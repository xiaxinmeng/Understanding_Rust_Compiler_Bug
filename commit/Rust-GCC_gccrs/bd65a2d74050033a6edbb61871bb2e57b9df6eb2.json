{"sha": "bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ2NWEyZDc0MDUwMDMzYTZlZGJiNjE4NzFiYjJlNTdiOWRmNmViMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T09:17:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T09:17:46Z"}, "message": "[multiple changes]\n\n2011-08-02  Yannick Moy  <moy@adacore.com>\n\n\t* errout.adb, errout.ads (Check_Formal_Restriction): move procedure\n\tfrom here...\n\t* restrict.adb, restrict.ads (Check_Formal_Restriction): ...to here\n\t* sem_aggr.adb, sem_ch5.adb, sem_util.adb:\n\tAdd with/use clauses to make Check_Formal_Restriction visible\n\n2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Check_Generic_Actuals): handle properly actual\n\tin-parameters when type of the generic formal is private in the generic\n\tspec and non-private in the body.\n\n2011-08-02  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.adb, a-cfdlli.ads, a-cfhase.adb, a-cfhase.ads, a-cfhama.adb,\n\ta-cfhama.ads, a-cforse.adb, a-cforse.ads, a-cforma.adb, a-cforma.ads,\n\ta-cofove.adb, a-cofove.ads: New files implementing formal containers.\n\t* impunit.adb, Makefile.rtl: Take new files into account.\n\nFrom-SVN: r177102", "tree": {"sha": "e10f4754a39287ad20096cfb93f40edf8cf10f77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e10f4754a39287ad20096cfb93f40edf8cf10f77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/comments", "author": null, "committer": null, "parents": [{"sha": "d4487611a99773fb4022999be28e0f1cf163f838", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4487611a99773fb4022999be28e0f1cf163f838", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4487611a99773fb4022999be28e0f1cf163f838"}], "stats": {"total": 15192, "additions": 15152, "deletions": 40}, "files": [{"sha": "b50d02af14317230de4c43d3d76b62652023a19c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -1,7 +1,23 @@\n-2011-08-02  Vincent Celier  <celier@adacore.com>\n+2011-08-02  Yannick Moy  <moy@adacore.com>\n+\n+\t* errout.adb, errout.ads (Check_Formal_Restriction): move procedure\n+\tfrom here...\n+\t* restrict.adb, restrict.ads (Check_Formal_Restriction): ...to here\n+\t* sem_aggr.adb, sem_ch5.adb, sem_util.adb:\n+\tAdd with/use clauses to make Check_Formal_Restriction visible\n+\n+2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Check_Generic_Actuals): handle properly actual\n+\tin-parameters when type of the generic formal is private in the generic\n+\tspec and non-private in the body.\n+\n+2011-08-02  Claire Dross  <dross@adacore.com>\n \n-\t* prj-nmsc.adb (Check_Library_Attributes): For virtual library project,\n-\tinherit library kind.\n+\t* a-cfdlli.adb, a-cfdlli.ads, a-cfhase.adb, a-cfhase.ads, a-cfhama.adb,\n+\ta-cfhama.ads, a-cforse.adb, a-cforse.ads, a-cforma.adb, a-cforma.ads,\n+\ta-cofove.adb, a-cofove.ads: New files implementing formal containers.\n+\t* impunit.adb, Makefile.rtl: Take new files into account.\n \n 2011-08-02  Robert Dewar  <dewar@adacore.com>\n "}, {"sha": "3617bea7b7774a58d17d83b352ff847bbacb7d27", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -92,6 +92,11 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-cbdlli$(objext) \\\n   a-cborma$(objext) \\\n   a-cdlili$(objext) \\\n+  a-cfhama$(objext) \\\n+  a-cfhase$(objext) \\\n+  a-cforse$(objext) \\\n+  a-cfdlli$(objext) \\\n+  a-cforma$(objext) \\\n   a-cgaaso$(objext) \\\n   a-cgarso$(objext) \\\n   a-cgcaso$(objext) \\\n@@ -123,6 +128,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-contai$(objext) \\\n   a-convec$(objext) \\\n   a-cobove$(objext) \\\n+  a-cofove$(objext) \\\n   a-coorma$(objext) \\\n   a-coormu$(objext) \\\n   a-coorse$(objext) \\"}, {"sha": "4f70f8174f6214b131c13864b8e88c6ae51af142", "filename": "gcc/ada/a-cfdlli.adb", "status": "added", "additions": 2291, "deletions": 0, "changes": 2291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,2291 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                 ADA.CONTAINERS.FORMAL_DOUBLY_LINKED_LISTS                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Formal_Doubly_Linked_Lists is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      New_Node  : out Count_Type);\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Node  : out Count_Type);\n+\n+   function Copy\n+     (Source   : Plain_List;\n+      Capacity : Count_Type := 0) return PList_Access;\n+\n+   function Find_Between\n+     (Container : Plain_List;\n+      Item      : Element_Type;\n+      From      : Count_Type;\n+      To        : Count_Type;\n+      Bg        : Count_Type) return Cursor;\n+\n+   function Element_Unchecked\n+     (Container : List;\n+      Position  : Count_Type) return Element_Type;\n+\n+   procedure Free\n+     (Container : in out Plain_List;\n+      X         : Count_Type);\n+\n+   function Has_Element_Base\n+     (Container : Plain_List;\n+      Position  : Cursor) return Boolean;\n+\n+   procedure Insert_Internal\n+     (Container : in out List;\n+      Before    : Count_Type;\n+      New_Node  : Count_Type);\n+\n+   procedure Iterate_Between\n+     (Container : List;\n+      From      : Count_Type;\n+      To        : Count_Type;\n+      Process   :\n+        not null access procedure (Container : List; Position : Cursor));\n+\n+   function Next_Unchecked\n+     (Container : List;\n+      Position  : Count_Type) return Count_Type;\n+\n+   procedure Query_Element_Plain\n+     (Container : Plain_List; Position : Cursor;\n+      Process   : not null access procedure (Element : Element_Type));\n+\n+   function Reverse_Find_Between\n+     (Container : Plain_List;\n+      Item      : Element_Type;\n+      From      : Count_Type;\n+      To        : Count_Type) return Cursor;\n+\n+   procedure Reverse_Iterate_Between\n+     (Container : List;\n+      From      : Count_Type;\n+      To        : Count_Type;\n+      Process   :\n+        not null access procedure (Container : List; Position : Cursor));\n+\n+   function Vet (L : List; Position : Cursor) return Boolean;\n+\n+   procedure Write_Between\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Plain_List;\n+      Length : Count_Type;\n+      From   : Count_Type;\n+      To     : Count_Type);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : List) return Boolean is\n+      LI, RI : Count_Type;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Left.Length /= Right.Length then\n+         return False;\n+      end if;\n+\n+      LI := Left.First;\n+      RI := Right.First;\n+      while LI /= 0 loop\n+         if Element_Unchecked (Left, LI) /= Element_Unchecked (Right, LI) then\n+            return False;\n+         end if;\n+\n+         LI := Next_Unchecked (Left, LI);\n+         RI := Next_Unchecked (Right, RI);\n+      end loop;\n+\n+      return True;\n+   end \"=\";\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      New_Node  : out Count_Type)\n+   is\n+      ContainerP : Plain_List renames Container.Plain.all;\n+   begin\n+      if Container.K /= Plain then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+         N : Node_Array renames Container.Plain.all.Nodes;\n+\n+      begin\n+         if ContainerP.Free >= 0 then\n+            New_Node := ContainerP.Free;\n+            N (New_Node).Element := New_Item;\n+            ContainerP.Free := N (New_Node).Next;\n+\n+         else\n+            New_Node := abs ContainerP.Free;\n+            N (New_Node).Element := New_Item;\n+            ContainerP.Free := ContainerP.Free - 1;\n+         end if;\n+      end;\n+   end Allocate;\n+\n+   procedure Allocate\n+     (Container : in out List;\n+      New_Node  : out Count_Type)\n+   is\n+      ContainerP : Plain_List renames Container.Plain.all;\n+   begin\n+      if Container.K /= Plain then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+         N : Node_Array renames ContainerP.Nodes;\n+\n+      begin\n+         if ContainerP.Free >= 0 then\n+            New_Node := ContainerP.Free;\n+            ContainerP.Free := N (New_Node).Next;\n+\n+         else\n+            New_Node := abs ContainerP.Free;\n+            ContainerP.Free := ContainerP.Free - 1;\n+         end if;\n+      end;\n+   end Allocate;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container, No_Element, New_Item, Count);\n+   end Append;\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out List; Source : List) is\n+   begin\n+      if Target.K /= Plain or Source.K /= Plain then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+         N : Node_Array renames Source.Plain.Nodes;\n+         J : Count_Type;\n+\n+      begin\n+         if Target'Address = Source'Address then\n+            return;\n+         end if;\n+\n+         if Target.Capacity < Source.Length then\n+            raise Constraint_Error with  -- ???\n+              \"Source length exceeds Target capacity\";\n+         end if;\n+\n+         Clear (Target);\n+\n+         J := Source.First;\n+         while J /= 0 loop\n+            Append (Target, N (J).Element);\n+            J := N (J).Next;\n+         end loop;\n+      end;\n+   end Assign;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out List) is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         N : Node_Array renames Container.Plain.Nodes;\n+         X : Count_Type;\n+\n+      begin\n+         if Container.Length = 0 then\n+            pragma Assert (Container.First = 0);\n+            pragma Assert (Container.Last = 0);\n+            pragma Assert (Container.Plain.Busy = 0);\n+            pragma Assert (Container.Plain.Lock = 0);\n+            return;\n+         end if;\n+\n+         pragma Assert (Container.First >= 1);\n+         pragma Assert (Container.Last >= 1);\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         if Container.Plain.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (list is busy)\";\n+         end if;\n+\n+         while Container.Length > 1 loop\n+            X := Container.First;\n+\n+            Container.First := N (X).Next;\n+            N (Container.First).Prev := 0;\n+\n+            Container.Length := Container.Length - 1;\n+\n+            Free (Container.Plain.all, X);\n+         end loop;\n+\n+         X := Container.First;\n+\n+         Container.First := 0;\n+         Container.Last := 0;\n+         Container.Length := 0;\n+\n+         Free (Container.Plain.all, X);\n+      end;\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean\n+   is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy\n+     (Source   : Plain_List;\n+      Capacity : Count_Type := 0) return PList_Access\n+   is\n+      C : constant Count_Type := Count_Type'Max (Source.Capacity, Capacity);\n+      P : PList_Access;\n+      N : Count_Type := 1;\n+   begin\n+      P := new Plain_List (C);\n+      while N <= Source.Capacity loop\n+         P.Nodes (N).Prev := Source.Nodes (N).Prev;\n+         P.Nodes (N).Next := Source.Nodes (N).Next;\n+         P.Nodes (N).Element := Source.Nodes (N).Element;\n+         N := N + 1;\n+      end loop;\n+      P.Free := Source.Free;\n+      if P.Free >= 0 then\n+         N := Source.Capacity + 1;\n+         while N <= C loop\n+            Free (P.all, N);\n+            N := N + 1;\n+         end loop;\n+      end if;\n+      return P;\n+   end Copy;\n+\n+   function Copy\n+     (Source   : List;\n+      Capacity : Count_Type := 0) return List\n+   is\n+      Cap : constant Count_Type := Count_Type'Max (Source.Capacity, Capacity);\n+   begin\n+      case Source.K is\n+         when Plain =>\n+            return (Capacity => Cap,\n+                    Length   => Source.Length,\n+                    Plain    => Copy (Source.Plain.all, Cap),\n+                    First    => Source.First,\n+                    Last     => Source.Last,\n+                    others   => <>);\n+         when Part =>\n+            declare\n+               Target : List (Capacity => Cap);\n+               C      : Cursor;\n+               P      : Cursor;\n+            begin\n+               Target := (Capacity => Cap,\n+                          Length   => Source.Part.LLength,\n+                          Plain    => Copy (Source.Plain.all, Cap),\n+                          First    => Source.Part.LFirst,\n+                          Last     => Source.Part.LLast,\n+                          others   => <>);\n+               C := (Node => Target.First);\n+               while C.Node /= Source.First loop\n+                  P := Next (Target, C);\n+                  Delete (Container => Target, Position => C);\n+                  C := P;\n+               end loop;\n+               if Source.Last /= 0 then\n+                  C := (Node => Source.Plain.all.Nodes (Source.Last).Next);\n+                  while C.Node /= 0 loop\n+                     P := Next (Target, C);\n+                     Delete (Container => Target, Position => C);\n+                     C := P;\n+                  end loop;\n+               end if;\n+               return Target;\n+            end;\n+      end case;\n+   end Copy;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+         N : Node_Array renames Container.Plain.Nodes;\n+         X : Count_Type;\n+\n+      begin\n+         if not Has_Element (Container => Container,\n+                             Position  => Position) then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+\n+         pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n+         pragma Assert (Container.First >= 1);\n+         pragma Assert (Container.Last >= 1);\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         if Position.Node = Container.First then\n+            Delete_First (Container, Count);\n+            Position := No_Element;\n+            return;\n+         end if;\n+\n+         if Count = 0 then\n+            Position := No_Element;\n+            return;\n+         end if;\n+\n+         if Container.Plain.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (list is busy)\";\n+         end if;\n+\n+         for Index in 1 .. Count loop\n+            pragma Assert (Container.Length >= 2);\n+\n+            X := Position.Node;\n+            Container.Length := Container.Length - 1;\n+\n+            if X = Container.Last then\n+               Position := No_Element;\n+\n+               Container.Last := N (X).Prev;\n+               N (Container.Last).Next := 0;\n+\n+               Free (Container.Plain.all, X);\n+               return;\n+            end if;\n+\n+            Position.Node := N (X).Next;\n+            pragma Assert (N (Position.Node).Prev >= 0);\n+\n+            N (N (X).Next).Prev := N (X).Prev;\n+            N (N (X).Prev).Next := N (X).Next;\n+\n+            Free (Container.Plain.all, X);\n+         end loop;\n+         Position := No_Element;\n+      end;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First\n+     (Container : in out List;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+         N : Node_Array renames Container.Plain.Nodes;\n+         X : Count_Type;\n+\n+      begin\n+         if Count >= Container.Length then\n+            Clear (Container);\n+            return;\n+         end if;\n+\n+         if Count = 0 then\n+            return;\n+         end if;\n+\n+         if Container.Plain.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (list is busy)\";\n+         end if;\n+\n+         for I in 1 .. Count loop\n+            X := Container.First;\n+            pragma Assert (N (N (X).Next).Prev = Container.First);\n+\n+            Container.First := N (X).Next;\n+            N (Container.First).Prev := 0;\n+\n+            Container.Length := Container.Length - 1;\n+\n+            Free (Container.Plain.all, X);\n+         end loop;\n+      end;\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last\n+     (Container : in out List;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+         N : Node_Array renames Container.Plain.Nodes;\n+         X : Count_Type;\n+\n+      begin\n+         if Count >= Container.Length then\n+            Clear (Container);\n+            return;\n+         end if;\n+\n+         if Count = 0 then\n+            return;\n+         end if;\n+\n+         if Container.Plain.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (list is busy)\";\n+         end if;\n+\n+         for I in 1 .. Count loop\n+            X := Container.Last;\n+            pragma Assert (N (N (X).Prev).Next = Container.Last);\n+\n+            Container.Last := N (X).Prev;\n+            N (Container.Last).Next := 0;\n+\n+            Container.Length := Container.Length - 1;\n+\n+            Free (Container.Plain.all, X);\n+         end loop;\n+      end;\n+   end Delete_Last;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element_Unchecked\n+     (Container : List;\n+      Position  : Count_Type) return Element_Type is\n+   begin\n+      case Container.K is\n+         when Plain =>\n+            return Container.Plain.Nodes (Position).Element;\n+         when others =>\n+            return Container.Plain.all.Nodes (Position).Element;\n+      end case;\n+   end Element_Unchecked;\n+\n+   function Element\n+     (Container : List;\n+      Position  : Cursor) return Element_Type is\n+   begin\n+      if not Has_Element (Container => Container, Position  => Position) then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      return Element_Unchecked (Container => Container,\n+                                Position  => Position.Node);\n+   end Element;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find_Between\n+     (Container : Plain_List;\n+      Item      : Element_Type;\n+      From      : Count_Type;\n+      To        : Count_Type;\n+      Bg        : Count_Type) return Cursor\n+   is\n+      Nodes : Node_Array renames Container.Nodes;\n+      Node  : Count_Type := Bg;\n+   begin\n+      while Node /= From loop\n+         if Node = 0 or else Node = To then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+         Node := Nodes (Node).Next;\n+      end loop;\n+      while Node /= Nodes (To).Next loop\n+         if Nodes (Node).Element = Item then\n+            return (Node => Node);\n+         end if;\n+         Node := Nodes (Node).Next;\n+      end loop;\n+\n+      return No_Element;\n+   end Find_Between;\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      From : Count_Type := Position.Node;\n+   begin\n+      if From = 0 and Container.Length = 0 then\n+         return No_Element;\n+      end if;\n+      if From = 0 then\n+         From := Container.First;\n+      end if;\n+      if Position.Node /= 0 and then\n+        not Has_Element_Base (Container.Plain.all, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+      return Find_Between (Container => Container.Plain.all,\n+                           Item      => Item,\n+                           From      => From,\n+                           To        => Container.Last,\n+                           Bg        => Container.First);\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : List) return Cursor is\n+   begin\n+      if Container.First = 0 then\n+         return No_Element;\n+      end if;\n+      return (Node => Container.First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : List) return Element_Type is\n+      F : constant Count_Type := Container.First;\n+   begin\n+      if F = 0 then\n+         raise Constraint_Error with \"list is empty\";\n+      else\n+         return Element_Unchecked (Container, F);\n+      end if;\n+   end First_Element;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free\n+     (Container : in out Plain_List;\n+      X         : Count_Type)\n+   is\n+      pragma Assert (X > 0);\n+      pragma Assert (X <= Container.Capacity);\n+\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      N (X).Prev := -1;  -- Node is deallocated (not on active list)\n+\n+      if Container.Free >= 0 then\n+         N (X).Next := Container.Free;\n+         Container.Free := X;\n+\n+      elsif X + 1 = abs Container.Free then\n+         N (X).Next := 0;  -- Not strictly necessary, but marginally safer\n+         Container.Free := Container.Free + 1;\n+\n+      else\n+         Container.Free := abs Container.Free;\n+\n+         if Container.Free > Container.Capacity then\n+            Container.Free := 0;\n+\n+         else\n+            for I in Container.Free .. Container.Capacity - 1 loop\n+               N (I).Next := I + 1;\n+            end loop;\n+\n+            N (Container.Capacity).Next := 0;\n+         end if;\n+\n+         N (X).Next := Container.Free;\n+         Container.Free := X;\n+      end if;\n+   end Free;\n+\n+   ---------------------\n+   -- Generic_Sorting --\n+   ---------------------\n+\n+   package body Generic_Sorting is\n+\n+      ---------------\n+      -- Is_Sorted --\n+      ---------------\n+\n+      function Is_Sorted (Container : List) return Boolean is\n+         Nodes : Node_Array renames Container.Plain.all.Nodes;\n+         Node  : Count_Type := Container.First;\n+      begin\n+         for I in 2 .. Container.Length loop\n+            if Nodes (Nodes (Node).Next).Element < Nodes (Node).Element then\n+               return False;\n+            end if;\n+\n+            Node := Nodes (Node).Next;\n+         end loop;\n+\n+         return True;\n+      end Is_Sorted;\n+\n+      -----------\n+      -- Merge --\n+      -----------\n+\n+      procedure Merge\n+        (Target : in out List;\n+         Source : in out List)\n+      is\n+      begin\n+         if Target.K /= Plain or Source.K /= Plain then\n+            raise Program_Error with \"cannot modify part of container\";\n+         end if;\n+\n+         declare\n+            LN : Node_Array renames Target.Plain.Nodes;\n+            RN : Node_Array renames Source.Plain.Nodes;\n+            LI : Cursor;\n+            RI : Cursor;\n+\n+         begin\n+            if Target'Address = Source'Address then\n+               return;\n+            end if;\n+\n+            if Target.Plain.Busy > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with cursors of Target (list is busy)\";\n+            end if;\n+\n+            if Source.Plain.Busy > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with cursors of Source (list is busy)\";\n+            end if;\n+\n+            LI := First (Target);\n+            RI := First (Source);\n+            while RI.Node /= 0 loop\n+               pragma Assert (RN (RI.Node).Next = 0\n+                 or else not (RN (RN (RI.Node).Next).Element <\n+                     RN (RI.Node).Element));\n+\n+               if LI.Node = 0 then\n+                  Splice (Target, No_Element, Source);\n+                  return;\n+               end if;\n+\n+               pragma Assert (LN (LI.Node).Next = 0\n+                 or else not (LN (LN (LI.Node).Next).Element <\n+                     LN (LI.Node).Element));\n+\n+               if RN (RI.Node).Element < LN (LI.Node).Element then\n+                  declare\n+                     RJ : Cursor := RI;\n+                     pragma Warnings (Off, RJ);\n+                  begin\n+                     RI.Node := RN (RI.Node).Next;\n+                     Splice (Target, LI, Source, RJ);\n+                  end;\n+\n+               else\n+                  LI.Node := LN (LI.Node).Next;\n+               end if;\n+            end loop;\n+         end;\n+      end Merge;\n+\n+      ----------\n+      -- Sort --\n+      ----------\n+\n+      procedure Sort (Container : in out List) is\n+      begin\n+         if Container.K /= Plain then\n+            raise Program_Error with \"cannot modify part of container\";\n+         end if;\n+\n+         declare\n+            N : Node_Array renames Container.Plain.Nodes;\n+\n+            procedure Partition (Pivot, Back : Count_Type);\n+            procedure Sort (Front, Back : Count_Type);\n+\n+            ---------------\n+            -- Partition --\n+            ---------------\n+\n+            procedure Partition (Pivot, Back : Count_Type) is\n+               Node : Count_Type := N (Pivot).Next;\n+\n+            begin\n+               while Node /= Back loop\n+                  if N (Node).Element < N (Pivot).Element then\n+                     declare\n+                        Prev : constant Count_Type := N (Node).Prev;\n+                        Next : constant Count_Type := N (Node).Next;\n+\n+                     begin\n+                        N (Prev).Next := Next;\n+\n+                        if Next = 0 then\n+                           Container.Last := Prev;\n+                        else\n+                           N (Next).Prev := Prev;\n+                        end if;\n+\n+                        N (Node).Next := Pivot;\n+                        N (Node).Prev := N (Pivot).Prev;\n+\n+                        N (Pivot).Prev := Node;\n+\n+                        if N (Node).Prev = 0 then\n+                           Container.First := Node;\n+                        else\n+                           N (N (Node).Prev).Next := Node;\n+                        end if;\n+\n+                        Node := Next;\n+                     end;\n+\n+                  else\n+                     Node := N (Node).Next;\n+                  end if;\n+               end loop;\n+            end Partition;\n+\n+            ----------\n+            -- Sort --\n+            ----------\n+\n+            procedure Sort (Front, Back : Count_Type) is\n+               Pivot : Count_Type;\n+\n+            begin\n+               if Front = 0 then\n+                  Pivot := Container.First;\n+               else\n+                  Pivot := N (Front).Next;\n+               end if;\n+\n+               if Pivot /= Back then\n+                  Partition (Pivot, Back);\n+                  Sort (Front, Pivot);\n+                  Sort (Pivot, Back);\n+               end if;\n+            end Sort;\n+\n+            --  Start of processing for Sort\n+\n+         begin\n+            if Container.Length <= 1 then\n+               return;\n+            end if;\n+\n+            pragma Assert (N (Container.First).Prev = 0);\n+            pragma Assert (N (Container.Last).Next = 0);\n+\n+            if Container.Plain.Busy > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with elements (list is busy)\";\n+            end if;\n+\n+            Sort (Front => 0, Back => 0);\n+\n+            pragma Assert (N (Container.First).Prev = 0);\n+            pragma Assert (N (Container.Last).Next = 0);\n+         end;\n+      end Sort;\n+\n+   end Generic_Sorting;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element_Base (Container : Plain_List; Position : Cursor)\n+                              return Boolean\n+   is\n+   begin\n+      return Container.Nodes (Position.Node).Prev /= -1;\n+   end Has_Element_Base;\n+\n+   function Has_Element (Container : List; Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 then\n+         return False;\n+      end if;\n+\n+      case Container.K is\n+         when Plain =>\n+            return Container.Plain.Nodes (Position.Node).Prev /= -1;\n+         when Part =>\n+            declare\n+               Current : Count_Type := Container.First;\n+            begin\n+               if Container.Plain.Nodes (Position.Node).Prev = -1 then\n+                  return False;\n+               end if;\n+               while Current /= 0 loop\n+                  if Current = Position.Node then\n+                     return True;\n+                  end if;\n+                  Current := Next_Unchecked (Container, Current);\n+               end loop;\n+               return False;\n+            end;\n+      end case;\n+   end Has_Element;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      J : Count_Type;\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      if Before.Node /= 0 then\n+         null;\n+         pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n+      end if;\n+\n+      if Count = 0 then\n+         Position := Before;\n+         return;\n+      end if;\n+\n+      if Container.Length > Container.Capacity - Count then\n+         raise Constraint_Error with \"new length exceeds capacity\";\n+      end if;\n+\n+      if Container.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n+      end if;\n+\n+      Allocate (Container, New_Item, New_Node => J);\n+      Insert_Internal (Container, Before.Node, New_Node => J);\n+      Position := (Node => J);\n+\n+      for Index in 2 .. Count loop\n+         Allocate (Container, New_Item, New_Node => J);\n+         Insert_Internal (Container, Before.Node, New_Node => J);\n+      end loop;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      Position : Cursor;\n+\n+   begin\n+      Insert (Container, Before, New_Item, Position, Count);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      J : Count_Type;\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      if Before.Node /= 0 then\n+         null;\n+         pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n+      end if;\n+\n+      if Count = 0 then\n+         Position := Before;\n+         return;\n+      end if;\n+\n+      if Container.Length > Container.Capacity - Count then\n+         raise Constraint_Error with \"new length exceeds capacity\";\n+      end if;\n+\n+      if Container.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n+      end if;\n+\n+      Allocate (Container, New_Node => J);\n+      Insert_Internal (Container, Before.Node, New_Node => J);\n+      Position := (Node => J);\n+\n+      for Index in 2 .. Count loop\n+         Allocate (Container, New_Node => J);\n+         Insert_Internal (Container, Before.Node, New_Node => J);\n+      end loop;\n+   end Insert;\n+\n+   ---------------------\n+   -- Insert_Internal --\n+   ---------------------\n+\n+   procedure Insert_Internal\n+     (Container : in out List;\n+      Before    : Count_Type;\n+      New_Node  : Count_Type)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+         N : Node_Array renames Container.Plain.Nodes;\n+\n+      begin\n+         if Container.Length = 0 then\n+            pragma Assert (Before = 0);\n+            pragma Assert (Container.First = 0);\n+            pragma Assert (Container.Last = 0);\n+\n+            Container.First := New_Node;\n+            Container.Last := New_Node;\n+\n+            N (Container.First).Prev := 0;\n+            N (Container.Last).Next := 0;\n+\n+         elsif Before = 0 then\n+            pragma Assert (N (Container.Last).Next = 0);\n+\n+            N (Container.Last).Next := New_Node;\n+            N (New_Node).Prev := Container.Last;\n+\n+            Container.Last := New_Node;\n+            N (Container.Last).Next := 0;\n+\n+         elsif Before = Container.First then\n+            pragma Assert (N (Container.First).Prev = 0);\n+\n+            N (Container.First).Prev := New_Node;\n+            N (New_Node).Next := Container.First;\n+\n+            Container.First := New_Node;\n+            N (Container.First).Prev := 0;\n+\n+         else\n+            pragma Assert (N (Container.First).Prev = 0);\n+            pragma Assert (N (Container.Last).Next = 0);\n+\n+            N (New_Node).Next := Before;\n+            N (New_Node).Prev := N (Before).Prev;\n+\n+            N (N (Before).Prev).Next := New_Node;\n+            N (Before).Prev := New_Node;\n+         end if;\n+\n+         Container.Length := Container.Length + 1;\n+      end;\n+   end Insert_Internal;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : List) return Boolean is\n+   begin\n+      return Length (Container) = 0;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate_Between\n+     (Container : List;\n+      From      : Count_Type;\n+      To        : Count_Type;\n+      Process   :\n+        not null access procedure (Container : List; Position : Cursor))\n+   is\n+      C : Plain_List renames Container.Plain.all;\n+      N : Node_Array renames C.Nodes;\n+      B : Natural renames C.Busy;\n+\n+      Node : Count_Type := From;\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         while Node /= N (To).Next loop\n+            pragma Assert (N (Node).Prev >= 0);\n+            Process (Container, Position => (Node => Node));\n+            Node := N (Node).Next;\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate_Between;\n+\n+   procedure Iterate\n+     (Container : List;\n+      Process   :\n+        not null access procedure (Container : List; Position : Cursor))\n+   is\n+   begin\n+      if Container.Length = 0 then\n+         return;\n+      end if;\n+      Iterate_Between (Container, Container.First, Container.Last, Process);\n+   end Iterate;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : List) return Cursor is\n+   begin\n+      if Container.Last = 0 then\n+         return No_Element;\n+      end if;\n+      return (Node => Container.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : List) return Element_Type is\n+      L : constant Count_Type := Container.Last;\n+   begin\n+      if L = 0 then\n+         raise Constraint_Error with \"list is empty\";\n+      else\n+         return Element_Unchecked (Container, L);\n+      end if;\n+   end Last_Element;\n+\n+   ----------\n+   -- Left --\n+   ----------\n+\n+   function Left (Container : List; Position : Cursor) return List is\n+      L   : Count_Type := 0;\n+      C   : Count_Type := Container.First;\n+      LLe : Count_Type;\n+      LF  : Count_Type;\n+      LLa : Count_Type;\n+   begin\n+      case Container.K is\n+         when Plain =>\n+            LLe := Container.Length;\n+            LF := Container.First;\n+            LLa := Container.Last;\n+         when Part =>\n+            LLe := Container.Part.LLength;\n+            LF := Container.Part.LFirst;\n+            LLa := Container.Part.LLast;\n+      end case;\n+      if Position.Node = 0 then\n+         return (Capacity => Container.Capacity,\n+                 K        => Part,\n+                 Length   => Container.Length,\n+                 First    => Container.First,\n+                 Last     => Container.Last,\n+                 Plain    => Container.Plain,\n+                 Part     => (LLength => LLe, LFirst => LF, LLast => LLa));\n+      else\n+         while C /= Position.Node loop\n+            if C = Container.Last or C = 0 then\n+               raise Constraint_Error with\n+                 \"Position cursor has no element\";\n+            end if;\n+            C := Next_Unchecked (Container, C);\n+            L := L + 1;\n+         end loop;\n+         if L = 0 then\n+            return (Capacity => Container.Capacity,\n+                    K        => Part,\n+                    Length   => 0,\n+                    First    => 0,\n+                    Last     => 0,\n+                    Plain    => Container.Plain,\n+                    Part     => (LLength => LLe, LFirst => LF, LLast => LLa));\n+         else\n+            return (Capacity => Container.Capacity,\n+                    K        => Part,\n+                    Length   => L,\n+                    First    => Container.First,\n+                    Last     => Container.Plain.Nodes (C).Prev,\n+                    Plain    => Container.Plain,\n+                    Part     => (LLength => LLe, LFirst => LF, LLast => LLa));\n+         end if;\n+      end if;\n+   end Left;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : List) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Target : in out List;\n+      Source : in out List)\n+   is\n+   begin\n+      if Target.K /= Plain or Source.K /= Plain  then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+\n+         N : Node_Array renames Source.Plain.Nodes;\n+         X : Count_Type;\n+\n+      begin\n+         if Target'Address = Source'Address then\n+            return;\n+         end if;\n+\n+         if Target.Capacity < Source.Length then\n+            raise Constraint_Error with  -- ???\n+              \"Source length exceeds Target capacity\";\n+         end if;\n+\n+         if Source.Plain.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors of Source (list is busy)\";\n+         end if;\n+\n+         Clear (Target);\n+\n+         while Source.Length > 0 loop\n+            X := Source.First;\n+            Append (Target, N (X).Element);  -- optimize away???\n+\n+            Source.First := N (X).Next;\n+            N (Source.First).Prev := 0;\n+\n+            Source.Length := Source.Length - 1;\n+            Free (Source.Plain.all, X);\n+         end loop;\n+      end;\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Container : List; Position : in out Cursor) is\n+   begin\n+      Position := Next (Container, Position);\n+   end Next;\n+\n+   function Next (Container : List; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+      if not Has_Element (Container, Position) then\n+         raise Program_Error with \"Position cursor has no element\";\n+      end if;\n+      return (Node => Next_Unchecked (Container, Position.Node));\n+   end Next;\n+\n+   function Next_Unchecked (Container : List; Position : Count_Type)\n+                            return Count_Type\n+   is\n+   begin\n+      case Container.K is\n+         when Plain =>\n+            return Container.Plain.Nodes (Position).Next;\n+         when Part =>\n+            if Position = Container.Last then\n+               return 0;\n+            else\n+               return Container.Plain.Nodes (Position).Next;\n+            end if;\n+      end case;\n+   end Next_Unchecked;\n+\n+   -------------\n+   -- Prepend --\n+   -------------\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container, First (Container), New_Item, Count);\n+   end Prepend;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   procedure Previous (Container : List; Position : in out Cursor) is\n+   begin\n+      Position := Previous (Container, Position);\n+   end Previous;\n+\n+   function Previous (Container : List; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Program_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      case Container.K is\n+         when Plain =>\n+            return (Node => Container.Plain.Nodes (Position.Node).Prev);\n+         when Part =>\n+            if Container.First = Position.Node then\n+               return No_Element;\n+            else\n+               return (Node => Container.Plain.Nodes (Position.Node).Prev);\n+            end if;\n+      end case;\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element_Plain\n+     (Container : Plain_List; Position : Cursor;\n+      Process   : not null access procedure (Element : Element_Type))\n+   is\n+      C : Plain_List renames Container'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+      L : Natural renames C.Lock;\n+\n+   begin\n+      B := B + 1;\n+      L := L + 1;\n+\n+      declare\n+         N : Node_Type renames C.Nodes (Position.Node);\n+      begin\n+         Process (N.Element);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n+   end Query_Element_Plain;\n+\n+   procedure Query_Element\n+     (Container : List; Position : Cursor;\n+      Process   : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+      Query_Element_Plain (Container.Plain.all, Position, Process);\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out List)\n+   is\n+      N : Count_Type'Base;\n+\n+   begin\n+      Clear (Item);\n+\n+      Count_Type'Base'Read (Stream, N);\n+\n+      if N < 0 then\n+         raise Program_Error with \"bad list length\";\n+      end if;\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      if N > Item.Capacity then\n+         raise Constraint_Error with \"length exceeds capacity\";\n+      end if;\n+\n+      for J in 1 .. N loop\n+         Item.Append (Element_Type'Input (Stream));  -- ???\n+      end loop;\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream list cursor\";\n+   end Read;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Container.K /= Plain  then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Container.Plain.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is locked)\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position),\n+                     \"bad cursor in Replace_Element\");\n+\n+      declare\n+         N : Node_Array renames Container.Plain.Nodes;\n+      begin\n+         N (Position.Node).Element := New_Item;\n+      end;\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reverse_Elements --\n+   ----------------------\n+\n+   procedure Reverse_Elements (Container : in out List) is\n+   begin\n+      if Container.K /= Plain  then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+         N : Node_Array renames Container.Plain.Nodes;\n+         I : Count_Type := Container.First;\n+         J : Count_Type := Container.Last;\n+\n+         procedure Swap (L, R : Count_Type);\n+\n+         ----------\n+         -- Swap --\n+         ----------\n+\n+         procedure Swap (L, R : Count_Type) is\n+            LN : constant Count_Type := N (L).Next;\n+            LP : constant Count_Type := N (L).Prev;\n+\n+            RN : constant Count_Type := N (R).Next;\n+            RP : constant Count_Type := N (R).Prev;\n+\n+         begin\n+            if LP /= 0 then\n+               N (LP).Next := R;\n+            end if;\n+\n+            if RN /= 0 then\n+               N (RN).Prev := L;\n+            end if;\n+\n+            N (L).Next := RN;\n+            N (R).Prev := LP;\n+\n+            if LN = R then\n+               pragma Assert (RP = L);\n+\n+               N (L).Prev := R;\n+               N (R).Next := L;\n+\n+            else\n+               N (L).Prev := RP;\n+               N (RP).Next := L;\n+\n+               N (R).Next := LN;\n+               N (LN).Prev := R;\n+            end if;\n+         end Swap;\n+\n+         --  Start of processing for Reverse_Elements\n+\n+      begin\n+         if Container.Length <= 1 then\n+            return;\n+         end if;\n+\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         if Container.Plain.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (list is busy)\";\n+         end if;\n+\n+         Container.First := J;\n+         Container.Last := I;\n+         loop\n+            Swap (L => I, R => J);\n+\n+            J := N (J).Next;\n+            exit when I = J;\n+\n+            I := N (I).Prev;\n+            exit when I = J;\n+\n+            Swap (L => J, R => I);\n+\n+            I := N (I).Next;\n+            exit when I = J;\n+\n+            J := N (J).Prev;\n+            exit when I = J;\n+         end loop;\n+\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+      end;\n+   end Reverse_Elements;\n+\n+   ------------------\n+   -- Reverse_Find --\n+   ------------------\n+\n+   function Reverse_Find_Between\n+     (Container : Plain_List;\n+      Item      : Element_Type;\n+      From      : Count_Type;\n+      To        : Count_Type) return Cursor\n+   is\n+      Nodes : Node_Array renames Container.Nodes;\n+      Node  : Count_Type := To;\n+   begin\n+      while Node /= Nodes (From).Prev loop\n+         if Nodes (Node).Element = Item then\n+            return (Node => Node);\n+         end if;\n+         Node := Nodes (Node).Prev;\n+      end loop;\n+\n+      return No_Element;\n+   end Reverse_Find_Between;\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      CFirst : Count_Type := Position.Node;\n+   begin\n+      if CFirst = 0 then\n+         CFirst := Container.First;\n+      end if;\n+\n+      if Container.Length = 0 then\n+         return No_Element;\n+      end if;\n+      return Reverse_Find_Between (Container => Container.Plain.all,\n+                                   Item      => Item,\n+                                   From      => CFirst,\n+                                   To        => Container.Last);\n+   end Reverse_Find;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate_Between\n+     (Container : List;\n+      From      : Count_Type;\n+      To        : Count_Type;\n+      Process   :\n+        not null access procedure (Container : List; Position : Cursor))\n+   is\n+      C : Plain_List renames Container.Plain.all;\n+      N : Node_Array renames C.Nodes;\n+      B : Natural renames C.Busy;\n+\n+      Node : Count_Type := To;\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         while Node /= N (From).Prev loop\n+            pragma Assert (N (Node).Prev >= 0);\n+            Process (Container, Position => (Node => Node));\n+            Node := N (Node).Prev;\n+         end loop;\n+\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Reverse_Iterate_Between;\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   :\n+        not null access procedure (Container : List; Position : Cursor))\n+   is\n+   begin\n+      if Container.Length = 0 then\n+         return;\n+      end if;\n+      Reverse_Iterate_Between\n+        (Container, Container.First, Container.Last, Process);\n+   end Reverse_Iterate;\n+\n+   -----------\n+   -- Right --\n+   -----------\n+\n+   function Right (Container : List; Position : Cursor) return List is\n+      L   : Count_Type := 0;\n+      C   : Count_Type := Container.First;\n+      LLe : Count_Type;\n+      LF  : Count_Type;\n+      LLa : Count_Type;\n+   begin\n+      case Container.K is\n+         when Plain =>\n+            LLe := Container.Length;\n+            LF := Container.First;\n+            LLa := Container.Last;\n+         when Part =>\n+            LLe := Container.Part.LLength;\n+            LF := Container.Part.LFirst;\n+            LLa := Container.Part.LLast;\n+      end case;\n+      if Position.Node = 0 then\n+         return (Capacity => Container.Capacity,\n+                 K        => Part,\n+                 Length   => 0,\n+                 First    => 0,\n+                 Last     => 0,\n+                 Plain    => Container.Plain,\n+                 Part     => (LLength => LLe, LFirst => LF, LLast => LLa));\n+      else\n+         while C /= Position.Node loop\n+            if C = Container.Last or C = 0 then\n+               raise Constraint_Error with\n+                 \"Position cursor has no element\";\n+            end if;\n+            C := Next_Unchecked (Container, C);\n+            L := L + 1;\n+         end loop;\n+         return (Capacity => Container.Capacity,\n+                 K        => Part,\n+                 Length   => Container.Length - L,\n+                 First    => Position.Node,\n+                 Last     => Container.Last,\n+                 Plain    => Container.Plain,\n+                 Part     => (LLength => LLe, LFirst => LF, LLast => LLa));\n+      end if;\n+   end Right;\n+\n+   ------------\n+   -- Splice --\n+   ------------\n+\n+   procedure Splice\n+     (Target : in out List;\n+      Before : Cursor;\n+      Source : in out List)\n+   is\n+   begin\n+      if Target.K /= Plain or Source.K /= Plain then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+         SN : Node_Array renames Source.Plain.Nodes;\n+\n+      begin\n+         if Before.Node /= 0 then\n+            null;\n+            pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n+         end if;\n+\n+         if Target'Address = Source'Address\n+           or else Source.Length = 0\n+         then\n+            return;\n+         end if;\n+\n+         pragma Assert (SN (Source.First).Prev = 0);\n+         pragma Assert (SN (Source.Last).Next = 0);\n+\n+         if Target.Length > Count_Type'Base'Last - Source.Length then\n+            raise Constraint_Error with \"new length exceeds maximum\";\n+         end if;\n+\n+         if Target.Length + Source.Length > Target.Capacity then\n+            raise Constraint_Error;\n+         end if;\n+\n+         if Target.Plain.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors of Target (list is busy)\";\n+         end if;\n+\n+         if Source.Plain.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors of Source (list is busy)\";\n+         end if;\n+\n+         loop\n+            Insert (Target, Before, SN (Source.Last).Element);\n+            Delete_Last (Source);\n+            exit when Is_Empty (Source);\n+         end loop;\n+      end;\n+   end Splice;\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Source   : in out List;\n+      Position : in out Cursor)\n+   is\n+      Target_Position : Cursor;\n+\n+   begin\n+      if Target.K /= Plain or Source.K /= Plain  then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         Splice (Target, Before, Position);\n+         return;\n+      end if;\n+\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Source, Position), \"bad Position cursor in Splice\");\n+\n+      if Target.Length >= Target.Capacity then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Target.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Target (list is busy)\";\n+      end if;\n+\n+      if Source.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Source (list is busy)\";\n+      end if;\n+\n+      Insert\n+        (Container => Target,\n+         Before    => Before,\n+         New_Item  => Source.Plain.Nodes (Position.Node).Element,\n+         Position  => Target_Position);\n+\n+      Delete (Source, Position);\n+      Position := Target_Position;\n+   end Splice;\n+\n+   procedure Splice\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : Cursor)\n+   is\n+   begin\n+      if Container.K /= Plain  then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+         N : Node_Array renames Container.Plain.Nodes;\n+\n+      begin\n+         if Before.Node /= 0 then\n+            null;\n+            pragma Assert (Vet (Container, Before),\n+                           \"bad Before cursor in Splice\");\n+         end if;\n+\n+         if Position.Node = 0 then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n+\n+         pragma Assert (Vet (Container, Position),\n+                        \"bad Position cursor in Splice\");\n+\n+         if Position.Node = Before.Node\n+           or else N (Position.Node).Next = Before.Node\n+         then\n+            return;\n+         end if;\n+\n+         pragma Assert (Container.Length >= 2);\n+\n+         if Container.Plain.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (list is busy)\";\n+         end if;\n+\n+         if Before.Node = 0 then\n+            pragma Assert (Position.Node /= Container.Last);\n+\n+            if Position.Node = Container.First then\n+               Container.First := N (Position.Node).Next;\n+               N (Container.First).Prev := 0;\n+\n+            else\n+               N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+               N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+            end if;\n+\n+            N (Container.Last).Next := Position.Node;\n+            N (Position.Node).Prev := Container.Last;\n+\n+            Container.Last := Position.Node;\n+            N (Container.Last).Next := 0;\n+\n+            return;\n+         end if;\n+\n+         if Before.Node = Container.First then\n+            pragma Assert (Position.Node /= Container.First);\n+\n+            if Position.Node = Container.Last then\n+               Container.Last := N (Position.Node).Prev;\n+               N (Container.Last).Next := 0;\n+\n+            else\n+               N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+               N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+            end if;\n+\n+            N (Container.First).Prev := Position.Node;\n+            N (Position.Node).Next := Container.First;\n+\n+            Container.First := Position.Node;\n+            N (Container.First).Prev := 0;\n+\n+            return;\n+         end if;\n+\n+         if Position.Node = Container.First then\n+            Container.First := N (Position.Node).Next;\n+            N (Container.First).Prev := 0;\n+\n+         elsif Position.Node = Container.Last then\n+            Container.Last := N (Position.Node).Prev;\n+            N (Container.Last).Next := 0;\n+\n+         else\n+            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+         end if;\n+\n+         N (N (Before.Node).Prev).Next := Position.Node;\n+         N (Position.Node).Prev := N (Before.Node).Prev;\n+\n+         N (Before.Node).Prev := Position.Node;\n+         N (Position.Node).Next := Before.Node;\n+\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+      end;\n+   end Splice;\n+\n+   ------------------\n+   -- Strict_Equal --\n+   ------------------\n+\n+   function Strict_Equal (Left, Right : List) return Boolean is\n+      CL : Count_Type := Left.First;\n+      CR : Count_Type := Right.First;\n+   begin\n+      while CL /= 0 or CR /= 0 loop\n+         if CL /= CR or else\n+           Element_Unchecked (Left, CL) /= Element_Unchecked (Right, CL) then\n+            return False;\n+         end if;\n+         CL := Next_Unchecked (Left, CL);\n+         CR := Next_Unchecked (Right, CR);\n+      end loop;\n+      return True;\n+   end Strict_Equal;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap\n+     (Container : in out List;\n+      I, J      : Cursor)\n+   is\n+   begin\n+      if Container.K /= Plain  then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      if I.Node = 0 then\n+         raise Constraint_Error with \"I cursor has no element\";\n+      end if;\n+\n+      if J.Node = 0 then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n+\n+      if Container.Plain.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is locked)\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, I), \"bad I cursor in Swap\");\n+      pragma Assert (Vet (Container, J), \"bad J cursor in Swap\");\n+\n+      declare\n+         NN : Node_Array renames Container.Plain.Nodes;\n+         NI : Node_Type renames NN (I.Node);\n+         NJ : Node_Type renames NN (J.Node);\n+\n+         EI_Copy : constant Element_Type := NI.Element;\n+\n+      begin\n+         NI.Element := NJ.Element;\n+         NJ.Element := EI_Copy;\n+      end;\n+   end Swap;\n+\n+   ----------------\n+   -- Swap_Links --\n+   ----------------\n+\n+   procedure Swap_Links\n+     (Container : in out List;\n+      I, J      : Cursor)\n+   is\n+      I_Next, J_Next : Cursor;\n+\n+   begin\n+      if Container.K /= Plain  then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      if I.Node = 0 then\n+         raise Constraint_Error with \"I cursor has no element\";\n+      end if;\n+\n+      if J.Node = 0 then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n+\n+      if Container.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, I), \"bad I cursor in Swap_Links\");\n+      pragma Assert (Vet (Container, J), \"bad J cursor in Swap_Links\");\n+\n+      I_Next := Next (Container, I);\n+\n+      if I_Next = J then\n+         Splice (Container, Before => I, Position => J);\n+\n+      else\n+         J_Next := Next (Container, J);\n+\n+         if J_Next = I then\n+            Splice (Container, Before => J, Position => I);\n+\n+         else\n+            pragma Assert (Container.Length >= 3);\n+            Splice (Container, Before => I_Next, Position => J);\n+            Splice (Container, Before => J_Next, Position => I);\n+         end if;\n+      end if;\n+   end Swap_Links;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type))\n+   is\n+   begin\n+      if Container.K /= Plain  then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position),\n+                     \"bad cursor in Update_Element\");\n+\n+      declare\n+         B : Natural renames Container.Plain.Busy;\n+         L : Natural renames Container.Plain.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         declare\n+            N : Node_Type renames Container.Plain.Nodes (Position.Node);\n+         begin\n+            Process (N.Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Update_Element;\n+\n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (L : List; Position : Cursor) return Boolean is\n+   begin\n+      if L.K /= Plain  then\n+         raise Program_Error with \"cannot modify part of container\";\n+      end if;\n+\n+      declare\n+         N : Node_Array renames L.Plain.Nodes;\n+\n+      begin\n+         if L.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if L.First = 0 then\n+            return False;\n+         end if;\n+\n+         if L.Last = 0 then\n+            return False;\n+         end if;\n+\n+         if Position.Node > L.Capacity then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Prev < 0\n+           or else N (Position.Node).Prev > L.Capacity\n+         then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Next > L.Capacity then\n+            return False;\n+         end if;\n+\n+         if N (L.First).Prev /= 0 then\n+            return False;\n+         end if;\n+\n+         if N (L.Last).Next /= 0 then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Prev = 0\n+           and then Position.Node /= L.First\n+         then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Next = 0\n+           and then Position.Node /= L.Last\n+         then\n+            return False;\n+         end if;\n+\n+         if L.Length = 1 then\n+            return L.First = L.Last;\n+         end if;\n+\n+         if L.First = L.Last then\n+            return False;\n+         end if;\n+\n+         if N (L.First).Next = 0 then\n+            return False;\n+         end if;\n+\n+         if N (L.Last).Prev = 0 then\n+            return False;\n+         end if;\n+\n+         if N (N (L.First).Next).Prev /= L.First then\n+            return False;\n+         end if;\n+\n+         if N (N (L.Last).Prev).Next /= L.Last then\n+            return False;\n+         end if;\n+\n+         if L.Length = 2 then\n+            if N (L.First).Next /= L.Last then\n+               return False;\n+            end if;\n+\n+            if N (L.Last).Prev /= L.First then\n+               return False;\n+            end if;\n+\n+            return True;\n+         end if;\n+\n+         if N (L.First).Next = L.Last then\n+            return False;\n+         end if;\n+\n+         if N (L.Last).Prev = L.First then\n+            return False;\n+         end if;\n+\n+         if Position.Node = L.First then\n+            return True;\n+         end if;\n+\n+         if Position.Node = L.Last then\n+            return True;\n+         end if;\n+\n+         if N (Position.Node).Next = 0 then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Prev = 0 then\n+            return False;\n+         end if;\n+\n+         if N (N (Position.Node).Next).Prev /= Position.Node then\n+            return False;\n+         end if;\n+\n+         if N (N (Position.Node).Prev).Next /= Position.Node then\n+            return False;\n+         end if;\n+\n+         if L.Length = 3 then\n+            if N (L.First).Next /= Position.Node then\n+               return False;\n+            end if;\n+\n+            if N (L.Last).Prev /= Position.Node then\n+               return False;\n+            end if;\n+         end if;\n+\n+         return True;\n+      end;\n+   end Vet;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write_Between\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Plain_List;\n+      Length : Count_Type;\n+      From   : Count_Type;\n+      To     : Count_Type) is\n+\n+      N    : Node_Array renames Item.Nodes;\n+      Node : Count_Type;\n+\n+   begin\n+      Count_Type'Base'Write (Stream, Length);\n+\n+      Node := From;\n+      while Node /= N (To).Next loop\n+         Element_Type'Write (Stream, N (Node).Element);\n+         Node := N (Node).Next;\n+      end loop;\n+   end Write_Between;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : List)\n+   is\n+   begin\n+      Write_Between\n+        (Stream, Item.Plain.all, Item.Length, Item.First, Item.Last);\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream list cursor\";\n+   end Write;\n+\n+end Ada.Containers.Formal_Doubly_Linked_Lists;"}, {"sha": "af64ea35f8b0fc145aba50b841c3feb145a6189a", "filename": "gcc/ada/a-cfdlli.ads", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,288 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                 ADA.CONTAINERS.FORMAL_DOUBLY_LINKED_LISTS                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Streams;\n+with Ada.Containers; use Ada.Containers;\n+\n+generic\n+   type Element_Type is private;\n+\n+   with function \"=\" (Left, Right : Element_Type)\n+                      return Boolean is <>;\n+\n+package Ada.Containers.Formal_Doubly_Linked_Lists is\n+   pragma Pure;\n+\n+   type List (Capacity : Count_Type) is tagged private;\n+   --  pragma Preelaborable_Initialization (List);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_List : constant List;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : List) return Boolean;\n+\n+   function Length (Container : List) return Count_Type;\n+\n+   function Is_Empty (Container : List) return Boolean;\n+\n+   procedure Clear (Container : in out List);\n+\n+   procedure Assign (Target : in out List; Source : List);\n+\n+   function Copy (Source : List; Capacity : Count_Type := 0) return List;\n+\n+   function Element (Container : List; Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Container : List; Position : Cursor;\n+      Process   : not null access procedure (Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Move (Target : in out List; Source : in out List);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_First\n+     (Container : in out List;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_Last\n+     (Container : in out List;\n+      Count     : Count_Type := 1);\n+\n+   procedure Reverse_Elements (Container : in out List);\n+\n+   procedure Swap\n+     (Container : in out List;\n+      I, J      : Cursor);\n+\n+   procedure Swap_Links\n+     (Container : in out List;\n+      I, J      : Cursor);\n+\n+   procedure Splice\n+     (Target : in out List;\n+      Before : Cursor;\n+      Source : in out List);\n+\n+   procedure Splice\n+     (Target   : in out List;\n+      Before   : Cursor;\n+      Source   : in out List;\n+      Position : in out Cursor);\n+\n+   procedure Splice\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : Cursor);\n+\n+   function First (Container : List) return Cursor;\n+\n+   function First_Element (Container : List) return Element_Type;\n+\n+   function Last (Container : List) return Cursor;\n+\n+   function Last_Element (Container : List) return Element_Type;\n+\n+   function Next (Container : List; Position : Cursor) return Cursor;\n+\n+   procedure Next (Container : List; Position : in out Cursor);\n+\n+   function Previous (Container : List; Position : Cursor) return Cursor;\n+\n+   procedure Previous (Container : List; Position : in out Cursor);\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean;\n+\n+   function Has_Element (Container : List; Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : List;\n+      Process   :\n+      not null access procedure (Container : List; Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   :\n+      not null access procedure (Container : List; Position : Cursor));\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : List) return Boolean;\n+\n+      procedure Sort (Container : in out List);\n+\n+      procedure Merge (Target, Source : in out List);\n+\n+   end Generic_Sorting;\n+\n+   function Strict_Equal (Left, Right : List) return Boolean;\n+\n+   function Left (Container : List; Position : Cursor) return List;\n+\n+   function Right (Container : List; Position : Cursor) return List;\n+\n+private\n+\n+   type Node_Type is record\n+      Prev    : Count_Type'Base := -1;\n+      Next    : Count_Type;\n+      Element : Element_Type;\n+   end record;\n+   function \"=\" (L, R : Node_Type) return Boolean is abstract;\n+\n+   type Node_Array is array (Count_Type range <>) of Node_Type;\n+   function \"=\" (L, R : Node_Array) return Boolean is abstract;\n+\n+   type List_Access is access all List;\n+   for List_Access'Storage_Size use 0;\n+\n+   type Kind is (Plain, Part);\n+\n+   type Plain_List (Capacity : Count_Type) is record\n+      Nodes  : Node_Array (1 .. Capacity) := (others => <>);\n+      Free   : Count_Type'Base := -1;\n+      Busy   : Natural := 0;\n+      Lock   : Natural := 0;\n+   end record;\n+\n+   type PList_Access is access Plain_List;\n+\n+   type Part_List is record\n+      LLength : Count_Type := 0;\n+      LFirst  : Count_Type := 0;\n+      LLast   : Count_Type := 0;\n+   end record;\n+\n+   type List (Capacity : Count_Type) is tagged record\n+      K      : Kind := Plain;\n+      Length : Count_Type := 0;\n+      First  : Count_Type := 0;\n+      Last   : Count_Type := 0;\n+      Part   : Part_List;\n+      Plain  : PList_Access := new Plain_List'(Capacity, others => <>);\n+   end record;\n+\n+   use Ada.Streams;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out List);\n+\n+   for List'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : List);\n+\n+   for List'Write use Write;\n+\n+   type Cursor is\n+      record\n+         Node      : Count_Type := 0;\n+      end record;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   Empty_List : constant List := (0, others => <>);\n+\n+   No_Element : constant Cursor := (Node => 0);\n+\n+end Ada.Containers.Formal_Doubly_Linked_Lists;"}, {"sha": "34a8a43f1fcbc663c328d796679b78e550382e55", "filename": "gcc/ada/a-cfhama.adb", "status": "added", "additions": 1558, "deletions": 0, "changes": 1558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,1558 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--    A D A . C O N T A I N E R S . F O R M A L _ H A S H E D _ M A P S     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Hash_Tables.Generic_Bounded_Operations;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Operations);\n+\n+with Ada.Containers.Hash_Tables.Generic_Bounded_Keys;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Keys);\n+\n+with Ada.Containers.Prime_Numbers; use Ada.Containers.Prime_Numbers;\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Formal_Hashed_Maps is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Equivalent_Keys\n+     (Key  : Key_Type;\n+      Node : Node_Type) return Boolean;\n+   pragma Inline (Equivalent_Keys);\n+\n+   function Find_Between\n+     (HT   : Hash_Table_Type;\n+      Key  : Key_Type;\n+      From : Count_Type;\n+      To   : Count_Type) return Count_Type;\n+\n+   procedure Free\n+     (HT : in out Hash_Table_Type;\n+      X  : Count_Type);\n+\n+   generic\n+      with procedure Set_Element (Node : in out Node_Type);\n+   procedure Generic_Allocate\n+     (HT   : in out Hash_Table_Type;\n+      Node : out Count_Type);\n+\n+   function Hash_Node (Node : Node_Type) return Hash_Type;\n+   pragma Inline (Hash_Node);\n+\n+   function Next_Unchecked\n+     (Container : Map;\n+      Position  : Cursor) return Cursor;\n+\n+   function Next (Node : Node_Type) return Count_Type;\n+   pragma Inline (Next);\n+\n+   procedure Set_Next (Node : in out Node_Type; Next : Count_Type);\n+   pragma Inline (Set_Next);\n+\n+   function Vet (Container : Map; Position : Cursor) return Boolean;\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   package HT_Ops is\n+     new Hash_Tables.Generic_Bounded_Operations\n+       (HT_Types        => HT_Types,\n+        Hash_Node       => Hash_Node,\n+        Next            => Next,\n+        Set_Next        => Set_Next);\n+\n+   package Key_Ops is\n+     new Hash_Tables.Generic_Bounded_Keys\n+       (HT_Types        => HT_Types,\n+        Next            => Next,\n+        Set_Next        => Set_Next,\n+        Key_Type        => Key_Type,\n+        Hash            => Hash,\n+        Equivalent_Keys => Equivalent_Keys);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Map) return Boolean is\n+   begin\n+\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      if Length (Left) = 0 then\n+         return True;\n+      end if;\n+\n+      declare\n+         Node  : Count_Type := First (Left).Node;\n+         ENode : Count_Type;\n+         Last  : Count_Type;\n+      begin\n+\n+         if Left.K = Plain then\n+            Last := 0;\n+         else\n+            Last := HT_Ops.Next (Left.HT.all, Left.Last);\n+         end if;\n+\n+         while Node /= Last loop\n+            ENode := Find (Container => Right,\n+                           Key       => Left.HT.Nodes (Node).Key).Node;\n+            if ENode = 0 or else\n+              Right.HT.Nodes (ENode).Element /= Left.HT.Nodes (Node).Element\n+            then\n+               return False;\n+            end if;\n+\n+            Node := HT_Ops.Next (Left.HT.all, Node);\n+         end loop;\n+\n+         return True;\n+\n+      end;\n+\n+   end \"=\";\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Map; Source : Map) is\n+      procedure Insert_Element (Source_Node : Count_Type);\n+      pragma Inline (Insert_Element);\n+\n+      procedure Insert_Elements is\n+        new HT_Ops.Generic_Iteration (Insert_Element);\n+\n+      --------------------\n+      -- Insert_Element --\n+      --------------------\n+\n+      procedure Insert_Element (Source_Node : Count_Type) is\n+         N : Node_Type renames Source.HT.Nodes (Source_Node);\n+      begin\n+         Target.Insert (N.Key, N.Element);\n+      end Insert_Element;\n+\n+      --  Start of processing for Assign\n+\n+   begin\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Length (Source) then\n+         raise Constraint_Error with  -- correct exception ???\n+           \"Source length exceeds Target capacity\";\n+      end if;\n+\n+      Clear (Target);  -- checks busy bits\n+\n+      case Source.K is\n+         when Plain =>\n+            Insert_Elements (Source.HT.all);\n+         when Part =>\n+            declare\n+               N : Count_Type := Source.First;\n+            begin\n+               while N /= HT_Ops.Next (Source.HT.all, Source.Last) loop\n+                  Insert_Element (N);\n+                  N := HT_Ops.Next (Source.HT.all, N);\n+               end loop;\n+            end;\n+      end case;\n+   end Assign;\n+\n+   --------------\n+   -- Capacity --\n+   --------------\n+\n+   function Capacity (Container : Map) return Count_Type is\n+   begin\n+      return Container.HT.Nodes'Length;\n+   end Capacity;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Map) is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      HT_Ops.Clear (Container.HT.all);\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean is\n+   begin\n+      return Find (Container, Key) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy\n+     (Source   : Map;\n+      Capacity : Count_Type := 0) return Map\n+   is\n+      C      : constant Count_Type :=\n+                 Count_Type'Max (Capacity, Source.Capacity);\n+      H      : Hash_Type := 1;\n+      N      : Count_Type := 1;\n+      Target : Map (C, Source.Modulus);\n+      Cu     : Cursor;\n+   begin\n+      if (Source.K = Part and Source.Length = 0) or\n+        Source.HT.Length = 0 then\n+         return Target;\n+      end if;\n+\n+      Target.HT.Length := Source.HT.Length;\n+      Target.HT.Free := Source.HT.Free;\n+      while H <= Source.Modulus loop\n+         Target.HT.Buckets (H) := Source.HT.Buckets (H);\n+         H := H + 1;\n+      end loop;\n+      while N <= Source.Capacity loop\n+         Target.HT.Nodes (N) := Source.HT.Nodes (N);\n+         N := N + 1;\n+      end loop;\n+      while N <= C loop\n+         Cu := (Node => N);\n+         Free (Target.HT.all, Cu.Node);\n+         N := N + 1;\n+      end loop;\n+      if Source.K = Part then\n+         N := HT_Ops.First (Target.HT.all);\n+         while N /= Source.First loop\n+            Cu := (Node => N);\n+            N := HT_Ops.Next (Target.HT.all, N);\n+            Delete (Target, Cu);\n+         end loop;\n+         N := HT_Ops.Next (Target.HT.all, Source.Last);\n+         while N /= 0 loop\n+            Cu := (Node => N);\n+            N := HT_Ops.Next (Target.HT.all, N);\n+            Delete (Target, Cu);\n+         end loop;\n+      end if;\n+      return Target;\n+   end Copy;\n+\n+   ---------------------\n+   -- Default_Modulus --\n+   ---------------------\n+\n+   function Default_Modulus (Capacity : Count_Type) return Hash_Type is\n+   begin\n+      return To_Prime (Capacity);\n+   end Default_Modulus;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type) is\n+      X : Count_Type;\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      Key_Ops.Delete_Key_Sans_Free (Container.HT.all, Key, X);\n+\n+      if X = 0 then\n+         raise Constraint_Error with \"attempt to delete key not in map\";\n+      end if;\n+\n+      Free (Container.HT.all, X);\n+   end Delete;\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor) is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of Delete has no element\";\n+      end if;\n+\n+      if Container.HT.Busy > 0 then\n+         raise Program_Error with\n+           \"Delete attempted to tamper with elements (map is busy)\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n+\n+      HT_Ops.Delete_Node_Sans_Free (Container.HT.all, Position.Node);\n+\n+      Free (Container.HT.all, Position.Node);\n+   end Delete;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type is\n+      Node : constant Count_Type := Find (Container, Key).Node;\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"no element available because key not in map\";\n+      end if;\n+\n+      return Container.HT.Nodes (Node).Element;\n+   end Element;\n+\n+   function Element (Container : Map; Position : Cursor) return Element_Type is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position),\n+                     \"bad cursor in function Element\");\n+\n+      return Container.HT.Nodes (Position.Node).Element;\n+   end Element;\n+\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n+\n+   function Equivalent_Keys\n+     (Key  : Key_Type;\n+      Node : Node_Type) return Boolean is\n+   begin\n+      return Equivalent_Keys (Key, Node.Key);\n+   end Equivalent_Keys;\n+\n+   function Equivalent_Keys (Left  : Map; CLeft : Cursor;\n+                             Right : Map; CRight : Cursor)\n+                             return Boolean is\n+   begin\n+      if not Has_Element (Left, CLeft) then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Keys has no element\";\n+      end if;\n+\n+      if not Has_Element (Right, CRight) then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Keys has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left, CLeft),\n+                     \"Left cursor of Equivalent_Keys is bad\");\n+      pragma Assert (Vet (Right, CRight),\n+                     \"Right cursor of Equivalent_Keys is bad\");\n+\n+      declare\n+         LT : Hash_Table_Type renames Left.HT.all;\n+         RT : Hash_Table_Type renames Right.HT.all;\n+\n+         LN : Node_Type renames LT.Nodes (CLeft.Node);\n+         RN : Node_Type renames RT.Nodes (CRight.Node);\n+\n+      begin\n+         return Equivalent_Keys (LN.Key, RN.Key);\n+      end;\n+   end Equivalent_Keys;\n+\n+   function Equivalent_Keys\n+     (Left  : Map;\n+      CLeft : Cursor;\n+      Right : Key_Type) return Boolean is\n+   begin\n+      if not Has_Element (Left, CLeft) then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Keys has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left, CLeft),\n+                     \"Left cursor in Equivalent_Keys is bad\");\n+\n+      declare\n+         LT : Hash_Table_Type renames Left.HT.all;\n+         LN : Node_Type renames LT.Nodes (CLeft.Node);\n+\n+      begin\n+         return Equivalent_Keys (LN.Key, Right);\n+      end;\n+   end Equivalent_Keys;\n+\n+   function Equivalent_Keys\n+     (Left   : Key_Type;\n+      Right  : Map;\n+      CRight : Cursor) return Boolean is\n+   begin\n+      if Has_Element (Right, CRight) then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Keys has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Right, CRight),\n+                     \"Right cursor of Equivalent_Keys is bad\");\n+\n+      declare\n+         RT : Hash_Table_Type renames Right.HT.all;\n+         RN : Node_Type renames RT.Nodes (CRight.Node);\n+\n+      begin\n+         return Equivalent_Keys (Left, RN.Key);\n+      end;\n+   end Equivalent_Keys;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type) is\n+      X : Count_Type;\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      Key_Ops.Delete_Key_Sans_Free (Container.HT.all, Key, X);\n+      Free (Container.HT.all, X);\n+   end Exclude;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+   function Find_Between\n+     (HT   : Hash_Table_Type;\n+      Key  : Key_Type;\n+      From : Count_Type;\n+      To   : Count_Type) return Count_Type is\n+\n+      Indx      : Hash_Type;\n+      Indx_From : constant Hash_Type :=\n+        Key_Ops.Index (HT, HT.Nodes (From).Key);\n+      Indx_To   : constant Hash_Type :=\n+        Key_Ops.Index (HT, HT.Nodes (To).Key);\n+      Node      : Count_Type;\n+      To_Node   : Count_Type;\n+\n+   begin\n+\n+      Indx := Key_Ops.Index (HT, Key);\n+\n+      if Indx < Indx_From or Indx > Indx_To then\n+         return 0;\n+      end if;\n+\n+      if Indx = Indx_From then\n+         Node := From;\n+      else\n+         Node := HT.Buckets (Indx);\n+      end if;\n+\n+      if Indx = Indx_To then\n+         To_Node := HT.Nodes (To).Next;\n+      else\n+         To_Node := 0;\n+      end if;\n+\n+      while Node /= To_Node loop\n+         if Equivalent_Keys (Key, HT.Nodes (Node)) then\n+            return Node;\n+         end if;\n+         Node := HT.Nodes (Node).Next;\n+      end loop;\n+      return 0;\n+   end Find_Between;\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor is\n+   begin\n+      case Container.K is\n+         when Plain =>\n+            declare\n+               Node : constant Count_Type :=\n+                        Key_Ops.Find (Container.HT.all, Key);\n+\n+            begin\n+               if Node = 0 then\n+                  return No_Element;\n+               end if;\n+\n+               return (Node => Node);\n+            end;\n+         when Part =>\n+            if Container.Length = 0 then\n+               return No_Element;\n+            end if;\n+\n+            return (Node => Find_Between (Container.HT.all, Key,\n+                    Container.First, Container.Last));\n+      end case;\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Map) return Cursor is\n+   begin\n+      case Container.K is\n+         when Plain =>\n+            declare\n+               Node : constant Count_Type := HT_Ops.First (Container.HT.all);\n+\n+            begin\n+               if Node = 0 then\n+                  return No_Element;\n+               end if;\n+\n+               return (Node => Node);\n+            end;\n+         when Part =>\n+            declare\n+               Node : constant Count_Type := Container.First;\n+\n+            begin\n+               if Node = 0 then\n+                  return No_Element;\n+               end if;\n+\n+               return (Node => Node);\n+            end;\n+      end case;\n+   end First;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free\n+     (HT : in out Hash_Table_Type;\n+      X  : Count_Type)\n+   is\n+   begin\n+      HT.Nodes (X).Has_Element := False;\n+      HT_Ops.Free (HT, X);\n+   end Free;\n+\n+   ----------------------\n+   -- Generic_Allocate --\n+   ----------------------\n+\n+   procedure Generic_Allocate\n+     (HT   : in out Hash_Table_Type;\n+      Node : out Count_Type)\n+   is\n+\n+      procedure Allocate is\n+        new HT_Ops.Generic_Allocate (Set_Element);\n+\n+   begin\n+      Allocate (HT, Node);\n+      HT.Nodes (Node).Has_Element := True;\n+   end Generic_Allocate;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Container : Map; Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 or else\n+        not Container.HT.Nodes (Position.Node).Has_Element then\n+         return False;\n+      end if;\n+\n+      if Container.K = Plain then\n+         return True;\n+      end if;\n+\n+      declare\n+         Lst_Index : constant Hash_Type :=\n+                       Key_Ops.Index (Container.HT.all,\n+                                      Container.HT.Nodes (Container.Last).Key);\n+         Fst_Index : constant Hash_Type :=\n+                       Key_Ops.Index (Container.HT.all,\n+                                     Container.HT.Nodes (Container.First).Key);\n+         Index     : constant Hash_Type :=\n+                       Key_Ops.Index (Container.HT.all,\n+                                      Container.HT.Nodes (Position.Node).Key);\n+         Lst_Node  : Count_Type;\n+         Node      : Count_Type;\n+      begin\n+\n+         if Index < Fst_Index or Index > Lst_Index then\n+            return False;\n+         end if;\n+\n+         if Index > Fst_Index and Index < Lst_Index then\n+            return True;\n+         end if;\n+\n+         if Index = Fst_Index then\n+            Node := Container.First;\n+         else\n+            Node := Container.HT.Buckets (Index);\n+         end if;\n+\n+         if Index = Lst_Index then\n+            Lst_Node := Container.HT.Nodes (Container.Last).Next;\n+         else\n+            Lst_Node := 0;\n+         end if;\n+\n+         while Node /= Lst_Node loop\n+            if Position.Node = Node then\n+               return True;\n+            end if;\n+            Node := HT_Ops.Next (Container.HT.all, Node);\n+         end loop;\n+\n+         return False;\n+      end;\n+   end Has_Element;\n+\n+   ---------------\n+   -- Hash_Node --\n+   ---------------\n+\n+   function Hash_Node\n+     (Node : Node_Type) return Hash_Type is\n+   begin\n+      return Hash (Node.Key);\n+   end Hash_Node;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         if Container.HT.Lock > 0 then\n+            raise Program_Error with\n+              \"Include attempted to tamper with cursors (map is locked)\";\n+         end if;\n+\n+         declare\n+            N : Node_Type renames Container.HT.Nodes (Position.Node);\n+         begin\n+            N.Key := Key;\n+            N.Element := New_Item;\n+         end;\n+      end if;\n+   end Include;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+      declare\n+         procedure Assign_Key (Node : in out Node_Type);\n+         pragma Inline (Assign_Key);\n+\n+         function New_Node return Count_Type;\n+         pragma Inline (New_Node);\n+\n+         procedure Local_Insert is\n+           new Key_Ops.Generic_Conditional_Insert (New_Node);\n+\n+         procedure Allocate is\n+           new Generic_Allocate (Assign_Key);\n+\n+         -----------------\n+         --  Assign_Key --\n+         -----------------\n+\n+         procedure Assign_Key (Node : in out Node_Type) is\n+         begin\n+            Node.Key := Key;\n+            --  Node.Element := New_Item;\n+         end Assign_Key;\n+\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Count_Type is\n+            Result : Count_Type;\n+         begin\n+            Allocate (Container.HT.all, Result);\n+            return Result;\n+         end New_Node;\n+\n+         --  Start of processing for Insert\n+\n+      begin\n+\n+         Local_Insert (Container.HT.all, Key, Position.Node, Inserted);\n+      end;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+      declare\n+         procedure Assign_Key (Node : in out Node_Type);\n+         pragma Inline (Assign_Key);\n+\n+         function New_Node return Count_Type;\n+         pragma Inline (New_Node);\n+\n+         procedure Local_Insert is\n+           new Key_Ops.Generic_Conditional_Insert (New_Node);\n+\n+         procedure Allocate is\n+           new Generic_Allocate (Assign_Key);\n+\n+         -----------------\n+         --  Assign_Key --\n+         -----------------\n+\n+         procedure Assign_Key (Node : in out Node_Type) is\n+         begin\n+            Node.Key := Key;\n+            Node.Element := New_Item;\n+         end Assign_Key;\n+\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Count_Type is\n+            Result : Count_Type;\n+         begin\n+            Allocate (Container.HT.all, Result);\n+            return Result;\n+         end New_Node;\n+\n+         --  Start of processing for Insert\n+\n+      begin\n+\n+         Local_Insert (Container.HT.all, Key, Position.Node, Inserted);\n+      end;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      pragma Unreferenced (Position);\n+\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error with\n+           \"attempt to insert key already in map\";\n+      end if;\n+   end Insert;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Map) return Boolean is\n+   begin\n+      return Length (Container) = 0;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   :\n+        not null access procedure (Container : Map; Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Count_Type);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Iterate is new HT_Ops.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Count_Type) is\n+      begin\n+         Process (Container, (Node => Node));\n+      end Process_Node;\n+\n+      B : Natural renames Container'Unrestricted_Access.HT.Busy;\n+\n+      --  Start of processing for Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         case Container.K is\n+            when Plain =>\n+               Local_Iterate (Container.HT.all);\n+            when Part =>\n+\n+               if Container.Length = 0 then\n+                  return;\n+               end if;\n+\n+               declare\n+                  Node : Count_Type := Container.First;\n+               begin\n+                  while Node /= Container.HT.Nodes (Container.Last).Next loop\n+                     Process_Node (Node);\n+                     Node := HT_Ops.Next (Container.HT.all, Node);\n+                  end loop;\n+               end;\n+         end case;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate;\n+\n+   ---------\n+   -- Key --\n+   ---------\n+\n+   function Key (Container : Map; Position : Cursor) return Key_Type is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of function Key has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position), \"bad cursor in function Key\");\n+\n+      return Container.HT.Nodes (Position.Node).Key;\n+   end Key;\n+\n+   ----------\n+   -- Left --\n+   ----------\n+\n+   function Left (Container : Map; Position : Cursor) return Map is\n+      Lst : Count_Type;\n+      Fst : constant Count_Type := First (Container).Node;\n+      L   : Count_Type := 0;\n+      C   : Count_Type := Fst;\n+   begin\n+      while C /= Position.Node loop\n+         if C = 0 or C = Container.Last then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+         Lst := C;\n+         C := HT_Ops.Next (Container.HT.all, C);\n+         L := L + 1;\n+      end loop;\n+      if L = 0 then\n+         return (Capacity => Container.Capacity,\n+                 Modulus  => Container.Modulus,\n+                 K        => Part,\n+                 HT       => Container.HT,\n+                 Length   => 0,\n+                 First    => 0,\n+                 Last     => 0);\n+      else\n+         return (Capacity => Container.Capacity,\n+                 Modulus  => Container.Modulus,\n+                 K        => Part,\n+                 HT       => Container.HT,\n+                 Length   => L,\n+                 First    => Fst,\n+                 Last     => Lst);\n+      end if;\n+   end Left;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Map) return Count_Type is\n+   begin\n+      case Container.K is\n+         when Plain =>\n+            return Container.HT.Length;\n+         when Part =>\n+            return Container.Length;\n+      end case;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Target : in out Map;\n+      Source : in out Map)\n+   is\n+      HT   : HT_Types.Hash_Table_Type renames Source.HT.all;\n+      NN   : HT_Types.Nodes_Type renames HT.Nodes;\n+      X, Y : Count_Type;\n+\n+   begin\n+\n+      if Target.K /= Plain or Source.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Length (Source) then\n+         raise Constraint_Error with  -- ???\n+           \"Source length exceeds Target capacity\";\n+      end if;\n+\n+      if HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Source (list is busy)\";\n+      end if;\n+\n+      Clear (Target);\n+\n+      if HT.Length = 0 then\n+         return;\n+      end if;\n+\n+      X := HT_Ops.First (HT);\n+      while X /= 0 loop\n+         Insert (Target, NN (X).Key, NN (X).Element);  -- optimize???\n+\n+         Y := HT_Ops.Next (HT, X);\n+\n+         HT_Ops.Delete_Node_Sans_Free (HT, X);\n+         Free (HT, X);\n+\n+         X := Y;\n+      end loop;\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Next;\n+   end Next;\n+\n+   function Next_Unchecked\n+     (Container : Map;\n+      Position  : Cursor) return Cursor\n+   is\n+      HT   : Hash_Table_Type renames Container.HT.all;\n+      Node : constant Count_Type := HT_Ops.Next (HT, Position.Node);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if Container.K = Part and then Container.Last = Position.Node then\n+         return No_Element;\n+      end if;\n+\n+      return (Node => Node);\n+   end Next_Unchecked;\n+\n+   function Next (Container : Map; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error\n+           with \"Position has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position), \"bad cursor in function Next\");\n+\n+      return Next_Unchecked (Container, Position);\n+   end Next;\n+\n+   procedure Next (Container : Map; Position : in out Cursor) is\n+   begin\n+      Position := Next (Container, Position);\n+   end Next;\n+\n+   -------------\n+   -- Overlap --\n+   -------------\n+\n+   function Overlap (Left, Right : Map) return Boolean is\n+      Left_Node  : Count_Type;\n+      Left_Nodes : Nodes_Type renames Left.HT.Nodes;\n+      To_Node    : Count_Type;\n+   begin\n+      if Length (Right) = 0 or Length (Left) = 0 then\n+         return False;\n+      end if;\n+\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      Left_Node := First (Left).Node;\n+\n+      if Left.K = Plain then\n+         To_Node := 0;\n+      else\n+         To_Node := Left.HT.Nodes (Left.Last).Next;\n+      end if;\n+\n+      while Left_Node /= To_Node loop\n+         declare\n+            N : Node_Type renames Left_Nodes (Left_Node);\n+            E : Key_Type renames N.Key;\n+\n+         begin\n+            if Find (Right, E).Node /= 0 then\n+               return True;\n+            end if;\n+         end;\n+\n+         Left_Node := HT_Ops.Next (Left.HT.all, Left_Node);\n+      end loop;\n+\n+      return False;\n+   end Overlap;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access\n+        procedure (Key : Key_Type; Element : Element_Type))\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position), \"bad cursor in Query_Element\");\n+\n+      declare\n+         HT : Hash_Table_Type renames Container.HT.all;\n+         N  : Node_Type renames HT.Nodes (Position.Node);\n+\n+         B : Natural renames HT.Busy;\n+         L : Natural renames HT.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         declare\n+            K : Key_Type renames N.Key;\n+            E : Element_Type renames N.Element;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Map)\n+   is\n+      function Read_Node (Stream : not null access Root_Stream_Type'Class)\n+                          return Count_Type;\n+\n+      procedure Read_Nodes is\n+        new HT_Ops.Generic_Read (Read_Node);\n+\n+      ---------------\n+      -- Read_Node --\n+      ---------------\n+\n+      function Read_Node (Stream : not null access Root_Stream_Type'Class)\n+                          return Count_Type\n+      is\n+         procedure Read_Element (Node : in out Node_Type);\n+         pragma Inline (Read_Element);\n+\n+         procedure Allocate is\n+           new Generic_Allocate (Read_Element);\n+\n+         procedure Read_Element (Node : in out Node_Type) is\n+         begin\n+            Element_Type'Read (Stream, Node.Element);\n+         end Read_Element;\n+\n+         Node : Count_Type;\n+\n+         --  Start of processing for Read_Node\n+\n+      begin\n+         Allocate (Container.HT.all, Node);\n+         return Node;\n+      end Read_Node;\n+\n+      --  Start of processing for Read\n+      Result : HT_Access;\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Container.HT = null then\n+         Result := new HT_Types.Hash_Table_Type (Container.Capacity,\n+                                                 Container.Modulus);\n+      else\n+         Result := Container.HT;\n+      end if;\n+\n+      Read_Nodes (Stream, Result.all);\n+      Container.HT := Result;\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream set cursor\";\n+   end Read;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Node : constant Count_Type := Key_Ops.Find (Container.HT.all, Key);\n+\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"attempt to replace key not in map\";\n+      end if;\n+\n+      if Container.HT.Lock > 0 then\n+         raise Program_Error with\n+           \"Replace attempted to tamper with cursors (map is locked)\";\n+      end if;\n+\n+      declare\n+         N : Node_Type renames Container.HT.Nodes (Node);\n+      begin\n+         N.Key := Key;\n+         N.Element := New_Item;\n+      end;\n+   end Replace;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of Replace_Element has no element\";\n+      end if;\n+\n+      if Container.HT.Lock > 0 then\n+         raise Program_Error with\n+           \"Replace_Element attempted to tamper with cursors (map is locked)\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position),\n+                     \"bad cursor in Replace_Element\");\n+\n+      Container.HT.Nodes (Position.Node).Element := New_Item;\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Map;\n+      Capacity  : Count_Type)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Capacity > Container.Capacity then\n+         raise Capacity_Error with \"requested capacity is too large\";\n+      end if;\n+   end Reserve_Capacity;\n+\n+   -----------\n+   -- Right --\n+   -----------\n+\n+   function Right (Container : Map; Position : Cursor) return Map is\n+      Last : Count_Type;\n+      Lst  : Count_Type;\n+      L    : Count_Type := 0;\n+      C    : Count_Type := Position.Node;\n+   begin\n+\n+      if C = 0 then\n+         return (Capacity => Container.Capacity,\n+                 Modulus  => Container.Modulus,\n+                 K        => Part,\n+                 HT       => Container.HT,\n+                 Length   => 0,\n+                 First    => 0,\n+                 Last     => 0);\n+      end if;\n+\n+      if Container.K = Plain then\n+         Lst := 0;\n+      else\n+         Lst := HT_Ops.Next (Container.HT.all, Container.Last);\n+      end if;\n+\n+      if C = Lst then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      while C /= Lst loop\n+         if C = 0 then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+         Last := C;\n+         C := HT_Ops.Next (Container.HT.all, C);\n+         L := L + 1;\n+      end loop;\n+\n+      return (Capacity => Container.Capacity,\n+              Modulus  => Container.Modulus,\n+              K        => Part,\n+              HT       => Container.HT,\n+              Length   => L,\n+              First    => Position.Node,\n+              Last     => Last);\n+   end Right;\n+\n+   --------------\n+   -- Set_Next --\n+   --------------\n+\n+   procedure Set_Next (Node : in out Node_Type; Next : Count_Type) is\n+   begin\n+      Node.Next := Next;\n+   end Set_Next;\n+\n+   ------------------\n+   -- Strict_Equal --\n+   ------------------\n+\n+   function Strict_Equal (Left, Right : Map) return Boolean is\n+      CuL : Cursor := First (Left);\n+      CuR : Cursor := First (Right);\n+   begin\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      while CuL.Node /= 0 or CuR.Node /= 0 loop\n+         if CuL.Node /= CuR.Node or else\n+           (Left.HT.Nodes (CuL.Node).Element /=\n+              Right.HT.Nodes (CuR.Node).Element or\n+              Left.HT.Nodes (CuL.Node).Key /=\n+              Right.HT.Nodes (CuR.Node).Key) then\n+            return False;\n+         end if;\n+         CuL := Next_Unchecked (Left, CuL);\n+         CuR := Next_Unchecked (Right, CuR);\n+      end loop;\n+\n+      return True;\n+   end Strict_Equal;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Key     : Key_Type;\n+                                             Element : in out Element_Type))\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of Update_Element has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position),\n+                     \"bad cursor in Update_Element\");\n+\n+      declare\n+         HT : Hash_Table_Type renames Container.HT.all;\n+         B  : Natural renames HT.Busy;\n+         L  : Natural renames HT.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         declare\n+            N : Node_Type renames HT.Nodes (Position.Node);\n+            K : Key_Type renames N.Key;\n+            E : Element_Type renames N.Element;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Update_Element;\n+\n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Container : Map; Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 then\n+         return True;\n+      end if;\n+\n+      declare\n+         M : HT_Types.Hash_Table_Type renames Container.HT.all;\n+         X : Count_Type;\n+\n+      begin\n+         if M.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if M.Capacity = 0 then\n+            return False;\n+         end if;\n+\n+         if M.Buckets'Length = 0 then\n+            return False;\n+         end if;\n+\n+         if Position.Node > M.Capacity then\n+            return False;\n+         end if;\n+\n+         if M.Nodes (Position.Node).Next = Position.Node then\n+            return False;\n+         end if;\n+\n+         X := M.Buckets (Key_Ops.Index (M, M.Nodes (Position.Node).Key));\n+\n+         for J in 1 .. M.Length loop\n+            if X = Position.Node then\n+               return True;\n+            end if;\n+\n+            if X = 0 then\n+               return False;\n+            end if;\n+\n+            if X = M.Nodes (X).Next then  --  to prevent unnecessary looping\n+               return False;\n+            end if;\n+\n+            X := M.Nodes (X).Next;\n+         end loop;\n+\n+         return False;\n+      end;\n+   end Vet;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Map)\n+   is\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type);\n+      pragma Inline (Write_Node);\n+\n+      procedure Write_Nodes is new HT_Ops.Generic_Write (Write_Node);\n+\n+      ----------------\n+      -- Write_Node --\n+      ----------------\n+\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type)\n+      is\n+      begin\n+         Key_Type'Write (Stream, Node.Key);\n+         Element_Type'Write (Stream, Node.Element);\n+      end Write_Node;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      Write_Nodes (Stream, Container.HT.all);\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream map cursor\";\n+   end Write;\n+\n+end Ada.Containers.Formal_Hashed_Maps;"}, {"sha": "03b6d36789d87f24929b93d0cb6af9186bf77fed", "filename": "gcc/ada/a-cfhama.ads", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,259 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--    A D A . C O N T A I N E R S . F O R M A L _ H A S H E D _ M A P S     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Containers.Hash_Tables;\n+private with Ada.Streams;\n+with Ada.Containers; use Ada.Containers;\n+\n+generic\n+   type Key_Type is private;\n+   type Element_Type is private;\n+\n+   with function Hash (Key : Key_Type) return Hash_Type;\n+   with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Formal_Hashed_Maps is\n+   pragma Pure;\n+\n+   type Map (Capacity : Count_Type; Modulus : Hash_Type) is tagged private;\n+   --  pragma Preelaborable_Initialization (Map);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Map : constant Map;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Map) return Boolean;\n+\n+   function Capacity (Container : Map) return Count_Type;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Map;\n+      Capacity  : Count_Type);\n+\n+   function Length (Container : Map) return Count_Type;\n+\n+   function Is_Empty (Container : Map) return Boolean;\n+\n+   --  ??? what does clear do to active elements?\n+   procedure Clear (Container : in out Map);\n+\n+   procedure Assign (Target : in out Map; Source : Map);\n+\n+   --  ???\n+   --  capacity=0 means use container.length as cap of tgt\n+   --  modulos=0 means use default_modulous(container.length)\n+   function Copy (Source   : Map;\n+                  Capacity : Count_Type := 0) return Map;\n+\n+   function Key (Container : Map; Position : Cursor) return Key_Type;\n+\n+   function Element (Container : Map; Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access\n+        procedure (Key : Key_Type; Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access\n+        procedure (Key : Key_Type; Element : in out Element_Type));\n+\n+   procedure Move (Target : in out Map; Source : in out Map);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type);\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type);\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor);\n+\n+   function First (Container : Map) return Cursor;\n+\n+   function Next (Container : Map; Position : Cursor) return Cursor;\n+\n+   procedure Next (Container : Map; Position : in out Cursor);\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean;\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+\n+   function Has_Element (Container : Map; Position : Cursor) return Boolean;\n+\n+   function Equivalent_Keys\n+     (Left   : Map;\n+      CLeft  : Cursor;\n+      Right  : Map;\n+      CRight : Cursor) return Boolean;\n+\n+   function Equivalent_Keys\n+     (Left  : Map;\n+      CLeft : Cursor;\n+      Right : Key_Type) return Boolean;\n+\n+   function Equivalent_Keys\n+     (Left   : Key_Type;\n+      Right  : Map;\n+      CRight : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   :\n+        not null access procedure (Container : Map; Position : Cursor));\n+\n+   function Default_Modulus (Capacity : Count_Type) return Hash_Type;\n+\n+   function Strict_Equal (Left, Right : Map) return Boolean;\n+\n+   function Left (Container : Map; Position : Cursor) return Map;\n+\n+   function Right (Container : Map; Position : Cursor) return Map;\n+\n+   function Overlap (Left, Right : Map) return Boolean;\n+\n+private\n+   --  pragma Inline (\"=\");\n+   pragma Inline (Length);\n+   pragma Inline (Is_Empty);\n+   pragma Inline (Clear);\n+   pragma Inline (Key);\n+   pragma Inline (Element);\n+   --  pragma Inline (Move);  ???\n+   pragma Inline (Contains);\n+   pragma Inline (Capacity);\n+   --  pragma Inline (Reserve_Capacity);  ???\n+   pragma Inline (Has_Element);\n+   pragma Inline (Equivalent_Keys);\n+   pragma Inline (Next);\n+\n+   type Node_Type is record\n+      Key         : Key_Type;\n+      Element     : Element_Type;\n+      Next        : Count_Type;\n+      Has_Element : Boolean := False;\n+   end record;\n+\n+   package HT_Types is new\n+     Ada.Containers.Hash_Tables.Generic_Bounded_Hash_Table_Types\n+     (Node_Type);\n+\n+   type HT_Access is access all HT_Types.Hash_Table_Type;\n+\n+   type Kind is (Plain, Part);\n+\n+   type Map (Capacity : Count_Type; Modulus : Hash_Type) is tagged record\n+      HT     : HT_Access := new HT_Types.Hash_Table_Type (Capacity, Modulus);\n+      K      : Kind := Plain;\n+      Length : Count_Type := 0;\n+      First  : Count_Type := 0;\n+      Last   : Count_Type := 0;\n+   end record;\n+\n+   use HT_Types;\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Map);\n+\n+   for Map'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Map);\n+\n+   for Map'Read use Read;\n+\n+   type Map_Access is access all Map;\n+   for Map_Access'Storage_Size use 0;\n+\n+   type Cursor is\n+      record\n+         Node      : Count_Type;\n+      end record;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   Empty_Map : constant Map := (Capacity => 0, Modulus => 0, others => <>);\n+\n+   No_Element : constant Cursor := (Node => 0);\n+\n+end Ada.Containers.Formal_Hashed_Maps;"}, {"sha": "ed514c826d65fcae5b06a5f076dd2e52b59a3c7e", "filename": "gcc/ada/a-cfhase.adb", "status": "added", "additions": 2436, "deletions": 0, "changes": 2436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,2436 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--    A D A . C O N T A I N E R S . F O R M A L _ H A S H E D _ S E T S     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Hash_Tables.Generic_Bounded_Operations;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Operations);\n+\n+with Ada.Containers.Hash_Tables.Generic_Bounded_Keys;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Keys);\n+\n+with Ada.Containers.Prime_Numbers; use Ada.Containers.Prime_Numbers;\n+\n+with System; use type System.Address;\n+\n+package body Ada.Containers.Formal_Hashed_Sets is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Difference\n+     (Left, Right : Set;\n+      Target      : in out Hash_Table_Type);\n+\n+   function Equivalent_Keys\n+     (Key  : Element_Type;\n+      Node : Node_Type) return Boolean;\n+   pragma Inline (Equivalent_Keys);\n+\n+   procedure Free\n+     (HT : in out Hash_Table_Type;\n+      X  : Count_Type);\n+\n+   generic\n+      with procedure Set_Element (Node : in out Node_Type);\n+   procedure Generic_Allocate\n+     (HT   : in out Hash_Table_Type;\n+      Node : out Count_Type);\n+\n+   function Hash_Node (Node : Node_Type) return Hash_Type;\n+   pragma Inline (Hash_Node);\n+\n+   procedure Insert\n+     (Container       : in out Hash_Table_Type;\n+      New_Item : Element_Type;\n+      Node     : out Count_Type;\n+      Inserted : out Boolean);\n+\n+   procedure Intersection\n+     (Left   : Hash_Table_Type;\n+      Right  : Set;\n+      Target : in out Hash_Table_Type);\n+\n+   function Is_In\n+     (HT  : HT_Types.Hash_Table_Type;\n+      Key : Node_Type) return Boolean;\n+   pragma Inline (Is_In);\n+\n+   procedure Set_Element (Node : in out Node_Type; Item : Element_Type);\n+   pragma Inline (Set_Element);\n+\n+   function Next_Unchecked\n+     (Container : Set;\n+      Position  : Cursor) return Cursor;\n+\n+   function Next (Node : Node_Type) return Count_Type;\n+   pragma Inline (Next);\n+\n+   procedure Set_Next (Node : in out Node_Type; Next : Count_Type);\n+   pragma Inline (Set_Next);\n+\n+   function Vet (Container : Set; Position : Cursor) return Boolean;\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   package HT_Ops is new Hash_Tables.Generic_Bounded_Operations\n+     (HT_Types  => HT_Types,\n+      Hash_Node => Hash_Node,\n+      Next      => Next,\n+      Set_Next  => Set_Next);\n+\n+   package Element_Keys is new Hash_Tables.Generic_Bounded_Keys\n+     (HT_Types        => HT_Types,\n+      Next            => Next,\n+      Set_Next        => Set_Next,\n+      Key_Type        => Element_Type,\n+      Hash            => Hash,\n+      Equivalent_Keys => Equivalent_Keys);\n+\n+   procedure Replace_Element is\n+     new Element_Keys.Generic_Replace_Element (Hash_Node, Set_Element);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Set) return Boolean is\n+   begin\n+\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      if Length (Left) = 0 then\n+         return True;\n+      end if;\n+\n+      declare\n+         Node  : Count_Type := First (Left).Node;\n+         ENode : Count_Type;\n+         Last  : Count_Type;\n+      begin\n+\n+         if Left.K = Plain then\n+            Last := 0;\n+         else\n+            Last := HT_Ops.Next (Left.HT.all, Left.Last);\n+         end if;\n+\n+         while Node /= Last loop\n+            ENode := Find (Container => Right,\n+                           Item      => Left.HT.Nodes (Node).Element).Node;\n+            if ENode = 0  or else\n+              Right.HT.Nodes (ENode).Element /= Left.HT.Nodes (Node).Element\n+            then\n+               return False;\n+            end if;\n+\n+            Node := HT_Ops.Next (Left.HT.all, Node);\n+         end loop;\n+\n+         return True;\n+\n+      end;\n+\n+   end \"=\";\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Set; Source : Set) is\n+      procedure Insert_Element (Source_Node : Count_Type);\n+\n+      procedure Insert_Elements is\n+        new HT_Ops.Generic_Iteration (Insert_Element);\n+\n+      --------------------\n+      -- Insert_Element --\n+      --------------------\n+\n+      procedure Insert_Element (Source_Node : Count_Type) is\n+         N : Node_Type renames Source.HT.Nodes (Source_Node);\n+         X : Count_Type;\n+         B : Boolean;\n+\n+      begin\n+         Insert (Target.HT.all, N.Element, X, B);\n+         pragma Assert (B);\n+      end Insert_Element;\n+\n+      --  Start of processing for Assign\n+\n+   begin\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Length (Source) then\n+         raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n+      end if;\n+\n+      HT_Ops.Clear (Target.HT.all);\n+\n+      case Source.K is\n+         when Plain =>\n+            Insert_Elements (Source.HT.all);\n+         when Part =>\n+            declare\n+               N : Count_Type := Source.First;\n+            begin\n+               while N /= HT_Ops.Next (Source.HT.all, Source.Last) loop\n+                  Insert_Element (N);\n+                  N := HT_Ops.Next (Source.HT.all, N);\n+               end loop;\n+            end;\n+      end case;\n+   end Assign;\n+\n+   --------------\n+   -- Capacity --\n+   --------------\n+\n+   function Capacity (Container : Set) return Count_Type is\n+   begin\n+      return Container.HT.Nodes'Length;\n+   end Capacity;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Set) is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      HT_Ops.Clear (Container.HT.all);\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy\n+     (Source   : Set;\n+      Capacity : Count_Type := 0) return Set\n+   is\n+      C      : constant Count_Type :=\n+        Count_Type'Max (Capacity, Source.Capacity);\n+      H      : Hash_Type := 1;\n+      N      : Count_Type := 1;\n+      Target : Set (C, Source.Modulus);\n+      Cu     : Cursor;\n+   begin\n+      if (Source.K = Part and Source.Length = 0) or\n+        Source.HT.Length = 0 then\n+         return Target;\n+      end if;\n+\n+      Target.HT.Length := Source.HT.Length;\n+      Target.HT.Free := Source.HT.Free;\n+      while H <= Source.Modulus loop\n+         Target.HT.Buckets (H) := Source.HT.Buckets (H);\n+         H := H + 1;\n+      end loop;\n+      while N <= Source.Capacity loop\n+         Target.HT.Nodes (N) := Source.HT.Nodes (N);\n+         N := N + 1;\n+      end loop;\n+      while N <= C loop\n+         Cu := (Node => N);\n+         Free (Target.HT.all, Cu.Node);\n+         N := N + 1;\n+      end loop;\n+      if Source.K = Part then\n+         N := HT_Ops.First (Target.HT.all);\n+         while N /= Source.First loop\n+            Cu := (Node => N);\n+            N := HT_Ops.Next (Target.HT.all, N);\n+            Delete (Target, Cu);\n+         end loop;\n+         N := HT_Ops.Next (Target.HT.all, Source.Last);\n+         while N /= 0 loop\n+            Cu := (Node => N);\n+            N := HT_Ops.Next (Target.HT.all, N);\n+            Delete (Target, Cu);\n+         end loop;\n+      end if;\n+      return Target;\n+   end Copy;\n+\n+   ---------------------\n+   -- Default_Modulus --\n+   ---------------------\n+\n+   function Default_Modulus (Capacity : Count_Type) return Hash_Type is\n+   begin\n+      return To_Prime (Capacity);\n+   end Default_Modulus;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out Set;\n+      Item      : Element_Type)\n+   is\n+      X : Count_Type;\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      Element_Keys.Delete_Key_Sans_Free (Container.HT.all, Item, X);\n+\n+      if X = 0 then\n+         raise Constraint_Error with \"attempt to delete element not in set\";\n+      end if;\n+      Free (Container.HT.all, X);\n+   end Delete;\n+\n+   procedure Delete\n+     (Container : in out Set;\n+      Position  : in out Cursor)\n+   is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Container.HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n+\n+      HT_Ops.Delete_Node_Sans_Free (Container.HT.all, Position.Node);\n+      Free (Container.HT.all, Position.Node);\n+\n+      Position := No_Element;\n+   end Delete;\n+\n+   ----------------\n+   -- Difference --\n+   ----------------\n+\n+   procedure Difference\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      Tgt_Node, Src_Node, Src_Last, Src_Length : Count_Type;\n+\n+      TN : Nodes_Type renames Target.HT.Nodes;\n+      SN : Nodes_Type renames Source.HT.Nodes;\n+\n+   begin\n+\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      case Source.K is\n+         when Plain =>\n+            Src_Length := Source.HT.Length;\n+         when Part =>\n+            Src_Length := Source.Length;\n+      end case;\n+\n+      if Src_Length = 0 then\n+         return;\n+      end if;\n+\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n+      end if;\n+\n+      case Source.K is\n+         when Plain =>\n+            if Src_Length >= Target.HT.Length then\n+               Tgt_Node := HT_Ops.First (Target.HT.all);\n+               while Tgt_Node /= 0 loop\n+                  if Element_Keys.Find (Source.HT.all,\n+                                        TN (Tgt_Node).Element) /= 0 then\n+                     declare\n+                        X : constant Count_Type := Tgt_Node;\n+                     begin\n+                        Tgt_Node := HT_Ops.Next (Target.HT.all, Tgt_Node);\n+                        HT_Ops.Delete_Node_Sans_Free (Target.HT.all, X);\n+                        Free (Target.HT.all, X);\n+                     end;\n+                  else\n+                     Tgt_Node := HT_Ops.Next (Target.HT.all, Tgt_Node);\n+                  end if;\n+               end loop;\n+               return;\n+            else\n+               Src_Node := HT_Ops.First (Source.HT.all);\n+               Src_Last := 0;\n+            end if;\n+         when Part =>\n+            Src_Node := Source.First;\n+            Src_Last := HT_Ops.Next (Source.HT.all, Source.Last);\n+      end case;\n+      while Src_Node /= Src_Last loop\n+         Tgt_Node := Element_Keys.Find\n+           (Target.HT.all, SN (Src_Node).Element);\n+\n+         if Tgt_Node /= 0 then\n+            HT_Ops.Delete_Node_Sans_Free (Target.HT.all, Tgt_Node);\n+            Free (Target.HT.all, Tgt_Node);\n+         end if;\n+\n+         Src_Node := HT_Ops.Next (Source.HT.all, Src_Node);\n+      end loop;\n+   end Difference;\n+\n+   procedure Difference\n+     (Left, Right : Set;\n+      Target      : in out Hash_Table_Type)\n+   is\n+      procedure Process (L_Node : Count_Type);\n+\n+      procedure Iterate is\n+        new HT_Ops.Generic_Iteration (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process (L_Node : Count_Type) is\n+         E : Element_Type renames Left.HT.Nodes (L_Node).Element;\n+         X : Count_Type;\n+         B : Boolean;\n+\n+      begin\n+         if Find (Right, E).Node = 0 then\n+            Insert (Target, E, X, B);\n+            pragma Assert (B);\n+         end if;\n+      end Process;\n+\n+      --  Start of processing for Difference\n+\n+   begin\n+      if Left.K = Plain then\n+         Iterate (Left.HT.all);\n+      else\n+\n+         if Left.Length = 0 then\n+            return;\n+         end if;\n+\n+         declare\n+            Node : Count_Type := Left.First;\n+         begin\n+            while Node /= Left.HT.Nodes (Left.Last).Next loop\n+               Process (Node);\n+               Node := HT_Ops.Next (Left.HT.all, Node);\n+            end loop;\n+         end;\n+      end if;\n+   end Difference;\n+\n+   function Difference (Left, Right : Set) return Set is\n+      C : Count_Type;\n+      H : Hash_Type;\n+      S : Set (C, H);\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      if Length (Left) = 0 then\n+         return Empty_Set;\n+      end if;\n+\n+      if Length (Right) = 0 then\n+         return Left.Copy;\n+      end if;\n+\n+      C := Length (Left);\n+      H := Default_Modulus (C);\n+      Difference (Left, Right, Target => S.HT.all);\n+      return S;\n+   end Difference;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element\n+     (Container : Set;\n+      Position  : Cursor) return Element_Type is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position),\n+                     \"bad cursor in function Element\");\n+\n+      declare\n+         HT : Hash_Table_Type renames Container.HT.all;\n+      begin\n+         return HT.Nodes (Position.Node).Element;\n+      end;\n+   end Element;\n+\n+   ---------------------\n+   -- Equivalent_Sets --\n+   ---------------------\n+\n+   function Equivalent_Sets (Left, Right : Set) return Boolean is\n+   begin\n+      if Left.K = Plain and Right.K = Plain then\n+         declare\n+\n+            function Find_Equivalent_Key\n+              (R_HT   : Hash_Table_Type'Class;\n+               L_Node : Node_Type) return Boolean;\n+            pragma Inline (Find_Equivalent_Key);\n+\n+            function Is_Equivalent is\n+              new HT_Ops.Generic_Equal (Find_Equivalent_Key);\n+\n+            -------------------------\n+            -- Find_Equivalent_Key --\n+            -------------------------\n+\n+            function Find_Equivalent_Key\n+              (R_HT   : Hash_Table_Type'Class;\n+               L_Node : Node_Type) return Boolean\n+            is\n+               R_Index : constant Hash_Type :=\n+                 Element_Keys.Index (R_HT, L_Node.Element);\n+\n+               R_Node  : Count_Type := R_HT.Buckets (R_Index);\n+\n+               RN      : Nodes_Type renames R_HT.Nodes;\n+\n+            begin\n+               loop\n+                  if R_Node = 0 then\n+                     return False;\n+                  end if;\n+\n+                  if Equivalent_Elements (L_Node.Element,\n+                                          RN (R_Node).Element) then\n+                     return True;\n+                  end if;\n+\n+                  R_Node := HT_Ops.Next (R_HT, R_Node);\n+               end loop;\n+            end Find_Equivalent_Key;\n+\n+            --  Start of processing of Equivalent_Sets\n+\n+         begin\n+            return Is_Equivalent (Left.HT.all, Right.HT.all);\n+         end;\n+      else\n+         declare\n+\n+            function Equal_Between\n+              (L    : Hash_Table_Type; R : Set;\n+               From : Count_Type; To : Count_Type) return Boolean;\n+\n+            --  To and From are valid and Length are equal\n+            function Equal_Between\n+              (L    : Hash_Table_Type; R : Set;\n+               From : Count_Type; To : Count_Type) return Boolean\n+            is\n+               L_Index  : Hash_Type;\n+               To_Index : constant Hash_Type :=\n+                 Element_Keys.Index (L, L.Nodes (To).Element);\n+               L_Node   : Count_Type := From;\n+\n+            begin\n+\n+               L_Index := Element_Keys.Index (L, L.Nodes (From).Element);\n+\n+               --  For each node of hash table L, search for an equivalent\n+               --  node in hash table R.\n+\n+               while L_Index /= To_Index or else\n+                 L_Node /= HT_Ops.Next (L, To) loop\n+                  pragma Assert (L_Node /= 0);\n+\n+                  if Find (R, L.Nodes (L_Node).Element).Node = 0 then\n+                     return False;\n+                  end if;\n+\n+                  L_Node := L.Nodes (L_Node).Next;\n+\n+                  if L_Node = 0 then\n+                     --  We have exhausted the nodes in this bucket\n+                     --  Find the next bucket\n+\n+                     loop\n+                        L_Index := L_Index + 1;\n+                        L_Node := L.Buckets (L_Index);\n+                        exit when L_Node /= 0;\n+                     end loop;\n+                  end if;\n+               end loop;\n+\n+               return True;\n+            end Equal_Between;\n+\n+         begin\n+            if Length (Left) /= Length (Right) then\n+               return False;\n+            end if;\n+            if Length (Left) = 0 then\n+               return True;\n+            end if;\n+            if Left.K = Part then\n+               return Equal_Between (Left.HT.all, Right,\n+                                     Left.First, Left.Last);\n+            else\n+               return Equal_Between (Right.HT.all, Left,\n+                                     Right.First, Right.Last);\n+            end if;\n+         end;\n+      end if;\n+   end Equivalent_Sets;\n+\n+   -------------------------\n+   -- Equivalent_Elements --\n+   -------------------------\n+\n+   function Equivalent_Elements (Left  : Set; CLeft : Cursor;\n+                                 Right : Set; CRight : Cursor)\n+                                 return Boolean is\n+   begin\n+      if not Has_Element (Left, CLeft) then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Elements has no element\";\n+      end if;\n+\n+      if not Has_Element (Right, CRight) then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Elements has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left, CLeft),\n+                     \"bad Left cursor in Equivalent_Elements\");\n+      pragma Assert (Vet (Right, CRight),\n+                     \"bad Right cursor in Equivalent_Elements\");\n+\n+      declare\n+         LN : Node_Type renames Left.HT.Nodes (CLeft.Node);\n+         RN : Node_Type renames Right.HT.Nodes (CRight.Node);\n+      begin\n+         return Equivalent_Elements (LN.Element, RN.Element);\n+      end;\n+   end Equivalent_Elements;\n+\n+   function Equivalent_Elements\n+     (Left  : Set;\n+      CLeft : Cursor;\n+      Right : Element_Type) return Boolean is\n+   begin\n+      if not Has_Element (Left, CLeft) then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Elements has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left, CLeft),\n+                     \"Left cursor in Equivalent_Elements is bad\");\n+\n+      declare\n+         LN : Node_Type renames Left.HT.Nodes (CLeft.Node);\n+      begin\n+         return Equivalent_Elements (LN.Element, Right);\n+      end;\n+   end Equivalent_Elements;\n+\n+   function Equivalent_Elements\n+     (Left   : Element_Type;\n+      Right  : Set;\n+      CRight : Cursor) return Boolean is\n+   begin\n+      if not Has_Element (Right, CRight) then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Elements has no element\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Right, CRight),\n+         \"Right cursor of Equivalent_Elements is bad\");\n+\n+      declare\n+         RN : Node_Type renames Right.HT.Nodes (CRight.Node);\n+      begin\n+         return Equivalent_Elements (Left, RN.Element);\n+      end;\n+   end Equivalent_Elements;\n+\n+   --  NOT MODIFIED\n+\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n+\n+   function Equivalent_Keys (Key : Element_Type; Node : Node_Type)\n+                             return Boolean is\n+   begin\n+      return Equivalent_Elements (Key, Node.Element);\n+   end Equivalent_Keys;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type)\n+   is\n+      X : Count_Type;\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+      Element_Keys.Delete_Key_Sans_Free (Container.HT.all, Item, X);\n+      Free (Container.HT.all, X);\n+   end Exclude;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Container : Set;\n+      Item      : Element_Type) return Cursor\n+   is\n+   begin\n+      case Container.K is\n+         when Plain =>\n+            declare\n+               Node : constant Count_Type :=\n+                 Element_Keys.Find (Container.HT.all, Item);\n+\n+            begin\n+               if Node = 0 then\n+                  return No_Element;\n+               end if;\n+               return (Node => Node);\n+            end;\n+         when Part =>\n+            declare\n+               function Find_Between\n+                 (HT   : Hash_Table_Type;\n+                  Key  : Element_Type;\n+                  From : Count_Type;\n+                  To   : Count_Type) return Count_Type;\n+\n+               function Find_Between\n+                 (HT   : Hash_Table_Type;\n+                  Key  : Element_Type;\n+                  From : Count_Type;\n+                  To   : Count_Type) return Count_Type is\n+\n+                  Indx      : Hash_Type;\n+                  Indx_From : constant Hash_Type :=\n+                    Element_Keys.Index (HT,\n+                                        HT.Nodes (From).Element);\n+                  Indx_To   : constant Hash_Type :=\n+                    Element_Keys.Index (HT,\n+                                        HT.Nodes (To).Element);\n+                  Node      : Count_Type;\n+                  To_Node   : Count_Type;\n+\n+               begin\n+\n+                  Indx := Element_Keys.Index (HT, Key);\n+\n+                  if Indx < Indx_From or Indx > Indx_To then\n+                     return 0;\n+                  end if;\n+\n+                  if Indx = Indx_From then\n+                     Node := From;\n+                  else\n+                     Node := HT.Buckets (Indx);\n+                  end if;\n+\n+                  if Indx = Indx_To then\n+                     To_Node := HT.Nodes (To).Next;\n+                  else\n+                     To_Node := 0;\n+                  end if;\n+\n+                  while Node /= To_Node loop\n+                     if Equivalent_Keys (Key, HT.Nodes (Node)) then\n+                        return Node;\n+                     end if;\n+                     Node := HT.Nodes (Node).Next;\n+                  end loop;\n+                  return 0;\n+               end Find_Between;\n+            begin\n+\n+               if Container.Length = 0 then\n+                  return No_Element;\n+               end if;\n+\n+               return (Node => Find_Between (Container.HT.all, Item,\n+                       Container.First, Container.Last));\n+            end;\n+      end case;\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Set) return Cursor is\n+   begin\n+      case Container.K is\n+         when Plain =>\n+            declare\n+               Node : constant Count_Type := HT_Ops.First (Container.HT.all);\n+\n+            begin\n+               if Node = 0 then\n+                  return No_Element;\n+               end if;\n+\n+               return (Node => Node);\n+            end;\n+         when Part =>\n+            declare\n+               Node : constant Count_Type := Container.First;\n+\n+            begin\n+               if Node = 0 then\n+                  return No_Element;\n+               end if;\n+\n+               return (Node => Node);\n+            end;\n+      end case;\n+   end First;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free\n+     (HT : in out Hash_Table_Type;\n+      X  : Count_Type)\n+   is\n+   begin\n+      HT.Nodes (X).Has_Element := False;\n+      HT_Ops.Free (HT, X);\n+   end Free;\n+\n+   ----------------------\n+   -- Generic_Allocate --\n+   ----------------------\n+\n+   procedure Generic_Allocate\n+     (HT   : in out Hash_Table_Type;\n+      Node : out Count_Type)\n+   is\n+\n+      procedure Allocate is\n+        new HT_Ops.Generic_Allocate (Set_Element);\n+\n+   begin\n+      Allocate (HT, Node);\n+      HT.Nodes (Node).Has_Element := True;\n+   end Generic_Allocate;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Container : Set; Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 or else\n+        not Container.HT.Nodes (Position.Node).Has_Element then\n+         return False;\n+      end if;\n+\n+      if Container.K = Plain then\n+         return True;\n+      end if;\n+\n+      declare\n+         Lst_Index : constant Hash_Type :=\n+           Element_Keys.Index (Container.HT.all,\n+                               Container.HT.Nodes\n+                                 (Container.Last).Element);\n+         Fst_Index : constant Hash_Type :=\n+           Element_Keys.Index (Container.HT.all,\n+                               Container.HT.Nodes\n+                                 (Container.First).Element);\n+         Index     : constant Hash_Type :=\n+           Element_Keys.Index (Container.HT.all,\n+                               Container.HT.Nodes\n+                                 (Position.Node).Element);\n+         Lst_Node  : Count_Type;\n+         Node      : Count_Type;\n+      begin\n+\n+         if Index < Fst_Index or Index > Lst_Index then\n+            return False;\n+         end if;\n+\n+         if Index > Fst_Index and Index < Lst_Index then\n+            return True;\n+         end if;\n+\n+         if Index = Fst_Index then\n+            Node := Container.First;\n+         else\n+            Node := Container.HT.Buckets (Index);\n+         end if;\n+\n+         if Index = Lst_Index then\n+            Lst_Node := Container.HT.Nodes (Container.Last).Next;\n+         else\n+            Lst_Node := 0;\n+         end if;\n+\n+         while Node /= Lst_Node loop\n+            if Position.Node = Node then\n+               return True;\n+            end if;\n+            Node := HT_Ops.Next (Container.HT.all, Node);\n+         end loop;\n+\n+         return False;\n+      end;\n+   end Has_Element;\n+\n+   ---------------\n+   -- Hash_Node --\n+   ---------------\n+\n+   function Hash_Node (Node : Node_Type) return Hash_Type is\n+   begin\n+      return Hash (Node.Element);\n+   end Hash_Node;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         if Container.HT.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n+         end if;\n+\n+         Container.HT.Nodes (Position.Node).Element := New_Item;\n+      end if;\n+   end Include;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      Insert (Container.HT.all, New_Item, Position.Node, Inserted);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error with\n+           \"attempt to insert element already in set\";\n+      end if;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Hash_Table_Type;\n+      New_Item  : Element_Type;\n+      Node      : out Count_Type;\n+      Inserted  : out Boolean)\n+   is\n+      procedure Allocate_Set_Element (Node : in out Node_Type);\n+      pragma Inline (Allocate_Set_Element);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Insert is\n+        new Element_Keys.Generic_Conditional_Insert (New_Node);\n+\n+      procedure Allocate is\n+        new Generic_Allocate (Allocate_Set_Element);\n+\n+      ---------------------------\n+      --  Allocate_Set_Element --\n+      ---------------------------\n+\n+      procedure Allocate_Set_Element (Node : in out Node_Type) is\n+      begin\n+         Node.Element := New_Item;\n+      end Allocate_Set_Element;\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+      begin\n+         Allocate (Container, Result);\n+         return Result;\n+      end New_Node;\n+\n+      --  Start of processing for Insert\n+\n+   begin\n+\n+      Local_Insert (Container, New_Item, Node, Inserted);\n+\n+   end Insert;\n+\n+   ------------------\n+   -- Intersection --\n+   ------------------\n+\n+   procedure Intersection\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      Tgt_Node : Count_Type;\n+      TN       : Nodes_Type renames Target.HT.Nodes;\n+\n+   begin\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Source.HT.Length = 0 then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n+      end if;\n+\n+      Tgt_Node := HT_Ops.First (Target.HT.all);\n+      while Tgt_Node /= 0 loop\n+         if Find (Source, TN (Tgt_Node).Element).Node /= 0 then\n+            Tgt_Node := HT_Ops.Next (Target.HT.all, Tgt_Node);\n+\n+         else\n+            declare\n+               X : constant Count_Type := Tgt_Node;\n+            begin\n+               Tgt_Node := HT_Ops.Next (Target.HT.all, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target.HT.all, X);\n+               Free (Target.HT.all, X);\n+            end;\n+         end if;\n+      end loop;\n+   end Intersection;\n+\n+   procedure Intersection\n+     (Left   : Hash_Table_Type;\n+      Right  : Set;\n+      Target : in out Hash_Table_Type)\n+   is\n+      procedure Process (L_Node : Count_Type);\n+\n+      procedure Iterate is\n+        new HT_Ops.Generic_Iteration (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process (L_Node : Count_Type) is\n+         E : Element_Type renames Left.Nodes (L_Node).Element;\n+         X : Count_Type;\n+         B : Boolean;\n+\n+      begin\n+         if Find (Right, E).Node /= 0 then\n+            Insert (Target, E, X, B);\n+            pragma Assert (B);\n+         end if;\n+      end Process;\n+\n+      --  Start of processing for Intersection\n+\n+   begin\n+      Iterate (Left);\n+   end Intersection;\n+\n+   function Intersection (Left, Right : Set) return Set is\n+      C : Count_Type;\n+      H : Hash_Type;\n+      X : Count_Type;\n+      B : Boolean;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left.Copy;\n+      end if;\n+\n+      C := Count_Type'Min (Length (Left), Length (Right));  -- ???\n+      H := Default_Modulus (C);\n+      return S : Set (C, H) do\n+         if Length (Left) /= 0 and Length (Right) /= 0 then\n+            if Left.K = Plain then\n+               Intersection (Left.HT.all, Right, Target => S.HT.all);\n+            else\n+               C := Left.First;\n+               while C /= Left.HT.Nodes (Left.Last).Next loop\n+                  pragma Assert (C /= 0);\n+                  if Find (Right, Left.HT.Nodes (C).Element).Node /= 0 then\n+                     Insert (S.HT.all, Left.HT.Nodes (C).Element, X, B);\n+                     pragma Assert (B);\n+                  end if;\n+                  C := Left.HT.Nodes (C).Next;\n+               end loop;\n+            end if;\n+         end if;\n+      end return;\n+   end Intersection;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Set) return Boolean is\n+   begin\n+      return Length (Container) = 0;\n+   end Is_Empty;\n+\n+   -----------\n+   -- Is_In --\n+   -----------\n+\n+   function Is_In (HT : HT_Types.Hash_Table_Type;\n+                   Key : Node_Type) return Boolean is\n+   begin\n+      return Element_Keys.Find (HT, Key.Element) /= 0;\n+   end Is_In;\n+\n+   ---------------\n+   -- Is_Subset --\n+   ---------------\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n+      Subset_Node  : Count_Type;\n+      Subset_Nodes : Nodes_Type renames Subset.HT.Nodes;\n+      To_Node      : Count_Type;\n+   begin\n+      if Subset'Address = Of_Set'Address then\n+         return True;\n+      end if;\n+\n+      if Length (Subset) > Length (Of_Set) then\n+         return False;\n+      end if;\n+\n+      Subset_Node := First (Subset).Node;\n+\n+      if Subset.K = Plain then\n+         To_Node := 0;\n+      else\n+         To_Node := Subset.HT.Nodes (Subset.Last).Next;\n+      end if;\n+\n+      while Subset_Node /= To_Node loop\n+         declare\n+            N : Node_Type renames Subset_Nodes (Subset_Node);\n+            E : Element_Type renames N.Element;\n+\n+         begin\n+            if Find (Of_Set, E).Node = 0 then\n+               return False;\n+            end if;\n+         end;\n+\n+         Subset_Node := HT_Ops.Next (Subset.HT.all, Subset_Node);\n+      end loop;\n+\n+      return True;\n+   end Is_Subset;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   :\n+      not null access procedure (Container : Set; Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Count_Type);\n+      pragma Inline (Process_Node);\n+\n+      procedure Iterate is\n+        new HT_Ops.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Count_Type) is\n+      begin\n+         Process (Container, (Node => Node));\n+      end Process_Node;\n+\n+      B : Natural renames Container'Unrestricted_Access.HT.Busy;\n+\n+      --  Start of processing for Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         case Container.K is\n+            when Plain =>\n+               Iterate (Container.HT.all);\n+            when Part =>\n+\n+               if Container.Length = 0 then\n+                  return;\n+               end if;\n+\n+               declare\n+                  Node : Count_Type := Container.First;\n+               begin\n+                  while Node /= Container.HT.Nodes (Container.Last).Next loop\n+                     Process_Node (Node);\n+                     Node := HT_Ops.Next (Container.HT.all, Node);\n+                  end loop;\n+               end;\n+         end case;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate;\n+\n+   ----------\n+   -- Left --\n+   ----------\n+\n+   function Left (Container : Set; Position : Cursor) return Set is\n+      Lst : Count_Type;\n+      Fst : constant Count_Type := First (Container).Node;\n+      L   : Count_Type := 0;\n+      C   : Count_Type := Fst;\n+   begin\n+      while C /= Position.Node loop\n+         if C = 0 or C = Container.Last then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+         Lst := C;\n+         C := HT_Ops.Next (Container.HT.all, C);\n+         L := L + 1;\n+      end loop;\n+      if L = 0 then\n+         return (Capacity => Container.Capacity,\n+                 Modulus  => Container.Modulus,\n+                 K        => Part,\n+                 HT       => Container.HT,\n+                 Length   => 0,\n+                 First    => 0,\n+                 Last     => 0);\n+      else\n+         return (Capacity => Container.Capacity,\n+                 Modulus  => Container.Modulus,\n+                 K        => Part,\n+                 HT       => Container.HT,\n+                 Length   => L,\n+                 First    => Fst,\n+                 Last     => Lst);\n+      end if;\n+   end Left;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Set) return Count_Type is\n+   begin\n+      case Container.K is\n+         when Plain =>\n+            return Container.HT.Length;\n+         when Part =>\n+            return Container.Length;\n+      end case;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out Set; Source : in out Set) is\n+      HT   : HT_Types.Hash_Table_Type renames Source.HT.all;\n+      NN   : HT_Types.Nodes_Type renames HT.Nodes;\n+      X, Y : Count_Type;\n+\n+   begin\n+\n+      if Target.K /= Plain or Source.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Length (Source) then\n+         raise Constraint_Error with  -- ???\n+           \"Source length exceeds Target capacity\";\n+      end if;\n+\n+      if HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Source (list is busy)\";\n+      end if;\n+\n+      Clear (Target);\n+\n+      if HT.Length = 0 then\n+         return;\n+      end if;\n+\n+      X := HT_Ops.First (HT);\n+      while X /= 0 loop\n+         Insert (Target, NN (X).Element);  -- optimize???\n+\n+         Y := HT_Ops.Next (HT, X);\n+\n+         HT_Ops.Delete_Node_Sans_Free (HT, X);\n+         Free (HT, X);\n+\n+         X := Y;\n+      end loop;\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Next;\n+   end Next;\n+\n+   function Next_Unchecked\n+     (Container : Set;\n+      Position  : Cursor) return Cursor\n+   is\n+      HT   : Hash_Table_Type renames Container.HT.all;\n+      Node : constant Count_Type := HT_Ops.Next (HT, Position.Node);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if Container.K = Part and then Container.Last = Position.Node then\n+         return No_Element;\n+      end if;\n+\n+      return (Node => Node);\n+   end Next_Unchecked;\n+\n+   function Next (Container : Set; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error\n+           with \"Position has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position), \"bad cursor in Next\");\n+\n+      return Next_Unchecked (Container, Position);\n+   end Next;\n+\n+   procedure Next (Container : Set; Position : in out Cursor) is\n+   begin\n+      Position := Next (Container, Position);\n+   end Next;\n+\n+   -------------\n+   -- Overlap --\n+   -------------\n+\n+   function Overlap (Left, Right : Set) return Boolean is\n+      Left_Node  : Count_Type;\n+      Left_Nodes : Nodes_Type renames Left.HT.Nodes;\n+      To_Node    : Count_Type;\n+   begin\n+      if Length (Right) = 0 or Length (Left) = 0 then\n+         return False;\n+      end if;\n+\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      Left_Node := First (Left).Node;\n+\n+      if Left.K = Plain then\n+         To_Node := 0;\n+      else\n+         To_Node := Left.HT.Nodes (Left.Last).Next;\n+      end if;\n+\n+      while Left_Node /= To_Node loop\n+         declare\n+            N : Node_Type renames Left_Nodes (Left_Node);\n+            E : Element_Type renames N.Element;\n+\n+         begin\n+            if Find (Right, E).Node /= 0 then\n+               return True;\n+            end if;\n+         end;\n+\n+         Left_Node := HT_Ops.Next (Left.HT.all, Left_Node);\n+      end loop;\n+\n+      return False;\n+   end Overlap;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position), \"bad cursor in Query_Element\");\n+\n+      declare\n+         HT : Hash_Table_Type renames Container.HT.all;\n+\n+         B : Natural renames HT.Busy;\n+         L : Natural renames HT.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         begin\n+            Process (HT.Nodes (Position.Node).Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Set)\n+   is\n+      function Read_Node (Stream : not null access Root_Stream_Type'Class)\n+                          return Count_Type;\n+\n+      procedure Read_Nodes is\n+        new HT_Ops.Generic_Read (Read_Node);\n+\n+      ---------------\n+      -- Read_Node --\n+      ---------------\n+\n+      function Read_Node (Stream : not null access Root_Stream_Type'Class)\n+                          return Count_Type\n+      is\n+         procedure Read_Element (Node : in out Node_Type);\n+         pragma Inline (Read_Element);\n+\n+         procedure Allocate is\n+           new Generic_Allocate (Read_Element);\n+\n+         procedure Read_Element (Node : in out Node_Type) is\n+         begin\n+            Element_Type'Read (Stream, Node.Element);\n+         end Read_Element;\n+\n+         Node : Count_Type;\n+\n+         --  Start of processing for Read_Node\n+\n+      begin\n+         Allocate (Container.HT.all, Node);\n+         return Node;\n+      end Read_Node;\n+\n+      --  Start of processing for Read\n+      Result : HT_Access;\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Container.HT = null then\n+         Result := new HT_Types.Hash_Table_Type (Container.Capacity,\n+                                                 Container.Modulus);\n+      else\n+         Result := Container.HT;\n+      end if;\n+\n+      Read_Nodes (Stream, Result.all);\n+      Container.HT := Result;\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream set cursor\";\n+   end Read;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Node : constant Count_Type :=\n+        Element_Keys.Find (Container.HT.all, New_Item);\n+\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"attempt to replace element not in set\";\n+      end if;\n+\n+      if Container.HT.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is locked)\";\n+      end if;\n+\n+      Container.HT.Nodes (Node).Element := New_Item;\n+   end Replace;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position),\n+                     \"bad cursor in Replace_Element\");\n+\n+      Replace_Element (Container.HT.all, Position.Node, New_Item);\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Set;\n+      Capacity  : Count_Type)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+      if Capacity > Container.Capacity then\n+         raise Constraint_Error with \"requested capacity is too large\";\n+      end if;\n+   end Reserve_Capacity;\n+\n+   -----------\n+   -- Right --\n+   -----------\n+\n+   function Right (Container : Set; Position : Cursor) return Set is\n+      Last : Count_Type;\n+      Lst  : Count_Type;\n+      L    : Count_Type := 0;\n+      C    : Count_Type := Position.Node;\n+   begin\n+\n+      if C = 0 then\n+         return (Capacity => Container.Capacity,\n+                 Modulus  => Container.Modulus,\n+                 K        => Part,\n+                 HT       => Container.HT,\n+                 Length   => 0,\n+                 First    => 0,\n+                 Last     => 0);\n+      end if;\n+\n+      if Container.K = Plain then\n+         Lst := 0;\n+      else\n+         Lst := HT_Ops.Next (Container.HT.all, Container.Last);\n+      end if;\n+\n+      if C = Lst then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      while C /= Lst loop\n+         if C = 0 then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+         Last := C;\n+         C := HT_Ops.Next (Container.HT.all, C);\n+         L := L + 1;\n+      end loop;\n+\n+      return (Capacity => Container.Capacity,\n+              Modulus  => Container.Modulus,\n+              K        => Part,\n+              HT       => Container.HT,\n+              Length   => L,\n+              First    => Position.Node,\n+              Last     => Last);\n+   end Right;\n+\n+   ------------------\n+   --  Set_Element --\n+   ------------------\n+\n+   procedure Set_Element (Node : in out Node_Type; Item : Element_Type) is\n+   begin\n+      Node.Element := Item;\n+   end Set_Element;\n+\n+   --------------\n+   -- Set_Next --\n+   --------------\n+\n+   procedure Set_Next (Node : in out Node_Type; Next : Count_Type) is\n+   begin\n+      Node.Next := Next;\n+   end Set_Next;\n+\n+   ------------------\n+   -- Strict_Equal --\n+   ------------------\n+\n+   function Strict_Equal (Left, Right : Set) return Boolean is\n+      CuL : Cursor := First (Left);\n+      CuR : Cursor := First (Right);\n+   begin\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      while CuL.Node /= 0 or CuR.Node /= 0 loop\n+         if CuL.Node /= CuR.Node or else\n+           Left.HT.Nodes (CuL.Node).Element /=\n+           Right.HT.Nodes (CuR.Node).Element then\n+            return False;\n+         end if;\n+         CuL := Next_Unchecked (Left, CuL);\n+         CuR := Next_Unchecked (Right, CuR);\n+      end loop;\n+\n+      return True;\n+   end Strict_Equal;\n+\n+   --------------------------\n+   -- Symmetric_Difference --\n+   --------------------------\n+\n+   procedure Symmetric_Difference\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      procedure Process (Source_Node : Count_Type);\n+      pragma Inline (Process);\n+\n+      procedure Iterate is\n+        new HT_Ops.Generic_Iteration (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process (Source_Node : Count_Type) is\n+         N : Node_Type renames Source.HT.Nodes (Source_Node);\n+         X : Count_Type;\n+         B : Boolean;\n+\n+      begin\n+         if Is_In (Target.HT.all, N) then\n+            Delete (Target, N.Element);\n+         else\n+            Insert (Target.HT.all, N.Element, X, B);\n+            pragma Assert (B);\n+         end if;\n+      end Process;\n+\n+      --  Start of processing for Symmetric_Difference\n+\n+   begin\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n+\n+      if Length (Target) = 0 then\n+         Assign (Target, Source);\n+         return;\n+      end if;\n+\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n+      end if;\n+\n+      if Source.K = Plain then\n+         Iterate (Source.HT.all);\n+      else\n+\n+         if Source.Length = 0 then\n+            return;\n+         end if;\n+\n+         declare\n+            Node : Count_Type := Source.First;\n+         begin\n+            while Node /= Source.HT.Nodes (Source.Last).Next loop\n+               Process (Node);\n+               Node := HT_Ops.Next (Source.HT.all, Node);\n+            end loop;\n+         end;\n+      end if;\n+\n+   end Symmetric_Difference;\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set is\n+      C : Count_Type;\n+      H : Hash_Type;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      if Length (Right) = 0 then\n+         return Left.Copy;\n+      end if;\n+\n+      if Length (Left) = 0 then\n+         return Right.Copy;\n+      end if;\n+\n+      C := Length (Left) + Length (Right);\n+      H := Default_Modulus (C);\n+      return S : Set (C, H) do\n+         Difference (Left, Right, S.HT.all);\n+         Difference (Right, Left, S.HT.all);\n+      end return;\n+   end Symmetric_Difference;\n+\n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set (New_Item : Element_Type) return Set is\n+      X : Count_Type;\n+      B : Boolean;\n+\n+   begin\n+      return S : Set (Capacity => 1, Modulus => 1) do\n+         Insert (S.HT.all, New_Item, X, B);\n+         pragma Assert (B);\n+      end return;\n+   end To_Set;\n+\n+   -----------\n+   -- Union --\n+   -----------\n+\n+   procedure Union\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      procedure Process (Src_Node : Count_Type);\n+\n+      procedure Iterate is\n+        new HT_Ops.Generic_Iteration (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process (Src_Node : Count_Type) is\n+         N : Node_Type renames Source.HT.Nodes (Src_Node);\n+         E : Element_Type renames N.Element;\n+\n+         X : Count_Type;\n+         B : Boolean;\n+\n+      begin\n+         Insert (Target.HT.all, E, X, B);\n+      end Process;\n+\n+      --  Start of processing for Union\n+\n+   begin\n+\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n+      end if;\n+\n+      if Source.K = Plain then\n+         Iterate (Source.HT.all);\n+      else\n+\n+         if Source.Length = 0 then\n+            return;\n+         end if;\n+\n+         declare\n+            Node : Count_Type := Source.First;\n+         begin\n+            while Node /= Source.HT.Nodes (Source.Last).Next loop\n+               Process (Node);\n+               Node := HT_Ops.Next (Source.HT.all, Node);\n+            end loop;\n+         end;\n+      end if;\n+   end Union;\n+\n+   function Union (Left, Right : Set) return Set is\n+      C : Count_Type;\n+      H : Hash_Type;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left.Copy;\n+      end if;\n+\n+      if Length (Right) = 0 then\n+         return Left.Copy;\n+      end if;\n+\n+      if Length (Left) = 0 then\n+         return Right.Copy;\n+      end if;\n+\n+      C := Length (Left) + Length (Right);\n+      H := Default_Modulus (C);\n+      return S : Set (C, H) do\n+         Assign (Target => S, Source => Left);\n+         Union (Target => S, Source => Right);\n+      end return;\n+   end Union;\n+\n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Container : Set; Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 then\n+         return True;\n+      end if;\n+\n+      declare\n+         S : Set renames Container;\n+         N : Nodes_Type renames S.HT.Nodes;\n+         X : Count_Type;\n+\n+      begin\n+         if S.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if Position.Node > N'Last then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Next = Position.Node then\n+            return False;\n+         end if;\n+\n+         X := S.HT.Buckets (Element_Keys.Index (S.HT.all,\n+           N (Position.Node).Element));\n+\n+         for J in 1 .. S.Length loop\n+            if X = Position.Node then\n+               return True;\n+            end if;\n+\n+            if X = 0 then\n+               return False;\n+            end if;\n+\n+            if X = N (X).Next then  --  to prevent unnecessary looping\n+               return False;\n+            end if;\n+\n+            X := N (X).Next;\n+         end loop;\n+\n+         return False;\n+      end;\n+   end Vet;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Set)\n+   is\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type);\n+      pragma Inline (Write_Node);\n+\n+      procedure Write_Nodes is\n+        new HT_Ops.Generic_Write (Write_Node);\n+\n+      ----------------\n+      -- Write_Node --\n+      ----------------\n+\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type)\n+      is\n+      begin\n+         Element_Type'Write (Stream, Node.Element);\n+      end Write_Node;\n+\n+      --  Start of processing for Write\n+\n+   begin\n+      Write_Nodes (Stream, Container.HT.all);\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream set cursor\";\n+   end Write;\n+   package body Generic_Keys is\n+\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n+\n+      function Equivalent_Key_Node\n+        (Key  : Key_Type;\n+         Node : Node_Type) return Boolean;\n+      pragma Inline (Equivalent_Key_Node);\n+\n+      --------------------------\n+      -- Local Instantiations --\n+      --------------------------\n+\n+      package Key_Keys is\n+        new Hash_Tables.Generic_Bounded_Keys\n+          (HT_Types        => HT_Types,\n+           Next            => Next,\n+           Set_Next        => Set_Next,\n+           Key_Type        => Key_Type,\n+           Hash            => Hash,\n+           Equivalent_Keys => Equivalent_Key_Node);\n+\n+      --------------\n+      -- Contains --\n+      --------------\n+\n+      function Contains\n+        (Container : Set;\n+         Key       : Key_Type) return Boolean\n+      is\n+      begin\n+         return Find (Container, Key) /= No_Element;\n+      end Contains;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete\n+        (Container : in out Set;\n+         Key       : Key_Type)\n+      is\n+         X : Count_Type;\n+\n+      begin\n+         if Container.K /= Plain then\n+            raise Constraint_Error\n+              with \"Can't modify part of container\";\n+         end if;\n+\n+         Key_Keys.Delete_Key_Sans_Free (Container.HT.all, Key, X);\n+\n+         if X = 0 then\n+            raise Constraint_Error with \"attempt to delete key not in set\";\n+         end if;\n+\n+         Free (Container.HT.all, X);\n+      end Delete;\n+\n+      -------------\n+      -- Element --\n+      -------------\n+\n+      function Element\n+        (Container : Set;\n+         Key       : Key_Type) return Element_Type\n+      is\n+         Node : constant Count_Type := Find (Container, Key).Node;\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with \"key not in map\";\n+         end if;\n+\n+         return Container.HT.Nodes (Node).Element;\n+      end Element;\n+\n+      -------------------------\n+      -- Equivalent_Key_Node --\n+      -------------------------\n+\n+      function Equivalent_Key_Node\n+        (Key  : Key_Type;\n+         Node : Node_Type) return Boolean\n+      is\n+      begin\n+         return Equivalent_Keys (Key, Generic_Keys.Key (Node.Element));\n+      end Equivalent_Key_Node;\n+\n+      -------------\n+      -- Exclude --\n+      -------------\n+\n+      procedure Exclude\n+        (Container : in out Set;\n+         Key       : Key_Type)\n+      is\n+         X : Count_Type;\n+      begin\n+         if Container.K /= Plain then\n+            raise Constraint_Error\n+              with \"Can't modify part of container\";\n+         end if;\n+\n+         Key_Keys.Delete_Key_Sans_Free (Container.HT.all, Key, X);\n+         Free (Container.HT.all, X);\n+      end Exclude;\n+\n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find\n+        (Container : Set;\n+         Key       : Key_Type) return Cursor\n+      is\n+      begin\n+         if Container.K = Plain then\n+            declare\n+               Node : constant Count_Type :=\n+                 Key_Keys.Find (Container.HT.all, Key);\n+\n+            begin\n+               if Node = 0 then\n+                  return No_Element;\n+               end if;\n+\n+               return (Node => Node);\n+            end;\n+         else\n+            declare\n+               function Find_Between\n+                 (HT   : Hash_Table_Type;\n+                  Key  : Key_Type;\n+                  From : Count_Type;\n+                  To   : Count_Type) return Count_Type;\n+\n+               function Find_Between\n+                 (HT   : Hash_Table_Type;\n+                  Key  : Key_Type;\n+                  From : Count_Type;\n+                  To   : Count_Type) return Count_Type is\n+\n+                  Indx      : Hash_Type;\n+                  Indx_From : constant Hash_Type :=\n+                    Key_Keys.Index (HT, Generic_Keys.Key\n+                                    (HT.Nodes (From).Element));\n+                  Indx_To   : constant Hash_Type :=\n+                    Key_Keys.Index (HT, Generic_Keys.Key\n+                                    (HT.Nodes (To).Element));\n+                  Node      : Count_Type;\n+                  To_Node   : Count_Type;\n+\n+               begin\n+\n+                  Indx := Key_Keys.Index (HT, Key);\n+\n+                  if Indx < Indx_From or Indx > Indx_To then\n+                     return 0;\n+                  end if;\n+\n+                  if Indx = Indx_From then\n+                     Node := From;\n+                  else\n+                     Node := HT.Buckets (Indx);\n+                  end if;\n+\n+                  if Indx = Indx_To then\n+                     To_Node := HT.Nodes (To).Next;\n+                  else\n+                     To_Node := 0;\n+                  end if;\n+\n+                  while Node /= To_Node loop\n+                     if Equivalent_Key_Node (Key, HT.Nodes (Node)) then\n+                        return Node;\n+                     end if;\n+                     Node := HT.Nodes (Node).Next;\n+                  end loop;\n+\n+                  return 0;\n+               end Find_Between;\n+\n+            begin\n+               if Container.Length = 0 then\n+                  return No_Element;\n+               end if;\n+\n+               return (Node => Find_Between (Container.HT.all, Key,\n+                       Container.First, Container.Last));\n+            end;\n+         end if;\n+      end Find;\n+\n+      ---------\n+      -- Key --\n+      ---------\n+\n+      function Key (Container : Set; Position : Cursor) return Key_Type is\n+      begin\n+         if not Has_Element (Container, Position) then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+\n+         pragma Assert (Vet (Container, Position),\n+                        \"bad cursor in function Key\");\n+\n+         declare\n+            HT : Hash_Table_Type renames Container.HT.all;\n+            N  : Node_Type renames HT.Nodes (Position.Node);\n+         begin\n+            return Key (N.Element);\n+         end;\n+      end Key;\n+\n+      -------------\n+      -- Replace --\n+      -------------\n+\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type)\n+      is\n+      begin\n+         if Container.K /= Plain then\n+            raise Constraint_Error\n+              with \"Can't modify part of container\";\n+         end if;\n+\n+         declare\n+            Node : constant Count_Type :=\n+              Key_Keys.Find (Container.HT.all, Key);\n+\n+         begin\n+            if Node = 0 then\n+               raise Constraint_Error with\n+                 \"attempt to replace key not in set\";\n+            end if;\n+\n+            Replace_Element (Container.HT.all, Node, New_Item);\n+         end;\n+      end Replace;\n+\n+      -----------------------------------\n+      -- Update_Element_Preserving_Key --\n+      -----------------------------------\n+\n+      procedure Update_Element_Preserving_Key\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+           procedure (Element : in out Element_Type))\n+      is\n+         Indx : Hash_Type;\n+         N    : Nodes_Type renames Container.HT.Nodes;\n+\n+      begin\n+\n+         if Container.K /= Plain then\n+            raise Constraint_Error\n+              with \"Can't modify part of container\";\n+         end if;\n+\n+         if Position.Node = 0 then\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n+         end if;\n+\n+         --  ???\n+         --  if HT.Buckets = null\n+         --    or else HT.Buckets'Length = 0\n+         --    or else HT.Length = 0\n+         --    or else Position.Node.Next = Position.Node\n+         --  then\n+         --     raise Program_Error with\n+         --        \"Position cursor is bad (set is empty)\";\n+         --  end if;\n+\n+         pragma Assert\n+           (Vet (Container, Position),\n+            \"bad cursor in Update_Element_Preserving_Key\");\n+\n+         --  Record bucket now, in case key is changed.\n+         Indx := HT_Ops.Index (Container.HT.Buckets, N (Position.Node));\n+\n+         declare\n+            E : Element_Type renames N (Position.Node).Element;\n+            K : constant Key_Type := Key (E);\n+\n+            B : Natural renames Container.HT.Busy;\n+            L : Natural renames Container.HT.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            begin\n+               Process (E);\n+            exception\n+               when others =>\n+                  L := L - 1;\n+                  B := B - 1;\n+                  raise;\n+            end;\n+\n+            L := L - 1;\n+            B := B - 1;\n+\n+            if Equivalent_Keys (K, Key (E)) then\n+               pragma Assert (Hash (K) = Hash (E));\n+               return;\n+            end if;\n+         end;\n+\n+         --  Key was modified, so remove this node from set.\n+\n+         if Container.HT.Buckets (Indx) = Position.Node then\n+            Container.HT.Buckets (Indx) := N (Position.Node).Next;\n+\n+         else\n+            declare\n+               Prev : Count_Type := Container.HT.Buckets (Indx);\n+\n+            begin\n+               while N (Prev).Next /= Position.Node loop\n+                  Prev := N (Prev).Next;\n+\n+                  if Prev = 0 then\n+                     raise Program_Error with\n+                       \"Position cursor is bad (node not found)\";\n+                  end if;\n+               end loop;\n+\n+               N (Prev).Next := N (Position.Node).Next;\n+            end;\n+         end if;\n+\n+         Container.Length := Container.Length - 1;\n+         Free (Container.HT.all, Position.Node);\n+\n+         raise Program_Error with \"key was modified\";\n+      end Update_Element_Preserving_Key;\n+\n+   end Generic_Keys;\n+\n+end Ada.Containers.Formal_Hashed_Sets;"}, {"sha": "2a6a613b3da352eb579986027149b503d119543b", "filename": "gcc/ada/a-cfhase.ads", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,284 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--    A D A . C O N T A I N E R S . F O R M A L _ H A S H E D _ S E T S     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Containers.Hash_Tables;\n+private with Ada.Streams;\n+\n+with Ada.Containers;\n+use Ada.Containers;\n+\n+generic\n+   type Element_Type is private;\n+\n+   with function Hash (Element : Element_Type) return Hash_Type;\n+\n+   with function Equivalent_Elements (Left, Right : Element_Type)\n+                                      return Boolean;\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Formal_Hashed_Sets is\n+   pragma Pure;\n+\n+   type Set (Capacity : Count_Type; Modulus : Hash_Type) is tagged private;\n+   --  pragma Preelaborable_Initialization (Set);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Set : constant Set;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Set) return Boolean;\n+\n+   function Equivalent_Sets (Left, Right : Set) return Boolean;\n+\n+   function To_Set (New_Item : Element_Type) return Set;\n+\n+   function Capacity (Container : Set) return Count_Type;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Set;\n+      Capacity  : Count_Type);\n+\n+   function Length (Container : Set) return Count_Type;\n+\n+   function Is_Empty (Container : Set) return Boolean;\n+\n+   procedure Clear (Container : in out Set);\n+\n+   procedure Assign (Target : in out Set; Source : Set);\n+\n+   function Copy (Source   : Set;\n+                  Capacity : Count_Type := 0) return Set;\n+\n+   function Element (Container : Set; Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : Element_Type));\n+\n+   procedure Move (Target : in out Set; Source : in out Set);\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert  (Container : in out Set; New_Item : Element_Type);\n+\n+   procedure Include (Container : in out Set; New_Item : Element_Type);\n+\n+   procedure Replace (Container : in out Set; New_Item : Element_Type);\n+\n+   procedure Exclude (Container : in out Set; Item     : Element_Type);\n+\n+   procedure Delete  (Container : in out Set; Item     : Element_Type);\n+\n+   procedure Delete (Container : in out Set; Position  : in out Cursor);\n+\n+   procedure Union (Target : in out Set; Source : Set);\n+\n+   function Union (Left, Right : Set) return Set;\n+\n+   function \"or\" (Left, Right : Set) return Set renames Union;\n+\n+   procedure Intersection (Target : in out Set; Source : Set);\n+\n+   function Intersection (Left, Right : Set) return Set;\n+\n+   function \"and\" (Left, Right : Set) return Set renames Intersection;\n+\n+   procedure Difference (Target : in out Set; Source : Set);\n+\n+   function Difference (Left, Right : Set) return Set;\n+\n+   function \"-\" (Left, Right : Set) return Set renames Difference;\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set;\n+\n+   function \"xor\" (Left, Right : Set) return Set\n+                   renames Symmetric_Difference;\n+\n+   function Overlap (Left, Right : Set) return Boolean;\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+\n+   function First (Container : Set) return Cursor;\n+\n+   function Next (Container : Set; Position : Cursor) return Cursor;\n+\n+   procedure Next (Container : Set; Position : in out Cursor);\n+\n+   function Find\n+     (Container : Set;\n+      Item      : Element_Type) return Cursor;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n+   function Has_Element (Container : Set; Position : Cursor) return Boolean;\n+\n+   function Equivalent_Elements (Left  : Set; CLeft : Cursor;\n+                                 Right : Set; CRight : Cursor) return Boolean;\n+\n+   function Equivalent_Elements\n+     (Left  : Set; CLeft : Cursor;\n+      Right : Element_Type) return Boolean;\n+\n+   function Equivalent_Elements\n+     (Left  : Element_Type;\n+      Right : Set; CRight : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   :\n+        not null access procedure (Container : Set; Position : Cursor));\n+\n+   function Default_Modulus (Capacity : Count_Type) return Hash_Type;\n+\n+   generic\n+      type Key_Type (<>) is private;\n+\n+      with function Key (Element : Element_Type) return Key_Type;\n+\n+      with function Hash (Key : Key_Type) return Hash_Type;\n+\n+      with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+\n+   package Generic_Keys is\n+\n+      function Key (Container : Set; Position : Cursor) return Key_Type;\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type;\n+\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type);\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type);\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n+\n+      procedure Update_Element_Preserving_Key\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+           procedure (Element : in out Element_Type));\n+\n+   end Generic_Keys;\n+\n+   function Strict_Equal (Left, Right : Set) return Boolean;\n+\n+   function Left (Container : Set; Position : Cursor) return Set;\n+\n+   function Right (Container : Set; Position : Cursor) return Set;\n+\n+private\n+\n+   pragma Inline (Next);\n+\n+   type Node_Type is\n+      record\n+         Element     : Element_Type;\n+         Next        : Count_Type;\n+         Has_Element : Boolean := False;\n+      end record;\n+\n+   package HT_Types is\n+     new Ada.Containers.Hash_Tables.Generic_Bounded_Hash_Table_Types\n+     (Node_Type);\n+\n+   type HT_Access is access all HT_Types.Hash_Table_Type;\n+\n+   type Kind is (Plain, Part);\n+\n+   type Set (Capacity : Count_Type; Modulus : Hash_Type) is tagged record\n+      HT     : HT_Access :=\n+                 new HT_Types.Hash_Table_Type'(Capacity, Modulus,\n+                                               others => <>);\n+      K      : Kind := Plain;\n+      Length : Count_Type := 0;\n+      First  : Count_Type := 0;\n+      Last   : Count_Type := 0;\n+   end record;\n+\n+   use HT_Types;\n+   use Ada.Streams;\n+\n+   type Cursor is\n+      record\n+         Node      : Count_Type;\n+      end record;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := (Node => 0);\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Set);\n+\n+   for Set'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Set);\n+\n+   for Set'Read use Read;\n+\n+   Empty_Set : constant Set := (Capacity => 0, Modulus => 0, others => <>);\n+\n+end Ada.Containers.Formal_Hashed_Sets;"}, {"sha": "705fd618e9f0c4381ab12adbad7c5a105cbd1e3a", "filename": "gcc/ada/a-cforma.adb", "status": "added", "additions": 1737, "deletions": 0, "changes": 1737, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,1737 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . C O N T A I N E R S . F O R M A L _ O R D E R E D _ M A P S    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;\n+pragma Elaborate_All\n+  (Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations);\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys;\n+pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys);\n+\n+with System; use type System.Address;\n+\n+package body Ada.Containers.Formal_Ordered_Maps is\n+\n+   -----------------------------\n+   -- Node Access Subprograms --\n+   -----------------------------\n+\n+   --  These subprograms provide a functional interface to access fields\n+   --  of a node, and a procedural interface for modifying these values.\n+\n+   function Color (Node : Node_Type)\n+                   return Ada.Containers.Red_Black_Trees.Color_Type;\n+   pragma Inline (Color);\n+\n+   function Left_Son (Node : Node_Type) return Count_Type;\n+   pragma Inline (Left);\n+\n+   function Parent (Node : Node_Type) return Count_Type;\n+   pragma Inline (Parent);\n+\n+   function Right_Son (Node : Node_Type) return Count_Type;\n+   pragma Inline (Right);\n+\n+   procedure Set_Color\n+     (Node  : in out Node_Type;\n+      Color : Ada.Containers.Red_Black_Trees.Color_Type);\n+   pragma Inline (Set_Color);\n+\n+   procedure Set_Left (Node : in out Node_Type; Left : Count_Type);\n+   pragma Inline (Set_Left);\n+\n+   procedure Set_Right (Node : in out Node_Type; Right : Count_Type);\n+   pragma Inline (Set_Right);\n+\n+   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type);\n+   pragma Inline (Set_Parent);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   generic\n+      with procedure Set_Element (Node : in out Node_Type);\n+   procedure Generic_Allocate\n+     (Tree : in out Tree_Types.Tree_Type'Class;\n+      Node : out Count_Type);\n+\n+   procedure Free (Tree : in out Tree_Types.Tree_Type; X : Count_Type);\n+\n+   function Is_Greater_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Type) return Boolean;\n+   pragma Inline (Is_Greater_Key_Node);\n+\n+   function Is_Less_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Type) return Boolean;\n+   pragma Inline (Is_Less_Key_Node);\n+\n+   function Next_Unchecked\n+     (Container : Map;\n+      Position  : Count_Type) return Count_Type;\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   package Tree_Operations is\n+     new Red_Black_Trees.Generic_Bounded_Operations\n+       (Tree_Types => Tree_Types,\n+        Left      => Left_Son,\n+        Right     => Right_Son);\n+\n+   use Tree_Operations;\n+\n+   package Key_Ops is\n+     new Red_Black_Trees.Generic_Bounded_Keys\n+       (Tree_Operations     => Tree_Operations,\n+        Key_Type            => Key_Type,\n+        Is_Less_Key_Node    => Is_Less_Key_Node,\n+        Is_Greater_Key_Node => Is_Greater_Key_Node);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Map) return Boolean is\n+      Lst   : Count_Type;\n+      Node  : Count_Type := First (Left).Node;\n+      ENode : Count_Type;\n+   begin\n+\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      if Is_Empty (Left) then\n+         return True;\n+      end if;\n+\n+      Lst := Next (Left.Tree.all, Last (Left).Node);\n+      while Node /= Lst loop\n+         ENode := Find (Right, Left.Tree.Nodes (Node).Key).Node;\n+         if ENode = 0 or else\n+           Left.Tree.Nodes (Node).Element /= Right.Tree.Nodes (ENode).Element\n+         then\n+            return False;\n+         end if;\n+         Node := Next (Left.Tree.all, Node);\n+      end loop;\n+\n+      return True;\n+\n+   end \"=\";\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Map; Source : Map) is\n+      procedure Append_Element (Source_Node : Count_Type);\n+\n+      procedure Append_Elements is\n+         new Tree_Operations.Generic_Iteration (Append_Element);\n+\n+      --------------------\n+      -- Append_Element --\n+      --------------------\n+\n+      procedure Append_Element (Source_Node : Count_Type) is\n+         SN : Node_Type renames Source.Tree.Nodes (Source_Node);\n+\n+         procedure Set_Element (Node : in out Node_Type);\n+         pragma Inline (Set_Element);\n+\n+         function New_Node return Count_Type;\n+         pragma Inline (New_Node);\n+\n+         procedure Insert_Post is\n+            new Key_Ops.Generic_Insert_Post (New_Node);\n+\n+         procedure Unconditional_Insert_Sans_Hint is\n+            new Key_Ops.Generic_Unconditional_Insert (Insert_Post);\n+\n+         procedure Unconditional_Insert_Avec_Hint is\n+            new Key_Ops.Generic_Unconditional_Insert_With_Hint\n+              (Insert_Post,\n+               Unconditional_Insert_Sans_Hint);\n+\n+         procedure Allocate is\n+            new Generic_Allocate (Set_Element);\n+\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Count_Type is\n+            Result : Count_Type;\n+\n+         begin\n+            Allocate (Target.Tree.all, Result);\n+            return Result;\n+         end New_Node;\n+\n+         -----------------\n+         -- Set_Element --\n+         -----------------\n+\n+         procedure Set_Element (Node : in out Node_Type) is\n+         begin\n+            Node.Key := SN.Key;\n+            Node.Element := SN.Element;\n+         end Set_Element;\n+\n+         Target_Node : Count_Type;\n+\n+      --  Start of processing for Append_Element\n+\n+      begin\n+         Unconditional_Insert_Avec_Hint\n+           (Tree  => Target.Tree.all,\n+            Hint  => 0,\n+            Key   => SN.Key,\n+            Node  => Target_Node);\n+      end Append_Element;\n+\n+   --  Start of processing for Assign\n+\n+   begin\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Length (Source) then\n+         raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n+      end if;\n+\n+      Tree_Operations.Clear_Tree (Target.Tree.all);\n+\n+      if Source.K = Plain then\n+         Append_Elements (Source.Tree.all);\n+      else\n+         declare\n+            X : Count_Type;\n+         begin\n+            X := Source.First;\n+            while X /= Next (Source.Tree.all, Source.Last) loop\n+               Append_Element (X);\n+               X := Next (Source.Tree.all, X);\n+            end loop;\n+         end;\n+      end if;\n+   end Assign;\n+\n+   -------------\n+   -- Ceiling --\n+   -------------\n+\n+   function Ceiling (Container : Map; Key : Key_Type) return Cursor is\n+   begin\n+\n+      if Container.K = Part then\n+         if Container.Length = 0 then\n+            return No_Element;\n+         end if;\n+\n+         if Key < Container.Tree.Nodes (Container.First).Key then\n+            return (Node => Container.First);\n+         end if;\n+\n+         if Container.Tree.Nodes (Container.Last).Key < Key then\n+            return No_Element;\n+         end if;\n+      end if;\n+\n+      declare\n+         Node : constant Count_Type :=\n+                  Key_Ops.Ceiling (Container.Tree.all, Key);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return (Node => Node);\n+      end;\n+   end Ceiling;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Map) is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      Tree_Operations.Clear_Tree (Container.Tree.all);\n+   end Clear;\n+\n+   -----------\n+   -- Color --\n+   -----------\n+\n+   function Color (Node : Node_Type) return Color_Type is\n+   begin\n+      return Node.Color;\n+   end Color;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean is\n+   begin\n+      return Find (Container, Key) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy (Source : Map; Capacity : Count_Type := 0) return Map is\n+      Node : Count_Type := 1;\n+      N    : Count_Type;\n+      Cu   : Cursor;\n+   begin\n+      return Target : Map (Count_Type'Max (Source.Capacity, Capacity)) do\n+         if Length (Source) > 0 then\n+            Target.Tree.Length := Source.Tree.Length;\n+            Target.Tree.Root := Source.Tree.Root;\n+            Target.Tree.First := Source.Tree.First;\n+            Target.Tree.Last := Source.Tree.Last;\n+            Target.Tree.Free := Source.Tree.Free;\n+\n+            while Node <= Source.Capacity loop\n+               Target.Tree.Nodes (Node).Element :=\n+                 Source.Tree.Nodes (Node).Element;\n+               Target.Tree.Nodes (Node).Key :=\n+                 Source.Tree.Nodes (Node).Key;\n+               Target.Tree.Nodes (Node).Parent :=\n+                 Source.Tree.Nodes (Node).Parent;\n+               Target.Tree.Nodes (Node).Left :=\n+                 Source.Tree.Nodes (Node).Left;\n+               Target.Tree.Nodes (Node).Right :=\n+                 Source.Tree.Nodes (Node).Right;\n+               Target.Tree.Nodes (Node).Color :=\n+                 Source.Tree.Nodes (Node).Color;\n+               Target.Tree.Nodes (Node).Has_Element :=\n+                 Source.Tree.Nodes (Node).Has_Element;\n+               Node := Node + 1;\n+            end loop;\n+\n+            while Node <= Target.Capacity loop\n+               N := Node;\n+               Formal_Ordered_Maps.Free (Tree => Target.Tree.all, X => N);\n+               Node := Node + 1;\n+            end loop;\n+\n+            if Source.K = Part then\n+               Node := Target.Tree.First;\n+               while Node /= Source.First loop\n+                  Cu := (Node => Node);\n+                  Node := Next (Target.Tree.all, Node);\n+                  Delete (Target, Cu);\n+               end loop;\n+\n+               Node := Next (Target.Tree.all, Source.Last);\n+\n+               while Node /= 0 loop\n+                  Cu := (Node => Node);\n+                  Node := Next (Target.Tree.all, Node);\n+                  Delete (Target, Cu);\n+               end loop;\n+            end if;\n+         end if;\n+      end return;\n+   end Copy;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor) is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of Delete has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"Position cursor of Delete is bad\");\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all,\n+                                             Position.Node);\n+      Formal_Ordered_Maps.Free (Container.Tree.all, Position.Node);\n+   end Delete;\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type) is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+      declare\n+         X : constant Node_Access := Key_Ops.Find (Container.Tree.all, Key);\n+\n+      begin\n+         if X = 0 then\n+            raise Constraint_Error with \"key not in map\";\n+         end if;\n+\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n+         Formal_Ordered_Maps.Free (Container.Tree.all, X);\n+      end;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First (Container : in out Map) is\n+      X : constant Node_Access := First (Container).Node;\n+\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n+         Formal_Ordered_Maps.Free (Container.Tree.all, X);\n+      end if;\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last (Container : in out Map) is\n+      X : constant Node_Access := Last (Container).Node;\n+\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n+         Formal_Ordered_Maps.Free (Container.Tree.all, X);\n+      end if;\n+   end Delete_Last;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Container : Map; Position : Cursor) return Element_Type is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of function Element has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"Position cursor of function Element is bad\");\n+\n+      return Container.Tree.Nodes (Position.Node).Element;\n+\n+   end Element;\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type is\n+      Node : constant Node_Access := Find (Container, Key).Node;\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      return Container.Tree.Nodes (Node).Element;\n+   end Element;\n+\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n+\n+   function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n+   begin\n+      if Left < Right\n+        or else Right < Left\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Equivalent_Keys;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type) is\n+      X : constant Node_Access := Key_Ops.Find (Container.Tree.all, Key);\n+\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n+         Formal_Ordered_Maps.Free (Container.Tree.all, X);\n+      end if;\n+   end Exclude;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor is\n+   begin\n+      if Container.K = Part then\n+         if Container.Length = 0 then\n+            return No_Element;\n+         end if;\n+\n+         if Key < Container.Tree.Nodes (Container.First).Key or\n+           Container.Tree.Nodes (Container.Last).Key < Key then\n+            return No_Element;\n+         end if;\n+      end if;\n+\n+      declare\n+         Node : constant Count_Type :=\n+                  Key_Ops.Find (Container.Tree.all, Key);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return (Node => Node);\n+      end;\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Map) return Cursor is\n+   begin\n+      if Length (Container) = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if Container.K = Plain then\n+         return (Node => Container.Tree.First);\n+      else\n+         return (Node => Container.First);\n+      end if;\n+\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : Map) return Element_Type is\n+   begin\n+      if Is_Empty (Container) then\n+         raise Constraint_Error with \"map is empty\";\n+      end if;\n+\n+      return Container.Tree.Nodes (First (Container).Node).Element;\n+   end First_Element;\n+\n+   ---------------\n+   -- First_Key --\n+   ---------------\n+\n+   function First_Key (Container : Map) return Key_Type is\n+   begin\n+      if Is_Empty (Container) then\n+         raise Constraint_Error with \"map is empty\";\n+      end if;\n+\n+      return Container.Tree.Nodes (First (Container).Node).Key;\n+   end First_Key;\n+\n+   -----------\n+   -- Floor --\n+   -----------\n+\n+   function Floor (Container : Map; Key : Key_Type) return Cursor is\n+   begin\n+\n+      if Container.K = Part then\n+         if Container.Length = 0 then\n+            return No_Element;\n+         end if;\n+\n+         if Key < Container.Tree.Nodes (Container.First).Key then\n+            return No_Element;\n+         end if;\n+\n+         if Container.Tree.Nodes (Container.Last).Key < Key then\n+            return (Node => Container.Last);\n+         end if;\n+      end if;\n+\n+      declare\n+         Node : constant Count_Type :=\n+                  Key_Ops.Floor (Container.Tree.all, Key);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return (Node => Node);\n+      end;\n+   end Floor;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free\n+     (Tree : in out Tree_Types.Tree_Type;\n+      X  : Count_Type)\n+   is\n+   begin\n+      Tree.Nodes (X).Has_Element := False;\n+      Tree_Operations.Free (Tree, X);\n+   end Free;\n+\n+   ----------------------\n+   -- Generic_Allocate --\n+   ----------------------\n+\n+   procedure Generic_Allocate\n+     (Tree : in out Tree_Types.Tree_Type'Class;\n+      Node : out Count_Type)\n+   is\n+\n+      procedure Allocate is\n+        new Tree_Operations.Generic_Allocate (Set_Element);\n+\n+   begin\n+      Allocate (Tree, Node);\n+      Tree.Nodes (Node).Has_Element := True;\n+   end Generic_Allocate;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Container : Map; Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 then\n+         return False;\n+      end if;\n+\n+      if not Container.Tree.Nodes (Position.Node).Has_Element then\n+         return False;\n+      end if;\n+\n+      if Container.K = Plain then\n+         return True;\n+      end if;\n+\n+      declare\n+         Key : constant Key_Type := Container.Tree.Nodes (Position.Node).Key;\n+      begin\n+\n+         if Key < Container.Tree.Nodes (Container.First).Key or\n+           Container.Tree.Nodes (Container.Last).Key < Key then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end;\n+   end Has_Element;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         if Container.Tree.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (map is locked)\";\n+         end if;\n+\n+         declare\n+            N : Node_Type renames Container.Tree.Nodes (Position.Node);\n+         begin\n+            N.Key := Key;\n+            N.Element := New_Item;\n+         end;\n+      end if;\n+   end Include;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      declare\n+         function New_Node return Node_Access;\n+\n+         procedure Insert_Post is\n+           new Key_Ops.Generic_Insert_Post (New_Node);\n+\n+         procedure Insert_Sans_Hint is\n+           new Key_Ops.Generic_Conditional_Insert (Insert_Post);\n+\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Node_Access is\n+            procedure Initialize (Node : in out Node_Type);\n+            procedure Allocate_Node is new Generic_Allocate (Initialize);\n+\n+            procedure Initialize (Node : in out Node_Type) is\n+            begin\n+               Node.Key := Key;\n+               Node.Element := New_Item;\n+            end Initialize;\n+\n+            X : Node_Access;\n+\n+         begin\n+            Allocate_Node (Container.Tree.all, X);\n+            return X;\n+         end New_Node;\n+\n+         --  Start of processing for Insert\n+\n+      begin\n+         Insert_Sans_Hint\n+           (Container.Tree.all,\n+            Key,\n+            Position.Node,\n+            Inserted);\n+      end;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error with \"key already in map\";\n+      end if;\n+   end Insert;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      declare\n+         function New_Node return Node_Access;\n+\n+         procedure Insert_Post is\n+           new Key_Ops.Generic_Insert_Post (New_Node);\n+\n+         procedure Insert_Sans_Hint is\n+           new Key_Ops.Generic_Conditional_Insert (Insert_Post);\n+\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Node_Access is\n+            procedure Initialize (Node : in out Node_Type);\n+            procedure Allocate_Node is new Generic_Allocate (Initialize);\n+\n+            procedure Initialize (Node : in out Node_Type) is\n+            begin\n+               Node.Key := Key;\n+            end Initialize;\n+\n+            X : Node_Access;\n+\n+         begin\n+            Allocate_Node (Container.Tree.all, X);\n+            return X;\n+         end New_Node;\n+\n+         --  Start of processing for Insert\n+\n+      begin\n+         Insert_Sans_Hint\n+           (Container.Tree.all,\n+            Key,\n+            Position.Node,\n+            Inserted);\n+      end;\n+   end Insert;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Map) return Boolean is\n+   begin\n+      return Length (Container) = 0;\n+   end Is_Empty;\n+\n+   -------------------------\n+   -- Is_Greater_Key_Node --\n+   -------------------------\n+\n+   function Is_Greater_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Type) return Boolean\n+   is\n+   begin\n+      --  k > node same as node < k\n+\n+      return Right.Key < Left;\n+   end Is_Greater_Key_Node;\n+\n+   ----------------------\n+   -- Is_Less_Key_Node --\n+   ----------------------\n+\n+   function Is_Less_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Type) return Boolean\n+   is\n+   begin\n+      return Left < Right.Key;\n+   end Is_Less_Key_Node;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   :\n+        not null access procedure (Container : Map; Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Iterate is\n+        new Tree_Operations.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Container, (Node => Node));\n+      end Process_Node;\n+\n+      B : Natural renames Container.Tree.all.Busy;\n+\n+      --  Start of processing for Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+\n+         if Container.K = Plain then\n+            Local_Iterate (Container.Tree.all);\n+            return;\n+         end if;\n+\n+         if Container.Length = 0 then\n+            return;\n+         end if;\n+\n+         declare\n+            FElt : constant Key_Type :=\n+              Container.Tree.Nodes (Container.First).Key;\n+            TElt : constant Key_Type :=\n+              Container.Tree.Nodes (Container.Last).Key;\n+\n+            procedure Iterate (P : Count_Type);\n+\n+            procedure Iterate (P : Count_Type) is\n+               X : Count_Type := P;\n+            begin\n+               while X /= 0 loop\n+                  if Container.Tree.Nodes (X).Key < FElt then\n+                     X := Container.Tree.Nodes (X).Right;\n+                  elsif TElt < Container.Tree.Nodes (X).Key then\n+                     X := Container.Tree.Nodes (X).Left;\n+                  else\n+                     Iterate (Container.Tree.Nodes (X).Left);\n+                     Process_Node (X);\n+                     X := Container.Tree.Nodes (X).Right;\n+                  end if;\n+               end loop;\n+            end Iterate;\n+\n+         begin\n+            Iterate (Container.Tree.Root);\n+         end;\n+\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate;\n+\n+   ---------\n+   -- Key --\n+   ---------\n+\n+   function Key (Container : Map; Position : Cursor) return Key_Type is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of function Key has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"Position cursor of function Key is bad\");\n+\n+      return Container.Tree.Nodes (Position.Node).Key;\n+   end Key;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : Map) return Cursor is\n+   begin\n+      if Length (Container) = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if Container.K = Plain then\n+         return (Node => Container.Tree.Last);\n+      end if;\n+\n+      return (Node => Container.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : Map) return Element_Type is\n+   begin\n+      if Is_Empty (Container) then\n+         raise Constraint_Error with \"map is empty\";\n+      end if;\n+\n+      return Container.Tree.Nodes (Last (Container).Node).Element;\n+   end Last_Element;\n+\n+   --------------\n+   -- Last_Key --\n+   --------------\n+\n+   function Last_Key (Container : Map) return Key_Type is\n+   begin\n+      if Is_Empty (Container) then\n+         raise Constraint_Error with \"map is empty\";\n+      end if;\n+\n+      return Container.Tree.Nodes (Last (Container).Node).Key;\n+   end Last_Key;\n+\n+   ----------\n+   -- Left --\n+   ----------\n+\n+   function Left (Container : Map; Position : Cursor) return Map is\n+      Lst : Count_Type;\n+      Fst : constant Count_Type := First (Container).Node;\n+      L   : Count_Type := 0;\n+      C   : Count_Type := Fst;\n+   begin\n+      while C /= Position.Node loop\n+         if C = Last (Container).Node or C = 0 then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+         Lst := C;\n+         C := Next (Container.Tree.all, C);\n+         L := L + 1;\n+      end loop;\n+      if L = 0 then\n+         return (Capacity => Container.Capacity,\n+                 K        => Part,\n+                 Tree     => Container.Tree,\n+                 Length   => 0,\n+                 First    => 0,\n+                 Last     => 0);\n+      else\n+         return (Capacity => Container.Capacity,\n+                 K        => Part,\n+                 Tree     => Container.Tree,\n+                 Length   => L,\n+                 First    => Fst,\n+                 Last     => Lst);\n+      end if;\n+   end Left;\n+\n+   --------------\n+   -- Left_Son --\n+   --------------\n+\n+   function Left_Son (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Left;\n+   end Left_Son;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Map) return Count_Type is\n+   begin\n+      if Container.K = Plain then\n+         return Container.Tree.Length;\n+      else\n+         return Container.Length;\n+      end if;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out Map; Source : in out Map) is\n+      NN : Tree_Types.Nodes_Type renames Source.Tree.Nodes;\n+      X  : Node_Access;\n+\n+   begin\n+      if Target.K /= Plain or Source.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Length (Source) then\n+         raise Constraint_Error with  -- ???\n+           \"Source length exceeds Target capacity\";\n+      end if;\n+\n+      if Source.Tree.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Source (list is busy)\";\n+      end if;\n+\n+      Clear (Target);\n+\n+      loop\n+         X := First (Source).Node;\n+         exit when X = 0;\n+\n+         --  Here we insert a copy of the source element into the target, and\n+         --  then delete the element from the source.  Another possibility is\n+         --  that delete it first (and hang onto its index), then insert it.\n+         --  ???\n+\n+         Insert (Target, NN (X).Key, NN (X).Element);  -- optimize???\n+\n+         Tree_Operations.Delete_Node_Sans_Free (Source.Tree.all, X);\n+         Formal_Ordered_Maps.Free (Source.Tree.all, X);\n+      end loop;\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next_Unchecked\n+     (Container : Map;\n+      Position  : Count_Type) return Count_Type is\n+   begin\n+\n+      if Container.K = Part and then\n+        (Container.Length = 0 or Position = Container.Last) then\n+         return 0;\n+      end if;\n+\n+      return Tree_Operations.Next (Container.Tree.all, Position);\n+   end Next_Unchecked;\n+\n+   procedure Next (Container : Map; Position : in out Cursor) is\n+   begin\n+      Position := Next (Container, Position);\n+   end Next;\n+\n+   function Next (Container : Map; Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"bad cursor in Next\");\n+\n+      return (Node => Next_Unchecked (Container, Position.Node));\n+   end Next;\n+\n+   -------------\n+   -- Overlap --\n+   -------------\n+\n+   function Overlap (Left, Right : Map) return Boolean is\n+   begin\n+\n+      if Length (Left) = 0 or Length (Right) = 0 then\n+         return False;\n+      end if;\n+\n+      declare\n+\n+         L_Node : Count_Type := First (Left).Node;\n+         R_Node : Count_Type := First (Right).Node;\n+\n+         L_Last : constant Count_Type :=\n+                    Next (Left.Tree.all, Last (Left).Node);\n+         R_Last : constant Count_Type :=\n+                    Next (Right.Tree.all, Last (Right).Node);\n+\n+      begin\n+         if Left'Address = Right'Address then\n+            return True;\n+         end if;\n+\n+         loop\n+            if L_Node = L_Last\n+              or else R_Node = R_Last\n+            then\n+               return False;\n+            end if;\n+\n+            if Left.Tree.Nodes (L_Node).Key\n+              < Right.Tree.Nodes (R_Node).Key then\n+               L_Node := Next (Left.Tree.all, L_Node);\n+            elsif Right.Tree.Nodes (R_Node).Key\n+              < Left.Tree.Nodes (L_Node).Key then\n+               R_Node := Next (Right.Tree.all, R_Node);\n+\n+            else\n+               return True;\n+            end if;\n+         end loop;\n+      end;\n+   end Overlap;\n+\n+   ------------\n+   -- Parent --\n+   ------------\n+\n+   function Parent (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Parent;\n+   end Parent;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   procedure Previous (Container : Map; Position : in out Cursor) is\n+   begin\n+      Position := Previous (Container, Position);\n+   end Previous;\n+\n+   function Previous (Container : Map; Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"bad cursor in Previous\");\n+\n+      if Container.K = Part and then\n+        (Container.Length = 0 or Position.Node = Container.First) then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Tree : Tree_Types.Tree_Type renames Container.Tree.all;\n+         Node : constant Count_Type :=\n+                  Tree_Operations.Previous (Tree, Position.Node);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return (Node => Node);\n+      end;\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Key     : Key_Type;\n+                                             Element : Element_Type))\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"Position cursor of Query_Element is bad\");\n+\n+      declare\n+         T : Tree_Types.Tree_Type renames Container.Tree.all;\n+\n+         B : Natural renames T.Busy;\n+         L : Natural renames T.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         declare\n+            N  : Node_Type renames T.Nodes (Position.Node);\n+            K  : Key_Type renames N.Key;\n+            E  : Element_Type renames N.Element;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Map)\n+   is\n+      procedure Read_Element (Node : in out Node_Type);\n+      pragma Inline (Read_Element);\n+\n+      procedure Allocate is\n+         new Generic_Allocate (Read_Element);\n+\n+      procedure Read_Elements is\n+         new Tree_Operations.Generic_Read (Allocate);\n+\n+      ------------------\n+      -- Read_Element --\n+      ------------------\n+\n+      procedure Read_Element (Node : in out Node_Type) is\n+      begin\n+         Key_Type'Read (Stream, Node.Key);\n+         Element_Type'Read (Stream, Node.Element);\n+      end Read_Element;\n+\n+      --  Start of processing for Read\n+      Result : Tree_Type_Access;\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Container.Tree = null then\n+         Result := new Tree_Types.Tree_Type (Container.Capacity);\n+      else\n+         Result := Container.Tree;\n+      end if;\n+\n+      Read_Elements (Stream, Result.all);\n+      Container.Tree := Result;\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream map cursor\";\n+   end Read;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      declare\n+         Node : constant Node_Access := Key_Ops.Find (Container.Tree.all, Key);\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with \"key not in map\";\n+         end if;\n+\n+         if Container.Tree.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (map is locked)\";\n+         end if;\n+\n+         declare\n+            N : Node_Type renames Container.Tree.Nodes (Node);\n+         begin\n+            N.Key := Key;\n+            N.Element := New_Item;\n+         end;\n+      end;\n+   end Replace;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of Replace_Element has no element\";\n+      end if;\n+\n+      if Container.Tree.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (map is locked)\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"Position cursor of Replace_Element is bad\");\n+\n+      Container.Tree.Nodes (Position.Node).Element := New_Item;\n+   end Replace_Element;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : Map;\n+      Process   :\n+        not null access procedure (Container : Map; Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Reverse_Iterate is\n+        new Tree_Operations.Generic_Reverse_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Container, (Node => Node));\n+      end Process_Node;\n+\n+      B : Natural renames Container.Tree.Busy;\n+\n+      --  Start of processing for Reverse_Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+\n+         if Container.K = Plain then\n+            Local_Reverse_Iterate (Container.Tree.all);\n+            return;\n+         end if;\n+\n+         if Container.Length = 0 then\n+            return;\n+         end if;\n+\n+         declare\n+            FElt : constant Key_Type :=\n+              Container.Tree.Nodes (Container.First).Key;\n+            TElt : constant Key_Type :=\n+              Container.Tree.Nodes (Container.Last).Key;\n+\n+            procedure Iterate (P : Count_Type);\n+\n+            procedure Iterate (P : Count_Type) is\n+               X : Count_Type := P;\n+            begin\n+               while X /= 0 loop\n+                  if Container.Tree.Nodes (X).Key < FElt then\n+                     X := Container.Tree.Nodes (X).Right;\n+                  elsif TElt < Container.Tree.Nodes (X).Key then\n+                     X := Container.Tree.Nodes (X).Left;\n+                  else\n+                     Iterate (Container.Tree.Nodes (X).Right);\n+                     Process_Node (X);\n+                     X := Container.Tree.Nodes (X).Left;\n+                  end if;\n+               end loop;\n+            end Iterate;\n+\n+         begin\n+            Iterate (Container.Tree.Root);\n+         end;\n+\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Reverse_Iterate;\n+\n+   -----------\n+   -- Right --\n+   -----------\n+\n+   function Right (Container : Map; Position : Cursor) return Map is\n+      Lst : Count_Type;\n+      L   : Count_Type := 0;\n+      C   : Count_Type := Position.Node;\n+   begin\n+\n+      if C = 0 then\n+         return (Capacity => Container.Capacity,\n+                 K        => Part,\n+                 Tree     => Container.Tree,\n+                 Length   => 0,\n+                 First    => 0,\n+                 Last     => 0);\n+      end if;\n+\n+      if Container.K = Plain then\n+         Lst := 0;\n+      else\n+         Lst := Next (Container.Tree.all, Container.Last);\n+      end if;\n+\n+      if C = Lst then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      while C /= Lst loop\n+         if C = 0 then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+         C := Next (Container.Tree.all, C);\n+         L := L + 1;\n+      end loop;\n+\n+      return (Capacity => Container.Capacity,\n+              K        => Part,\n+              Tree     => Container.Tree,\n+              Length   => L,\n+              First    => Position.Node,\n+              Last     => Last (Container).Node);\n+   end Right;\n+\n+   ---------------\n+   -- Right_Son --\n+   ---------------\n+\n+   function Right_Son (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Right;\n+   end Right_Son;\n+\n+   ---------------\n+   -- Set_Color --\n+   ---------------\n+\n+   procedure Set_Color\n+     (Node  : in out Node_Type;\n+      Color : Color_Type)\n+   is\n+   begin\n+      Node.Color := Color;\n+   end Set_Color;\n+\n+   --------------\n+   -- Set_Left --\n+   --------------\n+\n+   procedure Set_Left (Node : in out Node_Type; Left : Count_Type) is\n+   begin\n+      Node.Left := Left;\n+   end Set_Left;\n+\n+   ----------------\n+   -- Set_Parent --\n+   ----------------\n+\n+   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type) is\n+   begin\n+      Node.Parent := Parent;\n+   end Set_Parent;\n+\n+   ---------------\n+   -- Set_Right --\n+   ---------------\n+\n+   procedure Set_Right (Node : in out Node_Type; Right : Count_Type) is\n+   begin\n+      Node.Right := Right;\n+   end Set_Right;\n+\n+   ------------------\n+   -- Strict_Equal --\n+   ------------------\n+\n+   function Strict_Equal (Left, Right : Map) return Boolean is\n+      LNode : Count_Type := First (Left).Node;\n+      RNode : Count_Type := First (Right).Node;\n+   begin\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      while LNode = RNode loop\n+         if LNode = 0 then\n+            return True;\n+         end if;\n+\n+         if Left.Tree.Nodes (LNode).Element /=\n+           Right.Tree.Nodes (RNode).Element or\n+           Left.Tree.Nodes (LNode).Key /= Right.Tree.Nodes (RNode).Key then\n+            exit;\n+         end if;\n+\n+         LNode := Next_Unchecked (Left, LNode);\n+         RNode := Next_Unchecked (Right, RNode);\n+      end loop;\n+      return False;\n+   end Strict_Equal;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Key     : Key_Type;\n+                                             Element : in out Element_Type))\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor of Update_Element has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"Position cursor of Update_Element is bad\");\n+\n+      declare\n+         T : Tree_Types.Tree_Type renames Container.Tree.all;\n+\n+         B : Natural renames T.Busy;\n+         L : Natural renames T.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         declare\n+            N : Node_Type renames T.Nodes (Position.Node);\n+            K : Key_Type renames N.Key;\n+            E : Element_Type renames N.Element;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Update_Element;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Map)\n+   is\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type);\n+      pragma Inline (Write_Node);\n+\n+      procedure Write_Nodes is\n+         new Tree_Operations.Generic_Write (Write_Node);\n+\n+      ----------------\n+      -- Write_Node --\n+      ----------------\n+\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type)\n+      is\n+      begin\n+         Key_Type'Write (Stream, Node.Key);\n+         Element_Type'Write (Stream, Node.Element);\n+      end Write_Node;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      Write_Nodes (Stream, Container.Tree.all);\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream map cursor\";\n+   end Write;\n+\n+end Ada.Containers.Formal_Ordered_Maps;"}, {"sha": "25cb8a743e0a4597eba767fdea344f4e5bfb846b", "filename": "gcc/ada/a-cforma.ads", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,252 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . C O N T A I N E R S . F O R M A L _ O R D E R E D _ M A P S    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Containers.Red_Black_Trees;\n+private with Ada.Streams;\n+with Ada.Containers; use Ada.Containers;\n+\n+generic\n+   type Key_Type is private;\n+   type Element_Type is private;\n+\n+   with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Formal_Ordered_Maps is\n+   pragma Pure;\n+\n+   function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+\n+   type Map (Capacity : Count_Type) is tagged private;\n+   --  pragma Preelaborable_Initialization (Map);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Map : constant Map;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Map) return Boolean;\n+\n+   function Length (Container : Map) return Count_Type;\n+\n+   function Is_Empty (Container : Map) return Boolean;\n+\n+   procedure Clear (Container : in out Map);\n+\n+   procedure Assign (Target : in out Map; Source : Map);\n+\n+   function Copy (Source : Map; Capacity : Count_Type := 0) return Map;\n+\n+   function Key (Container : Map; Position : Cursor) return Key_Type;\n+\n+   function Element (Container : Map; Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access\n+        procedure (Key : Key_Type; Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access\n+        procedure (Key : Key_Type; Element : in out Element_Type));\n+\n+   procedure Move (Target : in out Map; Source : in out Map);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type);\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type);\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor);\n+\n+   procedure Delete_First (Container : in out Map);\n+\n+   procedure Delete_Last (Container : in out Map);\n+\n+   function First (Container : Map) return Cursor;\n+\n+   function First_Element (Container : Map) return Element_Type;\n+\n+   function First_Key (Container : Map) return Key_Type;\n+\n+   function Last (Container : Map) return Cursor;\n+\n+   function Last_Element (Container : Map) return Element_Type;\n+\n+   function Last_Key (Container : Map) return Key_Type;\n+\n+   function Next (Container : Map; Position : Cursor) return Cursor;\n+\n+   procedure Next (Container : Map; Position : in out Cursor);\n+\n+   function Previous (Container : Map; Position : Cursor) return Cursor;\n+\n+   procedure Previous (Container : Map; Position : in out Cursor);\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+\n+   function Floor (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Ceiling (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean;\n+\n+   function Has_Element (Container : Map; Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   :\n+        not null access procedure (Container : Map; Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : Map;\n+      Process   :\n+        not null access procedure (Container : Map; Position : Cursor));\n+\n+   function Strict_Equal (Left, Right : Map) return Boolean;\n+\n+   function Left (Container : Map; Position : Cursor) return Map;\n+\n+   function Right (Container : Map; Position : Cursor) return Map;\n+\n+   function Overlap (Left, Right : Map) return Boolean;\n+\n+private\n+\n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n+   subtype Node_Access is Count_Type;\n+\n+   use Red_Black_Trees;\n+\n+   type Node_Type is record\n+      Has_Element : Boolean := False;\n+      Parent  : Node_Access;\n+      Left    : Node_Access;\n+      Right   : Node_Access;\n+      Color   : Red_Black_Trees.Color_Type := Red;\n+      Key     : Key_Type;\n+      Element : Element_Type;\n+   end record;\n+\n+   type Kind is (Plain, Part);\n+\n+   package Tree_Types is\n+     new Ada.Containers.Red_Black_Trees.Generic_Bounded_Tree_Types (Node_Type);\n+\n+   type Tree_Type_Access is access all Tree_Types.Tree_Type;\n+\n+   type Map (Capacity : Count_Type) is tagged record\n+      Tree   : Tree_Type_Access := new Tree_Types.Tree_Type (Capacity);\n+      K      : Kind := Plain;\n+      Length : Count_Type := 0;\n+      First  : Count_Type := 0;\n+      Last   : Count_Type := 0;\n+   end record;\n+\n+   use Ada.Streams;\n+\n+   type Map_Access is access all Map;\n+   for Map_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Node      : Node_Access;\n+   end record;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := (Node => 0);\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Map);\n+\n+   for Map'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Map);\n+\n+   for Map'Read use Read;\n+\n+   Empty_Map : constant Map := (Capacity => 0, others => <>);\n+\n+end Ada.Containers.Formal_Ordered_Maps;"}, {"sha": "30a0f97a31d64ec37f4696b8c4d5c5c1e90df9c7", "filename": "gcc/ada/a-cforse.adb", "status": "added", "additions": 2924, "deletions": 0, "changes": 2924, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,2924 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . C O N T A I N E R S . F O R M A L _ O R D E R E D _ S E T S    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;\n+pragma Elaborate_All\n+  (Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations);\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys;\n+pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys);\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations;\n+pragma Elaborate_All\n+  (Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations);\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Formal_Ordered_Sets is\n+\n+   ------------------------------\n+   -- Access to Fields of Node --\n+   ------------------------------\n+\n+   --  These subprograms provide functional notation for access to fields\n+   --  of a node, and procedural notation for modifiying these fields.\n+\n+   function Color (Node : Node_Type) return Red_Black_Trees.Color_Type;\n+   pragma Inline (Color);\n+\n+   function Left_Son (Node : Node_Type) return Count_Type;\n+   pragma Inline (Left);\n+\n+   function Parent (Node : Node_Type) return Count_Type;\n+   pragma Inline (Parent);\n+\n+   function Right_Son (Node : Node_Type) return Count_Type;\n+   pragma Inline (Right);\n+\n+   procedure Set_Color\n+     (Node  : in out Node_Type;\n+      Color : Red_Black_Trees.Color_Type);\n+   pragma Inline (Set_Color);\n+\n+   procedure Set_Left (Node : in out Node_Type; Left : Count_Type);\n+   pragma Inline (Set_Left);\n+\n+   procedure Set_Right (Node : in out Node_Type; Right : Count_Type);\n+   pragma Inline (Set_Right);\n+\n+   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type);\n+   pragma Inline (Set_Parent);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   generic\n+      with procedure Set_Element (Node : in out Node_Type);\n+   procedure Generic_Allocate\n+     (Tree : in out Tree_Types.Tree_Type'Class;\n+      Node : out Count_Type);\n+\n+   procedure Assign (Target : in out Tree_Types.Tree_Type;\n+                     Source : Tree_Types.Tree_Type);\n+\n+   procedure Clear (Container : in out Tree_Types.Tree_Type);\n+\n+   procedure Free (Tree : in out Tree_Types.Tree_Type; X : Count_Type);\n+\n+   procedure Insert_Sans_Hint\n+     (Container : in out Tree_Types.Tree_Type;\n+      New_Item  : Element_Type;\n+      Node      : out Count_Type;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert_With_Hint\n+     (Dst_Set  : in out Tree_Types.Tree_Type;\n+      Dst_Hint : Count_Type;\n+      Src_Node : Node_Type;\n+      Dst_Node : out Count_Type);\n+\n+   function Is_Greater_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Type) return Boolean;\n+   pragma Inline (Is_Greater_Element_Node);\n+\n+   function Is_Less_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Type) return Boolean;\n+   pragma Inline (Is_Less_Element_Node);\n+\n+   function Is_Less_Node_Node (L, R : Node_Type) return Boolean;\n+   pragma Inline (Is_Less_Node_Node);\n+\n+   generic\n+      with procedure Process (Node : Count_Type) is <>;\n+   procedure Iterate_Between (Tree : Tree_Types.Tree_Type;\n+                              From : Count_Type;\n+                              To   : Count_Type);\n+\n+   function Next_Unchecked\n+     (Container : Set;\n+      Position  : Count_Type) return Count_Type;\n+\n+   procedure Replace_Element\n+     (Tree : in out Tree_Types.Tree_Type;\n+      Node : Count_Type;\n+      Item : Element_Type);\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   package Tree_Operations is\n+     new Red_Black_Trees.Generic_Bounded_Operations\n+       (Tree_Types,\n+        Left      => Left_Son,\n+        Right     => Right_Son);\n+\n+   use Tree_Operations;\n+\n+   package Element_Keys is\n+     new Red_Black_Trees.Generic_Bounded_Keys\n+       (Tree_Operations     => Tree_Operations,\n+        Key_Type            => Element_Type,\n+        Is_Less_Key_Node    => Is_Less_Element_Node,\n+        Is_Greater_Key_Node => Is_Greater_Element_Node);\n+\n+   package Set_Ops is\n+     new Red_Black_Trees.Generic_Bounded_Set_Operations\n+       (Tree_Operations  => Tree_Operations,\n+        Set_Type         => Tree_Types.Tree_Type,\n+        Assign           => Assign,\n+        Insert_With_Hint => Insert_With_Hint,\n+        Is_Less          => Is_Less_Node_Node);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Set) return Boolean is\n+      Lst   : Count_Type;\n+      Node  : Count_Type := First (Left).Node;\n+      ENode : Count_Type;\n+   begin\n+\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      if Is_Empty (Left) then\n+         return True;\n+      end if;\n+\n+      Lst := Next (Left.Tree.all, Last (Left).Node);\n+      while Node /= Lst loop\n+         ENode := Find (Right, Left.Tree.Nodes (Node).Element).Node;\n+         if ENode = 0 or else\n+           Left.Tree.Nodes (Node).Element /= Right.Tree.Nodes (ENode).Element\n+         then\n+            return False;\n+         end if;\n+         Node := Next (Left.Tree.all, Node);\n+      end loop;\n+\n+      return True;\n+\n+   end \"=\";\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Tree_Types.Tree_Type;\n+                     Source : Tree_Types.Tree_Type) is\n+      procedure Append_Element (Source_Node : Count_Type);\n+\n+      procedure Append_Elements is\n+        new Tree_Operations.Generic_Iteration (Append_Element);\n+\n+      --------------------\n+      -- Append_Element --\n+      --------------------\n+\n+      procedure Append_Element (Source_Node : Count_Type) is\n+         SN : Node_Type renames Source.Nodes (Source_Node);\n+\n+         procedure Set_Element (Node : in out Node_Type);\n+         pragma Inline (Set_Element);\n+\n+         function New_Node return Count_Type;\n+         pragma Inline (New_Node);\n+\n+         procedure Insert_Post is\n+           new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+         procedure Unconditional_Insert_Sans_Hint is\n+           new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n+\n+         procedure Unconditional_Insert_Avec_Hint is\n+           new Element_Keys.Generic_Unconditional_Insert_With_Hint\n+             (Insert_Post,\n+              Unconditional_Insert_Sans_Hint);\n+\n+         procedure Allocate is\n+           new Generic_Allocate (Set_Element);\n+\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Count_Type is\n+            Result : Count_Type;\n+\n+         begin\n+            Allocate (Target, Result);\n+            return Result;\n+         end New_Node;\n+\n+         -----------------\n+         -- Set_Element --\n+         -----------------\n+\n+         procedure Set_Element (Node : in out Node_Type) is\n+         begin\n+            Node.Element := SN.Element;\n+         end Set_Element;\n+\n+         Target_Node : Count_Type;\n+\n+         --  Start of processing for Append_Element\n+\n+      begin\n+         Unconditional_Insert_Avec_Hint\n+           (Tree  => Target,\n+            Hint  => 0,\n+            Key   => SN.Element,\n+            Node  => Target_Node);\n+      end Append_Element;\n+\n+      --  Start of processing for Assign\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Source.Length then\n+         raise Constraint_Error\n+           with \"Target capacity is less than Source length\";\n+      end if;\n+\n+      Tree_Operations.Clear_Tree (Target);\n+      Append_Elements (Source);\n+   end Assign;\n+\n+   procedure Assign (Target : in out Set; Source : Set) is\n+      X : Count_Type;\n+   begin\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Length (Source) then\n+         raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n+      end if;\n+\n+      if Source.K = Plain then\n+         Assign (Target => Target.Tree.all, Source => Source.Tree.all);\n+      else\n+         declare\n+            procedure Append_Element (Source_Node : Count_Type);\n+\n+            procedure Append_Element (Source_Node : Count_Type) is\n+               SN : Node_Type renames Source.Tree.Nodes (Source_Node);\n+\n+               procedure Set_Element (Node : in out Node_Type);\n+               pragma Inline (Set_Element);\n+\n+               function New_Node return Count_Type;\n+               pragma Inline (New_Node);\n+\n+               procedure Insert_Post is\n+                 new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+               procedure Unconditional_Insert_Sans_Hint is\n+                 new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n+\n+               procedure Unconditional_Insert_Avec_Hint is\n+                 new Element_Keys.Generic_Unconditional_Insert_With_Hint\n+                   (Insert_Post,\n+                    Unconditional_Insert_Sans_Hint);\n+\n+               procedure Allocate is\n+                 new Generic_Allocate (Set_Element);\n+\n+               --------------\n+               -- New_Node --\n+               --------------\n+\n+               function New_Node return Count_Type is\n+                  Result : Count_Type;\n+\n+               begin\n+                  Allocate (Target.Tree.all, Result);\n+                  return Result;\n+               end New_Node;\n+\n+               -----------------\n+               -- Set_Element --\n+               -----------------\n+\n+               procedure Set_Element (Node : in out Node_Type) is\n+               begin\n+                  Node.Element := SN.Element;\n+               end Set_Element;\n+\n+               Target_Node : Count_Type;\n+\n+               --  Start of processing for Append_Element\n+\n+            begin\n+               Unconditional_Insert_Avec_Hint\n+                 (Tree  => Target.Tree.all,\n+                  Hint  => 0,\n+                  Key   => SN.Element,\n+                  Node  => Target_Node);\n+            end Append_Element;\n+         begin\n+            Tree_Operations.Clear_Tree (Target.Tree.all);\n+            X := Source.First;\n+            while X /= Next (Source.Tree.all, Source.Last) loop\n+               Append_Element (X);\n+               X := Next (Source.Tree.all, X);\n+            end loop;\n+         end;\n+      end if;\n+   end Assign;\n+\n+   -------------\n+   -- Ceiling --\n+   -------------\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor is\n+   begin\n+\n+      if Container.K = Part then\n+         if Container.Length = 0 then\n+            return No_Element;\n+         end if;\n+\n+         if Item < Container.Tree.Nodes (Container.First).Element then\n+            return (Node => Container.First);\n+         end if;\n+\n+         if Container.Tree.Nodes (Container.Last).Element < Item then\n+            return No_Element;\n+         end if;\n+      end if;\n+\n+      declare\n+         Node : constant Count_Type :=\n+           Element_Keys.Ceiling (Container.Tree.all, Item);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return (Node => Node);\n+      end;\n+   end Ceiling;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Tree_Types.Tree_Type) is\n+   begin\n+      Tree_Operations.Clear_Tree (Container);\n+   end Clear;\n+\n+   procedure Clear (Container : in out Set) is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      Clear (Container.Tree.all);\n+   end Clear;\n+\n+   -----------\n+   -- Color --\n+   -----------\n+\n+   function Color (Node : Node_Type) return Red_Black_Trees.Color_Type is\n+   begin\n+      return Node.Color;\n+   end Color;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : Set;\n+      Item      : Element_Type) return Boolean\n+   is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy (Source : Set; Capacity : Count_Type := 0) return Set is\n+      Node : Count_Type := 1;\n+      N    : Count_Type;\n+      Cu   : Cursor;\n+      Target : Set (Count_Type'Max (Source.Capacity, Capacity));\n+   begin\n+      if Length (Source) > 0 then\n+         Target.Tree.Length := Source.Tree.Length;\n+         Target.Tree.Root := Source.Tree.Root;\n+         Target.Tree.First := Source.Tree.First;\n+         Target.Tree.Last := Source.Tree.Last;\n+         Target.Tree.Free := Source.Tree.Free;\n+\n+         while Node <= Source.Capacity loop\n+            Target.Tree.Nodes (Node).Element :=\n+              Source.Tree.Nodes (Node).Element;\n+            Target.Tree.Nodes (Node).Parent :=\n+              Source.Tree.Nodes (Node).Parent;\n+            Target.Tree.Nodes (Node).Left :=\n+              Source.Tree.Nodes (Node).Left;\n+            Target.Tree.Nodes (Node).Right :=\n+              Source.Tree.Nodes (Node).Right;\n+            Target.Tree.Nodes (Node).Color :=\n+              Source.Tree.Nodes (Node).Color;\n+            Target.Tree.Nodes (Node).Has_Element :=\n+              Source.Tree.Nodes (Node).Has_Element;\n+            Node := Node + 1;\n+         end loop;\n+\n+         while Node <= Target.Capacity loop\n+            N := Node;\n+            Formal_Ordered_Sets.Free (Tree => Target.Tree.all, X => N);\n+            Node := Node + 1;\n+         end loop;\n+\n+         if Source.K = Part then\n+            Node := Target.Tree.First;\n+            while Node /= Source.First loop\n+               Cu := (Node => Node);\n+               Node := Next (Target.Tree.all, Node);\n+               Delete (Target, Cu);\n+            end loop;\n+\n+            Node := Next (Target.Tree.all, Source.Last);\n+\n+            while Node /= 0 loop\n+               Cu := (Node => Node);\n+               Node := Next (Target.Tree.all, Node);\n+               Delete (Target, Cu);\n+            end loop;\n+         end if;\n+         Node := 1;\n+\n+      end if;\n+      return Target;\n+   end Copy;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (Container : in out Set; Position : in out Cursor) is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"bad cursor in Delete\");\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all,\n+                                             Position.Node);\n+      Formal_Ordered_Sets.Free (Container.Tree.all, Position.Node);\n+      Position := No_Element;\n+   end Delete;\n+\n+   procedure Delete (Container : in out Set; Item : Element_Type) is\n+      X : constant Count_Type := Element_Keys.Find (Container.Tree.all, Item);\n+\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if X = 0 then\n+         raise Constraint_Error with \"attempt to delete element not in set\";\n+      end if;\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n+      Formal_Ordered_Sets.Free (Container.Tree.all, X);\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First (Container : in out Set) is\n+      Tree : Tree_Types.Tree_Type renames Container.Tree.all;\n+      X    : constant Count_Type := Tree.First;\n+\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+         Formal_Ordered_Sets.Free (Tree, X);\n+      end if;\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last (Container : in out Set) is\n+      Tree : Tree_Types.Tree_Type renames Container.Tree.all;\n+      X    : constant Count_Type := Tree.Last;\n+\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+         Formal_Ordered_Sets.Free (Tree, X);\n+      end if;\n+   end Delete_Last;\n+\n+   ----------------\n+   -- Difference --\n+   ----------------\n+\n+   procedure Difference (Target : in out Set; Source : Set) is\n+   begin\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Source.K = Plain then\n+         Set_Ops.Set_Difference (Target.Tree.all, Source.Tree.all);\n+      else\n+         declare\n+            Tgt : Count_Type := Target.Tree.First;\n+            Src : Count_Type := Source.First;\n+         begin\n+            if Target'Address = Source'Address then\n+               if Target.Tree.Busy > 0 then\n+                  raise Program_Error with\n+                    \"attempt to tamper with cursors (container is busy)\";\n+               end if;\n+\n+               Clear (Target.Tree.all);\n+               return;\n+            end if;\n+\n+            if Source.Length = 0 then\n+               return;\n+            end if;\n+\n+            if Target.Tree.Busy > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with cursors (container is busy)\";\n+            end if;\n+\n+            loop\n+               if Tgt = 0 then\n+                  return;\n+               end if;\n+\n+               if Src = Next (Source.Tree.all, Source.Last) then\n+                  return;\n+               end if;\n+\n+               if Target.Tree.Nodes (Tgt).Element <\n+                 Source.Tree.Nodes (Src).Element then\n+                  Tgt := Next (Target.Tree.all, Tgt);\n+\n+               elsif Source.Tree.Nodes (Src).Element <\n+                 Target.Tree.Nodes (Tgt).Element then\n+                  Src := Next (Source.Tree.all, Src);\n+\n+               else\n+                  declare\n+                     X : constant Count_Type := Tgt;\n+                  begin\n+                     Tgt := Next (Target.Tree.all, Tgt);\n+                     Delete_Node_Sans_Free (Target.Tree.all, X);\n+                     Formal_Ordered_Sets.Free (Target.Tree.all, X);\n+                  end;\n+\n+                  Src := Next (Source.Tree.all, Src);\n+               end if;\n+            end loop;\n+         end;\n+      end if;\n+   end Difference;\n+\n+   function Difference (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      if Length (Left) = 0 then\n+         return Empty_Set;\n+      end if;\n+\n+      if Length (Right) = 0 then\n+         return Left.Copy;\n+      end if;\n+\n+      return S : Set (Length (Left)) do\n+         if Left.K = Plain and Right.K = Plain then\n+            Assign (S.Tree.all,\n+                    Set_Ops.Set_Difference (Left.Tree.all, Right.Tree.all));\n+         else\n+            declare\n+               Tree : Tree_Types.Tree_Type renames S.Tree.all;\n+\n+               L_Node : Count_Type := First (Left).Node;\n+               R_Node : Count_Type := First (Right).Node;\n+\n+               L_Last : constant Count_Type := Next (Left.Tree.all,\n+                                                     Last (Left).Node);\n+               R_Last : constant Count_Type := Next (Right.Tree.all,\n+                                                     Last (Right).Node);\n+\n+               Dst_Node : Count_Type;\n+\n+            begin\n+               loop\n+                  if L_Node = L_Last then\n+                     return;\n+                  end if;\n+\n+                  if R_Node = R_Last then\n+                     while L_Node /= L_Last loop\n+                        Insert_With_Hint\n+                          (Dst_Set  => Tree,\n+                           Dst_Hint => 0,\n+                           Src_Node => Left.Tree.Nodes (L_Node),\n+                           Dst_Node => Dst_Node);\n+\n+                        L_Node := Next (Left.Tree.all, L_Node);\n+\n+                     end loop;\n+\n+                     return;\n+                  end if;\n+\n+                  if Left.Tree.Nodes (L_Node).Element <\n+                    Right.Tree.Nodes (R_Node).Element then\n+                     Insert_With_Hint\n+                       (Dst_Set  => Tree,\n+                        Dst_Hint => 0,\n+                        Src_Node => Left.Tree.Nodes (L_Node),\n+                        Dst_Node => Dst_Node);\n+\n+                     L_Node := Next (Left.Tree.all, L_Node);\n+\n+                  elsif Right.Tree.Nodes (R_Node).Element <\n+                    Left.Tree.Nodes (L_Node).Element then\n+                     R_Node := Next (Right.Tree.all, R_Node);\n+\n+                  else\n+                     L_Node := Next (Left.Tree.all, L_Node);\n+                     R_Node := Next (Right.Tree.all, R_Node);\n+                  end if;\n+               end loop;\n+            end;\n+         end if;\n+      end return;\n+   end Difference;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Container : Set; Position : Cursor) return Element_Type is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"bad cursor in Element\");\n+\n+      declare\n+         N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+      begin\n+         return N (Position.Node).Element;\n+      end;\n+   end Element;\n+\n+   -------------------------\n+   -- Equivalent_Elements --\n+   -------------------------\n+\n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean is\n+   begin\n+      if Left < Right\n+        or else Right < Left\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Equivalent_Elements;\n+\n+   ---------------------\n+   -- Equivalent_Sets --\n+   ---------------------\n+\n+   function Equivalent_Sets (Left, Right : Set) return Boolean is\n+      function Is_Equivalent_Node_Node\n+        (L, R        : Node_Type) return Boolean;\n+      pragma Inline (Is_Equivalent_Node_Node);\n+\n+      function Is_Equivalent is\n+        new Tree_Operations.Generic_Equal (Is_Equivalent_Node_Node);\n+\n+      -----------------------------\n+      -- Is_Equivalent_Node_Node --\n+      -----------------------------\n+\n+      function Is_Equivalent_Node_Node (L, R : Node_Type) return Boolean is\n+      begin\n+         if L.Element < R.Element then\n+            return False;\n+         elsif R.Element < L.Element then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Is_Equivalent_Node_Node;\n+\n+      --  Start of processing for Equivalent_Sets\n+\n+   begin\n+      if Left.K = Plain and Right.K = Plain then\n+         return Is_Equivalent (Left.Tree.all, Right.Tree.all);\n+      end if;\n+\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      if Length (Left) = 0 then\n+         return True;\n+      end if;\n+\n+      declare\n+         L_Node : Count_Type;\n+         R_Node : Count_Type;\n+\n+         L_Last : constant Count_Type := Next (Left.Tree.all,\n+                                               Last (Left).Node);\n+      begin\n+\n+         L_Node := First (Left).Node;\n+         R_Node := First (Right).Node;\n+         while L_Node /= L_Last loop\n+            if not Is_Equivalent_Node_Node (Left.Tree.Nodes (L_Node),\n+                                            Right.Tree.Nodes (R_Node)) then\n+               return False;\n+            end if;\n+\n+            L_Node := Next (Left.Tree.all, L_Node);\n+            R_Node := Next (Right.Tree.all, R_Node);\n+         end loop;\n+\n+         return True;\n+      end;\n+   end Equivalent_Sets;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude (Container : in out Set; Item : Element_Type) is\n+      X : constant Count_Type := Element_Keys.Find (Container.Tree.all, Item);\n+\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n+         Formal_Ordered_Sets.Free (Container.Tree.all, X);\n+      end if;\n+   end Exclude;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find (Container : Set; Item : Element_Type) return Cursor is\n+   begin\n+\n+      if Container.K = Part then\n+         if Container.Length = 0 then\n+            return No_Element;\n+         end if;\n+\n+         if Item < Container.Tree.Nodes (Container.First).Element or\n+           Container.Tree.Nodes (Container.Last).Element < Item then\n+            return No_Element;\n+         end if;\n+      end if;\n+\n+      declare\n+         Node : constant Count_Type :=\n+           Element_Keys.Find (Container.Tree.all, Item);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return (Node => Node);\n+      end;\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Set) return Cursor is\n+   begin\n+      if Length (Container) = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if Container.K = Plain then\n+         return (Node => Container.Tree.First);\n+      else\n+         return (Node => Container.First);\n+      end if;\n+\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : Set) return Element_Type is\n+      Fst : constant Count_Type :=  First (Container).Node;\n+   begin\n+      if Fst = 0 then\n+         raise Constraint_Error with \"set is empty\";\n+      end if;\n+\n+      declare\n+         N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+      begin\n+         return N (Fst).Element;\n+      end;\n+   end First_Element;\n+\n+   -----------\n+   -- Floor --\n+   -----------\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor is\n+   begin\n+\n+      if Container.K = Part then\n+         if Container.Length = 0 then\n+            return No_Element;\n+         end if;\n+\n+         if Item < Container.Tree.Nodes (Container.First).Element then\n+            return No_Element;\n+         end if;\n+\n+         if Container.Tree.Nodes (Container.Last).Element < Item then\n+            return (Node => Container.Last);\n+         end if;\n+      end if;\n+\n+      declare\n+         Node : constant Count_Type :=\n+           Element_Keys.Floor (Container.Tree.all, Item);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return (Node => Node);\n+      end;\n+   end Floor;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free\n+     (Tree : in out Tree_Types.Tree_Type;\n+      X  : Count_Type)\n+   is\n+   begin\n+      Tree.Nodes (X).Has_Element := False;\n+      Tree_Operations.Free (Tree, X);\n+   end Free;\n+\n+   ----------------------\n+   -- Generic_Allocate --\n+   ----------------------\n+\n+   procedure Generic_Allocate\n+     (Tree : in out Tree_Types.Tree_Type'Class;\n+      Node : out Count_Type)\n+   is\n+\n+      procedure Allocate is\n+        new Tree_Operations.Generic_Allocate (Set_Element);\n+\n+   begin\n+      Allocate (Tree, Node);\n+      Tree.Nodes (Node).Has_Element := True;\n+   end Generic_Allocate;\n+\n+   ------------------\n+   -- Generic_Keys --\n+   ------------------\n+\n+   package body Generic_Keys is\n+\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n+\n+      function Is_Greater_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Type) return Boolean;\n+      pragma Inline (Is_Greater_Key_Node);\n+\n+      function Is_Less_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Type) return Boolean;\n+      pragma Inline (Is_Less_Key_Node);\n+\n+      --------------------------\n+      -- Local Instantiations --\n+      --------------------------\n+\n+      package Key_Keys is\n+        new Red_Black_Trees.Generic_Bounded_Keys\n+          (Tree_Operations     => Tree_Operations,\n+           Key_Type            => Key_Type,\n+           Is_Less_Key_Node    => Is_Less_Key_Node,\n+           Is_Greater_Key_Node => Is_Greater_Key_Node);\n+\n+      -------------\n+      -- Ceiling --\n+      -------------\n+\n+      function Ceiling (Container : Set; Key : Key_Type) return Cursor is\n+      begin\n+\n+         if Container.K = Part then\n+            if Container.Length = 0 then\n+               return No_Element;\n+            end if;\n+\n+            if Key < Generic_Keys.Key\n+              (Container.Tree.Nodes (Container.First).Element) then\n+               return (Node => Container.First);\n+            end if;\n+\n+            if Generic_Keys.Key\n+              (Container.Tree.Nodes (Container.Last).Element) < Key then\n+               return No_Element;\n+            end if;\n+         end if;\n+\n+         declare\n+            Node : constant Count_Type :=\n+              Key_Keys.Ceiling (Container.Tree.all, Key);\n+\n+         begin\n+            if Node = 0 then\n+               return No_Element;\n+            end if;\n+\n+            return (Node => Node);\n+         end;\n+      end Ceiling;\n+\n+      --------------\n+      -- Contains --\n+      --------------\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean is\n+      begin\n+         return Find (Container, Key) /= No_Element;\n+      end Contains;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type) is\n+      begin\n+         if Container.K /= Plain then\n+            raise Constraint_Error\n+              with \"Can't modify part of container\";\n+         end if;\n+\n+         declare\n+            X : constant Count_Type := Key_Keys.Find (Container.Tree.all, Key);\n+\n+         begin\n+            if X = 0 then\n+               raise Constraint_Error with \"attempt to delete key not in set\";\n+            end if;\n+\n+            Delete_Node_Sans_Free (Container.Tree.all, X);\n+            Formal_Ordered_Sets.Free (Container.Tree.all, X);\n+         end;\n+      end Delete;\n+\n+      -------------\n+      -- Element --\n+      -------------\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type is\n+      begin\n+\n+         if Container.K = Part then\n+            if Container.Length = 0 or else\n+              (Key < Generic_Keys.Key\n+                 (Container.Tree.Nodes (Container.First).Element) or\n+                 Generic_Keys.Key\n+                   (Container.Tree.Nodes (Container.Last).Element) < Key) then\n+               raise Constraint_Error with \"key not in set\";\n+            end if;\n+         end if;\n+\n+         declare\n+            Node : constant Count_Type :=\n+              Key_Keys.Find (Container.Tree.all, Key);\n+\n+         begin\n+            if Node = 0 then\n+               raise Constraint_Error with \"key not in set\";\n+            end if;\n+\n+            declare\n+               N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+            begin\n+               return N (Node).Element;\n+            end;\n+         end;\n+      end Element;\n+\n+      ---------------------\n+      -- Equivalent_Keys --\n+      ---------------------\n+\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n+      begin\n+         if Left < Right\n+           or else Right < Left\n+         then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Equivalent_Keys;\n+\n+      -------------\n+      -- Exclude --\n+      -------------\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type) is\n+      begin\n+         if Container.K /= Plain then\n+            raise Constraint_Error\n+              with \"Can't modify part of container\";\n+         end if;\n+\n+         declare\n+\n+            X : constant Count_Type := Key_Keys.Find (Container.Tree.all, Key);\n+\n+         begin\n+            if X /= 0 then\n+               Delete_Node_Sans_Free (Container.Tree.all, X);\n+               Formal_Ordered_Sets.Free (Container.Tree.all, X);\n+            end if;\n+         end;\n+      end Exclude;\n+\n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor is\n+      begin\n+\n+         if Container.K = Part then\n+            if Container.Length = 0 or else\n+              (Key < Generic_Keys.Key\n+                 (Container.Tree.Nodes (Container.First).Element) or\n+                 Generic_Keys.Key\n+                   (Container.Tree.Nodes (Container.Last).Element) < Key) then\n+               return No_Element;\n+            end if;\n+         end if;\n+\n+         declare\n+\n+            Node : constant Count_Type := Key_Keys.Find (Container.Tree.all,\n+                                                         Key);\n+\n+         begin\n+            if Node = 0 then\n+               return No_Element;\n+            end if;\n+\n+            return (Node => Node);\n+         end;\n+      end Find;\n+\n+      -----------\n+      -- Floor --\n+      -----------\n+\n+      function Floor (Container : Set; Key : Key_Type) return Cursor is\n+      begin\n+         if Container.K = Part then\n+            if Container.Length = 0 or else\n+              Key < Generic_Keys.Key\n+                (Container.Tree.Nodes (Container.First).Element) then\n+               return No_Element;\n+            end if;\n+\n+            if Generic_Keys.Key\n+              (Container.Tree.Nodes (Container.Last).Element) < Key then\n+               return (Node => Container.Last);\n+            end if;\n+         end if;\n+\n+         declare\n+            Node : constant Count_Type :=\n+              Key_Keys.Floor (Container.Tree.all, Key);\n+\n+         begin\n+            if Node = 0 then\n+               return No_Element;\n+            end if;\n+\n+            return (Node => Node);\n+         end;\n+      end Floor;\n+\n+      -------------------------\n+      -- Is_Greater_Key_Node --\n+      -------------------------\n+\n+      function Is_Greater_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Type) return Boolean\n+      is\n+      begin\n+         return Key (Right.Element) < Left;\n+      end Is_Greater_Key_Node;\n+\n+      ----------------------\n+      -- Is_Less_Key_Node --\n+      ----------------------\n+\n+      function Is_Less_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Type) return Boolean\n+      is\n+      begin\n+         return Left < Key (Right.Element);\n+      end Is_Less_Key_Node;\n+\n+      ---------\n+      -- Key --\n+      ---------\n+\n+      function Key (Container : Set; Position : Cursor) return Key_Type is\n+      begin\n+         if not Has_Element (Container, Position) then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+\n+         pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                        \"bad cursor in Key\");\n+\n+         declare\n+            N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+         begin\n+            return Key (N (Position.Node).Element);\n+         end;\n+      end Key;\n+\n+      -------------\n+      -- Replace --\n+      -------------\n+\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type)\n+      is\n+         Node : constant Count_Type := Key_Keys.Find (Container.Tree.all, Key);\n+\n+      begin\n+         if Container.K /= Plain then\n+            raise Constraint_Error\n+              with \"Can't modify part of container\";\n+         end if;\n+\n+         if not Has_Element (Container, (Node => Node)) then\n+            raise Constraint_Error with\n+              \"attempt to replace key not in set\";\n+         end if;\n+\n+         Replace_Element (Container.Tree.all, Node, New_Item);\n+      end Replace;\n+\n+      -----------------------------------\n+      -- Update_Element_Preserving_Key --\n+      -----------------------------------\n+\n+      procedure Update_Element_Preserving_Key\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access procedure (Element : in out Element_Type))\n+      is\n+         Tree : Tree_Types.Tree_Type renames Container.Tree.all;\n+\n+      begin\n+         if Container.K /= Plain then\n+            raise Constraint_Error\n+              with \"Can't modify part of container\";\n+         end if;\n+\n+         if not Has_Element (Container, Position) then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+\n+         pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                        \"bad cursor in Update_Element_Preserving_Key\");\n+\n+         declare\n+            N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+\n+            E : Element_Type renames N (Position.Node).Element;\n+            K : constant Key_Type := Key (E);\n+\n+            B : Natural renames Tree.Busy;\n+            L : Natural renames Tree.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            begin\n+               Process (E);\n+            exception\n+               when others =>\n+                  L := L - 1;\n+                  B := B - 1;\n+                  raise;\n+            end;\n+\n+            L := L - 1;\n+            B := B - 1;\n+\n+            if Equivalent_Keys (K, Key (E)) then\n+               return;\n+            end if;\n+         end;\n+\n+         declare\n+            X : constant Count_Type := Position.Node;\n+         begin\n+            Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+            Formal_Ordered_Sets.Free (Tree, X);\n+         end;\n+\n+         raise Program_Error with \"key was modified\";\n+      end Update_Element_Preserving_Key;\n+\n+   end Generic_Keys;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Container : Set; Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 then\n+         return False;\n+      end if;\n+\n+      if not Container.Tree.Nodes (Position.Node).Has_Element then\n+         return False;\n+      end if;\n+\n+      if Container.K = Plain then\n+         return True;\n+      end if;\n+\n+      declare\n+         Elt : constant Element_Type :=\n+           Container.Tree.Nodes (Position.Node).Element;\n+      begin\n+\n+         if Elt < Container.Tree.Nodes (Container.First).Element or\n+           Container.Tree.Nodes (Container.Last).Element < Elt then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end;\n+   end Has_Element;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include (Container : in out Set; New_Item : Element_Type) is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         if Container.Tree.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n+         end if;\n+\n+         declare\n+            N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+         begin\n+            N (Position.Node).Element := New_Item;\n+         end;\n+      end if;\n+   end Include;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      Insert_Sans_Hint\n+        (Container.Tree.all,\n+         New_Item,\n+         Position.Node,\n+         Inserted);\n+\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error with\n+           \"attempt to insert element already in set\";\n+      end if;\n+   end Insert;\n+\n+   ----------------------\n+   -- Insert_Sans_Hint --\n+   ----------------------\n+\n+   procedure Insert_Sans_Hint\n+     (Container : in out Tree_Types.Tree_Type;\n+      New_Item  : Element_Type;\n+      Node      : out Count_Type;\n+      Inserted  : out Boolean)\n+   is\n+\n+      procedure Set_Element (Node : in out Node_Type);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Insert_Post is\n+        new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Conditional_Insert_Sans_Hint is\n+        new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+      procedure Allocate is\n+        new Generic_Allocate (Set_Element);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+\n+      begin\n+         Allocate (Container, Result);\n+         return Result;\n+      end New_Node;\n+\n+      -----------------\n+      -- Set_Element --\n+      -----------------\n+\n+      procedure Set_Element (Node : in out Node_Type) is\n+      begin\n+         Node.Element := New_Item;\n+      end Set_Element;\n+\n+      --  Start of processing for Insert_Sans_Hint\n+\n+   begin\n+      Conditional_Insert_Sans_Hint\n+        (Container,\n+         New_Item,\n+         Node,\n+         Inserted);\n+   end Insert_Sans_Hint;\n+\n+   ----------------------\n+   -- Insert_With_Hint --\n+   ----------------------\n+\n+   procedure Insert_With_Hint\n+     (Dst_Set  : in out Tree_Types.Tree_Type;\n+      Dst_Hint : Count_Type;\n+      Src_Node : Node_Type;\n+      Dst_Node : out Count_Type)\n+   is\n+      Success : Boolean;\n+      pragma Unreferenced (Success);\n+\n+      procedure Set_Element (Node : in out Node_Type);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Insert_Post is\n+        new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Insert_Sans_Hint is\n+        new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+      procedure Local_Insert_With_Hint is\n+        new Element_Keys.Generic_Conditional_Insert_With_Hint\n+          (Insert_Post,\n+           Insert_Sans_Hint);\n+\n+      procedure Allocate is\n+        new Generic_Allocate (Set_Element);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+\n+      begin\n+         Allocate (Dst_Set, Result);\n+         return Result;\n+      end New_Node;\n+\n+      -----------------\n+      -- Set_Element --\n+      -----------------\n+\n+      procedure Set_Element (Node : in out Node_Type) is\n+      begin\n+         Node.Element := Src_Node.Element;\n+      end Set_Element;\n+\n+      --  Start of processing for Insert_With_Hint\n+\n+   begin\n+      Local_Insert_With_Hint\n+        (Dst_Set,\n+         Dst_Hint,\n+         Src_Node.Element,\n+         Dst_Node,\n+         Success);\n+   end Insert_With_Hint;\n+\n+   ------------------\n+   -- Intersection --\n+   ------------------\n+\n+   procedure Intersection (Target : in out Set; Source : Set) is\n+   begin\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Source.K = Plain then\n+         Set_Ops.Set_Intersection (Target.Tree.all, Source.Tree.all);\n+      else\n+         declare\n+            Tgt : Count_Type := Target.First;\n+            Src : Count_Type := Source.First;\n+\n+            S_Last : constant Count_Type :=\n+              Next (Source.Tree.all, Source.Last);\n+\n+         begin\n+            if Target'Address = Source'Address then\n+               return;\n+            end if;\n+\n+            if Target.Tree.Busy > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with cursors (container is busy)\";\n+            end if;\n+\n+            if Source.Length = 0 then\n+               Clear (Target);\n+               return;\n+            end if;\n+\n+            while Tgt /= 0\n+              and then Src /= S_Last\n+            loop\n+               if Target.Tree.Nodes (Tgt).Element <\n+                 Source.Tree.Nodes (Src).Element then\n+                  declare\n+                     X : constant Count_Type := Tgt;\n+                  begin\n+                     Tgt := Next (Target.Tree.all, Tgt);\n+                     Delete_Node_Sans_Free (Target.Tree.all, X);\n+                     Formal_Ordered_Sets.Free (Target.Tree.all, X);\n+                  end;\n+\n+               elsif Source.Tree.Nodes (Src).Element <\n+                 Target.Tree.Nodes (Tgt).Element then\n+                  Src := Next (Source.Tree.all, Src);\n+\n+               else\n+                  Tgt := Next (Target.Tree.all, Tgt);\n+                  Src := Next (Source.Tree.all, Src);\n+               end if;\n+            end loop;\n+\n+            while Tgt /= 0 loop\n+               declare\n+                  X : constant Count_Type := Tgt;\n+               begin\n+                  Tgt := Next (Target.Tree.all, Tgt);\n+                  Delete_Node_Sans_Free (Target.Tree.all, X);\n+                  Formal_Ordered_Sets.Free (Target.Tree.all, X);\n+               end;\n+            end loop;\n+         end;\n+      end if;\n+   end Intersection;\n+\n+   function Intersection (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left.Copy;\n+      end if;\n+\n+      return S : Set (Count_Type'Min (Length (Left), Length (Right))) do\n+         if Left.K = Plain and Right.K = Plain then\n+            Assign (S.Tree.all, Set_Ops.Set_Intersection\n+                    (Left.Tree.all, Right.Tree.all));\n+            return;\n+         end if;\n+\n+         if Length (Left) = 0 or Length (Right) = 0 then\n+            return;\n+         end if;\n+\n+         declare\n+\n+            L_Node : Count_Type := First (Left).Node;\n+            R_Node : Count_Type := First (Right).Node;\n+\n+            L_Last : constant Count_Type :=\n+              Next (Left.Tree.all, Last (Left).Node);\n+            R_Last : constant Count_Type :=\n+              Next (Right.Tree.all, Last (Right).Node);\n+\n+            Dst_Node : Count_Type;\n+\n+         begin\n+            loop\n+\n+               if L_Node = L_Last or R_Node = R_Last then\n+                  return;\n+               end if;\n+\n+               if Left.Tree.Nodes (L_Node).Element <\n+                 Right.Tree.Nodes (R_Node).Element then\n+                  L_Node := Next (Left.Tree.all, L_Node);\n+\n+               elsif Right.Tree.Nodes (R_Node).Element <\n+                 Left.Tree.Nodes (L_Node).Element then\n+                  R_Node := Next (Right.Tree.all, R_Node);\n+\n+               else\n+                  Insert_With_Hint\n+                    (Dst_Set  => S.Tree.all,\n+                     Dst_Hint => 0,\n+                     Src_Node => Left.Tree.Nodes (L_Node),\n+                     Dst_Node => Dst_Node);\n+\n+                  L_Node := Next (Left.Tree.all, L_Node);\n+                  R_Node := Next (Right.Tree.all, R_Node);\n+               end if;\n+            end loop;\n+         end;\n+      end return;\n+   end Intersection;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Set) return Boolean is\n+   begin\n+      return Length (Container) = 0;\n+   end Is_Empty;\n+\n+   -----------------------------\n+   -- Is_Greater_Element_Node --\n+   -----------------------------\n+\n+   function Is_Greater_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Type) return Boolean\n+   is\n+   begin\n+      --  Compute e > node same as node < e\n+\n+      return Right.Element < Left;\n+   end Is_Greater_Element_Node;\n+\n+   --------------------------\n+   -- Is_Less_Element_Node --\n+   --------------------------\n+\n+   function Is_Less_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Type) return Boolean\n+   is\n+   begin\n+      return Left < Right.Element;\n+   end Is_Less_Element_Node;\n+\n+   -----------------------\n+   -- Is_Less_Node_Node --\n+   -----------------------\n+\n+   function Is_Less_Node_Node (L, R : Node_Type) return Boolean is\n+   begin\n+      return L.Element < R.Element;\n+   end Is_Less_Node_Node;\n+\n+   ---------------\n+   -- Is_Subset --\n+   ---------------\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n+   begin\n+      if Subset.K = Plain and Of_Set.K = Plain then\n+         return Set_Ops.Set_Subset (Subset.Tree.all,\n+                                    Of_Set => Of_Set.Tree.all);\n+      end if;\n+\n+      if Subset'Address = Of_Set'Address then\n+         return True;\n+      end if;\n+\n+      if Length (Subset) > Length (Of_Set) then\n+         return False;\n+      end if;\n+\n+      declare\n+         Subset_Node : Count_Type := First (Subset).Node;\n+         Set_Node    : Count_Type := First (Of_Set).Node;\n+\n+         Subset_Last : constant Count_Type :=\n+           Next (Subset.Tree.all, Last (Subset).Node);\n+         Set_Last    : constant Count_Type :=\n+           Next (Of_Set.Tree.all, Last (Of_Set).Node);\n+\n+      begin\n+         loop\n+            if Set_Node = Set_Last then\n+               return Subset_Node = 0;\n+            end if;\n+\n+            if Subset_Node = Subset_Last then\n+               return True;\n+            end if;\n+\n+            if Subset.Tree.Nodes (Subset_Node).Element <\n+              Of_Set.Tree.Nodes (Set_Node).Element then\n+               return False;\n+            end if;\n+\n+            if Of_Set.Tree.Nodes (Set_Node).Element <\n+              Subset.Tree.Nodes (Subset_Node).Element then\n+               Set_Node := Next (Of_Set.Tree.all, Set_Node);\n+            else\n+               Set_Node := Next (Of_Set.Tree.all, Set_Node);\n+               Subset_Node := Next (Subset.Tree.all, Subset_Node);\n+            end if;\n+         end loop;\n+      end;\n+   end Is_Subset;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   :\n+      not null access procedure (Container : Set; Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Count_Type);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Iterate is\n+        new Tree_Operations.Generic_Iteration (Process_Node);\n+\n+      procedure Local_Iterate_Between is\n+        new Iterate_Between (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Count_Type) is\n+      begin\n+         Process (Container, (Node => Node));\n+      end Process_Node;\n+\n+      T : Tree_Types.Tree_Type renames Container.Tree.all;\n+      B : Natural renames T.Busy;\n+\n+      --  Start of prccessing for Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         if Container.K = Plain then\n+            Local_Iterate (T);\n+            return;\n+         end if;\n+\n+         if Container.Length = 0 then\n+            return;\n+         end if;\n+\n+         Local_Iterate_Between (T, Container.First, Container.Last);\n+\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate;\n+\n+   ---------------------\n+   -- Iterate_Between --\n+   ---------------------\n+\n+   procedure Iterate_Between (Tree : Tree_Types.Tree_Type;\n+                              From : Count_Type;\n+                              To   : Count_Type) is\n+\n+      FElt : constant Element_Type := Tree.Nodes (From).Element;\n+      TElt : constant Element_Type := Tree.Nodes (To).Element;\n+      procedure Iterate (P : Count_Type);\n+\n+      -------------\n+      -- Iterate --\n+      -------------\n+\n+      procedure Iterate (P : Count_Type) is\n+         X : Count_Type := P;\n+      begin\n+         while X /= 0 loop\n+            if Tree.Nodes (X).Element < FElt then\n+               X := Tree.Nodes (X).Right;\n+            elsif TElt < Tree.Nodes (X).Element then\n+               X := Tree.Nodes (X).Left;\n+            else\n+               Iterate (Tree.Nodes (X).Left);\n+               Process (X);\n+               X := Tree.Nodes (X).Right;\n+            end if;\n+         end loop;\n+      end Iterate;\n+\n+   begin\n+      Iterate (Tree.Root);\n+   end Iterate_Between;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : Set) return Cursor is\n+   begin\n+      if Length (Container) = 0 then\n+         return No_Element;\n+      end if;\n+\n+      if Container.K = Plain then\n+         return (Node => Container.Tree.Last);\n+      end if;\n+\n+      return (Node => Container.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : Set) return Element_Type is\n+   begin\n+      if Last (Container).Node = 0 then\n+         raise Constraint_Error with \"set is empty\";\n+      end if;\n+\n+      declare\n+         N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+      begin\n+         return N (Last (Container).Node).Element;\n+      end;\n+   end Last_Element;\n+\n+   ----------\n+   -- Left --\n+   ----------\n+\n+   function Left (Container : Set; Position : Cursor) return Set is\n+      Lst : Count_Type;\n+      Fst : constant Count_Type := First (Container).Node;\n+      L   : Count_Type := 0;\n+      C   : Count_Type := Fst;\n+   begin\n+      while C /= Position.Node loop\n+         if C = Last (Container).Node or C = 0 then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+         Lst := C;\n+         C := Next (Container.Tree.all, C);\n+         L := L + 1;\n+      end loop;\n+      if L = 0 then\n+         return (Capacity => Container.Capacity,\n+                 K        => Part,\n+                 Tree     => Container.Tree,\n+                 Length   => 0,\n+                 First    => 0,\n+                 Last     => 0);\n+      else\n+         return (Capacity => Container.Capacity,\n+                 K        => Part,\n+                 Tree     => Container.Tree,\n+                 Length   => L,\n+                 First    => Fst,\n+                 Last     => Lst);\n+      end if;\n+   end Left;\n+\n+   --------------\n+   -- Left_Son --\n+   --------------\n+\n+   function Left_Son (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Left;\n+   end Left_Son;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Set) return Count_Type is\n+   begin\n+      if Container.K = Plain then\n+         return Container.Tree.Length;\n+      else\n+         return Container.Length;\n+      end if;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out Set; Source : in out Set) is\n+      S : Tree_Types.Tree_Type renames Source.Tree.all;\n+      N : Tree_Types.Nodes_Type renames S.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Target.K /= Plain or Source.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Length (Source) then\n+         raise Constraint_Error with  -- ???\n+           \"Source length exceeds Target capacity\";\n+      end if;\n+\n+      if S.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Source (list is busy)\";\n+      end if;\n+\n+      Clear (Target);\n+\n+      loop\n+         X := S.First;\n+         exit when X = 0;\n+\n+         Insert (Target, N (X).Element);  -- optimize???\n+\n+         Tree_Operations.Delete_Node_Sans_Free (S, X);\n+         Formal_Ordered_Sets.Free (S, X);\n+      end loop;\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next_Unchecked\n+     (Container : Set;\n+      Position  : Count_Type) return Count_Type is\n+   begin\n+\n+      if Container.K = Part and then\n+        (Container.Length = 0 or Position = Container.Last) then\n+         return 0;\n+      end if;\n+\n+      return Tree_Operations.Next (Container.Tree.all, Position);\n+   end Next_Unchecked;\n+\n+   function Next (Container : Set; Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"bad cursor in Next\");\n+      return (Node => Next_Unchecked (Container, Position.Node));\n+   end Next;\n+\n+   procedure Next (Container : Set; Position : in out Cursor) is\n+   begin\n+      Position := Next (Container, Position);\n+   end Next;\n+\n+   -------------\n+   -- Overlap --\n+   -------------\n+\n+   function Overlap (Left, Right : Set) return Boolean is\n+   begin\n+      if Left.K = Plain and Right.K = Plain then\n+         return Set_Ops.Set_Overlap (Left.Tree.all, Right.Tree.all);\n+      end if;\n+\n+      if Length (Left) = 0 or Length (Right) = 0 then\n+         return False;\n+      end if;\n+\n+      declare\n+\n+         L_Node : Count_Type := First (Left).Node;\n+         R_Node : Count_Type := First (Right).Node;\n+\n+         L_Last : constant Count_Type :=\n+           Next (Left.Tree.all, Last (Left).Node);\n+         R_Last : constant Count_Type :=\n+           Next (Right.Tree.all, Last (Right).Node);\n+\n+      begin\n+         if Left'Address = Right'Address then\n+            return True;\n+         end if;\n+\n+         loop\n+            if L_Node = L_Last\n+              or else R_Node = R_Last\n+            then\n+               return False;\n+            end if;\n+\n+            if Left.Tree.Nodes (L_Node).Element <\n+              Right.Tree.Nodes (R_Node).Element then\n+               L_Node := Next (Left.Tree.all, L_Node);\n+\n+            elsif Right.Tree.Nodes (R_Node).Element <\n+              Left.Tree.Nodes (L_Node).Element then\n+               R_Node := Next (Right.Tree.all, R_Node);\n+\n+            else\n+               return True;\n+            end if;\n+         end loop;\n+      end;\n+   end Overlap;\n+\n+   ------------\n+   -- Parent --\n+   ------------\n+\n+   function Parent (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Parent;\n+   end Parent;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   function Previous (Container : Set; Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"bad cursor in Previous\");\n+\n+      if Container.K = Part and then\n+        (Container.Length = 0 or Position.Node = Container.First) then\n+         return No_Element;\n+      end if;\n+\n+      declare\n+         Tree : Tree_Types.Tree_Type renames Container.Tree.all;\n+         Node : constant Count_Type :=\n+           Tree_Operations.Previous (Tree, Position.Node);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return (Node => Node);\n+      end;\n+   end Previous;\n+\n+   procedure Previous (Container : Set; Position : in out Cursor) is\n+   begin\n+      Position := Previous (Container, Position);\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"bad cursor in Query_Element\");\n+\n+      declare\n+         T : Tree_Types.Tree_Type renames Container.Tree.all;\n+\n+         B : Natural renames T.Busy;\n+         L : Natural renames T.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         begin\n+            Process (T.Nodes (Position.Node).Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Set)\n+   is\n+      procedure Read_Element (Node : in out Node_Type);\n+      pragma Inline (Read_Element);\n+\n+      procedure Allocate is\n+        new Generic_Allocate (Read_Element);\n+\n+      procedure Read_Elements is\n+        new Tree_Operations.Generic_Read (Allocate);\n+\n+      ------------------\n+      -- Read_Element --\n+      ------------------\n+\n+      procedure Read_Element (Node : in out Node_Type) is\n+      begin\n+         Element_Type'Read (Stream, Node.Element);\n+      end Read_Element;\n+\n+      --  Start of processing for Read\n+      Result : Tree_Type_Access;\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Container.Tree = null then\n+         Result := new Tree_Types.Tree_Type (Container.Capacity);\n+      else\n+         Result := Container.Tree;\n+      end if;\n+\n+      Read_Elements (Stream, Result.all);\n+      Container.Tree := Result;\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream set cursor\";\n+   end Read;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace (Container : in out Set; New_Item : Element_Type) is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      declare\n+         Node : constant Count_Type :=\n+           Element_Keys.Find (Container.Tree.all, New_Item);\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with\n+              \"attempt to replace element not in set\";\n+         end if;\n+\n+         if Container.Tree.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n+         end if;\n+\n+         Container.Tree.Nodes (Node).Element := New_Item;\n+      end;\n+   end Replace;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Tree : in out Tree_Types.Tree_Type;\n+      Node : Count_Type;\n+      Item : Element_Type)\n+   is\n+      pragma Assert (Node /= 0);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Insert_Post is\n+        new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Local_Insert_Sans_Hint is\n+        new Element_Keys.Generic_Conditional_Insert (Local_Insert_Post);\n+\n+      procedure Local_Insert_With_Hint is\n+        new Element_Keys.Generic_Conditional_Insert_With_Hint\n+          (Local_Insert_Post,\n+           Local_Insert_Sans_Hint);\n+\n+      NN : Tree_Types.Nodes_Type renames Tree.Nodes;\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+         N  : Node_Type renames NN (Node);\n+\n+      begin\n+         N.Element := Item;\n+         N.Color := Red;\n+         N.Parent := 0;\n+         N.Right := 0;\n+         N.Left := 0;\n+\n+         return Node;\n+      end New_Node;\n+\n+      Hint      : Count_Type;\n+      Result    : Count_Type;\n+      Inserted  : Boolean;\n+\n+      --  Start of processing for Insert\n+\n+   begin\n+      if Item < NN (Node).Element\n+        or else NN (Node).Element < Item\n+      then\n+         null;\n+\n+      else\n+         if Tree.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n+         end if;\n+\n+         NN (Node).Element := Item;\n+         return;\n+      end if;\n+\n+      Hint := Element_Keys.Ceiling (Tree, Item);\n+\n+      if Hint = 0 then\n+         null;\n+\n+      elsif Item < NN (Hint).Element then\n+         if Hint = Node then\n+            if Tree.Lock > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with cursors (set is locked)\";\n+            end if;\n+\n+            NN (Node).Element := Item;\n+            return;\n+         end if;\n+\n+      else\n+         pragma Assert (not (NN (Hint).Element < Item));\n+         raise Program_Error with \"attempt to replace existing element\";\n+      end if;\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);  -- Checks busy-bit\n+\n+      Local_Insert_With_Hint\n+        (Tree     => Tree,\n+         Position => Hint,\n+         Key      => Item,\n+         Node     => Result,\n+         Inserted => Inserted);\n+\n+      pragma Assert (Inserted);\n+      pragma Assert (Result = Node);\n+   end Replace_Element;\n+\n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+                     \"bad cursor in Replace_Element\");\n+\n+      Replace_Element (Container.Tree.all, Position.Node, New_Item);\n+   end Replace_Element;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : Set;\n+      Process   :\n+      not null access procedure (Container : Set; Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Count_Type);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Reverse_Iterate is\n+        new Tree_Operations.Generic_Reverse_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Count_Type) is\n+      begin\n+         Process (Container, (Node => Node));\n+      end Process_Node;\n+\n+      T : Tree_Types.Tree_Type renames Container.Tree.all;\n+      B : Natural renames T.Busy;\n+\n+      --  Start of processing for Reverse_Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         if Container.K = Plain then\n+            Local_Reverse_Iterate (T);\n+            return;\n+         end if;\n+\n+         if Container.Length = 0 then\n+            return;\n+         end if;\n+\n+         declare\n+            Node  : Count_Type := Container.Last;\n+            First : constant Count_Type :=\n+              Previous (Container.Tree.all, Container.First);\n+\n+         begin\n+\n+            while Node /= First loop\n+               Process_Node (Node);\n+               Node := Previous (Container.Tree.all, Node);\n+            end loop;\n+\n+         end;\n+\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Reverse_Iterate;\n+\n+   -----------\n+   -- Right --\n+   -----------\n+\n+   function Right (Container : Set; Position : Cursor) return Set is\n+      Lst : Count_Type;\n+      L   : Count_Type := 0;\n+      C   : Count_Type := Position.Node;\n+   begin\n+\n+      if C = 0 then\n+         return (Capacity => Container.Capacity,\n+                 K        => Part,\n+                 Tree     => Container.Tree,\n+                 Length   => 0,\n+                 First    => 0,\n+                 Last     => 0);\n+      end if;\n+\n+      if Container.K = Plain then\n+         Lst := 0;\n+      else\n+         Lst := Next (Container.Tree.all, Container.Last);\n+      end if;\n+\n+      if C = Lst then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      while C /= Lst loop\n+         if C = 0 then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+         C := Next (Container.Tree.all, C);\n+         L := L + 1;\n+      end loop;\n+\n+      return (Capacity => Container.Capacity,\n+              K        => Part,\n+              Tree     => Container.Tree,\n+              Length   => L,\n+              First    => Position.Node,\n+              Last     => Last (Container).Node);\n+   end Right;\n+\n+   ---------------\n+   -- Right_Son --\n+   ---------------\n+\n+   function Right_Son (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Right;\n+   end Right_Son;\n+\n+   ---------------\n+   -- Set_Color --\n+   ---------------\n+\n+   procedure Set_Color\n+     (Node  : in out Node_Type;\n+      Color : Red_Black_Trees.Color_Type)\n+   is\n+   begin\n+      Node.Color := Color;\n+   end Set_Color;\n+\n+   --------------\n+   -- Set_Left --\n+   --------------\n+\n+   procedure Set_Left (Node : in out Node_Type; Left : Count_Type) is\n+   begin\n+      Node.Left := Left;\n+   end Set_Left;\n+\n+   ----------------\n+   -- Set_Parent --\n+   ----------------\n+\n+   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type) is\n+   begin\n+      Node.Parent := Parent;\n+   end Set_Parent;\n+\n+   ---------------\n+   -- Set_Right --\n+   ---------------\n+\n+   procedure Set_Right (Node : in out Node_Type; Right : Count_Type) is\n+   begin\n+      Node.Right := Right;\n+   end Set_Right;\n+\n+   ------------------\n+   -- Strict_Equal --\n+   ------------------\n+\n+   function Strict_Equal (Left, Right : Set) return Boolean is\n+      LNode : Count_Type := First (Left).Node;\n+      RNode : Count_Type := First (Right).Node;\n+   begin\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      while LNode = RNode loop\n+         if LNode = 0 then\n+            return True;\n+         end if;\n+\n+         if Left.Tree.Nodes (LNode).Element /=\n+           Right.Tree.Nodes (RNode).Element then\n+            exit;\n+         end if;\n+\n+         LNode := Next_Unchecked (Left, LNode);\n+         RNode := Next_Unchecked (Right, RNode);\n+      end loop;\n+      return False;\n+\n+   end Strict_Equal;\n+\n+   --------------------------\n+   -- Symmetric_Difference --\n+   --------------------------\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n+   begin\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Source.K = Plain then\n+         Set_Ops.Set_Symmetric_Difference (Target.Tree.all, Source.Tree.all);\n+         return;\n+      end if;\n+\n+      if Source.Length = 0 then\n+         return;\n+      end if;\n+\n+      declare\n+\n+         Tgt : Count_Type := Target.First;\n+         Src : Count_Type := Source.First;\n+\n+         SLast : constant Count_Type := Next (Source.Tree.all, Source.Last);\n+\n+         New_Tgt_Node : Count_Type;\n+\n+      begin\n+         if Target.Tree.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (container is busy)\";\n+         end if;\n+\n+         if Target'Address = Source'Address then\n+            Clear (Target);\n+            return;\n+         end if;\n+\n+         loop\n+            if Tgt = 0 then\n+               while Src /= SLast loop\n+                  Insert_With_Hint\n+                    (Dst_Set  => Target.Tree.all,\n+                     Dst_Hint => 0,\n+                     Src_Node => Source.Tree.Nodes (Src),\n+                     Dst_Node => New_Tgt_Node);\n+\n+                  Src := Next (Source.Tree.all, Src);\n+               end loop;\n+\n+               return;\n+            end if;\n+\n+            if Src = SLast then\n+               return;\n+            end if;\n+\n+            if Target.Tree.Nodes (Tgt).Element <\n+              Source.Tree.Nodes (Src).Element then\n+               Tgt := Next (Target.Tree.all, Tgt);\n+\n+            elsif Source.Tree.Nodes (Src).Element <\n+              Target.Tree.Nodes (Tgt).Element then\n+               Insert_With_Hint\n+                 (Dst_Set  => Target.Tree.all,\n+                  Dst_Hint => Tgt,\n+                  Src_Node => Source.Tree.Nodes (Src),\n+                  Dst_Node => New_Tgt_Node);\n+\n+               Src := Next (Source.Tree.all, Src);\n+\n+            else\n+               declare\n+                  X : constant Count_Type := Tgt;\n+               begin\n+                  Tgt := Next (Target.Tree.all, Tgt);\n+                  Delete_Node_Sans_Free (Target.Tree.all, X);\n+                  Formal_Ordered_Sets.Free (Target.Tree.all, X);\n+               end;\n+\n+               Src := Next (Source.Tree.all, Src);\n+            end if;\n+         end loop;\n+      end;\n+   end Symmetric_Difference;\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      if Length (Right) = 0 then\n+         return Left.Copy;\n+      end if;\n+\n+      if Length (Left) = 0 then\n+         return Right.Copy;\n+      end if;\n+\n+      return S : Set (Length (Left) + Length (Right)) do\n+         if Left.K = Plain and Right.K = Plain then\n+            Assign (S.Tree.all,\n+              Set_Ops.Set_Symmetric_Difference (Left.Tree.all,\n+                Right.Tree.all));\n+            return;\n+         end if;\n+\n+         declare\n+\n+            Tree : Tree_Types.Tree_Type renames S.Tree.all;\n+\n+            L_Node : Count_Type := First (Left).Node;\n+            R_Node : Count_Type := First (Right).Node;\n+\n+            L_Last : constant Count_Type :=\n+              Next (Left.Tree.all, Last (Left).Node);\n+            R_Last : constant Count_Type :=\n+              Next (Right.Tree.all, Last (Right).Node);\n+\n+            Dst_Node : Count_Type;\n+\n+         begin\n+            loop\n+               if L_Node = L_Last then\n+                  while R_Node /= R_Last loop\n+                     Insert_With_Hint\n+                       (Dst_Set  => Tree,\n+                        Dst_Hint => 0,\n+                        Src_Node => Right.Tree.Nodes (R_Node),\n+                        Dst_Node => Dst_Node);\n+\n+                     R_Node := Next (Right.Tree.all, R_Node);\n+                  end loop;\n+\n+                  return;\n+               end if;\n+\n+               if R_Node = R_Last then\n+                  while L_Node /= L_Last  loop\n+                     Insert_With_Hint\n+                       (Dst_Set  => Tree,\n+                        Dst_Hint => 0,\n+                        Src_Node => Left.Tree.Nodes (L_Node),\n+                        Dst_Node => Dst_Node);\n+\n+                     L_Node := Next (Left.Tree.all, L_Node);\n+                  end loop;\n+\n+                  return;\n+               end if;\n+\n+               if Left.Tree.Nodes (L_Node).Element <\n+                 Right.Tree.Nodes (R_Node).Element then\n+                  Insert_With_Hint\n+                    (Dst_Set  => Tree,\n+                     Dst_Hint => 0,\n+                     Src_Node => Left.Tree.Nodes (L_Node),\n+                     Dst_Node => Dst_Node);\n+\n+                  L_Node := Next (Left.Tree.all, L_Node);\n+\n+               elsif Right.Tree.Nodes (R_Node).Element <\n+                 Left.Tree.Nodes (L_Node).Element then\n+                  Insert_With_Hint\n+                    (Dst_Set  => Tree,\n+                     Dst_Hint => 0,\n+                     Src_Node => Right.Tree.Nodes (R_Node),\n+                     Dst_Node => Dst_Node);\n+\n+                  R_Node := Next (Right.Tree.all, R_Node);\n+\n+               else\n+                  L_Node := Next (Left.Tree.all, L_Node);\n+                  R_Node := Next (Right.Tree.all, R_Node);\n+               end if;\n+            end loop;\n+         end;\n+\n+      end return;\n+   end Symmetric_Difference;\n+\n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set (New_Item : Element_Type) return Set is\n+      Node     : Count_Type;\n+      Inserted : Boolean;\n+\n+   begin\n+      return S : Set (Capacity => 1) do\n+         Insert_Sans_Hint (S.Tree.all, New_Item, Node, Inserted);\n+         pragma Assert (Inserted);\n+      end return;\n+   end To_Set;\n+\n+   -----------\n+   -- Union --\n+   -----------\n+\n+   procedure Union (Target : in out Set; Source : Set) is\n+   begin\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Source.K = Plain then\n+         Set_Ops.Set_Union (Target.Tree.all, Source.Tree.all);\n+         return;\n+      end if;\n+\n+      if Source.Length = 0 then\n+         return;\n+      end if;\n+\n+      declare\n+         Hint : Count_Type := 0;\n+\n+         procedure Process (Node : Count_Type);\n+         pragma Inline (Process);\n+\n+         procedure Iterate is new Iterate_Between (Process);\n+\n+         -------------\n+         -- Process --\n+         -------------\n+\n+         procedure Process (Node : Count_Type) is\n+         begin\n+            Insert_With_Hint\n+              (Dst_Set  => Target.Tree.all,\n+               Dst_Hint => Hint,\n+               Src_Node => Source.Tree.Nodes (Node),\n+               Dst_Node => Hint);\n+         end Process;\n+\n+         --  Start of processing for Union\n+\n+      begin\n+         if Target'Address = Source'Address then\n+            return;\n+         end if;\n+\n+         if Target.Tree.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (container is busy)\";\n+         end if;\n+\n+         Iterate (Source.Tree.all, Source.First, Source.Last);\n+      end;\n+   end Union;\n+\n+   function Union (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left.Copy;\n+      end if;\n+\n+      if Length (Left) = 0 then\n+         return Right.Copy;\n+      end if;\n+\n+      if Length (Right) = 0 then\n+         return Left.Copy;\n+      end if;\n+\n+      return S : Set (Length (Left) + Length (Right)) do\n+         S.Assign (Source => Left);\n+         S.Union (Right);\n+      end return;\n+   end Union;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Set)\n+   is\n+      procedure Write_Element\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type);\n+      pragma Inline (Write_Element);\n+\n+      procedure Write_Elements is\n+        new Tree_Operations.Generic_Write (Write_Element);\n+\n+      -------------------\n+      -- Write_Element --\n+      -------------------\n+\n+      procedure Write_Element\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type)\n+      is\n+      begin\n+         Element_Type'Write (Stream, Node.Element);\n+      end Write_Element;\n+\n+      --  Start of processing for Write\n+\n+   begin\n+      Write_Elements (Stream, Container.Tree.all);\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream set cursor\";\n+   end Write;\n+\n+end Ada.Containers.Formal_Ordered_Sets;"}, {"sha": "92c4e93497f965a2c31a4083dda98bda9b7f09e0", "filename": "gcc/ada/a-cforse.ads", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,301 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . C O N T A I N E R S . F O R M A L _ O R D E R E D _ S E T S    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Containers.Red_Black_Trees;\n+private with Ada.Streams;\n+\n+with Ada.Containers;\n+use Ada.Containers;\n+\n+generic\n+   type Element_Type is private;\n+\n+   with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Formal_Ordered_Sets is\n+   pragma Pure;\n+\n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n+\n+   type Set (Capacity : Count_Type) is tagged private;\n+   --  pragma Preelaborable_Initialization (Set);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Set : constant Set;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Set) return Boolean;\n+\n+   function Equivalent_Sets (Left, Right : Set) return Boolean;\n+\n+   function To_Set (New_Item : Element_Type) return Set;\n+\n+   function Length (Container : Set) return Count_Type;\n+\n+   function Is_Empty (Container : Set) return Boolean;\n+\n+   procedure Clear (Container : in out Set);\n+\n+   procedure Assign (Target : in out Set; Source : Set);\n+\n+   function Copy (Source : Set; Capacity : Count_Type := 0) return Set;\n+\n+   function Element (Container : Set; Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : Element_Type));\n+\n+   procedure Move (Target : in out Set; Source : in out Set);\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type);\n+\n+   procedure Include\n+     (Container : in out Set;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace\n+     (Container : in out Set;\n+      New_Item  : Element_Type);\n+\n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type);\n+\n+   procedure Delete\n+     (Container : in out Set;\n+      Item      : Element_Type);\n+\n+   procedure Delete\n+     (Container : in out Set;\n+      Position  : in out Cursor);\n+\n+   procedure Delete_First (Container : in out Set);\n+\n+   procedure Delete_Last (Container : in out Set);\n+\n+   procedure Union (Target : in out Set; Source : Set);\n+\n+   function Union (Left, Right : Set) return Set;\n+\n+   function \"or\" (Left, Right : Set) return Set renames Union;\n+\n+   procedure Intersection (Target : in out Set; Source : Set);\n+\n+   function Intersection (Left, Right : Set) return Set;\n+\n+   function \"and\" (Left, Right : Set) return Set renames Intersection;\n+\n+   procedure Difference (Target : in out Set; Source : Set);\n+\n+   function Difference (Left, Right : Set) return Set;\n+\n+   function \"-\" (Left, Right : Set) return Set renames Difference;\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set;\n+\n+   function \"xor\" (Left, Right : Set) return Set renames Symmetric_Difference;\n+\n+   function Overlap (Left, Right : Set) return Boolean;\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+\n+   function First (Container : Set) return Cursor;\n+\n+   function First_Element (Container : Set) return Element_Type;\n+\n+   function Last (Container : Set) return Cursor;\n+\n+   function Last_Element (Container : Set) return Element_Type;\n+\n+   function Next (Container : Set; Position : Cursor) return Cursor;\n+\n+   procedure Next (Container : Set; Position : in out Cursor);\n+\n+   function Previous (Container : Set; Position : Cursor) return Cursor;\n+\n+   procedure Previous (Container : Set; Position : in out Cursor);\n+\n+   function Find (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n+   function Has_Element (Container : Set; Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   :\n+        not null access procedure (Container : Set; Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : Set;\n+      Process   :\n+        not null access procedure (Container : Set; Position : Cursor));\n+\n+   generic\n+      type Key_Type (<>) is private;\n+\n+      with function Key (Element : Element_Type) return Key_Type;\n+\n+      with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n+\n+   package Generic_Keys is\n+\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+\n+      function Key (Container : Set; Position : Cursor) return Key_Type;\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type;\n+\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type);\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type);\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Floor (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n+\n+      procedure Update_Element_Preserving_Key\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+           procedure (Element : in out Element_Type));\n+\n+   end Generic_Keys;\n+\n+   function Strict_Equal (Left, Right : Set) return Boolean;\n+\n+   function Left (Container : Set; Position : Cursor) return Set;\n+\n+   function Right (Container : Set; Position : Cursor) return Set;\n+\n+private\n+\n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n+   type Node_Type is record\n+      Has_Element : Boolean := False;\n+      Parent  : Count_Type;\n+      Left    : Count_Type;\n+      Right   : Count_Type;\n+      Color   : Red_Black_Trees.Color_Type;\n+      Element : Element_Type;\n+   end record;\n+\n+   type Kind is (Plain, Part);\n+\n+   package Tree_Types is\n+     new Red_Black_Trees.Generic_Bounded_Tree_Types (Node_Type);\n+\n+   type Tree_Type_Access is access all Tree_Types.Tree_Type;\n+\n+   type Set (Capacity : Count_Type) is tagged record\n+      Tree   : Tree_Type_Access := new Tree_Types.Tree_Type (Capacity);\n+      K      : Kind := Plain;\n+      Length : Count_Type := 0;\n+      First  : Count_Type := 0;\n+      Last   : Count_Type := 0;\n+   end record;\n+\n+   use Red_Black_Trees;\n+   use Ada.Streams;\n+\n+   type Set_Access is access all Set;\n+   for Set_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Node      : Count_Type;\n+   end record;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := (Node => 0);\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Set);\n+\n+   for Set'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Set);\n+\n+   for Set'Read use Read;\n+\n+   Empty_Set : constant Set :=\n+                 (Capacity => 0, others => <>);\n+\n+end Ada.Containers.Formal_Ordered_Sets;"}, {"sha": "fd30ca9cda71a4951af5472628c8992dc08fb869", "filename": "gcc/ada/a-cofove.adb", "status": "added", "additions": 2293, "deletions": 0, "changes": 2293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,2293 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--         A D A . C O N T A I N E R S . F O R M A L _ V E C T O R S        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Generic_Array_Sort;\n+with System; use type System.Address;\n+\n+package body Ada.Containers.Formal_Vectors is\n+\n+   type Int is range System.Min_Int .. System.Max_Int;\n+   type UInt is mod System.Max_Binary_Modulus;\n+\n+   function Get_Element\n+     (Container : Vector;\n+      Position  : Count_Type) return Element_Type;\n+\n+   ---------\n+   -- \"&\" --\n+   ---------\n+\n+   function \"&\" (Left, Right : Vector) return Vector is\n+      LN : constant Count_Type := Length (Left);\n+      RN : constant Count_Type := Length (Right);\n+\n+      RFst : Count_Type;\n+      RLst : Count_Type;\n+      LFst : Count_Type;\n+      LLst : Count_Type;\n+\n+   begin\n+\n+      if Right.K = Plain then\n+         RFst := 1;\n+         RLst := RN;\n+      else\n+         RFst := Right.First;\n+         RLst := Right.First + RN - 1;\n+      end if;\n+\n+      if Left.K = Plain then\n+         LFst := 1;\n+         LLst := LN;\n+      else\n+         LFst := Left.First;\n+         LLst := Left.First + LN - 1;\n+      end if;\n+\n+      if LN = 0 then\n+         if RN = 0 then\n+            return Empty_Vector;\n+         end if;\n+\n+         declare\n+            E : constant Elements_Array (1 .. Length (Right)) :=\n+              Right.Plain.Elements (RFst .. RLst);\n+         begin\n+            return (Length (Right),\n+              new Plain_Vector'(Length (Right), E,\n+                Last => Right.Plain.Last, others => <>),\n+              others => <>);\n+         end;\n+      end if;\n+\n+      if RN = 0 then\n+         declare\n+            E : constant Elements_Array (1 .. Length (Left)) :=\n+              Left.Plain.Elements (LFst .. LLst);\n+         begin\n+            return (Length (Left),\n+                    new Plain_Vector'(Length (Left), E,\n+                          Last => Left.Plain.Last, others => <>),\n+                    others => <>);\n+         end;\n+\n+      end if;\n+\n+      declare\n+         N           : constant Int'Base := Int (LN) + Int (RN);\n+         Last_As_Int : Int'Base;\n+\n+      begin\n+         if Int (No_Index) > Int'Last - N then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         Last_As_Int := Int (No_Index) + N;\n+\n+         if Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         --  TODO: should check whether length > max capacity (cnt_t'last)  ???\n+\n+         declare\n+            Last : constant Index_Type := Index_Type (Last_As_Int);\n+\n+            LE : constant Elements_Array (1 .. Length (Left)) :=\n+              Left.Plain.Elements (LFst .. LLst);\n+\n+            RE : Elements_Array renames Right.Plain.Elements (RFst .. RLst);\n+\n+            Capacity : constant Count_Type := Length (Left) + Length (Right);\n+\n+         begin\n+            return (Capacity,\n+                    new Plain_Vector'(Capacity, LE & RE,\n+                          Last => Last, others => <>),\n+                    others => <>);\n+         end;\n+      end;\n+   end \"&\";\n+\n+   function \"&\" (Left  : Vector; Right : Element_Type) return Vector is\n+      LN          : constant Count_Type := Length (Left);\n+      Last_As_Int : Int'Base;\n+      LFst        : Count_Type;\n+      LLst        : Count_Type;\n+\n+   begin\n+      if LN = 0 then\n+         return (1,\n+                 new Plain_Vector'(1, (1 .. 1 => Right),\n+                       Index_Type'First, others => <>),\n+                 others => <>);\n+      end if;\n+\n+      if Int (Index_Type'First) > Int'Last - Int (LN) then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      Last_As_Int := Int (Index_Type'First) + Int (LN);\n+\n+      if Last_As_Int > Int (Index_Type'Last) then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      if Left.K = Plain then\n+         LFst := 1;\n+         LLst := LN;\n+      else\n+         LFst := Left.First;\n+         LLst := Left.First + LN - 1;\n+      end if;\n+\n+      declare\n+         Last : constant Index_Type := Index_Type (Last_As_Int);\n+\n+         LE : constant Elements_Array (1 .. LN) :=\n+           Left.Plain.Elements (LFst .. LLst);\n+\n+         Capacity : constant Count_Type := Length (Left) + 1;\n+\n+      begin\n+         return (Capacity,\n+                 new Plain_Vector'(Capacity, LE & Right,\n+                       Last => Last, others => <>),\n+                 others => <>);\n+      end;\n+\n+   end \"&\";\n+\n+   function \"&\" (Left  : Element_Type; Right : Vector) return Vector is\n+      RN          : constant Count_Type := Length (Right);\n+      Last_As_Int : Int'Base;\n+\n+      RFst : Count_Type;\n+      RLst : Count_Type;\n+\n+   begin\n+      if RN = 0 then\n+         return (1,\n+                 new Plain_Vector'(1, (1 .. 1 => Left),\n+                       Index_Type'First, others => <>),\n+                 others => <>);\n+      end if;\n+\n+      if Int (Index_Type'First) > Int'Last - Int (RN) then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      Last_As_Int := Int (Index_Type'First) + Int (RN);\n+\n+      if Last_As_Int > Int (Index_Type'Last) then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      if Right.K = Plain then\n+         RFst := 1;\n+         RLst := RN;\n+      else\n+         RFst := Right.First;\n+         RLst := Right.First + RN - 1;\n+      end if;\n+\n+      declare\n+         Last : constant Index_Type := Index_Type (Last_As_Int);\n+\n+         RE : Elements_Array renames Right.Plain.Elements (RFst .. RLst);\n+\n+         Capacity : constant Count_Type := 1 + Length (Right);\n+\n+      begin\n+         return (Capacity,\n+                 new Plain_Vector'(Capacity, Left & RE,\n+                       Last => Last, others => <>),\n+                 others => <>);\n+      end;\n+   end \"&\";\n+\n+   function \"&\" (Left, Right : Element_Type) return Vector is\n+   begin\n+      if Index_Type'First >= Index_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      declare\n+         Last : constant Index_Type := Index_Type'First + 1;\n+\n+      begin\n+         return (2,\n+                 new Plain_Vector'(2, (Left, Right),\n+                       Last => Last, others => <>),\n+                 others => <>);\n+      end;\n+   end \"&\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Vector) return Boolean is\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      for J in Count_Type range 1 .. Length (Left) loop\n+         if Get_Element (Left, J) /= Get_Element (Right, J) then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end \"=\";\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append (Container : in out Vector; New_Item : Vector) is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Is_Empty (New_Item) then\n+         return;\n+      end if;\n+\n+      if Container.Plain.Last = Index_Type'Last then\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n+      end if;\n+\n+      Insert\n+        (Container,\n+         Container.Plain.Last + 1,\n+         New_Item);\n+   end Append;\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Plain.Last = Index_Type'Last then\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n+      end if;\n+\n+      --  TODO: should check whether length > max capacity (cnt_t'last)  ???\n+\n+      Insert\n+        (Container,\n+         Container.Plain.Last + 1,\n+         New_Item,\n+         Count);\n+   end Append;\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Vector; Source : Vector) is\n+      LS : constant Count_Type := Length (Source);\n+   begin\n+\n+      if Target.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < LS then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Target.Clear;\n+\n+      if Source.K = Plain then\n+         Target.Plain.Elements (1 .. LS) :=\n+           Source.Plain.Elements (1 .. LS);\n+         Target.Plain.Last := Source.Plain.Last;\n+      else\n+         Target.Plain.Elements (1 .. LS) :=\n+           Source.Plain.Elements (Source.First .. (Source.First + LS - 1));\n+         Target.Plain.Last := Source.Last;\n+      end if;\n+\n+   end Assign;\n+\n+   --------------\n+   -- Capacity --\n+   --------------\n+\n+   function Capacity (Container : Vector) return Capacity_Subtype is\n+   begin\n+      return Container.Plain.Elements'Length;\n+   end Capacity;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Vector) is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Container.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n+      end if;\n+\n+      Container.Plain.Last := No_Index;\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : Vector;\n+      Item      : Element_Type) return Boolean\n+   is\n+   begin\n+      return Find_Index (Container, Item) /= No_Index;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy\n+     (Source   : Vector;\n+      Capacity : Capacity_Subtype := 0) return Vector\n+   is\n+      LS : constant Count_Type := Length (Source);\n+      C  : Capacity_Subtype;\n+\n+   begin\n+      if Capacity = 0 then\n+         C := LS;\n+\n+      elsif Capacity >= LS then\n+         C := Capacity;\n+\n+      else\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Target                   : Vector (C) do\n+         if Source.K = Plain then\n+            Target.Plain.Elements (1 .. LS) :=\n+              Source.Plain.Elements (1 .. LS);\n+            Target.Plain.Last := Source.Plain.Last;\n+         else\n+            Target.Plain.Elements (1 .. LS) :=\n+              Source.Plain.Elements (Source.First .. (Source.First + LS - 1));\n+            Target.Plain.Last := Source.Last;\n+         end if;\n+\n+      end return;\n+   end Copy;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Index < Index_Type'First then\n+         raise Constraint_Error with \"Index is out of range (too small)\";\n+      end if;\n+\n+      if Index > Container.Plain.Last then\n+         if Index > Container.Plain.Last + 1 then\n+            raise Constraint_Error with \"Index is out of range (too large)\";\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n+      end if;\n+\n+      declare\n+         I_As_Int        : constant Int := Int (Index);\n+         Old_Last_As_Int : constant Int :=\n+                             Index_Type'Pos (Container.Plain.Last);\n+\n+         Count1 : constant Int'Base := Count_Type'Pos (Count);\n+         Count2 : constant Int'Base := Old_Last_As_Int - I_As_Int + 1;\n+         N      : constant Int'Base := Int'Min (Count1, Count2);\n+\n+         J_As_Int : constant Int'Base := I_As_Int + N;\n+\n+      begin\n+         if J_As_Int > Old_Last_As_Int then\n+            Container.Plain.Last := Index - 1;\n+\n+         else\n+            declare\n+               EA : Elements_Array renames Container.Plain.Elements;\n+\n+               II : constant Int'Base := I_As_Int - Int (No_Index);\n+               I  : constant Count_Type := Count_Type (II);\n+\n+               JJ : constant Int'Base := J_As_Int - Int (No_Index);\n+               J  : constant Count_Type := Count_Type (JJ);\n+\n+               New_Last_As_Int : constant Int'Base := Old_Last_As_Int - N;\n+               New_Last        : constant Index_Type :=\n+                                   Index_Type (New_Last_As_Int);\n+\n+               KK : constant Int := New_Last_As_Int - Int (No_Index);\n+               K  : constant Count_Type := Count_Type (KK);\n+\n+            begin\n+               EA (I .. K) := EA (J .. Length (Container));\n+               Container.Plain.Last := New_Last;\n+            end;\n+         end if;\n+      end;\n+   end Delete;\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Position.Valid then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Index > Container.Plain.Last then\n+         raise Program_Error with \"Position index is out of range\";\n+      end if;\n+\n+      Delete (Container, Position.Index, Count);\n+      Position := No_Element;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First\n+     (Container : in out Vector;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Count >= Length (Container) then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      Delete (Container, Index_Type'First, Count);\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last\n+     (Container : in out Vector;\n+      Count     : Count_Type := 1)\n+   is\n+      Index : Int'Base;\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n+      end if;\n+\n+      Index := Int'Base (Container.Plain.Last) - Int'Base (Count);\n+\n+      if Index < Index_Type'Pos (Index_Type'First) then\n+         Container.Plain.Last := No_Index;\n+      else\n+         Container.Plain.Last := Index_Type (Index);\n+      end if;\n+   end Delete_Last;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element\n+     (Container : Vector;\n+      Index     : Index_Type) return Element_Type\n+   is\n+   begin\n+      if Index > Container.Plain.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      declare\n+         II : constant Int'Base := Int (Index) - Int (No_Index);\n+         I  : constant Count_Type := Count_Type (II);\n+\n+      begin\n+\n+         if Container.K = Part and then\n+           (I > Length (Container)) then\n+            raise Constraint_Error with \"Index is out of range\";\n+         end if;\n+\n+         return Get_Element (Container, I);\n+      end;\n+   end Element;\n+\n+   function Element\n+     (Container : Vector;\n+      Position  : Cursor) return Element_Type\n+   is\n+      Lst : constant Index_Type := Last_Index (Container);\n+   begin\n+      if not Position.Valid then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Index > Lst then\n+         raise Constraint_Error with \"Position cursor is out of range\";\n+      end if;\n+\n+      declare\n+         II : constant Int'Base := Int (Position.Index) - Int (No_Index);\n+         I  : constant Count_Type := Count_Type (II);\n+\n+      begin\n+\n+         return Get_Element (Container, I);\n+      end;\n+   end Element;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      K    : Count_Type;\n+      Last : constant Index_Type := Last_Index (Container);\n+\n+   begin\n+\n+      if Position.Valid then\n+         if Position.Index > Last_Index (Container) then\n+            raise Program_Error with \"Position index is out of range\";\n+         end if;\n+      end if;\n+\n+      K := Count_Type (Int (Position.Index) - Int (No_Index));\n+\n+      for J in Position.Index .. Last loop\n+         if Get_Element (Container, K) = Item then\n+            return Cursor'(Index => J, others => <>);\n+         end if;\n+         K := K + 1;\n+      end loop;\n+\n+      return No_Element;\n+\n+   end Find;\n+\n+   ----------------\n+   -- Find_Index --\n+   ----------------\n+\n+   function Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'First) return Extended_Index\n+   is\n+      K    : Count_Type;\n+      Last : constant Index_Type := Last_Index (Container);\n+\n+   begin\n+\n+      K := Count_Type (Int (Index) - Int (No_Index));\n+      for Indx in Index .. Last loop\n+         if Get_Element (Container, K) = Item then\n+            return Indx;\n+         end if;\n+         K := K + 1;\n+      end loop;\n+\n+      return No_Index;\n+   end Find_Index;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Vector) return Cursor is\n+   begin\n+      if Is_Empty (Container) then\n+         return No_Element;\n+      end if;\n+\n+      return (True, Index_Type'First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : Vector) return Element_Type is\n+   begin\n+      if Is_Empty (Container) then\n+         raise Constraint_Error with \"Container is empty\";\n+      end if;\n+\n+      return Get_Element (Container, 1);\n+   end First_Element;\n+\n+   -----------------\n+   -- First_Index --\n+   -----------------\n+\n+   function First_Index (Container : Vector) return Index_Type is\n+      pragma Unreferenced (Container);\n+   begin\n+      return Index_Type'First;\n+   end First_Index;\n+\n+   ---------------------\n+   -- Generic_Sorting --\n+   ---------------------\n+\n+   package body Generic_Sorting is\n+\n+      ---------------\n+      -- Is_Sorted --\n+      ---------------\n+\n+      function Is_Sorted (Container : Vector) return Boolean is\n+         Last : constant Index_Type := Last_Index (Container);\n+      begin\n+\n+         if Container.Plain.Last <= Last then\n+            return True;\n+         end if;\n+\n+         declare\n+            L : constant Capacity_Subtype := Length (Container);\n+         begin\n+\n+            for J in Count_Type range 1 .. L - 1 loop\n+               if Get_Element (Container, J + 1)\n+                 < Get_Element (Container, J) then\n+                  return False;\n+               end if;\n+            end loop;\n+         end;\n+\n+         return True;\n+      end Is_Sorted;\n+\n+      -----------\n+      -- Merge --\n+      -----------\n+\n+      procedure Merge (Target, Source : in out Vector) is\n+      begin\n+\n+         if Target.K /= Plain or Source.K /= Plain then\n+            raise Constraint_Error\n+              with \"Can't modify part of container\";\n+         end if;\n+\n+         declare\n+            TA : Elements_Array renames Target.Plain.Elements;\n+            SA : Elements_Array renames Source.Plain.Elements;\n+\n+            I, J : Count_Type;\n+\n+         begin\n+            --  ???\n+            --           if Target.Last < Index_Type'First then\n+            --              Move (Target => Target, Source => Source);\n+            --              return;\n+            --           end if;\n+\n+            if Target'Address = Source'Address then\n+               return;\n+            end if;\n+\n+            if Source.Plain.Last < Index_Type'First then\n+               return;\n+            end if;\n+\n+            --  I think we're missing this check in a-convec.adb...  ???\n+            if Target.Plain.Busy > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with elements (vector is busy)\";\n+            end if;\n+\n+            if Source.Plain.Busy > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with elements (vector is busy)\";\n+            end if;\n+\n+            I := Length (Target);\n+            Target.Set_Length (I + Length (Source));\n+\n+            J := Length (Target);\n+            while not Source.Is_Empty loop\n+               pragma Assert (Length (Source) <= 1\n+                 or else not (SA (Length (Source)) <\n+                     SA (Length (Source) - 1)));\n+\n+               if I = 0 then\n+                  TA (1 .. J) := SA (1 .. Length (Source));\n+                  Source.Plain.Last := No_Index;\n+                  return;\n+               end if;\n+\n+               pragma Assert (I <= 1\n+                              or else not (TA (I) < TA (I - 1)));\n+\n+               if SA (Length (Source)) < TA (I) then\n+                  TA (J) := TA (I);\n+                  I := I - 1;\n+\n+               else\n+                  TA (J) := SA (Length (Source));\n+                  Source.Plain.Last := Source.Plain.Last - 1;\n+               end if;\n+\n+               J := J - 1;\n+            end loop;\n+         end;\n+      end Merge;\n+\n+      ----------\n+      -- Sort --\n+      ----------\n+\n+      procedure Sort (Container : in out Vector)\n+      is\n+         procedure Sort is\n+           new Generic_Array_Sort\n+             (Index_Type   => Count_Type,\n+              Element_Type => Element_Type,\n+              Array_Type   => Elements_Array,\n+              \"<\"          => \"<\");\n+\n+      begin\n+\n+         if Container.K /= Plain then\n+            raise Constraint_Error\n+              with \"Can't modify part of container\";\n+         end if;\n+\n+         if Container.Plain.Last <= Index_Type'First then\n+            return;\n+         end if;\n+\n+         if Container.Plain.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (vector is locked)\";\n+         end if;\n+\n+         Sort (Container.Plain.Elements (1 .. Length (Container)));\n+      end Sort;\n+\n+   end Generic_Sorting;\n+\n+   -----------------\n+   -- Get_Element --\n+   -----------------\n+\n+   function Get_Element\n+     (Container : Vector;\n+      Position  : Count_Type) return Element_Type is\n+   begin\n+      if Container.K = Plain then\n+         return Container.Plain.Elements (Position);\n+      end if;\n+\n+      return Container.Plain.Elements (Position + Container.First - 1);\n+   end Get_Element;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element\n+     (Container : Vector;\n+      Position  : Cursor) return Boolean is\n+   begin\n+      if not Position.Valid then\n+         return False;\n+      end if;\n+\n+      return Position.Index <= Last_Index (Container);\n+   end Has_Element;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      N : constant Int := Count_Type'Pos (Count);\n+\n+      First           : constant Int := Int (Index_Type'First);\n+      New_Last_As_Int : Int'Base;\n+      New_Last        : Index_Type;\n+      New_Length      : UInt;\n+      Max_Length      : constant UInt := UInt (Container.Capacity);\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Before < Index_Type'First then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n+      end if;\n+\n+      if Before > Container.Plain.Last\n+        and then Before > Container.Plain.Last + 1\n+      then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      declare\n+         Old_Last_As_Int : constant Int := Int (Container.Plain.Last);\n+\n+      begin\n+         if Old_Last_As_Int > Int'Last - N then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         New_Last_As_Int := Old_Last_As_Int + N;\n+\n+         if New_Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         New_Length := UInt (New_Last_As_Int - First + Int'(1));\n+\n+         if New_Length > Max_Length then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         New_Last := Index_Type (New_Last_As_Int);\n+\n+         --  Resolve issue of capacity vs. max index  ???\n+      end;\n+\n+      if Container.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n+      end if;\n+\n+      declare\n+         EA : Elements_Array renames Container.Plain.Elements;\n+\n+         BB : constant Int'Base := Int (Before) - Int (No_Index);\n+         B  : constant Count_Type := Count_Type (BB);\n+\n+         LL : constant Int'Base := New_Last_As_Int - Int (No_Index);\n+         L  : constant Count_Type := Count_Type (LL);\n+\n+      begin\n+         if Before <= Container.Plain.Last then\n+            declare\n+               II : constant Int'Base := BB + N;\n+               I  : constant Count_Type := Count_Type (II);\n+\n+            begin\n+               EA (I .. L) := EA (B .. Length (Container));\n+               EA (B .. I - 1) := (others => New_Item);\n+            end;\n+\n+         else\n+            EA (B .. L) := (others => New_Item);\n+         end if;\n+      end;\n+\n+      Container.Plain.Last := New_Last;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Vector)\n+   is\n+      N : constant Count_Type := Length (New_Item);\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Before < Index_Type'First then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n+      end if;\n+\n+      if Before > Container.Plain.Last\n+        and then Before > Container.Plain.Last + 1\n+      then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n+      end if;\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      Insert_Space (Container, Before, Count => N);\n+\n+      declare\n+         Dst_Last_As_Int : constant Int'Base :=\n+                             Int (Before) + Int (N) - 1 - Int (No_Index);\n+\n+         Dst_Last : constant Count_Type := Count_Type (Dst_Last_As_Int);\n+\n+         Src_Fst : Count_Type;\n+         Src_Lst : Count_Type;\n+\n+         BB : constant Int'Base := Int (Before) - Int (No_Index);\n+         B  : constant Count_Type := Count_Type (BB);\n+\n+      begin\n+\n+         if Container.K = Plain then\n+            Src_Fst := 1;\n+            Src_Lst := N;\n+         else\n+            Src_Fst := New_Item.First;\n+            Src_Lst := N + New_Item.First - 1;\n+         end if;\n+\n+         if Container'Address /= New_Item'Address then\n+            Container.Plain.Elements (B .. Dst_Last) :=\n+              New_Item.Plain.Elements (Src_Fst .. Src_Lst);\n+\n+            return;\n+         end if;\n+\n+         declare\n+            Src : Elements_Array renames Container.Plain.Elements (1 .. B - 1);\n+\n+            Index_As_Int : constant Int'Base := BB + Src'Length - 1;\n+\n+            Index : constant Count_Type := Count_Type (Index_As_Int);\n+\n+            Dst : Elements_Array renames Container.Plain.Elements (B .. Index);\n+\n+         begin\n+            Dst := Src;\n+         end;\n+\n+         if Dst_Last = Length (Container) then\n+            return;\n+         end if;\n+\n+         declare\n+            Src : Elements_Array renames\n+                    Container.Plain.Elements\n+                      (Dst_Last + 1 .. Length (Container));\n+\n+            Index_As_Int : constant Int'Base :=\n+                             Dst_Last_As_Int - Src'Length + 1;\n+\n+            Index : constant Count_Type := Count_Type (Index_As_Int);\n+\n+            Dst : Elements_Array renames\n+                    Container.Plain.Elements (Index .. Dst_Last);\n+\n+         begin\n+            Dst := Src;\n+         end;\n+      end;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Vector)\n+   is\n+      Index : Index_Type'Base;\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Is_Empty (New_Item) then\n+         return;\n+      end if;\n+\n+      if not Before.Valid\n+        or else Before.Index > Container.Plain.Last\n+      then\n+         if Container.Plain.Last = Index_Type'Last then\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n+         end if;\n+\n+         Index := Container.Plain.Last + 1;\n+\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Vector;\n+      Position  : out Cursor)\n+   is\n+      Index : Index_Type'Base;\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Is_Empty (New_Item) then\n+         if not Before.Valid\n+           or else Before.Index > Container.Plain.Last\n+         then\n+            Position := No_Element;\n+         else\n+            Position := (True, Before.Index);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      if not Before.Valid\n+        or else Before.Index > Container.Plain.Last\n+      then\n+         if Container.Plain.Last = Index_Type'Last then\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n+         end if;\n+\n+         Index := Container.Plain.Last + 1;\n+\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item);\n+\n+      Position := Cursor'(True, Index);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      Index : Index_Type'Base;\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if not Before.Valid\n+        or else Before.Index > Container.Plain.Last\n+      then\n+         if Container.Plain.Last = Index_Type'Last then\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n+         end if;\n+\n+         Index := Container.Plain.Last + 1;\n+\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item, Count);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      Index : Index_Type'Base;\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Count = 0 then\n+         if not Before.Valid\n+           or else Before.Index > Container.Plain.Last\n+         then\n+            Position := No_Element;\n+         else\n+            Position := (True, Before.Index);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      if not Before.Valid\n+        or else Before.Index > Container.Plain.Last\n+      then\n+         if Container.Plain.Last = Index_Type'Last then\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n+         end if;\n+\n+         Index := Container.Plain.Last + 1;\n+\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item, Count);\n+\n+      Position := Cursor'(True, Index);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Item : Element_Type;  -- Default-initialized value\n+      pragma Warnings (Off, New_Item);\n+\n+   begin\n+      Insert (Container, Before, New_Item, Count);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Item : Element_Type;  -- Default-initialized value\n+      pragma Warnings (Off, New_Item);\n+\n+   begin\n+      Insert (Container, Before, New_Item, Position, Count);\n+   end Insert;\n+\n+   ------------------\n+   -- Insert_Space --\n+   ------------------\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1)\n+   is\n+      N : constant Int := Count_Type'Pos (Count);\n+\n+      First           : constant Int := Int (Index_Type'First);\n+      New_Last_As_Int : Int'Base;\n+      New_Last        : Index_Type;\n+      New_Length      : UInt;\n+      Max_Length      : constant UInt := UInt (Count_Type'Last);\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Before < Index_Type'First then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n+      end if;\n+\n+      if Before > Container.Plain.Last\n+        and then Before > Container.Plain.Last + 1\n+      then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      declare\n+         Old_Last_As_Int : constant Int := Int (Container.Plain.Last);\n+\n+      begin\n+         if Old_Last_As_Int > Int'Last - N then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         New_Last_As_Int := Old_Last_As_Int + N;\n+\n+         if New_Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         New_Length := UInt (New_Last_As_Int - First + Int'(1));\n+\n+         if New_Length > Max_Length then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         New_Last := Index_Type (New_Last_As_Int);\n+\n+         --  Resolve issue of capacity vs. max index  ???\n+      end;\n+\n+      if Container.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n+      end if;\n+\n+      declare\n+         EA : Elements_Array renames Container.Plain.Elements;\n+\n+         BB : constant Int'Base := Int (Before) - Int (No_Index);\n+         B  : constant Count_Type := Count_Type (BB);\n+\n+         LL : constant Int'Base := New_Last_As_Int - Int (No_Index);\n+         L  : constant Count_Type := Count_Type (LL);\n+\n+      begin\n+         if Before <= Container.Plain.Last then\n+            declare\n+               II : constant Int'Base := BB + N;\n+               I  : constant Count_Type := Count_Type (II);\n+\n+            begin\n+               EA (I .. L) := EA (B .. Length (Container));\n+            end;\n+         end if;\n+      end;\n+\n+      Container.Plain.Last := New_Last;\n+   end Insert_Space;\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      Index : Index_Type'Base;\n+\n+   begin\n+\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Count = 0 then\n+         if not Before.Valid\n+           or else Before.Index > Container.Plain.Last\n+         then\n+            Position := No_Element;\n+         else\n+            Position := (True, Before.Index);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      if not Before.Valid\n+        or else Before.Index > Container.Plain.Last\n+      then\n+         if Container.Plain.Last = Index_Type'Last then\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n+         end if;\n+\n+         Index := Container.Plain.Last + 1;\n+\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert_Space (Container, Index, Count => Count);\n+\n+      Position := Cursor'(True, Index);\n+   end Insert_Space;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Vector) return Boolean is\n+   begin\n+      return Last_Index (Container) < Index_Type'First;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Vector;\n+      Process   :\n+        not null access procedure (Container : Vector; Position : Cursor))\n+   is\n+      V : Vector renames Container'Unrestricted_Access.all;\n+      B : Natural renames V.Plain.Busy;\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         for Indx in Index_Type'First .. Last_Index (Container) loop\n+            Process (Container, Cursor'(True, Indx));\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : Vector) return Cursor is\n+   begin\n+      if Is_Empty (Container) then\n+         return No_Element;\n+      end if;\n+\n+      return (True, Last_Index (Container));\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : Vector) return Element_Type is\n+   begin\n+      if Is_Empty (Container) then\n+         raise Constraint_Error with \"Container is empty\";\n+      end if;\n+\n+      return Get_Element (Container, Length (Container));\n+   end Last_Element;\n+\n+   ----------------\n+   -- Last_Index --\n+   ----------------\n+\n+   function Last_Index (Container : Vector) return Extended_Index is\n+   begin\n+      if Container.K = Plain then\n+         return Container.Plain.Last;\n+      else\n+         return Container.Last;\n+      end if;\n+   end Last_Index;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Vector) return Capacity_Subtype is\n+      L : constant Int := Int (Last_Index (Container));\n+      F : constant Int := Int (Index_Type'First);\n+      N : constant Int'Base := L - F + 1;\n+\n+   begin\n+      return Capacity_Subtype (N);\n+   end Length;\n+\n+   ----------\n+   -- Left --\n+   ----------\n+\n+   function Left (Container : Vector; Position : Cursor) return Vector is\n+      Fst : Count_Type;\n+   begin\n+      if Container.K = Plain then\n+         Fst := 1;\n+      else\n+         Fst := Container.First;\n+      end if;\n+\n+      if not Position.Valid then\n+         return (Container.Capacity, Container.Plain, Part, Fst,\n+                 Last_Index (Container));\n+      end if;\n+\n+      if Position.Index > Last_Index (Container) then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n+      end if;\n+\n+      return (Container.Capacity, Container.Plain, Part, Fst,\n+              (Position.Index - 1));\n+   end Left;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Target : in out Vector;\n+      Source : in out Vector)\n+   is\n+      N : constant Count_Type := Length (Source);\n+\n+   begin\n+\n+      if Target.K /= Plain or Source.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (Target is busy)\";\n+      end if;\n+\n+      if Source.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (Source is busy)\";\n+      end if;\n+\n+      if N > Target.Capacity then\n+         raise Constraint_Error with  -- correct exception here???\n+           \"length of Source is greater than capacity of Target\";\n+      end if;\n+\n+      --  We could also write this as a loop, and incrementally\n+      --  copy elements from source to target.\n+\n+      Target.Plain.Last := No_Index;  -- in case array assignment files\n+      Target.Plain.Elements (1 .. N) := Source.Plain.Elements (1 .. N);\n+\n+      Target.Plain.Last := Source.Plain.Last;\n+      Source.Plain.Last := No_Index;\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Container : Vector; Position : Cursor) return Cursor is\n+   begin\n+      if not Position.Valid then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Index < Last_Index (Container) then\n+         return (True, Position.Index + 1);\n+      end if;\n+\n+      return No_Element;\n+   end Next;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Container : Vector; Position : in out Cursor) is\n+   begin\n+      if not Position.Valid then\n+         return;\n+      end if;\n+\n+      if Position.Index < Last_Index (Container) then\n+         Position.Index := Position.Index + 1;\n+      else\n+         Position := No_Element;\n+      end if;\n+   end Next;\n+\n+   -------------\n+   -- Prepend --\n+   -------------\n+\n+   procedure Prepend (Container : in out Vector; New_Item : Vector) is\n+   begin\n+      Insert (Container, Index_Type'First, New_Item);\n+   end Prepend;\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container,\n+              Index_Type'First,\n+              New_Item,\n+              Count);\n+   end Prepend;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   procedure Previous (Container : Vector; Position : in out Cursor) is\n+   begin\n+      if not Position.Valid then\n+         return;\n+      end if;\n+\n+      if Position.Index > Index_Type'First and\n+        Position.Index <= Last_Index (Container) then\n+         Position.Index := Position.Index - 1;\n+      else\n+         Position := No_Element;\n+      end if;\n+   end Previous;\n+\n+   function Previous (Container : Vector; Position : Cursor) return Cursor is\n+   begin\n+      if not Position.Valid then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Index > Index_Type'First and\n+        Position.Index <= Last_Index (Container) then\n+         return (True, Position.Index - 1);\n+      end if;\n+\n+      return No_Element;\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Container : Vector;\n+      Index     : Index_Type;\n+      Process   : not null access procedure (Element : Element_Type))\n+   is\n+      V : Vector renames Container'Unrestricted_Access.all;\n+      B : Natural renames V.Plain.Busy;\n+      L : Natural renames V.Plain.Lock;\n+\n+   begin\n+      if Index > Last_Index (Container) then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      declare\n+         II : constant Int'Base := Int (Index) - Int (No_Index);\n+         I  : constant Count_Type := Count_Type (II);\n+\n+      begin\n+         Process (Get_Element (V, I));\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n+   end Query_Element;\n+\n+   procedure Query_Element\n+     (Container : Vector;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      if not Position.Valid then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      Query_Element (Container, Position.Index, Process);\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Vector)\n+   is\n+      Length : Count_Type'Base;\n+      Last   : Index_Type'Base := No_Index;\n+\n+   begin\n+      Clear (Container);\n+\n+      Count_Type'Base'Read (Stream, Length);\n+\n+      if Length < 0 then\n+         raise Program_Error with \"stream appears to be corrupt\";\n+      end if;\n+\n+      if Length > Container.Capacity then\n+         raise Storage_Error with \"not enough capacity\";  --  ???\n+      end if;\n+\n+      for J in Count_Type range 1 .. Length loop\n+         Last := Last + 1;\n+         Element_Type'Read (Stream, Container.Plain.Elements (J));\n+         Container.Plain.Last := Last;\n+      end loop;\n+   end Read;\n+\n+   procedure Read\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream vector cursor\";\n+   end Read;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Index > Container.Plain.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      if Container.Plain.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n+      end if;\n+\n+      declare\n+         II : constant Int'Base := Int (Index) - Int (No_Index);\n+         I  : constant Count_Type := Count_Type (II);\n+\n+      begin\n+         Container.Plain.Elements (I) := New_Item;\n+      end;\n+   end Replace_Element;\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not Position.Valid then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Index > Container.Plain.Last then\n+         raise Constraint_Error with \"Position cursor is out of range\";\n+      end if;\n+\n+      if Container.Plain.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n+      end if;\n+\n+      declare\n+         II : constant Int'Base := Int (Position.Index) - Int (No_Index);\n+         I  : constant Count_Type := Count_Type (II);\n+\n+      begin\n+         Container.Plain.Elements (I) := New_Item;\n+      end;\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Vector;\n+      Capacity  : Capacity_Subtype)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Capacity > Container.Capacity then\n+         raise Constraint_Error;  -- ???\n+      end if;\n+   end Reserve_Capacity;\n+\n+   ----------------------\n+   -- Reverse_Elements --\n+   ----------------------\n+\n+   procedure Reverse_Elements (Container : in out Vector) is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Length (Container) <= 1 then\n+         return;\n+      end if;\n+\n+      if Container.Plain.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n+      end if;\n+\n+      declare\n+         I, J : Count_Type;\n+         E    : Elements_Array renames Container.Plain.Elements;\n+\n+      begin\n+         I := 1;\n+         J := Length (Container);\n+         while I < J loop\n+            declare\n+               EI : constant Element_Type := E (I);\n+\n+            begin\n+               E (I) := E (J);\n+               E (J) := EI;\n+            end;\n+\n+            I := I + 1;\n+            J := J - 1;\n+         end loop;\n+      end;\n+   end Reverse_Elements;\n+\n+   ------------------\n+   -- Reverse_Find --\n+   ------------------\n+\n+   function Reverse_Find\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      Last : Index_Type'Base;\n+      K    : Count_Type;\n+\n+   begin\n+\n+      if not Position.Valid\n+        or else Position.Index > Last_Index (Container)\n+      then\n+         Last := Last_Index (Container);\n+      else\n+         Last := Position.Index;\n+      end if;\n+\n+      K := Count_Type (Int (Last) - Int (No_Index));\n+      for Indx in reverse Index_Type'First .. Last loop\n+         if Get_Element (Container, K) = Item then\n+            return (True, Indx);\n+         end if;\n+         K := K - 1;\n+      end loop;\n+\n+      return No_Element;\n+   end Reverse_Find;\n+\n+   ------------------------\n+   -- Reverse_Find_Index --\n+   ------------------------\n+\n+   function Reverse_Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'Last) return Extended_Index\n+   is\n+      Last : Index_Type'Base;\n+      K    : Count_Type;\n+\n+   begin\n+      if Index > Last_Index (Container) then\n+         Last := Last_Index (Container);\n+      else\n+         Last := Index;\n+      end if;\n+\n+      K := Count_Type (Int (Last) - Int (No_Index));\n+      for Indx in reverse Index_Type'First .. Last loop\n+         if Get_Element (Container, K) = Item then\n+            return Indx;\n+         end if;\n+         K := K - 1;\n+      end loop;\n+\n+      return No_Index;\n+   end Reverse_Find_Index;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : Vector;\n+      Process   :\n+        not null access procedure (Container : Vector; Position : Cursor))\n+   is\n+      V : Vector renames Container'Unrestricted_Access.all;\n+      B : Natural renames V.Plain.Busy;\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         for Indx in reverse Index_Type'First .. Last_Index (Container) loop\n+            Process (Container, Cursor'(True, Indx));\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Reverse_Iterate;\n+\n+   -----------\n+   -- Right --\n+   -----------\n+\n+   function Right (Container : Vector; Position : Cursor) return Vector is\n+      Fst : Count_Type;\n+   begin\n+      if Container.K = Plain then\n+         Fst := 1;\n+      else\n+         Fst := Container.First;\n+      end if;\n+\n+      if not Position.Valid then\n+         return (Container.Capacity, Container.Plain, Part, Fst, No_Index);\n+      end if;\n+\n+      if Position.Index > Last_Index (Container) then\n+         raise Constraint_Error with\n+           \"Position index is out of range (too large)\";\n+      end if;\n+\n+      Fst := Fst + Count_Type (Int (Position.Index) - Int (No_Index)) - 1;\n+\n+      return (Container.Capacity, Container.Plain, Part, Fst,\n+              (Last_Index (Container) - Position.Index + 1));\n+   end Right;\n+\n+   ----------------\n+   -- Set_Length --\n+   ----------------\n+\n+   procedure Set_Length\n+     (Container : in out Vector;\n+      Length    : Capacity_Subtype)\n+   is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Length = Formal_Vectors.Length (Container) then\n+         return;\n+      end if;\n+\n+      if Container.Plain.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n+      end if;\n+\n+      if Length > Container.Capacity then\n+         raise Constraint_Error;  -- ???\n+      end if;\n+\n+      declare\n+         Last_As_Int : constant Int'Base :=\n+                         Int (Index_Type'First) + Int (Length) - 1;\n+      begin\n+         Container.Plain.Last := Index_Type'Base (Last_As_Int);\n+      end;\n+   end Set_Length;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap (Container : in out Vector; I, J : Index_Type) is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if I > Container.Plain.Last then\n+         raise Constraint_Error with \"I index is out of range\";\n+      end if;\n+\n+      if J > Container.Plain.Last then\n+         raise Constraint_Error with \"J index is out of range\";\n+      end if;\n+\n+      if I = J then\n+         return;\n+      end if;\n+\n+      if Container.Plain.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n+      end if;\n+\n+      declare\n+         II : constant Int'Base := Int (I) - Int (No_Index);\n+         JJ : constant Int'Base := Int (J) - Int (No_Index);\n+\n+         EI : Element_Type renames Container.Plain.Elements (Count_Type (II));\n+         EJ : Element_Type renames Container.Plain.Elements (Count_Type (JJ));\n+\n+         EI_Copy : constant Element_Type := EI;\n+\n+      begin\n+         EI := EJ;\n+         EJ := EI_Copy;\n+      end;\n+   end Swap;\n+\n+   procedure Swap (Container : in out Vector; I, J : Cursor) is\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if not I.Valid then\n+         raise Constraint_Error with \"I cursor has no element\";\n+      end if;\n+\n+      if not J.Valid then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      Swap (Container, I.Index, J.Index);\n+   end Swap;\n+\n+   ---------------\n+   -- To_Cursor --\n+   ---------------\n+\n+   function To_Cursor\n+     (Container : Vector;\n+      Index     : Extended_Index) return Cursor\n+   is\n+   begin\n+      if Index not in Index_Type'First .. Last_Index (Container) then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(True, Index);\n+   end To_Cursor;\n+\n+   --------------\n+   -- To_Index --\n+   --------------\n+\n+   function To_Index (Position : Cursor) return Extended_Index is\n+   begin\n+      if not Position.Valid then\n+         return No_Index;\n+      end if;\n+\n+      return Position.Index;\n+   end To_Index;\n+\n+   ---------------\n+   -- To_Vector --\n+   ---------------\n+\n+   function To_Vector (Length : Capacity_Subtype) return Vector is\n+   begin\n+      if Length = 0 then\n+         return Empty_Vector;\n+      end if;\n+\n+      declare\n+         First       : constant Int := Int (Index_Type'First);\n+         Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n+         Last        : Index_Type;\n+\n+      begin\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error with \"Length is out of range\";  -- ???\n+         end if;\n+\n+         Last := Index_Type (Last_As_Int);\n+\n+         return (Length,\n+                 new Plain_Vector'(Length, (others => <>), Last => Last,\n+                                   others => <>),\n+                 others => <>);\n+      end;\n+   end To_Vector;\n+\n+   function To_Vector\n+     (New_Item : Element_Type;\n+      Length   : Capacity_Subtype) return Vector\n+   is\n+   begin\n+      if Length = 0 then\n+         return Empty_Vector;\n+      end if;\n+\n+      declare\n+         First       : constant Int := Int (Index_Type'First);\n+         Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n+         Last        : Index_Type;\n+\n+      begin\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error with \"Length is out of range\";  -- ???\n+         end if;\n+\n+         Last := Index_Type (Last_As_Int);\n+\n+         return (Length,\n+                 new Plain_Vector'(Length, (others => New_Item), Last => Last,\n+                                   others => <>),\n+                 others => <>);\n+      end;\n+   end To_Vector;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      Process   : not null access procedure (Element : in out Element_Type))\n+   is\n+      B : Natural renames Container.Plain.Busy;\n+      L : Natural renames Container.Plain.Lock;\n+\n+   begin\n+      if Container.K /= Plain then\n+         raise Constraint_Error\n+           with \"Can't modify part of container\";\n+      end if;\n+\n+      if Index > Container.Plain.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      declare\n+         II : constant Int'Base := Int (Index) - Int (No_Index);\n+         I  : constant Count_Type := Count_Type (II);\n+\n+      begin\n+         Process (Container.Plain.Elements (I));\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n+   end Update_Element;\n+\n+   procedure Update_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type))\n+   is\n+   begin\n+      if not Position.Valid then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      Update_Element (Container, Position.Index, Process);\n+   end Update_Element;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Vector)\n+   is\n+   begin\n+      Count_Type'Base'Write (Stream, Length (Container));\n+\n+      for J in 1 .. Length (Container) loop\n+         Element_Type'Write (Stream, Container.Plain.Elements (J));\n+      end loop;\n+   end Write;\n+\n+   procedure Write\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream vector cursor\";\n+   end Write;\n+\n+end Ada.Containers.Formal_Vectors;"}, {"sha": "d8e87f6695ad0fd2941b2ec4cb7a0a3609943e84", "filename": "gcc/ada/a-cofove.ads", "status": "added", "additions": 396, "deletions": 0, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -0,0 +1,396 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--         A D A . C O N T A I N E R S . F O R M A L _ V E C T O R S        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Streams;\n+with Ada.Containers;\n+use Ada.Containers;\n+\n+generic\n+   type Index_Type is range <>;\n+   type Element_Type is private;\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Formal_Vectors is\n+   pragma Pure;\n+\n+   subtype Extended_Index is Index_Type'Base\n+   range Index_Type'First - 1 ..\n+     Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n+\n+   --  ??? i don't think we can do this...\n+   --  TODO: we need the ARG to either figure out how to declare this subtype,\n+   --  or eliminate the requirement that it be present.\n+   --  subtype Capacity_Subtype is Count_Type -- correct name???\n+   --  range 0 .. Count_Type'Max (0,\n+   --                             Index_Type'Pos (Index_Type'Last) -\n+   --                             Index_Type'Pos (Index_Type'First) + 1);\n+   --\n+   --  so for now:\n+   subtype Capacity_Subtype is Count_Type;\n+\n+   No_Index : constant Extended_Index := Extended_Index'First;\n+\n+   type Vector (Capacity : Capacity_Subtype) is tagged private;\n+   --  pragma Preelaborable_Initialization (Vector);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Vector : constant Vector;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Vector) return Boolean;\n+\n+   function To_Vector (Length : Capacity_Subtype) return Vector;\n+\n+   function To_Vector\n+     (New_Item : Element_Type;\n+      Length   : Capacity_Subtype) return Vector;\n+\n+   function \"&\" (Left, Right : Vector) return Vector;\n+\n+   function \"&\" (Left : Vector; Right : Element_Type) return Vector;\n+\n+   function \"&\" (Left : Element_Type; Right : Vector) return Vector;\n+\n+   function \"&\" (Left, Right : Element_Type) return Vector;\n+\n+   function Capacity (Container : Vector) return Capacity_Subtype;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Vector;\n+      Capacity  : Capacity_Subtype);\n+\n+   function Length (Container : Vector) return Capacity_Subtype;\n+\n+   procedure Set_Length\n+     (Container : in out Vector;\n+      Length    : Capacity_Subtype);\n+\n+   function Is_Empty (Container : Vector) return Boolean;\n+\n+   procedure Clear (Container : in out Vector);\n+\n+   procedure Assign (Target : in out Vector; Source : Vector);\n+\n+   function Copy\n+     (Source   : Vector;\n+      Capacity : Capacity_Subtype := 0) return Vector;\n+\n+   function To_Cursor\n+     (Container : Vector;\n+      Index     : Extended_Index) return Cursor;\n+\n+   function To_Index (Position : Cursor) return Extended_Index;\n+\n+   function Element\n+     (Container : Vector;\n+      Index     : Index_Type) return Element_Type;\n+\n+   function Element (Container : Vector; Position : Cursor)\n+                     return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Container : Vector;\n+      Index     : Index_Type;\n+      Process   : not null access procedure (Element : Element_Type));\n+\n+   procedure Query_Element\n+     (Container : Vector;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      Process   : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Move (Target : in out Vector; Source : in out Vector);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Vector);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Vector);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Vector;\n+      Position  : out Cursor);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Vector);\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Vector);\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_First\n+     (Container : in out Vector;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_Last\n+     (Container : in out Vector;\n+      Count     : Count_Type := 1);\n+\n+   procedure Reverse_Elements (Container : in out Vector);\n+\n+   procedure Swap (Container : in out Vector; I, J : Index_Type);\n+\n+   procedure Swap (Container : in out Vector; I, J : Cursor);\n+\n+   function First_Index (Container : Vector) return Index_Type;\n+\n+   function First (Container : Vector) return Cursor;\n+\n+   function First_Element (Container : Vector) return Element_Type;\n+\n+   function Last_Index (Container : Vector) return Extended_Index;\n+\n+   function Last (Container : Vector) return Cursor;\n+\n+   function Last_Element (Container : Vector) return Element_Type;\n+\n+   function Next (Container : Vector; Position : Cursor) return Cursor;\n+\n+   procedure Next (Container : Vector; Position : in out Cursor);\n+\n+   function Previous (Container : Vector; Position : Cursor) return Cursor;\n+\n+   procedure Previous (Container : Vector; Position : in out Cursor);\n+\n+   function Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'First) return Extended_Index;\n+\n+   function Find\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Reverse_Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'Last) return Extended_Index;\n+\n+   function Reverse_Find\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Contains\n+     (Container : Vector;\n+      Item      : Element_Type) return Boolean;\n+\n+   function Has_Element (Container : Vector; Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Vector;\n+      Process   :\n+        not null access procedure (Container : Vector; Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : Vector;\n+      Process   :\n+        not null access procedure (Container : Vector; Position : Cursor));\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : Vector) return Boolean;\n+\n+      procedure Sort (Container : in out Vector);\n+\n+      procedure Merge (Target : in out Vector; Source : in out Vector);\n+\n+   end Generic_Sorting;\n+\n+   function Left (Container : Vector; Position : Cursor) return Vector;\n+\n+   function Right (Container : Vector; Position : Cursor) return Vector;\n+\n+private\n+\n+   pragma Inline (First_Index);\n+   pragma Inline (Last_Index);\n+   pragma Inline (Element);\n+   pragma Inline (First_Element);\n+   pragma Inline (Last_Element);\n+   pragma Inline (Query_Element);\n+   pragma Inline (Update_Element);\n+   pragma Inline (Replace_Element);\n+   pragma Inline (Contains);\n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n+   type Elements_Array is array (Count_Type range <>) of Element_Type;\n+   function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n+\n+   type Kind is (Plain, Part);\n+\n+   type Plain_Vector (Capacity : Capacity_Subtype) is record\n+      Elements : Elements_Array (1 .. Capacity);\n+      Last     : Extended_Index := No_Index;\n+      Busy     : Natural := 0;\n+      Lock     : Natural := 0;\n+   end record;\n+\n+   type Plain_Access is access all Plain_Vector;\n+\n+   type Vector (Capacity : Capacity_Subtype) is tagged record\n+      Plain : Plain_Access := new Plain_Vector (Capacity);\n+      K     : Kind := Formal_Vectors.Plain;\n+      First : Count_Type := 0;\n+      Last  : Index_Type'Base := No_Index;\n+   end record;\n+\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Vector);\n+\n+   for Vector'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Vector);\n+\n+   for Vector'Read use Read;\n+\n+   type Cursor is record\n+      Valid     : Boolean := True;\n+      Index     : Index_Type := Index_Type'First;\n+   end record;\n+\n+   procedure Write\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   Empty_Vector : constant Vector := (Capacity => 0, others => <>);\n+\n+   No_Element : constant Cursor := (Valid => False, Index => Index_Type'First);\n+\n+end Ada.Containers.Formal_Vectors;"}, {"sha": "59babb14581aeeaf3a2e669b17bec49ea499b3dc", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -224,19 +224,6 @@ package body Errout is\n       end if;\n    end Change_Error_Text;\n \n-   ------------------------------\n-   -- Check_Formal_Restriction --\n-   ------------------------------\n-\n-   procedure Check_Formal_Restriction (Msg : String; N : Node_Id) is\n-   begin\n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (Original_Node (N))\n-      then\n-         Error_Msg_F (\"|~~\" & Msg, N);\n-      end if;\n-   end Check_Formal_Restriction;\n-\n    ------------------------\n    -- Compilation_Errors --\n    ------------------------"}, {"sha": "57b8efe0abb79b1985ffd33df49a86d6d03bbb76", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -740,13 +740,6 @@ package Errout is\n    --  the given text. This text may contain insertion characters in the\n    --  usual manner, and need not be the same length as the original text.\n \n-   procedure Check_Formal_Restriction (Msg : String; N : Node_Id);\n-   --  Provides a wrappper on Error_Msg_F which prepends the special characters\n-   --  \"|~~\" (error not serious, language prepended) provided:\n-   --  * the current mode is formal verification.\n-   --  * the node N comes originally from source.\n-   --  Otherwise, does nothing.\n-\n    function First_Node (C : Node_Id) return Node_Id;\n    --  Given a construct C, finds the first node in the construct, i.e. the\n    --  one with the lowest Sloc value. This is useful in placing error msgs."}, {"sha": "788afa4c18b17ce187b8dafaecbf39b1cda52e07", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -512,7 +512,13 @@ package body Impunit is\n      \"a-cborse\",    -- Ada.Containers.Bounded_Ordered_Sets\n      \"a-cborma\",    -- Ada.Containers.Bounded_Ordered_Maps\n      \"a-cbhase\",    -- Ada.Containers.Bounded_Hashed_Sets\n-     \"a-cbhama\");   -- Ada.Containers.Bounded_Hashed_Maps\n+     \"a-cbhama\",    -- Ada.Containers.Bounded_Hashed_Maps\n+     \"a-cofove\",    -- Ada.Containers.Formal_Vectors\n+     \"a-cfdlli\",    -- Ada.Containers.Formal_Doubly_Linked_Lists\n+     \"a-cforse\",    -- Ada.Containers.Formal_Ordered_Sets\n+     \"a-cforma\",    -- Ada.Containers.Formal_Ordered_Maps\n+     \"a-cfhase\",    -- Ada.Containers.Formal_Hashed_Sets\n+     \"a-cfhama\");   -- Ada.Containers.Formal_Hashed_Maps\n \n    -----------------------\n    -- Alternative Units --"}, {"sha": "42746f111ca7012a0c5074b085d5bdcb52648627", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -105,6 +105,19 @@ package body Restrict is\n       Check_Restriction (No_Elaboration_Code, N);\n    end Check_Elaboration_Code_Allowed;\n \n+   ------------------------------\n+   -- Check_Formal_Restriction --\n+   ------------------------------\n+\n+   procedure Check_Formal_Restriction (Msg : String; N : Node_Id) is\n+   begin\n+      if Formal_Verification_Mode\n+        and then Comes_From_Source (Original_Node (N))\n+      then\n+         Error_Msg_F (\"|~~\" & Msg, N);\n+      end if;\n+   end Check_Formal_Restriction;\n+\n    -----------------------------------------\n    -- Check_Implicit_Dynamic_Code_Allowed --\n    -----------------------------------------"}, {"sha": "a13326ca8313450a4b6efeec5cb54333bb46920b", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -219,6 +219,12 @@ package Restrict is\n    --  an elaboration routine. If elaboration code is not allowed, an error\n    --  message is posted on the node given as argument.\n \n+   procedure Check_Formal_Restriction (Msg : String; N : Node_Id);\n+   --  Provides a wrappper on Error_Msg_F which prepends the special characters\n+   --  \"|~~\" (error not serious, language prepended) provided the current mode\n+   --  is formal verification and the node N comes originally from source.\n+   --  Otherwise, does nothing.\n+\n    procedure Check_Implicit_Dynamic_Code_Allowed (N : Node_Id);\n    --  Tests to see if dynamic code generation (dynamically generated\n    --  trampolines, in particular) is allowed by the current restrictions"}, {"sha": "2835caf0b419703509cd57e73d28ec964ec71904", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -40,6 +40,7 @@ with Namet.Sp; use Namet.Sp;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n+with Restrict; use Restrict;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Cat;  use Sem_Cat;\n@@ -1098,10 +1099,11 @@ package body Sem_Aggr is\n       end if;\n \n       --  An unqualified aggregate is restricted in SPARK or ALFA to:\n-      --  * an 'aggregate item' inside an aggregate for a multi-dimensional\n-      --    array.\n-      --  * an expression being assigned to an unconstrained array, but only\n-      --    if the aggregate specifies a value for OTHERS only.\n+\n+      --    An aggregate item inside an aggregate for a multi-dimensional array\n+\n+      --    An expression being assigned to an unconstrained array, but only if\n+      --    the aggregate specifies a value for OTHERS only.\n \n       if Nkind (Parent (N)) /= N_Qualified_Expression then\n          if Is_Array_Type (Etype (N)) then\n@@ -1114,7 +1116,7 @@ package body Sem_Aggr is\n                end if;\n \n                --  The following check is disabled until a proper place is\n-               --  found where the type of the parent node can be inspected.\n+               --  found where the type of the parent node can be inspected???\n \n --              elsif not (Nkind (Parent (N)) = N_Aggregate\n --                         and then Is_Array_Type (Etype (Parent (N)))\n@@ -1130,10 +1132,12 @@ package body Sem_Aggr is\n             Check_Formal_Restriction\n               (\"record aggregate should be qualified\", N);\n \n-            --  The type of aggregate is neither array nor record, so an error\n-            --  must have occurred during resolution. Do not report an\n-            --  additional message here.\n+         --  The type of aggregate is neither array nor record, so an error\n+         --  must have occurred during resolution. Do not report an additional\n+         --  message here.\n \n+         else\n+            null;\n          end if;\n       end if;\n \n@@ -1145,8 +1149,7 @@ package body Sem_Aggr is\n       if Raises_Constraint_Error (N) then\n          Aggr_Subtyp := Etype (N);\n          Rewrite (N,\n-           Make_Raise_Constraint_Error (Loc,\n-             Reason => CE_Range_Check_Failed));\n+           Make_Raise_Constraint_Error (Loc, Reason => CE_Range_Check_Failed));\n          Set_Raises_Constraint_Error (N);\n          Set_Etype (N, Aggr_Subtyp);\n          Set_Analyzed (N);\n@@ -3112,9 +3115,9 @@ package body Sem_Aggr is\n \n    begin\n       --  A record aggregate is restricted in SPARK or ALFA:\n-      --  * each named association can have only a single choice.\n-      --  * OTHERS cannot be used.\n-      --  * positional and named associations cannot be mixed.\n+      --    Each named association can have only a single choice.\n+      --    OTHERS cannot be used.\n+      --    Positional and named associations cannot be mixed.\n \n       if Present (Component_Associations (N))\n         and then Present (First (Component_Associations (N)))\n@@ -3128,19 +3131,21 @@ package body Sem_Aggr is\n \n          declare\n             Assoc : Node_Id;\n+\n          begin\n             Assoc := First (Component_Associations (N));\n-\n             while Present (Assoc) loop\n                if List_Length (Choices (Assoc)) > 1 then\n                   Check_Formal_Restriction\n                     (\"component association in record aggregate must \"\n                      & \"contain a single choice\", Assoc);\n                end if;\n+\n                if Nkind (First (Choices (Assoc))) = N_Others_Choice then\n                   Check_Formal_Restriction\n                     (\"record aggregate cannot contain OTHERS\", Assoc);\n                end if;\n+\n                Assoc := Next (Assoc);\n             end loop;\n          end;"}, {"sha": "08a08d8f68eb4974ca8307ffa867d6c58b9bb8d5", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -4966,6 +4966,7 @@ package body Sem_Ch12 is\n             else\n                Check_Private_View (Subtype_Indication (Parent (E)));\n             end if;\n+\n             Set_Is_Generic_Actual_Type (E, True);\n             Set_Is_Hidden (E, False);\n             Set_Is_Potentially_Use_Visible (E,\n@@ -5054,6 +5055,63 @@ package body Sem_Ch12 is\n             Set_Is_Hidden (E, False);\n          end if;\n \n+         if Ekind (E) = E_Constant then\n+\n+            --  If the type of the actual is a private type declared in the\n+            --  enclosing scope of the generic unit, the body of the generic\n+            --  sees the full view of the type (because it has to appear in\n+            --  the corresponding package body). If the type is private now,\n+            --  exchange views to restore the proper visiblity in the instance.\n+\n+            declare\n+               Typ          : constant Entity_Id := Base_Type (Etype (E));\n+               --  The type of the actual\n+\n+               Gen_Id       : Entity_Id;\n+               --  The generic unit\n+\n+               Parent_Scope : Entity_Id;\n+               --  The enclosing scope of the generic unit\n+\n+            begin\n+               if Is_Wrapper_Package (Instance) then\n+                  Gen_Id :=\n+                     Generic_Parent\n+                       (Specification\n+                         (Unit_Declaration_Node\n+                           (Related_Instance (Instance))));\n+               else\n+                  Gen_Id :=\n+                    Generic_Parent\n+                      (Specification (Unit_Declaration_Node (Instance)));\n+               end if;\n+\n+               Parent_Scope := Scope (Gen_Id);\n+\n+               --  The exchange is only needed if the generic is defined\n+               --  within a package which is not a common ancestor of the\n+               --  scope of the instance, and is not already in scope.\n+\n+               if Is_Private_Type (Typ)\n+                 and then Scope (Typ) = Parent_Scope\n+                 and then Scope (Instance) /= Parent_Scope\n+                 and then Ekind (Parent_Scope) = E_Package\n+                 and then not Is_Child_Unit (Gen_Id)\n+               then\n+                  Switch_View (Typ);\n+\n+                  --  If the type of the entity is a subtype, it may also\n+                  --  have to be made visible, together with the base type\n+                  --  of its full view, after exchange.\n+\n+                  if Is_Private_Type (Etype (E)) then\n+                     Switch_View (Etype (E));\n+                     Switch_View (Base_Type (Etype (E)));\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+\n          Next_Entity (E);\n       end loop;\n    end Check_Generic_Actuals;"}, {"sha": "65880d5604eec8fe2e4ec0425d0801107a0f2979", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -36,6 +36,7 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n+with Restrict; use Restrict;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n@@ -1860,8 +1861,9 @@ package body Sem_Ch5 is\n                --  SPARK or ALFA.\n \n                if Nkind (DS) = N_Range then\n-                  Check_Formal_Restriction (\"loop parameter specification \"\n-                                            & \"must include subtype mark\", N);\n+                  Check_Formal_Restriction\n+                    (\"loop parameter specification must include subtype mark\",\n+                     N);\n                end if;\n \n                --  Now analyze the subtype definition. If it is a range, create"}, {"sha": "14824ca385b58082fa207b7f01494ccd6a895242", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd65a2d74050033a6edbb61871bb2e57b9df6eb2/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=bd65a2d74050033a6edbb61871bb2e57b9df6eb2", "patch": "@@ -40,6 +40,7 @@ with Lib.Xref; use Lib.Xref;\n with Nlists;   use Nlists;\n with Output;   use Output;\n with Opt;      use Opt;\n+with Restrict; use Restrict;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;"}]}