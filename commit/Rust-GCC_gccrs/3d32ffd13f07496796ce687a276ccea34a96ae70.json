{"sha": "3d32ffd13f07496796ce687a276ccea34a96ae70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QzMmZmZDEzZjA3NDk2Nzk2Y2U2ODdhMjc2Y2NlYTM0YTk2YWU3MA==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-25T10:14:05Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-25T10:14:05Z"}, "message": "(expand_divmod): Eliminate the generation of branches\n\twhen possible.\n\nFrom-SVN: r1687", "tree": {"sha": "de4be488decee1b41097f56119290f5340ff1996", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de4be488decee1b41097f56119290f5340ff1996"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d32ffd13f07496796ce687a276ccea34a96ae70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d32ffd13f07496796ce687a276ccea34a96ae70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d32ffd13f07496796ce687a276ccea34a96ae70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d32ffd13f07496796ce687a276ccea34a96ae70/comments", "author": null, "committer": null, "parents": [{"sha": "3a6aca8e65b3096c59bef64888ef6f54a94606e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a6aca8e65b3096c59bef64888ef6f54a94606e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a6aca8e65b3096c59bef64888ef6f54a94606e3"}], "stats": {"total": 66, "additions": 54, "deletions": 12}, "files": [{"sha": "5b6ed4d08f871c55ad01c0a32628d9e1a64cba39", "filename": "gcc/expmed.c", "status": "modified", "additions": 54, "deletions": 12, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d32ffd13f07496796ce687a276ccea34a96ae70/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d32ffd13f07496796ce687a276ccea34a96ae70/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=3d32ffd13f07496796ce687a276ccea34a96ae70", "patch": "@@ -2156,6 +2156,12 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n   rtx adjusted_op0 = op0;\n   optab optab1, optab2;\n \n+  /* We shouldn't be called with op1 == const1_rtx, but some of the\n+     code below will malfunction if we are, so check here and handle\n+     the special case if so.  */\n+  if (op1 == const1_rtx)\n+    return rem_flag ? const0_rtx : op0;\n+\n   /* Don't use the function value register as a target\n      since we have to read it as well as write it,\n      and function-inlining gets confused by this.  */\n@@ -2273,7 +2279,6 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n     case TRUNC_DIV_EXPR:\n       if (log >= 0 && ! unsignedp)\n \t{\n-\t  rtx label = gen_label_rtx ();\n \t  if (! can_clobber_op0)\n \t    {\n \t      adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target,\n@@ -2282,11 +2287,32 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t which will screw up mem refs for autoincrements.  */\n \t      op0 = force_reg (compute_mode, op0);\n \t    }\n-\t  emit_cmp_insn (adjusted_op0, const0_rtx, GE, \n-\t\t\t NULL_RTX, compute_mode, 0, 0);\n-\t  emit_jump_insn (gen_bge (label));\n-\t  expand_inc (adjusted_op0, plus_constant (op1, -1));\n-\t  emit_label (label);\n+\t  /* Here we need to add OP1-1 if OP0 is negative, 0 otherwise.\n+\t     This can be computed without jumps by arithmetically shifting\n+\t     OP0 right LOG-1 places and then shifting right logically\n+\t     SIZE-LOG bits.  The resulting value is unconditionally added\n+\t     to OP0.  */\n+\t  if (log == 1 || BRANCH_COST >= 3)\n+\t    {\n+\t      rtx temp = gen_reg_rtx (compute_mode);\n+\t      temp = copy_to_suggested_reg (adjusted_op0, temp, compute_mode);\n+\t      temp = expand_shift (RSHIFT_EXPR, compute_mode, temp,\n+\t\t\t\t   build_int_2 (log - 1, 0), NULL_RTX, 0);\n+\t      temp = expand_shift (RSHIFT_EXPR, compute_mode, temp,\n+\t\t\t\t   build_int_2 (GET_MODE_BITSIZE (mode) - log,\n+\t\t\t\t\t\t0),\n+\t\t\t\t   temp, 1);\n+\t      expand_inc (adjusted_op0, temp);\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx label = gen_label_rtx ();\n+\t      emit_cmp_insn (adjusted_op0, const0_rtx, GE, \n+\t\t\t     NULL_RTX, compute_mode, 0, 0);\n+\t      emit_jump_insn (gen_bge (label));\n+\t      expand_inc (adjusted_op0, plus_constant (op1, -1));\n+\t      emit_label (label);\n+\t    }\n \t  mod_insn_no_good = 1;\n \t}\n       break;\n@@ -2364,12 +2390,28 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\t      integer_one_node, NULL_RTX, 0);\n \t  if (! unsignedp)\n \t    {\n-\t      rtx label = gen_label_rtx ();\n-\t      emit_cmp_insn (adjusted_op0, const0_rtx, GE, NULL_RTX,\n-\t\t\t     compute_mode, 0, 0);\n-\t      emit_jump_insn (gen_bge (label));\n-\t      expand_unop (compute_mode, neg_optab, op1, op1, 0);\n-\t      emit_label (label);\n+\t      if (BRANCH_COST >= 2)\n+\t\t{\n+\t\t  /* Negate OP1 if OP0 < 0.  Do this by computing a temporary\n+\t\t     that has all bits equal to the sign bit and exclusive\n+\t\t     or-ing it with OP1.  */\n+\t\t  rtx temp = gen_reg_rtx (compute_mode);\n+\t\t  temp = copy_to_suggested_reg (adjusted_op0, temp, compute_mode);\n+\t\t  temp = expand_shift (RSHIFT_EXPR, compute_mode, temp,\n+\t\t\t\t       build_int_2 (GET_MODE_BITSIZE (mode) - 1, 0),\n+\t\t\t\t       NULL_RTX, 0);\n+\t\t  op1 = expand_binop (compute_mode, xor_optab, op1, temp, op1,\n+\t\t\t\t      unsignedp, OPTAB_LIB_WIDEN);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx label = gen_label_rtx ();\n+\t\t  emit_cmp_insn (adjusted_op0, const0_rtx, GE, NULL_RTX,\n+\t\t\t\t compute_mode, 0, 0);\n+\t\t  emit_jump_insn (gen_bge (label));\n+\t\t  expand_unop (compute_mode, neg_optab, op1, op1, 0);\n+\t\t  emit_label (label);\n+\t\t}\n \t    }\n \t  expand_inc (adjusted_op0, op1);\n \t}"}]}