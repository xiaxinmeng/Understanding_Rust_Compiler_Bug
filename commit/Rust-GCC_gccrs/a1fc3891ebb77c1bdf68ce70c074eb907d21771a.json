{"sha": "a1fc3891ebb77c1bdf68ce70c074eb907d21771a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFmYzM4OTFlYmI3N2MxYmRmNjhjZTcwYzA3NGViOTA3ZDIxNzcxYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-09-10T20:25:32Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-09-10T20:25:32Z"}, "message": "go/internal/gccgoimporter: support embedded field in pointer loop\n    \n    Backport of https://golang.org/cl/194440.  Original description:\n    \n        If an embedded field refers to a type via a pointer, the parser needs\n        to know the name of the embedded field. It is possible that the\n        pointer type is not yet resolved. This CL fixes the parser to handle\n        that case by setting the pointer element type to the unresolved named\n        type while the pointer is being resolved.\n    \n    Updates golang/go#34182\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/194562\n\nFrom-SVN: r275606", "tree": {"sha": "a024cf28fec03c64a811a8e271913a0150ce5b5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a024cf28fec03c64a811a8e271913a0150ce5b5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1fc3891ebb77c1bdf68ce70c074eb907d21771a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1fc3891ebb77c1bdf68ce70c074eb907d21771a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1fc3891ebb77c1bdf68ce70c074eb907d21771a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1fc3891ebb77c1bdf68ce70c074eb907d21771a/comments", "author": null, "committer": null, "parents": [{"sha": "d7fb4c3162307590c0babddcea4fb60c07a7c033", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7fb4c3162307590c0babddcea4fb60c07a7c033", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7fb4c3162307590c0babddcea4fb60c07a7c033"}], "stats": {"total": 101, "additions": 75, "deletions": 26}, "files": [{"sha": "5591c1dfc52597b9a19bec2271d7b17f11ff2fa7", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fc3891ebb77c1bdf68ce70c074eb907d21771a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fc3891ebb77c1bdf68ce70c074eb907d21771a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=a1fc3891ebb77c1bdf68ce70c074eb907d21771a", "patch": "@@ -1,4 +1,4 @@\n-68038b4fdf1456482af986cb05dcf3121bd43ffc\n+556451586b10584e4778694c84b03d0ecbbab150\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "37250fde413e4133f8518580b454388f3bd8b65c", "filename": "libgo/go/go/internal/gccgoimporter/importer_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fc3891ebb77c1bdf68ce70c074eb907d21771a/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fc3891ebb77c1bdf68ce70c074eb907d21771a/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter_test.go?ref=a1fc3891ebb77c1bdf68ce70c074eb907d21771a", "patch": "@@ -96,6 +96,7 @@ var importerTests = [...]importerTest{\n \t{pkgpath: \"issue29198\", name: \"FooServer\", gccgoVersion: 7, want: \"type FooServer struct{FooServer *FooServer; user string; ctx context.Context}\"},\n \t{pkgpath: \"issue30628\", name: \"Apple\", want: \"type Apple struct{hey sync.RWMutex; x int; RQ [517]struct{Count uintptr; NumBytes uintptr; Last uintptr}}\"},\n \t{pkgpath: \"issue31540\", name: \"S\", gccgoVersion: 7, want: \"type S struct{b int; map[Y]Z}\"},\n+\t{pkgpath: \"issue34182\", name: \"T1\", want: \"type T1 struct{f *T2}\"},\n }\n \n func TestGoxImporter(t *testing.T) {"}, {"sha": "c089b5e054177f81e743898049cb258075c7395c", "filename": "libgo/go/go/internal/gccgoimporter/parser.go", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fc3891ebb77c1bdf68ce70c074eb907d21771a/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fc3891ebb77c1bdf68ce70c074eb907d21771a/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go?ref=a1fc3891ebb77c1bdf68ce70c074eb907d21771a", "patch": "@@ -254,7 +254,7 @@ func (p *parser) parseField(pkg *types.Package) (field *types.Var, tag string) {\n \t\t\tcase *types.Named:\n \t\t\t\tname = typ.Obj().Name()\n \t\t\tdefault:\n-\t\t\t\tp.error(\"anonymous field expected\")\n+\t\t\t\tp.error(\"embedded field expected\")\n \t\t\t}\n \t\t}\n \t}\n@@ -469,8 +469,12 @@ func (p *parser) reserve(n int) {\n \t}\n }\n \n-// update sets the type map entries for the given type numbers nlist to t.\n-func (p *parser) update(t types.Type, nlist []int) {\n+// update sets the type map entries for the entries in nlist to t.\n+// An entry in nlist can be a type number in p.typeList,\n+// used to resolve named types, or it can be a *types.Pointer,\n+// used to resolve pointers to named types in case they are referenced\n+// by embedded fields.\n+func (p *parser) update(t types.Type, nlist []interface{}) {\n \tif len(nlist) != 0 {\n \t\tif t == reserved {\n \t\t\tp.errorf(\"internal error: update(%v) invoked on reserved\", nlist)\n@@ -480,20 +484,34 @@ func (p *parser) update(t types.Type, nlist []int) {\n \t\t}\n \t}\n \tfor _, n := range nlist {\n-\t\tif p.typeList[n] == t {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif p.typeList[n] != reserved {\n-\t\t\tp.errorf(\"internal error: update(%v): %d not reserved\", nlist, n)\n+\t\tswitch n := n.(type) {\n+\t\tcase int:\n+\t\t\tif p.typeList[n] == t {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif p.typeList[n] != reserved {\n+\t\t\t\tp.errorf(\"internal error: update(%v): %d not reserved\", nlist, n)\n+\t\t\t}\n+\t\t\tp.typeList[n] = t\n+\t\tcase *types.Pointer:\n+\t\t\tif *n != (types.Pointer{}) {\n+\t\t\t\telem := n.Elem()\n+\t\t\t\tif elem == t {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tp.errorf(\"internal error: update: pointer already set to %v, expected %v\", elem, t)\n+\t\t\t}\n+\t\t\t*n = *types.NewPointer(t)\n+\t\tdefault:\n+\t\t\tp.errorf(\"internal error: %T on nlist\", n)\n \t\t}\n-\t\tp.typeList[n] = t\n \t}\n }\n \n // NamedType = TypeName [ \"=\" ] Type { Method } .\n // TypeName  = ExportedName .\n // Method    = \"func\" \"(\" Param \")\" Name ParamList ResultList [InlineBody] \";\" .\n-func (p *parser) parseNamedType(nlist []int) types.Type {\n+func (p *parser) parseNamedType(nlist []interface{}) types.Type {\n \tpkg, name := p.parseExportedName()\n \tscope := pkg.Scope()\n \tobj := scope.Lookup(name)\n@@ -504,7 +522,7 @@ func (p *parser) parseNamedType(nlist []int) types.Type {\n \t// type alias\n \tif p.tok == '=' {\n \t\tp.next()\n-\t\tp.aliases[nlist[len(nlist)-1]] = name\n+\t\tp.aliases[nlist[len(nlist)-1].(int)] = name\n \t\tif obj != nil {\n \t\t\t// use the previously imported (canonical) type\n \t\t\tt := obj.Type()\n@@ -603,7 +621,7 @@ func (p *parser) parseInt() int {\n }\n \n // ArrayOrSliceType = \"[\" [ int ] \"]\" Type .\n-func (p *parser) parseArrayOrSliceType(pkg *types.Package, nlist []int) types.Type {\n+func (p *parser) parseArrayOrSliceType(pkg *types.Package, nlist []interface{}) types.Type {\n \tp.expect('[')\n \tif p.tok == ']' {\n \t\tp.next()\n@@ -626,7 +644,7 @@ func (p *parser) parseArrayOrSliceType(pkg *types.Package, nlist []int) types.Ty\n }\n \n // MapType = \"map\" \"[\" Type \"]\" Type .\n-func (p *parser) parseMapType(pkg *types.Package, nlist []int) types.Type {\n+func (p *parser) parseMapType(pkg *types.Package, nlist []interface{}) types.Type {\n \tp.expectKeyword(\"map\")\n \n \tt := new(types.Map)\n@@ -642,7 +660,7 @@ func (p *parser) parseMapType(pkg *types.Package, nlist []int) types.Type {\n }\n \n // ChanType = \"chan\" [\"<-\" | \"-<\"] Type .\n-func (p *parser) parseChanType(pkg *types.Package, nlist []int) types.Type {\n+func (p *parser) parseChanType(pkg *types.Package, nlist []interface{}) types.Type {\n \tp.expectKeyword(\"chan\")\n \n \tt := new(types.Chan)\n@@ -669,7 +687,7 @@ func (p *parser) parseChanType(pkg *types.Package, nlist []int) types.Type {\n }\n \n // StructType = \"struct\" \"{\" { Field } \"}\" .\n-func (p *parser) parseStructType(pkg *types.Package, nlist []int) types.Type {\n+func (p *parser) parseStructType(pkg *types.Package, nlist []interface{}) types.Type {\n \tp.expectKeyword(\"struct\")\n \n \tt := new(types.Struct)\n@@ -736,7 +754,7 @@ func (p *parser) parseResultList(pkg *types.Package) *types.Tuple {\n }\n \n // FunctionType = ParamList ResultList .\n-func (p *parser) parseFunctionType(pkg *types.Package, nlist []int) *types.Signature {\n+func (p *parser) parseFunctionType(pkg *types.Package, nlist []interface{}) *types.Signature {\n \tt := new(types.Signature)\n \tp.update(t, nlist)\n \n@@ -776,7 +794,7 @@ func (p *parser) parseFunc(pkg *types.Package) *types.Func {\n }\n \n // InterfaceType = \"interface\" \"{\" { (\"?\" Type | Func) \";\" } \"}\" .\n-func (p *parser) parseInterfaceType(pkg *types.Package, nlist []int) types.Type {\n+func (p *parser) parseInterfaceType(pkg *types.Package, nlist []interface{}) types.Type {\n \tp.expectKeyword(\"interface\")\n \n \tt := new(types.Interface)\n@@ -805,7 +823,7 @@ func (p *parser) parseInterfaceType(pkg *types.Package, nlist []int) types.Type\n }\n \n // PointerType = \"*\" (\"any\" | Type) .\n-func (p *parser) parsePointerType(pkg *types.Package, nlist []int) types.Type {\n+func (p *parser) parsePointerType(pkg *types.Package, nlist []interface{}) types.Type {\n \tp.expect('*')\n \tif p.tok == scanner.Ident {\n \t\tp.expectKeyword(\"any\")\n@@ -817,13 +835,13 @@ func (p *parser) parsePointerType(pkg *types.Package, nlist []int) types.Type {\n \tt := new(types.Pointer)\n \tp.update(t, nlist)\n \n-\t*t = *types.NewPointer(p.parseType(pkg))\n+\t*t = *types.NewPointer(p.parseType(pkg, t))\n \n \treturn t\n }\n \n // TypeSpec = NamedType | MapType | ChanType | StructType | InterfaceType | PointerType | ArrayOrSliceType | FunctionType .\n-func (p *parser) parseTypeSpec(pkg *types.Package, nlist []int) types.Type {\n+func (p *parser) parseTypeSpec(pkg *types.Package, nlist []interface{}) types.Type {\n \tswitch p.tok {\n \tcase scanner.String:\n \t\treturn p.parseNamedType(nlist)\n@@ -912,14 +930,14 @@ func lookupBuiltinType(typ int) types.Type {\n //\n // parseType updates the type map to t for all type numbers n.\n //\n-func (p *parser) parseType(pkg *types.Package, n ...int) types.Type {\n+func (p *parser) parseType(pkg *types.Package, n ...interface{}) types.Type {\n \tp.expect('<')\n \tt, _ := p.parseTypeAfterAngle(pkg, n...)\n \treturn t\n }\n \n // (*parser).Type after reading the \"<\".\n-func (p *parser) parseTypeAfterAngle(pkg *types.Package, n ...int) (t types.Type, n1 int) {\n+func (p *parser) parseTypeAfterAngle(pkg *types.Package, n ...interface{}) (t types.Type, n1 int) {\n \tp.expectKeyword(\"type\")\n \n \tn1 = 0\n@@ -962,7 +980,7 @@ func (p *parser) parseTypeAfterAngle(pkg *types.Package, n ...int) (t types.Type\n // parseTypeExtended is identical to parseType, but if the type in\n // question is a saved type, returns the index as well as the type\n // pointer (index returned is zero if we parsed a builtin).\n-func (p *parser) parseTypeExtended(pkg *types.Package, n ...int) (t types.Type, n1 int) {\n+func (p *parser) parseTypeExtended(pkg *types.Package, n ...interface{}) (t types.Type, n1 int) {\n \tp.expect('<')\n \tt, n1 = p.parseTypeAfterAngle(pkg, n...)\n \treturn\n@@ -1044,12 +1062,12 @@ func (p *parser) parseTypes(pkg *types.Package) {\n \t}\n \n \tfor i := 1; i < int(exportedp1); i++ {\n-\t\tp.parseSavedType(pkg, i, []int{})\n+\t\tp.parseSavedType(pkg, i, nil)\n \t}\n }\n \n // parseSavedType parses one saved type definition.\n-func (p *parser) parseSavedType(pkg *types.Package, i int, nlist []int) {\n+func (p *parser) parseSavedType(pkg *types.Package, i int, nlist []interface{}) {\n \tdefer func(s *scanner.Scanner, tok rune, lit string) {\n \t\tp.scanner = s\n \t\tp.tok = tok"}, {"sha": "2a5c333a05791fa399a7cf2b870a3a26e0276eb9", "filename": "libgo/go/go/internal/gccgoimporter/testdata/issue34182.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fc3891ebb77c1bdf68ce70c074eb907d21771a/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fissue34182.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fc3891ebb77c1bdf68ce70c074eb907d21771a/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fissue34182.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fissue34182.go?ref=a1fc3891ebb77c1bdf68ce70c074eb907d21771a", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package issue34182\n+\n+type T1 struct {\n+\tf *T2\n+}\n+\n+type T2 struct {\n+\tf T3\n+}\n+\n+type T3 struct {\n+\t*T2\n+}"}, {"sha": "671a7d62d6f62bcaaaee1c6cb194a5a0c38da087", "filename": "libgo/go/go/internal/gccgoimporter/testdata/issue34182.gox", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fc3891ebb77c1bdf68ce70c074eb907d21771a/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fissue34182.gox", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fc3891ebb77c1bdf68ce70c074eb907d21771a/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fissue34182.gox", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Ftestdata%2Fissue34182.gox?ref=a1fc3891ebb77c1bdf68ce70c074eb907d21771a", "patch": "@@ -0,0 +1,13 @@\n+v3;\n+package issue34182\n+pkgpath issue34182\n+init issue34182 ~go.issue34182\n+types 8 4 21 21 21 17 30 45 45\n+type 1 \"T1\" <type 6>\n+type 2 \"T2\" <type 7>\n+type 3 \"T3\" <type 5>\n+type 4 *<type 2>\n+type 5 struct { ? <type 4>; }\n+type 6 struct { .go.issue34182.f <type 4>; }\n+type 7 struct { .go.issue34182.f <type 3>; }\n+checksum FF02C49BAF44B06C087ED4E573F7CC880C79C208"}]}