{"sha": "913eb73e8a1057c50771e484dda36cf305cd4d57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEzZWI3M2U4YTEwNTdjNTA3NzFlNDg0ZGRhMzZjZjMwNWNkNGQ1Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T12:34:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T12:34:06Z"}, "message": "[multiple changes]\n\n2010-09-09  Ben Brosgol  <brosgol@adacore.com>\n\n\t* gnat_rm.texi: Minor wordsmithing of section on pragma Ordered.\n\n2010-09-09  Arnaud Charlet  <charlet@adacore.com>\n\n\t* par-ch2.adb (Scan_Pragma_Argument_Association): In CodePeer mode,\n\tdo not generate an error for compatibility with legacy code.\n\tignored when generating SCIL.\n\t* sem_attr.adb (Resolve_Attribute): Ignore AI-229 in CodePeer mode.\n\nFrom-SVN: r164082", "tree": {"sha": "2ebb2b22186f80f5bd68f4133e0e4c4d701dad8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ebb2b22186f80f5bd68f4133e0e4c4d701dad8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/913eb73e8a1057c50771e484dda36cf305cd4d57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/913eb73e8a1057c50771e484dda36cf305cd4d57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/913eb73e8a1057c50771e484dda36cf305cd4d57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/913eb73e8a1057c50771e484dda36cf305cd4d57/comments", "author": null, "committer": null, "parents": [{"sha": "c90b20580d68059a45e6599e3afb6bb120fa0451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c90b20580d68059a45e6599e3afb6bb120fa0451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c90b20580d68059a45e6599e3afb6bb120fa0451"}], "stats": {"total": 118, "additions": 70, "deletions": 48}, "files": [{"sha": "2b990566d8675a424dd125542627df4c59a51edf", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/913eb73e8a1057c50771e484dda36cf305cd4d57/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/913eb73e8a1057c50771e484dda36cf305cd4d57/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=913eb73e8a1057c50771e484dda36cf305cd4d57", "patch": "@@ -1,3 +1,14 @@\n+2010-09-09  Ben Brosgol  <brosgol@adacore.com>\n+\n+\t* gnat_rm.texi: Minor wordsmithing of section on pragma Ordered.\n+\n+2010-09-09  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* par-ch2.adb (Scan_Pragma_Argument_Association): In CodePeer mode,\n+\tdo not generate an error for compatibility with legacy code.\n+\tignored when generating SCIL.\n+\t* sem_attr.adb (Resolve_Attribute): Ignore AI-229 in CodePeer mode.\n+\n 2010-09-09  Thomas Quinot  <quinot@adacore.com>\n \n \t* s-strxdr.adb, gnat_rm.texi, s-stratt-xdr.adb, s-stratt.ads: Rename"}, {"sha": "09fcb145fa4e9a2630010e0a55f537c3ba5c18ff", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/913eb73e8a1057c50771e484dda36cf305cd4d57/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/913eb73e8a1057c50771e484dda36cf305cd4d57/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=913eb73e8a1057c50771e484dda36cf305cd4d57", "patch": "@@ -3731,6 +3731,7 @@ pragma appears at the start of the file.\n @node Pragma Ordered\n @unnumberedsec Pragma Ordered\n @findex Ordered\n+@findex pragma @code{Ordered}\n @noindent\n Syntax:\n \n@@ -3740,84 +3741,88 @@ pragma Ordered (enumeration_first_subtype_LOCAL_NAME);\n \n @noindent\n Most enumeration types are from a conceptual point of view unordered.\n-For example, if we write:\n+For example, consider:\n \n @smallexample @c ada\n type Color is (Red, Blue, Green, Yellow);\n @end smallexample\n \n @noindent\n-Then Ada semantics says that Blue > Red, and Green > Blue, but really\n-these relations make no sense, the enumeration type merely specifies\n-a set of possible colors, and the order is unimportant.\n+By Ada semantics @code{Blue > Red} and @code{Green > Blue},\n+but really these relations make no sense; the enumeration type merely\n+specifies a set of possible colors, and the order is unimportant.\n \n-@noindent\n-For such unordered enumeration types, it is generally a good idea if\n-clients avoid comparisons (other than equality or inequality), or\n-explicit ranges. For example, if we have code buried in some client\n-that says:\n+For unordered enumeration types, it is generally a good idea if\n+clients avoid comparisons (other than equality or inequality) and\n+explicit ranges. (A @emph{client} is a unit where the type is referenced,\n+other than the unit where the type is declared, its body, and its subunits.)\n+For example, if code buried in some client says:\n \n @smallexample @c ada\n-if Current_Color < Yellow ....\n-if Current_Color in Blue .. Green\n+if Current_Color < Yellow then ...\n+if Current_Color in Blue .. Green then ...\n @end smallexample\n \n @noindent\n-Then the code is relying on the order, which is undesriable in this case.\n+then the client code is relying on the order, which is undesirable.\n It makes the code hard to read and creates maintenance difficulties if\n-entries have to be added to the enumeration type. In cases like this,\n-we prefer if the code in the client lists the possibilities, or an\n-appropriate subtype is declared in the parent package, e.g. for the\n-above case, we might have in the parent package:\n+entries have to be added to the enumeration type. Instead,\n+the code in the client should list the possibilities, or an\n+appropriate subtype should be declared in the unit that declares\n+the original enumeration type. E.g., the following subtype could\n+be declared along with the type @code{Color}:\n \n @smallexample @c ada\n subtype RBG is Color range Red .. Green;\n @end smallexample\n \n @noindent\n-and then in the client we could write:\n+and then the client could write:\n \n @smallexample @c ada\n-if Current_Color in RBG ....\n-if Current_Color = Blue or Current_Color = Green ...\n+if Current_Color in RBG then ...\n+if Current_Color = Blue or Current_Color = Green then ...\n @end smallexample\n \n @noindent\n-\n-However some enumeration types are legitimately ordered from a conceptual\n-point of view. For example, if you have:\n+However, some enumeration types are legitimately ordered from a conceptual\n+point of view. For example, if you declare:\n \n @smallexample @c ada\n type Day is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);\n @end smallexample\n \n @noindent\n-then the ordering imposed by the language is reasonable, and it\n-is fine for clients to depend on this, writing for example:\n+then the ordering imposed by the language is reasonable, and \n+clients can depend on it, writing for example:\n \n @smallexample @c ada\n-if D in Mon .. Fri then\n-if D < Wed\n+if D in Mon .. Fri then ...\n+if D < Wed then ...\n @end smallexample\n \n @noindent\n-pragma @option{Order} is provided to mark enumeration types that\n-are conceptually ordered, warning the reader that clients may depend\n-on the ordering. We provide a pragma to mark enumerations as Ordered\n-rather than one to mark them as Unordered, since in our experience,\n-the great majority of enumeration types are conceptually Unordered.\n+The pragma @option{Ordered} is provided to mark enumeration types that\n+are conceptually ordered, alerting the reader that clients may depend\n+on the ordering. GNAT provides a pragma to mark enumerations as ordered\n+rather than one to mark them as unordered, since in our experience,\n+the great majority of enumeration types are conceptually unordered.\n \n-The types Boolean, Character, Wide_Character, and Wide_Wide_Character\n-are considered to be ordered types, so there is a pragma Ordered\n-present in Standard for these types.\n+The types @code{Boolean}, @code{Character}, @code{Wide_Character},\n+and @code{Wide_Wide_Character}\n+are considered to be ordered types, so each is declared with a\n+pragma @code{Ordered} in package @code{Standard}.\n \n-Normally pragma Order serves as only documentation and a guide for\n-coding standards, but GNAT provides a warning switch -gnatw.u that\n+Normally pragma @code{Ordered} serves only as documentation and a guide for\n+coding standards, but GNAT provides a warning switch @option{-gnatw.u} that\n requests warnings for inappropriate uses (comparisons and explicit\n subranges) for unordered types. If this switch is used, then any\n-enumeration type not marked with pragma Ordered will be considered\n+enumeration type not marked with pragma @code{Ordered} will be considered\n as unordered, and will generate warnings for inappropriate uses.\n \n+For additional information please refer to the description of the\n+@option{-gnatw.u} switch in the @value{EDITION} User's Guide.\n+\n @node Pragma Passive\n @unnumberedsec Pragma Passive\n @findex Passive"}, {"sha": "6a0a18d30df05142a83a0271cf657b0632c14362", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/913eb73e8a1057c50771e484dda36cf305cd4d57/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/913eb73e8a1057c50771e484dda36cf305cd4d57/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=913eb73e8a1057c50771e484dda36cf305cd4d57", "patch": "@@ -5613,12 +5613,13 @@ the effect of @option{-gnatwF}).\n @emph{Activate warnings on unordered enumeration types.}\n @cindex @option{-gnatw.u} (@command{gcc})\n This switch causes enumeration types to be considered as conceptually\n-unordered, unless an explicit pragma Order is given for the type. The\n-effect is to generate warnings in clients that use explicit comparisons\n+unordered, unless an explicit pragma @code{Ordered} is given for the type.\n+The effect is to generate warnings in clients that use explicit comparisons\n or subranges, since these constructs both treat objects of the type as\n-ordered. A client is defined as a unit that is other than the unit in\n-which the type is declared, or its body or subunits. See description\n-of pragma Order in the GNAT RM for further details.\n+ordered. (A @emph{client} is defined as a unit that is other than the unit in\n+which the type is declared, or its body or subunits.) Please refer to\n+the description of pragma @code{Ordered} in the\n+@cite{@value{EDITION} Reference Manual} for further details.\n \n @item -gnatw.U\n @emph{Deactivate warnings on unordered enumeration types.}"}, {"sha": "e0bf09dd64688c924c62b042168bd87fe9156c35", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/913eb73e8a1057c50771e484dda36cf305cd4d57/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/913eb73e8a1057c50771e484dda36cf305cd4d57/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=913eb73e8a1057c50771e484dda36cf305cd4d57", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -501,11 +501,13 @@ package body Ch2 is\n          Id_Present := False;\n       end if;\n \n-      if Identifier_Seen and not Id_Present then\n-         Error_Msg_SC\n-           (\"|pragma argument identifier required here\");\n-         Error_Msg_SC\n-           (\"\\since previous argument had identifier (RM 2.8(4))\");\n+      if Identifier_Seen and not Id_Present and not CodePeer_Mode then\n+         --  In CodePeer mode, we do not generate an error for compatibility\n+         --  with legacy code, since this error can be safely ignored when\n+         --  generating SCIL.\n+\n+         Error_Msg_SC (\"|pragma argument identifier required here\");\n+         Error_Msg_SC (\"\\since previous argument had identifier (RM 2.8(4))\");\n       end if;\n \n       if Id_Present then"}, {"sha": "3eccf93c0069840045b664b97be97f7a618be647", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/913eb73e8a1057c50771e484dda36cf305cd4d57/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/913eb73e8a1057c50771e484dda36cf305cd4d57/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=913eb73e8a1057c50771e484dda36cf305cd4d57", "patch": "@@ -7930,6 +7930,8 @@ package body Sem_Attr is\n                   --  didn't permit the access to be declared in the generic\n                   --  spec, whereas the revised rule does (as long as it's not\n                   --  a formal type).\n+                  --  Note that we relax this check in CodePeer mode for\n+                  --  compatibility with legacy code.\n \n                   --  There are a couple of subtleties of the test for applying\n                   --  the check that are worth noting. First, we only apply it\n@@ -7950,6 +7952,7 @@ package body Sem_Attr is\n                   --  been caught by the compilation of the generic unit.\n \n                   elsif Attr_Id = Attribute_Access\n+                    and then not CodePeer_Mode\n                     and then not In_Instance\n                     and then Present (Enclosing_Generic_Unit (Entity (P)))\n                     and then Present (Enclosing_Generic_Body (N))"}]}