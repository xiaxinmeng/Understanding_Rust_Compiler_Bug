{"sha": "c87222f0749e8a97e3843355be012a9243ffd4f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg3MjIyZjA3NDllOGE5N2UzODQzMzU1YmUwMTJhOTI0M2ZmZDRmMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-11-29T17:53:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-11-29T17:53:13Z"}, "message": "* init.c: Remove obsolete dwarf2 frame.h section.\n\nFrom-SVN: r47445", "tree": {"sha": "8f2f1b0d3ff18d2e77aab31a5848cd5792126328", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f2f1b0d3ff18d2e77aab31a5848cd5792126328"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c87222f0749e8a97e3843355be012a9243ffd4f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c87222f0749e8a97e3843355be012a9243ffd4f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c87222f0749e8a97e3843355be012a9243ffd4f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c87222f0749e8a97e3843355be012a9243ffd4f3/comments", "author": null, "committer": null, "parents": [{"sha": "2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6"}], "stats": {"total": 327, "additions": 5, "deletions": 322}, "files": [{"sha": "e0bcba8bc5c079d78009094682af7f7f7e5c9daf", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87222f0749e8a97e3843355be012a9243ffd4f3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87222f0749e8a97e3843355be012a9243ffd4f3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c87222f0749e8a97e3843355be012a9243ffd4f3", "patch": "@@ -1,3 +1,7 @@\n+2001-11-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* init.c: Remove obsolete dwarf2 frame.h section.\n+\n 2001-11-29  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* Make-lang.in (ada.generated-manpages): New dummy target."}, {"sha": "e4a83cfc5a07449fc6e0fde2303be0dfb465c10a", "filename": "gcc/ada/init.c", "status": "modified", "additions": 1, "deletions": 322, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87222f0749e8a97e3843355be012a9243ffd4f3/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87222f0749e8a97e3843355be012a9243ffd4f3/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=c87222f0749e8a97e3843355be012a9243ffd4f3", "patch": "@@ -4,7 +4,7 @@\n  *                                                                          *\n  *                                 I N I T                                  *\n  *                                                                          *\n- *                            $Revision$\n+ *                            $Revision: 1.6 $\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n@@ -1640,327 +1640,6 @@ __gnat_initialize ()\n #endif\n }\n \n-/***************************************/\n-/* __gnat_initialize (default version) */\n-/***************************************/\n-\n-/* Get the stack unwinding mechanism when available and when compiling\n-   a-init.c for the run time. Except in the case of a restricted run-time,\n-   such as RT-Linux modules (__RT__ is defined). */\n-\n-#elif defined (IN_RTS) && !defined (__RT__)\n-\n-/* If we have a definition of INCOMING_RETURN_ADDR_RTX, assume that\n-   the rest of the DWARF 2 frame unwind support is also provided.  */\n-#if !defined (DWARF2_UNWIND_INFO) && defined (INCOMING_RETURN_ADDR_RTX)\n-#define DWARF2_UNWIND_INFO 1\n-#endif\n-\n-#ifdef DWARF2_UNWIND_INFO\n-#include \"frame.h\"\n-\n-struct machine_state\n-{\n-  frame_state f1, f2, f3;\n-  frame_state *udata, *udata_start, *sub_udata;\n-  void *pc, *pc_start, *new_pc;\n-};\n-\n-typedef int word_type __attribute__ ((mode (__word__)));\n-\n-/* This type is used in get_reg and put_reg to deal with ABIs where a void*\n-   is smaller than a word, such as the Irix 6 n32 ABI.  We cast twice to\n-   avoid a warning about casting between int and pointer of different\n-   sizes.  */\n-\n-typedef int ptr_type __attribute__ ((mode (pointer)));\n-\n-static void get_reg\t\t\tPARAMS ((unsigned int, frame_state *,\n-\t\t\t\t\t\t frame_state *));\n-static void put_reg\t\t\tPARAMS ((unsigned int, void *,\n-\t\t\t\t\t\t frame_state *));\n-static void copy_reg\t\t\tPARAMS ((unsigned int, frame_state *,\n-\t\t\t\t\t\t frame_state *));\n-static inline void put_return_addr\tPARAMS ((void *, frame_state *));\n-static inline void *get_return_addr\tPARAMS ((frame_state *,\n-\t\t\t\t\t\t frame_state *));\n-static frame_state *__frame_state_for_r\tPARAMS ((void *, frame_state *));\n-\n-#ifdef INCOMING_REGNO\n-static int in_reg_window\t\tPARAMS ((unsigned int, frame_state *));\n-#endif\n-\n-extern void __gnat_pop_frame\t\tPARAMS ((struct machine_state *));\n-extern void __gnat_set_machine_state\tPARAMS ((struct machine_state *));\n-extern void __gnat_enter_handler\tPARAMS ((struct machine_state *,\n-\t\t\t\t\t\t void *));\n-extern __SIZE_TYPE__ __gnat_machine_state_length PARAMS ((void));\n-extern void *__gnat_get_code_loc\tPARAMS ((struct machine_state *));\n-\n-/* Get the value of register REG as saved in UDATA, where SUB_UDATA is a\n-   frame called by UDATA or 0.  */\n-\n-static void *\n-get_reg (reg, udata, sub_udata)\n-     unsigned int reg;\n-     frame_state *udata, *sub_udata;\n-{\n-  if (udata->saved[reg] == REG_SAVED_OFFSET)\n-    return\n-      (void *) (ptr_type) *(word_type *) (udata->cfa\n-\t\t\t\t\t  + udata->reg_or_offset[reg]);\n-  else if (udata->saved[reg] == REG_SAVED_REG && sub_udata)\n-    return get_reg (udata->reg_or_offset[reg], sub_udata, 0);\n-  else\n-    abort ();\n-}\n-\n-/* Overwrite the saved value for register REG in frame UDATA with VAL.  */\n-\n-static void\n-put_reg (reg, val, udata)\n-     unsigned int reg;\n-     void *val;\n-     frame_state *udate;\n-{\n-  if (udata->saved[reg] == REG_SAVED_OFFSET)\n-    *(word_type *) (udata->cfa + udata->reg_or_offset[reg])\n-      = (word_type) (ptr_type) val;\n-  else\n-    abort ();\n-}\n-\n-/* Copy the saved value for register REG from frame UDATA to frame\n-   TARGET_UDATA.  Unlike the previous two functions, this can handle\n-   registers that are not one word large.  */\n-\n-static void\n-copy_reg (reg, udata, target_udata)\n-     unsigned int reg;\n-     frame_state *udate, *target_udata;\n-{\n-  if (udata->saved[reg] == REG_SAVED_OFFSET\n-      && target_udata->saved[reg] == REG_SAVED_OFFSET)\n-    memcpy (target_udata->cfa + target_udata->reg_or_offset[reg],\n-            udata->cfa + udata->reg_or_offset[reg],\n-            __builtin_dwarf_reg_size (reg));\n-  else\n-    abort ();\n-}\n-\n-/* Overwrite the return address for frame UDATA with VAL.  */\n-\n-static inline void\n-put_return_addr (val, udata)\n-     void *val;\n-     frame_state *udata;\n-{\n-  val = __builtin_frob_return_addr (val);\n-  put_reg (udata->retaddr_column, val, udata);\n-}\n-\n-#ifdef INCOMING_REGNO\n-\n-/* Is the saved value for register REG in frame UDATA stored in a register\n-   window in the previous frame?  */\n-\n-static int\n-in_reg_window (reg, udata)\n-     unsigned int reg;\n-     frame_state *udata;\n-{\n-  if (udata->saved[reg] != REG_SAVED_OFFSET)\n-    return 0;\n-\n-#ifdef STACK_GROWS_DOWNWARD\n-  return udata->reg_or_offset[reg] > 0;\n-#else\n-  return udata->reg_or_offset[reg] < 0;\n-#endif\n-}\n-#endif /* INCOMING_REGNO */\n-\n-/* Retrieve the return address for frame UDATA, where SUB_UDATA is a\n-   frame called by UDATA or 0.  */\n-\n-static inline void *\n-get_return_addr (udata, sub_udata)\n-     frame_state *udate, *sub_udata;\n-{\n-  return __builtin_extract_return_addr (get_reg (udata->retaddr_column,\n-\t\t\t\t\t\t udata, sub_udata));\n-}\n-\n-/* Thread-safe version of __frame_state_for */\n-\n-static frame_state *\n-__frame_state_for_r (void *pc_target, frame_state *state_in)\n-     void *pc_target;\n-     frame_state *state_in;\n-{\n-  frame_state *f;\n-\n-  (*Lock_Task) ();\n-  f = __frame_state_for (pc_target, state_in);\n-  (*Unlock_Task) ();\n-  return f;\n-}\n-\n-/* Given the current frame UDATA and its return address PC, return the\n-   information about the calling frame in CALLER_UDATA.  */\n-\n-void\n-__gnat_pop_frame (m)\n-     struct machine_state *m;\n-{\n-  frame_state *p;\n-\n-  int i;\n-\n-  m->pc = m->new_pc;\n-  p = m->udata;\n-  if (! __frame_state_for_r (m->pc, m->sub_udata))\n-    {\n-      m->new_pc = 0;\n-      return;\n-    }\n-\n-  /* Now go back to our caller's stack frame.  If our caller's CFA register\n-     was saved in our stack frame, restore it; otherwise, assume the CFA\n-     register is SP and restore it to our CFA value.  */\n-  if (m->udata->saved[m->sub_udata->cfa_reg])\n-    m->sub_udata->cfa = get_reg (m->sub_udata->cfa_reg, m->udata, 0);\n-  else\n-    m->sub_udata->cfa = m->udata->cfa;\n-  m->sub_udata->cfa += m->sub_udata->cfa_offset;\n-\n-  m->udata = m->sub_udata;\n-  m->sub_udata = p;\n-  m->new_pc = get_return_addr (m->udata, m->sub_udata) - 1;\n-\n-  return;\n-\n-/* ??? disable this code for now since it doesn't work properly */\n-#if 0\n-  if (m->pc == m->pc_start)\n-    return;\n-\n-  /* Copy the frame's saved register values into our register save slots.  */\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n-    if (i != m->udata->retaddr_column && m->udata->saved[i])\n-      {\n-#ifdef INCOMING_REGNO\n-        /* If you modify the saved value of the return address\n-           register on the SPARC, you modify the return address for\n-           your caller's frame.  Don't do that here, as it will\n-           confuse get_return_addr.  */\n-        if (in_reg_window (i, m->udata)\n-            && m->udata->saved[m->udata->retaddr_column] == REG_SAVED_REG\n-            && m->udata->reg_or_offset[m->udata->retaddr_column] == i)\n-          continue;\n-#endif\n-        copy_reg (i, m->udata, m->udata_start);\n-      }\n-#endif\n-}\n-\n-void\n-__gnat_set_machine_state (machine_state)\n-     struct machine_state *machine_state;\n-{\n-  frame_state sub_udata;\n-\n-  /* Start at our stack frame.  */\n-label:\n-  machine_state->udata = &machine_state->f1;\n-  machine_state->sub_udata = &machine_state->f2;\n-  machine_state->udata_start = &machine_state->f3;\n-\n-  if (! __frame_state_for_r (&&label, machine_state->udata))\n-    return;\n-\n-  /* We need to get the value from the CFA register.  At this point in\n-     compiling libgnat.a we don't know whether or not we will use the frame\n-     pointer register for the CFA, so we check our unwind info.  */\n-  if (machine_state->udata->cfa_reg == __builtin_dwarf_fp_regnum ())\n-    machine_state->udata->cfa = __builtin_fp ();\n-  else\n-    machine_state->udata->cfa = __builtin_sp ();\n-  machine_state->udata->cfa += machine_state->udata->cfa_offset;\n-\n-  memcpy (machine_state->udata_start, machine_state->udata,\n-    sizeof (frame_state));\n-  machine_state->new_pc =\n-  machine_state->pc_start =\n-  machine_state->pc = &&label;\n-\n-  /* Do any necessary initialization to access arbitrary stack frames.\n-     On the SPARC, this means flushing the register windows.  */\n-  __builtin_unwind_init ();\n-\n-  /* go up one frame */\n-  __gnat_pop_frame (machine_state);\n-}\n-\n-void\n-__gnat_enter_handler (m, handler)\n-     struct machine_state *m;\n-     void *handler;\n-{\n-  void *retaddr;\n-\n-#ifdef INCOMING_REGNO\n-      /* we need to update the saved return address register from\n-         the last frame we unwind, or the handler frame will have the wrong\n-         return address.  */\n-      if (m->udata->saved[m->udata->retaddr_column] == REG_SAVED_REG)\n-        {\n-          int i = m->udata->reg_or_offset[m->udata->retaddr_column];\n-          if (in_reg_window (i, m->udata))\n-            copy_reg (i, m->udata, m->udata_start);\n-        }\n-#endif\n-\n-  /* Emit the stub to adjust sp and jump to the handler.  */\n-  retaddr = __builtin_eh_stub ();\n-\n-  /* And then set our return address to point to the stub.  */\n-  if (m->udata_start->saved[m->udata_start->retaddr_column] ==\n-      REG_SAVED_OFFSET)\n-    put_return_addr (retaddr, m->udata_start);\n-  else\n-    __builtin_set_return_addr_reg (retaddr);\n-\n-  /* Set up the registers we use to communicate with the stub.\n-     We check STACK_GROWS_DOWNWARD so the stub can use adjust_stack.  */\n-  __builtin_set_eh_regs\n-    (handler,\n-#ifdef STACK_GROWS_DOWNWARD\n-     m->udata->cfa - m->udata_start->cfa\n-#else\n-     m->udata_start->cfa - m->udata->cfa\n-#endif\n-     + m->udata->args_size);\n-\n-  /* Epilogue:  restore the handler frame's register values and return\n-     to the stub.  */\n-}\n-\n-__SIZE_TYPE__\n-__gnat_machine_state_length ()\n-{\n-  return sizeof (struct machine_state);\n-}\n-\n-void *\n-__gnat_get_code_loc (m)\n-     struct machine_state *m;\n-{\n-  return m->pc;\n-}\n-#endif /* DWARF2_UNWIND_INFO */\n-\n #else\n \n /* For all other versions of GNAT, the initialize routine and handler"}]}