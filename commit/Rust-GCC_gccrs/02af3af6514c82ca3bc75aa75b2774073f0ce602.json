{"sha": "02af3af6514c82ca3bc75aa75b2774073f0ce602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJhZjNhZjY1MTRjODJjYTNiYzc1YWE3NWIyNzc0MDczZjBjZTYwMg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@wrs.com", "date": "1999-08-19T21:39:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-19T21:39:04Z"}, "message": "c-common.c (c_get_alias_set): Fix support for poitners and references.\n\n\t* c-common.c (c_get_alias_set): Fix support for poitners and\n\treferences.\n\nCo-Authored-By: Mark Mitchell <mark@codesourcery.com>\n\nFrom-SVN: r28768", "tree": {"sha": "25c740c2a068a0f2acc3146f3aad5ba91086744b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25c740c2a068a0f2acc3146f3aad5ba91086744b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02af3af6514c82ca3bc75aa75b2774073f0ce602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02af3af6514c82ca3bc75aa75b2774073f0ce602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02af3af6514c82ca3bc75aa75b2774073f0ce602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02af3af6514c82ca3bc75aa75b2774073f0ce602/comments", "author": null, "committer": null, "parents": [{"sha": "2aaf816dad783f6cfccae11e356a5213a2455adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aaf816dad783f6cfccae11e356a5213a2455adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aaf816dad783f6cfccae11e356a5213a2455adf"}], "stats": {"total": 42, "additions": 39, "deletions": 3}, "files": [{"sha": "8f83f30f17fcbd2640b8bbdb854d18e73a6c0c9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02af3af6514c82ca3bc75aa75b2774073f0ce602/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02af3af6514c82ca3bc75aa75b2774073f0ce602/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02af3af6514c82ca3bc75aa75b2774073f0ce602", "patch": "@@ -1,3 +1,9 @@\n+Thu Aug 19 14:42:38 1999  Mike Stump <mrs@wrs.com>\n+\t                  Mark Mitchell <mark@codesourcery.com>\n+\n+\t* c-common.c (c_get_alias_set): Fix support for poitners and\n+\treferences.\n+\n Thu Aug 19 11:51:22 EDT 1999  John Wehle  (john@feith.com)\n \n \t* alias.c: Include tree.h."}, {"sha": "d194be625e46719d2ac0c48e017a4199e77fc852", "filename": "gcc/c-common.c", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02af3af6514c82ca3bc75aa75b2774073f0ce602/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02af3af6514c82ca3bc75aa75b2774073f0ce602/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=02af3af6514c82ca3bc75aa75b2774073f0ce602", "patch": "@@ -3401,11 +3401,41 @@ c_get_alias_set (t)\n        whose type is the same as one of the fields, recursively, but\n        we don't yet make any use of that information.)  */\n     TYPE_ALIAS_SET (type) = 0;\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   || TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      tree t;\n+\n+      /* Unfortunately, there is no canonical form of a pointer type.\n+\t In particular, if we have `typedef int I', then `int *', and\n+\t `I *' are different types.  So, we have to pick a canonical\n+\t representative.  We do this below.\n+\t \n+\t Note that this approach is actually more conservative that it\n+\t needs to be.  In particular, `const int *' and `int *' should\n+\t be in different alias sets, but this approach puts them in\n+\t the same alias set.  */\n+\n+      t = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+      t = ((TREE_CODE (type) == POINTER_TYPE)\n+\t   ? build_pointer_type (t) : build_reference_type (t));\n+      if (t != type)\n+\tTYPE_ALIAS_SET (type) = c_get_alias_set (t);\n+    }\n \n   if (!TYPE_ALIAS_SET_KNOWN_P (type)) \n-    /* TYPE is something we haven't seen before.  Put it in a new\n-       alias set.  */\n-    TYPE_ALIAS_SET (type) = new_alias_set ();\n+    {\n+      /* Types that are not allocated on the permanent obstack are not\n+\t placed in the type hash table.  Thus, there can be multiple\n+\t copies of identical types in local scopes.  In the long run,\n+\t all types should be permanent.  */\n+      if (! TREE_PERMANENT (type))\n+\tTYPE_ALIAS_SET (type) = 0;\n+      else\n+\t/* TYPE is something we haven't seen before.  Put it in a new\n+\t   alias set.  */\n+\tTYPE_ALIAS_SET (type) = new_alias_set ();\n+    }\n \n   return TYPE_ALIAS_SET (type);\n }"}]}