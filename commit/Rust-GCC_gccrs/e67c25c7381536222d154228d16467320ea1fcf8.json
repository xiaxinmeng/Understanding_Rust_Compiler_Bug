{"sha": "e67c25c7381536222d154228d16467320ea1fcf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY3YzI1YzczODE1MzYyMjJkMTU0MjI4ZDE2NDY3MzIwZWExZmNmOA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2006-03-21T05:07:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2006-03-21T05:07:37Z"}, "message": "tree-pass.h (pass_phi_only_copy_prop): Delete.\n\n\n\t* tree-pass.h (pass_phi_only_copy_prop): Delete.\n\t(pass_phi_only_cprop): Declare.\n\t* passes.c (init_optimization_passes): Replace pass_phi_only_copy_prop\n\twith phi_only_cprop\n\t* tree-ssa-dom.c (degenerate_phi_result): New function.\n\t(remove_stmt_or_phi, get_lhs_or_phi_result): Likewise.\n\t(get_rhs_or_phi_arg, propagate_rhs_into_lhs): Likewise.\n\t(eliminate_const_or_copy, eliminate_degenerate_phis_1): Likewise.\n\t(eliminate_degenerate_phis): Likewise.\n\t(pass_phi_only_cprop): New pass descriptor.\n\t* tree-ssa-copy.c (init_copy_prop): Lose PHIS_ONLY argument and\n\tsupport code.  Callers updated.\n\t(execute_copy_prop, do_copy_prop): Likewise and corresponding changes.\n\t(store_copy_prop): Likewise.\n\t(do_phi_only_copy_prop, pass_phi_only_copy_prop): Remove.\n\n\t* gcc.dg/tree-ssa/pr21829.c: New test.\n\nFrom-SVN: r112242", "tree": {"sha": "199bbfcaab0678283b684b3453409019e876c0b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/199bbfcaab0678283b684b3453409019e876c0b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e67c25c7381536222d154228d16467320ea1fcf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67c25c7381536222d154228d16467320ea1fcf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e67c25c7381536222d154228d16467320ea1fcf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67c25c7381536222d154228d16467320ea1fcf8/comments", "author": null, "committer": null, "parents": [{"sha": "4a282de4b36221c7168bf10ad0dc8836b374cfb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a282de4b36221c7168bf10ad0dc8836b374cfb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a282de4b36221c7168bf10ad0dc8836b374cfb8"}], "stats": {"total": 540, "additions": 488, "deletions": 52}, "files": [{"sha": "20c32c30cc9a91bfec1c7f8dd7002c6683ce9440", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e67c25c7381536222d154228d16467320ea1fcf8", "patch": "@@ -1,3 +1,21 @@\n+2006-03-20  Jeff Law  <law@redhat.com>\n+\n+\t* tree-pass.h (pass_phi_only_copy_prop): Delete.\n+\t(pass_phi_only_cprop): Declare.\n+\t* passes.c (init_optimization_passes): Replace pass_phi_only_copy_prop\n+\twith phi_only_cprop\n+\t* tree-ssa-dom.c (degenerate_phi_result): New function.\n+\t(remove_stmt_or_phi, get_lhs_or_phi_result): Likewise.\n+\t(get_rhs_or_phi_arg, propagate_rhs_into_lhs): Likewise.\n+\t(eliminate_const_or_copy, eliminate_degenerate_phis_1): Likewise.\n+\t(eliminate_degenerate_phis): Likewise.\n+\t(pass_phi_only_cprop): New pass descriptor.\n+\t* tree-ssa-copy.c (init_copy_prop): Lose PHIS_ONLY argument and\n+\tsupport code.  Callers updated.\n+\t(execute_copy_prop, do_copy_prop): Likewise and corresponding changes.\n+\t(store_copy_prop): Likewise.\n+\t(do_phi_only_copy_prop, pass_phi_only_copy_prop): Remove.\n+\n 2006-03-20  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/21764"}, {"sha": "ab37f20798fd089256465a846cbc835acf195f89", "filename": "gcc/passes.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=e67c25c7381536222d154228d16467320ea1fcf8", "patch": "@@ -505,11 +505,12 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_dce);\n   NEXT_PASS (pass_dominator);\n \n-  /* The only copy propagation opportunities left after DOM\n-     should be due to degenerate PHI nodes.  So rather than\n-     run the full copy propagator, just discover and copy\n-     propagate away the degenerate PHI nodes.  */\n-  NEXT_PASS (pass_phi_only_copy_prop);\n+  /* The only const/copy propagation opportunities left after\n+     DOM should be due to degenerate PHI nodes.  So rather than\n+     run the full propagators, run a specialized pass which\n+     only examines PHIs to discover const/copy propagation\n+     opportunities.  */\n+  NEXT_PASS (pass_phi_only_cprop);\n \n   NEXT_PASS (pass_phiopt);\n   NEXT_PASS (pass_may_alias);\n@@ -526,11 +527,12 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_rename_ssa_copies);\n   NEXT_PASS (pass_dominator);\n \n-  /* The only copy propagation opportunities left after DOM\n-     should be due to degenerate PHI nodes.  So rather than\n-     run the full copy propagator, just discover and copy\n-     propagate away the degenerate PHI nodes.  */\n-  NEXT_PASS (pass_phi_only_copy_prop);\n+  /* The only const/copy propagation opportunities left after\n+     DOM should be due to degenerate PHI nodes.  So rather than\n+     run the full propagators, run a specialized pass which\n+     only examines PHIs to discover const/copy propagation\n+     opportunities.  */\n+  NEXT_PASS (pass_phi_only_cprop);\n \n   NEXT_PASS (pass_reassoc);\n   NEXT_PASS (pass_dce);\n@@ -556,11 +558,12 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_vrp);\n   NEXT_PASS (pass_dominator);\n \n-  /* The only copy propagation opportunities left after DOM\n-     should be due to degenerate PHI nodes.  So rather than\n-     run the full copy propagator, just discover and copy\n-     propagate away the degenerate PHI nodes.  */\n-  NEXT_PASS (pass_phi_only_copy_prop);\n+  /* The only const/copy propagation opportunities left after\n+     DOM should be due to degenerate PHI nodes.  So rather than\n+     run the full propagators, run a specialized pass which\n+     only examines PHIs to discover const/copy propagation\n+     opportunities.  */\n+  NEXT_PASS (pass_phi_only_cprop);\n \n   NEXT_PASS (pass_cd_dce);\n "}, {"sha": "8b5095299b4279ad7d52faf11d4a3c384bcfae2d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e67c25c7381536222d154228d16467320ea1fcf8", "patch": "@@ -1,5 +1,7 @@\n 2006-03-20  Jeff Law  <law@redhat.com>\n \n+\t* gcc.dg/tree-ssa/pr21829.c: New test.\n+\n \t* gcc.dg/tree-ssa/20030807-2.c: Make sure to run VRP.\n \n 2006-03-20  Richard Sandiford  <richard@codesourcery.com>"}, {"sha": "4c723f3ff86999af377940aaf5b0d0d35838ab6f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21829.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21829.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21829.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21829.c?ref=e67c25c7381536222d154228d16467320ea1fcf8", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-phicprop-details\" } */\n+\n+int test(int v)\n+{\n+  int x = 0;\n+  int u;\n+  for (u=0;u<2;u++)\n+  {\n+    if (u>v)\n+    {\n+      if (u%2==1)\n+        x++;\n+    }\n+  }  \n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Original statement:.*% 2\\[ \\t\\n]*Updated statement.*=1\" 0 \"phicprop3\" } } */\n+/* { dg-final { cleanup-tree-dump \"phicprop3\" } } */\n+"}, {"sha": "6a457cabf63cd6e181bcb3219bbf317f26eb832a", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=e67c25c7381536222d154228d16467320ea1fcf8", "patch": "@@ -257,6 +257,7 @@ extern struct tree_opt_pass pass_iv_optimize;\n extern struct tree_opt_pass pass_tree_loop_done;\n extern struct tree_opt_pass pass_ch;\n extern struct tree_opt_pass pass_ccp;\n+extern struct tree_opt_pass pass_phi_only_cprop;\n extern struct tree_opt_pass pass_build_ssa;\n extern struct tree_opt_pass pass_del_ssa;\n extern struct tree_opt_pass pass_dominator;\n@@ -295,7 +296,6 @@ extern struct tree_opt_pass pass_sink_code;\n extern struct tree_opt_pass pass_fre;\n extern struct tree_opt_pass pass_linear_transform;\n extern struct tree_opt_pass pass_copy_prop;\n-extern struct tree_opt_pass pass_phi_only_copy_prop;\n extern struct tree_opt_pass pass_store_ccp;\n extern struct tree_opt_pass pass_store_copy_prop;\n extern struct tree_opt_pass pass_vrp;"}, {"sha": "ea8a39e6ab8392ba91f97fd781e2dd640c3ebad5", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=e67c25c7381536222d154228d16467320ea1fcf8", "patch": "@@ -843,7 +843,7 @@ copy_prop_visit_phi_node (tree phi)\n    opportunities.  */\n \n static void\n-init_copy_prop (bool phis_only)\n+init_copy_prop (void)\n {\n   basic_block bb;\n \n@@ -868,7 +868,7 @@ init_copy_prop (bool phis_only)\n \t     lists of the propagator.  */\n \t  if (stmt_ends_bb_p (stmt))\n \t    DONT_SIMULATE_AGAIN (stmt) = false;\n-\t  else if (!phis_only && stmt_may_generate_copy (stmt))\n+\t  else if (stmt_may_generate_copy (stmt))\n \t    DONT_SIMULATE_AGAIN (stmt) = false;\n \t  else\n \t    {\n@@ -1027,10 +1027,10 @@ fini_copy_prop (void)\n    x_53 and x_54 are both copies of x_898.  */\n \n static void\n-execute_copy_prop (bool store_copy_prop, bool phis_only)\n+execute_copy_prop (bool store_copy_prop)\n {\n   do_store_copy_prop = store_copy_prop;\n-  init_copy_prop (phis_only);\n+  init_copy_prop ();\n   ssa_propagate (copy_prop_visit_stmt, copy_prop_visit_phi_node);\n   fini_copy_prop ();\n }\n@@ -1045,7 +1045,7 @@ gate_copy_prop (void)\n static unsigned int\n do_copy_prop (void)\n {\n-  execute_copy_prop (false, false);\n+  execute_copy_prop (false);\n   return 0;\n }\n \n@@ -1070,36 +1070,6 @@ struct tree_opt_pass pass_copy_prop =\n   0\t\t\t\t\t/* letter */\n };\n \n-\n-static unsigned int\n-do_phi_only_copy_prop (void)\n-{\n-  execute_copy_prop (false, true);\n-  return 0;\n-}\n-\n-struct tree_opt_pass pass_phi_only_copy_prop =\n-{\n-  \"phionlycopyprop\",\t\t\t/* name */\n-  gate_copy_prop,\t\t\t/* gate */\n-  do_phi_only_copy_prop,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_COPY_PROP,\t\t\t/* tv_id */\n-  PROP_ssa | PROP_alias | PROP_cfg,\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_cleanup_cfg\n-    | TODO_dump_func\n-    | TODO_ggc_collect\n-    | TODO_verify_ssa\n-    | TODO_update_ssa,\t\t\t/* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */\n-};\n-\n-\n static bool\n gate_store_copy_prop (void)\n {\n@@ -1114,7 +1084,7 @@ static unsigned int\n store_copy_prop (void)\n {\n   /* If STORE-COPY-PROP is not enabled, we just run regular COPY-PROP.  */\n-  execute_copy_prop (flag_tree_store_copy_prop != 0, false);\n+  execute_copy_prop (flag_tree_store_copy_prop != 0);\n   return 0;\n }\n "}, {"sha": "daa2f0ea81db4e7f58f1346c4e2758d40138a45e", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67c25c7381536222d154228d16467320ea1fcf8/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=e67c25c7381536222d154228d16467320ea1fcf8", "patch": "@@ -2020,3 +2020,425 @@ avail_expr_eq (const void *p1, const void *p2)\n \n   return false;\n }\n+\n+/* PHI-ONLY copy and constant propagation.  This pass is meant to clean\n+   up degenerate PHIs created by or exposed by jump threading.  */\n+\n+/* Given PHI, return its RHS if the PHI is a degenerate, otherwise return\n+   NULL.  */\n+\n+static tree\n+degenerate_phi_result (tree phi)\n+{\n+  tree lhs = PHI_RESULT (phi);\n+  tree val = NULL;\n+  int i;\n+\n+  /* Ignoring arguments which are the same as LHS, if all the remaining\n+     arguments are the same, then the PHI is a degenerate and has the\n+     value of that common argument.  */\n+  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+    {\n+      tree arg = PHI_ARG_DEF (phi, i);\n+\n+      if (arg == lhs)\n+\tcontinue;\n+      else if (!val)\n+\tval = arg;\n+      else if (!operand_equal_p (arg, val, 0))\n+\tbreak;\n+    }\n+  return (i == PHI_NUM_ARGS (phi) ? val : NULL);\n+}\n+\n+/* Given a tree node T, which is either a PHI_NODE or MODIFY_EXPR,\n+   remove it from the IL.  */\n+\n+static void\n+remove_stmt_or_phi (tree t)\n+{\n+  if (TREE_CODE (t) == PHI_NODE)\n+    remove_phi_node (t, NULL);\n+  else\n+    {\n+      block_stmt_iterator bsi = bsi_for_stmt (t);\n+      bsi_remove (&bsi, true);\n+    }\n+}\n+\n+/* Given a tree node T, which is either a PHI_NODE or MODIFY_EXPR,\n+   return the \"rhs\" of the node, in the case of a non-degenerate\n+   PHI, NULL is returned.  */\n+\n+static tree\n+get_rhs_or_phi_arg (tree t)\n+{\n+  if (TREE_CODE (t) == PHI_NODE)\n+    return degenerate_phi_result (t);\n+  else if (TREE_CODE (t) == MODIFY_EXPR)\n+    return TREE_OPERAND (t, 1);\n+  gcc_unreachable ();\n+}\n+\n+\n+/* Given a tree node T, which is either a PHI_NODE or a MODIFY_EXPR,\n+   return the \"lhs\" of the node.  */\n+\n+static tree\n+get_lhs_or_phi_result (tree t)\n+{\n+  if (TREE_CODE (t) == PHI_NODE)\n+    return PHI_RESULT (t);\n+  else if (TREE_CODE (t) == MODIFY_EXPR)\n+    return TREE_OPERAND (t, 0);\n+  gcc_unreachable ();\n+}\n+\n+/* Propagate RHS into all uses of LHS (when possible).\n+\n+   RHS and LHS are derived from STMT, which is passed in solely so\n+   that we can remove it if propagation is successful.\n+\n+   When propagating into a PHI node or into a statement which turns\n+   into a trivial copy or constant initialization, set the\n+   appropriate bit in INTERESTING_NAMEs so that we will visit those\n+   nodes as well in an effort to pick up secondary optimization\n+   opportunities.  */\n+\n+static void \n+propagate_rhs_into_lhs (tree stmt, tree lhs, tree rhs, bitmap interesting_names)\n+{\n+  /* First verify that propagation is valid and isn't going to move a\n+     loop variant variable outside its loop.  */\n+  if (! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs)\n+      && (TREE_CODE (rhs) != SSA_NAME\n+\t  || ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs))\n+      && may_propagate_copy (lhs, rhs)\n+      && loop_depth_of_name (lhs) >= loop_depth_of_name (rhs))\n+    {\n+      use_operand_p use_p;\n+      imm_use_iterator iter;\n+      bool all = true;\n+\n+      /* Dump details.  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"  Replacing '\");\n+\t  print_generic_expr (dump_file, lhs, dump_flags);\n+\t  fprintf (dump_file, \"' with %s '\",\n+\t           (TREE_CODE (rhs) != SSA_NAME ? \"constant\" : \"variable\"));\n+\t\t   print_generic_expr (dump_file, rhs, dump_flags);\n+\t  fprintf (dump_file, \"'\\n\");\n+\t}\n+\n+      /* Walk over every use of LHS and try to replace the use with RHS. \n+\t At this point the only reason why such a propagation would not\n+\t be successful would be if the use occurs in an ASM_EXPR.  */\n+      FOR_EACH_IMM_USE_SAFE (use_p, iter, lhs)\n+\t{\n+\t  tree use_stmt = USE_STMT (use_p);\n+\t\n+\t  /* It's not always safe to propagate into an ASM_EXPR.  */\n+\t  if (TREE_CODE (use_stmt) == ASM_EXPR\n+\t      && ! may_propagate_copy_into_asm (lhs))\n+\t    {\n+\t      all = false;\n+\t      continue;\n+\t    }\n+\n+\t  /* Dump details.  */\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"    Original statement:\");\n+\t      print_generic_expr (dump_file, use_stmt, dump_flags);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  /* Propagate, fold and update the statement.  Note this may\n+\t     expose new const/copy propagation opportunities as well\n+\t     collapse control statements.  */\n+\t  propagate_value (use_p, rhs);\n+\t  fold_stmt_inplace (use_stmt);\n+\t  update_stmt (use_stmt);\n+\n+\t  /* Dump details.  */\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"    Updated statement:\");\n+\t      print_generic_expr (dump_file, use_stmt, dump_flags);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  /* Sometimes propagation can expose new operands to the\n+\t     renamer.  */\n+\t  mark_new_vars_to_rename (use_stmt);\n+\n+\t  /* If we replaced a variable index with a constant, then\n+\t     we would need to update the invariant flag for ADDR_EXPRs.  */\n+\t  if (TREE_CODE (use_stmt) == MODIFY_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (use_stmt, 1)) == ADDR_EXPR)\n+\t    recompute_tree_invariant_for_addr_expr (TREE_OPERAND (use_stmt, 1));\n+\n+\t  /* If we cleaned up EH information from the statement,\n+             remove EH edges.  I'm not sure if this happens in \n+\t     practice with this code, but better safe than sorry.  */\n+\t  if (maybe_clean_or_replace_eh_stmt (use_stmt, use_stmt))\n+\t    tree_purge_dead_eh_edges (bb_for_stmt (use_stmt));\n+\n+\t  /* Propagation may expose new degenerate PHIs or\n+\t     trivial copy/constant propagation opportunities.  */\n+\t  if (TREE_CODE (use_stmt) == PHI_NODE\n+\t      || (TREE_CODE (use_stmt) == MODIFY_EXPR\n+\t\t  && TREE_CODE (TREE_OPERAND (use_stmt, 0)) == SSA_NAME\n+\t\t  && (TREE_CODE (TREE_OPERAND (use_stmt, 1)) == SSA_NAME\n+\t\t      || is_gimple_min_invariant (TREE_OPERAND (use_stmt, 1)))))\n+\t    {\n+\t      tree result = get_lhs_or_phi_result (use_stmt);\n+\t      bitmap_set_bit (interesting_names, SSA_NAME_VERSION (result));\n+\t    }\n+\n+\t  /* Propagation into these nodes may make certain edges in\n+\t     the CFG unexecutable.  We want to identify them as PHI nodes\n+\t     at the destination of those unexecutable edges may become\n+\t     degenerates.  */\n+\t  else if (TREE_CODE (use_stmt) == COND_EXPR\n+\t\t   || TREE_CODE (use_stmt) == SWITCH_EXPR\n+\t\t   || TREE_CODE (use_stmt) == GOTO_EXPR)\n+\t    {\n+\t      tree val;\n+\n+\t      if (TREE_CODE (use_stmt) == COND_EXPR)\n+\t\tval = COND_EXPR_COND (use_stmt);\n+\t      else if (TREE_CODE (use_stmt) == SWITCH_EXPR)\n+\t\tval = SWITCH_COND (use_stmt);\n+\t      else\n+\t\tval = GOTO_DESTINATION  (use_stmt);\n+\n+\t      if (is_gimple_min_invariant (val))\n+\t\t{\n+\t\t  basic_block bb = bb_for_stmt (use_stmt);\n+\t\t  edge te = find_taken_edge (bb, val);\n+\t\t  edge_iterator ei;\n+\t\t  edge e;\n+\t\t  block_stmt_iterator bsi;\n+\n+\t\t  /* Remove all outgoing edges except TE.  */\n+\t\t  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei));)\n+\t\t    {\n+\t\t      if (e != te)\n+\t\t\t{\n+\t\t\t  tree phi;\n+\n+\t\t\t  /* Mark all the PHI nodes at the destination of\n+\t\t\t     the unexecutable edge as interesting.  */\n+\t\t\t  for (phi = phi_nodes (e->dest);\n+\t\t\t       phi;\n+\t\t\t       phi = PHI_CHAIN (phi))\n+\t\t\t    {\n+\t\t\t      tree result = PHI_RESULT (phi);\n+\t\t\t      int version = SSA_NAME_VERSION (result);\n+\n+\t\t\t      bitmap_set_bit (interesting_names, version);\n+\t\t\t    }\n+\n+\t\t\t  te->probability += e->probability;\n+\n+\t\t\t  te->count += e->count;\n+\t\t\t  remove_edge (e);\n+\t\t\t  cfg_altered = 1;\n+\t\t\t}\n+\t\t      else\n+\t\t\tei_next (&ei);\n+\t\t    }\n+\n+\t\t  bsi = bsi_last (bb_for_stmt (use_stmt));\n+\t\t  bsi_remove (&bsi, true);\n+\n+\t\t  /* And fixup the flags on the single remaining edge.  */\n+\t\t  te->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+\t\t  te->flags &= ~EDGE_ABNORMAL;\n+\t\t  te->flags |= EDGE_FALLTHRU;\n+\t\t  if (te->probability > REG_BR_PROB_BASE)\n+\t\t    te->probability = REG_BR_PROB_BASE;\n+\t        }\n+\t    }\n+\t}\n+\n+      /* If we were able to propagate away all uses of LHS, then\n+\t we can remove STMT.  */\n+      if (all)\n+\tremove_stmt_or_phi (stmt);\n+    }\n+}\n+\n+/* T is either a PHI node (potentally a degenerate PHI node) or\n+   a statement that is a trivial copy or constant initialization.\n+\n+   Attempt to eliminate T by propagating its RHS into all uses of\n+   its LHS.  This may in turn set new bits in INTERESTING_NAMES\n+   for nodes we want to revisit later.\n+\n+   All exit paths should clear INTERESTING_NAMES for the result\n+   of T.  */\n+\n+static void\n+eliminate_const_or_copy (tree t, bitmap interesting_names)\n+{\n+  tree lhs = get_lhs_or_phi_result (t);\n+  tree rhs;\n+  int version = SSA_NAME_VERSION (lhs);\n+\n+  /* If the LHS of this statement or PHI has no uses, then we can\n+     just eliminate it.  This can occur if, for example, the PHI\n+     was created by block duplication due to threading and its only\n+     use was in the conditional at the end of the block which was\n+     deleted.  */\n+  if (has_zero_uses (lhs))\n+    {\n+      bitmap_clear_bit (interesting_names, version);\n+      remove_stmt_or_phi (t);\n+      return;\n+    }\n+\n+  /* Get the RHS of the assignment or PHI node if the PHI is a\n+     degenerate.  */\n+  rhs = get_rhs_or_phi_arg (t);\n+  if (!rhs)\n+    {\n+      bitmap_clear_bit (interesting_names, version);\n+      return;\n+    }\n+\n+  propagate_rhs_into_lhs (t, lhs, rhs, interesting_names);\n+\n+  /* Note that T may well have been deleted by now, so do\n+     not access it, instead use the saved version # to clear\n+     T's entry in the worklist.  */\n+  bitmap_clear_bit (interesting_names, version);\n+}\n+\n+/* The first phase in degenerate PHI elimination.\n+\n+   Eliminate the degenerate PHIs in BB, then recurse on the\n+   dominator children of BB.  */\n+\n+static void\n+eliminate_degenerate_phis_1 (basic_block bb, bitmap interesting_names)\n+{\n+  tree phi, next;\n+  basic_block son;\n+\n+  for (phi = phi_nodes (bb); phi; phi = next)\n+    {\n+      next = PHI_CHAIN (phi);\n+      eliminate_const_or_copy (phi, interesting_names);\n+    }\n+\n+  /* Recurse into the dominator children of BB.  */\n+  for (son = first_dom_son (CDI_DOMINATORS, bb);\n+       son;\n+       son = next_dom_son (CDI_DOMINATORS, son))\n+    eliminate_degenerate_phis_1 (son, interesting_names);\n+}\n+\n+\n+/* A very simple pass to eliminate degenerate PHI nodes from the\n+   IL.  This is meant to be fast enough to be able to be run several\n+   times in the optimization pipeline.\n+\n+   Certain optimizations, particularly those which duplicate blocks\n+   or remove edges from the CFG can create or expose PHIs which are\n+   trivial copies or constant initializations.\n+\n+   While we could pick up these optimizations in DOM or with the\n+   combination of copy-prop and CCP, those solutions are far too\n+   heavy-weight for our needs.\n+\n+   This implementation has two phases so that we can efficiently\n+   eliminate the first order degenerate PHIs and second order\n+   degenerate PHIs.\n+\n+   The first phase performs a dominator walk to identify and eliminate\n+   the vast majority of the degenerate PHIs.  When a degenerate PHI\n+   is identified and eliminated any affected statements or PHIs\n+   are put on a worklist.\n+\n+   The second phase eliminates degenerate PHIs and trivial copies\n+   or constant initializations using the worklist.  This is how we\n+   pick up the secondary optimization opportunities with minimal\n+   cost.  */\n+\n+static unsigned int\n+eliminate_degenerate_phis (void)\n+{\n+  bitmap interesting_names;\n+\n+  /* INTERESTING_NAMES is effectively our worklist, indexed by\n+     SSA_NAME_VERSION.\n+\n+     A set bit indicates that the statement or PHI node which\n+     defines the SSA_NAME should be (re)examined to determine if\n+     it has become a degenerate PHI or trival const/copy propagation\n+     opportunity. \n+\n+     Experiments have show we generally get better compilation\n+     time behavior with bitmaps rather than sbitmaps.  */\n+  interesting_names = BITMAP_ALLOC (NULL);\n+\n+  /* First phase.  Elimiante degenerate PHIs via a domiantor\n+     walk of the CFG.\n+\n+     Experiments have indicated that we generally get better\n+     compile-time behavior by visiting blocks in the first\n+     phase in dominator order.  Presumably this is because walking\n+     in dominator order leaves fewer PHIs for later examination\n+     by the worklist phase.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  eliminate_degenerate_phis_1 (ENTRY_BLOCK_PTR, interesting_names);\n+\n+  /* Second phase.  Eliminate second order degnerate PHIs as well\n+     as trivial copies or constant initializations identified by\n+     the first phase or this phase.  Basically we keep iterating\n+     until our set of INTERESTING_NAMEs is empty.   */\n+  while (!bitmap_empty_p (interesting_names))\n+    {\n+      unsigned int i;\n+      bitmap_iterator bi;\n+\n+      EXECUTE_IF_SET_IN_BITMAP (interesting_names, 0, i, bi)\n+\t{\n+\t  tree name = ssa_name (i);\n+\n+\t  /* Ignore SSA_NAMEs that have been released because\n+\t     their defining statement was deleted (unreachable).  */\n+\t  if (name)\n+\t    eliminate_const_or_copy (SSA_NAME_DEF_STMT (ssa_name (i)),\n+\t\t\t\t     interesting_names);\n+\t}\n+    }\n+\n+  BITMAP_FREE (interesting_names);\n+  if (cfg_altered)\n+    free_dominance_info (CDI_DOMINATORS);\n+  return 0;\n+}\n+\n+struct tree_opt_pass pass_phi_only_cprop =\n+{\n+  \"phicprop\",                           /* name */\n+  gate_dominator,                       /* gate */\n+  eliminate_degenerate_phis,            /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_TREE_CCP,                          /* tv_id */\n+  PROP_cfg | PROP_ssa | PROP_alias,     /* properties_required */\n+  0,                                    /* properties_provided */\n+  PROP_smt_usage,                       /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_cleanup_cfg | TODO_dump_func \n+    | TODO_ggc_collect | TODO_verify_ssa\n+    | TODO_verify_stmts | TODO_update_smt_usage\n+    | TODO_update_ssa, /* todo_flags_finish */\n+  0                                     /* letter */\n+};"}]}