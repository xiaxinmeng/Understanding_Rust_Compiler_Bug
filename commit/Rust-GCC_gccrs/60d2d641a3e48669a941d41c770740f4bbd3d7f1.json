{"sha": "60d2d641a3e48669a941d41c770740f4bbd3d7f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBkMmQ2NDFhM2U0ODY2OWE5NDFkNDFjNzcwNzQwZjRiYmQzZDdmMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-02-28T18:57:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-02-28T18:57:38Z"}, "message": "re PR c++/84609 (internal compiler error: in cp_parser_abort_tentative_parse, at cp/parser.c:28960 (cp_parser_member_declaration()))\n\n\tPR c++/84609\n\t* parser.c (cp_parser_attributes_opt): Formatting fix.\n\t(cp_parser_skip_balanced_tokens, cp_parser_skip_gnu_attributes_opt,\n\tcp_parser_skip_std_attribute_spec_seq, cp_parser_skip_attributes_opt):\n\tNew functions.\n\t(cp_parser_member_declaration): Use cp_parser_skip_attributes_opt\n\tinstead of tentative parse to peek over optional attribute tokens\n\tto check for CPP_COLON after them.\n\n\t* g++.dg/cpp0x/pr84609.C: New test.\n\nFrom-SVN: r258080", "tree": {"sha": "bf09f0cbb881e96c7f0ca3ab9fcb4aa987b2397d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf09f0cbb881e96c7f0ca3ab9fcb4aa987b2397d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60d2d641a3e48669a941d41c770740f4bbd3d7f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d2d641a3e48669a941d41c770740f4bbd3d7f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60d2d641a3e48669a941d41c770740f4bbd3d7f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d2d641a3e48669a941d41c770740f4bbd3d7f1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f6eee6bf4cc9c7b1a9f8f7af82b8fcccefac973a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6eee6bf4cc9c7b1a9f8f7af82b8fcccefac973a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6eee6bf4cc9c7b1a9f8f7af82b8fcccefac973a"}], "stats": {"total": 155, "additions": 142, "deletions": 13}, "files": [{"sha": "40d7f873abfb1000bd7bc3615f6affad559c55a8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d2d641a3e48669a941d41c770740f4bbd3d7f1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d2d641a3e48669a941d41c770740f4bbd3d7f1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=60d2d641a3e48669a941d41c770740f4bbd3d7f1", "patch": "@@ -1,5 +1,14 @@\n 2018-02-28  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/84609\n+\t* parser.c (cp_parser_attributes_opt): Formatting fix.\n+\t(cp_parser_skip_balanced_tokens, cp_parser_skip_gnu_attributes_opt,\n+\tcp_parser_skip_std_attribute_spec_seq, cp_parser_skip_attributes_opt):\n+\tNew functions.\n+\t(cp_parser_member_declaration): Use cp_parser_skip_attributes_opt\n+\tinstead of tentative parse to peek over optional attribute tokens\n+\tto check for CPP_COLON after them.\n+\n \tPR c++/83871\n \tPR c++/83503\n \t* pt.c (INCLUDE_STRING): Remove define."}, {"sha": "359460cd4d8d633c9cb84e17c23c72e6a6d7054f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 119, "deletions": 13, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d2d641a3e48669a941d41c770740f4bbd3d7f1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d2d641a3e48669a941d41c770740f4bbd3d7f1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=60d2d641a3e48669a941d41c770740f4bbd3d7f1", "patch": "@@ -2393,6 +2393,8 @@ static tree cp_parser_std_attribute_spec\n   (cp_parser *);\n static tree cp_parser_std_attribute_spec_seq\n   (cp_parser *);\n+static size_t cp_parser_skip_attributes_opt\n+  (cp_parser *, size_t);\n static bool cp_parser_extension_opt\n   (cp_parser *, int *);\n static void cp_parser_label_declaration\n@@ -23628,34 +23630,29 @@ cp_parser_member_declaration (cp_parser* parser)\n \t  tree attributes = NULL_TREE;\n \t  tree first_attribute;\n \t  tree initializer;\n-\t  bool is_bitfld = false;\n \t  bool named_bitfld = false;\n \n \t  /* Peek at the next token.  */\n \t  token = cp_lexer_peek_token (parser->lexer);\n \n \t  /* The following code wants to know early if it is a bit-field\n \t     or some other declaration.  Attributes can appear before\n-\t     the `:' token, but are hopefully rare enough that the\n-\t     simplicity of the tentative lookup pays off.  */\n+\t     the `:' token.  Skip over them without consuming any tokens\n+\t     to peek if they are followed by `:'.  */\n \t  if (cp_next_tokens_can_be_attribute_p (parser)\n \t      || (token->type == CPP_NAME\n \t\t  && cp_nth_tokens_can_be_attribute_p (parser, 2)\n \t\t  && (named_bitfld = true)))\n \t    {\n-\t      cp_parser_parse_tentatively (parser);\n-\t      if (named_bitfld)\n-\t\tcp_lexer_consume_token (parser->lexer);\n-\t      cp_parser_attributes_opt (parser);\n-\t      token = cp_lexer_peek_token (parser->lexer);\n-\t      is_bitfld = cp_lexer_next_token_is (parser->lexer, CPP_COLON);\n-\t      cp_parser_abort_tentative_parse (parser);\n+\t      size_t n\n+\t\t= cp_parser_skip_attributes_opt (parser, 1 + named_bitfld);\n+\t      token = cp_lexer_peek_nth_token (parser->lexer, n);\n \t    }\n \n \t  /* Check for a bitfield declaration.  */\n-\t  if (is_bitfld\n-\t      || token->type == CPP_COLON\n+\t  if (token->type == CPP_COLON\n \t      || (token->type == CPP_NAME\n+\t\t  && token == cp_lexer_peek_token (parser->lexer)\n \t\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_COLON)\n \t\t  && (named_bitfld = true)))\n \t    {\n@@ -24919,7 +24916,7 @@ static tree\n cp_parser_attributes_opt (cp_parser *parser)\n {\n   if (cp_next_tokens_can_be_gnu_attribute_p (parser))\n-      return cp_parser_gnu_attributes_opt (parser);\n+    return cp_parser_gnu_attributes_opt (parser);\n   return cp_parser_std_attribute_spec_seq (parser);\n }\n \n@@ -25462,6 +25459,115 @@ cp_parser_std_attribute_spec_seq (cp_parser *parser)\n   return attr_specs;\n }\n \n+/* Skip a balanced-token starting at Nth token (with 1 as the next token),\n+   return index of the first token after balanced-token, or N on failure.  */\n+\n+static size_t\n+cp_parser_skip_balanced_tokens (cp_parser *parser, size_t n)\n+{\n+  size_t orig_n = n;\n+  int nparens = 0, nbraces = 0, nsquares = 0;\n+  do\n+    switch (cp_lexer_peek_nth_token (parser->lexer, n++)->type)\n+      {\n+      case CPP_EOF:\n+      case CPP_PRAGMA_EOL:\n+\t/* Ran out of tokens.  */\n+\treturn orig_n;\n+      case CPP_OPEN_PAREN:\n+\t++nparens;\n+\tbreak;\n+      case CPP_OPEN_BRACE:\n+\t++nbraces;\n+\tbreak;\n+      case CPP_OPEN_SQUARE:\n+\t++nsquares;\n+\tbreak;\n+      case CPP_CLOSE_PAREN:\n+\t--nparens;\n+\tbreak;\n+      case CPP_CLOSE_BRACE:\n+\t--nbraces;\n+\tbreak;\n+      case CPP_CLOSE_SQUARE:\n+\t--nsquares;\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+  while (nparens || nbraces || nsquares);\n+  return n;\n+}\n+\n+/* Skip GNU attribute tokens starting at Nth token (with 1 as the next token),\n+   return index of the first token after the GNU attribute tokens, or N on\n+   failure.  */\n+\n+static size_t\n+cp_parser_skip_gnu_attributes_opt (cp_parser *parser, size_t n)\n+{\n+  while (true)\n+    {\n+      if (!cp_lexer_nth_token_is_keyword (parser->lexer, n, RID_ATTRIBUTE)\n+\t  || !cp_lexer_nth_token_is (parser->lexer, n + 1, CPP_OPEN_PAREN)\n+\t  || !cp_lexer_nth_token_is (parser->lexer, n + 2, CPP_OPEN_PAREN))\n+\tbreak;\n+\n+      size_t n2 = cp_parser_skip_balanced_tokens (parser, n + 2);\n+      if (n2 == n + 2)\n+\tbreak;\n+      if (!cp_lexer_nth_token_is (parser->lexer, n2, CPP_CLOSE_PAREN))\n+\tbreak;\n+      n = n2 + 1;\n+    }\n+  return n;\n+}\n+\n+/* Skip standard C++11 attribute tokens starting at Nth token (with 1 as the\n+   next token), return index of the first token after the standard C++11\n+   attribute tokens, or N on failure.  */\n+\n+static size_t\n+cp_parser_skip_std_attribute_spec_seq (cp_parser *parser, size_t n)\n+{\n+  while (true)\n+    {\n+      if (cp_lexer_nth_token_is (parser->lexer, n, CPP_OPEN_SQUARE)\n+\t  && cp_lexer_nth_token_is (parser->lexer, n + 1, CPP_OPEN_SQUARE))\n+\t{\n+\t  size_t n2 = cp_parser_skip_balanced_tokens (parser, n + 1);\n+\t  if (n2 == n + 1)\n+\t    break;\n+\t  if (!cp_lexer_nth_token_is (parser->lexer, n2, CPP_CLOSE_SQUARE))\n+\t    break;\n+\t  n = n2 + 1;\n+\t}\n+      else if (cp_lexer_nth_token_is_keyword (parser->lexer, n, RID_ALIGNAS)\n+\t       && cp_lexer_nth_token_is (parser->lexer, n + 1, CPP_OPEN_PAREN))\n+\t{\n+\t  size_t n2 = cp_parser_skip_balanced_tokens (parser, n + 1);\n+\t  if (n2 == n + 1)\n+\t    break;\n+\t  n = n2;\n+\t}\n+      else\n+\tbreak;\n+    }\n+  return n;\n+}\n+\n+/* Skip standard C++11 or GNU attribute tokens starting at Nth token (with 1\n+   as the next token), return index of the first token after the attribute\n+   tokens, or N on failure.  */\n+\n+static size_t\n+cp_parser_skip_attributes_opt (cp_parser *parser, size_t n)\n+{\n+  if (cp_nth_tokens_can_be_gnu_attribute_p (parser, n))\n+    return cp_parser_skip_gnu_attributes_opt (parser, n);\n+  return cp_parser_skip_std_attribute_spec_seq (parser, n);\n+}\n+\n /* Parse an optional `__extension__' keyword.  Returns TRUE if it is\n    present, and FALSE otherwise.  *SAVED_PEDANTIC is set to the\n    current value of the PEDANTIC flag, regardless of whether or not"}, {"sha": "afe8cf974b5e5555eee2b09e1b7e07d76a77fe71", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d2d641a3e48669a941d41c770740f4bbd3d7f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d2d641a3e48669a941d41c770740f4bbd3d7f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60d2d641a3e48669a941d41c770740f4bbd3d7f1", "patch": "@@ -1,3 +1,8 @@\n+2018-02-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/84609\n+\t* g++.dg/cpp0x/pr84609.C: New test.\n+\n 2018-02-28  Martin Sebor  <msebor@redhat.com>\n \n \tPR testsuite/84617"}, {"sha": "057219280a8450ff474f3aed542985994cbe2cb7", "filename": "gcc/testsuite/g++.dg/cpp0x/pr84609.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d2d641a3e48669a941d41c770740f4bbd3d7f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr84609.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d2d641a3e48669a941d41c770740f4bbd3d7f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr84609.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr84609.C?ref=60d2d641a3e48669a941d41c770740f4bbd3d7f1", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/84609\n+// { dg-do compile { target c++11 } }\n+\n+struct S {\n+  int s __attribute__((aligned([](char *) {})));\t// { dg-error \"requested alignment is not an integer constant\" }\n+  int t [[gnu::aligned([](char *) {})]];\t\t// { dg-error \"requested alignment is not an integer constant\" }\n+  int u __attribute__((aligned([](char *) {}))) : 2;\t// { dg-error \"requested alignment is not an integer constant\" }\n+  int v [[gnu::aligned([](char *) {})]] : 4;\t\t// { dg-error \"requested alignment is not an integer constant\" }\n+};"}]}