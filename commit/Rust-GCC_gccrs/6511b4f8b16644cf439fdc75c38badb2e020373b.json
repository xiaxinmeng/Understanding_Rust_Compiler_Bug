{"sha": "6511b4f8b16644cf439fdc75c38badb2e020373b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUxMWI0ZjhiMTY2NDRjZjQzOWZkYzc1YzM4YmFkYjJlMDIwMzczYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-17T21:31:32Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-17T21:31:32Z"}, "message": "(calculate_giv_inc): Add new variables increment_total and tries...\n\n(calculate_giv_inc): Add new variables increment_total\nand tries, and new label retry, to handle case where increment is\ntwo add instructions.\n\nFrom-SVN: r4689", "tree": {"sha": "8b326b7f99e23ec20da18596e58aa585d5b2ff45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b326b7f99e23ec20da18596e58aa585d5b2ff45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6511b4f8b16644cf439fdc75c38badb2e020373b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6511b4f8b16644cf439fdc75c38badb2e020373b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6511b4f8b16644cf439fdc75c38badb2e020373b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6511b4f8b16644cf439fdc75c38badb2e020373b/comments", "author": null, "committer": null, "parents": [{"sha": "5b0f630beeaa6692f021f32bdbe2a341ab4f4a8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0f630beeaa6692f021f32bdbe2a341ab4f4a8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0f630beeaa6692f021f32bdbe2a341ab4f4a8a"}], "stats": {"total": 38, "additions": 33, "deletions": 5}, "files": [{"sha": "fc8a3f69f19b2941b5c4b1d57aaf489210b2fba6", "filename": "gcc/unroll.c", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6511b4f8b16644cf439fdc75c38badb2e020373b/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6511b4f8b16644cf439fdc75c38badb2e020373b/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=6511b4f8b16644cf439fdc75c38badb2e020373b", "patch": "@@ -1,5 +1,5 @@\n /* Try to unroll loops, and split induction variables.\n-   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n    Contributed by James E. Wilson, Cygnus Support/UC Berkeley.\n \n This file is part of GNU CC.\n@@ -1318,7 +1318,10 @@ calculate_giv_inc (pattern, src_insn, regno)\n      int regno;\n {\n   rtx increment;\n+  rtx increment_total = 0;\n+  int tries = 0;\n \n+ retry:\n   /* Verify that we have an increment insn here.  First check for a plus\n      as the set source.  */\n   if (GET_CODE (SET_SRC (pattern)) != PLUS)\n@@ -1341,7 +1344,8 @@ calculate_giv_inc (pattern, src_insn, regno)\n     {\n       /* SR sometimes puts the constant in a register, especially if it is\n \t too big to be an add immed operand.  */\n-      increment = SET_SRC (PATTERN (PREV_INSN (src_insn)));\n+      src_insn = PREV_INSN (src_insn);\n+      increment = SET_SRC (PATTERN (src_insn));\n \n       /* SR may have used LO_SUM to compute the constant if it is too large\n \t for a load immed operand.  In this case, the constant is in operand\n@@ -1357,12 +1361,36 @@ calculate_giv_inc (pattern, src_insn, regno)\n       delete_insn (get_last_insn ());\n     }\n \n-  /* Check that the source register is the same as the dest register.  */\n+  if (increment_total)\n+    increment_total = GEN_INT (INTVAL (increment_total) + INTVAL (increment));\n+  else\n+    increment_total = increment;\n+\n+  /* Check that the source register is the same as the register we expected\n+     to see as the source.  If not, something is seriously wrong.  */\n   if (GET_CODE (XEXP (SET_SRC (pattern), 0)) != REG\n       || REGNO (XEXP (SET_SRC (pattern), 0)) != regno)\n-    abort ();\n+    {\n+      /* Some machines (e.g. the romp), may emit two add instructions for\n+\t certain constants, so lets try looking for another add immediately\n+\t before this one if we have only seen one add insn so far.  */\n+\n+      if (tries == 0)\n+\t{\n+\t  tries++;\n+\n+\t  src_insn = PREV_INSN (src_insn);\n+\t  pattern = PATTERN (src_insn);\n+\n+\t  delete_insn (get_last_insn ());\n+\n+\t  goto retry;\n+\t}\n+\n+      abort ();\n+    }\n \n-  return increment;\n+  return increment_total;\n }\n \n /* Copy REG_NOTES, except for insn references, because not all insn_map"}]}