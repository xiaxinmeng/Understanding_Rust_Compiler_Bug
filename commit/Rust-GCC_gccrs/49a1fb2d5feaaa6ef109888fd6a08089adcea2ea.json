{"sha": "49a1fb2d5feaaa6ef109888fd6a08089adcea2ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlhMWZiMmQ1ZmVhYWE2ZWYxMDk4ODhmZDZhMDgwODlhZGNlYTJlYQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-03-08T19:30:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-03-08T19:30:55Z"}, "message": "tree-ssa-sccvn.h (vn_binary_op_lookup): Remove.\n\n2008-03-08  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-sccvn.h (vn_binary_op_lookup): Remove.\n\t(vn_binary_op_insert): Likewise.\n\t(vn_unary_op_lookup): Likewise.\n\t(vn_unary_op_insert): Likewise.\n\t(vn_nary_op_lookup): Declare.\n\t(vn_nary_op_insert): Likewise.\n\t* tree-ssa-sccvn.c (struct vn_tables_s): Merge unary\n\tand binary hashes, use a single obstack for unary_op_pool\n\tand binary_op_pool.\n\t(struct vn_binary_op_s, struct vn_unary_op_s): Replace with\n\ta single struct vn_nary_op_s.  Store tree code length and\n\ta variable number of operands.\n\t(struct vn_reference_op_struct): Remove unused op2.\n\t(vn_reference_op_eq): Do not compare op2.\n\t(vn_reference_op_compute_hash): Do not compute hash of op2.\n\t(vn_unary_op_hash, vn_binary_op_hash): Replace with vn_nary_op_hash.\n\t(vn_unary_op_compute_hash, vn_binary_op_compute_hash): Replace\n\twith vn_nary_op_compute_hash.\n\t(vn_unary_op_eq, vn_binary_op_eq): Replace with vn_nary_op_eq.\n\t(vn_unary_op_lookup, vn_binary_op_lookup): Replace with\n\tvn_nary_op_lookup.\n\t(vn_unary_op_insert, vn_binary_op_insert): Replace with\n\tvn_nary_op_insert.\n\t(visit_unary_op): Call nary functions.\n\t(visit_binary_op): Likewise.\n\t(process_scc): Adjust for struct vn_tables_s changes.\n\t(allocate_vn_table): Likewise.\n\t(free_vn_table): Likewise.\n\t* tree-vn.c (vn_add): Call nary functions.\n\t(vn_lookup): Likewise.\n\nFrom-SVN: r133038", "tree": {"sha": "f7a70a860769fdd44d7052da465846a6ebecf6e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7a70a860769fdd44d7052da465846a6ebecf6e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba4698e168aa270ac9ba50ecd2069ec7fa667613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4698e168aa270ac9ba50ecd2069ec7fa667613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba4698e168aa270ac9ba50ecd2069ec7fa667613"}], "stats": {"total": 334, "additions": 130, "deletions": 204}, "files": [{"sha": "c1a187c00c4ecba1d9954709a326d73de6896d60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49a1fb2d5feaaa6ef109888fd6a08089adcea2ea", "patch": "@@ -1,3 +1,36 @@\n+2008-03-08  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-sccvn.h (vn_binary_op_lookup): Remove.\n+\t(vn_binary_op_insert): Likewise.\n+\t(vn_unary_op_lookup): Likewise.\n+\t(vn_unary_op_insert): Likewise.\n+\t(vn_nary_op_lookup): Declare.\n+\t(vn_nary_op_insert): Likewise.\n+\t* tree-ssa-sccvn.c (struct vn_tables_s): Merge unary\n+\tand binary hashes, use a single obstack for unary_op_pool\n+\tand binary_op_pool.\n+\t(struct vn_binary_op_s, struct vn_unary_op_s): Replace with\n+\ta single struct vn_nary_op_s.  Store tree code length and\n+\ta variable number of operands.\n+\t(struct vn_reference_op_struct): Remove unused op2.\n+\t(vn_reference_op_eq): Do not compare op2.\n+\t(vn_reference_op_compute_hash): Do not compute hash of op2.\n+\t(vn_unary_op_hash, vn_binary_op_hash): Replace with vn_nary_op_hash.\n+\t(vn_unary_op_compute_hash, vn_binary_op_compute_hash): Replace\n+\twith vn_nary_op_compute_hash.\n+\t(vn_unary_op_eq, vn_binary_op_eq): Replace with vn_nary_op_eq.\n+\t(vn_unary_op_lookup, vn_binary_op_lookup): Replace with\n+\tvn_nary_op_lookup.\n+\t(vn_unary_op_insert, vn_binary_op_insert): Replace with\n+\tvn_nary_op_insert.\n+\t(visit_unary_op): Call nary functions.\n+\t(visit_binary_op): Likewise.\n+\t(process_scc): Adjust for struct vn_tables_s changes.\n+\t(allocate_vn_table): Likewise.\n+\t(free_vn_table): Likewise.\n+\t* tree-vn.c (vn_add): Call nary functions.\n+\t(vn_lookup): Likewise.\n+\n 2008-03-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/35498"}, {"sha": "044be45c8bc7446c472aa3d627f4d3f5f9bdeafe", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 89, "deletions": 194, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=49a1fb2d5feaaa6ef109888fd6a08089adcea2ea", "patch": "@@ -107,45 +107,29 @@ along with GCC; see the file COPYING3.  If not see\n \n typedef struct vn_tables_s\n {\n-  htab_t unary;\n-  htab_t binary;\n+  htab_t nary;\n   htab_t phis;\n   htab_t references;\n-  alloc_pool unary_op_pool;\n-  alloc_pool binary_op_pool;\n+  struct obstack nary_obstack;\n   alloc_pool phis_pool;\n   alloc_pool references_pool;\n } *vn_tables_t;\n \n-/* Binary operations in the hashtable consist of two operands, an\n+/* Nary operations in the hashtable consist of length operands, an\n    opcode, and a type.  Result is the value number of the operation,\n    and hashcode is stored to avoid having to calculate it\n    repeatedly.  */\n \n-typedef struct vn_binary_op_s\n+typedef struct vn_nary_op_s\n {\n-  enum tree_code opcode;\n+  ENUM_BITFIELD(tree_code) opcode : 16;\n+  unsigned length : 16;\n   hashval_t hashcode;\n-  tree type;\n-  tree op0;\n-  tree op1;\n   tree result;\n-} *vn_binary_op_t;\n-typedef const struct vn_binary_op_s *const_vn_binary_op_t;\n-\n-/* Unary operations in the hashtable consist of a single operand, an\n-   opcode, and a type.  Result is the value number of the operation,\n-   and hashcode is stored to avoid having to calculate it repeatedly. */\n-\n-typedef struct vn_unary_op_s\n-{\n-  enum tree_code opcode;\n-  hashval_t hashcode;\n   tree type;\n-  tree op0;\n-  tree result;\n-} *vn_unary_op_t;\n-typedef const struct vn_unary_op_s *const_vn_unary_op_t;\n+  tree op[4];\n+} *vn_nary_op_t;\n+typedef const struct vn_nary_op_s *const_vn_nary_op_t;\n \n /* Phi nodes in the hashtable consist of their non-VN_TOP phi\n    arguments, and the basic block the phi is in. Result is the value\n@@ -174,7 +158,6 @@ typedef struct vn_reference_op_struct\n   tree type;\n   tree op0;\n   tree op1;\n-  tree op2;\n } vn_reference_op_s;\n typedef vn_reference_op_s *vn_reference_op_t;\n typedef const vn_reference_op_s *const_vn_reference_op_t;\n@@ -315,8 +298,7 @@ vn_reference_op_eq (const void *p1, const void *p2)\n   return vro1->opcode == vro2->opcode\n     && vro1->type == vro2->type\n     && expressions_equal_p (vro1->op0, vro2->op0)\n-    && expressions_equal_p (vro1->op1, vro2->op1)\n-    && expressions_equal_p (vro1->op2, vro2->op2);\n+    && expressions_equal_p (vro1->op1, vro2->op1);\n }\n \n /* Compute the hash for a reference operand VRO1  */\n@@ -325,8 +307,7 @@ static hashval_t\n vn_reference_op_compute_hash (const vn_reference_op_t vro1)\n {\n   return iterative_hash_expr (vro1->op0, vro1->opcode)\n-    + iterative_hash_expr (vro1->op1, vro1->opcode)\n-    + iterative_hash_expr (vro1->op2, vro1->opcode);\n+    + iterative_hash_expr (vro1->op1, vro1->opcode);\n }\n \n /* Return the hashcode for a given reference operation P1.  */\n@@ -723,193 +704,116 @@ vn_reference_insert (tree op, tree result, VEC (tree, gc) *vuses)\n   *slot = vr1;\n }\n \n-\n-/* Return the stored hashcode for a unary operation.  */\n-\n-static hashval_t\n-vn_unary_op_hash (const void *p1)\n-{\n-  const_vn_unary_op_t const vuo1 = (const_vn_unary_op_t) p1;\n-  return vuo1->hashcode;\n-}\n-\n-/* Hash a unary operation P1 and return the result.  */\n+/* Compute and return the hash value for nary operation VBO1.  */\n \n static inline hashval_t\n-vn_unary_op_compute_hash (const vn_unary_op_t vuo1)\n-{\n-  return iterative_hash_expr (vuo1->op0, vuo1->opcode);\n-}\n-\n-/* Return true if P1 and P2, two unary operations, are equivalent.  */\n-\n-static int\n-vn_unary_op_eq (const void *p1, const void *p2)\n-{\n-  const_vn_unary_op_t const vuo1 = (const_vn_unary_op_t) p1;\n-  const_vn_unary_op_t const vuo2 = (const_vn_unary_op_t) p2;\n-  return vuo1->opcode == vuo2->opcode\n-    && vuo1->type == vuo2->type\n-    && expressions_equal_p (vuo1->op0, vuo2->op0);\n-}\n-\n-/* Lookup OP in the current hash table, and return the resulting\n-   value number if it exists in the hash table.  Return NULL_TREE if\n-   it does not exist in the hash table. */\n-\n-tree\n-vn_unary_op_lookup (tree op)\n-{\n-  void **slot;\n-  struct vn_unary_op_s vuo1;\n-\n-  vuo1.opcode = TREE_CODE (op);\n-  vuo1.type = TREE_TYPE (op);\n-  vuo1.op0 = TREE_OPERAND (op, 0);\n-\n-  if (TREE_CODE (vuo1.op0) == SSA_NAME)\n-    vuo1.op0 = SSA_VAL (vuo1.op0);\n-\n-  vuo1.hashcode = vn_unary_op_compute_hash (&vuo1);\n-  slot = htab_find_slot_with_hash (current_info->unary, &vuo1, vuo1.hashcode,\n-\t\t\t\t   NO_INSERT);\n-  if (!slot && current_info == optimistic_info)\n-    slot = htab_find_slot_with_hash (valid_info->unary, &vuo1, vuo1.hashcode,\n-\t\t\t\t     NO_INSERT);\n-  if (!slot)\n-    return NULL_TREE;\n-  return ((vn_unary_op_t)*slot)->result;\n-}\n-\n-/* Insert OP into the current hash table with a value number of\n-   RESULT.  */\n-\n-void\n-vn_unary_op_insert (tree op, tree result)\n+vn_nary_op_compute_hash (const vn_nary_op_t vno1)\n {\n-  void **slot;\n-  vn_unary_op_t vuo1 = (vn_unary_op_t) pool_alloc (current_info->unary_op_pool);\n-\n-  vuo1->opcode = TREE_CODE (op);\n-  vuo1->type = TREE_TYPE (op);\n-  vuo1->op0 = TREE_OPERAND (op, 0);\n-  vuo1->result = result;\n+  hashval_t hash = 0;\n+  unsigned i;\n \n-  if (TREE_CODE (vuo1->op0) == SSA_NAME)\n-    vuo1->op0 = SSA_VAL (vuo1->op0);\n+  for (i = 0; i < vno1->length; ++i)\n+    if (TREE_CODE (vno1->op[i]) == SSA_NAME)\n+      vno1->op[i] = SSA_VAL (vno1->op[i]);\n \n-  vuo1->hashcode = vn_unary_op_compute_hash (vuo1);\n-  slot = htab_find_slot_with_hash (current_info->unary, vuo1, vuo1->hashcode,\n-\t\t\t\t   INSERT);\n-  gcc_assert (!*slot);\n-  *slot = vuo1;\n-}\n+  if (vno1->length == 2\n+      && commutative_tree_code (vno1->opcode)\n+      && tree_swap_operands_p (vno1->op[0], vno1->op[1], false))\n+    {\n+      tree temp = vno1->op[0];\n+      vno1->op[0] = vno1->op[1];\n+      vno1->op[1] = temp;\n+    }\n \n-/* Compute and return the hash value for binary operation VBO1.  */\n+  for (i = 0; i < vno1->length; ++i)\n+    hash += iterative_hash_expr (vno1->op[i], vno1->opcode);\n \n-static inline hashval_t\n-vn_binary_op_compute_hash (const vn_binary_op_t vbo1)\n-{\n-  return iterative_hash_expr (vbo1->op0, vbo1->opcode)\n-    + iterative_hash_expr (vbo1->op1, vbo1->opcode);\n+  return hash;\n }\n \n-/* Return the computed hashcode for binary operation P1.  */\n+/* Return the computed hashcode for nary operation P1.  */\n \n static hashval_t\n-vn_binary_op_hash (const void *p1)\n+vn_nary_op_hash (const void *p1)\n {\n-  const_vn_binary_op_t const vbo1 = (const_vn_binary_op_t) p1;\n-  return vbo1->hashcode;\n+  const_vn_nary_op_t const vno1 = (const_vn_nary_op_t) p1;\n+  return vno1->hashcode;\n }\n \n-/* Compare binary operations P1 and P2 and return true if they are\n+/* Compare nary operations P1 and P2 and return true if they are\n    equivalent.  */\n \n static int\n-vn_binary_op_eq (const void *p1, const void *p2)\n+vn_nary_op_eq (const void *p1, const void *p2)\n {\n-  const_vn_binary_op_t const vbo1 = (const_vn_binary_op_t) p1;\n-  const_vn_binary_op_t const vbo2 = (const_vn_binary_op_t) p2;\n-  return vbo1->opcode == vbo2->opcode\n-    && vbo1->type == vbo2->type\n-    && expressions_equal_p (vbo1->op0, vbo2->op0)\n-    && expressions_equal_p (vbo1->op1, vbo2->op1);\n+  const_vn_nary_op_t const vno1 = (const_vn_nary_op_t) p1;\n+  const_vn_nary_op_t const vno2 = (const_vn_nary_op_t) p2;\n+  unsigned i;\n+\n+  if (vno1->opcode != vno2->opcode\n+      || vno1->type != vno2->type)\n+    return false;\n+\n+  for (i = 0; i < vno1->length; ++i)\n+    if (!expressions_equal_p (vno1->op[i], vno2->op[i]))\n+      return false;\n+\n+  return true;\n }\n \n /* Lookup OP in the current hash table, and return the resulting\n    value number if it exists in the hash table.  Return NULL_TREE if\n    it does not exist in the hash table. */\n \n tree\n-vn_binary_op_lookup (tree op)\n+vn_nary_op_lookup (tree op)\n {\n   void **slot;\n-  struct vn_binary_op_s vbo1;\n-\n-  vbo1.opcode = TREE_CODE (op);\n-  vbo1.type = TREE_TYPE (op);\n-  vbo1.op0 = TREE_OPERAND (op, 0);\n-  vbo1.op1 = TREE_OPERAND (op, 1);\n-\n-  if (TREE_CODE (vbo1.op0) == SSA_NAME)\n-    vbo1.op0 = SSA_VAL (vbo1.op0);\n-  if (TREE_CODE (vbo1.op1) == SSA_NAME)\n-    vbo1.op1 = SSA_VAL (vbo1.op1);\n-\n-  if (tree_swap_operands_p (vbo1.op0, vbo1.op1, false)\n-      && commutative_tree_code (vbo1.opcode))\n-    {\n-      tree temp = vbo1.op0;\n-      vbo1.op0 = vbo1.op1;\n-      vbo1.op1 = temp;\n-    }\n-\n-  vbo1.hashcode = vn_binary_op_compute_hash (&vbo1);\n-  slot = htab_find_slot_with_hash (current_info->binary, &vbo1, vbo1.hashcode,\n+  struct vn_nary_op_s vno1;\n+  unsigned i;\n+\n+  vno1.opcode = TREE_CODE (op);\n+  vno1.length = TREE_CODE_LENGTH (TREE_CODE (op));\n+  vno1.type = TREE_TYPE (op);\n+  for (i = 0; i < vno1.length; ++i)\n+    vno1.op[i] = TREE_OPERAND (op, i);\n+  vno1.hashcode = vn_nary_op_compute_hash (&vno1);\n+  slot = htab_find_slot_with_hash (current_info->nary, &vno1, vno1.hashcode,\n \t\t\t\t   NO_INSERT);\n   if (!slot && current_info == optimistic_info)\n-    slot = htab_find_slot_with_hash (valid_info->binary, &vbo1, vbo1.hashcode,\n+    slot = htab_find_slot_with_hash (valid_info->nary, &vno1, vno1.hashcode,\n \t\t\t\t     NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n-  return ((vn_binary_op_t)*slot)->result;\n+  return ((vn_nary_op_t)*slot)->result;\n }\n \n /* Insert OP into the current hash table with a value number of\n    RESULT.  */\n \n void\n-vn_binary_op_insert (tree op, tree result)\n+vn_nary_op_insert (tree op, tree result)\n {\n+  unsigned length = TREE_CODE_LENGTH (TREE_CODE (op));\n   void **slot;\n-  vn_binary_op_t vbo1;\n-  vbo1 = (vn_binary_op_t) pool_alloc (current_info->binary_op_pool);\n-\n-  vbo1->opcode = TREE_CODE (op);\n-  vbo1->type = TREE_TYPE (op);\n-  vbo1->op0 = TREE_OPERAND (op, 0);\n-  vbo1->op1 = TREE_OPERAND (op, 1);\n-  vbo1->result = result;\n-\n-  if (TREE_CODE (vbo1->op0) == SSA_NAME)\n-    vbo1->op0 = SSA_VAL (vbo1->op0);\n-  if (TREE_CODE (vbo1->op1) == SSA_NAME)\n-    vbo1->op1 = SSA_VAL (vbo1->op1);\n-\n-  if (tree_swap_operands_p (vbo1->op0, vbo1->op1, false)\n-      && commutative_tree_code (vbo1->opcode))\n-    {\n-      tree temp = vbo1->op0;\n-      vbo1->op0 = vbo1->op1;\n-      vbo1->op1 = temp;\n-    }\n-  vbo1->hashcode = vn_binary_op_compute_hash (vbo1);\n-  slot = htab_find_slot_with_hash (current_info->binary, vbo1, vbo1->hashcode,\n+  vn_nary_op_t vno1;\n+  unsigned i;\n+\n+  vno1 = obstack_alloc (&current_info->nary_obstack,\n+\t\t\t(sizeof (struct vn_nary_op_s)\n+\t\t\t - sizeof (tree) * (4 - length)));\n+  vno1->opcode = TREE_CODE (op);\n+  vno1->length = length;\n+  vno1->type = TREE_TYPE (op);\n+  for (i = 0; i < vno1->length; ++i)\n+    vno1->op[i] = TREE_OPERAND (op, i);\n+  vno1->result = result;\n+  vno1->hashcode = vn_nary_op_compute_hash (vno1);\n+  slot = htab_find_slot_with_hash (current_info->nary, vno1, vno1->hashcode,\n \t\t\t\t   INSERT);\n   gcc_assert (!*slot);\n \n-  *slot = vbo1;\n+  *slot = vno1;\n }\n \n /* Compute a hashcode for PHI operation VP1 and return it.  */\n@@ -1139,7 +1043,7 @@ static bool\n visit_unary_op (tree lhs, tree op)\n {\n   bool changed = false;\n-  tree result = vn_unary_op_lookup (op);\n+  tree result = vn_nary_op_lookup (op);\n \n   if (result)\n     {\n@@ -1148,7 +1052,7 @@ visit_unary_op (tree lhs, tree op)\n   else\n     {\n       changed = set_ssa_val_to (lhs, lhs);\n-      vn_unary_op_insert (op, lhs);\n+      vn_nary_op_insert (op, lhs);\n     }\n \n   return changed;\n@@ -1161,7 +1065,7 @@ static bool\n visit_binary_op (tree lhs, tree op)\n {\n   bool changed = false;\n-  tree result = vn_binary_op_lookup (op);\n+  tree result = vn_nary_op_lookup (op);\n \n   if (result)\n     {\n@@ -1170,7 +1074,7 @@ visit_binary_op (tree lhs, tree op)\n   else\n     {\n       changed = set_ssa_val_to (lhs, lhs);\n-      vn_binary_op_insert (op, lhs);\n+      vn_nary_op_insert (op, lhs);\n     }\n \n   return changed;\n@@ -1843,12 +1747,11 @@ process_scc (VEC (tree, heap) *scc)\n \t{\n \t  changed = false;\n \t  iterations++;\n-\t  htab_empty (optimistic_info->unary);\n-\t  htab_empty (optimistic_info->binary);\n+\t  htab_empty (optimistic_info->nary);\n \t  htab_empty (optimistic_info->phis);\n \t  htab_empty (optimistic_info->references);\n-\t  empty_alloc_pool (optimistic_info->unary_op_pool);\n-\t  empty_alloc_pool (optimistic_info->binary_op_pool);\n+\t  obstack_free (&optimistic_info->nary_obstack, NULL);\n+\t  gcc_obstack_init (&optimistic_info->nary_obstack);\n \t  empty_alloc_pool (optimistic_info->phis_pool);\n \t  empty_alloc_pool (optimistic_info->references_pool);\n \t  for (i = 0; VEC_iterate (tree, scc, i, var); i++)\n@@ -1965,17 +1868,11 @@ static void\n allocate_vn_table (vn_tables_t table)\n {\n   table->phis = htab_create (23, vn_phi_hash, vn_phi_eq, free_phi);\n-  table->unary = htab_create (23, vn_unary_op_hash, vn_unary_op_eq, NULL);\n-  table->binary = htab_create (23, vn_binary_op_hash, vn_binary_op_eq, NULL);\n+  table->nary = htab_create (23, vn_nary_op_hash, vn_nary_op_eq, NULL);\n   table->references = htab_create (23, vn_reference_hash, vn_reference_eq,\n \t\t\t\t   free_reference);\n \n-  table->unary_op_pool = create_alloc_pool (\"VN unary operations\",\n-\t\t\t\t\t    sizeof (struct vn_unary_op_s),\n-\t\t\t\t\t    30);\n-  table->binary_op_pool = create_alloc_pool (\"VN binary operations\",\n-\t\t\t\t\t     sizeof (struct vn_binary_op_s),\n-\t\t\t\t\t     30);\n+  gcc_obstack_init (&table->nary_obstack);\n   table->phis_pool = create_alloc_pool (\"VN phis\",\n \t\t\t\t\tsizeof (struct vn_phi_s),\n \t\t\t\t\t30);\n@@ -1990,11 +1887,9 @@ static void\n free_vn_table (vn_tables_t table)\n {\n   htab_delete (table->phis);\n-  htab_delete (table->unary);\n-  htab_delete (table->binary);\n+  htab_delete (table->nary);\n   htab_delete (table->references);\n-  free_alloc_pool (table->unary_op_pool);\n-  free_alloc_pool (table->binary_op_pool);\n+  obstack_free (&table->nary_obstack, NULL);\n   free_alloc_pool (table->phis_pool);\n   free_alloc_pool (table->references_pool);\n }"}, {"sha": "54055d412a6e28e990032ec20caa82c9f21becde", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=49a1fb2d5feaaa6ef109888fd6a08089adcea2ea", "patch": "@@ -52,10 +52,8 @@ extern vn_ssa_aux_t VN_INFO_GET (tree);\n bool run_scc_vn (void);\n void free_scc_vn (void);\n void switch_to_PRE_table (void);\n-tree vn_binary_op_lookup (tree);\n-void vn_binary_op_insert (tree, tree);\n-tree vn_unary_op_lookup (tree);\n-void vn_unary_op_insert (tree, tree);\n+tree vn_nary_op_lookup (tree);\n+void vn_nary_op_insert (tree, tree);\n tree vn_reference_lookup (tree, VEC (tree, gc) *);\n void vn_reference_insert (tree, tree, VEC (tree, gc) *);\n VEC (tree, gc) *shared_vuses_from_stmt (tree);"}, {"sha": "2122a7e432ecdeaccd4390b42f96b599c99d33ad", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a1fb2d5feaaa6ef109888fd6a08089adcea2ea/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=49a1fb2d5feaaa6ef109888fd6a08089adcea2ea", "patch": "@@ -173,10 +173,10 @@ vn_add (tree expr, tree val)\n     {\n     case tcc_comparison:\n     case tcc_binary:\n-      vn_binary_op_insert (expr, val);\n+      vn_nary_op_insert (expr, val);\n       break;\n     case tcc_unary:\n-      vn_unary_op_insert (expr, val);\n+      vn_nary_op_insert (expr, val);\n       break;\n       /* In the case of array-refs of constants, for example, we can\n \t end up with no vuses.  */\n@@ -201,7 +201,7 @@ vn_add (tree expr, tree val)\n \t}\n       else if (TREE_CODE (expr) == ADDR_EXPR)\n \t{\n-\t  vn_unary_op_insert (expr, val);\n+\t  vn_nary_op_insert (expr, val);\n \t  break;\n \t}\n       /* FALLTHROUGH */\n@@ -248,9 +248,9 @@ vn_lookup (tree expr)\n     {\n     case tcc_comparison:\n     case tcc_binary:\n-      return vn_binary_op_lookup (expr);\n+      return vn_nary_op_lookup (expr);\n     case tcc_unary:\n-      return vn_unary_op_lookup (expr);\n+      return vn_nary_op_lookup (expr);\n       break;\n       /* In the case of array-refs of constants, for example, we can\n \t end up with no vuses.  */\n@@ -268,7 +268,7 @@ vn_lookup (tree expr)\n       else if (TREE_CODE (expr) == SSA_NAME)\n \treturn SSA_NAME_VALUE (expr);\n       else if (TREE_CODE (expr) == ADDR_EXPR)\n-\treturn vn_unary_op_lookup (expr);\n+\treturn vn_nary_op_lookup (expr);\n       /* FALLTHROUGH */\n     default:\n       gcc_unreachable ();"}]}