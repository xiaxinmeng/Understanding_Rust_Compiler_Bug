{"sha": "3910a7cb5ea4b50d79c6aa36b28369716e130111", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkxMGE3Y2I1ZWE0YjUwZDc5YzZhYTM2YjI4MzY5NzE2ZTEzMDExMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-20T10:10:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-20T10:10:50Z"}, "message": "(contains_placeholder_p): Call contains_this_placeholder_p.\n\n(contains_this_placeholder_p): Renamed from contains_placeholder_p.\nAdded new arg, PL.\nRework to make more consistent, check more codes, and avoid\nundefined fields.\n\nFrom-SVN: r14497", "tree": {"sha": "527b7b2325254e72b39cf16141ff6d008c7dcb31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/527b7b2325254e72b39cf16141ff6d008c7dcb31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3910a7cb5ea4b50d79c6aa36b28369716e130111", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3910a7cb5ea4b50d79c6aa36b28369716e130111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3910a7cb5ea4b50d79c6aa36b28369716e130111", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3910a7cb5ea4b50d79c6aa36b28369716e130111/comments", "author": null, "committer": null, "parents": [{"sha": "b9a2d59104ca641614e4bbaed657a4d09b4e97bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a2d59104ca641614e4bbaed657a4d09b4e97bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a2d59104ca641614e4bbaed657a4d09b4e97bf"}], "stats": {"total": 79, "additions": 56, "deletions": 23}, "files": [{"sha": "58a4173d420d705b91a4410cd9b43b1deaaa8431", "filename": "gcc/tree.c", "status": "modified", "additions": 56, "deletions": 23, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3910a7cb5ea4b50d79c6aa36b28369716e130111/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3910a7cb5ea4b50d79c6aa36b28369716e130111/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3910a7cb5ea4b50d79c6aa36b28369716e130111", "patch": "@@ -2392,53 +2392,86 @@ unsave_expr_now (expr)\n }\n \f\n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n-   or offset that depends on a field within a record.\n-\n-   Note that we only allow such expressions within simple arithmetic\n-   or a COND_EXPR.  */\n+   or offset that depends on a field within a record.  */\n \n int\n contains_placeholder_p (exp)\n      tree exp;\n+{\n+  return contains_this_placeholder_p (exp, NULL_TREE);\n+}\n+\n+/* Similar, but if PL is non-zero it is assumed to be a PLACEHOLDER_EXPR\n+   and we return 1 if that PLACEHOLDER_EXPR is in EXP.  */\n+\n+int\n+contains_this_placeholder_p (exp, pl)\n+     tree exp;\n+     tree pl;\n {\n   register enum tree_code code = TREE_CODE (exp);\n-  tree inner;\n \n   /* If we have a WITH_RECORD_EXPR, it \"cancels\" any PLACEHOLDER_EXPR\n      in it since it is supplying a value for it.  */\n   if (code == WITH_RECORD_EXPR)\n     return 0;\n   else if (code == PLACEHOLDER_EXPR)\n-    return 1;\n+    return (pl == 0 || pl == exp);\n \n   switch (TREE_CODE_CLASS (code))\n     {\n     case 'r':\n-      for (inner = TREE_OPERAND (exp, 0);\n-\t   TREE_CODE_CLASS (TREE_CODE (inner)) == 'r';\n-\t   inner = TREE_OPERAND (inner, 0))\n-\t;\n-      return TREE_CODE (inner) == PLACEHOLDER_EXPR;\n+      if (TREE_CODE (exp) == ARRAY_REF)\n+\t{\n+\t  tree domain = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\n+\t  if (domain != 0\n+\t      && ((TREE_CODE (TYPE_MIN_VALUE (domain)) != INTEGER_CST\n+\t\t   && contains_this_placeholder_p (TYPE_MIN_VALUE (domain),\n+\t\t\t\t\t\t   pl))\n+\t\t  || (TREE_CODE (TYPE_MAX_VALUE (domain)) != INTEGER_CST\n+\t\t      && contains_this_placeholder_p (TYPE_MAX_VALUE (domain),\n+\t\t\t\t\t\t      pl))\n+\t\t  || contains_this_placeholder_p (TREE_OPERAND (exp, 1), pl)))\n+\t    return 1;\n+\t}\n+      else if (TREE_CODE (exp) == BIT_FIELD_REF\n+\t       && (contains_this_placeholder_p (TREE_OPERAND (exp, 1), pl)\n+\t\t   || contains_this_placeholder_p (TREE_OPERAND (exp, 2), pl)))\n+\treturn 1;\n+\n+      return contains_this_placeholder_p (TREE_OPERAND (exp, 0), pl);\n \n     case '1':\n     case '2':  case '<':\n     case 'e':\n+      switch (code)\n+\t{\n+\tcase COMPOUND_EXPR:\n+\t  /* Ignoring the first operand isn't quite right, but works best. */\n+\t  return contains_this_placeholder_p (TREE_OPERAND (exp, 1), pl);\n+\n+\tcase RTL_EXPR:\n+\tcase CONSTRUCTOR:\n+\t  return 0;\n+\n+\tcase COND_EXPR:\n+\t  return (contains_this_placeholder_p (TREE_OPERAND (exp, 0), pl)\n+\t\t  || contains_this_placeholder_p (TREE_OPERAND (exp, 1), pl)\n+\t\t  || contains_this_placeholder_p (TREE_OPERAND (exp, 2), pl));\n+\n+\tcase SAVE_EXPR:\n+\t   return (SAVE_EXPR_RTL (exp) == 0\n+\t\t   && contains_this_placeholder_p (TREE_OPERAND (exp, 0), pl));\n+\t}\n+\n       switch (tree_code_length[(int) code])\n \t{\n \tcase 1:\n-\t  return contains_placeholder_p (TREE_OPERAND (exp, 0));\n+\t  return contains_this_placeholder_p (TREE_OPERAND (exp, 0), pl);\n \tcase 2:\n-\t  return (code != RTL_EXPR\n-\t\t  && code != CONSTRUCTOR\n-\t\t  && ! (code == SAVE_EXPR && SAVE_EXPR_RTL (exp) != 0)\n-\t\t  && code != WITH_RECORD_EXPR\n-\t\t  && (contains_placeholder_p (TREE_OPERAND (exp, 0))\n-\t\t      || contains_placeholder_p (TREE_OPERAND (exp, 1))));\n-\tcase 3:\n-\t  return (code == COND_EXPR\n-\t\t  && (contains_placeholder_p (TREE_OPERAND (exp, 0))\n-\t\t      || contains_placeholder_p (TREE_OPERAND (exp, 1))\n-\t\t      || contains_placeholder_p (TREE_OPERAND (exp, 2))));\n+\t  return (contains_this_placeholder_p (TREE_OPERAND (exp, 0), pl)\n+\t\t  || contains_this_placeholder_p (TREE_OPERAND (exp, 1), pl));\n \t}\n     }\n "}]}