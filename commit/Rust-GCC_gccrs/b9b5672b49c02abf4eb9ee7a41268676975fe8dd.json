{"sha": "b9b5672b49c02abf4eb9ee7a41268676975fe8dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjliNTY3MmI0OWMwMmFiZjRlYjllZTdhNDEyNjg2NzY5NzVmZThkZA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@mckinlay.net.nz", "date": "2003-10-26T02:25:42Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2003-10-26T02:25:42Z"}, "message": "Constructor.java (toString): Avoid extra whitespace on constructor with no modifiers.\n\n2003-10-26  Bryce McKinlay  <bryce@mckinlay.net.nz>\n\n\t* java/lang/reflect/Constructor.java (toString): Avoid extra\n\twhitespace on constructor with no modifiers.\n\t* java/lang/reflect/natConstructor.java (newInstance): Look up\n\tcaller and perform accessibility check only if constructor is\n\tnon-public and accessible flag is not set.\n\n2003-10-26  Bryce McKinlay  <bryce@mckinlay.net.nz>\n\n\t* jni.cc (_Jv_JNI_CallAnyMethodV, _Jv_JNI_CallAnyMethodA,\n\t_Jv_JNI_CallAnyVoidMethodV, _Jv_JNI_CallAnyVoidMethodA): Don't\n\tuse _Jv_LookupDeclaredMethod(). Call _Jv_CallAnyMethodA with\n\tis_virtual_call argument.\n\t* include/jvm.h (_Jv_isVirtualMethod): Moved and renamed from\n\tnatClass.cc.\n\t* java/lang/natClass.cc (_Jv_LayoutVTableMethods): Use\n\t_Jv_isVirtualMethod.\n\t* java/lang/reflect/natMethod.cc (invoke): Don't use\n\t_Jv_LookupDeclaredMethod.\n\t(_Jv_CallAnyMethodA): New is_virtual_call argument. If specified,\n\tlook up method in target object's vtable.\n\nFrom-SVN: r72942", "tree": {"sha": "904732224e65247ccdf90cd04bd9cd1ec4f63816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/904732224e65247ccdf90cd04bd9cd1ec4f63816"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9b5672b49c02abf4eb9ee7a41268676975fe8dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9b5672b49c02abf4eb9ee7a41268676975fe8dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9b5672b49c02abf4eb9ee7a41268676975fe8dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/comments", "author": null, "committer": null, "parents": [{"sha": "077a148bf5d7da017005caa18faccc7976704c79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/077a148bf5d7da017005caa18faccc7976704c79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/077a148bf5d7da017005caa18faccc7976704c79"}], "stats": {"total": 147, "additions": 90, "deletions": 57}, "files": [{"sha": "54a900b4568a7e6e20e727c36187a2a746e10104", "filename": "libjava/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b9b5672b49c02abf4eb9ee7a41268676975fe8dd", "patch": "@@ -1,3 +1,26 @@\n+2003-10-26  Bryce McKinlay  <bryce@mckinlay.net.nz>\n+\n+\t* java/lang/reflect/Constructor.java (toString): Avoid extra \n+\twhitespace on constructor with no modifiers.\n+\t* java/lang/reflect/natConstructor.java (newInstance): Look up\n+\tcaller and perform accessibility check only if constructor is\n+\tnon-public and accessible flag is not set.\n+\n+2003-10-26  Bryce McKinlay  <bryce@mckinlay.net.nz>\n+\n+\t* jni.cc (_Jv_JNI_CallAnyMethodV, _Jv_JNI_CallAnyMethodA,\n+\t_Jv_JNI_CallAnyVoidMethodV, _Jv_JNI_CallAnyVoidMethodA): Don't\n+\tuse _Jv_LookupDeclaredMethod(). Call _Jv_CallAnyMethodA with \n+\tis_virtual_call argument.\n+\t* include/jvm.h (_Jv_isVirtualMethod): Moved and renamed from \n+\tnatClass.cc.\n+\t* java/lang/natClass.cc (_Jv_LayoutVTableMethods): Use \n+\t_Jv_isVirtualMethod.\n+\t* java/lang/reflect/natMethod.cc (invoke): Don't use \n+\t_Jv_LookupDeclaredMethod.\n+\t(_Jv_CallAnyMethodA): New is_virtual_call argument. If specified,\n+\tlook up method in target object's vtable.\n+\n 2003-10-25  Graydon Hoare  <graydon@redhat.com>\n \n \t* gnu/java/awt/ClasspathToolkit.java: New abstract class."}, {"sha": "e1a5c33bbc6ffbdc29ac1402babeb8c4f075f0a4", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=b9b5672b49c02abf4eb9ee7a41268676975fe8dd", "patch": "@@ -335,6 +335,14 @@ _Jv_VTable::new_vtable (int count)\n   return (_Jv_VTable *) _Jv_AllocBytes (size);\n }\n \n+// Determine if METH gets an entry in a VTable.\n+static inline jboolean _Jv_isVirtualMethod (_Jv_Method *meth)\n+{\n+  using namespace java::lang::reflect;\n+  return (((meth->accflags & (Modifier::STATIC | Modifier::PRIVATE)) == 0)\n+          && meth->name->data[0] != '<');\n+}\n+\n // This function is used to determine the hash code of an object.\n inline jint\n _Jv_HashCode (jobject obj)\n@@ -418,6 +426,7 @@ extern void _Jv_CallAnyMethodA (jobject obj,\n \t\t\t\tjclass return_type,\n \t\t\t\tjmethodID meth,\n \t\t\t\tjboolean is_constructor,\n+\t\t\t\tjboolean is_virtual_call,\n \t\t\t\tJArray<jclass> *parameter_types,\n \t\t\t\tjvalue *args,\n \t\t\t\tjvalue *result,"}, {"sha": "ffac2c1ff53fd4fe7dd4b0bd0443a3bd58ef3def", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=b9b5672b49c02abf4eb9ee7a41268676975fe8dd", "patch": "@@ -1779,16 +1779,6 @@ _Jv_linkExceptionClassTable (jclass self)\n   self->catch_classes->classname = (_Jv_Utf8Const *)-1;\n }\n   \n-\n-// Returns true if METH should get an entry in a VTable.\n-static jboolean\n-isVirtualMethod (_Jv_Method *meth)\n-{\n-  using namespace java::lang::reflect;\n-  return (((meth->accflags & (Modifier::STATIC | Modifier::PRIVATE)) == 0)\n-          && meth->name->data[0] != '<');\n-}\n-\n // This is put in empty vtable slots.\n static void\n _Jv_abstractMethodError (void)\n@@ -1842,7 +1832,7 @@ _Jv_LayoutVTableMethods (jclass klass)\n       _Jv_Method *meth = &klass->methods[i];\n       _Jv_Method *super_meth = NULL;\n \n-      if (! isVirtualMethod (meth))\n+      if (! _Jv_isVirtualMethod (meth))\n \tcontinue;\n \n       if (superclass != NULL)"}, {"sha": "980ca2a41f2486f3e37728c02fca01f38b5a0772", "filename": "libjava/java/lang/reflect/Constructor.java", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java?ref=b9b5672b49c02abf4eb9ee7a41268676975fe8dd", "patch": "@@ -151,8 +151,12 @@ public String toString ()\n     if (parameter_types == null)\n       getType ();\n     StringBuffer b = new StringBuffer ();\n-    Modifier.toString(getModifiers(), b);\n-    b.append(\" \");\n+    int mods = getModifiers();\n+    if (mods != 0)\n+      {\n+\tModifier.toString(mods, b);\n+\tb.append(\" \");\n+      }\n     Method.appendClassName (b, declaringClass);\n     b.append(\"(\");\n     for (int i = 0; i < parameter_types.length; ++i)"}, {"sha": "3697332d1efb0e8d129654b059a58b5c914620ea", "filename": "libjava/java/lang/reflect/natConstructor.cc", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc?ref=b9b5672b49c02abf4eb9ee7a41268676975fe8dd", "patch": "@@ -45,34 +45,39 @@ java::lang::reflect::Constructor::getType ()\n jobject\n java::lang::reflect::Constructor::newInstance (jobjectArray args)\n {\n+  using namespace java::lang::reflect;\n+\n   if (parameter_types == NULL)\n     getType ();\n \n-  gnu::gcj::runtime::StackTrace *t \n-    = new gnu::gcj::runtime::StackTrace(4);\n-  Class *caller = NULL;\n-  try\n+  jmethodID meth = _Jv_FromReflectedConstructor (this);\n+\n+  // Check accessibility, if required.\n+  if (! (Modifier::isPublic (meth->accflags) || this->isAccessible()))\n     {\n-      for (int i = 1; !caller; i++)\n+      gnu::gcj::runtime::StackTrace *t \n+\t= new gnu::gcj::runtime::StackTrace(4);\n+      Class *caller = NULL;\n+      try\n+\t{\n+\t  for (int i = 1; !caller; i++)\n+\t    {\n+\t      caller = t->classAt (i);\n+\t    }\n+\t}\n+      catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n \t{\n-\t  caller = t->classAt (i);\n \t}\n-    }\n-  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-    {\n-    }\n \n-  if (! isAccessible() && ! _Jv_CheckAccess(caller, declaringClass,\n-\t\t\t\t\t    declaringClass->getModifiers()))\n-    throw new java::lang::IllegalAccessException;\n+      if (! _Jv_CheckAccess(caller, declaringClass, meth->accflags))\n+\tthrow new IllegalAccessException;\n+    }\n \n-  using namespace java::lang::reflect;\n   if (Modifier::isAbstract (declaringClass->getModifiers()))\n     throw new InstantiationException;\n \n   _Jv_InitClass (declaringClass);\n \n-  jmethodID meth = _Jv_FromReflectedConstructor (this);\n   // In the constructor case the return type is the type of the\n   // constructor.\n   return _Jv_CallAnyMethodA (NULL, declaringClass, meth, true,"}, {"sha": "525a4a0e9c90e892850b9da6030d4b34b30bd742", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=b9b5672b49c02abf4eb9ee7a41268676975fe8dd", "patch": "@@ -149,26 +149,22 @@ java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n     \n   jmethodID meth = _Jv_FromReflectedMethod (this);\n \n-  jclass klass;\n-  if (! Modifier::isStatic(meth->accflags))\n-    {\n-      if (! obj)\n-\tthrow new java::lang::NullPointerException;\n-      klass = obj->getClass();\n-      if (! declaringClass->isAssignableFrom(klass))\n-\tthrow new java::lang::IllegalArgumentException;\n-\n-      // Find the possibly overloaded method based on the runtime type\n-      // of the object.\n-      meth = _Jv_LookupDeclaredMethod (klass, meth->name, meth->signature);\n-    }\n-  else\n+  jclass objClass;\n+  \n+  if (Modifier::isStatic(meth->accflags))\n     {\n       // We have to initialize a static class.  It is safe to do this\n       // here and not in _Jv_CallAnyMethodA because JNI initializes a\n       // class whenever a method lookup is done.\n       _Jv_InitClass (declaringClass);\n-      klass = declaringClass;\n+      objClass = declaringClass;\n+    }\n+  else\n+    {\n+      objClass = JV_CLASS (obj);\n+     \n+      if (! _Jv_IsAssignableFrom (declaringClass, objClass))\n+        throw new java::lang::IllegalArgumentException;\n     }\n \n   // Check accessibility, if required.\n@@ -188,7 +184,7 @@ java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n \t{\n \t}\n \n-      if (! _Jv_CheckAccess(caller, klass, meth->accflags))\n+      if (! _Jv_CheckAccess(caller, objClass, meth->accflags))\n \tthrow new IllegalAccessException;\n     }\n \n@@ -341,6 +337,7 @@ _Jv_CallAnyMethodA (jobject obj,\n \t\t    jclass return_type,\n \t\t    jmethodID meth,\n \t\t    jboolean is_constructor,\n+\t\t    jboolean is_virtual_call,\n \t\t    JArray<jclass> *parameter_types,\n \t\t    jvalue *args,\n \t\t    jvalue *result,\n@@ -465,9 +462,21 @@ _Jv_CallAnyMethodA (jobject obj,\n       break;\n     }\n \n+  void *ncode;\n+\n+  if (is_virtual_call)\n+    {\n+      _Jv_VTable *vtable = *(_Jv_VTable **) obj;\n+      ncode = vtable->get_method (meth->index);\n+    }\n+  else\n+    {\n+      ncode = meth->ncode;\n+    }\n+\n   try\n     {\n-      ffi_call (&cif, (void (*)()) meth->ncode, &ffi_result, values);\n+      ffi_call (&cif, (void (*)()) ncode, &ffi_result, values);\n     }\n   catch (Throwable *ex)\n     {\n@@ -599,6 +608,7 @@ _Jv_CallAnyMethodA (jobject obj,\n \n   jvalue ret_value;\n   _Jv_CallAnyMethodA (obj, return_type, meth, is_constructor,\n+  \t\t      _Jv_isVirtualMethod (meth),\n \t\t      parameter_types, argvals, &ret_value,\n \t\t      false);\n "}, {"sha": "e2e10defd0a8cfefe4b2be6c3c9c7b92dd381632", "filename": "libjava/jni.cc", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9b5672b49c02abf4eb9ee7a41268676975fe8dd/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=b9b5672b49c02abf4eb9ee7a41268676975fe8dd", "patch": "@@ -767,9 +767,6 @@ static T\n   obj = unwrap (obj);\n   klass = unwrap (klass);\n \n-  if (style == normal)\n-    id = _Jv_LookupDeclaredMethod (obj->getClass (), id->name, id->signature);\n-\n   jclass decl_class = klass ? klass : obj->getClass ();\n   JvAssert (decl_class != NULL);\n \n@@ -791,6 +788,7 @@ static T\n       jvalue result;\n       _Jv_CallAnyMethodA (obj, return_type, id,\n \t\t\t  style == constructor,\n+\t\t\t  style == normal,\n \t\t\t  arg_types, args, &result);\n \n       return wrap_value (env, extract_from_jvalue<T>(result));\n@@ -826,9 +824,6 @@ static T\n   obj = unwrap (obj);\n   klass = unwrap (klass);\n \n-  if (style == normal)\n-    id = _Jv_LookupDeclaredMethod (obj->getClass (), id->name, id->signature);\n-\n   jclass decl_class = klass ? klass : obj->getClass ();\n   JvAssert (decl_class != NULL);\n \n@@ -857,6 +852,7 @@ static T\n       jvalue result;\n       _Jv_CallAnyMethodA (obj, return_type, id,\n \t\t\t  style == constructor,\n+\t\t\t  style == normal,\n \t\t\t  arg_types, arg_copy, &result);\n \n       return wrap_value (env, extract_from_jvalue<T>(result));\n@@ -877,9 +873,6 @@ static void\n   obj = unwrap (obj);\n   klass = unwrap (klass);\n \n-  if (style == normal)\n-    id = _Jv_LookupDeclaredMethod (obj->getClass (), id->name, id->signature);\n-\n   jclass decl_class = klass ? klass : obj->getClass ();\n   JvAssert (decl_class != NULL);\n \n@@ -899,6 +892,7 @@ static void\n \n       _Jv_CallAnyMethodA (obj, return_type, id,\n \t\t\t  style == constructor,\n+\t\t\t  style == normal,\n \t\t\t  arg_types, args, NULL);\n     }\n   catch (jthrowable t)\n@@ -924,9 +918,6 @@ static void\n (JNICALL _Jv_JNI_CallAnyVoidMethodA) (JNIEnv *env, jobject obj, jclass klass,\n \t\t\t              jmethodID id, jvalue *args)\n {\n-  if (style == normal)\n-    id = _Jv_LookupDeclaredMethod (obj->getClass (), id->name, id->signature);\n-\n   jclass decl_class = klass ? klass : obj->getClass ();\n   JvAssert (decl_class != NULL);\n \n@@ -950,6 +941,7 @@ static void\n \n       _Jv_CallAnyMethodA (obj, return_type, id,\n \t\t\t  style == constructor,\n+\t\t\t  style == normal,\n \t\t\t  arg_types, args, NULL);\n     }\n   catch (jthrowable t)"}]}