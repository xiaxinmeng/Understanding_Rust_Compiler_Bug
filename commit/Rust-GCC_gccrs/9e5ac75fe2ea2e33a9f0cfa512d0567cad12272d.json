{"sha": "9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU1YWM3NWZlMmVhMmUzM2E5ZjBjZmE1MTJkMDU2N2NhZDEyMjcyZA==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2006-10-31T17:54:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:54:50Z"}, "message": "exp_ch5.ads (Expand_N_Extended_Return_Statement): New procedure.\n\n2006-10-31  Bob Duff  <duff@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.ads (Expand_N_Extended_Return_Statement): New procedure.\n\n        * exp_ch5.adb (Expand_N_Loop_Statement): Do validity checks on range\n\t(Expand_N_Assignment_Statement): Call\n\tMake_Build_In_Place_Call_In_Assignment if the right-hand side is a\n\tbuild-in-place function call. Currently, this can happen only for\n\tassignments that come from aggregates.\n\tAdd -gnatd.l --Use Ada 95 semantics for limited function returns,\n\tin order to alleviate the upward compatibility introduced by AI-318.\n\t(Expand_N_Extended_Return_Statement): Add support for handling the\n\treturn object as a build-in-place result.\n\t(Expand_Non_Function_Return): Implement simple return statements nested\n\twithin an extended return.\n\t(Enable_New_Return_Processing): Turn on the new processing of return\n\tstatements.\n\t(Expand_Non_Function_Return): For a return within an extended return,\n\tdon't raise Program_Error, because Sem_Ch6 now gives a warning.\n\t(Expand_N_Extended_Return_Statement): Implement AI-318\n\t(Expand_Simple_Function_Return): Ditto.\n\t(Expand_N_If_Statement): Handle new -gnatwt warning\n\t(Expand_N_Case_Statement): Handle new -gnatwt warning\n\t(Expand_N_Assignment): Handle assignment to the Priority attribute of\n\ta protected object.\n\t(Expand_N_Assignment_Statement): Implement -gnatVe/E to control\n\tvalidity checking of assignments to elementary record components.\n\t(Expand_N_Return_Statement): return Class Wide types on the secondary\n\tstack independantly of their controlled status since with HIE runtimes,\n\tclass wide types are not potentially controlled anymore.\n\n\t* expander.adb (Expand): Add case for new N_Extended_Return_Statement\n\tnode kind.\n\n\t* exp_ch11.adb (Expand_N_Handled_Sequence_Of_Statements): Avoid\n\tExpand_Cleanup_Actions in case of N_Extended_Return_Statement, because\n\tit expects a block, procedure, or task. The return statement will get\n\tturned into a block, and Expand_Cleanup_Actions will happen then.\n\nFrom-SVN: r118258", "tree": {"sha": "739ad4aa947a7e50224a09d6456a53c48457b96d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/739ad4aa947a7e50224a09d6456a53c48457b96d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "20b5d666e7c8f05951fa54942a24174e600f8884", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20b5d666e7c8f05951fa54942a24174e600f8884", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20b5d666e7c8f05951fa54942a24174e600f8884"}], "stats": {"total": 1402, "additions": 1278, "deletions": 124}, "files": [{"sha": "2312f504dd773541254ae3925baeed236a1931b9", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -485,6 +485,7 @@ package body Exp_Ch11 is\n \n       if Nkind (Parent (N)) /= N_Package_Body\n         and then Nkind (Parent (N)) /= N_Accept_Statement\n+        and then Nkind (Parent (N)) /= N_Extended_Return_Statement\n         and then not Delay_Cleanups (Current_Scope)\n       then\n          Expand_Cleanup_Actions (Parent (N));"}, {"sha": "7410db22552367912cb2d7a2e9e603a71132fc15", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 1263, "deletions": 114, "changes": 1377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d", "patch": "@@ -26,9 +26,11 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Exp_Aggr; use Exp_Aggr;\n+with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Dbug; use Exp_Dbug;\n@@ -45,7 +47,6 @@ with Rtsfind;  use Rtsfind;\n with Sinfo;    use Sinfo;\n with Sem;      use Sem;\n with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch5;  use Sem_Ch5;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n@@ -61,6 +62,12 @@ with Validsw;  use Validsw;\n \n package body Exp_Ch5 is\n \n+   Enable_New_Return_Processing : constant Boolean := True;\n+   --  ??? This flag is temporary. False causes the compiler to use the old\n+   --  version of Analyze_Return_Statement; True, the new version, which does\n+   --  not yet work. We probably want this to match the corresponding thing\n+   --  in sem_ch6.adb.\n+\n    function Change_Of_Representation (N : Node_Id) return Boolean;\n    --  Determine if the right hand side of the assignment N is a type\n    --  conversion which requires a change of representation. Called\n@@ -100,13 +107,30 @@ package body Exp_Ch5 is\n    --  either because the target is not byte aligned, or there is a change\n    --  of representation.\n \n+   procedure Expand_Non_Function_Return (N : Node_Id);\n+   --  Called by Expand_Simple_Return in case we're returning from a procedure\n+   --  body, entry body, accept statement, or extended returns statement.\n+   --  Note that all non-function returns are simple return statements.\n+\n+   procedure Expand_Simple_Function_Return (N : Node_Id);\n+   --  Expand simple return from function. Called by Expand_Simple_Return in\n+   --  case we're returning from a function body.\n+\n+   procedure Expand_Simple_Return (N : Node_Id);\n+   --  Expansion for simple return statements. Calls either\n+   --  Expand_Simple_Function_Return or Expand_Non_Function_Return.\n+\n    function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id;\n    --  Generate the necessary code for controlled and tagged assignment,\n    --  that is to say, finalization of the target before, adjustement of\n    --  the target after and save and restore of the tag and finalization\n    --  pointers which are not 'part of the value' and must not be changed\n    --  upon assignment. N is the original Assignment node.\n \n+   procedure No_Secondary_Stack_Case (N : Node_Id);\n+   --  Obsolete code to deal with functions for which\n+   --  Function_Returns_With_DSP is True.\n+\n    function Possible_Bit_Aligned_Component (N : Node_Id) return Boolean;\n    --  This function is used in processing the assignment of a record or\n    --  indexed component. The argument N is either the left hand or right\n@@ -382,9 +406,9 @@ package body Exp_Ch5 is\n \n          --  A formal parameter reference with an unconstrained bit\n          --  array type is the other case we need to worry about (here\n-         --  we assume the same BITS type declared above:\n+         --  we assume the same BITS type declared above):\n \n-         --    procedure Write_All (File : out BITS; Contents : in  BITS);\n+         --    procedure Write_All (File : out BITS; Contents : BITS);\n          --    begin\n          --       File.Storage := Contents;\n          --    end Write_All;\n@@ -1375,8 +1399,102 @@ package body Exp_Ch5 is\n       Exp  : Node_Id;\n \n    begin\n-      --  First deal with generation of range check if required. For now\n-      --  we do this only for discrete types.\n+      --  Ada 2005 (AI-327): Handle assignment to priority of protected object\n+\n+      --  Rewrite an assignment to X'Priority into a run-time call.\n+\n+      --   For example:         X'Priority := New_Prio_Expr;\n+      --   ...is expanded into  Set_Ceiling (X._Object, New_Prio_Expr);\n+\n+      --  Note that although X'Priority is notionally an object, it is quite\n+      --  deliberately not defined as an aliased object in the RM. This means\n+      --  that it works fine to rewrite it as a call, without having to worry\n+      --  about complications that would other arise from X'Priority'Access,\n+      --  which is illegal, because of the lack of aliasing.\n+\n+      if Ada_Version >= Ada_05 then\n+         declare\n+            Call           : Node_Id;\n+            Conctyp        : Entity_Id;\n+            Ent            : Entity_Id;\n+            Object_Parm    : Node_Id;\n+            Subprg         : Entity_Id;\n+            RT_Subprg_Name : Node_Id;\n+\n+         begin\n+            --  Handle chains of renamings\n+\n+            Ent := Name (N);\n+            while Nkind (Ent) in N_Has_Entity\n+              and then Present (Entity (Ent))\n+              and then Present (Renamed_Object (Entity (Ent)))\n+            loop\n+               Ent := Renamed_Object (Entity (Ent));\n+            end loop;\n+\n+            --  The attribute Priority applied to protected objects has been\n+            --  previously expanded into calls to the Get_Ceiling run-time\n+            --  subprogram.\n+\n+            if Nkind (Ent) = N_Function_Call\n+              and then (Entity (Name (Ent)) = RTE (RE_Get_Ceiling)\n+                          or else\n+                        Entity (Name (Ent)) = RTE (RO_PE_Get_Ceiling))\n+            then\n+               --  Look for the enclosing concurrent type\n+\n+               Conctyp := Current_Scope;\n+               while not Is_Concurrent_Type (Conctyp) loop\n+                  Conctyp := Scope (Conctyp);\n+               end loop;\n+\n+               pragma Assert (Is_Protected_Type (Conctyp));\n+\n+               --  Generate the first actual of the call\n+\n+               Subprg := Current_Scope;\n+               while not Present (Protected_Body_Subprogram (Subprg)) loop\n+                  Subprg := Scope (Subprg);\n+               end loop;\n+\n+               Object_Parm :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix => New_Reference_To\n+                                   (First_Entity\n+                                     (Protected_Body_Subprogram (Subprg)),\n+                                    Loc),\n+                     Selector_Name =>\n+                       Make_Identifier (Loc, Name_uObject)),\n+                   Attribute_Name => Name_Unchecked_Access);\n+\n+               --  Select the appropriate run-time call\n+\n+               if Number_Entries (Conctyp) = 0 then\n+                  RT_Subprg_Name :=\n+                    New_Reference_To (RTE (RE_Set_Ceiling), Loc);\n+               else\n+                  RT_Subprg_Name :=\n+                    New_Reference_To (RTE (RO_PE_Set_Ceiling), Loc);\n+               end if;\n+\n+               Call :=\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => RT_Subprg_Name,\n+                   Parameter_Associations =>\n+                     New_List (Object_Parm,\n+                               Relocate_Node (Expression (N))));\n+\n+               Rewrite (N, Call);\n+               Analyze (N);\n+               return;\n+            end if;\n+         end;\n+      end if;\n+\n+      --  First deal with generation of range check if required. For now we do\n+      --  this only for discrete types.\n \n       if Do_Range_Check (Rhs)\n         and then Is_Discrete_Type (Typ)\n@@ -1639,6 +1757,15 @@ package body Exp_Ch5 is\n          Expand_Bit_Packed_Element_Set (N);\n          return;\n \n+      --  Build-in-place function call case. Note that we're not yet doing\n+      --  build-in-place for user-written assignment statements; the\n+      --  assignment here came from can aggregate.\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Is_Build_In_Place_Function_Call (Rhs)\n+      then\n+         Make_Build_In_Place_Call_In_Assignment (N, Rhs);\n+\n       elsif Is_Tagged_Type (Typ)\n         or else (Controlled_Type (Typ) and then not Is_Array_Type (Typ))\n       then\n@@ -1897,9 +2024,20 @@ package body Exp_Ch5 is\n             --  Validate right side if we are validating copies\n \n             if Validity_Checks_On\n-               and then Validity_Check_Copies\n+              and then Validity_Check_Copies\n             then\n-               Ensure_Valid (Rhs);\n+               --  Skip this if left hand side is an array or record component\n+               --  and elementary component validity checks are suppressed.\n+\n+               if (Nkind (Lhs) = N_Selected_Component\n+                    or else\n+                   Nkind (Lhs) = N_Indexed_Component)\n+                 and then not Validity_Check_Components\n+               then\n+                  null;\n+               else\n+                  Ensure_Valid (Rhs);\n+               end if;\n \n                --  We can propagate this to the left side where appropriate\n \n@@ -1999,12 +2137,30 @@ package body Exp_Ch5 is\n \n          Insert_List_After (N, Statements (Alt));\n \n-         --  That leaves the case statement as a shell. The alternative\n-         --  that will be executed is reset to a null list. So now we can\n-         --  kill the entire case statement.\n+         --  That leaves the case statement as a shell. So now we can kill all\n+         --  other alternatives in the case statement.\n \n          Kill_Dead_Code (Expression (N));\n-         Kill_Dead_Code (Alternatives (N));\n+\n+         declare\n+            A : Node_Id;\n+\n+         begin\n+            --  Loop through case alternatives, skipping pragmas, and skipping\n+            --  the one alternative that we select (and therefore retain).\n+\n+            A := First (Alternatives (N));\n+            while Present (A) loop\n+               if A /= Alt\n+                 and then Nkind (A) = N_Case_Statement_Alternative\n+               then\n+                  Kill_Dead_Code (Statements (A), Warn_On_Deleted_Code);\n+               end if;\n+\n+               Next (A);\n+            end loop;\n+         end;\n+\n          Rewrite (N, Make_Null_Statement (Loc));\n          return;\n       end if;\n@@ -2163,6 +2319,294 @@ package body Exp_Ch5 is\n       Adjust_Condition (Condition (N));\n    end Expand_N_Exit_Statement;\n \n+   ----------------------------------------\n+   -- Expand_N_Extended_Return_Statement --\n+   ----------------------------------------\n+\n+   --  If there is a Handled_Statement_Sequence, we rewrite this:\n+\n+   --     return Result : T := <expression> do\n+   --        <handled_seq_of_stms>\n+   --     end return;\n+\n+   --  to be:\n+\n+   --     declare\n+   --        Result : T := <expression>;\n+   --     begin\n+   --        <handled_seq_of_stms>\n+   --        return Result;\n+   --     end;\n+\n+   --  Otherwise (no Handled_Statement_Sequence), we rewrite this:\n+\n+   --     return Result : T := <expression>;\n+\n+   --  to be:\n+\n+   --     return <expression>;\n+\n+   --  unless it's build-in-place or there's no <expression>, in which case\n+   --  we generate:\n+\n+   --     declare\n+   --        Result : T := <expression>;\n+   --     begin\n+   --        return Result;\n+   --     end;\n+\n+   --  Note that this case could have been written by the user as an extended\n+   --  return statement, or could have been transformed to this from a simple\n+   --  return statement.\n+\n+   --  That is, we need to have a reified return object if there are statements\n+   --  (which might refer to it) or if we're doing build-in-place (so we can\n+   --  set its address to the final resting place -- but that key part is not\n+   --  yet implemented) or if there is no expression (in which case default\n+   --  initial values might need to be set).\n+\n+   procedure Expand_N_Extended_Return_Statement (N : Node_Id) is\n+\n+      function Is_Build_In_Place_Function (Fun : Entity_Id) return Boolean;\n+      --  F must be of type E_Function or E_Generic_Function. Return True if it\n+      --  uses build-in-place for the result object. In Ada 95, this must be\n+      --  False for inherently limited result type. In Ada 2005, this must be\n+      --  True for inherently limited result type. For other types, we have a\n+      --  choice -- build-in-place is usually more efficient for large things,\n+      --  and less efficient for small things. However, we had better not use\n+      --  build-in-place if the Convention is other than Ada, because that\n+      --  would disturb mixed-language programs.\n+      --\n+      --  Note that for the non-inherently-limited cases, we must make the same\n+      --  decision for Ada 95 and 2005, so that mixed-dialect programs work.\n+      --\n+      --  ???This function will be needed when compiling the call sites;\n+      --  we will have to move it to a more global place.\n+\n+      --------------------------------\n+      -- Is_Build_In_Place_Function --\n+      --------------------------------\n+\n+      function Is_Build_In_Place_Function (Fun : Entity_Id) return Boolean is\n+         R_Type : constant Entity_Id := Underlying_Type (Etype (Fun));\n+\n+      begin\n+         --  First, the cases that matter for correctness\n+\n+         if Is_Inherently_Limited_Type (R_Type) then\n+            return Ada_Version >= Ada_05 and then not Debug_Flag_Dot_L;\n+\n+            --  Note: If you have Convention (C) on an inherently limited\n+            --  type, you're on your own. That is, the C code will have to be\n+            --  carefully written to know about the Ada conventions.\n+\n+         elsif\n+           Has_Foreign_Convention (R_Type)\n+             or else\n+           Has_Foreign_Convention (Fun)\n+         then\n+            return False;\n+\n+         --  Second, the efficiency-related decisions. It would be obnoxiously\n+         --  inefficient to use build-in-place for elementary types. For\n+         --  composites, we could return False if the subtype is known to be\n+         --  small (<= one or two words?) but we don't bother with that yet.\n+\n+         else\n+            return Is_Composite_Type (R_Type);\n+         end if;\n+      end Is_Build_In_Place_Function;\n+\n+      ------------------------\n+      -- Local Declarations --\n+      ------------------------\n+\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Return_Object_Entity : constant Entity_Id :=\n+                               First_Entity (Return_Statement_Entity (N));\n+      Return_Object_Decl   : constant Node_Id :=\n+                               Parent (Return_Object_Entity);\n+      Parent_Function      : constant Entity_Id :=\n+                               Return_Applies_To (Return_Statement_Entity (N));\n+      Is_Build_In_Place    : constant Boolean :=\n+                               Is_Build_In_Place_Function (Parent_Function);\n+\n+      Return_Stm      : Node_Id;\n+      Handled_Stm_Seq : Node_Id;\n+      Result          : Node_Id;\n+      Exp             : Node_Id;\n+\n+   --  Start of processing for Expand_N_Extended_Return_Statement\n+\n+   begin\n+      if Nkind (Return_Object_Decl) = N_Object_Declaration then\n+         Exp := Expression (Return_Object_Decl);\n+      else\n+         Exp := Empty;\n+      end if;\n+\n+      Handled_Stm_Seq := Handled_Statement_Sequence (N);\n+\n+      if Present (Handled_Stm_Seq)\n+        or else Is_Build_In_Place\n+        or else No (Exp)\n+      then\n+         --  Build simple_return_statement that returns the return object\n+\n+         Return_Stm :=\n+           Make_Return_Statement (Loc,\n+             Expression => New_Occurrence_Of (Return_Object_Entity, Loc));\n+\n+         if Present (Handled_Stm_Seq) then\n+            Handled_Stm_Seq :=\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => New_List (Handled_Stm_Seq, Return_Stm));\n+         else\n+            Handled_Stm_Seq :=\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => New_List (Return_Stm));\n+         end if;\n+\n+         pragma Assert (Present (Handled_Stm_Seq));\n+      end if;\n+\n+      --  Case where we build a block\n+\n+      if Present (Handled_Stm_Seq) then\n+         Result :=\n+           Make_Block_Statement (Loc,\n+             Declarations => Return_Object_Declarations (N),\n+             Handled_Statement_Sequence => Handled_Stm_Seq);\n+\n+         if Is_Build_In_Place then\n+\n+            --  Locate the implicit access parameter associated with the\n+            --  the caller-supplied return object and convert the return\n+            --  statement's return object declaration to a renaming of a\n+            --  dereference of the access parameter. If the return object's\n+            --  declaration includes an expression that has not already been\n+            --  expanded as separate assignments, then add an assignment\n+            --  statement to ensure the return object gets initialized.\n+\n+            --  declare\n+            --     Result : T [:= <expression>];\n+            --  begin\n+            --     ...\n+\n+            --  is converted to\n+\n+            --  declare\n+            --     Result : T renames FuncRA.all;\n+            --     [Result := <expression;]\n+            --  begin\n+            --     ...\n+\n+            declare\n+               Return_Obj_Id   : constant Entity_Id :=\n+                                   Defining_Identifier (Return_Object_Decl);\n+               Return_Obj_Typ  : constant Entity_Id := Etype (Return_Obj_Id);\n+               Return_Obj_Expr : constant Node_Id :=\n+                                   Expression (Return_Object_Decl);\n+               Obj_Acc_Formal  : Entity_Id := Extra_Formals (Parent_Function);\n+               Obj_Acc_Deref   : Node_Id;\n+               Init_Assignment : Node_Id;\n+\n+            begin\n+               --  Build-in-place results must be returned by reference\n+\n+               Set_By_Ref (Return_Stm);\n+\n+               --  Locate the implicit access parameter passed by the caller.\n+               --  It might be better to search for that with a symbol table\n+               --  lookup, but for now we traverse the extra actuals to find\n+               --  the access parameter (currently there can only be one).\n+\n+               while Present (Obj_Acc_Formal) loop\n+                  exit when\n+                    Ekind (Etype (Obj_Acc_Formal)) = E_Anonymous_Access_Type;\n+                  Next_Formal_With_Extras (Obj_Acc_Formal);\n+               end loop;\n+\n+               --  ??? pragma Assert (Present (Obj_Acc_Formal));\n+\n+               --  For now we only rewrite the object if we can locate the\n+               --  implicit access parameter. Normally there should be one\n+               --  if Build_In_Place is true, but at the moment it's only\n+               --  created in the more restrictive case of constrained\n+               --  inherently limited result subtypes. ???\n+\n+               if Present (Obj_Acc_Formal) then\n+\n+                  --  If the return object's declaration includes an expression\n+                  --  and the declaration isn't marked as No_Initialization,\n+                  --  then we need to generate an assignment to the object and\n+                  --  insert it after the declaration before rewriting it as\n+                  --  a renaming (otherwise we'll lose the initialization).\n+\n+                  if Present (Return_Obj_Expr)\n+                    and then not No_Initialization (Return_Object_Decl)\n+                  then\n+                     Init_Assignment :=\n+                       Make_Assignment_Statement (Loc,\n+                         Name       => New_Reference_To (Return_Obj_Id, Loc),\n+                         Expression => Relocate_Node (Return_Obj_Expr));\n+                     Set_Assignment_OK (Name (Init_Assignment));\n+                     Set_No_Ctrl_Actions (Init_Assignment);\n+\n+                     --  ??? Should we be setting the parent of the expression\n+                     --  here?\n+                     --  Set_Parent\n+                     --    (Expression (Init_Assignment), Init_Assignment);\n+\n+                     Set_Expression (Return_Object_Decl, Empty);\n+\n+                     Insert_After (Return_Object_Decl, Init_Assignment);\n+                  end if;\n+\n+                  --  Replace the return object declaration with a renaming\n+                  --  of a dereference of the implicit access formal.\n+\n+                  Obj_Acc_Deref :=\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix => New_Reference_To (Obj_Acc_Formal, Loc));\n+\n+                  Rewrite (Return_Object_Decl,\n+                    Make_Object_Renaming_Declaration (Loc,\n+                      Defining_Identifier => Return_Obj_Id,\n+                      Access_Definition   => Empty,\n+                      Subtype_Mark        => New_Occurrence_Of\n+                                               (Return_Obj_Typ, Loc),\n+                      Name                => Obj_Acc_Deref));\n+\n+                  Set_Renamed_Object (Return_Obj_Id, Obj_Acc_Deref);\n+               end if;\n+            end;\n+         end if;\n+\n+      --  Case where we do not build a block\n+\n+      else\n+         --  We're about to drop Return_Object_Declarations on the floor, so\n+         --  we need to insert it, in case it got expanded into useful code.\n+\n+         Insert_List_Before (N, Return_Object_Declarations (N));\n+\n+         --  Build simple_return_statement that returns the expression directly\n+\n+         Return_Stm := Make_Return_Statement (Loc, Expression => Exp);\n+\n+         Result := Return_Stm;\n+      end if;\n+\n+      --  Set the flag to prevent infinite recursion\n+\n+      Set_Comes_From_Extended_Return_Statement (Return_Stm);\n+\n+      Rewrite (N, Result);\n+      Analyze (N);\n+   end Expand_N_Extended_Return_Statement;\n+\n    -----------------------------\n    -- Expand_N_Goto_Statement --\n    -----------------------------\n@@ -2231,8 +2675,8 @@ package body Exp_Ch5 is\n \n             --  All the else parts can be killed\n \n-            Kill_Dead_Code (Elsif_Parts (N));\n-            Kill_Dead_Code (Else_Statements (N));\n+            Kill_Dead_Code (Elsif_Parts (N), Warn_On_Deleted_Code);\n+            Kill_Dead_Code (Else_Statements (N), Warn_On_Deleted_Code);\n \n             Hed := Remove_Head (Then_Statements (N));\n             Insert_List_After (N, Then_Statements (N));\n@@ -2252,19 +2696,17 @@ package body Exp_Ch5 is\n                Kill_Dead_Code (Condition (N));\n             end if;\n \n-            Kill_Dead_Code (Then_Statements (N));\n+            Kill_Dead_Code (Then_Statements (N), Warn_On_Deleted_Code);\n \n             --  If there are no elsif statements, then we simply replace\n             --  the entire if statement by the sequence of else statements.\n \n             if No (Elsif_Parts (N)) then\n-\n                if No (Else_Statements (N))\n                  or else Is_Empty_List (Else_Statements (N))\n                then\n                   Rewrite (N,\n                     Make_Null_Statement (Sloc (N)));\n-\n                else\n                   Hed := Remove_Head (Else_Statements (N));\n                   Insert_List_After (N, Else_Statements (N));\n@@ -2288,7 +2730,7 @@ package body Exp_Ch5 is\n                --  the tree, so a Current_Value pointer in the condition might\n                --  need to be updated.\n \n-               Check_Possible_Current_Value_Condition (N);\n+               Set_Current_Value_Condition (N);\n \n                if Is_Empty_List (Elsif_Parts (N)) then\n                   Set_Elsif_Parts (N, No_List);\n@@ -2461,10 +2903,16 @@ package body Exp_Ch5 is\n          Generate_Poll_Call (First (Statements (N)));\n       end if;\n \n+      --  Nothing more to do for plain loop with no iteration scheme\n+\n       if No (Isc) then\n          return;\n       end if;\n \n+      --  Note: we do not have to worry about validity chekcing of the for loop\n+      --  range bounds here, since they were frozen with constant declarations\n+      --  and it is during that process that the validity checking is done.\n+\n       --  Handle the case where we have a for loop with the range type being\n       --  an enumeration type with non-standard representation. In this case\n       --  we expand:\n@@ -2655,6 +3103,11 @@ package body Exp_Ch5 is\n       Result_Obj  : Node_Id;\n \n    begin\n+      if Enable_New_Return_Processing then --  ???Temporary hack\n+         Expand_Simple_Return (N);\n+         return;\n+      end if;\n+\n       --  Case where returned expression is present\n \n       if Present (Exp) then\n@@ -2699,6 +3152,9 @@ package body Exp_Ch5 is\n             pragma Assert (Cur_Idx >= 0);\n          end if;\n       end loop;\n+      --  ???I believe the above code is no longer necessary\n+      pragma Assert (Scope_Id =\n+                       Return_Applies_To (Return_Statement_Entity (N)));\n \n       if No (Exp) then\n          Kind := Ekind (Scope_Id);\n@@ -2772,7 +3228,6 @@ package body Exp_Ch5 is\n \n             Insert_Before (N, Call);\n             Analyze (Call);\n-\n          end if;\n \n          return;\n@@ -2782,11 +3237,10 @@ package body Exp_Ch5 is\n       Return_Type := Etype (Scope_Id);\n       Utyp := Underlying_Type (Return_Type);\n \n-      --  Check the result expression of a scalar function against\n-      --  the subtype of the function by inserting a conversion.\n-      --  This conversion must eventually be performed for other\n-      --  classes of types, but for now it's only done for scalars.\n-      --  ???\n+      --  Check the result expression of a scalar function against the subtype\n+      --  of the function by inserting a conversion. This conversion must\n+      --  eventually be performed for other classes of types, but for now it's\n+      --  only done for scalars. ???\n \n       if Is_Scalar_Type (T) then\n          Rewrite (Exp, Convert_To (Return_Type, Exp));\n@@ -2795,24 +3249,25 @@ package body Exp_Ch5 is\n \n       --  Deal with returning variable length objects and controlled types\n \n-      --  Nothing to do if we are returning by reference, or this is not\n-      --  a type that requires special processing (indicated by the fact\n-      --  that it requires a cleanup scope for the secondary stack case).\n+      --  Nothing to do if we are returning by reference, or this is not a\n+      --  type that requires special processing (indicated by the fact that\n+      --  it requires a cleanup scope for the secondary stack case).\n \n-      if Is_Return_By_Reference_Type (T) then\n+      if Is_Inherently_Limited_Type (T) then\n          null;\n \n       elsif not Requires_Transient_Scope (Return_Type) then\n \n          --  Mutable records with no variable length components are not\n-         --  returned on the sec-stack so we need to make sure that the\n-         --  backend will only copy back the size of the actual value  and not\n-         --  the maximum size. We create an actual subtype for this purpose\n+         --  returned on the sec-stack, so we need to make sure that the\n+         --  backend will only copy back the size of the actual value, and not\n+         --  the maximum size. We create an actual subtype for this purpose.\n \n          declare\n             Ubt  : constant Entity_Id := Underlying_Type (Base_Type (T));\n             Decl : Node_Id;\n             Ent  : Entity_Id;\n+\n          begin\n             if Has_Discriminants (Ubt)\n               and then not Is_Constrained (Ubt)\n@@ -2821,14 +3276,23 @@ package body Exp_Ch5 is\n                Decl := Build_Actual_Subtype (Ubt, Exp);\n                Ent := Defining_Identifier (Decl);\n                Insert_Action (Exp, Decl);\n+\n                Rewrite (Exp, Unchecked_Convert_To (Ent, Exp));\n+               Analyze_And_Resolve (Exp);\n             end if;\n          end;\n \n       --  Case of secondary stack not used\n \n       elsif Function_Returns_With_DSP (Scope_Id) then\n \n+         --  The DSP method is no longer in use. We would like to ignore DSP\n+         --  while implementing AI-318; hence the raise below.\n+\n+         if True then\n+            raise Program_Error;\n+         end if;\n+\n          --  Here what we need to do is to always return by reference, since\n          --  we will return with the stack pointer depressed. We may need to\n          --  do a copy to a local temporary before doing this return.\n@@ -2973,11 +3437,11 @@ package body Exp_Ch5 is\n       --  Here if secondary stack is used\n \n       else\n-         --  Make sure that no surrounding block will reclaim the\n-         --  secondary-stack on which we are going to put the result.\n-         --  Not only may this introduce secondary stack leaks but worse,\n-         --  if the reclamation is done too early, then the result we are\n-         --  returning may get clobbered. See example in 7417-003.\n+         --  Make sure that no surrounding block will reclaim the secondary\n+         --  stack on which we are going to put the result. Not only may this\n+         --  introduce secondary stack leaks but worse, if the reclamation is\n+         --  done too early, then the result we are returning may get\n+         --  clobbered. See example in 7417-003.\n \n          declare\n             S : Entity_Id := Current_Scope;\n@@ -3004,6 +3468,7 @@ package body Exp_Ch5 is\n            and then\n               (not Is_Array_Type (T)\n                 or else Is_Constrained (T) = Is_Constrained (Return_Type)\n+                or else Is_Class_Wide_Type (Utyp)\n                 or else Controlled_Type (T))\n            and then Nkind (Exp) = N_Function_Call\n          then\n@@ -3015,14 +3480,19 @@ package body Exp_Ch5 is\n \n             Rewrite (Exp, Duplicate_Subexpr_No_Checks (Exp));\n \n-         --  For controlled types, do the allocation on the sec-stack\n-         --  manually in order to call adjust at the right time\n+         --  For controlled types, do the allocation on the secondary stack\n+         --  manually in order to call adjust at the right time:\n          --    type Anon1 is access Return_Type;\n          --    for Anon1'Storage_pool use ss_pool;\n          --    Anon2 : anon1 := new Return_Type'(expr);\n          --    return Anon2.all;\n+         --  We do the same for classwide types that are not potentially\n+         --  controlled (by the virtue of restriction No_Finalization) because\n+         --  gigi is not able to properly allocate class-wide types.\n \n-         elsif Controlled_Type (Utyp) then\n+         elsif Is_Class_Wide_Type (Utyp)\n+           or else Controlled_Type (Utyp)\n+         then\n             declare\n                Loc        : constant Source_Ptr := Sloc (N);\n                Temp       : constant Entity_Id :=\n@@ -3191,102 +3661,626 @@ package body Exp_Ch5 is\n          return;\n    end Expand_N_Return_Statement;\n \n-   ------------------------------\n-   -- Make_Tag_Ctrl_Assignment --\n-   ------------------------------\n-\n-   function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id is\n-      Loc : constant Source_Ptr := Sloc (N);\n-      L   : constant Node_Id    := Name (N);\n-      T   : constant Entity_Id  := Underlying_Type (Etype (L));\n-\n-      Ctrl_Act : constant Boolean := Controlled_Type (T)\n-                                       and then not No_Ctrl_Actions (N);\n+   --------------------------------\n+   -- Expand_Non_Function_Return --\n+   --------------------------------\n \n-      Save_Tag : constant Boolean := Is_Tagged_Type (T)\n-                                       and then not No_Ctrl_Actions (N)\n-                                       and then not Java_VM;\n-      --  Tags are not saved and restored when Java_VM because JVM tags\n-      --  are represented implicitly in objects.\n+   procedure Expand_Non_Function_Return (N : Node_Id) is\n+      pragma Assert (No (Expression (N)));\n \n-      Res       : List_Id;\n-      Tag_Tmp   : Entity_Id;\n+      Loc         : constant Source_Ptr := Sloc (N);\n+      Scope_Id    : Entity_Id :=\n+                      Return_Applies_To (Return_Statement_Entity (N));\n+      Kind        : constant Entity_Kind := Ekind (Scope_Id);\n+      Call        : Node_Id;\n+      Acc_Stat    : Node_Id;\n+      Goto_Stat   : Node_Id;\n+      Lab_Node    : Node_Id;\n \n    begin\n-      Res := New_List;\n+      --  If it is a return from procedures do no extra steps\n \n-      --  Finalize the target of the assignment when controlled.\n-      --  We have two exceptions here:\n+      if Kind = E_Procedure or else Kind = E_Generic_Procedure then\n+         return;\n \n-      --   1. If we are in an init proc since it is an initialization\n-      --      more than an assignment\n+      --  If it is a nested return within an extended one, replace it\n+      --  with a return of the previously declared return object.\n \n-      --   2. If the left-hand side is a temporary that was not initialized\n-      --      (or the parent part of a temporary since it is the case in\n-      --      extension aggregates). Such a temporary does not come from\n-      --      source. We must examine the original node for the prefix, because\n-      --      it may be a component of an entry formal, in which case it has\n-      --      been rewritten and does not appear to come from source either.\n+      elsif Kind = E_Return_Statement then\n+         Rewrite (N,\n+           Make_Return_Statement (Loc,\n+             Expression =>\n+               New_Occurrence_Of (First_Entity (Scope_Id), Loc)));\n+         Set_Comes_From_Extended_Return_Statement (N);\n+         Set_Return_Statement_Entity (N, Scope_Id);\n+         Expand_Simple_Function_Return (N);\n+         return;\n+      end if;\n \n-      --  Case of init proc\n+      pragma Assert (Is_Entry (Scope_Id));\n \n-      if not Ctrl_Act then\n-         null;\n+      --  Look at the enclosing block to see whether the return is from\n+      --  an accept statement or an entry body.\n \n-      --  The left hand side is an uninitialized temporary\n+      for J in reverse 0 .. Scope_Stack.Last loop\n+         Scope_Id := Scope_Stack.Table (J).Entity;\n+         exit when Is_Concurrent_Type (Scope_Id);\n+      end loop;\n \n-      elsif Nkind (L) = N_Type_Conversion\n-        and then Is_Entity_Name (Expression (L))\n-        and then No_Initialization (Parent (Entity (Expression (L))))\n-      then\n-         null;\n-      else\n-         Append_List_To (Res,\n-           Make_Final_Call (\n-             Ref         => Duplicate_Subexpr_No_Checks (L),\n-             Typ         => Etype (L),\n-             With_Detach => New_Reference_To (Standard_False, Loc)));\n-      end if;\n+      --  If it is a return from accept statement it is expanded as call to\n+      --  RTS Complete_Rendezvous and a goto to the end of the accept body.\n \n-      --  Save the Tag in a local variable Tag_Tmp\n+      --  (cf : Expand_N_Accept_Statement, Expand_N_Selective_Accept,\n+      --  Expand_N_Accept_Alternative in exp_ch9.adb)\n \n-      if Save_Tag then\n-         Tag_Tmp :=\n-           Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n+      if Is_Task_Type (Scope_Id) then\n \n-         Append_To (Res,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Tag_Tmp,\n-             Object_Definition => New_Reference_To (RTE (RE_Tag), Loc),\n-             Expression =>\n-               Make_Selected_Component (Loc,\n-                 Prefix        => Duplicate_Subexpr_No_Checks (L),\n-                 Selector_Name => New_Reference_To (First_Tag_Component (T),\n-                                                    Loc))));\n+         Call :=\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Reference_To\n+                       (RTE (RE_Complete_Rendezvous), Loc));\n+         Insert_Before (N, Call);\n+         --  why not insert actions here???\n+         Analyze (Call);\n \n-      --  Otherwise Tag_Tmp not used\n+         Acc_Stat := Parent (N);\n+         while Nkind (Acc_Stat) /= N_Accept_Statement loop\n+            Acc_Stat := Parent (Acc_Stat);\n+         end loop;\n \n-      else\n-         Tag_Tmp := Empty;\n-      end if;\n+         Lab_Node := Last (Statements\n+           (Handled_Statement_Sequence (Acc_Stat)));\n \n-      --  Processing for controlled types and types with controlled components\n+         Goto_Stat := Make_Goto_Statement (Loc,\n+           Name => New_Occurrence_Of\n+             (Entity (Identifier (Lab_Node)), Loc));\n \n-      --  Variables of such types contain pointers used to chain them in\n-      --  finalization lists, in addition to user data. These pointers are\n-      --  specific to each object of the type, not to the value being assigned.\n-      --  Thus they need to be left intact during the assignment. We achieve\n-      --  this by constructing a Storage_Array subtype, and by overlaying\n-      --  objects of this type on the source and target of the assignment.\n-      --  The assignment is then rewritten to assignments of slices of these\n-      --  arrays, copying the user data, and leaving the pointers untouched.\n+         Set_Analyzed (Goto_Stat);\n \n-      if Ctrl_Act then\n-         Controlled_Actions : declare\n-            Prev_Ref : Node_Id;\n-            --  A reference to the Prev component of the record controller\n+         Rewrite (N, Goto_Stat);\n+         Analyze (N);\n \n-            First_After_Root : Node_Id := Empty;\n+      --  If it is a return from an entry body, put a Complete_Entry_Body\n+      --  call in front of the return.\n+\n+      elsif Is_Protected_Type (Scope_Id) then\n+         Call :=\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Reference_To\n+               (RTE (RE_Complete_Entry_Body), Loc),\n+             Parameter_Associations => New_List\n+               (Make_Attribute_Reference (Loc,\n+                 Prefix =>\n+                   New_Reference_To\n+                     (Object_Ref\n+                        (Corresponding_Body (Parent (Scope_Id))),\n+                     Loc),\n+                 Attribute_Name => Name_Unchecked_Access)));\n+\n+         Insert_Before (N, Call);\n+         Analyze (Call);\n+      end if;\n+   end Expand_Non_Function_Return;\n+\n+   --------------------------\n+   -- Expand_Simple_Return --\n+   --------------------------\n+\n+   procedure Expand_Simple_Return (N : Node_Id) is\n+   begin\n+      --  Distinguish the function and non-function cases:\n+\n+      case Ekind (Return_Applies_To (Return_Statement_Entity (N))) is\n+\n+         when E_Function          |\n+              E_Generic_Function  =>\n+            Expand_Simple_Function_Return (N);\n+\n+         when E_Procedure         |\n+              E_Generic_Procedure |\n+              E_Entry             |\n+              E_Entry_Family      |\n+              E_Return_Statement =>\n+            Expand_Non_Function_Return (N);\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+\n+   exception\n+      when RE_Not_Available =>\n+         return;\n+   end Expand_Simple_Return;\n+\n+   -----------------------------------\n+   -- Expand_Simple_Function_Return --\n+   -----------------------------------\n+\n+   --  The \"simple\" comes from the syntax rule simple_return_statement.\n+   --  The semantics are not at all simple!\n+\n+   procedure Expand_Simple_Function_Return (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Scope_Id : constant Entity_Id :=\n+                   Return_Applies_To (Return_Statement_Entity (N));\n+      --  The function we are returning from\n+\n+      R_Type : constant Entity_Id := Etype (Scope_Id);\n+      --  The result type of the function\n+\n+      Utyp : constant Entity_Id := Underlying_Type (R_Type);\n+\n+      Exp : constant Node_Id := Expression (N);\n+      pragma Assert (Present (Exp));\n+\n+      Exptyp : constant Entity_Id := Etype (Exp);\n+      --  The type of the expression (not necessarily the same as R_Type)\n+\n+   begin\n+      --  The DSP method is no longer in use\n+\n+      pragma Assert (not Function_Returns_With_DSP (Scope_Id));\n+\n+      --  We rewrite \"return <expression>;\" to be:\n+\n+      --    return _anon_ : <return_subtype> := <expression>\n+\n+      --  The expansion produced by Expand_N_Extended_Return_Statement will\n+      --  contain simple return statements (for example, a block containing a\n+      --  simple return of the return object), which brings us back here with\n+      --  Comes_From_Extended_Return_Statement set. To avoid infinite\n+      --  recursion, we do not transform into an extended return if\n+      --  Comes_From_Extended_Return_Statement is True.\n+\n+      --  The reason for this design is that for Ada 2005 limited returns, we\n+      --  need to reify the return object, so we can build it \"in place\",\n+      --  and we need a block statement to hang finalization and tasking stuff\n+      --  off of.\n+\n+      --  ??? In order to avoid disruption, we avoid translating to extended\n+      --  return except in the cases where we really need to (Ada 2005\n+      --  inherently limited). We would prefer eventually to do this\n+      --  translation in all cases except perhaps for the case of Ada 95\n+      --  inherently limited, in order to fully exercise the code in\n+      --  Expand_N_Extended_Return_Statement, and in order to do\n+      --  build-in-place for efficiency when it is not required.\n+\n+      if not Comes_From_Extended_Return_Statement (N)\n+        and then Is_Inherently_Limited_Type (R_Type) --  ???\n+        and then Ada_Version >= Ada_05 --  ???\n+        and then not Debug_Flag_Dot_L\n+      then\n+         declare\n+            Return_Object_Entity : constant Entity_Id :=\n+                                     Make_Defining_Identifier (Loc,\n+                                       New_Internal_Name ('R'));\n+\n+            Subtype_Ind : constant Node_Id := New_Occurrence_Of (R_Type, Loc);\n+\n+            Obj_Decl : constant Node_Id :=\n+                         Make_Object_Declaration (Loc,\n+                           Defining_Identifier => Return_Object_Entity,\n+                           Object_Definition   => Subtype_Ind,\n+                           Expression          => Exp);\n+\n+            Ext : constant Node_Id := Make_Extended_Return_Statement (Loc,\n+                    Return_Object_Declarations => New_List (Obj_Decl));\n+\n+         begin\n+            Rewrite (N, Ext);\n+            Analyze (N);\n+            return;\n+         end;\n+      end if;\n+\n+      --  Here we have a simple return statement that is part of the expansion\n+      --  of an extended return statement (either written by the user, or\n+      --  generated by the above code).\n+\n+      --  Always normalize C/Fortran boolean result. This is not always\n+      --  necessary, but it seems a good idea to minimize the passing\n+      --  around of non-normalized values, and in any case this handles\n+      --  the processing of barrier functions for protected types, which\n+      --  turn the condition into a return statement.\n+\n+      if Is_Boolean_Type (Exptyp)\n+        and then Nonzero_Is_True (Exptyp)\n+      then\n+         Adjust_Condition (Exp);\n+         Adjust_Result_Type (Exp, Exptyp);\n+      end if;\n+\n+      --  Do validity check if enabled for returns\n+\n+      if Validity_Checks_On\n+        and then Validity_Check_Returns\n+      then\n+         Ensure_Valid (Exp);\n+      end if;\n+\n+      --  Check the result expression of a scalar function against the subtype\n+      --  of the function by inserting a conversion. This conversion must\n+      --  eventually be performed for other classes of types, but for now it's\n+      --  only done for scalars.\n+      --  ???\n+\n+      if Is_Scalar_Type (Exptyp) then\n+         Rewrite (Exp, Convert_To (R_Type, Exp));\n+         Analyze (Exp);\n+      end if;\n+\n+      --  Deal with returning variable length objects and controlled types\n+\n+      --  Nothing to do if we are returning by reference, or this is not a\n+      --  type that requires special processing (indicated by the fact that\n+      --  it requires a cleanup scope for the secondary stack case).\n+\n+      if Is_Inherently_Limited_Type (Exptyp) then\n+         null;\n+\n+      elsif not Requires_Transient_Scope (R_Type) then\n+\n+         --  Mutable records with no variable length components are not\n+         --  returned on the sec-stack, so we need to make sure that the\n+         --  backend will only copy back the size of the actual value, and not\n+         --  the maximum size. We create an actual subtype for this purpose.\n+\n+         declare\n+            Ubt  : constant Entity_Id := Underlying_Type (Base_Type (Exptyp));\n+            Decl : Node_Id;\n+            Ent  : Entity_Id;\n+         begin\n+            if Has_Discriminants (Ubt)\n+              and then not Is_Constrained (Ubt)\n+              and then not Has_Unchecked_Union (Ubt)\n+            then\n+               Decl := Build_Actual_Subtype (Ubt, Exp);\n+               Ent := Defining_Identifier (Decl);\n+               Insert_Action (Exp, Decl);\n+               Rewrite (Exp, Unchecked_Convert_To (Ent, Exp));\n+               Analyze_And_Resolve (Exp);\n+            end if;\n+         end;\n+\n+      --  Case of secondary stack not used\n+\n+      elsif Function_Returns_With_DSP (Scope_Id) then\n+\n+         --  The DSP method is no longer in use. We would like to ignore DSP\n+         --  while implementing AI-318; hence the following assertion. Keep the\n+         --  old code around in case DSP is revived someday.\n+\n+         pragma Assert (False);\n+\n+         No_Secondary_Stack_Case (N);\n+\n+      --  Here if secondary stack is used\n+\n+      else\n+         --  Make sure that no surrounding block will reclaim the secondary\n+         --  stack on which we are going to put the result. Not only may this\n+         --  introduce secondary stack leaks but worse, if the reclamation is\n+         --  done too early, then the result we are returning may get\n+         --  clobbered. See example in 7417-003.\n+\n+         declare\n+            S : Entity_Id;\n+         begin\n+            S := Current_Scope;\n+            while Ekind (S) = E_Block or else Ekind (S) = E_Loop loop\n+               Set_Sec_Stack_Needed_For_Return (S, True);\n+               S := Enclosing_Dynamic_Scope (S);\n+            end loop;\n+         end;\n+\n+         --  Optimize the case where the result is a function call. In this\n+         --  case either the result is already on the secondary stack, or is\n+         --  already being returned with the stack pointer depressed and no\n+         --  further processing is required except to set the By_Ref flag to\n+         --  ensure that gigi does not attempt an extra unnecessary copy.\n+         --  (actually not just unnecessary but harmfully wrong in the case\n+         --  of a controlled type, where gigi does not know how to do a copy).\n+         --  To make up for a gcc 2.8.1 deficiency (???), we perform\n+         --  the copy for array types if the constrained status of the\n+         --  target type is different from that of the expression.\n+\n+         if Requires_Transient_Scope (Exptyp)\n+           and then\n+              (not Is_Array_Type (Exptyp)\n+                or else Is_Constrained (Exptyp) = Is_Constrained (R_Type)\n+                or else Is_Class_Wide_Type (Utyp)\n+                or else Controlled_Type (Exptyp))\n+           and then Nkind (Exp) = N_Function_Call\n+         then\n+            Set_By_Ref (N);\n+\n+            --  Remove side effects from the expression now so that\n+            --  other part of the expander do not have to reanalyze\n+            --  this node without this optimization\n+\n+            Rewrite (Exp, Duplicate_Subexpr_No_Checks (Exp));\n+\n+         --  For controlled types, do the allocation on the secondary stack\n+         --  manually in order to call adjust at the right time:\n+\n+         --    type Anon1 is access R_Type;\n+         --    for Anon1'Storage_pool use ss_pool;\n+         --    Anon2 : anon1 := new R_Type'(expr);\n+         --    return Anon2.all;\n+\n+         --  We do the same for classwide types that are not potentially\n+         --  controlled (by the virtue of restriction No_Finalization) because\n+         --  gigi is not able to properly allocate class-wide types.\n+\n+         elsif Is_Class_Wide_Type (Utyp)\n+           or else Controlled_Type (Utyp)\n+         then\n+            declare\n+               Loc        : constant Source_Ptr := Sloc (N);\n+               Temp       : constant Entity_Id :=\n+                              Make_Defining_Identifier (Loc,\n+                                Chars => New_Internal_Name ('R'));\n+               Acc_Typ    : constant Entity_Id :=\n+                              Make_Defining_Identifier (Loc,\n+                                Chars => New_Internal_Name ('A'));\n+               Alloc_Node : Node_Id;\n+\n+            begin\n+               Set_Ekind (Acc_Typ, E_Access_Type);\n+\n+               Set_Associated_Storage_Pool (Acc_Typ, RTE (RE_SS_Pool));\n+\n+               Alloc_Node :=\n+                 Make_Allocator (Loc,\n+                   Expression =>\n+                     Make_Qualified_Expression (Loc,\n+                       Subtype_Mark => New_Reference_To (Etype (Exp), Loc),\n+                       Expression => Relocate_Node (Exp)));\n+\n+               Insert_List_Before_And_Analyze (N, New_List (\n+                 Make_Full_Type_Declaration (Loc,\n+                   Defining_Identifier => Acc_Typ,\n+                   Type_Definition     =>\n+                     Make_Access_To_Object_Definition (Loc,\n+                       Subtype_Indication =>\n+                          New_Reference_To (R_Type, Loc))),\n+\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Object_Definition   => New_Reference_To (Acc_Typ, Loc),\n+                   Expression          => Alloc_Node)));\n+\n+               Rewrite (Exp,\n+                 Make_Explicit_Dereference (Loc,\n+                 Prefix => New_Reference_To (Temp, Loc)));\n+\n+               Analyze_And_Resolve (Exp, R_Type);\n+            end;\n+\n+         --  Otherwise use the gigi mechanism to allocate result on the\n+         --  secondary stack.\n+\n+         else\n+            Set_Storage_Pool      (N, RTE (RE_SS_Pool));\n+\n+            --  If we are generating code for the Java VM do not use\n+            --  SS_Allocate since everything is heap-allocated anyway.\n+\n+            if not Java_VM then\n+               Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  Implement the rules of 6.5(8-10), which require a tag check in\n+      --  the case of a limited tagged return type, and tag reassignment\n+      --  for nonlimited tagged results. These actions are needed when\n+      --  the return type is a specific tagged type and the result\n+      --  expression is a conversion or a formal parameter, because in\n+      --  that case the tag of the expression might differ from the tag\n+      --  of the specific result type.\n+\n+      if Is_Tagged_Type (Utyp)\n+        and then not Is_Class_Wide_Type (Utyp)\n+        and then (Nkind (Exp) = N_Type_Conversion\n+                    or else Nkind (Exp) = N_Unchecked_Type_Conversion\n+                    or else (Is_Entity_Name (Exp)\n+                               and then Ekind (Entity (Exp)) in Formal_Kind))\n+      then\n+         --  When the return type is limited, perform a check that the\n+         --  tag of the result is the same as the tag of the return type.\n+\n+         if Is_Limited_Type (R_Type) then\n+            Insert_Action (Exp,\n+              Make_Raise_Constraint_Error (Loc,\n+                Condition =>\n+                  Make_Op_Ne (Loc,\n+                    Left_Opnd =>\n+                      Make_Selected_Component (Loc,\n+                        Prefix => Duplicate_Subexpr (Exp),\n+                        Selector_Name =>\n+                          New_Reference_To (First_Tag_Component (Utyp), Loc)),\n+                    Right_Opnd =>\n+                      Unchecked_Convert_To (RTE (RE_Tag),\n+                        New_Reference_To\n+                          (Node (First_Elmt\n+                                  (Access_Disp_Table (Base_Type (Utyp)))),\n+                           Loc))),\n+                Reason => CE_Tag_Check_Failed));\n+\n+         --  If the result type is a specific nonlimited tagged type,\n+         --  then we have to ensure that the tag of the result is that\n+         --  of the result type. This is handled by making a copy of the\n+         --  expression in the case where it might have a different tag,\n+         --  namely when the expression is a conversion or a formal\n+         --  parameter. We create a new object of the result type and\n+         --  initialize it from the expression, which will implicitly\n+         --  force the tag to be set appropriately.\n+\n+         else\n+            declare\n+               Result_Id  : constant Entity_Id :=\n+                              Make_Defining_Identifier (Loc,\n+                                Chars => New_Internal_Name ('R'));\n+               Result_Exp : constant Node_Id :=\n+                              New_Reference_To (Result_Id, Loc);\n+               Result_Obj : constant Node_Id :=\n+                              Make_Object_Declaration (Loc,\n+                                Defining_Identifier => Result_Id,\n+                                Object_Definition   =>\n+                                  New_Reference_To (R_Type, Loc),\n+                                Constant_Present    => True,\n+                                Expression          => Relocate_Node (Exp));\n+\n+            begin\n+               Set_Assignment_OK (Result_Obj);\n+               Insert_Action (Exp, Result_Obj);\n+\n+               Rewrite (Exp, Result_Exp);\n+               Analyze_And_Resolve (Exp, R_Type);\n+            end;\n+         end if;\n+\n+      --  Ada 2005 (AI-344): If the result type is class-wide, then insert\n+      --  a check that the level of the return expression's underlying type\n+      --  is not deeper than the level of the master enclosing the function.\n+      --  Always generate the check when the type of the return expression\n+      --  is class-wide, when it's a type conversion, or when it's a formal\n+      --  parameter. Otherwise, suppress the check in the case where the\n+      --  return expression has a specific type whose level is known not to\n+      --  be statically deeper than the function's result type.\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Is_Class_Wide_Type (R_Type)\n+        and then not Scope_Suppress (Accessibility_Check)\n+        and then\n+          (Is_Class_Wide_Type (Etype (Exp))\n+            or else Nkind (Exp) = N_Type_Conversion\n+            or else Nkind (Exp) = N_Unchecked_Type_Conversion\n+            or else (Is_Entity_Name (Exp)\n+                       and then Ekind (Entity (Exp)) in Formal_Kind)\n+            or else Scope_Depth (Enclosing_Dynamic_Scope (Etype (Exp))) >\n+                      Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))\n+      then\n+         Insert_Action (Exp,\n+           Make_Raise_Program_Error (Loc,\n+             Condition =>\n+               Make_Op_Gt (Loc,\n+                 Left_Opnd =>\n+                   Make_Function_Call (Loc,\n+                     Name =>\n+                       New_Reference_To\n+                         (RTE (RE_Get_Access_Level), Loc),\n+                     Parameter_Associations =>\n+                       New_List (Make_Attribute_Reference (Loc,\n+                                   Prefix         =>\n+                                      Duplicate_Subexpr (Exp),\n+                                   Attribute_Name =>\n+                                      Name_Tag))),\n+                 Right_Opnd =>\n+                   Make_Integer_Literal (Loc,\n+                     Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n+             Reason => PE_Accessibility_Check_Failed));\n+      end if;\n+   end Expand_Simple_Function_Return;\n+\n+   ------------------------------\n+   -- Make_Tag_Ctrl_Assignment --\n+   ------------------------------\n+\n+   function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id is\n+      Loc : constant Source_Ptr := Sloc (N);\n+      L   : constant Node_Id    := Name (N);\n+      T   : constant Entity_Id  := Underlying_Type (Etype (L));\n+\n+      Ctrl_Act : constant Boolean := Controlled_Type (T)\n+                                       and then not No_Ctrl_Actions (N);\n+\n+      Save_Tag : constant Boolean := Is_Tagged_Type (T)\n+                                       and then not No_Ctrl_Actions (N)\n+                                       and then not Java_VM;\n+      --  Tags are not saved and restored when Java_VM because JVM tags\n+      --  are represented implicitly in objects.\n+\n+      Res       : List_Id;\n+      Tag_Tmp   : Entity_Id;\n+\n+   begin\n+      Res := New_List;\n+\n+      --  Finalize the target of the assignment when controlled.\n+      --  We have two exceptions here:\n+\n+      --   1. If we are in an init proc since it is an initialization\n+      --      more than an assignment\n+\n+      --   2. If the left-hand side is a temporary that was not initialized\n+      --      (or the parent part of a temporary since it is the case in\n+      --      extension aggregates). Such a temporary does not come from\n+      --      source. We must examine the original node for the prefix, because\n+      --      it may be a component of an entry formal, in which case it has\n+      --      been rewritten and does not appear to come from source either.\n+\n+      --  Case of init proc\n+\n+      if not Ctrl_Act then\n+         null;\n+\n+      --  The left hand side is an uninitialized temporary\n+\n+      elsif Nkind (L) = N_Type_Conversion\n+        and then Is_Entity_Name (Expression (L))\n+        and then No_Initialization (Parent (Entity (Expression (L))))\n+      then\n+         null;\n+      else\n+         Append_List_To (Res,\n+           Make_Final_Call (\n+             Ref         => Duplicate_Subexpr_No_Checks (L),\n+             Typ         => Etype (L),\n+             With_Detach => New_Reference_To (Standard_False, Loc)));\n+      end if;\n+\n+      --  Save the Tag in a local variable Tag_Tmp\n+\n+      if Save_Tag then\n+         Tag_Tmp :=\n+           Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n+\n+         Append_To (Res,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Tag_Tmp,\n+             Object_Definition => New_Reference_To (RTE (RE_Tag), Loc),\n+             Expression =>\n+               Make_Selected_Component (Loc,\n+                 Prefix        => Duplicate_Subexpr_No_Checks (L),\n+                 Selector_Name => New_Reference_To (First_Tag_Component (T),\n+                                                    Loc))));\n+\n+      --  Otherwise Tag_Tmp not used\n+\n+      else\n+         Tag_Tmp := Empty;\n+      end if;\n+\n+      --  Processing for controlled types and types with controlled components\n+\n+      --  Variables of such types contain pointers used to chain them in\n+      --  finalization lists, in addition to user data. These pointers are\n+      --  specific to each object of the type, not to the value being assigned.\n+      --  Thus they need to be left intact during the assignment. We achieve\n+      --  this by constructing a Storage_Array subtype, and by overlaying\n+      --  objects of this type on the source and target of the assignment.\n+      --  The assignment is then rewritten to assignments of slices of these\n+      --  arrays, copying the user data, and leaving the pointers untouched.\n+\n+      if Ctrl_Act then\n+         Controlled_Actions : declare\n+            Prev_Ref : Node_Id;\n+            --  A reference to the Prev component of the record controller\n+\n+            First_After_Root : Node_Id := Empty;\n             --  Index of first byte to be copied (used to skip\n             --  Root_Controlled in controlled objects).\n \n@@ -3619,6 +4613,161 @@ package body Exp_Ch5 is\n          return Empty_List;\n    end Make_Tag_Ctrl_Assignment;\n \n+   -----------------------------\n+   -- No_Secondary_Stack_Case --\n+   -----------------------------\n+\n+   procedure No_Secondary_Stack_Case (N : Node_Id) is\n+      pragma Assert (False); --  DSP method no longer in use\n+\n+      Loc         : constant Source_Ptr := Sloc (N);\n+      Exp         : constant Node_Id    := Expression (N);\n+      T           : constant Entity_Id  := Etype (Exp);\n+      Scope_Id    : constant Entity_Id  :=\n+                      Return_Applies_To (Return_Statement_Entity (N));\n+      Return_Type : constant Entity_Id  := Etype (Scope_Id);\n+      Utyp        : constant Entity_Id  := Underlying_Type (Return_Type);\n+\n+      --  Here what we need to do is to always return by reference, since\n+      --  we will return with the stack pointer depressed. We may need to\n+      --  do a copy to a local temporary before doing this return.\n+\n+      Local_Copy_Required : Boolean := False;\n+      --  Set to True if a local copy is required\n+\n+      Copy_Ent : Entity_Id;\n+      --  Used for the target entity if a copy is required\n+\n+      Decl : Node_Id;\n+      --  Declaration used to create copy if needed\n+\n+      procedure Test_Copy_Required (Expr : Node_Id);\n+      --  Determines if Expr represents a return value for which a\n+      --  copy is required. More specifically, a copy is not required\n+      --  if Expr represents an object or component of an object that\n+      --  is either in the local subprogram frame, or is constant.\n+      --  If a copy is required, then Local_Copy_Required is set True.\n+\n+      ------------------------\n+      -- Test_Copy_Required --\n+      ------------------------\n+\n+      procedure Test_Copy_Required (Expr : Node_Id) is\n+         Ent : Entity_Id;\n+\n+      begin\n+         --  If component, test prefix (object containing component)\n+\n+         if Nkind (Expr) = N_Indexed_Component\n+              or else\n+            Nkind (Expr) = N_Selected_Component\n+         then\n+            Test_Copy_Required (Prefix (Expr));\n+            return;\n+\n+         --  See if we have an entity name\n+\n+         elsif Is_Entity_Name (Expr) then\n+            Ent := Entity (Expr);\n+\n+            --  Constant entity is always OK, no copy required\n+\n+            if Ekind (Ent) = E_Constant then\n+               return;\n+\n+            --  No copy required for local variable\n+\n+            elsif Ekind (Ent) = E_Variable\n+              and then Scope (Ent) = Current_Subprogram\n+            then\n+               return;\n+            end if;\n+         end if;\n+\n+         --  All other cases require a copy\n+\n+         Local_Copy_Required := True;\n+      end Test_Copy_Required;\n+\n+   --  Start of processing for No_Secondary_Stack_Case\n+\n+   begin\n+      --  No copy needed if result is from a function call.\n+      --  In this case the result is already being returned by\n+      --  reference with the stack pointer depressed.\n+\n+      --  To make up for a gcc 2.8.1 deficiency (???), we perform\n+      --  the copy for array types if the constrained status of the\n+      --  target type is different from that of the expression.\n+\n+      if Requires_Transient_Scope (T)\n+        and then\n+          (not Is_Array_Type (T)\n+             or else Is_Constrained (T) = Is_Constrained (Return_Type)\n+             or else Controlled_Type (T))\n+        and then Nkind (Exp) = N_Function_Call\n+      then\n+         Set_By_Ref (N);\n+\n+      --  We always need a local copy for a controlled type, since\n+      --  we are required to finalize the local value before return.\n+      --  The copy will automatically include the required finalize.\n+      --  Moreover, gigi cannot make this copy, since we need special\n+      --  processing to ensure proper behavior for finalization.\n+\n+      --  Note: the reason we are returning with a depressed stack\n+      --  pointer in the controlled case (even if the type involved\n+      --  is constrained) is that we must make a local copy to deal\n+      --  properly with the requirement that the local result be\n+      --  finalized.\n+\n+      elsif Controlled_Type (Utyp) then\n+         Copy_Ent :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_Internal_Name ('R'));\n+\n+         --  Build declaration to do the copy, and insert it, setting\n+         --  Assignment_OK, because we may be copying a limited type.\n+         --  In addition we set the special flag to inhibit finalize\n+         --  attachment if this is a controlled type (since this attach\n+         --  must be done by the caller, otherwise if we attach it here\n+         --  we will finalize the returned result prematurely).\n+\n+         Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Copy_Ent,\n+             Object_Definition   => New_Occurrence_Of (Return_Type, Loc),\n+             Expression          => Relocate_Node (Exp));\n+\n+         Set_Assignment_OK (Decl);\n+         Set_Delay_Finalize_Attach (Decl);\n+         Insert_Action (N, Decl);\n+\n+         --  Now the actual return uses the copied value\n+\n+         Rewrite (Exp, New_Occurrence_Of (Copy_Ent, Loc));\n+         Analyze_And_Resolve (Exp, Return_Type);\n+\n+         --  Since we have made the copy, gigi does not have to, so\n+         --  we set the By_Ref flag to prevent another copy being made.\n+\n+         Set_By_Ref (N);\n+\n+      --  Non-controlled cases\n+\n+      else\n+         Test_Copy_Required (Exp);\n+\n+         --  If a local copy is required, then gigi will make the\n+         --  copy, otherwise, we can return the result directly,\n+         --  so set By_Ref to suppress the gigi copy.\n+\n+         if not Local_Copy_Required then\n+            Set_By_Ref (N);\n+         end if;\n+      end if;\n+   end No_Secondary_Stack_Case;\n+\n    ------------------------------------\n    -- Possible_Bit_Aligned_Component --\n    ------------------------------------"}, {"sha": "a052a84d6fc82a81cd8bf058a642144fa30309c4", "filename": "gcc/ada/exp_ch5.ads", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d/gcc%2Fada%2Fexp_ch5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d/gcc%2Fada%2Fexp_ch5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.ads?ref=9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-1999, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,12 +29,13 @@\n with Types; use Types;\n \n package Exp_Ch5 is\n-   procedure Expand_N_Assignment_Statement (N : Node_Id);\n-   procedure Expand_N_Block_Statement      (N : Node_Id);\n-   procedure Expand_N_Case_Statement       (N : Node_Id);\n-   procedure Expand_N_Exit_Statement       (N : Node_Id);\n-   procedure Expand_N_Goto_Statement       (N : Node_Id);\n-   procedure Expand_N_If_Statement         (N : Node_Id);\n-   procedure Expand_N_Loop_Statement       (N : Node_Id);\n-   procedure Expand_N_Return_Statement     (N : Node_Id);\n+   procedure Expand_N_Assignment_Statement      (N : Node_Id);\n+   procedure Expand_N_Block_Statement           (N : Node_Id);\n+   procedure Expand_N_Case_Statement            (N : Node_Id);\n+   procedure Expand_N_Exit_Statement            (N : Node_Id);\n+   procedure Expand_N_Extended_Return_Statement (N : Node_Id);\n+   procedure Expand_N_Goto_Statement            (N : Node_Id);\n+   procedure Expand_N_If_Statement              (N : Node_Id);\n+   procedure Expand_N_Loop_Statement            (N : Node_Id);\n+   procedure Expand_N_Return_Statement          (N : Node_Id);\n end Exp_Ch5;"}, {"sha": "91191941b162ff27bc60f2e8f1fc4f01eb7a1006", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=9e5ac75fe2ea2e33a9f0cfa512d0567cad12272d", "patch": "@@ -204,6 +204,9 @@ package body Expander is\n                when N_Explicit_Dereference =>\n                   Expand_N_Explicit_Dereference (N);\n \n+               when N_Extended_Return_Statement =>\n+                  Expand_N_Extended_Return_Statement (N);\n+\n                when N_Extension_Aggregate =>\n                   Expand_N_Extension_Aggregate (N);\n "}]}