{"sha": "0a8e311d153cabafc215ec3deecc2f4b49af9a79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE4ZTMxMWQxNTNjYWJhZmMyMTVlYzNkZWVjYzJmNGI0OWFmOWE3OQ==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2007-09-26T10:44:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-09-26T10:44:46Z"}, "message": "make.adb: (Kill): New procedure (__gnat_kill imported)\n\n2007-09-26  Vincent Celier  <celier@adacore.com>\n\n\t* make.adb: (Kill): New procedure (__gnat_kill imported)\n\t(Running_Compile, Outstanding_Compiles): Global variables that\n\twere previously local to procedure Compile_Sources.\n\t(Sigint_Intercepted): Send signal SIGINT to all outstanding\n\tcompilation processes.\n\n\t(Gnatmake): If project files are used, create the mapping of all the\n\tsources, so that the correct paths will be found.\n\n\t* prj-env.ads, prj-env.adb (Create_Mapping): New procedure\n\nFrom-SVN: r128795", "tree": {"sha": "196edbbd7c61c42db784576080bdf0b1cbe074d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/196edbbd7c61c42db784576080bdf0b1cbe074d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a8e311d153cabafc215ec3deecc2f4b49af9a79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8e311d153cabafc215ec3deecc2f4b49af9a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8e311d153cabafc215ec3deecc2f4b49af9a79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8e311d153cabafc215ec3deecc2f4b49af9a79/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a338b0e34936f88d8a87d53610eb63cae6bcd20e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a338b0e34936f88d8a87d53610eb63cae6bcd20e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a338b0e34936f88d8a87d53610eb63cae6bcd20e"}], "stats": {"total": 181, "additions": 102, "deletions": 79}, "files": [{"sha": "c12f7944ad2ac6028caa3caab0cb56e3355d9949", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 93, "deletions": 79, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8e311d153cabafc215ec3deecc2f4b49af9a79/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8e311d153cabafc215ec3deecc2f4b49af9a79/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=0a8e311d153cabafc215ec3deecc2f4b49af9a79", "patch": "@@ -62,10 +62,10 @@ package body Lib.Xref is\n       --  Entity referenced (E parameter to Generate_Reference)\n \n       Def : Source_Ptr;\n-      --  Original source location for entity being referenced. Note that\n-      --  these values are used only during the output process, they are\n-      --  not set when the entries are originally built. This is because\n-      --  private entities can be swapped when the initial call is made.\n+      --  Original source location for entity being referenced. Note that these\n+      --  values are used only during the output process, they are not set when\n+      --  the entries are originally built. This is because private entities\n+      --  can be swapped when the initial call is made.\n \n       Loc : Source_Ptr;\n       --  Location of reference (Original_Location (Sloc field of N parameter\n@@ -103,17 +103,17 @@ package body Lib.Xref is\n    begin\n       pragma Assert (Nkind (E) in N_Entity);\n \n-      --  Note that we do not test Xref_Entity_Letters here. It is too\n-      --  early to do so, since we are often called before the entity\n-      --  is fully constructed, so that the Ekind is still E_Void.\n+      --  Note that we do not test Xref_Entity_Letters here. It is too early\n+      --  to do so, since we are often called before the entity is fully\n+      --  constructed, so that the Ekind is still E_Void.\n \n       if Opt.Xref_Active\n \n          --  Definition must come from source\n \n-         --  We make an exception for subprogram child units that have no\n-         --  spec. For these we generate a subprogram declaration for library\n-         --  use, and the corresponding entity does not come from source.\n+         --  We make an exception for subprogram child units that have no spec.\n+         --  For these we generate a subprogram declaration for library use,\n+         --  and the corresponding entity does not come from source.\n          --  Nevertheless, all references will be attached to it and we have\n          --  to treat is as coming from user code.\n \n@@ -161,8 +161,8 @@ package body Lib.Xref is\n          return;\n       end if;\n \n-      --  If the operator is not a Standard operator, then we generate\n-      --  a real reference to the user defined operator.\n+      --  If the operator is not a Standard operator, then we generate a real\n+      --  reference to the user defined operator.\n \n       if Sloc (Entity (N)) /= Standard_Location then\n          Generate_Reference (Entity (N), N);\n@@ -177,19 +177,18 @@ package body Lib.Xref is\n             Generate_Reference (Corresponding_Equality (Entity (N)), N);\n          end if;\n \n-      --  For the case of Standard operators, we mark the result type\n-      --  as referenced. This ensures that in the case where we are\n-      --  using a derived operator, we mark an entity of the unit that\n-      --  implicitly defines this operator as used. Otherwise we may\n-      --  think that no entity of the unit is used. The actual entity\n-      --  marked as referenced is the first subtype, which is the user\n-      --  defined entity that is relevant.\n+      --  For the case of Standard operators, we mark the result type as\n+      --  referenced. This ensures that in the case where we are using a\n+      --  derived operator, we mark an entity of the unit that implicitly\n+      --  defines this operator as used. Otherwise we may think that no entity\n+      --  of the unit is used. The actual entity marked as referenced is the\n+      --  first subtype, which is the relevant user defined entity.\n \n-      --  Note: we only do this for operators that come from source.\n-      --  The generated code sometimes reaches for entities that do\n-      --  not need to be explicitly visible (for example, when we\n-      --  expand the code for comparing two record types, the fields\n-      --  of the record may not be visible).\n+      --  Note: we only do this for operators that come from source. The\n+      --  generated code sometimes reaches for entities that do not need to be\n+      --  explicitly visible (for example, when we expand the code for\n+      --  comparing two record objects, the fields of the record may not be\n+      --  visible).\n \n       elsif Comes_From_Source (N) then\n          Set_Referenced (First_Subtype (T));\n@@ -370,7 +369,7 @@ package body Lib.Xref is\n       end if;\n \n       --  Unless the reference is forced, we ignore references where the\n-      --  reference itself does not come from Source.\n+      --  reference itself does not come from source.\n \n       if not Force and then not Comes_From_Source (N) then\n          return;\n@@ -445,21 +444,21 @@ package body Lib.Xref is\n          end if;\n \n          --  Check for pragma Unreferenced given and reference is within\n-         --  this source unit (occasion for possible warning to be issued)\n+         --  this source unit (occasion for possible warning to be issued).\n \n          if Has_Pragma_Unreferenced (E)\n            and then In_Same_Extended_Unit (E, N)\n          then\n             --  A reference as a named parameter in a call does not count\n-            --  as a violation of pragma Unreferenced for this purpose.\n+            --  as a violation of pragma Unreferenced for this purpose...\n \n             if Nkind (N) = N_Identifier\n               and then Nkind (Parent (N)) = N_Parameter_Association\n               and then Selector_Name (Parent (N)) = N\n             then\n                null;\n \n-            --  Neither does a reference to a variable on the left side\n+            --  ... Neither does a reference to a variable on the left side\n             --  of an assignment.\n \n             elsif Is_On_LHS (N) then\n@@ -564,8 +563,8 @@ package body Lib.Xref is\n          if Comes_From_Source (E) then\n             Ent := E;\n \n-         --  Entity does not come from source, but is a derived subprogram\n-         --  and the derived subprogram comes from source (after one or more\n+         --  Entity does not come from source, but is a derived subprogram and\n+         --  the derived subprogram comes from source (after one or more\n          --  derivations) in which case the reference is to parent subprogram.\n \n          elsif Is_Overloadable (E)\n@@ -588,8 +587,8 @@ package body Lib.Xref is\n          then\n             Ent := E;\n \n-         --  Record components of discriminated subtypes or derived types\n-         --  must be treated as references to the original component.\n+         --  Record components of discriminated subtypes or derived types must\n+         --  be treated as references to the original component.\n \n          elsif Ekind (E) = E_Component\n            and then Comes_From_Source (Original_Record_Component (E))\n@@ -711,11 +710,11 @@ package body Lib.Xref is\n          Tref  : out Entity_Id;\n          Left  : out Character;\n          Right : out Character);\n-      --  Given an entity id Ent, determines whether a type reference is\n+      --  Given an Entity_Id Ent, determines whether a type reference is\n       --  required. If so, Tref is set to the entity for the type reference\n-      --  and Left and Right are set to the left/right brackets to be\n-      --  output for the reference. If no type reference is required, then\n-      --  Tref is set to Empty, and Left/Right are set to space.\n+      --  and Left and Right are set to the left/right brackets to be output\n+      --  for the reference. If no type reference is required, then Tref is\n+      --  set to Empty, and Left/Right are set to space.\n \n       procedure Output_Import_Export_Info (Ent : Entity_Id);\n       --  Ouput language and external name information for an interfaced\n@@ -756,18 +755,18 @@ package body Lib.Xref is\n                   if Tref /= Etype (Tref) then\n                      Tref := First_Subtype (Etype (Tref));\n \n-                     --  Set brackets for derived type, but don't\n-                     --  override pointer case since the fact that\n-                     --  something is a pointer is more important\n+                     --  Set brackets for derived type, but don't override\n+                     --  pointer case since the fact that something is a\n+                     --  pointer is more important.\n \n                      if Left /= '(' then\n                         Left := '<';\n                         Right := '>';\n                      end if;\n \n                   --  If non-derived ptr, get directly designated type.\n-                  --  If the type has a full view, all references are\n-                  --  on the partial view, that is seen first.\n+                  --  If the type has a full view, all references are on the\n+                  --  partial view, that is seen first.\n \n                   elsif Is_Access_Type (Tref) then\n                      Tref := Directly_Designated_Type (Tref);\n@@ -822,8 +821,8 @@ package body Lib.Xref is\n                   end if;\n                end if;\n \n-            --  For objects, functions, enum literals,\n-            --  just get type from Etype field.\n+            --  For objects, functions, enum literals, just get type from\n+            --  Etype field.\n \n             elsif Is_Object (Tref)\n               or else Ekind (Tref) = E_Enumeration_Literal\n@@ -838,26 +837,24 @@ package body Lib.Xref is\n                exit;\n             end if;\n \n-            --  Exit if no type reference, or we are stuck in\n-            --  some loop trying to find the type reference, or\n-            --  if the type is standard void type (the latter is\n-            --  an implementation artifact that should not show\n-            --  up in the generated cross-references).\n+            --  Exit if no type reference, or we are stuck in some loop trying\n+            --  to find the type reference, or if the type is standard void\n+            --  type (the latter is an implementation artifact that should not\n+            --  show up in the generated cross-references).\n \n             exit when No (Tref)\n               or else Tref = Sav\n               or else Tref = Standard_Void_Type;\n \n-            --  If we have a usable type reference, return, otherwise\n-            --  keep looking for something useful (we are looking for\n-            --  something that either comes from source or standard)\n+            --  If we have a usable type reference, return, otherwise keep\n+            --  looking for something useful (we are looking for something\n+            --  that either comes from source or standard)\n \n             if Sloc (Tref) = Standard_Location\n               or else Comes_From_Source (Tref)\n             then\n-               --  If the reference is a subtype created for a generic\n-               --  actual, go to actual directly, the inner subtype is\n-               --  not user visible.\n+               --  If the reference is a subtype created for a generic actual,\n+               --  go actual directly, the inner subtype is not user visible.\n \n                if Nkind (Parent (Tref)) = N_Subtype_Declaration\n                  and then not Comes_From_Source (Parent (Tref))\n@@ -964,7 +961,7 @@ package body Lib.Xref is\n \n          procedure New_Entry (E : Entity_Id);\n          --  Make an additional entry into the Xref table for a type entity\n-         --  that is related to the current entity (parent, type. ancestor,\n+         --  that is related to the current entity (parent, type ancestor,\n          --  progenitor, etc.).\n \n          ----------------\n@@ -993,7 +990,7 @@ package body Lib.Xref is\n       begin\n          --  Note that this is not a for loop for a very good reason. The\n          --  processing of items in the table can add new items to the table,\n-         --  and they must be processed as well\n+         --  and they must be processed as well.\n \n          J := 1;\n          while J <= Xrefs.Last loop\n@@ -1040,8 +1037,8 @@ package body Lib.Xref is\n                   Prim    : Entity_Id;\n \n                   function Parent_Op (E : Entity_Id) return Entity_Id;\n-                  --  Find original operation, which may be inherited\n-                  --  through several derivations.\n+                  --  Find original operation, which may be inherited through\n+                  --  several derivations.\n \n                   function Parent_Op (E : Entity_Id) return Entity_Id is\n                      Orig_Op : constant Entity_Id := Alias (E);\n@@ -1090,8 +1087,8 @@ package body Lib.Xref is\n       Output_Refs : declare\n \n          Nrefs : Nat := Xrefs.Last;\n-         --  Number of references in table. This value may get reset\n-         --  (reduced) when we eliminate duplicate reference entries.\n+         --  Number of references in table. This value may get reset (reduced)\n+         --  when we eliminate duplicate reference entries.\n \n          Rnums : array (0 .. Nrefs) of Nat;\n          --  This array contains numbers of references in the Xrefs table.\n@@ -1152,30 +1149,30 @@ package body Lib.Xref is\n             T2 : Xref_Entry renames Xrefs.Table (Rnums (Nat (Op2)));\n \n          begin\n-            --  First test. If entity is in different unit, sort by unit\n+            --  First test: if entity is in different unit, sort by unit\n \n             if T1.Eun /= T2.Eun then\n                return Dependency_Num (T1.Eun) < Dependency_Num (T2.Eun);\n \n-            --  Second test, within same unit, sort by entity Sloc\n+            --  Second test: within same unit, sort by entity Sloc\n \n             elsif T1.Def /= T2.Def then\n                return T1.Def < T2.Def;\n \n-            --  Third test, sort definitions ahead of references\n+            --  Third test: sort definitions ahead of references\n \n             elsif T1.Loc = No_Location then\n                return True;\n \n             elsif T2.Loc = No_Location then\n                return False;\n \n-            --  Fourth test, for same entity, sort by reference location unit\n+            --  Fourth test: for same entity, sort by reference location unit\n \n             elsif T1.Lun /= T2.Lun then\n                return Dependency_Num (T1.Lun) < Dependency_Num (T2.Lun);\n \n-            --  Fifth test order of location within referencing unit\n+            --  Fifth test: order of location within referencing unit\n \n             elsif T1.Loc /= T2.Loc then\n                return T1.Loc < T2.Loc;\n@@ -1318,8 +1315,8 @@ package body Lib.Xref is\n                begin\n                   if List_Interface then\n \n-                     --  This is a progenitor interface of the type for\n-                     --  which xref information is being generated.\n+                     --  This is a progenitor interface of the type for which\n+                     --  xref information is being generated.\n \n                      Tref  := Ent;\n                      Left  := '<';\n@@ -1374,8 +1371,8 @@ package body Lib.Xref is\n                         Write_Info_Nat\n                           (Int (Get_Column_Number (Sloc (Tref))));\n \n-                        --  If the type comes from an instantiation,\n-                        --  add the corresponding info.\n+                        --  If the type comes from an instantiation, add the\n+                        --  corresponding info.\n \n                         Output_Instantiation_Refs (Sloc (Tref));\n                         Write_Info_Char (Right);\n@@ -1459,9 +1456,9 @@ package body Lib.Xref is\n                Ctyp := Xref_Entity_Letters (Ekind (Ent));\n \n                --  Skip reference if it is the only reference to an entity,\n-               --  and it is an end-line reference, and the entity is not in\n+               --  and it is an END line reference, and the entity is not in\n                --  the current extended source. This prevents junk entries\n-               --  consisting only of packages with end lines, where no\n+               --  consisting only of packages with END lines, where no\n                --  entity from the package is actually referenced.\n \n                if XE.Typ = 'e'\n@@ -1511,7 +1508,7 @@ package body Lib.Xref is\n \n                   elsif Is_Generic_Type (Ent) then\n \n-                     --  If the type of the entity is a  generic private type\n+                     --  If the type of the entity is a generic private type,\n                      --  there is no usable full view, so retain the indication\n                      --  that this is an object.\n \n@@ -1547,10 +1544,10 @@ package body Lib.Xref is\n                  and then Is_Abstract_Subprogram (XE.Ent)\n                then\n                   if Ctyp = 'U' then\n-                     Ctyp := 'x';            --  abstract procedure\n+                     Ctyp := 'x';            --  Abstract procedure\n \n                   elsif Ctyp = 'V' then\n-                     Ctyp := 'y';            --  abstract function\n+                     Ctyp := 'y';            --  Abstract function\n                   end if;\n \n                elsif Is_Type (XE.Ent)\n@@ -1560,7 +1557,7 @@ package body Lib.Xref is\n                      Ctyp := 'h';\n \n                   elsif Ctyp = 'R' then\n-                     Ctyp := 'H';            --  abstract type\n+                     Ctyp := 'H';            --  Abstract type\n                   end if;\n                end if;\n \n@@ -1717,7 +1714,7 @@ package body Lib.Xref is\n                      end Write_Level_Info;\n \n                      --  Output entity name. We use the occurrence from the\n-                     --  actual source program at the definition point\n+                     --  actual source program at the definition point.\n \n                      P := Original_Location (Sloc (XE.Ent));\n \n@@ -1828,7 +1825,7 @@ package body Lib.Xref is\n                      end if;\n \n                      --  Indicate that the entity is in the unit of the current\n-                     --  xref xection.\n+                     --  xref section.\n \n                      Curru := Curxu;\n \n@@ -1862,6 +1859,8 @@ package body Lib.Xref is\n \n                      Check_Type_Reference (XE.Ent, False);\n \n+                     --  Additional information for types with progenitors\n+\n                      if Is_Record_Type (XE.Ent)\n                        and then Present (Abstract_Interfaces (XE.Ent))\n                      then\n@@ -1875,10 +1874,25 @@ package body Lib.Xref is\n                               Next_Elmt (Elmt);\n                            end loop;\n                         end;\n+\n+                     --  For array types, list index types as well.\n+                     --  (This is not C, indices have distinct types).\n+\n+                     elsif Is_Array_Type (XE.Ent) then\n+                        declare\n+                           Indx : Node_Id;\n+                        begin\n+                           Indx := First_Index (XE.Ent);\n+                           while Present (Indx) loop\n+                              Check_Type_Reference\n+                                (First_Subtype (Etype (Indx)), True);\n+                              Next_Index (Indx);\n+                           end loop;\n+                        end;\n                      end if;\n \n-                     --  If the entity is an overriding operation, write\n-                     --  info on operation that was overridden.\n+                     --  If the entity is an overriding operation, write info\n+                     --  on operation that was overridden.\n \n                      if Is_Subprogram (XE.Ent)\n                        and then Is_Overriding_Operation (XE.Ent)"}, {"sha": "c40f483df05bdab97114c2763316041a8d529344", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8e311d153cabafc215ec3deecc2f4b49af9a79/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8e311d153cabafc215ec3deecc2f4b49af9a79/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=0a8e311d153cabafc215ec3deecc2f4b49af9a79", "patch": "@@ -117,6 +117,10 @@ package Lib.Xref is\n    --          entry of the form  LR=<> for each of the interfaces appearing\n    --          in the type declaration.\n \n+   --          For an array type, there is an entry of the form LR=<> for\n+   --          each of the index types appearing in the type declaration.\n+   --          The index types follow the entry for the component type.\n+\n    --          In the above list LR shows the brackets used in the output,\n    --          which has one of the two following forms:\n \n@@ -169,6 +173,7 @@ package Lib.Xref is\n    --              p = primitive operation\n    --              P = overriding primitive operation\n    --              r = reference\n+   --              R = subprogram reference in dispatching call\n    --              t = end of body\n    --              w = WITH line\n    --              x = type extension\n@@ -249,6 +254,10 @@ package Lib.Xref is\n    --           operation of the parent type, the letter 'P' is used in the\n    --           corresponding entry.\n \n+   --           R is used to mark a dispatching call. The reference is to\n+   --           the specification of the primitive operation of the root\n+   --           type when the call has a controlling argument in its class.\n+\n    --           t is similar to e. It identifies the end of a corresponding\n    --           body (such a reference always links up with a b reference)\n "}]}