{"sha": "2dd24dbdfeed75a433307948e6083c78d7181f53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRkMjRkYmRmZWVkNzVhNDMzMzA3OTQ4ZTYwODNjNzhkNzE4MWY1Mw==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-27T10:06:59Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-27T10:06:59Z"}, "message": "In gcc/objc/: 2010-11-27 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Implemented optional properties.\n        * objc-act.h (PROPERTY_OPTIONAL): New.\n        * objc-act.c (objc_add_property_declaration): Set\n        PROPERTY_OPTIONAL if appropriate.\n        (finish_class): When generating definitions of setter and getter\n        methods associated with a property for a protocol, mark them as\n        optional if the property is optional.\n        (maybe_make_artificial_property_decl): Added 'getter_name'\n        argument.  Set PROPERTY_OPTIONAL.\n        (objc_maybe_build_component_ref): Updated calls to\n        maybe_make_artificial_property_decl.  Added code for optional,\n        readonly properties.\n        (objc_build_class_component_ref): Updated call to\n        maybe_make_artificial_property_decl.\n\nIn gcc/testsuite/:\n2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/property/at-property-24.m: New.\n        * objc.dg/property/at-property-25.m: New.\n        * obj-c++.dg/property/at-property-24.mm: New.\n        * obj-c++.dg/property/at-property-25.mm: New.\n\nFrom-SVN: r167197", "tree": {"sha": "3286544b1f9262f2a2f7654ba7439ed2294ca00d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3286544b1f9262f2a2f7654ba7439ed2294ca00d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dd24dbdfeed75a433307948e6083c78d7181f53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dd24dbdfeed75a433307948e6083c78d7181f53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dd24dbdfeed75a433307948e6083c78d7181f53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dd24dbdfeed75a433307948e6083c78d7181f53/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c5589aa7e1e8bf1e56d3c46d952675e1087be311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5589aa7e1e8bf1e56d3c46d952675e1087be311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5589aa7e1e8bf1e56d3c46d952675e1087be311"}], "stats": {"total": 533, "additions": 520, "deletions": 13}, "files": [{"sha": "1ebff02f1cac7867fb5d1401aa3406d7870015f2", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=2dd24dbdfeed75a433307948e6083c78d7181f53", "patch": "@@ -1,3 +1,20 @@\n+2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented optional properties.\n+\t* objc-act.h (PROPERTY_OPTIONAL): New.\n+\t* objc-act.c (objc_add_property_declaration): Set\n+\tPROPERTY_OPTIONAL if appropriate.\n+\t(finish_class): When generating definitions of setter and getter\n+\tmethods associated with a property for a protocol, mark them as\n+\toptional if the property is optional.\n+\t(maybe_make_artificial_property_decl): Added 'getter_name'\n+\targument.  Set PROPERTY_OPTIONAL.\n+\t(objc_maybe_build_component_ref): Updated calls to\n+\tmaybe_make_artificial_property_decl.  Added code for optional,\n+\treadonly properties.\n+\t(objc_build_class_component_ref): Updated call to\n+\tmaybe_make_artificial_property_decl.\n+\t\n 2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_build_struct): Fixed loops that save and"}, {"sha": "70056d394306ee47990a1452b4fb6f82944f237c", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 81, "deletions": 13, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=2dd24dbdfeed75a433307948e6083c78d7181f53", "patch": "@@ -1181,7 +1181,7 @@ objc_add_property_declaration (location_t location, tree decl,\n       /* An existing property was found; check that it has the same\n \t types, or it is compatible.  */\n       location_t original_location = DECL_SOURCE_LOCATION (x);\n-\t  \n+\n       if (PROPERTY_NONATOMIC (x) != parsed_property_nonatomic)\n \t{\n \t  warning_at (location, 0,\n@@ -1293,6 +1293,13 @@ objc_add_property_declaration (location_t location, tree decl,\n   PROPERTY_IVAR_NAME (property_decl) = NULL_TREE;\n   PROPERTY_DYNAMIC (property_decl) = 0;\n \n+  /* Remember the fact that the property was found in the @optional\n+     section in a @protocol, or not.  */\n+  if (objc_method_optional_flag)\n+    PROPERTY_OPTIONAL (property_decl) = 1;\n+  else\n+    PROPERTY_OPTIONAL (property_decl) = 0;\n+\n   /* Note that PROPERTY_GETTER_NAME is always set for all\n      PROPERTY_DECLs, and PROPERTY_SETTER_NAME is always set for all\n      PROPERTY_DECLs where PROPERTY_READONLY == 0.  Any time we deal\n@@ -1310,18 +1317,22 @@ objc_add_property_declaration (location_t location, tree decl,\n    in the implementation, and failing that, the protocol list)\n    provided for a 'setter' or 'getter' for 'component' with default\n    names (ie, if 'component' is \"name\", then search for \"name\" and\n-   \"setName:\").  If any is found, then create an artificial property\n-   that uses them.  Return NULL_TREE if 'getter' or 'setter' could not\n-   be found.  */\n+   \"setName:\").  It is also possible to specify a different\n+   'getter_name' (this is used for @optional readonly properties).  If\n+   any is found, then create an artificial property that uses them.\n+   Return NULL_TREE if 'getter' or 'setter' could not be found.  */\n static tree\n maybe_make_artificial_property_decl (tree interface, tree implementation, \n-\t\t\t\t     tree protocol_list, tree component, bool is_class)\n+\t\t\t\t     tree protocol_list, tree component, bool is_class,\n+\t\t\t\t     tree getter_name)\n {\n-  tree getter_name = component;\n   tree setter_name = get_identifier (objc_build_property_setter_name (component));\n   tree getter = NULL_TREE;\n   tree setter = NULL_TREE;\n \n+  if (getter_name == NULL_TREE)\n+    getter_name = component;\n+\n   /* First, check the @interface and all superclasses.  */\n   if (interface)\n     {\n@@ -1401,6 +1412,7 @@ maybe_make_artificial_property_decl (tree interface, tree implementation,\n       PROPERTY_ASSIGN_SEMANTICS (property_decl) = 0;\n       PROPERTY_IVAR_NAME (property_decl) = NULL_TREE;\n       PROPERTY_DYNAMIC (property_decl) = 0;\n+      PROPERTY_OPTIONAL (property_decl) = 0;\n \n       if (!getter)\n \tPROPERTY_HAS_NO_GETTER (property_decl) = 1;\n@@ -1481,7 +1493,7 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t properties.  */\n \t      if (!IS_CLASS (rtype))\n \t\tx = lookup_property_in_protocol_list (rprotos, property_ident);\n-\t      \n+\n \t      if (x == NULL_TREE)\n \t\t{\n \t\t  /* Ok, no property.  Maybe it was an\n@@ -1493,7 +1505,25 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t\t\t\t\t\t   NULL_TREE,\n \t\t\t\t\t\t\t   rprotos, \n \t\t\t\t\t\t\t   property_ident,\n-\t\t\t\t\t\t\t   IS_CLASS (rtype));\n+\t\t\t\t\t\t\t   IS_CLASS (rtype),\n+\t\t\t\t\t\t\t   NULL_TREE);\n+\t\t}\n+\t      else if (PROPERTY_OPTIONAL (x) && PROPERTY_READONLY (x))\n+\t\t{\n+\t\t  /* This is a special, complicated case.  If the\n+\t\t     property is optional, and is read-only, then the\n+\t\t     property is always used for reading, but an\n+\t\t     eventual existing non-property setter can be used\n+\t\t     for writing.  We create an artificial property\n+\t\t     decl copying the getter from the optional\n+\t\t     property, and looking up the setter in the\n+\t\t     interface.  */\n+\t\t  x = maybe_make_artificial_property_decl (NULL_TREE,\n+\t\t\t\t\t\t\t   NULL_TREE,\n+\t\t\t\t\t\t\t   rprotos,\n+\t\t\t\t\t\t\t   property_ident,\n+\t\t\t\t\t\t\t   false,\n+\t\t\t\t\t\t\t   PROPERTY_GETTER_NAME (x));\t\t  \n \t\t}\n \t    }\n \t}\n@@ -1538,7 +1568,22 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t  x = maybe_make_artificial_property_decl \n \t\t    (interface_type, implementation, NULL_TREE,\n \t\t     property_ident,\n-\t\t     (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL));\n+\t\t     (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL),\n+\t\t     NULL_TREE);\n+\t\t}\n+\t      else if (PROPERTY_OPTIONAL (x) && PROPERTY_READONLY (x))\n+\t\t{\n+\t\t  tree implementation = NULL_TREE;\n+\t\t  \n+\t\t  if (t == self_decl)\n+\t\t    implementation = objc_implementation_context;\n+\t\t  \n+\t\t  x = maybe_make_artificial_property_decl (interface_type,\n+\t\t\t\t\t\t\t   implementation,\n+\t\t\t\t\t\t\t   NULL_TREE,\n+\t\t\t\t\t\t\t   property_ident,\n+\t\t\t\t\t\t\t   false,\n+\t\t\t\t\t\t\t   PROPERTY_GETTER_NAME (x));\t\t  \n \t\t}\n \t    }\n \t}\n@@ -1603,8 +1648,25 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t\t\t\t\t\t   implementation,\n \t\t\t\t\t\t\t   protocol_list, \n \t\t\t\t\t\t\t   property_ident,\n-\t\t\t\t\t\t\t   IS_CLASS (rtype));\n+\t\t\t\t\t\t\t   IS_CLASS (rtype),\n+\t\t\t\t\t\t\t   NULL_TREE);\n \t\t}\n+\t      else if (PROPERTY_OPTIONAL (x) && PROPERTY_READONLY (x))\n+\t\t{\n+\t\t  tree implementation = NULL_TREE;\n+\n+\t\t  if (objc_implementation_context\n+\t\t      && CLASS_NAME (objc_implementation_context) \n+\t\t      == OBJC_TYPE_NAME (interface_type))\n+\t\t    implementation = objc_implementation_context;\n+\t\t  \n+\t\t  x = maybe_make_artificial_property_decl (interface_type,\n+\t\t\t\t\t\t\t   implementation,\n+\t\t\t\t\t\t\t   protocol_list,\n+\t\t\t\t\t\t\t   property_ident,\n+\t\t\t\t\t\t\t   false,\n+\t\t\t\t\t\t\t   PROPERTY_GETTER_NAME (x));\t\t  \n+\t\t}\t      \n \t    }\n \t}\n     }\n@@ -1703,7 +1765,7 @@ objc_build_class_component_ref (tree class_name, tree property_ident)\n \n   x = maybe_make_artificial_property_decl (rtype, NULL_TREE, NULL_TREE,\n \t\t\t\t\t   property_ident,\n-\t\t\t\t\t   true);\n+\t\t\t\t\t   true, NULL_TREE);\n   \n   if (x)\n     {\n@@ -10534,7 +10596,10 @@ finish_class (tree klass)\n \t\tgetter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n \t\t\t\t\t\t rettype, PROPERTY_GETTER_NAME (x), \n \t\t\t\t\t\t NULL_TREE, false);\n-\t\tobjc_add_method (objc_interface_context, getter_decl, false, false);\n+\t\tif (PROPERTY_OPTIONAL (x))\n+\t\t  objc_add_method (objc_interface_context, getter_decl, false, true);\n+\t\telse\n+\t\t  objc_add_method (objc_interface_context, getter_decl, false, false);\n \t\tMETHOD_PROPERTY_CONTEXT (getter_decl) = x;\n \t      }\n \n@@ -10574,7 +10639,10 @@ finish_class (tree klass)\n \t\t\t\t\t\t     ret_type, selector,\n \t\t\t\t\t\t     build_tree_list (NULL_TREE, NULL_TREE),\n \t\t\t\t\t\t     false);\n-\t\t    objc_add_method (objc_interface_context, setter_decl, false, false);\n+\t\t    if (PROPERTY_OPTIONAL (x))\n+\t\t      objc_add_method (objc_interface_context, setter_decl, false, true);\n+\t\t    else\n+\t\t      objc_add_method (objc_interface_context, setter_decl, false, false);\n \t\t    METHOD_PROPERTY_CONTEXT (setter_decl) = x;\n \t\t  }\t       \n \t      }"}, {"sha": "6403161da7be4de8d9f8c33149b88d1b66761acd", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=2dd24dbdfeed75a433307948e6083c78d7181f53", "patch": "@@ -113,6 +113,11 @@ typedef enum objc_property_assign_semantics {\n    setter, it is set to 1.  */\n #define PROPERTY_HAS_NO_SETTER(DECL) DECL_LANG_FLAG_4 (DECL)\n \n+/* PROPERTY_OPTIONAL can be 0 or 1.  Normally it is 0, but if this is\n+   a property declared as @optional in a @protocol, then it is set to\n+   1.  */\n+#define PROPERTY_OPTIONAL(DECL) DECL_LANG_FLAG_5 (DECL)\n+\n /* PROPERTY_REF.  A PROPERTY_REF represents an 'object.property'\n    expression.  It is normally used for property access, but when\n    the Objective-C 2.0 \"dot-syntax\" (object.component) is used"}, {"sha": "7b6f1306e9b3ba56a436f43c2f6366a89036725a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2dd24dbdfeed75a433307948e6083c78d7181f53", "patch": "@@ -1,3 +1,10 @@\n+2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/property/at-property-24.m: New.\n+\t* objc.dg/property/at-property-25.m: New.\t\n+\t* obj-c++.dg/property/at-property-24.mm: New.\n+\t* obj-c++.dg/property/at-property-25.mm: New.\n+\n 2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/protocol-qualifier-1.m: New.\t"}, {"sha": "b4a7699f6e409b373ccaf811b9edb06086a7c620", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-24.mm", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-24.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-24.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-24.mm?ref=2dd24dbdfeed75a433307948e6083c78d7181f53", "patch": "@@ -0,0 +1,118 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @optional @properties.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+/* Use a different getters/setters, so that the only way to compile\n+   object.countX is to find the actual @property.  */\n+@protocol count\n+@required\n+/* @required + @synthesize.  */\n+@property (getter=number1, setter=setNumber1:) int count1;\n+/* @required + manual setters/getters.  */\n+@property (getter=number2, setter=setNumber2:) int count2;\n+\n+@optional\n+/* @optional + @synthesize.  */\n+@property (getter=number3, setter=setNumber3:) int count3;\n+/* @optional + manual setters/getters.  */\n+@property (getter=number4, setter=setNumber4:) int count4;\n+\n+@optional\n+/* @optional + readonly, with a setter added in the class itself.  */\n+@property (readonly, getter=number5) int count5;\n+@end\n+\n+@interface MySubClass : MyRootClass <count>\n+{\n+  int count1;\n+  int count2;\n+  int count3;\n+  int count4;\n+  int count5;\n+}\n+- (void) setCount5: (int)value;\n+@end\n+\n+@implementation MySubClass\n+@synthesize count1;\n+- (int) number2\n+{\n+  return count2;\n+}\n+- (void) setNumber2: (int)value\n+{\n+  count2 = value;\n+}\n+@synthesize count3;\n+- (int) number4\n+{\n+  return count4;\n+}\n+- (void) setNumber4: (int)value\n+{\n+  count4 = value;\n+}\n+- (int) number5\n+{\n+  return count5;\n+}\n+- (void) setCount5: (int)value\n+{\n+  count5 = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  /* First, test that @required and @optional properties work as\n+     expected if implemented either via @synthesize or manually.  */\n+  object.count1 = 44;\n+  if (object.count1 != 44)\n+    abort ();\n+\n+  object.count2 = 88;\n+  if (object.count2 != 88)\n+    abort ();\n+\n+  object.count3 = 77;\n+  if (object.count3 != 77)\n+    abort ();\n+\n+  object.count4 = 11;\n+  if (object.count4 != 11)\n+    abort ();\n+\n+  /* Now, test the complication: @optional @property which is\n+     readonly, but which has a setter manually implemented.\n+     Apparently it is possible to use the dotsyntax and the @optional\n+     @property getter is used when reading, while the manual setter is\n+     used when writing.  */\n+  object.count5 = 99;\n+  if (object.count5 != 99)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "422a29e552c85a513b36aae273f8dd69ddf822ff", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-25.mm", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-25.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-25.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-25.mm?ref=2dd24dbdfeed75a433307948e6083c78d7181f53", "patch": "@@ -0,0 +1,87 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test warnings and non-warnings with @optional @properties.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol count\n+@optional\n+@property int count1;\n+@property (readonly) int count2;\n+@end\n+\n+\n+/* A class that implements all the properties.  */\n+@interface MySubClass1 : MyRootClass <count>\n+{\n+  int count1;\n+  int count2;\n+}\n+@end\n+\n+@implementation MySubClass1\n+@synthesize count1;\n+@synthesize count2;\n+@end\n+\n+\n+/* A class that implements nothing; no warnings as the properties are\n+   all optional.  */\n+@interface MySubClass2 : MyRootClass <count>\n+@end\n+\n+@implementation MySubClass2\n+@end\n+\n+\n+@protocol count2\n+@required\n+@property int count1;\n+@property (readonly) int count2;\n+@end\n+\n+/* A class that implements all the properties.  */\n+@interface MySubClass3 : MyRootClass <count2>\n+{\n+  int count1;\n+  int count2;\n+}\n+@end\n+\n+@implementation MySubClass3\n+@synthesize count1;\n+@synthesize count2;\n+@end\n+\n+\n+/* A class that implements nothing; warnings as the properties are\n+   all required.  */\n+@interface MySubClass4 : MyRootClass <count2>\n+@end\n+\n+@implementation MySubClass4\n+@end\n+\n+/* { dg-warning \"incomplete implementation of class\" \"\" { target *-*-* } 81 } */\n+/* { dg-warning \"method definition for ..setCount1:. not found\" \"\" { target *-*-* } 81 } */\n+/* { dg-warning \"method definition for ..count1. not found\" \"\" { target *-*-* } 81 } */\n+/* { dg-warning \"method definition for ..count2. not found\" \"\" { target *-*-* } 81 } */\n+/* { dg-warning \"class .MySubClass4. does not fully implement the .count2. protocol\" \"\" { target *-*-* } 81 } */"}, {"sha": "b4a7699f6e409b373ccaf811b9edb06086a7c620", "filename": "gcc/testsuite/objc.dg/property/at-property-24.m", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-24.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-24.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-24.m?ref=2dd24dbdfeed75a433307948e6083c78d7181f53", "patch": "@@ -0,0 +1,118 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @optional @properties.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+/* Use a different getters/setters, so that the only way to compile\n+   object.countX is to find the actual @property.  */\n+@protocol count\n+@required\n+/* @required + @synthesize.  */\n+@property (getter=number1, setter=setNumber1:) int count1;\n+/* @required + manual setters/getters.  */\n+@property (getter=number2, setter=setNumber2:) int count2;\n+\n+@optional\n+/* @optional + @synthesize.  */\n+@property (getter=number3, setter=setNumber3:) int count3;\n+/* @optional + manual setters/getters.  */\n+@property (getter=number4, setter=setNumber4:) int count4;\n+\n+@optional\n+/* @optional + readonly, with a setter added in the class itself.  */\n+@property (readonly, getter=number5) int count5;\n+@end\n+\n+@interface MySubClass : MyRootClass <count>\n+{\n+  int count1;\n+  int count2;\n+  int count3;\n+  int count4;\n+  int count5;\n+}\n+- (void) setCount5: (int)value;\n+@end\n+\n+@implementation MySubClass\n+@synthesize count1;\n+- (int) number2\n+{\n+  return count2;\n+}\n+- (void) setNumber2: (int)value\n+{\n+  count2 = value;\n+}\n+@synthesize count3;\n+- (int) number4\n+{\n+  return count4;\n+}\n+- (void) setNumber4: (int)value\n+{\n+  count4 = value;\n+}\n+- (int) number5\n+{\n+  return count5;\n+}\n+- (void) setCount5: (int)value\n+{\n+  count5 = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  /* First, test that @required and @optional properties work as\n+     expected if implemented either via @synthesize or manually.  */\n+  object.count1 = 44;\n+  if (object.count1 != 44)\n+    abort ();\n+\n+  object.count2 = 88;\n+  if (object.count2 != 88)\n+    abort ();\n+\n+  object.count3 = 77;\n+  if (object.count3 != 77)\n+    abort ();\n+\n+  object.count4 = 11;\n+  if (object.count4 != 11)\n+    abort ();\n+\n+  /* Now, test the complication: @optional @property which is\n+     readonly, but which has a setter manually implemented.\n+     Apparently it is possible to use the dotsyntax and the @optional\n+     @property getter is used when reading, while the manual setter is\n+     used when writing.  */\n+  object.count5 = 99;\n+  if (object.count5 != 99)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "422a29e552c85a513b36aae273f8dd69ddf822ff", "filename": "gcc/testsuite/objc.dg/property/at-property-25.m", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-25.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dd24dbdfeed75a433307948e6083c78d7181f53/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-25.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-25.m?ref=2dd24dbdfeed75a433307948e6083c78d7181f53", "patch": "@@ -0,0 +1,87 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test warnings and non-warnings with @optional @properties.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol count\n+@optional\n+@property int count1;\n+@property (readonly) int count2;\n+@end\n+\n+\n+/* A class that implements all the properties.  */\n+@interface MySubClass1 : MyRootClass <count>\n+{\n+  int count1;\n+  int count2;\n+}\n+@end\n+\n+@implementation MySubClass1\n+@synthesize count1;\n+@synthesize count2;\n+@end\n+\n+\n+/* A class that implements nothing; no warnings as the properties are\n+   all optional.  */\n+@interface MySubClass2 : MyRootClass <count>\n+@end\n+\n+@implementation MySubClass2\n+@end\n+\n+\n+@protocol count2\n+@required\n+@property int count1;\n+@property (readonly) int count2;\n+@end\n+\n+/* A class that implements all the properties.  */\n+@interface MySubClass3 : MyRootClass <count2>\n+{\n+  int count1;\n+  int count2;\n+}\n+@end\n+\n+@implementation MySubClass3\n+@synthesize count1;\n+@synthesize count2;\n+@end\n+\n+\n+/* A class that implements nothing; warnings as the properties are\n+   all required.  */\n+@interface MySubClass4 : MyRootClass <count2>\n+@end\n+\n+@implementation MySubClass4\n+@end\n+\n+/* { dg-warning \"incomplete implementation of class\" \"\" { target *-*-* } 81 } */\n+/* { dg-warning \"method definition for ..setCount1:. not found\" \"\" { target *-*-* } 81 } */\n+/* { dg-warning \"method definition for ..count1. not found\" \"\" { target *-*-* } 81 } */\n+/* { dg-warning \"method definition for ..count2. not found\" \"\" { target *-*-* } 81 } */\n+/* { dg-warning \"class .MySubClass4. does not fully implement the .count2. protocol\" \"\" { target *-*-* } 81 } */"}]}