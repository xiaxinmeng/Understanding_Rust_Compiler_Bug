{"sha": "14203c9cac8bfbabc168aee4df38cb752bbed421", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQyMDNjOWNhYzhiZmJhYmMxNjhhZWU0ZGYzOGNiNzUyYmJlZDQyMQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-09-11T22:49:29Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-09-11T22:49:29Z"}, "message": "Field.java (toString): Don't rely on Class.toString.\n\n\t* java/lang/reflect/Field.java (toString): Don't rely on\n\tClass.toString.\n\nFrom-SVN: r36341", "tree": {"sha": "06e7a4f15149766a0752a18103b431dd1f44fd26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06e7a4f15149766a0752a18103b431dd1f44fd26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14203c9cac8bfbabc168aee4df38cb752bbed421", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14203c9cac8bfbabc168aee4df38cb752bbed421", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14203c9cac8bfbabc168aee4df38cb752bbed421", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14203c9cac8bfbabc168aee4df38cb752bbed421/comments", "author": null, "committer": null, "parents": [{"sha": "c82fd9b858106eb8e73782e03d713625c79b3ec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c82fd9b858106eb8e73782e03d713625c79b3ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c82fd9b858106eb8e73782e03d713625c79b3ec8"}], "stats": {"total": 429, "additions": 421, "deletions": 8}, "files": [{"sha": "acbbbbc2e7b96040831958203f750bfb8347c084", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14203c9cac8bfbabc168aee4df38cb752bbed421/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14203c9cac8bfbabc168aee4df38cb752bbed421/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=14203c9cac8bfbabc168aee4df38cb752bbed421", "patch": "@@ -1,3 +1,8 @@\n+2000-09-11  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java/lang/reflect/Field.java (toString): Don't rely on\n+\tClass.toString.\n+\n 2000-09-08  Tom Tromey  <tromey@cygnus.com>\n \n \t* gnu/gcj/convert/BytesToUnicode.java (getDefaultDecoder): Let"}, {"sha": "edfa1f5924b49702d89d6967ae50d8fdd0a5bc5a", "filename": "libjava/java/io/DataInputStream.java", "status": "modified", "additions": 415, "deletions": 7, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14203c9cac8bfbabc168aee4df38cb752bbed421/libjava%2Fjava%2Fio%2FDataInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14203c9cac8bfbabc168aee4df38cb752bbed421/libjava%2Fjava%2Fio%2FDataInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataInputStream.java?ref=14203c9cac8bfbabc168aee4df38cb752bbed421", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -8,34 +8,78 @@\n  \n package java.io;\n \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date October 20, 1998.  \n- */\n-\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  */\n  \n+/**\n+ * This subclass of <code>FilteredInputStream</code> implements the\n+ * <code>DataInput</code> interface that provides method for reading primitive\n+ * Java data types from a stream.\n+ *\n+ * @see DataInput\n+ *\n+ * @version 0.0\n+ *\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @date October 20, 1998.  \n+ */\n+\n public class DataInputStream extends FilterInputStream implements DataInput\n {\n   // readLine() hack to ensure that an '\\r' not followed by an '\\n' is\n   // handled correctly. If set, readLine() will ignore the first char it sees\n   // if that char is a '\\n'\n   boolean ignoreInitialNewline = false;\n   \n+  /**\n+   * This constructor initializes a new <code>DataInputStream</code>\n+   * to read from the specified subordinate stream.\n+   *\n+   * @param in The subordinate <code>InputStream</code> to read from\n+   */\n   public DataInputStream(InputStream in)\n   {\n     super(in);\n   }\n \n+  /**\n+   * This method reads bytes from the underlying stream into the specified\n+   * byte array buffer.  It will attempt to fill the buffer completely, but\n+   * may return a short count if there is insufficient data remaining to be\n+   * read to fill the buffer.\n+   *\n+   * @param b The buffer into which bytes will be read.\n+   * \n+   * @return The actual number of bytes read, or -1 if end of stream reached \n+   * before reading any bytes.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public final int read(byte[] b) throws IOException\n   {\n     return super.read(b, 0, b.length);\n   }\n \n+  /**\n+   * This method reads bytes from the underlying stream into the specified\n+   * byte array buffer.  It will attempt to read <code>len</code> bytes and\n+   * will start storing them at position <code>off</code> into the buffer.\n+   * This method can return a short count if there is insufficient data\n+   * remaining to be read to complete the desired read length.\n+   *\n+   * @param b The buffer into which bytes will be read.\n+   * @param off The offset into the buffer to start storing bytes.\n+   * @param len The requested number of bytes to read.\n+   *\n+   * @return The actual number of bytes read, or -1 if end of stream reached\n+   * before reading any bytes.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public final int read(byte[] b, int off, int len) throws IOException\n   {\n     if (off < 0 || len < 0 || off + len > b.length)\n@@ -44,11 +88,42 @@ public final int read(byte[] b, int off, int len) throws IOException\n     return super.read(b, off, len);\n   }\n \n+  /**\n+   * This method reads a Java boolean value from an input stream.  It does\n+   * so by reading a single byte of data.  If that byte is zero, then the\n+   * value returned is <code>false</code>.  If the byte is non-zero, then\n+   * the value returned is <code>true</code>.\n+   * <p>\n+   * This method can read a <code>boolean</code> written by an object\n+   * implementing the <code>writeBoolean()</code> method in the\n+   * <code>DataOutput</code> interface. \n+   *\n+   * @return The <code>boolean</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading\n+   * the boolean\n+   * @exception IOException If any other error occurs\n+   */\n   public final boolean readBoolean() throws IOException\n   {\n     return (readByte() != 0);\n   }\n \n+  /**\n+   * This method reads a Java byte value from an input stream.  The value\n+   * is in the range of -128 to 127.\n+   * <p>\n+   * This method can read a <code>byte</code> written by an object\n+   * implementing the <code>writeByte()</code> method in the\n+   * <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>byte</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading the byte\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final byte readByte() throws IOException\n   {\n     int i = read();\n@@ -58,26 +133,118 @@ public final byte readByte() throws IOException\n     return (byte) i;\n   }\n \n+  /**\n+   * This method reads a Java <code>char</code> value from an input stream.  \n+   * It operates by reading two bytes from the stream and converting them to \n+   * a single 16-bit Java <code>char</code>.  The two bytes are stored most\n+   * significant byte first (i.e., \"big endian\") regardless of the native\n+   * host byte ordering. \n+   * <p>\n+   * As an example, if <code>byte1</code> and <code>byte2</code>\n+   * represent the first and second byte read from the stream\n+   * respectively, they will be transformed to a <code>char</code> in\n+   * the following manner: \n+   * <p>\n+   * <code>(char)(((byte1 & 0xFF) << 8) | (byte2 & 0xFF)</code>\n+   * <p>\n+   * This method can read a <code>char</code> written by an object\n+   * implementing the <code>writeChar()</code> method in the\n+   * <code>DataOutput</code> interface. \n+   *\n+   * @return The <code>char</code> value read \n+   *\n+   * @exception EOFException If end of file is reached before reading the char\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final char readChar() throws IOException\n   {\n     return (char) ((readByte() << 8) | readUnsignedByte());\n   }\n \n+  /**\n+   * This method reads a Java double value from an input stream.  It operates\n+   * by first reading a <code>long</code> value from the stream by calling the\n+   * <code>readLong()</code> method in this interface, then converts\n+   * that <code>long</code> to a <code>double</code> using the\n+   * <code>longBitsToDouble</code> method in the class\n+   * <code>java.lang.Double</code> \n+   * <p>\n+   * This method can read a <code>double</code> written by an object\n+   * implementing the <code>writeDouble()</code> method in the\n+   * <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>double</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading\n+   * the double\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see java.lang.Double\n+   * @see DataOutput\n+   */\n   public final double readDouble() throws IOException\n   {\n     return Double.longBitsToDouble(readLong());\n   }\n \n+  /**\n+   * This method reads a Java float value from an input stream.  It\n+   * operates by first reading an <code>int</code> value from the\n+   * stream by calling the <code>readInt()</code> method in this\n+   * interface, then converts that <code>int</code> to a\n+   * <code>float</code> using the <code>intBitsToFloat</code> method\n+   * in the class <code>java.lang.Float</code>\n+   * <p>\n+   * This method can read a <code>float</code> written by an object\n+   * implementing the * <code>writeFloat()</code> method in the\n+   * <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>float</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading the float\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see java.lang.Float\n+   * @see DataOutput */\n   public final float readFloat() throws IOException\n   {\n     return Float.intBitsToFloat(readInt());\n   }\n \n+  /**\n+   * This method reads raw bytes into the passed array until the array is\n+   * full.  Note that this method blocks until the data is available and\n+   * throws an exception if there is not enough data left in the stream to\n+   * fill the buffer\n+   *\n+   * @param b The buffer into which to read the data\n+   *\n+   * @exception EOFException If end of file is reached before filling\n+   * the buffer\n+   * @exception IOException If any other error occurs */\n   public final void readFully(byte[] b) throws IOException\n   {\n     readFully(b, 0, b.length);\n   }\n \n+  /**\n+   * This method reads raw bytes into the passed array\n+   * <code>buf</code> starting <code>offset</code> bytes into the\n+   * buffer.  The number of bytes read will be exactly\n+   * <code>len</code> Note that this method blocks until the data is\n+   * available and * throws an exception if there is not enough data\n+   * left in the stream to read <code>len</code> bytes.\n+   *\n+   * @param buf The buffer into which to read the data\n+   * @param offset The offset into the buffer to start storing data\n+   * @param len The number of bytes to read into the buffer\n+   *\n+   * @exception EOFException If end of file is reached before filling\n+   * the buffer\n+   * @exception IOException If any other error occurs\n+   */\n   public final void readFully(byte[] b, int off, int len) throws IOException\n   {\n     if (off < 0 || len < 0 || off + len > b.length)\n@@ -94,6 +261,33 @@ public final void readFully(byte[] b, int off, int len) throws IOException\n       }\n   }\n \n+  /**\n+   * This method reads a Java <code>int</code> value from an input\n+   * stream It operates by reading four bytes from the stream and\n+   * converting them to a single Java <code>int</code> The bytes are\n+   * stored most significant byte first (i.e., \"big endian\")\n+   * regardless of the native host byte ordering.\n+   * <p>\n+   * As an example, if <code>byte1</code> through <code>byte4</code>\n+   * represent the first four bytes read from the stream, they will be\n+   * transformed to an <code>int</code> in the following manner:\n+   * <p>\n+   * <code>(int)(((byte1 & 0xFF) << 24) + ((byte2 & 0xFF) << 16) + \n+   * ((byte3 & 0xFF) << 8) + (byte4 & 0xFF)))</code>\n+   * <p>\n+   * The value returned is in the range of 0 to 65535.\n+   * <p>\n+   * This method can read an <code>int</code> written by an object\n+   * implementing the <code>writeInt()</code> method in the\n+   * <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>int</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading the int\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final int readInt() throws IOException\n   {\n     int retval = 0;\n@@ -103,7 +297,32 @@ public final int readInt() throws IOException\n     return retval;\n   }\n \n-  // Deprecated as of JDK 1.1\n+  /**\n+   * This method reads the next line of text data from an input\n+   * stream.  It operates by reading bytes and converting those bytes\n+   * to <code>char</code> values by treating the byte read as the low\n+   * eight bits of the <code>char</code> and using 0 as the high eight\n+   * bits.  Because of this, it does not support the full 16-bit\n+   * Unicode character set.\n+   * <p>\n+   * The reading of bytes ends when either the end of file or a line\n+   * terminator is encountered.  The bytes read are then returned as a\n+   * <code>String</code> A line terminator is a byte sequence\n+   * consisting of either <code>\\r</code>, <code>\\n</code> or\n+   * <code>\\r\\n</code>.  These termination charaters are discarded and\n+   * are not returned as part of the string.\n+   * <p>\n+   * This method can read data that was written by an object implementing the\n+   * <code>writeLine()</code> method in <code>DataOutput</code>.\n+   *\n+   * @return The line read as a <code>String</code>\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @see DataOutput\n+   *\n+   * @deprecated\n+   */\n   public final String readLine() throws IOException\n   {\n     StringBuffer strb = new StringBuffer();\n@@ -191,6 +410,35 @@ else if (markSupported())\n     return strb.length() > 0 ? strb.toString() : \"\";\n   }\n \n+  /**\n+   * This method reads a Java long value from an input stream\n+   * It operates by reading eight bytes from the stream and converting them to \n+   * a single Java <code>long</code>  The bytes are stored most\n+   * significant byte first (i.e., \"big endian\") regardless of the native\n+   * host byte ordering. \n+   * <p>\n+   * As an example, if <code>byte1</code> through <code>byte8</code>\n+   * represent the first eight bytes read from the stream, they will\n+   * be transformed to an <code>long</code> in the following manner:\n+   * <p>\n+   * <code>(long)((((long)byte1 & 0xFF) << 56) + (((long)byte2 & 0xFF) << 48) + \n+   * (((long)byte3 & 0xFF) << 40) + (((long)byte4 & 0xFF) << 32) + \n+   * (((long)byte5 & 0xFF) << 24) + (((long)byte6 & 0xFF) << 16) + \n+   * (((long)byte7 & 0xFF) << 8) + ((long)byte9 & 0xFF)))</code>\n+   * <p>\n+   * The value returned is in the range of 0 to 65535.\n+   * <p>\n+   * This method can read an <code>long</code> written by an object\n+   * implementing the <code>writeLong()</code> method in the\n+   * <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>long</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading the long\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final long readLong() throws IOException\n   {\n     long retval = 0L;\n@@ -200,11 +448,54 @@ public final long readLong() throws IOException\n     return retval;\n   }\n \n+  /**\n+   * This method reads a signed 16-bit value into a Java in from the\n+   * stream.  It operates by reading two bytes from the stream and\n+   * converting them to a single 16-bit Java <code>short</code>.  The\n+   * two bytes are stored most significant byte first (i.e., \"big\n+   * endian\") regardless of the native host byte ordering.\n+   * <p>\n+   * As an example, if <code>byte1</code> and <code>byte2</code>\n+   * represent the first and second byte read from the stream\n+   * respectively, they will be transformed to a <code>short</code>. in\n+   * the following manner:\n+   * <p>\n+   * <code>(short)(((byte1 & 0xFF) << 8) | (byte2 & 0xFF)</code>\n+   * <p>\n+   * The value returned is in the range of -32768 to 32767.\n+   * <p>\n+   * This method can read a <code>short</code> written by an object\n+   * implementing the <code>writeShort()</code> method in the\n+   * <code>DataOutput</code> interface.\n+   *\n+   * @return The <code>short</code> value read\n+   *\n+   * @exception EOFException If end of file is reached before reading the value\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final short readShort() throws IOException\n   {\n     return (short) ((readByte() << 8) | readUnsignedByte());\n   }\n \n+  /**\n+   * This method reads 8 unsigned bits into a Java <code>int</code>\n+   * value from the stream. The value returned is in the range of 0 to\n+   * 255.\n+   * <p>\n+   * This method can read an unsigned byte written by an object\n+   * implementing the <code>writeUnsignedByte()</code> method in the\n+   * <code>DataOutput</code> interface.\n+   *\n+   * @return The unsigned bytes value read as a Java <code>int</code>.\n+   *\n+   * @exception EOFException If end of file is reached before reading the value\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final int readUnsignedByte() throws IOException\n   {\n     int i = read();\n@@ -214,16 +505,121 @@ public final int readUnsignedByte() throws IOException\n     return (i & 0xFF);\n   }\n \n+  /**\n+   * This method reads 16 unsigned bits into a Java int value from the stream.\n+   * It operates by reading two bytes from the stream and converting them to \n+   * a single Java <code>int</code>  The two bytes are stored most\n+   * significant byte first (i.e., \"big endian\") regardless of the native\n+   * host byte ordering. \n+   * <p>\n+   * As an example, if <code>byte1</code> and code{byte2</code>\n+   * represent the first and second byte read from the stream\n+   * respectively, they will be transformed to an <code>int</code> in\n+   * the following manner:\n+   * <p>\n+   * <code>(int)(((byte1 & 0xFF) << 8) + (byte2 & 0xFF))</code>\n+   * <p>\n+   * The value returned is in the range of 0 to 65535.\n+   * <p>\n+   * This method can read an unsigned short written by an object\n+   * implementing the <code>writeUnsignedShort()</code> method in the\n+   * <code>DataOutput</code> interface.\n+   *\n+   * @return The unsigned short value read as a Java <code>int</code>\n+   *\n+   * @exception EOFException If end of file is reached before reading the value\n+   * @exception IOException If any other error occurs\n+   */\n   public final int readUnsignedShort() throws IOException\n   {\n     return (readUnsignedByte() << 8) | readUnsignedByte();\n   }\n \n+  /**\n+   * This method reads a <code>String</code> from an input stream that\n+   * is encoded in a modified UTF-8 format.  This format has a leading\n+   * two byte sequence that contains the remaining number of bytes to\n+   * read.  This two byte sequence is read using the\n+   * <code>readUnsignedShort()</code> method of this interface.\n+   * <p>\n+   * After the number of remaining bytes have been determined, these\n+   * bytes are read an transformed into <code>char</code> values.\n+   * These <code>char</code> values are encoded in the stream using\n+   * either a one, two, or three byte format.  The particular format\n+   * in use can be determined by examining the first byte read.\n+   * <p>\n+   * If the first byte has a high order bit of 0, then that character\n+   * consists on only one byte.  This character value consists of\n+   * seven bits that are at positions 0 through 6 of the byte.  As an\n+   * example, if <code>byte1</code> is the byte read from the stream,\n+   * it would be converted to a <code>char</code> like so:\n+   * <p>\n+   * <code>(char)byte1</code>\n+   * <p>\n+   * If the first byte has 110 as its high order bits, then the \n+   * character consists of two bytes.  The bits that make up the character\n+   * value are in positions 0 through 4 of the first byte and bit positions\n+   * 0 through 5 of the second byte.  (The second byte should have \n+   * 10 as its high order bits).  These values are in most significant\n+   * byte first (i.e., \"big endian\") order.\n+   * <p>\n+   * As an example, if <code>byte1</code> and <code>byte2</code> are\n+   * the first two bytes read respectively, and the high order bits of\n+   * them match the patterns which indicate a two byte character\n+   * encoding, then they would be converted to a Java\n+   * <code>char</code> like so:\n+   * <p>\n+   * <code>(char)(((byte1 & 0x1F) << 6) | (byte2 & 0x3F))</code>\n+   * <p>\n+   * If the first byte has a 1110 as its high order bits, then the\n+   * character consists of three bytes.  The bits that make up the character\n+   * value are in positions 0 through 3 of the first byte and bit positions\n+   * 0 through 5 of the other two bytes.  (The second and third bytes should\n+   * have 10 as their high order bits).  These values are in most\n+   * significant byte first (i.e., \"big endian\") order.\n+   * <p>\n+   * As an example, if <code>byte1</code> <code>byte2</code> and\n+   * <code>byte3</code> are the three bytes read, and the high order\n+   * bits of them match the patterns which indicate a three byte\n+   * character encoding, then they would be converted to a Java\n+   * <code>char</code> like so:\n+   * <p>\n+   * <code>(char)(((byte1 & 0x0F) << 12) | ((byte2 & 0x3F) << 6) | (byte3 & 0x3F))</code>\n+   * <p>\n+   * Note that all characters are encoded in the method that requires\n+   * the fewest number of bytes with the exception of the character\n+   * with the value of <code>&#92;u0000</code> which is encoded as two\n+   * bytes.  This is a modification of the UTF standard used to\n+   * prevent C language style <code>NUL</code> values from appearing\n+   * in the byte stream.\n+   * <p>\n+   * This method can read data that was written by an object implementing the\n+   * <code>writeUTF()</code> method in <code>DataOutput</code>\n+   * \n+   * @returns The <code>String</code> read\n+   *\n+   * @exception EOFException If end of file is reached before reading\n+   * the String\n+   * @exception UTFDataFormatException If the data is not in UTF-8 format\n+   * @exception IOException If any other error occurs\n+   *\n+   * @see DataOutput\n+   */\n   public final String readUTF() throws IOException\n   {\n     return readUTF(this);\n   }\n \n+  /**\n+   * This method reads a String encoded in UTF-8 format from the \n+   * specified <code>DataInput</code> source.\n+   *\n+   * @param in The <code>DataInput</code> source to read from\n+   *\n+   * @return The String read from the source\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final static String readUTF(DataInput in) throws IOException\n   {\n     final int UTFlen = in.readUnsignedShort();\n@@ -265,6 +661,18 @@ else if ((buf[i] & 0xF0) == 0xE0)\t// bit pattern 1110xxxx\n     return strbuf.toString();\n   }\n \n+  /**\n+   * This method attempts to skip and discard the specified number of bytes \n+   * in the input stream.  It may actually skip fewer bytes than requested. \n+   * The actual number of bytes skipped is returned.  This method will not\n+   * skip any bytes if passed a negative number of bytes to skip.\n+   *\n+   * @param n The requested number of bytes to skip.\n+   *\n+   * @return The number of bytes actually skipped.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public final int skipBytes(int n) throws IOException\n   {\n     // The contract in the Java Lang. Spec. says that this never"}, {"sha": "76243f30464eab8d5b0c200ade7eb816273fb075", "filename": "libjava/java/lang/reflect/Field.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14203c9cac8bfbabc168aee4df38cb752bbed421/libjava%2Fjava%2Flang%2Freflect%2FField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14203c9cac8bfbabc168aee4df38cb752bbed421/libjava%2Fjava%2Flang%2Freflect%2FField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FField.java?ref=14203c9cac8bfbabc168aee4df38cb752bbed421", "patch": "@@ -257,7 +257,7 @@ public String toString ()\n \tModifier.toString(mods, sbuf);\n \tsbuf.append(' ');\n       }\n-    sbuf.append(getType());\n+    sbuf.append(getType().getName());\n     sbuf.append(' ');\n     sbuf.append(getDeclaringClass().getName());\n     sbuf.append('.');"}]}