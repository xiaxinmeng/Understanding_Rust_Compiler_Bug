{"sha": "93ae92c1d55bcfff73922939264b74f77ddb91a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNhZTkyYzFkNTViY2ZmZjczOTIyOTM5MjY0Yjc0Zjc3ZGRiOTFhNQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-05-03T05:07:56Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-05-03T05:07:56Z"}, "message": "pa.c (output_call): Fix typo/thinko in last change.\n\n\t* pa.c (output_call): Fix typo/thinko in last change.\n\t(output_function_epilogue): Align the data section before\n\temitting deferred plabels.\n\n\tFrom Torbjorn:\n\t* pa.c (before functions): Declare deferred_plabels and\n\tn_deferred_plabels.\n\t(output_call): When generating pic, don't use LP and RP.  Use 32 bit\n\tplabel instead.\n\t(output_function_epilogue): Output plabels accumulated in output_call.\n\nFrom-SVN: r9567", "tree": {"sha": "3473fa1d2355a7ba9deca14e10c8f4e49185c67c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3473fa1d2355a7ba9deca14e10c8f4e49185c67c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93ae92c1d55bcfff73922939264b74f77ddb91a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93ae92c1d55bcfff73922939264b74f77ddb91a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93ae92c1d55bcfff73922939264b74f77ddb91a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93ae92c1d55bcfff73922939264b74f77ddb91a5/comments", "author": null, "committer": null, "parents": [{"sha": "a69e1f6afc37b9203a538f94c89df4efb416847b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a69e1f6afc37b9203a538f94c89df4efb416847b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a69e1f6afc37b9203a538f94c89df4efb416847b"}], "stats": {"total": 63, "additions": 58, "deletions": 5}, "files": [{"sha": "6afbbcf8a69fb48db8029247bd166fb1be10ab0f", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 58, "deletions": 5, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93ae92c1d55bcfff73922939264b74f77ddb91a5/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93ae92c1d55bcfff73922939264b74f77ddb91a5/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=93ae92c1d55bcfff73922939264b74f77ddb91a5", "patch": "@@ -63,6 +63,16 @@ static rtx find_addr_reg ();\n \n unsigned int total_code_bytes;\n \n+/* Variables to handle plabels that we discover are necessary at assembly\n+   output time.  They are output after the currrent function.  */\n+\n+struct defer_plab\n+{\n+  rtx internal_label;\n+  rtx symbol;\n+} *deferred_plabels = 0;\n+int n_deferred_plabels = 0;\n+\n void\n override_options ()\n {\n@@ -2330,8 +2340,8 @@ output_function_epilogue (file, size)\n      FILE *file;\n      int size;\n {\n-\n   rtx insn = get_last_insn ();\n+  int i;\n \n   /* hppa_expand_epilogue does the dirty work now.  We just need\n      to output the assembler directives which denote the end\n@@ -2356,6 +2366,23 @@ output_function_epilogue (file, size)\n     fprintf (file, \"\\tnop\\n\");\n \n   fprintf (file, \"\\t.EXIT\\n\\t.PROCEND\\n\");\n+\n+  /* If we have deferred plabels, then we need to switch into the data\n+     section and align it to a 4 byte boundary before we output the\n+     deferred plabels.  */\n+  if (n_deferred_plabels)\n+    {\n+      data_section ();\n+      ASM_OUTPUT_ALIGN (file, 2);\n+    }\n+\n+  /* Now output the deferred plabels.  */\n+  for (i = 0; i < n_deferred_plabels; i++)\n+    {\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (deferred_plabels[i].internal_label));\n+      ASM_OUTPUT_INT (file, deferred_plabels[i].symbol);\n+    }\n+  n_deferred_plabels = 0;\n }\n \n void\n@@ -4109,10 +4136,36 @@ output_call (insn, call_dest, return_pointer)\n \t    }\n \t}\n \n-      /* Now emit the inline long-call.  */\n-      xoperands[0] = call_dest;\n-      output_asm_insn (\"ldil LP%%%0,%%r22\\n\\tldo RP%%%0(%%r22),%%r22\",\n-\t\t\txoperands);\n+      if (flag_pic)\n+\t{\n+\t  /* We have to load the address of the function using a procedure\n+\t     label (plabel).  The LP and RP relocs don't work reliably for PIC,\n+\t     so we make a plain 32 bit plabel in the data segment instead.  We\n+\t     have to defer outputting it of course...  Not pretty.  */\n+\n+\t  xoperands[0] = gen_label_rtx ();\n+\t  output_asm_insn (\"addil LT%%%0,%%r19\\n\\tldw RT%%%0(%%r1),%%r22\",\n+\t\t\t   xoperands);\n+\t  output_asm_insn (\"ldw 0(0,%%r22),%%r22\", xoperands);\n+\n+\t  if (deferred_plabels == 0)\n+\t    deferred_plabels = (struct defer_plab *)\n+\t      xmalloc (1 * sizeof (struct defer_plab));\n+\t  else\n+\t    deferred_plabels = (struct defer_plab *)\n+\t      xrealloc (deferred_plabels,\n+\t\t\t(n_deferred_plabels + 1) * sizeof (struct defer_plab));\n+\t  deferred_plabels[n_deferred_plabels].internal_label = xoperands[0];\n+\t  deferred_plabels[n_deferred_plabels].symbol = call_dest;\n+\t  n_deferred_plabels++;\n+\t}\n+      else\n+\t{\n+\t  /* Now emit the inline long-call.  */\n+\t  xoperands[0] = call_dest;\n+\t  output_asm_insn (\"ldil LP%%%0,%%r22\\n\\tldo RP%%%0(%%r22),%%r22\",\n+\t\t\t   xoperands);\n+\t}\n \n       /* If TARGET_MILLICODE_LONG_CALLS, then we must use a long-call sequence\n \t to call dyncall!  */"}]}