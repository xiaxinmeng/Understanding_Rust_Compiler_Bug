{"sha": "e14c1050008ecece4bff253a54eac0f15a6467bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE0YzEwNTAwMDhlY2VjZTRiZmYyNTNhNTRlYWMwZjE1YTY0NjdiYg==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-05-18T11:09:44Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-05-18T11:09:44Z"}, "message": "tree-vect-loop-manip.c (vect_create_cond_for_alias_checks): Use new names for group elements access.\n\n\n        * tree-vect-loop-manip.c (vect_create_cond_for_alias_checks): Use new\n        names for group elements access.\n        * tree-vectorizer.h (struct _stmt_vec_info): Use interleaving info for\n        reduction chains as well.  Remove data reference and interleaving\n        related words from the fields names.\n        * tree-vect-loop.c (vect_transform_loop): Use new names for group\n        elements access.\n        * tree-vect-data-refs.c (vect_get_place_in_interleaving_chain,\n         vect_insert_into_interleaving_chain, vect_update_interleaving_chain,\n        vect_update_interleaving_chain, vect_same_range_drs,\n        vect_analyze_data_ref_dependence, vect_update_misalignment_for_peel,\n        vect_verify_datarefs_alignment, vector_alignment_reachable_p,\n        vect_peeling_hash_get_lowest_cost, vect_enhance_data_refs_alignment,\n        vect_analyze_group_access, vect_analyze_data_ref_access,\n        vect_create_data_ref_ptr, vect_transform_strided_load,\n        vect_record_strided_load_vectors): Likewise.\n        * tree-vect-stmts.c (vect_model_simple_cost, vect_model_store_cost,\n        vect_model_load_cost, vectorizable_store, vectorizable_load,\n        vect_remove_stores, new_stmt_vec_info): Likewise.\n        * tree-vect-slp.c (vect_build_slp_tree, \n        vect_supported_slp_permutation_p, vect_analyze_slp_instance): Likewise.\n\nFrom-SVN: r173855", "tree": {"sha": "76686ccad74a56a2bd47836756642d4c2e2860f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76686ccad74a56a2bd47836756642d4c2e2860f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e14c1050008ecece4bff253a54eac0f15a6467bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e14c1050008ecece4bff253a54eac0f15a6467bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e14c1050008ecece4bff253a54eac0f15a6467bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e14c1050008ecece4bff253a54eac0f15a6467bb/comments", "author": null, "committer": null, "parents": [{"sha": "51c213f79189dd3527d1f66137c57bc4e68ec2d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51c213f79189dd3527d1f66137c57bc4e68ec2d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51c213f79189dd3527d1f66137c57bc4e68ec2d1"}], "stats": {"total": 317, "additions": 171, "deletions": 146}, "files": [{"sha": "89575eac4d98600adc24584faa43044a2297434d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e14c1050008ecece4bff253a54eac0f15a6467bb", "patch": "@@ -1,3 +1,27 @@\n+2011-05-18  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks): Use new\n+\tnames for group elements access.\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Use interleaving info for\n+\treduction chains as well.  Remove data reference and interleaving\n+\trelated words from the fields names.\n+\t* tree-vect-loop.c (vect_transform_loop): Use new names for group\n+\telements access.\n+\t* tree-vect-data-refs.c (vect_get_place_in_interleaving_chain,\n+\tvect_insert_into_interleaving_chain, vect_update_interleaving_chain,\n+\tvect_update_interleaving_chain, vect_same_range_drs,\n+\tvect_analyze_data_ref_dependence, vect_update_misalignment_for_peel,\n+\tvect_verify_datarefs_alignment, vector_alignment_reachable_p,\n+\tvect_peeling_hash_get_lowest_cost, vect_enhance_data_refs_alignment,\n+\tvect_analyze_group_access, vect_analyze_data_ref_access,\n+\tvect_create_data_ref_ptr, vect_transform_strided_load,\n+\tvect_record_strided_load_vectors): Likewise.\n+\t* tree-vect-stmts.c (vect_model_simple_cost, vect_model_store_cost,\n+\tvect_model_load_cost, vectorizable_store, vectorizable_load,\n+\tvect_remove_stores, new_stmt_vec_info): Likewise.\n+\t* tree-vect-slp.c (vect_build_slp_tree,\n+\tvect_supported_slp_permutation_p, vect_analyze_slp_instance): Likewise.\n+\n 2011-05-18  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/48989"}, {"sha": "8d3b2533dc4e6cd1b4dd25d681c77ed1b6312a4e", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 77, "deletions": 77, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=e14c1050008ecece4bff253a54eac0f15a6467bb", "patch": "@@ -135,13 +135,13 @@ vect_get_place_in_interleaving_chain (gimple stmt, gimple first_stmt)\n   gimple next_stmt = first_stmt;\n   int result = 0;\n \n-  if (first_stmt != DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)))\n+  if (first_stmt != GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     return -1;\n \n   while (next_stmt && next_stmt != stmt)\n     {\n       result++;\n-      next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+      next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n     }\n \n   if (next_stmt)\n@@ -164,25 +164,25 @@ vect_insert_into_interleaving_chain (struct data_reference *dra,\n   stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n   stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n \n-  prev = DR_GROUP_FIRST_DR (stmtinfo_b);\n-  next = DR_GROUP_NEXT_DR (vinfo_for_stmt (prev));\n+  prev = GROUP_FIRST_ELEMENT (stmtinfo_b);\n+  next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev));\n   while (next)\n     {\n       next_init = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n       if (tree_int_cst_compare (next_init, DR_INIT (dra)) > 0)\n \t{\n \t  /* Insert here.  */\n-\t  DR_GROUP_NEXT_DR (vinfo_for_stmt (prev)) = DR_STMT (dra);\n-\t  DR_GROUP_NEXT_DR (stmtinfo_a) = next;\n+\t  GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev)) = DR_STMT (dra);\n+\t  GROUP_NEXT_ELEMENT (stmtinfo_a) = next;\n \t  return;\n \t}\n       prev = next;\n-      next = DR_GROUP_NEXT_DR (vinfo_for_stmt (prev));\n+      next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev));\n     }\n \n   /* We got to the end of the list. Insert here.  */\n-  DR_GROUP_NEXT_DR (vinfo_for_stmt (prev)) = DR_STMT (dra);\n-  DR_GROUP_NEXT_DR (stmtinfo_a) = NULL;\n+  GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev)) = DR_STMT (dra);\n+  GROUP_NEXT_ELEMENT (stmtinfo_a) = NULL;\n }\n \n \n@@ -221,27 +221,27 @@ vect_update_interleaving_chain (struct data_reference *drb,\n   gimple node, prev, next, first_stmt;\n \n   /* 1. New stmts - both DRA and DRB are not a part of any chain.   */\n-  if (!DR_GROUP_FIRST_DR (stmtinfo_a) && !DR_GROUP_FIRST_DR (stmtinfo_b))\n+  if (!GROUP_FIRST_ELEMENT (stmtinfo_a) && !GROUP_FIRST_ELEMENT (stmtinfo_b))\n     {\n-      DR_GROUP_FIRST_DR (stmtinfo_a) = DR_STMT (drb);\n-      DR_GROUP_FIRST_DR (stmtinfo_b) = DR_STMT (drb);\n-      DR_GROUP_NEXT_DR (stmtinfo_b) = DR_STMT (dra);\n+      GROUP_FIRST_ELEMENT (stmtinfo_a) = DR_STMT (drb);\n+      GROUP_FIRST_ELEMENT (stmtinfo_b) = DR_STMT (drb);\n+      GROUP_NEXT_ELEMENT (stmtinfo_b) = DR_STMT (dra);\n       return;\n     }\n \n   /* 2. DRB is a part of a chain and DRA is not.  */\n-  if (!DR_GROUP_FIRST_DR (stmtinfo_a) && DR_GROUP_FIRST_DR (stmtinfo_b))\n+  if (!GROUP_FIRST_ELEMENT (stmtinfo_a) && GROUP_FIRST_ELEMENT (stmtinfo_b))\n     {\n-      DR_GROUP_FIRST_DR (stmtinfo_a) = DR_GROUP_FIRST_DR (stmtinfo_b);\n+      GROUP_FIRST_ELEMENT (stmtinfo_a) = GROUP_FIRST_ELEMENT (stmtinfo_b);\n       /* Insert DRA into the chain of DRB.  */\n       vect_insert_into_interleaving_chain (dra, drb);\n       return;\n     }\n \n   /* 3. DRA is a part of a chain and DRB is not.  */\n-  if (DR_GROUP_FIRST_DR (stmtinfo_a) && !DR_GROUP_FIRST_DR (stmtinfo_b))\n+  if (GROUP_FIRST_ELEMENT (stmtinfo_a) && !GROUP_FIRST_ELEMENT (stmtinfo_b))\n     {\n-      gimple old_first_stmt = DR_GROUP_FIRST_DR (stmtinfo_a);\n+      gimple old_first_stmt = GROUP_FIRST_ELEMENT (stmtinfo_a);\n       tree init_old = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (\n \t\t\t\t\t\t\t      old_first_stmt)));\n       gimple tmp;\n@@ -251,29 +251,29 @@ vect_update_interleaving_chain (struct data_reference *drb,\n \t  /* DRB's init is smaller than the init of the stmt previously marked\n \t     as the first stmt of the interleaving chain of DRA.  Therefore, we\n \t     update FIRST_STMT and put DRB in the head of the list.  */\n-\t  DR_GROUP_FIRST_DR (stmtinfo_b) = DR_STMT (drb);\n-\t  DR_GROUP_NEXT_DR (stmtinfo_b) = old_first_stmt;\n+\t  GROUP_FIRST_ELEMENT (stmtinfo_b) = DR_STMT (drb);\n+\t  GROUP_NEXT_ELEMENT (stmtinfo_b) = old_first_stmt;\n \n \t  /* Update all the stmts in the list to point to the new FIRST_STMT.  */\n \t  tmp = old_first_stmt;\n \t  while (tmp)\n \t    {\n-\t      DR_GROUP_FIRST_DR (vinfo_for_stmt (tmp)) = DR_STMT (drb);\n-\t      tmp = DR_GROUP_NEXT_DR (vinfo_for_stmt (tmp));\n+\t      GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp)) = DR_STMT (drb);\n+\t      tmp = GROUP_NEXT_ELEMENT (vinfo_for_stmt (tmp));\n \t    }\n \t}\n       else\n \t{\n \t  /* Insert DRB in the list of DRA.  */\n \t  vect_insert_into_interleaving_chain (drb, dra);\n-\t  DR_GROUP_FIRST_DR (stmtinfo_b) = DR_GROUP_FIRST_DR (stmtinfo_a);\n+\t  GROUP_FIRST_ELEMENT (stmtinfo_b) = GROUP_FIRST_ELEMENT (stmtinfo_a);\n \t}\n       return;\n     }\n \n   /* 4. both DRA and DRB are in some interleaving chains.  */\n-  first_a = DR_GROUP_FIRST_DR (stmtinfo_a);\n-  first_b = DR_GROUP_FIRST_DR (stmtinfo_b);\n+  first_a = GROUP_FIRST_ELEMENT (stmtinfo_a);\n+  first_b = GROUP_FIRST_ELEMENT (stmtinfo_b);\n   if (first_a == first_b)\n     return;\n   init_dra_chain = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (first_a)));\n@@ -284,47 +284,47 @@ vect_update_interleaving_chain (struct data_reference *drb,\n       /* Insert the nodes of DRA chain into the DRB chain.\n \t After inserting a node, continue from this node of the DRB chain (don't\n          start from the beginning.  */\n-      node = DR_GROUP_FIRST_DR (stmtinfo_a);\n-      prev = DR_GROUP_FIRST_DR (stmtinfo_b);\n+      node = GROUP_FIRST_ELEMENT (stmtinfo_a);\n+      prev = GROUP_FIRST_ELEMENT (stmtinfo_b);\n       first_stmt = first_b;\n     }\n   else\n     {\n       /* Insert the nodes of DRB chain into the DRA chain.\n \t After inserting a node, continue from this node of the DRA chain (don't\n          start from the beginning.  */\n-      node = DR_GROUP_FIRST_DR (stmtinfo_b);\n-      prev = DR_GROUP_FIRST_DR (stmtinfo_a);\n+      node = GROUP_FIRST_ELEMENT (stmtinfo_b);\n+      prev = GROUP_FIRST_ELEMENT (stmtinfo_a);\n       first_stmt = first_a;\n     }\n \n   while (node)\n     {\n       node_init = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (node)));\n-      next = DR_GROUP_NEXT_DR (vinfo_for_stmt (prev));\n+      next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev));\n       while (next)\n \t{\n \t  next_init = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n \t  if (tree_int_cst_compare (next_init, node_init) > 0)\n \t    {\n \t      /* Insert here.  */\n-\t      DR_GROUP_NEXT_DR (vinfo_for_stmt (prev)) = node;\n-\t      DR_GROUP_NEXT_DR (vinfo_for_stmt (node)) = next;\n+\t      GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev)) = node;\n+\t      GROUP_NEXT_ELEMENT (vinfo_for_stmt (node)) = next;\n \t      prev = node;\n \t      break;\n \t    }\n \t  prev = next;\n-\t  next = DR_GROUP_NEXT_DR (vinfo_for_stmt (prev));\n+\t  next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev));\n \t}\n       if (!next)\n \t{\n \t  /* We got to the end of the list. Insert here.  */\n-\t  DR_GROUP_NEXT_DR (vinfo_for_stmt (prev)) = node;\n-\t  DR_GROUP_NEXT_DR (vinfo_for_stmt (node)) = NULL;\n+\t  GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev)) = node;\n+\t  GROUP_NEXT_ELEMENT (vinfo_for_stmt (node)) = NULL;\n \t  prev = node;\n \t}\n-      DR_GROUP_FIRST_DR (vinfo_for_stmt (node)) = first_stmt;\n-      node = DR_GROUP_NEXT_DR (vinfo_for_stmt (node));\n+      GROUP_FIRST_ELEMENT (vinfo_for_stmt (node)) = first_stmt;\n+      node = GROUP_NEXT_ELEMENT (vinfo_for_stmt (node));\n     }\n }\n \n@@ -482,10 +482,10 @@ vect_same_range_drs (data_reference_p dr_i, data_reference_p dr_j)\n   gimple stmt_j = DR_STMT (dr_j);\n \n   if (operand_equal_p (DR_REF (dr_i), DR_REF (dr_j), 0)\n-      || (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_i))\n-\t    && DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_j))\n-\t    && (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_i))\n-\t\t== DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_j)))))\n+      || (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_i))\n+\t    && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_j))\n+\t    && (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_i))\n+\t\t== GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_j)))))\n     return true;\n   else\n     return false;\n@@ -685,11 +685,11 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n           /* For interleaving, mark that there is a read-write dependency if\n              necessary. We check before that one of the data-refs is store.  */\n           if (DR_IS_READ (dra))\n-            DR_GROUP_READ_WRITE_DEPENDENCE (stmtinfo_a) = true;\n+            GROUP_READ_WRITE_DEPENDENCE (stmtinfo_a) = true;\n \t  else\n             {\n               if (DR_IS_READ (drb))\n-                DR_GROUP_READ_WRITE_DEPENDENCE (stmtinfo_b) = true;\n+                GROUP_READ_WRITE_DEPENDENCE (stmtinfo_b) = true;\n \t    }\n \n \t  continue;\n@@ -992,9 +992,9 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n  /* For interleaved data accesses the step in the loop must be multiplied by\n      the size of the interleaving group.  */\n   if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n-    dr_size *= DR_GROUP_SIZE (vinfo_for_stmt (DR_GROUP_FIRST_DR (stmt_info)));\n+    dr_size *= GROUP_SIZE (vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info)));\n   if (STMT_VINFO_STRIDED_ACCESS (peel_stmt_info))\n-    dr_peel_size *= DR_GROUP_SIZE (peel_stmt_info);\n+    dr_peel_size *= GROUP_SIZE (peel_stmt_info);\n \n   /* It can be assumed that the data refs with the same alignment as dr_peel\n      are aligned in the vector loop.  */\n@@ -1054,7 +1054,7 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       /* For interleaving, only the alignment of the first access matters. \n          Skip statements marked as not vectorizable.  */\n       if ((STMT_VINFO_STRIDED_ACCESS (stmt_info)\n-           && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n+           && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n           || !STMT_VINFO_VECTORIZABLE (stmt_info))\n         continue;\n \n@@ -1109,7 +1109,7 @@ vector_alignment_reachable_p (struct data_reference *dr)\n       elem_size = GET_MODE_SIZE (TYPE_MODE (vectype)) / nelements;\n       mis_in_elements = DR_MISALIGNMENT (dr) / elem_size;\n \n-      if ((nelements - mis_in_elements) % DR_GROUP_SIZE (stmt_info))\n+      if ((nelements - mis_in_elements) % GROUP_SIZE (stmt_info))\n \treturn false;\n     }\n \n@@ -1282,7 +1282,7 @@ vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n       /* For interleaving, only the alignment of the first access\n          matters.  */\n       if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n-          && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n+          && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n         continue;\n \n       save_misalignment = DR_MISALIGNMENT (dr);\n@@ -1494,7 +1494,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       /* For interleaving, only the alignment of the first access\n          matters.  */\n       if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n-          && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n+          && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n         continue;\n \n       supportable_dr_alignment = vect_supportable_dr_alignment (dr, true);\n@@ -1732,7 +1732,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t     by the group size.  */\n \t  stmt_info = vinfo_for_stmt (DR_STMT (dr0));\n \t  if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n-\t    npeel /= DR_GROUP_SIZE (stmt_info);\n+\t    npeel /= GROUP_SIZE (stmt_info);\n \n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"Try peeling by %d\", npeel);\n@@ -1751,7 +1751,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  /* For interleaving, only the alignment of the first access\n             matters.  */\n \t  if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n-\t      && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n+\t      && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n \t    continue;\n \n \t  save_misalignment = DR_MISALIGNMENT (dr);\n@@ -1833,7 +1833,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t     matters.  */\n \t  if (aligned_access_p (dr)\n \t      || (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n-\t\t  && DR_GROUP_FIRST_DR (stmt_info) != stmt))\n+\t\t  && GROUP_FIRST_ELEMENT (stmt_info) != stmt))\n \t    continue;\n \n \t  supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n@@ -2051,7 +2051,7 @@ vect_analyze_group_access (struct data_reference *dr)\n   stride = dr_step / type_size;\n \n   /* Not consecutive access is possible only if it is a part of interleaving.  */\n-  if (!DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)))\n+  if (!GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n       /* Check if it this DR is a part of interleaving, and is a single\n \t element of the group that is accessed in the loop.  */\n@@ -2063,8 +2063,8 @@ vect_analyze_group_access (struct data_reference *dr)\n \t  && stride > 0\n \t  && exact_log2 (stride) != -1)\n \t{\n-\t  DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) = stmt;\n-\t  DR_GROUP_SIZE (vinfo_for_stmt (stmt)) = stride;\n+\t  GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = stmt;\n+\t  GROUP_SIZE (vinfo_for_stmt (stmt)) = stride;\n \t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n \t    {\n \t      fprintf (vect_dump, \"Detected single element interleaving \");\n@@ -2091,10 +2091,10 @@ vect_analyze_group_access (struct data_reference *dr)\n       return false;\n     }\n \n-  if (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) == stmt)\n+  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) == stmt)\n     {\n       /* First stmt in the interleaving chain. Check the chain.  */\n-      gimple next = DR_GROUP_NEXT_DR (vinfo_for_stmt (stmt));\n+      gimple next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n       struct data_reference *data_ref = dr;\n       unsigned int count = 1;\n       tree next_step;\n@@ -2121,8 +2121,8 @@ vect_analyze_group_access (struct data_reference *dr)\n \n               /* Check that there is no load-store dependencies for this loads\n                  to prevent a case of load-store-load to the same location.  */\n-              if (DR_GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (next))\n-                  || DR_GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (prev)))\n+              if (GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (next))\n+                  || GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (prev)))\n                 {\n                   if (vect_print_dump_info (REPORT_DETAILS))\n                     fprintf (vect_dump,\n@@ -2131,10 +2131,10 @@ vect_analyze_group_access (struct data_reference *dr)\n                 }\n \n               /* For load use the same data-ref load.  */\n-              DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next)) = prev;\n+              GROUP_SAME_DR_STMT (vinfo_for_stmt (next)) = prev;\n \n               prev = next;\n-              next = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));\n+              next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n               continue;\n             }\n           prev = next;\n@@ -2168,11 +2168,11 @@ vect_analyze_group_access (struct data_reference *dr)\n \t    }\n \n           /* Store the gap from the previous member of the group. If there is no\n-             gap in the access, DR_GROUP_GAP is always 1.  */\n-          DR_GROUP_GAP (vinfo_for_stmt (next)) = diff;\n+             gap in the access, GROUP_GAP is always 1.  */\n+          GROUP_GAP (vinfo_for_stmt (next)) = diff;\n \n           prev_init = DR_INIT (data_ref);\n-          next = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));\n+          next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n           /* Count the number of data-refs in the chain.  */\n           count++;\n         }\n@@ -2203,7 +2203,7 @@ vect_analyze_group_access (struct data_reference *dr)\n               /* There is a gap after the last load in the group. This gap is a\n                  difference between the stride and the number of elements. When\n                  there is no gap, this difference should be 0.  */\n-              DR_GROUP_GAP (vinfo_for_stmt (stmt)) = stride - count;\n+              GROUP_GAP (vinfo_for_stmt (stmt)) = stride - count;\n             }\n           else\n             {\n@@ -2230,7 +2230,7 @@ vect_analyze_group_access (struct data_reference *dr)\n       if (stride == 0)\n         stride = count;\n \n-      DR_GROUP_SIZE (vinfo_for_stmt (stmt)) = stride;\n+      GROUP_SIZE (vinfo_for_stmt (stmt)) = stride;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"Detected interleaving of size %d\", (int)stride);\n \n@@ -2284,7 +2284,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n     {\n       /* Interleaved accesses are not yet supported within outer-loop\n         vectorization for references in the inner-loop.  */\n-      DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) = NULL;\n+      GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n \n       /* For the rest of the analysis we use the outer-loop step.  */\n       step = STMT_VINFO_DR_STEP (stmt_info);\n@@ -2307,7 +2307,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \t  && !compare_tree_int (TYPE_SIZE_UNIT (scalar_type), -dr_step)))\n     {\n       /* Mark that it is not interleaving.  */\n-      DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) = NULL;\n+      GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n       return true;\n     }\n \n@@ -3081,9 +3081,9 @@ vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,\n     }\n \n   /* Likewise for any of the data references in the stmt group.  */\n-  else if (STMT_VINFO_DR_GROUP_SIZE (stmt_info) > 1)\n+  else if (STMT_VINFO_GROUP_SIZE (stmt_info) > 1)\n     {\n-      gimple orig_stmt = STMT_VINFO_DR_GROUP_FIRST_DR (stmt_info);\n+      gimple orig_stmt = STMT_VINFO_GROUP_FIRST_ELEMENT (stmt_info);\n       do\n \t{\n \t  tree lhs = gimple_assign_lhs (orig_stmt);\n@@ -3099,7 +3099,7 @@ vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,\n \t      break;\n \t    }\n \n-\t  orig_stmt = STMT_VINFO_DR_GROUP_NEXT_DR (vinfo_for_stmt (orig_stmt));\n+\t  orig_stmt = STMT_VINFO_GROUP_NEXT_ELEMENT (vinfo_for_stmt (orig_stmt));\n \t}\n       while (orig_stmt);\n     }\n@@ -4048,7 +4048,7 @@ vect_transform_strided_load (gimple stmt, VEC(tree,heap) *dr_chain, int size,\n void\n vect_record_strided_load_vectors (gimple stmt, VEC(tree,heap) *result_chain)\n {\n-  gimple first_stmt = DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt));\n+  gimple first_stmt = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n   gimple next_stmt, new_stmt;\n   unsigned int i, gap_count;\n   tree tmp_data_ref;\n@@ -4066,11 +4066,11 @@ vect_record_strided_load_vectors (gimple stmt, VEC(tree,heap) *result_chain)\n       /* Skip the gaps.  Loads created for the gaps will be removed by dead\n        code elimination pass later.  No need to check for the first stmt in\n        the group, since it always exists.\n-       DR_GROUP_GAP is the number of steps in elements from the previous\n-       access (if there is no gap DR_GROUP_GAP is 1).  We skip loads that\n+       GROUP_GAP is the number of steps in elements from the previous\n+       access (if there is no gap GROUP_GAP is 1).  We skip loads that\n        correspond to the gaps.  */\n       if (next_stmt != first_stmt\n-          && gap_count < DR_GROUP_GAP (vinfo_for_stmt (next_stmt)))\n+          && gap_count < GROUP_GAP (vinfo_for_stmt (next_stmt)))\n       {\n         gap_count++;\n         continue;\n@@ -4086,7 +4086,7 @@ vect_record_strided_load_vectors (gimple stmt, VEC(tree,heap) *result_chain)\n \t    STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt)) = new_stmt;\n \t  else\n             {\n-              if (!DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n+              if (!GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n                 {\n  \t          gimple prev_stmt =\n \t\t    STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt));\n@@ -4104,12 +4104,12 @@ vect_record_strided_load_vectors (gimple stmt, VEC(tree,heap) *result_chain)\n                 }\n             }\n \n-\t  next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+\t  next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n \t  gap_count = 1;\n \t  /* If NEXT_STMT accesses the same DR as the previous statement,\n \t     put the same TMP_DATA_REF as its vectorized statement; otherwise\n \t     get the next data-ref from RESULT_CHAIN.  */\n-\t  if (!next_stmt || !DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n+\t  if (!next_stmt || !GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n \t    break;\n         }\n     }"}, {"sha": "7619d74b910fd72db0b8ac410aadbffb4beab6c7", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=e14c1050008ecece4bff253a54eac0f15a6467bb", "patch": "@@ -2437,7 +2437,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n \n       dr_a = DDR_A (ddr);\n       stmt_a = DR_STMT (DDR_A (ddr));\n-      dr_group_first_a = DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_a));\n+      dr_group_first_a = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_a));\n       if (dr_group_first_a)\n         {\n \t  stmt_a = dr_group_first_a;\n@@ -2446,7 +2446,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n \n       dr_b = DDR_B (ddr);\n       stmt_b = DR_STMT (DDR_B (ddr));\n-      dr_group_first_b = DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_b));\n+      dr_group_first_b = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_b));\n       if (dr_group_first_b)\n         {\n \t  stmt_b = dr_group_first_b;"}, {"sha": "d786e679e76d4c8ea0640f8b10c76defcee5f0af", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e14c1050008ecece4bff253a54eac0f15a6467bb", "patch": "@@ -4924,7 +4924,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t  /* Interleaving. If IS_STORE is TRUE, the vectorization of the\n \t\t     interleaving chain was completed - free all the stores in\n \t\t     the chain.  */\n-\t\t  vect_remove_stores (DR_GROUP_FIRST_DR (stmt_info));\n+\t\t  vect_remove_stores (GROUP_FIRST_ELEMENT (stmt_info));\n \t\t  gsi_remove (&si, true);\n \t\t  continue;\n \t\t}"}, {"sha": "8dd07dc4da933efd6cba5d8267498629d3241109", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=e14c1050008ecece4bff253a54eac0f15a6467bb", "patch": "@@ -509,10 +509,10 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t    {\n \t      /* Load.  */\n               /* FORNOW: Check that there is no gap between the loads.  */\n-              if ((DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) == stmt\n-                   && DR_GROUP_GAP (vinfo_for_stmt (stmt)) != 0)\n-                  || (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) != stmt\n-                      && DR_GROUP_GAP (vinfo_for_stmt (stmt)) != 1))\n+              if ((GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) == stmt\n+                   && GROUP_GAP (vinfo_for_stmt (stmt)) != 0)\n+                  || (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) != stmt\n+                      && GROUP_GAP (vinfo_for_stmt (stmt)) != 1))\n                 {\n                   if (vect_print_dump_info (REPORT_SLP))\n                     {\n@@ -526,7 +526,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n               /* Check that the size of interleaved loads group is not\n                  greater than the SLP group size.  */\n-              if (DR_GROUP_SIZE (vinfo_for_stmt (stmt)) > ncopies * group_size)\n+              if (GROUP_SIZE (vinfo_for_stmt (stmt)) > ncopies * group_size)\n                 {\n                   if (vect_print_dump_info (REPORT_SLP))\n                     {\n@@ -539,7 +539,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                   return false;\n                 }\n \n-              first_load = DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt));\n+              first_load = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n               if (prev_first_load)\n                 {\n                   /* Check that there are no loads from different interleaving\n@@ -784,7 +784,7 @@ vect_supported_slp_permutation_p (slp_instance instance)\n {\n   slp_tree node = VEC_index (slp_tree, SLP_INSTANCE_LOADS (instance), 0);\n   gimple stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (node), 0);\n-  gimple first_load = DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt));\n+  gimple first_load = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n   VEC (slp_tree, heap) *sorted_loads = NULL;\n   int index;\n   slp_tree *tmp_loads = NULL;\n@@ -803,7 +803,7 @@ vect_supported_slp_permutation_p (slp_instance instance)\n     {\n       gimple scalar_stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (load), 0);\n       /* Check that the loads are all in the same interleaving chain.  */\n-      if (DR_GROUP_FIRST_DR (vinfo_for_stmt (scalar_stmt)) != first_load)\n+      if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (scalar_stmt)) != first_load)\n         {\n           if (vect_print_dump_info (REPORT_DETAILS))\n             {\n@@ -933,7 +933,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n                 first = stmt;\n               else\n                 {\n-                  if (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) != first)\n+                  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) != first)\n                     {\n                       if (complex_numbers != 2)\n                         return false;\n@@ -948,7 +948,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n                       other_node_first = VEC_index (gimple, \n                                 SLP_TREE_SCALAR_STMTS (other_complex_node), 0);\n \n-                      if (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) \n+                      if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n                           != other_node_first)\n                        return false;\n                     }\n@@ -1142,7 +1142,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n {\n   slp_instance new_instance;\n   slp_tree node = XNEW (struct _slp_tree);\n-  unsigned int group_size = DR_GROUP_SIZE (vinfo_for_stmt (stmt));\n+  unsigned int group_size = GROUP_SIZE (vinfo_for_stmt (stmt));\n   unsigned int unrolling_factor = 1, nunits;\n   tree vectype, scalar_type = NULL_TREE;\n   gimple next;\n@@ -1157,7 +1157,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n     {\n       scalar_type = TREE_TYPE (DR_REF (dr));\n       vectype = get_vectype_for_scalar_type (scalar_type);\n-      group_size = DR_GROUP_SIZE (vinfo_for_stmt (stmt));\n+      group_size = GROUP_SIZE (vinfo_for_stmt (stmt));\n     }\n   else\n     {\n@@ -1204,7 +1204,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       while (next)\n         {\n           VEC_safe_push (gimple, heap, SLP_TREE_SCALAR_STMTS (node), next);\n-          next = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));\n+          next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n         }\n     }\n   else"}, {"sha": "33aab9bc2ea4e33f7b6540fc894ae648f0e3cf60", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e14c1050008ecece4bff253a54eac0f15a6467bb", "patch": "@@ -708,10 +708,10 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n static int\n vect_cost_strided_group_size (stmt_vec_info stmt_info)\n {\n-  gimple first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+  gimple first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n \n   if (first_stmt == STMT_VINFO_STMT (stmt_info))\n-    return DR_GROUP_SIZE (stmt_info);\n+    return GROUP_SIZE (stmt_info);\n \n   return 1;\n }\n@@ -740,7 +740,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n     outside_cost = vect_get_stmt_cost (scalar_to_vec); \n \n   /* Strided access?  */\n-  if (DR_GROUP_FIRST_DR (stmt_info))\n+  if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n     {\n       if (slp_node)\n         {\n@@ -749,7 +749,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n         }\n       else\n         {\n-          first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+          first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n           group_size = vect_cost_strided_group_size (stmt_info);\n         }\n \n@@ -855,8 +855,8 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, bool load_lanes_p,\n     return;\n \n   /* Strided accesses?  */\n-  first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n-  if (first_stmt && !slp_node)\n+  first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+  if (STMT_VINFO_STRIDED_ACCESS (stmt_info) && first_stmt && !slp_node)\n     {\n       group_size = vect_cost_strided_group_size (stmt_info);\n       first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n@@ -885,7 +885,8 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, bool load_lanes_p,\n \n   /* The loads themselves.  */\n   vect_get_load_cost (first_dr, ncopies,\n-         ((!DR_GROUP_FIRST_DR (stmt_info)) || group_size > 1 || slp_node),\n+         ((!STMT_VINFO_STRIDED_ACCESS (stmt_info)) || group_size > 1\n+          || slp_node),\n          &inside_cost, &outside_cost);\n \n   if (vect_print_dump_info (REPORT_COST))\n@@ -3515,10 +3516,10 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n     {\n       strided_store = true;\n-      first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n       if (!slp && !PURE_SLP_STMT (stmt_info))\n \t{\n-\t  group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+\t  group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n \t  if (vect_store_lanes_supported (vectype, group_size))\n \t    store_lanes_p = true;\n \t  else if (!vect_strided_store_supported (vectype, group_size))\n@@ -3529,7 +3530,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t{\n           /* STMT is the leader of the group. Check the operands of all the\n              stmts of the group.  */\n-          next_stmt = DR_GROUP_NEXT_DR (stmt_info);\n+          next_stmt = GROUP_NEXT_ELEMENT (stmt_info);\n           while (next_stmt)\n             {\n \t      gcc_assert (gimple_assign_single_p (next_stmt));\n@@ -3541,7 +3542,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n                     fprintf (vect_dump, \"use not simple.\");\n                   return false;\n                 }\n-              next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+              next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n             }\n         }\n     }\n@@ -3558,17 +3559,17 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (strided_store)\n     {\n       first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-      group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n \n-      DR_GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))++;\n+      GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))++;\n \n       /* FORNOW */\n       gcc_assert (!loop || !nested_in_vect_loop_p (loop, stmt));\n \n       /* We vectorize all the stmts of the interleaving group when we\n \t reach the last stmt in the group.  */\n-      if (DR_GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))\n-\t  < DR_GROUP_SIZE (vinfo_for_stmt (first_stmt))\n+      if (GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))\n+\t  < GROUP_SIZE (vinfo_for_stmt (first_stmt))\n \t  && !slp)\n \t{\n \t  *vec_stmt = NULL;\n@@ -3695,7 +3696,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t\t\t\t    NULL);\n \t\t  VEC_quick_push(tree, dr_chain, vec_oprnd);\n \t\t  VEC_quick_push(tree, oprnds, vec_oprnd);\n-\t\t  next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+\t\t  next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n \t\t}\n \t    }\n \n@@ -3808,7 +3809,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      if (slp)\n \t\tcontinue;\n \n-\t      next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+\t      next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n \t      if (!next_stmt)\n \t\tbreak;\n \t    }\n@@ -4052,10 +4053,10 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       /* FORNOW */\n       gcc_assert (! nested_in_vect_loop);\n \n-      first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n       if (!slp && !PURE_SLP_STMT (stmt_info))\n \t{\n-\t  group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+\t  group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n \t  if (vect_load_lanes_supported (vectype, group_size))\n \t    load_lanes_p = true;\n \t  else if (!vect_strided_load_supported (vectype, group_size))\n@@ -4096,15 +4097,15 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   if (strided_load)\n     {\n-      first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n       /* Check if the chain of loads is already vectorized.  */\n       if (STMT_VINFO_VEC_STMT (vinfo_for_stmt (first_stmt)))\n \t{\n \t  *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n \t  return true;\n \t}\n       first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-      group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n \n       /* VEC_NUM is the number of vect stmts to be created for this group.  */\n       if (slp)\n@@ -5138,7 +5139,7 @@ vect_remove_stores (gimple first_stmt)\n       /* Free the attached stmt_vec_info and remove the stmt.  */\n       next_si = gsi_for_stmt (next);\n       gsi_remove (&next_si, true);\n-      tmp = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));\n+      tmp = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n       free_stmt_vec_info (next);\n       next = tmp;\n     }\n@@ -5185,13 +5186,13 @@ new_stmt_vec_info (gimple stmt, loop_vec_info loop_vinfo,\n   STMT_VINFO_INSIDE_OF_LOOP_COST (res) = 0;\n   STMT_VINFO_OUTSIDE_OF_LOOP_COST (res) = 0;\n   STMT_SLP_TYPE (res) = loop_vect;\n-  DR_GROUP_FIRST_DR (res) = NULL;\n-  DR_GROUP_NEXT_DR (res) = NULL;\n-  DR_GROUP_SIZE (res) = 0;\n-  DR_GROUP_STORE_COUNT (res) = 0;\n-  DR_GROUP_GAP (res) = 0;\n-  DR_GROUP_SAME_DR_STMT (res) = NULL;\n-  DR_GROUP_READ_WRITE_DEPENDENCE (res) = false;\n+  GROUP_FIRST_ELEMENT (res) = NULL;\n+  GROUP_NEXT_ELEMENT (res) = NULL;\n+  GROUP_SIZE (res) = 0;\n+  GROUP_STORE_COUNT (res) = 0;\n+  GROUP_GAP (res) = 0;\n+  GROUP_SAME_DR_STMT (res) = NULL;\n+  GROUP_READ_WRITE_DEPENDENCE (res) = false;\n \n   return res;\n }"}, {"sha": "1f5e3efe7057c85a05732fbd1f534433f6771f11", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14c1050008ecece4bff253a54eac0f15a6467bb/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=e14c1050008ecece4bff253a54eac0f15a6467bb", "patch": "@@ -468,15 +468,15 @@ typedef struct _stmt_vec_info {\n   /*  Whether the stmt is SLPed, loop-based vectorized, or both.  */\n   enum slp_vect_type slp_type;\n \n-  /* Interleaving info.  */\n-  /* First data-ref in the interleaving group.  */\n-  gimple first_dr;\n-  /* Pointer to the next data-ref in the group.  */\n-  gimple next_dr;\n-  /* In case that two or more stmts share data-ref, this is the pointer to the\n-     previously detected stmt with the same dr.  */\n+  /* Interleaving and reduction chains info.  */\n+  /* First element in the group.  */\n+  gimple first_element;\n+  /* Pointer to the next element in the group.  */\n+  gimple next_element;\n+  /* For data-refs, in case that two or more stmts share data-ref, this is the\n+     pointer to the previously detected stmt with the same dr.  */\n   gimple same_dr_stmt;\n-  /* The size of the interleaving group.  */\n+  /* The size of the group.  */\n   unsigned int size;\n   /* For stores, number of stores from this group seen. We vectorize the last\n      one.  */\n@@ -527,22 +527,22 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_RELATED_STMT(S)         (S)->related_stmt\n #define STMT_VINFO_SAME_ALIGN_REFS(S)      (S)->same_align_refs\n #define STMT_VINFO_DEF_TYPE(S)             (S)->def_type\n-#define STMT_VINFO_DR_GROUP_FIRST_DR(S)    (S)->first_dr\n-#define STMT_VINFO_DR_GROUP_NEXT_DR(S)     (S)->next_dr\n-#define STMT_VINFO_DR_GROUP_SIZE(S)        (S)->size\n-#define STMT_VINFO_DR_GROUP_STORE_COUNT(S) (S)->store_count\n-#define STMT_VINFO_DR_GROUP_GAP(S)         (S)->gap\n-#define STMT_VINFO_DR_GROUP_SAME_DR_STMT(S)(S)->same_dr_stmt\n-#define STMT_VINFO_DR_GROUP_READ_WRITE_DEPENDENCE(S)  (S)->read_write_dep\n-#define STMT_VINFO_STRIDED_ACCESS(S)      ((S)->first_dr != NULL)\n-\n-#define DR_GROUP_FIRST_DR(S)               (S)->first_dr\n-#define DR_GROUP_NEXT_DR(S)                (S)->next_dr\n-#define DR_GROUP_SIZE(S)                   (S)->size\n-#define DR_GROUP_STORE_COUNT(S)            (S)->store_count\n-#define DR_GROUP_GAP(S)                    (S)->gap\n-#define DR_GROUP_SAME_DR_STMT(S)           (S)->same_dr_stmt\n-#define DR_GROUP_READ_WRITE_DEPENDENCE(S)  (S)->read_write_dep\n+#define STMT_VINFO_GROUP_FIRST_ELEMENT(S)  (S)->first_element\n+#define STMT_VINFO_GROUP_NEXT_ELEMENT(S)   (S)->next_element\n+#define STMT_VINFO_GROUP_SIZE(S)           (S)->size\n+#define STMT_VINFO_GROUP_STORE_COUNT(S)    (S)->store_count\n+#define STMT_VINFO_GROUP_GAP(S)            (S)->gap\n+#define STMT_VINFO_GROUP_SAME_DR_STMT(S)   (S)->same_dr_stmt\n+#define STMT_VINFO_GROUP_READ_WRITE_DEPENDENCE(S)  (S)->read_write_dep\n+#define STMT_VINFO_STRIDED_ACCESS(S)      ((S)->first_element != NULL && (S)->data_ref_info)\n+\n+#define GROUP_FIRST_ELEMENT(S)          (S)->first_element\n+#define GROUP_NEXT_ELEMENT(S)           (S)->next_element\n+#define GROUP_SIZE(S)                   (S)->size\n+#define GROUP_STORE_COUNT(S)            (S)->store_count\n+#define GROUP_GAP(S)                    (S)->gap\n+#define GROUP_SAME_DR_STMT(S)           (S)->same_dr_stmt\n+#define GROUP_READ_WRITE_DEPENDENCE(S)  (S)->read_write_dep\n \n #define STMT_VINFO_RELEVANT_P(S)          ((S)->relevant != vect_unused_in_scope)\n #define STMT_VINFO_OUTSIDE_OF_LOOP_COST(S) (S)->cost.outside_of_loop"}]}