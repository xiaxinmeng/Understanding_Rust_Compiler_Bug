{"sha": "c799797ddfe3b0d779dc0a9d9549067b0a6558cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc5OTc5N2RkZmUzYjBkNzc5ZGMwYTlkOTU0OTA2N2IwYTY1NThjZg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-05-19T15:09:09Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-05-19T15:09:09Z"}, "message": "* config/alpha/alpha.c (alpha_legitimize_reload_address)\n\t(alpha_preferred_reload_class, alpha_legitimate_constant_p): Use\n\tCONST_INT_P, CONST_SCALAR_INT_P and CONST_DOUBLE_P predicates.\n\t(alpha_split_reload_pair) <case CONST_INT, case CONST_WIDE_INT>:\n\tUse CASE_CONST_SCALAR_INT.\n\t(print_operand) <case 'M'>: Use mode_width_operand to check the\n\tvalue of the constant.\n\t* config/alpha/alpha.md (movti): Use CONST_SCALAR_INT_P predicate.\n\t* config/alpha/predicates.md (input_operand): Use general_operand\n\tinstead of match_code as operand check.\n\t(symbolic_operand): Use match_code with subexpression digits.\n\t* config/alpha/constraints.md (Q): Ditto.\n\nFrom-SVN: r223371", "tree": {"sha": "50bd8fb9ac79fb374b20ddad286efb3ed0791315", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50bd8fb9ac79fb374b20ddad286efb3ed0791315"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c799797ddfe3b0d779dc0a9d9549067b0a6558cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c799797ddfe3b0d779dc0a9d9549067b0a6558cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c799797ddfe3b0d779dc0a9d9549067b0a6558cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c799797ddfe3b0d779dc0a9d9549067b0a6558cf/comments", "author": null, "committer": null, "parents": [{"sha": "a2780ddb46556eac870f843df4dca394a48844bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2780ddb46556eac870f843df4dca394a48844bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2780ddb46556eac870f843df4dca394a48844bb"}], "stats": {"total": 55, "additions": 31, "deletions": 24}, "files": [{"sha": "5b82a8551c1d6cc07e24d423657d2598a155b51c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c799797ddfe3b0d779dc0a9d9549067b0a6558cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c799797ddfe3b0d779dc0a9d9549067b0a6558cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c799797ddfe3b0d779dc0a9d9549067b0a6558cf", "patch": "@@ -1,3 +1,18 @@\n+2015-05-19  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/alpha/alpha.c (alpha_legitimize_reload_address)\n+\t(alpha_preferred_reload_class, alpha_legitimate_constant_p): Use\n+\tCONST_INT_P, CONST_SCALAR_INT_P and CONST_DOUBLE_P predicates.\n+\t(alpha_split_reload_pair) <case CONST_INT, case CONST_WIDE_INT>:\n+\tUse CASE_CONST_SCALAR_INT.\n+\t(print_operand) <case 'M'>: Use mode_width_operand to check the\n+\tvalue of the constant.\n+\t* config/alpha/alpha.md (movti): Use CONST_SCALAR_INT_P predicate.\n+\t* config/alpha/predicates.md (input_operand): Use general_operand\n+\tinstead of match_code as operand check.\n+\t(symbolic_operand): Use match_code with subexpression digits.\n+\t* config/alpha/constraints.md (Q): Ditto.\n+\n 2015-05-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* optabs.c (expand_vec_perm): Don't re-use SEL as target operand.\n@@ -363,8 +378,7 @@\n 2015-05-18  Martin Liska  <mliska@suse.cz>\n \n \t* dbgcnt.def: Add new counter.\n-\t* ipa-icf.c (sem_item_optimizer::merge_classes): Use the\n-\tcounter.\n+\t* ipa-icf.c (sem_item_optimizer::merge_classes): Use the counter.\n \n 2015-05-18  Martin Liska  <mliska@suse.cz>\n "}, {"sha": "1ba99d042482bf9f4991e0f5a897022d97b80350", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c799797ddfe3b0d779dc0a9d9549067b0a6558cf/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c799797ddfe3b0d779dc0a9d9549067b0a6558cf/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=c799797ddfe3b0d779dc0a9d9549067b0a6558cf", "patch": "@@ -1352,7 +1352,7 @@ alpha_legitimize_reload_address (rtx x,\n       && REG_P (XEXP (x, 0))\n       && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n       && REGNO_OK_FOR_BASE_P (REGNO (XEXP (x, 0)))\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (x, 1)))\n     {\n       HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n       HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\n@@ -1644,9 +1644,8 @@ alpha_preferred_reload_class(rtx x, enum reg_class rclass)\n     return rclass;\n \n   /* These sorts of constants we can easily drop to memory.  */\n-  if (CONST_INT_P (x)\n-      || GET_CODE (x) == CONST_WIDE_INT\n-      || GET_CODE (x) == CONST_DOUBLE\n+  if (CONST_SCALAR_INT_P (x)\n+      || CONST_DOUBLE_P (x)\n       || GET_CODE (x) == CONST_VECTOR)\n     {\n       if (rclass == FLOAT_REGS)\n@@ -2133,7 +2132,7 @@ alpha_legitimate_constant_p (machine_mode mode, rtx x)\n \n     case CONST:\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1)))\n \tx = XEXP (XEXP (x, 0), 0);\n       else\n \treturn true;\n@@ -3283,8 +3282,7 @@ alpha_split_tmode_pair (rtx operands[4], machine_mode mode,\n       operands[2] = adjust_address (operands[1], DImode, 0);\n       break;\n \n-    case CONST_INT:\n-    case CONST_WIDE_INT:\n+    CASE_CONST_SCALAR_INT:\n     case CONST_DOUBLE:\n       gcc_assert (operands[1] == CONST0_RTX (mode));\n       operands[2] = operands[3] = const0_rtx;\n@@ -5257,9 +5255,7 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'M':\n       /* 'b', 'w', 'l', or 'q' as the value of the constant.  */\n-      if (!CONST_INT_P (x)\n-\t  || (INTVAL (x) != 8 && INTVAL (x) != 16\n-\t      && INTVAL (x) != 32 && INTVAL (x) != 64))\n+      if (!mode_width_operand (x, VOIDmode))\n \toutput_operand_lossage (\"invalid %%M value\");\n \n       fprintf (file, \"%s\","}, {"sha": "7626d3f0233f27d3261274b3ea3cf2ed43af5557", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c799797ddfe3b0d779dc0a9d9549067b0a6558cf/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c799797ddfe3b0d779dc0a9d9549067b0a6558cf/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=c799797ddfe3b0d779dc0a9d9549067b0a6558cf", "patch": "@@ -4153,8 +4153,7 @@\n   /* We must put 64-bit constants in memory.  We could keep the\n      32-bit constants in TImode and rely on the splitter, but\n      this doesn't seem to be worth the pain.  */\n-  else if (CONST_INT_P (operands[1])\n-\t   || GET_CODE (operands[1]) == CONST_WIDE_INT)\n+  else if (CONST_SCALAR_INT_P (operands[1]))\n     {\n       rtx in[2], out[2], target;\n "}, {"sha": "6abba61acdcdc5f253c863cc7d313b2a1416177f", "filename": "gcc/config/alpha/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c799797ddfe3b0d779dc0a9d9549067b0a6558cf/gcc%2Fconfig%2Falpha%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c799797ddfe3b0d779dc0a9d9549067b0a6558cf/gcc%2Fconfig%2Falpha%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fconstraints.md?ref=c799797ddfe3b0d779dc0a9d9549067b0a6558cf", "patch": "@@ -97,7 +97,7 @@\n (define_memory_constraint \"Q\"\n   \"@internal A normal_memory_operand\"\n   (and (match_code \"mem\")\n-       (not (match_test \"GET_CODE (XEXP (op, 0)) == AND\"))))\n+       (not (match_code \"and\" \"0\"))))\n \n (define_constraint \"R\"\n   \"@internal A direct_call_operand\""}, {"sha": "30a064577396a91cf7fea39f820a998bf7c91f3c", "filename": "gcc/config/alpha/predicates.md", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c799797ddfe3b0d779dc0a9d9549067b0a6558cf/gcc%2Fconfig%2Falpha%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c799797ddfe3b0d779dc0a9d9549067b0a6558cf/gcc%2Fconfig%2Falpha%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fpredicates.md?ref=c799797ddfe3b0d779dc0a9d9549067b0a6558cf", "patch": "@@ -72,7 +72,7 @@\n ;; Return 1 if the operand is a non-symbolic, nonzero constant operand.\n (define_predicate \"non_zero_const_operand\"\n   (and (match_code \"const_int,const_wide_int,const_double,const_vector\")\n-       (match_test \"op != CONST0_RTX (mode)\")))\n+       (not (match_test \"op == CONST0_RTX (mode)\"))))\n \n ;; Return 1 if OP is the constant 4 or 8.\n (define_predicate \"const48_operand\"\n@@ -150,8 +150,7 @@\n \n ;; Return 1 if OP is a valid operand for the source of a move insn.\n (define_predicate \"input_operand\"\n-  (match_code \"label_ref,symbol_ref,const,high,reg,subreg,mem,\n-\t       const_double,const_vector,const_int,const_wide_int\")\n+  (match_operand 0 \"general_operand\")\n {\n   switch (GET_CODE (op))\n     {\n@@ -273,8 +272,8 @@\n (define_predicate \"call_operand\"\n   (ior (match_code \"symbol_ref\")\n        (and (match_code \"reg\")\n-\t    (ior (match_test \"!TARGET_ABI_OSF\")\n-\t\t (match_test \"!HARD_REGISTER_P (op)\")\n+\t    (ior (not (match_test \"TARGET_ABI_OSF\"))\n+\t\t (not (match_test \"HARD_REGISTER_P (op)\"))\n \t\t (match_test \"REGNO (op) == R27_REG\")))))\n \n ;; Return true if OP is a LABEL_REF, or SYMBOL_REF or CONST referencing\n@@ -371,10 +370,9 @@\n (define_predicate \"symbolic_operand\"\n   (ior (match_code \"symbol_ref,label_ref\")\n        (and (match_code \"const\")\n-\t    (match_test \"GET_CODE (XEXP (op,0)) == PLUS\n-\t\t\t && (GET_CODE (XEXP (XEXP (op,0), 0)) == SYMBOL_REF\n-\t\t\t     || GET_CODE (XEXP (XEXP (op,0), 0)) == LABEL_REF)\n-\t\t\t && CONST_INT_P (XEXP (XEXP (op,0), 1))\"))))\n+\t    (match_code \"plus\" \"0\")\n+\t    (match_code \"symbol_ref,label_ref\" \"00\")\n+\t    (match_code \"const_int\" \"01\"))))\n \n ;; Return true if OP is valid for 16-bit DTP relative relocations.\n (define_predicate \"dtp16_symbolic_operand\""}]}