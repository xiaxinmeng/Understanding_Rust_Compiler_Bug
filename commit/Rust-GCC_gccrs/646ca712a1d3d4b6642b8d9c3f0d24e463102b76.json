{"sha": "646ca712a1d3d4b6642b8d9c3f0d24e463102b76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ2Y2E3MTJhMWQzZDRiNjY0MmI4ZDljM2YwZDI0ZTQ2MzEwMmI3Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-05-17T06:52:43Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-05-17T06:52:43Z"}, "message": "mips.h (MASK_DEBUG_G, [...]): Delete.\n\n\t* config/mips/mips.h (MASK_DEBUG_G, TARGET_DEBUG_G_MODE): Delete.\n\t(TARGET_SWITCHES): Remove debugg.\n\t* config/mips/mips.md (adddi3, ashldi3, ashrdi3, lshrdi3): Only handle\n\tTARGET_64BIT.\n\t(subdi3): Replace the define_expand with a define_insn, the latter\n\trenamed from subdi3_internal_3.\n\t(negdi2): Likewise negdi2_internal_2.\n\t(adddi3_internal_[12], subdi3_internal, ashldi3_internal{,2,3})\n\t(ashrdi3_internal{,2,3}, lshrdi3_internal{,2,3}): Remove patterns\n\tand associated define_splits.\n\t(adddi3_internal): Renamed from adddi3_internal_3.\n\t(ashldi3_internal): Likewise ashldi3_internal4.\n\t(ashrdi3_internal): Likewise ashrdi3_internal4.\n\t(lshrdi3_internal): Likewise lshrdi3_internal4.\n\nFrom-SVN: r81934", "tree": {"sha": "d2adc0acf6ca0d1e1ebc0811c49a732c9c2e0bdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2adc0acf6ca0d1e1ebc0811c49a732c9c2e0bdc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/646ca712a1d3d4b6642b8d9c3f0d24e463102b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646ca712a1d3d4b6642b8d9c3f0d24e463102b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/646ca712a1d3d4b6642b8d9c3f0d24e463102b76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646ca712a1d3d4b6642b8d9c3f0d24e463102b76/comments", "author": null, "committer": null, "parents": [{"sha": "d83aba0f8b3bfec016bb62d146e022b15c35f1ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d83aba0f8b3bfec016bb62d146e022b15c35f1ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d83aba0f8b3bfec016bb62d146e022b15c35f1ca"}], "stats": {"total": 935, "additions": 82, "deletions": 853}, "files": [{"sha": "61bca60e7d387b64f6e8fcd21b530f441e5e660a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/646ca712a1d3d4b6642b8d9c3f0d24e463102b76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/646ca712a1d3d4b6642b8d9c3f0d24e463102b76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=646ca712a1d3d4b6642b8d9c3f0d24e463102b76", "patch": "@@ -1,3 +1,20 @@\n+2004-05-17  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.h (MASK_DEBUG_G, TARGET_DEBUG_G_MODE): Delete.\n+\t(TARGET_SWITCHES): Remove debugg.\n+\t* config/mips/mips.md (adddi3, ashldi3, ashrdi3, lshrdi3): Only handle\n+\tTARGET_64BIT.\n+\t(subdi3): Replace the define_expand with a define_insn, the latter\n+\trenamed from subdi3_internal_3.\n+\t(negdi2): Likewise negdi2_internal_2.\n+\t(adddi3_internal_[12], subdi3_internal, ashldi3_internal{,2,3})\n+\t(ashrdi3_internal{,2,3}, lshrdi3_internal{,2,3}): Remove patterns\n+\tand associated define_splits.\n+\t(adddi3_internal): Renamed from adddi3_internal_3.\n+\t(ashldi3_internal): Likewise ashldi3_internal4.\n+\t(ashrdi3_internal): Likewise ashrdi3_internal4.\n+\t(lshrdi3_internal): Likewise lshrdi3_internal4.\n+\n 2004-05-17  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* optabs.c (expand_unop): Try implementing negation using subtraction"}, {"sha": "d426bc4eddc7cbb9751da4e712d7563430ac5a08", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/646ca712a1d3d4b6642b8d9c3f0d24e463102b76/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/646ca712a1d3d4b6642b8d9c3f0d24e463102b76/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=646ca712a1d3d4b6642b8d9c3f0d24e463102b76", "patch": "@@ -178,7 +178,6 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define MASK_DEBUG\t0\t\t/* unused */\n #define MASK_DEBUG_C\t0\t\t/* don't expand seq, etc.  */\n #define MASK_DEBUG_D\t0\t\t/* don't do define_split's */\n-#define MASK_DEBUG_G\t0\t\t/* don't support 64 bit arithmetic */\n \n \t\t\t\t\t/* Dummy switches used only in specs */\n #define MASK_MIPS_TFILE\t0\t\t/* flag for mips-tfile usage */\n@@ -200,7 +199,6 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define TARGET_DEBUG_MODE\t(target_flags & MASK_DEBUG)\n #define TARGET_DEBUG_C_MODE\t(target_flags & MASK_DEBUG_C)\n #define TARGET_DEBUG_D_MODE\t(target_flags & MASK_DEBUG_D)\n-#define TARGET_DEBUG_G_MODE\t(target_flags & MASK_DEBUG_G)\n \n \t\t\t\t\t/* Reg. Naming in .s ($21 vs. $a0) */\n #define TARGET_NAME_REGS\t(target_flags & MASK_NAME_REGS)\n@@ -678,8 +676,6 @@ extern const struct mips_cpu_info *mips_tune_info;\n      NULL},\t\t\t\t\t\t\t\t\\\n   {\"debugd\",\t\t  MASK_DEBUG_D,\t\t\t\t\t\\\n      NULL},\t\t\t\t\t\t\t\t\\\n-  {\"debugg\",\t\t  MASK_DEBUG_G,\t\t\t\t\t\\\n-     NULL},\t\t\t\t\t\t\t\t\\\n   {\"\",\t\t\t  (TARGET_DEFAULT\t\t\t\t\\\n \t\t\t   | TARGET_CPU_DEFAULT\t\t\t\t\\\n \t\t\t   | TARGET_ENDIAN_DEFAULT\t\t\t\\"}, {"sha": "022562ddc85ce6bfe45cadfc56a8eb8fdc7254cf", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 65, "deletions": 849, "changes": 914, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/646ca712a1d3d4b6642b8d9c3f0d24e463102b76/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/646ca712a1d3d4b6642b8d9c3f0d24e463102b76/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=646ca712a1d3d4b6642b8d9c3f0d24e463102b76", "patch": "@@ -890,11 +890,10 @@\n })\n \n (define_expand \"adddi3\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\")\n-\t\t   (plus:DI (match_operand:DI 1 \"register_operand\")\n-\t\t\t    (match_operand:DI 2 \"arith_operand\")))\n-\t      (clobber (match_dup 3))])]\n-  \"TARGET_64BIT || (!TARGET_DEBUG_G_MODE && !TARGET_MIPS16)\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\")\n+\t\t (match_operand:DI 2 \"arith_operand\")))]\n+  \"TARGET_64BIT\"\n {\n   /* If a large stack adjustment was forced into a register, we may be\n      asked to generate rtx such as:\n@@ -916,156 +915,9 @@\n       emit_move_insn (operands[0], tmp);\n       DONE;\n     }\n-\n-  if (TARGET_64BIT)\n-    {\n-      emit_insn (gen_adddi3_internal_3 (operands[0], operands[1],\n-\t\t\t\t\toperands[2]));\n-      DONE;\n-    }\n-\n-  operands[3] = gen_reg_rtx (SImode);\n })\n \n-(define_insn \"adddi3_internal_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,&d\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"0,d\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"d,d\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d,d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\"\n-{\n-  return (REGNO (operands[0]) == REGNO (operands[1])\n-\t  && REGNO (operands[0]) == REGNO (operands[2]))\n-    ? \"srl\\t%3,%L0,31\\;sll\\t%M0,%M0,1\\;sll\\t%L0,%L1,1\\;addu\\t%M0,%M0,%3\"\n-    : \"addu\\t%L0,%L1,%L2\\;sltu\\t%3,%L0,%L2\\;addu\\t%M0,%M1,%M2\\;addu\\t%M0,%M0,%3\";\n-}\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"16\")])\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\")\n-\t\t (match_operand:DI 2 \"register_operand\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && !WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n-   && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\n-   && (REGNO (operands[0]) != REGNO (operands[1])\n-       || REGNO (operands[0]) != REGNO (operands[2]))\"\n-\n-  [(set (subreg:SI (match_dup 0) 0)\n-\t(plus:SI (subreg:SI (match_dup 1) 0)\n-\t\t (subreg:SI (match_dup 2) 0)))\n-\n-   (set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 0) 0)\n-\t\t(subreg:SI (match_dup 2) 0)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(plus:SI (subreg:SI (match_dup 1) 4)\n-\t\t (subreg:SI (match_dup 2) 4)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(plus:SI (subreg:SI (match_dup 0) 4)\n-\t\t (match_dup 3)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\")\n-\t\t (match_operand:DI 2 \"register_operand\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n-   && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\n-   && (REGNO (operands[0]) != REGNO (operands[1])\n-       || REGNO (operands[0]) != REGNO (operands[2]))\"\n-\n-  [(set (subreg:SI (match_dup 0) 4)\n-\t(plus:SI (subreg:SI (match_dup 1) 4)\n-\t\t (subreg:SI (match_dup 2) 4)))\n-\n-   (set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 0) 4)\n-\t\t(subreg:SI (match_dup 2) 4)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(plus:SI (subreg:SI (match_dup 1) 0)\n-\t\t (subreg:SI (match_dup 2) 0)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(plus:SI (subreg:SI (match_dup 0) 0)\n-\t\t (match_dup 3)))]\n-  \"\")\n-\n-(define_insn \"adddi3_internal_2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%d,d,d\")\n-\t\t (match_operand:DI 2 \"small_int\" \"P,J,N\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d,d,d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\"\n-  \"@\n-   addu\\t%L0,%L1,%2\\;sltu\\t%3,%L0,%2\\;addu\\t%M0,%M1,%3\n-   move\\t%L0,%L1\\;move\\t%M0,%M1\n-   subu\\t%L0,%L1,%n2\\;sltu\\t%3,%L0,%2\\;subu\\t%M0,%M1,1\\;addu\\t%M0,%M0,%3\"\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"12,8,16\")])\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\")\n-\t\t (match_operand:DI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && !WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n-   && INTVAL (operands[2]) > 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 0)\n-\t(plus:SI (subreg:SI (match_dup 1) 0)\n-\t\t (match_dup 2)))\n-\n-   (set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 0) 0)\n-\t\t(match_dup 2)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(plus:SI (subreg:SI (match_dup 1) 4)\n-\t\t (match_dup 3)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\")\n-\t\t (match_operand:DI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n-   && INTVAL (operands[2]) > 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 4)\n-\t(plus:SI (subreg:SI (match_dup 1) 4)\n-\t\t (match_dup 2)))\n-\n-   (set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 0) 4)\n-\t\t(match_dup 2)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(plus:SI (subreg:SI (match_dup 1) 0)\n-\t\t (match_dup 3)))]\n-  \"\")\n-\n-(define_insn \"adddi3_internal_3\"\n+(define_insn \"adddi3_internal\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n \t(plus:DI (match_operand:DI 1 \"reg_or_0_operand\" \"dJ,dJ\")\n \t\t (match_operand:DI 2 \"arith_operand\" \"d,Q\")))]\n@@ -1281,91 +1133,7 @@\n   [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-(define_expand \"subdi3\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\")\n-\t\t   (minus:DI (match_operand:DI 1 \"register_operand\")\n-\t\t\t     (match_operand:DI 2 \"register_operand\")))\n-\t      (clobber (match_dup 3))])]\n-  \"TARGET_64BIT || (!TARGET_DEBUG_G_MODE && !TARGET_MIPS16)\"\n-{\n-  if (TARGET_64BIT)\n-    {\n-      emit_insn (gen_subdi3_internal_3 (operands[0], operands[1],\n-\t\t\t\t\toperands[2]));\n-      DONE;\n-    }\n-\n-  operands[3] = gen_reg_rtx (SImode);\n-})\n-\n-(define_insn \"subdi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t  (match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\"\n-  \"sltu\\t%3,%L1,%L2\\;subu\\t%L0,%L1,%L2\\;subu\\t%M0,%M1,%M2\\;subu\\t%M0,%M0,%3\"\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"16\")])\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\")\n-\t\t  (match_operand:DI 2 \"register_operand\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && !WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n-   && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n-\n-  [(set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 1) 0)\n-\t\t(subreg:SI (match_dup 2) 0)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(minus:SI (subreg:SI (match_dup 1) 0)\n-\t\t  (subreg:SI (match_dup 2) 0)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(minus:SI (subreg:SI (match_dup 1) 4)\n-\t\t  (subreg:SI (match_dup 2) 4)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(minus:SI (subreg:SI (match_dup 0) 4)\n-\t\t  (match_dup 3)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\")\n-\t\t  (match_operand:DI 2 \"register_operand\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n-   && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n-\n-  [(set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 1) 4)\n-\t        (subreg:SI (match_dup 2) 4)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(minus:SI (subreg:SI (match_dup 1) 4)\n-\t\t  (subreg:SI (match_dup 2) 4)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(minus:SI (subreg:SI (match_dup 1) 0)\n-\t\t  (subreg:SI (match_dup 2) 0)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(minus:SI (subreg:SI (match_dup 0) 0)\n-\t\t  (match_dup 3)))]\n-  \"\")\n-\n-(define_insn \"subdi3_internal_3\"\n+(define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t  (match_operand:DI 2 \"register_operand\" \"d\")))]\n@@ -2987,32 +2755,7 @@ dsrl\\t%3,%3,1\\n\\\n   [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-(define_expand \"negdi2\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\")\n-\t\t   (neg:DI (match_operand:DI 1 \"register_operand\")))\n-\t      (clobber (match_dup 2))])]\n-  \"(TARGET_64BIT || !TARGET_DEBUG_G_MODE) && !TARGET_MIPS16\"\n-{\n-  if (TARGET_64BIT)\n-    {\n-      emit_insn (gen_negdi2_internal_2 (operands[0], operands[1]));\n-      DONE;\n-    }\n-\n-  operands[2] = gen_reg_rtx (SImode);\n-})\n-\n-(define_insn \"negdi2_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(neg:DI (match_operand:DI 1 \"register_operand\" \"d\")))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=d\"))]\n-  \"! TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\"\n-  \"subu\\t%L0,%.,%L1\\;subu\\t%M0,%.,%M1\\;sltu\\t%2,%.,%L0\\;subu\\t%M0,%M0,%2\"\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"16\")])\n-\n-(define_insn \"negdi2_internal_2\"\n+(define_insn \"negdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(neg:DI (match_operand:DI 1 \"register_operand\" \"d\")))]\n   \"TARGET_64BIT && !TARGET_MIPS16\"\n@@ -5536,213 +5279,37 @@ dsrl\\t%3,%3,1\\n\\\n   { operands[2] = GEN_INT (INTVAL (operands[2]) - 8); })\n \n (define_expand \"ashldi3\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\")\n-\t\t   (ashift:DI (match_operand:DI 1 \"register_operand\")\n-\t\t\t      (match_operand:SI 2 \"arith_operand\")))\n-\t      (clobber (match_dup  3))])]\n-  \"TARGET_64BIT || (!TARGET_DEBUG_G_MODE && !TARGET_MIPS16)\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\")\n+\t\t   (match_operand:SI 2 \"arith_operand\")))]\n+  \"TARGET_64BIT\"\n {\n-  if (TARGET_64BIT)\n+  /* On the mips16, a shift of more than 8 is a four byte\n+     instruction, so, for a shift between 8 and 16, it is just as\n+     fast to do two shifts of 8 or less.  If there is a lot of\n+     shifting going on, we may win in CSE.  Otherwise combine will\n+     put the shifts back together again.  This can be called by\n+     function_arg, so we must be careful not to allocate a new\n+     register if we've reached the reload pass.  */\n+  if (TARGET_MIPS16\n+      && optimize\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) > 8\n+      && INTVAL (operands[2]) <= 16\n+      && ! reload_in_progress\n+      && ! reload_completed)\n     {\n-      /* On the mips16, a shift of more than 8 is a four byte\n-\t instruction, so, for a shift between 8 and 16, it is just as\n-\t fast to do two shifts of 8 or less.  If there is a lot of\n-\t shifting going on, we may win in CSE.  Otherwise combine will\n-\t put the shifts back together again.  This can be called by\n-\t function_arg, so we must be careful not to allocate a new\n-\t register if we've reached the reload pass.  */\n-      if (TARGET_MIPS16\n-\t  && optimize\n-\t  && GET_CODE (operands[2]) == CONST_INT\n-\t  && INTVAL (operands[2]) > 8\n-\t  && INTVAL (operands[2]) <= 16\n-\t  && ! reload_in_progress\n-\t  && ! reload_completed)\n-\t{\n-\t  rtx temp = gen_reg_rtx (DImode);\n-\n-\t  emit_insn (gen_ashldi3_internal4 (temp, operands[1], GEN_INT (8)));\n-\t  emit_insn (gen_ashldi3_internal4 (operands[0], temp,\n-\t\t\t\t\t    GEN_INT (INTVAL (operands[2]) - 8)));\n-\t  DONE;\n-\t}\n+      rtx temp = gen_reg_rtx (DImode);\n \n-      emit_insn (gen_ashldi3_internal4 (operands[0], operands[1],\n-\t\t\t\t\toperands[2]));\n+      emit_insn (gen_ashldi3_internal (temp, operands[1], GEN_INT (8)));\n+      emit_insn (gen_ashldi3_internal (operands[0], temp,\n+\t\t\t\t       GEN_INT (INTVAL (operands[2]) - 8)));\n       DONE;\n     }\n-\n-  operands[3] = gen_reg_rtx (SImode);\n })\n \n \n (define_insn \"ashldi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t   (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\"\n-  \"sll\\t%3,%2,26\\;\\\n-bgez\\t%3,1f%#\\;\\\n-sll\\t%M0,%L1,%2\\;\\\n-%(b\\t3f\\;\\\n-move\\t%L0,%.%)\\\n-\\n\\n\\\n-%~1:\\;\\\n-%(beq\\t%3,%.,2f\\;\\\n-sll\\t%M0,%M1,%2%)\\\n-\\n\\;\\\n-subu\\t%3,%.,%2\\;\\\n-srl\\t%3,%L1,%3\\;\\\n-or\\t%M0,%M0,%3\\n\\\n-%~2:\\;\\\n-sll\\t%L0,%L1,%2\\n\\\n-%~3:\"\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"48\")])\n-\n-\n-(define_insn \"ashldi3_internal2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t   (match_operand:SI 2 \"small_int\" \"IJK\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && (INTVAL (operands[2]) & 32) != 0\"\n-{\n-  operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n-  return \"sll\\t%M0,%L1,%2\\;move\\t%L0,%.\";\n-}\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"8\")])\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\")\n-\t\t   (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && !WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 32) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 4) (ashift:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n-   (set (subreg:SI (match_dup 0) 0) (const_int 0))]\n-\n-  \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\")\n-\t\t   (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 32) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 0) (ashift:SI (subreg:SI (match_dup 1) 4) (match_dup 2)))\n-   (set (subreg:SI (match_dup 0) 4) (const_int 0))]\n-\n-  \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n-\n-\n-(define_insn \"ashldi3_internal3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t   (match_operand:SI 2 \"small_int\" \"IJK\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && (INTVAL (operands[2]) & 63) < 32\n-   && (INTVAL (operands[2]) & 63) != 0\"\n-{\n-  int amount = INTVAL (operands[2]);\n-\n-  operands[2] = GEN_INT (amount & 31);\n-  operands[4] = GEN_INT ((-amount) & 31);\n-\n-  return \"sll\\t%M0,%M1,%2\\;srl\\t%3,%L1,%4\\;or\\t%M0,%M0,%3\\;sll\\t%L0,%L1,%2\";\n-}\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"16\")])\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\")\n-\t\t   (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && !WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 63) < 32\n-   && (INTVAL (operands[2]) & 63) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 4)\n-\t(ashift:SI (subreg:SI (match_dup 1) 4)\n-\t\t   (match_dup 2)))\n-\n-   (set (match_dup 3)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 0)\n-\t\t     (match_dup 4)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(ior:SI (subreg:SI (match_dup 0) 4)\n-\t\t(match_dup 3)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(ashift:SI (subreg:SI (match_dup 1) 0)\n-\t\t   (match_dup 2)))]\n-{\n-  int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT (amount & 31);\n-  operands[4] = GEN_INT ((-amount) & 31);\n-})\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\")\n-\t\t   (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 63) < 32\n-   && (INTVAL (operands[2]) & 63) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 0)\n-\t(ashift:SI (subreg:SI (match_dup 1) 0)\n-\t\t   (match_dup 2)))\n-\n-   (set (match_dup 3)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 4)\n-\t\t     (match_dup 4)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(ior:SI (subreg:SI (match_dup 0) 0)\n-\t\t(match_dup 3)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(ashift:SI (subreg:SI (match_dup 1) 4)\n-\t\t   (match_dup 2)))]\n-{\n-  int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT (amount & 31);\n-  operands[4] = GEN_INT ((-amount) & 31);\n-})\n-\n-\n-(define_insn \"ashldi3_internal4\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(ashift:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t   (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n@@ -5872,208 +5439,33 @@ sll\\t%L0,%L1,%2\\n\\\n   { operands[2] = GEN_INT (INTVAL (operands[2]) - 8); })\n \n (define_expand \"ashrdi3\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\")\n-\t\t   (ashiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t\t\t(match_operand:SI 2 \"arith_operand\")))\n-\t      (clobber (match_dup  3))])]\n-  \"TARGET_64BIT || (!TARGET_DEBUG_G_MODE && !TARGET_MIPS16)\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\")\n+\t\t     (match_operand:SI 2 \"arith_operand\")))]\n+  \"TARGET_64BIT\"\n {\n-  if (TARGET_64BIT)\n+  /* On the mips16, a shift of more than 8 is a four byte\n+     instruction, so, for a shift between 8 and 16, it is just as\n+     fast to do two shifts of 8 or less.  If there is a lot of\n+     shifting going on, we may win in CSE.  Otherwise combine will\n+     put the shifts back together again.  */\n+  if (TARGET_MIPS16\n+      && optimize\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) > 8\n+      && INTVAL (operands[2]) <= 16)\n     {\n-      /* On the mips16, a shift of more than 8 is a four byte\n-\t instruction, so, for a shift between 8 and 16, it is just as\n-\t fast to do two shifts of 8 or less.  If there is a lot of\n-\t shifting going on, we may win in CSE.  Otherwise combine will\n-\t put the shifts back together again.  */\n-      if (TARGET_MIPS16\n-\t  && optimize\n-\t  && GET_CODE (operands[2]) == CONST_INT\n-\t  && INTVAL (operands[2]) > 8\n-\t  && INTVAL (operands[2]) <= 16)\n-\t{\n-\t  rtx temp = gen_reg_rtx (DImode);\n+      rtx temp = gen_reg_rtx (DImode);\n \n-\t  emit_insn (gen_ashrdi3_internal4 (temp, operands[1], GEN_INT (8)));\n-\t  emit_insn (gen_ashrdi3_internal4 (operands[0], temp,\n-\t\t\t\t\t    GEN_INT (INTVAL (operands[2]) - 8)));\n-\t  DONE;\n-\t}\n-\n-      emit_insn (gen_ashrdi3_internal4 (operands[0], operands[1],\n-\t\t\t\t\toperands[2]));\n+      emit_insn (gen_ashrdi3_internal (temp, operands[1], GEN_INT (8)));\n+      emit_insn (gen_ashrdi3_internal (operands[0], temp,\n+\t\t\t\t       GEN_INT (INTVAL (operands[2]) - 8)));\n       DONE;\n     }\n-\n-  operands[3] = gen_reg_rtx (SImode);\n })\n \n \n (define_insn \"ashrdi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t     (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\"\n-  \"sll\\t%3,%2,26\\;\\\n-bgez\\t%3,1f%#\\;\\\n-sra\\t%L0,%M1,%2\\;\\\n-%(b\\t3f\\;\\\n-sra\\t%M0,%M1,31%)\\\n-\\n\\n\\\n-%~1:\\;\\\n-%(beq\\t%3,%.,2f\\;\\\n-srl\\t%L0,%L1,%2%)\\\n-\\n\\;\\\n-subu\\t%3,%.,%2\\;\\\n-sll\\t%3,%M1,%3\\;\\\n-or\\t%L0,%L0,%3\\n\\\n-%~2:\\;\\\n-sra\\t%M0,%M1,%2\\n\\\n-%~3:\"\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"48\")])\n-\n-\n-(define_insn \"ashrdi3_internal2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t     (match_operand:SI 2 \"small_int\" \"IJK\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && (INTVAL (operands[2]) & 32) != 0\"\n-{\n-  operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n-  return \"sra\\t%L0,%M1,%2\\;sra\\t%M0,%M1,31\";\n-}\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"8\")])\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && !WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 32) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 0) (ashiftrt:SI (subreg:SI (match_dup 1) 4) (match_dup 2)))\n-   (set (subreg:SI (match_dup 0) 4) (ashiftrt:SI (subreg:SI (match_dup 1) 4) (const_int 31)))]\n-\n-  \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 32) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 4) (ashiftrt:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n-   (set (subreg:SI (match_dup 0) 0) (ashiftrt:SI (subreg:SI (match_dup 1) 0) (const_int 31)))]\n-\n-  \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n-\n-\n-(define_insn \"ashrdi3_internal3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t     (match_operand:SI 2 \"small_int\" \"IJK\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && (INTVAL (operands[2]) & 63) < 32\n-   && (INTVAL (operands[2]) & 63) != 0\"\n-{\n-  int amount = INTVAL (operands[2]);\n-\n-  operands[2] = GEN_INT (amount & 31);\n-  operands[4] = GEN_INT ((-amount) & 31);\n-\n-  return \"srl\\t%L0,%L1,%2\\;sll\\t%3,%M1,%4\\;or\\t%L0,%L0,%3\\;sra\\t%M0,%M1,%2\";\n-}\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"16\")])\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && !WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 63) < 32\n-   && (INTVAL (operands[2]) & 63) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 0)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 0)\n-\t\t     (match_dup 2)))\n-\n-   (set (match_dup 3)\n-\t(ashift:SI (subreg:SI (match_dup 1) 4)\n-\t\t   (match_dup 4)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(ior:SI (subreg:SI (match_dup 0) 0)\n-\t\t(match_dup 3)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(ashiftrt:SI (subreg:SI (match_dup 1) 4)\n-\t\t     (match_dup 2)))]\n-{\n-  int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT (amount & 31);\n-  operands[4] = GEN_INT ((-amount) & 31);\n-})\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 63) < 32\n-   && (INTVAL (operands[2]) & 63) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 4)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 4)\n-\t\t     (match_dup 2)))\n-\n-   (set (match_dup 3)\n-\t(ashift:SI (subreg:SI (match_dup 1) 0)\n-\t\t   (match_dup 4)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(ior:SI (subreg:SI (match_dup 0) 4)\n-\t\t(match_dup 3)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(ashiftrt:SI (subreg:SI (match_dup 1) 0)\n-\t\t     (match_dup 2)))]\n-{\n-  int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT (amount & 31);\n-  operands[4] = GEN_INT ((-amount) & 31);\n-})\n-\n-\n-(define_insn \"ashrdi3_internal4\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n@@ -6222,209 +5614,33 @@ sra\\t%M0,%M1,%2\\n\\\n    (set_attr \"length\"\t\"16\")])\n \n (define_expand \"lshrdi3\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\")\n-\t\t   (lshiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t\t\t(match_operand:SI 2 \"arith_operand\")))\n-\t      (clobber (match_dup  3))])]\n-  \"TARGET_64BIT || (!TARGET_DEBUG_G_MODE && !TARGET_MIPS16)\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\")\n+\t\t     (match_operand:SI 2 \"arith_operand\")))]\n+  \"TARGET_64BIT\"\n {\n-  if (TARGET_64BIT)\n+  /* On the mips16, a shift of more than 8 is a four byte\n+     instruction, so, for a shift between 8 and 16, it is just as\n+     fast to do two shifts of 8 or less.  If there is a lot of\n+     shifting going on, we may win in CSE.  Otherwise combine will\n+     put the shifts back together again.  */\n+  if (TARGET_MIPS16\n+      && optimize\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) > 8\n+      && INTVAL (operands[2]) <= 16)\n     {\n-      /* On the mips16, a shift of more than 8 is a four byte\n-\t instruction, so, for a shift between 8 and 16, it is just as\n-\t fast to do two shifts of 8 or less.  If there is a lot of\n-\t shifting going on, we may win in CSE.  Otherwise combine will\n-\t put the shifts back together again.  */\n-      if (TARGET_MIPS16\n-\t  && optimize\n-\t  && GET_CODE (operands[2]) == CONST_INT\n-\t  && INTVAL (operands[2]) > 8\n-\t  && INTVAL (operands[2]) <= 16)\n-\t{\n-\t  rtx temp = gen_reg_rtx (DImode);\n-\n-\t  emit_insn (gen_lshrdi3_internal4 (temp, operands[1], GEN_INT (8)));\n-\t  emit_insn (gen_lshrdi3_internal4 (operands[0], temp,\n-\t\t\t\t\t    GEN_INT (INTVAL (operands[2]) - 8)));\n-\t  DONE;\n-\t}\n+      rtx temp = gen_reg_rtx (DImode);\n \n-      emit_insn (gen_lshrdi3_internal4 (operands[0], operands[1],\n-\t\t\t\t\toperands[2]));\n+      emit_insn (gen_lshrdi3_internal (temp, operands[1], GEN_INT (8)));\n+      emit_insn (gen_lshrdi3_internal (operands[0], temp,\n+\t\t\t\t       GEN_INT (INTVAL (operands[2]) - 8)));\n       DONE;\n     }\n-\n-  operands[3] = gen_reg_rtx (SImode);\n })\n \n \n (define_insn \"lshrdi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t     (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\"\n-  \"sll\\t%3,%2,26\\;\\\n-bgez\\t%3,1f%#\\;\\\n-srl\\t%L0,%M1,%2\\;\\\n-%(b\\t3f\\;\\\n-move\\t%M0,%.%)\\\n-\\n\\n\\\n-%~1:\\;\\\n-%(beq\\t%3,%.,2f\\;\\\n-srl\\t%L0,%L1,%2%)\\\n-\\n\\;\\\n-subu\\t%3,%.,%2\\;\\\n-sll\\t%3,%M1,%3\\;\\\n-or\\t%L0,%L0,%3\\n\\\n-%~2:\\;\\\n-srl\\t%M0,%M1,%2\\n\\\n-%~3:\"\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"48\")])\n-\n-\n-(define_insn \"lshrdi3_internal2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t     (match_operand:SI 2 \"small_int\" \"IJK\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && (INTVAL (operands[2]) & 32) != 0\"\n-{\n-  operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n-  return \"srl\\t%L0,%M1,%2\\;move\\t%M0,%.\";\n-}\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"8\")])\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && !WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 32) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 0) (lshiftrt:SI (subreg:SI (match_dup 1) 4) (match_dup 2)))\n-   (set (subreg:SI (match_dup 0) 4) (const_int 0))]\n-\n-  \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 32) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 4) (lshiftrt:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n-   (set (subreg:SI (match_dup 0) 0) (const_int 0))]\n-\n-  \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n-\n-\n-(define_insn \"lshrdi3_internal3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t   (match_operand:SI 2 \"small_int\" \"IJK\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && (INTVAL (operands[2]) & 63) < 32\n-   && (INTVAL (operands[2]) & 63) != 0\"\n-{\n-  int amount = INTVAL (operands[2]);\n-\n-  operands[2] = GEN_INT (amount & 31);\n-  operands[4] = GEN_INT ((-amount) & 31);\n-\n-  return \"srl\\t%L0,%L1,%2\\;sll\\t%3,%M1,%4\\;or\\t%L0,%L0,%3\\;srl\\t%M0,%M1,%2\";\n-}\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"16\")])\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && !WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 63) < 32\n-   && (INTVAL (operands[2]) & 63) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 0)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 0)\n-\t\t     (match_dup 2)))\n-\n-   (set (match_dup 3)\n-\t(ashift:SI (subreg:SI (match_dup 1) 4)\n-\t\t   (match_dup 4)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(ior:SI (subreg:SI (match_dup 0) 0)\n-\t\t(match_dup 3)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 4)\n-\t\t     (match_dup 2)))]\n-{\n-  int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT (amount & 31);\n-  operands[4] = GEN_INT ((-amount) & 31);\n-})\n-\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"small_int\")))\n-   (clobber (match_operand:SI 3 \"register_operand\"))]\n-  \"reload_completed && WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-   && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-   && (INTVAL (operands[2]) & 63) < 32\n-   && (INTVAL (operands[2]) & 63) != 0\"\n-\n-  [(set (subreg:SI (match_dup 0) 4)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 4)\n-\t\t     (match_dup 2)))\n-\n-   (set (match_dup 3)\n-\t(ashift:SI (subreg:SI (match_dup 1) 0)\n-\t\t   (match_dup 4)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(ior:SI (subreg:SI (match_dup 0) 4)\n-\t\t(match_dup 3)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 0)\n-\t\t     (match_dup 2)))]\n-{\n-  int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT (amount & 31);\n-  operands[4] = GEN_INT ((-amount) & 31);\n-})\n-\n-\n-(define_insn \"lshrdi3_internal4\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]"}]}