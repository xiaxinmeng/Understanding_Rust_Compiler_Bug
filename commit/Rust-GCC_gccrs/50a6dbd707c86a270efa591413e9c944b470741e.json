{"sha": "50a6dbd707c86a270efa591413e9c944b470741e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBhNmRiZDcwN2M4NmEyNzBlZmE1OTE0MTNlOWM5NDRiNDcwNzQxZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-08-20T17:41:43Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-08-20T17:41:43Z"}, "message": "tree.c (search_tree, [...]): New fn.\n\n\t* tree.c (search_tree, no_linkage_helper, no_linkage_check): New fn.\n\t* pt.c (coerce_template_parms): Use no_linkage_check.\n\t* decl.c (grokvardecl): Likewise.\n\t(grokfndecl): Likewise.  Members of anonymous types have no linkage.\n\t* method.c (process_overload_item): Remove useless code.\n\nFrom-SVN: r21884", "tree": {"sha": "170ce25cb6bd3fd7d83f00c25549721f52ebfc12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/170ce25cb6bd3fd7d83f00c25549721f52ebfc12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50a6dbd707c86a270efa591413e9c944b470741e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50a6dbd707c86a270efa591413e9c944b470741e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50a6dbd707c86a270efa591413e9c944b470741e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50a6dbd707c86a270efa591413e9c944b470741e/comments", "author": null, "committer": null, "parents": [{"sha": "a604b0f1db0ee1c21b28be926918d6b05b8fc1ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a604b0f1db0ee1c21b28be926918d6b05b8fc1ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a604b0f1db0ee1c21b28be926918d6b05b8fc1ca"}], "stats": {"total": 352, "additions": 339, "deletions": 13}, "files": [{"sha": "c5f938b990f9f09aa6ae94b084a9dc5e7dd884f1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=50a6dbd707c86a270efa591413e9c944b470741e", "patch": "@@ -1,3 +1,12 @@\n+1998-08-20  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (search_tree, no_linkage_helper, no_linkage_check): New fn.\n+\t* pt.c (coerce_template_parms): Use no_linkage_check.\n+\t* decl.c (grokvardecl): Likewise.\n+\t(grokfndecl): Likewise.  Members of anonymous types have no linkage.\n+\n+\t* method.c (process_overload_item): Remove useless code.\n+\n 1998-08-20  Per Bothner  <bothner@cygnus.com>\n \n \tHandle new'ing of Java classes."}, {"sha": "b567b950638eeafd26882888c1db6de480638936", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=50a6dbd707c86a270efa591413e9c944b470741e", "patch": "@@ -3042,6 +3042,7 @@ extern int really_overloaded_fn\t\t\tPROTO((tree));\n extern int cp_tree_equal\t\t\tPROTO((tree, tree));\n extern int can_free\t\t\t\tPROTO((struct obstack *, tree));\n extern tree mapcar\t\t\t\tPROTO((tree, tree (*) (tree)));\n+extern tree no_linkage_check\t\t\tPROTO((tree));\n extern void debug_binfo\t\t\t\tPROTO((tree));\n extern void push_expression_obstack\t\tPROTO((void));\n #define scratchalloc expralloc"}, {"sha": "251cbef850838dc4669d5438fd56b9c78a1bc089", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=50a6dbd707c86a270efa591413e9c944b470741e", "patch": "@@ -6636,6 +6636,26 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n   /* Corresponding pop_obstacks is done in `cp_finish_decl'.  */\n   push_obstacks_nochange ();\n \n+  /* [basic.link]: A name with no linkage (notably, the name of a class or\n+     enumeration declared in a local scope) shall not be used to declare an\n+     entity with linkage.\n+\n+     Only check this for public decls for now.  */\n+  if (TREE_PUBLIC (tem))\n+    {\n+      tree t = no_linkage_check (TREE_TYPE (tem));\n+      if (t)\n+\t{\n+\t  if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t    {\n+\t      if (TREE_CODE (tem) == FUNCTION_DECL)\n+\t\tcp_pedwarn (\"public decl `%#D' uses anonymous type\", tem);\n+\t    }\n+\t  else\n+\t    cp_pedwarn (\"non-local decl `%#D' uses local type `%T'\", tem, t);\n+\t}\n+    }\n+\n #if 0\n   /* We have no way of knowing whether the initializer will need to be\n      evaluated at run-time or not until we've parsed it, so let's just put\n@@ -7897,7 +7917,28 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n       inlinep = 0;\n       publicp = 1;\n     }\n-\t  \n+\n+  /* Members of anonymous types have no linkage; make them internal.  */\n+  if (ctype && ANON_AGGRNAME_P (TYPE_IDENTIFIER (ctype)))\n+    publicp = 0;\n+\n+  if (publicp)\n+    {\n+      /* [basic.link]: A name with no linkage (notably, the name of a class\n+\t or enumeration declared in a local scope) shall not be used to\n+\t declare an entity with linkage.\n+\n+\t Only check this for public decls for now.  */\n+      t = no_linkage_check (TREE_TYPE (decl));\n+      if (t)\n+\t{\n+\t  if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t    cp_pedwarn (\"function `%#D' uses anonymous type\", decl);\n+\t  else\n+\t    cp_pedwarn (\"function `%#D' uses local type `%T'\", decl, t);\n+\t}\n+    }\n+\n   TREE_PUBLIC (decl) = publicp;\n   if (! publicp)\n     {\n@@ -8157,6 +8198,25 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n       TREE_STATIC (decl) = !! RIDBIT_SETP (RID_STATIC, specbits);\n       TREE_PUBLIC (decl) = DECL_EXTERNAL (decl);\n     }\n+\n+  if (TREE_PUBLIC (decl))\n+    {\n+      /* [basic.link]: A name with no linkage (notably, the name of a class\n+\t or enumeration declared in a local scope) shall not be used to\n+\t declare an entity with linkage.\n+\n+\t Only check this for public decls for now.  */\n+      tree t = no_linkage_check (TREE_TYPE (decl));\n+      if (t)\n+\t{\n+\t  if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t    /* Ignore for now; `enum { foo } e' is pretty common.  */;\n+\t  else\n+\t    cp_pedwarn (\"non-local variable `%#D' uses local type `%T'\",\n+\t\t\tdecl, t);\n+\t}\n+    }\n+\n   return decl;\n }\n \n@@ -9991,6 +10051,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  DECL_ASSEMBLER_NAME (decl)\n \t    = get_identifier (build_overload_name (type, 1, 1));\n \t  DECL_CONTEXT (decl) = NULL_TREE;\n+\n+\t  /* FIXME remangle member functions; member functions of a\n+\t     type with external linkage have external linkage.  */\n \t}\n \n       if (TREE_CODE (type) == OFFSET_TYPE || TREE_CODE (type) == METHOD_TYPE)"}, {"sha": "51ee80ca9f37acd6e30e6ba2f50c673f42ca7f1d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=50a6dbd707c86a270efa591413e9c944b470741e", "patch": "@@ -1411,11 +1411,6 @@ process_overload_item (parmtype, extra_Gcode)\n       {\n         tree name = TYPE_NAME (parmtype);\n \n-        if (TREE_CODE (name) == IDENTIFIER_NODE)\n-          {\n-            build_overload_identifier (TYPE_NAME (parmtype));\n-            break;\n-          }\n         my_friendly_assert (TREE_CODE (name) == TYPE_DECL, 248);\n \n         build_qualified_name (name);"}, {"sha": "b0202b13198bd598db14d69ee3ea36fb6020490b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=50a6dbd707c86a270efa591413e9c944b470741e", "patch": "@@ -2832,13 +2832,21 @@ coerce_template_parms (parms, arglist, in_decl,\n \t      val = groktypename (arg);\n \t      if (! processing_template_decl)\n \t\t{\n-\t\t  tree t = target_type (val);\n-\t\t  if (((IS_AGGR_TYPE (t) && TREE_CODE (t) != TYPENAME_TYPE)\n-\t\t       || TREE_CODE (t) == ENUMERAL_TYPE)\n-\t\t      && decl_function_context (TYPE_MAIN_DECL (t)))\n+\t\t  /* [basic.link]: A name with no linkage (notably, the\n+                     name of a class or enumeration declared in a local\n+                     scope) shall not be used to declare an entity with\n+                     linkage.  This implies that names with no linkage\n+                     cannot be used as template arguments.  */\n+\t\t  tree t = no_linkage_check (val);\n+\t\t  if (t)\n \t\t    {\n-\t\t      cp_error (\"type `%T' composed from a local type is not a valid template-argument\",\n-\t\t\t\tval);\n+\t\t      if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t\t\tcp_pedwarn\n+\t\t\t  (\"template-argument `%T' uses anonymous type\", val);\n+\t\t      else\n+\t\t\tcp_error\n+\t\t\t  (\"template-argument `%T' uses local type `%T'\",\n+\t\t\t   val, t);\n \t\t      return error_mark_node;\n \t\t    }\n \t\t}\n@@ -3435,7 +3443,11 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t{\n \t  DECL_ASSEMBLER_NAME (type_decl)\n \t    = get_identifier (build_overload_name (t, 1, 1));\n-\t  \n+\n+\t  /* For backwards compatibility; code that uses\n+\t     -fexternal-templates expects looking up a template to\n+\t     instantiate it.  I think DDD still relies on this.\n+\t     (jason 8/20/1998) */\n \t  if (TREE_CODE (t) != ENUMERAL_TYPE\n \t      && flag_external_templates\n \t      && CLASSTYPE_INTERFACE_KNOWN (TREE_TYPE (template))"}, {"sha": "13d8a08fa0a4f25dca4b6c4c1ecba64bc256b2ba", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a6dbd707c86a270efa591413e9c944b470741e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=50a6dbd707c86a270efa591413e9c944b470741e", "patch": "@@ -1557,6 +1557,252 @@ copy_template_template_parm (t)\n   return t2;\n }\n \n+/* Walk through the tree structure T, applying func.  If func ever returns\n+   non-null, return that value.  */\n+\n+static tree\n+search_tree (t, func)\n+     tree t;\n+     tree (*func) PROTO((tree));\n+{\n+#define TRY(ARG) if (tmp = walk_tree (ARG, func), tmp != NULL_TREE) return tmp\n+\n+  tree tmp;\n+\n+  if (t == NULL_TREE)\n+    return t;\n+\n+  if (tmp = func (t), tmp != NULL_TREE)\n+    return tmp;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case ERROR_MARK:\n+      break;\n+\n+    case IDENTIFIER_NODE:\n+      break;\n+\n+    case VAR_DECL:\n+    case FUNCTION_DECL:\n+    case CONST_DECL:\n+    case TEMPLATE_DECL:\n+    case NAMESPACE_DECL:\n+      break;\n+\n+    case TYPE_DECL:\n+      TRY (TREE_TYPE (t));\n+      break;\n+\n+    case PARM_DECL:\n+      TRY (TREE_TYPE (t));\n+      TRY (TREE_CHAIN (t));\n+      break;\n+\n+    case TREE_LIST:\n+      TRY (TREE_PURPOSE (t));\n+      TRY (TREE_VALUE (t));\n+      TRY (TREE_CHAIN (t));\n+      break;\n+\n+    case OVERLOAD:\n+      TRY (OVL_FUNCTION (t));\n+      TRY (OVL_CHAIN (t));\n+      break;\n+\n+    case TREE_VEC:\n+      {\n+\tint len = TREE_VEC_LENGTH (t);\n+\n+\tt = copy_node (t);\n+\twhile (len--)\n+\t  TRY (TREE_VEC_ELT (t, len));\n+      }\n+      break;\n+\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case STRING_CST:\n+    case DEFAULT_ARG:\n+      break;\n+\n+    case COND_EXPR:\n+    case TARGET_EXPR:\n+    case AGGR_INIT_EXPR:\n+    case NEW_EXPR:\n+      TRY (TREE_OPERAND (t, 0));\n+      TRY (TREE_OPERAND (t, 1));\n+      TRY (TREE_OPERAND (t, 2));\n+      break;\n+\n+    case MODIFY_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_ANDTC_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case COMPOUND_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case ARRAY_REF:\n+    case SCOPE_REF:\n+    case TRY_CATCH_EXPR:\n+    case WITH_CLEANUP_EXPR:\n+    case CALL_EXPR:\n+      TRY (TREE_OPERAND (t, 0));\n+      TRY (TREE_OPERAND (t, 1));\n+      break;\n+\n+    case SAVE_EXPR:\n+    case CONVERT_EXPR:\n+    case ADDR_EXPR:\n+    case INDIRECT_REF:\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case NOP_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case COMPONENT_REF:\n+    case CLEANUP_POINT_EXPR:\n+    case LOOKUP_EXPR:\n+    case SIZEOF_EXPR:\n+    case ALIGNOF_EXPR:\n+      TRY (TREE_OPERAND (t, 0));\n+      break;\n+\n+    case MODOP_EXPR:\n+    case CAST_EXPR:\n+    case REINTERPRET_CAST_EXPR:\n+    case CONST_CAST_EXPR:\n+    case STATIC_CAST_EXPR:\n+    case DYNAMIC_CAST_EXPR:\n+    case ARROW_EXPR:\n+    case DOTSTAR_EXPR:\n+    case TYPEID_EXPR:\n+      break;\n+\n+    case COMPLEX_CST:\n+      TRY (TREE_REALPART (t));\n+      TRY (TREE_IMAGPART (t));\n+      break;\n+\n+    case CONSTRUCTOR:\n+      TRY (CONSTRUCTOR_ELTS (t));\n+      break;\n+\n+    case TEMPLATE_TEMPLATE_PARM:\n+    case TEMPLATE_PARM_INDEX:\n+    case TEMPLATE_TYPE_PARM:\n+      break;\n+\n+    case BIND_EXPR:\n+      break;\n+\n+    case REAL_TYPE:\n+    case COMPLEX_TYPE:\n+    case VOID_TYPE:\n+    case BOOLEAN_TYPE:\n+    case TYPENAME_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      break;\n+\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      TRY (TREE_TYPE (t));\n+      break;\n+\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+      TRY (TREE_TYPE (t));\n+      TRY (TYPE_ARG_TYPES (t));\n+      break;\n+\n+    case ARRAY_TYPE:\n+      TRY (TREE_TYPE (t));\n+      TRY (TYPE_DOMAIN (t));\n+      break;\n+\n+    case INTEGER_TYPE:\n+      TRY (TYPE_MAX_VALUE (t));\n+      break;\n+\n+    case OFFSET_TYPE:\n+      TRY (TREE_TYPE (t));\n+      TRY (TYPE_OFFSET_BASETYPE (t));\n+      break;\n+\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (t))\n+\tTRY (TYPE_PTRMEMFUNC_FN_TYPE (t));\n+      break;\n+      \n+      /*  This list is incomplete, but should suffice for now.\n+\t  It is very important that `sorry' not call\n+\t  `report_error_function'.  That could cause an infinite loop.  */\n+    default:\n+      sorry (\"initializer contains unrecognized tree code\");\n+      return error_mark_node;\n+\n+    }\n+\n+  return NULL_TREE;\n+\n+#undef TRY\n+}\n+\n+/* Passed to search_tree.  Checks for the use of types with no linkage.  */\n+\n+static tree\n+no_linkage_helper (t)\n+     tree t;\n+{\n+  if (TYPE_P (t)\n+      && (IS_AGGR_TYPE (t) || TREE_CODE (t) == ENUMERAL_TYPE)\n+      && (decl_function_context (TYPE_MAIN_DECL (t))\n+\t  || ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))))\n+    return t;\n+  return NULL_TREE;\n+}\n+\n+/* Check if the type T depends on a type with no linkage and if so, return\n+   it.  */\n+\n+tree\n+no_linkage_check (t)\n+     tree t;\n+{\n+  t = search_tree (t, no_linkage_helper);\n+  if (t != error_mark_node)\n+    return t;\n+  return NULL_TREE;\n+}\n+\n+\n /* Subroutine of copy_to_permanent\n \n    Assuming T is a node build bottom-up, make it all exist on"}]}