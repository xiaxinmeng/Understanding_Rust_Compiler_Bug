{"sha": "22806403ec9dff3f819ac87298aca28a7e795cb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI4MDY0MDNlYzlkZmYzZjgxOWFjODcyOThhY2EyOGE3ZTc5NWNiMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-03T15:51:38Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-03T15:51:38Z"}, "message": "re PR go/61877 (reflect: cannot use []string as type string in Call)\n\n\tPR go/61877\nrefect: fix direct call of variadic method value\n\nAs reported in bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61877\ngcc mainline has regressed in this.  This CL adds the tests proposed\nfor the main Go repository:\n\n        https://codereview.appspot.com/151280043/\n        https://codereview.appspot.com/152060043/\n\nrestores the code from the amd64/386 path that makes this work and\nwas lost when the Go 1.3 stdlib was merged and changes the FFI path\nto call into the same helper code as the amd64/386 path.\n\nI've only tested this on amd64 but I did test a version that was\npatched to unconditionally take the FFI path.\n\nFrom-SVN: r215859", "tree": {"sha": "b092d9b0ceaf4ff19e48ba6cb48bf54842aac96c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b092d9b0ceaf4ff19e48ba6cb48bf54842aac96c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22806403ec9dff3f819ac87298aca28a7e795cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22806403ec9dff3f819ac87298aca28a7e795cb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22806403ec9dff3f819ac87298aca28a7e795cb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22806403ec9dff3f819ac87298aca28a7e795cb0/comments", "author": null, "committer": null, "parents": [{"sha": "acbe08d242491a93e90957116dffa81c9f91ee11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acbe08d242491a93e90957116dffa81c9f91ee11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acbe08d242491a93e90957116dffa81c9f91ee11"}], "stats": {"total": 136, "additions": 97, "deletions": 39}, "files": [{"sha": "3e107795bdf13f18345a3bf896c741848aa688ae", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 71, "deletions": 6, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22806403ec9dff3f819ac87298aca28a7e795cb0/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22806403ec9dff3f819ac87298aca28a7e795cb0/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=22806403ec9dff3f819ac87298aca28a7e795cb0", "patch": "@@ -1543,7 +1543,17 @@ func TestMakeFuncVariadic(t *testing.T) {\n \tfv := MakeFunc(TypeOf(fn), func(in []Value) []Value { return in[1:2] })\n \tValueOf(&fn).Elem().Set(fv)\n \n-\tr := fv.Call([]Value{ValueOf(1), ValueOf(2), ValueOf(3)})[0].Interface().([]int)\n+\tr := fn(1, 2, 3)\n+\tif r[0] != 2 || r[1] != 3 {\n+\t\tt.Errorf(\"Call returned [%v, %v]; want 2, 3\", r[0], r[1])\n+\t}\n+\n+\tr = fn(1, []int{2, 3}...)\n+\tif r[0] != 2 || r[1] != 3 {\n+\t\tt.Errorf(\"Call returned [%v, %v]; want 2, 3\", r[0], r[1])\n+\t}\n+\n+\tr = fv.Call([]Value{ValueOf(1), ValueOf(2), ValueOf(3)})[0].Interface().([]int)\n \tif r[0] != 2 || r[1] != 3 {\n \t\tt.Errorf(\"Call returned [%v, %v]; want 2, 3\", r[0], r[1])\n \t}\n@@ -1552,6 +1562,17 @@ func TestMakeFuncVariadic(t *testing.T) {\n \tif r[0] != 2 || r[1] != 3 {\n \t\tt.Errorf(\"Call returned [%v, %v]; want 2, 3\", r[0], r[1])\n \t}\n+\n+\tf := fv.Interface().(func(int, ...int) []int)\n+\n+\tr = f(1, 2, 3)\n+\tif r[0] != 2 || r[1] != 3 {\n+\t\tt.Errorf(\"Call returned [%v, %v]; want 2, 3\", r[0], r[1])\n+\t}\n+\tr = f(1, []int{2, 3}...)\n+\tif r[0] != 2 || r[1] != 3 {\n+\t\tt.Errorf(\"Call returned [%v, %v]; want 2, 3\", r[0], r[1])\n+\t}\n }\n \n type Point struct {\n@@ -1569,6 +1590,24 @@ func (p Point) Dist(scale int) int {\n \treturn p.x*p.x*scale + p.y*p.y*scale\n }\n \n+// This will be index 2.\n+func (p Point) GCMethod(k int) int {\n+\truntime.GC()\n+\treturn k + p.x\n+}\n+\n+// This will be index 3.\n+func (p Point) TotalDist(points ...Point) int {\n+\ttot := 0\n+\tfor _, q := range points {\n+\t\tdx := q.x - p.x\n+\t\tdy := q.y - p.y\n+\t\ttot += dx*dx + dy*dy // Should call Sqrt, but it's just a test.\n+\n+\t}\n+\treturn tot\n+}\n+\n func TestMethod(t *testing.T) {\n \t// Non-curried method of type.\n \tp := Point{3, 4}\n@@ -1751,6 +1790,37 @@ func TestMethodValue(t *testing.T) {\n \t}\n }\n \n+func TestVariadicMethodValue(t *testing.T) {\n+\tp := Point{3, 4}\n+\tpoints := []Point{{20, 21}, {22, 23}, {24, 25}}\n+\twant := int64(p.TotalDist(points[0], points[1], points[2]))\n+\n+\t// Curried method of value.\n+\ttfunc := TypeOf((func(...Point) int)(nil))\n+\tv := ValueOf(p).Method(3)\n+\tif tt := v.Type(); tt != tfunc {\n+\t\tt.Errorf(\"Variadic Method Type is %s; want %s\", tt, tfunc)\n+\t}\n+\ti := ValueOf(v.Interface()).Call([]Value{ValueOf(points[0]), ValueOf(points[1]), ValueOf(points[2])})[0].Int()\n+\tif i != want {\n+\t\tt.Errorf(\"Variadic Method returned %d; want %d\", i, want)\n+\t}\n+\ti = ValueOf(v.Interface()).CallSlice([]Value{ValueOf(points)})[0].Int()\n+\tif i != want {\n+\t\tt.Errorf(\"Variadic Method CallSlice returned %d; want %d\", i, want)\n+\t}\n+\n+\tf := v.Interface().(func(...Point) int)\n+\ti = int64(f(points[0], points[1], points[2]))\n+\tif i != want {\n+\t\tt.Errorf(\"Variadic Method Interface returned %d; want %d\", i, want)\n+\t}\n+\ti = int64(f(points...))\n+\tif i != want {\n+\t\tt.Errorf(\"Variadic Method Interface Slice returned %d; want %d\", i, want)\n+\t}\n+}\n+\n // Reflect version of $GOROOT/test/method5.go\n \n // Concrete types implementing M method.\n@@ -3718,11 +3788,6 @@ func TestReflectFuncTraceback(t *testing.T) {\n \tf.Call([]Value{})\n }\n \n-func (p Point) GCMethod(k int) int {\n-\truntime.GC()\n-\treturn k + p.x\n-}\n-\n func TestReflectMethodTraceback(t *testing.T) {\n \tp := Point{3, 4}\n \tm := ValueOf(p).MethodByName(\"GCMethod\")"}, {"sha": "977aacfd4382af704f64b10c82bcb003f9385905", "filename": "libgo/go/reflect/makefunc.go", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22806403ec9dff3f819ac87298aca28a7e795cb0/libgo%2Fgo%2Freflect%2Fmakefunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22806403ec9dff3f819ac87298aca28a7e795cb0/libgo%2Fgo%2Freflect%2Fmakefunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc.go?ref=22806403ec9dff3f819ac87298aca28a7e795cb0", "patch": "@@ -117,29 +117,21 @@ func makeMethodValue(op string, v Value) Value {\n \tftyp := (*funcType)(unsafe.Pointer(t))\n \tmethod := int(v.flag) >> flagMethodShift\n \n-\tvar code uintptr\n-\tvar ffi *ffiData\n+\tfv := &makeFuncImpl{\n+\t\ttyp:    ftyp,\n+\t\tmethod: method,\n+\t\trcvr:   rcvr,\n+\t}\n+\n \tswitch runtime.GOARCH {\n \tcase \"amd64\", \"386\":\n \t\t// Indirect Go func value (dummy) to obtain actual\n \t\t// code address. (A Go func value is a pointer to a C\n \t\t// function pointer. http://golang.org/s/go11func.)\n \t\tdummy := makeFuncStub\n-\t\tcode = **(**uintptr)(unsafe.Pointer(&dummy))\n+\t\tfv.code = **(**uintptr)(unsafe.Pointer(&dummy))\n \tdefault:\n-\t\tcode, ffi = makeFuncFFI(ftyp,\n-\t\t\tfunc(in []Value) []Value {\n-\t\t\t\tm := rcvr.Method(method)\n-\t\t\t\treturn m.Call(in)\n-\t\t\t})\n-\t}\n-\n-\tfv := &makeFuncImpl{\n-\t\tcode:   code,\n-\t\ttyp:    ftyp,\n-\t\tmethod: method,\n-\t\trcvr:   rcvr,\n-\t\tffi:    ffi,\n+\t\tfv.code, fv.ffi = makeFuncFFI(ftyp, fv.call)\n \t}\n \n \treturn Value{ft, unsafe.Pointer(&fv), v.flag&flagRO | flag(Func)<<flagKindShift | flagIndir}\n@@ -160,28 +152,21 @@ func makeValueMethod(v Value) Value {\n \tt := typ.common()\n \tftyp := (*funcType)(unsafe.Pointer(t))\n \n-\tvar code uintptr\n-\tvar ffi *ffiData\n+\timpl := &makeFuncImpl{\n+\t\ttyp:    ftyp,\n+\t\tmethod: -2,\n+\t\trcvr:   v,\n+\t}\n+\n \tswitch runtime.GOARCH {\n \tcase \"amd64\", \"386\":\n \t\t// Indirect Go func value (dummy) to obtain actual\n \t\t// code address. (A Go func value is a pointer to a C\n \t\t// function pointer. http://golang.org/s/go11func.)\n \t\tdummy := makeFuncStub\n-\t\tcode = **(**uintptr)(unsafe.Pointer(&dummy))\n+\t\timpl.code = **(**uintptr)(unsafe.Pointer(&dummy))\n \tdefault:\n-\t\tcode, ffi = makeFuncFFI(ftyp,\n-\t\t\tfunc(in []Value) []Value {\n-\t\t\t\treturn v.Call(in)\n-\t\t\t})\n-\t}\n-\n-\timpl := &makeFuncImpl{\n-\t\tcode:   code,\n-\t\ttyp:    ftyp,\n-\t\tmethod: -2,\n-\t\trcvr:   v,\n-\t\tffi:    ffi,\n+\t\timpl.code, impl.ffi = makeFuncFFI(ftyp, impl.call)\n \t}\n \n \treturn Value{t, unsafe.Pointer(&impl), flag(Func<<flagKindShift) | flagIndir}\n@@ -192,9 +177,17 @@ func (c *makeFuncImpl) call(in []Value) []Value {\n \tif c.method == -1 {\n \t\treturn c.fn(in)\n \t} else if c.method == -2 {\n-\t\treturn c.rcvr.Call(in)\n+\t\tif c.typ.IsVariadic() {\n+\t\t\treturn c.rcvr.CallSlice(in)\n+\t\t} else {\n+\t\t\treturn c.rcvr.Call(in)\n+\t\t}\n \t} else {\n \t\tm := c.rcvr.Method(c.method)\n-\t\treturn m.Call(in)\n+\t\tif c.typ.IsVariadic() {\n+\t\t\treturn m.CallSlice(in)\n+\t\t} else {\n+\t\t\treturn m.Call(in)\n+\t\t}\n \t}\n }"}]}