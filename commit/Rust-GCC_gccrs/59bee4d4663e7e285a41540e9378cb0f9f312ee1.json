{"sha": "59bee4d4663e7e285a41540e9378cb0f9f312ee1", "node_id": "C_kwDOANBUbNoAKDU5YmVlNGQ0NjYzZTdlMjg1YTQxNTQwZTkzNzhjYjBmOWYzMTJlZTE", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-13T09:10:37Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-02-21T11:36:33Z"}, "message": "gccrs: Method resolution must support multiple candidates\n\nThis patch fixes bad method resolution in our operator_overload_9 case.\nWhen we have a &mut reference to something and we deref we must resolve to\nthe mutable reference impl block. The interface we are using to resolve\nmethods is the can_eq interface which allows for permissive mutability\nwhich means allowing for mutable reference being unified with an immutable\none. This meant we actual match against both the immutable and mutable\nversion leading to multiple candidate error.\n\nThe fix here adds a method resolution flag to the can_eq interface so that\nwe enforce mutability equality. The other hack is that we do not allow\ncan_eq of ParamTypes to generic Slices. I think there is some subtle thing\ngoing on for that case. The Rustc method resolver actually filters the\nimpl blocks for reference types based looking up the relevant lang items\nwe need to do this as well but is a much larger refactor to our method\nresolver which should be done seperately.\n\nFixes #1588\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-autoderef.cc: Add support for multiple resolution candidates.\n\t* typecheck/rust-hir-dot-operator.cc (MethodResolver::MethodResolver): Edit\n\t`try_result` field and change constructor.\n\t(MethodResolver::Probe): Return set of candidates instead of singular candidate.\n\t(MethodResolver::select): Add better implementation to account for multiple\n\tcandidates.\n\t* typecheck/rust-hir-dot-operator.h (struct MethodCandidate): Overload comparison\n\toperator in order to store them in `std::set`.\n\t* typecheck/rust-hir-inherent-impl-overlap.h: Do not fail assertion on missing type.\n\t* typecheck/rust-hir-type-check-expr.cc (TypeCheckExpr::visit): Adapt code to use\n\tmultiple candidates.\n\t* typecheck/rust-tyty.cc (set_cmp_autoderef_mode): Add code to handle automatic\n\tderefs properly.\n\t(reset_cmp_autoderef_mode): Add helper function to reset said mode.\n\t* typecheck/rust-tyty.h (set_cmp_autoderef_mode): Declare function.\n\t(reset_cmp_autoderef_mode): Likewise.\n\t* typecheck/rust-tyty-cmp.h: Add handling of `autoderef_cmp_flag`\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/generics7.rs: Fix test with missing assertion.\n\t* rust/execute/torture/operator_overload_9.rs: Fix test assertion.", "tree": {"sha": "2283b25ed9a4f4eee89372c65af858a16dcfd47a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2283b25ed9a4f4eee89372c65af858a16dcfd47a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59bee4d4663e7e285a41540e9378cb0f9f312ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59bee4d4663e7e285a41540e9378cb0f9f312ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59bee4d4663e7e285a41540e9378cb0f9f312ee1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59bee4d4663e7e285a41540e9378cb0f9f312ee1/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d7661e76e1276b3661502022ecee2861d040026", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d7661e76e1276b3661502022ecee2861d040026", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d7661e76e1276b3661502022ecee2861d040026"}], "stats": {"total": 188, "additions": 157, "deletions": 31}, "files": [{"sha": "fe05aeec3884fbaa9cb1c1a5140ea9736d767965", "filename": "gcc/rust/typecheck/rust-autoderef.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc?ref=59bee4d4663e7e285a41540e9378cb0f9f312ee1", "patch": "@@ -139,15 +139,23 @@ resolve_operator_overload_fn (\n     return false;\n \n   auto segment = HIR::PathIdentSegment (associated_item_name);\n-  auto candidate\n+  auto candidates\n     = MethodResolver::Probe (ty, HIR::PathIdentSegment (associated_item_name),\n \t\t\t     true);\n \n-  bool have_implementation_for_lang_item = !candidate.is_error ();\n+  bool have_implementation_for_lang_item = !candidates.empty ();\n   if (!have_implementation_for_lang_item)\n     return false;\n \n+  // multiple candidates?\n+  if (candidates.size () > 1)\n+    {\n+      // error out? probably not for this case\n+      return false;\n+    }\n+\n   // Get the adjusted self\n+  auto candidate = *candidates.begin ();\n   Adjuster adj (ty);\n   TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n "}, {"sha": "84fa8d4f08b6d0f8b4068b6fa9f6036c23a9d80e", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.cc", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc?ref=59bee4d4663e7e285a41540e9378cb0f9f312ee1", "patch": "@@ -25,18 +25,17 @@ namespace Resolver {\n \n MethodResolver::MethodResolver (bool autoderef_flag,\n \t\t\t\tconst HIR::PathIdentSegment &segment_name)\n-  : AutoderefCycle (autoderef_flag), segment_name (segment_name),\n-    try_result (MethodCandidate::get_error ())\n+  : AutoderefCycle (autoderef_flag), segment_name (segment_name), result ()\n {}\n \n-MethodCandidate\n+std::set<MethodCandidate>\n MethodResolver::Probe (const TyTy::BaseType *receiver,\n \t\t       const HIR::PathIdentSegment &segment_name,\n \t\t       bool autoderef_flag)\n {\n   MethodResolver resolver (autoderef_flag, segment_name);\n-  bool ok = resolver.cycle (receiver);\n-  return ok ? resolver.try_result : MethodCandidate::get_error ();\n+  resolver.cycle (receiver);\n+  return resolver.result;\n }\n \n void\n@@ -177,8 +176,18 @@ MethodResolver::select (const TyTy::BaseType &receiver)\n \t      (unsigned long) trait_fns.size (),\n \t      (unsigned long) predicate_items.size ());\n \n-  for (auto impl_item : inherent_impl_fns)\n+  // see the follow for the proper fix to get rid of this we need to assemble\n+  // candidates based on a match expression gathering the relevant impl blocks\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/method/probe.rs#L580-L694\n+  TyTy::set_cmp_autoderef_mode ();\n+\n+  bool found_possible_candidate = false;\n+  for (auto &impl_item : inherent_impl_fns)\n     {\n+      bool is_trait_impl_block = impl_item.impl_block->has_trait_ref ();\n+      if (is_trait_impl_block)\n+\tcontinue;\n+\n       TyTy::FnType *fn = impl_item.ty;\n       rust_assert (fn->is_method ());\n \n@@ -190,13 +199,50 @@ MethodResolver::select (const TyTy::BaseType &receiver)\n \t{\n \t  PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n \t\t\t\t\t\t  impl_item.impl_block};\n-\t  try_result = MethodCandidate{\n+\t  auto try_result = MethodCandidate{\n \t    PathProbeCandidate (PathProbeCandidate::CandidateType::IMPL_FUNC,\n \t\t\t\tfn, impl_item.item->get_locus (), c),\n \t    adjustments};\n-\t  return true;\n+\t  result.insert (std::move (try_result));\n+\t  found_possible_candidate = true;\n \t}\n     }\n+  if (found_possible_candidate)\n+    {\n+      TyTy::reset_cmp_autoderef_mode ();\n+      return true;\n+    }\n+\n+  for (auto &impl_item : inherent_impl_fns)\n+    {\n+      bool is_trait_impl_block = impl_item.impl_block->has_trait_ref ();\n+      if (!is_trait_impl_block)\n+\tcontinue;\n+\n+      TyTy::FnType *fn = impl_item.ty;\n+      rust_assert (fn->is_method ());\n+\n+      TyTy::BaseType *fn_self = fn->get_self_type ();\n+      rust_debug (\n+\t\"dot-operator trait_impl_item fn_self={%s} can_eq receiver={%s}\",\n+\tfn_self->debug_str ().c_str (), receiver.debug_str ().c_str ());\n+      if (fn_self->can_eq (&receiver, false))\n+\t{\n+\t  PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n+\t\t\t\t\t\t  impl_item.impl_block};\n+\t  auto try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::IMPL_FUNC,\n+\t\t\t\tfn, impl_item.item->get_locus (), c),\n+\t    adjustments};\n+\t  result.insert (std::move (try_result));\n+\t  found_possible_candidate = true;\n+\t}\n+    }\n+  if (found_possible_candidate)\n+    {\n+      TyTy::reset_cmp_autoderef_mode ();\n+      return true;\n+    }\n \n   for (auto trait_item : trait_fns)\n     {\n@@ -212,13 +258,19 @@ MethodResolver::select (const TyTy::BaseType &receiver)\n \t  PathProbeCandidate::TraitItemCandidate c{trait_item.reference,\n \t\t\t\t\t\t   trait_item.item_ref,\n \t\t\t\t\t\t   nullptr};\n-\t  try_result = MethodCandidate{\n+\t  auto try_result = MethodCandidate{\n \t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n \t\t\t\tfn, trait_item.item->get_locus (), c),\n \t    adjustments};\n-\t  return true;\n+\t  result.insert (std::move (try_result));\n+\t  found_possible_candidate = true;\n \t}\n     }\n+  if (found_possible_candidate)\n+    {\n+      TyTy::reset_cmp_autoderef_mode ();\n+      return true;\n+    }\n \n   for (const auto &predicate : predicate_items)\n     {\n@@ -238,15 +290,17 @@ MethodResolver::select (const TyTy::BaseType &receiver)\n \n \t  PathProbeCandidate::TraitItemCandidate c{trait_ref, trait_item,\n \t\t\t\t\t\t   nullptr};\n-\t  try_result = MethodCandidate{\n+\t  auto try_result = MethodCandidate{\n \t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n \t\t\t\tfn->clone (), trait_item->get_locus (), c),\n \t    adjustments};\n-\t  return true;\n+\t  result.insert (std::move (try_result));\n+\t  found_possible_candidate = true;\n \t}\n     }\n \n-  return false;\n+  TyTy::reset_cmp_autoderef_mode ();\n+  return found_possible_candidate;\n }\n \n std::vector<MethodResolver::predicate_candidate>"}, {"sha": "e14baf3f87d0e8c1650064c6cfa4b34bed49fa6b", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=59bee4d4663e7e285a41540e9378cb0f9f312ee1", "patch": "@@ -35,6 +35,13 @@ struct MethodCandidate\n   }\n \n   bool is_error () const { return candidate.is_error (); }\n+\n+  DefId get_defid () const { return candidate.get_defid (); }\n+\n+  bool operator< (const MethodCandidate &c) const\n+  {\n+    return get_defid () < c.get_defid ();\n+  }\n };\n \n class MethodResolver : private TypeCheckBase, protected AutoderefCycle\n@@ -46,9 +53,10 @@ class MethodResolver : private TypeCheckBase, protected AutoderefCycle\n     TyTy::FnType *fntype;\n   };\n \n-  static MethodCandidate Probe (const TyTy::BaseType *receiver,\n-\t\t\t\tconst HIR::PathIdentSegment &segment_name,\n-\t\t\t\tbool autoderef_flag = false);\n+  static std::set<MethodCandidate>\n+  Probe (const TyTy::BaseType *receiver,\n+\t const HIR::PathIdentSegment &segment_name,\n+\t bool autoderef_flag = false);\n \n   static std::vector<predicate_candidate> get_predicate_items (\n     const HIR::PathIdentSegment &segment_name, const TyTy::BaseType &receiver,\n@@ -68,7 +76,7 @@ class MethodResolver : private TypeCheckBase, protected AutoderefCycle\n   std::vector<MethodResolver::predicate_candidate> predicate_items;\n \n   // mutable fields\n-  MethodCandidate try_result;\n+  std::set<MethodCandidate> result;\n };\n \n } // namespace Resolver"}, {"sha": "6e2fe1b2286eb4d77c7066df9cc4f0fd857672f2", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=59bee4d4663e7e285a41540e9378cb0f9f312ee1", "patch": "@@ -93,8 +93,9 @@ class OverlappingImplItemPass : public TypeCheckBase\n \n     HirId impl_type_id = impl->get_type ()->get_mappings ().get_hirid ();\n     TyTy::BaseType *impl_type = nullptr;\n-    bool ok = context->lookup_type (impl_type_id, &impl_type);\n-    rust_assert (ok);\n+    bool ok = query_type (impl_type_id, &impl_type);\n+    if (!ok)\n+      return;\n \n     std::string impl_item_name;\n     ok = ImplItemToName::resolve (impl_item, impl_item_name);"}, {"sha": "4e377d52a0fb4a44f7bd300d4149aecf1dc3330b", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=59bee4d4663e7e285a41540e9378cb0f9f312ee1", "patch": "@@ -1015,10 +1015,10 @@ TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n \n   context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n \n-  auto candidate\n+  auto candidates\n     = MethodResolver::Probe (receiver_tyty,\n \t\t\t     expr.get_method_name ().get_segment ());\n-  if (candidate.is_error ())\n+  if (candidates.empty ())\n     {\n       rust_error_at (\n \texpr.get_method_name ().get_locus (),\n@@ -1027,6 +1027,19 @@ TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n       return;\n     }\n \n+  if (candidates.size () > 1)\n+    {\n+      RichLocation r (expr.get_method_name ().get_locus ());\n+      for (auto &c : candidates)\n+\tr.add_range (c.candidate.locus);\n+\n+      rust_error_at (\n+\tr, \"multiple candidates found for method %<%s%>\",\n+\texpr.get_method_name ().get_segment ().as_string ().c_str ());\n+      return;\n+    }\n+\n+  auto candidate = *candidates.begin ();\n   rust_debug_loc (expr.get_method_name ().get_locus (),\n \t\t  \"resolved method to: {%u} {%s}\",\n \t\t  candidate.candidate.ty->get_ref (),\n@@ -1422,14 +1435,28 @@ TypeCheckExpr::resolve_operator_overload (\n     return false;\n \n   auto segment = HIR::PathIdentSegment (associated_item_name);\n-  auto candidate\n+  auto candidates\n     = MethodResolver::Probe (lhs, HIR::PathIdentSegment (associated_item_name));\n \n-  bool have_implementation_for_lang_item = !candidate.is_error ();\n+  bool have_implementation_for_lang_item = candidates.size () > 0;\n   if (!have_implementation_for_lang_item)\n     return false;\n \n+  if (candidates.size () > 1)\n+    {\n+      // mutliple candidates\n+      RichLocation r (expr.get_locus ());\n+      for (auto &c : candidates)\n+\tr.add_range (c.candidate.locus);\n+\n+      rust_error_at (\n+\tr, \"multiple candidates found for possible operator overload\");\n+\n+      return false;\n+    }\n+\n   // Get the adjusted self\n+  auto candidate = *candidates.begin ();\n   Adjuster adj (lhs);\n   TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n "}, {"sha": "5dfd2d7184aaa5200aea6a7e55daf0fc22e3cb8b", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=59bee4d4663e7e285a41540e9378cb0f9f312ee1", "patch": "@@ -28,6 +28,10 @@\n namespace Rust {\n namespace TyTy {\n \n+// we need to fix this properly by implementing the match for assembling\n+// candidates\n+extern bool autoderef_cmp_flag;\n+\n class BaseCmp : public TyConstVisitor\n {\n public:\n@@ -1244,6 +1248,9 @@ class ReferenceCmp : public BaseCmp\n     auto other_base_type = type.get_base ();\n \n     bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n+    if (autoderef_cmp_flag)\n+      mutability_ok = base->mutability () == type.mutability ();\n+\n     if (!mutability_ok)\n       {\n \tBaseCmp::visit (type);\n@@ -1289,9 +1296,10 @@ class PointerCmp : public BaseCmp\n     auto base_type = base->get_base ();\n     auto other_base_type = type.get_base ();\n \n-    // rust is permissive about mutablity here you can always go from mutable to\n-    // immutable but not the otherway round\n     bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n+    if (autoderef_cmp_flag)\n+      mutability_ok = base->mutability () == type.mutability ();\n+\n     if (!mutability_ok)\n       {\n \tBaseCmp::visit (type);\n@@ -1370,7 +1378,7 @@ class ParamCmp : public BaseCmp\n \n   void visit (const ArrayType &) override { ok = true; }\n \n-  void visit (const SliceType &) override { ok = true; }\n+  void visit (const SliceType &) override { ok = !autoderef_cmp_flag; }\n \n   void visit (const BoolType &) override { ok = true; }\n "}, {"sha": "462c5bf91fd19f1b53039106af69260238389226", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=59bee4d4663e7e285a41540e9378cb0f9f312ee1", "patch": "@@ -32,6 +32,19 @@\n namespace Rust {\n namespace TyTy {\n \n+bool autoderef_cmp_flag = false;\n+\n+void\n+set_cmp_autoderef_mode ()\n+{\n+  autoderef_cmp_flag = true;\n+}\n+void\n+reset_cmp_autoderef_mode ()\n+{\n+  autoderef_cmp_flag = false;\n+}\n+\n std::string\n TypeKindFormat::to_string (TypeKind kind)\n {"}, {"sha": "b17f01f67eab178a026570c24e4079ad54b9e430", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=59bee4d4663e7e285a41540e9378cb0f9f312ee1", "patch": "@@ -135,6 +135,11 @@ class TypeBoundsMappings\n   std::vector<TypeBoundPredicate> specified_bounds;\n };\n \n+extern void\n+set_cmp_autoderef_mode ();\n+extern void\n+reset_cmp_autoderef_mode ();\n+\n class TyVisitor;\n class TyConstVisitor;\n class BaseType : public TypeBoundsMappings"}, {"sha": "2789c30ee38421bea4c81b9f3fc44bc6de4f63aa", "filename": "gcc/testsuite/rust/compile/generics7.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs?ref=59bee4d4663e7e285a41540e9378cb0f9f312ee1", "patch": "@@ -3,13 +3,13 @@ struct Foo<A> {\n }\n \n impl Foo<isize> {\n-    fn bar(self) -> isize { // { dg-error \"duplicate definitions with name bar\" }\n+    fn bar(self) -> isize {\n         self.a\n     }\n }\n \n impl Foo<char> {\n-    fn bar(self) -> char { // { dg-error \"duplicate definitions with name bar\" }\n+    fn bar(self) -> char {\n         self.a\n     }\n }\n@@ -23,4 +23,6 @@ impl<T> Foo<T> {\n fn main() {\n     let a = Foo { a: 123 };\n     a.bar();\n+    // { dg-error \"multiple candidates found for method .bar.\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-2 }\n }"}, {"sha": "fd972e28ab35fb08558f0a13b3ebebc347446a22", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bee4d4663e7e285a41540e9378cb0f9f312ee1/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_9.rs?ref=59bee4d4663e7e285a41540e9378cb0f9f312ee1", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-output \"imm_deref\\n123\\n\" } */\n+/* { dg-output \"mut_deref\\n123\\n\" } */\n extern \"C\" {\n     fn printf(s: *const i8, ...);\n }"}]}