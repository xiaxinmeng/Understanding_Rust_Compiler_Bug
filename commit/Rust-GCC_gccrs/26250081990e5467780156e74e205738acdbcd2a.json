{"sha": "26250081990e5467780156e74e205738acdbcd2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYyNTAwODE5OTBlNTQ2Nzc4MDE1NmU3NGUyMDU3MzhhY2RiY2QyYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-12-09T05:11:34Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1997-12-09T05:11:34Z"}, "message": "alpha.c (REG_RA, [...]): Fix merge problems.\n\n* alpha.c (REG_RA, alpha_return_addr, output_epilog):\nFix merge problems.\n\n* alpha.c (override_options): Don't know about scheduling for EV6.\n* alpha.md (ev5 function units): Don't overload as ev6.\n\n* alpha.c (alpha_adjust_cost): Simplify.  Fix typo in ev5 mult case.\n* alpha.md (define_attr type): Add mvi.\n(ev5_e0): Define sceduling parameters for it.\n(TARGET_MAX insns): Type is mvi not shift.\n\nFrom-SVN: r17020", "tree": {"sha": "d3375028fe0d80fc97ca2fe548b101e0ebf6c513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3375028fe0d80fc97ca2fe548b101e0ebf6c513"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26250081990e5467780156e74e205738acdbcd2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26250081990e5467780156e74e205738acdbcd2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26250081990e5467780156e74e205738acdbcd2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26250081990e5467780156e74e205738acdbcd2a/comments", "author": null, "committer": null, "parents": [{"sha": "7120f213cac995d9fd4f7b5592e5453b99924ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7120f213cac995d9fd4f7b5592e5453b99924ee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7120f213cac995d9fd4f7b5592e5453b99924ee0"}], "stats": {"total": 188, "additions": 92, "deletions": 96}, "files": [{"sha": "579746261c0ca880aa7b5015c45a3d3911af039a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26250081990e5467780156e74e205738acdbcd2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26250081990e5467780156e74e205738acdbcd2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26250081990e5467780156e74e205738acdbcd2a", "patch": "@@ -1,3 +1,16 @@\n+Mon Dec  8 21:03:28 1997  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (REG_RA, alpha_return_addr, output_epilog):\n+\tFix merge problems.\n+\n+\t* alpha.c (override_options): Don't know about scheduling for EV6.\n+\t* alpha.md (ev5 function units): Don't overload as ev6.\n+\n+\t* alpha.c (alpha_adjust_cost): Simplify.  Fix typo in ev5 mult case.\n+\t* alpha.md (define_attr type): Add mvi.\n+\t(ev5_e0): Define sceduling parameters for it.\n+\t(TARGET_MAX insns): Type is mvi not shift.\n+\n Mon Dec  8 18:15:00 1997  Richard Henderson  <rth@cygnus.com>\n \n \t* alpha/win-nt.h (TRAMPOLINE_TEMPLATE): Fix backported gcc-2.8 bug."}, {"sha": "0bf28c4db40248ba82a1b0c2d27767e33e5cf73f", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 44, "deletions": 67, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26250081990e5467780156e74e205738acdbcd2a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26250081990e5467780156e74e205738acdbcd2a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=26250081990e5467780156e74e205738acdbcd2a", "patch": "@@ -106,14 +106,23 @@ static void alpha_sa_mask\tPROTO((unsigned long *imaskP,\n #else\n #define NUM_ARGS current_function_args_info\n #endif\n+\n+#if OPEN_VMS\n+#define REG_PV 27\n+#define REG_RA 26\n+#else\n+#define REG_RA 26\n+#endif\n \f\n /* Parse target option strings. */\n \n void\n override_options ()\n {\n+  /* 971208 -- EV6 scheduling parameters are still secret, so don't even\n+     pretend and just schedule for an EV5 for now.  -- r~  */\n   alpha_cpu\n-    = TARGET_CPU_DEFAULT & MASK_CPU_EV6 ? PROCESSOR_EV6\n+    = TARGET_CPU_DEFAULT & MASK_CPU_EV6 ? PROCESSOR_EV5\n       : (TARGET_CPU_DEFAULT & MASK_CPU_EV5 ? PROCESSOR_EV5 : PROCESSOR_EV4);\n \n   if (alpha_cpu_string)\n@@ -138,7 +147,8 @@ override_options ()\n \t  target_flags &= ~ (MASK_CIX | MASK_MAX);\n \t}\n       else if (! strcmp (alpha_cpu_string, \"pca56\")\n-\t       || ! strcmp (alpha_cpu_string, \"21164PC\"))\n+\t       || ! strcmp (alpha_cpu_string, \"21164PC\")\n+\t       || ! strcmp (alpha_cpu_string, \"21164pc\"))\n \t{\n \t  alpha_cpu = PROCESSOR_EV5;\n \t  target_flags |= MASK_BWX | MASK_MAX;\n@@ -147,7 +157,7 @@ override_options ()\n       else if (! strcmp (alpha_cpu_string, \"ev6\")\n \t       || ! strcmp (alpha_cpu_string, \"21264\"))\n \t{\n-\t  alpha_cpu = PROCESSOR_EV6;\n+\t  alpha_cpu = PROCESSOR_EV5;\n \t  target_flags |= MASK_BWX | MASK_CIX | MASK_MAX;\n \t}\n       else\n@@ -1191,6 +1201,7 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n      int cost;\n {\n   rtx set, set_src;\n+  enum attr_type insn_type, dep_insn_type;\n \n   /* If the dependence is an anti-dependence, there is no cost.  For an\n      output dependence, there is sometimes a cost, but it doesn't seem\n@@ -1199,17 +1210,22 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n   if (REG_NOTE_KIND (link) != 0)\n     return 0;\n \n+  /* If we can't recognize the insns, we can't really do anything.  */\n+  if (recog_memoized (insn) < 0 || recog_memoized (dep_insn) < 0)\n+    return cost;\n+\n+  insn_type = get_attr_type (insn);\n+  dep_insn_type = get_attr_type (dep_insn);\n+\n   if (alpha_cpu == PROCESSOR_EV5)\n     {\n       /* And the lord DEC saith:  \"A special bypass provides an effective\n \t latency of 0 cycles for an ICMP or ILOG insn producing the test\n \t operand of an IBR or CMOV insn.\" */\n-      if (recog_memoized (dep_insn) >= 0\n-\t  && (get_attr_type (dep_insn) == TYPE_ICMP\n-\t      || get_attr_type (dep_insn) == TYPE_ILOG)\n-\t  && recog_memoized (insn) >= 0\n-\t  && (get_attr_type (insn) == TYPE_IBR\n-\t      || (get_attr_type (insn) == TYPE_CMOV\n+      if ((dep_insn_type == TYPE_ICMP\n+\t   || dep_insn_type == TYPE_ILOG)\n+\t  && (insn_type == TYPE_IBR\n+\t      || (insn_type == TYPE_CMOV\n \t\t  && !((set = single_set (dep_insn)) != 0\n \t\t       && GET_CODE (PATTERN (insn)) == SET\n \t\t       && (set_src = SET_SRC (PATTERN (insn)),\n@@ -1219,14 +1235,15 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n \t\t\t   || rtx_equal_p (set, XEXP (set_src, 2)))))))\n \treturn 0;\n \n-      /* On EV5 it takes longer to get data to the multiplier than to\n-\t anywhere else, so increase costs.  */\n+      /* \"The multiplier is unable to receive data from IEU bypass paths.\n+\t The instruction issues at the expected time, but its latency is\n+\t increased by the time it takes for the input data to become\n+\t available to the multiplier\" -- which happens in pipeline stage\n+\t six, when results are comitted to the register file.  */\n \n-      if (recog_memoized (insn) >= 0\n-\t  && recog_memoized (dep_insn) >= 0\n-\t  && (get_attr_type (insn) == TYPE_IMULL\n-\t      || get_attr_type (insn) == TYPE_IMULQ\n-\t      || get_attr_type (insn) == TYPE_IMULH)\n+      if ((insn_type == TYPE_IMULL\n+\t   || insn_type == TYPE_IMULQ\n+\t   || insn_type == TYPE_IMULH)\n \t  && (set = single_set (dep_insn)) != 0\n \t  && GET_CODE (PATTERN (insn)) == SET\n \t  && (set_src = SET_SRC (PATTERN (insn)),\n@@ -1235,19 +1252,19 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n \t      rtx_equal_p (set, XEXP (set_src, 0))\n \t      || rtx_equal_p (set, XEXP (set_src, 1))))\n \t{\n-\t  switch (get_attr_type (insn))\n+\t  switch (dep_insn_type)\n \t    {\n+\t    /* These insns produce their results in pipeline stage five.  */\n \t    case TYPE_LD:\n \t    case TYPE_CMOV:\n \t    case TYPE_IMULL:\n \t    case TYPE_IMULQ:\n \t    case TYPE_IMULH:\n+\t    case TYPE_MVI:\n \t      return cost + 1;\n-\t    case TYPE_JSR:\n-\t    case TYPE_IADD:\n-\t    case TYPE_ILOG:\n-\t    case TYPE_SHIFT:\n-\t    case TYPE_ICMP:\n+\n+\t    /* Other integer insns produce results in pipeline stage four.  */\n+\t    default:\n \t      return cost + 2;\n \t    }\n \t}\n@@ -1257,12 +1274,12 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n       /* On EV4, if INSN is a store insn and DEP_INSN is setting the data\n \t being stored, we can sometimes lower the cost.  */\n \n-      if (recog_memoized (insn) >= 0 && get_attr_type (insn) == TYPE_ST\n+      if (insn_type == TYPE_ST\n \t  && (set = single_set (dep_insn)) != 0\n \t  && GET_CODE (PATTERN (insn)) == SET\n \t  && rtx_equal_p (SET_DEST (set), SET_SRC (PATTERN (insn))))\n \t{\n-\t  switch (get_attr_type (dep_insn))\n+\t  switch (dep_insn_type)\n \t    {\n \t    case TYPE_LD:\n \t      /* No savings here.  */\n@@ -1285,11 +1302,9 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n \t two in the MD file.  The only case that it is actually two is\n \t for the address in loads and stores.  */\n \n-      if (recog_memoized (dep_insn) >= 0\n-\t  && (get_attr_type (dep_insn) == TYPE_IADD\n-\t      || get_attr_type (dep_insn) == TYPE_ILOG))\n+      if (dep_insn_type == TYPE_IADD || dep_insn_type == TYPE_ILOG)\n \t{\n-\t  switch (get_attr_type (insn))\n+\t  switch (insn_type)\n \t    {\n \t    case TYPE_LD:\n \t    case TYPE_ST:\n@@ -1302,10 +1317,7 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n       /* The final case is when a compare feeds into an integer branch;\n \t the cost is only one cycle in that case.  */\n \n-      if (recog_memoized (dep_insn) >= 0\n-\t  && get_attr_type (dep_insn) == TYPE_ICMP\n-\t  && recog_memoized (insn) >= 0\n-\t  && get_attr_type (insn) == TYPE_IBR)\n+      if (dep_insn_type == TYPE_ICMP && insn_type == TYPE_IBR)\n \treturn 1;\n     }\n \n@@ -1781,39 +1793,6 @@ alpha_builtin_saveregs (arglist)\n     }\n }\n \f\n-#if OPEN_VMS\n-#define REG_PV 27\n-#define REG_RA 26\n-#else\n-#define REG_RA 26\n-#endif\n-\n-/* Find the current function's return address.\n-\n-   ??? It would be better to arrange things such that if we would ordinarily\n-   have been a leaf function and we didn't spill the hard reg that we\n-   wouldn't have to save the register in the prolog.  But it's not clear\n-   how to get the right information at the right time.  */\n-\n-static rtx alpha_return_addr_rtx;\n-\n-rtx\n-alpha_return_addr ()\n-{\n-  rtx ret;\n-\n-  if ((ret = alpha_return_addr_rtx) == NULL)\n-    {\n-      alpha_return_addr_rtx = ret = gen_reg_rtx (Pmode);\n-\n-      emit_insn_after (gen_rtx (SET, VOIDmode, ret,\n-\t\t\t        gen_rtx (REG, Pmode, REG_RA)),\n-\t\t       get_insns ());\n-    }\n-\n-  return ret;\n-}\n-\n /* This page contains routines that are used to determine what the function\n    prologue and epilogue code will do and write them out.  */\n \n@@ -2725,8 +2704,6 @@ output_epilog (file, size)\n \n   /* Show that we know this function if it is called again.  */\n   SYMBOL_REF_FLAG (XEXP (DECL_RTL (current_function_decl), 0)) = 1;\n-\n-  alpha_return_addr_rtx = 0;\n }\n #endif /* !OPEN_VMS */\n \f"}, {"sha": "6e24c31bb0b024da26bfa80dfda9dc33993fd804", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26250081990e5467780156e74e205738acdbcd2a/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26250081990e5467780156e74e205738acdbcd2a/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=26250081990e5467780156e74e205738acdbcd2a", "patch": "@@ -24,7 +24,7 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in alpha.h.\n \n-(define_attr \"cpu\" \"ev4,ev5,ev6\"\n+(define_attr \"cpu\" \"ev4,ev5\"\n   (const (symbol_ref \"alpha_cpu\")))\n \n ;; Define an insn type attribute.  This is used in function unit delay\n@@ -33,7 +33,7 @@\n ;; separately.\n \n (define_attr \"type\"\n-  \"ld,st,ibr,fbr,jsr,iadd,ilog,shift,cmov,icmp,imull,imulq,imulh,fadd,fmul,fcpys,fdivs,fdivt,ldsym,misc\"\n+  \"ld,st,ibr,fbr,jsr,iadd,ilog,shift,cmov,icmp,imull,imulq,imulh,fadd,fmul,fcpys,fdivs,fdivt,ldsym,misc,mvi\"\n   (const_string \"iadd\"))\n \n ;; The TRAP_TYPE attribute marks instructions that may generate traps\n@@ -122,94 +122,100 @@\n ;; those as well.\n \n (define_function_unit \"ev5_ebox\" 2 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n-       (eq_attr \"type\" \"iadd,ilog,icmp,st,shift,imull,imulq,imulh\"))\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"iadd,ilog,icmp,st,shift,imull,imulq,imulh,mvi\"))\n   1 1)\n \n ;; Memory takes at least 2 clocks, and load cannot dual issue with stores.\n (define_function_unit \"ev5_ebox\" 2 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"ld,ldsym\"))\n   2 1)\n \n (define_function_unit \"ev5_e0\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"ld,ldsym\"))\n   0 1\n   [(eq_attr \"type\" \"st\")])\n \n ;; Conditional moves always take 2 ticks.\n (define_function_unit \"ev5_ebox\" 2 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"cmov\"))\n   2 1)\n \n-;; Stores, shifts, and multiplies can only issue to E0\n+;; Stores, shifts, multiplies can only issue to E0\n (define_function_unit \"ev5_e0\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"st\"))\n   1 1)\n \n+;; Motion video insns also issue only to E0, and take two ticks.\n+(define_function_unit \"ev5_e0\" 1 0\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"mvi\"))\n+  2 1)\n+\n ;; But shifts and multiplies don't conflict with loads.\n (define_function_unit \"ev5_e0\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n-       (eq_attr \"type\" \"shift,imull,imulq,imulh\"))\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"shift,imull,imulq,imulh,mvi\"))\n   1 1\n-  [(eq_attr \"type\" \"st,shift,imull,imulq,imulh\")])\n+  [(eq_attr \"type\" \"st,shift,imull,imulq,imulh,mvi\")])\n \n ;; Branches can only issue to E1\n (define_function_unit \"ev5_e1\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"ibr,jsr\"))\n   1 1)\n \n ;; Multiplies also use the integer multiplier.\n (define_function_unit \"ev5_imult\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"imull\"))\n   8 4)\n \n (define_function_unit \"ev5_imult\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"imulq\"))\n   12 8)\n \n (define_function_unit \"ev5_imult\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"imulh\"))\n   14 8)\n \n ;; Similarly for the FPU we have two asymetric units.  But fcpys can issue\n ;; on either so we have to play the game again.\n \n (define_function_unit \"ev5_fpu\" 2 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fadd,fmul,fcpys,fbr,fdivs,fdivt\"))\n   4 1)\n   \n ;; Multiplies (resp. adds) also use the fmul (resp. fadd) units.\n (define_function_unit \"ev5_fm\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fmul\"))\n   4 1)\n \n (define_function_unit \"ev5_fa\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fadd\"))\n   4 1)\n \n (define_function_unit \"ev5_fa\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fbr\"))\n   1 1)\n \n (define_function_unit \"ev5_fa\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fdivs\"))\n   15 1)\n \n (define_function_unit \"ev5_fa\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5,ev6\")\n+  (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fdivt\"))\n   22 1)\n \f\n@@ -2069,55 +2075,55 @@\n \t\t (match_operand:QI 2 \"reg_or_8bit_operand\" \"rI\")))]\n   \"TARGET_MAX\"\n   \"minsb8 %r1,%2,%0\"\n-  [(set_attr \"type\" \"shift\")])\n+  [(set_attr \"type\" \"mvi\")])\n \n (define_insn \"uminqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n \t(umin:SI (match_operand:QI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t (match_operand:QI 2 \"reg_or_8bit_operand\" \"rI\")))]\n   \"TARGET_MAX\"\n   \"minub8 %r1,%2,%0\"\n-  [(set_attr \"type\" \"shift\")])\n+  [(set_attr \"type\" \"mvi\")])\n \n (define_insn \"smaxqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n \t(smax:SI (match_operand:QI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t (match_operand:QI 2 \"reg_or_8bit_operand\" \"rI\")))]\n   \"TARGET_MAX\"\n   \"maxsb8 %r1,%2,%0\"\n-  [(set_attr \"type\" \"shift\")])\n+  [(set_attr \"type\" \"mvi\")])\n \n (define_insn \"umaxqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n \t(umax:SI (match_operand:QI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t (match_operand:QI 2 \"reg_or_8bit_operand\" \"rI\")))]\n   \"TARGET_MAX\"\n   \"maxub8 %r1,%2,%0\"\n-  [(set_attr \"type\" \"shift\")])\n+  [(set_attr \"type\" \"mvi\")])\n \n (define_insn \"sminhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(smin:SI (match_operand:HI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t (match_operand:HI 2 \"reg_or_8bit_operand\" \"rI\")))]\n   \"TARGET_MAX\"\n   \"minsw4 %r1,%2,%0\"\n-  [(set_attr \"type\" \"shift\")])\n+  [(set_attr \"type\" \"mvi\")])\n \n (define_insn \"uminhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(umin:SI (match_operand:HI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t (match_operand:HI 2 \"reg_or_8bit_operand\" \"rI\")))]\n   \"TARGET_MAX\"\n   \"minuw4 %r1,%2,%0\"\n-  [(set_attr \"type\" \"shift\")])\n+  [(set_attr \"type\" \"mvi\")])\n \n (define_insn \"smaxhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(smax:SI (match_operand:HI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t (match_operand:HI 2 \"reg_or_8bit_operand\" \"rI\")))]\n   \"TARGET_MAX\"\n   \"maxsw4 %r1,%2,%0\"\n-  [(set_attr \"type\" \"shift\")])\n+  [(set_attr \"type\" \"mvi\")])\n \n (define_insn \"umaxhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")"}]}