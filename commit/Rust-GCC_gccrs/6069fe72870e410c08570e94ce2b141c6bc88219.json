{"sha": "6069fe72870e410c08570e94ce2b141c6bc88219", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA2OWZlNzI4NzBlNDEwYzA4NTcwZTk0Y2UyYjE0MWM2YmM4ODIxOQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-10-04T13:41:01Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-10-04T13:41:01Z"}, "message": "jit: implement gcc_jit_context_new_rvalue_from_vector\n\nThis patch implements a new API entrypoint:\n\n/* Build a vector rvalue from an array of elements.\n\n   \"vec_type\" should be a vector type, created using gcc_jit_type_get_vector.\n\n   This API entrypoint was added in LIBGCCJIT_ABI_10; you can test for its\n   presence using\n     #ifdef LIBGCCJIT_HAVE_gcc_jit_context_new_rvalue_from_vector\n*/\nextern gcc_jit_rvalue *\ngcc_jit_context_new_rvalue_from_vector (gcc_jit_context *ctxt,\n                                        gcc_jit_location *loc,\n                                        gcc_jit_type *vec_type,\n                                        size_t num_elements,\n                                        gcc_jit_rvalue **elements);\n\n\ngcc/jit/ChangeLog:\n\t* docs/cp/topics/expressions.rst (Vector expressions): New\n\tsection.\n\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_10): New ABI tag.\n\t* docs/topics/expressions.rst (Vector expressions): New section.\n\t* docs/topics/types.rst (gcc_jit_type_get_vector): Add link to\n\tgcc_jit_context_new_rvalue_from_vector.\n\t* jit-common.h (gcc::jit:recording::vector_type): New forward\n\tdecl.\n\t* jit-playback.c\n\t(gcc::jit::playback::context::new_rvalue_from_vector): New method.\n\t* jit-playback.h\n\t(gcc::jit::playback::context::new_rvalue_from_vector): New method.\n\t* jit-recording.c: In namespace gcc::jit::\n\t(class comma_separated_string): New class.\n\t(comma_separated_string::comma_separated_string): New ctor,\n\tadapted from recording::call::make_debug_string.\n\t(comma_separated_string::~comma_separated_string): New dtor.\n\tIn namespace gcc::jit::recording::\n\t(context::new_rvalue_from_vector): New method.\n\t(type::get_vector): Update for renaming of memento_of_get_vector.\n\t(class memento_of_get_vector): Rename to...\n\t(class vector_type): ..this.\n\t(memento_of_new_rvalue_from_vector::memento_of_new_rvalue_from_vector):\n\tNew ctor.\n\t(memento_of_new_rvalue_from_vector::replay_into): New method.\n\t(memento_of_new_rvalue_from_vector::visit_children): New method.\n\t(memento_of_new_rvalue_from_vector::make_debug_string): New\n\tmethod.\n\t(memento_of_new_rvalue_from_vector::write_reproducer): New method.\n\t(call::make_debug_string): Split out arg-printing code into ctor\n\tfor comma_separated_string.\n\t* jit-recording.h: In namespace gcc::jit::recording::\n\t(context::new_rvalue_from_vector): New method.\n\t(type::dyn_cast_vector_type): New virtual function.\n\t(class memento_of_get_vector): Rename to...\n\t(class vector_type): ...this.\n\t(vector_type::unqualified): Remove this vfunc override in favor\n\tof...\n\t(vector_type::get_element_type): ...this new method.\n\t(vector_type::get_num_units): New method.\n\t(vector_type::dyn_cast_vector_type): New vfunc override.\n\t(class memento_of_new_rvalue_from_vector): New class.\n\t* libgccjit++.h (gccjit::context::new_rvalue): Add overload for\n\tvector of rvalue.\n\t* libgccjit.c (gcc_jit_context_new_binary_op): Strip off type\n\tqualifications when checking that both operands have same type.\n\t(gcc_jit_context_new_rvalue_from_vector): New API entrypoint.\n\t* libgccjit.h\n\t(LIBGCCJIT_HAVE_gcc_jit_context_new_rvalue_from_vector): New\n\tmacro.\n\t(gcc_jit_context_new_rvalue_from_vector): New API entrypoint.\n\t* libgccjit.map (LIBGCCJIT_ABI_10): New ABI tag.\n\ngcc/testsuite/ChangeLog:\n\t* jit.dg/test-expressions.c (make_test_of_vectors): New function.\n\t(create_code): Call it.\n\t* jit.dg/test-vector-rvalues.cc: New test case.\n\nFrom-SVN: r253409", "tree": {"sha": "5a934460e85fcef8a36ea6e8242e0d10b59be28e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a934460e85fcef8a36ea6e8242e0d10b59be28e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6069fe72870e410c08570e94ce2b141c6bc88219", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6069fe72870e410c08570e94ce2b141c6bc88219", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6069fe72870e410c08570e94ce2b141c6bc88219", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6069fe72870e410c08570e94ce2b141c6bc88219/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f15b6a282bc4c11ee8b32dac4f05aab10ce3e10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f15b6a282bc4c11ee8b32dac4f05aab10ce3e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f15b6a282bc4c11ee8b32dac4f05aab10ce3e10"}], "stats": {"total": 1752, "additions": 1231, "deletions": 521}, "files": [{"sha": "24df99057a0a62fe3ed806f254b09e51d09665f9", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -1,3 +1,59 @@\n+2017-10-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* docs/cp/topics/expressions.rst (Vector expressions): New\n+\tsection.\n+\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_10): New ABI tag.\n+\t* docs/topics/expressions.rst (Vector expressions): New section.\n+\t* docs/topics/types.rst (gcc_jit_type_get_vector): Add link to\n+\tgcc_jit_context_new_rvalue_from_vector.\n+\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n+\t* jit-common.h (gcc::jit:recording::vector_type): New forward\n+\tdecl.\n+\t* jit-playback.c\n+\t(gcc::jit::playback::context::new_rvalue_from_vector): New method.\n+\t* jit-playback.h\n+\t(gcc::jit::playback::context::new_rvalue_from_vector): New method.\n+\t* jit-recording.c: In namespace gcc::jit::\n+\t(class comma_separated_string): New class.\n+\t(comma_separated_string::comma_separated_string): New ctor,\n+\tadapted from recording::call::make_debug_string.\n+\t(comma_separated_string::~comma_separated_string): New dtor.\n+\tIn namespace gcc::jit::recording::\n+\t(context::new_rvalue_from_vector): New method.\n+\t(type::get_vector): Update for renaming of memento_of_get_vector.\n+\t(class memento_of_get_vector): Rename to...\n+\t(class vector_type): ..this.\n+\t(memento_of_new_rvalue_from_vector::memento_of_new_rvalue_from_vector):\n+\tNew ctor.\n+\t(memento_of_new_rvalue_from_vector::replay_into): New method.\n+\t(memento_of_new_rvalue_from_vector::visit_children): New method.\n+\t(memento_of_new_rvalue_from_vector::make_debug_string): New\n+\tmethod.\n+\t(memento_of_new_rvalue_from_vector::write_reproducer): New method.\n+\t(call::make_debug_string): Split out arg-printing code into ctor\n+\tfor comma_separated_string.\n+\t* jit-recording.h: In namespace gcc::jit::recording::\n+\t(context::new_rvalue_from_vector): New method.\n+\t(type::dyn_cast_vector_type): New virtual function.\n+\t(class memento_of_get_vector): Rename to...\n+\t(class vector_type): ...this.\n+\t(vector_type::unqualified): Remove this vfunc override in favor\n+\tof...\n+\t(vector_type::get_element_type): ...this new method.\n+\t(vector_type::get_num_units): New method.\n+\t(vector_type::dyn_cast_vector_type): New vfunc override.\n+\t(class memento_of_new_rvalue_from_vector): New class.\n+\t* libgccjit++.h (gccjit::context::new_rvalue): Add overload for\n+\tvector of rvalue.\n+\t* libgccjit.c (gcc_jit_context_new_binary_op): Strip off type\n+\tqualifications when checking that both operands have same type.\n+\t(gcc_jit_context_new_rvalue_from_vector): New API entrypoint.\n+\t* libgccjit.h\n+\t(LIBGCCJIT_HAVE_gcc_jit_context_new_rvalue_from_vector): New\n+\tmacro.\n+\t(gcc_jit_context_new_rvalue_from_vector): New API entrypoint.\n+\t* libgccjit.map (LIBGCCJIT_ABI_10): New ABI tag.\n+\n 2017-09-28  David Malcolm  <dmalcolm@redhat.com>\n \n \t* docs/topics/expressions.rst (Function calls): Add link to"}, {"sha": "344c93e4ccf7404a80b5100f1ea4648f7272c514", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 547, "deletions": 481, "changes": 1028, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=6069fe72870e410c08570e94ce2b141c6bc88219"}, {"sha": "b0081f68fc176e7b1f952b4cfecadebb0358252d", "filename": "gcc/jit/docs/cp/topics/expressions.rst", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fexpressions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fexpressions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fexpressions.rst?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -105,6 +105,17 @@ Simple expressions\n    Generate an rvalue of type :c:data:`GCC_JIT_TYPE_CONST_CHAR_PTR` for\n    the given string.  This is akin to a string literal.\n \n+Vector expressions\n+******************\n+\n+.. function:: gccjit::rvalue \\\n+\t      gccjit::context::new_rvalue (gccjit::type vector_type, \\\n+\t                                   std::vector<gccjit::rvalue> elements) const\n+\n+   Given a vector type, and a vector of scalar rvalue elements, generate a\n+   vector rvalue.\n+\n+   The number of elements needs to match that of the vector type.\n \n Unary Operations\n ****************"}, {"sha": "84d342b13e3d4339471ef5ef7799c9544d7947e8", "filename": "gcc/jit/docs/topics/compatibility.rst", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -163,3 +163,11 @@ entrypoints:\n -------------------\n ``LIBGCCJIT_ABI_9`` covers the addition of\n :func:`gcc_jit_function_get_address`\n+\n+.. _LIBGCCJIT_ABI_10:\n+\n+``LIBGCCJIT_ABI_10``\n+--------------------\n+\n+``LIBGCCJIT_ABI_10`` covers the addition of\n+:func:`gcc_jit_context_new_rvalue_from_vector`"}, {"sha": "e6e09dd4eb2dc6a3f54b79a72b4f51a81fd5a1ec", "filename": "gcc/jit/docs/topics/expressions.rst", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -126,6 +126,30 @@ Simple expressions\n    underlying string, so it is valid to pass in a pointer to an on-stack\n    buffer.\n \n+Vector expressions\n+******************\n+\n+.. function:: gcc_jit_rvalue * \\\n+              gcc_jit_context_new_rvalue_from_vector (gcc_jit_context *ctxt, \\\n+                                                      gcc_jit_location *loc, \\\n+                                                      gcc_jit_type *vec_type, \\\n+                                                      size_t num_elements, \\\n+                                                      gcc_jit_rvalue **elements)\n+\n+   Build a vector rvalue from an array of elements.\n+\n+   \"vec_type\" should be a vector type, created using\n+   :func:`gcc_jit_type_get_vector`.\n+\n+   \"num_elements\" should match that of the vector type.\n+\n+   This entrypoint was added in :ref:`LIBGCCJIT_ABI_10`; you can test for\n+   its presence using\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_gcc_jit_context_new_rvalue_from_vector\n+\n Unary Operations\n ****************\n "}, {"sha": "a9ab9b3f291c04882eb82f894a9983e30480cd18", "filename": "gcc/jit/docs/topics/types.rst", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -177,6 +177,9 @@ Vector types\n \n       #ifdef LIBGCCJIT_HAVE_gcc_jit_type_get_vector\n \n+   Vector rvalues can be generated using\n+   :func:`gcc_jit_context_new_rvalue_from_vector`.\n+\n \n Structures and unions\n ---------------------"}, {"sha": "daf94a03cd805e31838f0ea88337c786ae931988", "filename": "gcc/jit/jit-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fjit-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fjit-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-common.h?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -117,6 +117,7 @@ namespace recording {\n       class compound_type;\n         class struct_;\n \tclass union_;\n+      class vector_type;\n     class field;\n     class fields;\n     class function;"}, {"sha": "95126c94393c0896234b3187e089cf118fa7660b", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -629,6 +629,22 @@ new_string_literal (const char *value)\n   return new rvalue (this, t_addr);\n }\n \n+/* Construct a playback::rvalue instance (wrapping a tree) for a\n+   vector.  */\n+\n+playback::rvalue *\n+playback::context::new_rvalue_from_vector (location *,\n+\t\t\t\t\t   type *type,\n+\t\t\t\t\t   const auto_vec<rvalue *> &elements)\n+{\n+  vec<constructor_elt, va_gc> *v;\n+  vec_alloc (v, elements.length ());\n+  for (unsigned i = 0; i < elements.length (); ++i)\n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elements[i]->as_tree ());\n+  tree t_ctor = build_constructor (type->as_tree (), v);\n+  return new rvalue (this, t_ctor);\n+}\n+\n /* Coerce a tree expression into a boolean tree expression.  */\n \n tree"}, {"sha": "b45f6d51536be163db03ddd4943d2ef8b977c033", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -113,6 +113,11 @@ class context : public log_user\n   rvalue *\n   new_string_literal (const char *value);\n \n+  rvalue *\n+  new_rvalue_from_vector (location *loc,\n+\t\t\t  type *type,\n+\t\t\t  const auto_vec<rvalue *> &elements);\n+\n   rvalue *\n   new_unary_op (location *loc,\n \t\tenum gcc_jit_unary_op op,"}, {"sha": "bd8f11658b11b44af30bcbc996f18494b0c302b8", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 172, "deletions": 35, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -447,6 +447,62 @@ reproducer::xstrdup_printf (const char *fmt, ...)\n   return result;\n }\n \n+/* A helper class for implementing make_debug_string, for building\n+   a temporary string from a vec of rvalues.  */\n+\n+class comma_separated_string\n+{\n+ public:\n+  comma_separated_string (const auto_vec<recording::rvalue *> &rvalues,\n+\t\t\t  enum recording::precedence prec);\n+  ~comma_separated_string ();\n+\n+  const char *as_char_ptr () const { return m_buf; }\n+\n+ private:\n+  char *m_buf;\n+};\n+\n+/* comma_separated_string's ctor\n+   Build m_buf.  */\n+\n+comma_separated_string::comma_separated_string\n+  (const auto_vec<recording::rvalue *> &rvalues,\n+   enum recording::precedence prec)\n+: m_buf (NULL)\n+{\n+  /* Calculate length of said buffer.  */\n+  size_t sz = 1; /* nil terminator */\n+  for (unsigned i = 0; i< rvalues.length (); i++)\n+    {\n+      sz += strlen (rvalues[i]->get_debug_string_parens (prec));\n+      sz += 2; /* \", \" separator */\n+    }\n+\n+  /* Now allocate and populate the buffer.  */\n+  m_buf = new char[sz];\n+  size_t len = 0;\n+\n+  for (unsigned i = 0; i< rvalues.length (); i++)\n+    {\n+      strcpy (m_buf + len, rvalues[i]->get_debug_string_parens (prec));\n+      len += strlen (rvalues[i]->get_debug_string_parens (prec));\n+      if (i + 1 < rvalues.length ())\n+\t{\n+\t  strcpy (m_buf + len, \", \");\n+\t  len += 2;\n+\t}\n+    }\n+  m_buf[len] = '\\0';\n+}\n+\n+/* comma_separated_string's dtor.  */\n+\n+comma_separated_string::~comma_separated_string ()\n+{\n+  delete[] m_buf;\n+}\n+\n /**********************************************************************\n  Recording.\n  **********************************************************************/\n@@ -1001,6 +1057,23 @@ recording::context::new_string_literal (const char *value)\n   return result;\n }\n \n+/* Create a recording::memento_of_new_rvalue_from_vector instance and add it\n+   to this context's list of mementos.\n+\n+   Implements the post-error-checking part of\n+   gcc_jit_context_new_rvalue_from_vector.  */\n+\n+recording::rvalue *\n+recording::context::new_rvalue_from_vector (location *loc,\n+\t\t\t\t\t    vector_type *type,\n+\t\t\t\t\t    rvalue **elements)\n+{\n+  recording::rvalue *result\n+    = new memento_of_new_rvalue_from_vector (this, loc, type, elements);\n+  record (result);\n+  return result;\n+}\n+\n /* Create a recording::unary_op instance and add it to this context's\n    list of mementos.\n \n@@ -2035,7 +2108,7 @@ recording::type *\n recording::type::get_vector (size_t num_units)\n {\n   recording::type *result\n-    = new memento_of_get_vector (this, num_units);\n+    = new vector_type (this, num_units);\n   m_ctxt->record (result);\n   return result;\n }\n@@ -2523,13 +2596,13 @@ recording::memento_of_get_aligned::write_reproducer (reproducer &r)\n \t   m_alignment_in_bytes);\n }\n \n-/* The implementation of class gcc::jit::recording::memento_of_get_vector.  */\n+/* The implementation of class gcc::jit::recording::vector_type.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n-   for recording::memento_of_get_vector.  */\n+   for recording::vector_type.  */\n \n void\n-recording::memento_of_get_vector::replay_into (replayer *)\n+recording::vector_type::replay_into (replayer *)\n {\n   set_playback_obj\n     (m_other_type->playback_type ()->get_vector (m_num_units));\n@@ -2539,7 +2612,7 @@ recording::memento_of_get_vector::replay_into (replayer *)\n    results of get_vector.  */\n \n recording::string *\n-recording::memento_of_get_vector::make_debug_string ()\n+recording::vector_type::make_debug_string ()\n {\n   return string::from_printf\n     (m_ctxt,\n@@ -2549,11 +2622,10 @@ recording::memento_of_get_vector::make_debug_string ()\n      m_num_units);\n }\n \n-/* Implementation of recording::memento::write_reproducer for volatile\n-   types. */\n+/* Implementation of recording::memento::write_reproducer for vector types. */\n \n void\n-recording::memento_of_get_vector::write_reproducer (reproducer &r)\n+recording::vector_type::write_reproducer (reproducer &r)\n {\n   const char *id = r.make_identifier (this, \"type\");\n   r.write (\"  gcc_jit_type *%s =\\n\"\n@@ -4569,6 +4641,96 @@ recording::memento_of_new_string_literal::write_reproducer (reproducer &r)\n     m_value->get_debug_string ());\n }\n \n+/* The implementation of class\n+   gcc::jit::recording::memento_of_new_rvalue_from_vector.  */\n+\n+/* The constructor for\n+   gcc::jit::recording::memento_of_new_rvalue_from_vector.  */\n+\n+recording::memento_of_new_rvalue_from_vector::\n+memento_of_new_rvalue_from_vector (context *ctxt,\n+\t\t\t\t   location *loc,\n+\t\t\t\t   vector_type *type,\n+\t\t\t\t   rvalue **elements)\n+: rvalue (ctxt, loc, type),\n+  m_vector_type (type),\n+  m_elements ()\n+{\n+  for (unsigned i = 0; i < type->get_num_units (); i++)\n+    m_elements.safe_push (elements[i]);\n+}\n+\n+/* Implementation of pure virtual hook recording::memento::replay_into\n+   for recording::memento_of_new_rvalue_from_vector.  */\n+\n+void\n+recording::memento_of_new_rvalue_from_vector::replay_into (replayer *r)\n+{\n+  auto_vec<playback::rvalue *> playback_elements;\n+  playback_elements.create (m_elements.length ());\n+  for (unsigned i = 0; i< m_elements.length (); i++)\n+    playback_elements.safe_push (m_elements[i]->playback_rvalue ());\n+\n+  set_playback_obj (r->new_rvalue_from_vector (playback_location (r, m_loc),\n+\t\t\t\t\t       m_type->playback_type (),\n+\t\t\t\t\t       playback_elements));\n+}\n+\n+/* Implementation of pure virtual hook recording::rvalue::visit_children\n+   for recording::memento_of_new_rvalue_from_vector.  */\n+\n+void\n+recording::memento_of_new_rvalue_from_vector::visit_children (rvalue_visitor *v)\n+{\n+  for (unsigned i = 0; i< m_elements.length (); i++)\n+    v->visit (m_elements[i]);\n+}\n+\n+/* Implementation of recording::memento::make_debug_string for\n+   vectors.  */\n+\n+recording::string *\n+recording::memento_of_new_rvalue_from_vector::make_debug_string ()\n+{\n+  comma_separated_string elements (m_elements, get_precedence ());\n+\n+  /* Now build a string.  */\n+  string *result = string::from_printf (m_ctxt,\n+\t\t\t\t\t\"{%s}\",\n+\t\t\t\t\telements.as_char_ptr ());\n+\n+ return result;\n+\n+}\n+\n+/* Implementation of recording::memento::write_reproducer for\n+   vectors.  */\n+\n+void\n+recording::memento_of_new_rvalue_from_vector::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"vector\");\n+  const char *elements_id = r.make_tmp_identifier (\"elements_for_\", this);\n+  r.write (\"  gcc_jit_rvalue *%s[%i] = {\\n\",\n+\t   elements_id,\n+\t   m_elements.length ());\n+  for (unsigned i = 0; i< m_elements.length (); i++)\n+    r.write (\"    %s,\\n\", r.get_identifier_as_rvalue (m_elements[i]));\n+  r.write (\"  };\\n\");\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t   \"    gcc_jit_context_new_rvalue_from_vector (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t   \"                                            %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                            %s, /* gcc_jit_type *vec_type */\\n\"\n+\t   \"                                            %i, /* size_t num_elements  */ \\n\"\n+\t   \"                                            %s); /* gcc_jit_rvalue **elements*/\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier (m_vector_type),\n+\t   m_elements.length (),\n+\t   elements_id);\n+}\n+\n /* The implementation of class gcc::jit::recording::unary_op.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -4982,39 +5144,14 @@ recording::call::visit_children (rvalue_visitor *v)\n recording::string *\n recording::call::make_debug_string ()\n {\n-  enum precedence prec = get_precedence ();\n   /* First, build a buffer for the arguments.  */\n-  /* Calculate length of said buffer.  */\n-  size_t sz = 1; /* nil terminator */\n-  for (unsigned i = 0; i< m_args.length (); i++)\n-    {\n-      sz += strlen (m_args[i]->get_debug_string_parens (prec));\n-      sz += 2; /* \", \" separator */\n-    }\n-\n-  /* Now allocate and populate the buffer.  */\n-  char *argbuf = new char[sz];\n-  size_t len = 0;\n-\n-  for (unsigned i = 0; i< m_args.length (); i++)\n-    {\n-      strcpy (argbuf + len, m_args[i]->get_debug_string_parens (prec));\n-      len += strlen (m_args[i]->get_debug_string_parens (prec));\n-      if (i + 1 < m_args.length ())\n-\t{\n-\t  strcpy (argbuf + len, \", \");\n-\t  len += 2;\n-\t}\n-    }\n-  argbuf[len] = '\\0';\n+  comma_separated_string args (m_args, get_precedence ());\n \n   /* ...and use it to get the string for the call as a whole.  */\n   string *result = string::from_printf (m_ctxt,\n \t\t\t\t\t\"%s (%s)\",\n \t\t\t\t\tm_func->get_debug_string (),\n-\t\t\t\t\targbuf);\n-\n-  delete[] argbuf;\n+\t\t\t\t\targs.as_char_ptr ());\n \n   return result;\n }"}, {"sha": "6a3fd5d03840fa3d0dfc6f18eb8cbbc3ad34ba03", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -148,6 +148,11 @@ class context : public log_user\n   rvalue *\n   new_string_literal (const char *value);\n \n+  rvalue *\n+  new_rvalue_from_vector (location *loc,\n+\t\t\t  vector_type *type,\n+\t\t\t  rvalue **elements);\n+\n   rvalue *\n   new_unary_op (location *loc,\n \t\tenum gcc_jit_unary_op op,\n@@ -486,6 +491,7 @@ class type : public memento\n   virtual function_type *dyn_cast_function_type () { return NULL; }\n   virtual function_type *as_a_function_type() { gcc_unreachable (); return NULL; }\n   virtual struct_ *dyn_cast_struct () { return NULL; }\n+  virtual vector_type *dyn_cast_vector_type () { return NULL; }\n \n   /* Is it typesafe to copy to this type from rtype?  */\n   virtual bool accepts_writes_from (type *rtype)\n@@ -690,15 +696,18 @@ class memento_of_get_aligned : public decorated_type\n };\n \n /* Result of \"gcc_jit_type_get_vector\".  */\n-class memento_of_get_vector : public decorated_type\n+class vector_type : public decorated_type\n {\n public:\n-  memento_of_get_vector (type *other_type, size_t num_units)\n+  vector_type (type *other_type, size_t num_units)\n   : decorated_type (other_type),\n     m_num_units (num_units) {}\n \n-  /* Strip off the alignment, giving the underlying type.  */\n-  type *unqualified () FINAL OVERRIDE { return m_other_type; }\n+  size_t get_num_units () const { return m_num_units; }\n+\n+  vector_type *dyn_cast_vector_type () FINAL OVERRIDE { return this; }\n+\n+  type *get_element_type () { return m_other_type; }\n \n   void replay_into (replayer *) FINAL OVERRIDE;\n \n@@ -1358,6 +1367,31 @@ class memento_of_new_string_literal : public rvalue\n   string *m_value;\n };\n \n+class memento_of_new_rvalue_from_vector : public rvalue\n+{\n+public:\n+  memento_of_new_rvalue_from_vector (context *ctxt,\n+\t\t\t\t     location *loc,\n+\t\t\t\t     vector_type *type,\n+\t\t\t\t     rvalue **elements);\n+\n+  void replay_into (replayer *r) FINAL OVERRIDE;\n+\n+  void visit_children (rvalue_visitor *) FINAL OVERRIDE;\n+\n+private:\n+  string * make_debug_string () FINAL OVERRIDE;\n+  void write_reproducer (reproducer &r) FINAL OVERRIDE;\n+  enum precedence get_precedence () const FINAL OVERRIDE\n+  {\n+    return PRECEDENCE_PRIMARY;\n+  }\n+\n+private:\n+  vector_type *m_vector_type;\n+  auto_vec<rvalue *> m_elements;\n+};\n+\n class unary_op : public rvalue\n {\n public:"}, {"sha": "9e3c1792b5da6c097b474976bfafc21b304a3667", "filename": "gcc/jit/libgccjit++.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -187,6 +187,8 @@ namespace gccjit\n     rvalue new_rvalue (type pointer_type,\n \t\t       void *value) const;\n     rvalue new_rvalue (const std::string &value) const;\n+    rvalue new_rvalue (type vector_type,\n+\t\t       std::vector<rvalue> elements) const;\n \n     /* Generic unary operations...  */\n     rvalue new_unary_op (enum gcc_jit_unary_op op,\n@@ -896,6 +898,26 @@ context::new_rvalue (const std::string &value) const\n     gcc_jit_context_new_string_literal (m_inner_ctxt, value.c_str ()));\n }\n \n+inline rvalue\n+context::new_rvalue (type vector_type,\n+\t\t     std::vector<rvalue> elements) const\n+{\n+  /* Treat std::vector as an array, relying on it not being resized: */\n+  rvalue *as_array_of_wrappers = &elements[0];\n+\n+  /* Treat the array as being of the underlying pointers, relying on\n+     the wrapper type being such a pointer internally.\t*/\n+  gcc_jit_rvalue **as_array_of_ptrs =\n+    reinterpret_cast<gcc_jit_rvalue **> (as_array_of_wrappers);\n+\n+  return rvalue (\n+    gcc_jit_context_new_rvalue_from_vector (m_inner_ctxt,\n+\t\t\t\t\t    NULL,\n+\t\t\t\t\t    vector_type.get_inner_type (),\n+\t\t\t\t\t    elements.size (),\n+\t\t\t\t\t    as_array_of_ptrs));\n+}\n+\n inline rvalue\n context::new_unary_op (enum gcc_jit_unary_op op,\n \t\t       type result_type,"}, {"sha": "c00acbfd81439409303e93212c21f2de01fe4e0d", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -1335,7 +1335,7 @@ gcc_jit_context_new_binary_op (gcc_jit_context *ctxt,\n   RETURN_NULL_IF_FAIL (a, ctxt, loc, \"NULL a\");\n   RETURN_NULL_IF_FAIL (b, ctxt, loc, \"NULL b\");\n   RETURN_NULL_IF_FAIL_PRINTF4 (\n-    a->get_type () == b->get_type (),\n+    a->get_type ()->unqualified () == b->get_type ()->unqualified (),\n     ctxt, loc,\n     \"mismatching types for binary op:\"\n     \" a: %s (type: %s) b: %s (type: %s)\",\n@@ -3042,3 +3042,61 @@ gcc_jit_function_get_address (gcc_jit_function *fn,\n \n   return (gcc_jit_rvalue *)fn->get_address (loc);\n }\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_rvalue_from_vector method, in\n+   jit-recording.c.  */\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_rvalue_from_vector (gcc_jit_context *ctxt,\n+\t\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\t\tgcc_jit_type *vec_type,\n+\t\t\t\t\tsize_t num_elements,\n+\t\t\t\t\tgcc_jit_rvalue **elements)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL ctxt\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (vec_type, ctxt, loc, \"NULL vec_type\");\n+\n+  /* \"vec_type\" must be a vector type.  */\n+  gcc::jit::recording::vector_type *as_vec_type\n+    = vec_type->dyn_cast_vector_type ();\n+  RETURN_NULL_IF_FAIL_PRINTF1 (as_vec_type, ctxt, loc,\n+\t\t\t       \"%s is not a vector type\",\n+\t\t\t       vec_type->get_debug_string ());\n+\n+  /* \"num_elements\" must match.  */\n+  RETURN_NULL_IF_FAIL_PRINTF1 (\n+    num_elements == as_vec_type->get_num_units (), ctxt, loc,\n+    \"num_elements != %zi\", as_vec_type->get_num_units ());\n+\n+  /* \"elements must be non-NULL.  */\n+  RETURN_NULL_IF_FAIL (elements, ctxt, loc, \"NULL elements\");\n+\n+  /* Each of \"elements\" must be non-NULL and of the correct type.  */\n+  gcc::jit::recording::type *element_type\n+    = as_vec_type->get_element_type ();\n+  for (size_t i = 0; i < num_elements; i++)\n+    {\n+      RETURN_NULL_IF_FAIL_PRINTF1 (\n+\telements[i], ctxt, loc, \"NULL elements[%zi]\", i);\n+      RETURN_NULL_IF_FAIL_PRINTF4 (\n+\tcompatible_types (element_type,\n+\t\t\t  elements[i]->get_type ()),\n+\tctxt, loc,\n+\t\"mismatching type for element[%zi] (expected type: %s): %s (type: %s)\",\n+\ti,\n+\telement_type->get_debug_string (),\n+\telements[i]->get_debug_string (),\n+\telements[i]->get_type ()->get_debug_string ());\n+    }\n+\n+  return (gcc_jit_rvalue *)ctxt->new_rvalue_from_vector\n+    (loc,\n+     as_vec_type,\n+     (gcc::jit::recording::rvalue **)elements);\n+}"}, {"sha": "f955eb2aff6122ee9840fee33e8d61f158ff5d7a", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -1433,6 +1433,23 @@ gcc_jit_function_get_address (gcc_jit_function *fn,\n \t\t\t      gcc_jit_location *loc);\n \n \n+#define LIBGCCJIT_HAVE_gcc_jit_context_new_rvalue_from_vector\n+\n+/* Build a vector rvalue from an array of elements.\n+\n+   \"vec_type\" should be a vector type, created using gcc_jit_type_get_vector.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_10; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_gcc_jit_context_new_rvalue_from_vector\n+*/\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_rvalue_from_vector (gcc_jit_context *ctxt,\n+\t\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\t\tgcc_jit_type *vec_type,\n+\t\t\t\t\tsize_t num_elements,\n+\t\t\t\t\tgcc_jit_rvalue **elements);\n+\n #ifdef __cplusplus\n }\n #endif /* __cplusplus */"}, {"sha": "03f65fd834ee19af53006d2a8bb4e008a9f50a69", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -165,3 +165,8 @@ LIBGCCJIT_ABI_9 {\n   global:\n     gcc_jit_function_get_address;\n } LIBGCCJIT_ABI_8;\n+\n+LIBGCCJIT_ABI_10 {\n+  global:\n+    gcc_jit_context_new_rvalue_from_vector;\n+} LIBGCCJIT_ABI_9;"}, {"sha": "61357e87f20316b4dce799e1f13717511355c9d5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -1,3 +1,9 @@\n+2017-10-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-expressions.c (make_test_of_vectors): New function.\n+\t(create_code): Call it.\n+\t* jit.dg/test-vector-rvalues.cc: New test case.\n+\n 2017-10-04  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* g++.dg/vect/slp-pr56812.cc: xfail for targets which don't want"}, {"sha": "f9cc64fd4db3a69d0ca5cb1db1bfb638456f76ab", "filename": "gcc/testsuite/jit.dg/test-expressions.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Ftestsuite%2Fjit.dg%2Ftest-expressions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Ftestsuite%2Fjit.dg%2Ftest-expressions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-expressions.c?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -919,6 +919,35 @@ verify_get_address (gcc_jit_result *result)\n   CHECK_VALUE (test_get_address (), &test_global);\n }\n \n+/**********************************************************************\n+ Vector values\n+ **********************************************************************/\n+\n+static void\n+make_test_of_vectors (gcc_jit_context *ctxt)\n+{\n+  gcc_jit_type *scalar_type;\n+  gcc_jit_type *vec_type;\n+  gcc_jit_rvalue *elements[4];\n+\n+  scalar_type = gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  vec_type = gcc_jit_type_get_vector (scalar_type, 4);\n+\n+  elements[0] = gcc_jit_context_new_rvalue_from_int (ctxt, scalar_type, 1);\n+  elements[1] = gcc_jit_context_new_rvalue_from_int (ctxt, scalar_type, -2);\n+  elements[2] = gcc_jit_context_new_rvalue_from_int (ctxt, scalar_type, 3);\n+  elements[3] = gcc_jit_context_new_rvalue_from_int (ctxt, scalar_type, -4);\n+\n+  gcc_jit_rvalue *vec_rvalue\n+    = gcc_jit_context_new_rvalue_from_vector (ctxt, NULL, vec_type,\n+\t\t\t\t\t      4, elements);\n+  CHECK_STRING_VALUE (\n+    gcc_jit_object_get_debug_string (\n+      gcc_jit_rvalue_as_object (vec_rvalue)),\n+    \"{(int)1, (int)-2, (int)3, (int)-4}\");\n+}\n+\n /**********************************************************************\n  Code for harness\n  **********************************************************************/\n@@ -932,6 +961,7 @@ create_code (gcc_jit_context *ctxt, void *user_data)\n   make_tests_of_casts (ctxt);\n   make_tests_of_dereferences (ctxt);\n   make_test_of_get_address (ctxt);\n+  make_test_of_vectors (ctxt);\n }\n \n void"}, {"sha": "ac230bf774c3c9055ba334b2f40e202cd7e63a6d", "filename": "gcc/testsuite/jit.dg/test-vector-rvalues.cc", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Ftestsuite%2Fjit.dg%2Ftest-vector-rvalues.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6069fe72870e410c08570e94ce2b141c6bc88219/gcc%2Ftestsuite%2Fjit.dg%2Ftest-vector-rvalues.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-vector-rvalues.cc?ref=6069fe72870e410c08570e94ce2b141c6bc88219", "patch": "@@ -0,0 +1,211 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+typedef int v4si __attribute__ ((vector_size (16)));\n+typedef unsigned int v4ui __attribute__ ((vector_size (16)));\n+typedef float v4f __attribute__ ((vector_size (16)));\n+\n+static void\n+create_vec_fn (gcc_jit_context *ctxt, const char *fnname,\n+\t       gcc_jit_type *vec_type,\n+\t       gcc_jit_type *elem_type,\n+\t       enum gcc_jit_binary_op op)\n+{\n+  /* Create equivalent to:\n+\n+       static void\n+       FNNAME (V *dst, const V *lhs, E p, E q, E r, E s)\n+       {\n+\t V pqrs;\n+\t pqrs = {p, q, r, s};\n+\t *dst = *lhs OP pqrs;\n+       }\n+\n+     where V is \"vec_type\" (e.g. v4si)\n+     and   E is \"elem_type\" (e.g. int).  */\n+\n+  gcc_jit_type *ptr_type = gcc_jit_type_get_pointer (vec_type);\n+\n+  gcc_jit_type *const_type = gcc_jit_type_get_const (vec_type);\n+  gcc_jit_type *ptr_to_const_type = gcc_jit_type_get_pointer (const_type);\n+\n+  gcc_jit_param *dst =\n+    gcc_jit_context_new_param (ctxt, NULL, ptr_type, \"dst\");\n+  gcc_jit_param *lhs =\n+    gcc_jit_context_new_param (ctxt, NULL, ptr_to_const_type, \"lhs\");\n+  gcc_jit_param *p =\n+    gcc_jit_context_new_param (ctxt, NULL, elem_type, \"p\");\n+  gcc_jit_param *q =\n+    gcc_jit_context_new_param (ctxt, NULL, elem_type, \"q\");\n+  gcc_jit_param *r =\n+    gcc_jit_context_new_param (ctxt, NULL, elem_type, \"r\");\n+  gcc_jit_param *s =\n+    gcc_jit_context_new_param (ctxt, NULL, elem_type, \"s\");\n+\n+  gcc_jit_type *return_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+\n+  gcc_jit_param *params[6] = {dst, lhs, p, q, r, s};\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  return_type,\n+\t\t\t\t  fnname,\n+\t\t\t\t  6, params, 0);\n+  gcc_jit_block *initial =\n+    gcc_jit_function_new_block (func, \"initial\");\n+\n+  /* V pqrs; */\n+  gcc_jit_lvalue *pqrs\n+    = gcc_jit_function_new_local (func, NULL,\n+\t\t\t\t  vec_type, \"pqrs\");\n+\n+  /* pqrs = {p, q, r, s}; */\n+  gcc_jit_rvalue *elems[4];\n+  elems[0] = gcc_jit_param_as_rvalue (p);\n+  elems[1] = gcc_jit_param_as_rvalue (q);\n+  elems[2] = gcc_jit_param_as_rvalue (r);\n+  elems[3] = gcc_jit_param_as_rvalue (s);\n+  gcc_jit_block_add_assignment (\n+    initial, NULL,\n+    pqrs,\n+    gcc_jit_context_new_rvalue_from_vector (ctxt, NULL, vec_type, 4, elems));\n+\n+  /* (*lhs OP pqrs) */\n+  gcc_jit_rvalue *op_result =\n+    gcc_jit_context_new_binary_op (\n+      ctxt, NULL,\n+      op,\n+      vec_type,\n+      gcc_jit_lvalue_as_rvalue (gcc_jit_rvalue_dereference (gcc_jit_param_as_rvalue (lhs),\n+\t\t\t\t\t\t\t    NULL)),\n+      gcc_jit_lvalue_as_rvalue (pqrs));\n+  /* *dst = *lhs OP pqrs; */\n+  gcc_jit_block_add_assignment (\n+    initial, NULL,\n+    gcc_jit_rvalue_dereference (gcc_jit_param_as_rvalue (dst), NULL),\n+    op_result);\n+  gcc_jit_block_end_with_void_return (initial, NULL);\n+}\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *unsigned_type\n+    = gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_UNSIGNED_INT);\n+  gcc_jit_type *float_type = gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_FLOAT);\n+\n+  gcc_jit_type *v4si_type = gcc_jit_type_get_vector (int_type, 4);\n+  gcc_jit_type *v4ui_type = gcc_jit_type_get_vector (unsigned_type, 4);\n+  gcc_jit_type *v4f_type = gcc_jit_type_get_vector (float_type, 4);\n+\n+  create_vec_fn (ctxt, \"jit_v4si_add\",\n+\t\t v4si_type, int_type, GCC_JIT_BINARY_OP_PLUS);\n+  create_vec_fn (ctxt, \"jit_v4si_sub\",\n+\t\t v4si_type, int_type, GCC_JIT_BINARY_OP_MINUS);\n+  create_vec_fn (ctxt, \"jit_v4si_mult\",\n+\t\t v4si_type, int_type, GCC_JIT_BINARY_OP_MULT);\n+  create_vec_fn (ctxt, \"jit_v4si_div\",\n+\t\t v4si_type, int_type, GCC_JIT_BINARY_OP_DIVIDE);\n+\n+  create_vec_fn (ctxt, \"jit_v4ui_add\",\n+\t\t v4ui_type, unsigned_type, GCC_JIT_BINARY_OP_PLUS);\n+  create_vec_fn (ctxt, \"jit_v4ui_sub\",\n+\t\t v4ui_type, unsigned_type, GCC_JIT_BINARY_OP_MINUS);\n+  create_vec_fn (ctxt, \"jit_v4ui_mult\",\n+\t\t v4ui_type, unsigned_type, GCC_JIT_BINARY_OP_MULT);\n+  create_vec_fn (ctxt, \"jit_v4ui_div\",\n+\t\t v4ui_type, unsigned_type, GCC_JIT_BINARY_OP_DIVIDE);\n+\n+  create_vec_fn (ctxt, \"jit_v4f_add\",\n+\t\t v4f_type, float_type, GCC_JIT_BINARY_OP_PLUS);\n+  create_vec_fn (ctxt, \"jit_v4f_sub\",\n+\t\t v4f_type, float_type, GCC_JIT_BINARY_OP_MINUS);\n+  create_vec_fn (ctxt, \"jit_v4f_mult\",\n+\t\t v4f_type, float_type, GCC_JIT_BINARY_OP_MULT);\n+  create_vec_fn (ctxt, \"jit_v4f_div\",\n+\t\t v4f_type, float_type, GCC_JIT_BINARY_OP_DIVIDE);\n+}\n+\n+template <typename V>\n+void\n+check_add (const V &a, const V &b, const V &c)\n+{\n+  for (int i = 0; i < 4; i++)\n+    CHECK_VALUE (c[i], a[i] + b[i]);\n+}\n+\n+template <typename V>\n+void\n+check_sub (const V &a, const V &b, const V &c)\n+{\n+  for (int i = 0; i < 4; i++)\n+    CHECK_VALUE (c[i], a[i] - b[i]);\n+}\n+\n+template <typename V>\n+void\n+check_mult (const V &a, const V &b, const V &c)\n+{\n+  for (int i = 0; i < 4; i++)\n+    CHECK_VALUE (c[i], a[i] * b[i]);\n+}\n+\n+template <typename V>\n+void\n+check_div (const V &a, const V &b, const V &c)\n+{\n+  for (int i = 0; i < 4; i++)\n+    CHECK_VALUE (c[i], a[i] / b[i]);\n+}\n+\n+template <typename V, typename E>\n+void\n+verify_vec_code (gcc_jit_context *ctxt, gcc_jit_result *result,\n+\t\t const char *fnname,\n+\t\t void (*check_cb) (const V &a, const V &b, const V &c))\n+{\n+  typedef void (*binop_type) (const V *a, V *b, E p, E q, E r, E s);\n+  CHECK_NON_NULL (result);\n+  binop_type fn =\n+    (binop_type)gcc_jit_result_get_code (result, fnname);\n+  CHECK_NON_NULL (fn);\n+\n+  V dst, lhs, pqrs;\n+\n+  /* Init.  */\n+  for (int i = 0; i < 4; i++)\n+    {\n+      lhs[i] = i + 5;\n+      pqrs[i] = (i + 4) * 3;\n+    }\n+\n+  /* Run jit-compiled code and verify result.  */\n+  fn (&dst, &lhs, pqrs[0], pqrs[1], pqrs[2], pqrs[3]);\n+  check_cb (lhs, pqrs, dst);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  verify_vec_code<v4si, int> (ctxt, result, \"jit_v4si_add\", check_add);\n+  verify_vec_code<v4si, int> (ctxt, result, \"jit_v4si_sub\", check_sub);\n+  verify_vec_code<v4si, int> (ctxt, result, \"jit_v4si_mult\", check_mult);\n+  verify_vec_code<v4si, int> (ctxt, result, \"jit_v4si_div\", check_div);\n+\n+  verify_vec_code<v4ui, unsigned int> (ctxt, result, \"jit_v4ui_add\", check_add);\n+  verify_vec_code<v4ui, unsigned int> (ctxt, result, \"jit_v4ui_sub\", check_sub);\n+  verify_vec_code<v4ui, unsigned int> (ctxt, result, \"jit_v4ui_mult\", check_mult);\n+  verify_vec_code<v4ui, unsigned int> (ctxt, result, \"jit_v4ui_div\", check_div);\n+\n+  verify_vec_code<v4f, float> (ctxt, result, \"jit_v4f_add\", check_add);\n+  verify_vec_code<v4f, float> (ctxt, result, \"jit_v4f_sub\", check_sub);\n+  verify_vec_code<v4f, float> (ctxt, result, \"jit_v4f_mult\", check_mult);\n+  verify_vec_code<v4f, float> (ctxt, result, \"jit_v4f_div\", check_div);\n+}"}]}