{"sha": "1e9b78b094572631b2abf3759e4752fe1862cc12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU5Yjc4YjA5NDU3MjYzMWIyYWJmMzc1OWU0NzUyZmUxODYyY2MxMg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-04-12T17:28:11Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-04-12T17:28:11Z"}, "message": "simplify-rtx.c (simplify_binary_operation): Remove fall throughs.\n\n\n\t* simplify-rtx.c (simplify_binary_operation) <UDIV, DIV, UMOD, MOD>:\n\tRemove fall throughs.  Convert 0/x and 0%x into x&0 when x has\n\tside-effects.  Don't convert x/1.0 into x if we honor signaling NaNs.\n\tConvert x/-1.0 into -x if we don't honor signaling NaNs.  Convert\n\tx/-1 into -x.  Optimize x%1 into x&0 if x has side-effects.  Optimize\n\tx%-1 into 0 (or x&0 if x has side-effects).\n\nFrom-SVN: r80625", "tree": {"sha": "8639f921f4775bdce91bf3b169dbbbda56350d26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8639f921f4775bdce91bf3b169dbbbda56350d26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e9b78b094572631b2abf3759e4752fe1862cc12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e9b78b094572631b2abf3759e4752fe1862cc12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e9b78b094572631b2abf3759e4752fe1862cc12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e9b78b094572631b2abf3759e4752fe1862cc12/comments", "author": null, "committer": null, "parents": [{"sha": "e0fb1c5c37a5728cc2deb3a98df0c2bf3f1cd109", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0fb1c5c37a5728cc2deb3a98df0c2bf3f1cd109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0fb1c5c37a5728cc2deb3a98df0c2bf3f1cd109"}], "stats": {"total": 152, "additions": 109, "deletions": 43}, "files": [{"sha": "ac9f0c9fef2385e3d904eaa1d2658f547575fcc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9b78b094572631b2abf3759e4752fe1862cc12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9b78b094572631b2abf3759e4752fe1862cc12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e9b78b094572631b2abf3759e4752fe1862cc12", "patch": "@@ -1,3 +1,12 @@\n+2004-04-12  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* simplify-rtx.c (simplify_binary_operation) <UDIV, DIV, UMOD, MOD>:\n+\tRemove fall throughs.  Convert 0/x and 0%x into x&0 when x has\n+\tside-effects.  Don't convert x/1.0 into x if we honor signaling NaNs.\n+\tConvert x/-1.0 into -x if we don't honor signaling NaNs.  Convert\n+\tx/-1 into -x.  Optimize x%1 into x&0 if x has side-effects.  Optimize\n+\tx%-1 into 0 (or x&0 if x has side-effects).\n+\n 2004-04-11  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/rs6000.md: Document why a pattern is not"}, {"sha": "b6340e54c8b8c1ab7bedd9c280f76aeb09a6fe6e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 100, "deletions": 43, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e9b78b094572631b2abf3759e4752fe1862cc12/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e9b78b094572631b2abf3759e4752fe1862cc12/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=1e9b78b094572631b2abf3759e4752fe1862cc12", "patch": "@@ -1900,70 +1900,127 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t  break;\n \n \tcase UDIV:\n-\t  /* Convert divide by power of two into shift (divide by 1 handled\n-\t     below).  */\n-\t  if (GET_CODE (trueop1) == CONST_INT\n-\t      && (arg1 = exact_log2 (INTVAL (trueop1))) > 0)\n-\t    return simplify_gen_binary (LSHIFTRT, mode, op0, GEN_INT (arg1));\n-\n-\t  /* Fall through....  */\n-\n-\tcase DIV:\n-\t  if (trueop1 == CONST1_RTX (mode))\n+\t  /* 0/x is 0 (or x&0 if x has side-effects).  */\n+\t  if (trueop0 == const0_rtx)\n+\t    return side_effects_p (op1)\n+\t\t   ? simplify_gen_binary (AND, mode, op1, const0_rtx)\n+\t\t   : const0_rtx;\n+\t  /* x/1 is x.  */\n+\t  if (trueop1 == const1_rtx)\n \t    {\n-\t      /* On some platforms DIV uses narrower mode than its\n-\t\t operands.  */\n+\t      /* Handle narrowing UDIV.  */\n \t      rtx x = gen_lowpart_common (mode, op0);\n \t      if (x)\n \t\treturn x;\n-\t      else if (mode != GET_MODE (op0) && GET_MODE (op0) != VOIDmode)\n+\t      if (mode != GET_MODE (op0) && GET_MODE (op0) != VOIDmode)\n \t\treturn gen_lowpart_SUBREG (mode, op0);\n-\t      else\n-\t\treturn op0;\n+\t      return op0;\n \t    }\n+\t  /* Convert divide by power of two into shift.  */\n+\t  if (GET_CODE (trueop1) == CONST_INT\n+\t      && (arg1 = exact_log2 (INTVAL (trueop1))) > 0)\n+\t    return simplify_gen_binary (LSHIFTRT, mode, op0, GEN_INT (arg1));\n+\t  break;\n \n-\t  /* Maybe change 0 / x to 0.  This transformation isn't safe for\n-\t     modes with NaNs, since 0 / 0 will then be NaN rather than 0.\n-\t     Nor is it safe for modes with signed zeros, since dividing\n-\t     0 by a negative number gives -0, not 0.  */\n-\t  if (!HONOR_NANS (mode)\n-\t      && !HONOR_SIGNED_ZEROS (mode)\n-\t      && trueop0 == CONST0_RTX (mode)\n-\t      && ! side_effects_p (op1))\n-\t    return op0;\n-\n-\t  /* Change division by a constant into multiplication.  Only do\n-\t     this with -funsafe-math-optimizations.  */\n-\t  else if (GET_CODE (trueop1) == CONST_DOUBLE\n-\t\t   && GET_MODE_CLASS (GET_MODE (trueop1)) == MODE_FLOAT\n-\t\t   && trueop1 != CONST0_RTX (mode)\n-\t\t   && flag_unsafe_math_optimizations)\n+\tcase DIV:\n+\t  /* Handle floating point and integers separately.  */\n+\t  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t    {\n-\t      REAL_VALUE_TYPE d;\n-\t      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop1);\n+\t      /* Maybe change 0.0 / x to 0.0.  This transformation isn't\n+\t\t safe for modes with NaNs, since 0.0 / 0.0 will then be\n+\t\t NaN rather than 0.0.  Nor is it safe for modes with signed\n+\t\t zeros, since dividing 0 by a negative number gives -0.0  */\n+\t      if (trueop0 == CONST0_RTX (mode)\n+\t\t  && !HONOR_NANS (mode)\n+\t\t  && !HONOR_SIGNED_ZEROS (mode)\n+\t\t  && ! side_effects_p (op1))\n+\t\treturn op0;\n+\t      /* x/1.0 is x.  */\n+\t      if (trueop1 == CONST1_RTX (mode)\n+\t\t  && !HONOR_SNANS (mode))\n+\t\treturn op0;\n \n-\t      if (! REAL_VALUES_EQUAL (d, dconst0))\n+\t      if (GET_CODE (trueop1) == CONST_DOUBLE\n+\t\t  && trueop1 != CONST0_RTX (mode))\n+\t\t{\n+\t\t  REAL_VALUE_TYPE d;\n+\t\t  REAL_VALUE_FROM_CONST_DOUBLE (d, trueop1);\n+\n+\t\t  /* x/-1.0 is -x.  */\n+\t\t  if (REAL_VALUES_EQUAL (d, dconstm1)\n+\t\t      && !HONOR_SNANS (mode))\n+\t\t    return simplify_gen_unary (NEG, mode, op0, mode);\n+\n+\t          /* Change FP division by a constant into multiplication.\n+\t\t     Only do this with -funsafe-math-optimizations.  */\n+\t\t  if (flag_unsafe_math_optimizations\n+\t\t      && !REAL_VALUES_EQUAL (d, dconst0))\n+\t\t    {\n+\t\t      REAL_ARITHMETIC (d, RDIV_EXPR, dconst1, d);\n+\t\t      tem = CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n+\t\t      return simplify_gen_binary (MULT, mode, op0, tem);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* 0/x is 0 (or x&0 if x has side-effects).  */\n+\t      if (trueop0 == const0_rtx)\n+\t\treturn side_effects_p (op1)\n+\t\t       ? simplify_gen_binary (AND, mode, op1, const0_rtx)\n+\t\t       : const0_rtx;\n+\t      /* x/1 is x.  */\n+\t      if (trueop1 == const1_rtx)\n+\t\t{\n+\t\t  /* Handle narrowing DIV.  */\n+\t\t  rtx x = gen_lowpart_common (mode, op0);\n+\t\t  if (x)\n+\t\t    return x;\n+\t\t  if (mode != GET_MODE (op0) && GET_MODE (op0) != VOIDmode)\n+\t\t    return gen_lowpart_SUBREG (mode, op0);\n+\t\t  return op0;\n+\t\t}\n+\t      /* x/-1 is -x.  */\n+\t      if (trueop1 == constm1_rtx)\n \t\t{\n-\t\t  REAL_ARITHMETIC (d, rtx_to_tree_code (DIV), dconst1, d);\n-\t\t  tem = CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n-\t\t  return simplify_gen_binary (MULT, mode, op0, tem);\n+\t\t  rtx x = gen_lowpart_common (mode, op0);\n+\t\t  if (!x)\n+\t\t    x = (mode != GET_MODE (op0) && GET_MODE (op0) != VOIDmode)\n+\t\t\t? gen_lowpart_SUBREG (mode, op0) : op0;\n+\t\t  return simplify_gen_unary (NEG, mode, x, mode);\n \t\t}\n \t    }\n \t  break;\n \n \tcase UMOD:\n-\t  /* Handle modulus by power of two (mod with 1 handled below).  */\n+\t  /* 0%x is 0 (or x&0 if x has side-effects).  */\n+\t  if (trueop0 == const0_rtx)\n+\t    return side_effects_p (op1)\n+\t\t   ? simplify_gen_binary (AND, mode, op1, const0_rtx)\n+\t\t   : const0_rtx;\n+\t  /* x%1 is 0 (of x&0 if x has side-effects).  */\n+\t  if (trueop1 == const1_rtx)\n+\t    return side_effects_p (op0)\n+\t\t   ? simplify_gen_binary (AND, mode, op0, const0_rtx)\n+\t\t   : const0_rtx;\n+\t  /* Implement modulus by power of two as AND.  */\n \t  if (GET_CODE (trueop1) == CONST_INT\n \t      && exact_log2 (INTVAL (trueop1)) > 0)\n \t    return simplify_gen_binary (AND, mode, op0,\n \t\t\t\t\tGEN_INT (INTVAL (op1) - 1));\n-\n-\t  /* Fall through....  */\n+\t  break;\n \n \tcase MOD:\n-\t  if ((trueop0 == const0_rtx || trueop1 == const1_rtx)\n-\t      && ! side_effects_p (op0) && ! side_effects_p (op1))\n-\t    return const0_rtx;\n+\t  /* 0%x is 0 (or x&0 if x has side-effects).  */\n+\t  if (trueop0 == const0_rtx)\n+\t    return side_effects_p (op1)\n+\t\t   ? simplify_gen_binary (AND, mode, op1, const0_rtx)\n+\t\t   : const0_rtx;\n+\t  /* x%1 and x%-1 is 0 (or x&0 if x has side-effects).  */\n+\t  if (trueop1 == const1_rtx || trueop1 == constm1_rtx)\n+\t    return side_effects_p (op0)\n+\t\t   ? simplify_gen_binary (AND, mode, op0, const0_rtx)\n+\t\t   : const0_rtx;\n \t  break;\n \n \tcase ROTATERT:"}]}