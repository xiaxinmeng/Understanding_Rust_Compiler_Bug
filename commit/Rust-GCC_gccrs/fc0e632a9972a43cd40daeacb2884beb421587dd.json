{"sha": "fc0e632a9972a43cd40daeacb2884beb421587dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMwZTYzMmE5OTcyYTQzY2Q0MGRhZWFjYjI4ODRiZWI0MjE1ODdkZA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2018-06-11T09:19:17Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-06-11T09:19:17Z"}, "message": "[Ada] Unnesting: refactor handling of uplevel refs. for unconstrained arrays\n\n2018-06-11  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* exp_unst.ads, exp_unst.adb (Needs_Fat_Pointer,\n\tBuild_Access_Type_Decl): New subprograms to handle uplevel references\n\tto formals of an unconstrained array type. The activation record\n\tcomponent for these is an access type, and the reference is rewritten\n\tas an explicit derefenrence of that component.\n\nFrom-SVN: r261425", "tree": {"sha": "5bc8455c4972ed880ca300e42aba2b1391d4a0ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bc8455c4972ed880ca300e42aba2b1391d4a0ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc0e632a9972a43cd40daeacb2884beb421587dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc0e632a9972a43cd40daeacb2884beb421587dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc0e632a9972a43cd40daeacb2884beb421587dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc0e632a9972a43cd40daeacb2884beb421587dd/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6534852011f3e72090c690ffc53b990feb709b9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6534852011f3e72090c690ffc53b990feb709b9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6534852011f3e72090c690ffc53b990feb709b9f"}], "stats": {"total": 214, "additions": 186, "deletions": 28}, "files": [{"sha": "de142bfe442b660e5193ceb16f5aebfdba414635", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc0e632a9972a43cd40daeacb2884beb421587dd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc0e632a9972a43cd40daeacb2884beb421587dd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fc0e632a9972a43cd40daeacb2884beb421587dd", "patch": "@@ -1,3 +1,11 @@\n+2018-06-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_unst.ads, exp_unst.adb (Needs_Fat_Pointer,\n+\tBuild_Access_Type_Decl): New subprograms to handle uplevel references\n+\tto formals of an unconstrained array type. The activation record\n+\tcomponent for these is an access type, and the reference is rewritten\n+\tas an explicit derefenrence of that component.\n+\n 2018-06-11  Bob Duff  <duff@adacore.com>\n \n \t* libgnat/a-ciorma.adb, libgnat/a-ciormu.adb, libgnat/a-ciorse.adb,"}, {"sha": "183a6a77f1810681060154fe07327337916bdbdf", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 142, "deletions": 28, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc0e632a9972a43cd40daeacb2884beb421587dd/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc0e632a9972a43cd40daeacb2884beb421587dd/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=fc0e632a9972a43cd40daeacb2884beb421587dd", "patch": "@@ -98,6 +98,23 @@ package body Exp_Unst is\n    --  Append a call entry to the Calls table. A check is made to see if the\n    --  table already contains this entry and if so it has no effect.\n \n+   ----------------------------------\n+   -- subprograms for fat pointers --\n+   ----------------------------------\n+\n+   function Needs_Fat_Pointer (E : Entity_Id) return Boolean;\n+   --  A formal parameter of an unconstrained array type that appears in\n+   --  an uplevel reference requires the construction of an access type,\n+   --  to be used in the corresponding component declaration.\n+\n+   function Build_Access_Type_Decl\n+     (E    : Entity_Id;\n+      Scop : Entity_Id) return Node_Id;\n+   --  For an uplevel reference that involves an unconstrained array type,\n+   --  build an access type declaration for the corresponding activation\n+   --  record component. The relevant attributes of the access type are\n+   --  set here to avoid a full analysis that would require a scope stack.\n+\n    -----------\n    -- Urefs --\n    -----------\n@@ -152,6 +169,44 @@ package body Exp_Unst is\n       Calls.Append (Call);\n    end Append_Unique_Call;\n \n+   -----------------------\n+   -- Needs_Fat_Pointer --\n+   -----------------------\n+\n+   function Needs_Fat_Pointer (E : Entity_Id) return Boolean is\n+   begin\n+      return Is_Formal (E)\n+        and then Is_Array_Type (Etype (E))\n+        and then not Is_Constrained (Etype (E));\n+   end Needs_Fat_Pointer;\n+\n+   -----------------------------\n+   --  Build_Access_Type_Decl --\n+   -----------------------------\n+\n+   function Build_Access_Type_Decl\n+     (E    : Entity_Id;\n+      Scop : Entity_Id) return Node_Id\n+   is\n+      Loc  : constant Source_Ptr := Sloc (E);\n+      Decl : Node_Id;\n+      Typ  : Entity_Id;\n+\n+   begin\n+      Typ := Make_Temporary (Loc, 'S');\n+      Set_Ekind (Typ, E_General_Access_Type);\n+      Set_Etype (Typ, Typ);\n+      Set_Scope (Typ, Scop);\n+      Set_Directly_Designated_Type (Typ, Etype (E));\n+\n+      Decl := Make_Full_Type_Declaration (Loc,\n+        Defining_Identifier => Typ,\n+        Type_Definition => Make_Access_To_Object_Definition (Loc,\n+         Subtype_Indication => New_Occurrence_Of (Etype (E), Loc)));\n+\n+      return Decl;\n+   end Build_Access_Type_Decl;\n+\n    ---------------\n    -- Get_Level --\n    ---------------\n@@ -755,6 +810,21 @@ package body Exp_Unst is\n                      end if;\n                   end;\n \n+                  --  For an allocator with a qualified expression, check\n+                  --  type of expression being qualified. The explicit type\n+                  --  name is handled as an entity reference..\n+\n+                  if Nkind (N) = N_Allocator\n+                     and then Nkind (Expression (N)) = N_Qualified_Expression\n+                  then\n+                     declare\n+                        DT : Boolean := False;\n+                     begin\n+                        Check_Static_Type\n+                          (Etype (Expression (Expression (N))), Empty,  DT);\n+                     end;\n+                  end if;\n+\n                --  A 'Access reference is a (potential) call. Other attributes\n                --  require special handling.\n \n@@ -1004,7 +1074,8 @@ package body Exp_Unst is\n                         Callee := Enclosing_Subprogram (Ent);\n \n                         if Callee /= Caller\n-                          and then not Is_Static_Type (Ent)\n+                           and then (not Is_Static_Type (Ent)\n+                                      or else Needs_Fat_Pointer (Ent))\n                         then\n                            Note_Uplevel_Ref (Ent, N, Caller, Callee);\n \n@@ -1501,7 +1572,7 @@ package body Exp_Unst is\n                      Decl_Assign : Node_Id;\n                      --  Assigment to set uplink, Empty if none\n \n-                     Decls : List_Id;\n+                     Decls : constant List_Id := New_List;\n                      --  List of new declarations we create\n \n                   begin\n@@ -1534,8 +1605,9 @@ package body Exp_Unst is\n \n                      if Present (STJ.Uents) then\n                         declare\n-                           Elmt : Elmt_Id;\n-                           Uent : Entity_Id;\n+                           Elmt     : Elmt_Id;\n+                           Ptr_Decl : Node_Id;\n+                           Uent     : Entity_Id;\n \n                            Indx : Nat;\n                            --  1's origin of index in list of elements. This is\n@@ -1555,21 +1627,42 @@ package body Exp_Unst is\n                               Set_Activation_Record_Component\n                                 (Uent, Comp);\n \n-                              Append_To (Clist,\n-                                Make_Component_Declaration (Loc,\n-                                  Defining_Identifier  => Comp,\n-                                  Component_Definition =>\n-                                    Make_Component_Definition (Loc,\n-                                      Subtype_Indication =>\n-                                        New_Occurrence_Of (Addr, Loc))));\n+                              if Needs_Fat_Pointer (Uent) then\n+\n+                                 --  Build corresponding access type\n \n+                                 Ptr_Decl :=\n+                                   Build_Access_Type_Decl\n+                                     (Etype (Uent), STJ.Ent);\n+                                 Append_To (Decls, Ptr_Decl);\n+\n+                                 --  And use its type in the corresponding\n+                                 --  component.\n+\n+                                 Append_To (Clist,\n+                                   Make_Component_Declaration (Loc,\n+                                     Defining_Identifier  => Comp,\n+                                     Component_Definition =>\n+                                       Make_Component_Definition (Loc,\n+                                         Subtype_Indication =>\n+                                           New_Occurrence_Of\n+                                             (Defining_Identifier (Ptr_Decl),\n+                                               Loc))));\n+                              else\n+                                 Append_To (Clist,\n+                                   Make_Component_Declaration (Loc,\n+                                     Defining_Identifier  => Comp,\n+                                     Component_Definition =>\n+                                       Make_Component_Definition (Loc,\n+                                         Subtype_Indication =>\n+                                           New_Occurrence_Of (Addr, Loc))));\n+                              end if;\n                               Next_Elmt (Elmt);\n                            end loop;\n                         end;\n                      end if;\n \n                      --  Now we can insert the AREC declarations into the body\n-\n                      --    type ARECnT is record .. end record;\n                      --    pragma Suppress_Initialization (ARECnT);\n \n@@ -1584,7 +1677,7 @@ package body Exp_Unst is\n                              Component_List =>\n                                Make_Component_List (Loc,\n                                  Component_Items => Clist)));\n-                     Decls := New_List (Decl_ARECnT);\n+                     Append_To (Decls, Decl_ARECnT);\n \n                      --  type ARECnPT is access all ARECnT;\n \n@@ -1693,8 +1786,9 @@ package body Exp_Unst is\n                                  Loc : constant Source_Ptr := Sloc (Ent);\n                                  Dec : constant Node_Id    :=\n                                          Declaration_Node (Ent);\n-                                 Ins : Node_Id;\n-                                 Asn : Node_Id;\n+                                 Ins  : Node_Id;\n+                                 Asn  : Node_Id;\n+                                 Attr : Name_Id;\n \n                               begin\n                                  --  For parameters, we insert the assignment\n@@ -1716,6 +1810,13 @@ package body Exp_Unst is\n \n                                  --  Build and insert the assignment:\n                                  --    ARECn.nam := nam'Address\n+                                 --  or else 'Access for unconstrained array\n+\n+                                 if Needs_Fat_Pointer (Ent) then\n+                                    Attr := Name_Access;\n+                                 else\n+                                    Attr := Name_Address;\n+                                 end if;\n \n                                  Asn :=\n                                    Make_Assignment_Statement (Loc,\n@@ -1733,9 +1834,8 @@ package body Exp_Unst is\n                                        Make_Attribute_Reference (Loc,\n                                          Prefix         =>\n                                            New_Occurrence_Of (Ent, Loc),\n-                                         Attribute_Name => Name_Address));\n+                                         Attribute_Name => Attr));\n \n-                                 --  or else 'Access for unconstrained\n                                  Insert_After (Ins, Asn);\n \n                                  --  Analyze the assignment statement. We do\n@@ -1890,17 +1990,31 @@ package body Exp_Unst is\n                Comp := Activation_Record_Component (UPJ.Ent);\n                pragma Assert (Present (Comp));\n \n-               --  Do the replacement\n-\n-               Rewrite (UPJ.Ref,\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix         => New_Occurrence_Of (Atyp, Loc),\n-                   Attribute_Name => Name_Deref,\n-                   Expressions    => New_List (\n-                     Make_Selected_Component (Loc,\n-                       Prefix        => Pfx,\n-                       Selector_Name =>\n-                         New_Occurrence_Of (Comp, Loc)))));\n+               --  Do the replacement. If the component type is an\n+               --  access type, this is an uplevel reference for an\n+               --  entity that requires a fat pointer, so dereference\n+               --  the component.\n+\n+               if Is_Access_Type (Etype (Comp)) then\n+                  Rewrite (UPJ.Ref,\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix        => Pfx,\n+                          Selector_Name =>\n+                            New_Occurrence_Of (Comp, Loc))));\n+\n+               else\n+                  Rewrite (UPJ.Ref,\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Occurrence_Of (Atyp, Loc),\n+                      Attribute_Name => Name_Deref,\n+                      Expressions    => New_List (\n+                        Make_Selected_Component (Loc,\n+                          Prefix        => Pfx,\n+                          Selector_Name =>\n+                            New_Occurrence_Of (Comp, Loc)))));\n+               end if;\n \n                --  Analyze and resolve the new expression. We do not need to\n                --  establish the relevant scope stack entries here, because we"}, {"sha": "0cffd50d93cdfea23cd0393259da01fa8be2fcc5", "filename": "gcc/ada/exp_unst.ads", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc0e632a9972a43cd40daeacb2884beb421587dd/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc0e632a9972a43cd40daeacb2884beb421587dd/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=fc0e632a9972a43cd40daeacb2884beb421587dd", "patch": "@@ -562,6 +562,42 @@ package Exp_Unst is\n    --    uplevel call, a subprogram at level 5 can call one at level 2 or even\n    --    the outer level subprogram at level 1.\n \n+   -------------------------------------\n+   -- Handling of unconstrained types --\n+   -------------------------------------\n+\n+   --  Objects whose nominal subtype is an unconstrained array type present\n+   --  additional complications for translation into LLVM. The address\n+   --  attributes of such objects points to the first component of the\n+   --  array, and the bounds are found elsewhere, typically ahead of the\n+   --  components. In many cases the bounds of an object are stored ahead\n+   --  of the components and can be retrieved from it. However, if the\n+   --  object is an expression (.e.g a slice) the bounds are not adjacent\n+   --  and thus must be conveyed explicitly by means of a so-called\n+   --  fat pointer. This leads to the following enhancements to the\n+   --  handling of uplevel references described so far. This applies only\n+   --  to uplevel references to unconstrained formals of enclosing\n+   --  subprograms:\n+   --\n+   --  a) Uplevel references are detected as before during the tree traversal\n+   --  in Visit_Node. For referenes to uplevel formals, we include those with\n+   --  an unconstrained array type (e.g. String) even if suvh a type has\n+   --  static bounds.\n+   --\n+   --  b) references to unconstrained formals are recognized in the Subp\n+   --  table by means of the predicate Needs_Fat_Pointer.\n+   --\n+   --  c) When constructing the required activation record we also construct\n+   --  a named access type whose designated type is the unconstrained array\n+   --  type. The activation record of a subprogram that contains such an\n+   --  uplevel reference includes a component of this access type. The\n+   --  declaration for that access type is introduced and analyzed before\n+   --  that of the activation record, so it appears in the subprogram that\n+   --  has that formal.\n+   --\n+   --  d) The uplevel reference is rewritten as an explicit dereference (.all)\n+   --  of the corresponding pointer component.\n+   --\n    -----------\n    -- Subps --\n    -----------"}]}