{"sha": "5877286edf40476fffde9b05dfaaa382cd304c5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg3NzI4NmVkZjQwNDc2ZmZmZGU5YjA1ZGZhYWEzODJjZDMwNGM1YQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-03-31T11:46:42Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-03-31T11:46:42Z"}, "message": "gjavah.c (print_field_info): Allow constants of other types.\n\n\t* gjavah.c (print_field_info): Allow constants of other types.\n\t(print_include): Generate include when new name is proper prefix\n\tof already printed name.\n\t(add_namelet): Likewise.\n\t(cxx_keyword_subst): New function.\n\t(print_method_info): Use it.\n\t(print_field_name): New function.\n\t(get_field_name): New function.\n\t(print_field_info): Use get_field_name and print_field_name.\n\nFrom-SVN: r26085", "tree": {"sha": "281223c051aa325cb83f86820a7483ee10c1ae22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/281223c051aa325cb83f86820a7483ee10c1ae22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5877286edf40476fffde9b05dfaaa382cd304c5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5877286edf40476fffde9b05dfaaa382cd304c5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5877286edf40476fffde9b05dfaaa382cd304c5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5877286edf40476fffde9b05dfaaa382cd304c5a/comments", "author": null, "committer": null, "parents": [{"sha": "8d0823e282b3d83cc743afc11e4732e23647c541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d0823e282b3d83cc743afc11e4732e23647c541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d0823e282b3d83cc743afc11e4732e23647c541"}], "stats": {"total": 168, "additions": 122, "deletions": 46}, "files": [{"sha": "4ae22f108e59267bcf6b51117bb6e8cc9e14d9cf", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5877286edf40476fffde9b05dfaaa382cd304c5a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5877286edf40476fffde9b05dfaaa382cd304c5a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5877286edf40476fffde9b05dfaaa382cd304c5a", "patch": "@@ -1,3 +1,15 @@\n+1999-03-31  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* gjavah.c (print_field_info): Allow constants of other types.\n+\t(print_include): Generate include when new name is proper prefix\n+\tof already printed name.\n+\t(add_namelet): Likewise.\n+\t(cxx_keyword_subst): New function.\n+\t(print_method_info): Use it.\n+\t(print_field_name): New function.\n+\t(get_field_name): New function.\n+\t(print_field_info): Use get_field_name and print_field_name.\n+\n Wed Mar 31 11:00:32 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n         * Makefile.in (keyword.h): Generate using gperf language 'C', not"}, {"sha": "8fbcc2c7942346b756da0320d8954c6da74c5fa3", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 110, "deletions": 46, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5877286edf40476fffde9b05dfaaa382cd304c5a/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5877286edf40476fffde9b05dfaaa382cd304c5a/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=5877286edf40476fffde9b05dfaaa382cd304c5a", "patch": "@@ -259,6 +259,23 @@ utf8_cmp (str, length, name)\n   return str != limit;\n }\n \n+/* If NAME is the name of a C++ keyword, then return an override name.\n+   This is a name that can be used in place of the keyword.\n+   Otherwise, return NULL.  FIXME: for now, we only handle those\n+   keywords we know to be a problem for libgcj.  */\n+\n+static char *\n+cxx_keyword_subst (str, length)\n+     unsigned char *str;\n+     int length;\n+{\n+  if (! utf8_cmp (str, length, \"delete\"))\n+    return \"__dummy_delete\";\n+  else if (! utf8_cmp (str, length, \"enum\"))\n+    return \"__dummy_enum\";\n+  return NULL;\n+}\n+\n /* Generate an access control keyword based on FLAGS.  Returns 0 if\n    FLAGS matches the saved access information, nonzero otherwise.  */\n \n@@ -309,28 +326,96 @@ name_is_method_p (name, length)\n   return 0;\n }\n \n+/* Get name of a field.  This handles renamings due to C++ clash.  */\n+static char *\n+get_field_name (jcf, name_index, flags)\n+     JCF *jcf;\n+     int name_index;\n+     JCF_u2 flags;\n+{\n+  unsigned char *name = JPOOL_UTF_DATA (jcf, name_index);\n+  int length = JPOOL_UTF_LENGTH (jcf, name_index);\n+  char *override;\n+\n+  if (name_is_method_p (name, length))\n+    {\n+      /* This field name matches a method.  So override the name with\n+\t a dummy name.  This is yucky, but it isn't clear what else to\n+\t do.  FIXME: if the field is static, then we'll be in real\n+\t trouble.  */\n+      if ((flags & ACC_STATIC))\n+\t{\n+\t  fprintf (stderr, \"static field has same name as method\\n\");\n+\t  found_error = 1;\n+\t  return NULL;\n+\t}\n+\n+      override = (char *) malloc (length + 3);\n+      memcpy (override, name, length);\n+      strcpy (override + length, \"__\");\n+    }\n+  else if ((override = cxx_keyword_subst (name, length)) != NULL)\n+    {\n+      /* Must malloc OVERRIDE.  */\n+      char *o2 = (char *) malloc (strlen (override) + 1);\n+      strcpy (o2, override);\n+      override = o2;\n+    }\n+\n+  return override;\n+}\n+\n+/* Print a field name.  Convenience function for use with\n+   get_field_name.  */\n+static void\n+print_field_name (stream, jcf, name_index, flags)\n+     FILE *stream;\n+     JCF *jcf;\n+     int name_index;\n+     JCF_u2 flags;\n+{\n+  char *override = get_field_name (jcf, name_index, flags);\n+\n+  if (override)\n+    {\n+      fputs (override, stream);\n+      free (override);\n+    }\n+  else\n+    jcf_print_utf8 (stream, JPOOL_UTF_DATA (jcf, name_index),\n+\t\t    JPOOL_UTF_LENGTH (jcf, name_index));\n+}\n+\n static void\n DEFUN(print_field_info, (stream, jcf, name_index, sig_index, flags),\n       FILE *stream AND JCF* jcf\n       AND int name_index AND int sig_index AND JCF_u2 flags)\n {\n   char *override = NULL;\n \n+  generate_access (stream, flags);\n+  if (JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n+    {\n+      fprintf (stream, \"<not a UTF8 constant>\");\n+      found_error = 1;\n+      return;\n+    }\n+\n   if (flags & ACC_FINAL)\n     {\n       if (current_field_value > 0)\n \t{\n \t  char buffer[25];\n+\t  int done = 1;\n \n-\t  generate_access (stream, flags);\n \t  switch (JPOOL_TAG (jcf, current_field_value))\n \t    {\n \t    case CONSTANT_Integer:\n \t      {\n \t\tjint num;\n \t\tint most_negative = 0;\n \t\tfputs (\"  static const jint \", out);\n-\t\tprint_name (out, jcf, name_index);\n+\t\tprint_field_name (out, jcf, name_index);\n \t\tfputs (\" = \", out);\n \t\tnum = JPOOL_INT (jcf, current_field_value);\n \t\t/* We single out the most negative number to print\n@@ -349,7 +434,7 @@ DEFUN(print_field_info, (stream, jcf, name_index, sig_index, flags),\n \t\tjlong num;\n \t\tint most_negative = 0;\n \t\tfputs (\"  static const jlong \", out);\n-\t\tprint_name (out, jcf, name_index);\n+\t\tprint_field_name (out, jcf, name_index);\n \t\tfputs (\" = \", out);\n \t\tnum = JPOOL_LONG (jcf, current_field_value);\n \t\t/* We single out the most negative number to print\n@@ -367,7 +452,7 @@ DEFUN(print_field_info, (stream, jcf, name_index, sig_index, flags),\n \t      {\n \t\tjfloat fnum = JPOOL_FLOAT (jcf, current_field_value);\n \t\tfputs (\"  static const jfloat \", out);\n-\t\tprint_name (out, jcf, name_index);\n+\t\tprint_field_name (out, jcf, name_index);\n \t\tif (! java_float_finite (fnum))\n \t\t  fputs (\";\\n\", out);\n \t\telse\n@@ -378,54 +463,30 @@ DEFUN(print_field_info, (stream, jcf, name_index, sig_index, flags),\n \t      {\n \t\tjdouble dnum = JPOOL_DOUBLE (jcf, current_field_value);\n \t\tfputs (\"  static const jdouble \", out);\n-\t\tprint_name (out, jcf, name_index);\n+\t\tprint_field_name (out, jcf, name_index);\n \t\tif (! java_double_finite (dnum))\n \t\t  fputs (\";\\n\", out);\n \t\telse\n \t\t  fprintf (out, \" = %.17g;\\n\",  dnum);\n \t      }\n \t      break;\n \t    default:\n-\t      fprintf(out, \" <<inappropriate constant type>>\\n\");\n+ \t      /* We can't print this as a constant, but we can still\n+ \t\t print something sensible.  */\n+ \t      done = 0;\n+ \t      break;\n \t    }\n \n-\t  return;\n+\t  if (done)\n+\t    return;\n \t}\n     }\n \n-  generate_access (stream, flags);\n   fputs (\"  \", out);\n   if ((flags & ACC_STATIC))\n     fputs (\"static \", out);\n \n-  if (JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n-    {\n-      fprintf (stream, \"<not a UTF8 constant>\");\n-      found_error = 1;\n-    }\n-  else\n-    {\n-      unsigned char *name = JPOOL_UTF_DATA (jcf, name_index);\n-      int length = JPOOL_UTF_LENGTH (jcf, name_index);\n-\n-      if (name_is_method_p (name, length))\n-\t{\n-\t  /* This field name matches a method.  So override the name\n-\t     with a dummy name.  This is yucky, but it isn't clear\n-\t     what else to do.  FIXME: if the field is static, then\n-\t     we'll be in real trouble.  */\n-\t  if ((flags & ACC_STATIC))\n-\t    {\n-\t      fprintf (stderr, \"static field has same name as method\\n\");\n-\t      found_error = 1;\n-\t    }\n-\n-\t  override = (char *) malloc (length + 3);\n-\t  memcpy (override, name, length);\n-\t  strcpy (override + length, \"__\");\n-\t}\n-    }\n-\n+  override = get_field_name (jcf, name_index, flags);\n   print_c_decl (out, jcf, name_index, sig_index, 0, override);\n   fputs (\";\\n\", out);\n \n@@ -480,21 +541,20 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n       method_name_list = nn;\n     }\n \n-  /* We can't generate a method whose name is a C++ reserved word.\n-     For now the only problem has been `delete'; add more here as\n-     required.  We can't just ignore the function, because that will\n-     cause incorrect code to be generated if the function is virtual\n-     (not only for calls to this function for for other functions\n-     after it in the vtbl).  So we give it a dummy name instead.  */\n-  if (! utf8_cmp (str, length, \"delete\"))\n+  /* We can't generate a method whose name is a C++ reserved word.  We\n+     can't just ignore the function, because that will cause incorrect\n+     code to be generated if the function is virtual (not only for\n+     calls to this function for for other functions after it in the\n+     vtbl).  So we give it a dummy name instead.  */\n+  override = cxx_keyword_subst (str, length);\n+  if (override)\n     {\n       /* If the method is static or final, we can safely skip it.  If\n \t we don't skip it then we'll have problems since the mangling\n \t will be wrong.  FIXME.  */\n       if (METHOD_IS_FINAL (jcf->access_flags, flags)\n \t  || (flags & ACC_STATIC))\n \treturn;\n-      override = \"__dummy_delete\";\n     }\n \n   method_printed = 1;\n@@ -861,7 +921,9 @@ print_include (out, utf8, len)\n \n   for (incl = all_includes; incl; incl = incl->next)\n     {\n-      if (! strncmp (incl->name, utf8, len))\n+      /* We check the length because we might have a proper prefix.  */\n+      if (len == strlen (incl->name)\n+\t  && ! strncmp (incl->name, utf8, len))\n \treturn;\n     }\n \n@@ -935,7 +997,9 @@ add_namelet (name, name_limit, parent)\n   /* Search for this name beneath the PARENT node.  */\n   for (np = parent->subnamelets; np != NULL; np = np->next)\n     {\n-      if (! strncmp (name, np->name, p - name))\n+      /* We check the length because we might have a proper prefix.  */\n+      if (strlen (np->name) == p - name &&\n+\t  ! strncmp (name, np->name, p - name))\n \t{\n \t  n = np;\n \t  break;"}]}