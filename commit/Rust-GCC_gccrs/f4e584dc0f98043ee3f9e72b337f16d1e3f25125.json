{"sha": "f4e584dc0f98043ee3f9e72b337f16d1e3f25125", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRlNTg0ZGMwZjk4MDQzZWUzZjllNzJiMzM3ZjE2ZDFlM2YyNTEyNQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-03-10T20:14:05Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-10T20:14:05Z"}, "message": "gcse.c: Update various comments.\n\n        * gcse.c: Update various comments.\n        (current_function_calls_longjmp): Delete declaration.\n\nFrom-SVN: r25674", "tree": {"sha": "c59b4da12b0dabbb55b5d5037b3b5a7af40083e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c59b4da12b0dabbb55b5d5037b3b5a7af40083e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4e584dc0f98043ee3f9e72b337f16d1e3f25125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e584dc0f98043ee3f9e72b337f16d1e3f25125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4e584dc0f98043ee3f9e72b337f16d1e3f25125", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e584dc0f98043ee3f9e72b337f16d1e3f25125/comments", "author": null, "committer": null, "parents": [{"sha": "e78d9500be1a9722b1936bab50706befa67ee6ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e78d9500be1a9722b1936bab50706befa67ee6ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e78d9500be1a9722b1936bab50706befa67ee6ca"}], "stats": {"total": 130, "additions": 49, "deletions": 81}, "files": [{"sha": "e79ad5e7ec5db007850438d5ceb9ec9c8f1acfd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e584dc0f98043ee3f9e72b337f16d1e3f25125/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e584dc0f98043ee3f9e72b337f16d1e3f25125/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4e584dc0f98043ee3f9e72b337f16d1e3f25125", "patch": "@@ -1,5 +1,8 @@\n Wed Mar 10 20:28:29 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* gcse.c: Update various comments.\n+\t(current_function_calls_longjmp): Delete declaration.\n+\n \t* gcse.c (run_jump_opt_after_gcse): New variable.\n \t(gcse_main): Returns an integer.\n \t(hash_scan_set): Record initializations from CONST_DOUBLEs too."}, {"sha": "cebf2c978f448886455b12e03f31af2628121ed8", "filename": "gcc/gcse.c", "status": "modified", "additions": 46, "deletions": 81, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e584dc0f98043ee3f9e72b337f16d1e3f25125/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e584dc0f98043ee3f9e72b337f16d1e3f25125/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=f4e584dc0f98043ee3f9e72b337f16d1e3f25125", "patch": "@@ -1,4 +1,4 @@\n-/* Global common subexpression elimination\n+/* Global common subexpression elimination/Partial redundancy elimination\n    and global constant/copy propagation for GNU compiler.\n    Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n \n@@ -24,18 +24,17 @@ Boston, MA 02111-1307, USA.  */\n    - do rough calc of how many regs are needed in each block, and a rough\n      calc of how many regs are available in each class and use that to\n      throttle back the code in cases where RTX_COST is minimal.\n-   - memory aliasing support\n+   - dead store elimination\n+   - a store to the same address as a load does not kill the load if the\n+     source of the store is also the destination of the load.  Handling this\n+     allows more load motion, particularly out of loops.\n    - ability to realloc sbitmap vectors would allow one initial computation\n      of reg_set_in_block with only subsequent additions, rather than\n      recomputing it for each pass\n \n-   NOTES\n-   - the classic gcse implementation is kept in for now for comparison\n */\n \n /* References searched while implementing this.\n-   This list will eventually be deleted but I wanted to have a record of it\n-   for now.\n \n    Compilers Principles, Techniques and Tools\n    Aho, Sethi, Ullman\n@@ -49,12 +48,6 @@ Boston, MA 02111-1307, USA.  */\n    Frederick Chow\n    Stanford Ph.D. thesis, Dec. 1983\n \n-xxx\n-   Elimination Algorithms for Data Flow Analysis\n-   B.G. Ryder, M.C. Paull\n-   ACM Computing Surveys, Vol. 18, Num. 3, Sep. 1986\n-\n-reread\n    A Fast Algorithm for Code Movement Optimization\n    D.M. Dhamdhere\n    SIGPLAN Notices, Vol. 23, Num. 10, Oct. 1988\n@@ -74,11 +67,6 @@ reread\n    R. Cytron, J. Ferrante, B.K. Rosen, M.N. Wegman, and F.K. Zadeck\n    ACM TOPLAS, Vol. 13, Num. 4, Oct. 1991\n \n-yyy\n-   How to Analyze Large Programs Efficiently and Informatively\n-   D.M. Dhamdhere, B.K. Rosen, F.K. Zadeck\n-   ACM SIGPLAN Notices Vol. 27, Num. 7, Jul. 1992, '92 Conference on PLDI\n-\n    Lazy Code Motion\n    J. Knoop, O. Ruthing, B. Steffen\n    ACM SIGPLAN Notices Vol. 27, Num. 7, Jul. 1992, '92 Conference on PLDI\n@@ -134,13 +122,24 @@ yyy\n    Michael Wolfe\n    Addison-Wesley, 1996\n \n-   People wishing to speed up the code here should read xxx, yyy.\n+   Advanced Compiler Design and Implementation\n+   Steven Muchnick\n+   Morgan Kaufmann, 1997\n+\n+   People wishing to speed up the code here should read:\n+     Elimination Algorithms for Data Flow Analysis\n+     B.G. Ryder, M.C. Paull\n+     ACM Computing Surveys, Vol. 18, Num. 3, Sep. 1986\n+\n+     How to Analyze Large Programs Efficiently and Informatively\n+     D.M. Dhamdhere, B.K. Rosen, F.K. Zadeck\n+     ACM SIGPLAN Notices Vol. 27, Num. 7, Jul. 1992, '92 Conference on PLDI\n+\n    People wishing to do something different can find various possibilities\n    in the above papers and elsewhere.\n */\n \n #include \"config.h\"\n-/* Must precede rtl.h for FFS.  */\n #include \"system.h\"\n \n #include \"rtl.h\"\n@@ -174,11 +173,10 @@ yyy\n    heuristics into gcse.c.  */\n #define FOLLOW_BACK_EDGES 1\n \n-/* We support two GCSE implementations: Classic GCSE (i.e. Dragon Book)\n-   and PRE (Partial Redundancy Elimination) GCSE (based on Fred Chow's thesis).\n-   The default is PRE.\n+/* We support GCSE via Partial Redundancy Elimination.  PRE optimizations\n+   are a superset of those done by GCSE.\n \n-   In either case we perform the following steps:\n+   We perform the following steps:\n \n    1) Compute basic block information.\n \n@@ -202,10 +200,7 @@ yyy\n    Function want_to_gcse_p says what these are.\n \n    PRE handles moving invariant expressions out of loops (by treating them as\n-   partially redundant).  This feature of PRE is disabled here (by not\n-   propagating dataflow information along back edges) because loop.c has more\n-   involved (and thus typically better) heuristics for what to move out of\n-   loops.\n+   partially redundant).\n \n    Eventually it would be nice to replace cse.c/gcse.c with SSA (static single\n    assignment) based GVN (global value numbering).  L. T. Simpson's paper\n@@ -254,7 +249,7 @@ yyy\n    argue it is not.  The number of iterations for the algorithm to converge\n    is typically 2-4 so I don't view it as that expensive (relatively speaking).\n \n-   PRE GCSE depends heavily on the seconds CSE pass to clean up the copies\n+   PRE GCSE depends heavily on the second CSE pass to clean up the copies\n    we create.  To make an expression reach the place where it's redundant,\n    the result of the expression is copied to a new register, and the redundant\n    expression is deleted by replacing it with this new register.  Classic GCSE\n@@ -263,35 +258,6 @@ yyy\n \n    **********************\n \n-   When -fclassic-gcse, we perform a classic global CSE pass.\n-   It is based on the algorithms in the Dragon book, and is based on code\n-   written by Devor Tevi at Intel.\n-\n-   The steps for Classic GCSE are:\n-\n-   1) Build the hash table of expressions we wish to GCSE (expr_hash_table).\n-      Also recorded are reaching definition \"gen\" statements (rd_gen)\n-\n-   2) Compute the reaching definitions (reaching_defs).\n-      This is a bitmap for each basic block indexed by INSN_CUID that is 1\n-      for each statement containing a definition that reaches the block.\n-\n-   3) Compute the available expressions (ae_in).\n-      This is a bitmap for each basic block indexed by expression number\n-      that is 1 for each expression that is available at the beginning of\n-      the block.\n-\n-   4) Perform GCSE.\n-      This is done by scanning each instruction looking for sets of the form\n-      (set (pseudo-reg) (expression)) and checking if `expression' is in the\n-      hash table.  If it is, and if the expression is available, and if only\n-      one computation of the expression reaches the instruction, we substitute\n-      the expression for a register containing its value.  If there is no\n-      such register, but the expression is expensive enough we create an\n-      instruction to copy the result of the expression into and use that.\n-\n-   **********************\n-\n    A fair bit of simplicity is created by creating small functions for simple\n    tasks, even when the function is only called in one place.  This may\n    measurably slow things down [or may not] by creating more function call\n@@ -307,6 +273,23 @@ yyy\n /* -dG dump file.  */\n static FILE *gcse_file;\n \n+/* Note whether or not we should run jump optimization after gcse.  We\n+   want to do this for two cases.\n+\n+    * If we changed any jumps via cprop.\n+\n+    * If we added any labels via edge splitting.  */\n+\n+static int run_jump_opt_after_gcse;\n+\n+/* Element I is a list of I's predecessors/successors.  */\n+static int_list_ptr *s_preds;\n+static int_list_ptr *s_succs;\n+\n+/* Element I is the number of predecessors/successors of basic block I.  */\n+static int *num_preds;\n+static int *num_succs;\n+\n /* Bitmaps are normally not included in debugging dumps.\n    However it's useful to be able to print them from GDB.\n    We could create special functions for this, but it's simpler to\n@@ -325,23 +308,6 @@ static char can_copy_p[(int) NUM_MACHINE_MODES];\n /* Non-zero if can_copy_p has been initialized.  */\n static int can_copy_init_p;\n \n-/* Element I is a list of I's predecessors/successors.  */\n-static int_list_ptr *s_preds;\n-static int_list_ptr *s_succs;\n-\n-/* Element I is the number of predecessors/successors of basic block I.  */\n-static int *num_preds;\n-static int *num_succs;\n-\n-/* Note whether or not we should run jump optimization after gcse.  We\n-   want to do this for two cases.\n-\n-    * If we changed any jumps via cprop.\n-\n-    * If we added any labels via edge splitting.  */\n-\n-static int run_jump_opt_after_gcse;\n-\n /* Hash table of expressions.  */\n \n struct expr\n@@ -354,8 +320,9 @@ struct expr\n   struct expr *next_same_hash;\n   /* List of anticipatable occurrences in basic blocks in the function.\n      An \"anticipatable occurrence\" is one that is the first occurrence in the\n-     basic block and the operands are not modified in the basic block prior\n-     to the occurrence.  */\n+     basic block, the operands are not modified in the basic block prior\n+     to the occurrence and the output is not used between the start of\n+     the block and the occurrence.  */\n   struct occr *antic_occr;\n   /* List of available occurrence in basic blocks in the function.\n      An \"available occurrence\" is one that is the last occurrence in the\n@@ -444,11 +411,10 @@ static int n_sets;\n \n    For simplicity, GCSE is done on sets of pseudo-regs only.  PRE GCSE only\n    requires knowledge of which blocks kill which regs [and thus could use\n-   a bitmap instead of the lists `reg_set_table' uses].  The classic GCSE\n-   uses the information in lists.\n+   a bitmap instead of the lists `reg_set_table' uses].\n \n-   If the classic GCSE pass is deleted `reg_set_table' and could be turned\n-   into an array of bitmaps (num-bbs x num-regs)\n+   `reg_set_table' and could be turned into an array of bitmaps\n+   (num-bbs x num-regs)\n    [however perhaps it may be useful to keep the data as is].\n    One advantage of recording things this way is that `reg_set_table' is\n    fairly sparse with respect to pseudo regs but for hard regs could be\n@@ -515,7 +481,6 @@ static int copy_prop_count;\n \n extern char *current_function_name;\n extern int current_function_calls_setjmp;\n-extern int current_function_calls_longjmp;\n \f\n /* These variables are used by classic GCSE.\n    Normally they'd be defined a bit later, but `rd_gen' needs to"}]}