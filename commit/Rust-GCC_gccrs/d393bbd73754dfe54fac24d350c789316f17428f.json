{"sha": "d393bbd73754dfe54fac24d350c789316f17428f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM5M2JiZDczNzU0ZGZlNTRmYWMyNGQzNTBjNzg5MzE2ZjE3NDI4Zg==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2008-05-18T22:45:05Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2008-05-18T22:45:05Z"}, "message": "intrinsic.c (char_conversions, ncharconv): New static variables.\n\n\t* intrinsic.c (char_conversions, ncharconv): New static variables.\n\t(find_char_conv): New function.\n\t(add_functions): Add simplification functions for ADJUSTL and\n\tADJUSTR. Don't check the kind of their argument. Add checking for\n\tLGE, LLE, LGT and LLT.\n\t(add_subroutines): Fix argument type for SLEEP. Fix argument name\n\tfor SYSTEM.\n\t(add_char_conversions): New function.\n\t(gfc_intrinsic_init_1): Call add_char_conversions.\n\t(gfc_intrinsic_done_1): Free char_conversions.\n\t(check_arglist): Use kind == 0 as a signal that we don't want\n\tthe kind value to be checked.\n\t(do_simplify): Also simplify character functions.\n\t(gfc_convert_chartype): New function\n\t* trans-array.c (gfc_trans_array_ctor_element): Don't force the\n\tuse of default character type.\n\t(gfc_trans_array_constructor_value): Likewise.\n\t(get_array_ctor_var_strlen): Use integer kind to build an integer\n\tinstead of a character kind!\n\t(gfc_build_constant_array_constructor): Don't force the use of\n\tdefault character type.\n\t(gfc_conv_loop_setup): Likewise.\n\t* trans-expr.c (gfc_conv_string_tmp): Don't force the use of\n\tdefault character type. Allocate enough memory for wide strings.\n\t(gfc_conv_concat_op): Make sure operand kind are the same.\n\t(string_to_single_character): Remove gfc_ prefix. Reindent.\n\tDon't force the use of default character type.\n\t(gfc_conv_scalar_char_value): Likewise.\n\t(gfc_build_compare_string): Call string_to_single_character.\n\t(fill_with_spaces): New function\n\t(gfc_trans_string_copy): Add kind arguments. Use them to deal\n\twith wide character kinds.\n\t(gfc_conv_statement_function): Whitespace fix. Call\n\tgfc_trans_string_copy with new kind arguments.\n\t(gfc_conv_substring_expr): Call gfc_build_wide_string_const\n\tinstead of using gfc_widechar_to_char.\n\t(gfc_conv_string_parameter): Don't force the use of default\n\tcharacter type.\n\t(gfc_trans_scalar_assign): Pass kind args to gfc_trans_string_copy.\n\t* intrinsic.h (gfc_check_lge_lgt_lle_llt, gfc_convert_char_constant,\n\tgfc_resolve_adjustl, gfc_resolve_adjustr): New prototypes.\n\t* decl.c (gfc_set_constant_character_len): Don't assert the\n\texistence of a single character kind.\n\t* trans-array.h (gfc_trans_string_copy): New prototype.\n\t* gfortran.h (gfc_check_character_range, gfc_convert_chartype):\n\tNew prototypes.\n\t* error.c (print_wide_char_into_buffer): New function lifting\n\tcode from gfc_print_wide_char. Fix order to output '\\x??' instead\n\tof 'x\\??'.\n\t(gfc_print_wide_char): Call print_wide_char_into_buffer.\n\t(show_locus): Call print_wide_char_into_buffer with buffer local\n\tto this function.\n\t* trans-const.c (gfc_build_wide_string_const): New function.\n\t(gfc_conv_string_init): Deal with wide characters strings\n\tconstructors.\n\t(gfc_conv_constant_to_tree): Call gfc_build_wide_string_const.\n\t* trans-stmt.c (gfc_trans_label_assign): Likewise.\n\t(gfc_trans_character_select): Deal with wide strings.\n\t* expr.c (gfc_check_assign): Allow conversion between character\n\tkinds on assignment.\n\t* trans-const.h (gfc_build_wide_string_const): New prototype.\n\t* trans-types.c (gfc_get_character_type_len_for_eltype,\n\tgfc_get_character_type_len): Create too variants of the old\n\tgfc_get_character_type_len, one getting kind argument and the\n\tother one directly taking a type tree.\n\t* trans.h (gfor_fndecl_select_string_char4,\n\tgfor_fndecl_convert_char1_to_char4,\n\tgfor_fndecl_convert_char4_to_char1): New prototypes.\n\t* trans-types.h (gfc_get_character_type_len_for_eltype): New\n\tprototype.\n\t* resolve.c (resolve_operator): Exit early when kind mismatches\n\tare detected, because that makes us issue an error message later.\n\t(validate_case_label_expr): Fix wording of error message.\n\t* iresolve.c (gfc_resolve_adjustl, gfc_resolve_adjustr): New\n\tfunctions.\n\t(gfc_resolve_pack): Call _char4 variants of library function\n\twhen dealing with wide characters.\n\t(gfc_resolve_reshape): Likewise.\n\t(gfc_resolve_spread): Likewise.\n\t(gfc_resolve_transpose): Likewise.\n\t(gfc_resolve_unpack): Likewise.\n\t* target-memory.c (size_character): Take character kind bit size\n\tcorrectly into account (not that it changes anything for now, but\n\tit's more generic).\n\t(gfc_encode_character): Added gfc_ prefix. Encoding each\n\tcharacter of a string by calling native_encode_expr for the\n\tcorresponding unsigned integer.\n\t(gfc_target_encode_expr): Add gfc_ prefix to encode_character.\n\t* trans-decl.c (gfc_build_intrinsic_function_decls): Build\n\tgfor_fndecl_select_string_char4, gfor_fndecl_convert_char1_to_char4\n\tand gfor_fndecl_convert_char4_to_char1.\n\t* target-memory.h (gfc_encode_character): New prototype.\n\t* arith.c (gfc_check_character_range): New function.\n\t(eval_intrinsic): Allow non-default character kinds.\n\t* check.c (gfc_check_access_func): Only allow default\n\tcharacter kind arguments.\n\t(gfc_check_chdir): Likewise.\n\t(gfc_check_chdir_sub): Likewise.\n\t(gfc_check_chmod): Likewise.\n\t(gfc_check_chmod_sub): Likewise.\n\t(gfc_check_lge_lgt_lle_llt): New function.\n\t(gfc_check_link): Likewise.\n\t(gfc_check_link_sub): Likewise.\n\t(gfc_check_symlnk): Likewise.\n\t(gfc_check_symlnk_sub): Likewise.\n\t(gfc_check_rename): Likewise.\n\t(gfc_check_rename_sub): Likewise.\n\t(gfc_check_fgetputc_sub): Likewise.\n\t(gfc_check_fgetput_sub): Likewise.\n\t(gfc_check_stat): Likewise.\n\t(gfc_check_stat_sub): Likewise.\n\t(gfc_check_date_and_time): Likewise.\n\t(gfc_check_ctime_sub): Likewise.\n\t(gfc_check_fdate_sub): Likewise.\n\t(gfc_check_gerror): Likewise.\n\t(gfc_check_getcwd_sub): Likewise.\n\t(gfc_check_getarg): Likewise.\n\t(gfc_check_getlog): Likewise.\n\t(gfc_check_hostnm): Likewise.\n\t(gfc_check_hostnm_sub): Likewise.\n\t(gfc_check_ttynam_sub): Likewise.\n\t(gfc_check_perror): Likewise.\n\t(gfc_check_unlink): Likewise.\n\t(gfc_check_unlink_sub): Likewise.\n\t(gfc_check_system_sub): Likewise.\n\t* primary.c (got_delim): Perform correct character range checking\n\tfor all kinds.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_conversion): Generate\n\tcalls to library functions convert_char4_to_char1 and\n\tconvert_char1_to_char4 for character conversions.\n\t(gfc_conv_intrinsic_char): Allow all character kings.\n\t(gfc_conv_intrinsic_strcmp): Fix whitespace.\n\t(gfc_conv_intrinsic_repeat): Take care of all character kinds.\n\t* intrinsic.texi: For all GNU intrinsics accepting character\n\targuments, mention that they're restricted to the default kind.\n\t* simplify.c (simplify_achar_char): New function.\n\t(gfc_simplify_achar, gfc_simplify_char): Call simplify_achar_char.\n\tgfc_simplify_ichar): Don't error out for wide characters.\n\t(gfc_convert_char_constant): New function.\n\n\t* gfortran.dg/achar_3.f90: Adjust error messages.\n\t* gfortran.dg/achar_5.f90: New test.\n\t* gfortran.dg/achar_6.F90: New test.\n\t* gfortran.dg/widechar_1.f90: New test.\n\t* gfortran.dg/widechar_2.f90: New test.\n\t* gfortran.dg/widechar_3.f90: New test.\n\t* gfortran.dg/widechar_4.f90: New test.\n\t* gfortran.dg/widechar_intrinsics_1.f90: New test.\n\t* gfortran.dg/widechar_intrinsics_2.f90: New test.\n\t* gfortran.dg/widechar_intrinsics_3.f90: New test.\n\t* gfortran.dg/widechar_intrinsics_4.f90: New test.\n\t* gfortran.dg/widechar_intrinsics_5.f90: New test.\n\t* gfortran.dg/widechar_select_1.f90: New test.\n\t* gfortran.dg/widechar_select_2.f90: New test.\n\nFrom-SVN: r135515", "tree": {"sha": "8a592f8dffb59a80d1cbd5fbc829a670104539c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a592f8dffb59a80d1cbd5fbc829a670104539c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d393bbd73754dfe54fac24d350c789316f17428f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d393bbd73754dfe54fac24d350c789316f17428f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d393bbd73754dfe54fac24d350c789316f17428f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d393bbd73754dfe54fac24d350c789316f17428f/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45a7844faf66271c1b2491d2931aa761c80c2f90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a7844faf66271c1b2491d2931aa761c80c2f90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45a7844faf66271c1b2491d2931aa761c80c2f90"}], "stats": {"total": 2540, "additions": 2219, "deletions": 321}, "files": [{"sha": "ffbc9c53f20598b38e1a845c424fad29927a12a1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -1,3 +1,145 @@\n+2008-05-18  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* intrinsic.c (char_conversions, ncharconv): New static variables.\n+\t(find_char_conv): New function.\n+\t(add_functions): Add simplification functions for ADJUSTL and\n+\tADJUSTR. Don't check the kind of their argument. Add checking for\n+\tLGE, LLE, LGT and LLT.\n+\t(add_subroutines): Fix argument type for SLEEP. Fix argument name\n+\tfor SYSTEM.\n+\t(add_char_conversions): New function.\n+\t(gfc_intrinsic_init_1): Call add_char_conversions.\n+\t(gfc_intrinsic_done_1): Free char_conversions.\n+\t(check_arglist): Use kind == 0 as a signal that we don't want\n+\tthe kind value to be checked.\n+\t(do_simplify): Also simplify character functions.\n+\t(gfc_convert_chartype): New function\n+\t* trans-array.c (gfc_trans_array_ctor_element): Don't force the\n+\tuse of default character type.\n+\t(gfc_trans_array_constructor_value): Likewise.\n+\t(get_array_ctor_var_strlen): Use integer kind to build an integer\n+\tinstead of a character kind!\n+\t(gfc_build_constant_array_constructor): Don't force the use of\n+\tdefault character type.\n+\t(gfc_conv_loop_setup): Likewise.\n+\t* trans-expr.c (gfc_conv_string_tmp): Don't force the use of\n+\tdefault character type. Allocate enough memory for wide strings.\n+\t(gfc_conv_concat_op): Make sure operand kind are the same.\n+\t(string_to_single_character): Remove gfc_ prefix. Reindent.\n+\tDon't force the use of default character type.\n+\t(gfc_conv_scalar_char_value): Likewise.\n+\t(gfc_build_compare_string): Call string_to_single_character.\n+\t(fill_with_spaces): New function\n+\t(gfc_trans_string_copy): Add kind arguments. Use them to deal\n+\twith wide character kinds.\n+\t(gfc_conv_statement_function): Whitespace fix. Call\n+\tgfc_trans_string_copy with new kind arguments.\n+\t(gfc_conv_substring_expr): Call gfc_build_wide_string_const\n+\tinstead of using gfc_widechar_to_char.\n+\t(gfc_conv_string_parameter): Don't force the use of default\n+\tcharacter type.\n+\t(gfc_trans_scalar_assign): Pass kind args to gfc_trans_string_copy.\n+\t* intrinsic.h (gfc_check_lge_lgt_lle_llt, gfc_convert_char_constant,\n+\tgfc_resolve_adjustl, gfc_resolve_adjustr): New prototypes.\n+\t* decl.c (gfc_set_constant_character_len): Don't assert the\n+\texistence of a single character kind.\n+\t* trans-array.h (gfc_trans_string_copy): New prototype.\n+\t* gfortran.h (gfc_check_character_range, gfc_convert_chartype):\n+\tNew prototypes.\n+\t* error.c (print_wide_char_into_buffer): New function lifting\n+\tcode from gfc_print_wide_char. Fix order to output '\\x??' instead\n+\tof 'x\\??'.\n+\t(gfc_print_wide_char): Call print_wide_char_into_buffer.\n+\t(show_locus): Call print_wide_char_into_buffer with buffer local\n+\tto this function.\n+\t* trans-const.c (gfc_build_wide_string_const): New function.\n+\t(gfc_conv_string_init): Deal with wide characters strings\n+\tconstructors.\n+\t(gfc_conv_constant_to_tree): Call gfc_build_wide_string_const.\n+\t* trans-stmt.c (gfc_trans_label_assign): Likewise.\n+\t(gfc_trans_character_select): Deal with wide strings.\n+\t* expr.c (gfc_check_assign): Allow conversion between character\n+\tkinds on assignment.\n+\t* trans-const.h (gfc_build_wide_string_const): New prototype.\n+\t* trans-types.c (gfc_get_character_type_len_for_eltype,\n+\tgfc_get_character_type_len): Create too variants of the old\n+\tgfc_get_character_type_len, one getting kind argument and the\n+\tother one directly taking a type tree.\n+\t* trans.h (gfor_fndecl_select_string_char4,\n+\tgfor_fndecl_convert_char1_to_char4,\n+\tgfor_fndecl_convert_char4_to_char1): New prototypes.\n+\t* trans-types.h (gfc_get_character_type_len_for_eltype): New\n+\tprototype.\n+\t* resolve.c (resolve_operator): Exit early when kind mismatches\n+\tare detected, because that makes us issue an error message later.\n+\t(validate_case_label_expr): Fix wording of error message.\n+\t* iresolve.c (gfc_resolve_adjustl, gfc_resolve_adjustr): New\n+\tfunctions.\n+\t(gfc_resolve_pack): Call _char4 variants of library function\n+\twhen dealing with wide characters.\n+\t(gfc_resolve_reshape): Likewise.\n+\t(gfc_resolve_spread): Likewise.\n+\t(gfc_resolve_transpose): Likewise.\n+\t(gfc_resolve_unpack): Likewise.\n+\t* target-memory.c (size_character): Take character kind bit size\n+\tcorrectly into account (not that it changes anything for now, but\n+\tit's more generic).\n+\t(gfc_encode_character): Added gfc_ prefix. Encoding each\n+\tcharacter of a string by calling native_encode_expr for the\n+\tcorresponding unsigned integer.\n+\t(gfc_target_encode_expr): Add gfc_ prefix to encode_character.\n+\t* trans-decl.c (gfc_build_intrinsic_function_decls): Build\n+\tgfor_fndecl_select_string_char4, gfor_fndecl_convert_char1_to_char4\n+\tand gfor_fndecl_convert_char4_to_char1.\n+\t* target-memory.h (gfc_encode_character): New prototype.\n+\t* arith.c (gfc_check_character_range): New function.\n+\t(eval_intrinsic): Allow non-default character kinds.\n+\t* check.c (gfc_check_access_func): Only allow default\n+\tcharacter kind arguments.\n+\t(gfc_check_chdir): Likewise.\n+\t(gfc_check_chdir_sub): Likewise.\n+\t(gfc_check_chmod): Likewise.\n+\t(gfc_check_chmod_sub): Likewise.\n+\t(gfc_check_lge_lgt_lle_llt): New function.\n+\t(gfc_check_link): Likewise.\n+\t(gfc_check_link_sub): Likewise.\n+\t(gfc_check_symlnk): Likewise.\n+\t(gfc_check_symlnk_sub): Likewise.\n+\t(gfc_check_rename): Likewise.\n+\t(gfc_check_rename_sub): Likewise.\n+\t(gfc_check_fgetputc_sub): Likewise.\n+\t(gfc_check_fgetput_sub): Likewise.\n+\t(gfc_check_stat): Likewise.\n+\t(gfc_check_stat_sub): Likewise.\n+\t(gfc_check_date_and_time): Likewise.\n+\t(gfc_check_ctime_sub): Likewise.\n+\t(gfc_check_fdate_sub): Likewise.\n+\t(gfc_check_gerror): Likewise.\n+\t(gfc_check_getcwd_sub): Likewise.\n+\t(gfc_check_getarg): Likewise.\n+\t(gfc_check_getlog): Likewise.\n+\t(gfc_check_hostnm): Likewise.\n+\t(gfc_check_hostnm_sub): Likewise.\n+\t(gfc_check_ttynam_sub): Likewise.\n+\t(gfc_check_perror): Likewise.\n+\t(gfc_check_unlink): Likewise.\n+\t(gfc_check_unlink_sub): Likewise.\n+\t(gfc_check_system_sub): Likewise.\n+\t* primary.c (got_delim): Perform correct character range checking\n+\tfor all kinds.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_conversion): Generate\n+\tcalls to library functions convert_char4_to_char1 and\n+\tconvert_char1_to_char4 for character conversions.\n+\t(gfc_conv_intrinsic_char): Allow all character kings.\n+\t(gfc_conv_intrinsic_strcmp): Fix whitespace.\n+\t(gfc_conv_intrinsic_repeat): Take care of all character kinds.\n+\t* intrinsic.texi: For all GNU intrinsics accepting character\n+\targuments, mention that they're restricted to the default kind.\n+\t* simplify.c (simplify_achar_char): New function.\n+\t(gfc_simplify_achar, gfc_simplify_char): Call simplify_achar_char.\n+\tgfc_simplify_ichar): Don't error out for wide characters.\n+\t(gfc_convert_char_constant): New function.\n+\n 2008-05-18  Steven G. Kargl  <kargls@comcast.net>\n \n \tPR fortran/36251"}, {"sha": "6e09f8a3e1e26ad8a6984b78a26914c18723f62a", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -280,6 +280,23 @@ gfc_arith_done_1 (void)\n }\n \n \n+/* Given a wide character value and a character kind, determine whether\n+   the character is representable for that kind.  */\n+bool\n+gfc_check_character_range (gfc_char_t c, int kind)\n+{\n+  /* As wide characters are stored as 32-bit values, they're all\n+     representable in UCS=4.  */\n+  if (kind == 4)\n+    return true;\n+\n+  if (kind == 1)\n+    return c <= 255 ? true : false;\n+\n+  gcc_unreachable ();\n+}\n+\n+\n /* Given an integer and a kind, make sure that the integer lies within\n    the range of the kind.  Returns ARITH_OK, ARITH_ASYMMETRIC or\n    ARITH_OVERFLOW.  */\n@@ -1655,6 +1672,11 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \t  unary = 0;\n \t  temp.ts.type = BT_LOGICAL;\n \t  temp.ts.kind = gfc_default_logical_kind;\n+\n+\t  /* If kind mismatch, exit and we'll error out later.  */\n+\t  if (op1->ts.kind != op2->ts.kind)\n+\t    goto runtime;\n+\n \t  break;\n \t}\n \n@@ -1696,11 +1718,12 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \n     /* Character binary  */\n     case INTRINSIC_CONCAT:\n-      if (op1->ts.type != BT_CHARACTER || op2->ts.type != BT_CHARACTER)\n+      if (op1->ts.type != BT_CHARACTER || op2->ts.type != BT_CHARACTER\n+\t  || op1->ts.kind != op2->ts.kind)\n \tgoto runtime;\n \n       temp.ts.type = BT_CHARACTER;\n-      temp.ts.kind = gfc_default_character_kind;\n+      temp.ts.kind = op1->ts.kind;\n       unary = 0;\n       break;\n "}, {"sha": "87d962e50a78c2c0d05a63305070a36bfb86814f", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 97, "deletions": 2, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -492,10 +492,14 @@ gfc_check_access_func (gfc_expr *name, gfc_expr *mode)\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE\n       || scalar_check (name, 0) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (name, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (type_check (mode, 1, BT_CHARACTER) == FAILURE\n       || scalar_check (mode, 1) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (mode, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -716,6 +720,8 @@ gfc_check_chdir (gfc_expr *dir)\n {\n   if (type_check (dir, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (dir, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -726,13 +732,14 @@ gfc_check_chdir_sub (gfc_expr *dir, gfc_expr *status)\n {\n   if (type_check (dir, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (dir, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (status == NULL)\n     return SUCCESS;\n \n   if (type_check (status, 1, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-\n   if (scalar_check (status, 1) == FAILURE)\n     return FAILURE;\n \n@@ -745,9 +752,13 @@ gfc_check_chmod (gfc_expr *name, gfc_expr *mode)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (name, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (type_check (mode, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (mode, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -758,9 +769,13 @@ gfc_check_chmod_sub (gfc_expr *name, gfc_expr *mode, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (name, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (type_check (mode, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (mode, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (status == NULL)\n     return SUCCESS;\n@@ -1496,14 +1511,35 @@ gfc_check_len_lentrim (gfc_expr *s, gfc_expr *kind)\n }\n \n \n+try\n+gfc_check_lge_lgt_lle_llt (gfc_expr *a, gfc_expr *b)\n+{\n+  if (type_check (a, 0, BT_CHARACTER) == FAILURE)\n+    return FAILURE;\n+  if (kind_value_check (a, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (b, 1, BT_CHARACTER) == FAILURE)\n+    return FAILURE;\n+  if (kind_value_check (b, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n try\n gfc_check_link (gfc_expr *path1, gfc_expr *path2)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path1, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (type_check (path2, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path2, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -1514,9 +1550,13 @@ gfc_check_link_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path1, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (type_check (path2, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path2, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (status == NULL)\n     return SUCCESS;\n@@ -1543,9 +1583,13 @@ gfc_check_symlnk (gfc_expr *path1, gfc_expr *path2)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path1, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (type_check (path2, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path2, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -1556,9 +1600,13 @@ gfc_check_symlnk_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path1, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (type_check (path2, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path2, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (status == NULL)\n     return SUCCESS;\n@@ -2166,9 +2214,13 @@ gfc_check_rename (gfc_expr *path1, gfc_expr *path2)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path1, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (type_check (path2, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path2, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -2179,9 +2231,13 @@ gfc_check_rename_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path1, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (type_check (path2, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (path2, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (status == NULL)\n     return SUCCESS;\n@@ -2535,6 +2591,8 @@ gfc_check_fgetputc_sub (gfc_expr *unit, gfc_expr *c, gfc_expr *status)\n \n   if (type_check (c, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (c, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (status == NULL)\n     return SUCCESS;\n@@ -2560,6 +2618,8 @@ gfc_check_fgetput_sub (gfc_expr *c, gfc_expr *status)\n {\n   if (type_check (c, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (c, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (status == NULL)\n     return SUCCESS;\n@@ -2705,6 +2765,8 @@ gfc_check_stat (gfc_expr *name, gfc_expr *array)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (name, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (type_check (array, 1, BT_INTEGER) == FAILURE\n       || kind_value_check (array, 1, gfc_default_integer_kind) == FAILURE)\n@@ -2722,6 +2784,8 @@ gfc_check_stat_sub (gfc_expr *name, gfc_expr *array, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (name, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (type_check (array, 1, BT_INTEGER) == FAILURE\n       || kind_value_check (array, 1, gfc_default_integer_kind) == FAILURE)\n@@ -2914,6 +2978,8 @@ gfc_check_date_and_time (gfc_expr *date, gfc_expr *time,\n     {\n       if (type_check (date, 0, BT_CHARACTER) == FAILURE)\n \treturn FAILURE;\n+      if (kind_value_check (date, 0, gfc_default_character_kind) == FAILURE)\n+\treturn FAILURE;\n       if (scalar_check (date, 0) == FAILURE)\n \treturn FAILURE;\n       if (variable_check (date, 0) == FAILURE)\n@@ -2924,6 +2990,8 @@ gfc_check_date_and_time (gfc_expr *date, gfc_expr *time,\n     {\n       if (type_check (time, 1, BT_CHARACTER) == FAILURE)\n \treturn FAILURE;\n+      if (kind_value_check (time, 1, gfc_default_character_kind) == FAILURE)\n+\treturn FAILURE;\n       if (scalar_check (time, 1) == FAILURE)\n \treturn FAILURE;\n       if (variable_check (time, 1) == FAILURE)\n@@ -2934,6 +3002,8 @@ gfc_check_date_and_time (gfc_expr *date, gfc_expr *time,\n     {\n       if (type_check (zone, 2, BT_CHARACTER) == FAILURE)\n \treturn FAILURE;\n+      if (kind_value_check (zone, 2, gfc_default_character_kind) == FAILURE)\n+\treturn FAILURE;\n       if (scalar_check (zone, 2) == FAILURE)\n \treturn FAILURE;\n       if (variable_check (zone, 2) == FAILURE)\n@@ -3246,12 +3316,13 @@ gfc_check_ctime_sub (gfc_expr *time, gfc_expr *result)\n {\n   if (scalar_check (time, 0) == FAILURE)\n     return FAILURE;\n-\n   if (type_check (time, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n   if (type_check (result, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (result, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -3315,6 +3386,8 @@ gfc_check_fdate_sub (gfc_expr *date)\n {\n   if (type_check (date, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (date, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -3325,6 +3398,8 @@ gfc_check_gerror (gfc_expr *msg)\n {\n   if (type_check (msg, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (msg, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -3335,6 +3410,8 @@ gfc_check_getcwd_sub (gfc_expr *cwd, gfc_expr *status)\n {\n   if (type_check (cwd, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (cwd, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (status == NULL)\n     return SUCCESS;\n@@ -3366,6 +3443,8 @@ gfc_check_getarg (gfc_expr *pos, gfc_expr *value)\n \n   if (type_check (value, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (value, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -3376,6 +3455,8 @@ gfc_check_getlog (gfc_expr *msg)\n {\n   if (type_check (msg, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (msg, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -3431,6 +3512,8 @@ gfc_check_hostnm (gfc_expr *name)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (name, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -3441,6 +3524,8 @@ gfc_check_hostnm_sub (gfc_expr *name, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (name, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (status == NULL)\n     return SUCCESS;\n@@ -3519,6 +3604,8 @@ gfc_check_ttynam_sub (gfc_expr *unit, gfc_expr *name)\n \n   if (type_check (name, 1, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (name, 1, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -3555,6 +3642,8 @@ gfc_check_perror (gfc_expr *string)\n {\n   if (type_check (string, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (string, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -3600,6 +3689,8 @@ gfc_check_unlink (gfc_expr *name)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (name, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -3610,6 +3701,8 @@ gfc_check_unlink_sub (gfc_expr *name, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (name, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (status == NULL)\n     return SUCCESS;\n@@ -3686,6 +3779,8 @@ gfc_check_system_sub (gfc_expr *cmd, gfc_expr *status)\n {\n   if (type_check (cmd, 0, BT_CHARACTER) == FAILURE)\n     return FAILURE;\n+  if (kind_value_check (cmd, 0, gfc_default_character_kind) == FAILURE)\n+    return FAILURE;\n \n   if (scalar_check (status, 1) == FAILURE)\n     return FAILURE;"}, {"sha": "79044eb18463780756c9b8eaf2d75e0a6fd37a8c", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -1093,7 +1093,7 @@ gfc_set_constant_character_len (int len, gfc_expr *expr, bool array)\n   int slen;\n \n   gcc_assert (expr->expr_type == EXPR_CONSTANT);\n-  gcc_assert (expr->ts.type == BT_CHARACTER && expr->ts.kind == 1);\n+  gcc_assert (expr->ts.type == BT_CHARACTER);\n \n   slen = expr->value.character.length;\n   if (len != slen)"}, {"sha": "c34899f1337267b30cd36efb79e49d659d82b28b", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -152,14 +152,11 @@ error_integer (long int i)\n }\n \n \n-static char wide_char_print_buffer[11];\n-\n-const char *\n-gfc_print_wide_char (gfc_char_t c)\n+static void\n+print_wide_char_into_buffer (gfc_char_t c, char *buf)\n {\n   static const char xdigit[16] = { '0', '1', '2', '3', '4', '5', '6',\n     '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n-  char *buf = wide_char_print_buffer;\n \n   if (gfc_wide_is_printable (c))\n     {\n@@ -173,8 +170,8 @@ gfc_print_wide_char (gfc_char_t c)\n       c = c >> 4;\n       buf[2] = xdigit[c & 0x0F];\n \n-      buf[1] = '\\\\';\n-      buf[0] = 'x';\n+      buf[1] = 'x';\n+      buf[0] = '\\\\';\n     }\n   else if (c < ((gfc_char_t) 1 << 16))\n     {\n@@ -187,8 +184,8 @@ gfc_print_wide_char (gfc_char_t c)\n       c = c >> 4;\n       buf[2] = xdigit[c & 0x0F];\n \n-      buf[1] = '\\\\';\n-      buf[0] = 'u';\n+      buf[1] = 'u';\n+      buf[0] = '\\\\';\n     }\n   else\n     {\n@@ -209,13 +206,21 @@ gfc_print_wide_char (gfc_char_t c)\n       c = c >> 4;\n       buf[2] = xdigit[c & 0x0F];\n \n-      buf[1] = '\\\\';\n-      buf[0] = 'U';\n+      buf[1] = 'U';\n+      buf[0] = '\\\\';\n     }\n+}\n \n-  return buf;\n+static char wide_char_print_buffer[11];\n+\n+const char *\n+gfc_print_wide_char (gfc_char_t c)\n+{\n+  print_wide_char_into_buffer (c, wide_char_print_buffer);\n+  return wide_char_print_buffer;\n }\n \n+\n /* Show the file, where it was included, and the source line, give a\n    locus.  Calls error_printf() recursively, but the recursion is at\n    most one level deep.  */\n@@ -317,11 +322,14 @@ show_locus (locus *loc, int c1, int c2)\n \n   for (; i > 0; i--)\n     {\n+      static char buffer[11];\n+\n       c = *p++;\n       if (c == '\\t')\n \tc = ' ';\n \n-      error_string (gfc_print_wide_char (c));\n+      print_wide_char_into_buffer (c, buffer);\n+      error_string (buffer);\n     }\n \n   error_char ('\\n');"}, {"sha": "a8727430221fec5e1d59c7d0cf76d1f9a99bc200", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -2847,6 +2847,16 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n       return FAILURE;\n     }\n \n+  /* Assignment is the only case where character variables of different\n+     kind values can be converted into one another.  */\n+  if (lvalue->ts.type == BT_CHARACTER && rvalue->ts.type == BT_CHARACTER)\n+    {\n+      if (lvalue->ts.kind != rvalue->ts.kind)\n+\tgfc_convert_chartype (rvalue, &lvalue->ts);\n+\n+      return SUCCESS;\n+    }\n+\n   return gfc_convert_type (rvalue, &lvalue->ts, 1);\n }\n "}, {"sha": "e3a9446333e39bb06c3feabd8baeb64360aa28c7", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -2069,6 +2069,7 @@ void gfc_arith_init_1 (void);\n void gfc_arith_done_1 (void);\n gfc_expr *gfc_enum_initializer (gfc_expr *, locus);\n arith gfc_check_integer_range (mpz_t p, int kind);\n+bool gfc_check_character_range (gfc_char_t, int);\n \n /* trans-types.c */\n try gfc_validate_c_kind (gfc_typespec *);\n@@ -2225,6 +2226,7 @@ char gfc_type_letter (bt);\n gfc_symbol * gfc_get_intrinsic_sub_symbol (const char *);\n try gfc_convert_type (gfc_expr *, gfc_typespec *, int);\n try gfc_convert_type_warn (gfc_expr *, gfc_typespec *, int, int);\n+try gfc_convert_chartype (gfc_expr *, gfc_typespec *);\n int gfc_generic_intrinsic (const char *);\n int gfc_specific_intrinsic (const char *);\n int gfc_intrinsic_name (const char *, int);"}, {"sha": "e902f693f6b436649fd670f8f508da7c5e04002f", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 159, "deletions": 20, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -39,9 +39,10 @@ const char *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n locus *gfc_current_intrinsic_where;\n \n static gfc_intrinsic_sym *functions, *subroutines, *conversion, *next_sym;\n+static gfc_intrinsic_sym *char_conversions;\n static gfc_intrinsic_arg *next_arg;\n \n-static int nfunc, nsub, nargs, nconv;\n+static int nfunc, nsub, nargs, nconv, ncharconv;\n \n static enum\n { SZ_NOTHING = 0, SZ_SUBS, SZ_FUNCS, SZ_CONVS }\n@@ -148,6 +149,28 @@ find_conv (gfc_typespec *from, gfc_typespec *to)\n }\n \n \n+/* Given a pair of CHARACTER typespecs, find the gfc_intrinsic_sym node\n+   that corresponds to the conversion.  Returns NULL if the conversion\n+   isn't found.  */\n+\n+static gfc_intrinsic_sym *\n+find_char_conv (gfc_typespec *from, gfc_typespec *to)\n+{\n+  gfc_intrinsic_sym *sym;\n+  const char *target;\n+  int i;\n+\n+  target = conv_name (from, to);\n+  sym = char_conversions;\n+\n+  for (i = 0; i < ncharconv; i++, sym++)\n+    if (target == sym->name)\n+      return sym;\n+\n+  return NULL;\n+}\n+\n+\n /* Interface to the check functions.  We break apart an argument list\n    and call the proper check function rather than forcing each\n    function to manipulate the argument list.  */\n@@ -974,15 +997,15 @@ add_functions (void)\n \n   make_generic (\"acosh\", GFC_ISYM_ACOSH, GFC_STD_F2008);\n \n-  add_sym_1 (\"adjustl\", GFC_ISYM_ADJUSTL, CLASS_ELEMENTAL, ACTUAL_NO, BT_CHARACTER, dc, GFC_STD_F95,\n-\t     NULL, gfc_simplify_adjustl, NULL,\n-\t     stg, BT_CHARACTER, dc, REQUIRED);\n+  add_sym_1 (\"adjustl\", GFC_ISYM_ADJUSTL, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_CHARACTER, dc, GFC_STD_F95, NULL, gfc_simplify_adjustl,\n+\t     gfc_resolve_adjustl, stg, BT_CHARACTER, 0, REQUIRED);\n \n   make_generic (\"adjustl\", GFC_ISYM_ADJUSTL, GFC_STD_F95);\n \n-  add_sym_1 (\"adjustr\", GFC_ISYM_ADJUSTR, CLASS_ELEMENTAL, ACTUAL_NO, BT_CHARACTER, dc, GFC_STD_F95,\n-\t     NULL, gfc_simplify_adjustr, NULL,\n-\t     stg, BT_CHARACTER, dc, REQUIRED);\n+  add_sym_1 (\"adjustr\", GFC_ISYM_ADJUSTR, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_CHARACTER, dc, GFC_STD_F95, NULL, gfc_simplify_adjustr,\n+\t     gfc_resolve_adjustr, stg, BT_CHARACTER, 0, REQUIRED);\n \n   make_generic (\"adjustr\", GFC_ISYM_ADJUSTR, GFC_STD_F95);\n \n@@ -1760,26 +1783,26 @@ add_functions (void)\n   make_generic (\"log_gamma\", GFC_ISYM_LGAMMA, GFC_STD_F2008);\n \n \n-  add_sym_2 (\"lge\", GFC_ISYM_LGE, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL, dl, GFC_STD_F77,\n-\t     NULL, gfc_simplify_lge, NULL,\n+  add_sym_2 (\"lge\", GFC_ISYM_LGE, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL, dl,\n+\t     GFC_STD_F77, gfc_check_lge_lgt_lle_llt, gfc_simplify_lge, NULL,\n \t     sta, BT_CHARACTER, dc, REQUIRED, stb, BT_CHARACTER, dc, REQUIRED);\n \n   make_generic (\"lge\", GFC_ISYM_LGE, GFC_STD_F77);\n \n-  add_sym_2 (\"lgt\", GFC_ISYM_LGT, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL, dl, GFC_STD_F77,\n-\t     NULL, gfc_simplify_lgt, NULL,\n+  add_sym_2 (\"lgt\", GFC_ISYM_LGT, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL, dl,\n+\t     GFC_STD_F77, gfc_check_lge_lgt_lle_llt, gfc_simplify_lgt, NULL,\n \t     sta, BT_CHARACTER, dc, REQUIRED, stb, BT_CHARACTER, dc, REQUIRED);\n \n   make_generic (\"lgt\", GFC_ISYM_LGT, GFC_STD_F77);\n \n-  add_sym_2 (\"lle\",GFC_ISYM_LLE,  CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL, dl, GFC_STD_F77,\n-\t     NULL, gfc_simplify_lle, NULL,\n+  add_sym_2 (\"lle\",GFC_ISYM_LLE,  CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL, dl,\n+\t     GFC_STD_F77, gfc_check_lge_lgt_lle_llt, gfc_simplify_lle, NULL,\n \t     sta, BT_CHARACTER, dc, REQUIRED, stb, BT_CHARACTER, dc, REQUIRED);\n \n   make_generic (\"lle\", GFC_ISYM_LLE, GFC_STD_F77);\n \n-  add_sym_2 (\"llt\", GFC_ISYM_LLT, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL, dl, GFC_STD_F77,\n-\t     NULL, gfc_simplify_llt, NULL,\n+  add_sym_2 (\"llt\", GFC_ISYM_LLT, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL, dl,\n+\t     GFC_STD_F77, gfc_check_lge_lgt_lle_llt, gfc_simplify_llt, NULL,\n \t     sta, BT_CHARACTER, dc, REQUIRED, stb, BT_CHARACTER, dc, REQUIRED);\n \n   make_generic (\"llt\", GFC_ISYM_LLT, GFC_STD_F77);\n@@ -2625,7 +2648,7 @@ add_subroutines (void)\n \n   add_sym_1s (\"sleep\", GFC_ISYM_SLEEP, NO_CLASS, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      gfc_check_sleep_sub, NULL, gfc_resolve_sleep_sub,\n-\t      val, BT_CHARACTER, dc, REQUIRED);\n+\t      val, BT_INTEGER, di, REQUIRED);\n \n   add_sym_3s (\"fstat\", GFC_ISYM_FSTAT, NO_CLASS, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      gfc_check_fstat_sub, NULL, gfc_resolve_fstat_sub,\n@@ -2654,7 +2677,7 @@ add_subroutines (void)\n \n   add_sym_2s (\"system\", GFC_ISYM_SYSTEM, NO_CLASS, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      NULL, NULL, gfc_resolve_system_sub,\n-\t      c, BT_CHARACTER, dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n+\t      com, BT_CHARACTER, dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_3s (\"system_clock\", GFC_ISYM_SYSTEM_CLOCK, NO_CLASS, BT_UNKNOWN, 0, GFC_STD_F95,\n \t      gfc_check_system_clock, NULL, gfc_resolve_system_clock,\n@@ -2817,6 +2840,52 @@ add_conversions (void)\n }\n \n \n+static void\n+add_char_conversions (void)\n+{\n+  int n, i, j;\n+\n+  /* Count possible conversions.  */\n+  for (i = 0; gfc_character_kinds[i].kind != 0; i++)\n+    for (j = 0; gfc_character_kinds[j].kind != 0; j++)\n+      if (i != j)\n+\tncharconv++;\n+\n+  /* Allocate memory.  */\n+  char_conversions = gfc_getmem (sizeof (gfc_intrinsic_sym) * ncharconv);\n+\n+  /* Add the conversions themselves.  */\n+  n = 0;\n+  for (i = 0; gfc_character_kinds[i].kind != 0; i++)\n+    for (j = 0; gfc_character_kinds[j].kind != 0; j++)\n+      {\n+\tgfc_typespec from, to;\n+\n+\tif (i == j)\n+\t  continue;\n+\n+\tgfc_clear_ts (&from);\n+\tfrom.type = BT_CHARACTER;\n+\tfrom.kind = gfc_character_kinds[i].kind;\n+\n+\tgfc_clear_ts (&to);\n+\tto.type = BT_CHARACTER;\n+\tto.kind = gfc_character_kinds[j].kind;\n+\n+\tchar_conversions[n].name = conv_name (&from, &to);\n+\tchar_conversions[n].lib_name = char_conversions[n].name;\n+\tchar_conversions[n].simplify.cc = gfc_convert_char_constant;\n+\tchar_conversions[n].standard = GFC_STD_F2003;\n+\tchar_conversions[n].elemental = 1;\n+\tchar_conversions[n].conversion = 0;\n+\tchar_conversions[n].ts = to;\n+\tchar_conversions[n].id = GFC_ISYM_CONVERSION;\n+\n+\tn++;\n+      }\n+}\n+\n+\n /* Initialize the table of intrinsics.  */\n void\n gfc_intrinsic_init_1 (void)\n@@ -2852,6 +2921,9 @@ gfc_intrinsic_init_1 (void)\n   add_subroutines ();\n   add_conversions ();\n \n+  /* Character conversion intrinsics need to be treated separately.  */\n+  add_char_conversions ();\n+\n   /* Set the pure flag.  All intrinsic functions are pure, and\n      intrinsic subroutines are pure if they are elemental.  */\n \n@@ -2868,6 +2940,7 @@ gfc_intrinsic_done_1 (void)\n {\n   gfc_free (functions);\n   gfc_free (conversion);\n+  gfc_free (char_conversions);\n   gfc_free_namespace (gfc_intrinsic_namespace);\n }\n \n@@ -3052,10 +3125,18 @@ check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n   i = 0;\n   for (; formal; formal = formal->next, actual = actual->next, i++)\n     {\n+      gfc_typespec ts;\n+\n       if (actual->expr == NULL)\n \tcontinue;\n \n-      if (!gfc_compare_types (&formal->ts, &actual->expr->ts))\n+      ts = formal->ts;\n+\n+      /* A kind of 0 means we don't check for kind.  */\n+      if (ts.kind == 0)\n+\tts.kind = actual->expr->ts.kind;\n+\n+      if (!gfc_compare_types (&ts, &actual->expr->ts))\n \t{\n \t  if (error_flag)\n \t    gfc_error (\"Type of argument '%s' in call to '%s' at %L should \"\n@@ -3199,9 +3280,10 @@ do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)\n   a1 = arg->expr;\n   arg = arg->next;\n \n-  if (specific->simplify.cc == gfc_convert_constant)\n+  if (specific->simplify.cc == gfc_convert_constant\n+      || specific->simplify.cc == gfc_convert_char_constant)\n     {\n-      result = gfc_convert_constant (a1, specific->ts.type, specific->ts.kind);\n+      result = specific->simplify.cc (a1, specific->ts.type, specific->ts.kind);\n       goto finish;\n     }\n \n@@ -3687,3 +3769,60 @@ gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)\n \t\t      &expr->where);\n   /* Not reached */\n }\n+\n+\n+try\n+gfc_convert_chartype (gfc_expr *expr, gfc_typespec *ts)\n+{\n+  gfc_intrinsic_sym *sym;\n+  gfc_typespec from_ts;\n+  locus old_where;\n+  gfc_expr *new;\n+  int rank;\n+  mpz_t *shape;\n+\n+  gcc_assert (expr->ts.type == BT_CHARACTER && ts->type == BT_CHARACTER);\n+  from_ts = expr->ts;\t\t/* expr->ts gets clobbered */\n+\n+  sym = find_char_conv (&expr->ts, ts);\n+  gcc_assert (sym);\n+\n+  /* Insert a pre-resolved function call to the right function.  */\n+  old_where = expr->where;\n+  rank = expr->rank;\n+  shape = expr->shape;\n+\n+  new = gfc_get_expr ();\n+  *new = *expr;\n+\n+  new = gfc_build_conversion (new);\n+  new->value.function.name = sym->lib_name;\n+  new->value.function.isym = sym;\n+  new->where = old_where;\n+  new->rank = rank;\n+  new->shape = gfc_copy_shape (shape, rank);\n+\n+  gfc_get_ha_sym_tree (sym->name, &new->symtree);\n+  new->symtree->n.sym->ts = *ts;\n+  new->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  new->symtree->n.sym->attr.function = 1;\n+  new->symtree->n.sym->attr.elemental = 1;\n+  new->symtree->n.sym->attr.pure = 1;\n+  new->symtree->n.sym->attr.referenced = 1;\n+  gfc_intrinsic_symbol(new->symtree->n.sym);\n+  gfc_commit_symbol (new->symtree->n.sym);\n+\n+  *expr = *new;\n+\n+  gfc_free (new);\n+  expr->ts = *ts;\n+\n+  if (gfc_is_constant_expr (expr->value.function.actual->expr)\n+      && do_simplify (sym, expr) == FAILURE)\n+    {\n+      /* Error already generated in do_simplify() */\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}"}, {"sha": "e280c50d78fce2225a41596ba13b6462d75be68e", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -91,6 +91,7 @@ try gfc_check_kind (gfc_expr *);\n try gfc_check_lbound (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_len_lentrim (gfc_expr *, gfc_expr *);\n try gfc_check_link (gfc_expr *, gfc_expr *);\n+try gfc_check_lge_lgt_lle_llt (gfc_expr *, gfc_expr *);\n try gfc_check_loc (gfc_expr *);\n try gfc_check_logical (gfc_expr *, gfc_expr *);\n try gfc_check_min_max (gfc_actual_arglist *);\n@@ -317,11 +318,14 @@ gfc_expr *gfc_simplify_xor (gfc_expr *, gfc_expr *);\n \n /* Constant conversion simplification.  */\n gfc_expr *gfc_convert_constant (gfc_expr *, bt, int);\n+gfc_expr *gfc_convert_char_constant (gfc_expr *, bt, int);\n \n \n /* Resolution functions.  */\n void gfc_resolve_abs (gfc_expr *, gfc_expr *);\n void gfc_resolve_access (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_adjustl (gfc_expr *, gfc_expr *);\n+void gfc_resolve_adjustr (gfc_expr *, gfc_expr *);\n void gfc_resolve_achar (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_acos (gfc_expr *, gfc_expr *);\n void gfc_resolve_acosh (gfc_expr *, gfc_expr *);"}, {"sha": "6852d64387e141d4d1bc4c9c255af7fd1954b0b7", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 75, "deletions": 51, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -428,13 +428,14 @@ Inquiry function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{NAME} @tab Scalar @code{CHARACTER} with the file name.\n-Tailing blank are ignored unless the character @code{achar(0)} is\n-present, then all characters up to and excluding @code{achar(0)} are\n+@item @var{NAME} @tab Scalar @code{CHARACTER} of default kind with the\n+file name. Tailing blank are ignored unless the character @code{achar(0)}\n+is present, then all characters up to and excluding @code{achar(0)} are\n used as file name.\n-@item @var{MODE} @tab Scalar @code{CHARACTER} with the file access mode,\n-may be any concatenation of @code{\"r\"} (readable), @code{\"w\"} (writable)\n-and @code{\"x\"} (executable), or @code{\" \"} to check for existence.\n+@item @var{MODE} @tab Scalar @code{CHARACTER} of default kind with the\n+file access mode, may be any concatenation of @code{\"r\"} (readable),\n+@code{\"w\"} (writable) and @code{\"x\"} (executable), or @code{\" \"} to check\n+for existence.\n @end multitable\n \n @item @emph{Return value}:\n@@ -644,9 +645,9 @@ Elemental function\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{CHARACTER} where leading spaces \n-are removed and the same number of spaces are inserted on the end\n-of @var{STR}. The return value has the same kind as @var{STRING}.\n+The return value is of type @code{CHARACTER} and of the same kind as\n+@var{STRING} where leading spaces are removed and the same number of\n+spaces are inserted on the end of @var{STRING}.\n \n @item @emph{Example}:\n @smallexample\n@@ -689,9 +690,9 @@ Elemental function\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{CHARACTER} where trailing spaces \n-are removed and the same number of spaces are inserted at the start\n-of @var{STR}. The return value has the same kind as @var{STRING}.\n+The return value is of type @code{CHARACTER} and of the same kind as\n+@var{STRING} where trailing spaces are removed and the same number of\n+spaces are inserted at the start of @var{STRING}.\n \n @item @emph{Example}:\n @smallexample\n@@ -2262,8 +2263,9 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{NAME}   @tab The type shall be @code{CHARACTER} and shall\n-                        specify a valid path within the file system.\n+@item @var{NAME}   @tab The type shall be @code{CHARACTER} of default\n+                        kind and shall specify a valid path within the\n+\t\t\tfile system.\n @item @var{STATUS} @tab (Optional) @code{INTEGER} status flag of the default\n                         kind.  Returns 0 on success, and a system specific\n                         and nonzero error code otherwise.\n@@ -2314,14 +2316,15 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{NAME} @tab Scalar @code{CHARACTER} with the file name.\n-Trailing blanks are ignored unless the character @code{achar(0)} is\n-present, then all characters up to and excluding @code{achar(0)} are\n-used as the file name.\n \n-@item @var{MODE} @tab Scalar @code{CHARACTER} giving the file permission.\n-@var{MODE} uses the same syntax as the @var{MODE} argument of\n-@code{/bin/chmod}.\n+@item @var{NAME} @tab Scalar @code{CHARACTER} of default kind with the\n+file name. Trailing blanks are ignored unless the character\n+@code{achar(0)} is present, then all characters up to and excluding\n+@code{achar(0)} are used as the file name.\n+\n+@item @var{MODE} @tab Scalar @code{CHARACTER} of default kind giving the\n+file permission. @var{MODE} uses the same syntax as the @var{MODE}\n+argument of @code{/bin/chmod}.\n \n @item @var{STATUS} @tab (optional) scalar @code{INTEGER}, which is\n @code{0} on success and nonzero otherwise.\n@@ -2873,7 +2876,8 @@ Subroutine, function\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{TIME}    @tab The type shall be of type @code{INTEGER(KIND=8)}.\n-@item @var{RESULT}  @tab The type shall be of type @code{CHARACTER}.\n+@item @var{RESULT}  @tab The type shall be of type @code{CHARACTER} and\n+                         of default kind.\n @end multitable\n \n @item @emph{Return value}:\n@@ -2940,9 +2944,12 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{DATE}  @tab (Optional) The type shall be @code{CHARACTER(8)} or larger.\n-@item @var{TIME}  @tab (Optional) The type shall be @code{CHARACTER(10)} or larger.\n-@item @var{ZONE}  @tab (Optional) The type shall be @code{CHARACTER(5)} or larger.\n+@item @var{DATE}  @tab (Optional) The type shall be @code{CHARACTER(LEN=8)}\n+                                  or larger, and of default kind.\n+@item @var{TIME}  @tab (Optional) The type shall be @code{CHARACTER(LEN=10)}\n+                                  or larger, and of default kind.\n+@item @var{ZONE}  @tab (Optional) The type shall be @code{CHARACTER(LEN=5)}\n+                                  or larger, and of default kind.\n @item @var{VALUES}@tab (Optional) The type shall be @code{INTEGER(8)}.\n @end multitable\n \n@@ -3887,7 +3894,8 @@ TIME())}.\n This intrinsic is provided in both subroutine and function forms; however,\n only one form can be used in any given program unit.\n \n-@var{DATE} is an @code{INTENT(OUT)} @code{CHARACTER} variable.\n+@var{DATE} is an @code{INTENT(OUT)} @code{CHARACTER} variable of the\n+default kind.\n \n @item @emph{Standard}:\n GNU extension\n@@ -3903,7 +3911,8 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{DATE}@tab The type shall be of type @code{CHARACTER}.\n+@item @var{DATE}@tab The type shall be of type @code{CHARACTER} of the\n+default kind\n @end multitable\n \n @item @emph{Return value}:\n@@ -3999,7 +4008,8 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{C}      @tab The type shall be @code{CHARACTER}.\n+@item @var{C}      @tab The type shall be @code{CHARACTER} and of default\n+                        kind.\n @item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER}.\n                         Returns 0 on success, -1 on end-of-file, and a\n                         system specific positive error code otherwise.\n@@ -4061,9 +4071,11 @@ Subroutine, function\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{UNIT}   @tab The type shall be @code{INTEGER}.\n-@item @var{C}      @tab The type shall be @code{CHARACTER}.\n-@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER}. Returns 0 on success,\n-                        -1 on end-of-file and a system specific positive error code otherwise.\n+@item @var{C}      @tab The type shall be @code{CHARACTER} and of default\n+                        kind.\n+@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER}.\n+                        Returns 0 on success, -1 on end-of-file and a\n+                        system specific positive error code otherwise.\n @end multitable\n \n @item @emph{Example}:\n@@ -4241,9 +4253,11 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{C}      @tab The type shall be @code{CHARACTER}.\n-@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER}. Returns 0 on success,\n-                        -1 on end-of-file and a system specific positive error code otherwise.\n+@item @var{C}      @tab The type shall be @code{CHARACTER} and of default\n+                        kind.\n+@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER}.\n+                        Returns 0 on success, -1 on end-of-file and a\n+                        system specific positive error code otherwise.\n @end multitable\n \n @item @emph{Example}:\n@@ -4296,9 +4310,11 @@ Subroutine, function\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{UNIT}   @tab The type shall be @code{INTEGER}.\n-@item @var{C}      @tab The type shall be @code{CHARACTER}.\n-@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER}. Returns 0 on success,\n-                        -1 on end-of-file and a system specific positive error code otherwise.\n+@item @var{C}      @tab The type shall be @code{CHARACTER} and of default\n+                        kind.\n+@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER}.\n+                        Returns 0 on success, -1 on end-of-file and a\n+                        system specific positive error code otherwise.\n @end multitable\n \n @item @emph{Example}:\n@@ -4656,7 +4672,7 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{RESULT}  @tab Shall of type @code{CHARACTER}.\n+@item @var{RESULT}  @tab Shall of type @code{CHARACTER} and of default\n @end multitable\n \n @item @emph{Example}:\n@@ -4703,6 +4719,8 @@ Subroutine\n @multitable @columnfractions .15 .70\n @item @var{POS}   @tab Shall be of type @code{INTEGER} and not wider than\n the default integer kind; @math{@var{POS} \\geq 0}\n+@item @var{VALUE} @tab Shall be of type @code{CHARACTER} and of default\n+kind.\n @item @var{VALUE} @tab Shall be of type @code{CHARACTER}. \n @end multitable\n \n@@ -4757,7 +4775,8 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{COMMAND} @tab Shall be of type @code{CHARACTER}. \n+@item @var{COMMAND} @tab Shall be of type @code{CHARACTER} and of default\n+kind.\n @end multitable\n \n @item @emph{Return value}:\n@@ -4802,8 +4821,10 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{NUMBER} @tab Shall be a scalar of type @code{INTEGER(4)}, @math{@var{N} \\geq 0}.\n-@item @var{VALUE}  @tab (Option) Shall be a scalar of type @code{CHARACTER(1)}. \n+@item @var{NUMBER} @tab Shall be a scalar of type @code{INTEGER(4)},\n+                        @math{@var{NUMBER} \\geq 0}\n+@item @var{VALUE}  @tab Shall be a scalar of type @code{CHARACTER}\n+                        and of default kind.\n @item @var{LENGTH} @tab (Option) Shall be a scalar of type @code{INTEGER(4)}. \n @item @var{STATUS} @tab (Option) Shall be a scalar of type @code{INTEGER(4)}. \n @end multitable\n@@ -4865,7 +4886,7 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{C}      @tab The type shall be @code{CHARACTER}.\n+@item @var{C} @tab The type shall be @code{CHARACTER} and of default kind.\n @item @var{STATUS} @tab (Optional) status flag. Returns 0 on success, \n                         a system specific and nonzero error code otherwise.\n @end multitable\n@@ -4910,8 +4931,8 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{NAME}   @tab Shall be of type @code{CHARACTER}. \n-@item @var{VALUE}  @tab Shall be of type @code{CHARACTER}. \n+@item @var{NAME}  @tab Shall be of type @code{CHARACTER} and of default kind.\n+@item @var{VALUE} @tab Shall be of type @code{CHARACTER} and of default kind.\n @end multitable\n \n @item @emph{Return value}:\n@@ -5039,7 +5060,7 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{C} @tab Shall be of type @code{CHARACTER}.\n+@item @var{C} @tab Shall be of type @code{CHARACTER} and of default kind.\n @end multitable\n \n @item @emph{Return value}:\n@@ -5215,7 +5236,7 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{C }      @tab Shall of type @code{CHARACTER}.\n+@item @var{C}    @tab Shall of type @code{CHARACTER} and of default kind.\n @item @var{STATUS}  @tab (Optional) status flag of type @code{INTEGER}.\n                          Returns 0 on success, or a system specific error\n                          code otherwise.\n@@ -7132,10 +7153,11 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{FILE}   @tab The type shall be @code{CHARACTER}, a valid path within the file system.\n+@item @var{FILE}   @tab The type shall be @code{CHARACTER} of the default\n+kind, a valid path within the file system.\n @item @var{BUFF}   @tab The type shall be @code{INTEGER(4), DIMENSION(13)}.\n-@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER(4)}. Returns 0 \n-                        on success and a system specific error code otherwise.\n+@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER(4)}.\n+Returns 0 on success and a system specific error code otherwise.\n @end multitable\n \n @item @emph{Example}:\n@@ -8407,7 +8429,8 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{STRING} @tab A scalar of default @code{CHARACTER} type.\n+@item @var{STRING} @tab A scalar of type @code{CHARACTER} and of the\n+default kind.\n @end multitable\n \n @item @emph{See also}:\n@@ -10158,7 +10181,8 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{FILE}   @tab The type shall be @code{CHARACTER}, a valid path within the file system.\n+@item @var{FILE}   @tab The type shall be @code{CHARACTER}, of the\n+default kind and a valid path within the file system.\n @item @var{BUFF}   @tab The type shall be @code{INTEGER(4), DIMENSION(13)}.\n @item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER(4)}. Returns 0 \n                         on success and a system specific error code otherwise."}, {"sha": "4b7e17d70f3894e94ac7998753ddb9be3703231c", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 80, "deletions": 16, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -143,6 +143,24 @@ gfc_resolve_access (gfc_expr *f, gfc_expr *name ATTRIBUTE_UNUSED,\n }\n \n \n+void\n+gfc_resolve_adjustl (gfc_expr *f, gfc_expr *string)\n+{\n+  f->ts.type = BT_CHARACTER;\n+  f->ts.kind = string->ts.kind;\n+  f->value.function.name = gfc_get_string (\"__adjustl_s%d\", f->ts.kind);\n+}\n+\n+\n+void\n+gfc_resolve_adjustr (gfc_expr *f, gfc_expr *string)\n+{\n+  f->ts.type = BT_CHARACTER;\n+  f->ts.kind = string->ts.kind;\n+  f->value.function.name = gfc_get_string (\"__adjustr_s%d\", f->ts.kind);\n+}\n+\n+\n static void\n gfc_resolve_char_achar (gfc_expr *f, gfc_expr *x, gfc_expr *kind,\n \t\t\tconst char *name)\n@@ -1690,11 +1708,27 @@ gfc_resolve_pack (gfc_expr *f, gfc_expr *array, gfc_expr *mask,\n   resolve_mask_arg (mask);\n \n   if (mask->rank != 0)\n-    f->value.function.name = (array->ts.type == BT_CHARACTER\n-\t\t\t      ? PREFIX (\"pack_char\") : PREFIX (\"pack\"));\n+    {\n+      if (array->ts.type == BT_CHARACTER)\n+\tf->value.function.name\n+\t  = array->ts.kind == 1 ? PREFIX (\"pack_char\")\n+\t\t\t\t: gfc_get_string\n+\t\t\t\t\t(PREFIX (\"pack_char%d\"),\n+\t\t\t\t\t array->ts.kind);\n+      else\n+\tf->value.function.name = PREFIX (\"pack\");\n+    }\n   else\n-    f->value.function.name = (array->ts.type == BT_CHARACTER\n-\t\t\t      ? PREFIX (\"pack_s_char\") : PREFIX (\"pack_s\"));\n+    {\n+      if (array->ts.type == BT_CHARACTER)\n+\tf->value.function.name\n+\t  = array->ts.kind == 1 ? PREFIX (\"pack_s_char\")\n+\t\t\t\t: gfc_get_string\n+\t\t\t\t\t(PREFIX (\"pack_s_char%d\"),\n+\t\t\t\t\t array->ts.kind);\n+      else\n+\tf->value.function.name = PREFIX (\"pack_s\");\n+    }\n }\n \n \n@@ -1801,6 +1835,7 @@ gfc_resolve_reshape (gfc_expr *f, gfc_expr *source, gfc_expr *shape,\n     case BT_REAL:\n     case BT_INTEGER:\n     case BT_LOGICAL:\n+    case BT_CHARACTER:\n       kind = source->ts.kind;\n       break;\n \n@@ -1820,15 +1855,17 @@ gfc_resolve_reshape (gfc_expr *f, gfc_expr *source, gfc_expr *shape,\n \t  = gfc_get_string (PREFIX (\"reshape_%c%d\"),\n \t\t\t    gfc_type_letter (source->ts.type),\n \t\t\t    source->ts.kind);\n+      else if (source->ts.type == BT_CHARACTER)\n+\tf->value.function.name = gfc_get_string (PREFIX (\"reshape_char%d\"),\n+\t\t\t\t\t\t kind);\n       else\n \tf->value.function.name\n \t  = gfc_get_string (PREFIX (\"reshape_%d\"), source->ts.kind);\n-\n       break;\n \n     default:\n       f->value.function.name = (source->ts.type == BT_CHARACTER\n-\t\t\t     ? PREFIX (\"reshape_char\") : PREFIX (\"reshape\"));\n+\t\t\t\t? PREFIX (\"reshape_char\") : PREFIX (\"reshape\"));\n       break;\n     }\n \n@@ -2000,13 +2037,27 @@ gfc_resolve_spread (gfc_expr *f, gfc_expr *source, gfc_expr *dim,\n   f->ts = source->ts;\n   f->rank = source->rank + 1;\n   if (source->rank == 0)\n-    f->value.function.name = (source->ts.type == BT_CHARACTER\n-\t\t\t      ? PREFIX (\"spread_char_scalar\")\n-\t\t\t      : PREFIX (\"spread_scalar\"));\n+    {\n+      if (source->ts.type == BT_CHARACTER)\n+\tf->value.function.name\n+\t  = source->ts.kind == 1 ? PREFIX (\"spread_char_scalar\")\n+\t\t\t\t : gfc_get_string\n+\t\t\t\t\t(PREFIX (\"spread_char%d_scalar\"),\n+\t\t\t\t\t source->ts.kind);\n+      else\n+\tf->value.function.name = PREFIX (\"spread_scalar\");\n+    }\n   else\n-    f->value.function.name = (source->ts.type == BT_CHARACTER\n-\t\t\t      ? PREFIX (\"spread_char\")\n-\t\t\t      : PREFIX (\"spread\"));\n+    {\n+      if (source->ts.type == BT_CHARACTER)\n+\tf->value.function.name\n+\t  = source->ts.kind == 1 ? PREFIX (\"spread_char\")\n+\t\t\t\t : gfc_get_string\n+\t\t\t\t\t(PREFIX (\"spread_char%d\"),\n+\t\t\t\t\t source->ts.kind);\n+      else\n+\tf->value.function.name = PREFIX (\"spread\");\n+    }\n \n   if (dim && gfc_is_constant_expr (dim)\n       && ncopies && gfc_is_constant_expr (ncopies) && source->shape[0])\n@@ -2313,7 +2364,10 @@ gfc_resolve_transpose (gfc_expr *f, gfc_expr *matrix)\n \t  break;\n \n \tdefault:\n-\t  f->value.function.name = PREFIX (\"transpose\");\n+\t  if (matrix->ts.type == BT_CHARACTER && matrix->ts.kind == 4)\n+\t    f->value.function.name = PREFIX (\"transpose_char4\");\n+\t  else\n+\t    f->value.function.name = PREFIX (\"transpose\");\n \t  break;\n \t}\n       break;\n@@ -2413,9 +2467,19 @@ gfc_resolve_unpack (gfc_expr *f, gfc_expr *vector, gfc_expr *mask,\n   f->rank = mask->rank;\n   resolve_mask_arg (mask);\n \n-  f->value.function.name\n-    = gfc_get_string (PREFIX (\"unpack%d%s\"), field->rank > 0 ? 1 : 0,\n-\t\t      vector->ts.type == BT_CHARACTER ? \"_char\" : \"\");\n+  if (vector->ts.type == BT_CHARACTER)\n+    {\n+      if (vector->ts.kind == 1)\n+\tf->value.function.name\n+\t  = gfc_get_string (PREFIX (\"unpack%d_char\"), field->rank > 0 ? 1 : 0);\n+      else\n+\tf->value.function.name\n+\t  = gfc_get_string (PREFIX (\"unpack%d_char%d\"),\n+\t\t\t    field->rank > 0 ? 1 : 0, vector->ts.kind);\n+    }\n+  else\n+    f->value.function.name\n+      = gfc_get_string (PREFIX (\"unpack%d\"), field->rank > 0 ? 1 : 0);\n }\n \n "}, {"sha": "a9b47d8bced79095902c99e7f359af41f49256ac", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -992,10 +992,10 @@ match_string_constant (gfc_expr **result)\n     {\n       c = next_string_char (delimiter, &ret);\n \n-      if (!gfc_wide_fits_in_byte (c))\n+      if (!gfc_check_character_range (c, kind))\n \t{\n-\t  gfc_error (\"Unimplemented feature at %C: gfortran currently only \"\n-\t\t     \"supports character strings with one-byte characters\");\n+\t  gfc_error (\"Character '%s' in string at %C is not representable \"\n+\t\t     \"in character kind %d\", gfc_print_wide_char (c), kind);\n \t  return MATCH_ERROR;\n \t}\n "}, {"sha": "c3354a97d37b0d4893aac9359912a9d0d516b241", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -2965,7 +2965,8 @@ resolve_operator (gfc_expr *e)\n       goto bad_op;\n \n     case INTRINSIC_CONCAT:\n-      if (op1->ts.type == BT_CHARACTER && op2->ts.type == BT_CHARACTER)\n+      if (op1->ts.type == BT_CHARACTER && op2->ts.type == BT_CHARACTER\n+\t  && op1->ts.kind == op2->ts.kind)\n \t{\n \t  e->ts.type = BT_CHARACTER;\n \t  e->ts.kind = op1->ts.kind;\n@@ -3030,7 +3031,8 @@ resolve_operator (gfc_expr *e)\n     case INTRINSIC_EQ_OS:\n     case INTRINSIC_NE:\n     case INTRINSIC_NE_OS:\n-      if (op1->ts.type == BT_CHARACTER && op2->ts.type == BT_CHARACTER)\n+      if (op1->ts.type == BT_CHARACTER && op2->ts.type == BT_CHARACTER\n+\t  && op1->ts.kind == op2->ts.kind)\n \t{\n \t  e->ts.type = BT_LOGICAL;\n \t  e->ts.kind = gfc_default_logical_kind;\n@@ -5124,8 +5126,8 @@ validate_case_label_expr (gfc_expr *e, gfc_expr *case_expr)\n \n   if (case_expr->ts.type == BT_CHARACTER && e->ts.kind != case_expr->ts.kind)\n     {\n-      gfc_error(\"Expression in CASE statement at %L must be kind %d\",\n-\t\t&e->where, case_expr->ts.kind);\n+      gfc_error (\"Expression in CASE statement at %L must be of kind %d\",\n+\t\t &e->where, case_expr->ts.kind);\n       return FAILURE;\n     }\n "}, {"sha": "e094a62e33fade39a489af7a4055c687ec611121", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 82, "deletions": 47, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -256,43 +256,73 @@ gfc_simplify_abs (gfc_expr *e)\n   return result;\n }\n \n-/* We use the processor's collating sequence, because all\n-   systems that gfortran currently works on are ASCII.  */\n \n-gfc_expr *\n-gfc_simplify_achar (gfc_expr *e, gfc_expr *k)\n+static gfc_expr *\n+simplify_achar_char (gfc_expr *e, gfc_expr *k, const char *name, bool ascii)\n {\n   gfc_expr *result;\n-  int c, kind;\n-  const char *ch;\n+  int kind;\n+  bool too_large = false;\n \n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  kind = get_kind (BT_CHARACTER, k, \"ACHAR\", gfc_default_character_kind);\n+  kind = get_kind (BT_CHARACTER, k, name, gfc_default_character_kind);\n   if (kind == -1)\n     return &gfc_bad_expr;\n \n-  ch = gfc_extract_int (e, &c);\n+  if (mpz_cmp_si (e->value.integer, 0) < 0)\n+    {\n+      gfc_error (\"Argument of %s function at %L is negative\", name,\n+\t\t &e->where);\n+      return &gfc_bad_expr;\n+    }\n \n-  if (ch != NULL)\n-    gfc_internal_error (\"gfc_simplify_achar: %s\", ch);\n+  if (ascii && gfc_option.warn_surprising\n+      && mpz_cmp_si (e->value.integer, 127) > 0)\n+    gfc_warning (\"Argument of %s function at %L outside of range [0,127]\",\n+\t\t name, &e->where);\n \n-  if (gfc_option.warn_surprising && (c < 0 || c > 127))\n-    gfc_warning (\"Argument of ACHAR function at %L outside of range [0,127]\",\n-\t\t &e->where);\n+  if (kind == 1 && mpz_cmp_si (e->value.integer, 255) > 0)\n+    too_large = true;\n+  else if (kind == 4)\n+    {\n+      mpz_t t;\n+      mpz_init_set_ui (t, 2);\n+      mpz_pow_ui (t, t, 32);\n+      mpz_sub_ui (t, t, 1);\n+      if (mpz_cmp (e->value.integer, t) > 0)\n+\ttoo_large = true;\n+      mpz_clear (t);\n+    }\n \n-  result = gfc_constant_result (BT_CHARACTER, kind, &e->where);\n+  if (too_large)\n+    {\n+      gfc_error (\"Argument of %s function at %L is too large for the \"\n+\t\t \"collating sequence of kind %d\", name, &e->where, kind);\n+      return &gfc_bad_expr;\n+    }\n \n+  result = gfc_constant_result (BT_CHARACTER, kind, &e->where);\n   result->value.character.string = gfc_get_wide_string (2);\n-\n   result->value.character.length = 1;\n-  result->value.character.string[0] = c;\n+  result->value.character.string[0] = mpz_get_ui (e->value.integer);\n   result->value.character.string[1] = '\\0';\t/* For debugger */\n   return result;\n }\n \n \n+\n+/* We use the processor's collating sequence, because all\n+   systems that gfortran currently works on are ASCII.  */\n+\n+gfc_expr *\n+gfc_simplify_achar (gfc_expr *e, gfc_expr *k)\n+{\n+  return simplify_achar_char (e, k, \"ACHAR\", true);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_acos (gfc_expr *x)\n {\n@@ -821,35 +851,7 @@ gfc_simplify_ceiling (gfc_expr *e, gfc_expr *k)\n gfc_expr *\n gfc_simplify_char (gfc_expr *e, gfc_expr *k)\n {\n-  gfc_expr *result;\n-  int c, kind;\n-  const char *ch;\n-\n-  kind = get_kind (BT_CHARACTER, k, \"CHAR\", gfc_default_character_kind);\n-  if (kind == -1)\n-    return &gfc_bad_expr;\n-\n-  if (e->expr_type != EXPR_CONSTANT)\n-    return NULL;\n-\n-  ch = gfc_extract_int (e, &c);\n-\n-  if (ch != NULL)\n-    gfc_internal_error (\"gfc_simplify_char: %s\", ch);\n-\n-  if (c < 0 || c > UCHAR_MAX)\n-    gfc_error (\"Argument of CHAR function at %L outside of range [0,255]\",\n-\t       &e->where);\n-\n-  result = gfc_constant_result (BT_CHARACTER, kind, &e->where);\n-\n-  result->value.character.length = 1;\n-  result->value.character.string = gfc_get_wide_string (2);\n-\n-  result->value.character.string[0] = c;\n-  result->value.character.string[1] = '\\0';\t/* For debugger */\n-\n-  return result;\n+  return simplify_achar_char (e, k, \"CHAR\", false);\n }\n \n \n@@ -1698,8 +1700,6 @@ gfc_simplify_ichar (gfc_expr *e, gfc_expr *kind)\n     }\n \n   index = e->value.character.string[0];\n-  if (index > UCHAR_MAX)\n-    gfc_internal_error(\"Argument of ICHAR at %L out of range\", &e->where);\n \n   if ((result = int_expr_with_kind (index, kind, \"ICHAR\")) == NULL)\n     return &gfc_bad_expr;\n@@ -4799,3 +4799,38 @@ gfc_convert_constant (gfc_expr *e, bt type, int kind)\n \n   return result;\n }\n+\n+\n+/* Function for converting character constants.  */\n+gfc_expr *\n+gfc_convert_char_constant (gfc_expr *e, bt type ATTRIBUTE_UNUSED, int kind)\n+{\n+  gfc_expr *result;\n+  int i;\n+\n+  if (!gfc_is_constant_expr (e))\n+    return NULL;\n+\n+  result = gfc_constant_result (BT_CHARACTER, kind, &e->where);\n+  if (result == NULL)\n+    return &gfc_bad_expr;\n+\n+  result->value.character.length = e->value.character.length;\n+  result->value.character.string\n+    = gfc_get_wide_string (e->value.character.length + 1);\n+  memcpy (result->value.character.string, e->value.character.string,\n+\t  (e->value.character.length + 1) * sizeof (gfc_char_t));\n+\n+  /* Check we only have values representable in the destination kind.  */\n+  for (i = 0; i < result->value.character.length; i++)\n+    if (!gfc_check_character_range (result->value.character.string[i], kind))\n+      {\n+\tgfc_error (\"Character '%s' in string at %L cannot be converted into \"\n+\t\t   \"character kind %d\",\n+\t\t   gfc_print_wide_char (result->value.character.string[i]),\n+\t\t   &e->where, kind);\n+\treturn &gfc_bad_expr;\n+      }\n+\n+  return result;\n+}"}, {"sha": "e1f9b7c33a45098d72138a15e4d95590049188eb", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -75,7 +75,8 @@ size_logical (int kind)\n static size_t\n size_character (int length, int kind)\n {\n-  return length * kind;\n+  int i = gfc_validate_kind (BT_CHARACTER, kind, false);\n+  return length * gfc_character_kinds[i].bit_size / 8;\n }\n \n \n@@ -182,20 +183,19 @@ encode_logical (int kind, int logical, unsigned char *buffer, size_t buffer_size\n }\n \n \n-static int\n-encode_character (int kind, int length, gfc_char_t *string,\n-\t\t  unsigned char *buffer, size_t buffer_size)\n+int\n+gfc_encode_character (int kind, int length, const gfc_char_t *string,\n+\t\t      unsigned char *buffer, size_t buffer_size)\n {\n-  char *s;\n+  size_t elsize = size_character (1, kind);\n+  tree type = gfc_get_char_type (kind);\n+  int i;\n \n   gcc_assert (buffer_size >= size_character (length, kind));\n-  /* FIXME -- when we support wide character types, we'll need to go\n-     via integers for them.  For now, we keep the simple memcpy().  */\n-  gcc_assert (kind == gfc_default_character_kind);\n \n-  s = gfc_widechar_to_char (string, length);\n-  memcpy (buffer, s, length);\n-  gfc_free (s);\n+  for (i = 0; i < length; i++)\n+    native_encode_expr (build_int_cst (type, string[i]), &buffer[i*elsize],\n+\t\t\telsize);\n \n   return length;\n }\n@@ -268,21 +268,20 @@ gfc_target_encode_expr (gfc_expr *source, unsigned char *buffer,\n \t\t\t     buffer_size);\n     case BT_CHARACTER:\n       if (source->expr_type == EXPR_CONSTANT || source->ref == NULL)\n-\treturn encode_character (source->ts.kind,\n-\t\t\t\t source->value.character.length,\n-\t\t\t         source->value.character.string, buffer,\n-\t\t\t         buffer_size);\n+\treturn gfc_encode_character (source->ts.kind,\n+\t\t\t\t     source->value.character.length,\n+\t\t\t\t     source->value.character.string,\n+\t\t\t\t     buffer, buffer_size);\n       else\n \t{\n \t  int start, end;\n \n \t  gcc_assert (source->expr_type == EXPR_SUBSTRING);\n \t  gfc_extract_int (source->ref->u.ss.start, &start);\n \t  gfc_extract_int (source->ref->u.ss.end, &end);\n-\t  return encode_character (source->ts.kind,\n-\t\t\t\t   MAX(end - start + 1, 0),\n-\t\t\t\t   &source->value.character.string[start-1],\n-\t\t\t\t   buffer, buffer_size);\n+\t  return gfc_encode_character (source->ts.kind, MAX(end - start + 1, 0),\n+\t\t\t\t       &source->value.character.string[start-1],\n+\t\t\t\t       buffer, buffer_size);\n \t}\n \n     case BT_DERIVED:"}, {"sha": "bc3a1e8c0449e3e0fc8cb814721dbdc165b15285", "filename": "gcc/fortran/target-memory.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -31,6 +31,8 @@ bool gfc_convert_boz (gfc_expr *, gfc_typespec *);\n size_t gfc_target_expr_size (gfc_expr *);\n \n /* Write a constant expression in binary form to a target buffer.  */\n+int gfc_encode_character (int, int, const gfc_char_t *, unsigned char *,\n+\t\t\t  size_t);\n int gfc_target_encode_expr (gfc_expr *, unsigned char *, size_t);\n \n /* Read a target buffer into a constant expression.  */"}, {"sha": "a691ad5ffefa83f84226a655514274cc8c2edcc5", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -992,12 +992,11 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n       else\n \t{\n \t  /* The temporary is an array of string values.  */\n-\t  tmp = gfc_build_addr_expr (pchar_type_node, tmp);\n+\t  tmp = gfc_build_addr_expr (gfc_get_pchar_type (expr->ts.kind), tmp);\n \t  /* We know the temporary and the value will be the same length,\n \t     so can use memcpy.  */\n-\t  gfc_trans_string_copy (&se->pre, esize, tmp,\n-\t\t\t\t se->string_length,\n-\t\t\t\t se->expr);\n+\t  gfc_trans_string_copy (&se->pre, esize, tmp, expr->ts.kind,\n+\t\t\t\t se->string_length, se->expr, expr->ts.kind);\n \t}\n       if (flag_bounds_check && !typespec_chararray_ctor)\n \t{\n@@ -1185,15 +1184,15 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t{\n \t\t  gfc_init_se (&se, NULL);\n \t\t  gfc_conv_constant (&se, p->expr);\n+\n+\t\t  /* For constant character array constructors we build\n+\t\t     an array of pointers.  */\n \t\t  if (p->expr->ts.type == BT_CHARACTER\n \t\t      && POINTER_TYPE_P (type))\n-\t\t    {\n-\t\t      /* For constant character array constructors we build\n-\t\t\t an array of pointers.  */\n-\t\t      se.expr = gfc_build_addr_expr (pchar_type_node,\n-\t\t\t\t\t\t     se.expr);\n-\t\t    }\n-\t\t    \n+\t\t    se.expr = gfc_build_addr_expr\n+\t\t\t\t(gfc_get_pchar_type (p->expr->ts.kind),\n+\t\t\t\t se.expr);\n+\n \t\t  list = tree_cons (NULL_TREE, se.expr, list);\n \t\t  c = p;\n \t\t  p = p->next;\n@@ -1394,8 +1393,7 @@ get_array_ctor_var_strlen (gfc_expr * expr, tree * len)\n \t  mpz_init_set_ui (char_len, 1);\n \t  mpz_add (char_len, char_len, ref->u.ss.end->value.integer);\n \t  mpz_sub (char_len, char_len, ref->u.ss.start->value.integer);\n-\t  *len = gfc_conv_mpz_to_tree (char_len,\n-\t\t\t\t       gfc_default_character_kind);\n+\t  *len = gfc_conv_mpz_to_tree (char_len, gfc_default_integer_kind);\n \t  *len = convert (gfc_charlen_type_node, *len);\n \t  mpz_clear (char_len);\n \t  return;\n@@ -1546,9 +1544,9 @@ gfc_build_constant_array_constructor (gfc_expr * expr, tree type)\n     {\n       gfc_init_se (&se, NULL);\n       gfc_conv_constant (&se, c->expr);\n-      if (c->expr->ts.type == BT_CHARACTER\n-\t  && POINTER_TYPE_P (type))\n-\tse.expr = gfc_build_addr_expr (pchar_type_node, se.expr);\n+      if (c->expr->ts.type == BT_CHARACTER && POINTER_TYPE_P (type))\n+\tse.expr = gfc_build_addr_expr (gfc_get_pchar_type (c->expr->ts.kind),\n+\t\t\t\t       se.expr);\n       list = tree_cons (NULL_TREE, se.expr, list);\n       c = c->next;\n       nelem++;\n@@ -3488,8 +3486,9 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n       /* Make absolutely sure that this is a complete type.  */\n       if (loop->temp_ss->string_length)\n \tloop->temp_ss->data.temp.type\n-\t\t= gfc_get_character_type_len (gfc_default_character_kind,\n-\t\t\t\t\t      loop->temp_ss->string_length);\n+\t\t= gfc_get_character_type_len_for_eltype\n+\t\t\t(TREE_TYPE (loop->temp_ss->data.temp.type),\n+\t\t\t loop->temp_ss->string_length);\n \n       tmp = loop->temp_ss->data.temp.type;\n       len = loop->temp_ss->string_length;"}, {"sha": "2b644c7880b9f013d449e8dfc5448d348dbfe95c", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -139,4 +139,4 @@ unsigned HOST_WIDE_INT gfc_constant_array_constructor_p (gfc_constructor *);\n tree gfc_build_constant_array_constructor (gfc_expr *, tree);\n \n /* Copy a string from src to dest.  */\n-void gfc_trans_string_copy (stmtblock_t *, tree, tree, tree, tree);\n+void gfc_trans_string_copy (stmtblock_t *, tree, tree, int, tree, tree, int);"}, {"sha": "e4da3f08647ee65f3c8c743743f70e71a5fc635e", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans.h\"\n #include \"trans-const.h\"\n #include \"trans-types.h\"\n+#include \"target-memory.h\"\n \n tree gfc_rank_cst[GFC_MAX_DIMENSIONS + 1];\n \n@@ -66,6 +67,8 @@ gfc_build_const (tree type, tree intval)\n   return val;\n }\n \n+/* Build a string constant with C char type.  */\n+\n tree\n gfc_build_string_const (int length, const char *s)\n {\n@@ -81,6 +84,36 @@ gfc_build_string_const (int length, const char *s)\n   return str;\n }\n \n+\n+/* Build a string constant with a type given by its kind; take care of\n+   non-default character kinds.  */\n+\n+tree\n+gfc_build_wide_string_const (int kind, int length, const gfc_char_t *string)\n+{\n+  int i;\n+  tree str, len;\n+  size_t size;\n+  char *s;\n+\n+  i = gfc_validate_kind (BT_CHARACTER, kind, false);\n+  size = length * gfc_character_kinds[i].bit_size / 8;\n+\n+  s = gfc_getmem (size);\n+  gfc_encode_character (kind, length, string, (unsigned char *) s, size);\n+\n+  str = build_string (size, s);\n+  gfc_free (s);\n+\n+  len = build_int_cst (NULL_TREE, length);\n+  TREE_TYPE (str) =\n+    build_array_type (gfc_get_char_type (kind),\n+\t\t      build_range_type (gfc_charlen_type_node,\n+\t\t\t\t\tinteger_one_node, len));\n+  return str;\n+}\n+\n+\n /* Build a Fortran character constant from a zero-terminated string.\n    There a two version of this function, one that translates the string\n    and one that doesn't.  */\n@@ -106,13 +139,13 @@ tree\n gfc_conv_string_init (tree length, gfc_expr * expr)\n {\n   gfc_char_t *s;\n-  char *c;\n   HOST_WIDE_INT len;\n   int slen;\n   tree str;\n+  bool free_s = false;\n \n   gcc_assert (expr->expr_type == EXPR_CONSTANT);\n-  gcc_assert (expr->ts.type == BT_CHARACTER && expr->ts.kind == 1);\n+  gcc_assert (expr->ts.type == BT_CHARACTER);\n   gcc_assert (INTEGER_CST_P (length));\n   gcc_assert (TREE_INT_CST_HIGH (length) == 0);\n \n@@ -124,18 +157,15 @@ gfc_conv_string_init (tree length, gfc_expr * expr)\n       s = gfc_get_wide_string (len);\n       memcpy (s, expr->value.character.string, slen * sizeof (gfc_char_t));\n       gfc_wide_memset (&s[slen], ' ', len - slen);\n-\n-      /* FIXME -- currently ignore wide character strings; see assert\n-\t above.  */\n-      c = gfc_widechar_to_char (s, len);\n-      gfc_free (s);\n+      free_s = true;\n     }\n   else\n-    c = gfc_widechar_to_char (expr->value.character.string,\n-\t\t\t      expr->value.character.length);\n+    s = expr->value.character.string;\n \n-  str = gfc_build_string_const (len, c);\n-  gfc_free (c);\n+  str = gfc_build_wide_string_const (expr->ts.kind, len, s);\n+\n+  if (free_s)\n+    gfc_free (s);\n \n   return str;\n }\n@@ -223,7 +253,6 @@ tree\n gfc_conv_constant_to_tree (gfc_expr * expr)\n {\n   tree res;\n-  char *s;\n \n   gcc_assert (expr->expr_type == EXPR_CONSTANT);\n \n@@ -278,11 +307,9 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n \t}\n \n     case BT_CHARACTER:\n-      gcc_assert (expr->ts.kind == 1);\n-      s = gfc_widechar_to_char (expr->value.character.string,\n-\t\t\t\texpr->value.character.length);\n-      res = gfc_build_string_const (expr->value.character.length, s);\n-      gfc_free (s);\n+      res = gfc_build_wide_string_const (expr->ts.kind,\n+\t\t\t\t\t expr->value.character.length,\n+\t\t\t\t\t expr->value.character.string);\n       return res;\n \n     case BT_HOLLERITH:"}, {"sha": "2cba791c9c995a36fbcd84134bde8b63c1a9b9fc", "filename": "gcc/fortran/trans-const.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.h?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -37,6 +37,7 @@ tree gfc_conv_constant_to_tree (gfc_expr *);\n void gfc_conv_constant (gfc_se *, gfc_expr *);\n \n tree gfc_build_string_const (int, const char *);\n+tree gfc_build_wide_string_const (int, int, const gfc_char_t *);\n tree gfc_build_cstring_const (const char *);\n tree gfc_build_localized_cstring_const (const char *);\n "}, {"sha": "57914ae7a427e6e651379871ae045d314efce380", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -77,7 +77,6 @@ tree gfor_fndecl_pause_numeric;\n tree gfor_fndecl_pause_string;\n tree gfor_fndecl_stop_numeric;\n tree gfor_fndecl_stop_string;\n-tree gfor_fndecl_select_string;\n tree gfor_fndecl_runtime_error;\n tree gfor_fndecl_runtime_error_at;\n tree gfor_fndecl_os_error;\n@@ -116,6 +115,7 @@ tree gfor_fndecl_string_trim;\n tree gfor_fndecl_string_minmax;\n tree gfor_fndecl_adjustl;\n tree gfor_fndecl_adjustr;\n+tree gfor_fndecl_select_string;\n tree gfor_fndecl_compare_string_char4;\n tree gfor_fndecl_concat_string_char4;\n tree gfor_fndecl_string_len_trim_char4;\n@@ -126,6 +126,12 @@ tree gfor_fndecl_string_trim_char4;\n tree gfor_fndecl_string_minmax_char4;\n tree gfor_fndecl_adjustl_char4;\n tree gfor_fndecl_adjustr_char4;\n+tree gfor_fndecl_select_string_char4;\n+\n+\n+/* Conversion between character kinds.  */\n+tree gfor_fndecl_convert_char1_to_char4;\n+tree gfor_fndecl_convert_char4_to_char1;\n \n \n /* Other misc. runtime library functions.  */\n@@ -2084,6 +2090,12 @@ gfc_build_intrinsic_function_decls (void)\n \t\t\t\t     void_type_node, 3, pchar1_type_node,\n \t\t\t\t     gfc_charlen_type_node, pchar1_type_node);\n \n+  gfor_fndecl_select_string =\n+    gfc_build_library_function_decl (get_identifier (PREFIX(\"select_string\")),\n+\t\t\t\t     integer_type_node, 4, pvoid_type_node,\n+\t\t\t\t     integer_type_node, pchar1_type_node,\n+\t\t\t\t     gfc_charlen_type_node);\n+\n   gfor_fndecl_compare_string_char4 =\n     gfc_build_library_function_decl (get_identifier\n \t\t\t\t\t(PREFIX(\"compare_string_char4\")),\n@@ -2155,6 +2167,30 @@ gfc_build_intrinsic_function_decls (void)\n \t\t\t\t     void_type_node, 3, pchar4_type_node,\n \t\t\t\t     gfc_charlen_type_node, pchar4_type_node);\n \n+  gfor_fndecl_select_string_char4 =\n+    gfc_build_library_function_decl (get_identifier\n+\t\t\t\t\t(PREFIX(\"select_string_char4\")),\n+\t\t\t\t     integer_type_node, 4, pvoid_type_node,\n+\t\t\t\t     integer_type_node, pvoid_type_node,\n+\t\t\t\t     gfc_charlen_type_node);\n+\n+\n+  /* Conversion between character kinds.  */\n+\n+  gfor_fndecl_convert_char1_to_char4 =\n+    gfc_build_library_function_decl (get_identifier\n+\t\t\t\t\t(PREFIX(\"convert_char1_to_char4\")),\n+\t\t\t\t     void_type_node, 3,\n+\t\t\t\t     build_pointer_type (pchar4_type_node),\n+\t\t\t\t     gfc_charlen_type_node, pchar1_type_node);\n+\n+  gfor_fndecl_convert_char4_to_char1 =\n+    gfc_build_library_function_decl (get_identifier\n+\t\t\t\t\t(PREFIX(\"convert_char4_to_char1\")),\n+\t\t\t\t     void_type_node, 3,\n+\t\t\t\t     build_pointer_type (pchar1_type_node),\n+\t\t\t\t     gfc_charlen_type_node, pchar4_type_node);\n+\n   /* Misc. functions.  */\n \n   gfor_fndecl_ttynam =\n@@ -2362,12 +2398,6 @@ gfc_build_builtin_function_decls (void)\n \t\t\t\t     void_type_node, 2, pchar_type_node,\n                                      gfc_int4_type_node);\n \n-  gfor_fndecl_select_string =\n-    gfc_build_library_function_decl (get_identifier (PREFIX(\"select_string\")),\n-\t\t\t\t     integer_type_node, 4, pvoid_type_node,\n-\t\t\t\t     integer_type_node, pchar_type_node,\n-\t\t\t\t     integer_type_node);\n-\n   gfor_fndecl_runtime_error =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"runtime_error\")),\n \t\t\t\t     void_type_node, -1, pchar_type_node);"}, {"sha": "482e8b14ff2ef6dc3b528f8365f24be028dcf2ca", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 122, "deletions": 39, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -977,15 +977,18 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n       tmp = fold_build2 (MINUS_EXPR, gfc_charlen_type_node, len,\n \t\t\t build_int_cst (gfc_charlen_type_node, 1));\n       tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n-      tmp = build_array_type (gfc_character1_type_node, tmp);\n+      tmp = build_array_type (TREE_TYPE (TREE_TYPE (type)), tmp);\n       var = gfc_create_var (tmp, \"str\");\n       var = gfc_build_addr_expr (type, var);\n     }\n   else\n     {\n       /* Allocate a temporary to hold the result.  */\n       var = gfc_create_var (type, \"pstr\");\n-      tmp = gfc_call_malloc (&se->pre, type, len);\n+      tmp = gfc_call_malloc (&se->pre, type,\n+\t\t\t     fold_build2 (MULT_EXPR, TREE_TYPE (len), len,\n+\t\t\t\t\t  fold_convert (TREE_TYPE (len),\n+\t\t\t\t\t\t\tTYPE_SIZE (type))));\n       gfc_add_modify_expr (&se->pre, var, tmp);\n \n       /* Free the temporary afterwards.  */\n@@ -1008,6 +1011,7 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n \n   gcc_assert (expr->value.op.op1->ts.type == BT_CHARACTER\n \t      && expr->value.op.op2->ts.type == BT_CHARACTER);\n+  gcc_assert (expr->value.op.op1->ts.kind == expr->value.op.op2->ts.kind);\n \n   gfc_init_se (&lse, se);\n   gfc_conv_expr (&lse, expr->value.op.op1);\n@@ -1238,14 +1242,14 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n /* If a string's length is one, we convert it to a single character.  */\n \n static tree\n-gfc_to_single_character (tree len, tree str)\n+string_to_single_character (tree len, tree str, int kind)\n {\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (str)));\n \n   if (INTEGER_CST_P (len) && TREE_INT_CST_LOW (len) == 1\n-    && TREE_INT_CST_HIGH (len) == 0)\n+      && TREE_INT_CST_HIGH (len) == 0)\n     {\n-      str = fold_convert (pchar_type_node, str);\n+      str = fold_convert (gfc_get_pchar_type (kind), str);\n       return build_fold_indirect_ref (str);\n     }\n \n@@ -1293,18 +1297,21 @@ gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr)\n         {\n \t  if ((*expr)->ref == NULL)\n \t    {\n-\t      se->expr = gfc_to_single_character\n+\t      se->expr = string_to_single_character\n \t\t(build_int_cst (integer_type_node, 1),\n-\t\t gfc_build_addr_expr (pchar_type_node,\n+\t\t gfc_build_addr_expr (gfc_get_pchar_type ((*expr)->ts.kind),\n \t\t\t\t      gfc_get_symbol_decl\n-\t\t\t\t      ((*expr)->symtree->n.sym)));\n+\t\t\t\t      ((*expr)->symtree->n.sym)),\n+\t\t (*expr)->ts.kind);\n \t    }\n \t  else\n \t    {\n \t      gfc_conv_variable (se, *expr);\n-\t      se->expr = gfc_to_single_character\n+\t      se->expr = string_to_single_character\n \t\t(build_int_cst (integer_type_node, 1),\n-\t\t gfc_build_addr_expr (pchar_type_node, se->expr));\n+\t\t gfc_build_addr_expr (gfc_get_pchar_type ((*expr)->ts.kind),\n+\t\t\t\t      se->expr),\n+\t\t (*expr)->ts.kind);\n \t    }\n \t}\n     }\n@@ -1324,8 +1331,8 @@ gfc_build_compare_string (tree len1, tree str1, tree len2, tree str2, int kind)\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (str1)));\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (str2)));\n \n-  sc1 = gfc_to_single_character (len1, str1);\n-  sc2 = gfc_to_single_character (len2, str2);\n+  sc1 = string_to_single_character (len1, str1, kind);\n+  sc2 = string_to_single_character (len2, str2, kind);\n \n   if (sc1 != NULL_TREE && sc2 != NULL_TREE)\n     {\n@@ -2827,11 +2834,77 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n }\n \n \n+/* Fill a character string with spaces.  */\n+\n+static tree\n+fill_with_spaces (tree start, tree type, tree size)\n+{\n+  stmtblock_t block, loop;\n+  tree i, el, exit_label, cond, tmp;\n+\n+  /* For a simple char type, we can call memset().  */\n+  if (compare_tree_int (TYPE_SIZE_UNIT (type), 1) == 0)\n+    return build_call_expr (built_in_decls[BUILT_IN_MEMSET], 3, start,\n+\t\t\t    build_int_cst (gfc_get_int_type (gfc_c_int_kind),\n+\t\t\t\t\t   lang_hooks.to_target_charset (' ')),\n+\t\t\t    size);\n+\n+  /* Otherwise, we use a loop:\n+\tfor (el = start, i = size; i > 0; el--, i+= TYPE_SIZE_UNIT (type))\n+\t  *el = (type) ' ';\n+   */\n+\n+  /* Initialize variables.  */\n+  gfc_init_block (&block);\n+  i = gfc_create_var (sizetype, \"i\");\n+  gfc_add_modify_expr (&block, i, fold_convert (sizetype, size));\n+  el = gfc_create_var (build_pointer_type (type), \"el\");\n+  gfc_add_modify_expr (&block, el, fold_convert (TREE_TYPE (el), start));\n+  exit_label = gfc_build_label_decl (NULL_TREE);\n+  TREE_USED (exit_label) = 1;\n+\n+\n+  /* Loop body.  */\n+  gfc_init_block (&loop);\n+\n+  /* Exit condition.  */\n+  cond = fold_build2 (LE_EXPR, boolean_type_node, i,\n+\t\t      fold_convert (sizetype, integer_zero_node));\n+  tmp = build1_v (GOTO_EXPR, exit_label);\n+  tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp, build_empty_stmt ());\n+  gfc_add_expr_to_block (&loop, tmp);\n+\n+  /* Assignment.  */\n+  gfc_add_modify_expr (&loop, fold_build1 (INDIRECT_REF, type, el),\n+\t\t       build_int_cst (type,\n+\t\t\t\t      lang_hooks.to_target_charset (' ')));\n+\n+  /* Increment loop variables.  */\n+  gfc_add_modify_expr (&loop, i, fold_build2 (MINUS_EXPR, sizetype, i,\n+\t\t\t\t\t      TYPE_SIZE_UNIT (type)));\n+  gfc_add_modify_expr (&loop, el, fold_build2 (POINTER_PLUS_EXPR,\n+\t\t\t\t\t       TREE_TYPE (el), el,\n+\t\t\t\t\t       TYPE_SIZE_UNIT (type)));\n+\n+  /* Making the loop... actually loop!  */\n+  tmp = gfc_finish_block (&loop);\n+  tmp = build1_v (LOOP_EXPR, tmp);\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+  /* The exit label.  */\n+  tmp = build1_v (LABEL_EXPR, exit_label);\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+\n /* Generate code to copy a string.  */\n \n void\n gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n-\t\t       tree slength, tree src)\n+\t\t       int dkind, tree slength, tree src, int skind)\n {\n   tree tmp, dlen, slen;\n   tree dsc;\n@@ -2841,12 +2914,15 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   tree tmp2;\n   tree tmp3;\n   tree tmp4;\n+  tree chartype;\n   stmtblock_t tempblock;\n \n+  gcc_assert (dkind == skind);\n+\n   if (slength != NULL_TREE)\n     {\n       slen = fold_convert (size_type_node, gfc_evaluate_now (slength, block));\n-      ssc = gfc_to_single_character (slen, src);\n+      ssc = string_to_single_character (slen, src, skind);\n     }\n   else\n     {\n@@ -2857,7 +2933,7 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   if (dlength != NULL_TREE)\n     {\n       dlen = fold_convert (size_type_node, gfc_evaluate_now (dlength, block));\n-      dsc = gfc_to_single_character (slen, dest);\n+      dsc = string_to_single_character (slen, dest, dkind);\n     }\n   else\n     {\n@@ -2866,14 +2942,14 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n     }\n \n   if (slength != NULL_TREE && POINTER_TYPE_P (TREE_TYPE (src)))\n-    ssc = gfc_to_single_character (slen, src);\n+    ssc = string_to_single_character (slen, src, skind);\n   if (dlength != NULL_TREE && POINTER_TYPE_P (TREE_TYPE (dest)))\n-    dsc = gfc_to_single_character (dlen, dest);\n+    dsc = string_to_single_character (dlen, dest, dkind);\n \n \n   /* Assign directly if the types are compatible.  */\n   if (dsc != NULL_TREE && ssc != NULL_TREE\n-\t&& TREE_TYPE (dsc) == TREE_TYPE (ssc))\n+      && TREE_TYPE (dsc) == TREE_TYPE (ssc))\n     {\n       gfc_add_modify_expr (block, dsc, ssc);\n       return;\n@@ -2906,6 +2982,14 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n      We're now doing it here for better optimization, but the logic\n      is the same.  */\n \n+  /* For non-default character kinds, we have to multiply the string\n+     length by the base type size.  */\n+  chartype = gfc_get_char_type (dkind);\n+  slen = fold_build2 (MULT_EXPR, size_type_node, slen,\n+\t\t      TYPE_SIZE_UNIT (chartype));\n+  dlen = fold_build2 (MULT_EXPR, size_type_node, dlen,\n+\t\t      TYPE_SIZE_UNIT (chartype));\n+\n   if (dlength)\n     dest = fold_convert (pvoid_type_node, dest);\n   else\n@@ -2927,12 +3011,9 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n \n   tmp4 = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (dest), dest,\n \t\t      fold_convert (sizetype, slen));\n-  tmp4 = build_call_expr (built_in_decls[BUILT_IN_MEMSET], 3,\n-\t\t\t  tmp4, \n-\t\t\t  build_int_cst (gfc_get_int_type (gfc_c_int_kind),\n-\t\t\t\t\t lang_hooks.to_target_charset (' ')),\n-\t\t\t  fold_build2 (MINUS_EXPR, TREE_TYPE(dlen),\n-\t\t\t\t       dlen, slen));\n+  tmp4 = fill_with_spaces (tmp4, chartype,\n+\t\t\t   fold_build2 (MINUS_EXPR, TREE_TYPE(dlen),\n+\t\t\t\t\tdlen, slen));\n \n   gfc_init_block (&tempblock);\n   gfc_add_expr_to_block (&tempblock, tmp3);\n@@ -2994,7 +3075,7 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n           tree arglen;\n \n           gcc_assert (fsym->ts.cl && fsym->ts.cl->length\n-                     && fsym->ts.cl->length->expr_type == EXPR_CONSTANT);\n+\t\t      && fsym->ts.cl->length->expr_type == EXPR_CONSTANT);\n \n           arglen = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n           tmp = gfc_build_addr_expr (build_pointer_type (type),\n@@ -3005,8 +3086,8 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n           gfc_add_block_to_block (&se->pre, &lse.pre);\n           gfc_add_block_to_block (&se->pre, &rse.pre);\n \n-\t  gfc_trans_string_copy (&se->pre, arglen, tmp, rse.string_length,\n-\t\t\t\t rse.expr);\n+\t  gfc_trans_string_copy (&se->pre, arglen, tmp, fsym->ts.kind,\n+\t\t\t\t rse.string_length, rse.expr, fsym->ts.kind);\n           gfc_add_block_to_block (&se->pre, &lse.post);\n           gfc_add_block_to_block (&se->pre, &rse.post);\n         }\n@@ -3042,7 +3123,8 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n \t  tmp = gfc_create_var (type, sym->name);\n \t  tmp = gfc_build_addr_expr (build_pointer_type (type), tmp);\n \t  gfc_trans_string_copy (&se->pre, sym->ts.cl->backend_decl, tmp,\n-\t\t\t\t se->string_length, se->expr);\n+\t\t\t\t sym->ts.kind, se->string_length, se->expr,\n+\t\t\t\t sym->ts.kind);\n \t  se->expr = tmp;\n \t}\n       se->string_length = sym->ts.cl->backend_decl;\n@@ -3501,17 +3583,14 @@ static void\n gfc_conv_substring_expr (gfc_se * se, gfc_expr * expr)\n {\n   gfc_ref *ref;\n-  char *s;\n \n   ref = expr->ref;\n \n   gcc_assert (ref == NULL || ref->type == REF_SUBSTRING);\n \n-  gcc_assert (expr->ts.kind == gfc_default_character_kind);\n-  s = gfc_widechar_to_char (expr->value.character.string,\n-\t\t\t    expr->value.character.length);\n-  se->expr = gfc_build_string_const (expr->value.character.length, s);\n-  gfc_free (s);\n+  se->expr = gfc_build_wide_string_const (expr->ts.kind,\n+\t\t\t\t\t  expr->value.character.length,\n+\t\t\t\t\t  expr->value.character.string);\n \n   se->string_length = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (se->expr)));\n   TYPE_STRING_FLAG (TREE_TYPE (se->expr)) = 1;\n@@ -3824,15 +3903,18 @@ gfc_conv_string_parameter (gfc_se * se)\n \n   if (TREE_CODE (se->expr) == STRING_CST)\n     {\n-      se->expr = gfc_build_addr_expr (pchar_type_node, se->expr);\n+      type = TREE_TYPE (TREE_TYPE (se->expr));\n+      se->expr = gfc_build_addr_expr (build_pointer_type (type), se->expr);\n       return;\n     }\n \n-  type = TREE_TYPE (se->expr);\n-  if (TYPE_STRING_FLAG (type))\n+  if (TYPE_STRING_FLAG (TREE_TYPE (se->expr)))\n     {\n       if (TREE_CODE (se->expr) != INDIRECT_REF)\n-        se->expr = gfc_build_addr_expr (pchar_type_node, se->expr);\n+\t{\n+\t  type = TREE_TYPE (se->expr);\n+          se->expr = gfc_build_addr_expr (build_pointer_type (type), se->expr);\n+\t}\n       else\n \t{\n \t  type = gfc_get_character_type_len (gfc_default_character_kind,\n@@ -3881,7 +3963,8 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \t  rlen = rse->string_length;\n \t}\n \n-      gfc_trans_string_copy (&block, llen, lse->expr, rlen, rse->expr);\n+      gfc_trans_string_copy (&block, llen, lse->expr, ts.kind, rlen,\n+\t\t\t     rse->expr, ts.kind);\n     }\n   else if (ts.type == BT_DERIVED && ts.derived->attr.alloc_comp)\n     {"}, {"sha": "990a12789fe534cc75c084ad6d5102447845025a", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 52, "deletions": 13, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -250,6 +250,41 @@ gfc_conv_intrinsic_conversion (gfc_se * se, gfc_expr * expr)\n   gcc_assert (expr->value.function.actual->expr);\n   gfc_conv_intrinsic_function_args (se, expr, args, nargs);\n \n+  /* Conversion between character kinds involves a call to a library\n+     function.  */\n+  if (expr->ts.type == BT_CHARACTER)\n+    {\n+      tree fndecl, var, addr, tmp;\n+\n+      if (expr->ts.kind == 1\n+\t  && expr->value.function.actual->expr->ts.kind == 4)\n+\tfndecl = gfor_fndecl_convert_char4_to_char1;\n+      else if (expr->ts.kind == 4\n+\t       && expr->value.function.actual->expr->ts.kind == 1)\n+\tfndecl = gfor_fndecl_convert_char1_to_char4;\n+      else\n+\tgcc_unreachable ();\n+\n+      /* Create the variable storing the converted value.  */\n+      type = gfc_get_pchar_type (expr->ts.kind);\n+      var = gfc_create_var (type, \"str\");\n+      addr = gfc_build_addr_expr (build_pointer_type (type), var);\n+\n+      /* Call the library function that will perform the conversion.  */\n+      gcc_assert (nargs >= 2);\n+      tmp = build_call_expr (fndecl, 3, addr, args[0], args[1]);\n+      gfc_add_expr_to_block (&se->pre, tmp);\n+\n+      /* Free the temporary afterwards.  */\n+      tmp = gfc_call_free (var);\n+      gfc_add_expr_to_block (&se->post, tmp);\n+\n+      se->expr = var;\n+      se->string_length = args[0];\n+\n+      return;\n+    }\n+\n   /* Conversion from complex to non-complex involves taking the real\n      component of the value.  */\n   if (TREE_CODE (TREE_TYPE (args[0])) == COMPLEX_TYPE\n@@ -1273,16 +1308,13 @@ gfc_conv_intrinsic_char (gfc_se * se, gfc_expr * expr)\n   tree type;\n   unsigned int num_args;\n \n-  /* We must allow for the KIND argument, even though.... */\n   num_args = gfc_intrinsic_argument_list_length (expr);\n   gfc_conv_intrinsic_function_args (se, expr, arg, num_args);\n \n-  /* .... we currently don't support character types != 1.  */\n-  gcc_assert (expr->ts.kind == 1);\n-  type = gfc_character1_type_node;\n+  type = gfc_get_char_type (expr->ts.kind);\n   var = gfc_create_var (type, \"char\");\n \n-  arg[0] = convert (type, arg[0]);\n+  arg[0] = fold_build1 (NOP_EXPR, type, arg[0]);\n   gfc_add_modify_expr (&se->pre, var, arg[0]);\n   se->expr = gfc_build_addr_expr (build_pointer_type (type), var);\n   se->string_length = integer_one_node;\n@@ -3290,7 +3322,7 @@ gfc_conv_intrinsic_strcmp (gfc_se * se, gfc_expr * expr, int op)\n \n   se->expr\n     = gfc_build_compare_string (args[0], args[1], args[2], args[3],\n-                               expr->value.function.actual->expr->ts.kind);\n+\t\t\t\texpr->value.function.actual->expr->ts.kind);\n   se->expr = fold_build2 (op, gfc_typenode_for_spec (&expr->ts), se->expr,\n \t\t\t  build_int_cst (TREE_TYPE (se->expr), 0));\n }\n@@ -3892,9 +3924,14 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n {\n   tree args[3], ncopies, dest, dlen, src, slen, ncopies_type;\n   tree type, cond, tmp, count, exit_label, n, max, largest;\n+  tree size;\n   stmtblock_t block, body;\n   int i;\n \n+  /* We store in charsize the size of an character.  */\n+  i = gfc_validate_kind (BT_CHARACTER, expr->ts.kind, false);\n+  size = build_int_cst (size_type_node, gfc_character_kinds[i].bit_size / 8);\n+\n   /* Get the arguments.  */\n   gfc_conv_intrinsic_function_args (se, expr, args, 3);\n   slen = fold_convert (size_type_node, gfc_evaluate_now (args[0], &se->pre));\n@@ -3939,7 +3976,6 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n \t\t      cond);\n   gfc_trans_runtime_check (cond, &se->pre, &expr->where,\n \t\t\t   \"Argument NCOPIES of REPEAT intrinsic is too large\");\n-\t\t\t   \n \n   /* Compute the destination length.  */\n   dlen = fold_build2 (MULT_EXPR, gfc_charlen_type_node,\n@@ -3950,7 +3986,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n \n   /* Generate the code to do the repeat operation:\n        for (i = 0; i < ncopies; i++)\n-         memmove (dest + (i * slen), src, slen);  */\n+         memmove (dest + (i * slen * size), src, slen*size);  */\n   gfc_start_block (&block);\n   count = gfc_create_var (ncopies_type, \"count\");\n   gfc_add_modify_expr (&block, count, build_int_cst (ncopies_type, 0));\n@@ -3967,15 +4003,18 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n \t\t     build_empty_stmt ());\n   gfc_add_expr_to_block (&body, tmp);\n \n-  /* Call memmove (dest + (i*slen), src, slen).  */\n+  /* Call memmove (dest + (i*slen*size), src, slen*size).  */\n   tmp = fold_build2 (MULT_EXPR, gfc_charlen_type_node,\n \t\t     fold_convert (gfc_charlen_type_node, slen),\n \t\t     fold_convert (gfc_charlen_type_node, count));\n-  tmp = fold_build2 (POINTER_PLUS_EXPR, pchar_type_node,\n-\t\t     fold_convert (pchar_type_node, dest),\n+  tmp = fold_build2 (MULT_EXPR, gfc_charlen_type_node,\n+\t\t     tmp, fold_convert (gfc_charlen_type_node, size));\n+  tmp = fold_build2 (POINTER_PLUS_EXPR, pvoid_type_node,\n+\t\t     fold_convert (pvoid_type_node, dest),\n \t\t     fold_convert (sizetype, tmp));\n-  tmp = build_call_expr (built_in_decls[BUILT_IN_MEMMOVE], 3,\n-\t\t\t tmp, src, slen);\n+  tmp = build_call_expr (built_in_decls[BUILT_IN_MEMMOVE], 3, tmp, src,\n+\t\t\t fold_build2 (MULT_EXPR, size_type_node, slen,\n+\t\t\t\t      fold_convert (size_type_node, size)));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Increment count.  */"}, {"sha": "6afac5d3734474d2edac72e934a0e732f824123b", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 59, "deletions": 40, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -99,7 +99,6 @@ gfc_trans_label_assign (gfc_code * code)\n   tree len;\n   tree addr;\n   tree len_tree;\n-  char *label_str;\n   int label_len;\n \n   /* Start a new block.  */\n@@ -119,14 +118,13 @@ gfc_trans_label_assign (gfc_code * code)\n     }\n   else\n     {\n-      label_len = code->label->format->value.character.length;\n-      label_str\n-\t= gfc_widechar_to_char (code->label->format->value.character.string,\n-\t\t\t\tlabel_len);\n+      gfc_expr *format = code->label->format;\n+\n+      label_len = format->value.character.length;\n       len_tree = build_int_cst (NULL_TREE, label_len);\n-      label_tree = gfc_build_string_const (label_len + 1, label_str);\n+      label_tree = gfc_build_wide_string_const (format->ts.kind, label_len + 1,\n+\t\t\t\t\t\tformat->value.character.string);\n       label_tree = gfc_build_addr_expr (pvoid_type_node, label_tree);\n-      gfc_free (label_str);\n     }\n \n   gfc_add_modify_expr (&se.pre, len, len_tree);\n@@ -1321,41 +1319,56 @@ gfc_trans_logical_select (gfc_code * code)\n static tree\n gfc_trans_character_select (gfc_code *code)\n {\n-  tree init, node, end_label, tmp, type, case_num, label;\n+  tree init, node, end_label, tmp, type, case_num, label, fndecl;\n   stmtblock_t block, body;\n   gfc_case *cp, *d;\n   gfc_code *c;\n   gfc_se se;\n-  int n;\n+  int n, k;\n+\n+  /* The jump table types are stored in static variables to avoid\n+     constructing them from scratch every single time.  */\n+  static tree select_struct[2];\n+  static tree ss_string1[2], ss_string1_len[2];\n+  static tree ss_string2[2], ss_string2_len[2];\n+  static tree ss_target[2];\n \n-  static tree select_struct;\n-  static tree ss_string1, ss_string1_len;\n-  static tree ss_string2, ss_string2_len;\n-  static tree ss_target;\n+  tree pchartype = gfc_get_pchar_type (code->expr->ts.kind);\n+\n+  if (code->expr->ts.kind == 1)\n+    k = 0;\n+  else if (code->expr->ts.kind == 4)\n+    k = 1;\n+  else\n+    gcc_unreachable ();\n \n-  if (select_struct == NULL)\n+  if (select_struct[k] == NULL)\n     {\n-      tree gfc_int4_type_node = gfc_get_int_type (4);\n+      select_struct[k] = make_node (RECORD_TYPE);\n \n-      select_struct = make_node (RECORD_TYPE);\n-      TYPE_NAME (select_struct) = get_identifier (\"_jump_struct\");\n+      if (code->expr->ts.kind == 1)\n+\tTYPE_NAME (select_struct[k]) = get_identifier (\"_jump_struct_char1\");\n+      else if (code->expr->ts.kind == 4)\n+\tTYPE_NAME (select_struct[k]) = get_identifier (\"_jump_struct_char4\");\n+      else\n+\tgcc_unreachable ();\n \n #undef ADD_FIELD\n-#define ADD_FIELD(NAME, TYPE)\t\t\t\t\\\n-  ss_##NAME = gfc_add_field_to_struct\t\t\t\\\n-     (&(TYPE_FIELDS (select_struct)), select_struct,\t\\\n+#define ADD_FIELD(NAME, TYPE)\t\t\t\t\t\\\n+  ss_##NAME[k] = gfc_add_field_to_struct\t\t\t\t\\\n+     (&(TYPE_FIELDS (select_struct[k])), select_struct[k],\t\\\n       get_identifier (stringize(NAME)), TYPE)\n \n-      ADD_FIELD (string1, pchar_type_node);\n-      ADD_FIELD (string1_len, gfc_int4_type_node);\n+      ADD_FIELD (string1, pchartype);\n+      ADD_FIELD (string1_len, gfc_charlen_type_node);\n \n-      ADD_FIELD (string2, pchar_type_node);\n-      ADD_FIELD (string2_len, gfc_int4_type_node);\n+      ADD_FIELD (string2, pchartype);\n+      ADD_FIELD (string2_len, gfc_charlen_type_node);\n \n       ADD_FIELD (target, integer_type_node);\n #undef ADD_FIELD\n \n-      gfc_finish_type (select_struct);\n+      gfc_finish_type (select_struct[k]);\n     }\n \n   cp = code->block->ext.case_list;\n@@ -1401,40 +1414,40 @@ gfc_trans_character_select (gfc_code *code)\n \n       if (d->low == NULL)\n         {\n-          node = tree_cons (ss_string1, null_pointer_node, node);\n-          node = tree_cons (ss_string1_len, integer_zero_node, node);\n+          node = tree_cons (ss_string1[k], null_pointer_node, node);\n+          node = tree_cons (ss_string1_len[k], integer_zero_node, node);\n         }\n       else\n         {\n           gfc_conv_expr_reference (&se, d->low);\n \n-          node = tree_cons (ss_string1, se.expr, node);\n-          node = tree_cons (ss_string1_len, se.string_length, node);\n+          node = tree_cons (ss_string1[k], se.expr, node);\n+          node = tree_cons (ss_string1_len[k], se.string_length, node);\n         }\n \n       if (d->high == NULL)\n         {\n-          node = tree_cons (ss_string2, null_pointer_node, node);\n-          node = tree_cons (ss_string2_len, integer_zero_node, node);\n+          node = tree_cons (ss_string2[k], null_pointer_node, node);\n+          node = tree_cons (ss_string2_len[k], integer_zero_node, node);\n         }\n       else\n         {\n           gfc_init_se (&se, NULL);\n           gfc_conv_expr_reference (&se, d->high);\n \n-          node = tree_cons (ss_string2, se.expr, node);\n-          node = tree_cons (ss_string2_len, se.string_length, node);\n+          node = tree_cons (ss_string2[k], se.expr, node);\n+          node = tree_cons (ss_string2_len[k], se.string_length, node);\n         }\n \n-      node = tree_cons (ss_target, build_int_cst (integer_type_node, d->n),\n+      node = tree_cons (ss_target[k], build_int_cst (integer_type_node, d->n),\n \t\t\tnode);\n \n-      tmp = build_constructor_from_list (select_struct, nreverse (node));\n+      tmp = build_constructor_from_list (select_struct[k], nreverse (node));\n       init = tree_cons (NULL_TREE, tmp, init);\n     }\n \n-  type = build_array_type (select_struct, build_index_type\n-\t\t\t   (build_int_cst (NULL_TREE, n - 1)));\n+  type = build_array_type (select_struct[k],\n+\t\t\t   build_index_type (build_int_cst (NULL_TREE, n-1)));\n \n   init = build_constructor_from_list (type, nreverse(init));\n   TREE_CONSTANT (init) = 1;\n@@ -1455,9 +1468,15 @@ gfc_trans_character_select (gfc_code *code)\n \n   gfc_add_block_to_block (&block, &se.pre);\n \n-  tmp = build_call_expr (gfor_fndecl_select_string, 4, init,\n-\t\t\t build_int_cst (NULL_TREE, n), se.expr,\n-\t\t\t se.string_length);\n+  if (code->expr->ts.kind == 1)\n+    fndecl = gfor_fndecl_select_string;\n+  else if (code->expr->ts.kind == 4)\n+    fndecl = gfor_fndecl_select_string_char4;\n+  else\n+    gcc_unreachable ();\n+\n+  tmp = build_call_expr (fndecl, 4, init, build_int_cst (NULL_TREE, n),\n+\t\t\t se.expr, se.string_length);\n   case_num = gfc_create_var (integer_type_node, \"case_num\");\n   gfc_add_modify_expr (&block, case_num, tmp);\n "}, {"sha": "fa1bf248aecd9e4057a48d37c83688a5e7fa0fd1", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -874,19 +874,24 @@ gfc_get_pchar_type (int kind)\n /* Create a character type with the given kind and length.  */\n \n tree\n-gfc_get_character_type_len (int kind, tree len)\n+gfc_get_character_type_len_for_eltype (tree eltype, tree len)\n {\n   tree bounds, type;\n \n-  gfc_validate_kind (BT_CHARACTER, kind, false);\n-\n   bounds = build_range_type (gfc_charlen_type_node, gfc_index_one_node, len);\n-  type = build_array_type (gfc_get_char_type (kind), bounds);\n+  type = build_array_type (eltype, bounds);\n   TYPE_STRING_FLAG (type) = 1;\n \n   return type;\n }\n \n+tree\n+gfc_get_character_type_len (int kind, tree len)\n+{\n+  gfc_validate_kind (BT_CHARACTER, kind, false);\n+  return gfc_get_character_type_len_for_eltype (gfc_get_char_type (kind), len);\n+}\n+\n \n /* Get a type node for a character kind.  */\n "}, {"sha": "7074913d4efe566a74fb1ee1fbe45c609fa9f48b", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -59,6 +59,7 @@ tree gfc_get_char_type (int);\n tree gfc_get_pchar_type (int);\n tree gfc_get_character_type (int, gfc_charlen *);\n tree gfc_get_character_type_len (int, tree);\n+tree gfc_get_character_type_len_for_eltype (tree, tree);\n \n tree gfc_sym_type (gfc_symbol *);\n tree gfc_typenode_for_spec (gfc_typespec *);"}, {"sha": "d0ce235412072d6b876c0964529b2a555ae388e8", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -504,7 +504,6 @@ extern GTY(()) tree gfor_fndecl_pause_numeric;\n extern GTY(()) tree gfor_fndecl_pause_string;\n extern GTY(()) tree gfor_fndecl_stop_numeric;\n extern GTY(()) tree gfor_fndecl_stop_string;\n-extern GTY(()) tree gfor_fndecl_select_string;\n extern GTY(()) tree gfor_fndecl_runtime_error;\n extern GTY(()) tree gfor_fndecl_runtime_error_at;\n extern GTY(()) tree gfor_fndecl_os_error;\n@@ -551,6 +550,7 @@ extern GTY(()) tree gfor_fndecl_string_trim;\n extern GTY(()) tree gfor_fndecl_string_minmax;\n extern GTY(()) tree gfor_fndecl_adjustl;\n extern GTY(()) tree gfor_fndecl_adjustr;\n+extern GTY(()) tree gfor_fndecl_select_string;\n extern GTY(()) tree gfor_fndecl_compare_string_char4;\n extern GTY(()) tree gfor_fndecl_concat_string_char4;\n extern GTY(()) tree gfor_fndecl_string_len_trim_char4;\n@@ -561,6 +561,11 @@ extern GTY(()) tree gfor_fndecl_string_trim_char4;\n extern GTY(()) tree gfor_fndecl_string_minmax_char4;\n extern GTY(()) tree gfor_fndecl_adjustl_char4;\n extern GTY(()) tree gfor_fndecl_adjustr_char4;\n+extern GTY(()) tree gfor_fndecl_select_string_char4;\n+\n+/* Conversion between character kinds.  */\n+extern GTY(()) tree gfor_fndecl_convert_char1_to_char4;\n+extern GTY(()) tree gfor_fndecl_convert_char4_to_char1;\n \n /* Other misc. runtime library functions.  */\n extern GTY(()) tree gfor_fndecl_size0;"}, {"sha": "77c5dab835a9e95995e2843edf0d9c719e35118b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -1,3 +1,20 @@\n+2008-05-18  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* gfortran.dg/achar_3.f90: Adjust error messages.\n+\t* gfortran.dg/achar_5.f90: New test.\n+\t* gfortran.dg/achar_6.F90: New test.\n+\t* gfortran.dg/widechar_1.f90: New test.\n+\t* gfortran.dg/widechar_2.f90: New test.\n+\t* gfortran.dg/widechar_3.f90: New test.\n+\t* gfortran.dg/widechar_4.f90: New test.\n+\t* gfortran.dg/widechar_intrinsics_1.f90: New test.\n+\t* gfortran.dg/widechar_intrinsics_2.f90: New test.\n+\t* gfortran.dg/widechar_intrinsics_3.f90: New test.\n+\t* gfortran.dg/widechar_intrinsics_4.f90: New test.\n+\t* gfortran.dg/widechar_intrinsics_5.f90: New test.\n+\t* gfortran.dg/widechar_select_1.f90: New test.\n+\t* gfortran.dg/widechar_select_2.f90: New test.\n+\n 2008-05-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/loop_optimization2.ad[sb]: New test."}, {"sha": "b33bfd11d97f7e678295db204cdcc079e36d353f", "filename": "gcc/testsuite/gfortran.dg/achar_3.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_3.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -1,9 +1,9 @@\n ! { dg-do compile }\n ! { dg-options \"-Wall\" }\n program main\n-  print *,achar(-3)     ! { dg-warning \"outside of range\" }\n+  print *,achar(-3)     ! { dg-error \"negative\" }\n   print *,achar(200)    ! { dg-warning \"outside of range\" }\n-  print *,char(222+221) ! { dg-error \"outside of range\" }\n-  print *,char(-44)     ! { dg-error \"outside of range\" }\n+  print *,char(222+221) ! { dg-error \"too large for the collating sequence\" }\n+  print *,char(-44)     ! { dg-error \"negative\" }\n   print *,iachar(\"\ufffd\")   ! { dg-warning \"outside of range\" }\n end program main"}, {"sha": "c4f78c0173c828ab98f69f34a7da67a08b37f826", "filename": "gcc/testsuite/gfortran.dg/achar_5.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_5.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do compile }\n+!\n+program test\n+\n+  print *, char(255)\n+  print *, achar(255)\n+  print *, char(255,kind=1)\n+  print *, achar(255,kind=1)\n+  print *, char(255,kind=4)\n+  print *, achar(255,kind=4)\n+\n+  print *, char(0)\n+  print *, achar(0)\n+  print *, char(0,kind=1)\n+  print *, achar(0,kind=1)\n+  print *, char(0,kind=4)\n+  print *, achar(0,kind=4)\n+\n+  print *, char(297) ! { dg-error \"too large for the collating sequence\" }\n+  print *, achar(297) ! { dg-error \"too large for the collating sequence\" }\n+  print *, char(297,kind=1) ! { dg-error \"too large for the collating sequence\" }\n+  print *, achar(297,kind=1) ! { dg-error \"too large for the collating sequence\" }\n+  print *, char(297,kind=4)\n+  print *, achar(297,kind=4)\n+\n+  print *, char(-1) ! { dg-error \"negative\" }\n+  print *, achar(-1) ! { dg-error \"negative\" }\n+  print *, char(-1,kind=1) ! { dg-error \"negative\" }\n+  print *, achar(-1,kind=1) ! { dg-error \"negative\" }\n+  print *, char(-1,kind=4) ! { dg-error \"negative\" }\n+  print *, achar(-1,kind=4) ! { dg-error \"negative\" }\n+\n+  print *, char(huge(0_8)) ! { dg-error \"too large for the collating sequence\" }\n+  print *, achar(huge(0_8)) ! { dg-error \"too large for the collating sequence\" }\n+  print *, char(huge(0_8),kind=1) ! { dg-error \"too large for the collating sequence\" }\n+  print *, achar(huge(0_8),kind=1) ! { dg-error \"too large for the collating sequence\" }\n+  print *, char(huge(0_8),kind=4) ! { dg-error \"too large for the collating sequence\" }\n+  print *, achar(huge(0_8),kind=4) ! { dg-error \"too large for the collating sequence\" }\n+\n+  print *, char(z'FFFFFFFF', kind=4)\n+  print *, achar(z'FFFFFFFF', kind=4)\n+  print *, char(z'100000000', kind=4) ! { dg-error \"too large for the collating sequence\" }\n+  print *, achar(z'100000000', kind=4) ! { dg-error \"too large for the collating sequence\" }\n+\n+end program test"}, {"sha": "dd93c27472c0ad03ee85dc047be6f12d8b0531fe", "filename": "gcc/testsuite/gfortran.dg/achar_6.F90", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_6.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_6.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fachar_6.F90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,70 @@\n+! { dg-do run }\n+! { dg-options \"-fbackslash\" }\n+\n+#define TEST(x,y,z) \\\n+  call test (x, y, z, iachar(x), iachar(y), ichar(x), ichar(y))\n+\n+  TEST(\"a\", 4_\"a\", 97)\n+  TEST(\"\\0\", 4_\"\\0\", 0)\n+  TEST(\"\\b\", 4_\"\\b\", 8)\n+  TEST(\"\\x80\", 4_\"\\x80\", int(z'80'))\n+  TEST(\"\\xFF\", 4_\"\\xFF\", int(z'FF'))\n+\n+#define TEST2(y,z) \\\n+  call test_bis (y, z, iachar(y), ichar(y))\n+\n+  TEST2(4_\"\\u0100\", int(z'0100'))\n+  TEST2(4_\"\\ufe00\", int(z'fe00'))\n+  TEST2(4_\"\\u106a\", int(z'106a'))\n+  TEST2(4_\"\\uff00\", int(z'ff00'))\n+  TEST2(4_\"\\uffff\", int(z'ffff'))\n+\n+contains\n+\n+subroutine test (s1, s4, i, i1, i2, i3, i4)\n+  character(kind=1,len=1) :: s1\n+  character(kind=4,len=1) :: s4\n+  integer :: i, i1, i2, i3, i4\n+\n+  if (i /= i1) call abort\n+  if (i /= i2) call abort\n+  if (i /= i3) call abort\n+  if (i /= i4) call abort\n+\n+  if (iachar (s1) /= i) call abort\n+  if (iachar (s4) /= i) call abort\n+  \n+  if (ichar (s1) /= i) call abort\n+  if (ichar (s4) /= i) call abort\n+  \n+  if (achar(i, kind=1) /= s1) call abort\n+  if (achar(i, kind=4) /= s4) call abort\n+\n+  if (char(i, kind=1) /= s1) call abort\n+  if (char(i, kind=4) /= s4) call abort\n+\n+  if (iachar(achar(i, kind=1)) /= i) call abort\n+  if (iachar(achar(i, kind=4)) /= i) call abort\n+\n+  if (ichar(char(i, kind=1)) /= i) call abort\n+  if (ichar(char(i, kind=4)) /= i) call abort\n+\n+end subroutine test\n+\n+subroutine test_bis (s4, i, i2, i4)\n+  character(kind=4,len=1) :: s4\n+  integer :: i, i2, i4\n+\n+  if (i /= i2) call abort\n+  if (i /= i4) call abort\n+\n+  if (iachar (s4) /= i) call abort\n+  if (ichar (s4) /= i) call abort\n+  if (achar(i, kind=4) /= s4) call abort\n+  if (char(i, kind=4) /= s4) call abort\n+  if (iachar(achar(i, kind=4)) /= i) call abort\n+  if (ichar(char(i, kind=4)) /= i) call abort\n+\n+end subroutine test_bis\n+\n+end"}, {"sha": "804de9d7a44edbef038624ac8d195d767131aed6", "filename": "gcc/testsuite/gfortran.dg/widechar_1.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_1.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+! { dg-options \"-fbackslash\" }\n+\n+  character(len=20,kind=4) :: s4\n+  character(len=20,kind=1) :: s1\n+\n+  s1 = \"foo\\u0000\"\n+  s1 = \"foo\\u00ff\"\n+  s1 = \"foo\\u0100\" ! { dg-error \"is not representable\" }\n+  s1 = \"foo\\u0101\" ! { dg-error \"is not representable\" }\n+  s1 = \"foo\\U00000101\" ! { dg-error \"is not representable\" }\n+\n+  s1 = 4_\"foo bar\"\n+  s1 = 4_\"foo\\u00ff\"\n+  s1 = 4_\"foo\\u0101\" ! { dg-error \"cannot be converted\" }\n+  s1 = 4_\"foo\\u1101\" ! { dg-error \"cannot be converted\" }\n+  s1 = 4_\"foo\\UFFFFFFFF\" ! { dg-error \"cannot be converted\" }\n+\n+  s4 = \"foo\\u0000\"\n+  s4 = \"foo\\u00ff\"\n+  s4 = \"foo\\u0100\" ! { dg-error \"is not representable\" }\n+  s4 = \"foo\\U00000100\" ! { dg-error \"is not representable\" }\n+\n+  s4 = 4_\"foo bar\"\n+  s4 = 4_\"\\xFF\\x96\"\n+  s4 = 4_\"\\x00\\x96\"\n+  s4 = 4_\"foo\\u00ff\"\n+  s4 = 4_\"foo\\u0101\"\n+  s4 = 4_\"foo\\u1101\"\n+  s4 = 4_\"foo\\Uab98EF56\"\n+  s4 = 4_\"foo\\UFFFFFFFF\"\n+\n+end"}, {"sha": "706901e6b1cb1f571d41aec806fdef2f7e458807", "filename": "gcc/testsuite/gfortran.dg/widechar_2.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_2.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do run }\n+! { dg-options \"-fbackslash\" }\n+\n+  character(kind=1,len=20) :: s1\n+  character(kind=4,len=20) :: s4\n+\n+  s1 = \"this is me!\"\n+  s4 = s1\n+  call check(s1, 4_\"this is me!         \")\n+  call check2(s1, 4_\"this is me!         \")\n+  s4 = \"this is me!\"\n+  call check(s1, 4_\"this is me!         \")\n+  call check2(s1, 4_\"this is me!         \")\n+\n+  s1 = \"\"\n+  s4 = s1\n+  call check(s1, 4_\"                    \")\n+  call check2(s1, 4_\"                    \")\n+  s4 = \"\"\n+  call check(s1, 4_\"                    \")\n+  call check2(s1, 4_\"                    \")\n+\n+  s1 = \" \\xFF\"\n+  s4 = s1\n+  call check(s1, 4_\" \\xFF                  \")\n+  call check2(s1, 4_\" \\xFF                  \")\n+  s4 = \" \\xFF\"\n+  call check(s1, 4_\" \\xFF                  \")\n+  call check2(s1, 4_\" \\xFF                  \")\n+\n+  s1 = \"  \\xFF\"\n+  s4 = s1\n+  call check(s1, 4_\"  \\xFF                 \")\n+  call check2(s1, 4_\"  \\xFF                 \")\n+  s4 = \"  \\xFF\"\n+  call check(s1, 4_\"  \\xFF                 \")\n+  call check2(s1, 4_\"  \\xFF                 \")\n+\n+contains\n+  subroutine check(s1,s4)\n+    character(kind=1,len=20) :: s1, t1\n+    character(kind=4,len=20) :: s4\n+    t1 = s4\n+    if (t1 /= s1) call abort\n+    if (len(s1) /= len(t1)) call abort\n+    if (len(s1) /= len(s4)) call abort\n+    if (len_trim(s1) /= len_trim(t1)) call abort\n+    if (len_trim(s1) /= len_trim(s4)) call abort\n+  end subroutine check\n+\n+  subroutine check2(s1,s4)\n+    character(kind=1,len=*) :: s1\n+    character(kind=4,len=*) :: s4\n+    character(kind=1,len=len(s1)) :: t1\n+    character(kind=4,len=len(s4)) :: t4\n+\n+    t1 = s4\n+    t4 = s1\n+    if (t1 /= s1) call abort\n+    if (t4 /= s4) call abort\n+    if (len(s1) /= len(t1)) call abort\n+    if (len(s1) /= len(s4)) call abort\n+    if (len(s1) /= len(t4)) call abort\n+    if (len_trim(s1) /= len_trim(t1)) call abort\n+    if (len_trim(s1) /= len_trim(s4)) call abort\n+    if (len_trim(s1) /= len_trim(t4)) call abort\n+  end subroutine check2\n+\n+end"}, {"sha": "653f1d93ac1771e8456b82326dce66db9c6d5267", "filename": "gcc/testsuite/gfortran.dg/widechar_3.f90", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_3.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,112 @@\n+! { dg-do compile }\n+! { dg-options \"-fmax-errors=1000\" }\n+\n+  character(kind=1,len=20) :: s1, t1\n+  character(kind=4,len=20) :: s4, t4\n+\n+  print *, \"\" // \"\"\n+  print *, \"\" // 4_\"\" ! { dg-error \"Operands of string concatenation operator\" }\n+  print *, 4_\"\" // \"\" ! { dg-error \"Operands of string concatenation operator\" }\n+  print *, 4_\"\" // 4_\"\"\n+\n+  print *, s1 // \"\"\n+  print *, s1 // 4_\"\" ! { dg-error \"Operands of string concatenation operator\" }\n+  print *, s4 // \"\" ! { dg-error \"Operands of string concatenation operator\" }\n+  print *, s4 // 4_\"\"\n+\n+  print *, \"\" // s1\n+  print *, 4_\"\" // s1 ! { dg-error \"Operands of string concatenation operator\" }\n+  print *, \"\" // s4 ! { dg-error \"Operands of string concatenation operator\" }\n+  print *, 4_\"\" // s4\n+\n+  print *, s1 // t1\n+  print *, s1 // t4 ! { dg-error \"Operands of string concatenation operator\" }\n+  print *, s4 // t1 ! { dg-error \"Operands of string concatenation operator\" }\n+  print *, s4 // t4\n+\n+  print *, s1 .eq. \"\"\n+  print *, s1 .eq. 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .eq. \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .eq. 4_\"\"\n+\n+  print *, s1 == \"\"\n+  print *, s1 == 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 == \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 == 4_\"\"\n+\n+  print *, s1 .ne. \"\"\n+  print *, s1 .ne. 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .ne. \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .ne. 4_\"\"\n+\n+  print *, s1 /= \"\"\n+  print *, s1 /= 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 /= \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 /= 4_\"\"\n+\n+  print *, s1 .le. \"\"\n+  print *, s1 .le. 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .le. \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .le. 4_\"\"\n+\n+  print *, s1 <= \"\"\n+  print *, s1 <= 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 <= \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 <= 4_\"\"\n+\n+  print *, s1 .ge. \"\"\n+  print *, s1 .ge. 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .ge. \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .ge. 4_\"\"\n+\n+  print *, s1 >= \"\"\n+  print *, s1 >= 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 >= \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 >= 4_\"\"\n+\n+  print *, s1 .lt. \"\"\n+  print *, s1 .lt. 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .lt. \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .lt. 4_\"\"\n+\n+  print *, s1 < \"\"\n+  print *, s1 < 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 < \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 < 4_\"\"\n+\n+  print *, s1 .gt. \"\"\n+  print *, s1 .gt. 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .gt. \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 .gt. 4_\"\"\n+\n+  print *, s1 > \"\"\n+  print *, s1 > 4_\"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 > \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, s4 > 4_\"\"\n+\n+  print *, \"\" ==  \"\"\n+  print *, 4_\"\" ==  \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, \"\" .eq.  \"\"\n+  print *, 4_\"\" .eq.  \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, \"\" /=  \"\"\n+  print *, 4_\"\" /=  \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, \"\" .ne.  \"\"\n+  print *, 4_\"\" .ne.  \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, \"\" .lt.  \"\"\n+  print *, 4_\"\" .lt.  \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, \"\" <  \"\"\n+  print *, 4_\"\" <  \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, \"\" .le.  \"\"\n+  print *, 4_\"\" .le.  \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, \"\" <=  \"\"\n+  print *, 4_\"\" <=  \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, \"\" .gt.  \"\"\n+  print *, 4_\"\" .gt.  \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, \"\" >  \"\"\n+  print *, 4_\"\" >  \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, \"\" .ge.  \"\"\n+  print *, 4_\"\" .ge.  \"\" ! { dg-error \"Operands of comparison operator\" }\n+  print *, \"\" >=  \"\"\n+  print *, 4_\"\" >=  \"\" ! { dg-error \"Operands of comparison operator\" }\n+\n+  end"}, {"sha": "1166f8bfb77934923380ee2846b7465090bf784e", "filename": "gcc/testsuite/gfortran.dg/widechar_4.f90", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_4.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,147 @@\n+! { dg-do run }\n+! { dg-options \"-fbackslash\" }\n+\n+  character(kind=1,len=20) :: s1, t1\n+  character(kind=4,len=20) :: s4, t4\n+\n+  call test (4_\"ccc  \", 4_\"bbb\", 4_\"ccc\", 4_\"ddd\")\n+  call test (4_\" \\xACp  \", 4_\" \\x900000 \", 4_\" \\xACp  \", 4_\"ddd\")\n+  call test (4_\" \\xACp  \", 4_\" \\x900000 \", 4_\" \\xACp  \", 4_\"ddd\")\n+\n+  call test2 (4_\" \\x900000 \", 4_\" \\xACp  \", 4_\"ddd\")\n+\n+contains\n+\n+  subroutine test(s4, t4, u4, v4)\n+    character(kind=4,len=*) :: s4, t4, u4, v4\n+\n+    if (.not. (s4 >= t4)) call abort\n+    if (.not. (s4 > t4)) call abort\n+    if (.not. (s4 .ge. t4)) call abort\n+    if (.not. (s4 .gt. t4)) call abort\n+    if (      (s4 == t4)) call abort\n+    if (.not. (s4 /= t4)) call abort\n+    if (      (s4 .eq. t4)) call abort\n+    if (.not. (s4 .ne. t4)) call abort\n+    if (      (s4 <= t4)) call abort\n+    if (      (s4 < t4)) call abort\n+    if (      (s4 .le. t4)) call abort\n+    if (      (s4 .lt. t4)) call abort\n+\n+    if (.not. (s4 >= u4)) call abort\n+    if (      (s4 > u4)) call abort\n+    if (.not. (s4 .ge. u4)) call abort\n+    if (      (s4 .gt. u4)) call abort\n+    if (.not. (s4 == u4)) call abort\n+    if (      (s4 /= u4)) call abort\n+    if (.not. (s4 .eq. u4)) call abort\n+    if (      (s4 .ne. u4)) call abort\n+    if (.not. (s4 <= u4)) call abort\n+    if (      (s4 < u4)) call abort\n+    if (.not. (s4 .le. u4)) call abort\n+    if (      (s4 .lt. u4)) call abort\n+\n+    if (      (s4 >= v4)) call abort\n+    if (      (s4 > v4)) call abort\n+    if (      (s4 .ge. v4)) call abort\n+    if (      (s4 .gt. v4)) call abort\n+    if (      (s4 == v4)) call abort\n+    if (.not. (s4 /= v4)) call abort\n+    if (      (s4 .eq. v4)) call abort\n+    if (.not. (s4 .ne. v4)) call abort\n+    if (.not. (s4 <= v4)) call abort\n+    if (.not. (s4 < v4)) call abort\n+    if (.not. (s4 .le. v4)) call abort\n+    if (.not. (s4 .lt. v4)) call abort\n+\n+  end subroutine test\n+\n+  subroutine test2(t4, u4, v4)\n+    character(kind=4,len=*) :: t4, u4, v4\n+\n+    if (.not. (4_\" \\xACp  \" >= t4)) call abort\n+    if (.not. (4_\" \\xACp  \" > t4)) call abort\n+    if (.not. (4_\" \\xACp  \" .ge. t4)) call abort\n+    if (.not. (4_\" \\xACp  \" .gt. t4)) call abort\n+    if (      (4_\" \\xACp  \" == t4)) call abort\n+    if (.not. (4_\" \\xACp  \" /= t4)) call abort\n+    if (      (4_\" \\xACp  \" .eq. t4)) call abort\n+    if (.not. (4_\" \\xACp  \" .ne. t4)) call abort\n+    if (      (4_\" \\xACp  \" <= t4)) call abort\n+    if (      (4_\" \\xACp  \" < t4)) call abort\n+    if (      (4_\" \\xACp  \" .le. t4)) call abort\n+    if (      (4_\" \\xACp  \" .lt. t4)) call abort\n+\n+    if (.not. (4_\" \\xACp  \" >= u4)) call abort\n+    if (      (4_\" \\xACp  \" > u4)) call abort\n+    if (.not. (4_\" \\xACp  \" .ge. u4)) call abort\n+    if (      (4_\" \\xACp  \" .gt. u4)) call abort\n+    if (.not. (4_\" \\xACp  \" == u4)) call abort\n+    if (      (4_\" \\xACp  \" /= u4)) call abort\n+    if (.not. (4_\" \\xACp  \" .eq. u4)) call abort\n+    if (      (4_\" \\xACp  \" .ne. u4)) call abort\n+    if (.not. (4_\" \\xACp  \" <= u4)) call abort\n+    if (      (4_\" \\xACp  \" < u4)) call abort\n+    if (.not. (4_\" \\xACp  \" .le. u4)) call abort\n+    if (      (4_\" \\xACp  \" .lt. u4)) call abort\n+\n+    if (      (4_\" \\xACp  \" >= v4)) call abort\n+    if (      (4_\" \\xACp  \" > v4)) call abort\n+    if (      (4_\" \\xACp  \" .ge. v4)) call abort\n+    if (      (4_\" \\xACp  \" .gt. v4)) call abort\n+    if (      (4_\" \\xACp  \" == v4)) call abort\n+    if (.not. (4_\" \\xACp  \" /= v4)) call abort\n+    if (      (4_\" \\xACp  \" .eq. v4)) call abort\n+    if (.not. (4_\" \\xACp  \" .ne. v4)) call abort\n+    if (.not. (4_\" \\xACp  \" <= v4)) call abort\n+    if (.not. (4_\" \\xACp  \" < v4)) call abort\n+    if (.not. (4_\" \\xACp  \" .le. v4)) call abort\n+    if (.not. (4_\" \\xACp  \" .lt. v4)) call abort\n+\n+  end subroutine test2\n+\n+  subroutine test3(t4, u4, v4)\n+    character(kind=4,len=*) :: t4, u4, v4\n+\n+    if (.not. (4_\" \\xACp  \" >= 4_\" \\x900000 \")) call abort\n+    if (.not. (4_\" \\xACp  \" > 4_\" \\x900000 \")) call abort\n+    if (.not. (4_\" \\xACp  \" .ge. 4_\" \\x900000 \")) call abort\n+    if (.not. (4_\" \\xACp  \" .gt. 4_\" \\x900000 \")) call abort\n+    if (      (4_\" \\xACp  \" == 4_\" \\x900000 \")) call abort\n+    if (.not. (4_\" \\xACp  \" /= 4_\" \\x900000 \")) call abort\n+    if (      (4_\" \\xACp  \" .eq. 4_\" \\x900000 \")) call abort\n+    if (.not. (4_\" \\xACp  \" .ne. 4_\" \\x900000 \")) call abort\n+    if (      (4_\" \\xACp  \" <= 4_\" \\x900000 \")) call abort\n+    if (      (4_\" \\xACp  \" < 4_\" \\x900000 \")) call abort\n+    if (      (4_\" \\xACp  \" .le. 4_\" \\x900000 \")) call abort\n+    if (      (4_\" \\xACp  \" .lt. 4_\" \\x900000 \")) call abort\n+\n+    if (.not. (4_\" \\xACp  \" >= 4_\" \\xACp  \")) call abort\n+    if (      (4_\" \\xACp  \" > 4_\" \\xACp  \")) call abort\n+    if (.not. (4_\" \\xACp  \" .ge. 4_\" \\xACp  \")) call abort\n+    if (      (4_\" \\xACp  \" .gt. 4_\" \\xACp  \")) call abort\n+    if (.not. (4_\" \\xACp  \" == 4_\" \\xACp  \")) call abort\n+    if (      (4_\" \\xACp  \" /= 4_\" \\xACp  \")) call abort\n+    if (.not. (4_\" \\xACp  \" .eq. 4_\" \\xACp  \")) call abort\n+    if (      (4_\" \\xACp  \" .ne. 4_\" \\xACp  \")) call abort\n+    if (.not. (4_\" \\xACp  \" <= 4_\" \\xACp  \")) call abort\n+    if (      (4_\" \\xACp  \" < 4_\" \\xACp  \")) call abort\n+    if (.not. (4_\" \\xACp  \" .le. 4_\" \\xACp  \")) call abort\n+    if (      (4_\" \\xACp  \" .lt. 4_\" \\xACp  \")) call abort\n+\n+    if (      (4_\" \\xACp  \" >= 4_\"ddd\")) call abort\n+    if (      (4_\" \\xACp  \" > 4_\"ddd\")) call abort\n+    if (      (4_\" \\xACp  \" .ge. 4_\"ddd\")) call abort\n+    if (      (4_\" \\xACp  \" .gt. 4_\"ddd\")) call abort\n+    if (      (4_\" \\xACp  \" == 4_\"ddd\")) call abort\n+    if (.not. (4_\" \\xACp  \" /= 4_\"ddd\")) call abort\n+    if (      (4_\" \\xACp  \" .eq. 4_\"ddd\")) call abort\n+    if (.not. (4_\" \\xACp  \" .ne. 4_\"ddd\")) call abort\n+    if (.not. (4_\" \\xACp  \" <= 4_\"ddd\")) call abort\n+    if (.not. (4_\" \\xACp  \" < 4_\"ddd\")) call abort\n+    if (.not. (4_\" \\xACp  \" .le. 4_\"ddd\")) call abort\n+    if (.not. (4_\" \\xACp  \" .lt. 4_\"ddd\")) call abort\n+\n+  end subroutine test3\n+\n+end"}, {"sha": "cb9804296dd9d3ce9facded9301ad49e594c2dff", "filename": "gcc/testsuite/gfortran.dg/widechar_intrinsics_1.f90", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_1.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,116 @@\n+! { dg-do compile }\n+! { dg-options \"-fmax-errors=100000\" }\n+\n+  character(kind=1,len=20) :: s1, t1, u1, v1\n+  character(kind=4,len=20) :: s4, t4, u4, v4\n+\n+  call date_and_time(date=s1)\n+  call date_and_time(time=s1)\n+  call date_and_time(zone=s1)\n+  call date_and_time(s1, t1, u1)\n+\n+  call date_and_time(date=s4) ! { dg-error \"must be of kind 1\" }\n+  call date_and_time(time=s4) ! { dg-error \"must be of kind 1\" }\n+  call date_and_time(zone=s4) ! { dg-error \"must be of kind 1\" }\n+  call date_and_time(s4, t4, u4) ! { dg-error \"must be of kind 1\" }\n+\n+  call get_command(s1)\n+  call get_command(s4) ! { dg-error \"Type of argument\" }\n+\n+  call get_command_argument(1, s1)\n+  call get_command_argument(1, s4) ! { dg-error \"Type of argument\" }\n+\n+  call get_environment_variable(\"PATH\", s1)\n+  call get_environment_variable(s1)\n+  call get_environment_variable(s1, t1)\n+  call get_environment_variable(4_\"PATH\", s1) ! { dg-error \"Type of argument\" }\n+  call get_environment_variable(s4) ! { dg-error \"Type of argument\" }\n+  call get_environment_variable(s1, t4) ! { dg-error \"Type of argument\" }\n+  call get_environment_variable(s4, t1) ! { dg-error \"Type of argument\" }\n+\n+  print *, lge(s1,t1)\n+  print *, lge(s1,\"foo\")\n+  print *, lge(\"foo\",t1)\n+  print *, lge(\"bar\",\"foo\")\n+\n+  print *, lge(s1,t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lge(s1,4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, lge(\"foo\",t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lge(\"bar\",4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, lge(s4,t1) ! { dg-error \"must be of kind 1\" }\n+  print *, lge(s4,\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, lge(4_\"foo\",t1) ! { dg-error \"must be of kind 1\" }\n+  print *, lge(4_\"bar\",\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, lge(s4,t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lge(s4,4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, lge(4_\"foo\",t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lge(4_\"bar\",4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, lgt(s1,t1)\n+  print *, lgt(s1,\"foo\")\n+  print *, lgt(\"foo\",t1)\n+  print *, lgt(\"bar\",\"foo\")\n+\n+  print *, lgt(s1,t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lgt(s1,4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, lgt(\"foo\",t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lgt(\"bar\",4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, lgt(s4,t1) ! { dg-error \"must be of kind 1\" }\n+  print *, lgt(s4,\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, lgt(4_\"foo\",t1) ! { dg-error \"must be of kind 1\" }\n+  print *, lgt(4_\"bar\",\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, lgt(s4,t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lgt(s4,4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, lgt(4_\"foo\",t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lgt(4_\"bar\",4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, lle(s1,t1)\n+  print *, lle(s1,\"foo\")\n+  print *, lle(\"foo\",t1)\n+  print *, lle(\"bar\",\"foo\")\n+\n+  print *, lle(s1,t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lle(s1,4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, lle(\"foo\",t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lle(\"bar\",4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, lle(s4,t1) ! { dg-error \"must be of kind 1\" }\n+  print *, lle(s4,\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, lle(4_\"foo\",t1) ! { dg-error \"must be of kind 1\" }\n+  print *, lle(4_\"bar\",\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, lle(s4,t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lle(s4,4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, lle(4_\"foo\",t4) ! { dg-error \"must be of kind 1\" }\n+  print *, lle(4_\"bar\",4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, llt(s1,t1)\n+  print *, llt(s1,\"foo\")\n+  print *, llt(\"foo\",t1)\n+  print *, llt(\"bar\",\"foo\")\n+\n+  print *, llt(s1,t4) ! { dg-error \"must be of kind 1\" }\n+  print *, llt(s1,4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, llt(\"foo\",t4) ! { dg-error \"must be of kind 1\" }\n+  print *, llt(\"bar\",4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, llt(s4,t1) ! { dg-error \"must be of kind 1\" }\n+  print *, llt(s4,\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, llt(4_\"foo\",t1) ! { dg-error \"must be of kind 1\" }\n+  print *, llt(4_\"bar\",\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, llt(s4,t4) ! { dg-error \"must be of kind 1\" }\n+  print *, llt(s4,4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, llt(4_\"foo\",t4) ! { dg-error \"must be of kind 1\" }\n+  print *, llt(4_\"bar\",4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+\n+  print *, selected_char_kind(\"foo\")\n+  print *, selected_char_kind(4_\"foo\") ! { dg-error \"must be of kind 1\" }\n+  print *, selected_char_kind(s1)\n+  print *, selected_char_kind(s4) ! { dg-error \"must be of kind 1\" }\n+\n+  end"}, {"sha": "0a1d449b60564caeda90c139775abb59325ea273", "filename": "gcc/testsuite/gfortran.dg/widechar_intrinsics_2.f90", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_2.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,129 @@\n+! { dg-do compile }\n+! { dg-options \"-fmax-errors=1000\" }\n+\n+program failme\n+\n+  integer :: i, j, array(20)\n+  integer(kind=4) :: i4\n+  integer(kind=8) :: i8\n+  character(kind=1,len=20) :: s1, t1\n+  character(kind=4,len=20) :: s4, t4\n+\n+  call ctime (i8, s1)\n+  call ctime (i8, s4) ! { dg-error \"must be of kind\" }\n+\n+  call chdir (s1)\n+  call chdir (s1, i)\n+  call chdir (s4) ! { dg-error \"must be of kind\" }\n+  call chdir (s4, i) ! { dg-error \"must be of kind\" }\n+\n+  call chmod (s1, t1)\n+  call chmod (s1, t4) ! { dg-error \"must be of kind\" }\n+  call chmod (s4, t1) ! { dg-error \"must be of kind\" }\n+  call chmod (s4, t4) ! { dg-error \"must be of kind\" }\n+  call chmod (s1, t1, i)\n+  call chmod (s1, t4, i) ! { dg-error \"must be of kind\" }\n+  call chmod (s4, t1, i) ! { dg-error \"must be of kind\" }\n+  call chmod (s4, t4, i) ! { dg-error \"must be of kind\" }\n+\n+  call fdate (s1)\n+  call fdate (s4) ! { dg-error \"must be of kind\" }\n+\n+  call gerror (s1)\n+  call gerror (s4) ! { dg-error \"must be of kind\" }\n+\n+  call getcwd (s1)\n+  call getcwd (s1, i)\n+  call getcwd (s4) ! { dg-error \"must be of kind\" }\n+  call getcwd (s4, i) ! { dg-error \"must be of kind\" }\n+\n+  call getenv (s1, t1)\n+  call getenv (s1, t4) ! { dg-error \"Type of argument\" }\n+  call getenv (s4, t1) ! { dg-error \"Type of argument\" }\n+  call getenv (s4, t4) ! { dg-error \"Type of argument\" }\n+\n+  call getarg (i, s1)\n+  call getarg (i, s4) ! { dg-error \"must be of kind\" }\n+\n+  call getlog (s1)\n+  call getlog (s4) ! { dg-error \"must be of kind\" }\n+\n+  call fgetc (j, s1)\n+  call fgetc (j, s1, i)\n+  call fgetc (j, s4) ! { dg-error \"must be of kind\" }\n+  call fgetc (j, s4, i) ! { dg-error \"must be of kind\" }\n+\n+  call fget (s1)\n+  call fget (s1, i)\n+  call fget (s4) ! { dg-error \"must be of kind\" }\n+  call fget (s4, i) ! { dg-error \"must be of kind\" }\n+\n+  call fputc (j, s1)\n+  call fputc (j, s1, i)\n+  call fputc (j, s4) ! { dg-error \"must be of kind\" }\n+  call fputc (j, s4, i) ! { dg-error \"must be of kind\" }\n+\n+  call fput (s1)\n+  call fput (s1, i)\n+  call fput (s4) ! { dg-error \"must be of kind\" }\n+  call fput (s4, i) ! { dg-error \"must be of kind\" }\n+\n+  call hostnm (s1)\n+  call hostnm (s1, i)\n+  call hostnm (s4) ! { dg-error \"must be of kind\" }\n+  call hostnm (s4, i) ! { dg-error \"must be of kind\" }\n+\n+  call link (s1, t1)\n+  call link (s1, t4) ! { dg-error \"must be of kind\" }\n+  call link (s4, t1) ! { dg-error \"must be of kind\" }\n+  call link (s4, t4) ! { dg-error \"must be of kind\" }\n+  call link (s1, t1, i)\n+  call link (s1, t4, i) ! { dg-error \"must be of kind\" }\n+  call link (s4, t1, i) ! { dg-error \"must be of kind\" }\n+  call link (s4, t4, i) ! { dg-error \"must be of kind\" }\n+\n+  call perror (s1)\n+  call perror (s4) ! { dg-error \"must be of kind\" }\n+\n+  call rename (s1, t1)\n+  call rename (s1, t4) ! { dg-error \"must be of kind\" }\n+  call rename (s4, t1) ! { dg-error \"must be of kind\" }\n+  call rename (s4, t4) ! { dg-error \"must be of kind\" }\n+  call rename (s1, t1, i)\n+  call rename (s1, t4, i) ! { dg-error \"must be of kind\" }\n+  call rename (s4, t1, i) ! { dg-error \"must be of kind\" }\n+  call rename (s4, t4, i) ! { dg-error \"must be of kind\" }\n+\n+  call lstat (s1, array)\n+  call lstat (s1, array, i)\n+  call lstat (s4, array) ! { dg-error \"must be of kind\" }\n+  call lstat (s4, array, i) ! { dg-error \"must be of kind\" }\n+\n+  call stat (s1, array)\n+  call stat (s1, array, i)\n+  call stat (s4, array) ! { dg-error \"must be of kind\" }\n+  call stat (s4, array, i) ! { dg-error \"must be of kind\" }\n+\n+  call symlnk (s1, t1)\n+  call symlnk (s1, t4) ! { dg-error \"must be of kind\" }\n+  call symlnk (s4, t1) ! { dg-error \"must be of kind\" }\n+  call symlnk (s4, t4) ! { dg-error \"must be of kind\" }\n+  call symlnk (s1, t1, i)\n+  call symlnk (s1, t4, i) ! { dg-error \"must be of kind\" }\n+  call symlnk (s4, t1, i) ! { dg-error \"must be of kind\" }\n+  call symlnk (s4, t4, i) ! { dg-error \"must be of kind\" }\n+\n+  call system (s1)\n+  call system (s1, i)\n+  call system (s4) ! { dg-error \"Type of argument\" }\n+  call system (s4, i) ! { dg-error \"Type of argument\" }\n+\n+  call ttynam (i, s1)\n+  call ttynam (i, s4) ! { dg-error \"must be of kind\" }\n+\n+  call unlink (s1)\n+  call unlink (s1, i)\n+  call unlink (s4) ! { dg-error \"must be of kind\" }\n+  call unlink (s4, i) ! { dg-error \"must be of kind\" }\n+\n+end program failme"}, {"sha": "7073b893bb3f93511b934a6e5332cf0f48dc6d52", "filename": "gcc/testsuite/gfortran.dg/widechar_intrinsics_3.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_3.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do compile }\n+! { dg-options \"-fmax-errors=1000\" }\n+\n+program failme\n+\n+  integer :: i, array(20)\n+  integer(kind=4) :: i4\n+  integer(kind=8) :: i8\n+  character(kind=1,len=20) :: s1, t1\n+  character(kind=4,len=20) :: s4, t4\n+\n+  print *, access (s1, t1)\n+  print *, access (s1, t4) ! { dg-error \"must be of kind\" }\n+  print *, access (s4, t1) ! { dg-error \"must be of kind\" }\n+  print *, access (s4, t4) ! { dg-error \"must be of kind\" }\n+\n+  print *, chdir (s1)\n+  print *, chdir (s4) ! { dg-error \"must be of kind\" }\n+\n+  print *, chmod (s1, t1)\n+  print *, chmod (s1, t4) ! { dg-error \"must be of kind\" }\n+  print *, chmod (s4, t1) ! { dg-error \"must be of kind\" }\n+  print *, chmod (s4, t4) ! { dg-error \"must be of kind\" }\n+\n+  print *, fget (s1)\n+  print *, fget (s4) ! { dg-error \"must be of kind\" }\n+\n+  print *, fgetc (i, s1)\n+  print *, fgetc (i, s4) ! { dg-error \"must be of kind\" }\n+\n+  print *, fput (s1)\n+  print *, fput (s4) ! { dg-error \"must be of kind\" }\n+\n+  print *, fputc (i, s1)\n+  print *, fputc (i, s4) ! { dg-error \"must be of kind\" }\n+\n+  print *, getcwd (s1)\n+  print *, getcwd (s4) ! { dg-error \"Type of argument\" }\n+\n+  print *, hostnm (s1)\n+  print *, hostnm (s4) ! { dg-error \"must be of kind\" }\n+\n+  print *, link (s1, t1)\n+  print *, link (s1, t4) ! { dg-error \"must be of kind\" }\n+  print *, link (s4, t1) ! { dg-error \"must be of kind\" }\n+  print *, link (s4, t4) ! { dg-error \"must be of kind\" }\n+\n+  print *, lstat (s1, array)\n+  print *, lstat (s4, array) ! { dg-error \"must be of kind\" }\n+  print *, stat (s1, array)\n+  print *, stat (s4, array) ! { dg-error \"must be of kind\" }\n+\n+  print *, rename (s1, t1)\n+  print *, rename (s1, t4) ! { dg-error \"must be of kind\" }\n+  print *, rename (s4, t1) ! { dg-error \"must be of kind\" }\n+  print *, rename (s4, t4) ! { dg-error \"must be of kind\" }\n+\n+  print *, symlnk (s1, t1)\n+  print *, symlnk (s1, t4) ! { dg-error \"must be of kind\" }\n+  print *, symlnk (s4, t1) ! { dg-error \"must be of kind\" }\n+  print *, symlnk (s4, t4) ! { dg-error \"must be of kind\" }\n+\n+  print *, system (s1)\n+  print *, system (s4) ! { dg-error \"Type of argument\" }\n+\n+  print *, unlink (s1)\n+  print *, unlink (s4) ! { dg-error \"must be of kind\" }\n+\n+end program failme"}, {"sha": "c9f8e8cd26c64b5fa6f0216b73f4878a7d9b1a89", "filename": "gcc/testsuite/gfortran.dg/widechar_intrinsics_4.f90", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_4.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,121 @@\n+! { dg-do run }\n+! { dg-options \"-fbackslash\" }\n+\n+  character(kind=1,len=20) :: s1\n+  character(kind=4,len=20) :: s4\n+\n+  call test_adjust1 (\"  foo bar \", 4_\"  foo bar \")\n+  s1 = \"  foo bar \" ; s4 = 4_\"  foo bar \"\n+  call test_adjust2 (s1, s4)\n+\n+  call test_adjust1 (\"  foo bar \\xFF\", 4_\"  foo bar \\xFF\")\n+  s1 = \"  foo bar \\xFF\" ; s4 = 4_\"  foo bar \\xFF\"\n+  call test_adjust2 (s1, s4)\n+\n+  call test_adjust1 (\"\\0  foo bar \\xFF\", 4_\"\\0  foo bar \\xFF\")\n+  s1 = \"\\0  foo bar \\xFF\" ; s4 = 4_\"\\0  foo bar \\xFF\"\n+  call test_adjust2 (s1, s4)\n+\n+  s4 = \"\\0  foo bar \\xFF\"\n+  if (adjustl (s4) /= adjustl (4_\"\\0  foo bar \\xFF        \")) call abort\n+  if (adjustr (s4) /= adjustr (4_\"\\0  foo bar \\xFF        \")) call abort\n+\n+  s4 = \"   \\0  foo bar \\xFF\"\n+  if (adjustl (s4) /= adjustl (4_\"   \\0  foo bar \\xFF     \")) call abort\n+  if (adjustr (s4) /= adjustr (4_\"   \\0  foo bar \\xFF     \")) call abort\n+\n+  s4 = 4_\" \\U12345678\\xeD bar \\ufd30\"\n+  if (adjustl (s4) /= &\n+      adjustl (4_\" \\U12345678\\xeD bar \\ufd30           \")) call abort\n+  if (adjustr (s4) /= &\n+      adjustr (4_\" \\U12345678\\xeD bar \\ufd30           \")) call abort\n+\n+contains\n+\n+  subroutine test_adjust1 (s1, s4)\n+\n+    character(kind=1,len=*) :: s1\n+    character(kind=4,len=*) :: s4\n+\n+    character(kind=1,len=len(s4)) :: t1\n+    character(kind=4,len=len(s1)) :: t4\n+\n+    if (len(s1) /= len(s4)) call abort\n+    if (len(t1) /= len(t4)) call abort\n+\n+    if (len_trim(s1) /= len_trim (s4)) call abort\n+\n+    t1 = adjustl (s4)\n+    t4 = adjustl (s1)\n+    if (t1 /= adjustl (s1)) call abort\n+    if (t4 /= adjustl (s4)) call abort\n+    if (len_trim (t1) /= len_trim (t4)) call abort\n+    if (len_trim (adjustl (s1)) /= len_trim (t4)) call abort\n+    if (len_trim (adjustl (s4)) /= len_trim (t1)) call abort\n+\n+    if (len_trim (t1) /= len (trim (t1))) call abort\n+    if (len_trim (s1) /= len (trim (s1))) call abort\n+    if (len_trim (t4) /= len (trim (t4))) call abort\n+    if (len_trim (s4) /= len (trim (s4))) call abort\n+\n+    t1 = adjustr (s4)\n+    t4 = adjustr (s1)\n+    if (t1 /= adjustr (s1)) call abort\n+    if (t4 /= adjustr (s4)) call abort\n+    if (len_trim (t1) /= len_trim (t4)) call abort\n+    if (len_trim (adjustr (s1)) /= len_trim (t4)) call abort\n+    if (len_trim (adjustr (s4)) /= len_trim (t1)) call abort\n+    if (len (t1) /= len_trim (t1)) call abort\n+    if (len (t4) /= len_trim (t4)) call abort\n+\n+    if (len_trim (t1) /= len (trim (t1))) call abort\n+    if (len_trim (s1) /= len (trim (s1))) call abort\n+    if (len_trim (t4) /= len (trim (t4))) call abort\n+    if (len_trim (s4) /= len (trim (s4))) call abort\n+\n+  end subroutine test_adjust1\n+\n+  subroutine test_adjust2 (s1, s4)\n+\n+    character(kind=1,len=20) :: s1\n+    character(kind=4,len=20) :: s4\n+\n+    character(kind=1,len=len(s4)) :: t1\n+    character(kind=4,len=len(s1)) :: t4\n+\n+    if (len(s1) /= len(s4)) call abort\n+    if (len(t1) /= len(t4)) call abort\n+\n+    if (len_trim(s1) /= len_trim (s4)) call abort\n+\n+    t1 = adjustl (s4)\n+    t4 = adjustl (s1)\n+    if (t1 /= adjustl (s1)) call abort\n+    if (t4 /= adjustl (s4)) call abort\n+    if (len_trim (t1) /= len_trim (t4)) call abort\n+    if (len_trim (adjustl (s1)) /= len_trim (t4)) call abort\n+    if (len_trim (adjustl (s4)) /= len_trim (t1)) call abort\n+\n+    if (len_trim (t1) /= len (trim (t1))) call abort\n+    if (len_trim (s1) /= len (trim (s1))) call abort\n+    if (len_trim (t4) /= len (trim (t4))) call abort\n+    if (len_trim (s4) /= len (trim (s4))) call abort\n+\n+    t1 = adjustr (s4)\n+    t4 = adjustr (s1)\n+    if (t1 /= adjustr (s1)) call abort\n+    if (t4 /= adjustr (s4)) call abort\n+    if (len_trim (t1) /= len_trim (t4)) call abort\n+    if (len_trim (adjustr (s1)) /= len_trim (t4)) call abort\n+    if (len_trim (adjustr (s4)) /= len_trim (t1)) call abort\n+    if (len (t1) /= len_trim (t1)) call abort\n+    if (len (t4) /= len_trim (t4)) call abort\n+\n+    if (len_trim (t1) /= len (trim (t1))) call abort\n+    if (len_trim (s1) /= len (trim (s1))) call abort\n+    if (len_trim (t4) /= len (trim (t4))) call abort\n+    if (len_trim (s4) /= len (trim (s4))) call abort\n+\n+  end subroutine test_adjust2\n+\n+end"}, {"sha": "8475a67906b8d8cca66d0991182f52b89d9fa526", "filename": "gcc/testsuite/gfortran.dg/widechar_intrinsics_5.f90", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_intrinsics_5.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,120 @@\n+  implicit none\n+  integer :: i, j\n+  character(kind=4,len=5), dimension(3,3), parameter :: &\n+    p = reshape([4_\" \\xFF   \", 4_\"\\0    \", 4_\" foo \", &\n+                 4_\"\\u1230\\uD67Bde\\U31DC8B30\", 4_\"\", 4_\"fa fe\", &\n+                 4_\"\", 4_\"foo  \", 4_\"nul\\0l\"], [3,3])\n+       \n+  character(kind=4,len=5), dimension(3,3) :: m1\n+  character(kind=4,len=5), allocatable, dimension(:,:) :: m2\n+\n+  if (kind (p) /= 4) call abort\n+  if (kind (m1) /= 4) call abort\n+  if (kind (m2) /= 4) call abort\n+\n+  m1 = reshape (p, [3,3])\n+\n+  allocate (m2(3,3))\n+  m2(:,:) = reshape (m1, [3,3])\n+\n+  if (any (m1 /= p)) call abort\n+  if (any (m2 /= p)) call abort\n+\n+  if (size (p) /= 9) call abort\n+  if (size (m1) /= 9) call abort\n+  if (size (m2) /= 9) call abort\n+  if (size (p,1) /= 3) call abort\n+  if (size (m1,1) /= 3) call abort\n+  if (size (m2,1) /= 3) call abort\n+  if (size (p,2) /= 3) call abort\n+  if (size (m1,2) /= 3) call abort\n+  if (size (m2,2) /= 3) call abort\n+\n+  call check_shape (p, (/3,3/), 5)\n+  call check_shape (p, shape(p), 5)\n+  call check_shape (m1, (/3,3/), 5)\n+  call check_shape (m1, shape(m1), 5)\n+  call check_shape (m1, (/3,3/), 5)\n+  call check_shape (m1, shape(m1), 5)\n+\n+  deallocate (m2)\n+\n+\n+  allocate (m2(3,4))\n+  m2 = reshape (m1, [3,4], p)\n+  if (any (m2(1:3,1:3) /= p)) call abort\n+  if (any (m2(1:3,4) /= m1(1:3,1))) call abort\n+  call check_shape (m2, (/3,4/), 5)\n+  deallocate (m2)\n+\n+  allocate (m2(3,3))\n+  do i = 1, 3\n+    do j = 1, 3\n+      m2(i,j) = m1(i,j)\n+    end do\n+  end do\n+\n+  m2 = transpose(m2)\n+  if (any(transpose(p) /= m2)) call abort\n+  if (any(transpose(m1) /= m2)) call abort\n+  if (any(transpose(m2) /= p)) call abort\n+  if (any(transpose(m2) /= m1)) call abort\n+\n+  m1 = transpose(p)\n+  if (any(transpose(p) /= m2)) call abort\n+  if (any(m1 /= m2)) call abort\n+  if (any(transpose(m2) /= p)) call abort\n+  if (any(transpose(m2) /= transpose(m1))) call abort\n+  deallocate (m2)\n+\n+  ! Tests below should be uncommented when PR36257 is fixed.\n+  !\n+  !allocate (m2(3,3))\n+  !m2 = p\n+  !m1 = m2\n+  !if (any (spread ( p, 1, 2) /= spread (m1, 1, 2))) call abort\n+  !if (any (spread ( p, 1, 2) /= spread (m2, 1, 2))) call abort\n+  !if (any (spread (m1, 1, 2) /= spread (m2, 1, 2))) call abort\n+  !deallocate (m2)\n+\n+  allocate (m2(3,3))\n+  m2 = p\n+  m1 = m2\n+  if (any (pack (p, p /= 4_\"\") /= [4_\" \\xFF   \", 4_\"\\0    \", 4_\" foo \", &\n+                                   4_\"\\u1230\\uD67Bde\\U31DC8B30\", 4_\"fa fe\", &\n+                                   4_\"foo  \", 4_\"nul\\0l\"])) call abort\n+  if (any (len_trim (pack (p, p /= 4_\"\")) /= [2,1,4,5,5,3,5])) call abort\n+  if (any (pack (m1, m1 /= 4_\"\") /= [4_\" \\xFF   \", 4_\"\\0    \", 4_\" foo \", &\n+                                   4_\"\\u1230\\uD67Bde\\U31DC8B30\", 4_\"fa fe\", &\n+                                   4_\"foo  \", 4_\"nul\\0l\"])) call abort\n+  if (any (len_trim (pack (m1, m1 /= 4_\"\")) /= [2,1,4,5,5,3,5])) call abort\n+  if (any (pack (m2, m2 /= 4_\"\") /= [4_\" \\xFF   \", 4_\"\\0    \", 4_\" foo \", &\n+                                   4_\"\\u1230\\uD67Bde\\U31DC8B30\", 4_\"fa fe\", &\n+                                   4_\"foo  \", 4_\"nul\\0l\"])) call abort\n+  if (any (len_trim (pack (m2, m2 /= 4_\"\")) /= [2,1,4,5,5,3,5])) call abort\n+  deallocate (m2)\n+\n+  allocate (m2(1,7))\n+  m2 = reshape ([4_\" \\xFF   \", 4_\"\\0    \", 4_\" foo \", &\n+                 4_\"\\u1230\\uD67Bde\\U31DC8B30\", 4_\"fa fe\", &\n+                 4_\"foo  \", 4_\"nul\\0l\"], [1,7])\n+  m1 = p\n+  if (any (unpack(m2(1,:), p /= 4_\"\", 4_\"     \") /= p)) call abort\n+  if (any (unpack(m2(1,:), m1 /= 4_\"\", 4_\"     \") /= m1)) call abort\n+  deallocate (m2)\n+\n+contains\n+\n+  subroutine check_shape (array, res, l)\n+    character(kind=4,len=*), dimension(:,:) :: array\n+    integer, dimension(:) :: res\n+    integer :: l\n+\n+    if (kind (array) /= 4) call abort\n+    if (len(array) /= l) call abort\n+\n+    if (size (res) /= size (shape (array))) call abort\n+    if (any (shape (array) /= res)) call abort\n+  end subroutine check_shape\n+\n+end"}, {"sha": "64315af0b71e75d9724cc140763f5128b76c6c97", "filename": "gcc/testsuite/gfortran.dg/widechar_select_1.f90", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_select_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_select_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_select_1.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do run }\n+! { dg-options \"-fbackslash\" }\n+\n+  call testme(test(\"foo\"), test4(4_\"foo\"), 1)\n+  call testme(test(\"\"), test4(4_\"\"), 1)\n+  call testme(test(\"gee\"), test4(4_\"gee\"), 4)\n+  call testme(test(\"bar\"), test4(4_\"bar\"), 1)\n+  call testme(test(\"magi\"), test4(4_\"magi\"), 4)\n+  call testme(test(\"magic\"), test4(4_\"magic\"), 2)\n+  call testme(test(\"magic   \"), test4(4_\"magic   \"), 2)\n+  call testme(test(\"magica\"), test4(4_\"magica\"), 4)\n+  call testme(test(\"freeze\"), test4(4_\"freeze\"), 3)\n+  call testme(test(\"freeze \"), test4(4_\"freeze \"), 3)\n+  call testme(test(\"frugal\"), test4(4_\"frugal\"), 3)\n+  call testme(test(\"frugal \"), test4(4_\"frugal \"), 3)\n+  call testme(test(\"frugal \\x01\"), test4(4_\"frugal \\x01\"), 3)\n+  call testme(test(\"frugal \\xFF\"), test4(4_\"frugal \\xFF\"), 4)\n+\n+contains\n+  integer function test(s)\n+    character(len=*) :: s\n+  \n+    select case (s)\n+      case (\"\":\"foo\")\n+        test = 1\n+      case (\"magic\")\n+        test = 2\n+      case (\"freeze\":\"frugal\")\n+        test = 3\n+      case default\n+        test = 4\n+    end select\n+  end function test\n+\n+  integer function test4(s)\n+    character(kind=4,len=*) :: s\n+  \n+    select case (s)\n+      case (4_\"\":4_\"foo\")\n+        test4 = 1\n+      case (4_\"magic\")\n+        test4 = 2\n+      case (4_\"freeze\":4_\"frugal\")\n+        test4 = 3\n+      case default\n+        test4 = 4\n+    end select\n+  end function test4\n+\n+  subroutine testme(x,y,z)\n+    integer :: x, y, z\n+    if (x /= y) call abort\n+    if (x /= z) call abort\n+  end subroutine testme\n+end"}, {"sha": "2eea9aed72d11acadb49fd7d91ade70fb78cc1f1", "filename": "gcc/testsuite/gfortran.dg/widechar_select_2.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_select_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393bbd73754dfe54fac24d350c789316f17428f/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_select_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwidechar_select_2.f90?ref=d393bbd73754dfe54fac24d350c789316f17428f", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+\n+  character(kind=1,len=20) :: s1\n+  character(kind=4,len=20) :: s4\n+\n+  select case (s1)\n+    case (\"\":4_\"foo\") ! { dg-error \"must be of kind\" }\n+      test = 1\n+    case (4_\"gee\") ! { dg-error \"must be of kind\" }\n+      test = 1\n+    case (\"bar\")\n+      test = 1\n+    case default\n+      test = 4\n+  end select\n+\n+  select case (s4)\n+    case (\"\":4_\"foo\") ! { dg-error \"must be of kind\" }\n+      test = 1\n+    case (4_\"gee\")\n+      test = 1\n+    case (\"bar\") ! { dg-error \"must be of kind\" }\n+      test = 1\n+    case default\n+      test = 4\n+  end select\n+\n+  select case (s4)\n+    case (4_\"foo\":4_\"bar\")\n+      test = 1\n+    case (4_\"foo\":4_\"gee\") ! { dg-error \"overlaps with CASE label\" }\n+      test = 1\n+    case (4_\"foo\") ! { dg-error \"overlaps with CASE label\" }\n+      test = 1\n+  end select\n+\n+end"}]}