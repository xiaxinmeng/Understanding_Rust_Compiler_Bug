{"sha": "0462b6aa20fd6734f7497f5eed9496d33701a952", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ2MmI2YWEyMGZkNjczNGY3NDk3ZjVlZWQ5NDk2ZDMzNzAxYTk1Mg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-04-22T20:22:07Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-04-22T20:22:07Z"}, "message": "hashtable_policy.h: Add C++11 allocator support.\n\n2013-04-22  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/hashtable_policy.h: Add C++11 allocator support.\n\t* include/bits/hashtable.h: Likewise.\n\t* include/bits/unordered_set.h: Likewise.\n\t* include/bits/unordered_map.h: Likewise.\n\t* include/debug/unordered_set: Likewise.\n\t* include/debug/unordered_map: Likewise.\n\t* include/std/unordered_set: Remove bits/algobase.h\n\tinclude. Replace bits/alloc_traits.h by ext/alloc_traits.h.\n\t* include/std/unordered_map: Likewise.\n\t* include/ext/throw_allocator.h: Add checks on calls to allocator\n\tconstruct/destroy.\n\t(std::hash<__gnu_cxx::throw_value_limit>): Add conditional throw.\n\t(std::hash<__gnu_cxx::throw_value_random>): Likewise.\n\t* testsuite/util/regression/rand/priority_queue\n\t/container_rand_regression_test.tcc: Adapt.\n\t* testsuite/util/regression/rand/assoc\n\t/container_rand_regression_test.tcc: Likewise.\n\t* testsuite/util/testsuite_counter_type.h: Add count of destructors.\n\t* testsuite/23_containers/unordered_set\n\t/not_default_constructible_hash_neg.cc: Adjust dg-error line number.\n\t* testsuite/23_containers/unordered_set/instantiation_neg.cc: Likewise.\n\t* testsuite/23_containers/unordered_set/allocator/copy.cc: New.\n\t* testsuite/23_containers/unordered_set/allocator/copy_assign.cc: New.\n\t* testsuite/23_containers/unordered_set/allocator/minimal.cc: New.\n\t* testsuite/23_containers/unordered_set/allocator/move_assign.cc: New.\n\t* testsuite/23_containers/unordered_set/allocator/noexcept.cc: New.\n\t* testsuite/23_containers/unordered_set/allocator/swap.cc: New.\n\t* testsuite/23_containers/unordered_multiset/allocator/copy.cc: New.\n\t* testsuite/23_containers/unordered_multiset/allocator/copy_assign.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_multiset/allocator/minimal.cc: New.\n\t* testsuite/23_containers/unordered_multiset/allocator/move_assign.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_multiset/allocator/noexcept.cc: New.\n\t* testsuite/23_containers/unordered_multiset/allocator/swap.cc: New.\n\t* testsuite/23_containers/unordered_map/allocator/copy.cc: New.\n\t* testsuite/23_containers/unordered_map/allocator/copy_assign.cc: New.\n\t* testsuite/23_containers/unordered_map/allocator/minimal.cc: New.\n\t* testsuite/23_containers/unordered_map/allocator/move_assign.cc: New.\n\t* testsuite/23_containers/unordered_map/allocator/noexcept.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_map/allocator/swap.cc: New.\n\t* testsuite/23_containers/unordered_multimap/allocator/copy.cc: New.\n\t* testsuite/23_containers/unordered_multimap/allocator/copy_assign.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_multimap/allocator/minimal.cc: New.\n\t* testsuite/23_containers/unordered_multimap/allocator/move_assign.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_multimap/allocator/noexcept.cc: New.\n\t* testsuite/23_containers/unordered_multimap/allocator/swap.cc: New.\n\nFrom-SVN: r198158", "tree": {"sha": "5569c55c22034b5f3fd78df58dc634c6e5709ead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5569c55c22034b5f3fd78df58dc634c6e5709ead"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0462b6aa20fd6734f7497f5eed9496d33701a952", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0462b6aa20fd6734f7497f5eed9496d33701a952", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0462b6aa20fd6734f7497f5eed9496d33701a952", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0462b6aa20fd6734f7497f5eed9496d33701a952/comments", "author": null, "committer": null, "parents": [{"sha": "ca45eca116b838230e9b169c2ee5579190593af8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca45eca116b838230e9b169c2ee5579190593af8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca45eca116b838230e9b169c2ee5579190593af8"}], "stats": {"total": 3605, "additions": 3254, "deletions": 351}, "files": [{"sha": "a320fa7f527b3822543d8715e708f968ac579740", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -1,3 +1,56 @@\n+2013-04-22  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/hashtable_policy.h: Add C++11 allocator support.\n+\t* include/bits/hashtable.h: Likewise.\n+\t* include/bits/unordered_set.h: Likewise.\n+\t* include/bits/unordered_map.h: Likewise.\n+\t* include/debug/unordered_set: Likewise.\n+\t* include/debug/unordered_map: Likewise.\n+\t* include/std/unordered_set: Remove bits/algobase.h\n+\tinclude. Replace bits/alloc_traits.h by ext/alloc_traits.h.\n+\t* include/std/unordered_map: Likewise.\n+\t* include/ext/throw_allocator.h: Add checks on calls to allocator\n+\tconstruct/destroy.\n+\t(std::hash<__gnu_cxx::throw_value_limit>): Add conditional throw.\n+\t(std::hash<__gnu_cxx::throw_value_random>): Likewise.\n+\t* testsuite/util/regression/rand/priority_queue\n+\t/container_rand_regression_test.tcc: Adapt.\n+\t* testsuite/util/regression/rand/assoc\n+\t/container_rand_regression_test.tcc: Likewise.\n+\t* testsuite/util/testsuite_counter_type.h: Add count of destructors.\n+\t* testsuite/23_containers/unordered_set\n+\t/not_default_constructible_hash_neg.cc: Adjust dg-error line number.\n+\t* testsuite/23_containers/unordered_set/instantiation_neg.cc: Likewise.\n+\t* testsuite/23_containers/unordered_set/allocator/copy.cc: New.\n+\t* testsuite/23_containers/unordered_set/allocator/copy_assign.cc: New.\n+\t* testsuite/23_containers/unordered_set/allocator/minimal.cc: New.\n+\t* testsuite/23_containers/unordered_set/allocator/move_assign.cc: New.\n+\t* testsuite/23_containers/unordered_set/allocator/noexcept.cc: New.\n+\t* testsuite/23_containers/unordered_set/allocator/swap.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/allocator/copy.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/allocator/copy_assign.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_multiset/allocator/minimal.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/allocator/move_assign.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_multiset/allocator/noexcept.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/allocator/swap.cc: New.\n+\t* testsuite/23_containers/unordered_map/allocator/copy.cc: New.\n+\t* testsuite/23_containers/unordered_map/allocator/copy_assign.cc: New.\n+\t* testsuite/23_containers/unordered_map/allocator/minimal.cc: New.\n+\t* testsuite/23_containers/unordered_map/allocator/move_assign.cc: New.\n+\t* testsuite/23_containers/unordered_map/allocator/noexcept.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_map/allocator/swap.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/allocator/copy.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/allocator/copy_assign.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_multimap/allocator/minimal.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/allocator/move_assign.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_multimap/allocator/noexcept.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/allocator/swap.cc: New.\n+\n 2013-04-22  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/std/type_traits (is_signed): Simplify."}, {"sha": "0ff6e132a83d3b2617ebe6ae474b656727b16f69", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 457, "deletions": 111, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -183,18 +183,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>\n     {\n+      typedef std::allocator_traits<_Alloc> _Alloc_traits;\n+      typedef typename _Alloc_traits::template rebind_alloc<_Value>\n+\t\t\t\t\t\t\t_Value_alloc_type;\n+      typedef __gnu_cxx::__alloc_traits<_Value_alloc_type> _Value_alloc_traits;\n+\n     public:\n-      typedef _Key                                    key_type;\n-      typedef _Value                                  value_type;\n-      typedef _Alloc                                  allocator_type;\n-      typedef _Equal                                  key_equal;\n+      typedef _Key\t\t\t\t\t\tkey_type;\n+      typedef _Value\t\t\t\t\t\tvalue_type;\n+      typedef _Alloc\t\t\t\t\t\tallocator_type;\n+      typedef _Equal\t\t\t\t\t\tkey_equal;\n \n       // mapped_type, if present, comes from _Map_base.\n       // hasher, if present, comes from _Hash_code_base/_Hashtable_base.\n-      typedef typename _Alloc::pointer\t\t      pointer;\n-      typedef typename _Alloc::const_pointer          const_pointer;\n-      typedef typename _Alloc::reference              reference;\n-      typedef typename _Alloc::const_reference        const_reference;\n+      typedef typename _Value_alloc_traits::pointer\t\tpointer;\n+      typedef typename _Value_alloc_traits::const_pointer\tconst_pointer;\n+      typedef value_type&\t\t\t\t\treference;\n+      typedef const value_type&\t\t\t\t\tconst_reference;\n \n     private:\n       using __rehash_type = _RehashPolicy;\n@@ -236,8 +241,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t    _RehashPolicy, _Traits>;\n \n       // Metaprogramming for picking apart hash caching.\n-      using __hash_noexcept = __detail::__is_noexcept_hash<_Key, _H1>;\n-\n       template<typename _Cond>\n \tusing __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;\n \n@@ -246,12 +249,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // Compile-time diagnostics.\n \n-      // When hash codes are not cached the hash functor shall not\n-      // throw because it is used in methods (erase, swap...) that\n-      // shall not throw.\n-      static_assert(__if_hash_not_cached<__hash_noexcept>::value,\n-\t\t    \"Cache the hash code\"\n-\t\t    \" or qualify your hash functor with noexcept\");\n+      // Getting a bucket index from a node shall not throw because it is used\n+      // in methods (erase, swap...) that shall not throw.\n+      static_assert(noexcept(declval<const _Hashtable&>()\n+\t\t\t     ._M_bucket_index((const __node_type*)nullptr,\n+\t\t\t\t\t      (std::size_t)0)),\n+\t\t    \"Cache the hash code or qualify your functors involved\"\n+\t\t    \" in hash code and bucket index computation with noexcept\");\n \n       // Following two static assertions are necessary to guarantee\n       // that local_iterator will be default constructible.\n@@ -302,6 +306,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       bool _Constant_iteratorsa, bool _Unique_keysa>\n \tfriend struct __detail::_Insert;\n \n+      template<typename _Keya, typename _Valuea, typename _Alloca,\n+\t       typename _ExtractKeya, typename _Equala,\n+\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _RehashPolicya, typename _Traitsa,\n+\t       bool _IsCopyAssignable>\n+\tfriend struct __detail::_ReuseOrAllocNode;\n+\n+      template<typename _Keya, typename _Valuea, typename _Alloca,\n+\t       typename _ExtractKeya, typename _Equala,\n+\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _RehashPolicya, typename _Traitsa,\n+\t       bool _IsMoveAssignable>\n+\tfriend struct __detail::_MoveReuseOrAllocNode;\n+\n       using size_type = typename __hashtable_base::size_type;\n       using difference_type = typename __hashtable_base::difference_type;\n \n@@ -313,24 +331,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t   const_local_iterator;\n \n     private:\n-      typedef typename _Alloc::template rebind<__node_type>::other\n-\t\t\t\t\t\t\t_Node_allocator_type;\n-      typedef typename _Alloc::template rebind<__bucket_type>::other\n-\t\t\t\t\t\t\t_Bucket_allocator_type;\n+      typedef typename _Alloc_traits::template rebind_alloc<__node_type>\n+\t\t\t\t\t\t\t_Node_alloc_type;\n+      // Use __gnu_cxx to benefit from _S_always_equal and al.\n+      typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;\n \n-      using __before_begin = __detail::_Before_begin<_Node_allocator_type>;\n+      typedef\n+      typename _Alloc_traits::template rebind_alloc<__bucket_type>\n+\t\t\t\t\t\t\t_Bucket_alloc_type;\n+      typedef std::allocator_traits<_Bucket_alloc_type> _Bucket_alloc_traits;\n+\n+      using __before_begin = __detail::_Before_begin<_Node_alloc_type>;\n \n       __bucket_type*\t\t_M_buckets;\n       size_type\t\t\t_M_bucket_count;\n       __before_begin\t\t_M_bbegin;\n       size_type\t\t\t_M_element_count;\n       _RehashPolicy\t\t_M_rehash_policy;\n \n-      _Node_allocator_type&\n+      _Node_alloc_type&\n       _M_node_allocator()\n       { return _M_bbegin; }\n \n-      const _Node_allocator_type&\n+      const _Node_alloc_type&\n       _M_node_allocator() const\n       { return _M_bbegin; }\n \n@@ -359,6 +382,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_deallocate_buckets(__bucket_type*, size_type __n);\n \n+      void\n+      _M_deallocate_buckets()\n+      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }\n+\n       // Gets bucket begin, deals with the fact that non-empty buckets contain\n       // their before begin node.\n       __node_type*\n@@ -368,6 +395,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_begin() const\n       { return static_cast<__node_type*>(_M_before_begin()._M_nxt); }\n \n+      template<typename _UnaryOp>\n+\tvoid\n+\t_M_assign(const _Hashtable&, const _UnaryOp&);\n+\n+      void\n+      _M_move_assign(_Hashtable&&, std::true_type);\n+\n+      void\n+      _M_move_assign(_Hashtable&&, std::false_type);\n+\n+      void\n+      _M_reset() noexcept;\n+\n     public:\n       // Constructor, destructor, assignment, swap\n       _Hashtable(size_type __bucket_hint,\n@@ -384,9 +424,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Hashtable(const _Hashtable&);\n \n-      _Hashtable(_Hashtable&&);\n+      _Hashtable(_Hashtable&&) noexcept;\n+\n+      _Hashtable(const _Hashtable&, const allocator_type&);\n+\n+      _Hashtable(_Hashtable&&, const allocator_type&);\n \n       // Use delegating constructors.\n+      explicit\n+      _Hashtable(const allocator_type& __a)\n+\t: _Hashtable(10, _H1(), __detail::_Mod_range_hashing(),\n+\t\t     __detail::_Default_ranged_hash(), key_equal(),\n+\t\t     __key_extract(), __a)\n+      { }\n+\n       explicit\n       _Hashtable(size_type __n = 10,\n \t\t const _H1& __hf = _H1(),\n@@ -420,34 +471,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { }\n \n       _Hashtable&\n-      operator=(const _Hashtable& __ht)\n-      {\n-\t_Hashtable __tmp(__ht);\n-\tthis->swap(__tmp);\n-\treturn *this;\n-      }\n+      operator=(const _Hashtable& __ht);\n \n       _Hashtable&\n       operator=(_Hashtable&& __ht)\n+      noexcept(_Node_alloc_traits::_S_nothrow_move())\n       {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__ht);\n+        constexpr bool __move_storage =\n+          _Node_alloc_traits::_S_propagate_on_move_assign()\n+          || _Node_alloc_traits::_S_always_equal();\n+        _M_move_assign(std::move(__ht),\n+                       integral_constant<bool, __move_storage>());\n \treturn *this;\n       }\n \n       _Hashtable&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n+\tclear();\n \tthis->insert(__l.begin(), __l.end());\n \treturn *this;\n       }\n \n       ~_Hashtable() noexcept;\n \n-      void swap(_Hashtable&);\n+      void\n+      swap(_Hashtable&)\n+      noexcept(_Node_alloc_traits::_S_nothrow_swap());\n \n       // Basic container operations\n       iterator\n@@ -488,7 +538,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       size_type\n       max_size() const noexcept\n-      { return _M_node_allocator().max_size(); }\n+      { return _Node_alloc_traits::max_size(_M_node_allocator()); }\n \n       // Observers\n       key_equal\n@@ -585,7 +635,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     protected:\n       // Bucket index computation helpers.\n       size_type\n-      _M_bucket_index(__node_type* __n) const\n+      _M_bucket_index(__node_type* __n) const noexcept\n       { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }\n \n       size_type\n@@ -682,7 +732,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       size_type\n       erase(const key_type& __k)\n-      { return _M_erase(__unique_keys(), __k); }\n+      {\n+\tif (__builtin_expect(_M_bucket_count == 0, false))\n+\t  return 0;\n+\treturn _M_erase(__unique_keys(), __k);\n+      }\n \n       iterator\n       erase(const_iterator, const_iterator);\n@@ -721,15 +775,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_allocate_node(_Args&&... __args)\n       {\n-\t__node_type* __n = _M_node_allocator().allocate(1);\n+\t__node_type* __n = _Node_alloc_traits::allocate(_M_node_allocator(), 1);\n \t__try\n \t  {\n-\t    _M_node_allocator().construct(__n, std::forward<_Args>(__args)...);\n+\t    _Value_alloc_type __a(_M_node_allocator());\n+\t    ::new ((void*)__n) __node_type();\n+\t    _Value_alloc_traits::construct(__a, __n->_M_valptr(),\n+\t\t\t\t\t   std::forward<_Args>(__args)...);\n \t    return __n;\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_node_allocator().deallocate(__n, 1);\n+\t    _Node_alloc_traits::deallocate(_M_node_allocator(), __n, 1);\n \t    __throw_exception_again;\n \t  }\n       }\n@@ -743,8 +800,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_deallocate_node(__node_type* __n)\n     {\n-      _M_node_allocator().destroy(__n);\n-      _M_node_allocator().deallocate(__n, 1);\n+      _Value_alloc_type __a(_M_node_allocator());\n+      _Value_alloc_traits::destroy(__a, __n->_M_valptr());\n+      __n->~__node_type();\n+      _Node_alloc_traits::deallocate(_M_node_allocator(), __n, 1);\n     }\n \n   template<typename _Key, typename _Value,\n@@ -774,9 +833,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_allocate_buckets(size_type __n)\n     {\n-      _Bucket_allocator_type __alloc(_M_node_allocator());\n+      _Bucket_alloc_type __alloc(_M_node_allocator());\n \n-      __bucket_type* __p = __alloc.allocate(__n);\n+      __bucket_type* __p = _Bucket_alloc_traits::allocate(__alloc, __n);\n       __builtin_memset(__p, 0, __n * sizeof(__bucket_type));\n       return __p;\n     }\n@@ -788,10 +847,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_deallocate_buckets(__bucket_type* __p, size_type __n)\n+    _M_deallocate_buckets(__bucket_type* __bkts, size_type __n)\n     {\n-      _Bucket_allocator_type __alloc(_M_node_allocator());\n-      __alloc.deallocate(__p, __n);\n+      _Bucket_alloc_type __alloc(_M_node_allocator());\n+      _Bucket_alloc_traits::deallocate(__alloc, __bkts, __n);\n     }\n \n   template<typename _Key, typename _Value,\n@@ -822,7 +881,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : __hashtable_base(__exk, __h1, __h2, __h, __eq),\n       __map_base(),\n       __rehash_base(),\n-      _M_bucket_count(0),\n       _M_bbegin(__a),\n       _M_element_count(0),\n       _M_rehash_policy()\n@@ -846,7 +904,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : __hashtable_base(__exk, __h1, __h2, __h, __eq),\n \t__map_base(),\n \t__rehash_base(),\n-\t_M_bucket_count(0),\n \t_M_bbegin(__a),\n \t_M_element_count(0),\n \t_M_rehash_policy()\n@@ -866,11 +923,256 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__catch(...)\n \t  {\n \t    clear();\n-\t    _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+\t    _M_deallocate_buckets();\n \t    __throw_exception_again;\n \t  }\n       }\n \n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>&\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::operator=(\n+\t\tconst _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>& __ht)\n+      {\n+\tif (&__ht == this)\n+\t  return *this;\n+\n+\tif (_Node_alloc_traits::_S_propagate_on_copy_assign())\n+\t  {\n+\t    auto& __this_alloc = this->_M_node_allocator();\n+\t    auto& __that_alloc = __ht._M_node_allocator();\n+\t    if (!_Node_alloc_traits::_S_always_equal()\n+\t\t&& __this_alloc != __that_alloc)\n+\t      {\n+\t\t// Replacement allocator cannot free existing storage.\n+\t\t_M_deallocate_nodes(_M_begin());\n+\t\tif (__builtin_expect(_M_bucket_count != 0, true))\n+\t\t  _M_deallocate_buckets();\n+\t\t_M_reset();\n+\t\tstd::__alloc_on_copy(__this_alloc, __that_alloc);\n+\t\t__hashtable_base::operator=(__ht);\n+\t\t_M_bucket_count = __ht._M_bucket_count;\n+\t\t_M_element_count = __ht._M_element_count;\n+\t\t_M_rehash_policy = __ht._M_rehash_policy;\n+\t\t__try\n+\t\t  {\n+\t\t    _M_assign(__ht,\n+\t\t\t      [this](const __node_type* __n)\n+\t\t\t      { return _M_allocate_node(__n->_M_v()); });\n+\t\t  }\n+\t\t__catch(...)\n+\t\t  {\n+\t\t    // _M_assign took care of deallocating all memory. Now we\n+\t\t    // must make sure this instance remains in a usable state.\n+\t\t    _M_reset();\n+\t\t    __throw_exception_again;\n+\t\t  }\n+\t\treturn *this;\n+\t      }\n+\t    std::__alloc_on_copy(__this_alloc, __that_alloc);\n+\t  }\n+\n+\t// Reuse allocated buckets and nodes.\n+\t__bucket_type* __former_buckets = nullptr;\n+\tstd::size_t __former_bucket_count = _M_bucket_count;\n+\tconst __rehash_state& __former_state = _M_rehash_policy._M_state();\n+\t\n+\tif (_M_bucket_count != __ht._M_bucket_count)\n+\t  {\n+\t    __former_buckets = _M_buckets;\n+\t    _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);\n+\t    _M_bucket_count = __ht._M_bucket_count;\n+\t  }\n+\telse\n+\t  __builtin_memset(_M_buckets, 0,\n+\t\t\t   _M_bucket_count * sizeof(__bucket_type));\n+\n+\t__try\n+\t  {\n+\t    __hashtable_base::operator=(__ht);\n+\t    _M_element_count = __ht._M_element_count;\n+\t    _M_rehash_policy = __ht._M_rehash_policy;\n+\t    __detail::_ReuseOrAllocNode<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t\t_Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t_RehashPolicy, _Traits>\n+\t      __roan(_M_begin(), *this);\n+\t    _M_before_begin()._M_nxt = nullptr;\n+\t    _M_assign(__ht, __roan);\n+\t    if (__former_buckets)\n+\t      _M_deallocate_buckets(__former_buckets, __former_bucket_count);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    if (__former_buckets)\n+\t      {\n+\t\t// Restore previous buckets.\n+\t\t_M_deallocate_buckets();\n+\t\t_M_rehash_policy._M_reset(__former_state);\n+\t\t_M_buckets = __former_buckets;\n+\t\t_M_bucket_count = __former_bucket_count;\n+\t      }\n+\t    __builtin_memset(_M_buckets, 0,\n+\t\t\t     _M_bucket_count * sizeof(__bucket_type));\n+\t    __throw_exception_again;\n+\t  }\n+\treturn *this;\n+      }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    template<typename _UnaryOp>\n+      void\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+      _M_assign(const _Hashtable& __ht, const _UnaryOp& __node_getter)\n+      {\n+\t__bucket_type* __buckets = nullptr;\n+\tif (!_M_buckets)\n+\t  _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);\n+\n+\t__try\n+\t  {\n+\t    if (!__ht._M_before_begin()._M_nxt)\n+\t      return;\n+\n+\t    // First deal with the special first node pointed to by\n+\t    // _M_before_begin.\n+\t    __node_type* __ht_n = __ht._M_begin();\n+\t    __node_type* __this_n = __node_getter(__ht_n);\n+\t    this->_M_copy_code(__this_n, __ht_n);\n+\t    _M_before_begin()._M_nxt = __this_n;\n+\t    _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin();\n+\n+\t    // Then deal with other nodes.\n+\t    __node_base* __prev_n = __this_n;\n+\t    for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())\n+\t      {\n+\t\t__this_n = __node_getter(__ht_n);\n+\t\t__prev_n->_M_nxt = __this_n;\n+\t\tthis->_M_copy_code(__this_n, __ht_n);\n+\t\tsize_type __bkt = _M_bucket_index(__this_n);\n+\t\tif (!_M_buckets[__bkt])\n+\t\t  _M_buckets[__bkt] = __prev_n;\n+\t\t__prev_n = __this_n;\n+\t      }\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    clear();\n+\t    if (__buckets)\n+\t      _M_deallocate_buckets();\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    void\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_reset() noexcept\n+    {\n+      _M_rehash_policy._M_reset();\n+      _M_bucket_count = 0;\n+      _M_buckets = nullptr;\n+      _M_before_begin()._M_nxt = nullptr;\n+      _M_element_count = 0;\n+    }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    void\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_move_assign(_Hashtable&& __ht, std::true_type)\n+    {\n+      _M_deallocate_nodes(_M_begin());\n+      if (__builtin_expect(_M_bucket_count != 0, true))\n+\t_M_deallocate_buckets();\n+\n+      __hashtable_base::operator=(std::move(__ht));\n+      _M_rehash_policy = __ht._M_rehash_policy;\n+      _M_buckets = __ht._M_buckets;\n+      _M_bucket_count = __ht._M_bucket_count;\n+      _M_before_begin()._M_nxt = __ht._M_before_begin()._M_nxt;\n+      _M_element_count = __ht._M_element_count;\n+      std::__alloc_on_move(_M_node_allocator(), __ht._M_node_allocator());\n+\n+      // Fix buckets containing the _M_before_begin pointers that can't be\n+      // moved.\n+      if (_M_begin())\n+\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();\n+      __ht._M_reset();\n+    }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    void\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_move_assign(_Hashtable&& __ht, std::false_type)\n+    {\n+      if (__ht._M_node_allocator() == _M_node_allocator())\n+\t_M_move_assign(std::move(__ht), std::true_type());\n+      else\n+\t{\n+\t  // Can't move memory, move elements then.\n+\t  __bucket_type* __former_buckets = nullptr;\n+\t  size_type __former_bucket_count = _M_bucket_count;\n+\t  const __rehash_state& __former_state = _M_rehash_policy._M_state();\n+\n+\t  if (_M_bucket_count != __ht._M_bucket_count)\n+\t    {\n+\t      __former_buckets = _M_buckets;\n+\t      _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);\n+\t      _M_bucket_count = __ht._M_bucket_count;\n+\t    }\n+\t  else\n+\t    __builtin_memset(_M_buckets, 0,\n+\t\t\t     _M_bucket_count * sizeof(__bucket_type));\n+\n+\t  __try\n+\t    {\n+\t      __hashtable_base::operator=(std::move(__ht));\n+\t      _M_element_count = __ht._M_element_count;\n+\t      _M_rehash_policy = __ht._M_rehash_policy;\n+\t      __detail::_MoveReuseOrAllocNode<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t\t      _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t      _RehashPolicy, _Traits>\n+\t\t__mroan(_M_begin(), *this);\n+\t      _M_before_begin()._M_nxt = nullptr;\n+\t      _M_assign(__ht, __mroan);\n+\t      __ht.clear();\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      if (__former_buckets)\n+\t\t{\n+\t\t  _M_deallocate_buckets();\n+\t\t  _M_rehash_policy._M_reset(__former_state);\n+\t\t  _M_buckets = __former_buckets;\n+\t\t  _M_bucket_count = __former_bucket_count;\n+\t\t}\n+\t      __builtin_memset(_M_buckets, 0,\n+\t\t\t       _M_bucket_count * sizeof(__bucket_type));\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n+    }\n+\n   template<typename _Key, typename _Value,\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n@@ -881,44 +1183,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : __hashtable_base(__ht),\n       __map_base(__ht),\n       __rehash_base(__ht),\n+      _M_buckets(),\n       _M_bucket_count(__ht._M_bucket_count),\n-      _M_bbegin(__ht._M_bbegin),\n+      _M_bbegin(_Node_alloc_traits::_S_select_on_copy(\n+\t\t__ht._M_node_allocator())),\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n-      _M_buckets = _M_allocate_buckets(_M_bucket_count);\n-      __try\n-\t{\n-\t  if (!__ht._M_before_begin()._M_nxt)\n-\t    return;\n-\n-\t  // First deal with the special first node pointed to by\n-\t  // _M_before_begin.\n-\t  const __node_type* __ht_n = __ht._M_begin();\n-\t  __node_type* __this_n = _M_allocate_node(__ht_n->_M_v);\n-\t  this->_M_copy_code(__this_n, __ht_n);\n-\t  _M_before_begin()._M_nxt = __this_n;\n-\t  _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin();\n-\n-\t  // Then deal with other nodes.\n-\t  __node_base* __prev_n = __this_n;\n-\t  for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())\n-\t    {\n-\t      __this_n = _M_allocate_node(__ht_n->_M_v);\n-\t      __prev_n->_M_nxt = __this_n;\n-\t      this->_M_copy_code(__this_n, __ht_n);\n-\t      size_type __bkt = _M_bucket_index(__this_n);\n-\t      if (!_M_buckets[__bkt])\n-\t\t_M_buckets[__bkt] = __prev_n;\n-\t      __prev_n = __this_n;\n-\t    }\n-\t}\n-      __catch(...)\n-\t{\n-\t  clear();\n-\t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n-\t  __throw_exception_again;\n-\t}\n+      _M_assign(__ht,\n+\t\t[this](const __node_type* __n)\n+\t\t{ return _M_allocate_node(__n->_M_v()); });\n     }\n \n   template<typename _Key, typename _Value,\n@@ -927,7 +1201,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Traits>\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _Hashtable(_Hashtable&& __ht)\n+    _Hashtable(_Hashtable&& __ht) noexcept\n     : __hashtable_base(__ht),\n       __map_base(__ht),\n       __rehash_base(__ht),\n@@ -937,14 +1211,70 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n-      // Update, if necessary, bucket pointing to before begin that hasn't moved.\n+      // Update, if necessary, bucket pointing to before begin that hasn't\n+      // moved.\n       if (_M_begin())\n \t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();\n-      __ht._M_rehash_policy = _RehashPolicy();\n-      __ht._M_bucket_count = __ht._M_rehash_policy._M_next_bkt(0);\n-      __ht._M_buckets = __ht._M_allocate_buckets(__ht._M_bucket_count);\n-      __ht._M_before_begin()._M_nxt = nullptr;\n-      __ht._M_element_count = 0;\n+      __ht._M_reset();\n+    }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _Hashtable(const _Hashtable& __ht, const allocator_type& __a)\n+    : __hashtable_base(__ht),\n+      __map_base(__ht),\n+      __rehash_base(__ht),\n+      _M_buckets(),\n+      _M_bucket_count(__ht._M_bucket_count),\n+      _M_bbegin(_Node_alloc_type(__a)),\n+      _M_element_count(__ht._M_element_count),\n+      _M_rehash_policy(__ht._M_rehash_policy)\n+    {\n+      _M_assign(__ht,\n+\t\t[this](const __node_type* __n)\n+\t\t{ return _M_allocate_node(__n->_M_v()); });\n+    }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _Hashtable(_Hashtable&& __ht, const allocator_type& __a)\n+    : __hashtable_base(__ht),\n+      __map_base(__ht),\n+      __rehash_base(__ht),\n+      _M_buckets(),\n+      _M_bucket_count(__ht._M_bucket_count),\n+      _M_bbegin(_Node_alloc_type(__a)),\n+      _M_element_count(__ht._M_element_count),\n+      _M_rehash_policy(__ht._M_rehash_policy)\n+    {\n+      if (__ht._M_node_allocator() == _M_node_allocator())\n+\t{\n+\t  _M_buckets = __ht._M_buckets;\n+\t  _M_before_begin()._M_nxt = __ht._M_before_begin()._M_nxt;\n+\t  // Update, if necessary, bucket pointing to before begin that hasn't\n+\t  // moved.\n+\t  if (_M_begin())\n+\t    _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();\n+\t  __ht._M_reset();\n+\t}\n+      else\n+\t{\n+\t  _M_assign(__ht,\n+\t\t    [this](__node_type* __n)\n+\t\t    {\n+\t\t      return _M_allocate_node(\n+\t\t\t\t\tstd::move_if_noexcept(__n->_M_v()));\n+\t\t    });\n+\t  __ht.clear();\n+\t}\n     }\n \n   template<typename _Key, typename _Value,\n@@ -956,7 +1286,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     ~_Hashtable() noexcept\n     {\n       clear();\n-      _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+      if (_M_buckets)\n+\t_M_deallocate_buckets();\n     }\n \n   template<typename _Key, typename _Value,\n@@ -967,25 +1298,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     swap(_Hashtable& __x)\n+    noexcept(_Node_alloc_traits::_S_nothrow_swap())\n     {\n       // The only base class with member variables is hash_code_base.\n       // We define _Hash_code_base::_M_swap because different\n       // specializations have different members.\n       this->_M_swap(__x);\n \n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 431. Swapping containers with unequal allocators.\n-      std::__alloc_swap<_Node_allocator_type>::_S_do_it(_M_node_allocator(),\n-\t\t\t\t\t\t\t__x._M_node_allocator());\n-\n+      std::__alloc_on_swap(_M_node_allocator(), __x._M_node_allocator());\n       std::swap(_M_rehash_policy, __x._M_rehash_policy);\n       std::swap(_M_buckets, __x._M_buckets);\n       std::swap(_M_bucket_count, __x._M_bucket_count);\n       std::swap(_M_before_begin()._M_nxt, __x._M_before_begin()._M_nxt);\n       std::swap(_M_element_count, __x._M_element_count);\n \n-      // Fix buckets containing the _M_before_begin pointers that\n-      // can't be swapped.\n+      // Fix buckets containing the _M_before_begin pointers that can't be\n+      // swapped.\n       if (_M_begin())\n \t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();\n       if (__x._M_begin())\n@@ -1020,10 +1348,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     find(const key_type& __k)\n     {\n+      if (__builtin_expect(_M_bucket_count == 0, false))\n+\treturn end();\n+\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n       __node_type* __p = _M_find_node(__n, __k, __code);\n-      return __p ? iterator(__p) : this->end();\n+      return __p ? iterator(__p) : end();\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1037,10 +1368,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     find(const key_type& __k) const\n     {\n+      if (__builtin_expect(_M_bucket_count == 0, false))\n+\treturn end();\n+      \n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n       __node_type* __p = _M_find_node(__n, __k, __code);\n-      return __p ? const_iterator(__p) : this->end();\n+      return __p ? const_iterator(__p) : end();\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1054,6 +1388,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     count(const key_type& __k) const\n     {\n+      if (__builtin_expect(_M_bucket_count == 0, false))\n+\treturn 0;\n+\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n       __node_type* __p = _M_bucket_begin(__n);\n@@ -1092,6 +1429,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     equal_range(const key_type& __k)\n     {\n+      if (__builtin_expect(_M_bucket_count == 0, false))\n+\treturn std::make_pair(end(), end());\n+\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n       __node_type* __p = _M_find_node(__n, __k, __code);\n@@ -1106,7 +1446,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return std::make_pair(iterator(__p), iterator(__p1));\n \t}\n       else\n-\treturn std::make_pair(this->end(), this->end());\n+\treturn std::make_pair(end(), end());\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1125,6 +1465,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     equal_range(const key_type& __k) const\n     {\n+      if (__builtin_expect(_M_bucket_count == 0, false))\n+\treturn std::make_pair(end(), end());\n+\t\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n       __node_type* __p = _M_find_node(__n, __k, __code);\n@@ -1139,7 +1482,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return std::make_pair(const_iterator(__p), const_iterator(__p1));\n \t}\n       else\n-\treturn std::make_pair(this->end(), this->end());\n+\treturn std::make_pair(end(), end());\n     }\n \n   // Find the node whose key compares equal to k in the bucket n.\n@@ -1258,7 +1601,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \t// First build the node to get access to the hash code\n \t__node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);\n-\tconst key_type& __k = this->_M_extract()(__node->_M_v);\n+\tconst key_type& __k = this->_M_extract()(__node->_M_v());\n \t__hash_code __code;\n \t__try\n \t  {\n@@ -1301,7 +1644,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__hash_code __code;\n \t__try\n \t  {\n-\t    __code = this->_M_hash_code(this->_M_extract()(__node->_M_v));\n+\t    __code = this->_M_hash_code(this->_M_extract()(__node->_M_v()));\n \t  }\n \t__catch(...)\n \t  {\n@@ -1333,7 +1676,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  if (__do_rehash.first)\n \t    {\n \t      _M_rehash(__do_rehash.second, __saved_state);\n-\t      __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v), __code);\n+\t      __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v()), __code);\n \t    }\n \n \t  this->_M_store_code(__node, __code);\n@@ -1373,7 +1716,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    _M_rehash(__do_rehash.second, __saved_state);\n \n \t  this->_M_store_code(__node, __code);\n-\t  const key_type& __k = this->_M_extract()(__node->_M_v);\n+\t  const key_type& __k = this->_M_extract()(__node->_M_v());\n \t  size_type __bkt = _M_bucket_index(__k, __code);\n \n \t  // Find the node before an equivalent one.\n@@ -1722,7 +2065,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    }\n \t  __p = __next;\n \t}\n-      _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+\n+      if (__builtin_expect(_M_bucket_count != 0, true))\n+\t_M_deallocate_buckets();\n       _M_bucket_count = __n;\n       _M_buckets = __new_buckets;\n     }\n@@ -1812,7 +2157,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    __new_buckets[__next_bkt] = __prev_p;\n \t}\n \n-      _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+      if (__builtin_expect(_M_bucket_count != 0, true))\n+\t_M_deallocate_buckets();\n       _M_bucket_count = __n;\n       _M_buckets = __new_buckets;\n     }"}, {"sha": "5cabb53bb6d4731f847f28011eab3a1dd3fb64c2", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 175, "deletions": 36, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -155,6 +155,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Hash_node_base(_Hash_node_base* __next) : _M_nxt(__next) { }\n   };\n \n+  /**\n+   *  struct _Hash_node_value_base\n+   *\n+   *  Node type with the value to store.\n+   */\n+  template<typename _Value>\n+    struct _Hash_node_value_base : _Hash_node_base\n+    {\n+      __gnu_cxx::__aligned_buffer<_Value> _M_storage;\n+\n+      _Value*\n+      _M_valptr() noexcept\n+      { return _M_storage._M_ptr(); }\n+\n+      const _Value*\n+      _M_valptr() const noexcept\n+      { return _M_storage._M_ptr(); }\n+\n+      _Value&\n+      _M_v() noexcept\n+      { return *_M_valptr(); }\n+\n+      const _Value&\n+      _M_v() const noexcept\n+      { return *_M_valptr(); }\n+    };\n+\n   /**\n    *  Primary template struct _Hash_node.\n    */\n@@ -164,38 +191,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /**\n    *  Specialization for nodes with caches, struct _Hash_node.\n    *\n-   *  Base class is __detail::_Hash_node_base.\n+   *  Base class is __detail::_Hash_node_value_base.\n    */\n   template<typename _Value>\n-    struct _Hash_node<_Value, true> : _Hash_node_base\n+    struct _Hash_node<_Value, true> : _Hash_node_value_base<_Value>\n     {\n-      _Value       _M_v;\n       std::size_t  _M_hash_code;\n \n-      template<typename... _Args>\n-\t_Hash_node(_Args&&... __args)\n-\t: _M_v(std::forward<_Args>(__args)...), _M_hash_code() { }\n-\n       _Hash_node*\n-      _M_next() const { return static_cast<_Hash_node*>(_M_nxt); }\n+      _M_next() const { return static_cast<_Hash_node*>(this->_M_nxt); }\n     };\n \n   /**\n    *  Specialization for nodes without caches, struct _Hash_node.\n    *\n-   *  Base class is __detail::_Hash_node_base.\n+   *  Base class is __detail::_Hash_node_value_base.\n    */\n   template<typename _Value>\n-    struct _Hash_node<_Value, false> : _Hash_node_base\n+    struct _Hash_node<_Value, false> : _Hash_node_value_base<_Value>\n     {\n-      _Value       _M_v;\n-\n-      template<typename... _Args>\n-\t_Hash_node(_Args&&... __args)\n-\t: _M_v(std::forward<_Args>(__args)...) { }\n-\n       _Hash_node*\n-      _M_next() const { return static_cast<_Hash_node*>(_M_nxt); }\n+      _M_next() const { return static_cast<_Hash_node*>(this->_M_nxt); }\n     };\n \n   /// Base class for node iterators.\n@@ -255,11 +271,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       reference\n       operator*() const\n-      { return this->_M_cur->_M_v; }\n+      { return this->_M_cur->_M_v(); }\n \n       pointer\n       operator->() const\n-      { return std::__addressof(this->_M_cur->_M_v); }\n+      { return this->_M_cur->_M_valptr(); }\n \n       _Node_iterator&\n       operator++()\n@@ -307,11 +323,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       reference\n       operator*() const\n-      { return this->_M_cur->_M_v; }\n+      { return this->_M_cur->_M_v(); }\n \n       pointer\n       operator->() const\n-      { return std::__addressof(this->_M_cur->_M_v); }\n+      { return this->_M_cur->_M_valptr(); }\n \n       _Node_const_iterator&\n       operator++()\n@@ -341,7 +357,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     typedef std::size_t result_type;\n \n     result_type\n-    operator()(first_argument_type __num, second_argument_type __den) const\n+    operator()(first_argument_type __num,\n+\t       second_argument_type __den) const noexcept\n     { return __num % __den; }\n   };\n \n@@ -386,6 +403,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_state() const\n     { return _M_next_resize; }\n \n+    void\n+    _M_reset() noexcept\n+    { _M_next_resize = 0; }\n+\n     void\n     _M_reset(_State __state)\n     { _M_next_resize = __state; }\n@@ -496,7 +517,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return __h->_M_insert_unique_node(__n, __code, __p)->second;\n \t}\n \n-      return (__p->_M_v).second;\n+      return __p->_M_v().second;\n     }\n \n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n@@ -522,7 +543,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return __h->_M_insert_unique_node(__n, __code, __p)->second;\n \t}\n \n-      return (__p->_M_v).second;\n+      return __p->_M_v().second;\n     }\n \n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n@@ -542,7 +563,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       if (!__p)\n \t__throw_out_of_range(__N(\"_Map_base::at\"));\n-      return (__p->_M_v).second;\n+      return __p->_M_v().second;\n     }\n \n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n@@ -562,7 +583,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       if (!__p)\n \t__throw_out_of_range(__N(\"_Map_base::at\"));\n-      return (__p->_M_v).second;\n+      return __p->_M_v().second;\n     }\n \n   /**\n@@ -939,7 +960,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       std::size_t\n       _M_bucket_index(const __node_type* __p, std::size_t __n) const\n-      { return _M_ranged_hash()(_M_extract()(__p->_M_v), __n); }\n+\tnoexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>(), (std::size_t)0)) )\n+      { return _M_ranged_hash()(_M_extract()(__p->_M_v()), __n); }\n \n       void\n       _M_store_code(__node_type*, __hash_code) const\n@@ -1023,9 +1045,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return _M_h2()(__c, __n); }\n \n       std::size_t\n-      _M_bucket_index(const __node_type* __p,\n-\t\t      std::size_t __n) const\n-      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v)), __n); }\n+      _M_bucket_index(const __node_type* __p, std::size_t __n) const\n+\tnoexcept( noexcept(declval<const _H1&>()(declval<const _Key&>()))\n+\t\t  && noexcept(declval<const _H2&>()((__hash_code)0, (std::size_t)0)) )\n+      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __n); }\n \n       void\n       _M_store_code(__node_type*, __hash_code) const\n@@ -1109,6 +1132,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       std::size_t\n       _M_bucket_index(const __node_type* __p, std::size_t __n) const\n+\tnoexcept( noexcept(declval<const _H2&>()((__hash_code)0,\n+\t\t\t\t\t\t (std::size_t)0)) )\n       { return _M_h2()(__p->_M_hash_code, __n); }\n \n       void\n@@ -1163,7 +1188,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     static bool\n     _S_equals(const _Equal& __eq, const _ExtractKey& __extract,\n \t      const _Key& __k, _HashCodeType __c, _Hash_node<_Value, true>* __n)\n-    { return __c == __n->_M_hash_code && __eq(__k, __extract(__n->_M_v)); }\n+    { return __c == __n->_M_hash_code && __eq(__k, __extract(__n->_M_v())); }\n   };\n \n   /// Specialization.\n@@ -1174,7 +1199,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     static bool\n     _S_equals(const _Equal& __eq, const _ExtractKey& __extract,\n \t      const _Key& __k, _HashCodeType, _Hash_node<_Value, false>* __n)\n-    { return __eq(__k, __extract(__n->_M_v)); }\n+    { return __eq(__k, __extract(__n->_M_v())); }\n   };\n \n \n@@ -1305,11 +1330,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       reference\n       operator*() const\n-      { return this->_M_cur->_M_v; }\n+      { return this->_M_cur->_M_v(); }\n \n       pointer\n       operator->() const\n-      { return std::__addressof(this->_M_cur->_M_v); }\n+      { return this->_M_cur->_M_valptr(); }\n \n       _Local_iterator&\n       operator++()\n@@ -1364,11 +1389,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       reference\n       operator*() const\n-      { return this->_M_cur->_M_v; }\n+      { return this->_M_cur->_M_v(); }\n \n       pointer\n       operator->() const\n-      { return std::__addressof(this->_M_cur->_M_v); }\n+      { return this->_M_cur->_M_valptr(); }\n \n       _Local_const_iterator&\n       operator++()\n@@ -1662,6 +1687,120 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ }\n     };\n \n+  /*\n+   * Following are functors recyclicing a pool of nodes and using allocation\n+   * once the pool is empty.\n+   */\n+  /// Version using copy semantic through the copy constructor.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _ReuseOrAllocNode\n+    {\n+    private:\n+      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t     _Equal, _H1, _H2, _Hash,\n+\t\t\t\t     _RehashPolicy, _Traits>;\n+      using __val_alloc_type = typename __hashtable::_Value_alloc_type;\n+      using __val_alloc_traits = typename __hashtable::_Value_alloc_traits;\n+      using __node_alloc_traits = typename __hashtable::_Node_alloc_traits;\n+      using __node_type = typename __hashtable::__node_type;\n+\n+    public:\n+      _ReuseOrAllocNode(__node_type* __nodes, __hashtable& __h)\n+\t: _M_nodes(__nodes), _M_h(__h) { }\n+      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;\n+\n+      ~_ReuseOrAllocNode()\n+      { _M_h._M_deallocate_nodes(_M_nodes); }\n+\n+      __node_type*\n+      operator()(const __node_type* __n) const\n+      {\n+\tif (_M_nodes)\n+\t  {\n+\t    __node_type* __node = _M_nodes;\n+\t    _M_nodes = _M_nodes->_M_next();\n+\t    __node->_M_nxt = nullptr;\n+\t    __val_alloc_type __a(_M_h._M_node_allocator());\n+\t    __val_alloc_traits::destroy(__a, __node->_M_valptr());\n+\t    __try\n+\t      {\n+\t\t__val_alloc_traits::construct(__a, __node->_M_valptr(),\n+\t\t\t\t\t      __n->_M_v());\n+\t      }\n+\t    __catch(...)\n+\t      {\n+\t\t__node->~__node_type();\n+\t\t__node_alloc_traits::deallocate(_M_h._M_node_allocator(),\n+\t\t\t\t\t\t__node, 1);\n+\t\t__throw_exception_again;\n+\t      }\n+\t    return __node;\n+\t  }\n+\treturn _M_h._M_allocate_node(__n->_M_v());\n+      }\n+\n+      mutable __node_type* _M_nodes;\n+      __hashtable& _M_h;\n+    };\n+\n+  /// Version using move semantic through the move constructor.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _MoveReuseOrAllocNode\n+    {\n+    private:\n+      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t     _Equal, _H1, _H2, _Hash,\n+\t\t\t\t     _RehashPolicy, _Traits>;\n+      using __val_alloc_type = typename __hashtable::_Value_alloc_type;\n+      using __val_alloc_traits = typename __hashtable::_Value_alloc_traits;\n+      using __node_alloc_traits = typename __hashtable::_Node_alloc_traits;\n+      using __node_type = typename __hashtable::__node_type;\n+\n+    public:\n+      _MoveReuseOrAllocNode(__node_type* __nodes, __hashtable& __h)\n+\t: _M_nodes(__nodes), _M_h(__h) { }\n+      _MoveReuseOrAllocNode(const _MoveReuseOrAllocNode&) = delete;\n+\n+      ~_MoveReuseOrAllocNode()\n+      { _M_h._M_deallocate_nodes(_M_nodes); }\n+\n+      __node_type*\n+      operator()(__node_type* __n) const\n+      {\n+\tif (_M_nodes)\n+\t  {\n+\t    __node_type* __node = _M_nodes;\n+\t    _M_nodes = _M_nodes->_M_next();\n+\t    __node->_M_nxt = nullptr;\n+\t    __val_alloc_type  __a(_M_h._M_node_allocator());\n+\t    __val_alloc_traits::destroy(__a, __node->_M_valptr());\n+\t    __try\n+\t      {\n+\t\t__val_alloc_traits::construct(__a, __node->_M_valptr(),\n+\t\t\t\t\tstd::move_if_noexcept(__n->_M_v()));\n+\t      }\n+\t    __catch(...)\n+\t      {\n+\t\t__node->~__node_type();\n+\t\t__node_alloc_traits::deallocate(_M_h._M_node_allocator(),\n+\t\t\t\t\t\t__node, 1);\n+\t\t__throw_exception_again;\n+\t      }\n+\t    return __node;\n+\t  }\n+\treturn _M_h._M_allocate_node(std::move_if_noexcept(__n->_M_v()));\n+      }\n+\n+      mutable __node_type* _M_nodes;\n+      __hashtable& _M_h;\n+    };\n+\n  //@} hashtable-detail\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace __detail"}, {"sha": "7fd84e35cc007bf3d9f7d57c43381bad35aa23e3", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -113,10 +113,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       //@{\n       ///  Iterator-related typedefs.\n-      typedef typename allocator_type::pointer\t\tpointer;\n-      typedef typename allocator_type::const_pointer\tconst_pointer;\n-      typedef typename allocator_type::reference\treference;\n-      typedef typename allocator_type::const_reference\tconst_reference;\n+      typedef typename _Hashtable::pointer\t\tpointer;\n+      typedef typename _Hashtable::const_pointer\tconst_pointer;\n+      typedef typename _Hashtable::reference\t\treference;\n+      typedef typename _Hashtable::const_reference\tconst_reference;\n       typedef typename _Hashtable::iterator\t\titerator;\n       typedef typename _Hashtable::const_iterator\tconst_iterator;\n       typedef typename _Hashtable::local_iterator\tlocal_iterator;\n@@ -170,6 +170,35 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       /// Move constructor.\n       unordered_map(unordered_map&&) = default;\n \n+      /**\n+       *  @brief Creates an %unordered_map with no elements.\n+       *  @param __a An allocator object.\n+       */\n+      explicit\n+      unordered_map(const allocator_type& __a)\n+\t: _M_h(__a)\n+      { }\n+\n+      /*\n+       *  @brief Copy constructor with allocator argument.\n+       * @param  __uset  Input %unordered_map to copy.\n+       * @param  __a  An allocator object.\n+       */\n+      unordered_map(const unordered_map& __umap,\n+\t\t    const allocator_type& __a)\n+\t: _M_h(__umap._M_h, __a)\n+      { }\n+\n+      /*\n+       *  @brief  Move constructor with allocator argument.\n+       *  @param  __uset Input %unordered_map to move.\n+       *  @param  __a    An allocator object.\n+       */\n+      unordered_map(unordered_map&& __umap,\n+\t\t    const allocator_type& __a)\n+\t: _M_h(std::move(__umap._M_h), __a)\n+      { }\n+\n       /**\n        *  @brief  Builds an %unordered_map from an initializer_list.\n        *  @param  __l  An initializer_list.\n@@ -508,6 +537,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       swap(unordered_map& __x)\n+      noexcept( noexcept(_M_h.swap(__x._M_h)) )\n       { _M_h.swap(__x._M_h); }\n \n       // observers.\n@@ -794,10 +824,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       //@{\n       ///  Iterator-related typedefs.\n-      typedef typename allocator_type::pointer\t\tpointer;\n-      typedef typename allocator_type::const_pointer\tconst_pointer;\n-      typedef typename allocator_type::reference\treference;\n-      typedef typename allocator_type::const_reference\tconst_reference;\n+      typedef typename _Hashtable::pointer\t\tpointer;\n+      typedef typename _Hashtable::const_pointer\tconst_pointer;\n+      typedef typename _Hashtable::reference\t\treference;\n+      typedef typename _Hashtable::const_reference\tconst_reference;\n       typedef typename _Hashtable::iterator\t\titerator;\n       typedef typename _Hashtable::const_iterator\tconst_iterator;\n       typedef typename _Hashtable::local_iterator\tlocal_iterator;\n@@ -851,6 +881,35 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       /// Move constructor.\n       unordered_multimap(unordered_multimap&&) = default;\n \n+      /**\n+       *  @brief Creates an %unordered_multimap with no elements.\n+       *  @param __a An allocator object.\n+       */\n+      explicit\n+      unordered_multimap(const allocator_type& __a)\n+\t: _M_h(__a)\n+      { }\n+\n+      /*\n+       *  @brief Copy constructor with allocator argument.\n+       * @param  __uset  Input %unordered_multimap to copy.\n+       * @param  __a  An allocator object.\n+       */\n+      unordered_multimap(const unordered_multimap& __ummap,\n+\t\t\t const allocator_type& __a)\n+\t: _M_h(__ummap._M_h, __a)\n+      { }\n+\n+      /*\n+       *  @brief  Move constructor with allocator argument.\n+       *  @param  __uset Input %unordered_multimap to move.\n+       *  @param  __a    An allocator object.\n+       */\n+      unordered_multimap(unordered_multimap&& __ummap,\n+\t\t\t const allocator_type& __a)\n+\t: _M_h(std::move(__ummap._M_h), __a)\n+      { }\n+\n       /**\n        *  @brief  Builds an %unordered_multimap from an initializer_list.\n        *  @param  __l  An initializer_list.\n@@ -1173,6 +1232,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       swap(unordered_multimap& __x)\n+      noexcept( noexcept(_M_h.swap(__x._M_h)) )\n       { _M_h.swap(__x._M_h); }\n \n       // observers."}, {"sha": "89deb496f11c440ef95537c28dcd3fa3ed48fc90", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "modified", "additions": 69, "deletions": 9, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -108,10 +108,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       //@{\n       ///  Iterator-related typedefs.\n-      typedef typename allocator_type::pointer\t\tpointer;\n-      typedef typename allocator_type::const_pointer\tconst_pointer;\n-      typedef typename allocator_type::reference\treference;\n-      typedef typename allocator_type::const_reference\tconst_reference;\n+      typedef typename _Hashtable::pointer\t\tpointer;\n+      typedef typename _Hashtable::const_pointer\tconst_pointer;\n+      typedef typename _Hashtable::reference\t\treference;\n+      typedef typename _Hashtable::const_reference\tconst_reference;\n       typedef typename _Hashtable::iterator\t\titerator;\n       typedef typename _Hashtable::const_iterator\tconst_iterator;\n       typedef typename _Hashtable::local_iterator\tlocal_iterator;\n@@ -164,6 +164,35 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       /// Move constructor.\n       unordered_set(unordered_set&&) = default;\n \n+      /**\n+       *  @brief Creates an %unordered_set with no elements.\n+       *  @param __a An allocator object.\n+       */\n+      explicit\n+      unordered_set(const allocator_type& __a)\n+\t: _M_h(__a)\n+      { }\n+\n+      /*\n+       *  @brief Copy constructor with allocator argument.\n+       * @param  __uset  Input %unordered_set to copy.\n+       * @param  __a  An allocator object.\n+       */\n+      unordered_set(const unordered_set& __uset,\n+\t\t    const allocator_type& __a)\n+\t: _M_h(__uset._M_h, __a)\n+      { }\n+\n+      /*\n+       *  @brief  Move constructor with allocator argument.\n+       *  @param  __uset Input %unordered_set to move.\n+       *  @param  __a    An allocator object.\n+       */\n+      unordered_set(unordered_set&& __uset,\n+\t\t    const allocator_type& __a)\n+\t: _M_h(std::move(__uset._M_h), __a)\n+      { }\n+\n       /**\n        *  @brief  Builds an %unordered_set from an initializer_list.\n        *  @param  __l  An initializer_list.\n@@ -482,6 +511,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       swap(unordered_set& __x)\n+      noexcept( noexcept(_M_h.swap(__x._M_h)) )\n       { _M_h.swap(__x._M_h); }\n \n       // observers.\n@@ -713,10 +743,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       //@{\n       ///  Iterator-related typedefs.\n-      typedef typename allocator_type::pointer\t\tpointer;\n-      typedef typename allocator_type::const_pointer\tconst_pointer;\n-      typedef typename allocator_type::reference\treference;\n-      typedef typename allocator_type::const_reference\tconst_reference;\n+      typedef typename _Hashtable::pointer\t\tpointer;\n+      typedef typename _Hashtable::const_pointer\tconst_pointer;\n+      typedef typename _Hashtable::reference\t\treference;\n+      typedef typename _Hashtable::const_reference\tconst_reference;\n       typedef typename _Hashtable::iterator\t\titerator;\n       typedef typename _Hashtable::const_iterator\tconst_iterator;\n       typedef typename _Hashtable::local_iterator\tlocal_iterator;\n@@ -794,7 +824,36 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       /// Move assignment operator.\n       unordered_multiset&\n-      operator=(unordered_multiset&& __x) = default;\n+      operator=(unordered_multiset&&) = default;\n+\n+      /**\n+       *  @brief Creates an %unordered_multiset with no elements.\n+       *  @param __a An allocator object.\n+       */\n+      explicit\n+      unordered_multiset(const allocator_type& __a)\n+\t: _M_h(__a)\n+      { }\n+\n+      /*\n+       *  @brief Copy constructor with allocator argument.\n+       * @param  __uset  Input %unordered_multiset to copy.\n+       * @param  __a  An allocator object.\n+       */\n+      unordered_multiset(const unordered_multiset& __umset,\n+\t\t\t const allocator_type& __a)\n+\t: _M_h(__umset._M_h, __a)\n+      { }\n+\n+      /*\n+       *  @brief  Move constructor with allocator argument.\n+       *  @param  __umset  Input %unordered_multiset to move.\n+       *  @param  __a  An allocator object.\n+       */\n+      unordered_multiset(unordered_multiset&& __umset,\n+\t\t\t const allocator_type& __a)\n+\t: _M_h(std::move(__umset._M_h), __a)\n+      { }\n \n       /**\n        *  @brief  %Unordered_multiset list assignment operator.\n@@ -1070,6 +1129,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       swap(unordered_multiset& __x)\n+      noexcept( noexcept(_M_h.swap(__x._M_h)) )\n       { _M_h.swap(__x._M_h); }\n \n       // observers."}, {"sha": "d62deac3917646a8f81fe43f2691e45b9dadf29a", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 70, "deletions": 18, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -60,6 +60,9 @@ namespace __debug\n       typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n       typedef typename _Base::local_iterator _Base_local_iterator;\n \n+      typedef __gnu_cxx::__alloc_traits<typename\n+\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n+\n     public:\n       typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n@@ -96,12 +99,27 @@ namespace __debug\n \t\t__gnu_debug::__base(__last), __n,\n \t\t__hf, __eql, __a) { }\n \n-      unordered_map(const unordered_map& __x) = default;\n+      unordered_map(const unordered_map&) = default;\n \n       unordered_map(const _Base& __x)\n       : _Base(__x) { }\n \n-      unordered_map(unordered_map&& __x) = default;\n+      unordered_map(unordered_map&&) = default;\n+\n+      explicit\n+      unordered_map(const allocator_type& __a)\n+\t: _Base(__a)\n+      { }\n+\n+      unordered_map(const unordered_map& __umap,\n+\t\t    const allocator_type& __a)\n+\t: _Base(__umap._M_base(), __a)\n+      { }\n+\n+      unordered_map(unordered_map&& __umap,\n+\t\t    const allocator_type& __a)\n+\t: _Base(std::move(__umap._M_base()), __a)\n+      { }\n \n       unordered_map(initializer_list<value_type> __l,\n \t\t    size_type __n = 0,\n@@ -115,33 +133,41 @@ namespace __debug\n       unordered_map&\n       operator=(const unordered_map& __x)\n       {\n-\t*static_cast<_Base*>(this) = __x;\n+\t_M_base() = __x._M_base();\n \tthis->_M_invalidate_all();\n \treturn *this;\n       }\n \n       unordered_map&\n       operator=(unordered_map&& __x)\n+      noexcept(_Alloc_traits::_S_nothrow_move())\n       {\n-   \t// NB: DR 1204.\n-\t// NB: DR 675.\n \t__glibcxx_check_self_move_assign(__x);\n-\tclear();\n-\tswap(__x);\n+\tbool xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n+\t    || __x.get_allocator() == this->get_allocator();\n+\t_M_base() = std::move(__x._M_base());\t\n+\tif (xfer_memory)\n+\t  this->_M_swap(__x);\n+\telse\n+\t  this->_M_invalidate_all();\n+\t__x._M_invalidate_all();\n \treturn *this;\n       }\n \n       unordered_map&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l);\n+\t_M_base() = __l;\n+\tthis->_M_invalidate_all();\n \treturn *this;\n       }\n \n       void\n       swap(unordered_map& __x)\n+      noexcept(_Alloc_traits::_S_nothrow_swap())\n       {\n+\tif (!_Alloc_traits::_S_propagate_on_swap())\n+\t  __glibcxx_check_equal_allocs(__x);\n \t_Base::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }\n@@ -490,6 +516,9 @@ namespace __debug\n       typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n       typedef typename _Base::local_iterator _Base_local_iterator;\n \n+      typedef __gnu_cxx::__alloc_traits<typename\n+\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n+\n     public:\n       typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n@@ -526,12 +555,27 @@ namespace __debug\n \t\t__gnu_debug::__base(__last), __n,\n \t\t__hf, __eql, __a) { }\n \n-      unordered_multimap(const unordered_multimap& __x) = default;\n+      unordered_multimap(const unordered_multimap&) = default;\n \n       unordered_multimap(const _Base& __x) \n       : _Base(__x) { }\n \n-      unordered_multimap(unordered_multimap&& __x) = default;\n+      unordered_multimap(unordered_multimap&&) = default;\n+\n+      explicit\n+      unordered_multimap(const allocator_type& __a)\n+\t: _Base(__a)\n+      { }\n+\n+      unordered_multimap(const unordered_multimap& __umap,\n+\t\t\t const allocator_type& __a)\n+\t: _Base(__umap._M_base(), __a)\n+      { }\n+\n+      unordered_multimap(unordered_multimap&& __umap,\n+\t\t\t const allocator_type& __a)\n+\t: _Base(std::move(__umap._M_base()), __a)\n+      { }\n \n       unordered_multimap(initializer_list<value_type> __l,\n \t\t\t size_type __n = 0,\n@@ -545,33 +589,41 @@ namespace __debug\n       unordered_multimap&\n       operator=(const unordered_multimap& __x)\n       {\n-\t*static_cast<_Base*>(this) = __x;\n+\t_M_base() = __x._M_base();\n \tthis->_M_invalidate_all();\n \treturn *this;\n       }\n \n       unordered_multimap&\n       operator=(unordered_multimap&& __x)\n+      noexcept(_Alloc_traits::_S_nothrow_move())\n       {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n \t__glibcxx_check_self_move_assign(__x);\n-\tclear();\n-\tswap(__x);\n+\tbool xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n+\t    || __x.get_allocator() == this->get_allocator();\n+\t_M_base() = std::move(__x._M_base());\n+\tif (xfer_memory)\n+\t  this->_M_swap(__x);\n+\telse\n+\t  this->_M_invalidate_all();\n+\t__x._M_invalidate_all();\n \treturn *this;\n       }\n \n       unordered_multimap&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l);\n+\t_M_base() = __l;\n+\tthis->_M_invalidate_all();\n \treturn *this;\n       }\n \n       void\n       swap(unordered_multimap& __x)\n+      noexcept(_Alloc_traits::_S_nothrow_swap())\n       {\n+\tif (!_Alloc_traits::_S_propagate_on_swap())\n+\t  __glibcxx_check_equal_allocs(__x);\n \t_Base::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }"}, {"sha": "66898e243b1b828265cc9073407236432d65abf1", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 71, "deletions": 20, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -60,6 +60,8 @@ namespace __debug\n       typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n       typedef typename _Base::local_iterator _Base_local_iterator;\n \n+      typedef __gnu_cxx::__alloc_traits<typename\n+\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n     public:\n       typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n@@ -96,12 +98,27 @@ namespace __debug\n \t\t__gnu_debug::__base(__last), __n,\n \t\t__hf, __eql, __a) { }\n \n-      unordered_set(const unordered_set& __x) = default;\n+      unordered_set(const unordered_set&) = default;\n \n-      unordered_set(const _Base& __x) \n-      : _Base(__x) { }\n+      unordered_set(const _Base& __x)\n+\t: _Base(__x) { }\n+\n+      unordered_set(unordered_set&&) = default;\n+\n+      explicit\n+      unordered_set(const allocator_type& __a)\n+\t: _Base(__a)\n+      { }\n+\n+      unordered_set(const unordered_set& __uset,\n+\t\t    const allocator_type& __a)\n+\t: _Base(__uset._M_base(), __a)\n+      { }\n \n-      unordered_set(unordered_set&& __x) = default;\n+      unordered_set(unordered_set&& __uset,\n+\t\t    const allocator_type& __a)\n+\t: _Base(std::move(__uset._M_base()), __a)\n+      { }\n \n       unordered_set(initializer_list<value_type> __l,\n \t\t    size_type __n = 0,\n@@ -115,33 +132,41 @@ namespace __debug\n       unordered_set&\n       operator=(const unordered_set& __x)\n       {\n-\t*static_cast<_Base*>(this) = __x;\n+\t_M_base() = __x._M_base();\n \tthis->_M_invalidate_all();\n \treturn *this;\n       }\n \n       unordered_set&\n       operator=(unordered_set&& __x)\n+      noexcept(_Alloc_traits::_S_nothrow_move())\n       {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n \t__glibcxx_check_self_move_assign(__x);\n-\tclear();\n-\tswap(__x);\n+\tbool xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n+\t    || __x.get_allocator() == this->get_allocator();\n+\t_M_base() = std::move(__x._M_base());\n+\tif (xfer_memory)\n+\t  this->_M_swap(__x);\n+\telse\n+\t  this->_M_invalidate_all();\n+\t__x._M_invalidate_all();\n \treturn *this;\n       }\n \n       unordered_set&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l);\n+\t_M_base() = __l;\n+\tthis->_M_invalidate_all();\n \treturn *this;\n       }\n \n       void\n       swap(unordered_set& __x)\n+      noexcept(_Alloc_traits::_S_nothrow_swap())\n       {\n+\tif (!_Alloc_traits::_S_propagate_on_swap())\n+\t  __glibcxx_check_equal_allocs(__x);\n \t_Base::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }\n@@ -485,6 +510,9 @@ namespace __debug\n       typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n       typedef typename _Base::local_iterator _Base_local_iterator;\n \n+      typedef __gnu_cxx::__alloc_traits<typename\n+\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n+\n     public:\n       typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n@@ -521,12 +549,27 @@ namespace __debug\n \t\t__gnu_debug::__base(__last), __n,\n \t\t__hf, __eql, __a) { }\n \n-      unordered_multiset(const unordered_multiset& __x) = default;\n+      unordered_multiset(const unordered_multiset&) = default;\n \n       unordered_multiset(const _Base& __x) \n       : _Base(__x) { }\n \n-      unordered_multiset(unordered_multiset&& __x) = default;\n+      unordered_multiset(unordered_multiset&&) = default;\n+\n+      explicit\n+      unordered_multiset(const allocator_type& __a)\n+\t: _Base(__a)\n+      { }\n+\n+      unordered_multiset(const unordered_multiset& __uset,\n+\t\t\t const allocator_type& __a)\n+\t: _Base(__uset._M_base(), __a)\n+      { }\n+      \n+      unordered_multiset(unordered_multiset&& __uset,\n+\t\t\t const allocator_type& __a)\n+\t: _Base(std::move(__uset._M_base()), __a)\n+      { }\n \n       unordered_multiset(initializer_list<value_type> __l,\n \t\t\t size_type __n = 0,\n@@ -540,33 +583,41 @@ namespace __debug\n       unordered_multiset&\n       operator=(const unordered_multiset& __x)\n       {\n-\t*static_cast<_Base*>(this) = __x;\n+\t_M_base() = __x._M_base();\n \tthis->_M_invalidate_all();\n \treturn *this;\n       }\n \n       unordered_multiset&\n       operator=(unordered_multiset&& __x)\n+      noexcept(_Alloc_traits::_S_nothrow_move())\n       {\n-\t// NB: DR 1204.\n-        // NB: DR 675.\n \t__glibcxx_check_self_move_assign(__x);\n-\tclear();\n-\tswap(__x);\n+\tbool xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n+\t    || __x.get_allocator() == this->get_allocator();\n+\t_M_base() = std::move(__x._M_base());\n+\tif (xfer_memory)\n+\t  this->_M_swap(__x);\n+\telse\n+\t  this->_M_invalidate_all();\n+\t__x._M_invalidate_all();\n \treturn *this;\n       }\n \n       unordered_multiset&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l);\n+\t_M_base() = __l;\n+\tthis->_M_invalidate_all();\n \treturn *this;\n       }\n \n       void\n       swap(unordered_multiset& __x)\n+      noexcept(_Alloc_traits::_S_nothrow_swap())\n       {\n+\tif (!_Alloc_traits::_S_propagate_on_swap())\n+\t  __glibcxx_check_equal_allocs(__x);\n \t_Base::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }"}, {"sha": "31f22dc386a59b68632a7a5bcd1df7bf531cebe6", "filename": "libstdc++-v3/include/ext/throw_allocator.h", "status": "modified", "additions": 195, "deletions": 31, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -90,7 +90,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     annotate_base()\n     {\n       label();\n-      map();\n+      map_alloc();\n     }\n \n     static void\n@@ -111,31 +111,61 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  std::__throw_logic_error(error.c_str());\n \t}\n \n-      const_iterator found = map().find(p);\n-      if (found != map().end())\n+      const_iterator found = map_alloc().find(p);\n+      if (found != map_alloc().end())\n \t{\n \t  std::string error(\"annotate_base::insert double insert!\\n\");\n \t  log_to_string(error, make_entry(p, size));\n \t  log_to_string(error, *found);\n \t  std::__throw_logic_error(error.c_str());\n \t}\n \n-      map().insert(make_entry(p, size));\n+      map_alloc().insert(make_entry(p, size));\n     }\n \n     void\n     erase(void* p, size_t size)\n     {\n       check_allocated(p, size);\n-      map().erase(p);\n+      map_alloc().erase(p);\n     }\n \n+#if __cplusplus >= 201103L\n+    void\n+    insert_construct(void* p)\n+    {\n+      if (!p)\n+\t{\n+\t  std::string error(\"annotate_base::insert_construct null!\\n\");\n+\t  std::__throw_logic_error(error.c_str());\n+\t}\n+\n+      auto found = map_construct().find(p);\n+      if (found != map_construct().end())\n+\t{\n+\t  std::string error(\"annotate_base::insert_construct double insert!\\n\");\n+\t  log_to_string(error, std::make_pair(p, get_label()));\n+\t  log_to_string(error, *found);\n+\t  std::__throw_logic_error(error.c_str());\n+\t}\n+\n+      map_construct().insert(std::make_pair(p, get_label()));\n+    }\n+\n+    void\n+    erase_construct(void* p)\n+    {\n+      check_constructed(p);\n+      map_construct().erase(p);\n+    }\n+#endif\n+\n     // See if a particular address and allocation size has been saved.\n     inline void\n     check_allocated(void* p, size_t size)\n     {\n-      const_iterator found = map().find(p);\n-      if (found == map().end())\n+      const_iterator found = map_alloc().find(p);\n+      if (found == map_alloc().end())\n \t{\n \t  std::string error(\"annotate_base::check_allocated by value \"\n \t\t\t    \"null erase!\\n\");\n@@ -155,32 +185,121 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     // See if a given label has been allocated.\n     inline void\n-    check_allocated(size_t label)\n+    check(size_t label)\n+    {\n+      std::string found;\n+      {\n+\tconst_iterator beg = map_alloc().begin();\n+\tconst_iterator end = map_alloc().end();\n+\twhile (beg != end)\n+\t  {\n+\t    if (beg->second.first == label)\n+\t      log_to_string(found, *beg);\n+\t    ++beg;\n+\t  }\n+      }\n+\n+#if __cplusplus >= 201103L\n+      {\n+\tauto beg = map_construct().begin();\n+\tauto end = map_construct().end();\n+\twhile (beg != end)\n+\t  {\n+\t    if (beg->second == label)\n+\t      log_to_string(found, *beg);\n+\t    ++beg;\n+\t  }\n+      }\n+#endif\n+\n+      if (!found.empty())\n+\t{\n+\t  std::string error(\"annotate_base::check by label\\n\");\n+\t  error += found;\n+\t  std::__throw_logic_error(error.c_str());\n+\t}\n+    }\n+\n+    // See if there is anything left allocated or constructed.\n+    inline static void\n+    check()\n+    {\n+      std::string found;\n+      {\n+\tconst_iterator beg = map_alloc().begin();\n+\tconst_iterator end = map_alloc().end();\n+\twhile (beg != end)\n+\t  {\n+\t    log_to_string(found, *beg);\n+\t    ++beg;\n+\t  }\n+      }\n+\n+#if __cplusplus >= 201103L\n+      {\n+\tauto beg = map_construct().begin();\n+\tauto end = map_construct().end();\n+\twhile (beg != end)\n+\t  {\n+\t    log_to_string(found, *beg);\n+\t    ++beg;\n+\t  }\n+      }\n+#endif\n+\n+      if (!found.empty())\n+\t{\n+\t  std::string error(\"annotate_base::check \\n\");\n+\t  error += found;\n+\t  std::__throw_logic_error(error.c_str());\n+\t}\n+    }\n+\n+#if __cplusplus >= 201103L\n+    inline void\n+    check_constructed(void* p)\n+    {\n+      auto found = map_construct().find(p);\n+      if (found == map_construct().end())\n+\t{\n+\t  std::string error(\"annotate_base::check_constructed not \"\n+\t\t\t    \"constructed!\\n\");\n+\t  log_to_string(error, std::make_pair(p, get_label()));\n+\t  std::__throw_logic_error(error.c_str());\n+\t}\n+    }\n+\n+    inline void\n+    check_constructed(size_t label)\n     {\n-      const_iterator beg = map().begin();\n-      const_iterator end = map().end();\n+      auto beg = map_construct().begin();\n+      auto end = map_construct().end();\n       std::string found;\n       while (beg != end)\n \t{\n-\t  if (beg->second.first == label)\n+\t  if (beg->second == label)\n \t    log_to_string(found, *beg);\n \t  ++beg;\n \t}\n \n       if (!found.empty())\n \t{\n-\t  std::string error(\"annotate_base::check_allocated by label\\n\");\n+\t  std::string error(\"annotate_base::check_constructed by label\\n\");\n \t  error += found;\n \t  std::__throw_logic_error(error.c_str());\n \t}\n     }\n+#endif\n \n   private:\n-    typedef std::pair<size_t, size_t> \t\tdata_type;\n-    typedef std::map<void*, data_type> \t\tmap_type;\n-    typedef map_type::value_type \t\tentry_type;\n-    typedef map_type::const_iterator \t\tconst_iterator;\n-    typedef map_type::const_reference \t\tconst_reference;\n+    typedef std::pair<size_t, size_t>\t\tdata_type;\n+    typedef std::map<void*, data_type> \t\tmap_alloc_type;\n+    typedef map_alloc_type::value_type \t\tentry_type;\n+    typedef map_alloc_type::const_iterator \t\tconst_iterator;\n+    typedef map_alloc_type::const_reference \t\tconst_reference;\n+#if __cplusplus >= 201103L\n+    typedef std::map<void*, size_t>\t\tmap_construct_type;\n+#endif\n \n     friend std::ostream&\n     operator<<(std::ostream&, const annotate_base&);\n@@ -189,8 +308,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     make_entry(void* p, size_t size)\n     { return std::make_pair(p, data_type(get_label(), size)); }\n \n-    void\n-    log_to_string(std::string& s, const_reference ref) const\n+    static void\n+    log_to_string(std::string& s, const_reference ref)\n     {\n       char buf[40];\n       const char tab('\\t');\n@@ -210,30 +329,67 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       s += '\\n';\n     }\n \n+#if __cplusplus >= 201103L\n+    static void\n+    log_to_string(std::string& s, const std::pair<const void*, size_t>& ref)\n+    {\n+      char buf[40];\n+      const char tab('\\t');\n+      s += \"label: \";\n+      unsigned long l = static_cast<unsigned long>(ref.second);\n+      __builtin_sprintf(buf, \"%lu\", l);\n+      s += buf;\n+      s += tab;\n+      s += \"address: \";\n+      __builtin_sprintf(buf, \"%p\", ref.first);\n+      s += buf;\n+      s += '\\n';\n+    }\n+#endif\n+\n     static size_t&\n     label()\n     {\n       static size_t _S_label(std::numeric_limits<size_t>::max());\n       return _S_label;\n     }\n \n-    static map_type&\n-    map()\n+    static map_alloc_type&\n+    map_alloc()\n     {\n-      static map_type _S_map;\n+      static map_alloc_type _S_map;\n       return _S_map;\n     }\n+\n+#if __cplusplus >= 201103L\n+    static map_construct_type&\n+    map_construct()\n+    {\n+      static map_construct_type _S_map;\n+      return _S_map;\n+    }\n+#endif\n   };\n \n   inline std::ostream&\n   operator<<(std::ostream& os, const annotate_base& __b)\n   {\n     std::string error;\n     typedef annotate_base base_type;\n-    base_type::const_iterator beg = __b.map().begin();\n-    base_type::const_iterator end = __b.map().end();\n-    for (; beg != end; ++beg)\n-      __b.log_to_string(error, *beg);\n+    {\n+      base_type::const_iterator beg = __b.map_alloc().begin();\n+      base_type::const_iterator end = __b.map_alloc().end();\n+      for (; beg != end; ++beg)\n+\t__b.log_to_string(error, *beg);\n+    }\n+#if __cplusplus >= 201103L\n+    {\n+      auto beg = __b.map_construct().begin();\n+      auto end = __b.map_construct().end();\n+      for (; beg != end; ++beg)\n+\t__b.log_to_string(error, *beg);      \n+    }\n+#endif\n     return os << error;\n   }\n \n@@ -685,12 +841,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Up, typename... _Args>\n         void\n         construct(_Up* __p, _Args&&... __args)\n-\t{ return _M_allocator.construct(__p, std::forward<_Args>(__args)...); }\n+\t{\n+\t  _M_allocator.construct(__p, std::forward<_Args>(__args)...);\n+\t  insert_construct(__p);\n+\t}\n \n       template<typename _Up>\n         void \n         destroy(_Up* __p)\n-        { _M_allocator.destroy(__p); }\n+        {\n+\t  erase_construct(__p);\n+\t  _M_allocator.destroy(__p);\n+\t}\n #else\n       void\n       construct(pointer __p, const value_type& val)\n@@ -716,8 +878,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       void\n-      check_allocated(size_type __n)\n-      { annotate_base::check_allocated(__n); }\n+      check(size_type __n)\n+      { annotate_base::check(__n); }\n   };\n \n   template<typename _Tp, typename _Cond>\n@@ -791,20 +953,22 @@ namespace std _GLIBCXX_VISIBILITY(default)\n       size_t\n       operator()(const __gnu_cxx::throw_value_limit& __val) const\n       {\n+\t__gnu_cxx::throw_value_limit::throw_conditionally();\n \tstd::hash<std::size_t> __h;\n \tsize_t __result = __h(__val._M_i);\n \treturn __result;\n       }\n     };\n \n-  /// Explicit specialization of std::hash for __gnu_cxx::throw_value_limit.\n+  /// Explicit specialization of std::hash for __gnu_cxx::throw_value_random.\n   template<>\n     struct hash<__gnu_cxx::throw_value_random>\n     : public std::unary_function<__gnu_cxx::throw_value_random, size_t>\n     {\n       size_t\n       operator()(const __gnu_cxx::throw_value_random& __val) const\n       {\n+\t__gnu_cxx::throw_value_random::throw_conditionally();\n \tstd::hash<std::size_t> __h;\n \tsize_t __result = __h(__val._M_i);\n \treturn __result;"}, {"sha": "ed5bf83431c2306793db3b5d1319251db3182c72", "filename": "libstdc++-v3/include/std/unordered_map", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -39,9 +39,9 @@\n #include <type_traits>\n #include <initializer_list>\n #include <tuple>\n-#include <bits/stl_algobase.h>\n #include <bits/allocator.h>\n-#include <bits/alloc_traits.h>\n+#include <ext/alloc_traits.h>\n+#include <ext/aligned_buffer.h>\n #include <bits/stl_function.h> // equal_to, _Identity, _Select1st\n #include <bits/functional_hash.h>\n #include <bits/hashtable.h>"}, {"sha": "12f39917f57932bbfd65d1c5fb6a2b44b5008911", "filename": "libstdc++-v3/include/std/unordered_set", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -39,9 +39,9 @@\n #include <type_traits>\n #include <initializer_list>\n #include <tuple>\n-#include <bits/stl_algobase.h>\n #include <bits/allocator.h>\n-#include <bits/alloc_traits.h>\n+#include <ext/alloc_traits.h>\n+#include <ext/aligned_buffer.h>\n #include <bits/stl_function.h> // equal_to, _Identity, _Select1st\n #include <bits/functional_hash.h>\n #include <bits/hashtable.h>"}, {"sha": "3b85f6fc249a5d5e1ab0431168cfbfcdc216f0af", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/allocator/copy.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fcopy.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,71 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "155e2f0b939bb6c6a3cea74b3aea631b9156d507", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/allocator/copy_assign.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fcopy_assign.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "9c99e4ec876d00c6fd7265537394e5fd9eda440f", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/allocator/minimal.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fminimal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fminimal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fminimal.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+\n+bool operator==(const T& l, const T& r) { return l.i == r.i; }\n+bool operator<(const T& l, const T& r) { return l.i < r.i; }\n+\n+using __gnu_test::SimpleAllocator;\n+\n+template class std::unordered_map<T, T, hash, equal_to, SimpleAllocator<T>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef SimpleAllocator<T> alloc_type;\n+  typedef std::allocator_traits<alloc_type> traits_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v(alloc_type{});\n+  v.emplace(std::piecewise_construct,\n+\t    std::make_tuple(T()), std::make_tuple(T()));\n+  VERIFY( v.max_size() == traits_type::max_size(v.get_allocator()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "0a9b9ec85166deccdd227810aa72d72eae843ae1", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/allocator/move_assign.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove_assign.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,89 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+#include <testsuite_counter_type.h>\n+\n+using __gnu_test::propagating_allocator;\n+using __gnu_test::counter_type;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<counter_type, false> alloc_type;\n+  typedef __gnu_test::counter_type_hasher hash;\n+  typedef std::unordered_map<counter_type, counter_type, hash,\n+\t\t\t     std::equal_to<counter_type>,\n+\t\t\t     alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(1), std::make_tuple(1));\n+\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(2), std::make_tuple(2));\n+\n+  counter_type::reset();\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( 1 == v1.get_allocator().get_personality() );\n+  VERIFY( 2 == v2.get_allocator().get_personality() );\n+\n+  // No move because key is const.\n+  VERIFY( counter_type::move_assign_count == 0  );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<counter_type, true> alloc_type;\n+  typedef __gnu_test::counter_type_hasher hash;\n+  typedef std::unordered_map<counter_type, counter_type, hash,\n+\t\t\t     std::equal_to<counter_type>,\n+\t\t\t     alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(1), std::make_tuple(1));\n+\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(2), std::make_tuple(2));\n+\n+  counter_type::reset();\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+\n+  VERIFY( counter_type::move_assign_count == 0 );\n+  VERIFY( counter_type::destructor_count == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "47eb61d77fcebf598fb5a1ce140c6436ac52706d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/allocator/noexcept.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fnoexcept.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+namespace __gnu_test\n+{\n+  inline void\n+  swap(propagating_allocator<T, true>& l, propagating_allocator<T, true>& r)\n+  noexcept(false)\n+  {\n+    typedef uneq_allocator<T> base_alloc;\n+    swap(static_cast<base_alloc&>(l), static_cast<base_alloc&>(r));\n+  }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<T> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  // static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "1b7cbc4cda984e47dad0b0095e60c58da025188d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/allocator/swap.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fswap.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,96 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+// It is undefined behaviour to swap() containers wth unequal allocators\n+// if the allocator doesn't propagate, so ensure the allocators compare\n+// equal, while still being able to test propagation via get_personality().\n+bool\n+operator==(const propagating_allocator<std::pair<const T, T>, false>&,\n+           const propagating_allocator<std::pair<const T, T>, false>&)\n+{\n+  return true;\n+}\n+\n+bool\n+operator!=(const propagating_allocator<std::pair<const T, T>, false>&,\n+           const propagating_allocator<std::pair<const T, T>, false>&)\n+{\n+  return false;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, T>, false> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+  // swap back so assertions in uneq_allocator::deallocate don't fail\n+  std::swap(v1, v2);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, T>, true> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "74c8f19455d993c98a474e97ee3ae56179bc8f01", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/allocator/copy.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fcopy.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,71 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "6ae476915acbea23ffca6e9a6132986c0fe40c3d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/allocator/copy_assign.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fcopy_assign.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "0d444f3cf997b06b8a29ea0764727745de96b39b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/allocator/minimal.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fminimal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fminimal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fminimal.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,64 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+\n+bool operator==(const T& l, const T& r) { return l.i == r.i; }\n+bool operator<(const T& l, const T& r) { return l.i < r.i; }\n+\n+using __gnu_test::SimpleAllocator;\n+\n+template class std::unordered_multimap<T, T, hash, equal_to,\n+\t\t\t\t       SimpleAllocator<T>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef SimpleAllocator<T> alloc_type;\n+  typedef std::allocator_traits<alloc_type> traits_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v(alloc_type{});\n+  v.emplace(std::piecewise_construct,\n+\t    std::make_tuple(T()), std::make_tuple(T()));\n+  VERIFY( v.max_size() == traits_type::max_size(v.get_allocator()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "89a3eb5e7ec9ed2bd8b82274c53e8f00cef553b0", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/allocator/move_assign.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove_assign.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,89 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+#include <testsuite_counter_type.h>\n+\n+using __gnu_test::propagating_allocator;\n+using __gnu_test::counter_type;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<counter_type, false> alloc_type;\n+  typedef __gnu_test::counter_type_hasher hash;\n+  typedef std::unordered_multimap<counter_type, counter_type, hash,\n+\t\t\t\t  std::equal_to<counter_type>,\n+\t\t\t\t  alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(1), std::make_tuple(1));\n+\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(2), std::make_tuple(2));\n+\n+  counter_type::reset();\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( 1 == v1.get_allocator().get_personality() );\n+  VERIFY( 2 == v2.get_allocator().get_personality() );\n+\n+  // No move because key is const.\n+  VERIFY( counter_type::move_assign_count == 0  );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<counter_type, true> alloc_type;\n+  typedef __gnu_test::counter_type_hasher hash;\n+  typedef std::unordered_multimap<counter_type, counter_type, hash,\n+\t\t\t\t  std::equal_to<counter_type>,\n+\t\t\t\t  alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(1), std::make_tuple(1));\n+\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(2), std::make_tuple(2));\n+\n+  counter_type::reset();\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+\n+  VERIFY( counter_type::move_assign_count == 0 );\n+  VERIFY( counter_type::destructor_count == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "de16cbd25e8c7df08dfcc6990d1b1e57050ed195", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/allocator/noexcept.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fnoexcept.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+namespace __gnu_test\n+{\n+  inline void\n+  swap(propagating_allocator<T, true>& l, propagating_allocator<T, true>& r)\n+  noexcept(false)\n+  {\n+    typedef uneq_allocator<T> base_alloc;\n+    swap(static_cast<base_alloc&>(l), static_cast<base_alloc&>(r));\n+  }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<T> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  // static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "fe8e3c74b6326fcb9907c82c5480a0e1b9963f16", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/allocator/swap.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fswap.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,96 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+// It is undefined behaviour to swap() containers wth unequal allocators\n+// if the allocator doesn't propagate, so ensure the allocators compare\n+// equal, while still being able to test propagation via get_personality().\n+bool\n+operator==(const propagating_allocator<std::pair<const T, T>, false>&,\n+           const propagating_allocator<std::pair<const T, T>, false>&)\n+{\n+  return true;\n+}\n+\n+bool\n+operator!=(const propagating_allocator<std::pair<const T, T>, false>&,\n+           const propagating_allocator<std::pair<const T, T>, false>&)\n+{\n+  return false;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, T>, false> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+  // swap back so assertions in uneq_allocator::deallocate don't fail\n+  std::swap(v1, v2);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, T>, true> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(alloc_type(2));\n+  v2.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "94b032b80de53866032e98070b8e7ca22adbcd8e", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/allocator/copy.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fcopy.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "50c6d4183fdef1e6556910a73241a7332e66b540", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/allocator/copy_assign.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fcopy_assign.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(alloc_type(2));\n+  v2.insert(T());\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(alloc_type(2));\n+  v2.insert(T());\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "b89034b6afb9f4792bf3abd618b0778f94b3b922", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/allocator/minimal.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fminimal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fminimal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fminimal.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+\n+bool operator==(const T& l, const T& r) { return l.i == r.i; }\n+bool operator<(const T& l, const T& r) { return l.i < r.i; }\n+\n+using __gnu_test::SimpleAllocator;\n+\n+template class std::unordered_multiset<T, hash, equal_to, SimpleAllocator<T>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef SimpleAllocator<T> alloc_type;\n+  typedef std::allocator_traits<alloc_type> traits_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v(alloc_type{});\n+  v.insert(T());\n+  VERIFY( v.max_size() == traits_type::max_size(v.get_allocator()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "aaba1e9fbe21515a67a29865a1a8267a445b7113", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/allocator/move_assign.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove_assign.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,86 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+#include <testsuite_counter_type.h>\n+\n+using __gnu_test::propagating_allocator;\n+using __gnu_test::counter_type;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<counter_type, false> alloc_type;\n+  typedef __gnu_test::counter_type_hasher hash;\n+  typedef std::unordered_multiset<counter_type, hash,\n+\t\t\t\t  std::equal_to<counter_type>,\n+\t\t\t\t  alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.emplace(0);\n+\n+  test_type v2(alloc_type(2));\n+  v2.emplace(1);\n+\n+  counter_type::reset();\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( 1 == v1.get_allocator().get_personality() );\n+  VERIFY( 2 == v2.get_allocator().get_personality() );\n+\n+  VERIFY( counter_type::move_count == 1  );\n+  VERIFY( counter_type::destructor_count == 2 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<counter_type, true> alloc_type;\n+  typedef __gnu_test::counter_type_hasher hash;\n+  typedef std::unordered_multiset<counter_type, hash,\n+\t\t\t\t  std::equal_to<counter_type>,\n+\t\t\t\t  alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.emplace(0);\n+\n+  test_type v2(alloc_type(2));\n+  v2.emplace(0);\n+\n+  counter_type::reset();\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+\n+  VERIFY( counter_type::move_count == 0 );\n+  VERIFY( counter_type::copy_count == 0 );\n+  VERIFY( counter_type::destructor_count == 1 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "5d69e0768ceda9c36efc95a78190fd53d773ca50", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/allocator/noexcept.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fnoexcept.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+namespace __gnu_test\n+{\n+  inline void\n+  swap(propagating_allocator<T, true>& l, propagating_allocator<T, true>& r)\n+  noexcept(false)\n+  {\n+    typedef uneq_allocator<T> base_alloc;\n+    swap(static_cast<base_alloc&>(l), static_cast<base_alloc&>(r));\n+  }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<T> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  // static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "bce2dd1e898e73fda30bf9202dda06ae115e7a38", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/allocator/swap.cc", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fswap.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,92 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+// It is undefined behaviour to swap() containers wth unequal allocators\n+// if the allocator doesn't propagate, so ensure the allocators compare\n+// equal, while still being able to test propagation via get_personality().\n+bool\n+operator==(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return true;\n+}\n+\n+bool\n+operator!=(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return false;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(alloc_type(2));\n+  v2.insert(T());\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+  // swap back so assertions in uneq_allocator::deallocate don't fail\n+  std::swap(v1, v2);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(alloc_type(2));\n+  v2.insert(T());\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "8f1b7ee638c64957629f6818d9069c31f2933a18", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/copy.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fcopy.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "e50b72a78b2a3697fbbb409a19cdd1a03f0cf8ba", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/copy_assign.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fcopy_assign.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(alloc_type(2));\n+  v2.insert(T());\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(alloc_type(2));\n+  v2.insert(T());\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "5e1f2f5c714ab11f3c1904d7d0dfce518878d6b9", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/minimal.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fminimal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fminimal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fminimal.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2012-2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+\n+bool operator==(const T& l, const T& r) { return l.i == r.i; }\n+bool operator<(const T& l, const T& r) { return l.i < r.i; }\n+\n+using __gnu_test::SimpleAllocator;\n+\n+template class std::unordered_set<T, hash, equal_to, SimpleAllocator<T>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef SimpleAllocator<T> alloc_type;\n+  typedef std::allocator_traits<alloc_type> traits_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v(alloc_type{});\n+  v.insert(T());\n+  VERIFY( v.max_size() == traits_type::max_size(v.get_allocator()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ad4aebc7e6370236a5fbe1b5406415817d6f7285", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/move_assign.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove_assign.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,86 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+#include <testsuite_counter_type.h>\n+\n+using __gnu_test::propagating_allocator;\n+using __gnu_test::counter_type;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<counter_type, false> alloc_type;\n+  typedef __gnu_test::counter_type_hasher hash;\n+  typedef std::unordered_set<counter_type, hash,\n+\t\t\t     std::equal_to<counter_type>,\n+\t\t\t     alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.emplace(0);\n+\n+  test_type v2(alloc_type(2));\n+  v2.emplace(1);\n+\n+  counter_type::reset();\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( 1 == v1.get_allocator().get_personality() );\n+  VERIFY( 2 == v2.get_allocator().get_personality() );\n+\n+  VERIFY( counter_type::move_count == 1  );\n+  VERIFY( counter_type::destructor_count == 2 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<counter_type, true> alloc_type;\n+  typedef __gnu_test::counter_type_hasher hash;\n+  typedef std::unordered_set<counter_type, hash,\n+\t\t\t     std::equal_to<counter_type>,\n+\t\t\t     alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.emplace(0);\n+\n+  test_type v2(alloc_type(2));\n+  v2.emplace(0);\n+\n+  counter_type::reset();\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+\n+  VERIFY( counter_type::move_count == 0 );\n+  VERIFY( counter_type::copy_count == 0 );\n+  VERIFY( counter_type::destructor_count == 1 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "0f73126ccd95bb2f0ff58d93e4dc14bad5cedf9b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/noexcept.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fnoexcept.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+namespace __gnu_test\n+{\n+  inline void\n+  swap(propagating_allocator<T, true>& l, propagating_allocator<T, true>& r)\n+  noexcept(false)\n+  {\n+    typedef uneq_allocator<T> base_alloc;\n+    swap(static_cast<base_alloc&>(l), static_cast<base_alloc&>(r));\n+  }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<T> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  // static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "5b436706ba56996c8bce3379270cb74bb76e7b02", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/swap.cc", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fswap.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -0,0 +1,92 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::propagating_allocator;\n+\n+// It is undefined behaviour to swap() containers wth unequal allocators\n+// if the allocator doesn't propagate, so ensure the allocators compare\n+// equal, while still being able to test propagation via get_personality().\n+bool\n+operator==(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return true;\n+}\n+\n+bool\n+operator!=(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return false;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(alloc_type(2));\n+  v2.insert(T());\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+  // swap back so assertions in uneq_allocator::deallocate don't fail\n+  std::swap(v1, v2);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(alloc_type(2));\n+  v2.insert(T());\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "f22c8bef31a19e1c7cc67225c93ee765c112669f", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/instantiation_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"with noexcept\" \"\" { target *-*-* } 252 }\n+// { dg-error \"with noexcept\" \"\" { target *-*-* } 254 }\n \n #include <unordered_set>\n "}, {"sha": "7590344b61a71bc6957c560edaa6085c74f59086", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/not_default_constructible_hash_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"default constructible\" \"\" { target *-*-* } 268 }\n+// { dg-error \"default constructible\" \"\" { target *-*-* } 272 }\n \n #include <unordered_set>\n "}, {"sha": "790323661cc98b7d8fbd55b5a20015e177c48975", "filename": "libstdc++-v3/testsuite/util/exception/safety.h", "status": "modified", "additions": 168, "deletions": 99, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -1292,6 +1292,48 @@ namespace __gnu_test\n \t    { throw; }\n \t}\n       };\n+\n+    template<typename _Tp>\n+      struct assign_operator\n+      {\n+\t_Tp _M_other;\n+\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      // An exception while assigning might leave the container empty\n+\t      // making future attemps less relevant. So we copy it before to\n+\t      // always assign to a non empty container. It also check for copy\n+\t      // constructor exception safety at the same time.\n+\t      _Tp __clone(__container);\n+\t      __clone = _M_other;\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+\n+\n+#if __cplusplus >= 201103L\n+    template<typename _Tp>\n+      struct move_assign_operator\n+      {\n+\t_Tp _M_other;\n+\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      __container = std::move(_M_other);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+#endif\n   };\n \n   // Base class for exception tests.\n@@ -1320,27 +1362,12 @@ namespace __gnu_test\n       typedef swap<container_type> \t\t\tswap;\n       typedef iterator_operations<container_type>\titerator_ops;\n       typedef const_iterator_operations<container_type>\tconst_iterator_ops;\n+      typedef assign_operator<container_type>\t\tassign_operator;\n+#if __cplusplus >= 201103L\n+      typedef move_assign_operator<container_type>\tmove_assign_operator;\n+#endif\n \n       using base_type::compare;\n-\n-      // Functor objects.\n-      clear\t\t\t_M_clear;\n-      erase_point\t\t_M_erasep;\n-      erase_range\t\t_M_eraser;\n-      insert_point\t\t_M_insertp;\n-      emplace\t\t\t_M_emplace;\n-      emplace_point\t\t_M_emplacep;\n-      emplace_front\t\t_M_emplacef;\n-      emplace_back\t\t_M_emplaceb;\n-      pop_front\t\t\t_M_popf;\n-      pop_back\t\t\t_M_popb;\n-      push_front\t       \t_M_pushf;\n-      push_back\t\t\t_M_pushb;\n-      rehash\t\t\t_M_rehash;\n-      swap\t\t\t_M_swap;\n-\n-      iterator_ops\t       \t_M_iops;\n-      const_iterator_ops\t_M_ciops;\n     };\n \n \n@@ -1369,67 +1396,97 @@ namespace __gnu_test\n \n       using base_type::generate;\n \n-      container_type \t\t\t\t\t_M_container;\n-      std::vector<function_type>\t\t\t_M_functions;\n-\n       basic_safety() { run(); }\n \n       void\n       run()\n       {\n-\t// Setup.\n-\tcondition_type::never_adjustor off;\n-\t\n-\t// Construct containers.\n-\tpopulate p1(_M_container);\n-\tpopulate p2(base_type::_M_swap._M_other);\n-\t\n-\t// Construct list of member functions to exercise.\n-\t_M_functions.push_back(function_type(base_type::_M_iops));\n-\t_M_functions.push_back(function_type(base_type::_M_ciops));\n-\t\n-\t_M_functions.push_back(function_type(base_type::_M_erasep));\n-\t_M_functions.push_back(function_type(base_type::_M_eraser));\n-\t_M_functions.push_back(function_type(base_type::_M_insertp));\n-\t_M_functions.push_back(function_type(base_type::_M_emplace));\n-\t_M_functions.push_back(function_type(base_type::_M_emplacep));\n-\t_M_functions.push_back(function_type(base_type::_M_emplacef));\n-\t_M_functions.push_back(function_type(base_type::_M_emplaceb));\n-\t_M_functions.push_back(function_type(base_type::_M_popf));\n-\t_M_functions.push_back(function_type(base_type::_M_popb));\n-\t_M_functions.push_back(function_type(base_type::_M_pushf));\n-\t_M_functions.push_back(function_type(base_type::_M_pushb));\n-\t_M_functions.push_back(function_type(base_type::_M_rehash));\n-\t_M_functions.push_back(function_type(base_type::_M_swap));\n+\t{\n+\t  // Setup.\n+\t  condition_type::never_adjustor off;\n+\n+\t  // Construct containers.\n+\t  container_type container;\n+\t  populate p1(container);\n+\n+\t  // Construct list of member functions to exercise.\n+\t  std::vector<function_type> functions;\n+\t  typename base_type::iterator_ops iops;\n+\t  functions.push_back(function_type(iops));\n+\t  typename base_type::const_iterator_ops ciops;\n+\t  functions.push_back(function_type(ciops));\n \t\n-\t// Last.\n-\t_M_functions.push_back(function_type(base_type::_M_clear));\n+\t  typename base_type::erase_point erasep;\n+\t  functions.push_back(function_type(erasep));\n+\t  typename base_type::erase_range eraser;\n+\t  functions.push_back(function_type(eraser));\n+\t  typename base_type::insert_point insertp;\n+\t  functions.push_back(function_type(insertp));\n+\t  typename base_type::emplace emplace;\n+\t  functions.push_back(function_type(emplace));\n+\t  typename base_type::emplace_point emplacep;\n+\t  functions.push_back(function_type(emplacep));\n+\t  typename base_type::emplace_front emplacef;\n+\t  functions.push_back(function_type(emplacef));\n+\t  typename base_type::emplace_back emplaceb;\n+\t  functions.push_back(function_type(emplaceb));\n+\t  typename base_type::pop_front popf;\n+\t  functions.push_back(function_type(popf));\n+\t  typename base_type::pop_back popb;\n+\t  functions.push_back(function_type(popb));\n+\t  typename base_type::push_front pushf;\n+\t  functions.push_back(function_type(pushf));\n+\t  typename base_type::push_back pushb;\n+\t  functions.push_back(function_type(pushb));\n+\t  typename base_type::rehash rehash;\n+\t  functions.push_back(function_type(rehash));\n+\t  typename base_type::swap swap;\n+\t  populate p2(swap._M_other);\n+\t  functions.push_back(function_type(swap));\n+\t  typename base_type::assign_operator assignop;\n+\t  populate p3(assignop._M_other);\n+\t  functions.push_back(function_type(assignop));\n+#if __cplusplus >= 201103L\n+\t  typename base_type::move_assign_operator massignop;\n+\t  populate p4(massignop._M_other);\n+\t  functions.push_back(function_type(massignop));\n+#endif\t\n+\t  // Last.\n+\t  typename base_type::clear clear;\n+\t  functions.push_back(function_type(clear));\n \n-\t// Run tests.\n-\tfor (auto i = _M_functions.begin(); i != _M_functions.end(); ++i)\n-\t  {\n-\t    function_type& f = *i;\n-\t    run_steps_to_limit(f);\n-\t  }\n+\t  // Run tests.\n+\t  size_t i(1);\n+\t  for (auto it = functions.begin(); it != functions.end(); ++it)\n+\t    {\n+\t      function_type& f = *it;\n+\t      i = run_steps_to_limit(i, container, f);\n+\t    }\n+\t}\n+\n+\t// Now that all instances has been destroyed check that there is no\n+\t// allocation remaining.\n+\tstd::cout << \"Checking remaining stuff\" << std::endl;\n+\t__gnu_cxx::annotate_base::check();\n       }\n \n       template<typename _Funct>\n-\tvoid\n-\trun_steps_to_limit(const _Funct& __f)\n+\tsize_t\n+\trun_steps_to_limit(size_t __step, container_type& __cont,\n+\t\t\t   const _Funct& __f)\n \t{\n-\t  size_t i(1);\n \t  bool exit(false);\n-\t  auto a = _M_container.get_allocator();\n+\t  auto a = __cont.get_allocator();\n \n \t  do\n \t    {\n \t      // Use the current step as an allocator label.\n-\t      a.set_label(i);\n+\t      a.set_label(__step);\n \n \t      try\n \t\t{\n-\t\t  condition_type::limit_adjustor limit(i);\n-\t\t  __f(_M_container);\n+\t\t  condition_type::limit_adjustor limit(__step);\n+\t\t  __f(__cont);\n \n \t\t  // If we get here, done.\n \t\t  exit = true;\n@@ -1438,18 +1495,19 @@ namespace __gnu_test\n \t\t{\n \t\t  // Check this step for allocations.\n \t\t  // NB: Will throw std::logic_error if allocations.\n-\t\t  a.check_allocated(i);\n+\t\t  a.check(__step);\n \n \t\t  // Check memory allocated with operator new.\n \n-\t\t  ++i;\n \t\t}\n+\t      ++__step;\n \t    }\n \t  while (!exit);\n \n \t  // Log count info.\n \t  std::cout << __f.target_type().name() << std::endl;\n-\t  std::cout << \"end count \" << i << std::endl;\n+\t  std::cout << \"end count \" << __step << std::endl;\n+\t  return __step;\n \t}\n   };\n \n@@ -1467,8 +1525,6 @@ namespace __gnu_test\n       typedef typename base_type::populate \t\tpopulate;\n       typedef __gnu_cxx::random_condition\t\tcondition_type;\n \n-      container_type \t\t\t\t\t_M_container;\n-\n       generation_prohibited()  { run(); }\n \n       void\n@@ -1479,10 +1535,13 @@ namespace __gnu_test\n \t// propagated and in error. Sudden death!\n \n \t// Setup.\n+\tcontainer_type container;\n+\ttypename base_type::swap swap;\n+\n \t{\n \t  condition_type::never_adjustor off;\n-\t  populate p1(_M_container);\n-\t  populate p2(base_type::_M_swap._M_other);\n+\t  populate p1(container);\n+\t  populate p2(swap._M_other);\n \t}\n \n \t// Run tests.\n@@ -1493,20 +1552,27 @@ namespace __gnu_test\n \t  // constructor or assignment operator of value_type throws.\n \t  if (!traits<container_type>::has_throwing_erase::value)\n \t    {\n-\t      this->_M_erasep(_M_container);\n-\t      this->_M_eraser(_M_container);\n+\t      typename base_type::erase_point erasep;\n+\t      erasep(container);\n+\t      typename base_type::erase_range eraser;\n+\t      eraser(container);\n \t    }\n \n-\t  this->_M_popf(_M_container);\n-\t  this->_M_popb(_M_container);\n+\t  typename base_type::pop_front popf;\n+\t  popf(container);\n+\t  typename base_type::pop_back popb;\n+\t  popb(container);\n \n-\t  this->_M_iops(_M_container);\n-\t  this->_M_ciops(_M_container);\n+\t  typename base_type::iterator_ops iops;\n+\t  iops(container);\n+\t  typename base_type::const_iterator_ops ciops;\n+\t  ciops(container);\n \n-\t  this->_M_swap(_M_container);\n+\t  swap(container);\n \n \t  // Last.\n-\t  this->_M_clear(_M_container);\n+\t  typename base_type::clear clear;\n+\t  clear(container);\n \t}\n       }\n     };\n@@ -1529,16 +1595,8 @@ namespace __gnu_test\n \n       using base_type::compare;\n \n-      container_type \t\t\t\t\t_M_container_test;\n-      container_type \t\t\t\t\t_M_container_control;\n-      std::vector<function_type>\t\t\t_M_functions;\n-\n       propagation_consistent() { run(); }\n \n-      void\n-      sync()\n-      { _M_container_test = _M_container_control; }\n-\n       // Run test.\n       void\n       run()\n@@ -1547,48 +1605,59 @@ namespace __gnu_test\n \tcondition_type::never_adjustor off;\n \n \t// Construct containers.\n-\tpopulate p(_M_container_control);\n+\tcontainer_type container_control;\n+\n+\tpopulate p(container_control);\n \n \t// Construct list of member functions to exercise.\n-\t_M_functions.push_back(function_type(base_type::_M_emplace));\n-\t_M_functions.push_back(function_type(base_type::_M_emplacep));\n-\t_M_functions.push_back(function_type(base_type::_M_emplacef));\n-\t_M_functions.push_back(function_type(base_type::_M_emplaceb));\n-\t_M_functions.push_back(function_type(base_type::_M_pushf));\n-\t_M_functions.push_back(function_type(base_type::_M_pushb));\n-\t_M_functions.push_back(function_type(base_type::_M_insertp));\n-\t_M_functions.push_back(function_type(base_type::_M_rehash));\n+\tstd::vector<function_type> functions;\n+\ttypename base_type::emplace emplace;\n+\tfunctions.push_back(function_type(emplace));\n+\ttypename base_type::emplace_point emplacep;\n+\tfunctions.push_back(function_type(emplacep));\n+\ttypename base_type::emplace_front emplacef;\n+\tfunctions.push_back(function_type(emplacef));\n+\ttypename base_type::emplace_back emplaceb;\n+\tfunctions.push_back(function_type(emplaceb));\n+\ttypename base_type::push_front pushf;\n+\tfunctions.push_back(function_type(pushf));\n+\ttypename base_type::push_back pushb;\n+\tfunctions.push_back(function_type(pushb));\n+\ttypename base_type::insert_point insertp;\n+\tfunctions.push_back(function_type(insertp));\n+\ttypename base_type::rehash rehash;\n+\tfunctions.push_back(function_type(rehash));\n \n \t// Run tests.\n-\tfor (auto i = _M_functions.begin(); i != _M_functions.end(); ++i)\n+\tfor (auto i = functions.begin(); i != functions.end(); ++i)\n \t  {\n \t    function_type& f = *i;\n-\t    run_steps_to_limit(f);\n+\t    run_steps_to_limit(container_control, f);\n \t  }\n       }\n \n       template<typename _Funct>\n \tvoid\n-\trun_steps_to_limit(const _Funct& __f)\n+\trun_steps_to_limit(container_type& container_control, const _Funct& __f)\n \t{\n \t  size_t i(1);\n \t  bool exit(false);\n \n \t  do\n \t    {\n-\t      sync();\n+\t      container_type container_test(container_control);\n \n \t      try\n \t\t{\n \t\t  condition_type::limit_adjustor limit(i);\n-\t\t  __f(_M_container_test);\n+\t\t  __f(container_test);\n \n \t\t  // If we get here, done.\n \t\t  exit = true;\n \t\t}\n \t      catch(const __gnu_cxx::forced_error&)\n \t\t{\n-\t\t  compare(_M_container_control, _M_container_test);\n+\t\t  compare(container_control, container_test);\n \t\t  ++i;\n \t\t}\n \t    }"}, {"sha": "86d479a7054f00f1379af5d04c0e1d292b9f1433", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/container_rand_regression_test.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.tcc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -1003,7 +1003,7 @@ operator()()\n   delete m_p_c;\n \n   try \n-    { m_alloc.check_allocated(memory_label); }\n+    { m_alloc.check(memory_label); }\n   catch (...)\n     {\n       std::cerr << \"detected leaks!\" << std::endl;"}, {"sha": "6a4c5f6f8240432bd7be3b915bf9b6f00c4f50e5", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/container_rand_regression_test.tcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.tcc?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -352,11 +352,11 @@ operator()()\n   try \n     { \n       for (size_t n = starting_label; n <= m_n; ++n)\n-\tm_alloc.check_allocated(n); \n+\tm_alloc.check(n); \n     }\n   catch (std::logic_error& obj)\n     {\n-      // On fail, check_allocated should throw std::logic_error.\n+      // On fail, check should throw std::logic_error.\n       std::cerr << obj.what() << std::endl;\n       std::cerr << typeid(Cntnr).name() << std::endl;\n       throw;"}, {"sha": "5bf71a947a7199e6936a04399b69a1cc97bddb07", "filename": "libstdc++-v3/testsuite/util/testsuite_counter_type.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_counter_type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0462b6aa20fd6734f7497f5eed9496d33701a952/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_counter_type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_counter_type.h?ref=0462b6aa20fd6734f7497f5eed9496d33701a952", "patch": "@@ -36,23 +36,21 @@ namespace __gnu_test\n     static int move_count;\n     static int move_assign_count;\n #endif\n+    static int destructor_count;\n \n     int val;\n     \n     counter_type() : val(0)\n-    {\n-      ++default_count;\n-    }\n+    { ++default_count; }\n \n     counter_type(int inval) : val(inval)\n-    {\n-      ++specialize_count;\n-    }\n+    { ++specialize_count; }\n \n     counter_type(const counter_type& in) : val(in.val)\n-    {\n-      ++copy_count;\n-    }\n+    { ++copy_count; }\n+\n+    ~counter_type()\n+    { ++destructor_count; }\n \n     counter_type&\n     operator=(const counter_type& in)\n@@ -70,7 +68,7 @@ namespace __gnu_test\n     }\n \n     counter_type&\n-    operator=(counter_type&& rhs)\n+    operator=(counter_type&& rhs) noexcept\n     {\n       val = rhs.val;\n       ++move_assign_count;\n@@ -90,6 +88,7 @@ namespace __gnu_test\n       move_count = 0;\n       move_assign_count = 0;\n #endif\n+      destructor_count = 0;\n     }\n \n     bool operator==(const counter_type& rhs) const\n@@ -109,6 +108,7 @@ namespace __gnu_test\n   int counter_type::move_count = 0;\n   int counter_type::move_assign_count = 0;\n #endif\n+  int counter_type::destructor_count = 0;\n \n   struct counter_type_hasher\n   {"}]}