{"sha": "680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgwYzYwZmViNDMwMzVhYTNiMWVlNmFjM2JjYzkwNTViZjUwZmQ1ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-02-25T08:18:24Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-02-25T08:18:24Z"}, "message": "re PR debug/77589 (fortran: Missing DW_AT_byte_stride for an array record field selection)\n\n\tPR debug/77589\ninclude/\n\t* dwarf2.def (DW_OP_GNU_variable_value): New opcode.\ngcc/\n\t* dwarf2out.c (struct dw_loc_list_struct): Add noted_variable_value\n\tbitfield.\n\t(size_of_loc_descr): Handle DW_OP_GNU_variable_value.\n\t(output_loc_operands): Handle DW_OP_call_ref and\n\tDW_OP_GNU_variable_value.\n\t(struct variable_value_struct): New type.\n\t(struct variable_value_hasher): Likewise.\n\t(variable_value_hash): New variable.\n\t(string_types): Remove.\n\t(copy_loc_descr): New function.\n\t(add_loc_descr_to_each): Clarify comment.  Use copy_loc_descr.\n\t(prepend_loc_descr_to_each): New function.\n\t(add_loc_list): Fix comment typo.  Use prepend_loc_descr_to_each\n\tinstead of add_loc_descr_to_each if the first argument is single\n\tlocation list and the second has multiple.\n\t(resolve_args_picking_1): Handle DW_OP_GNU_variable_value.\n\t(loc_list_from_tree_1): For early_dwarf, emit DW_OP_GNU_variable_value\n\twhen looking for variable value which doesn't have other location info.\n\t(loc_list_from_tree): Formatting fix.\n\t(gen_array_type_die): Simplify DW_AT_string_length handling.\n\t(adjust_string_types): Remove.\n\t(gen_subprogram_die): Don't call adjust_string_types nor test/set\n\tstring_types.  Call resolve_variable_values.\n\t(prune_unused_types_walk_loc_descr): Handle DW_OP_GNU_variable_value.\n\t(resolve_addr_in_expr): Likewise.  Add A argument.\n\t(copy_deref_exprloc): Remove deref argument.  Adjust for the\n\toriginal expression being DW_OP_GNU_variable_value with optionally\n\tDW_OP_stack_value after it instead of DW_OP_call4 with DW_OP_deref\n\toptionally after it.\n\t(optimize_string_length): Rework for DW_OP_GNU_variable_value.\n\t(resolve_addr): Adjust optimize_string_length and resolve_addr_in_expr\n\tcallers.  Set remove_AT_byte_size if removing DW_AT_string_length.\n\t(variable_value_hasher::hash, variable_value_hasher::equal): New\n\tmethods.\n\t(resolve_variable_value_in_expr, resolve_variable_value,\n\tresolve_variable_values, note_variable_value_in_expr,\n\tnote_variable_value): New functions.\n\t(dwarf2out_early_finish): Call note_variable_value on all toplevel\n\tDIEs.\n\nFrom-SVN: r245733", "tree": {"sha": "5fb3988baa9b0eb009e0de677ef621c40c56981e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fb3988baa9b0eb009e0de677ef621c40c56981e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a920ed32a76182218dff13bb0b2ee1f21532559b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a920ed32a76182218dff13bb0b2ee1f21532559b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a920ed32a76182218dff13bb0b2ee1f21532559b"}], "stats": {"total": 688, "additions": 546, "deletions": 142}, "files": [{"sha": "a38fd2063ecc6c6dd45bcdaccc7cbc02a5337c59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e", "patch": "@@ -1,3 +1,46 @@\n+2017-02-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/77589\n+\t* dwarf2out.c (struct dw_loc_list_struct): Add noted_variable_value\n+\tbitfield.\n+\t(size_of_loc_descr): Handle DW_OP_GNU_variable_value.\n+\t(output_loc_operands): Handle DW_OP_call_ref and\n+\tDW_OP_GNU_variable_value.\n+\t(struct variable_value_struct): New type.\n+\t(struct variable_value_hasher): Likewise.\n+\t(variable_value_hash): New variable.\n+\t(string_types): Remove.\n+\t(copy_loc_descr): New function.\n+\t(add_loc_descr_to_each): Clarify comment.  Use copy_loc_descr.\n+\t(prepend_loc_descr_to_each): New function.\n+\t(add_loc_list): Fix comment typo.  Use prepend_loc_descr_to_each\n+\tinstead of add_loc_descr_to_each if the first argument is single\n+\tlocation list and the second has multiple.\n+\t(resolve_args_picking_1): Handle DW_OP_GNU_variable_value.\n+\t(loc_list_from_tree_1): For early_dwarf, emit DW_OP_GNU_variable_value\n+\twhen looking for variable value which doesn't have other location info.\n+\t(loc_list_from_tree): Formatting fix.\n+\t(gen_array_type_die): Simplify DW_AT_string_length handling.\n+\t(adjust_string_types): Remove.\n+\t(gen_subprogram_die): Don't call adjust_string_types nor test/set\n+\tstring_types.  Call resolve_variable_values.\n+\t(prune_unused_types_walk_loc_descr): Handle DW_OP_GNU_variable_value.\n+\t(resolve_addr_in_expr): Likewise.  Add A argument.\n+\t(copy_deref_exprloc): Remove deref argument.  Adjust for the\n+\toriginal expression being DW_OP_GNU_variable_value with optionally\n+\tDW_OP_stack_value after it instead of DW_OP_call4 with DW_OP_deref\n+\toptionally after it.\n+\t(optimize_string_length): Rework for DW_OP_GNU_variable_value.\n+\t(resolve_addr): Adjust optimize_string_length and resolve_addr_in_expr\n+\tcallers.  Set remove_AT_byte_size if removing DW_AT_string_length.\n+\t(variable_value_hasher::hash, variable_value_hasher::equal): New\n+\tmethods.\n+\t(resolve_variable_value_in_expr, resolve_variable_value,\n+\tresolve_variable_values, note_variable_value_in_expr,\n+\tnote_variable_value): New functions.\n+\t(dwarf2out_early_finish): Call note_variable_value on all toplevel\n+\tDIEs.\n+\n 2017-02-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/79677"}, {"sha": "87060a33804e88093941eac501e1da5c0fa7d1b9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 495, "deletions": 142, "changes": 637, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e", "patch": "@@ -1293,6 +1293,8 @@ typedef struct GTY(()) dw_loc_list_struct {\n   unsigned char num_assigned : 1;\n   /* True if .debug_loclists.dwo offset has been emitted for it already.  */\n   unsigned char offset_emitted : 1;\n+  /* True if note_variable_value_in_expr has been called on it.  */\n+  unsigned char noted_variable_value : 1;\n   /* True if the range should be emitted even if begin and end\n      are the same.  */\n   bool force;\n@@ -1791,6 +1793,7 @@ size_of_loc_descr (dw_loc_descr_ref loc)\n       size += 4;\n       break;\n     case DW_OP_call_ref:\n+    case DW_OP_GNU_variable_value:\n       size += DWARF_REF_SIZE;\n       break;\n     case DW_OP_implicit_value:\n@@ -2214,6 +2217,17 @@ output_loc_operands (dw_loc_descr_ref loc, int for_eh_or_skip)\n       }\n       break;\n \n+    case DW_OP_call_ref:\n+    case DW_OP_GNU_variable_value:\n+      {\n+\tchar label[MAX_ARTIFICIAL_LABEL_BYTES\n+\t\t   + HOST_BITS_PER_WIDE_INT / 2 + 2];\n+\tgcc_assert (val1->val_class == dw_val_class_die_ref);\n+\tget_ref_die_offset_label (label, val1->v.val_die_ref.die);\n+\tdw2_asm_output_offset (DWARF_REF_SIZE, label, debug_info_section, NULL);\n+      }\n+      break;\n+\n     case DW_OP_implicit_pointer:\n     case DW_OP_GNU_implicit_pointer:\n       {\n@@ -3097,6 +3111,23 @@ struct decl_die_hasher : ggc_ptr_hash<die_node>\n    The key is a DECL_UID() which is a unique number identifying each decl.  */\n static GTY (()) hash_table<decl_die_hasher> *decl_die_table;\n \n+struct GTY ((for_user)) variable_value_struct {\n+  unsigned int decl_id;\n+  vec<dw_die_ref, va_gc> *dies;\n+};\n+\n+struct variable_value_hasher : ggc_ptr_hash<variable_value_struct>\n+{\n+  typedef tree compare_type;\n+\n+  static hashval_t hash (variable_value_struct *);\n+  static bool equal (variable_value_struct *, tree);\n+};\n+/* A hash table of DIEs that contain DW_OP_GNU_variable_value with\n+   dw_val_class_decl_ref class, indexed by FUNCTION_DECLs which is\n+   DECL_CONTEXT of the referenced VAR_DECLs.  */\n+static GTY (()) hash_table<variable_value_hasher> *variable_value_hash;\n+\n struct block_die_hasher : ggc_ptr_hash<die_struct>\n {\n   static hashval_t hash (die_struct *);\n@@ -3287,10 +3318,6 @@ static bool frame_pointer_fb_offset_valid;\n \n static vec<dw_die_ref> base_types;\n \n-/* Pointer to vector of DW_TAG_string_type DIEs that need finalization\n-   once all arguments are parsed.  */\n-static vec<dw_die_ref> *string_types;\n-\n /* Flags to represent a set of attribute classes for attributes that represent\n    a scalar value (bounds, pointers, ...).  */\n enum dw_scalar_form\n@@ -3605,6 +3632,7 @@ static void gen_remaining_tmpl_value_param_die_attribute (void);\n static bool generic_type_p (tree);\n static void schedule_generic_params_dies_gen (tree t);\n static void gen_scheduled_generic_parms_dies (void);\n+static void resolve_variable_values (void);\n \n static const char *comp_dir_string (void);\n \n@@ -16292,7 +16320,17 @@ single_element_loc_list_p (dw_loc_list_ref list)\n   return !list->ll_symbol;\n }\n \n-/* To each location in list LIST add loc descr REF.  */\n+/* Duplicate a single element of location list.  */\n+\n+static inline dw_loc_descr_ref\n+copy_loc_descr (dw_loc_descr_ref ref)\n+{\n+  dw_loc_descr_ref copy = ggc_alloc<dw_loc_descr_node> ();\n+  memcpy (copy, ref, sizeof (dw_loc_descr_node));\n+  return copy;\n+}\n+\n+/* To each location in list LIST append loc descr REF.  */\n \n static void\n add_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref)\n@@ -16302,16 +16340,31 @@ add_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref)\n   list = list->dw_loc_next;\n   while (list)\n     {\n-      copy = ggc_alloc<dw_loc_descr_node> ();\n-      memcpy (copy, ref, sizeof (dw_loc_descr_node));\n+      copy = copy_loc_descr (ref);\n       add_loc_descr (&list->expr, copy);\n       while (copy->dw_loc_next)\n-\t{\n-\t  dw_loc_descr_ref new_copy = ggc_alloc<dw_loc_descr_node> ();\n-\t  memcpy (new_copy, copy->dw_loc_next, sizeof (dw_loc_descr_node));\n-\t  copy->dw_loc_next = new_copy;\n-\t  copy = new_copy;\n-\t}\n+\tcopy = copy->dw_loc_next = copy_loc_descr (copy->dw_loc_next);\n+      list = list->dw_loc_next;\n+    }\n+}\n+\n+/* To each location in list LIST prepend loc descr REF.  */\n+\n+static void\n+prepend_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref)\n+{\n+  dw_loc_descr_ref copy;\n+  dw_loc_descr_ref ref_end = list->expr;\n+  add_loc_descr (&ref, list->expr);\n+  list->expr = ref;\n+  list = list->dw_loc_next;\n+  while (list)\n+    {\n+      dw_loc_descr_ref end = list->expr;\n+      list->expr = copy = copy_loc_descr (ref);\n+      while (copy->dw_loc_next != ref_end)\n+\tcopy = copy->dw_loc_next = copy_loc_descr (copy->dw_loc_next);\n+      copy->dw_loc_next = end;\n       list = list->dw_loc_next;\n     }\n }\n@@ -16322,7 +16375,7 @@ add_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref)\n    Might be destructive on both RET and LIST.\n \n    TODO: We handle only simple cases of RET or LIST having at most one\n-   element. General case would inolve sorting the lists in program order\n+   element.  General case would involve sorting the lists in program order\n    and merging them that will need some additional work.\n    Adding that will improve quality of debug info especially for SRA-ed\n    structures.  */\n@@ -16344,7 +16397,7 @@ add_loc_list (dw_loc_list_ref *ret, dw_loc_list_ref list)\n     }\n   if (!(*ret)->dw_loc_next)\n     {\n-      add_loc_descr_to_each (list, (*ret)->expr);\n+      prepend_loc_descr_to_each (list, (*ret)->expr);\n       *ret = list;\n       return;\n     }\n@@ -16824,6 +16877,7 @@ resolve_args_picking_1 (dw_loc_descr_ref loc, unsigned initial_frame_offset,\n \tcase DW_OP_fbreg:\n \tcase DW_OP_push_object_address:\n \tcase DW_OP_call_frame_cfa:\n+\tcase DW_OP_GNU_variable_value:\n \t  ++frame_offset_;\n \t  break;\n \n@@ -17299,6 +17353,31 @@ loc_list_from_tree_1 (tree loc, int want_address,\n \trtl = rtl_for_decl_location (loc);\n \tif (rtl == NULL_RTX)\n \t  {\n+\t    if (TREE_CODE (loc) != FUNCTION_DECL\n+\t\t&& early_dwarf\n+\t\t&& current_function_decl\n+\t\t&& want_address != 1\n+\t\t&& (INTEGRAL_TYPE_P (TREE_TYPE (loc))\n+\t\t    || POINTER_TYPE_P (TREE_TYPE (loc)))\n+\t\t&& DECL_CONTEXT (loc) == current_function_decl\n+\t\t&& (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (loc)))\n+\t\t    <= DWARF2_ADDR_SIZE))\n+\t      {\n+\t\tdw_die_ref ref = lookup_decl_die (loc);\n+\t\tret = new_loc_descr (DW_OP_GNU_variable_value, 0, 0);\n+\t\tif (ref)\n+\t\t  {\n+\t\t    ret->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t\t    ret->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+\t\t    ret->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    ret->dw_loc_oprnd1.val_class = dw_val_class_decl_ref;\n+\t\t    ret->dw_loc_oprnd1.v.val_decl_ref = loc;\n+\t\t  }\n+\t\tbreak;\n+\t      }\n \t    expansion_failed (loc, NULL_RTX, \"DECL has no RTL\");\n \t    return 0;\n \t  }\n@@ -17873,8 +17952,7 @@ loc_list_from_tree (tree loc, int want_address,\n   dw_loc_list_ref result = loc_list_from_tree_1 (loc, want_address, context);\n \n   for (dw_loc_list_ref loc_cur = result;\n-       loc_cur != NULL; loc_cur =\n-       loc_cur->dw_loc_next)\n+       loc_cur != NULL; loc_cur = loc_cur->dw_loc_next)\n     loc_descr_without_nops (loc_cur->expr);\n   return result;\n }\n@@ -20685,7 +20763,6 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n \t{\n \t  tree szdecl = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n \t  tree rszdecl = szdecl;\n-\t  HOST_WIDE_INT rsize = 0;\n \n \t  size = int_size_in_bytes (TREE_TYPE (szdecl));\n \t  if (!DECL_P (szdecl))\n@@ -20694,50 +20771,18 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n \t\t  && DECL_P (TREE_OPERAND (szdecl, 0)))\n \t\t{\n \t\t  rszdecl = TREE_OPERAND (szdecl, 0);\n-\t\t  rsize = int_size_in_bytes (TREE_TYPE (rszdecl));\n-\t\t  if (rsize <= 0)\n+\t\t  if (int_size_in_bytes (TREE_TYPE (rszdecl))\n+\t\t      != DWARF2_ADDR_SIZE)\n \t\t    size = 0;\n \t\t}\n \t      else\n \t\tsize = 0;\n \t    }\n \t  if (size > 0)\n \t    {\n-\t      dw_loc_list_ref loc = loc_list_from_tree (szdecl, 2, NULL);\n-\t      if (loc == NULL\n-\t\t  && early_dwarf\n-\t\t  && current_function_decl\n-\t\t  && DECL_CONTEXT (rszdecl) == current_function_decl)\n-\t\t{\n-\t\t  dw_die_ref ref = lookup_decl_die (rszdecl);\n-\t\t  dw_loc_descr_ref l = NULL;\n-\t\t  if (ref)\n-\t\t    {\n-\t\t      l = new_loc_descr (DW_OP_call4, 0, 0);\n-\t\t      l->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t\t      l->dw_loc_oprnd1.v.val_die_ref.die = ref;\n-\t\t      l->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t\t    }\n-\t\t  else if (TREE_CODE (rszdecl) == PARM_DECL\n-\t\t\t   && string_types)\n-\t\t    {\n-\t\t      l = new_loc_descr (DW_OP_call4, 0, 0);\n-\t\t      l->dw_loc_oprnd1.val_class = dw_val_class_decl_ref;\n-\t\t      l->dw_loc_oprnd1.v.val_decl_ref = rszdecl;\n-\t\t      string_types->safe_push (array_die);\n-\t\t    }\n-\t\t  if (l && rszdecl != szdecl)\n-\t\t    {\n-\t\t      if (rsize == DWARF2_ADDR_SIZE)\n-\t\t\tadd_loc_descr (&l, new_loc_descr (DW_OP_deref,\n-\t\t\t\t\t\t\t  0, 0));\n-\t\t      else\n-\t\t\tadd_loc_descr (&l, new_loc_descr (DW_OP_deref_size,\n-\t\t\t\t\t\t\t  rsize, 0));\n-\t\t    }\n-\t\t  if (l)\n-\t\t    loc = new_loc_list (l, NULL, NULL, NULL);\n-\t\t}\n+\t      dw_loc_list_ref loc\n+\t\t= loc_list_from_tree (rszdecl, szdecl == rszdecl ? 2 : 0,\n+\t\t\t\t      NULL);\n \t      if (loc)\n \t\t{\n \t\t  add_AT_location_description (array_die, DW_AT_string_length,\n@@ -20814,39 +20859,6 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n   add_alignment_attribute (array_die, type);\n }\n \n-/* After all arguments are created, adjust any DW_TAG_string_type\n-   DIEs DW_AT_string_length attributes.  */\n-\n-static void\n-adjust_string_types (void)\n-{\n-  dw_die_ref array_die;\n-  unsigned int i;\n-  FOR_EACH_VEC_ELT (*string_types, i, array_die)\n-    {\n-      dw_attr_node *a = get_AT (array_die, DW_AT_string_length);\n-      if (a == NULL)\n-\tcontinue;\n-      dw_loc_descr_ref loc = AT_loc (a);\n-      gcc_assert (loc->dw_loc_opc == DW_OP_call4\n-\t\t  && loc->dw_loc_oprnd1.val_class == dw_val_class_decl_ref);\n-      dw_die_ref ref = lookup_decl_die (loc->dw_loc_oprnd1.v.val_decl_ref);\n-      if (ref)\n-\t{\n-\t  loc->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t  loc->dw_loc_oprnd1.v.val_die_ref.die = ref;\n-\t  loc->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t}\n-      else\n-\t{\n-\t  remove_AT (array_die, DW_AT_string_length);\n-\t  remove_AT (array_die, dwarf_version >= 5\n-\t\t\t\t? DW_AT_string_length_byte_size\n-\t\t\t\t: DW_AT_byte_size);\n-\t}\n-    }\n-}\n-\n /* This routine generates DIE for array with hidden descriptor, details\n    are filled into *info by a langhook.  */\n \n@@ -22289,6 +22301,8 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  add_AT_location_description (subr_die, DW_AT_static_link,\n \t\t\t\t       loc_list_from_tree (fb_expr, 0, NULL));\n \t}\n+\n+      resolve_variable_values ();\n     }\n \n   /* Generate child dies for template paramaters.  */\n@@ -22321,9 +22335,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       tree generic_decl_parm = generic_decl\n \t\t\t\t? DECL_ARGUMENTS (generic_decl)\n \t\t\t\t: NULL;\n-      auto_vec<dw_die_ref> string_types_vec;\n-      if (string_types == NULL)\n-\tstring_types = &string_types_vec;\n \n       /* Now we want to walk the list of parameters of the function and\n \t emit their relevant DIEs.\n@@ -22386,14 +22397,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  else if (DECL_INITIAL (decl) == NULL_TREE)\n \t    gen_unspecified_parameters_die (decl, subr_die);\n \t}\n-\n-      /* Adjust DW_TAG_string_type DIEs if needed, now that all arguments\n-\t have DIEs.  */\n-      if (string_types == &string_types_vec)\n-\t{\n-\t  adjust_string_types ();\n-\t  string_types = NULL;\n-\t}\n     }\n \n   if (subr_die != old_die)\n@@ -27532,6 +27535,18 @@ prune_unused_types_walk_loc_descr (dw_loc_descr_ref loc)\n \tif (loc->dw_loc_oprnd1.val_class == dw_val_class_die_ref)\n \t  prune_unused_types_mark (loc->dw_loc_oprnd1.v.val_die_ref.die, 1);\n \tbreak;\n+      case DW_OP_GNU_variable_value:\n+\tif (loc->dw_loc_oprnd1.val_class == dw_val_class_decl_ref)\n+\t  {\n+\t    dw_die_ref ref\n+\t      = lookup_decl_die (loc->dw_loc_oprnd1.v.val_decl_ref);\n+\t    if (ref == NULL)\n+\t      break;\n+\t    loc->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t    loc->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+\t    loc->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  }\n+\t/* FALLTHRU */\n       case DW_OP_call2:\n       case DW_OP_call4:\n       case DW_OP_call_ref:\n@@ -28300,7 +28315,7 @@ optimize_one_addr_into_implicit_ptr (dw_loc_descr_ref loc)\n    the location list couldn't be resolved.  */\n \n static bool\n-resolve_addr_in_expr (dw_loc_descr_ref loc)\n+resolve_addr_in_expr (dw_attr_node *a, dw_loc_descr_ref loc)\n {\n   dw_loc_descr_ref keep = NULL;\n   for (dw_loc_descr_ref prev = NULL; loc; prev = loc, loc = loc->dw_loc_next)\n@@ -28360,6 +28375,7 @@ resolve_addr_in_expr (dw_loc_descr_ref loc)\n       case DW_OP_implicit_pointer:\n       case DW_OP_GNU_implicit_pointer:\n       case DW_OP_GNU_parameter_ref:\n+      case DW_OP_GNU_variable_value:\n \tif (loc->dw_loc_oprnd1.val_class == dw_val_class_decl_ref)\n \t  {\n \t    dw_die_ref ref\n@@ -28370,6 +28386,37 @@ resolve_addr_in_expr (dw_loc_descr_ref loc)\n \t    loc->dw_loc_oprnd1.v.val_die_ref.die = ref;\n \t    loc->dw_loc_oprnd1.v.val_die_ref.external = 0;\n \t  }\n+\tif (loc->dw_loc_opc == DW_OP_GNU_variable_value)\n+\t  {\n+\t    if (prev == NULL\n+\t\t&& loc->dw_loc_next == NULL\n+\t\t&& AT_class (a) == dw_val_class_loc)\n+\t      switch (a->dw_attr)\n+\t\t{\n+\t\t  /* Following attributes allow both exprloc and reference,\n+\t\t     so if the whole expression is DW_OP_GNU_variable_value\n+\t\t     alone we could transform it into reference.  */\n+\t\tcase DW_AT_byte_size:\n+\t\tcase DW_AT_bit_size:\n+\t\tcase DW_AT_lower_bound:\n+\t\tcase DW_AT_upper_bound:\n+\t\tcase DW_AT_bit_stride:\n+\t\tcase DW_AT_count:\n+\t\tcase DW_AT_allocated:\n+\t\tcase DW_AT_associated:\n+\t\tcase DW_AT_byte_stride:\n+\t\t  a->dw_attr_val.val_class = dw_val_class_die_ref;\n+\t\t  a->dw_attr_val.val_entry = NULL;\n+\t\t  a->dw_attr_val.v.val_die_ref.die\n+\t\t    = loc->dw_loc_oprnd1.v.val_die_ref.die;\n+\t\t  a->dw_attr_val.v.val_die_ref.external = 0;\n+\t\t  return true;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    if (dwarf_strict)\n+\t      return false;\n+\t  }\n \tbreak;\n       case DW_OP_const_type:\n       case DW_OP_regval_type:\n@@ -28544,18 +28591,18 @@ non_dwarf_expression (dw_loc_descr_ref l)\n /* Return adjusted copy of EXPR:\n    If it is empty DWARF expression, return it.\n    If it is valid non-empty DWARF expression,\n-   return copy of EXPR with copy of DEREF appended to it.\n+   return copy of EXPR with DW_OP_deref appended to it.\n    If it is DWARF expression followed by DW_OP_reg{N,x}, return\n-   copy of the DWARF expression with DW_OP_breg{N,x} <0> appended\n-   and no DEREF.\n+   copy of the DWARF expression with DW_OP_breg{N,x} <0> appended.\n    If it is DWARF expression followed by DW_OP_stack_value, return\n    copy of the DWARF expression without anything appended.\n    Otherwise, return NULL.  */\n \n static dw_loc_descr_ref\n-copy_deref_exprloc (dw_loc_descr_ref expr, dw_loc_descr_ref deref)\n+copy_deref_exprloc (dw_loc_descr_ref expr)\n {\n-  \n+  dw_loc_descr_ref tail = NULL;\n+\n   if (expr == NULL)\n     return NULL;\n \n@@ -28566,26 +28613,24 @@ copy_deref_exprloc (dw_loc_descr_ref expr, dw_loc_descr_ref deref)\n   if (l)\n     {\n       if (l->dw_loc_opc >= DW_OP_reg0 && l->dw_loc_opc <= DW_OP_reg31)\n-\tderef = new_loc_descr ((enum dwarf_location_atom)\n-\t\t\t       (DW_OP_breg0 + (l->dw_loc_opc - DW_OP_reg0)),\n-\t\t\t       0, 0);\n+\ttail = new_loc_descr ((enum dwarf_location_atom)\n+\t\t\t      (DW_OP_breg0 + (l->dw_loc_opc - DW_OP_reg0)),\n+\t\t\t      0, 0);\n       else\n \tswitch (l->dw_loc_opc)\n \t  {\n \t  case DW_OP_regx:\n-\t    deref = new_loc_descr (DW_OP_bregx,\n-\t\t\t\t   l->dw_loc_oprnd1.v.val_unsigned, 0);\n+\t    tail = new_loc_descr (DW_OP_bregx,\n+\t\t\t\t  l->dw_loc_oprnd1.v.val_unsigned, 0);\n \t    break;\n \t  case DW_OP_stack_value:\n-\t    deref = NULL;\n \t    break;\n \t  default:\n \t    return NULL;\n \t  }\n     }\n   else\n-    deref = new_loc_descr (deref->dw_loc_opc,\n-\t\t\t   deref->dw_loc_oprnd1.v.val_int, 0);\n+    tail = new_loc_descr (DW_OP_deref, 0, 0);\n \n   dw_loc_descr_ref ret = NULL, *p = &ret;\n   while (expr != l)\n@@ -28596,29 +28641,55 @@ copy_deref_exprloc (dw_loc_descr_ref expr, dw_loc_descr_ref deref)\n       p = &(*p)->dw_loc_next;\n       expr = expr->dw_loc_next;\n     }\n-  *p = deref;\n+  *p = tail;\n   return ret;\n }\n \n-/* For DW_AT_string_length attribute with DW_OP_call4 reference to a variable\n-   or argument, adjust it if needed and return:\n+/* For DW_AT_string_length attribute with DW_OP_GNU_variable_value\n+   reference to a variable or argument, adjust it if needed and return:\n    -1 if the DW_AT_string_length attribute and DW_AT_{string_length_,}byte_size\n       attribute if present should be removed\n-   0 keep the attribute as is if the referenced var or argument has\n-     only DWARF expression that covers all ranges\n+   0 keep the attribute perhaps with minor modifications, no need to rescan\n    1 if the attribute has been successfully adjusted.  */\n \n static int\n optimize_string_length (dw_attr_node *a)\n {\n   dw_loc_descr_ref l = AT_loc (a), lv;\n-  dw_die_ref die = l->dw_loc_oprnd1.v.val_die_ref.die;\n+  dw_die_ref die;\n+  if (l->dw_loc_oprnd1.val_class == dw_val_class_decl_ref)\n+    {\n+      tree decl = l->dw_loc_oprnd1.v.val_decl_ref;\n+      die = lookup_decl_die (decl);\n+      if (die)\n+\t{\n+\t  l->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  l->dw_loc_oprnd1.v.val_die_ref.die = die;\n+\t  l->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t}\n+      else\n+\treturn -1;\n+    }\n+  else\n+    die = l->dw_loc_oprnd1.v.val_die_ref.die;\n+\n+  /* DWARF5 allows reference class, so we can then reference the DIE.\n+     Only do this for DW_OP_GNU_variable_value DW_OP_stack_value.  */\n+  if (l->dw_loc_next != NULL && dwarf_version >= 5)\n+    {\n+      a->dw_attr_val.val_class = dw_val_class_die_ref;\n+      a->dw_attr_val.val_entry = NULL;\n+      a->dw_attr_val.v.val_die_ref.die = die;\n+      a->dw_attr_val.v.val_die_ref.external = 0;\n+      return 0;\n+    }\n+\n   dw_attr_node *av = get_AT (die, DW_AT_location);\n   dw_loc_list_ref d;\n   bool non_dwarf_expr = false;\n \n   if (av == NULL)\n-    return -1;\n+    return dwarf_strict ? -1 : 0;\n   switch (AT_class (av))\n     {\n     case dw_val_class_loc_list:\n@@ -28629,22 +28700,31 @@ optimize_string_length (dw_attr_node *a)\n     case dw_val_class_loc:\n       lv = AT_loc (av);\n       if (lv == NULL)\n-\treturn -1;\n+\treturn dwarf_strict ? -1 : 0;\n       if (non_dwarf_expression (lv))\n \tnon_dwarf_expr = true;\n       break;\n     default:\n-      return -1;\n+      return dwarf_strict ? -1 : 0;\n     }\n \n-  /* If it is safe to keep DW_OP_call4 in, keep it.  */\n+  /* If it is safe to transform DW_OP_GNU_variable_value DW_OP_stack_value\n+     into DW_OP_call4  or DW_OP_GNU_variable_value into\n+     DW_OP_call4 DW_OP_deref, do so.  */\n   if (!non_dwarf_expr\n-      && (l->dw_loc_next == NULL || AT_class (av) == dw_val_class_loc))\n-    return 0;\n+      && (l->dw_loc_next != NULL || AT_class (av) == dw_val_class_loc))\n+    {\n+      l->dw_loc_opc = DW_OP_call4;\n+      if (l->dw_loc_next)\n+\tl->dw_loc_next = NULL;\n+      else\n+\tl->dw_loc_next = new_loc_descr (DW_OP_deref, 0, 0);\n+      return 0;\n+    }\n \n-  /* If not dereferencing the DW_OP_call4 afterwards, we can just\n+  /* For DW_OP_GNU_variable_value DW_OP_stack_value, we can just\n      copy over the DW_AT_location attribute from die to a.  */\n-  if (l->dw_loc_next == NULL)\n+  if (l->dw_loc_next != NULL)\n     {\n       a->dw_attr_val = av->dw_attr_val;\n       return 1;\n@@ -28658,23 +28738,25 @@ optimize_string_length (dw_attr_node *a)\n       list = NULL;\n       for (d = AT_loc_list (av); d != NULL; d = d->dw_loc_next)\n \t{\n-\t  lv = copy_deref_exprloc (d->expr, l->dw_loc_next);\n+\t  lv = copy_deref_exprloc (d->expr);\n \t  if (lv)\n \t    {\n \t      *p = new_loc_list (lv, d->begin, d->end, d->section);\n \t      p = &(*p)->dw_loc_next;\n \t    }\n+\t  else if (!dwarf_strict && d->expr)\n+\t    return 0;\n \t}\n       if (list == NULL)\n-\treturn -1;\n+\treturn dwarf_strict ? -1 : 0;\n       a->dw_attr_val.val_class = dw_val_class_loc_list;\n       gen_llsym (list);\n       *AT_loc_list_ptr (a) = list;\n       return 1;\n     case dw_val_class_loc:\n-      lv = copy_deref_exprloc (AT_loc (av), l->dw_loc_next);\n+      lv = copy_deref_exprloc (AT_loc (av));\n       if (lv == NULL)\n-\treturn -1;\n+\treturn dwarf_strict ? -1 : 0;\n       a->dw_attr_val.v.val_loc = lv;\n       return 1;\n     default:\n@@ -28720,7 +28802,7 @@ resolve_addr (dw_die_ref die)\n \t    while (*curr)\n \t      {\n \t\tgcc_assert (!(*curr)->replaced && !(*curr)->resolved_addr);\n-\t\tif (!resolve_addr_in_expr ((*curr)->expr))\n+\t\tif (!resolve_addr_in_expr (a, (*curr)->expr))\n \t\t  {\n \t\t    dw_loc_list_ref next = (*curr)->dw_loc_next;\n                     dw_loc_descr_ref l = (*curr)->expr;\n@@ -28757,19 +28839,19 @@ resolve_addr (dw_die_ref die)\n       case dw_val_class_loc:\n \t{\n \t  dw_loc_descr_ref l = AT_loc (a);\n-\t  /* Using DW_OP_call4 or DW_OP_call4 DW_OP_deref in\n-\t     DW_AT_string_length is only a rough approximation; unfortunately\n-\t     DW_AT_string_length can't be a reference to a DIE.  DW_OP_call4\n-\t     needs a DWARF expression, while DW_AT_location of the referenced\n-\t     variable or argument might be any location description.  */\n+\t  /* DW_OP_GNU_variable_value DW_OP_stack_value or\n+\t     DW_OP_GNU_variable_value in DW_AT_string_length can be converted\n+\t     into DW_OP_call4 or DW_OP_call4 DW_OP_deref, which is standard\n+\t     DWARF4 unlike DW_OP_GNU_variable_value.  Or for DWARF5\n+\t     DW_OP_GNU_variable_value DW_OP_stack_value can be replaced\n+\t     with DW_FORM_ref referencing the same DIE as\n+\t     DW_OP_GNU_variable_value used to reference.  */\n \t  if (a->dw_attr == DW_AT_string_length\n \t      && l\n-\t      && l->dw_loc_opc == DW_OP_call4\n-\t      && l->dw_loc_oprnd1.val_class == dw_val_class_die_ref\n+\t      && l->dw_loc_opc == DW_OP_GNU_variable_value\n \t      && (l->dw_loc_next == NULL\n \t\t  || (l->dw_loc_next->dw_loc_next == NULL\n-\t\t      && (l->dw_loc_next->dw_loc_opc == DW_OP_deref\n-\t\t\t  || l->dw_loc_next->dw_loc_opc != DW_OP_deref_size))))\n+\t\t      && l->dw_loc_next->dw_loc_opc == DW_OP_stack_value)))\n \t    {\n \t      switch (optimize_string_length (a))\n \t\t{\n@@ -28799,7 +28881,7 @@ resolve_addr (dw_die_ref die)\n \t       || l == NULL\n \t       || l->dw_loc_opc != DW_OP_plus_uconst\n \t       || l->dw_loc_next != NULL)\n-\t      && !resolve_addr_in_expr (l))\n+\t      && !resolve_addr_in_expr (a, l))\n \t    {\n \t      if (dwarf_split_debug_info)\n \t\tremove_loc_list_addr_table_entries (l);\n@@ -28816,6 +28898,10 @@ resolve_addr (dw_die_ref die)\n \t\t  optimize_location_into_implicit_ptr (die, decl);\n \t\t  break;\n \t\t}\n+\t      if (a->dw_attr == DW_AT_string_length)\n+\t\t/* If we drop DW_AT_string_length, we need to drop also\n+\t\t   DW_AT_{string_length_,}byte_size.  */\n+\t\tremove_AT_byte_size = true;\n \t      remove_AT (die, a->dw_attr);\n \t      ix--;\n \t    }\n@@ -29874,6 +29960,262 @@ dwarf2out_finish (const char *)\n     }\n }\n \n+/* Returns a hash value for X (which really is a variable_value_struct).  */\n+\n+inline hashval_t\n+variable_value_hasher::hash (variable_value_struct *x)\n+{\n+  return (hashval_t) x->decl_id;\n+}\n+\n+/* Return nonzero if decl_id of variable_value_struct X is the same as\n+   UID of decl Y.  */\n+\n+inline bool\n+variable_value_hasher::equal (variable_value_struct *x, tree y)\n+{\n+  return x->decl_id == DECL_UID (y);\n+}\n+\n+/* Helper function for resolve_variable_value, handle\n+   DW_OP_GNU_variable_value in one location expression.\n+   Return true if exprloc has been changed into loclist.  */\n+\n+static bool\n+resolve_variable_value_in_expr (dw_attr_node *a, dw_loc_descr_ref loc)\n+{\n+  dw_loc_descr_ref next;\n+  for (dw_loc_descr_ref prev = NULL; loc; prev = loc, loc = next)\n+    {\n+      next = loc->dw_loc_next;\n+      if (loc->dw_loc_opc != DW_OP_GNU_variable_value\n+\t  || loc->dw_loc_oprnd1.val_class != dw_val_class_decl_ref)\n+\tcontinue;\n+\n+      tree decl = loc->dw_loc_oprnd1.v.val_decl_ref;\n+      if (DECL_CONTEXT (decl) != current_function_decl)\n+\tcontinue;\n+\n+      dw_die_ref ref = lookup_decl_die (decl);\n+      if (ref)\n+\t{\n+\t  loc->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  loc->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+\t  loc->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  continue;\n+\t}\n+      dw_loc_list_ref l = loc_list_from_tree (decl, 0, NULL);\n+      if (l == NULL)\n+\tcontinue;\n+      if (l->dw_loc_next)\n+\t{\n+\t  if (AT_class (a) != dw_val_class_loc)\n+\t    continue;\n+\t  switch (a->dw_attr)\n+\t    {\n+\t    /* Following attributes allow both exprloc and loclist\n+\t       classes, so we can change them into a loclist.  */\n+\t    case DW_AT_location:\n+\t    case DW_AT_string_length:\n+\t    case DW_AT_return_addr:\n+\t    case DW_AT_data_member_location:\n+\t    case DW_AT_frame_base:\n+\t    case DW_AT_segment:\n+\t    case DW_AT_static_link:\n+\t    case DW_AT_use_location:\n+\t    case DW_AT_vtable_elem_location:\n+\t      if (prev)\n+\t\t{\n+\t\t  prev->dw_loc_next = NULL;\n+\t\t  prepend_loc_descr_to_each (l, AT_loc (a));\n+\t\t}\n+\t      if (next)\n+\t\tadd_loc_descr_to_each (l, next);\n+\t      a->dw_attr_val.val_class = dw_val_class_loc_list;\n+\t      a->dw_attr_val.val_entry = NULL;\n+\t      a->dw_attr_val.v.val_loc_list = l;\n+\t      have_location_lists = true;\n+\t      return true;\n+\t    /* Following attributes allow both exprloc and reference,\n+\t       so if the whole expression is DW_OP_GNU_variable_value alone\n+\t       we could transform it into reference.  */\n+\t    case DW_AT_byte_size:\n+\t    case DW_AT_bit_size:\n+\t    case DW_AT_lower_bound:\n+\t    case DW_AT_upper_bound:\n+\t    case DW_AT_bit_stride:\n+\t    case DW_AT_count:\n+\t    case DW_AT_allocated:\n+\t    case DW_AT_associated:\n+\t    case DW_AT_byte_stride:\n+\t      if (prev == NULL && next == NULL)\n+\t\tbreak;\n+\t      /* FALLTHRU */\n+\t    default:\n+\t      if (dwarf_strict)\n+\t\tcontinue;\n+\t      break;\n+\t    }\n+\t  /* Create DW_TAG_variable that we can refer to.  */\n+\t  ref = gen_decl_die (decl, NULL_TREE, NULL,\n+\t\t\t      lookup_decl_die (current_function_decl));\n+\t  if (ref)\n+\t    {\n+\t      loc->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t      loc->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+\t      loc->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t    }\n+\t  continue;\n+\t}\n+      if (prev)\n+\t{\n+\t  prev->dw_loc_next = l->expr;\n+\t  add_loc_descr (&prev->dw_loc_next, next);\n+\t  free_loc_descr (loc, NULL);\n+\t  next = prev->dw_loc_next;\n+\t}\n+      else\n+\t{\n+\t  memcpy (loc, l->expr, sizeof (dw_loc_descr_node));\n+\t  add_loc_descr (&loc, next);\n+\t  next = loc;\n+\t}\n+      loc = prev;\n+    }\n+  return false;\n+}\n+\n+/* Attempt to resolve DW_OP_GNU_variable_value using loc_list_from_tree.  */\n+\n+static void\n+resolve_variable_value (dw_die_ref die)\n+{\n+  dw_attr_node *a;\n+  dw_loc_list_ref loc;\n+  unsigned ix;\n+\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n+    switch (AT_class (a))\n+      {\n+      case dw_val_class_loc:\n+\tif (!resolve_variable_value_in_expr (a, AT_loc (a)))\n+\t  break;\n+\t/* FALLTHRU */\n+      case dw_val_class_loc_list:\n+\tloc = AT_loc_list (a);\n+\tgcc_assert (loc);\n+\tfor (; loc; loc = loc->dw_loc_next)\n+\t  resolve_variable_value_in_expr (a, loc->expr);\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+}\n+\n+/* Attempt to optimize DW_OP_GNU_variable_value refering to\n+   temporaries in the current function.  */\n+\n+static void\n+resolve_variable_values (void)\n+{\n+  if (!variable_value_hash || !current_function_decl)\n+    return;\n+\n+  struct variable_value_struct *node\n+    = variable_value_hash->find_with_hash (current_function_decl,\n+\t\t\t\t\t   DECL_UID (current_function_decl));\n+\n+  if (node == NULL)\n+    return;\n+\n+  unsigned int i;\n+  dw_die_ref die;\n+  FOR_EACH_VEC_SAFE_ELT (node->dies, i, die)\n+    resolve_variable_value (die);\n+}\n+\n+/* Helper function for note_variable_value, handle one location\n+   expression.  */\n+\n+static void\n+note_variable_value_in_expr (dw_die_ref die, dw_loc_descr_ref loc)\n+{\n+  for (; loc; loc = loc->dw_loc_next)\n+    if (loc->dw_loc_opc == DW_OP_GNU_variable_value\n+\t&& loc->dw_loc_oprnd1.val_class == dw_val_class_decl_ref)\n+      {\n+\ttree decl = loc->dw_loc_oprnd1.v.val_decl_ref;\n+\tdw_die_ref ref = lookup_decl_die (decl);\n+\tif (ref)\n+\t  {\n+\t    loc->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t    loc->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+\t    loc->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  }\n+\tif (VAR_P (decl)\n+\t    && DECL_CONTEXT (decl)\n+\t    && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL\n+\t    && lookup_decl_die (DECL_CONTEXT (decl)))\n+\t  {\n+\t    if (!variable_value_hash)\n+\t      variable_value_hash\n+\t\t= hash_table<variable_value_hasher>::create_ggc (10);\n+\n+\t    tree fndecl = DECL_CONTEXT (decl);\n+\t    struct variable_value_struct *node;\n+\t    struct variable_value_struct **slot\n+\t      = variable_value_hash->find_slot_with_hash (fndecl,\n+\t\t\t\t\t\t\t  DECL_UID (fndecl),\n+\t\t\t\t\t\t\t  INSERT);\n+\t    if (*slot == NULL)\n+\t      {\n+\t\tnode = ggc_cleared_alloc<variable_value_struct> ();\n+\t\tnode->decl_id = DECL_UID (fndecl);\n+\t\t*slot = node;\n+\t      }\n+\t    else\n+\t      node = *slot;\n+\n+\t    vec_safe_push (node->dies, die);\n+\t  }\n+      }\n+}\n+\n+/* Walk the tree DIE and note DIEs with DW_OP_GNU_variable_value still\n+   with dw_val_class_decl_ref operand.  */\n+\n+static void\n+note_variable_value (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+  dw_attr_node *a;\n+  dw_loc_list_ref loc;\n+  unsigned ix;\n+\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n+    switch (AT_class (a))\n+      {\n+      case dw_val_class_loc_list:\n+\tloc = AT_loc_list (a);\n+\tgcc_assert (loc);\n+\tif (!loc->noted_variable_value)\n+\t  {\n+\t    loc->noted_variable_value = 1;\n+\t    for (; loc; loc = loc->dw_loc_next)\n+\t      note_variable_value_in_expr (die, loc->expr);\n+\t  }\n+\tbreak;\n+      case dw_val_class_loc:\n+\tnote_variable_value_in_expr (die, AT_loc (a));\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+\n+  /* Mark children.  */\n+  FOR_EACH_CHILD (die, c, note_variable_value (c));\n+}\n+\n /* Perform any cleanups needed after the early debug generation pass\n    has run.  */\n \n@@ -30000,6 +30342,17 @@ dwarf2out_early_finish (const char *filename)\n \t}\n     }\n \n+  /* Traverse the DIE's and note DIEs with DW_OP_GNU_variable_value still\n+     with dw_val_class_decl_ref operand.  */\n+  note_variable_value (comp_unit_die ());\n+  for (limbo_die_node *node = cu_die_list; node; node = node->next)\n+    note_variable_value (node->die);\n+  for (comdat_type_node *ctnode = comdat_type_list; ctnode != NULL;\n+       ctnode = ctnode->next)\n+    note_variable_value (ctnode->root_die);\n+  for (limbo_die_node *node = limbo_die_list; node; node = node->next)\n+    note_variable_value (node->die);\n+\n   /* The early debug phase is now finished.  */\n   early_dwarf_finished = true;\n }"}, {"sha": "2e927cbd5a1a56e17fad15a0c7383d1e720c6238", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e", "patch": "@@ -1,3 +1,8 @@\n+2017-02-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/77589\n+\t* dwarf2.def (DW_OP_GNU_variable_value): New opcode.\n+\n 2017-01-30  Alexandre Oliva <aoliva@redhat.com>\n \n \tIntroduce C++ support in libcc1."}, {"sha": "ea6194ef33e5a82f5159090aeb967fc7acefb239", "filename": "include/dwarf2.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e/include%2Fdwarf2.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e/include%2Fdwarf2.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdwarf2.def?ref=680c60feb43035aa3b1ee6ac3bcc9055bf50fd5e", "patch": "@@ -675,6 +675,9 @@ DW_OP (DW_OP_GNU_parameter_ref, 0xfa)\n /* Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFission.  */\n DW_OP (DW_OP_GNU_addr_index, 0xfb)\n DW_OP (DW_OP_GNU_const_index, 0xfc)\n+/* The GNU variable value extension.\n+   See http://dwarfstd.org/ShowIssue.php?issue=161109.2 . */\n+DW_OP (DW_OP_GNU_variable_value, 0xfd)\n /* HP extensions.  */\n DW_OP_DUP (DW_OP_HP_unknown, 0xe0) /* Ouch, the same as GNU_push_tls_address.  */\n DW_OP (DW_OP_HP_is_value, 0xe1)"}]}