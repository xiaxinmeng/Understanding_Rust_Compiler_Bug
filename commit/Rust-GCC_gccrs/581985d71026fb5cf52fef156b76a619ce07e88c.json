{"sha": "581985d71026fb5cf52fef156b76a619ce07e88c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxOTg1ZDcxMDI2ZmI1Y2Y1MmZlZjE1NmI3NmE2MTljZTA3ZTg4Yw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2011-04-11T14:57:06Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2011-04-11T14:57:06Z"}, "message": "except.c (set_nothrow_function_flags): Call cgraph_get_node instead of cgraph_node.\n\n2011-04-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* except.c (set_nothrow_function_flags): Call cgraph_get_node instead\n\tof cgraph_node.\n\t* final.c (rest_of_clean_state): Likewise.\n\t* gimple-iterator.c (update_call_edge_frequencies): Likewise.\n\t* passes.c (pass_init_dump_file): Likewise.\n\t(execute_all_ipa_transforms): Likewise.\n\t(function_called_by_processed_nodes_p): Likewise.\n\t* predict.c (maybe_hot_frequency_p): Likewise.\n\t(probably_never_executed_bb_p): Likewise.\n\t(compute_function_frequency): Likewise.\n\t* tree-nested.c (check_for_nested_with_variably_modified): Likewise.\n\t(unnest_nesting_tree_1): Likewise.\n\t(lower_nested_functions): Likewise.\n\t* tree-optimize.c (execute_fixup_cfg): Likewise.\n\t(tree_rest_of_compilation): Likewise.\n\t* tree-profile.c (gimple_gen_ic_func_profiler): Likewise.\n\t* tree-sra.c (ipa_early_sra): Likewise.\n\t* tree-ssa-loop-ivopts.c (computation_cost): Likewise.\n\t* config/i386/i386.c (ix86_compute_frame_layout): Likewise.\n\t* ipa.c (record_cdtor_fn): Likewise.\n\t* ipa-inline.c (cgraph_early_inlining): Likewise.\n\t(compute_inline_parameters_for_current): Likewise.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Likewise.\n\t* ipa-pure-const.c (local_pure_const): Likewise.\n\t* ipa-split.c (split_function): Likewise.\n\t(execute_split_functions): Likewise.\n\t* cgraphbuild.c (build_cgraph_edges): Likewise.\n\t(rebuild_cgraph_edges): Likewise.\n\t(cgraph_rebuild_references): Likewise.\t\n\t(remove_cgraph_callee_edges): Likewise.\n\t* cgraphunit.c (cgraph_mark_if_needed): Likewise.\n\t(verify_cgraph_node): Likewise.\n\t(cgraph_analyze_functions): Likewise.\n\t(cgraph_preserve_function_body_p): Likewise.\n\t(save_inline_function_body): Likewise.\n\t(save_inline_function_body): Likewise.\n\t* tree-inline.c (copy_bb): Likewise.\n\t(optimize_inline_calls): Likewise.\n\nFrom-SVN: r172257", "tree": {"sha": "0c3135978b211c7b20cc361439e62ec190004c11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c3135978b211c7b20cc361439e62ec190004c11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/581985d71026fb5cf52fef156b76a619ce07e88c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581985d71026fb5cf52fef156b76a619ce07e88c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/581985d71026fb5cf52fef156b76a619ce07e88c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581985d71026fb5cf52fef156b76a619ce07e88c/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57dbdc5a66ce818e168dc5f3d364b9d9cad3826a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57dbdc5a66ce818e168dc5f3d364b9d9cad3826a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57dbdc5a66ce818e168dc5f3d364b9d9cad3826a"}], "stats": {"total": 133, "additions": 90, "deletions": 43}, "files": [{"sha": "dee374f6d6370cf66c297da49e91fc4d3b1efd36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -1,3 +1,44 @@\n+2011-04-11  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* except.c (set_nothrow_function_flags): Call cgraph_get_node instead\n+\tof cgraph_node.\n+\t* final.c (rest_of_clean_state): Likewise.\n+\t* gimple-iterator.c (update_call_edge_frequencies): Likewise.\n+\t* passes.c (pass_init_dump_file): Likewise.\n+\t(execute_all_ipa_transforms): Likewise.\n+\t(function_called_by_processed_nodes_p): Likewise.\n+\t* predict.c (maybe_hot_frequency_p): Likewise.\n+\t(probably_never_executed_bb_p): Likewise.\n+\t(compute_function_frequency): Likewise.\n+\t* tree-nested.c (check_for_nested_with_variably_modified): Likewise.\n+\t(unnest_nesting_tree_1): Likewise.\n+\t(lower_nested_functions): Likewise.\n+\t* tree-optimize.c (execute_fixup_cfg): Likewise.\n+\t(tree_rest_of_compilation): Likewise.\n+\t* tree-profile.c (gimple_gen_ic_func_profiler): Likewise.\n+\t* tree-sra.c (ipa_early_sra): Likewise.\n+\t* tree-ssa-loop-ivopts.c (computation_cost): Likewise.\n+\t* config/i386/i386.c (ix86_compute_frame_layout): Likewise.\n+\t* ipa.c (record_cdtor_fn): Likewise.\n+\t* ipa-inline.c (cgraph_early_inlining): Likewise.\n+\t(compute_inline_parameters_for_current): Likewise.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Likewise.\n+\t* ipa-pure-const.c (local_pure_const): Likewise.\n+\t* ipa-split.c (split_function): Likewise.\n+\t(execute_split_functions): Likewise.\n+\t* cgraphbuild.c (build_cgraph_edges): Likewise.\n+\t(rebuild_cgraph_edges): Likewise.\n+\t(cgraph_rebuild_references): Likewise.\n+\t(remove_cgraph_callee_edges): Likewise.\n+\t* cgraphunit.c (cgraph_mark_if_needed): Likewise.\n+\t(verify_cgraph_node): Likewise.\n+\t(cgraph_analyze_functions): Likewise.\n+\t(cgraph_preserve_function_body_p): Likewise.\n+\t(save_inline_function_body): Likewise.\n+\t(save_inline_function_body): Likewise.\n+\t* tree-inline.c (copy_bb): Likewise.\n+\t(optimize_inline_calls): Likewise.\n+\n 2011-04-11  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/48195"}, {"sha": "47199f3a783204ce0494d43b302f5aecdb6cb6e4", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -340,7 +340,7 @@ static unsigned int\n build_cgraph_edges (void)\n {\n   basic_block bb;\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   struct pointer_set_t *visited_nodes = pointer_set_create ();\n   gimple_stmt_iterator gsi;\n   tree decl;\n@@ -451,7 +451,7 @@ unsigned int\n rebuild_cgraph_edges (void)\n {\n   basic_block bb;\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   gimple_stmt_iterator gsi;\n \n   cgraph_node_remove_callees (node);\n@@ -502,7 +502,7 @@ void\n cgraph_rebuild_references (void)\n {\n   basic_block bb;\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   gimple_stmt_iterator gsi;\n \n   ipa_remove_all_references (&node->ref_list);\n@@ -549,7 +549,7 @@ struct gimple_opt_pass pass_rebuild_cgraph_edges =\n static unsigned int\n remove_cgraph_callee_edges (void)\n {\n-  cgraph_node_remove_callees (cgraph_node (current_function_decl));\n+  cgraph_node_remove_callees (cgraph_get_node (current_function_decl));\n   return 0;\n }\n "}, {"sha": "e0e51dc3d7dd2f306d8d89a229fd18bb4c783ae9", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -390,7 +390,7 @@ cgraph_finalize_function (tree decl, bool nested)\n void\n cgraph_mark_if_needed (tree decl)\n {\n-  struct cgraph_node *node = cgraph_node (decl);\n+  struct cgraph_node *node = cgraph_get_node (decl);\n   if (node->local.finalized && cgraph_decide_is_function_needed (node, decl))\n     cgraph_mark_needed_node (node);\n }\n@@ -667,7 +667,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t\t     && cgraph_get_node (decl)\n \t\t\t\t     && (e->callee->former_clone_of\n \t\t\t\t\t != cgraph_get_node (decl)->decl)\n-\t\t\t\t     && !clone_of_p (cgraph_node (decl),\n+\t\t\t\t     && !clone_of_p (cgraph_get_node (decl),\n \t\t\t\t\t\t     e->callee))\n \t\t\t      {\n \t\t\t\terror (\"edge points to wrong declaration:\");\n@@ -995,10 +995,12 @@ cgraph_analyze_functions (void)\n \n       /* If decl is a clone of an abstract function, mark that abstract\n \t function so that we don't release its body. The DECL_INITIAL() of that\n-         abstract function declaration will be later needed to output debug info.  */\n+\t abstract function declaration will be later needed to output debug\n+\t info.  */\n       if (DECL_ABSTRACT_ORIGIN (decl))\n \t{\n-\t  struct cgraph_node *origin_node = cgraph_node (DECL_ABSTRACT_ORIGIN (decl));\n+\t  struct cgraph_node *origin_node;\n+\t  origin_node = cgraph_get_node (DECL_ABSTRACT_ORIGIN (decl));\n \t  origin_node->abstract_and_needed = true;\n \t}\n \n@@ -1766,7 +1768,7 @@ cgraph_preserve_function_body_p (tree decl)\n \n   gcc_assert (cgraph_global_info_ready);\n   /* Look if there is any clone around.  */\n-  node = cgraph_node (decl);\n+  node = cgraph_get_node (decl);\n   if (node->clones)\n     return true;\n   return false;\n@@ -2106,15 +2108,15 @@ save_inline_function_body (struct cgraph_node *node)\n {\n   struct cgraph_node *first_clone, *n;\n \n-  gcc_assert (node == cgraph_node (node->decl));\n+  gcc_assert (node == cgraph_get_node (node->decl));\n \n   cgraph_lower_function (node);\n \n   first_clone = node->clones;\n \n   first_clone->decl = copy_node (node->decl);\n   cgraph_insert_node_to_hashtable (first_clone);\n-  gcc_assert (first_clone == cgraph_node (first_clone->decl));\n+  gcc_assert (first_clone == cgraph_get_node (first_clone->decl));\n   if (first_clone->next_sibling_clone)\n     {\n       for (n = first_clone->next_sibling_clone; n->next_sibling_clone; n = n->next_sibling_clone)"}, {"sha": "cd47ba75f942738fb967419aa966bf86d4a2bfd6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -9298,7 +9298,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n            && cfun->machine->use_fast_prologue_epilogue_nregs != frame->nregs)\n     {\n       int count = frame->nregs;\n-      struct cgraph_node *node = cgraph_node (current_function_decl);\n+      struct cgraph_node *node = cgraph_get_node (current_function_decl);\n \n       cfun->machine->use_fast_prologue_epilogue_nregs = count;\n "}, {"sha": "5c6359e4c85e67548525ece8fc9882a13c5b54c1", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -1879,11 +1879,11 @@ set_nothrow_function_flags (void)\n \t  }\n       }\n   if (crtl->nothrow\n-      && (cgraph_function_body_availability (cgraph_node\n+      && (cgraph_function_body_availability (cgraph_get_node\n \t\t\t\t\t     (current_function_decl))\n           >= AVAIL_AVAILABLE))\n     {\n-      struct cgraph_node *node = cgraph_node (current_function_decl);\n+      struct cgraph_node *node = cgraph_get_node (current_function_decl);\n       struct cgraph_edge *e;\n       for (e = node->callers; e; e = e->next_caller)\n         e->can_throw_external = false;"}, {"sha": "d049906cb8b3a2da3c47c9eb993c08d828d55271", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -4356,7 +4356,7 @@ rest_of_clean_state (void)\n       else\n \t{\n \t  const char *aname;\n-\t  struct cgraph_node *node = cgraph_node (current_function_decl);\n+\t  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n \n \t  aname = (IDENTIFIER_POINTER\n \t\t   (DECL_ASSEMBLER_NAME (current_function_decl)));"}, {"sha": "f5a1d26dc276964e413cc92ae3e1ca0cf6f4f643", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -84,7 +84,7 @@ update_call_edge_frequencies (gimple_seq_node first, basic_block bb)\n \t   to avoid calling them if we never see any calls.  */\n \tif (cfun_node == NULL)\n \t  {\n-\t    cfun_node = cgraph_node (current_function_decl);\n+\t    cfun_node = cgraph_get_node (current_function_decl);\n \t    bb_freq = (compute_call_stmt_bb_frequency\n \t\t       (current_function_decl, bb));\n \t  }"}, {"sha": "6f72bfad4fce67c2a81e0223b365c86b573c9fe1", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -1718,7 +1718,7 @@ static GTY ((length (\"nnodes\"))) struct cgraph_node **order;\n static unsigned int\n cgraph_early_inlining (void)\n {\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   unsigned int todo = 0;\n   int iterations = 0;\n   bool inlined = false;\n@@ -1996,7 +1996,7 @@ compute_inline_parameters (struct cgraph_node *node)\n static unsigned int\n compute_inline_parameters_for_current (void)\n {\n-  compute_inline_parameters (cgraph_node (current_function_decl));\n+  compute_inline_parameters (cgraph_get_node (current_function_decl));\n   return 0;\n }\n "}, {"sha": "cc5e8ee11c29826484729bfbbda1c745fb65fcbe", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -1648,7 +1648,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target, tree delta)\n     target = TREE_OPERAND (target, 0);\n   if (TREE_CODE (target) != FUNCTION_DECL)\n     return NULL;\n-  callee = cgraph_node (target);\n+  callee = cgraph_get_node (target);\n   if (!callee)\n     return NULL;\n   ipa_check_create_node_params ();"}, {"sha": "b7deb5776f4d6c3d09e1497b4f01d52eba66a5d2", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -1563,7 +1563,7 @@ local_pure_const (void)\n   bool skip;\n   struct cgraph_node *node;\n \n-  node = cgraph_node (current_function_decl);\n+  node = cgraph_get_node (current_function_decl);\n   skip = skip_function_for_local_pure_const (node);\n   if (!warn_suggest_attribute_const\n       && !warn_suggest_attribute_pure"}, {"sha": "60102db336d777a93f6c4d3c39b121a18721e681", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -1080,7 +1080,7 @@ split_function (struct split_point *split_point)\n \n   /* Now create the actual clone.  */\n   rebuild_cgraph_edges ();\n-  node = cgraph_function_versioning (cgraph_node (current_function_decl),\n+  node = cgraph_function_versioning (cgraph_get_node (current_function_decl),\n \t\t\t\t     NULL, NULL,\n \t\t\t\t     args_to_skip,\n \t\t\t\t     split_point->split_bbs,\n@@ -1093,7 +1093,7 @@ split_function (struct split_point *split_point)\n       DECL_BUILT_IN_CLASS (node->decl) = NOT_BUILT_IN;\n       DECL_FUNCTION_CODE (node->decl) = (enum built_in_function) 0;\n     }\n-  cgraph_node_remove_callees (cgraph_node (current_function_decl));\n+  cgraph_node_remove_callees (cgraph_get_node (current_function_decl));\n   if (!split_part_return_p)\n     TREE_THIS_VOLATILE (node->decl) = 1;\n   if (dump_file)\n@@ -1265,7 +1265,7 @@ execute_split_functions (void)\n   basic_block bb;\n   int overall_time = 0, overall_size = 0;\n   int todo = 0;\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n \n   if (flags_from_decl_or_type (current_function_decl) & ECF_NORETURN)\n     {"}, {"sha": "24f686e8207ff6b20c060a158753d9ccae49648a", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -1626,7 +1626,7 @@ record_cdtor_fn (struct cgraph_node *node)\n     VEC_safe_push (tree, heap, static_ctors, node->decl);\n   if (DECL_STATIC_DESTRUCTOR (node->decl))\n     VEC_safe_push (tree, heap, static_dtors, node->decl);\n-  node = cgraph_node (node->decl);\n+  node = cgraph_get_node (node->decl);\n   node->local.disregard_inline_limits = 1;\n }\n "}, {"sha": "62c70d2f8f297fca4d7e33082223c478a762677d", "filename": "gcc/passes.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -1343,7 +1343,7 @@ pass_init_dump_file (struct opt_pass *pass)\n       if (dump_file && current_function_decl)\n \t{\n \t  const char *dname, *aname;\n-\t  struct cgraph_node *node = cgraph_node (current_function_decl);\n+\t  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n \t  dname = lang_hooks.decl_printable_name (current_function_decl, 2);\n \t  aname = (IDENTIFIER_POINTER\n \t\t   (DECL_ASSEMBLER_NAME (current_function_decl)));\n@@ -1475,7 +1475,7 @@ execute_all_ipa_transforms (void)\n   struct cgraph_node *node;\n   if (!cfun)\n     return;\n-  node = cgraph_node (current_function_decl);\n+  node = cgraph_get_node (current_function_decl);\n \n   if (node->ipa_transforms_to_apply)\n     {\n@@ -2029,7 +2029,9 @@ bool\n function_called_by_processed_nodes_p (void)\n {\n   struct cgraph_edge *e;\n-  for (e = cgraph_node (current_function_decl)->callers; e; e = e->next_caller)\n+  for (e = cgraph_get_node (current_function_decl)->callers;\n+       e;\n+       e = e->next_caller)\n     {\n       if (e->caller->decl == current_function_decl)\n         continue;"}, {"sha": "b9a4063073b8d2ac97f05762d5335c8d994b27cf", "filename": "gcc/predict.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -113,7 +113,7 @@ static const struct predictor_info predictor_info[]= {\n static inline bool\n maybe_hot_frequency_p (int freq)\n {\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   if (!profile_info || !flag_branch_probabilities)\n     {\n       if (node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n@@ -203,7 +203,8 @@ probably_never_executed_bb_p (const_basic_block bb)\n   if (profile_info && flag_branch_probabilities)\n     return ((bb->count + profile_info->runs / 2) / profile_info->runs) == 0;\n   if ((!profile_info || !flag_branch_probabilities)\n-      && cgraph_node (current_function_decl)->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n+      && (cgraph_get_node (current_function_decl)->frequency\n+\t  == NODE_FREQUENCY_UNLIKELY_EXECUTED))\n     return true;\n   return false;\n }\n@@ -2225,7 +2226,7 @@ void\n compute_function_frequency (void)\n {\n   basic_block bb;\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   if (DECL_STATIC_CONSTRUCTOR (current_function_decl)\n       || MAIN_NAME_P (DECL_NAME (current_function_decl)))\n     node->only_called_at_startup = true;"}, {"sha": "25d3e26badf194bf09cbcf1fbedcad3588de7ddc", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -1727,7 +1727,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t       && id->transform_call_graph_edges == CB_CGE_MOVE_CLONES))\n \t\t  && (fn = gimple_call_fndecl (stmt)) != NULL)\n \t\t{\n-\t\t  struct cgraph_node *dest = cgraph_node (fn);\n+\t\t  struct cgraph_node *dest = cgraph_get_node (fn);\n \n \t\t  /* We have missing edge in the callgraph.  This can happen\n \t\t     when previous inlining turned an indirect call into a\n@@ -4158,7 +4158,7 @@ optimize_inline_calls (tree fn)\n   /* Clear out ID.  */\n   memset (&id, 0, sizeof (id));\n \n-  id.src_node = id.dst_node = cgraph_node (fn);\n+  id.src_node = id.dst_node = cgraph_get_node (fn);\n   gcc_assert (id.dst_node->analyzed);\n   id.dst_fn = fn;\n   /* Or any functions that aren't finished yet.  */"}, {"sha": "c5ca65baabb0b4839b3fbc44a03d42c570479f7c", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -693,7 +693,7 @@ walk_all_functions (walk_stmt_fn callback_stmt, walk_tree_fn callback_op,\n static bool\n check_for_nested_with_variably_modified (tree fndecl, tree orig_fndecl)\n {\n-  struct cgraph_node *cgn = cgraph_node (fndecl);\n+  struct cgraph_node *cgn = cgraph_get_node (fndecl);\n   tree arg;\n \n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n@@ -2523,13 +2523,13 @@ finalize_nesting_tree (struct nesting_info *root)\n static void\n unnest_nesting_tree_1 (struct nesting_info *root)\n {\n-  struct cgraph_node *node = cgraph_node (root->context);\n+  struct cgraph_node *node = cgraph_get_node (root->context);\n \n   /* For nested functions update the cgraph to reflect unnesting.\n      We also delay finalizing of these functions up to this point.  */\n   if (node->origin)\n     {\n-       cgraph_unnest_node (cgraph_node (root->context));\n+       cgraph_unnest_node (node);\n        cgraph_finalize_function (root->context, true);\n     }\n }\n@@ -2583,7 +2583,7 @@ lower_nested_functions (tree fndecl)\n   struct nesting_info *root;\n \n   /* If there are no nested functions, there's nothing to do.  */\n-  cgn = cgraph_node (fndecl);\n+  cgn = cgraph_get_node (fndecl);\n   if (!cgn->nested)\n     return;\n "}, {"sha": "e277277e7d5ec8e945b5bda88ffbedf7e34f3357", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -247,12 +247,13 @@ execute_fixup_cfg (void)\n   edge_iterator ei;\n \n   if (ENTRY_BLOCK_PTR->count)\n-    count_scale = (cgraph_node (current_function_decl)->count * REG_BR_PROB_BASE\n-    \t\t   + ENTRY_BLOCK_PTR->count / 2) / ENTRY_BLOCK_PTR->count;\n+    count_scale = ((cgraph_get_node (current_function_decl)->count\n+\t\t    * REG_BR_PROB_BASE + ENTRY_BLOCK_PTR->count / 2)\n+\t\t   / ENTRY_BLOCK_PTR->count);\n   else\n     count_scale = REG_BR_PROB_BASE;\n \n-  ENTRY_BLOCK_PTR->count = cgraph_node (current_function_decl)->count;\n+  ENTRY_BLOCK_PTR->count = cgraph_get_node (current_function_decl)->count;\n   EXIT_BLOCK_PTR->count = (EXIT_BLOCK_PTR->count * count_scale\n   \t\t\t   + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n \n@@ -457,7 +458,7 @@ tree_rest_of_compilation (tree fndecl)\n \n   gimple_set_body (fndecl, NULL);\n   if (DECL_STRUCT_FUNCTION (fndecl) == 0\n-      && !cgraph_node (fndecl)->origin)\n+      && !cgraph_get_node (fndecl)->origin)\n     {\n       /* Stop pointing to the local nodes about to be freed.\n \t But DECL_INITIAL must remain nonzero so we know this"}, {"sha": "9619ae8ee12dd87f5bf60c8e435e518e6f430a05", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -346,7 +346,7 @@ gimple_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)\n void\n gimple_gen_ic_func_profiler (void)\n {\n-  struct cgraph_node * c_node = cgraph_node (current_function_decl);\n+  struct cgraph_node * c_node = cgraph_get_node (current_function_decl);\n   gimple_stmt_iterator gsi;\n   gimple stmt1, stmt2;\n   tree tree_uid, cur_func, counter_ptr, ptr_var, void0;"}, {"sha": "95a9f1b1235faacd1b50a30e224532376162de8d", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -4502,7 +4502,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n static unsigned int\n ipa_early_sra (void)\n {\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   ipa_parm_adjustment_vec adjustments;\n   int ret = 0;\n "}, {"sha": "0aa21e0c9f3488e6ec2c095463d79dcb11c984dd", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581985d71026fb5cf52fef156b76a619ce07e88c/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=581985d71026fb5cf52fef156b76a619ce07e88c", "patch": "@@ -2849,7 +2849,7 @@ computation_cost (tree expr, bool speed)\n   unsigned cost;\n   /* Avoid using hard regs in ways which may be unsupported.  */\n   int regno = LAST_VIRTUAL_REGISTER + 1;\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   enum node_frequency real_frequency = node->frequency;\n \n   node->frequency = NODE_FREQUENCY_NORMAL;"}]}