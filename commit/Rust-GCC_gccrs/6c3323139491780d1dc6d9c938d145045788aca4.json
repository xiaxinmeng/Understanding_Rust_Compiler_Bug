{"sha": "6c3323139491780d1dc6d9c938d145045788aca4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMzMzIzMTM5NDkxNzgwZDFkYzZkOWM5MzhkMTQ1MDQ1Nzg4YWNhNA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2018-02-22T01:08:02Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-02-22T01:08:02Z"}, "message": "rs6000: Use brace blocks in define_insn\n\nThis patch changes the remaining cases in our machine description files\nto use brace blocks instead of double-quoted strings as the output\ncontrol string.  This increases readability by making the blocks look\nmore like normal C code, mostly because backslash quoting is no longer\nneeded.  It also removes such quoting where it was still there (usually\nharmless but always confusing). and it writes \"\\n\\t\" as \"\\;\" in one\nplace where we didn't already.\n\n\n\t* config/rs6000/altivec.md: Write output control strings as braced\n\tblocks instead of double-quoted strings.\n\t* config/rs6000/darwin.md: Ditto.\n\t* config/rs6000/rs6000.md: Ditto.\n\t* config/rs6000/vector.md: Ditto.\n\t* config/rs6000/vsx.md: Ditto.\n\nFrom-SVN: r257889", "tree": {"sha": "a47241a23319fb46789dfc881f7bf8f9611e8a8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a47241a23319fb46789dfc881f7bf8f9611e8a8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c3323139491780d1dc6d9c938d145045788aca4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3323139491780d1dc6d9c938d145045788aca4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c3323139491780d1dc6d9c938d145045788aca4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3323139491780d1dc6d9c938d145045788aca4/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "78a85122c054bae870c831079e7127eeff2eaf97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a85122c054bae870c831079e7127eeff2eaf97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78a85122c054bae870c831079e7127eeff2eaf97"}], "stats": {"total": 646, "additions": 258, "deletions": 388}, "files": [{"sha": "f0496eb6449549a2c28bb08f46b1fac30a0f6b96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c3323139491780d1dc6d9c938d145045788aca4", "patch": "@@ -1,3 +1,12 @@\n+2018-02-21  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/altivec.md: Write output control strings as braced\n+\tblocks instead of double-quoted strings.\n+\t* config/rs6000/darwin.md: Ditto.\n+\t* config/rs6000/rs6000.md: Ditto.\n+\t* config/rs6000/vector.md: Ditto.\n+\t* config/rs6000/vsx.md: Ditto.\n+\n 2018-02-21  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/84314 - ICE with templates and fastcall attribute."}, {"sha": "55a9f53b029e29ebb5cad3dc07a98080738746a1", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 64, "deletions": 95, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=6c3323139491780d1dc6d9c938d145045788aca4", "patch": "@@ -1680,13 +1680,12 @@\n                       (match_operand:V4SI 2 \"register_operand\" \"v\")]\n \t\t     UNSPEC_VPKPX))]\n   \"TARGET_ALTIVEC\"\n-  \"*\n-  {\n-    if (VECTOR_ELT_ORDER_BIG)\n-      return \\\"vpkpx %0,%1,%2\\\";\n-    else\n-      return \\\"vpkpx %0,%2,%1\\\";\n-  }\"\n+{\n+  if (VECTOR_ELT_ORDER_BIG)\n+    return \"vpkpx %0,%1,%2\";\n+  else\n+    return \"vpkpx %0,%2,%1\";\n+}\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"altivec_vpks<VI_char>ss\"\n@@ -1695,13 +1694,12 @@\n \t\t\t    (match_operand:VP 2 \"register_operand\" \"v\")]\n \t\t\t   UNSPEC_VPACK_SIGN_SIGN_SAT))]\n   \"<VI_unit>\"\n-  \"*\n-  {\n-    if (VECTOR_ELT_ORDER_BIG)\n-      return \\\"vpks<VI_char>ss %0,%1,%2\\\";\n-    else\n-      return \\\"vpks<VI_char>ss %0,%2,%1\\\";\n-  }\"\n+{\n+  if (VECTOR_ELT_ORDER_BIG)\n+    return \"vpks<VI_char>ss %0,%1,%2\";\n+  else\n+    return \"vpks<VI_char>ss %0,%2,%1\";\n+}\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"altivec_vpks<VI_char>us\"\n@@ -1710,13 +1708,12 @@\n \t\t\t    (match_operand:VP 2 \"register_operand\" \"v\")]\n \t\t\t   UNSPEC_VPACK_SIGN_UNS_SAT))]\n   \"<VI_unit>\"\n-  \"*\n-  {\n-    if (VECTOR_ELT_ORDER_BIG)\n-      return \\\"vpks<VI_char>us %0,%1,%2\\\";\n-    else\n-      return \\\"vpks<VI_char>us %0,%2,%1\\\";\n-  }\"\n+{\n+  if (VECTOR_ELT_ORDER_BIG)\n+    return \"vpks<VI_char>us %0,%1,%2\";\n+  else\n+    return \"vpks<VI_char>us %0,%2,%1\";\n+}\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"altivec_vpku<VI_char>us\"\n@@ -1725,13 +1722,12 @@\n \t\t\t    (match_operand:VP 2 \"register_operand\" \"v\")]\n \t\t\t   UNSPEC_VPACK_UNS_UNS_SAT))]\n   \"<VI_unit>\"\n-  \"*\n-  {\n-    if (VECTOR_ELT_ORDER_BIG)\n-      return \\\"vpku<VI_char>us %0,%1,%2\\\";\n-    else\n-      return \\\"vpku<VI_char>us %0,%2,%1\\\";\n-  }\"\n+{\n+  if (VECTOR_ELT_ORDER_BIG)\n+    return \"vpku<VI_char>us %0,%1,%2\";\n+  else\n+    return \"vpku<VI_char>us %0,%2,%1\";\n+}\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"altivec_vpku<VI_char>um\"\n@@ -1740,13 +1736,12 @@\n \t\t\t    (match_operand:VP 2 \"register_operand\" \"v\")]\n \t\t\t   UNSPEC_VPACK_UNS_UNS_MOD))]\n   \"<VI_unit>\"\n-  \"*\n-  {\n-    if (VECTOR_ELT_ORDER_BIG)\n-      return \\\"vpku<VI_char>um %0,%1,%2\\\";\n-    else\n-      return \\\"vpku<VI_char>um %0,%2,%1\\\";\n-  }\"\n+{\n+  if (VECTOR_ELT_ORDER_BIG)\n+    return \"vpku<VI_char>um %0,%1,%2\";\n+  else\n+    return \"vpku<VI_char>um %0,%2,%1\";\n+}\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"altivec_vpku<VI_char>um_direct\"\n@@ -1755,13 +1750,12 @@\n \t\t\t    (match_operand:VP 2 \"register_operand\" \"v\")]\n \t\t\t   UNSPEC_VPACK_UNS_UNS_MOD_DIRECT))]\n   \"<VI_unit>\"\n-  \"*\n-  {\n-    if (BYTES_BIG_ENDIAN)\n-      return \\\"vpku<VI_char>um %0,%1,%2\\\";\n-    else\n-      return \\\"vpku<VI_char>um %0,%2,%1\\\";\n-  }\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    return \"vpku<VI_char>um %0,%1,%2\";\n+  else\n+    return \"vpku<VI_char>um %0,%2,%1\";\n+}\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"*altivec_vrl<VI_char>\"\n@@ -2348,7 +2342,6 @@\n    (use (match_operand:V4SF 1 \"register_operand\" \"\"))\n    (use (match_operand:V4SF 2 \"register_operand\" \"\"))]\n   \"VECTOR_UNIT_ALTIVEC_P (V4SFmode)\"\n-  \"\n {\n   rtx mask = gen_reg_rtx (V4SImode);\n   rtvec v = rtvec_alloc (4);\n@@ -2363,7 +2356,7 @@\n   emit_insn (gen_vector_select_v4sf (operands[0], operands[1], operands[2],\n \t\t\t\t     gen_lowpart (V4SFmode, mask)));\n   DONE;\n-}\")\n+})\n \n (define_insn \"altivec_vsldoi_<mode>\"\n   [(set (match_operand:VM 0 \"register_operand\" \"=v\")\n@@ -2670,8 +2663,7 @@\n   [(set (match_operand:V16QI 0 \"register_operand\" \"\")\n \t(unspec:V16QI [(match_operand 1 \"memory_operand\" \"\")] UNSPEC_LVSR))]\n   \"TARGET_ALTIVEC\"\n-  \"\n-{ \n+{\n   rtx addr;\n   rtx temp;\n \n@@ -2683,7 +2675,7 @@\n   emit_insn (gen_altivec_lvsr (operands[0], \n \t\t\t       replace_equiv_address (operands[1], temp)));\n   DONE;\n-}\")\n+})\n \n ;; Parallel some of the LVE* and STV*'s with unspecs because some have\n ;; identical rtl but different instructions-- and gcc gets confused.\n@@ -3361,69 +3353,64 @@\n                                  (match_operand:VIshort 2 \"register_operand\" \"v\")] \n                                 UNSPEC_VMSUMU)))]\n   \"TARGET_ALTIVEC\"\n-  \"\n-{  \n+{\n   emit_insn (gen_altivec_vmsumu<VI_char>m (operands[0], operands[1], operands[2], operands[3]));\n   DONE;\n-}\")\n-   \n+})\n+\n (define_expand \"sdot_prodv8hi\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (plus:V4SI (match_operand:V4SI 3 \"register_operand\" \"v\")\n                    (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n                                  (match_operand:V8HI 2 \"register_operand\" \"v\")]\n                                 UNSPEC_VMSUMSHM)))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   emit_insn (gen_altivec_vmsumshm (operands[0], operands[1], operands[2], operands[3]));\n   DONE;\n-}\")\n+})\n \n (define_expand \"widen_usum<mode>3\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (plus:V4SI (match_operand:V4SI 2 \"register_operand\" \"v\")\n                    (unspec:V4SI [(match_operand:VIshort 1 \"register_operand\" \"v\")]\n                                 UNSPEC_VMSUMU)))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx vones = gen_reg_rtx (GET_MODE (operands[1]));\n \n   emit_insn (gen_altivec_vspltis<VI_char> (vones, const1_rtx));\n   emit_insn (gen_altivec_vmsumu<VI_char>m (operands[0], operands[1], vones, operands[2]));\n   DONE;\n-}\")\n+})\n \n (define_expand \"widen_ssumv16qi3\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (plus:V4SI (match_operand:V4SI 2 \"register_operand\" \"v\")\n                    (unspec:V4SI [(match_operand:V16QI 1 \"register_operand\" \"v\")]\n                                 UNSPEC_VMSUMM)))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx vones = gen_reg_rtx (V16QImode);\n \n   emit_insn (gen_altivec_vspltisb (vones, const1_rtx));\n   emit_insn (gen_altivec_vmsummbm (operands[0], operands[1], vones, operands[2]));\n   DONE;\n-}\")\n+})\n \n (define_expand \"widen_ssumv8hi3\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (plus:V4SI (match_operand:V4SI 2 \"register_operand\" \"v\")\n                    (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")]\n                                 UNSPEC_VMSUMSHM)))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx vones = gen_reg_rtx (V8HImode);\n \n   emit_insn (gen_altivec_vspltish (vones, const1_rtx));\n   emit_insn (gen_altivec_vmsumshm (operands[0], operands[1], vones, operands[2]));\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_unpacks_hi_<VP_small_lc>\"\n   [(set (match_operand:VP 0 \"register_operand\" \"=v\")\n@@ -3471,7 +3458,6 @@\n         (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")]\n                      UNSPEC_VUPKHUB))]\n   \"TARGET_ALTIVEC\"      \n-  \"\n {  \n   rtx vzero = gen_reg_rtx (V8HImode);\n   rtx mask = gen_reg_rtx (V16QImode);\n@@ -3500,14 +3486,13 @@\n   emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v16qiv8hi (operands[0], operands[1], vzero, mask));\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_unpacku_hi_v8hi\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")]\n                      UNSPEC_VUPKHUH))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx vzero = gen_reg_rtx (V4SImode);\n   rtx mask = gen_reg_rtx (V16QImode);\n@@ -3536,14 +3521,13 @@\n   emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v8hiv4si (operands[0], operands[1], vzero, mask));\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_unpacku_lo_v16qi\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")]\n                      UNSPEC_VUPKLUB))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx vzero = gen_reg_rtx (V8HImode);\n   rtx mask = gen_reg_rtx (V16QImode);\n@@ -3572,14 +3556,13 @@\n   emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v16qiv8hi (operands[0], operands[1], vzero, mask));\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_unpacku_lo_v8hi\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")]\n                      UNSPEC_VUPKLUH))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx vzero = gen_reg_rtx (V4SImode);\n   rtx mask = gen_reg_rtx (V16QImode);\n@@ -3608,15 +3591,14 @@\n   emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v8hiv4si (operands[0], operands[1], vzero, mask));\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_widen_umult_hi_v16qi\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n                       (match_operand:V16QI 2 \"register_operand\" \"v\")]\n                      UNSPEC_VMULWHUB))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx ve = gen_reg_rtx (V8HImode);\n   rtx vo = gen_reg_rtx (V8HImode);\n@@ -3634,15 +3616,14 @@\n       emit_insn (gen_altivec_vmrghh_direct (operands[0], vo, ve));\n     }\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_widen_umult_lo_v16qi\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n                       (match_operand:V16QI 2 \"register_operand\" \"v\")]\n                      UNSPEC_VMULWLUB))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx ve = gen_reg_rtx (V8HImode);\n   rtx vo = gen_reg_rtx (V8HImode);\n@@ -3660,15 +3641,14 @@\n       emit_insn (gen_altivec_vmrglh_direct (operands[0], vo, ve));\n     }\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_widen_smult_hi_v16qi\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n                       (match_operand:V16QI 2 \"register_operand\" \"v\")]\n                      UNSPEC_VMULWHSB))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx ve = gen_reg_rtx (V8HImode);\n   rtx vo = gen_reg_rtx (V8HImode);\n@@ -3686,15 +3666,14 @@\n       emit_insn (gen_altivec_vmrghh_direct (operands[0], vo, ve));\n     }\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_widen_smult_lo_v16qi\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n                       (match_operand:V16QI 2 \"register_operand\" \"v\")]\n                      UNSPEC_VMULWLSB))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx ve = gen_reg_rtx (V8HImode);\n   rtx vo = gen_reg_rtx (V8HImode);\n@@ -3712,15 +3691,14 @@\n       emit_insn (gen_altivec_vmrglh_direct (operands[0], vo, ve));\n     }\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_widen_umult_hi_v8hi\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n                       (match_operand:V8HI 2 \"register_operand\" \"v\")]\n                      UNSPEC_VMULWHUH))]\n   \"TARGET_ALTIVEC\"\n-  \"\n { \n   rtx ve = gen_reg_rtx (V4SImode);\n   rtx vo = gen_reg_rtx (V4SImode);\n@@ -3738,15 +3716,14 @@\n       emit_insn (gen_altivec_vmrghw_direct (operands[0], vo, ve));\n     }\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_widen_umult_lo_v8hi\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n                       (match_operand:V8HI 2 \"register_operand\" \"v\")]\n                      UNSPEC_VMULWLUH))]\n   \"TARGET_ALTIVEC\"\n-  \"\n { \n   rtx ve = gen_reg_rtx (V4SImode);\n   rtx vo = gen_reg_rtx (V4SImode);\n@@ -3764,15 +3741,14 @@\n       emit_insn (gen_altivec_vmrglw_direct (operands[0], vo, ve));\n     }\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_widen_smult_hi_v8hi\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n                       (match_operand:V8HI 2 \"register_operand\" \"v\")]\n                      UNSPEC_VMULWHSH))]\n   \"TARGET_ALTIVEC\"\n-  \"\n { \n   rtx ve = gen_reg_rtx (V4SImode);\n   rtx vo = gen_reg_rtx (V4SImode);\n@@ -3790,15 +3766,14 @@\n       emit_insn (gen_altivec_vmrghw_direct (operands[0], vo, ve));\n     }\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_widen_smult_lo_v8hi\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n                       (match_operand:V8HI 2 \"register_operand\" \"v\")]\n                      UNSPEC_VMULWLSH))]\n   \"TARGET_ALTIVEC\"\n-  \"\n { \n   rtx ve = gen_reg_rtx (V4SImode);\n   rtx vo = gen_reg_rtx (V4SImode);\n@@ -3816,7 +3791,7 @@\n       emit_insn (gen_altivec_vmrglw_direct (operands[0], vo, ve));\n     }\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_pack_trunc_<mode>\"\n   [(set (match_operand:<VP_small> 0 \"register_operand\" \"=v\")\n@@ -3831,7 +3806,6 @@\n         (mult:V16QI (match_operand:V16QI 1 \"register_operand\" \"v\")\n                     (match_operand:V16QI 2 \"register_operand\" \"v\")))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx even = gen_reg_rtx (V8HImode);\n   rtx odd = gen_reg_rtx (V8HImode);\n@@ -3851,13 +3825,12 @@\n   emit_insn (gen_altivec_vmulosb (odd, operands[1], operands[2]));\n   emit_insn (gen_altivec_vperm_v8hiv16qi (operands[0], even, odd, mask));\n   DONE;\n-}\")\n+})\n \n (define_expand \"altivec_negv4sf2\"\n   [(use (match_operand:V4SF 0 \"register_operand\" \"\"))\n    (use (match_operand:V4SF 1 \"register_operand\" \"\"))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx neg0;\n \n@@ -3871,7 +3844,7 @@\n \t\t\t   gen_lowpart (V4SFmode, neg0), operands[1])); \n     \n   DONE;\n-}\")\n+})\n \n ;; Vector reverse elements\n (define_expand \"altivec_vreve<mode>2\"\n@@ -3973,56 +3946,52 @@\n         (unspec:V4SF [(match_operand:V8HI 1 \"register_operand\" \"\")]\n                      UNSPEC_VUPKHS_V4SF))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx tmp = gen_reg_rtx (V4SImode);\n \n   emit_insn (gen_vec_unpacks_hi_v8hi (tmp, operands[1]));\n   emit_insn (gen_altivec_vcfsx (operands[0], tmp, const0_rtx));\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_unpacks_float_lo_v8hi\"\n  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n         (unspec:V4SF [(match_operand:V8HI 1 \"register_operand\" \"\")]\n                      UNSPEC_VUPKLS_V4SF))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx tmp = gen_reg_rtx (V4SImode);\n \n   emit_insn (gen_vec_unpacks_lo_v8hi (tmp, operands[1]));\n   emit_insn (gen_altivec_vcfsx (operands[0], tmp, const0_rtx));\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_unpacku_float_hi_v8hi\"\n  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n         (unspec:V4SF [(match_operand:V8HI 1 \"register_operand\" \"\")]\n                      UNSPEC_VUPKHU_V4SF))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx tmp = gen_reg_rtx (V4SImode);\n \n   emit_insn (gen_vec_unpacku_hi_v8hi (tmp, operands[1]));\n   emit_insn (gen_altivec_vcfux (operands[0], tmp, const0_rtx));\n   DONE;\n-}\")\n+})\n \n (define_expand \"vec_unpacku_float_lo_v8hi\"\n  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n         (unspec:V4SF [(match_operand:V8HI 1 \"register_operand\" \"\")]\n                      UNSPEC_VUPKLU_V4SF))]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx tmp = gen_reg_rtx (V4SImode);\n \n   emit_insn (gen_vec_unpacku_lo_v8hi (tmp, operands[1]));\n   emit_insn (gen_altivec_vcfux (operands[0], tmp, const0_rtx));\n   DONE;\n-}\")\n+})\n \n \f\n ;; Power8/power9 vector instructions encoded as Altivec instructions"}, {"sha": "780ad17154092bd69ae15fa0c98b3f2f76f37633", "filename": "gcc/config/rs6000/darwin.md", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2Fconfig%2Frs6000%2Fdarwin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2Fconfig%2Frs6000%2Fdarwin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.md?ref=6c3323139491780d1dc6d9c938d145045788aca4", "patch": "@@ -31,28 +31,27 @@ You should have received a copy of the GNU General Public License\n         (mem:DF (lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b,b\")\n                            (match_operand 2 \"\" \"\"))))]\n   \"TARGET_MACHO && TARGET_HARD_FLOAT && !TARGET_64BIT\"\n-  \"*\n {\n   switch (which_alternative)\n     {\n       case 0:\n-\treturn \\\"lfd %0,lo16(%2)(%1)\\\";\n+\treturn \"lfd %0,lo16(%2)(%1)\";\n       case 1:\n \t{\n \t  if (TARGET_POWERPC64 && TARGET_32BIT)\n \t    /* Note, old assemblers didn't support relocation here.  */\n-\t    return \\\"ld %0,lo16(%2)(%1)\\\";\n+\t    return \"ld %0,lo16(%2)(%1)\";\n \t  else\n \t    {\n-\t      output_asm_insn (\\\"la %0,lo16(%2)(%1)\\\", operands);\n-\t      output_asm_insn (\\\"lwz %L0,4(%0)\\\", operands);\n-\t      return (\\\"lwz %0,0(%0)\\\");\n+\t      output_asm_insn (\"la %0,lo16(%2)(%1)\", operands);\n+\t      output_asm_insn (\"lwz %L0,4(%0)\", operands);\n+\t      return (\"lwz %0,0(%0)\");\n \t    }\n \t}\n       default:\n \tgcc_unreachable ();\n     }\n-}\"\n+}\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4,12\")])\n \n@@ -62,18 +61,17 @@ You should have received a copy of the GNU General Public License\n         (mem:DF (lo_sum:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b,b\")\n                            (match_operand 2 \"\" \"\"))))]\n   \"TARGET_MACHO && TARGET_HARD_FLOAT && TARGET_64BIT\"\n-  \"*\n {\n   switch (which_alternative)\n     {\n       case 0:\n-\treturn \\\"lfd %0,lo16(%2)(%1)\\\";\n+\treturn \"lfd %0,lo16(%2)(%1)\";\n       case 1:\n-\treturn \\\"ld %0,lo16(%2)(%1)\\\";\n+\treturn \"ld %0,lo16(%2)(%1)\";\n       default:\n \tgcc_unreachable ();\n     }\n-}\"\n+}\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4,4\")])\n \n@@ -262,7 +260,7 @@ You should have received a copy of the GNU General Public License\n #else\n   gcc_unreachable ();\n #endif\n-  return \"bcl 20,31,%0\\\\n%0:\";\n+  return \"bcl 20,31,%0\\n%0:\";\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cannot_copy\" \"yes\")\n@@ -279,7 +277,7 @@ You should have received a copy of the GNU General Public License\n #else\n   gcc_unreachable ();\n #endif\n-  return \"bcl 20,31,%0\\\\n%0:\";\n+  return \"bcl 20,31,%0\\n%0:\";\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cannot_copy\" \"yes\")\n@@ -408,14 +406,14 @@ You should have received a copy of the GNU General Public License\n     {\n       static char tmp[64];\n       const char *cnam = machopic_get_function_picbase ();\n-      snprintf (tmp, 64, \"bcl 20,31,%s\\\\n%s:\\\\n%%0:\", cnam, cnam);\n+      snprintf (tmp, 64, \"bcl 20,31,%s\\n%s:\\n%%0:\", cnam, cnam);\n       return tmp;\n     }\n   else\n #else\n   gcc_unreachable ();\n #endif\n-    return \"bcl 20,31,%0\\\\n%0:\";\n+    return \"bcl 20,31,%0\\n%0:\";\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cannot_copy\" \"yes\")\n@@ -432,14 +430,14 @@ You should have received a copy of the GNU General Public License\n     {\n       static char tmp[64];\n       const char *cnam = machopic_get_function_picbase ();\n-      snprintf (tmp, 64, \"bcl 20,31,%s\\\\n%s:\\\\n%%0:\", cnam, cnam);\n+      snprintf (tmp, 64, \"bcl 20,31,%s\\n%s:\\n%%0:\", cnam, cnam);\n       return tmp;\n     }\n   else\n #else\n   gcc_unreachable ();\n #endif\n-    return \"bcl 20,31,%0\\\\n%0:\";\n+    return \"bcl 20,31,%0\\n%0:\";\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cannot_copy\" \"yes\")"}, {"sha": "999aa3788be8e99bdc6d74761a8d1186ef2a9b73", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 140, "deletions": 206, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=6c3323139491780d1dc6d9c938d145045788aca4", "patch": "@@ -2595,7 +2595,6 @@\n    (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"\"))]\n   \"TARGET_POWERPC64 && !TARGET_LDBRX && reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx dest   = operands[0];\n   rtx src    = operands[1];\n@@ -2650,7 +2649,7 @@\n   emit_insn (gen_ashldi3 (op3, op3, GEN_INT (32)));\n   emit_insn (gen_iordi3 (dest, dest, op3));\n   DONE;\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:DI 0 \"indexed_or_indirect_operand\" \"\")\n@@ -2659,7 +2658,6 @@\n    (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"\"))]\n   \"TARGET_POWERPC64 && !TARGET_LDBRX && reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx dest   = operands[0];\n   rtx src    = operands[1];\n@@ -2713,7 +2711,7 @@\n       emit_insn (gen_bswapsi2 (word1, op3_si));\n     }\n   DONE;\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n@@ -2722,7 +2720,6 @@\n    (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"\"))]\n   \"TARGET_POWERPC64 && !TARGET_P9_VECTOR && reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx dest    = operands[0];\n   rtx src     = operands[1];\n@@ -2740,7 +2737,7 @@\n   emit_insn (gen_ashldi3 (dest, dest, GEN_INT (32)));\n   emit_insn (gen_iordi3 (dest, dest, op3));\n   DONE;\n-}\")\n+})\n \n (define_insn \"bswapdi2_32bit\"\n   [(set (match_operand:DI 0 \"reg_or_mem_operand\" \"=r,Z,?&r\")\n@@ -2756,7 +2753,6 @@\n    (clobber (match_operand:SI 2 \"gpc_reg_operand\" \"\"))]\n   \"!TARGET_POWERPC64 && reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx dest  = operands[0];\n   rtx src   = operands[1];\n@@ -2801,15 +2797,14 @@\n      thus allowing us to omit an early clobber on the output.  */\n   emit_insn (gen_bswapsi2 (dest1, word2));\n   DONE;\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:DI 0 \"indexed_or_indirect_operand\" \"\")\n \t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n    (clobber (match_operand:SI 2 \"gpc_reg_operand\" \"\"))]\n   \"!TARGET_POWERPC64 && reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx dest = operands[0];\n   rtx src  = operands[1];\n@@ -2850,15 +2845,14 @@\n   emit_insn (gen_bswapsi2 (word2, src1));\n   emit_insn (gen_bswapsi2 (word1, src2));\n   DONE;\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n    (clobber (match_operand:SI 2 \"\" \"\"))]\n   \"!TARGET_POWERPC64 && reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx dest  = operands[0];\n   rtx src   = operands[1];\n@@ -2870,7 +2864,7 @@\n   emit_insn (gen_bswapsi2 (dest1, src2));\n   emit_insn (gen_bswapsi2 (dest2, src1));\n   DONE;\n-}\")\n+})\n \n \n (define_insn \"mul<mode>3\"\n@@ -4972,13 +4966,12 @@\n \t\t\t   (match_operand:GPR 2 \"gpc_reg_operand\" \"\")\n \t\t\t   (match_operand:GPR 3 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_ISEL\"\n-  \"\n {\n   if (rs6000_emit_cmove (operands[0], operands[1], operands[2], operands[3]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n ;; We use the BASE_REGS for the isel input operands because, if rA is\n ;; 0, the value of 0 is placed in rD upon truth.  Similarly for rB\n@@ -5053,13 +5046,12 @@\n \t\t\t    (match_operand:SFDF 2 \"gpc_reg_operand\" \"\")\n \t\t\t    (match_operand:SFDF 3 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT\"\n-  \"\n {\n   if (rs6000_emit_cmove (operands[0], operands[1], operands[2], operands[3]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_insn \"*fsel<SFDF:mode><SFDF2:mode>4\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=&<SFDF:rreg2>\")\n@@ -5193,7 +5185,6 @@\n   \"#\"\n   \"\"\n   [(pc)]\n-  \"\n {\n   rtx dest = operands[0];\n   rtx src = operands[1];\n@@ -5221,7 +5212,7 @@\n     }\n   emit_insn (gen_floatdi<mode>2 (dest, tmp));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"12\")\n    (set_attr \"type\" \"fpload\")])\n \n@@ -5235,7 +5226,6 @@\n   \"#\"\n   \"\"\n   [(pc)]\n-  \"\n {\n   operands[1] = rs6000_address_for_fpconvert (operands[1]);\n   if (GET_CODE (operands[2]) == SCRATCH)\n@@ -5246,7 +5236,7 @@\n     emit_insn (gen_lfiwax (operands[2], operands[1]));\n   emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"fpload\")])\n \n@@ -5270,7 +5260,6 @@\n   \"#\"\n   \"\"\n   [(pc)]\n-  \"\n {\n   rtx dest = operands[0];\n   rtx src = operands[1];\n@@ -5298,7 +5287,7 @@\n     }\n   emit_insn (gen_floatdi<mode>2 (dest, tmp));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"12\")\n    (set_attr \"type\" \"fpload\")])\n \n@@ -5312,7 +5301,6 @@\n   \"#\"\n   \"\"\n   [(pc)]\n-  \"\n {\n   operands[1] = rs6000_address_for_fpconvert (operands[1]);\n   if (GET_CODE (operands[2]) == SCRATCH)\n@@ -5323,7 +5311,7 @@\n     emit_insn (gen_lfiwzx (operands[2], operands[1]));\n   emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"fpload\")])\n \n@@ -5341,7 +5329,6 @@\n \t      (clobber (match_dup 5))\n \t      (clobber (match_dup 6))])]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"\n {\n   if (TARGET_LFIWAX && TARGET_FCFID)\n     {\n@@ -5365,7 +5352,7 @@\n   operands[4] = rs6000_allocate_stack_temp (DFmode, true, false);\n   operands[5] = gen_reg_rtx (DFmode);\n   operands[6] = gen_reg_rtx (SImode);\n-}\")\n+})\n \n (define_insn_and_split \"*floatsidf2_internal\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=&d\")\n@@ -5379,7 +5366,6 @@\n   \"#\"\n   \"\"\n   [(pc)]\n-  \"\n {\n   rtx lowword, highword;\n   gcc_assert (MEM_P (operands[4]));\n@@ -5395,7 +5381,7 @@\n   emit_move_insn (operands[5], operands[4]);\n   emit_insn (gen_subdf3 (operands[0], operands[5], operands[3]));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"24\")\n    (set_attr \"type\" \"fp\")])\n \n@@ -5409,7 +5395,6 @@\n    && ((TARGET_FCFIDUS && TARGET_LFIWZX)\n        || (TARGET_DOUBLE_FLOAT && TARGET_FCFID\n \t   && (TARGET_POWERPC64 || flag_unsafe_math_optimizations)))\"\n-  \"\n {\n   if (TARGET_LFIWZX && TARGET_FCFIDUS)\n     {\n@@ -5425,7 +5410,7 @@\n       emit_insn (gen_floatdisf2 (operands[0], dreg));\n       DONE;\n     }\n-}\")\n+})\n \n (define_expand \"floatunssidf2\"\n   [(parallel [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n@@ -5435,7 +5420,6 @@\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))])]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"\n {\n   if (TARGET_LFIWZX && TARGET_FCFID)\n     {\n@@ -5458,7 +5442,7 @@\n   operands[3] = force_reg (DFmode, CONST_DOUBLE_ATOF (\\\"4503599627370496\\\", DFmode));\n   operands[4] = rs6000_allocate_stack_temp (DFmode, true, false);\n   operands[5] = gen_reg_rtx (DFmode);\n-}\")\n+})\n \n (define_insn_and_split \"*floatunssidf2_internal\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=&d\")\n@@ -5472,7 +5456,6 @@\n   \"#\"\n   \"\"\n   [(pc)]\n-  \"\n {\n   rtx lowword, highword;\n   gcc_assert (MEM_P (operands[4]));\n@@ -5486,7 +5469,7 @@\n   emit_move_insn (operands[5], operands[4]);\n   emit_insn (gen_subdf3 (operands[0], operands[5], operands[3]));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"20\")\n    (set_attr \"type\" \"fp\")])\n \n@@ -5597,7 +5580,6 @@\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT && <TARGET_FLOAT>\"\n-  \"\n {\n   if (!TARGET_P8_VECTOR)\n     {\n@@ -5614,7 +5596,7 @@\n \t}\n       DONE;\n     }\n-}\")\n+})\n \n ; Like the convert to float patterns, this insn must be split before\n ; register allocation so that it can allocate the memory slot if it\n@@ -5671,7 +5653,6 @@\n   \"#\"\n   \"\"\n   [(pc)]\n-  \"\n {\n   rtx lowword;\n   gcc_assert (MEM_P (operands[3]));\n@@ -5681,7 +5662,7 @@\n   emit_move_insn (operands[3], operands[2]);\n   emit_move_insn (operands[0], lowword);\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"16\")\n    (set_attr \"type\" \"fp\")])\n \n@@ -5759,14 +5740,13 @@\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT && <TARGET_FLOAT> && TARGET_FCTIWUZ && TARGET_STFIWX\"\n-  \"\n {\n   if (!TARGET_P8_VECTOR)\n     {\n       emit_insn (gen_fixuns_trunc<mode>si2_stfiwx (operands[0], operands[1]));\n       DONE;\n     }\n-}\")\n+})\n \n (define_insn_and_split \"fixuns_trunc<mode>si2_stfiwx\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n@@ -6034,7 +6014,6 @@\n    && ((TARGET_FCFIDS && TARGET_LFIWAX)\n        || (TARGET_DOUBLE_FLOAT && TARGET_FCFID\n \t   && (TARGET_POWERPC64 || flag_unsafe_math_optimizations)))\"\n-  \"\n {\n   if (TARGET_FCFIDS && TARGET_LFIWAX)\n     {\n@@ -6057,7 +6036,7 @@\n       emit_insn (gen_floatdisf2 (operands[0], dreg));\n       DONE;\n     }\n-}\")\n+})\n \n (define_insn \"floatdidf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n@@ -6121,7 +6100,6 @@\n         (float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n    && (TARGET_FCFIDS || TARGET_POWERPC64 || flag_unsafe_math_optimizations)\"\n-  \"\n {\n   if (!TARGET_FCFIDS)\n     {\n@@ -6136,7 +6114,7 @@\n       emit_insn (gen_floatdisf2_internal1 (operands[0], val));\n       DONE;\n     }\n-}\")\n+})\n \n (define_insn \"floatdisf2_fcfids\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy\")\n@@ -6157,12 +6135,11 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(pc)]\n-  \"\n {\n   emit_move_insn (operands[2], operands[1]);\n   emit_insn (gen_floatdisf2_fcfids (operands[0], operands[2]));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"8\")])\n \n ;; This is not IEEE compliant if rounding mode is \"round to nearest\".\n@@ -6210,11 +6187,10 @@\n    (set (match_dup 0) (match_dup 1))]\n   \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n    && !TARGET_FCFIDS\"\n-  \"\n {\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (CCUNSmode);\n-}\")\n+})\n \n (define_expand \"floatunsdisf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n@@ -6242,12 +6218,11 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(pc)]\n-  \"\n {\n   emit_move_insn (operands[2], operands[1]);\n   emit_insn (gen_floatunsdisf2_fcfidus (operands[0], operands[2]));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"fpload\")])\n \f\n@@ -6670,7 +6645,6 @@\n \t(unspec:SI [(match_operand:SI 1 \"got_operand\" \"\")\n \t\t    (match_dup 2)] UNSPEC_MOVSI_GOT))]\n   \"DEFAULT_ABI == ABI_V4 && flag_pic == 1\"\n-  \"\n {\n   if (GET_CODE (operands[1]) == CONST)\n     {\n@@ -6691,7 +6665,7 @@\n     }\n \n   operands[2] = rs6000_got_register (operands[1]);\n-}\")\n+})\n \n (define_insn \"*movsi_got_internal\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n@@ -6975,13 +6949,12 @@\n    (set (match_dup 0)\n \t(ior:SI (match_dup 0)\n \t\t(match_dup 3)))]\n-  \"\n {\n   if (rs6000_emit_set_const (operands[0], operands[1]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n ;; Split loading -128..127 to use XXSPLITB and VEXTSW2D\n (define_split\n@@ -7030,7 +7003,10 @@\n   [(set (match_operand:INT 0 \"general_operand\" \"\")\n \t(match_operand:INT 1 \"any_operand\" \"\"))]\n   \"\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], <MODE>mode); DONE; }\")\n+{\n+  rs6000_emit_move (operands[0], operands[1], <MODE>mode);\n+  DONE;\n+})\n \n ;;\t\tMR          LHZ/LBZ    LXSI*ZX    STH/STB    STXSI*X    LI\n ;;\t\tXXLOR       load 0     load -1    VSPLTI*    #          MFVSRWZ\n@@ -7137,7 +7113,10 @@\n   [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:FMOVE32 1 \"any_operand\" \"\"))]\n   \"<fmove_ok>\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], <MODE>mode); DONE; }\")\n+{\n+  rs6000_emit_move (operands[0], operands[1], <MODE>mode);\n+  DONE;\n+})\n \n (define_split\n   [(set (match_operand:FMOVE32 0 \"gpc_reg_operand\" \"\")\n@@ -7148,7 +7127,6 @@\n \t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n \t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 3))]\n-  \"\n {\n   long l;\n \n@@ -7160,7 +7138,7 @@\n     operands[2] = gen_lowpart (SImode, operands[0]);\n \n   operands[3] = gen_int_mode (l, SImode);\n-}\")\n+})\n \n ;; Originally, we tried to keep movsf and movsd common, but the differences\n ;; addressing was making it rather difficult to hide with mode attributes.  In\n@@ -7334,7 +7312,10 @@\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:FMOVE64 1 \"any_operand\" \"\"))]\n   \"\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], <MODE>mode); DONE; }\")\n+{\n+  rs6000_emit_move (operands[0], operands[1], <MODE>mode);\n+  DONE;\n+})\n \n (define_split\n   [(set (match_operand:FMOVE64 0 \"gpc_reg_operand\" \"\")\n@@ -7346,7 +7327,6 @@\n \t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 1))]\n-  \"\n {\n   int endian = (WORDS_BIG_ENDIAN == 0);\n   HOST_WIDE_INT value = INTVAL (operands[1]);\n@@ -7355,7 +7335,7 @@\n   operands[3] = operand_subword (operands[0], 1 - endian, 0, <MODE>mode);\n   operands[4] = GEN_INT (value >> 32);\n   operands[1] = GEN_INT (((value & 0xffffffff) ^ 0x80000000) - 0x80000000);\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:FMOVE64 0 \"gpc_reg_operand\" \"\")\n@@ -7367,7 +7347,6 @@\n \t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n-  \"\n {\n   int endian = (WORDS_BIG_ENDIAN == 0);\n   long l[2];\n@@ -7378,7 +7357,7 @@\n   operands[3] = operand_subword (operands[0], 1 - endian, 0, <MODE>mode);\n   operands[4] = gen_int_mode (l[endian], SImode);\n   operands[5] = gen_int_mode (l[1 - endian], SImode);\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:FMOVE64 0 \"gpc_reg_operand\" \"\")\n@@ -7389,7 +7368,6 @@\n \t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n \t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 3))]\n-  \"\n {\n   int endian = (WORDS_BIG_ENDIAN == 0);\n   long l[2];\n@@ -7403,7 +7381,7 @@\n          | ((HOST_WIDE_INT)(unsigned long)l[1 - endian]));\n \n   operands[3] = gen_int_mode (val, DImode);\n-}\")\n+})\n \n ;; Don't have reload use general registers to load a constant.  It is\n ;; less efficient than loading the constant into an FP register, since\n@@ -7511,7 +7489,10 @@\n   [(set (match_operand:FMOVE128 0 \"general_operand\" \"\")\n \t(match_operand:FMOVE128 1 \"any_operand\" \"\"))]\n   \"\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], <MODE>mode); DONE; }\")\n+{\n+  rs6000_emit_move (operands[0], operands[1], <MODE>mode);\n+  DONE;\n+})\n \n ;; It's important to list Y->r and r->Y before r->r because otherwise\n ;; reload, given m->r, will try to pick r->r and reload it, which\n@@ -7897,7 +7878,6 @@\n \t(neg:FLOAT128 (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n   \"FLOAT128_IEEE_P (<MODE>mode)\n    || (FLOAT128_IBM_P (<MODE>mode) && TARGET_HARD_FLOAT)\"\n-  \"\n {\n   if (FLOAT128_IEEE_P (<MODE>mode))\n     {\n@@ -7931,19 +7911,18 @@\n \t}\n       DONE;\n     }\n-}\")\n+})\n \n (define_insn \"neg<mode>2_internal\"\n   [(set (match_operand:IBM128 0 \"gpc_reg_operand\" \"=d\")\n \t(neg:IBM128 (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")))]\n   \"TARGET_HARD_FLOAT && FLOAT128_IBM_P (TFmode)\"\n-  \"*\n {\n   if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-    return \\\"fneg %L0,%L1\\;fneg %0,%1\\\";\n+    return \"fneg %L0,%L1\\;fneg %0,%1\";\n   else\n-    return \\\"fneg %0,%1\\;fneg %L0,%L1\\\";\n-}\"\n+    return \"fneg %0,%1\\;fneg %L0,%L1\";\n+}\n   [(set_attr \"type\" \"fpsimple\")\n    (set_attr \"length\" \"8\")])\n \n@@ -7952,7 +7931,6 @@\n \t(abs:FLOAT128 (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))]\n   \"FLOAT128_IEEE_P (<MODE>mode)\n    || (FLOAT128_IBM_P (<MODE>mode) && TARGET_HARD_FLOAT)\"\n-  \"\n {\n   rtx label;\n \n@@ -7991,7 +7969,7 @@\n     FAIL;\n   emit_label (label);\n   DONE;\n-}\")\n+})\n \n (define_expand \"abs<mode>2_internal\"\n   [(set (match_operand:IBM128 0 \"gpc_reg_operand\" \"\")\n@@ -8004,15 +7982,14 @@\n \t\t\t   (pc)))\n    (set (match_dup 6) (neg:DF (match_dup 6)))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n-  \"\n {\n   const int hi_word = LONG_DOUBLE_LARGE_FIRST ? 0 : GET_MODE_SIZE (DFmode);\n   const int lo_word = LONG_DOUBLE_LARGE_FIRST ? GET_MODE_SIZE (DFmode) : 0;\n   operands[3] = gen_reg_rtx (DFmode);\n   operands[4] = gen_reg_rtx (CCFPmode);\n   operands[5] = simplify_gen_subreg (DFmode, operands[0], <MODE>mode, hi_word);\n   operands[6] = simplify_gen_subreg (DFmode, operands[0], <MODE>mode, lo_word);\n-}\")\n+})\n \n \f\n ;; Generate IEEE 128-bit -0.0 (0x80000000000000000000000000000000) in a vector\n@@ -8546,7 +8523,6 @@\n    && !direct_move_p (operands[0], operands[1])\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 1))]\n-  \"\n {\n   HOST_WIDE_INT value = INTVAL (operands[1]);\n   operands[2] = operand_subword_force (operands[0], WORDS_BIG_ENDIAN == 0,\n@@ -8555,7 +8531,7 @@\n \t\t\t\t       DImode);\n   operands[4] = GEN_INT (value >> 32);\n   operands[1] = GEN_INT (((value & 0xffffffff) ^ 0x80000000) - 0x80000000);\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:DIFD 0 \"nonimmediate_operand\" \"\")\n@@ -8659,27 +8635,25 @@\n   \"TARGET_POWERPC64 && num_insns_constant (operands[1], DImode) > 1\"\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 3)))]\n-  \"\n {\n   if (rs6000_emit_set_const (operands[0], operands[1]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:DI 0 \"int_reg_operand_not_pseudo\" \"\")\n \t(match_operand:DI 1 \"const_scalar_int_operand\" \"\"))]\n   \"TARGET_POWERPC64 && num_insns_constant (operands[1], DImode) > 1\"\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 3)))]\n-  \"\n {\n   if (rs6000_emit_set_const (operands[0], operands[1]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:DI 0 \"altivec_register_operand\" \"\")\n@@ -8764,7 +8738,6 @@\n        || (reload_completed && INT_REGNO_P (REGNO (operands[0]))))\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n-  \"\n {\n   operands[2] = operand_subword_force (operands[0], WORDS_BIG_ENDIAN == 0,\n \t\t\t\t       <MODE>mode);\n@@ -8782,7 +8755,7 @@\n     }\n   else\n     FAIL;\n-}\")\n+})\n \n (define_split\n   [(set (match_operand:TI2 0 \"nonimmediate_operand\" \"\")\n@@ -8800,7 +8773,6 @@\n \t      (use (match_operand:SI 1 \"\" \"\"))\n \t      (use (match_operand:SI 3 \"\" \"\"))])]\n   \"\"\n-  \"\n {\n   /* If value to set is not zero, use the library routine.  */\n   if (operands[2] != const0_rtx)\n@@ -8810,7 +8782,7 @@\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n ;; String compare N insn.\n ;; Argument 0 is the target (result)\n@@ -8891,13 +8863,12 @@\n \t      (use (match_operand:SI 2 \"\" \"\"))\n \t      (use (match_operand:SI 3 \"\" \"\"))])]\n   \"\"\n-  \"\n {\n   if (expand_block_move (operands))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \f\n ;; Define insns that do load or store with update.  Some of these we can\n ;; get by using pre-decrement or pre-increment, but the hardware can also\n@@ -9352,10 +9323,9 @@\n    (set (match_dup 0)\n    \t(lo_sum:TLSmode (match_dup 3)\n \t    (unspec:TLSmode [(match_dup 1) (match_dup 2)] UNSPEC_TLSGD)))]\n-  \"\n {\n   operands[3] = gen_reg_rtx (TARGET_64BIT ? DImode : SImode);\n-}\"\n+}\n   [(set (attr \"length\")\n      (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n      \t\t   (const_int 8)\n@@ -9489,10 +9459,9 @@\n    (set (match_dup 0)\n    \t(lo_sum:TLSmode (match_dup 2)\n \t    (unspec:TLSmode [(const_int 0) (match_dup 1)] UNSPEC_TLSLD)))]\n-  \"\n {\n   operands[2] = gen_reg_rtx (TARGET_64BIT ? DImode : SImode);\n-}\"\n+}\n   [(set (attr \"length\")\n      (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n      \t\t   (const_int 8)\n@@ -9587,10 +9556,9 @@\n    (set (match_dup 0)\n \t(lo_sum:TLSmode (match_dup 3)\n \t    (unspec:TLSmode [(match_dup 1) (match_dup 2)] UNSPEC_TLSGOTDTPREL)))]\n-  \"\n {\n   operands[3] = gen_reg_rtx (TARGET_64BIT ? DImode : SImode);\n-}\"\n+}\n   [(set (attr \"length\")\n      (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n      \t\t   (const_int 8)\n@@ -9657,10 +9625,9 @@\n    (set (match_dup 0)\n \t(lo_sum:TLSmode (match_dup 3)\n \t    (unspec:TLSmode [(match_dup 1) (match_dup 2)] UNSPEC_TLSGOTTPREL)))]\n-  \"\n {\n   operands[3] = gen_reg_rtx (TARGET_64BIT ? DImode : SImode);\n-}\"\n+}\n   [(set (attr \"length\")\n      (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n      \t\t   (const_int 8)\n@@ -9698,12 +9665,11 @@\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(unspec:SI [(const_int 0)] UNSPEC_TLSTLS))]\n   \"TARGET_XCOFF && HAVE_AS_TLS\"\n-  \"\n {\n   emit_insn (gen_tls_get_tpointer_internal ());\n   emit_move_insn (operands[0], gen_rtx_REG (SImode, 3));\n   DONE;\n-}\")\n+})\n \n (define_insn \"tls_get_tpointer_internal\"\n   [(set (reg:SI 3)\n@@ -9717,14 +9683,13 @@\n \t(unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"\")\n                    (match_operand:P 2 \"gpc_reg_operand\" \"\")] UNSPEC_TLSTLS))]\n   \"TARGET_XCOFF && HAVE_AS_TLS\"\n-  \"\n {\n   emit_move_insn (gen_rtx_REG (Pmode, 3), operands[1]);\n   emit_move_insn (gen_rtx_REG (Pmode, 4), operands[2]);\n   emit_insn (gen_tls_get_addr_internal<mode> ());\n   emit_move_insn (operands[0], gen_rtx_REG (Pmode, 3));\n   DONE;\n-}\")\n+})\n \n (define_insn \"tls_get_addr_internal<mode>\"\n   [(set (reg:P 3)\n@@ -9759,8 +9724,8 @@\n    (set (reg 1)\n \t(minus (reg 1) (match_dup 1)))]\n   \"\"\n-  \"\n-{ rtx chain = gen_reg_rtx (Pmode);\n+{\n+  rtx chain = gen_reg_rtx (Pmode);\n   rtx stack_bot = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n   rtx neg_op0;\n   rtx insn, par, set, mem;\n@@ -9864,7 +9829,7 @@\n \n   emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n   DONE;\n-}\")\n+})\n \n ;; These patterns say how to save and restore the stack pointer.  We need not\n ;; save the stack pointer at function level since we are careful to\n@@ -9897,7 +9862,6 @@\n    (set (match_operand 0 \"register_operand\" \"\")\n \t(match_operand 1 \"register_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   rtvec p;\n \n@@ -9909,14 +9873,13 @@\n   RTVEC_ELT (p, 0) = gen_rtx_SET (gen_frame_mem (BLKmode, operands[0]),\n \t\t\t\t  const0_rtx);\n   operands[5] = gen_rtx_PARALLEL (VOIDmode, p);\n-}\")\n+})\n \n (define_expand \"save_stack_nonlocal\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_operand 0 \"memory_operand\" \"\") (match_dup 3))\n    (set (match_dup 2) (match_operand 1 \"register_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   int units_per_word = (TARGET_32BIT) ? 4 : 8;\n \n@@ -9925,7 +9888,7 @@\n   operands[2] = adjust_address_nv (operands[0], Pmode, units_per_word);\n   operands[3] = gen_reg_rtx (Pmode);\n   operands[4] = gen_frame_mem (Pmode, operands[1]);\n-}\")\n+})\n \n (define_expand \"restore_stack_nonlocal\"\n   [(set (match_dup 2) (match_operand 1 \"memory_operand\" \"\"))\n@@ -9934,7 +9897,6 @@\n    (match_dup 6)\n    (set (match_operand 0 \"register_operand\" \"\") (match_dup 3))]\n   \"\"\n-  \"\n {\n   int units_per_word = (TARGET_32BIT) ? 4 : 8;\n   rtvec p;\n@@ -9949,7 +9911,7 @@\n   RTVEC_ELT (p, 0) = gen_rtx_SET (gen_frame_mem (BLKmode, operands[0]),\n \t\t\t\t  const0_rtx);\n   operands[6] = gen_rtx_PARALLEL (VOIDmode, p);\n-}\")\n+})\n \f\n ;; TOC register handling.\n \n@@ -9960,16 +9922,15 @@\n \t\t   (unspec:SI [(const_int 0)] UNSPEC_TOC))\n \t      (use (reg:SI 2))])]\n   \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2) && TARGET_32BIT\"\n-  \"*\n {\n   char buf[30];\n   extern int need_toc_init;\n   need_toc_init = 1;\n-  ASM_GENERATE_INTERNAL_LABEL (buf, \\\"LCTOC\\\", 1);\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 1);\n   operands[1] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n   operands[2] = gen_rtx_REG (Pmode, 2);\n-  return \\\"lwz %0,%1(%2)\\\";\n-}\"\n+  return \"lwz %0,%1(%2)\";\n+}\n   [(set_attr \"type\" \"load\")\n    (set_attr \"update\" \"no\")\n    (set_attr \"indexed\" \"no\")])\n@@ -9979,19 +9940,18 @@\n \t\t   (unspec:DI [(const_int 0)] UNSPEC_TOC))\n \t      (use (reg:DI 2))])]\n   \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2) && TARGET_64BIT\"\n-  \"*\n {\n   char buf[30];\n   extern int need_toc_init;\n   need_toc_init = 1;\n-  ASM_GENERATE_INTERNAL_LABEL (buf, \\\"LCTOC\\\",\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\",\n \t\t\t       !TARGET_ELF || !TARGET_MINIMAL_TOC);\n   if (TARGET_ELF)\n-    strcat (buf, \\\"@toc\\\");\n+    strcat (buf, \"@toc\");\n   operands[1] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n   operands[2] = gen_rtx_REG (Pmode, 2);\n-  return \\\"ld %0,%1(%2)\\\";\n-}\"\n+  return \"ld %0,%1(%2)\";\n+}\n   [(set_attr \"type\" \"load\")\n    (set_attr \"update\" \"no\")\n    (set_attr \"indexed\" \"no\")])\n@@ -10018,7 +9978,7 @@\n    (use (unspec [(match_dup 0)] UNSPEC_TOC))]\n   \"!TARGET_LINK_STACK && TARGET_ELF && DEFAULT_ABI == ABI_V4\n    && (flag_pic == 2 || (flag_pic && TARGET_SECURE_PLT))\"\n-  \"bcl 20,31,%0\\\\n%0:\"\n+  \"bcl 20,31,%0\\n%0:\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")\n    (set_attr \"cannot_copy\" \"yes\")])\n@@ -10029,15 +9989,14 @@\n    (use (unspec [(match_dup 0)] UNSPEC_TOC))]\n   \"TARGET_LINK_STACK && TARGET_ELF && DEFAULT_ABI == ABI_V4\n    && (flag_pic == 2 || (flag_pic && TARGET_SECURE_PLT))\"\n-  \"*\n {\n   char name[32];\n   static char templ[32];\n \n   get_ppc476_thunk_name (name);\n-  sprintf (templ, \\\"bl %s\\\\n%%0:\\\", name);\n+  sprintf (templ, \"bl %s\\n%%0:\", name);\n   return templ;\n-}\"\n+}\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")\n    (set_attr \"cannot_copy\" \"yes\")])\n@@ -10069,15 +10028,14 @@\n \t\tUNSPEC_TOCPTR))\n    (match_dup 1)]\n   \"TARGET_LINK_STACK && TARGET_ELF && DEFAULT_ABI == ABI_V4 && flag_pic == 2\"\n-  \"*\n {\n   char name[32];\n   static char templ[32];\n \n   get_ppc476_thunk_name (name);\n-  sprintf (templ, \\\"bl %s\\\\n\\\\tb $+8\\\\n\\\\t.long %%0-$\\\", name);\n+  sprintf (templ, \"bl %s\\;b $+8\\;.long %%0-$\", name);\n   return templ;\n-}\"\n+}\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"16\")])\n \n@@ -10123,7 +10081,6 @@\n   \"(DEFAULT_ABI == ABI_V4 && flag_pic == 1)\n    || (TARGET_TOC && TARGET_MINIMAL_TOC)\n    || (DEFAULT_ABI == ABI_DARWIN && flag_pic)\"\n-  \"\n {\n #if TARGET_MACHO\n   if (DEFAULT_ABI == ABI_DARWIN)\n@@ -10134,7 +10091,7 @@\n       char tmplab[20];\n \n       crtl->uses_pic_offset_table = 1;\n-      ASM_GENERATE_INTERNAL_LABEL(tmplab, \\\"LSJR\\\",\n+      ASM_GENERATE_INTERNAL_LABEL(tmplab, \"LSJR\",\n \t\t\t\t  CODE_LABEL_NUMBER (operands[0]));\n       tmplabrtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (tmplab));\n \n@@ -10146,7 +10103,7 @@\n #endif\n     rs6000_emit_load_toc_table (FALSE);\n   DONE;\n-}\")\n+})\n \n ;; Largetoc support\n (define_insn \"*largetoc_high\"\n@@ -10236,7 +10193,6 @@\n \t      (use (match_operand 2 \"\" \"\"))\n \t      (clobber (reg:SI LR_REGNO))])]\n   \"\"\n-  \"\n {\n #if TARGET_MACHO\n   if (MACHOPIC_INDIRECT)\n@@ -10271,7 +10227,7 @@\n \t  gcc_unreachable ();\n \t}\n     }\n-}\")\n+})\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -10280,7 +10236,6 @@\n \t      (use (match_operand 3 \"\" \"\"))\n \t      (clobber (reg:SI LR_REGNO))])]\n   \"\"\n-  \"\n {\n #if TARGET_MACHO\n   if (MACHOPIC_INDIRECT)\n@@ -10315,7 +10270,7 @@\n \t  gcc_unreachable ();\n \t}\n     }\n-}\")\n+})\n \n ;; Call to function in current module.  No TOC pointer reload needed.\n ;; Operand2 is nonzero if we are using the V.4 calling sequence and\n@@ -10329,16 +10284,15 @@\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n    (clobber (reg:SI LR_REGNO))]\n   \"(INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"*\n {\n   if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+    output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+    output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z0@local\\\" : \\\"bl %z0\\\";\n-}\"\n+  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"bl %z0@local\" : \"bl %z0\";\n+}\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -10348,16 +10302,15 @@\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n    (clobber (reg:SI LR_REGNO))]\n   \"TARGET_64BIT && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"*\n {\n   if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+    output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+    output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z0@local\\\" : \\\"bl %z0\\\";\n-}\"\n+  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"bl %z0@local\" : \"bl %z0\";\n+}\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -10368,16 +10321,15 @@\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (clobber (reg:SI LR_REGNO))]\n   \"(INTVAL (operands[3]) & CALL_LONG) == 0\"\n-  \"*\n {\n   if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+    output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+    output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z1@local\\\" : \\\"bl %z1\\\";\n-}\"\n+  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"bl %z1@local\" : \"bl %z1\";\n+}\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -10389,16 +10341,15 @@\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (clobber (reg:SI LR_REGNO))]\n   \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n-  \"*\n {\n   if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+    output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+    output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z1@local\\\" : \\\"bl %z1\\\";\n-}\"\n+  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"bl %z1@local\" : \"bl %z1\";\n+}\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -10772,7 +10723,6 @@\n \t      (match_operand 1 \"\" \"\")\n \t      (match_operand 2 \"\" \"\")])]\n   \"\"\n-  \"\n {\n   int i;\n \n@@ -10791,7 +10741,7 @@\n   emit_insn (gen_blockage ());\n \n   DONE;\n-}\")\n+})\n \n ;; sibling call patterns\n (define_expand \"sibcall\"\n@@ -10800,7 +10750,6 @@\n \t      (use (match_operand 2 \"\" \"\"))\n \t      (simple_return)])]\n   \"\"\n-  \"\n {\n #if TARGET_MACHO\n   if (MACHOPIC_INDIRECT)\n@@ -10817,7 +10766,7 @@\n       rs6000_sibcall_aix (NULL_RTX, operands[0], operands[1], operands[2]);\n       DONE;\n     }\n-}\")\n+})\n \n (define_expand \"sibcall_value\"\n   [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n@@ -10826,7 +10775,6 @@\n \t      (use (match_operand 3 \"\" \"\"))\n \t      (simple_return)])]\n   \"\"\n-  \"\n {\n #if TARGET_MACHO\n   if (MACHOPIC_INDIRECT)\n@@ -10843,24 +10791,23 @@\n       rs6000_sibcall_aix (operands[0], operands[1], operands[2], operands[3]);\n       DONE;\n     }\n-}\")\n+})\n \n (define_insn \"*sibcall_local32\"\n   [(call (mem:SI (match_operand:SI 0 \"current_file_function_operand\" \"s,s\"))\n \t (match_operand 1 \"\" \"g,g\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n    (simple_return)]\n   \"(INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"*\n {\n   if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+    output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+    output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"b %z0@local\\\" : \\\"b %z0\\\";\n-}\"\n+  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"b %z0@local\" : \"b %z0\";\n+}\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -10870,16 +10817,15 @@\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n    (simple_return)]\n   \"TARGET_64BIT && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"*\n {\n   if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+    output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+    output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"b %z0@local\\\" : \\\"b %z0\\\";\n-}\"\n+  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"b %z0@local\" : \"b %z0\";\n+}\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -10890,16 +10836,15 @@\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (simple_return)]\n   \"(INTVAL (operands[3]) & CALL_LONG) == 0\"\n-  \"*\n {\n   if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+    output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+    output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"b %z1@local\\\" : \\\"b %z1\\\";\n-}\"\n+  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"b %z1@local\" : \"b %z1\";\n+}\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -10910,16 +10855,15 @@\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (simple_return)]\n   \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n-  \"*\n {\n   if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+    output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+    output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"b %z1@local\\\" : \\\"b %z1\\\";\n-}\"\n+  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"b %z1@local\" : \"b %z1\";\n+}\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -11121,7 +11065,6 @@\n           (match_operand:GPR 2 \"reg_or_short_operand\" \"\")]))\n    (use (match_operand 3 \"\"))]\n   \"\"\n-  \"\n {\n   /* Take care of the possibility that operands[2] might be negative but\n      this might be a logical operation.  That insn doesn't exist.  */\n@@ -11136,19 +11079,18 @@\n \n   rs6000_emit_cbranch (<MODE>mode, operands);\n   DONE;\n-}\")\n+})\n \n (define_expand \"cbranch<mode>4\"\n   [(use (match_operator 0 \"comparison_operator\"\n          [(match_operand:FP 1 \"gpc_reg_operand\" \"\")\n           (match_operand:FP 2 \"gpc_reg_operand\" \"\")]))\n    (use (match_operand 3 \"\"))]\n   \"\"\n-  \"\n {\n   rs6000_emit_cbranch (<MODE>mode, operands);\n   DONE;\n-}\")\n+})\n \n (define_expand \"cstore<mode>4_signed\"\n   [(use (match_operator 1 \"signed_comparison_operator\"\n@@ -11795,7 +11737,6 @@\n \t\t\t\t       (const_int 0)])\n \t\t   (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"\"\n-  \"*\n {\n   int is_bit = ccr_bit (operands[1], 1);\n   int put_bit = 31 - (INTVAL (operands[3]) & 31);\n@@ -11809,8 +11750,8 @@\n   operands[4] = GEN_INT (count);\n   operands[5] = GEN_INT (put_bit);\n \n-  return \\\"mfcr %0%Q2\\;rlwinm %0,%0,%4,%5,%5\\\";\n-}\"\n+  return \"mfcr %0%Q2\\;rlwinm %0,%0,%4,%5,%5\";\n+}\n   [(set (attr \"type\")\n      (cond [(match_test \"TARGET_MFCRF\")\n \t\t(const_string \"mfcrf\")\n@@ -11830,15 +11771,14 @@\n \t(ashift:SI (match_op_dup 1 [(match_dup 2) (const_int 0)])\n \t\t   (match_dup 3)))]\n   \"\"\n-  \"*\n {\n   int is_bit = ccr_bit (operands[1], 1);\n   int put_bit = 31 - (INTVAL (operands[3]) & 31);\n   int count;\n \n   /* Force split for non-cc0 compare.  */\n   if (which_alternative == 1)\n-     return \\\"#\\\";\n+     return \"#\";\n \n   if (is_bit >= put_bit)\n     count = is_bit - put_bit;\n@@ -11848,8 +11788,8 @@\n   operands[5] = GEN_INT (count);\n   operands[6] = GEN_INT (put_bit);\n \n-  return \\\"mfcr %4%Q2\\;rlwinm. %4,%4,%5,%6,%6\\\";\n-}\"\n+  return \"mfcr %4%Q2\\;rlwinm. %4,%4,%5,%6,%6\";\n+}\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"dot\" \"yes\")\n    (set_attr \"length\" \"8,16\")])\n@@ -12433,7 +12373,6 @@\n   \"\"\n   [(set (match_dup 0) (compare:CCEQ (xor:SI (match_dup 1) (match_dup 3))\n \t\t\t\t    (match_dup 5)))]\n-  \"\n {\n   int positive_1, positive_2;\n \n@@ -12469,7 +12408,7 @@\n     {\n       operands[5] = const1_rtx;\n     }\n-}\")\n+})\n \n ;; Unconditional branch and return.\n \n@@ -12894,18 +12833,17 @@\n \t\t\t\t     (match_operand 3 \"immediate_operand\" \"n\")]\n \t\t\t  UNSPEC_MOVESI_FROM_CR))])]\n   \"TARGET_MFCRF\"\n-  \"*\n {\n   int mask = 0;\n   int i;\n   for (i = 0; i < XVECLEN (operands[0], 0); i++)\n   {\n     mask = INTVAL (XVECEXP (SET_SRC (XVECEXP (operands[0], 0, i)), 0, 1));\n     operands[4] = GEN_INT (mask);\n-    output_asm_insn (\\\"mfcr %1,%4\\\", operands);\n+    output_asm_insn (\"mfcr %1,%4\", operands);\n   }\n-  return \\\"\\\";\n-}\"\n+  return \"\";\n+}\n   [(set_attr \"type\" \"mfcrf\")])\n \n ;; Don't include the volatile CRs since their values are not used wrt CR save\n@@ -13077,15 +13015,14 @@\n \t\t\t\t     (match_operand 3 \"immediate_operand\" \"n\")]\n \t\t\t\t    UNSPEC_MOVESI_TO_CR))])]\n  \"\"\n- \"*\n {\n   int mask = 0;\n   int i;\n   for (i = 0; i < XVECLEN (operands[0], 0); i++)\n     mask |= INTVAL (XVECEXP (SET_SRC (XVECEXP (operands[0], 0, i)), 0, 1));\n   operands[4] = GEN_INT (mask);\n-  return \\\"mtcrf %4,%2\\\";\n-}\"\n+  return \"mtcrf %4,%2\";\n+}\n   [(set_attr \"type\" \"mtcr\")])\n \n (define_insn \"*mtcrfsi\"\n@@ -13275,14 +13212,13 @@\n (define_expand \"eh_return\"\n   [(use (match_operand 0 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n {\n   if (TARGET_32BIT)\n     emit_insn (gen_eh_set_lr_si (operands[0]));\n   else\n     emit_insn (gen_eh_set_lr_di (operands[0]));\n   DONE;\n-}\")\n+})\n \n ; We can't expand this before we know where the link register is stored.\n (define_insn \"eh_set_lr_<mode>\"\n@@ -13297,23 +13233,21 @@\n    (clobber (match_scratch 1 \"\"))]\n   \"reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rs6000_emit_eh_reg_restore (operands[0], operands[1]);\n   DONE;\n-}\")\n+})\n \n (define_insn \"prefetch\"\n   [(prefetch (match_operand 0 \"indexed_or_indirect_address\" \"a\")\n \t     (match_operand:SI 1 \"const_int_operand\" \"n\")\n \t     (match_operand:SI 2 \"const_int_operand\" \"n\"))]\n   \"\"\n-  \"*\n {\n   if (GET_CODE (operands[0]) == REG)\n-    return INTVAL (operands[1]) ? \\\"dcbtst 0,%0\\\" : \\\"dcbt 0,%0\\\";\n-  return INTVAL (operands[1]) ? \\\"dcbtst %a0\\\" : \\\"dcbt %a0\\\";\n-}\"\n+    return INTVAL (operands[1]) ? \"dcbtst 0,%0\" : \"dcbt 0,%0\";\n+  return INTVAL (operands[1]) ? \"dcbtst %a0\" : \"dcbt %a0\";\n+}\n   [(set_attr \"type\" \"load\")])\n \f\n ;; Handle -fsplit-stack."}, {"sha": "0a58a75135aefc802300acce64c9f2afd5d504f5", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 23, "deletions": 46, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=6c3323139491780d1dc6d9c938d145045788aca4", "patch": "@@ -181,7 +181,6 @@\n   [(set (match_operand:VEC_M 0 \"vfloat_operand\" \"\")\n \t(match_operand:VEC_M 1 \"memory_operand\" \"\"))]\n   \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   gcc_assert (VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode));\n \n@@ -198,13 +197,12 @@\n         emit_insn (gen_altivec_lvx_<mode>_1op (operands[0], operands[1]));\n       DONE;\n     }\n-}\")\n+})\n \n (define_expand \"vector_altivec_store_<mode>\"\n   [(set (match_operand:VEC_M 0 \"memory_operand\" \"\")\n \t(match_operand:VEC_M 1 \"vfloat_operand\" \"\"))]\n   \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   gcc_assert (VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode));\n \n@@ -221,7 +219,7 @@\n         emit_insn (gen_altivec_stvx_<mode>_1op (operands[1], operands[0]));\n       DONE;\n     }\n-}\")\n+})\n \n \n \f\n@@ -272,27 +270,25 @@\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n \t(neg:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\" \"\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   if (<MODE>mode == V4SFmode && VECTOR_UNIT_ALTIVEC_P (<MODE>mode))\n     {\n       emit_insn (gen_altivec_negv4sf2 (operands[0], operands[1]));\n       DONE;\n     }\n-}\")\n+})\n \n (define_expand \"abs<mode>2\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n \t(abs:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\" \"\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   if (<MODE>mode == V4SFmode && VECTOR_UNIT_ALTIVEC_P (<MODE>mode))\n     {\n       emit_insn (gen_altivec_absv4sf2 (operands[0], operands[1]));\n       DONE;\n     }\n-}\")\n+})\n \n (define_expand \"smin<mode>3\"\n   [(set (match_operand:VEC_F 0 \"register_operand\" \"\")\n@@ -369,15 +365,14 @@\n \t(unspec:VEC_F [(match_operand:VEC_F 1 \"vfloat_operand\" \"\")\n \t\t       (match_operand:VEC_F 2 \"vfloat_operand\" \"\")] UNSPEC_COPYSIGN))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   if (<MODE>mode == V4SFmode && VECTOR_UNIT_ALTIVEC_P (<MODE>mode))\n     {\n       emit_insn (gen_altivec_copysign_v4sf3 (operands[0], operands[1],\n \t\t\t\t\t     operands[2]));\n       DONE;\n     }\n-}\")\n+})\n \n \f\n ;; Vector comparisons\n@@ -390,14 +385,13 @@\n \t (match_operand:VEC_F 1 \"vfloat_operand\" \"\")\n \t (match_operand:VEC_F 2 \"vfloat_operand\" \"\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   if (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n \t\t\t\t    operands[3], operands[4], operands[5]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_expand \"vcond<mode><mode>\"\n   [(set (match_operand:VEC_I 0 \"vint_operand\")\n@@ -408,14 +402,13 @@\n \t (match_operand:VEC_I 1 \"vector_int_reg_or_same_bit\")\n \t (match_operand:VEC_I 2 \"vector_int_reg_or_same_bit\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   if (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n \t\t\t\t    operands[3], operands[4], operands[5]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_expand \"vcondv4sfv4si\"\n   [(set (match_operand:V4SF 0 \"vfloat_operand\" \"\")\n@@ -427,14 +420,13 @@\n \t (match_operand:V4SF 2 \"vfloat_operand\" \"\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\n    && VECTOR_UNIT_ALTIVEC_P (V4SImode)\"\n-  \"\n {\n   if (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n \t\t\t\t    operands[3], operands[4], operands[5]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_expand \"vcondv4siv4sf\"\n   [(set (match_operand:V4SI 0 \"vint_operand\" \"\")\n@@ -446,14 +438,13 @@\n \t (match_operand:V4SI 2 \"vint_operand\" \"\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\n    && VECTOR_UNIT_ALTIVEC_P (V4SImode)\"\n-  \"\n {\n   if (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n \t\t\t\t    operands[3], operands[4], operands[5]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_expand \"vcondv2dfv2di\"\n   [(set (match_operand:V2DF 0 \"vfloat_operand\")\n@@ -500,14 +491,13 @@\n \t (match_operand:VEC_I 1 \"vector_int_reg_or_same_bit\")\n \t (match_operand:VEC_I 2 \"vector_int_reg_or_same_bit\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   if (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n \t\t\t\t    operands[3], operands[4], operands[5]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_expand \"vconduv4sfv4si\"\n   [(set (match_operand:V4SF 0 \"vfloat_operand\" \"\")\n@@ -519,14 +509,13 @@\n \t (match_operand:V4SF 2 \"vfloat_operand\" \"\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\n    && VECTOR_UNIT_ALTIVEC_P (V4SImode)\"\n-  \"\n {\n   if (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n \t\t\t\t    operands[3], operands[4], operands[5]))\n     DONE;\n   else\n     FAIL;\n-}\")\n+})\n \n (define_expand \"vconduv2dfv2di\"\n   [(set (match_operand:V2DF 0 \"vfloat_operand\")\n@@ -575,10 +564,9 @@\n    (set (match_operand:VEC_I 0 \"vlogical_operand\" \"\")\n         (not:VEC_I (match_dup 3)))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n-}\")\n+})\n \n (define_expand \"vector_gtu<mode>\"\n   [(set (match_operand:VEC_I 0 \"vint_operand\" \"\")\n@@ -595,10 +583,9 @@\n    (set (match_operand:VEC_I 0 \"vlogical_operand\" \"\")\n         (not:VEC_I (match_dup 3)))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n-}\")\n+})\n \n (define_expand \"vector_geu<mode>\"\n   [(set (match_operand:VEC_I 0 \"vint_operand\" \"\")\n@@ -615,10 +602,9 @@\n    (set (match_operand:VEC_I 0 \"vlogical_operand\" \"\")\n         (not:VEC_I (match_dup 3)))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n-}\")\n+})\n \n (define_expand \"vector_ngtu<mode>\"\n   [(set (match_operand:VEC_I 3 \"vlogical_operand\" \"\")\n@@ -627,10 +613,9 @@\n    (set (match_operand:VEC_I 0 \"vlogical_operand\" \"\")\n         (not:VEC_I (match_dup 3)))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n-}\")\n+})\n \n (define_insn_and_split \"*vector_uneq<mode>\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n@@ -669,11 +654,10 @@\n    (set (match_dup 0)\n \t(ior:VEC_F (match_dup 3)\n \t\t   (match_dup 4)))]\n-  \"\n {\n   operands[3] = gen_reg_rtx (<MODE>mode);\n   operands[4] = gen_reg_rtx (<MODE>mode);\n-}\")\n+})\n \n (define_insn_and_split \"*vector_ordered<mode>\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n@@ -691,11 +675,10 @@\n    (set (match_dup 0)\n \t(ior:VEC_F (match_dup 3)\n \t\t   (match_dup 4)))]\n-  \"\n {\n   operands[3] = gen_reg_rtx (<MODE>mode);\n   operands[4] = gen_reg_rtx (<MODE>mode);\n-}\")\n+})\n \n (define_insn_and_split \"*vector_unordered<mode>\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n@@ -713,11 +696,10 @@\n    (set (match_dup 0)\n         (and:VEC_F (not:VEC_F (match_dup 3))\n                    (not:VEC_F (match_dup 4))))]\n-  \"\n {\n   operands[3] = gen_reg_rtx (<MODE>mode);\n   operands[4] = gen_reg_rtx (<MODE>mode);\n-}\")\n+})\n \n ;; Note the arguments for __builtin_altivec_vsel are op2, op1, mask\n ;; which is in the reverse order that we want\n@@ -1030,53 +1012,49 @@\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n \t(float:VEC_F (match_operand:<VEC_INT> 1 \"vint_operand\" \"\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   if (<MODE>mode == V4SFmode && VECTOR_UNIT_ALTIVEC_P (<MODE>mode))\n     {\n       emit_insn (gen_altivec_vcfsx (operands[0], operands[1], const0_rtx));\n       DONE;\n     }\n-}\")\n+})\n \n (define_expand \"floatuns<VEC_int><mode>2\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n \t(unsigned_float:VEC_F (match_operand:<VEC_INT> 1 \"vint_operand\" \"\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   if (<MODE>mode == V4SFmode && VECTOR_UNIT_ALTIVEC_P (<MODE>mode))\n     {\n       emit_insn (gen_altivec_vcfux (operands[0], operands[1], const0_rtx));\n       DONE;\n     }\n-}\")\n+})\n \n (define_expand \"fix_trunc<mode><VEC_int>2\"\n   [(set (match_operand:<VEC_INT> 0 \"vint_operand\" \"\")\n \t(fix:<VEC_INT> (match_operand:VEC_F 1 \"vfloat_operand\" \"\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   if (<MODE>mode == V4SFmode && VECTOR_UNIT_ALTIVEC_P (<MODE>mode))\n     {\n       emit_insn (gen_altivec_vctsxs (operands[0], operands[1], const0_rtx));\n       DONE;\n     }\n-}\")\n+})\n \n (define_expand \"fixuns_trunc<mode><VEC_int>2\"\n   [(set (match_operand:<VEC_INT> 0 \"vint_operand\" \"\")\n \t(unsigned_fix:<VEC_INT> (match_operand:VEC_F 1 \"vfloat_operand\" \"\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\n {\n   if (<MODE>mode == V4SFmode && VECTOR_UNIT_ALTIVEC_P (<MODE>mode))\n     {\n       emit_insn (gen_altivec_vctuxs (operands[0], operands[1], const0_rtx));\n       DONE;\n     }\n-}\")\n+})\n \n \f\n ;; Vector initialization, set, extract\n@@ -1273,7 +1251,6 @@\n    (match_operand:VEC_L 1 \"vlogical_operand\" \"\")\n    (match_operand:QI 2 \"reg_or_short_operand\" \"\")]\n   \"TARGET_ALTIVEC\"\n-  \"\n {\n   rtx bitshift = operands[2];\n   rtx shift;\n@@ -1315,7 +1292,7 @@\n \n   emit_insn (insn);\n   DONE;\n-}\")\n+})\n \n ;; Expanders for rotate each element in a vector\n (define_expand \"vrotl<mode>3\""}, {"sha": "9249ce56cfc5bbfd7390d19e510dd6e70dfabe02", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3323139491780d1dc6d9c938d145045788aca4/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=6c3323139491780d1dc6d9c938d145045788aca4", "patch": "@@ -443,7 +443,6 @@\n         (vec_select:<MODE>\n           (match_dup 2)\n           (parallel [(const_int 1) (const_int 0)])))]\n-  \"\n {\n   rtx mem = operands[1];\n \n@@ -475,7 +474,6 @@\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n                                        : operands[0];\n }\n-  \"\n   [(set_attr \"type\" \"vecload\")\n    (set_attr \"length\" \"8\")])\n \n@@ -495,7 +493,6 @@\n           (match_dup 2)\n           (parallel [(const_int 2) (const_int 3)\n                      (const_int 0) (const_int 1)])))]\n-  \"\n {\n   rtx mem = operands[1];\n \n@@ -527,7 +524,6 @@\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n                                        : operands[0];\n }\n-  \"\n   [(set_attr \"type\" \"vecload\")\n    (set_attr \"length\" \"8\")])\n \n@@ -551,7 +547,6 @@\n                      (const_int 6) (const_int 7)\n                      (const_int 0) (const_int 1)\n                      (const_int 2) (const_int 3)])))]\n-  \"\n {\n   rtx mem = operands[1];\n \n@@ -583,7 +578,6 @@\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n                                        : operands[0];\n }\n-  \"\n   [(set_attr \"type\" \"vecload\")\n    (set_attr \"length\" \"8\")])\n \n@@ -615,7 +609,6 @@\n                      (const_int 2) (const_int 3)\n                      (const_int 4) (const_int 5)\n                      (const_int 6) (const_int 7)])))]\n-  \"\n {\n   rtx mem = operands[1];\n \n@@ -647,7 +640,6 @@\n   operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n                                        : operands[0];\n }\n-  \"\n   [(set_attr \"type\" \"vecload\")\n    (set_attr \"length\" \"8\")])\n \n@@ -1037,7 +1029,6 @@\n    #\"\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n   [(const_int 0)]\n-  \"\n {\n   rtx tmp = (can_create_pseudo_p ()\n \t     ? gen_reg_rtx_and_attrs (operands[0])\n@@ -1046,7 +1037,6 @@\n   rs6000_emit_le_vsx_permute (operands[0], tmp, <MODE>mode);\n   DONE;\n }\n-  \"\n   [(set_attr \"type\" \"vecload,load\")\n    (set_attr \"length\" \"8,8\")])\n \n@@ -1640,7 +1630,6 @@\n   \"#\"\n   \"VECTOR_MEM_VSX_P (V2DImode) && !reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n@@ -1668,7 +1657,7 @@\n     }\n   emit_insn (gen_vsx_concat_v2di (op0, op5, op3));\n   DONE;\n-}\"\n+}\n   [(set_attr \"type\" \"mul\")])\n \n (define_insn \"*vsx_div<mode>3\"\n@@ -1690,7 +1679,6 @@\n   \"#\"\n   \"VECTOR_MEM_VSX_P (V2DImode) && !reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n@@ -1726,7 +1714,7 @@\n     }\n   emit_insn (gen_vsx_concat_v2di (op0, op5, op3));\n   DONE;\n-}\"\n+}\n   [(set_attr \"type\" \"div\")])\n \n (define_insn_and_split \"vsx_udiv_v2di\"\n@@ -1738,7 +1726,6 @@\n   \"#\"\n   \"VECTOR_MEM_VSX_P (V2DImode) && !reload_completed\"\n   [(const_int 0)]\n-  \"\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n@@ -1774,7 +1761,7 @@\n     }\n   emit_insn (gen_vsx_concat_v2di (op0, op5, op3));\n   DONE;\n-}\"\n+}\n   [(set_attr \"type\" \"div\")])\n \n ;; *tdiv* instruction returning the FG flag\n@@ -4328,15 +4315,14 @@\n   \"#\"\n   \"\"\n   [(const_int 0)]\n-  \"\n {\n   rtx tmp = (GET_CODE (operands[2]) == SCRATCH)\n \t     ? gen_reg_rtx (V2DFmode)\n \t     : operands[2];\n   emit_insn (gen_vsx_xxsldwi_v2df (tmp, operands[1], operands[1], const2_rtx));\n   emit_insn (gen_<VEC_reduc_rtx>v2df3 (operands[0], tmp, operands[1]));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"veccomplex\")])\n \n@@ -4351,7 +4337,6 @@\n   \"#\"\n   \"\"\n   [(const_int 0)]\n-  \"\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n@@ -4375,7 +4360,7 @@\n   emit_insn (gen_vsx_xxsldwi_v4sf (tmp4, tmp3, tmp3, GEN_INT (3)));\n   emit_insn (gen_<VEC_reduc_rtx>v4sf3 (op0, tmp4, tmp3));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"16\")\n    (set_attr \"type\" \"veccomplex\")])\n \n@@ -4400,7 +4385,6 @@\n   \"#\"\n   \"\"\n   [(const_int 0)]\n-  \"\n {\n   rtx hi = gen_highpart (DFmode, operands[1]);\n   rtx lo = (GET_CODE (operands[2]) == SCRATCH)\n@@ -4410,7 +4394,7 @@\n   emit_insn (gen_vsx_extract_v2df (lo, operands[1], const1_rtx));\n   emit_insn (gen_<VEC_reduc_rtx>df3 (operands[0], hi, lo));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"veccomplex\")])\n \n@@ -4428,7 +4412,6 @@\n   \"#\"\n   \"\"\n   [(const_int 0)]\n-  \"\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n@@ -4455,7 +4438,7 @@\n   emit_insn (gen_<VEC_reduc_rtx>v4sf3 (tmp5, tmp4, tmp3));\n   emit_insn (gen_vsx_xscvspdp_scalar2 (op0, tmp5));\n   DONE;\n-}\"\n+}\n   [(set_attr \"length\" \"20\")\n    (set_attr \"type\" \"veccomplex\")])\n "}]}