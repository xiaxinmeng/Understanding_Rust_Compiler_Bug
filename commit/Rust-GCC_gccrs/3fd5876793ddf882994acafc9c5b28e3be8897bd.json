{"sha": "3fd5876793ddf882994acafc9c5b28e3be8897bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZkNTg3Njc5M2RkZjg4Mjk5NGFjYWZjOWM1YjI4ZTNiZTg4OTdiZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-21T23:42:11Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-21T23:42:11Z"}, "message": "Strenghten bound for bulitin_constant_p hint.\n\nthis patch makes builtin_constant_p hint to combine with other loop hints\nwe already support.\n\ngcc/ChangeLog:\n\n2020-10-22  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR ipa/97445\n\t* ipa-inline.c (inline_insns_single): Add hint2 parameter.\n\t(inline_insns_auto): Add hint2 parameter.\n\t(can_inline_edge_by_limits_p): Update.\n\t(want_inline_small_function_p): Update.\n\t(wrapper_heuristics_may_apply): Update.", "tree": {"sha": "c133a6d3e91cc3c740802711094528652f1975b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c133a6d3e91cc3c740802711094528652f1975b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fd5876793ddf882994acafc9c5b28e3be8897bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd5876793ddf882994acafc9c5b28e3be8897bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fd5876793ddf882994acafc9c5b28e3be8897bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd5876793ddf882994acafc9c5b28e3be8897bd/comments", "author": null, "committer": null, "parents": [{"sha": "083c17f86dcf13fc344667432b59c96bf2b63dcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/083c17f86dcf13fc344667432b59c96bf2b63dcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/083c17f86dcf13fc344667432b59c96bf2b63dcb"}], "stats": {"total": 71, "additions": 47, "deletions": 24}, "files": [{"sha": "3827970635c0a5c5f5d2dd0fcaacd80e3082fd5b", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd5876793ddf882994acafc9c5b28e3be8897bd/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd5876793ddf882994acafc9c5b28e3be8897bd/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=3fd5876793ddf882994acafc9c5b28e3be8897bd", "patch": "@@ -398,26 +398,42 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n   return inlinable;\n }\n \n-/* Return inlining_insns_single limit for function N. If HINT is true\n+/* Return inlining_insns_single limit for function N.  If HINT or HINT2 is true\n    scale up the bound.  */\n \n static int\n-inline_insns_single (cgraph_node *n, bool hint)\n+inline_insns_single (cgraph_node *n, bool hint, bool hint2)\n {\n-  if (hint)\n+  if (hint && hint2)\n+    {\n+      int64_t spd = opt_for_fn (n->decl, param_inline_heuristics_hint_percent);\n+      spd = spd * spd;\n+      if (spd > 1000000)\n+\tspd = 1000000;\n+      return opt_for_fn (n->decl, param_max_inline_insns_single) * spd / 100;\n+    }\n+  if (hint || hint2)\n     return opt_for_fn (n->decl, param_max_inline_insns_single)\n \t   * opt_for_fn (n->decl, param_inline_heuristics_hint_percent) / 100;\n   return opt_for_fn (n->decl, param_max_inline_insns_single);\n }\n \n-/* Return inlining_insns_auto limit for function N. If HINT is true\n+/* Return inlining_insns_auto limit for function N.  If HINT or HINT2 is true\n    scale up the bound.   */\n \n static int\n-inline_insns_auto (cgraph_node *n, bool hint)\n+inline_insns_auto (cgraph_node *n, bool hint, bool hint2)\n {\n   int max_inline_insns_auto = opt_for_fn (n->decl, param_max_inline_insns_auto);\n-  if (hint)\n+  if (hint && hint2)\n+    {\n+      int64_t spd = opt_for_fn (n->decl, param_inline_heuristics_hint_percent);\n+      spd = spd * spd;\n+      if (spd > 1000000)\n+\tspd = 1000000;\n+      return max_inline_insns_auto * spd / 100;\n+    }\n+  if (hint || hint2)\n     return max_inline_insns_auto\n \t   * opt_for_fn (n->decl, param_inline_heuristics_hint_percent) / 100;\n   return max_inline_insns_auto;\n@@ -566,8 +582,8 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \t  int growth = estimate_edge_growth (e);\n \t  if (growth > opt_for_fn (caller->decl, param_max_inline_insns_size)\n \t      && (!DECL_DECLARED_INLINE_P (callee->decl)\n-\t\t  && growth >= MAX (inline_insns_single (caller, false),\n-\t\t\t\t    inline_insns_auto (caller, false))))\n+\t\t  && growth >= MAX (inline_insns_single (caller, false, false),\n+\t\t\t\t    inline_insns_auto (caller, false, false))))\n \t    {\n \t      e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t      inlinable = false;\n@@ -806,7 +822,7 @@ inlining_speedup (struct cgraph_edge *edge,\n }\n \n /* Return true if the speedup for inlining E is bigger than\n-   PARAM_MAX_INLINE_MIN_SPEEDUP.  */\n+   param_inline_min_speedup.  */\n \n static bool\n big_speedup_p (struct cgraph_edge *e)\n@@ -855,7 +871,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t   && (!e->count.ipa ().initialized_p () || !e->maybe_hot_p ()))\n \t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n-\t      > inline_insns_auto (e->caller, true))\n+\t      > inline_insns_auto (e->caller, true, true))\n     {\n       e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n       want_inline = false;\n@@ -864,7 +880,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t    || e->count.ipa ().nonzero_p ())\n \t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n-\t      > inline_insns_single (e->caller, true))\n+\t      > inline_insns_single (e->caller, true, true))\n     {\n       e->inline_failed = (DECL_DECLARED_INLINE_P (callee->decl)\n \t\t\t  ? CIF_MAX_INLINE_INSNS_SINGLE_LIMIT\n@@ -875,11 +891,14 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n     {\n       int growth = estimate_edge_growth (e);\n       ipa_hints hints = estimate_edge_hints (e);\n+      /* We have two independent groups of hints.  If one matches in each\n+\t of groups the limits are inreased.  If both groups matches, limit\n+\t is increased even more.  */\n       bool apply_hints = (hints & (INLINE_HINT_indirect_call\n \t\t\t\t   | INLINE_HINT_known_hot\n \t\t\t\t   | INLINE_HINT_loop_iterations\n-\t\t\t\t   | INLINE_HINT_loop_stride\n-\t\t\t\t   | INLINE_HINT_builtin_constant_p));\n+\t\t\t\t   | INLINE_HINT_loop_stride));\n+      bool apply_hints2 = (hints & INLINE_HINT_builtin_constant_p);\n \n       if (growth <= opt_for_fn (to->decl,\n \t\t\t\tparam_max_inline_insns_size))\n@@ -889,9 +908,11 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t Avoid computation of big_speedup_p when not necessary to change\n \t outcome of decision.  */\n       else if (DECL_DECLARED_INLINE_P (callee->decl)\n-\t       && growth >= inline_insns_single (e->caller, apply_hints)\n-\t       && (apply_hints\n-\t\t   || growth >= inline_insns_single (e->caller, true)\n+\t       && growth >= inline_insns_single (e->caller, apply_hints,\n+\t\t\t\t\t\t apply_hints2)\n+\t       && (apply_hints || apply_hints2\n+\t\t   || growth >= inline_insns_single (e->caller, true,\n+\t\t\t\t\t\t     apply_hints2)\n \t\t   || !big_speedup_p (e)))\n \t{\n           e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n@@ -903,7 +924,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t\t\t\t\tparam_max_inline_insns_small))\n \t{\n \t  /* growth_positive_p is expensive, always test it last.  */\n-          if (growth >= inline_insns_single (e->caller, false)\n+\t  if (growth >= inline_insns_single (e->caller, false, false)\n \t      || growth_positive_p (callee, e, growth))\n \t    {\n               e->inline_failed = CIF_NOT_DECLARED_INLINED;\n@@ -913,13 +934,15 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       /* Apply param_max_inline_insns_auto limit for functions not declared\n \t inline.  Bypass the limit when speedup seems big.  */\n       else if (!DECL_DECLARED_INLINE_P (callee->decl)\n-\t       && growth >= inline_insns_auto (e->caller, apply_hints)\n-\t       && (apply_hints\n-\t\t   || growth >= inline_insns_auto (e->caller, true)\n+\t       && growth >= inline_insns_auto (e->caller, apply_hints,\n+\t\t\t\t\t       apply_hints2)\n+\t       && (apply_hints || apply_hints2\n+\t\t   || growth >= inline_insns_auto (e->caller, true,\n+\t\t\t\t\t\t   apply_hints2)\n \t\t   || !big_speedup_p (e)))\n \t{\n \t  /* growth_positive_p is expensive, always test it last.  */\n-          if (growth >= inline_insns_single (e->caller, false)\n+\t  if (growth >= inline_insns_single (e->caller, false, false)\n \t      || growth_positive_p (callee, e, growth))\n \t    {\n \t      e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n@@ -928,7 +951,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t}\n       /* If call is cold, do not inline when function body would grow. */\n       else if (!e->maybe_hot_p ()\n-\t       && (growth >= inline_insns_single (e->caller, false)\n+\t       && (growth >= inline_insns_single (e->caller, false, false)\n \t\t   || growth_positive_p (callee, e, growth)))\n \t{\n           e->inline_failed = CIF_UNLIKELY_CALL;\n@@ -1112,8 +1135,8 @@ static bool\n wrapper_heuristics_may_apply (struct cgraph_node *where, int size)\n {\n   return size < (DECL_DECLARED_INLINE_P (where->decl)\n-\t\t ? inline_insns_single (where, false)\n-\t\t : inline_insns_auto (where, false));\n+\t\t ? inline_insns_single (where, false, false)\n+\t\t : inline_insns_auto (where, false, false));\n }\n \n /* A cost model driving the inlining heuristics in a way so the edges with"}]}