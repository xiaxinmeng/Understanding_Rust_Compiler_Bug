{"sha": "d321bd2d6ee4ebfd3246e7c0bbc121354bfe496d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMyMWJkMmQ2ZWU0ZWJmZDMyNDZlN2MwYmJjMTIxMzU0YmZlNDk2ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-19T22:04:57Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-19T22:04:57Z"}, "message": "ifcvt.c (noce_try_cmove_arith): Fix long lines.\n\n\t* ifcvt.c (noce_try_cmove_arith): Fix long lines.\n\t(check_cond_move_block): Likewise.\n\t(cond_move_process_if_block): Likewise.\n\t(noce_find_if_block): Improve formatting.\n\t(find_if_header): Pass 0 to memset and tweak conditions.\n\t(cond_exec_find_if_block): Fix long lines and tweak conditions.\n\nFrom-SVN: r158529", "tree": {"sha": "d48a40fb5914174bce06ffd32d7dac624ca1c37b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d48a40fb5914174bce06ffd32d7dac624ca1c37b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d321bd2d6ee4ebfd3246e7c0bbc121354bfe496d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d321bd2d6ee4ebfd3246e7c0bbc121354bfe496d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d321bd2d6ee4ebfd3246e7c0bbc121354bfe496d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d321bd2d6ee4ebfd3246e7c0bbc121354bfe496d/comments", "author": null, "committer": null, "parents": [{"sha": "310e44721056e49ef306847d4dc128cd9b736077", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310e44721056e49ef306847d4dc128cd9b736077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/310e44721056e49ef306847d4dc128cd9b736077"}], "stats": {"total": 53, "additions": 33, "deletions": 20}, "files": [{"sha": "46ab976abbfebebdc417428bbbf8111d1449a9e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d321bd2d6ee4ebfd3246e7c0bbc121354bfe496d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d321bd2d6ee4ebfd3246e7c0bbc121354bfe496d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d321bd2d6ee4ebfd3246e7c0bbc121354bfe496d", "patch": "@@ -1,3 +1,12 @@\n+2010-04-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* ifcvt.c (noce_try_cmove_arith): Fix long lines.\n+\t(check_cond_move_block): Likewise.\n+\t(cond_move_process_if_block): Likewise.\n+\t(noce_find_if_block): Improve formatting.\n+\t(find_if_header): Pass 0 to memset and tweak conditions.\n+\t(cond_exec_find_if_block): Fix long lines and tweak conditions.\n+\n 2010-04-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (lower_bound_default): For DW_LANG_Python return"}, {"sha": "0c2d437a9dcb632c047073cb7de7e88a17573045", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d321bd2d6ee4ebfd3246e7c0bbc121354bfe496d/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d321bd2d6ee4ebfd3246e7c0bbc121354bfe496d/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=d321bd2d6ee4ebfd3246e7c0bbc121354bfe496d", "patch": "@@ -1440,8 +1440,9 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n      if insn_rtx_cost can't be estimated.  */\n   if (insn_a)\n     {\n-      insn_cost = insn_rtx_cost (PATTERN (insn_a),\n-      \t\t\t\t optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn_a)));\n+      insn_cost\n+\t= insn_rtx_cost (PATTERN (insn_a),\n+      \t\t\t optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn_a)));\n       if (insn_cost == 0 || insn_cost > COSTS_N_INSNS (if_info->branch_cost))\n \treturn FALSE;\n     }\n@@ -1450,8 +1451,9 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n \n   if (insn_b)\n     {\n-      insn_cost += insn_rtx_cost (PATTERN (insn_b),\n-      \t\t\t\t optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn_b)));\n+      insn_cost\n+\t+= insn_rtx_cost (PATTERN (insn_b),\n+      \t\t\t  optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn_b)));\n       if (insn_cost == 0 || insn_cost > COSTS_N_INSNS (if_info->branch_cost))\n         return FALSE;\n     }\n@@ -2579,7 +2581,8 @@ noce_process_if_block (struct noce_if_info *if_info)\n    REGS.  COND is the condition we will test.  */\n \n static int\n-check_cond_move_block (basic_block bb, rtx *vals, VEC (int, heap) **regs, rtx cond)\n+check_cond_move_block (basic_block bb, rtx *vals, VEC (int, heap) **regs,\n+\t\t       rtx cond)\n {\n   rtx insn;\n \n@@ -2743,7 +2746,8 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n \n   /* Make sure the blocks are suitable.  */\n   if (!check_cond_move_block (then_bb, then_vals, &then_regs, cond)\n-      || (else_bb && !check_cond_move_block (else_bb, else_vals, &else_regs, cond)))\n+      || (else_bb\n+\t  && !check_cond_move_block (else_bb, else_vals, &else_regs, cond)))\n     {\n       VEC_free (int, heap, then_regs);\n       VEC_free (int, heap, else_regs);\n@@ -2859,8 +2863,7 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n    Return TRUE if we were successful at converting the block.  */\n \n static int\n-noce_find_if_block (basic_block test_bb,\n-\t\t    edge then_edge, edge else_edge,\n+noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n \t\t    int pass)\n {\n   basic_block then_bb, else_bb, join_bb;\n@@ -2941,9 +2944,7 @@ noce_find_if_block (basic_block test_bb,\n     return FALSE;\n \n   /* If this is not a standard conditional jump, we can't parse it.  */\n-  cond = noce_get_condition (jump,\n-\t\t\t     &cond_earliest,\n-\t\t\t     then_else_reversed);\n+  cond = noce_get_condition (jump, &cond_earliest, then_else_reversed);\n   if (!cond)\n     return FALSE;\n \n@@ -3135,7 +3136,7 @@ find_if_header (basic_block test_bb, int pass)\n     /* Otherwise this must be a multiway branch of some sort.  */\n     return NULL;\n \n-  memset (&ce_info, '\\0', sizeof (ce_info));\n+  memset (&ce_info, 0, sizeof (ce_info));\n   ce_info.test_bb = test_bb;\n   ce_info.then_bb = then_edge->dest;\n   ce_info.else_bb = else_edge->dest;\n@@ -3145,11 +3146,12 @@ find_if_header (basic_block test_bb, int pass)\n   IFCVT_INIT_EXTRA_FIELDS (&ce_info);\n #endif\n \n-  if (! reload_completed\n+  if (!reload_completed\n       && noce_find_if_block (test_bb, then_edge, else_edge, pass))\n     goto success;\n \n-  if (targetm.have_conditional_execution () && reload_completed\n+  if (reload_completed\n+      && targetm.have_conditional_execution ()\n       && cond_exec_find_if_block (&ce_info))\n     goto success;\n \n@@ -3159,7 +3161,7 @@ find_if_header (basic_block test_bb, int pass)\n     goto success;\n \n   if (dom_info_state (CDI_POST_DOMINATORS) >= DOM_NO_FAST_QUERY\n-      && (! targetm.have_conditional_execution () || reload_completed))\n+      && (reload_completed || !targetm.have_conditional_execution ()))\n     {\n       if (find_if_case_1 (test_bb, then_edge, else_edge))\n \tgoto success;\n@@ -3265,8 +3267,8 @@ cond_exec_find_if_block (struct ce_if_block * ce_info)\n   ce_info->last_test_bb = test_bb;\n \n   /* We only ever should get here after reload,\n-     and only if we have conditional execution.  */\n-  gcc_assert (targetm.have_conditional_execution () && reload_completed);\n+     and if we have conditional execution.  */\n+  gcc_assert (reload_completed && targetm.have_conditional_execution ());\n \n   /* Discover if any fall through predecessors of the current test basic block\n      were && tests (which jump to the else block) or || tests (which jump to\n@@ -3347,7 +3349,8 @@ cond_exec_find_if_block (struct ce_if_block * ce_info)\n   if (EDGE_COUNT (then_bb->succs) > 0\n       && (!single_succ_p (then_bb)\n           || (single_succ_edge (then_bb)->flags & EDGE_COMPLEX)\n-\t  || (epilogue_completed && tablejump_p (BB_END (then_bb), NULL, NULL))))\n+\t  || (epilogue_completed\n+\t      && tablejump_p (BB_END (then_bb), NULL, NULL))))\n     return FALSE;\n \n   /* If the THEN block has no successors, conditional execution can still\n@@ -3393,8 +3396,9 @@ cond_exec_find_if_block (struct ce_if_block * ce_info)\n   else if (single_succ_p (else_bb)\n \t   && single_succ (then_bb) == single_succ (else_bb)\n \t   && single_pred_p (else_bb)\n-\t   && ! (single_succ_edge (else_bb)->flags & EDGE_COMPLEX)\n-\t   && ! (epilogue_completed && tablejump_p (BB_END (else_bb), NULL, NULL)))\n+\t   && !(single_succ_edge (else_bb)->flags & EDGE_COMPLEX)\n+\t   && !(epilogue_completed\n+\t\t&& tablejump_p (BB_END (else_bb), NULL, NULL)))\n     join_bb = single_succ (else_bb);\n \n   /* Otherwise it is not an IF-THEN or IF-THEN-ELSE combination.  */"}]}