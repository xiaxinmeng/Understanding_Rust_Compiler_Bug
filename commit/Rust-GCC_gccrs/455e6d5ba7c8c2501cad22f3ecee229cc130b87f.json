{"sha": "455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU1ZTZkNWJhN2M4YzI1MDFjYWQyMmYzZWNlZTIyOWNjMTMwYjg3Zg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-08-04T12:29:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-08-04T12:29:48Z"}, "message": "tree-ssa-propagate.h (struct prop_value_d, [...]): Move ...\n\n2010-08-04  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-propagate.h (struct prop_value_d, prop_value_t): Move ...\n\t* tree-ssa-ccp.c: ... here.\n\t* tree-ssa-copy.c: ... and here.\n\t* tree-ssa-propagate.h (enum value_range_type, struct value_range_d, \n\tvalue_range_t): Move ...\n\t* tree-vrp.c: ... here.\n\t* tree-ssa-propagate.h (ssa_prop_get_value_fn): New typedef.\n\t(substitute_and_fold): Adjust prototype.\n\t* tree-ssa-propagate.c (replace_uses_in): Adjust.\n\t(replace_phi_args_in): Likewise.\n\t(substitute_and_fold): Take callback to query lattice instead\n\tof pointer to lattice.  Replace SSA name defs with lattice\n\tvalues first.\n\t* tree-ssa-ccp.c (ccp_finalize): Adjust.\n\t* tree-ssa-copy.c (copy_prop_visit_phi_node): Adjust.\n\t(get_value): New function.\n\t(fini_copy_prop): Adjust.\n\t* tree-vrp.c (vrp_finalize): Adjust.\n\n\t* gcc.dg/tree-ssa/vrp35.c: Adjust.\n\t* gcc.dg/tree-ssa/vrp36.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp50.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp52.c: Likewise.\n\nFrom-SVN: r162864", "tree": {"sha": "44d87dd02a78032816f3cb81e0405f29ab9570c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44d87dd02a78032816f3cb81e0405f29ab9570c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a48a91732b5252f6be1f0b3d54bfb1da52947caf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a48a91732b5252f6be1f0b3d54bfb1da52947caf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a48a91732b5252f6be1f0b3d54bfb1da52947caf"}], "stats": {"total": 272, "additions": 169, "deletions": 103}, "files": [{"sha": "77424eba5f83cf77fbaa845e7a89efc991723d96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "patch": "@@ -1,3 +1,24 @@\n+2010-08-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-propagate.h (struct prop_value_d, prop_value_t): Move ...\n+\t* tree-ssa-ccp.c: ... here.\n+\t* tree-ssa-copy.c: ... and here.\n+\t* tree-ssa-propagate.h (enum value_range_type, struct value_range_d, \n+\tvalue_range_t): Move ...\n+\t* tree-vrp.c: ... here.\n+\t* tree-ssa-propagate.h (ssa_prop_get_value_fn): New typedef.\n+\t(substitute_and_fold): Adjust prototype.\n+\t* tree-ssa-propagate.c (replace_uses_in): Adjust.\n+\t(replace_phi_args_in): Likewise.\n+\t(substitute_and_fold): Take callback to query lattice instead\n+\tof pointer to lattice.  Replace SSA name defs with lattice\n+\tvalues first.\n+\t* tree-ssa-ccp.c (ccp_finalize): Adjust.\n+\t* tree-ssa-copy.c (copy_prop_visit_phi_node): Adjust.\n+\t(get_value): New function.\n+\t(fini_copy_prop): Adjust.\n+\t* tree-vrp.c (vrp_finalize): Adjust.\n+\n 2010-08-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/45176"}, {"sha": "90dee6b74ed321752100d5721794703b777c2f03", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "patch": "@@ -1,3 +1,10 @@\n+2010-08-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/vrp35.c: Adjust.\n+\t* gcc.dg/tree-ssa/vrp36.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp50.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp52.c: Likewise.\n+\n 2010-08-04  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/44857"}, {"sha": "6402f4d2228d8b5f254d5ef278a28deeb6d90cd0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp35.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c?ref=455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "patch": "@@ -11,5 +11,5 @@ int test1(int i, int k)\n   return 1;\n }\n \n-/* { dg-final { scan-tree-dump \"Folding predicate j_.* == 10 to 0\" \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-not \"j_.* == 10\" \"vrp1\" } } */\n /* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "de300d7276b6dc577a9ef2f5f345a225e71af0fd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp36.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c?ref=455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "patch": "@@ -8,5 +8,5 @@ int foo(int i)\n   return 1;\n }\n \n-/* { dg-final { scan-tree-dump \"Folding predicate i_.* == 1 to 0\" \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-not \"i_.* == 1\" \"vrp1\" } } */\n /* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "a5b3ee28fd60454a4c4d163fba196b89cd6dfeac", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp50.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp50.c?ref=455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "patch": "@@ -30,7 +30,5 @@ int baz (int x, int y)\n   return x < 20;\n }\n \n-/* { dg-final { scan-tree-dump \"Folding predicate i_\\[^\\n\\r\\]* to 1\" \"vrp1\" } } */\n-/* { dg-final { scan-tree-dump \"Folding predicate c_\\[^\\n\\r\\]* to 1\" \"vrp1\" } } */\n-/* { dg-final { scan-tree-dump \"Folding predicate x_\\[^\\n\\r\\]* to 1\" \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 1;\" 3 \"vrp1\" } } */\n /* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "231d081565cb5d47f51755300f7665b07312b5c4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp52.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp52.c?ref=455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "patch": "@@ -12,5 +12,5 @@ foo (unsigned int i, unsigned int j)\n   return i >= 1024 + 2048;\n }\n \n-/* { dg-final { scan-tree-dump \"Folding predicate i_\\[^\\n\\r\\]* to 1\" \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 1;\" 1 \"vrp1\" } } */\n /* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "7d5f1a99ba4d85dc0c6ca146cb4fba541bde8004", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "patch": "@@ -144,6 +144,16 @@ typedef enum\n   VARYING\n } ccp_lattice_t;\n \n+struct prop_value_d {\n+    /* Lattice value.  */\n+    ccp_lattice_t lattice_val;\n+\n+    /* Propagated value.  */\n+    tree value;\n+};\n+\n+typedef struct prop_value_d prop_value_t;\n+\n /* Array of propagated constant values.  After propagation,\n    CONST_VAL[I].VALUE holds the constant value for SSA_NAME(I).  If\n    the constant is held in an SSA name representing a memory store\n@@ -645,7 +655,8 @@ ccp_finalize (void)\n \n   do_dbg_cnt ();\n   /* Perform substitutions based on the known constant values.  */\n-  something_changed = substitute_and_fold (const_val, ccp_fold_stmt, true);\n+  something_changed = substitute_and_fold (get_constant_value,\n+\t\t\t\t\t   ccp_fold_stmt, true);\n \n   free (const_val);\n   const_val = NULL;"}, {"sha": "767e18328d4e54b0515e31c368963552620995f5", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "patch": "@@ -285,6 +285,14 @@ propagate_tree_value_into_stmt (gimple_stmt_iterator *gsi, tree val)\n    After propagation, the copy-of value for each variable X_i is\n    converted into the final value by walking the copy-of chains and\n    updating COPY_OF[i].VALUE to be the last element of the chain.  */\n+\n+struct prop_value_d {\n+    /* Copy-of value.  */\n+    tree value;\n+};\n+\n+typedef struct prop_value_d prop_value_t;\n+\n static prop_value_t *copy_of;\n \n /* Used in set_copy_of_val to determine if the last link of a copy-of\n@@ -626,7 +634,7 @@ copy_prop_visit_phi_node (gimple phi)\n {\n   enum ssa_prop_result retval;\n   unsigned i;\n-  prop_value_t phi_val = { 0, NULL_TREE };\n+  prop_value_t phi_val = { NULL_TREE };\n \n   tree lhs = gimple_phi_result (phi);\n \n@@ -818,19 +826,27 @@ init_copy_prop (void)\n     }\n }\n \n+/* Callback for substitute_and_fold to get at the final copy-of values.  */\n+\n+static tree\n+get_value (tree name)\n+{\n+  tree val = copy_of[SSA_NAME_VERSION (name)].value;\n+  if (val && val != name)\n+    return val;\n+  return NULL_TREE;\n+}\n \n /* Deallocate memory used in copy propagation and do final\n    substitution.  */\n \n static void\n fini_copy_prop (void)\n {\n-  size_t i;\n-  prop_value_t *tmp;\n+  unsigned i;\n \n   /* Set the final copy-of value for each variable by traversing the\n      copy-of chains.  */\n-  tmp = XCNEWVEC (prop_value_t, num_ssa_names);\n   for (i = 1; i < num_ssa_names; i++)\n     {\n       tree var = ssa_name (i);\n@@ -839,26 +855,25 @@ fini_copy_prop (void)\n \t  || copy_of[i].value == var)\n \tcontinue;\n \n-      tmp[i].value = get_last_copy_of (var);\n+      copy_of[i].value = get_last_copy_of (var);\n \n       /* In theory the points-to solution of all members of the\n          copy chain is their intersection.  For now we do not bother\n \t to compute this but only make sure we do not lose points-to\n \t information completely by setting the points-to solution\n \t of the representative to the first solution we find if\n \t it doesn't have one already.  */\n-      if (tmp[i].value != var\n+      if (copy_of[i].value != var\n \t  && POINTER_TYPE_P (TREE_TYPE (var))\n \t  && SSA_NAME_PTR_INFO (var)\n-\t  && !SSA_NAME_PTR_INFO (tmp[i].value))\n-\tduplicate_ssa_name_ptr_info (tmp[i].value, SSA_NAME_PTR_INFO (var));\n+\t  && !SSA_NAME_PTR_INFO (copy_of[i].value))\n+\tduplicate_ssa_name_ptr_info (copy_of[i].value, SSA_NAME_PTR_INFO (var));\n     }\n \n-  substitute_and_fold (tmp, NULL, true);\n+  substitute_and_fold (get_value, NULL, true);\n \n   free (cached_last_copy_of);\n   free (copy_of);\n-  free (tmp);\n }\n \n "}, {"sha": "e08d2e7ae0cd5341233eeac77d456dd01575477f", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "patch": "@@ -872,7 +872,7 @@ static struct prop_stats_d prop_stats;\n    PROP_VALUE. Return true if at least one reference was replaced.  */\n \n static bool\n-replace_uses_in (gimple stmt, prop_value_t *prop_value)\n+replace_uses_in (gimple stmt, ssa_prop_get_value_fn get_value)\n {\n   bool replaced = false;\n   use_operand_p use;\n@@ -881,7 +881,7 @@ replace_uses_in (gimple stmt, prop_value_t *prop_value)\n   FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n       tree tuse = USE_FROM_PTR (use);\n-      tree val = prop_value[SSA_NAME_VERSION (tuse)].value;\n+      tree val = (*get_value) (tuse);\n \n       if (val == tuse || val == NULL_TREE)\n \tcontinue;\n@@ -911,7 +911,7 @@ replace_uses_in (gimple stmt, prop_value_t *prop_value)\n    values from PROP_VALUE.  */\n \n static void\n-replace_phi_args_in (gimple phi, prop_value_t *prop_value)\n+replace_phi_args_in (gimple phi, ssa_prop_get_value_fn get_value)\n {\n   size_t i;\n   bool replaced = false;\n@@ -928,7 +928,7 @@ replace_phi_args_in (gimple phi, prop_value_t *prop_value)\n \n       if (TREE_CODE (arg) == SSA_NAME)\n \t{\n-\t  tree val = prop_value[SSA_NAME_VERSION (arg)].value;\n+\t  tree val = (*get_value) (arg);\n \n \t  if (val && val != arg && may_propagate_copy (arg, val))\n \t    {\n@@ -978,29 +978,82 @@ replace_phi_args_in (gimple phi, prop_value_t *prop_value)\n    Return TRUE when something changed.  */\n \n bool\n-substitute_and_fold (prop_value_t *prop_value, ssa_prop_fold_stmt_fn fold_fn,\n+substitute_and_fold (ssa_prop_get_value_fn get_value_fn,\n+\t\t     ssa_prop_fold_stmt_fn fold_fn,\n \t\t     bool do_dce)\n {\n   basic_block bb;\n   bool something_changed = false;\n+  unsigned i;\n \n-  if (prop_value == NULL && !fold_fn)\n+  if (!get_value_fn && !fold_fn)\n     return false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nSubstituting values and folding statements\\n\\n\");\n \n   memset (&prop_stats, 0, sizeof (prop_stats));\n \n-  /* Substitute values in every statement of every basic block.  */\n+  /* Substitute lattice values at definition sites.  */\n+  if (get_value_fn)\n+    for (i = 1; i < num_ssa_names; ++i)\n+      {\n+\ttree name = ssa_name (i);\n+\ttree val;\n+\tgimple def_stmt;\n+\tgimple_stmt_iterator gsi;\n+\n+\tif (!name\n+\t    || !is_gimple_reg (name))\n+\t  continue;\n+\n+\tdef_stmt = SSA_NAME_DEF_STMT (name);\n+\tif (gimple_nop_p (def_stmt)\n+\t    /* Do not substitute ASSERT_EXPR rhs, this will confuse VRP.  */\n+\t    || (gimple_assign_single_p (def_stmt)\n+\t\t&& gimple_assign_rhs_code (def_stmt) == ASSERT_EXPR)\n+\t    || !(val = (*get_value_fn) (name))\n+\t    || !may_propagate_copy (name, val))\n+\t  continue;\n+\n+\tgsi = gsi_for_stmt (def_stmt);\n+\tif (is_gimple_assign (def_stmt))\n+\t  {\n+\t    gimple_assign_set_rhs_with_ops (&gsi, TREE_CODE (val),\n+\t\t\t\t\t    val, NULL_TREE);\n+\t    gcc_assert (gsi_stmt (gsi) == def_stmt);\n+\t    if (maybe_clean_eh_stmt (def_stmt))\n+\t      gimple_purge_dead_eh_edges (gimple_bb (def_stmt));\n+\t    update_stmt (def_stmt);\n+\t  }\n+\telse if (is_gimple_call (def_stmt))\n+\t  {\n+\t    if (update_call_from_tree (&gsi, val)\n+\t\t&& maybe_clean_or_replace_eh_stmt (def_stmt, gsi_stmt (gsi)))\n+\t      gimple_purge_dead_eh_edges (gimple_bb (gsi_stmt (gsi)));\n+\t  }\n+\telse if (gimple_code (def_stmt) == GIMPLE_PHI)\n+\t  {\n+\t    gimple new_stmt = gimple_build_assign (name, val);\n+\t    gimple_stmt_iterator gsi2;\n+\t    SSA_NAME_DEF_STMT (name) = new_stmt;\n+\t    gsi2 = gsi_after_labels (gimple_bb (def_stmt));\n+\t    gsi_insert_before (&gsi2, new_stmt, GSI_SAME_STMT);\n+\t    remove_phi_node (&gsi, false);\n+\t  }\n+\n+\tsomething_changed = true;\n+      }\n+\n+  /* Propagate into all uses and fold.  */\n   FOR_EACH_BB (bb)\n     {\n       gimple_stmt_iterator i;\n \n       /* Propagate known values into PHI nodes.  */\n-      if (prop_value)\n+      if (get_value_fn)\n \tfor (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))\n-\t  replace_phi_args_in (gsi_stmt (i), prop_value);\n+\t  replace_phi_args_in (gsi_stmt (i), get_value_fn);\n \n       /* Propagate known values into stmts.  Do a backward walk to expose\n \t more trivially deletable stmts.  */\n@@ -1073,9 +1126,9 @@ substitute_and_fold (prop_value_t *prop_value, ssa_prop_fold_stmt_fn fold_fn,\n \n \t  /* Only replace real uses if we couldn't fold the\n \t     statement using value range information.  */\n-\t  if (prop_value\n+\t  if (get_value_fn\n \t      && !did_replace)\n-\t    did_replace |= replace_uses_in (stmt, prop_value);\n+\t    did_replace |= replace_uses_in (stmt, get_value_fn);\n \n \t  /* If we made a replacement, fold the statement.  */\n \t  if (did_replace)"}, {"sha": "778f650d030715d8c71b35d0953beaa2185bb629", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 2, "deletions": 47, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "patch": "@@ -61,56 +61,11 @@ enum ssa_prop_result {\n };\n \n \n-struct prop_value_d {\n-    /* Lattice value.  Each propagator is free to define its own\n-       lattice and this field is only meaningful while propagating.\n-       It will not be used by substitute_and_fold.  */\n-    unsigned lattice_val;\n-\n-    /* Propagated value.  */\n-    tree value;\n-};\n-\n-typedef struct prop_value_d prop_value_t;\n-\n-\n-/* Type of value ranges.  See value_range_d for a description of these\n-   types.  */\n-enum value_range_type { VR_UNDEFINED, VR_RANGE, VR_ANTI_RANGE, VR_VARYING };\n-\n-/* Range of values that can be associated with an SSA_NAME after VRP\n-   has executed.  */\n-struct value_range_d\n-{\n-  /* Lattice value represented by this range.  */\n-  enum value_range_type type;\n-\n-  /* Minimum and maximum values represented by this range.  These\n-     values should be interpreted as follows:\n-\n-\t- If TYPE is VR_UNDEFINED or VR_VARYING then MIN and MAX must\n-\t  be NULL.\n-\n-\t- If TYPE == VR_RANGE then MIN holds the minimum value and\n-\t  MAX holds the maximum value of the range [MIN, MAX].\n-\n-\t- If TYPE == ANTI_RANGE the variable is known to NOT\n-\t  take any values in the range [MIN, MAX].  */\n-  tree min;\n-  tree max;\n-\n-  /* Set of SSA names whose value ranges are equivalent to this one.\n-     This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */\n-  bitmap equiv;\n-};\n-\n-typedef struct value_range_d value_range_t;\n-\n-\n /* Call-back functions used by the value propagation engine.  */\n typedef enum ssa_prop_result (*ssa_prop_visit_stmt_fn) (gimple, edge *, tree *);\n typedef enum ssa_prop_result (*ssa_prop_visit_phi_fn) (gimple);\n typedef bool (*ssa_prop_fold_stmt_fn) (gimple_stmt_iterator *gsi);\n+typedef tree (*ssa_prop_get_value_fn) (tree);\n \n \n /* In tree-ssa-propagate.c  */\n@@ -119,6 +74,6 @@ bool valid_gimple_rhs_p (tree);\n void move_ssa_defining_stmt_for_defs (gimple, gimple);\n bool update_call_from_tree (gimple_stmt_iterator *, tree);\n bool stmt_makes_single_store (gimple);\n-bool substitute_and_fold (prop_value_t *, ssa_prop_fold_stmt_fn, bool);\n+bool substitute_and_fold (ssa_prop_get_value_fn, ssa_prop_fold_stmt_fn, bool);\n \n #endif /* _TREE_SSA_PROPAGATE_H  */"}, {"sha": "35d12b309ddb76a839ae2d4820f8bdc0ad33cf75", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455e6d5ba7c8c2501cad22f3ecee229cc130b87f/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=455e6d5ba7c8c2501cad22f3ecee229cc130b87f", "patch": "@@ -42,6 +42,38 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-chrec.h\"\n \n \n+/* Type of value ranges.  See value_range_d for a description of these\n+   types.  */\n+enum value_range_type { VR_UNDEFINED, VR_RANGE, VR_ANTI_RANGE, VR_VARYING };\n+\n+/* Range of values that can be associated with an SSA_NAME after VRP\n+   has executed.  */\n+struct value_range_d\n+{\n+  /* Lattice value represented by this range.  */\n+  enum value_range_type type;\n+\n+  /* Minimum and maximum values represented by this range.  These\n+     values should be interpreted as follows:\n+\n+\t- If TYPE is VR_UNDEFINED or VR_VARYING then MIN and MAX must\n+\t  be NULL.\n+\n+\t- If TYPE == VR_RANGE then MIN holds the minimum value and\n+\t  MAX holds the maximum value of the range [MIN, MAX].\n+\n+\t- If TYPE == ANTI_RANGE the variable is known to NOT\n+\t  take any values in the range [MIN, MAX].  */\n+  tree min;\n+  tree max;\n+\n+  /* Set of SSA names whose value ranges are equivalent to this one.\n+     This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */\n+  bitmap equiv;\n+};\n+\n+typedef struct value_range_d value_range_t;\n+\n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n static sbitmap *live;\n@@ -7526,8 +7558,6 @@ static void\n vrp_finalize (void)\n {\n   size_t i;\n-  prop_value_t *single_val_range;\n-  bool do_value_subst_p;\n   unsigned num = num_ssa_names;\n \n   if (dump_file)\n@@ -7537,31 +7567,8 @@ vrp_finalize (void)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  /* We may have ended with ranges that have exactly one value.  Those\n-     values can be substituted as any other const propagated\n-     value using substitute_and_fold.  */\n-  single_val_range = XCNEWVEC (prop_value_t, num);\n-\n-  do_value_subst_p = false;\n-  for (i = 0; i < num; i++)\n-    if (vr_value[i]\n-\t&& vr_value[i]->type == VR_RANGE\n-\t&& vr_value[i]->min == vr_value[i]->max\n-\t&& is_gimple_min_invariant (vr_value[i]->min))\n-      {\n-\tsingle_val_range[i].value = vr_value[i]->min;\n-\tdo_value_subst_p = true;\n-      }\n-\n-  if (!do_value_subst_p)\n-    {\n-      /* We found no single-valued ranges, don't waste time trying to\n-\t do single value substitution in substitute_and_fold.  */\n-      free (single_val_range);\n-      single_val_range = NULL;\n-    }\n-\n-  substitute_and_fold (single_val_range, vrp_fold_stmt, false);\n+  substitute_and_fold (op_with_constant_singleton_value_range,\n+\t\t       vrp_fold_stmt, false);\n \n   if (warn_array_bounds)\n     check_all_array_refs ();\n@@ -7578,7 +7585,6 @@ vrp_finalize (void)\n \tfree (vr_value[i]);\n       }\n \n-  free (single_val_range);\n   free (vr_value);\n   free (vr_phi_edge_counts);\n "}]}