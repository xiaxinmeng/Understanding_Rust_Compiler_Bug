{"sha": "e9dd4c3e048450ef944455cd1e9440bee024d0f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlkZDRjM2UwNDg0NTBlZjk0NDQ1NWNkMWU5NDQwYmVlMDI0ZDBmOA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-05-28T12:17:42Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-05-28T12:17:42Z"}, "message": "i386.c (ix86_expand_vector_move): Expand unaligned memory access via x86_expand_vector_move_misalign() only for...\n\n\t* target/i386/i386.c (ix86_expand_vector_move): Expand unaligned\n\tmemory access via x86_expand_vector_move_misalign() only for\n\tTImode values on 32-bit targets.\n\nFrom-SVN: r125129", "tree": {"sha": "9e71824a6f8fff8b20bed9ad39cbe614d6d3e834", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e71824a6f8fff8b20bed9ad39cbe614d6d3e834"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9dd4c3e048450ef944455cd1e9440bee024d0f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9dd4c3e048450ef944455cd1e9440bee024d0f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9dd4c3e048450ef944455cd1e9440bee024d0f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9dd4c3e048450ef944455cd1e9440bee024d0f8/comments", "author": null, "committer": null, "parents": [{"sha": "ae5dd5f579538ba4f64f628b716019e01f887f2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae5dd5f579538ba4f64f628b716019e01f887f2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae5dd5f579538ba4f64f628b716019e01f887f2c"}], "stats": {"total": 24, "additions": 15, "deletions": 9}, "files": [{"sha": "355293dd63101c408f00234b255f4b9a83e21502", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9dd4c3e048450ef944455cd1e9440bee024d0f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9dd4c3e048450ef944455cd1e9440bee024d0f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9dd4c3e048450ef944455cd1e9440bee024d0f8", "patch": "@@ -1,13 +1,19 @@\n+2007-05-28  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* target/i386/i386.c (ix86_expand_vector_move): Expand unaligned\n+\tmemory access via x86_expand_vector_move_misalign() only for\n+\tTImode values on 32-bit targets.\n+\t\n 2007-05-28  Razya Ladelsky  <razya@il.ibm.com>  \n         \n-        * matrix-reorg.c: New file. Implement matrix flattening and transposing\n-\t    optimization.\n-        * tree-pass.h: Add matrix reorg pass.\n-        * common.opt: Add fipa-mreorg flag.\n-        * Makefile.in: Add matrix-reorg.c.\n-        * passes.c: Add matrix reorg pass.\n-\t  * varpool.c (add_new_static_var): New function.\n-\t  * cgraph.h (add_new_static_var): Declare.\n+\t* matrix-reorg.c: New file. Implement matrix flattening and\n+\ttransposing optimization.\n+\t* tree-pass.h: Add matrix reorg pass.\n+\t* common.opt: Add fipa-mreorg flag.\n+\t* Makefile.in: Add matrix-reorg.c.\n+\t* passes.c: Add matrix reorg pass.\n+\t* varpool.c (add_new_static_var): New function.\n+\t* cgraph.h (add_new_static_var): Declare.\n \n \n 2007-05-27  Eric Christopher  <echristo@apple.com>"}, {"sha": "f68dc6aabd29d6448929631ddb510dac74183a79", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9dd4c3e048450ef944455cd1e9440bee024d0f8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9dd4c3e048450ef944455cd1e9440bee024d0f8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e9dd4c3e048450ef944455cd1e9440bee024d0f8", "patch": "@@ -9746,7 +9746,7 @@ ix86_expand_vector_move (enum machine_mode mode, rtx operands[])\n      unaligned memory access.  Use ix86_expand_vector_move_misalign()\n      if memory operand is not aligned correctly.  */\n   if (!no_new_pseudos\n-      && SSE_REG_MODE_P (mode)\n+      && (mode == TImode) && !TARGET_64BIT\n       && ((MEM_P (op0) && (MEM_ALIGN (op0) < align))\n \t  || (MEM_P (op1) && (MEM_ALIGN (op1) < align))))\n     {"}]}