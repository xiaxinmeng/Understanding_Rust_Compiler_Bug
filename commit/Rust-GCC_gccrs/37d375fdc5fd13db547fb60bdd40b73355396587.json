{"sha": "37d375fdc5fd13db547fb60bdd40b73355396587", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdkMzc1ZmRjNWZkMTNkYjU0N2ZiNjBiZGQ0MGI3MzM1NTM5NjU4Nw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-07-16T00:31:27Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-07-16T00:31:27Z"}, "message": "Initial revision\n\nFrom-SVN: r102075", "tree": {"sha": "ed80c7de91726768a42b235beffbaf622dc2553e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed80c7de91726768a42b235beffbaf622dc2553e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37d375fdc5fd13db547fb60bdd40b73355396587", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37d375fdc5fd13db547fb60bdd40b73355396587", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37d375fdc5fd13db547fb60bdd40b73355396587", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37d375fdc5fd13db547fb60bdd40b73355396587/comments", "author": null, "committer": null, "parents": [{"sha": "f911ba985aa7fe0096c386c5be385ac5825ea527", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f911ba985aa7fe0096c386c5be385ac5825ea527", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f911ba985aa7fe0096c386c5be385ac5825ea527"}], "stats": {"total": 5340, "additions": 5340, "deletions": 0}, "files": [{"sha": "282522db0342d8750454b3dc162493b5fc709cc8", "filename": "libjava/classpath/vm/.cvsignore", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2F.cvsignore?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,2 @@\n+Makefile\n+Makefile.in"}, {"sha": "d89e46883a3c4eb55a1cee1497a19998b4bb0c91", "filename": "libjava/classpath/vm/Makefile.am", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2FMakefile.am?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,4 @@\n+# used by automake to generate Makefile.in\n+\n+\n+SUBDIRS = reference"}, {"sha": "282522db0342d8750454b3dc162493b5fc709cc8", "filename": "libjava/classpath/vm/reference/.cvsignore", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2F.cvsignore?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,2 @@\n+Makefile\n+Makefile.in"}, {"sha": "84b0350444d48849605e8629bc67cec95242d7fc", "filename": "libjava/classpath/vm/reference/Makefile.am", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2FMakefile.am?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,3 @@\n+# used by automake to generate Makefile.in\n+\n+SUBDIRS = java gnu"}, {"sha": "28e4ce36443a79e2075016eb460f2e5b78833f43", "filename": "libjava/classpath/vm/reference/gnu/classpath/VMStackWalker.java", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fclasspath%2FVMStackWalker.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fclasspath%2FVMStackWalker.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fclasspath%2FVMStackWalker.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,108 @@\n+/* VMStackWalker.java -- Reference implementation of VM hooks for stack access\n+   Copyright (C) 2005 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.classpath;\n+\n+/**\n+ * This class provides access to the classes on the Java stack\n+ * for reflection and security purposes.\n+ *\n+ * <p>\n+ * This class is only available to privileged code (i.e., code loaded\n+ * by the bootstrap loader).\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @author Archie Cobbs\n+ */\n+public final class VMStackWalker\n+{\n+  /**\n+   * Get a list of all the classes currently executing methods on the\n+   * Java stack. <code>getClassContext()[0]</code> is the class associated\n+   * with the currently executing method, i.e., the method that called\n+   * <code>VMStackWalker.getClassContext()</code> (possibly through\n+   * reflection). So you may need to pop off these stack frames from\n+   * the top of the stack:\n+   * <ul>\n+   * <li><code>VMStackWalker.getClassContext()</code>\n+   * <li><code>Method.invoke()</code>\n+   * </ul>\n+   *\n+   * @return an array of the declaring classes of each stack frame\n+   */\n+  public static native Class[] getClassContext();\n+\n+  /**\n+   * Get the class associated with the method invoking the method\n+   * invoking this method, or <code>null</code> if the stack is not\n+   * that deep (e.g., invoked via JNI invocation API). This method\n+   * is an optimization for the expression <code>getClassContext()[1]</code>\n+   * and should return the same result.\n+   *\n+   * <p>\n+   * VM implementers are encouraged to provide a more efficient\n+   * version of this method.\n+   */\n+  public static Class getCallingClass()\n+  {\n+    Class[] ctx = getClassContext();\n+    if (ctx.length < 3)\n+      return null;\n+    return ctx[2];\n+  }\n+\n+  /**\n+   * Get the class loader associated with the Class returned by\n+   * <code>getCallingClass()</code>, or <code>null</code> if no\n+   * such class exists or it is the boot loader. This method is an optimization\n+   * for the expression <code>getClassContext()[1].getClassLoader()</code>\n+   * and should return the same result.\n+   *\n+   * <p>\n+   * VM implementers are encouraged to provide a more efficient\n+   * version of this method.\n+   */\n+  public static ClassLoader getCallingClassLoader()\n+  {\n+    Class[] ctx = getClassContext();\n+    if (ctx.length < 3)\n+      return null;\n+    return ctx[2].getClassLoader();\n+  }\n+}\n+"}, {"sha": "e7cb91fde70ca3172aa3c66e01e03632807fe4ae", "filename": "libjava/classpath/vm/reference/gnu/classpath/VMSystemProperties.java", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fclasspath%2FVMSystemProperties.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fclasspath%2FVMSystemProperties.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fclasspath%2FVMSystemProperties.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,97 @@\n+/* VMSystemProperties.java -- Allow the VM to set System properties.\n+   Copyright (C) 2004 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.classpath;\n+\n+import java.util.Properties;\n+\n+class VMSystemProperties\n+{\n+    /**\n+     * Get the system properties. This is done here, instead of in System,\n+     * because of the bootstrap sequence. Note that the native code should\n+     * not try to use the Java I/O classes yet, as they rely on the properties\n+     * already existing. The only safe method to use to insert these default\n+     * system properties is {@link Properties#setProperty(String, String)}.\n+     *\n+     * <p>These properties MUST include:\n+     * <dl>\n+     * <dt>java.version         <dd>Java version number\n+     * <dt>java.vendor          <dd>Java vendor specific string\n+     * <dt>java.vendor.url      <dd>Java vendor URL\n+     * <dt>java.home            <dd>Java installation directory\n+     * <dt>java.vm.specification.version <dd>VM Spec version\n+     * <dt>java.vm.specification.vendor  <dd>VM Spec vendor\n+     * <dt>java.vm.specification.name    <dd>VM Spec name\n+     * <dt>java.vm.version      <dd>VM implementation version\n+     * <dt>java.vm.vendor       <dd>VM implementation vendor\n+     * <dt>java.vm.name         <dd>VM implementation name\n+     * <dt>java.specification.version    <dd>Java Runtime Environment version\n+     * <dt>java.specification.vendor     <dd>Java Runtime Environment vendor\n+     * <dt>java.specification.name       <dd>Java Runtime Environment name\n+     * <dt>java.class.version   <dd>Java class version number\n+     * <dt>java.class.path      <dd>Java classpath\n+     * <dt>java.library.path    <dd>Path for finding Java libraries\n+     * <dt>java.io.tmpdir       <dd>Default temp file path\n+     * <dt>java.compiler        <dd>Name of JIT to use\n+     * <dt>java.ext.dirs        <dd>Java extension path\n+     * <dt>os.name              <dd>Operating System Name\n+     * <dt>os.arch              <dd>Operating System Architecture\n+     * <dt>os.version           <dd>Operating System Version\n+     * <dt>file.separator       <dd>File separator (\"/\" on Unix)\n+     * <dt>path.separator       <dd>Path separator (\":\" on Unix)\n+     * <dt>line.separator       <dd>Line separator (\"\\n\" on Unix)\n+     * <dt>user.name            <dd>User account name\n+     * <dt>user.home            <dd>User home directory\n+     * <dt>user.dir             <dd>User's current working directory\n+     * <dt>gnu.cpu.endian       <dd>\"big\" or \"little\"\n+     * </dl>\n+     *\n+     * @param p the Properties object to insert the system properties into\n+     */\n+    static native void preInit(Properties properties);\n+\n+    /**\n+     * Here you get a chance to overwrite some of the properties set by\n+     * the common SystemProperties code. For example, it might be\n+     * a good idea to process the properties specified on the command\n+     * line here.\n+     */\n+    static void postInit(Properties properties)\n+    {\n+    }\n+}"}, {"sha": "11dd2aa7b4b151ac3e6cb750e46c010ac287d35f", "filename": "libjava/classpath/vm/reference/gnu/java/nio/VMPipe.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fjava%2Fnio%2FVMPipe.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fjava%2Fnio%2FVMPipe.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fjava%2Fnio%2FVMPipe.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,64 @@\n+/* VMPipe.java -- Reference implementation for VM hooks used by PipeImpl\n+   Copyright (C) 2004 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.io.IOException;\n+import java.nio.channels.spi.SelectorProvider;\n+import gnu.classpath.Configuration;\n+\n+/**\n+ * This class contains the native methods for gnu.java.nio.PipeImpl\n+ * As such, it needs help from the VM.\n+ *\n+ * @author Patrik Reali\n+ */\n+final class VMPipe\n+{\n+\n+  static\n+  {\n+    // load the shared library needed for native methods.\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+        System.loadLibrary (\"javanio\");\n+      }\n+  }\n+\n+  static native void init(PipeImpl self, SelectorProvider provider)\n+    throws IOException;\n+}"}, {"sha": "488132d24c2483097b6e2e47d4c0620fa702815e", "filename": "libjava/classpath/vm/reference/gnu/java/nio/VMSelector.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fjava%2Fnio%2FVMSelector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fjava%2Fnio%2FVMSelector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fgnu%2Fjava%2Fnio%2FVMSelector.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,59 @@\n+/* VMSelector.java -- \n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import gnu.classpath.Configuration;\n+import java.io.IOException;\n+\n+public final class VMSelector\n+{\n+  static\n+  {\n+    // load the shared library needed for native methods.\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+        System.loadLibrary (\"javanio\");\n+      }\n+  }\n+  \n+  // A timeout value of 0 means block forever.\n+  static native int select (int[] read, int[] write,\n+                                        int[] except, long timeout)\n+    throws IOException;\n+\n+}"}, {"sha": "2931044c85376a337bfe06d720000a4bfe0ebc8b", "filename": "libjava/classpath/vm/reference/java/io/VMFile.java", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fio%2FVMFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fio%2FVMFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fio%2FVMFile.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,229 @@\n+/* VMFile.java -- Class for methods natively accessing files\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.io;\n+\n+import gnu.classpath.Configuration;\n+import gnu.java.io.PlatformHelper;\n+\n+\n+/**\n+ * @author Michael Koch (konqueror@gmx.de)\n+ */\n+final class VMFile\n+{\n+  // FIXME: We support only case sensitive filesystems currently.\n+  static final boolean IS_CASE_SENSITIVE = true;\n+  static final boolean IS_DOS_8_3 = false;\n+\n+  static\n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+\tSystem.loadLibrary(\"javaio\");\n+      }\n+  }\n+\n+  /*\n+   * This native method does the actual work of getting the last file\n+   * modification time.  It also does the existence check to avoid the\n+   * overhead of a call to exists()\n+   */\n+  static native long lastModified(String path);\n+\n+  /*\n+   * This native method sets the permissions to make the file read only.\n+   */\n+  static native boolean setReadOnly(String path);\n+\n+  /**\n+   * This method is used to create a temporary file\n+   */\n+  static native boolean create(String path) throws IOException;\n+\n+  /*\n+   * This native function actually produces the list of file in this\n+   * directory\n+   */\n+  static native String[] list(String dirpath);\n+\n+  /*\n+   * This native method actually performs the rename.\n+   */\n+  static native boolean renameTo(String targetpath, String destpath);\n+\n+  /*\n+   * This native method actually determines the length of the file and\n+   * handles the existence check\n+   */\n+  static native long length(String path);\n+\n+  /*\n+   * This native method does the actual checking of file existence.\n+   */\n+  static native boolean exists(String path);\n+\n+  /*\n+   * This native method handles the actual deleting of the file\n+   */\n+  static native boolean delete(String path);\n+\n+  /*\n+   * This method does the actual setting of the modification time.\n+   */\n+  static native boolean setLastModified(String path, long time);\n+\n+  /*\n+   * This native method actually creates the directory\n+   */\n+  static native boolean mkdir(String dirpath);\n+\n+  /*\n+   * This native method does the actual check of whether or not a file\n+   * is a plain file or not.  It also handles the existence check to\n+   * eliminate the overhead of a call to exists()\n+   */\n+  static native boolean isFile(String path);\n+\n+  /**\n+   * This native method checks file permissions for writing\n+   */\n+  static synchronized native boolean canWrite(String path);\n+\n+  /**\n+   * This methods checks if a directory can be written to.\n+   */\n+  static boolean canWriteDirectory(File dir)\n+  {\n+    try\n+      {\n+        String filename = IS_DOS_8_3 ? \"tst\" : \"test-dir-write\";\n+        File test = File.createTempFile(filename, null, dir);\n+        return (test != null && test.delete());\n+      }\n+    catch (IOException ioe)\n+      {\n+        return false;\n+      }\n+  }\n+\n+  /**\n+   * This native method checks file permissions for reading\n+   */\n+  static synchronized native boolean canRead(String path);\n+\n+  /*\n+   * This method does the actual check of whether or not a file is a\n+   * directory or not.  It also handle the existence check to eliminate\n+   * the overhead of a call to exists()\n+   */\n+  static native boolean isDirectory(String dirpath);\n+\n+  /**\n+   * This method returns an array of filesystem roots.  Some operating systems\n+   * have volume oriented filesystem.  This method provides a mechanism for\n+   * determining which volumes exist.  GNU systems use a single hierarchical\n+   * filesystem, so will have only one \"/\" filesystem root.\n+   *\n+   * @return An array of <code>File</code> objects for each filesystem root\n+   * available.\n+   *\n+   * @since 1.2\n+   */\n+  static File[] listRoots()\n+  {\n+\tFile[] roots = new File[1];\n+\troots[0] = new File(\"/\");\n+\treturn roots;\n+  }\n+\n+  /**\n+   * This method tests whether or not this file represents a \"hidden\" file.\n+   * On GNU systems, a file is hidden if its name begins with a \".\"\n+   * character.  Files with these names are traditionally not shown with\n+   * directory listing tools.\n+   *\n+   * @return <code>true</code> if the file is hidden, <code>false</code>\n+   * otherwise.\n+   *\n+   * @since 1.2\n+   */\n+  static boolean isHidden(String path)\n+  {\n+\t// FIXME: this only works on UNIX\n+\treturn getName(path).startsWith(\".\");\n+  }\n+\n+  /**\n+   * This method returns the name of the file.  This is everything in the\n+   * complete path of the file after the last instance of the separator\n+   * string.\n+   *\n+   * @return The file name\n+   */\n+  static String getName(String path)\n+  {\n+\tint pos = PlatformHelper.lastIndexOfSeparator(path);\n+\tif (pos == -1)\n+\t  return path;\n+\t\n+\tif (PlatformHelper.endWithSeparator(path))\n+\t  return \"\";\n+\t\n+\treturn path.substring(pos + File.separator.length());\n+  }\n+\n+  /**\n+   * This method returns a canonical representation of the pathname of\n+   * the given path.  The actual form of the canonical representation is\n+   * different.  On the GNU system, the canonical form differs from the\n+   * absolute form in that all relative file references to \".\" and \"..\"\n+   * are resolved and removed.\n+   * <p>\n+   * Note that this method, unlike the other methods which return path\n+   * names, can throw an IOException.  This is because native method \n+   * might be required in order to resolve the canonical path\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public static String toCanonicalForm(String path) throws IOException\n+  {\n+\t// FIXME: this only works on UNIX\n+\treturn PlatformHelper.toCanonicalForm(path);\n+  }\n+}"}, {"sha": "7cd97192e7419097cf076b8876d90e0f3b771c09", "filename": "libjava/classpath/vm/reference/java/io/VMObjectInputStream.java", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fio%2FVMObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fio%2FVMObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fio%2FVMObjectInputStream.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,86 @@\n+/* ObjectInputStream.java -- Class used to read serialized objects\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2005\n+   Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.io;\n+\n+import gnu.classpath.VMStackWalker;\n+import java.lang.reflect.Constructor;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+final class VMObjectInputStream\n+{\n+  private static Class oisClass = ObjectInputStream.class;\n+  private static Class vmoisClass = VMObjectInputStream.class;\n+\n+  // PrivilegedAction needed for Class.getClassLoader()\n+  private static PrivilegedAction loaderAction = new PrivilegedAction()\n+    {\n+      public Object run()\n+      {\n+\tClass[] ctx = VMStackWalker.getClassContext();\n+\tfor (int i = 0; i < ctx.length; i++)\n+\t  {\n+\t    ClassLoader cl = ctx[i].getClassLoader();\n+\t    if (cl != null)\n+\t      return cl;\n+\t  }\n+\treturn null;\n+      }\n+    };\n+\n+  /**\n+   * Returns the first user defined class loader on the call stack, or\n+   * null when no non-null class loader was found.\n+   */\n+  static ClassLoader currentClassLoader()\n+  {\n+    return (ClassLoader) AccessController.doPrivileged(loaderAction);\n+  }\n+\n+  /**\n+   * Allocates a new Object of type clazz but without running the\n+   * default constructor on it. It then calls the given constructor on\n+   * it. The given constructor method comes from the constr_clazz\n+   * which is a super class of the given clazz.\n+   */\n+  static native Object allocateObject(Class clazz, Class constr_clazz,\n+\t\t\t\t      Constructor constructor)\n+    throws InstantiationException;\n+}"}, {"sha": "2aee7a9e6a70a7dbdac926a0882e7abf67452137", "filename": "libjava/classpath/vm/reference/java/io/VMObjectStreamClass.java", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fio%2FVMObjectStreamClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fio%2FVMObjectStreamClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fio%2FVMObjectStreamClass.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,160 @@\n+/* VMObjectStreamClass.java -- VM helper functions for ObjectStreamClass\n+   Copyright (C) 2003  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.io;\n+\n+import java.lang.reflect.Field;\n+\n+final class VMObjectStreamClass\n+{\n+  /**\n+    * Returns true if CLAZZ has a static class initializer\n+    * (a.k.a. <clinit>).\n+    */\n+  static native boolean hasClassInitializer (Class clazz);\n+\n+  /**\n+   * Sets the value of the specified field. This method handles \"double\".\n+   * Warning ! The types are not truely checked here and final values may be\n+   * assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setDoubleNative(Field field, Object obj, double val)\n+    throws InternalError;\n+\n+  /**\n+   * Sets the value of the specified field. This method handles \"float\".\n+   * Warning ! The types are not truely checked here and final values may be\n+   * assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setFloatNative(Field field, Object obj, float val)\n+    throws InternalError;\n+\n+  /**\n+   * Sets the value of the specified field. This method handles \"long\".\n+   * Warning ! The types are not truely checked here and final values may be\n+   * assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setLongNative(Field field, Object obj, long val)\n+    throws InternalError;\n+  \n+  /**\n+   * Sets the value of the specified field. This method handles \"int\".\n+   * Warning ! The types are not truely checked here and final values may be\n+   * assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setIntNative(Field field, Object obj, int val) \n+    throws InternalError;\n+  \n+  /**\n+   * Sets the value of the specified field. This method handles \"short\".\n+   * Warning ! The types are not truely checked here and final values may be\n+   * assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setShortNative(Field field, Object obj, short val) \n+    throws InternalError;\n+\n+  /**\n+   * Sets the value of the specified field. This method handles \"char\".\n+   * Warning ! The types are not truely checked here and final values may be\n+   * assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setCharNative(Field field, Object obj, char val) \n+    throws InternalError;\n+\n+  /**\n+   * Sets the value of the specified field. This method handles \"byte\".\n+   * Warning ! The types are not truely checked here and final values may be\n+   * assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setByteNative(Field field, Object obj, byte val) \n+    throws InternalError;\n+\n+  /**\n+   * Sets the value of the specified field. This method handles \"boolean\".\n+   * Warning ! The types are not truely checked here and final values may be\n+   * assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setBooleanNative(Field field, Object obj, boolean val) \n+    throws InternalError;\n+\n+  /**\n+   * Sets the value of the specified field. This method handles \"object\".\n+   * Warning ! The types are not truely checked here and final values may be\n+   * assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setObjectNative(Field field, Object obj, Object val) \n+    throws InternalError;\n+  \n+}\n+"}, {"sha": "0ca0329ba3002d7a640883932b7a8e6333803e88", "filename": "libjava/classpath/vm/reference/java/lang/VMClass.java", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMClass.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,295 @@\n+/* VMClass.java -- VM Specific Class methods\n+   Copyright (C) 2003, 2004 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+/*\n+ * This class is a reference version, mainly for compiling a class library\n+ * jar.  It is likely that VM implementers replace this with their own\n+ * version that can communicate effectively with the VM.\n+ */\n+\n+/**\n+ *\n+ * @author Etienne Gagnon <etienne.gagnon@uqam.ca>\n+ * @author Archie Cobbs <archie@dellroad.org>\n+ * @author C. Brian Jones <cbj@gnu.org>\n+ */\n+final class VMClass \n+{\n+\n+  // Only static methods. Cannot be instantiated.\n+  private VMClass()\n+  {\n+  }\n+\n+  /**\n+   * Discover whether an Object is an instance of this Class.  Think of it\n+   * as almost like <code>o instanceof (this class)</code>.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @param o the Object to check\n+   * @return whether o is an instance of this class\n+   * @since 1.1\n+   */\n+  static native boolean isInstance(Class klass, Object o);\n+\n+  /**\n+   * Discover whether an instance of the Class parameter would be an\n+   * instance of this Class as well.  Think of doing\n+   * <code>isInstance(c.newInstance())</code> or even\n+   * <code>c.newInstance() instanceof (this class)</code>. While this\n+   * checks widening conversions for objects, it must be exact for primitive\n+   * types.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @param c the class to check\n+   * @return whether an instance of c would be an instance of this class\n+   *         as well\n+   * @throws NullPointerException if c is null\n+   * @since 1.1\n+   */\n+  static native boolean isAssignableFrom(Class klass, Class c);\n+\n+  /**\n+   * Check whether this class is an interface or not.  Array types are not\n+   * interfaces.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @return whether this class is an interface or not\n+   */\n+  static native boolean isInterface(Class klass);\n+\n+  /**\n+   * Return whether this class is a primitive type.  A primitive type class\n+   * is a class representing a kind of \"placeholder\" for the various\n+   * primitive types, or void.  You can access the various primitive type\n+   * classes through java.lang.Boolean.TYPE, java.lang.Integer.TYPE, etc.,\n+   * or through boolean.class, int.class, etc.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @return whether this class is a primitive type\n+   * @see Boolean#TYPE\n+   * @see Byte#TYPE\n+   * @see Character#TYPE\n+   * @see Short#TYPE\n+   * @see Integer#TYPE\n+   * @see Long#TYPE\n+   * @see Float#TYPE\n+   * @see Double#TYPE\n+   * @see Void#TYPE\n+   * @since 1.1\n+   */\n+  static native boolean isPrimitive(Class klass);\n+\n+  /**\n+   * Get the name of this class, separated by dots for package separators.\n+   * Primitive types and arrays are encoded as:\n+   * <pre>\n+   * boolean             Z\n+   * byte                B\n+   * char                C\n+   * short               S\n+   * int                 I\n+   * long                J\n+   * float               F\n+   * double              D\n+   * void                V\n+   * array type          [<em>element type</em>\n+   * class or interface, alone: &lt;dotted name&gt;\n+   * class or interface, as element type: L&lt;dotted name&gt;;\n+   *\n+   * @param klass the Class object that's calling us\n+   * @return the name of this class\n+   */\n+  static native String getName(Class klass);\n+\n+  /**\n+   * Get the direct superclass of this class.  If this is an interface,\n+   * Object, a primitive type, or void, it will return null. If this is an\n+   * array type, it will return Object.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @return the direct superclass of this class\n+   */\n+  static native Class getSuperclass(Class klass);\n+\n+  /**\n+   * Get the interfaces this class <EM>directly</EM> implements, in the\n+   * order that they were declared. This returns an empty array, not null,\n+   * for Object, primitives, void, and classes or interfaces with no direct\n+   * superinterface. Array types return Cloneable and Serializable.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @return the interfaces this class directly implements\n+   */\n+  static native Class[] getInterfaces(Class klass);\n+\n+  /**\n+   * If this is an array, get the Class representing the type of array.\n+   * Examples: \"[[Ljava.lang.String;\" would return \"[Ljava.lang.String;\", and\n+   * calling getComponentType on that would give \"java.lang.String\".  If\n+   * this is not an array, returns null.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @return the array type of this class, or null\n+   * @see Array\n+   * @since 1.1\n+   */\n+  static native Class getComponentType(Class klass);\n+\n+  /**\n+   * Get the modifiers of this class.  These can be decoded using Modifier,\n+   * and is limited to one of public, protected, or private, and any of\n+   * final, static, abstract, or interface. An array class has the same\n+   * public, protected, or private modifier as its component type, and is\n+   * marked final but not an interface. Primitive types and void are marked\n+   * public and final, but not an interface.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @param ignoreInnerClassesAttrib if set, return the real modifiers, not\n+   * the ones specified in the InnerClasses attribute.\n+   * @return the modifiers of this class\n+   * @see Modifer\n+   * @since 1.1\n+   */\n+  static native int getModifiers(Class klass, boolean ignoreInnerClassesAttrib);\n+\n+  /**\n+   * If this is a nested or inner class, return the class that declared it.\n+   * If not, return null.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @return the declaring class of this class\n+   * @since 1.1\n+   */\n+  static native Class getDeclaringClass(Class klass);\n+\n+  /**\n+   * Like <code>getDeclaredClasses()</code> but without the security checks.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @param pulicOnly Only public classes should be returned\n+   */\n+  static native Class[] getDeclaredClasses(Class klass, boolean publicOnly);\n+\n+  /**\n+   * Like <code>getDeclaredFields()</code> but without the security checks.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @param pulicOnly Only public fields should be returned\n+   */\n+  static native Field[] getDeclaredFields(Class klass, boolean publicOnly);\n+\n+  /**\n+   * Like <code>getDeclaredMethods()</code> but without the security checks.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @param pulicOnly Only public methods should be returned\n+   */\n+  static native Method[] getDeclaredMethods(Class klass, boolean publicOnly);\n+\n+  /**\n+   * Like <code>getDeclaredConstructors()</code> but without\n+   * the security checks.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @param pulicOnly Only public constructors should be returned\n+   */\n+  static native Constructor[] getDeclaredConstructors(Class klass, boolean publicOnly);\n+\n+  /**\n+   * Return the class loader of this class.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @return the class loader\n+   */\n+  static native ClassLoader getClassLoader(Class klass);\n+\n+  /**\n+   * VM implementors are free to make this method a noop if \n+   * the default implementation is acceptable.\n+   *\n+   * @param name the name of the class to find\n+   * @return the Class object representing the class or null for noop\n+   * @throws ClassNotFoundException if the class was not found by the\n+   *         classloader\n+   * @throws LinkageError if linking the class fails\n+   * @throws ExceptionInInitializerError if the class loads, but an exception\n+   *         occurs during initialization\n+   */\n+  static native Class forName(String name) throws ClassNotFoundException;\n+\n+  /**\n+   * Return whether this class is an array type.\n+   *\n+   * @param klass the Class object that's calling us\n+   * @return true if this class is an array type\n+   * operation\n+   */\n+  static native boolean isArray(Class klass);\n+\n+  /**\n+   * This method should trigger class initialization (if the\n+   * class hasn't already been initialized)\n+   * \n+   * @param klass the Class object that's calling us\n+   * @throws ExceptionInInitializerError if an exception\n+   *         occurs during initialization\n+   */\n+  static native void initialize(Class klass);\n+\n+  /**\n+   * Load an array class.\n+   *\n+   * @return the Class object representing the class\n+   * @throws ClassNotFoundException if the class was not found by the\n+   *         classloader\n+   */\n+  static native Class loadArrayClass(String name, ClassLoader classloader)\n+\tthrows ClassNotFoundException;\n+\n+  /**\n+   * Throw a checked exception without declaring it.\n+   */\n+  static native void throwException(Throwable t);\n+\n+} // class VMClass"}, {"sha": "c62f0a4d98ef007abb732265aabab16388743462", "filename": "libjava/classpath/vm/reference/java/lang/VMClassLoader.java", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMClassLoader.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,285 @@\n+/* VMClassLoader.java -- Reference implementation of native interface\n+   required by ClassLoader\n+   Copyright (C) 1998, 2001, 2002, 2004, 2005 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.lang;\n+\n+import gnu.classpath.SystemProperties;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.security.ProtectionDomain;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+import java.util.Vector;\n+import java.util.zip.ZipFile;\n+\n+/**\n+ * java.lang.VMClassLoader is a package-private helper for VMs to implement\n+ * on behalf of java.lang.ClassLoader.\n+ *\n+ * @author John Keiser\n+ * @author Mark Wielaard (mark@klomp.org)\n+ * @author Eric Blake (ebb9@email.byu.edu)\n+ */\n+final class VMClassLoader\n+{\n+  /**\n+   * Helper to define a class using a string of bytes. This assumes that\n+   * the security checks have already been performed, if necessary.\n+   *\n+   * Implementations of this method are advised to consider the\n+   * situation where user code modifies the byte array after it has\n+   * been passed to defineClass.  This can be handled by making a\n+   * private copy of the array, or arranging to only read any given\n+   * byte a single time.\n+   *\n+   * @param name the name to give the class, or null if unknown\n+   * @param data the data representing the classfile, in classfile format\n+   * @param offset the offset into the data where the classfile starts\n+   * @param len the length of the classfile data in the array\n+   * @param pd the protection domain\n+   * @return the class that was defined\n+   * @throws ClassFormatError if data is not in proper classfile format\n+   */\n+  static final native Class defineClass(ClassLoader cl, String name,\n+                                 byte[] data, int offset, int len,\n+                                 ProtectionDomain pd)\n+    throws ClassFormatError;\n+\n+  /**\n+   * Helper to resolve all references to other classes from this class.\n+   *\n+   * @param c the class to resolve\n+   */\n+  static final native void resolveClass(Class c);\n+\n+  /**\n+   * Helper to load a class from the bootstrap class loader.\n+   *\n+   * @param name the class name to load\n+   * @param resolve whether to resolve it\n+   * @return the class, loaded by the bootstrap classloader or null\n+   * if the class wasn't found. Returning null is equivalent to throwing\n+   * a ClassNotFoundException (but a possible performance optimization).\n+   */\n+  static final native Class loadClass(String name, boolean resolve)\n+    throws ClassNotFoundException;\n+\n+  /**\n+   * Helper to load a resource from the bootstrap class loader.\n+   *\n+   * @param name the resource to find\n+   * @return the URL to the resource\n+   */\n+  static URL getResource(String name)\n+  {\n+    Enumeration e = getResources(name);\n+    if (e.hasMoreElements())\n+      return (URL)e.nextElement();\n+    return null;\n+  }\n+\n+  /**\n+   * Helper to get a list of resources from the bootstrap class loader.\n+   *\n+   * @param name the resource to find\n+   * @return an enumeration of resources\n+   * @throws IOException if one occurs\n+   */\n+  static Enumeration getResources(String name)\n+  {\n+    StringTokenizer st = new StringTokenizer(\n+      SystemProperties.getProperty(\"java.boot.class.path\", \".\"),\n+      File.pathSeparator);\n+    Vector v = new Vector();\n+    while (st.hasMoreTokens())\n+      {\n+\tFile file = new File(st.nextToken());\n+\tif (file.isDirectory())\n+\t  {\n+\t    try\n+\t      {\n+\t\tv.add(new URL(\"file://\"\n+\t\t  + new File(file, name).getAbsolutePath()));\n+\t      }\n+\t    catch (MalformedURLException e)\n+\t      {\n+\t\tthrow new Error(e);\n+\t      }\n+\t  }\n+\telse if (file.isFile())\n+\t  {\n+\t    ZipFile zip;\n+\t    try\n+\t      {\n+\t\tzip = new ZipFile(file);\n+\t      }\n+\t    catch (IOException e)\n+\t      {\n+\t\tcontinue;\n+\t      }\n+\t    String zname = name.startsWith(\"/\") ? name.substring(1) : name;\n+\t    try\n+\t      {\n+\t\tif (zip.getEntry(zname) == null)\n+\t\t    continue;\n+\t      }\n+\t    finally\n+\t      {\n+\t\ttry\n+\t\t  {\n+\t\t    zip.close();\n+\t\t  }\n+\t\tcatch (IOException e)\n+\t\t  {\n+\t\t  }\n+\t      }\n+\t    try\n+\t      {\n+\t\tv.add(new URL(\"jar:file://\"\n+\t\t  + file.getAbsolutePath() + \"!/\" + zname));\n+\t      }\n+\t    catch (MalformedURLException e)\n+\t      {\n+\t\tthrow new Error(e);\n+\t      }\n+\t  }\n+      }\n+    return v.elements();\n+  }\n+\n+  /**\n+   * Helper to get a package from the bootstrap class loader.  The default\n+   * implementation of returning null may be adequate, or you may decide\n+   * that this needs some native help.\n+   *\n+   * @param name the name to find\n+   * @return the named package, if it exists\n+   */\n+  static Package getPackage(String name)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Helper to get all packages from the bootstrap class loader.  The default\n+   * implementation of returning an empty array may be adequate, or you may\n+   * decide that this needs some native help.\n+   *\n+   * @return all named packages, if any exist\n+   */\n+  static Package[] getPackages()\n+  {\n+    return new Package[0];\n+  }\n+\n+  /**\n+   * Helper for java.lang.Integer, Byte, etc to get the TYPE class\n+   * at initialization time. The type code is one of the chars that\n+   * represents the primitive type as in JNI.\n+   *\n+   * <ul>\n+   * <li>'Z' - boolean</li>\n+   * <li>'B' - byte</li>\n+   * <li>'C' - char</li>\n+   * <li>'D' - double</li>\n+   * <li>'F' - float</li>\n+   * <li>'I' - int</li>\n+   * <li>'J' - long</li>\n+   * <li>'S' - short</li>\n+   * <li>'V' - void</li>\n+   * </ul>\n+   *\n+   * @param type the primitive type\n+   * @return a \"bogus\" class representing the primitive type\n+   */\n+  static final native Class getPrimitiveClass(char type);\n+\n+  /**\n+   * The system default for assertion status. This is used for all system\n+   * classes (those with a null ClassLoader), as well as the initial value for\n+   * every ClassLoader's default assertion status.\n+   *\n+   * XXX - Not implemented yet; this requires native help.\n+   *\n+   * @return the system-wide default assertion status\n+   */\n+  static final boolean defaultAssertionStatus()\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * The system default for package assertion status. This is used for all\n+   * ClassLoader's packageAssertionStatus defaults. It must be a map of\n+   * package names to Boolean.TRUE or Boolean.FALSE, with the unnamed package\n+   * represented as a null key.\n+   *\n+   * XXX - Not implemented yet; this requires native help.\n+   *\n+   * @return a (read-only) map for the default packageAssertionStatus\n+   */\n+  static final Map packageAssertionStatus()\n+  {\n+    return new HashMap();\n+  }\n+\n+  /**\n+   * The system default for class assertion status. This is used for all\n+   * ClassLoader's classAssertionStatus defaults. It must be a map of\n+   * class names to Boolean.TRUE or Boolean.FALSE\n+   *\n+   * XXX - Not implemented yet; this requires native help.\n+   *\n+   * @return a (read-only) map for the default classAssertionStatus\n+   */\n+  static final Map classAssertionStatus()\n+  {\n+    return new HashMap();\n+  }\n+\n+  static ClassLoader getSystemClassLoader()\n+  {\n+    return ClassLoader.defaultGetSystemClassLoader();\n+  }\n+}"}, {"sha": "fe7400756712ebf174c270a9efdbfb37641077a3", "filename": "libjava/classpath/vm/reference/java/lang/VMCompiler.java", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMCompiler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMCompiler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMCompiler.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,112 @@\n+/* VMClassLoader.java -- Reference implementation of compiler interface\n+   Copyright (C) 2004 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+/**\n+ * This class is just a per-VM reflection of java.lang.Compiler.\n+ * All methods are defined identically.\n+ */\n+final class VMCompiler\n+{\n+  /**\n+   * Don't allow new `Compiler's to be made.\n+   */\n+  private VMCompiler()\n+  {\n+  }\n+\n+  /**\n+   * Compile the class named by <code>oneClass</code>.\n+   *\n+   * @param oneClass the class to compile\n+   * @return <code>false</code> if no compiler is available or\n+   *         compilation failed, <code>true</code> if compilation succeeded\n+   * @throws NullPointerException if oneClass is null\n+   */\n+  public static boolean compileClass(Class oneClass)\n+  {\n+    // Never succeed.\n+    return false;\n+  }\n+\n+  /**\n+   * Compile the classes whose name matches <code>classNames</code>.\n+   *\n+   * @param classNames the name of classes to compile\n+   * @return <code>false</code> if no compiler is available or\n+   *         compilation failed, <code>true</code> if compilation succeeded\n+   * @throws NullPointerException if classNames is null\n+   */\n+  public static boolean compileClasses(String classNames)\n+  {\n+    // Note the incredibly lame interface.  Always fail.\n+    return false;\n+  }\n+\n+  /**\n+   * This method examines the argument and performs an operation\n+   * according to the compilers documentation.  No specific operation\n+   * is required.\n+   *\n+   * @param arg a compiler-specific argument\n+   * @return a compiler-specific value, including null\n+   * @throws NullPointerException if the compiler doesn't like a null arg\n+   */\n+  public static Object command(Object arg)\n+  {\n+    // Our implementation defines this to a no-op.\n+    return null;\n+  }\n+\n+  /**\n+   * Calling <code>Compiler.enable()</code> will cause the compiler\n+   * to resume operation if it was previously disabled; provided that a\n+   * compiler even exists.\n+   */\n+  public static void enable()\n+  {\n+  }\n+\n+  /**\n+   * Calling <code>Compiler.disable()</code> will cause the compiler\n+   * to be suspended; provided that a compiler even exists.\n+   */\n+  public static void disable()\n+  {\n+  }\n+}"}, {"sha": "8a991c9ad787154d1f8bcf5c0a783784967ae385", "filename": "libjava/classpath/vm/reference/java/lang/VMDouble.java", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMDouble.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMDouble.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMDouble.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,131 @@\n+/* VMDouble.java -- VM Specific Double methods\n+   Copyright (C) 2003, 2005  Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+import gnu.classpath.Configuration;\n+\n+/*\n+ * This class is a reference version, mainly for compiling a class library\n+ * jar.  It is likely that VM implementers replace this with their own\n+ * version that can communicate effectively with the VM.\n+ */\n+\n+/**\n+ * Code relocated from java.lang.Double by \n+ * @author Dave Grove (groved@us.ibm.com)\n+ */\n+final class VMDouble\n+{\n+\n+  /**\n+   * Load native routines necessary for this class.\n+   */\n+  static\n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+\tSystem.loadLibrary(\"javalang\");\n+      }\n+\n+    initIDs();\n+  }\n+\n+  /**\n+   * Convert the double to the IEEE 754 floating-point \"double format\" bit\n+   * layout. Bit 63 (the most significant) is the sign bit, bits 62-52\n+   * (masked by 0x7ff0000000000000L) represent the exponent, and bits 51-0\n+   * (masked by 0x000fffffffffffffL) are the mantissa. This function\n+   * collapses all versions of NaN to 0x7ff8000000000000L. The result of this\n+   * function can be used as the argument to\n+   * <code>Double.longBitsToDouble(long)</code> to obtain the original\n+   * <code>double</code> value.\n+   *\n+   * @param value the <code>double</code> to convert\n+   * @return the bits of the <code>double</code>\n+   * @see #longBitsToDouble(long)\n+   */\n+  public static native long doubleToLongBits(double value);\n+\n+  /**\n+   * Convert the double to the IEEE 754 floating-point \"double format\" bit\n+   * layout. Bit 63 (the most significant) is the sign bit, bits 62-52\n+   * (masked by 0x7ff0000000000000L) represent the exponent, and bits 51-0\n+   * (masked by 0x000fffffffffffffL) are the mantissa. This function\n+   * leaves NaN alone, rather than collapsing to a canonical value. The\n+   * result of this function can be used as the argument to\n+   * <code>Double.longBitsToDouble(long)</code> to obtain the original\n+   * <code>double</code> value.\n+   *\n+   * @param value the <code>double</code> to convert\n+   * @return the bits of the <code>double</code>\n+   * @see #longBitsToDouble(long)\n+   */\n+  public static native long doubleToRawLongBits(double value);\n+\n+  /**\n+   * Convert the argument in IEEE 754 floating-point \"double format\" bit\n+   * layout to the corresponding float. Bit 63 (the most significant) is the\n+   * sign bit, bits 62-52 (masked by 0x7ff0000000000000L) represent the\n+   * exponent, and bits 51-0 (masked by 0x000fffffffffffffL) are the mantissa.\n+   * This function leaves NaN alone, so that you can recover the bit pattern\n+   * with <code>Double.doubleToRawLongBits(double)</code>.\n+   *\n+   * @param bits the bits to convert\n+   * @return the <code>double</code> represented by the bits\n+   * @see #doubleToLongBits(double)\n+   * @see #doubleToRawLongBits(double)\n+   */\n+  public static native double longBitsToDouble(long bits);\n+\n+  /**\n+   * Helper method to convert to string.\n+   *\n+   * @param d the double to convert\n+   * @param isFloat true if the conversion is requested by Float (results in\n+   *        fewer digits)\n+   */\n+  public static native String toString(double d, boolean isFloat);\n+\n+  /**\n+   * Initialize JNI cache.  This method is called only by the\n+   * static initializer when using JNI.\n+   */\n+  public static native void initIDs();\n+\n+  public static native double parseDouble(String str);\n+}"}, {"sha": "2e7f439a443aa18bf45f4a4f91ab55a07f045d6b", "filename": "libjava/classpath/vm/reference/java/lang/VMFloat.java", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMFloat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMFloat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMFloat.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,111 @@\n+/* VMFloat.java -- VM Specific Float methods\n+   Copyright (C) 2003 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+import gnu.classpath.Configuration;\n+\n+/*\n+ * This class is a reference version, mainly for compiling a class library\n+ * jar.  It is likely that VM implementers replace this with their own\n+ * version that can communicate effectively with the VM.\n+ */\n+\n+/**\n+ * Code relocated from java.lang.Float by \n+ * @author Dave Grove <groved@us.ibm.com>\n+ */\n+final class VMFloat\n+{\n+\n+  /**\n+   * Load native routines necessary for this class.\n+   */\n+  static\n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+        System.loadLibrary(\"javalang\");\n+      }\n+  }\n+\n+  /**\n+   * Convert the float to the IEEE 754 floating-point \"single format\" bit\n+   * layout. Bit 31 (the most significant) is the sign bit, bits 30-23\n+   * (masked by 0x7f800000) represent the exponent, and bits 22-0\n+   * (masked by 0x007fffff) are the mantissa. This function collapses all\n+   * versions of NaN to 0x7fc00000. The result of this function can be used\n+   * as the argument to <code>Float.intBitsToFloat(int)</code> to obtain the\n+   * original <code>float</code> value.\n+   *\n+   * @param value the <code>float</code> to convert\n+   * @return the bits of the <code>float</code>\n+   * @see #intBitsToFloat(int)\n+   */\n+  static native int floatToIntBits(float value);\n+\n+  /**\n+   * Convert the float to the IEEE 754 floating-point \"single format\" bit\n+   * layout. Bit 31 (the most significant) is the sign bit, bits 30-23\n+   * (masked by 0x7f800000) represent the exponent, and bits 22-0\n+   * (masked by 0x007fffff) are the mantissa. This function leaves NaN alone,\n+   * rather than collapsing to a canonical value. The result of this function\n+   * can be used as the argument to <code>Float.intBitsToFloat(int)</code> to\n+   * obtain the original <code>float</code> value.\n+   *\n+   * @param value the <code>float</code> to convert\n+   * @return the bits of the <code>float</code>\n+   * @see #intBitsToFloat(int)\n+   */\n+  static native int floatToRawIntBits(float value);\n+\n+  /**\n+   * Convert the argument in IEEE 754 floating-point \"single format\" bit\n+   * layout to the corresponding float. Bit 31 (the most significant) is the\n+   * sign bit, bits 30-23 (masked by 0x7f800000) represent the exponent, and\n+   * bits 22-0 (masked by 0x007fffff) are the mantissa. This function leaves\n+   * NaN alone, so that you can recover the bit pattern with\n+   * <code>Float.floatToRawIntBits(float)</code>.\n+   *\n+   * @param bits the bits to convert\n+   * @return the <code>float</code> represented by the bits\n+   * @see #floatToIntBits(float)\n+   * @see #floatToRawIntBits(float)\n+   */\n+  static native float intBitsToFloat(int bits);\n+\n+} // class VMFloat"}, {"sha": "1d1ec40b511971bdc250a1ad12ed4e74d4ac239a", "filename": "libjava/classpath/vm/reference/java/lang/VMObject.java", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMObject.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,105 @@\n+/* VMObject.java -- Reference implementation for VM hooks used by Object\n+   Copyright (C) 1998, 2002, 2005  Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+/**\n+ * Object is the ultimate superclass of every class (excepting interfaces).\n+ * As such, it needs help from the VM.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake (ebb9@email.byu.edu)\n+ */\n+final class VMObject\n+{\n+  /**\n+   * Returns the runtime {@link Class} of a given Object.\n+   *\n+   * @param obj the object to return the class for.\n+   *\n+   * @return the class of the Object.\n+   */\n+  static native Class getClass(Object obj);\n+  \n+  /**\n+   * The VM is expected to make a field-for-field shallow copy of the\n+   * argument. Thus, the copy has the same runtime type as the argument.\n+   * Note, however, that the cloned object must still be finalizable, even\n+   * if the original has already had finalize() invoked on it.\n+   *\n+   * @param c the Cloneable to clone\n+   * @return the clone\n+   */\n+  static native Object clone(Cloneable c);\n+\n+  /**\n+   * Wakes up one of the threads that is waiting on this Object's monitor.\n+   * Only the owner of a lock on the Object may call this method. The Thread\n+   * to wake up is chosen arbitrarily.\n+   *\n+   * @param o the object doing the notify\n+   * @throw IllegalMonitorStateException if this Thread does not own the\n+   *        lock on the Object\n+   */\n+  static native void notify(Object o) throws IllegalMonitorStateException;\n+\n+  /**\n+   * Wakes up all of the threads waiting on this Object's monitor.  Only\n+   * the owner of the lock on this Object may call this method.\n+   *\n+   * @param o the object doing the notifyAll\n+   * @throws IllegalMonitorStateException if this Thread does not own the\n+   *         lock on the Object\n+   */\n+  static native void notifyAll(Object o) throws IllegalMonitorStateException;\n+\n+  /**\n+   * Waits a specified amount of time for notify() or notifyAll() to be\n+   * called on this Object.  The VM does not have to pay attention to the\n+   * ns argument, if it does not have that much granularity.\n+   *\n+   * @param o the object to suspend on\n+   * @param ms milliseconds to wait (1,000 milliseconds = 1 second)\n+   * @param ns nanoseconds to wait beyond ms (1,000,000 nanoseconds\n+   *        == 1 millisecond)\n+   * @throws IllegalMonitorStateException if this Thread does not own the\n+   *         lock on the Object\n+   * @throws InterruptedException if some other Thread interrupts this Thread\n+   */\n+  static native void wait(Object o, long ms, int ns)\n+    throws IllegalMonitorStateException, InterruptedException;\n+}"}, {"sha": "fa157d752e9491678b2cd694e5e81de02212b00e", "filename": "libjava/classpath/vm/reference/java/lang/VMProcess.java", "status": "added", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMProcess.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMProcess.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMProcess.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,368 @@\n+/* java.lang.VMProcess -- VM implementation of java.lang.Process\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+\n+/**\n+ * Represents one external process. Each instance of this class is in\n+ * one of three states: INITIAL, RUNNING, or TERMINATED. The instance\n+ * is {@link Object#notifyAll notifyAll()}'d each time the state changes.\n+ * The state of all instances is managed by a single dedicated thread\n+ * which does the actual fork()/exec() and wait() system calls. User\n+ * threads {@link Object#wait wait()} on the instance when creating the\n+ * process or waiting for it to terminate.\n+ *\n+ * <p>\n+ * See\n+ * <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11801\">GCC bug\n+ * #11801</a> for the motivation behind the design of this class.\n+ *\n+ * @author Archie Cobbs\n+ * @see Process\n+ * @see Runtime#exec\n+ */\n+final class VMProcess extends Process\n+{\n+\n+  // Possible states for a VMProcess\n+  private static final int INITIAL = 0;\n+  private static final int RUNNING = 1;\n+  private static final int TERMINATED = 2;\n+\n+  // Dedicated thread that does all the fork()'ing and wait()'ing.\n+  static Thread processThread;\n+\n+  // New processes waiting to be spawned by processThread.\n+  static final LinkedList workList = new LinkedList();\n+\n+  // Return values set by nativeReap() when a child is reaped.\n+  // These are only accessed by processThread so no locking required.\n+  static long reapedPid;\n+  static int reapedExitValue;\n+\n+  // Information about this process\n+  int state;\t\t\t\t       // current state of process\n+  final String[] cmd;\t\t\t       // copied from Runtime.exec()\n+  final String[] env;\t\t\t       // copied from Runtime.exec()\n+  final File dir;\t\t\t       // copied from Runtime.exec()\n+  Throwable exception;\t\t\t       // if process failed to start\n+  long pid;\t\t\t\t       // process id\n+  OutputStream stdin;\t\t\t       // process input stream\n+  InputStream stdout;\t\t\t       // process output stream\n+  InputStream stderr;\t\t\t       // process error stream\n+  int exitValue;\t\t\t       // process exit value\n+\n+  //\n+  // Dedicated thread that does all the fork()'ing and wait()'ing\n+  // for external processes. This is needed because some systems like\n+  // Linux use a process-per-thread model, which means the same thread\n+  // that did the fork()/exec() must also do the wait().\n+  //\n+  private static class ProcessThread extends Thread\n+  {\n+\n+    // Max time (in ms) we'll delay before trying to reap another child.\n+    private static final int MAX_REAP_DELAY = 1000;\n+\n+    // Processes created but not yet terminated; maps Long(pid) -> VMProcess\n+    // Only used in run() and spawn() method from this Thread, so no locking.\n+    private final HashMap activeMap = new HashMap();\n+\n+    // We have an explicit constructor, because the default\n+    // constructor will be private, which means the compiler will have\n+    // to generate a second package-private constructor, which is\n+    // bogus.\n+    ProcessThread ()\n+    {\n+    }\n+\n+    public void run()\n+    {\n+      final LinkedList workList = VMProcess.workList;\n+      while (true)\n+\t{\n+\n+\t  // Get the next process to spawn (if any) and spawn it. Spawn\n+\t  // at most one at a time before checking for reapable children.\n+\t  VMProcess process = null;\n+\t  synchronized (workList)\n+\t    {\n+\t      if (!workList.isEmpty())\n+\t\tprocess = (VMProcess)workList.removeFirst();\n+\t    }\n+\n+\t  if (process != null)\n+\t    spawn(process);\n+\n+\n+\t  // Check for termination of active child processes\n+\t  while (!activeMap.isEmpty() && VMProcess.nativeReap())\n+\t    {\n+\t      long pid = VMProcess.reapedPid;\n+\t      int exitValue = VMProcess.reapedExitValue;\n+\t      process = (VMProcess)activeMap.remove(new Long(pid));\n+\t      if (process != null)\n+\t\t{\n+\t\t  synchronized (process)\n+\t\t    {\n+\t\t      process.exitValue = exitValue;\n+\t\t      process.state = TERMINATED;\n+\t\t      process.notify();\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tSystem.err.println(\"VMProcess WARNING reaped unknown process: \"\n+\t\t\t\t   + pid);\n+\t    }\n+\n+\n+\t  // If there are more new processes to create, go do that now.\n+\t  // If there is nothing left to do, exit this thread. Otherwise,\n+\t  // sleep a little while, and then check again for reapable children.\n+\t  // We will get woken up immediately if there are new processes to\n+\t  // spawn, but not if there are new children to reap. So we only\n+\t  // sleep a short time, in effect polling while processes are active.\n+\t  synchronized (workList)\n+\t    {\n+\t      if (!workList.isEmpty())\n+\t\tcontinue;\n+\t      if (activeMap.isEmpty())\n+\t\t{\n+\t\t  processThread = null;\n+\t\t  break;\n+\t\t}\n+\t\n+\t      try\n+\t\t{\n+\t\t  workList.wait(MAX_REAP_DELAY);\n+\t\t}\n+\t      catch (InterruptedException e)\n+\t\t{\n+\t\t  /* ignore */\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    // Spawn a process\n+    private void spawn(VMProcess process)\n+    {\n+      \n+      // Spawn the process and put it in our active map indexed by pid.\n+      // If the spawn operation fails, store the exception with the process.\n+      // In either case, wake up thread that created the process.\n+      synchronized (process)\n+\t{\n+\t  try\n+\t    {\n+\t      process.nativeSpawn(process.cmd, process.env, process.dir);\n+\t      process.state = RUNNING;\n+\t      activeMap.put(new Long(process.pid), process);\n+\t    }\n+          catch (ThreadDeath death)\n+            {\n+              throw death;\n+            }\n+\t  catch (Throwable t)\n+\t    {\n+\t      process.state = TERMINATED;\n+\t      process.exception = t;\n+\t    }\n+\t  process.notify();\n+\t}\n+    }\n+  }\n+\n+  // Constructor\n+  private VMProcess(String[] cmd, String[] env, File dir) throws IOException\n+  {\n+    \n+    // Initialize this process\n+    this.state = INITIAL;\n+    this.cmd = cmd;\n+    this.env = env;\n+    this.dir = dir;\n+  \n+    // Add process to the new process work list and wakeup processThread\n+    synchronized (workList)\n+      {\n+\tworkList.add(this);\n+\tif (processThread == null)\n+\t  {\n+\t    processThread = new ProcessThread();\n+\t    processThread.setDaemon(true);\n+\t    processThread.start();\n+\t  }\n+\telse\n+\t  {\n+\t    workList.notify();\n+\t  }\n+      }\n+\n+    // Wait for processThread to spawn this process and update its state\n+    synchronized (this)\n+      {\n+\twhile (state == INITIAL)\n+\t  {\n+\t    try\n+\t      {\n+\t\twait();\n+\t      }\n+\t    catch (InterruptedException e)\n+\t      {\n+\t\t/* ignore */\n+\t      }\n+\t  }\n+      }\n+\n+    // If spawning failed, rethrow the exception in this thread\n+    if (exception != null)\n+      {\n+\texception.fillInStackTrace();\n+\tif (exception instanceof IOException)\n+\t  throw (IOException)exception;\n+\n+\tif (exception instanceof Error)\n+\t  throw (Error)exception;\n+\n+\tif (exception instanceof RuntimeException)\n+\t  throw (RuntimeException)exception;\n+\n+\tthrow new RuntimeException(exception);\n+      }\n+  }\n+\n+  // Invoked by native code (from nativeSpawn()) to record process info.\n+  private void setProcessInfo(OutputStream stdin,\n+                 InputStream stdout, InputStream stderr, long pid)\n+  {\n+    this.stdin = stdin;\n+    this.stdout = stdout;\n+    this.stderr = stderr;\n+    this.pid = pid;\n+  }\n+\n+  /**\n+   * Entry point from Runtime.exec().\n+   */\n+  static Process exec(String[] cmd, String[] env, File dir) throws IOException\n+  {\n+    return new VMProcess(cmd, env, dir);\n+  }\n+\n+  public OutputStream getOutputStream()\n+  {\n+    return stdin;\n+  }\n+\n+  public InputStream getInputStream()\n+  {\n+    return stdout;\n+  }\n+\n+  public InputStream getErrorStream()\n+  {\n+    return stderr;\n+  }\n+\n+  public synchronized int waitFor() throws InterruptedException\n+  {\n+    while (state != TERMINATED)\n+      wait();\n+    return exitValue;\n+  }\n+\n+  public synchronized int exitValue()\n+  {\n+    if (state != TERMINATED)\n+      throw new IllegalThreadStateException();\n+    return exitValue;\n+  }\n+\n+  public synchronized void destroy()\n+  {\n+    if (state == TERMINATED)\n+      return;\n+\n+    nativeKill(pid);\n+    \n+    while (state != TERMINATED)\n+      {\n+\ttry\n+\t  {\n+\t    wait();\n+\t  }\n+\tcatch (InterruptedException e)\n+\t  {\n+\t    /* ignore */\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Does the fork()/exec() thing to create the O/S process.\n+   * Must invoke setProcessInfo() before returning successfully.\n+   * This method is only invoked by processThread.\n+   *\n+   * @throws IOException if the O/S process could not be created.\n+   */\n+  native void nativeSpawn(String[] cmd, String[] env, File dir)\n+    throws IOException;\n+\n+  /**\n+   * Test for a reapable child process, and reap if so. Does not block.\n+   * If a child was reaped, this method must set reapedPid and\n+   * reapedExitValue appropriately before returning.\n+   * This method is only invoked by processThread.\n+   *\n+   * @return true if a child was reaped, otherwise false\n+   */\n+  // This is not private as it is called from an inner class.\n+  static native boolean nativeReap();\n+\n+  /**\n+   * Kill a process. This sends it a fatal signal but does not reap it.\n+   */\n+  private static native void nativeKill(long pid);\n+}"}, {"sha": "b685b351239e19e98ab21e7a4e65b4e83da02463", "filename": "libjava/classpath/vm/reference/java/lang/VMRuntime.java", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMRuntime.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMRuntime.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMRuntime.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,192 @@\n+/* VMRuntime.java -- VM interface to Runtime\n+   Copyright (C) 2003 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+/**\n+ * VMRuntime represents the interface to the Virtual Machine.\n+ *\n+ * @author Jeroen Frijters\n+ */\n+final class VMRuntime\n+{\n+    /**\n+     * No instance is ever created.\n+     */\n+    private VMRuntime() \n+    {\n+    }\n+\n+    /**\n+     * Returns the number of available processors currently available to the\n+     * virtual machine. This number may change over time; so a multi-processor\n+     * program want to poll this to determine maximal resource usage.\n+     *\n+     * @return the number of processors available, at least 1\n+     */\n+    static native int availableProcessors();\n+\n+    /**\n+     * Find out how much memory is still free for allocating Objects on the heap.\n+     *\n+     * @return the number of bytes of free memory for more Objects\n+     */\n+    static native long freeMemory();\n+\n+    /**\n+     * Find out how much memory total is available on the heap for allocating\n+     * Objects.\n+     *\n+     * @return the total number of bytes of memory for Objects\n+     */\n+    static native long totalMemory();\n+\n+    /**\n+     * Returns the maximum amount of memory the virtual machine can attempt to\n+     * use. This may be <code>Long.MAX_VALUE</code> if there is no inherent\n+     * limit (or if you really do have a 8 exabyte memory!).\n+     *\n+     * @return the maximum number of bytes the virtual machine will attempt\n+     *         to allocate\n+     */\n+    static native long maxMemory();\n+\n+    /**\n+     * Run the garbage collector. This method is more of a suggestion than\n+     * anything. All this method guarantees is that the garbage collector will\n+     * have \"done its best\" by the time it returns. Notice that garbage\n+     * collection takes place even without calling this method.\n+     */\n+    static native void gc();\n+\n+    /**\n+     * Run finalization on all Objects that are waiting to be finalized. Again,\n+     * a suggestion, though a stronger one than {@link #gc()}. This calls the\n+     * <code>finalize</code> method of all objects waiting to be collected.\n+     *\n+     * @see #finalize()\n+     */\n+    static native void runFinalization();\n+\n+    /**\n+     * Run finalization on all finalizable Objects (even live ones). This\n+     * should only be called immediately prior to VM termination.\n+     *\n+     * @see #finalize()\n+     */\n+    static native void runFinalizationForExit();\n+\n+    /**\n+     * Tell the VM to trace every bytecode instruction that executes (print out\n+     * a trace of it).  No guarantees are made as to where it will be printed,\n+     * and the VM is allowed to ignore this request.\n+     *\n+     * @param on whether to turn instruction tracing on\n+     */\n+    static native void traceInstructions(boolean on);\n+\n+    /**\n+     * Tell the VM to trace every method call that executes (print out a trace\n+     * of it).  No guarantees are made as to where it will be printed, and the\n+     * VM is allowed to ignore this request.\n+     *\n+     * @param on whether to turn method tracing on\n+     */\n+    static native void traceMethodCalls(boolean on);\n+\n+    /**\n+     * Native method that actually sets the finalizer setting.\n+     *\n+     * @param value whether to run finalizers on exit\n+     */\n+    static native void runFinalizersOnExit(boolean value);\n+\n+    /**\n+     * Native method that actually shuts down the virtual machine.\n+     *\n+     * @param status the status to end the process with\n+     */\n+    static native void exit(int status);\n+\n+    /**\n+     * Load a file. If it has already been loaded, do nothing. The name has\n+     * already been mapped to a true filename.\n+     *\n+     * @param filename the file to load\n+     * @param loader class loader, or <code>null</code> for the boot loader\n+     * @return 0 on failure, nonzero on success\n+     */\n+    static native int nativeLoad(String filename, ClassLoader loader);\n+\n+    /**\n+     * Map a system-independent \"short name\" to the full file name.\n+     *\n+     * @param libname the short version of the library name\n+     * @return the full filename\n+     */\n+    static native String mapLibraryName(String libname);\n+\n+    /**\n+     * Execute a process. The command line has already been tokenized, and\n+     * the environment should contain name=value mappings. If directory is null,\n+     * use the current working directory; otherwise start the process in that\n+     * directory.  If env is null, then the new process should inherit\n+     * the environment of this process.\n+     *\n+     * @param cmd the non-null command tokens\n+     * @param env the environment setup\n+     * @param dir the directory to use, may be null\n+     * @return the newly created process\n+     * @throws NullPointerException if cmd or env have null elements\n+     */\n+    static Process exec(String[] cmd, String[] env, File dir)\n+\tthrows IOException {\n+      return VMProcess.exec(cmd, env, dir);\n+    }\n+\n+    /**\n+     * This method is called by Runtime.addShutdownHook() when it is\n+     * called for the first time. It enables the VM to lazily setup\n+     * an exit handler, should it so desire.\n+     */\n+    static void enableShutdownHooks()\n+    {\n+    }\n+} // class VMRuntime"}, {"sha": "7e65eed98f7dc53caaee00e96272addcbbffab4a", "filename": "libjava/classpath/vm/reference/java/lang/VMString.java", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMString.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,91 @@\n+/* VMString.java -- VM Specific String methods\n+   Copyright (C) 2003 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.WeakHashMap;\n+\n+/*\n+ * This class is a reference version, mainly for compiling a class library\n+ * jar.  It is likely that VM implementers replace this with their own\n+ * version that can communicate effectively with the VM.\n+ */\n+\n+/**\n+ * Code relocated from java.lang.String by \n+ * @author Dave Grove <groved@us.ibm.com>\n+ */\n+final class VMString\n+{\n+\n+  /**\n+   * Holds the references for each intern()'d String. If all references to\n+   * the string disappear, and the VM properly supports weak references,\n+   * the String will be GC'd.\n+   */\n+  private static final WeakHashMap internTable = new WeakHashMap();\n+\n+  /**\n+   * Fetches this String from the intern hashtable. If two Strings are\n+   * considered equal, by the equals() method, then intern() will return the\n+   * same String instance. ie. if (s1.equals(s2)) then\n+   * (s1.intern() == s2.intern()). All string literals and string-valued\n+   * constant expressions are already interned.\n+   *\n+   * @param str the String to intern\n+   * @return the interned String\n+   */\n+  static String intern(String str)\n+  {\n+    synchronized (internTable)\n+      {\n+        WeakReference ref = (WeakReference) internTable.get(str);\n+        if (ref != null)\n+          {\n+            String s = (String) ref.get();\n+            // If s is null, then no strong references exist to the String;\n+            // the weak hash map will soon delete the key.\n+            if (s != null)\n+              return s;\n+          }\n+        internTable.put(str, new WeakReference(str));\n+      }\n+    return str;\n+  }\n+\n+} // class VMString"}, {"sha": "70f9dbac2672d2e00432ceb88fbfec5d63f2809c", "filename": "libjava/classpath/vm/reference/java/lang/VMSystem.java", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMSystem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMSystem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMSystem.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,181 @@\n+/* VMSystem.java -- helper for java.lang.system\n+   Copyright (C) 1998, 2002, 2004 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+\n+/**\n+ * VMSystem is a package-private helper class for System that the\n+ * VM must implement.\n+ *\n+ * @author John Keiser\n+ */\n+final class VMSystem\n+{\n+  /**\n+   * Copy one array onto another from <code>src[srcStart]</code> ...\n+   * <code>src[srcStart+len-1]</code> to <code>dest[destStart]</code> ...\n+   * <code>dest[destStart+len-1]</code>. First, the arguments are validated:\n+   * neither array may be null, they must be of compatible types, and the\n+   * start and length must fit within both arrays. Then the copying starts,\n+   * and proceeds through increasing slots.  If src and dest are the same\n+   * array, this will appear to copy the data to a temporary location first.\n+   * An ArrayStoreException in the middle of copying will leave earlier\n+   * elements copied, but later elements unchanged.\n+   *\n+   * @param src the array to copy elements from\n+   * @param srcStart the starting position in src\n+   * @param dest the array to copy elements to\n+   * @param destStart the starting position in dest\n+   * @param len the number of elements to copy\n+   * @throws NullPointerException if src or dest is null\n+   * @throws ArrayStoreException if src or dest is not an array, if they are\n+   *         not compatible array types, or if an incompatible runtime type\n+   *         is stored in dest\n+   * @throws IndexOutOfBoundsException if len is negative, or if the start or\n+   *         end copy position in either array is out of bounds\n+   */\n+  static native void arraycopy(Object src, int srcStart,\n+                               Object dest, int destStart, int len);\n+\n+  /**\n+   * Get a hash code computed by the VM for the Object. This hash code will\n+   * be the same as Object's hashCode() method.  It is usually some\n+   * convolution of the pointer to the Object internal to the VM.  It\n+   * follows standard hash code rules, in that it will remain the same for a\n+   * given Object for the lifetime of that Object.\n+   *\n+   * @param o the Object to get the hash code for\n+   * @return the VM-dependent hash code for this Object\n+   */\n+  static native int identityHashCode(Object o);\n+\n+  /**\n+   * Convert a library name to its platform-specific variant.\n+   *\n+   * @param libname the library name, as used in <code>loadLibrary</code>\n+   * @return the platform-specific mangling of the name\n+   * @XXX Add this method\n+  static native String mapLibraryName(String libname);\n+   */\n+\n+  /**\n+   * Set {@link #in} to a new InputStream.\n+   *\n+   * @param in the new InputStream\n+   * @see #setIn(InputStream)\n+   */\n+  static native void setIn(InputStream in);\n+\n+  /**\n+   * Set {@link #out} to a new PrintStream.\n+   *\n+   * @param out the new PrintStream\n+   * @see #setOut(PrintStream)\n+   */\n+  static native void setOut(PrintStream out);\n+\n+  /**\n+   * Set {@link #err} to a new PrintStream.\n+   *\n+   * @param err the new PrintStream\n+   * @see #setErr(PrintStream)\n+   */\n+  static native void setErr(PrintStream err);\n+\n+  /**\n+   * Get the current time, measured in the number of milliseconds from the\n+   * beginning of Jan. 1, 1970. This is gathered from the system clock, with\n+   * any attendant incorrectness (it may be timezone dependent).\n+   *\n+   * @return the current time\n+   * @see java.util.Date\n+   */\n+   public static native long currentTimeMillis();\n+\n+  /**\n+   * Helper method which creates the standard input stream.\n+   * VM implementors may choose to construct these streams differently.\n+   * This method can also return null if the stream is created somewhere \n+   * else in the VM startup sequence.\n+   */\n+\n+    static InputStream makeStandardInputStream()\n+    {\n+\treturn new BufferedInputStream(new FileInputStream(FileDescriptor.in));\n+    }\n+\n+  /**\n+   * Helper method which creates the standard output stream.\n+   * VM implementors may choose to construct these streams differently.\n+   * This method can also return null if the stream is created somewhere \n+   * else in the VM startup sequence.\n+   */\n+\n+    static PrintStream makeStandardOutputStream()\n+    {\n+\treturn new PrintStream(new BufferedOutputStream(new FileOutputStream(FileDescriptor.out)), true);\n+    }\n+  /**\n+   * Helper method which creates the standard error stream.\n+   * VM implementors may choose to construct these streams differently.\n+   * This method can also return null if the stream is created somewhere \n+   * else in the VM startup sequence.\n+   */\n+\n+    static PrintStream makeStandardErrorStream()\n+    {\n+\treturn new PrintStream(new BufferedOutputStream(new FileOutputStream(FileDescriptor.err)), true);\n+    }\n+\n+  /**\n+   * Gets the value of an environment variable.\n+   * Always returning null is a valid (but not very useful) implementation.\n+   *\n+   * @param name The name of the environment variable (will not be null).\n+   * @return The string value of the variable or null when the\n+   *         environment variable is not defined.\n+   */\n+  static native String getenv(String name);\n+}"}, {"sha": "6b9102b707118583e92b29f389d93ba6c56a46fa", "filename": "libjava/classpath/vm/reference/java/lang/VMThread.java", "status": "added", "additions": 450, "deletions": 0, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMThread.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,450 @@\n+/* VMThread -- VM interface for Thread of executable code\n+   Copyright (C) 2003, 2004, 2005 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+/**\n+ * VM interface for Thread of executable code. Holds VM dependent state.\n+ * It is deliberately package local and final and should only be accessed\n+ * by the Thread class.\n+ * <p>\n+ * This is the GNU Classpath reference implementation, it should be adapted\n+ * for a specific VM.\n+ * <p>\n+ * The following methods must be implemented:\n+ * <ul>\n+ * <li>native void start(long stacksize);\n+ * <li>native void interrupt();\n+ * <li>native boolean isInterrupted();\n+ * <li>native void suspend();\n+ * <li>native void resume();\n+ * <li>native void nativeSetPriority(int priority);\n+ * <li>native void nativeStop(Throwable t);\n+ * <li>native static Thread currentThread();\n+ * <li>static native void yield();\n+ * <li>static native boolean interrupted();\n+ * </ul>\n+ * All other methods may be implemented to make Thread handling more efficient\n+ * or to implement some optional (and sometimes deprecated) behaviour. Default\n+ * implementations are provided but it is highly recommended to optimize them\n+ * for a specific VM.\n+ * \n+ * @author Jeroen Frijters (jeroen@frijters.net)\n+ * @author Dalibor Topic (robilad@kaffe.org)\n+ */\n+final class VMThread\n+{\n+    /**\n+     * The Thread object that this VM state belongs to.\n+     * Used in currentThread() and start().\n+     * Note: when this thread dies, this reference is *not* cleared\n+     */\n+    volatile Thread thread;\n+\n+    /**\n+     * Flag that is set when the thread runs, used by stop() to protect against\n+     * stop's getting lost.\n+     */\n+    private volatile boolean running;\n+\n+    /**\n+     * VM private data.\n+     */\n+    private transient Object vmdata;\n+\n+    /**\n+     * Private constructor, create VMThreads with the static create method.\n+     *\n+     * @param thread The Thread object that was just created.\n+     */\n+    private VMThread(Thread thread)\n+    {\n+\tthis.thread = thread;\n+    }\n+\n+    /**\n+     * This method is the initial Java code that gets executed when a native\n+     * thread starts. It's job is to coordinate with the rest of the VMThread\n+     * logic and to start executing user code and afterwards handle clean up.\n+     */\n+    private void run()\n+    {\n+\ttry\n+\t{\n+\t    try\n+\t    {\n+\t\trunning = true;\n+\t\tsynchronized(thread)\n+\t\t{\n+\t\t    Throwable t = thread.stillborn;\n+\t\t    if(t != null)\n+\t\t    {\n+\t\t\tthread.stillborn = null;\n+\t\t\tthrow t;\n+\t\t    }\n+\t\t}\n+\t\tthread.run();\n+\t    }\n+\t    catch(Throwable t)\n+\t    {\n+\t\ttry\n+\t\t{\n+\t\t    thread.group.uncaughtException(thread, t);\n+\t\t}\n+\t\tcatch(Throwable ignore)\n+\t\t{\n+\t\t}\n+\t    }\n+\t}\n+\tfinally\n+\t{\n+\t    // Setting runnable to false is partial protection against stop\n+\t    // being called while we're cleaning up. To be safe all code in\n+\t    // VMThread be unstoppable.\n+\t    running = false;\n+\t    thread.die();\n+\t    synchronized(this)\n+\t    {\n+\t\t// release the threads waiting to join us\n+\t\tnotifyAll();\n+\t    }\n+\t}\n+    }\n+\n+    /**\n+     * Creates a native Thread. This is called from the start method of Thread.\n+     * The Thread is started.\n+     *\n+     * @param thread The newly created Thread object\n+     * @param stacksize Indicates the requested stacksize. Normally zero,\n+     * non-zero values indicate requested stack size in bytes but it is up\n+     * to the specific VM implementation to interpret them and may be ignored.\n+     */\n+    static void create(Thread thread, long stacksize)\n+    {\n+\tVMThread vmThread = new VMThread(thread);\n+\tvmThread.start(stacksize);\n+\tthread.vmThread = vmThread;\n+    }\n+\n+    /**\n+     * Gets the name of the thread. Usually this is the name field of the\n+     * associated Thread object, but some implementation might choose to\n+     * return the name of the underlying platform thread.\n+     */\n+    String getName()\n+    {\n+\treturn thread.name;\n+    }\n+\n+    /**\n+     * Set the name of the thread. Usually this sets the name field of the\n+     * associated Thread object, but some implementations might choose to\n+     * set the name of the underlying platform thread.\n+     * @param name The new name\n+     */\n+    void setName(String name)\n+    {\n+\tthread.name = name;\n+    }\n+\n+    /**\n+     * Set the thread priority field in the associated Thread object and\n+     * calls the native method to set the priority of the underlying\n+     * platform thread.\n+     * @param priority The new priority\n+     */\n+    void setPriority(int priority)\n+    {\n+\tthread.priority = priority;\n+\tnativeSetPriority(priority);\n+    }\n+\n+    /**\n+     * Returns the priority. Usually this is the priority field from the\n+     * associated Thread object, but some implementation might choose to\n+     * return the priority of the underlying platform thread.\n+     * @return this Thread's priority\n+     */\n+    int getPriority()\n+    {\n+        return thread.priority;\n+    }\n+\n+    /**\n+     * Returns true if the thread is a daemon thread. Usually this is the\n+     * daemon field from the associated Thread object, but some\n+     * implementation might choose to return the daemon state of the underlying\n+     * platform thread.\n+     * @return whether this is a daemon Thread or not\n+     */\n+    boolean isDaemon()\n+    {\n+        return thread.daemon;\n+    }\n+\n+    /**\n+     * Returns the number of stack frames in this Thread.\n+     * Will only be called when when a previous call to suspend() returned true.\n+     *\n+     * @deprecated unsafe operation\n+     */\n+    native int countStackFrames();\n+\n+    /**\n+     * Wait the specified amount of time for the Thread in question to die.\n+     *\n+     * <p>Note that 1,000,000 nanoseconds == 1 millisecond, but most VMs do\n+     * not offer that fine a grain of timing resolution. Besides, there is\n+     * no guarantee that this thread can start up immediately when time expires,\n+     * because some other thread may be active.  So don't expect real-time\n+     * performance.\n+     *\n+     * @param ms the number of milliseconds to wait, or 0 for forever\n+     * @param ns the number of extra nanoseconds to sleep (0-999999)\n+     * @throws InterruptedException if the Thread is interrupted; it's\n+     *         <i>interrupted status</i> will be cleared\n+     */\n+    synchronized void join(long ms, int ns) throws InterruptedException\n+    {\n+\t// Round up\n+\tms += (ns != 0) ? 1 : 0;\n+\n+\t// Compute end time, but don't overflow\n+\tlong now = System.currentTimeMillis();\n+\tlong end = now + ms;\n+\tif (end < now)\n+\t    end = Long.MAX_VALUE;\n+\n+\t// A VM is allowed to return from wait() without notify() having been\n+\t// called, so we loop to handle possible spurious wakeups.\n+\twhile(thread.vmThread != null)\n+\t{\n+\t    // We use the VMThread object to wait on, because this is a private\n+\t    // object, so client code cannot call notify on us.\n+\t    wait(ms);\n+\t    if(ms != 0)\n+\t    {\n+\t\tnow = System.currentTimeMillis();\n+\t\tms = end - now;\n+\t\tif(ms <= 0)\n+\t\t{\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    /**\n+     * Cause this Thread to stop abnormally and throw the specified exception.\n+     * If you stop a Thread that has not yet started, the stop is ignored\n+     * (contrary to what the JDK documentation says).\n+     * <b>WARNING</b>This bypasses Java security, and can throw a checked\n+     * exception which the call stack is unprepared to handle. Do not abuse \n+     * this power.\n+     *\n+     * <p>This is inherently unsafe, as it can interrupt synchronized blocks and\n+     * leave data in bad states.\n+     *\n+     * <p><b>NOTE</b> stop() should take care not to stop a thread if it is\n+     * executing code in this class.\n+     *\n+     * @param t the Throwable to throw when the Thread dies\n+     * @deprecated unsafe operation, try not to use\n+     */\n+    void stop(Throwable t)\n+    {\n+\t// Note: we assume that we own the lock on thread\n+\t// (i.e. that Thread.stop() is synchronized)\n+\tif(running)\n+\t    nativeStop(t);\n+\telse\n+\t    thread.stillborn = t;\n+    }\n+\n+    /**\n+     * Create a native thread on the underlying platform and start it executing\n+     * on the run method of this object.\n+     * @param stacksize the requested size of the native thread stack\n+     */\n+    native void start(long stacksize);\n+\n+    /**\n+     * Interrupt this thread.\n+     */\n+    native void interrupt();\n+\n+    /**\n+     * Determine whether this Thread has been interrupted, but leave\n+     * the <i>interrupted status</i> alone in the process.\n+     *\n+     * @return whether the Thread has been interrupted\n+     */\n+    native boolean isInterrupted();\n+\n+    /**\n+     * Suspend this Thread.  It will not come back, ever, unless it is resumed.\n+     */\n+    native void suspend();\n+\n+    /**\n+     * Resume this Thread.  If the thread is not suspended, this method does\n+     * nothing.\n+     */\n+    native void resume();\n+\n+    /**\n+     * Set the priority of the underlying platform thread.\n+     *\n+     * @param priority the new priority\n+     */\n+    native void nativeSetPriority(int priority);\n+\n+    /**\n+     * Asynchronously throw the specified throwable in this Thread.\n+     *\n+     * @param t the exception to throw\n+     */\n+    native void nativeStop(Throwable t);\n+\n+    /**\n+     * Return the Thread object associated with the currently executing\n+     * thread.\n+     *\n+     * @return the currently executing Thread\n+     */\n+    static native Thread currentThread();\n+\n+    /**\n+     * Yield to another thread. The Thread will not lose any locks it holds\n+     * during this time. There are no guarantees which thread will be\n+     * next to run, and it could even be this one, but most VMs will choose\n+     * the highest priority thread that has been waiting longest.\n+     */\n+    static native void yield();\n+\n+    /**\n+     * Suspend the current Thread's execution for the specified amount of\n+     * time. The Thread will not lose any locks it has during this time. There\n+     * are no guarantees which thread will be next to run, but most VMs will\n+     * choose the highest priority thread that has been waiting longest.\n+     *\n+     * <p>Note that 1,000,000 nanoseconds == 1 millisecond, but most VMs do\n+     * not offer that fine a grain of timing resolution. Besides, there is\n+     * no guarantee that this thread can start up immediately when time expires,\n+     * because some other thread may be active.  So don't expect real-time\n+     * performance.\n+     *\n+     * @param ms the number of milliseconds to sleep.\n+     * @param ns the number of extra nanoseconds to sleep (0-999999)\n+     * @throws InterruptedException if the Thread is (or was) interrupted;\n+     *         it's <i>interrupted status</i> will be cleared\n+     */\n+    static void sleep(long ms, int ns) throws InterruptedException\n+    {\n+\n+      // Round up\n+      ms += (ns != 0) ? 1 : 0;\n+\n+      // Note: JDK treats a zero length sleep is like Thread.yield(),\n+      // without checking the interrupted status of the thread.\n+      // It's unclear if this is a bug in the implementation or the spec.\n+      // See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6213203\n+      if (ms == 0)\n+\t{\n+\t  if (Thread.interrupted())\n+\t    throw new InterruptedException();\n+\t  return;\n+\t}\n+\n+      // Compute end time, but don't overflow\n+      long now = System.currentTimeMillis();\n+      long end = now + ms;\n+      if (end < now)\n+\t  end = Long.MAX_VALUE;\n+\n+      // A VM is allowed to return from wait() without notify() having been\n+      // called, so we loop to handle possible spurious wakeups.\n+      VMThread vt = Thread.currentThread().vmThread;\n+      synchronized (vt)\n+\t{\n+\t  while (true)\n+\t    {\n+\t      vt.wait(ms);\n+\t      now = System.currentTimeMillis();\n+\t      if (now >= end)\n+\t\tbreak;\n+\t      ms = end - now;\n+\t    }\n+\t}\n+    }\n+\n+    /**\n+     * Determine whether the current Thread has been interrupted, and clear\n+     * the <i>interrupted status</i> in the process.\n+     *\n+     * @return whether the current Thread has been interrupted\n+     */\n+    static native boolean interrupted();\n+\n+    /**\n+     * Checks whether the current thread holds the monitor on a given object.\n+     * This allows you to do <code>assert Thread.holdsLock(obj)</code>.\n+     *\n+     * @param obj the object to check\n+     * @return true if the current thread is currently synchronized on obj\n+     * @throws NullPointerException if obj is null\n+     */\n+    static boolean holdsLock(Object obj) \n+    {\n+      /* Use obj.notify to check if the current thread holds\n+       * the monitor of the object.\n+       * If it doesn't, notify will throw an exception.\n+       */\n+      try \n+\t{\n+\t  obj.notify();\n+\t  // okay, current thread holds lock\n+\t  return true;\n+\t}\n+      catch (IllegalMonitorStateException e)\n+\t{\n+\t  // it doesn't hold the lock\n+\t  return false;\n+\t}\n+    }\n+}"}, {"sha": "19a204e88186a58319192e8c6e4e69a1a64aba18", "filename": "libjava/classpath/vm/reference/java/lang/VMThrowable.java", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMThrowable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMThrowable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2FVMThrowable.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,82 @@\n+/* java.lang.VMThrowable -- VM support methods for Throwable.\n+   Copyright (C) 1998, 1999, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+/**\n+ * VM dependant state and support methods for Throwable.\n+ * It is deliberately package local and final and should only be accessed\n+ * by the Throwable class.\n+ * <p>\n+ * This is the GNU Classpath reference implementation, it should be adapted\n+ * for a specific VM. The reference implementation does nothing.\n+ *\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+final class VMThrowable\n+{\n+  /**\n+   * VM private data.\n+   */\n+  private transient Object vmdata;\n+\n+  /**\n+   * Private contructor, create VMThrowables with fillInStackTrace();\n+   */\n+  private VMThrowable() { }\n+\n+  /**\n+   * Fill in the stack trace with the current execution stack.\n+   * Called by <code>Throwable.fillInStackTrace()</code> to get the state of\n+   * the VM. Can return null when the VM does not support caputing the VM\n+   * execution state.\n+   *\n+   * @return a new VMThrowable containing the current execution stack trace.\n+   * @see Throwable#fillInStackTrace()\n+   */\n+  static native VMThrowable fillInStackTrace(Throwable t);\n+\n+  /**\n+   * Returns an <code>StackTraceElement</code> array based on the execution\n+   * state of the VM as captured by <code>fillInStackTrace</code>.\n+   * Called by <code>Throwable.getStackTrace()</code>.\n+   *\n+   * @return a non-null but possible zero length array of StackTraceElement.\n+   * @see Throwable#getStackTrace()\n+   */\n+  native StackTraceElement[] getStackTrace(Throwable t);\n+}"}, {"sha": "cddb9ad5e66326b6285376f46a4024c45a553622", "filename": "libjava/classpath/vm/reference/java/lang/reflect/Constructor.java", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2Freflect%2FConstructor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2Freflect%2FConstructor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2Freflect%2FConstructor.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,249 @@\n+/* java.lang.reflect.Constructor - reflection of Java constructors\n+   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.lang.reflect;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * The Constructor class represents a constructor of a class. It also allows\n+ * dynamic creation of an object, via reflection. Invocation on Constructor\n+ * objects knows how to do widening conversions, but throws\n+ * {@link IllegalArgumentException} if a narrowing conversion would be\n+ * necessary. You can query for information on this Constructor regardless\n+ * of location, but construction access may be limited by Java language\n+ * access controls. If you can't do it in the compiler, you can't normally\n+ * do it here either.<p>\n+ *\n+ * <B>Note:</B> This class returns and accepts types as Classes, even\n+ * primitive types; there are Class types defined that represent each\n+ * different primitive type.  They are <code>java.lang.Boolean.TYPE,\n+ * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,\n+ * byte.class</code>, etc.  These are not to be confused with the\n+ * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are\n+ * real classes.<p>\n+ *\n+ * Also note that this is not a serializable class.  It is entirely feasible\n+ * to make it serializable using the Externalizable interface, but this is\n+ * on Sun, not me.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Member\n+ * @see Class\n+ * @see java.lang.Class#getConstructor(Object[])\n+ * @see java.lang.Class#getDeclaredConstructor(Object[])\n+ * @see java.lang.Class#getConstructors()\n+ * @see java.lang.Class#getDeclaredConstructors()\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n+public final class Constructor\n+extends AccessibleObject implements Member\n+{\n+  private Class clazz;\n+  private int slot;\n+  \n+  /**\n+   * This class is uninstantiable except from native code.\n+   */\n+  private Constructor(Class declaringClass,int slot)\n+  {\n+    this.clazz = declaringClass;\n+    this.slot = slot;\n+  }\n+\n+  private Constructor()\n+  {\n+  }\n+\n+  /**\n+   * Gets the class that declared this constructor.\n+   * @return the class that declared this member\n+   */\n+  public Class getDeclaringClass()\n+  {\n+    return clazz;\n+  }\n+\n+  /**\n+   * Gets the name of this constructor (the non-qualified name of the class\n+   * it was declared in).\n+   * @return the name of this constructor\n+   */\n+  public String getName()\n+  {\n+    return getDeclaringClass().getName();\n+  }\n+\n+  /**\n+   * Gets the modifiers this constructor uses.  Use the <code>Modifier</code>\n+   * class to interpret the values. A constructor can only have a subset of the\n+   * following modifiers: public, private, protected.\n+   *\n+   * @return an integer representing the modifiers to this Member\n+   * @see Modifier\n+   */\n+  public native int getModifiers();\n+\n+  /**\n+   * Get the parameter list for this constructor, in declaration order. If the\n+   * constructor takes no parameters, returns a 0-length array (not null).\n+   *\n+   * @return a list of the types of the constructor's parameters\n+   */\n+  public native Class[] getParameterTypes();\n+\n+  /**\n+   * Get the exception types this constructor says it throws, in no particular\n+   * order. If the constructor has no throws clause, returns a 0-length array\n+   * (not null).\n+   *\n+   * @return a list of the types in the constructor's throws clause\n+   */\n+  public native Class[] getExceptionTypes();\n+\n+  /**\n+   * Compare two objects to see if they are semantically equivalent.\n+   * Two Constructors are semantically equivalent if they have the same\n+   * declaring class and the same parameter list.  This ignores different\n+   * exception clauses, but since you can't create a Method except through the\n+   * VM, this is just the == relation.\n+   *\n+   * @param o the object to compare to\n+   * @return <code>true</code> if they are equal; <code>false</code> if not.\n+   */\n+  public boolean equals(Object o)\n+  {\n+    if (!(o instanceof Constructor))\n+      return false;\n+    Constructor that = (Constructor)o; \n+    if (this.getDeclaringClass() != that.getDeclaringClass())\n+      return false;\n+    if (!Arrays.equals(this.getParameterTypes(), that.getParameterTypes()))\n+      return false;\n+    return true;\n+  }\n+\n+  /**\n+   * Get the hash code for the Constructor. The Constructor hash code is the\n+   * hash code of the declaring class's name.\n+   *\n+   * @return the hash code for the object\n+   */\n+  public int hashCode()\n+  {\n+    return getDeclaringClass().getName().hashCode();\n+  }\n+\n+  /**\n+   * Get a String representation of the Constructor. A Constructor's String\n+   * representation is \"&lt;modifier&gt; &lt;classname&gt;(&lt;paramtypes&gt;)\n+   * throws &lt;exceptions&gt;\", where everything after ')' is omitted if\n+   * there are no exceptions.<br> Example:\n+   * <code>public java.io.FileInputStream(java.lang.Runnable)\n+   * throws java.io.FileNotFoundException</code>\n+   *\n+   * @return the String representation of the Constructor\n+   */\n+  public String toString()\n+  {\n+    // 128 is a reasonable buffer initial size for constructor\n+    StringBuffer sb = new StringBuffer(128);\n+    Modifier.toString(getModifiers(), sb).append(' ');\n+    sb.append(getDeclaringClass().getName()).append('(');\n+    Class[] c = getParameterTypes();\n+    if (c.length > 0)\n+      {\n+        sb.append(c[0].getName());\n+        for (int i = 1; i < c.length; i++)\n+          sb.append(',').append(c[i].getName());\n+      }\n+    sb.append(')');\n+    c = getExceptionTypes();\n+    if (c.length > 0)\n+      {\n+        sb.append(\" throws \").append(c[0].getName());\n+        for (int i = 1; i < c.length; i++)\n+          sb.append(',').append(c[i].getName());\n+      }\n+    return sb.toString();\n+  }\n+ \n+  /**\n+   * Create a new instance by invoking the constructor. Arguments are\n+   * automatically unwrapped and widened, if needed.<p>\n+   *\n+   * If this class is abstract, you will get an\n+   * <code>InstantiationException</code>. If the constructor takes 0\n+   * arguments, you may use null or a 0-length array for <code>args</code>.<p>\n+   *\n+   * If this Constructor enforces access control, your runtime context is\n+   * evaluated, and you may have an <code>IllegalAccessException</code> if\n+   * you could not create this object in similar compiled code. If the class\n+   * is uninitialized, you trigger class initialization, which may end in a\n+   * <code>ExceptionInInitializerError</code>.<p>\n+   *\n+   * Then, the constructor is invoked. If it completes normally, the return\n+   * value will be the new object. If it completes abruptly, the exception is\n+   * wrapped in an <code>InvocationTargetException</code>.\n+   *\n+   * @param args the arguments to the constructor\n+   * @return the newly created object\n+   * @throws IllegalAccessException if the constructor could not normally be\n+   *         called by the Java code (i.e. it is not public)\n+   * @throws IllegalArgumentException if the number of arguments is incorrect;\n+   *         or if the arguments types are wrong even with a widening\n+   *         conversion\n+   * @throws InstantiationException if the class is abstract\n+   * @throws InvocationTargetException if the constructor throws an exception\n+   * @throws ExceptionInInitializerError if construction triggered class\n+   *         initialization, which then failed\n+   */\n+  public Object newInstance(Object args[])\n+    throws InstantiationException, IllegalAccessException,\n+           InvocationTargetException\n+  {\n+    return constructNative(args, clazz, slot);\n+  }\n+\n+  private native Object constructNative(Object[] args, Class declaringClass,\n+                                        int slot)\n+    throws InstantiationException, IllegalAccessException,\n+           InvocationTargetException;\n+}"}, {"sha": "85e76d6347916697aa93b0c4fddaceb0a50a5e66", "filename": "libjava/classpath/vm/reference/java/lang/reflect/Field.java", "status": "added", "additions": 589, "deletions": 0, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2Freflect%2FField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2Freflect%2FField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2Freflect%2FField.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,589 @@\n+/* java.lang.reflect.Field - reflection of Java fields\n+   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.lang.reflect;\n+\n+/**\n+ * The Field class represents a member variable of a class. It also allows\n+ * dynamic access to a member, via reflection. This works for both\n+ * static and instance fields. Operations on Field objects know how to\n+ * do widening conversions, but throw {@link IllegalArgumentException} if\n+ * a narrowing conversion would be necessary. You can query for information\n+ * on this Field regardless of location, but get and set access may be limited\n+ * by Java language access controls. If you can't do it in the compiler, you\n+ * can't normally do it here either.<p>\n+ *\n+ * <B>Note:</B> This class returns and accepts types as Classes, even\n+ * primitive types; there are Class types defined that represent each\n+ * different primitive type.  They are <code>java.lang.Boolean.TYPE,\n+ * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,\n+ * byte.class</code>, etc.  These are not to be confused with the\n+ * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are\n+ * real classes.<p>\n+ *\n+ * Also note that this is not a serializable class.  It is entirely feasible\n+ * to make it serializable using the Externalizable interface, but this is\n+ * on Sun, not me.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Member\n+ * @see Class\n+ * @see Class#getField(String)\n+ * @see Class#getDeclaredField(String)\n+ * @see Class#getFields()\n+ * @see Class#getDeclaredFields()\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n+public final class Field\n+extends AccessibleObject implements Member\n+{\n+  private Class declaringClass;\n+  private String name;\n+  private int slot;\n+\n+  /**\n+   * This class is uninstantiable except natively.\n+   */\n+  private Field(Class declaringClass, String name, int slot)\n+  {\n+    this.declaringClass = declaringClass;\n+    this.name = name;\n+    this.slot = slot;\n+  }\n+\n+  /**\n+   * Gets the class that declared this field, or the class where this field\n+   * is a non-inherited member.\n+   * @return the class that declared this member\n+   */\n+  public Class getDeclaringClass()\n+  {\n+    return declaringClass;\n+  }\n+\n+  /**\n+   * Gets the name of this field.\n+   * @return the name of this field\n+   */\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  /**\n+   * Gets the modifiers this field uses.  Use the <code>Modifier</code>\n+   * class to interpret the values.  A field can only have a subset of the\n+   * following modifiers: public, private, protected, static, final,\n+   * transient, and volatile.\n+   *\n+   * @return an integer representing the modifiers to this Member\n+   * @see Modifier\n+   */\n+  public native int getModifiers();\n+\n+  /**\n+   * Gets the type of this field.\n+   * @return the type of this field\n+   */\n+  public native Class getType();\n+\n+  /**\n+   * Compare two objects to see if they are semantically equivalent.\n+   * Two Fields are semantically equivalent if they have the same declaring\n+   * class, name, and type. Since you can't creat a Field except through\n+   * the VM, this is just the == relation.\n+   *\n+   * @param o the object to compare to\n+   * @return <code>true</code> if they are equal; <code>false</code> if not\n+   */\n+  public boolean equals(Object o)\n+  {\n+    if (!(o instanceof Field))\n+      return false;\n+    Field that = (Field)o; \n+    if (this.getDeclaringClass() != that.getDeclaringClass())\n+      return false;\n+    if (!this.getName().equals(that.getName()))\n+      return false;\n+    if (this.getType() != that.getType())\n+      return false;\n+    return true;\n+  }\n+\n+  /**\n+   * Get the hash code for the Field. The Field hash code is the hash code\n+   * of its name XOR'd with the hash code of its class name.\n+   *\n+   * @return the hash code for the object.\n+   */\n+  public int hashCode()\n+  {\n+    return getDeclaringClass().getName().hashCode() ^ getName().hashCode();\n+  }\n+\n+  /**\n+   * Get a String representation of the Field. A Field's String\n+   * representation is \"&lt;modifiers&gt; &lt;type&gt;\n+   * &lt;class&gt;.&lt;fieldname&gt;\".<br> Example:\n+   * <code>public transient boolean gnu.parse.Parser.parseComplete</code>\n+   *\n+   * @return the String representation of the Field\n+   */\n+  public String toString()\n+  {\n+    // 64 is a reasonable buffer initial size for field\n+    StringBuffer sb = new StringBuffer(64);\n+    Modifier.toString(getModifiers(), sb).append(' ');\n+    sb.append(getType().getName()).append(' ');\n+    sb.append(getDeclaringClass().getName()).append('.');\n+    sb.append(getName());\n+    return sb.toString();\n+  }\n+ \n+  /**\n+   * Get the value of this Field.  If it is primitive, it will be wrapped\n+   * in the appropriate wrapper type (boolean = java.lang.Boolean).<p>\n+   *\n+   * If the field is static, <code>o</code> will be ignored. Otherwise, if\n+   * <code>o</code> is null, you get a <code>NullPointerException</code>,\n+   * and if it is incompatible with the declaring class of the field, you\n+   * get an <code>IllegalArgumentException</code>.<p>\n+   *\n+   * Next, if this Field enforces access control, your runtime context is\n+   * evaluated, and you may have an <code>IllegalAccessException</code> if\n+   * you could not access this field in similar compiled code. If the field\n+   * is static, and its class is uninitialized, you trigger class\n+   * initialization, which may end in a\n+   * <code>ExceptionInInitializerError</code>.<p>\n+   *\n+   * Finally, the field is accessed, and primitives are wrapped (but not\n+   * necessarily in new objects). This method accesses the field of the\n+   * declaring class, even if the instance passed in belongs to a subclass\n+   * which declares another field to hide this one.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if <code>o</code> is not an instance of\n+   *         the class or interface declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #getBoolean(Object)\n+   * @see #getByte(Object)\n+   * @see #getChar(Object)\n+   * @see #getShort(Object)\n+   * @see #getInt(Object)\n+   * @see #getLong(Object)\n+   * @see #getFloat(Object)\n+   * @see #getDouble(Object)\n+   */\n+  public native Object get(Object o)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Get the value of this boolean Field. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a boolean field of\n+   *         <code>o</code>, or if <code>o</code> is not an instance of the\n+   *         declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public native boolean getBoolean(Object o)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Get the value of this byte Field. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte field of\n+   *         <code>o</code>, or if <code>o</code> is not an instance of the\n+   *         declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public native byte getByte(Object o)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Get the value of this Field as a char. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a char field of\n+   *         <code>o</code>, or if <code>o</code> is not an instance\n+   *         of the declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public native char getChar(Object o)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Get the value of this Field as a short. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte or short\n+   *         field of <code>o</code>, or if <code>o</code> is not an instance\n+   *         of the declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public native short getShort(Object o)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Get the value of this Field as an int. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte, short, char, or\n+   *         int field of <code>o</code>, or if <code>o</code> is not an\n+   *         instance of the declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public native int getInt(Object o)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Get the value of this Field as a long. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte, short, char, int,\n+   *         or long field of <code>o</code>, or if <code>o</code> is not an\n+   *         instance of the declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public native long getLong(Object o)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Get the value of this Field as a float. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte, short, char, int,\n+   *         long, or float field of <code>o</code>, or if <code>o</code> is\n+   *         not an instance of the declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public native float getFloat(Object o)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Get the value of this Field as a double. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte, short, char, int,\n+   *         long, float, or double field of <code>o</code>, or if\n+   *         <code>o</code> is not an instance of the declaring class of this\n+   *         field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public native double getDouble(Object o)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Set the value of this Field.  If it is a primitive field, the value\n+   * will be unwrapped from the passed object (boolean = java.lang.Boolean).<p>\n+   *\n+   * If the field is static, <code>o</code> will be ignored. Otherwise, if\n+   * <code>o</code> is null, you get a <code>NullPointerException</code>,\n+   * and if it is incompatible with the declaring class of the field, you\n+   * get an <code>IllegalArgumentException</code>.<p>\n+   *\n+   * Next, if this Field enforces access control, your runtime context is\n+   * evaluated, and you may have an <code>IllegalAccessException</code> if\n+   * you could not access this field in similar compiled code. This also\n+   * occurs whether or not there is access control if the field is final.\n+   * If the field is primitive, and unwrapping your argument fails, you will\n+   * get an <code>IllegalArgumentException</code>; likewise, this error\n+   * happens if <code>value</code> cannot be cast to the correct object type.\n+   * If the field is static, and its class is uninitialized, you trigger class\n+   * initialization, which may end in a\n+   * <code>ExceptionInInitializerError</code>.<p>\n+   *\n+   * Finally, the field is set with the widened value. This method accesses\n+   * the field of the declaring class, even if the instance passed in belongs\n+   * to a subclass which declares another field to hide this one.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if <code>value</code> cannot be\n+   *         converted by a widening conversion to the underlying type of\n+   *         the Field, or if <code>o</code> is not an instance of the class\n+   *         declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #setBoolean(Object, boolean)\n+   * @see #setByte(Object, byte)\n+   * @see #setChar(Object, char)\n+   * @see #setShort(Object, short)\n+   * @see #setInt(Object, int)\n+   * @see #setLong(Object, long)\n+   * @see #setFloat(Object, float)\n+   * @see #setDouble(Object, double)\n+   */\n+  public native void set(Object o, Object value)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Set this boolean Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a boolean field, or if\n+   *         <code>o</code> is not an instance of the class declaring this\n+   *         field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public native void setBoolean(Object o, boolean value)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Set this byte Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte, short, int, long,\n+   *         float, or double field, or if <code>o</code> is not an instance\n+   *         of the class declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public native void setByte(Object o, byte value)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Set this char Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a char, int, long,\n+   *         float, or double field, or if <code>o</code> is not an instance\n+   *         of the class declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public native void setChar(Object o, char value)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Set this short Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a short, int, long,\n+   *         float, or double field, or if <code>o</code> is not an instance\n+   *         of the class declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public native void setShort(Object o, short value)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Set this int Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not an int, long, float, or\n+   *         double field, or if <code>o</code> is not an instance of the\n+   *         class declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public native void setInt(Object o, int value)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Set this long Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a long, float, or double\n+   *         field, or if <code>o</code> is not an instance of the class\n+   *         declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public native void setLong(Object o, long value)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Set this float Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a float or long field, or\n+   *         if <code>o</code> is not an instance of the class declaring this\n+   *         field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public native void setFloat(Object o, float value)\n+    throws IllegalAccessException;\n+\n+  /**\n+   * Set this double Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a double field, or if\n+   *         <code>o</code> is not an instance of the class declaring this\n+   *         field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public native void setDouble(Object o, double value)\n+    throws IllegalAccessException;\n+}"}, {"sha": "f289e7763377561efcbfc5ca180908877d0fa0ab", "filename": "libjava/classpath/vm/reference/java/lang/reflect/Method.java", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2Freflect%2FMethod.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2Freflect%2FMethod.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Flang%2Freflect%2FMethod.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,339 @@\n+/* java.lang.reflect.Method - reflection of Java methods\n+   Copyright (C) 1998, 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.lang.reflect;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * The Method class represents a member method of a class. It also allows\n+ * dynamic invocation, via reflection. This works for both static and\n+ * instance methods. Invocation on Method objects knows how to do\n+ * widening conversions, but throws {@link IllegalArgumentException} if\n+ * a narrowing conversion would be necessary. You can query for information\n+ * on this Method regardless of location, but invocation access may be limited\n+ * by Java language access controls. If you can't do it in the compiler, you\n+ * can't normally do it here either.<p>\n+ *\n+ * <B>Note:</B> This class returns and accepts types as Classes, even\n+ * primitive types; there are Class types defined that represent each\n+ * different primitive type.  They are <code>java.lang.Boolean.TYPE,\n+ * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,\n+ * byte.class</code>, etc.  These are not to be confused with the\n+ * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are\n+ * real classes.<p>\n+ *\n+ * Also note that this is not a serializable class.  It is entirely feasible\n+ * to make it serializable using the Externalizable interface, but this is\n+ * on Sun, not me.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Member\n+ * @see Class\n+ * @see java.lang.Class#getMethod(String,Object[])\n+ * @see java.lang.Class#getDeclaredMethod(String,Object[])\n+ * @see java.lang.Class#getMethods()\n+ * @see java.lang.Class#getDeclaredMethods()\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n+public final class Method\n+extends AccessibleObject implements Member\n+{\n+  Class declaringClass;\n+  String name;\n+  int slot;\n+\n+  /**\n+   * This class is uninstantiable.\n+   */\n+  private Method(Class declaringClass, String name, int slot)\n+  {\n+    this.declaringClass = declaringClass;\n+    this.name = name;\n+    this.slot = slot;\n+  }\n+\n+  /**\n+   * Gets the class that declared this method, or the class where this method\n+   * is a non-inherited member.\n+   * @return the class that declared this member\n+   */\n+  public Class getDeclaringClass()\n+  {\n+    return declaringClass;\n+  }\n+\n+  /**\n+   * Gets the name of this method.\n+   * @return the name of this method\n+   */\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  /**\n+   * Gets the modifiers this method uses.  Use the <code>Modifier</code>\n+   * class to interpret the values.  A method can only have a subset of the\n+   * following modifiers: public, private, protected, abstract, static,\n+   * final, synchronized, native, and strictfp.\n+   *\n+   * @return an integer representing the modifiers to this Member\n+   * @see Modifier\n+   */\n+  public native int getModifiers();\n+\n+  /**\n+   * Gets the return type of this method.\n+   * @return the type of this method\n+   */\n+  public native Class getReturnType();\n+\n+  /**\n+   * Get the parameter list for this method, in declaration order. If the\n+   * method takes no parameters, returns a 0-length array (not null).\n+   *\n+   * @return a list of the types of the method's parameters\n+   */\n+  public native Class[] getParameterTypes();\n+\n+  /**\n+   * Get the exception types this method says it throws, in no particular\n+   * order. If the method has no throws clause, returns a 0-length array\n+   * (not null).\n+   *\n+   * @return a list of the types in the method's throws clause\n+   */\n+  public native Class[] getExceptionTypes();\n+\n+  /**\n+   * Compare two objects to see if they are semantically equivalent.\n+   * Two Methods are semantically equivalent if they have the same declaring\n+   * class, name, parameter list, and return type.\n+   *\n+   * @param o the object to compare to\n+   * @return <code>true</code> if they are equal; <code>false</code> if not\n+   */\n+  public boolean equals(Object o)\n+  {\n+      // Implementation note:\n+      // The following is a correct but possibly slow implementation.\n+      //\n+      // This class has a private field 'slot' that could be used by\n+      // the VM implementation to \"link\" a particular method to a Class.\n+      // In that case equals could be simply implemented as:\n+      //\n+      // if (o instanceof Method)\n+      // {\n+      //    Method m = (Method)o;\n+      //    return m.declaringClass == this.declaringClass\n+      //           && m.slot == this.slot;\n+      // }\n+      // return false;\n+      //\n+      // If a VM uses the Method class as their native/internal representation\n+      // then just using the following would be optimal:\n+      //\n+      // return this == o;\n+      //\n+    if (!(o instanceof Method))\n+      return false;\n+    Method that = (Method)o;\n+    if (this.getDeclaringClass() != that.getDeclaringClass())\n+      return false;\n+    if (!this.getName().equals(that.getName()))\n+      return false;\n+    if (this.getReturnType() != that.getReturnType())\n+      return false;\n+    if (!Arrays.equals(this.getParameterTypes(), that.getParameterTypes()))\n+      return false;\n+    return true;\n+  }\n+\n+  /**\n+   * Get the hash code for the Method. The Method hash code is the hash code\n+   * of its name XOR'd with the hash code of its class name.\n+   *\n+   * @return the hash code for the object\n+   */\n+  public int hashCode()\n+  {\n+    return getDeclaringClass().getName().hashCode() ^ getName().hashCode();\n+  }\n+\n+  /**\n+   * Get a String representation of the Method. A Method's String\n+   * representation is \"&lt;modifiers&gt; &lt;returntype&gt;\n+   * &lt;methodname&gt;(&lt;paramtypes&gt;) throws &lt;exceptions&gt;\", where\n+   * everything after ')' is omitted if there are no exceptions.<br> Example:\n+   * <code>public static int run(java.lang.Runnable,int)</code>\n+   *\n+   * @return the String representation of the Method\n+   */\n+  public String toString()\n+  {\n+    // 128 is a reasonable buffer initial size for constructor\n+    StringBuffer sb = new StringBuffer(128);\n+    Modifier.toString(getModifiers(), sb).append(' ');\n+    sb.append(getUserTypeName(getReturnType().getName())).append(' ');\n+    sb.append(getDeclaringClass().getName()).append('.');\n+    sb.append(getName()).append('(');\n+    Class[] c = getParameterTypes();\n+    if (c.length > 0)\n+      {\n+        sb.append(getUserTypeName(c[0].getName()));\n+        for (int i = 1; i < c.length; i++)\n+          sb.append(',').append(getUserTypeName(c[i].getName()));\n+      }\n+    sb.append(')');\n+    c = getExceptionTypes();\n+    if (c.length > 0)\n+      {\n+        sb.append(\" throws \").append(c[0].getName());\n+        for (int i = 1; i < c.length; i++)\n+          sb.append(',').append(c[i].getName());\n+      }\n+    return sb.toString();\n+  }\n+\n+  private static String getUserTypeName(String typeSpec)\n+  {\n+    int pos = 0;\n+    String typeName = \"\";\n+    String arrayPart = \"\";\n+\n+    while (typeSpec.charAt(pos) == '[')\n+      {\n+\tarrayPart += \"[]\";\n+\t++pos;\n+      }\n+\n+    switch (typeSpec.charAt(pos))\n+      {\n+      case 'Z':\n+\ttypeName = \"boolean\";\n+\tbreak;\n+      case 'B':\n+\ttypeName = \"byte\";\n+\tbreak;\n+      case 'C':\n+\ttypeName = \"char\";\n+\tbreak;\n+      case 'D':\n+\ttypeName = \"double\";\n+\tbreak;\n+      case 'F':\n+\ttypeName = \"float\";\n+\tbreak;\n+      case 'I':\n+\ttypeName = \"int\";\n+\tbreak;\n+      case 'J':\n+\ttypeName = \"long\";\n+\tbreak;\n+      case 'S':\n+\ttypeName = \"short\";\n+\tbreak;\n+      case 'L':\n+\ttypeName = typeSpec.substring(pos + 1, typeSpec.length() - 1);\n+\tbreak;\n+      default:\n+\ttypeName = typeSpec;\n+\tbreak;\n+      }\n+\n+    return typeName + arrayPart;\n+  }\n+\n+  /**\n+   * Invoke the method. Arguments are automatically unwrapped and widened,\n+   * and the result is automatically wrapped, if needed.<p>\n+   *\n+   * If the method is static, <code>o</code> will be ignored. Otherwise,\n+   * the method uses dynamic lookup as described in JLS 15.12.4.4. You cannot\n+   * mimic the behavior of nonvirtual lookup (as in super.foo()). This means\n+   * you will get a <code>NullPointerException</code> if <code>o</code> is\n+   * null, and an <code>IllegalArgumentException</code> if it is incompatible\n+   * with the declaring class of the method. If the method takes 0 arguments,\n+   * you may use null or a 0-length array for <code>args</code>.<p>\n+   *\n+   * Next, if this Method enforces access control, your runtime context is\n+   * evaluated, and you may have an <code>IllegalAccessException</code> if\n+   * you could not acces this method in similar compiled code. If the method\n+   * is static, and its class is uninitialized, you trigger class\n+   * initialization, which may end in a\n+   * <code>ExceptionInInitializerError</code>.<p>\n+   *\n+   * Finally, the method is invoked. If it completes normally, the return value\n+   * will be null for a void method, a wrapped object for a primitive return\n+   * method, or the actual return of an Object method. If it completes\n+   * abruptly, the exception is wrapped in an\n+   * <code>InvocationTargetException</code>.\n+   *\n+   * @param o the object to invoke the method on\n+   * @param args the arguments to the method\n+   * @return the return value of the method, wrapped in the appropriate\n+   *         wrapper if it is primitive\n+   * @throws IllegalAccessException if the method could not normally be called\n+   *         by the Java code (i.e. it is not public)\n+   * @throws IllegalArgumentException if the number of arguments is incorrect;\n+   *         if the arguments types are wrong even with a widening conversion;\n+   *         or if <code>o</code> is not an instance of the class or interface\n+   *         declaring this method\n+   * @throws InvocationTargetException if the method throws an exception\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static method triggered\n+   *         class initialization, which then failed\n+   */\n+  public Object invoke(Object o, Object[] args)\n+    throws IllegalAccessException, InvocationTargetException\n+  {\n+    return invokeNative(o, args, declaringClass, slot);\n+  }\n+\n+  /*\n+   * NATIVE HELPERS\n+   */\n+\n+  private native Object invokeNative(Object o, Object[] args,\n+                                     Class declaringClass, int slot)\n+    throws IllegalAccessException, InvocationTargetException;\n+}"}, {"sha": "1253ded7327dbfc1f3365f133edbc07e85fcb041", "filename": "libjava/classpath/vm/reference/java/net/VMInetAddress.java", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnet%2FVMInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnet%2FVMInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnet%2FVMInetAddress.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,93 @@\n+/* VMInetAddress.java -- Class to model an Internet address\n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.net;\n+\n+import gnu.classpath.Configuration;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.StringTokenizer;\n+\n+class VMInetAddress implements Serializable\n+{\n+  static\n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      System.loadLibrary(\"javanet\");\n+  }\n+\n+  /**\n+   * This method looks up the hostname of the local machine\n+   * we are on.  If the actual hostname cannot be determined, then the\n+   * value \"localhost\" will be used.  This native method wrappers the\n+   * \"gethostname\" function.\n+   *\n+   * @return The local hostname.\n+   */\n+  public static native String getLocalHostname();\n+\n+  /**\n+   * Returns the value of the special address INADDR_ANY\n+   */\n+  public static native byte[] lookupInaddrAny() throws UnknownHostException;\n+\n+  /**\n+   * This method returns the hostname for a given IP address.  It will\n+   * throw an UnknownHostException if the hostname cannot be determined.\n+   *\n+   * @param ip The IP address as a byte array\n+   *\n+   * @return The hostname\n+   *\n+   * @exception UnknownHostException If the reverse lookup fails\n+   */\n+  public static native String getHostByAddr(byte[] ip)\n+    throws UnknownHostException;\n+\n+  /**\n+   * Returns a list of all IP addresses for a given hostname.  Will throw\n+   * an UnknownHostException if the hostname cannot be resolved.\n+   */\n+  public static native byte[][] getHostByName(String hostname)\n+    throws UnknownHostException;\n+}"}, {"sha": "af71ce294d197766665e1472c3d2c03514f468c4", "filename": "libjava/classpath/vm/reference/java/net/VMNetworkInterface.java", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnet%2FVMNetworkInterface.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnet%2FVMNetworkInterface.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnet%2FVMNetworkInterface.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,66 @@\n+/* VMNetworkInterface.java --\n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.net;\n+\n+import gnu.classpath.Configuration;\n+\n+import java.util.Enumeration;\n+import java.util.Vector;\n+\n+/**\n+ * This class models a network interface on the host computer.  A network\n+ * interface contains a name (typically associated with a specific\n+ * hardware adapter) and a list of addresses that are bound to it.\n+ * For example, an ethernet interface may be named \"eth0\" and have the\n+ * address 192.168.1.101 assigned to it.\n+ *\n+ * @author Michael Koch (konqueror@gmx.de)\n+ * @since 1.4\n+ */\n+final class VMNetworkInterface\n+{\n+  static\n+    {\n+      if (Configuration.INIT_LOAD_LIBRARY)\n+\tSystem.loadLibrary(\"javanet\");\n+    }\n+\n+  public static native Vector getInterfaces()\n+    throws SocketException;\n+}"}, {"sha": "e42f503813099ddca272e2ac5c70c9d5d5861818", "filename": "libjava/classpath/vm/reference/java/nio/VMDirectByteBuffer.java", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnio%2FVMDirectByteBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnio%2FVMDirectByteBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnio%2FVMDirectByteBuffer.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,66 @@\n+/* VMDirectByteBuffer.java -- \n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.nio;\n+\n+import gnu.classpath.Configuration;\n+import gnu.classpath.RawData;\n+\n+final class VMDirectByteBuffer\n+{\n+  static\n+  {\n+    // load the shared library needed for native methods.\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+        System.loadLibrary(\"javanio\");\n+      }\n+\n+    init();\n+  }\n+\n+  private static native void init();\n+  \n+  static native RawData allocate (int capacity);\n+  static native void free(RawData address);\n+  static native byte get(RawData address, int index);\n+  static native void get(RawData address, int index, byte[] dst, int offset, int length);\n+  static native void put(RawData address, int index, byte value);\n+  static native RawData adjustAddress(RawData address, int offset);\n+  static native void shiftDown(RawData address, int dst_offset, int src_offset, int count);\n+}"}, {"sha": "e58d7fbf92c06a526a3e52b252284859c7cc969e", "filename": "libjava/classpath/vm/reference/java/nio/channels/VMChannels.java", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnio%2Fchannels%2FVMChannels.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnio%2Fchannels%2FVMChannels.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fnio%2Fchannels%2FVMChannels.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,116 @@\n+/* VMChannels.java --\n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.nio.channels;\n+\n+import gnu.java.nio.ChannelInputStream;\n+import gnu.java.nio.ChannelOutputStream;\n+import gnu.java.nio.channels.FileChannelImpl;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+final class VMChannels\n+{\n+  /**\n+   * This class isn't intended to be instantiated.\n+   */\n+  private VMChannels()\n+  {\n+    // Do nothing here.\n+  }\n+\n+  private static Object createStream(Class streamClass, Channel ch)\n+  {\n+    try\n+      {\n+\tClass[] argTypes = new Class[1];\n+\targTypes[0] = FileChannelImpl.class;\n+\tConstructor constructor =\n+\t  streamClass.getDeclaredConstructor(argTypes);\n+\tconstructor.setAccessible(true);\n+\tObject[] args = new Object[1];\n+\targs[0] = ch;\n+\treturn constructor.newInstance(args);\n+      }\n+    catch (IllegalAccessException e)\n+      {\n+\t// Ignored.\n+      }\n+    catch (InstantiationException e)\n+      {\n+\t// Ignored.\n+      }\n+    catch (InvocationTargetException e)\n+      {\n+\t// Ignored.\n+      }\n+    catch (NoSuchMethodException e)\n+      {\n+\t// Ignored.\n+      }\n+\n+    return null;\n+  }\n+  \n+  /**\n+   * Constructs a stream that reads bytes from the given channel.\n+   */\n+  static InputStream newInputStream(ReadableByteChannel ch)\n+  {\n+    if (ch instanceof FileChannelImpl)\n+      return (FileInputStream) createStream(FileInputStream.class, ch);\n+    \n+    return  new ChannelInputStream(ch);\n+  }\n+\n+  /**\n+   * Constructs a stream that writes bytes to the given channel.\n+   */\n+  static OutputStream newOutputStream(WritableByteChannel ch)\n+  {\n+    if (ch instanceof FileChannelImpl)\n+      return (FileOutputStream) createStream(FileOutputStream.class, ch);\n+    \n+    return new ChannelOutputStream(ch);\n+  }\n+}"}, {"sha": "7058a5e345c5734b0f9c6782a46262defaf77fe9", "filename": "libjava/classpath/vm/reference/java/security/VMAccessController.java", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fsecurity%2FVMAccessController.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fsecurity%2FVMAccessController.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Fsecurity%2FVMAccessController.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,260 @@\n+/* VMAccessController.java -- VM-specific access controller methods.\n+   Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security;\n+\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+\n+final class VMAccessController\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * This is a per-thread stack of AccessControlContext objects (which can\n+   * be null) for each call to AccessController.doPrivileged in each thread's\n+   * call stack. We use this to remember which context object corresponds to\n+   * which call.\n+   */\n+  private static final ThreadLocal contexts = new ThreadLocal();\n+\n+  /**\n+   * This is a Boolean that, if set, tells getContext that it has already\n+   * been called once, allowing us to handle recursive permission checks\n+   * caused by methods getContext calls.\n+   */\n+  private static final ThreadLocal inGetContext = new ThreadLocal();\n+\n+  /**\n+   * And we return this all-permissive context to ensure that privileged\n+   * methods called from getContext succeed.\n+   */\n+  private static final AccessControlContext DEFAULT_CONTEXT;\n+  static\n+  {\n+    CodeSource source = new CodeSource(null, null);\n+    Permissions permissions = new Permissions();\n+    permissions.add(new AllPermission());\n+    ProtectionDomain[] domain = new ProtectionDomain[] {\n+      new ProtectionDomain(source, permissions)\n+    };\n+    DEFAULT_CONTEXT = new AccessControlContext(domain);\n+  }\n+\n+  private static final boolean DEBUG = false;\n+  private static void debug(String msg)\n+  {\n+    System.err.print(\">>> VMAccessController: \");\n+    System.err.println(msg);\n+  }\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  private VMAccessController() { }\n+\n+  // Class methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Relate a class (which should be an instance of {@link PrivilegedAction}\n+   * with an access control context. This method is used by {@link\n+   * AccessController#doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)}\n+   * to set up the context that will be returned by {@link #getContext()}.\n+   * This method relates the class to the current thread, so contexts\n+   * pushed from one thread will not be available to another.\n+   *\n+   * @param acc The access control context.\n+   */\n+  static void pushContext (AccessControlContext acc)\n+  {\n+    if (DEBUG)\n+      debug(\"pushing \" + acc);\n+    LinkedList stack = (LinkedList) contexts.get();\n+    if (stack == null)\n+      {\n+        stack = new LinkedList();\n+        contexts.set(stack);\n+      }\n+    stack.addFirst(acc);\n+  }\n+\n+  /**\n+   * Removes the relation of a class to an {@link AccessControlContext}.\n+   * This method is used by {@link AccessController} when exiting from a\n+   * call to {@link\n+   * AccessController#doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)}.\n+   */\n+  static void popContext()\n+  {\n+    if (DEBUG)\n+      debug(\"popping context\");\n+\n+    // Stack should never be null, nor should it be empty, if this method\n+    // and its counterpart has been called properly.\n+    LinkedList stack = (LinkedList) contexts.get();\n+    if (stack != null)\n+      {\n+        stack.removeFirst();\n+        if (stack.isEmpty())\n+          contexts.set(null);\n+      }\n+  }\n+\n+  /**\n+   * Examine the method stack of the currently running thread, and create\n+   * an {@link AccessControlContext} filled in with the appropriate {@link\n+   * ProtectionDomain} objects given this stack.\n+   *\n+   * @return The context.\n+   */\n+  static AccessControlContext getContext()\n+  {\n+    // If we are already in getContext, but called a method that needs\n+    // a permission check, return the all-permissive context so methods\n+    // called from here succeed.\n+    //\n+    // XXX is this necessary? We should verify if there are any calls in\n+    // the stack below this method that require permission checks.\n+    Boolean inCall = (Boolean) inGetContext.get();\n+    if (inCall != null && inCall.booleanValue())\n+      {\n+        if (DEBUG)\n+          debug(\"already in getContext\");\n+        return DEFAULT_CONTEXT;\n+      }\n+\n+    inGetContext.set(Boolean.TRUE);\n+\n+    Object[][] stack = getStack();\n+    Class[] classes = (Class[]) stack[0];\n+    String[] methods = (String[]) stack[1];\n+\n+    if (DEBUG)\n+      debug(\">>> got trace of length \" + classes.length);\n+\n+    HashSet domains = new HashSet();\n+    HashSet seenDomains = new HashSet();\n+    AccessControlContext context = null;\n+    int privileged = 0;\n+\n+    // We walk down the stack, adding each ProtectionDomain for each\n+    // class in the call stack. If we reach a call to doPrivileged,\n+    // we don't add any more stack frames. We skip the first three stack\n+    // frames, since they comprise the calls to getStack, getContext,\n+    // and AccessController.getContext.\n+    for (int i = 3; i < classes.length && privileged < 2; i++)\n+      {\n+        Class clazz = classes[i];\n+        String method = methods[i];\n+\n+        if (DEBUG)\n+          {\n+            debug(\">>> checking \" + clazz + \".\" + method);\n+            debug(\">>> loader = \" + clazz.getClassLoader());\n+          }\n+\n+        // If the previous frame was a call to doPrivileged, then this is\n+        // the last frame we look at.\n+        if (privileged == 1)\n+          privileged = 2;\n+\n+        if (clazz.equals (AccessController.class)\n+            && method.equals (\"doPrivileged\"))\n+          {\n+            // If there was a call to doPrivileged with a supplied context,\n+            // return that context.\n+            LinkedList l = (LinkedList) contexts.get();\n+            if (l != null)\n+              context = (AccessControlContext) l.getFirst();\n+            privileged = 1;\n+          }\n+\n+        ProtectionDomain domain = clazz.getProtectionDomain();\n+\n+        if (domain == null)\n+          continue;\n+        if (seenDomains.contains(domain))\n+          continue;\n+        seenDomains.add(domain);\n+\n+        // Create a static snapshot of this domain, which may change over time\n+        // if the current policy changes.\n+        domains.add(new ProtectionDomain(domain.getCodeSource(),\n+                                         domain.getPermissions()));\n+      }\n+\n+    if (DEBUG)\n+      debug(\"created domains: \" + domains);\n+\n+    ProtectionDomain[] result = (ProtectionDomain[])\n+      domains.toArray(new ProtectionDomain[domains.size()]);\n+\n+    // Intersect the derived protection domain with the context supplied\n+    // to doPrivileged.\n+    if (context != null)\n+      context = new AccessControlContext(result, context,\n+                                         IntersectingDomainCombiner.SINGLETON);\n+    // No context was supplied. Return the derived one.\n+    else\n+      context = new AccessControlContext(result);\n+\n+    inGetContext.set(Boolean.FALSE);\n+    return context;\n+  }\n+\n+  /**\n+   * Returns a snapshot of the current call stack as a pair of arrays:\n+   * the first an array of classes in the call stack, the second an array\n+   * of strings containing the method names in the call stack. The two\n+   * arrays match up, meaning that method <i>i</i> is declared in class\n+   * <i>i</i>. The arrays are clean; it will only contain Java methods,\n+   * and no element of the list should be null.\n+   *\n+   * <p>The default implementation returns an empty stack, which will be\n+   * interpreted as having no permissions whatsoever.\n+   *\n+   * @return A pair of arrays describing the current call stack. The first\n+   *    element is an array of Class objects, and the second is an array\n+   *    of Strings comprising the method names.\n+   */\n+  private static Object[][] getStack()\n+  {\n+    return new Object[][] { new Class[0], new String[0] };\n+  }\n+}"}, {"sha": "86b62584307ea578d82cdbc4a94ec408bd8fe8d8", "filename": "libjava/classpath/vm/reference/java/util/VMTimeZone.java", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Futil%2FVMTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d375fdc5fd13db547fb60bdd40b73355396587/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Futil%2FVMTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fvm%2Freference%2Fjava%2Futil%2FVMTimeZone.java?ref=37d375fdc5fd13db547fb60bdd40b73355396587", "patch": "@@ -0,0 +1,345 @@\n+/* java.util.VMTimeZone\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.util;\n+\n+import gnu.classpath.Configuration;\n+\n+import java.io.*;\n+\n+/**\n+ *\n+ */\n+final class VMTimeZone\n+{\n+  static\n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+\tSystem.loadLibrary(\"javautil\");\n+      }\n+  }\n+\t\t\n+  /**\n+   * This method returns a time zone id string which is in the form\n+   * (standard zone name) or (standard zone name)(GMT offset) or\n+   * (standard zone name)(GMT offset)(daylight time zone name).  The\n+   * GMT offset can be in seconds, or where it is evenly divisible by\n+   * 3600, then it can be in hours.  The offset must be the time to\n+   * add to the local time to get GMT.  If a offset is given and the\n+   * time zone observes daylight saving then the (daylight time zone\n+   * name) must also be given (otherwise it is assumed the time zone\n+   * does not observe any daylight savings).\n+   * <p>\n+   * The result of this method is given to the method\n+   * TimeZone.getDefaultTimeZone(String) which tries to map the time\n+   * zone id to a known TimeZone.  See that method on how the returned\n+   * String is mapped to a real TimeZone object.\n+   * <p>\n+   * The reference implementation which is made for GNU/Posix like\n+   * systems calls <code>System.getenv(\"TZ\")</code>,\n+   * <code>readTimeZoneFile(\"/etc/timezone\")</code>,\n+   * <code>readtzFile(\"/etc/localtime\")</code> and finally\n+   * <code>getSystemTimeZoneId()</code> till a supported TimeZone is\n+   * found through <code>TimeZone.getDefaultTimeZone(String)</code>.\n+   * If every method fails <code>null</code> is returned (which means\n+   * the TimeZone code will fall back on GMT as default time zone).\n+   * <p>\n+   * Note that this method is called inside a\n+   * <code>AccessController.doPrivileged()</code> block and runs with\n+   * the priviliges of the java.util system classes.  It will only be\n+   * called when the default time zone is not yet set, the system\n+   * property user.timezone isn't set and it is requested for the\n+   * first time.\n+   */\n+  static TimeZone getDefaultTimeZoneId()\n+  {\n+    TimeZone zone = null;\n+\n+    // See if TZ environment variable is set and accessible.\n+    String tzid = System.getenv(\"TZ\");\n+    if (tzid != null && !tzid.equals(\"\"))\n+      zone = TimeZone.getDefaultTimeZone(tzid);\n+\n+    // Try to parse /etc/timezone.\n+    if (zone == null)\n+      {\n+\ttzid = readTimeZoneFile(\"/etc/timezone\");\n+\tif (tzid != null && !tzid.equals(\"\"))\n+\t  zone = TimeZone.getDefaultTimeZone(tzid);\n+      }\n+    \n+    // Try to parse /etc/localtime\n+    if (zone == null)\n+      {\n+\ttzid = readtzFile(\"/etc/localtime\");\n+\tif (tzid != null && !tzid.equals(\"\"))\n+\t  zone = TimeZone.getDefaultTimeZone(tzid);\n+      }\n+\n+    // Try some system specific way\n+    if (zone == null)\n+      {\n+\ttzid = getSystemTimeZoneId();\n+\tif (tzid != null && !tzid.equals(\"\"))\n+\t  zone = TimeZone.getDefaultTimeZone(tzid);\n+      }\n+\n+    return zone;\n+  }\n+\n+  /**\n+   * Tries to read the time zone name from a file. Only the first\n+   * consecutive letters, digits, slashes, dashes and underscores are\n+   * read from the file. If the file cannot be read or an IOException\n+   * occurs null is returned.\n+   * <p>\n+   * The /etc/timezone file is not standard, but a lot of systems have\n+   * it. If it exist the first line always contains a string\n+   * describing the timezone of the host of domain. Some systems\n+   * contain a /etc/TIMEZONE file which is used to set the TZ\n+   * environment variable (which is checked before /etc/timezone is\n+   * read).\n+   */\n+  private static String readTimeZoneFile(String file)\n+  {\n+    File f = new File(file);\n+    if (!f.exists())\n+      return null;\n+\n+    InputStreamReader isr = null;\n+    try\n+      {\n+\tFileInputStream fis = new FileInputStream(f);\n+\tBufferedInputStream bis = new BufferedInputStream(fis);\n+\tisr = new InputStreamReader(bis);\n+\t\n+\tStringBuffer sb = new StringBuffer();\n+\tint i = isr.read();\n+\twhile (i != -1)\n+\t  {\n+\t    char c = (char) i;\n+\t    if (Character.isLetter(c) || Character.isDigit(c)\n+\t\t|| c == '/' || c == '-' || c == '_')\n+\t      {\n+\t\tsb.append(c);\n+\t\ti = isr.read();\n+\t      }\n+\t    else\n+\t      break;\n+\t  }\n+\treturn sb.toString();\n+      }\n+    catch (IOException ioe)\n+      {\n+\t// Parse error, not a proper tzfile.\n+\treturn null;\n+      }\n+    finally\n+      {\n+\ttry\n+\t  {\n+\t    if (isr != null)\n+\t      isr.close();\n+\t  }\n+\tcatch (IOException ioe)\n+\t  {\n+\t    // Error while close, nothing we can do.\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Tries to read a file as a \"standard\" tzfile and return a time\n+   * zone id string as expected by <code>getDefaultTimeZone(String)</code>.\n+   * If the file doesn't exist, an IOException occurs or it isn't a tzfile\n+   * that can be parsed null is returned.\n+   * <p>\n+   * The tzfile structure (as also used by glibc) is described in the Olson\n+   * tz database archive as can be found at\n+   * <code>ftp://elsie.nci.nih.gov/pub/</code>.\n+   * <p>\n+   * At least the following platforms support the tzdata file format\n+   * and /etc/localtime (GNU/Linux, Darwin, Solaris and FreeBSD at\n+   * least). Some systems (like Darwin) don't start the file with the\n+   * required magic bytes 'TZif', this implementation can handle\n+   * that).\n+   */\n+  private static String readtzFile(String file)\n+  {\n+    File f = new File(file);\n+    if (!f.exists())\n+      return null;\n+    \n+    DataInputStream dis = null;\n+    try\n+      {\n+        FileInputStream fis = new FileInputStream(f);\n+        BufferedInputStream bis = new BufferedInputStream(fis);\n+        dis = new DataInputStream(bis);\n+\t\n+        // Make sure we are reading a tzfile.\n+        byte[] tzif = new byte[4];\n+        dis.readFully(tzif);\n+        if (tzif[0] == 'T' && tzif[1] == 'Z'\n+            && tzif[2] == 'i' && tzif[3] == 'f')\n+\t  // Reserved bytes, ttisgmtcnt, ttisstdcnt and leapcnt\n+\t  skipFully(dis, 16 + 3 * 4);\n+\telse\n+\t  // Darwin has tzdata files that don't start with the TZif marker\n+\t  skipFully(dis, 16 + 3 * 4 - 4);\n+\t\n+\tint timecnt = dis.readInt();\n+\tint typecnt = dis.readInt();\n+\tif (typecnt > 0)\n+\t  {\n+\t    int charcnt = dis.readInt();\n+\t    // Transition times plus indexed transition times.\n+\t    skipFully(dis, timecnt * (4 + 1));\n+\t    \n+\t    // Get last gmt_offset and dst/non-dst time zone names.\n+\t    int abbrind = -1;\n+\t    int dst_abbrind = -1;\n+\t    int gmt_offset = 0;\n+\t    while (typecnt-- > 0)\n+\t      {\n+\t\t// gmtoff\n+\t\tint offset = dis.readInt();\n+\t\tint dst = dis.readByte();\n+\t\tif (dst == 0)\n+\t\t  {\n+\t\t    abbrind = dis.readByte();\n+\t\t    gmt_offset = offset;\n+\t\t  }\n+\t\telse\n+\t\t  dst_abbrind = dis.readByte();\n+\t      }\n+\t    \n+\t    // gmt_offset is the offset you must add to UTC/GMT to\n+\t    // get the local time, we need the offset to add to\n+\t    // the local time to get UTC/GMT.\n+\t    gmt_offset *= -1;\n+\t    \n+\t    // Turn into hours if possible.\n+\t    if (gmt_offset % 3600 == 0)\n+\t      gmt_offset /= 3600;\n+\t    \n+\t    if (abbrind >= 0)\n+\t      {\n+\t\tbyte[] names = new byte[charcnt];\n+\t\tdis.readFully(names);\n+\t\tint j = abbrind;\n+\t\twhile (j < charcnt && names[j] != 0)\n+\t\t  j++;\n+\t\t\n+\t\tString zonename = new String(names, abbrind, j - abbrind,\n+\t\t\t\t\t     \"ASCII\");\n+\t\t\n+\t\tString dst_zonename;\n+\t\tif (dst_abbrind >= 0)\n+\t\t  {\n+\t\t    j = dst_abbrind;\n+\t\t    while (j < charcnt && names[j] != 0)\n+\t\t      j++;\n+\t\t    dst_zonename = new String(names, dst_abbrind,\n+\t\t\t\t\t      j - dst_abbrind, \"ASCII\");\n+\t\t  }\n+\t\telse\n+\t\t  dst_zonename = \"\";\n+\t\t\n+\t\t// Only use gmt offset when necessary.\n+\t\t// Also special case GMT+/- timezones.\n+\t\tString offset_string;\n+\t\tif (\"\".equals(dst_zonename)\n+\t\t    && (gmt_offset == 0\n+\t\t\t|| zonename.startsWith(\"GMT+\")\n+\t\t\t|| zonename.startsWith(\"GMT-\")))\n+\t\t  offset_string = \"\";\n+\t\telse\n+\t\t  offset_string = Integer.toString(gmt_offset);\n+\t\t\n+\t\tString id = zonename + offset_string + dst_zonename;\n+\t\t\n+\t\treturn id;\n+\t      }\n+\t  }\n+\t\n+\t// Something didn't match while reading the file.\n+\treturn null;\n+      }\n+    catch (IOException ioe)\n+      {\n+\t// Parse error, not a proper tzfile.\n+\treturn null;\n+      }\n+    finally\n+      {\n+\ttry\n+\t  {\n+\t    if (dis != null)\n+\t      dis.close();\n+\t  }\n+\tcatch(IOException ioe)\n+\t  {\n+\t    // Error while close, nothing we can do.\n+\t  }\n+      }\n+  }\n+  \n+  /**\n+   * Skips the requested number of bytes in the given InputStream.\n+   * Throws EOFException if not enough bytes could be skipped.\n+   * Negative numbers of bytes to skip are ignored.\n+   */\n+  private static void skipFully(InputStream is, long l) throws IOException\n+  {\n+    while (l > 0)\n+      {\n+        long k = is.skip(l);\n+        if (k <= 0)\n+          throw new EOFException();\n+        l -= k;\n+      }\n+  }\n+\n+  /**\n+   * Tries to get the system time zone id through native code.\n+   */\n+  private static native String getSystemTimeZoneId();\n+}"}]}