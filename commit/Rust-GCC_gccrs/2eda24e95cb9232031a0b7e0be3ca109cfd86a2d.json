{"sha": "2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVkYTI0ZTk1Y2I5MjMyMDMxYTBiN2UwYmUzY2ExMDljZmQ4NmEyZA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-09-18T09:52:11Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-09-18T09:52:11Z"}, "message": "sem_ch4.adb (Complete_Object_Operation): Do not insert 'Access for reference types in the access-to-access case.\n\ngcc/ada/\n\n2017-09-18  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch4.adb (Complete_Object_Operation): Do not insert 'Access for\n\treference types in the access-to-access case.\n\n2017-09-18  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_attr.adb (Analyze_Access_Attribute): Move check for the presence\n\tof the \"aliased\" keyword on the prefix from here to...\n\t(Resolve_Attribute) <Attribute_Access>: ...here.  Remove useless call\n\tto Check_No_Implicit_Aliasing.\n\t* sinfo.ads (Non_Aliased_Prefix): Delete.\n\t(Set_Non_Aliased_Prefix): Likewise.\n\t* sinfo.adb (Non_Aliased_Prefix): Delete.\n\t(Set_Non_Aliased_Prefix): Likewise.\n\n2017-09-18  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch5.adb (Build_Formal_Container_Iteration,\n\tExpand_Formal_Container_Element_Loop): Convert the container to the\n\troot type before passing it to the iteration operations, so it will be\n\tof the right type.\n\n2017-09-18  Bob Duff  <duff@adacore.com>\n\n\t* einfo.ads, validsw.ads, treepr.ads, sem_util.ads: Comment fixes.\n\n2017-09-18  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch3.adb (Build_Array_Init_Proc): If validity checking is enabled,\n\tand it's a bit-packed array, pass False to the Consider_IS parameter of\n\tNeeds_Simple_Initialization.\n\n2017-09-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch6.adb (Check_Inline_Pragma): Link the newly generated spec to\n\tthe preexisting body.\n\t* sem_prag.adb (Check_Inline_Always_Placement): New routine.\n\t(Process_Inline): Verify the placement of pragma Inline_Always. The\n\tpragma must now appear on the initial declaration of the related\n\tsubprogram.\n\n2017-09-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Declarations): In ASIS mode,  At the end of the\n\tdeclarative list in a subprogram body, analyze aspext specifications to\n\tprovide basic semantic information, because otherwise the aspect\n\tspecifications might only be snalyzed during expansion, when related\n\tsubprograms are generated.\n\n2017-09-18  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch9.adb (Is_Simple_Barrier_Name): Follow Original_Node, in case\n\tvalidity checks have rewritten the tree.\n\n2017-09-18  Bob Duff  <duff@adacore.com>\n\n\t* sem_util.adb: Comment fixes, and remove redundant Is_Itype check.\n\n2017-09-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Save_References_In_Aggregate): When constructing a\n\tqualified exxpression for an aggregate in a generic unit, verify that\n\tthe scope of the type is itself visible and not hidden, so that the\n\tqualified expression is correctly resolved in any instance.\n\ngcc/testsuite/\n\n2017-09-18  Bob Duff  <duff@adacore.com>\n\n\t* gnat.dg/validity_check.adb: New testcase.\n\n2017-09-18  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gnat.dg/overload.ads, gnat.dg/overload.adb: New testcase.\n\n2017-09-18  Bob Duff  <duff@adacore.com>\n\n\t* gnat.dg/tagged_prefix_call.adb: New testcase.\n\nFrom-SVN: r252916", "tree": {"sha": "87fb901cfb539e595e3225fafc799a20de13ddb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87fb901cfb539e595e3225fafc799a20de13ddb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/comments", "author": null, "committer": null, "parents": [{"sha": "f1e3a534a0f331c40cf76318812e915e1482b45c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1e3a534a0f331c40cf76318812e915e1482b45c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1e3a534a0f331c40cf76318812e915e1482b45c"}], "stats": {"total": 699, "additions": 545, "deletions": 154}, "files": [{"sha": "b90a2623342f7f62f1928ad0cdffa3fe9c1f8cec", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -1,3 +1,69 @@\n+2017-09-18  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch4.adb (Complete_Object_Operation): Do not insert 'Access for\n+\treference types in the access-to-access case.\n+\n+2017-09-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Access_Attribute): Move check for the presence\n+\tof the \"aliased\" keyword on the prefix from here to...\n+\t(Resolve_Attribute) <Attribute_Access>: ...here.  Remove useless call\n+\tto Check_No_Implicit_Aliasing.\n+\t* sinfo.ads (Non_Aliased_Prefix): Delete.\n+\t(Set_Non_Aliased_Prefix): Likewise.\n+\t* sinfo.adb (Non_Aliased_Prefix): Delete.\n+\t(Set_Non_Aliased_Prefix): Likewise.\n+\n+2017-09-18  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch5.adb (Build_Formal_Container_Iteration,\n+\tExpand_Formal_Container_Element_Loop): Convert the container to the\n+\troot type before passing it to the iteration operations, so it will be\n+\tof the right type.\n+\n+2017-09-18  Bob Duff  <duff@adacore.com>\n+\n+\t* einfo.ads, validsw.ads, treepr.ads, sem_util.ads: Comment fixes.\n+\n+2017-09-18  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Array_Init_Proc): If validity checking is enabled,\n+\tand it's a bit-packed array, pass False to the Consider_IS parameter of\n+\tNeeds_Simple_Initialization.\n+\n+2017-09-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch6.adb (Check_Inline_Pragma): Link the newly generated spec to\n+\tthe preexisting body.\n+\t* sem_prag.adb (Check_Inline_Always_Placement): New routine.\n+\t(Process_Inline): Verify the placement of pragma Inline_Always. The\n+\tpragma must now appear on the initial declaration of the related\n+\tsubprogram.\n+\n+2017-09-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Declarations): In ASIS mode,  At the end of the\n+\tdeclarative list in a subprogram body, analyze aspext specifications to\n+\tprovide basic semantic information, because otherwise the aspect\n+\tspecifications might only be snalyzed during expansion, when related\n+\tsubprograms are generated.\n+\n+2017-09-18  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch9.adb (Is_Simple_Barrier_Name): Follow Original_Node, in case\n+\tvalidity checks have rewritten the tree.\n+\n+2017-09-18  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_util.adb: Comment fixes, and remove redundant Is_Itype check.\n+\n+2017-09-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Save_References_In_Aggregate): When constructing a\n+\tqualified exxpression for an aggregate in a generic unit, verify that\n+\tthe scope of the type is itself visible and not hidden, so that the\n+\tqualified expression is correctly resolved in any instance.\n+\n 2017-09-18  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch4.adb (Analyze_Qualified_Expression): Give an error if the type"}, {"sha": "13bf62019d7a2e144427d29548bdce95b4538ab6", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -323,7 +323,7 @@ package Einfo is\n --  only].  These are representation attributes which must always apply to a\n --  full non-private type, and where the attributes are always on the full\n --  type. The attribute can be referenced on a subtype (and automatically\n---  retries the value from the implementation base type). However, it is an\n+--  retrieves the value from the implementation base type). However, it is an\n --  error to try to set the attribute on other than the implementation base\n --  type, and if assertions are enabled, an attempt to set the attribute on a\n --  subtype will raise an assert error."}, {"sha": "6e90fb686a7fd2956258f93daae44b247ae5f591", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -517,6 +517,10 @@ package body Exp_Ch3 is\n \n    procedure Build_Array_Init_Proc (A_Type : Entity_Id; Nod : Node_Id) is\n       Comp_Type        : constant Entity_Id  := Component_Type (A_Type);\n+      Comp_Type_Simple : constant Boolean :=\n+        Needs_Simple_Initialization\n+          (Comp_Type, Consider_IS =>\n+             not (Validity_Check_Copies and Is_Bit_Packed_Array (A_Type)));\n       Body_Stmts       : List_Id;\n       Has_Default_Init : Boolean;\n       Index_List       : List_Id;\n@@ -557,7 +561,7 @@ package body Exp_Ch3 is\n                   Convert_To (Comp_Type,\n                     Default_Aspect_Component_Value (First_Subtype (A_Type)))));\n \n-         elsif Needs_Simple_Initialization (Comp_Type) then\n+         elsif Comp_Type_Simple then\n             Set_Assignment_OK (Comp);\n             return New_List (\n               Make_Assignment_Statement (Loc,\n@@ -589,7 +593,7 @@ package body Exp_Ch3 is\n          --  the dummy Init_Proc needed for Initialize_Scalars processing.\n \n          if not Has_Non_Null_Base_Init_Proc (Comp_Type)\n-           and then not Needs_Simple_Initialization (Comp_Type)\n+           and then not Comp_Type_Simple\n            and then not Has_Task (Comp_Type)\n            and then not Has_Default_Aspect (A_Type)\n          then\n@@ -679,7 +683,7 @@ package body Exp_Ch3 is\n       --  init_proc.\n \n       Has_Default_Init := Has_Non_Null_Base_Init_Proc (Comp_Type)\n-                            or else Needs_Simple_Initialization (Comp_Type)\n+                            or else Comp_Type_Simple\n                             or else Has_Task (Comp_Type)\n                             or else Has_Default_Aspect (A_Type);\n "}, {"sha": "e682bfd0fb491ad1a336eaa1fbc727bf1c595674", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -74,6 +74,12 @@ package body Exp_Ch5 is\n    --  Utility to create declarations and loop statement for both forms\n    --  of formal container iterators.\n \n+   function Convert_To_Iterable_Type\n+     (Container : Entity_Id; Loc : Source_Ptr) return Node_Id;\n+   --  Returns New_Occurrence_Of (Container), possibly converted to an\n+   --  ancestor type, if the type of Container inherited the Iterable\n+   --  aspect_specification from that ancestor.\n+\n    function Change_Of_Representation (N : Node_Id) return Boolean;\n    --  Determine if the right-hand side of assignment N is a type conversion\n    --  which requires a change of representation. Called only for the array\n@@ -189,7 +195,7 @@ package body Exp_Ch5 is\n             Make_Function_Call (Loc,\n               Name                   => New_Occurrence_Of (First_Op, Loc),\n               Parameter_Associations => New_List (\n-                New_Occurrence_Of (Container, Loc))));\n+                Convert_To_Iterable_Type (Container, Loc))));\n \n       --  Statement that advances cursor in loop\n \n@@ -200,7 +206,7 @@ package body Exp_Ch5 is\n             Make_Function_Call (Loc,\n               Name                   => New_Occurrence_Of (Next_Op, Loc),\n               Parameter_Associations => New_List (\n-                New_Occurrence_Of (Container, Loc),\n+                Convert_To_Iterable_Type (Container, Loc),\n                 New_Occurrence_Of (Cursor, Loc))));\n \n       --  Iterator is rewritten as a while_loop\n@@ -211,13 +217,12 @@ package body Exp_Ch5 is\n             Make_Iteration_Scheme (Loc,\n               Condition =>\n                 Make_Function_Call (Loc,\n-                  Name                   =>\n-                    New_Occurrence_Of (Has_Element_Op, Loc),\n+                  Name => New_Occurrence_Of (Has_Element_Op, Loc),\n                   Parameter_Associations => New_List (\n-                    New_Occurrence_Of (Container, Loc),\n+                    Convert_To_Iterable_Type (Container, Loc),\n                     New_Occurrence_Of (Cursor, Loc)))),\n-          Statements       => Stats,\n-          End_Label        => Empty);\n+          Statements => Stats,\n+          End_Label  => Empty);\n    end Build_Formal_Container_Iteration;\n \n    ------------------------------\n@@ -233,6 +238,26 @@ package body Exp_Ch5 is\n             not Same_Representation (Etype (Rhs), Etype (Expression (Rhs)));\n    end Change_Of_Representation;\n \n+   ------------------------------\n+   -- Convert_To_Iterable_Type --\n+   ------------------------------\n+\n+   function Convert_To_Iterable_Type\n+     (Container : Entity_Id; Loc : Source_Ptr) return Node_Id\n+   is\n+      Typ    : constant Entity_Id  := Base_Type (Etype (Container));\n+      Aspect : constant Node_Id := Find_Aspect (Typ, Aspect_Iterable);\n+      Result : Node_Id := New_Occurrence_Of (Container, Loc);\n+   begin\n+      if Entity (Aspect) /= Typ then\n+         Result := Make_Type_Conversion (Loc,\n+                     Subtype_Mark => New_Occurrence_Of (Entity (Aspect), Loc),\n+                     Expression   => Result);\n+      end if;\n+\n+      return Result;\n+   end Convert_To_Iterable_Type;\n+\n    -------------------------\n    -- Expand_Assign_Array --\n    -------------------------\n@@ -3207,7 +3232,7 @@ package body Exp_Ch5 is\n            Make_Function_Call (Loc,\n              Name                   => New_Occurrence_Of (Element_Op, Loc),\n              Parameter_Associations => New_List (\n-               New_Occurrence_Of (Container, Loc),\n+               Convert_To_Iterable_Type (Container, Loc),\n                New_Occurrence_Of (Cursor, Loc))));\n \n          Set_Statements (New_Loop,\n@@ -3226,7 +3251,7 @@ package body Exp_Ch5 is\n                Make_Function_Call (Loc,\n                  Name                   => New_Occurrence_Of (Element_Op, Loc),\n                  Parameter_Associations => New_List (\n-                   New_Occurrence_Of (Container, Loc),\n+                   Convert_To_Iterable_Type (Container, Loc),\n                    New_Occurrence_Of (Cursor, Loc))));\n \n          Prepend (Elmt_Ref, Stats);"}, {"sha": "0cd4fde15b1f40be65fae63181c590ace0e05fdb", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -6000,11 +6000,13 @@ package body Exp_Ch9 is\n \n       begin\n          --  Check if the name is a component of the protected object. If\n-         --  the expander is active, the component has been transformed into\n-         --  a renaming of _object.all.component.\n+         --  the expander is active, the component has been transformed into a\n+         --  renaming of _object.all.component. Original_Node is needed in case\n+         --  validity checking is enabled, in which case the simple object\n+         --  reference will have been rewritten.\n \n          if Expander_Active then\n-            Renamed := Renamed_Object (Entity (N));\n+            Renamed := Renamed_Object (Entity (Original_Node (N)));\n \n             return\n               Present (Renamed)"}, {"sha": "9500b1a5a18d7fad4a83da5c7ce155e1f3ccf2c1", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 49, "deletions": 60, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -1074,49 +1074,6 @@ package body Sem_Attr is\n                end if;\n             end loop;\n          end;\n-\n-         --  Check for aliased view. We allow a nonaliased prefix when within\n-         --  an instance because the prefix may have been a tagged formal\n-         --  object, which is defined to be aliased even when the actual\n-         --  might not be (other instance cases will have been caught in the\n-         --  generic). Similarly, within an inlined body we know that the\n-         --  attribute is legal in the original subprogram, and therefore\n-         --  legal in the expansion.\n-\n-         if not Is_Aliased_View (P)\n-           and then not In_Instance\n-           and then not In_Inlined_Body\n-           and then Comes_From_Source (N)\n-         then\n-            --  Here we have a non-aliased view. This is illegal unless we\n-            --  have the case of Unrestricted_Access, where for now we allow\n-            --  this (we will reject later if expected type is access to an\n-            --  unconstrained array with a thin pointer).\n-\n-            --  No need for an error message on a generated access reference\n-            --  for the controlling argument in a dispatching call: error will\n-            --  be reported when resolving the call.\n-\n-            if Aname /= Name_Unrestricted_Access then\n-               Error_Attr_P (\"prefix of % attribute must be aliased\");\n-               Check_No_Implicit_Aliasing (P);\n-\n-            --  For Unrestricted_Access, record that prefix is not aliased\n-            --  to simplify legality check later on.\n-\n-            else\n-               Set_Non_Aliased_Prefix (N);\n-            end if;\n-\n-         --  If we have an aliased view, and we have Unrestricted_Access, then\n-         --  output a warning that Unchecked_Access would have been fine, and\n-         --  change the node to be Unchecked_Access.\n-\n-         else\n-            --  For now, hold off on this change ???\n-\n-            null;\n-         end if;\n       end Analyze_Access_Attribute;\n \n       ----------------------------------\n@@ -11120,24 +11077,56 @@ package body Sem_Attr is\n                end if;\n             end if;\n \n-            --  Check for unrestricted access where expected type is a thin\n-            --  pointer to an unconstrained array.\n-\n-            if Non_Aliased_Prefix (N)\n-              and then Has_Size_Clause (Typ)\n-              and then RM_Size (Typ) = System_Address_Size\n+            --  Check for aliased view. We allow a nonaliased prefix when in\n+            --  an instance because the prefix may have been a tagged formal\n+            --  object, which is defined to be aliased even when the actual\n+            --  might not be (other instance cases will have been caught in\n+            --  the generic). Similarly, within an inlined body we know that\n+            --  the attribute is legal in the original subprogram, therefore\n+            --  legal in the expansion.\n+\n+            if not (Is_Entity_Name (P)\n+                     and then Is_Overloadable (Entity (P)))\n+              and then not (Nkind (P) = N_Selected_Component\n+                             and then\n+                            Is_Overloadable (Entity (Selector_Name (P))))\n+              and then not Is_Aliased_View (P)\n+              and then not In_Instance\n+              and then not In_Inlined_Body\n+              and then Comes_From_Source (N)\n             then\n-               declare\n-                  DT : constant Entity_Id := Designated_Type (Typ);\n-               begin\n-                  if Is_Array_Type (DT) and then not Is_Constrained (DT) then\n-                     Error_Msg_N\n-                       (\"illegal use of Unrestricted_Access attribute\", P);\n-                     Error_Msg_N\n-                       (\"\\attempt to generate thin pointer to unaliased \"\n-                        & \"object\", P);\n-                  end if;\n-               end;\n+               --  Here we have a non-aliased view. This is illegal unless we\n+               --  have the case of Unrestricted_Access, where for now we allow\n+               --  this (we will reject later if expected type is access to an\n+               --  unconstrained array with a thin pointer).\n+\n+               --  No need for an error message on a generated access reference\n+               --  for the controlling argument in a dispatching call: error\n+               --  will be reported when resolving the call.\n+\n+               if Attr_Id /= Attribute_Unrestricted_Access then\n+                  Error_Msg_N (\"prefix of % attribute must be aliased\", P);\n+\n+               --  Check for unrestricted access where expected type is a thin\n+               --  pointer to an unconstrained array.\n+\n+               elsif Has_Size_Clause (Typ)\n+                 and then RM_Size (Typ) = System_Address_Size\n+               then\n+                  declare\n+                     DT : constant Entity_Id := Designated_Type (Typ);\n+                  begin\n+                     if Is_Array_Type (DT)\n+                       and then not Is_Constrained (DT)\n+                     then\n+                        Error_Msg_N\n+                          (\"illegal use of Unrestricted_Access attribute\", P);\n+                        Error_Msg_N\n+                          (\"\\attempt to generate thin pointer to unaliased \"\n+                           & \"object\", P);\n+                     end if;\n+                  end;\n+               end if;\n             end if;\n \n             --  Mark that address of entity is taken in case of"}, {"sha": "058809e78b493f585659fc893ea5001d29899573", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -15118,10 +15118,10 @@ package body Sem_Ch12 is\n                --  preserved. In order to preserve some of this information,\n                --  wrap the aggregate in a qualified expression, using the id\n                --  of its type. For further disambiguation we qualify the type\n-               --  name with its scope (if visible) because both id's will have\n-               --  corresponding entities in an instance. This resolves most of\n-               --  the problems with missing type information on aggregates in\n-               --  instances.\n+               --  name with its scope (if visible and not hidden by a local\n+               --  homograph) because both id's will have corresponding\n+               --  entities in an instance. This resolves most of the problems\n+               --  with missing type information on aggregates in instances.\n \n                if Present (N2)\n                  and then Nkind (N2) = Nkind (N)\n@@ -15131,7 +15131,9 @@ package body Sem_Ch12 is\n                then\n                   Nam := Make_Identifier (Loc, Chars (Typ));\n \n-                  if Is_Immediately_Visible (Scope (Typ)) then\n+                  if Is_Immediately_Visible (Scope (Typ))\n+                    and then Current_Entity (Scope (Typ)) = Scope (Typ)\n+                  then\n                      Nam :=\n                        Make_Selected_Component (Loc,\n                          Prefix        =>"}, {"sha": "2d9cacaebf068bfa40e2e9e1c57d64005144adc0", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -2666,6 +2666,16 @@ package body Sem_Ch3 is\n                   Freeze_From := Last_Entity (Current_Scope);\n \n                else\n+                  --  For declarations in a subprogram body there is no issue\n+                  --  with name resolution in aspect specifications, but in\n+                  --  ASIS mode we need to preanalyze aspect specifications\n+                  --  that may otherwise only be analyzed during expansion\n+                  --  (e.g. during generation of a related subprogram).\n+\n+                  if ASIS_Mode then\n+                     Resolve_Aspects;\n+                  end if;\n+\n                   Freeze_All (First_Entity (Current_Scope), Decl);\n                   Freeze_From := Last_Entity (Current_Scope);\n                end if;\n@@ -13510,6 +13520,7 @@ package body Sem_Ch3 is\n          end if;\n \n          Constrain_Discriminated_Type (Def_Id, SI, Related_Nod);\n+         Set_First_Private_Entity (Def_Id, First_Private_Entity (T_Ent));\n \n          Set_Depends_On_Private (Def_Id, Has_Private_Component (Def_Id));\n          Set_Corresponding_Record_Type (Def_Id,"}, {"sha": "555217c2f168b2217f9883bd80392766da91b9d1", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -8554,14 +8554,21 @@ package body Sem_Ch4 is\n                  (\"expect variable in call to&\", Prefix (N), Entity (Subprog));\n             end if;\n \n-         --  Conversely, if the formal is an access parameter and the object\n-         --  is not, replace the actual with a 'Access reference. Its analysis\n-         --  will check that the object is aliased.\n+         --  Conversely, if the formal is an access parameter and the object is\n+         --  not an access type or a reference type (i.e. a type with the\n+         --  Implicit_Dereference aspect specified), replace the actual with a\n+         --  'Access reference. Its analysis will check that the object is\n+         --  aliased.\n \n          elsif Is_Access_Type (Formal_Type)\n            and then not Is_Access_Type (Etype (Obj))\n+           and then (not Has_Implicit_Dereference (Etype (Obj))\n+             or else\n+               not Is_Access_Type\n+                     (Designated_Type\n+                        (Etype (Get_Reference_Discriminant (Etype (Obj))))))\n          then\n-            --  A special case: A.all'access is illegal if A is an access to a\n+            --  A special case: A.all'Access is illegal if A is an access to a\n             --  constant and the context requires an access to a variable.\n \n             if not Is_Access_Constant (Formal_Type) then"}, {"sha": "468c112d01ec6f7d6da43af8d015437ec386d749", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -2882,6 +2882,11 @@ package body Sem_Ch6 is\n                                New_Copy_Tree (Specification (N)));\n \n                begin\n+                  --  Link the body and the generated spec\n+\n+                  Set_Corresponding_Body (Decl, Body_Id);\n+                  Set_Corresponding_Spec (N, Subp);\n+\n                   Set_Defining_Unit_Name (Specification (Decl), Subp);\n \n                   --  To ensure proper coverage when body is inlined, indicate"}, {"sha": "417de9267df44863f855b70798a9f8be3a53af33", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 240, "deletions": 23, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -9097,14 +9097,9 @@ package body Sem_Prag is\n          --  The entity of the first Ghost subprogram encountered while\n          --  processing the arguments of the pragma.\n \n-         procedure Make_Inline (Subp : Entity_Id);\n-         --  Subp is the defining unit name of the subprogram declaration. If\n-         --  the pragma is valid, call Set_Inline_Flags on Subp, as well as on\n-         --  the corresponding body, if there is one present.\n-\n-         procedure Set_Inline_Flags (Subp : Entity_Id);\n-         --  Set Has_Pragma_{No_Inline,Inline,Inline_Always} flag on Subp.\n-         --  Also set or clear Is_Inlined flag on Subp depending on Status.\n+         procedure Check_Inline_Always_Placement (Spec_Id : Entity_Id);\n+         --  Verify the placement of pragma Inline_Always with respect to the\n+         --  initial declaration of subprogram Spec_Id.\n \n          function Inlining_Not_Possible (Subp : Entity_Id) return Boolean;\n          --  Returns True if it can be determined at this stage that inlining\n@@ -9116,6 +9111,222 @@ package body Sem_Prag is\n          --  ??? is business with link symbols still valid, or does it relate\n          --  to front end ZCX which is being phased out ???\n \n+         procedure Make_Inline (Subp : Entity_Id);\n+         --  Subp is the defining unit name of the subprogram declaration. If\n+         --  the pragma is valid, call Set_Inline_Flags on Subp, as well as on\n+         --  the corresponding body, if there is one present.\n+\n+         procedure Set_Inline_Flags (Subp : Entity_Id);\n+         --  Set Has_Pragma_{No_Inline,Inline,Inline_Always} flag on Subp.\n+         --  Also set or clear Is_Inlined flag on Subp depending on Status.\n+\n+         -----------------------------------\n+         -- Check_Inline_Always_Placement --\n+         -----------------------------------\n+\n+         procedure Check_Inline_Always_Placement (Spec_Id : Entity_Id) is\n+            Spec_Decl : constant Node_Id := Unit_Declaration_Node (Spec_Id);\n+\n+            function Compilation_Unit_OK return Boolean;\n+            pragma Inline (Compilation_Unit_OK);\n+            --  Determine whether pragma Inline_Always applies to a compatible\n+            --  compilation unit denoted by Spec_Id.\n+\n+            function Declarative_List_OK return Boolean;\n+            pragma Inline (Declarative_List_OK);\n+            --  Determine whether the initial declaration of subprogram Spec_Id\n+            --  and the pragma appear in compatible declarative lists.\n+\n+            function Subprogram_Body_OK return Boolean;\n+            pragma Inline (Subprogram_Body_OK);\n+            --  Determine whether pragma Inline_Always applies to a compatible\n+            --  subprogram body denoted by Spec_Id.\n+\n+            -------------------------\n+            -- Compilation_Unit_OK --\n+            -------------------------\n+\n+            function Compilation_Unit_OK return Boolean is\n+               Comp_Unit : constant Node_Id := Parent (Spec_Decl);\n+\n+            begin\n+               --  The pragma appears after the initial declaration of a\n+               --  compilation unit.\n+\n+               --    procedure Comp_Unit;\n+               --    pragma Inline_Always (Comp_Unit);\n+\n+               --  Note that for compatibility reasons, the following case is\n+               --  also accepted.\n+\n+               --    procedure Stand_Alone_Body_Comp_Unit is\n+               --       ...\n+               --    end Stand_Alone_Body_Comp_Unit;\n+               --    pragma Inline_Always (Stand_Alone_Body_Comp_Unit);\n+\n+               return\n+                 Nkind (Comp_Unit) = N_Compilation_Unit\n+                   and then Present (Aux_Decls_Node (Comp_Unit))\n+                   and then Is_List_Member (N)\n+                   and then List_Containing (N) =\n+                              Pragmas_After (Aux_Decls_Node (Comp_Unit));\n+            end Compilation_Unit_OK;\n+\n+            -------------------------\n+            -- Declarative_List_OK --\n+            -------------------------\n+\n+            function Declarative_List_OK return Boolean is\n+               Context : constant Node_Id := Parent (Spec_Decl);\n+\n+               Init_Decl : Node_Id;\n+               Init_List : List_Id;\n+               Prag_List : List_Id;\n+\n+            begin\n+               --  Determine the proper initial declaration. In general this is\n+               --  the declaration node of the subprogram except when the input\n+               --  denotes a generic instantiation.\n+\n+               --    procedure Inst is new Gen;\n+               --    pragma Inline_Always (Inst);\n+\n+               --  In this case the original subprogram is moved inside an\n+               --  anonymous package while pragma Inline_Always remains at the\n+               --  level of the anonymous package. Use the declaration of the\n+               --  package because it reflects the placement of the original\n+               --  instantiation.\n+\n+               --    package Anon_Pack is\n+               --       procedure Inst is ... end Inst;  --  original\n+               --    end Anon_Pack;\n+\n+               --    procedure Inst renames Anon_Pack.Inst;\n+               --    pragma Inline_Always (Inst);\n+\n+               if Is_Generic_Instance (Spec_Id) then\n+                  Init_Decl := Parent (Parent (Spec_Decl));\n+                  pragma Assert (Nkind (Init_Decl) = N_Package_Declaration);\n+               else\n+                  Init_Decl := Spec_Decl;\n+               end if;\n+\n+               if Is_List_Member (Init_Decl) and then Is_List_Member (N) then\n+                  Init_List := List_Containing (Init_Decl);\n+                  Prag_List := List_Containing (N);\n+\n+                  --  The pragma and then initial declaration appear within the\n+                  --  same declarative list.\n+\n+                  if Init_List = Prag_List then\n+                     return True;\n+\n+                  --  A special case of the above is when both the pragma and\n+                  --  the initial declaration appear in different lists of a\n+                  --  package spec, protected definition, or a task definition.\n+\n+                  --    package Pack is\n+                  --       procedure Proc;\n+                  --    private\n+                  --       pragma Inline_Always (Proc);\n+                  --    end Pack;\n+\n+                  elsif Nkind_In (Context, N_Package_Specification,\n+                                           N_Protected_Definition,\n+                                           N_Task_Definition)\n+                    and then Init_List = Visible_Declarations (Context)\n+                    and then Prag_List = Private_Declarations (Context)\n+                  then\n+                     return True;\n+                  end if;\n+               end if;\n+\n+               return False;\n+            end Declarative_List_OK;\n+\n+            ------------------------\n+            -- Subprogram_Body_OK --\n+            ------------------------\n+\n+            function Subprogram_Body_OK return Boolean is\n+               Body_Decl : Node_Id;\n+\n+            begin\n+               --  The pragma appears within the declarative list of a stand-\n+               --  alone subprogram body.\n+\n+               --    procedure Stand_Alone_Body is\n+               --       pragma Inline_Always (Stand_Alone_Body);\n+               --    begin\n+               --       ...\n+               --    end Stand_Alone_Body;\n+\n+               --  The compiler creates a dummy spec in this case, however the\n+               --  pragma remains within the declarative list of the body.\n+\n+               if Nkind (Spec_Decl) = N_Subprogram_Declaration\n+                 and then not Comes_From_Source (Spec_Decl)\n+                 and then Present (Corresponding_Body (Spec_Decl))\n+               then\n+                  Body_Decl :=\n+                    Unit_Declaration_Node (Corresponding_Body (Spec_Decl));\n+\n+                  if Present (Declarations (Body_Decl))\n+                    and then Is_List_Member (N)\n+                    and then List_Containing (N) = Declarations (Body_Decl)\n+                  then\n+                     return True;\n+                  end if;\n+               end if;\n+\n+               return False;\n+            end Subprogram_Body_OK;\n+\n+         --  Start of processing for Check_Inline_Always_Placement\n+\n+         begin\n+            --  This check is relevant only for pragma Inline_Always\n+\n+            if Pname /= Name_Inline_Always then\n+               return;\n+\n+            --  Nothing to do when the pragma is internally generated on the\n+            --  assumption that it is properly placed.\n+\n+            elsif not Comes_From_Source (N) then\n+               return;\n+\n+            --  Nothing to do for internally generated subprograms that act\n+            --  as accidental homonyms of a source subprogram being inlined.\n+\n+            elsif not Comes_From_Source (Spec_Id) then\n+               return;\n+\n+            --  Nothing to do for generic formal subprograms that act as\n+            --  homonyms of another source subprogram being inlined.\n+\n+            elsif Is_Formal_Subprogram (Spec_Id) then\n+               return;\n+\n+            elsif Compilation_Unit_OK\n+              or else Declarative_List_OK\n+              or else Subprogram_Body_OK\n+            then\n+               return;\n+            end if;\n+\n+            --  At this point it is known that the pragma applies to or appears\n+            --  within a completing body, a completing stub, or a subunit.\n+\n+            Error_Msg_Name_1 := Pname;\n+            Error_Msg_Name_2 := Chars (Spec_Id);\n+            Error_Msg_Sloc   := Sloc (Spec_Id);\n+\n+            Error_Msg_N\n+              (\"pragma % must appear on initial declaration of subprogram \"\n+               & \"% defined #\", N);\n+         end Check_Inline_Always_Placement;\n+\n          ---------------------------\n          -- Inlining_Not_Possible --\n          ---------------------------\n@@ -9236,6 +9447,12 @@ package body Sem_Prag is\n             --  retrieve it as the alias of the visible subprogram instance.\n \n             if Is_Subprogram (Subp) then\n+\n+               --  Ensure that pragma Inline_Always is associated with the\n+               --  initial declaration of the subprogram.\n+\n+               Check_Inline_Always_Placement (Subp);\n+\n                if Is_Wrapper_Package (Scope (Subp)) then\n                   Inner_Subp := Subp;\n                else\n@@ -13662,8 +13879,8 @@ package body Sem_Prag is\n          --    related subprogram [body] when it is:\n \n          --       aspect on subprogram declaration\n-         --       aspect on stand alone subprogram body\n-         --       pragma on stand alone subprogram body\n+         --       aspect on stand-alone subprogram body\n+         --       pragma on stand-alone subprogram body\n \n          --    The annotation must prepare its own template when it is:\n \n@@ -14523,8 +14740,8 @@ package body Sem_Prag is\n          --    related subprogram [body] when it is:\n \n          --       aspect on subprogram declaration\n-         --       aspect on stand alone subprogram body\n-         --       pragma on stand alone subprogram body\n+         --       aspect on stand-alone subprogram body\n+         --       pragma on stand-alone subprogram body\n \n          --    The annotation must prepare its own template when it is:\n \n@@ -15463,8 +15680,8 @@ package body Sem_Prag is\n          --    related subprogram [body] when it is:\n \n          --       aspect on subprogram declaration\n-         --       aspect on stand alone subprogram body\n-         --       pragma on stand alone subprogram body\n+         --       aspect on stand-alone subprogram body\n+         --       pragma on stand-alone subprogram body\n \n          --    The annotation must prepare its own template when it is:\n \n@@ -15906,7 +16123,7 @@ package body Sem_Prag is\n                then\n                   Id := Defining_Entity (Context);\n \n-               --  Pragma Ghost applies to a stand alone subprogram body\n+               --  Pragma Ghost applies to a stand-alone subprogram body\n \n                elsif Nkind (Context) = N_Subprogram_Body\n                  and then No (Corresponding_Spec (Context))\n@@ -16050,8 +16267,8 @@ package body Sem_Prag is\n          --    related subprogram [body] when it is:\n \n          --       aspect on subprogram declaration\n-         --       aspect on stand alone subprogram body\n-         --       pragma on stand alone subprogram body\n+         --       aspect on stand-alone subprogram body\n+         --       pragma on stand-alone subprogram body\n \n          --    The annotation must prepare its own template when it is:\n \n@@ -19828,8 +20045,8 @@ package body Sem_Prag is\n          --    related subprogram [body] when it is:\n \n          --       aspect on subprogram declaration\n-         --       aspect on stand alone subprogram body\n-         --       pragma on stand alone subprogram body\n+         --       aspect on stand-alone subprogram body\n+         --       pragma on stand-alone subprogram body\n \n          --    The annotation must prepare its own template when it is:\n \n@@ -19875,8 +20092,8 @@ package body Sem_Prag is\n          --    related subprogram [body] when it is:\n \n          --       aspect on subprogram declaration\n-         --       aspect on stand alone subprogram body\n-         --       pragma on stand alone subprogram body\n+         --       aspect on stand-alone subprogram body\n+         --       pragma on stand-alone subprogram body\n \n          --    The annotation must prepare its own template when it is:\n \n@@ -21859,7 +22076,7 @@ package body Sem_Prag is\n \n                if Nkind_In (Decl, N_Entry_Body, N_Subprogram_Body) then\n \n-                  --  A stand alone subprogram body\n+                  --  A stand-alone subprogram body\n \n                   if Body_Id = Spec_Id then\n                      Check_Pragma_Conformance\n@@ -28644,7 +28861,7 @@ package body Sem_Prag is\n          Depends := Get_Pragma (Subp_Id, Pragma_Refined_Depends);\n          Global  := Get_Pragma (Subp_Id, Pragma_Refined_Global);\n \n-      --  Subprogram declaration or stand alone body case, look for pragmas\n+      --  Subprogram declaration or stand-alone body case, look for pragmas\n       --  Depends and Global\n \n       else"}, {"sha": "0b731125c7a960e7585146a4ff171e564438a9ce", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -22049,14 +22049,14 @@ package body Sem_Util is\n          end if;\n       end if;\n \n-      --  If E is an object or component, and the type of E is an anonymous\n-      --  access type with no convention set, then also set the convention of\n-      --  the anonymous access type. We do not do this for anonymous protected\n-      --  types, since protected types always have the default convention.\n+      --  If E is an object, including a component, and the type of E is an\n+      --  anonymous access type with no convention set, then also set the\n+      --  convention of the anonymous access type. We do not do this for\n+      --  anonymous protected types, since protected types always have the\n+      --  default convention.\n \n       if Present (Etype (E))\n         and then (Is_Object (E)\n-                   or else Ekind (E) = E_Component\n \n                    --  Allow E_Void (happens for pragma Convention appearing\n                    --  in the middle of a record applying to a component)\n@@ -22075,15 +22075,13 @@ package body Sem_Util is\n                Set_Has_Convention_Pragma (Typ);\n \n                --  And for the access subprogram type, deal similarly with the\n-               --  designated E_Subprogram_Type if it is also internal (which\n-               --  it always is?)\n+               --  designated E_Subprogram_Type, which is always internal.\n \n                if Ekind (Typ) = E_Anonymous_Access_Subprogram_Type then\n                   declare\n                      Dtype : constant Entity_Id := Designated_Type (Typ);\n                   begin\n                      if Ekind (Dtype) = E_Subprogram_Type\n-                       and then Is_Itype (Dtype)\n                        and then not Has_Convention_Pragma (Dtype)\n                      then\n                         Basic_Set_Convention (Dtype, Val);"}, {"sha": "30c35cb15919b9659b2ba8c56e40dad6dbda716d", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -1056,7 +1056,7 @@ package Sem_Util is\n      (Typ : Entity_Id;\n       Nam : Name_Id) return Entity_Id;\n    --  Retrieve one of the primitives First, Next, Has_Element, Element from\n-   --  the value of the Iterable aspect of a formal type.\n+   --  the value of the Iterable aspect of a type.\n \n    procedure Get_Library_Unit_Name_String (Decl_Node : Node_Id);\n    --  Retrieve the fully expanded name of the library unit declared by"}, {"sha": "4a902e82e4ff9f37347bcb8aa98925f0ba0e84f1", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2464,14 +2464,6 @@ package body Sinfo is\n       return Flag17 (N);\n    end No_Truncation;\n \n-   function Non_Aliased_Prefix\n-     (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Attribute_Reference);\n-      return Flag18 (N);\n-   end Non_Aliased_Prefix;\n-\n    function Null_Excluding_Subtype\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5774,14 +5766,6 @@ package body Sinfo is\n       Set_Flag17 (N, Val);\n    end Set_No_Truncation;\n \n-   procedure Set_Non_Aliased_Prefix\n-     (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Attribute_Reference);\n-      Set_Flag18 (N, Val);\n-   end Set_Non_Aliased_Prefix;\n-\n    procedure Set_Null_Excluding_Subtype\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "a5a6413200b819998d345937e9fd4013238a4e3b", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -2083,13 +2083,6 @@ package Sinfo is\n    --    is used for properly setting out of range values for use by pragmas\n    --    Initialize_Scalars and Normalize_Scalars.\n \n-   --  Non_Aliased_Prefix (Flag18-Sem)\n-   --    Present in N_Attribute_Reference nodes. Set only for the case of an\n-   --    Unrestricted_Access reference whose prefix is non-aliased, which is\n-   --    the case that is permitted for Unrestricted_Access except when the\n-   --    expected type is a thin pointer to unconstrained array. This flag is\n-   --    to assist in detecting this illegal use of Unrestricted_Access.\n-\n    --  Null_Excluding_Subtype (Flag16)\n    --    Present in N_Access_To_Object_Definition. Indicates that the subtype\n    --    indication carries a null-exclusion indicator, which is distinct from\n@@ -3944,7 +3937,6 @@ package Sinfo is\n       --  Do_Overflow_Check (Flag17-Sem)\n       --  Header_Size_Added (Flag11-Sem)\n       --  Must_Be_Byte_Aligned (Flag14-Sem)\n-      --  Non_Aliased_Prefix (Flag18-Sem)\n       --  Redundant_Use (Flag13-Sem)\n       --  plus fields for expression\n \n@@ -9732,9 +9724,6 @@ package Sinfo is\n    function No_Truncation\n      (N : Node_Id) return Boolean;    -- Flag17\n \n-   function Non_Aliased_Prefix\n-     (N : Node_Id) return Boolean;    -- Flag18\n-\n    function Null_Excluding_Subtype\n      (N : Node_Id) return Boolean;    -- Flag16\n \n@@ -10791,9 +10780,6 @@ package Sinfo is\n    procedure Set_No_Truncation\n      (N : Node_Id; Val : Boolean := True);    -- Flag17\n \n-   procedure Set_Non_Aliased_Prefix\n-     (N : Node_Id; Val : Boolean := True);    -- Flag18\n-\n    procedure Set_Null_Excluding_Subtype\n      (N : Node_Id; Val : Boolean := True);    -- Flag16\n \n@@ -13129,7 +13115,6 @@ package Sinfo is\n    pragma Inline (No_Minimize_Eliminate);\n    pragma Inline (No_Side_Effect_Removal);\n    pragma Inline (No_Truncation);\n-   pragma Inline (Non_Aliased_Prefix);\n    pragma Inline (Null_Excluding_Subtype);\n    pragma Inline (Null_Exclusion_Present);\n    pragma Inline (Null_Exclusion_In_Return_Present);\n@@ -13478,7 +13463,6 @@ package Sinfo is\n    pragma Inline (Set_No_Minimize_Eliminate);\n    pragma Inline (Set_No_Side_Effect_Removal);\n    pragma Inline (Set_No_Truncation);\n-   pragma Inline (Set_Non_Aliased_Prefix);\n    pragma Inline (Set_Null_Excluding_Subtype);\n    pragma Inline (Set_Null_Exclusion_Present);\n    pragma Inline (Set_Null_Exclusion_In_Return_Present);"}, {"sha": "c49d5e5a2292df93df8e87f76a92dc033b587b63", "filename": "gcc/ada/treepr.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Ftreepr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Ftreepr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.ads?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -49,7 +49,7 @@ package Treepr is\n    --  of the nodes in the list\n \n    procedure Print_Node_Subtree (N : Node_Id);\n-   --  Prints the subtree routed at a specified tree node, including all\n+   --  Prints the subtree rooted at a specified tree node, including all\n    --  referenced descendants.\n \n    procedure Print_List_Subtree (L : List_Id);"}, {"sha": "7ea181595329bfeae00dfbcf89fdc9e39d75d1c3", "filename": "gcc/ada/validsw.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fvalidsw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Fada%2Fvalidsw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvalidsw.ads?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,7 +54,7 @@ package Validsw is\n \n    Validity_Check_Default : Boolean := True;\n    --  Controls default (reference manual) validity checking. If this switch is\n-   --  set to True using -gnatVd or a 'd' in the argument of a Validity_ Checks\n+   --  set to True using -gnatVd or a 'd' in the argument of a Validity_Checks\n    --  pragma (or the initial default value is used, set True), then left side\n    --  subscripts and case statement arguments are checked for validity. This\n    --  switch is also set by default if no -gnatV switch is used and no"}, {"sha": "a84419551de0cf0d3645600d89ce5879a9695ab1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -1,3 +1,15 @@\n+2017-09-18  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat.dg/validity_check.adb: New testcase.\n+\n+2017-09-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/overload.ads, gnat.dg/overload.adb: New testcase.\n+\n+2017-09-18  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat.dg/tagged_prefix_call.adb: New testcase.\n+\n 2017-09-18  Ed Schonberg  <schonberg@adacore.com>\n \n \t* gnat.dg/default_variants.adb: New testcase."}, {"sha": "9e82815a0cb9902e9a16039b35339896ff362e69", "filename": "gcc/testsuite/gnat.dg/overload.adb", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Ftestsuite%2Fgnat.dg%2Foverload.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Ftestsuite%2Fgnat.dg%2Foverload.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foverload.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -0,0 +1,23 @@\n+--  { dg-do compile }\n+\n+package body Overload is\n+\n+   function Get (I : Integer) return Ptr1 is\n+      P : Ptr1 := null;\n+   begin\n+      return P;\n+   end;\n+\n+   function Get (I : Integer) return Ptr2 is\n+      P : Ptr2 := null;\n+   begin\n+      return P;\n+   end;\n+\n+   function F (I : Integer) return Ptr1 is\n+     P : Ptr1 := Get (I).Data'Access;\n+   begin\n+     return P;\n+   end;\n+\n+end Overload;"}, {"sha": "42ec67955685a282ebfc1fcddd5559a92947de20", "filename": "gcc/testsuite/gnat.dg/overload.ads", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Ftestsuite%2Fgnat.dg%2Foverload.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Ftestsuite%2Fgnat.dg%2Foverload.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Foverload.ads?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -0,0 +1,20 @@\n+package Overload is\n+\n+   type Rec1 is record\n+      Data : Integer;\n+   end record;\n+   type Ptr1 is access all Rec1;\n+\n+   type Rec2 is record\n+      Data : aliased Rec1;\n+   end record;\n+\n+   type Ptr2 is access Rec2;\n+\n+   function Get (I : Integer) return Ptr1;\n+\n+   function Get (I : Integer) return Ptr2;\n+\n+   function F (I : Integer) return Ptr1;\n+     \n+end Overload;"}, {"sha": "15d1ba1522392f9711de37afcf05a3591a1be15f", "filename": "gcc/testsuite/gnat.dg/tagged_prefix_call.adb", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Ftestsuite%2Fgnat.dg%2Ftagged_prefix_call.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Ftestsuite%2Fgnat.dg%2Ftagged_prefix_call.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Ftagged_prefix_call.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -0,0 +1,24 @@\n+--  { dg-do compile }\n+\n+procedure Tagged_Prefix_Call is\n+\n+   package Defs is\n+      type Database_Connection_Record is abstract tagged null record;\n+      type Database_Connection is access all Database_Connection_Record'Class;\n+\n+      procedure Start_Transaction\n+        (Self : not null access Database_Connection_Record'Class)\n+      is null;\n+\n+      type DB_Connection (Elem : access Database_Connection)\n+      is null record\n+        with Implicit_Dereference => Elem;\n+   end Defs;\n+\n+   use Defs;\n+\n+   DB  : DB_Connection(null);\n+\n+begin\n+   DB.Start_Transaction;\n+end Tagged_Prefix_Call;"}, {"sha": "a37a5955201db59b6d5a0e6d654fbab078b51360", "filename": "gcc/testsuite/gnat.dg/validity_check.adb", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Ftestsuite%2Fgnat.dg%2Fvalidity_check.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eda24e95cb9232031a0b7e0be3ca109cfd86a2d/gcc%2Ftestsuite%2Fgnat.dg%2Fvalidity_check.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvalidity_check.adb?ref=2eda24e95cb9232031a0b7e0be3ca109cfd86a2d", "patch": "@@ -0,0 +1,18 @@\n+--  { dg-do run }\n+--  { dg-options \"-cargs -O -gnatn -gnatVa -gnatws -margs\" }\n+\n+pragma Initialize_Scalars;\n+\n+procedure Validity_Check is\n+\n+   type Small_Int is mod 2**6;\n+\n+   type Arr is array (1 .. 16) of Small_Int;\n+   pragma Pack (Arr);\n+\n+   S : Small_Int;\n+   A : Arr;\n+\n+begin\n+   null;\n+end;"}]}