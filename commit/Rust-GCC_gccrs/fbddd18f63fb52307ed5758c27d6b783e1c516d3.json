{"sha": "fbddd18f63fb52307ed5758c27d6b783e1c516d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJkZGQxOGY2M2ZiNTIzMDdlZDU3NThjMjdkNmI3ODNlMWM1MTZkMw==", "commit": {"author": {"name": "Robert Schuster", "email": "thebohemian@gmx.net", "date": "2004-11-18T18:26:54Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-11-18T18:26:54Z"}, "message": "Complete 1.4 support\n\n2004-11-18  Robert Schuster <address@bogus.example.com>\n\n\tComplete 1.4 support\n\t* java/beans/PropertyDescriptor.java:\n\t(setReadMethod): New method\n\t(setWriteMethod): New method\n\t(equals): Implemented (1.4)\n\t(checkMethods): operates on arguments now (private)\n\nFrom-SVN: r90876", "tree": {"sha": "835b27b10c197286d7894b48ddcc7027880ec82a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/835b27b10c197286d7894b48ddcc7027880ec82a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbddd18f63fb52307ed5758c27d6b783e1c516d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbddd18f63fb52307ed5758c27d6b783e1c516d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbddd18f63fb52307ed5758c27d6b783e1c516d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbddd18f63fb52307ed5758c27d6b783e1c516d3/comments", "author": {"login": "thebohemian", "id": 336602, "node_id": "MDQ6VXNlcjMzNjYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/336602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thebohemian", "html_url": "https://github.com/thebohemian", "followers_url": "https://api.github.com/users/thebohemian/followers", "following_url": "https://api.github.com/users/thebohemian/following{/other_user}", "gists_url": "https://api.github.com/users/thebohemian/gists{/gist_id}", "starred_url": "https://api.github.com/users/thebohemian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thebohemian/subscriptions", "organizations_url": "https://api.github.com/users/thebohemian/orgs", "repos_url": "https://api.github.com/users/thebohemian/repos", "events_url": "https://api.github.com/users/thebohemian/events{/privacy}", "received_events_url": "https://api.github.com/users/thebohemian/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb30f5c021cd1a4f042af7579e4d44cc09c3d3a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb30f5c021cd1a4f042af7579e4d44cc09c3d3a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb30f5c021cd1a4f042af7579e4d44cc09c3d3a4"}], "stats": {"total": 837, "additions": 533, "deletions": 304}, "files": [{"sha": "fa71bbc267029ed14db4e9801fc8f10434c996aa", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbddd18f63fb52307ed5758c27d6b783e1c516d3/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbddd18f63fb52307ed5758c27d6b783e1c516d3/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fbddd18f63fb52307ed5758c27d6b783e1c516d3", "patch": "@@ -1,3 +1,13 @@\n+2004-11-18  Robert Schuster <address@bogus.example.com>\n+\n+\tComplete 1.4 support\n+\t* java/beans/PropertyDescriptor.java:\n+\t(setReadMethod): New method\n+\t(setWriteMethod): New method\n+\t(equals): Implemented (1.4)\n+\t(checkMethods): operates on arguments now (private)\n+\n+\n 2004-11-18  Mattias Rehnberg  <Mattias.Rehnberg@home.se>\n \n \t* java/net/Inet6Address.java (getHostAddress): Fix textual"}, {"sha": "b62440a2e4749f73e04bb522d44c58f4e4f7850a", "filename": "libjava/java/beans/PropertyDescriptor.java", "status": "modified", "additions": 523, "deletions": 304, "changes": 827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbddd18f63fb52307ed5758c27d6b783e1c516d3/libjava%2Fjava%2Fbeans%2FPropertyDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbddd18f63fb52307ed5758c27d6b783e1c516d3/libjava%2Fjava%2Fbeans%2FPropertyDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyDescriptor.java?ref=fbddd18f63fb52307ed5758c27d6b783e1c516d3", "patch": "@@ -1,5 +1,5 @@\n /* java.beans.PropertyDescriptor\n-   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2001, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,7 +35,6 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.beans;\n \n import java.lang.reflect.Method;\n@@ -58,317 +57,537 @@\n  ** </OL>\n  **\n  ** @author John Keiser\n- ** @since JDK1.1\n- ** @version 1.1.0, 26 Jul 1998\n+ ** @author Robert Schuster <thebohemian@gmx.net>\n+ ** @since 1.1\n+ ** @status updated to 1.4\n  **/\n \n-public class PropertyDescriptor extends FeatureDescriptor {\n-  Class propertyType;\n-  Method getMethod;\n-  Method setMethod;\n-  \n-  Class propertyEditorClass;\n-  boolean bound;\n-  boolean constrained;\n-  \n-  PropertyDescriptor(String name) {\n-    setName(name);\n-  }\n-  \n-  /** Create a new PropertyDescriptor by introspection.\n-   ** This form of constructor creates the PropertyDescriptor by\n-   ** looking for a getter method named <CODE>get&lt;name&gt;()</CODE>\n-   ** (or, optionally, if the property is boolean,\n-   ** <CODE>is&lt;name&gt;()</CODE>) and\n-   ** <CODE>set&lt;name&gt;()</CODE> in class\n-   ** <CODE>&lt;beanClass&gt;</CODE>, where &lt;name&gt; has its\n-   ** first letter capitalized by the constructor.<P>\n-   **\n-   ** <B>Implementation note:</B> If there is both are both isXXX and\n-   ** getXXX methods, the former is used in preference to the latter.\n-   ** We do not check that an isXXX method returns a boolean. In both\n-   ** cases, this matches the behaviour of JDK 1.4<P>\n-   **\n-   ** @param name the programmatic name of the property, usually\n-   **             starting with a lowercase letter (e.g. fooManChu\n-   **             instead of FooManChu).\n-   ** @param beanClass the class the get and set methods live in.\n-   ** @exception IntrospectionException if the methods are not found \n-   **            or invalid.\n-   **/\n-  public PropertyDescriptor(String name, Class beanClass) \n-    throws IntrospectionException \n-  {\n-    setName(name);\n-    if (name.length() == 0) {\n-      throw new IntrospectionException(\"empty property name\");\n+public class PropertyDescriptor extends FeatureDescriptor\n+{\n+    Class propertyType;\n+    Method getMethod;\n+    Method setMethod;\n+\n+    Class propertyEditorClass;\n+    boolean bound;\n+    boolean constrained;\n+\n+    PropertyDescriptor(String name)\n+    {\n+        setName(name);\n     }\n-    String caps = Character.toUpperCase(name.charAt(0)) + name.substring(1);\n-    findMethods(beanClass, \"is\" + caps, \"get\" + caps, \"set\" + caps);\n-    if (getMethod == null) {\n-      throw new IntrospectionException(\"Cannot find an is\" + caps + \n-\t\t\t\t       \" or get\" + caps + \" method\");\n+\n+    /** Create a new PropertyDescriptor by introspection.\n+     ** This form of constructor creates the PropertyDescriptor by\n+     ** looking for a getter method named <CODE>get&lt;name&gt;()</CODE>\n+     ** (or, optionally, if the property is boolean,\n+     ** <CODE>is&lt;name&gt;()</CODE>) and\n+     ** <CODE>set&lt;name&gt;()</CODE> in class\n+     ** <CODE>&lt;beanClass&gt;</CODE>, where &lt;name&gt; has its\n+     ** first letter capitalized by the constructor.<P>\n+     **\n+     ** Note that using this constructor the given property must be read- <strong>and</strong>\n+     ** writeable. If the implementation does not both, a read and a write method, an\n+     ** <code>IntrospectionException</code> is thrown.\n+     **\n+     ** <B>Implementation note:</B> If there is both are both isXXX and\n+     ** getXXX methods, the former is used in preference to the latter.\n+     ** We do not check that an isXXX method returns a boolean. In both\n+     ** cases, this matches the behaviour of JDK 1.4<P>\n+     **\n+     ** @param name the programmatic name of the property, usually\n+     **             starting with a lowercase letter (e.g. fooManChu\n+     **             instead of FooManChu).\n+     ** @param beanClass the class the get and set methods live in.\n+     ** @exception IntrospectionException if the methods are not found \n+     **            or invalid.\n+     **/\n+    public PropertyDescriptor(String name, Class beanClass)\n+        throws IntrospectionException\n+    {\n+        setName(name);\n+        if (name.length() == 0)\n+        {\n+            throw new IntrospectionException(\"empty property name\");\n+        }\n+        String caps = Character.toUpperCase(name.charAt(0)) + name.substring(1);\n+        findMethods(beanClass, \"is\" + caps, \"get\" + caps, \"set\" + caps);\n+\n+        if (getMethod == null)\n+        {\n+            throw new IntrospectionException(\n+                \"Cannot find a is\" + caps + \" or get\" + caps + \" method\");\n+        }\n+\n+        if (setMethod == null)\n+        {\n+            throw new IntrospectionException(\n+                \"Cannot find a \" + caps + \" method\");\n+        }\n+\n+        // finally check the methods compatibility        \n+        checkMethods(getMethod, setMethod);\n     }\n-    if (setMethod == null) {\n-      throw new IntrospectionException(\"Cannot find a \" + caps + \" method\");\n+\n+    /** Create a new PropertyDescriptor by introspection.\n+     ** This form of constructor allows you to specify the\n+     ** names of the get and set methods to search for.<P>\n+     **\n+     ** <B>Implementation note:</B> If there is a get method (or\n+     ** boolean isXXX() method), then the return type of that method\n+     ** is used to find the set method.  If there is no get method,\n+     ** then the set method is searched for exhaustively.<P>\n+     **\n+     ** <B>Spec note:</B>\n+     ** If there is no get method and multiple set methods with\n+     ** the same name and a single parameter (different type of course),\n+     ** then an IntrospectionException is thrown.  While Sun's spec\n+     ** does not state this, it can make Bean behavior different on\n+     ** different systems (since method order is not guaranteed) and as\n+     ** such, can be treated as a bug in the spec.  I am not aware of\n+     ** whether Sun's implementation catches this.\n+     **\n+     ** @param name the programmatic name of the property, usually\n+     **             starting with a lowercase letter (e.g. fooManChu\n+     **             instead of FooManChu).\n+     ** @param beanClass the class the get and set methods live in.\n+     ** @param getMethodName the name of the get method or <code>null</code> if the property is write-only.\n+     ** @param setMethodName the name of the set method or <code>null</code> if the property is read-only.\n+     ** @exception IntrospectionException if the methods are not found \n+     **            or invalid.\n+     **/\n+    public PropertyDescriptor(\n+        String name,\n+        Class beanClass,\n+        String getMethodName,\n+        String setMethodName)\n+        throws IntrospectionException\n+    {\n+        setName(name);\n+        findMethods(beanClass, getMethodName, null, setMethodName);\n+\n+        if (getMethod == null && getMethodName != null)\n+        {\n+            throw new IntrospectionException(\n+                \"Cannot find a getter method called \" + getMethodName);\n+        }\n+\n+        if (setMethod == null && setMethodName != null)\n+        {\n+            throw new IntrospectionException(\n+                \"Cannot find a setter method called \" + setMethodName);\n+        }\n+\n+        checkMethods(getMethod, setMethod);\n     }\n-    checkMethods();\n-  }\n-  \n-  /** Create a new PropertyDescriptor by introspection.\n-   ** This form of constructor allows you to specify the\n-   ** names of the get and set methods to search for.<P>\n-   **\n-   ** <B>Implementation note:</B> If there is a get method (or\n-   ** boolean isXXX() method), then the return type of that method\n-   ** is used to find the set method.  If there is no get method,\n-   ** then the set method is searched for exhaustively.<P>\n-   **\n-   ** <B>Spec note:</B>\n-   ** If there is no get method and multiple set methods with\n-   ** the same name and a single parameter (different type of course),\n-   ** then an IntrospectionException is thrown.  While Sun's spec\n-   ** does not state this, it can make Bean behavior different on\n-   ** different systems (since method order is not guaranteed) and as\n-   ** such, can be treated as a bug in the spec.  I am not aware of\n-   ** whether Sun's implementation catches this.\n-   **\n-   ** @param name the programmatic name of the property, usually\n-   **             starting with a lowercase letter (e.g. fooManChu\n-   **             instead of FooManChu).\n-   ** @param beanClass the class the get and set methods live in.\n-   ** @param getMethodName the name of the get method.\n-   ** @param setMethodName the name of the set method.\n-   ** @exception IntrospectionException if the methods are not found \n-   **            or invalid.\n-   **/\n-  public PropertyDescriptor(String name, Class beanClass, \n-\t\t\t    String getMethodName, String setMethodName) \n-    throws IntrospectionException \n-  {\n-    setName(name);\n-    findMethods(beanClass, getMethodName, null, setMethodName);\n-    if (getMethod == null && getMethodName != null) {\n-      throw new IntrospectionException(\"Cannot find a getter method called \" + \n-\t\t\t\t       getMethodName);\n+\n+    /** Create a new PropertyDescriptor using explicit Methods.\n+     ** Note that the methods will be checked for conformance to standard\n+     ** Property method rules, as described above at the top of this class.\n+     **<br>\n+     ** It is possible to call this method with both <code>Method</code> arguments\n+     ** being <code>null</code>. In such a case the property type is <code>null</code>.\n+     ** \n+     ** @param name the programmatic name of the property, usually\n+     **             starting with a lowercase letter (e.g. fooManChu\n+     **             instead of FooManChu).\n+     ** @param readMethod the read method or <code>null</code> if the property is write-only.\n+     ** @param writeMethod the write method or <code>null</code> if the property is read-only.\n+     ** @exception IntrospectionException if the methods are not found \n+     **            or invalid.\n+     **/\n+    public PropertyDescriptor(\n+        String name,\n+        Method readMethod,\n+        Method writeMethod)\n+        throws IntrospectionException\n+    {\n+        setName(name);\n+        getMethod = readMethod;\n+        setMethod = writeMethod;\n+\n+        if (getMethod != null)\n+        {\n+            this.propertyType = getMethod.getReturnType();\n+        }\n+        else if (setMethod != null)\n+        {\n+            this.propertyType = setMethod.getParameterTypes()[0];\n+        }\n+\n+        checkMethods(getMethod, setMethod);\n     }\n-    if (setMethod == null && setMethodName != null) {\n-      throw new IntrospectionException(\"Cannot find a setter method called \" + \n-\t\t\t\t       setMethodName);\n+\n+    /** Get the property type.\n+     ** This is the type the get method returns and the set method\n+     ** takes in.\n+     **/\n+    public Class getPropertyType()\n+    {\n+        return propertyType;\n     }\n-    checkMethods();\n-  }\n-  \n-  /** Create a new PropertyDescriptor using explicit Methods.\n-   ** Note that the methods will be checked for conformance to standard\n-   ** Property method rules, as described above at the top of this class.\n-   ** \n-   ** @param name the programmatic name of the property, usually\n-   **             starting with a lowercase letter (e.g. fooManChu\n-   **             instead of FooManChu).\n-   ** @param getMethod the get method.\n-   ** @param setMethod the set method.\n-   ** @exception IntrospectionException if the methods are not found \n-   **            or invalid.\n-   **/\n-  public PropertyDescriptor(String name, Method getMethod, Method setMethod)\n-    throws IntrospectionException \n-  {\n-    setName(name);\n-    this.getMethod = getMethod;\n-    this.setMethod = setMethod;\n-    if (getMethod != null) {\n-      this.propertyType = getMethod.getReturnType();\n-    } \n-    else if (setMethod != null) {\n-      this.propertyType = setMethod.getParameterTypes()[0];\n+\n+    /** Get the get method.  Why they call it readMethod here and\n+     ** get everywhere else is beyond me.\n+     **/\n+    public Method getReadMethod()\n+    {\n+        return getMethod;\n+    }\n+\n+    /** Sets the read method.<br/>\n+     * The read method is used to retrieve the value of a property. A legal\n+     * read method must have no arguments. Its return type must not be\n+     * <code>void</code>. If this methods succeeds the property type\n+     * is adjusted to the return type of the read method.<br/>\n+     * <br/>\n+     * It is legal to set the read and the write method to <code>null</code>\n+     * or provide method which have been declared in distinct classes.\n+     * \n+     * @param readMethod The new method to be used or <code>null</code>.\n+     * @throws IntrospectionException If the given method is invalid.\n+     * @since 1.2\n+     */\n+    public void setReadMethod(Method readMethod) throws IntrospectionException\n+    {\n+        checkMethods(readMethod, setMethod);\n+\n+        getMethod = readMethod;\n+    }\n+\n+    /** Get the set method.  Why they call it writeMethod here and\n+     ** set everywhere else is beyond me.\n+     **/\n+    public Method getWriteMethod()\n+    {\n+        return setMethod;\n+    }\n+\n+    /** Sets the write method.<br/>\n+     * The write method is used to set the value of a property. A legal write method\n+     * must have a single argument which can be assigned to the property. If no\n+     * read method exists the property type changes to the argument type of the\n+     * write method.<br/>\n+     * <br/>\n+     * It is legal to set the read and the write method to <code>null</code>\n+     * or provide method which have been declared in distinct classes.\n+     * \n+     * @param writeMethod The new method to be used or <code>null</code>.\n+     * @throws IntrospectionException If the given method is invalid.\n+     * @since 1.2\n+     */\n+    public void setWriteMethod(Method writeMethod)\n+        throws IntrospectionException\n+    {\n+        propertyType = checkMethods(getMethod, writeMethod);\n+\n+        setMethod = writeMethod;\n     }\n-    checkMethods();\n-  }\n-  \n-  /** Get the property type.\n-   ** This is the type the get method returns and the set method\n-   ** takes in.\n-   **/\n-  public Class getPropertyType() {\n-    return propertyType;\n-  }\n-  \n-  /** Get the get method.  Why they call it readMethod here and\n-   ** get everywhere else is beyond me.\n-   **/\n-  public Method getReadMethod() {\n-    return getMethod;\n-  }\n-  \n-  /** Get the set method.  Why they call it writeMethod here and\n-   ** set everywhere else is beyond me.\n-   **/\n-  public Method getWriteMethod() {\n-    return setMethod;\n-  }\n-  \n-  /** Get whether the property is bound.  Defaults to false. **/\n-  public boolean isBound() {\n-    return bound;\n-  }\n-  \n-  /** Set whether the property is bound.\n-   ** As long as the the bean implements addPropertyChangeListener() and\n-   ** removePropertyChangeListener(), setBound(true) may safely be called.<P>\n-   ** If these things are not true, then the behavior of the system\n-   ** will be undefined.<P>\n-   **\n-   ** When a property is bound, its set method is required to fire the\n-   ** <CODE>PropertyChangeListener.propertyChange())</CODE> event\n-   ** after the value has changed.\n-   ** @param bound whether the property is bound or not.\n-   **/\n-  public void setBound(boolean bound) {\n-    this.bound = bound;\n-  }\n-  \n-  /** Get whether the property is constrained.  Defaults to false. **/\n-  public boolean isConstrained() {\n-    return constrained;\n-  }\n-  \n-  /** Set whether the property is constrained.\n-   ** If the set method throws <CODE>java.beans.PropertyVetoException</CODE>\n-   ** (or subclass thereof) and the bean implements addVetoableChangeListener()\n-   ** and removeVetoableChangeListener(), then setConstrained(true) may safely\n-   ** be called.  Otherwise, the system behavior is undefined.\n-   ** <B>Spec note:</B> given those strict parameters, it would be nice if it\n-   ** got set automatically by detection, but oh well.<P>\n-   ** When a property is constrained, its set method is required to:<P>\n-   ** <OL>\n-   ** <LI>Fire the <CODE>VetoableChangeListener.vetoableChange()</CODE>\n-   **     event notifying others of the change and allowing them a chance to\n-   **     say it is a bad thing.</LI>\n-   ** <LI>If any of the listeners throws a PropertyVetoException, then\n-   **     it must fire another vetoableChange() event notifying the others\n-   **     of a reversion to the old value (though, of course, the change\n-   **     was never made).  Then it rethrows the PropertyVetoException and\n-   **     exits.</LI>\n-   ** <LI>If all has gone well to this point, the value may be changed.</LI>\n-   ** </OL>\n-   ** @param constrained whether the property is constrained or not.\n-   **/\n-  public void setConstrained(boolean constrained) {\n-    this.constrained = constrained;\n-  }\n-  \n-  /** Get the PropertyEditor class.  Defaults to null. **/\n-  public Class getPropertyEditorClass() {\n-    return propertyEditorClass;\n-  }\n-  \n-  /** Set the PropertyEditor class.  If the class does not implement\n-   ** the PropertyEditor interface, you will likely get an exception\n-   ** late in the game.\n-   ** @param propertyEditorClass the PropertyEditor class for this \n-   **        class to use.\n-   **/\n-  public void setPropertyEditorClass(Class propertyEditorClass) {\n-    this.propertyEditorClass = propertyEditorClass;\n-  }\n-  \n-  private void findMethods(Class beanClass, String getMethodName1, \n-\t\t\t   String getMethodName2, String setMethodName) \n-    throws IntrospectionException \n-  {\n-    try {\n-      // Try the first get method name\n-      if (getMethodName1 != null) {\n-\ttry {\n-\t  getMethod = beanClass.getMethod(getMethodName1, new Class[0]);\n-\t} \n-\tcatch (NoSuchMethodException e) {\n-\t}\n-      }\n-\n-      // Fall back to the second get method name\n-      if (getMethod == null && getMethodName2 != null) {\n-\ttry {\n-\t  getMethod = beanClass.getMethod(getMethodName2, new Class[0]);\n-\t} \n-\tcatch (NoSuchMethodException e) {\n-\t}\n-      }\n-\n-      // Try the set method name\n-      if (setMethodName != null) {\n-\tif (getMethod != null) {\n-\t  // If there is a get method, use its return type to help\n-\t  // select the corresponding set method.\n-\t  Class propertyType = getMethod.getReturnType();\n-\t  if (propertyType == Void.TYPE) {\n-\t    String msg = \"The property's read method has return type 'void'\";\n-\t    throw new IntrospectionException(msg);\n-\t  }\n-\t  \n-\t  Class[] setArgs = new Class[]{propertyType};\n-\t  try {\n-\t    setMethod = beanClass.getMethod(setMethodName, setArgs);\n-\t  } \n-\t  catch (NoSuchMethodException e) {\n-\t  }\n-\t}\n-\telse if (getMethodName1 == null && getMethodName2 == null) {\n-\t  // If this is a write-only property, choose the first set method\n-\t  // with the required name, one parameter and return type 'void'\n-\t  Method[] methods = beanClass.getMethods();\n-\t  for (int i = 0; i < methods.length; i++) {\n-\t    if (methods[i].getName().equals(setMethodName) &&\n-\t\tmethods[i].getParameterTypes().length == 1 &&\n-\t\tmethods[i].getReturnType() == Void.TYPE) {\n-\t      setMethod = methods[i];\n-\t      break;\n-\t    }\n-\t  }\n-\t}\n-      }\n-    } \n-    catch (SecurityException e) {\n-      // FIXME -- shouldn't we just allow SecurityException to propagate?\n-      String msg = \"SecurityException thrown on attempt to access methods.\";\n-      throw new IntrospectionException(msg);\n+\n+    /** Get whether the property is bound.  Defaults to false. **/\n+    public boolean isBound()\n+    {\n+        return bound;\n     }\n-  }\n-\n-  private void checkMethods() \n-    throws IntrospectionException\n-  {\n-    if (getMethod != null) {\n-      if (getMethod.getParameterTypes().length > 0) {\n-\tthrow new IntrospectionException(\"get method has parameters\");\n-      }\n-      this.propertyType = getMethod.getReturnType();\n-      if (propertyType == Void.TYPE) {\n-\tthrow new IntrospectionException(\"get method has void return type\");\n-      }\n+\n+    /** Set whether the property is bound.\n+     ** As long as the the bean implements addPropertyChangeListener() and\n+     ** removePropertyChangeListener(), setBound(true) may safely be called.<P>\n+     ** If these things are not true, then the behavior of the system\n+     ** will be undefined.<P>\n+     **\n+     ** When a property is bound, its set method is required to fire the\n+     ** <CODE>PropertyChangeListener.propertyChange())</CODE> event\n+     ** after the value has changed.\n+     ** @param bound whether the property is bound or not.\n+     **/\n+    public void setBound(boolean bound)\n+    {\n+        this.bound = bound;\n     }\n-    if (setMethod != null) {\n-      if (setMethod.getParameterTypes().length != 1) {\n-\tString msg = \"set method does not have exactly one parameter\"; \n-\tthrow new IntrospectionException(msg);\n-      }\n-      if (getMethod == null) {\n-\tpropertyType = setMethod.getParameterTypes()[0];\n-      }\n-      else {\n-\tif (!propertyType.equals(setMethod.getParameterTypes()[0])) {\n-\t  String msg = \"set and get methods do not share the same type\";\n-\t  throw new IntrospectionException(msg);\n-\t}\n-\tif ((!getMethod.getDeclaringClass().\n-\t     isAssignableFrom(setMethod.getDeclaringClass())) &&\n-\t    (!setMethod.getDeclaringClass().\n-\t     isAssignableFrom(getMethod.getDeclaringClass()))) {\n-\t  String msg = \"set and get methods are not in the same class.\";\n-\t  throw new IntrospectionException(msg);\n-\t}\n-      }\n+\n+    /** Get whether the property is constrained.  Defaults to false. **/\n+    public boolean isConstrained()\n+    {\n+        return constrained;\n+    }\n+\n+    /** Set whether the property is constrained.\n+     ** If the set method throws <CODE>java.beans.PropertyVetoException</CODE>\n+     ** (or subclass thereof) and the bean implements addVetoableChangeListener()\n+     ** and removeVetoableChangeListener(), then setConstrained(true) may safely\n+     ** be called.  Otherwise, the system behavior is undefined.\n+     ** <B>Spec note:</B> given those strict parameters, it would be nice if it\n+     ** got set automatically by detection, but oh well.<P>\n+     ** When a property is constrained, its set method is required to:<P>\n+     ** <OL>\n+     ** <LI>Fire the <CODE>VetoableChangeListener.vetoableChange()</CODE>\n+     **     event notifying others of the change and allowing them a chance to\n+     **     say it is a bad thing.</LI>\n+     ** <LI>If any of the listeners throws a PropertyVetoException, then\n+     **     it must fire another vetoableChange() event notifying the others\n+     **     of a reversion to the old value (though, of course, the change\n+     **     was never made).  Then it rethrows the PropertyVetoException and\n+     **     exits.</LI>\n+     ** <LI>If all has gone well to this point, the value may be changed.</LI>\n+     ** </OL>\n+     ** @param constrained whether the property is constrained or not.\n+     **/\n+    public void setConstrained(boolean constrained)\n+    {\n+        this.constrained = constrained;\n     }\n-  }\n+\n+    /** Get the PropertyEditor class.  Defaults to null. **/\n+    public Class getPropertyEditorClass()\n+    {\n+        return propertyEditorClass;\n+    }\n+\n+    /** Set the PropertyEditor class.  If the class does not implement\n+     ** the PropertyEditor interface, you will likely get an exception\n+     ** late in the game.\n+     ** @param propertyEditorClass the PropertyEditor class for this \n+     **        class to use.\n+     **/\n+    public void setPropertyEditorClass(Class propertyEditorClass)\n+    {\n+        this.propertyEditorClass = propertyEditorClass;\n+    }\n+\n+    private void findMethods(\n+        Class beanClass,\n+        String getMethodName1,\n+        String getMethodName2,\n+        String setMethodName)\n+        throws IntrospectionException\n+    {\n+        try\n+        {\n+            // Try the first get method name\n+            if (getMethodName1 != null)\n+            {\n+                try\n+                {\n+                    getMethod =\n+                        beanClass.getMethod(getMethodName1, new Class[0]);\n+                }\n+                catch (NoSuchMethodException e)\n+                {}\n+            }\n+\n+            // Fall back to the second get method name\n+            if (getMethod == null && getMethodName2 != null)\n+            {\n+                try\n+                {\n+                    getMethod =\n+                        beanClass.getMethod(getMethodName2, new Class[0]);\n+                }\n+                catch (NoSuchMethodException e)\n+                {}\n+            }\n+\n+            // Try the set method name\n+            if (setMethodName != null)\n+            {\n+                if (getMethod != null)\n+                {\n+                    // If there is a get method, use its return type to help\n+                    // select the corresponding set method.\n+                    Class propertyType = getMethod.getReturnType();\n+                    if (propertyType == Void.TYPE)\n+                    {\n+                        String msg =\n+                            \"The property's read method has return type 'void'\";\n+                        throw new IntrospectionException(msg);\n+                    }\n+\n+                    Class[] setArgs = new Class[] { propertyType };\n+                    try\n+                    {\n+                        setMethod = beanClass.getMethod(setMethodName, setArgs);\n+                    }\n+                    catch (NoSuchMethodException e)\n+                    {}\n+                }\n+                else if (getMethodName1 == null && getMethodName2 == null)\n+                {\n+                    // If this is a write-only property, choose the first set method\n+                    // with the required name, one parameter and return type 'void'\n+                    Method[] methods = beanClass.getMethods();\n+                    for (int i = 0; i < methods.length; i++)\n+                    {\n+                        if (methods[i].getName().equals(setMethodName)\n+                            && methods[i].getParameterTypes().length == 1\n+                            && methods[i].getReturnType() == Void.TYPE)\n+                        {\n+                            setMethod = methods[i];\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        catch (SecurityException e)\n+        {\n+            // FIXME -- shouldn't we just allow SecurityException to propagate?\n+            String msg =\n+                \"SecurityException thrown on attempt to access methods.\";\n+            throw new IntrospectionException(msg);\n+        }\n+    }\n+\n+    /** Checks whether the given <code>Method</code> instances are legal read and\n+     * write methods. The following requirements must be met:<br/>\n+     * <ul>\n+     * <li>the read method must not have an argument</li>\n+     * <li>the read method must have a non void return type</li>\n+     * <li>the read method may not exist</li>\n+     * <li>the write method must have a single argument</li>\n+     * <li>the property type and the read method's return type must be assignable from the\n+     * write method's argument type</li>\n+     * <li>the write method may not exist</li>\n+     * <ul>\n+     * While checking the methods a common new property type is calculated. If the method\n+     * succeeds this property type is returned.<br/>\n+     * <br/>\n+     * For compatibility this has to be noted:<br/>\n+     * The two methods are allowed to be defined in two distinct classes and may both be null.\n+     * \n+     * @param readMethod The new read method to check.\n+     * @param writeMethod The new write method to check.\n+     * @return The common property type of the two method.\n+     * @throws IntrospectionException If any of the above requirements are not met.\n+     */\n+    private Class checkMethods(Method readMethod, Method writeMethod)\n+        throws IntrospectionException\n+    {\n+        Class newPropertyType = propertyType;\n+\n+        // a valid read method has zero arguments and a non-void return type.\n+        if (readMethod != null)\n+        {\n+            if (readMethod.getParameterTypes().length > 0)\n+            {\n+                throw new IntrospectionException(\"read method has unexpected parameters\");\n+            }\n+\n+            newPropertyType = readMethod.getReturnType();\n+\n+            if (newPropertyType == Void.TYPE)\n+            {\n+                throw new IntrospectionException(\"read method return type is void\");\n+            }\n+        }\n+\n+        // a valid write method has one argument which can be assigned to the property\n+        if (writeMethod != null)\n+        {\n+            if (writeMethod.getParameterTypes().length != 1)\n+            {\n+                String msg = \"write method does not have exactly one parameter\";\n+                throw new IntrospectionException(msg);\n+            }\n+\n+            if (readMethod == null)\n+            {\n+                // changes the property type if there is no read method\n+                newPropertyType = writeMethod.getParameterTypes()[0];\n+            }\n+            else\n+            {\n+                // checks whether the write method can be assigned to the return type of the read\n+                // method (if this is not the case, the methods are not compatible)\n+                // note: newPropertyType may be null if no methods or method names have been\n+                // delivered in the constructor.\n+                if (newPropertyType != null\n+                    && !newPropertyType.isAssignableFrom(\n+                        writeMethod.getParameterTypes()[0]))\n+                {\n+                    // note: newPropertyType is the same as readMethod.getReturnType() at this point\n+                    throw new IntrospectionException(\"read and write method are not compatible\");\n+                }\n+\n+                /* note: the check whether both method are defined in related classes makes sense but is not\n+                 * done in the JDK. \n+                 * I leave this code here in case someone at Sun decides to add that functionality in later versions (rschuster)\n+                if ((!readMethod\n+                    .getDeclaringClass()\n+                    .isAssignableFrom(writeMethod.getDeclaringClass()))\n+                    && (!writeMethod\n+                        .getDeclaringClass()\n+                        .isAssignableFrom(readMethod.getDeclaringClass())))\n+                {\n+                    String msg =\n+                        \"set and get methods are not in the same class.\";\n+                    throw new IntrospectionException(msg);\n+                }\n+                */\n+\n+            }\n+        }\n+\n+        return newPropertyType;\n+    }\n+\n+    /** Compares this <code>PropertyDescriptor</code> against the\n+     * given object.\n+     * Two PropertyDescriptors are equals if\n+     * <ul>\n+     * <li>the read methods are equal</li>\n+     * <li>the write methods are equal</li>\n+     * <li>the property types are equals</li>\n+     * <li>the property editor classes are equal</li>\n+     * <li>the flags (constrained and bound) are equal</li>\n+     * </ul>\n+     * @return Whether both objects are equal according to the rules given above.\n+     * @since 1.4\n+    */\n+    public boolean equals(Object o)\n+    {\n+        if (o instanceof PropertyDescriptor)\n+        {\n+            PropertyDescriptor that = (PropertyDescriptor) o;\n+\n+            // compares the property types and checks the case where both are null\n+            boolean samePropertyType =\n+                (propertyType == null)\n+                    ? that.propertyType == null\n+                    : propertyType.equals(that.propertyType);\n+\n+            // compares the property editor classes and checks the case where both are null\n+            boolean samePropertyEditorClass =\n+                (propertyEditorClass == null)\n+                    ? that.propertyEditorClass == null\n+                    : propertyEditorClass.equals(that.propertyEditorClass);\n+\n+            // compares the flags for equality\n+            boolean sameFlags =\n+                bound == that.bound && constrained == that.constrained;\n+\n+            // compares the read methods and checks the case where both are null\n+            boolean sameReadMethod =\n+                (getMethod == null)\n+                    ? that.getMethod == null\n+                    : getMethod.equals(that.getMethod);\n+\n+            boolean sameWriteMethod =\n+                (setMethod == null)\n+                    ? that.setMethod == null\n+                    : setMethod.equals(that.setMethod);\n+\n+            return samePropertyType\n+                && sameFlags\n+                && sameReadMethod\n+                && sameWriteMethod\n+                && samePropertyEditorClass;\n+        }\n+        else\n+        {\n+            return false;\n+        }\n+        \n+    }\n+\n }"}]}