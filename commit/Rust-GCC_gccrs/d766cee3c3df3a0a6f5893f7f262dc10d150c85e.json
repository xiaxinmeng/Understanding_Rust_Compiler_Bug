{"sha": "d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc2NmNlZTNjM2RmM2EwYTZmNTg5M2Y3ZjI2MmRjMTBkMTUwYzg1ZQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-08-14T08:37:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:37:26Z"}, "message": "a-stzsup.adb, [...]: Fix warnings for range tests optimized out.\n\n2007-08-14  Robert Dewar  <dewar@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* a-stzsup.adb, nlists.adb, lib-util.adb, treepr.adb, \n\ta-stwisu.adb, a-strsup.adb: Fix warnings for range\n\ttests optimized out.\n\n\t* exp_ch4.adb (Expand_N_In): Add warnings for range tests optimized out.\n\t(Get_Allocator_Final_List): For the case of an anonymous access type\n\tthat has a specified Associated_Final_Chain, do not go up to the\n\tenclosing scope.\n\t(Expand_N_Type_Conversion): Test for the case of renamings of access\n\tparameters when deciding whether to apply a run-time accessibility\n\tcheck.\n\t(Convert_Aggr_In_Allocator): Use Insert_Actions to place expanded\n\taggregate code before allocator, and ahead of declaration for\n\ttemporary, to prevent access before elaboration when the allocator is\n\tan actual for an access parameter.\n\t(Expand_N_Type_Conversion): On an access type conversion involving an\n\taccess parameter, do not apply an accessibility check when the\n\toperand's original node was an attribute other than 'Access. We now\n\tcreate access conversions for the expansion of 'Unchecked_Access and\n\t'Unrestricted_Access in certain cases and clearly accessibility should\n\tnot be checked for those.\n\n\t* exp_ch6.ads, exp_ch6.adb (Add_Call_By_Copy_Code): For an actual that\n\tincludes a type conversion of a packed component that has been expanded,\n\trecover the original expression for the object, and use this expression\n\tin the post-call assignment statement, so that the assignment is made\n\tto the object and not to a back-end temporary.\n\t(Freeze_Subprogram): In case of primitives of tagged types not defined\n\tat the library level force generation of code to register the primitive\n\tin the dispatch table. In addition some code reorganization has been\n\tdone to leave the implementation clear.\n\t(Expand_Call): When expanding an inherited implicit conversion,\n\tpreserve the type of the inherited function after the intrinsic\n\toperation has been expanded.\n\n\t* exp_ch2.ads, exp_ch2.adb\n\t(Expand_Entry_Parameter.In_Assignment_Context): An implicit dereference\n\tof an entry formal appearing in an assignment statement does not assign\n\tto the formal.\n\t(Expand_Current_Value): Instead of calling a routine to determine\n\twhether the prefix of an attribute reference should be optimized or\n\tnot, prevent the optimization of such prefixes all together.\n\n\t* lib-xref.adb (Generate_Reference.Is_On_LHS): An indexed or selected\n\tcomponent whose prefix is known to be of an access type is an implicit\n\tdereference and does not assign to the prefix.\n\nFrom-SVN: r127411", "tree": {"sha": "7c3895b13822ab5f7e3c1e9da39c7366611502b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c3895b13822ab5f7e3c1e9da39c7366611502b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/comments", "author": null, "committer": null, "parents": [{"sha": "939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939c12d26a67c4e4d42d106d31c8f821b68cb1fb"}], "stats": {"total": 523, "additions": 357, "deletions": 166}, "files": [{"sha": "bf017f87a2b6c3377425e5cca4a74d0c92ce6cc6", "filename": "gcc/ada/a-strsup.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fa-strsup.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fa-strsup.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strsup.adb?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -783,7 +783,7 @@ package body Ada.Strings.Superbounded is\n       Index  : Positive) return Character\n    is\n    begin\n-      if Index in 1 .. Source.Current_Length then\n+      if Index <= Source.Current_Length then\n          return Source.Data (Index);\n       else\n          raise Strings.Index_Error;"}, {"sha": "fb44fa7555f955febf691015cbb8636dc19ed265", "filename": "gcc/ada/a-stwisu.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fa-stwisu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fa-stwisu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwisu.adb?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -784,7 +784,7 @@ package body Ada.Strings.Wide_Superbounded is\n       Index  : Positive) return Wide_Character\n    is\n    begin\n-      if Index in 1 .. Source.Current_Length then\n+      if Index <= Source.Current_Length then\n          return Source.Data (Index);\n       else\n          raise Strings.Index_Error;"}, {"sha": "b10d2cb9f9cd59636768edc6732dc8142bad9e05", "filename": "gcc/ada/a-stzsup.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fa-stzsup.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fa-stzsup.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzsup.adb?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -787,7 +787,7 @@ package body Ada.Strings.Wide_Wide_Superbounded is\n       Index  : Positive) return Wide_Wide_Character\n    is\n    begin\n-      if Index in 1 .. Source.Current_Length then\n+      if Index <= Source.Current_Length then\n          return Source.Data (Index);\n       else\n          raise Strings.Index_Error;"}, {"sha": "223b51bc776b43f0036dd090f1483d8e1746efbe", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -32,15 +32,16 @@ with Exp_Smem; use Exp_Smem;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Exp_VFpt; use Exp_VFpt;\n+with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Sem;      use Sem;\n-with Sem_Attr; use Sem_Attr;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n@@ -90,13 +91,13 @@ package body Exp_Ch2 is\n    procedure Expand_Entry_Parameter (N : Node_Id);\n    --  A reference to an entry parameter is modified to be a reference to the\n    --  corresponding component of the entry parameter record that is passed by\n-   --  the runtime to the accept body procedure\n+   --  the runtime to the accept body procedure.\n \n    procedure Expand_Formal (N : Node_Id);\n    --  A reference to a formal parameter of a protected subprogram is expanded\n    --  into the corresponding formal of the unprotected procedure used to\n    --  represent the operation within the protected object. In other cases\n-   --  Expand_Formal is a noop.\n+   --  Expand_Formal is a no-op.\n \n    procedure Expand_Protected_Private (N : Node_Id);\n    --  A reference to a private component of a protected type is expanded to a\n@@ -156,11 +157,18 @@ package body Exp_Ch2 is\n \n          and then Nkind (Parent (N)) /= N_Pragma_Argument_Association\n \n-         --  Same for attribute references that require a simple name prefix\n+         --  Do not replace the prefixes of attribute references, since this\n+         --  causes trouble with cases like 4'Size. Also for Name_Asm_Input and\n+         --  Name_Asm_Output, don't do replacement anywhere, since we can have\n+         --  lvalue references in the arguments.\n \n          and then not (Nkind (Parent (N)) = N_Attribute_Reference\n-                         and then Requires_Simple_Name_Prefix (\n-                                    Attribute_Name (Parent (N))))\n+                         and then\n+                           (Attribute_Name (Parent (N)) = Name_Asm_Input\n+                              or else\n+                            Attribute_Name (Parent (N)) = Name_Asm_Output\n+                              or else\n+                            Prefix (Parent (N)) = N))\n \n       then\n          --  Case of Current_Value is a compile time known value\n@@ -421,6 +429,11 @@ package body Exp_Ch2 is\n \n       function In_Assignment_Context (N : Node_Id) return Boolean is\n       begin\n+         --  Case of use in a call\n+\n+         --  ??? passing a formal as actual for a mode IN formal is\n+         --  considered as an assignment?\n+\n          if Nkind (Parent (N)) = N_Procedure_Call_Statement\n            or else Nkind (Parent (N)) = N_Entry_Call_Statement\n            or else\n@@ -429,15 +442,25 @@ package body Exp_Ch2 is\n          then\n             return True;\n \n+         --  Case of a parameter association: climb up to enclosing call\n+\n          elsif Nkind (Parent (N)) = N_Parameter_Association then\n             return In_Assignment_Context (Parent (N));\n \n+         --  Case of a selected component, indexed component or slice prefix:\n+         --  climb up the tree, unless the prefix is of an access type (in\n+         --  which case there is an implicit dereference, and the formal itself\n+         --  is not being assigned to).\n+\n          elsif (Nkind (Parent (N)) = N_Selected_Component\n                  or else Nkind (Parent (N)) = N_Indexed_Component\n                  or else Nkind (Parent (N)) = N_Slice)\n+           and then N = Prefix (Parent (N))\n+           and then not Is_Access_Type (Etype (N))\n            and then In_Assignment_Context (Parent (N))\n          then\n             return True;\n+\n          else\n             return False;\n          end if;\n@@ -670,17 +693,31 @@ package body Exp_Ch2 is\n    --  through an address clause is rewritten as dereference as well.\n \n    function Param_Entity (N : Node_Id) return Entity_Id is\n+      Renamed_Obj : Node_Id;\n+\n    begin\n       --  Simple reference case\n \n       if Nkind (N) = N_Identifier or else Nkind (N) = N_Expanded_Name then\n          if Is_Formal (Entity (N)) then\n             return Entity (N);\n \n-         elsif Nkind (Parent (Entity (N))) = N_Object_Renaming_Declaration\n-           and then Nkind (Parent (Parent (Entity (N)))) = N_Accept_Statement\n-         then\n-            return Entity (N);\n+         --  Handle renamings of formal parameters and formals of tasks that\n+         --  are rewritten as renamings.\n+\n+         elsif Nkind (Parent (Entity (N))) = N_Object_Renaming_Declaration then\n+            Renamed_Obj := Get_Referenced_Object (Renamed_Object (Entity (N)));\n+\n+            if Is_Entity_Name (Renamed_Obj)\n+              and then Is_Formal (Entity (Renamed_Obj))\n+            then\n+               return Entity (Renamed_Obj);\n+\n+            elsif\n+              Nkind (Parent (Parent (Entity (N)))) = N_Accept_Statement\n+            then\n+               return Entity (N);\n+            end if;\n          end if;\n \n       else"}, {"sha": "97b231984b3337886ce247e7c7307597d7720f46", "filename": "gcc/ada/exp_ch2.ads", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fexp_ch2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fexp_ch2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.ads?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,9 +37,10 @@ package Exp_Ch2 is\n    --  Given an expression N, determines if the expression is a reference\n    --  to a formal (of a subprogram or entry), and if so returns the Id\n    --  of the corresponding formal entity, otherwise returns Empty. The\n-   --  reason that this is in Exp_Ch2 is that it has to deal with the\n-   --  case where the reference is to an entry formal, and has been\n-   --  expanded already. Since Exp_Ch2 is in charge of the expansion, it\n-   --  is best suited to knowing how to detect this case.\n+   --  reason that this is in Exp_Ch2 is that it has to deal with the case\n+   --  where the reference is to an entry formal, and has been expanded\n+   --  already. Since Exp_Ch2 is in charge of the expansion, it is best\n+   --  suited to knowing how to detect this case. Also handles the case\n+   --  of references to renamings of formals.\n \n end Exp_Ch2;"}, {"sha": "3b4490adf49f10eb7789ba722cf9712dd5a6fa83", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 108, "deletions": 34, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -670,7 +670,7 @@ package body Exp_Ch4 is\n                   Flist := Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n                end if;\n \n-               Convert_Aggr_In_Allocator (Tmp_Node, Exp);\n+               Convert_Aggr_In_Allocator (N, Tmp_Node, Exp);\n             else\n                Node := Relocate_Node (N);\n                Set_Analyzed (Node);\n@@ -741,7 +741,7 @@ package body Exp_Ch4 is\n                        Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n                   end if;\n \n-                  Convert_Aggr_In_Allocator (Tmp_Node, Exp);\n+                  Convert_Aggr_In_Allocator (N, Tmp_Node, Exp);\n                else\n                   Node := Relocate_Node (N);\n                   Set_Analyzed (Node);\n@@ -935,7 +935,7 @@ package body Exp_Ch4 is\n \n          Set_No_Initialization (Expression (Tmp_Node));\n          Insert_Action (N, Tmp_Node);\n-         Convert_Aggr_In_Allocator (Tmp_Node, Exp);\n+         Convert_Aggr_In_Allocator (N, Tmp_Node, Exp);\n          Rewrite (N, New_Reference_To (Temp, Loc));\n          Analyze_And_Resolve (N, PtrT);\n \n@@ -1467,7 +1467,7 @@ package body Exp_Ch4 is\n               Make_Implicit_If_Statement (Nod,\n                 Condition => Make_Op_Not (Loc, Right_Opnd => Test),\n                 Then_Statements => New_List (\n-                  Make_Return_Statement (Loc,\n+                  Make_Simple_Return_Statement (Loc,\n                     Expression => New_Occurrence_Of (Standard_False, Loc))));\n          end if;\n       end Component_Equality;\n@@ -1749,20 +1749,20 @@ package body Exp_Ch4 is\n                 Make_Implicit_If_Statement (Nod,\n                   Condition => Test_Empty_Arrays,\n                   Then_Statements => New_List (\n-                    Make_Return_Statement (Loc,\n+                    Make_Simple_Return_Statement (Loc,\n                       Expression =>\n                         New_Occurrence_Of (Standard_True, Loc)))),\n \n                 Make_Implicit_If_Statement (Nod,\n                   Condition => Test_Lengths_Correspond,\n                   Then_Statements => New_List (\n-                    Make_Return_Statement (Loc,\n+                    Make_Simple_Return_Statement (Loc,\n                       Expression =>\n                         New_Occurrence_Of (Standard_False, Loc)))),\n \n                 Handle_One_Dimension (1, First_Index (Ltyp)),\n \n-                Make_Return_Statement (Loc,\n+                Make_Simple_Return_Statement (Loc,\n                   Expression => New_Occurrence_Of (Standard_True, Loc)))));\n \n          Set_Has_Completion (Func_Name, True);\n@@ -2590,7 +2590,7 @@ package body Exp_Ch4 is\n           Condition       => S_Length_Test (1),\n           Then_Statements => New_List (Init_L (1)),\n           Elsif_Parts     => Elsif_List,\n-          Else_Statements => New_List (Make_Return_Statement (Loc,\n+          Else_Statements => New_List (Make_Simple_Return_Statement (Loc,\n                                          Expression => S (Nb_Opnds))));\n \n       --  Construct the declaration for H\n@@ -2641,7 +2641,8 @@ package body Exp_Ch4 is\n                       Then_Statements => Copy_Into_R_S (I, I = Nb_Opnds)));\n       end loop;\n \n-      Append_To (Declare_Stmts, Make_Return_Statement (Loc, Expression => R));\n+      Append_To\n+        (Declare_Stmts, Make_Simple_Return_Statement (Loc, Expression => R));\n \n       --  Construct the declare block\n \n@@ -2817,7 +2818,7 @@ package body Exp_Ch4 is\n             P := Parent (N);\n             while Present (P) loop\n                if Nkind (P) = N_Extended_Return_Statement\n-                 or else Nkind (P) = N_Return_Statement\n+                 or else Nkind (P) = N_Simple_Return_Statement\n                then\n                   return True;\n \n@@ -3441,7 +3442,7 @@ package body Exp_Ch4 is\n                --  Postpone the generation of a finalization call for the\n                --  current allocator if it acts as a coextension.\n \n-               if Is_Coextension (N) then\n+               if Is_Dynamic_Coextension (N) then\n                   if No (Coextensions (N)) then\n                      Set_Coextensions (N, New_Elmt_List);\n                   end if;\n@@ -3762,31 +3763,67 @@ package body Exp_Ch4 is\n             Lo : constant Node_Id := Low_Bound (Rop);\n             Hi : constant Node_Id := High_Bound (Rop);\n \n+            Ltyp : constant Entity_Id := Etype (Lop);\n+\n             Lo_Orig : constant Node_Id := Original_Node (Lo);\n             Hi_Orig : constant Node_Id := Original_Node (Hi);\n \n             Lcheck : constant Compare_Result := Compile_Time_Compare (Lop, Lo);\n             Ucheck : constant Compare_Result := Compile_Time_Compare (Lop, Hi);\n \n+            Warn1 : constant Boolean :=\n+                      Constant_Condition_Warnings\n+                        and then Comes_From_Source (N);\n+            --  This must be true for any of the optimization warnings, we\n+            --  clearly want to give them only for source with the flag on.\n+\n+            Warn2 : constant Boolean :=\n+                      Warn1\n+                        and then Nkind (Original_Node (Rop)) = N_Range\n+                        and then Is_Integer_Type (Etype (Lo));\n+            --  For the case where only one bound warning is elided, we also\n+            --  insist on an explicit range and an integer type. The reason is\n+            --  that the use of enumeration ranges including an end point is\n+            --  common, as is the use of a subtype name, one of whose bounds\n+            --  is the same as the type of the expression.\n+\n          begin\n             --  If test is explicit x'first .. x'last, replace by valid check\n \n-            if Is_Scalar_Type (Etype (Lop))\n+            if Is_Scalar_Type (Ltyp)\n               and then Nkind (Lo_Orig) = N_Attribute_Reference\n               and then Attribute_Name (Lo_Orig) = Name_First\n               and then Nkind (Prefix (Lo_Orig)) in N_Has_Entity\n-              and then Entity (Prefix (Lo_Orig)) = Etype (Lop)\n+              and then Entity (Prefix (Lo_Orig)) = Ltyp\n               and then Nkind (Hi_Orig) = N_Attribute_Reference\n               and then Attribute_Name (Hi_Orig) = Name_Last\n               and then Nkind (Prefix (Hi_Orig)) in N_Has_Entity\n-              and then Entity (Prefix (Hi_Orig)) = Etype (Lop)\n+              and then Entity (Prefix (Hi_Orig)) = Ltyp\n               and then Comes_From_Source (N)\n               and then VM_Target = No_VM\n             then\n                Substitute_Valid_Check;\n                return;\n             end if;\n \n+            --  If bounds of type are known at compile time, and the end points\n+            --  are known at compile time and identical, this is another case\n+            --  for substituting a valid test. We only do this for discrete\n+            --  types, since it won't arise in practice for float types.\n+\n+            if Comes_From_Source (N)\n+              and then Is_Discrete_Type (Ltyp)\n+              and then Compile_Time_Known_Value (Type_High_Bound (Ltyp))\n+              and then Compile_Time_Known_Value (Type_Low_Bound  (Ltyp))\n+              and then Compile_Time_Known_Value (Lo)\n+              and then Compile_Time_Known_Value (Hi)\n+              and then Expr_Value (Type_High_Bound (Ltyp)) = Expr_Value (Hi)\n+              and then Expr_Value (Type_Low_Bound  (Ltyp)) = Expr_Value (Lo)\n+            then\n+               Substitute_Valid_Check;\n+               return;\n+            end if;\n+\n             --  If we have an explicit range, do a bit of optimization based\n             --  on range analysis (we may be able to kill one or both checks).\n \n@@ -3795,44 +3832,68 @@ package body Exp_Ch4 is\n             --  legality checks, because we are constant-folding beyond RM 4.9.\n \n             if Lcheck = LT or else Ucheck = GT then\n+               if Warn1 then\n+                  Error_Msg_N (\"?range test optimized away\", N);\n+                  Error_Msg_N (\"\\?value is known to be out of range\", N);\n+               end if;\n+\n                Rewrite (N,\n                  New_Reference_To (Standard_False, Loc));\n                Analyze_And_Resolve (N, Rtyp);\n                Set_Is_Static_Expression (N, Static);\n+\n                return;\n \n             --  If both checks are known to succeed, replace result\n             --  by True, since we know we are in range.\n \n             elsif Lcheck in Compare_GE and then Ucheck in Compare_LE then\n+               if Warn1 then\n+                  Error_Msg_N (\"?range test optimized away\", N);\n+                  Error_Msg_N (\"\\?value is known to be in range\", N);\n+               end if;\n+\n                Rewrite (N,\n                  New_Reference_To (Standard_True, Loc));\n                Analyze_And_Resolve (N, Rtyp);\n                Set_Is_Static_Expression (N, Static);\n+\n                return;\n \n-            --  If lower bound check succeeds and upper bound check is\n-            --  not known to succeed or fail, then replace the range check\n-            --  with a comparison against the upper bound.\n+            --  If lower bound check succeeds and upper bound check is not\n+            --  known to succeed or fail, then replace the range check with\n+            --  a comparison against the upper bound.\n \n             elsif Lcheck in Compare_GE then\n+               if Warn2 then\n+                  Error_Msg_N (\"?lower bound test optimized away\", Lo);\n+                  Error_Msg_N (\"\\?value is known to be in range\", Lo);\n+               end if;\n+\n                Rewrite (N,\n                  Make_Op_Le (Loc,\n                    Left_Opnd  => Lop,\n                    Right_Opnd => High_Bound (Rop)));\n                Analyze_And_Resolve (N, Rtyp);\n+\n                return;\n \n-            --  If upper bound check succeeds and lower bound check is\n-            --  not known to succeed or fail, then replace the range check\n-            --  with a comparison against the lower bound.\n+            --  If upper bound check succeeds and lower bound check is not\n+            --  known to succeed or fail, then replace the range check with\n+            --  a comparison against the lower bound.\n \n             elsif Ucheck in Compare_LE then\n+               if Warn2 then\n+                  Error_Msg_N (\"?upper bound test optimized away\", Hi);\n+                  Error_Msg_N (\"\\?value is known to be in range\", Hi);\n+               end if;\n+\n                Rewrite (N,\n                  Make_Op_Ge (Loc,\n                    Left_Opnd  => Lop,\n                    Right_Opnd => Low_Bound (Rop)));\n                Analyze_And_Resolve (N, Rtyp);\n+\n                return;\n             end if;\n          end;\n@@ -4203,9 +4264,9 @@ package body Exp_Ch4 is\n           Right_Opnd =>\n             Make_In (Loc,\n               Left_Opnd  => Left_Opnd (N),\n-                     Right_Opnd => Right_Opnd (N))));\n+              Right_Opnd => Right_Opnd (N))));\n \n-      --  We want this tp appear as coming from source if original does (see\n+      --  We want this to appear as coming from source if original does (see\n       --  tranformations in Expand_N_In).\n \n       Set_Comes_From_Source (N, Cfs);\n@@ -6295,7 +6356,7 @@ package body Exp_Ch4 is\n             Make_Handled_Sequence_Of_Statements (Loc,\n               Statements => New_List (\n                 Loop_Statement,\n-                Make_Return_Statement (Loc,\n+                Make_Simple_Return_Statement (Loc,\n                   Expression =>\n                     Make_Identifier (Loc, Chars (B)))))));\n \n@@ -7413,13 +7474,23 @@ package body Exp_Ch4 is\n \n       if Is_Access_Type (Target_Type) then\n \n-         --  Apply an accessibility check if the operand is an\n-         --  access parameter. Note that other checks may still\n-         --  need to be applied below (such as tagged type checks).\n+         --  Apply an accessibility check when the conversion operand is an\n+         --  access parameter (or a renaming thereof), unless conversion was\n+         --  expanded from an unchecked or unrestricted access attribute. Note\n+         --  that other checks may still need to be applied below (such as\n+         --  tagged type checks).\n \n          if Is_Entity_Name (Operand)\n-           and then Ekind (Entity (Operand)) in Formal_Kind\n+           and then\n+             (Is_Formal (Entity (Operand))\n+               or else\n+                 (Present (Renamed_Object (Entity (Operand)))\n+                   and then Is_Entity_Name (Renamed_Object (Entity (Operand)))\n+                   and then Is_Formal\n+                              (Entity (Renamed_Object (Entity (Operand))))))\n            and then Ekind (Etype (Operand)) = E_Anonymous_Access_Type\n+           and then (Nkind (Original_Node (N)) /= N_Attribute_Reference\n+                      or else Attribute_Name (Original_Node (N)) = Name_Access)\n          then\n             Apply_Accessibility_Check (Operand, Target_Type);\n \n@@ -8172,9 +8243,12 @@ package body Exp_Ch4 is\n \n          --  Case of an access discriminant, or (Ada 2005), of an anonymous\n          --  access component or anonymous access function result: find the\n-         --  final list associated with the scope of the type.\n+         --  final list associated with the scope of the type. (In the\n+         --  anonymous access component kind, a list controller will have\n+         --  been allocated when freezing the record type, and PtrT has an\n+         --  Associated_Final_Chain attribute designating it.)\n \n-         else\n+         elsif No (Associated_Final_Chain (PtrT)) then\n             Owner := Scope (PtrT);\n          end if;\n       end if;\n@@ -8480,7 +8554,7 @@ package body Exp_Ch4 is\n           Then_Statements => New_List (Inner_If),\n \n           Else_Statements => New_List (\n-            Make_Return_Statement (Loc,\n+            Make_Simple_Return_Statement (Loc,\n               Expression =>\n                 Make_Op_Gt (Loc,\n                   Left_Opnd =>\n@@ -8551,7 +8625,7 @@ package body Exp_Ch4 is\n \n           Then_Statements =>\n             New_List (\n-              Make_Return_Statement (Loc,\n+              Make_Simple_Return_Statement (Loc,\n                 Expression => New_Reference_To (Standard_False, Loc))),\n \n           Elsif_Parts => New_List (\n@@ -8567,12 +8641,12 @@ package body Exp_Ch4 is\n \n               Then_Statements =>\n                 New_List (\n-                  Make_Return_Statement (Loc,\n+                  Make_Simple_Return_Statement (Loc,\n                      Expression => New_Reference_To (Standard_True, Loc))))),\n \n           Else_Statements => New_List (\n             Loop_Statement,\n-            Make_Return_Statement (Loc,\n+            Make_Simple_Return_Statement (Loc,\n               Expression => Final_Expr)));\n \n       --  (X : a; Y: a)\n@@ -8741,7 +8815,7 @@ package body Exp_Ch4 is\n             Make_Handled_Sequence_Of_Statements (Loc,\n               Statements => New_List (\n                 Loop_Statement,\n-                Make_Return_Statement (Loc,\n+                Make_Simple_Return_Statement (Loc,\n                   Expression => New_Reference_To (C, Loc)))));\n \n       return Func_Body;"}, {"sha": "71650fe8df6f7e03a83a75b5ccdb1d172bb6d9a6", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 144, "deletions": 91, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -1123,13 +1123,48 @@ package body Exp_Ch6 is\n             Rewrite (Actual, New_Reference_To (Temp, Loc));\n             Analyze (Actual);\n \n-            Append_To (Post_Call,\n-              Make_Assignment_Statement (Loc,\n-                Name       => New_Occurrence_Of (Var, Loc),\n-                Expression => Expr));\n+            --  If the actual is a conversion of a packed reference, it may\n+            --  already have been expanded by Remove_Side_Effects, and the\n+            --  resulting variable is a temporary which does not designate\n+            --  the proper out-parameter, which may not be addressable. In\n+            --  that case, generate an assignment to the original expression\n+            --  (before expansion of the  packed reference) so that the proper\n+            --  expansion of assignment to a packed component can take place.\n \n-            Set_Assignment_OK (Name (Last (Post_Call)));\n+            declare\n+               Obj : Node_Id;\n+               Lhs : Node_Id;\n+\n+            begin\n+               if Is_Renaming_Of_Object (Var)\n+                 and then Nkind (Renamed_Object (Var)) = N_Selected_Component\n+                 and then Is_Entity_Name (Prefix (Renamed_Object (Var)))\n+                 and then Nkind (Original_Node (Prefix (Renamed_Object (Var))))\n+                   = N_Indexed_Component\n+                 and then\n+                   Has_Non_Standard_Rep (Etype (Prefix (Renamed_Object (Var))))\n+               then\n+                  Obj := Renamed_Object (Var);\n+                  Lhs :=\n+                    Make_Selected_Component (Loc,\n+                      Prefix        =>\n+                        New_Copy_Tree (Original_Node (Prefix (Obj))),\n+                      Selector_Name => New_Copy (Selector_Name (Obj)));\n+                  Reset_Analyzed_Flags (Lhs);\n+\n+               else\n+                  Lhs :=  New_Occurrence_Of (Var, Loc);\n+               end if;\n+\n+               Set_Assignment_OK (Lhs);\n+\n+               Append_To (Post_Call,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => Lhs,\n+                   Expression => Expr));\n+            end;\n          end if;\n+\n       end Add_Call_By_Copy_Code;\n \n       ----------------------------------\n@@ -2104,13 +2139,21 @@ package body Exp_Ch6 is\n \n             if Is_Entity_Name (Prev_Orig) then\n \n-               --  When passing an access parameter as the actual to another\n-               --  access parameter we need to pass along the actual's own\n-               --  associated access level parameter. This is done if we are\n-               --  in the scope of the formal access parameter (if this is an\n-               --  inlined body the extra formal is irrelevant).\n-\n-               if Ekind (Entity (Prev_Orig)) in Formal_Kind\n+               --  When passing an access parameter, or a renaming of an access\n+               --  parameter, as the actual to another access parameter we need\n+               --  to pass along the actual's own access level parameter. This\n+               --  is done if we are within the scope of the formal access\n+               --  parameter (if this is an inlined body the extra formal is\n+               --  irrelevant).\n+\n+               if (Is_Formal (Entity (Prev_Orig))\n+                    or else\n+                      (Present (Renamed_Object (Entity (Prev_Orig)))\n+                        and then\n+                          Is_Entity_Name (Renamed_Object (Entity (Prev_Orig)))\n+                        and then\n+                          Is_Formal\n+                            (Entity (Renamed_Object (Entity (Prev_Orig))))))\n                  and then Ekind (Etype (Prev_Orig)) = E_Anonymous_Access_Type\n                  and then In_Open_Scopes (Scope (Entity (Prev_Orig)))\n                then\n@@ -2218,7 +2261,7 @@ package body Exp_Ch6 is\n             if Is_Access_Type (Etype (Formal))\n               and then Can_Never_Be_Null (Etype (Formal))\n               and then Nkind (Prev) /= N_Raise_Constraint_Error\n-              and then (Nkind (Prev) = N_Null\n+              and then (Known_Null (Prev)\n                           or else not Can_Never_Be_Null (Etype (Prev)))\n             then\n                Install_Null_Excluding_Check (Prev);\n@@ -2410,7 +2453,7 @@ package body Exp_Ch6 is\n                   then\n                      Error_Msg_NE\n                        (\"tag-indeterminate expression \"\n-                         & \" must have designated type& ('R'M 5.2 (6))\",\n+                         & \" must have designated type& (RM 5.2 (6))\",\n                            N, Root_Type (Etype (Name (Ass))));\n                   else\n                      Propagate_Tag (Name (Ass), N);\n@@ -2419,7 +2462,7 @@ package body Exp_Ch6 is\n                elsif Etype (N) /= Root_Type (Etype (Name (Ass))) then\n                   Error_Msg_NE\n                     (\"tag-indeterminate expression must have type&\"\n-                     & \"('R'M 5.2 (6))\", N, Root_Type (Etype (Name (Ass))));\n+                     & \"(RM 5.2 (6))\", N, Root_Type (Etype (Name (Ass))));\n \n                else\n                   Propagate_Tag (Name (Ass), N);\n@@ -2708,9 +2751,21 @@ package body Exp_Ch6 is\n       --  In the case where the intrinsic is to be processed by the back end,\n       --  the call to Expand_Intrinsic_Call will do nothing, which is fine,\n       --  since the idea in this case is to pass the call unchanged.\n+      --  If the intrinsic is an inherited unchecked conversion, and the\n+      --  derived type is the target type of the conversion, we must retain\n+      --  it as the return type of the expression. Otherwise the expansion\n+      --  below, which uses the parent operation, will yield the wrong type.\n \n       if Is_Intrinsic_Subprogram (Subp) then\n          Expand_Intrinsic_Call (N, Subp);\n+\n+         if Nkind (N) = N_Unchecked_Type_Conversion\n+           and then Parent_Subp /= Orig_Subp\n+           and then Etype (Parent_Subp) /= Etype (Orig_Subp)\n+         then\n+            Set_Etype (N, Etype (Orig_Subp));\n+         end if;\n+\n          return;\n       end if;\n \n@@ -3147,7 +3202,7 @@ package body Exp_Ch6 is\n                    and then\n                      (No (Stat2)\n                        or else\n-                         (Nkind (Stat2) = N_Return_Statement\n+                         (Nkind (Stat2) = N_Simple_Return_Statement\n                            and then No (Next (Stat2))));\n             end;\n          end if;\n@@ -3211,19 +3266,21 @@ package body Exp_Ch6 is\n                   Rewrite (N, New_Occurrence_Of (A, Loc));\n                   Check_Private_View (N);\n \n-               else   --  numeric literal\n+               --  Numeric literal\n+\n+               else\n                   Rewrite (N, New_Copy (A));\n                end if;\n             end if;\n \n             return Skip;\n \n-         elsif Nkind (N) = N_Return_Statement then\n-\n+         elsif Nkind (N) = N_Simple_Return_Statement then\n             if No (Expression (N)) then\n                Make_Exit_Label;\n-               Rewrite (N, Make_Goto_Statement (Loc,\n-                 Name => New_Copy (Lab_Id)));\n+               Rewrite (N,\n+                 Make_Goto_Statement (Loc,\n+                   Name => New_Copy (Lab_Id)));\n \n             else\n                if Nkind (Parent (N)) = N_Handled_Sequence_Of_Statements\n@@ -3863,7 +3920,7 @@ package body Exp_Ch6 is\n          if Is_Inherently_Limited_Type (Typ) then\n             return True;\n \n-         elsif Nkind (Parent (N)) /= N_Return_Statement then\n+         elsif Nkind (Parent (N)) /= N_Simple_Return_Statement then\n             return False;\n \n          elsif Requires_Transient_Scope (Typ) then\n@@ -4113,7 +4170,7 @@ package body Exp_Ch6 is\n                Loc := Sloc (Last_Stm);\n             end if;\n \n-            Append_To (S, Make_Return_Statement (Loc));\n+            Append_To (S, Make_Simple_Return_Statement (Loc));\n          end if;\n       end Add_Return;\n \n@@ -4275,7 +4332,8 @@ package body Exp_Ch6 is\n       then\n          Add_Discriminal_Declarations\n            (Declarations (N), Scop, Name_uObject, Loc);\n-         Add_Private_Declarations (Declarations (N), Scop, Name_uObject, Loc);\n+         Add_Private_Declarations\n+           (Declarations (N), Scop, Name_uObject, Loc);\n \n          --  Associate privals and discriminals with the next protected\n          --  operation body to be expanded. These are used to expand references\n@@ -4787,7 +4845,7 @@ package body Exp_Ch6 is\n \n    function Is_Build_In_Place_Function_Return (N : Node_Id) return Boolean is\n    begin\n-      if Nkind (N) = N_Return_Statement\n+      if Nkind (N) = N_Simple_Return_Statement\n         or else Nkind (N) = N_Extended_Return_Statement\n       then\n          return Is_Build_In_Place_Function\n@@ -4841,11 +4899,7 @@ package body Exp_Ch6 is\n          while Present (Iface_DT_Ptr)\n             and then Ekind (Node (Iface_DT_Ptr)) = E_Constant\n          loop\n-            Expand_Interface_Thunk\n-              (N           => Prim,\n-               Thunk_Alias => Prim,\n-               Thunk_Id    => Thunk_Id,\n-               Thunk_Code  => Thunk_Code);\n+            Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n             if Present (Thunk_Code) then\n                Insert_Actions (N, New_List (\n@@ -4867,89 +4921,88 @@ package body Exp_Ch6 is\n       --  Local variables\n \n       Subp : constant Entity_Id := Entity (N);\n-      Typ  : constant Entity_Id := Etype (Subp);\n-      Utyp : constant Entity_Id := Underlying_Type (Typ);\n \n    begin\n-      if not Static_Dispatch_Tables then\n+      --  We suppress the initialization of the dispatch table entry when\n+      --  VM_Target because the dispatching mechanism is handled internally\n+      --  by the VM.\n+\n+      if Is_Dispatching_Operation (Subp)\n+        and then not Is_Abstract_Subprogram (Subp)\n+        and then Present (DTC_Entity (Subp))\n+        and then Present (Scope (DTC_Entity (Subp)))\n+        and then VM_Target = No_VM\n+        and then not Restriction_Active (No_Dispatching_Calls)\n+        and then RTE_Available (RE_Tag)\n+      then\n          declare\n-            E   : constant Entity_Id := Subp;\n-            Typ : Entity_Id;\n+            Typ : constant Entity_Id := Scope (DTC_Entity (Subp));\n \n          begin\n-            --  We assume that imported CPP primitives correspond with objects\n-            --  whose constructor is in the CPP side (and therefore we don't\n-            --  need to generate code to register them in the dispatch table).\n+            --  Handle private overriden primitives\n \n-            if Is_Imported (E)\n-              and then Convention (E) = Convention_CPP\n-            then\n-               return;\n+            if not Is_CPP_Class (Typ) then\n+               Check_Overriding_Operation (Subp);\n             end if;\n \n-            --  When a primitive is frozen, enter its name in the corresponding\n-            --  dispatch table. If the DTC_Entity field is not set this is\n-            --  an overridden primitive that can be ignored. We suppress the\n-            --  initialization of the dispatch table entry when VM_Target\n-            --  because the dispatching mechanism is handled internally by\n-            --  the VM.\n-\n-            if Is_Dispatching_Operation (E)\n-              and then not Is_Abstract_Subprogram (E)\n-              and then Present (DTC_Entity (E))\n-              and then VM_Target = No_VM\n-              and then not Is_CPP_Class (Scope (DTC_Entity (E)))\n-            then\n-               Check_Overriding_Operation (E);\n+            --  We assume that imported CPP primitives correspond with objects\n+            --  whose constructor is in the CPP side; therefore we don't need\n+            --  to generate code to register them in the dispatch table.\n \n-               --  Register the primitive in its dispatch table if we are not\n-               --  compiling under No_Dispatching_Calls restriction\n+            if Is_CPP_Class (Typ) then\n+               null;\n \n-               if not Restriction_Active (No_Dispatching_Calls)\n-                 and then RTE_Available (RE_Tag)\n-               then\n-                  Typ := Scope (DTC_Entity (E));\n+            --  Handle CPP primitives found in derivations of CPP_Class types.\n+            --  These primitives must have been inherited from some parent, and\n+            --  there is no need to register them in the dispatch table because\n+            --  Build_Inherit_Prims takes care of the initialization of these\n+            --  slots.\n \n-                  if not Is_Interface (Typ)\n-                    or else Present (Abstract_Interface_Alias (E))\n-                  then\n-                     if Is_Predefined_Dispatching_Operation (E) then\n-                        Register_Predefined_DT_Entry (E);\n-                     end if;\n+            elsif Is_Imported (Subp)\n+                    and then (Convention (Subp) = Convention_CPP\n+                                or else Convention (Subp) = Convention_C)\n+            then\n+               null;\n+\n+            --  Generate code to register the primitive in non statically\n+            --  allocated dispatch tables\n+\n+            elsif not Static_Dispatch_Tables\n+              or else not\n+                Is_Library_Level_Tagged_Type (Scope (DTC_Entity (Subp)))\n+            then\n+               --  When a primitive is frozen, enter its name in its dispatch\n+               --  table slot.\n \n-                     Register_Primitive (Loc,\n-                       Prim    => E,\n-                       Ins_Nod => N);\n+               if not Is_Interface (Typ)\n+                 or else Present (Abstract_Interface_Alias (Subp))\n+               then\n+                  if Is_Predefined_Dispatching_Operation (Subp) then\n+                     Register_Predefined_DT_Entry (Subp);\n                   end if;\n+\n+                  Register_Primitive (Loc,\n+                    Prim    => Subp,\n+                    Ins_Nod => N);\n                end if;\n             end if;\n          end;\n-\n-      --  GCC 4.1 backend\n-\n-      else\n-         --  Handle private overriden primitives\n-\n-         if Is_Dispatching_Operation (Subp)\n-           and then not Is_Abstract_Subprogram (Subp)\n-           and then Present (DTC_Entity (Subp))\n-           and then VM_Target = No_VM\n-           and then not Is_CPP_Class (Scope (DTC_Entity (Subp)))\n-         then\n-            Check_Overriding_Operation (Subp);\n-         end if;\n       end if;\n \n       --  Mark functions that return by reference. Note that it cannot be part\n       --  of the normal semantic analysis of the spec since the underlying\n       --  returned type may not be known yet (for private types).\n \n-      if Is_Inherently_Limited_Type (Typ) then\n-         Set_Returns_By_Ref (Subp);\n-\n-      elsif Present (Utyp) and then CW_Or_Controlled_Type (Utyp) then\n-         Set_Returns_By_Ref (Subp);\n-      end if;\n+      declare\n+         Typ  : constant Entity_Id := Etype (Subp);\n+         Utyp : constant Entity_Id := Underlying_Type (Typ);\n+      begin\n+         if Is_Inherently_Limited_Type (Typ) then\n+            Set_Returns_By_Ref (Subp);\n+         elsif Present (Utyp) and then CW_Or_Controlled_Type (Utyp) then\n+            Set_Returns_By_Ref (Subp);\n+         end if;\n+      end;\n    end Freeze_Subprogram;\n \n    -------------------------------------------"}, {"sha": "43c9c4d4d5407748c8d56adc858133b93227629a", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -72,7 +72,7 @@ package Exp_Ch6 is\n       --  Present if result type contains tasks. Master associated with\n       --  calling context.\n       BIP_Activation_Chain,\n-      --  Present if result type contains tasks. Caller's activation chain.\n+      --  Present if result type contains tasks. Caller's activation chain\n       BIP_Object_Access);\n       --  Present for all build-in-place functions. Address at which to place\n       --  the return object, or null if BIP_Alloc_Form indicates\n@@ -114,9 +114,9 @@ package Exp_Ch6 is\n    --  expression applied to such a call; otherwise returns False.\n \n    function Is_Build_In_Place_Function_Return (N : Node_Id) return Boolean;\n-   --  Ada 2005 (AI-318-02): Returns True if N is an N_Return_Statement or\n-   --  N_Extended_Return_Statement and it applies to a build-in-place function\n-   --  or generic function.\n+   --  Ada 2005 (AI-318-02): Returns True if N is an N_Simple_Return_Statement\n+   --  or N_Extended_Return_Statement and it applies to a build-in-place\n+   --  function or generic function.\n \n    procedure Make_Build_In_Place_Call_In_Allocator\n      (Allocator     : Node_Id;"}, {"sha": "36876ffaa2bc586bb1facf68a08d8cdfc800f5fb", "filename": "gcc/ada/lib-util.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Flib-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Flib-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-util.adb?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -74,13 +74,19 @@ package body Lib.Util is\n    --  Start of processing for Write_Info_Char_Code\n \n    begin\n-      if Code in 16#00# .. 16#7F# then\n+      --  00 .. 7F\n+\n+      if Code <= 16#7F# then\n          Write_Info_Char (Character'Val (Code));\n \n-      elsif Code in 16#80# .. 16#FF# then\n+      --  80 .. FF\n+\n+      elsif Code <= 16#FF# then\n          Write_Info_Char ('U');\n          Write_Info_Hex_Byte (Natural (Code));\n \n+      --  0100 .. FFFF\n+\n       else\n          Write_Info_Char ('W');\n          Write_Info_Hex_Byte (Natural (Code / 256));"}, {"sha": "15755a56f84ada9782de150d256c792da054e158", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -223,13 +223,20 @@ package body Lib.Xref is\n       --   Prefix    Of an indexed or selected component that is present in a\n       --             subtree rooted by an assignment statement. There is no\n       --             restriction of nesting of components, thus cases such as\n-      --             A.B(C).D are handled properly.\n+      --             A.B (C).D are handled properly.\n+      --             However a prefix of a dereference (either implicit or\n+      --             explicit) is never considered as on a LHS.\n \n       ---------------\n       -- Is_On_LHS --\n       ---------------\n \n-      --  Couldn't we use Is_Lvalue or whatever it is called ???\n+      --  ??? There are several routines here and there that perform a similar\n+      --      (but subtly different) computation, which should be factored:\n+\n+      --      Sem_Util.May_Be_Lvalue\n+      --      Sem_Util.Known_To_Be_Assigned\n+      --      Exp_Ch2.Expand_Entry_Parameter.In_Assignment_Context\n \n       function Is_On_LHS (Node : Node_Id) return Boolean is\n          N : Node_Id := Node;\n@@ -247,13 +254,28 @@ package body Lib.Xref is\n \n          while Nkind (Parent (N)) /= N_Assignment_Statement loop\n \n-            --  Check whether the parent is a component and the\n-            --  current node is its prefix.\n+            --  Check whether the parent is a component and the current node\n+            --  is its prefix, but return False if the current node has an\n+            --  access type, as in that case the selected or indexed component\n+            --  is an implicit dereference, and the LHS is the designated\n+            --  object, not the access object.\n+\n+            --  ??? case of a slice assignment?\n+\n+            --  ??? Note that in some cases this is called too early\n+            --  (see comments in Sem_Ch8.Find_Direct_Name), at a point where\n+            --  the tree is not fully typed yet. In that case we may lack\n+            --  an Etype for N, and we must disable the check for an implicit\n+            --  dereference. If the dereference is on an LHS, this causes a\n+            --  false positive.\n \n             if (Nkind (Parent (N)) = N_Selected_Component\n                   or else\n                 Nkind (Parent (N)) = N_Indexed_Component)\n               and then Prefix (Parent (N)) = N\n+              and then not (Present (Etype (N))\n+                              and then\n+                            Is_Access_Type (Etype (N)))\n             then\n                N := Parent (N);\n             else\n@@ -370,7 +392,7 @@ package body Lib.Xref is\n          --  a left hand side. We also set the Referenced_As_LHS flag of a\n          --  prefix of selected or indexed component.\n \n-         if Ekind (E) = E_Variable\n+         if (Ekind (E) = E_Variable or else Is_Formal (E))\n            and then Is_On_LHS (N)\n          then\n             Set_Referenced_As_LHS (E);\n@@ -1004,9 +1026,8 @@ package body Lib.Xref is\n                end if;\n             end if;\n \n-            --  Collect inherited primitive operations that may be\n-            --  declared in another unit and have no visible reference\n-            --  in the current one.\n+            --  Collect inherited primitive operations that may be declared in\n+            --  another unit and have no visible reference in the current one.\n \n             if Is_Type (Ent)\n               and then Is_Tagged_Type (Ent)"}, {"sha": "0745f388c7f10d0c49173ebff3dc8f20f5264efe", "filename": "gcc/ada/nlists.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fnlists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Fnlists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.adb?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -304,7 +304,7 @@ package body Nlists is\n       if List = No_List then\n          return Empty;\n       else\n-         pragma Assert (List in First_List_Id .. Lists.Last);\n+         pragma Assert (List <= Lists.Last);\n          return Lists.Table (List).First;\n       end if;\n    end First;\n@@ -630,7 +630,7 @@ package body Nlists is\n \n    function Last (List : List_Id) return Node_Id is\n    begin\n-      pragma Assert (List in First_List_Id .. Lists.Last);\n+      pragma Assert (List <= Lists.Last);\n       return Lists.Table (List).Last;\n    end Last;\n \n@@ -1028,7 +1028,7 @@ package body Nlists is\n \n    function Parent (List : List_Id) return Node_Id is\n    begin\n-      pragma Assert (List in First_List_Id .. Lists.Last);\n+      pragma Assert (List <= Lists.Last);\n       return Lists.Table (List).Parent;\n    end Parent;\n \n@@ -1355,7 +1355,7 @@ package body Nlists is\n \n    procedure Set_Parent (List : List_Id; Node : Node_Id) is\n    begin\n-      pragma Assert (List in First_List_Id .. Lists.Last);\n+      pragma Assert (List <= Lists.Last);\n       Lists.Table (List).Parent := Node;\n    end Set_Parent;\n "}, {"sha": "e35ab262f277d92dea7fe120c4c50d0f8ba54a9b", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d766cee3c3df3a0a6f5893f7f262dc10d150c85e/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "patch": "@@ -796,8 +796,7 @@ package body Treepr is\n \n       Notes := False;\n \n-      if N not in\n-        Atree_Private_Part.Nodes.First .. Atree_Private_Part.Nodes.Last then\n+      if N > Atree_Private_Part.Nodes.Last then\n          Print_Str (\" (no such node)\");\n          Print_Eol;\n          return;"}]}