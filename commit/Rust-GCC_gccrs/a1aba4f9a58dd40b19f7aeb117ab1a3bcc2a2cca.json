{"sha": "a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFhYmE0ZjlhNThkZDQwYjE5ZjdhZWIxMTdhYjFhM2JjYzJhMmNjYQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-12-19T19:31:55Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-12-19T19:31:55Z"}, "message": "natClassLoader.cc (defineClass0): Removed erroneous comment.\n\n\t* java/lang/natClassLoader.cc (defineClass0): Removed erroneous\n\tcomment.\n\t* java/lang/ClassLoader.java (defineClass): Use chained\n\texception when rethrowing.\n\t* defineclass.cc (handleClassBegin): Mark class as interpreted.\n\t* java/lang/reflect/Modifier.java (INVISIBLE, INTERPRETED): New\n\tconstants.\n\t* resolve.cc (_Jv_PrepareMissingMethods): New function.\n\t(_Jv_PrepareClass): Use it.\n\t* include/java-interp.h (_Jv_IsInterpretedClass): Rewrote.\n\t(_Jv_InterpClass): _Jv_PrepareMissingMethods now friend.\n\t* java/lang/Class.h (Class::getModifiers): Mask with ALL_FLAGS.\n\t(Class): _Jv_PrepareMissingMethods now friend.\n\t* java/lang/natClassLoader.cc (defineClass0): Use JvSynchronize.\n\tRecord `NULL' for system class loader.\n\t(_Jv_RegisterInitiatingLoader): Use JvSynchronize.  Special case\n\tsystem class loader.\n\t(_Jv_FindClassInCache): Likewise.\n\t(_Jv_UnregisterClass): Use JvSynchronize.  Free old loader info.\n\t(_Jv_FindClass): Special case system class loader.\n\t* java/lang/natClass.cc (_Jv_abstractMethodError): New function.\n\t(_Jv_SetVTableEntries): Put _Jv_abstractMethodError into empty\n\tvtable slots.\n\t(_Jv_LayoutVTableMethods): Don't generate vtable slot for a method\n\tin a final class.\n\t(_getDeclaredMethod): Don't return synthetic methods.\n\t(getDeclaredMethods): Likewise.\n\t(_getMethod): Likewise.\n\t(_getMethods): Likewise.\n\nFrom-SVN: r60319", "tree": {"sha": "f9577aaed149db0eda3cc774a016793bce9754d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9577aaed149db0eda3cc774a016793bce9754d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/comments", "author": null, "committer": null, "parents": [{"sha": "385405940e8b05e4d8e1ad9136f6c9f86b279b07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385405940e8b05e4d8e1ad9136f6c9f86b279b07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/385405940e8b05e4d8e1ad9136f6c9f86b279b07"}], "stats": {"total": 317, "additions": 221, "deletions": 96}, "files": [{"sha": "f139ff9cd65a1d8052d6d053a4d28ef237287ef6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "patch": "@@ -1,3 +1,35 @@\n+2002-12-19  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/natClassLoader.cc (defineClass0): Removed erroneous\n+\tcomment.\n+\t* java/lang/ClassLoader.java (defineClass): Use chained\n+\texception when rethrowing.\n+\t* defineclass.cc (handleClassBegin): Mark class as interpreted.\n+\t* java/lang/reflect/Modifier.java (INVISIBLE, INTERPRETED): New\n+\tconstants.\n+\t* resolve.cc (_Jv_PrepareMissingMethods): New function.\n+\t(_Jv_PrepareClass): Use it.\n+\t* include/java-interp.h (_Jv_IsInterpretedClass): Rewrote.\n+\t(_Jv_InterpClass): _Jv_PrepareMissingMethods now friend.\n+\t* java/lang/Class.h (Class::getModifiers): Mask with ALL_FLAGS.\n+\t(Class): _Jv_PrepareMissingMethods now friend.\n+\t* java/lang/natClassLoader.cc (defineClass0): Use JvSynchronize.\n+\tRecord `NULL' for system class loader.\n+\t(_Jv_RegisterInitiatingLoader): Use JvSynchronize.  Special case\n+\tsystem class loader.\n+\t(_Jv_FindClassInCache): Likewise.\n+\t(_Jv_UnregisterClass): Use JvSynchronize.  Free old loader info.\n+\t(_Jv_FindClass): Special case system class loader.\n+\t* java/lang/natClass.cc (_Jv_abstractMethodError): New function.\n+\t(_Jv_SetVTableEntries): Put _Jv_abstractMethodError into empty\n+\tvtable slots.\n+\t(_Jv_LayoutVTableMethods): Don't generate vtable slot for a method\n+\tin a final class.\n+\t(_getDeclaredMethod): Don't return synthetic methods.\n+\t(getDeclaredMethods): Likewise.\n+\t(_getMethod): Likewise.\n+\t(_getMethods): Likewise.\n+\n 2002-12-18  Raif Naffah  <raif@fl.net.au>\n \n \t* java/math/BigInteger.java (euclidInv): Make sure quot and rem are in"}, {"sha": "81de5ad7da2028a6d8361b28b09fc9d7085297c0", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "patch": "@@ -890,7 +890,7 @@ _Jv_ClassReader::handleClassBegin\n       throw_no_class_def_found_error (msg);\n     }\n \n-  def->accflags = access_flags;\n+  def->accflags = access_flags | java::lang::reflect::Modifier::INTERPRETED;\n   pool_data[this_class].clazz = def;\n   pool_tags[this_class] = JV_CONSTANT_ResolvedClass;\n "}, {"sha": "a00f4db0a1dbd341604b506e5b6d33d73d49a4d5", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "patch": "@@ -21,6 +21,7 @@ details.  */\n \n #include <java/lang/Class.h>\n #include <java/lang/ClassLoader.h>\n+#include <java/lang/reflect/Modifier.h>\n #include <gnu/gcj/runtime/StackTrace.h>\n \n extern \"C\" {\n@@ -30,7 +31,7 @@ extern \"C\" {\n extern inline jboolean\n _Jv_IsInterpretedClass (jclass c)\n {\n-  return (c->loader != 0);\n+  return (c->accflags & java::lang::reflect::Modifier::INTERPRETED) != 0;\n }\n \n struct _Jv_ResolvedMethod;\n@@ -158,6 +159,7 @@ class _Jv_InterpClass : public java::lang::Class\n   friend class _Jv_ClassReader;\n   friend class _Jv_InterpMethod;\n   friend void  _Jv_PrepareClass(jclass);\n+  friend void  _Jv_PrepareMissingMethods (jclass base2, jclass iface_class);\n   friend void  _Jv_InitField (jobject, jclass, int);\n #ifdef JV_MARKOBJ_DECL\n   friend JV_MARKOBJ_DECL;"}, {"sha": "d59899a81829263984b2197c1681271dc0af7c87", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "patch": "@@ -182,9 +182,9 @@ class java::lang::Class : public java::lang::Object\n   JArray<java::lang::reflect::Method *> *getMethods (void);\n \n   inline jint getModifiers (void)\n-    {\n-      return accflags;\n-    }\n+  {\n+    return accflags & java::lang::reflect::Modifier::ALL_FLAGS;\n+  }\n \n   jstring getName (void);\n \n@@ -348,6 +348,7 @@ class java::lang::Class : public java::lang::Object\n \t\t\t\t\t      _Jv_Utf8Const *method_signature);\n \n   friend void _Jv_PrepareClass (jclass);\n+  friend void _Jv_PrepareMissingMethods (jclass base, jclass iface_class);\n \n   friend class _Jv_ClassReader;\t\n   friend class _Jv_InterpClass;"}, {"sha": "8c99897cd1af08a04767f3627ece8e074447cc61", "filename": "libjava/java/lang/ClassLoader.java", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fjava%2Flang%2FClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fjava%2Flang%2FClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassLoader.java?ref=a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "patch": "@@ -468,17 +468,18 @@ protected final synchronized Class defineClass(String name,\n       {\n \tthrow x;\t\t// rethrow\n       }\n-    catch (java.lang.VirtualMachineError x)\n+    catch (VirtualMachineError x)\n       {\n \tthrow x;\t\t// rethrow\n       }\n-    catch (java.lang.Throwable x)\n+    catch (Throwable x)\n       {\n \t// This should never happen, or we are beyond spec.  \n-      \tthrow new InternalError (\"Unexpected exception \"\n-\t\t\t\t + \"while defining class \"\n-\t\t\t\t + name + \": \" \n-\t\t\t\t + x.toString ());\n+      \tInternalError r = new InternalError (\"Unexpected exception \"\n+\t\t\t\t\t     + \"while defining class \"\n+\t\t\t\t\t     + name);\n+\tr.initCause(x);\n+\tthrow r;\n       }\n   }\n "}, {"sha": "768ced611ac2cb9500614c2d8de44e12c1ff5943", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "patch": "@@ -343,7 +343,9 @@ java::lang::Class::_getDeclaredMethod (jstring name,\n   while (--i >= 0)\n     {\n       if (_Jv_equalUtf8Consts (methods[i].name, utf_name)\n-\t  && _Jv_equaln (methods[i].signature, partial_sig, p_len))\n+\t  && _Jv_equaln (methods[i].signature, partial_sig, p_len)\n+\t  && (methods[i].accflags\n+\t      & java::lang::reflect::Modifier::INVISIBLE) == 0)\n \t{\n \t  // Found it.\n \t  using namespace java::lang::reflect;\n@@ -368,7 +370,9 @@ java::lang::Class::getDeclaredMethods (void)\n       if (method->name == NULL\n \t  || _Jv_equalUtf8Consts (method->name, clinit_name)\n \t  || _Jv_equalUtf8Consts (method->name, init_name)\n-\t  || _Jv_equalUtf8Consts (method->name, finit_name))\n+\t  || _Jv_equalUtf8Consts (method->name, finit_name)\n+\t  || (methods[i].accflags\n+\t      & java::lang::reflect::Modifier::INVISIBLE) != 0)\n \tcontinue;\n       numMethods++;\n     }\n@@ -382,7 +386,9 @@ java::lang::Class::getDeclaredMethods (void)\n       if (method->name == NULL\n \t  || _Jv_equalUtf8Consts (method->name, clinit_name)\n \t  || _Jv_equalUtf8Consts (method->name, init_name)\n-\t  || _Jv_equalUtf8Consts (method->name, finit_name))\n+\t  || _Jv_equalUtf8Consts (method->name, finit_name)\n+\t  || (methods[i].accflags\n+\t      & java::lang::reflect::Modifier::INVISIBLE) != 0)\n \tcontinue;\n       java::lang::reflect::Method* rmethod\n \t= new java::lang::reflect::Method ();\n@@ -514,7 +520,9 @@ java::lang::Class::_getMethod (jstring name, JArray<jclass> *param_types)\n \t{\n \t  // FIXME: access checks.\n \t  if (_Jv_equalUtf8Consts (klass->methods[i].name, utf_name)\n-\t      && _Jv_equaln (klass->methods[i].signature, partial_sig, p_len))\n+\t      && _Jv_equaln (klass->methods[i].signature, partial_sig, p_len)\n+\t      && (klass->methods[i].accflags\n+\t\t  & java::lang::reflect::Modifier::INVISIBLE) == 0)\n \t    {\n \t      // Found it.\n \t      using namespace java::lang::reflect;\n@@ -565,7 +573,9 @@ java::lang::Class::_getMethods (JArray<java::lang::reflect::Method *> *result,\n       if (method->name == NULL\n \t  || _Jv_equalUtf8Consts (method->name, clinit_name)\n \t  || _Jv_equalUtf8Consts (method->name, init_name)\n-\t  || _Jv_equalUtf8Consts (method->name, finit_name))\n+\t  || _Jv_equalUtf8Consts (method->name, finit_name)\n+\t  || (method->accflags\n+\t      & java::lang::reflect::Modifier::INVISIBLE) != 0)\n \tcontinue;\n       // Only want public methods.\n       if (! java::lang::reflect::Modifier::isPublic (method->accflags))\n@@ -1564,6 +1574,13 @@ isVirtualMethod (_Jv_Method *meth)\n           && meth->name->data[0] != '<');\n }\n \n+// This is put in empty vtable slots.\n+static void\n+_Jv_abstractMethodError (void)\n+{\n+  throw new java::lang::AbstractMethodError();\n+}\n+\n // Prepare virtual method declarations in KLASS, and any superclasses as \n // required, by determining their vtable index, setting method->index, and\n // finally setting the class's vtable_method_count. Must be called with the\n@@ -1594,13 +1611,16 @@ _Jv_LayoutVTableMethods (jclass klass)\n \tcontinue;\n \n       if (superclass != NULL)\n-        super_meth = _Jv_LookupDeclaredMethod (superclass, meth->name, \n-\t\t\t\t\t       meth->signature);\n+\t{\n+\t  super_meth = _Jv_LookupDeclaredMethod (superclass, meth->name, \n+\t\t\t\t\t\t meth->signature);\n+\t}\n \n       if (super_meth)\n         meth->index = super_meth->index;\n-      else if (! (meth->accflags & java::lang::reflect::Modifier::FINAL))\n-        meth->index = index++;\n+      else if (! (meth->accflags & java::lang::reflect::Modifier::FINAL)\n+\t       && ! (klass->accflags & java::lang::reflect::Modifier::FINAL))\n+\tmeth->index = index++;\n     }\n \n   klass->vtable_method_count = index;\n@@ -1626,8 +1646,7 @@ _Jv_SetVTableEntries (jclass klass, _Jv_VTable *vtable, jboolean *flags)\n \tcontinue;\n       if ((meth->accflags & Modifier::ABSTRACT))\n \t{\n-\t  // FIXME: we should set abstract slots to a function that\n-\t  // throws AbstractMethodError.  How can we do that on IA-64?\n+\t  vtable->set_method(meth->index, (void *) &_Jv_abstractMethodError);\n \t  flags[meth->index] = false;\n \t}\n       else"}, {"sha": "96a81812219cff60ab6592d79cabe89e1df4f788", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "patch": "@@ -56,17 +56,18 @@ java::lang::ClassLoader::defineClass0 (jstring name,\n \t\t\t\t  sizeof (_Jv_InterpClass));\n   _Jv_InitNewClassFields (klass);\n \n-  // synchronize on the class, so that it is not\n-  // attempted initialized until we're done loading.\n-  _Jv_MonitorEnter (klass);\n+  // Synchronize on the class, so that it is not attempted initialized\n+  // until we're done loading.\n+  JvSynchronize sync (klass);\n \n-  // record which is the defining loader\n-  klass->loader = this;\n+  // Record the defining loader.  For the system class loader, we\n+  // record NULL.\n+  if (this != java::lang::ClassLoader::getSystemClassLoader())\n+    klass->loader = this;\n \n-  // register that we are the initiating loader...\n   if (name != 0)\n     {\n-      _Jv_Utf8Const *   name2 = _Jv_makeUtf8Const (name);\n+      _Jv_Utf8Const *name2 = _Jv_makeUtf8Const (name);\n \n       if (! _Jv_VerifyClassName (name2))\n \tthrow new java::lang::ClassFormatError\n@@ -86,16 +87,8 @@ java::lang::ClassLoader::defineClass0 (jstring name,\n \n       _Jv_UnregisterClass (klass);\n \n-      _Jv_MonitorExit (klass);\n-\n-      // FIXME: Here we may want to test that EX does\n-      // indeed represent a valid exception.  That is,\n-      // anything but ClassNotFoundException, \n-      // or some kind of Error.\n-\n-      // FIXME: Rewrite this as a cleanup instead of\n-      // as a catch handler.\n-\n+      // If EX is not a ClassNotFoundException, that's ok, because we\n+      // account for the possibility in defineClass().\n       throw ex;\n     }\n     \n@@ -104,10 +97,6 @@ java::lang::ClassLoader::defineClass0 (jstring name,\n   // if everything proceeded sucessfully, we're loaded.\n   JvAssert (klass->state == JV_STATE_LOADED);\n \n-  // if an exception is generated, this is initially missed.\n-  // however, we come back here in handleException0 below...\n-  _Jv_MonitorExit (klass);\n-\n   return klass;\n \n #else // INTERPRETER\n@@ -293,10 +282,11 @@ _Jv_PrepareCompiledClass (jclass klass)\n // Hash function for Utf8Consts.\n #define HASH_UTF(Utf) (((Utf)->hash) % HASH_LEN)\n \n-struct _Jv_LoaderInfo {\n-    _Jv_LoaderInfo          *next;\n-    java::lang::Class       *klass;\n-    java::lang::ClassLoader *loader;\n+struct _Jv_LoaderInfo\n+{\n+  _Jv_LoaderInfo          *next;\n+  java::lang::Class       *klass;\n+  java::lang::ClassLoader *loader;\n };\n \n static _Jv_LoaderInfo *initiated_classes[HASH_LEN];\n@@ -309,9 +299,12 @@ static jclass loaded_classes[HASH_LEN];\n jclass\n _Jv_FindClassInCache (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n {\n-  _Jv_MonitorEnter (&java::lang::Class::class$);\n+  JvSynchronize sync (&java::lang::Class::class$);\n   jint hash = HASH_UTF (name);\n \n+  if (loader && loader == java::lang::ClassLoader::getSystemClassLoader())\n+    loader = NULL;\n+\n   // first, if LOADER is a defining loader, then it is also initiating\n   jclass klass;\n   for (klass = loaded_classes[hash]; klass; klass = klass->next)\n@@ -337,15 +330,13 @@ _Jv_FindClassInCache (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n \t}\n     }\n \n-  _Jv_MonitorExit (&java::lang::Class::class$);\n-\n   return klass;\n }\n \n void\n _Jv_UnregisterClass (jclass the_class)\n {\n-  _Jv_MonitorEnter (&java::lang::Class::class$);\n+  JvSynchronize sync (&java::lang::Class::class$);\n   jint hash = HASH_UTF(the_class->name);\n \n   jclass *klass = &(loaded_classes[hash]);\n@@ -363,29 +354,32 @@ _Jv_UnregisterClass (jclass the_class)\n     {\n       while (*info && (*info)->klass == the_class)\n \t{\n+\t  _Jv_LoaderInfo *old = *info;\n \t  *info = (*info)->next;\n+\t  _Jv_Free (old);\n \t}\n \n       if (*info == NULL)\n \tbreak;\n     }\n-\n-  _Jv_MonitorExit (&java::lang::Class::class$);\n }\n \n void\n _Jv_RegisterInitiatingLoader (jclass klass, java::lang::ClassLoader *loader)\n {\n-  // non-gc alloc!\n-  _Jv_LoaderInfo *info = (_Jv_LoaderInfo *) _Jv_Malloc (sizeof(_Jv_LoaderInfo));\n+  if (loader && loader == java::lang::ClassLoader::getSystemClassLoader())\n+    loader = NULL;\n+\n+  // This information can't be visible to the GC.\n+  _Jv_LoaderInfo *info\n+    = (_Jv_LoaderInfo *) _Jv_Malloc (sizeof(_Jv_LoaderInfo));\n   jint hash = HASH_UTF(klass->name);\n \n-  _Jv_MonitorEnter (&java::lang::Class::class$);\n+  JvSynchronize sync (&java::lang::Class::class$);\n   info->loader = loader;\n   info->klass  = klass;\n   info->next   = initiated_classes[hash];\n   initiated_classes[hash] = info;\n-  _Jv_MonitorExit (&java::lang::Class::class$);\n }\n \n // This function is called many times during startup, before main() is\n@@ -471,6 +465,9 @@ _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n     {\n       jstring sname = _Jv_NewStringUTF (name->data);\n \n+      java::lang::ClassLoader *sys\n+\t= java::lang::ClassLoader::getSystemClassLoader ();\n+\n       if (loader)\n \t{\n \t  // Load using a user-defined loader, jvmspec 5.3.2\n@@ -479,14 +476,14 @@ _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n \t  // If \"loader\" delegated the loadClass operation to another\n \t  // loader, explicitly register that it is also an initiating\n \t  // loader of the given class.\n-\t  if (klass && (klass->getClassLoader () != loader))\n+\t  java::lang::ClassLoader *delegate = (loader == sys\n+\t\t\t\t\t       ? NULL\n+\t\t\t\t\t       : loader);\n+\t  if (klass && klass->getClassLoaderInternal () != delegate)\n \t    _Jv_RegisterInitiatingLoader (klass, loader);\n \t}\n       else \n \t{\n-\t  java::lang::ClassLoader *sys\n-\t    = java::lang::ClassLoader::getSystemClassLoader ();\n-\n \t  // Load using the bootstrap loader jvmspec 5.3.1.\n \t  klass = sys->loadClass (sname, false); \n "}, {"sha": "8171a88feb5ccf415b83caadc5f11c0ec1a1b2a3", "filename": "libjava/java/lang/reflect/Modifier.java", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fjava%2Flang%2Freflect%2FModifier.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fjava%2Flang%2Freflect%2FModifier.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FModifier.java?ref=a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "patch": "@@ -1,5 +1,5 @@\n /* java.lang.reflect.Modifier\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -157,6 +157,17 @@ public Modifier()\n    */\n   static final int ALL_FLAGS = 0xfff;\n \n+  /**\n+   * GCJ-LOCAL: This access flag is set on methods we declare\n+   * internally but which must not be visible to reflection.\n+   */\n+  static final int INVISIBLE = 0x1000;\n+\n+  /**\n+   * GCJ-LOCAL: This access flag is set on interpreted classes.\n+   */\n+  static final int INTERPRETED = 0x1000;\n+\n   /**\n    * Check whether the given modifier is abstract.\n    * @param mod the modifier."}, {"sha": "00785eed8fc67540eff7e6e807d58aacd1f0a47d", "filename": "libjava/resolve.cc", "status": "modified", "additions": 74, "deletions": 10, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "patch": "@@ -238,17 +238,18 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n \n       // First search the class itself.\n       the_method = _Jv_SearchMethodInClass (owner, klass, \n-\t           method_name, method_signature);\n+\t\t\t\t\t    method_name, method_signature);\n \n       if (the_method != 0)\n         {\n \t  found_class = owner;\n           goto end_of_method_search;\n \t}\n \n-      // If we are resolving an interface method, search the interface's \n-      // superinterfaces (A superinterface is not an interface's superclass - \n-      // a superinterface is implemented by the interface).\n+      // If we are resolving an interface method, search the\n+      // interface's superinterfaces (A superinterface is not an\n+      // interface's superclass - a superinterface is implemented by\n+      // the interface).\n       if (pool->tags[index] == JV_CONSTANT_InterfaceMethodref)\n         {\n \t  _Jv_ifaces ifaces;\n@@ -257,8 +258,8 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n \t  ifaces.list = (jclass *) _Jv_Malloc (ifaces.len * sizeof (jclass *));\n \n \t  _Jv_GetInterfaces (owner, &ifaces);\t  \n-          \n-\t  for (int i=0; i < ifaces.count; i++)\n+\n+\t  for (int i = 0; i < ifaces.count; i++)\n \t    {\n \t      jclass cls = ifaces.list[i];\n \t      the_method = _Jv_SearchMethodInClass (cls, klass, method_name, \n@@ -269,9 +270,9 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n                   break;\n \t\t}\n \t    }\n-\t  \n+\n \t  _Jv_Free (ifaces.list);\n-\t  \n+\n \t  if (the_method != 0)\n \t    goto end_of_method_search;\n \t}\n@@ -281,7 +282,7 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n            cls = cls->getSuperclass ())\n \t{\n \t  the_method = _Jv_SearchMethodInClass (cls, klass, \n-\t               method_name, method_signature);\n+\t\t\t\t\t\tmethod_name, method_signature);\n           if (the_method != 0)\n \t    {\n \t      found_class = cls;\n@@ -363,6 +364,58 @@ _Jv_SearchMethodInClass (jclass cls, jclass klass,\n   return 0;\n }\n \n+// A helper for _Jv_PrepareClass.  This adds missing `Miranda methods'\n+// to a class.\n+void\n+_Jv_PrepareMissingMethods (jclass base2, jclass iface_class)\n+{\n+  _Jv_InterpClass *base = reinterpret_cast<_Jv_InterpClass *> (base2);\n+  for (int i = 0; i < iface_class->interface_count; ++i)\n+    {\n+      for (int j = 0; j < iface_class->interfaces[i]->method_count; ++j)\n+\t{\n+\t  _Jv_Method *meth = &iface_class->interfaces[i]->methods[j];\n+\t  // Don't bother with <clinit>.\n+\t  if (meth->name->data[0] == '<')\n+\t    continue;\n+\t  _Jv_Method *new_meth = _Jv_LookupDeclaredMethod (base, meth->name,\n+\t\t\t\t\t\t\t   meth->signature);\n+\t  if (! new_meth)\n+\t    {\n+\t      // We assume that such methods are very unlikely, so we\n+\t      // just reallocate the method array each time one is\n+\t      // found.  This greatly simplifies the searching --\n+\t      // otherwise we have to make sure that each such method\n+\t      // found is really unique among all superinterfaces.\n+\t      int new_count = base->method_count + 1;\n+\t      _Jv_Method *new_m\n+\t\t= (_Jv_Method *) _Jv_AllocBytes (sizeof (_Jv_Method)\n+\t\t\t\t\t\t * new_count);\n+\t      memcpy (new_m, base->methods,\n+\t\t      sizeof (_Jv_Method) * base->method_count);\n+\n+\t      // Add new method.\n+\t      new_m[base->method_count] = *meth;\n+\t      new_m[base->method_count].index = (_Jv_ushort) -1;\n+\t      new_m[base->method_count].accflags\n+\t\t|= java::lang::reflect::Modifier::INVISIBLE;\n+\n+\t      _Jv_MethodBase **new_im\n+\t\t= (_Jv_MethodBase **) _Jv_AllocBytes (sizeof (_Jv_MethodBase *)\n+\t\t\t\t\t\t      * new_count);\n+\t      memcpy (new_im, base->interpreted_methods,\n+\t\t      sizeof (_Jv_MethodBase *) * base->method_count);\n+\n+\t      base->methods = new_m;\n+\t      base->interpreted_methods = new_im;\n+\t      base->method_count = new_count;\n+\t    }\n+\t}\n+\n+      _Jv_PrepareMissingMethods (base, iface_class->interfaces[i]);\n+    }\n+}\n+\n void \n _Jv_PrepareClass(jclass klass)\n {\n@@ -516,13 +569,24 @@ _Jv_PrepareClass(jclass klass)\n \t}\n     }\n \n-  if (clz->accflags & Modifier::INTERFACE)\n+  if ((clz->accflags & Modifier::INTERFACE))\n     {\n       clz->state = JV_STATE_PREPARED;\n       clz->notifyAll ();\n       return;\n     }\n \n+  // A class might have so-called \"Miranda methods\".  This is a method\n+  // that is declared in an interface and not re-declared in an\n+  // abstract class.  Some compilers don't emit declarations for such\n+  // methods in the class; this will give us problems since we expect\n+  // a declaration for any method requiring a vtable entry.  We handle\n+  // this here by searching for such methods and constructing new\n+  // internal declarations for them.  We only need to do this for\n+  // abstract classes.\n+  if ((clz->accflags & Modifier::ABSTRACT))\n+    _Jv_PrepareMissingMethods (clz, clz);\n+\n   clz->vtable_method_count = -1;\n   _Jv_MakeVTable (clz);\n "}, {"sha": "d77e3145f638639557c4a295a7d2d4485276c988", "filename": "libjava/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FChangeLog?ref=a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "patch": "@@ -1,3 +1,7 @@\n+2002-12-19  Tom Tromey  <tromey@redhat.com>\n+\n+\t* libjava.jacks/jacks.xfail: Updated.\n+\n 2002-12-18  Tom Tromey  <tromey@redhat.com>\n \n \t* libjava.lang/pr8945.java: New file."}, {"sha": "1bb25df7fbfce2d63fafa28cde79f8929ac953e5", "filename": "libjava/testsuite/libjava.jacks/jacks.xfail", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Ftestsuite%2Flibjava.jacks%2Fjacks.xfail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca/libjava%2Ftestsuite%2Flibjava.jacks%2Fjacks.xfail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jacks%2Fjacks.xfail?ref=a1aba4f9a58dd40b19f7aeb117ab1a3bcc2a2cca", "patch": "@@ -151,12 +151,8 @@\n 8.1.2-enclosing-4\n 8.1.2-enclosing-5\n 8.1.3-object-3\n-8.1.3-superclass-10\n-8.1.3-superclass-12\n-8.1.3-superclass-13\n-8.1.4-superinterface-8\n-8.1.4-superinterface-10\n-8.1.4-superinterface-11\n+8.1.3-superclass-5\n+8.1.3-superclass-6\n 8.2-accessibility-inherited-member-5\n 8.8.5.1-example-1\n 8.8.5.1-example-3\n@@ -218,9 +214,14 @@\n 8.6-checked-exception-10\n 8.6-checked-exception-11\n 8.6-checked-exception-12\n+8.6-complete-1\n+8.6-complete-4\n+8.6-complete-5\n 8.6-abrupt-1\n 8.6-abrupt-4\n-8.5-inheritance-4\n+8.5-inheritance-1\n+8.5-inheritance-2\n+8.5-inheritance-3\n 8.5-inheritance-6\n 8.5.2-non-static-member-usage-2\n 8.4.6-miranda-2\n@@ -262,6 +263,8 @@\n 8.4.3-bad-1\n 8.4.3-bad-2\n 8.7-abrupt-1\n+8.7-complete-1\n+8.7-complete-3\n 5.1.3-dti-1\n 5.1.3-dti-2\n 5.1.3-fti-1\n@@ -448,15 +451,15 @@\n 15.9.1-unqualified-concrete-6\n 15.9.1-unqualified-concrete-7\n 15.9.1-unqualified-concrete-10\n-15.9.1-unqualified-concrete-15\n+15.9.1-unqualified-concrete-14\n 15.9.1-qualified-concrete-6\n 15.9.1-qualified-concrete-7\n 15.9.1-qualified-concrete-10\n 15.9.1-qualified-concrete-12\n 15.9.1-qualified-concrete-14\n 15.9.1-qualified-concrete-16\n 15.9.1-qualified-concrete-20\n-15.9.1-qualified-concrete-23\n+15.9.1-qualified-concrete-24\n 15.28-primitive-9\n 15.28-primitive-15\n 15.28-primitive-16\n@@ -601,9 +604,6 @@\n 9.1.1-in-interface-3\n 9.1.1-in-interface-9\n 9.1.1-in-interface-16\n-9.1.2-interface-3\n-9.1.2-interface-5\n-9.1.2-interface-6\n 9.1.2-supertype-1\n 9.2-implicit-2\n 9.2-implicit-3\n@@ -680,10 +680,6 @@\n 6.6.2.1-protected-instance-method-6\n 6.6.2.1-protected-instance-method-7\n 6.6.2.1-protected-type-2\n-6.6.2.1-protected-type-4\n-6.6.2.1-protected-type-5\n-6.6.2.1-protected-type-7\n-6.6.2.1-protected-type-8\n 6.6.1-8\n 6.6.1-11\n 6.6.1-array-2\n@@ -711,14 +707,14 @@\n 6.5.6.1-local-4\n 6.5.6.1-field-6\n 6.5.6.1-explicit-constructor-2\n-6.5.4.2-qualified-1\n 6.5.4.1-simple-6\n-6.5.4.1-simple-8\n+6.5.4.1-simple-10\n+6.5.4.1-simple-11\n 6.5.1-type-15\n 6.5.1-type-16\n 6.5.1-type-19\n-6.5.1-typeorpackage-1\n 6.5.1-typeorpackage-2\n+6.5.5.2-type-4\n 6.5.5.2-type-5\n 6.5.5.2-type-6\n 6.5.5.2-type-7\n@@ -733,18 +729,17 @@\n 6.5.5.1-nested-19\n 6.5.5.1-nested-20\n 6.5.5.1-nested-21\n-6.5.5.1-nested-22\n 6.5.5.1-nested-23\n 6.3-1\n+7.4.2-subpackage-1\n+7.4.2-subpackage-2\n 7.5.1-canonical-3\n 7.5.1-accessible-1\n 7.5.1-duplicate-4\n 7.5.2-canonical-3\n 7.5.2-accessible-1\n 7.5.2-accessible-3\n 7.5.2-duplicate-3\n-7.1-named-5\n-7.1-named-6\n 7.1-named-7\n 7.6-unnamed-scope-1\n 4.5.4-static-1\n@@ -805,7 +800,6 @@ non-jls-zip-2\n 14-runtime-jump-1\n 14-runtime-jump-2\n 14.3.1-runtime-3\n-14.19.2-runtime-try-1\n 8.1.2-runtime-1\n 6.6.1-runtime-privateconstructor-1\n 8.8.3-runtime-inner-4\n@@ -831,11 +825,11 @@ non-jls-zip-2\n 15.11.1-runtime-static-1\n 15.11.1-runtime-static-2\n 15.11.1-runtime-static-3\n+15.11.1-runtime-static-4\n 15.12.3-runtime-mode-1\n 15.12.3-runtime-mode-2\n 15.12.3-runtime-mode-3\n 15.12.3-runtime-mode-4\n-15.12.3-runtime-mode-5\n 15.12.3-runtime-mode-6\n 15.12.4.1-runtime-static-1\n 15.12.4.1-runtime-static-2"}]}