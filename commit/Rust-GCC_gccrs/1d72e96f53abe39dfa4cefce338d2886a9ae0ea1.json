{"sha": "1d72e96f53abe39dfa4cefce338d2886a9ae0ea1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ3MmU5NmY1M2FiZTM5ZGZhNGNlZmNlMzM4ZDI4ODZhOWFlMGVhMQ==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2012-04-26T07:14:01Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2012-04-26T07:14:01Z"}, "message": "tree-diagnostic.c (maybe_unwind_expanded_macro_loc): Fix comment.\n\n2012-04-26  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\t* tree-diagnostic.c (maybe_unwind_expanded_macro_loc): Fix\n\tcomment. Delete unused parameter first_exp_point_map.\n\t(virt_loc_aware_diagnostic_finalizer): Update call.\nlibcpp/\n\t* line-map.c (linemap_resolve_location): Synchronize comments with\n\tthose in line-map.h.\n\t* include/line-map.h (linemap_resolve_location): Fix spelling in\n\tcomment.\n\nFrom-SVN: r186860", "tree": {"sha": "d3312d2f0112387a0c5c243b879b69fbce449e0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3312d2f0112387a0c5c243b879b69fbce449e0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1/comments", "author": null, "committer": null, "parents": [{"sha": "c7121189c39bdda5e94360cf03002c2b2fe865cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7121189c39bdda5e94360cf03002c2b2fe865cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7121189c39bdda5e94360cf03002c2b2fe865cd"}], "stats": {"total": 52, "additions": 31, "deletions": 21}, "files": [{"sha": "f4b212fb28e2ef79f125c136fa9e568841a485dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d72e96f53abe39dfa4cefce338d2886a9ae0ea1", "patch": "@@ -1,3 +1,9 @@\n+2012-04-26  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\t* tree-diagnostic.c (maybe_unwind_expanded_macro_loc): Fix\n+\tcomment. Delete unused parameter first_exp_point_map.\n+\t(virt_loc_aware_diagnostic_finalizer): Update call.\n+\n 2012-04-26  Michael Hope  <michael.hope@linaro.org>\n \t    Richard Earnshaw  <rearnsha@arm.com>\n "}, {"sha": "48c78000703efc7a9e0c0ab4de6b433d1d4f2583", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=1d72e96f53abe39dfa4cefce338d2886a9ae0ea1", "patch": "@@ -95,23 +95,18 @@ DEF_VEC_ALLOC_O (loc_map_pair, heap);\n     test.c:5:3: note: expanded from here\n     test.c:5:14: note: in expansion of macro 'SHIFTL'\n     test.c:8:3: note: expanded from here\n-    test.c:8:3: note: in expansion of macro 'MULT2'\n+    test.c:8:3: note: in expansion of macro 'MULT'\n     test.c:13:3: note: expanded from here\n \n    The part that goes from the third to the eighth line of this\n    diagnostic (the lines containing the 'note:' string) is called the\n    unwound macro expansion trace.  That's the part generated by this\n-   function.\n-\n-   If FIRST_EXP_POINT_MAP is non-null, *FIRST_EXP_POINT_MAP is set to\n-   the map of the location in the source that first triggered the\n-   macro expansion.  This must be an ordinary map.  */\n+   function.  */\n \n static void\n maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n                                  diagnostic_info *diagnostic,\n-                                 source_location where,\n-                                 const struct line_map **first_exp_point_map)\n+                                 source_location where)\n {\n   const struct line_map *map;\n   VEC(loc_map_pair,heap) *loc_vec = NULL;\n@@ -146,8 +141,8 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n       where = linemap_unwind_toward_expansion (line_table, where, &map);\n     } while (linemap_macro_expansion_map_p (map));\n \n-  if (first_exp_point_map)\n-    *first_exp_point_map = map;\n+  /* Now map is set to the map of the location in the source that\n+     first triggered the macro expansion.  This must be an ordinary map.  */\n \n   /* Walk LOC_VEC and print the macro expansion trace, unless the\n      first macro which expansion triggered this trace was expanded\n@@ -227,8 +222,7 @@ virt_loc_aware_diagnostic_finalizer (diagnostic_context *context,\n \t\t\t\t     diagnostic_info *diagnostic)\n {\n   maybe_unwind_expanded_macro_loc (context, diagnostic,\n-\t\t\t\t   diagnostic->location,\n-\t\t\t\t   NULL);\n+\t\t\t\t   diagnostic->location);\n }\n \n /* Default tree printer.   Handles declarations only.  */"}, {"sha": "08878b2781106dbc1c1f5d323041ca6c035f764e", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=1d72e96f53abe39dfa4cefce338d2886a9ae0ea1", "patch": "@@ -1,3 +1,10 @@\n+2012-04-26  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\t* line-map.c (linemap_resolve_location): Synchronize comments with\n+\tthose in line-map.h.\n+\t* include/line-map.h (linemap_resolve_location): Fix spelling in\n+\tcomment.\n+\n 2012-03-22  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* lex.c (search_line_fast): Provide Neon-optimized version for ARM."}, {"sha": "22e2f0fc3c675d34d8d8e9c3cc984237126a8910", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=1d72e96f53abe39dfa4cefce338d2886a9ae0ea1", "patch": "@@ -651,7 +651,7 @@ enum location_resolution_kind\n    LRK_SPELLING_LOCATION.\n \n    If LOC_MAP is not NULL, *LOC_MAP is set to the map encoding the\n-   returned location.  Note that if the resturned location wasn't originally\n+   returned location.  Note that if the returned location wasn't originally\n    encoded by a map, the *MAP is set to NULL.  This can happen if LOC\n    resolves to a location reserved for the client code, like\n    UNKNOWN_LOCATION or BUILTINS_LOCATION in GCC.  */"}, {"sha": "106a4b515a7197366642551d0ec182f2727190f2", "filename": "libcpp/line-map.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=1d72e96f53abe39dfa4cefce338d2886a9ae0ea1", "patch": "@@ -1015,19 +1015,22 @@ linemap_macro_loc_to_exp_point (struct line_maps *set,\n    * If LRK is set to LRK_MACRO_EXPANSION_POINT\n    -------------------------------\n \n-   The virtual location is resolved to the location to the locus of\n-   the expansion point of the macro.\n+   The virtual location is resolved to the first macro expansion point\n+   that led to this macro expansion.\n \n    * If LRK is set to LRK_SPELLING_LOCATION\n    -------------------------------------\n \n-   The virtual location is resolved to the location to the locus where\n-   the token has been spelled in the source. This can follow through\n-   all the macro expansions that led to the token.\n+   The virtual location is resolved to the locus where the token has\n+   been spelled in the source.   This can follow through all the macro\n+   expansions that led to the token.\n \n-   * If LRK is set to LRK_MACRO_PARM_REPLACEMENT_POINT\n+   * If LRK is set to LRK_MACRO_DEFINITION_LOCATION\n    --------------------------------------\n \n+   The virtual location is resolved to the locus of the token in the\n+   context of the macro definition.\n+\n    If LOC is the locus of a token that is an argument of a\n    function-like macro [replacing a parameter in the replacement list\n    of the macro] the virtual location is resolved to the locus of the\n@@ -1038,8 +1041,8 @@ linemap_macro_loc_to_exp_point (struct line_maps *set,\n    function-like macro, then the function behaves as if LRK was set to\n    LRK_SPELLING_LOCATION.\n \n-   If MAP is non-NULL, *MAP is set to the map of the resolved\n-   location.  Note that if the resturned location wasn't originally\n+   If LOC_MAP is not NULL, *LOC_MAP is set to the map encoding the\n+   returned location.  Note that if the returned location wasn't originally\n    encoded by a map, the *MAP is set to NULL.  This can happen if LOC\n    resolves to a location reserved for the client code, like\n    UNKNOWN_LOCATION or BUILTINS_LOCATION in GCC.  */"}]}