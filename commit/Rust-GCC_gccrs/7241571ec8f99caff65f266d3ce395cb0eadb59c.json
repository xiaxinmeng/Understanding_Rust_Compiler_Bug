{"sha": "7241571ec8f99caff65f266d3ce395cb0eadb59c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI0MTU3MWVjOGY5OWNhZmY2NWYyNjZkM2NlMzk1Y2IwZWFkYjU5Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-10-07T18:48:40Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-10-07T18:48:40Z"}, "message": "re PR middle-end/29609 (Even with  -O0 -g gcc optimizes a goto away and I cannot debug)\n\n\tPR debug/29609\n\tPR debug/36690\n\tPR debug/37616\n\t* basic-block.h (struct edge_def): Add goto_block field.\n\t* cfglayout.c (fixup_reorder_chain): Ensure that there is at least\n\tone insn with locus corresponding to edge's goto_locus if !optimize.\n\t* profile.c (branch_prob): Copy edge's goto_block.\n\t* cfgrtl.c (force_nonfallthru_and_redirect): Use goto_locus for\n\temitted jumps.\n\t(cfg_layout_merge_blocks): Emit a nop with edge's goto_locus\n\tlocator in between the merged basic blocks if !optimize and needed.\n\t* cfgexpand.c (expand_gimple_cond): Convert goto_block and\n\tgoto_locus into RTL locator.  For unconditional jump use that\n\tlocator for the jump insn.\n\t(expand_gimple_cond): Convert goto_block and goto_locus into\n\tRTL locator for all remaining edges.  For unconditional jump\n\tuse that locator for the jump insn.\n\t* cfgcleanup.c (try_forward_edges): Avoid the optimization if\n\tthere is more than one edge or insn locator along the forwarding\n\tedges and !optimize.  If there is just one, set e->goto_locus.\n\t* tree-cfg.c (make_cond_expr_edges, make_goto_expr_edges): Set also\n\tedge's goto_block.\n\t(move_block_to_fn): Adjust edge's goto_block.\n\n\t* gcc.dg/debug/pr29609-1.c: New test.\n\t* gcc.dg/debug/pr29609-2.c: New test.\n\t* gcc.dg/debug/pr36690-1.c: New test.\n\t* gcc.dg/debug/pr36690-2.c: New test.\n\t* gcc.dg/debug/pr36690-3.c: New test.\n\t* gcc.dg/debug/pr37616.c: New test.\n\t* gcc.dg/debug/dwarf2/pr29609-1.c: New test.\n\t* gcc.dg/debug/dwarf2/pr29609-2.c: New test.\n\t* gcc.dg/debug/dwarf2/pr36690-1.c: New test.\n\t* gcc.dg/debug/dwarf2/pr36690-2.c: New test.\n\t* gcc.dg/debug/dwarf2/pr36690-3.c: New test.\n\t* gcc.dg/debug/dwarf2/pr37616.c: New test.\n\nFrom-SVN: r140948", "tree": {"sha": "03f51a3cfb0818209eab45192a2bd9ce8a4fa7c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03f51a3cfb0818209eab45192a2bd9ce8a4fa7c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7241571ec8f99caff65f266d3ce395cb0eadb59c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7241571ec8f99caff65f266d3ce395cb0eadb59c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7241571ec8f99caff65f266d3ce395cb0eadb59c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7241571ec8f99caff65f266d3ce395cb0eadb59c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aee857a2f4fbbcf0d3fde1d80c8c40d53b5edab1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee857a2f4fbbcf0d3fde1d80c8c40d53b5edab1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aee857a2f4fbbcf0d3fde1d80c8c40d53b5edab1"}], "stats": {"total": 702, "additions": 679, "deletions": 23}, "files": [{"sha": "0c0208699b5577d79e7e1a05c0d635306738f2db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -1,3 +1,29 @@\n+2008-10-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/29609\n+\tPR debug/36690\n+\tPR debug/37616\n+\t* basic-block.h (struct edge_def): Add goto_block field.\n+\t* cfglayout.c (fixup_reorder_chain): Ensure that there is at least\n+\tone insn with locus corresponding to edge's goto_locus if !optimize.\n+\t* profile.c (branch_prob): Copy edge's goto_block.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect): Use goto_locus for\n+\temitted jumps.\n+\t(cfg_layout_merge_blocks): Emit a nop with edge's goto_locus\n+\tlocator in between the merged basic blocks if !optimize and needed.\n+\t* cfgexpand.c (expand_gimple_cond): Convert goto_block and\n+\tgoto_locus into RTL locator.  For unconditional jump use that\n+\tlocator for the jump insn.\n+\t(expand_gimple_cond): Convert goto_block and goto_locus into\n+\tRTL locator for all remaining edges.  For unconditional jump\n+\tuse that locator for the jump insn.\n+\t* cfgcleanup.c (try_forward_edges): Avoid the optimization if\n+\tthere is more than one edge or insn locator along the forwarding\n+\tedges and !optimize.  If there is just one, set e->goto_locus.\n+\t* tree-cfg.c (make_cond_expr_edges, make_goto_expr_edges): Set also\n+\tedge's goto_block.\n+\t(move_block_to_fn): Adjust edge's goto_block.\n+\n 2008-10-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR middle-end/37731"}, {"sha": "f954c9ffa5dcafc27524b35fa4d86495b0ce9755", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -129,7 +129,8 @@ struct edge_def GTY(())\n   /* Auxiliary info specific to a pass.  */\n   PTR GTY ((skip (\"\"))) aux;\n \n-  /* Location of any goto implicit in the edge, during tree-ssa.  */\n+  /* Location of any goto implicit in the edge and associated BLOCK.  */\n+  tree goto_block;\n   location_t goto_locus;\n \n   /* The index number corresponding to this edge in the edge vector"}, {"sha": "8b9756def217439d7a4a5b654509cdc48a58bda0", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -429,7 +429,7 @@ try_forward_edges (int mode, basic_block b)\n   for (ei = ei_start (b->succs); (e = ei_safe_edge (ei)); )\n     {\n       basic_block target, first;\n-      int counter;\n+      int counter, goto_locus;\n       bool threaded = false;\n       int nthreaded_edges = 0;\n       bool may_thread = first_pass | df_get_bb_dirty (b);\n@@ -447,6 +447,7 @@ try_forward_edges (int mode, basic_block b)\n \n       target = first = e->dest;\n       counter = NUM_FIXED_BLOCKS;\n+      goto_locus = e->goto_locus;\n \n       /* If we are partitioning hot/cold basic_blocks, we don't want to mess\n \t up jumps that cross between hot/cold sections.\n@@ -476,6 +477,27 @@ try_forward_edges (int mode, basic_block b)\n \t      new_target = single_succ (target);\n \t      if (target == new_target)\n \t\tcounter = n_basic_blocks;\n+\t      else if (!optimize)\n+\t\t{\n+\t\t  /* When not optimizing, ensure that edges or forwarder\n+\t\t     blocks with different locus are not optimized out.  */\n+\t\t  int locus = single_succ_edge (target)->goto_locus;\n+\n+\t\t  if (locus && goto_locus && locus != goto_locus)\n+\t\t    counter = n_basic_blocks;\n+\t\t  else if (locus)\n+\t\t    goto_locus = locus;\n+\n+\t\t  if (INSN_P (BB_END (target)))\n+\t\t    {\n+\t\t      locus = INSN_LOCATOR (BB_END (target));\n+\n+\t\t      if (locus && goto_locus && locus != goto_locus)\n+\t\t\tcounter = n_basic_blocks;\n+\t\t      else if (locus)\n+\t\t\tgoto_locus = locus;\n+\t\t    }\n+\t\t}\n \t    }\n \n \t  /* Allow to thread only over one edge at time to simplify updating\n@@ -539,6 +561,8 @@ try_forward_edges (int mode, basic_block b)\n \t  int edge_frequency;\n \t  int n = 0;\n \n+\t  e->goto_locus = goto_locus;\n+\n \t  /* Don't force if target is exit block.  */\n \t  if (threaded && target != EXIT_BLOCK_PTR)\n \t    {"}, {"sha": "e94fe356e1c2cbca9c680a9b43e2088ab4e43628", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -1666,7 +1666,12 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n       add_reg_br_prob_note (last, true_edge->probability);\n       maybe_dump_rtl_for_gimple_stmt (stmt, last);\n       if (true_edge->goto_locus)\n-  \tset_curr_insn_source_location (true_edge->goto_locus);\n+\t{\n+\t  set_curr_insn_source_location (true_edge->goto_locus);\n+\t  set_curr_insn_block (true_edge->goto_block);\n+\t  true_edge->goto_locus = curr_insn_locator ();\n+\t}\n+      true_edge->goto_block = NULL;\n       false_edge->flags |= EDGE_FALLTHRU;\n       ggc_free (pred);\n       return NULL;\n@@ -1677,7 +1682,12 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n       add_reg_br_prob_note (last, false_edge->probability);\n       maybe_dump_rtl_for_gimple_stmt (stmt, last);\n       if (false_edge->goto_locus)\n-  \tset_curr_insn_source_location (false_edge->goto_locus);\n+\t{\n+\t  set_curr_insn_source_location (false_edge->goto_locus);\n+\t  set_curr_insn_block (false_edge->goto_block);\n+\t  false_edge->goto_locus = curr_insn_locator ();\n+\t}\n+      false_edge->goto_block = NULL;\n       true_edge->flags |= EDGE_FALLTHRU;\n       ggc_free (pred);\n       return NULL;\n@@ -1686,6 +1696,13 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n   jumpif (pred, label_rtx_for_bb (true_edge->dest));\n   add_reg_br_prob_note (last, true_edge->probability);\n   last = get_last_insn ();\n+  if (false_edge->goto_locus)\n+    {\n+      set_curr_insn_source_location (false_edge->goto_locus);\n+      set_curr_insn_block (false_edge->goto_block);\n+      false_edge->goto_locus = curr_insn_locator ();\n+    }\n+  false_edge->goto_block = NULL;\n   emit_jump (label_rtx_for_bb (false_edge->dest));\n \n   BB_END (bb) = last;\n@@ -1708,9 +1725,6 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n \n   maybe_dump_rtl_for_gimple_stmt (stmt, last2);\n \n-  if (false_edge->goto_locus)\n-    set_curr_insn_source_location (false_edge->goto_locus);\n-\n   ggc_free (pred);\n   return new_bb;\n }\n@@ -1962,19 +1976,21 @@ expand_gimple_basic_block (basic_block bb)\n \t}\n     }\n \n-  /* Expand implicit goto.  */\n+  /* Expand implicit goto and convert goto_locus.  */\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-      if (e->flags & EDGE_FALLTHRU)\n-\tbreak;\n-    }\n-\n-  if (e && e->dest != bb->next_bb)\n-    {\n-      emit_jump (label_rtx_for_bb (e->dest));\n-      if (e->goto_locus)\n-        set_curr_insn_source_location (e->goto_locus);\n-      e->flags &= ~EDGE_FALLTHRU;\n+      if (e->goto_locus && e->goto_block)\n+\t{\n+\t  set_curr_insn_source_location (e->goto_locus);\n+\t  set_curr_insn_block (e->goto_block);\n+\t  e->goto_locus = curr_insn_locator ();\n+\t}\n+      e->goto_block = NULL;\n+      if ((e->flags & EDGE_FALLTHRU) && e->dest != bb->next_bb)\n+\t{\n+\t  emit_jump (label_rtx_for_bb (e->dest));\n+\t  e->flags &= ~EDGE_FALLTHRU;\n+\t}\n     }\n \n   do_pending_stack_adjust ();"}, {"sha": "be1188d0b615ef2c77910f29a6b5cbd351987ae4", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -887,6 +887,46 @@ fixup_reorder_chain (void)\n       if (e && !can_fallthru (e->src, e->dest))\n \tforce_nonfallthru (e);\n     }\n+\n+  /* Ensure goto_locus from edges has some instructions with that locus\n+     in RTL.  */\n+  if (!optimize)\n+    FOR_EACH_BB (bb)\n+      {\n+        edge e;\n+        edge_iterator ei;\n+\n+        FOR_EACH_EDGE (e, ei, bb->succs)\n+\t  if (e->goto_locus && !(e->flags & EDGE_ABNORMAL))\n+\t    {\n+\t      basic_block nb;\n+\n+\t      if (simplejump_p (BB_END (e->src)))\n+\t\t{\n+\t\t  if (INSN_LOCATOR (BB_END (e->src)) == (int) e->goto_locus)\n+\t\t    continue;\n+\t\t  if (INSN_LOCATOR (BB_END (e->src)) == 0)\n+\t\t    {\n+\t\t      INSN_LOCATOR (BB_END (e->src)) = e->goto_locus;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      if (e->dest != EXIT_BLOCK_PTR)\n+\t\t{\n+\t\t  insn = BB_HEAD (e->dest);\n+\t\t  if (!INSN_P (insn))\n+\t\t    insn = next_insn (insn);\n+\t\t  if (insn && INSN_P (insn)\n+\t\t      && INSN_LOCATOR (insn) == (int) e->goto_locus)\n+\t\t    continue;\n+\t\t}\n+\t      nb = split_edge (e);\n+\t      if (!INSN_P (BB_END (nb)))\n+\t\tBB_END (nb) = emit_insn_after_noloc (gen_nop (), BB_END (nb),\n+\t\t\t\t\t\t     nb);\n+\t      INSN_LOCATOR (BB_END (nb)) = e->goto_locus;\n+\t    }\n+      }\n }\n \f\n /* Perform sanity checks on the insn chain."}, {"sha": "24469ebf30de3f28508ba55aa5024ea0512cb884", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -1009,6 +1009,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n   rtx note;\n   edge new_edge;\n   int abnormal_edge_flags = 0;\n+  int loc;\n \n   /* In the case the last instruction is conditional jump to the next\n      instruction, first redirect the jump itself and then continue\n@@ -1127,19 +1128,23 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n   else\n     jump_block = e->src;\n \n+  if (e->goto_locus && e->goto_block == NULL)\n+    loc = e->goto_locus;\n+  else\n+    loc = 0;\n   e->flags &= ~EDGE_FALLTHRU;\n   if (target == EXIT_BLOCK_PTR)\n     {\n #ifdef HAVE_return\n-\temit_jump_insn_after_noloc (gen_return (), BB_END (jump_block));\n+\temit_jump_insn_after_setloc (gen_return (), BB_END (jump_block), loc);\n #else\n \tgcc_unreachable ();\n #endif\n     }\n   else\n     {\n       rtx label = block_label (target);\n-      emit_jump_insn_after_noloc (gen_jump (label), BB_END (jump_block));\n+      emit_jump_insn_after_setloc (gen_jump (label), BB_END (jump_block), loc);\n       JUMP_LABEL (BB_END (jump_block)) = label;\n       LABEL_NUSES (label)++;\n     }\n@@ -2606,6 +2611,32 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n     try_redirect_by_replacing_jump (EDGE_SUCC (a, 0), b, true);\n   gcc_assert (!JUMP_P (BB_END (a)));\n \n+  /* When not optimizing and the edge is the only place in RTL which holds\n+     some unique locus, emit a nop with that locus in between.  */\n+  if (!optimize && EDGE_SUCC (a, 0)->goto_locus)\n+    {\n+      rtx insn = BB_END (a);\n+      int goto_locus = EDGE_SUCC (a, 0)->goto_locus;\n+\n+      if (NOTE_P (insn))\n+\tinsn = prev_nonnote_insn (insn);\n+      if (insn && INSN_P (insn) && INSN_LOCATOR (insn) == goto_locus)\n+\tgoto_locus = 0;\n+      else\n+\t{\n+\t  insn = BB_HEAD (b);\n+\t  if (!INSN_P (insn))\n+\t    insn = next_insn (insn);\n+\t  if (insn && INSN_P (insn) && INSN_LOCATOR (insn) == goto_locus)\n+\t    goto_locus = 0;\n+\t}\n+      if (goto_locus)\n+\t{\n+\t  BB_END (a) = emit_insn_after_noloc (gen_nop (), BB_END (a), a);\n+\t  INSN_LOCATOR (BB_END (a)) = goto_locus;\n+\t}\n+    }\n+\n   /* Possible line number notes should appear in between.  */\n   if (b->il.rtl->header)\n     {"}, {"sha": "976d91cc17bc58e403e2322fd5e18b9cc278f23a", "filename": "gcc/profile.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -960,10 +960,12 @@ branch_prob (void)\n \t      && (LOCATION_FILE (e->goto_locus)\n \t          != LOCATION_FILE (gimple_location (last))\n \t\t  || (LOCATION_LINE (e->goto_locus)\n-\t\t      != LOCATION_LINE (gimple_location  (last)))))\n+\t\t      != LOCATION_LINE (gimple_location (last)))))\n \t    {\n \t      basic_block new_bb = split_edge (e);\n-\t      single_succ_edge (new_bb)->goto_locus = e->goto_locus;\n+\t      edge ne = single_succ_edge (new_bb);\n+\t      ne->goto_locus = e->goto_locus;\n+\t      ne->goto_block = e->goto_block;\n \t    }\n \t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n \t       && e->dest != EXIT_BLOCK_PTR)"}, {"sha": "3ba82219cf299e5139b2b1e89b2abd7a406049e3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -1,3 +1,21 @@\n+2008-10-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/29609\n+\tPR debug/36690\n+\tPR debug/37616\n+\t* gcc.dg/debug/pr29609-1.c: New test.\n+\t* gcc.dg/debug/pr29609-2.c: New test.\n+\t* gcc.dg/debug/pr36690-1.c: New test.\n+\t* gcc.dg/debug/pr36690-2.c: New test.\n+\t* gcc.dg/debug/pr36690-3.c: New test.\n+\t* gcc.dg/debug/pr37616.c: New test.\n+\t* gcc.dg/debug/dwarf2/pr29609-1.c: New test.\n+\t* gcc.dg/debug/dwarf2/pr29609-2.c: New test.\n+\t* gcc.dg/debug/dwarf2/pr36690-1.c: New test.\n+\t* gcc.dg/debug/dwarf2/pr36690-2.c: New test.\n+\t* gcc.dg/debug/dwarf2/pr36690-3.c: New test.\n+\t* gcc.dg/debug/dwarf2/pr37616.c: New test.\n+\n 2008-10-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR middle-end/37731"}, {"sha": "5476aac0afd715ab6472c13c32781dc3ce227076", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/pr29609-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr29609-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr29609-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr29609-1.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,32 @@\n+/* PR debug/29609 */\n+/* Verify that breakpoint on the break is hit.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+\n+void abort (void);\n+\n+int\n+foo (void)\n+{\n+  int a, i;\n+\n+  for (i = 1; i <= 10; i++)\n+    {\n+      if (i < 3)\n+\ta = 1;\n+      else\n+\tbreak;\n+      a = 5;\n+    }\n+  return a;\n+}\n+\n+int\n+main (void)\n+{\n+  if (foo () != 5)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"pr29609-1.c:18\" } } */"}, {"sha": "43bc54524a999ffa4d8753df250d44462fb0f8e0", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/pr29609-2.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr29609-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr29609-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr29609-2.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,53 @@\n+/* PR debug/29609 */\n+/* Verify that breakpoint on both goto failure; stmts is hit.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+\n+extern void abort (void);\n+int x;\n+\n+int\n+foo (void)\n+{\n+  return 0 ^ x;\n+}\n+\n+int\n+bar (void)\n+{\n+  return 1 ^ x;\n+}\n+\n+int\n+baz (void)\n+{\n+  int c;\n+\n+  if (!foo ())\n+    goto failure;\n+\n+  if (!bar ())\n+    goto failure;\n+\n+  return 0;\n+\n+failure:\n+  return 1;\n+}\n+\n+int\n+main (void)\n+{\n+  if (baz () != 1)\n+    abort ();\n+  x = 1;\n+  if (baz () != 1)\n+    abort ();\n+  x = 2;\n+  if (baz () != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"pr29609-2.c:27\" } } */\n+/* { dg-final { scan-assembler \"pr29609-2.c:30\" } } */"}, {"sha": "de90acb81bf76c6c4ae40d748eac26a0ec24e298", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr36690-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr36690-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr36690-1.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,22 @@\n+/* PR debug/36690 */\n+/* Verify that break func is hit.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+\n+int i;\n+\n+void\n+func (void)\n+{\n+  while (i == 1)\n+    i = 0;\n+}\n+\n+int\n+main (void)\n+{\n+  func ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"pr36690-1.c:11\" } } */"}, {"sha": "2330f53858e6a659e06eacdf89831be1b8effa84", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-2.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr36690-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr36690-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr36690-2.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,39 @@\n+/* PR debug/36690 */\n+/* Verify that breakpoint can be put on goto f1, it is hit and\n+   varz at that spot is defined and contains 5.  Nowhere else\n+   in the function should be varz in the scope.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+\n+int cnt;\n+\n+void\n+bar (int i)\n+{\n+  cnt += i;\n+}\n+\n+void\n+foo (int i)\n+{\n+  if (!i)\n+    bar (0);\n+  else\n+    {\n+      static int varz = 5;\n+      goto f1;\n+    }\n+  bar (1);\n+f1:\n+  bar (2);\n+}\n+\n+int\n+main (void)\n+{\n+  foo (0);\n+  foo (1);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"pr36690-2.c:24\" } } */"}, {"sha": "234ad1263b28ef93cbedd2413209001caf1e8a9a", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-3.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr36690-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr36690-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr36690-3.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,53 @@\n+/* PR debug/36690 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+\n+int cnt;\n+\n+void\n+bar (int i)\n+{\n+  cnt += i;\n+}\n+\n+void\n+foo (int i, int j)\n+{\n+  if (j)\n+    {\n+      bar (i + 1);\n+      goto f1;\n+    }\n+  bar (i + 2);\n+  goto f2;\n+f1:\n+  if (i > 10)\n+    goto f3;\n+f2:\n+  if (i > 40)\n+    goto f4;\n+  else\n+    goto f5;\n+f3:\n+  bar (i);\n+f4:\n+  bar (i);\n+f5:\n+  bar (i);\n+}\n+\n+int\n+main (void)\n+{\n+  foo (0, 1);\n+  foo (11, 1);\n+  foo (21, 0);\n+  foo (41, 0);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"pr36690-3.c:19\" } } */\n+/* { dg-final { scan-assembler \"pr36690-3.c:22\" } } */\n+/* { dg-final { scan-assembler \"pr36690-3.c:25\" } } */\n+/* { dg-final { scan-assembler \"pr36690-3.c:28\" } } */\n+/* { dg-final { scan-assembler \"pr36690-3.c:30\" } } */"}, {"sha": "badff447a8bc52e1bec0eac117f335fda97abc18", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/pr37616.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr37616.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr37616.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr37616.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,41 @@\n+/* PR debug/37616 */\n+/* Test that one can put breakpoints onto continue, exitlab and break\n+   and actually see program reaching those breakpoints.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gdwarf-2 -dA\" } */\n+\n+extern void abort (void);\n+\n+int\n+foo (int parm)\n+{\n+  int varj, varm;\n+\n+  for (varj = 0; varj < 10; varj++)\n+    {\n+      if (varj == 5)\n+\tcontinue;\n+      if (varj == 7 && !parm)\n+\tgoto exitlab;\n+      if (varj == 9)\n+\tbreak;\n+      varm = varj;\n+    }\n+\n+exitlab:\n+  return varm;\n+}\n+\n+int\n+main (void)\n+{\n+  if (foo (0) != 6)\n+    abort ();\n+  if (foo (1) != 8)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"pr37616.c:17\" } } */\n+/* { dg-final { scan-assembler \"pr37616.c:19\" } } */\n+/* { dg-final { scan-assembler \"pr37616.c:21\" } } */"}, {"sha": "85069ebd650efac884e845d5ae9ccb21cbd9d047", "filename": "gcc/testsuite/gcc.dg/debug/pr29609-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr29609-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr29609-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr29609-1.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,33 @@\n+/* PR debug/29609 */\n+/* Verify that breakpoint on the break is hit.\n+   This version of the test just checks that it can be compiled, linked\n+   and executed, further testing is done in corresponding gcc.dg/dwarf2/\n+   test and hopefully in gdb testsuite.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O0 -g -dA\" } */\n+\n+extern void abort (void);\n+\n+int\n+foo (void)\n+{\n+  int a, i;\n+\n+  for (i = 1; i <= 10; i++)\n+    {\n+      if (i < 3)\n+\ta = 1;\n+      else\n+\tbreak;\n+      a = 5;\n+    }\n+  return a;\n+}\n+\n+int\n+main (void)\n+{\n+  if (foo () != 5)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "1ae1a738d9790e9fe9422c3fa88ffa32bf3cdccf", "filename": "gcc/testsuite/gcc.dg/debug/pr29609-2.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr29609-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr29609-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr29609-2.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,53 @@\n+/* PR debug/29609 */\n+/* Verify that breakpoint on both goto failure; stmts is hit.\n+   This version of the test just checks that it can be compiled, linked\n+   and executed, further testing is done in corresponding gcc.dg/dwarf2/\n+   test and hopefully in gdb testsuite.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O0 -g -dA\" } */\n+\n+extern void abort (void);\n+int x;\n+\n+int\n+foo (void)\n+{\n+  return 0 ^ x;\n+}\n+\n+int\n+bar (void)\n+{\n+  return 1 ^ x;\n+}\n+\n+int\n+baz (void)\n+{\n+  int c;\n+\n+  if (!foo ())\n+    goto failure;\n+\n+  if (!bar ())\n+    goto failure;\n+\n+  return 0;\n+\n+failure:\n+  return 1;\n+}\n+\n+int\n+main (void)\n+{\n+  if (baz () != 1)\n+    abort ();\n+  x = 1;\n+  if (baz () != 1)\n+    abort ();\n+  x = 2;\n+  if (baz () != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "e3c913b6bb0d38f90fd3e8ec5c70bcff31b4e2e4", "filename": "gcc/testsuite/gcc.dg/debug/pr36690-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr36690-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr36690-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr36690-1.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,23 @@\n+/* PR debug/36690 */\n+/* Verify that break func is hit.  \n+   This version of the test just checks that it can be compiled, linked\n+   and executed, further testing is done in corresponding gcc.dg/dwarf2/\n+   test and hopefully in gdb testsuite.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O0 -g -dA\" } */\n+\n+int i;\n+\n+void\n+func (void)\n+{\n+  while (i == 1)\n+    i = 0;\n+}\n+\n+int\n+main (void)\n+{\n+  func ();\n+  return 0;\n+}"}, {"sha": "ddda18cf73c4b6b9e045067244134cd9a132297d", "filename": "gcc/testsuite/gcc.dg/debug/pr36690-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr36690-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr36690-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr36690-2.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,40 @@\n+/* PR debug/36690 */\n+/* Verify that breakpoint can be put on goto f1, it is hit and\n+   varz at that spot is defined and contains 5.  Nowhere else\n+   in the function should be varz in the scope.\n+   This version of the test just checks that it can be compiled, linked\n+   and executed, further testing is done in corresponding gcc.dg/dwarf2/\n+   test and hopefully in gdb testsuite.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O0 -g -dA\" } */\n+\n+int cnt;\n+\n+void\n+bar (int i)\n+{\n+  cnt += i;\n+}\n+\n+void\n+foo (int i)\n+{\n+  if (!i)\n+    bar (0);\n+  else\n+    {\n+      static int varz = 5;\n+      goto f1;\n+    }\n+  bar (1);\n+f1:\n+  bar (2);\n+}\n+\n+int\n+main (void)\n+{\n+  foo (0);\n+  foo (1);\n+  return 0;\n+}"}, {"sha": "62d3494dacd4e161f09b518c979c2631363ebb3f", "filename": "gcc/testsuite/gcc.dg/debug/pr36690-3.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr36690-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr36690-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr36690-3.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,47 @@\n+/* PR debug/36690 */\n+/* { dg-do run } */\n+/* { dg-options \"-O0 -g -dA\" } */\n+\n+int cnt;\n+\n+void\n+bar (int i)\n+{\n+  cnt += i;\n+}\n+\n+void\n+foo (int i, int j)\n+{\n+  if (j)\n+    {\n+      bar (i + 1);\n+      goto f1;\n+    }\n+  bar (i + 2);\n+  goto f2;\n+f1:\n+  if (i > 10)\n+    goto f3;\n+f2:\n+  if (i > 40)\n+    goto f4;\n+  else\n+    goto f5;\n+f3:\n+  bar (i);\n+f4:\n+  bar (i);\n+f5:\n+  bar (i);\n+}\n+\n+int\n+main (void)\n+{\n+  foo (0, 1);\n+  foo (11, 1);\n+  foo (21, 0);\n+  foo (41, 0);\n+  return 0;\n+}"}, {"sha": "3bbaebbdf78a06ffcbd5b083a306ad9d2de940f9", "filename": "gcc/testsuite/gcc.dg/debug/pr37616.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr37616.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr37616.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr37616.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -0,0 +1,40 @@\n+/* PR debug/37616 */\n+/* Test that one can put breakpoints onto continue, exitlab and break\n+   and actually see program reaching those breakpoints.\n+   This version of the test just checks that it can be compiled, linked\n+   and executed, further testing is done in corresponding gcc.dg/dwarf2/\n+   test and hopefully in gdb testsuite.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O0 -g -dA\" } */\n+\n+extern void abort (void);\n+\n+int\n+foo (int parm)\n+{\n+  int varj, varm;\n+\n+  for (varj = 0; varj < 10; varj++)\n+    {\n+      if (varj == 5)\n+\tcontinue;\n+      if (varj == 7 && !parm)\n+\tgoto exitlab;\n+      if (varj == 9)\n+\tbreak;\n+      varm = varj;\n+    }\n+\n+exitlab:\n+  return varm;\n+}\n+\n+int\n+main (void)\n+{\n+  if (foo (0) != 6)\n+    abort ();\n+  if (foo (1) != 8)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "505ee70005704ff3efac85450d5b4f80d813cf6e", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7241571ec8f99caff65f266d3ce395cb0eadb59c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=7241571ec8f99caff65f266d3ce395cb0eadb59c", "patch": "@@ -658,9 +658,13 @@ make_cond_expr_edges (basic_block bb)\n \n   e = make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n   e->goto_locus = gimple_location (then_stmt);\n+  e->goto_block = gimple_block (then_stmt);\n   e = make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n   if (e)\n-    e->goto_locus = gimple_location (else_stmt);\n+    {\n+      e->goto_locus = gimple_location (else_stmt);\n+      e->goto_block = gimple_block (else_stmt);\n+    }\n \n   /* We do not need the labels anymore.  */\n   gimple_cond_set_true_label (entry, NULL_TREE);\n@@ -849,6 +853,7 @@ make_goto_expr_edges (basic_block bb)\n       tree dest = gimple_goto_dest (goto_t);\n       edge e = make_edge (bb, label_to_block (dest), EDGE_FALLTHRU);\n       e->goto_locus = gimple_location (goto_t);\n+      e->goto_block = gimple_block (goto_t);\n       gsi_remove (&last, true);\n       return;\n     }\n@@ -5743,6 +5748,23 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n       update_stmt (stmt);\n       pop_cfun ();\n     }\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->goto_locus)\n+      {\n+\ttree block = e->goto_block;\n+\tif (d->orig_block == NULL_TREE\n+\t    || block == d->orig_block)\n+\t  e->goto_block = d->new_block;\n+#ifdef ENABLE_CHECKING\n+\telse if (block != d->new_block)\n+\t  {\n+\t    while (block && block != d->orig_block)\n+\t      block = BLOCK_SUPERCONTEXT (block);\n+\t    gcc_assert (block);\n+\t  }\n+#endif\n+      }\n }\n \n /* Examine the statements in BB (which is in SRC_CFUN); find and return"}]}