{"sha": "0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY4OWRmNjdmYzVkYmFkMGU2ZWIwNjhmNmZhY2M0Y2JiMDM0MmMwZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-04-22T23:02:08Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-22T23:02:08Z"}, "message": "cpphash.c (trad_stringify, add_pat): New functions.\n\n\t* cpphash.c (trad_stringify, add_pat): New functions.\n\t(collect_expansion): Restore support for -traditional syntax.\n\tUse trad_stringify and add_pat.\n\t(_cpp_macroexpand): Restore support for -traditional semantics.\n\t* cpplex.c (_cpp_scan_line): Don't change space_before if we\n\tget a COMMENT token.\n\t(_cpp_lex_token): Provide COMMENT tokens to caller if\n\ttraditional and parsing_define_directive.\n\t(skip_comment): Warn about // comments if -Wtraditional.\n\t* cpplib.c (do_define): Fix typo.  Create EMPTY nodes with\n\tproper node type.\n\t(do_undef): Don't warn about undefining EMPTY nodes.\n\nFrom-SVN: r33350", "tree": {"sha": "ce631ea761f6a054491332ece44f6ba0154f01b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce631ea761f6a054491332ece44f6ba0154f01b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d/comments", "author": null, "committer": null, "parents": [{"sha": "4ff812cd3f08389d68aa257bbfa9baaf9dbda2cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ff812cd3f08389d68aa257bbfa9baaf9dbda2cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ff812cd3f08389d68aa257bbfa9baaf9dbda2cc"}], "stats": {"total": 233, "additions": 186, "deletions": 47}, "files": [{"sha": "28db7bafdb5e6cdb3889a18cc499e1bf042caa06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d", "patch": "@@ -1,3 +1,18 @@\n+2000-04-22  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpphash.c (trad_stringify, add_pat): New functions.\n+\t(collect_expansion): Restore support for -traditional syntax.\n+\tUse trad_stringify and add_pat.\n+\t(_cpp_macroexpand): Restore support for -traditional semantics.\n+\t* cpplex.c (_cpp_scan_line): Don't change space_before if we\n+\tget a COMMENT token.\n+\t(_cpp_lex_token): Provide COMMENT tokens to caller if\n+\ttraditional and parsing_define_directive.\n+\t(skip_comment): Warn about // comments if -Wtraditional.\n+\t* cpplib.c (do_define): Fix typo.  Create EMPTY nodes with\n+\tproper node type.\n+\t(do_undef): Don't warn about undefining EMPTY nodes.\n+\n Sat Apr 22 22:35:38 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* loop.c (strength_reduce): Fix biv removal code."}, {"sha": "26d03fec05514df1c818a6846d0a09116c7d5e26", "filename": "gcc/cpphash.c", "status": "modified", "additions": 147, "deletions": 37, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d", "patch": "@@ -79,7 +79,13 @@ static unsigned int collect_params PARAMS ((cpp_reader *, cpp_toklist *,\n \n static void warn_trad_stringify\tPARAMS ((cpp_reader *, U_CHAR *, size_t,\n \t\t\t\t\t unsigned int, const struct arg *));\n+static unsigned int trad_stringify PARAMS ((cpp_reader *, U_CHAR *, size_t,\n+\t\t\t\t\t    unsigned int, const struct arg *,\n+\t\t\t\t\t    struct reflist **,\n+\t\t\t\t\t    struct reflist **, unsigned int));\n static int duplicate_arg_p PARAMS ((U_CHAR *, U_CHAR *));\n+static void add_pat PARAMS ((struct reflist **, struct reflist **,\n+\t\t\t     unsigned int, unsigned int, int, int, int, int));\n \n /* This structure represents one parsed argument in a macro call.\n    `raw' points to the argument text as written (`raw_length' is its length).\n@@ -279,6 +285,32 @@ macro_cleanup (pbuf, pfile)\n   return 0;\n }\n \n+/* Create pat nodes.  */\n+\n+static void\n+add_pat (pat, endpat, nchars, argno, raw_before, raw_after, strize, rest)\n+     struct reflist **pat, **endpat;\n+     unsigned int nchars;\n+     unsigned int argno;\n+     int raw_before, raw_after, strize, rest;\n+{\n+  struct reflist *tpat;\n+  tpat = (struct reflist *) xmalloc (sizeof (struct reflist));\n+  tpat->next = NULL;\n+  tpat->raw_before = raw_before;\n+  tpat->raw_after = raw_after;\n+  tpat->stringify = strize;\n+  tpat->rest_args = rest;\n+  tpat->argno = argno;\n+  tpat->nchars = nchars;\n+\n+  if (*endpat == NULL)\n+    *pat = tpat;\n+  else\n+    (*endpat)->next = tpat;\n+  *endpat = tpat;\n+}  \n+\n /* Issue warnings for macro argument names seen inside strings.  */\n static void\n warn_trad_stringify (pfile, p, len, argc, argv)\n@@ -287,7 +319,6 @@ warn_trad_stringify (pfile, p, len, argc, argv)\n      size_t len;\n      unsigned int argc;\n      const struct arg *argv;\n-     \n {\n   U_CHAR *limit;\n   unsigned int i;\n@@ -315,6 +346,59 @@ warn_trad_stringify (pfile, p, len, argc, argv)\n     }\n }\n \n+/* Generate pat nodes for macro arguments seen inside strings.  */\n+static unsigned int\n+trad_stringify (pfile, base, len, argc, argv, pat, endpat, last)\n+     cpp_reader *pfile;\n+     U_CHAR *base;\n+     size_t len;\n+     unsigned int argc;\n+     const struct arg *argv;\n+     struct reflist **pat, **endpat;\n+     unsigned int last;\n+{\n+  U_CHAR *p, *limit;\n+  unsigned int i;\n+\n+  p = base;\n+  limit = base + len;\n+  for (;;)\n+    {\n+    proceed:\n+      while (p < limit && !is_idstart (*p)) p++;\n+      if (p >= limit)\n+\tbreak;\n+\n+      for (i = 0; i < argc; i++)\n+\tif (!strncmp (p, argv[i].name, argv[i].len)\n+\t    && ! is_idchar (p[argv[i].len]))\n+\t  {\n+\t    if (CPP_WTRADITIONAL (pfile))\n+\t      cpp_warning (pfile, \"macro argument \\\"%s\\\" is stringified\",\n+\t\t\t   argv[i].name);\n+\t    /* Write out the string up to this point, and add a pat\n+\t       node for the argument.  Note that the argument is NOT\n+\t       stringified.  */\n+\t    CPP_PUTS (pfile, base, p - base);\n+\t    add_pat (pat, endpat, CPP_WRITTEN (pfile) - last, i /* argno */,\n+\t\t     !is_hspace (p[-1]) /* raw_before */,\n+\t\t     !is_hspace (p[argv[i].len]) /* raw_after */,\n+\t\t     0 /* strize */,\n+\t\t     argv[i].rest_arg);\n+\t    last = CPP_WRITTEN (pfile);\n+\t    base = p + argv[i].len;\n+\t    goto proceed;\n+\t  }\n+      p++;\n+      while (p < limit && is_idchar (*p)) p++;\n+      if (p >= limit)\n+\tbreak;\n+    }\n+  CPP_PUTS (pfile, base, p - base);\n+  return last;\n+}\n+\n+\n /* Read a replacement list for a macro, and build the DEFINITION\n    structure.  LIST contains the replacement list, beginning at\n    REPLACEMENT.  ARGLIST specifies the formal parameters to look for\n@@ -332,7 +416,7 @@ collect_expansion (pfile, list, arglist, replacement)\n   DEFINITION *defn;\n   struct reflist *pat = 0, *endpat = 0;\n   enum cpp_ttype token;\n-  long start, last;\n+  unsigned int start, last;\n   unsigned int i;\n   int j, argc;\n   size_t len;\n@@ -374,19 +458,21 @@ collect_expansion (pfile, list, arglist, replacement)\n \t  /* # is not special in object-like macros.  It is special in\n \t     function-like macros with no args.  (6.10.3.2 para 1.)\n \t     However, it is not special after PASTE. (Implied by\n-\t     6.10.3.3 para 4.)  */\n-\t  if (arglist == NULL || last_token == PASTE)\n-\t    goto norm;\n+\t     6.10.3.3 para 4.)  Nor is it special if -traditional.  */\n+\t  if (arglist == NULL || last_token == PASTE\n+\t      || CPP_TRADITIONAL (pfile))\n+\t    break;\n \t  last_token = STRIZE;\n-\t  break;\n+\t  continue;\n \n \tcase CPP_PASTE:\n-\t  if (last_token == PASTE)\n-\t    /* ## ## - the second ## is ordinary.  */\n-\t    goto norm;\n-\t  else if (last_token == START)\n+\t  /* ## is not special if it appears right after another ##;\n+\t     nor is it special if -traditional.  */\n+\t  if (last_token == PASTE || CPP_TRADITIONAL (pfile))\n+\t    break;\n+\n+\t  if (last_token == START)\n \t    cpp_error (pfile, \"`##' at start of macro definition\");\n-\t    \n \t  else if (last_token == ARG)\n \t    /* If the last token was an argument, mark it raw_after.  */\n \t    endpat->raw_after = 1;\n@@ -395,12 +481,33 @@ collect_expansion (pfile, list, arglist, replacement)\n \t    CPP_PUTC (pfile, '#');\n \n \t  last_token = PASTE;\n-\t  break;\n+\t  continue;\n \n+\tdefault:;\n+\t}\n+\n+      if (last_token != PASTE && last_token != START\n+\t  && (list->tokens[i].flags & HSPACE_BEFORE))\n+\tCPP_PUTC (pfile, ' ');\n+      if (last_token == ARG && CPP_TRADITIONAL (pfile)\n+\t  && !(list->tokens[i].flags & HSPACE_BEFORE))\n+\tendpat->raw_after = 1;\n+\n+      switch (token)\n+\t{\n \tcase CPP_STRING:\n \tcase CPP_CHAR:\n-\t  if (argc && CPP_WTRADITIONAL (pfile))\n-\t    warn_trad_stringify (pfile, tok, len, argc, argv);\n+\t  if (argc)\n+\t    {\n+\t      if (CPP_TRADITIONAL (pfile))\n+\t\t{\n+\t\t  last = trad_stringify (pfile, tok, len, argc, argv,\n+\t\t\t\t\t &pat, &endpat, last);\n+\t\t  break;\n+\t\t}\n+\t      if (CPP_WTRADITIONAL (pfile))\n+\t\twarn_trad_stringify (pfile, tok, len, argc, argv);\n+\t    }\n \t  goto norm;\n \t  \n \tcase CPP_NAME:\n@@ -419,31 +526,20 @@ collect_expansion (pfile, list, arglist, replacement)\n \t    CPP_PUTC (pfile, ' ');\n \t  CPP_PUTS (pfile, tok, len);\n \t  last_token = NORM;\n-\t  break;\n \t}\n       continue;\n \n     addref:\n       {\n-\tstruct reflist *tpat;\n-\tif (last_token != PASTE && (list->tokens[i].flags & HSPACE_BEFORE))\n-\t  CPP_PUTC (pfile, ' ');\n-\n-\t/* Make a pat node for this arg and add it to the pat list */\n-\ttpat = (struct reflist *) xmalloc (sizeof (struct reflist));\n-\ttpat->next = NULL;\n-\ttpat->raw_before = (last_token == PASTE);\n-\ttpat->raw_after = 0;\n-\ttpat->stringify = (last_token == STRIZE);\n-\ttpat->rest_args = argv[j].rest_arg;\n-\ttpat->argno = j;\n-\ttpat->nchars = CPP_WRITTEN (pfile) - last;\n-\n-\tif (endpat == NULL)\n-\t  pat = tpat;\n-\telse\n-\t  endpat->next = tpat;\n-\tendpat = tpat;\n+\tint raw_before = (last_token == PASTE\n+\t\t\t  || (CPP_TRADITIONAL (pfile)\n+\t\t\t      && !(list->tokens[i].flags & HSPACE_BEFORE)));\n+      \n+\tadd_pat (&pat, &endpat,\n+\t\t CPP_WRITTEN (pfile) - last /* nchars */, j /* argno */,\n+\t\t raw_before, 0 /* raw_after */,\n+\t\t (last_token == STRIZE), argv[j].rest_arg);\n+      \n \tlast = CPP_WRITTEN (pfile);\n       }\n       last_token = ARG;\n@@ -1028,8 +1124,11 @@ _cpp_macroexpand (pfile, hp)\n \t}\n       else if (i < nargs)\n \t{\n+\t  /* traditional C allows foo() if foo wants one argument.  */\n+\t  if (nargs == 1 && i == 0 && CPP_TRADITIONAL (pfile))\n+\t    ;\n \t  /* the rest args token is allowed to absorb 0 tokens */\n-\t  if (i == nargs - 1 && defn->rest_args)\n+\t  else if (i == nargs - 1 && defn->rest_args)\n \t    rest_zero = 1;\n \t  else if (i == 0)\n \t    cpp_error (pfile, \"macro `%s' used without args\", hp->name);\n@@ -1317,8 +1416,19 @@ _cpp_macroexpand (pfile, hp)\n   /* Pop the space we've used in the token_buffer for argument expansion.  */\n   CPP_SET_WRITTEN (pfile, old_written);\n \n-  /* Per C89, a macro cannot be expanded recursively.  */\n-  hp->type = T_DISABLED;\n+  /* In C89, a macro cannot be expanded recursively.  Traditional C\n+     permits it, but any use in an object-like macro must lead to\n+     infinite recursion, so always follow C89 in object-like macros.\n+\n+     The only example known where this doesn't cause infinite recursion\n+     in function-like macros is:\n+\t#define foo(x,y) bar(x(y, 0))\n+\tfoo(foo, baz)\n+     which expands to bar(foo(baz, 0)) in C89 and\n+     bar(bar(baz(0, 0)) in K+R.  This looks pathological to me.\n+     If someone has a real-world example I would love to see it.  */\n+  if (nargs <= 0 || !CPP_TRADITIONAL (pfile))\n+    hp->type = T_DISABLED;\n }\n \n /* Return 1 iff a token ending in C1 followed directly by a token C2"}, {"sha": "3e6a89feac590e23c8bc0ec5cf0f37720f88eebe", "filename": "gcc/cpplex.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d", "patch": "@@ -513,6 +513,11 @@ _cpp_scan_line (pfile, list)\n \t  space_before = 1;\n \t  continue;\n \t}\n+      else if (type == CPP_COMMENT)\n+\t/* Only happens when processing -traditional macro definitions.\n+\t   Do not give this a token entry, but do not change space_before\n+\t   either.  */\n+\tcontinue;\n \n       if (list->tokens_used >= list->tokens_cap)\n \texpand_token_space (list);\n@@ -644,13 +649,17 @@ skip_comment (pfile, m)\n \t}\n       else if (CPP_OPTION (pfile, cplusplus_comments))\n \t{\n-\t  if (CPP_OPTION (pfile, c89)\n-\t      && CPP_PEDANTIC (pfile)\n-\t      && ! CPP_BUFFER (pfile)->warned_cplusplus_comments)\n+\t  if (! CPP_BUFFER (pfile)->warned_cplusplus_comments)\n \t    {\n-\t      cpp_pedwarn (pfile,\n-\t\t\t   \"C++ style comments are not allowed in ISO C89\");\n-\t      cpp_pedwarn (pfile,\n+\t      if (CPP_WTRADITIONAL (pfile))\n+\t\tcpp_pedwarn (pfile,\n+\t\t\t\"C++ style comments are not allowed in traditional C\");\n+\t      else if (CPP_OPTION (pfile, c89) && CPP_PEDANTIC (pfile))\n+\t\tcpp_pedwarn (pfile,\n+\t\t\t\"C++ style comments are not allowed in ISO C89\");\n+\t      if (CPP_WTRADITIONAL (pfile)\n+\t\t  || (CPP_OPTION (pfile, c89) && CPP_PEDANTIC (pfile)))\n+\t\tcpp_pedwarn (pfile,\n \t\t\t   \"(this will be reported only once per input file)\");\n \t      CPP_BUFFER (pfile)->warned_cplusplus_comments = 1;\n \t    }\n@@ -1053,7 +1062,11 @@ _cpp_lex_token (pfile)\n       if (!CPP_OPTION (pfile, discard_comments))\n \treturn CPP_COMMENT;\n       else if (CPP_TRADITIONAL (pfile))\n-\tgoto get_next;\n+\t{\n+\t  if (pfile->parsing_define_directive)\n+\t    return CPP_COMMENT;\n+\t  goto get_next;\n+\t}\n       else\n \t{\n \t  CPP_PUTC (pfile, c);"}, {"sha": "7f2554bfc06ec3a8f71ec971f16d98de9674dc36", "filename": "gcc/cpplib.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=0f89df67fc5dbad0e6eb068f6facc4cbb0342c0d", "patch": "@@ -352,7 +352,7 @@ do_define (pfile)\n \n \n   if (list->tokens_used == 2 && list->tokens[1].type == CPP_VSPACE)\n-    empty = 0;  /* Empty definition of object-like macro.  */\n+    empty = 1;  /* Empty definition of object-like macro.  */\n \n   /* If the next character, with no intervening whitespace, is '(',\n      then this is a function-like macro.  Otherwise it is an object-\n@@ -425,7 +425,8 @@ do_define (pfile)\n     }\n   else\n     {\n-      HASHNODE *hp = _cpp_make_hashnode (sym, len, T_MACRO, hash);\n+      HASHNODE *hp = _cpp_make_hashnode (sym, len, empty ? T_EMPTY : T_MACRO,\n+\t\t\t\t\t hash);\n       hp->value.defn = def;\n       *slot = hp;\n     }\n@@ -768,7 +769,7 @@ do_undef (pfile)\n \t  if (CPP_OPTION (pfile, debug_output))\n \t    pass_thru_directive (hp->name, len, pfile, T_UNDEF);\n \n-\t  if (hp->type != T_MACRO)\n+\t  if (hp->type != T_MACRO && hp->type != T_EMPTY)\n \t    cpp_warning (pfile, \"undefining `%s'\", hp->name);\n \n \t  htab_clear_slot (pfile->hashtab, (void **)slot);"}]}