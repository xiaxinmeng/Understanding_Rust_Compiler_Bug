{"sha": "09e881c9e21a9209b2092e400ea4c38948614f78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDllODgxYzllMjFhOTIwOWIyMDkyZTQwMGVhNGMzODk0ODYxNGY3OA==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2009-10-26T21:55:59Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2009-10-26T21:55:59Z"}, "message": "extend.texi (Named Address Spaces): New section.\n\n2009-10-26  Ben Elliston  <bje@au.ibm.com>\n\t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Ulrich Weigand  <uweigand@de.ibm.com>\n\n\t* doc/extend.texi (Named Address Spaces): New section.\n\t* coretypes.h (addr_space_t): New type.\n\t(ADDR_SPACE_GENERIC): New define.\n\t(ADDR_SPACE_GENERIC_P): New macro.\n\n\t* doc/tm.texi (Named Address Spaces): New section.\n\t(TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Document.\n\t(TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS): Document.\n\t(TARGET_ADDR_SPACE_SUBSET_P): Document.\n\t(TARGET_ADDR_SPACE_CONVERT): Document.\n\t* target.h (struct gcc_target): Add addr_space substructure.\n\t* target-def.h (TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Define.\n\t(TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS): Likewise.\n\t(TARGET_ADDR_SPACE_SUBSET_P): Likewise.\n\t(TARGET_ADDR_SPACE_CONVERT): Likewise.\n\t(TARGET_ADDR_SPACE_HOOKS): Likewise.\n\t(TARGET_INITIALIZER): Initialize addr_space hooks.\n\t* targhooks.c (default_addr_space_legitimate_address_p): New function.\n\t(default_addr_space_legitimize_address): Likewise.\n\t(default_addr_space_subset_p): Likewise.\n\t(default_addr_space_convert): Likewise.\n\t* targhooks.h (default_addr_space_legitimate_address_p): Add prototype.\n\t(default_addr_space_legitimize_address): Likewise.\n\t(default_addr_space_subset_p): Likewise.\n\t(default_addr_space_convert): Likewise.\n\n\t* doc/rtl.texi (MEM_ADDR_SPACE): Document.\n\t* rtl.h (mem_attrs): Add ADDRSPACE memory attribute.\n\t(MEM_ADDR_SPACE): New macro.\n\t* emit-rtl.c (get_mem_attrs): Add ADDRSPACE argument and set\n\taddress space memory attribute.\n\t(mem_attrs_htab_hash): Handle address space memory attribute.\n\t(mem_attrs_htab_eq): Likewise.\n\t(set_mem_attributes_minus_bitpos): Likewise.\n\t(set_mem_alias_set): Likewise.\n\t(set_mem_align): Likewise.\n\t(set_mem_expr): Likewise.\n\t(set_mem_offset): Likewise.\n\t(set_mem_size): Likewise.\n\t(adjust_address_1): Likewise.\n\t(offset_address): Likewise.\n\t(widen_memoy_address): Likewise.\n\t(get_spill_slot_decl): Likewise.\n\t(set_mem_attrs_for_spill): Likewise.\n\t(set_mem_addr_space): New function.\n\t* emit-rtl.h (set_mem_addr_space): Add prototype.\n\t* print-rtl.c (print_rtx): Print address space memory attribute.\n\t* expr.c (expand_assignment): Set address space memory attribute\n\tof generated MEM RTXes as appropriate.\n\t(expand_expr_real_1): Likewise.\n\t* cfgexpand.c (expand_debug_expr): Likewise.\n\t* tree-ssa-loop-ivopts.c (produce_memory_decl_rtl): Likewise.\n\n\t* tree.h (struct tree_base): Add address_space bitfield.  Reduce\n\tsize of \"spare\" bitfield.\n\t(TYPE_ADDR_SPACE): New macro.\n\t(ENCODE_QUAL_ADDR_SPACE): Likewise.\n\t(DECODE_QUAL_ADDR_SPACE): Likewise.\n\t(CLEAR_QUAL_ADDR_SPACE): Likewise.\n\t(KEEP_QUAL_ADDR_SPACE): Likewise.\n\t(TYPE_QUALS): Encode type address space.\n\t(TYPE_QUALS_NO_ADDR_SPACE): New macro.\n\t* tree.c (set_type_quals): Set type address space.\n\t(build_array_type): Inherit array address space from element type.\n\t* print-tree.c (print_node_brief): Print type address space.\n\t(print_node): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\n\t* explow.c (memory_address): Rename to ...\n\t(memory_address_addr_space): ... this.  Add ADDRSPACE argument.\n\tUse address-space aware variants of memory address routines.\n\t* recog.c (memory_address_p): Rename to ...\n\t(memory_address_addr_space_p): ... this.  Add ADDSPACE argument.\n\tUse address-space aware variants of memory address routines.\n\t(offsettable_address_p): Rename to ...\n\t(offsettable_address_addr_space_p): ... this.  Add ADDRSPACE argument.\n\tUse address-space aware variants of memory address routines.\n\t* reload.c (strict_memory_address_p): Rename to ...\n\t(strict_memory_address_addr_space_p): ... this.  Add ADDSPACE argument.\n\tUse address-space aware variants of memory address routines.\n\t(maybe_memory_address_p): Rename to ...\n\t(maybe_memory_address_addr_space_p): ... this.  Add ADDSPACE argument.\n\tUse address-space aware variants of memory address routines.\n\t* expr.h (memory_address_addr_space): Add prototype.\n\t(memory_address): Define as macro.\n\t* recog.h (memory_address_addr_space_p): Add prototype.\n\t(memory_address_p): Define as macro.\n\t(offsettable_address_addr_space_p): Add prototype.\n\t(offsettable_address_p): Define as macro.\n\t(strict_memory_address_addr_space_p): Add prototype.\n\t(strict_memory_address_p): Define as macro.\n\n\t* combine.c (find_split_point): Use address-space aware variants\n\tof memory address routines.\n\t* emit-rtl.c (operand_subword): Likewise.\n\t(change_address_1): Likewise.\n\t(adjust_address_1): Likewise.\n\t(offset_address): Likewise.\n\t* expr.c (emit_move_insn): Likewise.\n\t(expand_assignment): Likewise.\n\t(expand_expr_real_1): Likewise.\n\t* recog.c (verify_changes): Likewise.\n\t(general_operand): Likewise.\n\t(offsettable_memref_p): Likewise.\n\t(offsettable_nonstrict_memref_p): Likewise.\n\t(constrain_operands): Likewise.\n\t* reload.c (get_secondary_mem): Likewise.\n\t(find_reloads_toplev): Likewise.\n\t(find_reloads_address): Likewise.\n\t(find_reloads_subreg_address): Likewise.\n\t* reload1.c (reload): Likewise.\n\t* rtlhooks.c (gen_lowpart_if_possible): Likewise.\n\t* rtl.h (address_cost): Add ADDRSPACE argument.\n\t* rtlanal.c (address_cost): Add ADDRSPACE argument.  Use address-space\n\taware variant of memory address routines.\n\t* loop-invariant.c (create_new_invariant): Update address_cost call.\n\t* tree-ssa-loop-ivopts.c (computation_cost): Likewise.\n\t* fwprop.c (should_replace_address): Add ADDRSPACE argument.\n\tUse address-space aware variant of memory address routines.\n\t(propagate_rtx_1): Update call to should_replace_address.\n\t* tree-flow.h (multiplier_allowed_in_address_p): Add ADDRSPACE\n\targument.\n\t* tree-ssa-loop-ivopts.c (multiplier_allowed_in_address_p): Add\n\tADDRSPACE argument.  Use per-address-space instead of global cache.\n\tUse address-space aware variant of memory address routines.\n\t(get_address_cost): Likewise.\n\t(get_computation_cost_at): Update calls.\n\t* tree-ssa-address.c (valid_mem_ref_p): Add ADDRSPACE argument.\n\tUse address-space aware variant of memory address routines.\n\t(create_mem_ref_raw): Update call to valid_mem_ref_p.\n\t(most_expensive_mult_to_index): Update call to\n\tmultiplier_allowed_in_address_p.\n\n\t* dwarf2out.c (modified_type_die): Output DW_AT_address_class\n\tattribute to indicate named address spaces.\n\n\t* varasm.c (get_variable_section): DECLs in named address spaces\n\tcannot be \"common\".\n\n\t* reload.c (find_reloads_address): Do not use LEGITIMIZE_RELOAD_ADDRESS\n\tfor addresses in a non-generic address space.\n\n\t* expr.c (emit_block_move_hints): Do not use libcalls for\n\tmemory in non-generic address spaces.\n\t(clear_storage_hints): Likewise.\n\t(expand_assignment): Likewise.\n\n\t* fold-const.c (operand_equal_p): Expressions refering to different\n\taddress spaces are not equivalent.\n\n\t* rtl.c (rtx_equal_p_cb): MEMs refering to different address\n\tspaces are not equivalent.\n\t(rtx_equal_p): Likewise.\n\t* cse.c (exp_equiv_p): Likewise.\n\t* jump.c (rtx_renumbered_equal_p): Likewise.\n\t* reload.c (operands_match_p): Likewise.\n\n\t* alias.c (nonoverlapping_memrefs_p): MEMs refering to different\n\taddress spaces may alias.\n\t(true_dependence): Likewise.\n\t(canon_true_dependence): Likewise.\n\t(write_dependence_p): Likewise.\n\n\t* dse.c (canon_address): Handle named address spaces.\n\t* ifcvt.c (noce_try_cmove_arith): Likewise.\n\n\t* tree.def (ADDR_SPACE_CONVERT_EXPR): New tree code.\n\t* expr.c (expand_expr_real_2): Expand ADDR_SPACE_CONVERT_EXPR.\n\t* convert.c (convert_to_pointer): Generate ADDR_SPACE_CONVERT_EXPR\n\tto handle conversions between different address spaces.\n\t* fold-const.c (fold_convert_loc): Likewise.\n\t(fold_unary_loc): Handle ADDR_SPACE_CONVERT_EXPR.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* gimple-pretty-print.c (dump_unary_rhs): Likewise.\n\t* tree-cfg.c (verify_gimple_assign_unary): Likewise.\n\t* tree-inline.c (estimate_operator_cost): Likewise.\n\t* tree-ssa.c (useless_type_conversion_p): Conversions between pointers\n\tto different address spaces are not useless.\n\nCo-Authored-By: Michael Meissner <meissner@linux.vnet.ibm.com>\nCo-Authored-By: Ulrich Weigand <uweigand@de.ibm.com>\n\nFrom-SVN: r153572", "tree": {"sha": "ea57b1c9bc1dc4b71890b4a10a89294179e3c5e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea57b1c9bc1dc4b71890b4a10a89294179e3c5e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09e881c9e21a9209b2092e400ea4c38948614f78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e881c9e21a9209b2092e400ea4c38948614f78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09e881c9e21a9209b2092e400ea4c38948614f78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e881c9e21a9209b2092e400ea4c38948614f78/comments", "author": null, "committer": null, "parents": [{"sha": "89c74f4afa6db154288515ed1e1cdbe8694dc4c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c74f4afa6db154288515ed1e1cdbe8694dc4c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89c74f4afa6db154288515ed1e1cdbe8694dc4c5"}], "stats": {"total": 1086, "additions": 914, "deletions": 172}, "files": [{"sha": "ebe6aec2ba44160cfceef9739e828b80c27dbbe9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -1,3 +1,186 @@\n+2009-10-26  Ben Elliston  <bje@au.ibm.com>\n+\t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* doc/extend.texi (Named Address Spaces): New section.\n+\t* coretypes.h (addr_space_t): New type.\n+\t(ADDR_SPACE_GENERIC): New define.\n+\t(ADDR_SPACE_GENERIC_P): New macro.\n+\n+\t* doc/tm.texi (Named Address Spaces): New section.\n+\t(TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Document.\n+\t(TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS): Document.\n+\t(TARGET_ADDR_SPACE_SUBSET_P): Document.\n+\t(TARGET_ADDR_SPACE_CONVERT): Document.\n+\t* target.h (struct gcc_target): Add addr_space substructure.\n+\t* target-def.h (TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Define.\n+\t(TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS): Likewise.\n+\t(TARGET_ADDR_SPACE_SUBSET_P): Likewise.\n+\t(TARGET_ADDR_SPACE_CONVERT): Likewise.\n+\t(TARGET_ADDR_SPACE_HOOKS): Likewise.\n+\t(TARGET_INITIALIZER): Initialize addr_space hooks.\n+\t* targhooks.c (default_addr_space_legitimate_address_p): New function.\n+\t(default_addr_space_legitimize_address): Likewise.\n+\t(default_addr_space_subset_p): Likewise.\n+\t(default_addr_space_convert): Likewise.\n+\t* targhooks.h (default_addr_space_legitimate_address_p): Add prototype.\n+\t(default_addr_space_legitimize_address): Likewise.\n+\t(default_addr_space_subset_p): Likewise.\n+\t(default_addr_space_convert): Likewise.\n+\n+\t* doc/rtl.texi (MEM_ADDR_SPACE): Document.\n+\t* rtl.h (mem_attrs): Add ADDRSPACE memory attribute.\n+\t(MEM_ADDR_SPACE): New macro.\n+\t* emit-rtl.c (get_mem_attrs): Add ADDRSPACE argument and set\n+\taddress space memory attribute.\n+\t(mem_attrs_htab_hash): Handle address space memory attribute.\n+\t(mem_attrs_htab_eq): Likewise.\n+\t(set_mem_attributes_minus_bitpos): Likewise.\n+\t(set_mem_alias_set): Likewise.\n+\t(set_mem_align): Likewise.\n+\t(set_mem_expr): Likewise.\n+\t(set_mem_offset): Likewise.\n+\t(set_mem_size): Likewise.\n+\t(adjust_address_1): Likewise.\n+\t(offset_address): Likewise.\n+\t(widen_memoy_address): Likewise.\n+\t(get_spill_slot_decl): Likewise.\n+\t(set_mem_attrs_for_spill): Likewise.\n+\t(set_mem_addr_space): New function.\n+\t* emit-rtl.h (set_mem_addr_space): Add prototype.\n+\t* print-rtl.c (print_rtx): Print address space memory attribute.\n+\t* expr.c (expand_assignment): Set address space memory attribute\n+\tof generated MEM RTXes as appropriate.\n+\t(expand_expr_real_1): Likewise.\n+\t* cfgexpand.c (expand_debug_expr): Likewise.\n+\t* tree-ssa-loop-ivopts.c (produce_memory_decl_rtl): Likewise.\n+\n+\t* tree.h (struct tree_base): Add address_space bitfield.  Reduce\n+\tsize of \"spare\" bitfield.\n+\t(TYPE_ADDR_SPACE): New macro.\n+\t(ENCODE_QUAL_ADDR_SPACE): Likewise.\n+\t(DECODE_QUAL_ADDR_SPACE): Likewise.\n+\t(CLEAR_QUAL_ADDR_SPACE): Likewise.\n+\t(KEEP_QUAL_ADDR_SPACE): Likewise.\n+\t(TYPE_QUALS): Encode type address space.\n+\t(TYPE_QUALS_NO_ADDR_SPACE): New macro.\n+\t* tree.c (set_type_quals): Set type address space.\n+\t(build_array_type): Inherit array address space from element type.\n+\t* print-tree.c (print_node_brief): Print type address space.\n+\t(print_node): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\n+\t* explow.c (memory_address): Rename to ...\n+\t(memory_address_addr_space): ... this.  Add ADDRSPACE argument.\n+\tUse address-space aware variants of memory address routines.\n+\t* recog.c (memory_address_p): Rename to ...\n+\t(memory_address_addr_space_p): ... this.  Add ADDSPACE argument.\n+\tUse address-space aware variants of memory address routines.\n+\t(offsettable_address_p): Rename to ...\n+\t(offsettable_address_addr_space_p): ... this.  Add ADDRSPACE argument.\n+\tUse address-space aware variants of memory address routines.\n+\t* reload.c (strict_memory_address_p): Rename to ...\n+\t(strict_memory_address_addr_space_p): ... this.  Add ADDSPACE argument.\n+\tUse address-space aware variants of memory address routines.\n+\t(maybe_memory_address_p): Rename to ...\n+\t(maybe_memory_address_addr_space_p): ... this.  Add ADDSPACE argument.\n+\tUse address-space aware variants of memory address routines.\n+\t* expr.h (memory_address_addr_space): Add prototype.\n+\t(memory_address): Define as macro.\n+\t* recog.h (memory_address_addr_space_p): Add prototype.\n+\t(memory_address_p): Define as macro.\n+\t(offsettable_address_addr_space_p): Add prototype.\n+\t(offsettable_address_p): Define as macro.\n+\t(strict_memory_address_addr_space_p): Add prototype.\n+\t(strict_memory_address_p): Define as macro.\n+\n+\t* combine.c (find_split_point): Use address-space aware variants\n+\tof memory address routines.\n+\t* emit-rtl.c (operand_subword): Likewise.\n+\t(change_address_1): Likewise.\n+\t(adjust_address_1): Likewise.\n+\t(offset_address): Likewise.\n+\t* expr.c (emit_move_insn): Likewise.\n+\t(expand_assignment): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t* recog.c (verify_changes): Likewise.\n+\t(general_operand): Likewise.\n+\t(offsettable_memref_p): Likewise.\n+\t(offsettable_nonstrict_memref_p): Likewise.\n+\t(constrain_operands): Likewise.\n+\t* reload.c (get_secondary_mem): Likewise.\n+\t(find_reloads_toplev): Likewise.\n+\t(find_reloads_address): Likewise.\n+\t(find_reloads_subreg_address): Likewise.\n+\t* reload1.c (reload): Likewise.\n+\t* rtlhooks.c (gen_lowpart_if_possible): Likewise.\n+\t* rtl.h (address_cost): Add ADDRSPACE argument.\n+\t* rtlanal.c (address_cost): Add ADDRSPACE argument.  Use address-space\n+\taware variant of memory address routines.\n+\t* loop-invariant.c (create_new_invariant): Update address_cost call.\n+\t* tree-ssa-loop-ivopts.c (computation_cost): Likewise.\n+\t* fwprop.c (should_replace_address): Add ADDRSPACE argument.\n+\tUse address-space aware variant of memory address routines.\n+\t(propagate_rtx_1): Update call to should_replace_address.\n+\t* tree-flow.h (multiplier_allowed_in_address_p): Add ADDRSPACE\n+\targument.\n+\t* tree-ssa-loop-ivopts.c (multiplier_allowed_in_address_p): Add\n+\tADDRSPACE argument.  Use per-address-space instead of global cache.\n+\tUse address-space aware variant of memory address routines.\n+\t(get_address_cost): Likewise.\n+\t(get_computation_cost_at): Update calls.\n+\t* tree-ssa-address.c (valid_mem_ref_p): Add ADDRSPACE argument.\n+\tUse address-space aware variant of memory address routines.\n+\t(create_mem_ref_raw): Update call to valid_mem_ref_p.\n+\t(most_expensive_mult_to_index): Update call to\n+\tmultiplier_allowed_in_address_p.\n+\n+\t* dwarf2out.c (modified_type_die): Output DW_AT_address_class\n+\tattribute to indicate named address spaces.\n+\n+\t* varasm.c (get_variable_section): DECLs in named address spaces\n+\tcannot be \"common\".\n+\n+\t* reload.c (find_reloads_address): Do not use LEGITIMIZE_RELOAD_ADDRESS\n+\tfor addresses in a non-generic address space.\n+\n+\t* expr.c (emit_block_move_hints): Do not use libcalls for\n+\tmemory in non-generic address spaces.\n+\t(clear_storage_hints): Likewise.\n+\t(expand_assignment): Likewise.\n+\n+\t* fold-const.c (operand_equal_p): Expressions refering to different\n+\taddress spaces are not equivalent.\n+\n+\t* rtl.c (rtx_equal_p_cb): MEMs refering to different address\n+\tspaces are not equivalent.\n+\t(rtx_equal_p): Likewise.\n+\t* cse.c (exp_equiv_p): Likewise.\n+\t* jump.c (rtx_renumbered_equal_p): Likewise.\n+\t* reload.c (operands_match_p): Likewise.\n+\n+\t* alias.c (nonoverlapping_memrefs_p): MEMs refering to different\n+\taddress spaces may alias.\n+\t(true_dependence): Likewise.\n+\t(canon_true_dependence): Likewise.\n+\t(write_dependence_p): Likewise.\n+\n+\t* dse.c (canon_address): Handle named address spaces.\n+\t* ifcvt.c (noce_try_cmove_arith): Likewise.\n+\n+\t* tree.def (ADDR_SPACE_CONVERT_EXPR): New tree code.\n+\t* expr.c (expand_expr_real_2): Expand ADDR_SPACE_CONVERT_EXPR.\n+\t* convert.c (convert_to_pointer): Generate ADDR_SPACE_CONVERT_EXPR\n+\tto handle conversions between different address spaces.\n+\t* fold-const.c (fold_convert_loc): Likewise.\n+\t(fold_unary_loc): Handle ADDR_SPACE_CONVERT_EXPR.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* gimple-pretty-print.c (dump_unary_rhs): Likewise.\n+\t* tree-cfg.c (verify_gimple_assign_unary): Likewise.\n+\t* tree-inline.c (estimate_operator_cost): Likewise.\n+\t* tree-ssa.c (useless_type_conversion_p): Conversions between pointers\n+\tto different address spaces are not useless.\n+\n 2009-10-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/41345"}, {"sha": "b6d0b7eccc59577f79fa2f0106aea7fd3e8ac9a5", "filename": "gcc/alias.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -2188,6 +2188,13 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y)\n       && ! rtx_equal_p (rtlx, rtly))\n     return 1;\n \n+  /* If we have MEMs refering to different address spaces (which can\n+     potentially overlap), we cannot easily tell from the addresses\n+     whether the references overlap.  */\n+  if (MEM_P (rtlx) && MEM_P (rtly)\n+      && MEM_ADDR_SPACE (rtlx) != MEM_ADDR_SPACE (rtly))\n+    return 0;\n+\n   /* Get the base and offsets of both decls.  If either is a register, we\n      know both are and are the same, so use that as the base.  The only\n      we can avoid overlap is if we can deduce that they are nonoverlapping\n@@ -2279,6 +2286,12 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n   if (nonoverlapping_memrefs_p (mem, x))\n     return 0;\n \n+  /* If we have MEMs refering to different address spaces (which can\n+     potentially overlap), we cannot easily tell from the addresses\n+     whether the references overlap.  */\n+  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n+    return 1;\n+\n   if (mem_mode == VOIDmode)\n     mem_mode = GET_MODE (mem);\n \n@@ -2356,6 +2369,12 @@ canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n   if (nonoverlapping_memrefs_p (x, mem))\n     return 0;\n \n+  /* If we have MEMs refering to different address spaces (which can\n+     potentially overlap), we cannot easily tell from the addresses\n+     whether the references overlap.  */\n+  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n+    return 1;\n+\n   if (! x_addr)\n     x_addr = get_addr (XEXP (x, 0));\n \n@@ -2416,6 +2435,12 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)\n   if (nonoverlapping_memrefs_p (x, mem))\n     return 0;\n \n+  /* If we have MEMs refering to different address spaces (which can\n+     potentially overlap), we cannot easily tell from the addresses\n+     whether the references overlap.  */\n+  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n+    return 1;\n+\n   x_addr = get_addr (XEXP (x, 0));\n   mem_addr = get_addr (XEXP (mem, 0));\n "}, {"sha": "21b900a540a2d873deba9f2f0df200cc6d754bc4", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -2235,6 +2235,7 @@ expand_debug_expr (tree exp)\n   rtx op0 = NULL_RTX, op1 = NULL_RTX, op2 = NULL_RTX;\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (exp));\n+  addr_space_t as;\n \n   switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n     {\n@@ -2428,6 +2429,11 @@ expand_debug_expr (tree exp)\n       if (!op0)\n \treturn NULL;\n \n+      if (POINTER_TYPE_P (TREE_TYPE (exp)))\n+\tas = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)));\n+      else\n+\tas = ADDR_SPACE_GENERIC;\n+\n       gcc_assert (GET_MODE (op0) == Pmode\n \t\t  || GET_MODE (op0) == ptr_mode\n \t\t  || GET_CODE (op0) == CONST_INT\n@@ -2442,6 +2448,7 @@ expand_debug_expr (tree exp)\n       op0 = gen_rtx_MEM (mode, op0);\n \n       set_mem_attributes (op0, exp, 0);\n+      set_mem_addr_space (op0, as);\n \n       return op0;\n \n@@ -2455,6 +2462,8 @@ expand_debug_expr (tree exp)\n       if (!op0)\n \treturn NULL;\n \n+      as = TYPE_ADDR_SPACE (TREE_TYPE (exp));\n+\n       gcc_assert (GET_MODE (op0) == Pmode\n \t\t  || GET_MODE (op0) == ptr_mode\n \t\t  || GET_CODE (op0) == CONST_INT\n@@ -2463,6 +2472,7 @@ expand_debug_expr (tree exp)\n       op0 = gen_rtx_MEM (mode, op0);\n \n       set_mem_attributes (op0, exp, 0);\n+      set_mem_addr_space (op0, as);\n \n       return op0;\n "}, {"sha": "89dc4154947292fc85f994804cc1db87fd7bf896", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -4174,7 +4174,8 @@ find_split_point (rtx *loc, rtx insn)\n \t it will not remain in the result.  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n \t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n-\t  && ! memory_address_p (GET_MODE (x), XEXP (x, 0)))\n+\t  && ! memory_address_addr_space_p (GET_MODE (x), XEXP (x, 0),\n+\t\t\t\t\t    MEM_ADDR_SPACE (x)))\n \t{\n \t  rtx reg = regno_reg_rtx[FIRST_PSEUDO_REGISTER];\n \t  rtx seq = combine_split_insns (gen_rtx_SET (VOIDmode, reg,\n@@ -4197,8 +4198,9 @@ find_split_point (rtx *loc, rtx insn)\n \t      && NONJUMP_INSN_P (NEXT_INSN (seq))\n \t      && GET_CODE (PATTERN (NEXT_INSN (seq))) == SET\n \t      && SET_DEST (PATTERN (NEXT_INSN (seq))) == reg\n-\t      && memory_address_p (GET_MODE (x),\n-\t\t\t\t   SET_SRC (PATTERN (NEXT_INSN (seq)))))\n+\t      && memory_address_addr_space_p\n+\t\t   (GET_MODE (x), SET_SRC (PATTERN (NEXT_INSN (seq))),\n+\t\t    MEM_ADDR_SPACE (x)))\n \t    {\n \t      rtx src1 = SET_SRC (PATTERN (seq));\n \t      rtx src2 = SET_SRC (PATTERN (NEXT_INSN (seq)));\n@@ -4237,7 +4239,8 @@ find_split_point (rtx *loc, rtx insn)\n       /* If we have a PLUS whose first operand is complex, try computing it\n          separately by making a split there.  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n-          && ! memory_address_p (GET_MODE (x), XEXP (x, 0))\n+          && ! memory_address_addr_space_p (GET_MODE (x), XEXP (x, 0),\n+\t\t\t\t\t    MEM_ADDR_SPACE (x))\n           && ! OBJECT_P (XEXP (XEXP (x, 0), 0))\n           && ! (GET_CODE (XEXP (XEXP (x, 0), 0)) == SUBREG\n                 && OBJECT_P (SUBREG_REG (XEXP (XEXP (x, 0), 0)))))"}, {"sha": "453f5ed873c96d1fa05af1cc513ee59eb6e1dd55", "filename": "gcc/convert.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -54,7 +54,17 @@ convert_to_pointer (tree type, tree expr)\n     {\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-      return fold_build1_loc (loc, NOP_EXPR, type, expr);\n+      {\n+        /* If the pointers point to different address spaces, conversion needs\n+\t   to be done via a ADDR_SPACE_CONVERT_EXPR instead of a NOP_EXPR.  */\n+\taddr_space_t to_as = TYPE_ADDR_SPACE (TREE_TYPE (type));\n+\taddr_space_t from_as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (expr)));\n+\n+\tif (to_as == from_as)\n+\t  return fold_build1_loc (loc, NOP_EXPR, type, expr);\n+\telse\n+\t  return fold_build1_loc (loc, ADDR_SPACE_CONVERT_EXPR, type, expr);\n+      }\n \n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:"}, {"sha": "0b8261fc6146cd94561247fd5c6f77fa34cc00f1", "filename": "gcc/coretypes.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -69,6 +69,13 @@ struct gimple_seq_node_d;\n typedef struct gimple_seq_node_d *gimple_seq_node;\n typedef const struct gimple_seq_node_d *const_gimple_seq_node;\n \n+/* Address space number for named address space support.  */\n+typedef unsigned char addr_space_t;\n+\n+/* The value of addr_space_t that represents the generic address space.  */\n+#define ADDR_SPACE_GENERIC 0\n+#define ADDR_SPACE_GENERIC_P(AS) ((AS) == ADDR_SPACE_GENERIC)\n+\n /* The major intermediate representations of GCC.  */\n enum ir_type {\n   IR_GIMPLE,"}, {"sha": "05f6ed6e0fe20608c024cae1d406372e2c978cfc", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -2623,6 +2623,10 @@ exp_equiv_p (const_rtx x, const_rtx y, int validate, bool for_gcse)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n+  /* MEMs refering to different address space are not equivalent.  */\n+  if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))\n+    return 0;\n+\n   switch (code)\n     {\n     case PC:"}, {"sha": "cb764c600eb6feecc5d30374e3641ee211f3a451", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -39,6 +39,7 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Decimal Float::       Decimal Floating Types. \n * Hex Floats::          Hexadecimal floating-point constants.\n * Fixed-Point::         Fixed-Point Types.\n+* Named Address Spaces::Named address spaces.\n * Zero Length::         Zero-length arrays.\n * Variable Length::     Arrays whose length is computed at run time.\n * Empty Structures::    Structures with no members.\n@@ -1197,6 +1198,31 @@ Pragmas to control overflow and rounding behaviors are not implemented.\n \n Fixed-point types are supported by the DWARF2 debug information format.\n \n+@node Named Address Spaces\n+@section Named address spaces\n+@cindex named address spaces\n+\n+As an extension, the GNU C compiler supports named address spaces as\n+defined in the N1275 draft of ISO/IEC DTR 18037.  Support for named\n+address spaces in GCC will evolve as the draft technical report changes.\n+Calling conventions for any target might also change.  At present, only\n+the SPU target supports other address spaces.  On the SPU target, for\n+example, variables may be declared as belonging to another address space\n+by qualifying the type with the @code{__ea} address space identifier:\n+\n+@smallexample\n+extern int __ea i;\n+@end smallexample\n+\n+When the variable @code{i} is accessed, the compiler will generate\n+special code to access this variable.  It may use runtime library\n+support, or generate special machine instructions to access that address\n+space.\n+\n+The @code{__ea} identifier may be used exactly like any other C type\n+qualifier (e.g., @code{const} or @code{volatile}).  See the N1275\n+document for more details.\n+\n @node Zero Length\n @section Arrays of Length Zero\n @cindex arrays of length zero"}, {"sha": "4888eb3f1e1200fa9b156f43aeef7592901ac808", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -420,6 +420,11 @@ the size is implied by the mode.\n @findex MEM_ALIGN\n @item MEM_ALIGN (@var{x})\n The known alignment in bits of the memory reference.\n+\n+@findex MEM_ADDR_SPACE\n+@item MEM_ADDR_SPACE (@var{x})\n+The address space of the memory reference.  This will commonly be zero\n+for the generic address space.\n @end table\n \n @item REG"}, {"sha": "4a2fe56df9511fbd89ed6bbf3a7c7a8743a86c65", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -55,6 +55,7 @@ through the macros defined in the @file{.h} file.\n * MIPS Coprocessors::   MIPS coprocessor support and how to customize it.\n * PCH Target::          Validity checking for precompiled headers.\n * C++ ABI::             Controlling C++ ABI changes.\n+* Named Address Spaces:: Adding support for named address spaces\n * Misc::                Everything else.\n @end menu\n \n@@ -9825,6 +9826,69 @@ defined.  Use this hook to make adjustments to the class (eg, tweak\n visibility or perform any other required target modifications).\n @end deftypefn\n \n+@node Named Address Spaces\n+@section Adding support for named address spaces\n+@cindex named address spaces\n+\n+The draft technical report of the ISO/IEC JTC1 S22 WG14 N1275\n+standards committee, @cite{Programming Languages - C - Extensions to\n+support embedded processors}, specifies a syntax for embedded\n+processors to specify alternate address spaces.  You can configure a\n+GCC port to support section 5.1 of the draft report to add support for\n+address spaces other than the default address space.  These address\n+spaces are new keywords that are similar to the @code{volatile} and\n+@code{const} type attributes.\n+\n+Pointers to named address spaces can a a different size than\n+pointers to the generic address space.\n+\n+For example, the SPU port uses the @code{__ea} address space to refer\n+to memory in the host processor, rather than memory local to the SPU\n+processor.  Access to memory in the @code{__ea} address space involves\n+issuing DMA operations to move data between the host processor and the\n+local processor memory address space.  Pointers in the @code{__ea}\n+address space are either 32 bits or 64 bits based on the\n+@option{-mea32} or @option{-mea64} switches (native SPU pointers are\n+always 32 bits).\n+\n+Internally, address spaces are represented as a small integer in the\n+range 0 to 15 with address space 0 being reserved for the generic\n+address space.\n+\n+@deftypefn {Target Hook} {bool} TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P (enum machine_mode @var{mode}, rtx @var{exp}, bool @var{strict}, addr_space_t @var{as})\n+Define this to return true if @var{exp} is a valid address for mode\n+@var{mode} in the named address space @var{as}.  The @var{strict}\n+parameter says whether strict addressing is in effect after reload has\n+finished.  This target hook is the same as the\n+@code{TARGET_LEGITIMATE_ADDRESS_P} target hook, except that it includes\n+explicit named address space support.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} {rtx} TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS (rtx @var{x}, rtx @var{oldx}, enum machine_mode @var{mode}, addr_space_t @var{as})\n+Define this to modify an invalid address @var{x} to be a valid address\n+with mode @var{mode} in the named address space @var{as}.  This target\n+hook is the same as the @code{TARGET_LEGITIMIZE_ADDRESS} target hook,\n+except that it includes explicit named address space support.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} {bool} TARGET_ADDR_SPACE_SUBSET_P (addr_space_t @var{superset}, addr_space_t @var{subset})\n+Define this to return whether the @var{subset} named address space is\n+contained within the @var{superset} named address space.  Pointers to\n+a named address space that is a subset of another named address space\n+will be converted automatically without a cast if used together in\n+arithmetic operations.  Pointers to a superset address space can be\n+converted to pointers to a subset address space via explict casts.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} {rtx} TARGET_ADDR_SPACE_CONVERT (rtx @var{op}, tree @var{from_type}, tree @var{to_type})\n+Define this to convert the pointer expression represented by the RTL\n+@var{op} with type @var{from_type} that points to a named address\n+space to a new pointer expression with type @var{to_type} that points\n+to a different named address space.  When this hook it called, it is\n+guaranteed that one of the two address spaces is a subset of the other,\n+as determined by the @code{TARGET_ADDR_SPACE_SUBSET_P} target hook.\n+@end deftypefn\n+\n @node Misc\n @section Miscellaneous Parameters\n @cindex parameters, miscellaneous"}, {"sha": "f11c34a6c4c8b88097103ed63382674bc1ed7dce", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -1173,7 +1173,8 @@ canon_address (rtx mem,\n \t  address = XEXP (address, 0);\n \t}\n \n-      if (const_or_frame_p (address))\n+      if (ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (mem))\n+\t  && const_or_frame_p (address))\n \t{\n \t  group_info_t group = get_group_info (address);\n "}, {"sha": "129ba7de92748a66bf858c2263960ec53afd0c3d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -12158,13 +12158,19 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n       add_AT_unsigned (mod_type_die, DW_AT_byte_size,\n \t\t       simple_type_size_in_bits (type) / BITS_PER_UNIT);\n       item_type = TREE_TYPE (type);\n+      if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (item_type)))\n+\tadd_AT_unsigned (mod_type_die, DW_AT_address_class,\n+\t\t\t TYPE_ADDR_SPACE (item_type));\n     }\n   else if (code == REFERENCE_TYPE)\n     {\n       mod_type_die = new_die (DW_TAG_reference_type, comp_unit_die, type);\n       add_AT_unsigned (mod_type_die, DW_AT_byte_size,\n \t\t       simple_type_size_in_bits (type) / BITS_PER_UNIT);\n       item_type = TREE_TYPE (type);\n+      if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (item_type)))\n+\tadd_AT_unsigned (mod_type_die, DW_AT_address_class,\n+\t\t\t TYPE_ADDR_SPACE (item_type));\n     }\n   else if (code == INTEGER_TYPE\n \t   && TREE_TYPE (type) != NULL_TREE"}, {"sha": "baad4a85eefb710a92cb4185f89a69dee7dcc37a", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -193,7 +193,7 @@ static rtx lookup_const_fixed (rtx);\n static hashval_t mem_attrs_htab_hash (const void *);\n static int mem_attrs_htab_eq (const void *, const void *);\n static mem_attrs *get_mem_attrs (alias_set_type, tree, rtx, rtx, unsigned int,\n-\t\t\t\t enum machine_mode);\n+\t\t\t\t addr_space_t, enum machine_mode);\n static hashval_t reg_attrs_htab_hash (const void *);\n static int reg_attrs_htab_eq (const void *, const void *);\n static reg_attrs *get_reg_attrs (tree, int);\n@@ -292,6 +292,7 @@ mem_attrs_htab_hash (const void *x)\n   const mem_attrs *const p = (const mem_attrs *) x;\n \n   return (p->alias ^ (p->align * 1000)\n+\t  ^ (p->addrspace * 4000)\n \t  ^ ((p->offset ? INTVAL (p->offset) : 0) * 50000)\n \t  ^ ((p->size ? INTVAL (p->size) : 0) * 2500000)\n \t  ^ (size_t) iterative_hash_expr (p->expr, 0));\n@@ -309,6 +310,7 @@ mem_attrs_htab_eq (const void *x, const void *y)\n \n   return (p->alias == q->alias && p->offset == q->offset\n \t  && p->size == q->size && p->align == q->align\n+\t  && p->addrspace == q->addrspace\n \t  && (p->expr == q->expr\n \t      || (p->expr != NULL_TREE && q->expr != NULL_TREE\n \t\t  && operand_equal_p (p->expr, q->expr, 0))));\n@@ -320,15 +322,15 @@ mem_attrs_htab_eq (const void *x, const void *y)\n \n static mem_attrs *\n get_mem_attrs (alias_set_type alias, tree expr, rtx offset, rtx size,\n-\t       unsigned int align, enum machine_mode mode)\n+\t       unsigned int align, addr_space_t addrspace, enum machine_mode mode)\n {\n   mem_attrs attrs;\n   void **slot;\n \n   /* If everything is the default, we can just return zero.\n      This must match what the corresponding MEM_* macros return when the\n      field is not present.  */\n-  if (alias == 0 && expr == 0 && offset == 0\n+  if (alias == 0 && expr == 0 && offset == 0 && addrspace == 0\n       && (size == 0\n \t  || (mode != BLKmode && GET_MODE_SIZE (mode) == INTVAL (size)))\n       && (STRICT_ALIGNMENT && mode != BLKmode\n@@ -340,6 +342,7 @@ get_mem_attrs (alias_set_type alias, tree expr, rtx offset, rtx size,\n   attrs.offset = offset;\n   attrs.size = size;\n   attrs.align = align;\n+  attrs.addrspace = addrspace;\n \n   slot = htab_find_slot (mem_attrs_htab, &attrs, INSERT);\n   if (*slot == 0)\n@@ -1386,7 +1389,9 @@ operand_subword (rtx op, unsigned int offset, int validate_address, enum machine\n \n       else if (reload_completed)\n \t{\n-\t  if (! strict_memory_address_p (word_mode, XEXP (new_rtx, 0)))\n+\t  if (! strict_memory_address_addr_space_p (word_mode,\n+\t\t\t\t\t\t    XEXP (new_rtx, 0),\n+\t\t\t\t\t\t    MEM_ADDR_SPACE (op)))\n \t    return 0;\n \t}\n       else\n@@ -1795,7 +1800,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \n   /* Now set the attributes we computed above.  */\n   MEM_ATTRS (ref)\n-    = get_mem_attrs (alias, expr, offset, size, align, GET_MODE (ref));\n+    = get_mem_attrs (alias, expr, offset, size, align,\n+\t\t     TYPE_ADDR_SPACE (type), GET_MODE (ref));\n \n   /* If this is already known to be a scalar or aggregate, we are done.  */\n   if (MEM_IN_STRUCT_P (ref) || MEM_SCALAR_P (ref))\n@@ -1827,7 +1833,17 @@ set_mem_alias_set (rtx mem, alias_set_type set)\n \n   MEM_ATTRS (mem) = get_mem_attrs (set, MEM_EXPR (mem), MEM_OFFSET (mem),\n \t\t\t\t   MEM_SIZE (mem), MEM_ALIGN (mem),\n-\t\t\t\t   GET_MODE (mem));\n+\t\t\t\t   MEM_ADDR_SPACE (mem), GET_MODE (mem));\n+}\n+\n+/* Set the address space of MEM to ADDRSPACE (target-defined).  */\n+\n+void\n+set_mem_addr_space (rtx mem, addr_space_t addrspace)\n+{\n+  MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n+\t\t\t\t   MEM_OFFSET (mem), MEM_SIZE (mem),\n+\t\t\t\t   MEM_ALIGN (mem), addrspace, GET_MODE (mem));\n }\n \n /* Set the alignment of MEM to ALIGN bits.  */\n@@ -1837,7 +1853,7 @@ set_mem_align (rtx mem, unsigned int align)\n {\n   MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n \t\t\t\t   MEM_OFFSET (mem), MEM_SIZE (mem), align,\n-\t\t\t\t   GET_MODE (mem));\n+\t\t\t\t   MEM_ADDR_SPACE (mem), GET_MODE (mem));\n }\n \n /* Set the expr for MEM to EXPR.  */\n@@ -1847,7 +1863,8 @@ set_mem_expr (rtx mem, tree expr)\n {\n   MEM_ATTRS (mem)\n     = get_mem_attrs (MEM_ALIAS_SET (mem), expr, MEM_OFFSET (mem),\n-\t\t     MEM_SIZE (mem), MEM_ALIGN (mem), GET_MODE (mem));\n+\t\t     MEM_SIZE (mem), MEM_ALIGN (mem),\n+\t\t     MEM_ADDR_SPACE (mem), GET_MODE (mem));\n }\n \n /* Set the offset of MEM to OFFSET.  */\n@@ -1857,7 +1874,7 @@ set_mem_offset (rtx mem, rtx offset)\n {\n   MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n \t\t\t\t   offset, MEM_SIZE (mem), MEM_ALIGN (mem),\n-\t\t\t\t   GET_MODE (mem));\n+\t\t\t\t   MEM_ADDR_SPACE (mem), GET_MODE (mem));\n }\n \n /* Set the size of MEM to SIZE.  */\n@@ -1867,7 +1884,7 @@ set_mem_size (rtx mem, rtx size)\n {\n   MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n \t\t\t\t   MEM_OFFSET (mem), size, MEM_ALIGN (mem),\n-\t\t\t\t   GET_MODE (mem));\n+\t\t\t\t   MEM_ADDR_SPACE (mem), GET_MODE (mem));\n }\n \f\n /* Return a memory reference like MEMREF, but with its mode changed to MODE\n@@ -1879,23 +1896,25 @@ set_mem_size (rtx mem, rtx size)\n static rtx\n change_address_1 (rtx memref, enum machine_mode mode, rtx addr, int validate)\n {\n+  addr_space_t as;\n   rtx new_rtx;\n \n   gcc_assert (MEM_P (memref));\n+  as = MEM_ADDR_SPACE (memref);\n   if (mode == VOIDmode)\n     mode = GET_MODE (memref);\n   if (addr == 0)\n     addr = XEXP (memref, 0);\n   if (mode == GET_MODE (memref) && addr == XEXP (memref, 0)\n-      && (!validate || memory_address_p (mode, addr)))\n+      && (!validate || memory_address_addr_space_p (mode, addr, as)))\n     return memref;\n \n   if (validate)\n     {\n       if (reload_in_progress || reload_completed)\n-\tgcc_assert (memory_address_p (mode, addr));\n+\tgcc_assert (memory_address_addr_space_p (mode, addr, as));\n       else\n-\taddr = memory_address (mode, addr);\n+\taddr = memory_address_addr_space (mode, addr, as);\n     }\n \n   if (rtx_equal_p (addr, XEXP (memref, 0)) && mode == GET_MODE (memref))\n@@ -1934,7 +1953,8 @@ change_address (rtx memref, enum machine_mode mode, rtx addr)\n     }\n \n   MEM_ATTRS (new_rtx)\n-    = get_mem_attrs (MEM_ALIAS_SET (memref), 0, 0, size, align, mmode);\n+    = get_mem_attrs (MEM_ALIAS_SET (memref), 0, 0, size, align,\n+\t\t     MEM_ADDR_SPACE (memref), mmode);\n \n   return new_rtx;\n }\n@@ -1954,11 +1974,12 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n   rtx memoffset = MEM_OFFSET (memref);\n   rtx size = 0;\n   unsigned int memalign = MEM_ALIGN (memref);\n+  addr_space_t as = MEM_ADDR_SPACE (memref);\n   int pbits;\n \n   /* If there are no changes, just return the original memory reference.  */\n   if (mode == GET_MODE (memref) && !offset\n-      && (!validate || memory_address_p (mode, addr)))\n+      && (!validate || memory_address_addr_space_p (mode, addr, as)))\n     return memref;\n \n   /* ??? Prefer to create garbage instead of creating shared rtl.\n@@ -2017,7 +2038,8 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n     size = plus_constant (MEM_SIZE (memref), -offset);\n \n   MEM_ATTRS (new_rtx) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref),\n-\t\t\t\t   memoffset, size, memalign, GET_MODE (new_rtx));\n+\t\t\t\t       memoffset, size, memalign, as,\n+\t\t\t\t       GET_MODE (new_rtx));\n \n   /* At some point, we should validate that this offset is within the object,\n      if all the appropriate values are known.  */\n@@ -2045,6 +2067,7 @@ rtx\n offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n {\n   rtx new_rtx, addr = XEXP (memref, 0);\n+  addr_space_t as = MEM_ADDR_SPACE (memref);\n \n   new_rtx = simplify_gen_binary (PLUS, Pmode, addr, offset);\n \n@@ -2055,7 +2078,7 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n      being able to recognize the magic around pic_offset_table_rtx.\n      This stuff is fragile, and is yet another example of why it is\n      bad to expose PIC machinery too early.  */\n-  if (! memory_address_p (GET_MODE (memref), new_rtx)\n+  if (! memory_address_addr_space_p (GET_MODE (memref), new_rtx, as)\n       && GET_CODE (addr) == PLUS\n       && XEXP (addr, 0) == pic_offset_table_rtx)\n     {\n@@ -2075,7 +2098,7 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n   MEM_ATTRS (new_rtx)\n     = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref), 0, 0,\n \t\t     MIN (MEM_ALIGN (memref), pow2 * BITS_PER_UNIT),\n-\t\t     GET_MODE (new_rtx));\n+\t\t     as, GET_MODE (new_rtx));\n   return new_rtx;\n }\n \n@@ -2179,7 +2202,8 @@ widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n   /* ??? Maybe use get_alias_set on any remaining expression.  */\n \n   MEM_ATTRS (new_rtx) = get_mem_attrs (0, expr, memoffset, GEN_INT (size),\n-\t\t\t\t   MEM_ALIGN (new_rtx), mode);\n+\t\t\t\t       MEM_ALIGN (new_rtx),\n+\t\t\t\t       MEM_ADDR_SPACE (new_rtx), mode);\n \n   return new_rtx;\n }\n@@ -2207,7 +2231,7 @@ get_spill_slot_decl (bool force_build_p)\n   rd = gen_rtx_MEM (BLKmode, frame_pointer_rtx);\n   MEM_NOTRAP_P (rd) = 1;\n   MEM_ATTRS (rd) = get_mem_attrs (new_alias_set (), d, const0_rtx,\n-\t\t\t\t  NULL_RTX, 0, BLKmode);\n+\t\t\t\t  NULL_RTX, 0, ADDR_SPACE_GENERIC, BLKmode);\n   SET_DECL_RTL (d, rd);\n \n   return d;\n@@ -2240,7 +2264,7 @@ set_mem_attrs_for_spill (rtx mem)\n \n   MEM_ATTRS (mem) = get_mem_attrs (alias, expr, offset,\n \t\t\t\t   MEM_SIZE (mem), MEM_ALIGN (mem),\n-\t\t\t\t   GET_MODE (mem));\n+\t\t\t\t   ADDR_SPACE_GENERIC, GET_MODE (mem));\n   MEM_NOTRAP_P (mem) = 1;\n }\n \f"}, {"sha": "01479e1eb5faa6be10eadc57c6e0d8313fba238a", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -26,6 +26,9 @@ extern void set_mem_alias_set (rtx, alias_set_type);\n /* Set the alignment of MEM to ALIGN bits.  */\n extern void set_mem_align (rtx, unsigned int);\n \n+/* Set the address space of MEM to ADDRSPACE.  */\n+extern void set_mem_addr_space (rtx, addr_space_t);\n+\n /* Set the expr for MEM to EXPR.  */\n extern void set_mem_expr (rtx, tree);\n "}, {"sha": "1115f222c4c2296153d062baa146ec081c2f66d5", "filename": "gcc/explow.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -405,12 +405,12 @@ convert_memory_address (enum machine_mode to_mode ATTRIBUTE_UNUSED,\n #endif /* defined(POINTERS_EXTEND_UNSIGNED) */\n }\n \f\n-/* Return something equivalent to X but valid as a memory address\n-   for something of mode MODE.  When X is not itself valid, this\n-   works by copying X or subexpressions of it into registers.  */\n+/* Return something equivalent to X but valid as a memory address for something\n+   of mode MODE in the named address space AS.  When X is not itself valid,\n+   this works by copying X or subexpressions of it into registers.  */\n \n rtx\n-memory_address (enum machine_mode mode, rtx x)\n+memory_address_addr_space (enum machine_mode mode, rtx x, addr_space_t as)\n {\n   rtx oldx = x;\n \n@@ -431,12 +431,12 @@ memory_address (enum machine_mode mode, rtx x)\n \tx = break_out_memory_refs (x);\n \n       /* At this point, any valid address is accepted.  */\n-      if (memory_address_p (mode, x))\n+      if (memory_address_addr_space_p (mode, x, as))\n \tgoto done;\n \n       /* If it was valid before but breaking out memory refs invalidated it,\n \t use it the old way.  */\n-      if (memory_address_p (mode, oldx))\n+      if (memory_address_addr_space_p (mode, oldx, as))\n \t{\n \t  x = oldx;\n \t  goto done;\n@@ -447,9 +447,9 @@ memory_address (enum machine_mode mode, rtx x)\n \t below can handle all possible cases, but machine-dependent\n \t transformations can make better code.  */\n       {\n-        rtx orig_x = x;\n-        x = targetm.legitimize_address (x, oldx, mode);\n-\tif (orig_x != x && memory_address_p (mode, x))\n+\trtx orig_x = x;\n+\tx = targetm.addr_space.legitimize_address (x, oldx, mode, as);\n+\tif (orig_x != x && memory_address_addr_space_p (mode, x, as))\n \t  goto done;\n       }\n \n@@ -467,12 +467,12 @@ memory_address (enum machine_mode mode, rtx x)\n \t  rtx constant_term = const0_rtx;\n \t  rtx y = eliminate_constant_term (x, &constant_term);\n \t  if (constant_term == const0_rtx\n-\t      || ! memory_address_p (mode, y))\n+\t      || ! memory_address_addr_space_p (mode, y, as))\n \t    x = force_operand (x, NULL_RTX);\n \t  else\n \t    {\n \t      y = gen_rtx_PLUS (GET_MODE (x), copy_to_reg (y), constant_term);\n-\t      if (! memory_address_p (mode, y))\n+\t      if (! memory_address_addr_space_p (mode, y, as))\n \t\tx = force_operand (x, NULL_RTX);\n \t      else\n \t\tx = y;\n@@ -495,7 +495,7 @@ memory_address (enum machine_mode mode, rtx x)\n \n  done:\n \n-  gcc_assert (memory_address_p (mode, x));\n+  gcc_assert (memory_address_addr_space_p (mode, x, as));\n   /* If we didn't change the address, we are done.  Otherwise, mark\n      a reg as a pointer if we have REG or REG + CONST_INT.  */\n   if (oldx == x)\n@@ -523,7 +523,8 @@ validize_mem (rtx ref)\n   if (!MEM_P (ref))\n     return ref;\n   ref = use_anchored_address (ref);\n-  if (memory_address_p (GET_MODE (ref), XEXP (ref, 0)))\n+  if (memory_address_addr_space_p (GET_MODE (ref), XEXP (ref, 0),\n+\t\t\t\t   MEM_ADDR_SPACE (ref)))\n     return ref;\n \n   /* Don't alter REF itself, since that is probably a stack slot.  */"}, {"sha": "5e8fae123cb29c0ebfccb1569e079239199bfcfa", "filename": "gcc/expr.c", "status": "modified", "additions": 66, "deletions": 10, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -1215,7 +1215,9 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n   else if (emit_block_move_via_movmem (x, y, size, align,\n \t\t\t\t       expected_align, expected_size))\n     ;\n-  else if (may_use_call)\n+  else if (may_use_call\n+\t   && ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (x))\n+\t   && ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (y)))\n     retval = emit_block_move_via_libcall (x, y, size,\n \t\t\t\t\t  method == BLOCK_OP_TAILCALL);\n   else\n@@ -2641,9 +2643,11 @@ clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n   else if (set_storage_via_setmem (object, size, const0_rtx, align,\n \t\t\t\t   expected_align, expected_size))\n     ;\n-  else\n+  else if (ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (object)))\n     return set_storage_via_libcall (object, size, const0_rtx,\n \t\t\t\t    method == BLOCK_OP_TAILCALL);\n+  else\n+    gcc_unreachable ();\n \n   return NULL;\n }\n@@ -3432,12 +3436,14 @@ emit_move_insn (rtx x, rtx y)\n   /* If X or Y are memory references, verify that their addresses are valid\n      for the machine.  */\n   if (MEM_P (x)\n-      && (! memory_address_p (GET_MODE (x), XEXP (x, 0))\n+      && (! memory_address_addr_space_p (GET_MODE (x), XEXP (x, 0),\n+\t\t\t\t\t MEM_ADDR_SPACE (x))\n \t  && ! push_operand (x, GET_MODE (x))))\n     x = validize_mem (x);\n \n   if (MEM_P (y)\n-      && ! memory_address_p (GET_MODE (y), XEXP (y, 0)))\n+      && ! memory_address_addr_space_p (GET_MODE (y), XEXP (y, 0),\n+\t\t\t\t\tMEM_ADDR_SPACE (y)))\n     y = validize_mem (y);\n \n   gcc_assert (mode != BLKmode);\n@@ -4298,20 +4304,25 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \n    else if (TREE_CODE (to) == MISALIGNED_INDIRECT_REF)\n      {\n+       addr_space_t as = ADDR_SPACE_GENERIC;\n        enum machine_mode mode, op_mode1;\n        enum insn_code icode;\n        rtx reg, addr, mem, insn;\n \n+       if (POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (to, 0))))\n+\t as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (to, 0))));\n+\n        reg = expand_expr (from, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n        reg = force_not_mem (reg);\n \n        mode = TYPE_MODE (TREE_TYPE (to));\n        addr = expand_expr (TREE_OPERAND (to, 0), NULL_RTX, VOIDmode,\n                          EXPAND_SUM);\n-       addr = memory_address (mode, addr);\n+       addr = memory_address_addr_space (mode, addr, as);\n        mem = gen_rtx_MEM (mode, addr);\n \n        set_mem_attributes (mem, to, 0);\n+       set_mem_addr_space (mem, as);\n \n        icode = movmisalign_optab->handlers[mode].insn_code;\n        gcc_assert (icode != CODE_FOR_nothing);\n@@ -4400,6 +4411,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n      the place the value is being stored, use a safe function when copying\n      a value through a pointer into a structure value return block.  */\n   if (TREE_CODE (to) == RESULT_DECL && TREE_CODE (from) == INDIRECT_REF\n+      && ADDR_SPACE_GENERIC_P\n+\t  (TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (from, 0)))))\n       && cfun->returns_struct\n       && !cfun->returns_pcc_struct)\n     {\n@@ -7343,6 +7356,39 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \n       return REDUCE_BIT_FIELD (op0);\n \n+    case ADDR_SPACE_CONVERT_EXPR:\n+      {\n+\ttree treeop0_type = TREE_TYPE (treeop0);\n+\taddr_space_t as_to;\n+\taddr_space_t as_from;\n+\n+\tgcc_assert (POINTER_TYPE_P (type));\n+\tgcc_assert (POINTER_TYPE_P (treeop0_type));\n+\n+\tas_to = TYPE_ADDR_SPACE (TREE_TYPE (type));\n+\tas_from = TYPE_ADDR_SPACE (TREE_TYPE (treeop0_type));\n+\n+        /* Conversions between pointers to the same address space should\n+\t   have been implemented via CONVERT_EXPR / NOP_EXPR.  */\n+\tgcc_assert (as_to != as_from);\n+\n+        /* Ask target code to handle conversion between pointers\n+\t   to overlapping address spaces.  */\n+\tif (targetm.addr_space.subset_p (as_to, as_from)\n+\t    || targetm.addr_space.subset_p (as_from, as_to))\n+\t  {\n+\t    op0 = expand_expr (treeop0, NULL_RTX, VOIDmode, modifier);\n+\t    op0 = targetm.addr_space.convert (op0, treeop0_type, type);\n+\t    gcc_assert (op0);\n+\t    return op0;\n+\t  }\n+\n+\t/* For disjoint address spaces, converting anything but\n+\t   a null pointer invokes undefined behaviour.  We simply\n+\t   always return a null pointer here.  */\n+\treturn CONST0_RTX (mode);\n+      }\n+\n     case POINTER_PLUS_EXPR: \n       /* Even though the sizetype mode and the pointer's mode can be different\n          expand is able to handle this correctly and get the correct result out \n@@ -8431,7 +8477,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  decl_rtl = use_anchored_address (decl_rtl);\n \t  if (modifier != EXPAND_CONST_ADDRESS\n \t      && modifier != EXPAND_SUM\n-\t      && !memory_address_p (DECL_MODE (exp), XEXP (decl_rtl, 0)))\n+\t      && !memory_address_addr_space_p (DECL_MODE (exp),\n+\t\t\t\t\t       XEXP (decl_rtl, 0),\n+\t\t\t\t\t       MEM_ADDR_SPACE (decl_rtl)))\n \t    temp = replace_equiv_address (decl_rtl,\n \t\t\t\t\t  copy_rtx (XEXP (decl_rtl, 0)));\n \t}\n@@ -8551,7 +8599,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       if (modifier != EXPAND_CONST_ADDRESS\n \t  && modifier != EXPAND_INITIALIZER\n \t  && modifier != EXPAND_SUM\n-\t  && ! memory_address_p (mode, XEXP (temp, 0)))\n+\t  && ! memory_address_addr_space_p (mode, XEXP (temp, 0),\n+\t\t\t\t\t    MEM_ADDR_SPACE (temp)))\n \treturn replace_equiv_address (temp,\n \t\t\t\t      copy_rtx (XEXP (temp, 0)));\n       return temp;\n@@ -8607,6 +8656,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case INDIRECT_REF:\n       {\n \ttree exp1 = treeop0;\n+\taddr_space_t as = ADDR_SPACE_GENERIC;\n \n \tif (modifier != EXPAND_WRITE)\n \t  {\n@@ -8617,19 +8667,23 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      return expand_expr (t, target, tmode, modifier);\n \t  }\n \n+\tif (POINTER_TYPE_P (TREE_TYPE (exp1)))\n+\t  as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp1)));\n+\n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n-\top0 = memory_address (mode, op0);\n+\top0 = memory_address_addr_space (mode, op0, as);\n \n \tif (code == ALIGN_INDIRECT_REF)\n \t  {\n \t    int align = TYPE_ALIGN_UNIT (type);\n \t    op0 = gen_rtx_AND (Pmode, op0, GEN_INT (-align));\n-\t    op0 = memory_address (mode, op0);\n+\t    op0 = memory_address_addr_space (mode, op0, as);\n \t  }\n \n \ttemp = gen_rtx_MEM (mode, op0);\n \n \tset_mem_attributes (temp, exp, 0);\n+\tset_mem_addr_space (temp, as);\n \n \t/* Resolve the misalignment now, so that we don't have to remember\n \t   to resolve it later.  Of course, this only works for reads.  */\n@@ -8661,13 +8715,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case TARGET_MEM_REF:\n       {\n+\taddr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (exp));\n \tstruct mem_address addr;\n \n \tget_address_description (exp, &addr);\n \top0 = addr_for_mem_ref (&addr, true);\n-\top0 = memory_address (mode, op0);\n+\top0 = memory_address_addr_space (mode, op0, as);\n \ttemp = gen_rtx_MEM (mode, op0);\n \tset_mem_attributes (temp, TMR_ORIGINAL (exp), 0);\n+\tset_mem_addr_space (temp, as);\n       }\n       return temp;\n "}, {"sha": "0eceb6e45bee3e0332d9f960859ed779ba64979d", "filename": "gcc/expr.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -650,9 +650,15 @@ extern rtx force_label_rtx (tree);\n    The constant terms are added and stored via a second arg.  */\n extern rtx eliminate_constant_term (rtx, rtx *);\n \n-/* Convert arg to a valid memory address for specified machine mode,\n-   by emitting insns to perform arithmetic if nec.  */\n-extern rtx memory_address (enum machine_mode, rtx);\n+/* Convert arg to a valid memory address for specified machine mode that points\n+   to a specific named address space, by emitting insns to perform arithmetic\n+   if necessary.  */\n+extern rtx memory_address_addr_space (enum machine_mode, rtx, addr_space_t);\n+\n+/* Like memory_address_addr_space, except assume the memory address points to\n+   the generic named address space.  */\n+#define memory_address(MODE,RTX) \\\n+\tmemory_address_addr_space ((MODE), (RTX), ADDR_SPACE_GENERIC)\n \n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR."}, {"sha": "aab4fac9edbead949527b1812de895a1f4c64257", "filename": "gcc/fold-const.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -2647,8 +2647,16 @@ fold_convert_loc (location_t loc, tree type, tree arg)\n \n   switch (TREE_CODE (type))\n     {\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      /* Handle conversions between pointers to different address spaces.  */\n+      if (POINTER_TYPE_P (orig)\n+\t  && (TYPE_ADDR_SPACE (TREE_TYPE (type))\n+\t      != TYPE_ADDR_SPACE (TREE_TYPE (orig))))\n+\treturn fold_build1_loc (loc, ADDR_SPACE_CONVERT_EXPR, type, arg);\n+      /* fall through */\n+\n     case INTEGER_TYPE: case ENUMERAL_TYPE: case BOOLEAN_TYPE:\n-    case POINTER_TYPE: case REFERENCE_TYPE:\n     case OFFSET_TYPE:\n       if (TREE_CODE (arg) == INTEGER_CST)\n \t{\n@@ -3179,6 +3187,12 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n       || POINTER_TYPE_P (TREE_TYPE (arg0)) != POINTER_TYPE_P (TREE_TYPE (arg1)))\n     return 0;\n \n+  /* We cannot consider pointers to different address space equal.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (arg0)) && POINTER_TYPE_P (TREE_TYPE (arg1))\n+      && (TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg0)))\n+\t  != TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg1)))))\n+    return 0;\n+\n   /* If both types don't have the same precision, then it is not safe\n      to strip NOPs.  */\n   if (TYPE_PRECISION (TREE_TYPE (arg0)) != TYPE_PRECISION (TREE_TYPE (arg1)))\n@@ -8682,6 +8696,11 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n       tem = fold_convert_const (code, type, op0);\n       return tem ? tem : NULL_TREE;\n \n+    case ADDR_SPACE_CONVERT_EXPR:\n+      if (integer_zerop (arg0))\n+\treturn fold_convert_const (code, type, arg0);\n+      return NULL_TREE;\n+\n     case FIXED_CONVERT_EXPR:\n       tem = fold_convert_const (code, type, arg0);\n       return tem ? tem : NULL_TREE;"}, {"sha": "75a354ea54df3e04fee764a2c9b3cbecf76d797d", "filename": "gcc/fwprop.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -375,19 +375,21 @@ canonicalize_address (rtx x)\n \n static bool\n should_replace_address (rtx old_rtx, rtx new_rtx, enum machine_mode mode,\n-\t\t\tbool speed)\n+\t\t\taddr_space_t as, bool speed)\n {\n   int gain;\n \n-  if (rtx_equal_p (old_rtx, new_rtx) || !memory_address_p (mode, new_rtx))\n+  if (rtx_equal_p (old_rtx, new_rtx)\n+      || !memory_address_addr_space_p (mode, new_rtx, as))\n     return false;\n \n   /* Copy propagation is always ok.  */\n   if (REG_P (old_rtx) && REG_P (new_rtx))\n     return true;\n \n   /* Prefer the new address if it is less expensive.  */\n-  gain = address_cost (old_rtx, mode, speed) - address_cost (new_rtx, mode, speed);\n+  gain = (address_cost (old_rtx, mode, as, speed)\n+\t  - address_cost (new_rtx, mode, as, speed));\n \n   /* If the addresses have equivalent cost, prefer the new address\n      if it has the highest `rtx_cost'.  That has the potential of\n@@ -555,6 +557,7 @@ propagate_rtx_1 (rtx *px, rtx old_rtx, rtx new_rtx, int flags)\n \t  /* Copy propagations are always ok.  Otherwise check the costs.  */\n \t  if (!(REG_P (old_rtx) && REG_P (new_rtx))\n \t      && !should_replace_address (op0, new_op0, GET_MODE (x),\n+\t\t\t\t\t  MEM_ADDR_SPACE (x),\n \t      \t\t\t \t  flags & PR_OPTIMIZE_FOR_SPEED))\n \t    return true;\n "}, {"sha": "4f6c4470c9dcd7760b1d8113cc847cd904cd07a0", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -254,6 +254,7 @@ dump_unary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n       break;\n \n     case FIXED_CONVERT_EXPR:\n+    case ADDR_SPACE_CONVERT_EXPR:\n     case FIX_TRUNC_EXPR:\n     case FLOAT_EXPR:\n     CASE_CONVERT:"}, {"sha": "8b1b4500e6f501fcf3a7e2f9ba13507ac4c4742b", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -1329,6 +1329,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   /* ??? FIXME: Magic number 5.  */\n   if (cse_not_expected\n       && MEM_P (a) && MEM_P (b)\n+      && MEM_ADDR_SPACE (a) == MEM_ADDR_SPACE (b)\n       && if_info->branch_cost >= 5)\n     {\n       a = XEXP (a, 0);\n@@ -1482,6 +1483,9 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n       set_mem_align (tmp,\n \t\t     MIN (MEM_ALIGN (if_info->a), MEM_ALIGN (if_info->b)));\n \n+      gcc_assert (MEM_ADDR_SPACE (if_info->a) == MEM_ADDR_SPACE (if_info->b));\n+      set_mem_addr_space (tmp, MEM_ADDR_SPACE (if_info->a));\n+\n       noce_emit_move_insn (if_info->x, tmp);\n     }\n   else if (target != x)"}, {"sha": "6ebc7ef1cd7e2c8010c6a7c31807160601873b47", "filename": "gcc/jump.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -1695,6 +1695,10 @@ rtx_renumbered_equal_p (const_rtx x, const_rtx y)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n+  /* MEMs refering to different address space are not equivalent.  */\n+  if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))\n+    return 0;\n+\n   /* For commutative operations, the RTX match if the operand match in any\n      order.  Also handle the simple binary and unary cases without a loop.  */\n   if (targetm.commutative_p (x, UNKNOWN))"}, {"sha": "37f88f2fcbda13501234fb3fc2ba6c6d7a29a120", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -715,7 +715,7 @@ create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n \t invariants).\n \t See http://gcc.gnu.org/ml/gcc-patches/2009-10/msg01210.html .  */\n       inv->cheap_address = address_cost (SET_SRC (set), word_mode,\n-\t\t\t\t\t speed) < 3;\n+\t\t\t\t\t ADDR_SPACE_GENERIC, speed) < 3;\n     }\n   else\n     {"}, {"sha": "bc2854d9179c3b6d2180e41fecd9ca94c24b2745", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -562,6 +562,9 @@ print_rtx (const_rtx in_rtx)\n       if (MEM_ALIGN (in_rtx) != 1)\n \tfprintf (outfile, \" A%u\", MEM_ALIGN (in_rtx));\n \n+      if (!ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (in_rtx)))\n+\tfprintf (outfile, \" AS%u\", MEM_ADDR_SPACE (in_rtx));\n+\n       fputc (']', outfile);\n       break;\n "}, {"sha": "f0a3294263ab397fcea7451d1848e87ec1a8bba1", "filename": "gcc/print-tree.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -111,6 +111,8 @@ print_node_brief (FILE *file, const char *prefix, const_tree node, int indent)\n \t    fprintf (file, \" %s\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (node))));\n \t}\n+      if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (node)))\n+\tfprintf (file, \" address-space-%d\", TYPE_ADDR_SPACE (node));\n     }\n   if (TREE_CODE (node) == IDENTIFIER_NODE)\n     fprintf (file, \" %s\", IDENTIFIER_POINTER (node));\n@@ -300,6 +302,9 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n   else if (TYPE_P (node) && TYPE_SIZES_GIMPLIFIED (node))\n     fputs (\" sizes-gimplified\", file);\n \n+  if (TYPE_P (node) && !ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (node)))\n+    fprintf (file, \" address-space-%d\", TYPE_ADDR_SPACE (node));\n+\n   if (TREE_ADDRESSABLE (node))\n     fputs (\" addressable\", file);\n   if (TREE_THIS_VOLATILE (node))"}, {"sha": "b03324146f1bc0fcee2b074eb382d649166962fb", "filename": "gcc/recog.c", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -376,7 +376,9 @@ verify_changes (int num)\n \n       if (MEM_P (object))\n \t{\n-\t  if (! memory_address_p (GET_MODE (object), XEXP (object, 0)))\n+\t  if (! memory_address_addr_space_p (GET_MODE (object),\n+\t\t\t\t\t     XEXP (object, 0),\n+\t\t\t\t\t     MEM_ADDR_SPACE (object)))\n \t    break;\n \t}\n       else if (REG_P (changes[i].old)\n@@ -978,7 +980,7 @@ general_operand (rtx op, enum machine_mode mode)\n \treturn 0;\n \n       /* Use the mem's mode, since it will be reloaded thus.  */\n-      if (memory_address_p (GET_MODE (op), y))\n+      if (memory_address_addr_space_p (GET_MODE (op), y, MEM_ADDR_SPACE (op)))\n \treturn 1;\n     }\n \n@@ -1262,19 +1264,22 @@ pop_operand (rtx op, enum machine_mode mode)\n   return XEXP (op, 0) == stack_pointer_rtx;\n }\n \n-/* Return 1 if ADDR is a valid memory address for mode MODE.  */\n+/* Return 1 if ADDR is a valid memory address\n+   for mode MODE in address space AS.  */\n \n int\n-memory_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx addr)\n+memory_address_addr_space_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t     rtx addr, addr_space_t as)\n {\n #ifdef GO_IF_LEGITIMATE_ADDRESS\n+  gcc_assert (ADDR_SPACE_GENERIC_P (as));\n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n   return 0;\n \n  win:\n   return 1;\n #else\n-  return targetm.legitimate_address_p (mode, addr, 0);\n+  return targetm.addr_space.legitimate_address_p (mode, addr, 0, as);\n #endif\n }\n \n@@ -1871,7 +1876,8 @@ int\n offsettable_memref_p (rtx op)\n {\n   return ((MEM_P (op))\n-\t  && offsettable_address_p (1, GET_MODE (op), XEXP (op, 0)));\n+\t  && offsettable_address_addr_space_p (1, GET_MODE (op), XEXP (op, 0),\n+\t\t\t\t\t       MEM_ADDR_SPACE (op)));\n }\n \n /* Similar, but don't require a strictly valid mem ref:\n@@ -1881,12 +1887,13 @@ int\n offsettable_nonstrict_memref_p (rtx op)\n {\n   return ((MEM_P (op))\n-\t  && offsettable_address_p (0, GET_MODE (op), XEXP (op, 0)));\n+\t  && offsettable_address_addr_space_p (0, GET_MODE (op), XEXP (op, 0),\n+\t\t\t\t\t       MEM_ADDR_SPACE (op)));\n }\n \n /* Return 1 if Y is a memory address which contains no side effects\n-   and would remain valid after the addition of a positive integer\n-   less than the size of that mode.\n+   and would remain valid for address space AS after the addition of\n+   a positive integer less than the size of that mode.\n \n    We assume that the original address is valid and do not check it.\n    We do check that it is valid for narrower modes.\n@@ -1895,14 +1902,16 @@ offsettable_nonstrict_memref_p (rtx op)\n    for the sake of use in reload.c.  */\n \n int\n-offsettable_address_p (int strictp, enum machine_mode mode, rtx y)\n+offsettable_address_addr_space_p (int strictp, enum machine_mode mode, rtx y,\n+\t\t\t\t  addr_space_t as)\n {\n   enum rtx_code ycode = GET_CODE (y);\n   rtx z;\n   rtx y1 = y;\n   rtx *y2;\n-  int (*addressp) (enum machine_mode, rtx) =\n-    (strictp ? strict_memory_address_p : memory_address_p);\n+  int (*addressp) (enum machine_mode, rtx, addr_space_t) =\n+    (strictp ? strict_memory_address_addr_space_p\n+\t     : memory_address_addr_space_p);\n   unsigned int mode_sz = GET_MODE_SIZE (mode);\n \n   if (CONSTANT_ADDRESS_P (y))\n@@ -1932,7 +1941,7 @@ offsettable_address_p (int strictp, enum machine_mode mode, rtx y)\n       *y2 = plus_constant (*y2, mode_sz - 1);\n       /* Use QImode because an odd displacement may be automatically invalid\n \t for any wider mode.  But it should be valid for a single byte.  */\n-      good = (*addressp) (QImode, y);\n+      good = (*addressp) (QImode, y, as);\n \n       /* In any case, restore old contents of memory.  */\n       *y2 = y1;\n@@ -1957,7 +1966,7 @@ offsettable_address_p (int strictp, enum machine_mode mode, rtx y)\n \n   /* Use QImode because an odd displacement may be automatically invalid\n      for any wider mode.  But it should be valid for a single byte.  */\n-  return (*addressp) (QImode, z);\n+  return (*addressp) (QImode, z, as);\n }\n \n /* Return 1 if ADDR is an address-expression whose effect depends\n@@ -2502,11 +2511,14 @@ constrain_operands (int strict)\n \t\tif (MEM_P (op))\n \t\t  {\n \t\t    if (strict > 0\n-\t\t\t&& !strict_memory_address_p (GET_MODE (op),\n-\t\t\t\t\t\t     XEXP (op, 0)))\n+\t\t\t&& !strict_memory_address_addr_space_p\n+\t\t\t     (GET_MODE (op), XEXP (op, 0),\n+\t\t\t      MEM_ADDR_SPACE (op)))\n \t\t      break;\n \t\t    if (strict == 0\n-\t\t\t&& !memory_address_p (GET_MODE (op), XEXP (op, 0)))\n+\t\t\t&& !memory_address_addr_space_p\n+\t\t\t     (GET_MODE (op), XEXP (op, 0),\n+\t\t\t      MEM_ADDR_SPACE (op)))\n \t\t      break;\n \t\t    win = 1;\n \t\t  }"}, {"sha": "3354a66496a4508d5fcddc3517b40240f0c67fae", "filename": "gcc/recog.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -84,8 +84,13 @@ extern int num_validated_changes (void);\n extern void cancel_changes (int);\n extern int constrain_operands (int);\n extern int constrain_operands_cached (int);\n-extern int memory_address_p (enum machine_mode, rtx);\n-extern int strict_memory_address_p (enum machine_mode, rtx);\n+extern int memory_address_addr_space_p (enum machine_mode, rtx, addr_space_t);\n+#define memory_address_p(mode,addr) \\\n+\tmemory_address_addr_space_p ((mode), (addr), ADDR_SPACE_GENERIC)\n+extern int strict_memory_address_addr_space_p (enum machine_mode, rtx,\n+\t\t\t\t\t       addr_space_t);\n+#define strict_memory_address_p(mode,addr) \\\n+\tstrict_memory_address_addr_space_p ((mode), (addr), ADDR_SPACE_GENERIC)\n extern int validate_replace_rtx_subexp (rtx, rtx, rtx, rtx *);\n extern int validate_replace_rtx (rtx, rtx, rtx);\n extern int validate_replace_rtx_part (rtx, rtx, rtx *, rtx);\n@@ -101,7 +106,11 @@ extern int reg_fits_class_p (rtx, enum reg_class, int, enum machine_mode);\n \n extern int offsettable_memref_p (rtx);\n extern int offsettable_nonstrict_memref_p (rtx);\n-extern int offsettable_address_p (int, enum machine_mode, rtx);\n+extern int offsettable_address_addr_space_p (int, enum machine_mode, rtx,\n+\t\t\t\t\t     addr_space_t);\n+#define offsettable_address_p(strict,mode,addr) \\\n+\toffsettable_address_addr_space_p ((strict), (mode), (addr), \\\n+\t\t\t\t\t  ADDR_SPACE_GENERIC)\n extern int mode_dependent_address_p (rtx);\n \n extern int recog (rtx, rtx, int *);"}, {"sha": "166bcb986116a73fd89710028cfe3af82826e5e1", "filename": "gcc/reload.c", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -268,7 +268,8 @@ static bool alternative_allows_const_pool_ref (rtx, const char *, int);\n static rtx find_reloads_toplev (rtx, int, enum reload_type, int, int, rtx,\n \t\t\t\tint *);\n static rtx make_memloc (rtx, int);\n-static int maybe_memory_address_p (enum machine_mode, rtx, rtx *);\n+static int maybe_memory_address_addr_space_p (enum machine_mode, rtx,\n+\t\t\t\t\t      addr_space_t, rtx *);\n static int find_reloads_address (enum machine_mode, rtx *, rtx, rtx *,\n \t\t\t\t int, enum reload_type, int, rtx);\n static rtx subst_reg_equivs (rtx, rtx);\n@@ -612,7 +613,8 @@ get_secondary_mem (rtx x ATTRIBUTE_UNUSED, enum machine_mode mode,\n      didn't give us a new MEM, make a new one if it isn't valid.  */\n \n   loc = eliminate_regs (secondary_memlocs[(int) mode], VOIDmode, NULL_RTX);\n-  mem_valid = strict_memory_address_p (mode, XEXP (loc, 0));\n+  mem_valid = strict_memory_address_addr_space_p (mode, XEXP (loc, 0),\n+\t\t\t\t\t\t  MEM_ADDR_SPACE (loc));\n \n   if (! mem_valid && loc == secondary_memlocs[(int) mode])\n     loc = copy_rtx (loc);\n@@ -2129,21 +2131,23 @@ hard_reg_set_here_p (unsigned int beg_regno, unsigned int end_regno, rtx x)\n   return 0;\n }\n \n-/* Return 1 if ADDR is a valid memory address for mode MODE,\n-   and check that each pseudo reg has the proper kind of\n-   hard reg.  */\n+/* Return 1 if ADDR is a valid memory address for mode MODE\n+   in address space AS, and check that each pseudo reg has the\n+   proper kind of hard reg.  */\n \n int\n-strict_memory_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx addr)\n+strict_memory_address_addr_space_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t    rtx addr, addr_space_t as)\n {\n #ifdef GO_IF_LEGITIMATE_ADDRESS\n+  gcc_assert (ADDR_SPACE_GENERIC_P (as));\n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n   return 0;\n \n  win:\n   return 1;\n #else\n-  return targetm.legitimate_address_p (mode, addr, 1);\n+  return targetm.addr_space.legitimate_address_p (mode, addr, 1, as);\n #endif\n }\n \f\n@@ -2247,6 +2251,10 @@ operands_match_p (rtx x, rtx y)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n+  /* MEMs refering to different address space are not equivalent.  */\n+  if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))\n+    return 0;\n+\n   switch (code)\n     {\n     case CONST_INT:\n@@ -4760,8 +4768,9 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n #endif\n \t       && (reg_equiv_address[regno] != 0\n \t\t   || (reg_equiv_mem[regno] != 0\n-\t\t       && (! strict_memory_address_p (GET_MODE (x),\n-\t\t\t\t\t\t      XEXP (reg_equiv_mem[regno], 0))\n+\t\t       && (! strict_memory_address_addr_space_p\n+\t\t\t       (GET_MODE (x), XEXP (reg_equiv_mem[regno], 0),\n+\t\t\t\tMEM_ADDR_SPACE (reg_equiv_mem[regno]))\n \t\t\t   || ! offsettable_memref_p (reg_equiv_mem[regno])\n \t\t\t   || num_not_at_initial_offset))))\n \tx = find_reloads_subreg_address (x, 1, opnum, type, ind_levels,\n@@ -4819,18 +4828,19 @@ make_memloc (rtx ad, int regno)\n }\n \n /* Returns true if AD could be turned into a valid memory reference\n-   to mode MODE by reloading the part pointed to by PART into a\n-   register.  */\n+   to mode MODE in address space AS by reloading the part pointed to\n+   by PART into a register.  */\n \n static int\n-maybe_memory_address_p (enum machine_mode mode, rtx ad, rtx *part)\n+maybe_memory_address_addr_space_p (enum machine_mode mode, rtx ad,\n+\t\t\t\t   addr_space_t as, rtx *part)\n {\n   int retv;\n   rtx tem = *part;\n   rtx reg = gen_rtx_REG (GET_MODE (tem), max_reg_num ());\n \n   *part = reg;\n-  retv = memory_address_p (mode, ad);\n+  retv = memory_address_addr_space_p (mode, ad, as);\n   *part = tem;\n \n   return retv;\n@@ -4866,6 +4876,8 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t\t      rtx *loc, int opnum, enum reload_type type,\n \t\t      int ind_levels, rtx insn)\n {\n+  addr_space_t as = memrefloc? MEM_ADDR_SPACE (*memrefloc)\n+\t\t\t     : ADDR_SPACE_GENERIC;\n   int regno;\n   int removed_and = 0;\n   int op_index;\n@@ -4893,7 +4905,9 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t  if (reg_equiv_address[regno] != 0 || num_not_at_initial_offset)\n \t    {\n \t      tem = make_memloc (ad, regno);\n-\t      if (! strict_memory_address_p (GET_MODE (tem), XEXP (tem, 0)))\n+\t      if (! strict_memory_address_addr_space_p (GET_MODE (tem),\n+\t\t\t\t\t\t\tXEXP (tem, 0),\n+\t\t\t\t\t\t\tMEM_ADDR_SPACE (tem)))\n \t\t{\n \t\t  rtx orig = tem;\n \n@@ -4909,7 +4923,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t\t address: only reg or reg+constant.  */\n \n \t      if (ind_levels > 0\n-\t\t  && strict_memory_address_p (mode, tem)\n+\t\t  && strict_memory_address_addr_space_p (mode, tem, as)\n \t\t  && (REG_P (XEXP (tem, 0))\n \t\t      || (GET_CODE (XEXP (tem, 0)) == PLUS\n \t\t\t  && REG_P (XEXP (XEXP (tem, 0), 0))\n@@ -4953,7 +4967,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n       return 1;\n     }\n \n-  if (strict_memory_address_p (mode, ad))\n+  if (strict_memory_address_addr_space_p (mode, ad, as))\n     {\n       /* The address appears valid, so reloads are not needed.\n \t But the address may contain an eliminable register.\n@@ -4976,14 +4990,14 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \treturn 0;\n \n       /* Check result for validity after substitution.  */\n-      if (strict_memory_address_p (mode, ad))\n+      if (strict_memory_address_addr_space_p (mode, ad, as))\n \treturn 0;\n     }\n \n #ifdef LEGITIMIZE_RELOAD_ADDRESS\n   do\n     {\n-      if (memrefloc)\n+      if (memrefloc && ADDR_SPACE_GENERIC_P (as))\n \t{\n \t  LEGITIMIZE_RELOAD_ADDRESS (ad, GET_MODE (*memrefloc), opnum, type,\n \t\t\t\t     ind_levels, win);\n@@ -5160,8 +5174,8 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t   || operand == arg_pointer_rtx\n #endif\n \t   || operand == stack_pointer_rtx)\n-\t  && ! maybe_memory_address_p (mode, ad, \n-\t\t\t\t       &XEXP (XEXP (ad, 0), 1 - op_index)))\n+\t  && ! maybe_memory_address_addr_space_p\n+\t\t(mode, ad, as, &XEXP (XEXP (ad, 0), 1 - op_index)))\n \t{\n \t  rtx offset_reg;\n \t  enum reg_class cls;\n@@ -5199,7 +5213,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n   tem = ad;\n   if (GET_CODE (ad) == PLUS)\n     tem = subst_indexed_address (ad);\n-  if (tem != ad && strict_memory_address_p (mode, tem))\n+  if (tem != ad && strict_memory_address_addr_space_p (mode, tem, as))\n     {\n       /* Ok, we win that way.  Replace any additional eliminable\n \t registers.  */\n@@ -5209,7 +5223,8 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \n       /* Make sure that didn't make the address invalid again.  */\n \n-      if (! subst_reg_equivs_changed || strict_memory_address_p (mode, tem))\n+      if (! subst_reg_equivs_changed\n+\t  || strict_memory_address_addr_space_p (mode, tem, as))\n \t{\n \t  *loc = tem;\n \t  return 0;\n@@ -5218,7 +5233,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \n   /* If constants aren't valid addresses, reload the constant address\n      into a register.  */\n-  if (CONSTANT_P (ad) && ! strict_memory_address_p (mode, ad))\n+  if (CONSTANT_P (ad) && ! strict_memory_address_addr_space_p (mode, ad, as))\n     {\n       /* If AD is an address in the constant pool, the MEM rtx may be shared.\n \t Unshare it so we can safely alter it.  */\n@@ -6180,8 +6195,9 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t\t the address, there is nothing further to do.  */\n \t      if (reloaded == 0\n \t\t  && reg_equiv_mem[regno] != 0\n-\t\t  && !strict_memory_address_p (GET_MODE (x),\n-\t\t\t\t\t       XEXP (reg_equiv_mem[regno], 0)))\n+\t\t  && !strict_memory_address_addr_space_p\n+\t\t\t(GET_MODE (x), XEXP (reg_equiv_mem[regno], 0),\n+\t\t\t MEM_ADDR_SPACE (reg_equiv_mem[regno])))\n \t\tpush_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,\n \t\t\t     base_reg_class (GET_MODE (tem), MEM, SCRATCH),\n \t\t\t     GET_MODE (XEXP (tem, 0)), VOIDmode, 0, 0,"}, {"sha": "2c881e4d4f0e20ea9ffcc2cb4a00709f8c8aed74", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -1000,8 +1000,9 @@ reload (rtx first, int global)\n \t    rtx x = eliminate_regs (reg_equiv_memory_loc[i], VOIDmode,\n \t\t\t\t    NULL_RTX);\n \n-\t    if (strict_memory_address_p (GET_MODE (regno_reg_rtx[i]),\n-\t\t\t\t\t XEXP (x, 0)))\n+\t    if (strict_memory_address_addr_space_p\n+\t\t  (GET_MODE (regno_reg_rtx[i]), XEXP (x, 0),\n+\t\t   MEM_ADDR_SPACE (x)))\n \t      reg_equiv_mem[i] = x, reg_equiv_address[i] = 0;\n \t    else if (CONSTANT_P (XEXP (x, 0))\n \t\t     || (REG_P (XEXP (x, 0))"}, {"sha": "58867aec7ccfb4d6d3cb0c1b0327702e8c54dc85", "filename": "gcc/rtl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -385,6 +385,10 @@ rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n+  /* MEMs refering to different address space are not equivalent.  */\n+  if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))\n+    return 0;\n+\n   /* Some RTL can be compared nonrecursively.  */\n   switch (code)\n     {\n@@ -501,6 +505,10 @@ rtx_equal_p (const_rtx x, const_rtx y)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n+  /* MEMs refering to different address space are not equivalent.  */\n+  if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))\n+    return 0;\n+\n   /* Some RTL can be compared nonrecursively.  */\n   switch (code)\n     {"}, {"sha": "e9536b54536f10b974eea0f4bad7970334e65125", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -146,6 +146,7 @@ typedef struct GTY(()) mem_attrs\n   rtx size;\t\t\t/* Size in bytes, as a CONST_INT.  */\n   alias_set_type alias;\t\t/* Memory alias set.  */\n   unsigned int align;\t\t/* Alignment of MEM in bits.  */\n+  unsigned char addrspace;\t/* Address space (0 for generic).  */\n } mem_attrs;\n \n /* Structure used to describe the attributes of a REG in similar way as\n@@ -1122,7 +1123,7 @@ rhs_regno (const_rtx x)\n \n extern void init_rtlanal (void);\n extern int rtx_cost (rtx, enum rtx_code, bool);\n-extern int address_cost (rtx, enum machine_mode, bool);\n+extern int address_cost (rtx, enum machine_mode, addr_space_t, bool);\n extern unsigned int subreg_lsb (const_rtx);\n extern unsigned int subreg_lsb_1 (enum machine_mode, enum machine_mode,\n \t\t\t\t  unsigned int);\n@@ -1269,6 +1270,10 @@ do {\t\t\t\t\t\t\\\n    RTX that is always a CONST_INT.  */\n #define MEM_OFFSET(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->offset)\n \n+/* For a MEM rtx, the address space.  */\n+#define MEM_ADDR_SPACE(RTX) (MEM_ATTRS (RTX) == 0 ? ADDR_SPACE_GENERIC \\\n+\t\t\t\t\t\t  : MEM_ATTRS (RTX)->addrspace)\n+\n /* For a MEM rtx, the size in bytes of the MEM, if known, as an RTX that\n    is always a CONST_INT.  */\n #define MEM_SIZE(RTX)\t\t\t\t\t\t\t\\"}, {"sha": "7da04f2835ad0dc4db17e09f660aa27ce2eb4fd1", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -3603,13 +3603,13 @@ rtx_cost (rtx x, enum rtx_code outer_code ATTRIBUTE_UNUSED, bool speed)\n    be returned.  */\n \n int\n-address_cost (rtx x, enum machine_mode mode, bool speed)\n+address_cost (rtx x, enum machine_mode mode, addr_space_t as, bool speed)\n {\n   /* We may be asked for cost of various unusual addresses, such as operands\n      of push instruction.  It is not worthwhile to complicate writing\n      of the target hook by such cases.  */\n \n-  if (!memory_address_p (mode, x))\n+  if (!memory_address_addr_space_p (mode, x, as))\n     return 1000;\n \n   return targetm.address_cost (x, speed);"}, {"sha": "a64c0674dc8d106bcb527feb5b5e306d20f8fd62", "filename": "gcc/rtlhooks.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frtlhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Frtlhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -153,7 +153,8 @@ gen_lowpart_if_possible (enum machine_mode mode, rtx x)\n \t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n \n       new_rtx = adjust_address_nv (x, mode, offset);\n-      if (! memory_address_p (mode, XEXP (new_rtx, 0)))\n+      if (! memory_address_addr_space_p (mode, XEXP (new_rtx, 0),\n+\t\t\t\t\t MEM_ADDR_SPACE (x)))\n \treturn 0;\n \n       return new_rtx;"}, {"sha": "fae4210c2736dc42c528e03a53d4a3c4bce0b211", "filename": "gcc/target-def.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -471,6 +471,32 @@\n #define TARGET_VALID_POINTER_MODE default_valid_pointer_mode\n #endif\n \n+#ifndef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \\\n+  default_addr_space_legitimate_address_p\n+#endif\n+\n+#ifndef TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS\n+#define TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS \\\n+  default_addr_space_legitimize_address\n+#endif\n+\n+#ifndef TARGET_ADDR_SPACE_SUBSET_P\n+#define TARGET_ADDR_SPACE_SUBSET_P default_addr_space_subset_p\n+#endif\n+\n+#ifndef TARGET_ADDR_SPACE_CONVERT\n+#define TARGET_ADDR_SPACE_CONVERT default_addr_space_convert\n+#endif\n+\n+#define TARGET_ADDR_SPACE_HOOKS\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P,\t\\\n+    TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS,\t\\\n+    TARGET_ADDR_SPACE_SUBSET_P,\t\t\t\\\n+    TARGET_ADDR_SPACE_CONVERT,\t\t\t\\\n+  }\n+\n #ifndef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P default_scalar_mode_supported_p\n #endif\n@@ -913,6 +939,7 @@\n   TARGET_MIN_DIVISIONS_FOR_RECIP_MUL,\t\t\\\n   TARGET_MODE_REP_EXTENDED,\t\t\t\\\n   TARGET_VALID_POINTER_MODE,                    \\\n+  TARGET_ADDR_SPACE_HOOKS,\t\t\t\\\n   TARGET_SCALAR_MODE_SUPPORTED_P,\t\t\\\n   TARGET_VECTOR_MODE_SUPPORTED_P,               \\\n   TARGET_RTX_COSTS,\t\t\t\t\\"}, {"sha": "5b296d5df310eda2cd0ec4d3f19426a1a6ed49eb", "filename": "gcc/target.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -694,6 +694,26 @@ struct gcc_target\n   /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n   bool (* valid_pointer_mode) (enum machine_mode mode);\n \n+  /* Support for named address spaces.  */\n+  struct addr_space {\n+    /* True if an address is a valid memory address to a given named address\n+       space for a given mode.  */\n+    bool (* legitimate_address_p) (enum machine_mode, rtx, bool, addr_space_t);\n+\n+    /* Return an updated address to convert an invalid pointer to a named\n+       address space to a valid one.  If NULL_RTX is returned use machine\n+       independent methods to make the address valid.  */\n+    rtx (* legitimize_address) (rtx, rtx, enum machine_mode, addr_space_t);\n+\n+    /* True if one named address space is a subset of another named address. */\n+    bool (* subset_p) (addr_space_t, addr_space_t);\n+\n+    /* Function to convert an rtl expression from one address space to\n+       another.  */\n+    rtx (* convert) (rtx, tree, tree);\n+\n+  } addr_space;\n+\n   /* True if MODE is valid for the target.  By \"valid\", we mean able to\n      be manipulated in non-trivial ways.  In particular, this means all\n      the arithmetic is supported.  */"}, {"sha": "ab9c05bb0297538cca1248bb38b9068cddd1becb", "filename": "gcc/targhooks.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -831,6 +831,51 @@ default_builtin_support_vector_misalignment (enum machine_mode mode,\n   return false;\n }\n \n+/* Named address space version of legitimate_address_p.  */\n+\n+bool\n+default_addr_space_legitimate_address_p (enum machine_mode mode, rtx mem,\n+\t\t\t\t\t bool strict, addr_space_t as)\n+{\n+  if (!ADDR_SPACE_GENERIC_P (as))\n+    gcc_unreachable ();\n+\n+  return targetm.legitimate_address_p (mode, mem, strict);\n+}\n+\n+/* Named address space version of LEGITIMIZE_ADDRESS.  */\n+\n+rtx\n+default_addr_space_legitimize_address (rtx x, rtx oldx,\n+\t\t\t\t       enum machine_mode mode, addr_space_t as)\n+{\n+  if (!ADDR_SPACE_GENERIC_P (as))\n+    return x;\n+\n+  return targetm.legitimize_address (x, oldx, mode);\n+}\n+\n+/* The default hook for determining if one named address space is a subset of\n+   another and to return which address space to use as the common address\n+   space.  */\n+\n+bool\n+default_addr_space_subset_p (addr_space_t subset, addr_space_t superset)\n+{\n+  return (subset == superset);\n+}\n+\n+/* The default hook for TARGET_ADDR_SPACE_CONVERT. This hook should never be\n+   called for targets with only a generic address space.  */\n+\n+rtx\n+default_addr_space_convert (rtx op ATTRIBUTE_UNUSED,\n+\t\t\t    tree from_type ATTRIBUTE_UNUSED,\n+\t\t\t    tree to_type ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n bool\n default_hard_regno_scratch_ok (unsigned int regno ATTRIBUTE_UNUSED)\n {"}, {"sha": "eedc52b0ae795106459f6e20b44786ca6c0c7457", "filename": "gcc/targhooks.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -119,4 +119,10 @@ extern bool default_hard_regno_scratch_ok (unsigned int);\n extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);\n extern bool default_target_option_pragma_parse (tree, tree);\n extern bool default_target_can_inline_p (tree, tree);\n+extern bool default_addr_space_legitimate_address_p (enum machine_mode, rtx,\n+\t\t\t\t\t\t     bool, addr_space_t);\n+extern rtx default_addr_space_legitimize_address (rtx, rtx, enum machine_mode,\n+\t\t\t\t\t\t  addr_space_t);\n+extern bool default_addr_space_subset_p (addr_space_t, addr_space_t);\n+extern rtx default_addr_space_convert (rtx, tree, tree);\n extern unsigned int default_case_values_threshold (void);"}, {"sha": "97b08924ff7822725f896925f64983ee65816ab7", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -3107,6 +3107,21 @@ verify_gimple_assign_unary (gimple stmt)\n \treturn false;\n       }\n \n+    case ADDR_SPACE_CONVERT_EXPR:\n+      {\n+\tif (!POINTER_TYPE_P (rhs1_type) || !POINTER_TYPE_P (lhs_type)\n+\t    || (TYPE_ADDR_SPACE (TREE_TYPE (rhs1_type))\n+\t\t== TYPE_ADDR_SPACE (TREE_TYPE (lhs_type))))\n+\t  {\n+\t    error (\"invalid types in address space conversion\");\n+\t    debug_generic_expr (lhs_type);\n+\t    debug_generic_expr (rhs1_type);\n+\t    return true;\n+\t  }\n+\n+\treturn false;\n+      }\n+\n     case FIXED_CONVERT_EXPR:\n       {\n \tif (!valid_fixed_convert_types_p (lhs_type, rhs1_type)"}, {"sha": "ca1e06a0b62845503190e57949c2360cf81c4d5b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -890,7 +890,8 @@ extern void tree_check_data_deps (void);\n /* In tree-ssa-loop-ivopts.c  */\n bool expr_invariant_in_loop_p (struct loop *, tree);\n bool stmt_invariant_in_loop_p (struct loop *, gimple);\n-bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode);\n+bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode,\n+\t\t\t\t      addr_space_t);\n unsigned multiply_by_cost (HOST_WIDE_INT, enum machine_mode, bool);\n \n /* In tree-ssa-threadupdate.c.  */"}, {"sha": "f0ed4ba73a72067aaf73322afa00dd18cea4e05b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -3083,6 +3083,7 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n     case MINUS_EXPR:\n     case MULT_EXPR:\n \n+    case ADDR_SPACE_CONVERT_EXPR:\n     case FIXED_CONVERT_EXPR:\n     case FIX_TRUNC_EXPR:\n "}, {"sha": "7173ad2331be48a5eda70ed8e4a5e498f9525027", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -657,6 +657,13 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \telse if (quals & TYPE_QUAL_RESTRICT)\n \t  pp_string (buffer, \"restrict \");\n \n+\tif (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (node)))\n+\t  {\n+\t    pp_string (buffer, \"<address-space-\");\n+\t    pp_decimal_int (buffer, TYPE_ADDR_SPACE (node));\n+\t    pp_string (buffer, \"> \");\n+\t  }\n+\n \ttclass = TREE_CODE_CLASS (TREE_CODE (node));\n \n \tif (tclass == tcc_declaration)\n@@ -755,6 +762,13 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t  if (quals & TYPE_QUAL_RESTRICT)\n \t    pp_string (buffer, \" restrict\");\n \n+\t  if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (node)))\n+\t    {\n+\t      pp_string (buffer, \" <address-space-\");\n+\t      pp_decimal_int (buffer, TYPE_ADDR_SPACE (node));\n+\t      pp_string (buffer, \">\");\n+\t    }\n+\n \t  if (TYPE_REF_CAN_ALIAS_ALL (node))\n \t    pp_string (buffer, \" {ref-all}\");\n \t}\n@@ -1550,6 +1564,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       NIY;\n       break;\n \n+    case ADDR_SPACE_CONVERT_EXPR:\n     case FIXED_CONVERT_EXPR:\n     case FIX_TRUNC_EXPR:\n     case FLOAT_EXPR:"}, {"sha": "c5e34229bf6b6123bb8219063314c530ffcfac3f", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -305,15 +305,16 @@ tree_mem_ref_addr (tree type, tree mem_ref)\n    ADDR is valid on the current target.  */\n \n static bool\n-valid_mem_ref_p (enum machine_mode mode, struct mem_address *addr)\n+valid_mem_ref_p (enum machine_mode mode, addr_space_t as,\n+\t\t struct mem_address *addr)\n {\n   rtx address;\n \n   address = addr_for_mem_ref (addr, false);\n   if (!address)\n     return false;\n \n-  return memory_address_p (mode, address);\n+  return memory_address_addr_space_p (mode, address, as);\n }\n \n /* Checks whether a TARGET_MEM_REF with type TYPE and parameters given by ADDR\n@@ -323,7 +324,7 @@ valid_mem_ref_p (enum machine_mode mode, struct mem_address *addr)\n static tree\n create_mem_ref_raw (tree type, struct mem_address *addr)\n {\n-  if (!valid_mem_ref_p (TYPE_MODE (type), addr))\n+  if (!valid_mem_ref_p (TYPE_MODE (type), TYPE_ADDR_SPACE (type), addr))\n     return NULL_TREE;\n \n   if (addr->step && integer_onep (addr->step))\n@@ -456,7 +457,8 @@ most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr,\n \n       coef = double_int_to_shwi (addr->elts[i].coef);\n       if (coef == 1\n-\t  || !multiplier_allowed_in_address_p (coef, Pmode))\n+\t  || !multiplier_allowed_in_address_p (coef, Pmode,\n+\t\t\t\t\t       ADDR_SPACE_GENERIC))\n \tcontinue;\n \n       acost = multiply_by_cost (coef, Pmode, speed);"}, {"sha": "7e536136c806f56852152748b9e2fc0d570181e9", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 93, "deletions": 53, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -2642,6 +2642,7 @@ seq_cost (rtx seq, bool speed)\n static rtx\n produce_memory_decl_rtl (tree obj, int *regno)\n {\n+  addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (obj));\n   rtx x;\n   \n   gcc_assert (obj);\n@@ -2651,12 +2652,14 @@ produce_memory_decl_rtl (tree obj, int *regno)\n       x = gen_rtx_SYMBOL_REF (Pmode, name);\n       SET_SYMBOL_REF_DECL (x, obj);\n       x = gen_rtx_MEM (DECL_MODE (obj), x);\n+      set_mem_addr_space (x, as);\n       targetm.encode_section_info (obj, x, true);\n     }\n   else\n     {\n       x = gen_raw_REG (Pmode, (*regno)++);\n       x = gen_rtx_MEM (DECL_MODE (obj), x);\n+      set_mem_addr_space (x, as);\n     }\n \n   return x;\n@@ -2744,7 +2747,8 @@ computation_cost (tree expr, bool speed)\n \n   cost = seq_cost (seq, speed);\n   if (MEM_P (rslt))\n-    cost += address_cost (XEXP (rslt, 0), TYPE_MODE (type), speed);\n+    cost += address_cost (XEXP (rslt, 0), TYPE_MODE (type),\n+\t\t\t  TYPE_ADDR_SPACE (type), speed);\n \n   return cost;\n }\n@@ -3020,51 +3024,64 @@ multiply_by_cost (HOST_WIDE_INT cst, enum machine_mode mode, bool speed)\n }\n \n /* Returns true if multiplying by RATIO is allowed in an address.  Test the\n-   validity for a memory reference accessing memory of mode MODE.  */\n+   validity for a memory reference accessing memory of mode MODE in\n+   address space AS.  */\n+\n+DEF_VEC_P (sbitmap);\n+DEF_VEC_ALLOC_P (sbitmap, heap);\n \n bool\n-multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode)\n+multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode,\n+\t\t\t\t addr_space_t as)\n {\n #define MAX_RATIO 128\n-  static sbitmap valid_mult[MAX_MACHINE_MODE];\n-  \n-  if (!valid_mult[mode])\n+  unsigned int data_index = (int) as * MAX_MACHINE_MODE + (int) mode;\n+  static VEC (sbitmap, heap) *valid_mult_list;\n+  sbitmap valid_mult;\n+\n+  if (data_index >= VEC_length (sbitmap, valid_mult_list))\n+    VEC_safe_grow_cleared (sbitmap, heap, valid_mult_list, data_index + 1);\n+\n+  valid_mult = VEC_index (sbitmap, valid_mult_list, data_index);\n+  if (!valid_mult)\n     {\n       rtx reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n       rtx addr;\n       HOST_WIDE_INT i;\n \n-      valid_mult[mode] = sbitmap_alloc (2 * MAX_RATIO + 1);\n-      sbitmap_zero (valid_mult[mode]);\n+      valid_mult = sbitmap_alloc (2 * MAX_RATIO + 1);\n+      sbitmap_zero (valid_mult);\n       addr = gen_rtx_fmt_ee (MULT, Pmode, reg1, NULL_RTX);\n       for (i = -MAX_RATIO; i <= MAX_RATIO; i++)\n \t{\n \t  XEXP (addr, 1) = gen_int_mode (i, Pmode);\n-\t  if (memory_address_p (mode, addr))\n-\t    SET_BIT (valid_mult[mode], i + MAX_RATIO);\n+\t  if (memory_address_addr_space_p (mode, addr, as))\n+\t    SET_BIT (valid_mult, i + MAX_RATIO);\n \t}\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"  allowed multipliers:\");\n \t  for (i = -MAX_RATIO; i <= MAX_RATIO; i++)\n-\t    if (TEST_BIT (valid_mult[mode], i + MAX_RATIO))\n+\t    if (TEST_BIT (valid_mult, i + MAX_RATIO))\n \t      fprintf (dump_file, \" %d\", (int) i);\n \t  fprintf (dump_file, \"\\n\");\n \t  fprintf (dump_file, \"\\n\");\n \t}\n+\n+      VEC_replace (sbitmap, valid_mult_list, data_index, valid_mult);\n     }\n \n   if (ratio > MAX_RATIO || ratio < -MAX_RATIO)\n     return false;\n \n-  return TEST_BIT (valid_mult[mode], ratio + MAX_RATIO);\n+  return TEST_BIT (valid_mult, ratio + MAX_RATIO);\n }\n \n /* Returns cost of address in shape symbol + var + OFFSET + RATIO * index.\n    If SYMBOL_PRESENT is false, symbol is omitted.  If VAR_PRESENT is false,\n    variable is omitted.  Compute the cost for a memory reference that accesses\n-   a memory location of mode MEM_MODE.\n+   a memory location of mode MEM_MODE in address space AS.\n \n    MAY_AUTOINC is set to true if the autoincrement (increasing index by\n    size of MEM_MODE / RATIO) is available.  To make this determination, we\n@@ -3075,16 +3092,25 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode)\n \n    TODO -- there must be some better way.  This all is quite crude.  */\n \n+typedef struct\n+{\n+  HOST_WIDE_INT min_offset, max_offset;\n+  unsigned costs[2][2][2][2];\n+} *address_cost_data;\n+\n+DEF_VEC_P (address_cost_data);\n+DEF_VEC_ALLOC_P (address_cost_data, heap);\n+\n static comp_cost\n get_address_cost (bool symbol_present, bool var_present,\n \t\t  unsigned HOST_WIDE_INT offset, HOST_WIDE_INT ratio,\n-\t\t  HOST_WIDE_INT cstep, enum machine_mode mem_mode, bool speed,\n+\t\t  HOST_WIDE_INT cstep, enum machine_mode mem_mode,\n+\t\t  addr_space_t as, bool speed,\n \t\t  bool stmt_after_inc, bool *may_autoinc)\n {\n-  static bool initialized[MAX_MACHINE_MODE];\n-  static HOST_WIDE_INT rat[MAX_MACHINE_MODE], off[MAX_MACHINE_MODE];\n-  static HOST_WIDE_INT min_offset[MAX_MACHINE_MODE], max_offset[MAX_MACHINE_MODE];\n-  static unsigned costs[MAX_MACHINE_MODE][2][2][2][2];\n+  static VEC(address_cost_data, heap) *address_cost_data_list;\n+  unsigned int data_index = (int) as * MAX_MACHINE_MODE + (int) mem_mode;\n+  address_cost_data data;\n   static bool has_preinc[MAX_MACHINE_MODE], has_postinc[MAX_MACHINE_MODE];\n   static bool has_predec[MAX_MACHINE_MODE], has_postdec[MAX_MACHINE_MODE];\n   unsigned cost, acost, complexity;\n@@ -3093,53 +3119,59 @@ get_address_cost (bool symbol_present, bool var_present,\n   unsigned HOST_WIDE_INT mask;\n   unsigned bits;\n \n-  if (!initialized[mem_mode])\n+  if (data_index >= VEC_length (address_cost_data, address_cost_data_list))\n+    VEC_safe_grow_cleared (address_cost_data, heap, address_cost_data_list,\n+\t\t\t   data_index + 1);\n+\n+  data = VEC_index (address_cost_data, address_cost_data_list, data_index);\n+  if (!data)\n     {\n       HOST_WIDE_INT i;\n       HOST_WIDE_INT start = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n+      HOST_WIDE_INT rat, off;\n       int old_cse_not_expected;\n       unsigned sym_p, var_p, off_p, rat_p, add_c;\n       rtx seq, addr, base;\n       rtx reg0, reg1;\n \n-      initialized[mem_mode] = true;\n+      data = (address_cost_data) xcalloc (1, sizeof (*data));\n \n       reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n \n       addr = gen_rtx_fmt_ee (PLUS, Pmode, reg1, NULL_RTX);\n       for (i = start; i <= 1 << 20; i <<= 1)\n \t{\n \t  XEXP (addr, 1) = gen_int_mode (i, Pmode);\n-\t  if (!memory_address_p (mem_mode, addr))\n+\t  if (!memory_address_addr_space_p (mem_mode, addr, as))\n \t    break;\n \t}\n-      max_offset[mem_mode] = i == start ? 0 : i >> 1;\n-      off[mem_mode] = max_offset[mem_mode];\n+      data->max_offset = i == start ? 0 : i >> 1;\n+      off = data->max_offset;\n \n       for (i = start; i <= 1 << 20; i <<= 1)\n \t{\n \t  XEXP (addr, 1) = gen_int_mode (-i, Pmode);\n-\t  if (!memory_address_p (mem_mode, addr))\n+\t  if (!memory_address_addr_space_p (mem_mode, addr, as))\n \t    break;\n \t}\n-      min_offset[mem_mode] = i == start ? 0 : -(i >> 1);\n+      data->min_offset = i == start ? 0 : -(i >> 1);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"get_address_cost:\\n\");\n \t  fprintf (dump_file, \"  min offset %s %d\\n\",\n \t\t   GET_MODE_NAME (mem_mode),\n-\t\t   (int) min_offset[mem_mode]);\n+\t\t   (int) data->min_offset);\n \t  fprintf (dump_file, \"  max offset %s %d\\n\",\n \t\t   GET_MODE_NAME (mem_mode),\n-\t\t   (int) max_offset[mem_mode]);\n+\t\t   (int) data->max_offset);\n \t}\n \n-      rat[mem_mode] = 1;\n+      rat = 1;\n       for (i = 2; i <= MAX_RATIO; i++)\n-\tif (multiplier_allowed_in_address_p (i, mem_mode))\n+\tif (multiplier_allowed_in_address_p (i, mem_mode, as))\n \t  {\n-\t    rat[mem_mode] = i;\n+\t    rat = i;\n \t    break;\n \t  }\n \n@@ -3151,22 +3183,26 @@ get_address_cost (bool symbol_present, bool var_present,\n       if (HAVE_PRE_DECREMENT)\n \t{\n \t  addr = gen_rtx_PRE_DEC (Pmode, reg0);\n-\t  has_predec[mem_mode] = memory_address_p (mem_mode, addr);\n+\t  has_predec[mem_mode]\n+\t    = memory_address_addr_space_p (mem_mode, addr, as);\n \t}\n       if (HAVE_POST_DECREMENT)\n \t{\n \t  addr = gen_rtx_POST_DEC (Pmode, reg0);\n-\t  has_postdec[mem_mode] = memory_address_p (mem_mode, addr);\n+\t  has_postdec[mem_mode]\n+\t    = memory_address_addr_space_p (mem_mode, addr, as);\n \t}\n       if (HAVE_PRE_INCREMENT)\n \t{\n \t  addr = gen_rtx_PRE_INC (Pmode, reg0);\n-\t  has_preinc[mem_mode] = memory_address_p (mem_mode, addr);\n+\t  has_preinc[mem_mode]\n+\t    = memory_address_addr_space_p (mem_mode, addr, as);\n \t}\n       if (HAVE_POST_INCREMENT)\n \t{\n \t  addr = gen_rtx_POST_INC (Pmode, reg0);\n-\t  has_postinc[mem_mode] = memory_address_p (mem_mode, addr);\n+\t  has_postinc[mem_mode]\n+\t    = memory_address_addr_space_p (mem_mode, addr, as);\n \t}\n       for (i = 0; i < 16; i++)\n \t{\n@@ -3178,7 +3214,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t  addr = reg0;\n \t  if (rat_p)\n \t    addr = gen_rtx_fmt_ee (MULT, Pmode, addr,\n-\t\t\t\t   gen_int_mode (rat[mem_mode], Pmode));\n+\t\t\t\t   gen_int_mode (rat, Pmode));\n \n \t  if (var_p)\n \t    addr = gen_rtx_fmt_ee (PLUS, Pmode, addr, reg1);\n@@ -3194,13 +3230,12 @@ get_address_cost (bool symbol_present, bool var_present,\n \n \t      if (off_p)\n \t\tbase = gen_rtx_fmt_e (CONST, Pmode,\n-\t\t\t\t      gen_rtx_fmt_ee (PLUS, Pmode,\n-\t\t\t\t\t\t      base,\n-\t\t\t\t\t\t      gen_int_mode (off[mem_mode],\n-\t\t\t\t\t\t\t\t    Pmode)));\n+\t\t\t\t      gen_rtx_fmt_ee\n+\t\t\t\t\t(PLUS, Pmode, base,\n+\t\t\t\t\t gen_int_mode (off, Pmode)));\n \t    }\n \t  else if (off_p)\n-\t    base = gen_int_mode (off[mem_mode], Pmode);\n+\t    base = gen_int_mode (off, Pmode);\n \t  else\n \t    base = NULL_RTX;\n     \n@@ -3212,17 +3247,17 @@ get_address_cost (bool symbol_present, bool var_present,\n \t     follow.  */\n \t  old_cse_not_expected = cse_not_expected;\n \t  cse_not_expected = true;\n-\t  addr = memory_address (mem_mode, addr);\n+\t  addr = memory_address_addr_space (mem_mode, addr, as);\n \t  cse_not_expected = old_cse_not_expected;\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n \t  acost = seq_cost (seq, speed);\n-\t  acost += address_cost (addr, mem_mode, speed);\n+\t  acost += address_cost (addr, mem_mode, as, speed);\n \n \t  if (!acost)\n \t    acost = 1;\n-\t  costs[mem_mode][sym_p][var_p][off_p][rat_p] = acost;\n+\t  data->costs[sym_p][var_p][off_p][rat_p] = acost;\n \t}\n \n       /* On some targets, it is quite expensive to load symbol to a register,\n@@ -3244,12 +3279,12 @@ get_address_cost (bool symbol_present, bool var_present,\n \t  off_p = (i >> 1) & 1;\n \t  rat_p = (i >> 2) & 1;\n \n-\t  acost = costs[mem_mode][0][1][off_p][rat_p] + 1;\n+\t  acost = data->costs[0][1][off_p][rat_p] + 1;\n \t  if (var_p)\n \t    acost += add_c;\n \n-\t  if (acost < costs[mem_mode][1][var_p][off_p][rat_p])\n-\t    costs[mem_mode][1][var_p][off_p][rat_p] = acost;\n+\t  if (acost < data->costs[1][var_p][off_p][rat_p])\n+\t    data->costs[1][var_p][off_p][rat_p] = acost;\n \t}\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3273,14 +3308,17 @@ get_address_cost (bool symbol_present, bool var_present,\n \t      if (rat_p)\n \t\tfprintf (dump_file, \"rat * \");\n \n-\t      acost = costs[mem_mode][sym_p][var_p][off_p][rat_p];\n+\t      acost = data->costs[sym_p][var_p][off_p][rat_p];\n \t      fprintf (dump_file, \"index costs %d\\n\", acost);\n \t    }\n \t  if (has_predec[mem_mode] || has_postdec[mem_mode]\n \t      || has_preinc[mem_mode] || has_postinc[mem_mode])\n \t    fprintf (dump_file, \"  May include autoinc/dec\\n\");\n \t  fprintf (dump_file, \"\\n\");\n \t}\n+\n+      VEC_replace (address_cost_data, address_cost_data_list,\n+\t\t   data_index, data);\n     }\n \n   bits = GET_MODE_BITSIZE (Pmode);\n@@ -3309,10 +3347,10 @@ get_address_cost (bool symbol_present, bool var_present,\n \n   cost = 0;\n   offset_p = (s_offset != 0\n-\t      && min_offset[mem_mode] <= s_offset\n-\t      && s_offset <= max_offset[mem_mode]);\n+\t      && data->min_offset <= s_offset\n+\t      && s_offset <= data->max_offset);\n   ratio_p = (ratio != 1\n-\t     && multiplier_allowed_in_address_p (ratio, mem_mode));\n+\t     && multiplier_allowed_in_address_p (ratio, mem_mode, as));\n \n   if (ratio != 1 && !ratio_p)\n     cost += multiply_by_cost (ratio, Pmode, speed);\n@@ -3322,7 +3360,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \n   if (may_autoinc)\n     *may_autoinc = autoinc;\n-  acost = costs[mem_mode][symbol_present][var_present][offset_p][ratio_p];\n+  acost = data->costs[symbol_present][var_present][offset_p][ratio_p];\n   complexity = (symbol_present != 0) + (var_present != 0) + offset_p + ratio_p;\n   return new_cost (cost + acost, complexity);\n }\n@@ -3742,8 +3780,9 @@ get_computation_cost_at (struct ivopts_data *data,\n     }\n   else if (address_p\n \t   && !POINTER_TYPE_P (ctype)\n-\t   && multiplier_allowed_in_address_p (ratio,\n-\t\t\t\t\t       TYPE_MODE (TREE_TYPE (utype))))\n+\t   && multiplier_allowed_in_address_p\n+\t\t(ratio, TYPE_MODE (TREE_TYPE (utype)),\n+\t\t\tTYPE_ADDR_SPACE (TREE_TYPE (utype))))\n     {\n       cbase\n \t= fold_build2 (MULT_EXPR, ctype, cbase, build_int_cst (ctype, ratio));\n@@ -3777,6 +3816,7 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t      get_address_cost (symbol_present, var_present,\n \t\t\t\t\toffset, ratio, cstepi,\n \t\t\t\t\tTYPE_MODE (TREE_TYPE (utype)),\n+\t\t\t\t\tTYPE_ADDR_SPACE (TREE_TYPE (utype)),\n \t\t\t\t\tspeed, stmt_is_after_inc,\n \t\t\t\t\tcan_autoinc));\n "}, {"sha": "b646ded59e77eae1b0e4a3bd6c645750e28114a6", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -1192,6 +1192,11 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n   if (POINTER_TYPE_P (inner_type)\n       && POINTER_TYPE_P (outer_type))\n     {\n+      /* Do not lose casts between pointers to different address spaces.  */\n+      if (TYPE_ADDR_SPACE (TREE_TYPE (outer_type))\n+\t  != TYPE_ADDR_SPACE (TREE_TYPE (inner_type)))\n+\treturn false;\n+\n       /* If the outer type is (void *) or a pointer to an incomplete\n \t record type or a pointer to an unprototyped function,\n \t then the conversion is not necessary.  */"}, {"sha": "dfc88077e96211ccf622384218e8f81051e5770d", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -5424,6 +5424,7 @@ set_type_quals (tree type, int type_quals)\n   TYPE_READONLY (type) = (type_quals & TYPE_QUAL_CONST) != 0;\n   TYPE_VOLATILE (type) = (type_quals & TYPE_QUAL_VOLATILE) != 0;\n   TYPE_RESTRICT (type) = (type_quals & TYPE_QUAL_RESTRICT) != 0;\n+  TYPE_ADDR_SPACE (type) = DECODE_QUAL_ADDR_SPACE (type_quals);\n }\n \n /* Returns true iff CAND is equivalent to BASE with TYPE_QUALS.  */\n@@ -7003,6 +7004,7 @@ build_array_type (tree elt_type, tree index_type)\n   t = make_node (ARRAY_TYPE);\n   TREE_TYPE (t) = elt_type;\n   TYPE_DOMAIN (t) = index_type;\n+  TYPE_ADDR_SPACE (t) = TYPE_ADDR_SPACE (elt_type);\n   layout_type (t);\n \n   /* If the element type is incomplete at this point we get marked for"}, {"sha": "74470b5783ad76eddc06aa7c30af45fe8c1ac3b1", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -752,6 +752,10 @@ DEFTREECODE (PAREN_EXPR, \"paren_expr\", tcc_unary, 1)\n    represented by CONVERT_EXPR or NOP_EXPR nodes.  */\n DEFTREECODE (CONVERT_EXPR, \"convert_expr\", tcc_unary, 1)\n \n+/* Conversion of a pointer value to a pointer to a different\n+   address space.  */\n+DEFTREECODE (ADDR_SPACE_CONVERT_EXPR, \"addr_space_convert_expr\", tcc_unary, 1)\n+\n /* Conversion of a fixed-point value to an integer, a real, or a fixed-point\n    value.  Or conversion of a fixed-point value from an integer, a real, or\n    a fixed-point value.  */"}, {"sha": "ad810b040c5853ffc65f381965cd9fbfc501cf39", "filename": "gcc/tree.h", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -392,7 +392,12 @@ struct GTY(()) tree_base {\n   unsigned packed_flag : 1;\n   unsigned user_align : 1;\n \n-  unsigned spare : 21;\n+  unsigned spare : 13;\n+\n+  /* This field is only used with type nodes; the only reason it is present\n+     in tree_base instead of tree_type is to save space.  The size of the\n+     field must be large enough to hold addr_space_t values.  */\n+  unsigned address_space : 8;\n \n   union tree_ann_d *ann;\n };\n@@ -2169,6 +2174,9 @@ extern enum machine_mode vector_type_mode (const_tree);\n    the term.  */\n #define TYPE_RESTRICT(NODE) (TYPE_CHECK (NODE)->type.restrict_flag)\n \n+/* The address space the type is in.  */\n+#define TYPE_ADDR_SPACE(NODE) (TYPE_CHECK (NODE)->base.address_space)\n+\n /* There is a TYPE_QUAL value for each type qualifier.  They can be\n    combined by bitwise-or to form the complete set of qualifiers for a\n    type.  */\n@@ -2178,8 +2186,27 @@ extern enum machine_mode vector_type_mode (const_tree);\n #define TYPE_QUAL_VOLATILE 0x2\n #define TYPE_QUAL_RESTRICT 0x4\n \n+/* Encode/decode the named memory support as part of the qualifier.  If more\n+   than 8 qualifiers are added, these macros need to be adjusted.  */\n+#define ENCODE_QUAL_ADDR_SPACE(NUM) ((NUM & 0xFF) << 8)\n+#define DECODE_QUAL_ADDR_SPACE(X) (((X) >> 8) & 0xFF)\n+\n+/* Return all qualifiers except for the address space qualifiers.  */\n+#define CLEAR_QUAL_ADDR_SPACE(X) ((X) & ~0xFF00)\n+\n+/* Only keep the address space out of the qualifiers and discard the other\n+   qualifiers.  */\n+#define KEEP_QUAL_ADDR_SPACE(X) ((X) & 0xFF00)\n+\n /* The set of type qualifiers for this type.  */\n #define TYPE_QUALS(NODE)\t\t\t\t\t\\\n+  ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\t\\\n+   | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)\t\t\\\n+   | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)\t\t\\\n+   | (ENCODE_QUAL_ADDR_SPACE (TYPE_ADDR_SPACE (NODE))))\n+\n+/* The same as TYPE_QUALS without the address space qualifications.  */\n+#define TYPE_QUALS_NO_ADDR_SPACE(NODE)\t\t\t\t\\\n   ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\t\\\n    | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)\t\t\\\n    | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT))"}, {"sha": "95239b2d43210d766afe252ecf4cfccc6dc6b631", "filename": "gcc/varasm.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e881c9e21a9209b2092e400ea4c38948614f78/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=09e881c9e21a9209b2092e400ea4c38948614f78", "patch": "@@ -1168,11 +1168,17 @@ align_variable (tree decl, bool dont_output_data)\n static section *\n get_variable_section (tree decl, bool prefer_noswitch_p)\n {\n+  addr_space_t as = ADDR_SPACE_GENERIC;\n   int reloc;\n \n-  /* If the decl has been given an explicit section name, then it\n-     isn't common, and shouldn't be handled as such.  */\n-  if (DECL_COMMON (decl) && DECL_SECTION_NAME (decl) == NULL)\n+  if (TREE_TYPE (decl) != error_mark_node)\n+    as = TYPE_ADDR_SPACE (TREE_TYPE (decl));\n+\n+  /* If the decl has been given an explicit section name, or it resides\n+     in a non-generic address space, then it isn't common, and shouldn't\n+     be handled as such.  */\n+  if (DECL_COMMON (decl) && DECL_SECTION_NAME (decl) == NULL\n+      && ADDR_SPACE_GENERIC_P (as))\n     {\n       if (DECL_THREAD_LOCAL_P (decl))\n \treturn tls_comm_section;\n@@ -1196,7 +1202,8 @@ get_variable_section (tree decl, bool prefer_noswitch_p)\n   if (IN_NAMED_SECTION (decl))\n     return get_named_section (decl, NULL, reloc);\n \n-  if (!DECL_THREAD_LOCAL_P (decl)\n+  if (ADDR_SPACE_GENERIC_P (as)\n+      && !DECL_THREAD_LOCAL_P (decl)\n       && !(prefer_noswitch_p && targetm.have_switchable_bss_sections)\n       && bss_initializer_p (decl))\n     {"}]}