{"sha": "3f267553fca2671ca4abb0dbbe3c9f625357edf0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YyNjc1NTNmY2EyNjcxY2E0YWJiMGRiYmUzYzlmNjI1MzU3ZWRmMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-16T14:46:30Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-16T14:46:30Z"}, "message": "cp-tree.h (class ovl_iterator, [...]): New OVERLOAD iterators.\n\n\t* cp-tree.h (class ovl_iterator, class lkp_iterator): New OVERLOAD\n\titerators.\n\t(MAYBE_BASELINK_FUNCTIONS): New.\n\t* constraint.cc\t(resolve_constraint_check): Use lkp_iterator.\n\t* decl2.c (maybe_warn_sized_delete): Use ovl_iterator.\n\t* lambda.c (maybe_generic_this_capture): Use lkp_iterator.\n\t* method.c (inherited_ctor_binfo): Use ovl_iterator.\n\t(binfo_inherited_from): Likewise.\n\t* parser.c (lookup_literal_operator): Use lkp_iterator.\n\t* pt.c (iterative_hash_template_arg): Use lkp_iterator.\n\t(print_candidates_1): Likewise.\n\t(determine_specialization): Likewise.\n\t(resolve_overloaded_unification): Likewise.\n\t(resolve_nondeduced_context): Likewise.\n\t(type_dependent_expression_p): Likewise.\n\t(dependent_template_p): Likewise.\n\t* ptree.c (cxx_print_xnode): Likewise.\n\t* semantics.c (omp_reduction_lookup): Use lkp_iterator.\n\t(classtype_has_nothrow_assign_or_copy_p): Use ovl_iterator.\n\t* typeck.c (check_template_keyword): Use lkp_iterator.\n\nFrom-SVN: r248112", "tree": {"sha": "75f1cd1884906c9e7903a3f2d97c780e17e2066f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75f1cd1884906c9e7903a3f2d97c780e17e2066f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f267553fca2671ca4abb0dbbe3c9f625357edf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f267553fca2671ca4abb0dbbe3c9f625357edf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f267553fca2671ca4abb0dbbe3c9f625357edf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f267553fca2671ca4abb0dbbe3c9f625357edf0/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "058c785479b1652ffd47d397a9693fe5e5fdea39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058c785479b1652ffd47d397a9693fe5e5fdea39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058c785479b1652ffd47d397a9693fe5e5fdea39"}], "stats": {"total": 262, "additions": 171, "deletions": 91}, "files": [{"sha": "4f7c8d412491e338c8d1251111ab9349facc1bb5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3f267553fca2671ca4abb0dbbe3c9f625357edf0", "patch": "@@ -1,5 +1,26 @@\n 2017-05-16  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (class ovl_iterator, class lkp_iterator): New OVERLOAD\n+\titerators.\n+\t(MAYBE_BASELINK_FUNCTIONS): New.\n+\t* constraint.cc\t(resolve_constraint_check): Use lkp_iterator.\n+\t* decl2.c (maybe_warn_sized_delete): Use ovl_iterator.\n+\t* lambda.c (maybe_generic_this_capture): Use lkp_iterator.\n+\t* method.c (inherited_ctor_binfo): Use ovl_iterator.\n+\t(binfo_inherited_from): Likewise.\n+\t* parser.c (lookup_literal_operator): Use lkp_iterator.\n+\t* pt.c (iterative_hash_template_arg): Use lkp_iterator.\n+\t(print_candidates_1): Likewise.\n+\t(determine_specialization): Likewise.\n+\t(resolve_overloaded_unification): Likewise.\n+\t(resolve_nondeduced_context): Likewise.\n+\t(type_dependent_expression_p): Likewise.\n+\t(dependent_template_p): Likewise.\n+\t* ptree.c (cxx_print_xnode): Likewise.\n+\t* semantics.c (omp_reduction_lookup): Use lkp_iterator.\n+\t(classtype_has_nothrow_assign_or_copy_p): Use ovl_iterator.\n+\t* typeck.c (check_template_keyword): Use lkp_iterator.\n+\n \t* cp-tree.h (OVL_FIRST, OVL_NAME): New.\n \t(ovl_first): New.\n \t* constexpr.c (function_concept_check): Use OVL_FIRST."}, {"sha": "e3b876278d40e94263c5d33d3621aad1d31b40fd", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=3f267553fca2671ca4abb0dbbe3c9f625357edf0", "patch": "@@ -204,10 +204,10 @@ resolve_constraint_check (tree ovl, tree args)\n {\n   int nerrs = 0;\n   tree cands = NULL_TREE;\n-  for (tree p = ovl; p != NULL_TREE; p = OVL_NEXT (p))\n+  for (lkp_iterator iter (ovl); iter; ++iter)\n     {\n       // Get the next template overload.\n-      tree tmpl = OVL_CURRENT (p);\n+      tree tmpl = *iter;\n       if (TREE_CODE (tmpl) != TEMPLATE_DECL)\n         continue;\n "}, {"sha": "b81e94ddf9acdac10ef1ba87bf30672382a0ee55", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3f267553fca2671ca4abb0dbbe3c9f625357edf0", "patch": "@@ -636,6 +636,62 @@ struct GTY(()) tree_overload {\n   tree function;\n };\n \n+/* Iterator for a 1 dimensional overload. */\n+\n+class ovl_iterator \n+{\n+  tree ovl;\n+\n+ public:\n+  ovl_iterator (tree o)\n+  :ovl (o)\n+    {}\n+\n+  ovl_iterator &operator= (const ovl_iterator &from)\n+  {\n+    ovl = from.ovl;\n+\n+    return *this;\n+  }\n+\n+ public:\n+  operator bool () const\n+  {\n+    return ovl;\n+  }\n+  ovl_iterator &operator++ ()\n+  {\n+    ovl = TREE_CODE (ovl) != OVERLOAD ? NULL_TREE : OVL_CHAIN (ovl);\n+    return *this;\n+  }\n+  tree operator* () const\n+  {\n+    tree fn = TREE_CODE (ovl) != OVERLOAD ? ovl : OVL_FUNCTION (ovl);\n+\n+    /* Check this is not an unexpected 2-dimensional overload.  */\n+    gcc_checking_assert (TREE_CODE (fn) != OVERLOAD);\n+\n+    return fn;\n+  }\n+};\n+\n+/* Iterator over a (potentially) 2 dimensional overload, which is\n+   produced by name lookup.  */\n+\n+/* Note this is currently a placeholder, as the name-lookup changes\n+   are not yet committed.  */\n+\n+class lkp_iterator : public ovl_iterator\n+{\n+  typedef ovl_iterator parent;\n+\n+ public:\n+  lkp_iterator (tree o)\n+    : parent (o)\n+  {\n+  }\n+};\n+\n struct GTY(()) tree_template_decl {\n   struct tree_decl_common common;\n   tree arguments;\n@@ -653,6 +709,10 @@ struct GTY(()) tree_template_decl {\n    a TEMPLATE_DECL, an OVERLOAD, or a TEMPLATE_ID_EXPR.  */\n #define BASELINK_FUNCTIONS(NODE) \\\n   (((struct tree_baselink*) BASELINK_CHECK (NODE))->functions)\n+/* If T is a BASELINK, grab the functions, otherwise just T, which is\n+   expected to already be a (list of) functions.  */\n+#define MAYBE_BASELINK_FUNCTIONS(T) \\\n+  (BASELINK_P (T) ? BASELINK_FUNCTIONS (T) : T)\n /* The BINFO in which the search for the functions indicated by this baselink\n    began.  This base is used to determine the accessibility of functions\n    selected by overload resolution.  */"}, {"sha": "c1ac98098dbaaac97f282ad865784065e18fed84", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3f267553fca2671ca4abb0dbbe3c9f625357edf0", "patch": "@@ -4390,10 +4390,10 @@ maybe_warn_sized_delete (enum tree_code code)\n   tree sized = NULL_TREE;\n   tree unsized = NULL_TREE;\n \n-  for (tree ovl = IDENTIFIER_GLOBAL_VALUE (cp_operator_id (code));\n-       ovl; ovl = OVL_NEXT (ovl))\n+  for (ovl_iterator iter (IDENTIFIER_GLOBAL_VALUE (cp_operator_id (code)));\n+       iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (ovl);\n+      tree fn = *iter;\n       /* We're only interested in usual deallocation functions.  */\n       if (!usual_deallocation_fn_p (fn))\n \tcontinue;"}, {"sha": "9d7701fba9bf4d3bf3d8498965d996892ede3fea", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=3f267553fca2671ca4abb0dbbe3c9f625357edf0", "patch": "@@ -841,18 +841,15 @@ maybe_generic_this_capture (tree object, tree fns)\n \tbool id_expr = TREE_CODE (fns) == TEMPLATE_ID_EXPR;\n \tif (id_expr)\n \t  fns = TREE_OPERAND (fns, 0);\n-\tfor (; fns; fns = OVL_NEXT (fns))\n-\t  {\n-\t    tree fn = OVL_CURRENT (fns);\n-\n-\t    if ((!id_expr || TREE_CODE (fn) == TEMPLATE_DECL)\n-\t\t&& DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n-\t      {\n-\t\t/* Found a non-static member.  Capture this.  */\n-\t\tlambda_expr_this_capture (lam, true);\n-\t\tbreak;\n-\t      }\n-\t  }\n+\n+\tfor (lkp_iterator iter (fns); iter; ++iter)\n+\t  if ((!id_expr || TREE_CODE (*iter) == TEMPLATE_DECL)\n+\t      && DECL_NONSTATIC_MEMBER_FUNCTION_P (*iter))\n+\t    {\n+\t      /* Found a non-static member.  Capture this.  */\n+\t      lambda_expr_this_capture (lam, true);\n+\t      break;\n+\t    }\n       }\n }\n "}, {"sha": "9898ff19089723bb1f3c5139a76c8bbc584c9135", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=3f267553fca2671ca4abb0dbbe3c9f625357edf0", "patch": "@@ -538,9 +538,9 @@ inherited_ctor_binfo (tree binfo, tree fndecl)\n     return binfo;\n \n   tree results = NULL_TREE;\n-  for (; inh; inh = OVL_NEXT (inh))\n+  for (ovl_iterator iter (inh); iter; ++iter)\n     {\n-      tree one = inherited_ctor_binfo_1 (binfo, OVL_CURRENT (inh));\n+      tree one = inherited_ctor_binfo_1 (binfo, *iter);\n       if (!results)\n \tresults = one;\n       else if (one != results)\n@@ -593,9 +593,9 @@ binfo_inherited_from (tree binfo, tree init_binfo, tree inh)\n {\n   /* inh is an OVERLOAD if we inherited the same constructor along\n      multiple paths, check all of them.  */\n-  for (; inh; inh = OVL_NEXT (inh))\n+  for (ovl_iterator iter (inh); iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (inh);\n+      tree fn = *iter;\n       tree base = DECL_CONTEXT (fn);\n       tree base_binfo = NULL_TREE;\n       for (int i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)"}, {"sha": "7509dce7db0cfb345cb140061cbf1b71e3ae5d24", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3f267553fca2671ca4abb0dbbe3c9f625357edf0", "patch": "@@ -4061,16 +4061,16 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n static tree\n lookup_literal_operator (tree name, vec<tree, va_gc> *args)\n {\n-  tree decl, fns;\n+  tree decl;\n   decl = lookup_name (name);\n   if (!decl || !is_overloaded_fn (decl))\n     return error_mark_node;\n \n-  for (fns = decl; fns; fns = OVL_NEXT (fns))\n+  for (lkp_iterator iter (decl); iter; ++iter)\n     {\n       unsigned int ix;\n       bool found = true;\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n       tree parmtypes = TYPE_ARG_TYPES (TREE_TYPE (fn));\n       if (parmtypes != NULL_TREE)\n \t{"}, {"sha": "142ed66ff38da5c00afff641d68f4fc0a86944c0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3f267553fca2671ca4abb0dbbe3c9f625357edf0", "patch": "@@ -1746,8 +1746,8 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n       return val;\n \n     case OVERLOAD:\n-      for (; arg; arg = OVL_NEXT (arg))\n-\tval = iterative_hash_template_arg (OVL_CURRENT (arg), val);\n+      for (lkp_iterator iter (arg); iter; ++iter)\n+\tval = iterative_hash_template_arg (*iter, val);\n       return val;\n \n     case CONSTRUCTOR:\n@@ -1926,15 +1926,15 @@ print_candidates_1 (tree fns, char **str, bool more = false)\n     for (; fns; fns = TREE_CHAIN (fns))\n       print_candidates_1 (TREE_VALUE (fns), str, more || TREE_CHAIN (fns));\n   else\n-    while (fns)\n+    for (lkp_iterator iter (fns); iter;)\n       {\n-\ttree cand = OVL_CURRENT (fns);\n+\ttree cand = *iter;\n+\t++iter;\n \n-\tfns = OVL_NEXT (fns);\n \tconst char *pfx = *str;\n \tif (!pfx)\n \t  {\n-\t    if (more || fns)\n+\t    if (more || iter)\n \t      pfx = _(\"candidates are:\");\n \t    else\n \t      pfx = _(\"candidate is:\");\n@@ -2102,9 +2102,9 @@ determine_specialization (tree template_id,\n       if (targs != error_mark_node)\n         templates = tree_cons (targs, fns, templates);\n     }\n-  else for (; fns; fns = OVL_NEXT (fns))\n+  else for (lkp_iterator iter (fns); iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n \n       if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t{\n@@ -19379,9 +19379,9 @@ resolve_overloaded_unification (tree tparms,\n       tree expl_subargs = TREE_OPERAND (arg, 1);\n       arg = TREE_OPERAND (arg, 0);\n \n-      for (; arg; arg = OVL_NEXT (arg))\n+      for (lkp_iterator iter (arg); iter; ++iter)\n \t{\n-\t  tree fn = OVL_CURRENT (arg);\n+\t  tree fn = *iter;\n \t  tree subargs, elem;\n \n \t  if (TREE_CODE (fn) != TEMPLATE_DECL)\n@@ -19420,15 +19420,17 @@ resolve_overloaded_unification (tree tparms,\n        not just the function on its own.  */\n     return false;\n   else\n-    for (; arg; arg = OVL_NEXT (arg))\n-      if (try_one_overload (tparms, targs, tempargs, parm,\n-\t\t\t    TREE_TYPE (OVL_CURRENT (arg)),\n-\t\t\t    strict, sub_strict, addr_p, explain_p)\n-\t  && (!goodfn || !decls_match (goodfn, OVL_CURRENT (arg))))\n-\t{\n-\t  goodfn = OVL_CURRENT (arg);\n-\t  ++good;\n-\t}\n+    for (lkp_iterator iter (arg); iter; ++iter)\n+      {\n+\ttree fn = *iter;\n+\tif (try_one_overload (tparms, targs, tempargs, parm, TREE_TYPE (fn),\n+\t\t\t      strict, sub_strict, addr_p, explain_p)\n+\t    && (!goodfn || !decls_match (goodfn, fn)))\n+\t  {\n+\t    goodfn = fn;\n+\t    ++good;\n+\t  }\n+      }\n \n   /* [temp.deduct.type] A template-argument can be deduced from a pointer\n      to function or pointer to member function argument if the set of\n@@ -19510,9 +19512,9 @@ resolve_nondeduced_context (tree orig_expr, tsubst_flags_t complain)\n       tree badfn = NULL_TREE;\n       tree badargs = NULL_TREE;\n \n-      for (; arg; arg = OVL_NEXT (arg))\n+      for (lkp_iterator iter (arg); iter; ++iter)\n \t{\n-\t  tree fn = OVL_CURRENT (arg);\n+\t  tree fn = *iter;\n \t  tree subargs, elem;\n \n \t  if (TREE_CODE (fn) != TEMPLATE_DECL)\n@@ -23926,12 +23928,10 @@ type_dependent_expression_p (tree expression)\n       gcc_assert (TREE_CODE (expression) == OVERLOAD\n \t\t  || TREE_CODE (expression) == FUNCTION_DECL);\n \n-      while (expression)\n-\t{\n-\t  if (type_dependent_expression_p (OVL_CURRENT (expression)))\n-\t    return true;\n-\t  expression = OVL_NEXT (expression);\n-\t}\n+      for (lkp_iterator iter (expression); iter; ++iter)\n+\tif (type_dependent_expression_p (*iter))\n+\t  return true;\n+\n       return false;\n     }\n \n@@ -24284,12 +24284,9 @@ dependent_template_p (tree tmpl)\n {\n   if (TREE_CODE (tmpl) == OVERLOAD)\n     {\n-      while (tmpl)\n-\t{\n-\t  if (dependent_template_p (OVL_CURRENT (tmpl)))\n-\t    return true;\n-\t  tmpl = OVL_NEXT (tmpl);\n-\t}\n+      for (lkp_iterator iter (tmpl); iter; ++iter)\n+\tif (dependent_template_p (*iter))\n+\t  return true;\n       return false;\n     }\n "}, {"sha": "5c7548adbdad9da74924f0dd6f703ec012cb7692", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=3f267553fca2671ca4abb0dbbe3c9f625357edf0", "patch": "@@ -236,8 +236,9 @@ cxx_print_xnode (FILE *file, tree node, int indent)\n \t\t  indent + 4);\n       break;\n     case OVERLOAD:\n-      print_node (file, \"function\", OVL_FUNCTION (node), indent+4);\n-      print_node (file, \"chain\", TREE_CHAIN (node), indent+4);\n+      print_node (file, \"name\", OVL_NAME (node), indent+4);\n+      for (lkp_iterator iter (node); iter; ++iter)\n+\tprint_node (file, \"function\", *iter, indent+4);\n       break;\n     case TEMPLATE_PARM_INDEX:\n       print_node (file, \"decl\", TEMPLATE_PARM_DECL (node), indent+4);"}, {"sha": "ce2899b7aef29b3652c4a22f9bcabf613788425e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3f267553fca2671ca4abb0dbbe3c9f625357edf0", "patch": "@@ -5205,26 +5205,33 @@ omp_reduction_lookup (location_t loc, tree id, tree type, tree *baselinkp,\n \t\t\t\t\t\t  type),\n \t\t\t\tfalse, false);\n   tree fns = id;\n-  if (id && is_overloaded_fn (id))\n-    id = get_fns (id);\n-  for (; id; id = OVL_NEXT (id))\n+  id = NULL_TREE;\n+  if (fns && is_overloaded_fn (fns))\n     {\n-      tree fndecl = OVL_CURRENT (id);\n-      if (TREE_CODE (fndecl) == FUNCTION_DECL)\n+      for (lkp_iterator iter (get_fns (fns)); iter; ++iter)\n \t{\n-\t  tree argtype = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n-\t  if (same_type_p (TREE_TYPE (argtype), type))\n-\t    break;\n+\t  tree fndecl = *iter;\n+\t  if (TREE_CODE (fndecl) == FUNCTION_DECL)\n+\t    {\n+\t      tree argtype = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n+\t      if (same_type_p (TREE_TYPE (argtype), type))\n+\t\t{\n+\t\t  id = fndecl;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (id && BASELINK_P (fns))\n+\t{\n+\t  if (baselinkp)\n+\t    *baselinkp = fns;\n+\t  else\n+\t    baselink = fns;\n \t}\n     }\n-  if (id && BASELINK_P (fns))\n-    {\n-      if (baselinkp)\n-\t*baselinkp = fns;\n-      else\n-\tbaselink = fns;\n-    }\n-  if (id == NULL_TREE && CLASS_TYPE_P (type) && TYPE_BINFO (type))\n+\n+  if (!id && CLASS_TYPE_P (type) && TYPE_BINFO (type))\n     {\n       vec<tree> ambiguous = vNULL;\n       tree binfo = TYPE_BINFO (type), base_binfo, ret = NULL_TREE;\n@@ -9062,9 +9069,9 @@ classtype_has_nothrow_assign_or_copy_p (tree type, bool assign_p)\n   else\n     return false;\n \n-  for (; fns; fns = OVL_NEXT (fns))\n+  for (ovl_iterator iter (fns); iter; ++iter)\n     {\n-      tree fn = OVL_CURRENT (fns);\n+      tree fn = *iter;\n  \n       if (assign_p)\n \t{"}, {"sha": "46a6bf8df35291098534b8e9265934a309ef5142", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f267553fca2671ca4abb0dbbe3c9f625357edf0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3f267553fca2671ca4abb0dbbe3c9f625357edf0", "patch": "@@ -2628,23 +2628,20 @@ check_template_keyword (tree decl)\n \tpermerror (input_location, \"%qD is not a template\", decl);\n       else\n \t{\n-\t  tree fns;\n-\t  fns = decl;\n-\t  if (BASELINK_P (fns))\n-\t    fns = BASELINK_FUNCTIONS (fns);\n-\t  while (fns)\n+\t  bool found = false;\n+\n+\t  for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (decl));\n+\t       !found && iter; ++iter)\n \t    {\n-\t      tree fn = OVL_CURRENT (fns);\n+\t      tree fn = *iter;\n \t      if (TREE_CODE (fn) == TEMPLATE_DECL\n-\t\t  || TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n-\t\tbreak;\n-\t      if (TREE_CODE (fn) == FUNCTION_DECL\n-\t\t  && DECL_USE_TEMPLATE (fn)\n-\t\t  && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (fn)))\n-\t\tbreak;\n-\t      fns = OVL_NEXT (fns);\n+\t\t  || TREE_CODE (fn) == TEMPLATE_ID_EXPR\n+\t\t  || (TREE_CODE (fn) == FUNCTION_DECL\n+\t\t      && DECL_USE_TEMPLATE (fn)\n+\t\t      && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (fn))))\n+\t\tfound = true;\n \t    }\n-\t  if (!fns)\n+\t  if (!found)\n \t    permerror (input_location, \"%qD is not a template\", decl);\n \t}\n     }"}]}