{"sha": "db0e878d33f768ce3becc50fee31ae3aee34087f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIwZTg3OGQzM2Y3NjhjZTNiZWNjNTBmZWUzMWFlM2FlZTM0MDg3Zg==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-07-13T08:40:07Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-13T08:40:07Z"}, "message": "* cgraphunit.c: Convert prototypes to ISO C90.\n\nFrom-SVN: r69285", "tree": {"sha": "2eb1e3af2ff6ab63d2f18a576840765656c79885", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2eb1e3af2ff6ab63d2f18a576840765656c79885"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db0e878d33f768ce3becc50fee31ae3aee34087f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db0e878d33f768ce3becc50fee31ae3aee34087f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db0e878d33f768ce3becc50fee31ae3aee34087f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db0e878d33f768ce3becc50fee31ae3aee34087f/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4146d8d0c4bcb7e8279fe1e64b53af27d9665dab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4146d8d0c4bcb7e8279fe1e64b53af27d9665dab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4146d8d0c4bcb7e8279fe1e64b53af27d9665dab"}], "stats": {"total": 69, "additions": 30, "deletions": 39}, "files": [{"sha": "5fdb4b11bf8f68c80e76a9bc555674231f1cc748", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db0e878d33f768ce3becc50fee31ae3aee34087f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db0e878d33f768ce3becc50fee31ae3aee34087f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db0e878d33f768ce3becc50fee31ae3aee34087f", "patch": "@@ -1,3 +1,7 @@\n+2003-07-13  Andreas Jaeger  <aj@suse.de>\n+\n+\t* cgraphunit.c: Convert prototypes to ISO C90.\n+\n 2003-07-13  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* fixinc/inclhack.def (avoid_wchar_t_type): Use __cplusplus bypass"}, {"sha": "4f51e5d0e07c933d1355d365740ec8ee3a28e3f5", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db0e878d33f768ce3becc50fee31ae3aee34087f/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db0e878d33f768ce3becc50fee31ae3aee34087f/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=db0e878d33f768ce3becc50fee31ae3aee34087f", "patch": "@@ -41,12 +41,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #define INSNS_PER_CALL 10\n \n-static void cgraph_expand_functions PARAMS ((void));\n-static void cgraph_mark_functions_to_output PARAMS ((void));\n-static void cgraph_expand_function PARAMS ((struct cgraph_node *));\n-static tree record_call_1 PARAMS ((tree *, int *, void *));\n-static void cgraph_mark_local_functions PARAMS ((void));\n-static void cgraph_optimize_function PARAMS ((struct cgraph_node *));\n+static void cgraph_expand_functions (void);\n+static void cgraph_mark_functions_to_output (void);\n+static void cgraph_expand_function (struct cgraph_node *);\n+static tree record_call_1 (tree *, int *, void *);\n+static void cgraph_mark_local_functions (void);\n+static void cgraph_optimize_function (struct cgraph_node *);\n \n /* Statistics we collect about inlining algorithm.  */\n static int ncalls_inlined;\n@@ -58,9 +58,7 @@ static int overall_insns;\n    available - create cgraph edges for function calls via BODY.  */\n \n void\n-cgraph_finalize_function (decl, body)\n-     tree decl;\n-     tree body ATTRIBUTE_UNUSED;\n+cgraph_finalize_function (tree decl, tree body ATTRIBUTE_UNUSED)\n {\n   struct cgraph_node *node = cgraph_node (decl);\n \n@@ -92,10 +90,7 @@ cgraph_finalize_function (decl, body)\n \n /* Walk tree and record all calls.  Called via walk_tree.  */\n static tree\n-record_call_1 (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees;\n-     void *data;\n+record_call_1 (tree *tp, int *walk_subtrees, void *data)\n {\n   if (TREE_CODE (*tp) == VAR_DECL && TREE_STATIC (*tp))\n     cgraph_varpool_mark_needed_node (cgraph_varpool_node (*tp));\n@@ -115,7 +110,7 @@ record_call_1 (tp, walk_subtrees, data)\n \t  if (DECL_BUILT_IN (decl))\n \t    return NULL;\n \t  cgraph_record_call (data, decl);\n-\t     \n+\n \t  /* When we see a function call, we don't want to look at the\n \t     function reference in the ADDR_EXPR that is hanging from\n \t     the CALL_EXPR we're examining here, because we would\n@@ -133,9 +128,7 @@ record_call_1 (tp, walk_subtrees, data)\n /* Create cgraph edges for function calls inside BODY from DECL.  */\n \n void\n-cgraph_create_edges (decl, body)\n-     tree decl;\n-     tree body;\n+cgraph_create_edges (tree decl, tree body)\n {\n   /* The nodes we're interested in are never shared, so walk\n      the tree ignoring duplicates.  */\n@@ -145,7 +138,7 @@ cgraph_create_edges (decl, body)\n /* Analyze the whole compilation unit once it is parsed completely.  */\n \n void\n-cgraph_finalize_compilation_unit ()\n+cgraph_finalize_compilation_unit (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n@@ -247,7 +240,7 @@ cgraph_finalize_compilation_unit ()\n /* Figure out what functions we want to assemble.  */\n \n static void\n-cgraph_mark_functions_to_output ()\n+cgraph_mark_functions_to_output (void)\n {\n   struct cgraph_node *node;\n \n@@ -277,8 +270,7 @@ cgraph_mark_functions_to_output ()\n /* Optimize the function before expansion.  */\n \n static void\n-cgraph_optimize_function (node)\n-     struct cgraph_node *node;\n+cgraph_optimize_function (struct cgraph_node *node)\n {\n   tree decl = node->decl;\n \n@@ -298,8 +290,7 @@ cgraph_optimize_function (node)\n /* Expand function specified by NODE.  */\n \n static void\n-cgraph_expand_function (node)\n-     struct cgraph_node *node;\n+cgraph_expand_function (struct cgraph_node *node)\n {\n   tree decl = node->decl;\n   struct cgraph_edge *e;\n@@ -385,7 +376,7 @@ cgraph_postorder (struct cgraph_node **order)\n #define SET_INLINED_TIMES(node,times) ((node)->aux = (void *)(times))\n \n /* Return list of nodes we decided to inline NODE into, set their output\n-   flag and compute INLINED_TIMES. \n+   flag and compute INLINED_TIMES.\n \n    We do simple backtracing to get INLINED_TIMES right.  This should not be\n    expensive as we limit the amount of inlining.  Alternatively we may first\n@@ -485,7 +476,7 @@ cgraph_inlined_into (struct cgraph_node *node, struct cgraph_node **array)\n }\n \n /* Return list of nodes we decided to inline into NODE, set their output\n-   flag and compute INLINED_TIMES. \n+   flag and compute INLINED_TIMES.\n \n    This function is identical to cgraph_inlined_into with callers and callees\n    nodes swapped.  */\n@@ -584,8 +575,7 @@ cgraph_inlined_callees (struct cgraph_node *node, struct cgraph_node **array)\n /* Estimate size of the function after inlining WHAT into TO.  */\n \n static int\n-cgraph_estimate_size_after_inlining (int times,\n-\t\t\t\t     struct cgraph_node *to,\n+cgraph_estimate_size_after_inlining (int times, struct cgraph_node *to,\n \t\t\t\t     struct cgraph_node *what)\n {\n   return (what->global.insns - INSNS_PER_CALL) *times + to->global.insns;\n@@ -627,8 +617,7 @@ cgraph_estimate_growth (struct cgraph_node *node)\n    all nodes in INLINED array.  */\n \n static void\n-cgraph_mark_inline (struct cgraph_node *to,\n-\t\t    struct cgraph_node *what,\n+cgraph_mark_inline (struct cgraph_node *to, struct cgraph_node *what,\n \t\t    struct cgraph_node **inlined, int ninlined,\n \t\t    struct cgraph_node **inlined_callees,\n \t\t    int ninlined_callees)\n@@ -700,8 +689,7 @@ cgraph_mark_inline (struct cgraph_node *to,\n    too large growth of function bodies.  */\n \n static bool\n-cgraph_check_inline_limits (struct cgraph_node *to,\n-\t\t\t    struct cgraph_node *what,\n+cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n \t\t\t    struct cgraph_node **inlined, int ninlined)\n {\n   int i;\n@@ -757,14 +745,13 @@ cgraph_default_inline_p (struct cgraph_node *n)\n /* We use greedy algorithm for inlining of small functions:\n    All inline candidates are put into prioritized heap based on estimated\n    growth of the overall number of instructions and then update the estimates.\n-   \n+\n    INLINED and INLINED_CALEES are just pointers to arrays large enought\n    to be passed to cgraph_inlined_into and cgraph_inlined_callees.  */\n \n static void\n cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n-\t\t\t\t\t   struct cgraph_node\n-\t\t\t\t\t   **inlined_callees)\n+\t\t\t\t\t   struct cgraph_node **inlined_callees)\n {\n   int i;\n   struct cgraph_node *node;\n@@ -1037,8 +1024,8 @@ cgraph_inline_p (tree caller_decl, tree callee_decl)\n      function body.  */\n   return false;\n }\n-/* Expand all functions that must be output. \n-  \n+/* Expand all functions that must be output.\n+\n    Attempt to topologically sort the nodes so function is output when\n    all called functions are already assembled to allow data to be\n    propagated accross the callgraph.  Use a stack to get smaller distance\n@@ -1048,7 +1035,7 @@ cgraph_inline_p (tree caller_decl, tree callee_decl)\n    order).  */\n \n static void\n-cgraph_expand_functions ()\n+cgraph_expand_functions (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_node **order =\n@@ -1082,7 +1069,7 @@ cgraph_expand_functions ()\n    as local.  */\n \n static void\n-cgraph_mark_local_functions ()\n+cgraph_mark_local_functions (void)\n {\n   struct cgraph_node *node;\n \n@@ -1105,7 +1092,7 @@ cgraph_mark_local_functions ()\n /* Perform simple optimizations based on callgraph.  */\n \n void\n-cgraph_optimize ()\n+cgraph_optimize (void)\n {\n   timevar_push (TV_CGRAPHOPT);\n   if (!quiet_flag)"}]}