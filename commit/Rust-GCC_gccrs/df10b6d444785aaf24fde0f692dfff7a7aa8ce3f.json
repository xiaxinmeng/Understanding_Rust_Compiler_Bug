{"sha": "df10b6d444785aaf24fde0f692dfff7a7aa8ce3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYxMGI2ZDQ0NDc4NWFhZjI0ZmRlMGY2OTJkZmZmN2E3YWE4Y2UzZg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2011-04-26T17:48:29Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2011-04-26T17:48:29Z"}, "message": "PR target/48258, improve vector reduction on power7\n\nFrom-SVN: r172981", "tree": {"sha": "c23cb566af188ae27d60669cb2914c66ae376ef0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c23cb566af188ae27d60669cb2914c66ae376ef0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/comments", "author": null, "committer": null, "parents": [{"sha": "35a5db044834df01f9865ee6857f6a6b66147da5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35a5db044834df01f9865ee6857f6a6b66147da5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35a5db044834df01f9865ee6857f6a6b66147da5"}], "stats": {"total": 412, "additions": 405, "deletions": 7}, "files": [{"sha": "99c029d748d6472285aeefe3cc22e620c51ed72b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df10b6d444785aaf24fde0f692dfff7a7aa8ce3f", "patch": "@@ -1,3 +1,27 @@\n+2011-04-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/48258\n+\t* config/rs6000/vector.md (UNSPEC_REDUC): New unspec for vector\n+\treduction.\n+\t(VEC_reduc): New code iterator and splitters for vector reduction.\n+\t(VEC_reduc_name): Ditto.\n+\t(VEC_reduc_rtx): Ditto.\n+\t(reduc_<VEC_reduc_name>_v2df): Vector reduction expanders for VSX.\n+\t(reduc_<VEC_reduc_name>_v4sf): Ditto.\n+\n+\t* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Add\n+\tsupport for extracting SF on VSX.\n+\n+\t* config/rs6000/vsx.md (vsx_xscvspdp_scalar2): New insn for\n+\tgenerating xscvspdp.\n+\t(vsx_extract_v4sf): New insn to extract SF from V4SF vector.\n+\t(vsx_reduc_<VEC_reduc_name>_v2df): New insns and splitters for\n+\tdouble add, minimum, maximum vector reduction.\n+\t(vsx_reduc_<VEC_reduc_name>_v4sf): Ditto.\n+\t(vsx_reduc_<VEC_reduc_name>_v2df2_scalar): New combiner insn to\n+\toptimize double vector reduction.\n+\t(vsx_reduc_<VEC_reduc_name>_v4sf_scalar): Ditto.\n+\n 2011-04-26  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/fr30/fr30.h (inhibit_libc): Don't define."}, {"sha": "41259630bf4f5d04af0f1f5455005df1d3c9de11", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=df10b6d444785aaf24fde0f692dfff7a7aa8ce3f", "patch": "@@ -5463,12 +5463,22 @@ rs6000_expand_vector_extract (rtx target, rtx vec, int elt)\n   enum machine_mode inner_mode = GET_MODE_INNER (mode);\n   rtx mem;\n \n-  if (VECTOR_MEM_VSX_P (mode) && (mode == V2DFmode || mode == V2DImode))\n+  if (VECTOR_MEM_VSX_P (mode))\n     {\n-      rtx (*extract_func) (rtx, rtx, rtx)\n-\t= ((mode == V2DFmode) ? gen_vsx_extract_v2df : gen_vsx_extract_v2di);\n-      emit_insn (extract_func (target, vec, GEN_INT (elt)));\n-      return;\n+      switch (mode)\n+\t{\n+\tdefault:\n+\t  break;\n+\tcase V2DFmode:\n+\t  emit_insn (gen_vsx_extract_v2df (target, vec, GEN_INT (elt)));\n+\t  return;\n+\tcase V2DImode:\n+\t  emit_insn (gen_vsx_extract_v2di (target, vec, GEN_INT (elt)));\n+\t  return;\n+\tcase V4SFmode:\n+\t  emit_insn (gen_vsx_extract_v4sf (target, vec, GEN_INT (elt)));\n+\t  return;\n+\t}\n     }\n \n   /* Allocate mode-sized buffer.  */"}, {"sha": "c0112507a6e49723416a46021b8c239c050fc5f7", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=df10b6d444785aaf24fde0f692dfff7a7aa8ce3f", "patch": "@@ -74,7 +74,19 @@\n \t\t\t   (V2DF  \"V2DI\")])\n \n ;; constants for unspec\n-(define_c_enum \"unspec\" [UNSPEC_PREDICATE])\n+(define_c_enum \"unspec\" [UNSPEC_PREDICATE\n+\t\t\t UNSPEC_REDUC])\n+\n+;; Vector reduction code iterators\n+(define_code_iterator VEC_reduc [plus smin smax])\n+\n+(define_code_attr VEC_reduc_name [(plus \"splus\")\n+\t\t\t\t  (smin \"smin\")\n+\t\t\t\t  (smax \"smax\")])\n+\n+(define_code_attr VEC_reduc_rtx [(plus \"add\")\n+\t\t\t\t (smin \"smin\")\n+\t\t\t\t (smax \"smax\")])\n \n \f\n ;; Vector move instructions.\n@@ -991,6 +1003,41 @@\n   \"TARGET_ALTIVEC\"\n   \"\")\n \f\n+;; Vector reduction expanders for VSX\n+\n+(define_expand \"reduc_<VEC_reduc_name>_v2df\"\n+  [(parallel [(set (match_operand:V2DF 0 \"vfloat_operand\" \"\")\n+\t\t   (VEC_reduc:V2DF\n+\t\t    (vec_concat:V2DF\n+\t\t     (vec_select:DF\n+\t\t      (match_operand:V2DF 1 \"vfloat_operand\" \"\")\n+\t\t      (parallel [(const_int 1)]))\n+\t\t     (vec_select:DF\n+\t\t      (match_dup 1)\n+\t\t      (parallel [(const_int 0)])))\n+\t\t    (match_dup 1)))\n+\t      (clobber (match_scratch:V2DF 2 \"\"))])]\n+  \"VECTOR_UNIT_VSX_P (V2DFmode)\"\n+  \"\")\n+\n+; The (VEC_reduc:V4SF\n+;\t(op1)\n+;\t(unspec:V4SF [(const_int 0)] UNSPEC_REDUC))\n+;\n+; is to allow us to use a code iterator, but not completely list all of the\n+; vector rotates, etc. to prevent canonicalization\n+\n+(define_expand \"reduc_<VEC_reduc_name>_v4sf\"\n+  [(parallel [(set (match_operand:V4SF 0 \"vfloat_operand\" \"\")\n+\t\t   (VEC_reduc:V4SF\n+\t\t    (unspec:V4SF [(const_int 0)] UNSPEC_REDUC)\n+\t\t    (match_operand:V4SF 1 \"vfloat_operand\" \"\")))\n+\t      (clobber (match_scratch:V4SF 2 \"\"))\n+\t      (clobber (match_scratch:V4SF 3 \"\"))])]\n+  \"VECTOR_UNIT_VSX_P (V4SFmode)\"\n+  \"\")\n+\n+\f\n ;;; Expanders for vector insn patterns shared between the SPE and TARGET_PAIRED systems.\n \n (define_expand \"absv2sf2\""}, {"sha": "d4f529676e42b000007e0001e4d659f775a2ab5d", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=df10b6d444785aaf24fde0f692dfff7a7aa8ce3f", "patch": "@@ -829,6 +829,15 @@\n   \"xscvdpsp %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n+;; Same as vsx_xscvspdp, but use SF as the type\n+(define_insn \"vsx_xscvspdp_scalar2\"\n+  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=f\")\n+\t(unspec:SF [(match_operand:V4SF 1 \"vsx_register_operand\" \"wa\")]\n+\t\t   UNSPEC_VSX_CVSPDP))]\n+  \"VECTOR_UNIT_VSX_P (DFmode)\"\n+  \"xscvspdp %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n ;; Convert from 64-bit to 32-bit types\n ;; Note, favor the Altivec registers since the usual use of these instructions\n ;; is in vector converts and we need to use the Altivec vperm instruction.\n@@ -1039,6 +1048,43 @@\n   [(set_attr \"type\" \"fpload\")\n    (set_attr \"length\" \"4\")])  \n \n+;; Extract a SF element from V4SF\n+(define_insn_and_split \"vsx_extract_v4sf\"\n+  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=f,f\")\n+\t(vec_select:SF\n+\t (match_operand:V4SF 1 \"vsx_register_operand\" \"wa,wa\")\n+\t (parallel [(match_operand:QI 2 \"u5bit_cint_operand\" \"O,i\")])))\n+   (clobber (match_scratch:V4SF 3 \"=X,0\"))]\n+  \"VECTOR_UNIT_VSX_P (V4SFmode)\"\n+  \"@\n+   xscvspdp %x0,%x1\n+   #\"\n+  \"\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  rtx op3 = operands[3];\n+  rtx tmp;\n+  HOST_WIDE_INT ele = INTVAL (op2);\n+\n+  if (ele == 0)\n+    tmp = op1;\n+  else\n+    {\n+      if (GET_CODE (op3) == SCRATCH)\n+\top3 = gen_reg_rtx (V4SFmode);\n+      emit_insn (gen_vsx_xxsldwi_v4sf (op3, op1, op1, op2));\n+      tmp = op3;\n+    }\n+  emit_insn (gen_vsx_xscvspdp_scalar2 (op0, tmp));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"4,8\")\n+   (set_attr \"type\" \"fp\")])\n+\n ;; General double word oriented permute, allow the other vector types for\n ;; optimizing the permute instruction.\n (define_insn \"vsx_xxpermdi_<mode>\"\n@@ -1150,3 +1196,153 @@\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"xxsldwi %x0,%x1,%x2,%3\"\n   [(set_attr \"type\" \"vecperm\")])\n+\n+\f\n+;; Vector reduction insns and splitters\n+\n+(define_insn_and_split \"*vsx_reduc_<VEC_reduc_name>_v2df\"\n+  [(set (match_operand:V2DF 0 \"vfloat_operand\" \"=&wd,&?wa,wd,?wa\")\n+\t(VEC_reduc:V2DF\n+\t (vec_concat:V2DF\n+\t  (vec_select:DF\n+\t   (match_operand:V2DF 1 \"vfloat_operand\" \"wd,wa,wd,wa\")\n+\t   (parallel [(const_int 1)]))\n+\t  (vec_select:DF\n+\t   (match_dup 1)\n+\t   (parallel [(const_int 0)])))\n+\t (match_dup 1)))\n+   (clobber (match_scratch:V2DF 2 \"=0,0,&wd,&wa\"))]\n+  \"VECTOR_UNIT_VSX_P (V2DFmode)\"\n+  \"#\"\n+  \"\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx tmp = (GET_CODE (operands[2]) == SCRATCH)\n+\t     ? gen_reg_rtx (V2DFmode)\n+\t     : operands[2];\n+  emit_insn (gen_vsx_xxsldwi_v2df (tmp, operands[1], operands[1], const2_rtx));\n+  emit_insn (gen_<VEC_reduc_rtx>v2df3 (operands[0], tmp, operands[1]));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"veccomplex\")])\n+\n+(define_insn_and_split \"*vsx_reduc_<VEC_reduc_name>_v4sf\"\n+  [(set (match_operand:V4SF 0 \"vfloat_operand\" \"=wf,?wa\")\n+\t(VEC_reduc:V4SF\n+\t (unspec:V4SF [(const_int 0)] UNSPEC_REDUC)\n+\t (match_operand:V4SF 1 \"vfloat_operand\" \"wf,wa\")))\n+   (clobber (match_scratch:V4SF 2 \"=&wf,&wa\"))\n+   (clobber (match_scratch:V4SF 3 \"=&wf,&wa\"))]\n+  \"VECTOR_UNIT_VSX_P (V4SFmode)\"\n+  \"#\"\n+  \"\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx tmp2, tmp3, tmp4;\n+\n+  if (can_create_pseudo_p ())\n+    {\n+      tmp2 = gen_reg_rtx (V4SFmode);\n+      tmp3 = gen_reg_rtx (V4SFmode);\n+      tmp4 = gen_reg_rtx (V4SFmode);\n+    }\n+  else\n+    {\n+      tmp2 = operands[2];\n+      tmp3 = operands[3];\n+      tmp4 = tmp2;\n+    }\n+\n+  emit_insn (gen_vsx_xxsldwi_v4sf (tmp2, op1, op1, const2_rtx));\n+  emit_insn (gen_<VEC_reduc_rtx>v4sf3 (tmp3, tmp2, op1));\n+  emit_insn (gen_vsx_xxsldwi_v4sf (tmp4, tmp3, tmp3, GEN_INT (3)));\n+  emit_insn (gen_<VEC_reduc_rtx>v4sf3 (op0, tmp4, tmp3));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"16\")\n+   (set_attr \"type\" \"veccomplex\")])\n+\n+;; Combiner patterns with the vector reduction patterns that knows we can get\n+;; to the top element of the V2DF array without doing an extract.\n+\n+(define_insn_and_split \"*vsx_reduc_<VEC_reduc_name>_v2df_scalar\"\n+  [(set (match_operand:DF 0 \"vfloat_operand\" \"=&ws,&?wa,ws,?wa\")\n+\t(vec_select:DF\n+\t (VEC_reduc:V2DF\n+\t  (vec_concat:V2DF\n+\t   (vec_select:DF\n+\t    (match_operand:V2DF 1 \"vfloat_operand\" \"wd,wa,wd,wa\")\n+\t    (parallel [(const_int 1)]))\n+\t   (vec_select:DF\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 0)])))\n+\t  (match_dup 1))\n+\t (parallel [(const_int 1)])))\n+   (clobber (match_scratch:DF 2 \"=0,0,&wd,&wa\"))]\n+  \"VECTOR_UNIT_VSX_P (V2DFmode)\"\n+  \"#\"\n+  \"\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx hi = gen_highpart (DFmode, operands[1]);\n+  rtx lo = (GET_CODE (operands[2]) == SCRATCH)\n+\t    ? gen_reg_rtx (DFmode)\n+\t    : operands[2];\n+\n+  emit_insn (gen_vsx_extract_v2df (lo, operands[1], const1_rtx));\n+  emit_insn (gen_<VEC_reduc_rtx>df3 (operands[0], hi, lo));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"veccomplex\")])\n+\n+(define_insn_and_split \"*vsx_reduc_<VEC_reduc_name>_v4sf_scalar\"\n+  [(set (match_operand:SF 0 \"vfloat_operand\" \"=f,?f\")\n+\t(vec_select:SF\n+\t (VEC_reduc:V4SF\n+\t  (unspec:V4SF [(const_int 0)] UNSPEC_REDUC)\n+\t  (match_operand:V4SF 1 \"vfloat_operand\" \"wf,wa\"))\n+\t (parallel [(const_int 3)])))\n+   (clobber (match_scratch:V4SF 2 \"=&wf,&wa\"))\n+   (clobber (match_scratch:V4SF 3 \"=&wf,&wa\"))\n+   (clobber (match_scratch:V4SF 4 \"=0,0\"))]\n+  \"VECTOR_UNIT_VSX_P (V4SFmode)\"\n+  \"#\"\n+  \"\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx tmp2, tmp3, tmp4, tmp5;\n+\n+  if (can_create_pseudo_p ())\n+    {\n+      tmp2 = gen_reg_rtx (V4SFmode);\n+      tmp3 = gen_reg_rtx (V4SFmode);\n+      tmp4 = gen_reg_rtx (V4SFmode);\n+      tmp5 = gen_reg_rtx (V4SFmode);\n+    }\n+  else\n+    {\n+      tmp2 = operands[2];\n+      tmp3 = operands[3];\n+      tmp4 = tmp2;\n+      tmp5 = operands[4];\n+    }\n+\n+  emit_insn (gen_vsx_xxsldwi_v4sf (tmp2, op1, op1, const2_rtx));\n+  emit_insn (gen_<VEC_reduc_rtx>v4sf3 (tmp3, tmp2, op1));\n+  emit_insn (gen_vsx_xxsldwi_v4sf (tmp4, tmp3, tmp3, GEN_INT (3)));\n+  emit_insn (gen_<VEC_reduc_rtx>v4sf3 (tmp5, tmp4, tmp3));\n+  emit_insn (gen_vsx_xscvspdp_scalar2 (op0, tmp5));\n+  DONE;\n+}\"\n+  [(set_attr \"length\" \"20\")\n+   (set_attr \"type\" \"veccomplex\")])"}, {"sha": "f6533cae2bb13d11119fd7a0a2bf544468e80851", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=df10b6d444785aaf24fde0f692dfff7a7aa8ce3f", "patch": "@@ -1,5 +1,11 @@\n+2011-03-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/48258\n+\t* gcc.target/powerpc/pr48258-1.c: New file.\n+\t* gcc.target/powerpc/pr48258-2.c: Ditto.\n+\n 2011-04-26  Xinliang David Li  <davidxl@google.com>\n-\t\n+\n \t* gcc.dg/uninit-suppress.c: New test.\n \t* gcc.dg/uninit-suppress.c: New test.\n "}, {"sha": "4f37815d38422529ebbd0f26a3f230ec9ae17ecb", "filename": "gcc/testsuite/gcc.target/powerpc/pr48258-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48258-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48258-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48258-1.c?ref=df10b6d444785aaf24fde0f692dfff7a7aa8ce3f", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -mcpu=power7 -mabi=altivec -ffast-math -fno-unroll-loops\" } */\n+/* { dg-final { scan-assembler-times \"xvaddsp\" 3 } } */\n+/* { dg-final { scan-assembler-times \"xvminsp\" 3 } } */\n+/* { dg-final { scan-assembler-times \"xvmaxsp\" 3 } } */\n+/* { dg-final { scan-assembler-times \"xxsldwi\" 6 } } */\n+/* { dg-final { scan-assembler-times \"xscvspdp\" 3 } } */\n+/* { dg-final { scan-assembler-not \"stvewx\" } } */\n+/* { dg-final { scan-assembler-not \"stvx\" } } */\n+/* { dg-final { scan-assembler-not \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler-not \"stxvw4x\" } } */\n+\n+#include <stddef.h>\n+\n+#ifndef SIZE\n+#define SIZE 1024\n+#endif\n+\n+float values[SIZE] __attribute__((__aligned__(32)));\n+\n+float\n+vector_sum (void)\n+{\n+  size_t i;\n+  float sum = 0.0f;\n+\n+  for (i = 0; i < SIZE; i++)\n+    sum += values[i];\n+\n+  return sum;\n+}\n+\n+float\n+vector_min (void)\n+{\n+  size_t i;\n+  float min = values[0];\n+\n+  for (i = 0; i < SIZE; i++)\n+    min = __builtin_fminf (min, values[i]);\n+\n+  return min;\n+}\n+\n+float\n+vector_max (void)\n+{\n+  size_t i;\n+  float max = values[0];\n+\n+  for (i = 0; i < SIZE; i++)\n+    max = __builtin_fmaxf (max, values[i]);\n+\n+  return max;\n+}"}, {"sha": "443fb624e30114c982dd4d08190634dd21f7a9c1", "filename": "gcc/testsuite/gcc.target/powerpc/pr48258-2.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48258-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df10b6d444785aaf24fde0f692dfff7a7aa8ce3f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48258-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48258-2.c?ref=df10b6d444785aaf24fde0f692dfff7a7aa8ce3f", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -mcpu=power7 -mabi=altivec -ffast-math -fno-unroll-loops\" } */\n+/* { dg-final { scan-assembler-times \"xvadddp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xvmindp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xvmaxdp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xsadddp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xsmindp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xsmaxdp\" 1 } } */\n+/* { dg-final { scan-assembler-not \"xxsldwi\" } } */\n+/* { dg-final { scan-assembler-not \"stvx\" } } */\n+/* { dg-final { scan-assembler-not \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler-not \"stxvw4x\" } } */\n+\n+#include <stddef.h>\n+\n+#ifndef SIZE\n+#define SIZE 1024\n+#endif\n+\n+double values[SIZE] __attribute__((__aligned__(32)));\n+\n+double\n+vector_sum (void)\n+{\n+  size_t i;\n+  double sum = 0.0;\n+\n+  for (i = 0; i < SIZE; i++)\n+    sum += values[i];\n+\n+  return sum;\n+}\n+\n+double\n+vector_min (void)\n+{\n+  size_t i;\n+  double min = values[0];\n+\n+  for (i = 0; i < SIZE; i++)\n+    min = __builtin_fmin (min, values[i]);\n+\n+  return min;\n+}\n+\n+double\n+vector_max (void)\n+{\n+  size_t i;\n+  double max = values[0];\n+\n+  for (i = 0; i < SIZE; i++)\n+    max = __builtin_fmax (max, values[i]);\n+\n+  return max;\n+}"}]}