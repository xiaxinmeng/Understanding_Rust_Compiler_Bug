{"sha": "d0d4601ccde3c4849f6e7244035f1a899d608cb7", "node_id": "C_kwDOANBUbNoAKGQwZDQ2MDFjY2RlM2M0ODQ5ZjZlNzI0NDAzNWYxYTg5OWQ2MDhjYjc", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-02-08T15:11:20Z"}, "committer": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-02-08T19:46:20Z"}, "message": "ifcvt: Fix PR104153 and PR104198.\n\nThis is a bugfix for r12-6747-gaa8cfe785953a0 which caused an ICE\non or1k (PR104153) and broke SPARC bootstrap (PR104198).\n\ncond_exec_get_condition () returns the jump condition directly and we\nnow pass it to the backend.  The or1k backend modified the condition\nin-place (other backends do that as well) but this modification is not\nreverted when the sequence in question is discarded.  Therefore we copy\nthe RTX instead of using it directly.\n\nThe SPARC problem is due to the SPARC backend recreating the initial\ncondition when being passed a CC comparison.  This causes the sequence\nto read from an already overwritten condition operand.  Generally, this\ncould also happen on other targets.  The workaround is to always first\nemit to a temporary.  In a second run of noce_convert_multiple_sets_1\nwe know which sequences actually require the comparison and will use no\ntemporaries if all sequences after the current one do not require it.\n\n\tPR rtl-optimization/104198\n\tPR rtl-optimization/104153\n\ngcc/ChangeLog:\n\n\t* ifcvt.cc (noce_convert_multiple_sets_1): Copy rtx instead of\n\tusing it directly.  Rework comparison handling and always\n\tperform a second pass.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/pr104198.c: New test.", "tree": {"sha": "816d6878fa064b9e89703a8dbb0f6bac391f2fe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/816d6878fa064b9e89703a8dbb0f6bac391f2fe3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0d4601ccde3c4849f6e7244035f1a899d608cb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d4601ccde3c4849f6e7244035f1a899d608cb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0d4601ccde3c4849f6e7244035f1a899d608cb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d4601ccde3c4849f6e7244035f1a899d608cb7/comments", "author": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71e6353e1b03021bc8bbcf4bd67a5f14d09b5fb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71e6353e1b03021bc8bbcf4bd67a5f14d09b5fb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71e6353e1b03021bc8bbcf4bd67a5f14d09b5fb1"}], "stats": {"total": 82, "additions": 81, "deletions": 1}, "files": [{"sha": "6305621e4602db9d509ec328f9da89c35d692812", "filename": "gcc/ifcvt.cc", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d4601ccde3c4849f6e7244035f1a899d608cb7/gcc%2Fifcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d4601ccde3c4849f6e7244035f1a899d608cb7/gcc%2Fifcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.cc?ref=d0d4601ccde3c4849f6e7244035f1a899d608cb7", "patch": "@@ -3391,7 +3391,11 @@ noce_convert_multiple_sets_1 (struct noce_if_info *if_info,\n   rtx cond = noce_get_condition (jump, &cond_earliest, false);\n \n   rtx cc_cmp = cond_exec_get_condition (jump);\n+  if (cc_cmp)\n+    cc_cmp = copy_rtx (cc_cmp);\n   rtx rev_cc_cmp = cond_exec_get_condition (jump, /* get_reversed */ true);\n+  if (rev_cc_cmp)\n+    rev_cc_cmp = copy_rtx (rev_cc_cmp);\n \n   rtx_insn *insn;\n   int count = 0;\n@@ -3515,6 +3519,7 @@ noce_convert_multiple_sets_1 (struct noce_if_info *if_info,\n       unsigned cost1 = 0, cost2 = 0;\n       rtx_insn *seq, *seq1, *seq2;\n       rtx temp_dest = NULL_RTX, temp_dest1 = NULL_RTX, temp_dest2 = NULL_RTX;\n+      bool read_comparison = false;\n \n       seq1 = try_emit_cmove_seq (if_info, temp, cond,\n \t\t\t\t new_val, old_val, need_cmov,\n@@ -3524,10 +3529,41 @@ noce_convert_multiple_sets_1 (struct noce_if_info *if_info,\n \t as well.  This allows the backend to emit a cmov directly without\n \t creating an additional compare for each.  If successful, costing\n \t is easier and this sequence is usually preferred.  */\n-      seq2 = try_emit_cmove_seq (if_info, target, cond,\n+      seq2 = try_emit_cmove_seq (if_info, temp, cond,\n \t\t\t\t new_val, old_val, need_cmov,\n \t\t\t\t &cost2, &temp_dest2, cc_cmp, rev_cc_cmp);\n \n+      /* The backend might have created a sequence that uses the\n+\t condition.  Check this.  */\n+      rtx_insn *walk = seq2;\n+      while (walk)\n+\t{\n+\t  rtx set = single_set (walk);\n+\n+\t  if (!set || !SET_SRC (set))\n+\t    {\n+\t      walk = NEXT_INSN (walk);\n+\t      continue;\n+\t    }\n+\n+\t  rtx src = SET_SRC (set);\n+\n+\t  if (XEXP (set, 1) && GET_CODE (XEXP (set, 1)) == IF_THEN_ELSE)\n+\t    ; /* We assume that this is the cmove created by the backend that\n+\t\t naturally uses the condition.  Therefore we ignore it.  */\n+\t  else\n+\t    {\n+\t      if (reg_mentioned_p (XEXP (cond, 0), src)\n+\t\t  || reg_mentioned_p (XEXP (cond, 1), src))\n+\t\t{\n+\t\t  read_comparison = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  walk = NEXT_INSN (walk);\n+\t}\n+\n       /* Check which version is less expensive.  */\n       if (seq1 != NULL_RTX && (cost1 <= cost2 || seq2 == NULL_RTX))\n \t{\n@@ -3540,6 +3576,8 @@ noce_convert_multiple_sets_1 (struct noce_if_info *if_info,\n \t{\n \t  seq = seq2;\n \t  temp_dest = temp_dest2;\n+\t  if (!second_try && read_comparison)\n+\t    *last_needs_comparison = count;\n \t}\n       else\n \t{\n@@ -3558,6 +3596,12 @@ noce_convert_multiple_sets_1 (struct noce_if_info *if_info,\n       unmodified_insns->safe_push (insn);\n     }\n \n+  /* Even if we did not actually need the comparison, we want to make sure\n+     to try a second time in order to get rid of the temporaries.  */\n+  if (*last_needs_comparison == -1)\n+    *last_needs_comparison = 0;\n+\n+\n   return true;\n }\n "}, {"sha": "bfc7a7771846c7cf4a867fe6e833a87087e29e30", "filename": "gcc/testsuite/gcc.dg/pr104198.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d4601ccde3c4849f6e7244035f1a899d608cb7/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104198.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d4601ccde3c4849f6e7244035f1a899d608cb7/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104198.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104198.c?ref=d0d4601ccde3c4849f6e7244035f1a899d608cb7", "patch": "@@ -0,0 +1,36 @@\n+/* Make sure if conversion for two instructions does not break\n+   anything (if it runs).  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -std=c99\" } */\n+\n+#include <limits.h>\n+#include <assert.h>\n+\n+__attribute__ ((noinline))\n+int foo (int *a, int n)\n+{\n+  int min = 999999;\n+  int bla = 0;\n+  for (int i = 0; i < n; i++)\n+    {\n+      if (a[i] < min)\n+\t{\n+\t  min = a[i];\n+\t  bla = 1;\n+\t}\n+    }\n+\n+  if (bla)\n+    min += 1;\n+  return min;\n+}\n+\n+int main()\n+{\n+  int a[] = {2, 1, -13, INT_MAX, INT_MIN, 0};\n+\n+  int res = foo (a, sizeof (a) / sizeof (a[0]));\n+\n+  assert (res == (INT_MIN + 1));\n+}"}]}