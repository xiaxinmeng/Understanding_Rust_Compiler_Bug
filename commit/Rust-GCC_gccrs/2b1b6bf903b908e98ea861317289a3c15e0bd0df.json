{"sha": "2b1b6bf903b908e98ea861317289a3c15e0bd0df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIxYjZiZjkwM2I5MDhlOThlYTg2MTMxNzI4OWEzYzE1ZTBiZDBkZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-07-04T18:20:21Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-07-04T18:20:21Z"}, "message": "emit-rtl.c (change_address): Don't abort if invalid address while reload is in progress.\n\n\t* emit-rtl.c (change_address): Don't abort if invalid address while\n\treload is in progress.\n\nFrom-SVN: r43765", "tree": {"sha": "1dc4db2ef792bbf2e548d464bcc5a5c8bd3f6be9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dc4db2ef792bbf2e548d464bcc5a5c8bd3f6be9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b1b6bf903b908e98ea861317289a3c15e0bd0df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1b6bf903b908e98ea861317289a3c15e0bd0df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b1b6bf903b908e98ea861317289a3c15e0bd0df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1b6bf903b908e98ea861317289a3c15e0bd0df/comments", "author": null, "committer": null, "parents": [{"sha": "98aff0b52ee9c65edf7099ac2a23b47ef813ea47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98aff0b52ee9c65edf7099ac2a23b47ef813ea47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98aff0b52ee9c65edf7099ac2a23b47ef813ea47"}], "stats": {"total": 21, "additions": 16, "deletions": 5}, "files": [{"sha": "de559fb5320f4db4393a65ceea5ff360ea6e26f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1b6bf903b908e98ea861317289a3c15e0bd0df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1b6bf903b908e98ea861317289a3c15e0bd0df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b1b6bf903b908e98ea861317289a3c15e0bd0df", "patch": "@@ -1,3 +1,8 @@\n+Wed Jul  4 13:40:02 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* emit-rtl.c (change_address): Don't abort if invalid address while\n+\treload is in progress.\n+\n 2001-07-04  Daniel Berlin  <dan@cgsoftware.com>\n \n \t* c-lex.c (cb_file_change): Pass line number to\n@@ -14,14 +19,16 @@\n \t* toplev.h (debug_start_source_file): Add line number to\n \tparameters.\n \t\n-\t* dwarf2out.h (dwarf2out_start_source_file): Add line number to parameters.\n+\t* dwarf2out.h (dwarf2out_start_source_file): Add line number to\n+\tparameters.\n \n \t* dwarf2out.c (dwarf2out_start_source_file): Add line number to\n \tparameters.\n \tOutput debug_macinfo data for starting file if requested. \n \t(dwarf2out_end_source_file): Output debug_macinfo data for ending\n \tfile if requested.\n-\t(dwarf2out_define): Output debug_macinfo data for defining a macro if requested.\n+\t(dwarf2out_define): Output debug_macinfo data for defining a macro\n+\tif requested.\n \t(dwarf2out_undef): Output debug_macinfo data for undefining a\n \tmacro if requested.\n \t(DEBUG_MACINFO_SECTION): New. DWARF2 macro info section name."}, {"sha": "107e75d4cd012f1dd9c583bb0a4260ef4b892d38", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1b6bf903b908e98ea861317289a3c15e0bd0df/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1b6bf903b908e98ea861317289a3c15e0bd0df/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=2b1b6bf903b908e98ea861317289a3c15e0bd0df", "patch": "@@ -1584,9 +1584,13 @@ change_address (memref, mode, addr)\n   if (addr == 0)\n     addr = XEXP (memref, 0);\n \n-  /* If reload is in progress or has completed, ADDR must be valid.\n-     Otherwise, we can call memory_address to make it valid.  */\n-  if (reload_completed || reload_in_progress)\n+  /* If reload is in progress, don't check for validity of the address since we\n+     assume the caller knows what they are doing.  If reload has completed, the\n+     address must be valid.  Otherwise, we call memory_address to make it\n+     valid.  */\n+  if (reload_in_progress)\n+    ;\n+  else if (reload_completed)\n     {\n       if (! memory_address_p (mode, addr))\n \tabort ();"}]}