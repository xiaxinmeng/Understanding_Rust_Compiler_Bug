{"sha": "76a7314dc936394490f2207c45ed76ab248b3da0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZhNzMxNGRjOTM2Mzk0NDkwZjIyMDdjNDVlZDc2YWIyNDhiM2RhMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-11-22T10:14:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-11-22T10:14:21Z"}, "message": "re PR middle-end/78416 (wrong code for division by (u128)~INT64_MAX at -O0)\n\n\tPR middle-end/78416\n\t* expmed.c (expand_divmod): Use wide_int for computation of\n\top1_is_pow2.  Don't set it if op1 is 0.  Formatting fixes.\n\tUse size <= HOST_BITS_PER_WIDE_INT instead of\n\tHOST_BITS_PER_WIDE_INT >= size.\n\n\t* gcc.dg/torture/pr78416.c: New test.\n\nFrom-SVN: r242690", "tree": {"sha": "49f5edae95f070125d3ae2782f39364e76559f75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49f5edae95f070125d3ae2782f39364e76559f75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76a7314dc936394490f2207c45ed76ab248b3da0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a7314dc936394490f2207c45ed76ab248b3da0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a7314dc936394490f2207c45ed76ab248b3da0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a7314dc936394490f2207c45ed76ab248b3da0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b28cb6f0abed5a65534487ca27487675fa4dc18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b28cb6f0abed5a65534487ca27487675fa4dc18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b28cb6f0abed5a65534487ca27487675fa4dc18"}], "stats": {"total": 80, "additions": 57, "deletions": 23}, "files": [{"sha": "0402b3949f3841b3a69815715c611f1b53cf175b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a7314dc936394490f2207c45ed76ab248b3da0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a7314dc936394490f2207c45ed76ab248b3da0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76a7314dc936394490f2207c45ed76ab248b3da0", "patch": "@@ -1,5 +1,11 @@\n 2016-11-22  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/78416\n+\t* expmed.c (expand_divmod): Use wide_int for computation of\n+\top1_is_pow2.  Don't set it if op1 is 0.  Formatting fixes.\n+\tUse size <= HOST_BITS_PER_WIDE_INT instead of\n+\tHOST_BITS_PER_WIDE_INT >= size.\n+\n \tPR tree-optimization/78445\n \t* tree-if-conv.c (tree_if_conversion): If any_pred_load_store or\n \tany_complicated_phi, version loop even if flag_tree_loop_if_convert is"}, {"sha": "fa710565f304652b12fb5239911b4d05e2d94186", "filename": "gcc/expmed.c", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a7314dc936394490f2207c45ed76ab248b3da0/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a7314dc936394490f2207c45ed76ab248b3da0/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=76a7314dc936394490f2207c45ed76ab248b3da0", "patch": "@@ -3994,11 +3994,10 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n   op1_is_constant = CONST_INT_P (op1);\n   if (op1_is_constant)\n     {\n-      unsigned HOST_WIDE_INT ext_op1 = UINTVAL (op1);\n-      if (unsignedp)\n-\text_op1 &= GET_MODE_MASK (mode);\n-      op1_is_pow2 = ((EXACT_POWER_OF_2_OR_ZERO_P (ext_op1)\n-\t\t     || (! unsignedp && EXACT_POWER_OF_2_OR_ZERO_P (-ext_op1))));\n+      wide_int ext_op1 = rtx_mode_t (op1, mode);\n+      op1_is_pow2 = (wi::popcount (ext_op1) == 1\n+\t\t     || (! unsignedp\n+\t\t\t && wi::popcount (wi::neg (ext_op1)) == 1));\n     }\n \n   /*\n@@ -4079,11 +4078,10 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n      not straightforward to generalize this.  Maybe we should make an array\n      of possible modes in init_expmed?  Save this for GCC 2.7.  */\n \n-  optab1 = ((op1_is_pow2 && op1 != const0_rtx)\n+  optab1 = (op1_is_pow2\n \t    ? (unsignedp ? lshr_optab : ashr_optab)\n \t    : (unsignedp ? udiv_optab : sdiv_optab));\n-  optab2 = ((op1_is_pow2 && op1 != const0_rtx)\n-\t    ? optab1\n+  optab2 = (op1_is_pow2 ? optab1\n \t    : (unsignedp ? udivmod_optab : sdivmod_optab));\n \n   for (compute_mode = mode; compute_mode != VOIDmode;\n@@ -4139,10 +4137,15 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n       /* convert_modes may have placed op1 into a register, so we\n \t must recompute the following.  */\n       op1_is_constant = CONST_INT_P (op1);\n-      op1_is_pow2 = (op1_is_constant\n-\t\t     && ((EXACT_POWER_OF_2_OR_ZERO_P (INTVAL (op1))\n-\t\t\t  || (! unsignedp\n-\t\t\t      && EXACT_POWER_OF_2_OR_ZERO_P (-UINTVAL (op1))))));\n+      if (op1_is_constant)\n+\t{\n+\t  wide_int ext_op1 = rtx_mode_t (op1, compute_mode);\n+\t  op1_is_pow2 = (wi::popcount (ext_op1) == 1\n+\t\t\t || (! unsignedp\n+\t\t\t     && wi::popcount (wi::neg (ext_op1)) == 1));\n+\t}\n+      else\n+\top1_is_pow2 = 0;\n     }\n \n   /* If one of the operands is a volatile MEM, copy it into a register.  */\n@@ -4182,10 +4185,10 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\tunsigned HOST_WIDE_INT mh, ml;\n \t\tint pre_shift, post_shift;\n \t\tint dummy;\n-\t\tunsigned HOST_WIDE_INT d = (INTVAL (op1)\n-\t\t\t\t\t    & GET_MODE_MASK (compute_mode));\n+\t\twide_int wd = rtx_mode_t (op1, compute_mode);\n+\t\tunsigned HOST_WIDE_INT d = wd.to_uhwi ();\n \n-\t\tif (EXACT_POWER_OF_2_OR_ZERO_P (d))\n+\t\tif (wi::popcount (wd) == 1)\n \t\t  {\n \t\t    pre_shift = floor_log2 (d);\n \t\t    if (rem_flag)\n@@ -4325,7 +4328,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\telse if (d == -1)\n \t\t  quotient = expand_unop (compute_mode, neg_optab, op0,\n \t\t\t\t\t  tquotient, 0);\n-\t\telse if (HOST_BITS_PER_WIDE_INT >= size\n+\t\telse if (size <= HOST_BITS_PER_WIDE_INT\n \t\t\t && abs_d == HOST_WIDE_INT_1U << (size - 1))\n \t\t  {\n \t\t    /* This case is not handled correctly below.  */\n@@ -4335,6 +4338,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t      goto fail1;\n \t\t  }\n \t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (d)\n+\t\t\t && (size <= HOST_BITS_PER_WIDE_INT || d >= 0)\n \t\t\t && (rem_flag\n \t\t\t     ? smod_pow2_cheap (speed, compute_mode)\n \t\t\t     : sdiv_pow2_cheap (speed, compute_mode))\n@@ -4348,7 +4352,9 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t\t\t\tcompute_mode)\n \t\t\t\t != CODE_FOR_nothing)))\n \t\t  ;\n-\t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d))\n+\t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d)\n+\t\t\t && (size <= HOST_BITS_PER_WIDE_INT\n+\t\t\t     || abs_d != (unsigned HOST_WIDE_INT) d))\n \t\t  {\n \t\t    if (rem_flag)\n \t\t      {\n@@ -4483,7 +4489,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n       case FLOOR_DIV_EXPR:\n       case FLOOR_MOD_EXPR:\n       /* We will come here only for signed operations.  */\n-\tif (op1_is_constant && HOST_BITS_PER_WIDE_INT >= size)\n+\tif (op1_is_constant && size <= HOST_BITS_PER_WIDE_INT)\n \t  {\n \t    unsigned HOST_WIDE_INT mh, ml;\n \t    int pre_shift, lgup, post_shift;\n@@ -4552,9 +4558,8 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t\t\t\t  op0, constm1_rtx), NULL_RTX);\n \t\tt2 = expand_binop (compute_mode, ior_optab, op0, t1, NULL_RTX,\n \t\t\t\t   0, OPTAB_WIDEN);\n-\t\tnsign = expand_shift\n-\t\t  (RSHIFT_EXPR, compute_mode, t2,\n-\t\t   size - 1, NULL_RTX, 0);\n+\t\tnsign = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t\t      size - 1, NULL_RTX, 0);\n \t\tt3 = force_operand (gen_rtx_MINUS (compute_mode, t1, nsign),\n \t\t\t\t    NULL_RTX);\n \t\tt4 = expand_divmod (0, TRUNC_DIV_EXPR, compute_mode, t3, op1,\n@@ -4663,7 +4668,10 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n       case CEIL_MOD_EXPR:\n \tif (unsignedp)\n \t  {\n-\t    if (op1_is_constant && EXACT_POWER_OF_2_OR_ZERO_P (INTVAL (op1)))\n+\t    if (op1_is_constant\n+\t\t&& EXACT_POWER_OF_2_OR_ZERO_P (INTVAL (op1))\n+\t\t&& (size <= HOST_BITS_PER_WIDE_INT\n+\t\t    || INTVAL (op1) >= 0))\n \t      {\n \t\trtx t1, t2, t3;\n \t\tunsigned HOST_WIDE_INT d = INTVAL (op1);\n@@ -4876,7 +4884,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \tbreak;\n \n       case EXACT_DIV_EXPR:\n-\tif (op1_is_constant && HOST_BITS_PER_WIDE_INT >= size)\n+\tif (op1_is_constant && size <= HOST_BITS_PER_WIDE_INT)\n \t  {\n \t    HOST_WIDE_INT d = INTVAL (op1);\n \t    unsigned HOST_WIDE_INT ml;"}, {"sha": "c24012dee07e03739fe7dbc7ba4999eefc8b0322", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a7314dc936394490f2207c45ed76ab248b3da0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a7314dc936394490f2207c45ed76ab248b3da0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=76a7314dc936394490f2207c45ed76ab248b3da0", "patch": "@@ -1,5 +1,8 @@\n 2016-11-22  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/78416\n+\t* gcc.dg/torture/pr78416.c: New test.\n+\n \tPR tree-optimization/78445\n \t* gcc.dg/pr78445.c: New test.\n "}, {"sha": "5028156f4fa16eac8bad4a08fd96cb1e8afe0535", "filename": "gcc/testsuite/gcc.dg/torture/pr78416.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a7314dc936394490f2207c45ed76ab248b3da0/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr78416.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a7314dc936394490f2207c45ed76ab248b3da0/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr78416.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr78416.c?ref=76a7314dc936394490f2207c45ed76ab248b3da0", "patch": "@@ -0,0 +1,17 @@\n+/* PR middle-end/78416 */\n+/* { dg-do run { target int128 } } */\n+\n+int\n+main ()\n+{\n+  unsigned __int128 x;\n+  x = 0xFFFFFFFFFFFFFFFFULL;\n+  x /= ~0x7FFFFFFFFFFFFFFFLL;\n+  if (x != 0)\n+    __builtin_abort ();\n+  x = ~0x7FFFFFFFFFFFFFFELL;\n+  x /= ~0x7FFFFFFFFFFFFFFFLL;\n+  if (x != 1)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}