{"sha": "43c36287976d2cb4d134aff2952eca031c78eb59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNjMzYyODc5NzZkMmNiNGQxMzRhZmYyOTUyZWNhMDMxYzc4ZWI1OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-10-11T17:15:41Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-10-11T17:15:41Z"}, "message": "simplify-rtx.c (simplify_unary_operation_1): Use unsigned arithmetics in masking operations.\n\n\t* simplify-rtx.c (simplify_unary_operation_1): Use unsigned arithmetics\n\tin masking operations.\n\t(simplify_const_unary_operation): Likewise.\n\t(simplify_binary_operation_1): Likewise.\n\t(simplify_const_binary_operation): Likewise.\n\t(simplify_const_relational_operation): Likewise.\n\t(simplify_ternary_operation): Likewise.\n\t(simplify_immed_subreg): Likewise.\n\nFrom-SVN: r165320", "tree": {"sha": "2fd1054b26198d3a286f8b50581cbe51889bed8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fd1054b26198d3a286f8b50581cbe51889bed8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43c36287976d2cb4d134aff2952eca031c78eb59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c36287976d2cb4d134aff2952eca031c78eb59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43c36287976d2cb4d134aff2952eca031c78eb59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c36287976d2cb4d134aff2952eca031c78eb59/comments", "author": null, "committer": null, "parents": [{"sha": "74b90fe2a00d558380d9ae40a309a7b97dc3bdb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b90fe2a00d558380d9ae40a309a7b97dc3bdb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74b90fe2a00d558380d9ae40a309a7b97dc3bdb5"}], "stats": {"total": 147, "additions": 83, "deletions": 64}, "files": [{"sha": "abd433b0db40243f099d6b77c7814c39b16f0a91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43c36287976d2cb4d134aff2952eca031c78eb59/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43c36287976d2cb4d134aff2952eca031c78eb59/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43c36287976d2cb4d134aff2952eca031c78eb59", "patch": "@@ -1,3 +1,14 @@\n+2010-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* simplify-rtx.c (simplify_unary_operation_1): Use unsigned arithmetics\n+\tin masking operations.\n+\t(simplify_const_unary_operation): Likewise.\n+\t(simplify_binary_operation_1): Likewise.\n+\t(simplify_const_binary_operation): Likewise.\n+\t(simplify_const_relational_operation): Likewise.\n+\t(simplify_ternary_operation): Likewise.\n+\t(simplify_immed_subreg): Likewise.\n+\n 2010-10-11  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR middle-end/45862"}, {"sha": "97ff266211ab064e5bbbc6a1672dbf956b796a5c", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 72, "deletions": 64, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43c36287976d2cb4d134aff2952eca031c78eb59/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43c36287976d2cb4d134aff2952eca031c78eb59/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=43c36287976d2cb4d134aff2952eca031c78eb59", "patch": "@@ -813,7 +813,7 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n          than HOST_BITS_PER_WIDE_INT.  */\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && COMPARISON_P (op)\n-\t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE & ~GET_MODE_MASK (mode)) == 0)\n+\t  && (STORE_FLAG_VALUE & ~GET_MODE_MASK (mode)) == 0)\n \treturn rtl_hooks.gen_lowpart_no_emit (mode, op);\n       break;\n \n@@ -912,7 +912,7 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t  || ((GET_MODE_BITSIZE (GET_MODE (op))\n \t       <= HOST_BITS_PER_WIDE_INT)\n \t      && ((nonzero_bits (op, GET_MODE (op))\n-\t\t   & ((HOST_WIDE_INT) 1\n+\t\t   & ((unsigned HOST_WIDE_INT) 1\n \t\t      << (GET_MODE_BITSIZE (GET_MODE (op)) - 1)))\n \t\t  == 0)))\n \treturn op;\n@@ -1330,7 +1330,8 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t      val = arg0;\n \t    }\n \t  else if (GET_MODE_BITSIZE (op_mode) < HOST_BITS_PER_WIDE_INT)\n-\t    val = arg0 & ~((HOST_WIDE_INT) (-1) << GET_MODE_BITSIZE (op_mode));\n+\t    val = arg0 & ~((unsigned HOST_WIDE_INT) (-1)\n+\t\t\t   << GET_MODE_BITSIZE (op_mode));\n \t  else\n \t    return 0;\n \t  break;\n@@ -1349,10 +1350,12 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t  else if (GET_MODE_BITSIZE (op_mode) < HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      val\n-\t\t= arg0 & ~((HOST_WIDE_INT) (-1) << GET_MODE_BITSIZE (op_mode));\n-\t      if (val\n-\t\t  & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (op_mode) - 1)))\n-\t\tval -= (HOST_WIDE_INT) 1 << GET_MODE_BITSIZE (op_mode);\n+\t\t= arg0 & ~((unsigned HOST_WIDE_INT) (-1)\n+\t\t\t   << GET_MODE_BITSIZE (op_mode));\n+\t      if (val & ((unsigned HOST_WIDE_INT) 1\n+\t\t\t << (GET_MODE_BITSIZE (op_mode) - 1)))\n+\t\tval\n+\t\t  -= (unsigned HOST_WIDE_INT) 1 << GET_MODE_BITSIZE (op_mode);\n \t    }\n \t  else\n \t    return 0;\n@@ -1505,9 +1508,9 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t    {\n \t      lv = l1 & GET_MODE_MASK (op_mode);\n \t      if (GET_MODE_BITSIZE (op_mode) < HOST_BITS_PER_WIDE_INT\n-\t\t  && (lv & ((HOST_WIDE_INT) 1\n+\t\t  && (lv & ((unsigned HOST_WIDE_INT) 1\n \t\t\t    << (GET_MODE_BITSIZE (op_mode) - 1))) != 0)\n-\t\tlv -= (HOST_WIDE_INT) 1 << GET_MODE_BITSIZE (op_mode);\n+\t\tlv -= (unsigned HOST_WIDE_INT) 1 << GET_MODE_BITSIZE (op_mode);\n \n \t      hv = HWI_SIGN_EXTEND (lv);\n \t    }\n@@ -1613,13 +1616,14 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t  /* Test against the signed lower bound.  */\n \t  if (width > HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      th = (HOST_WIDE_INT) -1 << (width - HOST_BITS_PER_WIDE_INT - 1);\n+\t      th = (unsigned HOST_WIDE_INT) (-1)\n+\t\t   << (width - HOST_BITS_PER_WIDE_INT - 1);\n \t      tl = 0;\n \t    }\n \t  else\n \t    {\n \t      th = -1;\n-\t      tl = (HOST_WIDE_INT) -1 << (width - 1);\n+\t      tl = (unsigned HOST_WIDE_INT) (-1) << (width - 1);\n \t    }\n \t  real_from_integer (&t, VOIDmode, tl, th, 0);\n \t  if (REAL_VALUES_LESS (x, t))\n@@ -2197,7 +2201,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n       /* Convert multiply by constant power of two into shift unless\n \t we are still generating RTL.  This test is a kludge.  */\n       if (CONST_INT_P (trueop1)\n-\t  && (val = exact_log2 (INTVAL (trueop1))) >= 0\n+\t  && (val = exact_log2 (UINTVAL (trueop1))) >= 0\n \t  /* If the mode is larger than the host word size, and the\n \t     uppermost bit is set, then this isn't a power of two due\n \t     to implicit sign extension.  */\n@@ -2263,7 +2267,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n       if (trueop1 == CONST0_RTX (mode))\n \treturn op0;\n       if (CONST_INT_P (trueop1)\n-\t  && ((INTVAL (trueop1) & GET_MODE_MASK (mode))\n+\t  && ((UINTVAL (trueop1) & GET_MODE_MASK (mode))\n \t      == GET_MODE_MASK (mode)))\n \treturn op1;\n       if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n@@ -2278,7 +2282,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n       /* (ior A C) is C if all bits of A that might be nonzero are on in C.  */\n       if (CONST_INT_P (op1)\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && (nonzero_bits (op0, mode) & ~INTVAL (op1)) == 0)\n+\t  && (nonzero_bits (op0, mode) & ~UINTVAL (op1)) == 0)\n \treturn op1;\n \n       /* Canonicalize (X & C1) | C2.  */\n@@ -2367,12 +2371,12 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t  && GET_CODE (op0) == AND\n \t  && CONST_INT_P (XEXP (op0, 1))\n \t  && CONST_INT_P (op1)\n-\t  && (INTVAL (XEXP (op0, 1)) & INTVAL (op1)) != 0)\n+\t  && (UINTVAL (XEXP (op0, 1)) & UINTVAL (op1)) != 0)\n \treturn simplify_gen_binary (IOR, mode,\n \t\t\t\t    simplify_gen_binary\n \t\t\t\t\t  (AND, mode, XEXP (op0, 0),\n-\t\t\t\t\t   GEN_INT (INTVAL (XEXP (op0, 1))\n-\t\t\t\t\t\t    & ~INTVAL (op1))),\n+\t\t\t\t\t   GEN_INT (UINTVAL (XEXP (op0, 1))\n+\t\t\t\t\t\t    & ~UINTVAL (op1))),\n \t\t\t\t    op1);\n \n       /* If OP0 is (ashiftrt (plus ...) C), it might actually be\n@@ -2405,7 +2409,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n       if (trueop1 == CONST0_RTX (mode))\n \treturn op0;\n       if (CONST_INT_P (trueop1)\n-\t  && ((INTVAL (trueop1) & GET_MODE_MASK (mode))\n+\t  && ((UINTVAL (trueop1) & GET_MODE_MASK (mode))\n \t      == GET_MODE_MASK (mode)))\n \treturn simplify_gen_unary (NOT, mode, op0, mode);\n       if (rtx_equal_p (trueop0, trueop1)\n@@ -2549,7 +2553,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t  && CONST_INT_P (trueop1)\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && (~GET_MODE_MASK (GET_MODE (XEXP (op0, 0)))\n-\t      & INTVAL (trueop1)) == 0)\n+\t      & UINTVAL (trueop1)) == 0)\n \t{\n \t  enum machine_mode imode = GET_MODE (XEXP (op0, 0));\n \t  tem = simplify_gen_binary (AND, imode, XEXP (op0, 0),\n@@ -2630,8 +2634,8 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t (A +- N) & M -> A & M.  */\n       if (CONST_INT_P (trueop1)\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && ~INTVAL (trueop1)\n-\t  && (INTVAL (trueop1) & (INTVAL (trueop1) + 1)) == 0\n+\t  && ~UINTVAL (trueop1)\n+\t  && (UINTVAL (trueop1) & (UINTVAL (trueop1) + 1)) == 0\n \t  && (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS))\n \t{\n \t  rtx pmop[2];\n@@ -2641,7 +2645,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t  pmop[1] = XEXP (op0, 1);\n \n \t  if (CONST_INT_P (pmop[1])\n-\t      && (INTVAL (pmop[1]) & INTVAL (trueop1)) == 0)\n+\t      && (UINTVAL (pmop[1]) & UINTVAL (trueop1)) == 0)\n \t    return simplify_gen_binary (AND, mode, pmop[0], op1);\n \n \t  for (which = 0; which < 2; which++)\n@@ -2651,14 +2655,14 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t\t{\n \t\tcase AND:\n \t\t  if (CONST_INT_P (XEXP (tem, 1))\n-\t\t      && (INTVAL (XEXP (tem, 1)) & INTVAL (trueop1))\n-\t\t      == INTVAL (trueop1))\n+\t\t      && (UINTVAL (XEXP (tem, 1)) & UINTVAL (trueop1))\n+\t\t      == UINTVAL (trueop1))\n \t\t    pmop[which] = XEXP (tem, 0);\n \t\t  break;\n \t\tcase IOR:\n \t\tcase XOR:\n \t\t  if (CONST_INT_P (XEXP (tem, 1))\n-\t\t      && (INTVAL (XEXP (tem, 1)) & INTVAL (trueop1)) == 0)\n+\t\t      && (UINTVAL (XEXP (tem, 1)) & UINTVAL (trueop1)) == 0)\n \t\t    pmop[which] = XEXP (tem, 0);\n \t\t  break;\n \t\tdefault:\n@@ -2704,7 +2708,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \treturn rtl_hooks.gen_lowpart_no_emit (mode, op0);\n       /* Convert divide by power of two into shift.  */\n       if (CONST_INT_P (trueop1)\n-\t  && (val = exact_log2 (INTVAL (trueop1))) > 0)\n+\t  && (val = exact_log2 (UINTVAL (trueop1))) > 0)\n \treturn simplify_gen_binary (LSHIFTRT, mode, op0, GEN_INT (val));\n       break;\n \n@@ -2786,7 +2790,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t}\n       /* Implement modulus by power of two as AND.  */\n       if (CONST_INT_P (trueop1)\n-\t  && exact_log2 (INTVAL (trueop1)) > 0)\n+\t  && exact_log2 (UINTVAL (trueop1)) > 0)\n \treturn simplify_gen_binary (AND, mode, op0,\n \t\t\t\t    GEN_INT (INTVAL (op1) - 1));\n       break;\n@@ -2817,7 +2821,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \treturn op0;\n       /* Rotating ~0 always results in ~0.  */\n       if (CONST_INT_P (trueop0) && width <= HOST_BITS_PER_WIDE_INT\n-\t  && (unsigned HOST_WIDE_INT) INTVAL (trueop0) == GET_MODE_MASK (mode)\n+\t  && UINTVAL (trueop0) == GET_MODE_MASK (mode)\n \t  && ! side_effects_p (op1))\n \treturn op0;\n     canonicalize_shift:\n@@ -2863,7 +2867,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n     case SMIN:\n       if (width <= HOST_BITS_PER_WIDE_INT\n \t  && CONST_INT_P (trueop1)\n-\t  && INTVAL (trueop1) == (HOST_WIDE_INT) 1 << (width -1)\n+\t  && UINTVAL (trueop1) == (unsigned HOST_WIDE_INT) 1 << (width -1)\n \t  && ! side_effects_p (op0))\n \treturn op1;\n       if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n@@ -2876,8 +2880,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n     case SMAX:\n       if (width <= HOST_BITS_PER_WIDE_INT\n \t  && CONST_INT_P (trueop1)\n-\t  && ((unsigned HOST_WIDE_INT) INTVAL (trueop1)\n-\t      == (unsigned HOST_WIDE_INT) GET_MODE_MASK (mode) >> 1)\n+\t  && (UINTVAL (trueop1) == GET_MODE_MASK (mode) >> 1)\n \t  && ! side_effects_p (op0))\n \treturn op1;\n       if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n@@ -3469,16 +3472,16 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n \n       if (width < HOST_BITS_PER_WIDE_INT)\n         {\n-          arg0 &= ((HOST_WIDE_INT) 1 << width) - 1;\n-          arg1 &= ((HOST_WIDE_INT) 1 << width) - 1;\n+          arg0 &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n+          arg1 &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n \n           arg0s = arg0;\n-          if (arg0s & ((HOST_WIDE_INT) 1 << (width - 1)))\n-\t    arg0s |= ((HOST_WIDE_INT) (-1) << width);\n+          if (arg0s & ((unsigned HOST_WIDE_INT) 1 << (width - 1)))\n+\t    arg0s |= ((unsigned HOST_WIDE_INT) (-1) << width);\n \n \t  arg1s = arg1;\n-\t  if (arg1s & ((HOST_WIDE_INT) 1 << (width - 1)))\n-\t    arg1s |= ((HOST_WIDE_INT) (-1) << width);\n+\t  if (arg1s & ((unsigned HOST_WIDE_INT) 1 << (width - 1)))\n+\t    arg1s |= ((unsigned HOST_WIDE_INT) (-1) << width);\n \t}\n       else\n \t{\n@@ -3504,31 +3507,35 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n \n \tcase DIV:\n \t  if (arg1s == 0\n-\t      || (arg0s == (HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)\n+\t      || ((unsigned HOST_WIDE_INT) arg0s\n+\t\t  == (unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)\n \t\t  && arg1s == -1))\n \t    return 0;\n \t  val = arg0s / arg1s;\n \t  break;\n \n \tcase MOD:\n \t  if (arg1s == 0\n-\t      || (arg0s == (HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)\n+\t      || ((unsigned HOST_WIDE_INT) arg0s\n+\t\t  == (unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)\n \t\t  && arg1s == -1))\n \t    return 0;\n \t  val = arg0s % arg1s;\n \t  break;\n \n \tcase UDIV:\n \t  if (arg1 == 0\n-\t      || (arg0s == (HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)\n+\t      || ((unsigned HOST_WIDE_INT) arg0s\n+\t\t  == (unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)\n \t\t  && arg1s == -1))\n \t    return 0;\n \t  val = (unsigned HOST_WIDE_INT) arg0 / arg1;\n \t  break;\n \n \tcase UMOD:\n \t  if (arg1 == 0\n-\t      || (arg0s == (HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)\n+\t      || ((unsigned HOST_WIDE_INT) arg0s\n+\t\t  == (unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)\n \t\t  && arg1s == -1))\n \t    return 0;\n \t  val = (unsigned HOST_WIDE_INT) arg0 % arg1;\n@@ -3567,7 +3574,7 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n \n \t  /* Sign-extend the result for arithmetic right shifts.  */\n \t  if (code == ASHIFTRT && arg0s < 0 && arg1 > 0)\n-\t    val |= ((HOST_WIDE_INT) -1) << (width - arg1);\n+\t    val |= ((unsigned HOST_WIDE_INT) (-1)) << (width - arg1);\n \t  break;\n \n \tcase ROTATERT:\n@@ -4447,14 +4454,14 @@ simplify_const_relational_operation (enum rtx_code code,\n \t we have to sign or zero-extend the values.  */\n       if (width != 0 && width < HOST_BITS_PER_WIDE_INT)\n \t{\n-\t  l0u &= ((HOST_WIDE_INT) 1 << width) - 1;\n-\t  l1u &= ((HOST_WIDE_INT) 1 << width) - 1;\n+\t  l0u &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n+\t  l1u &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n \n-\t  if (l0s & ((HOST_WIDE_INT) 1 << (width - 1)))\n-\t    l0s |= ((HOST_WIDE_INT) (-1) << width);\n+\t  if (l0s & ((unsigned HOST_WIDE_INT) 1 << (width - 1)))\n+\t    l0s |= ((unsigned HOST_WIDE_INT) (-1) << width);\n \n-\t  if (l1s & ((HOST_WIDE_INT) 1 << (width - 1)))\n-\t    l1s |= ((HOST_WIDE_INT) (-1) << width);\n+\t  if (l1s & ((unsigned HOST_WIDE_INT) 1 << (width - 1)))\n+\t    l1s |= ((unsigned HOST_WIDE_INT) (-1) << width);\n \t}\n       if (width != 0 && width <= HOST_BITS_PER_WIDE_INT)\n \th0u = h1u = 0, h0s = HWI_SIGN_EXTEND (l0s), h1s = HWI_SIGN_EXTEND (l1s);\n@@ -4607,8 +4614,9 @@ simplify_const_relational_operation (enum rtx_code code,\n \t    {\n \t      int sign_bitnum = GET_MODE_BITSIZE (mode) - 1;\n \t      int has_sign = (HOST_BITS_PER_WIDE_INT >= sign_bitnum\n-\t\t\t      && (INTVAL (inner_const)\n-\t\t\t\t  & ((HOST_WIDE_INT) 1 << sign_bitnum)));\n+\t\t\t      && (UINTVAL (inner_const)\n+\t\t\t\t  & ((unsigned HOST_WIDE_INT) 1\n+\t\t\t\t     << sign_bitnum)));\n \n \t      switch (code)\n \t\t{\n@@ -4713,32 +4721,32 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n \t  && width <= (unsigned) HOST_BITS_PER_WIDE_INT)\n \t{\n \t  /* Extracting a bit-field from a constant */\n-\t  HOST_WIDE_INT val = INTVAL (op0);\n+\t  unsigned HOST_WIDE_INT val = UINTVAL (op0);\n \n \t  if (BITS_BIG_ENDIAN)\n-\t    val >>= (GET_MODE_BITSIZE (op0_mode)\n-\t\t     - INTVAL (op2) - INTVAL (op1));\n+\t    val >>= GET_MODE_BITSIZE (op0_mode) - INTVAL (op2) - INTVAL (op1);\n \t  else\n \t    val >>= INTVAL (op2);\n \n \t  if (HOST_BITS_PER_WIDE_INT != INTVAL (op1))\n \t    {\n \t      /* First zero-extend.  */\n-\t      val &= ((HOST_WIDE_INT) 1 << INTVAL (op1)) - 1;\n+\t      val &= ((unsigned HOST_WIDE_INT) 1 << INTVAL (op1)) - 1;\n \t      /* If desired, propagate sign bit.  */\n \t      if (code == SIGN_EXTRACT\n-\t\t  && (val & ((HOST_WIDE_INT) 1 << (INTVAL (op1) - 1))))\n-\t\tval |= ~ (((HOST_WIDE_INT) 1 << INTVAL (op1)) - 1);\n+\t\t  && (val & ((unsigned HOST_WIDE_INT) 1 << (INTVAL (op1) - 1)))\n+\t\t     != 0)\n+\t\tval |= ~ (((unsigned HOST_WIDE_INT) 1 << INTVAL (op1)) - 1);\n \t    }\n \n \t  /* Clear the bits that don't belong in our mode,\n \t     unless they and our sign bit are all one.\n \t     So we get either a reasonable negative value or a reasonable\n \t     unsigned value for this mode.  */\n \t  if (width < HOST_BITS_PER_WIDE_INT\n-\t      && ((val & ((HOST_WIDE_INT) (-1) << (width - 1)))\n-\t\t  != ((HOST_WIDE_INT) (-1) << (width - 1))))\n-\t    val &= ((HOST_WIDE_INT) 1 << width) - 1;\n+\t      && ((val & ((unsigned HOST_WIDE_INT) (-1) << (width - 1)))\n+\t\t  != ((unsigned HOST_WIDE_INT) (-1) << (width - 1))))\n+\t    val &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n \n \t  return gen_int_mode (val, mode);\n \t}\n@@ -5096,10 +5104,10 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \t    for (i = 0;\n \t\t i < HOST_BITS_PER_WIDE_INT && i < elem_bitsize;\n \t\t i += value_bit)\n-\t      lo |= (HOST_WIDE_INT)(*vp++ & value_mask) << i;\n+\t      lo |= (unsigned HOST_WIDE_INT)(*vp++ & value_mask) << i;\n \t    for (; i < elem_bitsize; i += value_bit)\n-\t      hi |= ((HOST_WIDE_INT)(*vp++ & value_mask)\n-\t\t     << (i - HOST_BITS_PER_WIDE_INT));\n+\t      hi |= (unsigned HOST_WIDE_INT)(*vp++ & value_mask)\n+\t\t     << (i - HOST_BITS_PER_WIDE_INT);\n \n \t    /* immed_double_const doesn't call trunc_int_for_mode.  I don't\n \t       know why.  */\n@@ -5152,9 +5160,9 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \t    for (i = 0;\n \t\t i < HOST_BITS_PER_WIDE_INT && i < elem_bitsize;\n \t\t i += value_bit)\n-\t      f.data.low |= (HOST_WIDE_INT)(*vp++ & value_mask) << i;\n+\t      f.data.low |= (unsigned HOST_WIDE_INT)(*vp++ & value_mask) << i;\n \t    for (; i < elem_bitsize; i += value_bit)\n-\t      f.data.high |= ((HOST_WIDE_INT)(*vp++ & value_mask)\n+\t      f.data.high |= ((unsigned HOST_WIDE_INT)(*vp++ & value_mask)\n \t\t\t     << (i - HOST_BITS_PER_WIDE_INT));\n \n \t    elems[elem] = CONST_FIXED_FROM_FIXED_VALUE (f, outer_submode);"}]}