{"sha": "0502226c85bddf9ed6eb549770c0dbcabe66a856", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUwMjIyNmM4NWJkZGY5ZWQ2ZWI1NDk3NzBjMGRiY2FiZTY2YTg1Ng==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-02-19T17:50:20Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-02-19T17:50:20Z"}, "message": "(*zeroextract[qs]i_compare0_scratch): Use const_int_operand for operands 1 and 2.\n\n(*zeroextract[qs]i_compare0_scratch): Use const_int_operand\nfor operands 1 and 2.\n(split patterns for aligned memory half-word operations): New patterns.\n(movhi): Handle memory accesses where the alignment is known in a more\nefficient manner.\n(*compareqi_eq0): Use CC_Zmode.\n\nFrom-SVN: r11305", "tree": {"sha": "d759f85ef7b865374941240c97d3981be8f108ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d759f85ef7b865374941240c97d3981be8f108ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0502226c85bddf9ed6eb549770c0dbcabe66a856", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0502226c85bddf9ed6eb549770c0dbcabe66a856", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0502226c85bddf9ed6eb549770c0dbcabe66a856", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0502226c85bddf9ed6eb549770c0dbcabe66a856/comments", "author": null, "committer": null, "parents": [{"sha": "5165176d89089f9c0a0a0d823acc99fb452b6d91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5165176d89089f9c0a0a0d823acc99fb452b6d91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5165176d89089f9c0a0a0d823acc99fb452b6d91"}], "stats": {"total": 165, "additions": 150, "deletions": 15}, "files": [{"sha": "ac701f9e858897fce7ca5e94d7c156ef6797d269", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 150, "deletions": 15, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0502226c85bddf9ed6eb549770c0dbcabe66a856/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0502226c85bddf9ed6eb549770c0dbcabe66a856/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=0502226c85bddf9ed6eb549770c0dbcabe66a856", "patch": "@@ -1012,8 +1012,8 @@\n   [(set (reg:CC_NOOV 24)\n \t(compare:CC_NOOV (zero_extract:SI\n \t\t\t  (match_operand:SI 0 \"s_register_operand\" \"r\")\n-\t\t \t  (match_operand:SI 1 \"immediate_operand\" \"n\")\n-\t\t\t  (match_operand:SI 2 \"immediate_operand\" \"n\"))\n+\t\t \t  (match_operand 1 \"const_int_operand\" \"n\")\n+\t\t\t  (match_operand 2 \"const_int_operand\" \"n\"))\n \t\t\t (const_int 0)))]\n   \"INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) < 32\n    && INTVAL (operands[1]) > 0 \n@@ -1037,8 +1037,8 @@\n   [(set (reg:CC_NOOV 24)\n \t(compare:CC_NOOV (zero_extract:SI\n \t\t\t  (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t\t \t  (match_operand 1 \"immediate_operand\" \"n\")\n-\t\t\t  (match_operand 2 \"immediate_operand\" \"n\"))\n+\t\t\t  (match_operand 1 \"const_int_operand\" \"n\")\n+\t\t\t  (match_operand 2 \"const_int_operand\" \"n\"))\n \t\t\t (const_int 0)))\n    (clobber (match_scratch:QI 3 \"=r\"))]\n   \"INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) < 8\n@@ -1875,6 +1875,36 @@\n   \"ldr%?h\\\\t%0, %1\"\n [(set_attr \"type\" \"load\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:HI 1 \"alignable_memory_operand\" \"\")))\n+   (clobber (match_operand:SI 2 \"s_register_operand\" \"\"))]\n+  \"! arm_arch4\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (lshiftrt:SI (match_dup 2) (const_int 16)))]\n+  \"\n+{\n+  if ((operands[1] = gen_rotated_half_load (operands[1])) == NULL)\n+    FAIL;\n+}\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(match_operator:SI 3 \"shiftable_operator\"\n+\t [(zero_extend:SI (match_operand:HI 1 \"alignable_memory_operand\" \"\"))\n+\t  (match_operand:SI 4 \"s_register_operand\" \"\")]))\n+   (clobber (match_operand:SI 2 \"s_register_operand\" \"\"))]\n+  \"! arm_arch4\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0)\n+\t(match_op_dup 3\n+\t [(lshiftrt:SI (match_dup 2) (const_int 16)) (match_dup 4)]))]\n+  \"\n+{\n+  if ((operands[1] = gen_rotated_half_load (operands[1])) == NULL)\n+    FAIL;\n+}\")\n+\n (define_expand \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n \t(zero_extend:SI\n@@ -1906,8 +1936,8 @@\n   \"\")\n \n (define_insn \"*compareqi_eq0\"\n-  [(set (reg:CC_NOOV 24)\n-\t(compare:CC_NOOV (match_operand:QI 0 \"s_register_operand\" \"r\")\n+  [(set (reg:CC_Z 24)\n+\t(compare:CC_Z (match_operand:QI 0 \"s_register_operand\" \"r\")\n \t\t\t (const_int 0)))]\n   \"\"\n   \"tst\\\\t%0, #255\"\n@@ -1975,6 +2005,36 @@\n   \"ldr%?sh\\\\t%0, %1\"\n [(set_attr \"type\" \"load\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"alignable_memory_operand\" \"\")))\n+   (clobber (match_operand:SI 2 \"s_register_operand\" \"\"))]\n+  \"! arm_arch4\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (ashiftrt:SI (match_dup 2) (const_int 16)))]\n+  \"\n+{\n+  if ((operands[1] = gen_rotated_half_load (operands[1])) == NULL)\n+    FAIL;\n+}\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(match_operator:SI 3 \"shiftable_operator\"\n+\t [(sign_extend:SI (match_operand:HI 1 \"alignable_memory_operand\" \"\"))\n+\t  (match_operand:SI 4 \"s_register_operand\" \"\")]))\n+   (clobber (match_operand:SI 2 \"s_register_operand\" \"\"))]\n+  \"! arm_arch4\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0)\n+\t(match_op_dup 3\n+\t [(ashiftrt:SI (match_dup 2) (const_int 16)) (match_dup 4)]))]\n+  \"\n+{\n+  if ((operands[1] = gen_rotated_half_load (operands[1])) == NULL)\n+    FAIL;\n+}\")\n+\n (define_expand \"extendqihi2\"\n   [(set (match_dup 2)\n \t(ashift:SI (match_operand:QI 1 \"general_operand\" \"\")\n@@ -2366,22 +2426,97 @@\n \t}\n       else if (! arm_arch4)\n \t{\n-\t  if (TARGET_SHORT_BY_BYTES && GET_CODE (operands[1]) == MEM)\n+\t  if (GET_CODE (operands[1]) == MEM)\n \t    {\n-\t      rtx reg = gen_reg_rtx (SImode);\n-\t      emit_insn (gen_movhi_bytes (reg, operands[1]));\n-\t      operands[1] = gen_lowpart (HImode, reg);\n-\t    }\n-\t  else if (BYTES_BIG_ENDIAN && GET_CODE (operands[1]) == MEM)\n-\t    {\n-\t      emit_insn (gen_movhi_bigend (operands[0], operands[1]));\n-\t      DONE;\n+\t      if (TARGET_SHORT_BY_BYTES)\n+\t\t{\n+\t\t  rtx base;\n+\t\t  rtx offset = const0_rtx;\n+\t\t  rtx reg = gen_reg_rtx (SImode);\n+\n+\t\t  if ((GET_CODE (base = XEXP (operands[1], 0)) == REG\n+\t\t       || (GET_CODE (base) == PLUS\n+\t\t\t   && GET_CODE (offset = XEXP (base, 1)) == CONST_INT\n+\t\t\t   && GET_CODE (base = XEXP (base, 0)) == REG))\n+\t\t      && REGNO_POINTER_ALIGN (REGNO (base)) >= 4)\n+\t\t    {\n+\t\t      HOST_WIDE_INT new_offset = INTVAL (offset) & ~2;\n+\n+\t\t      emit_insn (gen_movsi (reg, gen_rtx (MEM, SImode,\n+\t\t\t\t\t   plus_constant (base, new_offset))));\n+\t\t      if (((INTVAL (offset) & 2) != 0)\n+\t\t\t  ^ (BYTES_BIG_ENDIAN ? 1 : 0))\n+\t\t\t{\n+\t\t\t  rtx reg2 = gen_reg_rtx (SImode);\n+\n+\t\t\t  emit_insn (gen_lshrsi3 (reg2, reg, GEN_INT (16)));\n+\t\t\t  reg = reg2;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    emit_insn (gen_movhi_bytes (reg, operands[1]));\n+\n+\t\t  operands[1] = gen_lowpart (HImode, reg);\n+\t\t}\n+\t      else if (BYTES_BIG_ENDIAN)\n+\t\t{\n+\t\t  rtx base;\n+\t\t  rtx offset = const0_rtx;\n+\n+\t\t  if ((GET_CODE (base = XEXP (operands[1], 0)) == REG\n+\t\t       || (GET_CODE (base) == PLUS\n+\t\t\t   && GET_CODE (offset = XEXP (base, 1)) == CONST_INT\n+\t\t\t   && GET_CODE (base = XEXP (base, 0)) == REG))\n+\t\t      && REGNO_POINTER_ALIGN (REGNO (base)) >= 4)\n+\t\t    {\n+\t\t      rtx reg = gen_reg_rtx (SImode);\n+\t\t      rtx new_mem;\n+\n+\t\t      if ((INTVAL (offset) & 2) == 2)\n+\t\t\t{\n+\t\t\t  HOST_WIDE_INT new_offset = INTVAL (offset) ^ 2;\n+\t\t\t  new_mem = gen_rtx (MEM, SImode,\n+\t\t\t\t\t     plus_constant (base, new_offset));\n+\n+\t\t\t  emit_insn (gen_movsi (reg, new_mem));\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  new_mem = gen_rtx (MEM, SImode,\n+\t\t\t\t\t     XEXP (operands[1], 0));\n+\t\t\t  emit_insn (gen_rotated_loadsi (reg, new_mem));\n+\t\t\t}\n+\n+\t\t      operands[1] = gen_lowpart (HImode, reg);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      emit_insn (gen_movhi_bigend (operands[0], operands[1]));\n+\t\t      DONE;\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n     }\n }\n \")\n \n+(define_insn \"rotated_loadsi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(rotate:SI (match_operand:SI 1 \"offsettable_memory_operand\" \"o\")\n+\t\t   (const_int 16)))]\n+  \"! TARGET_SHORT_BY_BYTES\"\n+  \"*\n+{\n+  rtx ops[2];\n+\n+  ops[0] = operands[0];\n+  ops[1] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[1], 0), 2));\n+  output_asm_insn (\\\"ldr%?\\\\t%0, %1\\\\t%@ load-rotate\\\", ops);\n+  return \\\"\\\";\n+}\"\n+[(set_attr \"type\" \"load\")])\n+\n (define_expand \"movhi_bytes\"\n   [(set (match_dup 2) (zero_extend:SI (mem:QI (match_operand:HI 1 \"\" \"\"))))\n    (set (match_dup 3)"}]}