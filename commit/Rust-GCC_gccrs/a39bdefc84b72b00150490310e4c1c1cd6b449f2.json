{"sha": "a39bdefc84b72b00150490310e4c1c1cd6b449f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM5YmRlZmM4NGI3MmIwMDE1MDQ5MDMxMGU0YzFjMWNkNmI0NDlmMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-09-05T08:43:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-05T08:43:13Z"}, "message": "alpha.c (alpha_legitimate_address_p): New.\n\n        * config/alpha/alpha.c (alpha_legitimate_address_p): New.\n        * config/alpha/alpha-protos.h: Declare it.\n        * config/alpha/alpha.h (GO_IF_LEGITIMATE_ADDRESS): Move to c file.\n        (NONSTRICT_REG_OK_FOR_BASE_P): Rename from non-strict macro.\n        (NONSTRICT_REG_OK_FP_BASE_P): Likewise.\n        (STRICT_REG_OK_FOR_BASE_P): Rename from strict macro.\n        (REG_OK_FOR_BASE_P): Select one of the above.\n\nFrom-SVN: r45405", "tree": {"sha": "94e6fdd1dbda205e0dcbd348662c8748bd6fa2a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94e6fdd1dbda205e0dcbd348662c8748bd6fa2a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a39bdefc84b72b00150490310e4c1c1cd6b449f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a39bdefc84b72b00150490310e4c1c1cd6b449f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a39bdefc84b72b00150490310e4c1c1cd6b449f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a39bdefc84b72b00150490310e4c1c1cd6b449f2/comments", "author": null, "committer": null, "parents": [{"sha": "d4fbd953e8930cc804537cc028dc6c5eef9b57dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4fbd953e8930cc804537cc028dc6c5eef9b57dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4fbd953e8930cc804537cc028dc6c5eef9b57dd"}], "stats": {"total": 184, "additions": 106, "deletions": 78}, "files": [{"sha": "7554869b88ff5776d379031821569e1c4c521abc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39bdefc84b72b00150490310e4c1c1cd6b449f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39bdefc84b72b00150490310e4c1c1cd6b449f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a39bdefc84b72b00150490310e4c1c1cd6b449f2", "patch": "@@ -1,3 +1,13 @@\n+2001-09-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (alpha_legitimate_address_p): New.\n+\t* config/alpha/alpha-protos.h: Declare it.\n+\t* config/alpha/alpha.h (GO_IF_LEGITIMATE_ADDRESS): Move to c file.\n+\t(NONSTRICT_REG_OK_FOR_BASE_P): Rename from non-strict macro.\n+\t(NONSTRICT_REG_OK_FP_BASE_P): Likewise.\n+\t(STRICT_REG_OK_FOR_BASE_P): Rename from strict macro.\n+\t(REG_OK_FOR_BASE_P): Select one of the above.\n+\n 2001-09-05  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/t-elf (EXTRA_PARTS): Use EXTRA_MULTILIB_PARTS instead."}, {"sha": "7de2c62d717236332d1bea4f4ad5e39e92eba77a", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39bdefc84b72b00150490310e4c1c1cd6b449f2/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39bdefc84b72b00150490310e4c1c1cd6b449f2/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=a39bdefc84b72b00150490310e4c1c1cd6b449f2", "patch": "@@ -73,6 +73,7 @@ extern int addition_operation PARAMS ((rtx, enum machine_mode));\n extern rtx alpha_tablejump_addr_vec PARAMS ((rtx));\n extern rtx alpha_tablejump_best_label PARAMS ((rtx));\n \n+extern bool alpha_legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n extern rtx alpha_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n extern rtx alpha_legitimize_reload_address PARAMS ((rtx, enum machine_mode,\n \t\t\t\t\t\t    int, int, int));"}, {"sha": "45b6f72472dee5b2d4976621ca5ffcf9abec0e77", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39bdefc84b72b00150490310e4c1c1cd6b449f2/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39bdefc84b72b00150490310e4c1c1cd6b449f2/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=a39bdefc84b72b00150490310e4c1c1cd6b449f2", "patch": "@@ -1154,6 +1154,77 @@ alpha_tablejump_best_label (insn)\n   return best_label ? best_label : const0_rtx;\n }\n \f\n+/* legitimate_address_p recognizes an RTL expression that is a valid\n+   memory address for an instruction.  The MODE argument is the\n+   machine mode for the MEM expression that wants to use this address.\n+\n+   For Alpha, we have either a constant address or the sum of a\n+   register and a constant address, or just a register.  For DImode,\n+   any of those forms can be surrounded with an AND that clear the\n+   low-order three bits; this is an \"unaligned\" access.  */\n+\n+bool\n+alpha_legitimate_address_p (mode, x, strict)\n+     enum machine_mode mode;\n+     rtx x;\n+     int strict;\n+{\n+  /* If this is an ldq_u type address, discard the outer AND.  */\n+  if (mode == DImode\n+      && GET_CODE (x) == AND\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && INTVAL (XEXP (x, 1)) == -8)\n+    x = XEXP (x, 0);\n+\n+  /* Discard non-paradoxical subregs.  */\n+  if (GET_CODE (x) == SUBREG\n+      && (GET_MODE_SIZE (GET_MODE (x))\n+\t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n+    x = SUBREG_REG (x);\n+\n+  /* Unadorned general registers are valid.  */\n+  if (REG_P (x)\n+      && (strict\n+\t  ? STRICT_REG_OK_FOR_BASE_P (x)\n+\t  : NONSTRICT_REG_OK_FOR_BASE_P (x)))\n+    return true;\n+\n+  /* Constant addresses (i.e. +/- 32k) are valid.  */\n+  if (CONSTANT_ADDRESS_P (x))\n+    return true;\n+\n+  /* Register plus a small constant offset is valid.  */\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      rtx ofs = XEXP (x, 1);\n+      x = XEXP (x, 0);\n+\n+      /* Discard non-paradoxical subregs.  */\n+      if (GET_CODE (x) == SUBREG\n+          && (GET_MODE_SIZE (GET_MODE (x))\n+\t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n+\tx = SUBREG_REG (x);\n+\n+      if (REG_P (x))\n+\t{\n+\t  if (! strict\n+\t      && NONSTRICT_REG_OK_FP_BASE_P (x)\n+\t      && GET_CODE (ofs) == CONST_INT)\n+\t    return true;\n+\t  if ((strict\n+\t       ? STRICT_REG_OK_FOR_BASE_P (x)\n+\t       : NONSTRICT_REG_OK_FOR_BASE_P (x))\n+\t      && CONSTANT_ADDRESS_P (ofs))\n+\t    return true;\n+\t}\n+      else if (GET_CODE (x) == ADDRESSOF\n+\t       && GET_CODE (ofs) == CONST_INT)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.  */\n "}, {"sha": "c320701d37d0df2d5433f735339546a2064f4ebb", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 23, "deletions": 77, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39bdefc84b72b00150490310e4c1c1cd6b449f2/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39bdefc84b72b00150490310e4c1c1cd6b449f2/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=a39bdefc84b72b00150490310e4c1c1cd6b449f2", "patch": "@@ -1359,108 +1359,54 @@ do {\t\t\t\t\t\t\\\n    After reload, it makes no difference, since pseudo regs have\n    been eliminated by then.  */\n \n-#ifndef REG_OK_STRICT\n-\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) 0\n \n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X)  \\\n+#define NONSTRICT_REG_OK_FOR_BASE_P(X)  \\\n   (REGNO (X) < 32 || REGNO (X) == 63 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n /* ??? Nonzero if X is the frame pointer, or some virtual register\n    that may eliminate to the frame pointer.  These will be allowed to\n    have offsets greater than 32K.  This is done because register\n    elimination offsets will change the hi/lo split, and if we split\n    before reload, we will require additional instructions.   */\n-#define REG_OK_FP_BASE_P(X)\t\t\t\\\n+#define NONSTRICT_REG_OK_FP_BASE_P(X)\t\t\\\n   (REGNO (X) == 31 || REGNO (X) == 63\t\t\\\n    || (REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n        && REGNO (X) < LAST_VIRTUAL_REGISTER))\n \n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#define REG_OK_FP_BASE_P(X) 0\n+#define STRICT_REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n+#ifdef REG_OK_STRICT\n+#define REG_OK_FOR_BASE_P(X)\tSTRICT_REG_OK_FOR_BASE_P (X)\n+#else\n+#define REG_OK_FOR_BASE_P(X)\tNONSTRICT_REG_OK_FOR_BASE_P (X)\n #endif\n \f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address. \n-\n-   For Alpha, we have either a constant address or the sum of a register\n-   and a constant address, or just a register.  For DImode, any of those\n-   forms can be surrounded with an AND that clear the low-order three bits;\n-   this is an \"unaligned\" access.\n-\n-   First define the basic valid address.  */\n-\n-#define GO_IF_LEGITIMATE_SIMPLE_ADDRESS(MODE, X, ADDR)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx tmp = (X);\t\t\t\t\t\t\t\\\n-  if (GET_CODE (tmp) == SUBREG\t\t\t\t\t\t\\\n-      && (GET_MODE_SIZE (GET_MODE (tmp))\t\t\t\t\\\n-\t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (tmp)))))\t\t\\\n-    tmp = SUBREG_REG (tmp);\t\t\t\t\t\t\\\n-  if (REG_P (tmp) && REG_OK_FOR_BASE_P (tmp))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (CONSTANT_ADDRESS_P (X))\t\t\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      tmp = XEXP (X, 0);\t\t\t\t\t\t\\\n-      if (GET_CODE (tmp) == SUBREG\t\t\t\t\t\\\n-          && (GET_MODE_SIZE (GET_MODE (tmp))\t\t\t\t\\\n-\t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (tmp)))))\t\t\\\n-        tmp = SUBREG_REG (tmp);\t\t\t\t\t\t\\\n-      if (REG_P (tmp))\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (REG_OK_FP_BASE_P (tmp)\t\t\t\t\t\\\n-\t      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t  if (REG_OK_FOR_BASE_P (tmp)\t\t\t\t\t\\\n-\t      && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (tmp) == ADDRESSOF\t\t\t\t\\\n-\t       && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Now accept the simple address, or, for DImode only, an AND of a simple\n-   address that turns off the low three bits.  */\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n+   valid memory address for an instruction.  */\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-{ GO_IF_LEGITIMATE_SIMPLE_ADDRESS (MODE, X, ADDR); \\\n-  if ((MODE) == DImode\t\t\t\t\\\n-      && GET_CODE (X) == AND\t\t\t\\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\\\n-      && INTVAL (XEXP (X, 1)) == -8)\t\t\\\n-    GO_IF_LEGITIMATE_SIMPLE_ADDRESS (MODE, XEXP (X, 0), ADDR); \\\n-}\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\\\n+do {\t\t\t\t\t\t\\\n+  if (alpha_legitimate_address_p (MODE, X, 1))\t\\\n+    goto WIN;\t\t\t\t\t\\\n+} while (0)\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\\\n+do {\t\t\t\t\t\t\\\n+  if (alpha_legitimate_address_p (MODE, X, 0))\t\\\n+    goto WIN;\t\t\t\t\t\\\n+} while (0)\n+#endif\n \n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n+   This macro is used in only one place: `memory_address' in explow.c.  */\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\\\n do {\t\t\t\t\t\t\t\\"}, {"sha": "828024b37a1805cb2b1e78b97a7ab27980c1e138", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39bdefc84b72b00150490310e4c1c1cd6b449f2/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39bdefc84b72b00150490310e4c1c1cd6b449f2/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=a39bdefc84b72b00150490310e4c1c1cd6b449f2", "patch": "@@ -663,7 +663,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (plus:DI (match_operand:DI 1 \"reg_no_subreg_operand\" \"r\")\n \t\t (match_operand:DI 2 \"const_int_operand\" \"n\")))]\n-  \"REG_OK_FP_BASE_P (operands[1])\n+  \"NONSTRICT_REG_OK_FP_BASE_P (operands[1])\n    && INTVAL (operands[2]) >= 0\n    /* This is the largest constant an lda+ldah pair can add, minus\n       an upper bound on the displacement between SP and AP during"}]}