{"sha": "db048faf78eb1d18c9166c7c527c517e1583432e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIwNDhmYWY3OGViMWQxOGM5MTY2YzdjNTI3YzUxN2UxNTgzNDMyZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-31T16:24:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-31T16:24:30Z"}, "message": "alias.c (canon_rtx): Make it global.\n\n\t* alias.c (canon_rtx): Make it global.\n\t(rtx_equal_for_memref_p): CONST_INT equality is now pointer\n\tequality.\n\t* cse.c (struct table_elt): Add canon_exp.\n\t(insert): Clear it.\n\t(invalidate): Canonicalize expressions only once.\n\t* rtl.h (canon_rtx): Declare.\n\nFrom-SVN: r32845", "tree": {"sha": "29733578f10f54be20280e380068194f151ef962", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29733578f10f54be20280e380068194f151ef962"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db048faf78eb1d18c9166c7c527c517e1583432e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db048faf78eb1d18c9166c7c527c517e1583432e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db048faf78eb1d18c9166c7c527c517e1583432e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db048faf78eb1d18c9166c7c527c517e1583432e/comments", "author": null, "committer": null, "parents": [{"sha": "c13e8210479fd194128fed8742d8a491b686a404", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13e8210479fd194128fed8742d8a491b686a404", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13e8210479fd194128fed8742d8a491b686a404"}], "stats": {"total": 93, "additions": 69, "deletions": 24}, "files": [{"sha": "18da14b13d1dda8296013e0c55f1e3582c2d3c53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db048faf78eb1d18c9166c7c527c517e1583432e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db048faf78eb1d18c9166c7c527c517e1583432e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db048faf78eb1d18c9166c7c527c517e1583432e", "patch": "@@ -1,3 +1,13 @@\n+2000-03-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* alias.c (canon_rtx): Make it global.\n+\t(rtx_equal_for_memref_p): CONST_INT equality is now pointer\n+\tequality.\n+\t* cse.c (struct table_elt): Add canon_exp.\n+\t(insert): Clear it.\n+\t(invalidate): Canonicalize expressions only once.\n+\t* rtl.h (canon_rtx): Declare.\n+\n 2000-03-30  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in (emit-rtl.o): Depend on HASHTAB_H."}, {"sha": "db89ecc173e9810f5ccf72f4fb105f7f10704cab", "filename": "gcc/alias.c", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db048faf78eb1d18c9166c7c527c517e1583432e/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db048faf78eb1d18c9166c7c527c517e1583432e/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=db048faf78eb1d18c9166c7c527c517e1583432e", "patch": "@@ -79,7 +79,6 @@ typedef struct alias_set_entry\n   splay_tree children;\n } *alias_set_entry;\n \n-static rtx canon_rtx\t\t\tPARAMS ((rtx));\n static int rtx_equal_for_memref_p\tPARAMS ((rtx, rtx));\n static rtx find_symbolic_term\t\tPARAMS ((rtx));\n static rtx get_addr\t\t\tPARAMS ((rtx));\n@@ -544,7 +543,12 @@ record_base_value (regno, val, invariant)\n   reg_base_value[regno] = find_base_value (val);\n }\n \n-static rtx\n+/* Returns a canonical version of X, from the point of view alias\n+   analysis.  (For example, if X is a MEM whose address is a register,\n+   and the register has a known value (say a SYMBOL_REF), then a MEM\n+   whose address is the SYMBOL_REF is returned.)  */\n+\n+rtx\n canon_rtx (x)\n      rtx x;\n {\n@@ -627,23 +631,32 @@ rtx_equal_for_memref_p (x, y)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n-  /* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */\n-\n-  if (code == REG)\n-    return REGNO (x) == REGNO (y);\n-  if (code == LABEL_REF)\n-    return XEXP (x, 0) == XEXP (y, 0);\n-  if (code == SYMBOL_REF)\n-    return XSTR (x, 0) == XSTR (y, 0);\n-  if (code == CONST_INT)\n-    return INTVAL (x) == INTVAL (y);\n-  /* There's no need to compare the contents of CONST_DOUBLEs because\n-     they're unique. */\n-  if (code == CONST_DOUBLE)\n-    return 0;\n-  if (code == ADDRESSOF)\n-    return (REGNO (XEXP (x, 0)) == REGNO (XEXP (y, 0))\n-\t    && XINT (x, 1) == XINT (y, 1));\n+  /* Some RTL can be compared without a recursive examination.  */\n+  switch (code)\n+    {\n+    case REG:\n+      return REGNO (x) == REGNO (y);\n+\n+    case LABEL_REF:\n+      return XEXP (x, 0) == XEXP (y, 0);\n+      \n+    case SYMBOL_REF:\n+      return XSTR (x, 0) == XSTR (y, 0);\n+\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+      /* There's no need to compare the contents of CONST_DOUBLEs or\n+\t CONST_INTs because pointer equality is a good enough\n+\t comparison for these nodes.  */\n+      return 0;\n+\n+    case ADDRESSOF:\n+      return (REGNO (XEXP (x, 0)) == REGNO (XEXP (y, 0))\n+\t      && XINT (x, 1) == XINT (y, 1));\n+\n+    default:\n+      break;\n+    }\n \n   /* For commutative operations, the RTX match if the operand match in any\n      order.  Also handle the simple binary and unary cases without a loop.  */"}, {"sha": "aa26539fc6949225dcf569d7b4125d3bde7fb41f", "filename": "gcc/cse.c", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db048faf78eb1d18c9166c7c527c517e1583432e/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db048faf78eb1d18c9166c7c527c517e1583432e/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=db048faf78eb1d18c9166c7c527c517e1583432e", "patch": "@@ -408,6 +408,9 @@ static int hash_arg_in_memory;\n    each recording one expression's information.\n    That expression is in the `exp' field.\n \n+   The canon_exp field contains a canonical (from the point of view of\n+   alias analysis) version of the `exp' field.\n+\n    Those elements with the same hash code are chained in both directions\n    through the `next_same_hash' and `prev_same_hash' fields.\n \n@@ -447,6 +450,7 @@ static int hash_arg_in_memory;\n struct table_elt\n {\n   rtx exp;\n+  rtx canon_exp;\n   struct table_elt *next_same_hash;\n   struct table_elt *prev_same_hash;\n   struct table_elt *next_same_value;\n@@ -1498,6 +1502,7 @@ insert (x, classp, hash, mode)\n     }\n \n   elt->exp = x;\n+  elt->canon_exp = NULL_RTX;\n   elt->cost = COST (x);\n   elt->next_same_value = 0;\n   elt->prev_same_value = 0;\n@@ -1823,6 +1828,10 @@ invalidate (x, full_mode)\n       return;\n \n     case MEM:\n+      /* Calculate the canonical version of X here so that\n+\t true_dependence doesn't generate new RTL for X on each call.  */\n+      x = canon_rtx (x);\n+\n       /* Remove all hash table elements that refer to overlapping pieces of\n \t memory.  */\n       if (full_mode == VOIDmode)\n@@ -1835,11 +1844,23 @@ invalidate (x, full_mode)\n \t  for (p = table[i]; p; p = next)\n \t    {\n \t      next = p->next_same_hash;\n-\t      if (p->in_memory\n-\t\t  && (GET_CODE (p->exp) != MEM\n-\t\t      || true_dependence (x, full_mode, p->exp,\n-\t\t\t\t\t  cse_rtx_varies_p)))\n-\t\tremove_from_table (p, i);\n+\t      if (p->in_memory)\n+\t\t{\n+\t\t  if (GET_CODE (p->exp) != MEM)\n+\t\t    remove_from_table (p, i);\n+\t\t  else \n+\t\t    {\n+\t\t      /* Just canonicalize the expression once;\n+\t\t\t otherwise each time we call invalidate\n+\t\t\t true_dependence will canonicalize the\n+\t\t\t expression again.  */\n+\t\t      if (!p->canon_exp)\n+\t\t\tp->canon_exp = canon_rtx (p->exp);\n+\t\t      if (true_dependence (x, full_mode, p->canon_exp,\n+\t\t\t\t\t   cse_rtx_varies_p))\n+\t\t\tremove_from_table (p, i);\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n       return;"}, {"sha": "ec95b4bec436fbc209bcd5ca65e42d099038f2bf", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db048faf78eb1d18c9166c7c527c517e1583432e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db048faf78eb1d18c9166c7c527c517e1583432e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=db048faf78eb1d18c9166c7c527c517e1583432e", "patch": "@@ -1761,6 +1761,7 @@ extern void fancy_abort PARAMS ((const char *, int, const char *))\n #endif\n \n /* In alias.c */\n+extern rtx canon_rtx                    PARAMS ((rtx));\n extern int true_dependence\t\tPARAMS ((rtx, enum machine_mode, rtx,\n \t\t\t\t\t\tint (*)(rtx)));\n extern int read_dependence\t\tPARAMS ((rtx, rtx));"}]}