{"sha": "3e8c4b925a9825fdb8c81f47b621f63108894362", "node_id": "C_kwDOANBUbNoAKDNlOGM0YjkyNWE5ODI1ZmRiOGM4MWY0N2I2MjFmNjMxMDg4OTQzNjI", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-09-15T10:43:16Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-09-16T07:44:42Z"}, "message": "Modernize ix86_builtin_vectorized_function with corresponding expanders.\n\nFor ifloor/lfloor/iceil/lceil/irint/lrint/iround/lround when size of\nin_mode is not equal out_mode, vectorizer doesn't go to internal fn\nway,still left that part in the ix86_builtin_vectorized_function.\n\nRemove others builtins and add corresponding expanders.\n\ngcc/ChangeLog:\n\n\tPR target/106910\n\t* config/i386/i386-builtins.cc\n\t(ix86_builtin_vectorized_function): Modernized with\n\tcorresponding expanders.\n\t* config/i386/sse.md (lrint<mode><sseintvecmodelower>2): New\n\texpander.\n\t(floor<mode>2): Ditto.\n\t(lfloor<mode><sseintvecmodelower>2): Ditto.\n\t(ceil<mode>2): Ditto.\n\t(lceil<mode><sseintvecmodelower>2): Ditto.\n\t(btrunc<mode>2): Ditto.\n\t(lround<mode><sseintvecmodelower>2): Ditto.\n\t(exp2<mode>2): Ditto.", "tree": {"sha": "779d3110db768415119fad8b27f820a9a3f3e35e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/779d3110db768415119fad8b27f820a9a3f3e35e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e8c4b925a9825fdb8c81f47b621f63108894362", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e8c4b925a9825fdb8c81f47b621f63108894362", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e8c4b925a9825fdb8c81f47b621f63108894362", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e8c4b925a9825fdb8c81f47b621f63108894362/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0fc05e86027463eef60ffe16fb8d1fe74acc4e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0fc05e86027463eef60ffe16fb8d1fe74acc4e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0fc05e86027463eef60ffe16fb8d1fe74acc4e8"}], "stats": {"total": 265, "additions": 84, "deletions": 181}, "files": [{"sha": "af2faee245b85a9a3536eb570b45787ea92988c7", "filename": "gcc/config/i386/i386-builtins.cc", "status": "modified", "additions": 4, "deletions": 181, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e8c4b925a9825fdb8c81f47b621f63108894362/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e8c4b925a9825fdb8c81f47b621f63108894362/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc?ref=3e8c4b925a9825fdb8c81f47b621f63108894362", "patch": "@@ -1540,21 +1540,16 @@ ix86_builtin_vectorized_function (unsigned int fn, tree type_out,\n \n   switch (fn)\n     {\n-    CASE_CFN_EXP2:\n-      if (out_mode == SFmode && in_mode == SFmode)\n-\t{\n-\t  if (out_n == 16 && in_n == 16)\n-\t    return ix86_get_builtin (IX86_BUILTIN_EXP2PS);\n-\t}\n-      break;\n-\n     CASE_CFN_IFLOOR:\n     CASE_CFN_LFLOOR:\n-    CASE_CFN_LLFLOOR:\n       /* The round insn does not trap on denormals.  */\n       if (flag_trapping_math || !TARGET_SSE4_1)\n \tbreak;\n \n+      /* PR106910, currently vectorizer doesn't go direct internal fn way\n+\t when out_n != in_n, so let's still keep this.\n+\t Otherwise, it relies on expander of\n+\t lceilmn2/lfloormn2/lroundmn2/lrintmn2.  */\n       if (out_mode == SImode && in_mode == DFmode)\n \t{\n \t  if (out_n == 4 && in_n == 2)\n@@ -1564,20 +1559,10 @@ ix86_builtin_vectorized_function (unsigned int fn, tree type_out,\n \t  else if (out_n == 16 && in_n == 8)\n \t    return ix86_get_builtin (IX86_BUILTIN_FLOORPD_VEC_PACK_SFIX512);\n \t}\n-      if (out_mode == SImode && in_mode == SFmode)\n-\t{\n-\t  if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPS_SFIX);\n-\t  else if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPS_SFIX256);\n-\t  else if (out_n == 16 && in_n == 16)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPS_SFIX512);\n-\t}\n       break;\n \n     CASE_CFN_ICEIL:\n     CASE_CFN_LCEIL:\n-    CASE_CFN_LLCEIL:\n       /* The round insn does not trap on denormals.  */\n       if (flag_trapping_math || !TARGET_SSE4_1)\n \tbreak;\n@@ -1591,20 +1576,10 @@ ix86_builtin_vectorized_function (unsigned int fn, tree type_out,\n \t  else if (out_n == 16 && in_n == 8)\n \t    return ix86_get_builtin (IX86_BUILTIN_CEILPD_VEC_PACK_SFIX512);\n \t}\n-      if (out_mode == SImode && in_mode == SFmode)\n-\t{\n-\t  if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPS_SFIX);\n-\t  else if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPS_SFIX256);\n-\t  else if (out_n == 16 && in_n == 16)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPS_SFIX512);\n-\t}\n       break;\n \n     CASE_CFN_IRINT:\n     CASE_CFN_LRINT:\n-    CASE_CFN_LLRINT:\n       if (out_mode == SImode && in_mode == DFmode)\n \t{\n \t  if (out_n == 4 && in_n == 2)\n@@ -1614,20 +1589,10 @@ ix86_builtin_vectorized_function (unsigned int fn, tree type_out,\n \t  else if (out_n == 16 && in_n == 8)\n \t    return ix86_get_builtin (IX86_BUILTIN_VEC_PACK_SFIX512);\n \t}\n-      if (out_mode == SImode && in_mode == SFmode)\n-\t{\n-\t  if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CVTPS2DQ);\n-\t  else if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CVTPS2DQ256);\n-\t  else if (out_n == 16 && in_n == 16)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CVTPS2DQ512);\n-\t}\n       break;\n \n     CASE_CFN_IROUND:\n     CASE_CFN_LROUND:\n-    CASE_CFN_LLROUND:\n       /* The round insn does not trap on denormals.  */\n       if (flag_trapping_math || !TARGET_SSE4_1)\n \tbreak;\n@@ -1641,150 +1606,8 @@ ix86_builtin_vectorized_function (unsigned int fn, tree type_out,\n \t  else if (out_n == 16 && in_n == 8)\n \t    return ix86_get_builtin (IX86_BUILTIN_ROUNDPD_AZ_VEC_PACK_SFIX512);\n \t}\n-      if (out_mode == SImode && in_mode == SFmode)\n-\t{\n-\t  if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_ROUNDPS_AZ_SFIX);\n-\t  else if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_ROUNDPS_AZ_SFIX256);\n-\t  else if (out_n == 16 && in_n == 16)\n-\t    return ix86_get_builtin (IX86_BUILTIN_ROUNDPS_AZ_SFIX512);\n-\t}\n       break;\n \n-    CASE_CFN_FLOOR:\n-      /* The round insn does not trap on denormals.  */\n-      if (flag_trapping_math || !TARGET_SSE4_1)\n-\tbreak;\n-\n-      if (out_mode == DFmode && in_mode == DFmode)\n-\t{\n-\t  if (out_n == 2 && in_n == 2)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPD);\n-\t  else if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPD256);\n-\t  else if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPD512);\n-\t}\n-      if (out_mode == SFmode && in_mode == SFmode)\n-\t{\n-\t  if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPS);\n-\t  else if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPS256);\n-\t  else if (out_n == 16 && in_n == 16)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPS512);\n-\t}\n-      if (out_mode == HFmode && in_mode == HFmode)\n-\t{\n-\t  /* V8HF/V16HF is supported in ix86_vector_mode_supported_p\n-\t     under TARGET_AVX512FP16, TARGET_AVX512VL is needed here.  */\n-\t  if (out_n < 32 && !TARGET_AVX512VL)\n-\t    break;\n-\n-\t  if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPH);\n-\t  else if (out_n == 16 && in_n == 16)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPH256);\n-\t  else if (out_n == 32 && in_n == 32)\n-\t    return ix86_get_builtin (IX86_BUILTIN_FLOORPH512);\n-\t}\n-      break;\n-\n-    CASE_CFN_CEIL:\n-      /* The round insn does not trap on denormals.  */\n-      if (flag_trapping_math || !TARGET_SSE4_1)\n-\tbreak;\n-\n-      if (out_mode == DFmode && in_mode == DFmode)\n-\t{\n-\t  if (out_n == 2 && in_n == 2)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPD);\n-\t  else if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPD256);\n-\t  else if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPD512);\n-\t}\n-      if (out_mode == SFmode && in_mode == SFmode)\n-\t{\n-\t  if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPS);\n-\t  else if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPS256);\n-\t  else if (out_n == 16 && in_n == 16)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPS512);\n-\t}\n-      if (out_mode == HFmode && in_mode == HFmode)\n-\t{\n-\t  /* V8HF/V16HF is supported in ix86_vector_mode_supported_p\n-\t     under TARGET_AVX512FP16, TARGET_AVX512VL is needed here.  */\n-\t  if (out_n < 32 && !TARGET_AVX512VL)\n-\t    break;\n-\n-\t  if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPH);\n-\t  else if (out_n == 16 && in_n == 16)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPH256);\n-\t  else if (out_n == 32 && in_n == 32)\n-\t    return ix86_get_builtin (IX86_BUILTIN_CEILPH512);\n-\t}\n-      break;\n-\n-    CASE_CFN_TRUNC:\n-      /* The round insn does not trap on denormals.  */\n-      if (flag_trapping_math || !TARGET_SSE4_1)\n-\tbreak;\n-\n-      if (out_mode == DFmode && in_mode == DFmode)\n-\t{\n-\t  if (out_n == 2 && in_n == 2)\n-\t    return ix86_get_builtin (IX86_BUILTIN_TRUNCPD);\n-\t  else if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_TRUNCPD256);\n-\t  else if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_TRUNCPD512);\n-\t}\n-      if (out_mode == SFmode && in_mode == SFmode)\n-\t{\n-\t  if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_TRUNCPS);\n-\t  else if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_TRUNCPS256);\n-\t  else if (out_n == 16 && in_n == 16)\n-\t    return ix86_get_builtin (IX86_BUILTIN_TRUNCPS512);\n-\t}\n-      if (out_mode == HFmode && in_mode == HFmode)\n-\t{\n-\t  /* V8HF/V16HF is supported in ix86_vector_mode_supported_p\n-\t     under TARGET_AVX512FP16, TARGET_AVX512VL is needed here.  */\n-\t  if (out_n < 32 && !TARGET_AVX512VL)\n-\t    break;\n-\n-\t  if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_TRUNCPH);\n-\t  else if (out_n == 16 && in_n == 16)\n-\t    return ix86_get_builtin (IX86_BUILTIN_TRUNCPH256);\n-\t  else if (out_n == 32 && in_n == 32)\n-\t    return ix86_get_builtin (IX86_BUILTIN_TRUNCPH512);\n-\t}\n-      break;\n-\n-    CASE_CFN_FMA:\n-      if (out_mode == DFmode && in_mode == DFmode)\n-\t{\n-\t  if (out_n == 2 && in_n == 2)\n-\t    return ix86_get_builtin (IX86_BUILTIN_VFMADDPD);\n-\t  if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_VFMADDPD256);\n-\t}\n-      if (out_mode == SFmode && in_mode == SFmode)\n-\t{\n-\t  if (out_n == 4 && in_n == 4)\n-\t    return ix86_get_builtin (IX86_BUILTIN_VFMADDPS);\n-\t  if (out_n == 8 && in_n == 8)\n-\t    return ix86_get_builtin (IX86_BUILTIN_VFMADDPS256);\n-\t}\n-      break;\n \n     default:\n       break;"}, {"sha": "b60c0d34855cbe880d9e464f14d8959559a7b2a5", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e8c4b925a9825fdb8c81f47b621f63108894362/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e8c4b925a9825fdb8c81f47b621f63108894362/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=3e8c4b925a9825fdb8c81f47b621f63108894362", "patch": "@@ -321,6 +321,11 @@\n   [(V16SF \"TARGET_AVX512F\") (V8SF \"TARGET_AVX\") V4SF\n    (V8DF \"TARGET_AVX512F\") (V4DF \"TARGET_AVX\") (V2DF \"TARGET_SSE2\")])\n \n+(define_mode_iterator VF1_VF2_AVX512DQ\n+  [(V16SF \"TARGET_AVX512F\") (V8SF \"TARGET_AVX\") V4SF\n+   (V8DF \"TARGET_AVX512DQ\") (V4DF \"TARGET_AVX512DQ && TARGET_AVX512VL\")\n+   (V2DF \"TARGET_AVX512DQ && TARGET_AVX512VL\")])\n+\n (define_mode_iterator VFH\n   [(V32HF \"TARGET_AVX512FP16\")\n    (V16HF \"TARGET_AVX512FP16 && TARGET_AVX512VL\")\n@@ -23177,6 +23182,14 @@\n   \"TARGET_SSE4_1\"\n   \"operands[2] = GEN_INT (ROUND_MXCSR);\")\n \n+;; Note vcvtpd2qq require avx512dq for all vector lengths.\n+(define_expand \"lrint<mode><sseintvecmodelower>2\"\n+  [(set (match_operand:<sseintvecmode> 0 \"register_operand\")\n+\t(unspec:<sseintvecmode>\n+\t  [(match_operand:VF1_VF2_AVX512DQ 1 \"register_operand\")]\n+\t UNSPEC_FIX_NOTRUNC))]\n+ \"TARGET_SSE2\")\n+\n (define_insn \"<sse4_1>_round<ssemodesuffix><avxsizesuffix>\"\n   [(set (match_operand:VF_128_256 0 \"register_operand\" \"=Yr,*x,x\")\n \t(unspec:VF_128_256\n@@ -23316,6 +23329,55 @@\n    (set_attr \"prefix\" \"orig,orig,vex,evex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_expand \"floor<mode>2\"\n+  [(set (match_operand:VFH 0 \"register_operand\")\n+\t(unspec:VFH\n+\t  [(match_operand:VFH 1 \"vector_operand\")\n+\t   (match_dup 2)]\n+\t  UNSPEC_ROUND))]\n+  \"TARGET_SSE4_1 && !flag_trapping_math\"\n+  \"operands[2] = GEN_INT (ROUND_FLOOR | ROUND_NO_EXC);\")\n+\n+(define_expand \"lfloor<mode><sseintvecmodelower>2\"\n+  [(match_operand:<sseintvecmode> 0 \"register_operand\")\n+   (match_operand:VF1_VF2_AVX512DQ 1 \"register_operand\")]\n+ \"TARGET_SSE4_1 && !flag_trapping_math\"\n+{\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_floor<mode>2 (tmp, operands[1]));\n+  emit_insn (gen_fix_trunc<mode><sseintvecmodelower>2 (operands[0], tmp));\n+  DONE;\n+})\n+\n+(define_expand \"ceil<mode>2\"\n+  [(set (match_operand:VFH 0 \"register_operand\")\n+\t(unspec:VFH\n+\t  [(match_operand:VFH 1 \"vector_operand\")\n+\t   (match_dup 2)]\n+\t  UNSPEC_ROUND))]\n+  \"TARGET_SSE4_1 && !flag_trapping_math\"\n+  \"operands[2] = GEN_INT (ROUND_CEIL | ROUND_NO_EXC);\")\n+\n+(define_expand \"lceil<mode><sseintvecmodelower>2\"\n+  [(match_operand:<sseintvecmode> 0 \"register_operand\")\n+   (match_operand:VF1_VF2_AVX512DQ 1 \"register_operand\")]\n+ \"TARGET_SSE4_1 && !flag_trapping_math\"\n+{\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_ceil<mode>2 (tmp, operands[1]));\n+  emit_insn (gen_fix_trunc<mode><sseintvecmodelower>2 (operands[0], tmp));\n+  DONE;\n+})\n+\n+(define_expand \"btrunc<mode>2\"\n+  [(set (match_operand:VFH 0 \"register_operand\")\n+\t(unspec:VFH\n+\t  [(match_operand:VFH 1 \"vector_operand\")\n+\t   (match_dup 2)]\n+\t  UNSPEC_ROUND))]\n+  \"TARGET_SSE4_1 && !flag_trapping_math\"\n+  \"operands[2] = GEN_INT (ROUND_TRUNC | ROUND_NO_EXC);\")\n+\n (define_expand \"round<mode>2\"\n   [(set (match_dup 3)\n \t(plus:VF\n@@ -23350,6 +23412,17 @@\n   operands[4] = GEN_INT (ROUND_TRUNC);\n })\n \n+(define_expand \"lround<mode><sseintvecmodelower>2\"\n+  [(match_operand:<sseintvecmode> 0 \"register_operand\")\n+   (match_operand:VF1_VF2_AVX512DQ 1 \"register_operand\")]\n+ \"TARGET_SSE4_1 && !flag_trapping_math\"\n+{\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_round<mode>2 (tmp, operands[1]));\n+  emit_insn (gen_fix_trunc<mode><sseintvecmodelower>2 (operands[0], tmp));\n+  DONE;\n+})\n+\n (define_expand \"round<mode>2_sfix\"\n   [(match_operand:<sseintvecmode> 0 \"register_operand\")\n    (match_operand:VF1 1 \"register_operand\")]\n@@ -23868,6 +23941,13 @@\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"XI\")])\n \n+(define_expand \"exp2<mode>2\"\n+  [(set (match_operand:VF_512 0 \"register_operand\")\n+\t(unspec:VF_512\n+\t  [(match_operand:VF_512 1 \"vector_operand\")]\n+\t  UNSPEC_EXP2))]\n+  \"TARGET_AVX512ER\")\n+\n (define_insn \"avx512er_exp2<mode><mask_name><round_saeonly_name>\"\n   [(set (match_operand:VF_512 0 \"register_operand\" \"=v\")\n \t(unspec:VF_512"}]}