{"sha": "c203255aba10d807f68097646f4aeb3feaf2cb48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIwMzI1NWFiYTEwZDgwN2Y2ODA5NzY0NmY0YWViM2ZlYWYyY2I0OA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-09-11T16:44:39Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-09-11T16:44:39Z"}, "message": "natFilePosix.cc (getCanonicalPath): Handle case where file does not exist.\n\n\t* java/io/natFilePosix.cc (getCanonicalPath): Handle case where\n\tfile does not exist.\n\nFrom-SVN: r71307", "tree": {"sha": "2bd1b3aa7b8c77927fd3714436e9b3f883b1fc83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bd1b3aa7b8c77927fd3714436e9b3f883b1fc83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c203255aba10d807f68097646f4aeb3feaf2cb48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c203255aba10d807f68097646f4aeb3feaf2cb48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c203255aba10d807f68097646f4aeb3feaf2cb48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c203255aba10d807f68097646f4aeb3feaf2cb48/comments", "author": null, "committer": null, "parents": [{"sha": "92af500d3e3f3ae08792a6e4446356321ec3ae65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92af500d3e3f3ae08792a6e4446356321ec3ae65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92af500d3e3f3ae08792a6e4446356321ec3ae65"}], "stats": {"total": 69, "additions": 68, "deletions": 1}, "files": [{"sha": "8a633e6483aff4033f63c12a5481759a58c76771", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203255aba10d807f68097646f4aeb3feaf2cb48/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203255aba10d807f68097646f4aeb3feaf2cb48/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c203255aba10d807f68097646f4aeb3feaf2cb48", "patch": "@@ -1,3 +1,8 @@\n+2003-09-11  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/io/natFilePosix.cc (getCanonicalPath): Handle case where\n+\tfile does not exist.\n+\n 2003-09-10  Anthony Green  <green@redhat.com>\n \n \t* gnu/java/net/natPlainDatagramSocketImplWin32.cc (peekData):"}, {"sha": "a1eb1c74b80424455eeff26e81bfd6f4718579dc", "filename": "libjava/java/io/natFilePosix.cc", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203255aba10d807f68097646f4aeb3feaf2cb48/libjava%2Fjava%2Fio%2FnatFilePosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203255aba10d807f68097646f4aeb3feaf2cb48/libjava%2Fjava%2Fio%2FnatFilePosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFilePosix.cc?ref=c203255aba10d807f68097646f4aeb3feaf2cb48", "patch": "@@ -118,7 +118,69 @@ java::io::File::getCanonicalPath (void)\n \n #ifdef HAVE_REALPATH\n   if (realpath (buf, buf2) == NULL)\n-    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+    {\n+      // If realpath failed, we have to come up with a canonical path\n+      // anyway.  We do this with purely textual manipulation.\n+      // FIXME: this isn't perfect.  You can construct a case where\n+      // we get a different answer from the JDK:\n+      // mkdir -p /tmp/a/b/c\n+      // ln -s /tmp/a/b /tmp/a/z\n+      // ... getCanonicalPath(\"/tmp/a/z/c/nosuchfile\")\n+      // We will give /tmp/a/z/c/nosuchfile, while the JDK will\n+      // give /tmp/a/b/c/nosuchfile.\n+      int out_idx;\n+      if (buf[0] != '/')\n+\t{\n+\t  // Not absolute, so start with current directory.\n+\t  if (getcwd (buf2, sizeof (buf2)) == NULL)\n+\t    throw new IOException ();\n+\t  out_idx = strlen (buf2);\n+\t}\n+      else\n+\t{\n+\t  buf2[0] = '/';\n+\t  out_idx = 1;\n+\t} \n+      int in_idx = 0;\n+      while (buf[in_idx] != '\\0')\n+\t{\n+\t  // Skip '/'s.\n+\t  while (buf[in_idx] == '/')\n+\t    ++in_idx;\n+\t  int elt_start = in_idx;\n+\t  // Find next '/' or end of path.\n+\t  while (buf[in_idx] != '\\0' && buf[in_idx] != '/')\n+\t    ++in_idx;\n+\t  if (in_idx == elt_start)\n+\t    {\n+\t      // An empty component means we've reached the end.\n+\t      break;\n+\t    }\n+\t  int len = in_idx - elt_start;\n+\t  if (len == 1 && buf[in_idx] == '.')\n+\t    continue;\n+\t  if (len == 2 && buf[in_idx] == '.' && buf[in_idx + 1] == '.')\n+\t    {\n+\t      // Found \"..\" component, lop off last part from existing\n+\t      // buffer.\n+\t      --out_idx;\n+\t      while (out_idx > 0 && buf[out_idx] != '/')\n+\t\t--out_idx;\n+\t      // Can't go up past \"/\".\n+\t      if (out_idx == 0)\n+\t\t++out_idx;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Append a real path component to the output.\n+\t      if (out_idx > 1)\n+\t\tbuf2[out_idx++] = '/';\n+\t      strncpy (&buf2[out_idx], &buf[elt_start], len);\n+\t      out_idx += len;\n+\t    }\n+\t}\n+      buf[out_idx] = '\\0';\n+    }\n \n   // FIXME: what encoding to assume for file names?  This affects many\n   // calls."}]}