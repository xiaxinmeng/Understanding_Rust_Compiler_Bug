{"sha": "eab511df13ca6abb24c3c2abb0f420a89c91e310", "node_id": "C_kwDOANBUbNoAKGVhYjUxMWRmMTNjYTZhYmIyNGMzYzJhYmIwZjQyMGE4OWM5MWUzMTA", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-09-02T13:00:14Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-09-02T13:00:14Z"}, "message": "vect: Ensure SLP nodes don't end up in multiple BB partitions [PR106787]\n\nIn the PR we have two REDUC_PLUS SLP instances that share a common\nload of stride 4.  Each instance also has a unique contiguous load.\n\nInitially all three loads are out of order, so have a nontrivial\nload permutation.  The layout pass puts them in order instead,\nFor the two contiguous loads it is possible to do this by adjusting the\nSLP_LOAD_PERMUTATION to be { 0, 1, 2, 3 }.  But a SLP_LOAD_PERMUTATION\nof { 0, 4, 8, 12 } is rejected as unsupported, so the pass creates a\nseparate VEC_PERM_EXPR instead.\n\nLater the 4-stride load's initial SLP_LOAD_PERMUTATION is rejected too,\nso that the load gets replaced by an external node built from scalars.\nWe then have an external node feeding a VEC_PERM_EXPR.\n\nVEC_PERM_EXPRs created in this way do not have any associated\nSLP_TREE_SCALAR_STMTS.  This means that they do not affect the\ndecision about which nodes should be in which subgraph for costing\npurposes.  If the VEC_PERM_EXPR is fed by a vect_external_def,\nthen the VEC_PERM_EXPR's input doesn't affect that decision either.\n\nThe net effect is that a shared VEC_PERM_EXPR fed by an external def\ncan appear in more than one subgraph.  This triggered an ICE in\nvect_schedule_node, which (rightly) expects to be called no more\nthan once for the same internal def.\n\nThere seemed to be many possible fixes, including:\n\n(1) Replace unsupported loads with external defs *before* doing\n    the layout optimisation.  This would avoid the need for the\n    VEC_PERM_EXPR altogether.\n\n(2) If the target doesn't support a load in its original layout,\n    stop the layout optimisation from checking whether the target\n    supports loads in any new candidate layout.  In other words,\n    treat all layouts as if they were supported whenever the\n    original layout is not in fact supported.\n\n    I'd rather not do this.  In principle, the layout optimisation\n    could convert an unsupported layout to a supported one.\n    Selectively ignoring target support would work against that.\n\n    We could try to look specifically for loads that will need\n    to be decomposed, but that just seems like admitting that\n    things are happening in the wrong order.\n\n(3) Add SLP_TREE_SCALAR_STMTS to VEC_PERM_EXPRs.\n\n    That would be OK for this case, but wouldn't be possible\n    for external defs that represent existing vectors.\n\n(4) Make vect_schedule_slp share SCC info between subgraphs.\n\n    It feels like that's working around the partitioning problem\n    rather than a real fix though.\n\n(5) Directly ensure that internal def nodes belong to a single\n    subgraph.\n\n(1) is probably the best long-term fix, but (5) is much simpler.\nThe subgraph partitioning code already has a hash set to record\nwhich nodes have been visited; we just need to convert that to a\nmap from nodes to instances instead.\n\ngcc/\n\tPR tree-optimization/106787\n\t* tree-vect-slp.cc (vect_map_to_instance): New function, split out\n\tfrom...\n\t(vect_bb_partition_graph_r): ...here.  Replace the visited set\n\twith a map from nodes to instances.  Ensure that a node only\n\tappears in one partition.\n\t(vect_bb_partition_graph): Update accordingly.\n\ngcc/testsuite/\n\t* gcc.dg/vect/bb-slp-layout-19.c: New test.", "tree": {"sha": "b4b1af4bb20cbdea497d90e5a584157e13d7c0fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4b1af4bb20cbdea497d90e5a584157e13d7c0fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eab511df13ca6abb24c3c2abb0f420a89c91e310", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab511df13ca6abb24c3c2abb0f420a89c91e310", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eab511df13ca6abb24c3c2abb0f420a89c91e310", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab511df13ca6abb24c3c2abb0f420a89c91e310/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "805c91843f2f8fc73d17a07d1545cc6ddcbd8935", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/805c91843f2f8fc73d17a07d1545cc6ddcbd8935", "html_url": "https://github.com/Rust-GCC/gccrs/commit/805c91843f2f8fc73d17a07d1545cc6ddcbd8935"}], "stats": {"total": 103, "additions": 77, "deletions": 26}, "files": [{"sha": "f075a83a25ba618550caba33e85449bcbda356d5", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-19.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab511df13ca6abb24c3c2abb0f420a89c91e310/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab511df13ca6abb24c3c2abb0f420a89c91e310/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-19.c?ref=eab511df13ca6abb24c3c2abb0f420a89c91e310", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fno-tree-loop-vectorize\" } */\n+\n+extern int a[][4], b[][4], c[][4], d[4], e[4];\n+void f()\n+{\n+  int t0 = a[0][3];\n+  int t1 = a[1][3];\n+  int t2 = a[2][3];\n+  int t3 = a[3][3];\n+  int a0 = 0, a1 = 0, a2 = 0, a3 = 0, b0 = 0, b1 = 0, b2 = 0, b3 = 0;\n+  for (int j = 0; j < 100; ++j)\n+    for (int i = 0; i < 400; i += 4)\n+      {\n+\ta0 += b[i][3] * t0;\n+\ta1 += b[i][2] * t1;\n+\ta2 += b[i][1] * t2;\n+\ta3 += b[i][0] * t3;\n+\tb0 += c[i][3] * t0;\n+\tb1 += c[i][2] * t1;\n+\tb2 += c[i][1] * t2;\n+\tb3 += c[i][0] * t3;\n+      }\n+  d[0] = a0;\n+  d[1] = a1;\n+  d[2] = a2;\n+  d[3] = a3;\n+  e[0] = b0;\n+  e[1] = b1;\n+  e[2] = b2;\n+  e[3] = b3;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 3 \"slp1\" { target { vect_int_mult && vect_perm } } } } */"}, {"sha": "59ec66a6f9602ed1ef3f34e469cf51e91e327fa9", "filename": "gcc/tree-vect-slp.cc", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab511df13ca6abb24c3c2abb0f420a89c91e310/gcc%2Ftree-vect-slp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab511df13ca6abb24c3c2abb0f420a89c91e310/gcc%2Ftree-vect-slp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.cc?ref=eab511df13ca6abb24c3c2abb0f420a89c91e310", "patch": "@@ -6435,47 +6435,64 @@ get_ultimate_leader (slp_instance instance,\n   return instance;\n }\n \n+namespace {\n+/* Subroutine of vect_bb_partition_graph_r.  Map KEY to INSTANCE in\n+   KEY_TO_INSTANCE, making INSTANCE the leader of any previous mapping\n+   for KEY.  Return true if KEY was already in KEY_TO_INSTANCE.\n+\n+   INSTANCE_LEADER is as for get_ultimate_leader.  */\n+\n+template<typename T>\n+bool\n+vect_map_to_instance (slp_instance instance, T key,\n+\t\t      hash_map<T, slp_instance> &key_to_instance,\n+\t\t      hash_map<slp_instance, slp_instance> &instance_leader)\n+{\n+  bool existed_p;\n+  slp_instance &key_instance = key_to_instance.get_or_insert (key, &existed_p);\n+  if (!existed_p)\n+    ;\n+  else if (key_instance != instance)\n+    {\n+      /* If we're running into a previously marked key make us the\n+\t leader of the current ultimate leader.  This keeps the\n+\t leader chain acyclic and works even when the current instance\n+\t connects two previously independent graph parts.  */\n+      slp_instance key_leader\n+\t= get_ultimate_leader (key_instance, instance_leader);\n+      if (key_leader != instance)\n+\tinstance_leader.put (key_leader, instance);\n+    }\n+  key_instance = instance;\n+  return existed_p;\n+}\n+}\n+\n /* Worker of vect_bb_partition_graph, recurse on NODE.  */\n \n static void\n vect_bb_partition_graph_r (bb_vec_info bb_vinfo,\n \t\t\t   slp_instance instance, slp_tree node,\n \t\t\t   hash_map<stmt_vec_info, slp_instance> &stmt_to_instance,\n-\t\t\t   hash_map<slp_instance, slp_instance> &instance_leader,\n-\t\t\t   hash_set<slp_tree> &visited)\n+\t\t\t   hash_map<slp_tree, slp_instance> &node_to_instance,\n+\t\t\t   hash_map<slp_instance, slp_instance> &instance_leader)\n {\n   stmt_vec_info stmt_info;\n   unsigned i;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n-    {\n-      bool existed_p;\n-      slp_instance &stmt_instance\n-\t= stmt_to_instance.get_or_insert (stmt_info, &existed_p);\n-      if (!existed_p)\n-\t;\n-      else if (stmt_instance != instance)\n-\t{\n-\t  /* If we're running into a previously marked stmt make us the\n-\t     leader of the current ultimate leader.  This keeps the\n-\t     leader chain acyclic and works even when the current instance\n-\t     connects two previously independent graph parts.  */\n-\t  slp_instance stmt_leader\n-\t    = get_ultimate_leader (stmt_instance, instance_leader);\n-\t  if (stmt_leader != instance)\n-\t    instance_leader.put (stmt_leader, instance);\n-\t}\n-      stmt_instance = instance;\n-    }\n+    vect_map_to_instance (instance, stmt_info, stmt_to_instance,\n+\t\t\t  instance_leader);\n \n-  if (!SLP_TREE_SCALAR_STMTS (node).is_empty () && visited.add (node))\n+  if (vect_map_to_instance (instance, node, node_to_instance,\n+\t\t\t    instance_leader))\n     return;\n \n   slp_tree child;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     if (child && SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n       vect_bb_partition_graph_r (bb_vinfo, instance, child, stmt_to_instance,\n-\t\t\t\t instance_leader, visited);\n+\t\t\t\t node_to_instance, instance_leader);\n }\n \n /* Partition the SLP graph into pieces that can be costed independently.  */\n@@ -6489,16 +6506,16 @@ vect_bb_partition_graph (bb_vec_info bb_vinfo)\n      corresponding SLP graph entry and upon visiting a previously\n      marked stmt, make the stmts leader the current SLP graph entry.  */\n   hash_map<stmt_vec_info, slp_instance> stmt_to_instance;\n+  hash_map<slp_tree, slp_instance> node_to_instance;\n   hash_map<slp_instance, slp_instance> instance_leader;\n-  hash_set<slp_tree> visited;\n   slp_instance instance;\n   for (unsigned i = 0; bb_vinfo->slp_instances.iterate (i, &instance); ++i)\n     {\n       instance_leader.put (instance, instance);\n       vect_bb_partition_graph_r (bb_vinfo,\n \t\t\t\t instance, SLP_INSTANCE_TREE (instance),\n-\t\t\t\t stmt_to_instance, instance_leader,\n-\t\t\t\t visited);\n+\t\t\t\t stmt_to_instance, node_to_instance,\n+\t\t\t\t instance_leader);\n     }\n \n   /* Then collect entries to each independent subgraph.  */"}]}