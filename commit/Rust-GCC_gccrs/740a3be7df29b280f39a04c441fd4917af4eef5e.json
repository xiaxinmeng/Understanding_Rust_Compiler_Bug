{"sha": "740a3be7df29b280f39a04c441fd4917af4eef5e", "node_id": "C_kwDOANBUbNoAKDc0MGEzYmU3ZGYyOWIyODBmMzlhMDRjNDQxZmQ0OTE3YWY0ZWVmNWU", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2023-02-08T13:40:29Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2023-02-08T13:40:29Z"}, "message": "vect: Check gather/scatter offset types [PR108316]\n\nThe gather/scatter support can over-widen an offset if the target\nrequires it, but this relies on using a pattern sequence to add\nthe widening conversion.  That failed in the testcase because an\nearlier pattern (bool) took priority.\n\nI think we should allow patterns to be applied to other patterns,\nbut that's quite an invasive change and isn't suitable for stage 4.\nThis patch instead punts if the offset type doesn't match the\nexpected one.\n\nIf we switched to using the SLP representation for everything,\nwe would probably handle both patterns by rewriting the graph,\nwhich should be much easier.\n\ngcc/\n\tPR tree-optimization/108316\n\t* tree-vect-stmts.cc (get_load_store_type): When using\n\tinternal functions for gather/scatter, make sure that the type\n\tof the offset argument is consistent with the offset vector type.\n\ngcc/testsuite/\n\tPR tree-optimization/108316\n\t* gcc.dg/vect/pr108316.c: New test.", "tree": {"sha": "25cb8a000f468c1295b8534db91a636c8a3d4038", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25cb8a000f468c1295b8534db91a636c8a3d4038"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/740a3be7df29b280f39a04c441fd4917af4eef5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740a3be7df29b280f39a04c441fd4917af4eef5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/740a3be7df29b280f39a04c441fd4917af4eef5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740a3be7df29b280f39a04c441fd4917af4eef5e/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad2bd0ad0413c2448fee0d4a062dd52ca8a75e8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2bd0ad0413c2448fee0d4a062dd52ca8a75e8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad2bd0ad0413c2448fee0d4a062dd52ca8a75e8c"}], "stats": {"total": 28, "additions": 28, "deletions": 0}, "files": [{"sha": "540b7f2aed46a138aacc9d1629ab055dd36b2559", "filename": "gcc/testsuite/gcc.dg/vect/pr108316.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740a3be7df29b280f39a04c441fd4917af4eef5e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr108316.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740a3be7df29b280f39a04c441fd4917af4eef5e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr108316.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr108316.c?ref=740a3be7df29b280f39a04c441fd4917af4eef5e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+extern _Bool a[];\n+\n+void\n+foo (short i, int b[][64][1])\n+{\n+  for (; i < 64; i += 4)\n+    a[i] = b[0][i] != 0;\n+}"}, {"sha": "c86249adcc399a93ec31c4b296589aaba6386a5c", "filename": "gcc/tree-vect-stmts.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740a3be7df29b280f39a04c441fd4917af4eef5e/gcc%2Ftree-vect-stmts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740a3be7df29b280f39a04c441fd4917af4eef5e/gcc%2Ftree-vect-stmts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.cc?ref=740a3be7df29b280f39a04c441fd4917af4eef5e", "patch": "@@ -2474,6 +2474,23 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n       *memory_access_type = VMAT_GATHER_SCATTER;\n       if (!vect_check_gather_scatter (stmt_info, loop_vinfo, gs_info))\n \tgcc_unreachable ();\n+      /* When using internal functions, we rely on pattern recognition\n+\t to convert the type of the offset to the type that the target\n+\t requires, with the result being a call to an internal function.\n+\t If that failed for some reason (e.g. because another pattern\n+\t took priority), just handle cases in which the offset already\n+\t has the right type.  */\n+      else if (gs_info->ifn != IFN_LAST\n+\t       && !is_gimple_call (stmt_info->stmt)\n+\t       && !tree_nop_conversion_p (TREE_TYPE (gs_info->offset),\n+\t\t\t\t\t  TREE_TYPE (gs_info->offset_vectype)))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"%s offset requires a conversion\\n\",\n+\t\t\t     vls_type == VLS_LOAD ? \"gather\" : \"scatter\");\n+\t  return false;\n+\t}\n       else if (!vect_is_simple_use (gs_info->offset, vinfo,\n \t\t\t\t    &gs_info->offset_dt,\n \t\t\t\t    &gs_info->offset_vectype))"}]}