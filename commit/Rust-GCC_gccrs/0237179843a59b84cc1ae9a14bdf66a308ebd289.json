{"sha": "0237179843a59b84cc1ae9a14bdf66a308ebd289", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIzNzE3OTg0M2E1OWI4NGNjMWFlOWExNGJkZjY2YTMwOGViZDI4OQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2013-07-19T11:10:08Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2013-07-19T11:10:08Z"}, "message": "re PR target/57516 ([avr] Incorrect fixed-point rounding result in the overflow case)\n\ngcc/\n\tPR target/57516\n\t* config/avr/avr-fixed.md (round<mode>3_const): Turn expander to insn.\n\t* config/avr/avr.md (adjust_len): Add `round'.\n\t* config/avr/avr-protos.h (avr_out_round): New prototype.\n\t(avr_out_plus): Add `out_label' argument.\n\t* config/avr/avr.c (avr_out_plus_1): Add `out_label' argument.\n\t(avr_out_plus): Pass down `out_label' to avr_out_plus_1.\n\tHandle the case where `insn' is just a pattern.\n\t(avr_out_bitop): Handle the case where `insn' is just a pattern.\n\t(avr_out_round): New function.\n\t(avr_adjust_insn_length): Handle ADJUST_LEN_ROUND.\n\nlibgcc/\n\tPR target/57516\n\t* config/avr/lib1funcs-fixed.S (__roundqq3, __rounduqq3)\n\t(__round_s2_const, __round_u2_const)\n\t(__round_s4_const, __round_u4_const, __round_x8):\n\tSaturate result if addition result cannot be represented.\n\ngcc/testsuite/\n\tPR target/57516\n\t* gcc.target/avr/torture/builtins-4-roundfx.c (test2hr, test2k):\n\tAdjust to corrected rounding.\n\nFrom-SVN: r201051", "tree": {"sha": "aec31c0be57cb1d48958052153b5c54d7e94476e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aec31c0be57cb1d48958052153b5c54d7e94476e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0237179843a59b84cc1ae9a14bdf66a308ebd289", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0237179843a59b84cc1ae9a14bdf66a308ebd289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0237179843a59b84cc1ae9a14bdf66a308ebd289", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0237179843a59b84cc1ae9a14bdf66a308ebd289/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1545921d63fe20ebe99a3280728ec33c99f8af78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1545921d63fe20ebe99a3280728ec33c99f8af78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1545921d63fe20ebe99a3280728ec33c99f8af78"}], "stats": {"total": 256, "additions": 167, "deletions": 89}, "files": [{"sha": "1810dbeccb8a04dc48be1713ee0816089aa75fba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0237179843a59b84cc1ae9a14bdf66a308ebd289", "patch": "@@ -1,3 +1,17 @@\n+2013-07-19  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/57516\n+\t* config/avr/avr-fixed.md (round<mode>3_const): Turn expander to insn.\n+\t* config/avr/avr.md (adjust_len): Add `round'.\n+\t* config/avr/avr-protos.h (avr_out_round): New prototype.\n+\t(avr_out_plus): Add `out_label' argument.\n+\t* config/avr/avr.c (avr_out_plus_1): Add `out_label' argument.\n+\t(avr_out_plus): Pass down `out_label' to avr_out_plus_1.\n+\tHandle the case where `insn' is just a pattern.\n+\t(avr_out_bitop): Handle the case where `insn' is just a pattern.\n+\t(avr_out_round): New function.\n+\t(avr_adjust_insn_length): Handle ADJUST_LEN_ROUND.\n+\n 2013-07-18  David Holsgrove <david.holsgrove@xilinx.com>\n \n \t* config/microblaze/microblaze.c (microblaze_expand_prologue):"}, {"sha": "b2f0b9aa144ec383175f231ae549b5ee24da5de8", "filename": "gcc/config/avr/avr-fixed.md", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Fconfig%2Favr%2Favr-fixed.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Fconfig%2Favr%2Favr-fixed.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-fixed.md?ref=0237179843a59b84cc1ae9a14bdf66a308ebd289", "patch": "@@ -447,49 +447,18 @@\n ;; \"roundqq3_const\"  \"rounduqq3_const\"\n ;; \"roundhq3_const\"  \"rounduhq3_const\"  \"roundha3_const\"  \"rounduha3_const\"\n ;; \"roundsq3_const\"  \"roundusq3_const\"  \"roundsa3_const\"  \"roundusa3_const\"\n-(define_expand \"round<mode>3_const\"\n-  [(parallel [(match_operand:ALL124QA 0 \"register_operand\" \"\")\n-              (match_operand:ALL124QA 1 \"register_operand\" \"\")\n-              (match_operand:HI 2 \"const_int_operand\" \"\")])]\n+(define_insn \"round<mode>3_const\"\n+  [(set (match_operand:ALL124QA 0 \"register_operand\"                  \"=d\")\n+        (unspec:ALL124QA [(match_operand:ALL124QA 1 \"register_operand\" \"0\")\n+                          (match_operand:HI 2 \"const_int_operand\"      \"n\")\n+                          (const_int 0)]\n+                         UNSPEC_ROUND))]\n   \"\"\n   {\n-    // The rounding point RP is $2.  The smallest fractional\n-    // bit that is not cleared by the rounding is 2^(-RP).\n-\n-    enum machine_mode imode = int_mode_for_mode (<MODE>mode);\n-    int fbit = (int) GET_MODE_FBIT (<MODE>mode);\n-\n-    // Add-Saturate  1/2 * 2^(-RP)\n-\n-    double_int i_add = double_int_zero.set_bit (fbit-1 - INTVAL (operands[2]));\n-    rtx x_add = const_fixed_from_double_int (i_add, <MODE>mode);\n-\n-    if (SIGNED_FIXED_POINT_MODE_P (<MODE>mode))\n-      emit_move_insn (operands[0],\n-                      gen_rtx_SS_PLUS (<MODE>mode, operands[1], x_add));\n-    else\n-      emit_move_insn (operands[0],\n-                      gen_rtx_US_PLUS (<MODE>mode, operands[1], x_add));\n-\n-    // Keep  all bits from RP and higher:   ... 2^(-RP)\n-    // Clear all bits from RP+1 and lower:              2^(-RP-1) ...\n-    // Rounding point                           ^^^^^^^\n-    // Added above                                      ^^^^^^^^^\n-\n-    rtx xreg = simplify_gen_subreg (imode, operands[0], <MODE>mode, 0);\n-    rtx xmask = immed_double_int_const (-i_add - i_add, imode);\n-\n-    if (SImode == imode)\n-      emit_insn (gen_andsi3 (xreg, xreg, xmask));\n-    else if (HImode == imode)\n-      emit_insn (gen_andhi3 (xreg, xreg, xmask));\n-    else if (QImode == imode)\n-      emit_insn (gen_andqi3 (xreg, xreg, xmask));\n-    else\n-      gcc_unreachable();\n-\n-    DONE;\n-  })\n+    return avr_out_round (insn, operands);\n+  }\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"adjust_len\" \"round\")])\n \n \n ;; \"*roundqq3.libgcc\"  \"*rounduqq3.libgcc\""}, {"sha": "21ad26a6f3420ec2e351194615f59f4936560f6e", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=0237179843a59b84cc1ae9a14bdf66a308ebd289", "patch": "@@ -86,7 +86,8 @@ extern int avr_starting_frame_offset (void);\n extern void avr_output_addr_vec_elt (FILE *stream, int value);\n extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);\n extern const char* avr_out_bitop (rtx, rtx*, int*);\n-extern const char* avr_out_plus (rtx, rtx*, int* =NULL, int* =NULL);\n+extern const char* avr_out_plus (rtx, rtx*, int* =NULL, int* =NULL, bool =true);\n+extern const char* avr_out_round (rtx, rtx*, int* =NULL);\n extern const char* avr_out_addto_sp (rtx*, int*);\n extern const char* avr_out_xload (rtx, rtx*, int*);\n extern const char* avr_out_movmem (rtx, rtx*, int*);"}, {"sha": "50100bf55134d0882dbb762ce2a94282c2ad5662", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 88, "deletions": 16, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=0237179843a59b84cc1ae9a14bdf66a308ebd289", "patch": "@@ -6232,11 +6232,14 @@ lshrsi3_out (rtx insn, rtx operands[], int *len)\n    the subtrahend in the original insn, provided it is a compile time constant.\n    In all other cases, SIGN is 0.\n \n-   Return \"\".  */\n+   If OUT_LABEL is true, print the final 0: label which is needed for\n+   saturated addition / subtraction.  The only case where OUT_LABEL = false\n+   is useful is for saturated addition / subtraction performed during\n+   fixed-point rounding, cf. `avr_out_round'.  */\n \n static void\n avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc,\n-                enum rtx_code code_sat = UNKNOWN, int sign = 0)\n+                enum rtx_code code_sat, int sign, bool out_label)\n {\n   /* MODE of the operation.  */\n   enum machine_mode mode = GET_MODE (xop[0]);\n@@ -6675,7 +6678,8 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc,\n                      \"mov %r0+5,%0\", xop, plen, 4);\n     }\n \n-  avr_asm_len (\"0:\", op, plen, 0);\n+  if (out_label)\n+    avr_asm_len (\"0:\", op, plen, 0);\n }\n \n \n@@ -6713,8 +6717,8 @@ avr_out_plus_symbol (rtx *xop, enum rtx_code code, int *plen, int *pcc)\n \n /* Prepare operands of addition/subtraction to be used with avr_out_plus_1.\n \n-   INSN is a single_set insn with a binary operation as SET_SRC that is\n-   one of:  PLUS, SS_PLUS, US_PLUS, MINUS, SS_MINUS, US_MINUS.\n+   INSN is a single_set insn or an insn pattern with a binary operation as\n+   SET_SRC that is one of: PLUS, SS_PLUS, US_PLUS, MINUS, SS_MINUS, US_MINUS.\n \n    XOP are the operands of INSN.  In the case of 64-bit operations with\n    constant XOP[] has just one element:  The summand/subtrahend in XOP[0].\n@@ -6729,19 +6733,22 @@ avr_out_plus_symbol (rtx *xop, enum rtx_code code, int *plen, int *pcc)\n \n    PLEN and PCC default to NULL.\n \n+   OUT_LABEL defaults to TRUE.  For a description, see AVR_OUT_PLUS_1.\n+\n    Return \"\"  */\n \n const char*\n-avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)\n+avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc, bool out_label)\n {\n   int cc_plus, cc_minus, cc_dummy;\n   int len_plus, len_minus;\n   rtx op[4];\n-  rtx xdest = SET_DEST (single_set (insn));\n+  rtx xpattern = INSN_P (insn) ? single_set (insn) : insn;\n+  rtx xdest = SET_DEST (xpattern);\n   enum machine_mode mode = GET_MODE (xdest);\n   enum machine_mode imode = int_mode_for_mode (mode);\n   int n_bytes = GET_MODE_SIZE (mode);\n-  enum rtx_code code_sat = GET_CODE (SET_SRC (single_set (insn)));\n+  enum rtx_code code_sat = GET_CODE (SET_SRC (xpattern));\n   enum rtx_code code\n     = (PLUS == code_sat || SS_PLUS == code_sat || US_PLUS == code_sat\n        ? PLUS : MINUS);\n@@ -6756,7 +6763,7 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)\n \n   if (n_bytes <= 4 && REG_P (xop[2]))\n     {\n-      avr_out_plus_1 (xop, plen, code, pcc, code_sat);\n+      avr_out_plus_1 (xop, plen, code, pcc, code_sat, 0, out_label);\n       return \"\";\n     }\n \n@@ -6783,7 +6790,8 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)\n   /* Saturations and 64-bit operations don't have a clobber operand.\n      For the other cases, the caller will provide a proper XOP[3].  */\n \n-  op[3] = PARALLEL == GET_CODE (PATTERN (insn)) ? xop[3] : NULL_RTX;\n+  xpattern = INSN_P (insn) ? PATTERN (insn) : insn;\n+  op[3] = PARALLEL == GET_CODE (xpattern) ? xop[3] : NULL_RTX;\n \n   /* Saturation will need the sign of the original operand.  */\n \n@@ -6798,18 +6806,18 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)\n \n   /* Work out the shortest sequence.  */\n \n-  avr_out_plus_1 (op, &len_minus, MINUS, &cc_plus, code_sat, sign);\n-  avr_out_plus_1 (op, &len_plus, PLUS, &cc_minus, code_sat, sign);\n+  avr_out_plus_1 (op, &len_minus, MINUS, &cc_plus, code_sat, sign, out_label);\n+  avr_out_plus_1 (op, &len_plus, PLUS, &cc_minus, code_sat, sign, out_label);\n \n   if (plen)\n     {\n       *plen = (len_minus <= len_plus) ? len_minus : len_plus;\n       *pcc  = (len_minus <= len_plus) ? cc_minus : cc_plus;\n     }\n   else if (len_minus <= len_plus)\n-    avr_out_plus_1 (op, NULL, MINUS, pcc, code_sat, sign);\n+    avr_out_plus_1 (op, NULL, MINUS, pcc, code_sat, sign, out_label);\n   else\n-    avr_out_plus_1 (op, NULL, PLUS, pcc, code_sat, sign);\n+    avr_out_plus_1 (op, NULL, PLUS, pcc, code_sat, sign, out_label);\n \n   return \"\";\n }\n@@ -6823,13 +6831,15 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)\n    and return \"\".  If PLEN == NULL, print assembler instructions to perform the\n    operation; otherwise, set *PLEN to the length of the instruction sequence\n    (in words) printed with PLEN == NULL.  XOP[3] is either an 8-bit clobber\n-   register or SCRATCH if no clobber register is needed for the operation.  */\n+   register or SCRATCH if no clobber register is needed for the operation.\n+   INSN is an INSN_P or a pattern of an insn.  */\n \n const char*\n avr_out_bitop (rtx insn, rtx *xop, int *plen)\n {\n   /* CODE and MODE of the operation.  */\n-  enum rtx_code code = GET_CODE (SET_SRC (single_set (insn)));\n+  rtx xpattern = INSN_P (insn) ? single_set (insn) : insn;\n+  enum rtx_code code = GET_CODE (SET_SRC (xpattern));\n   enum machine_mode mode = GET_MODE (xop[0]);\n \n   /* Number of bytes to operate on.  */\n@@ -7332,6 +7342,67 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)\n }\n \n \n+/* Output fixed-point rounding.  XOP[0] = XOP[1] is the operand to round.\n+   XOP[2] is the rounding point, a CONST_INT.  The function prints the\n+   instruction sequence if PLEN = NULL and computes the length in words\n+   of the sequence if PLEN != NULL.  Most of this function deals with\n+   preparing operands for calls to `avr_out_plus' and `avr_out_bitop'.  */\n+\n+const char*\n+avr_out_round (rtx insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)\n+{\n+  enum machine_mode mode = GET_MODE (xop[0]);\n+  enum machine_mode imode = int_mode_for_mode (mode);\n+  // The smallest fractional bit not cleared by the rounding is 2^(-RP).\n+  int fbit = (int) GET_MODE_FBIT (mode);\n+  double_int i_add = double_int_zero.set_bit (fbit-1 - INTVAL (xop[2]));\n+  // Lengths of PLUS and AND parts.\n+  int len_add = 0, *plen_add = plen ? &len_add : NULL;\n+  int len_and = 0, *plen_and = plen ? &len_and : NULL;\n+\n+  // Add-Saturate  1/2 * 2^(-RP).  Don't print the label \"0:\" when printing\n+  // the saturated addition so that we can emit the \"rjmp 1f\" before the\n+  // \"0:\" below.\n+\n+  rtx xadd = const_fixed_from_double_int (i_add, mode);\n+  rtx xpattern, xsrc, op[4];\n+\n+  xsrc = SIGNED_FIXED_POINT_MODE_P (mode)\n+    ? gen_rtx_SS_PLUS (mode, xop[1], xadd)\n+    : gen_rtx_US_PLUS (mode, xop[1], xadd);\n+  xpattern = gen_rtx_SET (VOIDmode, xop[0], xsrc);\n+\n+  op[0] = xop[0];\n+  op[1] = xop[1];\n+  op[2] = xadd;\n+  avr_out_plus (xpattern, op, plen_add, NULL, false /* Don't print \"0:\" */);\n+\n+  avr_asm_len (\"rjmp 1f\" CR_TAB\n+               \"0:\", NULL, plen_add, 1);\n+\n+  // Keep  all bits from RP and higher:   ... 2^(-RP)\n+  // Clear all bits from RP+1 and lower:              2^(-RP-1) ...\n+  // Rounding point                           ^^^^^^^\n+  // Added above                                      ^^^^^^^^^\n+  rtx xreg = simplify_gen_subreg (imode, xop[0], mode, 0);\n+  rtx xmask = immed_double_int_const (-i_add - i_add, imode);\n+\n+  xpattern = gen_rtx_SET (VOIDmode, xreg, gen_rtx_AND (imode, xreg, xmask));\n+\n+  op[0] = xreg;\n+  op[1] = xreg;\n+  op[2] = xmask;\n+  op[3] = gen_rtx_SCRATCH (QImode);\n+  avr_out_bitop (xpattern, op, plen_and);\n+  avr_asm_len (\"1:\", NULL, plen, 0);\n+\n+  if (plen)\n+    *plen = len_add + len_and;\n+\n+  return \"\";\n+}\n+\n+\n /* Create RTL split patterns for byte sized rotate expressions.  This\n   produces a series of move instructions and considers overlap situations.\n   Overlapping non-HImode operands need a scratch register.  */\n@@ -7540,6 +7611,7 @@ avr_adjust_insn_length (rtx insn, int len)\n \n     case ADJUST_LEN_SFRACT: avr_out_fract (insn, op, true, &len); break;\n     case ADJUST_LEN_UFRACT: avr_out_fract (insn, op, false, &len); break;\n+    case ADJUST_LEN_ROUND: avr_out_round (insn, op, &len); break;\n \n     case ADJUST_LEN_TSTHI: avr_out_tsthi (insn, op, &len); break;\n     case ADJUST_LEN_TSTPSI: avr_out_tstpsi (insn, op, &len); break;"}, {"sha": "f2681233acee549114e42dc678777e244e268157", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=0237179843a59b84cc1ae9a14bdf66a308ebd289", "patch": "@@ -140,7 +140,7 @@\n   \"out_bitop, plus, addto_sp,\n    tsthi, tstpsi, tstsi, compare, compare64, call,\n    mov8, mov16, mov24, mov32, reload_in16, reload_in24, reload_in32,\n-   ufract, sfract,\n+   ufract, sfract, round,\n    xload, lpm, movmem,\n    ashlqi, ashrqi, lshrqi,\n    ashlhi, ashrhi, lshrhi,"}, {"sha": "9c8bfe331029ada652a122dfc91b5f1d1bdab43e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0237179843a59b84cc1ae9a14bdf66a308ebd289", "patch": "@@ -1,3 +1,9 @@\n+2013-07-19  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/57516\n+\t* gcc.target/avr/torture/builtins-4-roundfx.c (test2hr, test2k):\n+\tAdjust to corrected rounding.\n+\n 2013-07-19  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* lib/target-supports.exp (check_effective_target_cilkplus): New proc."}, {"sha": "46e915a6c8755f14a68dbe172dba0660a333a358", "filename": "gcc/testsuite/gcc.target/avr/torture/builtins-4-roundfx.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltins-4-roundfx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0237179843a59b84cc1ae9a14bdf66a308ebd289/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltins-4-roundfx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltins-4-roundfx.c?ref=0237179843a59b84cc1ae9a14bdf66a308ebd289", "patch": "@@ -72,11 +72,11 @@ DEFTEST1 (long long accum, llk)\n \n static void test2hr (void)\n {\n-  TEST2 (hr, 1, 0x7f, 0x40);\n-  TEST2 (hr, 2, 0x7f, 0b1100000);\n-  TEST2 (hr, 3, 0x7f, 0b1110000);\n-  TEST2 (hr, 4, 0x7f, 0b1111000);\n-\n+  TEST2 (hr, 1, 0x7f, 0x7f);\n+  TEST2 (hr, 2, 0x70, 0x7f);\n+  TEST2 (hr, 3, 0x78, 0x7f);\n+  TEST2 (hr, 4, 0x7f, 0x7f);\n+ \n   TEST2 (uhr, 1, 0x7f, 0x80);\n   TEST2 (uhr, 2, 0x7f, 0x80);\n   TEST2 (uhr, 3, 0x7f, 0x80);\n@@ -85,10 +85,13 @@ static void test2hr (void)\n \n void test2k (void)\n {\n-  TEST2 (k, 1, 0x7fffffff, 0x7fff8000 | 0b100000000000000);\n-  TEST2 (k, 2, 0x7fffffff, 0x7fff8000 | 0b110000000000000);\n-  TEST2 (k, 3, 0x7fffffff, 0x7fff8000 | 0b111000000000000);\n-  TEST2 (k, 4, 0x7fffffff, 0x7fff8000 | 0b111100000000000);\n+  TEST2 (k, 1, 0x7fffff00, 0x7fffffff);\n+  TEST2 (k, 2, 0x7ffffff0, 0x7fffffff);\n+  TEST2 (k, 2, 0x7ffff000, 0x7fffffff);\n+  TEST2 (k, 3, 0x7ffff000, 0x7ffff000);\n+  TEST2 (k, 3, 0x7ffff800, 0x7fffffff);\n+  TEST2 (k, 3, 0x7ffff7ff, 0x7ffff000);\n+  TEST2 (k, 4, 0x7ffff7ff, 0x7ffff800);\n \n   TEST2 (uk, 1, 0x7fffffff, 1ul << 31);\n   TEST2 (uk, 2, 0x7fffffff, 1ul << 31);"}, {"sha": "9020a64394637858d48c39bbd45321d4ad575b61", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0237179843a59b84cc1ae9a14bdf66a308ebd289/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0237179843a59b84cc1ae9a14bdf66a308ebd289/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=0237179843a59b84cc1ae9a14bdf66a308ebd289", "patch": "@@ -1,3 +1,11 @@\n+2013-07-19  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/57516\n+\t* config/avr/lib1funcs-fixed.S (__roundqq3, __rounduqq3)\n+\t(__round_s2_const, __round_u2_const)\n+\t(__round_s4_const, __round_u4_const, __round_x8):\n+\tSaturate result if addition result cannot be represented.\n+\n 2013-07-15  Matthias Klose  <doko@ubuntu.com>\n \n \t* libgcc2.c: Don't include <limits.h>."}, {"sha": "f920891e19e8c4656d3811ed6fd331c931ff48df", "filename": "libgcc/config/avr/lib1funcs-fixed.S", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0237179843a59b84cc1ae9a14bdf66a308ebd289/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0237179843a59b84cc1ae9a14bdf66a308ebd289/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S?ref=0237179843a59b84cc1ae9a14bdf66a308ebd289", "patch": "@@ -1464,12 +1464,13 @@ DEFUN  __roundqq3\n     ;; Add-Saturate 2^{-RP-1}\n     add     A0, C0\n     brvc 0f\n-    ldi     A0, 0x7f\n+    ldi     C0, 0x7f\n+    rjmp 9f\n 0:  ;; Mask out bits beyond RP\n     lsl     C0\n     neg     C0\n     and     C0, A0\n-    mov     C1, __tmp_reg__\n+9:  mov     C1, __tmp_reg__\n     ret\n ENDF  __roundqq3\n #endif /* L_roundqq3 */\n@@ -1488,12 +1489,13 @@ DEFUN  __rounduqq3\n     ;; Add-Saturate 2^{-RP-1}\n     add     A0, C0\n     brcc 0f\n-    ldi     A0, 0xff\n+    ldi     C0, 0xff\n+    rjmp 9f\n 0:  ;; Mask out bits beyond RP\n     lsl     C0\n     neg     C0\n     and     C0, A0\n-    mov     C1, __tmp_reg__\n+9:  mov     C1, __tmp_reg__\n     ret\n ENDF  __rounduqq3\n #endif /* L_rounduqq3 */\n@@ -1565,16 +1567,17 @@ ENDF  __rounduha3\n \n DEFUN  __round_s2_const\n     brvc 2f\n-    ldi     A1, 0x7f\n+    ldi     C1, 0x7f\n     rjmp 1f\n     ;; FALLTHRU (Barrier)\n ENDF  __round_s2_const\n \n DEFUN __round_u2_const\n     brcc 2f\n-    ldi     A1, 0xff\n+    ldi     C1, 0xff\n 1:\n-    ldi     A0, 0xff\n+    ldi     C0, 0xff\n+    rjmp 9f\n 2:\n     ;; Saturation is performed now.\n     ;; Currently, we have C[] = 2^{-RP-1}\n@@ -1586,7 +1589,7 @@ DEFUN __round_u2_const\n     ;; Clear the bits beyond the rounding point.\n     and     C0, A0\n     and     C1, A1\n-    ret\n+9:  ret\n ENDF  __round_u2_const\n \n #endif /* L_round_2_const */\n@@ -1681,18 +1684,19 @@ ENDF  __roundusa3\n \n DEFUN  __round_s4_const\n     brvc 2f\n-    ldi     A3, 0x7f\n+    ldi     C3, 0x7f\n     rjmp 1f\n     ;; FALLTHRU (Barrier)\n ENDF  __round_s4_const\n \n DEFUN __round_u4_const\n     brcc 2f\n-    ldi     A3, 0xff\n+    ldi     C3, 0xff\n 1:\n-    ldi     A2, 0xff\n-    ldi     A1, 0xff\n-    ldi     A0, 0xff\n+    ldi     C2, 0xff\n+    ldi     C1, 0xff\n+    ldi     C0, 0xff\n+    rjmp 9f\n 2:\n     ;; Saturation is performed now.\n     ;; Currently, we have C[] = 2^{-RP-1}\n@@ -1707,7 +1711,7 @@ DEFUN __round_u4_const\n     and     C1, A1\n     and     C2, A2\n     and     C3, A3\n-    ret\n+9:  ret\n ENDF  __round_u4_const\n \n #endif /* L_round_4_const */\n@@ -1847,12 +1851,13 @@ DEFUN __round_x8\n 1:  ;; Unsigned\n     brcc    3f\n     ;; Unsigned overflow: A[] = 0xff...\n-2:  ldi     A7, 0xff\n-    ldi     A6, 0xff\n-    wmov    A0, A6\n-    wmov    A2, A6\n-    wmov    A4, A6\n-    bld     A7, 7\n+2:  ldi     C7, 0xff\n+    ldi     C6, 0xff\n+    wmov    C0, C6\n+    wmov    C2, C6\n+    wmov    C4, C6\n+    bld     C7, 7\n+    rjmp 9f\n 3:\n     ;;  C[] = -C[] - C[]\n     push    A0\n@@ -1869,7 +1874,7 @@ DEFUN __round_x8\n     and     C5, A5\n     and     C6, A6\n     and     C7, A7\n-    ;; Epilogue\n+9:  ;; Epilogue\n     pop r29\n     pop r28\n     pop r17"}]}