{"sha": "271892929a448a2bad2fa83e5652958d1af3f1a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcxODkyOTI5YTQ0OGEyYmFkMmZhODNlNTY1Mjk1OGQxYWYzZjFhNA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-03-25T09:01:23Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-03-25T09:01:23Z"}, "message": "re PR fortran/30877 (Extending intrinsic operators)\n\n\tPR fortran/30877\n\n\t* fortran/interface.c (check_operator_interface): Implement\n\tthe standard checks on user operators extending intrinsic operators.\n\t* fortran/resolve.c (resolve_operator): If the ranks of operators\n\tdon't match, don't error out but try the user-defined ones first.\n\n\t* gfortran.dg/operator_1.f90: New test.\n\t* gfortran.dg/operator_2.f90: New test.\n\nFrom-SVN: r123196", "tree": {"sha": "aaa2d1d804beb94ea0e00a7da4806f5163831ac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaa2d1d804beb94ea0e00a7da4806f5163831ac8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/271892929a448a2bad2fa83e5652958d1af3f1a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271892929a448a2bad2fa83e5652958d1af3f1a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/271892929a448a2bad2fa83e5652958d1af3f1a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271892929a448a2bad2fa83e5652958d1af3f1a4/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc41ec4ebc020fdf032bb981b5990469649a8926", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc41ec4ebc020fdf032bb981b5990469649a8926", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc41ec4ebc020fdf032bb981b5990469649a8926"}], "stats": {"total": 321, "additions": 239, "deletions": 82}, "files": [{"sha": "460f2119266c5b75ebb1a80ae4e7c47edcf6cd4f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=271892929a448a2bad2fa83e5652958d1af3f1a4", "patch": "@@ -1,3 +1,11 @@\n+2007-03-25  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/30877\n+\t* fortran/interface.c (check_operator_interface): Implement\n+\tthe standard checks on user operators extending intrinsic operators.\n+\t* fortran/resolve.c (resolve_operator): If the ranks of operators\n+\tdon't match, don't error out but try the user-defined ones first.\n+\n 2007-03-24  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/30655"}, {"sha": "1672b1c3abc932d1e3ab9ce304066788864ce5c3", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 104, "deletions": 77, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=271892929a448a2bad2fa83e5652958d1af3f1a4", "patch": "@@ -493,14 +493,16 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op operator)\n   sym_intent i1, i2;\n   gfc_symbol *sym;\n   bt t1, t2;\n-  int args;\n+  int args, r1, r2, k1, k2;\n \n   if (intr == NULL)\n     return;\n \n   args = 0;\n   t1 = t2 = BT_UNKNOWN;\n   i1 = i2 = INTENT_UNKNOWN;\n+  r1 = r2 = -1;\n+  k1 = k2 = -1;\n \n   for (formal = intr->sym->formal; formal; formal = formal->next)\n     {\n@@ -515,20 +517,35 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op operator)\n \t{\n \t  t1 = sym->ts.type;\n \t  i1 = sym->attr.intent;\n+\t  r1 = (sym->as != NULL) ? sym->as->rank : 0;\n+\t  k1 = sym->ts.kind;\n \t}\n       if (args == 1)\n \t{\n \t  t2 = sym->ts.type;\n \t  i2 = sym->attr.intent;\n+\t  r2 = (sym->as != NULL) ? sym->as->rank : 0;\n+\t  k2 = sym->ts.kind;\n \t}\n       args++;\n     }\n \n-  if (args == 0 || args > 2)\n-    goto num_args;\n-\n   sym = intr->sym;\n \n+  /* Only +, - and .not. can be unary operators.\n+     .not. cannot be a binary operator.  */\n+  if (args == 0 || args > 2 || (args == 1 && operator != INTRINSIC_PLUS\n+\t\t\t\t&& operator != INTRINSIC_MINUS\n+\t\t\t\t&& operator != INTRINSIC_NOT)\n+      || (args == 2 && operator == INTRINSIC_NOT))\n+    {\n+      gfc_error (\"Operator interface at %L has the wrong number of arguments\",\n+\t\t &intr->where);\n+      return;\n+    }\n+\n+  /* Check that intrinsics are mapped to functions, except\n+     INTRINSIC_ASSIGN which should map to a subroutine.  */\n   if (operator == INTRINSIC_ASSIGN)\n     {\n       if (!sym->attr.subroutine)\n@@ -564,114 +581,124 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op operator)\n \t}\n     }\n \n-  switch (operator)\n+  /* Check intents on operator interfaces.  */\n+  if (operator == INTRINSIC_ASSIGN)\n     {\n-    case INTRINSIC_PLUS:\t/* Numeric unary or binary */\n-    case INTRINSIC_MINUS:\n-      if ((args == 1)\n-\t  && (t1 == BT_INTEGER || t1 == BT_REAL || t1 == BT_COMPLEX))\n+      if (i1 != INTENT_OUT && i1 != INTENT_INOUT)\n+\tgfc_error (\"First argument of defined assignment at %L must be \"\n+\t\t   \"INTENT(IN) or INTENT(INOUT)\", &intr->where);\n+\n+      if (i2 != INTENT_IN)\n+\tgfc_error (\"Second argument of defined assignment at %L must be \"\n+\t\t   \"INTENT(IN)\", &intr->where);\n+    }\n+  else\n+    {\n+      if (i1 != INTENT_IN)\n+\tgfc_error (\"First argument of operator interface at %L must be \"\n+\t\t   \"INTENT(IN)\", &intr->where);\n+\n+      if (args == 2 && i2 != INTENT_IN)\n+\tgfc_error (\"Second argument of operator interface at %L must be \"\n+\t\t   \"INTENT(IN)\", &intr->where);\n+    }\n+\n+  /* From now on, all we have to do is check that the operator definition\n+     doesn't conflict with an intrinsic operator. The rules for this\n+     game are defined in 7.1.2 and 7.1.3 of both F95 and F2003 standards,\n+     as well as 12.3.2.1.1 of Fortran 2003:\n+\n+     \"If the operator is an intrinsic-operator (R310), the number of\n+     function arguments shall be consistent with the intrinsic uses of\n+     that operator, and the types, kind type parameters, or ranks of the\n+     dummy arguments shall differ from those required for the intrinsic\n+     operation (7.1.2).\"  */\n+\n+#define IS_NUMERIC_TYPE(t) \\\n+  ((t) == BT_INTEGER || (t) == BT_REAL || (t) == BT_COMPLEX)\n+\n+  /* Unary ops are easy, do them first.  */\n+  if (operator == INTRINSIC_NOT)\n+    {\n+      if (t1 == BT_LOGICAL)\n \tgoto bad_repl;\n+      else\n+\treturn;\n+    }\n \n-      if ((args == 2)\n-\t  && (t1 == BT_INTEGER || t1 == BT_REAL || t1 == BT_COMPLEX)\n-\t  && (t2 == BT_INTEGER || t2 == BT_REAL || t2 == BT_COMPLEX))\n+  if (args == 1 && (operator == INTRINSIC_PLUS || operator == INTRINSIC_MINUS))\n+    {\n+      if (IS_NUMERIC_TYPE (t1))\n \tgoto bad_repl;\n+      else\n+\treturn;\n+    }\n \n-      break;\n+  /* Character intrinsic operators have same character kind, thus\n+     operator definitions with operands of different character kinds\n+     are always safe.  */\n+  if (t1 == BT_CHARACTER && t2 == BT_CHARACTER && k1 != k2)\n+    return;\n \n-    case INTRINSIC_POWER:\t/* Binary numeric */\n-    case INTRINSIC_TIMES:\n-    case INTRINSIC_DIVIDE:\n+  /* Intrinsic operators always perform on arguments of same rank,\n+     so different ranks is also always safe.  (rank == 0) is an exception\n+     to that, because all intrinsic operators are elemental.  */\n+  if (r1 != r2 && r1 != 0 && r2 != 0)\n+    return;\n \n+  switch (operator)\n+  {\n     case INTRINSIC_EQ:\n     case INTRINSIC_NE:\n-      if (args == 1)\n-\tgoto num_args;\n-\n-      if ((t1 == BT_INTEGER || t1 == BT_REAL || t1 == BT_COMPLEX)\n-\t  && (t2 == BT_INTEGER || t2 == BT_REAL || t2 == BT_COMPLEX))\n+      if (t1 == BT_CHARACTER && t2 == BT_CHARACTER)\n \tgoto bad_repl;\n+      /* Fall through.  */\n \n+    case INTRINSIC_PLUS:\n+    case INTRINSIC_MINUS:\n+    case INTRINSIC_TIMES:\n+    case INTRINSIC_DIVIDE:\n+    case INTRINSIC_POWER:\n+      if (IS_NUMERIC_TYPE (t1) && IS_NUMERIC_TYPE (t2))\n+\tgoto bad_repl;\n       break;\n \n-    case INTRINSIC_GE:\t\t/* Binary numeric operators that do not support */\n-    case INTRINSIC_LE:\t\t/* complex numbers */\n-    case INTRINSIC_LT:\n     case INTRINSIC_GT:\n-      if (args == 1)\n-\tgoto num_args;\n-\n+    case INTRINSIC_GE:\n+    case INTRINSIC_LT:\n+    case INTRINSIC_LE:\n+      if (t1 == BT_CHARACTER && t2 == BT_CHARACTER)\n+\tgoto bad_repl;\n       if ((t1 == BT_INTEGER || t1 == BT_REAL)\n \t  && (t2 == BT_INTEGER || t2 == BT_REAL))\n \tgoto bad_repl;\n+      break;\n \n+    case INTRINSIC_CONCAT:\n+      if (t1 == BT_CHARACTER && t2 == BT_CHARACTER)\n+\tgoto bad_repl;\n       break;\n \n-    case INTRINSIC_OR:\t\t/* Binary logical */\n     case INTRINSIC_AND:\n+    case INTRINSIC_OR:\n     case INTRINSIC_EQV:\n     case INTRINSIC_NEQV:\n-      if (args == 1)\n-\tgoto num_args;\n       if (t1 == BT_LOGICAL && t2 == BT_LOGICAL)\n \tgoto bad_repl;\n       break;\n \n-    case INTRINSIC_NOT:\t/* Unary logical */\n-      if (args != 1)\n-\tgoto num_args;\n-      if (t1 == BT_LOGICAL)\n-\tgoto bad_repl;\n-      break;\n-\n-    case INTRINSIC_CONCAT:\t/* Binary string */\n-      if (args != 2)\n-\tgoto num_args;\n-      if (t1 == BT_CHARACTER && t2 == BT_CHARACTER)\n-\tgoto bad_repl;\n-      break;\n-\n-    case INTRINSIC_ASSIGN:\t/* Class by itself */\n-      if (args != 2)\n-\tgoto num_args;\n-      break;\n     default:\n-      gfc_internal_error (\"check_operator_interface(): Bad operator\");\n-    }\n-\n-  /* Check intents on operator interfaces.  */\n-  if (operator == INTRINSIC_ASSIGN)\n-    {\n-      if (i1 != INTENT_OUT && i1 != INTENT_INOUT)\n-\tgfc_error (\"First argument of defined assignment at %L must be \"\n-\t\t   \"INTENT(IN) or INTENT(INOUT)\", &intr->where);\n-\n-      if (i2 != INTENT_IN)\n-\tgfc_error (\"Second argument of defined assignment at %L must be \"\n-\t\t   \"INTENT(IN)\", &intr->where);\n-    }\n-  else\n-    {\n-      if (i1 != INTENT_IN)\n-\tgfc_error (\"First argument of operator interface at %L must be \"\n-\t\t   \"INTENT(IN)\", &intr->where);\n-\n-      if (args == 2 && i2 != INTENT_IN)\n-\tgfc_error (\"Second argument of operator interface at %L must be \"\n-\t\t   \"INTENT(IN)\", &intr->where);\n-    }\n+      break;\n+  }\n \n   return;\n \n+#undef IS_NUMERIC_TYPE\n+\n bad_repl:\n   gfc_error (\"Operator interface at %L conflicts with intrinsic interface\",\n \t     &intr->where);\n   return;\n-\n-num_args:\n-  gfc_error (\"Operator interface at %L has the wrong number of arguments\",\n-\t     &intr->where);\n-  return;\n }\n \n "}, {"sha": "03e63601c1e6bdffb1dbaa2aae69c7935a4d5b22", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=271892929a448a2bad2fa83e5652958d1af3f1a4", "patch": "@@ -2082,6 +2082,7 @@ resolve_operator (gfc_expr *e)\n {\n   gfc_expr *op1, *op2;\n   char msg[200];\n+  bool dual_locus_error;\n   try t;\n \n   /* Resolve all subnodes-- give them types.  */\n@@ -2107,6 +2108,7 @@ resolve_operator (gfc_expr *e)\n \n   op1 = e->value.op.op1;\n   op2 = e->value.op.op2;\n+  dual_locus_error = false;\n \n   switch (e->value.op.operator)\n     {\n@@ -2306,12 +2308,14 @@ resolve_operator (gfc_expr *e)\n \t    }\n \t  else\n \t    {\n-\t      gfc_error (\"Inconsistent ranks for operator at %L and %L\",\n-\t\t\t &op1->where, &op2->where);\n-\t      t = FAILURE;\n-\n \t      /* Allow higher level expressions to work.  */\n \t      e->rank = 0;\n+\n+\t      /* Try user-defined operators, and otherwise throw an error.  */\n+\t      dual_locus_error = true;\n+\t      sprintf (msg,\n+\t\t       _(\"Inconsistent ranks for operator at %%L and %%L\"));\n+\t      goto bad_op;\n \t    }\n \t}\n \n@@ -2350,7 +2354,10 @@ resolve_operator (gfc_expr *e)\n   if (gfc_extend_expr (e) == SUCCESS)\n     return SUCCESS;\n \n-  gfc_error (msg, &e->where);\n+  if (dual_locus_error)\n+    gfc_error (msg, &op1->where, &op2->where);\n+  else\n+    gfc_error (msg, &e->where);\n \n   return FAILURE;\n }"}, {"sha": "8bd087add9240a5142d633c2f80e24a5946c80cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=271892929a448a2bad2fa83e5652958d1af3f1a4", "patch": "@@ -1,3 +1,9 @@\n+2007-03-25  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/30877\n+\t* gfortran.dg/operator_1.f90: New test.\n+\t* gfortran.dg/operator_2.f90: New test.\n+\n 2007-03-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR libfortran/31196"}, {"sha": "1800b68e3612266d297d5cf57000b33b176da68b", "filename": "gcc/testsuite/gfortran.dg/operator_1.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ftestsuite%2Fgfortran.dg%2Foperator_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ftestsuite%2Fgfortran.dg%2Foperator_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Foperator_1.f90?ref=271892929a448a2bad2fa83e5652958d1af3f1a4", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do run }\n+! Test the extension of intrinsic operators\n+module m1\n+ interface operator(*)\n+  module procedure f1\n+  module procedure f2\n+  module procedure f3\n+ end interface\n+\n+ interface operator(.or.)\n+  module procedure g1\n+ end interface\n+\n+ interface operator(//)\n+  module procedure g1\n+ end interface\n+\n+contains\n+\n+ function f1(a,b) result (c)\n+  integer, dimension(2,2), intent(in) :: a\n+  integer, dimension(2), intent(in)   :: b\n+  integer, dimension(2)   :: c\n+  c = matmul(a,b)\n+ end function f1\n+ function f2(a,b) result (c)\n+  real, dimension(2,2), intent(in) :: a\n+  real, dimension(2), intent(in)   :: b\n+  real, dimension(2)   :: c\n+  c = matmul(a,b)\n+ end function f2\n+ function f3(a,b) result (c)\n+  complex, dimension(2,2), intent(in) :: a\n+  complex, dimension(2), intent(in)   :: b\n+  complex, dimension(2)   :: c\n+  c = matmul(a,b)\n+ end function f3\n+\n+ elemental function g1(a,b) result (c)\n+   integer, intent(in) :: a, b\n+   integer :: c\n+   c = a + b\n+ end function g1\n+\n+end module m1\n+\n+  use m1\n+  implicit none\n+\n+  integer, dimension(2,2) :: ai\n+  integer, dimension(2)   :: bi, ci\n+  real, dimension(2,2) :: ar\n+  real, dimension(2)   :: br, cr\n+  complex, dimension(2,2) :: ac\n+  complex, dimension(2)   :: bc, cc\n+\n+  ai = reshape((/-2,-4,7,8/),(/2,2/)) ; bi = 3\n+  if (any((ai*bi) /= matmul(ai,bi))) call abort()\n+  if (any((ai .or. ai) /= ai+ai)) call abort()\n+  if (any((ai // ai) /= ai+ai)) call abort()\n+\n+  ar = reshape((/-2,-4,7,8/),(/2,2/)) ; br = 3\n+  if (any((ar*br) /= matmul(ar,br))) call abort()\n+\n+  ac = reshape((/-2,-4,7,8/),(/2,2/)) ; bc = 3\n+  if (any((ac*bc) /= matmul(ac,bc))) call abort()\n+\n+end\n+! { dg-final { cleanup-modules \"m1\" } }"}, {"sha": "11540caaf8af5d32c56e01e338492ed10b706e52", "filename": "gcc/testsuite/gfortran.dg/operator_2.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ftestsuite%2Fgfortran.dg%2Foperator_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271892929a448a2bad2fa83e5652958d1af3f1a4/gcc%2Ftestsuite%2Fgfortran.dg%2Foperator_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Foperator_2.f90?ref=271892929a448a2bad2fa83e5652958d1af3f1a4", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+! Test that we can't override intrinsic operators in invalid ways\n+module foo\n+\n+ interface operator(*)\n+  module procedure f1 ! { dg-error \"conflicts with intrinsic interface\" }\n+ end interface\n+\n+ interface operator(>)\n+   module procedure f2 ! { dg-error \"conflicts with intrinsic interface\" }\n+ end interface\n+\n+ interface operator(/)\n+  module procedure f3\n+ end interface\n+\n+contains\n+\n+ function f1(a,b) result (c)\n+  integer, intent(in) :: a\n+  integer, dimension(:), intent(in)   :: b\n+  integer, dimension(size(b,1))   :: c\n+  c = 0\n+ end function f1\n+\n+ function f2(a,b)\n+   character(len=*), intent(in) :: a\n+   character(len=*), intent(in) :: b\n+   logical :: f2\n+   f2 = .false.\n+ end function f2\n+\n+ function f3(a,b) result (c)\n+  integer, dimension(:,:), intent(in) :: a\n+  integer, dimension(:), intent(in)   :: b\n+  integer, dimension(size(b,1))   :: c\n+  c = 0\n+ end function f3\n+\n+end"}]}