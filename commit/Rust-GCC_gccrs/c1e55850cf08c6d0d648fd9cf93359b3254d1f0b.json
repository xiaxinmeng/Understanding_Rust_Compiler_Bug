{"sha": "c1e55850cf08c6d0d648fd9cf93359b3254d1f0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFlNTU4NTBjZjA4YzZkMGQ2NDhmZDljZjkzMzU5YjMyNTRkMWYwYg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2004-07-31T01:40:18Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2004-07-31T01:40:18Z"}, "message": "rs6000.c (legitimate_lo_sum_address_p): Permit non-offsettable addresses even for DImode.\n\n2004-07-30  Geoffrey Keating  <geoffk@apple.com>\n\n\t* config/rs6000/rs6000.c (legitimate_lo_sum_address_p): Permit\n\tnon-offsettable addresses even for DImode.\n\t(rs6000_split_multireg_move): Cope with non-offsettable addresses\n\tbeing moved into multiple GPRs.\n\n\t* config/rs6000/rs6000.c (RS6000_DEFAULT_LONG_DOUBLE_SIZE): Default\n\tto 64.\n\t(rs6000_override_options): Use RS6000_DEFAULT_LONG_DOUBLE_SIZE.\n\t* config/rs6000/darwin.h (RS6000_DEFAULT_LONG_DOUBLE_SIZE): Define\n\tto 128.\n\t* config/rs6000/darwin-ldouble.c (isless): New macro.\n\t(inf): New macro.\n\t(nonfinite): New macro.\n\t(FPKINF): Delete.\n\t(_xlqadd): Completely rewrite.\n\t(_xlqmul): Correct overflow handling.\n\t(_xlqdiv): Correct overflow handling.\n\t* config/rs6000/darwin-ldouble-format: New file.\n\nIndex: testsuite/ChangeLog\n2004-07-30  Geoffrey Keating  <geoffk@apple.com>\n\n\t* gcc.dg/darwin-longdouble.c: New file.\n\nFrom-SVN: r85371", "tree": {"sha": "4d9dd0c1be8c782967c209e2f38d6be5b51df9bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d9dd0c1be8c782967c209e2f38d6be5b51df9bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5571d77b5a7767dbe7b6cea3dc62da8273832b86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5571d77b5a7767dbe7b6cea3dc62da8273832b86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5571d77b5a7767dbe7b6cea3dc62da8273832b86"}], "stats": {"total": 376, "additions": 304, "deletions": 72}, "files": [{"sha": "0120ce46d75117480c431737b2d80898d4318055", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1e55850cf08c6d0d648fd9cf93359b3254d1f0b", "patch": "@@ -1,3 +1,24 @@\n+2004-07-30  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* config/rs6000/rs6000.c (legitimate_lo_sum_address_p): Permit\n+\tnon-offsettable addresses even for DImode.\n+\t(rs6000_split_multireg_move): Cope with non-offsettable addresses\n+\tbeing moved into multiple GPRs.\n+\n+\t* config/rs6000/rs6000.c (RS6000_DEFAULT_LONG_DOUBLE_SIZE): Default\n+\tto 64.\n+\t(rs6000_override_options): Use RS6000_DEFAULT_LONG_DOUBLE_SIZE.\n+\t* config/rs6000/darwin.h (RS6000_DEFAULT_LONG_DOUBLE_SIZE): Define\n+\tto 128.\n+\t* config/rs6000/darwin-ldouble.c (isless): New macro.\n+\t(inf): New macro.\n+\t(nonfinite): New macro.\n+\t(FPKINF): Delete.\n+\t(_xlqadd): Completely rewrite.\n+\t(_xlqmul): Correct overflow handling.\n+\t(_xlqdiv): Correct overflow handling.\n+\t* config/rs6000/darwin-ldouble-format: New file.\n+\n 2004-07-30  Roger Sayle  <roger@eyesopen.com>\n \t    Richard Henderson  <rth@redhat.com>\n "}, {"sha": "0012a332d719e88f995d3b2723de04d5f9c4c8b6", "filename": "gcc/config/rs6000/darwin-ldouble-format", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble-format", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble-format", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble-format?ref=c1e55850cf08c6d0d648fd9cf93359b3254d1f0b", "patch": "@@ -0,0 +1,84 @@\n+Long double format\n+==================\n+\n+  Each long double is made up of two IEEE doubles.  The value of the\n+long double is the sum of the values of the two parts (except for\n+-0.0).  The most significant part is required to be the value of the\n+long double rounded to the nearest double, as specified by IEEE.  For\n+Inf values, the least significant part is required to be one of +0.0\n+or -0.0.  No other requirements are made; so, for example, 1.0 may be\n+represented as (1.0, +0.0) or (1.0, -0.0), and the low part of a NaN\n+is don't-care.\n+\n+Classification\n+--------------\n+\n+A long double can represent any value of the form\n+  s * 2^e * sum(k=0...105: f_k * 2^(-k))\n+where 's' is +1 or -1, 'e' is between 1022 and -968 inclusive, f_0 is\n+1, and f_k for k>0 is 0 or 1.  These are the 'normal' long doubles.\n+\n+A long double can also represent any value of the form\n+  s * 2^-968 * sum(k=0...105: f_k * 2^(-k))\n+where 's' is +1 or -1, f_0 is 0, and f_k for k>0 is 0 or 1.  These are\n+the 'subnormal' long doubles.\n+\n+There are four long doubles that represent zero, two that represent\n++0.0 and two that represent -0.0.  The sign of the high part is the\n+sign of the long double, and the sign of the low part is ignored.\n+\n+Likewise, there are four long doubles that represent infinities, two\n+for +Inf and two for -Inf.\n+\n+Each NaN, quiet or signalling, that can be represented as a 'double'\n+can be represented as a 'long double'.  In fact, there are 2^64\n+equivalent representations for each one.\n+\n+There are certain other valid long doubles where both parts are\n+nonzero but the low part represents a value which has a bit set below\n+2^(e-105).  These, together with the subnormal long doubles, make up\n+the denormal long doubles.\n+\n+Many possible long double bit patterns are not valid long doubles.\n+These do not represent any value.\n+\n+Limits\n+------\n+\n+The maximum representable long double is 2^1024-2^918.  The smallest\n+*normal* positive long double is 2^-968.  The smallest denormalised\n+positive long double is 2^-1074 (this is the same as for 'double').\n+\n+Conversions\n+-----------\n+\n+A double can be converted to a long double by adding a zero low part.\n+\n+A long double can be converted to a double by removing the low part.\n+\n+Comparisons\n+-----------\n+\n+Two long doubles can be compared by comparing the high parts, and if\n+those compare equal, comparing the low parts.\n+\n+Arithmetic\n+----------\n+\n+The unary negate operation operates by negating the low and high parts.\n+\n+An absolute or absolute-negate operation must be done by comparing\n+against zero and negating if necessary.\n+\n+Addition and subtraction are performed using library routines.  They\n+are not at present performed perfectly accurately, the result produced\n+will be within 1ulp of the range generated by adding or subtracting\n+1ulp from the input values, where a 'ulp' is 2^(e-106) given the\n+exponent 'e'.  In the presence of cancellation, this may be\n+arbitrarily inaccurate.  Subtraction is done by negation and addition.\n+\n+Multiplication is also performed using a library routine.  Its result\n+will be within 2ulp of the correct result.\n+\n+Division is also performed using a library routine.  Its result will\n+be within 3ulp of the correct result."}, {"sha": "91c0028158540c23284f3ec439de9b9420cf68c4", "filename": "gcc/config/rs6000/darwin-ldouble.c", "status": "modified", "additions": 39, "deletions": 64, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c?ref=c1e55850cf08c6d0d648fd9cf93359b3254d1f0b", "patch": "@@ -51,9 +51,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #if !_SOFT_FLOAT && (defined (__MACH__) || defined (__powerpc64__))\n \n #define fabs(x) __builtin_fabs(x)\n+#define isless(x, y) __builtin_isless (x, y)\n+#define inf() __builtin_inf()\n \n #define unlikely(x) __builtin_expect ((x), 0)\n \n+#define nonfinite(a) unlikely (! isless (fabs (a), inf ()))\n+\n /* All these routines actually take two long doubles as parameters,\n    but GCC currently generates poor code when a union is used to turn\n    a long double into a pair of doubles.  */\n@@ -69,66 +73,40 @@ typedef union\n   double dval[2];\n } longDblUnion;\n \n-static const double FPKINF = 1.0/0.0;\n-\n /* Add two 'long double' values and return the result.\t*/\n long double\n-_xlqadd (double a, double b, double c, double d)\n+_xlqadd (double a, double aa, double c, double cc)\n {\n-  longDblUnion z;\n-  double t, tau, u, FPR_zero, FPR_PosInf;\n-\n-  FPR_zero = 0.0;\n-  FPR_PosInf = FPKINF;\n-\n-  if (unlikely (a != a) || unlikely (c != c)) \n-    return a + c;  /* NaN result.  */\n+  longDblUnion x;\n+  double z, q, zz, xh;\n \n-  /* Ordered operands are arranged in order of their magnitudes.  */\n+  z = a + c;\n \n-  /* Switch inputs if |(c,d)| > |(a,b)|. */\n-  if (fabs (c) > fabs (a))\n+  if (nonfinite (z))\n     {\n-      t = a;\n-      tau = b;\n-      a = c;\n-      b = d;\n-      c = t;\n-      d = tau;\n+      z = cc + aa + c + a;\n+      if (nonfinite (z))\n+\treturn z;\n+      x.dval[0] = z;  /* Will always be DBL_MAX.  */\n+      zz = aa + cc;\n+      if (fabs(a) > fabs(c))\n+\tx.dval[1] = a - z + c + zz;\n+      else\n+\tx.dval[1] = c - z + a + zz;\n     }\n-\n-  /* b <- second largest magnitude double.  */\n-  if (fabs (c) > fabs (b))\n+  else\n     {\n-      t = b;\n-      b = c;\n-      c = t;\n-    }\n+      q = a - z;\n+      zz = q + c + (a - (q + z)) + aa + cc;\n+      xh = z + zz;\n \n-  /* Thanks to commutativity, sum is invariant w.r.t. the next\n-     conditional exchange.  */\n-  tau = d + c;\n+      if (nonfinite (xh))\n+\treturn xh;\n \n-  /* Order the smallest magnitude doubles.  */\n-  if (fabs (d) > fabs (c))\n-    {\n-      t = c;\n-      c = d;\n-      d = t;\n+      x.dval[0] = xh;\n+      x.dval[1] = z - xh + zz;\n     }\n-\n-  t = (tau + b) + a;\t     /* Sum values in ascending magnitude order.  */\n-\n-  /* Infinite or zero result.  */\n-  if (unlikely (t == FPR_zero) || unlikely (fabs (t) == FPR_PosInf))\n-    return t;\n-\n-  /* Usual case.  */\n-  tau = (((a-t) + b) + c) + d;\n-  u = t + tau;\n-  z.dval[0] = u;\t       /* Final fixup for long double result.  */\n-  z.dval[1] = (t - u) + tau;\n-  return z.ldval;\n+  return x.ldval;\n }\n \n long double\n@@ -141,28 +119,26 @@ long double\n _xlqmul (double a, double b, double c, double d)\n {\n   longDblUnion z;\n-  double t, tau, u, v, w, FPR_zero, FPR_PosInf;\n+  double t, tau, u, v, w;\n   \n-  FPR_zero = 0.0;\n-  FPR_PosInf = FPKINF;\n-\n   t = a * c;\t\t\t/* Highest order double term.  */\n \n-  if (unlikely (t != t) || unlikely (t == FPR_zero) \n-      || unlikely (fabs (t) == FPR_PosInf))\n+  if (unlikely (t == 0)\t\t/* Preserve -0.  */\n+      || nonfinite (t))\n     return t;\n \n-  /* Finite nonzero result requires summing of terms of two highest\n-     orders.\t*/\n+  /* Sum terms of two highest orders. */\n   \n-  /* Use fused multiply-add to get low part of a * c.\t */\n+  /* Use fused multiply-add to get low part of a * c.  */\n   asm (\"fmsub %0,%1,%2,%3\" : \"=f\"(tau) : \"f\"(a), \"f\"(c), \"f\"(t));\n   v = a*d;\n   w = b*c;\n   tau += v + w;\t    /* Add in other second-order terms.\t */\n   u = t + tau;\n \n   /* Construct long double result.  */\n+  if (nonfinite (u))\n+    return u;\n   z.dval[0] = u;\n   z.dval[1] = (t - u) + tau;\n   return z.ldval;\n@@ -172,15 +148,12 @@ long double\n _xlqdiv (double a, double b, double c, double d)\n {\n   longDblUnion z;\n-  double s, sigma, t, tau, u, v, w, FPR_zero, FPR_PosInf;\n-  \n-  FPR_zero = 0.0;\n-  FPR_PosInf = FPKINF;\n+  double s, sigma, t, tau, u, v, w;\n   \n   t = a / c;                    /* highest order double term */\n   \n-  if (unlikely (t != t) || unlikely (t == FPR_zero) \n-      || unlikely (fabs (t) == FPR_PosInf))\n+  if (unlikely (t == 0)\t\t/* Preserve -0.  */\n+      || nonfinite (t))\n     return t;\n \n   /* Finite nonzero result requires corrections to the highest order term.  */\n@@ -197,6 +170,8 @@ _xlqdiv (double a, double b, double c, double d)\n   u = t + tau;\n \n   /* Construct long double result.  */\n+  if (nonfinite (u))\n+    return u;\n   z.dval[0] = u;\n   z.dval[1] = (t - u) + tau;\n   return z.ldval;"}, {"sha": "1f891ac561ee613b052db9ee914946ee70fa12b6", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=c1e55850cf08c6d0d648fd9cf93359b3254d1f0b", "patch": "@@ -68,7 +68,7 @@\n /* The Darwin ABI always includes AltiVec, can't be (validly) turned\n    off.  */\n \n-#define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t  \t\\\n+#define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   rs6000_altivec_abi = 1;\t\t\t\t\t\t\\\n   rs6000_altivec_vrsave = 1;\t\t\t\t\t\t\\\n@@ -87,12 +87,19 @@ do {\t\t\t\t\t\t\t\t\t\\\n         flag_pic = 2;\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n-}while(0)\n+} while(0)\n+\n+/* Darwin has 128-bit long double support in libc in 10.4 and later.\n+   Default to 128-bit long doubles even on earlier platforms for ABI\n+   consistency; arithmetic will work even if libc and libm support is\n+   not available.  */\n+\n+#define RS6000_DEFAULT_LONG_DOUBLE_SIZE 128\n+\n \n /* We want -fPIC by default, unless we're using -static to compile for\n    the kernel or some such.  */\n \n-\n #define CC1_SPEC \"\\\n %{gused: -g -feliminate-unused-debug-symbols %<gused }\\\n %{gfull: -g -fno-eliminate-unused-debug-symbols %<gfull }\\"}, {"sha": "a624764e45455fbff3059db32bedd34d19001c23", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c1e55850cf08c6d0d648fd9cf93359b3254d1f0b", "patch": "@@ -1014,6 +1014,13 @@ rs6000_init_hard_regno_mode_ok (void)\n \trs6000_hard_regno_mode_ok_p[m][r] = true;\n }\n \n+/* If not otherwise specified by a target, make 'long double' equivalent to\n+   'double'.  */\n+\n+#ifndef RS6000_DEFAULT_LONG_DOUBLE_SIZE\n+#define RS6000_DEFAULT_LONG_DOUBLE_SIZE 64\n+#endif\n+\n /* Override command line options.  Mostly we process the processor\n    type and sometimes adjust other TARGET_ options.  */\n \n@@ -1220,7 +1227,7 @@ rs6000_override_options (const char *default_cpu)\n     }\n \n   /* Set size of long double */\n-  rs6000_long_double_type_size = 64;\n+  rs6000_long_double_type_size = RS6000_DEFAULT_LONG_DOUBLE_SIZE;\n   if (rs6000_long_double_size_string)\n     {\n       char *tail;\n@@ -1293,7 +1300,7 @@ rs6000_override_options (const char *default_cpu)\n       if (rs6000_isel_string == 0)\n \trs6000_isel = 0;\n       if (rs6000_long_double_size_string == 0)\n-\trs6000_long_double_type_size = 64;\n+\trs6000_long_double_type_size = RS6000_DEFAULT_LONG_DOUBLE_SIZE;\n     }\n \n   rs6000_always_hint = (rs6000_cpu != PROCESSOR_POWER4\n@@ -3161,8 +3168,7 @@ legitimate_lo_sum_address_p (enum machine_mode mode, rtx x, int strict)\n \treturn false;\n       if (GET_MODE_NUNITS (mode) != 1)\n \treturn false;\n-      if (GET_MODE_BITSIZE (mode) > 32\n-\t  && !(TARGET_HARD_FLOAT && TARGET_FPRS && mode == DFmode))\n+      if (GET_MODE_BITSIZE (mode) > 64)\n \treturn false;\n \n       return CONSTANT_P (x);\n@@ -11054,7 +11060,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n       int j = -1;\n       bool used_update = false;\n \n-      if (GET_CODE (src) == MEM && INT_REGNO_P (reg))\n+      if (MEM_P (src) && INT_REGNO_P (reg))\n         {\n           rtx breg;\n \n@@ -11071,6 +11077,15 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t\t\t : gen_adddi3 (breg, breg, delta_rtx));\n \t      src = gen_rtx_MEM (mode, breg);\n \t    }\n+\t  else if (! offsettable_memref_p (src))\n+\t    {\n+\t      rtx newsrc, basereg;\n+\t      basereg = gen_rtx_REG (Pmode, reg);\n+\t      emit_insn (gen_rtx_SET (VOIDmode, basereg, XEXP (src, 0)));\n+\t      newsrc = gen_rtx_MEM (GET_MODE (src), basereg);\n+\t      MEM_COPY_ATTRIBUTES (newsrc, src);\n+\t      src = newsrc;\n+\t    }\n \n \t  /* We have now address involving an base register only.\n \t     If we use one of the registers to address memory, \n@@ -11118,6 +11133,15 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t\t\t   : gen_adddi3 (breg, breg, delta_rtx));\n \t      dst = gen_rtx_MEM (mode, breg);\n \t    }\n+\t  else if (! offsettable_memref_p (dst))\n+\t    {\n+\t      rtx newdst, basereg;\n+\t      basereg = gen_rtx_REG (Pmode, reg);\n+\t      emit_insn (gen_rtx_SET (VOIDmode, basereg, XEXP (dst, 0)));\n+\t      newdst = gen_rtx_MEM (GET_MODE (dst), basereg);\n+\t      MEM_COPY_ATTRIBUTES (newdst, dst);\n+\t      dst = newdst;\n+\t    }\n \t}\n \n       for (i = 0; i < nregs; i++)"}, {"sha": "8bb22cd6325659590ae673366c677226e4797015", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c1e55850cf08c6d0d648fd9cf93359b3254d1f0b", "patch": "@@ -1,3 +1,7 @@\n+2004-07-30  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/darwin-longdouble.c: New file.\n+\n 2004-07-30  Richard Henderson  <rth@redhat.com>\n \n \t* gfortran.fortran-torture/execute/intrinsic_rrspacing.f90: Fix"}, {"sha": "54f090ddff6b60d34a000ed431cde79e38eefab5", "filename": "gcc/testsuite/gcc.dg/darwin-longdouble.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e55850cf08c6d0d648fd9cf93359b3254d1f0b/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-longdouble.c?ref=c1e55850cf08c6d0d648fd9cf93359b3254d1f0b", "patch": "@@ -0,0 +1,117 @@\n+/* { dg-do run { target powerpc*-*-darwin* } } */\n+/* { dg-options \"\" } */\n+/* No options so 'long long' can be used.  */\n+\n+#include <stdio.h>\n+\n+typedef unsigned long long uint64_t;\n+typedef uint64_t ldbits[2];\n+\n+union ldu \n+{\n+  ldbits lb;\n+  long double ld;\n+};\n+\n+static const struct {\n+  ldbits a;\n+  ldbits b;\n+  ldbits result;\n+} single_tests[] = {\n+  /* Test of values that add to near +Inf.  */\n+  { { 0x7FEFFFFFFFFFFFFFLL, 0xFC88000000000000LL },\n+    { 0x7C94000000000000LL, 0x0000000000000000LL },\n+    { 0x7FEFFFFFFFFFFFFFLL, 0x7C80000000000000LL } },\n+  { { 0x7FEFFFFFFFFFFFFFLL, 0x7C8FFFFFFFFFFFFFLL },\n+    { 0x792FFFFFFFFFFFFFLL, 0x0000000000000000LL },\n+    { 0x7FEFFFFFFFFFFFFFLL, 0x7C8FFFFFFFFFFFFFLL } },\n+  { { 0x7FEFFFFFFFFFFFFFLL, 0x7C8FFFFFFFFFFFFFLL },\n+    { 0x7930000000000000LL, 0xF5DFFFFFFFFFFFFFLL },\n+    /* correct result is: { 0x7FEFFFFFFFFFFFFFLL, 0x7C8FFFFFFFFFFFFFLL } */\n+    { 0x7FF0000000000000LL, 0x0000000000000000LL } },\n+  /* Test of values that add to +Inf.  */\n+  { { 0x7FEFFFFFFFFFFFFFLL, 0x7C8FFFFFFFFFFFFFLL },\n+    { 0x7930000000000000LL, 0x0000000000000000LL },\n+    { 0x7FF0000000000000LL, 0x0000000000000000LL } },\n+  /* Tests of Inf addition.  */\n+  { { 0x7FF0000000000000LL, 0x0000000000000000LL },\n+    { 0x0000000000000000LL, 0x0000000000000000LL },\n+    { 0x7FF0000000000000LL, 0x0000000000000000LL } },\n+  { { 0x7FF0000000000000LL, 0x0000000000000000LL },\n+    { 0x7FF0000000000000LL, 0x0000000000000000LL },\n+    { 0x7FF0000000000000LL, 0x0000000000000000LL } },\n+  /* Test of Inf addition producing NaN.  */\n+  { { 0x7FF0000000000000LL, 0x0000000000000000LL },\n+    { 0xFFF0000000000000LL, 0x0000000000000000LL },\n+    { 0x7FF8000000000000LL, 0x0000000000000000LL } },\n+  /* Tests of NaN addition.  */\n+  { { 0x7FF8000000000000LL, 0x0000000000000000LL },\n+    { 0x0000000000000000LL, 0x0000000000000000LL },\n+    { 0x7FF8000000000000LL, 0x7FF8000000000000LL } },\n+  { { 0x7FF8000000000000LL, 0x0000000000000000LL },\n+    { 0x7FF0000000000000LL, 0x0000000000000000LL },\n+    { 0x7FF8000000000000LL, 0x7FF8000000000000LL } },\n+  /* Addition of positive integers, with interesting rounding properties.  */\n+  { { 0x4690000000000000LL, 0x4330000000000000LL },\n+    { 0x4650000000000009LL, 0xC2FFFFFFFFFFFFF2LL },\n+    /* correct result is: { 0x4691000000000001LL, 0xC32C000000000000LL } */\n+    { 0x4691000000000001LL, 0xc32bfffffffffffeLL } },\n+  { { 0x4690000000000000LL, 0x4330000000000000LL },\n+    { 0x4650000000000008LL, 0x42F0000000000010LL },\n+    { 0x4691000000000001LL, 0xC32E000000000000LL } },\n+  { { 0x469FFFFFFFFFFFFFLL, 0x433FFFFFFFFFFFFFLL },\n+    { 0x4340000000000000LL, 0x3FF0000000000000LL },\n+    { 0x46A0000000000000LL, 0x0000000000000000LL } },\n+  { { 0x469FFFFFFFFFFFFFLL, 0x433FFFFFFFFFFFFFLL },\n+    { 0x4340000000000000LL, 0x0000000000000000LL },\n+    { 0x46A0000000000000LL, 0xBFF0000000000000LL } },\n+  /* Subtraction of integers, with cancellation.  */\n+  { { 0x4690000000000000LL, 0x4330000000000000LL },\n+    { 0xC690000000000000LL, 0xC330000000000000LL },\n+    { 0x0000000000000000LL, 0x0000000000000000LL } },\n+  { { 0x4690000000000000LL, 0x4330000000000000LL },\n+    { 0xC330000000000000LL, 0x0000000000000000LL },\n+    { 0x4690000000000000LL, 0x0000000000000000LL } },\n+  { { 0x4690000000000000LL, 0x4330000000000000LL },\n+    { 0xC330000000000000LL, 0x3FA0000000000000LL },\n+    { 0x4690000000000000LL, 0x3FA0000000000000LL } },\n+  { { 0x4690000000000000LL, 0x4330000000000000LL },\n+    { 0xC690000000000000LL, 0x3FA0000000000000LL },\n+    /* correct result is: { 0x4330000000000000LL, 0x3FA0000000000000LL } */\n+    { 0x4330000000000000LL, 0x0000000000000000LL } }\n+};\n+    \n+static int fail = 0;\n+\n+static void\n+run_single_tests (void)\n+{\n+  size_t i;\n+  for (i = 0; i < sizeof (single_tests) / sizeof (single_tests[0]); i++)\n+    {\n+      union ldu a, b, result, expected;\n+      memcpy (a.lb, single_tests[i].a, sizeof (ldbits));\n+      memcpy (b.lb, single_tests[i].b, sizeof (ldbits));\n+      memcpy (expected.lb, single_tests[i].result, sizeof (ldbits));\n+      result.ld = a.ld + b.ld;\n+      if (memcmp (result.lb, expected.lb,\n+\t\t  result.ld == result.ld ? sizeof (ldbits) : sizeof (double))\n+\t  != 0)\n+\t{\n+\t  printf (\"FAIL: %016llx %016llx + %016llx %016llx\\n\",\n+\t\t  a.lb[0], a.lb[1], b.lb[0], b.lb[1]);\n+\t  printf (\" = %016llx %016llx not %016llx %016llx\\n\",\n+\t\t  result.lb[0], result.lb[1], expected.lb[0], expected.lb[1]);\n+\t  fail = 1;\n+\t}\n+    }\n+}\n+\n+int main(void)\n+{\n+  run_single_tests();\n+  if (fail)\n+    abort ();\n+  else\n+    exit (0);\n+}"}]}