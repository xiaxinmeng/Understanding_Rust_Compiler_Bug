{"sha": "5c856b23687ca60610fb67b80f1e1e663c2db691", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM4NTZiMjM2ODdjYTYwNjEwZmI2N2I4MGYxZTFlNjYzYzJkYjY5MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-06-01T21:31:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-06-01T21:31:42Z"}, "message": "Makefile.in (tracer.o): New.\n\n\n\t* Makefile.in (tracer.o): New.\n\t* params.def (TRACER_*): New options.\n\t* rtl.h (tracer): Declare.\n\t* timevar.def (TV_TRACER): New.\n\t* toplev.c (dump_file_index): Add DFI_tracer.\n\t(dump_file_info): Add tracer.\n\t(flag_tracer): New.\n\t(lang_indepdenent_options): Add tracer.\n\t(rest_of_compilation): Call tracer.\n\t* tracer.c: New file.\n\t* invoke.texi (-ftracer): Document.\n\t(--param tracer-*): Document.\n\nFrom-SVN: r54154", "tree": {"sha": "e841b1f75587810fd318b1bbb37216cd8835c623", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e841b1f75587810fd318b1bbb37216cd8835c623"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c856b23687ca60610fb67b80f1e1e663c2db691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c856b23687ca60610fb67b80f1e1e663c2db691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c856b23687ca60610fb67b80f1e1e663c2db691", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c856b23687ca60610fb67b80f1e1e663c2db691/comments", "author": null, "committer": null, "parents": [{"sha": "e2405951a6550c5f6901988d8afc641baa971325", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2405951a6550c5f6901988d8afc641baa971325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2405951a6550c5f6901988d8afc641baa971325"}], "stats": {"total": 493, "additions": 489, "deletions": 4}, "files": [{"sha": "2e5018942e995c4eeea755fc01ed5a9286468967", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c856b23687ca60610fb67b80f1e1e663c2db691", "patch": "@@ -1,3 +1,18 @@\n+Sat Jun  1 23:29:51 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in (tracer.o): New.\n+\t* params.def (TRACER_*): New options.\n+\t* rtl.h (tracer): Declare.\n+\t* timevar.def (TV_TRACER): New.\n+\t* toplev.c (dump_file_index): Add DFI_tracer.\n+\t(dump_file_info): Add tracer.\n+\t(flag_tracer): New.\n+\t(lang_indepdenent_options): Add tracer.\n+\t(rest_of_compilation): Call tracer.\n+\t* tracer.c: New file.\n+\t* invoke.texi (-ftracer): Document.\n+\t(--param tracer-*): Document.\n+\n 2002-06-01  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-inline.c (expand_call_inline): Make the statement"}, {"sha": "69431fcebf0ff163264b013ef07edaff79b1281e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5c856b23687ca60610fb67b80f1e1e663c2db691", "patch": "@@ -732,7 +732,7 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t\\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t\\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t\\\n  sibcall.o simplify-rtx.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t\\\n- stor-layout.o stringpool.o timevar.o toplev.o tree.o tree-dump.o \t\\\n+ stor-layout.o stringpool.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  tree-inline.o unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o \\\n  $(GGC) $(out_object_file) $(EXTRA_OBJS)\n \n@@ -1596,6 +1596,9 @@ predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) toplev.h $(RTL_H) $(GGC_H)\n bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n    flags.h $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h $(TARGET_H)\n+tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h flags.h \\\n+   $(PARAMS_H) profile.h\n cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n    insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h output.h function.h \\\n    cfglayout.h"}, {"sha": "0b58d11fa8f413a780ccb642ce6565ba9d41c6d3", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5c856b23687ca60610fb67b80f1e1e663c2db691", "patch": "@@ -282,7 +282,7 @@ in the following sections.\n -frerun-cse-after-loop  -frerun-loop-opt @gol\n -fschedule-insns  -fschedule-insns2 @gol\n -fsingle-precision-constant  -fssa -fssa-ccp -fssa-dce @gol\n--fstrength-reduce  -fstrict-aliasing  -fthread-jumps  -ftrapv @gol\n+-fstrength-reduce  -fstrict-aliasing  -ftracer -fthread-jumps  -ftrapv @gol\n -funroll-all-loops  -funroll-loops  @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os}\n@@ -3637,6 +3637,12 @@ those which have no call-preserved registers to use instead.\n For all machines, optimization level 2 and higher enables this flag by\n default.\n \n+@item -ftracer\n+@opindex ftracer\n+Perform tail duplication to enlarge superblock size. This transformation\n+simplifies the control flow of the function allowing other optimizations to do\n+better job.\n+\n @item -funroll-loops\n @opindex funroll-loops\n Unroll loops whose number of iterations can be determined at compile\n@@ -3941,6 +3947,39 @@ given basic block needs to have to be considered hot.\n @item hot-bb-frequency-fraction\n Select fraction of the maximal frequency of executions of basic block in\n function given basic block needs to have to be considered hot\n+\n+@item tracer-dynamic-coverage\n+@itemx tracer-dynamic-coverage-feedback\n+\n+This value is used to limit superblock formation once given percentage of\n+executed instructions is covered.  This limits unnecesary code size expansion.\n+\n+The @option{tracer-dynamic-coverage-feedback} is used only when profile\n+feedback is available.  The real profiles (as opposed to statically estimated\n+ones) are much less balanced allowing the threshold to be larger value.\n+\n+@item tracer-max-code-growth\n+Stop tail duplication once code growth has reached given percentage.  This is\n+rather hokey argument, as most of the duplicates will be elliminated later in\n+cross jumping, so it may be set to much higher values than is the desired code\n+growth.\n+\n+@item tracer-min-branch-ratio\n+\n+Stop reverse growth when the reverse probability of best edge is less than this\n+threshold (in percent).\n+\n+@item tracer-min-branch-ratio\n+@itemx tracer-min-branch-ratio-feedback\n+\n+Stop forward growth if the best edge do have probability lower than this\n+threshold.\n+\n+Similary to @option{tracer-dynamic-coverage} two values are present, one for\n+compilation for profile feedback and one for compilation without.  The value\n+for compilation with profile feedback needs to be more conservative (higher) in\n+order to make tracer effective.\n+\n @end table\n @end table\n "}, {"sha": "1b3105556b2c73bb9dcd835c9e68608d7b0865fc", "filename": "gcc/params.def", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=5c856b23687ca60610fb67b80f1e1e663c2db691", "patch": "@@ -153,12 +153,43 @@ DEFPARAM(PARAM_MAX_UNROLLED_INSNS,\n \n DEFPARAM(HOT_BB_COUNT_FRACTION,\n \t \"hot-bb-count-fraction\",\n-\t \"Select fraction of the maximal count of repetitions of basic block in program given basic block needs to have to be considered hot\",\n+\t \"Select fraction of the maximal count of repetitions of basic block in \\\n+program given basic block needs to have to be considered hot\",\n \t 10000)\n DEFPARAM(HOT_BB_FREQUENCY_FRACTION,\n \t \"hot-bb-frequency-fraction\",\n-\t \"Select fraction of the maximal frequency of executions of basic block in function given basic block needs to have to be considered hot\",\n+\t \"Select fraction of the maximal frequency of executions of basic \\\n+block in function given basic block needs to have to be considered hot\",\n \t 1000)\n+DEFPARAM(TRACER_DYNAMIC_COVERAGE_FEEDBACK,\n+\t \"tracer-dynamic-coverage-feedback\",\n+\t \"The percentage of function, weighted by execution frequency, that \\\n+must be covered by trace formation. Used when profile feedback is available\",\n+\t 95)\n+DEFPARAM(TRACER_DYNAMIC_COVERAGE,\n+\t \"tracer-dynamic-coverage\",\n+\t \"The percentage of function, weighted by execution frequency, that \\\n+must be covered by trace formation. Used when profile feedback is not available\",\n+\t 75)\n+DEFPARAM(TRACER_MAX_CODE_GROWTH,\n+\t \"tracer-max-code-growth\",\n+\t \"Maximal code growth caused by tail duplication (in percents)\",\n+\t 100)\n+DEFPARAM(TRACER_MIN_BRANCH_RATIO,\n+\t \"tracer-min-branch-ratio\",\n+\t \"Stop reverse growth if the reverse probability of best edge is less \\\n+than this threshold (in percents)\",\n+\t 10)\n+DEFPARAM(TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK,\n+\t \"tracer-min-branch-probability-feedback\",\n+\t \"Stop forward growth if the probability of best edge is less than \\\n+this threshold (in percents). Used when profile feedback is available\",\n+\t 30)\n+DEFPARAM(TRACER_MIN_BRANCH_PROBABILITY,\n+\t \"tracer-min-branch-probability\",\n+\t \"Stop forward growth if the probability of best edge is less than \\\n+this threshold (in percents). Used when profile feedback is not available\",\n+\t 50)\n /*\n Local variables:\n mode:c"}, {"sha": "81388eb8b74c7eaeae6d292172ac92485b8d0839", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5c856b23687ca60610fb67b80f1e1e663c2db691", "patch": "@@ -2281,4 +2281,6 @@ extern void if_convert\t\t\tPARAMS ((int));\n /* In predict.c */\n extern void invert_br_probabilities\tPARAMS ((rtx));\n extern bool expensive_function_p\tPARAMS ((int));\n+/* In tracer.c */\n+extern void tracer\t\t\tPARAMS ((void));\n #endif /* ! GCC_RTL_H */"}, {"sha": "49eeedbf0a7e08d3da29b014a21bb07edd15378f", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=5c856b23687ca60610fb67b80f1e1e663c2db691", "patch": "@@ -58,6 +58,7 @@ DEFTIMEVAR (TV_JUMP                  , \"jump\")\n DEFTIMEVAR (TV_CSE                   , \"CSE\")\n DEFTIMEVAR (TV_GCSE                  , \"global CSE\")\n DEFTIMEVAR (TV_LOOP                  , \"loop analysis\")\n+DEFTIMEVAR (TV_TRACER                , \"tracer\")\n DEFTIMEVAR (TV_CSE2                  , \"CSE 2\")\n DEFTIMEVAR (TV_BRANCH_PROB           , \"branch prediction\")\n DEFTIMEVAR (TV_FLOW                  , \"flow analysis\")"}, {"sha": "b9432f44c357de9e02d3bff9f0129dbfbc978218", "filename": "gcc/toplev.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5c856b23687ca60610fb67b80f1e1e663c2db691", "patch": "@@ -224,6 +224,7 @@ enum dump_file_index\n   DFI_loop,\n   DFI_cfg,\n   DFI_bp,\n+  DFI_tracer,\n   DFI_cse2,\n   DFI_life,\n   DFI_combine,\n@@ -271,6 +272,7 @@ static struct dump_file_info dump_file[DFI_MAX] =\n   { \"loop\",\t'L', 1, 0, 0 },\n   { \"cfg\",\t'f', 1, 0, 0 },\n   { \"bp\",\t'b', 1, 0, 0 },\n+  { \"tracer\",\t'T', 1, 0, 0 },\n   { \"cse2\",\t't', 1, 0, 0 },\n   { \"life\",\t'f', 1, 0, 0 },\t/* Yes, duplicate enable switch.  */\n   { \"combine\",\t'c', 1, 0, 0 },\n@@ -866,6 +868,10 @@ int flag_merge_constants = 1;\n    one, unconditionally renumber instruction UIDs.  */\n int flag_renumber_insns = 1;\n \n+/* Nonzero if we perform superblock formation.  */\n+\n+int flag_tracer = 0;\n+\n /* Values of the -falign-* flags: how much to align labels in code.\n    0 means `use default', 1 means `don't align'.\n    For each variable, there is an _log variant which is the power\n@@ -977,6 +983,8 @@ static const lang_independent_options f_options[] =\n    N_(\"When possible do not generate stack frames\") },\n   {\"optimize-sibling-calls\", &flag_optimize_sibling_calls, 1,\n    N_(\"Optimize sibling and tail recursive calls\") },\n+  {\"tracer\", &flag_tracer, 1,\n+   N_(\"Perform superblock formation via tail duplication\") },\n   {\"cse-follow-jumps\", &flag_cse_follow_jumps, 1,\n    N_(\"When running CSE, follow jumps to their targets\") },\n   {\"cse-skip-blocks\", &flag_cse_skip_blocks, 1,\n@@ -2958,6 +2966,19 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_bp, print_rtl_with_bb, insns);\n       timevar_pop (TV_BRANCH_PROB);\n     }\n+  if (flag_tracer)\n+    {\n+      timevar_push (TV_TRACER);\n+      open_dump_file (DFI_tracer, decl);\n+      if (rtl_dump_file)\n+\tdump_flow_info (rtl_dump_file);\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      tracer ();\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      close_dump_file (DFI_tracer, print_rtl_with_bb, get_insns ());\n+      timevar_pop (TV_TRACER);\n+      reg_scan (get_insns (), max_reg_num (), 0);\n+    }\n \n   if (optimize > 0)\n     {"}, {"sha": "b7c5a768b7d70bab10605dea628a1d138614b19b", "filename": "gcc/tracer.c", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c856b23687ca60610fb67b80f1e1e663c2db691/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=5c856b23687ca60610fb67b80f1e1e663c2db691", "patch": "@@ -0,0 +1,373 @@\n+/* The tracer pass for the GNU compiler.\n+   Contributed by Jan Hubicka, SuSE Labs.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* This pass performs the tail duplication needed for superblock formation.\n+   For more information see:\n+\n+     Design and Analysis of Profile-Based Optimization in Compaq's\n+     Compilation Tools for Alpha; Journal of Instruction-Level\n+     Parallelism 3 (2000) 1-25\n+\n+   Unlike Compaq's implementation we don't do the loop peeling as most\n+   probably a better job can be done by a special pass and we don't\n+   need to worry too much about the code size implications as the tail\n+   duplicates are crossjumped again if optimizations are not\n+   performed.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"cfglayout.h\"\n+#include \"fibheap.h\"\n+#include \"flags.h\"\n+#include \"params.h\"\n+#include \"profile.h\"\n+\n+static int count_insns\t\tPARAMS ((basic_block));\n+static bool ignore_bb_p\t\tPARAMS ((basic_block));\n+static bool better_p\t\tPARAMS ((edge, edge));\n+static int find_trace\t\tPARAMS ((basic_block, basic_block *));\n+static void tail_duplicate\tPARAMS ((void));\n+static void layout_superblocks\tPARAMS ((void));\n+static bool ignore_bb_p\t\tPARAMS ((basic_block));\n+\n+/* Minimal outgoing edge probability considered for superblock formation.  */\n+static int probability_cutoff;\n+static int branch_ratio_cutoff;\n+\n+/* Return true if BB has been seen - it is connected to some trace\n+   already.  */\n+\n+#define seen(bb) (RBI (bb)->visited || RBI (bb)->next)\n+\n+/* Return true if we should ignore the basic block for purposes of tracing. */\n+static bool\n+ignore_bb_p (basic_block bb)\n+{\n+  if (bb->index < 0)\n+    return true;\n+  if (!maybe_hot_bb_p (bb))\n+    return true;\n+  return false;\n+}\n+\n+/* Return number of instructions in the block.  */\n+\n+static int\n+count_insns (bb)\n+     basic_block bb;\n+{\n+  rtx insn;\n+  int n = 0;\n+\n+  for (insn = bb->head; insn != NEXT_INSN (bb->end); insn = NEXT_INSN (insn))\n+    if (active_insn_p (insn))\n+      n++;\n+  return n;\n+}\n+\n+/* Return true if E1 is more frequent than E2.  */\n+static bool\n+better_p (e1, e2)\n+     edge e1, e2;\n+{\n+  if (e1->count != e2->count)\n+    return e1->count > e2->count;\n+  if (e1->src->frequency * e1->probability !=\n+      e2->src->frequency * e2->probability)\n+    return (e1->src->frequency * e1->probability\n+\t    > e2->src->frequency * e2->probability);\n+  /* This is needed to avoid changes in the decision after\n+     CFG is modified.  */\n+  if (e1->src != e2->src)\n+    return e1->src->index > e2->src->index;\n+  return e1->dest->index > e2->dest->index;\n+}\n+\n+/* Return most frequent successor of basic block BB.  */\n+\n+static edge\n+find_best_successor (basic_block bb)\n+{\n+  edge e;\n+  edge best = NULL;\n+\n+  for (e = bb->succ; e; e = e->succ_next)\n+    if (!best || better_p (e, best))\n+      best = e;\n+  if (!best || ignore_bb_p (best->dest))\n+    return NULL;\n+  if (best->probability <= probability_cutoff)\n+    return NULL;\n+  return best;\n+}\n+\n+/* Return most frequent predecessor of basic block BB.  */\n+\n+static edge\n+find_best_predecessor (basic_block bb)\n+{\n+  edge e;\n+  edge best = NULL;\n+\n+  for (e = bb->pred; e; e = e->pred_next)\n+    if (!best || better_p (e, best))\n+      best = e;\n+  if (!best || ignore_bb_p (best->src))\n+    return NULL;\n+  if (EDGE_FREQUENCY (best) * REG_BR_PROB_BASE\n+      < bb->frequency * branch_ratio_cutoff)\n+    return NULL;\n+  return best;\n+}\n+\n+/* Find the trace using bb and record it in the TRACE array.\n+   Return number of basic blocks recorded.  */\n+\n+static int\n+find_trace (bb, trace)\n+     basic_block bb;\n+     basic_block *trace;\n+{\n+  int i = 0;\n+  edge e;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Trace seed %i [%i]\", bb->index, bb->frequency);\n+\n+  while ((e = find_best_predecessor (bb)) != NULL)\n+    {\n+      basic_block bb2 = e->src;\n+      if (seen (bb2) || (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n+\t  || find_best_successor (bb2) != e)\n+\tbreak;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \",%i [%i]\", bb->index, bb->frequency);\n+      bb = bb2;\n+    }\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \" forward %i [%i]\", bb->index, bb->frequency);\n+  trace[i++] = bb;\n+\n+  /* Follow the trace in forward direction.  */\n+  while ((e = find_best_successor (bb)) != NULL)\n+    {\n+      bb = e->dest;\n+      if (seen (bb) || (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n+\t  || find_best_predecessor (bb) != e)\n+\tbreak;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \",%i [%i]\", bb->index, bb->frequency);\n+      trace[i++] = bb;\n+    }\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"\\n\");\n+  return i;\n+}\n+\n+/* Look for basic blocks in frequency order, construct traces and tail duplicate\n+   if profitable.  */\n+\n+static void\n+tail_duplicate ()\n+{\n+  fibnode_t *blocks = xcalloc (last_basic_block, sizeof (fibnode_t));\n+  basic_block *trace = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  int *counts = xmalloc (sizeof (int) * last_basic_block);\n+  int ninsns = 0, nduplicated = 0;\n+  gcov_type weighted_insns = 0, traced_insns = 0;\n+  fibheap_t heap = fibheap_new ();\n+  gcov_type cover_insns;\n+  int max_dup_insns;\n+  basic_block bb;\n+\n+  if (profile_info.count_profiles_merged && flag_branch_probabilities)\n+    probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK);\n+  else\n+    probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY);\n+  probability_cutoff = REG_BR_PROB_BASE / 100 * probability_cutoff;\n+\n+  branch_ratio_cutoff =\n+    (REG_BR_PROB_BASE / 100 * PARAM_VALUE (TRACER_MIN_BRANCH_RATIO));\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      int n = count_insns (bb);\n+      if (!ignore_bb_p (bb))\n+\tblocks[bb->index] = fibheap_insert (heap, -bb->frequency,\n+\t\t\t\t\t    bb);\n+\n+      counts [bb->index] = n;\n+      ninsns += n;\n+      weighted_insns += n * bb->frequency;\n+    }\n+\n+  if (profile_info.count_profiles_merged && flag_branch_probabilities)\n+    cover_insns = PARAM_VALUE (TRACER_DYNAMIC_COVERAGE_FEEDBACK);\n+  else\n+    cover_insns = PARAM_VALUE (TRACER_DYNAMIC_COVERAGE);\n+  cover_insns = (weighted_insns * cover_insns + 50) / 100;\n+  max_dup_insns = (ninsns * PARAM_VALUE (TRACER_MAX_CODE_GROWTH) + 50) / 100;\n+\n+  while (traced_insns < cover_insns && nduplicated < max_dup_insns\n+         && !fibheap_empty (heap))\n+    {\n+      basic_block bb = fibheap_extract_min (heap);\n+      int n, pos;\n+\n+      if (!bb)\n+\tbreak;\n+\n+      blocks[bb->index] = NULL;\n+\n+      if (ignore_bb_p (bb))\n+\tcontinue;\n+      if (seen (bb))\n+\tabort ();\n+\n+      n = find_trace (bb, trace);\n+\n+      bb = trace[0];\n+      traced_insns += bb->frequency * counts [bb->index];\n+      if (blocks[bb->index])\n+\t{\n+\t  fibheap_delete_node (heap, blocks[bb->index]);\n+\t  blocks[bb->index] = NULL;\n+\t}\n+\n+      for (pos = 1; pos < n; pos++)\n+\t{\n+\t  basic_block bb2 = trace[pos];\n+\n+\t  if (blocks[bb2->index])\n+\t    {\n+\t      fibheap_delete_node (heap, blocks[bb2->index]);\n+\t      blocks[bb2->index] = NULL;\n+\t    }\n+\t  traced_insns += bb2->frequency * counts [bb2->index];\n+\t  if (bb2->pred && bb2->pred->pred_next\n+\t      && cfg_layout_can_duplicate_bb_p (bb2))\n+\t    {\n+\t      edge e = bb2->pred;\n+\t      basic_block old = bb2;\n+\n+\t      while (e->src != bb)\n+\t\te = e->pred_next;\n+\t      nduplicated += counts [bb2->index];\n+\t      bb2 = cfg_layout_duplicate_bb (bb2, e);\n+\n+\t      /* Reconsider the original copy of block we've duplicated.\n+\t         Removing the most common predecesor may make it to be\n+\t         head.  */\n+\t      blocks[old->index] =\n+\t\tfibheap_insert (heap, -old->frequency, old);\n+\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file, \"Duplicated %i as %i [%i]\\n\",\n+\t\t\t old->index, bb2->index, bb2->frequency);\n+\t    }\n+\t  RBI (bb)->next = bb2;\n+\t  RBI (bb2)->visited = 1;\n+\t  bb = bb2;\n+\t  /* In case the trace became infrequent, stop duplicating.  */\n+\t  if (ignore_bb_p (bb))\n+\t    break;\n+\t}\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \" covered now %.1f\\n\\n\",\n+\t\t traced_insns * 100.0 / weighted_insns);\n+    }\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Duplicated %i insns (%i%%)\\n\", nduplicated,\n+\t     nduplicated * 100 / ninsns);\n+\n+  free (blocks);\n+  free (trace);\n+  free (counts);\n+  fibheap_delete (heap);\n+}\n+\n+/* Connect the superblocks into linear seuqence.  At the moment we attempt to keep\n+   the original order as much as possible, but the algorithm may be made smarter\n+   later if needed.  BB reordering pass should void most of the benefits of such\n+   change though.  */\n+\n+static void\n+layout_superblocks ()\n+{\n+  basic_block end = ENTRY_BLOCK_PTR->succ->dest;\n+  basic_block bb = ENTRY_BLOCK_PTR->succ->dest->next_bb;\n+\n+  while (bb != EXIT_BLOCK_PTR)\n+    {\n+      edge e, best = NULL;\n+      while (RBI (end)->next)\n+\tend = RBI (end)->next;\n+\n+      for (e = end->succ; e; e = e->succ_next)\n+\tif (e->dest != EXIT_BLOCK_PTR\n+\t    && e->dest != ENTRY_BLOCK_PTR->succ->dest\n+\t    && !RBI (e->dest)->visited\n+\t    && (!best || EDGE_FREQUENCY (e) > EDGE_FREQUENCY (best)))\n+\t  best = e;\n+\n+      if (best)\n+\t{\n+\t  RBI (end)->next = best->dest;\n+\t  RBI (best->dest)->visited = 1;\n+\t}\n+      else\n+\tfor (; bb != EXIT_BLOCK_PTR; bb=bb->next_bb)\n+\t  {\n+\t    if (!RBI (bb)->visited)\n+\t      {\n+\t\tRBI (end)->next = bb;\n+\t\tRBI (bb)->visited = 1;\n+\t\tbreak;\n+\t      }\n+\t  }\n+    }\n+}\n+\n+/* Main entry point to this file.  */\n+\n+void\n+tracer ()\n+{\n+  if (n_basic_blocks <= 1)\n+    return;\n+  cfg_layout_initialize ();\n+  mark_dfs_back_edges ();\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+  tail_duplicate ();\n+  layout_superblocks ();\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+  cfg_layout_finalize ();\n+  /* Merge basic blocks in duplicated traces.  */\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+}"}]}