{"sha": "6bd4352429afca8da067b4fa3f52854ce80981a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJkNDM1MjQyOWFmY2E4ZGEwNjdiNGZhM2Y1Mjg1NGNlODA5ODFhNg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-16T23:14:24Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-16T23:14:24Z"}, "message": "(initial_reg_note_copy, final_reg_note_copy): New functions.\n\n(copy_loop_body): Use new function to copy REG_NOTES.\n\nFrom-SVN: r4481", "tree": {"sha": "2f78af2748784d1c2a7964ccca71f8f50bc3f8a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f78af2748784d1c2a7964ccca71f8f50bc3f8a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bd4352429afca8da067b4fa3f52854ce80981a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd4352429afca8da067b4fa3f52854ce80981a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bd4352429afca8da067b4fa3f52854ce80981a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd4352429afca8da067b4fa3f52854ce80981a6/comments", "author": null, "committer": null, "parents": [{"sha": "2dff5a062aaa8e6d326bcce2441adcf3c801fd23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dff5a062aaa8e6d326bcce2441adcf3c801fd23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dff5a062aaa8e6d326bcce2441adcf3c801fd23"}], "stats": {"total": 52, "additions": 48, "deletions": 4}, "files": [{"sha": "71c26a0935f3e976ab53a5fb00e4cb38d4792553", "filename": "gcc/unroll.c", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd4352429afca8da067b4fa3f52854ce80981a6/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd4352429afca8da067b4fa3f52854ce80981a6/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=6bd4352429afca8da067b4fa3f52854ce80981a6", "patch": "@@ -1365,6 +1365,49 @@ calculate_giv_inc (pattern, src_insn, regno)\n   return increment;\n }\n \n+/* Copy REG_NOTES, except for insn references, because not all insn_map\n+   entries are valid yet.  We do need to copy registers now though, because\n+   the reg_map entries can change during copying.  */\n+\n+static rtx\n+initial_reg_note_copy (notes, map)\n+     rtx notes;\n+     struct inline_remap *map;\n+{\n+  rtx copy;\n+\n+  if (notes == 0)\n+    return 0;\n+\n+  copy = rtx_alloc (GET_CODE (notes));\n+  PUT_MODE (copy, GET_MODE (notes));\n+\n+  if (GET_CODE (notes) == EXPR_LIST)\n+    XEXP (copy, 0) = copy_rtx_and_substitute (XEXP (notes, 0), map);\n+  else if (GET_CODE (notes) == INSN_LIST)\n+    /* Don't substitute for these yet.  */\n+    XEXP (copy, 0) = XEXP (notes, 0);\n+  else\n+    abort ();\n+\n+  XEXP (copy, 1) = initial_reg_note_copy (XEXP (notes, 1), map);\n+\n+  return copy;\n+}\n+\n+/* Fixup insn references in copied REG_NOTES.  */\n+\n+static void\n+final_reg_note_copy (notes, map)\n+     rtx notes;\n+     struct inline_remap *map;\n+{\n+  rtx note;\n+\n+  for (note = notes; note; note = XEXP (note, 1))\n+    if (GET_CODE (note) == INSN_LIST)\n+      XEXP (note, 0) = map->insn_map[INSN_UID (XEXP (note, 0))];\n+}\n \n /* Copy each instruction in the loop, substituting from map as appropriate.\n    This is very similar to a loop in expand_inline_function.  */\n@@ -1611,7 +1654,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t      pattern = copy_rtx_and_substitute (pattern, map);\n \t      copy = emit_insn (pattern);\n \t    }\n-\t  /* REG_NOTES will be copied later.  */\n+\t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n \t  \n #ifdef HAVE_cc0\n \t  /* If this insn is setting CC0, it may need to look at\n@@ -1655,6 +1698,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \tcase JUMP_INSN:\n \t  pattern = copy_rtx_and_substitute (PATTERN (insn), map);\n \t  copy = emit_jump_insn (pattern);\n+\t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n \n \t  if (JUMP_LABEL (insn) == start_label && insn == copy_end\n \t      && ! last_iteration)\n@@ -1756,6 +1800,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \tcase CALL_INSN:\n \t  pattern = copy_rtx_and_substitute (PATTERN (insn), map);\n \t  copy = emit_call_insn (pattern);\n+\t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n \n #ifdef HAVE_cc0\n \t  if (cc0_insn)\n@@ -1806,16 +1851,15 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n     }\n   while (insn != copy_end);\n   \n-  /* Now copy the REG_NOTES.  */\n+  /* Now finish coping the REG_NOTES.  */\n   insn = copy_start;\n   do\n     {\n       insn = NEXT_INSN (insn);\n       if ((GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN\n \t   || GET_CODE (insn) == CALL_INSN)\n \t  && map->insn_map[INSN_UID (insn)])\n-\tREG_NOTES (map->insn_map[INSN_UID (insn)])\n-\t  = copy_rtx_and_substitute (REG_NOTES (insn), map);\n+\tfinal_reg_note_copy (REG_NOTES (map->insn_map[INSN_UID (insn)]), map);\n     }\n   while (insn != copy_end);\n "}]}