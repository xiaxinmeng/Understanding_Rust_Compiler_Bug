{"sha": "549bcbd17fb15e3d328a29d014ac983160d5b229", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ5YmNiZDE3ZmIxNWUzZDMyOGEyOWQwMTRhYzk4MzE2MGQ1YjIyOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-07-02T03:19:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-07-02T03:19:45Z"}, "message": "tree.c (decls_same_for_odr, [...]): Remove.\n\n\n\t* tree.c (decls_same_for_odr, decls_same_for_odr,\n\ttypes_same_for_odr): Remove.\n\t(type_in_anonymous_namespace_p): Constify argument.\n\t* tree.h (types_same_for_odr, type_in_anonymous_namespace_p):\n\tConstify.\n\t* ipa-devirt.c (odr_type_d): Add ODR_VIOLATED field.\n\t(main_odr_variant): New function.\n\t(hash_type_name): Make static; update assert; do not ICE on\n\tnon-records.\n\t(types_same_for_odr): Bring here from tree.c; simplify\n\tand remove old structural comparing code that doesn't work\n\tfor templates.\n\t(odr_hasher::equal): Update assert.\n\t(add_type_duplicate): Return true when bases should be computed;\n\treplace incomplete loader by complete; do not output duplicated\n\twarnings; do not ICE on non-records; set odr_violated flag.\n\t(get_odr_type): Be ready to replace incomplete type by complete\n\tone; work on ODR variants instead of main variants; reorder item\n\tin array so bases have still smaller indexes.\n\t(dump_type_inheritance_graph): Be ready for holdes in odr_types\n\tarray.\n\t(possible_polymorphic_call_targets): Do not ICE when BINFO is NULL.\n\nFrom-SVN: r212218", "tree": {"sha": "9e64f1bc05371e097406095323027fe53c72dc75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e64f1bc05371e097406095323027fe53c72dc75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/549bcbd17fb15e3d328a29d014ac983160d5b229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/549bcbd17fb15e3d328a29d014ac983160d5b229", "html_url": "https://github.com/Rust-GCC/gccrs/commit/549bcbd17fb15e3d328a29d014ac983160d5b229", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/549bcbd17fb15e3d328a29d014ac983160d5b229/comments", "author": null, "committer": null, "parents": [{"sha": "5656ccd782e9b488b6c257b3d8e4839353ffc61b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5656ccd782e9b488b6c257b3d8e4839353ffc61b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5656ccd782e9b488b6c257b3d8e4839353ffc61b"}], "stats": {"total": 424, "additions": 220, "deletions": 204}, "files": [{"sha": "1fd8930522c82e0db596770911aaff7457087adc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549bcbd17fb15e3d328a29d014ac983160d5b229/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549bcbd17fb15e3d328a29d014ac983160d5b229/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=549bcbd17fb15e3d328a29d014ac983160d5b229", "patch": "@@ -1,3 +1,28 @@\n+2014-07-01  Jan Hubicka   <hubicka@ucw.cz>\n+\n+\t* tree.c (decls_same_for_odr, decls_same_for_odr,\n+\ttypes_same_for_odr): Remove.\n+\t(type_in_anonymous_namespace_p): Constify argument.\n+\t* tree.h (types_same_for_odr, type_in_anonymous_namespace_p):\n+\tConstify.\n+\t* ipa-devirt.c (odr_type_d): Add ODR_VIOLATED field.\n+\t(main_odr_variant): New function.\n+\t(hash_type_name): Make static; update assert; do not ICE on\n+\tnon-records.\n+\t(types_same_for_odr): Bring here from tree.c; simplify\n+\tand remove old structural comparing code that doesn't work\n+\tfor templates.\n+\t(odr_hasher::equal): Update assert.\n+\t(add_type_duplicate): Return true when bases should be computed;\n+\treplace incomplete loader by complete; do not output duplicated\n+\twarnings; do not ICE on non-records; set odr_violated flag.\n+\t(get_odr_type): Be ready to replace incomplete type by complete\n+\tone; work on ODR variants instead of main variants; reorder item\n+\tin array so bases have still smaller indexes.\n+\t(dump_type_inheritance_graph): Be ready for holdes in odr_types\n+\tarray.\n+\t(possible_polymorphic_call_targets): Do not ICE when BINFO is NULL.\n+\n 2014-07-01  Cary Coutant  <ccoutant@google.com>\n \n \t* dwarf2out.c (remove_addr_table_entry): Remove unnecessary hash table"}, {"sha": "9579afab766406bb185a04bd4eb942e23a677083", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 192, "deletions": 55, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549bcbd17fb15e3d328a29d014ac983160d5b229/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549bcbd17fb15e3d328a29d014ac983160d5b229/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=549bcbd17fb15e3d328a29d014ac983160d5b229", "patch": "@@ -149,9 +149,10 @@ struct GTY(()) odr_type_d\n {\n   /* leader type.  */\n   tree type;\n-  /* All bases.  */\n+  /* All bases; built only for main variants of types  */\n   vec<odr_type> GTY((skip)) bases;\n-  /* All derrived types with virtual methods seen in unit.  */\n+  /* All derrived types with virtual methods seen in unit;\n+     built only for main variants oftypes  */\n   vec<odr_type> GTY((skip)) derived_types;\n \n   /* All equivalent types, if more than one.  */\n@@ -165,6 +166,8 @@ struct GTY(()) odr_type_d\n   bool anonymous_namespace;\n   /* Do we know about all derivations of given type?  */\n   bool all_derivations_known;\n+  /* Did we report ODR violation here?  */\n+  bool odr_violated;\n };\n \n \n@@ -249,12 +252,25 @@ struct odr_hasher\n   static inline void remove (value_type *);\n };\n \n+/* Return type that was declared with T's name so that T is an\n+   qualified variant of it.  */\n+\n+static inline tree\n+main_odr_variant (const_tree t)\n+{\n+  if (TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)\n+    return TREE_TYPE (TYPE_NAME (t));\n+  /* Unnamed types and non-C++ produced types can be compared by variants.  */\n+  else\n+    return TYPE_MAIN_VARIANT (t);\n+}\n+\n /* Produce hash based on type name.  */\n \n-hashval_t\n+static hashval_t\n hash_type_name (tree t)\n {\n-  gcc_checking_assert (TYPE_MAIN_VARIANT (t) == t);\n+  gcc_checking_assert (main_odr_variant (t) == t);\n \n   /* If not in LTO, all main variants are unique, so we can do\n      pointer hash.  */\n@@ -266,7 +282,8 @@ hash_type_name (tree t)\n     return htab_hash_pointer (t);\n \n   /* For polymorphic types, we can simply hash the virtual table.  */\n-  if (TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n+  if (TREE_CODE (t) == RECORD_TYPE\n+      && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n     {\n       tree v = BINFO_VTABLE (TYPE_BINFO (t));\n       hashval_t hash = 0;\n@@ -294,6 +311,61 @@ odr_hasher::hash (const value_type *odr_type)\n   return hash_type_name (odr_type->type);\n }\n \n+/* For languages with One Definition Rule, work out if\n+   types are the same based on their name.\n+ \n+   This is non-trivial for LTO where minnor differences in\n+   the type representation may have prevented type merging\n+   to merge two copies of otherwise equivalent type.\n+\n+   Until we start streaming mangled type names, this function works\n+   only for polymorphic types.  */\n+\n+bool\n+types_same_for_odr (const_tree type1, const_tree type2)\n+{\n+  gcc_checking_assert (TYPE_P (type1) && TYPE_P (type2));\n+\n+  type1 = main_odr_variant (type1);\n+  type2 = main_odr_variant (type2);\n+\n+  if (type1 == type2)\n+    return true;\n+\n+  if (!in_lto_p)\n+    return false;\n+\n+  /* Check for anonymous namespaces. Those have !TREE_PUBLIC\n+     on the corresponding TYPE_STUB_DECL.  */\n+  if (type_in_anonymous_namespace_p (type1)\n+      || type_in_anonymous_namespace_p (type2))\n+    return false;\n+\n+  /* At the moment we have no way to establish ODR equivlaence at LTO\n+     other than comparing virtual table pointrs of polymorphic types.\n+     Eventually we should start saving mangled names in TYPE_NAME.\n+     Then this condition will become non-trivial.  */\n+\n+  if (TREE_CODE (type1) == RECORD_TYPE\n+      && TYPE_BINFO (type1) && TYPE_BINFO (type2)\n+      && BINFO_VTABLE (TYPE_BINFO (type1))\n+      && BINFO_VTABLE (TYPE_BINFO (type2)))\n+    {\n+      tree v1 = BINFO_VTABLE (TYPE_BINFO (type1));\n+      tree v2 = BINFO_VTABLE (TYPE_BINFO (type2));\n+      gcc_assert (TREE_CODE (v1) == POINTER_PLUS_EXPR\n+\t\t  && TREE_CODE (v2) == POINTER_PLUS_EXPR);\n+      return (operand_equal_p (TREE_OPERAND (v1, 1),\n+\t\t\t       TREE_OPERAND (v2, 1), 0)\n+\t      && DECL_ASSEMBLER_NAME\n+\t\t     (TREE_OPERAND (TREE_OPERAND (v1, 0), 0))\n+\t\t == DECL_ASSEMBLER_NAME\n+\t\t     (TREE_OPERAND (TREE_OPERAND (v2, 0), 0)));\n+    }\n+  gcc_unreachable ();\n+}\n+\n+\n /* Compare types T1 and T2 and return true if they are\n    equivalent.  */\n \n@@ -302,7 +374,7 @@ odr_hasher::equal (const value_type *t1, const compare_type *ct2)\n {\n   tree t2 = const_cast <tree> (ct2);\n \n-  gcc_checking_assert (TYPE_MAIN_VARIANT (ct2) == ct2);\n+  gcc_checking_assert (main_odr_variant (t2) == t2);\n   if (t1->type == t2)\n     return true;\n   if (!in_lto_p)\n@@ -350,20 +422,34 @@ set_type_binfo (tree type, tree binfo)\n    all variants of the same type.  It may or may not mean the ODR violation.\n    Add it to the list of duplicates and warn on some violations.  */\n \n-static void\n+static bool\n add_type_duplicate (odr_type val, tree type)\n {\n+  bool build_bases = false;\n   if (!val->types_set)\n     val->types_set = pointer_set_create ();\n \n+  /* Always prefer complete type to be the leader.  */\n+  if (!COMPLETE_TYPE_P (val->type)\n+      && COMPLETE_TYPE_P (type))\n+    {\n+      tree tmp = type;\n+\n+      build_bases = true;\n+      type = val->type;\n+      val->type = tmp;\n+    }\n+\n   /* See if this duplicate is new.  */\n   if (!pointer_set_insert (val->types_set, type))\n     {\n       bool merge = true;\n       bool base_mismatch = false;\n+      bool warned = 0;\n+      unsigned int i,j;\n+\n       gcc_assert (in_lto_p);\n       vec_safe_push (val->types, type);\n-      unsigned int i,j;\n \n       /* First we compare memory layout.  */\n       if (!types_compatible_p (val->type, type))\n@@ -374,9 +460,13 @@ add_type_duplicate (odr_type val, tree type)\n \t      && warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (type)), 0,\n \t\t\t     \"type %qD violates one definition rule  \",\n \t\t\t     type))\n-\t    inform (DECL_SOURCE_LOCATION (TYPE_NAME (val->type)),\n-\t\t    \"a type with the same name but different layout is \"\n-\t\t    \"defined in another translation unit\");\n+\t    {\n+\t      inform (DECL_SOURCE_LOCATION (TYPE_NAME (val->type)),\n+\t\t      \"a type with the same name but different layout is \"\n+\t\t      \"defined in another translation unit\");\n+\t      warned = true;\n+\t    }\n+\t  val->odr_violated = true;\n \t  if (cgraph_dump_file)\n \t    {\n \t      fprintf (cgraph_dump_file, \"ODR violation or merging or ODR type bug?\\n\");\n@@ -390,37 +480,45 @@ add_type_duplicate (odr_type val, tree type)\n \n       /* Next sanity check that bases are the same.  If not, we will end\n \t up producing wrong answers.  */\n-      for (j = 0, i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n-\tif (polymorphic_type_binfo_p (BINFO_BASE_BINFO (TYPE_BINFO (type), i)))\n-\t  {\n-\t    odr_type base = get_odr_type\n-\t\t\t       (BINFO_TYPE\n-\t\t\t\t  (BINFO_BASE_BINFO (TYPE_BINFO (type),\n-\t\t\t\t\t\t     i)),\n-\t\t\t\ttrue);\n-\t    if (val->bases.length () <= j || val->bases[j] != base)\n-\t      base_mismatch = true;\n-\t    j++;\n-\t  }\n-      if (base_mismatch)\n+      if (COMPLETE_TYPE_P (type) && COMPLETE_TYPE_P (val->type)\n+\t  && TREE_CODE (val->type) == RECORD_TYPE\n+\t  && TREE_CODE (type) == RECORD_TYPE\n+\t  && TYPE_BINFO (val->type) && TYPE_BINFO (type))\n \t{\n-\t  merge = false;\n-\t  odr_violation_reported = true;\n-\n-\t  if (warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (type)), 0,\n-\t\t\t  \"type %qD violates one definition rule  \",\n-\t\t\t  type))\n-\t    inform (DECL_SOURCE_LOCATION (TYPE_NAME (val->type)),\n-\t\t    \"a type with the same name but different bases is \"\n-\t\t    \"defined in another translation unit\");\n-\t  if (cgraph_dump_file)\n+\t  for (j = 0, i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n+\t    if (polymorphic_type_binfo_p (BINFO_BASE_BINFO (TYPE_BINFO (type), i)))\n+\t      {\n+\t\todr_type base = get_odr_type\n+\t\t\t\t   (BINFO_TYPE\n+\t\t\t\t      (BINFO_BASE_BINFO (TYPE_BINFO (type),\n+\t\t\t\t\t\t\t i)),\n+\t\t\t\t    true);\n+\t\tif (val->bases.length () <= j || val->bases[j] != base)\n+\t\t  base_mismatch = true;\n+\t\tj++;\n+\t      }\n+\t  if (base_mismatch)\n \t    {\n-\t      fprintf (cgraph_dump_file, \"ODR bse violation or merging bug?\\n\");\n-\t    \n-\t      print_node (cgraph_dump_file, \"\", val->type, 0);\n-\t      putc ('\\n',cgraph_dump_file);\n-\t      print_node (cgraph_dump_file, \"\", type, 0);\n-\t      putc ('\\n',cgraph_dump_file);\n+\t      merge = false;\n+\t      odr_violation_reported = true;\n+\n+\t      if (!warned\n+\t\t  && warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (type)), 0,\n+\t\t\t         \"type %qD violates one definition rule  \",\n+\t\t\t         type))\n+\t\tinform (DECL_SOURCE_LOCATION (TYPE_NAME (val->type)),\n+\t\t\t\"a type with the same name but different bases is \"\n+\t\t\t\"defined in another translation unit\");\n+\t      val->odr_violated = true;\n+\t      if (cgraph_dump_file)\n+\t\t{\n+\t\t  fprintf (cgraph_dump_file, \"ODR bse violation or merging bug?\\n\");\n+\t\t\n+\t\t  print_node (cgraph_dump_file, \"\", val->type, 0);\n+\t\t  putc ('\\n',cgraph_dump_file);\n+\t\t  print_node (cgraph_dump_file, \"\", type, 0);\n+\t\t  putc ('\\n',cgraph_dump_file);\n+\t\t}\n \t    }\n \t}\n \n@@ -436,7 +534,14 @@ add_type_duplicate (odr_type val, tree type)\n \t merged LTO unit.  For this reason we absolutely need to remove\n \t them and replace by internal variants. Not doing so will lead\n          to incomplete answers from possible_polymorphic_call_targets.  */\n-      if (!flag_ltrans && merge)\n+      if (!flag_ltrans && merge\n+\t  && TREE_CODE (val->type) == RECORD_TYPE\n+\t  && TREE_CODE (type) == RECORD_TYPE\n+\t  && TYPE_BINFO (val->type) && TYPE_BINFO (type)\n+\t  && TYPE_MAIN_VARIANT (type) == type\n+\t  && TYPE_MAIN_VARIANT (val->type) == val->type\n+\t  && BINFO_VTABLE (TYPE_BINFO (val->type))\n+\t  && BINFO_VTABLE (TYPE_BINFO (type)))\n \t{\n \t  tree master_binfo = TYPE_BINFO (val->type);\n \t  tree v1 = BINFO_VTABLE (master_binfo);\n@@ -470,6 +575,7 @@ add_type_duplicate (odr_type val, tree type)\n \t    set_type_binfo (type, master_binfo);\n \t}\n     }\n+  return build_bases;\n }\n \n /* Get ODR type hash entry for TYPE.  If INSERT is true, create\n@@ -481,9 +587,12 @@ get_odr_type (tree type, bool insert)\n   odr_type_d **slot;\n   odr_type val;\n   hashval_t hash;\n+  bool build_bases = false;\n+  bool insert_to_odr_array = false;\n+  int base_id = -1;\n+\n+  type = main_odr_variant (type);\n \n-  type = TYPE_MAIN_VARIANT (type);\n-  gcc_checking_assert (TYPE_MAIN_VARIANT (type) == type);\n   hash = hash_type_name (type);\n   slot\n      = odr_hash->find_slot_with_hash (type, hash, insert ? INSERT : NO_INSERT);\n@@ -498,19 +607,28 @@ get_odr_type (tree type, bool insert)\n       /* With LTO we need to support multiple tree representation of\n \t the same ODR type.  */\n       if (val->type != type)\n-        add_type_duplicate (val, type);\n+        build_bases = add_type_duplicate (val, type);\n     }\n   else\n     {\n-      tree binfo = TYPE_BINFO (type);\n-      unsigned int i;\n \n       val = ggc_cleared_alloc<odr_type_d> ();\n       val->type = type;\n-      gcc_assert (BINFO_TYPE (TYPE_BINFO (val->type)) = type);\n       val->bases = vNULL;\n       val->derived_types = vNULL;\n       val->anonymous_namespace = type_in_anonymous_namespace_p (type);\n+      build_bases = COMPLETE_TYPE_P (val->type);\n+      insert_to_odr_array = true;\n+    }\n+\n+  if (build_bases && TREE_CODE (type) == RECORD_TYPE && TYPE_BINFO (type)\n+      && type == TYPE_MAIN_VARIANT (type))\n+    {\n+      tree binfo = TYPE_BINFO (type);\n+      unsigned int i;\n+\n+      gcc_assert (BINFO_TYPE (TYPE_BINFO (val->type)) = type);\n+  \n       val->all_derivations_known = type_all_derivations_known_p (type);\n       *slot = val;\n       for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); i++)\n@@ -522,14 +640,30 @@ get_odr_type (tree type, bool insert)\n \t    odr_type base = get_odr_type (BINFO_TYPE (BINFO_BASE_BINFO (binfo,\n \t\t\t\t\t\t\t\t\ti)),\n \t\t\t\t\t  true);\n+\t    gcc_assert (TYPE_MAIN_VARIANT (base->type) == base->type);\n \t    base->derived_types.safe_push (val);\n \t    val->bases.safe_push (base);\n+\t    if (base->id > base_id)\n+\t      base_id = base->id;\n \t  }\n-      /* First record bases, then add into array so ids are increasing.  */\n+      }\n+  /* Ensure that type always appears after bases.  */\n+  if (insert_to_odr_array)\n+    {\n       if (odr_types_ptr)\n         val->id = odr_types.length ();\n       vec_safe_push (odr_types_ptr, val);\n     }\n+  else if (base_id > val->id)\n+    {\n+      odr_types[val->id] = 0;\n+      /* Be sure we did not recorded any derived types; these may need\n+\t renumbering too.  */\n+      gcc_assert (val->derived_types.length() == 0);\n+      if (odr_types_ptr)\n+\tval->id = odr_types.length ();\n+      vec_safe_push (odr_types_ptr, val);\n+    }\n   return val;\n }\n \n@@ -577,12 +711,12 @@ dump_type_inheritance_graph (FILE *f)\n   fprintf (f, \"\\n\\nType inheritance graph:\\n\");\n   for (i = 0; i < odr_types.length (); i++)\n     {\n-      if (odr_types[i]->bases.length () == 0)\n+      if (odr_types[i] && odr_types[i]->bases.length () == 0)\n \tdump_odr_type (f, odr_types[i]);\n     }\n   for (i = 0; i < odr_types.length (); i++)\n     {\n-      if (odr_types[i]->types && odr_types[i]->types->length ())\n+      if (odr_types[i] && odr_types[i]->types && odr_types[i]->types->length ())\n \t{\n \t  unsigned int j;\n \t  fprintf (f, \"Duplicate tree types for odr type %i\\n\", i);\n@@ -637,7 +771,8 @@ build_type_inheritance_graph (void)\n     if (is_a <cgraph_node *> (n)\n \t&& DECL_VIRTUAL_P (n->decl)\n \t&& symtab_real_symbol_p (n))\n-      get_odr_type (method_class_type (TREE_TYPE (n->decl)), true);\n+      get_odr_type (TYPE_MAIN_VARIANT (method_class_type (TREE_TYPE (n->decl))),\n+\t\t    true);\n \n     /* Look also for virtual tables of types that do not define any methods.\n  \n@@ -663,7 +798,7 @@ build_type_inheritance_graph (void)\n \t     && TREE_CODE (DECL_CONTEXT (n->decl)) == RECORD_TYPE\n \t     && TYPE_BINFO (DECL_CONTEXT (n->decl))\n \t     && polymorphic_type_binfo_p (TYPE_BINFO (DECL_CONTEXT (n->decl))))\n-      get_odr_type (DECL_CONTEXT (n->decl), true);\n+      get_odr_type (TYPE_MAIN_VARIANT (DECL_CONTEXT (n->decl)), true);\n   if (inheritance_dump_file)\n     {\n       dump_type_inheritance_graph (inheritance_dump_file);\n@@ -1758,7 +1893,8 @@ possible_polymorphic_call_targets (tree otr_type,\n       gcc_assert (in_lto_p || context.maybe_derived_type);\n     }\n \n-  pointer_set_insert (matched_vtables, BINFO_VTABLE (binfo));\n+  if (binfo)\n+    pointer_set_insert (matched_vtables, BINFO_VTABLE (binfo));\n \n   /* Next walk recursively all derived types.  */\n   if (context.maybe_derived_type)\n@@ -1827,7 +1963,7 @@ dump_possible_polymorphic_call_targets (FILE *f,\n {\n   vec <cgraph_node *> targets;\n   bool final;\n-  odr_type type = get_odr_type (otr_type, false);\n+  odr_type type = get_odr_type (TYPE_MAIN_VARIANT (otr_type), false);\n   unsigned int i;\n   int nonconstruction;\n \n@@ -1926,7 +2062,8 @@ update_type_inheritance_graph (void)\n     if (DECL_VIRTUAL_P (n->decl)\n \t&& !n->definition\n \t&& symtab_real_symbol_p (n))\n-      get_odr_type (method_class_type (TREE_TYPE (n->decl)), true);\n+      get_odr_type (method_class_type (TYPE_MAIN_VARIANT (TREE_TYPE (n->decl))),\n+\t\t\t\t       true);\n   timevar_pop (TV_IPA_INHERITANCE);\n }\n "}, {"sha": "2c8159679e824fd3eea86a8312f864288643af3a", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 147, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549bcbd17fb15e3d328a29d014ac983160d5b229/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549bcbd17fb15e3d328a29d014ac983160d5b229/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=549bcbd17fb15e3d328a29d014ac983160d5b229", "patch": "@@ -232,7 +232,6 @@ static void print_value_expr_statistics (void);\n static int type_hash_marked_p (const void *);\n static unsigned int type_hash_list (const_tree, hashval_t);\n static unsigned int attribute_hash_list (const_tree, hashval_t);\n-static bool decls_same_for_odr (tree decl1, tree decl2);\n \n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n@@ -11821,151 +11820,6 @@ lhd_gcc_personality (void)\n   return gcc_eh_personality_decl;\n }\n \n-/* For languages with One Definition Rule, work out if\n-   trees are actually the same even if the tree representation\n-   differs.  This handles only decls appearing in TYPE_NAME\n-   and TYPE_CONTEXT.  That is NAMESPACE_DECL, TYPE_DECL,\n-   RECORD_TYPE and IDENTIFIER_NODE.  */\n-\n-static bool\n-same_for_odr (tree t1, tree t2)\n-{\n-  if (t1 == t2)\n-    return true;\n-  if (!t1 || !t2)\n-    return false;\n-  /* C and C++ FEs differ by using IDENTIFIER_NODE and TYPE_DECL.  */\n-  if (TREE_CODE (t1) == IDENTIFIER_NODE\n-      && TREE_CODE (t2) == TYPE_DECL\n-      && DECL_FILE_SCOPE_P (t1))\n-    {\n-      t2 = DECL_NAME (t2);\n-      gcc_assert (TREE_CODE (t2) == IDENTIFIER_NODE);\n-    }\n-  if (TREE_CODE (t2) == IDENTIFIER_NODE\n-      && TREE_CODE (t1) == TYPE_DECL\n-      && DECL_FILE_SCOPE_P (t2))\n-    {\n-      t1 = DECL_NAME (t1);\n-      gcc_assert (TREE_CODE (t1) == IDENTIFIER_NODE);\n-    }\n-  if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return false;\n-  if (TYPE_P (t1))\n-    return types_same_for_odr (t1, t2);\n-  if (DECL_P (t1))\n-    return decls_same_for_odr (t1, t2);\n-  return false;\n-}\n-\n-/* For languages with One Definition Rule, work out if\n-   decls are actually the same even if the tree representation\n-   differs.  This handles only decls appearing in TYPE_NAME\n-   and TYPE_CONTEXT.  That is NAMESPACE_DECL, TYPE_DECL,\n-   RECORD_TYPE and IDENTIFIER_NODE.  */\n-\n-static bool\n-decls_same_for_odr (tree decl1, tree decl2)\n-{\n-  if (decl1 && TREE_CODE (decl1) == TYPE_DECL\n-      && DECL_ORIGINAL_TYPE (decl1))\n-    decl1 = DECL_ORIGINAL_TYPE (decl1);\n-  if (decl2 && TREE_CODE (decl2) == TYPE_DECL\n-      && DECL_ORIGINAL_TYPE (decl2))\n-    decl2 = DECL_ORIGINAL_TYPE (decl2);\n-  if (decl1 == decl2)\n-    return true;\n-  if (!decl1 || !decl2)\n-    return false;\n-  gcc_checking_assert (DECL_P (decl1) && DECL_P (decl2));\n-  if (TREE_CODE (decl1) != TREE_CODE (decl2))\n-    return false;\n-  if (TREE_CODE (decl1) == TRANSLATION_UNIT_DECL)\n-    return true;\n-  if (TREE_CODE (decl1) != NAMESPACE_DECL\n-      && TREE_CODE (decl1) != TYPE_DECL)\n-    return false;\n-  if (!DECL_NAME (decl1))\n-    return false;\n-  gcc_checking_assert (TREE_CODE (DECL_NAME (decl1)) == IDENTIFIER_NODE);\n-  gcc_checking_assert (!DECL_NAME (decl2)\n-\t\t       ||  TREE_CODE (DECL_NAME (decl2)) == IDENTIFIER_NODE);\n-  if (DECL_NAME (decl1) != DECL_NAME (decl2))\n-    return false;\n-  return same_for_odr (DECL_CONTEXT (decl1),\n-\t\t       DECL_CONTEXT (decl2));\n-}\n-\n-/* For languages with One Definition Rule, work out if\n-   types are same even if the tree representation differs. \n-   This is non-trivial for LTO where minnor differences in\n-   the type representation may have prevented type merging\n-   to merge two copies of otherwise equivalent type.  */\n-\n-bool\n-types_same_for_odr (tree type1, tree type2)\n-{\n-  gcc_checking_assert (TYPE_P (type1) && TYPE_P (type2));\n-  type1 = TYPE_MAIN_VARIANT (type1);\n-  type2 = TYPE_MAIN_VARIANT (type2);\n-  if (type1 == type2)\n-    return true;\n-\n-#ifndef ENABLE_CHECKING\n-  if (!in_lto_p)\n-    return false;\n-#endif\n-\n-  /* Check for anonymous namespaces. Those have !TREE_PUBLIC\n-     on the corresponding TYPE_STUB_DECL.  */\n-  if (type_in_anonymous_namespace_p (type1)\n-      || type_in_anonymous_namespace_p (type2))\n-    return false;\n-  /* When assembler name of virtual table is available, it is\n-     easy to compare types for equivalence.  */\n-  if (TYPE_BINFO (type1) && TYPE_BINFO (type2)\n-      && BINFO_VTABLE (TYPE_BINFO (type1))\n-      && BINFO_VTABLE (TYPE_BINFO (type2)))\n-    {\n-      tree v1 = BINFO_VTABLE (TYPE_BINFO (type1));\n-      tree v2 = BINFO_VTABLE (TYPE_BINFO (type2));\n-\n-      if (TREE_CODE (v1) == POINTER_PLUS_EXPR)\n-\t{\n-\t  if (TREE_CODE (v2) != POINTER_PLUS_EXPR\n-\t      || !operand_equal_p (TREE_OPERAND (v1, 1),\n-\t\t\t     TREE_OPERAND (v2, 1), 0))\n-\t    return false;\n-\t  v1 = TREE_OPERAND (TREE_OPERAND (v1, 0), 0);\n-\t  v2 = TREE_OPERAND (TREE_OPERAND (v2, 0), 0);\n-\t}\n-      v1 = DECL_ASSEMBLER_NAME (v1);\n-      v2 = DECL_ASSEMBLER_NAME (v2);\n-      return (v1 == v2);\n-    }\n-\n-  /* FIXME: the code comparing type names consider all instantiations of the\n-     same template to have same name.  This is because we have no access\n-     to template parameters.  For types with no virtual method tables\n-     we thus can return false positives.  At the moment we do not need\n-     to compare types in other scenarios than devirtualization.  */\n-\n-  /* If types are not structuraly same, do not bother to contnue.\n-     Match in the remainder of code would mean ODR violation.  */\n-  if (!types_compatible_p (type1, type2))\n-    return false;\n-  if (!TYPE_NAME (type1))\n-    return false;\n-  if (!decls_same_for_odr (TYPE_NAME (type1), TYPE_NAME (type2)))\n-    return false;\n-  if (!same_for_odr (TYPE_CONTEXT (type1), TYPE_CONTEXT (type2)))\n-    return false;\n-  /* When not in LTO the MAIN_VARIANT check should be the same.  */\n-  gcc_assert (in_lto_p);\n-    \n-  return true;\n-}\n-\n /* TARGET is a call target of GIMPLE call statement\n    (obtained by gimple_call_fn).  Return true if it is\n    OBJ_TYPE_REF representing an virtual call of C++ method.\n@@ -12009,7 +11863,7 @@ obj_type_ref_class (tree ref)\n /* Return true if T is in anonymous namespace.  */\n \n bool\n-type_in_anonymous_namespace_p (tree t)\n+type_in_anonymous_namespace_p (const_tree t)\n {\n   return (TYPE_STUB_DECL (t) && !TREE_PUBLIC (TYPE_STUB_DECL (t)));\n }"}, {"sha": "8fa928bfcf839a94481e9c391fcb60eceb1121fa", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549bcbd17fb15e3d328a29d014ac983160d5b229/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549bcbd17fb15e3d328a29d014ac983160d5b229/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=549bcbd17fb15e3d328a29d014ac983160d5b229", "patch": "@@ -4316,9 +4316,9 @@ extern tree block_ultimate_origin (const_tree);\n extern tree get_binfo_at_offset (tree, HOST_WIDE_INT, tree);\n extern bool virtual_method_call_p (tree);\n extern tree obj_type_ref_class (tree ref);\n-extern bool types_same_for_odr (tree type1, tree type2);\n+extern bool types_same_for_odr (const_tree type1, const_tree type2);\n extern bool contains_bitfld_component_ref_p (const_tree);\n-extern bool type_in_anonymous_namespace_p (tree);\n+extern bool type_in_anonymous_namespace_p (const_tree);\n extern bool block_may_fallthru (const_tree);\n extern void using_eh_for_cleanups (void);\n extern bool using_eh_for_cleanups_p (void);"}]}