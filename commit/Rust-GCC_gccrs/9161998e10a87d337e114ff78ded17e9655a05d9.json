{"sha": "9161998e10a87d337e114ff78ded17e9655a05d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE2MTk5OGUxMGE4N2QzMzdlMTE0ZmY3OGRlZDE3ZTk2NTVhMDVkOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-23T22:45:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-23T22:45:15Z"}, "message": "(MOTOROLA): Define this.\n\n(VERSADOS): This the name of the DPX2 assembler. Define this in case.\n(USG): Define this.\n(SGS_NO_LI): define this to suppress jump table usage.\n(TARGET_DEFAULT): Define this to 3 inside the conditional USE_GAS since\nbitfields do not work a clean way on DPX2.\n(EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, SELECT_RTX_SECTION):\n#undef these.\n(READONLY_DATA_SECTION): Define to data_section.\n(*_ASM_OP, ASM_OUTPUT_*): Define these accordingly to the native assembler\nsyntax.\n(LONG_DOUBLE_TYPE_SIZE): Set to 64 to not use XFmode.\n(REAL_ARITHMETIC): Define this to use the software floating point emulator.\n(JUMP_TABLES_IN_TEXT_SECTION): Define this to 1.\n(FUNCTION_PROLOGUE, FUNCTION_EPILOGUE): Override m68k.h default.\n(ASM_OUTPUT_ASCII): add a new variable to take care of the lentgh of the\noperand field which must be < 80 chars.\n(PRINT_OPERAND_ADDRESS): Override m68k.h default.\n(PUT_SDB_TYPE): Output type in decimal.\n(PUT_SDB_FUNCTION_[START|END]): Override sdbout.c default.\n(PUT_SDB_BLOCK_[START|END]): Override sdbout.c default.\n\nFrom-SVN: r5195", "tree": {"sha": "fa06b254f0d930de30431ed1d9fa5950efe351c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa06b254f0d930de30431ed1d9fa5950efe351c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9161998e10a87d337e114ff78ded17e9655a05d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9161998e10a87d337e114ff78ded17e9655a05d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9161998e10a87d337e114ff78ded17e9655a05d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9161998e10a87d337e114ff78ded17e9655a05d9/comments", "author": null, "committer": null, "parents": [{"sha": "35e66bd1d966810d0939fb61573d49a79467d694", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e66bd1d966810d0939fb61573d49a79467d694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35e66bd1d966810d0939fb61573d49a79467d694"}], "stats": {"total": 766, "additions": 717, "deletions": 49}, "files": [{"sha": "77902cb64eaa43a24b77c3b61e5bfcfed234ee2b", "filename": "gcc/config/m68k/dpx2.h", "status": "modified", "additions": 717, "deletions": 49, "changes": 766, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9161998e10a87d337e114ff78ded17e9655a05d9/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9161998e10a87d337e114ff78ded17e9655a05d9/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fdpx2.h?ref=9161998e10a87d337e114ff78ded17e9655a05d9", "patch": "@@ -1,12 +1,22 @@\n /*\n- * dpx2.h - Bull DPX/2 200 and 300 systems (m68k, SysVr3)\n+   dpx2.h - Bull DPX/2 200 and 300 systems (m68k, SysVr3).\n+\n+   Contributed by Frederic Pierresteguy.\n+   Bug reports to F.Pierresteguy@frcl.bull.fr.\n  */\n \n+#ifndef USE_GAS\n+#define MOTOROLA\t   /* Use Motorola syntax rather than \"MIT\" */\n+#define SGS_NO_LI\t   /* Suppress jump table label usage */\n+#define VERSADOS           /* This is the name of the assembler we have */\n+#define USG\n+#endif\n+\n #include \"m68k/m68k.h\"\n #undef SELECT_RTX_SECTION\n #include \"svr3.h\"\n \n-/* See m68k.h.  7 means 68020 with 68881. \n+/* See m68k.h.  7 means 68020 with 68881.\n  * We really have 68030 and 68882,\n  * but this will get us going.  \n  */\n@@ -41,34 +51,81 @@\n # define __HAVE_68881__ 1\n # define CPP_SPEC \"%{!msoft-float:-D__HAVE_68881__ }\"\n \n-#undef ASM_LONG\n-#define ASM_LONG \"\\t.long\"\n-\n #define HAVE_ATEXIT\n #undef DO_GLOBAL_CTORS_BODY\t\t/* don't use svr3.h version */\n #undef DO_GLOBAL_DTORS_BODY\n \n #ifndef USE_GAS\n /*\n- * handle the native assembler.\n- * this does NOT yet work, there is much left to do.\n- * use GAS for now...\n+ * handle the native MOTOROLA VERSAdos assembler.\n+ */\n+\n+/* See m68k.h.  3 means 68020 with 68881 and no bitfiled\n+ * bitfield instructions do not seem to work a clean way.\n  */\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT 3\n+\n+#undef EXTRA_SECTIONS\n+#undef EXTRA_SECTION_FUNCTIONS\n+#undef READONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION data_section\n+#undef SELECT_SECTION\n+#undef SELECT_RTX_SECTION\n+#define fini_section() while (0)\n+\n+#undef CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP \"\\tsection 15\"\n+#undef DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP \"\\tsection 15\"\n+#undef INIT_SECTION_ASM_OP\n+#define BSS_SECTION_ASM_OP     \"\\tsection 14\"\n+#undef TEXT_SECTION_ASM_OP\n+#define TEXT_SECTION_ASM_OP    \"\\tsection 10\"\n+#undef DATA_SECTION_ASM_OP\n+#define DATA_SECTION_ASM_OP  \"\\tsection 15\"\n+\n+\n+/* Don't try using XFmode.  */\n+#undef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+/* Define if you don't want extended real, but do want to use the\n+   software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion. */\n+#define REAL_ARITHMETIC \n+\n #undef ASM_OUTPUT_SOURCE_FILENAME\n #define ASM_OUTPUT_SOURCE_FILENAME(FILE, NA)\t\\\n   do { fprintf ((FILE), \"\\t.file\\t'%s'\\n\", (NA)); } while (0)\n \n+/* Assembler pseudos to introduce constants of various size.  */\n+\n+#undef ASM_BYTE_OP\n+#define ASM_BYTE_OP \"\\tdc.b\"\n+#undef ASM_LONG\n+#define ASM_LONG \"\\tdc.l\"\n+\n /* \n  * we don't seem to support any of:\n  * .globl\n  * .even\n  * .align\n  * .ascii\n  */\n-#undef ASM_GLOBALIZE_LABEL\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME) while (0)\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\tdcb.b %u,0\\n\", (SIZE))\n+\n+#undef GLOBAL_ASM_OP \n+#define GLOBAL_ASM_OP \"\\txdef\"\n+\n #undef ASM_OUTPUT_ALIGN\n-#define ASM_OUTPUT_ALIGN(asm_out_file, align) while (0)\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) >= 1)\t\t\t\\\n+    fprintf (FILE, \"\\tds.w 0\\n\");\n+\n+\n #define STRING_LIMIT\t(0)\n #undef ASM_APP_ON\n #define ASM_APP_ON \"\"\n@@ -80,43 +137,49 @@\n  * is how we have to output \"hello, world!\\n\"\n  */\n #undef ASM_OUTPUT_ASCII\n-#define ASM_OUTPUT_ASCII(asm_out_file, p, thissize)\t\\\n-  do { register int i, c, f=0;\t\t\t\\\n-  for (i = 0; i < thissize; i++) { \t\t\\\n-    c = p[i];\t\t\t\t\t\\\n-    if (c == '\\'' || c < ' ' || c > 127) {\t\\\n-      switch(f) {\t\t\t\t\\\n-      case 0: /* need to output dc.b etc */\t\\\n-\tfprintf(asm_out_file, \"\\tdc.b %d\", c);\t\\\n-\tf=1;\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\\\n-      case 1:\t\t\t\t\t\\\n-\tfprintf(asm_out_file, \",%d\", c);\t\\\n-\tbreak;\t\t\t\t\t\\\n-      default:\t\t\t\t\t\\\n-\t/* close a string */\t\t\t\\\n-\tfprintf(asm_out_file, \"'\\n\\tdc.b %d\", c); \\\n-\tf=1;\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\\\n-    } else {\t\t\t\t\t\\\n-      switch(f) {\t\t\t\t\\\n-      case 0:\t\t\t\t\t\\\n-\tfprintf(asm_out_file, \"\\tdc.b '%c\", c);\t\\\n-\tf=2;\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\\\n-      case 2:\t\t\t\t\t\\\n-\tfprintf(asm_out_file, \"%c\", c);\t\t\\\n-\tbreak;\t\t\t\t\t\\\n-      default:\t\t\t\t\t\\\n-\tfprintf(asm_out_file, \"\\n\\tdc.b '%c\", c); \\\n-\tf=2;\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\\\n-  if (f==2)\t\t\t\t\t\\\n-    putc('\\'', asm_out_file);\t\t\t\\\n+#define ASM_OUTPUT_ASCII(asm_out_file, p, thissize)\t\t\\\n+  do { register int i, c, f=0, len=0;\t\t\t\t\\\n+  for (i = 0; i < thissize; i++) { \t\t\t\t\\\n+    c = p[i];\t\t\t\t\t\t\t\\\n+    if (c == '\\'' || c < ' ' || c > 127) {\t\t\t\\\n+      switch(f) {\t\t\t\t\t\t\\\n+      case 0: /* need to output dc.b etc */\t\t\t\\\n+\tfprintf(asm_out_file, \"\\tdc.b %d\", c);\t\t\t\\\n+\tf=1;\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\\\n+      case 1:\t\t\t\t\t\t\t\\\n+\tfprintf(asm_out_file, \",%d\", c);\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\\\n+\t/* close a string */\t\t\t\t\t\\\n+\tfprintf(asm_out_file, \"'\\n\\tdc.b %d\", c);\t\t\\\n+\tf=1;\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    } else {\t\t\t\t\t\t\t\\\n+      switch(f) {\t\t\t\t\t\t\\\n+      case 0:\t\t\t\t\t\t\t\\\n+\tfprintf(asm_out_file, \"\\tdc.b '%c\", c);\t\t\t\\\n+\tf=2;\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\\\n+      case 2:\t\t\t\t\t\t\t\\\n+        if (len >= 79) {\t\t\t\t\t\\\n+          fprintf(asm_out_file, \"'\\n\\tdc.b '%c\", c); \t        \\\n+          len = 0; }\t\t\t\t\t\t\\\n+        else\t\t\t\t\t\t\t\\\n+\t  fprintf(asm_out_file, \"%c\", c);\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\\\n+\tlen = 0;\t\t\t\t\t\t\\\n+\tfprintf(asm_out_file, \"\\n\\tdc.b '%c\", c);\t\t\\\n+\tf=2;\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+    len++;                                   \t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+  if (f==2)\t\t\t\t\t\t\t\\\n+    putc('\\'', asm_out_file);\t\t\t\t\t\\\n   putc('\\n', asm_out_file); } while (0)\n \n /* This is how to output an insn to push a register on the stack.\n@@ -132,5 +195,610 @@\n #undef ASM_OUTPUT_REG_POP\n #define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n   fprintf (FILE, \"\\tmove.l (sp)+,%s\\n\", reg_names[REGNO])\n-\t\t\t\n+\n+\n+#define PUT_SDB_FUNCTION_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.def\\t.bf%s\\t.val\\t*%s\\t.scl\\t101%s\\t.line\\t%d%s\\t.endef\\n\", \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+\n+#define PUT_SDB_FUNCTION_END(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.def\\t.ef%s\\t.val\\t*%s\\t.scl\\t101%s\\t.line\\t%d%s\\t.endef\\n\", \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+\n+#define PUT_SDB_BLOCK_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.def\\t.bb%s\\t.val\\t*%s\\t.scl\\t100%s\\t.line\\t%d%s\\t.endef\\n\", \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+\n+#define PUT_SDB_BLOCK_END(LINE)\t\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.def\\t.eb%s\\t.val\\t*%s\\t.scl\\t100%s\\t.line\\t%d%s\\t.endef\\n\",  \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+\n+#define PUT_SDB_EPILOGUE_END(NAME)\t\n+\n+/* Output type in decimal not in octal as done in sdbout.c */\t\n+#define PUT_SDB_TYPE(a) fprintf(asm_out_file, \"\\t.type\\t0%d%s\", a, SDB_DELIM)\n+\t\t\n+#undef FUNCTION_PROLOGUE\n+#define FUNCTION_PROLOGUE(FILE, SIZE)                                 \\\n+{                                                                     \\\n+  register int regno;                                                 \\\n+  register int mask = 0;                                              \\\n+  int num_saved_regs = 0, first = 1;                                  \\\n+  extern char call_used_regs[];                                       \\\n+  int fsize = ((SIZE) + 3) & -4;                                      \\\n+                                                                      \\\n+                                                                      \\\n+  if (frame_pointer_needed)                                           \\\n+    {                                                                 \\\n+      /* Adding negative number is faster on the 68040.  */           \\\n+      if (fsize < 0x8000 && !TARGET_68040)                            \\\n+\t{                                                             \\\n+\t  fprintf (FILE, \"\\tlink %s,#%d\\n\", \t                      \\\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);      \\\n+\t}                                                             \\\n+      else if (TARGET_68020)                                          \\\n+\t{                                                             \\\n+\t  fprintf (FILE, \"\\tlink %s,#%d\\n\",\t                      \\\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);      \\\n+\t}                                                             \\\n+      else                                                            \\\n+\t{                                                             \\\n+\t  fprintf (FILE, \"\\tlink %s,#0\\n\\tadd.l #%d,sp\\n\",\t      \\\n+\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);      \\\n+\t}\t\t\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t      \\\n+  else if (fsize)\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t      \\\n+      /* Adding negative number is faster on the 68040.  */\t      \\\n+      if (fsize + 4 < 0x8000)\t\t\t\t\t      \\\n+\t{\t\t\t\t\t\t\t      \\\n+\t  fprintf (FILE, \"\\tadd.w #%d,sp\\n\", - (fsize + 4));\t      \\\n+\t}\t\t\t\t\t\t\t      \\\n+      else\t\t\t\t\t\t\t      \\\n+\t{\t\t\t\t\t\t\t      \\\n+\t  fprintf (FILE, \"\\tadd.l #%d,sp\\n\", - (fsize + 4));          \\\n+\t}\t\t\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t      \\\n+  for (regno = 23; regno >= 16; regno--)                              \\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])             \\\n+      if (first) {\t\t\t\t\t\t      \\\n+        fprintf (FILE, \"\\tfmovem.x %s\", reg_names[regno]);            \\\n+\tfirst = 0;\t\t\t\t\t\t      \\\n+       }\t\t\t\t\t\t\t      \\\n+      else fprintf (FILE, \"/%s\", reg_names[regno]);            \t      \\\n+  if (!first) fprintf (FILE, \",-(sp)\\n\");\t\t\t      \\\n+\t\t\t\t\t\t\t\t      \\\n+  mask = 0;\t\t\t\t\t\t\t      \\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t      \\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t      \\\n+      {\t\t\t\t\t\t\t\t      \\\n+        mask |= 1 << (15 - regno);\t\t\t\t      \\\n+        num_saved_regs++;                   \t\t\t      \\\n+      }                                                               \\\n+  if (frame_pointer_needed)                                           \\\n+    {                                                                 \\\n+      mask &= ~ (1 << (15 - FRAME_POINTER_REGNUM));                   \\\n+      num_saved_regs--;                                               \\\n+    }                                                                 \\\n+                                                                      \\\n+                                                                      \\\n+  if (num_saved_regs <= 2)                                            \\\n+    {                                                                 \\\n+      /* Store each separately in the same order moveml uses.         \\\n+         Using two movel instructions instead of a single moveml      \\\n+         is about 15% faster for the 68020 and 68030 at no expense    \\\n+         in code size */                                              \\\n+                                                                      \\\n+      int i;                                                          \\\n+                                                                      \\\n+      /* Undo the work from above. */                                 \\\n+      for (i = 0; i< 16; i++)                                         \\\n+        if (mask & (1 << i))                                          \\\n+          fprintf (FILE, \"\\tmove.l %s,-(sp)\\n\", reg_names[15 - i]);   \\\n+    }                                                                 \\\n+  else if (mask)                                                      \\\n+    {                                                                 \\\n+      first = 1;                                                      \\\n+      for (regno = 0; regno < 16; regno++)                            \\\n+        if (mask & (1 << regno))                                      \\\n+          if (first) {                                                \\\n+            fprintf (FILE, \"\\tmovem.l %s\", reg_names[15 - regno]);    \\\n+            first = 0;                                                \\\n+           }                                                          \\\n+          else fprintf (FILE, \"/%s\", reg_names[15 - regno]);\t      \\\n+      fprintf (FILE, \",-(sp)\\n\");\t           \t\t      \\\n+    }                                                                 \\\n+  if (flag_pic && current_function_uses_pic_offset_table)             \\\n+    {                                                                 \\\n+      fprintf (FILE, \"\\tmove.l #__GLOBAL_OFFSET_TABLE_, %s\\n\",        \\\n+\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);               \\\n+      fprintf (FILE, \"\\tlea.l (pc,%s.l),%s\\n\",                        \\\n+\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM],                \\\n+\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);               \\\n+    }                                                                 \\\n+}\n+\n+\n+#undef FUNCTION_EPILOGUE\n+#define FUNCTION_EPILOGUE(FILE, SIZE)                                 \\\n+{                                                                     \\\n+  register int regno;                                                 \\\n+  register int mask, fmask;                                           \\\n+  register int nregs;                                                 \\\n+  int offset, foffset, fpoffset, first = 1;\t\t              \\\n+  extern char call_used_regs[];                                       \\\n+  int fsize = ((SIZE) + 3) & -4;                                      \\\n+  int big = 0;                                                        \\\n+  rtx insn = get_last_insn ();                                        \\\n+                                                                      \\\n+  /* If the last insn was a BARRIER, we don't have to write any code.  */ \\\n+  if (GET_CODE (insn) == NOTE)                                        \\\n+    insn = prev_nonnote_insn (insn);                                  \\\n+  if (insn && GET_CODE (insn) == BARRIER)                             \\\n+    {                                                                 \\\n+      /* Output just a no-op so that debuggers don't get confused     \\\n+\t about which function the pc is in at this address.  */       \\\n+      fprintf (FILE, \"\\tnop\\n\");                                      \\\n+      return;                                                         \\\n+    }                                                                 \\\n+                                                                      \\\n+  nregs = 0;  fmask = 0; fpoffset = 0;                                \\\n+  for (regno = 16; regno < 24; regno++)                               \\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])             \\\n+      {                                                               \\\n+        nregs++;                                                      \\\n+\tfmask |= 1 << (23 - regno);                                   \\\n+      }                                                               \\\n+  foffset = fpoffset + nregs * 12;                                    \\\n+  nregs = 0;  mask = 0;                                               \\\n+  if (frame_pointer_needed)                                           \\\n+    regs_ever_live[FRAME_POINTER_REGNUM] = 0;                         \\\n+  for (regno = 0; regno < 16; regno++)                                \\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])             \\\n+      {                                                               \\\n+        nregs++;                                                      \\\n+\tmask |= 1 << regno;                                           \\\n+      }                                                               \\\n+  offset = foffset + nregs * 4;                                       \\\n+  if (offset + fsize >= 0x8000                                        \\\n+      && frame_pointer_needed                                         \\\n+      && (mask || fmask || fpoffset))                                 \\\n+    {                                                                 \\\n+      fprintf (FILE, \"\\tmove.l #%d,a0\\n\", -fsize);                    \\\n+      fsize = 0, big = 1;                                             \\\n+    }                                                                 \\\n+  if (nregs <= 2)                                                     \\\n+    {                                                                 \\\n+      /* Restore each separately in the same order moveml does.       \\\n+         Using two movel instructions instead of a single moveml      \\\n+         is about 15% faster for the 68020 and 68030 at no expense    \\\n+         in code size. */                                             \\\n+                                                                      \\\n+      int i;                                                          \\\n+                                                                      \\\n+      /* Undo the work from above. */                                 \\\n+      for (i = 0; i< 16; i++)                                         \\\n+        if (mask & (1 << i))                                          \\\n+          {                                                           \\\n+            if (big)                                                  \\\n+\t      {                                                       \\\n+\t\tfprintf (FILE, \"\\tmove.l -%d(%s,a0.l),%s\\n\",          \\\n+\t\t\t     offset + fsize,                          \\\n+\t\t\t     reg_names[FRAME_POINTER_REGNUM],         \\\n+\t\t\t     reg_names[i]);                           \\\n+\t      }                                                       \\\n+            else if (! frame_pointer_needed)                          \\\n+\t      {                                                       \\\n+\t\tfprintf (FILE, \"\\tmove.l (sp)+,%s\\n\",                 \\\n+\t\t\t     reg_names[i]);                           \\\n+\t      }                                                       \\\n+            else                                                      \\\n+\t      {                                                       \\\n+\t\tfprintf (FILE, \"\\tmove.l -%d(%s),%s\\n\",               \\\n+\t\t\t     offset + fsize,                          \\\n+\t\t\t     reg_names[FRAME_POINTER_REGNUM],         \\\n+\t\t\t     reg_names[i]);                           \\\n+\t      }                                                       \\\n+            offset = offset - 4;                                      \\\n+          }                                                           \\\n+    }                                                                 \\\n+  else if (mask)                                                      \\\n+    {                                                                 \\\n+      first = 1;\t\t\t\t\t\t      \\\n+      for (regno = 0; regno < 16; regno++)                            \\\n+        if (mask & (1 << regno))                                      \\\n+          if (first && big) {                                         \\\n+            fprintf (FILE, \"\\tmovem.l -%d(%s,a0.l),%s\",               \\\n+\t\t     offset + fsize,                                  \\\n+\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n+\t\t     reg_names[regno]);                               \\\n+            first = 0;                                                \\\n+           }                                                          \\\n+          else if (first && ! frame_pointer_needed) {                 \\\n+            fprintf (FILE, \"\\tmovem.l (sp)+,%s\",                      \\\n+\t\t     offset + fsize,                                  \\\n+\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n+\t\t     reg_names[regno]);                               \\\n+            first = 0;                                                \\\n+           }                                                          \\\n+          else if (first) {   \t\t\t\t              \\\n+            fprintf (FILE, \"\\tmovem.l -%d(%s),%s\",                    \\\n+\t\t     offset + fsize,                                  \\\n+\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n+\t\t     reg_names[regno]);                               \\\n+            first = 0;                                                \\\n+           }                                                          \\\n+          else  \t\t\t\t\t\t      \\\n+\t    fprintf (FILE, \"/%s\", reg_names[regno]);\t              \\\n+      fprintf (FILE, \"\\n\");\t                 \t\t      \\\n+    }                                                                 \\\n+  if (fmask)                                                          \\\n+    {                                                                 \\\n+      first = 1;\t\t\t\t\t\t      \\\n+      for (regno = 16; regno < 24; regno++)                           \\\n+        if (fmask & (1 << (23 - regno)))                               \\\n+          if (first && big) {\t                                      \\\n+            fprintf (FILE, \"\\tfmovem.x -%d(%s,a0.l),%s\",              \\\n+\t\t     foffset + fsize,                                 \\\n+\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n+\t\t     reg_names[regno]);                               \\\n+\t    first = 0;\t\t\t\t\t\t      \\\n+           }                                                          \\\n+          else if (first && ! frame_pointer_needed) {                 \\\n+            fprintf (FILE, \"\\tfmovem.x (sp)+,%s\",                     \\\n+\t\t     foffset + fsize,                                 \\\n+\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n+\t\t     reg_names[regno]);                               \\\n+\t    first = 0;\t\t\t\t\t\t      \\\n+           }                                                          \\\n+          else if (first) {    \t\t\t\t              \\\n+            fprintf (FILE, \"\\tfmovem.x -%d(%s),%s\",                   \\\n+\t\t     foffset + fsize,                                 \\\n+\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n+\t\t     reg_names[regno]);                               \\\n+\t    first = 0;\t\t\t\t\t\t      \\\n+           }                                                          \\\n+\t  else fprintf (FILE, \"/%s\", reg_names[regno]); \t      \\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\t      \\\n+    }                                                                 \\\n+  if (frame_pointer_needed)                                           \\\n+    fprintf (FILE, \"\\tunlk %s\\n\",                                     \\\n+\t     reg_names[FRAME_POINTER_REGNUM]);                        \\\n+  else if (fsize)                                                     \\\n+    {                                                                 \\\n+      if (fsize + 4 < 0x8000)                                         \\\n+\t{                                                             \\\n+\t  fprintf (FILE, \"\\tadd.w #%d,sp\\n\", fsize + 4);              \\\n+\t}                                                             \\\n+      else                                                            \\\n+\t{                                                             \\\n+\t  fprintf (FILE, \"\\tadd.l #%d,sp\\n\", fsize + 4);              \\\n+\t}                                                             \\\n+    }                                                                 \\\n+  if (current_function_pops_args)                                     \\\n+    fprintf (FILE, \"\\trtd #%d\\n\", current_function_pops_args);        \\\n+  else                                                                \\\n+    fprintf (FILE, \"\\trts\\n\");                                        \\\n+}\n+\n+/* Translate Motorola opcodes such as `jbeq'\n+   into VERSAdos opcodes such as `beq'.\n+   Change `fbeq' to `fbseq', `fbne' to `fbsneq'.\n+*/\n+\n+#undef ASM_OUTPUT_OPCODE\n+#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n+{ if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n+    { ++(PTR);\t\t\t\t\t\t\\\n+      while (*(PTR) != ' ')\t\t\t\t\\\n+\t{ putc (*(PTR), (FILE)); ++(PTR); }\t\t\\\n+    }\t\t\t                          \t\\\n+  else if ((PTR)[0] == 'f')                             \\\n+    {                                                   \\\n+      if (!strncmp ((PTR), \"fbeq\", 4))                  \\\n+        { fprintf ((FILE), \"fbseq\"); (PTR) += 4; }      \\\n+      else if (!strncmp ((PTR), \"fbne\", 4))             \\\n+        { fprintf ((FILE), \"fbsneq\"); (PTR) += 4; }     \\\n+    }                                                   \\\n+  else if ((PTR)[0] == 'b' && (PTR)[1] == 'f')          \\\n+    {                                                   \\\n+      char *s;                                          \\\n+      if ((s = (char*)strchr ((PTR), '{')))             \\\n+\twhile (*s != '}') {                             \\\n+\t  if (*s == 'b')                                \\\n+\t    /* hack, I replace it with R ie nothing */  \\\n+\t    *s = '0';                                   \\\n+\t  s++; }\t\t\t\t\t\\\n+    }                                                   \\\n+}\n+\n+/* This is how to output a `long double' extended real constant. */\n+#undef ASM_OUTPUT_LONG_DOUBLE \n+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  \t\t\t\t\\\n+do { long l[3];\t\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+       fprintf (FILE, \"\\tdc.l $%x,$%x,$%x\\n\", l[0], l[1], l[2]);\t\\\n+     else\t\t\t\t\t\t\t\t\\\n+       fprintf (FILE, \"\\tdc.l $%lx,$%lx,$%lx\\n\", l[0], l[1], l[2]);\t\\\n+   } while (0)\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#if 0\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  do { char dstr[30];\t\t\t\t\t\t\\\n+       REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\\\n+       fprintf (FILE, \"\\tdc.d %s\\n\", dstr);\t        \t\\\n+     } while (0)\n+#endif\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+do { long l[2];\t\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t        \\\n+     fprintf (FILE, \"\\tdc.l $%x,$%x\\n\", l[0], l[1]);            \t\\\n+   } while (0)\n+\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+do { long l;\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\\\n+       fprintf (FILE, \"\\tdc.l $%x\\n\", l);\t\t\\\n+     else\t\t\t\t\t\t\\\n+       fprintf (FILE, \"\\tdc.l $%lx\\n\", l);\t\t\\\n+   } while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+#undef ASM_OUTPUT_INT \n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tdc.l \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+#undef ASM_OUTPUT_SHORT\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tdc.w \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#undef ASM_OUTPUT_CHAR\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tdc.b \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#undef ASM_OUTPUT_BYTE\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\tdc.b $%x\\n\", (VALUE))\n+\n+/* This is how to output an element of a case-vector that is absolute.\n+   (The 68000 does not use such vectors,\n+   but we must define this macro anyway.)  */\n+#undef ASM_OUTPUT_ADDR_VEC_ELT\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  asm_fprintf (FILE, \"\\tdc.l %LL%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  asm_fprintf (FILE, \"\\tdc.w %LL%d-%LL%d\\n\", VALUE, REL)\n+\n+/* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to\n+   keep switch tables in the text section. */\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+/* Output a float value (represented as a C double) as an immediate operand.\n+   This macro is a 68k-specific macro.  */\n+#undef ASM_OUTPUT_FLOAT_OPERAND\n+#define ASM_OUTPUT_FLOAT_OPERAND(CODE,FILE,VALUE)\t\t\\\n+ do {\t\t\t\t\t\t\t\t\\\n+      if (CODE == 'f')\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+          char dstr[30];\t\t\t\t\t\\\n+          REAL_VALUE_TO_DECIMAL (VALUE, \"%.9g\", dstr);\t\t\\\n+          asm_fprintf ((FILE), \"%I%s\", dstr);\t\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+          long l;\t\t\t\t\t\t\\\n+          REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n+          if (sizeof (int) == sizeof (long))\t\t\t\\\n+            asm_fprintf ((FILE), \"%I$%x\", l);\t\t\t\\\n+          else\t\t\t\t\t\t\t\\\n+            asm_fprintf ((FILE), \"%I$%lx\", l);\t\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+     } while (0)\n+\n+/* Output a double value (represented as a C double) as an immediate operand.\n+   This macro is a 68k-specific macro.  */\n+#undef ASM_OUTPUT_DOUBLE_OPERAND \n+#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n+ do { char dstr[30];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n+      asm_fprintf (FILE, \"%I%s\", dstr);\t\t\t\t\t\\\n+    } while (0)\n+\n+/* Note, long double immediate operands are not actually\n+   generated by m68k.md.  */\n+#undef ASM_OUTPUT_LONG_DOUBLE_OPERAND\n+#define ASM_OUTPUT_LONG_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\\\n+ do { char dstr[30];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n+      asm_fprintf (FILE, \"%I%s\", dstr);\t\t\t\t\t\\\n+    } while (0)\n+\n+#undef ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\t.comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    int align = exact_log2 (ROUNDED);\t\t\t\\\n+    /*fprintf ((FILE), \"\\tsection 14\\n\");  */               \\\n+    data_section ();\t\t\t\t\t\\\n+    ASM_OUTPUT_ALIGN ((FILE), align)                    \\\n+    ASM_OUTPUT_LABEL ((FILE), (NAME));\t\t\t\\\n+    fprintf ((FILE), \"\\tdcb.b %u,0\\n\", (ROUNDED));\t\\\n+    /* fprintf ((FILE), \"\\tsection 10\\n\"); */             \\\n+  } while (0)\n+\n+#undef PRINT_OPERAND_ADDRESS\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n+  register rtx addr = ADDR;\t\t\t\t\t\t\\\n+  rtx offset;\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case REG:\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)\", reg_names[REGNO (addr)]);\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PRE_DEC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case POST_INC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PLUS:\t\t\t\t\t\t\t\t\\\n+      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n+      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n+\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n+\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n+/*  for OLD_INDEXING\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (addr) == PLUS)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      reg2 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t      addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      reg2 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t      addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+  */\t\t\t\t\t\t\t\t\t\\\n+      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n+      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n+\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n+\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n+\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n+      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n+\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n+      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n+        { int scale = 1;\t\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n+\t    fprintf (FILE, \"(.L%d,pc,%s.w\",\t\t\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"(.L%d,pc,%s.l\",\t\t\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+\tif (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF      \\\n+\t    && ! (flag_pic && breg == pic_offset_table_rtx))            \\\n+\t  {                                                             \\\n+\t    fprintf (FILE, \"(.L%d,pc,%s.l\", \t                        \\\n+\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),            \\\n+\t\t\t reg_names[REGNO (breg)]);                      \\\n+\t    putc (')', FILE);                                           \\\n+\t    break; }                                                    \\\n+      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n+\t{ int scale = 1;\t\t\t\t\t\t\\\n+\t  if (breg == 0)\t\t\t\t\t\t\\\n+\t    abort ();\t\t\t\t\t\t\t\\\n+          putc ('(', FILE); \t     \t\t\t\t        \\\n+\t  if (addr != 0)\t\t\t\t\t\t\\\n+\t    {                                                           \\\n+\t      output_addr_const (FILE, addr);\t\t\t\t\\\n+\t      putc (',', FILE); \t\t\t\t\t\\\n+\t    }    \t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"%s\", reg_names[REGNO (breg)]);\t\t\\\n+\t  if (ireg != 0)\t\t\t\t\t\t\\\n+\t    putc (',', FILE);\t\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n+\t    fprintf (FILE, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n+\t  else if (ireg != 0)\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"%s.l\", reg_names[REGNO (ireg)]);\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n+\t{ fprintf (FILE, \"(.L%d,pc,%s.w)\",\t\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n+\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == CONST_INT\t\t\t\t\t\\\n+\t  && INTVAL (addr) < 0x8000\t\t\t\t\t\\\n+\t  && INTVAL (addr) >= -0x8000)\t\t\t\t\t\\\n+\tfprintf (FILE, \"%d.w\", INTVAL (addr));\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        output_addr_const (FILE, addr);\t\t\t\t\t\\\n+    }}\n+\n+\n #endif /* ! use gas */\t\t\t"}]}