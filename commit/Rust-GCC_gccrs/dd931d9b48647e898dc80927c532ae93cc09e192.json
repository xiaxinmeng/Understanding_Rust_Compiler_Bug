{"sha": "dd931d9b48647e898dc80927c532ae93cc09e192", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ5MzFkOWI0ODY0N2U4OThkYzgwOTI3YzUzMmFlOTNjYzA5ZTE5Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2018-09-24T21:46:21Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-24T21:46:21Z"}, "message": "libgo: update to Go 1.11\n    \n    Reviewed-on: https://go-review.googlesource.com/136435\n\ngotools/:\n\t* Makefile.am (mostlyclean-local): Run chmod on check-go-dir to\n\tmake sure it is writable.\n\t(check-go-tools): Likewise.\n\t(check-vet): Copy internal/objabi to check-vet-dir.\n\t* Makefile.in: Rebuild.\n\nFrom-SVN: r264546", "tree": {"sha": "71be2295cd79b8a182f6130611658db8628772d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71be2295cd79b8a182f6130611658db8628772d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd931d9b48647e898dc80927c532ae93cc09e192", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd931d9b48647e898dc80927c532ae93cc09e192", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd931d9b48647e898dc80927c532ae93cc09e192", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd931d9b48647e898dc80927c532ae93cc09e192/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4"}], "stats": {"total": 102842, "additions": 83888, "deletions": 18954}, "files": [{"sha": "175db5d42026180aba25a11afaa06790a1d986cd", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -1,4 +1,4 @@\n-92a14213215fd93df7240fa9d376a1213b1d5a74\n+7b25b4dff4778fc4d6b5d6e10594814146b3e5dd\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "7305c6063ccdc8193e9f7a9d525c445f1369019e", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug273.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug273.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug273.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug273.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -8,13 +8,15 @@\n \n package main\n \n+import \"unsafe\"\n+\n var bug = false\n \n var minus1 = -1\n var five = 5\n-var big int64 = 10 | 1<<32\n+var big int64 = 10 | 1<<40\n \n-type block [1<<19]byte\n+type block [1 << 19]byte\n \n var g1 []block\n \n@@ -48,9 +50,10 @@ func bigcap() {\n \tg1 = make([]block, 10, big)\n }\n \n-type cblock [1<<16-1]byte\n+type cblock [1<<16 - 1]byte\n \n var g4 chan cblock\n+\n func badchancap() {\n \tg4 = make(chan cblock, minus1)\n }\n@@ -60,7 +63,8 @@ func bigchancap() {\n }\n \n func overflowchan() {\n-\tg4 = make(chan cblock, 1<<30)\n+\tconst ptrSize = unsafe.Sizeof(uintptr(0))\n+\tg4 = make(chan cblock, 1<<(30*(ptrSize/4)))\n }\n \n func main() {"}, {"sha": "6bf315fcc2f0603835911f4739969d751ec92655", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue4085b.go", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4085b.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4085b.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4085b.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -1,6 +1,6 @@\n // run\n \n-// Copyright 2013 The Go Authors.  All rights reserved.\n+// Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -15,22 +15,31 @@ type T []int\n \n func main() {\n \tn := -1\n-\tshouldPanic(\"len out of range\", func() {_ = make(T, n)})\n-\tshouldPanic(\"cap out of range\", func() {_ = make(T, 0, n)})\n+\tshouldPanic(\"len out of range\", func() { _ = make(T, n) })\n+\tshouldPanic(\"cap out of range\", func() { _ = make(T, 0, n) })\n+\tshouldPanic(\"len out of range\", func() { _ = make(T, int64(n)) })\n+\tshouldPanic(\"cap out of range\", func() { _ = make(T, 0, int64(n)) })\n \tvar t *byte\n \tif unsafe.Sizeof(t) == 8 {\n-\t\tn = 1<<20\n-\t\tn <<= 20\n-\t\tshouldPanic(\"len out of range\", func() {_ = make(T, n)})\n-\t\tshouldPanic(\"cap out of range\", func() {_ = make(T, 0, n)})\n-\t\tn <<= 20\n-\t\tshouldPanic(\"len out of range\", func() {_ = make(T, n)})\n-\t\tshouldPanic(\"cap out of range\", func() {_ = make(T, 0, n)})\n+\t\tvar n2 int64 = 1 << 50\n+\t\tshouldPanic(\"len out of range\", func() { _ = make(T, int(n2)) })\n+\t\tshouldPanic(\"cap out of range\", func() { _ = make(T, 0, int(n2)) })\n+\t\tn2 = 1<<63 - 1\n+\t\tshouldPanic(\"len out of range\", func() { _ = make(T, int(n2)) })\n+\t\tshouldPanic(\"cap out of range\", func() { _ = make(T, 0, int(n2)) })\n \t} else {\n \t\tn = 1<<31 - 1\n-\t\tshouldPanic(\"len out of range\", func() {_ = make(T, n)})\n-\t\tshouldPanic(\"cap out of range\", func() {_ = make(T, 0, n)})\n+\t\tshouldPanic(\"len out of range\", func() { _ = make(T, n) })\n+\t\tshouldPanic(\"cap out of range\", func() { _ = make(T, 0, n) })\n+\t\tshouldPanic(\"len out of range\", func() { _ = make(T, int64(n)) })\n+\t\tshouldPanic(\"cap out of range\", func() { _ = make(T, 0, int64(n)) })\n \t}\n+\n+\t// Test make in append panics since the gc compiler optimizes makes in appends.\n+\tshouldPanic(\"len out of range\", func() { _ = append(T{}, make(T, n)...) })\n+\tshouldPanic(\"cap out of range\", func() { _ = append(T{}, make(T, 0, n)...) })\n+\tshouldPanic(\"len out of range\", func() { _ = append(T{}, make(T, int64(n))...) })\n+\tshouldPanic(\"cap out of range\", func() { _ = append(T{}, make(T, 0, int64(n))...) })\n }\n \n func shouldPanic(str string, f func()) {\n@@ -44,6 +53,6 @@ func shouldPanic(str string, f func()) {\n \t\t\tpanic(\"got panic \" + s + \", want \" + str)\n \t\t}\n \t}()\n-\t\n+\n \tf()\n }"}, {"sha": "afcd7a211c107ba39854931ec65578362e79ec03", "filename": "gotools/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/gotools%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/gotools%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FChangeLog?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -1,3 +1,11 @@\n+2018-09-24  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* Makefile.am (mostlyclean-local): Run chmod on check-go-dir to\n+\tmake sure it is writable.\n+\t(check-go-tools): Likewise.\n+\t(check-vet): Copy internal/objabi to check-vet-dir.\n+\t* Makefile.in: Rebuild.\n+\n 2018-05-09  Ian Lance Taylor  <iant@golang.org>\n \n \t* Makefile.am (check-go-tool): Don't copy zstdpkglist.go."}, {"sha": "cb4ffe7a66f4863393ce5a60caae419d26517ada", "filename": "gotools/Makefile.am", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/gotools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/gotools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.am?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -123,6 +123,7 @@ MOSTLYCLEANFILES = \\\n \t*.sent\n \n mostlyclean-local:\n+\tchmod -R u+w check-go-dir\n \trm -rf check-go-dir check-runtime-dir cgo-test-dir carchive-test-dir\n \n if NATIVE\n@@ -228,6 +229,7 @@ ECHO_ENV = PATH=`echo $(abs_builddir):$${PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,\n \n # check-go-tool runs `go test cmd/go` in our environment.\n check-go-tool: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n+\tchmod -R u+w check-go-dir\n \trm -rf check-go-dir cmd_go-testlog\n \t$(MKDIR_P) check-go-dir/src/cmd/go\n \tcp $(cmdsrcdir)/go/*.go check-go-dir/src/cmd/go/\n@@ -297,8 +299,10 @@ check-carchive-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check\n # check-vet runs `go test cmd/vet` in our environment.\n check-vet: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \trm -rf check-vet-dir cmd_vet-testlog\n-\t$(MKDIR_P) check-vet-dir/src/cmd\n+\t$(MKDIR_P) check-vet-dir/src/cmd/internal\n \tcp -r $(cmdsrcdir)/vet check-vet-dir/src/cmd/\n+\tcp -r $(cmdsrcdir)/internal/objabi check-vet-dir/src/cmd/internal\n+\tcp $(libgodir)/objabi.go check-vet-dir/src/cmd/internal/objabi/\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n \tabs_checkdir=`cd check-vet-dir && $(PWD_COMMAND)`; \\\n \techo \"cd check-vet-dir/src/cmd/vet && $(ECHO_ENV) GOPATH=$${abs_checkdir} $(abs_builddir)/go$(EXEEXT) test -test.short -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v\" > cmd_vet-testlog"}, {"sha": "acadfc64016d5db42f03ebefd72c263ba51a2e85", "filename": "gotools/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/gotools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/gotools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.in?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -637,8 +637,8 @@ distclean-generic:\n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\"\n \t@echo \"it deletes files that may require special tools to rebuild.\"\n-@NATIVE_FALSE@uninstall-local:\n @NATIVE_FALSE@install-exec-local:\n+@NATIVE_FALSE@uninstall-local:\n clean: clean-am\n \n clean-am: clean-binPROGRAMS clean-generic clean-noinstPROGRAMS \\\n@@ -744,6 +744,7 @@ s-zdefaultcc: Makefile\n \t$(STAMP) $@ \n \n mostlyclean-local:\n+\tchmod -R u+w check-go-dir\n \trm -rf check-go-dir check-runtime-dir cgo-test-dir carchive-test-dir\n \n @NATIVE_TRUE@go$(EXEEXT): $(go_cmd_go_files) $(LIBGOTOOL) $(LIBGODEP)\n@@ -807,6 +808,7 @@ mostlyclean-local:\n \n # check-go-tool runs `go test cmd/go` in our environment.\n @NATIVE_TRUE@check-go-tool: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n+@NATIVE_TRUE@\tchmod -R u+w check-go-dir\n @NATIVE_TRUE@\trm -rf check-go-dir cmd_go-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) check-go-dir/src/cmd/go\n @NATIVE_TRUE@\tcp $(cmdsrcdir)/go/*.go check-go-dir/src/cmd/go/\n@@ -876,8 +878,10 @@ mostlyclean-local:\n # check-vet runs `go test cmd/vet` in our environment.\n @NATIVE_TRUE@check-vet: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n @NATIVE_TRUE@\trm -rf check-vet-dir cmd_vet-testlog\n-@NATIVE_TRUE@\t$(MKDIR_P) check-vet-dir/src/cmd\n+@NATIVE_TRUE@\t$(MKDIR_P) check-vet-dir/src/cmd/internal\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/vet check-vet-dir/src/cmd/\n+@NATIVE_TRUE@\tcp -r $(cmdsrcdir)/internal/objabi check-vet-dir/src/cmd/internal\n+@NATIVE_TRUE@\tcp $(libgodir)/objabi.go check-vet-dir/src/cmd/internal/objabi/\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\tabs_checkdir=`cd check-vet-dir && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\techo \"cd check-vet-dir/src/cmd/vet && $(ECHO_ENV) GOPATH=$${abs_checkdir} $(abs_builddir)/go$(EXEEXT) test -test.short -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v\" > cmd_vet-testlog"}, {"sha": "9b907987defff5b23c1d8f9665014a62cd7147a0", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -1,4 +1,4 @@\n-fe8a0d12b14108cbe2408b417afcaab722b0727c\n+41e62b8c49d21659b48a95216e3062032285250f\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "373dd0cf73cff1b959ef75af694bd21d8f74954c", "filename": "libgo/Makefile.am", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -541,6 +541,7 @@ s-objabi: Makefile\n \techo 'const defaultGO386 = `sse2`' >> objabi.go.tmp\n \techo 'const defaultGOARM = `5`' >> objabi.go.tmp\n \techo 'const defaultGOMIPS = `hardfloat`' >> objabi.go.tmp\n+\techo 'const defaultGOMIPS64 = `hardfloat`' >> objabi.go.tmp\n \techo 'const defaultGOOS = runtime.GOOS' >> objabi.go.tmp\n \techo 'const defaultGOARCH = runtime.GOARCH' >> objabi.go.tmp\n \techo 'const defaultGO_EXTLINK_ENABLED = ``' >> objabi.go.tmp\n@@ -608,7 +609,7 @@ noinst_DATA += zdefaultcc.go\n zstdpkglist.go: s-zstdpkglist; @true\n s-zstdpkglist: Makefile\n \trm -f zstdpkglist.go.tmp\n-\techo 'package build' > zstdpkglist.go.tmp\n+\techo 'package goroot' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp\n \techo 'var stdpkg = map[string]bool{' >> zstdpkglist.go.tmp\n \techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_/]*_c\\.lo||g' | sed 's|\\([a-z0-9_/]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n@@ -707,6 +708,7 @@ PACKAGES = $(shell cat $(srcdir)/libgo-packages.txt)\n libgo_go_objs = \\\n \t$(addsuffix .lo,$(PACKAGES)) \\\n \tbytes/index.lo \\\n+\tinternal/bytealg/bytealg.lo \\\n \treflect/makefunc_ffi_c.lo \\\n \tstrings/index.lo \\\n \t$(syscall_lib_clone_lo) \\\n@@ -718,7 +720,8 @@ libgo_go_objs = \\\n \tlog/syslog/syslog_c.lo \\\n \t$(os_lib_inotify_lo) \\\n \truntime/internal/atomic_c.lo \\\n-\tsync/atomic_c.lo\n+\tsync/atomic_c.lo \\\n+\tinternal/cpu/cpu_gccgo.lo\n \n libgo_ldflags = \\\n \t-version-info $(libtool_VERSION) $(PTHREAD_CFLAGS) $(AM_LDFLAGS)\n@@ -960,8 +963,8 @@ runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n extra_go_files_runtime_internal_sys = version.go\n runtime/internal/sys.lo.dep: $(extra_go_files_runtime_internal_sys)\n \n-extra_go_files_go_build = zstdpkglist.go\n-go/build.lo.dep: $(extra_go_files_go_build)\n+extra_go_files_internal_goroot = zstdpkglist.go\n+internal/goroot.lo.dep: $(extra_go_files_internal_goroot)\n \n extra_go_files_go_types = gccgosizes.go\n go/types.lo.dep: $(extra_go_files_go_types)\n@@ -976,6 +979,16 @@ extra_check_libs_cmd_go_internal_cache = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_load = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_imports = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_modconv = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_modfetch = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_modfetch_codehost = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_modfile = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_modload = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_module = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_mvs = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_search = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_web2 = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_work = $(abs_builddir)/libgotool.a\n \n extra_check_libs_cmd_vet_internal_cfg = $(abs_builddir)/libgotool.a\n@@ -990,6 +1003,9 @@ bytes/index.lo: go/bytes/indexbyte.c runtime.inc\n strings/index.lo: go/strings/indexbyte.c runtime.inc\n \t@$(MKDIR_P) strings\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/strings/indexbyte.c\n+internal/bytealg/bytealg.lo: go/internal/bytealg/bytealg.c runtime.inc\n+\t@$(MKDIR_P) internal/bytealg\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/internal/bytealg/bytealg.c\n \n # Use a C function with a fixed number of arguments to call a C\n # varargs function.\n@@ -1024,6 +1040,11 @@ syscall/wait.lo: go/syscall/wait.c runtime.inc\n \t@$(MKDIR_P) syscall\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/syscall/wait.c\n \n+# internal/cpu needs some C code.\n+internal/cpu/cpu_gccgo.lo: go/internal/cpu/cpu_gccgo.c runtime.inc\n+\t@$(MKDIR_P) internal/cpu\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/internal/cpu/cpu_gccgo.c\n+\n # Solaris 11.4 changed the type of fields in struct stat.\n # Use a build tag, based on a configure check, to cope.\n if LIBGO_IS_SOLARIS"}, {"sha": "dfc2c66199b17bebf84f56843bab312b12617100", "filename": "libgo/Makefile.in", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -174,11 +174,12 @@ libgotool_a_OBJECTS = $(am_libgotool_a_OBJECTS)\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n @LIBGO_IS_LINUX_TRUE@am__DEPENDENCIES_1 = syscall/clone_linux.lo\n am__DEPENDENCIES_2 = $(addsuffix .lo,$(PACKAGES)) bytes/index.lo \\\n-\treflect/makefunc_ffi_c.lo strings/index.lo \\\n-\t$(am__DEPENDENCIES_1) syscall/errno.lo syscall/signame.lo \\\n-\tsyscall/wait.lo $(golang_org_x_net_lif_lo) \\\n+\tinternal/bytealg/bytealg.lo reflect/makefunc_ffi_c.lo \\\n+\tstrings/index.lo $(am__DEPENDENCIES_1) syscall/errno.lo \\\n+\tsyscall/signame.lo syscall/wait.lo $(golang_org_x_net_lif_lo) \\\n \t$(golang_org_x_net_route_lo) log/syslog/syslog_c.lo \\\n-\truntime/internal/atomic_c.lo sync/atomic_c.lo\n+\truntime/internal/atomic_c.lo sync/atomic_c.lo \\\n+\tinternal/cpu/cpu_gccgo.lo\n am__DEPENDENCIES_3 =\n am__DEPENDENCIES_4 = $(am__DEPENDENCIES_2) \\\n \t../libbacktrace/libbacktrace.la $(am__DEPENDENCIES_3) \\\n@@ -824,6 +825,7 @@ PACKAGES = $(shell cat $(srcdir)/libgo-packages.txt)\n libgo_go_objs = \\\n \t$(addsuffix .lo,$(PACKAGES)) \\\n \tbytes/index.lo \\\n+\tinternal/bytealg/bytealg.lo \\\n \treflect/makefunc_ffi_c.lo \\\n \tstrings/index.lo \\\n \t$(syscall_lib_clone_lo) \\\n@@ -835,7 +837,8 @@ libgo_go_objs = \\\n \tlog/syslog/syslog_c.lo \\\n \t$(os_lib_inotify_lo) \\\n \truntime/internal/atomic_c.lo \\\n-\tsync/atomic_c.lo\n+\tsync/atomic_c.lo \\\n+\tinternal/cpu/cpu_gccgo.lo\n \n libgo_ldflags = \\\n \t-version-info $(libtool_VERSION) $(PTHREAD_CFLAGS) $(AM_LDFLAGS)\n@@ -999,14 +1002,24 @@ runtime_internal_sys_lo_check_GOCFLAGS = -fgo-compiling-runtime\n # Also use -fno-inline to get better results from the memory profiler.\n runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n extra_go_files_runtime_internal_sys = version.go\n-extra_go_files_go_build = zstdpkglist.go\n+extra_go_files_internal_goroot = zstdpkglist.go\n extra_go_files_go_types = gccgosizes.go\n extra_go_files_cmd_internal_objabi = objabi.go\n extra_go_files_cmd_go_internal_cfg = zdefaultcc.go\n extra_check_libs_cmd_go_internal_cache = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_load = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_imports = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_modconv = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_modfetch = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_modfetch_codehost = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_modfile = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_modload = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_module = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_mvs = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_search = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_web2 = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_work = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_vet_internal_cfg = $(abs_builddir)/libgotool.a\n @HAVE_STAT_TIMESPEC_FALSE@@LIBGO_IS_SOLARIS_TRUE@matchargs_os = \n@@ -2755,6 +2768,7 @@ s-objabi: Makefile\n \techo 'const defaultGO386 = `sse2`' >> objabi.go.tmp\n \techo 'const defaultGOARM = `5`' >> objabi.go.tmp\n \techo 'const defaultGOMIPS = `hardfloat`' >> objabi.go.tmp\n+\techo 'const defaultGOMIPS64 = `hardfloat`' >> objabi.go.tmp\n \techo 'const defaultGOOS = runtime.GOOS' >> objabi.go.tmp\n \techo 'const defaultGOARCH = runtime.GOARCH' >> objabi.go.tmp\n \techo 'const defaultGO_EXTLINK_ENABLED = ``' >> objabi.go.tmp\n@@ -2816,7 +2830,7 @@ s-runtime-inc: runtime.lo Makefile\n zstdpkglist.go: s-zstdpkglist; @true\n s-zstdpkglist: Makefile\n \trm -f zstdpkglist.go.tmp\n-\techo 'package build' > zstdpkglist.go.tmp\n+\techo 'package goroot' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp\n \techo 'var stdpkg = map[string]bool{' >> zstdpkglist.go.tmp\n \techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_/]*_c\\.lo||g' | sed 's|\\([a-z0-9_/]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n@@ -2943,7 +2957,7 @@ $(foreach package,$(GOTOOL_PACKAGES),$(eval $(call PACKAGE_template,$(package)))\n runtime.lo.dep: $(extra_go_files_runtime)\n syscall.lo.dep: $(extra_go_files_syscall)\n runtime/internal/sys.lo.dep: $(extra_go_files_runtime_internal_sys)\n-go/build.lo.dep: $(extra_go_files_go_build)\n+internal/goroot.lo.dep: $(extra_go_files_internal_goroot)\n go/types.lo.dep: $(extra_go_files_go_types)\n cmd/internal/objabi.lo.dep: $(extra_go_files_cmd_internal_objabi)\n cmd/go/internal/cfg.lo.dep: $(extra_go_files_cmd_go_internal_cfg)\n@@ -2958,6 +2972,9 @@ bytes/index.lo: go/bytes/indexbyte.c runtime.inc\n strings/index.lo: go/strings/indexbyte.c runtime.inc\n \t@$(MKDIR_P) strings\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/strings/indexbyte.c\n+internal/bytealg/bytealg.lo: go/internal/bytealg/bytealg.c runtime.inc\n+\t@$(MKDIR_P) internal/bytealg\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/internal/bytealg/bytealg.c\n \n # Use a C function with a fixed number of arguments to call a C\n # varargs function.\n@@ -2992,6 +3009,11 @@ syscall/wait.lo: go/syscall/wait.c runtime.inc\n \t@$(MKDIR_P) syscall\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/syscall/wait.c\n \n+# internal/cpu needs some C code.\n+internal/cpu/cpu_gccgo.lo: go/internal/cpu/cpu_gccgo.c runtime.inc\n+\t@$(MKDIR_P) internal/cpu\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/internal/cpu/cpu_gccgo.c\n+\n # Build golang_org/x/net/route only on BSD systems.\n \n @LIBGO_IS_BSD_TRUE@$(eval $(call PACKAGE_template,golang_org/x/net/route))"}, {"sha": "f3220fb759237999ad9cac471b6564311ae68a79", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -1 +1 @@\n-go1.10.3\n+go1.11"}, {"sha": "6c307d3008538a2bde29e2066db571db557067a2", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -3,9 +3,23 @@ archive/zip\n bufio\n bytes\n cmd/go/internal/cache\n+cmd/go/internal/dirhash\n cmd/go/internal/generate\n cmd/go/internal/get\n+cmd/go/internal/imports\n cmd/go/internal/load\n+cmd/go/internal/modconv\n+cmd/go/internal/modfetch\n+cmd/go/internal/modfetch/codehost\n+cmd/go/internal/modfile\n+cmd/go/internal/modload\n+cmd/go/internal/module\n+cmd/go/internal/mvs\n+cmd/go/internal/par\n+cmd/go/internal/search\n+cmd/go/internal/semver\n+cmd/go/internal/txtar\n+cmd/go/internal/web2\n cmd/go/internal/work\n cmd/internal/buildid\n cmd/internal/edit\n@@ -29,6 +43,7 @@ crypto/dsa\n crypto/ecdsa\n crypto/elliptic\n crypto/hmac\n+crypto/internal/subtle\n crypto/md5\n crypto/rand\n crypto/rc4\n@@ -76,11 +91,15 @@ go/printer\n go/scanner\n go/token\n go/types\n+golang_org/x/crypto/internal/chacha20\n golang_org/x/crypto/chacha20poly1305\n golang_org/x/crypto/chacha20poly1305/internal/chacha20\n golang_org/x/crypto/cryptobyte\n golang_org/x/crypto/curve25519\n golang_org/x/crypto/poly1305\n+golang_org/x/net/dns/dnsmessage\n+golang_org/x/net/http/httpguts\n+golang_org/x/net/http/httpproxy\n golang_org/x/net/http2/hpack\n golang_org/x/net/idna\n golang_org/x/net/lex/httplex\n@@ -98,6 +117,7 @@ image/draw\n image/jpeg\n image/png\n index/suffixarray\n+internal/cpu\n internal/poll\n internal/singleflight\n internal/trace"}, {"sha": "dee9e47e4ae486f8c3c29408cee63002916f849b", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -56,7 +56,7 @@ func (he headerError) Error() string {\n const (\n \t// Type '0' indicates a regular file.\n \tTypeReg  = '0'\n-\tTypeRegA = '\\x00' // For legacy support; use TypeReg instead\n+\tTypeRegA = '\\x00' // Deprecated: Use TypeReg instead.\n \n \t// Type '1' to '6' are header-only flags and may not have a data body.\n \tTypeLink    = '1' // Hard link\n@@ -138,7 +138,10 @@ var basicKeys = map[string]bool{\n // should do so by creating a new Header and copying the fields\n // that they are interested in preserving.\n type Header struct {\n-\tTypeflag byte // Type of header entry (should be TypeReg for most files)\n+\t// Typeflag is the type of header entry.\n+\t// The zero value is automatically promoted to either TypeReg or TypeDir\n+\t// depending on the presence of a trailing slash in Name.\n+\tTypeflag byte\n \n \tName     string // Name of file entry\n \tLinkname string // Target name of link (valid for TypeLink or TypeSymlink)\n@@ -184,7 +187,7 @@ type Header struct {\n \t// The key and value should be non-empty UTF-8 strings.\n \t//\n \t// When Writer.WriteHeader is called, PAX records derived from the\n-\t// the other fields in Header take precedence over PAXRecords.\n+\t// other fields in Header take precedence over PAXRecords.\n \tPAXRecords map[string]string\n \n \t// Format specifies the format of the tar header."}, {"sha": "1f89d0c59a1599b76049161cb2033d61f62cd6d3", "filename": "libgo/go/archive/tar/format.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -94,7 +94,7 @@ const (\n \t// application can only parse GNU formatted archives.\n \t//\n \t// Reference:\n-\t//\thttp://www.gnu.org/software/tar/manual/html_node/Standard.html\n+\t//\thttps://www.gnu.org/software/tar/manual/html_node/Standard.html\n \tFormatGNU\n \n \t// Schily's tar format, which is incompatible with USTAR."}, {"sha": "39437185179a66ce605a292b0c7197ae78575bac", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -64,7 +64,6 @@ func (tr *Reader) next() (*Header, error) {\n \t// normally be visible to the outside. As such, this loop iterates through\n \t// one or more \"header files\" until it finds a \"normal file\".\n \tformat := FormatUSTAR | FormatPAX | FormatGNU\n-loop:\n \tfor {\n \t\t// Discard the remainder of the file and any padding.\n \t\tif err := discard(tr.r, tr.curr.PhysicalRemaining()); err != nil {\n@@ -102,7 +101,7 @@ loop:\n \t\t\t\t\tFormat:     format,\n \t\t\t\t}, nil\n \t\t\t}\n-\t\t\tcontinue loop // This is a meta header affecting the next header\n+\t\t\tcontinue // This is a meta header affecting the next header\n \t\tcase TypeGNULongName, TypeGNULongLink:\n \t\t\tformat.mayOnlyBe(FormatGNU)\n \t\t\trealname, err := ioutil.ReadAll(tr)\n@@ -117,7 +116,7 @@ loop:\n \t\t\tcase TypeGNULongLink:\n \t\t\t\tgnuLongLink = p.parseString(realname)\n \t\t\t}\n-\t\t\tcontinue loop // This is a meta header affecting the next header\n+\t\t\tcontinue // This is a meta header affecting the next header\n \t\tdefault:\n \t\t\t// The old GNU sparse format is handled here since it is technically\n \t\t\t// just a regular file with additional attributes.\n@@ -131,8 +130,12 @@ loop:\n \t\t\tif gnuLongLink != \"\" {\n \t\t\t\thdr.Linkname = gnuLongLink\n \t\t\t}\n-\t\t\tif hdr.Typeflag == TypeRegA && strings.HasSuffix(hdr.Name, \"/\") {\n-\t\t\t\thdr.Typeflag = TypeDir // Legacy archives use trailing slash for directories\n+\t\t\tif hdr.Typeflag == TypeRegA {\n+\t\t\t\tif strings.HasSuffix(hdr.Name, \"/\") {\n+\t\t\t\t\thdr.Typeflag = TypeDir // Legacy archives use trailing slash for directories\n+\t\t\t\t} else {\n+\t\t\t\t\thdr.Typeflag = TypeReg\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\t// The extended headers may have updated the size.\n@@ -200,7 +203,7 @@ func (tr *Reader) handleSparseFile(hdr *Header, rawHdr *block) error {\n // readGNUSparsePAXHeaders checks the PAX headers for GNU sparse headers.\n // If they are found, then this function reads the sparse map and returns it.\n // This assumes that 0.0 headers have already been converted to 0.1 headers\n-// by the the PAX header parsing logic.\n+// by the PAX header parsing logic.\n func (tr *Reader) readGNUSparsePAXHeaders(hdr *Header) (sparseDatas, error) {\n \t// Identify the version of GNU headers.\n \tvar is1x0 bool"}, {"sha": "f153b668deff8687376a20da0da756c884956757", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -189,15 +189,15 @@ func TestReader(t *testing.T) {\n \t\t\tGid:      5000,\n \t\t\tSize:     5,\n \t\t\tModTime:  time.Unix(1244593104, 0),\n-\t\t\tTypeflag: '\\x00',\n+\t\t\tTypeflag: '0',\n \t\t}, {\n \t\t\tName:     \"small2.txt\",\n \t\t\tMode:     0444,\n \t\t\tUid:      73025,\n \t\t\tGid:      5000,\n \t\t\tSize:     11,\n \t\t\tModTime:  time.Unix(1244593104, 0),\n-\t\t\tTypeflag: '\\x00',\n+\t\t\tTypeflag: '0',\n \t\t}},\n \t}, {\n \t\tfile: \"testdata/pax.tar\",\n@@ -378,9 +378,9 @@ func TestReader(t *testing.T) {\n \t\t\t\t\"security.selinux\": \"unconfined_u:object_r:default_t:s0\\x00\",\n \t\t\t},\n \t\t\tPAXRecords: map[string]string{\n-\t\t\t\t\"mtime\": \"1386065770.449252304\",\n-\t\t\t\t\"atime\": \"1389782991.41987522\",\n-\t\t\t\t\"ctime\": \"1386065770.449252304\",\n+\t\t\t\t\"mtime\":                         \"1386065770.449252304\",\n+\t\t\t\t\"atime\":                         \"1389782991.41987522\",\n+\t\t\t\t\"ctime\":                         \"1386065770.449252304\",\n \t\t\t\t\"SCHILY.xattr.security.selinux\": \"unconfined_u:object_r:default_t:s0\\x00\",\n \t\t\t},\n \t\t\tFormat: FormatPAX,\n@@ -534,9 +534,10 @@ func TestReader(t *testing.T) {\n \t\t// a buggy pre-Go1.8 tar.Writer.\n \t\tfile: \"testdata/invalid-go17.tar\",\n \t\theaders: []*Header{{\n-\t\t\tName:    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/foo\",\n-\t\t\tUid:     010000000,\n-\t\t\tModTime: time.Unix(0, 0),\n+\t\t\tName:     \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/foo\",\n+\t\t\tUid:      010000000,\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tTypeflag: '0',\n \t\t}},\n \t}, {\n \t\t// USTAR archive with a regular entry with non-zero device numbers."}, {"sha": "2676853122a5605d9751192357d092d43a4a0680", "filename": "libgo/go/archive/tar/tar_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -306,6 +306,7 @@ func TestRoundTrip(t *testing.T) {\n \t\tModTime:    time.Now().Round(time.Second),\n \t\tPAXRecords: map[string]string{\"uid\": \"2097152\"},\n \t\tFormat:     FormatPAX,\n+\t\tTypeflag:   TypeReg,\n \t}\n \tif err := tw.WriteHeader(hdr); err != nil {\n \t\tt.Fatalf(\"tw.WriteHeader: %v\", err)"}, {"sha": "c18d4283e38097edf81165094a4635a473693e94", "filename": "libgo/go/archive/tar/testdata/file-and-dir.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Ffile-and-dir.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Ffile-and-dir.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Ffile-and-dir.tar?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "93718b3034879fba292186c38fae7a9e7be69801", "filename": "libgo/go/archive/tar/testdata/trailing-slash.tar", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Ftrailing-slash.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Ftrailing-slash.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Ftrailing-slash.tar?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e80498d03e39c0699a4f6d51c91fd4dda471ffa4", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -5,7 +5,6 @@\n package tar\n \n import (\n-\t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n \t\"path\"\n@@ -71,6 +70,16 @@ func (tw *Writer) WriteHeader(hdr *Header) error {\n \t}\n \ttw.hdr = *hdr // Shallow copy of Header\n \n+\t// Avoid usage of the legacy TypeRegA flag, and automatically promote\n+\t// it to use TypeReg or TypeDir.\n+\tif tw.hdr.Typeflag == TypeRegA {\n+\t\tif strings.HasSuffix(tw.hdr.Name, \"/\") {\n+\t\t\ttw.hdr.Typeflag = TypeDir\n+\t\t} else {\n+\t\t\ttw.hdr.Typeflag = TypeReg\n+\t\t}\n+\t}\n+\n \t// Round ModTime and ignore AccessTime and ChangeTime unless\n \t// the format is explicitly chosen.\n \t// This ensures nominal usage of WriteHeader (without specifying the format)\n@@ -166,7 +175,7 @@ func (tw *Writer) writePAXHeader(hdr *Header, paxHdrs map[string]string) error {\n \t\tsort.Strings(keys)\n \n \t\t// Write each record to a buffer.\n-\t\tvar buf bytes.Buffer\n+\t\tvar buf strings.Builder\n \t\tfor _, k := range keys {\n \t\t\trec, err := formatPAXRecord(k, paxHdrs[k])\n \t\t\tif err != nil {"}, {"sha": "30556d27d027f370bd88396aae497526a3a8488a", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -461,6 +461,15 @@ func TestWriter(t *testing.T) {\n \t\t\ttestHeader{Header{Name: strings.Repeat(\"123456789/\", 30)}, nil},\n \t\t\ttestClose{nil},\n \t\t},\n+\t}, {\n+\t\t// Automatically promote zero value of Typeflag depending on the name.\n+\t\tfile: \"testdata/file-and-dir.tar\",\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{Name: \"small.txt\", Size: 5}, nil},\n+\t\t\ttestWrite{\"Kilts\", 5, nil},\n+\t\t\ttestHeader{Header{Name: \"dir/\"}, nil},\n+\t\t\ttestClose{nil},\n+\t\t},\n \t}}\n \n \tequalError := func(x, y error) bool {\n@@ -809,8 +818,8 @@ func TestValidTypeflagWithPAXHeader(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"Failed to read header: %s\", err)\n \t\t}\n-\t\tif header.Typeflag != 0 {\n-\t\t\tt.Fatalf(\"Typeflag should've been 0, found %d\", header.Typeflag)\n+\t\tif header.Typeflag != TypeReg {\n+\t\t\tt.Fatalf(\"Typeflag should've been %d, found %d\", TypeReg, header.Typeflag)\n \t\t}\n \t}\n }"}, {"sha": "c90151d9d44bb1a09b7cede7dd7c3812d69ce54a", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -81,8 +81,17 @@ const (\n // See the zip spec for details.\n type FileHeader struct {\n \t// Name is the name of the file.\n-\t// It must be a relative path, not start with a drive letter (e.g. C:),\n-\t// and must use forward slashes instead of back slashes.\n+\t//\n+\t// It must be a relative path, not start with a drive letter (such as \"C:\"),\n+\t// and must use forward slashes instead of back slashes. A trailing slash\n+\t// indicates that this file is a directory and should have no data.\n+\t//\n+\t// When reading zip files, the Name field is populated from\n+\t// the zip file directly and is not validated for correctness.\n+\t// It is the caller's responsibility to sanitize it as\n+\t// appropriate, including canonicalizing slash directions,\n+\t// validating that paths are relative, and preventing path\n+\t// traversal through filenames (\"../../../\").\n \tName string\n \n \t// Comment is any arbitrary user-defined string shorter than 64KiB.\n@@ -201,7 +210,7 @@ func timeZone(offset time.Duration) *time.Location {\n \n // msDosTimeToTime converts an MS-DOS date and time into a time.Time.\n // The resolution is 2s.\n-// See: http://msdn.microsoft.com/en-us/library/ms724247(v=VS.85).aspx\n+// See: https://msdn.microsoft.com/en-us/library/ms724247(v=VS.85).aspx\n func msDosTimeToTime(dosDate, dosTime uint16) time.Time {\n \treturn time.Date(\n \t\t// date bits 0-4: day of month; 5-8: month; 9-15: years since 1980\n@@ -221,7 +230,7 @@ func msDosTimeToTime(dosDate, dosTime uint16) time.Time {\n \n // timeToMsDosTime converts a time.Time to an MS-DOS date and time.\n // The resolution is 2s.\n-// See: http://msdn.microsoft.com/en-us/library/ms724274(v=VS.85).aspx\n+// See: https://msdn.microsoft.com/en-us/library/ms724274(v=VS.85).aspx\n func timeToMsDosTime(t time.Time) (fDate uint16, fTime uint16) {\n \tfDate = uint16(t.Day() + int(t.Month())<<5 + (t.Year()-1980)<<9)\n \tfTime = uint16(t.Second()/2 + t.Minute()<<5 + t.Hour()<<11)"}, {"sha": "5f0c0a1a555ac685210d5eb2c52d4fe2fffc5258", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 56, "deletions": 24, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n+\t\"strings\"\n \t\"unicode/utf8\"\n )\n \n@@ -71,7 +72,7 @@ func (w *Writer) SetComment(comment string) error {\n }\n \n // Close finishes writing the zip file by writing the central directory.\n-// It does not (and cannot) close the underlying writer.\n+// It does not close the underlying writer.\n func (w *Writer) Close() error {\n \tif w.last != nil && !w.last.closed {\n \t\tif err := w.last.close(); err != nil {\n@@ -209,7 +210,8 @@ func (w *Writer) Close() error {\n // The file contents will be compressed using the Deflate method.\n // The name must be a relative path: it must not start with a drive\n // letter (e.g. C:) or leading slash, and only forward slashes are\n-// allowed.\n+// allowed. To create a directory instead of a file, add a trailing\n+// slash to the name.\n // The file's contents must be written to the io.Writer before the next\n // call to Create, CreateHeader, or Close.\n func (w *Writer) Create(name string) (io.Writer, error) {\n@@ -261,8 +263,6 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \t\treturn nil, errors.New(\"archive/zip: invalid duplicate FileHeader\")\n \t}\n \n-\tfh.Flags |= 0x8 // we will write a data descriptor\n-\n \t// The ZIP format has a sad state of affairs regarding character encoding.\n \t// Officially, the name and comment fields are supposed to be encoded\n \t// in CP-437 (which is mostly compatible with ASCII), unless the UTF-8\n@@ -319,35 +319,58 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \t\tfh.Extra = append(fh.Extra, mbuf[:]...)\n \t}\n \n-\tfw := &fileWriter{\n-\t\tzipw:      w.cw,\n-\t\tcompCount: &countWriter{w: w.cw},\n-\t\tcrc32:     crc32.NewIEEE(),\n-\t}\n-\tcomp := w.compressor(fh.Method)\n-\tif comp == nil {\n-\t\treturn nil, ErrAlgorithm\n-\t}\n-\tvar err error\n-\tfw.comp, err = comp(fw.compCount)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tfw.rawCount = &countWriter{w: fw.comp}\n-\n+\tvar (\n+\t\tow io.Writer\n+\t\tfw *fileWriter\n+\t)\n \th := &header{\n \t\tFileHeader: fh,\n \t\toffset:     uint64(w.cw.count),\n \t}\n-\tw.dir = append(w.dir, h)\n-\tfw.header = h\n \n+\tif strings.HasSuffix(fh.Name, \"/\") {\n+\t\t// Set the compression method to Store to ensure data length is truly zero,\n+\t\t// which the writeHeader method always encodes for the size fields.\n+\t\t// This is necessary as most compression formats have non-zero lengths\n+\t\t// even when compressing an empty string.\n+\t\tfh.Method = Store\n+\t\tfh.Flags &^= 0x8 // we will not write a data descriptor\n+\n+\t\t// Explicitly clear sizes as they have no meaning for directories.\n+\t\tfh.CompressedSize = 0\n+\t\tfh.CompressedSize64 = 0\n+\t\tfh.UncompressedSize = 0\n+\t\tfh.UncompressedSize64 = 0\n+\n+\t\tow = dirWriter{}\n+\t} else {\n+\t\tfh.Flags |= 0x8 // we will write a data descriptor\n+\n+\t\tfw = &fileWriter{\n+\t\t\tzipw:      w.cw,\n+\t\t\tcompCount: &countWriter{w: w.cw},\n+\t\t\tcrc32:     crc32.NewIEEE(),\n+\t\t}\n+\t\tcomp := w.compressor(fh.Method)\n+\t\tif comp == nil {\n+\t\t\treturn nil, ErrAlgorithm\n+\t\t}\n+\t\tvar err error\n+\t\tfw.comp, err = comp(fw.compCount)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tfw.rawCount = &countWriter{w: fw.comp}\n+\t\tfw.header = h\n+\t\tow = fw\n+\t}\n+\tw.dir = append(w.dir, h)\n \tif err := writeHeader(w.cw, fh); err != nil {\n \t\treturn nil, err\n \t}\n-\n+\t// If we're creating a directory, fw is nil.\n \tw.last = fw\n-\treturn fw, nil\n+\treturn ow, nil\n }\n \n func writeHeader(w io.Writer, h *FileHeader) error {\n@@ -400,6 +423,15 @@ func (w *Writer) compressor(method uint16) Compressor {\n \treturn comp\n }\n \n+type dirWriter struct{}\n+\n+func (dirWriter) Write(b []byte) (int, error) {\n+\tif len(b) == 0 {\n+\t\treturn 0, nil\n+\t}\n+\treturn 0, errors.New(\"zip: write to directory\")\n+}\n+\n type fileWriter struct {\n \t*header\n \tzipw      io.Writer"}, {"sha": "1fedfd85e82dffaf3abc8255850b6e7add17d394", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -6,6 +6,7 @@ package zip\n \n import (\n \t\"bytes\"\n+\t\"encoding/binary\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -299,6 +300,59 @@ func TestWriterFlush(t *testing.T) {\n \t}\n }\n \n+func TestWriterDir(t *testing.T) {\n+\tw := NewWriter(ioutil.Discard)\n+\tdw, err := w.Create(\"dir/\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif _, err := dw.Write(nil); err != nil {\n+\t\tt.Errorf(\"Write(nil) to directory: got %v, want nil\", err)\n+\t}\n+\tif _, err := dw.Write([]byte(\"hello\")); err == nil {\n+\t\tt.Error(`Write(\"hello\") to directory: got nil error, want non-nil`)\n+\t}\n+}\n+\n+func TestWriterDirAttributes(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tw := NewWriter(&buf)\n+\tif _, err := w.CreateHeader(&FileHeader{\n+\t\tName:               \"dir/\",\n+\t\tMethod:             Deflate,\n+\t\tCompressedSize64:   1234,\n+\t\tUncompressedSize64: 5678,\n+\t}); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tb := buf.Bytes()\n+\n+\tvar sig [4]byte\n+\tbinary.LittleEndian.PutUint32(sig[:], uint32(fileHeaderSignature))\n+\n+\tidx := bytes.Index(b, sig[:])\n+\tif idx == -1 {\n+\t\tt.Fatal(\"file header not found\")\n+\t}\n+\tb = b[idx:]\n+\n+\tif !bytes.Equal(b[6:10], []byte{0, 0, 0, 0}) { // FileHeader.Flags: 0, FileHeader.Method: 0\n+\t\tt.Errorf(\"unexpected method and flags: %v\", b[6:10])\n+\t}\n+\n+\tif !bytes.Equal(b[14:26], make([]byte, 12)) { // FileHeader.{CRC32,CompressSize,UncompressedSize} all zero.\n+\t\tt.Errorf(\"unexpected crc, compress and uncompressed size to be 0 was: %v\", b[14:26])\n+\t}\n+\n+\tbinary.LittleEndian.PutUint32(sig[:], uint32(dataDescriptorSignature))\n+\tif bytes.Index(b, sig[:]) != -1 {\n+\t\tt.Error(\"there should be no data descriptor\")\n+\t}\n+}\n+\n func testCreate(t *testing.T, w *Writer, wt *WriteTest) {\n \theader := &FileHeader{\n \t\tName:   wt.Name,"}, {"sha": "50218a2bbd72b807511dba594e880b9dc741e8b2", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"internal/testenv\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"testing\"\n@@ -140,14 +141,7 @@ func (r *rleBuffer) Write(p []byte) (n int, err error) {\n \t\trp = &r.buf[len(r.buf)-1]\n \t\t// Fast path, if p is entirely the same byte repeated.\n \t\tif lastByte := rp.b; len(p) > 0 && p[0] == lastByte {\n-\t\t\tall := true\n-\t\t\tfor _, b := range p {\n-\t\t\t\tif b != lastByte {\n-\t\t\t\t\tall = false\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif all {\n+\t\t\tif bytes.Count(p, []byte{lastByte}) == len(p) {\n \t\t\t\trp.n += int64(len(p))\n \t\t\t\treturn len(p), nil\n \t\t\t}\n@@ -165,6 +159,25 @@ func (r *rleBuffer) Write(p []byte) (n int, err error) {\n \treturn len(p), nil\n }\n \n+func min(x, y int) int {\n+\tif x < y {\n+\t\treturn x\n+\t}\n+\treturn y\n+}\n+\n+func memset(a []byte, b byte) {\n+\tif len(a) == 0 {\n+\t\treturn\n+\t}\n+\t// Double, until we reach power of 2 >= len(a), same as bytes.Repeat,\n+\t// but without allocation.\n+\ta[0] = b\n+\tfor i, l := 1, len(a); i < l; i *= 2 {\n+\t\tcopy(a[i:], a[:i])\n+\t}\n+}\n+\n func (r *rleBuffer) ReadAt(p []byte, off int64) (n int, err error) {\n \tif len(p) == 0 {\n \t\treturn\n@@ -176,16 +189,13 @@ func (r *rleBuffer) ReadAt(p []byte, off int64) (n int, err error) {\n \tparts := r.buf[skipParts:]\n \tif len(parts) > 0 {\n \t\tskipBytes := off - parts[0].off\n-\t\tfor len(parts) > 0 {\n-\t\t\tpart := parts[0]\n-\t\t\tfor i := skipBytes; i < part.n; i++ {\n-\t\t\t\tif n == len(p) {\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\tp[n] = part.b\n-\t\t\t\tn++\n+\t\tfor _, part := range parts {\n+\t\t\trepeat := min(int(part.n-skipBytes), len(p)-n)\n+\t\t\tmemset(p[n:n+repeat], part.b)\n+\t\t\tn += repeat\n+\t\t\tif n == len(p) {\n+\t\t\t\treturn\n \t\t\t}\n-\t\t\tparts = parts[1:]\n \t\t\tskipBytes = 0\n \t\t}\n \t}\n@@ -452,6 +462,9 @@ func suffixIsZip64(t *testing.T, zip sizedReaderAt) bool {\n \n // Zip64 is required if the total size of the records is uint32max.\n func TestZip64LargeDirectory(t *testing.T) {\n+\tif runtime.GOARCH == \"wasm\" {\n+\t\tt.Skip(\"too slow on wasm\")\n+\t}\n \tif testing.Short() {\n \t\tt.Skip(\"skipping in short mode\")\n \t}"}, {"sha": "72545a7509541b1f5aeb9b3c13bb9e2bc7acedc7", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -462,6 +462,8 @@ func (b *Reader) ReadString(delim byte) (string, error) {\n \n // WriteTo implements io.WriterTo.\n // This may make multiple calls to the Read method of the underlying Reader.\n+// If the underlying reader supports the WriteTo method,\n+// this calls the underlying WriteTo without buffering.\n func (b *Reader) WriteTo(w io.Writer) (n int64, err error) {\n \tn, err = b.writeBuf(w)\n \tif err != nil {\n@@ -684,7 +686,9 @@ func (b *Writer) WriteString(s string) (int, error) {\n \treturn nn, nil\n }\n \n-// ReadFrom implements io.ReaderFrom.\n+// ReadFrom implements io.ReaderFrom. If the underlying writer\n+// supports the ReadFrom method, and b has no buffered data yet,\n+// this calls the underlying ReadFrom without buffering.\n func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) {\n \tif b.Buffered() == 0 {\n \t\tif w, ok := b.wr.(io.ReaderFrom); ok {"}, {"sha": "cefd26146479ebf7b3c1074640c955133d9db3a6", "filename": "libgo/go/bufio/scan.go", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbufio%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbufio%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -45,14 +45,19 @@ type Scanner struct {\n // input. The arguments are an initial substring of the remaining unprocessed\n // data and a flag, atEOF, that reports whether the Reader has no more data\n // to give. The return values are the number of bytes to advance the input\n-// and the next token to return to the user, plus an error, if any. If the\n-// data does not yet hold a complete token, for instance if it has no newline\n-// while scanning lines, SplitFunc can return (0, nil, nil) to signal the\n-// Scanner to read more data into the slice and try again with a longer slice\n-// starting at the same point in the input.\n+// and the next token to return to the user, if any, plus an error, if any.\n //\n-// If the returned error is non-nil, scanning stops and the error\n-// is returned to the client.\n+// Scanning stops if the function returns an error, in which case some of\n+// the input may be discarded.\n+//\n+// Otherwise, the Scanner advances the input. If the token is not nil,\n+// the Scanner returns it to the user. If the token is nil, the\n+// Scanner reads more data and continues scanning; if there is no more\n+// data--if atEOF was true--the Scanner returns. If the data does not\n+// yet hold a complete token, for instance if it has no newline while\n+// scanning lines, a SplitFunc can return (0, nil, nil) to signal the\n+// Scanner to read more data into the slice and try again with a\n+// longer slice starting at the same point in the input.\n //\n // The function is never called with an empty data slice unless atEOF\n // is true. If atEOF is true, however, data may be non-empty and,"}, {"sha": "a2eca2ed129bbf131b9ef6eccf480cf24eac65fb", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -202,6 +202,7 @@ func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) {\n \tb.lastRead = opInvalid\n \tfor {\n \t\ti := b.grow(MinRead)\n+\t\tb.buf = b.buf[:i]\n \t\tm, e := r.Read(b.buf[i:cap(b.buf)])\n \t\tif m < 0 {\n \t\t\tpanic(errNegativeRead)"}, {"sha": "acbe5ca0c49e2127b2f6abdca414d67f607094bf", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -269,6 +269,39 @@ func TestReadFrom(t *testing.T) {\n \t}\n }\n \n+type panicReader struct{ panic bool }\n+\n+func (r panicReader) Read(p []byte) (int, error) {\n+\tif r.panic {\n+\t\tpanic(nil)\n+\t}\n+\treturn 0, io.EOF\n+}\n+\n+// Make sure that an empty Buffer remains empty when\n+// it is \"grown\" before a Read that panics\n+func TestReadFromPanicReader(t *testing.T) {\n+\n+\t// First verify non-panic behaviour\n+\tvar buf Buffer\n+\ti, err := buf.ReadFrom(panicReader{})\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif i != 0 {\n+\t\tt.Fatalf(\"unexpected return from bytes.ReadFrom (1): got: %d, want %d\", i, 0)\n+\t}\n+\tcheck(t, \"TestReadFromPanicReader (1)\", &buf, \"\")\n+\n+\t// Confirm that when Reader panics, the emtpy buffer remains empty\n+\tvar buf2 Buffer\n+\tdefer func() {\n+\t\trecover()\n+\t\tcheck(t, \"TestReadFromPanicReader (2)\", &buf2, \"\")\n+\t}()\n+\tbuf2.ReadFrom(panicReader{panic: true})\n+}\n+\n func TestReadFromNegativeReader(t *testing.T) {\n \tvar b Buffer\n \tdefer func() {"}, {"sha": "437a6e12df867049c9c251a99e9a09925f9d637d", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 96, "deletions": 5, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -7,6 +7,7 @@\n package bytes\n \n import (\n+\t\"internal/bytealg\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n )\n@@ -46,12 +47,16 @@ func explode(s []byte, n int) [][]byte {\n \treturn a[0:na]\n }\n \n-// countGeneric actually implements Count\n-func countGeneric(s, sep []byte) int {\n+// Count counts the number of non-overlapping instances of sep in s.\n+// If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n+func Count(s, sep []byte) int {\n \t// special case\n \tif len(sep) == 0 {\n \t\treturn utf8.RuneCount(s) + 1\n \t}\n+\tif len(sep) == 1 {\n+\t\treturn bytealg.Count(s, sep[0])\n+\t}\n \tn := 0\n \tfor {\n \t\ti := Index(s, sep)\n@@ -800,9 +805,9 @@ func EqualFold(s, t []byte) bool {\n \t\t\ttr, sr = sr, tr\n \t\t}\n \t\t// Fast check for ASCII.\n-\t\tif tr < utf8.RuneSelf && 'A' <= sr && sr <= 'Z' {\n-\t\t\t// ASCII, and sr is upper case.  tr must be lower case.\n-\t\t\tif tr == sr+'a'-'A' {\n+\t\tif tr < utf8.RuneSelf {\n+\t\t\t// ASCII only, sr/tr must be upper/lower case\n+\t\t\tif 'A' <= sr && sr <= 'Z' && tr == sr+'a'-'A' {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\treturn false\n@@ -824,6 +829,92 @@ func EqualFold(s, t []byte) bool {\n \treturn len(s) == len(t)\n }\n \n+// Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n+func Index(s, sep []byte) int {\n+\tn := len(sep)\n+\tswitch {\n+\tcase n == 0:\n+\t\treturn 0\n+\tcase n == 1:\n+\t\treturn IndexByte(s, sep[0])\n+\tcase n == len(s):\n+\t\tif Equal(sep, s) {\n+\t\t\treturn 0\n+\t\t}\n+\t\treturn -1\n+\tcase n > len(s):\n+\t\treturn -1\n+\tcase n <= bytealg.MaxLen:\n+\t\t// Use brute force when s and sep both are small\n+\t\tif len(s) <= bytealg.MaxBruteForce {\n+\t\t\treturn bytealg.Index(s, sep)\n+\t\t}\n+\t\tc := sep[0]\n+\t\ti := 0\n+\t\tt := s[:len(s)-n+1]\n+\t\tfails := 0\n+\t\tfor i < len(t) {\n+\t\t\tif t[i] != c {\n+\t\t\t\t// IndexByte is faster than bytealg.Index, so use it as long as\n+\t\t\t\t// we're not getting lots of false positives.\n+\t\t\t\to := IndexByte(t[i:], c)\n+\t\t\t\tif o < 0 {\n+\t\t\t\t\treturn -1\n+\t\t\t\t}\n+\t\t\t\ti += o\n+\t\t\t}\n+\t\t\tif Equal(s[i:i+n], sep) {\n+\t\t\t\treturn i\n+\t\t\t}\n+\t\t\tfails++\n+\t\t\ti++\n+\t\t\t// Switch to bytealg.Index when IndexByte produces too many false positives.\n+\t\t\tif fails > bytealg.Cutover(i) {\n+\t\t\t\tr := bytealg.Index(s[i:], sep)\n+\t\t\t\tif r >= 0 {\n+\t\t\t\t\treturn r + i\n+\t\t\t\t}\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t}\n+\t\treturn -1\n+\t}\n+\tc := sep[0]\n+\ti := 0\n+\tfails := 0\n+\tt := s[:len(s)-n+1]\n+\tfor i < len(t) {\n+\t\tif t[i] != c {\n+\t\t\to := IndexByte(t[i:], c)\n+\t\t\tif o < 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\ti += o\n+\t\t}\n+\t\tif Equal(s[i:i+n], sep) {\n+\t\t\treturn i\n+\t\t}\n+\t\ti++\n+\t\tfails++\n+\t\tif fails >= 4+i>>4 && i < len(t) {\n+\t\t\t// Give up on IndexByte, it isn't skipping ahead\n+\t\t\t// far enough to be better than Rabin-Karp.\n+\t\t\t// Experiments (using IndexPeriodic) suggest\n+\t\t\t// the cutover is about 16 byte skips.\n+\t\t\t// TODO: if large prefixes of sep are matching\n+\t\t\t// we should cutover at even larger average skips,\n+\t\t\t// because Equal becomes that much more expensive.\n+\t\t\t// This code does not take that effect into account.\n+\t\t\tj := indexRabinKarp(s[i:], sep)\n+\t\t\tif j < 0 {\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t\treturn i + j\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n func indexRabinKarp(s, sep []byte) int {\n \t// Rabin-Karp search\n \thashsep, pow := hashStr(sep)"}, {"sha": "2fbbbb0d877cf843ffe97eb801b99a8a1e228995", "filename": "libgo/go/bytes/bytes_amd64.go", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go?ref=779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4", "patch": "@@ -1,90 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-package bytes\n-\n-import \"internal/cpu\"\n-\n-//go:noescape\n-\n-// indexShortStr returns the index of the first instance of c in s, or -1 if c is not present in s.\n-// indexShortStr requires 2 <= len(c) <= shortStringLen\n-func indexShortStr(s, c []byte) int  // ../runtime/asm_amd64.s\n-func countByte(s []byte, c byte) int // ../runtime/asm_amd64.s\n-\n-var shortStringLen int\n-\n-func init() {\n-\tif cpu.X86.HasAVX2 {\n-\t\tshortStringLen = 63\n-\t} else {\n-\t\tshortStringLen = 31\n-\t}\n-}\n-\n-// Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n-func Index(s, sep []byte) int {\n-\tn := len(sep)\n-\tswitch {\n-\tcase n == 0:\n-\t\treturn 0\n-\tcase n == 1:\n-\t\treturn IndexByte(s, sep[0])\n-\tcase n == len(s):\n-\t\tif Equal(sep, s) {\n-\t\t\treturn 0\n-\t\t}\n-\t\treturn -1\n-\tcase n > len(s):\n-\t\treturn -1\n-\tcase n <= shortStringLen:\n-\t\t// Use brute force when s and sep both are small\n-\t\tif len(s) <= 64 {\n-\t\t\treturn indexShortStr(s, sep)\n-\t\t}\n-\t\tc := sep[0]\n-\t\ti := 0\n-\t\tt := s[:len(s)-n+1]\n-\t\tfails := 0\n-\t\tfor i < len(t) {\n-\t\t\tif t[i] != c {\n-\t\t\t\t// IndexByte skips 16/32 bytes per iteration,\n-\t\t\t\t// so it's faster than indexShortStr.\n-\t\t\t\to := IndexByte(t[i:], c)\n-\t\t\t\tif o < 0 {\n-\t\t\t\t\treturn -1\n-\t\t\t\t}\n-\t\t\t\ti += o\n-\t\t\t}\n-\t\t\tif Equal(s[i:i+n], sep) {\n-\t\t\t\treturn i\n-\t\t\t}\n-\t\t\tfails++\n-\t\t\ti++\n-\t\t\t// Switch to indexShortStr when IndexByte produces too many false positives.\n-\t\t\t// Too many means more that 1 error per 8 characters.\n-\t\t\t// Allow some errors in the beginning.\n-\t\t\tif fails > (i+16)/8 {\n-\t\t\t\tr := indexShortStr(s[i:], sep)\n-\t\t\t\tif r >= 0 {\n-\t\t\t\t\treturn r + i\n-\t\t\t\t}\n-\t\t\t\treturn -1\n-\t\t\t}\n-\t\t}\n-\t\treturn -1\n-\t}\n-\treturn indexRabinKarp(s, sep)\n-}\n-\n-// Count counts the number of non-overlapping instances of sep in s.\n-// If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n-func Count(s, sep []byte) int {\n-\tif len(sep) == 1 && cpu.X86.HasPOPCNT {\n-\t\treturn countByte(s, sep[0])\n-\t}\n-\treturn countGeneric(s, sep)\n-}"}, {"sha": "1213b067a9dce9dd77484f1e4645f1ec42d0519f", "filename": "libgo/go/bytes/bytes_arm64.go", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4/libgo%2Fgo%2Fbytes%2Fbytes_arm64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4/libgo%2Fgo%2Fbytes%2Fbytes_arm64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_arm64.go?ref=779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4", "patch": "@@ -1,70 +0,0 @@\n-// Copyright 2017 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-package bytes\n-\n-func countByte(s []byte, c byte) int // bytes_arm64.s\n-\n-// Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n-func Index(s, sep []byte) int {\n-\tn := len(sep)\n-\tswitch {\n-\tcase n == 0:\n-\t\treturn 0\n-\tcase n == 1:\n-\t\treturn IndexByte(s, sep[0])\n-\tcase n == len(s):\n-\t\tif Equal(sep, s) {\n-\t\t\treturn 0\n-\t\t}\n-\t\treturn -1\n-\tcase n > len(s):\n-\t\treturn -1\n-\t}\n-\tc := sep[0]\n-\ti := 0\n-\tfails := 0\n-\tt := s[:len(s)-n+1]\n-\tfor i < len(t) {\n-\t\tif t[i] != c {\n-\t\t\to := IndexByte(t[i:], c)\n-\t\t\tif o < 0 {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\ti += o\n-\t\t}\n-\t\tif Equal(s[i:i+n], sep) {\n-\t\t\treturn i\n-\t\t}\n-\t\ti++\n-\t\tfails++\n-\t\tif fails >= 4+i>>4 && i < len(t) {\n-\t\t\t// Give up on IndexByte, it isn't skipping ahead\n-\t\t\t// far enough to be better than Rabin-Karp.\n-\t\t\t// Experiments (using IndexPeriodic) suggest\n-\t\t\t// the cutover is about 16 byte skips.\n-\t\t\t// TODO: if large prefixes of sep are matching\n-\t\t\t// we should cutover at even larger average skips,\n-\t\t\t// because Equal becomes that much more expensive.\n-\t\t\t// This code does not take that effect into account.\n-\t\t\tj := indexRabinKarp(s[i:], sep)\n-\t\t\tif j < 0 {\n-\t\t\t\treturn -1\n-\t\t\t}\n-\t\t\treturn i + j\n-\t\t}\n-\t}\n-\treturn -1\n-}\n-\n-// Count counts the number of non-overlapping instances of sep in s.\n-// If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n-func Count(s, sep []byte) int {\n-\tif len(sep) == 1 {\n-\t\treturn countByte(s, sep[0])\n-\t}\n-\treturn countGeneric(s, sep)\n-}"}, {"sha": "af0f8b179fddb92daf1540db5c49dd8635a682b8", "filename": "libgo/go/bytes/bytes_decl.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fbytes_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fbytes_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_decl.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -6,19 +6,19 @@ package bytes\n \n //go:noescape\n \n-// IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\n-func IndexByte(s []byte, c byte) int // ../runtime/asm_$GOARCH.s\n+// IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.\n+func IndexByte(b []byte, c byte) int // in internal/bytealg\n \n //go:noescape\n \n // Equal returns a boolean reporting whether a and b\n // are the same length and contain the same bytes.\n // A nil argument is equivalent to an empty slice.\n-func Equal(a, b []byte) bool // ../runtime/asm_$GOARCH.s\n+func Equal(a, b []byte) bool // in internal/bytealg\n \n //go:noescape\n \n // Compare returns an integer comparing two byte slices lexicographically.\n // The result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n // A nil argument is equivalent to an empty slice.\n-func Compare(a, b []byte) int // ../runtime/noasm.go or ../runtime/asm_{386,amd64}.s\n+func Compare(a, b []byte) int // in internal/bytealg"}, {"sha": "b52d93965208011d9ffc70b2f004b2eb66f16c0b", "filename": "libgo/go/bytes/bytes_generic.go", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4/libgo%2Fgo%2Fbytes%2Fbytes_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4/libgo%2Fgo%2Fbytes%2Fbytes_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_generic.go?ref=779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4", "patch": "@@ -1,65 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// -build !amd64,!s390x,!arm64\n-\n-package bytes\n-\n-// Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n-func Index(s, sep []byte) int {\n-\tn := len(sep)\n-\tswitch {\n-\tcase n == 0:\n-\t\treturn 0\n-\tcase n == 1:\n-\t\treturn IndexByte(s, sep[0])\n-\tcase n == len(s):\n-\t\tif Equal(sep, s) {\n-\t\t\treturn 0\n-\t\t}\n-\t\treturn -1\n-\tcase n > len(s):\n-\t\treturn -1\n-\t}\n-\tc := sep[0]\n-\ti := 0\n-\tfails := 0\n-\tt := s[:len(s)-n+1]\n-\tfor i < len(t) {\n-\t\tif t[i] != c {\n-\t\t\to := IndexByte(t[i:], c)\n-\t\t\tif o < 0 {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\ti += o\n-\t\t}\n-\t\tif Equal(s[i:i+n], sep) {\n-\t\t\treturn i\n-\t\t}\n-\t\ti++\n-\t\tfails++\n-\t\tif fails >= 4+i>>4 && i < len(t) {\n-\t\t\t// Give up on IndexByte, it isn't skipping ahead\n-\t\t\t// far enough to be better than Rabin-Karp.\n-\t\t\t// Experiments (using IndexPeriodic) suggest\n-\t\t\t// the cutover is about 16 byte skips.\n-\t\t\t// TODO: if large prefixes of sep are matching\n-\t\t\t// we should cutover at even larger average skips,\n-\t\t\t// because Equal becomes that much more expensive.\n-\t\t\t// This code does not take that effect into account.\n-\t\t\tj := indexRabinKarp(s[i:], sep)\n-\t\t\tif j < 0 {\n-\t\t\t\treturn -1\n-\t\t\t}\n-\t\t\treturn i + j\n-\t\t}\n-\t}\n-\treturn -1\n-}\n-\n-// Count counts the number of non-overlapping instances of sep in s.\n-// If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n-func Count(s, sep []byte) int {\n-\treturn countGeneric(s, sep)\n-}"}, {"sha": "0c228486fc3be5f7c0565fde177487b9c01a53c1", "filename": "libgo/go/bytes/bytes_s390x.go", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go?ref=779d8a5ad09b01428726ea5a0e6c87bd9ac3c0e4", "patch": "@@ -1,88 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-package bytes\n-\n-//go:noescape\n-\n-// indexShortStr returns the index of the first instance of sep in s,\n-// or -1 if sep is not present in s.\n-// indexShortStr requires 2 <= len(sep) <= shortStringLen\n-func indexShortStr(s, c []byte) int // ../runtime/asm_s390x.s\n-\n-// supportsVX reports whether the vector facility is available.\n-// indexShortStr must not be called if the vector facility is not\n-// available.\n-func supportsVX() bool // ../runtime/asm_s390x.s\n-\n-var shortStringLen = -1\n-\n-func init() {\n-\tif supportsVX() {\n-\t\tshortStringLen = 64\n-\t}\n-}\n-\n-// Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n-func Index(s, sep []byte) int {\n-\tn := len(sep)\n-\tswitch {\n-\tcase n == 0:\n-\t\treturn 0\n-\tcase n == 1:\n-\t\treturn IndexByte(s, sep[0])\n-\tcase n == len(s):\n-\t\tif Equal(sep, s) {\n-\t\t\treturn 0\n-\t\t}\n-\t\treturn -1\n-\tcase n > len(s):\n-\t\treturn -1\n-\tcase n <= shortStringLen:\n-\t\t// Use brute force when s and sep both are small\n-\t\tif len(s) <= 64 {\n-\t\t\treturn indexShortStr(s, sep)\n-\t\t}\n-\t\tc := sep[0]\n-\t\ti := 0\n-\t\tt := s[:len(s)-n+1]\n-\t\tfails := 0\n-\t\tfor i < len(t) {\n-\t\t\tif t[i] != c {\n-\t\t\t\t// IndexByte skips 16/32 bytes per iteration,\n-\t\t\t\t// so it's faster than indexShortStr.\n-\t\t\t\to := IndexByte(t[i:], c)\n-\t\t\t\tif o < 0 {\n-\t\t\t\t\treturn -1\n-\t\t\t\t}\n-\t\t\t\ti += o\n-\t\t\t}\n-\t\t\tif Equal(s[i:i+n], sep) {\n-\t\t\t\treturn i\n-\t\t\t}\n-\t\t\tfails++\n-\t\t\ti++\n-\t\t\t// Switch to indexShortStr when IndexByte produces too many false positives.\n-\t\t\t// Too many means more that 1 error per 8 characters.\n-\t\t\t// Allow some errors in the beginning.\n-\t\t\tif fails > (i+16)/8 {\n-\t\t\t\tr := indexShortStr(s[i:], sep)\n-\t\t\t\tif r >= 0 {\n-\t\t\t\t\treturn r + i\n-\t\t\t\t}\n-\t\t\t\treturn -1\n-\t\t\t}\n-\t\t}\n-\t\treturn -1\n-\t}\n-\treturn indexRabinKarp(s, sep)\n-}\n-\n-// Count counts the number of non-overlapping instances of sep in s.\n-// If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n-func Count(s, sep []byte) int {\n-\treturn countGeneric(s, sep)\n-}"}, {"sha": "11c5ef9ab807b9e3ae1a1b034cf2861bb3ca21ea", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -415,10 +415,6 @@ func TestCountByte(t *testing.T) {\n \t\t\tif p != j+1 {\n \t\t\t\tt.Errorf(\"TestCountByte.Count(%q, 100) = %d\", b[i:i+window], p)\n \t\t\t}\n-\t\t\tpGeneric := CountGeneric(b[i:i+window], []byte{100})\n-\t\t\tif pGeneric != j+1 {\n-\t\t\t\tt.Errorf(\"TestCountByte.CountGeneric(%q, 100) = %d\", b[i:i+window], p)\n-\t\t\t}\n \t\t}\n \t}\n \n@@ -466,10 +462,6 @@ func TestCountByteNoMatch(t *testing.T) {\n \t\t\tif p != 0 {\n \t\t\t\tt.Errorf(\"TestCountByteNoMatch(%q, 0) = %d\", b[i:i+window], p)\n \t\t\t}\n-\t\t\tpGeneric := CountGeneric(b[i:i+window], []byte{0})\n-\t\t\tif pGeneric != 0 {\n-\t\t\t\tt.Errorf(\"TestCountByteNoMatch.CountGeneric(%q, 100) = %d\", b[i:i+window], p)\n-\t\t\t}\n \t\t\tfor j := 0; j < window; j++ {\n \t\t\t\tb[i+j] = byte(0)\n \t\t\t}"}, {"sha": "3e33c27c9c961164419f1c2b68f80c96e5a8aa1f", "filename": "libgo/go/bytes/compare_test.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fcompare_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -6,6 +6,7 @@ package bytes_test\n \n import (\n \t. \"bytes\"\n+\t\"internal/testenv\"\n \t\"testing\"\n )\n \n@@ -58,10 +59,20 @@ func TestCompareIdenticalSlice(t *testing.T) {\n }\n \n func TestCompareBytes(t *testing.T) {\n-\tn := 128\n+\tlengths := make([]int, 0) // lengths to test in ascending order\n+\tfor i := 0; i <= 128; i++ {\n+\t\tlengths = append(lengths, i)\n+\t}\n+\tlengths = append(lengths, 256, 512, 1024, 1333, 4095, 4096, 4097)\n+\n+\tif !testing.Short() || testenv.Builder() != \"\" {\n+\t\tlengths = append(lengths, 65535, 65536, 65537, 99999)\n+\t}\n+\n+\tn := lengths[len(lengths)-1]\n \ta := make([]byte, n+1)\n \tb := make([]byte, n+1)\n-\tfor len := 0; len < 128; len++ {\n+\tfor _, len := range lengths {\n \t\t// randomish but deterministic data. No 0 or 255.\n \t\tfor i := 0; i < len; i++ {\n \t\t\ta[i] = byte(1 + 31*i%254)"}, {"sha": "f61523e60bbb3fd209594912ebcaa76cde9acd20", "filename": "libgo/go/bytes/export_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fbytes%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexport_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -7,4 +7,3 @@ package bytes\n // Export func for testing\n var IndexBytePortable = indexBytePortable\n var EqualPortable = equalPortable\n-var CountGeneric = countGeneric"}, {"sha": "1c7b228c98710b8c84fc0c1bd311a51f1bd8231f", "filename": "libgo/go/cmd/buildid/buildid.go", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fbuildid%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fbuildid%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fbuildid%2Fbuildid.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -22,6 +22,21 @@ func usage() {\n \n var wflag = flag.Bool(\"w\", false, \"write build ID\")\n \n+// taken from cmd/go/internal/work/buildid.go\n+func hashToString(h [32]byte) string {\n+\tconst b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"\n+\tconst chunks = 5\n+\tvar dst [chunks * 4]byte\n+\tfor i := 0; i < chunks; i++ {\n+\t\tv := uint32(h[3*i])<<16 | uint32(h[3*i+1])<<8 | uint32(h[3*i+2])\n+\t\tdst[4*i+0] = b64[(v>>18)&0x3F]\n+\t\tdst[4*i+1] = b64[(v>>12)&0x3F]\n+\t\tdst[4*i+2] = b64[(v>>6)&0x3F]\n+\t\tdst[4*i+3] = b64[v&0x3F]\n+\t}\n+\treturn string(dst[:])\n+}\n+\n func main() {\n \tlog.SetPrefix(\"buildid: \")\n \tlog.SetFlags(0)\n@@ -41,6 +56,8 @@ func main() {\n \t\treturn\n \t}\n \n+\t// Keep in sync with src/cmd/go/internal/work/buildid.go:updateBuildID\n+\n \tf, err := os.Open(file)\n \tif err != nil {\n \t\tlog.Fatal(err)\n@@ -51,14 +68,14 @@ func main() {\n \t}\n \tf.Close()\n \n-\ttail := id\n-\tif i := strings.LastIndex(id, \".\"); i >= 0 {\n-\t\ttail = tail[i+1:]\n+\tnewID := id[:strings.LastIndex(id, \"/\")] + \"/\" + hashToString(hash)\n+\tif len(newID) != len(id) {\n+\t\tlog.Fatalf(\"%s: build ID length mismatch %q vs %q\", file, id, newID)\n \t}\n-\tif len(tail) != len(hash)*2 {\n-\t\tlog.Fatalf(\"%s: cannot find %d-byte hash in id %s\", file, len(hash), id)\n+\n+\tif len(matches) == 0 {\n+\t\treturn\n \t}\n-\tnewID := id[:len(id)-len(tail)] + fmt.Sprintf(\"%x\", hash)\n \n \tf, err = os.OpenFile(file, os.O_WRONLY, 0)\n \tif err != nil {"}, {"sha": "4462136bf4bc5720ee21bc55ff52cbf76ad71408", "filename": "libgo/go/cmd/cgo/ast.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -95,7 +95,7 @@ func (f *File) ParseGo(name string, src []byte) {\n \t\t}\n \t}\n \tif !sawC {\n-\t\terror_(token.NoPos, `cannot find import \"C\"`)\n+\t\terror_(ast1.Package, `cannot find import \"C\"`)\n \t}\n \n \t// In ast2, strip the import \"C\" line.\n@@ -356,6 +356,7 @@ func (f *File) walk(x interface{}, context astContext, visit func(*File, interfa\n \tcase *ast.BadExpr:\n \tcase *ast.Ident:\n \tcase *ast.Ellipsis:\n+\t\tf.walk(&n.Elt, ctxType, visit)\n \tcase *ast.BasicLit:\n \tcase *ast.FuncLit:\n \t\tf.walk(n.Type, ctxType, visit)"}, {"sha": "157cd94d653abf71214778226ab01ef54e9059ab", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -64,6 +64,11 @@ a full argument: to allow -mfoo=bar, use CGO_CFLAGS_ALLOW='-mfoo.*',\n not just CGO_CFLAGS_ALLOW='-mfoo'. Similarly named variables control\n the allowed CPPFLAGS, CXXFLAGS, FFLAGS, and LDFLAGS.\n \n+Also for security reasons, only a limited set of characters are\n+permitted, notably alphanumeric characters and a few symbols, such as\n+'.', that will not be interpreted in unexpected ways. Attempts to use\n+forbidden characters will get a \"malformed #cgo argument\" error.\n+\n When building, the CGO_CFLAGS, CGO_CPPFLAGS, CGO_CXXFLAGS, CGO_FFLAGS and\n CGO_LDFLAGS environment variables are added to the flags derived from\n these directives. Package-specific flags should be set using the\n@@ -99,17 +104,24 @@ compiled with the C compiler. Any .cc, .cpp, or .cxx files will be\n compiled with the C++ compiler. Any .f, .F, .for or .f90 files will be\n compiled with the fortran compiler. Any .h, .hh, .hpp, or .hxx files will\n not be compiled separately, but, if these header files are changed,\n-the C and C++ files will be recompiled. The default C and C++\n-compilers may be changed by the CC and CXX environment variables,\n-respectively; those environment variables may include command line\n-options.\n+the package (including its non-Go source files) will be recompiled.\n+Note that changes to files in other directories do not cause the package\n+to be recompiled, so all non-Go source code for the package should be\n+stored in the package directory, not in subdirectories.\n+The default C and C++ compilers may be changed by the CC and CXX\n+environment variables, respectively; those environment variables\n+may include command line options.\n \n The cgo tool is enabled by default for native builds on systems where\n it is expected to work. It is disabled by default when\n cross-compiling. You can control this by setting the CGO_ENABLED\n environment variable when running the go tool: set it to 1 to enable\n the use of cgo, and to 0 to disable it. The go tool will set the\n-build constraint \"cgo\" if cgo is enabled.\n+build constraint \"cgo\" if cgo is enabled. The special import \"C\"\n+implies the \"cgo\" build constraint, as though the file also said\n+\"// +build cgo\".  Therefore, if cgo is disabled, files that import\n+\"C\" will not be built by the go tool. (For more about build constraints\n+see https://golang.org/pkg/go/build/#hdr-Build_Constraints).\n \n When cross-compiling, you must specify a C cross-compiler for cgo to\n use. You can do this by setting the generic CC_FOR_TARGET or the\n@@ -219,6 +231,26 @@ C compilers are aware of this calling convention and adjust\n the call accordingly, but Go cannot. In Go, you must pass\n the pointer to the first element explicitly: C.f(&C.x[0]).\n \n+Calling variadic C functions is not supported. It is possible to\n+circumvent this by using a C function wrapper. For example:\n+\n+\tpackage main\n+\n+\t// #include <stdio.h>\n+\t// #include <stdlib.h>\n+\t//\n+\t// static void myprint(char* s) {\n+\t//   printf(\"%s\\n\", s);\n+\t// }\n+\timport \"C\"\n+\timport \"unsafe\"\n+\n+\tfunc main() {\n+\t\tcs := C.CString(\"Hello from stdio\")\n+\t\tC.myprint(cs)\n+\t\tC.free(unsafe.Pointer(cs))\n+\t}\n+\n A few special functions convert between Go and C types\n by making copies of the data. In pseudo-Go definitions:\n \n@@ -348,6 +380,14 @@ and of course there is nothing stopping the C code from doing anything\n it likes. However, programs that break these rules are likely to fail\n in unexpected and unpredictable ways.\n \n+Note: the current implementation has a bug. While Go code is permitted\n+to write nil or a C pointer (but not a Go pointer) to C memory, the\n+current implementation may sometimes cause a runtime error if the\n+contents of the C memory appear to be a Go pointer. Therefore, avoid\n+passing uninitialized C memory to Go code if the Go code is going to\n+store pointer values in it. Zero out the memory in C before passing it\n+to Go.\n+\n Special cases\n \n A few special C types which would normally be represented by a pointer"}, {"sha": "2a2d0080d5e18f231c769bb7cc28bad56cfc4f0e", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 132, "deletions": 15, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -183,9 +183,29 @@ func (p *Package) Translate(f *File) {\n \t\tcref.Name.C = cname(cref.Name.Go)\n \t}\n \tp.loadDefines(f)\n-\tneedType := p.guessKinds(f)\n-\tif len(needType) > 0 {\n-\t\tp.loadDWARF(f, needType)\n+\tp.typedefs = map[string]bool{}\n+\tp.typedefList = nil\n+\tnumTypedefs := -1\n+\tfor len(p.typedefs) > numTypedefs {\n+\t\tnumTypedefs = len(p.typedefs)\n+\t\t// Also ask about any typedefs we've seen so far.\n+\t\tfor _, a := range p.typedefList {\n+\t\t\tf.Name[a] = &Name{\n+\t\t\t\tGo: a,\n+\t\t\t\tC:  a,\n+\t\t\t}\n+\t\t}\n+\t\tneedType := p.guessKinds(f)\n+\t\tif len(needType) > 0 {\n+\t\t\tp.loadDWARF(f, needType)\n+\t\t}\n+\n+\t\t// In godefs mode we're OK with the typedefs, which\n+\t\t// will presumably also be defined in the file, we\n+\t\t// don't want to resolve them to their base types.\n+\t\tif *godefs {\n+\t\t\tbreak\n+\t\t}\n \t}\n \tif p.rewriteCalls(f) {\n \t\t// Add `import _cgo_unsafe \"unsafe\"` after the package statement.\n@@ -570,6 +590,7 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t\t\t\tfatalf(\"malformed __cgo__ name: %s\", name)\n \t\t\t}\n \t\t\ttypes[i] = t.Type\n+\t\t\tp.recordTypedefs(t.Type)\n \t\t}\n \t\tif e.Tag != dwarf.TagCompileUnit {\n \t\t\tr.SkipChildren()\n@@ -605,7 +626,25 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\tcase \"fconst\":\n-\t\t\t\tif i < len(floats) {\n+\t\t\t\tif i >= len(floats) {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tswitch base(types[i]).(type) {\n+\t\t\t\tcase *dwarf.IntType, *dwarf.UintType:\n+\t\t\t\t\t// This has an integer type so it's\n+\t\t\t\t\t// not really a floating point\n+\t\t\t\t\t// constant. This can happen when the\n+\t\t\t\t\t// C compiler complains about using\n+\t\t\t\t\t// the value as an integer constant,\n+\t\t\t\t\t// but not as a general constant.\n+\t\t\t\t\t// Treat this as a variable of the\n+\t\t\t\t\t// appropriate type, not a constant,\n+\t\t\t\t\t// to get C-style type handling,\n+\t\t\t\t\t// avoiding the problem that C permits\n+\t\t\t\t\t// uint64(-1) but Go does not.\n+\t\t\t\t\t// See issue 26066.\n+\t\t\t\t\tn.Kind = \"var\"\n+\t\t\t\tdefault:\n \t\t\t\t\tn.Const = fmt.Sprintf(\"%f\", floats[i])\n \t\t\t\t}\n \t\t\tcase \"sconst\":\n@@ -618,6 +657,47 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t}\n }\n \n+// recordTypedefs remembers in p.typedefs all the typedefs used in dtypes and its children.\n+func (p *Package) recordTypedefs(dtype dwarf.Type) {\n+\tp.recordTypedefs1(dtype, map[dwarf.Type]bool{})\n+}\n+func (p *Package) recordTypedefs1(dtype dwarf.Type, visited map[dwarf.Type]bool) {\n+\tif dtype == nil {\n+\t\treturn\n+\t}\n+\tif visited[dtype] {\n+\t\treturn\n+\t}\n+\tvisited[dtype] = true\n+\tswitch dt := dtype.(type) {\n+\tcase *dwarf.TypedefType:\n+\t\tif strings.HasPrefix(dt.Name, \"__builtin\") {\n+\t\t\t// Don't look inside builtin types. There be dragons.\n+\t\t\treturn\n+\t\t}\n+\t\tif !p.typedefs[dt.Name] {\n+\t\t\tp.typedefs[dt.Name] = true\n+\t\t\tp.typedefList = append(p.typedefList, dt.Name)\n+\t\t\tp.recordTypedefs1(dt.Type, visited)\n+\t\t}\n+\tcase *dwarf.PtrType:\n+\t\tp.recordTypedefs1(dt.Type, visited)\n+\tcase *dwarf.ArrayType:\n+\t\tp.recordTypedefs1(dt.Type, visited)\n+\tcase *dwarf.QualType:\n+\t\tp.recordTypedefs1(dt.Type, visited)\n+\tcase *dwarf.FuncType:\n+\t\tp.recordTypedefs1(dt.ReturnType, visited)\n+\t\tfor _, a := range dt.ParamType {\n+\t\t\tp.recordTypedefs1(a, visited)\n+\t\t}\n+\tcase *dwarf.StructType:\n+\t\tfor _, f := range dt.Field {\n+\t\t\tp.recordTypedefs1(f.Type, visited)\n+\t\t}\n+\t}\n+}\n+\n // mangleName does name mangling to translate names\n // from the original Go source files to the names\n // used in the final Go files generated by cgo.\n@@ -1373,7 +1453,7 @@ func (p *Package) gccDebug(stdin []byte, nnames int) (d *dwarf.Data, ints []int6\n \t\t\tif len(data) <= strlen {\n \t\t\t\tfatalf(\"invalid string literal\")\n \t\t\t}\n-\t\t\tstrs[n] = string(data[:strlen])\n+\t\t\tstrs[n] = data[:strlen]\n \t\t}\n \t}\n \n@@ -1754,6 +1834,7 @@ type typeConv struct {\n \t// Map from types to incomplete pointers to those types.\n \tptrs map[dwarf.Type][]*Type\n \t// Keys of ptrs in insertion order (deterministic worklist)\n+\t// ptrKeys contains exactly the keys in ptrs.\n \tptrKeys []dwarf.Type\n \n \t// Type names X for which there exists an XGetTypeID function with type func() CFTypeID.\n@@ -1896,14 +1977,15 @@ func (c *typeConv) FinishType(pos token.Pos) {\n \tfor len(c.ptrKeys) > 0 {\n \t\tdtype := c.ptrKeys[0]\n \t\tc.ptrKeys = c.ptrKeys[1:]\n+\t\tptrs := c.ptrs[dtype]\n+\t\tdelete(c.ptrs, dtype)\n \n \t\t// Note Type might invalidate c.ptrs[dtype].\n \t\tt := c.Type(dtype, pos)\n-\t\tfor _, ptr := range c.ptrs[dtype] {\n+\t\tfor _, ptr := range ptrs {\n \t\t\tptr.Go.(*ast.StarExpr).X = t.Go\n \t\t\tptr.C.Set(\"%s*\", t.C)\n \t\t}\n-\t\tc.ptrs[dtype] = nil // retain the map key\n \t}\n }\n \n@@ -2180,6 +2262,10 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\ts := *sub\n \t\t\ts.Go = c.uintptr\n \t\t\tsub = &s\n+\t\t\t// Make sure we update any previously computed type.\n+\t\t\tif oldType := typedef[name.Name]; oldType != nil {\n+\t\t\t\toldType.Go = sub.Go\n+\t\t\t}\n \t\t}\n \t\tt.Go = name\n \t\tif unionWithPointer[sub.Go] {\n@@ -2341,7 +2427,7 @@ func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\t}\n \t\t\t// ...or the typedef is one in which we expect bad pointers.\n \t\t\t// It will be a uintptr instead of *X.\n-\t\t\tif c.badPointerTypedef(dt) {\n+\t\t\tif c.baseBadPointerTypedef(dt) {\n \t\t\t\tbreak\n \t\t\t}\n \n@@ -2693,6 +2779,19 @@ func (c *typeConv) badPointerTypedef(dt *dwarf.TypedefType) bool {\n \treturn false\n }\n \n+// baseBadPointerTypedef reports whether the base of a chain of typedefs is a bad typedef\n+// as badPointerTypedef reports.\n+func (c *typeConv) baseBadPointerTypedef(dt *dwarf.TypedefType) bool {\n+\tfor {\n+\t\tif t, ok := dt.Type.(*dwarf.TypedefType); ok {\n+\t\t\tdt = t\n+\t\t\tcontinue\n+\t\t}\n+\t\tbreak\n+\t}\n+\treturn c.badPointerTypedef(dt)\n+}\n+\n func (c *typeConv) badCFType(dt *dwarf.TypedefType) bool {\n \t// The real bad types are CFNumberRef and CFDateRef.\n \t// Sometimes non-pointers are stored in these types.\n@@ -2781,13 +2880,31 @@ func (c *typeConv) badJNI(dt *dwarf.TypedefType) bool {\n \t\t\t}\n \t\t}\n \n-\t\t// Check that the typedef is:\n-\t\t//     struct _jobject;\n-\t\t//     typedef struct _jobject *jobject;\n+\t\t// Check that the typedef is either:\n+\t\t// 1:\n+\t\t//     \tstruct _jobject;\n+\t\t//     \ttypedef struct _jobject *jobject;\n+\t\t// 2: (in NDK16 in C++)\n+\t\t//     \tclass _jobject {};\n+\t\t//     \ttypedef _jobject* jobject;\n+\t\t// 3: (in NDK16 in C)\n+\t\t//     \ttypedef void* jobject;\n \t\tif ptr, ok := w.Type.(*dwarf.PtrType); ok {\n-\t\t\tif str, ok := ptr.Type.(*dwarf.StructType); ok {\n-\t\t\t\tif str.StructName == \"_jobject\" && str.Kind == \"struct\" && len(str.Field) == 0 && str.Incomplete {\n-\t\t\t\t\treturn true\n+\t\t\tswitch v := ptr.Type.(type) {\n+\t\t\tcase *dwarf.VoidType:\n+\t\t\t\treturn true\n+\t\t\tcase *dwarf.StructType:\n+\t\t\t\tif v.StructName == \"_jobject\" && len(v.Field) == 0 {\n+\t\t\t\t\tswitch v.Kind {\n+\t\t\t\t\tcase \"struct\":\n+\t\t\t\t\t\tif v.Incomplete {\n+\t\t\t\t\t\t\treturn true\n+\t\t\t\t\t\t}\n+\t\t\t\t\tcase \"class\":\n+\t\t\t\t\t\tif !v.Incomplete {\n+\t\t\t\t\t\t\treturn true\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -2796,7 +2913,7 @@ func (c *typeConv) badJNI(dt *dwarf.TypedefType) bool {\n }\n \n // jniTypes maps from JNI types that we want to be uintptrs, to the underlying type to which\n-// they are mapped.  The base \"jobject\" maps to the empty string.\n+// they are mapped. The base \"jobject\" maps to the empty string.\n var jniTypes = map[string]string{\n \t\"jobject\":       \"\",\n \t\"jclass\":        \"jobject\","}, {"sha": "6720945cdddbaf791a6b8df2ab2a9b62fa2177ba", "filename": "libgo/go/cmd/cgo/godefs.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -19,7 +19,7 @@ import (\n func (p *Package) godefs(f *File, srcfile string) string {\n \tvar buf bytes.Buffer\n \n-\tfmt.Fprintf(&buf, \"// Created by cgo -godefs - DO NOT EDIT\\n\")\n+\tfmt.Fprintf(&buf, \"// Code generated by cmd/cgo -godefs; DO NOT EDIT.\\n\")\n \tfmt.Fprintf(&buf, \"// %s %s\\n\", filepath.Base(os.Args[0]), strings.Join(os.Args[1:], \" \"))\n \tfmt.Fprintf(&buf, \"\\n\")\n "}, {"sha": "1238016418e527ecc311d8aaf8368a13abeb550c", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -17,6 +17,7 @@ import (\n \t\"go/ast\"\n \t\"go/printer\"\n \t\"go/token\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -42,9 +43,11 @@ type Package struct {\n \tName        map[string]*Name // accumulated Name from Files\n \tExpFunc     []*ExpFunc       // accumulated ExpFunc from Files\n \tDecl        []ast.Decl\n-\tGoFiles     []string // list of Go files\n-\tGccFiles    []string // list of gcc output files\n-\tPreamble    string   // collected preamble for _cgo_export.h\n+\tGoFiles     []string        // list of Go files\n+\tGccFiles    []string        // list of gcc output files\n+\tPreamble    string          // collected preamble for _cgo_export.h\n+\ttypedefs    map[string]bool // type names that appear in the types of the objects we're interested in\n+\ttypedefList []string\n }\n \n // A File collects information about a single Go input file.\n@@ -278,6 +281,9 @@ func main() {\n \t\tif arg == \"-fsanitize=thread\" {\n \t\t\ttsanProlog = yesTsanProlog\n \t\t}\n+\t\tif arg == \"-fsanitize=memory\" {\n+\t\t\tmsanProlog = yesMsanProlog\n+\t\t}\n \t}\n \n \tp := newPackage(args[:i])\n@@ -297,6 +303,7 @@ func main() {\n \t// concern is other cgo wrappers for the same functions.\n \t// Use the beginning of the md5 of the input to disambiguate.\n \th := md5.New()\n+\tio.WriteString(h, *importPath)\n \tfs := make([]*File, len(goFiles))\n \tfor i, input := range goFiles {\n \t\tif *srcDir != \"\" {\n@@ -410,6 +417,14 @@ func (p *Package) Record(f *File) {\n \t\tfor k, v := range f.Name {\n \t\t\tif p.Name[k] == nil {\n \t\t\t\tp.Name[k] = v\n+\t\t\t} else if p.incompleteTypedef(p.Name[k].Type) {\n+\t\t\t\tp.Name[k] = v\n+\t\t\t} else if p.incompleteTypedef(v.Type) {\n+\t\t\t\t// Nothing to do.\n+\t\t\t} else if _, ok := nameToC[k]; ok {\n+\t\t\t\t// Names we predefine may appear inconsistent\n+\t\t\t\t// if some files typedef them and some don't.\n+\t\t\t\t// Issue 26743.\n \t\t\t} else if !reflect.DeepEqual(p.Name[k], v) {\n \t\t\t\terror_(token.NoPos, \"inconsistent definitions for C.%s\", fixGo(k))\n \t\t\t}\n@@ -422,3 +437,9 @@ func (p *Package) Record(f *File) {\n \t}\n \tp.Decl = append(p.Decl, f.AST.Decls...)\n }\n+\n+// incompleteTypedef reports whether t appears to be an incomplete\n+// typedef definition.\n+func (p *Package) incompleteTypedef(t *Type) bool {\n+\treturn t == nil || (t.Size == 0 && t.Align == -1)\n+}"}, {"sha": "10d4b74b6eebe57a5cd7dd32610b47105ca74245", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -17,6 +17,7 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"regexp\"\n \t\"sort\"\n \t\"strings\"\n )\n@@ -78,7 +79,7 @@ func (p *Package) writeDefs() {\n \t// Write second Go output: definitions of _C_xxx.\n \t// In a separate file so that the import of \"unsafe\" does not\n \t// pollute the original file.\n-\tfmt.Fprintf(fgo2, \"// Created by cgo - DO NOT EDIT\\n\\n\")\n+\tfmt.Fprintf(fgo2, \"// Code generated by cmd/cgo; DO NOT EDIT.\\n\\n\")\n \tfmt.Fprintf(fgo2, \"package %s\\n\\n\", p.PackageName)\n \tfmt.Fprintf(fgo2, \"import \\\"unsafe\\\"\\n\\n\")\n \tif !*gccgo && *importRuntimeCgo {\n@@ -277,53 +278,38 @@ func dynimport(obj string) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tsym, err := f.ImportedSymbols()\n-\t\tif err != nil {\n-\t\t\tfatalf(\"cannot load imported symbols from ELF file %s: %v\", obj, err)\n-\t\t}\n+\t\tsym, _ := f.ImportedSymbols()\n \t\tfor _, s := range sym {\n \t\t\ttarg := s.Name\n \t\t\tif s.Version != \"\" {\n \t\t\t\ttarg += \"#\" + s.Version\n \t\t\t}\n \t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic %s %s %q\\n\", s.Name, targ, s.Library)\n \t\t}\n-\t\tlib, err := f.ImportedLibraries()\n-\t\tif err != nil {\n-\t\t\tfatalf(\"cannot load imported libraries from ELF file %s: %v\", obj, err)\n-\t\t}\n+\t\tlib, _ := f.ImportedLibraries()\n \t\tfor _, l := range lib {\n \t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic _ _ %q\\n\", l)\n \t\t}\n \t\treturn\n \t}\n \n \tif f, err := macho.Open(obj); err == nil {\n-\t\tsym, err := f.ImportedSymbols()\n-\t\tif err != nil {\n-\t\t\tfatalf(\"cannot load imported symbols from Mach-O file %s: %v\", obj, err)\n-\t\t}\n+\t\tsym, _ := f.ImportedSymbols()\n \t\tfor _, s := range sym {\n \t\t\tif len(s) > 0 && s[0] == '_' {\n \t\t\t\ts = s[1:]\n \t\t\t}\n \t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic %s %s %q\\n\", s, s, \"\")\n \t\t}\n-\t\tlib, err := f.ImportedLibraries()\n-\t\tif err != nil {\n-\t\t\tfatalf(\"cannot load imported libraries from Mach-O file %s: %v\", obj, err)\n-\t\t}\n+\t\tlib, _ := f.ImportedLibraries()\n \t\tfor _, l := range lib {\n \t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic _ _ %q\\n\", l)\n \t\t}\n \t\treturn\n \t}\n \n \tif f, err := pe.Open(obj); err == nil {\n-\t\tsym, err := f.ImportedSymbols()\n-\t\tif err != nil {\n-\t\t\tfatalf(\"cannot load imported symbols from PE file %s: %v\", obj, err)\n-\t\t}\n+\t\tsym, _ := f.ImportedSymbols()\n \t\tfor _, s := range sym {\n \t\t\tss := strings.Split(s, \":\")\n \t\t\tname := strings.Split(ss[0], \"@\")[0]\n@@ -559,8 +545,8 @@ func (p *Package) writeOutput(f *File, srcfile string) {\n \tp.GccFiles = append(p.GccFiles, base+\".cgo2.c\")\n \n \t// Write Go output: Go input with rewrites of C.xxx to _C_xxx.\n-\tfmt.Fprintf(fgo1, \"// Created by cgo - DO NOT EDIT\\n\\n\")\n-\tfmt.Fprintf(fgo1, \"//line %s:1\\n\", srcfile)\n+\tfmt.Fprintf(fgo1, \"// Code generated by cmd/cgo; DO NOT EDIT.\\n\\n\")\n+\tfmt.Fprintf(fgo1, \"//line %s:1:1\\n\", srcfile)\n \tfgo1.Write(f.Edit.Bytes())\n \n \t// While we process the vars and funcs, also write gcc output.\n@@ -569,6 +555,7 @@ func (p *Package) writeOutput(f *File, srcfile string) {\n \tfmt.Fprintf(fgcc, \"%s\\n\", f.Preamble)\n \tfmt.Fprintf(fgcc, \"%s\\n\", gccProlog)\n \tfmt.Fprintf(fgcc, \"%s\\n\", tsanProlog)\n+\tfmt.Fprintf(fgcc, \"%s\\n\", msanProlog)\n \n \tfor _, key := range nameKeys(f.Name) {\n \t\tn := f.Name[key]\n@@ -632,24 +619,24 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \t// We're trying to write a gcc struct that matches gc's layout.\n \t// Use packed attribute to force no padding in this struct in case\n \t// gcc has different packing requirements.\n-\tfmt.Fprintf(fgcc, \"\\t%s %v *a = v;\\n\", ctype, p.packedAttribute())\n+\tfmt.Fprintf(fgcc, \"\\t%s %v *_cgo_a = v;\\n\", ctype, p.packedAttribute())\n \tif n.FuncType.Result != nil {\n \t\t// Save the stack top for use below.\n-\t\tfmt.Fprintf(fgcc, \"\\tchar *stktop = _cgo_topofstack();\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\tchar *_cgo_stktop = _cgo_topofstack();\\n\")\n \t}\n \ttr := n.FuncType.Result\n \tif tr != nil {\n-\t\tfmt.Fprintf(fgcc, \"\\t__typeof__(a->r) r;\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\t__typeof__(_cgo_a->r) _cgo_r;\\n\")\n \t}\n \tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_acquire();\\n\")\n \tif n.AddError {\n \t\tfmt.Fprintf(fgcc, \"\\terrno = 0;\\n\")\n \t}\n \tfmt.Fprintf(fgcc, \"\\t\")\n \tif tr != nil {\n-\t\tfmt.Fprintf(fgcc, \"r = \")\n+\t\tfmt.Fprintf(fgcc, \"_cgo_r = \")\n \t\tif c := tr.C.String(); c[len(c)-1] == '*' {\n-\t\t\tfmt.Fprint(fgcc, \"(__typeof__(a->r)) \")\n+\t\t\tfmt.Fprint(fgcc, \"(__typeof__(_cgo_a->r)) \")\n \t\t}\n \t}\n \tif n.Kind == \"macro\" {\n@@ -660,7 +647,7 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \t\t\tif i > 0 {\n \t\t\t\tfmt.Fprintf(fgcc, \", \")\n \t\t\t}\n-\t\t\tfmt.Fprintf(fgcc, \"a->p%d\", i)\n+\t\t\tfmt.Fprintf(fgcc, \"_cgo_a->p%d\", i)\n \t\t}\n \t\tfmt.Fprintf(fgcc, \");\\n\")\n \t}\n@@ -671,9 +658,19 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \tif n.FuncType.Result != nil {\n \t\t// The cgo call may have caused a stack copy (via a callback).\n \t\t// Adjust the return value pointer appropriately.\n-\t\tfmt.Fprintf(fgcc, \"\\ta = (void*)((char*)a + (_cgo_topofstack() - stktop));\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\t_cgo_a = (void*)((char*)_cgo_a + (_cgo_topofstack() - _cgo_stktop));\\n\")\n \t\t// Save the return value.\n-\t\tfmt.Fprintf(fgcc, \"\\ta->r = r;\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\t_cgo_a->r = _cgo_r;\\n\")\n+\t\t// The return value is on the Go stack. If we are using msan,\n+\t\t// and if the C value is partially or completely uninitialized,\n+\t\t// the assignment will mark the Go stack as uninitialized.\n+\t\t// The Go compiler does not update msan for changes to the\n+\t\t// stack. It is possible that the stack will remain\n+\t\t// uninitialized, and then later be used in a way that is\n+\t\t// visible to msan, possibly leading to a false positive.\n+\t\t// Mark the stack space as written, to avoid this problem.\n+\t\t// See issue 26209.\n+\t\tfmt.Fprintf(fgcc, \"\\t_cgo_msan_write(&_cgo_a->r, sizeof(_cgo_a->r));\\n\")\n \t}\n \tif n.AddError {\n \t\tfmt.Fprintf(fgcc, \"\\treturn _cgo_errno;\\n\")\n@@ -708,12 +705,12 @@ func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name) {\n \tfmt.Fprintf(fgcc, \")\\n\")\n \tfmt.Fprintf(fgcc, \"{\\n\")\n \tif t := n.FuncType.Result; t != nil {\n-\t\tfmt.Fprintf(fgcc, \"\\t%s r;\\n\", t.C.String())\n+\t\tfmt.Fprintf(fgcc, \"\\t%s _cgo_r;\\n\", t.C.String())\n \t}\n \tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_acquire();\\n\")\n \tfmt.Fprintf(fgcc, \"\\t\")\n \tif t := n.FuncType.Result; t != nil {\n-\t\tfmt.Fprintf(fgcc, \"r = \")\n+\t\tfmt.Fprintf(fgcc, \"_cgo_r = \")\n \t\t// Cast to void* to avoid warnings due to omitted qualifiers.\n \t\tif c := t.C.String(); c[len(c)-1] == '*' {\n \t\t\tfmt.Fprintf(fgcc, \"(void*)\")\n@@ -739,7 +736,7 @@ func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name) {\n \t\tif c := t.C.String(); c[len(c)-1] == '*' {\n \t\t\tfmt.Fprintf(fgcc, \"(void*)\")\n \t\t}\n-\t\tfmt.Fprintf(fgcc, \"r;\\n\")\n+\t\tfmt.Fprintf(fgcc, \"_cgo_r;\\n\")\n \t}\n \tfmt.Fprintf(fgcc, \"}\\n\")\n \tfmt.Fprintf(fgcc, \"\\n\")\n@@ -748,7 +745,7 @@ func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name) {\n // packedAttribute returns host compiler struct attribute that will be\n // used to match gc's struct layout. For example, on 386 Windows,\n // gcc wants to 8-align int64s, but gc does not.\n-// Use __gcc_struct__ to work around http://gcc.gnu.org/PR52991 on x86,\n+// Use __gcc_struct__ to work around https://gcc.gnu.org/PR52991 on x86,\n // and https://golang.org/issue/5603.\n func (p *Package) packedAttribute() string {\n \ts := \"__attribute__((__packed__\"\n@@ -763,7 +760,7 @@ func (p *Package) packedAttribute() string {\n func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \tp.writeExportHeader(fgcch)\n \n-\tfmt.Fprintf(fgcc, \"/* Created by cgo - DO NOT EDIT. */\\n\")\n+\tfmt.Fprintf(fgcc, \"/* Code generated by cmd/cgo; DO NOT EDIT. */\\n\\n\")\n \tfmt.Fprintf(fgcc, \"#include <stdlib.h>\\n\")\n \tfmt.Fprintf(fgcc, \"#include \\\"_cgo_export.h\\\"\\n\\n\")\n \n@@ -772,6 +769,7 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \tfmt.Fprintf(fgcc, \"extern void _cgo_release_context(__SIZE_TYPE__);\\n\\n\")\n \tfmt.Fprintf(fgcc, \"extern char* _cgo_topofstack(void);\")\n \tfmt.Fprintf(fgcc, \"%s\\n\", tsanProlog)\n+\tfmt.Fprintf(fgcc, \"%s\\n\", msanProlog)\n \n \tfor _, exp := range p.ExpFunc {\n \t\tfn := exp.Func\n@@ -1004,11 +1002,12 @@ func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \n \tp.writeExportHeader(fgcch)\n \n-\tfmt.Fprintf(fgcc, \"/* Created by cgo - DO NOT EDIT. */\\n\")\n+\tfmt.Fprintf(fgcc, \"/* Code generated by cmd/cgo; DO NOT EDIT. */\\n\\n\")\n \tfmt.Fprintf(fgcc, \"#include \\\"_cgo_export.h\\\"\\n\")\n \n \tfmt.Fprintf(fgcc, \"%s\\n\", gccgoExportFileProlog)\n \tfmt.Fprintf(fgcc, \"%s\\n\", tsanProlog)\n+\tfmt.Fprintf(fgcc, \"%s\\n\", msanProlog)\n \n \tfor _, exp := range p.ExpFunc {\n \t\tfn := exp.Func\n@@ -1170,16 +1169,23 @@ func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \n // writeExportHeader writes out the start of the _cgo_export.h file.\n func (p *Package) writeExportHeader(fgcch io.Writer) {\n-\tfmt.Fprintf(fgcch, \"/* Created by \\\"go tool cgo\\\" - DO NOT EDIT. */\\n\\n\")\n+\tfmt.Fprintf(fgcch, \"/* Code generated by cmd/cgo; DO NOT EDIT. */\\n\\n\")\n \tpkg := *importPath\n \tif pkg == \"\" {\n \t\tpkg = p.PackagePath\n \t}\n \tfmt.Fprintf(fgcch, \"/* package %s */\\n\\n\", pkg)\n \tfmt.Fprintf(fgcch, \"%s\\n\", builtinExportProlog)\n \n+\t// Remove absolute paths from #line comments in the preamble.\n+\t// They aren't useful for people using the header file,\n+\t// and they mean that the header files change based on the\n+\t// exact location of GOPATH.\n+\tre := regexp.MustCompile(`(?m)^(#line\\s+[0-9]+\\s+\")[^\"]*[/\\\\]([^\"]*\")`)\n+\tpreamble := re.ReplaceAllString(p.Preamble, \"$1$2\")\n+\n \tfmt.Fprintf(fgcch, \"/* Start of preamble from import \\\"C\\\" comments.  */\\n\\n\")\n-\tfmt.Fprintf(fgcch, \"%s\\n\", p.Preamble)\n+\tfmt.Fprintf(fgcch, \"%s\\n\", preamble)\n \tfmt.Fprintf(fgcch, \"\\n/* End of preamble from import \\\"C\\\" comments.  */\\n\\n\")\n \n \tfmt.Fprintf(fgcch, \"%s\\n\", p.gccExportHeaderProlog())\n@@ -1414,6 +1420,25 @@ static void _cgo_tsan_release() {\n // Set to yesTsanProlog if we see -fsanitize=thread in the flags for gcc.\n var tsanProlog = noTsanProlog\n \n+// noMsanProlog is a prologue defining an MSAN function in C.\n+// This is used when not compiling with -fsanitize=memory.\n+const noMsanProlog = `\n+#define _cgo_msan_write(addr, sz)\n+`\n+\n+// yesMsanProlog is a prologue defining an MSAN function in C.\n+// This is used when compiling with -fsanitize=memory.\n+// See the comment above where _cgo_msan_write is called.\n+const yesMsanProlog = `\n+extern void __msan_unpoison(const volatile void *, size_t);\n+\n+#define _cgo_msan_write(addr, sz) __msan_unpoison((addr), (sz))\n+`\n+\n+// msanProlog is set to yesMsanProlog if we see -fsanitize=memory in the flags\n+// for the C compiler.\n+var msanProlog = noMsanProlog\n+\n const builtinProlog = `\n #line 1 \"cgo-builtin-prolog\"\n #include <stddef.h> /* for ptrdiff_t and size_t below */"}, {"sha": "921306b7aabf653c5d60c04aaee505c8d86bb75d", "filename": "libgo/go/cmd/cgo/util.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -59,6 +59,8 @@ func run(stdin []byte, argv []string) (stdout, stderr []byte, ok bool) {\n \tvar bout, berr bytes.Buffer\n \tp.Stdout = &bout\n \tp.Stderr = &berr\n+\t// Disable escape codes in clang error messages.\n+\tp.Env = append(os.Environ(), \"TERM=dumb\")\n \terr := p.Run()\n \tif _, ok := err.(*exec.ExitError); err != nil && !ok {\n \t\tfatalf(\"%s\", err)\n@@ -97,6 +99,8 @@ func error_(pos token.Pos, msg string, args ...interface{}) {\n \tnerrors++\n \tif pos.IsValid() {\n \t\tfmt.Fprintf(os.Stderr, \"%s: \", fset.Position(pos).String())\n+\t} else {\n+\t\tfmt.Fprintf(os.Stderr, \"cgo: \")\n \t}\n \tfmt.Fprintf(os.Stderr, msg, args...)\n \tfmt.Fprintf(os.Stderr, \"\\n\")"}, {"sha": "ebbd154f3e6ffd647a2013f7c9c4912527e10d5c", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 1281, "deletions": 199, "changes": 1480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -2,50 +2,66 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// DO NOT EDIT THIS FILE. GENERATED BY mkalldocs.sh.\n+// Code generated by mkalldocs.sh; DO NOT EDIT.\n // Edit the documentation in other files and rerun mkalldocs.sh to generate this one.\n \n // Go is a tool for managing Go source code.\n //\n // Usage:\n //\n-// \tgo command [arguments]\n+// \tgo <command> [arguments]\n //\n // The commands are:\n //\n+// \tbug         start a bug report\n // \tbuild       compile packages and dependencies\n // \tclean       remove object files and cached files\n // \tdoc         show documentation for package or symbol\n // \tenv         print Go environment information\n-// \tbug         start a bug report\n // \tfix         update packages to use new APIs\n // \tfmt         gofmt (reformat) package sources\n // \tgenerate    generate Go files by processing source\n // \tget         download and install packages and dependencies\n // \tinstall     compile and install packages and dependencies\n-// \tlist        list packages\n+// \tlist        list packages or modules\n+// \tmod         module maintenance\n // \trun         compile and run Go program\n // \ttest        test packages\n // \ttool        run specified go tool\n // \tversion     print Go version\n // \tvet         report likely mistakes in packages\n //\n-// Use \"go help [command]\" for more information about a command.\n+// Use \"go help <command>\" for more information about a command.\n //\n // Additional help topics:\n //\n-// \tc           calling between Go and C\n // \tbuildmode   build modes\n+// \tc           calling between Go and C\n // \tcache       build and test caching\n+// \tenvironment environment variables\n // \tfiletype    file types\n+// \tgo.mod      the go.mod file\n // \tgopath      GOPATH environment variable\n-// \tenvironment environment variables\n+// \tgopath-get  legacy GOPATH go get\n+// \tgoproxy     module proxy protocol\n // \timportpath  import path syntax\n-// \tpackages    package lists\n+// \tmodules     modules, module versions, and more\n+// \tmodule-get  module-aware go get\n+// \tpackages    package lists and patterns\n // \ttestflag    testing flags\n // \ttestfunc    testing functions\n //\n-// Use \"go help [topic]\" for more information about that topic.\n+// Use \"go help <topic>\" for more information about that topic.\n+//\n+//\n+// Start a bug report\n+//\n+// Usage:\n+//\n+// \tgo bug\n+//\n+// Bug opens the default browser and starts a new bug report.\n+// The report includes useful system information.\n //\n //\n // Compile packages and dependencies\n@@ -95,7 +111,7 @@\n // \t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.\n // \t-msan\n // \t\tenable interoperation with memory sanitizer.\n-// \t\tSupported only on linux/amd64,\n+// \t\tSupported only on linux/amd64, linux/arm64\n // \t\tand only with Clang/LLVM as the host C compiler.\n // \t-v\n // \t\tprint the names of packages as they are compiled.\n@@ -127,6 +143,9 @@\n // \t-linkshared\n // \t\tlink against shared libraries previously created with\n // \t\t-buildmode=shared.\n+// \t-mod mode\n+// \t\tmodule download mode to use: readonly, release, or vendor.\n+// \t\tSee 'go help modules' for more.\n // \t-pkgdir dir\n // \t\tinstall and load all packages from dir instead of the usual locations.\n // \t\tFor example, when building with a non-standard configuration,\n@@ -175,7 +194,7 @@\n //\n // Usage:\n //\n-// \tgo clean [-i] [-r] [-n] [-x] [-cache] [-testcache] [build flags] [packages]\n+// \tgo clean [clean flags] [build flags] [packages]\n //\n // Clean removes object files from package source directories.\n // The go command builds most objects in a temporary directory,\n@@ -218,6 +237,10 @@\n // The -testcache flag causes clean to expire all test results in the\n // go build cache.\n //\n+// The -modcache flag causes clean to remove the entire module\n+// download cache, including unpacked source code of versioned\n+// dependencies.\n+//\n // For more about build flags, see 'go help build'.\n //\n // For more about specifying packages, see 'go help packages'.\n@@ -349,16 +372,6 @@\n // For more about environment variables, see 'go help environment'.\n //\n //\n-// Start a bug report\n-//\n-// Usage:\n-//\n-// \tgo bug\n-//\n-// Bug opens the default browser and starts a new bug report.\n-// The report includes useful system information.\n-//\n-//\n // Update packages to use new APIs\n //\n // Usage:\n@@ -419,6 +432,12 @@\n // (gofmt), a fully qualified path (/usr/you/bin/mytool), or a\n // command alias, described below.\n //\n+// To convey to humans and machine tools that code is generated,\n+// generated source should have a line early in the file that\n+// matches the following regular expression (in Go syntax):\n+//\n+// \t^// Code generated .* DO NOT EDIT\\.$\n+//\n // Note that go generate does not parse the file, so lines that look\n // like directives in comments or multiline strings will be treated\n // as directives.\n@@ -506,7 +525,7 @@\n //\n // Usage:\n //\n-// \tgo get [-d] [-f] [-fix] [-insecure] [-t] [-u] [-v] [build flags] [packages]\n+// \tgo get [-d] [-f] [-t] [-u] [-v] [-fix] [-insecure] [build flags] [packages]\n //\n // Get downloads the packages named by the import paths, along with their\n // dependencies. It then installs the named packages, like 'go install'.\n@@ -556,6 +575,12 @@\n // For more about how 'go get' finds source code to\n // download, see 'go help importpath'.\n //\n+// This text describes the behavior of get when using GOPATH\n+// to manage source code and dependencies.\n+// If instead the go command is running in module-aware mode,\n+// the details of get's flags and effects change, as does 'go help get'.\n+// See 'go help modules' and 'go help module-get'.\n+//\n // See also: go build, go install, go clean.\n //\n //\n@@ -575,13 +600,16 @@\n // See also: go build, go get, go clean.\n //\n //\n-// List packages\n+// List packages or modules\n //\n // Usage:\n //\n-// \tgo list [-e] [-f format] [-json] [build flags] [packages]\n+// \tgo list [-f format] [-json] [-m] [list flags] [build flags] [packages]\n //\n-// List lists the packages named by the import paths, one per line.\n+// List lists the named packages, one per line.\n+// The most commonly-used flags are -f and -json, which control the form\n+// of the output printed for each package. Other list flags, documented below,\n+// control more specific details.\n //\n // The default output shows the package import path:\n //\n@@ -591,40 +619,46 @@\n //     golang.org/x/net/html\n //\n // The -f flag specifies an alternate format for the list, using the\n-// syntax of package template. The default output is equivalent to -f\n-// '{{.ImportPath}}'. The struct being passed to the template is:\n+// syntax of package template. The default output is equivalent\n+// to -f '{{.ImportPath}}'. The struct being passed to the template is:\n //\n //     type Package struct {\n-//         Dir           string // directory containing package sources\n-//         ImportPath    string // import path of package in dir\n-//         ImportComment string // path in import comment on package statement\n-//         Name          string // package name\n-//         Doc           string // package documentation string\n-//         Target        string // install path\n-//         Shlib         string // the shared library that contains this package (only set when -linkshared)\n-//         Goroot        bool   // is this package in the Go root?\n-//         Standard      bool   // is this package part of the standard Go library?\n-//         Stale         bool   // would 'go install' do anything for this package?\n-//         StaleReason   string // explanation for Stale==true\n-//         Root          string // Go root or Go path dir containing this package\n-//         ConflictDir   string // this directory shadows Dir in $GOPATH\n-//         BinaryOnly    bool   // binary-only package: cannot be recompiled from sources\n+//         Dir           string   // directory containing package sources\n+//         ImportPath    string   // import path of package in dir\n+//         ImportComment string   // path in import comment on package statement\n+//         Name          string   // package name\n+//         Doc           string   // package documentation string\n+//         Target        string   // install path\n+//         Shlib         string   // the shared library that contains this package (only set when -linkshared)\n+//         Goroot        bool     // is this package in the Go root?\n+//         Standard      bool     // is this package part of the standard Go library?\n+//         Stale         bool     // would 'go install' do anything for this package?\n+//         StaleReason   string   // explanation for Stale==true\n+//         Root          string   // Go root or Go path dir containing this package\n+//         ConflictDir   string   // this directory shadows Dir in $GOPATH\n+//         BinaryOnly    bool     // binary-only package: cannot be recompiled from sources\n+//         ForTest       string   // package is only for use in named test\n+//         Export        string   // file containing export data (when using -export)\n+//         Module        *Module  // info about package's containing module, if any (can be nil)\n+//         Match         []string // command-line patterns matching this package\n+//         DepOnly       bool     // package is only a dependency, not explicitly listed\n //\n //         // Source files\n-//         GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n-//         CgoFiles       []string // .go sources files that import \"C\"\n-//         IgnoredGoFiles []string // .go sources ignored due to build constraints\n-//         CFiles         []string // .c source files\n-//         CXXFiles       []string // .cc, .cxx and .cpp source files\n-//         MFiles         []string // .m source files\n-//         HFiles         []string // .h, .hh, .hpp and .hxx source files\n-//         FFiles         []string // .f, .F, .for and .f90 Fortran source files\n-//         SFiles         []string // .s source files\n-//         SwigFiles      []string // .swig files\n-//         SwigCXXFiles   []string // .swigcxx files\n-//         SysoFiles      []string // .syso object files to add to archive\n-//         TestGoFiles    []string // _test.go files in package\n-//         XTestGoFiles   []string // _test.go files outside package\n+//         GoFiles         []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+//         CgoFiles        []string // .go source files that import \"C\"\n+//         CompiledGoFiles []string // .go files presented to compiler (when using -compiled)\n+//         IgnoredGoFiles  []string // .go source files ignored due to build constraints\n+//         CFiles          []string // .c source files\n+//         CXXFiles        []string // .cc, .cxx and .cpp source files\n+//         MFiles          []string // .m source files\n+//         HFiles          []string // .h, .hh, .hpp and .hxx source files\n+//         FFiles          []string // .f, .F, .for and .f90 Fortran source files\n+//         SFiles          []string // .s source files\n+//         SwigFiles       []string // .swig files\n+//         SwigCXXFiles    []string // .swigcxx files\n+//         SysoFiles       []string // .syso object files to add to archive\n+//         TestGoFiles     []string // _test.go files in package\n+//         XTestGoFiles    []string // _test.go files outside package\n //\n //         // Cgo directives\n //         CgoCFLAGS    []string // cgo: flags for C compiler\n@@ -635,10 +669,11 @@\n //         CgoPkgConfig []string // cgo: pkg-config names\n //\n //         // Dependency information\n-//         Imports      []string // import paths used by this package\n-//         Deps         []string // all (recursively) imported dependencies\n-//         TestImports  []string // imports from TestGoFiles\n-//         XTestImports []string // imports from XTestGoFiles\n+//         Imports      []string          // import paths used by this package\n+//         ImportMap    map[string]string // map from source import to ImportPath (identity entries omitted)\n+//         Deps         []string          // all (recursively) imported dependencies\n+//         TestImports  []string          // imports from TestGoFiles\n+//         XTestImports []string          // imports from XTestGoFiles\n //\n //         // Error information\n //         Incomplete bool            // this package or a dependency has an error\n@@ -650,7 +685,7 @@\n // path to the vendor directory (for example, \"d/vendor/p\" instead of \"p\"),\n // so that the ImportPath uniquely identifies a given copy of a package.\n // The Imports, Deps, TestImports, and XTestImports lists also contain these\n-// expanded imports paths. See golang.org/s/go15vendor for more about vendoring.\n+// expanded import paths. See golang.org/s/go15vendor for more about vendoring.\n //\n // The error information, if any, is\n //\n@@ -660,29 +695,44 @@\n //         Err           string   // the error itself\n //     }\n //\n+// The module information is a Module struct, defined in the discussion\n+// of list -m below.\n+//\n // The template function \"join\" calls strings.Join.\n //\n // The template function \"context\" returns the build context, defined as:\n //\n-// \ttype Context struct {\n-// \t\tGOARCH        string   // target architecture\n-// \t\tGOOS          string   // target operating system\n-// \t\tGOROOT        string   // Go root\n-// \t\tGOPATH        string   // Go path\n-// \t\tCgoEnabled    bool     // whether cgo can be used\n-// \t\tUseAllFiles   bool     // use files regardless of +build lines, file names\n-// \t\tCompiler      string   // compiler to assume when computing target paths\n-// \t\tBuildTags     []string // build constraints to match in +build lines\n-// \t\tReleaseTags   []string // releases the current release is compatible with\n-// \t\tInstallSuffix string   // suffix to use in the name of the install dir\n-// \t}\n+//     type Context struct {\n+//         GOARCH        string   // target architecture\n+//         GOOS          string   // target operating system\n+//         GOROOT        string   // Go root\n+//         GOPATH        string   // Go path\n+//         CgoEnabled    bool     // whether cgo can be used\n+//         UseAllFiles   bool     // use files regardless of +build lines, file names\n+//         Compiler      string   // compiler to assume when computing target paths\n+//         BuildTags     []string // build constraints to match in +build lines\n+//         ReleaseTags   []string // releases the current release is compatible with\n+//         InstallSuffix string   // suffix to use in the name of the install dir\n+//     }\n //\n // For more information about the meaning of these fields see the documentation\n // for the go/build package's Context type.\n //\n // The -json flag causes the package data to be printed in JSON format\n // instead of using the template format.\n //\n+// The -compiled flag causes list to set CompiledGoFiles to the Go source\n+// files presented to the compiler. Typically this means that it repeats\n+// the files listed in GoFiles and then also adds the Go code generated\n+// by processing CgoFiles and SwigFiles. The Imports list contains the\n+// union of all imports from both GoFiles and CompiledGoFiles.\n+//\n+// The -deps flag causes list to iterate over not just the named packages\n+// but also all their dependencies. It visits them in a depth-first post-order\n+// traversal, so that a package is listed only after all its dependencies.\n+// Packages not explicitly listed on the command line will have the DepOnly\n+// field set to true.\n+//\n // The -e flag changes the handling of erroneous packages, those that\n // cannot be found or are malformed. By default, the list command\n // prints an error to standard error for each erroneous package and\n@@ -693,19 +743,380 @@\n // a non-nil Error field; other information may or may not be missing\n // (zeroed).\n //\n+// The -export flag causes list to set the Export field to the name of a\n+// file containing up-to-date export information for the given package.\n+//\n+// The -find flag causes list to identify the named packages but not\n+// resolve their dependencies: the Imports and Deps lists will be empty.\n+//\n+// The -test flag causes list to report not only the named packages\n+// but also their test binaries (for packages with tests), to convey to\n+// source code analysis tools exactly how test binaries are constructed.\n+// The reported import path for a test binary is the import path of\n+// the package followed by a \".test\" suffix, as in \"math/rand.test\".\n+// When building a test, it is sometimes necessary to rebuild certain\n+// dependencies specially for that test (most commonly the tested\n+// package itself). The reported import path of a package recompiled\n+// for a particular test binary is followed by a space and the name of\n+// the test binary in brackets, as in \"math/rand [math/rand.test]\"\n+// or \"regexp [sort.test]\". The ForTest field is also set to the name\n+// of the package being tested (\"math/rand\" or \"sort\" in the previous\n+// examples).\n+//\n+// The Dir, Target, Shlib, Root, ConflictDir, and Export file paths\n+// are all absolute paths.\n+//\n+// By default, the lists GoFiles, CgoFiles, and so on hold names of files in Dir\n+// (that is, paths relative to Dir, not absolute paths).\n+// The generated files added when using the -compiled and -test flags\n+// are absolute paths referring to cached copies of generated Go source files.\n+// Although they are Go source files, the paths may not end in \".go\".\n+//\n+// The -m flag causes list to list modules instead of packages.\n+//\n+// When listing modules, the -f flag still specifies a format template\n+// applied to a Go struct, but now a Module struct:\n+//\n+//     type Module struct {\n+//         Path     string       // module path\n+//         Version  string       // module version\n+//         Versions []string     // available module versions (with -versions)\n+//         Replace  *Module      // replaced by this module\n+//         Time     *time.Time   // time version was created\n+//         Update   *Module      // available update, if any (with -u)\n+//         Main     bool         // is this the main module?\n+//         Indirect bool         // is this module only an indirect dependency of main module?\n+//         Dir      string       // directory holding files for this module, if any\n+//         GoMod    string       // path to go.mod file for this module, if any\n+//         Error    *ModuleError // error loading module\n+//     }\n+//\n+//     type ModuleError struct {\n+//         Err string // the error itself\n+//     }\n+//\n+// The default output is to print the module path and then\n+// information about the version and replacement if any.\n+// For example, 'go list -m all' might print:\n+//\n+//     my/main/module\n+//     golang.org/x/text v0.3.0 => /tmp/text\n+//     rsc.io/pdf v0.1.1\n+//\n+// The Module struct has a String method that formats this\n+// line of output, so that the default format is equivalent\n+// to -f '{{.String}}'.\n+//\n+// Note that when a module has been replaced, its Replace field\n+// describes the replacement module, and its Dir field is set to\n+// the replacement's source code, if present. (That is, if Replace\n+// is non-nil, then Dir is set to Replace.Dir, with no access to\n+// the replaced source code.)\n+//\n+// The -u flag adds information about available upgrades.\n+// When the latest version of a given module is newer than\n+// the current one, list -u sets the Module's Update field\n+// to information about the newer module.\n+// The Module's String method indicates an available upgrade by\n+// formatting the newer version in brackets after the current version.\n+// For example, 'go list -m -u all' might print:\n+//\n+//     my/main/module\n+//     golang.org/x/text v0.3.0 [v0.4.0] => /tmp/text\n+//     rsc.io/pdf v0.1.1 [v0.1.2]\n+//\n+// (For tools, 'go list -m -u -json all' may be more convenient to parse.)\n+//\n+// The -versions flag causes list to set the Module's Versions field\n+// to a list of all known versions of that module, ordered according\n+// to semantic versioning, earliest to latest. The flag also changes\n+// the default output format to display the module path followed by the\n+// space-separated version list.\n+//\n+// The arguments to list -m are interpreted as a list of modules, not packages.\n+// The main module is the module containing the current directory.\n+// The active modules are the main module and its dependencies.\n+// With no arguments, list -m shows the main module.\n+// With arguments, list -m shows the modules specified by the arguments.\n+// Any of the active modules can be specified by its module path.\n+// The special pattern \"all\" specifies all the active modules, first the main\n+// module and then dependencies sorted by module path.\n+// A pattern containing \"...\" specifies the active modules whose\n+// module paths match the pattern.\n+// A query of the form path@version specifies the result of that query,\n+// which is not limited to active modules.\n+// See 'go help modules' for more about module queries.\n+//\n+// The template function \"module\" takes a single string argument\n+// that must be a module path or query and returns the specified\n+// module as a Module struct. If an error occurs, the result will\n+// be a Module struct with a non-nil Error field.\n+//\n // For more about build flags, see 'go help build'.\n //\n // For more about specifying packages, see 'go help packages'.\n //\n+// For more about modules, see 'go help modules'.\n+//\n+//\n+// Module maintenance\n+//\n+// Go mod provides access to operations on modules.\n+//\n+// Note that support for modules is built into all the go commands,\n+// not just 'go mod'. For example, day-to-day adding, removing, upgrading,\n+// and downgrading of dependencies should be done using 'go get'.\n+// See 'go help modules' for an overview of module functionality.\n+//\n+// Usage:\n+//\n+// \tgo mod <command> [arguments]\n+//\n+// The commands are:\n+//\n+// \tdownload    download modules to local cache\n+// \tedit        edit go.mod from tools or scripts\n+// \tgraph       print module requirement graph\n+// \tinit        initialize new module in current directory\n+// \ttidy        add missing and remove unused modules\n+// \tvendor      make vendored copy of dependencies\n+// \tverify      verify dependencies have expected content\n+// \twhy         explain why packages or modules are needed\n+//\n+// Use \"go help mod <command>\" for more information about a command.\n+//\n+// Download modules to local cache\n+//\n+// Usage:\n+//\n+// \tgo mod download [-dir] [-json] [modules]\n+//\n+// Download downloads the named modules, which can be module patterns selecting\n+// dependencies of the main module or module queries of the form path@version.\n+// With no arguments, download applies to all dependencies of the main module.\n+//\n+// The go command will automatically download modules as needed during ordinary\n+// execution. The \"go mod download\" command is useful mainly for pre-filling\n+// the local cache or to compute the answers for a Go module proxy.\n+//\n+// By default, download reports errors to standard error but is otherwise silent.\n+// The -json flag causes download to print a sequence of JSON objects\n+// to standard output, describing each downloaded module (or failure),\n+// corresponding to this Go struct:\n+//\n+//     type Module struct {\n+//         Path     string // module path\n+//         Version  string // module version\n+//         Error    string // error loading module\n+//         Info     string // absolute path to cached .info file\n+//         GoMod    string // absolute path to cached .mod file\n+//         Zip      string // absolute path to cached .zip file\n+//         Dir      string // absolute path to cached source root directory\n+//         Sum      string // checksum for path, version (as in go.sum)\n+//         GoModSum string // checksum for go.mod (as in go.sum)\n+//     }\n+//\n+// See 'go help modules' for more about module queries.\n+//\n+//\n+// Edit go.mod from tools or scripts\n+//\n+// Usage:\n+//\n+// \tgo mod edit [editing flags] [go.mod]\n+//\n+// Edit provides a command-line interface for editing go.mod,\n+// for use primarily by tools or scripts. It reads only go.mod;\n+// it does not look up information about the modules involved.\n+// By default, edit reads and writes the go.mod file of the main module,\n+// but a different target file can be specified after the editing flags.\n+//\n+// The editing flags specify a sequence of editing operations.\n+//\n+// The -fmt flag reformats the go.mod file without making other changes.\n+// This reformatting is also implied by any other modifications that use or\n+// rewrite the go.mod file. The only time this flag is needed is if no other\n+// flags are specified, as in 'go mod edit -fmt'.\n+//\n+// The -module flag changes the module's path (the go.mod file's module line).\n+//\n+// The -require=path@version and -droprequire=path flags\n+// add and drop a requirement on the given module path and version.\n+// Note that -require overrides any existing requirements on path.\n+// These flags are mainly for tools that understand the module graph.\n+// Users should prefer 'go get path@version' or 'go get path@none',\n+// which make other go.mod adjustments as needed to satisfy\n+// constraints imposed by other modules.\n+//\n+// The -exclude=path@version and -dropexclude=path@version flags\n+// add and drop an exclusion for the given module path and version.\n+// Note that -exclude=path@version is a no-op if that exclusion already exists.\n+//\n+// The -replace=old[@v]=new[@v] and -dropreplace=old[@v] flags\n+// add and drop a replacement of the given module path and version pair.\n+// If the @v in old@v is omitted, the replacement applies to all versions\n+// with the old module path. If the @v in new@v is omitted, the new path\n+// should be a local module root directory, not a module path.\n+// Note that -replace overrides any existing replacements for old[@v].\n+//\n+// The -require, -droprequire, -exclude, -dropexclude, -replace,\n+// and -dropreplace editing flags may be repeated, and the changes\n+// are applied in the order given.\n+//\n+// The -print flag prints the final go.mod in its text format instead of\n+// writing it back to go.mod.\n+//\n+// The -json flag prints the final go.mod file in JSON format instead of\n+// writing it back to go.mod. The JSON output corresponds to these Go types:\n+//\n+// \ttype Module struct {\n+// \t\tPath string\n+// \t\tVersion string\n+// \t}\n+//\n+// \ttype GoMod struct {\n+// \t\tModule Module\n+// \t\tRequire []Require\n+// \t\tExclude []Module\n+// \t\tReplace []Replace\n+// \t}\n+//\n+// \ttype Require struct {\n+// \t\tPath string\n+// \t\tVersion string\n+// \t\tIndirect bool\n+// \t}\n+//\n+// \ttype Replace struct {\n+// \t\tOld Module\n+// \t\tNew Module\n+// \t}\n+//\n+// Note that this only describes the go.mod file itself, not other modules\n+// referred to indirectly. For the full set of modules available to a build,\n+// use 'go list -m -json all'.\n+//\n+// For example, a tool can obtain the go.mod as a data structure by\n+// parsing the output of 'go mod edit -json' and can then make changes\n+// by invoking 'go mod edit' with -require, -exclude, and so on.\n+//\n+//\n+// Print module requirement graph\n+//\n+// Usage:\n+//\n+// \tgo mod graph\n+//\n+// Graph prints the module requirement graph (with replacements applied)\n+// in text form. Each line in the output has two space-separated fields: a module\n+// and one of its requirements. Each module is identified as a string of the form\n+// path@version, except for the main module, which has no @version suffix.\n+//\n+//\n+// Initialize new module in current directory\n+//\n+// Usage:\n+//\n+// \tgo mod init [module]\n+//\n+// Init initializes and writes a new go.mod to the current directory,\n+// in effect creating a new module rooted at the current directory.\n+// The file go.mod must not already exist.\n+// If possible, init will guess the module path from import comments\n+// (see 'go help importpath') or from version control configuration.\n+// To override this guess, supply the module path as an argument.\n+//\n+//\n+// Add missing and remove unused modules\n+//\n+// Usage:\n+//\n+// \tgo mod tidy [-v]\n+//\n+// Tidy makes sure go.mod matches the source code in the module.\n+// It adds any missing modules necessary to build the current module's\n+// packages and dependencies, and it removes unused modules that\n+// don't provide any relevant packages. It also adds any missing entries\n+// to go.sum and removes any unnecessary ones.\n+//\n+// The -v flag causes tidy to print information about removed modules\n+// to standard error.\n+//\n+//\n+// Make vendored copy of dependencies\n+//\n+// Usage:\n+//\n+// \tgo mod vendor [-v]\n+//\n+// Vendor resets the main module's vendor directory to include all packages\n+// needed to build and test all the main module's packages.\n+// It does not include test code for vendored packages.\n+//\n+// The -v flag causes vendor to print the names of vendored\n+// modules and packages to standard error.\n+//\n+//\n+// Verify dependencies have expected content\n+//\n+// Usage:\n+//\n+// \tgo mod verify\n+//\n+// Verify checks that the dependencies of the current module,\n+// which are stored in a local downloaded source cache, have not been\n+// modified since being downloaded. If all the modules are unmodified,\n+// verify prints \"all modules verified.\" Otherwise it reports which\n+// modules have been changed and causes 'go mod' to exit with a\n+// non-zero status.\n+//\n+//\n+// Explain why packages or modules are needed\n+//\n+// Usage:\n+//\n+// \tgo mod why [-m] [-vendor] packages...\n+//\n+// Why shows a shortest path in the import graph from the main module to\n+// each of the listed packages. If the -m flag is given, why treats the\n+// arguments as a list of modules and finds a path to any package in each\n+// of the modules.\n+//\n+// By default, why queries the graph of packages matched by \"go list all\",\n+// which includes tests for reachable packages. The -vendor flag causes why\n+// to exclude tests of dependencies.\n+//\n+// The output is a sequence of stanzas, one for each package or module\n+// name on the command line, separated by blank lines. Each stanza begins\n+// with a comment line \"# package\" or \"# module\" giving the target\n+// package or module. Subsequent lines give a path through the import\n+// graph, one package per line. If the package or module is not\n+// referenced from the main module, the stanza will display a single\n+// parenthesized note indicating that fact.\n+//\n+// For example:\n+//\n+// \t$ go mod why golang.org/x/text/language golang.org/x/text/encoding\n+// \t# golang.org/x/text/language\n+// \trsc.io/quote\n+// \trsc.io/sampler\n+// \tgolang.org/x/text/language\n+//\n+// \t# golang.org/x/text/encoding\n+// \t(main module does not need package golang.org/x/text/encoding)\n+// \t$\n+//\n //\n // Compile and run Go program\n //\n // Usage:\n //\n-// \tgo run [build flags] [-exec xprog] gofiles... [arguments...]\n+// \tgo run [build flags] [-exec xprog] package [arguments...]\n //\n-// Run compiles and runs the main package comprising the named Go source files.\n-// A Go source file is defined to be a file ending in a literal \".go\" suffix.\n+// Run compiles and runs the named main Go package.\n+// Typically the package is specified as a list of .go source files,\n+// but it may also be an import path, file system path, or pattern\n+// matching a single known package, as in 'go run .' or 'go run my/cmd'.\n //\n // By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.\n // If the -exec flag is given, 'go run' invokes the binary using xprog:\n@@ -717,7 +1128,10 @@\n // cross-compiled programs when a simulator or other execution method is\n // available.\n //\n+// The exit status of Run is not the exit status of the compiled binary.\n+//\n // For more about build flags, see 'go help build'.\n+// For more about specifying packages, see 'go help packages'.\n //\n // See also: go build.\n //\n@@ -753,9 +1167,12 @@\n //\n // As part of building a test binary, go test runs go vet on the package\n // and its test source files to identify significant problems. If go vet\n-// finds any problems, go test reports those and does not run the test binary.\n-// Only a high-confidence subset of the default go vet checks are used.\n-// To disable the running of go vet, use the -vet=off flag.\n+// finds any problems, go test reports those and does not run the test\n+// binary. Only a high-confidence subset of the default go vet checks are\n+// used. That subset is: 'atomic', 'bool', 'buildtags', 'nilfunc', and\n+// 'printf'. You can see the documentation for these and other vet tests\n+// via \"go doc cmd/vet\". To disable the running of go vet, use the\n+// -vet=off flag.\n //\n // All test output and summary lines are printed to the go command's\n // standard output, even if the test printed them to its own standard\n@@ -887,25 +1304,6 @@\n // See also: go fmt, go fix.\n //\n //\n-// Calling between Go and C\n-//\n-// There are two different ways to call between Go and C/C++ code.\n-//\n-// The first is the cgo tool, which is part of the Go distribution. For\n-// information on how to use it see the cgo documentation (go doc cmd/cgo).\n-//\n-// The second is the SWIG program, which is a general tool for\n-// interfacing between languages. For information on SWIG see\n-// http://swig.org/. When running go build, any file with a .swig\n-// extension will be passed to SWIG. Any file with a .swigcxx extension\n-// will be passed to SWIG with the -c++ option.\n-//\n-// When either cgo or SWIG is used, go build will pass any .c, .m, .s,\n-// or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n-// compiler. The CC or CXX environment variables may be set to determine\n-// the C or C++ compiler, respectively, to use.\n-//\n-//\n // Build modes\n //\n // The 'go build' and 'go install' commands take a -buildmode argument which\n@@ -952,13 +1350,33 @@\n // \t\timport, into a Go plugin. Packages not named main are ignored.\n //\n //\n+// Calling between Go and C\n+//\n+// There are two different ways to call between Go and C/C++ code.\n+//\n+// The first is the cgo tool, which is part of the Go distribution. For\n+// information on how to use it see the cgo documentation (go doc cmd/cgo).\n+//\n+// The second is the SWIG program, which is a general tool for\n+// interfacing between languages. For information on SWIG see\n+// http://swig.org/. When running go build, any file with a .swig\n+// extension will be passed to SWIG. Any file with a .swigcxx extension\n+// will be passed to SWIG with the -c++ option.\n+//\n+// When either cgo or SWIG is used, go build will pass any .c, .m, .s,\n+// or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n+// compiler. The CC or CXX environment variables may be set to determine\n+// the C or C++ compiler, respectively, to use.\n+//\n+//\n // Build and test caching\n //\n // The go command caches build outputs for reuse in future builds.\n // The default location for cache data is a subdirectory named go-build\n // in the standard user cache directory for the current operating system.\n // Setting the GOCACHE environment variable overrides this default,\n // and running 'go env GOCACHE' prints the current cache directory.\n+// You can set the variable to 'off' to disable the cache.\n //\n // The go command periodically deletes cached data that has not been\n // used recently. Running 'go clean -cache' deletes all cached data.\n@@ -991,6 +1409,129 @@\n // decisions about whether to reuse a cached test result.\n //\n //\n+// Environment variables\n+//\n+// The go command, and the tools it invokes, examine a few different\n+// environment variables. For many of these, you can see the default\n+// value of on your system by running 'go env NAME', where NAME is the\n+// name of the variable.\n+//\n+// General-purpose environment variables:\n+//\n+// \tGCCGO\n+// \t\tThe gccgo command to run for 'go build -compiler=gccgo'.\n+// \tGOARCH\n+// \t\tThe architecture, or processor, for which to compile code.\n+// \t\tExamples are amd64, 386, arm, ppc64.\n+// \tGOBIN\n+// \t\tThe directory where 'go install' will install a command.\n+// \tGOCACHE\n+// \t\tThe directory where the go command will store cached\n+// \t\tinformation for reuse in future builds.\n+// \tGOFLAGS\n+// \t\tA space-separated list of -flag=value settings to apply\n+// \t\tto go commands by default, when the given flag is known by\n+// \t\tthe current command. Flags listed on the command-line\n+// \t\tare applied after this list and therefore override it.\n+// \tGOOS\n+// \t\tThe operating system for which to compile code.\n+// \t\tExamples are linux, darwin, windows, netbsd.\n+// \tGOPATH\n+// \t\tFor more details see: 'go help gopath'.\n+// \tGOPROXY\n+// \t\tURL of Go module proxy. See 'go help goproxy'.\n+// \tGORACE\n+// \t\tOptions for the race detector.\n+// \t\tSee https://golang.org/doc/articles/race_detector.html.\n+// \tGOROOT\n+// \t\tThe root of the go tree.\n+// \tGOTMPDIR\n+// \t\tThe directory where the go command will write\n+// \t\ttemporary source files, packages, and binaries.\n+//\n+// Environment variables for use with cgo:\n+//\n+// \tCC\n+// \t\tThe command to use to compile C code.\n+// \tCGO_ENABLED\n+// \t\tWhether the cgo command is supported. Either 0 or 1.\n+// \tCGO_CFLAGS\n+// \t\tFlags that cgo will pass to the compiler when compiling\n+// \t\tC code.\n+// \tCGO_CFLAGS_ALLOW\n+// \t\tA regular expression specifying additional flags to allow\n+// \t\tto appear in #cgo CFLAGS source code directives.\n+// \t\tDoes not apply to the CGO_CFLAGS environment variable.\n+// \tCGO_CFLAGS_DISALLOW\n+// \t\tA regular expression specifying flags that must be disallowed\n+// \t\tfrom appearing in #cgo CFLAGS source code directives.\n+// \t\tDoes not apply to the CGO_CFLAGS environment variable.\n+// \tCGO_CPPFLAGS, CGO_CPPFLAGS_ALLOW, CGO_CPPFLAGS_DISALLOW\n+// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+// \t\tbut for the C preprocessor.\n+// \tCGO_CXXFLAGS, CGO_CXXFLAGS_ALLOW, CGO_CXXFLAGS_DISALLOW\n+// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+// \t\tbut for the C++ compiler.\n+// \tCGO_FFLAGS, CGO_FFLAGS_ALLOW, CGO_FFLAGS_DISALLOW\n+// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+// \t\tbut for the Fortran compiler.\n+// \tCGO_LDFLAGS, CGO_LDFLAGS_ALLOW, CGO_LDFLAGS_DISALLOW\n+// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n+// \t\tbut for the linker.\n+// \tCXX\n+// \t\tThe command to use to compile C++ code.\n+// \tPKG_CONFIG\n+// \t\tPath to pkg-config tool.\n+//\n+// Architecture-specific environment variables:\n+//\n+// \tGOARM\n+// \t\tFor GOARCH=arm, the ARM architecture for which to compile.\n+// \t\tValid values are 5, 6, 7.\n+// \tGO386\n+// \t\tFor GOARCH=386, the floating point instruction set.\n+// \t\tValid values are 387, sse2.\n+// \tGOMIPS\n+// \t\tFor GOARCH=mips{,le}, whether to use floating point instructions.\n+// \t\tValid values are hardfloat (default), softfloat.\n+// \tGOMIPS64\n+// \t\tFor GOARCH=mips64{,le}, whether to use floating point instructions.\n+// \t\tValid values are hardfloat (default), softfloat.\n+//\n+// Special-purpose environment variables:\n+//\n+// \tGCCGOTOOLDIR\n+// \t\tIf set, where to find gccgo tools, such as cgo.\n+// \t\tThe default is based on how gccgo was configured.\n+// \tGOROOT_FINAL\n+// \t\tThe root of the installed Go tree, when it is\n+// \t\tinstalled in a location other than where it is built.\n+// \t\tFile names in stack traces are rewritten from GOROOT to\n+// \t\tGOROOT_FINAL.\n+// \tGO_EXTLINK_ENABLED\n+// \t\tWhether the linker should use external linking mode\n+// \t\twhen using -linkmode=auto with code that uses cgo.\n+// \t\tSet to 0 to disable external linking mode, 1 to enable it.\n+// \tGIT_ALLOW_PROTOCOL\n+// \t\tDefined by Git. A colon-separated list of schemes that are allowed to be used\n+// \t\twith git fetch/clone. If set, any scheme not explicitly mentioned will be\n+// \t\tconsidered insecure by 'go get'.\n+//\n+// Additional information available from 'go env' but not read from the environment:\n+//\n+// \tGOEXE\n+// \t\tThe executable file name suffix (\".exe\" on Windows, \"\" on other systems).\n+// \tGOHOSTARCH\n+// \t\tThe architecture (GOARCH) of the Go toolchain binaries.\n+// \tGOHOSTOS\n+// \t\tThe operating system (GOOS) of the Go toolchain binaries.\n+// \tGOMOD\n+// \t\tThe absolute path to the go.mod of the main module,\n+// \t\tor the empty string if not using modules.\n+// \tGOTOOLDIR\n+// \t\tThe directory where the go tools (compile, cover, doc, etc...) are installed.\n+//\n+//\n // File types\n //\n // The go command examines the contents of a restricted set of files\n@@ -1036,6 +1577,85 @@\n // command.\n //\n //\n+// The go.mod file\n+//\n+// A module version is defined by a tree of source files, with a go.mod\n+// file in its root. When the go command is run, it looks in the current\n+// directory and then successive parent directories to find the go.mod\n+// marking the root of the main (current) module.\n+//\n+// The go.mod file itself is line-oriented, with // comments but\n+// no /* */ comments. Each line holds a single directive, made up of a\n+// verb followed by arguments. For example:\n+//\n+// \tmodule my/thing\n+// \trequire other/thing v1.0.2\n+// \trequire new/thing v2.3.4\n+// \texclude old/thing v1.2.3\n+// \treplace bad/thing v1.4.5 => good/thing v1.4.5\n+//\n+// The verbs are module, to define the module path; require, to require\n+// a particular module at a given version or later; exclude, to exclude\n+// a particular module version from use; and replace, to replace a module\n+// version with a different module version. Exclude and replace apply only\n+// in the main module's go.mod and are ignored in dependencies.\n+// See https://research.swtch.com/vgo-mvs for details.\n+//\n+// The leading verb can be factored out of adjacent lines to create a block,\n+// like in Go imports:\n+//\n+// \trequire (\n+// \t\tnew/thing v2.3.4\n+// \t\told/thing v1.2.3\n+// \t)\n+//\n+// The go.mod file is designed both to be edited directly and to be\n+// easily updated by tools. The 'go mod edit' command can be used to\n+// parse and edit the go.mod file from programs and tools.\n+// See 'go help mod edit'.\n+//\n+// The go command automatically updates go.mod each time it uses the\n+// module graph, to make sure go.mod always accurately reflects reality\n+// and is properly formatted. For example, consider this go.mod file:\n+//\n+//         module M\n+//\n+//         require (\n+//                 A v1\n+//                 B v1.0.0\n+//                 C v1.0.0\n+//                 D v1.2.3\n+//                 E dev\n+//         )\n+//\n+//         exclude D v1.2.3\n+//\n+// The update rewrites non-canonical version identifiers to semver form,\n+// so A's v1 becomes v1.0.0 and E's dev becomes the pseudo-version for the\n+// latest commit on the dev branch, perhaps v0.0.0-20180523231146-b3f5c0f6e5f1.\n+//\n+// The update modifies requirements to respect exclusions, so the\n+// requirement on the excluded D v1.2.3 is updated to use the next\n+// available version of D, perhaps D v1.2.4 or D v1.3.0.\n+//\n+// The update removes redundant or misleading requirements.\n+// For example, if A v1.0.0 itself requires B v1.2.0 and C v1.0.0,\n+// then go.mod's requirement of B v1.0.0 is misleading (superseded by\n+// A's need for v1.2.0), and its requirement of C v1.0.0 is redundant\n+// (implied by A's need for the same version), so both will be removed.\n+// If module M contains packages that directly import packages from B or\n+// C, then the requirements will be kept but updated to the actual\n+// versions being used.\n+//\n+// Finally, the update reformats the go.mod in a canonical formatting, so\n+// that future mechanical changes will result in minimal diffs.\n+//\n+// Because the module graph defines the meaning of import statements, any\n+// commands that load packages also use and therefore update go.mod,\n+// including go build, go get, go install, go list, go test, go mod graph,\n+// go mod tidy, and go mod why.\n+//\n+//\n // GOPATH environment variable\n //\n // The Go path is used to resolve import statements.\n@@ -1102,6 +1722,12 @@\n //\n // See https://golang.org/doc/code.html for an example.\n //\n+// GOPATH and Modules\n+//\n+// When using modules, GOPATH is no longer used for resolving imports.\n+// However, it is still used to store downloaded source code (in GOPATH/pkg/mod)\n+// and compiled commands (in GOPATH/bin).\n+//\n // Internal Directories\n //\n // Code in or below a directory named \"internal\" is importable only\n@@ -1185,103 +1811,67 @@\n // See https://golang.org/s/go15vendor for details.\n //\n //\n-// Environment variables\n+// Module proxy protocol\n //\n-// The go command, and the tools it invokes, examine a few different\n-// environment variables. For many of these, you can see the default\n-// value of on your system by running 'go env NAME', where NAME is the\n-// name of the variable.\n+// The go command by default downloads modules from version control systems\n+// directly, just as 'go get' always has. The GOPROXY environment variable allows\n+// further control over the download source. If GOPROXY is unset, is the empty string,\n+// or is the string \"direct\", downloads use the default direct connection to version\n+// control systems. Setting GOPROXY to \"off\" disallows downloading modules from\n+// any source. Otherwise, GOPROXY is expected to be the URL of a module proxy,\n+// in which case the go command will fetch all modules from that proxy.\n+// No matter the source of the modules, downloaded modules must match existing\n+// entries in go.sum (see 'go help modules' for discussion of verification).\n //\n-// General-purpose environment variables:\n+// A Go module proxy is any web server that can respond to GET requests for\n+// URLs of a specified form. The requests have no query parameters, so even\n+// a site serving from a fixed file system (including a file:/// URL)\n+// can be a module proxy.\n //\n-// \tGCCGO\n-// \t\tThe gccgo command to run for 'go build -compiler=gccgo'.\n-// \tGOARCH\n-// \t\tThe architecture, or processor, for which to compile code.\n-// \t\tExamples are amd64, 386, arm, ppc64.\n-// \tGOBIN\n-// \t\tThe directory where 'go install' will install a command.\n-// \tGOOS\n-// \t\tThe operating system for which to compile code.\n-// \t\tExamples are linux, darwin, windows, netbsd.\n-// \tGOPATH\n-// \t\tFor more details see: 'go help gopath'.\n-// \tGORACE\n-// \t\tOptions for the race detector.\n-// \t\tSee https://golang.org/doc/articles/race_detector.html.\n-// \tGOROOT\n-// \t\tThe root of the go tree.\n-// \tGOTMPDIR\n-// \t\tThe directory where the go command will write\n-// \t\ttemporary source files, packages, and binaries.\n-// \tGOCACHE\n-// \t\tThe directory where the go command will store\n-// \t\tcached information for reuse in future builds.\n+// The GET requests sent to a Go module proxy are:\n //\n-// Environment variables for use with cgo:\n+// GET $GOPROXY/<module>/@v/list returns a list of all known versions of the\n+// given module, one per line.\n //\n-// \tCC\n-// \t\tThe command to use to compile C code.\n-// \tCGO_ENABLED\n-// \t\tWhether the cgo command is supported. Either 0 or 1.\n-// \tCGO_CFLAGS\n-// \t\tFlags that cgo will pass to the compiler when compiling\n-// \t\tC code.\n-// \tCGO_CFLAGS_ALLOW\n-// \t\tA regular expression specifying additional flags to allow\n-// \t\tto appear in #cgo CFLAGS source code directives.\n-// \t\tDoes not apply to the CGO_CFLAGS environment variable.\n-// \tCGO_CFLAGS_DISALLOW\n-// \t\tA regular expression specifying flags that must be disallowed\n-// \t\tfrom appearing in #cgo CFLAGS source code directives.\n-// \t\tDoes not apply to the CGO_CFLAGS environment variable.\n-// \tCGO_CPPFLAGS, CGO_CPPFLAGS_ALLOW, CGO_CPPFLAGS_DISALLOW\n-// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n-// \t\tbut for the C preprocessor.\n-// \tCGO_CXXFLAGS, CGO_CXXFLAGS_ALLOW, CGO_CXXFLAGS_DISALLOW\n-// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n-// \t\tbut for the C++ compiler.\n-// \tCGO_FFLAGS, CGO_FFLAGS_ALLOW, CGO_FFLAGS_DISALLOW\n-// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n-// \t\tbut for the Fortran compiler.\n-// \tCGO_LDFLAGS, CGO_LDFLAGS_ALLOW, CGO_LDFLAGS_DISALLOW\n-// \t\tLike CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,\n-// \t\tbut for the linker.\n-// \tCXX\n-// \t\tThe command to use to compile C++ code.\n-// \tPKG_CONFIG\n-// \t\tPath to pkg-config tool.\n+// GET $GOPROXY/<module>/@v/<version>.info returns JSON-formatted metadata\n+// about that version of the given module.\n //\n-// Architecture-specific environment variables:\n+// GET $GOPROXY/<module>/@v/<version>.mod returns the go.mod file\n+// for that version of the given module.\n //\n-// \tGOARM\n-// \t\tFor GOARCH=arm, the ARM architecture for which to compile.\n-// \t\tValid values are 5, 6, 7.\n-// \tGO386\n-// \t\tFor GOARCH=386, the floating point instruction set.\n-// \t\tValid values are 387, sse2.\n-// \tGOMIPS\n-// \t\tFor GOARCH=mips{,le}, whether to use floating point instructions.\n-// \t\tValid values are hardfloat (default), softfloat.\n+// GET $GOPROXY/<module>/@v/<version>.zip returns the zip archive\n+// for that version of the given module.\n //\n-// Special-purpose environment variables:\n+// To avoid problems when serving from case-sensitive file systems,\n+// the <module> and <version> elements are case-encoded, replacing every\n+// uppercase letter with an exclamation mark followed by the corresponding\n+// lower-case letter: github.com/Azure encodes as github.com/!azure.\n //\n-// \tGCCGOTOOLDIR\n-// \t\tIf set, where to find gccgo tools, such as cgo.\n-// \t\tThe default is based on how gccgo was configured.\n-// \tGOROOT_FINAL\n-// \t\tThe root of the installed Go tree, when it is\n-// \t\tinstalled in a location other than where it is built.\n-// \t\tFile names in stack traces are rewritten from GOROOT to\n-// \t\tGOROOT_FINAL.\n-// \tGO_EXTLINK_ENABLED\n-// \t\tWhether the linker should use external linking mode\n-// \t\twhen using -linkmode=auto with code that uses cgo.\n-// \t\tSet to 0 to disable external linking mode, 1 to enable it.\n-// \tGIT_ALLOW_PROTOCOL\n-// \t\tDefined by Git. A colon-separated list of schemes that are allowed to be used\n-// \t\twith git fetch/clone. If set, any scheme not explicitly mentioned will be\n-// \t\tconsidered insecure by 'go get'.\n+// The JSON-formatted metadata about a given module corresponds to\n+// this Go data structure, which may be expanded in the future:\n+//\n+//     type Info struct {\n+//         Version string    // version string\n+//         Time    time.Time // commit time\n+//     }\n+//\n+// The zip archive for a specific version of a given module is a\n+// standard zip file that contains the file tree corresponding\n+// to the module's source code and related files. The archive uses\n+// slash-separated paths, and every file path in the archive must\n+// begin with <module>@<version>/, where the module and version are\n+// substituted directly, not case-encoded. The root of the module\n+// file tree corresponds to the <module>@<version>/ prefix in the\n+// archive.\n+//\n+// Even when downloading directly from version control systems,\n+// the go command synthesizes explicit info, mod, and zip files\n+// and stores them in its local cache, $GOPATH/pkg/mod/cache/download,\n+// the same as if it had downloaded them directly from a proxy.\n+// The cache layout is the same as the proxy URL space, so\n+// serving $GOPATH/pkg/mod/cache/download at (or copying it to)\n+// https://example.com/proxy would let other users access those\n+// cached module versions with GOPROXY=https://example.com/proxy.\n //\n //\n // Import path syntax\n@@ -1361,6 +1951,7 @@\n // that repository. The supported version control systems are:\n //\n // \tBazaar      .bzr\n+// \tFossil      .fossil\n // \tGit         .git\n // \tMercurial   .hg\n // \tSubversion  .svn\n@@ -1404,7 +1995,7 @@\n // In particular, it should appear before any raw JavaScript or CSS,\n // to avoid confusing the go command's restricted parser.\n //\n-// The vcs is one of \"git\", \"hg\", \"svn\", etc,\n+// The vcs is one of \"bzr\", \"fossil\", \"git\", \"hg\", \"svn\".\n //\n // The repo-root is the root of the version control system\n // containing a scheme and not containing a .vcs qualifier.\n@@ -1426,12 +2017,22 @@\n // same meta tag and then git clone https://code.org/r/p/exproj into\n // GOPATH/src/example.org.\n //\n-// New downloaded packages are written to the first directory listed in the GOPATH\n-// environment variable (For more details see: 'go help gopath').\n+// When using GOPATH, downloaded packages are written to the first directory\n+// listed in the GOPATH environment variable.\n+// (See 'go help gopath-get' and 'go help gopath'.)\n+//\n+// When using modules, downloaded packages are stored in the module cache.\n+// (See 'go help modules-get' and 'go help goproxy'.)\n //\n-// The go command attempts to download the version of the\n-// package appropriate for the Go release being used.\n-// Run 'go help get' for more.\n+// When using modules, an additional variant of the go-import meta tag is\n+// recognized and is preferred over those listing version control systems.\n+// That variant uses \"mod\" as the vcs in the content value, as in:\n+//\n+// \t<meta name=\"go-import\" content=\"example.org mod https://code.org/moduleproxy\">\n+//\n+// This tag means to fetch modules with paths beginning with example.org\n+// from the module proxy available at the URL https://code.org/moduleproxy.\n+// See 'go help goproxy' for details about the proxy protocol.\n //\n // Import path checking\n //\n@@ -1454,10 +2055,484 @@\n // This makes it possible to copy code into alternate locations in vendor trees\n // without needing to update import comments.\n //\n+// Import path checking is also disabled when using modules.\n+// Import path comments are obsoleted by the go.mod file's module statement.\n+//\n // See https://golang.org/s/go14customimport for details.\n //\n //\n-// Package lists\n+// Modules, module versions, and more\n+//\n+// A module is a collection of related Go packages.\n+// Modules are the unit of source code interchange and versioning.\n+// The go command has direct support for working with modules,\n+// including recording and resolving dependencies on other modules.\n+// Modules replace the old GOPATH-based approach to specifying\n+// which source files are used in a given build.\n+//\n+// Preliminary module support\n+//\n+// Go 1.11 includes preliminary support for Go modules,\n+// including a new module-aware 'go get' command.\n+// We intend to keep revising this support, while preserving compatibility,\n+// until it can be declared official (no longer preliminary),\n+// and then at a later point we may remove support for work\n+// in GOPATH and the old 'go get' command.\n+//\n+// The quickest way to take advantage of the new Go 1.11 module support\n+// is to check out your repository into a directory outside GOPATH/src,\n+// create a go.mod file (described in the next section) there, and run\n+// go commands from within that file tree.\n+//\n+// For more fine-grained control, the module support in Go 1.11 respects\n+// a temporary environment variable, GO111MODULE, which can be set to one\n+// of three string values: off, on, or auto (the default).\n+// If GO111MODULE=off, then the go command never uses the\n+// new module support. Instead it looks in vendor directories and GOPATH\n+// to find dependencies; we now refer to this as \"GOPATH mode.\"\n+// If GO111MODULE=on, then the go command requires the use of modules,\n+// never consulting GOPATH. We refer to this as the command being\n+// module-aware or running in \"module-aware mode\".\n+// If GO111MODULE=auto or is unset, then the go command enables or\n+// disables module support based on the current directory.\n+// Module support is enabled only when the current directory is outside\n+// GOPATH/src and itself contains a go.mod file or is below a directory\n+// containing a go.mod file.\n+//\n+// In module-aware mode, GOPATH no longer defines the meaning of imports\n+// during a build, but it still stores downloaded dependencies (in GOPATH/pkg/mod)\n+// and installed commands (in GOPATH/bin, unless GOBIN is set).\n+//\n+// Defining a module\n+//\n+// A module is defined by a tree of Go source files with a go.mod file\n+// in the tree's root directory. The directory containing the go.mod file\n+// is called the module root. Typically the module root will also correspond\n+// to a source code repository root (but in general it need not).\n+// The module is the set of all Go packages in the module root and its\n+// subdirectories, but excluding subtrees with their own go.mod files.\n+//\n+// The \"module path\" is the import path prefix corresponding to the module root.\n+// The go.mod file defines the module path and lists the specific versions\n+// of other modules that should be used when resolving imports during a build,\n+// by giving their module paths and versions.\n+//\n+// For example, this go.mod declares that the directory containing it is the root\n+// of the module with path example.com/m, and it also declares that the module\n+// depends on specific versions of golang.org/x/text and gopkg.in/yaml.v2:\n+//\n+// \tmodule example.com/m\n+//\n+// \trequire (\n+// \t\tgolang.org/x/text v0.3.0\n+// \t\tgopkg.in/yaml.v2 v2.1.0\n+// \t)\n+//\n+// The go.mod file can also specify replacements and excluded versions\n+// that only apply when building the module directly; they are ignored\n+// when the module is incorporated into a larger build.\n+// For more about the go.mod file, see 'go help go.mod'.\n+//\n+// To start a new module, simply create a go.mod file in the root of the\n+// module's directory tree, containing only a module statement.\n+// The 'go mod init' command can be used to do this:\n+//\n+// \tgo mod init example.com/m\n+//\n+// In a project already using an existing dependency management tool like\n+// godep, glide, or dep, 'go mod init' will also add require statements\n+// matching the existing configuration.\n+//\n+// Once the go.mod file exists, no additional steps are required:\n+// go commands like 'go build', 'go test', or even 'go list' will automatically\n+// add new dependencies as needed to satisfy imports.\n+//\n+// The main module and the build list\n+//\n+// The \"main module\" is the module containing the directory where the go command\n+// is run. The go command finds the module root by looking for a go.mod in the\n+// current directory, or else the current directory's parent directory,\n+// or else the parent's parent directory, and so on.\n+//\n+// The main module's go.mod file defines the precise set of packages available\n+// for use by the go command, through require, replace, and exclude statements.\n+// Dependency modules, found by following require statements, also contribute\n+// to the definition of that set of packages, but only through their go.mod\n+// files' require statements: any replace and exclude statements in dependency\n+// modules are ignored. The replace and exclude statements therefore allow the\n+// main module complete control over its own build, without also being subject\n+// to complete control by dependencies.\n+//\n+// The set of modules providing packages to builds is called the \"build list\".\n+// The build list initially contains only the main module. Then the go command\n+// adds to the list the exact module versions required by modules already\n+// on the list, recursively, until there is nothing left to add to the list.\n+// If multiple versions of a particular module are added to the list,\n+// then at the end only the latest version (according to semantic version\n+// ordering) is kept for use in the build.\n+//\n+// The 'go list' command provides information about the main module\n+// and the build list. For example:\n+//\n+// \tgo list -m              # print path of main module\n+// \tgo list -m -f={{.Dir}}  # print root directory of main module\n+// \tgo list -m all          # print build list\n+//\n+// Maintaining module requirements\n+//\n+// The go.mod file is meant to be readable and editable by both\n+// programmers and tools. The go command itself automatically updates the go.mod file\n+// to maintain a standard formatting and the accuracy of require statements.\n+//\n+// Any go command that finds an unfamiliar import will look up the module\n+// containing that import and add the latest version of that module\n+// to go.mod automatically. In most cases, therefore, it suffices to\n+// add an import to source code and run 'go build', 'go test', or even 'go list':\n+// as part of analyzing the package, the go command will discover\n+// and resolve the import and update the go.mod file.\n+//\n+// Any go command can determine that a module requirement is\n+// missing and must be added, even when considering only a single\n+// package from the module. On the other hand, determining that a module requirement\n+// is no longer necessary and can be deleted requires a full view of\n+// all packages in the module, across all possible build configurations\n+// (architectures, operating systems, build tags, and so on).\n+// The 'go mod tidy' command builds that view and then\n+// adds any missing module requirements and removes unnecessary ones.\n+//\n+// As part of maintaining the require statements in go.mod, the go command\n+// tracks which ones provide packages imported directly by the current module\n+// and which ones provide packages only used indirectly by other module\n+// dependencies. Requirements needed only for indirect uses are marked with a\n+// \"// indirect\" comment in the go.mod file. Indirect requirements are\n+// automatically removed from the go.mod file once they are implied by other\n+// direct requirements. Indirect requirements only arise when using modules\n+// that fail to state some of their own dependencies or when explicitly\n+// upgrading a module's dependencies ahead of its own stated requirements.\n+//\n+// Because of this automatic maintenance, the information in go.mod is an\n+// up-to-date, readable description of the build.\n+//\n+// The 'go get' command updates go.mod to change the module versions used in a\n+// build. An upgrade of one module may imply upgrading others, and similarly a\n+// downgrade of one module may imply downgrading others. The 'go get' command\n+// makes these implied changes as well. If go.mod is edited directly, commands\n+// like 'go build' or 'go list' will assume that an upgrade is intended and\n+// automatically make any implied upgrades and update go.mod to reflect them.\n+//\n+// The 'go mod' command provides other functionality for use in maintaining\n+// and understanding modules and go.mod files. See 'go help mod'.\n+//\n+// The -mod build flag provides additional control over updating and use of go.mod.\n+//\n+// If invoked with -mod=readonly, the go command is disallowed from the implicit\n+// automatic updating of go.mod described above. Instead, it fails when any changes\n+// to go.mod are needed. This setting is most useful to check that go.mod does\n+// not need updates, such as in a continuous integration and testing system.\n+// The \"go get\" command remains permitted to update go.mod even with -mod=readonly,\n+// and the \"go mod\" commands do not take the -mod flag (or any other build flags).\n+//\n+// If invoked with -mod=vendor, the go command assumes that the vendor\n+// directory holds the correct copies of dependencies and ignores\n+// the dependency descriptions in go.mod.\n+//\n+// Pseudo-versions\n+//\n+// The go.mod file and the go command more generally use semantic versions as\n+// the standard form for describing module versions, so that versions can be\n+// compared to determine which should be considered earlier or later than another.\n+// A module version like v1.2.3 is introduced by tagging a revision in the\n+// underlying source repository. Untagged revisions can be referred to\n+// using a \"pseudo-version\" like v0.0.0-yyyymmddhhmmss-abcdefabcdef,\n+// where the time is the commit time in UTC and the final suffix is the prefix\n+// of the commit hash. The time portion ensures that two pseudo-versions can\n+// be compared to determine which happened later, the commit hash identifes\n+// the underlying commit, and the prefix (v0.0.0- in this example) is derived from\n+// the most recent tagged version in the commit graph before this commit.\n+//\n+// There are three pseudo-version forms:\n+//\n+// vX.0.0-yyyymmddhhmmss-abcdefabcdef is used when there is no earlier\n+// versioned commit with an appropriate major version before the target commit.\n+// (This was originally the only form, so some older go.mod files use this form\n+// even for commits that do follow tags.)\n+//\n+// vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef is used when the most\n+// recent versioned commit before the target commit is vX.Y.Z-pre.\n+//\n+// vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef is used when the most\n+// recent versioned commit before the target commit is vX.Y.Z.\n+//\n+// Pseudo-versions never need to be typed by hand: the go command will accept\n+// the plain commit hash and translate it into a pseudo-version (or a tagged\n+// version if available) automatically. This conversion is an example of a\n+// module query.\n+//\n+// Module queries\n+//\n+// The go command accepts a \"module query\" in place of a module version\n+// both on the command line and in the main module's go.mod file.\n+// (After evaluating a query found in the main module's go.mod file,\n+// the go command updates the file to replace the query with its result.)\n+//\n+// A fully-specified semantic version, such as \"v1.2.3\",\n+// evaluates to that specific version.\n+//\n+// A semantic version prefix, such as \"v1\" or \"v1.2\",\n+// evaluates to the latest available tagged version with that prefix.\n+//\n+// A semantic version comparison, such as \"<v1.2.3\" or \">=v1.5.6\",\n+// evaluates to the available tagged version nearest to the comparison target\n+// (the latest version for < and <=, the earliest version for > and >=).\n+//\n+// The string \"latest\" matches the latest available tagged version,\n+// or else the underlying source repository's latest untagged revision.\n+//\n+// A revision identifier for the underlying source repository,\n+// such as a commit hash prefix, revision tag, or branch name,\n+// selects that specific code revision. If the revision is\n+// also tagged with a semantic version, the query evaluates to\n+// that semantic version. Otherwise the query evaluates to a\n+// pseudo-version for the commit.\n+//\n+// All queries prefer release versions to pre-release versions.\n+// For example, \"<v1.2.3\" will prefer to return \"v1.2.2\"\n+// instead of \"v1.2.3-pre1\", even though \"v1.2.3-pre1\" is nearer\n+// to the comparison target.\n+//\n+// Module versions disallowed by exclude statements in the\n+// main module's go.mod are considered unavailable and cannot\n+// be returned by queries.\n+//\n+// For example, these commands are all valid:\n+//\n+// \tgo get github.com/gorilla/mux@latest    # same (@latest is default for 'go get')\n+// \tgo get github.com/gorilla/mux@v1.6.2    # records v1.6.2\n+// \tgo get github.com/gorilla/mux@e3702bed2 # records v1.6.2\n+// \tgo get github.com/gorilla/mux@c856192   # records v0.0.0-20180517173623-c85619274f5d\n+// \tgo get github.com/gorilla/mux@master    # records current meaning of master\n+//\n+// Module compatibility and semantic versioning\n+//\n+// The go command requires that modules use semantic versions and expects that\n+// the versions accurately describe compatibility: it assumes that v1.5.4 is a\n+// backwards-compatible replacement for v1.5.3, v1.4.0, and even v1.0.0.\n+// More generally the go command expects that packages follow the\n+// \"import compatibility rule\", which says:\n+//\n+// \"If an old package and a new package have the same import path,\n+// the new package must be backwards compatible with the old package.\"\n+//\n+// Because the go command assumes the import compatibility rule,\n+// a module definition can only set the minimum required version of one\n+// of its dependencies: it cannot set a maximum or exclude selected versions.\n+// Still, the import compatibility rule is not a guarantee: it may be that\n+// v1.5.4 is buggy and not a backwards-compatible replacement for v1.5.3.\n+// Because of this, the go command never updates from an older version\n+// to a newer version of a module unasked.\n+//\n+// In semantic versioning, changing the major version number indicates a lack\n+// of backwards compatibility with earlier versions. To preserve import\n+// compatibility, the go command requires that modules with major version v2\n+// or later use a module path with that major version as the final element.\n+// For example, version v2.0.0 of example.com/m must instead use module path\n+// example.com/m/v2, and packages in that module would use that path as\n+// their import path prefix, as in example.com/m/v2/sub/pkg. Including the\n+// major version number in the module path and import paths in this way is\n+// called \"semantic import versioning\". Pseudo-versions for modules with major\n+// version v2 and later begin with that major version instead of v0, as in\n+// v2.0.0-20180326061214-4fc5987536ef.\n+//\n+// As a special case, module paths beginning with gopkg.in/ continue to use the\n+// conventions established on that system: the major version is always present,\n+// and it is preceded by a dot instead of a slash: gopkg.in/yaml.v1\n+// and gopkg.in/yaml.v2, not gopkg.in/yaml and gopkg.in/yaml/v2.\n+//\n+// The go command treats modules with different module paths as unrelated:\n+// it makes no connection between example.com/m and example.com/m/v2.\n+// Modules with different major versions can be used together in a build\n+// and are kept separate by the fact that their packages use different\n+// import paths.\n+//\n+// In semantic versioning, major version v0 is for initial development,\n+// indicating no expectations of stability or backwards compatibility.\n+// Major version v0 does not appear in the module path, because those\n+// versions are preparation for v1.0.0, and v1 does not appear in the\n+// module path either.\n+//\n+// Code written before the semantic import versioning convention\n+// was introduced may use major versions v2 and later to describe\n+// the same set of unversioned import paths as used in v0 and v1.\n+// To accommodate such code, if a source code repository has a\n+// v2.0.0 or later tag for a file tree with no go.mod, the version is\n+// considered to be part of the v1 module's available versions\n+// and is given an +incompatible suffix when converted to a module\n+// version, as in v2.0.0+incompatible. The +incompatible tag is also\n+// applied to pseudo-versions derived from such versions, as in\n+// v2.0.1-0.yyyymmddhhmmss-abcdefabcdef+incompatible.\n+//\n+// In general, having a dependency in the build list (as reported by 'go list -m all')\n+// on a v0 version, pre-release version, pseudo-version, or +incompatible version\n+// is an indication that problems are more likely when upgrading that\n+// dependency, since there is no expectation of compatibility for those.\n+//\n+// See https://research.swtch.com/vgo-import for more information about\n+// semantic import versioning, and see https://semver.org/ for more about\n+// semantic versioning.\n+//\n+// Module code layout\n+//\n+// For now, see https://research.swtch.com/vgo-module for information\n+// about how source code in version control systems is mapped to\n+// module file trees.\n+//\n+// Module downloading and verification\n+//\n+// The go command maintains, in the main module's root directory alongside\n+// go.mod, a file named go.sum containing the expected cryptographic checksums\n+// of the content of specific module versions. Each time a dependency is\n+// used, its checksum is added to go.sum if missing or else required to match\n+// the existing entry in go.sum.\n+//\n+// The go command maintains a cache of downloaded packages and computes\n+// and records the cryptographic checksum of each package at download time.\n+// In normal operation, the go command checks these pre-computed checksums\n+// against the main module's go.sum file, instead of recomputing them on\n+// each command invocation. The 'go mod verify' command checks that\n+// the cached copies of module downloads still match both their recorded\n+// checksums and the entries in go.sum.\n+//\n+// The go command can fetch modules from a proxy instead of connecting\n+// to source control systems directly, according to the setting of the GOPROXY\n+// environment variable.\n+//\n+// See 'go help goproxy' for details about the proxy and also the format of\n+// the cached downloaded packages.\n+//\n+// Modules and vendoring\n+//\n+// When using modules, the go command completely ignores vendor directories.\n+//\n+// By default, the go command satisfies dependencies by downloading modules\n+// from their sources and using those downloaded copies (after verification,\n+// as described in the previous section). To allow interoperation with older\n+// versions of Go, or to ensure that all files used for a build are stored\n+// together in a single file tree, 'go mod vendor' creates a directory named\n+// vendor in the root directory of the main module and stores there all the\n+// packages from dependency modules that are needed to support builds and\n+// tests of packages in the main module.\n+//\n+// To build using the main module's top-level vendor directory to satisfy\n+// dependencies (disabling use of the usual network sources and local\n+// caches), use 'go build -mod=vendor'. Note that only the main module's\n+// top-level vendor directory is used; vendor directories in other locations\n+// are still ignored.\n+//\n+//\n+// Module-aware go get\n+//\n+// The 'go get' command changes behavior depending on whether the\n+// go command is running in module-aware mode or legacy GOPATH mode.\n+// This help text, accessible as 'go help module-get' even in legacy GOPATH mode,\n+// describes 'go get' as it operates in module-aware mode.\n+//\n+// Usage: go get [-d] [-m] [-u] [-v] [-insecure] [build flags] [packages]\n+//\n+// Get resolves and adds dependencies to the current development module\n+// and then builds and installs them.\n+//\n+// The first step is to resolve which dependencies to add.\n+//\n+// For each named package or package pattern, get must decide which version of\n+// the corresponding module to use. By default, get chooses the latest tagged\n+// release version, such as v0.4.5 or v1.2.3. If there are no tagged release\n+// versions, get chooses the latest tagged prerelease version, such as\n+// v0.0.1-pre1. If there are no tagged versions at all, get chooses the latest\n+// known commit.\n+//\n+// This default version selection can be overridden by adding an @version\n+// suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.\n+// For modules stored in source control repositories, the version suffix can\n+// also be a commit hash, branch identifier, or other syntax known to the\n+// source control system, as in 'go get golang.org/x/text@master'.\n+// The version suffix @latest explicitly requests the default behavior\n+// described above.\n+//\n+// If a module under consideration is already a dependency of the current\n+// development module, then get will update the required version.\n+// Specifying a version earlier than the current required version is valid and\n+// downgrades the dependency. The version suffix @none indicates that the\n+// dependency should be removed entirely.\n+//\n+// Although get defaults to using the latest version of the module containing\n+// a named package, it does not use the latest version of that module's\n+// dependencies. Instead it prefers to use the specific dependency versions\n+// requested by that module. For example, if the latest A requires module\n+// B v1.2.3, while B v1.2.4 and v1.3.1 are also available, then 'go get A'\n+// will use the latest A but then use B v1.2.3, as requested by A. (If there\n+// are competing requirements for a particular module, then 'go get' resolves\n+// those requirements by taking the maximum requested version.)\n+//\n+// The -u flag instructs get to update dependencies to use newer minor or\n+// patch releases when available. Continuing the previous example,\n+// 'go get -u A' will use the latest A with B v1.3.1 (not B v1.2.3).\n+//\n+// The -u=patch flag (not -u patch) instructs get to update dependencies\n+// to use newer patch releases when available. Continuing the previous example,\n+// 'go get -u=patch A' will use the latest A with B v1.2.4 (not B v1.2.3).\n+//\n+// In general, adding a new dependency may require upgrading\n+// existing dependencies to keep a working build, and 'go get' does\n+// this automatically. Similarly, downgrading one dependency may\n+// require downgrading other dependenceis, and 'go get' does\n+// this automatically as well.\n+//\n+// The -m flag instructs get to stop here, after resolving, upgrading,\n+// and downgrading modules and updating go.mod. When using -m,\n+// each specified package path must be a module path as well,\n+// not the import path of a package below the module root.\n+//\n+// The -insecure flag permits fetching from repositories and resolving\n+// custom domains using insecure schemes such as HTTP. Use with caution.\n+//\n+// The second step is to download (if needed), build, and install\n+// the named packages.\n+//\n+// If an argument names a module but not a package (because there is no\n+// Go source code in the module's root directory), then the install step\n+// is skipped for that argument, instead of causing a build failure.\n+// For example 'go get golang.org/x/perf' succeeds even though there\n+// is no code corresponding to that import path.\n+//\n+// Note that package patterns are allowed and are expanded after resolving\n+// the module versions. For example, 'go get golang.org/x/perf/cmd/...'\n+// adds the latest golang.org/x/perf and then installs the commands in that\n+// latest version.\n+//\n+// The -d flag instructs get to download the source code needed to build\n+// the named packages, including downloading necessary dependencies,\n+// but not to build and install them.\n+//\n+// With no package arguments, 'go get' applies to the main module,\n+// and to the Go package in the current directory, if any. In particular,\n+// 'go get -u' and 'go get -u=patch' update all the dependencies of the\n+// main module. With no package arguments and also without -u,\n+// 'go get' is not much more than 'go install', and 'go get -d' not much\n+// more than 'go list'.\n+//\n+// For more about modules, see 'go help modules'.\n+//\n+// For more about specifying packages, see 'go help packages'.\n+//\n+// This text describes the behavior of get using modules to manage source\n+// code and dependencies. If instead the go command is running in GOPATH\n+// mode, the details of get's flags and effects change, as does 'go help get'.\n+// See 'go help modules' and 'go help gopath-get'.\n+//\n+// See also: go build, go install, go clean, go mod.\n+//\n+//\n+// Package lists and patterns\n //\n // Many commands apply to a set of packages:\n //\n@@ -1481,9 +2556,11 @@\n //\n // - \"main\" denotes the top-level package in a stand-alone executable.\n //\n-// - \"all\" expands to all package directories found in all the GOPATH\n+// - \"all\" expands to all packages found in all the GOPATH\n // trees. For example, 'go list all' lists all the packages on the local\n-// system.\n+// system. When using modules, \"all\" expands to all packages in\n+// the main module and their dependencies, including dependencies\n+// needed by tests of any of those.\n //\n // - \"std\" is like all but expands to just the packages in the standard\n // Go library.\n@@ -1682,14 +2759,13 @@\n // \t    Writes test binary as -c would.\n //\n // \t-memprofile mem.out\n-// \t    Write a memory profile to the file after all tests have passed.\n+// \t    Write an allocation profile to the file after all tests have passed.\n // \t    Writes test binary as -c would.\n //\n // \t-memprofilerate n\n-// \t    Enable more precise (and expensive) memory profiles by setting\n-// \t    runtime.MemProfileRate. See 'go doc runtime.MemProfileRate'.\n-// \t    To profile all memory allocations, use -test.memprofilerate=1\n-// \t    and pass --alloc_space flag to the pprof tool.\n+// \t    Enable more precise (and expensive) memory allocation profiles by\n+// \t    setting runtime.MemProfileRate. See 'go doc runtime.MemProfileRate'.\n+// \t    To profile all memory allocations, use -test.memprofilerate=1.\n //\n // \t-mutexprofile mutex.out\n // \t    Write a mutex contention profile to the specified file\n@@ -1739,6 +2815,12 @@\n // the package list would have to appear before -myflag, but could appear\n // on either side of -v.\n //\n+// When 'go test' runs in package list mode, 'go test' caches successful\n+// package test results to avoid unnecessary repeated running of tests. To\n+// disable test caching, use any test flag or argument other than the\n+// cacheable flags. The idiomatic way to disable test caching explicitly\n+// is to use -count=1.\n+//\n // To keep an argument for a test binary from being interpreted as a\n // known flag or a package name, use -args (see 'go help test') which\n // passes the remainder of the command line through to the test binary"}, {"sha": "e88338815c3dc6982ba4842cfc903547fc47b974", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 708, "deletions": 521, "changes": 1229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -8,12 +8,14 @@ import (\n \t\"bytes\"\n \t\"debug/elf\"\n \t\"debug/macho\"\n+\t\"flag\"\n \t\"fmt\"\n \t\"go/format\"\n \t\"internal/race\"\n \t\"internal/testenv\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"log\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n@@ -48,7 +50,7 @@ func tooSlow(t *testing.T) {\n \n func init() {\n \tswitch runtime.GOOS {\n-\tcase \"android\", \"nacl\":\n+\tcase \"android\", \"js\", \"nacl\":\n \t\tcanRun = false\n \tcase \"darwin\":\n \t\tswitch runtime.GOARCH {\n@@ -99,6 +101,11 @@ func init() {\n var testGOROOT string\n \n var testCC string\n+var testGOCACHE string\n+\n+var testGo string\n+var testTmpDir string\n+var testBin string\n \n // The TestMain function creates a go command for testing purposes and\n // deletes it after the tests have been run.\n@@ -111,8 +118,28 @@ func TestMain(m *testing.M) {\n \t}\n \tos.Unsetenv(\"GOROOT_FINAL\")\n \n+\tflag.Parse()\n+\tif *proxyAddr != \"\" {\n+\t\tStartProxy()\n+\t\tselect {}\n+\t}\n+\n+\tdir, err := ioutil.TempDir(os.Getenv(\"GOTMPDIR\"), \"cmd-go-test-\")\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\ttestTmpDir = dir\n+\tif !*testWork {\n+\t\tdefer removeAll(testTmpDir)\n+\t}\n+\n \tif canRun {\n-\t\targs := []string{\"build\", \"-tags\", \"testgo\", \"-o\", \"testgo\" + exeSuffix}\n+\t\ttestBin = filepath.Join(testTmpDir, \"testbin\")\n+\t\tif err := os.Mkdir(testBin, 0777); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t\ttestGo = filepath.Join(testBin, \"go\"+exeSuffix)\n+\t\targs := []string{\"build\", \"-tags\", \"testgo\", \"-o\", testGo}\n \t\tif race.Enabled {\n \t\t\targs = append(args, \"-race\")\n \t\t}\n@@ -165,7 +192,7 @@ func TestMain(m *testing.M) {\n \t\t}\n \t\ttestCC = strings.TrimSpace(string(out))\n \n-\t\tif out, err := exec.Command(\"./testgo\"+exeSuffix, \"env\", \"CGO_ENABLED\").Output(); err != nil {\n+\t\tif out, err := exec.Command(testGo, \"env\", \"CGO_ENABLED\").Output(); err != nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"running testgo failed: %v\\n\", err)\n \t\t\tcanRun = false\n \t\t} else {\n@@ -175,6 +202,13 @@ func TestMain(m *testing.M) {\n \t\t\t}\n \t\t}\n \n+\t\tout, err = exec.Command(gotool, \"env\", \"GOCACHE\").CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"could not find testing GOCACHE: %v\\n%s\", err, out)\n+\t\t\tos.Exit(2)\n+\t\t}\n+\t\ttestGOCACHE = strings.TrimSpace(string(out))\n+\n \t\t// As of Sept 2017, MSan is only supported on linux/amd64.\n \t\t// https://github.com/google/sanitizers/wiki/MemorySanitizer#getting-memorysanitizer\n \t\tcanMSan = canCgo && runtime.GOOS == \"linux\" && runtime.GOARCH == \"amd64\"\n@@ -190,21 +224,18 @@ func TestMain(m *testing.M) {\n \tos.Unsetenv(\"GOBIN\")\n \tos.Unsetenv(\"GOPATH\")\n \tos.Unsetenv(\"GIT_ALLOW_PROTOCOL\")\n-\tif home, ccacheDir := os.Getenv(\"HOME\"), os.Getenv(\"CCACHE_DIR\"); home != \"\" && ccacheDir == \"\" {\n-\t\t// On some systems the default C compiler is ccache.\n-\t\t// Setting HOME to a non-existent directory will break\n-\t\t// those systems. Set CCACHE_DIR to cope. Issue 17668.\n-\t\tos.Setenv(\"CCACHE_DIR\", filepath.Join(home, \".ccache\"))\n-\t}\n \tos.Setenv(\"HOME\", \"/test-go-home-does-not-exist\")\n+\t// On some systems the default C compiler is ccache.\n+\t// Setting HOME to a non-existent directory will break\n+\t// those systems. Disable ccache and use real compiler. Issue 17668.\n+\tos.Setenv(\"CCACHE_DISABLE\", \"1\")\n \tif os.Getenv(\"GOCACHE\") == \"\" {\n-\t\tos.Setenv(\"GOCACHE\", \"off\") // because $HOME is gone\n+\t\tos.Setenv(\"GOCACHE\", testGOCACHE) // because $HOME is gone\n \t}\n \n \tr := m.Run()\n-\n-\tif canRun {\n-\t\tos.Remove(\"testgo\" + exeSuffix)\n+\tif !*testWork {\n+\t\tremoveAll(testTmpDir) // os.Exit won't run defer\n \t}\n \n \tos.Exit(r)\n@@ -234,6 +265,7 @@ type testgoData struct {\n \tran            bool\n \tinParallel     bool\n \tstdout, stderr bytes.Buffer\n+\texecDir        string // dir for tg.run\n }\n \n // skipIfGccgo skips the test if using gccgo.\n@@ -352,10 +384,7 @@ func (tg *testgoData) unsetenv(name string) {\n }\n \n func (tg *testgoData) goTool() string {\n-\tif tg.wd == \"\" {\n-\t\treturn \"./testgo\" + exeSuffix\n-\t}\n-\treturn filepath.Join(tg.wd, \"testgo\"+exeSuffix)\n+\treturn testGo\n }\n \n // doRun runs the test go command, recording stdout and stderr and\n@@ -389,6 +418,7 @@ func (tg *testgoData) doRun(args []string) error {\n \tcmd := exec.Command(prog, args...)\n \ttg.stdout.Reset()\n \ttg.stderr.Reset()\n+\tcmd.Dir = tg.execDir\n \tcmd.Stdout = &tg.stdout\n \tcmd.Stderr = &tg.stderr\n \tcmd.Env = tg.env\n@@ -409,7 +439,8 @@ func (tg *testgoData) doRun(args []string) error {\n func (tg *testgoData) run(args ...string) {\n \ttg.t.Helper()\n \tif status := tg.doRun(args); status != nil {\n-\t\ttg.t.Logf(\"go %v failed unexpectedly: %v\", args, status)\n+\t\twd, _ := os.Getwd()\n+\t\ttg.t.Logf(\"go %v failed unexpectedly in %s: %v\", args, wd, status)\n \t\ttg.t.FailNow()\n \t}\n }\n@@ -735,7 +766,11 @@ func (tg *testgoData) wantStale(pkg, reason, msg string) {\n \tif !stale {\n \t\ttg.t.Fatal(msg)\n \t}\n-\tif reason == \"\" && why != \"\" || !strings.Contains(why, reason) {\n+\t// We always accept the reason as being \"not installed but\n+\t// available in build cache\", because when that is the case go\n+\t// list doesn't try to sort out the underlying reason why the\n+\t// package is not installed.\n+\tif reason == \"\" && why != \"\" || !strings.Contains(why, reason) && !strings.Contains(why, \"not installed but available in build cache\") {\n \t\ttg.t.Errorf(\"wrong reason for Stale=true: %q, want %q\", why, reason)\n \t}\n }\n@@ -752,24 +787,51 @@ func (tg *testgoData) wantNotStale(pkg, reason, msg string) {\n \t}\n }\n \n+// If -testwork is specified, the test prints the name of the temp directory\n+// and does not remove it when done, so that a programmer can\n+// poke at the test file tree afterward.\n+var testWork = flag.Bool(\"testwork\", false, \"\")\n+\n // cleanup cleans up a test that runs testgo.\n func (tg *testgoData) cleanup() {\n \ttg.t.Helper()\n \tif tg.wd != \"\" {\n+\t\twd, _ := os.Getwd()\n+\t\ttg.t.Logf(\"ended in %s\", wd)\n+\n \t\tif err := os.Chdir(tg.wd); err != nil {\n \t\t\t// We are unlikely to be able to continue.\n \t\t\tfmt.Fprintln(os.Stderr, \"could not restore working directory, crashing:\", err)\n \t\t\tos.Exit(2)\n \t\t}\n \t}\n+\tif *testWork {\n+\t\ttg.t.Logf(\"TESTWORK=%s\\n\", tg.path(\".\"))\n+\t\treturn\n+\t}\n \tfor _, path := range tg.temps {\n-\t\ttg.check(os.RemoveAll(path))\n+\t\ttg.check(removeAll(path))\n \t}\n \tif tg.tempdir != \"\" {\n-\t\ttg.check(os.RemoveAll(tg.tempdir))\n+\t\ttg.check(removeAll(tg.tempdir))\n \t}\n }\n \n+func removeAll(dir string) error {\n+\t// module cache has 0444 directories;\n+\t// make them writable in order to remove content.\n+\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n+\t\tif err != nil {\n+\t\t\treturn nil // ignore errors walking in file system\n+\t\t}\n+\t\tif info.IsDir() {\n+\t\t\tos.Chmod(path, 0777)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\treturn os.RemoveAll(dir)\n+}\n+\n // failSSH puts an ssh executable in the PATH that always fails.\n // This is to stub out uses of ssh by go get.\n func (tg *testgoData) failSSH() {\n@@ -782,92 +844,6 @@ func (tg *testgoData) failSSH() {\n \ttg.setenv(\"PATH\", fmt.Sprintf(\"%v%c%v\", fail, filepath.ListSeparator, os.Getenv(\"PATH\")))\n }\n \n-func TestBuildComplex(t *testing.T) {\n-\t// Simple smoke test for build configuration.\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"build\", \"-x\", \"-o\", os.DevNull, \"complex\")\n-\n-\tif _, err := exec.LookPath(\"gccgo\"); err == nil {\n-\t\ttg.run(\"build\", \"-x\", \"-o\", os.DevNull, \"-compiler=gccgo\", \"complex\")\n-\t}\n-}\n-\n-func TestFileLineInErrorMessages(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempFile(\"err.go\", `package main; import \"bar\"`)\n-\tpath := tg.path(\"err.go\")\n-\ttg.runFail(\"run\", path)\n-\tshortPath := path\n-\tif rel, err := filepath.Rel(tg.pwd(), path); err == nil && len(rel) < len(path) {\n-\t\tshortPath = rel\n-\t}\n-\ttg.grepStderr(\"^\"+regexp.QuoteMeta(shortPath)+\":\", \"missing file:line in error message\")\n-}\n-\n-func TestProgramNameInCrashMessages(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo does not use cmd/link\")\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempFile(\"triv.go\", `package main; func main() {}`)\n-\ttg.runFail(\"build\", \"-ldflags\", \"-crash_for_testing\", tg.path(\"triv.go\"))\n-\ttg.grepStderr(`[/\\\\]tool[/\\\\].*[/\\\\]link`, \"missing linker name in error message\")\n-}\n-\n-func TestBrokenTestsWithoutTestFunctionsAllFail(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\t// TODO: tg.parallel()\n-\ttg.runFail(\"test\", \"./testdata/src/badtest/...\")\n-\ttg.grepBothNot(\"^ok\", \"test passed unexpectedly\")\n-\ttg.grepBoth(\"FAIL.*badtest/badexec\", \"test did not run everything\")\n-\ttg.grepBoth(\"FAIL.*badtest/badsyntax\", \"test did not run everything\")\n-\ttg.grepBoth(\"FAIL.*badtest/badvar\", \"test did not run everything\")\n-}\n-\n-func TestGoBuildDashAInDevBranch(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"don't rebuild the standard library in short mode\")\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.run(\"install\", \"math\") // should be up to date already but just in case\n-\ttg.setenv(\"TESTGO_IS_GO_RELEASE\", \"0\")\n-\ttg.run(\"build\", \"-v\", \"-a\", \"math\")\n-\ttg.grepStderr(\"runtime\", \"testgo build -a math in dev branch DID NOT build runtime, but should have\")\n-\n-\t// Everything is out of date. Rebuild to leave things in a better state.\n-\ttg.run(\"install\", \"std\")\n-}\n-\n-func TestGoBuildDashAInReleaseBranch(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"don't rebuild the standard library in short mode\")\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.run(\"install\", \"math\", \"net/http\") // should be up to date already but just in case\n-\ttg.setenv(\"TESTGO_IS_GO_RELEASE\", \"1\")\n-\ttg.run(\"install\", \"-v\", \"-a\", \"math\")\n-\ttg.grepStderr(\"runtime\", \"testgo build -a math in release branch DID NOT build runtime, but should have\")\n-\n-\t// Now runtime.a is updated (newer mtime), so everything would look stale if not for being a release.\n-\ttg.run(\"build\", \"-v\", \"net/http\")\n-\ttg.grepStderrNot(\"strconv\", \"testgo build -v net/http in release branch with newer runtime.a DID build strconv but should not have\")\n-\ttg.grepStderrNot(\"golang.org/x/net/http2/hpack\", \"testgo build -v net/http in release branch with newer runtime.a DID build .../golang.org/x/net/http2/hpack but should not have\")\n-\ttg.grepStderrNot(\"net/http\", \"testgo build -v net/http in release branch with newer runtime.a DID build net/http but should not have\")\n-\n-\t// Everything is out of date. Rebuild to leave things in a better state.\n-\ttg.run(\"install\", \"std\")\n-}\n-\n func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Skip(\"don't rebuild the standard library in short mode\")\n@@ -876,13 +852,13 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \n-\taddNL := func(name string) (restore func()) {\n+\taddVar := func(name string, idx int) (restore func()) {\n \t\tdata, err := ioutil.ReadFile(name)\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n \t\told := data\n-\t\tdata = append(data, '\\n')\n+\t\tdata = append(data, fmt.Sprintf(\"var DummyUnusedVar%d bool\\n\", idx)...)\n \t\tif err := ioutil.WriteFile(name, append(data, '\\n'), 0666); err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n@@ -894,235 +870,45 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \t\t}\n \t}\n \n-\ttg.tempFile(\"d1/src/p1/p1.go\", `package p1`)\n+\t// Every main package depends on the \"runtime\".\n+\ttg.tempFile(\"d1/src/p1/p1.go\", `package main; func main(){}`)\n \ttg.setenv(\"GOPATH\", tg.path(\"d1\"))\n-\ttg.run(\"install\", \"-a\", \"p1\")\n+\t// Pass -i flag to rebuild everything outdated.\n+\ttg.run(\"install\", \"-i\", \"p1\")\n \ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly, before any changes\")\n \n \t// Changing mtime of runtime/internal/sys/sys.go\n \t// should have no effect: only the content matters.\n \t// In fact this should be true even outside a release branch.\n \tsys := runtime.GOROOT() + \"/src/runtime/internal/sys/sys.go\"\n \ttg.sleep()\n-\trestore := addNL(sys)\n+\trestore := addVar(sys, 0)\n \trestore()\n \ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly, after updating mtime of runtime/internal/sys/sys.go\")\n \n \t// But changing content of any file should have an effect.\n \t// Previously zversion.go was the only one that mattered;\n \t// now they all matter, so keep using sys.go.\n-\trestore = addNL(sys)\n+\trestore = addVar(sys, 1)\n \tdefer restore()\n \ttg.wantStale(\"p1\", \"stale dependency: runtime/internal/sys\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing sys.go\")\n \trestore()\n \ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly, after changing back to old release\")\n-\taddNL(sys)\n+\taddVar(sys, 2)\n \ttg.wantStale(\"p1\", \"stale dependency: runtime/internal/sys\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing sys.go again\")\n-\ttg.run(\"install\", \"p1\")\n+\ttg.run(\"install\", \"-i\", \"p1\")\n \ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale after building with new release\")\n \n \t// Restore to \"old\" release.\n \trestore()\n \ttg.wantStale(\"p1\", \"stale dependency: runtime/internal/sys\", \"./testgo list claims p1 is NOT stale, incorrectly, after restoring sys.go\")\n-\ttg.run(\"install\", \"p1\")\n+\ttg.run(\"install\", \"-i\", \"p1\")\n \ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale after building with old release\")\n \n \t// Everything is out of date. Rebuild to leave things in a better state.\n \ttg.run(\"install\", \"std\")\n }\n \n-func TestGoListStandard(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo does not GOROOT\")\n-\ttooSlow(t)\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\t// TODO: tg.parallel()\n-\ttg.cd(runtime.GOROOT() + \"/src\")\n-\ttg.run(\"list\", \"-f\", \"{{if not .Standard}}{{.ImportPath}}{{end}}\", \"./...\")\n-\tstdout := tg.getStdout()\n-\tfor _, line := range strings.Split(stdout, \"\\n\") {\n-\t\tif strings.HasPrefix(line, \"_/\") && strings.HasSuffix(line, \"/src\") {\n-\t\t\t// $GOROOT/src shows up if there are any .go files there.\n-\t\t\t// We don't care.\n-\t\t\tcontinue\n-\t\t}\n-\t\tif line == \"\" {\n-\t\t\tcontinue\n-\t\t}\n-\t\tt.Errorf(\"package in GOROOT not listed as standard: %v\", line)\n-\t}\n-\n-\t// Similarly, expanding std should include some of our vendored code.\n-\ttg.run(\"list\", \"std\", \"cmd\")\n-\ttg.grepStdout(\"golang.org/x/net/http2/hpack\", \"list std cmd did not mention vendored hpack\")\n-\ttg.grepStdout(\"golang.org/x/arch/x86/x86asm\", \"list std cmd did not mention vendored x86asm\")\n-}\n-\n-func TestGoInstallCleansUpAfterGoBuild(t *testing.T) {\n-\ttooSlow(t)\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\t// TODO: tg.parallel()\n-\ttg.tempFile(\"src/mycmd/main.go\", `package main; func main(){}`)\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.cd(tg.path(\"src/mycmd\"))\n-\n-\tdoesNotExist := func(file, msg string) {\n-\t\tif _, err := os.Stat(file); err == nil {\n-\t\t\tt.Fatal(msg)\n-\t\t} else if !os.IsNotExist(err) {\n-\t\t\tt.Fatal(msg, \"error:\", err)\n-\t\t}\n-\t}\n-\n-\ttg.run(\"build\")\n-\ttg.wantExecutable(\"mycmd\"+exeSuffix, \"testgo build did not write command binary\")\n-\ttg.run(\"install\")\n-\tdoesNotExist(\"mycmd\"+exeSuffix, \"testgo install did not remove command binary\")\n-\ttg.run(\"build\")\n-\ttg.wantExecutable(\"mycmd\"+exeSuffix, \"testgo build did not write command binary (second time)\")\n-\t// Running install with arguments does not remove the target,\n-\t// even in the same directory.\n-\ttg.run(\"install\", \"mycmd\")\n-\ttg.wantExecutable(\"mycmd\"+exeSuffix, \"testgo install mycmd removed command binary when run in mycmd\")\n-\ttg.run(\"build\")\n-\ttg.wantExecutable(\"mycmd\"+exeSuffix, \"testgo build did not write command binary (third time)\")\n-\t// And especially not outside the directory.\n-\ttg.cd(tg.path(\".\"))\n-\tif data, err := ioutil.ReadFile(\"src/mycmd/mycmd\" + exeSuffix); err != nil {\n-\t\tt.Fatal(\"could not read file:\", err)\n-\t} else {\n-\t\tif err := ioutil.WriteFile(\"mycmd\"+exeSuffix, data, 0555); err != nil {\n-\t\t\tt.Fatal(\"could not write file:\", err)\n-\t\t}\n-\t}\n-\ttg.run(\"install\", \"mycmd\")\n-\ttg.wantExecutable(\"src/mycmd/mycmd\"+exeSuffix, \"testgo install mycmd removed command binary from its source dir when run outside mycmd\")\n-\ttg.wantExecutable(\"mycmd\"+exeSuffix, \"testgo install mycmd removed command binary from current dir when run outside mycmd\")\n-}\n-\n-func TestGoInstallRebuildsStalePackagesInOtherGOPATH(t *testing.T) {\n-\ttooSlow(t)\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempFile(\"d1/src/p1/p1.go\", `package p1\n-\t\timport \"p2\"\n-\t\tfunc F() { p2.F() }`)\n-\ttg.tempFile(\"d2/src/p2/p2.go\", `package p2\n-\t\tfunc F() {}`)\n-\tsep := string(filepath.ListSeparator)\n-\ttg.setenv(\"GOPATH\", tg.path(\"d1\")+sep+tg.path(\"d2\"))\n-\ttg.run(\"install\", \"-i\", \"p1\")\n-\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly\")\n-\ttg.wantNotStale(\"p2\", \"\", \"./testgo list claims p2 is stale, incorrectly\")\n-\ttg.sleep()\n-\tif f, err := os.OpenFile(tg.path(\"d2/src/p2/p2.go\"), os.O_WRONLY|os.O_APPEND, 0); err != nil {\n-\t\tt.Fatal(err)\n-\t} else if _, err = f.WriteString(`func G() {}`); err != nil {\n-\t\tt.Fatal(err)\n-\t} else {\n-\t\ttg.must(f.Close())\n-\t}\n-\ttg.wantStale(\"p2\", \"build ID mismatch\", \"./testgo list claims p2 is NOT stale, incorrectly\")\n-\ttg.wantStale(\"p1\", \"stale dependency: p2\", \"./testgo list claims p1 is NOT stale, incorrectly\")\n-\n-\ttg.run(\"install\", \"-i\", \"p1\")\n-\ttg.wantNotStale(\"p2\", \"\", \"./testgo list claims p2 is stale after reinstall, incorrectly\")\n-\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale after reinstall, incorrectly\")\n-}\n-\n-func TestGoInstallDetectsRemovedFiles(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempFile(\"src/mypkg/x.go\", `package mypkg`)\n-\ttg.tempFile(\"src/mypkg/y.go\", `package mypkg`)\n-\ttg.tempFile(\"src/mypkg/z.go\", `// +build missingtag\n-\n-\t\tpackage mypkg`)\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"install\", \"mypkg\")\n-\ttg.wantNotStale(\"mypkg\", \"\", \"./testgo list mypkg claims mypkg is stale, incorrectly\")\n-\t// z.go was not part of the build; removing it is okay.\n-\ttg.must(os.Remove(tg.path(\"src/mypkg/z.go\")))\n-\ttg.wantNotStale(\"mypkg\", \"\", \"./testgo list mypkg claims mypkg is stale after removing z.go; should not be stale\")\n-\t// y.go was part of the package; removing it should be detected.\n-\ttg.must(os.Remove(tg.path(\"src/mypkg/y.go\")))\n-\ttg.wantStale(\"mypkg\", \"build ID mismatch\", \"./testgo list mypkg claims mypkg is NOT stale after removing y.go; should be stale\")\n-}\n-\n-func TestWildcardMatchesSyntaxErrorDirs(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\t// TODO: tg.parallel()\n-\ttg.tempFile(\"src/mypkg/x.go\", `package mypkg`)\n-\ttg.tempFile(\"src/mypkg/y.go\", `pkg mypackage`)\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.cd(tg.path(\"src/mypkg\"))\n-\ttg.runFail(\"list\", \"./...\")\n-\ttg.runFail(\"build\", \"./...\")\n-\ttg.runFail(\"install\", \"./...\")\n-}\n-\n-func TestGoListWithTags(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.tempFile(\"src/mypkg/x.go\", \"// +build thetag\\n\\npackage mypkg\\n\")\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.cd(tg.path(\"./src\"))\n-\ttg.run(\"list\", \"-tags=thetag\", \"./my...\")\n-\ttg.grepStdout(\"mypkg\", \"did not find mypkg\")\n-}\n-\n-func TestGoInstallErrorOnCrossCompileToBin(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"don't install into GOROOT in short mode\")\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.tempFile(\"src/mycmd/x.go\", `package main\n-\t\tfunc main() {}`)\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.cd(tg.path(\"src/mycmd\"))\n-\n-\ttg.run(\"build\", \"mycmd\")\n-\n-\tgoarch := \"386\"\n-\tif runtime.GOARCH == \"386\" {\n-\t\tgoarch = \"amd64\"\n-\t}\n-\ttg.setenv(\"GOOS\", \"linux\")\n-\ttg.setenv(\"GOARCH\", goarch)\n-\ttg.run(\"install\", \"mycmd\")\n-\ttg.setenv(\"GOBIN\", tg.path(\".\"))\n-\ttg.runFail(\"install\", \"mycmd\")\n-\ttg.run(\"install\", \"cmd/pack\")\n-}\n-\n-func TestGoInstallDetectsRemovedFilesInPackageMain(t *testing.T) {\n-\ttooSlow(t)\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempFile(\"src/mycmd/x.go\", `package main\n-\t\tfunc main() {}`)\n-\ttg.tempFile(\"src/mycmd/y.go\", `package main`)\n-\ttg.tempFile(\"src/mycmd/z.go\", `// +build missingtag\n-\n-\t\tpackage main`)\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"install\", \"mycmd\")\n-\ttg.wantNotStale(\"mycmd\", \"\", \"./testgo list mypkg claims mycmd is stale, incorrectly\")\n-\t// z.go was not part of the build; removing it is okay.\n-\ttg.must(os.Remove(tg.path(\"src/mycmd/z.go\")))\n-\ttg.wantNotStale(\"mycmd\", \"\", \"./testgo list mycmd claims mycmd is stale after removing z.go; should not be stale\")\n-\t// y.go was part of the package; removing it should be detected.\n-\ttg.must(os.Remove(tg.path(\"src/mycmd/y.go\")))\n-\ttg.wantStale(\"mycmd\", \"build ID mismatch\", \"./testgo list mycmd claims mycmd is NOT stale after removing y.go; should be stale\")\n-}\n-\n func testLocalRun(tg *testgoData, exepath, local, match string) {\n \ttg.t.Helper()\n \tout, err := exec.Command(exepath).Output()\n@@ -1250,14 +1036,14 @@ func TestInternalPackagesInGOROOTAreRespected(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.runFail(\"build\", \"-v\", \"./testdata/testinternal\")\n-\ttg.grepBoth(`testinternal(\\/|\\\\)p\\.go\\:3\\:8\\: use of internal package not allowed`, \"wrong error message for testdata/testinternal\")\n+\ttg.grepBoth(`testinternal(\\/|\\\\)p\\.go\\:3\\:8\\: use of internal package net/http/internal not allowed`, \"wrong error message for testdata/testinternal\")\n }\n \n func TestInternalPackagesOutsideGOROOTAreRespected(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.runFail(\"build\", \"-v\", \"./testdata/testinternal2\")\n-\ttg.grepBoth(`testinternal2(\\/|\\\\)p\\.go\\:3\\:8\\: use of internal package not allowed`, \"wrote error message for testdata/testinternal2\")\n+\ttg.grepBoth(`testinternal2(\\/|\\\\)p\\.go\\:3\\:8\\: use of internal package .*internal/w not allowed`, \"wrote error message for testdata/testinternal2\")\n }\n \n func TestRunInternal(t *testing.T) {\n@@ -1267,7 +1053,19 @@ func TestRunInternal(t *testing.T) {\n \ttg.setenv(\"GOPATH\", dir)\n \ttg.run(\"run\", filepath.Join(dir, \"src/run/good.go\"))\n \ttg.runFail(\"run\", filepath.Join(dir, \"src/run/bad.go\"))\n-\ttg.grepStderr(`testdata(\\/|\\\\)src(\\/|\\\\)run(\\/|\\\\)bad\\.go\\:3\\:8\\: use of internal package not allowed`, \"unexpected error for run/bad.go\")\n+\ttg.grepStderr(`testdata(\\/|\\\\)src(\\/|\\\\)run(\\/|\\\\)bad\\.go\\:3\\:8\\: use of internal package run/subdir/internal/private not allowed`, \"unexpected error for run/bad.go\")\n+}\n+\n+func TestRunPkg(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tdir := filepath.Join(tg.pwd(), \"testdata\")\n+\ttg.setenv(\"GOPATH\", dir)\n+\ttg.run(\"run\", \"hello\")\n+\ttg.grepStderr(\"hello, world\", \"did not find hello, world\")\n+\ttg.cd(filepath.Join(dir, \"src/hello\"))\n+\ttg.run(\"run\", \".\")\n+\ttg.grepStderr(\"hello, world\", \"did not find hello, world\")\n }\n \n func testMove(t *testing.T, vcs, url, base, config string) {\n@@ -1368,6 +1166,41 @@ func TestImportCommentConflict(t *testing.T) {\n \ttg.grepStderr(\"found import comments\", \"go build did not mention comment conflict\")\n }\n \n+func TestImportCycle(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/importcycle\"))\n+\ttg.runFail(\"build\", \"selfimport\")\n+\n+\tcount := tg.grepCountBoth(\"import cycle not allowed\")\n+\tif count == 0 {\n+\t\tt.Fatal(\"go build did not mention cyclical import\")\n+\t}\n+\tif count > 1 {\n+\t\tt.Fatal(\"go build mentioned import cycle more than once\")\n+\t}\n+\n+\t// Don't hang forever.\n+\ttg.run(\"list\", \"-e\", \"-json\", \"selfimport\")\n+}\n+\n+func TestListImportMap(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo does not have standard packages\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.run(\"list\", \"-f\", \"{{.ImportPath}}: {{.ImportMap}}\", \"net\", \"fmt\")\n+\ttg.grepStdout(`^net: map\\[(.* )?golang_org/x/net/dns/dnsmessage:vendor/golang_org/x/net/dns/dnsmessage.*\\]`, \"net/http should have rewritten dnsmessage import\")\n+\ttg.grepStdout(`^fmt: map\\[\\]`, \"fmt should have no rewritten imports\")\n+\ttg.run(\"list\", \"-deps\", \"-test\", \"-f\", \"{{.ImportPath}} MAP: {{.ImportMap}}\\n{{.ImportPath}} IMPORT: {{.Imports}}\", \"fmt\")\n+\ttg.grepStdout(`^flag \\[fmt\\.test\\] MAP: map\\[fmt:fmt \\[fmt\\.test\\]\\]`, \"flag [fmt.test] should import fmt [fmt.test] as fmt\")\n+\ttg.grepStdout(`^fmt\\.test MAP: map\\[(.* )?testing:testing \\[fmt\\.test\\]`, \"fmt.test should import testing [fmt.test] as testing\")\n+\ttg.grepStdout(`^fmt\\.test MAP: map\\[(.* )?testing:testing \\[fmt\\.test\\]`, \"fmt.test should import testing [fmt.test] as testing\")\n+\ttg.grepStdoutNot(`^fmt\\.test MAP: map\\[(.* )?os:`, \"fmt.test should not import a modified os\")\n+\ttg.grepStdout(`^fmt\\.test IMPORT: \\[fmt \\[fmt\\.test\\] fmt_test \\[fmt\\.test\\] os testing \\[fmt\\.test\\] testing/internal/testdeps \\[fmt\\.test\\]\\]`, \"wrong imports for fmt.test\")\n+}\n+\n // cmd/go: custom import path checking should not apply to Go packages without import comment.\n func TestIssue10952(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n@@ -1459,6 +1292,7 @@ func TestGetGitDefaultBranch(t *testing.T) {\n \ttg.grepStdout(`\\* another-branch`, \"not on correct default branch\")\n }\n \n+// Security issue. Don't disable. See golang.org/issue/22125.\n func TestAccidentalGitCheckout(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \tif _, err := exec.LookPath(\"git\"); err != nil {\n@@ -1469,21 +1303,26 @@ func TestAccidentalGitCheckout(t *testing.T) {\n \tdefer tg.cleanup()\n \ttg.parallel()\n \ttg.tempDir(\"src\")\n+\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \n \ttg.runFail(\"get\", \"-u\", \"vcs-test.golang.org/go/test1-svn-git\")\n \ttg.grepStderr(\"src[\\\\\\\\/]vcs-test.* uses git, but parent .*src[\\\\\\\\/]vcs-test.* uses svn\", \"get did not fail for right reason\")\n \n-\ttg.runFail(\"get\", \"-u\", \"vcs-test.golang.org/go/test2-svn-git/test2main\")\n-\ttg.grepStderr(\"src[\\\\\\\\/]vcs-test.* uses git, but parent .*src[\\\\\\\\/]vcs-test.* uses svn\", \"get did not fail for right reason\")\n+\tif _, err := os.Stat(tg.path(\"SrC\")); err == nil {\n+\t\t// This case only triggers on a case-insensitive file system.\n+\t\ttg.runFail(\"get\", \"-u\", \"vcs-test.golang.org/go/test2-svn-git/test2main\")\n+\t\ttg.grepStderr(\"src[\\\\\\\\/]vcs-test.* uses git, but parent .*src[\\\\\\\\/]vcs-test.* uses svn\", \"get did not fail for right reason\")\n+\t}\n }\n \n func TestErrorMessageForSyntaxErrorInTestGoFileSaysFAIL(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.runFail(\"test\", \"syntaxerror\")\n-\ttg.grepStderr(\"FAIL\", \"go test did not say FAIL\")\n+\ttg.grepStderr(\"x_test.go:\", \"did not diagnose error\")\n+\ttg.grepStdout(\"FAIL\", \"go test did not say FAIL\")\n }\n \n func TestWildcardsDoNotLookInUselessDirectories(t *testing.T) {\n@@ -1580,6 +1419,7 @@ func TestRelativeGOBINFail(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.tempFile(\"triv.go\", `package main; func main() {}`)\n+\ttg.cd(tg.path(\".\"))\n \ttg.setenv(\"GOBIN\", \".\")\n \ttg.runFail(\"install\")\n \ttg.grepStderr(\"cannot install, GOBIN must be an absolute path\", \"go install must fail if $GOBIN is a relative path\")\n@@ -1634,12 +1474,6 @@ func TestPackageMainTestCompilerFlags(t *testing.T) {\n \ttg.grepStderr(`([\\\\/]compile|gccgo).* (-p p1|-fgo-pkgpath=p1).*p1\\.go`, \"should have run compile -p p1 p1.go\")\n }\n \n-// The runtime version string takes one of two forms:\n-// \"go1.X[.Y]\" for Go releases, and \"devel +hash\" at tip.\n-// Determine whether we are in a released copy by\n-// inspecting the version.\n-var isGoRelease = strings.HasPrefix(runtime.Version(), \"go1\")\n-\n // Issue 12690\n func TestPackageNotStaleWithTrailingSlash(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not have GOROOT\")\n@@ -1727,8 +1561,8 @@ func TestGoGetTestOnlyPkg(t *testing.T) {\n \tdefer tg.cleanup()\n \ttg.tempDir(\"gopath\")\n \ttg.setenv(\"GOPATH\", tg.path(\"gopath\"))\n-\ttg.run(\"get\", \"golang.org/x/tour/content\")\n-\ttg.run(\"get\", \"-t\", \"golang.org/x/tour/content\")\n+\ttg.run(\"get\", \"golang.org/x/tour/content...\")\n+\ttg.run(\"get\", \"-t\", \"golang.org/x/tour/content...\")\n }\n \n func TestInstalls(t *testing.T) {\n@@ -1854,7 +1688,7 @@ func TestGoListStdDoesNotIncludeCommands(t *testing.T) {\n }\n \n func TestGoListCmdOnlyShowsCommands(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo has no GOROOT\")\n+\tskipIfGccgo(t, \"gccgo does not have GOROOT\")\n \ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1894,6 +1728,118 @@ func TestGoListDeps(t *testing.T) {\n \ttg.tempFile(\"src/p1/p2/p3/p4/p.go\", \"package p4\\n\")\n \ttg.run(\"list\", \"-f\", \"{{.Deps}}\", \"p1\")\n \ttg.grepStdout(\"p1/p2/p3/p4\", \"Deps(p1) does not mention p4\")\n+\n+\ttg.run(\"list\", \"-deps\", \"p1\")\n+\ttg.grepStdout(\"p1/p2/p3/p4\", \"-deps p1 does not mention p4\")\n+\n+\tif runtime.Compiler != \"gccgo\" {\n+\t\t// Check the list is in dependency order.\n+\t\ttg.run(\"list\", \"-deps\", \"math\")\n+\t\twant := \"internal/cpu\\nunsafe\\nmath\\n\"\n+\t\tout := tg.stdout.String()\n+\t\tif !strings.Contains(out, \"internal/cpu\") {\n+\t\t\t// Some systems don't use internal/cpu.\n+\t\t\twant = \"unsafe\\nmath\\n\"\n+\t\t}\n+\t\tif tg.stdout.String() != want {\n+\t\t\tt.Fatalf(\"list -deps math: wrong order\\nhave %q\\nwant %q\", tg.stdout.String(), want)\n+\t\t}\n+\t}\n+}\n+\n+func TestGoListTest(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo does not have standard packages\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOCACHE\", tg.tempdir)\n+\n+\ttg.run(\"list\", \"-test\", \"-deps\", \"sort\")\n+\ttg.grepStdout(`^sort.test$`, \"missing test main\")\n+\ttg.grepStdout(`^sort$`, \"missing real sort\")\n+\ttg.grepStdout(`^sort \\[sort.test\\]$`, \"missing test copy of sort\")\n+\ttg.grepStdout(`^testing \\[sort.test\\]$`, \"missing test copy of testing\")\n+\ttg.grepStdoutNot(`^testing$`, \"unexpected real copy of testing\")\n+\n+\ttg.run(\"list\", \"-test\", \"sort\")\n+\ttg.grepStdout(`^sort.test$`, \"missing test main\")\n+\ttg.grepStdout(`^sort$`, \"missing real sort\")\n+\ttg.grepStdout(`^sort \\[sort.test\\]$`, \"unexpected test copy of sort\")\n+\ttg.grepStdoutNot(`^testing \\[sort.test\\]$`, \"unexpected test copy of testing\")\n+\ttg.grepStdoutNot(`^testing$`, \"unexpected real copy of testing\")\n+\n+\ttg.run(\"list\", \"-test\", \"cmd/dist\", \"cmd/doc\")\n+\ttg.grepStdout(`^cmd/dist$`, \"missing cmd/dist\")\n+\ttg.grepStdout(`^cmd/doc$`, \"missing cmd/doc\")\n+\ttg.grepStdout(`^cmd/doc\\.test$`, \"missing cmd/doc test\")\n+\ttg.grepStdoutNot(`^cmd/dist\\.test$`, \"unexpected cmd/dist test\")\n+\ttg.grepStdoutNot(`^testing`, \"unexpected testing\")\n+\n+\ttg.run(\"list\", \"-test\", \"runtime/cgo\")\n+\ttg.grepStdout(`^runtime/cgo$`, \"missing runtime/cgo\")\n+\n+\ttg.run(\"list\", \"-deps\", \"-f\", \"{{if .DepOnly}}{{.ImportPath}}{{end}}\", \"sort\")\n+\ttg.grepStdout(`^reflect$`, \"missing reflect\")\n+\ttg.grepStdoutNot(`^sort`, \"unexpected sort\")\n+}\n+\n+func TestGoListCompiledCgo(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOCACHE\", tg.tempdir)\n+\n+\ttg.run(\"list\", \"-f\", `{{join .CgoFiles \"\\n\"}}`, \"net\")\n+\tif tg.stdout.String() == \"\" {\n+\t\tt.Skip(\"net does not use cgo\")\n+\t}\n+\tif strings.Contains(tg.stdout.String(), tg.tempdir) {\n+\t\tt.Fatalf(\".CgoFiles unexpectedly mentioned cache %s\", tg.tempdir)\n+\t}\n+\ttg.run(\"list\", \"-compiled\", \"-f\", `{{.Dir}}{{\"\\n\"}}{{join .CompiledGoFiles \"\\n\"}}`, \"net\")\n+\tif !strings.Contains(tg.stdout.String(), tg.tempdir) {\n+\t\tt.Fatalf(\".CompiledGoFiles with -compiled did not mention cache %s\", tg.tempdir)\n+\t}\n+\tdir := \"\"\n+\tfor _, file := range strings.Split(tg.stdout.String(), \"\\n\") {\n+\t\tif file == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif dir == \"\" {\n+\t\t\tdir = file\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !strings.Contains(file, \"/\") && !strings.Contains(file, `\\`) {\n+\t\t\tfile = filepath.Join(dir, file)\n+\t\t}\n+\t\tif _, err := os.Stat(file); err != nil {\n+\t\t\tt.Fatalf(\"cannot find .CompiledGoFiles result %s: %v\", file, err)\n+\t\t}\n+\t}\n+}\n+\n+func TestGoListExport(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo does not have standard packages\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOCACHE\", tg.tempdir)\n+\n+\ttg.run(\"list\", \"-f\", \"{{.Export}}\", \"strings\")\n+\tif tg.stdout.String() != \"\" {\n+\t\tt.Fatalf(\".Export without -export unexpectedly set\")\n+\t}\n+\ttg.run(\"list\", \"-export\", \"-f\", \"{{.Export}}\", \"strings\")\n+\tfile := strings.TrimSpace(tg.stdout.String())\n+\tif file == \"\" {\n+\t\tt.Fatalf(\".Export with -export was empty\")\n+\t}\n+\tif _, err := os.Stat(file); err != nil {\n+\t\tt.Fatalf(\"cannot find .Export result %s: %v\", file, err)\n+\t}\n }\n \n // Issue 4096. Validate the output of unsuccessful go install foo/quxx.\n@@ -1962,7 +1908,18 @@ func homeEnvName() string {\n \tcase \"plan9\":\n \t\treturn \"home\"\n \tdefault:\n-\t\treturn \"HOME\"\n+\t\treturn \"HOME\"\n+\t}\n+}\n+\n+func tempEnvName() string {\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\treturn \"TMP\"\n+\tcase \"plan9\":\n+\t\treturn \"TMPDIR\" // actually plan 9 doesn't have one at all but this is fine\n+\tdefault:\n+\t\treturn \"TMPDIR\"\n \t}\n }\n \n@@ -2635,6 +2592,18 @@ func TestCoverageFunc(t *testing.T) {\n \ttg.grepStdoutNot(`\\tf\\t*[0-9]`, \"reported coverage for assembly function f\")\n }\n \n+// Issue 24588.\n+func TestCoverageDashC(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"test\", \"-c\", \"-o\", tg.path(\"coverdep\"), \"-coverprofile=\"+tg.path(\"no/such/dir/cover.out\"), \"coverdep\")\n+\ttg.wantExecutable(tg.path(\"coverdep\"), \"go -test -c -coverprofile did not create executable\")\n+}\n+\n func TestPluginNonMain(t *testing.T) {\n \twd, err := os.Getwd()\n \tif err != nil {\n@@ -2845,7 +2814,7 @@ func TestCgoPkgConfig(t *testing.T) {\n \t// OpenBSD's pkg-config is strict about whitespace and only\n \t// supports backslash-escaped whitespace. It does not support\n \t// quotes, which the normal freedesktop.org pkg-config does\n-\t// support. See http://man.openbsd.org/pkg-config.1\n+\t// support. See https://man.openbsd.org/pkg-config.1\n \ttg.tempFile(\"foo.pc\", `\n Name: foo\n Description: The foo library\n@@ -3048,11 +3017,25 @@ func TestBuildDashIInstallsDependencies(t *testing.T) {\n \tcheckbar(\"cmd\")\n }\n \n-func TestGoBuildInTestOnlyDirectoryFailsWithAGoodError(t *testing.T) {\n+func TestGoBuildTestOnly(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n-\ttg.runFail(\"build\", \"./testdata/testonly\")\n-\ttg.grepStderr(\"no non-test Go files in\", \"go build ./testdata/testonly produced unexpected error\")\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.tempFile(\"src/testonly/t_test.go\", `package testonly`)\n+\ttg.tempFile(\"src/testonly2/t.go\", `package testonly2`)\n+\ttg.cd(tg.path(\"src\"))\n+\n+\t// Named explicitly, test-only packages should be reported as unbuildable/uninstallable,\n+\t// even if there is a wildcard also matching.\n+\ttg.runFail(\"build\", \"testonly\", \"testonly...\")\n+\ttg.grepStderr(\"no non-test Go files in\", \"go build ./xtestonly produced unexpected error\")\n+\ttg.runFail(\"install\", \"./testonly\")\n+\ttg.grepStderr(\"no non-test Go files in\", \"go install ./testonly produced unexpected error\")\n+\n+\t// Named through a wildcards, the test-only packages should be silently ignored.\n+\ttg.run(\"build\", \"testonly...\")\n+\ttg.run(\"install\", \"./testonly...\")\n }\n \n func TestGoTestDetectsTestOnlyImportCycles(t *testing.T) {\n@@ -3088,6 +3071,9 @@ func TestGoTestMainAsNormalTest(t *testing.T) {\n }\n \n func TestGoTestMainTwice(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping in short mode\")\n+\t}\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n@@ -3182,6 +3168,22 @@ func TestGoGenerateEnv(t *testing.T) {\n \t}\n }\n \n+func TestGoGenerateXTestPkgName(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"skipping because windows has no echo command\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"env_test.go\", \"package main_test\\n\\n//go:generate echo $GOPACKAGE\")\n+\ttg.run(\"generate\", tg.path(\"env_test.go\"))\n+\twant := \"main_test\"\n+\tif got := strings.TrimSpace(tg.getStdout()); got != want {\n+\t\tt.Errorf(\"go generate in XTest file got package name %q; want %q\", got, want)\n+\t}\n+}\n+\n func TestGoGenerateBadImports(t *testing.T) {\n \tif runtime.GOOS == \"windows\" {\n \t\tt.Skip(\"skipping because windows has no echo command\")\n@@ -3549,24 +3551,43 @@ func TestImportLocal(t *testing.T) {\n }\n \n func TestGoGetInsecure(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n+\ttest := func(t *testing.T, modules bool) {\n+\t\ttestenv.MustHaveExternalNetwork(t)\n+\n+\t\ttg := testgo(t)\n+\t\tdefer tg.cleanup()\n+\t\ttg.makeTempdir()\n+\t\ttg.failSSH()\n+\n+\t\tif modules {\n+\t\t\ttg.setenv(\"GOPATH\", tg.path(\"gp\"))\n+\t\t\ttg.tempFile(\"go.mod\", \"module m\")\n+\t\t\ttg.cd(tg.path(\".\"))\n+\t\t\ttg.setenv(\"GO111MODULE\", \"on\")\n+\t\t} else {\n+\t\t\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\t\t\ttg.setenv(\"GO111MODULE\", \"off\")\n+\t\t}\n \n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.failSSH()\n+\t\tconst repo = \"insecure.go-get-issue-15410.appspot.com/pkg/p\"\n \n-\tconst repo = \"insecure.go-get-issue-15410.appspot.com/pkg/p\"\n+\t\t// Try go get -d of HTTP-only repo (should fail).\n+\t\ttg.runFail(\"get\", \"-d\", repo)\n \n-\t// Try go get -d of HTTP-only repo (should fail).\n-\ttg.runFail(\"get\", \"-d\", repo)\n+\t\t// Try again with -insecure (should succeed).\n+\t\ttg.run(\"get\", \"-d\", \"-insecure\", repo)\n \n-\t// Try again with -insecure (should succeed).\n-\ttg.run(\"get\", \"-d\", \"-insecure\", repo)\n+\t\t// Try updating without -insecure (should fail).\n+\t\ttg.runFail(\"get\", \"-d\", \"-u\", \"-f\", repo)\n+\n+\t\tif modules {\n+\t\t\ttg.run(\"list\", \"-m\", \"...\")\n+\t\t\ttg.grepStdout(\"insecure.go-get-issue\", \"should find insecure module\")\n+\t\t}\n+\t}\n \n-\t// Try updating without -insecure (should fail).\n-\ttg.runFail(\"get\", \"-d\", \"-u\", \"-f\", repo)\n+\tt.Run(\"gopath\", func(t *testing.T) { test(t, false) })\n+\tt.Run(\"modules\", func(t *testing.T) { test(t, true) })\n }\n \n func TestGoGetUpdateInsecure(t *testing.T) {\n@@ -3593,6 +3614,40 @@ func TestGoGetUpdateInsecure(t *testing.T) {\n \ttg.run(\"get\", \"-d\", \"-u\", \"-f\", \"-insecure\", pkg)\n }\n \n+func TestGoGetUpdateUnknownProtocol(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\tconst repo = \"github.com/golang/example\"\n+\n+\t// Clone the repo via HTTPS manually.\n+\trepoDir := tg.path(\"src/\" + repo)\n+\tcmd := exec.Command(\"git\", \"clone\", \"-q\", \"https://\"+repo, repoDir)\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Fatalf(\"cloning %v repo: %v\\n%s\", repo, err, out)\n+\t}\n+\n+\t// Configure the repo to use a protocol unknown to cmd/go\n+\t// that still actually works.\n+\tcmd = exec.Command(\"git\", \"remote\", \"set-url\", \"origin\", \"xyz://\"+repo)\n+\tcmd.Dir = repoDir\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Fatalf(\"git remote set-url: %v\\n%s\", err, out)\n+\t}\n+\tcmd = exec.Command(\"git\", \"config\", \"--local\", \"url.https://github.com/.insteadOf\", \"xyz://github.com/\")\n+\tcmd.Dir = repoDir\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Fatalf(\"git config: %v\\n%s\", err, out)\n+\t}\n+\n+\t// We need -f to ignore import comments.\n+\ttg.run(\"get\", \"-d\", \"-u\", \"-f\", repo+\"/hello\")\n+}\n+\n func TestGoGetInsecureCustomDomain(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n@@ -4175,9 +4230,10 @@ func TestGoGetUpdateWithWildcard(t *testing.T) {\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \tconst aPkgImportPath = \"github.com/tmwh/go-get-issue-14450/a\"\n \ttg.run(\"get\", aPkgImportPath)\n-\ttg.run(\"get\", \"-u\", \".../\")\n-\ttg.grepStderrNot(\"cannot find package\", \"did not update packages given wildcard path\")\n+\ttg.runFail(\"get\", \"-u\", \".../\")\n+\ttg.grepStderr(\"cannot find package.*d-dependency/e\", \"should have detected e missing\")\n \n+\t// Even though get -u failed, the source for others should be downloaded.\n \tvar expectedPkgPaths = []string{\n \t\t\"src/github.com/tmwh/go-get-issue-14450/b\",\n \t\t\"src/github.com/tmwh/go-get-issue-14450-b-dependency/c\",\n@@ -4754,7 +4810,7 @@ func main() {}`)\n \t\t\tbefore()\n \t\t\ttg.run(\"install\", \"mycmd\")\n \t\t\tafter()\n-\t\t\ttg.wantStale(\"mycmd\", \"stale dependency: runtime/internal/sys\", \"should be stale after environment variable change\")\n+\t\t\ttg.wantStale(\"mycmd\", \"stale dependency\", \"should be stale after environment variable change\")\n \t\t}\n \t}\n \n@@ -4795,34 +4851,34 @@ func TestTestRegexps(t *testing.T) {\n \t//\tBenchmarkX/Y is run in full, twice\n \twant := `=== RUN   TestX\n === RUN   TestX/Y\n-\tx_test.go:6: LOG: X running\n-    \tx_test.go:8: LOG: Y running\n+    x_test.go:6: LOG: X running\n+        x_test.go:8: LOG: Y running\n === RUN   TestXX\n-\tz_test.go:10: LOG: XX running\n+    z_test.go:10: LOG: XX running\n === RUN   TestX\n === RUN   TestX/Y\n-\tx_test.go:6: LOG: X running\n-    \tx_test.go:8: LOG: Y running\n+    x_test.go:6: LOG: X running\n+        x_test.go:8: LOG: Y running\n === RUN   TestXX\n-\tz_test.go:10: LOG: XX running\n+    z_test.go:10: LOG: XX running\n --- BENCH: BenchmarkX/Y\n-\tx_test.go:15: LOG: Y running N=1\n-\tx_test.go:15: LOG: Y running N=100\n-\tx_test.go:15: LOG: Y running N=10000\n-\tx_test.go:15: LOG: Y running N=1000000\n-\tx_test.go:15: LOG: Y running N=100000000\n-\tx_test.go:15: LOG: Y running N=2000000000\n+    x_test.go:15: LOG: Y running N=1\n+    x_test.go:15: LOG: Y running N=100\n+    x_test.go:15: LOG: Y running N=10000\n+    x_test.go:15: LOG: Y running N=1000000\n+    x_test.go:15: LOG: Y running N=100000000\n+    x_test.go:15: LOG: Y running N=2000000000\n --- BENCH: BenchmarkX/Y\n-\tx_test.go:15: LOG: Y running N=1\n-\tx_test.go:15: LOG: Y running N=100\n-\tx_test.go:15: LOG: Y running N=10000\n-\tx_test.go:15: LOG: Y running N=1000000\n-\tx_test.go:15: LOG: Y running N=100000000\n-\tx_test.go:15: LOG: Y running N=2000000000\n+    x_test.go:15: LOG: Y running N=1\n+    x_test.go:15: LOG: Y running N=100\n+    x_test.go:15: LOG: Y running N=10000\n+    x_test.go:15: LOG: Y running N=1000000\n+    x_test.go:15: LOG: Y running N=100000000\n+    x_test.go:15: LOG: Y running N=2000000000\n --- BENCH: BenchmarkX\n-\tx_test.go:13: LOG: X running N=1\n+    x_test.go:13: LOG: X running N=1\n --- BENCH: BenchmarkXX\n-\tz_test.go:18: LOG: XX running N=1\n+    z_test.go:18: LOG: XX running N=1\n `\n \n \thave := strings.Join(lines, \"\")\n@@ -4857,7 +4913,8 @@ func TestBuildmodePIE(t *testing.T) {\n \tplatform := fmt.Sprintf(\"%s/%s\", runtime.GOOS, runtime.GOARCH)\n \tswitch platform {\n \tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\", \"linux/s390x\",\n-\t\t\"android/amd64\", \"android/arm\", \"android/arm64\", \"android/386\":\n+\t\t\"android/amd64\", \"android/arm\", \"android/arm64\", \"android/386\",\n+\t\t\"freebsd/amd64\":\n \tcase \"darwin/amd64\":\n \tdefault:\n \t\tt.Skipf(\"skipping test because buildmode=pie is not supported on %s\", platform)\n@@ -4872,7 +4929,7 @@ func TestBuildmodePIE(t *testing.T) {\n \ttg.run(\"build\", \"-buildmode=pie\", \"-o\", obj, src)\n \n \tswitch runtime.GOOS {\n-\tcase \"linux\", \"android\":\n+\tcase \"linux\", \"android\", \"freebsd\":\n \t\tf, err := elf.Open(obj)\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n@@ -4983,7 +5040,8 @@ func TestWrongGOOSErrorBeforeLoadError(t *testing.T) {\n }\n \n func TestUpxCompression(t *testing.T) {\n-\tif runtime.GOOS != \"linux\" || runtime.GOARCH != \"amd64\" {\n+\tif runtime.GOOS != \"linux\" ||\n+\t\t(runtime.GOARCH != \"amd64\" && runtime.GOARCH != \"386\") {\n \t\tt.Skipf(\"skipping upx test on %s/%s\", runtime.GOOS, runtime.GOARCH)\n \t}\n \n@@ -5036,79 +5094,47 @@ func TestUpxCompression(t *testing.T) {\n \t}\n }\n \n-func TestGOTMPDIR(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOTMPDIR\", tg.tempdir)\n-\ttg.setenv(\"GOCACHE\", \"off\")\n-\n-\t// complex/x is a trivial non-main package.\n-\ttg.run(\"build\", \"-work\", \"-x\", \"complex/w\")\n-\ttg.grepStderr(\"WORK=\"+regexp.QuoteMeta(tg.tempdir), \"did not work in $GOTMPDIR\")\n-}\n-\n-func TestBuildCache(t *testing.T) {\n-\ttooSlow(t)\n-\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n-\t\tt.Skip(\"GODEBUG gocacheverify\")\n+// Test that Go binaries can be run under QEMU in user-emulation mode\n+// (See issue #13024).\n+func TestQEMUUserMode(t *testing.T) {\n+\tif testing.Short() && testenv.Builder() == \"\" {\n+\t\tt.Skipf(\"skipping in -short mode on non-builder\")\n \t}\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOCACHE\", tg.tempdir)\n-\n-\t// complex/w is a trivial non-main package.\n-\t// It imports nothing, so there should be no Deps.\n-\ttg.run(\"list\", \"-f={{join .Deps \\\" \\\"}}\", \"complex/w\")\n-\ttg.grepStdoutNot(\".+\", \"complex/w depends on unexpected packages\")\n-\n-\ttg.run(\"build\", \"-x\", \"complex/w\")\n-\ttg.grepStderr(`[\\\\/]compile|gccgo`, \"did not run compiler\")\n-\n-\ttg.run(\"build\", \"-x\", \"complex/w\")\n-\ttg.grepStderrNot(`[\\\\/]compile|gccgo`, \"ran compiler incorrectly\")\n-\n-\ttg.run(\"build\", \"-a\", \"-x\", \"complex/w\")\n-\ttg.grepStderr(`[\\\\/]compile|gccgo`, \"did not run compiler with -a\")\n-\n-\t// complex is a non-trivial main package.\n-\t// the link step should not be cached.\n-\ttg.run(\"build\", \"-o\", os.DevNull, \"-x\", \"complex\")\n-\ttg.grepStderr(`[\\\\/]link|gccgo`, \"did not run linker\")\n \n-\ttg.run(\"build\", \"-o\", os.DevNull, \"-x\", \"complex\")\n-\ttg.grepStderr(`[\\\\/]link|gccgo`, \"did not run linker\")\n-}\n-\n-func TestCacheOutput(t *testing.T) {\n-\t// Test that command output is cached and replayed too.\n-\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n-\t\tt.Skip(\"GODEBUG gocacheverify\")\n+\ttestArchs := []struct {\n+\t\tg, qemu string\n+\t}{\n+\t\t{\"arm\", \"arm\"},\n+\t\t{\"arm64\", \"aarch64\"},\n \t}\n+\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.tempFile(\"main.go\", `package main; import \"fmt\"; func main() { fmt.Print(\"hello qemu-user\") }`)\n \ttg.parallel()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOCACHE\", tg.tempdir)\n+\tsrc, obj := tg.path(\"main.go\"), tg.path(\"main\")\n \n-\ttg.run(\"build\", \"-gcflags=-m\", \"errors\")\n-\tstdout1 := tg.getStdout()\n-\tstderr1 := tg.getStderr()\n+\tfor _, arch := range testArchs {\n+\t\tout, err := exec.Command(\"qemu-\"+arch.qemu, \"--version\").CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Logf(\"Skipping %s test (qemu-%s not available)\", arch.g, arch.qemu)\n+\t\t\tcontinue\n+\t\t}\n \n-\ttg.run(\"build\", \"-gcflags=-m\", \"errors\")\n-\tstdout2 := tg.getStdout()\n-\tstderr2 := tg.getStderr()\n+\t\ttg.setenv(\"GOARCH\", arch.g)\n+\t\ttg.run(\"build\", \"-o\", obj, src)\n \n-\tif stdout2 != stdout1 || stderr2 != stderr1 {\n-\t\tt.Errorf(\"cache did not reproduce output:\\n\\nstdout1:\\n%s\\n\\nstdout2:\\n%s\\n\\nstderr1:\\n%s\\n\\nstderr2:\\n%s\",\n-\t\t\tstdout1, stdout2, stderr1, stderr2)\n+\t\tout, err = exec.Command(\"qemu-\"+arch.qemu, obj).CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Logf(\"qemu-%s output:\\n%s\\n\", arch.qemu, out)\n+\t\t\tt.Errorf(\"qemu-%s failed with %v\", arch.qemu, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif want := \"hello qemu-user\"; string(out) != want {\n+\t\t\tt.Errorf(\"bad output from qemu-%s:\\ngot %s; want %s\", arch.qemu, out, want)\n+\t\t}\n \t}\n+\n }\n \n func TestCacheListStale(t *testing.T) {\n@@ -5151,6 +5177,32 @@ func TestCacheCoverage(t *testing.T) {\n \ttg.run(\"test\", \"-cover\", \"-short\", \"math\", \"strings\")\n }\n \n+func TestCacheVet(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\n+\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\t\tt.Skip(\"GODEBUG gocacheverify\")\n+\t}\n+\tif os.Getenv(\"GOCACHE\") == \"off\" {\n+\t\ttooSlow(t)\n+\t\ttg.makeTempdir()\n+\t\ttg.setenv(\"GOCACHE\", tg.path(\"cache\"))\n+\t}\n+\n+\t// Check that second vet reuses cgo-derived inputs.\n+\t// The first command could be build instead of vet,\n+\t// except that if the cache is empty and there's a net.a\n+\t// in GOROOT/pkg, the build will not bother to regenerate\n+\t// and cache the cgo outputs, whereas vet always will.\n+\ttg.run(\"vet\", \"os/user\")\n+\ttg.run(\"vet\", \"-x\", \"os/user\")\n+\ttg.grepStderrNot(`^(clang|gcc)`, \"should not have run compiler\")\n+\ttg.grepStderrNot(`[\\\\/]cgo `, \"should not have run cgo\")\n+}\n+\n func TestIssue22588(t *testing.T) {\n \t// Don't get confused by stderr coming from tools.\n \ttg := testgo(t)\n@@ -5241,14 +5293,14 @@ func TestTestCache(t *testing.T) {\n \t\t// timeout here should not affect result being cached\n \t\t// or being retrieved later.\n \t\ttg.run(\"test\", \"-x\", \"-timeout=10s\", \"errors\")\n-\t\ttg.grepStderr(`[\\\\/](compile|gccgo) `, \"did not run compiler\")\n-\t\ttg.grepStderr(`[\\\\/](link|gccgo) `, \"did not run linker\")\n+\t\ttg.grepStderr(`[\\\\/]compile|gccgo`, \"did not run compiler\")\n+\t\ttg.grepStderr(`[\\\\/]link|gccgo`, \"did not run linker\")\n \t\ttg.grepStderr(`errors\\.test`, \"did not run test\")\n \n \t\ttg.run(\"test\", \"-x\", \"errors\")\n \t\ttg.grepStdout(`ok  \\terrors\\t\\(cached\\)`, \"did not report cached result\")\n-\t\ttg.grepStderrNot(`[\\\\/](compile|gccgo) `, \"incorrectly ran compiler\")\n-\t\ttg.grepStderrNot(`[\\\\/](link|gccgo) `, \"incorrectly ran linker\")\n+\t\ttg.grepStderrNot(`[\\\\/]compile|gccgo`, \"incorrectly ran compiler\")\n+\t\ttg.grepStderrNot(`[\\\\/]link|gccgo`, \"incorrectly ran linker\")\n \t\ttg.grepStderrNot(`errors\\.test`, \"incorrectly ran test\")\n \t\ttg.grepStderrNot(\"DO NOT USE\", \"poisoned action status leaked\")\n \n@@ -5520,9 +5572,29 @@ func TestTestVet(t *testing.T) {\n \ttg.runFail(\"test\", \"vetfail/...\")\n \ttg.grepStderr(`Printf format %d`, \"did not diagnose bad Printf\")\n \ttg.grepStdout(`ok\\s+vetfail/p2`, \"did not run vetfail/p2\")\n+\n+\t// Use -a so that we need to recompute the vet-specific export data for\n+\t// vetfail/p1.\n+\ttg.run(\"test\", \"-a\", \"vetfail/p2\")\n+\ttg.grepStderrNot(`invalid.*constraint`, \"did diagnose bad build constraint in vetxonly mode\")\n+}\n+\n+func TestTestSkipVetAfterFailedBuild(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\n+\ttg.tempFile(\"x_test.go\", `package x\n+\t\tfunc f() {\n+\t\t\treturn 1\n+\t\t}\n+\t`)\n+\n+\ttg.runFail(\"test\", tg.path(\"x_test.go\"))\n+\ttg.grepStderrNot(`vet`, \"vet should be skipped after the failed build\")\n }\n \n-func TestTestRebuild(t *testing.T) {\n+func TestTestVetRebuild(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -5558,6 +5630,7 @@ func TestTestRebuild(t *testing.T) {\n \n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.run(\"test\", \"b\")\n+\ttg.run(\"vet\", \"b\")\n }\n \n func TestInstallDeps(t *testing.T) {\n@@ -5619,37 +5692,6 @@ func TestRelativePkgdir(t *testing.T) {\n \ttg.run(\"build\", \"-i\", \"-pkgdir=.\", \"runtime\")\n }\n \n-func TestGcflagsPatterns(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo has no standard packages\")\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", \"\")\n-\ttg.setenv(\"GOCACHE\", \"off\")\n-\n-\ttg.run(\"build\", \"-n\", \"-v\", \"-gcflags= \\t\\r\\n -e\", \"fmt\")\n-\ttg.grepStderr(\"^# fmt\", \"did not rebuild fmt\")\n-\ttg.grepStderrNot(\"^# reflect\", \"incorrectly rebuilt reflect\")\n-\n-\ttg.run(\"build\", \"-n\", \"-v\", \"-gcflags=-e\", \"fmt\", \"reflect\")\n-\ttg.grepStderr(\"^# fmt\", \"did not rebuild fmt\")\n-\ttg.grepStderr(\"^# reflect\", \"did not rebuild reflect\")\n-\ttg.grepStderrNot(\"^# runtime\", \"incorrectly rebuilt runtime\")\n-\n-\ttg.run(\"build\", \"-n\", \"-x\", \"-v\", \"-gcflags= \\t\\r\\n reflect \\t\\r\\n = \\t\\r\\n -N\", \"fmt\")\n-\ttg.grepStderr(\"^# fmt\", \"did not rebuild fmt\")\n-\ttg.grepStderr(\"^# reflect\", \"did not rebuild reflect\")\n-\ttg.grepStderr(\"compile.* -N .*-p reflect\", \"did not build reflect with -N flag\")\n-\ttg.grepStderrNot(\"compile.* -N .*-p fmt\", \"incorrectly built fmt with -N flag\")\n-\n-\ttg.run(\"test\", \"-c\", \"-n\", \"-gcflags=-N\", \"-ldflags=-X=x.y=z\", \"strings\")\n-\ttg.grepStderr(\"compile.* -N .*compare_test.go\", \"did not compile strings_test package with -N flag\")\n-\ttg.grepStderr(\"link.* -X=x.y=z\", \"did not link strings.test binary with -X flag\")\n-\n-\ttg.run(\"test\", \"-c\", \"-n\", \"-gcflags=strings=-N\", \"-ldflags=strings=-X=x.y=z\", \"strings\")\n-\ttg.grepStderr(\"compile.* -N .*compare_test.go\", \"did not compile strings_test package with -N flag\")\n-\ttg.grepStderr(\"link.* -X=x.y=z\", \"did not link strings.test binary with -X flag\")\n-}\n-\n func TestGoTestMinusN(t *testing.T) {\n \t// Intent here is to verify that 'go test -n' works without crashing.\n \t// This reuses flag_test.go, but really any test would do.\n@@ -5726,6 +5768,9 @@ func TestFailFast(t *testing.T) {\n \t\t// non-parallel subtests:\n \t\t{\"TestFailingSubtestsA\", true, 1},\n \t\t{\"TestFailingSubtestsA\", false, 2},\n+\t\t// fatal test\n+\t\t{\"TestFatal[CD]\", true, 1},\n+\t\t{\"TestFatal[CD]\", false, 2},\n \t}\n \n \tfor _, tt := range tests {\n@@ -5789,59 +5834,6 @@ func init() {}\n \ttg.run(\"test\", \"a\")\n }\n \n-// Issue 23150.\n-func TestCpuprofileTwice(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempFile(\"prof/src/x/x_test.go\", `\n-\t\tpackage x_test\n-\t\timport (\n-\t\t\t\"testing\"\n-\t\t\t\"time\"\n-\t\t)\n-\t\tfunc TestSleep(t *testing.T) { time.Sleep(10 * time.Millisecond) }`)\n-\ttg.setenv(\"GOPATH\", tg.path(\"prof\"))\n-\tbin := tg.path(\"x.test\")\n-\tout := tg.path(\"cpu.out\")\n-\ttg.run(\"test\", \"-o=\"+bin, \"-cpuprofile=\"+out, \"x\")\n-\ttg.must(os.Remove(out))\n-\ttg.run(\"test\", \"-o=\"+bin, \"-cpuprofile=\"+out, \"x\")\n-\ttg.mustExist(out)\n-}\n-\n-// Issue 23694.\n-func TestAtomicCoverpkgAll(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo has no cover tool\")\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\n-\ttg.tempFile(\"src/x/x.go\", `package x; import _ \"sync/atomic\"; func F() {}`)\n-\ttg.tempFile(\"src/x/x_test.go\", `package x; import \"testing\"; func TestF(t *testing.T) { F() }`)\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"test\", \"-coverpkg=all\", \"-covermode=atomic\", \"x\")\n-\tif canRace {\n-\t\ttg.run(\"test\", \"-coverpkg=all\", \"-race\", \"x\")\n-\t}\n-}\n-\n-// Issue 23882.\n-func TestCoverpkgAllRuntime(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo has no cover tool\")\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\n-\ttg.tempFile(\"src/x/x.go\", `package x; import _ \"runtime\"; func F() {}`)\n-\ttg.tempFile(\"src/x/x_test.go\", `package x; import \"testing\"; func TestF(t *testing.T) { F() }`)\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"test\", \"-coverpkg=all\", \"x\")\n-\tif canRace {\n-\t\ttg.run(\"test\", \"-coverpkg=all\", \"-race\", \"x\")\n-\t}\n-}\n-\n func TestBadCommandLines(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -5871,12 +5863,12 @@ func TestBadCommandLines(t *testing.T) {\n \ttg.tempFile(\"src/@x/x.go\", \"package x\\n\")\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.runFail(\"build\", \"@x\")\n-\ttg.grepStderr(\"invalid input directory name \\\"@x\\\"\", \"did not reject @x directory\")\n+\ttg.grepStderr(\"invalid input directory name \\\"@x\\\"|cannot use path@version syntax\", \"did not reject @x directory\")\n \n \ttg.tempFile(\"src/@x/y/y.go\", \"package y\\n\")\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.runFail(\"build\", \"@x/y\")\n-\ttg.grepStderr(\"invalid import path \\\"@x/y\\\"\", \"did not reject @x/y import path\")\n+\ttg.grepStderr(\"invalid import path \\\"@x/y\\\"|cannot use path@version syntax\", \"did not reject @x/y import path\")\n \n \ttg.tempFile(\"src/-x/x.go\", \"package x\\n\")\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n@@ -6032,3 +6024,198 @@ echo $* >>`+tg.path(\"pkg-config.out\"))\n \t\tt.Errorf(\"got %q want %q\", out, want)\n \t}\n }\n+\n+func TestCgoCache(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"no cgo\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/x/a.go\", `package main\n+\t\t// #ifndef VAL\n+\t\t// #define VAL 0\n+\t\t// #endif\n+\t\t// int val = VAL;\n+\t\timport \"C\"\n+\t\timport \"fmt\"\n+\t\tfunc main() { fmt.Println(C.val) }\n+\t`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\texe := tg.path(\"x.exe\")\n+\ttg.run(\"build\", \"-o\", exe, \"x\")\n+\ttg.setenv(\"CGO_LDFLAGS\", \"-lnosuchlibraryexists\")\n+\ttg.runFail(\"build\", \"-o\", exe, \"x\")\n+\ttg.grepStderr(`nosuchlibraryexists`, \"did not run linker with changed CGO_LDFLAGS\")\n+}\n+\n+// Issue 23982\n+func TestFilepathUnderCwdFormat(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-x\", \"-cover\", \"log\")\n+\ttg.grepStderrNot(`\\.log\\.cover\\.go`, \"-x output should contain correctly formatted filepath under cwd\")\n+}\n+\n+// Issue 24396.\n+func TestDontReportRemoveOfEmptyDir(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/a/a.go\", `package a`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"install\", \"-x\", \"a\")\n+\ttg.run(\"install\", \"-x\", \"a\")\n+\t// The second install should have printed only a WORK= line,\n+\t// nothing else.\n+\tif bytes.Count(tg.stdout.Bytes(), []byte{'\\n'})+bytes.Count(tg.stderr.Bytes(), []byte{'\\n'}) > 1 {\n+\t\tt.Error(\"unnecessary output when installing installed package\")\n+\t}\n+}\n+\n+// Issue 23264.\n+func TestNoRelativeTmpdir(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.tempFile(\"src/a/a.go\", `package a`)\n+\ttg.cd(tg.path(\".\"))\n+\ttg.must(os.Mkdir(\"tmp\", 0777))\n+\n+\ttg.setenv(\"GOCACHE\", \"off\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.setenv(\"GOTMPDIR\", \"tmp\")\n+\ttg.run(\"build\", \"-work\", \"a\")\n+\ttg.grepStderr(\"WORK=[^t]\", \"work should be absolute path\")\n+\n+\ttg.unsetenv(\"GOTMPDIR\")\n+\ttg.setenv(\"TMP\", \"tmp\")    // windows\n+\ttg.setenv(\"TMPDIR\", \"tmp\") // unix\n+\ttg.run(\"build\", \"-work\", \"a\")\n+\ttg.grepStderr(\"WORK=[^t]\", \"work should be absolute path\")\n+}\n+\n+// Issue 24704.\n+func TestLinkerTmpDirIsDeleted(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo does not use cmd/link\")\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"a.go\", `package main; import \"C\"; func main() {}`)\n+\ttg.run(\"build\", \"-ldflags\", \"-v\", \"-o\", os.DevNull, tg.path(\"a.go\"))\n+\t// Find line that has \"host link:\" in linker output.\n+\tstderr := tg.getStderr()\n+\tvar hostLinkLine string\n+\tfor _, line := range strings.Split(stderr, \"\\n\") {\n+\t\tif !strings.Contains(line, \"host link:\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\thostLinkLine = line\n+\t\tbreak\n+\t}\n+\tif hostLinkLine == \"\" {\n+\t\tt.Fatal(`fail to find with \"host link:\" string in linker output`)\n+\t}\n+\t// Find parameter, like \"/tmp/go-link-408556474/go.o\" inside of\n+\t// \"host link:\" line, and extract temp directory /tmp/go-link-408556474\n+\t// out of it.\n+\ttmpdir := hostLinkLine\n+\ti := strings.Index(tmpdir, `go.o\"`)\n+\tif i == -1 {\n+\t\tt.Fatalf(`fail to find \"go.o\" in \"host link:\" line %q`, hostLinkLine)\n+\t}\n+\ttmpdir = tmpdir[:i-1]\n+\ti = strings.LastIndex(tmpdir, `\"`)\n+\tif i == -1 {\n+\t\tt.Fatalf(`fail to find \" in \"host link:\" line %q`, hostLinkLine)\n+\t}\n+\ttmpdir = tmpdir[i+1:]\n+\t// Verify that temp directory has been removed.\n+\t_, err := os.Stat(tmpdir)\n+\tif err == nil {\n+\t\tt.Fatalf(\"temp directory %q has not been removed\", tmpdir)\n+\t}\n+\tif !os.IsNotExist(err) {\n+\t\tt.Fatalf(\"Stat(%q) returns unexpected error: %v\", tmpdir, err)\n+\t}\n+}\n+\n+func testCDAndGOPATHAreDifferent(tg *testgoData, cd, gopath string) {\n+\tskipIfGccgo(tg.t, \"gccgo does not support -ldflags -X\")\n+\ttg.setenv(\"GOPATH\", gopath)\n+\n+\ttg.tempDir(\"dir\")\n+\texe := tg.path(\"dir/a.exe\")\n+\n+\ttg.cd(cd)\n+\n+\ttg.run(\"build\", \"-o\", exe, \"-ldflags\", \"-X=my.pkg.Text=linkXworked\")\n+\tout, err := exec.Command(exe).CombinedOutput()\n+\tif err != nil {\n+\t\ttg.t.Fatal(err)\n+\t}\n+\tif string(out) != \"linkXworked\\n\" {\n+\t\ttg.t.Errorf(`incorrect output with GOPATH=%q and CD=%q: expected \"linkXworked\\n\", but have %q`, gopath, cd, string(out))\n+\t}\n+}\n+\n+func TestCDAndGOPATHAreDifferent(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\tgopath := filepath.Join(tg.pwd(), \"testdata\")\n+\tcd := filepath.Join(gopath, \"src/my.pkg/main\")\n+\n+\ttestCDAndGOPATHAreDifferent(tg, cd, gopath)\n+\tif runtime.GOOS == \"windows\" {\n+\t\ttestCDAndGOPATHAreDifferent(tg, cd, strings.Replace(gopath, `\\`, `/`, -1))\n+\t\ttestCDAndGOPATHAreDifferent(tg, cd, strings.ToUpper(gopath))\n+\t\ttestCDAndGOPATHAreDifferent(tg, cd, strings.ToLower(gopath))\n+\t}\n+}\n+\n+// Issue 26242.\n+func TestGoTestWithoutTests(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"test\", \"testnorun\")\n+\ttg.grepStdout(`testnorun\\t\\[no test files\\]`, \"do not want test to run\")\n+}\n+\n+// Issue 25579.\n+func TestGoBuildDashODevNull(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"build\", \"-o\", os.DevNull, filepath.Join(tg.pwd(), \"testdata\", \"src\", \"hello\", \"hello.go\"))\n+\ttg.mustNotExist(\"hello\")\n+\ttg.mustNotExist(\"hello.exe\")\n+}\n+\n+// Issue 25093.\n+func TestCoverpkgTestOnly(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/a/a.go\", `package a\n+\t\tfunc F(i int) int {\n+\t\t\treturn i*i\n+\t\t}`)\n+\ttg.tempFile(\"src/atest/a_test.go\", `\n+\t\tpackage a_test\n+\t\timport ( \"a\"; \"testing\" )\n+\t\tfunc TestF(t *testing.T) { a.F(2) }\n+\t`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"test\", \"-coverpkg=a\", \"atest\")\n+\ttg.grepStderrNot(\"no packages being tested depend on matches\", \"bad match message\")\n+\ttg.grepStdout(\"coverage: 100\", \"no coverage\")\n+}"}, {"sha": "99af3d43dccb431a2828a4f086454e3656b910f6", "filename": "libgo/go/cmd/go/go_windows_test.go", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -12,7 +12,6 @@ import (\n \t\"os/exec\"\n \t\"path/filepath\"\n \t\"strings\"\n-\t\"syscall\"\n \t\"testing\"\n )\n \n@@ -57,15 +56,6 @@ func TestAbsolutePath(t *testing.T) {\n \t}\n }\n \n-func isWindowsXP(t *testing.T) bool {\n-\tv, err := syscall.GetVersion()\n-\tif err != nil {\n-\t\tt.Fatalf(\"GetVersion failed: %v\", err)\n-\t}\n-\tmajor := byte(v)\n-\treturn major < 6\n-}\n-\n func runIcacls(t *testing.T, args ...string) string {\n \tt.Helper()\n \tout, err := exec.Command(\"icacls\", args...).CombinedOutput()\n@@ -89,10 +79,6 @@ func runGetACL(t *testing.T, path string) string {\n // has discretionary access control list (DACL) set as if the file\n // was created in the destination directory.\n func TestACL(t *testing.T) {\n-\tif isWindowsXP(t) {\n-\t\tt.Skip(\"Windows XP does not have powershell command\")\n-\t}\n-\n \ttmpdir, err := ioutil.TempDir(\"\", \"TestACL\")\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -111,7 +97,7 @@ func TestACL(t *testing.T) {\n \t// will make all files created in TestACL/tmp have different\n \t// security attributes to the files created in TestACL.\n \trunIcacls(t, newtmpdir,\n-\t\t\"/grant\", \"guest:(oi)(ci)f\", // add Guest user to have full access\n+\t\t\"/grant\", \"*S-1-5-32-546:(oi)(ci)f\", // add Guests group to have full access\n \t)\n \n \tsrc := filepath.Join(tmpdir, \"main.go\")"}, {"sha": "e7f54c9a365fef809ba8f32e5e6ebaece13838e6", "filename": "libgo/go/cmd/go/internal/base/base.go", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -45,25 +45,43 @@ type Command struct {\n \t// CustomFlags indicates that the command will do its own\n \t// flag parsing.\n \tCustomFlags bool\n+\n+\t// Commands lists the available commands and help topics.\n+\t// The order here is the order in which they are printed by 'go help'.\n+\t// Note that subcommands are in general best avoided.\n+\tCommands []*Command\n }\n \n-// Commands lists the available commands and help topics.\n-// The order here is the order in which they are printed by 'go help'.\n-var Commands []*Command\n+var Go = &Command{\n+\tUsageLine: \"go\",\n+\tLong:      `Go is a tool for managing Go source code.`,\n+\t// Commands initialized in package main\n+}\n \n-// Name returns the command's name: the first word in the usage line.\n-func (c *Command) Name() string {\n+// LongName returns the command's long name: all the words in the usage line between \"go\" and a flag or argument,\n+func (c *Command) LongName() string {\n \tname := c.UsageLine\n-\ti := strings.Index(name, \" \")\n-\tif i >= 0 {\n+\tif i := strings.Index(name, \" [\"); i >= 0 {\n \t\tname = name[:i]\n \t}\n+\tif name == \"go\" {\n+\t\treturn \"\"\n+\t}\n+\treturn strings.TrimPrefix(name, \"go \")\n+}\n+\n+// Name returns the command's short name: the last word in the usage line before a flag or argument.\n+func (c *Command) Name() string {\n+\tname := c.LongName()\n+\tif i := strings.LastIndex(name, \" \"); i >= 0 {\n+\t\tname = name[i+1:]\n+\t}\n \treturn name\n }\n \n func (c *Command) Usage() {\n \tfmt.Fprintf(os.Stderr, \"usage: %s\\n\", c.UsageLine)\n-\tfmt.Fprintf(os.Stderr, \"Run 'go help %s' for details.\\n\", c.Name())\n+\tfmt.Fprintf(os.Stderr, \"Run 'go help %s' for details.\\n\", c.LongName())\n \tos.Exit(2)\n }\n "}, {"sha": "2f50b50bfcf368d1c1d911759b76ff1c398c38fd", "filename": "libgo/go/cmd/go/internal/base/goflags.go", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,152 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package base\n+\n+import (\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/cfg\"\n+)\n+\n+var (\n+\tgoflags   []string                // cached $GOFLAGS list; can be -x or --x form\n+\tknownFlag = make(map[string]bool) // flags allowed to appear in $GOFLAGS; no leading dashes\n+)\n+\n+// AddKnownFlag adds name to the list of known flags for use in $GOFLAGS.\n+func AddKnownFlag(name string) {\n+\tknownFlag[name] = true\n+}\n+\n+// GOFLAGS returns the flags from $GOFLAGS.\n+// The list can be assumed to contain one string per flag,\n+// with each string either beginning with -name or --name.\n+func GOFLAGS() []string {\n+\tInitGOFLAGS()\n+\treturn goflags\n+}\n+\n+// InitGOFLAGS initializes the goflags list from $GOFLAGS.\n+// If goflags is already initialized, it does nothing.\n+func InitGOFLAGS() {\n+\tif goflags != nil { // already initialized\n+\t\treturn\n+\t}\n+\n+\t// Build list of all flags for all commands.\n+\t// If no command has that flag, then we report the problem.\n+\t// This catches typos while still letting users record flags in GOFLAGS\n+\t// that only apply to a subset of go commands.\n+\t// Commands using CustomFlags can report their flag names\n+\t// by calling AddKnownFlag instead.\n+\tvar walkFlags func(*Command)\n+\twalkFlags = func(cmd *Command) {\n+\t\tfor _, sub := range cmd.Commands {\n+\t\t\twalkFlags(sub)\n+\t\t}\n+\t\tcmd.Flag.VisitAll(func(f *flag.Flag) {\n+\t\t\tknownFlag[f.Name] = true\n+\t\t})\n+\t}\n+\twalkFlags(Go)\n+\n+\t// Ignore bad flag in go env and go bug, because\n+\t// they are what people reach for when debugging\n+\t// a problem, and maybe they're debugging GOFLAGS.\n+\t// (Both will show the GOFLAGS setting if let succeed.)\n+\thideErrors := cfg.CmdName == \"env\" || cfg.CmdName == \"bug\"\n+\n+\tgoflags = strings.Fields(os.Getenv(\"GOFLAGS\"))\n+\tif goflags == nil {\n+\t\tgoflags = []string{} // avoid work on later InitGOFLAGS call\n+\t}\n+\n+\t// Each of the words returned by strings.Fields must be its own flag.\n+\t// To set flag arguments use -x=value instead of -x value.\n+\t// For boolean flags, -x is fine instead of -x=true.\n+\tfor _, f := range goflags {\n+\t\t// Check that every flag looks like -x --x -x=value or --x=value.\n+\t\tif !strings.HasPrefix(f, \"-\") || f == \"-\" || f == \"--\" || strings.HasPrefix(f, \"---\") || strings.HasPrefix(f, \"-=\") || strings.HasPrefix(f, \"--=\") {\n+\t\t\tif hideErrors {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tFatalf(\"go: parsing $GOFLAGS: non-flag %q\", f)\n+\t\t}\n+\n+\t\tname := f[1:]\n+\t\tif name[0] == '-' {\n+\t\t\tname = name[1:]\n+\t\t}\n+\t\tif i := strings.Index(name, \"=\"); i >= 0 {\n+\t\t\tname = name[:i]\n+\t\t}\n+\t\tif !knownFlag[name] {\n+\t\t\tif hideErrors {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tFatalf(\"go: parsing $GOFLAGS: unknown flag -%s\", name)\n+\t\t}\n+\t}\n+}\n+\n+// boolFlag is the optional interface for flag.Value known to the flag package.\n+// (It is not clear why package flag does not export this interface.)\n+type boolFlag interface {\n+\tflag.Value\n+\tIsBoolFlag() bool\n+}\n+\n+// SetFromGOFLAGS sets the flags in the given flag set using settings in $GOFLAGS.\n+func SetFromGOFLAGS(flags flag.FlagSet) {\n+\tInitGOFLAGS()\n+\n+\t// This loop is similar to flag.Parse except that it ignores\n+\t// unknown flags found in goflags, so that setting, say, GOFLAGS=-ldflags=-w\n+\t// does not break commands that don't have a -ldflags.\n+\t// It also adjusts the output to be clear that the reported problem is from $GOFLAGS.\n+\twhere := \"$GOFLAGS\"\n+\tif runtime.GOOS == \"windows\" {\n+\t\twhere = \"%GOFLAGS%\"\n+\t}\n+\tfor _, goflag := range goflags {\n+\t\tname, value, hasValue := goflag, \"\", false\n+\t\tif i := strings.Index(goflag, \"=\"); i >= 0 {\n+\t\t\tname, value, hasValue = goflag[:i], goflag[i+1:], true\n+\t\t}\n+\t\tif strings.HasPrefix(name, \"--\") {\n+\t\t\tname = name[1:]\n+\t\t}\n+\t\tf := flags.Lookup(name[1:])\n+\t\tif f == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif fb, ok := f.Value.(boolFlag); ok && fb.IsBoolFlag() {\n+\t\t\tif hasValue {\n+\t\t\t\tif err := fb.Set(value); err != nil {\n+\t\t\t\t\tfmt.Fprintf(flags.Output(), \"go: invalid boolean value %q for flag %s (from %s): %v\\n\", value, name, where, err)\n+\t\t\t\t\tflags.Usage()\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif err := fb.Set(\"true\"); err != nil {\n+\t\t\t\t\tfmt.Fprintf(flags.Output(), \"go: invalid boolean flag %s (from %s): %v\\n\", name, where, err)\n+\t\t\t\t\tflags.Usage()\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif !hasValue {\n+\t\t\t\tfmt.Fprintf(flags.Output(), \"go: flag needs an argument: %s (from %s)\\n\", name, where)\n+\t\t\t\tflags.Usage()\n+\t\t\t}\n+\t\t\tif err := f.Value.Set(value); err != nil {\n+\t\t\t\tfmt.Fprintf(flags.Output(), \"go: invalid value %q for flag %s (from %s): %v\\n\", value, name, where, err)\n+\t\t\t\tflags.Usage()\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "c109eecadb3321c68382def51980bbb595019e37", "filename": "libgo/go/cmd/go/internal/base/signal_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build aix darwin dragonfly freebsd linux nacl netbsd openbsd solaris\n+// +build aix darwin dragonfly freebsd js linux nacl netbsd openbsd solaris\n \n package base\n "}, {"sha": "e701f6eac9c943c4429956e4b89c5b4cece5ea4a", "filename": "libgo/go/cmd/go/internal/bug/bug.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -25,7 +25,7 @@ import (\n \n var CmdBug = &base.Command{\n \tRun:       runBug,\n-\tUsageLine: \"bug\",\n+\tUsageLine: \"go bug\",\n \tShort:     \"start a bug report\",\n \tLong: `\n Bug opens the default browser and starts a new bug report.\n@@ -38,6 +38,9 @@ func init() {\n }\n \n func runBug(cmd *base.Command, args []string) {\n+\tif len(args) > 0 {\n+\t\tbase.Fatalf(\"go bug: bug takes no arguments\")\n+\t}\n \tvar buf bytes.Buffer\n \tbuf.WriteString(bugHeader)\n \tinspectGoVersion(&buf)"}, {"sha": "0cf01550ff90d0d2967a6f481982868bc20eebd5", "filename": "libgo/go/cmd/go/internal/cache/cache.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -189,6 +189,21 @@ func (c *Cache) get(id ActionID) (Entry, error) {\n \treturn Entry{buf, size, time.Unix(0, tm)}, nil\n }\n \n+// GetFile looks up the action ID in the cache and returns\n+// the name of the corresponding data file.\n+func (c *Cache) GetFile(id ActionID) (file string, entry Entry, err error) {\n+\tentry, err = c.Get(id)\n+\tif err != nil {\n+\t\treturn \"\", Entry{}, err\n+\t}\n+\tfile = c.OutputFile(entry.OutputID)\n+\tinfo, err := os.Stat(file)\n+\tif err != nil || info.Size() != entry.Size {\n+\t\treturn \"\", Entry{}, errMissing\n+\t}\n+\treturn file, entry, nil\n+}\n+\n // GetBytes looks up the action ID in the cache and returns\n // the corresponding output bytes.\n // GetBytes should only be used for data that can be expected to fit in memory."}, {"sha": "02fc1e896f74d80b5a1564d16ce778b425a3cdb3", "filename": "libgo/go/cmd/go/internal/cache/default.go", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -35,12 +35,14 @@ See golang.org to learn more about Go.\n // initDefaultCache does the work of finding the default cache\n // the first time Default is called.\n func initDefaultCache() {\n-\tdir := DefaultDir()\n+\tdir, showWarnings := defaultDir()\n \tif dir == \"off\" {\n \t\treturn\n \t}\n \tif err := os.MkdirAll(dir, 0777); err != nil {\n-\t\tfmt.Fprintf(os.Stderr, \"go: disabling cache (%s) due to initialization failure: %s\\n\", dir, err)\n+\t\tif showWarnings {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: disabling cache (%s) due to initialization failure: %s\\n\", dir, err)\n+\t\t}\n \t\treturn\n \t}\n \tif _, err := os.Stat(filepath.Join(dir, \"README\")); err != nil {\n@@ -50,7 +52,9 @@ func initDefaultCache() {\n \n \tc, err := Open(dir)\n \tif err != nil {\n-\t\tfmt.Fprintf(os.Stderr, \"go: disabling cache (%s) due to initialization failure: %s\\n\", dir, err)\n+\t\tif showWarnings {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: disabling cache (%s) due to initialization failure: %s\\n\", dir, err)\n+\t\t}\n \t\treturn\n \t}\n \tdefaultCache = c\n@@ -59,14 +63,24 @@ func initDefaultCache() {\n // DefaultDir returns the effective GOCACHE setting.\n // It returns \"off\" if the cache is disabled.\n func DefaultDir() string {\n+\tdir, _ := defaultDir()\n+\treturn dir\n+}\n+\n+// defaultDir returns the effective GOCACHE setting.\n+// It returns \"off\" if the cache is disabled.\n+// The second return value reports whether warnings should\n+// be shown if the cache fails to initialize.\n+func defaultDir() (string, bool) {\n \tdir := os.Getenv(\"GOCACHE\")\n \tif dir != \"\" {\n-\t\treturn dir\n+\t\treturn dir, true\n \t}\n \n \t// Compute default location.\n \t// TODO(rsc): This code belongs somewhere else,\n \t// like maybe ioutil.CacheDir or os.CacheDir.\n+\tshowWarnings := true\n \tswitch runtime.GOOS {\n \tcase \"windows\":\n \t\tdir = os.Getenv(\"LocalAppData\")\n@@ -76,20 +90,20 @@ func DefaultDir() string {\n \t\t\tdir = os.Getenv(\"AppData\")\n \t\t}\n \t\tif dir == \"\" {\n-\t\t\treturn \"off\"\n+\t\t\treturn \"off\", true\n \t\t}\n \n \tcase \"darwin\":\n \t\tdir = os.Getenv(\"HOME\")\n \t\tif dir == \"\" {\n-\t\t\treturn \"off\"\n+\t\t\treturn \"off\", true\n \t\t}\n \t\tdir += \"/Library/Caches\"\n \n \tcase \"plan9\":\n \t\tdir = os.Getenv(\"home\")\n \t\tif dir == \"\" {\n-\t\t\treturn \"off\"\n+\t\t\treturn \"off\", true\n \t\t}\n \t\t// Plan 9 has no established per-user cache directory,\n \t\t// but $home/lib/xyz is the usual equivalent of $HOME/.xyz on Unix.\n@@ -101,10 +115,15 @@ func DefaultDir() string {\n \t\tif dir == \"\" {\n \t\t\tdir = os.Getenv(\"HOME\")\n \t\t\tif dir == \"\" {\n-\t\t\t\treturn \"off\"\n+\t\t\t\treturn \"off\", true\n+\t\t\t}\n+\t\t\tif dir == \"/\" {\n+\t\t\t\t// probably docker run with -u flag\n+\t\t\t\t// https://golang.org/issue/26280\n+\t\t\t\tshowWarnings = false\n \t\t\t}\n \t\t\tdir += \"/.cache\"\n \t\t}\n \t}\n-\treturn filepath.Join(dir, \"go-build\")\n+\treturn filepath.Join(dir, \"go-build\"), showWarnings\n }"}, {"sha": "a207497a42cc01ef162d7d56dc2fcf3a135b646d", "filename": "libgo/go/cmd/go/internal/cache/default_unix_test.go", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault_unix_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows,!darwin,!plan9\n+\n+package cache\n+\n+import (\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestDefaultDir(t *testing.T) {\n+\tgoCacheDir := \"/tmp/test-go-cache\"\n+\txdgCacheDir := \"/tmp/test-xdg-cache\"\n+\thomeDir := \"/tmp/test-home\"\n+\n+\t// undo env changes when finished\n+\tdefer func(GOCACHE, XDG_CACHE_HOME, HOME string) {\n+\t\tos.Setenv(\"GOCACHE\", GOCACHE)\n+\t\tos.Setenv(\"XDG_CACHE_HOME\", XDG_CACHE_HOME)\n+\t\tos.Setenv(\"HOME\", HOME)\n+\t}(os.Getenv(\"GOCACHE\"), os.Getenv(\"XDG_CACHE_HOME\"), os.Getenv(\"HOME\"))\n+\n+\tos.Setenv(\"GOCACHE\", goCacheDir)\n+\tos.Setenv(\"XDG_CACHE_HOME\", xdgCacheDir)\n+\tos.Setenv(\"HOME\", homeDir)\n+\n+\tdir, showWarnings := defaultDir()\n+\tif dir != goCacheDir {\n+\t\tt.Errorf(\"Cache DefaultDir %q should be $GOCACHE %q\", dir, goCacheDir)\n+\t}\n+\tif !showWarnings {\n+\t\tt.Error(\"Warnings should be shown when $GOCACHE is set\")\n+\t}\n+\n+\tos.Unsetenv(\"GOCACHE\")\n+\tdir, showWarnings = defaultDir()\n+\tif !strings.HasPrefix(dir, xdgCacheDir+\"/\") {\n+\t\tt.Errorf(\"Cache DefaultDir %q should be under $XDG_CACHE_HOME %q when $GOCACHE is unset\", dir, xdgCacheDir)\n+\t}\n+\tif !showWarnings {\n+\t\tt.Error(\"Warnings should be shown when $XDG_CACHE_HOME is set\")\n+\t}\n+\n+\tos.Unsetenv(\"XDG_CACHE_HOME\")\n+\tdir, showWarnings = defaultDir()\n+\tif !strings.HasPrefix(dir, homeDir+\"/.cache/\") {\n+\t\tt.Errorf(\"Cache DefaultDir %q should be under $HOME/.cache %q when $GOCACHE and $XDG_CACHE_HOME are unset\", dir, homeDir+\"/.cache\")\n+\t}\n+\tif !showWarnings {\n+\t\tt.Error(\"Warnings should be shown when $HOME is not /\")\n+\t}\n+\n+\tos.Unsetenv(\"HOME\")\n+\tif dir, _ := defaultDir(); dir != \"off\" {\n+\t\tt.Error(\"Cache not disabled when $GOCACHE, $XDG_CACHE_HOME, and $HOME are unset\")\n+\t}\n+\n+\tos.Setenv(\"HOME\", \"/\")\n+\tif _, showWarnings := defaultDir(); showWarnings {\n+\t\t// https://golang.org/issue/26280\n+\t\tt.Error(\"Cache initalization warnings should be squelched when $GOCACHE and $XDG_CACHE_HOME are unset and $HOME is /\")\n+\t}\n+}"}, {"sha": "8dc4d1fbd2989575d9ad6e76c3bacb6bbd5fd72f", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -20,7 +20,8 @@ import (\n var (\n \tBuildA                 bool   // -a flag\n \tBuildBuildmode         string // -buildmode flag\n-\tBuildContext           = build.Default\n+\tBuildContext           = defaultContext()\n+\tBuildMod               string             // -mod flag\n \tBuildI                 bool               // -i flag\n \tBuildLinkshared        bool               // -linkshared flag\n \tBuildMSan              bool               // -msan flag\n@@ -42,6 +43,12 @@ var (\n \tDebugActiongraph string // -debug-actiongraph flag (undocumented, unstable)\n )\n \n+func defaultContext() build.Context {\n+\tctxt := build.Default\n+\tctxt.JoinPath = filepath.Join // back door to say \"do not use go command\"\n+\treturn ctxt\n+}\n+\n func init() {\n \tBuildToolchainCompiler = func() string { return \"missing-compiler\" }\n \tBuildToolchainLinker = func() string { return \"missing-linker\" }\n@@ -67,6 +74,16 @@ var (\n \tGoos      = BuildContext.GOOS\n \tExeSuffix string\n \tGopath    = filepath.SplitList(BuildContext.GOPATH)\n+\n+\t// ModulesEnabled specifies whether the go command is running\n+\t// in module-aware mode (as opposed to GOPATH mode).\n+\t// It is equal to modload.Enabled, but not all packages can import modload.\n+\tModulesEnabled bool\n+\n+\t// GoModInGOPATH records whether we've found a go.mod in GOPATH/src\n+\t// in GO111MODULE=auto mode. In that case, we don't use modules\n+\t// but people might expect us to, so 'go get' warns.\n+\tGoModInGOPATH string\n )\n \n func init() {\n@@ -84,9 +101,10 @@ var (\n \tGOROOT_FINAL = findGOROOT_FINAL()\n \n \t// Used in envcmd.MkEnv and build ID computations.\n-\tGOARM  = fmt.Sprint(objabi.GOARM)\n-\tGO386  = objabi.GO386\n-\tGOMIPS = objabi.GOMIPS\n+\tGOARM    = fmt.Sprint(objabi.GOARM)\n+\tGO386    = objabi.GO386\n+\tGOMIPS   = objabi.GOMIPS\n+\tGOMIPS64 = objabi.GOMIPS64\n )\n \n // Update build context to use our computed GOROOT.\n@@ -102,6 +120,16 @@ func init() {\n \t}\n }\n \n+// There is a copy of findGOROOT, isSameDir, and isGOROOT in\n+// x/tools/cmd/godoc/goroot.go.\n+// Try to keep them in sync for now.\n+\n+// findGOROOT returns the GOROOT value, using either an explicitly\n+// provided environment variable, a GOROOT that contains the current\n+// os.Executable value, or else the GOROOT that the binary was built\n+// with from runtime.GOROOT().\n+//\n+// There is a copy of this code in x/tools/cmd/godoc/goroot.go.\n func findGOROOT() string {\n \tif env := os.Getenv(\"GOROOT\"); env != \"\" {\n \t\treturn filepath.Clean(env)\n@@ -161,6 +189,8 @@ func isSameDir(dir1, dir2 string) bool {\n // It does this by looking for the path/pkg/tool directory,\n // which is necessary for useful operation of the cmd/go tool,\n // and is not typically present in a GOPATH.\n+//\n+// There is a copy of this code in x/tools/cmd/godoc/goroot.go.\n func isGOROOT(path string) bool {\n \tstat, err := os.Stat(filepath.Join(path, \"pkg\", \"tool\"))\n \tif err != nil {"}, {"sha": "d023592eedceac42b605ce11c5fe3304866e65b1", "filename": "libgo/go/cmd/go/internal/clean/clean.go", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -17,11 +17,13 @@ import (\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/work\"\n )\n \n var CmdClean = &base.Command{\n-\tUsageLine: \"clean [-i] [-r] [-n] [-x] [-cache] [-testcache] [build flags] [packages]\",\n+\tUsageLine: \"go clean [clean flags] [build flags] [packages]\",\n \tShort:     \"remove object files and cached files\",\n \tLong: `\n Clean removes object files from package source directories.\n@@ -65,6 +67,10 @@ The -cache flag causes clean to remove the entire go build cache.\n The -testcache flag causes clean to expire all test results in the\n go build cache.\n \n+The -modcache flag causes clean to remove the entire module\n+download cache, including unpacked source code of versioned\n+dependencies.\n+\n For more about build flags, see 'go help build'.\n \n For more about specifying packages, see 'go help packages'.\n@@ -75,6 +81,7 @@ var (\n \tcleanI         bool // clean -i flag\n \tcleanR         bool // clean -r flag\n \tcleanCache     bool // clean -cache flag\n+\tcleanModcache  bool // clean -modcache flag\n \tcleanTestcache bool // clean -testcache flag\n )\n \n@@ -85,6 +92,7 @@ func init() {\n \tCmdClean.Flag.BoolVar(&cleanI, \"i\", false, \"\")\n \tCmdClean.Flag.BoolVar(&cleanR, \"r\", false, \"\")\n \tCmdClean.Flag.BoolVar(&cleanCache, \"cache\", false, \"\")\n+\tCmdClean.Flag.BoolVar(&cleanModcache, \"modcache\", false, \"\")\n \tCmdClean.Flag.BoolVar(&cleanTestcache, \"testcache\", false, \"\")\n \n \t// -n and -x are important enough to be\n@@ -95,8 +103,13 @@ func init() {\n }\n \n func runClean(cmd *base.Command, args []string) {\n-\tfor _, pkg := range load.PackagesAndErrors(args) {\n-\t\tclean(pkg)\n+\tif len(args) == 0 && modload.Failed() {\n+\t\t// Don't try to clean current directory,\n+\t\t// which will cause modload to base.Fatalf.\n+\t} else {\n+\t\tfor _, pkg := range load.PackagesAndErrors(args) {\n+\t\t\tclean(pkg)\n+\t\t}\n \t}\n \n \tif cleanCache {\n@@ -138,6 +151,29 @@ func runClean(cmd *base.Command, args []string) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tif cleanModcache {\n+\t\tif modfetch.PkgMod == \"\" {\n+\t\t\tbase.Fatalf(\"go clean -modcache: no module cache\")\n+\t\t}\n+\t\tif err := removeAll(modfetch.PkgMod); err != nil {\n+\t\t\tbase.Errorf(\"go clean -modcache: %v\", err)\n+\t\t}\n+\t}\n+}\n+\n+func removeAll(dir string) error {\n+\t// Module cache has 0555 directories; make them writable in order to remove content.\n+\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n+\t\tif err != nil {\n+\t\t\treturn nil // ignore errors walking in file system\n+\t\t}\n+\t\tif info.IsDir() {\n+\t\t\tos.Chmod(path, 0777)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\treturn os.RemoveAll(dir)\n }\n \n var cleaned = map[*load.Package]bool{}"}, {"sha": "b2a67e6f74a829161b4302e2c48797ac37238376", "filename": "libgo/go/cmd/go/internal/cmdflag/flag.go", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -69,6 +69,14 @@ func SyntaxError(cmd, msg string) {\n \tos.Exit(2)\n }\n \n+// AddKnownFlags registers the flags in defns with base.AddKnownFlag.\n+func AddKnownFlags(cmd string, defns []*Defn) {\n+\tfor _, f := range defns {\n+\t\tbase.AddKnownFlag(f.Name)\n+\t\tbase.AddKnownFlag(cmd + \".\" + f.Name)\n+\t}\n+}\n+\n // Parse sees if argument i is present in the definitions and if so,\n // returns its definition, value, and whether it consumed an extra word.\n // If the flag begins (cmd+\".\") it is ignored for the purpose of this function.\n@@ -121,3 +129,31 @@ func Parse(cmd string, defns []*Defn, args []string, i int) (f *Defn, value stri\n \tf = nil\n \treturn\n }\n+\n+// FindGOFLAGS extracts and returns the flags matching defns from GOFLAGS.\n+// Ideally the caller would mention that the flags were from GOFLAGS\n+// when reporting errors, but that's too hard for now.\n+func FindGOFLAGS(defns []*Defn) []string {\n+\tvar flags []string\n+\tfor _, flag := range base.GOFLAGS() {\n+\t\t// Flags returned by base.GOFLAGS are well-formed, one of:\n+\t\t//\t-x\n+\t\t//\t--x\n+\t\t//\t-x=value\n+\t\t//\t--x=value\n+\t\tif strings.HasPrefix(flag, \"--\") {\n+\t\t\tflag = flag[1:]\n+\t\t}\n+\t\tname := flag[1:]\n+\t\tif i := strings.Index(name, \"=\"); i >= 0 {\n+\t\t\tname = name[:i]\n+\t\t}\n+\t\tfor _, f := range defns {\n+\t\t\tif name == f.Name {\n+\t\t\t\tflags = append(flags, flag)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn flags\n+}"}, {"sha": "61d8face567c83448a02c33dee0df45a8afcf485", "filename": "libgo/go/cmd/go/internal/dirhash/hash.go", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdirhash%2Fhash.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdirhash%2Fhash.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdirhash%2Fhash.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package dirhash defines hashes over directory trees.\n+package dirhash\n+\n+import (\n+\t\"archive/zip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/base64\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strings\"\n+)\n+\n+var DefaultHash = Hash1\n+\n+type Hash func(files []string, open func(string) (io.ReadCloser, error)) (string, error)\n+\n+func Hash1(files []string, open func(string) (io.ReadCloser, error)) (string, error) {\n+\th := sha256.New()\n+\tfiles = append([]string(nil), files...)\n+\tsort.Strings(files)\n+\tfor _, file := range files {\n+\t\tif strings.Contains(file, \"\\n\") {\n+\t\t\treturn \"\", errors.New(\"filenames with newlines are not supported\")\n+\t\t}\n+\t\tr, err := open(file)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\thf := sha256.New()\n+\t\t_, err = io.Copy(hf, r)\n+\t\tr.Close()\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tfmt.Fprintf(h, \"%x  %s\\n\", hf.Sum(nil), file)\n+\t}\n+\treturn \"h1:\" + base64.StdEncoding.EncodeToString(h.Sum(nil)), nil\n+}\n+\n+func HashDir(dir, prefix string, hash Hash) (string, error) {\n+\tfiles, err := DirFiles(dir, prefix)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tosOpen := func(name string) (io.ReadCloser, error) {\n+\t\treturn os.Open(filepath.Join(dir, strings.TrimPrefix(name, prefix)))\n+\t}\n+\treturn hash(files, osOpen)\n+}\n+\n+func DirFiles(dir, prefix string) ([]string, error) {\n+\tvar files []string\n+\tdir = filepath.Clean(dir)\n+\terr := filepath.Walk(dir, func(file string, info os.FileInfo, err error) error {\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif info.IsDir() {\n+\t\t\treturn nil\n+\t\t}\n+\t\trel := file\n+\t\tif dir != \".\" {\n+\t\t\trel = file[len(dir)+1:]\n+\t\t}\n+\t\tf := filepath.Join(prefix, rel)\n+\t\tfiles = append(files, filepath.ToSlash(f))\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn files, nil\n+}\n+\n+func HashZip(zipfile string, hash Hash) (string, error) {\n+\tz, err := zip.OpenReader(zipfile)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdefer z.Close()\n+\tvar files []string\n+\tzfiles := make(map[string]*zip.File)\n+\tfor _, file := range z.File {\n+\t\tfiles = append(files, file.Name)\n+\t\tzfiles[file.Name] = file\n+\t}\n+\tzipOpen := func(name string) (io.ReadCloser, error) {\n+\t\tf := zfiles[name]\n+\t\tif f == nil {\n+\t\t\treturn nil, fmt.Errorf(\"file %q not found in zip\", name) // should never happen\n+\t\t}\n+\t\treturn f.Open()\n+\t}\n+\treturn hash(files, zipOpen)\n+}"}, {"sha": "ed463c1949cca66788742080dd382336fba3450d", "filename": "libgo/go/cmd/go/internal/dirhash/hash_test.go", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdirhash%2Fhash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdirhash%2Fhash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdirhash%2Fhash_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package dirhash\n+\n+import (\n+\t\"archive/zip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/base64\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func h(s string) string {\n+\treturn fmt.Sprintf(\"%x\", sha256.Sum256([]byte(s)))\n+}\n+\n+func htop(k string, s string) string {\n+\tsum := sha256.Sum256([]byte(s))\n+\treturn k + \":\" + base64.StdEncoding.EncodeToString(sum[:])\n+}\n+\n+func TestHash1(t *testing.T) {\n+\tfiles := []string{\"xyz\", \"abc\"}\n+\topen := func(name string) (io.ReadCloser, error) {\n+\t\treturn ioutil.NopCloser(strings.NewReader(\"data for \" + name)), nil\n+\t}\n+\twant := htop(\"h1\", fmt.Sprintf(\"%s  %s\\n%s  %s\\n\", h(\"data for abc\"), \"abc\", h(\"data for xyz\"), \"xyz\"))\n+\tout, err := Hash1(files, open)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif out != want {\n+\t\tt.Errorf(\"Hash1(...) = %s, want %s\", out, want)\n+\t}\n+\n+\t_, err = Hash1([]string{\"xyz\", \"a\\nbc\"}, open)\n+\tif err == nil {\n+\t\tt.Error(\"Hash1: expected error on newline in filenames\")\n+\t}\n+}\n+\n+func TestHashDir(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"\", \"dirhash-test-\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\tif err := ioutil.WriteFile(filepath.Join(dir, \"xyz\"), []byte(\"data for xyz\"), 0666); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := ioutil.WriteFile(filepath.Join(dir, \"abc\"), []byte(\"data for abc\"), 0666); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\twant := htop(\"h1\", fmt.Sprintf(\"%s  %s\\n%s  %s\\n\", h(\"data for abc\"), \"prefix/abc\", h(\"data for xyz\"), \"prefix/xyz\"))\n+\tout, err := HashDir(dir, \"prefix\", Hash1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"HashDir: %v\", err)\n+\t}\n+\tif out != want {\n+\t\tt.Errorf(\"HashDir(...) = %s, want %s\", out, want)\n+\t}\n+}\n+\n+func TestHashZip(t *testing.T) {\n+\tf, err := ioutil.TempFile(\"\", \"dirhash-test-\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.Remove(f.Name())\n+\tdefer f.Close()\n+\n+\tz := zip.NewWriter(f)\n+\tw, err := z.Create(\"prefix/xyz\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tw.Write([]byte(\"data for xyz\"))\n+\tw, err = z.Create(\"prefix/abc\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tw.Write([]byte(\"data for abc\"))\n+\tif err := z.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := f.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\twant := htop(\"h1\", fmt.Sprintf(\"%s  %s\\n%s  %s\\n\", h(\"data for abc\"), \"prefix/abc\", h(\"data for xyz\"), \"prefix/xyz\"))\n+\tout, err := HashZip(f.Name(), Hash1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"HashDir: %v\", err)\n+\t}\n+\tif out != want {\n+\t\tt.Errorf(\"HashDir(...) = %s, want %s\", out, want)\n+\t}\n+}\n+\n+func TestDirFiles(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"\", \"dirfiles-test-\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\tif err := ioutil.WriteFile(filepath.Join(dir, \"xyz\"), []byte(\"data for xyz\"), 0666); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := ioutil.WriteFile(filepath.Join(dir, \"abc\"), []byte(\"data for abc\"), 0666); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := os.Mkdir(filepath.Join(dir, \"subdir\"), 0777); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := ioutil.WriteFile(filepath.Join(dir, \"subdir\", \"xyz\"), []byte(\"data for subdir xyz\"), 0666); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tprefix := \"foo/bar@v2.3.4\"\n+\tout, err := DirFiles(dir, prefix)\n+\tif err != nil {\n+\t\tt.Fatalf(\"DirFiles: %v\", err)\n+\t}\n+\tfor _, file := range out {\n+\t\tif !strings.HasPrefix(file, prefix) {\n+\t\t\tt.Errorf(\"Dir file = %s, want prefix %s\", file, prefix)\n+\t\t}\n+\t}\n+}"}, {"sha": "4e7dca082d7425f8e75d30ea588e75566b95e0a9", "filename": "libgo/go/cmd/go/internal/doc/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -12,7 +12,7 @@ import (\n \n var CmdDoc = &base.Command{\n \tRun:         runDoc,\n-\tUsageLine:   \"doc [-u] [-c] [package|[package.]symbol[.methodOrField]]\",\n+\tUsageLine:   \"go doc [-u] [-c] [package|[package.]symbol[.methodOrField]]\",\n \tCustomFlags: true,\n \tShort:       \"show documentation for package or symbol\",\n \tLong: `"}, {"sha": "afadbade38ef789ff2a573e81f94998566083898", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -9,18 +9,20 @@ import (\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"os\"\n+\t\"path/filepath\"\n \t\"runtime\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/work\"\n )\n \n var CmdEnv = &base.Command{\n-\tUsageLine: \"env [-json] [var ...]\",\n+\tUsageLine: \"go env [-json] [var ...]\",\n \tShort:     \"print Go environment information\",\n \tLong: `\n Env prints Go environment information.\n@@ -52,17 +54,16 @@ func MkEnv() []cfg.EnvVar {\n \t\t{Name: \"GOBIN\", Value: cfg.GOBIN},\n \t\t{Name: \"GOCACHE\", Value: cache.DefaultDir()},\n \t\t{Name: \"GOEXE\", Value: cfg.ExeSuffix},\n+\t\t{Name: \"GOFLAGS\", Value: os.Getenv(\"GOFLAGS\")},\n \t\t{Name: \"GOHOSTARCH\", Value: runtime.GOARCH},\n \t\t{Name: \"GOHOSTOS\", Value: runtime.GOOS},\n \t\t{Name: \"GOOS\", Value: cfg.Goos},\n \t\t{Name: \"GOPATH\", Value: cfg.BuildContext.GOPATH},\n+\t\t{Name: \"GOPROXY\", Value: os.Getenv(\"GOPROXY\")},\n \t\t{Name: \"GORACE\", Value: os.Getenv(\"GORACE\")},\n \t\t{Name: \"GOROOT\", Value: cfg.GOROOT},\n \t\t{Name: \"GOTMPDIR\", Value: os.Getenv(\"GOTMPDIR\")},\n \t\t{Name: \"GOTOOLDIR\", Value: base.ToolDir},\n-\n-\t\t// disable escape codes in clang errors\n-\t\t{Name: \"TERM\", Value: \"dumb\"},\n \t}\n \n \tif work.GccgoBin != \"\" {\n@@ -78,6 +79,8 @@ func MkEnv() []cfg.EnvVar {\n \t\tenv = append(env, cfg.EnvVar{Name: \"GO386\", Value: cfg.GO386})\n \tcase \"mips\", \"mipsle\":\n \t\tenv = append(env, cfg.EnvVar{Name: \"GOMIPS\", Value: cfg.GOMIPS})\n+\tcase \"mips64\", \"mips64le\":\n+\t\tenv = append(env, cfg.EnvVar{Name: \"GOMIPS64\", Value: cfg.GOMIPS64})\n \t}\n \n \tcc := cfg.DefaultCC(cfg.Goos, cfg.Goarch)\n@@ -111,6 +114,18 @@ func findEnv(env []cfg.EnvVar, name string) string {\n \n // ExtraEnvVars returns environment variables that should not leak into child processes.\n func ExtraEnvVars() []cfg.EnvVar {\n+\tgomod := \"\"\n+\tif modload.Init(); modload.ModRoot != \"\" {\n+\t\tgomod = filepath.Join(modload.ModRoot, \"go.mod\")\n+\t}\n+\treturn []cfg.EnvVar{\n+\t\t{Name: \"GOMOD\", Value: gomod},\n+\t}\n+}\n+\n+// ExtraEnvVarsCostly returns environment variables that should not leak into child processes\n+// but are costly to evaluate.\n+func ExtraEnvVarsCostly() []cfg.EnvVar {\n \tvar b work.Builder\n \tb.Init()\n \tcppflags, cflags, cxxflags, fflags, ldflags, err := b.CFlags(&load.Package{})\n@@ -120,6 +135,7 @@ func ExtraEnvVars() []cfg.EnvVar {\n \t\treturn nil\n \t}\n \tcmd := b.GccCmd(\".\", \"\")\n+\n \treturn []cfg.EnvVar{\n \t\t// Note: Update the switch in runEnv below when adding to this list.\n \t\t{Name: \"CGO_CFLAGS\", Value: strings.Join(cflags, \" \")},\n@@ -134,13 +150,14 @@ func ExtraEnvVars() []cfg.EnvVar {\n \n func runEnv(cmd *base.Command, args []string) {\n \tenv := cfg.CmdEnv\n+\tenv = append(env, ExtraEnvVars()...)\n \n-\t// Do we need to call ExtraEnvVars, which is a bit expensive?\n+\t// Do we need to call ExtraEnvVarsCostly, which is a bit expensive?\n \t// Only if we're listing all environment variables (\"go env\")\n \t// or the variables being requested are in the extra list.\n-\tneedExtra := true\n+\tneedCostly := true\n \tif len(args) > 0 {\n-\t\tneedExtra = false\n+\t\tneedCostly = false\n \t\tfor _, arg := range args {\n \t\t\tswitch arg {\n \t\t\tcase \"CGO_CFLAGS\",\n@@ -150,12 +167,12 @@ func runEnv(cmd *base.Command, args []string) {\n \t\t\t\t\"CGO_LDFLAGS\",\n \t\t\t\t\"PKG_CONFIG\",\n \t\t\t\t\"GOGCCFLAGS\":\n-\t\t\t\tneedExtra = true\n+\t\t\t\tneedCostly = true\n \t\t\t}\n \t\t}\n \t}\n-\tif needExtra {\n-\t\tenv = append(env, ExtraEnvVars()...)\n+\tif needCostly {\n+\t\tenv = append(env, ExtraEnvVarsCostly()...)\n \t}\n \n \tif len(args) > 0 {"}, {"sha": "aab164148ff88a62424db7818d0584fb675c2daf", "filename": "libgo/go/cmd/go/internal/fix/fix.go", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -9,12 +9,15 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/str\"\n+\t\"fmt\"\n+\t\"os\"\n )\n \n var CmdFix = &base.Command{\n \tRun:       runFix,\n-\tUsageLine: \"fix [packages]\",\n+\tUsageLine: \"go fix [packages]\",\n \tShort:     \"update packages to use new APIs\",\n \tLong: `\n Fix runs the Go fix command on the packages named by the import paths.\n@@ -29,7 +32,15 @@ See also: go fmt, go vet.\n }\n \n func runFix(cmd *base.Command, args []string) {\n+\tprinted := false\n \tfor _, pkg := range load.Packages(args) {\n+\t\tif modload.Enabled() && !pkg.Module.Main {\n+\t\t\tif !printed {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: not fixing packages in dependency modules\\n\")\n+\t\t\t\tprinted = true\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n \t\t// Use pkg.gofiles instead of pkg.Dir so that\n \t\t// the command only applies to this package,\n \t\t// not to packages in subdirectories."}, {"sha": "8e4ef37281662500463f54fb1f80ec1f35f5f001", "filename": "libgo/go/cmd/go/internal/fmtcmd/fmt.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -6,6 +6,7 @@\n package fmtcmd\n \n import (\n+\t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -15,6 +16,7 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/str\"\n )\n \n@@ -24,7 +26,7 @@ func init() {\n \n var CmdFmt = &base.Command{\n \tRun:       runFmt,\n-\tUsageLine: \"fmt [-n] [-x] [packages]\",\n+\tUsageLine: \"go fmt [-n] [-x] [packages]\",\n \tShort:     \"gofmt (reformat) package sources\",\n \tLong: `\n Fmt runs the command 'gofmt -l -w' on the packages named\n@@ -43,6 +45,7 @@ See also: go fix, go vet.\n }\n \n func runFmt(cmd *base.Command, args []string) {\n+\tprinted := false\n \tgofmt := gofmtPath()\n \tprocs := runtime.GOMAXPROCS(0)\n \tvar wg sync.WaitGroup\n@@ -57,6 +60,13 @@ func runFmt(cmd *base.Command, args []string) {\n \t\t}()\n \t}\n \tfor _, pkg := range load.PackagesAndErrors(args) {\n+\t\tif modload.Enabled() && pkg.Module != nil && !pkg.Module.Main {\n+\t\t\tif !printed {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: not formatting packages in dependency modules\\n\")\n+\t\t\t\tprinted = true\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n \t\tif pkg.Error != nil {\n \t\t\tif strings.HasPrefix(pkg.Error.Err, \"build constraints exclude all Go files\") {\n \t\t\t\t// Skip this error, as we will format"}, {"sha": "9482be98aefb5c716e0ef995829e69e206a1cfa6", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -21,12 +21,13 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/work\"\n )\n \n var CmdGenerate = &base.Command{\n \tRun:       runGenerate,\n-\tUsageLine: \"generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]\",\n+\tUsageLine: \"go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]\",\n \tShort:     \"generate Go files by processing source\",\n \tLong: `\n Generate runs commands described by directives within existing\n@@ -47,6 +48,12 @@ that can be run locally. It must either be in the shell path\n (gofmt), a fully qualified path (/usr/you/bin/mytool), or a\n command alias, described below.\n \n+To convey to humans and machine tools that code is generated,\n+generated source should have a line early in the file that\n+matches the following regular expression (in Go syntax):\n+\n+\t^// Code generated .* DO NOT EDIT\\.$\n+\n Note that go generate does not parse the file, so lines that look\n like directives in comments or multiline strings will be treated\n as directives.\n@@ -152,9 +159,28 @@ func runGenerate(cmd *base.Command, args []string) {\n \t\t}\n \t}\n \t// Even if the arguments are .go files, this loop suffices.\n+\tprinted := false\n \tfor _, pkg := range load.Packages(args) {\n+\t\tif modload.Enabled() && !pkg.Module.Main {\n+\t\t\tif !printed {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: not generating in packages in dependency modules\\n\")\n+\t\t\t\tprinted = true\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tpkgName := pkg.Name\n+\n \t\tfor _, file := range pkg.InternalGoFiles() {\n-\t\t\tif !generate(pkg.Name, file) {\n+\t\t\tif !generate(pkgName, file) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n+\t\tpkgName += \"_test\"\n+\n+\t\tfor _, file := range pkg.InternalXGoFiles() {\n+\t\t\tif !generate(pkgName, file) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}"}, {"sha": "6ba5c091e39f07b3847df167fa990ebed7d77582", "filename": "libgo/go/cmd/go/internal/get/discovery.go", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -28,7 +28,7 @@ func charsetReader(charset string, input io.Reader) (io.Reader, error) {\n \n // parseMetaGoImports returns meta imports from the HTML in r.\n // Parsing ends at the end of the <head> section or the beginning of the <body>.\n-func parseMetaGoImports(r io.Reader) (imports []metaImport, err error) {\n+func parseMetaGoImports(r io.Reader, mod ModuleMode) (imports []metaImport, err error) {\n \td := xml.NewDecoder(r)\n \td.CharsetReader = charsetReader\n \td.Strict = false\n@@ -39,13 +39,13 @@ func parseMetaGoImports(r io.Reader) (imports []metaImport, err error) {\n \t\t\tif err == io.EOF || len(imports) > 0 {\n \t\t\t\terr = nil\n \t\t\t}\n-\t\t\treturn\n+\t\t\tbreak\n \t\t}\n \t\tif e, ok := t.(xml.StartElement); ok && strings.EqualFold(e.Name.Local, \"body\") {\n-\t\t\treturn\n+\t\t\tbreak\n \t\t}\n \t\tif e, ok := t.(xml.EndElement); ok && strings.EqualFold(e.Name.Local, \"head\") {\n-\t\t\treturn\n+\t\t\tbreak\n \t\t}\n \t\te, ok := t.(xml.StartElement)\n \t\tif !ok || !strings.EqualFold(e.Name.Local, \"meta\") {\n@@ -55,20 +55,34 @@ func parseMetaGoImports(r io.Reader) (imports []metaImport, err error) {\n \t\t\tcontinue\n \t\t}\n \t\tif f := strings.Fields(attrValue(e.Attr, \"content\")); len(f) == 3 {\n-\t\t\t// Ignore VCS type \"mod\", which is new Go modules.\n-\t\t\t// This code is for old go get and must ignore the new mod lines.\n-\t\t\t// Otherwise matchGoImport will complain about two\n-\t\t\t// different metaImport lines for the same Prefix.\n-\t\t\tif f[1] == \"mod\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n \t\t\timports = append(imports, metaImport{\n \t\t\t\tPrefix:   f[0],\n \t\t\t\tVCS:      f[1],\n \t\t\t\tRepoRoot: f[2],\n \t\t\t})\n \t\t}\n \t}\n+\n+\t// Extract mod entries if we are paying attention to them.\n+\tvar list []metaImport\n+\tvar have map[string]bool\n+\tif mod == PreferMod {\n+\t\thave = make(map[string]bool)\n+\t\tfor _, m := range imports {\n+\t\t\tif m.VCS == \"mod\" {\n+\t\t\t\thave[m.Prefix] = true\n+\t\t\t\tlist = append(list, m)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Append non-mod entries, ignoring those superseded by a mod entry.\n+\tfor _, m := range imports {\n+\t\tif m.VCS != \"mod\" && !have[m.Prefix] {\n+\t\t\tlist = append(list, m)\n+\t\t}\n+\t}\n+\treturn list, nil\n }\n \n // attrValue returns the attribute value for the case-insensitive key"}, {"sha": "e4148bceb048472d743cdd17d1e88e8aba10ef65", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 75, "deletions": 47, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -16,13 +16,14 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/web\"\n \t\"cmd/go/internal/work\"\n )\n \n var CmdGet = &base.Command{\n-\tUsageLine: \"get [-d] [-f] [-fix] [-insecure] [-t] [-u] [-v] [build flags] [packages]\",\n+\tUsageLine: \"go get [-d] [-f] [-t] [-u] [-v] [-fix] [-insecure] [build flags] [packages]\",\n \tShort:     \"download and install packages and dependencies\",\n \tLong: `\n Get downloads the packages named by the import paths, along with their\n@@ -73,23 +74,56 @@ For more about specifying packages, see 'go help packages'.\n For more about how 'go get' finds source code to\n download, see 'go help importpath'.\n \n+This text describes the behavior of get when using GOPATH\n+to manage source code and dependencies.\n+If instead the go command is running in module-aware mode,\n+the details of get's flags and effects change, as does 'go help get'.\n+See 'go help modules' and 'go help module-get'.\n+\n See also: go build, go install, go clean.\n \t`,\n }\n \n-var getD = CmdGet.Flag.Bool(\"d\", false, \"\")\n-var getF = CmdGet.Flag.Bool(\"f\", false, \"\")\n-var getT = CmdGet.Flag.Bool(\"t\", false, \"\")\n-var getU = CmdGet.Flag.Bool(\"u\", false, \"\")\n-var getFix = CmdGet.Flag.Bool(\"fix\", false, \"\")\n-var getInsecure = CmdGet.Flag.Bool(\"insecure\", false, \"\")\n+var HelpGopathGet = &base.Command{\n+\tUsageLine: \"gopath-get\",\n+\tShort:     \"legacy GOPATH go get\",\n+\tLong: `\n+The 'go get' command changes behavior depending on whether the\n+go command is running in module-aware mode or legacy GOPATH mode.\n+This help text, accessible as 'go help gopath-get' even in module-aware mode,\n+describes 'go get' as it operates in legacy GOPATH mode.\n+\n+Usage: ` + CmdGet.UsageLine + `\n+` + CmdGet.Long,\n+}\n+\n+var (\n+\tgetD   = CmdGet.Flag.Bool(\"d\", false, \"\")\n+\tgetF   = CmdGet.Flag.Bool(\"f\", false, \"\")\n+\tgetT   = CmdGet.Flag.Bool(\"t\", false, \"\")\n+\tgetU   = CmdGet.Flag.Bool(\"u\", false, \"\")\n+\tgetFix = CmdGet.Flag.Bool(\"fix\", false, \"\")\n+\n+\tInsecure bool\n+)\n \n func init() {\n \twork.AddBuildFlags(CmdGet)\n \tCmdGet.Run = runGet // break init loop\n+\tCmdGet.Flag.BoolVar(&Insecure, \"insecure\", Insecure, \"\")\n }\n \n func runGet(cmd *base.Command, args []string) {\n+\tif cfg.ModulesEnabled {\n+\t\t// Should not happen: main.go should install the separate module-enabled get code.\n+\t\tbase.Fatalf(\"go get: modules not implemented\")\n+\t}\n+\tif cfg.GoModInGOPATH != \"\" {\n+\t\t// Warn about not using modules with GO111MODULE=auto when go.mod exists.\n+\t\t// To silence the warning, users can set GO111MODULE=off.\n+\t\tfmt.Fprintf(os.Stderr, \"go get: warning: modules disabled by GO111MODULE=auto in GOPATH/src;\\n\\tignoring %s;\\n\\tsee 'go help modules'\\n\", base.ShortPath(cfg.GoModInGOPATH))\n+\t}\n+\n \twork.BuildInit()\n \n \tif *getF && !*getU {\n@@ -129,9 +163,8 @@ func runGet(cmd *base.Command, args []string) {\n \tif *getT {\n \t\tmode |= load.GetTestDeps\n \t}\n-\targs = downloadPaths(args)\n-\tfor _, arg := range args {\n-\t\tdownload(arg, nil, &stk, mode)\n+\tfor _, pkg := range downloadPaths(args) {\n+\t\tdownload(pkg, nil, &stk, mode)\n \t}\n \tbase.ExitIfErrors()\n \n@@ -150,8 +183,7 @@ func runGet(cmd *base.Command, args []string) {\n \t// This leads to duplicated loads of the standard packages.\n \tload.ClearCmdCache()\n \n-\targs = load.ImportPaths(args)\n-\tload.PackagesForBuild(args)\n+\tpkgs := load.PackagesForBuild(args)\n \n \t// Phase 3. Install.\n \tif *getD {\n@@ -161,36 +193,29 @@ func runGet(cmd *base.Command, args []string) {\n \t\treturn\n \t}\n \n-\twork.InstallPackages(args, true)\n+\twork.InstallPackages(args, pkgs)\n }\n \n // downloadPaths prepares the list of paths to pass to download.\n // It expands ... patterns that can be expanded. If there is no match\n // for a particular pattern, downloadPaths leaves it in the result list,\n // in the hope that we can figure out the repository from the\n // initial ...-free prefix.\n-func downloadPaths(args []string) []string {\n-\targs = load.ImportPathsNoDotExpansion(args)\n-\tvar out []string\n-\tfor _, a := range args {\n-\t\tif strings.Contains(a, \"...\") {\n-\t\t\tvar expand []string\n-\t\t\t// Use matchPackagesInFS to avoid printing\n-\t\t\t// warnings. They will be printed by the\n-\t\t\t// eventual call to importPaths instead.\n-\t\t\tif build.IsLocalImport(a) {\n-\t\t\t\texpand = load.MatchPackagesInFS(a)\n-\t\t\t} else {\n-\t\t\t\texpand = load.MatchPackages(a)\n-\t\t\t}\n-\t\t\tif len(expand) > 0 {\n-\t\t\t\tout = append(out, expand...)\n-\t\t\t\tcontinue\n-\t\t\t}\n+func downloadPaths(patterns []string) []string {\n+\tfor _, arg := range patterns {\n+\t\tif strings.Contains(arg, \"@\") {\n+\t\t\tbase.Fatalf(\"go: cannot use path@version syntax in GOPATH mode\")\n+\t\t}\n+\t}\n+\tvar pkgs []string\n+\tfor _, m := range search.ImportPathsQuiet(patterns) {\n+\t\tif len(m.Pkgs) == 0 && strings.Contains(m.Pattern, \"...\") {\n+\t\t\tpkgs = append(pkgs, m.Pattern)\n+\t\t} else {\n+\t\t\tpkgs = append(pkgs, m.Pkgs...)\n \t\t}\n-\t\tout = append(out, a)\n \t}\n-\treturn out\n+\treturn pkgs\n }\n \n // downloadCache records the import paths we have already\n@@ -215,7 +240,7 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \t}\n \tload1 := func(path string, mode int) *load.Package {\n \t\tif parent == nil {\n-\t\t\treturn load.LoadPackage(path, stk)\n+\t\t\treturn load.LoadPackageNoFlags(path, stk)\n \t\t}\n \t\treturn load.LoadImport(path, parent.Dir, parent, stk, nil, mode|load.ResolveModule)\n \t}\n@@ -271,9 +296,9 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \t\t// for p has been replaced in the package cache.\n \t\tif wildcardOkay && strings.Contains(arg, \"...\") {\n \t\t\tif build.IsLocalImport(arg) {\n-\t\t\t\targs = load.MatchPackagesInFS(arg)\n+\t\t\t\targs = search.MatchPackagesInFS(arg).Pkgs\n \t\t\t} else {\n-\t\t\t\targs = load.MatchPackages(arg)\n+\t\t\t\targs = search.MatchPackages(arg).Pkgs\n \t\t\t}\n \t\t\tisWildcard = true\n \t\t}\n@@ -304,7 +329,7 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \t\t\tbase.Run(cfg.BuildToolexec, str.StringList(base.Tool(\"fix\"), files))\n \n \t\t\t// The imports might have changed, so reload again.\n-\t\t\tp = load.ReloadPackage(arg, stk)\n+\t\t\tp = load.ReloadPackageNoFlags(arg, stk)\n \t\t\tif p.Error != nil {\n \t\t\t\tbase.Errorf(\"%s\", p.Error)\n \t\t\t\treturn\n@@ -369,10 +394,11 @@ func downloadPackage(p *load.Package) error {\n \t\tvcs            *vcsCmd\n \t\trepo, rootPath string\n \t\terr            error\n+\t\tblindRepo      bool // set if the repo has unusual configuration\n \t)\n \n \tsecurity := web.Secure\n-\tif *getInsecure {\n+\tif Insecure {\n \t\tsecurity = web.Insecure\n \t}\n \n@@ -389,34 +415,36 @@ func downloadPackage(p *load.Package) error {\n \t\t\tdir := filepath.Join(p.Internal.Build.SrcRoot, filepath.FromSlash(rootPath))\n \t\t\tremote, err := vcs.remoteRepo(vcs, dir)\n \t\t\tif err != nil {\n-\t\t\t\treturn err\n+\t\t\t\t// Proceed anyway. The package is present; we likely just don't understand\n+\t\t\t\t// the repo configuration (e.g. unusual remote protocol).\n+\t\t\t\tblindRepo = true\n \t\t\t}\n \t\t\trepo = remote\n-\t\t\tif !*getF {\n-\t\t\t\tif rr, err := repoRootForImportPath(p.ImportPath, security); err == nil {\n-\t\t\t\t\trepo := rr.repo\n+\t\t\tif !*getF && err == nil {\n+\t\t\t\tif rr, err := RepoRootForImportPath(p.ImportPath, IgnoreMod, security); err == nil {\n+\t\t\t\t\trepo := rr.Repo\n \t\t\t\t\tif rr.vcs.resolveRepo != nil {\n \t\t\t\t\t\tresolved, err := rr.vcs.resolveRepo(rr.vcs, dir, repo)\n \t\t\t\t\t\tif err == nil {\n \t\t\t\t\t\t\trepo = resolved\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tif remote != repo && rr.isCustom {\n-\t\t\t\t\t\treturn fmt.Errorf(\"%s is a custom import path for %s, but %s is checked out from %s\", rr.root, repo, dir, remote)\n+\t\t\t\t\tif remote != repo && rr.IsCustom {\n+\t\t\t\t\t\treturn fmt.Errorf(\"%s is a custom import path for %s, but %s is checked out from %s\", rr.Root, repo, dir, remote)\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t} else {\n \t\t// Analyze the import path to determine the version control system,\n \t\t// repository, and the import path for the root of the repository.\n-\t\trr, err := repoRootForImportPath(p.ImportPath, security)\n+\t\trr, err := RepoRootForImportPath(p.ImportPath, IgnoreMod, security)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tvcs, repo, rootPath = rr.vcs, rr.repo, rr.root\n+\t\tvcs, repo, rootPath = rr.vcs, rr.Repo, rr.Root\n \t}\n-\tif !vcs.isSecure(repo) && !*getInsecure {\n+\tif !blindRepo && !vcs.isSecure(repo) && !Insecure {\n \t\treturn fmt.Errorf(\"cannot download, %v uses insecure protocol\", repo)\n \t}\n "}, {"sha": "fc6a179c2e1f0b9d6fe112d1682cf437b4578341", "filename": "libgo/go/cmd/go/internal/get/pkg_test.go", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpkg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpkg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpkg_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -33,15 +33,18 @@ func TestFoldDup(t *testing.T) {\n \n var parseMetaGoImportsTests = []struct {\n \tin  string\n+\tmod ModuleMode\n \tout []metaImport\n }{\n \t{\n \t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">`,\n+\t\tIgnoreMod,\n \t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n \t},\n \t{\n \t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n \t\t<meta name=\"go-import\" content=\"baz/quux git http://github.com/rsc/baz/quux\">`,\n+\t\tIgnoreMod,\n \t\t[]metaImport{\n \t\t\t{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"},\n \t\t\t{\"baz/quux\", \"git\", \"http://github.com/rsc/baz/quux\"},\n@@ -50,42 +53,73 @@ var parseMetaGoImportsTests = []struct {\n \t{\n \t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n \t\t<meta name=\"go-import\" content=\"foo/bar mod http://github.com/rsc/baz/quux\">`,\n+\t\tIgnoreMod,\n \t\t[]metaImport{\n \t\t\t{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"},\n \t\t},\n \t},\n \t{\n \t\t`<meta name=\"go-import\" content=\"foo/bar mod http://github.com/rsc/baz/quux\">\n \t\t<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">`,\n+\t\tIgnoreMod,\n \t\t[]metaImport{\n \t\t\t{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"},\n \t\t},\n \t},\n+\t{\n+\t\t`<meta name=\"go-import\" content=\"foo/bar mod http://github.com/rsc/baz/quux\">\n+\t\t<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">`,\n+\t\tPreferMod,\n+\t\t[]metaImport{\n+\t\t\t{\"foo/bar\", \"mod\", \"http://github.com/rsc/baz/quux\"},\n+\t\t},\n+\t},\n \t{\n \t\t`<head>\n \t\t<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n \t\t</head>`,\n+\t\tIgnoreMod,\n \t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n \t},\n \t{\n \t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n \t\t<body>`,\n+\t\tIgnoreMod,\n \t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n \t},\n \t{\n \t\t`<!doctype html><meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">`,\n+\t\tIgnoreMod,\n \t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n \t},\n \t{\n \t\t// XML doesn't like <div style=position:relative>.\n \t\t`<!doctype html><title>Page Not Found</title><meta name=go-import content=\"chitin.io/chitin git https://github.com/chitin-io/chitin\"><div style=position:relative>DRAFT</div>`,\n+\t\tIgnoreMod,\n \t\t[]metaImport{{\"chitin.io/chitin\", \"git\", \"https://github.com/chitin-io/chitin\"}},\n \t},\n+\t{\n+\t\t`<meta name=\"go-import\" content=\"myitcv.io git https://github.com/myitcv/x\">\n+\t        <meta name=\"go-import\" content=\"myitcv.io/blah2 mod https://raw.githubusercontent.com/myitcv/pubx/master\">\n+\t        `,\n+\t\tIgnoreMod,\n+\t\t[]metaImport{{\"myitcv.io\", \"git\", \"https://github.com/myitcv/x\"}},\n+\t},\n+\t{\n+\t\t`<meta name=\"go-import\" content=\"myitcv.io git https://github.com/myitcv/x\">\n+\t        <meta name=\"go-import\" content=\"myitcv.io/blah2 mod https://raw.githubusercontent.com/myitcv/pubx/master\">\n+\t        `,\n+\t\tPreferMod,\n+\t\t[]metaImport{\n+\t\t\t{\"myitcv.io/blah2\", \"mod\", \"https://raw.githubusercontent.com/myitcv/pubx/master\"},\n+\t\t\t{\"myitcv.io\", \"git\", \"https://github.com/myitcv/x\"},\n+\t\t},\n+\t},\n }\n \n func TestParseMetaGoImports(t *testing.T) {\n \tfor i, tt := range parseMetaGoImportsTests {\n-\t\tout, err := parseMetaGoImports(strings.NewReader(tt.in))\n+\t\tout, err := parseMetaGoImports(strings.NewReader(tt.in), tt.mod)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"test#%d: %v\", i, err)\n \t\t\tcontinue"}, {"sha": "5cd164f2ff3a1e309ea2b94c5485844758752cbd", "filename": "libgo/go/cmd/go/internal/get/vcs.go", "status": "modified", "additions": 70, "deletions": 74, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -5,7 +5,6 @@\n package get\n \n import (\n-\t\"bytes\"\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n@@ -428,19 +427,18 @@ func (v *vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool)\n \t\tfmt.Printf(\"cd %s\\n\", dir)\n \t\tfmt.Printf(\"%s %s\\n\", v.cmd, strings.Join(args, \" \"))\n \t}\n-\tvar buf bytes.Buffer\n-\tcmd.Stdout = &buf\n-\tcmd.Stderr = &buf\n-\terr = cmd.Run()\n-\tout := buf.Bytes()\n+\tout, err := cmd.Output()\n \tif err != nil {\n \t\tif verbose || cfg.BuildV {\n \t\t\tfmt.Fprintf(os.Stderr, \"# cd %s; %s %s\\n\", dir, v.cmd, strings.Join(args, \" \"))\n-\t\t\tos.Stderr.Write(out)\n+\t\t\tif ee, ok := err.(*exec.ExitError); ok && len(ee.Stderr) > 0 {\n+\t\t\t\tos.Stderr.Write(ee.Stderr)\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n+\t\t\t}\n \t\t}\n-\t\treturn out, err\n \t}\n-\treturn out, nil\n+\treturn out, err\n }\n \n // ping pings to determine scheme to use.\n@@ -624,27 +622,29 @@ func checkNestedVCS(vcs *vcsCmd, dir, srcRoot string) error {\n \treturn nil\n }\n \n-// repoRoot represents a version control system, a repo, and a root of\n-// where to put it on disk.\n-type repoRoot struct {\n-\tvcs *vcsCmd\n-\n-\t// repo is the repository URL, including scheme\n-\trepo string\n+// RepoRoot describes the repository root for a tree of source code.\n+type RepoRoot struct {\n+\tRepo     string // repository URL, including scheme\n+\tRoot     string // import path corresponding to root of repo\n+\tIsCustom bool   // defined by served <meta> tags (as opposed to hard-coded pattern)\n+\tVCS      string // vcs type (\"mod\", \"git\", ...)\n \n-\t// root is the import path corresponding to the root of the\n-\t// repository\n-\troot string\n-\n-\t// isCustom is true for custom import paths (those defined by HTML meta tags)\n-\tisCustom bool\n+\tvcs *vcsCmd // internal: vcs command access\n }\n \n var httpPrefixRE = regexp.MustCompile(`^https?:`)\n \n-// repoRootForImportPath analyzes importPath to determine the\n+// ModuleMode specifies whether to prefer modules when looking up code sources.\n+type ModuleMode int\n+\n+const (\n+\tIgnoreMod ModuleMode = iota\n+\tPreferMod\n+)\n+\n+// RepoRootForImportPath analyzes importPath to determine the\n // version control system, and code repository to use.\n-func repoRootForImportPath(importPath string, security web.SecurityMode) (*repoRoot, error) {\n+func RepoRootForImportPath(importPath string, mod ModuleMode, security web.SecurityMode) (*RepoRoot, error) {\n \trr, err := repoRootFromVCSPaths(importPath, \"\", security, vcsPaths)\n \tif err == errUnknownSite {\n \t\t// If there are wildcards, look up the thing before the wildcard,\n@@ -654,7 +654,7 @@ func repoRootForImportPath(importPath string, security web.SecurityMode) (*repoR\n \t\tif i := strings.Index(lookup, \"/.../\"); i >= 0 {\n \t\t\tlookup = lookup[:i]\n \t\t}\n-\t\trr, err = repoRootForImportDynamic(lookup, security)\n+\t\trr, err = repoRootForImportDynamic(lookup, mod, security)\n \t\tif err != nil {\n \t\t\terr = fmt.Errorf(\"unrecognized import path %q (%v)\", importPath, err)\n \t\t}\n@@ -667,7 +667,7 @@ func repoRootForImportPath(importPath string, security web.SecurityMode) (*repoR\n \t\t}\n \t}\n \n-\tif err == nil && strings.Contains(importPath, \"...\") && strings.Contains(rr.root, \"...\") {\n+\tif err == nil && strings.Contains(importPath, \"...\") && strings.Contains(rr.Root, \"...\") {\n \t\t// Do not allow wildcards in the repo root.\n \t\trr = nil\n \t\terr = fmt.Errorf(\"cannot expand ... in %q\", importPath)\n@@ -680,7 +680,7 @@ var errUnknownSite = errors.New(\"dynamic lookup required to find mapping\")\n // repoRootFromVCSPaths attempts to map importPath to a repoRoot\n // using the mappings defined in vcsPaths.\n // If scheme is non-empty, that scheme is forced.\n-func repoRootFromVCSPaths(importPath, scheme string, security web.SecurityMode, vcsPaths []*vcsPath) (*repoRoot, error) {\n+func repoRootFromVCSPaths(importPath, scheme string, security web.SecurityMode, vcsPaths []*vcsPath) (*RepoRoot, error) {\n \t// A common error is to use https://packagepath because that's what\n \t// hg and git require. Diagnose this helpfully.\n \tif loc := httpPrefixRE.FindStringIndex(importPath); loc != nil {\n@@ -733,28 +733,32 @@ func repoRootFromVCSPaths(importPath, scheme string, security web.SecurityMode,\n \t\t\t\t\tif security == web.Secure && !vcs.isSecureScheme(scheme) {\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n-\t\t\t\t\tif vcs.ping(scheme, match[\"repo\"]) == nil {\n+\t\t\t\t\tif vcs.pingCmd != \"\" && vcs.ping(scheme, match[\"repo\"]) == nil {\n \t\t\t\t\t\tmatch[\"repo\"] = scheme + \"://\" + match[\"repo\"]\n-\t\t\t\t\t\tbreak\n+\t\t\t\t\t\tgoto Found\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\t// No scheme found. Fall back to the first one.\n+\t\t\t\tmatch[\"repo\"] = vcs.scheme[0] + \"://\" + match[\"repo\"]\n+\t\t\tFound:\n \t\t\t}\n \t\t}\n-\t\trr := &repoRoot{\n+\t\trr := &RepoRoot{\n+\t\t\tRepo: match[\"repo\"],\n+\t\t\tRoot: match[\"root\"],\n+\t\t\tVCS:  vcs.cmd,\n \t\t\tvcs:  vcs,\n-\t\t\trepo: match[\"repo\"],\n-\t\t\troot: match[\"root\"],\n \t\t}\n \t\treturn rr, nil\n \t}\n \treturn nil, errUnknownSite\n }\n \n-// repoRootForImportDynamic finds a *repoRoot for a custom domain that's not\n+// repoRootForImportDynamic finds a *RepoRoot for a custom domain that's not\n // statically known by repoRootForImportPathStatic.\n //\n // This handles custom import paths like \"name.tld/pkg/foo\" or just \"name.tld\".\n-func repoRootForImportDynamic(importPath string, security web.SecurityMode) (*repoRoot, error) {\n+func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.SecurityMode) (*RepoRoot, error) {\n \tslash := strings.Index(importPath, \"/\")\n \tif slash < 0 {\n \t\tslash = len(importPath)\n@@ -772,7 +776,7 @@ func repoRootForImportDynamic(importPath string, security web.SecurityMode) (*re\n \t\treturn nil, fmt.Errorf(msg, err)\n \t}\n \tdefer body.Close()\n-\timports, err := parseMetaGoImports(body)\n+\timports, err := parseMetaGoImports(body, mod)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"parsing %s: %v\", importPath, err)\n \t}\n@@ -799,7 +803,7 @@ func repoRootForImportDynamic(importPath string, security web.SecurityMode) (*re\n \t\t}\n \t\turlStr0 := urlStr\n \t\tvar imports []metaImport\n-\t\turlStr, imports, err = metaImportsForPrefix(mmi.Prefix, security)\n+\t\turlStr, imports, err = metaImportsForPrefix(mmi.Prefix, mod, security)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -809,48 +813,34 @@ func repoRootForImportDynamic(importPath string, security web.SecurityMode) (*re\n \t\t}\n \t}\n \n-\tif err := validateRepoRootScheme(mmi.RepoRoot); err != nil {\n+\tif err := validateRepoRoot(mmi.RepoRoot); err != nil {\n \t\treturn nil, fmt.Errorf(\"%s: invalid repo root %q: %v\", urlStr, mmi.RepoRoot, err)\n \t}\n-\trr := &repoRoot{\n-\t\tvcs:      vcsByCmd(mmi.VCS),\n-\t\trepo:     mmi.RepoRoot,\n-\t\troot:     mmi.Prefix,\n-\t\tisCustom: true,\n-\t}\n-\tif rr.vcs == nil {\n+\tvcs := vcsByCmd(mmi.VCS)\n+\tif vcs == nil && mmi.VCS != \"mod\" {\n \t\treturn nil, fmt.Errorf(\"%s: unknown vcs %q\", urlStr, mmi.VCS)\n \t}\n+\n+\trr := &RepoRoot{\n+\t\tRepo:     mmi.RepoRoot,\n+\t\tRoot:     mmi.Prefix,\n+\t\tIsCustom: true,\n+\t\tVCS:      mmi.VCS,\n+\t\tvcs:      vcs,\n+\t}\n \treturn rr, nil\n }\n \n-// validateRepoRootScheme returns an error if repoRoot does not seem\n-// to have a valid URL scheme. At this point we permit things that\n-// aren't valid URLs, although later, if not using -insecure, we will\n-// restrict repoRoots to be valid URLs. This is only because we've\n-// historically permitted them, and people may depend on that.\n-func validateRepoRootScheme(repoRoot string) error {\n-\tend := strings.Index(repoRoot, \"://\")\n-\tif end <= 0 {\n-\t\treturn errors.New(\"no scheme\")\n+// validateRepoRoot returns an error if repoRoot does not seem to be\n+// a valid URL with scheme.\n+func validateRepoRoot(repoRoot string) error {\n+\turl, err := url.Parse(repoRoot)\n+\tif err != nil {\n+\t\treturn err\n \t}\n-\n-\t// RFC 3986 section 3.1.\n-\tfor i := 0; i < end; i++ {\n-\t\tc := repoRoot[i]\n-\t\tswitch {\n-\t\tcase 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z':\n-\t\t\t// OK.\n-\t\tcase '0' <= c && c <= '9' || c == '+' || c == '-' || c == '.':\n-\t\t\t// OK except at start.\n-\t\t\tif i == 0 {\n-\t\t\t\treturn errors.New(\"invalid scheme\")\n-\t\t\t}\n-\t\tdefault:\n-\t\t\treturn errors.New(\"invalid scheme\")\n-\t\t}\n+\tif url.Scheme == \"\" {\n+\t\treturn errors.New(\"no scheme\")\n \t}\n-\n \treturn nil\n }\n \n@@ -868,7 +858,7 @@ var (\n // It is an error if no imports are found.\n // urlStr will still be valid if err != nil.\n // The returned urlStr will be of the form \"https://golang.org/x/tools?go-get=1\"\n-func metaImportsForPrefix(importPrefix string, security web.SecurityMode) (urlStr string, imports []metaImport, err error) {\n+func metaImportsForPrefix(importPrefix string, mod ModuleMode, security web.SecurityMode) (urlStr string, imports []metaImport, err error) {\n \tsetCache := func(res fetchResult) (fetchResult, error) {\n \t\tfetchCacheMu.Lock()\n \t\tdefer fetchCacheMu.Unlock()\n@@ -888,7 +878,7 @@ func metaImportsForPrefix(importPrefix string, security web.SecurityMode) (urlSt\n \t\tif err != nil {\n \t\t\treturn setCache(fetchResult{urlStr: urlStr, err: fmt.Errorf(\"fetch %s: %v\", urlStr, err)})\n \t\t}\n-\t\timports, err := parseMetaGoImports(body)\n+\t\timports, err := parseMetaGoImports(body, mod)\n \t\tif err != nil {\n \t\t\treturn setCache(fetchResult{urlStr: urlStr, err: fmt.Errorf(\"parsing %s: %v\", urlStr, err)})\n \t\t}\n@@ -956,7 +946,13 @@ func matchGoImport(imports []metaImport, importPath string) (metaImport, error)\n \t\t\tcontinue\n \t\t}\n \n-\t\tif match != -1 {\n+\t\tif match >= 0 {\n+\t\t\tif imports[match].VCS == \"mod\" && im.VCS != \"mod\" {\n+\t\t\t\t// All the mod entries precede all the non-mod entries.\n+\t\t\t\t// We have a mod entry and don't care about the rest,\n+\t\t\t\t// matching or not.\n+\t\t\t\tbreak\n+\t\t\t}\n \t\t\treturn metaImport{}, fmt.Errorf(\"multiple meta tags match import path %q\", importPath)\n \t\t}\n \t\tmatch = i\n@@ -1001,7 +997,7 @@ var vcsPaths = []*vcsPath{\n \t// IBM DevOps Services (JazzHub)\n \t{\n \t\tprefix: \"hub.jazz.net/git/\",\n-\t\tre:     `^(?P<root>hub.jazz.net/git/[a-z0-9]+/[A-Za-z0-9_.\\-]+)(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tre:     `^(?P<root>hub\\.jazz\\.net/git/[a-z0-9]+/[A-Za-z0-9_.\\-]+)(/[A-Za-z0-9_.\\-]+)*$`,\n \t\tvcs:    \"git\",\n \t\trepo:   \"https://{root}\",\n \t\tcheck:  noVCSSuffix,\n@@ -1010,7 +1006,7 @@ var vcsPaths = []*vcsPath{\n \t// Git at Apache\n \t{\n \t\tprefix: \"git.apache.org/\",\n-\t\tre:     `^(?P<root>git.apache.org/[a-z0-9_.\\-]+\\.git)(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tre:     `^(?P<root>git\\.apache\\.org/[a-z0-9_.\\-]+\\.git)(/[A-Za-z0-9_.\\-]+)*$`,\n \t\tvcs:    \"git\",\n \t\trepo:   \"https://{root}\",\n \t},"}, {"sha": "d13721bed1a489b3ab974c364b4cef6d6e79a0f9", "filename": "libgo/go/cmd/go/internal/get/vcs_test.go", "status": "modified", "additions": 79, "deletions": 54, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -16,49 +16,53 @@ import (\n \t\"cmd/go/internal/web\"\n )\n \n-// Test that RepoRootForImportPath creates the correct RepoRoot for a given importPath.\n+// Test that RepoRootForImportPath determines the correct RepoRoot for a given importPath.\n // TODO(cmang): Add tests for SVN and BZR.\n func TestRepoRootForImportPath(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n \ttests := []struct {\n \t\tpath string\n-\t\twant *repoRoot\n+\t\twant *RepoRoot\n \t}{\n \t\t{\n \t\t\t\"github.com/golang/groupcache\",\n-\t\t\t&repoRoot{\n+\t\t\t&RepoRoot{\n \t\t\t\tvcs:  vcsGit,\n-\t\t\t\trepo: \"https://github.com/golang/groupcache\",\n+\t\t\t\tRepo: \"https://github.com/golang/groupcache\",\n \t\t\t},\n \t\t},\n \t\t// Unicode letters in directories (issue 18660).\n \t\t{\n \t\t\t\"github.com/user/unicode/\u0438\u0441\u043f\u044b\u0442\u0430\u043d\u0438\u0435\",\n-\t\t\t&repoRoot{\n+\t\t\t&RepoRoot{\n \t\t\t\tvcs:  vcsGit,\n-\t\t\t\trepo: \"https://github.com/user/unicode\",\n+\t\t\t\tRepo: \"https://github.com/user/unicode\",\n \t\t\t},\n \t\t},\n \t\t// IBM DevOps Services tests\n \t\t{\n \t\t\t\"hub.jazz.net/git/user1/pkgname\",\n-\t\t\t&repoRoot{\n+\t\t\t&RepoRoot{\n \t\t\t\tvcs:  vcsGit,\n-\t\t\t\trepo: \"https://hub.jazz.net/git/user1/pkgname\",\n+\t\t\t\tRepo: \"https://hub.jazz.net/git/user1/pkgname\",\n \t\t\t},\n \t\t},\n \t\t{\n \t\t\t\"hub.jazz.net/git/user1/pkgname/submodule/submodule/submodule\",\n-\t\t\t&repoRoot{\n+\t\t\t&RepoRoot{\n \t\t\t\tvcs:  vcsGit,\n-\t\t\t\trepo: \"https://hub.jazz.net/git/user1/pkgname\",\n+\t\t\t\tRepo: \"https://hub.jazz.net/git/user1/pkgname\",\n \t\t\t},\n \t\t},\n \t\t{\n \t\t\t\"hub.jazz.net\",\n \t\t\tnil,\n \t\t},\n+\t\t{\n+\t\t\t\"hubajazz.net\",\n+\t\t\tnil,\n+\t\t},\n \t\t{\n \t\t\t\"hub2.jazz.net\",\n \t\t\tnil,\n@@ -87,9 +91,9 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\t\"hub.jazz.net/git/user/pkg.name\",\n-\t\t\t&repoRoot{\n+\t\t\t&RepoRoot{\n \t\t\t\tvcs:  vcsGit,\n-\t\t\t\trepo: \"https://hub.jazz.net/git/user/pkg.name\",\n+\t\t\t\tRepo: \"https://hub.jazz.net/git/user/pkg.name\",\n \t\t\t},\n \t\t},\n \t\t// User names cannot have uppercase letters\n@@ -100,26 +104,26 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t\t// OpenStack tests\n \t\t{\n \t\t\t\"git.openstack.org/openstack/swift\",\n-\t\t\t&repoRoot{\n+\t\t\t&RepoRoot{\n \t\t\t\tvcs:  vcsGit,\n-\t\t\t\trepo: \"https://git.openstack.org/openstack/swift\",\n+\t\t\t\tRepo: \"https://git.openstack.org/openstack/swift\",\n \t\t\t},\n \t\t},\n \t\t// Trailing .git is less preferred but included for\n \t\t// compatibility purposes while the same source needs to\n \t\t// be compilable on both old and new go\n \t\t{\n \t\t\t\"git.openstack.org/openstack/swift.git\",\n-\t\t\t&repoRoot{\n+\t\t\t&RepoRoot{\n \t\t\t\tvcs:  vcsGit,\n-\t\t\t\trepo: \"https://git.openstack.org/openstack/swift.git\",\n+\t\t\t\tRepo: \"https://git.openstack.org/openstack/swift.git\",\n \t\t\t},\n \t\t},\n \t\t{\n \t\t\t\"git.openstack.org/openstack/swift/go/hummingbird\",\n-\t\t\t&repoRoot{\n+\t\t\t&RepoRoot{\n \t\t\t\tvcs:  vcsGit,\n-\t\t\t\trepo: \"https://git.openstack.org/openstack/swift\",\n+\t\t\t\tRepo: \"https://git.openstack.org/openstack/swift\",\n \t\t\t},\n \t\t},\n \t\t{\n@@ -140,25 +144,29 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t\t\t\"git.apache.org/package-name/path/to/lib\",\n \t\t\tnil,\n \t\t},\n+\t\t{\n+\t\t\t\"gitbapache.org\",\n+\t\t\tnil,\n+\t\t},\n \t\t{\n \t\t\t\"git.apache.org/package-name.git\",\n-\t\t\t&repoRoot{\n+\t\t\t&RepoRoot{\n \t\t\t\tvcs:  vcsGit,\n-\t\t\t\trepo: \"https://git.apache.org/package-name.git\",\n+\t\t\t\tRepo: \"https://git.apache.org/package-name.git\",\n \t\t\t},\n \t\t},\n \t\t{\n \t\t\t\"git.apache.org/package-name_2.x.git/path/to/lib\",\n-\t\t\t&repoRoot{\n+\t\t\t&RepoRoot{\n \t\t\t\tvcs:  vcsGit,\n-\t\t\t\trepo: \"https://git.apache.org/package-name_2.x.git\",\n+\t\t\t\tRepo: \"https://git.apache.org/package-name_2.x.git\",\n \t\t\t},\n \t\t},\n \t\t{\n \t\t\t\"chiselapp.com/user/kyle/repository/fossilgg\",\n-\t\t\t&repoRoot{\n+\t\t\t&RepoRoot{\n \t\t\t\tvcs:  vcsFossil,\n-\t\t\t\trepo: \"https://chiselapp.com/user/kyle/repository/fossilgg\",\n+\t\t\t\tRepo: \"https://chiselapp.com/user/kyle/repository/fossilgg\",\n \t\t\t},\n \t\t},\n \t\t{\n@@ -173,21 +181,21 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t}\n \n \tfor _, test := range tests {\n-\t\tgot, err := repoRootForImportPath(test.path, web.Secure)\n+\t\tgot, err := RepoRootForImportPath(test.path, IgnoreMod, web.Secure)\n \t\twant := test.want\n \n \t\tif want == nil {\n \t\t\tif err == nil {\n-\t\t\t\tt.Errorf(\"repoRootForImportPath(%q): Error expected but not received\", test.path)\n+\t\t\t\tt.Errorf(\"RepoRootForImportPath(%q): Error expected but not received\", test.path)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"repoRootForImportPath(%q): %v\", test.path, err)\n+\t\t\tt.Errorf(\"RepoRootForImportPath(%q): %v\", test.path, err)\n \t\t\tcontinue\n \t\t}\n-\t\tif got.vcs.name != want.vcs.name || got.repo != want.repo {\n-\t\t\tt.Errorf(\"repoRootForImportPath(%q) = VCS(%s) Repo(%s), want VCS(%s) Repo(%s)\", test.path, got.vcs, got.repo, want.vcs, want.repo)\n+\t\tif got.vcs.name != want.vcs.name || got.Repo != want.Repo {\n+\t\t\tt.Errorf(\"RepoRootForImportPath(%q) = VCS(%s) Repo(%s), want VCS(%s) Repo(%s)\", test.path, got.vcs, got.Repo, want.vcs, want.Repo)\n \t\t}\n \t}\n }\n@@ -219,18 +227,18 @@ func TestFromDir(t *testing.T) {\n \t\t\tf.Close()\n \t\t}\n \n-\t\twant := repoRoot{\n+\t\twant := RepoRoot{\n \t\t\tvcs:  vcs,\n-\t\t\troot: path.Join(\"example.com\", vcs.name),\n+\t\t\tRoot: path.Join(\"example.com\", vcs.name),\n \t\t}\n-\t\tvar got repoRoot\n-\t\tgot.vcs, got.root, err = vcsFromDir(dir, tempDir)\n+\t\tvar got RepoRoot\n+\t\tgot.vcs, got.Root, err = vcsFromDir(dir, tempDir)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"FromDir(%q, %q): %v\", dir, tempDir, err)\n \t\t\tcontinue\n \t\t}\n-\t\tif got.vcs.name != want.vcs.name || got.root != want.root {\n-\t\t\tt.Errorf(\"FromDir(%q, %q) = VCS(%s) Root(%s), want VCS(%s) Root(%s)\", dir, tempDir, got.vcs, got.root, want.vcs, want.root)\n+\t\tif got.vcs.name != want.vcs.name || got.Root != want.Root {\n+\t\t\tt.Errorf(\"FromDir(%q, %q) = VCS(%s) Root(%s), want VCS(%s) Root(%s)\", dir, tempDir, got.vcs, got.Root, want.vcs, want.Root)\n \t\t}\n \t}\n }\n@@ -393,6 +401,22 @@ func TestMatchGoImport(t *testing.T) {\n \t\t\tpath: \"different.example.com/user/foo\",\n \t\t\terr:  errors.New(\"meta tags do not match import path\"),\n \t\t},\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"myitcv.io/blah2\", VCS: \"mod\", RepoRoot: \"https://raw.githubusercontent.com/myitcv/pubx/master\"},\n+\t\t\t\t{Prefix: \"myitcv.io\", VCS: \"git\", RepoRoot: \"https://github.com/myitcv/x\"},\n+\t\t\t},\n+\t\t\tpath: \"myitcv.io/blah2/foo\",\n+\t\t\tmi:   metaImport{Prefix: \"myitcv.io/blah2\", VCS: \"mod\", RepoRoot: \"https://raw.githubusercontent.com/myitcv/pubx/master\"},\n+\t\t},\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"myitcv.io/blah2\", VCS: \"mod\", RepoRoot: \"https://raw.githubusercontent.com/myitcv/pubx/master\"},\n+\t\t\t\t{Prefix: \"myitcv.io\", VCS: \"git\", RepoRoot: \"https://github.com/myitcv/x\"},\n+\t\t\t},\n+\t\t\tpath: \"myitcv.io/other\",\n+\t\t\tmi:   metaImport{Prefix: \"myitcv.io\", VCS: \"git\", RepoRoot: \"https://github.com/myitcv/x\"},\n+\t\t},\n \t}\n \n \tfor _, test := range tests {\n@@ -409,45 +433,46 @@ func TestMatchGoImport(t *testing.T) {\n \t}\n }\n \n-func TestValidateRepoRootScheme(t *testing.T) {\n+func TestValidateRepoRoot(t *testing.T) {\n \ttests := []struct {\n \t\troot string\n-\t\terr  string\n+\t\tok   bool\n \t}{\n \t\t{\n \t\t\troot: \"\",\n-\t\t\terr:  \"no scheme\",\n+\t\t\tok:   false,\n \t\t},\n \t\t{\n \t\t\troot: \"http://\",\n-\t\t\terr:  \"\",\n+\t\t\tok:   true,\n \t\t},\n \t\t{\n-\t\t\troot: \"a://\",\n-\t\t\terr:  \"\",\n+\t\t\troot: \"git+ssh://\",\n+\t\t\tok:   true,\n \t\t},\n \t\t{\n-\t\t\troot: \"a#://\",\n-\t\t\terr:  \"invalid scheme\",\n+\t\t\troot: \"http#://\",\n+\t\t\tok:   false,\n+\t\t},\n+\t\t{\n+\t\t\troot: \"-config\",\n+\t\t\tok:   false,\n \t\t},\n \t\t{\n \t\t\troot: \"-config://\",\n-\t\t\terr:  \"invalid scheme\",\n+\t\t\tok:   false,\n \t\t},\n \t}\n \n \tfor _, test := range tests {\n-\t\terr := validateRepoRootScheme(test.root)\n-\t\tif err == nil {\n-\t\t\tif test.err != \"\" {\n-\t\t\t\tt.Errorf(\"validateRepoRootScheme(%q) = nil, want %q\", test.root, test.err)\n-\t\t\t}\n-\t\t} else if test.err == \"\" {\n-\t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"validateRepoRootScheme(%q) = %q, want nil\", test.root, test.err)\n+\t\terr := validateRepoRoot(test.root)\n+\t\tok := err == nil\n+\t\tif ok != test.ok {\n+\t\t\twant := \"error\"\n+\t\t\tif test.ok {\n+\t\t\t\twant = \"nil\"\n \t\t\t}\n-\t\t} else if err.Error() != test.err {\n-\t\t\tt.Errorf(\"validateRepoRootScheme(%q) = %q, want %q\", test.root, err, test.err)\n+\t\t\tt.Errorf(\"validateRepoRoot(%q) = %q, want %s\", test.root, err, want)\n \t\t}\n \t}\n }"}, {"sha": "a80afe36c412c4de955f36f21fa60e13b7eeb18b", "filename": "libgo/go/cmd/go/internal/help/help.go", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -21,82 +21,95 @@ import (\n \n // Help implements the 'help' command.\n func Help(args []string) {\n-\tif len(args) == 0 {\n-\t\tPrintUsage(os.Stdout)\n-\t\t// not exit 2: succeeded at 'go help'.\n-\t\treturn\n-\t}\n-\tif len(args) != 1 {\n-\t\tfmt.Fprintf(os.Stderr, \"usage: go help command\\n\\nToo many arguments given.\\n\")\n-\t\tos.Exit(2) // failed at 'go help'\n-\t}\n-\n-\targ := args[0]\n-\n \t// 'go help documentation' generates doc.go.\n-\tif arg == \"documentation\" {\n+\tif len(args) == 1 && args[0] == \"documentation\" {\n \t\tfmt.Println(\"// Copyright 2011 The Go Authors. All rights reserved.\")\n \t\tfmt.Println(\"// Use of this source code is governed by a BSD-style\")\n \t\tfmt.Println(\"// license that can be found in the LICENSE file.\")\n \t\tfmt.Println()\n-\t\tfmt.Println(\"// DO NOT EDIT THIS FILE. GENERATED BY mkalldocs.sh.\")\n+\t\tfmt.Println(\"// Code generated by mkalldocs.sh; DO NOT EDIT.\")\n \t\tfmt.Println(\"// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.\")\n \t\tfmt.Println()\n \t\tbuf := new(bytes.Buffer)\n-\t\tPrintUsage(buf)\n+\t\tPrintUsage(buf, base.Go)\n \t\tusage := &base.Command{Long: buf.String()}\n-\t\ttmpl(&commentWriter{W: os.Stdout}, documentationTemplate, append([]*base.Command{usage}, base.Commands...))\n+\t\tcmds := []*base.Command{usage}\n+\t\tfor _, cmd := range base.Go.Commands {\n+\t\t\tif cmd.UsageLine == \"gopath-get\" {\n+\t\t\t\t// Avoid duplication of the \"get\" documentation.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcmds = append(cmds, cmd)\n+\t\t\tcmds = append(cmds, cmd.Commands...)\n+\t\t}\n+\t\ttmpl(&commentWriter{W: os.Stdout}, documentationTemplate, cmds)\n \t\tfmt.Println(\"package main\")\n \t\treturn\n \t}\n \n-\tfor _, cmd := range base.Commands {\n-\t\tif cmd.Name() == arg {\n-\t\t\ttmpl(os.Stdout, helpTemplate, cmd)\n-\t\t\t// not exit 2: succeeded at 'go help cmd'.\n-\t\t\treturn\n+\tcmd := base.Go\n+Args:\n+\tfor i, arg := range args {\n+\t\tfor _, sub := range cmd.Commands {\n+\t\t\tif sub.Name() == arg {\n+\t\t\t\tcmd = sub\n+\t\t\t\tcontinue Args\n+\t\t\t}\n+\t\t}\n+\n+\t\t// helpSuccess is the help command using as many args as possible that would succeed.\n+\t\thelpSuccess := \"go help\"\n+\t\tif i > 0 {\n+\t\t\thelpSuccess = \" \" + strings.Join(args[:i], \" \")\n \t\t}\n+\t\tfmt.Fprintf(os.Stderr, \"go help %s: unknown help topic. Run '%s'.\\n\", strings.Join(args, \" \"), helpSuccess)\n+\t\tos.Exit(2) // failed at 'go help cmd'\n \t}\n \n-\tfmt.Fprintf(os.Stderr, \"Unknown help topic %#q. Run 'go help'.\\n\", arg)\n-\tos.Exit(2) // failed at 'go help cmd'\n+\tif len(cmd.Commands) > 0 {\n+\t\tPrintUsage(os.Stdout, cmd)\n+\t} else {\n+\t\ttmpl(os.Stdout, helpTemplate, cmd)\n+\t}\n+\t// not exit 2: succeeded at 'go help cmd'.\n+\treturn\n }\n \n-var usageTemplate = `Go is a tool for managing Go source code.\n+var usageTemplate = `{{.Long | trim}}\n \n Usage:\n \n-\tgo command [arguments]\n+\t{{.UsageLine}} <command> [arguments]\n \n The commands are:\n-{{range .}}{{if .Runnable}}\n+{{range .Commands}}{{if or (.Runnable) .Commands}}\n \t{{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n \n-Use \"go help [command]\" for more information about a command.\n-\n+Use \"go help{{with .LongName}} {{.}}{{end}} <command>\" for more information about a command.\n+{{if eq (.UsageLine) \"go\"}}\n Additional help topics:\n-{{range .}}{{if not .Runnable}}\n+{{range .Commands}}{{if and (not .Runnable) (not .Commands)}}\n \t{{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n \n-Use \"go help [topic]\" for more information about that topic.\n-\n+Use \"go help{{with .LongName}} {{.}}{{end}} <topic>\" for more information about that topic.\n+{{end}}\n `\n \n-var helpTemplate = `{{if .Runnable}}usage: go {{.UsageLine}}\n+var helpTemplate = `{{if .Runnable}}usage: {{.UsageLine}}\n \n {{end}}{{.Long | trim}}\n `\n \n var documentationTemplate = `{{range .}}{{if .Short}}{{.Short | capitalize}}\n \n-{{end}}{{if .Runnable}}Usage:\n+{{end}}{{if .Commands}}` + usageTemplate + `{{else}}{{if .Runnable}}Usage:\n \n-\tgo {{.UsageLine}}\n+\t{{.UsageLine}}\n \n {{end}}{{.Long | trim}}\n \n \n-{{end}}`\n+{{end}}{{end}}`\n \n // commentWriter writes a Go comment to the underlying io.Writer,\n // using line comment form (//).\n@@ -171,8 +184,8 @@ func capitalize(s string) string {\n \treturn string(unicode.ToTitle(r)) + s[n:]\n }\n \n-func PrintUsage(w io.Writer) {\n+func PrintUsage(w io.Writer, cmd *base.Command) {\n \tbw := bufio.NewWriter(w)\n-\ttmpl(bw, usageTemplate, base.Commands)\n+\ttmpl(bw, usageTemplate, cmd)\n \tbw.Flush()\n }"}, {"sha": "aff4ce12f6c9ae05db4ff1ef24b0c267761a853e", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -30,7 +30,7 @@ the C or C++ compiler, respectively, to use.\n \n var HelpPackages = &base.Command{\n \tUsageLine: \"packages\",\n-\tShort:     \"package lists\",\n+\tShort:     \"package lists and patterns\",\n \tLong: `\n Many commands apply to a set of packages:\n \n@@ -54,9 +54,11 @@ for packages to be built with the go tool:\n \n - \"main\" denotes the top-level package in a stand-alone executable.\n \n-- \"all\" expands to all package directories found in all the GOPATH\n+- \"all\" expands to all packages found in all the GOPATH\n trees. For example, 'go list all' lists all the packages on the local\n-system.\n+system. When using modules, \"all\" expands to all packages in\n+the main module and their dependencies, including dependencies\n+needed by tests of any of those.\n \n - \"std\" is like all but expands to just the packages in the standard\n Go library.\n@@ -193,6 +195,7 @@ using the named version control system, and then the path inside\n that repository. The supported version control systems are:\n \n \tBazaar      .bzr\n+\tFossil      .fossil\n \tGit         .git\n \tMercurial   .hg\n \tSubversion  .svn\n@@ -236,7 +239,7 @@ The meta tag should appear as early in the file as possible.\n In particular, it should appear before any raw JavaScript or CSS,\n to avoid confusing the go command's restricted parser.\n \n-The vcs is one of \"git\", \"hg\", \"svn\", etc,\n+The vcs is one of \"bzr\", \"fossil\", \"git\", \"hg\", \"svn\".\n \n The repo-root is the root of the version control system\n containing a scheme and not containing a .vcs qualifier.\n@@ -258,12 +261,22 @@ the go tool will verify that https://example.org/?go-get=1 contains the\n same meta tag and then git clone https://code.org/r/p/exproj into\n GOPATH/src/example.org.\n \n-New downloaded packages are written to the first directory listed in the GOPATH\n-environment variable (For more details see: 'go help gopath').\n+When using GOPATH, downloaded packages are written to the first directory\n+listed in the GOPATH environment variable.\n+(See 'go help gopath-get' and 'go help gopath'.)\n+\n+When using modules, downloaded packages are stored in the module cache.\n+(See 'go help modules-get' and 'go help goproxy'.)\n+\n+When using modules, an additional variant of the go-import meta tag is\n+recognized and is preferred over those listing version control systems.\n+That variant uses \"mod\" as the vcs in the content value, as in:\n \n-The go command attempts to download the version of the\n-package appropriate for the Go release being used.\n-Run 'go help get' for more.\n+\t<meta name=\"go-import\" content=\"example.org mod https://code.org/moduleproxy\">\n+\n+This tag means to fetch modules with paths beginning with example.org\n+from the module proxy available at the URL https://code.org/moduleproxy.\n+See 'go help goproxy' for details about the proxy protocol.\n \n Import path checking\n \n@@ -286,6 +299,9 @@ Import path checking is disabled for code found within vendor trees.\n This makes it possible to copy code into alternate locations in vendor trees\n without needing to update import comments.\n \n+Import path checking is also disabled when using modules.\n+Import path comments are obsoleted by the go.mod file's module statement.\n+\n See https://golang.org/s/go14customimport for details.\n \t`,\n }\n@@ -358,6 +374,12 @@ in the list.\n \n See https://golang.org/doc/code.html for an example.\n \n+GOPATH and Modules\n+\n+When using modules, GOPATH is no longer used for resolving imports.\n+However, it is still used to store downloaded source code (in GOPATH/pkg/mod)\n+and compiled commands (in GOPATH/bin).\n+\n Internal Directories\n \n Code in or below a directory named \"internal\" is importable only\n@@ -461,11 +483,21 @@ General-purpose environment variables:\n \t\tExamples are amd64, 386, arm, ppc64.\n \tGOBIN\n \t\tThe directory where 'go install' will install a command.\n+\tGOCACHE\n+\t\tThe directory where the go command will store cached\n+\t\tinformation for reuse in future builds.\n+\tGOFLAGS\n+\t\tA space-separated list of -flag=value settings to apply\n+\t\tto go commands by default, when the given flag is known by\n+\t\tthe current command. Flags listed on the command-line\n+\t\tare applied after this list and therefore override it.\n \tGOOS\n \t\tThe operating system for which to compile code.\n \t\tExamples are linux, darwin, windows, netbsd.\n \tGOPATH\n \t\tFor more details see: 'go help gopath'.\n+\tGOPROXY\n+\t\tURL of Go module proxy. See 'go help goproxy'.\n \tGORACE\n \t\tOptions for the race detector.\n \t\tSee https://golang.org/doc/articles/race_detector.html.\n@@ -474,9 +506,6 @@ General-purpose environment variables:\n \tGOTMPDIR\n \t\tThe directory where the go command will write\n \t\ttemporary source files, packages, and binaries.\n-\tGOCACHE\n-\t\tThe directory where the go command will store\n-\t\tcached information for reuse in future builds.\n \n Environment variables for use with cgo:\n \n@@ -523,6 +552,9 @@ Architecture-specific environment variables:\n \tGOMIPS\n \t\tFor GOARCH=mips{,le}, whether to use floating point instructions.\n \t\tValid values are hardfloat (default), softfloat.\n+\tGOMIPS64\n+\t\tFor GOARCH=mips64{,le}, whether to use floating point instructions.\n+\t\tValid values are hardfloat (default), softfloat.\n \n Special-purpose environment variables:\n \n@@ -542,6 +574,20 @@ Special-purpose environment variables:\n \t\tDefined by Git. A colon-separated list of schemes that are allowed to be used\n \t\twith git fetch/clone. If set, any scheme not explicitly mentioned will be\n \t\tconsidered insecure by 'go get'.\n+\n+Additional information available from 'go env' but not read from the environment:\n+\n+\tGOEXE\n+\t\tThe executable file name suffix (\".exe\" on Windows, \"\" on other systems).\n+\tGOHOSTARCH\n+\t\tThe architecture (GOARCH) of the Go toolchain binaries.\n+\tGOHOSTOS\n+\t\tThe operating system (GOOS) of the Go toolchain binaries.\n+\tGOMOD\n+\t\tThe absolute path to the go.mod of the main module,\n+\t\tor the empty string if not using modules.\n+\tGOTOOLDIR\n+\t\tThe directory where the go tools (compile, cover, doc, etc...) are installed.\n \t`,\n }\n \n@@ -651,6 +697,7 @@ The default location for cache data is a subdirectory named go-build\n in the standard user cache directory for the current operating system.\n Setting the GOCACHE environment variable overrides this default,\n and running 'go env GOCACHE' prints the current cache directory.\n+You can set the variable to 'off' to disable the cache.\n \n The go command periodically deletes cached data that has not been\n used recently. Running 'go clean -cache' deletes all cached data."}, {"sha": "d1adf9440cb44db28f6e6af8f1a37bccfb8402ae", "filename": "libgo/go/cmd/go/internal/imports/build.go", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,211 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Copied from Go distribution src/go/build/build.go, syslist.go\n+\n+package imports\n+\n+import (\n+\t\"bytes\"\n+\t\"strings\"\n+\t\"unicode\"\n+)\n+\n+var slashslash = []byte(\"//\")\n+\n+// ShouldBuild reports whether it is okay to use this file,\n+// The rule is that in the file's leading run of // comments\n+// and blank lines, which must be followed by a blank line\n+// (to avoid including a Go package clause doc comment),\n+// lines beginning with '// +build' are taken as build directives.\n+//\n+// The file is accepted only if each such line lists something\n+// matching the file. For example:\n+//\n+//\t// +build windows linux\n+//\n+// marks the file as applicable only on Windows and Linux.\n+//\n+// If tags[\"*\"] is true, then ShouldBuild will consider every\n+// build tag except \"ignore\" to be both true and false for\n+// the purpose of satisfying build tags, in order to estimate\n+// (conservatively) whether a file could ever possibly be used\n+// in any build.\n+//\n+func ShouldBuild(content []byte, tags map[string]bool) bool {\n+\t// Pass 1. Identify leading run of // comments and blank lines,\n+\t// which must be followed by a blank line.\n+\tend := 0\n+\tp := content\n+\tfor len(p) > 0 {\n+\t\tline := p\n+\t\tif i := bytes.IndexByte(line, '\\n'); i >= 0 {\n+\t\t\tline, p = line[:i], p[i+1:]\n+\t\t} else {\n+\t\t\tp = p[len(p):]\n+\t\t}\n+\t\tline = bytes.TrimSpace(line)\n+\t\tif len(line) == 0 { // Blank line\n+\t\t\tend = len(content) - len(p)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !bytes.HasPrefix(line, slashslash) { // Not comment line\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tcontent = content[:end]\n+\n+\t// Pass 2.  Process each line in the run.\n+\tp = content\n+\tallok := true\n+\tfor len(p) > 0 {\n+\t\tline := p\n+\t\tif i := bytes.IndexByte(line, '\\n'); i >= 0 {\n+\t\t\tline, p = line[:i], p[i+1:]\n+\t\t} else {\n+\t\t\tp = p[len(p):]\n+\t\t}\n+\t\tline = bytes.TrimSpace(line)\n+\t\tif !bytes.HasPrefix(line, slashslash) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tline = bytes.TrimSpace(line[len(slashslash):])\n+\t\tif len(line) > 0 && line[0] == '+' {\n+\t\t\t// Looks like a comment +line.\n+\t\t\tf := strings.Fields(string(line))\n+\t\t\tif f[0] == \"+build\" {\n+\t\t\t\tok := false\n+\t\t\t\tfor _, tok := range f[1:] {\n+\t\t\t\t\tif matchTags(tok, tags) {\n+\t\t\t\t\t\tok = true\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif !ok {\n+\t\t\t\t\tallok = false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn allok\n+}\n+\n+// matchTags reports whether the name is one of:\n+//\n+//\ttag (if tags[tag] is true)\n+//\t!tag (if tags[tag] is false)\n+//\ta comma-separated list of any of these\n+//\n+func matchTags(name string, tags map[string]bool) bool {\n+\tif name == \"\" {\n+\t\treturn false\n+\t}\n+\tif i := strings.Index(name, \",\"); i >= 0 {\n+\t\t// comma-separated list\n+\t\tok1 := matchTags(name[:i], tags)\n+\t\tok2 := matchTags(name[i+1:], tags)\n+\t\treturn ok1 && ok2\n+\t}\n+\tif strings.HasPrefix(name, \"!!\") { // bad syntax, reject always\n+\t\treturn false\n+\t}\n+\tif strings.HasPrefix(name, \"!\") { // negation\n+\t\treturn len(name) > 1 && matchTag(name[1:], tags, false)\n+\t}\n+\treturn matchTag(name, tags, true)\n+}\n+\n+// matchTag reports whether the tag name is valid and satisfied by tags[name]==want.\n+func matchTag(name string, tags map[string]bool, want bool) bool {\n+\t// Tags must be letters, digits, underscores or dots.\n+\t// Unlike in Go identifiers, all digits are fine (e.g., \"386\").\n+\tfor _, c := range name {\n+\t\tif !unicode.IsLetter(c) && !unicode.IsDigit(c) && c != '_' && c != '.' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\tif tags[\"*\"] && name != \"\" && name != \"ignore\" {\n+\t\t// Special case for gathering all possible imports:\n+\t\t// if we put * in the tags map then all tags\n+\t\t// except \"ignore\" are considered both present and not\n+\t\t// (so we return true no matter how 'want' is set).\n+\t\treturn true\n+\t}\n+\n+\thave := tags[name]\n+\tif name == \"linux\" {\n+\t\thave = have || tags[\"android\"]\n+\t}\n+\treturn have == want\n+}\n+\n+// MatchFile returns false if the name contains a $GOOS or $GOARCH\n+// suffix which does not match the current system.\n+// The recognized name formats are:\n+//\n+//     name_$(GOOS).*\n+//     name_$(GOARCH).*\n+//     name_$(GOOS)_$(GOARCH).*\n+//     name_$(GOOS)_test.*\n+//     name_$(GOARCH)_test.*\n+//     name_$(GOOS)_$(GOARCH)_test.*\n+//\n+// An exception: if GOOS=android, then files with GOOS=linux are also matched.\n+//\n+// If tags[\"*\"] is true, then MatchFile will consider all possible\n+// GOOS and GOARCH to be available and will consequently\n+// always return true.\n+func MatchFile(name string, tags map[string]bool) bool {\n+\tif tags[\"*\"] {\n+\t\treturn true\n+\t}\n+\tif dot := strings.Index(name, \".\"); dot != -1 {\n+\t\tname = name[:dot]\n+\t}\n+\n+\t// Before Go 1.4, a file called \"linux.go\" would be equivalent to having a\n+\t// build tag \"linux\" in that file. For Go 1.4 and beyond, we require this\n+\t// auto-tagging to apply only to files with a non-empty prefix, so\n+\t// \"foo_linux.go\" is tagged but \"linux.go\" is not. This allows new operating\n+\t// systems, such as android, to arrive without breaking existing code with\n+\t// innocuous source code in \"android.go\". The easiest fix: cut everything\n+\t// in the name before the initial _.\n+\ti := strings.Index(name, \"_\")\n+\tif i < 0 {\n+\t\treturn true\n+\t}\n+\tname = name[i:] // ignore everything before first _\n+\n+\tl := strings.Split(name, \"_\")\n+\tif n := len(l); n > 0 && l[n-1] == \"test\" {\n+\t\tl = l[:n-1]\n+\t}\n+\tn := len(l)\n+\tif n >= 2 && KnownOS[l[n-2]] && KnownArch[l[n-1]] {\n+\t\treturn tags[l[n-2]] && tags[l[n-1]]\n+\t}\n+\tif n >= 1 && KnownOS[l[n-1]] {\n+\t\treturn tags[l[n-1]]\n+\t}\n+\tif n >= 1 && KnownArch[l[n-1]] {\n+\t\treturn tags[l[n-1]]\n+\t}\n+\treturn true\n+}\n+\n+var KnownOS = make(map[string]bool)\n+var KnownArch = make(map[string]bool)\n+\n+func init() {\n+\tfor _, v := range strings.Fields(goosList) {\n+\t\tKnownOS[v] = true\n+\t}\n+\tfor _, v := range strings.Fields(goarchList) {\n+\t\tKnownArch[v] = true\n+\t}\n+}\n+\n+const goosList = \"android darwin dragonfly freebsd js linux nacl netbsd openbsd plan9 solaris windows zos \"\n+const goarchList = \"386 amd64 amd64p32 arm armbe arm64 arm64be ppc64 ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc riscv riscv64 s390 s390x sparc sparc64 wasm \""}, {"sha": "58c2abdc29ab3a3384368d561ff2ad8e4398f499", "filename": "libgo/go/cmd/go/internal/imports/read.go", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Copied from Go distribution src/go/build/read.go.\n+\n+package imports\n+\n+import (\n+\t\"bufio\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"unicode/utf8\"\n+)\n+\n+type importReader struct {\n+\tb    *bufio.Reader\n+\tbuf  []byte\n+\tpeek byte\n+\terr  error\n+\teof  bool\n+\tnerr int\n+}\n+\n+func isIdent(c byte) bool {\n+\treturn 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || '0' <= c && c <= '9' || c == '_' || c >= utf8.RuneSelf\n+}\n+\n+var (\n+\terrSyntax = errors.New(\"syntax error\")\n+\terrNUL    = errors.New(\"unexpected NUL in input\")\n+)\n+\n+// syntaxError records a syntax error, but only if an I/O error has not already been recorded.\n+func (r *importReader) syntaxError() {\n+\tif r.err == nil {\n+\t\tr.err = errSyntax\n+\t}\n+}\n+\n+// readByte reads the next byte from the input, saves it in buf, and returns it.\n+// If an error occurs, readByte records the error in r.err and returns 0.\n+func (r *importReader) readByte() byte {\n+\tc, err := r.b.ReadByte()\n+\tif err == nil {\n+\t\tr.buf = append(r.buf, c)\n+\t\tif c == 0 {\n+\t\t\terr = errNUL\n+\t\t}\n+\t}\n+\tif err != nil {\n+\t\tif err == io.EOF {\n+\t\t\tr.eof = true\n+\t\t} else if r.err == nil {\n+\t\t\tr.err = err\n+\t\t}\n+\t\tc = 0\n+\t}\n+\treturn c\n+}\n+\n+// peekByte returns the next byte from the input reader but does not advance beyond it.\n+// If skipSpace is set, peekByte skips leading spaces and comments.\n+func (r *importReader) peekByte(skipSpace bool) byte {\n+\tif r.err != nil {\n+\t\tif r.nerr++; r.nerr > 10000 {\n+\t\t\tpanic(\"go/build: import reader looping\")\n+\t\t}\n+\t\treturn 0\n+\t}\n+\n+\t// Use r.peek as first input byte.\n+\t// Don't just return r.peek here: it might have been left by peekByte(false)\n+\t// and this might be peekByte(true).\n+\tc := r.peek\n+\tif c == 0 {\n+\t\tc = r.readByte()\n+\t}\n+\tfor r.err == nil && !r.eof {\n+\t\tif skipSpace {\n+\t\t\t// For the purposes of this reader, semicolons are never necessary to\n+\t\t\t// understand the input and are treated as spaces.\n+\t\t\tswitch c {\n+\t\t\tcase ' ', '\\f', '\\t', '\\r', '\\n', ';':\n+\t\t\t\tc = r.readByte()\n+\t\t\t\tcontinue\n+\n+\t\t\tcase '/':\n+\t\t\t\tc = r.readByte()\n+\t\t\t\tif c == '/' {\n+\t\t\t\t\tfor c != '\\n' && r.err == nil && !r.eof {\n+\t\t\t\t\t\tc = r.readByte()\n+\t\t\t\t\t}\n+\t\t\t\t} else if c == '*' {\n+\t\t\t\t\tvar c1 byte\n+\t\t\t\t\tfor (c != '*' || c1 != '/') && r.err == nil {\n+\t\t\t\t\t\tif r.eof {\n+\t\t\t\t\t\t\tr.syntaxError()\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tc, c1 = c1, r.readByte()\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tr.syntaxError()\n+\t\t\t\t}\n+\t\t\t\tc = r.readByte()\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tbreak\n+\t}\n+\tr.peek = c\n+\treturn r.peek\n+}\n+\n+// nextByte is like peekByte but advances beyond the returned byte.\n+func (r *importReader) nextByte(skipSpace bool) byte {\n+\tc := r.peekByte(skipSpace)\n+\tr.peek = 0\n+\treturn c\n+}\n+\n+// readKeyword reads the given keyword from the input.\n+// If the keyword is not present, readKeyword records a syntax error.\n+func (r *importReader) readKeyword(kw string) {\n+\tr.peekByte(true)\n+\tfor i := 0; i < len(kw); i++ {\n+\t\tif r.nextByte(false) != kw[i] {\n+\t\t\tr.syntaxError()\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tif isIdent(r.peekByte(false)) {\n+\t\tr.syntaxError()\n+\t}\n+}\n+\n+// readIdent reads an identifier from the input.\n+// If an identifier is not present, readIdent records a syntax error.\n+func (r *importReader) readIdent() {\n+\tc := r.peekByte(true)\n+\tif !isIdent(c) {\n+\t\tr.syntaxError()\n+\t\treturn\n+\t}\n+\tfor isIdent(r.peekByte(false)) {\n+\t\tr.peek = 0\n+\t}\n+}\n+\n+// readString reads a quoted string literal from the input.\n+// If an identifier is not present, readString records a syntax error.\n+func (r *importReader) readString(save *[]string) {\n+\tswitch r.nextByte(true) {\n+\tcase '`':\n+\t\tstart := len(r.buf) - 1\n+\t\tfor r.err == nil {\n+\t\t\tif r.nextByte(false) == '`' {\n+\t\t\t\tif save != nil {\n+\t\t\t\t\t*save = append(*save, string(r.buf[start:]))\n+\t\t\t\t}\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif r.eof {\n+\t\t\t\tr.syntaxError()\n+\t\t\t}\n+\t\t}\n+\tcase '\"':\n+\t\tstart := len(r.buf) - 1\n+\t\tfor r.err == nil {\n+\t\t\tc := r.nextByte(false)\n+\t\t\tif c == '\"' {\n+\t\t\t\tif save != nil {\n+\t\t\t\t\t*save = append(*save, string(r.buf[start:]))\n+\t\t\t\t}\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif r.eof || c == '\\n' {\n+\t\t\t\tr.syntaxError()\n+\t\t\t}\n+\t\t\tif c == '\\\\' {\n+\t\t\t\tr.nextByte(false)\n+\t\t\t}\n+\t\t}\n+\tdefault:\n+\t\tr.syntaxError()\n+\t}\n+}\n+\n+// readImport reads an import clause - optional identifier followed by quoted string -\n+// from the input.\n+func (r *importReader) readImport(imports *[]string) {\n+\tc := r.peekByte(true)\n+\tif c == '.' {\n+\t\tr.peek = 0\n+\t} else if isIdent(c) {\n+\t\tr.readIdent()\n+\t}\n+\tr.readString(imports)\n+}\n+\n+// ReadComments is like ioutil.ReadAll, except that it only reads the leading\n+// block of comments in the file.\n+func ReadComments(f io.Reader) ([]byte, error) {\n+\tr := &importReader{b: bufio.NewReader(f)}\n+\tr.peekByte(true)\n+\tif r.err == nil && !r.eof {\n+\t\t// Didn't reach EOF, so must have found a non-space byte. Remove it.\n+\t\tr.buf = r.buf[:len(r.buf)-1]\n+\t}\n+\treturn r.buf, r.err\n+}\n+\n+// ReadImports is like ioutil.ReadAll, except that it expects a Go file as input\n+// and stops reading the input once the imports have completed.\n+func ReadImports(f io.Reader, reportSyntaxError bool, imports *[]string) ([]byte, error) {\n+\tr := &importReader{b: bufio.NewReader(f)}\n+\n+\tr.readKeyword(\"package\")\n+\tr.readIdent()\n+\tfor r.peekByte(true) == 'i' {\n+\t\tr.readKeyword(\"import\")\n+\t\tif r.peekByte(true) == '(' {\n+\t\t\tr.nextByte(false)\n+\t\t\tfor r.peekByte(true) != ')' && r.err == nil {\n+\t\t\t\tr.readImport(imports)\n+\t\t\t}\n+\t\t\tr.nextByte(false)\n+\t\t} else {\n+\t\t\tr.readImport(imports)\n+\t\t}\n+\t}\n+\n+\t// If we stopped successfully before EOF, we read a byte that told us we were done.\n+\t// Return all but that last byte, which would cause a syntax error if we let it through.\n+\tif r.err == nil && !r.eof {\n+\t\treturn r.buf[:len(r.buf)-1], nil\n+\t}\n+\n+\t// If we stopped for a syntax error, consume the whole file so that\n+\t// we are sure we don't change the errors that go/parser returns.\n+\tif r.err == errSyntax && !reportSyntaxError {\n+\t\tr.err = nil\n+\t\tfor r.err == nil && !r.eof {\n+\t\t\tr.readByte()\n+\t\t}\n+\t}\n+\n+\treturn r.buf, r.err\n+}"}, {"sha": "6ea356f1ff05acbd8aee3e9de9b5564cb1537dd3", "filename": "libgo/go/cmd/go/internal/imports/read_test.go", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,228 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Copied from Go distribution src/go/build/read.go.\n+\n+package imports\n+\n+import (\n+\t\"io\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+const quote = \"`\"\n+\n+type readTest struct {\n+\t// Test input contains \u2119 where readImports should stop.\n+\tin  string\n+\terr string\n+}\n+\n+var readImportsTests = []readTest{\n+\t{\n+\t\t`package p`,\n+\t\t\"\",\n+\t},\n+\t{\n+\t\t`package p; import \"x\"`,\n+\t\t\"\",\n+\t},\n+\t{\n+\t\t`package p; import . \"x\"`,\n+\t\t\"\",\n+\t},\n+\t{\n+\t\t`package p; import \"x\";\u2119var x = 1`,\n+\t\t\"\",\n+\t},\n+\t{\n+\t\t`package p\n+\t\t\n+\t\t// comment\n+\t\t\n+\t\timport \"x\"\n+\t\timport _ \"x\"\n+\t\timport a \"x\"\n+\t\t\n+\t\t/* comment */\n+\t\t\n+\t\timport (\n+\t\t\t\"x\" /* comment */\n+\t\t\t_ \"x\"\n+\t\t\ta \"x\" // comment\n+\t\t\t` + quote + `x` + quote + `\n+\t\t\t_ /*comment*/ ` + quote + `x` + quote + `\n+\t\t\ta ` + quote + `x` + quote + `\n+\t\t)\n+\t\timport (\n+\t\t)\n+\t\timport ()\n+\t\timport()import()import()\n+\t\timport();import();import()\n+\t\t\n+\t\t\u2119var x = 1\n+\t\t`,\n+\t\t\"\",\n+\t},\n+}\n+\n+var readCommentsTests = []readTest{\n+\t{\n+\t\t`\u2119package p`,\n+\t\t\"\",\n+\t},\n+\t{\n+\t\t`\u2119package p; import \"x\"`,\n+\t\t\"\",\n+\t},\n+\t{\n+\t\t`\u2119package p; import . \"x\"`,\n+\t\t\"\",\n+\t},\n+\t{\n+\t\t`// foo\n+\n+\t\t/* bar */\n+\n+\t\t/* quux */ // baz\n+\t\t\n+\t\t/*/ zot */\n+\n+\t\t// asdf\n+\t\t\u2119Hello, world`,\n+\t\t\"\",\n+\t},\n+}\n+\n+func testRead(t *testing.T, tests []readTest, read func(io.Reader) ([]byte, error)) {\n+\tfor i, tt := range tests {\n+\t\tvar in, testOut string\n+\t\tj := strings.Index(tt.in, \"\u2119\")\n+\t\tif j < 0 {\n+\t\t\tin = tt.in\n+\t\t\ttestOut = tt.in\n+\t\t} else {\n+\t\t\tin = tt.in[:j] + tt.in[j+len(\"\u2119\"):]\n+\t\t\ttestOut = tt.in[:j]\n+\t\t}\n+\t\tr := strings.NewReader(in)\n+\t\tbuf, err := read(r)\n+\t\tif err != nil {\n+\t\t\tif tt.err == \"\" {\n+\t\t\t\tt.Errorf(\"#%d: err=%q, expected success (%q)\", i, err, string(buf))\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif !strings.Contains(err.Error(), tt.err) {\n+\t\t\t\tt.Errorf(\"#%d: err=%q, expected %q\", i, err, tt.err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err == nil && tt.err != \"\" {\n+\t\t\tt.Errorf(\"#%d: success, expected %q\", i, tt.err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tout := string(buf)\n+\t\tif out != testOut {\n+\t\t\tt.Errorf(\"#%d: wrong output:\\nhave %q\\nwant %q\\n\", i, out, testOut)\n+\t\t}\n+\t}\n+}\n+\n+func TestReadImports(t *testing.T) {\n+\ttestRead(t, readImportsTests, func(r io.Reader) ([]byte, error) { return ReadImports(r, true, nil) })\n+}\n+\n+func TestReadComments(t *testing.T) {\n+\ttestRead(t, readCommentsTests, ReadComments)\n+}\n+\n+var readFailuresTests = []readTest{\n+\t{\n+\t\t`package`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t\"package p\\n\\x00\\nimport `math`\\n\",\n+\t\t\"unexpected NUL in input\",\n+\t},\n+\t{\n+\t\t`package p; import`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import \"`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t\"package p; import ` \\n\\n\",\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import \"x`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import _`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import _ \"`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import _ \"x`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import .`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import . \"`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import . \"x`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import (`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import (\"`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import (\"x`,\n+\t\t\"syntax error\",\n+\t},\n+\t{\n+\t\t`package p; import (\"x\"`,\n+\t\t\"syntax error\",\n+\t},\n+}\n+\n+func TestReadFailures(t *testing.T) {\n+\t// Errors should be reported (true arg to readImports).\n+\ttestRead(t, readFailuresTests, func(r io.Reader) ([]byte, error) { return ReadImports(r, true, nil) })\n+}\n+\n+func TestReadFailuresIgnored(t *testing.T) {\n+\t// Syntax errors should not be reported (false arg to readImports).\n+\t// Instead, entire file should be the output and no error.\n+\t// Convert tests not to return syntax errors.\n+\ttests := make([]readTest, len(readFailuresTests))\n+\tcopy(tests, readFailuresTests)\n+\tfor i := range tests {\n+\t\ttt := &tests[i]\n+\t\tif !strings.Contains(tt.err, \"NUL\") {\n+\t\t\ttt.err = \"\"\n+\t\t}\n+\t}\n+\ttestRead(t, tests, func(r io.Reader) ([]byte, error) { return ReadImports(r, false, nil) })\n+}"}, {"sha": "d944e95724e54244e28f9694e8dbb6780db18f3d", "filename": "libgo/go/cmd/go/internal/imports/scan.go", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package imports\n+\n+import (\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+func ScanDir(dir string, tags map[string]bool) ([]string, []string, error) {\n+\tinfos, err := ioutil.ReadDir(dir)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\tvar files []string\n+\tfor _, info := range infos {\n+\t\tname := info.Name()\n+\t\tif info.Mode().IsRegular() && !strings.HasPrefix(name, \"_\") && strings.HasSuffix(name, \".go\") && MatchFile(name, tags) {\n+\t\t\tfiles = append(files, filepath.Join(dir, name))\n+\t\t}\n+\t}\n+\treturn scanFiles(files, tags, false)\n+}\n+\n+func ScanFiles(files []string, tags map[string]bool) ([]string, []string, error) {\n+\treturn scanFiles(files, tags, true)\n+}\n+\n+func scanFiles(files []string, tags map[string]bool, explicitFiles bool) ([]string, []string, error) {\n+\timports := make(map[string]bool)\n+\ttestImports := make(map[string]bool)\n+\tnumFiles := 0\n+Files:\n+\tfor _, name := range files {\n+\t\tr, err := os.Open(name)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tvar list []string\n+\t\tdata, err := ReadImports(r, false, &list)\n+\t\tr.Close()\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"reading %s: %v\", name, err)\n+\t\t}\n+\n+\t\t// import \"C\" is implicit requirement of cgo tag.\n+\t\t// When listing files on the command line (explicitFiles=true)\n+\t\t// we do not apply build tag filtering but we still do apply\n+\t\t// cgo filtering, so no explicitFiles check here.\n+\t\t// Why? Because we always have, and it's not worth breaking\n+\t\t// that behavior now.\n+\t\tfor _, path := range list {\n+\t\t\tif path == `\"C\"` && !tags[\"cgo\"] && !tags[\"*\"] {\n+\t\t\t\tcontinue Files\n+\t\t\t}\n+\t\t}\n+\n+\t\tif !explicitFiles && !ShouldBuild(data, tags) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tnumFiles++\n+\t\tm := imports\n+\t\tif strings.HasSuffix(name, \"_test.go\") {\n+\t\t\tm = testImports\n+\t\t}\n+\t\tfor _, p := range list {\n+\t\t\tq, err := strconv.Unquote(p)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tm[q] = true\n+\t\t}\n+\t}\n+\tif numFiles == 0 {\n+\t\treturn nil, nil, ErrNoGo\n+\t}\n+\treturn keys(imports), keys(testImports), nil\n+}\n+\n+var ErrNoGo = fmt.Errorf(\"no Go source files\")\n+\n+func keys(m map[string]bool) []string {\n+\tvar list []string\n+\tfor k := range m {\n+\t\tlist = append(list, k)\n+\t}\n+\tsort.Strings(list)\n+\treturn list\n+}"}, {"sha": "6a2ff62ba758936089e2e1cf7fe6e9756a2a49b9", "filename": "libgo/go/cmd/go/internal/imports/scan_test.go", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package imports\n+\n+import (\n+\t\"internal/testenv\"\n+\t\"path/filepath\"\n+\t\"reflect\"\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func TestScan(t *testing.T) {\n+\ttestenv.MustHaveGoBuild(t)\n+\n+\timports, testImports, err := ScanDir(filepath.Join(runtime.GOROOT(), \"src/encoding/json\"), Tags())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfoundBase64 := false\n+\tfor _, p := range imports {\n+\t\tif p == \"encoding/base64\" {\n+\t\t\tfoundBase64 = true\n+\t\t}\n+\t\tif p == \"encoding/binary\" {\n+\t\t\t// A dependency but not an import\n+\t\t\tt.Errorf(\"json reported as importing encoding/binary but does not\")\n+\t\t}\n+\t\tif p == \"net/http\" {\n+\t\t\t// A test import but not an import\n+\t\t\tt.Errorf(\"json reported as importing encoding/binary but does not\")\n+\t\t}\n+\t}\n+\tif !foundBase64 {\n+\t\tt.Errorf(\"json missing import encoding/base64 (%q)\", imports)\n+\t}\n+\n+\tfoundHTTP := false\n+\tfor _, p := range testImports {\n+\t\tif p == \"net/http\" {\n+\t\t\tfoundHTTP = true\n+\t\t}\n+\t\tif p == \"unicode/utf16\" {\n+\t\t\t// A package import but not a test import\n+\t\t\tt.Errorf(\"json reported as test-importing unicode/utf16  but does not\")\n+\t\t}\n+\t}\n+\tif !foundHTTP {\n+\t\tt.Errorf(\"json missing test import net/http (%q)\", testImports)\n+\t}\n+}\n+\n+func TestScanStar(t *testing.T) {\n+\ttestenv.MustHaveGoBuild(t)\n+\n+\timports, _, err := ScanDir(\"testdata/import1\", map[string]bool{\"*\": true})\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\twant := []string{\"import1\", \"import2\", \"import3\", \"import4\"}\n+\tif !reflect.DeepEqual(imports, want) {\n+\t\tt.Errorf(\"ScanDir testdata/import1:\\nhave %v\\nwant %v\", imports, want)\n+\t}\n+}"}, {"sha": "1c22a472b80d3ff5f5a855fb64b19947d7750be0", "filename": "libgo/go/cmd/go/internal/imports/tags.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftags.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package imports\n+\n+import \"cmd/go/internal/cfg\"\n+\n+var tags map[string]bool\n+\n+func Tags() map[string]bool {\n+\tif tags == nil {\n+\t\ttags = loadTags()\n+\t}\n+\treturn tags\n+}\n+\n+func loadTags() map[string]bool {\n+\ttags := map[string]bool{\n+\t\tcfg.BuildContext.GOOS:     true,\n+\t\tcfg.BuildContext.GOARCH:   true,\n+\t\tcfg.BuildContext.Compiler: true,\n+\t}\n+\tif cfg.BuildContext.CgoEnabled {\n+\t\ttags[\"cgo\"] = true\n+\t}\n+\tfor _, tag := range cfg.BuildContext.BuildTags {\n+\t\ttags[tag] = true\n+\t}\n+\tfor _, tag := range cfg.BuildContext.ReleaseTags {\n+\t\ttags[tag] = true\n+\t}\n+\treturn tags\n+}"}, {"sha": "98f9191053bc3d970c7ef2c6f881e48e4f858ebc", "filename": "libgo/go/cmd/go/internal/imports/testdata/import1/x.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,3 @@\n+package x\n+\n+import \"import1\""}, {"sha": "6a9594aed035e6570d51457d8428cd0fc0a0f73f", "filename": "libgo/go/cmd/go/internal/imports/testdata/import1/x1.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx1.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,9 @@\n+// +build blahblh\n+// +build linux\n+// +build !linux\n+// +build windows\n+// +build darwin\n+\n+package x\n+\n+import \"import4\""}, {"sha": "a0c3fdd21b5f5cc2ce45bb9dc0272e7123f61b18", "filename": "libgo/go/cmd/go/internal/imports/testdata/import1/x_darwin.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx_darwin.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,3 @@\n+package xxxx\n+\n+import \"import3\""}, {"sha": "63c508248fbff9ce6e7ca9defb380209943cbaf7", "filename": "libgo/go/cmd/go/internal/imports/testdata/import1/x_windows.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fimport1%2Fx_windows.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,3 @@\n+package x\n+\n+import \"import2\""}, {"sha": "b3ba4edc65001c852582e788ea1f6673ca7ab6f4", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 441, "deletions": 67, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -7,23 +7,33 @@ package list\n \n import (\n \t\"bufio\"\n+\t\"bytes\"\n \t\"encoding/json\"\n \t\"io\"\n \t\"os\"\n+\t\"sort\"\n \t\"strings\"\n \t\"text/template\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/work\"\n )\n \n var CmdList = &base.Command{\n-\tUsageLine: \"list [-e] [-f format] [-json] [build flags] [packages]\",\n-\tShort:     \"list packages\",\n+\t// Note: -f -json -m are listed explicitly because they are the most common list flags.\n+\t// Do not send CLs removing them because they're covered by [list flags].\n+\tUsageLine: \"go list [-f format] [-json] [-m] [list flags] [build flags] [packages]\",\n+\tShort:     \"list packages or modules\",\n \tLong: `\n-List lists the packages named by the import paths, one per line.\n+List lists the named packages, one per line.\n+The most commonly-used flags are -f and -json, which control the form\n+of the output printed for each package. Other list flags, documented below,\n+control more specific details.\n \n The default output shows the package import path:\n \n@@ -33,40 +43,46 @@ The default output shows the package import path:\n     golang.org/x/net/html\n \n The -f flag specifies an alternate format for the list, using the\n-syntax of package template. The default output is equivalent to -f\n-'{{.ImportPath}}'. The struct being passed to the template is:\n+syntax of package template. The default output is equivalent\n+to -f '{{.ImportPath}}'. The struct being passed to the template is:\n \n     type Package struct {\n-        Dir           string // directory containing package sources\n-        ImportPath    string // import path of package in dir\n-        ImportComment string // path in import comment on package statement\n-        Name          string // package name\n-        Doc           string // package documentation string\n-        Target        string // install path\n-        Shlib         string // the shared library that contains this package (only set when -linkshared)\n-        Goroot        bool   // is this package in the Go root?\n-        Standard      bool   // is this package part of the standard Go library?\n-        Stale         bool   // would 'go install' do anything for this package?\n-        StaleReason   string // explanation for Stale==true\n-        Root          string // Go root or Go path dir containing this package\n-        ConflictDir   string // this directory shadows Dir in $GOPATH\n-        BinaryOnly    bool   // binary-only package: cannot be recompiled from sources\n+        Dir           string   // directory containing package sources\n+        ImportPath    string   // import path of package in dir\n+        ImportComment string   // path in import comment on package statement\n+        Name          string   // package name\n+        Doc           string   // package documentation string\n+        Target        string   // install path\n+        Shlib         string   // the shared library that contains this package (only set when -linkshared)\n+        Goroot        bool     // is this package in the Go root?\n+        Standard      bool     // is this package part of the standard Go library?\n+        Stale         bool     // would 'go install' do anything for this package?\n+        StaleReason   string   // explanation for Stale==true\n+        Root          string   // Go root or Go path dir containing this package\n+        ConflictDir   string   // this directory shadows Dir in $GOPATH\n+        BinaryOnly    bool     // binary-only package: cannot be recompiled from sources\n+        ForTest       string   // package is only for use in named test\n+        Export        string   // file containing export data (when using -export)\n+        Module        *Module  // info about package's containing module, if any (can be nil)\n+        Match         []string // command-line patterns matching this package\n+        DepOnly       bool     // package is only a dependency, not explicitly listed\n \n         // Source files\n-        GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n-        CgoFiles       []string // .go sources files that import \"C\"\n-        IgnoredGoFiles []string // .go sources ignored due to build constraints\n-        CFiles         []string // .c source files\n-        CXXFiles       []string // .cc, .cxx and .cpp source files\n-        MFiles         []string // .m source files\n-        HFiles         []string // .h, .hh, .hpp and .hxx source files\n-        FFiles         []string // .f, .F, .for and .f90 Fortran source files\n-        SFiles         []string // .s source files\n-        SwigFiles      []string // .swig files\n-        SwigCXXFiles   []string // .swigcxx files\n-        SysoFiles      []string // .syso object files to add to archive\n-        TestGoFiles    []string // _test.go files in package\n-        XTestGoFiles   []string // _test.go files outside package\n+        GoFiles         []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+        CgoFiles        []string // .go source files that import \"C\"\n+        CompiledGoFiles []string // .go files presented to compiler (when using -compiled)\n+        IgnoredGoFiles  []string // .go source files ignored due to build constraints\n+        CFiles          []string // .c source files\n+        CXXFiles        []string // .cc, .cxx and .cpp source files\n+        MFiles          []string // .m source files\n+        HFiles          []string // .h, .hh, .hpp and .hxx source files\n+        FFiles          []string // .f, .F, .for and .f90 Fortran source files\n+        SFiles          []string // .s source files\n+        SwigFiles       []string // .swig files\n+        SwigCXXFiles    []string // .swigcxx files\n+        SysoFiles       []string // .syso object files to add to archive\n+        TestGoFiles     []string // _test.go files in package\n+        XTestGoFiles    []string // _test.go files outside package\n \n         // Cgo directives\n         CgoCFLAGS    []string // cgo: flags for C compiler\n@@ -77,10 +93,11 @@ syntax of package template. The default output is equivalent to -f\n         CgoPkgConfig []string // cgo: pkg-config names\n \n         // Dependency information\n-        Imports      []string // import paths used by this package\n-        Deps         []string // all (recursively) imported dependencies\n-        TestImports  []string // imports from TestGoFiles\n-        XTestImports []string // imports from XTestGoFiles\n+        Imports      []string          // import paths used by this package\n+        ImportMap    map[string]string // map from source import to ImportPath (identity entries omitted)\n+        Deps         []string          // all (recursively) imported dependencies\n+        TestImports  []string          // imports from TestGoFiles\n+        XTestImports []string          // imports from XTestGoFiles\n \n         // Error information\n         Incomplete bool            // this package or a dependency has an error\n@@ -92,7 +109,7 @@ Packages stored in vendor directories report an ImportPath that includes the\n path to the vendor directory (for example, \"d/vendor/p\" instead of \"p\"),\n so that the ImportPath uniquely identifies a given copy of a package.\n The Imports, Deps, TestImports, and XTestImports lists also contain these\n-expanded imports paths. See golang.org/s/go15vendor for more about vendoring.\n+expanded import paths. See golang.org/s/go15vendor for more about vendoring.\n \n The error information, if any, is\n \n@@ -102,29 +119,44 @@ The error information, if any, is\n         Err           string   // the error itself\n     }\n \n+The module information is a Module struct, defined in the discussion\n+of list -m below.\n+\n The template function \"join\" calls strings.Join.\n \n The template function \"context\" returns the build context, defined as:\n \n-\ttype Context struct {\n-\t\tGOARCH        string   // target architecture\n-\t\tGOOS          string   // target operating system\n-\t\tGOROOT        string   // Go root\n-\t\tGOPATH        string   // Go path\n-\t\tCgoEnabled    bool     // whether cgo can be used\n-\t\tUseAllFiles   bool     // use files regardless of +build lines, file names\n-\t\tCompiler      string   // compiler to assume when computing target paths\n-\t\tBuildTags     []string // build constraints to match in +build lines\n-\t\tReleaseTags   []string // releases the current release is compatible with\n-\t\tInstallSuffix string   // suffix to use in the name of the install dir\n-\t}\n+    type Context struct {\n+        GOARCH        string   // target architecture\n+        GOOS          string   // target operating system\n+        GOROOT        string   // Go root\n+        GOPATH        string   // Go path\n+        CgoEnabled    bool     // whether cgo can be used\n+        UseAllFiles   bool     // use files regardless of +build lines, file names\n+        Compiler      string   // compiler to assume when computing target paths\n+        BuildTags     []string // build constraints to match in +build lines\n+        ReleaseTags   []string // releases the current release is compatible with\n+        InstallSuffix string   // suffix to use in the name of the install dir\n+    }\n \n For more information about the meaning of these fields see the documentation\n for the go/build package's Context type.\n \n The -json flag causes the package data to be printed in JSON format\n instead of using the template format.\n \n+The -compiled flag causes list to set CompiledGoFiles to the Go source\n+files presented to the compiler. Typically this means that it repeats\n+the files listed in GoFiles and then also adds the Go code generated\n+by processing CgoFiles and SwigFiles. The Imports list contains the\n+union of all imports from both GoFiles and CompiledGoFiles.\n+\n+The -deps flag causes list to iterate over not just the named packages\n+but also all their dependencies. It visits them in a depth-first post-order\n+traversal, so that a package is listed only after all its dependencies.\n+Packages not explicitly listed on the command line will have the DepOnly\n+field set to true.\n+\n The -e flag changes the handling of erroneous packages, those that\n cannot be found or are malformed. By default, the list command\n prints an error to standard error for each erroneous package and\n@@ -135,9 +167,120 @@ printing. Erroneous packages will have a non-empty ImportPath and\n a non-nil Error field; other information may or may not be missing\n (zeroed).\n \n+The -export flag causes list to set the Export field to the name of a\n+file containing up-to-date export information for the given package.\n+\n+The -find flag causes list to identify the named packages but not\n+resolve their dependencies: the Imports and Deps lists will be empty.\n+\n+The -test flag causes list to report not only the named packages\n+but also their test binaries (for packages with tests), to convey to\n+source code analysis tools exactly how test binaries are constructed.\n+The reported import path for a test binary is the import path of\n+the package followed by a \".test\" suffix, as in \"math/rand.test\".\n+When building a test, it is sometimes necessary to rebuild certain\n+dependencies specially for that test (most commonly the tested\n+package itself). The reported import path of a package recompiled\n+for a particular test binary is followed by a space and the name of\n+the test binary in brackets, as in \"math/rand [math/rand.test]\"\n+or \"regexp [sort.test]\". The ForTest field is also set to the name\n+of the package being tested (\"math/rand\" or \"sort\" in the previous\n+examples).\n+\n+The Dir, Target, Shlib, Root, ConflictDir, and Export file paths\n+are all absolute paths.\n+\n+By default, the lists GoFiles, CgoFiles, and so on hold names of files in Dir\n+(that is, paths relative to Dir, not absolute paths).\n+The generated files added when using the -compiled and -test flags\n+are absolute paths referring to cached copies of generated Go source files.\n+Although they are Go source files, the paths may not end in \".go\".\n+\n+The -m flag causes list to list modules instead of packages.\n+\n+When listing modules, the -f flag still specifies a format template\n+applied to a Go struct, but now a Module struct:\n+\n+    type Module struct {\n+        Path     string       // module path\n+        Version  string       // module version\n+        Versions []string     // available module versions (with -versions)\n+        Replace  *Module      // replaced by this module\n+        Time     *time.Time   // time version was created\n+        Update   *Module      // available update, if any (with -u)\n+        Main     bool         // is this the main module?\n+        Indirect bool         // is this module only an indirect dependency of main module?\n+        Dir      string       // directory holding files for this module, if any\n+        GoMod    string       // path to go.mod file for this module, if any\n+        Error    *ModuleError // error loading module\n+    }\n+\n+    type ModuleError struct {\n+        Err string // the error itself\n+    }\n+\n+The default output is to print the module path and then\n+information about the version and replacement if any.\n+For example, 'go list -m all' might print:\n+\n+    my/main/module\n+    golang.org/x/text v0.3.0 => /tmp/text\n+    rsc.io/pdf v0.1.1\n+\n+The Module struct has a String method that formats this\n+line of output, so that the default format is equivalent\n+to -f '{{.String}}'.\n+\n+Note that when a module has been replaced, its Replace field\n+describes the replacement module, and its Dir field is set to\n+the replacement's source code, if present. (That is, if Replace\n+is non-nil, then Dir is set to Replace.Dir, with no access to\n+the replaced source code.)\n+\n+The -u flag adds information about available upgrades.\n+When the latest version of a given module is newer than\n+the current one, list -u sets the Module's Update field\n+to information about the newer module.\n+The Module's String method indicates an available upgrade by\n+formatting the newer version in brackets after the current version.\n+For example, 'go list -m -u all' might print:\n+\n+    my/main/module\n+    golang.org/x/text v0.3.0 [v0.4.0] => /tmp/text\n+    rsc.io/pdf v0.1.1 [v0.1.2]\n+\n+(For tools, 'go list -m -u -json all' may be more convenient to parse.)\n+\n+The -versions flag causes list to set the Module's Versions field\n+to a list of all known versions of that module, ordered according\n+to semantic versioning, earliest to latest. The flag also changes\n+the default output format to display the module path followed by the\n+space-separated version list.\n+\n+The arguments to list -m are interpreted as a list of modules, not packages.\n+The main module is the module containing the current directory.\n+The active modules are the main module and its dependencies.\n+With no arguments, list -m shows the main module.\n+With arguments, list -m shows the modules specified by the arguments.\n+Any of the active modules can be specified by its module path.\n+The special pattern \"all\" specifies all the active modules, first the main\n+module and then dependencies sorted by module path.\n+A pattern containing \"...\" specifies the active modules whose\n+module paths match the pattern.\n+A query of the form path@version specifies the result of that query,\n+which is not limited to active modules.\n+See 'go help modules' for more about module queries.\n+\n+The template function \"module\" takes a single string argument\n+that must be a module path or query and returns the specified\n+module as a Module struct. If an error occurs, the result will\n+be a Module struct with a non-nil Error field.\n+\n For more about build flags, see 'go help build'.\n \n For more about specifying packages, see 'go help packages'.\n+\n+For more about modules, see 'go help modules'.\n \t`,\n }\n \n@@ -146,20 +289,43 @@ func init() {\n \twork.AddBuildFlags(CmdList)\n }\n \n-var listE = CmdList.Flag.Bool(\"e\", false, \"\")\n-var listFmt = CmdList.Flag.String(\"f\", \"{{.ImportPath}}\", \"\")\n-var listJson = CmdList.Flag.Bool(\"json\", false, \"\")\n+var (\n+\tlistCompiled = CmdList.Flag.Bool(\"compiled\", false, \"\")\n+\tlistDeps     = CmdList.Flag.Bool(\"deps\", false, \"\")\n+\tlistE        = CmdList.Flag.Bool(\"e\", false, \"\")\n+\tlistExport   = CmdList.Flag.Bool(\"export\", false, \"\")\n+\tlistFmt      = CmdList.Flag.String(\"f\", \"\", \"\")\n+\tlistFind     = CmdList.Flag.Bool(\"find\", false, \"\")\n+\tlistJson     = CmdList.Flag.Bool(\"json\", false, \"\")\n+\tlistM        = CmdList.Flag.Bool(\"m\", false, \"\")\n+\tlistU        = CmdList.Flag.Bool(\"u\", false, \"\")\n+\tlistTest     = CmdList.Flag.Bool(\"test\", false, \"\")\n+\tlistVersions = CmdList.Flag.Bool(\"versions\", false, \"\")\n+)\n+\n var nl = []byte{'\\n'}\n \n func runList(cmd *base.Command, args []string) {\n+\tmodload.LoadTests = *listTest\n \twork.BuildInit()\n \tout := newTrackingWriter(os.Stdout)\n \tdefer out.w.Flush()\n \n-\tvar do func(*load.PackagePublic)\n+\tif *listFmt == \"\" {\n+\t\tif *listM {\n+\t\t\t*listFmt = \"{{.String}}\"\n+\t\t\tif *listVersions {\n+\t\t\t\t*listFmt = `{{.Path}}{{range .Versions}} {{.}}{{end}}`\n+\t\t\t}\n+\t\t} else {\n+\t\t\t*listFmt = \"{{.ImportPath}}\"\n+\t\t}\n+\t}\n+\n+\tvar do func(interface{})\n \tif *listJson {\n-\t\tdo = func(p *load.PackagePublic) {\n-\t\t\tb, err := json.MarshalIndent(p, \"\", \"\\t\")\n+\t\tdo = func(x interface{}) {\n+\t\t\tb, err := json.MarshalIndent(x, \"\", \"\\t\")\n \t\t\tif err != nil {\n \t\t\t\tout.Flush()\n \t\t\t\tbase.Fatalf(\"%s\", err)\n@@ -178,13 +344,14 @@ func runList(cmd *base.Command, args []string) {\n \t\tfm := template.FuncMap{\n \t\t\t\"join\":    strings.Join,\n \t\t\t\"context\": context,\n+\t\t\t\"module\":  modload.ModuleInfo,\n \t\t}\n \t\ttmpl, err := template.New(\"main\").Funcs(fm).Parse(*listFmt)\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"%s\", err)\n \t\t}\n-\t\tdo = func(p *load.PackagePublic) {\n-\t\t\tif err := tmpl.Execute(out, p); err != nil {\n+\t\tdo = func(x interface{}) {\n+\t\t\tif err := tmpl.Execute(out, x); err != nil {\n \t\t\t\tout.Flush()\n \t\t\t\tbase.Fatalf(\"%s\", err)\n \t\t\t}\n@@ -194,34 +361,241 @@ func runList(cmd *base.Command, args []string) {\n \t\t}\n \t}\n \n+\tif *listM {\n+\t\t// Module mode.\n+\t\tif *listCompiled {\n+\t\t\tbase.Fatalf(\"go list -compiled cannot be used with -m\")\n+\t\t}\n+\t\tif *listDeps {\n+\t\t\t// TODO(rsc): Could make this mean something with -m.\n+\t\t\tbase.Fatalf(\"go list -deps cannot be used with -m\")\n+\t\t}\n+\t\tif *listExport {\n+\t\t\tbase.Fatalf(\"go list -export cannot be used with -m\")\n+\t\t}\n+\t\tif *listFind {\n+\t\t\tbase.Fatalf(\"go list -find cannot be used with -m\")\n+\t\t}\n+\t\tif *listTest {\n+\t\t\tbase.Fatalf(\"go list -test cannot be used with -m\")\n+\t\t}\n+\n+\t\tif modload.Init(); !modload.Enabled() {\n+\t\t\tbase.Fatalf(\"go list -m: not using modules\")\n+\t\t}\n+\t\tmodload.LoadBuildList()\n+\n+\t\tmods := modload.ListModules(args, *listU, *listVersions)\n+\t\tif !*listE {\n+\t\t\tfor _, m := range mods {\n+\t\t\t\tif m.Error != nil {\n+\t\t\t\t\tbase.Errorf(\"go list -m %s: %v\", m.Path, m.Error.Err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbase.ExitIfErrors()\n+\t\t}\n+\t\tfor _, m := range mods {\n+\t\t\tdo(m)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\t// Package mode (not -m).\n+\tif *listU {\n+\t\tbase.Fatalf(\"go list -u can only be used with -m\")\n+\t}\n+\tif *listVersions {\n+\t\tbase.Fatalf(\"go list -versions can only be used with -m\")\n+\t}\n+\n+\t// These pairings make no sense.\n+\tif *listFind && *listDeps {\n+\t\tbase.Fatalf(\"go list -deps cannot be used with -find\")\n+\t}\n+\tif *listFind && *listTest {\n+\t\tbase.Fatalf(\"go list -test cannot be used with -find\")\n+\t}\n+\n+\tload.IgnoreImports = *listFind\n \tvar pkgs []*load.Package\n \tif *listE {\n \t\tpkgs = load.PackagesAndErrors(args)\n \t} else {\n \t\tpkgs = load.Packages(args)\n \t}\n \n-\t// Estimate whether staleness information is needed,\n-\t// since it's a little bit of work to compute.\n+\tif cache.Default() == nil {\n+\t\t// These flags return file names pointing into the build cache,\n+\t\t// so the build cache must exist.\n+\t\tif *listCompiled {\n+\t\t\tbase.Fatalf(\"go list -compiled requires build cache\")\n+\t\t}\n+\t\tif *listExport {\n+\t\t\tbase.Fatalf(\"go list -export requires build cache\")\n+\t\t}\n+\t\tif *listTest {\n+\t\t\tbase.Fatalf(\"go list -test requires build cache\")\n+\t\t}\n+\t}\n+\n+\tif *listTest {\n+\t\tc := cache.Default()\n+\t\t// Add test binaries to packages to be listed.\n+\t\tfor _, p := range pkgs {\n+\t\t\tif p.Error != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif len(p.TestGoFiles)+len(p.XTestGoFiles) > 0 {\n+\t\t\t\tpmain, ptest, pxtest, err := load.GetTestPackagesFor(p, nil)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tif *listE {\n+\t\t\t\t\t\tpkgs = append(pkgs, &load.Package{\n+\t\t\t\t\t\t\tPackagePublic: load.PackagePublic{\n+\t\t\t\t\t\t\t\tImportPath: p.ImportPath + \".test\",\n+\t\t\t\t\t\t\t\tError:      &load.PackageError{Err: err.Error()},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tbase.Errorf(\"can't load test package: %s\", err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tpkgs = append(pkgs, pmain)\n+\t\t\t\tif ptest != nil {\n+\t\t\t\t\tpkgs = append(pkgs, ptest)\n+\t\t\t\t}\n+\t\t\t\tif pxtest != nil {\n+\t\t\t\t\tpkgs = append(pkgs, pxtest)\n+\t\t\t\t}\n+\n+\t\t\t\tdata := *pmain.Internal.TestmainGo\n+\t\t\t\th := cache.NewHash(\"testmain\")\n+\t\t\t\th.Write([]byte(\"testmain\\n\"))\n+\t\t\t\th.Write(data)\n+\t\t\t\tout, _, err := c.Put(h.Sum(), bytes.NewReader(data))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tbase.Fatalf(\"%s\", err)\n+\t\t\t\t}\n+\t\t\t\tpmain.GoFiles[0] = c.OutputFile(out)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Remember which packages are named on the command line.\n+\tcmdline := make(map[*load.Package]bool)\n+\tfor _, p := range pkgs {\n+\t\tcmdline[p] = true\n+\t}\n+\n+\tif *listDeps {\n+\t\t// Note: This changes the order of the listed packages\n+\t\t// from \"as written on the command line\" to\n+\t\t// \"a depth-first post-order traversal\".\n+\t\t// (The dependency exploration order for a given node\n+\t\t// is alphabetical, same as listed in .Deps.)\n+\t\t// Note that -deps is applied after -test,\n+\t\t// so that you only get descriptions of tests for the things named\n+\t\t// explicitly on the command line, not for all dependencies.\n+\t\tpkgs = load.PackageList(pkgs)\n+\t}\n+\n+\t// Do we need to run a build to gather information?\n \tneedStale := *listJson || strings.Contains(*listFmt, \".Stale\")\n-\tif needStale {\n+\tif needStale || *listExport || *listCompiled {\n \t\tvar b work.Builder\n \t\tb.Init()\n-\t\tb.ComputeStaleOnly = true\n+\t\tb.IsCmdList = true\n+\t\tb.NeedExport = *listExport\n+\t\tb.NeedCompiledGoFiles = *listCompiled\n \t\ta := &work.Action{}\n \t\t// TODO: Use pkgsFilter?\n \t\tfor _, p := range pkgs {\n-\t\t\ta.Deps = append(a.Deps, b.AutoAction(work.ModeInstall, work.ModeInstall, p))\n+\t\t\tif len(p.GoFiles)+len(p.CgoFiles) > 0 {\n+\t\t\t\ta.Deps = append(a.Deps, b.AutoAction(work.ModeInstall, work.ModeInstall, p))\n+\t\t\t}\n \t\t}\n \t\tb.Do(a)\n \t}\n \n-\tfor _, pkg := range pkgs {\n+\tfor _, p := range pkgs {\n \t\t// Show vendor-expanded paths in listing\n-\t\tpkg.TestImports = pkg.Resolve(pkg.TestImports)\n-\t\tpkg.XTestImports = pkg.Resolve(pkg.XTestImports)\n+\t\tp.TestImports = p.Resolve(p.TestImports)\n+\t\tp.XTestImports = p.Resolve(p.XTestImports)\n+\t\tp.DepOnly = !cmdline[p]\n+\n+\t\tif *listCompiled {\n+\t\t\tp.Imports = str.StringList(p.Imports, p.Internal.CompiledImports)\n+\t\t}\n+\t}\n+\n+\tif *listTest {\n+\t\tall := pkgs\n+\t\tif !*listDeps {\n+\t\t\tall = load.PackageList(pkgs)\n+\t\t}\n+\t\t// Update import paths to distinguish the real package p\n+\t\t// from p recompiled for q.test.\n+\t\t// This must happen only once the build code is done\n+\t\t// looking at import paths, because it will get very confused\n+\t\t// if it sees these.\n+\t\told := make(map[string]string)\n+\t\tfor _, p := range all {\n+\t\t\tif p.ForTest != \"\" {\n+\t\t\t\tnew := p.ImportPath + \" [\" + p.ForTest + \".test]\"\n+\t\t\t\told[new] = p.ImportPath\n+\t\t\t\tp.ImportPath = new\n+\t\t\t}\n+\t\t\tp.DepOnly = !cmdline[p]\n+\t\t}\n+\t\t// Update import path lists to use new strings.\n+\t\tm := make(map[string]string)\n+\t\tfor _, p := range all {\n+\t\t\tfor _, p1 := range p.Internal.Imports {\n+\t\t\t\tif p1.ForTest != \"\" {\n+\t\t\t\t\tm[old[p1.ImportPath]] = p1.ImportPath\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor i, old := range p.Imports {\n+\t\t\t\tif new := m[old]; new != \"\" {\n+\t\t\t\t\tp.Imports[i] = new\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor old := range m {\n+\t\t\t\tdelete(m, old)\n+\t\t\t}\n+\t\t}\n+\t\t// Recompute deps lists using new strings, from the leaves up.\n+\t\tfor _, p := range all {\n+\t\t\tdeps := make(map[string]bool)\n+\t\t\tfor _, p1 := range p.Internal.Imports {\n+\t\t\t\tdeps[p1.ImportPath] = true\n+\t\t\t\tfor _, d := range p1.Deps {\n+\t\t\t\t\tdeps[d] = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tp.Deps = make([]string, 0, len(deps))\n+\t\t\tfor d := range deps {\n+\t\t\t\tp.Deps = append(p.Deps, d)\n+\t\t\t}\n+\t\t\tsort.Strings(p.Deps)\n+\t\t}\n+\t}\n+\n+\t// Record non-identity import mappings in p.ImportMap.\n+\tfor _, p := range pkgs {\n+\t\tfor i, srcPath := range p.Internal.RawImports {\n+\t\t\tpath := p.Imports[i]\n+\t\t\tif path != srcPath {\n+\t\t\t\tif p.ImportMap == nil {\n+\t\t\t\t\tp.ImportMap = make(map[string]string)\n+\t\t\t\t}\n+\t\t\t\tp.ImportMap[srcPath] = path\n+\t\t\t}\n+\t\t}\n+\t}\n \n-\t\tdo(&pkg.PackagePublic)\n+\tfor _, p := range pkgs {\n+\t\tdo(&p.PackagePublic)\n \t}\n }\n "}, {"sha": "7534e65f54c75309ee5fc3bcbe4fa3222481f9d0", "filename": "libgo/go/cmd/go/internal/load/flag.go", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -91,31 +91,3 @@ func (f *PerPackageFlag) For(p *Package) []string {\n \t}\n \treturn flags\n }\n-\n-var cmdlineMatchers []func(*Package) bool\n-\n-// SetCmdlinePatterns records the set of patterns given on the command line,\n-// for use by the PerPackageFlags.\n-func SetCmdlinePatterns(args []string) {\n-\tsetCmdlinePatterns(args, base.Cwd)\n-}\n-\n-func setCmdlinePatterns(args []string, cwd string) {\n-\tif len(args) == 0 {\n-\t\targs = []string{\".\"}\n-\t}\n-\tcmdlineMatchers = nil // allow reset for testing\n-\tfor _, arg := range args {\n-\t\tcmdlineMatchers = append(cmdlineMatchers, MatchPackage(arg, cwd))\n-\t}\n-}\n-\n-// isCmdlinePkg reports whether p is a package listed on the command line.\n-func isCmdlinePkg(p *Package) bool {\n-\tfor _, m := range cmdlineMatchers {\n-\t\tif m(p) {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}"}, {"sha": "0211b284a407a2b612299570f1db7380aa05cb31", "filename": "libgo/go/cmd/go/internal/load/path.go", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -32,22 +32,6 @@ func hasSubdir(root, dir string) (rel string, ok bool) {\n \treturn filepath.ToSlash(dir[len(root):]), true\n }\n \n-// hasPathPrefix reports whether the path s begins with the\n-// elements in prefix.\n-func hasPathPrefix(s, prefix string) bool {\n-\tswitch {\n-\tdefault:\n-\t\treturn false\n-\tcase len(s) == len(prefix):\n-\t\treturn s == prefix\n-\tcase len(s) > len(prefix):\n-\t\tif prefix != \"\" && prefix[len(prefix)-1] == '/' {\n-\t\t\treturn strings.HasPrefix(s, prefix)\n-\t\t}\n-\t\treturn s[len(prefix)] == '/' && s[:len(prefix)] == prefix\n-\t}\n-}\n-\n // expandPath returns the symlink-expanded form of path.\n func expandPath(p string) string {\n \tx, err := filepath.EvalSymlinks(p)"}, {"sha": "0579fd5ca539acfae7a6c5c0a4481f9b74fb9500", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 405, "deletions": 279, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -22,9 +22,26 @@ import (\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/modinfo\"\n+\t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/str\"\n )\n \n+var (\n+\t// module initialization hook; never nil, no-op if module use is disabled\n+\tModInit func()\n+\n+\t// module hooks; nil if module use is disabled\n+\tModBinDir            func() string                                       // return effective bin directory\n+\tModLookup            func(path string) (dir, realPath string, err error) // lookup effective meaning of import\n+\tModPackageModuleInfo func(path string) *modinfo.ModulePublic             // return module info for Package struct\n+\tModImportPaths       func(args []string) []*search.Match                 // expand import paths\n+\tModPackageBuildInfo  func(main string, deps []string) string             // return module info to embed in binary\n+\tModInfoProg          func(info string) []byte                            // wrap module info in .go code for binary\n+\tModImportFromFiles   func([]string)                                      // update go.mod to add modules for imports in these files\n+\tModDirImportPath     func(string) string                                 // return effective import path for directory\n+)\n+\n var IgnoreImports bool // control whether we ignore imports in packages\n \n // A Package describes a single package found in a directory.\n@@ -37,18 +54,24 @@ type PackagePublic struct {\n \t// Note: These fields are part of the go command's public API.\n \t// See list.go. It is okay to add fields, but not to change or\n \t// remove existing ones. Keep in sync with list.go\n-\tDir           string `json:\",omitempty\"` // directory containing package sources\n-\tImportPath    string `json:\",omitempty\"` // import path of package in dir\n-\tImportComment string `json:\",omitempty\"` // path in import comment on package statement\n-\tName          string `json:\",omitempty\"` // package name\n-\tDoc           string `json:\",omitempty\"` // package documentation string\n-\tTarget        string `json:\",omitempty\"` // installed target for this package (may be executable)\n-\tShlib         string `json:\",omitempty\"` // the shared library that contains this package (only set when -linkshared)\n-\tGoroot        bool   `json:\",omitempty\"` // is this package found in the Go root?\n-\tStandard      bool   `json:\",omitempty\"` // is this package part of the standard Go library?\n-\tRoot          string `json:\",omitempty\"` // Go root or Go path dir containing this package\n-\tConflictDir   string `json:\",omitempty\"` // Dir is hidden by this other directory\n-\tBinaryOnly    bool   `json:\",omitempty\"` // package cannot be recompiled\n+\tDir           string                `json:\",omitempty\"` // directory containing package sources\n+\tImportPath    string                `json:\",omitempty\"` // import path of package in dir\n+\tImportComment string                `json:\",omitempty\"` // path in import comment on package statement\n+\tName          string                `json:\",omitempty\"` // package name\n+\tDoc           string                `json:\",omitempty\"` // package documentation string\n+\tTarget        string                `json:\",omitempty\"` // installed target for this package (may be executable)\n+\tShlib         string                `json:\",omitempty\"` // the shared library that contains this package (only set when -linkshared)\n+\tRoot          string                `json:\",omitempty\"` // Go root or Go path dir containing this package\n+\tConflictDir   string                `json:\",omitempty\"` // Dir is hidden by this other directory\n+\tForTest       string                `json:\",omitempty\"` // package is only for use in named test\n+\tExport        string                `json:\",omitempty\"` // file containing export data (set by go list -export)\n+\tModule        *modinfo.ModulePublic `json:\",omitempty\"` // info about package's module, if any\n+\tMatch         []string              `json:\",omitempty\"` // command-line patterns matching this package\n+\tGoroot        bool                  `json:\",omitempty\"` // is this package found in the Go root?\n+\tStandard      bool                  `json:\",omitempty\"` // is this package part of the standard Go library?\n+\tDepOnly       bool                  `json:\",omitempty\"` // package is only as a dependency, not explicitly listed\n+\tBinaryOnly    bool                  `json:\",omitempty\"` // package cannot be recompiled\n+\tIncomplete    bool                  `json:\",omitempty\"` // was there an error loading this package or dependencies?\n \n \t// Stale and StaleReason remain here *only* for the list command.\n \t// They are only initialized in preparation for list execution.\n@@ -59,18 +82,19 @@ type PackagePublic struct {\n \t// Source files\n \t// If you add to this list you MUST add to p.AllFiles (below) too.\n \t// Otherwise file name security lists will not apply to any new additions.\n-\tGoFiles        []string `json:\",omitempty\"` // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n-\tCgoFiles       []string `json:\",omitempty\"` // .go sources files that import \"C\"\n-\tIgnoredGoFiles []string `json:\",omitempty\"` // .go sources ignored due to build constraints\n-\tCFiles         []string `json:\",omitempty\"` // .c source files\n-\tCXXFiles       []string `json:\",omitempty\"` // .cc, .cpp and .cxx source files\n-\tMFiles         []string `json:\",omitempty\"` // .m source files\n-\tHFiles         []string `json:\",omitempty\"` // .h, .hh, .hpp and .hxx source files\n-\tFFiles         []string `json:\",omitempty\"` // .f, .F, .for and .f90 Fortran source files\n-\tSFiles         []string `json:\",omitempty\"` // .s source files\n-\tSwigFiles      []string `json:\",omitempty\"` // .swig files\n-\tSwigCXXFiles   []string `json:\",omitempty\"` // .swigcxx files\n-\tSysoFiles      []string `json:\",omitempty\"` // .syso system object files added to package\n+\tGoFiles         []string `json:\",omitempty\"` // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+\tCgoFiles        []string `json:\",omitempty\"` // .go source files that import \"C\"\n+\tCompiledGoFiles []string `json:\",omitempty\"` // .go output from running cgo on CgoFiles\n+\tIgnoredGoFiles  []string `json:\",omitempty\"` // .go source files ignored due to build constraints\n+\tCFiles          []string `json:\",omitempty\"` // .c source files\n+\tCXXFiles        []string `json:\",omitempty\"` // .cc, .cpp and .cxx source files\n+\tMFiles          []string `json:\",omitempty\"` // .m source files\n+\tHFiles          []string `json:\",omitempty\"` // .h, .hh, .hpp and .hxx source files\n+\tFFiles          []string `json:\",omitempty\"` // .f, .F, .for and .f90 Fortran source files\n+\tSFiles          []string `json:\",omitempty\"` // .s source files\n+\tSwigFiles       []string `json:\",omitempty\"` // .swig files\n+\tSwigCXXFiles    []string `json:\",omitempty\"` // .swigcxx files\n+\tSysoFiles       []string `json:\",omitempty\"` // .syso system object files added to package\n \n \t// Cgo directives\n \tCgoCFLAGS    []string `json:\",omitempty\"` // cgo: flags for C compiler\n@@ -81,11 +105,12 @@ type PackagePublic struct {\n \tCgoPkgConfig []string `json:\",omitempty\"` // cgo: pkg-config names\n \n \t// Dependency information\n-\tImports []string `json:\",omitempty\"` // import paths used by this package\n-\tDeps    []string `json:\",omitempty\"` // all (recursively) imported dependencies\n+\tImports   []string          `json:\",omitempty\"` // import paths used by this package\n+\tImportMap map[string]string `json:\",omitempty\"` // map from source import to ImportPath (identity entries omitted)\n+\tDeps      []string          `json:\",omitempty\"` // all (recursively) imported dependencies\n \n \t// Error information\n-\tIncomplete bool            `json:\",omitempty\"` // was there an error loading this package or dependencies?\n+\t// Incomplete is above, packed into the other bools\n \tError      *PackageError   `json:\",omitempty\"` // error loading this package (not dependencies)\n \tDepsErrors []*PackageError `json:\",omitempty\"` // errors loading dependencies\n \n@@ -107,6 +132,7 @@ func (p *Package) AllFiles() []string {\n \treturn str.StringList(\n \t\tp.GoFiles,\n \t\tp.CgoFiles,\n+\t\t// no p.CompiledGoFiles, because they are from GoFiles or generated by us\n \t\tp.IgnoredGoFiles,\n \t\tp.CFiles,\n \t\tp.CXXFiles,\n@@ -122,21 +148,33 @@ func (p *Package) AllFiles() []string {\n \t)\n }\n \n+// Desc returns the package \"description\", for use in b.showOutput.\n+func (p *Package) Desc() string {\n+\tif p.ForTest != \"\" {\n+\t\treturn p.ImportPath + \" [\" + p.ForTest + \".test]\"\n+\t}\n+\treturn p.ImportPath\n+}\n+\n type PackageInternal struct {\n \t// Unexported fields are not part of the public API.\n-\tBuild        *build.Package\n-\tImports      []*Package           // this package's direct imports\n-\tRawImports   []string             // this package's original imports as they appear in the text of the program\n-\tForceLibrary bool                 // this package is a library (even if named \"main\")\n-\tCmdlineFiles bool                 // package built from files listed on command line\n-\tCmdlinePkg   bool                 // package listed on command line\n-\tLocal        bool                 // imported via local path (./ or ../)\n-\tLocalPrefix  string               // interpret ./ and ../ imports relative to this prefix\n-\tExeName      string               // desired name for temporary executable\n-\tCoverMode    string               // preprocess Go source files with the coverage tool in this mode\n-\tCoverVars    map[string]*CoverVar // variables created by coverage analysis\n-\tOmitDebug    bool                 // tell linker not to write debug information\n-\tGobinSubdir  bool                 // install target would be subdir of GOBIN\n+\tBuild             *build.Package\n+\tImports           []*Package           // this package's direct imports\n+\tCompiledImports   []string             // additional Imports necessary when using CompiledGoFiles (all from standard library)\n+\tRawImports        []string             // this package's original imports as they appear in the text of the program\n+\tForceLibrary      bool                 // this package is a library (even if named \"main\")\n+\tCmdlineFiles      bool                 // package built from files listed on command line\n+\tCmdlinePkg        bool                 // package listed on command line\n+\tCmdlinePkgLiteral bool                 // package listed as literal on command line (not via wildcard)\n+\tLocal             bool                 // imported via local path (./ or ../)\n+\tLocalPrefix       string               // interpret ./ and ../ imports relative to this prefix\n+\tExeName           string               // desired name for temporary executable\n+\tCoverMode         string               // preprocess Go source files with the coverage tool in this mode\n+\tCoverVars         map[string]*CoverVar // variables created by coverage analysis\n+\tOmitDebug         bool                 // tell linker not to write debug information\n+\tGobinSubdir       bool                 // install target would be subdir of GOBIN\n+\tBuildInfo         string               // add this info to package main\n+\tTestmainGo        *[]byte              // content for _testmain.go\n \n \tAsmflags   []string // -asmflags for this package\n \tGcflags    []string // -gcflags for this package\n@@ -224,7 +262,7 @@ func (p *Package) copyBuild(pp *build.Package) {\n \n \t// TODO? Target\n \tp.Goroot = pp.Goroot\n-\tp.Standard = p.Goroot && p.ImportPath != \"\" && isStandardImportPath(p.ImportPath)\n+\tp.Standard = p.Goroot && p.ImportPath != \"\" && search.IsStandardImportPath(p.ImportPath)\n \tp.GoFiles = pp.GoFiles\n \tp.CgoFiles = pp.CgoFiles\n \tp.IgnoredGoFiles = pp.IgnoredGoFiles\n@@ -253,24 +291,12 @@ func (p *Package) copyBuild(pp *build.Package) {\n \tp.XTestImports = pp.XTestImports\n \tif IgnoreImports {\n \t\tp.Imports = nil\n+\t\tp.Internal.RawImports = nil\n \t\tp.TestImports = nil\n \t\tp.XTestImports = nil\n \t}\n }\n \n-// isStandardImportPath reports whether $GOROOT/src/path should be considered\n-// part of the standard distribution. For historical reasons we allow people to add\n-// their own code to $GOROOT instead of using $GOPATH, but we assume that\n-// code will start with a domain name (dot in the first element).\n-func isStandardImportPath(path string) bool {\n-\ti := strings.Index(path, \"/\")\n-\tif i < 0 {\n-\t\ti = len(path)\n-\t}\n-\telem := path[:i]\n-\treturn !strings.Contains(elem, \".\")\n-}\n-\n // A PackageError describes an error loading information about a package.\n type PackageError struct {\n \tImportStack   []string // shortest path from package named on command line to this one\n@@ -296,7 +322,9 @@ func (p *PackageError) Error() string {\n \treturn \"package \" + strings.Join(p.ImportStack, \"\\n\\timports \") + \": \" + p.Err\n }\n \n-// An ImportStack is a stack of import paths.\n+// An ImportStack is a stack of import paths, possibly with the suffix \" (test)\" appended.\n+// The import path of a test package is the import path of the corresponding\n+// non-test package with the suffix \"_test\" added.\n type ImportStack []string\n \n func (s *ImportStack) Push(p string) {\n@@ -349,15 +377,17 @@ func ClearPackageCachePartial(args []string) {\n \t}\n }\n \n-// reloadPackage is like loadPackage but makes sure\n+// ReloadPackageNoFlags is like LoadPackageNoFlags but makes sure\n // not to use the package cache.\n-func ReloadPackage(arg string, stk *ImportStack) *Package {\n+// It is only for use by GOPATH-based \"go get\".\n+// TODO(rsc): When GOPATH-based \"go get\" is removed, delete this function.\n+func ReloadPackageNoFlags(arg string, stk *ImportStack) *Package {\n \tp := packageCache[arg]\n \tif p != nil {\n \t\tdelete(packageCache, p.Dir)\n \t\tdelete(packageCache, p.ImportPath)\n \t}\n-\treturn LoadPackage(arg, stk)\n+\treturn LoadPackageNoFlags(arg, stk)\n }\n \n // dirToImportPath returns the pseudo-import path we use for a package\n@@ -406,10 +436,53 @@ const (\n // but possibly a local import path (an absolute file system path or one beginning\n // with ./ or ../). A local relative path is interpreted relative to srcDir.\n // It returns a *Package describing the package found in that directory.\n+// LoadImport does not set tool flags and should only be used by\n+// this package, as part of a bigger load operation, and by GOPATH-based \"go get\".\n+// TODO(rsc): When GOPATH-based \"go get\" is removed, unexport this function.\n func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n \tstk.Push(path)\n \tdefer stk.Pop()\n \n+\tif strings.HasPrefix(path, \"mod/\") {\n+\t\t// Paths beginning with \"mod/\" might accidentally\n+\t\t// look in the module cache directory tree in $GOPATH/pkg/mod/.\n+\t\t// This prefix is owned by the Go core for possible use in the\n+\t\t// standard library (since it does not begin with a domain name),\n+\t\t// so it's OK to disallow entirely.\n+\t\treturn &Package{\n+\t\t\tPackagePublic: PackagePublic{\n+\t\t\t\tImportPath: path,\n+\t\t\t\tError: &PackageError{\n+\t\t\t\t\tImportStack: stk.Copy(),\n+\t\t\t\t\tErr:         fmt.Sprintf(\"disallowed import path %q\", path),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\tif strings.Contains(path, \"@\") {\n+\t\tvar text string\n+\t\tif cfg.ModulesEnabled {\n+\t\t\ttext = \"can only use path@version syntax with 'go get'\"\n+\t\t} else {\n+\t\t\ttext = \"cannot use path@version syntax in GOPATH mode\"\n+\t\t}\n+\t\treturn &Package{\n+\t\t\tPackagePublic: PackagePublic{\n+\t\t\t\tImportPath: path,\n+\t\t\t\tError: &PackageError{\n+\t\t\t\t\tImportStack: stk.Copy(),\n+\t\t\t\t\tErr:         text,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\tparentPath := \"\"\n+\tif parent != nil {\n+\t\tparentPath = parent.ImportPath\n+\t}\n+\n \t// Determine canonical identifier for this package.\n \t// For a local import the identifier is the pseudo-import path\n \t// we create from the full directory to the package.\n@@ -418,8 +491,16 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \timportPath := path\n \torigPath := path\n \tisLocal := build.IsLocalImport(path)\n+\tvar modDir string\n+\tvar modErr error\n \tif isLocal {\n \t\timportPath = dirToImportPath(filepath.Join(srcDir, path))\n+\t} else if cfg.ModulesEnabled {\n+\t\tvar p string\n+\t\tmodDir, p, modErr = ModLookup(path)\n+\t\tif modErr == nil {\n+\t\t\timportPath = p\n+\t\t}\n \t} else if mode&ResolveImport != 0 {\n \t\t// We do our own path resolution, because we want to\n \t\t// find out the key to use in packageCache without the\n@@ -444,17 +525,31 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \t\t// Load package.\n \t\t// Import always returns bp != nil, even if an error occurs,\n \t\t// in order to return partial information.\n-\t\tbuildMode := build.ImportComment\n-\t\tif mode&ResolveImport == 0 || path != origPath {\n-\t\t\t// Not vendoring, or we already found the vendored path.\n-\t\t\tbuildMode |= build.IgnoreVendor\n+\t\tvar bp *build.Package\n+\t\tvar err error\n+\t\tif modDir != \"\" {\n+\t\t\tbp, err = cfg.BuildContext.ImportDir(modDir, 0)\n+\t\t} else if modErr != nil {\n+\t\t\tbp = new(build.Package)\n+\t\t\terr = fmt.Errorf(\"unknown import path %q: %v\", importPath, modErr)\n+\t\t} else if cfg.ModulesEnabled && path != \"unsafe\" {\n+\t\t\tbp = new(build.Package)\n+\t\t\terr = fmt.Errorf(\"unknown import path %q: internal error: module loader did not resolve import\", importPath)\n+\t\t} else {\n+\t\t\tbuildMode := build.ImportComment\n+\t\t\tif mode&ResolveImport == 0 || path != origPath {\n+\t\t\t\t// Not vendoring, or we already found the vendored path.\n+\t\t\t\tbuildMode |= build.IgnoreVendor\n+\t\t\t}\n+\t\t\tbp, err = cfg.BuildContext.Import(path, srcDir, buildMode)\n \t\t}\n-\t\tbp, err := cfg.BuildContext.Import(path, srcDir, buildMode)\n \t\tbp.ImportPath = importPath\n \t\tif cfg.GOBIN != \"\" {\n \t\t\tbp.BinDir = cfg.GOBIN\n+\t\t} else if cfg.ModulesEnabled {\n+\t\t\tbp.BinDir = ModBinDir()\n \t\t}\n-\t\tif err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path &&\n+\t\tif modDir == \"\" && err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path &&\n \t\t\t!strings.Contains(path, \"/vendor/\") && !strings.HasPrefix(path, \"vendor/\") {\n \t\t\terr = fmt.Errorf(\"code in directory %s expects import %q\", bp.Dir, bp.ImportComment)\n \t\t}\n@@ -463,7 +558,7 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \t\t\tp = setErrorPos(p, importPos)\n \t\t}\n \n-\t\tif origPath != cleanImport(origPath) {\n+\t\tif modDir == \"\" && origPath != cleanImport(origPath) {\n \t\t\tp.Error = &PackageError{\n \t\t\t\tImportStack: stk.Copy(),\n \t\t\t\tErr:         fmt.Sprintf(\"non-canonical import path: %q should be %q\", origPath, pathpkg.Clean(origPath)),\n@@ -473,11 +568,11 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \t}\n \n \t// Checked on every import because the rules depend on the code doing the importing.\n-\tif perr := disallowInternal(srcDir, p, stk); perr != p {\n+\tif perr := disallowInternal(srcDir, parent, parentPath, p, stk); perr != p {\n \t\treturn setErrorPos(perr, importPos)\n \t}\n \tif mode&ResolveImport != 0 {\n-\t\tif perr := disallowVendor(srcDir, origPath, p, stk); perr != p {\n+\t\tif perr := disallowVendor(srcDir, parent, parentPath, origPath, p, stk); perr != p {\n \t\t\treturn setErrorPos(perr, importPos)\n \t\t}\n \t}\n@@ -539,8 +634,14 @@ func isDir(path string) bool {\n // There are two different resolutions applied.\n // First, there is Go 1.5 vendoring (golang.org/s/go15vendor).\n // If vendor expansion doesn't trigger, then the path is also subject to\n-// Go 1.11 vgo legacy conversion (golang.org/issue/25069).\n+// Go 1.11 module legacy conversion (golang.org/issue/25069).\n func ResolveImportPath(parent *Package, path string) (found string) {\n+\tif cfg.ModulesEnabled {\n+\t\tif _, p, e := ModLookup(path); e == nil {\n+\t\t\treturn p\n+\t\t}\n+\t\treturn path\n+\t}\n \tfound = VendoredImportPath(parent, path)\n \tif found != path {\n \t\treturn found\n@@ -828,10 +929,11 @@ func reusePackage(p *Package, stk *ImportStack) *Package {\n \treturn p\n }\n \n-// disallowInternal checks that srcDir is allowed to import p.\n+// disallowInternal checks that srcDir (containing package importerPath, if non-empty)\n+// is allowed to import p.\n // If the import is allowed, disallowInternal returns the original package p.\n // If not, it returns a new package containing just an appropriate error.\n-func disallowInternal(srcDir string, p *Package, stk *ImportStack) *Package {\n+func disallowInternal(srcDir string, importer *Package, importerPath string, p *Package, stk *ImportStack) *Package {\n \t// golang.org/s/go14internal:\n \t// An import of a path containing the element \u201cinternal\u201d\n \t// is disallowed if the importing code is outside the tree\n@@ -874,23 +976,40 @@ func disallowInternal(srcDir string, p *Package, stk *ImportStack) *Package {\n \tif i > 0 {\n \t\ti-- // rewind over slash in \".../internal\"\n \t}\n-\tparent := p.Dir[:i+len(p.Dir)-len(p.ImportPath)]\n-\tif str.HasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n-\t\treturn p\n-\t}\n \n-\t// Look for symlinks before reporting error.\n-\tsrcDir = expandPath(srcDir)\n-\tparent = expandPath(parent)\n-\tif str.HasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n-\t\treturn p\n+\tif p.Module == nil {\n+\t\tparent := p.Dir[:i+len(p.Dir)-len(p.ImportPath)]\n+\n+\t\tif str.HasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n+\t\t\treturn p\n+\t\t}\n+\n+\t\t// Look for symlinks before reporting error.\n+\t\tsrcDir = expandPath(srcDir)\n+\t\tparent = expandPath(parent)\n+\t\tif str.HasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n+\t\t\treturn p\n+\t\t}\n+\t} else {\n+\t\t// p is in a module, so make it available based on the importer's import path instead\n+\t\t// of the file path (https://golang.org/issue/23970).\n+\t\tif importerPath == \".\" {\n+\t\t\t// The importer is a list of command-line files.\n+\t\t\t// Pretend that the import path is the import path of the\n+\t\t\t// directory containing them.\n+\t\t\timporterPath = ModDirImportPath(importer.Dir)\n+\t\t}\n+\t\tparentOfInternal := p.ImportPath[:i]\n+\t\tif str.HasPathPrefix(importerPath, parentOfInternal) {\n+\t\t\treturn p\n+\t\t}\n \t}\n \n \t// Internal is present, and srcDir is outside parent's tree. Not allowed.\n \tperr := *p\n \tperr.Error = &PackageError{\n \t\tImportStack: stk.Copy(),\n-\t\tErr:         \"use of internal package not allowed\",\n+\t\tErr:         \"use of internal package \" + p.ImportPath + \" not allowed\",\n \t}\n \tperr.Incomplete = true\n \treturn &perr\n@@ -915,10 +1034,11 @@ func findInternal(path string) (index int, ok bool) {\n \treturn 0, false\n }\n \n-// disallowVendor checks that srcDir is allowed to import p as path.\n+// disallowVendor checks that srcDir (containing package importerPath, if non-empty)\n+// is allowed to import p as path.\n // If the import is allowed, disallowVendor returns the original package p.\n // If not, it returns a new package containing just an appropriate error.\n-func disallowVendor(srcDir, path string, p *Package, stk *ImportStack) *Package {\n+func disallowVendor(srcDir string, importer *Package, importerPath, path string, p *Package, stk *ImportStack) *Package {\n \t// The stack includes p.ImportPath.\n \t// If that's the only thing on the stack, we started\n \t// with a name given on the command line, not an\n@@ -927,6 +1047,20 @@ func disallowVendor(srcDir, path string, p *Package, stk *ImportStack) *Package\n \t\treturn p\n \t}\n \n+\t// Modules must not import vendor packages in the standard library,\n+\t// but the usual vendor visibility check will not catch them\n+\t// because the module loader presents them with an ImportPath starting\n+\t// with \"golang_org/\" instead of \"vendor/\".\n+\tif p.Standard && !importer.Standard && strings.HasPrefix(p.ImportPath, \"golang_org\") {\n+\t\tperr := *p\n+\t\tperr.Error = &PackageError{\n+\t\t\tImportStack: stk.Copy(),\n+\t\t\tErr:         \"use of vendored package \" + path + \" not allowed\",\n+\t\t}\n+\t\tperr.Incomplete = true\n+\t\treturn &perr\n+\t}\n+\n \tif perr := disallowVendorVisibility(srcDir, p, stk); perr != p {\n \t\treturn perr\n \t}\n@@ -1057,26 +1191,6 @@ var foldPath = make(map[string]string)\n func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \tp.copyBuild(bp)\n \n-\t// Decide whether p was listed on the command line.\n-\t// Given that load is called while processing the command line,\n-\t// you might think we could simply pass a flag down into load\n-\t// saying whether we are loading something named on the command\n-\t// line or something to satisfy an import. But the first load of a\n-\t// package named on the command line may be as a dependency\n-\t// of an earlier package named on the command line, not when we\n-\t// get to that package during command line processing.\n-\t// For example \"go test fmt reflect\" will load reflect as a dependency\n-\t// of fmt before it attempts to load as a command-line argument.\n-\t// Because loads are cached, the later load will be a no-op,\n-\t// so it is important that the first load can fill in CmdlinePkg correctly.\n-\t// Hence the call to an explicit matching check here.\n-\tp.Internal.CmdlinePkg = isCmdlinePkg(p)\n-\n-\tp.Internal.Asmflags = BuildAsmflags.For(p)\n-\tp.Internal.Gcflags = BuildGcflags.For(p)\n-\tp.Internal.Ldflags = BuildLdflags.For(p)\n-\tp.Internal.Gccgoflags = BuildGccgoflags.For(p)\n-\n \t// The localPrefix is the path we interpret ./ imports relative to.\n \t// Synthesized main packages sometimes override this.\n \tif p.Internal.Local {\n@@ -1113,11 +1227,45 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\t\treturn\n \t\t}\n \t\t_, elem := filepath.Split(p.Dir)\n+\t\tif cfg.ModulesEnabled {\n+\t\t\t// NOTE(rsc): Using p.ImportPath instead of p.Dir\n+\t\t\t// makes sure we install a package in the root of a\n+\t\t\t// cached module directory as that package name\n+\t\t\t// not name@v1.2.3.\n+\t\t\t// Using p.ImportPath instead of p.Dir\n+\t\t\t// is probably correct all the time,\n+\t\t\t// even for non-module-enabled code,\n+\t\t\t// but I'm not brave enough to change the\n+\t\t\t// non-module behavior this late in the\n+\t\t\t// release cycle. Maybe for Go 1.12.\n+\t\t\t// See golang.org/issue/26869.\n+\t\t\t_, elem = pathpkg.Split(p.ImportPath)\n+\n+\t\t\t// If this is example.com/mycmd/v2, it's more useful to install it as mycmd than as v2.\n+\t\t\t// See golang.org/issue/24667.\n+\t\t\tisVersion := func(v string) bool {\n+\t\t\t\tif len(v) < 2 || v[0] != 'v' || v[1] < '1' || '9' < v[1] {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\tfor i := 2; i < len(v); i++ {\n+\t\t\t\t\tif c := v[i]; c < '0' || '9' < c {\n+\t\t\t\t\t\treturn false\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tif isVersion(elem) {\n+\t\t\t\t_, elem = pathpkg.Split(pathpkg.Dir(p.ImportPath))\n+\t\t\t}\n+\t\t}\n \t\tfull := cfg.BuildContext.GOOS + \"_\" + cfg.BuildContext.GOARCH + \"/\" + elem\n \t\tif cfg.BuildContext.GOOS != base.ToolGOOS || cfg.BuildContext.GOARCH != base.ToolGOARCH {\n \t\t\t// Install cross-compiled binaries to subdirectories of bin.\n \t\t\telem = full\n \t\t}\n+\t\tif p.Internal.Build.BinDir == \"\" && cfg.ModulesEnabled {\n+\t\t\tp.Internal.Build.BinDir = ModBinDir()\n+\t\t}\n \t\tif p.Internal.Build.BinDir != \"\" {\n \t\t\t// Install to GOBIN or bin of GOPATH entry.\n \t\t\tp.Target = filepath.Join(p.Internal.Build.BinDir, elem)\n@@ -1165,31 +1313,37 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t// Build augmented import list to add implicit dependencies.\n \t// Be careful not to add imports twice, just to avoid confusion.\n \timportPaths := p.Imports\n-\taddImport := func(path string) {\n+\taddImport := func(path string, forCompiler bool) {\n \t\tfor _, p := range importPaths {\n \t\t\tif path == p {\n \t\t\t\treturn\n \t\t\t}\n \t\t}\n \t\timportPaths = append(importPaths, path)\n+\t\tif forCompiler {\n+\t\t\tp.Internal.CompiledImports = append(p.Internal.CompiledImports, path)\n+\t\t}\n \t}\n \n-\t// Cgo translation adds imports of \"runtime/cgo\" and \"syscall\",\n+\t// Cgo translation adds imports of \"unsafe\", \"runtime/cgo\" and \"syscall\",\n \t// except for certain packages, to avoid circular dependencies.\n+\tif p.UsesCgo() {\n+\t\taddImport(\"unsafe\", true)\n+\t}\n \tif p.UsesCgo() && (!p.Standard || !cgoExclude[p.ImportPath]) && cfg.BuildContext.Compiler != \"gccgo\" {\n-\t\taddImport(\"runtime/cgo\")\n+\t\taddImport(\"runtime/cgo\", true)\n \t}\n \tif p.UsesCgo() && (!p.Standard || !cgoSyscallExclude[p.ImportPath]) {\n-\t\taddImport(\"syscall\")\n+\t\taddImport(\"syscall\", true)\n \t}\n \n \t// SWIG adds imports of some standard packages.\n \tif p.UsesSwig() {\n \t\tif cfg.BuildContext.Compiler != \"gccgo\" {\n-\t\t\taddImport(\"runtime/cgo\")\n+\t\t\taddImport(\"runtime/cgo\", true)\n \t\t}\n-\t\taddImport(\"syscall\")\n-\t\taddImport(\"sync\")\n+\t\taddImport(\"syscall\", true)\n+\t\taddImport(\"sync\", true)\n \n \t\t// TODO: The .swig and .swigcxx files can use\n \t\t// %go_import directives to import other packages.\n@@ -1198,7 +1352,7 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t// The linker loads implicit dependencies.\n \tif p.Name == \"main\" && !p.Internal.ForceLibrary {\n \t\tfor _, dep := range LinkerDeps(p) {\n-\t\t\taddImport(dep)\n+\t\t\taddImport(dep, false)\n \t\t}\n \t}\n \n@@ -1368,6 +1522,13 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\tsetError(fmt.Sprintf(\"case-insensitive import collision: %q and %q\", p.ImportPath, other))\n \t\treturn\n \t}\n+\n+\tif cfg.ModulesEnabled {\n+\t\tp.Module = ModPackageModuleInfo(p.ImportPath)\n+\t\tif p.Name == \"main\" {\n+\t\t\tp.Internal.BuildInfo = ModPackageBuildInfo(p.ImportPath, p.Deps)\n+\t\t}\n+\t}\n }\n \n // SafeArg reports whether arg is a \"safe\" command-line argument,\n@@ -1466,7 +1627,13 @@ func (p *Package) mkAbs(list []string) []string {\n // InternalGoFiles returns the list of Go files being built for the package,\n // using absolute paths.\n func (p *Package) InternalGoFiles() []string {\n-\treturn p.mkAbs(str.StringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles))\n+\treturn p.mkAbs(str.StringList(p.GoFiles, p.CgoFiles, p.TestGoFiles))\n+}\n+\n+// InternalXGoFiles returns the list of Go files being built for the XTest package,\n+// using absolute paths.\n+func (p *Package) InternalXGoFiles() []string {\n+\treturn p.mkAbs(p.XTestGoFiles)\n }\n \n // InternalGoFiles returns the list of all Go files possibly relevant for the package,\n@@ -1492,7 +1659,7 @@ func (p *Package) UsesCgo() bool {\n \treturn len(p.CgoFiles) > 0\n }\n \n-// packageList returns the list of packages in the dag rooted at roots\n+// PackageList returns the list of packages in the dag rooted at roots\n // as visited in a depth-first post-order traversal.\n func PackageList(roots []*Package) []*Package {\n \tseen := map[*Package]bool{}\n@@ -1514,6 +1681,42 @@ func PackageList(roots []*Package) []*Package {\n \treturn all\n }\n \n+// TestPackageList returns the list of packages in the dag rooted at roots\n+// as visited in a depth-first post-order traversal, including the test\n+// imports of the roots. This ignores errors in test packages.\n+func GetTestPackageList(roots []*Package) []*Package {\n+\tseen := map[*Package]bool{}\n+\tall := []*Package{}\n+\tvar walk func(*Package)\n+\twalk = func(p *Package) {\n+\t\tif seen[p] {\n+\t\t\treturn\n+\t\t}\n+\t\tseen[p] = true\n+\t\tfor _, p1 := range p.Internal.Imports {\n+\t\t\twalk(p1)\n+\t\t}\n+\t\tall = append(all, p)\n+\t}\n+\twalkTest := func(root *Package, path string) {\n+\t\tvar stk ImportStack\n+\t\tp1 := LoadImport(path, root.Dir, root, &stk, root.Internal.Build.TestImportPos[path], ResolveImport)\n+\t\tif p1.Error == nil {\n+\t\t\twalk(p1)\n+\t\t}\n+\t}\n+\tfor _, root := range roots {\n+\t\twalk(root)\n+\t\tfor _, path := range root.TestImports {\n+\t\t\twalkTest(root, path)\n+\t\t}\n+\t\tfor _, path := range root.XTestImports {\n+\t\t\twalkTest(root, path)\n+\t\t}\n+\t}\n+\treturn all\n+}\n+\n var cmdCache = map[string]*Package{}\n \n func ClearCmdCache() {\n@@ -1522,11 +1725,31 @@ func ClearCmdCache() {\n \t}\n }\n \n+// LoadPackage loads the package named by arg.\n+func LoadPackage(arg string, stk *ImportStack) *Package {\n+\tp := loadPackage(arg, stk)\n+\tsetToolFlags(p)\n+\treturn p\n+}\n+\n+// LoadPackageNoFlags is like LoadPackage\n+// but does not guarantee that the build tool flags are set in the result.\n+// It is only for use by GOPATH-based \"go get\"\n+// and is only appropriate for preliminary loading of packages.\n+// A real load using LoadPackage or (more likely)\n+// Packages, PackageAndErrors, or PackagesForBuild\n+// must be done before passing the package to any build\n+// steps, so that the tool flags can be set properly.\n+// TODO(rsc): When GOPATH-based \"go get\" is removed, delete this function.\n+func LoadPackageNoFlags(arg string, stk *ImportStack) *Package {\n+\treturn loadPackage(arg, stk)\n+}\n+\n // loadPackage is like loadImport but is used for command-line arguments,\n // not for paths found in import statements. In addition to ordinary import paths,\n // loadPackage accepts pseudo-paths beginning with cmd/ to denote commands\n // in the Go command directory, as well as paths to those directories.\n-func LoadPackage(arg string, stk *ImportStack) *Package {\n+func loadPackage(arg string, stk *ImportStack) *Package {\n \tif build.IsLocalImport(arg) {\n \t\tdir := arg\n \t\tif !filepath.IsAbs(dir) {\n@@ -1573,8 +1796,12 @@ func LoadPackage(arg string, stk *ImportStack) *Package {\n \t// This lets you run go test ./ioutil in package io and be\n \t// referring to io/ioutil rather than a hypothetical import of\n \t// \"./ioutil\".\n-\tif build.IsLocalImport(arg) {\n-\t\tbp, _ := cfg.BuildContext.ImportDir(filepath.Join(base.Cwd, arg), build.FindOnly)\n+\tif build.IsLocalImport(arg) || filepath.IsAbs(arg) {\n+\t\tdir := arg\n+\t\tif !filepath.IsAbs(arg) {\n+\t\t\tdir = filepath.Join(base.Cwd, arg)\n+\t\t}\n+\t\tbp, _ := cfg.BuildContext.ImportDir(dir, build.FindOnly)\n \t\tif bp.ImportPath != \"\" && bp.ImportPath != \".\" {\n \t\t\targ = bp.ImportPath\n \t\t}\n@@ -1583,7 +1810,7 @@ func LoadPackage(arg string, stk *ImportStack) *Package {\n \treturn LoadImport(arg, base.Cwd, nil, stk, nil, 0)\n }\n \n-// packages returns the packages named by the\n+// Packages returns the packages named by the\n // command line arguments 'args'. If a named package\n // cannot be loaded at all (for example, if the directory does not exist),\n // then packages prints an error and does not include that\n@@ -1603,48 +1830,76 @@ func Packages(args []string) []*Package {\n \treturn pkgs\n }\n \n-// packagesAndErrors is like 'packages' but returns a\n+// PackagesAndErrors is like 'packages' but returns a\n // *Package for every argument, even the ones that\n // cannot be loaded at all.\n // The packages that fail to load will have p.Error != nil.\n-func PackagesAndErrors(args []string) []*Package {\n-\tif len(args) > 0 && strings.HasSuffix(args[0], \".go\") {\n-\t\treturn []*Package{GoFilesPackage(args)}\n+func PackagesAndErrors(patterns []string) []*Package {\n+\tif len(patterns) > 0 && strings.HasSuffix(patterns[0], \".go\") {\n+\t\treturn []*Package{GoFilesPackage(patterns)}\n \t}\n \n-\targs = ImportPaths(args)\n+\tmatches := ImportPaths(patterns)\n \tvar (\n \t\tpkgs    []*Package\n \t\tstk     ImportStack\n-\t\tseenArg = make(map[string]bool)\n \t\tseenPkg = make(map[*Package]bool)\n \t)\n \n-\tfor _, arg := range args {\n-\t\tif seenArg[arg] {\n-\t\t\tcontinue\n-\t\t}\n-\t\tseenArg[arg] = true\n-\t\tpkg := LoadPackage(arg, &stk)\n-\t\tif seenPkg[pkg] {\n-\t\t\tcontinue\n+\tfor _, m := range matches {\n+\t\tfor _, pkg := range m.Pkgs {\n+\t\t\tp := loadPackage(pkg, &stk)\n+\t\t\tp.Match = append(p.Match, m.Pattern)\n+\t\t\tp.Internal.CmdlinePkg = true\n+\t\t\tif m.Literal {\n+\t\t\t\t// Note: do not set = m.Literal unconditionally\n+\t\t\t\t// because maybe we'll see p matching both\n+\t\t\t\t// a literal and also a non-literal pattern.\n+\t\t\t\tp.Internal.CmdlinePkgLiteral = true\n+\t\t\t}\n+\t\t\tif seenPkg[p] {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tseenPkg[p] = true\n+\t\t\tpkgs = append(pkgs, p)\n \t\t}\n-\t\tseenPkg[pkg] = true\n-\t\tpkgs = append(pkgs, pkg)\n \t}\n \n+\t// Now that CmdlinePkg is set correctly,\n+\t// compute the effective flags for all loaded packages\n+\t// (not just the ones matching the patterns but also\n+\t// their dependencies).\n+\tsetToolFlags(pkgs...)\n+\n \treturn pkgs\n }\n \n-// packagesForBuild is like 'packages' but fails if any of\n-// the packages or their dependencies have errors\n+func setToolFlags(pkgs ...*Package) {\n+\tfor _, p := range PackageList(pkgs) {\n+\t\tp.Internal.Asmflags = BuildAsmflags.For(p)\n+\t\tp.Internal.Gcflags = BuildGcflags.For(p)\n+\t\tp.Internal.Ldflags = BuildLdflags.For(p)\n+\t\tp.Internal.Gccgoflags = BuildGccgoflags.For(p)\n+\t}\n+}\n+\n+func ImportPaths(args []string) []*search.Match {\n+\tif ModInit(); cfg.ModulesEnabled {\n+\t\treturn ModImportPaths(args)\n+\t}\n+\treturn search.ImportPaths(args)\n+}\n+\n+// PackagesForBuild is like Packages but exits\n+// if any of the packages or their dependencies have errors\n // (cannot be built).\n func PackagesForBuild(args []string) []*Package {\n \tpkgs := PackagesAndErrors(args)\n \tprinted := map[*PackageError]bool{}\n \tfor _, pkg := range pkgs {\n \t\tif pkg.Error != nil {\n \t\t\tbase.Errorf(\"can't load package: %s\", pkg.Error)\n+\t\t\tprinted[pkg.Error] = true\n \t\t}\n \t\tfor _, err := range pkg.DepsErrors {\n \t\t\t// Since these are errors in dependencies,\n@@ -1682,7 +1937,8 @@ func PackagesForBuild(args []string) []*Package {\n // (typically named on the command line). The target is named p.a for\n // package p or named after the first Go file for package main.\n func GoFilesPackage(gofiles []string) *Package {\n-\t// TODO: Remove this restriction.\n+\tModInit()\n+\n \tfor _, f := range gofiles {\n \t\tif !strings.HasSuffix(f, \".go\") {\n \t\t\tbase.Fatalf(\"named files must be .go files\")\n@@ -1720,6 +1976,10 @@ func GoFilesPackage(gofiles []string) *Package {\n \t}\n \tctxt.ReadDir = func(string) ([]os.FileInfo, error) { return dirent, nil }\n \n+\tif cfg.ModulesEnabled {\n+\t\tModImportFromFiles(gofiles)\n+\t}\n+\n \tvar err error\n \tif dir == \"\" {\n \t\tdir = base.Cwd\n@@ -1730,6 +1990,11 @@ func GoFilesPackage(gofiles []string) *Package {\n \t}\n \n \tbp, err := ctxt.ImportDir(dir, 0)\n+\tif ModDirImportPath != nil {\n+\t\t// Use the effective import path of the directory\n+\t\t// for deciding visibility during pkg.load.\n+\t\tbp.ImportPath = ModDirImportPath(dir)\n+\t}\n \tpkg := new(Package)\n \tpkg.Internal.Local = true\n \tpkg.Internal.CmdlineFiles = true\n@@ -1739,6 +2004,7 @@ func GoFilesPackage(gofiles []string) *Package {\n \tpkg.Internal.LocalPrefix = dirToImportPath(dir)\n \tpkg.ImportPath = \"command-line-arguments\"\n \tpkg.Target = \"\"\n+\tpkg.Match = gofiles\n \n \tif pkg.Name == \"main\" {\n \t\t_, elem := filepath.Split(gofiles[0])\n@@ -1748,152 +2014,12 @@ func GoFilesPackage(gofiles []string) *Package {\n \t\t}\n \t\tif cfg.GOBIN != \"\" {\n \t\t\tpkg.Target = filepath.Join(cfg.GOBIN, exe)\n+\t\t} else if cfg.ModulesEnabled {\n+\t\t\tpkg.Target = filepath.Join(ModBinDir(), exe)\n \t\t}\n \t}\n \n-\treturn pkg\n-}\n-\n-// GetTestPackagesFor returns package structs ptest, the package p plus\n-// its test files, and pxtest, the external tests of package p.\n-// pxtest may be nil. If there are no test files, forceTest decides\n-// whether this returns a new package struct or just returns p.\n-func GetTestPackagesFor(p *Package, forceTest bool) (ptest, pxtest *Package, err error) {\n-\tvar imports, ximports []*Package\n-\tvar stk ImportStack\n-\tstk.Push(p.ImportPath + \" (test)\")\n-\trawTestImports := str.StringList(p.TestImports)\n-\tfor i, path := range p.TestImports {\n-\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], ResolveImport)\n-\t\tif p1.Error != nil {\n-\t\t\treturn nil, nil, p1.Error\n-\t\t}\n-\t\tif len(p1.DepsErrors) > 0 {\n-\t\t\terr := p1.DepsErrors[0]\n-\t\t\terr.Pos = \"\" // show full import stack\n-\t\t\treturn nil, nil, err\n-\t\t}\n-\t\tif str.Contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {\n-\t\t\t// Same error that loadPackage returns (via reusePackage) in pkg.go.\n-\t\t\t// Can't change that code, because that code is only for loading the\n-\t\t\t// non-test copy of a package.\n-\t\t\terr := &PackageError{\n-\t\t\t\tImportStack:   testImportStack(stk[0], p1, p.ImportPath),\n-\t\t\t\tErr:           \"import cycle not allowed in test\",\n-\t\t\t\tIsImportCycle: true,\n-\t\t\t}\n-\t\t\treturn nil, nil, err\n-\t\t}\n-\t\tp.TestImports[i] = p1.ImportPath\n-\t\timports = append(imports, p1)\n-\t}\n-\tstk.Pop()\n-\tstk.Push(p.ImportPath + \"_test\")\n-\tpxtestNeedsPtest := false\n-\trawXTestImports := str.StringList(p.XTestImports)\n-\tfor i, path := range p.XTestImports {\n-\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], ResolveImport)\n-\t\tif p1.Error != nil {\n-\t\t\treturn nil, nil, p1.Error\n-\t\t}\n-\t\tif len(p1.DepsErrors) > 0 {\n-\t\t\terr := p1.DepsErrors[0]\n-\t\t\terr.Pos = \"\" // show full import stack\n-\t\t\treturn nil, nil, err\n-\t\t}\n-\t\tif p1.ImportPath == p.ImportPath {\n-\t\t\tpxtestNeedsPtest = true\n-\t\t} else {\n-\t\t\tximports = append(ximports, p1)\n-\t\t}\n-\t\tp.XTestImports[i] = p1.ImportPath\n-\t}\n-\tstk.Pop()\n-\n-\t// Test package.\n-\tif len(p.TestGoFiles) > 0 || forceTest {\n-\t\tptest = new(Package)\n-\t\t*ptest = *p\n-\t\tptest.GoFiles = nil\n-\t\tptest.GoFiles = append(ptest.GoFiles, p.GoFiles...)\n-\t\tptest.GoFiles = append(ptest.GoFiles, p.TestGoFiles...)\n-\t\tptest.Target = \"\"\n-\t\t// Note: The preparation of the vet config requires that common\n-\t\t// indexes in ptest.Imports, ptest.Internal.Imports, and ptest.Internal.RawImports\n-\t\t// all line up (but RawImports can be shorter than the others).\n-\t\t// That is, for 0 \u2264 i < len(RawImports),\n-\t\t// RawImports[i] is the import string in the program text,\n-\t\t// Imports[i] is the expanded import string (vendoring applied or relative path expanded away),\n-\t\t// and Internal.Imports[i] is the corresponding *Package.\n-\t\t// Any implicitly added imports appear in Imports and Internal.Imports\n-\t\t// but not RawImports (because they were not in the source code).\n-\t\t// We insert TestImports, imports, and rawTestImports at the start of\n-\t\t// these lists to preserve the alignment.\n-\t\tptest.Imports = str.StringList(p.TestImports, p.Imports)\n-\t\tptest.Internal.Imports = append(imports, p.Internal.Imports...)\n-\t\tptest.Internal.RawImports = str.StringList(rawTestImports, p.Internal.RawImports)\n-\t\tptest.Internal.ForceLibrary = true\n-\t\tptest.Internal.Build = new(build.Package)\n-\t\t*ptest.Internal.Build = *p.Internal.Build\n-\t\tm := map[string][]token.Position{}\n-\t\tfor k, v := range p.Internal.Build.ImportPos {\n-\t\t\tm[k] = append(m[k], v...)\n-\t\t}\n-\t\tfor k, v := range p.Internal.Build.TestImportPos {\n-\t\t\tm[k] = append(m[k], v...)\n-\t\t}\n-\t\tptest.Internal.Build.ImportPos = m\n-\t} else {\n-\t\tptest = p\n-\t}\n-\n-\t// External test package.\n-\tif len(p.XTestGoFiles) > 0 {\n-\t\tpxtest = &Package{\n-\t\t\tPackagePublic: PackagePublic{\n-\t\t\t\tName:       p.Name + \"_test\",\n-\t\t\t\tImportPath: p.ImportPath + \"_test\",\n-\t\t\t\tRoot:       p.Root,\n-\t\t\t\tDir:        p.Dir,\n-\t\t\t\tGoFiles:    p.XTestGoFiles,\n-\t\t\t\tImports:    p.XTestImports,\n-\t\t\t},\n-\t\t\tInternal: PackageInternal{\n-\t\t\t\tLocalPrefix: p.Internal.LocalPrefix,\n-\t\t\t\tBuild: &build.Package{\n-\t\t\t\t\tImportPos: p.Internal.Build.XTestImportPos,\n-\t\t\t\t},\n-\t\t\t\tImports:    ximports,\n-\t\t\t\tRawImports: rawXTestImports,\n-\n-\t\t\t\tAsmflags:   p.Internal.Asmflags,\n-\t\t\t\tGcflags:    p.Internal.Gcflags,\n-\t\t\t\tLdflags:    p.Internal.Ldflags,\n-\t\t\t\tGccgoflags: p.Internal.Gccgoflags,\n-\t\t\t},\n-\t\t}\n-\t\tif pxtestNeedsPtest {\n-\t\t\tpxtest.Internal.Imports = append(pxtest.Internal.Imports, ptest)\n-\t\t}\n-\t}\n-\n-\treturn ptest, pxtest, nil\n-}\n+\tsetToolFlags(pkg)\n \n-func testImportStack(top string, p *Package, target string) []string {\n-\tstk := []string{top, p.ImportPath}\n-Search:\n-\tfor p.ImportPath != target {\n-\t\tfor _, p1 := range p.Internal.Imports {\n-\t\t\tif p1.ImportPath == target || str.Contains(p1.Deps, target) {\n-\t\t\t\tstk = append(stk, p1.ImportPath)\n-\t\t\t\tp = p1\n-\t\t\t\tcontinue Search\n-\t\t\t}\n-\t\t}\n-\t\t// Can't happen, but in case it does...\n-\t\tstk = append(stk, \"<lost path to cycle>\")\n-\t\tbreak\n-\t}\n-\treturn stk\n+\treturn pkg\n }"}, {"sha": "cf09c7b0a89779ef2069162564b955e1077c4f7c", "filename": "libgo/go/cmd/go/internal/load/search.go", "status": "modified", "additions": 5, "deletions": 334, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fsearch.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -5,271 +5,16 @@\n package load\n \n import (\n-\t\"cmd/go/internal/cfg\"\n-\t\"fmt\"\n-\t\"go/build\"\n-\t\"log\"\n-\t\"os\"\n-\t\"path\"\n \t\"path/filepath\"\n-\t\"regexp\"\n \t\"strings\"\n-)\n-\n-// allPackages returns all the packages that can be found\n-// under the $GOPATH directories and $GOROOT matching pattern.\n-// The pattern is either \"all\" (all packages), \"std\" (standard packages),\n-// \"cmd\" (standard commands), or a path including \"...\".\n-func allPackages(pattern string) []string {\n-\tpkgs := MatchPackages(pattern)\n-\tif len(pkgs) == 0 {\n-\t\tfmt.Fprintf(os.Stderr, \"warning: %q matched no packages\\n\", pattern)\n-\t}\n-\treturn pkgs\n-}\n-\n-// allPackagesInFS is like allPackages but is passed a pattern\n-// beginning ./ or ../, meaning it should scan the tree rooted\n-// at the given directory. There are ... in the pattern too.\n-func allPackagesInFS(pattern string) []string {\n-\tpkgs := MatchPackagesInFS(pattern)\n-\tif len(pkgs) == 0 {\n-\t\tfmt.Fprintf(os.Stderr, \"warning: %q matched no packages\\n\", pattern)\n-\t}\n-\treturn pkgs\n-}\n-\n-// MatchPackages returns a list of package paths matching pattern\n-// (see go help packages for pattern syntax).\n-func MatchPackages(pattern string) []string {\n-\tmatch := func(string) bool { return true }\n-\ttreeCanMatch := func(string) bool { return true }\n-\tif !IsMetaPackage(pattern) {\n-\t\tmatch = matchPattern(pattern)\n-\t\ttreeCanMatch = treeCanMatchPattern(pattern)\n-\t}\n-\n-\thave := map[string]bool{\n-\t\t\"builtin\": true, // ignore pseudo-package that exists only for documentation\n-\t}\n-\tif !cfg.BuildContext.CgoEnabled {\n-\t\thave[\"runtime/cgo\"] = true // ignore during walk\n-\t}\n-\tvar pkgs []string\n-\n-\tfor _, src := range cfg.BuildContext.SrcDirs() {\n-\t\tif (pattern == \"std\" || pattern == \"cmd\") && src != cfg.GOROOTsrc {\n-\t\t\tcontinue\n-\t\t}\n-\t\tsrc = filepath.Clean(src) + string(filepath.Separator)\n-\t\troot := src\n-\t\tif pattern == \"cmd\" {\n-\t\t\troot += \"cmd\" + string(filepath.Separator)\n-\t\t}\n-\t\tfilepath.Walk(root, func(path string, fi os.FileInfo, err error) error {\n-\t\t\tif err != nil || path == src {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\n-\t\t\twant := true\n-\t\t\t// Avoid .foo, _foo, and testdata directory trees.\n-\t\t\t_, elem := filepath.Split(path)\n-\t\t\tif strings.HasPrefix(elem, \".\") || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n-\t\t\t\twant = false\n-\t\t\t}\n-\n-\t\t\tname := filepath.ToSlash(path[len(src):])\n-\t\t\tif pattern == \"std\" && (!isStandardImportPath(name) || name == \"cmd\") {\n-\t\t\t\t// The name \"std\" is only the standard library.\n-\t\t\t\t// If the name is cmd, it's the root of the command tree.\n-\t\t\t\twant = false\n-\t\t\t}\n-\t\t\tif !treeCanMatch(name) {\n-\t\t\t\twant = false\n-\t\t\t}\n-\n-\t\t\tif !fi.IsDir() {\n-\t\t\t\tif fi.Mode()&os.ModeSymlink != 0 && want {\n-\t\t\t\t\tif target, err := os.Stat(path); err == nil && target.IsDir() {\n-\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: ignoring symlink %s\\n\", path)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t\tif !want {\n-\t\t\t\treturn filepath.SkipDir\n-\t\t\t}\n-\n-\t\t\tif have[name] {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t\thave[name] = true\n-\t\t\tif !match(name) {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t\tpkg, err := cfg.BuildContext.ImportDir(path, 0)\n-\t\t\tif err != nil {\n-\t\t\t\tif _, noGo := err.(*build.NoGoError); noGo {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// If we are expanding \"cmd\", skip main\n-\t\t\t// packages under cmd/vendor. At least as of\n-\t\t\t// March, 2017, there is one there for the\n-\t\t\t// vendored pprof tool.\n-\t\t\tif pattern == \"cmd\" && strings.HasPrefix(pkg.ImportPath, \"cmd/vendor\") && pkg.Name == \"main\" {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\n-\t\t\tpkgs = append(pkgs, name)\n-\t\t\treturn nil\n-\t\t})\n-\t}\n-\treturn pkgs\n-}\n-\n-// MatchPackagesInFS returns a list of package paths matching pattern,\n-// which must begin with ./ or ../\n-// (see go help packages for pattern syntax).\n-func MatchPackagesInFS(pattern string) []string {\n-\t// Find directory to begin the scan.\n-\t// Could be smarter but this one optimization\n-\t// is enough for now, since ... is usually at the\n-\t// end of a path.\n-\ti := strings.Index(pattern, \"...\")\n-\tdir, _ := path.Split(pattern[:i])\n-\n-\t// pattern begins with ./ or ../.\n-\t// path.Clean will discard the ./ but not the ../.\n-\t// We need to preserve the ./ for pattern matching\n-\t// and in the returned import paths.\n-\tprefix := \"\"\n-\tif strings.HasPrefix(pattern, \"./\") {\n-\t\tprefix = \"./\"\n-\t}\n-\tmatch := matchPattern(pattern)\n-\n-\tvar pkgs []string\n-\tfilepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {\n-\t\tif err != nil || !fi.IsDir() {\n-\t\t\treturn nil\n-\t\t}\n-\t\tif path == dir {\n-\t\t\t// filepath.Walk starts at dir and recurses. For the recursive case,\n-\t\t\t// the path is the result of filepath.Join, which calls filepath.Clean.\n-\t\t\t// The initial case is not Cleaned, though, so we do this explicitly.\n-\t\t\t//\n-\t\t\t// This converts a path like \"./io/\" to \"io\". Without this step, running\n-\t\t\t// \"cd $GOROOT/src; go list ./io/...\" would incorrectly skip the io\n-\t\t\t// package, because prepending the prefix \"./\" to the unclean path would\n-\t\t\t// result in \"././io\", and match(\"././io\") returns false.\n-\t\t\tpath = filepath.Clean(path)\n-\t\t}\n-\n-\t\t// Avoid .foo, _foo, and testdata directory trees, but do not avoid \".\" or \"..\".\n-\t\t_, elem := filepath.Split(path)\n-\t\tdot := strings.HasPrefix(elem, \".\") && elem != \".\" && elem != \"..\"\n-\t\tif dot || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n-\t\t\treturn filepath.SkipDir\n-\t\t}\n-\n-\t\tname := prefix + filepath.ToSlash(path)\n-\t\tif !match(name) {\n-\t\t\treturn nil\n-\t\t}\n \n-\t\t// We keep the directory if we can import it, or if we can't import it\n-\t\t// due to invalid Go source files. This means that directories containing\n-\t\t// parse errors will be built (and fail) instead of being silently skipped\n-\t\t// as not matching the pattern. Go 1.5 and earlier skipped, but that\n-\t\t// behavior means people miss serious mistakes.\n-\t\t// See golang.org/issue/11407.\n-\t\tif p, err := cfg.BuildContext.ImportDir(path, 0); err != nil && (p == nil || len(p.InvalidGoFiles) == 0) {\n-\t\t\tif _, noGo := err.(*build.NoGoError); !noGo {\n-\t\t\t\tlog.Print(err)\n-\t\t\t}\n-\t\t\treturn nil\n-\t\t}\n-\t\tpkgs = append(pkgs, name)\n-\t\treturn nil\n-\t})\n-\treturn pkgs\n-}\n-\n-// treeCanMatchPattern(pattern)(name) reports whether\n-// name or children of name can possibly match pattern.\n-// Pattern is the same limited glob accepted by matchPattern.\n-func treeCanMatchPattern(pattern string) func(name string) bool {\n-\twildCard := false\n-\tif i := strings.Index(pattern, \"...\"); i >= 0 {\n-\t\twildCard = true\n-\t\tpattern = pattern[:i]\n-\t}\n-\treturn func(name string) bool {\n-\t\treturn len(name) <= len(pattern) && hasPathPrefix(pattern, name) ||\n-\t\t\twildCard && strings.HasPrefix(name, pattern)\n-\t}\n-}\n-\n-// matchPattern(pattern)(name) reports whether\n-// name matches pattern. Pattern is a limited glob\n-// pattern in which '...' means 'any string' and there\n-// is no other special syntax.\n-// Unfortunately, there are two special cases. Quoting \"go help packages\":\n-//\n-// First, /... at the end of the pattern can match an empty string,\n-// so that net/... matches both net and packages in its subdirectories, like net/http.\n-// Second, any slash-separted pattern element containing a wildcard never\n-// participates in a match of the \"vendor\" element in the path of a vendored\n-// package, so that ./... does not match packages in subdirectories of\n-// ./vendor or ./mycode/vendor, but ./vendor/... and ./mycode/vendor/... do.\n-// Note, however, that a directory named vendor that itself contains code\n-// is not a vendored package: cmd/vendor would be a command named vendor,\n-// and the pattern cmd/... matches it.\n-func matchPattern(pattern string) func(name string) bool {\n-\t// Convert pattern to regular expression.\n-\t// The strategy for the trailing /... is to nest it in an explicit ? expression.\n-\t// The strategy for the vendor exclusion is to change the unmatchable\n-\t// vendor strings to a disallowed code point (vendorChar) and to use\n-\t// \"(anything but that codepoint)*\" as the implementation of the ... wildcard.\n-\t// This is a bit complicated but the obvious alternative,\n-\t// namely a hand-written search like in most shell glob matchers,\n-\t// is too easy to make accidentally exponential.\n-\t// Using package regexp guarantees linear-time matching.\n-\n-\tconst vendorChar = \"\\x00\"\n-\n-\tif strings.Contains(pattern, vendorChar) {\n-\t\treturn func(name string) bool { return false }\n-\t}\n-\n-\tre := regexp.QuoteMeta(pattern)\n-\tre = replaceVendor(re, vendorChar)\n-\tswitch {\n-\tcase strings.HasSuffix(re, `/`+vendorChar+`/\\.\\.\\.`):\n-\t\tre = strings.TrimSuffix(re, `/`+vendorChar+`/\\.\\.\\.`) + `(/vendor|/` + vendorChar + `/\\.\\.\\.)`\n-\tcase re == vendorChar+`/\\.\\.\\.`:\n-\t\tre = `(/vendor|/` + vendorChar + `/\\.\\.\\.)`\n-\tcase strings.HasSuffix(re, `/\\.\\.\\.`):\n-\t\tre = strings.TrimSuffix(re, `/\\.\\.\\.`) + `(/\\.\\.\\.)?`\n-\t}\n-\tre = strings.Replace(re, `\\.\\.\\.`, `[^`+vendorChar+`]*`, -1)\n-\n-\treg := regexp.MustCompile(`^` + re + `$`)\n-\n-\treturn func(name string) bool {\n-\t\tif strings.Contains(name, vendorChar) {\n-\t\t\treturn false\n-\t\t}\n-\t\treturn reg.MatchString(replaceVendor(name, vendorChar))\n-\t}\n-}\n+\t\"cmd/go/internal/search\"\n+)\n \n // MatchPackage(pattern, cwd)(p) reports whether package p matches pattern in the working directory cwd.\n func MatchPackage(pattern, cwd string) func(*Package) bool {\n \tswitch {\n-\tcase strings.HasPrefix(pattern, \"./\") || strings.HasPrefix(pattern, \"../\") || pattern == \".\" || pattern == \"..\":\n+\tcase search.IsRelativePath(pattern):\n \t\t// Split pattern into leading pattern-free directory path\n \t\t// (including all . and .. elements) and the final pattern.\n \t\tvar dir string\n@@ -284,7 +29,7 @@ func MatchPackage(pattern, cwd string) func(*Package) bool {\n \t\tif pattern == \"\" {\n \t\t\treturn func(p *Package) bool { return p.Dir == dir }\n \t\t}\n-\t\tmatchPath := matchPattern(pattern)\n+\t\tmatchPath := search.MatchPattern(pattern)\n \t\treturn func(p *Package) bool {\n \t\t\t// Compute relative path to dir and see if it matches the pattern.\n \t\t\trel, err := filepath.Rel(dir, p.Dir)\n@@ -305,81 +50,7 @@ func MatchPackage(pattern, cwd string) func(*Package) bool {\n \tcase pattern == \"cmd\":\n \t\treturn func(p *Package) bool { return p.Standard && strings.HasPrefix(p.ImportPath, \"cmd/\") }\n \tdefault:\n-\t\tmatchPath := matchPattern(pattern)\n+\t\tmatchPath := search.MatchPattern(pattern)\n \t\treturn func(p *Package) bool { return matchPath(p.ImportPath) }\n \t}\n }\n-\n-// replaceVendor returns the result of replacing\n-// non-trailing vendor path elements in x with repl.\n-func replaceVendor(x, repl string) string {\n-\tif !strings.Contains(x, \"vendor\") {\n-\t\treturn x\n-\t}\n-\telem := strings.Split(x, \"/\")\n-\tfor i := 0; i < len(elem)-1; i++ {\n-\t\tif elem[i] == \"vendor\" {\n-\t\t\telem[i] = repl\n-\t\t}\n-\t}\n-\treturn strings.Join(elem, \"/\")\n-}\n-\n-// ImportPaths returns the import paths to use for the given command line.\n-func ImportPaths(args []string) []string {\n-\targs = ImportPathsNoDotExpansion(args)\n-\tvar out []string\n-\tfor _, a := range args {\n-\t\tif strings.Contains(a, \"...\") {\n-\t\t\tif build.IsLocalImport(a) {\n-\t\t\t\tout = append(out, allPackagesInFS(a)...)\n-\t\t\t} else {\n-\t\t\t\tout = append(out, allPackages(a)...)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tout = append(out, a)\n-\t}\n-\treturn out\n-}\n-\n-// ImportPathsNoDotExpansion returns the import paths to use for the given\n-// command line, but it does no ... expansion.\n-func ImportPathsNoDotExpansion(args []string) []string {\n-\tif cmdlineMatchers == nil {\n-\t\tSetCmdlinePatterns(args)\n-\t}\n-\tif len(args) == 0 {\n-\t\treturn []string{\".\"}\n-\t}\n-\tvar out []string\n-\tfor _, a := range args {\n-\t\t// Arguments are supposed to be import paths, but\n-\t\t// as a courtesy to Windows developers, rewrite \\ to /\n-\t\t// in command-line arguments. Handles .\\... and so on.\n-\t\tif filepath.Separator == '\\\\' {\n-\t\t\ta = strings.Replace(a, `\\`, `/`, -1)\n-\t\t}\n-\n-\t\t// Put argument in canonical form, but preserve leading ./.\n-\t\tif strings.HasPrefix(a, \"./\") {\n-\t\t\ta = \"./\" + path.Clean(a)\n-\t\t\tif a == \"./.\" {\n-\t\t\t\ta = \".\"\n-\t\t\t}\n-\t\t} else {\n-\t\t\ta = path.Clean(a)\n-\t\t}\n-\t\tif IsMetaPackage(a) {\n-\t\t\tout = append(out, allPackages(a)...)\n-\t\t\tcontinue\n-\t\t}\n-\t\tout = append(out, a)\n-\t}\n-\treturn out\n-}\n-\n-// IsMetaPackage checks if name is a reserved package name that expands to multiple packages.\n-func IsMetaPackage(name string) bool {\n-\treturn name == \"std\" || name == \"cmd\" || name == \"all\"\n-}"}, {"sha": "0eab21b176129f23bdcbd818e42797998b635e77", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "added", "additions": 654, "deletions": 0, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,654 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package load\n+\n+import (\n+\t\"bytes\"\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/str\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/build\"\n+\t\"go/doc\"\n+\t\"go/parser\"\n+\t\"go/token\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"text/template\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n+)\n+\n+var TestMainDeps = []string{\n+\t// Dependencies for testmain.\n+\t\"os\",\n+\t\"testing\",\n+\t\"testing/internal/testdeps\",\n+}\n+\n+type TestCover struct {\n+\tMode     string\n+\tLocal    bool\n+\tPkgs     []*Package\n+\tPaths    []string\n+\tVars     []coverInfo\n+\tDeclVars func(*Package, ...string) map[string]*CoverVar\n+}\n+\n+// TestPackagesFor returns three packages:\n+//\t- ptest, the package p compiled with added \"package p\" test files.\n+//\t- pxtest, the result of compiling any \"package p_test\" (external) test files.\n+//\t- pmain, the package main corresponding to the test binary (running tests in ptest and pxtest).\n+//\n+// If the package has no \"package p_test\" test files, pxtest will be nil.\n+// If the non-test compilation of package p can be reused\n+// (for example, if there are no \"package p\" test files and\n+// package p need not be instrumented for coverage or any other reason),\n+// then the returned ptest == p.\n+//\n+// The caller is expected to have checked that len(p.TestGoFiles)+len(p.XTestGoFiles) > 0,\n+// or else there's no point in any of this.\n+func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Package, err error) {\n+\tvar imports, ximports []*Package\n+\tvar stk ImportStack\n+\tstk.Push(p.ImportPath + \" (test)\")\n+\trawTestImports := str.StringList(p.TestImports)\n+\tfor i, path := range p.TestImports {\n+\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], ResolveImport)\n+\t\tif p1.Error != nil {\n+\t\t\treturn nil, nil, nil, p1.Error\n+\t\t}\n+\t\tif len(p1.DepsErrors) > 0 {\n+\t\t\terr := p1.DepsErrors[0]\n+\t\t\terr.Pos = \"\" // show full import stack\n+\t\t\treturn nil, nil, nil, err\n+\t\t}\n+\t\tif str.Contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {\n+\t\t\t// Same error that loadPackage returns (via reusePackage) in pkg.go.\n+\t\t\t// Can't change that code, because that code is only for loading the\n+\t\t\t// non-test copy of a package.\n+\t\t\terr := &PackageError{\n+\t\t\t\tImportStack:   testImportStack(stk[0], p1, p.ImportPath),\n+\t\t\t\tErr:           \"import cycle not allowed in test\",\n+\t\t\t\tIsImportCycle: true,\n+\t\t\t}\n+\t\t\treturn nil, nil, nil, err\n+\t\t}\n+\t\tp.TestImports[i] = p1.ImportPath\n+\t\timports = append(imports, p1)\n+\t}\n+\tstk.Pop()\n+\tstk.Push(p.ImportPath + \"_test\")\n+\tpxtestNeedsPtest := false\n+\trawXTestImports := str.StringList(p.XTestImports)\n+\tfor i, path := range p.XTestImports {\n+\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], ResolveImport)\n+\t\tif p1.Error != nil {\n+\t\t\treturn nil, nil, nil, p1.Error\n+\t\t}\n+\t\tif len(p1.DepsErrors) > 0 {\n+\t\t\terr := p1.DepsErrors[0]\n+\t\t\terr.Pos = \"\" // show full import stack\n+\t\t\treturn nil, nil, nil, err\n+\t\t}\n+\t\tif p1.ImportPath == p.ImportPath {\n+\t\t\tpxtestNeedsPtest = true\n+\t\t} else {\n+\t\t\tximports = append(ximports, p1)\n+\t\t}\n+\t\tp.XTestImports[i] = p1.ImportPath\n+\t}\n+\tstk.Pop()\n+\n+\t// Test package.\n+\tif len(p.TestGoFiles) > 0 || p.Name == \"main\" || cover != nil && cover.Local {\n+\t\tptest = new(Package)\n+\t\t*ptest = *p\n+\t\tptest.ForTest = p.ImportPath\n+\t\tptest.GoFiles = nil\n+\t\tptest.GoFiles = append(ptest.GoFiles, p.GoFiles...)\n+\t\tptest.GoFiles = append(ptest.GoFiles, p.TestGoFiles...)\n+\t\tptest.Target = \"\"\n+\t\t// Note: The preparation of the vet config requires that common\n+\t\t// indexes in ptest.Imports and ptest.Internal.RawImports\n+\t\t// all line up (but RawImports can be shorter than the others).\n+\t\t// That is, for 0 \u2264 i < len(RawImports),\n+\t\t// RawImports[i] is the import string in the program text, and\n+\t\t// Imports[i] is the expanded import string (vendoring applied or relative path expanded away).\n+\t\t// Any implicitly added imports appear in Imports and Internal.Imports\n+\t\t// but not RawImports (because they were not in the source code).\n+\t\t// We insert TestImports, imports, and rawTestImports at the start of\n+\t\t// these lists to preserve the alignment.\n+\t\t// Note that p.Internal.Imports may not be aligned with p.Imports/p.Internal.RawImports,\n+\t\t// but we insert at the beginning there too just for consistency.\n+\t\tptest.Imports = str.StringList(p.TestImports, p.Imports)\n+\t\tptest.Internal.Imports = append(imports, p.Internal.Imports...)\n+\t\tptest.Internal.RawImports = str.StringList(rawTestImports, p.Internal.RawImports)\n+\t\tptest.Internal.ForceLibrary = true\n+\t\tptest.Internal.Build = new(build.Package)\n+\t\t*ptest.Internal.Build = *p.Internal.Build\n+\t\tm := map[string][]token.Position{}\n+\t\tfor k, v := range p.Internal.Build.ImportPos {\n+\t\t\tm[k] = append(m[k], v...)\n+\t\t}\n+\t\tfor k, v := range p.Internal.Build.TestImportPos {\n+\t\t\tm[k] = append(m[k], v...)\n+\t\t}\n+\t\tptest.Internal.Build.ImportPos = m\n+\t} else {\n+\t\tptest = p\n+\t}\n+\n+\t// External test package.\n+\tif len(p.XTestGoFiles) > 0 {\n+\t\tpxtest = &Package{\n+\t\t\tPackagePublic: PackagePublic{\n+\t\t\t\tName:       p.Name + \"_test\",\n+\t\t\t\tImportPath: p.ImportPath + \"_test\",\n+\t\t\t\tRoot:       p.Root,\n+\t\t\t\tDir:        p.Dir,\n+\t\t\t\tGoFiles:    p.XTestGoFiles,\n+\t\t\t\tImports:    p.XTestImports,\n+\t\t\t\tForTest:    p.ImportPath,\n+\t\t\t},\n+\t\t\tInternal: PackageInternal{\n+\t\t\t\tLocalPrefix: p.Internal.LocalPrefix,\n+\t\t\t\tBuild: &build.Package{\n+\t\t\t\t\tImportPos: p.Internal.Build.XTestImportPos,\n+\t\t\t\t},\n+\t\t\t\tImports:    ximports,\n+\t\t\t\tRawImports: rawXTestImports,\n+\n+\t\t\t\tAsmflags:   p.Internal.Asmflags,\n+\t\t\t\tGcflags:    p.Internal.Gcflags,\n+\t\t\t\tLdflags:    p.Internal.Ldflags,\n+\t\t\t\tGccgoflags: p.Internal.Gccgoflags,\n+\t\t\t},\n+\t\t}\n+\t\tif pxtestNeedsPtest {\n+\t\t\tpxtest.Internal.Imports = append(pxtest.Internal.Imports, ptest)\n+\t\t}\n+\t}\n+\n+\t// Build main package.\n+\tpmain = &Package{\n+\t\tPackagePublic: PackagePublic{\n+\t\t\tName:       \"main\",\n+\t\t\tDir:        p.Dir,\n+\t\t\tGoFiles:    []string{\"_testmain.go\"},\n+\t\t\tImportPath: p.ImportPath + \".test\",\n+\t\t\tRoot:       p.Root,\n+\t\t\tImports:    str.StringList(TestMainDeps),\n+\t\t},\n+\t\tInternal: PackageInternal{\n+\t\t\tBuild:      &build.Package{Name: \"main\"},\n+\t\t\tAsmflags:   p.Internal.Asmflags,\n+\t\t\tGcflags:    p.Internal.Gcflags,\n+\t\t\tLdflags:    p.Internal.Ldflags,\n+\t\t\tGccgoflags: p.Internal.Gccgoflags,\n+\t\t},\n+\t}\n+\n+\t// The generated main also imports testing, regexp, and os.\n+\t// Also the linker introduces implicit dependencies reported by LinkerDeps.\n+\tstk.Push(\"testmain\")\n+\tdeps := TestMainDeps // cap==len, so safe for append\n+\tfor _, d := range LinkerDeps(p) {\n+\t\tdeps = append(deps, d)\n+\t}\n+\tfor _, dep := range deps {\n+\t\tif dep == ptest.ImportPath {\n+\t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, ptest)\n+\t\t} else {\n+\t\t\tp1 := LoadImport(dep, \"\", nil, &stk, nil, 0)\n+\t\t\tif p1.Error != nil {\n+\t\t\t\treturn nil, nil, nil, p1.Error\n+\t\t\t}\n+\t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, p1)\n+\t\t}\n+\t}\n+\tstk.Pop()\n+\n+\tif cover != nil && cover.Pkgs != nil {\n+\t\t// Add imports, but avoid duplicates.\n+\t\tseen := map[*Package]bool{p: true, ptest: true}\n+\t\tfor _, p1 := range pmain.Internal.Imports {\n+\t\t\tseen[p1] = true\n+\t\t}\n+\t\tfor _, p1 := range cover.Pkgs {\n+\t\t\tif !seen[p1] {\n+\t\t\t\tseen[p1] = true\n+\t\t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, p1)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Do initial scan for metadata needed for writing _testmain.go\n+\t// Use that metadata to update the list of imports for package main.\n+\t// The list of imports is used by recompileForTest and by the loop\n+\t// afterward that gathers t.Cover information.\n+\tt, err := loadTestFuncs(ptest)\n+\tif err != nil {\n+\t\treturn nil, nil, nil, err\n+\t}\n+\tt.Cover = cover\n+\tif len(ptest.GoFiles)+len(ptest.CgoFiles) > 0 {\n+\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, ptest)\n+\t\tpmain.Imports = append(pmain.Imports, ptest.ImportPath)\n+\t\tt.ImportTest = true\n+\t}\n+\tif pxtest != nil {\n+\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, pxtest)\n+\t\tpmain.Imports = append(pmain.Imports, pxtest.ImportPath)\n+\t\tt.ImportXtest = true\n+\t}\n+\n+\t// Sort and dedup pmain.Imports.\n+\t// Only matters for go list -test output.\n+\tsort.Strings(pmain.Imports)\n+\tw := 0\n+\tfor _, path := range pmain.Imports {\n+\t\tif w == 0 || path != pmain.Imports[w-1] {\n+\t\t\tpmain.Imports[w] = path\n+\t\t\tw++\n+\t\t}\n+\t}\n+\tpmain.Imports = pmain.Imports[:w]\n+\tpmain.Internal.RawImports = str.StringList(pmain.Imports)\n+\n+\tif ptest != p {\n+\t\t// We have made modifications to the package p being tested\n+\t\t// and are rebuilding p (as ptest).\n+\t\t// Arrange to rebuild all packages q such that\n+\t\t// the test depends on q and q depends on p.\n+\t\t// This makes sure that q sees the modifications to p.\n+\t\t// Strictly speaking, the rebuild is only necessary if the\n+\t\t// modifications to p change its export metadata, but\n+\t\t// determining that is a bit tricky, so we rebuild always.\n+\t\trecompileForTest(pmain, p, ptest, pxtest)\n+\t}\n+\n+\t// Should we apply coverage analysis locally,\n+\t// only for this package and only for this test?\n+\t// Yes, if -cover is on but -coverpkg has not specified\n+\t// a list of packages for global coverage.\n+\tif cover != nil && cover.Local {\n+\t\tptest.Internal.CoverMode = cover.Mode\n+\t\tvar coverFiles []string\n+\t\tcoverFiles = append(coverFiles, ptest.GoFiles...)\n+\t\tcoverFiles = append(coverFiles, ptest.CgoFiles...)\n+\t\tptest.Internal.CoverVars = cover.DeclVars(ptest, coverFiles...)\n+\t}\n+\n+\tfor _, cp := range pmain.Internal.Imports {\n+\t\tif len(cp.Internal.CoverVars) > 0 {\n+\t\t\tt.Cover.Vars = append(t.Cover.Vars, coverInfo{cp, cp.Internal.CoverVars})\n+\t\t}\n+\t}\n+\n+\tdata, err := formatTestmain(t)\n+\tif err != nil {\n+\t\treturn nil, nil, nil, err\n+\t}\n+\tpmain.Internal.TestmainGo = &data\n+\n+\treturn pmain, ptest, pxtest, nil\n+}\n+\n+func testImportStack(top string, p *Package, target string) []string {\n+\tstk := []string{top, p.ImportPath}\n+Search:\n+\tfor p.ImportPath != target {\n+\t\tfor _, p1 := range p.Internal.Imports {\n+\t\t\tif p1.ImportPath == target || str.Contains(p1.Deps, target) {\n+\t\t\t\tstk = append(stk, p1.ImportPath)\n+\t\t\t\tp = p1\n+\t\t\t\tcontinue Search\n+\t\t\t}\n+\t\t}\n+\t\t// Can't happen, but in case it does...\n+\t\tstk = append(stk, \"<lost path to cycle>\")\n+\t\tbreak\n+\t}\n+\treturn stk\n+}\n+\n+func recompileForTest(pmain, preal, ptest, pxtest *Package) {\n+\t// The \"test copy\" of preal is ptest.\n+\t// For each package that depends on preal, make a \"test copy\"\n+\t// that depends on ptest. And so on, up the dependency tree.\n+\ttestCopy := map[*Package]*Package{preal: ptest}\n+\tfor _, p := range PackageList([]*Package{pmain}) {\n+\t\tif p == preal {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Copy on write.\n+\t\tdidSplit := p == pmain || p == pxtest\n+\t\tsplit := func() {\n+\t\t\tif didSplit {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdidSplit = true\n+\t\t\tif testCopy[p] != nil {\n+\t\t\t\tpanic(\"recompileForTest loop\")\n+\t\t\t}\n+\t\t\tp1 := new(Package)\n+\t\t\ttestCopy[p] = p1\n+\t\t\t*p1 = *p\n+\t\t\tp1.ForTest = preal.ImportPath\n+\t\t\tp1.Internal.Imports = make([]*Package, len(p.Internal.Imports))\n+\t\t\tcopy(p1.Internal.Imports, p.Internal.Imports)\n+\t\t\tp1.Imports = make([]string, len(p.Imports))\n+\t\t\tcopy(p1.Imports, p.Imports)\n+\t\t\tp = p1\n+\t\t\tp.Target = \"\"\n+\t\t}\n+\n+\t\t// Update p.Internal.Imports to use test copies.\n+\t\tfor i, imp := range p.Internal.Imports {\n+\t\t\tif p1 := testCopy[imp]; p1 != nil && p1 != imp {\n+\t\t\t\tsplit()\n+\t\t\t\tp.Internal.Imports[i] = p1\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// isTestFunc tells whether fn has the type of a testing function. arg\n+// specifies the parameter type we look for: B, M or T.\n+func isTestFunc(fn *ast.FuncDecl, arg string) bool {\n+\tif fn.Type.Results != nil && len(fn.Type.Results.List) > 0 ||\n+\t\tfn.Type.Params.List == nil ||\n+\t\tlen(fn.Type.Params.List) != 1 ||\n+\t\tlen(fn.Type.Params.List[0].Names) > 1 {\n+\t\treturn false\n+\t}\n+\tptr, ok := fn.Type.Params.List[0].Type.(*ast.StarExpr)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\t// We can't easily check that the type is *testing.M\n+\t// because we don't know how testing has been imported,\n+\t// but at least check that it's *M or *something.M.\n+\t// Same applies for B and T.\n+\tif name, ok := ptr.X.(*ast.Ident); ok && name.Name == arg {\n+\t\treturn true\n+\t}\n+\tif sel, ok := ptr.X.(*ast.SelectorExpr); ok && sel.Sel.Name == arg {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+// isTest tells whether name looks like a test (or benchmark, according to prefix).\n+// It is a Test (say) if there is a character after Test that is not a lower-case letter.\n+// We don't want TesticularCancer.\n+func isTest(name, prefix string) bool {\n+\tif !strings.HasPrefix(name, prefix) {\n+\t\treturn false\n+\t}\n+\tif len(name) == len(prefix) { // \"Test\" is ok\n+\t\treturn true\n+\t}\n+\trune, _ := utf8.DecodeRuneInString(name[len(prefix):])\n+\treturn !unicode.IsLower(rune)\n+}\n+\n+type coverInfo struct {\n+\tPackage *Package\n+\tVars    map[string]*CoverVar\n+}\n+\n+// loadTestFuncs returns the testFuncs describing the tests that will be run.\n+func loadTestFuncs(ptest *Package) (*testFuncs, error) {\n+\tt := &testFuncs{\n+\t\tPackage: ptest,\n+\t}\n+\tfor _, file := range ptest.TestGoFiles {\n+\t\tif err := t.load(filepath.Join(ptest.Dir, file), \"_test\", &t.ImportTest, &t.NeedTest); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tfor _, file := range ptest.XTestGoFiles {\n+\t\tif err := t.load(filepath.Join(ptest.Dir, file), \"_xtest\", &t.ImportXtest, &t.NeedXtest); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\treturn t, nil\n+}\n+\n+// formatTestmain returns the content of the _testmain.go file for t.\n+func formatTestmain(t *testFuncs) ([]byte, error) {\n+\tvar buf bytes.Buffer\n+\tif err := testmainTmpl.Execute(&buf, t); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn buf.Bytes(), nil\n+}\n+\n+type testFuncs struct {\n+\tTests       []testFunc\n+\tBenchmarks  []testFunc\n+\tExamples    []testFunc\n+\tTestMain    *testFunc\n+\tPackage     *Package\n+\tImportTest  bool\n+\tNeedTest    bool\n+\tImportXtest bool\n+\tNeedXtest   bool\n+\tCover       *TestCover\n+}\n+\n+// ImportPath returns the import path of the package being tested, if it is within GOPATH.\n+// This is printed by the testing package when running benchmarks.\n+func (t *testFuncs) ImportPath() string {\n+\tpkg := t.Package.ImportPath\n+\tif strings.HasPrefix(pkg, \"_/\") {\n+\t\treturn \"\"\n+\t}\n+\tif pkg == \"command-line-arguments\" {\n+\t\treturn \"\"\n+\t}\n+\treturn pkg\n+}\n+\n+// Covered returns a string describing which packages are being tested for coverage.\n+// If the covered package is the same as the tested package, it returns the empty string.\n+// Otherwise it is a comma-separated human-readable list of packages beginning with\n+// \" in\", ready for use in the coverage message.\n+func (t *testFuncs) Covered() string {\n+\tif t.Cover == nil || t.Cover.Paths == nil {\n+\t\treturn \"\"\n+\t}\n+\treturn \" in \" + strings.Join(t.Cover.Paths, \", \")\n+}\n+\n+// Tested returns the name of the package being tested.\n+func (t *testFuncs) Tested() string {\n+\treturn t.Package.Name\n+}\n+\n+type testFunc struct {\n+\tPackage   string // imported package name (_test or _xtest)\n+\tName      string // function name\n+\tOutput    string // output, for examples\n+\tUnordered bool   // output is allowed to be unordered.\n+}\n+\n+var testFileSet = token.NewFileSet()\n+\n+func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) error {\n+\tf, err := parser.ParseFile(testFileSet, filename, nil, parser.ParseComments)\n+\tif err != nil {\n+\t\treturn base.ExpandScanner(err)\n+\t}\n+\tfor _, d := range f.Decls {\n+\t\tn, ok := d.(*ast.FuncDecl)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif n.Recv != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tname := n.Name.String()\n+\t\tswitch {\n+\t\tcase name == \"TestMain\":\n+\t\t\tif isTestFunc(n, \"T\") {\n+\t\t\t\tt.Tests = append(t.Tests, testFunc{pkg, name, \"\", false})\n+\t\t\t\t*doImport, *seen = true, true\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\terr := checkTestFunc(n, \"M\")\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif t.TestMain != nil {\n+\t\t\t\treturn errors.New(\"multiple definitions of TestMain\")\n+\t\t\t}\n+\t\t\tt.TestMain = &testFunc{pkg, name, \"\", false}\n+\t\t\t*doImport, *seen = true, true\n+\t\tcase isTest(name, \"Test\"):\n+\t\t\terr := checkTestFunc(n, \"T\")\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tt.Tests = append(t.Tests, testFunc{pkg, name, \"\", false})\n+\t\t\t*doImport, *seen = true, true\n+\t\tcase isTest(name, \"Benchmark\"):\n+\t\t\terr := checkTestFunc(n, \"B\")\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tt.Benchmarks = append(t.Benchmarks, testFunc{pkg, name, \"\", false})\n+\t\t\t*doImport, *seen = true, true\n+\t\t}\n+\t}\n+\tex := doc.Examples(f)\n+\tsort.Slice(ex, func(i, j int) bool { return ex[i].Order < ex[j].Order })\n+\tfor _, e := range ex {\n+\t\t*doImport = true // import test file whether executed or not\n+\t\tif e.Output == \"\" && !e.EmptyOutput {\n+\t\t\t// Don't run examples with no output.\n+\t\t\tcontinue\n+\t\t}\n+\t\tt.Examples = append(t.Examples, testFunc{pkg, \"Example\" + e.Name, e.Output, e.Unordered})\n+\t\t*seen = true\n+\t}\n+\treturn nil\n+}\n+\n+func checkTestFunc(fn *ast.FuncDecl, arg string) error {\n+\tif !isTestFunc(fn, arg) {\n+\t\tname := fn.Name.String()\n+\t\tpos := testFileSet.Position(fn.Pos())\n+\t\treturn fmt.Errorf(\"%s: wrong signature for %s, must be: func %s(%s *testing.%s)\", pos, name, name, strings.ToLower(arg), arg)\n+\t}\n+\treturn nil\n+}\n+\n+var testmainTmpl = template.Must(template.New(\"main\").Parse(`\n+package main\n+\n+import (\n+{{if not .TestMain}}\n+\t\"os\"\n+{{end}}\n+\t\"testing\"\n+\t\"testing/internal/testdeps\"\n+\n+{{if .ImportTest}}\n+\t{{if .NeedTest}}_test{{else}}_{{end}} {{.Package.ImportPath | printf \"%q\"}}\n+{{end}}\n+{{if .ImportXtest}}\n+\t{{if .NeedXtest}}_xtest{{else}}_{{end}} {{.Package.ImportPath | printf \"%s_test\" | printf \"%q\"}}\n+{{end}}\n+{{if .Cover}}\n+{{range $i, $p := .Cover.Vars}}\n+\t_cover{{$i}} {{$p.Package.ImportPath | printf \"%q\"}}\n+{{end}}\n+{{end}}\n+)\n+\n+var tests = []testing.InternalTest{\n+{{range .Tests}}\n+\t{\"{{.Name}}\", {{.Package}}.{{.Name}}},\n+{{end}}\n+}\n+\n+var benchmarks = []testing.InternalBenchmark{\n+{{range .Benchmarks}}\n+\t{\"{{.Name}}\", {{.Package}}.{{.Name}}},\n+{{end}}\n+}\n+\n+var examples = []testing.InternalExample{\n+{{range .Examples}}\n+\t{\"{{.Name}}\", {{.Package}}.{{.Name}}, {{.Output | printf \"%q\"}}, {{.Unordered}}},\n+{{end}}\n+}\n+\n+func init() {\n+\ttestdeps.ImportPath = {{.ImportPath | printf \"%q\"}}\n+}\n+\n+{{if .Cover}}\n+\n+// Only updated by init functions, so no need for atomicity.\n+var (\n+\tcoverCounters = make(map[string][]uint32)\n+\tcoverBlocks = make(map[string][]testing.CoverBlock)\n+)\n+\n+func init() {\n+\t{{range $i, $p := .Cover.Vars}}\n+\t{{range $file, $cover := $p.Vars}}\n+\tcoverRegisterFile({{printf \"%q\" $cover.File}}, _cover{{$i}}.{{$cover.Var}}.Count[:], _cover{{$i}}.{{$cover.Var}}.Pos[:], _cover{{$i}}.{{$cover.Var}}.NumStmt[:])\n+\t{{end}}\n+\t{{end}}\n+}\n+\n+func coverRegisterFile(fileName string, counter []uint32, pos []uint32, numStmts []uint16) {\n+\tif 3*len(counter) != len(pos) || len(counter) != len(numStmts) {\n+\t\tpanic(\"coverage: mismatched sizes\")\n+\t}\n+\tif coverCounters[fileName] != nil {\n+\t\t// Already registered.\n+\t\treturn\n+\t}\n+\tcoverCounters[fileName] = counter\n+\tblock := make([]testing.CoverBlock, len(counter))\n+\tfor i := range counter {\n+\t\tblock[i] = testing.CoverBlock{\n+\t\t\tLine0: pos[3*i+0],\n+\t\t\tCol0: uint16(pos[3*i+2]),\n+\t\t\tLine1: pos[3*i+1],\n+\t\t\tCol1: uint16(pos[3*i+2]>>16),\n+\t\t\tStmts: numStmts[i],\n+\t\t}\n+\t}\n+\tcoverBlocks[fileName] = block\n+}\n+{{end}}\n+\n+func main() {\n+{{if .Cover}}\n+\ttesting.RegisterCover(testing.Cover{\n+\t\tMode: {{printf \"%q\" .Cover.Mode}},\n+\t\tCounters: coverCounters,\n+\t\tBlocks: coverBlocks,\n+\t\tCoveredPackages: {{printf \"%q\" .Covered}},\n+\t})\n+{{end}}\n+\tm := testing.MainStart(testdeps.TestDeps{}, tests, benchmarks, examples)\n+{{with .TestMain}}\n+\t{{.Package}}.{{.Name}}(m)\n+{{else}}\n+\tos.Exit(m.Run())\n+{{end}}\n+}\n+\n+`))"}, {"sha": "cf42eff58a1f3b1a7c481fbbe20ac0042ab0d243", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modcmd\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/par\"\n+\t\"encoding/json\"\n+\t\"os\"\n+)\n+\n+var cmdDownload = &base.Command{\n+\tUsageLine: \"go mod download [-dir] [-json] [modules]\",\n+\tShort:     \"download modules to local cache\",\n+\tLong: `\n+Download downloads the named modules, which can be module patterns selecting\n+dependencies of the main module or module queries of the form path@version.\n+With no arguments, download applies to all dependencies of the main module.\n+\n+The go command will automatically download modules as needed during ordinary\n+execution. The \"go mod download\" command is useful mainly for pre-filling\n+the local cache or to compute the answers for a Go module proxy.\n+\n+By default, download reports errors to standard error but is otherwise silent.\n+The -json flag causes download to print a sequence of JSON objects\n+to standard output, describing each downloaded module (or failure),\n+corresponding to this Go struct:\n+\n+    type Module struct {\n+        Path     string // module path\n+        Version  string // module version\n+        Error    string // error loading module\n+        Info     string // absolute path to cached .info file\n+        GoMod    string // absolute path to cached .mod file\n+        Zip      string // absolute path to cached .zip file\n+        Dir      string // absolute path to cached source root directory\n+        Sum      string // checksum for path, version (as in go.sum)\n+        GoModSum string // checksum for go.mod (as in go.sum)\n+    }\n+\n+See 'go help modules' for more about module queries.\n+\t`,\n+}\n+\n+var downloadJSON = cmdDownload.Flag.Bool(\"json\", false, \"\")\n+\n+func init() {\n+\tcmdDownload.Run = runDownload // break init cycle\n+}\n+\n+type moduleJSON struct {\n+\tPath     string `json:\",omitempty\"`\n+\tVersion  string `json:\",omitempty\"`\n+\tError    string `json:\",omitempty\"`\n+\tInfo     string `json:\",omitempty\"`\n+\tGoMod    string `json:\",omitempty\"`\n+\tZip      string `json:\",omitempty\"`\n+\tDir      string `json:\",omitempty\"`\n+\tSum      string `json:\",omitempty\"`\n+\tGoModSum string `json:\",omitempty\"`\n+}\n+\n+func runDownload(cmd *base.Command, args []string) {\n+\tif len(args) == 0 {\n+\t\targs = []string{\"all\"}\n+\t}\n+\n+\tvar mods []*moduleJSON\n+\tvar work par.Work\n+\tlistU := false\n+\tlistVersions := false\n+\tfor _, info := range modload.ListModules(args, listU, listVersions) {\n+\t\tif info.Replace != nil {\n+\t\t\tinfo = info.Replace\n+\t\t}\n+\t\tif info.Version == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tm := &moduleJSON{\n+\t\t\tPath:    info.Path,\n+\t\t\tVersion: info.Version,\n+\t\t}\n+\t\tmods = append(mods, m)\n+\t\twork.Add(m)\n+\t}\n+\n+\twork.Do(10, func(item interface{}) {\n+\t\tm := item.(*moduleJSON)\n+\t\tvar err error\n+\t\tm.Info, err = modfetch.InfoFile(m.Path, m.Version)\n+\t\tif err != nil {\n+\t\t\tm.Error = err.Error()\n+\t\t\treturn\n+\t\t}\n+\t\tm.GoMod, err = modfetch.GoModFile(m.Path, m.Version)\n+\t\tif err != nil {\n+\t\t\tm.Error = err.Error()\n+\t\t\treturn\n+\t\t}\n+\t\tm.GoModSum, err = modfetch.GoModSum(m.Path, m.Version)\n+\t\tif err != nil {\n+\t\t\tm.Error = err.Error()\n+\t\t\treturn\n+\t\t}\n+\t\tmod := module.Version{Path: m.Path, Version: m.Version}\n+\t\tm.Zip, err = modfetch.DownloadZip(mod)\n+\t\tif err != nil {\n+\t\t\tm.Error = err.Error()\n+\t\t\treturn\n+\t\t}\n+\t\tm.Sum = modfetch.Sum(mod)\n+\t\tm.Dir, err = modfetch.Download(mod)\n+\t\tif err != nil {\n+\t\t\tm.Error = err.Error()\n+\t\t\treturn\n+\t\t}\n+\t})\n+\n+\tif *downloadJSON {\n+\t\tfor _, m := range mods {\n+\t\t\tb, err := json.MarshalIndent(m, \"\", \"\\t\")\n+\t\t\tif err != nil {\n+\t\t\t\tbase.Fatalf(\"%v\", err)\n+\t\t\t}\n+\t\t\tos.Stdout.Write(append(b, '\\n'))\n+\t\t}\n+\t}\n+}"}, {"sha": "5fea3e48e0816d82531050ffe7802cbe720f612c", "filename": "libgo/go/cmd/go/internal/modcmd/edit.go", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,382 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// go mod edit\n+\n+package modcmd\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+var cmdEdit = &base.Command{\n+\tUsageLine: \"go mod edit [editing flags] [go.mod]\",\n+\tShort:     \"edit go.mod from tools or scripts\",\n+\tLong: `\n+Edit provides a command-line interface for editing go.mod,\n+for use primarily by tools or scripts. It reads only go.mod;\n+it does not look up information about the modules involved.\n+By default, edit reads and writes the go.mod file of the main module,\n+but a different target file can be specified after the editing flags.\n+\n+The editing flags specify a sequence of editing operations.\n+\n+The -fmt flag reformats the go.mod file without making other changes.\n+This reformatting is also implied by any other modifications that use or\n+rewrite the go.mod file. The only time this flag is needed is if no other\n+flags are specified, as in 'go mod edit -fmt'.\n+\n+The -module flag changes the module's path (the go.mod file's module line).\n+\n+The -require=path@version and -droprequire=path flags\n+add and drop a requirement on the given module path and version.\n+Note that -require overrides any existing requirements on path.\n+These flags are mainly for tools that understand the module graph.\n+Users should prefer 'go get path@version' or 'go get path@none',\n+which make other go.mod adjustments as needed to satisfy\n+constraints imposed by other modules.\n+\n+The -exclude=path@version and -dropexclude=path@version flags\n+add and drop an exclusion for the given module path and version.\n+Note that -exclude=path@version is a no-op if that exclusion already exists.\n+\n+The -replace=old[@v]=new[@v] and -dropreplace=old[@v] flags\n+add and drop a replacement of the given module path and version pair.\n+If the @v in old@v is omitted, the replacement applies to all versions\n+with the old module path. If the @v in new@v is omitted, the new path\n+should be a local module root directory, not a module path.\n+Note that -replace overrides any existing replacements for old[@v].\n+\n+The -require, -droprequire, -exclude, -dropexclude, -replace,\n+and -dropreplace editing flags may be repeated, and the changes\n+are applied in the order given.\n+\n+The -print flag prints the final go.mod in its text format instead of\n+writing it back to go.mod.\n+\n+The -json flag prints the final go.mod file in JSON format instead of\n+writing it back to go.mod. The JSON output corresponds to these Go types:\n+\n+\ttype Module struct {\n+\t\tPath string\n+\t\tVersion string\n+\t}\n+\n+\ttype GoMod struct {\n+\t\tModule Module\n+\t\tRequire []Require\n+\t\tExclude []Module\n+\t\tReplace []Replace\n+\t}\n+\n+\ttype Require struct {\n+\t\tPath string\n+\t\tVersion string\n+\t\tIndirect bool\n+\t}\n+\n+\ttype Replace struct {\n+\t\tOld Module\n+\t\tNew Module\n+\t}\n+\n+Note that this only describes the go.mod file itself, not other modules\n+referred to indirectly. For the full set of modules available to a build,\n+use 'go list -m -json all'.\n+\n+For example, a tool can obtain the go.mod as a data structure by\n+parsing the output of 'go mod edit -json' and can then make changes\n+by invoking 'go mod edit' with -require, -exclude, and so on.\n+\t`,\n+}\n+\n+var (\n+\teditFmt = cmdEdit.Flag.Bool(\"fmt\", false, \"\")\n+\t// editGo     = cmdEdit.Flag.String(\"go\", \"\", \"\")\n+\teditJSON   = cmdEdit.Flag.Bool(\"json\", false, \"\")\n+\teditPrint  = cmdEdit.Flag.Bool(\"print\", false, \"\")\n+\teditModule = cmdEdit.Flag.String(\"module\", \"\", \"\")\n+\tedits      []func(*modfile.File) // edits specified in flags\n+)\n+\n+type flagFunc func(string)\n+\n+func (f flagFunc) String() string     { return \"\" }\n+func (f flagFunc) Set(s string) error { f(s); return nil }\n+\n+func init() {\n+\tcmdEdit.Run = runEdit // break init cycle\n+\n+\tcmdEdit.Flag.Var(flagFunc(flagRequire), \"require\", \"\")\n+\tcmdEdit.Flag.Var(flagFunc(flagDropRequire), \"droprequire\", \"\")\n+\tcmdEdit.Flag.Var(flagFunc(flagExclude), \"exclude\", \"\")\n+\tcmdEdit.Flag.Var(flagFunc(flagDropReplace), \"dropreplace\", \"\")\n+\tcmdEdit.Flag.Var(flagFunc(flagReplace), \"replace\", \"\")\n+\tcmdEdit.Flag.Var(flagFunc(flagDropExclude), \"dropexclude\", \"\")\n+\n+\tbase.AddBuildFlagsNX(&cmdEdit.Flag)\n+}\n+\n+func runEdit(cmd *base.Command, args []string) {\n+\tanyFlags :=\n+\t\t*editModule != \"\" ||\n+\t\t\t*editJSON ||\n+\t\t\t*editPrint ||\n+\t\t\t*editFmt ||\n+\t\t\tlen(edits) > 0\n+\n+\tif !anyFlags {\n+\t\tbase.Fatalf(\"go mod edit: no flags specified (see 'go help mod edit').\")\n+\t}\n+\n+\tif *editJSON && *editPrint {\n+\t\tbase.Fatalf(\"go mod edit: cannot use both -json and -print\")\n+\t}\n+\n+\tif len(args) > 1 {\n+\t\tbase.Fatalf(\"go mod edit: too many arguments\")\n+\t}\n+\tvar gomod string\n+\tif len(args) == 1 {\n+\t\tgomod = args[0]\n+\t} else {\n+\t\tmodload.MustInit()\n+\t\tgomod = filepath.Join(modload.ModRoot, \"go.mod\")\n+\t}\n+\n+\tif *editModule != \"\" {\n+\t\tif err := module.CheckPath(*editModule); err != nil {\n+\t\t\tbase.Fatalf(\"go mod: invalid -module: %v\", err)\n+\t\t}\n+\t}\n+\n+\t// TODO(rsc): Implement -go= once we start advertising it.\n+\n+\tdata, err := ioutil.ReadFile(gomod)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\n+\tmodFile, err := modfile.Parse(gomod, data, nil)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: errors parsing %s:\\n%s\", base.ShortPath(gomod), err)\n+\t}\n+\n+\tif *editModule != \"\" {\n+\t\tmodFile.AddModuleStmt(modload.CmdModModule)\n+\t}\n+\n+\tif len(edits) > 0 {\n+\t\tfor _, edit := range edits {\n+\t\t\tedit(modFile)\n+\t\t}\n+\t}\n+\tmodFile.SortBlocks()\n+\tmodFile.Cleanup() // clean file after edits\n+\n+\tif *editJSON {\n+\t\teditPrintJSON(modFile)\n+\t\treturn\n+\t}\n+\n+\tdata, err = modFile.Format()\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\n+\tif *editPrint {\n+\t\tos.Stdout.Write(data)\n+\t\treturn\n+\t}\n+\n+\tif err := ioutil.WriteFile(gomod, data, 0666); err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+}\n+\n+// parsePathVersion parses -flag=arg expecting arg to be path@version.\n+func parsePathVersion(flag, arg string) (path, version string) {\n+\ti := strings.Index(arg, \"@\")\n+\tif i < 0 {\n+\t\tbase.Fatalf(\"go mod: -%s=%s: need path@version\", flag, arg)\n+\t}\n+\tpath, version = strings.TrimSpace(arg[:i]), strings.TrimSpace(arg[i+1:])\n+\tif err := module.CheckPath(path); err != nil {\n+\t\tbase.Fatalf(\"go mod: -%s=%s: invalid path: %v\", flag, arg, err)\n+\t}\n+\n+\t// We don't call modfile.CheckPathVersion, because that insists\n+\t// on versions being in semver form, but here we want to allow\n+\t// versions like \"master\" or \"1234abcdef\", which the go command will resolve\n+\t// the next time it runs (or during -fix).\n+\t// Even so, we need to make sure the version is a valid token.\n+\tif modfile.MustQuote(version) {\n+\t\tbase.Fatalf(\"go mod: -%s=%s: invalid version %q\", flag, arg, version)\n+\t}\n+\n+\treturn path, version\n+}\n+\n+// parsePath parses -flag=arg expecting arg to be path (not path@version).\n+func parsePath(flag, arg string) (path string) {\n+\tif strings.Contains(arg, \"@\") {\n+\t\tbase.Fatalf(\"go mod: -%s=%s: need just path, not path@version\", flag, arg)\n+\t}\n+\tpath = arg\n+\tif err := module.CheckPath(path); err != nil {\n+\t\tbase.Fatalf(\"go mod: -%s=%s: invalid path: %v\", flag, arg, err)\n+\t}\n+\treturn path\n+}\n+\n+// parsePathVersionOptional parses path[@version], using adj to\n+// describe any errors.\n+func parsePathVersionOptional(adj, arg string, allowDirPath bool) (path, version string, err error) {\n+\tif i := strings.Index(arg, \"@\"); i < 0 {\n+\t\tpath = arg\n+\t} else {\n+\t\tpath, version = strings.TrimSpace(arg[:i]), strings.TrimSpace(arg[i+1:])\n+\t}\n+\tif err := module.CheckPath(path); err != nil {\n+\t\tif !allowDirPath || !modfile.IsDirectoryPath(path) {\n+\t\t\treturn path, version, fmt.Errorf(\"invalid %s path: %v\", adj, err)\n+\t\t}\n+\t}\n+\tif path != arg && modfile.MustQuote(version) {\n+\t\treturn path, version, fmt.Errorf(\"invalid %s version: %q\", adj, version)\n+\t}\n+\treturn path, version, nil\n+}\n+\n+// flagRequire implements the -require flag.\n+func flagRequire(arg string) {\n+\tpath, version := parsePathVersion(\"require\", arg)\n+\tedits = append(edits, func(f *modfile.File) {\n+\t\tif err := f.AddRequire(path, version); err != nil {\n+\t\t\tbase.Fatalf(\"go mod: -require=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n+// flagDropRequire implements the -droprequire flag.\n+func flagDropRequire(arg string) {\n+\tpath := parsePath(\"droprequire\", arg)\n+\tedits = append(edits, func(f *modfile.File) {\n+\t\tif err := f.DropRequire(path); err != nil {\n+\t\t\tbase.Fatalf(\"go mod: -droprequire=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n+// flagExclude implements the -exclude flag.\n+func flagExclude(arg string) {\n+\tpath, version := parsePathVersion(\"exclude\", arg)\n+\tedits = append(edits, func(f *modfile.File) {\n+\t\tif err := f.AddExclude(path, version); err != nil {\n+\t\t\tbase.Fatalf(\"go mod: -exclude=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n+// flagDropExclude implements the -dropexclude flag.\n+func flagDropExclude(arg string) {\n+\tpath, version := parsePathVersion(\"dropexclude\", arg)\n+\tedits = append(edits, func(f *modfile.File) {\n+\t\tif err := f.DropExclude(path, version); err != nil {\n+\t\t\tbase.Fatalf(\"go mod: -dropexclude=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n+// flagReplace implements the -replace flag.\n+func flagReplace(arg string) {\n+\tvar i int\n+\tif i = strings.Index(arg, \"=\"); i < 0 {\n+\t\tbase.Fatalf(\"go mod: -replace=%s: need old[@v]=new[@w] (missing =)\", arg)\n+\t}\n+\told, new := strings.TrimSpace(arg[:i]), strings.TrimSpace(arg[i+1:])\n+\tif strings.HasPrefix(new, \">\") {\n+\t\tbase.Fatalf(\"go mod: -replace=%s: separator between old and new is =, not =>\", arg)\n+\t}\n+\toldPath, oldVersion, err := parsePathVersionOptional(\"old\", old, false)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go mod: -replace=%s: %v\", arg, err)\n+\t}\n+\tnewPath, newVersion, err := parsePathVersionOptional(\"new\", new, true)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go mod: -replace=%s: %v\", arg, err)\n+\t}\n+\tif newPath == new && !modfile.IsDirectoryPath(new) {\n+\t\tbase.Fatalf(\"go mod: -replace=%s: unversioned new path must be local directory\", arg)\n+\t}\n+\n+\tedits = append(edits, func(f *modfile.File) {\n+\t\tif err := f.AddReplace(oldPath, oldVersion, newPath, newVersion); err != nil {\n+\t\t\tbase.Fatalf(\"go mod: -replace=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n+// flagDropReplace implements the -dropreplace flag.\n+func flagDropReplace(arg string) {\n+\tpath, version, err := parsePathVersionOptional(\"old\", arg, true)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go mod: -dropreplace=%s: %v\", arg, err)\n+\t}\n+\tedits = append(edits, func(f *modfile.File) {\n+\t\tif err := f.DropReplace(path, version); err != nil {\n+\t\t\tbase.Fatalf(\"go mod: -dropreplace=%s: %v\", arg, err)\n+\t\t}\n+\t})\n+}\n+\n+// fileJSON is the -json output data structure.\n+type fileJSON struct {\n+\tModule  module.Version\n+\tRequire []requireJSON\n+\tExclude []module.Version\n+\tReplace []replaceJSON\n+}\n+\n+type requireJSON struct {\n+\tPath     string\n+\tVersion  string `json:\",omitempty\"`\n+\tIndirect bool   `json:\",omitempty\"`\n+}\n+\n+type replaceJSON struct {\n+\tOld module.Version\n+\tNew module.Version\n+}\n+\n+// editPrintJSON prints the -json output.\n+func editPrintJSON(modFile *modfile.File) {\n+\tvar f fileJSON\n+\tf.Module = modFile.Module.Mod\n+\tfor _, r := range modFile.Require {\n+\t\tf.Require = append(f.Require, requireJSON{Path: r.Mod.Path, Version: r.Mod.Version, Indirect: r.Indirect})\n+\t}\n+\tfor _, x := range modFile.Exclude {\n+\t\tf.Exclude = append(f.Exclude, x.Mod)\n+\t}\n+\tfor _, r := range modFile.Replace {\n+\t\tf.Replace = append(f.Replace, replaceJSON{r.Old, r.New})\n+\t}\n+\tdata, err := json.MarshalIndent(&f, \"\", \"\\t\")\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: internal error: %v\", err)\n+\t}\n+\tdata = append(data, '\\n')\n+\tos.Stdout.Write(data)\n+}"}, {"sha": "5825c6d8ca8e0b5478e8db2337278dd1f0811a96", "filename": "libgo/go/cmd/go/internal/modcmd/graph.go", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// go mod graph\n+\n+package modcmd\n+\n+import (\n+\t\"bufio\"\n+\t\"os\"\n+\t\"sort\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/par\"\n+)\n+\n+var cmdGraph = &base.Command{\n+\tUsageLine: \"go mod graph\",\n+\tShort:     \"print module requirement graph\",\n+\tLong: `\n+Graph prints the module requirement graph (with replacements applied)\n+in text form. Each line in the output has two space-separated fields: a module\n+and one of its requirements. Each module is identified as a string of the form\n+path@version, except for the main module, which has no @version suffix.\n+\t`,\n+\tRun: runGraph,\n+}\n+\n+func runGraph(cmd *base.Command, args []string) {\n+\tif len(args) > 0 {\n+\t\tbase.Fatalf(\"go mod graph: graph takes no arguments\")\n+\t}\n+\tmodload.LoadBuildList()\n+\n+\treqs := modload.MinReqs()\n+\tformat := func(m module.Version) string {\n+\t\tif m.Version == \"\" {\n+\t\t\treturn m.Path\n+\t\t}\n+\t\treturn m.Path + \"@\" + m.Version\n+\t}\n+\n+\t// Note: using par.Work only to manage work queue.\n+\t// No parallelism here, so no locking.\n+\tvar out []string\n+\tvar deps int // index in out where deps start\n+\tvar work par.Work\n+\twork.Add(modload.Target)\n+\twork.Do(1, func(item interface{}) {\n+\t\tm := item.(module.Version)\n+\t\tlist, _ := reqs.Required(m)\n+\t\tfor _, r := range list {\n+\t\t\twork.Add(r)\n+\t\t\tout = append(out, format(m)+\" \"+format(r)+\"\\n\")\n+\t\t}\n+\t\tif m == modload.Target {\n+\t\t\tdeps = len(out)\n+\t\t}\n+\t})\n+\n+\tsort.Slice(out[deps:], func(i, j int) bool {\n+\t\treturn out[deps+i][0] < out[deps+j][0]\n+\t})\n+\n+\tw := bufio.NewWriter(os.Stdout)\n+\tfor _, line := range out {\n+\t\tw.WriteString(line)\n+\t}\n+\tw.Flush()\n+}"}, {"sha": "f510a46262b4eb95c619c94043bed5ee7a5ef0a3", "filename": "libgo/go/cmd/go/internal/modcmd/init.go", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// go mod init\n+\n+package modcmd\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modload\"\n+\t\"os\"\n+)\n+\n+var cmdInit = &base.Command{\n+\tUsageLine: \"go mod init [module]\",\n+\tShort:     \"initialize new module in current directory\",\n+\tLong: `\n+Init initializes and writes a new go.mod to the current directory,\n+in effect creating a new module rooted at the current directory.\n+The file go.mod must not already exist.\n+If possible, init will guess the module path from import comments\n+(see 'go help importpath') or from version control configuration.\n+To override this guess, supply the module path as an argument.\n+\t`,\n+\tRun: runInit,\n+}\n+\n+func runInit(cmd *base.Command, args []string) {\n+\tmodload.CmdModInit = true\n+\tif len(args) > 1 {\n+\t\tbase.Fatalf(\"go mod init: too many arguments\")\n+\t}\n+\tif len(args) == 1 {\n+\t\tmodload.CmdModModule = args[0]\n+\t}\n+\tif _, err := os.Stat(\"go.mod\"); err == nil {\n+\t\tbase.Fatalf(\"go mod init: go.mod already exists\")\n+\t}\n+\tmodload.InitMod() // does all the hard work\n+}"}, {"sha": "f150cc9728a4e588112cc1ba845dbdfb1a3b2d7b", "filename": "libgo/go/cmd/go/internal/modcmd/mod.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fmod.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package modcmd implements the ``go mod'' command.\n+package modcmd\n+\n+import \"cmd/go/internal/base\"\n+\n+var CmdMod = &base.Command{\n+\tUsageLine: \"go mod\",\n+\tShort:     \"module maintenance\",\n+\tLong: `Go mod provides access to operations on modules.\n+\n+Note that support for modules is built into all the go commands,\n+not just 'go mod'. For example, day-to-day adding, removing, upgrading,\n+and downgrading of dependencies should be done using 'go get'.\n+See 'go help modules' for an overview of module functionality.\n+\t`,\n+\n+\tCommands: []*base.Command{\n+\t\tcmdDownload,\n+\t\tcmdEdit,\n+\t\tcmdGraph,\n+\t\tcmdInit,\n+\t\tcmdTidy,\n+\t\tcmdVendor,\n+\t\tcmdVerify,\n+\t\tcmdWhy,\n+\t},\n+}"}, {"sha": "f2063a9ea601c976d596c9581aed7144db2f605d", "filename": "libgo/go/cmd/go/internal/modcmd/tidy.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// go mod tidy\n+\n+package modcmd\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+var cmdTidy = &base.Command{\n+\tUsageLine: \"go mod tidy [-v]\",\n+\tShort:     \"add missing and remove unused modules\",\n+\tLong: `\n+Tidy makes sure go.mod matches the source code in the module.\n+It adds any missing modules necessary to build the current module's\n+packages and dependencies, and it removes unused modules that\n+don't provide any relevant packages. It also adds any missing entries\n+to go.sum and removes any unnecessary ones.\n+\n+The -v flag causes tidy to print information about removed modules\n+to standard error.\n+\t`,\n+}\n+\n+func init() {\n+\tcmdTidy.Run = runTidy // break init cycle\n+\tcmdTidy.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n+}\n+\n+func runTidy(cmd *base.Command, args []string) {\n+\tif len(args) > 0 {\n+\t\tbase.Fatalf(\"go mod tidy: no arguments allowed\")\n+\t}\n+\n+\t// LoadALL adds missing modules.\n+\t// Remove unused modules.\n+\tused := make(map[module.Version]bool)\n+\tfor _, pkg := range modload.LoadALL() {\n+\t\tused[modload.PackageModule(pkg)] = true\n+\t}\n+\tused[modload.Target] = true // note: LoadALL initializes Target\n+\n+\tinGoMod := make(map[string]bool)\n+\tfor _, r := range modload.ModFile().Require {\n+\t\tinGoMod[r.Mod.Path] = true\n+\t}\n+\n+\tvar keep []module.Version\n+\tfor _, m := range modload.BuildList() {\n+\t\tif used[m] {\n+\t\t\tkeep = append(keep, m)\n+\t\t} else if cfg.BuildV && inGoMod[m.Path] {\n+\t\t\tfmt.Fprintf(os.Stderr, \"unused %s\\n\", m.Path)\n+\t\t}\n+\t}\n+\tmodload.SetBuildList(keep)\n+\tmodTidyGoSum() // updates memory copy; WriteGoMod on next line flushes it out\n+\tmodload.WriteGoMod()\n+}\n+\n+// modTidyGoSum resets the go.sum file content\n+// to be exactly what's needed for the current go.mod.\n+func modTidyGoSum() {\n+\t// Assuming go.sum already has at least enough from the successful load,\n+\t// we only have to tell modfetch what needs keeping.\n+\treqs := modload.Reqs()\n+\tkeep := make(map[module.Version]bool)\n+\tvar walk func(module.Version)\n+\twalk = func(m module.Version) {\n+\t\tkeep[m] = true\n+\t\tlist, _ := reqs.Required(m)\n+\t\tfor _, r := range list {\n+\t\t\tif !keep[r] {\n+\t\t\t\twalk(r)\n+\t\t\t}\n+\t\t}\n+\t}\n+\twalk(modload.Target)\n+\tmodfetch.TrimGoSum(keep)\n+}"}, {"sha": "62e74585359e77a69d7b9ee0e514ba645fb2490c", "filename": "libgo/go/cmd/go/internal/modcmd/vendor.go", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,200 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modcmd\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+var cmdVendor = &base.Command{\n+\tUsageLine: \"go mod vendor [-v]\",\n+\tShort:     \"make vendored copy of dependencies\",\n+\tLong: `\n+Vendor resets the main module's vendor directory to include all packages\n+needed to build and test all the main module's packages.\n+It does not include test code for vendored packages.\n+\n+The -v flag causes vendor to print the names of vendored\n+modules and packages to standard error.\n+\t`,\n+\tRun: runVendor,\n+}\n+\n+func init() {\n+\tcmdVendor.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n+}\n+\n+func runVendor(cmd *base.Command, args []string) {\n+\tif len(args) != 0 {\n+\t\tbase.Fatalf(\"go mod vendor: vendor takes no arguments\")\n+\t}\n+\tpkgs := modload.LoadVendor()\n+\n+\tvdir := filepath.Join(modload.ModRoot, \"vendor\")\n+\tif err := os.RemoveAll(vdir); err != nil {\n+\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t}\n+\n+\tmodpkgs := make(map[module.Version][]string)\n+\tfor _, pkg := range pkgs {\n+\t\tm := modload.PackageModule(pkg)\n+\t\tif m == modload.Target {\n+\t\t\tcontinue\n+\t\t}\n+\t\tmodpkgs[m] = append(modpkgs[m], pkg)\n+\t}\n+\n+\tvar buf bytes.Buffer\n+\tfor _, m := range modload.BuildList()[1:] {\n+\t\tif pkgs := modpkgs[m]; len(pkgs) > 0 {\n+\t\t\trepl := \"\"\n+\t\t\tif r := modload.Replacement(m); r.Path != \"\" {\n+\t\t\t\trepl = \" => \" + r.Path\n+\t\t\t\tif r.Version != \"\" {\n+\t\t\t\t\trepl += \" \" + r.Version\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfmt.Fprintf(&buf, \"# %s %s%s\\n\", m.Path, m.Version, repl)\n+\t\t\tif cfg.BuildV {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"# %s %s%s\\n\", m.Path, m.Version, repl)\n+\t\t\t}\n+\t\t\tfor _, pkg := range pkgs {\n+\t\t\t\tfmt.Fprintf(&buf, \"%s\\n\", pkg)\n+\t\t\t\tif cfg.BuildV {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", pkg)\n+\t\t\t\t}\n+\t\t\t\tvendorPkg(vdir, pkg)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif buf.Len() == 0 {\n+\t\tfmt.Fprintf(os.Stderr, \"go: no dependencies to vendor\\n\")\n+\t\treturn\n+\t}\n+\tif err := ioutil.WriteFile(filepath.Join(vdir, \"modules.txt\"), buf.Bytes(), 0666); err != nil {\n+\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t}\n+}\n+\n+func vendorPkg(vdir, pkg string) {\n+\trealPath := modload.ImportMap(pkg)\n+\tif realPath != pkg && modload.ImportMap(realPath) != \"\" {\n+\t\tfmt.Fprintf(os.Stderr, \"warning: %s imported as both %s and %s; making two copies.\\n\", realPath, realPath, pkg)\n+\t}\n+\n+\tdst := filepath.Join(vdir, pkg)\n+\tsrc := modload.PackageDir(realPath)\n+\tif src == \"\" {\n+\t\tfmt.Fprintf(os.Stderr, \"internal error: no pkg for %s -> %s\\n\", pkg, realPath)\n+\t}\n+\tcopyDir(dst, src, matchNonTest)\n+\tif m := modload.PackageModule(realPath); m.Path != \"\" {\n+\t\tcopyMetadata(m.Path, realPath, dst, src)\n+\t}\n+}\n+\n+type metakey struct {\n+\tmodPath string\n+\tdst     string\n+}\n+\n+var copiedMetadata = make(map[metakey]bool)\n+\n+// copyMetadata copies metadata files from parents of src to parents of dst,\n+// stopping after processing the src parent for modPath.\n+func copyMetadata(modPath, pkg, dst, src string) {\n+\tfor parent := 0; ; parent++ {\n+\t\tif copiedMetadata[metakey{modPath, dst}] {\n+\t\t\tbreak\n+\t\t}\n+\t\tcopiedMetadata[metakey{modPath, dst}] = true\n+\t\tif parent > 0 {\n+\t\t\tcopyDir(dst, src, matchMetadata)\n+\t\t}\n+\t\tif modPath == pkg {\n+\t\t\tbreak\n+\t\t}\n+\t\tpkg = filepath.Dir(pkg)\n+\t\tdst = filepath.Dir(dst)\n+\t\tsrc = filepath.Dir(src)\n+\t}\n+}\n+\n+// metaPrefixes is the list of metadata file prefixes.\n+// Vendoring copies metadata files from parents of copied directories.\n+// Note that this list could be arbitrarily extended, and it is longer\n+// in other tools (such as godep or dep). By using this limited set of\n+// prefixes and also insisting on capitalized file names, we are trying\n+// to nudge people toward more agreement on the naming\n+// and also trying to avoid false positives.\n+var metaPrefixes = []string{\n+\t\"AUTHORS\",\n+\t\"CONTRIBUTORS\",\n+\t\"COPYLEFT\",\n+\t\"COPYING\",\n+\t\"COPYRIGHT\",\n+\t\"LEGAL\",\n+\t\"LICENSE\",\n+\t\"NOTICE\",\n+\t\"PATENTS\",\n+}\n+\n+// matchMetadata reports whether info is a metadata file.\n+func matchMetadata(info os.FileInfo) bool {\n+\tname := info.Name()\n+\tfor _, p := range metaPrefixes {\n+\t\tif strings.HasPrefix(name, p) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// matchNonTest reports whether info is any non-test file (including non-Go files).\n+func matchNonTest(info os.FileInfo) bool {\n+\treturn !strings.HasSuffix(info.Name(), \"_test.go\")\n+}\n+\n+// copyDir copies all regular files satisfying match(info) from src to dst.\n+func copyDir(dst, src string, match func(os.FileInfo) bool) {\n+\tfiles, err := ioutil.ReadDir(src)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t}\n+\tif err := os.MkdirAll(dst, 0777); err != nil {\n+\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t}\n+\tfor _, file := range files {\n+\t\tif file.IsDir() || !file.Mode().IsRegular() || !match(file) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tr, err := os.Open(filepath.Join(src, file.Name()))\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\t}\n+\t\tw, err := os.Create(filepath.Join(dst, file.Name()))\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\t}\n+\t\tif _, err := io.Copy(w, r); err != nil {\n+\t\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\t}\n+\t\tr.Close()\n+\t\tif err := w.Close(); err != nil {\n+\t\t\tbase.Fatalf(\"go vendor: %v\", err)\n+\t\t}\n+\t}\n+}"}, {"sha": "381c18d58f1f607590599271160ffa0b42a37409", "filename": "libgo/go/cmd/go/internal/modcmd/verify.go", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modcmd\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/dirhash\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+var cmdVerify = &base.Command{\n+\tUsageLine: \"go mod verify\",\n+\tShort:     \"verify dependencies have expected content\",\n+\tLong: `\n+Verify checks that the dependencies of the current module,\n+which are stored in a local downloaded source cache, have not been\n+modified since being downloaded. If all the modules are unmodified,\n+verify prints \"all modules verified.\" Otherwise it reports which\n+modules have been changed and causes 'go mod' to exit with a\n+non-zero status.\n+\t`,\n+\tRun: runVerify,\n+}\n+\n+func runVerify(cmd *base.Command, args []string) {\n+\tif len(args) != 0 {\n+\t\t// NOTE(rsc): Could take a module pattern.\n+\t\tbase.Fatalf(\"go mod verify: verify takes no arguments\")\n+\t}\n+\tok := true\n+\tfor _, mod := range modload.LoadBuildList()[1:] {\n+\t\tok = verifyMod(mod) && ok\n+\t}\n+\tif ok {\n+\t\tfmt.Printf(\"all modules verified\\n\")\n+\t}\n+}\n+\n+func verifyMod(mod module.Version) bool {\n+\tok := true\n+\tzip, zipErr := modfetch.CachePath(mod, \"zip\")\n+\tif zipErr == nil {\n+\t\t_, zipErr = os.Stat(zip)\n+\t}\n+\tdir, dirErr := modfetch.DownloadDir(mod)\n+\tif dirErr == nil {\n+\t\t_, dirErr = os.Stat(dir)\n+\t}\n+\tdata, err := ioutil.ReadFile(zip + \"hash\")\n+\tif err != nil {\n+\t\tif zipErr != nil && os.IsNotExist(zipErr) && dirErr != nil && os.IsNotExist(dirErr) {\n+\t\t\t// Nothing downloaded yet. Nothing to verify.\n+\t\t\treturn true\n+\t\t}\n+\t\tbase.Errorf(\"%s %s: missing ziphash: %v\", mod.Path, mod.Version, err)\n+\t\treturn false\n+\t}\n+\th := string(bytes.TrimSpace(data))\n+\n+\tif zipErr != nil && os.IsNotExist(zipErr) {\n+\t\t// ok\n+\t} else {\n+\t\thZ, err := dirhash.HashZip(zip, dirhash.DefaultHash)\n+\t\tif err != nil {\n+\t\t\tbase.Errorf(\"%s %s: %v\", mod.Path, mod.Version, err)\n+\t\t\treturn false\n+\t\t} else if hZ != h {\n+\t\t\tbase.Errorf(\"%s %s: zip has been modified (%v)\", mod.Path, mod.Version, zip)\n+\t\t\tok = false\n+\t\t}\n+\t}\n+\tif dirErr != nil && os.IsNotExist(dirErr) {\n+\t\t// ok\n+\t} else {\n+\t\thD, err := dirhash.HashDir(dir, mod.Path+\"@\"+mod.Version, dirhash.DefaultHash)\n+\t\tif err != nil {\n+\n+\t\t\tbase.Errorf(\"%s %s: %v\", mod.Path, mod.Version, err)\n+\t\t\treturn false\n+\t\t}\n+\t\tif hD != h {\n+\t\t\tbase.Errorf(\"%s %s: dir has been modified (%v)\", mod.Path, mod.Version, dir)\n+\t\t\tok = false\n+\t\t}\n+\t}\n+\treturn ok\n+}"}, {"sha": "03e0a039bc5014d796a894b69fe9fcf4b0b6deea", "filename": "libgo/go/cmd/go/internal/modcmd/why.go", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modcmd\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/module\"\n+\t\"fmt\"\n+\t\"strings\"\n+)\n+\n+var cmdWhy = &base.Command{\n+\tUsageLine: \"go mod why [-m] [-vendor] packages...\",\n+\tShort:     \"explain why packages or modules are needed\",\n+\tLong: `\n+Why shows a shortest path in the import graph from the main module to\n+each of the listed packages. If the -m flag is given, why treats the\n+arguments as a list of modules and finds a path to any package in each\n+of the modules.\n+\n+By default, why queries the graph of packages matched by \"go list all\",\n+which includes tests for reachable packages. The -vendor flag causes why\n+to exclude tests of dependencies.\n+\n+The output is a sequence of stanzas, one for each package or module\n+name on the command line, separated by blank lines. Each stanza begins\n+with a comment line \"# package\" or \"# module\" giving the target\n+package or module. Subsequent lines give a path through the import\n+graph, one package per line. If the package or module is not\n+referenced from the main module, the stanza will display a single\n+parenthesized note indicating that fact.\n+\n+For example:\n+\n+\t$ go mod why golang.org/x/text/language golang.org/x/text/encoding\n+\t# golang.org/x/text/language\n+\trsc.io/quote\n+\trsc.io/sampler\n+\tgolang.org/x/text/language\n+\n+\t# golang.org/x/text/encoding\n+\t(main module does not need package golang.org/x/text/encoding)\n+\t$\n+\t`,\n+}\n+\n+var (\n+\twhyM      = cmdWhy.Flag.Bool(\"m\", false, \"\")\n+\twhyVendor = cmdWhy.Flag.Bool(\"vendor\", false, \"\")\n+)\n+\n+func init() {\n+\tcmdWhy.Run = runWhy // break init cycle\n+}\n+\n+func runWhy(cmd *base.Command, args []string) {\n+\tloadALL := modload.LoadALL\n+\tif *whyVendor {\n+\t\tloadALL = modload.LoadVendor\n+\t}\n+\tif *whyM {\n+\t\tlistU := false\n+\t\tlistVersions := false\n+\t\tfor _, arg := range args {\n+\t\t\tif strings.Contains(arg, \"@\") {\n+\t\t\t\tbase.Fatalf(\"go mod why: module query not allowed\")\n+\t\t\t}\n+\t\t}\n+\t\tmods := modload.ListModules(args, listU, listVersions)\n+\t\tbyModule := make(map[module.Version][]string)\n+\t\tfor _, path := range loadALL() {\n+\t\t\tm := modload.PackageModule(path)\n+\t\t\tif m.Path != \"\" {\n+\t\t\t\tbyModule[m] = append(byModule[m], path)\n+\t\t\t}\n+\t\t}\n+\t\tsep := \"\"\n+\t\tfor _, m := range mods {\n+\t\t\tbest := \"\"\n+\t\t\tbestDepth := 1000000000\n+\t\t\tfor _, path := range byModule[module.Version{Path: m.Path, Version: m.Version}] {\n+\t\t\t\td := modload.WhyDepth(path)\n+\t\t\t\tif d > 0 && d < bestDepth {\n+\t\t\t\t\tbest = path\n+\t\t\t\t\tbestDepth = d\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\twhy := modload.Why(best)\n+\t\t\tif why == \"\" {\n+\t\t\t\tvendoring := \"\"\n+\t\t\t\tif *whyVendor {\n+\t\t\t\t\tvendoring = \" to vendor\"\n+\t\t\t\t}\n+\t\t\t\twhy = \"(main module does not need\" + vendoring + \" module \" + m.Path + \")\\n\"\n+\t\t\t}\n+\t\t\tfmt.Printf(\"%s# %s\\n%s\", sep, m.Path, why)\n+\t\t\tsep = \"\\n\"\n+\t\t}\n+\t} else {\n+\t\tmatches := modload.ImportPaths(args) // resolve to packages\n+\t\tloadALL()                            // rebuild graph, from main module (not from named packages)\n+\t\tsep := \"\"\n+\t\tfor _, m := range matches {\n+\t\t\tfor _, path := range m.Pkgs {\n+\t\t\t\twhy := modload.Why(path)\n+\t\t\t\tif why == \"\" {\n+\t\t\t\t\tvendoring := \"\"\n+\t\t\t\t\tif *whyVendor {\n+\t\t\t\t\t\tvendoring = \" to vendor\"\n+\t\t\t\t\t}\n+\t\t\t\t\twhy = \"(main module does not need\" + vendoring + \" package \" + path + \")\\n\"\n+\t\t\t\t}\n+\t\t\t\tfmt.Printf(\"%s# %s\\n%s\", sep, path, why)\n+\t\t\t\tsep = \"\\n\"\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "6fc6718e4733aee72208614e68e2382cf1ba0273", "filename": "libgo/go/cmd/go/internal/modconv/convert.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/par\"\n+\t\"cmd/go/internal/semver\"\n+)\n+\n+// ConvertLegacyConfig converts legacy config to modfile.\n+// The file argument is slash-delimited.\n+func ConvertLegacyConfig(f *modfile.File, file string, data []byte) error {\n+\ti := strings.LastIndex(file, \"/\")\n+\tj := -2\n+\tif i >= 0 {\n+\t\tj = strings.LastIndex(file[:i], \"/\")\n+\t}\n+\tconvert := Converters[file[i+1:]]\n+\tif convert == nil && j != -2 {\n+\t\tconvert = Converters[file[j+1:]]\n+\t}\n+\tif convert == nil {\n+\t\treturn fmt.Errorf(\"unknown legacy config file %s\", file)\n+\t}\n+\tmf, err := convert(file, data)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"parsing %s: %v\", file, err)\n+\t}\n+\n+\t// Convert requirements block, which may use raw SHA1 hashes as versions,\n+\t// to valid semver requirement list, respecting major versions.\n+\tvar work par.Work\n+\tfor _, r := range mf.Require {\n+\t\tm := r.Mod\n+\t\tif m.Path == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\twork.Add(r.Mod)\n+\t}\n+\n+\tvar (\n+\t\tmu   sync.Mutex\n+\t\tneed = make(map[string]string)\n+\t)\n+\twork.Do(10, func(item interface{}) {\n+\t\tr := item.(module.Version)\n+\t\trepo, info, err := modfetch.ImportRepoRev(r.Path, r.Version)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: converting %s: stat %s@%s: %v\\n\", base.ShortPath(file), r.Path, r.Version, err)\n+\t\t\treturn\n+\t\t}\n+\t\tmu.Lock()\n+\t\tpath := repo.ModulePath()\n+\t\t// Don't use semver.Max here; need to preserve +incompatible suffix.\n+\t\tif v, ok := need[path]; !ok || semver.Compare(v, info.Version) < 0 {\n+\t\t\tneed[path] = info.Version\n+\t\t}\n+\t\tmu.Unlock()\n+\t})\n+\n+\tvar paths []string\n+\tfor path := range need {\n+\t\tpaths = append(paths, path)\n+\t}\n+\tsort.Strings(paths)\n+\tfor _, path := range paths {\n+\t\tf.AddNewRequire(path, need[path], false)\n+\t}\n+\n+\tfor _, r := range mf.Replace {\n+\t\terr := f.AddReplace(r.Old.Path, r.Old.Version, r.New.Path, r.New.Version)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"add replace: %v\", err)\n+\t\t}\n+\t}\n+\tf.Cleanup()\n+\treturn nil\n+}"}, {"sha": "ad27abb8ef7e1831aa2f6933d830e8865d9393a6", "filename": "libgo/go/cmd/go/internal/modconv/convert_test.go", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,186 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"internal/testenv\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/modfetch/codehost\"\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+func TestMain(m *testing.M) {\n+\tos.Exit(testMain(m))\n+}\n+\n+func testMain(m *testing.M) int {\n+\tif _, err := exec.LookPath(\"git\"); err != nil {\n+\t\tfmt.Fprintln(os.Stderr, \"skipping because git binary not found\")\n+\t\tfmt.Println(\"PASS\")\n+\t\treturn 0\n+\t}\n+\n+\tdir, err := ioutil.TempDir(\"\", \"modconv-test-\")\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\tmodfetch.PkgMod = filepath.Join(dir, \"pkg/mod\")\n+\tcodehost.WorkRoot = filepath.Join(dir, \"codework\")\n+\n+\treturn m.Run()\n+}\n+\n+func TestConvertLegacyConfig(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\tif testing.Verbose() {\n+\t\told := cfg.BuildX\n+\t\tdefer func() {\n+\t\t\tcfg.BuildX = old\n+\t\t}()\n+\t\tcfg.BuildX = true\n+\t}\n+\n+\tvar tests = []struct {\n+\t\tpath  string\n+\t\tvers  string\n+\t\tgomod string\n+\t}{\n+\t\t/*\n+\t\t\tDifferent versions of git seem to find or not find\n+\t\t\tgithub.com/Masterminds/semver's a93e51b5a57e,\n+\t\t\twhich is an unmerged pull request.\n+\t\t\tWe'd rather not provide access to unmerged pull requests,\n+\t\t\tso the line is removed from the golden file here,\n+\t\t\tbut some git commands still find it somehow.\n+\n+\t\t\t{\n+\t\t\t\t// Gopkg.lock parsing.\n+\t\t\t\t\"github.com/golang/dep\", \"v0.4.0\",\n+\t\t\t\t`module github.com/golang/dep\n+\n+\t\t\t\trequire (\n+\t\t\t\t\tgithub.com/Masterminds/vcs v1.11.1\n+\t\t\t\t\tgithub.com/armon/go-radix v0.0.0-20160115234725-4239b77079c7\n+\t\t\t\t\tgithub.com/boltdb/bolt v1.3.1\n+\t\t\t\t\tgithub.com/go-yaml/yaml v0.0.0-20170407172122-cd8b52f8269e\n+\t\t\t\t\tgithub.com/golang/protobuf v0.0.0-20170901042739-5afd06f9d81a\n+\t\t\t\t\tgithub.com/jmank88/nuts v0.3.0\n+\t\t\t\t\tgithub.com/nightlyone/lockfile v0.0.0-20170707060451-e83dc5e7bba0\n+\t\t\t\t\tgithub.com/pelletier/go-toml v0.0.0-20171218135716-b8b5e7696574\n+\t\t\t\t\tgithub.com/pkg/errors v0.8.0\n+\t\t\t\t\tgithub.com/sdboyer/constext v0.0.0-20170321163424-836a14457353\n+\t\t\t\t\tgolang.org/x/net v0.0.0-20170828231752-66aacef3dd8a\n+\t\t\t\t\tgolang.org/x/sync v0.0.0-20170517211232-f52d1811a629\n+\t\t\t\t\tgolang.org/x/sys v0.0.0-20170830134202-bb24a47a89ea\n+\t\t\t\t)`,\n+\t\t\t},\n+\t\t*/\n+\n+\t\t// TODO: https://github.com/docker/distribution uses vendor.conf\n+\n+\t\t{\n+\t\t\t// Godeps.json parsing.\n+\t\t\t// TODO: Should v2.0.0 work here too?\n+\t\t\t\"github.com/docker/distribution\", \"v0.0.0-20150410205453-85de3967aa93\",\n+\t\t\t`module github.com/docker/distribution\n+\n+\t\t\trequire (\n+\t\t\t\tgithub.com/AdRoll/goamz v0.0.0-20150130162828-d3664b76d905\n+\t\t\t\tgithub.com/MSOpenTech/azure-sdk-for-go v0.0.0-20150323223030-d90753bcad2e\n+\t\t\t\tgithub.com/Sirupsen/logrus v0.7.3\n+\t\t\t\tgithub.com/bugsnag/bugsnag-go v0.0.0-20141110184014-b1d153021fcd\n+\t\t\t\tgithub.com/bugsnag/osext v0.0.0-20130617224835-0dd3f918b21b\n+\t\t\t\tgithub.com/bugsnag/panicwrap v0.0.0-20141110184334-e5f9854865b9\n+\t\t\t\tgithub.com/codegangsta/cli v0.0.0-20150131031259-6086d7927ec3\n+\t\t\t\tgithub.com/docker/docker v0.0.0-20150204013315-165ea5c158cf\n+\t\t\t\tgithub.com/docker/libtrust v0.0.0-20150114040149-fa567046d9b1\n+\t\t\t\tgithub.com/garyburd/redigo v0.0.0-20150301180006-535138d7bcd7\n+\t\t\t\tgithub.com/gorilla/context v0.0.0-20140604161150-14f550f51af5\n+\t\t\t\tgithub.com/gorilla/handlers v0.0.0-20140825150757-0e84b7d810c1\n+\t\t\t\tgithub.com/gorilla/mux v0.0.0-20140926153814-e444e69cbd2e\n+\t\t\t\tgithub.com/jlhawn/go-crypto v0.0.0-20150401213827-cd738dde20f0\n+\t\t\t\tgithub.com/yvasiyarov/go-metrics v0.0.0-20140926110328-57bccd1ccd43\n+\t\t\t\tgithub.com/yvasiyarov/gorelic v0.0.0-20141212073537-a9bba5b9ab50\n+\t\t\t\tgithub.com/yvasiyarov/newrelic_platform_go v0.0.0-20140908184405-b21fdbd4370f\n+\t\t\t\tgolang.org/x/net v0.0.0-20150202051010-1dfe7915deaf\n+\t\t\t\tgopkg.in/check.v1 v1.0.0-20141024133853-64131543e789\n+\t\t\t\tgopkg.in/yaml.v2 v2.0.0-20150116202057-bef53efd0c76\n+\t\t\t)`,\n+\t\t},\n+\n+\t\t{\n+\t\t\t// golang.org/issue/24585 - confusion about v2.0.0 tag in legacy non-v2 module\n+\t\t\t\"github.com/fishy/gcsbucket\", \"v0.0.0-20150410205453-618d60fe84e0\",\n+\t\t\t`module github.com/fishy/gcsbucket\n+\n+\t\t\trequire (\n+\t\t\t\tcloud.google.com/go v0.18.0\n+\t\t\t\tgithub.com/fishy/fsdb v0.0.0-20180217030800-5527ded01371\n+\t\t\t\tgithub.com/golang/protobuf v1.0.0\n+\t\t\t\tgithub.com/googleapis/gax-go v2.0.0+incompatible\n+\t\t\t\tgolang.org/x/net v0.0.0-20180216171745-136a25c244d3\n+\t\t\t\tgolang.org/x/oauth2 v0.0.0-20180207181906-543e37812f10\n+\t\t\t\tgolang.org/x/text v0.0.0-20180208041248-4e4a3210bb54\n+\t\t\t\tgoogle.golang.org/api v0.0.0-20180217000815-c7a403bb5fe1\n+\t\t\t\tgoogle.golang.org/appengine v1.0.0\n+\t\t\t\tgoogle.golang.org/genproto v0.0.0-20180206005123-2b5a72b8730b\n+\t\t\t\tgoogle.golang.org/grpc v1.10.0\n+\t\t\t)`,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(strings.Replace(tt.path, \"/\", \"_\", -1)+\"_\"+tt.vers, func(t *testing.T) {\n+\t\t\tf, err := modfile.Parse(\"golden\", []byte(tt.gomod), nil)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\twant, err := f.Format()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\n+\t\t\tdir, err := modfetch.Download(module.Version{Path: tt.path, Version: tt.vers})\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\n+\t\t\tfor name := range Converters {\n+\t\t\t\tfile := filepath.Join(dir, name)\n+\t\t\t\tdata, err := ioutil.ReadFile(file)\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tf := new(modfile.File)\n+\t\t\t\t\tf.AddModuleStmt(tt.path)\n+\t\t\t\t\tif err := ConvertLegacyConfig(f, filepath.ToSlash(file), data); err != nil {\n+\t\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t\t}\n+\t\t\t\t\tout, err := f.Format()\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tt.Fatalf(\"format after conversion: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t\tif !bytes.Equal(out, want) {\n+\t\t\t\t\t\tt.Fatalf(\"final go.mod:\\n%s\\n\\nwant:\\n%s\", out, want)\n+\t\t\t\t\t}\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tt.Fatalf(\"no converter found for %s@%s\", tt.path, tt.vers)\n+\t\t})\n+\t}\n+}"}, {"sha": "690c206a1364e829e263096ae5422162b0fd41d7", "filename": "libgo/go/cmd/go/internal/modconv/dep.go", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fdep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fdep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fdep.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"fmt\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/semver\"\n+)\n+\n+func ParseGopkgLock(file string, data []byte) (*modfile.File, error) {\n+\tmf := new(modfile.File)\n+\tvar list []module.Version\n+\tvar r *module.Version\n+\tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n+\t\tlineno++\n+\t\tif i := strings.Index(line, \"#\"); i >= 0 {\n+\t\t\tline = line[:i]\n+\t\t}\n+\t\tline = strings.TrimSpace(line)\n+\t\tif line == \"[[projects]]\" {\n+\t\t\tlist = append(list, module.Version{})\n+\t\t\tr = &list[len(list)-1]\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.HasPrefix(line, \"[\") {\n+\t\t\tr = nil\n+\t\t\tcontinue\n+\t\t}\n+\t\tif r == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\ti := strings.Index(line, \"=\")\n+\t\tif i < 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tkey := strings.TrimSpace(line[:i])\n+\t\tval := strings.TrimSpace(line[i+1:])\n+\t\tif len(val) >= 2 && val[0] == '\"' && val[len(val)-1] == '\"' {\n+\t\t\tq, err := strconv.Unquote(val) // Go unquoting, but close enough for now\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"%s:%d: invalid quoted string: %v\", file, lineno, err)\n+\t\t\t}\n+\t\t\tval = q\n+\t\t}\n+\t\tswitch key {\n+\t\tcase \"name\":\n+\t\t\tr.Path = val\n+\t\tcase \"revision\", \"version\":\n+\t\t\t// Note: key \"version\" should take priority over \"revision\",\n+\t\t\t// and it does, because dep writes toml keys in alphabetical order,\n+\t\t\t// so we see version (if present) second.\n+\t\t\tif key == \"version\" {\n+\t\t\t\tif !semver.IsValid(val) || semver.Canonical(val) != val {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tr.Version = val\n+\t\t}\n+\t}\n+\tfor _, r := range list {\n+\t\tif r.Path == \"\" || r.Version == \"\" {\n+\t\t\treturn nil, fmt.Errorf(\"%s: empty [[projects]] stanza (%s)\", file, r.Path)\n+\t\t}\n+\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: r})\n+\t}\n+\treturn mf, nil\n+}"}, {"sha": "3bc675fcc0eb4bad6455ef14367659b118d6348a", "filename": "libgo/go/cmd/go/internal/modconv/glide.go", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglide.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglide.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglide.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+func ParseGlideLock(file string, data []byte) (*modfile.File, error) {\n+\tmf := new(modfile.File)\n+\timports := false\n+\tname := \"\"\n+\tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n+\t\tlineno++\n+\t\tif line == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.HasPrefix(line, \"imports:\") {\n+\t\t\timports = true\n+\t\t} else if line[0] != '-' && line[0] != ' ' && line[0] != '\\t' {\n+\t\t\timports = false\n+\t\t}\n+\t\tif !imports {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.HasPrefix(line, \"- name:\") {\n+\t\t\tname = strings.TrimSpace(line[len(\"- name:\"):])\n+\t\t}\n+\t\tif strings.HasPrefix(line, \"  version:\") {\n+\t\t\tversion := strings.TrimSpace(line[len(\"  version:\"):])\n+\t\t\tif name != \"\" && version != \"\" {\n+\t\t\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: module.Version{Path: name, Version: version}})\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn mf, nil\n+}"}, {"sha": "1b786a939c760cf2aff39544c96698fae9c5e37a", "filename": "libgo/go/cmd/go/internal/modconv/glock.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglock.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+func ParseGLOCKFILE(file string, data []byte) (*modfile.File, error) {\n+\tmf := new(modfile.File)\n+\tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n+\t\tlineno++\n+\t\tf := strings.Fields(line)\n+\t\tif len(f) >= 2 && f[0] != \"cmd\" {\n+\t\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: module.Version{Path: f[0], Version: f[1]}})\n+\t\t}\n+\t}\n+\treturn mf, nil\n+}"}, {"sha": "6398dbe7cd7475a5f54d737c8bc58dbde5863c4f", "filename": "libgo/go/cmd/go/internal/modconv/godeps.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fgodeps.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fgodeps.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fgodeps.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"encoding/json\"\n+\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+func ParseGodepsJSON(file string, data []byte) (*modfile.File, error) {\n+\tvar cfg struct {\n+\t\tImportPath string\n+\t\tDeps       []struct {\n+\t\t\tImportPath string\n+\t\t\tRev        string\n+\t\t}\n+\t}\n+\tif err := json.Unmarshal(data, &cfg); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tmf := new(modfile.File)\n+\tfor _, d := range cfg.Deps {\n+\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: module.Version{Path: d.ImportPath, Version: d.Rev}})\n+\t}\n+\treturn mf, nil\n+}"}, {"sha": "a58673382e6fd8f09c37a9cb8e1ec5814a51081e", "filename": "libgo/go/cmd/go/internal/modconv/modconv.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import \"cmd/go/internal/modfile\"\n+\n+var Converters = map[string]func(string, []byte) (*modfile.File, error){\n+\t\"GLOCKFILE\":          ParseGLOCKFILE,\n+\t\"Godeps/Godeps.json\": ParseGodepsJSON,\n+\t\"Gopkg.lock\":         ParseGopkgLock,\n+\t\"dependencies.tsv\":   ParseDependenciesTSV,\n+\t\"glide.lock\":         ParseGlideLock,\n+\t\"vendor.conf\":        ParseVendorConf,\n+\t\"vendor.yml\":         ParseVendorYML,\n+\t\"vendor/manifest\":    ParseVendorManifest,\n+\t\"vendor/vendor.json\": ParseVendorJSON,\n+}"}, {"sha": "353161bc5a3c613182daa9cc6416c86729ef647f", "filename": "libgo/go/cmd/go/internal/modconv/modconv_test.go", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+)\n+\n+var extMap = map[string]string{\n+\t\".dep\":       \"Gopkg.lock\",\n+\t\".glide\":     \"glide.lock\",\n+\t\".glock\":     \"GLOCKFILE\",\n+\t\".godeps\":    \"Godeps/Godeps.json\",\n+\t\".tsv\":       \"dependencies.tsv\",\n+\t\".vconf\":     \"vendor.conf\",\n+\t\".vjson\":     \"vendor/vendor.json\",\n+\t\".vyml\":      \"vendor.yml\",\n+\t\".vmanifest\": \"vendor/manifest\",\n+}\n+\n+func Test(t *testing.T) {\n+\ttests, _ := filepath.Glob(\"testdata/*\")\n+\tif len(tests) == 0 {\n+\t\tt.Fatalf(\"no tests found\")\n+\t}\n+\tfor _, test := range tests {\n+\t\tfile := filepath.Base(test)\n+\t\text := filepath.Ext(file)\n+\t\tif ext == \".out\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tt.Run(file, func(t *testing.T) {\n+\t\t\tif extMap[ext] == \"\" {\n+\t\t\t\tt.Fatal(\"unknown extension\")\n+\t\t\t}\n+\t\t\tif Converters[extMap[ext]] == nil {\n+\t\t\t\tt.Fatalf(\"Converters[%q] == nil\", extMap[ext])\n+\t\t\t}\n+\t\t\tdata, err := ioutil.ReadFile(test)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tout, err := Converters[extMap[ext]](test, data)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\twant, err := ioutil.ReadFile(test[:len(test)-len(ext)] + \".out\")\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t}\n+\t\t\tvar buf bytes.Buffer\n+\t\t\tfor _, r := range out.Require {\n+\t\t\t\tfmt.Fprintf(&buf, \"%s %s\\n\", r.Mod.Path, r.Mod.Version)\n+\t\t\t}\n+\t\t\tif !bytes.Equal(buf.Bytes(), want) {\n+\t\t\t\tt.Errorf(\"have:\\n%s\\nwant:\\n%s\", buf.Bytes(), want)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"}, {"sha": "221c8acdfd833fe9818d9bd5039b39f28122ebd1", "filename": "libgo/go/cmd/go/internal/modconv/testdata/cockroach.glock", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fcockroach.glock", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fcockroach.glock", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fcockroach.glock?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,41 @@\n+cmd github.com/cockroachdb/c-protobuf/cmd/protoc\n+cmd github.com/cockroachdb/yacc\n+cmd github.com/gogo/protobuf/protoc-gen-gogo\n+cmd github.com/golang/lint/golint\n+cmd github.com/jteeuwen/go-bindata/go-bindata\n+cmd github.com/kisielk/errcheck\n+cmd github.com/robfig/glock\n+cmd github.com/tebeka/go2xunit\n+cmd golang.org/x/tools/cmd/goimports\n+cmd golang.org/x/tools/cmd/stringer\n+github.com/agtorre/gocolorize f42b554bf7f006936130c9bb4f971afd2d87f671\n+github.com/biogo/store e1f74b3c58befe661feed7fa4cf52436de753128\n+github.com/cockroachdb/c-lz4 6e71f140a365017bbe0904710007f8725fd3f809\n+github.com/cockroachdb/c-protobuf 0f9ab7b988ca7474cf76b9a961ab03c0552abcb3\n+github.com/cockroachdb/c-rocksdb 7fc876fe79b96de0e25069c9ae27e6444637bd54\n+github.com/cockroachdb/c-snappy 618733f9e5bab8463b9049117a335a7a1bfc9fd5\n+github.com/cockroachdb/yacc 572e006f8e6b0061ebda949d13744f5108389514\n+github.com/coreos/etcd 18ecc297bc913bed6fc093d66b1fa22020dba7dc\n+github.com/docker/docker 7374852be9def787921aea2ca831771982badecf\n+github.com/elazarl/go-bindata-assetfs 3dcc96556217539f50599357fb481ac0dc7439b9\n+github.com/gogo/protobuf 98e73e511a62a9c232152f94999112c80142a813\n+github.com/golang/lint 7b7f4364ff76043e6c3610281525fabc0d90f0e4\n+github.com/google/btree cc6329d4279e3f025a53a83c397d2339b5705c45\n+github.com/inconshreveable/mousetrap 76626ae9c91c4f2a10f34cad8ce83ea42c93bb75\n+github.com/jteeuwen/go-bindata dce55d09e24ac40a6e725c8420902b86554f8046\n+github.com/julienschmidt/httprouter 6aacfd5ab513e34f7e64ea9627ab9670371b34e7\n+github.com/kisielk/errcheck 50b84cf7fa18ee2985b8c63ba3de5edd604b9259\n+github.com/kisielk/gotool d678387370a2eb9b5b0a33218bc8c9d8de15b6be\n+github.com/lib/pq a8d8d01c4f91602f876bf5aa210274e8203a6b45\n+github.com/montanaflynn/stats 44fb56da2a2a67d394dec0e18a82dd316f192529\n+github.com/peterh/liner 1bb0d1c1a25ed393d8feb09bab039b2b1b1fbced\n+github.com/robfig/glock cb3c3ec56de988289cab7bbd284eddc04dfee6c9\n+github.com/samalba/dockerclient 12570e600d71374233e5056ba315f657ced496c7\n+github.com/spf13/cobra 66816bcd0378e248c613e3c443c020f544c28804\n+github.com/spf13/pflag 67cbc198fd11dab704b214c1e629a97af392c085\n+github.com/tebeka/go2xunit d45000af2242dd0e7b8c7b07d82a1068adc5fd40\n+golang.org/x/crypto cc04154d65fb9296747569b107cfd05380b1ea3e\n+golang.org/x/net 8bfde94a845cb31000de3266ac83edbda58dab09\n+golang.org/x/text d4cc1b1e16b49d6dafc4982403b40fe89c512cd5\n+golang.org/x/tools d02228d1857b9f49cd0252788516ff5584266eb6\n+gopkg.in/yaml.v1 9f9df34309c04878acc86042b16630b0f696e1de"}, {"sha": "30cdbb7bf2972c62803b8d78bb376956e97c5228", "filename": "libgo/go/cmd/go/internal/modconv/testdata/cockroach.out", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fcockroach.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fcockroach.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fcockroach.out?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,31 @@\n+github.com/agtorre/gocolorize f42b554bf7f006936130c9bb4f971afd2d87f671\n+github.com/biogo/store e1f74b3c58befe661feed7fa4cf52436de753128\n+github.com/cockroachdb/c-lz4 6e71f140a365017bbe0904710007f8725fd3f809\n+github.com/cockroachdb/c-protobuf 0f9ab7b988ca7474cf76b9a961ab03c0552abcb3\n+github.com/cockroachdb/c-rocksdb 7fc876fe79b96de0e25069c9ae27e6444637bd54\n+github.com/cockroachdb/c-snappy 618733f9e5bab8463b9049117a335a7a1bfc9fd5\n+github.com/cockroachdb/yacc 572e006f8e6b0061ebda949d13744f5108389514\n+github.com/coreos/etcd 18ecc297bc913bed6fc093d66b1fa22020dba7dc\n+github.com/docker/docker 7374852be9def787921aea2ca831771982badecf\n+github.com/elazarl/go-bindata-assetfs 3dcc96556217539f50599357fb481ac0dc7439b9\n+github.com/gogo/protobuf 98e73e511a62a9c232152f94999112c80142a813\n+github.com/golang/lint 7b7f4364ff76043e6c3610281525fabc0d90f0e4\n+github.com/google/btree cc6329d4279e3f025a53a83c397d2339b5705c45\n+github.com/inconshreveable/mousetrap 76626ae9c91c4f2a10f34cad8ce83ea42c93bb75\n+github.com/jteeuwen/go-bindata dce55d09e24ac40a6e725c8420902b86554f8046\n+github.com/julienschmidt/httprouter 6aacfd5ab513e34f7e64ea9627ab9670371b34e7\n+github.com/kisielk/errcheck 50b84cf7fa18ee2985b8c63ba3de5edd604b9259\n+github.com/kisielk/gotool d678387370a2eb9b5b0a33218bc8c9d8de15b6be\n+github.com/lib/pq a8d8d01c4f91602f876bf5aa210274e8203a6b45\n+github.com/montanaflynn/stats 44fb56da2a2a67d394dec0e18a82dd316f192529\n+github.com/peterh/liner 1bb0d1c1a25ed393d8feb09bab039b2b1b1fbced\n+github.com/robfig/glock cb3c3ec56de988289cab7bbd284eddc04dfee6c9\n+github.com/samalba/dockerclient 12570e600d71374233e5056ba315f657ced496c7\n+github.com/spf13/cobra 66816bcd0378e248c613e3c443c020f544c28804\n+github.com/spf13/pflag 67cbc198fd11dab704b214c1e629a97af392c085\n+github.com/tebeka/go2xunit d45000af2242dd0e7b8c7b07d82a1068adc5fd40\n+golang.org/x/crypto cc04154d65fb9296747569b107cfd05380b1ea3e\n+golang.org/x/net 8bfde94a845cb31000de3266ac83edbda58dab09\n+golang.org/x/text d4cc1b1e16b49d6dafc4982403b40fe89c512cd5\n+golang.org/x/tools d02228d1857b9f49cd0252788516ff5584266eb6\n+gopkg.in/yaml.v1 9f9df34309c04878acc86042b16630b0f696e1de"}, {"sha": "a551002a04962eb58a4f5ccec293059fd4279e59", "filename": "libgo/go/cmd/go/internal/modconv/testdata/dockermachine.godeps", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockermachine.godeps", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockermachine.godeps", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockermachine.godeps?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,159 @@\n+{\n+\t\"ImportPath\": \"github.com/docker/machine\",\n+\t\"GoVersion\": \"go1.4.2\",\n+\t\"Deps\": [\n+\t\t{\n+\t\t\t\"ImportPath\": \"code.google.com/p/goauth2/oauth\",\n+\t\t\t\"Comment\": \"weekly-56\",\n+\t\t\t\"Rev\": \"afe77d958c701557ec5dc56f6936fcc194d15520\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/MSOpenTech/azure-sdk-for-go\",\n+\t\t\t\"Comment\": \"v1.1-17-g515f3ec\",\n+\t\t\t\"Rev\": \"515f3ec74ce6a5b31e934cefae997c97bd0a1b1e\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/cenkalti/backoff\",\n+\t\t\t\"Rev\": \"9831e1e25c874e0a0601b6dc43641071414eec7a\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/codegangsta/cli\",\n+\t\t\t\"Comment\": \"1.2.0-64-ge1712f3\",\n+\t\t\t\"Rev\": \"e1712f381785e32046927f64a7c86fe569203196\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/digitalocean/godo\",\n+\t\t\t\"Comment\": \"v0.5.0\",\n+\t\t\t\"Rev\": \"5478aae80694de1d2d0e02c386bbedd201266234\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/dockerversion\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/engine\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/archive\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/fileutils\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/ioutils\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/mflag\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/parsers\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/pools\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/promise\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/system\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/term\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/timeutils\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/units\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/pkg/version\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/docker/vendor/src/code.google.com/p/go/src/pkg/archive/tar\",\n+\t\t\t\"Comment\": \"v1.5.0\",\n+\t\t\t\"Rev\": \"a8a31eff10544860d2188dddabdee4d727545796\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/docker/libtrust\",\n+\t\t\t\"Rev\": \"c54fbb67c1f1e68d7d6f8d2ad7c9360404616a41\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/google/go-querystring/query\",\n+\t\t\t\"Rev\": \"30f7a39f4a218feb5325f3aebc60c32a572a8274\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/mitchellh/mapstructure\",\n+\t\t\t\"Rev\": \"740c764bc6149d3f1806231418adb9f52c11bcbf\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/rackspace/gophercloud\",\n+\t\t\t\"Comment\": \"v1.0.0-558-ce0f487\",\n+\t\t\t\"Rev\": \"ce0f487f6747ab43c4e4404722df25349385bebd\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/skarademir/naturalsort\",\n+\t\t\t\"Rev\": \"983d4d86054d80f91fd04dd62ec52c1d078ce403\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/smartystreets/go-aws-auth\",\n+\t\t\t\"Rev\": \"1f0db8c0ee6362470abe06a94e3385927ed72a4b\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/stretchr/testify/assert\",\n+\t\t\t\"Rev\": \"e4ec8152c15fc46bd5056ce65997a07c7d415325\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/pyr/egoscale/src/egoscale\",\n+\t\t\t\"Rev\": \"bbaa67324aeeacc90430c1fe0a9c620d3929512e\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/tent/http-link-go\",\n+\t\t\t\"Rev\": \"ac974c61c2f990f4115b119354b5e0b47550e888\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"github.com/vmware/govcloudair\",\n+\t\t\t\"Comment\": \"v0.0.2\",\n+\t\t\t\"Rev\": \"66a23eaabc61518f91769939ff541886fe1dceef\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"golang.org/x/crypto/ssh\",\n+\t\t\t\"Rev\": \"1fbbd62cfec66bd39d91e97749579579d4d3037e\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"google.golang.org/api/compute/v1\",\n+\t\t\t\"Rev\": \"aa91ac681e18e52b1a0dfe29b9d8354e88c0dcf5\"\n+\t\t},\n+\t\t{\n+\t\t\t\"ImportPath\": \"google.golang.org/api/googleapi\",\n+\t\t\t\"Rev\": \"aa91ac681e18e52b1a0dfe29b9d8354e88c0dcf5\"\n+\t\t}\n+\t]\n+}"}, {"sha": "0b39ceaccbbe2b3b05f01f96f788fe00f39d6e5c", "filename": "libgo/go/cmd/go/internal/modconv/testdata/dockermachine.out", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockermachine.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockermachine.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockermachine.out?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,33 @@\n+code.google.com/p/goauth2/oauth afe77d958c701557ec5dc56f6936fcc194d15520\n+github.com/MSOpenTech/azure-sdk-for-go 515f3ec74ce6a5b31e934cefae997c97bd0a1b1e\n+github.com/cenkalti/backoff 9831e1e25c874e0a0601b6dc43641071414eec7a\n+github.com/codegangsta/cli e1712f381785e32046927f64a7c86fe569203196\n+github.com/digitalocean/godo 5478aae80694de1d2d0e02c386bbedd201266234\n+github.com/docker/docker/dockerversion a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/engine a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/archive a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/fileutils a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/ioutils a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/mflag a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/parsers a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/pools a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/promise a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/system a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/term a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/timeutils a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/units a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/pkg/version a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/docker/vendor/src/code.google.com/p/go/src/pkg/archive/tar a8a31eff10544860d2188dddabdee4d727545796\n+github.com/docker/libtrust c54fbb67c1f1e68d7d6f8d2ad7c9360404616a41\n+github.com/google/go-querystring/query 30f7a39f4a218feb5325f3aebc60c32a572a8274\n+github.com/mitchellh/mapstructure 740c764bc6149d3f1806231418adb9f52c11bcbf\n+github.com/rackspace/gophercloud ce0f487f6747ab43c4e4404722df25349385bebd\n+github.com/skarademir/naturalsort 983d4d86054d80f91fd04dd62ec52c1d078ce403\n+github.com/smartystreets/go-aws-auth 1f0db8c0ee6362470abe06a94e3385927ed72a4b\n+github.com/stretchr/testify/assert e4ec8152c15fc46bd5056ce65997a07c7d415325\n+github.com/pyr/egoscale/src/egoscale bbaa67324aeeacc90430c1fe0a9c620d3929512e\n+github.com/tent/http-link-go ac974c61c2f990f4115b119354b5e0b47550e888\n+github.com/vmware/govcloudair 66a23eaabc61518f91769939ff541886fe1dceef\n+golang.org/x/crypto/ssh 1fbbd62cfec66bd39d91e97749579579d4d3037e\n+google.golang.org/api/compute/v1 aa91ac681e18e52b1a0dfe29b9d8354e88c0dcf5\n+google.golang.org/api/googleapi aa91ac681e18e52b1a0dfe29b9d8354e88c0dcf5"}, {"sha": "5ec765a4c63cc4df50252c2abeaf40af422bcc8d", "filename": "libgo/go/cmd/go/internal/modconv/testdata/dockerman.glide", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockerman.glide", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockerman.glide", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockerman.glide?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,52 @@\n+hash: ead3ea293a6143fe41069ebec814bf197d8c43a92cc7666b1f7e21a419b46feb\n+updated: 2016-06-20T21:53:35.420817456Z\n+imports:\n+- name: github.com/BurntSushi/toml\n+  version: f0aeabca5a127c4078abb8c8d64298b147264b55\n+- name: github.com/cpuguy83/go-md2man\n+  version: a65d4d2de4d5f7c74868dfa9b202a3c8be315aaa\n+  subpackages:\n+  - md2man\n+- name: github.com/fsnotify/fsnotify\n+  version: 30411dbcefb7a1da7e84f75530ad3abe4011b4f8\n+- name: github.com/hashicorp/hcl\n+  version: da486364306ed66c218be9b7953e19173447c18b\n+  subpackages:\n+  - hcl/ast\n+  - hcl/parser\n+  - hcl/token\n+  - json/parser\n+  - hcl/scanner\n+  - hcl/strconv\n+  - json/scanner\n+  - json/token\n+- name: github.com/inconshreveable/mousetrap\n+  version: 76626ae9c91c4f2a10f34cad8ce83ea42c93bb75\n+- name: github.com/magiconair/properties\n+  version: c265cfa48dda6474e208715ca93e987829f572f8\n+- name: github.com/mitchellh/mapstructure\n+  version: d2dd0262208475919e1a362f675cfc0e7c10e905\n+- name: github.com/russross/blackfriday\n+  version: 1d6b8e9301e720b08a8938b8c25c018285885438\n+- name: github.com/shurcooL/sanitized_anchor_name\n+  version: 10ef21a441db47d8b13ebcc5fd2310f636973c77\n+- name: github.com/spf13/cast\n+  version: 27b586b42e29bec072fe7379259cc719e1289da6\n+- name: github.com/spf13/jwalterweatherman\n+  version: 33c24e77fb80341fe7130ee7c594256ff08ccc46\n+- name: github.com/spf13/pflag\n+  version: dabebe21bf790f782ea4c7bbd2efc430de182afd\n+- name: github.com/spf13/viper\n+  version: c1ccc378a054ea8d4e38d8c67f6938d4760b53dd\n+- name: golang.org/x/sys\n+  version: 62bee037599929a6e9146f29d10dd5208c43507d\n+  subpackages:\n+  - unix\n+- name: gopkg.in/yaml.v2\n+  version: a83829b6f1293c91addabc89d0571c246397bbf4\n+- name: github.com/spf13/cobra\n+  repo: https://github.com/dnephin/cobra\n+  subpackages:\n+  - doc\n+  version: v1.3\n+devImports: []"}, {"sha": "5e6370b31c32e2513777627634b3d6b6493f9005", "filename": "libgo/go/cmd/go/internal/modconv/testdata/dockerman.out", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockerman.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockerman.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fdockerman.out?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,16 @@\n+github.com/BurntSushi/toml f0aeabca5a127c4078abb8c8d64298b147264b55\n+github.com/cpuguy83/go-md2man a65d4d2de4d5f7c74868dfa9b202a3c8be315aaa\n+github.com/fsnotify/fsnotify 30411dbcefb7a1da7e84f75530ad3abe4011b4f8\n+github.com/hashicorp/hcl da486364306ed66c218be9b7953e19173447c18b\n+github.com/inconshreveable/mousetrap 76626ae9c91c4f2a10f34cad8ce83ea42c93bb75\n+github.com/magiconair/properties c265cfa48dda6474e208715ca93e987829f572f8\n+github.com/mitchellh/mapstructure d2dd0262208475919e1a362f675cfc0e7c10e905\n+github.com/russross/blackfriday 1d6b8e9301e720b08a8938b8c25c018285885438\n+github.com/shurcooL/sanitized_anchor_name 10ef21a441db47d8b13ebcc5fd2310f636973c77\n+github.com/spf13/cast 27b586b42e29bec072fe7379259cc719e1289da6\n+github.com/spf13/jwalterweatherman 33c24e77fb80341fe7130ee7c594256ff08ccc46\n+github.com/spf13/pflag dabebe21bf790f782ea4c7bbd2efc430de182afd\n+github.com/spf13/viper c1ccc378a054ea8d4e38d8c67f6938d4760b53dd\n+golang.org/x/sys 62bee037599929a6e9146f29d10dd5208c43507d\n+gopkg.in/yaml.v2 a83829b6f1293c91addabc89d0571c246397bbf4\n+github.com/spf13/cobra v1.3"}, {"sha": "188c458b3d648cc86621a6456b0e279e3c9e7512", "filename": "libgo/go/cmd/go/internal/modconv/testdata/govmomi.out", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fgovmomi.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fgovmomi.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fgovmomi.out?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,5 @@\n+github.com/davecgh/go-xdr/xdr2 4930550ba2e22f87187498acfd78348b15f4e7a8\n+github.com/google/uuid 6a5e28554805e78ea6141142aba763936c4761c0\n+github.com/kr/pretty 2ee9d7453c02ef7fa518a83ae23644eb8872186a\n+github.com/kr/pty 95d05c1eef33a45bd58676b6ce28d105839b8d0b\n+github.com/vmware/vmw-guestinfo 25eff159a728be87e103a0b8045e08273f4dbec4"}, {"sha": "b89e4ab5eef11361cbce40d43146e52b8eebd3bb", "filename": "libgo/go/cmd/go/internal/modconv/testdata/govmomi.vmanifest", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fgovmomi.vmanifest", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fgovmomi.vmanifest", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fgovmomi.vmanifest?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,46 @@\n+{\n+\t\"version\": 0,\n+\t\"dependencies\": [\n+\t\t{\n+\t\t\t\"importpath\": \"github.com/davecgh/go-xdr/xdr2\",\n+\t\t\t\"repository\": \"https://github.com/rasky/go-xdr\",\n+\t\t\t\"vcs\": \"git\",\n+\t\t\t\"revision\": \"4930550ba2e22f87187498acfd78348b15f4e7a8\",\n+\t\t\t\"branch\": \"improvements\",\n+\t\t\t\"path\": \"/xdr2\",\n+\t\t\t\"notests\": true\n+\t\t},\n+\t\t{\n+\t\t\t\"importpath\": \"github.com/google/uuid\",\n+\t\t\t\"repository\": \"https://github.com/google/uuid\",\n+\t\t\t\"vcs\": \"git\",\n+\t\t\t\"revision\": \"6a5e28554805e78ea6141142aba763936c4761c0\",\n+\t\t\t\"branch\": \"master\",\n+\t\t\t\"notests\": true\n+\t\t},\n+\t\t{\n+\t\t\t\"importpath\": \"github.com/kr/pretty\",\n+\t\t\t\"repository\": \"https://github.com/dougm/pretty\",\n+\t\t\t\"vcs\": \"git\",\n+\t\t\t\"revision\": \"2ee9d7453c02ef7fa518a83ae23644eb8872186a\",\n+\t\t\t\"branch\": \"govmomi\",\n+\t\t\t\"notests\": true\n+\t\t},\n+\t\t{\n+\t\t\t\"importpath\": \"github.com/kr/pty\",\n+\t\t\t\"repository\": \"https://github.com/kr/pty\",\n+\t\t\t\"vcs\": \"git\",\n+\t\t\t\"revision\": \"95d05c1eef33a45bd58676b6ce28d105839b8d0b\",\n+\t\t\t\"branch\": \"master\",\n+\t\t\t\"notests\": true\n+\t\t},\n+\t\t{\n+\t\t\t\"importpath\": \"github.com/vmware/vmw-guestinfo\",\n+\t\t\t\"repository\": \"https://github.com/vmware/vmw-guestinfo\",\n+\t\t\t\"vcs\": \"git\",\n+\t\t\t\"revision\": \"25eff159a728be87e103a0b8045e08273f4dbec4\",\n+\t\t\t\"branch\": \"master\",\n+\t\t\t\"notests\": true\n+\t\t}\n+\t]\n+}"}, {"sha": "c2430b1e26d40eb955fabeadf26e489a835cfa96", "filename": "libgo/go/cmd/go/internal/modconv/testdata/juju.out", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fjuju.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fjuju.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fjuju.out?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,106 @@\n+github.com/Azure/azure-sdk-for-go 902d95d9f311ae585ee98cfd18f418b467d60d5a\n+github.com/Azure/go-autorest 6f40a8acfe03270d792cb8155e2942c09d7cff95\n+github.com/ajstarks/svgo 89e3ac64b5b3e403a5e7c35ea4f98d45db7b4518\n+github.com/altoros/gosigma 31228935eec685587914528585da4eb9b073c76d\n+github.com/beorn7/perks 3ac7bf7a47d159a033b107610db8a1b6575507a4\n+github.com/bmizerany/pat c068ca2f0aacee5ac3681d68e4d0a003b7d1fd2c\n+github.com/coreos/go-systemd 7b2428fec40033549c68f54e26e89e7ca9a9ce31\n+github.com/dgrijalva/jwt-go 01aeca54ebda6e0fbfafd0a524d234159c05ec20\n+github.com/dustin/go-humanize 145fabdb1ab757076a70a886d092a3af27f66f4c\n+github.com/godbus/dbus 32c6cc29c14570de4cf6d7e7737d68fb2d01ad15\n+github.com/golang/protobuf 4bd1920723d7b7c925de087aa32e2187708897f7\n+github.com/google/go-querystring 9235644dd9e52eeae6fa48efd539fdc351a0af53\n+github.com/gorilla/schema 08023a0215e7fc27a9aecd8b8c50913c40019478\n+github.com/gorilla/websocket 804cb600d06b10672f2fbc0a336a7bee507a428e\n+github.com/gosuri/uitable 36ee7e946282a3fb1cfecd476ddc9b35d8847e42\n+github.com/joyent/gocommon ade826b8b54e81a779ccb29d358a45ba24b7809c\n+github.com/joyent/gosdc 2f11feadd2d9891e92296a1077c3e2e56939547d\n+github.com/joyent/gosign 0da0d5f1342065321c97812b1f4ac0c2b0bab56c\n+github.com/juju/ansiterm b99631de12cf04a906c1d4e4ec54fb86eae5863d\n+github.com/juju/blobstore 06056004b3d7b54bbb7984d830c537bad00fec21\n+github.com/juju/bundlechanges 7725027b95e0d54635e0fb11efc2debdcdf19f75\n+github.com/juju/cmd 9425a576247f348b9b40afe3b60085de63470de5\n+github.com/juju/description d3742c23561884cd7d759ef7142340af1d22cab0\n+github.com/juju/errors 1b5e39b83d1835fa480e0c2ddefb040ee82d58b3\n+github.com/juju/gnuflag 4e76c56581859c14d9d87e1ddbe29e1c0f10195f\n+github.com/juju/go4 40d72ab9641a2a8c36a9c46a51e28367115c8e59\n+github.com/juju/gojsonpointer afe8b77aa08f272b49e01b82de78510c11f61500\n+github.com/juju/gojsonreference f0d24ac5ee330baa21721cdff56d45e4ee42628e\n+github.com/juju/gojsonschema e1ad140384f254c82f89450d9a7c8dd38a632838\n+github.com/juju/gomaasapi cfbc096bd45f276c17a391efc4db710b60ae3ad7\n+github.com/juju/httpprof 14bf14c307672fd2456bdbf35d19cf0ccd3cf565\n+github.com/juju/httprequest 266fd1e9debf09c037a63f074d099a2da4559ece\n+github.com/juju/idmclient 4dc25171f675da4206b71695d3fd80e519ad05c1\n+github.com/juju/jsonschema a0ef8b74ebcffeeff9fc374854deb4af388f037e\n+github.com/juju/loggo 21bc4c63e8b435779a080e39e592969b7b90b889\n+github.com/juju/mempool 24974d6c264fe5a29716e7d56ea24c4bd904b7cc\n+github.com/juju/mutex 59c26ee163447c5c57f63ff71610d433862013de\n+github.com/juju/persistent-cookiejar 5243747bf8f2d0897f6c7a52799327dc97d585e8\n+github.com/juju/pubsub 9dcaca7eb4340dbf685aa7b3ad4cc4f8691a33d4\n+github.com/juju/replicaset 6b5becf2232ce76656ea765d8d915d41755a1513\n+github.com/juju/retry 62c62032529169c7ec02fa48f93349604c345e1f\n+github.com/juju/rfc ebdbbdb950cd039a531d15cdc2ac2cbd94f068ee\n+github.com/juju/romulus 98d6700423d63971f10ca14afea9ecf2b9b99f0f\n+github.com/juju/schema 075de04f9b7d7580d60a1e12a0b3f50bb18e6998\n+github.com/juju/terms-client 9b925afd677234e4146dde3cb1a11e187cbed64e\n+github.com/juju/testing fce9bc4ebf7a77310c262ac4884e03b778eae06a\n+github.com/juju/txn 28898197906200d603394d8e4ce537436529f1c5\n+github.com/juju/usso 68a59c96c178fbbad65926e7f93db50a2cd14f33\n+github.com/juju/utils 9f8aeb9b09e2d8c769be8317ccfa23f7eec62c26\n+github.com/juju/version 1f41e27e54f21acccf9b2dddae063a782a8a7ceb\n+github.com/juju/webbrowser 54b8c57083b4afb7dc75da7f13e2967b2606a507\n+github.com/juju/xml eb759a627588d35166bc505fceb51b88500e291e\n+github.com/juju/zip f6b1e93fa2e29a1d7d49b566b2b51efb060c982a\n+github.com/julienschmidt/httprouter 77a895ad01ebc98a4dc95d8355bc825ce80a56f6\n+github.com/lestrrat/go-jspointer f4881e611bdbe9fb413a7780721ef8400a1f2341\n+github.com/lestrrat/go-jsref e452c7b5801d1c6494c9e7e0cbc7498c0f88dfd1\n+github.com/lestrrat/go-jsschema b09d7650b822d2ea3dc83d5091a5e2acd8330051\n+github.com/lestrrat/go-jsval b1258a10419fe0693f7b35ad65cd5074bc0ba1e5\n+github.com/lestrrat/go-pdebug 2e6eaaa5717f81bda41d27070d3c966f40a1e75f\n+github.com/lestrrat/go-structinfo f74c056fe41f860aa6264478c664a6fff8a64298\n+github.com/lunixbochs/vtclean 4fbf7632a2c6d3fbdb9931439bdbbeded02cbe36\n+github.com/lxc/lxd 23da0234979fa6299565b91b529a6dbeb42ee36d\n+github.com/masterzen/azure-sdk-for-go ee4f0065d00cd12b542f18f5bc45799e88163b12\n+github.com/masterzen/simplexml 4572e39b1ab9fe03ee513ce6fc7e289e98482190\n+github.com/masterzen/winrm 7a535cd943fccaeed196718896beec3fb51aff41\n+github.com/masterzen/xmlpath 13f4951698adc0fa9c1dda3e275d489a24201161\n+github.com/mattn/go-colorable ed8eb9e318d7a84ce5915b495b7d35e0cfe7b5a8\n+github.com/mattn/go-isatty 66b8e73f3f5cda9f96b69efd03dd3d7fc4a5cdb8\n+github.com/mattn/go-runewidth d96d1bd051f2bd9e7e43d602782b37b93b1b5666\n+github.com/matttproud/golang_protobuf_extensions c12348ce28de40eed0136aa2b644d0ee0650e56c\n+github.com/nu7hatch/gouuid 179d4d0c4d8d407a32af483c2354df1d2c91e6c3\n+github.com/pkg/errors 839d9e913e063e28dfd0e6c7b7512793e0a48be9\n+github.com/prometheus/client_golang 575f371f7862609249a1be4c9145f429fe065e32\n+github.com/prometheus/client_model fa8ad6fec33561be4280a8f0514318c79d7f6cb6\n+github.com/prometheus/common dd586c1c5abb0be59e60f942c22af711a2008cb4\n+github.com/prometheus/procfs abf152e5f3e97f2fafac028d2cc06c1feb87ffa5\n+github.com/rogpeppe/fastuuid 6724a57986aff9bff1a1770e9347036def7c89f6\n+github.com/vmware/govmomi c0c7ce63df7edd78e713257b924c89d9a2dac119\n+golang.org/x/crypto 8e06e8ddd9629eb88639aba897641bff8031f1d3\n+golang.org/x/net ea47fc708ee3e20177f3ca3716217c4ab75942cb\n+golang.org/x/oauth2 11c60b6f71a6ad48ed6f93c65fa4c6f9b1b5b46a\n+golang.org/x/sys 7a6e5648d140666db5d920909e082ca00a87ba2c\n+golang.org/x/text 2910a502d2bf9e43193af9d68ca516529614eed3\n+google.golang.org/api 0d3983fb069cb6651353fc44c5cb604e263f2a93\n+google.golang.org/cloud f20d6dcccb44ed49de45ae3703312cb46e627db1\n+gopkg.in/amz.v3 8c3190dff075bf5442c9eedbf8f8ed6144a099e7\n+gopkg.in/check.v1 4f90aeace3a26ad7021961c297b22c42160c7b25\n+gopkg.in/errgo.v1 442357a80af5c6bf9b6d51ae791a39c3421004f3\n+gopkg.in/goose.v1 ac43167b647feacdd9a1e34ee81e574551bc748d\n+gopkg.in/ini.v1 776aa739ce9373377cd16f526cdf06cb4c89b40f\n+gopkg.in/juju/blobstore.v2 51fa6e26128d74e445c72d3a91af555151cc3654\n+gopkg.in/juju/charm.v6-unstable 83771c4919d6810bce5b7e63f46bea5fbfed0b93\n+gopkg.in/juju/charmrepo.v2-unstable e79aa298df89ea887c9bffec46063c24bfb730f7\n+gopkg.in/juju/charmstore.v5-unstable fd1eef3002fc6b6daff5e97efab6f5056d22dcc7\n+gopkg.in/juju/environschema.v1 7359fc7857abe2b11b5b3e23811a9c64cb6b01e0\n+gopkg.in/juju/jujusvg.v2 d82160011935ef79fc7aca84aba2c6f74700fe75\n+gopkg.in/juju/names.v2 0847c26d322a121e52614f969fb82eae2820c715\n+gopkg.in/juju/worker.v1 6965b9d826717287bb002e02d1fd4d079978083e\n+gopkg.in/macaroon-bakery.v1 469b44e6f1f9479e115c8ae879ef80695be624d5\n+gopkg.in/macaroon.v1 ab3940c6c16510a850e1c2dd628b919f0f3f1464\n+gopkg.in/mgo.v2 f2b6f6c918c452ad107eec89615f074e3bd80e33\n+gopkg.in/natefinch/lumberjack.v2 514cbda263a734ae8caac038dadf05f8f3f9f738\n+gopkg.in/natefinch/npipe.v2 c1b8fa8bdccecb0b8db834ee0b92fdbcfa606dd6\n+gopkg.in/retry.v1 c09f6b86ba4d5d2cf5bdf0665364aec9fd4815db\n+gopkg.in/tomb.v1 dd632973f1e7218eb1089048e0798ec9ae7dceb8\n+gopkg.in/yaml.v2 a3f3340b5840cee44f372bddb5880fcbc419b46a"}, {"sha": "0bddcef81ce09a1a27d9c280eb9376bbdb9ccb8d", "filename": "libgo/go/cmd/go/internal/modconv/testdata/juju.tsv", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fjuju.tsv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fjuju.tsv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fjuju.tsv?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,106 @@\n+github.com/Azure/azure-sdk-for-go\tgit\t902d95d9f311ae585ee98cfd18f418b467d60d5a\t2016-07-20T05:16:58Z\n+github.com/Azure/go-autorest\tgit\t6f40a8acfe03270d792cb8155e2942c09d7cff95\t2016-07-19T23:14:56Z\n+github.com/ajstarks/svgo\tgit\t89e3ac64b5b3e403a5e7c35ea4f98d45db7b4518\t2014-10-04T21:11:59Z\n+github.com/altoros/gosigma\tgit\t31228935eec685587914528585da4eb9b073c76d\t2015-04-08T14:52:32Z\n+github.com/beorn7/perks\tgit\t3ac7bf7a47d159a033b107610db8a1b6575507a4\t2016-02-29T21:34:45Z\n+github.com/bmizerany/pat\tgit\tc068ca2f0aacee5ac3681d68e4d0a003b7d1fd2c\t2016-02-17T10:32:42Z\n+github.com/coreos/go-systemd\tgit\t7b2428fec40033549c68f54e26e89e7ca9a9ce31\t2016-02-02T21:14:25Z\n+github.com/dgrijalva/jwt-go\tgit\t01aeca54ebda6e0fbfafd0a524d234159c05ec20\t2016-07-05T20:30:06Z\n+github.com/dustin/go-humanize\tgit\t145fabdb1ab757076a70a886d092a3af27f66f4c\t2014-12-28T07:11:48Z\n+github.com/godbus/dbus\tgit\t32c6cc29c14570de4cf6d7e7737d68fb2d01ad15\t2016-05-06T22:25:50Z\n+github.com/golang/protobuf\tgit\t4bd1920723d7b7c925de087aa32e2187708897f7\t2016-11-09T07:27:36Z\n+github.com/google/go-querystring\tgit\t9235644dd9e52eeae6fa48efd539fdc351a0af53\t2016-04-01T23:30:42Z\n+github.com/gorilla/schema\tgit\t08023a0215e7fc27a9aecd8b8c50913c40019478\t2016-04-26T23:15:12Z\n+github.com/gorilla/websocket\tgit\t804cb600d06b10672f2fbc0a336a7bee507a428e\t2017-02-14T17:41:18Z\n+github.com/gosuri/uitable\tgit\t36ee7e946282a3fb1cfecd476ddc9b35d8847e42\t2016-04-04T20:39:58Z\n+github.com/joyent/gocommon\tgit\tade826b8b54e81a779ccb29d358a45ba24b7809c\t2016-03-20T19:31:33Z\n+github.com/joyent/gosdc\tgit\t2f11feadd2d9891e92296a1077c3e2e56939547d\t2014-05-24T00:08:15Z\n+github.com/joyent/gosign\tgit\t0da0d5f1342065321c97812b1f4ac0c2b0bab56c\t2014-05-24T00:07:34Z\n+github.com/juju/ansiterm\tgit\tb99631de12cf04a906c1d4e4ec54fb86eae5863d\t2016-09-07T23:45:32Z\n+github.com/juju/blobstore\tgit\t06056004b3d7b54bbb7984d830c537bad00fec21\t2015-07-29T11:18:58Z\n+github.com/juju/bundlechanges\tgit\t7725027b95e0d54635e0fb11efc2debdcdf19f75\t2016-12-15T16:06:52Z\n+github.com/juju/cmd\tgit\t9425a576247f348b9b40afe3b60085de63470de5\t2017-03-20T01:37:09Z\n+github.com/juju/description\tgit\td3742c23561884cd7d759ef7142340af1d22cab0\t2017-03-20T07:46:40Z\n+github.com/juju/errors\tgit\t1b5e39b83d1835fa480e0c2ddefb040ee82d58b3\t2015-09-16T12:56:42Z\n+github.com/juju/gnuflag\tgit\t4e76c56581859c14d9d87e1ddbe29e1c0f10195f\t2016-08-09T16:52:14Z\n+github.com/juju/go4\tgit\t40d72ab9641a2a8c36a9c46a51e28367115c8e59\t2016-02-22T16:32:58Z\n+github.com/juju/gojsonpointer\tgit\tafe8b77aa08f272b49e01b82de78510c11f61500\t2015-02-04T19:46:29Z\n+github.com/juju/gojsonreference\tgit\tf0d24ac5ee330baa21721cdff56d45e4ee42628e\t2015-02-04T19:46:33Z\n+github.com/juju/gojsonschema\tgit\te1ad140384f254c82f89450d9a7c8dd38a632838\t2015-03-12T17:00:16Z\n+github.com/juju/gomaasapi\tgit\tcfbc096bd45f276c17a391efc4db710b60ae3ad7\t2017-02-27T07:51:07Z\n+github.com/juju/httpprof\tgit\t14bf14c307672fd2456bdbf35d19cf0ccd3cf565\t2014-12-17T16:00:36Z\n+github.com/juju/httprequest\tgit\t266fd1e9debf09c037a63f074d099a2da4559ece\t2016-10-06T15:09:09Z\n+github.com/juju/idmclient\tgit\t4dc25171f675da4206b71695d3fd80e519ad05c1\t2017-02-09T16:27:49Z\n+github.com/juju/jsonschema\tgit\ta0ef8b74ebcffeeff9fc374854deb4af388f037e\t2016-11-02T18:19:19Z\n+github.com/juju/loggo\tgit\t21bc4c63e8b435779a080e39e592969b7b90b889\t2017-02-22T12:20:47Z\n+github.com/juju/mempool\tgit\t24974d6c264fe5a29716e7d56ea24c4bd904b7cc\t2016-02-05T10:49:27Z\n+github.com/juju/mutex\tgit\t59c26ee163447c5c57f63ff71610d433862013de\t2016-06-17T01:09:07Z\n+github.com/juju/persistent-cookiejar\tgit\t5243747bf8f2d0897f6c7a52799327dc97d585e8\t2016-11-15T13:33:28Z\n+github.com/juju/pubsub\tgit\t9dcaca7eb4340dbf685aa7b3ad4cc4f8691a33d4\t2016-07-28T03:00:34Z\n+github.com/juju/replicaset\tgit\t6b5becf2232ce76656ea765d8d915d41755a1513\t2016-11-25T16:08:49Z\n+github.com/juju/retry\tgit\t62c62032529169c7ec02fa48f93349604c345e1f\t2015-10-29T02:48:21Z\n+github.com/juju/rfc\tgit\tebdbbdb950cd039a531d15cdc2ac2cbd94f068ee\t2016-07-11T02:42:13Z\n+github.com/juju/romulus\tgit\t98d6700423d63971f10ca14afea9ecf2b9b99f0f\t2017-01-23T14:29:29Z\n+github.com/juju/schema\tgit\t075de04f9b7d7580d60a1e12a0b3f50bb18e6998\t2016-04-20T04:42:03Z\n+github.com/juju/terms-client\tgit\t9b925afd677234e4146dde3cb1a11e187cbed64e\t2016-08-09T13:19:00Z\n+github.com/juju/testing\tgit\tfce9bc4ebf7a77310c262ac4884e03b778eae06a\t2017-02-22T09:01:19Z\n+github.com/juju/txn\tgit\t28898197906200d603394d8e4ce537436529f1c5\t2016-11-16T04:07:55Z\n+github.com/juju/usso\tgit\t68a59c96c178fbbad65926e7f93db50a2cd14f33\t2016-04-01T10:44:24Z\n+github.com/juju/utils\tgit\t9f8aeb9b09e2d8c769be8317ccfa23f7eec62c26\t2017-02-15T08:19:00Z\n+github.com/juju/version\tgit\t1f41e27e54f21acccf9b2dddae063a782a8a7ceb\t2016-10-31T05:19:06Z\n+github.com/juju/webbrowser\tgit\t54b8c57083b4afb7dc75da7f13e2967b2606a507\t2016-03-09T14:36:29Z\n+github.com/juju/xml\tgit\teb759a627588d35166bc505fceb51b88500e291e\t2015-04-13T13:11:21Z\n+github.com/juju/zip\tgit\tf6b1e93fa2e29a1d7d49b566b2b51efb060c982a\t2016-02-05T10:52:21Z\n+github.com/julienschmidt/httprouter\tgit\t77a895ad01ebc98a4dc95d8355bc825ce80a56f6\t2015-10-13T22:55:20Z\n+github.com/lestrrat/go-jspointer\tgit\tf4881e611bdbe9fb413a7780721ef8400a1f2341\t2016-02-29T02:13:54Z\n+github.com/lestrrat/go-jsref\tgit\te452c7b5801d1c6494c9e7e0cbc7498c0f88dfd1\t2016-06-01T01:32:40Z\n+github.com/lestrrat/go-jsschema\tgit\tb09d7650b822d2ea3dc83d5091a5e2acd8330051\t2016-09-03T13:19:57Z\n+github.com/lestrrat/go-jsval\tgit\tb1258a10419fe0693f7b35ad65cd5074bc0ba1e5\t2016-10-12T04:57:17Z\n+github.com/lestrrat/go-pdebug\tgit\t2e6eaaa5717f81bda41d27070d3c966f40a1e75f\t2016-08-17T06:33:33Z\n+github.com/lestrrat/go-structinfo\tgit\tf74c056fe41f860aa6264478c664a6fff8a64298\t2016-03-08T13:11:05Z\n+github.com/lunixbochs/vtclean\tgit\t4fbf7632a2c6d3fbdb9931439bdbbeded02cbe36\t2016-01-25T03:51:06Z\n+github.com/lxc/lxd\tgit\t23da0234979fa6299565b91b529a6dbeb42ee36d\t2017-02-16T05:29:42Z\n+github.com/masterzen/azure-sdk-for-go\tgit\tee4f0065d00cd12b542f18f5bc45799e88163b12\t2016-10-14T13:56:28Z\n+github.com/masterzen/simplexml\tgit\t4572e39b1ab9fe03ee513ce6fc7e289e98482190\t2016-06-08T18:30:07Z\n+github.com/masterzen/winrm\tgit\t7a535cd943fccaeed196718896beec3fb51aff41\t2016-10-14T15:10:40Z\n+github.com/masterzen/xmlpath\tgit\t13f4951698adc0fa9c1dda3e275d489a24201161\t2014-02-18T18:59:01Z\n+github.com/mattn/go-colorable\tgit\ted8eb9e318d7a84ce5915b495b7d35e0cfe7b5a8\t2016-07-31T23:54:17Z\n+github.com/mattn/go-isatty\tgit\t66b8e73f3f5cda9f96b69efd03dd3d7fc4a5cdb8\t2016-08-06T12:27:52Z\n+github.com/mattn/go-runewidth\tgit\td96d1bd051f2bd9e7e43d602782b37b93b1b5666\t2015-11-18T07:21:59Z\n+github.com/matttproud/golang_protobuf_extensions\tgit\tc12348ce28de40eed0136aa2b644d0ee0650e56c\t2016-04-24T11:30:07Z\n+github.com/nu7hatch/gouuid\tgit\t179d4d0c4d8d407a32af483c2354df1d2c91e6c3\t2013-12-21T20:05:32Z\n+github.com/pkg/errors\tgit\t839d9e913e063e28dfd0e6c7b7512793e0a48be9\t2016-10-02T05:25:12Z\n+github.com/prometheus/client_golang\tgit\t575f371f7862609249a1be4c9145f429fe065e32\t2016-11-24T15:57:32Z\n+github.com/prometheus/client_model\tgit\tfa8ad6fec33561be4280a8f0514318c79d7f6cb6\t2015-02-12T10:17:44Z\n+github.com/prometheus/common\tgit\tdd586c1c5abb0be59e60f942c22af711a2008cb4\t2016-05-03T22:05:32Z\n+github.com/prometheus/procfs\tgit\tabf152e5f3e97f2fafac028d2cc06c1feb87ffa5\t2016-04-11T19:08:41Z\n+github.com/rogpeppe/fastuuid\tgit\t6724a57986aff9bff1a1770e9347036def7c89f6\t2015-01-06T09:32:20Z\n+github.com/vmware/govmomi\tgit\tc0c7ce63df7edd78e713257b924c89d9a2dac119\t2016-06-30T15:37:42Z\n+golang.org/x/crypto\tgit\t8e06e8ddd9629eb88639aba897641bff8031f1d3\t2016-09-22T17:06:29Z\n+golang.org/x/net\tgit\tea47fc708ee3e20177f3ca3716217c4ab75942cb\t2015-08-29T23:03:18Z\n+golang.org/x/oauth2\tgit\t11c60b6f71a6ad48ed6f93c65fa4c6f9b1b5b46a\t2015-03-25T02:00:22Z\n+golang.org/x/sys\tgit\t7a6e5648d140666db5d920909e082ca00a87ba2c\t2017-02-01T05:12:45Z\n+golang.org/x/text\tgit\t2910a502d2bf9e43193af9d68ca516529614eed3\t2016-07-26T16:48:57Z\n+google.golang.org/api\tgit\t0d3983fb069cb6651353fc44c5cb604e263f2a93\t2014-12-10T23:51:26Z\n+google.golang.org/cloud\tgit\tf20d6dcccb44ed49de45ae3703312cb46e627db1\t2015-03-19T22:36:35Z\n+gopkg.in/amz.v3\tgit\t8c3190dff075bf5442c9eedbf8f8ed6144a099e7\t2016-12-15T13:08:49Z\n+gopkg.in/check.v1\tgit\t4f90aeace3a26ad7021961c297b22c42160c7b25\t2016-01-05T16:49:36Z\n+gopkg.in/errgo.v1\tgit\t442357a80af5c6bf9b6d51ae791a39c3421004f3\t2016-12-22T12:58:16Z\n+gopkg.in/goose.v1\tgit\tac43167b647feacdd9a1e34ee81e574551bc748d\t2017-02-15T01:56:23Z\n+gopkg.in/ini.v1\tgit\t776aa739ce9373377cd16f526cdf06cb4c89b40f\t2016-02-22T23:24:41Z\n+gopkg.in/juju/blobstore.v2\tgit\t51fa6e26128d74e445c72d3a91af555151cc3654\t2016-01-25T02:37:03Z\n+gopkg.in/juju/charm.v6-unstable\tgit\t83771c4919d6810bce5b7e63f46bea5fbfed0b93\t2016-10-03T20:31:18Z\n+gopkg.in/juju/charmrepo.v2-unstable\tgit\te79aa298df89ea887c9bffec46063c24bfb730f7\t2016-11-17T15:25:28Z\n+gopkg.in/juju/charmstore.v5-unstable\tgit\tfd1eef3002fc6b6daff5e97efab6f5056d22dcc7\t2016-09-16T10:09:07Z\n+gopkg.in/juju/environschema.v1\tgit\t7359fc7857abe2b11b5b3e23811a9c64cb6b01e0\t2015-11-04T11:58:10Z\n+gopkg.in/juju/jujusvg.v2\tgit\td82160011935ef79fc7aca84aba2c6f74700fe75\t2016-06-09T10:52:15Z\n+gopkg.in/juju/names.v2\tgit\t0847c26d322a121e52614f969fb82eae2820c715\t2016-11-02T13:43:03Z\n+gopkg.in/juju/worker.v1\tgit\t6965b9d826717287bb002e02d1fd4d079978083e\t2017-03-08T00:24:58Z\n+gopkg.in/macaroon-bakery.v1\tgit\t469b44e6f1f9479e115c8ae879ef80695be624d5\t2016-06-22T12:14:21Z\n+gopkg.in/macaroon.v1\tgit\tab3940c6c16510a850e1c2dd628b919f0f3f1464\t2015-01-21T11:42:31Z\n+gopkg.in/mgo.v2\tgit\tf2b6f6c918c452ad107eec89615f074e3bd80e33\t2016-08-18T01:52:18Z\n+gopkg.in/natefinch/lumberjack.v2\tgit\t514cbda263a734ae8caac038dadf05f8f3f9f738\t2016-01-25T11:17:49Z\n+gopkg.in/natefinch/npipe.v2\tgit\tc1b8fa8bdccecb0b8db834ee0b92fdbcfa606dd6\t2016-06-21T03:49:01Z\n+gopkg.in/retry.v1\tgit\tc09f6b86ba4d5d2cf5bdf0665364aec9fd4815db\t2016-10-25T18:14:30Z\n+gopkg.in/tomb.v1\tgit\tdd632973f1e7218eb1089048e0798ec9ae7dceb8\t2014-10-24T13:56:13Z\n+gopkg.in/yaml.v2\tgit\ta3f3340b5840cee44f372bddb5880fcbc419b46a\t2017-02-08T14:18:51Z"}, {"sha": "2cb2e056a8331415a74d4ba7b63e19760d5d38d5", "filename": "libgo/go/cmd/go/internal/modconv/testdata/moby.out", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fmoby.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fmoby.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fmoby.out?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,105 @@\n+github.com/Azure/go-ansiterm d6e3b3328b783f23731bc4d058875b0371ff8109\n+github.com/Microsoft/hcsshim v0.6.5\n+github.com/Microsoft/go-winio v0.4.5\n+github.com/davecgh/go-spew 346938d642f2ec3594ed81d874461961cd0faa76\n+github.com/docker/libtrust 9cbd2a1374f46905c68a4eb3694a130610adc62a\n+github.com/go-check/check 4ed411733c5785b40214c70bce814c3a3a689609\n+github.com/gorilla/context v1.1\n+github.com/gorilla/mux v1.1\n+github.com/Microsoft/opengcs v0.3.4\n+github.com/kr/pty 5cf931ef8f\n+github.com/mattn/go-shellwords v1.0.3\n+github.com/sirupsen/logrus v1.0.3\n+github.com/tchap/go-patricia v2.2.6\n+github.com/vdemeester/shakers 24d7f1d6a71aa5d9cbe7390e4afb66b7eef9e1b3\n+golang.org/x/net 7dcfb8076726a3fdd9353b6b8a1f1b6be6811bd6\n+golang.org/x/sys 07c182904dbd53199946ba614a412c61d3c548f5\n+github.com/docker/go-units 9e638d38cf6977a37a8ea0078f3ee75a7cdb2dd1\n+github.com/docker/go-connections 3ede32e2033de7505e6500d6c868c2b9ed9f169d\n+golang.org/x/text f72d8390a633d5dfb0cc84043294db9f6c935756\n+github.com/stretchr/testify 4d4bfba8f1d1027c4fdbe371823030df51419987\n+github.com/pmezard/go-difflib v1.0.0\n+github.com/gotestyourself/gotestyourself v1.1.0\n+github.com/RackSec/srslog 456df3a81436d29ba874f3590eeeee25d666f8a5\n+github.com/imdario/mergo 0.2.1\n+golang.org/x/sync de49d9dcd27d4f764488181bea099dfe6179bcf0\n+github.com/containerd/continuity 22694c680ee48fb8f50015b44618517e2bde77e8\n+github.com/moby/buildkit aaff9d591ef128560018433fe61beb802e149de8\n+github.com/tonistiigi/fsutil dea3a0da73aee887fc02142d995be764106ac5e2\n+github.com/docker/libnetwork 68f1039f172434709a4550fe92e3e058406c74ce\n+github.com/docker/go-events 9461782956ad83b30282bf90e31fa6a70c255ba9\n+github.com/armon/go-radix e39d623f12e8e41c7b5529e9a9dd67a1e2261f80\n+github.com/armon/go-metrics eb0af217e5e9747e41dd5303755356b62d28e3ec\n+github.com/hashicorp/go-msgpack 71c2886f5a673a35f909803f38ece5810165097b\n+github.com/hashicorp/memberlist v0.1.0\n+github.com/sean-/seed e2103e2c35297fb7e17febb81e49b312087a2372\n+github.com/hashicorp/go-sockaddr acd314c5781ea706c710d9ea70069fd2e110d61d\n+github.com/hashicorp/go-multierror fcdddc395df1ddf4247c69bd436e84cfa0733f7e\n+github.com/hashicorp/serf 598c54895cc5a7b1a24a398d635e8c0ea0959870\n+github.com/docker/libkv 1d8431073ae03cdaedb198a89722f3aab6d418ef\n+github.com/vishvananda/netns 604eaf189ee867d8c147fafc28def2394e878d25\n+github.com/vishvananda/netlink bd6d5de5ccef2d66b0a26177928d0d8895d7f969\n+github.com/BurntSushi/toml f706d00e3de6abe700c994cdd545a1a4915af060\n+github.com/samuel/go-zookeeper d0e0d8e11f318e000a8cc434616d69e329edc374\n+github.com/deckarep/golang-set ef32fa3046d9f249d399f98ebaf9be944430fd1d\n+github.com/coreos/etcd v3.2.1\n+github.com/coreos/go-semver v0.2.0\n+github.com/ugorji/go f1f1a805ed361a0e078bb537e4ea78cd37dcf065\n+github.com/hashicorp/consul v0.5.2\n+github.com/boltdb/bolt fff57c100f4dea1905678da7e90d92429dff2904\n+github.com/miekg/dns 75e6e86cc601825c5dbcd4e0c209eab180997cd7\n+github.com/docker/distribution edc3ab29cdff8694dd6feb85cfeb4b5f1b38ed9c\n+github.com/vbatts/tar-split v0.10.1\n+github.com/opencontainers/go-digest a6d0ee40d4207ea02364bd3b9e8e77b9159ba1eb\n+github.com/mistifyio/go-zfs 22c9b32c84eb0d0c6f4043b6e90fc94073de92fa\n+github.com/pborman/uuid v1.0\n+google.golang.org/grpc v1.3.0\n+github.com/opencontainers/runc 0351df1c5a66838d0c392b4ac4cf9450de844e2d\n+github.com/opencontainers/image-spec 372ad780f63454fbbbbcc7cf80e5b90245c13e13\n+github.com/opencontainers/runtime-spec v1.0.0\n+github.com/seccomp/libseccomp-golang 32f571b70023028bd57d9288c20efbcb237f3ce0\n+github.com/coreos/go-systemd v4\n+github.com/godbus/dbus v4.0.0\n+github.com/syndtr/gocapability 2c00daeb6c3b45114c80ac44119e7b8801fdd852\n+github.com/golang/protobuf 7a211bcf3bce0e3f1d74f9894916e6f116ae83b4\n+github.com/Graylog2/go-gelf v2\n+github.com/fluent/fluent-logger-golang v1.2.1\n+github.com/philhofer/fwd 98c11a7a6ec829d672b03833c3d69a7fae1ca972\n+github.com/tinylib/msgp 75ee40d2601edf122ef667e2a07d600d4c44490c\n+github.com/fsnotify/fsnotify v1.4.2\n+github.com/aws/aws-sdk-go v1.4.22\n+github.com/go-ini/ini 060d7da055ba6ec5ea7a31f116332fe5efa04ce0\n+github.com/jmespath/go-jmespath 0b12d6b521d83fc7f755e7cfc1b1fbdd35a01a74\n+github.com/bsphere/le_go 7a984a84b5492ae539b79b62fb4a10afc63c7bcf\n+golang.org/x/oauth2 96382aa079b72d8c014eb0c50f6c223d1e6a2de0\n+google.golang.org/api 3cc2e591b550923a2c5f0ab5a803feda924d5823\n+cloud.google.com/go 9d965e63e8cceb1b5d7977a202f0fcb8866d6525\n+github.com/googleapis/gax-go da06d194a00e19ce00d9011a13931c3f6f6887c7\n+google.golang.org/genproto d80a6e20e776b0b17a324d0ba1ab50a39c8e8944\n+github.com/containerd/containerd 06b9cb35161009dcb7123345749fef02f7cea8e0\n+github.com/tonistiigi/fifo 1405643975692217d6720f8b54aeee1bf2cd5cf4\n+github.com/docker/swarmkit 872861d2ae46958af7ead1d5fffb092c73afbaf0\n+github.com/gogo/protobuf v0.4\n+github.com/cloudflare/cfssl 7fb22c8cba7ecaf98e4082d22d65800cf45e042a\n+github.com/google/certificate-transparency d90e65c3a07988180c5b1ece71791c0b6506826e\n+golang.org/x/crypto 558b6879de74bc843225cde5686419267ff707ca\n+golang.org/x/time a4bde12657593d5e90d0533a3e4fd95e635124cb\n+github.com/hashicorp/go-memdb cb9a474f84cc5e41b273b20c6927680b2a8776ad\n+github.com/hashicorp/go-immutable-radix 8e8ed81f8f0bf1bdd829593fdd5c29922c1ea990\n+github.com/hashicorp/golang-lru a0d98a5f288019575c6d1f4bb1573fef2d1fcdc4\n+github.com/coreos/pkg fa29b1d70f0beaddd4c7021607cc3c3be8ce94b8\n+github.com/pivotal-golang/clock 3fd3c1944c59d9742e1cd333672181cd1a6f9fa0\n+github.com/prometheus/client_golang 52437c81da6b127a9925d17eb3a382a2e5fd395e\n+github.com/beorn7/perks 4c0e84591b9aa9e6dcfdf3e020114cd81f89d5f9\n+github.com/prometheus/client_model fa8ad6fec33561be4280a8f0514318c79d7f6cb6\n+github.com/prometheus/common ebdfc6da46522d58825777cf1f90490a5b1ef1d8\n+github.com/prometheus/procfs abf152e5f3e97f2fafac028d2cc06c1feb87ffa5\n+github.com/matttproud/golang_protobuf_extensions v1.0.0\n+github.com/pkg/errors 839d9e913e063e28dfd0e6c7b7512793e0a48be9\n+github.com/grpc-ecosystem/go-grpc-prometheus 6b7015e65d366bf3f19b2b2a000a831940f0f7e0\n+github.com/spf13/cobra v1.5.1\n+github.com/spf13/pflag 9ff6c6923cfffbcd502984b8e0c80539a94968b7\n+github.com/inconshreveable/mousetrap 76626ae9c91c4f2a10f34cad8ce83ea42c93bb75\n+github.com/Nvveen/Gotty a8b993ba6abdb0e0c12b0125c603323a71c7790c\n+github.com/docker/go-metrics d466d4f6fd960e01820085bd7e1a24426ee7ef18\n+github.com/opencontainers/selinux v1.0.0-rc1"}, {"sha": "53b90d1e37239fdbacd567689f6dd369e5ff4e0b", "filename": "libgo/go/cmd/go/internal/modconv/testdata/moby.vconf", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fmoby.vconf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fmoby.vconf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fmoby.vconf?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,149 @@\n+# the following lines are in sorted order, FYI\n+github.com/Azure/go-ansiterm d6e3b3328b783f23731bc4d058875b0371ff8109\n+github.com/Microsoft/hcsshim v0.6.5\n+github.com/Microsoft/go-winio v0.4.5\n+github.com/davecgh/go-spew 346938d642f2ec3594ed81d874461961cd0faa76\n+github.com/docker/libtrust 9cbd2a1374f46905c68a4eb3694a130610adc62a\n+github.com/go-check/check 4ed411733c5785b40214c70bce814c3a3a689609 https://github.com/cpuguy83/check.git\n+github.com/gorilla/context v1.1\n+github.com/gorilla/mux v1.1\n+github.com/Microsoft/opengcs v0.3.4\n+github.com/kr/pty 5cf931ef8f\n+github.com/mattn/go-shellwords v1.0.3\n+github.com/sirupsen/logrus v1.0.3\n+github.com/tchap/go-patricia v2.2.6\n+github.com/vdemeester/shakers 24d7f1d6a71aa5d9cbe7390e4afb66b7eef9e1b3\n+golang.org/x/net 7dcfb8076726a3fdd9353b6b8a1f1b6be6811bd6\n+golang.org/x/sys 07c182904dbd53199946ba614a412c61d3c548f5\n+github.com/docker/go-units 9e638d38cf6977a37a8ea0078f3ee75a7cdb2dd1\n+github.com/docker/go-connections 3ede32e2033de7505e6500d6c868c2b9ed9f169d\n+golang.org/x/text f72d8390a633d5dfb0cc84043294db9f6c935756\n+github.com/stretchr/testify 4d4bfba8f1d1027c4fdbe371823030df51419987\n+github.com/pmezard/go-difflib v1.0.0\n+github.com/gotestyourself/gotestyourself v1.1.0\n+\n+github.com/RackSec/srslog 456df3a81436d29ba874f3590eeeee25d666f8a5\n+github.com/imdario/mergo 0.2.1\n+golang.org/x/sync de49d9dcd27d4f764488181bea099dfe6179bcf0\n+\n+github.com/containerd/continuity 22694c680ee48fb8f50015b44618517e2bde77e8\n+github.com/moby/buildkit aaff9d591ef128560018433fe61beb802e149de8\n+github.com/tonistiigi/fsutil dea3a0da73aee887fc02142d995be764106ac5e2\n+\n+#get libnetwork packages\n+github.com/docker/libnetwork 68f1039f172434709a4550fe92e3e058406c74ce \n+github.com/docker/go-events 9461782956ad83b30282bf90e31fa6a70c255ba9\n+github.com/armon/go-radix e39d623f12e8e41c7b5529e9a9dd67a1e2261f80\n+github.com/armon/go-metrics eb0af217e5e9747e41dd5303755356b62d28e3ec\n+github.com/hashicorp/go-msgpack 71c2886f5a673a35f909803f38ece5810165097b\n+github.com/hashicorp/memberlist v0.1.0\n+github.com/sean-/seed e2103e2c35297fb7e17febb81e49b312087a2372\n+github.com/hashicorp/go-sockaddr acd314c5781ea706c710d9ea70069fd2e110d61d\n+github.com/hashicorp/go-multierror fcdddc395df1ddf4247c69bd436e84cfa0733f7e\n+github.com/hashicorp/serf 598c54895cc5a7b1a24a398d635e8c0ea0959870\n+github.com/docker/libkv 1d8431073ae03cdaedb198a89722f3aab6d418ef\n+github.com/vishvananda/netns 604eaf189ee867d8c147fafc28def2394e878d25\n+github.com/vishvananda/netlink bd6d5de5ccef2d66b0a26177928d0d8895d7f969\n+github.com/BurntSushi/toml f706d00e3de6abe700c994cdd545a1a4915af060\n+github.com/samuel/go-zookeeper d0e0d8e11f318e000a8cc434616d69e329edc374\n+github.com/deckarep/golang-set ef32fa3046d9f249d399f98ebaf9be944430fd1d\n+github.com/coreos/etcd v3.2.1\n+github.com/coreos/go-semver v0.2.0\n+github.com/ugorji/go f1f1a805ed361a0e078bb537e4ea78cd37dcf065\n+github.com/hashicorp/consul v0.5.2\n+github.com/boltdb/bolt fff57c100f4dea1905678da7e90d92429dff2904\n+github.com/miekg/dns 75e6e86cc601825c5dbcd4e0c209eab180997cd7\n+\n+# get graph and distribution packages\n+github.com/docker/distribution edc3ab29cdff8694dd6feb85cfeb4b5f1b38ed9c\n+github.com/vbatts/tar-split v0.10.1\n+github.com/opencontainers/go-digest a6d0ee40d4207ea02364bd3b9e8e77b9159ba1eb\n+\n+# get go-zfs packages\n+github.com/mistifyio/go-zfs 22c9b32c84eb0d0c6f4043b6e90fc94073de92fa\n+github.com/pborman/uuid v1.0\n+\n+google.golang.org/grpc v1.3.0\n+\n+# When updating, also update RUNC_COMMIT in hack/dockerfile/binaries-commits accordingly\n+github.com/opencontainers/runc 0351df1c5a66838d0c392b4ac4cf9450de844e2d\n+github.com/opencontainers/image-spec 372ad780f63454fbbbbcc7cf80e5b90245c13e13\n+github.com/opencontainers/runtime-spec v1.0.0\n+\n+github.com/seccomp/libseccomp-golang 32f571b70023028bd57d9288c20efbcb237f3ce0\n+\n+# libcontainer deps (see src/github.com/opencontainers/runc/Godeps/Godeps.json)\n+github.com/coreos/go-systemd v4\n+github.com/godbus/dbus v4.0.0\n+github.com/syndtr/gocapability 2c00daeb6c3b45114c80ac44119e7b8801fdd852\n+github.com/golang/protobuf 7a211bcf3bce0e3f1d74f9894916e6f116ae83b4\n+\n+# gelf logging driver deps\n+github.com/Graylog2/go-gelf v2\n+\n+github.com/fluent/fluent-logger-golang v1.2.1\n+# fluent-logger-golang deps\n+github.com/philhofer/fwd 98c11a7a6ec829d672b03833c3d69a7fae1ca972\n+github.com/tinylib/msgp 75ee40d2601edf122ef667e2a07d600d4c44490c\n+\n+# fsnotify\n+github.com/fsnotify/fsnotify v1.4.2\n+\n+# awslogs deps\n+github.com/aws/aws-sdk-go v1.4.22\n+github.com/go-ini/ini 060d7da055ba6ec5ea7a31f116332fe5efa04ce0\n+github.com/jmespath/go-jmespath 0b12d6b521d83fc7f755e7cfc1b1fbdd35a01a74\n+\n+# logentries\n+github.com/bsphere/le_go 7a984a84b5492ae539b79b62fb4a10afc63c7bcf\n+\n+# gcplogs deps\n+golang.org/x/oauth2 96382aa079b72d8c014eb0c50f6c223d1e6a2de0\n+google.golang.org/api 3cc2e591b550923a2c5f0ab5a803feda924d5823\n+cloud.google.com/go 9d965e63e8cceb1b5d7977a202f0fcb8866d6525\n+github.com/googleapis/gax-go da06d194a00e19ce00d9011a13931c3f6f6887c7\n+google.golang.org/genproto d80a6e20e776b0b17a324d0ba1ab50a39c8e8944\n+\n+# containerd\n+github.com/containerd/containerd 06b9cb35161009dcb7123345749fef02f7cea8e0\n+github.com/tonistiigi/fifo 1405643975692217d6720f8b54aeee1bf2cd5cf4\n+\n+# cluster\n+github.com/docker/swarmkit 872861d2ae46958af7ead1d5fffb092c73afbaf0\n+github.com/gogo/protobuf v0.4\n+github.com/cloudflare/cfssl 7fb22c8cba7ecaf98e4082d22d65800cf45e042a\n+github.com/google/certificate-transparency d90e65c3a07988180c5b1ece71791c0b6506826e\n+golang.org/x/crypto 558b6879de74bc843225cde5686419267ff707ca\n+golang.org/x/time a4bde12657593d5e90d0533a3e4fd95e635124cb\n+github.com/hashicorp/go-memdb cb9a474f84cc5e41b273b20c6927680b2a8776ad\n+github.com/hashicorp/go-immutable-radix 8e8ed81f8f0bf1bdd829593fdd5c29922c1ea990\n+github.com/hashicorp/golang-lru a0d98a5f288019575c6d1f4bb1573fef2d1fcdc4\n+github.com/coreos/pkg fa29b1d70f0beaddd4c7021607cc3c3be8ce94b8\n+github.com/pivotal-golang/clock 3fd3c1944c59d9742e1cd333672181cd1a6f9fa0\n+github.com/prometheus/client_golang 52437c81da6b127a9925d17eb3a382a2e5fd395e\n+github.com/beorn7/perks 4c0e84591b9aa9e6dcfdf3e020114cd81f89d5f9\n+github.com/prometheus/client_model fa8ad6fec33561be4280a8f0514318c79d7f6cb6\n+github.com/prometheus/common ebdfc6da46522d58825777cf1f90490a5b1ef1d8\n+github.com/prometheus/procfs abf152e5f3e97f2fafac028d2cc06c1feb87ffa5\n+github.com/matttproud/golang_protobuf_extensions v1.0.0\n+github.com/pkg/errors 839d9e913e063e28dfd0e6c7b7512793e0a48be9\n+github.com/grpc-ecosystem/go-grpc-prometheus 6b7015e65d366bf3f19b2b2a000a831940f0f7e0\n+\n+# cli\n+github.com/spf13/cobra v1.5.1 https://github.com/dnephin/cobra.git\n+github.com/spf13/pflag 9ff6c6923cfffbcd502984b8e0c80539a94968b7\n+github.com/inconshreveable/mousetrap 76626ae9c91c4f2a10f34cad8ce83ea42c93bb75\n+github.com/Nvveen/Gotty a8b993ba6abdb0e0c12b0125c603323a71c7790c https://github.com/ijc25/Gotty\n+\n+# metrics\n+github.com/docker/go-metrics d466d4f6fd960e01820085bd7e1a24426ee7ef18\n+\n+github.com/opencontainers/selinux v1.0.0-rc1\n+\n+# archive/tar\n+# mkdir -p ./vendor/archive\n+# git clone git://github.com/tonistiigi/go-1.git ./go\n+# git --git-dir ./go/.git --work-tree ./go checkout revert-prefix-ignore\n+# cp -a go/src/archive/tar ./vendor/archive/tar\n+# rm -rf ./go\n+# vndr"}, {"sha": "8830033c6b7491836d42740a800b3d7554cf3ea3", "filename": "libgo/go/cmd/go/internal/modconv/testdata/panicparse.out", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fpanicparse.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fpanicparse.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fpanicparse.out?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,8 @@\n+github.com/kr/pretty 737b74a46c4bf788349f72cb256fed10aea4d0ac\n+github.com/kr/text 7cafcd837844e784b526369c9bce262804aebc60\n+github.com/maruel/ut a9c9f15ccfa6f8b90182a53df32f4745586fbae3\n+github.com/mattn/go-colorable 9056b7a9f2d1f2d96498d6d146acd1f9d5ed3d59\n+github.com/mattn/go-isatty 56b76bdf51f7708750eac80fa38b952bb9f32639\n+github.com/mgutz/ansi c286dcecd19ff979eeb73ea444e479b903f2cfcb\n+github.com/pmezard/go-difflib 792786c7400a136282c1664665ae0a8db921c6c2\n+golang.org/x/sys a646d33e2ee3172a661fc09bca23bb4889a41bc8"}, {"sha": "ff3d43f5f2d7a1afa1cd1350713e958495e2fc84", "filename": "libgo/go/cmd/go/internal/modconv/testdata/panicparse.vyml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fpanicparse.vyml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fpanicparse.vyml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fpanicparse.vyml?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,17 @@\n+vendors:\n+- path: github.com/kr/pretty\n+  rev: 737b74a46c4bf788349f72cb256fed10aea4d0ac\n+- path: github.com/kr/text\n+  rev: 7cafcd837844e784b526369c9bce262804aebc60\n+- path: github.com/maruel/ut\n+  rev: a9c9f15ccfa6f8b90182a53df32f4745586fbae3\n+- path: github.com/mattn/go-colorable\n+  rev: 9056b7a9f2d1f2d96498d6d146acd1f9d5ed3d59\n+- path: github.com/mattn/go-isatty\n+  rev: 56b76bdf51f7708750eac80fa38b952bb9f32639\n+- path: github.com/mgutz/ansi\n+  rev: c286dcecd19ff979eeb73ea444e479b903f2cfcb\n+- path: github.com/pmezard/go-difflib\n+  rev: 792786c7400a136282c1664665ae0a8db921c6c2\n+- path: golang.org/x/sys\n+  rev: a646d33e2ee3172a661fc09bca23bb4889a41bc8"}, {"sha": "d11b8ecc726ec046269b848d1236dae0200fd83e", "filename": "libgo/go/cmd/go/internal/modconv/testdata/prometheus.out", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fprometheus.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fprometheus.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fprometheus.out?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,258 @@\n+cloud.google.com/go/compute/metadata c589d0c9f0d81640c518354c7bcae77d99820aa3\n+cloud.google.com/go/internal c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/Azure/azure-sdk-for-go/arm/compute bd73d950fa4440dae889bd9917bff7cef539f86e\n+github.com/Azure/azure-sdk-for-go/arm/network bd73d950fa4440dae889bd9917bff7cef539f86e\n+github.com/Azure/go-autorest/autorest 8a25372bbfec739b8719a9e3987400d15ef9e179\n+github.com/Azure/go-autorest/autorest/azure 8a25372bbfec739b8719a9e3987400d15ef9e179\n+github.com/Azure/go-autorest/autorest/date 8a25372bbfec739b8719a9e3987400d15ef9e179\n+github.com/Azure/go-autorest/autorest/to 8a25372bbfec739b8719a9e3987400d15ef9e179\n+github.com/Azure/go-autorest/autorest/validation 8a25372bbfec739b8719a9e3987400d15ef9e179\n+github.com/PuerkitoBio/purell c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/PuerkitoBio/urlesc c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/asaskevich/govalidator 7b3beb6df3c42abd3509abfc3bcacc0fbfb7c877\n+github.com/aws/aws-sdk-go/aws 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/awserr 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/awsutil 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/client 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/client/metadata 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/corehandlers 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/credentials 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/credentials/ec2rolecreds 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/credentials/endpointcreds 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/credentials/stscreds 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/defaults 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/ec2metadata 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/request 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/session 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/aws/signer/v4 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/private/endpoints 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/private/protocol 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/private/protocol/ec2query 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/private/protocol/query 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/private/protocol/query/queryutil 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/private/protocol/rest 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/private/protocol/xml/xmlutil 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/private/waiter 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/service/ec2 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/aws/aws-sdk-go/service/sts 707203bc55114ed114446bf57949c5c211d8b7c0\n+github.com/beorn7/perks/quantile 3ac7bf7a47d159a033b107610db8a1b6575507a4\n+github.com/blang/semver c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/coreos/go-oidc/http c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/coreos/go-oidc/jose c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/coreos/go-oidc/key c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/coreos/go-oidc/oauth2 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/coreos/go-oidc/oidc c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/coreos/pkg/health c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/coreos/pkg/httputil c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/coreos/pkg/timeutil c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/davecgh/go-spew/spew c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/dgrijalva/jwt-go 9ed569b5d1ac936e6494082958d63a6aa4fff99a\n+github.com/docker/distribution/digest c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/docker/distribution/reference c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/emicklei/go-restful c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/emicklei/go-restful/log c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/emicklei/go-restful/swagger c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/ghodss/yaml c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/go-ini/ini 6e4869b434bd001f6983749881c7ead3545887d8\n+github.com/go-openapi/jsonpointer c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/go-openapi/jsonreference c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/go-openapi/spec c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/go-openapi/swag c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/gogo/protobuf/proto c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/gogo/protobuf/sortkeys c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/golang/glog c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/golang/protobuf/proto 98fa357170587e470c5f27d3c3ea0947b71eb455\n+github.com/golang/snappy d9eb7a3d35ec988b8585d4a0068e462c27d28380\n+github.com/google/gofuzz c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/hashicorp/consul/api daacc4be8bee214e3fc4b32a6dd385f5ef1b4c36\n+github.com/hashicorp/go-cleanhttp ad28ea4487f05916463e2423a55166280e8254b5\n+github.com/hashicorp/serf/coordinate 1d4fa605f6ff3ed628d7ae5eda7c0e56803e72a5\n+github.com/influxdb/influxdb/client 291aaeb9485b43b16875c238482b2f7d0a22a13b\n+github.com/influxdb/influxdb/tsdb 291aaeb9485b43b16875c238482b2f7d0a22a13b\n+github.com/jmespath/go-jmespath bd40a432e4c76585ef6b72d3fd96fb9b6dc7b68d\n+github.com/jonboulle/clockwork c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/juju/ratelimit c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/julienschmidt/httprouter 109e267447e95ad1bb48b758e40dd7453eb7b039\n+github.com/mailru/easyjson/buffer c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/mailru/easyjson/jlexer c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/mailru/easyjson/jwriter c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/matttproud/golang_protobuf_extensions/pbutil fc2b8d3a73c4867e51861bbdd5ae3c1f0869dd6a\n+github.com/miekg/dns 58f52c57ce9df13460ac68200cef30a008b9c468\n+github.com/pborman/uuid c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/pmezard/go-difflib/difflib d77da356e56a7428ad25149ca77381849a6a5232\n+github.com/prometheus/client_golang/prometheus c5b7fccd204277076155f10851dad72b76a49317\n+github.com/prometheus/client_model/go fa8ad6fec33561be4280a8f0514318c79d7f6cb6\n+github.com/prometheus/common/expfmt 85637ea67b04b5c3bb25e671dacded2977f8f9f6\n+github.com/prometheus/common/internal/bitbucket.org/ww/goautoneg 85637ea67b04b5c3bb25e671dacded2977f8f9f6\n+github.com/prometheus/common/log 85637ea67b04b5c3bb25e671dacded2977f8f9f6\n+github.com/prometheus/common/model 85637ea67b04b5c3bb25e671dacded2977f8f9f6\n+github.com/prometheus/common/route 85637ea67b04b5c3bb25e671dacded2977f8f9f6\n+github.com/prometheus/common/version 85637ea67b04b5c3bb25e671dacded2977f8f9f6\n+github.com/prometheus/procfs abf152e5f3e97f2fafac028d2cc06c1feb87ffa5\n+github.com/samuel/go-zookeeper/zk 177002e16a0061912f02377e2dd8951a8b3551bc\n+github.com/spf13/pflag c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/stretchr/testify/assert d77da356e56a7428ad25149ca77381849a6a5232\n+github.com/stretchr/testify/require d77da356e56a7428ad25149ca77381849a6a5232\n+github.com/syndtr/goleveldb/leveldb 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/syndtr/goleveldb/leveldb/cache 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/syndtr/goleveldb/leveldb/comparer 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/syndtr/goleveldb/leveldb/errors 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/syndtr/goleveldb/leveldb/filter 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/syndtr/goleveldb/leveldb/iterator 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/syndtr/goleveldb/leveldb/journal 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/syndtr/goleveldb/leveldb/memdb 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/syndtr/goleveldb/leveldb/opt 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/syndtr/goleveldb/leveldb/storage 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/syndtr/goleveldb/leveldb/table 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/syndtr/goleveldb/leveldb/util 6b4daa5362b502898ddf367c5c11deb9e7a5c727\n+github.com/ugorji/go/codec c589d0c9f0d81640c518354c7bcae77d99820aa3\n+github.com/vaughan0/go-ini a98ad7ee00ec53921f08832bc06ecf7fd600e6a1\n+golang.org/x/net/context b336a971b799939dd16ae9b1df8334cb8b977c4d\n+golang.org/x/net/context/ctxhttp b336a971b799939dd16ae9b1df8334cb8b977c4d\n+golang.org/x/net/http2 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/net/http2/hpack c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/net/idna c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/net/internal/timeseries 6250b412798208e6c90b03b7c4f226de5aa299e2\n+golang.org/x/net/lex/httplex c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/net/netutil bc3663df0ac92f928d419e31e0d2af22e683a5a2\n+golang.org/x/oauth2 65a8d08c6292395d47053be10b3c5e91960def76\n+golang.org/x/oauth2/google 65a8d08c6292395d47053be10b3c5e91960def76\n+golang.org/x/oauth2/internal 65a8d08c6292395d47053be10b3c5e91960def76\n+golang.org/x/oauth2/jws 65a8d08c6292395d47053be10b3c5e91960def76\n+golang.org/x/oauth2/jwt 65a8d08c6292395d47053be10b3c5e91960def76\n+golang.org/x/sys/unix c200b10b5d5e122be351b67af224adc6128af5bf\n+golang.org/x/sys/windows c200b10b5d5e122be351b67af224adc6128af5bf\n+golang.org/x/sys/windows/registry c200b10b5d5e122be351b67af224adc6128af5bf\n+golang.org/x/sys/windows/svc/eventlog c200b10b5d5e122be351b67af224adc6128af5bf\n+golang.org/x/text/cases c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/text/internal/tag c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/text/language c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/text/runes c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/text/secure/bidirule c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/text/secure/precis c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/text/transform c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/text/unicode/bidi c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/text/unicode/norm c589d0c9f0d81640c518354c7bcae77d99820aa3\n+golang.org/x/text/width c589d0c9f0d81640c518354c7bcae77d99820aa3\n+google.golang.org/api/compute/v1 63ade871fd3aec1225809d496e81ec91ab76ea29\n+google.golang.org/api/gensupport 63ade871fd3aec1225809d496e81ec91ab76ea29\n+google.golang.org/api/googleapi 63ade871fd3aec1225809d496e81ec91ab76ea29\n+google.golang.org/api/googleapi/internal/uritemplates 63ade871fd3aec1225809d496e81ec91ab76ea29\n+google.golang.org/appengine 267c27e7492265b84fc6719503b14a1e17975d79\n+google.golang.org/appengine/internal 267c27e7492265b84fc6719503b14a1e17975d79\n+google.golang.org/appengine/internal/app_identity 267c27e7492265b84fc6719503b14a1e17975d79\n+google.golang.org/appengine/internal/base 267c27e7492265b84fc6719503b14a1e17975d79\n+google.golang.org/appengine/internal/datastore 267c27e7492265b84fc6719503b14a1e17975d79\n+google.golang.org/appengine/internal/log 267c27e7492265b84fc6719503b14a1e17975d79\n+google.golang.org/appengine/internal/modules 267c27e7492265b84fc6719503b14a1e17975d79\n+google.golang.org/appengine/internal/remote_api 4f7eeb5305a4ba1966344836ba4af9996b7b4e05\n+google.golang.org/appengine/internal/urlfetch 267c27e7492265b84fc6719503b14a1e17975d79\n+google.golang.org/appengine/urlfetch 267c27e7492265b84fc6719503b14a1e17975d79\n+google.golang.org/cloud/compute/metadata 0a83eba2cadb60eb22123673c8fb6fca02b03c94\n+google.golang.org/cloud/internal 0a83eba2cadb60eb22123673c8fb6fca02b03c94\n+gopkg.in/fsnotify.v1 30411dbcefb7a1da7e84f75530ad3abe4011b4f8\n+gopkg.in/inf.v0 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+gopkg.in/yaml.v2 7ad95dd0798a40da1ccdff6dff35fd177b5edf40\n+k8s.io/client-go/1.5/discovery c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes/typed/apps/v1alpha1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes/typed/authentication/v1beta1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes/typed/authorization/v1beta1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes/typed/autoscaling/v1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes/typed/batch/v1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes/typed/certificates/v1alpha1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes/typed/core/v1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes/typed/extensions/v1beta1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes/typed/policy/v1alpha1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes/typed/rbac/v1alpha1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/kubernetes/typed/storage/v1beta1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/api c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/api/errors c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/api/install c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/api/meta c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/api/meta/metatypes c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/api/resource c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/api/unversioned c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/api/v1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/api/validation/path c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apimachinery c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apimachinery/announced c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apimachinery/registered c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/apps c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/apps/install c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/apps/v1alpha1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/authentication c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/authentication/install c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/authentication/v1beta1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/authorization c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/authorization/install c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/authorization/v1beta1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/autoscaling c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/autoscaling/install c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/autoscaling/v1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/batch c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/batch/install c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/batch/v1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/batch/v2alpha1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/certificates c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/certificates/install c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/certificates/v1alpha1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/extensions c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/extensions/install c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/extensions/v1beta1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/policy c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/policy/install c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/policy/v1alpha1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/rbac c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/rbac/install c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/rbac/v1alpha1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/storage c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/storage/install c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/apis/storage/v1beta1 c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/auth/user c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/conversion c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/conversion/queryparams c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/fields c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/genericapiserver/openapi/common c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/labels c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/runtime c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/runtime/serializer c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/runtime/serializer/json c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/runtime/serializer/protobuf c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/runtime/serializer/recognizer c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/runtime/serializer/streaming c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/runtime/serializer/versioning c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/selection c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/third_party/forked/golang/reflect c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/types c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/cert c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/clock c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/errors c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/flowcontrol c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/framer c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/integer c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/intstr c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/json c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/labels c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/net c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/parsers c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/rand c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/runtime c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/sets c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/uuid c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/validation c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/validation/field c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/wait c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/util/yaml c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/version c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/watch c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/pkg/watch/versioned c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/plugin/pkg/client/auth c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/plugin/pkg/client/auth/gcp c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/plugin/pkg/client/auth/oidc c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/rest c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/tools/cache c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/tools/clientcmd/api c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/tools/metrics c589d0c9f0d81640c518354c7bcae77d99820aa3\n+k8s.io/client-go/1.5/transport c589d0c9f0d81640c518354c7bcae77d99820aa3"}, {"sha": "648bec4260829e8d1d512cf89068b47b7d885d05", "filename": "libgo/go/cmd/go/internal/modconv/testdata/prometheus.vjson", "status": "added", "additions": 1605, "deletions": 0, "changes": 1605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fprometheus.vjson", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fprometheus.vjson", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fprometheus.vjson?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,1605 @@\n+{\n+\t\"comment\": \"\",\n+\t\"ignore\": \"test appengine\",\n+\t\"package\": [\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Cslv4/ITyQmgjSUhNXFu8q5bqOU=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/cloud.google.com/go/compute/metadata\",\n+\t\t\t\"path\": \"cloud.google.com/go/compute/metadata\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"hiJXjkFEGy+sDFf6O58Ocdy9Rnk=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/cloud.google.com/go/internal\",\n+\t\t\t\"path\": \"cloud.google.com/go/internal\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"oIt4tXgFYnZJBsCac1BQLnTWALM=\",\n+\t\t\t\"path\": \"github.com/Azure/azure-sdk-for-go/arm/compute\",\n+\t\t\t\"revision\": \"bd73d950fa4440dae889bd9917bff7cef539f86e\",\n+\t\t\t\"revisionTime\": \"2016-10-28T18:31:11Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"QKi6LiSyD5GnRK8ExpMgZl4XiMI=\",\n+\t\t\t\"path\": \"github.com/Azure/azure-sdk-for-go/arm/network\",\n+\t\t\t\"revision\": \"bd73d950fa4440dae889bd9917bff7cef539f86e\",\n+\t\t\t\"revisionTime\": \"2016-10-28T18:31:11Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"eVSHe6GIHj9/ziFrQLZ1SC7Nn6k=\",\n+\t\t\t\"path\": \"github.com/Azure/go-autorest/autorest\",\n+\t\t\t\"revision\": \"8a25372bbfec739b8719a9e3987400d15ef9e179\",\n+\t\t\t\"revisionTime\": \"2016-10-25T18:07:34Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"0sYi0JprevG/PZjtMbOh8h0pt0g=\",\n+\t\t\t\"path\": \"github.com/Azure/go-autorest/autorest/azure\",\n+\t\t\t\"revision\": \"8a25372bbfec739b8719a9e3987400d15ef9e179\",\n+\t\t\t\"revisionTime\": \"2016-10-25T18:07:34Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"q9Qz8PAxK5FTOZwgYKe5Lj38u4c=\",\n+\t\t\t\"path\": \"github.com/Azure/go-autorest/autorest/date\",\n+\t\t\t\"revision\": \"8a25372bbfec739b8719a9e3987400d15ef9e179\",\n+\t\t\t\"revisionTime\": \"2016-10-25T18:07:34Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Ev8qCsbFjDlMlX0N2tYAhYQFpUc=\",\n+\t\t\t\"path\": \"github.com/Azure/go-autorest/autorest/to\",\n+\t\t\t\"revision\": \"8a25372bbfec739b8719a9e3987400d15ef9e179\",\n+\t\t\t\"revisionTime\": \"2016-10-25T18:07:34Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"oBixceM+55gdk47iff8DSEIh3po=\",\n+\t\t\t\"path\": \"github.com/Azure/go-autorest/autorest/validation\",\n+\t\t\t\"revision\": \"8a25372bbfec739b8719a9e3987400d15ef9e179\",\n+\t\t\t\"revisionTime\": \"2016-10-25T18:07:34Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"IatnluZB5jTVUncMN134e4VOV34=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/PuerkitoBio/purell\",\n+\t\t\t\"path\": \"github.com/PuerkitoBio/purell\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"E/Tz8z0B/gaR551g+XqPKAhcteM=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/PuerkitoBio/urlesc\",\n+\t\t\t\"path\": \"github.com/PuerkitoBio/urlesc\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"BdLdZP/C2uOO3lqk9X3NCKFpXa4=\",\n+\t\t\t\"path\": \"github.com/asaskevich/govalidator\",\n+\t\t\t\"revision\": \"7b3beb6df3c42abd3509abfc3bcacc0fbfb7c877\",\n+\t\t\t\"revisionTime\": \"2016-10-01T16:31:30Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"WNfR3yhLjRC5/uccgju/bwrdsxQ=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Y9W+4GimK4Fuxq+vyIskVYFRnX4=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/awserr\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"+q4vdl3l1Wom8K1wfIpJ4jlFsbY=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/awsutil\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"/232RBWA3KnT7U+wciPS2+wmvR0=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/client\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"ieAJ+Cvp/PKv1LpUEnUXpc3OI6E=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/client/metadata\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"c1N3Loy3AS9zD+m5CzpPNAED39U=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/corehandlers\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"zu5C95rmCZff6NYZb62lEaT5ibE=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/credentials\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"KQiUK/zr3mqnAXD7x/X55/iNme0=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/credentials/ec2rolecreds\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"NUJUTWlc1sV8b7WjfiYc4JZbXl0=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/credentials/endpointcreds\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"4Ipx+5xN0gso+cENC2MHMWmQlR4=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/credentials/stscreds\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"DwhFsNluCFEwqzyp3hbJR3q2Wqs=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/defaults\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"8E0fEBUJY/1lJOyVxzTxMGQGInk=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/ec2metadata\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"5Ac22YMTBmrX/CXaEIXzWljr8UY=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/request\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"eOo6evLMAxQfo7Qkc5/h5euN1Sw=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/session\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"diXvBs1LRC0RJ9WK6sllWKdzC04=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/aws/signer/v4\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Esab5F8KswqkTdB4TtjSvZgs56k=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/private/endpoints\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"wk7EyvDaHwb5qqoOP/4d3cV0708=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/private/protocol\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"1QmQ3FqV37w0Zi44qv8pA1GeR0A=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/private/protocol/ec2query\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"ZqY5RWavBLWTo6j9xqdyBEaNFRk=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/private/protocol/query\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"5xzix1R8prUyWxgLnzUQoxTsfik=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/private/protocol/query/queryutil\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"TW/7U+/8ormL7acf6z2rv2hDD+s=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/private/protocol/rest\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"eUEkjyMPAuekKBE4ou+nM9tXEas=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/private/protocol/xml/xmlutil\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Eo9yODN5U99BK0pMzoqnBm7PCrY=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/private/waiter\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"6h4tJ9wVtbYb9wG4srtUxyPoAYM=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/service/ec2\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"ouwhxcAsIYQ6oJbMRdLW/Ys/iyg=\",\n+\t\t\t\"path\": \"github.com/aws/aws-sdk-go/service/sts\",\n+\t\t\t\"revision\": \"707203bc55114ed114446bf57949c5c211d8b7c0\",\n+\t\t\t\"revisionTime\": \"2016-11-02T21:59:28Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"4QnLdmB1kG3N+KlDd1N+G9TWAGQ=\",\n+\t\t\t\"path\": \"github.com/beorn7/perks/quantile\",\n+\t\t\t\"revision\": \"3ac7bf7a47d159a033b107610db8a1b6575507a4\",\n+\t\t\t\"revisionTime\": \"2016-02-29T21:34:45Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"n+s4YwtzpMWW5Rt0dEaQa7NHDGQ=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/blang/semver\",\n+\t\t\t\"path\": \"github.com/blang/semver\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Z2AOGSmDKKvI6nuxa+UPjQWpIeM=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/coreos/go-oidc/http\",\n+\t\t\t\"path\": \"github.com/coreos/go-oidc/http\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"8yvt1xKCgNwuuavJdxRnvaIjrIc=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/coreos/go-oidc/jose\",\n+\t\t\t\"path\": \"github.com/coreos/go-oidc/jose\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"zhXKrWBSSJLqZxVE/Xsw0M9ynFQ=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/coreos/go-oidc/key\",\n+\t\t\t\"path\": \"github.com/coreos/go-oidc/key\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"bkW0mnXvmHQwHprW/6wrbpP7lAk=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/coreos/go-oidc/oauth2\",\n+\t\t\t\"path\": \"github.com/coreos/go-oidc/oauth2\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"E1x2k5FdhJ+dzFrh3kCmC6aJfVw=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/coreos/go-oidc/oidc\",\n+\t\t\t\"path\": \"github.com/coreos/go-oidc/oidc\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"O0UMBRCOD9ItMayDqLQ2MJEjkVE=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/coreos/pkg/health\",\n+\t\t\t\"path\": \"github.com/coreos/pkg/health\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"74vyZz/d49FZXMbFaHOfCGvSLj0=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/coreos/pkg/httputil\",\n+\t\t\t\"path\": \"github.com/coreos/pkg/httputil\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"etBdQ0LN6ojGunfvUt6B5C3FNrQ=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/coreos/pkg/timeutil\",\n+\t\t\t\"path\": \"github.com/coreos/pkg/timeutil\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"SdSd7pyjONWWTHc5XE3AhglLo34=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/davecgh/go-spew/spew\",\n+\t\t\t\"path\": \"github.com/davecgh/go-spew/spew\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"2Fy1Y6Z3lRRX1891WF/+HT4XS2I=\",\n+\t\t\t\"path\": \"github.com/dgrijalva/jwt-go\",\n+\t\t\t\"revision\": \"9ed569b5d1ac936e6494082958d63a6aa4fff99a\",\n+\t\t\t\"revisionTime\": \"2016-11-01T19:39:35Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"f1wARLDzsF/JoyN01yoxXEwFIp8=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/docker/distribution/digest\",\n+\t\t\t\"path\": \"github.com/docker/distribution/digest\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"PzXRTLmmqWXxmDqdIXLcRYBma18=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/docker/distribution/reference\",\n+\t\t\t\"path\": \"github.com/docker/distribution/reference\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"1vQR+ZyudsjKio6RNKmWhwzGTb0=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/emicklei/go-restful\",\n+\t\t\t\"path\": \"github.com/emicklei/go-restful\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"3xWz4fZ9xW+CfADpYoPFcZCYJ4E=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/emicklei/go-restful/log\",\n+\t\t\t\"path\": \"github.com/emicklei/go-restful/log\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"J7CtF9gIs2yH9A7lPQDDrhYxiRk=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/emicklei/go-restful/swagger\",\n+\t\t\t\"path\": \"github.com/emicklei/go-restful/swagger\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"ww7LVo7jNJ1o6sfRcromEHKyY+o=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/ghodss/yaml\",\n+\t\t\t\"path\": \"github.com/ghodss/yaml\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"cVyhKIRI2gQrgpn5qrBeAqErmWM=\",\n+\t\t\t\"path\": \"github.com/go-ini/ini\",\n+\t\t\t\"revision\": \"6e4869b434bd001f6983749881c7ead3545887d8\",\n+\t\t\t\"revisionTime\": \"2016-08-27T06:11:18Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"NaZnW0tKj/b0k5WzcMD0twrLbrE=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/go-openapi/jsonpointer\",\n+\t\t\t\"path\": \"github.com/go-openapi/jsonpointer\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"3LJXjMDxPY+veIqzQtiAvK3hXnY=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/go-openapi/jsonreference\",\n+\t\t\t\"path\": \"github.com/go-openapi/jsonreference\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"faeB3fny260hQ/gEfEXa1ZQTGtk=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/go-openapi/spec\",\n+\t\t\t\"path\": \"github.com/go-openapi/spec\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"wGpZwJ5HZtReou8A3WEV1Gdxs6k=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/go-openapi/swag\",\n+\t\t\t\"path\": \"github.com/go-openapi/swag\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"BIyZQL97iG7mzZ2UMR3XpiXbZdc=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/gogo/protobuf/proto\",\n+\t\t\t\"path\": \"github.com/gogo/protobuf/proto\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"e6cMbpJj41MpihS5eP4SIliRBK4=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/gogo/protobuf/sortkeys\",\n+\t\t\t\"path\": \"github.com/gogo/protobuf/sortkeys\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"URsJa4y/sUUw/STmbeYx9EKqaYE=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/golang/glog\",\n+\t\t\t\"path\": \"github.com/golang/glog\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"yDh5kmmr0zEF1r+rvYqbZcR7iLs=\",\n+\t\t\t\"path\": \"github.com/golang/protobuf/proto\",\n+\t\t\t\"revision\": \"98fa357170587e470c5f27d3c3ea0947b71eb455\",\n+\t\t\t\"revisionTime\": \"2016-10-12T20:53:35Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"2a/SsTUBMKtcM6VtpbdPGO+c6c8=\",\n+\t\t\t\"path\": \"github.com/golang/snappy\",\n+\t\t\t\"revision\": \"d9eb7a3d35ec988b8585d4a0068e462c27d28380\",\n+\t\t\t\"revisionTime\": \"2016-05-29T05:00:41Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"/yFfUp3tGt6cK22UVzbq8SjPDCU=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/google/gofuzz\",\n+\t\t\t\"path\": \"github.com/google/gofuzz\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"LclVLJYrBi03PBjsVPpgoMbUDQ8=\",\n+\t\t\t\"path\": \"github.com/hashicorp/consul/api\",\n+\t\t\t\"revision\": \"daacc4be8bee214e3fc4b32a6dd385f5ef1b4c36\",\n+\t\t\t\"revisionTime\": \"2016-10-28T04:06:46Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Uzyon2091lmwacNsl1hCytjhHtg=\",\n+\t\t\t\"path\": \"github.com/hashicorp/go-cleanhttp\",\n+\t\t\t\"revision\": \"ad28ea4487f05916463e2423a55166280e8254b5\",\n+\t\t\t\"revisionTime\": \"2016-04-07T17:41:26Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"E3Xcanc9ouQwL+CZGOUyA/+giLg=\",\n+\t\t\t\"path\": \"github.com/hashicorp/serf/coordinate\",\n+\t\t\t\"revision\": \"1d4fa605f6ff3ed628d7ae5eda7c0e56803e72a5\",\n+\t\t\t\"revisionTime\": \"2016-10-07T00:41:22Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"path\": \"github.com/influxdb/influxdb/client\",\n+\t\t\t\"revision\": \"291aaeb9485b43b16875c238482b2f7d0a22a13b\",\n+\t\t\t\"revisionTime\": \"2015-09-16T14:41:53+02:00\"\n+\t\t},\n+\t\t{\n+\t\t\t\"path\": \"github.com/influxdb/influxdb/tsdb\",\n+\t\t\t\"revision\": \"291aaeb9485b43b16875c238482b2f7d0a22a13b\",\n+\t\t\t\"revisionTime\": \"2015-09-16T14:41:53+02:00\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"0ZrwvB6KoGPj2PoDNSEJwxQ6Mog=\",\n+\t\t\t\"path\": \"github.com/jmespath/go-jmespath\",\n+\t\t\t\"revision\": \"bd40a432e4c76585ef6b72d3fd96fb9b6dc7b68d\",\n+\t\t\t\"revisionTime\": \"2016-08-03T19:07:31Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"9ZVOEbIXnTuYpVqce4en8rwlkPE=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/jonboulle/clockwork\",\n+\t\t\t\"path\": \"github.com/jonboulle/clockwork\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"gA95N2LM2hEJLoqrTPaFsSWDJ2Y=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/juju/ratelimit\",\n+\t\t\t\"path\": \"github.com/juju/ratelimit\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Farach1xcmsQYrhiUfkwF2rbIaE=\",\n+\t\t\t\"path\": \"github.com/julienschmidt/httprouter\",\n+\t\t\t\"revision\": \"109e267447e95ad1bb48b758e40dd7453eb7b039\",\n+\t\t\t\"revisionTime\": \"2015-09-05T19:25:33+02:00\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"urY45++NYCue4nh4k8OjUFnIGfU=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/mailru/easyjson/buffer\",\n+\t\t\t\"path\": \"github.com/mailru/easyjson/buffer\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"yTDKAM4KBgOvXRsZC50zg0OChvM=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/mailru/easyjson/jlexer\",\n+\t\t\t\"path\": \"github.com/mailru/easyjson/jlexer\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"4+d+6rhM1pei6lBguhqSEW7LaXs=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/mailru/easyjson/jwriter\",\n+\t\t\t\"path\": \"github.com/mailru/easyjson/jwriter\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Q2vw4HZBbnU8BLFt8VrzStwqSJg=\",\n+\t\t\t\"path\": \"github.com/matttproud/golang_protobuf_extensions/pbutil\",\n+\t\t\t\"revision\": \"fc2b8d3a73c4867e51861bbdd5ae3c1f0869dd6a\",\n+\t\t\t\"revisionTime\": \"2015-04-06T19:39:34+02:00\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Wahi4g/9XiHhSLAJ+8jskg71PCU=\",\n+\t\t\t\"path\": \"github.com/miekg/dns\",\n+\t\t\t\"revision\": \"58f52c57ce9df13460ac68200cef30a008b9c468\",\n+\t\t\t\"revisionTime\": \"2016-10-18T06:08:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"3YJklSuzSE1Rt8A+2dhiWSmf/fw=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/pborman/uuid\",\n+\t\t\t\"path\": \"github.com/pborman/uuid\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"zKKp5SZ3d3ycKe4EKMNT0BqAWBw=\",\n+\t\t\t\"origin\": \"github.com/stretchr/testify/vendor/github.com/pmezard/go-difflib/difflib\",\n+\t\t\t\"path\": \"github.com/pmezard/go-difflib/difflib\",\n+\t\t\t\"revision\": \"d77da356e56a7428ad25149ca77381849a6a5232\",\n+\t\t\t\"revisionTime\": \"2016-06-15T09:26:46Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"KkB+77Ziom7N6RzSbyUwYGrmDeU=\",\n+\t\t\t\"path\": \"github.com/prometheus/client_golang/prometheus\",\n+\t\t\t\"revision\": \"c5b7fccd204277076155f10851dad72b76a49317\",\n+\t\t\t\"revisionTime\": \"2016-08-17T15:48:24Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"DvwvOlPNAgRntBzt3b3OSRMS2N4=\",\n+\t\t\t\"path\": \"github.com/prometheus/client_model/go\",\n+\t\t\t\"revision\": \"fa8ad6fec33561be4280a8f0514318c79d7f6cb6\",\n+\t\t\t\"revisionTime\": \"2015-02-12T10:17:44Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"mHyjbJ3BWOfUV6q9f5PBt0gaY1k=\",\n+\t\t\t\"path\": \"github.com/prometheus/common/expfmt\",\n+\t\t\t\"revision\": \"85637ea67b04b5c3bb25e671dacded2977f8f9f6\",\n+\t\t\t\"revisionTime\": \"2016-10-02T21:02:34Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"GWlM3d2vPYyNATtTFgftS10/A9w=\",\n+\t\t\t\"path\": \"github.com/prometheus/common/internal/bitbucket.org/ww/goautoneg\",\n+\t\t\t\"revision\": \"85637ea67b04b5c3bb25e671dacded2977f8f9f6\",\n+\t\t\t\"revisionTime\": \"2016-10-02T21:02:34Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"UU6hIfhVjnAYDADQEfE/3T7Ddm8=\",\n+\t\t\t\"path\": \"github.com/prometheus/common/log\",\n+\t\t\t\"revision\": \"85637ea67b04b5c3bb25e671dacded2977f8f9f6\",\n+\t\t\t\"revisionTime\": \"2016-10-02T21:02:34Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"nFie+rxcX5WdIv1diZ+fu3aj6lE=\",\n+\t\t\t\"path\": \"github.com/prometheus/common/model\",\n+\t\t\t\"revision\": \"85637ea67b04b5c3bb25e671dacded2977f8f9f6\",\n+\t\t\t\"revisionTime\": \"2016-10-02T21:02:34Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"QQKJYoGcY10nIHxhBEHwjwUZQzk=\",\n+\t\t\t\"path\": \"github.com/prometheus/common/route\",\n+\t\t\t\"revision\": \"85637ea67b04b5c3bb25e671dacded2977f8f9f6\",\n+\t\t\t\"revisionTime\": \"2016-10-02T21:02:34Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"91KYK0SpvkaMJJA2+BcxbVnyRO0=\",\n+\t\t\t\"path\": \"github.com/prometheus/common/version\",\n+\t\t\t\"revision\": \"85637ea67b04b5c3bb25e671dacded2977f8f9f6\",\n+\t\t\t\"revisionTime\": \"2016-10-02T21:02:34Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"W218eJZPXJG783fUr/z6IaAZyes=\",\n+\t\t\t\"path\": \"github.com/prometheus/procfs\",\n+\t\t\t\"revision\": \"abf152e5f3e97f2fafac028d2cc06c1feb87ffa5\",\n+\t\t\t\"revisionTime\": \"2016-04-11T19:08:41Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"+49Vr4Me28p3cR+gxX5SUQHbbas=\",\n+\t\t\t\"path\": \"github.com/samuel/go-zookeeper/zk\",\n+\t\t\t\"revision\": \"177002e16a0061912f02377e2dd8951a8b3551bc\",\n+\t\t\t\"revisionTime\": \"2015-08-17T10:50:50-07:00\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"YuPBOVkkE3uuBh4RcRUTF0n+frs=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/spf13/pflag\",\n+\t\t\t\"path\": \"github.com/spf13/pflag\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"iydUphwYqZRq3WhstEdGsbvBAKs=\",\n+\t\t\t\"path\": \"github.com/stretchr/testify/assert\",\n+\t\t\t\"revision\": \"d77da356e56a7428ad25149ca77381849a6a5232\",\n+\t\t\t\"revisionTime\": \"2016-06-15T09:26:46Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"P9FJpir2c4G5PA46qEkaWy3l60U=\",\n+\t\t\t\"path\": \"github.com/stretchr/testify/require\",\n+\t\t\t\"revision\": \"d77da356e56a7428ad25149ca77381849a6a5232\",\n+\t\t\t\"revisionTime\": \"2016-06-15T09:26:46Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"VhcnDY37sYAnL8WjfYQN9YYl+W4=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"EKIow7XkgNdWvR/982ffIZxKG8Y=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb/cache\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"5KPgnvCPlR0ysDAqo6jApzRQ3tw=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb/comparer\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"1DRAxdlWzS4U0xKN/yQ/fdNN7f0=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb/errors\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"eqKeD6DS7eNCtxVYZEHHRKkyZrw=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb/filter\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"8dXuAVIsbtaMiGGuHjzGR6Ny/5c=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb/iterator\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"gJY7bRpELtO0PJpZXgPQ2BYFJ88=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb/journal\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"j+uaQ6DwJ50dkIdfMQu1TXdlQcY=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb/memdb\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"UmQeotV+m8/FduKEfLOhjdp18rs=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb/opt\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"/Wvv9HeJTN9UUjdjwUlz7X4ioIo=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb/storage\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"JTJA+u8zk7EXy1UUmpFPNGvtO2A=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb/table\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"4zil8Gwg8VPkDn1YzlgCvtukJFU=\",\n+\t\t\t\"path\": \"github.com/syndtr/goleveldb/leveldb/util\",\n+\t\t\t\"revision\": \"6b4daa5362b502898ddf367c5c11deb9e7a5c727\",\n+\t\t\t\"revisionTime\": \"2016-10-11T05:00:08Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"f6Aew+ZA+HBAXCw6/xTST3mB0Lw=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/github.com/ugorji/go/codec\",\n+\t\t\t\"path\": \"github.com/ugorji/go/codec\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"sFD8LpJPQtWLwGda3edjf5mNUbs=\",\n+\t\t\t\"path\": \"github.com/vaughan0/go-ini\",\n+\t\t\t\"revision\": \"a98ad7ee00ec53921f08832bc06ecf7fd600e6a1\",\n+\t\t\t\"revisionTime\": \"2013-09-23T16:52:12+02:00\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"9jjO5GjLa0XF/nfWihF02RoH4qc=\",\n+\t\t\t\"path\": \"golang.org/x/net/context\",\n+\t\t\t\"revision\": \"b336a971b799939dd16ae9b1df8334cb8b977c4d\",\n+\t\t\t\"revisionTime\": \"2016-10-27T19:58:04Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"WHc3uByvGaMcnSoI21fhzYgbOgg=\",\n+\t\t\t\"path\": \"golang.org/x/net/context/ctxhttp\",\n+\t\t\t\"revision\": \"b336a971b799939dd16ae9b1df8334cb8b977c4d\",\n+\t\t\t\"revisionTime\": \"2016-10-27T19:58:04Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"SPYGC6DQrH9jICccUsOfbvvhB4g=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/net/http2\",\n+\t\t\t\"path\": \"golang.org/x/net/http2\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"EYNaHp7XdLWRydUCE0amEkKAtgk=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/net/http2/hpack\",\n+\t\t\t\"path\": \"golang.org/x/net/http2/hpack\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"gXiSniT8fevWOVPVKopYgrdzi60=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/net/idna\",\n+\t\t\t\"path\": \"golang.org/x/net/idna\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"/k7k6eJDkxXx6K9Zpo/OwNm58XM=\",\n+\t\t\t\"path\": \"golang.org/x/net/internal/timeseries\",\n+\t\t\t\"revision\": \"6250b412798208e6c90b03b7c4f226de5aa299e2\",\n+\t\t\t\"revisionTime\": \"2016-08-24T22:20:41Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"yhndhWXMs/VSEDLks4dNyFMQStA=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/net/lex/httplex\",\n+\t\t\t\"path\": \"golang.org/x/net/lex/httplex\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"7WASrg0PEueWDDRHkFhEEN6Qrms=\",\n+\t\t\t\"path\": \"golang.org/x/net/netutil\",\n+\t\t\t\"revision\": \"bc3663df0ac92f928d419e31e0d2af22e683a5a2\",\n+\t\t\t\"revisionTime\": \"2016-06-21T20:48:10Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"mktBVED98G2vv+OKcSgtnFVZC1Y=\",\n+\t\t\t\"path\": \"golang.org/x/oauth2\",\n+\t\t\t\"revision\": \"65a8d08c6292395d47053be10b3c5e91960def76\",\n+\t\t\t\"revisionTime\": \"2016-06-07T03:33:14Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"2rk6lthfQa5Rfydj8j7+dilKGbo=\",\n+\t\t\t\"path\": \"golang.org/x/oauth2/google\",\n+\t\t\t\"revision\": \"65a8d08c6292395d47053be10b3c5e91960def76\",\n+\t\t\t\"revisionTime\": \"2016-06-07T03:33:14Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"W/GiDqzsagBnR7/yEvxatMhUDBs=\",\n+\t\t\t\"path\": \"golang.org/x/oauth2/internal\",\n+\t\t\t\"revision\": \"65a8d08c6292395d47053be10b3c5e91960def76\",\n+\t\t\t\"revisionTime\": \"2016-06-07T03:33:14Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"CPTYHWrVL4jA0B1IuC0hvgcE2AQ=\",\n+\t\t\t\"path\": \"golang.org/x/oauth2/jws\",\n+\t\t\t\"revision\": \"65a8d08c6292395d47053be10b3c5e91960def76\",\n+\t\t\t\"revisionTime\": \"2016-06-07T03:33:14Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"xifBSq0Pn6pIoPA/o3tyzq8X4Ds=\",\n+\t\t\t\"path\": \"golang.org/x/oauth2/jwt\",\n+\t\t\t\"revision\": \"65a8d08c6292395d47053be10b3c5e91960def76\",\n+\t\t\t\"revisionTime\": \"2016-06-07T03:33:14Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"aVgPDgwY3/t4J/JOw9H3FVMHqh0=\",\n+\t\t\t\"path\": \"golang.org/x/sys/unix\",\n+\t\t\t\"revision\": \"c200b10b5d5e122be351b67af224adc6128af5bf\",\n+\t\t\t\"revisionTime\": \"2016-10-22T18:22:21Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"fpW2dhGFC6SrVzipJx7fjg2DIH8=\",\n+\t\t\t\"path\": \"golang.org/x/sys/windows\",\n+\t\t\t\"revision\": \"c200b10b5d5e122be351b67af224adc6128af5bf\",\n+\t\t\t\"revisionTime\": \"2016-10-22T18:22:21Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"PjYlbMS0ttyZYlaevvjA/gV3g1c=\",\n+\t\t\t\"path\": \"golang.org/x/sys/windows/registry\",\n+\t\t\t\"revision\": \"c200b10b5d5e122be351b67af224adc6128af5bf\",\n+\t\t\t\"revisionTime\": \"2016-10-22T18:22:21Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"uVlUSSKplihZG7N+QJ6fzDZ4Kh8=\",\n+\t\t\t\"path\": \"golang.org/x/sys/windows/svc/eventlog\",\n+\t\t\t\"revision\": \"c200b10b5d5e122be351b67af224adc6128af5bf\",\n+\t\t\t\"revisionTime\": \"2016-10-22T18:22:21Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"QQpKbWuqvhmxVr/hfEYdWzzcXRM=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/text/cases\",\n+\t\t\t\"path\": \"golang.org/x/text/cases\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"iAsGo/kxvnwILbJVUCd0ZcqZO/Q=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/text/internal/tag\",\n+\t\t\t\"path\": \"golang.org/x/text/internal/tag\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"mQ6PCGHY7K0oPjKbYD8wsTjm/P8=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/text/language\",\n+\t\t\t\"path\": \"golang.org/x/text/language\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"WpeH2TweiuiZAQVTJNO5vyZAQQA=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/text/runes\",\n+\t\t\t\"path\": \"golang.org/x/text/runes\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"1VjEPyjdi0xOiIN/Alkqiad/B/c=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/text/secure/bidirule\",\n+\t\t\t\"path\": \"golang.org/x/text/secure/bidirule\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"FcK7VslktIAWj5jnWVnU2SesBq0=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/text/secure/precis\",\n+\t\t\t\"path\": \"golang.org/x/text/secure/precis\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"nwlu7UTwYbCj9l5f3a7t2ROwNzM=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/text/transform\",\n+\t\t\t\"path\": \"golang.org/x/text/transform\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"nWJ9R1+Xw41f/mM3b7BYtv77CfI=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/text/unicode/bidi\",\n+\t\t\t\"path\": \"golang.org/x/text/unicode/bidi\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"BAZ96wCGUj6HdY9sG60Yw09KWA4=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/text/unicode/norm\",\n+\t\t\t\"path\": \"golang.org/x/text/unicode/norm\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"AZMILKWqLP99UilLgbGZ+uzIVrM=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/golang.org/x/text/width\",\n+\t\t\t\"path\": \"golang.org/x/text/width\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"AjdmRXf0fiy6Bec9mNlsGsmZi1k=\",\n+\t\t\t\"path\": \"google.golang.org/api/compute/v1\",\n+\t\t\t\"revision\": \"63ade871fd3aec1225809d496e81ec91ab76ea29\",\n+\t\t\t\"revisionTime\": \"2016-05-31T06:42:46Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"OtsMVXY89Hc/bBXdDp84atFQawM=\",\n+\t\t\t\"path\": \"google.golang.org/api/gensupport\",\n+\t\t\t\"revision\": \"63ade871fd3aec1225809d496e81ec91ab76ea29\",\n+\t\t\t\"revisionTime\": \"2016-05-31T06:42:46Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"yQREK/OWrz9PLljbr127+xFk6J0=\",\n+\t\t\t\"path\": \"google.golang.org/api/googleapi\",\n+\t\t\t\"revision\": \"63ade871fd3aec1225809d496e81ec91ab76ea29\",\n+\t\t\t\"revisionTime\": \"2016-05-31T06:42:46Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"ii4ET3JHk3vkMUEcg+9t/1RZSUU=\",\n+\t\t\t\"path\": \"google.golang.org/api/googleapi/internal/uritemplates\",\n+\t\t\t\"revision\": \"63ade871fd3aec1225809d496e81ec91ab76ea29\",\n+\t\t\t\"revisionTime\": \"2016-05-31T06:42:46Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"N3KZEuQ9O1QwJXcCJbe7Czwroo4=\",\n+\t\t\t\"path\": \"google.golang.org/appengine\",\n+\t\t\t\"revision\": \"267c27e7492265b84fc6719503b14a1e17975d79\",\n+\t\t\t\"revisionTime\": \"2016-06-21T05:59:22Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"G9Xp1ScdsfcKsw+PcWunivRRP3o=\",\n+\t\t\t\"path\": \"google.golang.org/appengine/internal\",\n+\t\t\t\"revision\": \"267c27e7492265b84fc6719503b14a1e17975d79\",\n+\t\t\t\"revisionTime\": \"2016-06-21T05:59:22Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"x6Thdfyasqd68dWZWqzWWeIfAfI=\",\n+\t\t\t\"path\": \"google.golang.org/appengine/internal/app_identity\",\n+\t\t\t\"revision\": \"267c27e7492265b84fc6719503b14a1e17975d79\",\n+\t\t\t\"revisionTime\": \"2016-06-21T05:59:22Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"TsNO8P0xUlLNyh3Ic/tzSp/fDWM=\",\n+\t\t\t\"path\": \"google.golang.org/appengine/internal/base\",\n+\t\t\t\"revision\": \"267c27e7492265b84fc6719503b14a1e17975d79\",\n+\t\t\t\"revisionTime\": \"2016-06-21T05:59:22Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"5QsV5oLGSfKZqTCVXP6NRz5T4Tw=\",\n+\t\t\t\"path\": \"google.golang.org/appengine/internal/datastore\",\n+\t\t\t\"revision\": \"267c27e7492265b84fc6719503b14a1e17975d79\",\n+\t\t\t\"revisionTime\": \"2016-06-21T05:59:22Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Gep2T9zmVYV8qZfK2gu3zrmG6QE=\",\n+\t\t\t\"path\": \"google.golang.org/appengine/internal/log\",\n+\t\t\t\"revision\": \"267c27e7492265b84fc6719503b14a1e17975d79\",\n+\t\t\t\"revisionTime\": \"2016-06-21T05:59:22Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"eLZVX1EHLclFtQnjDIszsdyWRHo=\",\n+\t\t\t\"path\": \"google.golang.org/appengine/internal/modules\",\n+\t\t\t\"revision\": \"267c27e7492265b84fc6719503b14a1e17975d79\",\n+\t\t\t\"revisionTime\": \"2016-06-21T05:59:22Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"a1XY7rz3BieOVqVI2Et6rKiwQCk=\",\n+\t\t\t\"path\": \"google.golang.org/appengine/internal/remote_api\",\n+\t\t\t\"revision\": \"4f7eeb5305a4ba1966344836ba4af9996b7b4e05\",\n+\t\t\t\"revisionTime\": \"2016-08-19T23:33:10Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"QtAbHtHmDzcf6vOV9eqlCpKgjiw=\",\n+\t\t\t\"path\": \"google.golang.org/appengine/internal/urlfetch\",\n+\t\t\t\"revision\": \"267c27e7492265b84fc6719503b14a1e17975d79\",\n+\t\t\t\"revisionTime\": \"2016-06-21T05:59:22Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"akOV9pYnCbcPA8wJUutSQVibdyg=\",\n+\t\t\t\"path\": \"google.golang.org/appengine/urlfetch\",\n+\t\t\t\"revision\": \"267c27e7492265b84fc6719503b14a1e17975d79\",\n+\t\t\t\"revisionTime\": \"2016-06-21T05:59:22Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Wp8g9MHRmK8SwcyGVCoGtPx+5Lo=\",\n+\t\t\t\"path\": \"google.golang.org/cloud/compute/metadata\",\n+\t\t\t\"revision\": \"0a83eba2cadb60eb22123673c8fb6fca02b03c94\",\n+\t\t\t\"revisionTime\": \"2016-06-21T15:59:29Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"U7dGDNwEHORvJFMoNSXErKE7ITg=\",\n+\t\t\t\"path\": \"google.golang.org/cloud/internal\",\n+\t\t\t\"revision\": \"0a83eba2cadb60eb22123673c8fb6fca02b03c94\",\n+\t\t\t\"revisionTime\": \"2016-06-21T15:59:29Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"JfVmsMwyeeepbdw4q4wpN07BuFg=\",\n+\t\t\t\"path\": \"gopkg.in/fsnotify.v1\",\n+\t\t\t\"revision\": \"30411dbcefb7a1da7e84f75530ad3abe4011b4f8\",\n+\t\t\t\"revisionTime\": \"2016-04-12T13:37:56Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"pfQwQtWlFezJq0Viroa/L+v+yDM=\",\n+\t\t\t\"origin\": \"k8s.io/client-go/1.5/vendor/gopkg.in/inf.v0\",\n+\t\t\t\"path\": \"gopkg.in/inf.v0\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"KgT+peLCcuh0/m2mpoOZXuxXmwc=\",\n+\t\t\t\"path\": \"gopkg.in/yaml.v2\",\n+\t\t\t\"revision\": \"7ad95dd0798a40da1ccdff6dff35fd177b5edf40\",\n+\t\t\t\"revisionTime\": \"2015-06-24T11:29:02+01:00\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"st0Nbu4zwLcP3mz03lDOJVZtn8Y=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/discovery\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"S+OzpkipMb46LGZoWuveqSLAcoM=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"yCBn8ig1TUMrk+ljtK0nDr7E5Vo=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes/typed/apps/v1alpha1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"ZRnUz5NrpvJsXAjtnRdEv5UYhSI=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes/typed/authentication/v1beta1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"TY55Np20olmPMzXgfVlIUIyqv04=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes/typed/authorization/v1beta1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"FRByJsFff/6lPH20FtJPaK1NPWI=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes/typed/autoscaling/v1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"3Cy2as7HnQ2FDcvpNbatpFWx0P4=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes/typed/batch/v1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"RUKywApIbSLLsfkYxXzifh7HIvs=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes/typed/certificates/v1alpha1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"4+Lsxu+sYgzsS2JOHP7CdrZLSKc=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes/typed/core/v1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"H8jzevN03YUfmf2krJt0qj2P9sU=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes/typed/extensions/v1beta1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"hrpA6xxtwj3oMcQbFxI2cDhO2ZA=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes/typed/policy/v1alpha1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"B2+F12NeMwrOHvHK2ALyEcr3UGA=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes/typed/rbac/v1alpha1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"h2eSNUym87RWPlez7UKujShwrUQ=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/kubernetes/typed/storage/v1beta1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"+oIykJ3A0wYjAWbbrGo0jNnMLXw=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/api\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"UsUsIdhuy5Ej2vI0hbmSsrimoaQ=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/api/errors\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Eo6LLHFqG6YznIAKr2mVjuqUj6k=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/api/install\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"dYznkLcCEai21z1dX8kZY7uDsck=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/api/meta\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"b06esG4xMj/YNFD85Lqq00cx+Yo=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/api/meta/metatypes\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"L9svak1yut0Mx8r9VLDOwpqZzBk=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/api/resource\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"m7jGshKDLH9kdokfa6MwAqzxRQk=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/api/unversioned\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"iI6s5WAexr1PEfqrbvuscB+oVik=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/api/v1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"ikac34qI/IkTWHnfi8pPl9irPyo=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/api/validation/path\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"MJyygSPp8N6z+7SPtcROz4PEwas=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apimachinery\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"EGb4IcSTQ1VXCmX0xcyG5GpWId8=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apimachinery/announced\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"vhSyuINHQhCsDKTyBmvJT1HzDHI=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apimachinery/registered\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"rXeBnwLg8ZFe6m5/Ki7tELVBYDk=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/apps\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"KzHaG858KV1tBh5cuLInNcm+G5s=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/apps/install\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"fynWdchlRbPaxuST2oGDKiKLTqE=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/apps/v1alpha1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"hreIYssoH4Ef/+Aglpitn3GNLR4=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/authentication\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"EgUqJH4CqB9vXVg6T8II2OEt5LE=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/authentication/install\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Z3DKgomzRPGcBv/8hlL6pfnIpXI=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/authentication/v1beta1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"GpuScB2Z+NOT4WIQg1mVvVSDUts=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/authorization\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"+u3UD+HY9lBH+PFi/2B4W564JEw=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/authorization/install\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"zIFzgWjmlWNLHGHMpCpDCvoLtKY=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/authorization/v1beta1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"tdpzQFQyVkt5kCLTvtKTVqT+maE=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/autoscaling\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"nb6LbYGS5tv8H8Ovptg6M7XuDZ4=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/autoscaling/install\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"DNb1/nl/5RDdckRrJoXBRagzJXs=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/autoscaling/v1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"4bLhH2vNl5l4Qp6MjLhWyWVAPE0=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/batch\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"RpAAEynmxlvOlLLZK1KEUQRnYzk=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/batch/install\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"uWJ2BHmjL/Gq4FFlNkqiN6vvPyM=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/batch/v1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"mHWt/p724dKeP1vqLtWQCye7zaE=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/batch/v2alpha1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"6dJ1dGfXkB3A42TOtMaY/rvv4N8=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/certificates\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Bkrhm6HbFYANwtzUE8eza9SWBk0=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/certificates/install\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"nRRPIBQ5O3Ad24kscNtK+gPC+fk=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/certificates/v1alpha1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"KUMhoaOg9GXHN/aAVvSLO18SgqU=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/extensions\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"eSo2VhNAYtesvmpEPqn05goW4LY=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/extensions/install\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"DunWIPrCC5iGMWzkaaugMOxD+hg=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/extensions/v1beta1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"rVGYi2ko0E7vL5OZSMYX+NAGPYw=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/policy\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"llJHd2H0LzABGB6BcletzIHnexo=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/policy/install\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"j44bqyY13ldnuCtysYE8nRkMD7o=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/policy/v1alpha1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"vT7rFxowcKMTYc55mddePqUFRgE=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/rbac\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"r1MzUXsG+Zyn30aU8I5R5dgrJPA=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/rbac/install\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"aNfO8xn8VDO3fM9CpVCe6EIB+GA=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/rbac/v1alpha1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"rQCxrbisCXmj2wymlYG63kcTL9I=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/storage\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"wZyxh5nt5Eh6kF7YNAIYukKWWy0=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/storage/install\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"P8ANOt/I4Cs3QtjVXWmDA/gpQdg=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/apis/storage/v1beta1\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"qnVPwzvNLz2mmr3BXdU9qIhQXXU=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/auth/user\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"KrIchxhapSs242yAy8yrTS1XlZo=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/conversion\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"weZqKFcOhcnF47eDDHXzluCKSF0=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/conversion/queryparams\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"T3EMfyXZX5939/OOQ1JU+Nmbk4k=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/fields\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"2v11s3EBH8UBl2qfImT29tQN2kM=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/genericapiserver/openapi/common\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"GvBlph6PywK3zguou/T9kKNNdoQ=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/labels\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Vtrgy827r0rWzIAgvIWY4flu740=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/runtime\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"SEcZqRATexhgHvDn+eHvMc07UJs=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/runtime/serializer\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"qzYKG9YZSj8l/W1QVTOrGAry/BM=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/runtime/serializer/json\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"F7h+8zZ0JPLYkac4KgSVljguBE4=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/runtime/serializer/protobuf\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"CvySOL8C85e3y7EWQ+Au4cwUZJM=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/runtime/serializer/recognizer\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"eCitoKeIun+lJzYFhAfdSIIicSM=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/runtime/serializer/streaming\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"kVWvZuLGltJ4YqQsiaCLRRLDDK0=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/runtime/serializer/versioning\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"m51+LAeQ9RK1KHX+l2iGcwbVCKs=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/selection\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"dp4IWcC3U6a0HeOdVCDQWODWCbw=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/third_party/forked/golang/reflect\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"ER898XJD1ox4d71gKZD8TLtTSpM=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/types\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"BVdXtnLDlmBQksRPfHOIG+qdeVg=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"nnh8Sa4dCupxRI4bbKaozGp1d/A=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/cert\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"S32d5uduNlwouM8+mIz+ALpliUQ=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/clock\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Y6rWC0TUw2/uUeUjJ7kazyEUzBQ=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/errors\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"C7IfEAdCOePw3/IraaZCNXuYXLw=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/flowcontrol\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"EuslQHnhBSRXaWimYqLEqhMPV48=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/framer\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"ByO18NbZwiifFr8qtLyfJAHXguA=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/integer\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"ww+RfsoIlUBDwThg2oqC5QVz33Y=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/intstr\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"7E8f8dLlXW7u6r9sggMjvB4HEiw=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/json\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"d0pFZxMJG9j95acNmaIM1l+X+QU=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/labels\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"wCN7u1lE+25neM9jXeI7aE8EAfk=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/net\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"g+kBkxcb+tYmFtRRly+VE+JAIfw=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/parsers\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"S4wUnE5VkaWWrkLbgPL/1oNLJ4g=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/rand\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"8j9c2PqTKybtnymXbStNYRexRj8=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/runtime\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"aAz4e8hLGs0+ZAz1TdA5tY/9e1A=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/sets\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"P/fwh6QZ5tsjVyHTaASDWL3WaGs=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/uuid\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"P9Bq/1qbF4SvnN9HyCTRpbUz7sQ=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/validation\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"D0JIEjlP69cuPOZEdsSKeFgsnI8=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/validation/field\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"T7ba8t8i+BtgClMgL+aMZM94fcI=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/wait\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"6RCTv/KDiw7as4KeyrgU3XrUSQI=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/util/yaml\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"OwKlsSeKtz1FBVC9cQ5gWRL5pKc=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/version\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Oil9WGw/dODbpBopn6LWQGS3DYg=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/watch\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"r5alnRCbLaPsbTeJjjTVn/bt6uw=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/pkg/watch/versioned\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"X1+ltyfHui/XCwDupXIf39+9gWQ=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/plugin/pkg/client/auth\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"KYy+js37AS0ZT08g5uBr1ZoMPmE=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/plugin/pkg/client/auth/gcp\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"wQ9G5++lbQpejqCzGHo037N3YcY=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/plugin/pkg/client/auth/oidc\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"ABe8YfZVEDoRpAUqp2BKP8o1VIA=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/rest\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"Gbe0Vs9hkI7X5hhbXUuWdRFffSI=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/tools/cache\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"K/oOznXABjqSS1c2Fs407c5F8KA=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/tools/clientcmd/api\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"c1PQ4WJRfpA9BYcFHW2+46hu5IE=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/tools/metrics\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t},\n+\t\t{\n+\t\t\t\"checksumSHA1\": \"e4W2q+6wvjejv3V0UCI1mewTTro=\",\n+\t\t\t\"path\": \"k8s.io/client-go/1.5/transport\",\n+\t\t\t\"revision\": \"c589d0c9f0d81640c518354c7bcae77d99820aa3\",\n+\t\t\t\"revisionTime\": \"2016-09-30T00:14:02Z\"\n+\t\t}\n+\t],\n+\t\"rootPath\": \"github.com/prometheus/prometheus\"\n+}"}, {"sha": "be77bcb9284e4cb424f5677134cf15764ff1f9d9", "filename": "libgo/go/cmd/go/internal/modconv/testdata/upspin.dep", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fupspin.dep", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fupspin.dep", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fupspin.dep?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,57 @@\n+# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n+\n+\n+[[projects]]\n+  branch = \"master\"\n+  name = \"bazil.org/fuse\"\n+  packages = [\".\",\"fs\",\"fuseutil\"]\n+  revision = \"371fbbdaa8987b715bdd21d6adc4c9b20155f748\"\n+\n+[[projects]]\n+  branch = \"master\"\n+  name = \"github.com/NYTimes/gziphandler\"\n+  packages = [\".\"]\n+  revision = \"97ae7fbaf81620fe97840685304a78a306a39c64\"\n+\n+[[projects]]\n+  branch = \"master\"\n+  name = \"github.com/golang/protobuf\"\n+  packages = [\"proto\"]\n+  revision = \"1643683e1b54a9e88ad26d98f81400c8c9d9f4f9\"\n+\n+[[projects]]\n+  branch = \"master\"\n+  name = \"github.com/russross/blackfriday\"\n+  packages = [\".\"]\n+  revision = \"6d1ef893fcb01b4f50cb6e57ed7df3e2e627b6b2\"\n+\n+[[projects]]\n+  branch = \"master\"\n+  name = \"golang.org/x/crypto\"\n+  packages = [\"acme\",\"acme/autocert\",\"hkdf\"]\n+  revision = \"13931e22f9e72ea58bb73048bc752b48c6d4d4ac\"\n+\n+[[projects]]\n+  branch = \"master\"\n+  name = \"golang.org/x/net\"\n+  packages = [\"context\"]\n+  revision = \"4b14673ba32bee7f5ac0f990a48f033919fd418b\"\n+\n+[[projects]]\n+  branch = \"master\"\n+  name = \"golang.org/x/text\"\n+  packages = [\"cases\",\"internal\",\"internal/gen\",\"internal/tag\",\"internal/triegen\",\"internal/ucd\",\"language\",\"runes\",\"secure/bidirule\",\"secure/precis\",\"transform\",\"unicode/bidi\",\"unicode/cldr\",\"unicode/norm\",\"unicode/rangetable\",\"width\"]\n+  revision = \"6eab0e8f74e86c598ec3b6fad4888e0c11482d48\"\n+\n+[[projects]]\n+  branch = \"v2\"\n+  name = \"gopkg.in/yaml.v2\"\n+  packages = [\".\"]\n+  revision = \"eb3733d160e74a9c7e442f435eb3bea458e1d19f\"\n+\n+[solve-meta]\n+  analyzer-name = \"dep\"\n+  analyzer-version = 1\n+  inputs-digest = \"2246e647ba1c78b0b9f948f9fb072fff1467284fb138709c063e99736f646b90\"\n+  solver-name = \"gps-cdcl\"\n+  solver-version = 1"}, {"sha": "00597db84844a6759991351f507d212507989d40", "filename": "libgo/go/cmd/go/internal/modconv/testdata/upspin.out", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fupspin.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fupspin.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Fupspin.out?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,8 @@\n+bazil.org/fuse 371fbbdaa8987b715bdd21d6adc4c9b20155f748\n+github.com/NYTimes/gziphandler 97ae7fbaf81620fe97840685304a78a306a39c64\n+github.com/golang/protobuf 1643683e1b54a9e88ad26d98f81400c8c9d9f4f9\n+github.com/russross/blackfriday 6d1ef893fcb01b4f50cb6e57ed7df3e2e627b6b2\n+golang.org/x/crypto 13931e22f9e72ea58bb73048bc752b48c6d4d4ac\n+golang.org/x/net 4b14673ba32bee7f5ac0f990a48f033919fd418b\n+golang.org/x/text 6eab0e8f74e86c598ec3b6fad4888e0c11482d48\n+gopkg.in/yaml.v2 eb3733d160e74a9c7e442f435eb3bea458e1d19f"}, {"sha": "feba181e052252ed2b2c8cbe7e032080792b802f", "filename": "libgo/go/cmd/go/internal/modconv/tsv.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftsv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftsv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftsv.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+func ParseDependenciesTSV(file string, data []byte) (*modfile.File, error) {\n+\tmf := new(modfile.File)\n+\tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n+\t\tlineno++\n+\t\tf := strings.Split(line, \"\\t\")\n+\t\tif len(f) >= 3 {\n+\t\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: module.Version{Path: f[0], Version: f[2]}})\n+\t\t}\n+\t}\n+\treturn mf, nil\n+}"}, {"sha": "a9a8e62518f279e546300a6503f78e4b4cf30e51", "filename": "libgo/go/cmd/go/internal/modconv/vconf.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvconf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvconf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvconf.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+func ParseVendorConf(file string, data []byte) (*modfile.File, error) {\n+\tmf := new(modfile.File)\n+\tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n+\t\tlineno++\n+\t\tif i := strings.Index(line, \"#\"); i >= 0 {\n+\t\t\tline = line[:i]\n+\t\t}\n+\t\tf := strings.Fields(line)\n+\t\tif len(f) >= 2 {\n+\t\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: module.Version{Path: f[0], Version: f[1]}})\n+\t\t}\n+\t}\n+\treturn mf, nil\n+}"}, {"sha": "eec86b733985d1263927026c32fbdf0514d9cc13", "filename": "libgo/go/cmd/go/internal/modconv/vjson.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvjson.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvjson.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvjson.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"encoding/json\"\n+\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+func ParseVendorJSON(file string, data []byte) (*modfile.File, error) {\n+\tvar cfg struct {\n+\t\tPackage []struct {\n+\t\t\tPath     string\n+\t\t\tRevision string\n+\t\t}\n+\t}\n+\tif err := json.Unmarshal(data, &cfg); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tmf := new(modfile.File)\n+\tfor _, d := range cfg.Package {\n+\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: module.Version{Path: d.Path, Version: d.Revision}})\n+\t}\n+\treturn mf, nil\n+}"}, {"sha": "c0ef2a98622e97fa497e6bbdfbba3c594446df78", "filename": "libgo/go/cmd/go/internal/modconv/vmanifest.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvmanifest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvmanifest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvmanifest.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"encoding/json\"\n+\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+func ParseVendorManifest(file string, data []byte) (*modfile.File, error) {\n+\tvar cfg struct {\n+\t\tDependencies []struct {\n+\t\t\tImportPath string\n+\t\t\tRevision   string\n+\t\t}\n+\t}\n+\tif err := json.Unmarshal(data, &cfg); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tmf := new(modfile.File)\n+\tfor _, d := range cfg.Dependencies {\n+\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: module.Version{Path: d.ImportPath, Version: d.Revision}})\n+\t}\n+\treturn mf, nil\n+}"}, {"sha": "0f017a3c7a6b3109c0cd20c862e0436a3ff1812e", "filename": "libgo/go/cmd/go/internal/modconv/vyml.go", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvyml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvyml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvyml.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modconv\n+\n+import (\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/modfile\"\n+\t\"cmd/go/internal/module\"\n+)\n+\n+func ParseVendorYML(file string, data []byte) (*modfile.File, error) {\n+\tmf := new(modfile.File)\n+\tvendors := false\n+\tpath := \"\"\n+\tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n+\t\tlineno++\n+\t\tif line == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.HasPrefix(line, \"vendors:\") {\n+\t\t\tvendors = true\n+\t\t} else if line[0] != '-' && line[0] != ' ' && line[0] != '\\t' {\n+\t\t\tvendors = false\n+\t\t}\n+\t\tif !vendors {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.HasPrefix(line, \"- path:\") {\n+\t\t\tpath = strings.TrimSpace(line[len(\"- path:\"):])\n+\t\t}\n+\t\tif strings.HasPrefix(line, \"  rev:\") {\n+\t\t\trev := strings.TrimSpace(line[len(\"  rev:\"):])\n+\t\t\tif path != \"\" && rev != \"\" {\n+\t\t\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: module.Version{Path: path, Version: rev}})\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn mf, nil\n+}"}, {"sha": "1f9cc96c3ec80858ff299b959e9b715438333596", "filename": "libgo/go/cmd/go/internal/modfetch/cache.go", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,522 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modfetch\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modfetch/codehost\"\n+\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/par\"\n+\t\"cmd/go/internal/semver\"\n+)\n+\n+var QuietLookup bool // do not print about lookups\n+\n+var PkgMod string // $GOPATH/pkg/mod; set by package modload\n+\n+func cacheDir(path string) (string, error) {\n+\tif PkgMod == \"\" {\n+\t\treturn \"\", fmt.Errorf(\"internal error: modfetch.PkgMod not set\")\n+\t}\n+\tenc, err := module.EncodePath(path)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn filepath.Join(PkgMod, \"cache/download\", enc, \"/@v\"), nil\n+}\n+\n+func CachePath(m module.Version, suffix string) (string, error) {\n+\tdir, err := cacheDir(m.Path)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif !semver.IsValid(m.Version) {\n+\t\treturn \"\", fmt.Errorf(\"non-semver module version %q\", m.Version)\n+\t}\n+\tif module.CanonicalVersion(m.Version) != m.Version {\n+\t\treturn \"\", fmt.Errorf(\"non-canonical module version %q\", m.Version)\n+\t}\n+\tencVer, err := module.EncodeVersion(m.Version)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn filepath.Join(dir, encVer+\".\"+suffix), nil\n+}\n+\n+func DownloadDir(m module.Version) (string, error) {\n+\tif PkgMod == \"\" {\n+\t\treturn \"\", fmt.Errorf(\"internal error: modfetch.PkgMod not set\")\n+\t}\n+\tenc, err := module.EncodePath(m.Path)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif !semver.IsValid(m.Version) {\n+\t\treturn \"\", fmt.Errorf(\"non-semver module version %q\", m.Version)\n+\t}\n+\tif module.CanonicalVersion(m.Version) != m.Version {\n+\t\treturn \"\", fmt.Errorf(\"non-canonical module version %q\", m.Version)\n+\t}\n+\tencVer, err := module.EncodeVersion(m.Version)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn filepath.Join(PkgMod, enc+\"@\"+encVer), nil\n+}\n+\n+// A cachingRepo is a cache around an underlying Repo,\n+// avoiding redundant calls to ModulePath, Versions, Stat, Latest, and GoMod (but not Zip).\n+// It is also safe for simultaneous use by multiple goroutines\n+// (so that it can be returned from Lookup multiple times).\n+// It serializes calls to the underlying Repo.\n+type cachingRepo struct {\n+\tpath  string\n+\tcache par.Cache // cache for all operations\n+\tr     Repo\n+}\n+\n+func newCachingRepo(r Repo) *cachingRepo {\n+\treturn &cachingRepo{\n+\t\tr:    r,\n+\t\tpath: r.ModulePath(),\n+\t}\n+}\n+\n+func (r *cachingRepo) ModulePath() string {\n+\treturn r.path\n+}\n+\n+func (r *cachingRepo) Versions(prefix string) ([]string, error) {\n+\ttype cached struct {\n+\t\tlist []string\n+\t\terr  error\n+\t}\n+\tc := r.cache.Do(\"versions:\"+prefix, func() interface{} {\n+\t\tlist, err := r.r.Versions(prefix)\n+\t\treturn cached{list, err}\n+\t}).(cached)\n+\n+\tif c.err != nil {\n+\t\treturn nil, c.err\n+\t}\n+\treturn append([]string(nil), c.list...), nil\n+}\n+\n+type cachedInfo struct {\n+\tinfo *RevInfo\n+\terr  error\n+}\n+\n+func (r *cachingRepo) Stat(rev string) (*RevInfo, error) {\n+\tc := r.cache.Do(\"stat:\"+rev, func() interface{} {\n+\t\tfile, info, err := readDiskStat(r.path, rev)\n+\t\tif err == nil {\n+\t\t\treturn cachedInfo{info, nil}\n+\t\t}\n+\n+\t\tif !QuietLookup {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: finding %s %s\\n\", r.path, rev)\n+\t\t}\n+\t\tinfo, err = r.r.Stat(rev)\n+\t\tif err == nil {\n+\t\t\tif err := writeDiskStat(file, info); err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: writing stat cache: %v\\n\", err)\n+\t\t\t}\n+\t\t\t// If we resolved, say, 1234abcde to v0.0.0-20180604122334-1234abcdef78,\n+\t\t\t// then save the information under the proper version, for future use.\n+\t\t\tif info.Version != rev {\n+\t\t\t\tr.cache.Do(\"stat:\"+info.Version, func() interface{} {\n+\t\t\t\t\treturn cachedInfo{info, err}\n+\t\t\t\t})\n+\t\t\t}\n+\t\t}\n+\t\treturn cachedInfo{info, err}\n+\t}).(cachedInfo)\n+\n+\tif c.err != nil {\n+\t\treturn nil, c.err\n+\t}\n+\tinfo := *c.info\n+\treturn &info, nil\n+}\n+\n+func (r *cachingRepo) Latest() (*RevInfo, error) {\n+\tc := r.cache.Do(\"latest:\", func() interface{} {\n+\t\tif !QuietLookup {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: finding %s latest\\n\", r.path)\n+\t\t}\n+\t\tinfo, err := r.r.Latest()\n+\n+\t\t// Save info for likely future Stat call.\n+\t\tif err == nil {\n+\t\t\tr.cache.Do(\"stat:\"+info.Version, func() interface{} {\n+\t\t\t\treturn cachedInfo{info, err}\n+\t\t\t})\n+\t\t\tif file, _, err := readDiskStat(r.path, info.Version); err != nil {\n+\t\t\t\twriteDiskStat(file, info)\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn cachedInfo{info, err}\n+\t}).(cachedInfo)\n+\n+\tif c.err != nil {\n+\t\treturn nil, c.err\n+\t}\n+\tinfo := *c.info\n+\treturn &info, nil\n+}\n+\n+func (r *cachingRepo) GoMod(rev string) ([]byte, error) {\n+\ttype cached struct {\n+\t\ttext []byte\n+\t\terr  error\n+\t}\n+\tc := r.cache.Do(\"gomod:\"+rev, func() interface{} {\n+\t\tfile, text, err := readDiskGoMod(r.path, rev)\n+\t\tif err == nil {\n+\t\t\t// Note: readDiskGoMod already called checkGoMod.\n+\t\t\treturn cached{text, nil}\n+\t\t}\n+\n+\t\t// Convert rev to canonical version\n+\t\t// so that we use the right identifier in the go.sum check.\n+\t\tinfo, err := r.Stat(rev)\n+\t\tif err != nil {\n+\t\t\treturn cached{nil, err}\n+\t\t}\n+\t\trev = info.Version\n+\n+\t\ttext, err = r.r.GoMod(rev)\n+\t\tif err == nil {\n+\t\t\tcheckGoMod(r.path, rev, text)\n+\t\t\tif err := writeDiskGoMod(file, text); err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: writing go.mod cache: %v\\n\", err)\n+\t\t\t}\n+\t\t}\n+\t\treturn cached{text, err}\n+\t}).(cached)\n+\n+\tif c.err != nil {\n+\t\treturn nil, c.err\n+\t}\n+\treturn append([]byte(nil), c.text...), nil\n+}\n+\n+func (r *cachingRepo) Zip(version, tmpdir string) (string, error) {\n+\treturn r.r.Zip(version, tmpdir)\n+}\n+\n+// Stat is like Lookup(path).Stat(rev) but avoids the\n+// repository path resolution in Lookup if the result is\n+// already cached on local disk.\n+func Stat(path, rev string) (*RevInfo, error) {\n+\t_, info, err := readDiskStat(path, rev)\n+\tif err == nil {\n+\t\treturn info, nil\n+\t}\n+\trepo, err := Lookup(path)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn repo.Stat(rev)\n+}\n+\n+// InfoFile is like Stat but returns the name of the file containing\n+// the cached information.\n+func InfoFile(path, version string) (string, error) {\n+\tif !semver.IsValid(version) {\n+\t\treturn \"\", fmt.Errorf(\"invalid version %q\", version)\n+\t}\n+\tif _, err := Stat(path, version); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\t// Stat should have populated the disk cache for us.\n+\tfile, _, err := readDiskStat(path, version)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn file, nil\n+}\n+\n+// GoMod is like Lookup(path).GoMod(rev) but avoids the\n+// repository path resolution in Lookup if the result is\n+// already cached on local disk.\n+func GoMod(path, rev string) ([]byte, error) {\n+\t// Convert commit hash to pseudo-version\n+\t// to increase cache hit rate.\n+\tif !semver.IsValid(rev) {\n+\t\tinfo, err := Stat(path, rev)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\trev = info.Version\n+\t}\n+\t_, data, err := readDiskGoMod(path, rev)\n+\tif err == nil {\n+\t\treturn data, nil\n+\t}\n+\trepo, err := Lookup(path)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn repo.GoMod(rev)\n+}\n+\n+// GoModFile is like GoMod but returns the name of the file containing\n+// the cached information.\n+func GoModFile(path, version string) (string, error) {\n+\tif !semver.IsValid(version) {\n+\t\treturn \"\", fmt.Errorf(\"invalid version %q\", version)\n+\t}\n+\tif _, err := GoMod(path, version); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\t// GoMod should have populated the disk cache for us.\n+\tfile, _, err := readDiskGoMod(path, version)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn file, nil\n+}\n+\n+// GoModSum returns the go.sum entry for the module version's go.mod file.\n+// (That is, it returns the entry listed in go.sum as \"path version/go.mod\".)\n+func GoModSum(path, version string) (string, error) {\n+\tif !semver.IsValid(version) {\n+\t\treturn \"\", fmt.Errorf(\"invalid version %q\", version)\n+\t}\n+\tdata, err := GoMod(path, version)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tsum, err := goModSum(data)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn sum, nil\n+}\n+\n+var errNotCached = fmt.Errorf(\"not in cache\")\n+\n+// readDiskStat reads a cached stat result from disk,\n+// returning the name of the cache file and the result.\n+// If the read fails, the caller can use\n+// writeDiskStat(file, info) to write a new cache entry.\n+func readDiskStat(path, rev string) (file string, info *RevInfo, err error) {\n+\tfile, data, err := readDiskCache(path, rev, \"info\")\n+\tif err != nil {\n+\t\tif file, info, err := readDiskStatByHash(path, rev); err == nil {\n+\t\t\treturn file, info, nil\n+\t\t}\n+\t\treturn file, nil, err\n+\t}\n+\tinfo = new(RevInfo)\n+\tif err := json.Unmarshal(data, info); err != nil {\n+\t\treturn file, nil, errNotCached\n+\t}\n+\t// The disk might have stale .info files that have Name and Short fields set.\n+\t// We want to canonicalize to .info files with those fields omitted.\n+\t// Remarshal and update the cache file if needed.\n+\tdata2, err := json.Marshal(info)\n+\tif err == nil && !bytes.Equal(data2, data) {\n+\t\twriteDiskCache(file, data)\n+\t}\n+\treturn file, info, nil\n+}\n+\n+// readDiskStatByHash is a fallback for readDiskStat for the case\n+// where rev is a commit hash instead of a proper semantic version.\n+// In that case, we look for a cached pseudo-version that matches\n+// the commit hash. If we find one, we use it.\n+// This matters most for converting legacy package management\n+// configs, when we are often looking up commits by full hash.\n+// Without this check we'd be doing network I/O to the remote repo\n+// just to find out about a commit we already know about\n+// (and have cached under its pseudo-version).\n+func readDiskStatByHash(path, rev string) (file string, info *RevInfo, err error) {\n+\tif PkgMod == \"\" {\n+\t\t// Do not download to current directory.\n+\t\treturn \"\", nil, errNotCached\n+\t}\n+\n+\tif !codehost.AllHex(rev) || len(rev) < 12 {\n+\t\treturn \"\", nil, errNotCached\n+\t}\n+\trev = rev[:12]\n+\tcdir, err := cacheDir(path)\n+\tif err != nil {\n+\t\treturn \"\", nil, errNotCached\n+\t}\n+\tdir, err := os.Open(cdir)\n+\tif err != nil {\n+\t\treturn \"\", nil, errNotCached\n+\t}\n+\tnames, err := dir.Readdirnames(-1)\n+\tdir.Close()\n+\tif err != nil {\n+\t\treturn \"\", nil, errNotCached\n+\t}\n+\tsuffix := \"-\" + rev + \".info\"\n+\tfor _, name := range names {\n+\t\tif strings.HasSuffix(name, suffix) && IsPseudoVersion(strings.TrimSuffix(name, \".info\")) {\n+\t\t\treturn readDiskStat(path, strings.TrimSuffix(name, \".info\"))\n+\t\t}\n+\t}\n+\treturn \"\", nil, errNotCached\n+}\n+\n+// oldVgoPrefix is the prefix in the old auto-generated cached go.mod files.\n+// We stopped trying to auto-generate the go.mod files. Now we use a trivial\n+// go.mod with only a module line, and we've dropped the version prefix\n+// entirely. If we see a version prefix, that means we're looking at an old copy\n+// and should ignore it.\n+var oldVgoPrefix = []byte(\"//vgo 0.0.\")\n+\n+// readDiskGoMod reads a cached stat result from disk,\n+// returning the name of the cache file and the result.\n+// If the read fails, the caller can use\n+// writeDiskGoMod(file, data) to write a new cache entry.\n+func readDiskGoMod(path, rev string) (file string, data []byte, err error) {\n+\tfile, data, err = readDiskCache(path, rev, \"mod\")\n+\n+\t// If the file has an old auto-conversion prefix, pretend it's not there.\n+\tif bytes.HasPrefix(data, oldVgoPrefix) {\n+\t\terr = errNotCached\n+\t\tdata = nil\n+\t}\n+\n+\tif err == nil {\n+\t\tcheckGoMod(path, rev, data)\n+\t}\n+\n+\treturn file, data, err\n+}\n+\n+// readDiskCache is the generic \"read from a cache file\" implementation.\n+// It takes the revision and an identifying suffix for the kind of data being cached.\n+// It returns the name of the cache file and the content of the file.\n+// If the read fails, the caller can use\n+// writeDiskCache(file, data) to write a new cache entry.\n+func readDiskCache(path, rev, suffix string) (file string, data []byte, err error) {\n+\tfile, err = CachePath(module.Version{Path: path, Version: rev}, suffix)\n+\tif err != nil {\n+\t\treturn \"\", nil, errNotCached\n+\t}\n+\tdata, err = ioutil.ReadFile(file)\n+\tif err != nil {\n+\t\treturn file, nil, errNotCached\n+\t}\n+\treturn file, data, nil\n+}\n+\n+// writeDiskStat writes a stat result cache entry.\n+// The file name must have been returned by a previous call to readDiskStat.\n+func writeDiskStat(file string, info *RevInfo) error {\n+\tif file == \"\" {\n+\t\treturn nil\n+\t}\n+\tjs, err := json.Marshal(info)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn writeDiskCache(file, js)\n+}\n+\n+// writeDiskGoMod writes a go.mod cache entry.\n+// The file name must have been returned by a previous call to readDiskGoMod.\n+func writeDiskGoMod(file string, text []byte) error {\n+\treturn writeDiskCache(file, text)\n+}\n+\n+// writeDiskCache is the generic \"write to a cache file\" implementation.\n+// The file must have been returned by a previous call to readDiskCache.\n+func writeDiskCache(file string, data []byte) error {\n+\tif file == \"\" {\n+\t\treturn nil\n+\t}\n+\t// Make sure directory for file exists.\n+\tif err := os.MkdirAll(filepath.Dir(file), 0777); err != nil {\n+\t\treturn err\n+\t}\n+\t// Write data to temp file next to target file.\n+\tf, err := ioutil.TempFile(filepath.Dir(file), filepath.Base(file)+\".tmp-\")\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer os.Remove(f.Name())\n+\tdefer f.Close()\n+\tif _, err := f.Write(data); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := f.Close(); err != nil {\n+\t\treturn err\n+\t}\n+\t// Rename temp file onto cache file,\n+\t// so that the cache file is always a complete file.\n+\tif err := os.Rename(f.Name(), file); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif strings.HasSuffix(file, \".mod\") {\n+\t\trewriteVersionList(filepath.Dir(file))\n+\t}\n+\treturn nil\n+}\n+\n+// rewriteVersionList rewrites the version list in dir\n+// after a new *.mod file has been written.\n+func rewriteVersionList(dir string) {\n+\tif filepath.Base(dir) != \"@v\" {\n+\t\tbase.Fatalf(\"go: internal error: misuse of rewriteVersionList\")\n+\t}\n+\n+\t// TODO(rsc): We should do some kind of directory locking here,\n+\t// to avoid lost updates.\n+\n+\tinfos, err := ioutil.ReadDir(dir)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar list []string\n+\tfor _, info := range infos {\n+\t\t// We look for *.mod files on the theory that if we can't supply\n+\t\t// the .mod file then there's no point in listing that version,\n+\t\t// since it's unusable. (We can have *.info without *.mod.)\n+\t\t// We don't require *.zip files on the theory that for code only\n+\t\t// involved in module graph construction, many *.zip files\n+\t\t// will never be requested.\n+\t\tname := info.Name()\n+\t\tif strings.HasSuffix(name, \".mod\") {\n+\t\t\tv := strings.TrimSuffix(name, \".mod\")\n+\t\t\tif v != \"\" && module.CanonicalVersion(v) == v {\n+\t\t\t\tlist = append(list, v)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tSortVersions(list)\n+\n+\tvar buf bytes.Buffer\n+\tfor _, v := range list {\n+\t\tbuf.WriteString(v)\n+\t\tbuf.WriteString(\"\\n\")\n+\t}\n+\tlistFile := filepath.Join(dir, \"list\")\n+\told, _ := ioutil.ReadFile(listFile)\n+\tif bytes.Equal(buf.Bytes(), old) {\n+\t\treturn\n+\t}\n+\t// TODO: Use rename to install file,\n+\t// so that readers never see an incomplete file.\n+\tioutil.WriteFile(listFile, buf.Bytes(), 0666)\n+}"}, {"sha": "241c800e692377f25099564e692a077d5c5d8600", "filename": "libgo/go/cmd/go/internal/modfetch/cache_test.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modfetch\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+)\n+\n+func TestWriteDiskCache(t *testing.T) {\n+\ttmpdir, err := ioutil.TempDir(\"\", \"go-writeCache-test-\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(tmpdir)\n+\n+\terr = writeDiskCache(filepath.Join(tmpdir, \"file\"), []byte(\"data\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}"}, {"sha": "4103ddc717f4912005cf9374519ccb85b6ead5c3", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/codehost.go", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,266 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package codehost defines the interface implemented by a code hosting source,\n+// along with support code for use by implementations.\n+package codehost\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/str\"\n+)\n+\n+// Downloaded size limits.\n+const (\n+\tMaxGoMod   = 16 << 20  // maximum size of go.mod file\n+\tMaxLICENSE = 16 << 20  // maximum size of LICENSE file\n+\tMaxZipFile = 500 << 20 // maximum size of downloaded zip file\n+)\n+\n+// A Repo represents a code hosting source.\n+// Typical implementations include local version control repositories,\n+// remote version control servers, and code hosting sites.\n+// A Repo must be safe for simultaneous use by multiple goroutines.\n+type Repo interface {\n+\t// List lists all tags with the given prefix.\n+\tTags(prefix string) (tags []string, err error)\n+\n+\t// Stat returns information about the revision rev.\n+\t// A revision can be any identifier known to the underlying service:\n+\t// commit hash, branch, tag, and so on.\n+\tStat(rev string) (*RevInfo, error)\n+\n+\t// Latest returns the latest revision on the default branch,\n+\t// whatever that means in the underlying implementation.\n+\tLatest() (*RevInfo, error)\n+\n+\t// ReadFile reads the given file in the file tree corresponding to revision rev.\n+\t// It should refuse to read more than maxSize bytes.\n+\t//\n+\t// If the requested file does not exist it should return an error for which\n+\t// os.IsNotExist(err) returns true.\n+\tReadFile(rev, file string, maxSize int64) (data []byte, err error)\n+\n+\t// ReadFileRevs reads a single file at multiple versions.\n+\t// It should refuse to read more than maxSize bytes.\n+\t// The result is a map from each requested rev strings\n+\t// to the associated FileRev. The map must have a non-nil\n+\t// entry for every requested rev (unless ReadFileRevs returned an error).\n+\t// A file simply being missing or even corrupted in revs[i]\n+\t// should be reported only in files[revs[i]].Err, not in the error result\n+\t// from ReadFileRevs.\n+\t// The overall call should return an error (and no map) only\n+\t// in the case of a problem with obtaining the data, such as\n+\t// a network failure.\n+\t// Implementations may assume that revs only contain tags,\n+\t// not direct commit hashes.\n+\tReadFileRevs(revs []string, file string, maxSize int64) (files map[string]*FileRev, err error)\n+\n+\t// ReadZip downloads a zip file for the subdir subdirectory\n+\t// of the given revision to a new file in a given temporary directory.\n+\t// It should refuse to read more than maxSize bytes.\n+\t// It returns a ReadCloser for a streamed copy of the zip file,\n+\t// along with the actual subdirectory (possibly shorter than subdir)\n+\t// contained in the zip file. All files in the zip file are expected to be\n+\t// nested in a single top-level directory, whose name is not specified.\n+\tReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, actualSubdir string, err error)\n+\n+\t// RecentTag returns the most recent tag at or before the given rev\n+\t// with the given prefix. It should make a best-effort attempt to\n+\t// find a tag that is a valid semantic version (following the prefix),\n+\t// or else the result is not useful to the caller, but it need not\n+\t// incur great expense in doing so. For example, the git implementation\n+\t// of RecentTag limits git's search to tags matching the glob expression\n+\t// \"v[0-9]*.[0-9]*.[0-9]*\" (after the prefix).\n+\tRecentTag(rev, prefix string) (tag string, err error)\n+}\n+\n+// A Rev describes a single revision in a source code repository.\n+type RevInfo struct {\n+\tName    string    // complete ID in underlying repository\n+\tShort   string    // shortened ID, for use in pseudo-version\n+\tVersion string    // version used in lookup\n+\tTime    time.Time // commit time\n+\tTags    []string  // known tags for commit\n+}\n+\n+// A FileRev describes the result of reading a file at a given revision.\n+type FileRev struct {\n+\tRev  string // requested revision\n+\tData []byte // file data\n+\tErr  error  // error if any; os.IsNotExist(Err)==true if rev exists but file does not exist in that rev\n+}\n+\n+// AllHex reports whether the revision rev is entirely lower-case hexadecimal digits.\n+func AllHex(rev string) bool {\n+\tfor i := 0; i < len(rev); i++ {\n+\t\tc := rev[i]\n+\t\tif '0' <= c && c <= '9' || 'a' <= c && c <= 'f' {\n+\t\t\tcontinue\n+\t\t}\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+// ShortenSHA1 shortens a SHA1 hash (40 hex digits) to the canonical length\n+// used in pseudo-versions (12 hex digits).\n+func ShortenSHA1(rev string) string {\n+\tif AllHex(rev) && len(rev) == 40 {\n+\t\treturn rev[:12]\n+\t}\n+\treturn rev\n+}\n+\n+// WorkRoot is the root of the cached work directory.\n+// It is set by cmd/go/internal/modload.InitMod.\n+var WorkRoot string\n+\n+// WorkDir returns the name of the cached work directory to use for the\n+// given repository type and name.\n+func WorkDir(typ, name string) (string, error) {\n+\tif WorkRoot == \"\" {\n+\t\treturn \"\", fmt.Errorf(\"codehost.WorkRoot not set\")\n+\t}\n+\n+\t// We name the work directory for the SHA256 hash of the type and name.\n+\t// We intentionally avoid the actual name both because of possible\n+\t// conflicts with valid file system paths and because we want to ensure\n+\t// that one checkout is never nested inside another. That nesting has\n+\t// led to security problems in the past.\n+\tif strings.Contains(typ, \":\") {\n+\t\treturn \"\", fmt.Errorf(\"codehost.WorkDir: type cannot contain colon\")\n+\t}\n+\tkey := typ + \":\" + name\n+\tdir := filepath.Join(WorkRoot, fmt.Sprintf(\"%x\", sha256.Sum256([]byte(key))))\n+\tdata, err := ioutil.ReadFile(dir + \".info\")\n+\tinfo, err2 := os.Stat(dir)\n+\tif err == nil && err2 == nil && info.IsDir() {\n+\t\t// Info file and directory both already exist: reuse.\n+\t\thave := strings.TrimSuffix(string(data), \"\\n\")\n+\t\tif have != key {\n+\t\t\treturn \"\", fmt.Errorf(\"%s exists with wrong content (have %q want %q)\", dir+\".info\", have, key)\n+\t\t}\n+\t\tif cfg.BuildX {\n+\t\t\tfmt.Fprintf(os.Stderr, \"# %s for %s %s\\n\", dir, typ, name)\n+\t\t}\n+\t\treturn dir, nil\n+\t}\n+\n+\t// Info file or directory missing. Start from scratch.\n+\tif cfg.BuildX {\n+\t\tfmt.Fprintf(os.Stderr, \"mkdir -p %s # %s %s\\n\", dir, typ, name)\n+\t}\n+\tos.RemoveAll(dir)\n+\tif err := os.MkdirAll(dir, 0777); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif err := ioutil.WriteFile(dir+\".info\", []byte(key), 0666); err != nil {\n+\t\tos.RemoveAll(dir)\n+\t\treturn \"\", err\n+\t}\n+\treturn dir, nil\n+}\n+\n+type RunError struct {\n+\tCmd    string\n+\tErr    error\n+\tStderr []byte\n+}\n+\n+func (e *RunError) Error() string {\n+\ttext := e.Cmd + \": \" + e.Err.Error()\n+\tstderr := bytes.TrimRight(e.Stderr, \"\\n\")\n+\tif len(stderr) > 0 {\n+\t\ttext += \":\\n\\t\" + strings.Replace(string(stderr), \"\\n\", \"\\n\\t\", -1)\n+\t}\n+\treturn text\n+}\n+\n+var dirLock sync.Map\n+\n+// Run runs the command line in the given directory\n+// (an empty dir means the current directory).\n+// It returns the standard output and, for a non-zero exit,\n+// a *RunError indicating the command, exit status, and standard error.\n+// Standard error is unavailable for commands that exit successfully.\n+func Run(dir string, cmdline ...interface{}) ([]byte, error) {\n+\treturn RunWithStdin(dir, nil, cmdline...)\n+}\n+\n+// bashQuoter escapes characters that have special meaning in double-quoted strings in the bash shell.\n+// See https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html.\n+var bashQuoter = strings.NewReplacer(`\"`, `\\\"`, `$`, `\\$`, \"`\", \"\\\\`\", `\\`, `\\\\`)\n+\n+func RunWithStdin(dir string, stdin io.Reader, cmdline ...interface{}) ([]byte, error) {\n+\tif dir != \"\" {\n+\t\tmuIface, ok := dirLock.Load(dir)\n+\t\tif !ok {\n+\t\t\tmuIface, _ = dirLock.LoadOrStore(dir, new(sync.Mutex))\n+\t\t}\n+\t\tmu := muIface.(*sync.Mutex)\n+\t\tmu.Lock()\n+\t\tdefer mu.Unlock()\n+\t}\n+\n+\tcmd := str.StringList(cmdline...)\n+\tif cfg.BuildX {\n+\t\ttext := new(strings.Builder)\n+\t\tif dir != \"\" {\n+\t\t\ttext.WriteString(\"cd \")\n+\t\t\ttext.WriteString(dir)\n+\t\t\ttext.WriteString(\"; \")\n+\t\t}\n+\t\tfor i, arg := range cmd {\n+\t\t\tif i > 0 {\n+\t\t\t\ttext.WriteByte(' ')\n+\t\t\t}\n+\t\t\tswitch {\n+\t\t\tcase strings.ContainsAny(arg, \"'\"):\n+\t\t\t\t// Quote args that could be mistaken for quoted args.\n+\t\t\t\ttext.WriteByte('\"')\n+\t\t\t\ttext.WriteString(bashQuoter.Replace(arg))\n+\t\t\t\ttext.WriteByte('\"')\n+\t\t\tcase strings.ContainsAny(arg, \"$`\\\\*?[\\\"\\t\\n\\v\\f\\r \\u0085\\u00a0\"):\n+\t\t\t\t// Quote args that contain special characters, glob patterns, or spaces.\n+\t\t\t\ttext.WriteByte('\\'')\n+\t\t\t\ttext.WriteString(arg)\n+\t\t\t\ttext.WriteByte('\\'')\n+\t\t\tdefault:\n+\t\t\t\ttext.WriteString(arg)\n+\t\t\t}\n+\t\t}\n+\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", text)\n+\t\tstart := time.Now()\n+\t\tdefer func() {\n+\t\t\tfmt.Fprintf(os.Stderr, \"%.3fs # %s\\n\", time.Since(start).Seconds(), text)\n+\t\t}()\n+\t}\n+\t// TODO: Impose limits on command output size.\n+\t// TODO: Set environment to get English error messages.\n+\tvar stderr bytes.Buffer\n+\tvar stdout bytes.Buffer\n+\tc := exec.Command(cmd[0], cmd[1:]...)\n+\tc.Dir = dir\n+\tc.Stdin = stdin\n+\tc.Stderr = &stderr\n+\tc.Stdout = &stdout\n+\terr := c.Run()\n+\tif err != nil {\n+\t\terr = &RunError{Cmd: strings.Join(cmd, \" \") + \" in \" + dir, Stderr: stderr.Bytes(), Err: err}\n+\t}\n+\treturn stdout.Bytes(), err\n+}"}, {"sha": "87940a8f02c9c4dad2cd11c3058064ac1f08702b", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git.go", "status": "added", "additions": 711, "deletions": 0, "changes": 711, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,711 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package codehost\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"cmd/go/internal/par\"\n+)\n+\n+// GitRepo returns the code repository at the given Git remote reference.\n+func GitRepo(remote string) (Repo, error) {\n+\treturn newGitRepoCached(remote, false)\n+}\n+\n+// LocalGitRepo is like Repo but accepts both Git remote references\n+// and paths to repositories on the local file system.\n+func LocalGitRepo(remote string) (Repo, error) {\n+\treturn newGitRepoCached(remote, true)\n+}\n+\n+const gitWorkDirType = \"git2\"\n+\n+var gitRepoCache par.Cache\n+\n+func newGitRepoCached(remote string, localOK bool) (Repo, error) {\n+\ttype key struct {\n+\t\tremote  string\n+\t\tlocalOK bool\n+\t}\n+\ttype cached struct {\n+\t\trepo Repo\n+\t\terr  error\n+\t}\n+\n+\tc := gitRepoCache.Do(key{remote, localOK}, func() interface{} {\n+\t\trepo, err := newGitRepo(remote, localOK)\n+\t\treturn cached{repo, err}\n+\t}).(cached)\n+\n+\treturn c.repo, c.err\n+}\n+\n+func newGitRepo(remote string, localOK bool) (Repo, error) {\n+\tr := &gitRepo{remote: remote}\n+\tif strings.Contains(remote, \"://\") {\n+\t\t// This is a remote path.\n+\t\tdir, err := WorkDir(gitWorkDirType, r.remote)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tr.dir = dir\n+\t\tif _, err := os.Stat(filepath.Join(dir, \"objects\")); err != nil {\n+\t\t\tif _, err := Run(dir, \"git\", \"init\", \"--bare\"); err != nil {\n+\t\t\t\tos.RemoveAll(dir)\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\t// We could just say git fetch https://whatever later,\n+\t\t\t// but this lets us say git fetch origin instead, which\n+\t\t\t// is a little nicer. More importantly, using a named remote\n+\t\t\t// avoids a problem with Git LFS. See golang.org/issue/25605.\n+\t\t\tif _, err := Run(dir, \"git\", \"remote\", \"add\", \"origin\", r.remote); err != nil {\n+\t\t\t\tos.RemoveAll(dir)\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tr.remote = \"origin\"\n+\t\t}\n+\t} else {\n+\t\t// Local path.\n+\t\t// Disallow colon (not in ://) because sometimes\n+\t\t// that's rcp-style host:path syntax and sometimes it's not (c:\\work).\n+\t\t// The go command has always insisted on URL syntax for ssh.\n+\t\tif strings.Contains(remote, \":\") {\n+\t\t\treturn nil, fmt.Errorf(\"git remote cannot use host:path syntax\")\n+\t\t}\n+\t\tif !localOK {\n+\t\t\treturn nil, fmt.Errorf(\"git remote must not be local directory\")\n+\t\t}\n+\t\tr.local = true\n+\t\tinfo, err := os.Stat(remote)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif !info.IsDir() {\n+\t\t\treturn nil, fmt.Errorf(\"%s exists but is not a directory\", remote)\n+\t\t}\n+\t\tr.dir = remote\n+\t}\n+\treturn r, nil\n+}\n+\n+type gitRepo struct {\n+\tremote string\n+\tlocal  bool\n+\tdir    string\n+\n+\tmu         sync.Mutex // protects fetchLevel, some git repo state\n+\tfetchLevel int\n+\n+\tstatCache par.Cache\n+\n+\trefsOnce sync.Once\n+\trefs     map[string]string\n+\trefsErr  error\n+\n+\tlocalTagsOnce sync.Once\n+\tlocalTags     map[string]bool\n+}\n+\n+const (\n+\t// How much have we fetched into the git repo (in this process)?\n+\tfetchNone = iota // nothing yet\n+\tfetchSome        // shallow fetches of individual hashes\n+\tfetchAll         // \"fetch -t origin\": get all remote branches and tags\n+)\n+\n+// loadLocalTags loads tag references from the local git cache\n+// into the map r.localTags.\n+// Should only be called as r.localTagsOnce.Do(r.loadLocalTags).\n+func (r *gitRepo) loadLocalTags() {\n+\t// The git protocol sends all known refs and ls-remote filters them on the client side,\n+\t// so we might as well record both heads and tags in one shot.\n+\t// Most of the time we only care about tags but sometimes we care about heads too.\n+\tout, err := Run(r.dir, \"git\", \"tag\", \"-l\")\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tr.localTags = make(map[string]bool)\n+\tfor _, line := range strings.Split(string(out), \"\\n\") {\n+\t\tif line != \"\" {\n+\t\t\tr.localTags[line] = true\n+\t\t}\n+\t}\n+}\n+\n+// loadRefs loads heads and tags references from the remote into the map r.refs.\n+// Should only be called as r.refsOnce.Do(r.loadRefs).\n+func (r *gitRepo) loadRefs() {\n+\t// The git protocol sends all known refs and ls-remote filters them on the client side,\n+\t// so we might as well record both heads and tags in one shot.\n+\t// Most of the time we only care about tags but sometimes we care about heads too.\n+\tout, err := Run(r.dir, \"git\", \"ls-remote\", \"-q\", r.remote)\n+\tif err != nil {\n+\t\tr.refsErr = err\n+\t\treturn\n+\t}\n+\n+\tr.refs = make(map[string]string)\n+\tfor _, line := range strings.Split(string(out), \"\\n\") {\n+\t\tf := strings.Fields(line)\n+\t\tif len(f) != 2 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif f[1] == \"HEAD\" || strings.HasPrefix(f[1], \"refs/heads/\") || strings.HasPrefix(f[1], \"refs/tags/\") {\n+\t\t\tr.refs[f[1]] = f[0]\n+\t\t}\n+\t}\n+\tfor ref, hash := range r.refs {\n+\t\tif strings.HasSuffix(ref, \"^{}\") { // record unwrapped annotated tag as value of tag\n+\t\t\tr.refs[strings.TrimSuffix(ref, \"^{}\")] = hash\n+\t\t\tdelete(r.refs, ref)\n+\t\t}\n+\t}\n+}\n+\n+func (r *gitRepo) Tags(prefix string) ([]string, error) {\n+\tr.refsOnce.Do(r.loadRefs)\n+\tif r.refsErr != nil {\n+\t\treturn nil, r.refsErr\n+\t}\n+\n+\ttags := []string{}\n+\tfor ref := range r.refs {\n+\t\tif !strings.HasPrefix(ref, \"refs/tags/\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttag := ref[len(\"refs/tags/\"):]\n+\t\tif !strings.HasPrefix(tag, prefix) {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttags = append(tags, tag)\n+\t}\n+\tsort.Strings(tags)\n+\treturn tags, nil\n+}\n+\n+func (r *gitRepo) Latest() (*RevInfo, error) {\n+\tr.refsOnce.Do(r.loadRefs)\n+\tif r.refsErr != nil {\n+\t\treturn nil, r.refsErr\n+\t}\n+\tif r.refs[\"HEAD\"] == \"\" {\n+\t\treturn nil, fmt.Errorf(\"no commits\")\n+\t}\n+\treturn r.Stat(r.refs[\"HEAD\"])\n+}\n+\n+// findRef finds some ref name for the given hash,\n+// for use when the server requires giving a ref instead of a hash.\n+// There may be multiple ref names for a given hash,\n+// in which case this returns some name - it doesn't matter which.\n+func (r *gitRepo) findRef(hash string) (ref string, ok bool) {\n+\tr.refsOnce.Do(r.loadRefs)\n+\tfor ref, h := range r.refs {\n+\t\tif h == hash {\n+\t\t\treturn ref, true\n+\t\t}\n+\t}\n+\treturn \"\", false\n+}\n+\n+func unshallow(gitDir string) []string {\n+\tif _, err := os.Stat(filepath.Join(gitDir, \"shallow\")); err == nil {\n+\t\treturn []string{\"--unshallow\"}\n+\t}\n+\treturn []string{}\n+}\n+\n+// minHashDigits is the minimum number of digits to require\n+// before accepting a hex digit sequence as potentially identifying\n+// a specific commit in a git repo. (Of course, users can always\n+// specify more digits, and many will paste in all 40 digits,\n+// but many of git's commands default to printing short hashes\n+// as 7 digits.)\n+const minHashDigits = 7\n+\n+// stat stats the given rev in the local repository,\n+// or else it fetches more info from the remote repository and tries again.\n+func (r *gitRepo) stat(rev string) (*RevInfo, error) {\n+\tif r.local {\n+\t\treturn r.statLocal(rev, rev)\n+\t}\n+\n+\t// Fast path: maybe rev is a hash we already have locally.\n+\tdidStatLocal := false\n+\tif len(rev) >= minHashDigits && len(rev) <= 40 && AllHex(rev) {\n+\t\tif info, err := r.statLocal(rev, rev); err == nil {\n+\t\t\treturn info, nil\n+\t\t}\n+\t\tdidStatLocal = true\n+\t}\n+\n+\t// Maybe rev is a tag we already have locally.\n+\t// (Note that we're excluding branches, which can be stale.)\n+\tr.localTagsOnce.Do(r.loadLocalTags)\n+\tif r.localTags[rev] {\n+\t\treturn r.statLocal(rev, \"refs/tags/\"+rev)\n+\t}\n+\n+\t// Maybe rev is the name of a tag or branch on the remote server.\n+\t// Or maybe it's the prefix of a hash of a named ref.\n+\t// Try to resolve to both a ref (git name) and full (40-hex-digit) commit hash.\n+\tr.refsOnce.Do(r.loadRefs)\n+\tvar ref, hash string\n+\tif r.refs[\"refs/tags/\"+rev] != \"\" {\n+\t\tref = \"refs/tags/\" + rev\n+\t\thash = r.refs[ref]\n+\t\t// Keep rev as is: tags are assumed not to change meaning.\n+\t} else if r.refs[\"refs/heads/\"+rev] != \"\" {\n+\t\tref = \"refs/heads/\" + rev\n+\t\thash = r.refs[ref]\n+\t\trev = hash // Replace rev, because meaning of refs/heads/foo can change.\n+\t} else if rev == \"HEAD\" && r.refs[\"HEAD\"] != \"\" {\n+\t\tref = \"HEAD\"\n+\t\thash = r.refs[ref]\n+\t\trev = hash // Replace rev, because meaning of HEAD can change.\n+\t} else if len(rev) >= minHashDigits && len(rev) <= 40 && AllHex(rev) {\n+\t\t// At the least, we have a hash prefix we can look up after the fetch below.\n+\t\t// Maybe we can map it to a full hash using the known refs.\n+\t\tprefix := rev\n+\t\t// Check whether rev is prefix of known ref hash.\n+\t\tfor k, h := range r.refs {\n+\t\t\tif strings.HasPrefix(h, prefix) {\n+\t\t\t\tif hash != \"\" && hash != h {\n+\t\t\t\t\t// Hash is an ambiguous hash prefix.\n+\t\t\t\t\t// More information will not change that.\n+\t\t\t\t\treturn nil, fmt.Errorf(\"ambiguous revision %s\", rev)\n+\t\t\t\t}\n+\t\t\t\tif ref == \"\" || ref > k { // Break ties deterministically when multiple refs point at same hash.\n+\t\t\t\t\tref = k\n+\t\t\t\t}\n+\t\t\t\trev = h\n+\t\t\t\thash = h\n+\t\t\t}\n+\t\t}\n+\t\tif hash == \"\" && len(rev) == 40 { // Didn't find a ref, but rev is a full hash.\n+\t\t\thash = rev\n+\t\t}\n+\t} else {\n+\t\treturn nil, fmt.Errorf(\"unknown revision %s\", rev)\n+\t}\n+\n+\t// Protect r.fetchLevel and the \"fetch more and more\" sequence.\n+\t// TODO(rsc): Add LockDir and use it for protecting that\n+\t// sequence, so that multiple processes don't collide in their\n+\t// git commands.\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\n+\t// Perhaps r.localTags did not have the ref when we loaded local tags,\n+\t// but we've since done fetches that pulled down the hash we need\n+\t// (or already have the hash we need, just without its tag).\n+\t// Either way, try a local stat before falling back to network I/O.\n+\tif !didStatLocal {\n+\t\tif info, err := r.statLocal(rev, hash); err == nil {\n+\t\t\tif strings.HasPrefix(ref, \"refs/tags/\") {\n+\t\t\t\t// Make sure tag exists, so it will be in localTags next time the go command is run.\n+\t\t\t\tRun(r.dir, \"git\", \"tag\", strings.TrimPrefix(ref, \"refs/tags/\"), hash)\n+\t\t\t}\n+\t\t\treturn info, nil\n+\t\t}\n+\t}\n+\n+\t// If we know a specific commit we need, fetch it.\n+\tif r.fetchLevel <= fetchSome && hash != \"\" && !r.local {\n+\t\tr.fetchLevel = fetchSome\n+\t\tvar refspec string\n+\t\tif ref != \"\" && ref != \"HEAD\" {\n+\t\t\t// If we do know the ref name, save the mapping locally\n+\t\t\t// so that (if it is a tag) it can show up in localTags\n+\t\t\t// on a future call. Also, some servers refuse to allow\n+\t\t\t// full hashes in ref specs, so prefer a ref name if known.\n+\t\t\trefspec = ref + \":\" + ref\n+\t\t} else {\n+\t\t\t// Fetch the hash but give it a local name (refs/dummy),\n+\t\t\t// because that triggers the fetch behavior of creating any\n+\t\t\t// other known remote tags for the hash. We never use\n+\t\t\t// refs/dummy (it's not refs/tags/dummy) and it will be\n+\t\t\t// overwritten in the next command, and that's fine.\n+\t\t\tref = hash\n+\t\t\trefspec = hash + \":refs/dummy\"\n+\t\t}\n+\t\t_, err := Run(r.dir, \"git\", \"fetch\", \"-f\", \"--depth=1\", r.remote, refspec)\n+\t\tif err == nil {\n+\t\t\treturn r.statLocal(rev, ref)\n+\t\t}\n+\t\t// Don't try to be smart about parsing the error.\n+\t\t// It's too complex and varies too much by git version.\n+\t\t// No matter what went wrong, fall back to a complete fetch.\n+\t}\n+\n+\t// Last resort.\n+\t// Fetch all heads and tags and hope the hash we want is in the history.\n+\tif r.fetchLevel < fetchAll {\n+\t\t// TODO(bcmills): should we wait to upgrade fetchLevel until after we check\n+\t\t// err? If there is a temporary server error, we want subsequent fetches to\n+\t\t// try again instead of proceeding with an incomplete repo.\n+\t\tr.fetchLevel = fetchAll\n+\t\tif err := r.fetchUnshallow(\"refs/heads/*:refs/heads/*\", \"refs/tags/*:refs/tags/*\"); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\treturn r.statLocal(rev, rev)\n+}\n+\n+func (r *gitRepo) fetchUnshallow(refSpecs ...string) error {\n+\t// To work around a protocol version 2 bug that breaks --unshallow,\n+\t// add -c protocol.version=0.\n+\t// TODO(rsc): The bug is believed to be server-side, meaning only\n+\t// on Google's Git servers. Once the servers are fixed, drop the\n+\t// protocol.version=0. See Google-internal bug b/110495752.\n+\tvar protoFlag []string\n+\tunshallowFlag := unshallow(r.dir)\n+\tif len(unshallowFlag) > 0 {\n+\t\tprotoFlag = []string{\"-c\", \"protocol.version=0\"}\n+\t}\n+\t_, err := Run(r.dir, \"git\", protoFlag, \"fetch\", unshallowFlag, \"-f\", r.remote, refSpecs)\n+\treturn err\n+}\n+\n+// statLocal returns a RevInfo describing rev in the local git repository.\n+// It uses version as info.Version.\n+func (r *gitRepo) statLocal(version, rev string) (*RevInfo, error) {\n+\tout, err := Run(r.dir, \"git\", \"-c\", \"log.showsignature=false\", \"log\", \"-n1\", \"--format=format:%H %ct %D\", rev)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"unknown revision %s\", rev)\n+\t}\n+\tf := strings.Fields(string(out))\n+\tif len(f) < 2 {\n+\t\treturn nil, fmt.Errorf(\"unexpected response from git log: %q\", out)\n+\t}\n+\thash := f[0]\n+\tif strings.HasPrefix(hash, version) {\n+\t\tversion = hash // extend to full hash\n+\t}\n+\tt, err := strconv.ParseInt(f[1], 10, 64)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"invalid time from git log: %q\", out)\n+\t}\n+\n+\tinfo := &RevInfo{\n+\t\tName:    hash,\n+\t\tShort:   ShortenSHA1(hash),\n+\t\tTime:    time.Unix(t, 0).UTC(),\n+\t\tVersion: hash,\n+\t}\n+\n+\t// Add tags. Output looks like:\n+\t//\tede458df7cd0fdca520df19a33158086a8a68e81 1523994202 HEAD -> master, tag: v1.2.4-annotated, tag: v1.2.3, origin/master, origin/HEAD\n+\tfor i := 2; i < len(f); i++ {\n+\t\tif f[i] == \"tag:\" {\n+\t\t\ti++\n+\t\t\tif i < len(f) {\n+\t\t\t\tinfo.Tags = append(info.Tags, strings.TrimSuffix(f[i], \",\"))\n+\t\t\t}\n+\t\t}\n+\t}\n+\tsort.Strings(info.Tags)\n+\n+\t// Used hash as info.Version above.\n+\t// Use caller's suggested version if it appears in the tag list\n+\t// (filters out branch names, HEAD).\n+\tfor _, tag := range info.Tags {\n+\t\tif version == tag {\n+\t\t\tinfo.Version = version\n+\t\t}\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (r *gitRepo) Stat(rev string) (*RevInfo, error) {\n+\tif rev == \"latest\" {\n+\t\treturn r.Latest()\n+\t}\n+\ttype cached struct {\n+\t\tinfo *RevInfo\n+\t\terr  error\n+\t}\n+\tc := r.statCache.Do(rev, func() interface{} {\n+\t\tinfo, err := r.stat(rev)\n+\t\treturn cached{info, err}\n+\t}).(cached)\n+\treturn c.info, c.err\n+}\n+\n+func (r *gitRepo) ReadFile(rev, file string, maxSize int64) ([]byte, error) {\n+\t// TODO: Could use git cat-file --batch.\n+\tinfo, err := r.Stat(rev) // download rev into local git repo\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tout, err := Run(r.dir, \"git\", \"cat-file\", \"blob\", info.Name+\":\"+file)\n+\tif err != nil {\n+\t\treturn nil, os.ErrNotExist\n+\t}\n+\treturn out, nil\n+}\n+\n+func (r *gitRepo) ReadFileRevs(revs []string, file string, maxSize int64) (map[string]*FileRev, error) {\n+\t// Create space to hold results.\n+\tfiles := make(map[string]*FileRev)\n+\tfor _, rev := range revs {\n+\t\tf := &FileRev{Rev: rev}\n+\t\tfiles[rev] = f\n+\t}\n+\n+\t// Collect locally-known revs.\n+\tneed, err := r.readFileRevs(revs, file, files)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(need) == 0 {\n+\t\treturn files, nil\n+\t}\n+\n+\t// Build list of known remote refs that might help.\n+\tvar redo []string\n+\tr.refsOnce.Do(r.loadRefs)\n+\tif r.refsErr != nil {\n+\t\treturn nil, r.refsErr\n+\t}\n+\tfor _, tag := range need {\n+\t\tif r.refs[\"refs/tags/\"+tag] != \"\" {\n+\t\t\tredo = append(redo, tag)\n+\t\t}\n+\t}\n+\tif len(redo) == 0 {\n+\t\treturn files, nil\n+\t}\n+\n+\t// Protect r.fetchLevel and the \"fetch more and more\" sequence.\n+\t// See stat method above.\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\n+\tvar refs []string\n+\tvar protoFlag []string\n+\tvar unshallowFlag []string\n+\tfor _, tag := range redo {\n+\t\trefs = append(refs, \"refs/tags/\"+tag+\":refs/tags/\"+tag)\n+\t}\n+\tif len(refs) > 1 {\n+\t\tunshallowFlag = unshallow(r.dir)\n+\t\tif len(unshallowFlag) > 0 {\n+\t\t\t// To work around a protocol version 2 bug that breaks --unshallow,\n+\t\t\t// add -c protocol.version=0.\n+\t\t\t// TODO(rsc): The bug is believed to be server-side, meaning only\n+\t\t\t// on Google's Git servers. Once the servers are fixed, drop the\n+\t\t\t// protocol.version=0. See Google-internal bug b/110495752.\n+\t\t\tprotoFlag = []string{\"-c\", \"protocol.version=0\"}\n+\t\t}\n+\t}\n+\tif _, err := Run(r.dir, \"git\", protoFlag, \"fetch\", unshallowFlag, \"-f\", r.remote, refs); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// TODO(bcmills): after the 1.11 freeze, replace the block above with:\n+\t//\tif r.fetchLevel <= fetchSome {\n+\t//\t\tr.fetchLevel = fetchSome\n+\t//\t\tvar refs []string\n+\t//\t\tfor _, tag := range redo {\n+\t//\t\t\trefs = append(refs, \"refs/tags/\"+tag+\":refs/tags/\"+tag)\n+\t//\t\t}\n+\t//\t\tif _, err := Run(r.dir, \"git\", \"fetch\", \"--update-shallow\", \"-f\", r.remote, refs); err != nil {\n+\t//\t\t\treturn nil, err\n+\t//\t\t}\n+\t//\t}\n+\n+\tif _, err := r.readFileRevs(redo, file, files); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn files, nil\n+}\n+\n+func (r *gitRepo) readFileRevs(tags []string, file string, fileMap map[string]*FileRev) (missing []string, err error) {\n+\tvar stdin bytes.Buffer\n+\tfor _, tag := range tags {\n+\t\tfmt.Fprintf(&stdin, \"refs/tags/%s\\n\", tag)\n+\t\tfmt.Fprintf(&stdin, \"refs/tags/%s:%s\\n\", tag, file)\n+\t}\n+\n+\tdata, err := RunWithStdin(r.dir, &stdin, \"git\", \"cat-file\", \"--batch\")\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tnext := func() (typ string, body []byte, ok bool) {\n+\t\tvar line string\n+\t\ti := bytes.IndexByte(data, '\\n')\n+\t\tif i < 0 {\n+\t\t\treturn \"\", nil, false\n+\t\t}\n+\t\tline, data = string(bytes.TrimSpace(data[:i])), data[i+1:]\n+\t\tif strings.HasSuffix(line, \" missing\") {\n+\t\t\treturn \"missing\", nil, true\n+\t\t}\n+\t\tf := strings.Fields(line)\n+\t\tif len(f) != 3 {\n+\t\t\treturn \"\", nil, false\n+\t\t}\n+\t\tn, err := strconv.Atoi(f[2])\n+\t\tif err != nil || n > len(data) {\n+\t\t\treturn \"\", nil, false\n+\t\t}\n+\t\tbody, data = data[:n], data[n:]\n+\t\tif len(data) > 0 && data[0] == '\\r' {\n+\t\t\tdata = data[1:]\n+\t\t}\n+\t\tif len(data) > 0 && data[0] == '\\n' {\n+\t\t\tdata = data[1:]\n+\t\t}\n+\t\treturn f[1], body, true\n+\t}\n+\n+\tbadGit := func() ([]string, error) {\n+\t\treturn nil, fmt.Errorf(\"malformed output from git cat-file --batch\")\n+\t}\n+\n+\tfor _, tag := range tags {\n+\t\tcommitType, _, ok := next()\n+\t\tif !ok {\n+\t\t\treturn badGit()\n+\t\t}\n+\t\tfileType, fileData, ok := next()\n+\t\tif !ok {\n+\t\t\treturn badGit()\n+\t\t}\n+\t\tf := fileMap[tag]\n+\t\tf.Data = nil\n+\t\tf.Err = nil\n+\t\tswitch commitType {\n+\t\tdefault:\n+\t\t\tf.Err = fmt.Errorf(\"unexpected non-commit type %q for rev %s\", commitType, tag)\n+\n+\t\tcase \"missing\":\n+\t\t\t// Note: f.Err must not satisfy os.IsNotExist. That's reserved for the file not existing in a valid commit.\n+\t\t\tf.Err = fmt.Errorf(\"no such rev %s\", tag)\n+\t\t\tmissing = append(missing, tag)\n+\n+\t\tcase \"tag\", \"commit\":\n+\t\t\tswitch fileType {\n+\t\t\tdefault:\n+\t\t\t\tf.Err = &os.PathError{Path: tag + \":\" + file, Op: \"read\", Err: fmt.Errorf(\"unexpected non-blob type %q\", fileType)}\n+\t\t\tcase \"missing\":\n+\t\t\t\tf.Err = &os.PathError{Path: tag + \":\" + file, Op: \"read\", Err: os.ErrNotExist}\n+\t\t\tcase \"blob\":\n+\t\t\t\tf.Data = fileData\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif len(bytes.TrimSpace(data)) != 0 {\n+\t\treturn badGit()\n+\t}\n+\n+\treturn missing, nil\n+}\n+\n+func (r *gitRepo) RecentTag(rev, prefix string) (tag string, err error) {\n+\tinfo, err := r.Stat(rev)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\trev = info.Name // expand hash prefixes\n+\n+\t// describe sets tag and err using 'git describe' and reports whether the\n+\t// result is definitive.\n+\tdescribe := func() (definitive bool) {\n+\t\tvar out []byte\n+\t\tout, err = Run(r.dir, \"git\", \"describe\", \"--first-parent\", \"--always\", \"--abbrev=0\", \"--match\", prefix+\"v[0-9]*.[0-9]*.[0-9]*\", \"--tags\", rev)\n+\t\tif err != nil {\n+\t\t\treturn true // Because we use \"--always\", describe should never fail.\n+\t\t}\n+\n+\t\ttag = string(bytes.TrimSpace(out))\n+\t\treturn tag != \"\" && !AllHex(tag)\n+\t}\n+\n+\tif describe() {\n+\t\treturn tag, err\n+\t}\n+\n+\t// Git didn't find a version tag preceding the requested rev.\n+\t// See whether any plausible tag exists.\n+\ttags, err := r.Tags(prefix + \"v\")\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif len(tags) == 0 {\n+\t\treturn \"\", nil\n+\t}\n+\n+\t// There are plausible tags, but we don't know if rev is a descendent of any of them.\n+\t// Fetch the history to find out.\n+\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\n+\tif r.fetchLevel < fetchAll {\n+\t\t// Fetch all heads and tags and see if that gives us enough history.\n+\t\tif err := r.fetchUnshallow(\"refs/heads/*:refs/heads/*\", \"refs/tags/*:refs/tags/*\"); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tr.fetchLevel = fetchAll\n+\t}\n+\n+\t// If we've reached this point, we have all of the commits that are reachable\n+\t// from all heads and tags.\n+\t//\n+\t// The only refs we should be missing are those that are no longer reachable\n+\t// (or never were reachable) from any branch or tag, including the master\n+\t// branch, and we don't want to resolve them anyway (they're probably\n+\t// unreachable for a reason).\n+\t//\n+\t// Try one last time in case some other goroutine fetched rev while we were\n+\t// waiting on r.mu.\n+\tdescribe()\n+\treturn tag, err\n+}\n+\n+func (r *gitRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, actualSubdir string, err error) {\n+\t// TODO: Use maxSize or drop it.\n+\targs := []string{}\n+\tif subdir != \"\" {\n+\t\targs = append(args, \"--\", subdir)\n+\t}\n+\tinfo, err := r.Stat(rev) // download rev into local git repo\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\t// Incredibly, git produces different archives depending on whether\n+\t// it is running on a Windows system or not, in an attempt to normalize\n+\t// text file line endings. Setting -c core.autocrlf=input means only\n+\t// translate files on the way into the repo, not on the way out (archive).\n+\t// The -c core.eol=lf should be unnecessary but set it anyway.\n+\tarchive, err := Run(r.dir, \"git\", \"-c\", \"core.autocrlf=input\", \"-c\", \"core.eol=lf\", \"archive\", \"--format=zip\", \"--prefix=prefix/\", info.Name, args)\n+\tif err != nil {\n+\t\tif bytes.Contains(err.(*RunError).Stderr, []byte(\"did not match any files\")) {\n+\t\t\treturn nil, \"\", os.ErrNotExist\n+\t\t}\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\treturn ioutil.NopCloser(bytes.NewReader(archive)), \"\", nil\n+}"}, {"sha": "da9e7050407e86a4cc8f3eef6c5214ea3ad38ab0", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git_test.go", "status": "added", "additions": 635, "deletions": 0, "changes": 635, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,635 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package codehost\n+\n+import (\n+\t\"archive/zip\"\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"internal/testenv\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path\"\n+\t\"path/filepath\"\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestMain(m *testing.M) {\n+\t// needed for initializing the test environment variables as testing.Short\n+\t// and HasExternalNetwork\n+\tflag.Parse()\n+\tos.Exit(testMain(m))\n+}\n+\n+const (\n+\tgitrepo1 = \"https://vcs-test.golang.org/git/gitrepo1\"\n+\thgrepo1  = \"https://vcs-test.golang.org/hg/hgrepo1\"\n+)\n+\n+var altRepos = []string{\n+\t\"localGitRepo\",\n+\thgrepo1,\n+}\n+\n+// TODO: Convert gitrepo1 to svn, bzr, fossil and add tests.\n+// For now, at least the hgrepo1 tests check the general vcs.go logic.\n+\n+// localGitRepo is like gitrepo1 but allows archive access.\n+var localGitRepo string\n+\n+func testMain(m *testing.M) int {\n+\tif _, err := exec.LookPath(\"git\"); err != nil {\n+\t\tfmt.Fprintln(os.Stderr, \"skipping because git binary not found\")\n+\t\tfmt.Println(\"PASS\")\n+\t\treturn 0\n+\t}\n+\n+\tdir, err := ioutil.TempDir(\"\", \"gitrepo-test-\")\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\tWorkRoot = dir\n+\n+\tif testenv.HasExternalNetwork() && testenv.HasExec() {\n+\t\t// Clone gitrepo1 into a local directory.\n+\t\t// If we use a file:// URL to access the local directory,\n+\t\t// then git starts up all the usual protocol machinery,\n+\t\t// which will let us test remote git archive invocations.\n+\t\tlocalGitRepo = filepath.Join(dir, \"gitrepo2\")\n+\t\tif _, err := Run(\"\", \"git\", \"clone\", \"--mirror\", gitrepo1, localGitRepo); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t\tif _, err := Run(localGitRepo, \"git\", \"config\", \"daemon.uploadarch\", \"true\"); err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t}\n+\n+\treturn m.Run()\n+}\n+\n+func testRepo(remote string) (Repo, error) {\n+\tif remote == \"localGitRepo\" {\n+\t\treturn LocalGitRepo(filepath.ToSlash(localGitRepo))\n+\t}\n+\tkind := \"git\"\n+\tfor _, k := range []string{\"hg\"} {\n+\t\tif strings.Contains(remote, \"/\"+k+\"/\") {\n+\t\t\tkind = k\n+\t\t}\n+\t}\n+\treturn NewRepo(kind, remote)\n+}\n+\n+var tagsTests = []struct {\n+\trepo   string\n+\tprefix string\n+\ttags   []string\n+}{\n+\t{gitrepo1, \"xxx\", []string{}},\n+\t{gitrepo1, \"\", []string{\"v1.2.3\", \"v1.2.4-annotated\", \"v2.0.1\", \"v2.0.2\", \"v2.3\"}},\n+\t{gitrepo1, \"v\", []string{\"v1.2.3\", \"v1.2.4-annotated\", \"v2.0.1\", \"v2.0.2\", \"v2.3\"}},\n+\t{gitrepo1, \"v1\", []string{\"v1.2.3\", \"v1.2.4-annotated\"}},\n+\t{gitrepo1, \"2\", []string{}},\n+}\n+\n+func TestTags(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExec(t)\n+\n+\tfor _, tt := range tagsTests {\n+\t\tf := func(t *testing.T) {\n+\t\t\tr, err := testRepo(tt.repo)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\ttags, err := r.Tags(tt.prefix)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif !reflect.DeepEqual(tags, tt.tags) {\n+\t\t\t\tt.Errorf(\"Tags: incorrect tags\\nhave %v\\nwant %v\", tags, tt.tags)\n+\t\t\t}\n+\t\t}\n+\t\tt.Run(path.Base(tt.repo)+\"/\"+tt.prefix, f)\n+\t\tif tt.repo == gitrepo1 {\n+\t\t\tfor _, tt.repo = range altRepos {\n+\t\t\t\tt.Run(path.Base(tt.repo)+\"/\"+tt.prefix, f)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+var latestTests = []struct {\n+\trepo string\n+\tinfo *RevInfo\n+}{\n+\t{\n+\t\tgitrepo1,\n+\t\t&RevInfo{\n+\t\t\tName:    \"ede458df7cd0fdca520df19a33158086a8a68e81\",\n+\t\t\tShort:   \"ede458df7cd0\",\n+\t\t\tVersion: \"ede458df7cd0fdca520df19a33158086a8a68e81\",\n+\t\t\tTime:    time.Date(2018, 4, 17, 19, 43, 22, 0, time.UTC),\n+\t\t\tTags:    []string{\"v1.2.3\", \"v1.2.4-annotated\"},\n+\t\t},\n+\t},\n+\t{\n+\t\thgrepo1,\n+\t\t&RevInfo{\n+\t\t\tName:    \"18518c07eb8ed5c80221e997e518cccaa8c0c287\",\n+\t\t\tShort:   \"18518c07eb8e\",\n+\t\t\tVersion: \"18518c07eb8ed5c80221e997e518cccaa8c0c287\",\n+\t\t\tTime:    time.Date(2018, 6, 27, 16, 16, 30, 0, time.UTC),\n+\t\t},\n+\t},\n+}\n+\n+func TestLatest(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExec(t)\n+\n+\tfor _, tt := range latestTests {\n+\t\tf := func(t *testing.T) {\n+\t\t\tr, err := testRepo(tt.repo)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tinfo, err := r.Latest()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif !reflect.DeepEqual(info, tt.info) {\n+\t\t\t\tt.Errorf(\"Latest: incorrect info\\nhave %+v\\nwant %+v\", *info, *tt.info)\n+\t\t\t}\n+\t\t}\n+\t\tt.Run(path.Base(tt.repo), f)\n+\t\tif tt.repo == gitrepo1 {\n+\t\t\ttt.repo = \"localGitRepo\"\n+\t\t\tt.Run(path.Base(tt.repo), f)\n+\t\t}\n+\t}\n+}\n+\n+var readFileTests = []struct {\n+\trepo string\n+\trev  string\n+\tfile string\n+\terr  string\n+\tdata string\n+}{\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"latest\",\n+\t\tfile: \"README\",\n+\t\tdata: \"\",\n+\t},\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"v2\",\n+\t\tfile: \"another.txt\",\n+\t\tdata: \"another\\n\",\n+\t},\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"v2.3.4\",\n+\t\tfile: \"another.txt\",\n+\t\terr:  os.ErrNotExist.Error(),\n+\t},\n+}\n+\n+func TestReadFile(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExec(t)\n+\n+\tfor _, tt := range readFileTests {\n+\t\tf := func(t *testing.T) {\n+\t\t\tr, err := testRepo(tt.repo)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tdata, err := r.ReadFile(tt.rev, tt.file, 100)\n+\t\t\tif err != nil {\n+\t\t\t\tif tt.err == \"\" {\n+\t\t\t\t\tt.Fatalf(\"ReadFile: unexpected error %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif !strings.Contains(err.Error(), tt.err) {\n+\t\t\t\t\tt.Fatalf(\"ReadFile: wrong error %q, want %q\", err, tt.err)\n+\t\t\t\t}\n+\t\t\t\tif len(data) != 0 {\n+\t\t\t\t\tt.Errorf(\"ReadFile: non-empty data %q with error %v\", data, err)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif tt.err != \"\" {\n+\t\t\t\tt.Fatalf(\"ReadFile: no error, wanted %v\", tt.err)\n+\t\t\t}\n+\t\t\tif string(data) != tt.data {\n+\t\t\t\tt.Errorf(\"ReadFile: incorrect data\\nhave %q\\nwant %q\", data, tt.data)\n+\t\t\t}\n+\t\t}\n+\t\tt.Run(path.Base(tt.repo)+\"/\"+tt.rev+\"/\"+tt.file, f)\n+\t\tif tt.repo == gitrepo1 {\n+\t\t\tfor _, tt.repo = range altRepos {\n+\t\t\t\tt.Run(path.Base(tt.repo)+\"/\"+tt.rev+\"/\"+tt.file, f)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+var readZipTests = []struct {\n+\trepo         string\n+\trev          string\n+\tsubdir       string\n+\tactualSubdir string\n+\terr          string\n+\tfiles        map[string]uint64\n+}{\n+\t{\n+\t\trepo:   gitrepo1,\n+\t\trev:    \"v2.3.4\",\n+\t\tsubdir: \"\",\n+\t\tfiles: map[string]uint64{\n+\t\t\t\"prefix/\":       0,\n+\t\t\t\"prefix/README\": 0,\n+\t\t\t\"prefix/v2\":     3,\n+\t\t},\n+\t},\n+\t{\n+\t\trepo:   hgrepo1,\n+\t\trev:    \"v2.3.4\",\n+\t\tsubdir: \"\",\n+\t\tfiles: map[string]uint64{\n+\t\t\t\"prefix/.hg_archival.txt\": ^uint64(0),\n+\t\t\t\"prefix/README\":           0,\n+\t\t\t\"prefix/v2\":               3,\n+\t\t},\n+\t},\n+\n+\t{\n+\t\trepo:   gitrepo1,\n+\t\trev:    \"v2\",\n+\t\tsubdir: \"\",\n+\t\tfiles: map[string]uint64{\n+\t\t\t\"prefix/\":            0,\n+\t\t\t\"prefix/README\":      0,\n+\t\t\t\"prefix/v2\":          3,\n+\t\t\t\"prefix/another.txt\": 8,\n+\t\t\t\"prefix/foo.txt\":     13,\n+\t\t},\n+\t},\n+\t{\n+\t\trepo:   hgrepo1,\n+\t\trev:    \"v2\",\n+\t\tsubdir: \"\",\n+\t\tfiles: map[string]uint64{\n+\t\t\t\"prefix/.hg_archival.txt\": ^uint64(0),\n+\t\t\t\"prefix/README\":           0,\n+\t\t\t\"prefix/v2\":               3,\n+\t\t\t\"prefix/another.txt\":      8,\n+\t\t\t\"prefix/foo.txt\":          13,\n+\t\t},\n+\t},\n+\n+\t{\n+\t\trepo:   gitrepo1,\n+\t\trev:    \"v3\",\n+\t\tsubdir: \"\",\n+\t\tfiles: map[string]uint64{\n+\t\t\t\"prefix/\":                    0,\n+\t\t\t\"prefix/v3/\":                 0,\n+\t\t\t\"prefix/v3/sub/\":             0,\n+\t\t\t\"prefix/v3/sub/dir/\":         0,\n+\t\t\t\"prefix/v3/sub/dir/file.txt\": 16,\n+\t\t\t\"prefix/README\":              0,\n+\t\t},\n+\t},\n+\t{\n+\t\trepo:   hgrepo1,\n+\t\trev:    \"v3\",\n+\t\tsubdir: \"\",\n+\t\tfiles: map[string]uint64{\n+\t\t\t\"prefix/.hg_archival.txt\":    ^uint64(0),\n+\t\t\t\"prefix/.hgtags\":             405,\n+\t\t\t\"prefix/v3/sub/dir/file.txt\": 16,\n+\t\t\t\"prefix/README\":              0,\n+\t\t},\n+\t},\n+\n+\t{\n+\t\trepo:   gitrepo1,\n+\t\trev:    \"v3\",\n+\t\tsubdir: \"v3/sub/dir\",\n+\t\tfiles: map[string]uint64{\n+\t\t\t\"prefix/\":                    0,\n+\t\t\t\"prefix/v3/\":                 0,\n+\t\t\t\"prefix/v3/sub/\":             0,\n+\t\t\t\"prefix/v3/sub/dir/\":         0,\n+\t\t\t\"prefix/v3/sub/dir/file.txt\": 16,\n+\t\t},\n+\t},\n+\t{\n+\t\trepo:   hgrepo1,\n+\t\trev:    \"v3\",\n+\t\tsubdir: \"v3/sub/dir\",\n+\t\tfiles: map[string]uint64{\n+\t\t\t\"prefix/v3/sub/dir/file.txt\": 16,\n+\t\t},\n+\t},\n+\n+\t{\n+\t\trepo:   gitrepo1,\n+\t\trev:    \"v3\",\n+\t\tsubdir: \"v3/sub\",\n+\t\tfiles: map[string]uint64{\n+\t\t\t\"prefix/\":                    0,\n+\t\t\t\"prefix/v3/\":                 0,\n+\t\t\t\"prefix/v3/sub/\":             0,\n+\t\t\t\"prefix/v3/sub/dir/\":         0,\n+\t\t\t\"prefix/v3/sub/dir/file.txt\": 16,\n+\t\t},\n+\t},\n+\t{\n+\t\trepo:   hgrepo1,\n+\t\trev:    \"v3\",\n+\t\tsubdir: \"v3/sub\",\n+\t\tfiles: map[string]uint64{\n+\t\t\t\"prefix/v3/sub/dir/file.txt\": 16,\n+\t\t},\n+\t},\n+\n+\t{\n+\t\trepo:   gitrepo1,\n+\t\trev:    \"aaaaaaaaab\",\n+\t\tsubdir: \"\",\n+\t\terr:    \"unknown revision\",\n+\t},\n+\t{\n+\t\trepo:   hgrepo1,\n+\t\trev:    \"aaaaaaaaab\",\n+\t\tsubdir: \"\",\n+\t\terr:    \"unknown revision\",\n+\t},\n+\n+\t{\n+\t\trepo:   \"https://github.com/rsc/vgotest1\",\n+\t\trev:    \"submod/v1.0.4\",\n+\t\tsubdir: \"submod\",\n+\t\tfiles: map[string]uint64{\n+\t\t\t\"prefix/\":                0,\n+\t\t\t\"prefix/submod/\":         0,\n+\t\t\t\"prefix/submod/go.mod\":   53,\n+\t\t\t\"prefix/submod/pkg/\":     0,\n+\t\t\t\"prefix/submod/pkg/p.go\": 31,\n+\t\t},\n+\t},\n+}\n+\n+type zipFile struct {\n+\tname string\n+\tsize int64\n+}\n+\n+func TestReadZip(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExec(t)\n+\n+\tfor _, tt := range readZipTests {\n+\t\tf := func(t *testing.T) {\n+\t\t\tr, err := testRepo(tt.repo)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\trc, actualSubdir, err := r.ReadZip(tt.rev, tt.subdir, 100000)\n+\t\t\tif err != nil {\n+\t\t\t\tif tt.err == \"\" {\n+\t\t\t\t\tt.Fatalf(\"ReadZip: unexpected error %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif !strings.Contains(err.Error(), tt.err) {\n+\t\t\t\t\tt.Fatalf(\"ReadZip: wrong error %q, want %q\", err, tt.err)\n+\t\t\t\t}\n+\t\t\t\tif rc != nil {\n+\t\t\t\t\tt.Errorf(\"ReadZip: non-nil io.ReadCloser with error %v\", err)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdefer rc.Close()\n+\t\t\tif tt.err != \"\" {\n+\t\t\t\tt.Fatalf(\"ReadZip: no error, wanted %v\", tt.err)\n+\t\t\t}\n+\t\t\tif actualSubdir != tt.actualSubdir {\n+\t\t\t\tt.Fatalf(\"ReadZip: actualSubdir = %q, want %q\", actualSubdir, tt.actualSubdir)\n+\t\t\t}\n+\t\t\tzipdata, err := ioutil.ReadAll(rc)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tz, err := zip.NewReader(bytes.NewReader(zipdata), int64(len(zipdata)))\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"ReadZip: cannot read zip file: %v\", err)\n+\t\t\t}\n+\t\t\thave := make(map[string]bool)\n+\t\t\tfor _, f := range z.File {\n+\t\t\t\tsize, ok := tt.files[f.Name]\n+\t\t\t\tif !ok {\n+\t\t\t\t\tt.Errorf(\"ReadZip: unexpected file %s\", f.Name)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\thave[f.Name] = true\n+\t\t\t\tif size != ^uint64(0) && f.UncompressedSize64 != size {\n+\t\t\t\t\tt.Errorf(\"ReadZip: file %s has unexpected size %d != %d\", f.Name, f.UncompressedSize64, size)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor name := range tt.files {\n+\t\t\t\tif !have[name] {\n+\t\t\t\t\tt.Errorf(\"ReadZip: missing file %s\", name)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tt.Run(path.Base(tt.repo)+\"/\"+tt.rev+\"/\"+tt.subdir, f)\n+\t\tif tt.repo == gitrepo1 {\n+\t\t\ttt.repo = \"localGitRepo\"\n+\t\t\tt.Run(path.Base(tt.repo)+\"/\"+tt.rev+\"/\"+tt.subdir, f)\n+\t\t}\n+\t}\n+}\n+\n+var hgmap = map[string]string{\n+\t\"HEAD\": \"41964ddce1180313bdc01d0a39a2813344d6261d\", // not tip due to bad hgrepo1 conversion\n+\t\"9d02800338b8a55be062c838d1f02e0c5780b9eb\": \"8f49ee7a6ddcdec6f0112d9dca48d4a2e4c3c09e\",\n+\t\"76a00fb249b7f93091bc2c89a789dab1fc1bc26f\": \"88fde824ec8b41a76baa16b7e84212cee9f3edd0\",\n+\t\"ede458df7cd0fdca520df19a33158086a8a68e81\": \"41964ddce1180313bdc01d0a39a2813344d6261d\",\n+\t\"97f6aa59c81c623494825b43d39e445566e429a4\": \"c0cbbfb24c7c3c50c35c7b88e7db777da4ff625d\",\n+}\n+\n+var statTests = []struct {\n+\trepo string\n+\trev  string\n+\terr  string\n+\tinfo *RevInfo\n+}{\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"HEAD\",\n+\t\tinfo: &RevInfo{\n+\t\t\tName:    \"ede458df7cd0fdca520df19a33158086a8a68e81\",\n+\t\t\tShort:   \"ede458df7cd0\",\n+\t\t\tVersion: \"ede458df7cd0fdca520df19a33158086a8a68e81\",\n+\t\t\tTime:    time.Date(2018, 4, 17, 19, 43, 22, 0, time.UTC),\n+\t\t\tTags:    []string{\"v1.2.3\", \"v1.2.4-annotated\"},\n+\t\t},\n+\t},\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"v2\", // branch\n+\t\tinfo: &RevInfo{\n+\t\t\tName:    \"9d02800338b8a55be062c838d1f02e0c5780b9eb\",\n+\t\t\tShort:   \"9d02800338b8\",\n+\t\t\tVersion: \"9d02800338b8a55be062c838d1f02e0c5780b9eb\",\n+\t\t\tTime:    time.Date(2018, 4, 17, 20, 00, 32, 0, time.UTC),\n+\t\t\tTags:    []string{\"v2.0.2\"},\n+\t\t},\n+\t},\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"v2.3.4\", // badly-named branch (semver should be a tag)\n+\t\tinfo: &RevInfo{\n+\t\t\tName:    \"76a00fb249b7f93091bc2c89a789dab1fc1bc26f\",\n+\t\t\tShort:   \"76a00fb249b7\",\n+\t\t\tVersion: \"76a00fb249b7f93091bc2c89a789dab1fc1bc26f\",\n+\t\t\tTime:    time.Date(2018, 4, 17, 19, 45, 48, 0, time.UTC),\n+\t\t\tTags:    []string{\"v2.0.1\", \"v2.3\"},\n+\t\t},\n+\t},\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"v2.3\", // badly-named tag (we only respect full semver v2.3.0)\n+\t\tinfo: &RevInfo{\n+\t\t\tName:    \"76a00fb249b7f93091bc2c89a789dab1fc1bc26f\",\n+\t\t\tShort:   \"76a00fb249b7\",\n+\t\t\tVersion: \"v2.3\",\n+\t\t\tTime:    time.Date(2018, 4, 17, 19, 45, 48, 0, time.UTC),\n+\t\t\tTags:    []string{\"v2.0.1\", \"v2.3\"},\n+\t\t},\n+\t},\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"v1.2.3\", // tag\n+\t\tinfo: &RevInfo{\n+\t\t\tName:    \"ede458df7cd0fdca520df19a33158086a8a68e81\",\n+\t\t\tShort:   \"ede458df7cd0\",\n+\t\t\tVersion: \"v1.2.3\",\n+\t\t\tTime:    time.Date(2018, 4, 17, 19, 43, 22, 0, time.UTC),\n+\t\t\tTags:    []string{\"v1.2.3\", \"v1.2.4-annotated\"},\n+\t\t},\n+\t},\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"ede458df\", // hash prefix in refs\n+\t\tinfo: &RevInfo{\n+\t\t\tName:    \"ede458df7cd0fdca520df19a33158086a8a68e81\",\n+\t\t\tShort:   \"ede458df7cd0\",\n+\t\t\tVersion: \"ede458df7cd0fdca520df19a33158086a8a68e81\",\n+\t\t\tTime:    time.Date(2018, 4, 17, 19, 43, 22, 0, time.UTC),\n+\t\t\tTags:    []string{\"v1.2.3\", \"v1.2.4-annotated\"},\n+\t\t},\n+\t},\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"97f6aa59\", // hash prefix not in refs\n+\t\tinfo: &RevInfo{\n+\t\t\tName:    \"97f6aa59c81c623494825b43d39e445566e429a4\",\n+\t\t\tShort:   \"97f6aa59c81c\",\n+\t\t\tVersion: \"97f6aa59c81c623494825b43d39e445566e429a4\",\n+\t\t\tTime:    time.Date(2018, 4, 17, 20, 0, 19, 0, time.UTC),\n+\t\t},\n+\t},\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"v1.2.4-annotated\", // annotated tag uses unwrapped commit hash\n+\t\tinfo: &RevInfo{\n+\t\t\tName:    \"ede458df7cd0fdca520df19a33158086a8a68e81\",\n+\t\t\tShort:   \"ede458df7cd0\",\n+\t\t\tVersion: \"v1.2.4-annotated\",\n+\t\t\tTime:    time.Date(2018, 4, 17, 19, 43, 22, 0, time.UTC),\n+\t\t\tTags:    []string{\"v1.2.3\", \"v1.2.4-annotated\"},\n+\t\t},\n+\t},\n+\t{\n+\t\trepo: gitrepo1,\n+\t\trev:  \"aaaaaaaaab\",\n+\t\terr:  \"unknown revision\",\n+\t},\n+}\n+\n+func TestStat(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExec(t)\n+\n+\tfor _, tt := range statTests {\n+\t\tf := func(t *testing.T) {\n+\t\t\tr, err := testRepo(tt.repo)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tinfo, err := r.Stat(tt.rev)\n+\t\t\tif err != nil {\n+\t\t\t\tif tt.err == \"\" {\n+\t\t\t\t\tt.Fatalf(\"Stat: unexpected error %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif !strings.Contains(err.Error(), tt.err) {\n+\t\t\t\t\tt.Fatalf(\"Stat: wrong error %q, want %q\", err, tt.err)\n+\t\t\t\t}\n+\t\t\t\tif info != nil {\n+\t\t\t\t\tt.Errorf(\"Stat: non-nil info with error %q\", err)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif !reflect.DeepEqual(info, tt.info) {\n+\t\t\t\tt.Errorf(\"Stat: incorrect info\\nhave %+v\\nwant %+v\", *info, *tt.info)\n+\t\t\t}\n+\t\t}\n+\t\tt.Run(path.Base(tt.repo)+\"/\"+tt.rev, f)\n+\t\tif tt.repo == gitrepo1 {\n+\t\t\tfor _, tt.repo = range altRepos {\n+\t\t\t\told := tt\n+\t\t\t\tvar m map[string]string\n+\t\t\t\tif tt.repo == hgrepo1 {\n+\t\t\t\t\tm = hgmap\n+\t\t\t\t}\n+\t\t\t\tif tt.info != nil {\n+\t\t\t\t\tinfo := *tt.info\n+\t\t\t\t\ttt.info = &info\n+\t\t\t\t\ttt.info.Name = remap(tt.info.Name, m)\n+\t\t\t\t\ttt.info.Version = remap(tt.info.Version, m)\n+\t\t\t\t\ttt.info.Short = remap(tt.info.Short, m)\n+\t\t\t\t}\n+\t\t\t\ttt.rev = remap(tt.rev, m)\n+\t\t\t\tt.Run(path.Base(tt.repo)+\"/\"+tt.rev, f)\n+\t\t\t\ttt = old\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func remap(name string, m map[string]string) string {\n+\tif m[name] != \"\" {\n+\t\treturn m[name]\n+\t}\n+\tif AllHex(name) {\n+\t\tfor k, v := range m {\n+\t\t\tif strings.HasPrefix(k, name) {\n+\t\t\t\treturn v[:len(name)]\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn name\n+}"}, {"sha": "7b813c37401c8785ee12681036ed164af376a5fe", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/shell.go", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,140 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+// Interactive debugging shell for codehost.Repo implementations.\n+\n+package main\n+\n+import (\n+\t\"archive/zip\"\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"cmd/go/internal/modfetch/codehost\"\n+)\n+\n+func usage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: go run shell.go vcs remote\\n\")\n+\tos.Exit(2)\n+}\n+\n+func main() {\n+\tcodehost.WorkRoot = \"/tmp/vcswork\"\n+\tlog.SetFlags(0)\n+\tlog.SetPrefix(\"shell: \")\n+\tflag.Usage = usage\n+\tflag.Parse()\n+\tif flag.NArg() != 2 {\n+\t\tusage()\n+\t}\n+\n+\trepo, err := codehost.NewRepo(flag.Arg(0), flag.Arg(1))\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\tb := bufio.NewReader(os.Stdin)\n+\tfor {\n+\t\tfmt.Fprintf(os.Stderr, \">>> \")\n+\t\tline, err := b.ReadString('\\n')\n+\t\tif err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t\tf := strings.Fields(line)\n+\t\tif len(f) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tswitch f[0] {\n+\t\tdefault:\n+\t\t\tfmt.Fprintf(os.Stderr, \"?unknown command\\n\")\n+\t\t\tcontinue\n+\t\tcase \"tags\":\n+\t\t\tprefix := \"\"\n+\t\t\tif len(f) == 2 {\n+\t\t\t\tprefix = f[1]\n+\t\t\t}\n+\t\t\tif len(f) > 2 {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"?usage: tags [prefix]\\n\")\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ttags, err := repo.Tags(prefix)\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"?%s\\n\", err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor _, tag := range tags {\n+\t\t\t\tfmt.Printf(\"%s\\n\", tag)\n+\t\t\t}\n+\n+\t\tcase \"stat\":\n+\t\t\tif len(f) != 2 {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"?usage: stat rev\\n\")\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tinfo, err := repo.Stat(f[1])\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"?%s\\n\", err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfmt.Printf(\"name=%s short=%s version=%s time=%s\\n\", info.Name, info.Short, info.Version, info.Time.UTC().Format(time.RFC3339))\n+\n+\t\tcase \"read\":\n+\t\t\tif len(f) != 3 {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"?usage: read rev file\\n\")\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdata, err := repo.ReadFile(f[1], f[2], 10<<20)\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"?%s\\n\", err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tos.Stdout.Write(data)\n+\n+\t\tcase \"zip\":\n+\t\t\tif len(f) != 4 {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"?usage: zip rev subdir output\\n\")\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tsubdir := f[2]\n+\t\t\tif subdir == \"-\" {\n+\t\t\t\tsubdir = \"\"\n+\t\t\t}\n+\t\t\trc, _, err := repo.ReadZip(f[1], subdir, 10<<20)\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"?%s\\n\", err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdata, err := ioutil.ReadAll(rc)\n+\t\t\trc.Close()\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"?%s\\n\", err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif f[3] != \"-\" {\n+\t\t\t\tif err := ioutil.WriteFile(f[3], data, 0666); err != nil {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, \"?%s\\n\", err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tz, err := zip.NewReader(bytes.NewReader(data), int64(len(data)))\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"?%s\\n\", err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor _, f := range z.File {\n+\t\t\t\tfmt.Printf(\"%s %d\\n\", f.Name, f.UncompressedSize64)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "9e862a0ef8c0d2059d7bce82d02a49a2ee70d26d", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/vcs.go", "status": "added", "additions": 528, "deletions": 0, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "patch": "@@ -0,0 +1,528 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package codehost\n+\n+import (\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"cmd/go/internal/par\"\n+\t\"cmd/go/internal/str\"\n+)\n+\n+// A VCSError indicates an error using a version control system.\n+// The implication of a VCSError is that we know definitively where\n+// to get the code, but we can't access it due to the error.\n+// The caller should report this error instead of continuing to probe\n+// other possible module paths.\n+type VCSError struct {\n+\tErr error\n+}\n+\n+func (e *VCSError) Error() string { return e.Err.Error() }\n+\n+func NewRepo(vcs, remote string) (Repo, error) {\n+\ttype key struct {\n+\t\tvcs    string\n+\t\tremote string\n+\t}\n+\ttype cached struct {\n+\t\trepo Repo\n+\t\terr  error\n+\t}\n+\tc := vcsRepoCache.Do(key{vcs, remote}, func() interface{} {\n+\t\trepo, err := newVCSRepo(vcs, remote)\n+\t\tif err != nil {\n+\t\t\terr = &VCSError{err}\n+\t\t}\n+\t\treturn cached{repo, err}\n+\t}).(cached)\n+\n+\treturn c.repo, c.err\n+}\n+\n+var vcsRepoCache par.Cache\n+\n+type vcsRepo struct {\n+\tremote string\n+\tcmd    *vcsCmd\n+\tdir    string\n+\n+\ttagsOnce sync.Once\n+\ttags     map[string]bool\n+\n+\tbranchesOnce sync.Once\n+\tbranches     map[string]bool\n+\n+\tfetchOnce sync.Once\n+\tfetchErr  error\n+}\n+\n+func newVCSRepo(vcs, remote string) (Repo, error) {\n+\tif vcs == \"git\" {\n+\t\treturn newGitRepo(remote, false)\n+\t}\n+\tcmd := vcsCmds[vcs]\n+\tif cmd == nil {\n+\t\treturn nil, fmt.Errorf(\"unknown vcs: %s %s\", vcs, remote)\n+\t}\n+\tif !strings.Contains(remote, \"://\") {\n+\t\treturn nil, fmt.Errorf(\"invalid vcs remote: %s %s\", vcs, remote)\n+\t}\n+\tr := &vcsRepo{remote: remote, cmd: cmd}\n+\tif cmd.init == nil {\n+\t\treturn r, nil\n+\t}\n+\tdir, err := WorkDir(vcsWorkDirType+vcs, r.remote)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tr.dir = dir\n+\tif _, err := os.Stat(filepath.Join(dir, \".\"+vcs)); err != nil {\n+\t\tif _, err := Run(dir, cmd.init(r.remote)); err != nil {\n+\t\t\tos.RemoveAll(dir)\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\treturn r, nil\n+}\n+\n+const vcsWorkDirType = \"vcs1.\"\n+\n+type vcsCmd struct {\n+\tvcs           string                                            // vcs name \"hg\"\n+\tinit          func(remote string) []string                      // cmd to init repo to track remote\n+\ttags          func(remote string) []string                      // cmd to list local tags\n+\ttagRE         *regexp.Regexp                                    // regexp to extract tag names from output of tags cmd\n+\tbranches      func(remote string) []string                      // cmd to list local branches\n+\tbranchRE      *regexp.Regexp                                    // regexp to extract branch names from output of tags cmd\n+\tbadLocalRevRE *regexp.Regexp                                    // regexp of names that must not be served out of local cache without doing fetch first\n+\tstatLocal     func(rev, remote string) []string                 // cmd to stat local rev\n+\tparseStat     func(rev, out string) (*RevInfo, error)           // cmd to parse output of statLocal\n+\tfetch         []string                                          // cmd to fetch everything from remote\n+\tlatest        string                                            // name of latest commit on remote (tip, HEAD, etc)\n+\treadFile      func(rev, file, remote string) []string           // cmd to read rev's file\n+\treadZip       func(rev, subdir, remote, target string) []string // cmd to read rev's subdir as zip file\n+}\n+\n+var re = regexp.MustCompile\n+\n+var vcsCmds = map[string]*vcsCmd{\n+\t\"hg\": {\n+\t\tvcs: \"hg\",\n+\t\tinit: func(remote string) []string {\n+\t\t\treturn []string{\"hg\", \"clone\", \"-U\", remote, \".\"}\n+\t\t},\n+\t\ttags: func(remote string) []string {\n+\t\t\treturn []string{\"hg\", \"tags\", \"-q\"}\n+\t\t},\n+\t\ttagRE: re(`(?m)^[^\\n]+$`),\n+\t\tbranches: func(remote string) []string {\n+\t\t\treturn []string{\"hg\", \"branches\", \"-c\", \"-q\"}\n+\t\t},\n+\t\tbranchRE:      re(`(?m)^[^\\n]+$`),\n+\t\tbadLocalRevRE: re(`(?m)^(tip)$`),\n+\t\tstatLocal: func(rev, remote string) []string {\n+\t\t\treturn []string{\"hg\", \"log\", \"-l1\", \"-r\", rev, \"--template\", \"{node} {date|hgdate} {tags}\"}\n+\t\t},\n+\t\tparseStat: hgParseStat,\n+\t\tfetch:     []string{\"hg\", \"pull\", \"-f\"},\n+\t\tlatest:    \"tip\",\n+\t\treadFile: func(rev, file, remote string) []string {\n+\t\t\treturn []string{\"hg\", \"cat\", \"-r\", rev, file}\n+\t\t},\n+\t\treadZip: func(rev, subdir, remote, target string) []string {\n+\t\t\tpattern := []string{}\n+\t\t\tif subdir != \"\" {\n+\t\t\t\tpattern = []string{\"-I\", subdir + \"/**\"}\n+\t\t\t}\n+\t\t\treturn str.StringList(\"hg\", \"archive\", \"-t\", \"zip\", \"--no-decode\", \"-r\", rev, \"--prefix=prefix/\", pattern, target)\n+\t\t},\n+\t},\n+\n+\t\"svn\": {\n+\t\tvcs:  \"svn\",\n+\t\tinit: nil, // no local checkout\n+\t\ttags: func(remote string) []string {\n+\t\t\treturn []string{\"svn\", \"list\", strings.TrimSuffix(remote, \"/trunk\") + \"/tags\"}\n+\t\t},\n+\t\ttagRE: re(`(?m)^(.*?)/?$`),\n+\t\tstatLocal: func(rev, remote string) []string {\n+\t\t\tsuffix := \"@\" + rev\n+\t\t\tif rev == \"latest\" {\n+\t\t\t\tsuffix = \"\"\n+\t\t\t}\n+\t\t\treturn []string{\"svn\", \"log\", \"-l1\", \"--xml\", remote + suffix}\n+\t\t},\n+\t\tparseStat: svnParseStat,\n+\t\tlatest:    \"latest\",\n+\t\treadFile: func(rev, file, remote string) []string {\n+\t\t\treturn []string{\"svn\", \"cat\", remote + \"/\" + file + \"@\" + rev}\n+\t\t},\n+\t\t// TODO: zip\n+\t},\n+\n+\t\"bzr\": {\n+\t\tvcs: \"bzr\",\n+\t\tinit: func(remote string) []string {\n+\t\t\treturn []string{\"bzr\", \"branch\", \"--use-existing-dir\", remote, \".\"}\n+\t\t},\n+\t\tfetch: []string{\n+\t\t\t\"bzr\", \"pull\", \"--overwrite-tags\",\n+\t\t},\n+\t\ttags: func(remote string) []string {\n+\t\t\treturn []string{\"bzr\", \"tags\"}\n+\t\t},\n+\t\ttagRE:         re(`(?m)^\\S+`),\n+\t\tbadLocalRevRE: re(`^revno:-`),\n+\t\tstatLocal: func(rev, remote string) []string {\n+\t\t\treturn []string{\"bzr\", \"log\", \"-l1\", \"--long\", \"--show-ids\", \"-r\", rev}\n+\t\t},\n+\t\tparseStat: bzrParseStat,\n+\t\tlatest:    \"revno:-1\",\n+\t\treadFile: func(rev, file, remote string) []string {\n+\t\t\treturn []string{\"bzr\", \"cat\", \"-r\", rev, file}\n+\t\t},\n+\t\treadZip: func(rev, subdir, remote, target string) []string {\n+\t\t\textra := []string{}\n+\t\t\tif subdir != \"\" {\n+\t\t\t\textra = []string{\"./\" + subdir}\n+\t\t\t}\n+\t\t\treturn str.StringList(\"bzr\", \"export\", \"--format=zip\", \"-r\", rev, \"--root=prefix/\", target, extra)\n+\t\t},\n+\t},\n+\n+\t\"fossil\": {\n+\t\tvcs: \"fossil\",\n+\t\tinit: func(remote string) []string {\n+\t\t\treturn []string{\"fossil\", \"clone\", remote, \".fossil\"}\n+\t\t},\n+\t\tfetch: []string{\"fossil\", \"pull\", \"-R\", \".fossil\"},\n+\t\ttags: func(remote string) []string {\n+\t\t\treturn []string{\"fossil\", \"tag\", \"-R\", \".fossil\", \"list\"}\n+\t\t},\n+\t\ttagRE: re(`XXXTODO`),\n+\t\tstatLocal: func(rev, remote string) []string {\n+\t\t\treturn []string{\"fossil\", \"info\", \"-R\", \".fossil\", rev}\n+\t\t},\n+\t\tparseStat: fossilParseStat,\n+\t\tlatest:    \"trunk\",\n+\t\treadFile: func(rev, file, remote string) []string {\n+\t\t\treturn []string{\"fossil\", \"cat\", \"-R\", \".fossil\", \"-r\", rev, file}\n+\t\t},\n+\t\treadZip: func(rev, subdir, remote, target string) []string {\n+\t\t\textra := []string{}\n+\t\t\tif subdir != \"\" && !strings.ContainsAny(subdir, \"*?[],\") {\n+\t\t\t\textra = []string{\"--include\", subdir}\n+\t\t\t}\n+\t\t\t// Note that vcsRepo.ReadZip below rewrites this command\n+\t\t\t// to run in a different directory, to work around a fossil bug.\n+\t\t\treturn str.StringList(\"fossil\", \"zip\", \"-R\", \".fossil\", \"--name\", \"prefix\", extra, rev, target)\n+\t\t},\n+\t},\n+}\n+\n+func (r *vcsRepo) loadTags() {\n+\tout, err := Run(r.dir, r.cmd.tags(r.remote))\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t// Run tag-listing command and extract tags.\n+\tr.tags = make(map[string]bool)\n+\tfor _, tag := range r.cmd.tagRE.FindAllString(string(out), -1) {\n+\t\tif r.cmd.badLocalRevRE != nil && r.cmd.badLocalRevRE.MatchString(tag) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tr.tags[tag] = true\n+\t}\n+}\n+\n+func (r *vcsRepo) loadBranches() {\n+\tif r.cmd.branches == nil {\n+\t\treturn\n+\t}\n+\n+\tout, err := Run(r.dir, r.cmd.branches(r.remote))\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tr.branches = make(map[string]bool)\n+\tfor _, branch := range r.cmd.branchRE.FindAllString(string(out), -1) {\n+\t\tif r.cmd.badLocalRevRE != nil && r.cmd.badLocalRevRE.MatchString(branch) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tr.branches[branch] = true\n+\t}\n+}\n+\n+func (r *vcsRepo) Tags(prefix string) ([]string, error) {\n+\tr.tagsOnce.Do(r.loadTags)\n+\n+\ttags := []string{}\n+\tfor tag := range r.tags {\n+\t\tif strings.HasPrefix(tag, prefix) {\n+\t\t\ttags = append(tags, tag)\n+\t\t}\n+\t}\n+\tsort.Strings(tags)\n+\treturn tags, nil\n+}\n+\n+func (r *vcsRepo) Stat(rev string) (*RevInfo, error) {\n+\tif rev == \"latest\" {\n+\t\trev = r.cmd.latest\n+\t}\n+\tr.branchesOnce.Do(r.loadBranches)\n+\trevOK := (r.cmd.badLocalRevRE == nil || !r.cmd.badLocalRevRE.MatchString(rev)) && !r.branches[rev]\n+\tif revOK {\n+\t\tif info, err := r.statLocal(rev); err == nil {\n+\t\t\treturn info, nil\n+\t\t}\n+\t}\n+\n+\tr.fetchOnce.Do(r.fetch)\n+\tif r.fetchErr != nil {\n+\t\treturn nil, r.fetchErr\n+\t}\n+\tinfo, err := r.statLocal(rev)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif !revOK {\n+\t\tinfo.Version = info.Name\n+\t}\n+\treturn info, nil\n+}\n+\n+func (r *vcsRepo) fetch() {\n+\t_, r.fetchErr = Run(r.dir, r.cmd.fetch)\n+}\n+\n+func (r *vcsRepo) statLocal(rev string) (*RevInfo, error) {\n+\tout, err := Run(r.dir, r.cmd.statLocal(rev, r.remote))\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"unknown revision %s\", rev)\n+\t}\n+\treturn r.cmd.parseStat(rev, string(out))\n+}\n+\n+func (r *vcsRepo) Latest() (*RevInfo, error) {\n+\treturn r.Stat(\"latest\")\n+}\n+\n+func (r *vcsRepo) ReadFile(rev, file string, maxSize int64) ([]byte, error) {\n+\tif rev == \"latest\" {\n+\t\trev = r.cmd.latest\n+\t}\n+\t_, err := r.Stat(rev) // download rev into local repo\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tout, err := Run(r.dir, r.cmd.readFile(rev, file, r.remote))\n+\tif err != nil {\n+\t\treturn nil, os.ErrNotExist\n+\t}\n+\treturn out, nil\n+}\n+\n+func (r *vcsRepo) ReadFileRevs(revs []string, file string, maxSize int64) (map[string]*FileRev, error) {\n+\treturn nil, fmt.Errorf(\"ReadFileRevs not implemented\")\n+}\n+\n+func (r *vcsRepo) RecentTag(rev, prefix string) (tag string, err error) {\n+\treturn \"\", fmt.Errorf(\"RecentTags not implemented\")\n+}\n+\n+func (r *vcsRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, actualSubdir string, err error) {\n+\tif rev == \"latest\" {\n+\t\trev = r.cmd.latest\n+\t}\n+\tf, err := ioutil.TempFile(\"\", \"go-readzip-*.zip\")\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\tif r.cmd.vcs == \"fossil\" {\n+\t\t// If you run\n+\t\t//\tfossil zip -R .fossil --name prefix trunk /tmp/x.zip\n+\t\t// fossil fails with \"unable to create directory /tmp\" [sic].\n+\t\t// Change the command to run in /tmp instead,\n+\t\t// replacing the -R argument with an absolute path.\n+\t\targs := r.cmd.readZip(rev, subdir, r.remote, filepath.Base(f.Name()))\n+\t\tfor i := range args {\n+\t\t\tif args[i] == \".fossil\" {\n+\t\t\t\targs[i] = filepath.Join(r.dir, \".fossil\")\n+\t\t\t}\n+\t\t}\n+\t\t_, err = Run(filepath.Dir(f.Name()), args)\n+\t} else {\n+\t\t_, err = Run(r.dir, r.cmd.readZip(rev, subdir, r.remote, f.Name()))\n+\t}\n+\tif err != nil {\n+\t\tf.Close()\n+\t\tos.Remove(f.Name())\n+\t\treturn nil, \"\", err\n+\t}\n+\treturn &deleteCloser{f}, \"\", nil\n+}\n+\n+// deleteCloser is a file that gets deleted on Close.\n+type deleteCloser struct {\n+\t*os.File\n+}\n+\n+func (d *deleteCloser) Close() error {\n+\tdefer os.Remove(d.File.Name())\n+\treturn d.File.Close()\n+}\n+\n+func hgParseStat(rev, out string) (*RevInfo, error) {\n+\tf := strings.Fields(string(out))\n+\tif len(f) < 3 {\n+\t\treturn nil, fmt.Errorf(\"unexpected response from hg log: %q\", out)\n+\t}\n+\thash := f[0]\n+\tversion := rev\n+\tif strings.HasPrefix(hash, version) {\n+\t\tversion = hash // extend to full hash\n+\t}\n+\tt, err := strconv.ParseInt(f[1], 10, 64)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"invalid time from hg log: %q\", out)\n+\t}\n+\n+\tvar tags []string\n+\tfor _, tag := range f[3:] {\n+\t\tif tag != \"tip\" {\n+\t\t\ttags = append(tags, tag)\n+\t\t}\n+\t}\n+\tsort.Strings(tags)\n+\n+\tinfo := &RevInfo{\n+\t\tName:    hash,\n+\t\tShort:   ShortenSHA1(hash),\n+\t\tTime:    time.Unix(t, 0).UTC(),\n+\t\tVersion: version,\n+\t\tTags:    tags,\n+\t}\n+\treturn info, nil\n+}\n+\n+func svnParseStat(rev, out string) (*RevInfo, error) {\n+\tvar log struct {\n+\t\tLogentry struct {\n+\t\t\tRevision int64  `xml:\"revision,attr\"`\n+\t\t\tDate     string `xml:\"date\"`\n+\t\t} `xml:\"logentry\"`\n+\t}\n+\tif err := xml.Unmarshal([]byte(out), &log); err != nil {\n+\t\treturn nil, fmt.Errorf(\"unexpected response from svn log --xml: %v\\n%s\", err, out)\n+\t}\n+\n+\tt, err := time.Parse(time.RFC3339, log.Logentry.Date)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"unexpected response from svn log --xml: %v\\n%s\", err, out)\n+\t}\n+\n+\tinfo := &RevInfo{\n+\t\tName:    fmt.Sprintf(\"%d\", log.Logentry.Revision),\n+\t\tShort:   fmt.Sprintf(\"%012d\", log.Logentry.Revision),\n+\t\tTime:    t.UTC(),\n+\t\tVersion: rev,\n+\t}\n+\treturn info, nil\n+}\n+\n+func bzrParseStat(rev, out string) (*RevInfo, error) {\n+\tvar revno int64\n+\tvar tm time.Time\n+\tfor _, line := range strings.Split(out, \"\\n\") {\n+\t\tif line == \"\" || line[0] == ' ' || line[0] == '\\t' {\n+\t\t\t// End of header, start of commit message.\n+\t\t\tbreak\n+\t\t}\n+\t\tif line[0] == '-' {\n+\t\t\tcontinue\n+\t\t}\n+\t\ti := strings.Index(line, \":\")\n+\t\tif i < 0 {\n+\t\t\t// End of header, start of commit message.\n+\t\t\tbreak\n+\t\t}\n+\t\tkey, val := line[:i], strings.TrimSpace(line[i+1:])\n+\t\tswitch key {\n+\t\tcase \"revno\":\n+\t\t\tif j := strings.Index(val, \" \"); j >= 0 {\n+\t\t\t\tval = val[:j]\n+\t\t\t}\n+\t\t\ti, err := strconv.ParseInt(val, 10, 64)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"unexpected revno from bzr log: %q\", line)\n+\t\t\t}\n+\t\t\trevno = i\n+\t\tcase \"timestamp\":\n+\t\t\tj := strings.Index(val, \" \")\n+\t\t\tif j < 0 {\n+\t\t\t\treturn nil, fmt.Errorf(\"unexpected timestamp from bzr log: %q\", line)\n+\t\t\t}\n+\t\t\tt, err := time.Parse(\"2006-01-02 15:04:05 -0700\", val[j+1:])\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"unexpected timestamp from bzr log: %q\", line)\n+\t\t\t}\n+\t\t\ttm = t.UTC()\n+\t\t}\n+\t}\n+\tif revno == 0 || tm.IsZero() {\n+\t\treturn nil, fmt.Errorf(\"unexpected response from bzr log: %q\", out)\n+\t}\n+\n+\tinfo := &RevInfo{\n+\t\tName:    fmt.Sprintf(\"%d\", revno),\n+\t\tShort:   fmt.Sprintf(\"%012d\", revno),\n+\t\tTime:    tm,\n+\t\tVersion: rev,\n+\t}\n+\treturn info, nil\n+}\n+\n+func fossilParseStat(rev, out string) (*RevInfo, error) {\n+\tfor _, line := range strings.Split(out, \"\\n\") {\n+\t\tif strings.HasPrefix(line, \"uuid:\") {\n+\t\t\tf := strings.Fields(line)\n+\t\t\tif len(f) != 5 || len(f[1]) != 40 || f[4] != \"UTC\" {\n+\t\t\t\treturn nil, fmt.Errorf(\"unexpected response from fossil info: %q\", line)\n+\t\t\t}\n+\t\t\tt, err := time.Parse(\"2006-01-02 15:04:05\", f[2]+\" \"+f[3])\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"unexpected response from fossil info: %q\", line)\n+\t\t\t}\n+\t\t\thash := f[1]\n+\t\t\tversion := rev\n+\t\t\tif strings.HasPrefix(hash, version) {\n+\t\t\t\tversion = hash // extend to full hash\n+\t\t\t}\n+\t\t\tinfo := &RevInfo{\n+\t\t\t\tName:    hash,\n+\t\t\t\tShort:   ShortenSHA1(hash),\n+\t\t\t\tTime:    t,\n+\t\t\t\tVersion: version,\n+\t\t\t}\n+\t\t\treturn info, nil\n+\t\t}\n+\t}\n+\treturn nil, fmt.Errorf(\"unexpected response from fossil info: %q\", out)\n+}"}, {"sha": "9cf0e911508c01eb076a8e881919f55dd8a00a38", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "79b82786cb96548ba1bb93bd4dd04598d2ac2daf", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo_test.go", "status": "added", "additions": 643, "deletions": 0, "changes": 643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "2e26bac434da8d17a03c006bb770f636d1d1a397", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "9d713dcc6696877224011eceec547a2f4e5068db", "filename": "libgo/go/cmd/go/internal/modfetch/noweb.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fnoweb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fnoweb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fnoweb.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "5f856b80d2e16a1b2d69145856736fb93b82b4cc", "filename": "libgo/go/cmd/go/internal/modfetch/proxy.go", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "32c7bf883becd471344061028757e777f8d3c8a0", "filename": "libgo/go/cmd/go/internal/modfetch/pseudo.go", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "3c2fa5146890eaa3e59d2fbbabbb4109706a1d44", "filename": "libgo/go/cmd/go/internal/modfetch/pseudo_test.go", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "0ea8c1f0e35e8d00da36ca56c7beb7fd25ebb846", "filename": "libgo/go/cmd/go/internal/modfetch/repo.go", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "a50431fd8629de18f4cd9b2f1f5ee1b790852bf9", "filename": "libgo/go/cmd/go/internal/modfetch/unzip.go", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Funzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Funzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Funzip.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "b327bf293d1de604040d8be3b69dd3ac2fbf3418", "filename": "libgo/go/cmd/go/internal/modfetch/web.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fweb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fweb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fweb.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "c94b3848a0e163a4d4220f0f39e00a390cd38c23", "filename": "libgo/go/cmd/go/internal/modfile/gopkgin.go", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fgopkgin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fgopkgin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fgopkgin.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "cefc43b141c6e88daa9731a4430dbaa913fbedb4", "filename": "libgo/go/cmd/go/internal/modfile/print.go", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fprint.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "1d81ff1ab7a326061f9352bbfe485533b6f9a5f5", "filename": "libgo/go/cmd/go/internal/modfile/read.go", "status": "added", "additions": 869, "deletions": 0, "changes": 869, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fread.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "8cb1a3908c53f268cbb4b6d3217ba1ac0d1ab76e", "filename": "libgo/go/cmd/go/internal/modfile/read_test.go", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fread_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e11f0a6e31e152d1f887aff6dd5f82d556ab3b40", "filename": "libgo/go/cmd/go/internal/modfile/rule.go", "status": "added", "additions": 724, "deletions": 0, "changes": 724, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "b88ad62916845b2b72d4eef9a49ccb0215b6e3e0", "filename": "libgo/go/cmd/go/internal/modfile/rule_test.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "4aa2d634fc92aae932db31c85f4b30ecb0dc7b26", "filename": "libgo/go/cmd/go/internal/modfile/testdata/block.golden", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.golden?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "1dfae65f5c0f080da0f924eec8a188930df00498", "filename": "libgo/go/cmd/go/internal/modfile/testdata/block.in", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.in?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "75f3b84478c35048432005b3bc3f1354e2c6bc94", "filename": "libgo/go/cmd/go/internal/modfile/testdata/comment.golden", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.golden?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "bfc2492b26450c8f4d3671cdd0ba898b46cf2e3b", "filename": "libgo/go/cmd/go/internal/modfile/testdata/comment.in", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.in?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgo/go/cmd/go/internal/modfile/testdata/empty.golden", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.golden?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgo/go/cmd/go/internal/modfile/testdata/empty.in", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.in?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "41669b3a737bb148d4f4df9d209e2a13ccc129b8", "filename": "libgo/go/cmd/go/internal/modfile/testdata/gopkg.in.golden", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fgopkg.in.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fgopkg.in.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fgopkg.in.golden?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "78ba94398c3b56416443b67d6ac56bc755d5197c", "filename": "libgo/go/cmd/go/internal/modfile/testdata/module.golden", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.golden?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "08f383623f912fc029b24c7eb01187139d0f365a", "filename": "libgo/go/cmd/go/internal/modfile/testdata/module.in", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.in?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "5d6abcfcdadb27a7741a1822c71a2bf040d76198", "filename": "libgo/go/cmd/go/internal/modfile/testdata/replace.golden", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.golden?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "685249946a26fd741cfd62123feca42430420b2d", "filename": "libgo/go/cmd/go/internal/modfile/testdata/replace.in", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.in?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e1d9c728df4e4551d48b5586606cf2923ad56e07", "filename": "libgo/go/cmd/go/internal/modfile/testdata/replace2.golden", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.golden?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "786469866f90aa7ca48e89f90b0a862ebc138dd9", "filename": "libgo/go/cmd/go/internal/modfile/testdata/replace2.in", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.in?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "8a5c725894858ba36199eccb6ee2625e5f729420", "filename": "libgo/go/cmd/go/internal/modfile/testdata/rule1.golden", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Frule1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Frule1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Frule1.golden?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "90a5bd81302c75a6c0fd1364dc0f4acdbca99138", "filename": "libgo/go/cmd/go/internal/modget/get.go", "status": "added", "additions": 656, "deletions": 0, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "7341ce44d20ae01bd1876a27f1d2eafd5ec616da", "filename": "libgo/go/cmd/go/internal/modinfo/info.go", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "558401d01f6c6212c424732cad7993a7bf2b51eb", "filename": "libgo/go/cmd/go/internal/modload/build.go", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "f2f34197244a4fc33f48751aa2b960ae7c849a4d", "filename": "libgo/go/cmd/go/internal/modload/help.go", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "44c2a2372670b5c50eb008db4a8b6769d0ec0481", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "3f4ddab436cc49a79dc74c852d2b3acd66e4fc79", "filename": "libgo/go/cmd/go/internal/modload/import_test.go", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "f995bad13b5433a71246672d1f548c3522000da3", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "added", "additions": 600, "deletions": 0, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "69a832de1df52670af413d8ee7c9c526f472f7c4", "filename": "libgo/go/cmd/go/internal/modload/list.go", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "5bf6c9b1cf974615c3c829976a429d3f63e6fea7", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "added", "additions": 1071, "deletions": 0, "changes": 1071, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "3b550f1db7f74d1ee25196c951d12649bf1ef7d5", "filename": "libgo/go/cmd/go/internal/modload/query.go", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "7f3ffabef742035cf03634bf58d452c1d5420df0", "filename": "libgo/go/cmd/go/internal/modload/query_test.go", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "24825cc35d8a373582a28d1c9c8895cc2c54464f", "filename": "libgo/go/cmd/go/internal/modload/search.go", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "1dbb0f5cb7996ccf530332d6f20fdc26509f9690", "filename": "libgo/go/cmd/go/internal/module/module.go", "status": "added", "additions": 540, "deletions": 0, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "f21d620d328f8bf4425542a672494f2eb32ec301", "filename": "libgo/go/cmd/go/internal/module/module_test.go", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "8ec9162dabcdc267d5ecb18c21bc5be36fd7f4e8", "filename": "libgo/go/cmd/go/internal/mvs/mvs.go", "status": "added", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "2a27dfb28890d99ea24bd95313cbddcd89d324ae", "filename": "libgo/go/cmd/go/internal/mvs/mvs_test.go", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "a568c86f60b77c171ec438322e5bb980be38cd5b", "filename": "libgo/go/cmd/go/internal/par/work.go", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "f104bc4106f208bc2fac5ce36955a971e5e9f064", "filename": "libgo/go/cmd/go/internal/par/work_test.go", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "303e6842e7be3eb90b8268dae5c155b40e188886", "filename": "libgo/go/cmd/go/internal/run/run.go", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "60ae73696bb4c1baf24ccce8c7b44d35b2c0fa5e", "filename": "libgo/go/cmd/go/internal/search/search.go", "status": "added", "additions": 505, "deletions": 0, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "0bef765fa452b586038f3e4829d519aaf501bf07", "filename": "libgo/go/cmd/go/internal/search/search_test.go", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192", "previous_filename": "libgo/go/cmd/go/internal/load/match_test.go"}, {"sha": "4af7118e55d2ef7977266d9561027ca0f9935b02", "filename": "libgo/go/cmd/go/internal/semver/semver.go", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "96b64a58075498a0f9d68d810414addd3f67587e", "filename": "libgo/go/cmd/go/internal/semver/semver_test.go", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "a9b4d759a6b051fea2e3d83e9ff932e3d1bcac4d", "filename": "libgo/go/cmd/go/internal/str/path.go", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "9841791552dbbc125afa5b3fa4e193a62d4aaad1", "filename": "libgo/go/cmd/go/internal/test/cover.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fcover.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fcover.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fcover.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "a089f1b134a97694de6cafc59b6f513715b99d84", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 69, "deletions": 496, "changes": 565, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "73f8c69d9e171aafb89062c384d747bc86d94904", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "edcf93513d89e341374baf6db395036bd362750d", "filename": "libgo/go/cmd/go/internal/tool/tool.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "c384f33bdf831881fa666e780600a7eb3b663ca0", "filename": "libgo/go/cmd/go/internal/txtar/archive.go", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "3f734f6762531ec9e4444daa742572b45e1a0721", "filename": "libgo/go/cmd/go/internal/txtar/archive_test.go", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftxtar%2Farchive_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "9344a28dc36af57e2ca5953967a986fe2aad36ea", "filename": "libgo/go/cmd/go/internal/version/version.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "ea85fb8d5c97cfb861473f785388a651ec94eec5", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "50eac425ec3693331e1d93cf933f7448296e7c4e", "filename": "libgo/go/cmd/go/internal/vet/vetflag.go", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "f3900379e1784fd8774d0902872864e513b2f874", "filename": "libgo/go/cmd/go/internal/web2/web.go", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "c6f6b1eff4dd76b1079e4edcbc689bd8a450b363", "filename": "libgo/go/cmd/go/internal/web2/web_test.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "94b20a33ffc7d5813abe1b21e2df7575e30b33d5", "filename": "libgo/go/cmd/go/internal/webtest/test.go", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwebtest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwebtest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwebtest%2Ftest.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "82cf228fa44ea49badaf2e7c04cf4980767e3c60", "filename": "libgo/go/cmd/go/internal/work/action.go", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "ed41ce5d0730ab1ada89510acdc77a90c7e8eedb", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "010e17ee480578be4f6be3371fa9042ad5ee355e", "filename": "libgo/go/cmd/go/internal/work/build_test.go", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "fb57e9128026baa3d38ff4f0e3c87ca1bdc135ed", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 86, "deletions": 33, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "84870e52ccc05663e1df124b7eb61d4adccd370d", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 587, "deletions": 170, "changes": 757, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "6e5333ccbc40d45465c6ab42c7430bbf5a91b32e", "filename": "libgo/go/cmd/go/internal/work/gc.go", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "7255748b5c38a54c6a2a88165b7f53a9a9d99be5", "filename": "libgo/go/cmd/go/internal/work/gccgo.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "de0cd4282b369761bd7e7e97ec16aa516a65a516", "filename": "libgo/go/cmd/go/internal/work/init.go", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "d5d126123a4b0b6839503dadf31e5bf54ff9b281", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "d23b6eadff50e8db21e368755f9ee3530691bc61", "filename": "libgo/go/cmd/go/internal/work/security_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "14b435295ecbc038ebb935a8a989a99c2d9adc4a", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 93, "deletions": 11, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "212e5aa08f7a10c0fb43993328d7a17e93ef5ff1", "filename": "libgo/go/cmd/go/proxy_test.go", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "02cb17b04527b9735a84e815e815a4697f4c49d4", "filename": "libgo/go/cmd/go/script_test.go", "status": "added", "additions": 905, "deletions": 0, "changes": 905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "19850af0f37b29b22186c80a25d9bce6f7f696d1", "filename": "libgo/go/cmd/go/testdata/addmod.go", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "f7f642387004c4e9e4657e30fdd69ca30fe2a804", "filename": "libgo/go/cmd/go/testdata/badmod/go.mod", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fgo.mod?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "579fb086eeb744698ff9c095aa6250ec7fafebf0", "filename": "libgo/go/cmd/go/testdata/badmod/x.go", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fx.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "dc63c4b9f295b800294836b5531e175b4571a118", "filename": "libgo/go/cmd/go/testdata/importcycle/src/selfimport/selfimport.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcycle%2Fsrc%2Fselfimport%2Fselfimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcycle%2Fsrc%2Fselfimport%2Fselfimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcycle%2Fsrc%2Fselfimport%2Fselfimport.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "43ddf77eff3844b631665485abe511380ae7066a", "filename": "libgo/go/cmd/go/testdata/mod/README", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2FREADME?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "1ecfa0b6de97248921e6bd89c6f66e138f208ce7", "filename": "libgo/go/cmd/go/testdata/mod/example.com_join_subpkg_v1.0.0.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_subpkg_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_subpkg_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_subpkg_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "9eb823adb76c0219b5f03e8674d9609f9ec4e4b2", "filename": "libgo/go/cmd/go/testdata/mod/example.com_join_subpkg_v1.1.0.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_subpkg_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_subpkg_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_subpkg_v1.1.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "84c68b13b6de6238856aab8a1e9547dcf47f9556", "filename": "libgo/go/cmd/go/testdata/mod/example.com_join_v1.0.0.txt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "5f92036d9e7b248f14a14f4f652f73152a001e0f", "filename": "libgo/go/cmd/go/testdata/mod/example.com_join_v1.1.0.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_join_v1.1.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "b197b66398185a59f45822aab4ab1bce687e6127", "filename": "libgo/go/cmd/go/testdata/mod/example.com_split_subpkg_v1.1.0.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split_subpkg_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split_subpkg_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split_subpkg_v1.1.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "b706e590d98fd52d932a9fc9d9bd6a8af2f0291b", "filename": "libgo/go/cmd/go/testdata/mod/example.com_split_v1.0.0.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "d38971f9b62817c3b206fc1b0558d8a0468b83fe", "filename": "libgo/go/cmd/go/testdata/mod/example.com_split_v1.1.0.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split_v1.1.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "263287d9e2cf8a713700edc468524a0c671d3ae1", "filename": "libgo/go/cmd/go/testdata/mod/example.com_v1.0.0.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "0420a1a4a0aee33062b90750eb7428fe093fb5a4", "filename": "libgo/go/cmd/go/testdata/mod/golang.org_notx_useinternal_v0.1.0.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_notx_useinternal_v0.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_notx_useinternal_v0.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_notx_useinternal_v0.1.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "5737e95cf47fdb761f7d8701924b2b62b29ec74a", "filename": "libgo/go/cmd/go/testdata/mod/golang.org_x_internal_v0.1.0.txt", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_internal_v0.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_internal_v0.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_internal_v0.1.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "f4f50cdedb616ebb822ce89a152f2c09f168fe0a", "filename": "libgo/go/cmd/go/testdata/mod/golang.org_x_text_v0.0.0-20170915032832-14c0d48ead0c.txt", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_text_v0.0.0-20170915032832-14c0d48ead0c.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_text_v0.0.0-20170915032832-14c0d48ead0c.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_text_v0.0.0-20170915032832-14c0d48ead0c.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "5561afae8ed2fd52ee24afb4c3b8777cb62e0aba", "filename": "libgo/go/cmd/go/testdata/mod/golang.org_x_text_v0.3.0.txt", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_text_v0.3.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_text_v0.3.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_text_v0.3.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "3fcba447befe22d4dc35a54684cf49028ecefa9b", "filename": "libgo/go/cmd/go/testdata/mod/golang.org_x_useinternal_v0.1.0.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_useinternal_v0.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_useinternal_v0.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgolang.org_x_useinternal_v0.1.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "f174159fd3fddc0e2fdd8728a7f85d6f971abe6a", "filename": "libgo/go/cmd/go/testdata/mod/gopkg.in_dummy.v2-unstable_v2.0.0.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgopkg.in_dummy.v2-unstable_v2.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgopkg.in_dummy.v2-unstable_v2.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgopkg.in_dummy.v2-unstable_v2.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "0f060dc8e32fedcdbdf1a8b2f67823f891d273a4", "filename": "libgo/go/cmd/go/testdata/mod/research.swtch.com_vgo-tour_v1.0.0.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fresearch.swtch.com_vgo-tour_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fresearch.swtch.com_vgo-tour_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fresearch.swtch.com_vgo-tour_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "6276147535b445b33e1ebecc9d154e56186ebd49", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_!c!g!o_v1.0.0.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_!c!g!o_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_!c!g!o_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_!c!g!o_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "21185c39f3320ed7e5b5926cf18d48bd3a923fdc", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_!q!u!o!t!e_v1.5.2.txt", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_!q!u!o!t!e_v1.5.2.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_!q!u!o!t!e_v1.5.2.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_!q!u!o!t!e_v1.5.2.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "54bac2df7bb36867c48026adf215aae7cc6a24c6", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_!q!u!o!t!e_v1.5.3-!p!r!e.txt", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_!q!u!o!t!e_v1.5.3-!p!r!e.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_!q!u!o!t!e_v1.5.3-!p!r!e.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_!q!u!o!t!e_v1.5.3-!p!r!e.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "9d23e7db98cf3a7570713686600e36c97d1642e5", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_badfile1_v1.0.0.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile1_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile1_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile1_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "58e1e1c103acdb862f82b3781e2bda8fa50a0a59", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_badfile2_v1.0.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile2_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile2_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile2_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "a008448c5fd27a32e81d5370536ae621611a089e", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_badfile3_v1.0.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile3_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile3_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile3_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e28844dc632e55a767fcfd11df4e8bfb37e303a5", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_badfile4_v1.0.0.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile4_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile4_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile4_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "3c7903a3bc0c71b3df20e10062cc301b5730d48d", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_badfile5_v1.0.0.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile5_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile5_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badfile5_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "993ceb7a0be72a4ab5a5596357cea171bd72d653", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_badmod_v1.0.0.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badmod_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badmod_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badmod_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "a103e3f8aa1a926e2095665f1b7bc300a614cdb1", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_breaker_v1.0.0.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_breaker_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_breaker_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_breaker_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "59d8bacf07881356e60c8d7a196ffd534d505b6b", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_breaker_v2.0.0+incompatible.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_breaker_v2.0.0%2Bincompatible.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_breaker_v2.0.0%2Bincompatible.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_breaker_v2.0.0%2Bincompatible.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "59d8bacf07881356e60c8d7a196ffd534d505b6b", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_breaker_v2.0.0.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_breaker_v2.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_breaker_v2.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_breaker_v2.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "d8a71f3cd9397f993133aeaa9b1ebfffec51a507", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_fortune_v1.0.0.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_fortune_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_fortune_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_fortune_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "cfa91f08a5d84ba07ffd96eef8580a43c455899b", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_fortune_v2_v2.0.0.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_fortune_v2_v2.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_fortune_v2_v2.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_fortune_v2_v2.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "8ae173e7aec71ffd8055273a3617f0741f3091f4", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v0.0.0-20180214005133-e7a685a342c0.txt", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180214005133-e7a685a342c0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180214005133-e7a685a342c0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180214005133-e7a685a342c0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "bc626bac7a49e22f79368972e840cda549d0e4a6", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v0.0.0-20180214005840-23179ee8a569.txt", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180214005840-23179ee8a569.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180214005840-23179ee8a569.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180214005840-23179ee8a569.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "bbc8097dc3a2f9ba7c8b5d60f6c06f75c634ce91", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v0.0.0-20180628003336-dd9747d19b04.txt", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180628003336-dd9747d19b04.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180628003336-dd9747d19b04.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180628003336-dd9747d19b04.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e461ed4231e20b0ef009e985e869954e8ec46daf", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v0.0.0-20180709153244-fd906ed3b100.txt", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709153244-fd906ed3b100.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709153244-fd906ed3b100.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709153244-fd906ed3b100.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "c1d511fda71b9ea26ec793be0e2388b99534c5e0", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v0.0.0-20180709160352-0d003b9c4bfa.txt", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709160352-0d003b9c4bfa.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709160352-0d003b9c4bfa.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709160352-0d003b9c4bfa.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "f7f794d76dd79fcb475cf9cec13ec3a3d323b4fb", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v0.0.0-20180709162749-b44a0b17b2d1.txt", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709162749-b44a0b17b2d1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709162749-b44a0b17b2d1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709162749-b44a0b17b2d1.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "2d5d8b4e72aa36b2ef25a58ea0f846fd97a2eedb", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v0.0.0-20180709162816-fe488b867524.txt", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709162816-fe488b867524.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709162816-fe488b867524.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709162816-fe488b867524.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "853a8c2a1ac7fcc502340a22d4da6d8cb0117b6f", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v0.0.0-20180709162918-a91498bed0a7.txt", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709162918-a91498bed0a7.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709162918-a91498bed0a7.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180709162918-a91498bed0a7.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "2ebeac397146fa95b166a87c9c458c9df313776e", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v0.0.0-20180710144737-5d9f230bcfba.txt", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180710144737-5d9f230bcfba.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180710144737-5d9f230bcfba.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v0.0.0-20180710144737-5d9f230bcfba.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "9a0793744455fa9e4fba7fd68faef2bd90c10395", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v1.0.0.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "0c416053901ce1a4dcfe4198661d91eeaa6a5a47", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v1.1.0.txt", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.1.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e714f0b913719e8cec983d916d69237097961c3d", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v1.2.0.txt", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.2.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.2.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.2.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "89d5191d3a068eb92992252be8efbabd7698512a", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v1.2.1.txt", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.2.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.2.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.2.1.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "d62766c7d2b950f5ef290b8483d5c0a7bcdc6396", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v1.3.0.txt", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.3.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.3.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.3.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "698ff8de81222020e39d2df4711cb400d288587c", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v1.4.0.txt", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.4.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.4.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.4.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e7fcdbccff5317095c54d931abbcdf66ef85ca6f", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v1.5.0.txt", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "eed051bea04f18c2023002dcb5ff3a245c6e8959", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v1.5.1.txt", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.1.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "8671f6fe772de54147fadc51e1bbee57cbad2962", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v1.5.2.txt", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.2.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.2.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.2.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "212ef13aaf82503671712da0cb8b06ed8f1a4922", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v1.5.3-pre1.txt", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.3-pre1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.3-pre1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v1.5.3-pre1.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e461ed4231e20b0ef009e985e869954e8ec46daf", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v2.0.0.txt", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v2.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v2.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v2.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "d51128c46b9f602c74bf70a2e46c00b5101056de", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v2_v2.0.1.txt", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v2_v2.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v2_v2.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v2_v2.0.1.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "0afe1f0519992e9b0e43fbfd15ae710938f4bc83", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_quote_v3_v3.0.0.txt", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v3_v3.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v3_v3.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_quote_v3_v3.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "c4b6a71c88c405e927490bcfd356304bab1e2c1d", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_sampler_v1.0.0.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "98c35fa238901321e24e54dd9cbdcb0f69702f22", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_sampler_v1.2.0.txt", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.2.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.2.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.2.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "00b71bf0d59468aec1b6ea12dec809f8f755e67f", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_sampler_v1.2.1.txt", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.2.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.2.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.2.1.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "febe51fd9a93358f31e53637410521a4bc14e5c7", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_sampler_v1.3.0.txt", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.3.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.3.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.3.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "a293f108696ea3e114e3239567d570bb571b8904", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_sampler_v1.3.1.txt", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.3.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.3.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.3.1.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "5036d20ab58b79421e0b2c8a3b449766f8f14925", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_sampler_v1.99.99.txt", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.99.99.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.99.99.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.99.99.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "dfb8ca24ec9ce4a07feb55db2e14b0889bf11363", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_testonly_v1.0.0.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_testonly_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_testonly_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_testonly_v1.0.0.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "48a6318860776560d8fb4527317ea74a4805fc5a", "filename": "libgo/go/cmd/go/testdata/savedir.go", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsavedir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsavedir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsavedir.go?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "a80233b8c3830afd48cc2b0ce9f9b21b132b08e6", "filename": "libgo/go/cmd/go/testdata/script/README", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "397904efaa8ab0fc9ebc826d32e8001b985ffb9f", "filename": "libgo/go/cmd/go/testdata/script/binary_only.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbinary_only.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbinary_only.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbinary_only.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "4c387afbbabd7d9205181bb6295fbed34e7158a0", "filename": "libgo/go/cmd/go/testdata/script/build_GOTMPDIR.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "7db881a2682d6f45d8ac22939c8db50224a3c6ce", "filename": "libgo/go/cmd/go/testdata/script/build_cache_compile.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_compile.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_compile.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_compile.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "61e7ee46d3a78d8ff3792ab96e3f2faed4f69661", "filename": "libgo/go/cmd/go/testdata/script/build_cache_link.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_link.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_link.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_link.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "ee4099e5f356cb8eec818ddaf5c7496c6d19d9a8", "filename": "libgo/go/cmd/go/testdata/script/build_cache_output.txt", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_output.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_output.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_output.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "c122c05cb68930e27655d3896afe7d2ebf3096dc", "filename": "libgo/go/cmd/go/testdata/script/cover_atomic_pkgall.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_atomic_pkgall.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_atomic_pkgall.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_atomic_pkgall.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "5d169d631268e21f8bc851e82baa4644f3df8457", "filename": "libgo/go/cmd/go/testdata/script/cover_pkgall_runtime.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_runtime.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_runtime.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_runtime.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "142d5ee718dceb754630d4ae833b61f1dd7513f4", "filename": "libgo/go/cmd/go/testdata/script/cpu_profile_twice.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcpu_profile_twice.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcpu_profile_twice.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcpu_profile_twice.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "cdc3be2df8f12bb4b1b923351fc238c3ffc9b8fa", "filename": "libgo/go/cmd/go/testdata/script/fileline.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffileline.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffileline.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffileline.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "93341a302c86cf8942af1aac30d55d982f5f584f", "filename": "libgo/go/cmd/go/testdata/script/get_with_git_trace.txt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_with_git_trace.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_with_git_trace.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_with_git_trace.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "20de325ac286b7b89ad190aff4187c08e250df98", "filename": "libgo/go/cmd/go/testdata/script/goflags.txt", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "cbbd15404b53683fb3d402a3ae6b91518e01ff3b", "filename": "libgo/go/cmd/go/testdata/script/help.txt", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fhelp.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fhelp.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fhelp.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "b8d322de629899ea638dddc9dd25ae25f6f65ad0", "filename": "libgo/go/cmd/go/testdata/script/install_cleans_build.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cleans_build.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cleans_build.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cleans_build.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "f85e896f61ef7813aba88bfad1f849a61c0889a6", "filename": "libgo/go/cmd/go/testdata/script/install_cross_gobin.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "d42b07004bf62880887ebece9e951352e4180957", "filename": "libgo/go/cmd/go/testdata/script/install_rebuild_gopath.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_gopath.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_gopath.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_gopath.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e7620a08caebee224c2d553610ad0482e3b57d3f", "filename": "libgo/go/cmd/go/testdata/script/install_rebuild_removed.txt", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_removed.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_removed.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_removed.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "e2ec00c6edc3d8aa4aa8cf8e9d84bf5324e138cc", "filename": "libgo/go/cmd/go/testdata/script/linkname.txt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flinkname.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flinkname.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flinkname.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "ba66b0937f84aebf71e979c7522f883615ddd3dc", "filename": "libgo/go/cmd/go/testdata/script/list_bad_import.txt", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "2c883b60610f9e05c82411c1dbd1d4d09b724039", "filename": "libgo/go/cmd/go/testdata/script/list_compiled_imports.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_compiled_imports.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_compiled_imports.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_compiled_imports.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "dbe8fb0ac98cea704f5eb2f3b5f655451aefe4e8", "filename": "libgo/go/cmd/go/testdata/script/list_find.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_find.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_find.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_find.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}, {"sha": "a63d74db1205a4a905e319eb59b195ce0625163e", "filename": "libgo/go/cmd/go/testdata/script/list_std.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_std.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd931d9b48647e898dc80927c532ae93cc09e192/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_std.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_std.txt?ref=dd931d9b48647e898dc80927c532ae93cc09e192"}]}