{"sha": "be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU4YzFjOGNjMGZmM2RhNzFlNGNmYjU1M2UyN2EyODMyZjRhOTM5ZA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2013-11-07T08:12:34Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2013-11-07T08:12:34Z"}, "message": "tree-ssa-loop-ivopts.c (alloc_iv): Lower address expressions.\n\n\n\t* tree-ssa-loop-ivopts.c (alloc_iv): Lower address expressions.\n\t* tree-affine.c (get_inner_reference_aff): Return base.\n\t* tree-affine.h (get_inner_reference_aff): Change prototype.\n\n\t* gcc.dg/tree-ssa/loop-2.c: Refine check condition.\n\t* gcc.dg/tree-ssa/ivopt_infer_2.c: Ditto.\n\t* gcc.dg/tree-ssa/ivopt_mult_3.c: Ditto.\n\nFrom-SVN: r204497", "tree": {"sha": "c0e359d6da2982c6ccbbe62856a6514b7b8eaf3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0e359d6da2982c6ccbbe62856a6514b7b8eaf3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/comments", "author": null, "committer": null, "parents": [{"sha": "196bb3237d1485b742e357be1c31771c5a0a35df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/196bb3237d1485b742e357be1c31771c5a0a35df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/196bb3237d1485b742e357be1c31771c5a0a35df"}], "stats": {"total": 53, "additions": 44, "deletions": 9}, "files": [{"sha": "fcbcbb5466f9a1a89bb6be98d554097e985e2053", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "patch": "@@ -1,3 +1,9 @@\n+2013-11-07  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (alloc_iv): Lower address expressions.\n+\t* tree-affine.c (get_inner_reference_aff): Return base.\n+\t* tree-affine.h (get_inner_reference_aff): Change prototype.\n+\n 2013-11-06  Tobias Burnus  <burnus@net-b.de>\n \n \t* doc/invoke.texi (Wdate-time): Fix typo."}, {"sha": "c89765b998c157f9668c8eb2b4ee27aeba804eb7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "patch": "@@ -1,3 +1,9 @@\n+2013-11-07  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/loop-2.c: Refine check condition.\n+\t* gcc.dg/tree-ssa/ivopt_infer_2.c: Ditto.\n+\t* gcc.dg/tree-ssa/ivopt_mult_3.c: Ditto.\n+\n 2013-11-06  DJ Delorie  <dj@redhat.com>\n \n \t* gcc.dg/mismatch-decl-1.c: New test."}, {"sha": "c0f6398d827cd261427b3e9dd7cec82830550e1a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_infer_2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_infer_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_infer_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_infer_2.c?ref=be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "patch": "@@ -7,7 +7,8 @@\n \n extern char a[];\n \n-/* Can not infer loop iteration from array -- exit test can not be replaced.  */\n+/* Can not infer loop iteration from array -- exit test can not be\n+   replaced by the array address.  */\n void foo (unsigned int i_width, TYPE dst)\n {\n   unsigned long long i = 0;\n@@ -21,5 +22,5 @@ void foo (unsigned int i_width, TYPE dst)\n     }\n }\n \n-/* { dg-final { scan-tree-dump-times \"Replacing\" 0 \"ivopts\"} } */\n+/* { dg-final { scan-tree-dump-times \"\\[^:\\]*if \\\\(.*j_\\[0-9\\]+.*\\\\)\" 1 \"ivopts\"} } */\n /* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "25ae845f71e21f2bcaa7a26ec8baf4ebaf4abfc1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_3.c?ref=be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "patch": "@@ -18,5 +18,5 @@ long foo(long* p, long* p2, int N1, int N2)\n   return s;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Replacing\" 1 \"ivopts\"} } */\n+/* { dg-final { scan-tree-dump-times \"Replacing exit test: if \\\\(.*p2.*\\\\)\" 1 \"ivopts\"} } */\n /* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "f43a6d8eb77ea0fdceda05e4781bf7940b5130cc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-2.c?ref=be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "patch": "@@ -27,7 +27,7 @@ void xxx(void)\n \n /* { dg-final { scan-tree-dump-times \" \\\\* \\[^\\\\n\\\\r\\]*=\" 0 \"optimized\" } } */\n /* { dg-final { scan-tree-dump-times \"\\[^\\\\n\\\\r\\]*= \\\\* \" 0 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \"MEM\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[base\" 1 \"optimized\" } } */\n \n /* 17 * iter should be strength reduced.  */\n "}, {"sha": "b492ff0a2118456cb1a41b1ed44f384ab7a5396b", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "patch": "@@ -874,10 +874,11 @@ debug_aff (aff_tree *val)\n   fprintf (stderr, \"\\n\");\n }\n \n-/* Returns address of the reference REF in ADDR.  The size of the accessed\n-   location is stored to SIZE.  */\n+/* Computes address of the reference REF in ADDR.  The size of the accessed\n+   location is stored to SIZE.  Returns the ultimate containing object to\n+   which REF refers.  */\n \n-void\n+tree\n get_inner_reference_aff (tree ref, aff_tree *addr, double_int *size)\n {\n   HOST_WIDE_INT bitsize, bitpos;\n@@ -904,6 +905,8 @@ get_inner_reference_aff (tree ref, aff_tree *addr, double_int *size)\n   aff_combination_add (addr, &tmp);\n \n   *size = double_int::from_shwi ((bitsize + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n+\n+  return base;\n }\n \n /* Returns true if a region of size SIZE1 at position 0 and a region of"}, {"sha": "86f90d82da08a227f5d0aecf56969d68bea39f84", "filename": "gcc/tree-affine.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftree-affine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftree-affine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.h?ref=be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "patch": "@@ -74,7 +74,7 @@ bool aff_combination_constant_multiple_p (aff_tree *, aff_tree *, double_int *);\n void aff_combination_expand (aff_tree *, struct pointer_map_t **);\n void tree_to_aff_combination_expand (tree, tree, aff_tree *,\n \t\t\t\t     struct pointer_map_t **);\n-void get_inner_reference_aff (tree, aff_tree *, double_int *);\n+tree get_inner_reference_aff (tree, aff_tree *, double_int *);\n void free_affine_expand_cache (struct pointer_map_t **);\n bool aff_comb_cannot_overlap_p (aff_tree *, double_int, double_int);\n "}, {"sha": "220aae6878b762f0506d455e68de9c056488e7c8", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=be8c1c8cc0ff3da71e4cfb553e27a2832f4a939d", "patch": "@@ -924,11 +924,30 @@ determine_base_object (tree expr)\n static struct iv *\n alloc_iv (tree base, tree step)\n {\n+  tree base_object = base;\n   struct iv *iv = XCNEW (struct iv);\n   gcc_assert (step != NULL_TREE);\n \n+  /* Lower all address expressions except ones with DECL_P as operand.\n+     By doing this:\n+       1) More accurate cost can be computed for address expressions;\n+       2) Duplicate candidates won't be created for bases in different\n+          forms, like &a[0] and &a.  */\n+  STRIP_NOPS (base_object);\n+  if (TREE_CODE (base_object) == ADDR_EXPR\n+      && !DECL_P (TREE_OPERAND (base_object, 0)))\n+    {\n+      aff_tree comb;\n+      double_int size;\n+      base_object = get_inner_reference_aff (TREE_OPERAND (base_object, 0),\n+\t\t\t\t\t     &comb, &size);\n+      gcc_assert (base_object != NULL_TREE);\n+      base_object = build_fold_addr_expr (base_object);\n+      base = fold_convert (TREE_TYPE (base), aff_combination_to_tree (&comb));\n+    }\n+\n   iv->base = base;\n-  iv->base_object = determine_base_object (base);\n+  iv->base_object = determine_base_object (base_object);\n   iv->step = step;\n   iv->biv_p = false;\n   iv->have_use_for = false;"}]}