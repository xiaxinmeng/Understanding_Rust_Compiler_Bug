{"sha": "b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZjOGU1YmVlNzEyZWNkZTkxMGUwNDk1ZTQ2ZjUyMTZhN2M5YTYwYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:37:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:37:41Z"}, "message": "[multiple changes]\n\n2014-07-30  Robert Dewar  <dewar@adacore.com>\n\n\t* g-forstr.adb: Minor code reorganization (use J rather than I\n\tas a variable name).\n\t* gnat_rm.texi, sem_prag.adb, sem_util.adb, sem_ch13.adb,\n\tg-forstr.ads: Minor reformatting.\n\n2014-07-30  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sprint.adb (Set_Debug_Sloc): Also reset the end location if\n\twe are debugging the generated code.\n\n2014-07-30  Yannick Moy  <moy@adacore.com>\n\n\t* sinput.ads, sinput.adb (Comes_From_Inlined_Body): New function that\n\treturns True for source pointer for an inlined body.\n\n2014-07-30  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch4.adb (Apply_Accessibility_Check): Add\n\tmissing calls to Base_Address().\n\n2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Hanalyze_Subprogram_Body_Helper): In GNATprove\n\tmode, subprogram bodies without a previous declaration are also\n\tcandidates for front-end inlining.\n\nFrom-SVN: r213242", "tree": {"sha": "1ef75048cc3c0c738f1de99c7172e436d221568f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ef75048cc3c0c738f1de99c7172e436d221568f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/comments", "author": null, "committer": null, "parents": [{"sha": "2f6f8285368749fd716178f92e3131d003b6a18c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6f8285368749fd716178f92e3131d003b6a18c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f6f8285368749fd716178f92e3131d003b6a18c"}], "stats": {"total": 373, "additions": 254, "deletions": 119}, "files": [{"sha": "4721dc83984cb559d14e7adcc836cfc9bc32fd13", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -1,3 +1,31 @@\n+2014-07-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* g-forstr.adb: Minor code reorganization (use J rather than I\n+\tas a variable name).\n+\t* gnat_rm.texi, sem_prag.adb, sem_util.adb, sem_ch13.adb,\n+\tg-forstr.ads: Minor reformatting.\n+\n+2014-07-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sprint.adb (Set_Debug_Sloc): Also reset the end location if\n+\twe are debugging the generated code.\n+\n+2014-07-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* sinput.ads, sinput.adb (Comes_From_Inlined_Body): New function that\n+\treturns True for source pointer for an inlined body.\n+\n+2014-07-30  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch4.adb (Apply_Accessibility_Check): Add\n+\tmissing calls to Base_Address().\n+\n+2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Hanalyze_Subprogram_Body_Helper): In GNATprove\n+\tmode, subprogram bodies without a previous declaration are also\n+\tcandidates for front-end inlining.\n+\n 2014-07-30  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* aspects.ads Aspects Async_Readers, Async_Writers,"}, {"sha": "10cf558a29d0e6fc690915b961716e5c38d7dec6", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -758,6 +758,25 @@ package body Exp_Ch4 is\n                Obj_Ref := New_Occurrence_Of (Ref, Loc);\n             end if;\n \n+            --  For access to interface types we must generate code to displace\n+            --  the pointer to the base of the object since the subsequent code\n+            --  references components located in the TSD of the object (which\n+            --  is associated with the primary dispatch table --see a-tags.ads)\n+            --  and also generates code invoking Free, which requires also a\n+            --  reference to the base of the unallocated object.\n+\n+            if Is_Interface (DesigT) then\n+               Obj_Ref :=\n+                 Unchecked_Convert_To (Etype (Obj_Ref),\n+                   Make_Function_Call (Loc,\n+                     Name =>\n+                       New_Occurrence_Of\n+                         (RTE (RE_Base_Address), Loc),\n+                     Parameter_Associations => New_List (\n+                       Unchecked_Convert_To (RTE (RE_Address),\n+                         New_Copy_Tree (Obj_Ref)))));\n+            end if;\n+\n             --  Step 1: Create the object clean up code\n \n             Stmts := New_List;\n@@ -831,26 +850,13 @@ package body Exp_Ch4 is\n \n             --  Step 2: Create the accessibility comparison\n \n-            --  Reference the tag: for a renaming of an access to an interface\n-            --  object Obj_Ref already references the tag of the secondary\n-            --  dispatch table.\n-\n-            if Nkind (Obj_Ref) in N_Has_Entity\n-              and then Present (Entity (Obj_Ref))\n-              and then Present (Renamed_Object (Entity (Obj_Ref)))\n-              and then Is_Interface (DesigT)\n-            then\n-               null;\n-\n             --  Generate:\n             --    Ref'Tag\n \n-            else\n-               Obj_Ref :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix         => Obj_Ref,\n-                   Attribute_Name => Name_Tag);\n-            end if;\n+            Obj_Ref :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => Obj_Ref,\n+                Attribute_Name => Name_Tag);\n \n             --  For tagged types, determine the accessibility level by looking\n             --  at the type specific data of the dispatch table. Generate:"}, {"sha": "a6ebc919303229c847256c229e5044fc22032a9f", "filename": "gcc/ada/g-forstr.adb", "status": "modified", "additions": 107, "deletions": 77, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fg-forstr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fg-forstr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-forstr.adb?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -64,7 +64,7 @@ package body GNAT.Formatted_String is\n \n    type F_Base is (None, C_Style, Ada_Style) with Default_Value => None;\n \n-   Unset    : constant Integer := -1;\n+   Unset : constant Integer := -1;\n \n    type F_Data is record\n       Kind         : F_Kind;\n@@ -78,12 +78,16 @@ package body GNAT.Formatted_String is\n    end record;\n \n    procedure Next_Format\n-     (Format : Formatted_String; F_Spec : out F_Data; Start : out Positive);\n+     (Format : Formatted_String;\n+      F_Spec : out F_Data;\n+      Start  : out Positive);\n    --  Parse the next format specifier, a format specifier has the following\n    --  syntax: %[flags][width][.precision][length]specifier\n \n    function Get_Formatted\n-     (F_Spec : F_Data; Value : String; Len : Positive) return String;\n+     (F_Spec : F_Data;\n+      Value  : String;\n+      Len    : Positive) return String;\n    --  Returns Value formatted given the information in F_Spec\n \n    procedure Raise_Wrong_Format (Format : Formatted_String) with No_Return;\n@@ -98,7 +102,8 @@ package body GNAT.Formatted_String is\n          Aft  : Text_IO.Field;\n          Exp  : Text_IO.Field);\n    function P_Flt_Format\n-     (Format : Formatted_String; Var : Flt) return Formatted_String;\n+     (Format : Formatted_String;\n+      Var    : Flt) return Formatted_String;\n    --  Generic routine which handles all floating point numbers\n \n    generic\n@@ -113,7 +118,8 @@ package body GNAT.Formatted_String is\n          Item : Int;\n          Base : Text_IO.Number_Base);\n    function P_Int_Format\n-     (Format : Formatted_String; Var : Int) return Formatted_String;\n+     (Format : Formatted_String;\n+      Var    : Int) return Formatted_String;\n    --  Generic routine which handles all the integer numbers\n \n    ---------\n@@ -134,24 +140,25 @@ package body GNAT.Formatted_String is\n \n    function \"-\" (Format : Formatted_String) return String is\n       F : String renames Format.D.Format;\n-      I : Natural renames Format.D.Index;\n+      J : Natural renames Format.D.Index;\n       R : Unbounded_String := Format.D.Result;\n+\n    begin\n       --  Make sure we get the remaining character up to the next unhandled\n       --  format specifier.\n \n-      while (I <= F'Length and then F (I) /= '%')\n-        or else (I < F'Length - 1 and then F (I + 1) = '%')\n+      while (J <= F'Length and then F (J) /= '%')\n+        or else (J < F'Length - 1 and then F (J + 1) = '%')\n       loop\n-         Append (R, F (I));\n+         Append (R, F (J));\n \n          --  If we have two consecutive %, skip the second one\n \n-         if F (I) = '%' and then I < F'Length - 1 and then F (I + 1) = '%' then\n-            I := I + 1;\n+         if F (J) = '%' and then J < F'Length - 1 and then F (J + 1) = '%' then\n+            J := J + 1;\n          end if;\n \n-         I := I + 1;\n+         J := J + 1;\n       end loop;\n \n       return To_String (R);\n@@ -167,6 +174,7 @@ package body GNAT.Formatted_String is\n    is\n       F     : F_Data;\n       Start : Positive;\n+\n    begin\n       Next_Format (Format, F, Start);\n \n@@ -190,6 +198,7 @@ package body GNAT.Formatted_String is\n    is\n       F     : F_Data;\n       Start : Positive;\n+\n    begin\n       Next_Format (Format, F, Start);\n \n@@ -282,6 +291,7 @@ package body GNAT.Formatted_String is\n       A_Img : constant String := System.Address_Image (Var);\n       F     : F_Data;\n       Start : Positive;\n+\n    begin\n       Next_Format (Format, F, Start);\n \n@@ -337,11 +347,11 @@ package body GNAT.Formatted_String is\n    --------------\n \n    overriding procedure Finalize (F : in out Formatted_String) is\n-\n       procedure Unchecked_Free is\n         new Unchecked_Deallocation (Data, Data_Access);\n \n       D : Data_Access := F.D;\n+\n    begin\n       F.D := null;\n \n@@ -391,8 +401,9 @@ package body GNAT.Formatted_String is\n \n       Res : Unbounded_String;\n       S   : Positive := Value'First;\n+\n    begin\n-      --  Let's hanfles the flags\n+      --  Handle the flags\n \n       if F_Spec.Kind in Is_Number then\n          if F_Spec.Sign = Forced and then Value (Value'First) /= '-' then\n@@ -442,10 +453,14 @@ package body GNAT.Formatted_String is\n      (Format : Formatted_String;\n       Var    : Int) return Formatted_String\n    is\n-      function Sign (Var : Int) return Sign_Kind\n-      is (if Var < 0 then Neg elsif Var = 0 then Zero else Pos);\n-      function To_Integer (Var : Int) return Integer is (Integer (Var));\n+      function Sign (Var : Int) return Sign_Kind is\n+        (if Var < 0 then Neg elsif Var = 0 then Zero else Pos);\n+\n+      function To_Integer (Var : Int) return Integer is\n+        (Integer (Var));\n+\n       function Int_Format is new P_Int_Format (Int, To_Integer, Sign, Put);\n+\n    begin\n       return Int_Format (Format, Var);\n    end Int_Format;\n@@ -458,10 +473,14 @@ package body GNAT.Formatted_String is\n      (Format : Formatted_String;\n       Var    : Int) return Formatted_String\n    is\n-      function Sign (Var : Int) return Sign_Kind\n-        is (if Var < 0 then Neg elsif Var = 0 then Zero else Pos);\n-      function To_Integer (Var : Int) return Integer is (Integer (Var));\n+      function Sign (Var : Int) return Sign_Kind is\n+        (if Var < 0 then Neg elsif Var = 0 then Zero else Pos);\n+\n+      function To_Integer (Var : Int) return Integer is\n+        (Integer (Var));\n+\n       function Int_Format is new P_Int_Format (Int, To_Integer, Sign, Put);\n+\n    begin\n       return Int_Format (Format, Var);\n    end Mod_Format;\n@@ -475,131 +494,139 @@ package body GNAT.Formatted_String is\n       F_Spec : out F_Data;\n       Start  : out Positive)\n    is\n-      F              : String renames Format.D.Format;\n-      I              : Natural renames Format.D.Index;\n+      F              : String  renames Format.D.Format;\n+      J              : Natural renames Format.D.Index;\n       S              : Natural;\n       Width_From_Var : Boolean := False;\n+\n    begin\n       Format.D.Current := Format.D.Current + 1;\n       F_Spec.Value_Needed := 0;\n \n       --  Got to next %\n \n-      while (I <= F'Last and then F (I) /= '%')\n-        or else (I < F'Last - 1 and then F (I + 1) = '%')\n+      while (J <= F'Last and then F (J) /= '%')\n+        or else (J < F'Last - 1 and then F (J + 1) = '%')\n       loop\n-         Append (Format.D.Result, F (I));\n+         Append (Format.D.Result, F (J));\n \n          --  If we have two consecutive %, skip the second one\n \n-         if F (I) = '%' and then I < F'Last - 1 and then F (I + 1) = '%' then\n-            I := I + 1;\n+         if F (J) = '%' and then J < F'Last - 1 and then F (J + 1) = '%' then\n+            J := J + 1;\n          end if;\n \n-         I := I + 1;\n+         J := J + 1;\n       end loop;\n \n-      if F (I) /= '%' or else I = F'Last then\n+      if F (J) /= '%' or else J = F'Last then\n          raise Format_Error with \"no format specifier found for parameter\"\n            & Positive'Image (Format.D.Current);\n       end if;\n \n-      Start := I;\n+      Start := J;\n \n-      I := I + 1;\n+      J := J + 1;\n \n       --  Check for any flags\n \n-      Flags_Check : while I < F'Last loop\n-         if F (I) = '-' then\n+      Flags_Check : while J < F'Last loop\n+         if F (J) = '-' then\n             F_Spec.Left_Justify := True;\n-         elsif F (I) = '+' then\n-            F_Spec.Sign := Forced;\n-         elsif F (I) = ' ' then\n-            F_Spec.Sign := Space;\n-         elsif F (I) = '#' then\n-            F_Spec.Base := C_Style;\n-         elsif F (I) = '~' then\n-            F_Spec.Base := Ada_Style;\n-         elsif F (I) = '0' then\n-            F_Spec.Zero_Pad := True;\n+         elsif F (J) = '+' then\n+            F_Spec.Sign         := Forced;\n+         elsif F (J) = ' ' then\n+            F_Spec.Sign         := Space;\n+         elsif F (J) = '#' then\n+            F_Spec.Base         := C_Style;\n+         elsif F (J) = '~' then\n+            F_Spec.Base         := Ada_Style;\n+         elsif F (J) = '0' then\n+            F_Spec.Zero_Pad     := True;\n          else\n             exit Flags_Check;\n          end if;\n \n-         I := I + 1;\n+         J := J + 1;\n       end loop Flags_Check;\n \n       --  Check width if any\n \n-      if F (I) in '0' .. '9' then\n+      if F (J) in '0' .. '9' then\n+\n          --  We have a width parameter\n \n-         S := I;\n+         S := J;\n \n-         while I < F'Last and then F (I + 1) in '0' .. '9' loop\n-            I := I + 1;\n+         while J < F'Last and then F (J + 1) in '0' .. '9' loop\n+            J := J + 1;\n          end loop;\n \n-         F_Spec.Width := Natural'Value (F (S .. I));\n+         F_Spec.Width := Natural'Value (F (S .. J));\n+\n+         J := J + 1;\n \n-         I := I + 1;\n+      elsif F (J) = '*' then\n \n-      elsif F (I) = '*' then\n          --  The width will be taken from the integer parameter\n \n          F_Spec.Value_Needed := 1;\n          Width_From_Var := True;\n \n-         I := I + 1;\n+         J := J + 1;\n       end if;\n \n-      if F (I) = '.' then\n+      if F (J) = '.' then\n+\n          --  We have a precision parameter\n \n-         I := I + 1;\n+         J := J + 1;\n \n-         if F (I) in '0' .. '9' then\n-            S := I;\n+         if F (J) in '0' .. '9' then\n+            S := J;\n \n-            while I < F'Length and then F (I + 1) in '0' .. '9' loop\n-               I := I + 1;\n+            while J < F'Length and then F (J + 1) in '0' .. '9' loop\n+               J := J + 1;\n             end loop;\n \n-            if F (I) = '.' then\n+            if F (J) = '.' then\n+\n                --  No precision, 0 is assumed\n+\n                F_Spec.Precision := 0;\n+\n             else\n-               F_Spec.Precision := Natural'Value (F (S .. I));\n+               F_Spec.Precision := Natural'Value (F (S .. J));\n             end if;\n \n-            I := I + 1;\n+            J := J + 1;\n+\n+         elsif F (J) = '*' then\n \n-         elsif F (I) = '*' then\n             --  The prevision will be taken from the integer parameter\n \n             F_Spec.Value_Needed := F_Spec.Value_Needed + 1;\n-            I := I + 1;\n+            J := J + 1;\n          end if;\n       end if;\n \n       --  Skip the length specifier, this is not needed for this implementation\n       --  but yet for compatibility reason it is handled.\n \n       Length_Check :\n-      while I <= F'Last\n-        and then F (I) in 'h' | 'l' | 'j' | 'z' | 't' | 'L'\n+      while J <= F'Last\n+        and then F (J) in 'h' | 'l' | 'j' | 'z' | 't' | 'L'\n       loop\n-         I := I + 1;\n+         J := J + 1;\n       end loop Length_Check;\n \n-      if I > F'Last then\n+      if J > F'Last then\n          Raise_Wrong_Format (Format);\n       end if;\n \n       --  Read next character which should be the expected type\n \n-      case F (I) is\n+      case F (J) is\n          when 'c'       => F_Spec.Kind := Char;\n          when 's'       => F_Spec.Kind := Str;\n          when 'd' | 'i' => F_Spec.Kind := Decimal_Int;\n@@ -618,7 +645,7 @@ package body GNAT.Formatted_String is\n               & Positive'Image (Format.D.Current);\n       end case;\n \n-      I := I + 1;\n+      J := J + 1;\n \n       if F_Spec.Value_Needed > 0\n         and then F_Spec.Value_Needed = Format.D.Stored_Value\n@@ -650,6 +677,7 @@ package body GNAT.Formatted_String is\n       S, E   : Positive := 1;\n       Start  : Positive;\n       Aft    : Text_IO.Field;\n+\n    begin\n       Next_Format (Format, F, Start);\n \n@@ -682,6 +710,7 @@ package body GNAT.Formatted_String is\n             end if;\n \n          when Shortest_Decimal_Float | Shortest_Decimal_Float_Up =>\n+\n             --  Without exponent\n \n             Put (Buffer, Var, Aft, Exp => 0);\n@@ -693,6 +722,7 @@ package body GNAT.Formatted_String is\n             declare\n                Buffer2 : String (1 .. 50);\n                S2, E2  : Positive;\n+\n             begin\n                Put (Buffer2, Var, Aft, Exp => 3);\n                S2 := Strings.Fixed.Index_Non_Blank (Buffer2);\n@@ -717,7 +747,7 @@ package body GNAT.Formatted_String is\n       end case;\n \n       Append (Format.D.Result,\n-              Get_Formatted (F, Buffer (S .. E), Buffer (S .. E)'Length));\n+        Get_Formatted (F, Buffer (S .. E), Buffer (S .. E)'Length));\n \n       return Format;\n    end P_Flt_Format;\n@@ -730,7 +760,6 @@ package body GNAT.Formatted_String is\n      (Format : Formatted_String;\n       Var    : Int) return Formatted_String\n    is\n-\n       function Handle_Precision return Boolean;\n       --  Return True if nothing else to do\n \n@@ -761,6 +790,8 @@ package body GNAT.Formatted_String is\n          return False;\n       end Handle_Precision;\n \n+   --  Start of processing for P_Int_Format\n+\n    begin\n       Next_Format (Format, F, Start);\n \n@@ -868,8 +899,7 @@ package body GNAT.Formatted_String is\n       --  Then add base if needed\n \n       declare\n-         N : String :=\n-               Get_Formatted (F, Buffer (S .. E), E - S + 1 + Len);\n+         N : String := Get_Formatted (F, Buffer (S .. E), E - S + 1 + Len);\n          P : constant Positive :=\n                (if F.Left_Justify\n                 then N'First\n@@ -915,9 +945,8 @@ package body GNAT.Formatted_String is\n                      N (N'First .. N'First + 1) := \"8#\";\n                      N (N'Last) := '#';\n \n-                  when Unsigned_Hexadecimal_Int\n-                    | Unsigned_Hexadecimal_Int_Up\n-                    =>\n+                  when Unsigned_Hexadecimal_Int    |\n+                       Unsigned_Hexadecimal_Int_Up =>\n                      if F.Left_Justify then\n                         N (N'First + 3 .. N'Last) := N (N'First .. N'Last - 3);\n                      else\n@@ -944,7 +973,8 @@ package body GNAT.Formatted_String is\n \n    procedure Raise_Wrong_Format (Format : Formatted_String) is\n    begin\n-      raise Format_Error with \"wrong format specified for parameter\"\n+      raise Format_Error with\n+        \"wrong format specified for parameter\"\n         & Positive'Image (Format.D.Current);\n    end Raise_Wrong_Format;\n "}, {"sha": "94c295c7251c8f3e5097ec028e573930a93a36bc", "filename": "gcc/ada/g-forstr.ads", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fg-forstr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fg-forstr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-forstr.ads?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -30,26 +30,24 @@\n ------------------------------------------------------------------------------\n \n --  This package add support for formatted string as supported by C printf().\n---\n+\n --  A simple usage is:\n---\n+\n --     declare\n --        F : Formatted_String := +\"['%c' ; %10d]\";\n --        C : Character := 'v';\n --        I : Integer := 98;\n --     begin\n --        F := F & C & I;\n --        Put_Line (-F);\n---\n --     end;\n---\n+\n --  Which will display:\n---\n+\n --     ['v' ;         98]\n---\n---\n+\n --  Each format specifier is: %[flags][width][.precision][length]specifier\n---\n+\n --  Specifiers:\n --    d or i    Signed decimal integer\n --    u         Unsigned decimal integer\n@@ -66,29 +64,37 @@\n --    s         String of characters\n --    p         Pointer address\n --    %         A % followed by another % character will write a single %\n---\n+\n --  Flags:\n+\n --    -         Left-justify within the given field width;\n---              Right justification is the default\n+--              Right justification is the default.\n+\n --    +         Forces to preceed the result with a plus or minus sign (+ or -)\n --              even for positive numbers. By default, only negative numbers\n --              are preceded with a - sign.\n+\n --    (space)   If no sign is going to be written, a blank space is inserted\n --              before the value.\n+\n --    #         Used with o, x or X specifiers the value is preceeded with\n --              0, 0x or 0X respectively for values different than zero.\n --              Used with a, A, e, E, f, F, g or G it forces the written\n --              output to contain a decimal point even if no more digits\n --              follow. By default, if no digits follow, no decimal point is\n --              written.\n+\n --    ~         As above, but using Ada style based <base>#<number>#\n+\n --    0         Left-pads the number with zeroes (0) instead of spaces when\n --              padding is specified.\n+\n --  Width:\n --    number    Minimum number of characters to be printed. If the value to\n --              be printed is shorter than this number, the result is padded\n --              with blank spaces. The value is not truncated even if the\n --              result is larger.\n+\n --    *         The width is not specified in the format string, but as an\n --              additional integer value argument preceding the argument that\n --              has to be formatted.\n@@ -99,15 +105,19 @@\n --              leading zeros. The value is not truncated even if the result\n --              is longer. A precision of 0 means that no character is written\n --              for the value 0.\n+\n --              For e, E, f and F specifiers: this is the number of digits to\n --              be printed after the decimal point (by default, this is 6).\n --              For g and G specifiers: This is the maximum number of\n --              significant digits to be printed.\n+\n --              For s: this is the maximum number of characters to be printed.\n --              By default all characters are printed until the ending null\n --              character is encountered.\n+\n --              If the period is specified without an explicit value for\n --              precision, 0 is assumed.\n+\n --    .*        The precision is not specified in the format string, but as an\n --              additional integer value argument preceding the argument that\n --              has to be formatted.\n@@ -119,7 +129,6 @@ private with Ada.Finalization;\n private with Ada.Strings.Unbounded;\n \n package GNAT.Formatted_String is\n-\n    use Ada;\n \n    type Formatted_String (<>) is private;\n@@ -249,11 +258,11 @@ package GNAT.Formatted_String is\n    generic\n       type Enum is (<>);\n    function Enum_Format\n-     (Format : Formatted_String; Var : Enum) return Formatted_String;\n+     (Format : Formatted_String;\n+      Var    : Enum) return Formatted_String;\n    --  As for String above, output the string representation of the enumeration\n \n private\n-\n    use Ada.Strings.Unbounded;\n \n    type I_Vars is array (Positive range 1 .. 2) of Integer;"}, {"sha": "4d93d0c2bb761ca5038a14640ae6606d4aa19563", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -19868,7 +19868,7 @@ in this package can be used to reestablish the required mode.\n @cindex Formatted String\n \n @noindent\n-Provides support for C/C++ printf() formatted string. The format is\n+Provides support for C/C++ printf() formatted strings. The format is\n copied from the printf() routine and should therefore gives identical\n output. Some generic routines are provided to be able to use types\n derived from Integer, Float or enumerations as values for the"}, {"sha": "cb3b105831bd79abc010ab25c788cf2e4e5550d6", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -2909,10 +2909,10 @@ package body Sem_Ch13 is\n                   --  their pragmas must contain two arguments, the second\n                   --  being the optional Boolean expression.\n \n-                  if A_Id = Aspect_Async_Readers\n-                    or else A_Id = Aspect_Async_Writers\n-                    or else A_Id = Aspect_Effective_Reads\n-                    or else A_Id = Aspect_Effective_Writes\n+                  if A_Id = Aspect_Async_Readers   or else\n+                     A_Id = Aspect_Async_Writers   or else\n+                     A_Id = Aspect_Effective_Reads or else\n+                     A_Id = Aspect_Effective_Writes\n                   then\n                      declare\n                         Args : List_Id;\n@@ -2921,9 +2921,10 @@ package body Sem_Ch13 is\n                         --  The first argument of the external property pragma\n                         --  is the related object.\n \n-                        Args := New_List (\n-                          Make_Pragma_Argument_Association (Sloc (Ent),\n-                            Expression => Ent));\n+                        Args :=\n+                          New_List (\n+                            Make_Pragma_Argument_Association (Sloc (Ent),\n+                              Expression => Ent));\n \n                         --  The second argument is the optional Boolean\n                         --  expression which must be propagated even if it"}, {"sha": "f18205185a42f5089bc9be73a0e9cfcf4512be6a", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -2952,6 +2952,42 @@ package body Sem_Ch6 is\n                Spec_Id := Disambiguate_Spec;\n             else\n                Spec_Id := Find_Corresponding_Spec (N);\n+\n+               --  In GNATprove mode, if the body has no previous spec, create\n+               --  one so that the inlining machinery can operate properly.\n+               --  Transfer aspects, if any, to the new spec, so that they\n+               --  are legal and can be processed ahead of the body.\n+               --  We make two copies of the given spec, one for the new\n+               --  declaration, and one for the body.\n+\n+               --  This cannot be done for a compilation unit, which is not\n+               --  in a context where we can insert a new spec.\n+\n+               if No (Spec_Id)\n+                 and then GNATprove_Mode\n+                 and then Debug_Flag_QQ\n+                 and then Full_Analysis\n+                 and then Comes_From_Source (Body_Id)\n+                 and then Is_List_Member (N)\n+               then\n+                  declare\n+                     Body_Spec : constant Node_Id :=\n+                       Copy_Separate_Tree (Specification (N));\n+                     New_Decl : constant Node_Id :=\n+                       Make_Subprogram_Declaration\n+                        (Loc, Copy_Separate_Tree (Specification (N)));\n+\n+                  begin\n+                     Insert_Before (N, New_Decl);\n+                     Move_Aspects (From => N, To => New_Decl);\n+                     Analyze (New_Decl);\n+                     Spec_Id := Defining_Entity (New_Decl);\n+\n+                     Set_Specification (N, Body_Spec);\n+                     Body_Id := Analyze_Subprogram_Specification (Body_Spec);\n+                     Set_Corresponding_Spec (N, Spec_Id);\n+                  end;\n+               end if;\n             end if;\n \n             --  If this is a duplicate body, no point in analyzing it"}, {"sha": "714512e4e958eba80e5b6a583319f5100dba014e", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -1845,7 +1845,7 @@ package body Sem_Prag is\n       --  than a formal subprogram parameter (SPARK RM 7.1.3(2)). The check\n       --  is performed at the end of the declarative region due to a possible\n       --  out-of-order arrangement of pragmas:\n-      --\n+\n       --    Obj : ...;\n       --    pragma Async_Readers (Obj);\n       --    pragma Volatile (Obj);"}, {"sha": "7043b79bd6c158d3bdbbe19444827d36dd7cc1cd", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -7698,8 +7698,7 @@ package body Sem_Util is\n             or else (Present (Full_View (Etype (Typ)))\n                       and then Full_View (Etype (Typ)) = Typ)\n \n-            --  Protect the frontend against wrong source with cyclic\n-            --  derivations\n+            --  Protect frontend against wrong sources with cyclic derivations\n \n             or else Etype (Typ) = T;\n "}, {"sha": "640e277eb66199c4c95e7571c1cff179620effac", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -302,6 +302,17 @@ package body Sinput is\n       end case;\n    end Check_For_BOM;\n \n+   -----------------------------\n+   -- Comes_From_Inlined_Body --\n+   -----------------------------\n+\n+   function Comes_From_Inlined_Body (S : Source_Ptr) return Boolean is\n+      SIE : Source_File_Record renames\n+        Source_File.Table (Get_Source_File_Index (S));\n+   begin\n+      return SIE.Inlined_Body;\n+   end Comes_From_Inlined_Body;\n+\n    -----------------------\n    -- Get_Column_Number --\n    -----------------------"}, {"sha": "3d36903bb05c6eb8f7d2ee26d5927fcea4669851", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -638,6 +638,13 @@ package Sinput is\n    --  value of the instantiation if this location is within an instance.\n    --  If S is not within an instance, then this returns No_Location.\n \n+   function Comes_From_Inlined_Body (S : Source_Ptr) return Boolean;\n+   pragma Inline (Comes_From_Inlined_Body);\n+   --  Given a source pointer S, returns whether it comes from an inlined body.\n+   --  This allows distinguishing these source pointers from those that come\n+   --  from instantiation of generics, since Instantiation_Location returns a\n+   --  valid location in both cases.\n+\n    function Top_Level_Location (S : Source_Ptr) return Source_Ptr;\n    --  Given a source pointer S, returns the argument unchanged if it is\n    --  not in an instantiation. If S is in an instantiation, then it returns"}, {"sha": "98a923afdd99d8737e60e52fd239290898be5a45", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c8e5bee712ecde910e0495e46f5216a7c9a60a/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "patch": "@@ -513,6 +513,14 @@ package body Sprint is\n    begin\n       if Debug_Generated_Code and then Present (Dump_Node) then\n          Set_Sloc (Dump_Node, Debug_Sloc + Source_Ptr (Column - 1));\n+\n+         --  We do not know the actual end location in the generated code and\n+         --  it could be much closer than in the source code, so play safe.\n+\n+         if Nkind_In (Dump_Node, N_Case_Statement, N_If_Statement) then\n+            Set_End_Location (Dump_Node, Debug_Sloc + Source_Ptr (Column - 1));\n+         end if;\n+\n          Dump_Node := Empty;\n       end if;\n    end Set_Debug_Sloc;"}]}