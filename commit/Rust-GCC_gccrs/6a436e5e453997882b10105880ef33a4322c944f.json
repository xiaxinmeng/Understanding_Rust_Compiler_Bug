{"sha": "6a436e5e453997882b10105880ef33a4322c944f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE0MzZlNWU0NTM5OTc4ODJiMTAxMDU4ODBlZjMzYTQzMjJjOTQ0Zg==", "commit": {"author": {"name": "Nicolas Pitre", "email": "nico@cam.org", "date": "2003-09-30T10:30:32Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-09-30T10:30:32Z"}, "message": "Nicolas Pitre <nico@cam.org>\n\nNicolas Pitre <nico@cam.org>\n* arm/lib1funcs.asm (ARM_DIV_MOD_BODY) split into ARM_DIV_BODY\nand ARM_MOD_BODY.\n(ARM_MOD_BODY): rewritten. added clz insns for __ARM_ARCH__ >= 5.\n(ARM_DIV_BODY): added clz insns for __ARM_ARCH__ >= 5,\nadded better divisor alignment in the other case.\n(ARM_DIV2_ORDER): added, finds the order of a single bit divisor.\n(__divsi3, __udivsi3, __modsi3, __umodsi3): rewritten using the\nmacros above, add fast exits for divisor >= dividend, etc.\n\nFrom-SVN: r71940", "tree": {"sha": "93abdfe4366b19848ed2a38e00fe26f6f53933f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93abdfe4366b19848ed2a38e00fe26f6f53933f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a436e5e453997882b10105880ef33a4322c944f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a436e5e453997882b10105880ef33a4322c944f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a436e5e453997882b10105880ef33a4322c944f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a436e5e453997882b10105880ef33a4322c944f/comments", "author": null, "committer": null, "parents": [{"sha": "47edf59e900f8d4efeac373f8b6b18f306ecf375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47edf59e900f8d4efeac373f8b6b18f306ecf375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47edf59e900f8d4efeac373f8b6b18f306ecf375"}], "stats": {"total": 356, "additions": 236, "deletions": 120}, "files": [{"sha": "1a505c1652c9e55d57358ed5994f3c838d14a985", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a436e5e453997882b10105880ef33a4322c944f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a436e5e453997882b10105880ef33a4322c944f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a436e5e453997882b10105880ef33a4322c944f", "patch": "@@ -1,3 +1,14 @@\n+2003-09-30  Nicolas Pitre <nico@cam.org>\n+\n+\t* arm/lib1funcs.asm (ARM_DIV_MOD_BODY) split into ARM_DIV_BODY\n+\tand ARM_MOD_BODY.\n+\t(ARM_MOD_BODY): rewritten. added clz insns for __ARM_ARCH__ >= 5.\n+\t(ARM_DIV_BODY): added clz insns for __ARM_ARCH__ >= 5,\n+\tadded better divisor alignment in the other case.\n+\t(ARM_DIV2_ORDER): added, finds the order of a single bit divisor.\n+\t(__divsi3, __udivsi3, __modsi3, __umodsi3): rewritten using the\n+\tmacros above, add fast exits for divisor >= dividend, etc.\n+\n 2003-09-30  Nicolas Pitre <nico@cam.org>\n \n \t* arm/ieee754-df.S: split compilation of fixunsdfsi from"}, {"sha": "fe14070e8121fb59caba8bb7496707757c04533b", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 225, "deletions": 120, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a436e5e453997882b10105880ef33a4322c944f/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a436e5e453997882b10105880ef33a4322c944f/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=6a436e5e453997882b10105880ef33a4322c944f", "patch": "@@ -208,6 +208,7 @@ _L__\\name:\t\t/* A hook to tell gdb that we've switched to ARM */\n .endm\n #endif\n \n+#ifdef __thumb__\n /* Register aliases.  */\n \n work\t\t.req\tr4\t@ XXXX is this safe ?\n@@ -216,102 +217,180 @@ divisor\t\t.req\tr1\n overdone\t.req\tr2\n result\t\t.req\tr2\n curbit\t\t.req\tr3\n+#endif\n #if 0\n ip\t\t.req\tr12\n sp\t\t.req\tr13\n lr\t\t.req\tr14\n pc\t\t.req\tr15\n #endif\n+\n /* ------------------------------------------------------------------------ */\n /*\t\tBodies of the division and modulo routines.\t\t    */\n /* ------------------------------------------------------------------------ */\t\n-.macro ARM_DIV_MOD_BODY modulo\n-LSYM(Loop1):\n+.macro ARM_DIV_BODY dividend, divisor, result, curbit\n+\n+#if __ARM_ARCH__ >= 5\n+\n+\tclz\t\\curbit, \\divisor\n+\tclz\t\\result, \\dividend\n+\tsub\t\\result, \\curbit, \\result\n+\tmov\t\\curbit, #1\n+\tmov\t\\divisor, \\divisor, lsl \\result\n+\tmov\t\\curbit, \\curbit, lsl \\result\n+\tmov\t\\result, #0\n+\t\n+#else\n+\n+\t@ Initially shift the divisor left 3 bits if possible,\n+\t@ set curbit accordingly.  This allows for curbit to be located\n+\t@ at the left end of each 4 bit nibbles in the division loop\n+\t@ to save one loop in most cases.\n+\ttst\t\\divisor, #0xe0000000\n+\tmoveq\t\\divisor, \\divisor, lsl #3\n+\tmoveq\t\\curbit, #8\n+\tmovne\t\\curbit, #1\n+\n \t@ Unless the divisor is very big, shift it up in multiples of\n \t@ four bits, since this is the amount of unwinding in the main\n \t@ division loop.  Continue shifting until the divisor is \n \t@ larger than the dividend.\n-\tcmp\tdivisor, #0x10000000\n-\tcmplo\tdivisor, dividend\n-\tmovlo\tdivisor, divisor, lsl #4\n-\tmovlo\tcurbit,  curbit,  lsl #4\n-\tblo\tLSYM(Loop1)\n+1:\tcmp\t\\divisor, #0x10000000\n+\tcmplo\t\\divisor, \\dividend\n+\tmovlo\t\\divisor, \\divisor, lsl #4\n+\tmovlo\t\\curbit, \\curbit, lsl #4\n+\tblo\t1b\n \n-LSYM(Lbignum):\n \t@ For very big divisors, we must shift it a bit at a time, or\n \t@ we will be in danger of overflowing.\n-\tcmp\tdivisor, #0x80000000\n-\tcmplo\tdivisor, dividend\n-\tmovlo\tdivisor, divisor, lsl #1\n-\tmovlo\tcurbit,  curbit,  lsl #1\n-\tblo\tLSYM(Lbignum)\n+1:\tcmp\t\\divisor, #0x80000000\n+\tcmplo\t\\divisor, \\dividend\n+\tmovlo\t\\divisor, \\divisor, lsl #1\n+\tmovlo\t\\curbit, \\curbit, lsl #1\n+\tblo\t1b\n \n-LSYM(Loop3):\n-\t@ Test for possible subtractions.  On the final pass, this may \n-\t@ subtract too much from the dividend ...\n+\tmov\t\\result, #0\n+\n+#endif\n+\n+\t@ Division loop\n+1:\tcmp\t\\dividend, \\divisor\n+\tsubhs\t\\dividend, \\dividend, \\divisor\n+\torrhs\t\\result,   \\result,   \\curbit\n+\tcmp\t\\dividend, \\divisor,  lsr #1\n+\tsubhs\t\\dividend, \\dividend, \\divisor, lsr #1\n+\torrhs\t\\result,   \\result,   \\curbit,  lsr #1\n+\tcmp\t\\dividend, \\divisor,  lsr #2\n+\tsubhs\t\\dividend, \\dividend, \\divisor, lsr #2\n+\torrhs\t\\result,   \\result,   \\curbit,  lsr #2\n+\tcmp\t\\dividend, \\divisor,  lsr #3\n+\tsubhs\t\\dividend, \\dividend, \\divisor, lsr #3\n+\torrhs\t\\result,   \\result,   \\curbit,  lsr #3\n+\tcmp\t\\dividend, #0\t\t\t@ Early termination?\n+\tmovnes\t\\curbit,   \\curbit,  lsr #4\t@ No, any more bits to do?\n+\tmovne\t\\divisor,  \\divisor, lsr #4\n+\tbne\t1b\n+\n+.endm\n+/* ------------------------------------------------------------------------ */\t\n+.macro ARM_DIV2_ORDER divisor, order\n+\n+#if __ARM_ARCH__ >= 5\n+\n+\tclz\t\\order, \\divisor\n+\trsb\t\\order, \\order, #31\n+\n+#else\n+\n+\tcmp\t\\divisor, #(1 << 16)\n+\tmovhs\t\\divisor, \\divisor, lsr #16\n+\tmovhs\t\\order, #16\n+\tmovlo\t\\order, #0\n+\n+\tcmp\t\\divisor, #(1 << 8)\n+\tmovhs\t\\divisor, \\divisor, lsr #8\n+\taddhs\t\\order, \\order, #8\n+\n+\tcmp\t\\divisor, #(1 << 4)\n+\tmovhs\t\\divisor, \\divisor, lsr #4\n+\taddhs\t\\order, \\order, #4\n+\n+\tcmp\t\\divisor, #(1 << 2)\n+\taddhi\t\\order, \\order, #3\n+\taddls\t\\order, \\order, \\divisor, lsr #1\n+\n+#endif\n+\n+.endm\n+/* ------------------------------------------------------------------------ */\n+.macro ARM_MOD_BODY dividend, divisor, order, spare\n+\n+#if __ARM_ARCH__ >= 5\n+\n+\tclz\t\\order, \\divisor\n+\tclz\t\\spare, \\dividend\n+\tsub\t\\order, \\order, \\spare\n+\tmov\t\\divisor, \\divisor, lsl \\order\n \t\n-  .if \\modulo\n-\t@ ... so keep track of which subtractions are done in OVERDONE.\n-\t@ We can fix them up afterwards.\n-\tmov\toverdone, #0\n-\tcmp\tdividend, divisor\n-\tsubhs\tdividend, dividend, divisor\n-\tcmp\tdividend, divisor,  lsr #1\n-\tsubhs\tdividend, dividend, divisor, lsr #1\n-\torrhs\toverdone, overdone, curbit,  ror #1\n-\tcmp\tdividend, divisor,  lsr #2\n-\tsubhs\tdividend, dividend, divisor, lsr #2\n-\torrhs\toverdone, overdone, curbit,  ror #2\n-\tcmp\tdividend, divisor,  lsr #3\n-\tsubhs\tdividend, dividend, divisor, lsr #3\n-\torrhs\toverdone, overdone, curbit,  ror #3\n-\tmov\tip,       curbit\n-  .else\n-\t@ ... so keep track of which subtractions are done in RESULT.\n-\t@ The result will be ok, since the \"bit\" will have been \n-\t@ shifted out at the bottom.\n-\tcmp\tdividend, divisor\n-\tsubhs\tdividend, dividend, divisor\n-\torrhs\tresult,   result,   curbit\n-\tcmp\tdividend, divisor,  lsr #1\n-\tsubhs\tdividend, dividend, divisor, lsr #1\n-\torrhs\tresult,   result,   curbit,  lsr #1\n-\tcmp\tdividend, divisor,  lsr #2\n-\tsubhs\tdividend, dividend, divisor, lsr #2\n-\torrhs\tresult,   result,   curbit,  lsr #2\n-\tcmp\tdividend, divisor,  lsr #3\n-\tsubhs\tdividend, dividend, divisor, lsr #3\n-\torrhs\tresult,   result,   curbit,  lsr #3\n-  .endif\n+#else\n \n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tmovnes\tcurbit,   curbit,  lsr #4\t@ No, any more bits to do?\n-\tmovne\tdivisor,  divisor, lsr #4\n-\tbne\tLSYM(Loop3)\n+\tmov\t\\order, #0\n \n-  .if \\modulo\n-LSYM(Lfixup_dividend):\t\n-\t@ Any subtractions that we should not have done will be recorded in\n-\t@ the top three bits of OVERDONE.  Exactly which were not needed\n-\t@ are governed by the position of the bit, stored in IP.\n-\tands\toverdone, overdone, #0xe0000000\n-\t@ If we terminated early, because dividend became zero, then the \n-\t@ bit in ip will not be in the bottom nibble, and we should not\n-\t@ perform the additions below.  We must test for this though\n-\t@ (rather relying upon the TSTs to prevent the additions) since\n-\t@ the bit in ip could be in the top two bits which might then match\n-\t@ with one of the smaller RORs.\n-\ttstne\tip, #0x7\n-\tbeq\tLSYM(Lgot_result)\n-\ttst\toverdone, ip, ror #3\n-\taddne\tdividend, dividend, divisor, lsr #3\n-\ttst\toverdone, ip, ror #2\n-\taddne\tdividend, dividend, divisor, lsr #2\n-\ttst\toverdone, ip, ror #1\n-\taddne\tdividend, dividend, divisor, lsr #1\n-  .endif\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+1:\tcmp\t\\divisor, #0x10000000\n+\tcmplo\t\\divisor, \\dividend\n+\tmovlo\t\\divisor, \\divisor, lsl #4\n+\taddlo\t\\order, \\order, #4\n+\tblo\t1b\n \n-LSYM(Lgot_result):\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+1:\tcmp\t\\divisor, #0x80000000\n+\tcmplo\t\\divisor, \\dividend\n+\tmovlo\t\\divisor, \\divisor, lsl #1\n+\taddlo\t\\order, \\order, #1\n+\tblo\t1b\n+\n+#endif\n+\n+\t@ Perform all needed substractions to keep only the reminder.\n+\t@ Do comparisons in batch of 4 first.\n+\tsubs\t\\order, \\order, #3\t\t@ yes, 3 is intended here\n+\tblt\t2f\n+\n+1:\tcmp\t\\dividend, \\divisor\n+\tsubhs\t\\dividend, \\dividend, \\divisor\n+\tcmp\t\\dividend, \\divisor,  lsr #1\n+\tsubhs\t\\dividend, \\dividend, \\divisor, lsr #1\n+\tcmp\t\\dividend, \\divisor,  lsr #2\n+\tsubhs\t\\dividend, \\dividend, \\divisor, lsr #2\n+\tcmp\t\\dividend, \\divisor,  lsr #3\n+\tsubhs\t\\dividend, \\dividend, \\divisor, lsr #3\n+\tcmp\t\\dividend, #1\n+\tmov\t\\divisor, \\divisor, lsr #4\n+\tsubges\t\\order, \\order, #4\n+\tbge\t1b\n+\n+\ttst\t\\order, #3\n+\tteqne\t\\dividend, #0\n+\tbeq\t5f\n+\n+\t@ Either 1, 2 or 3 comparison/substractions are left.\n+2:\tcmn\t\\order, #2\n+\tblt\t4f\n+\tbeq\t3f\n+\tcmp\t\\dividend, \\divisor\n+\tsubhs\t\\dividend, \\dividend, \\divisor\n+\tmov\t\\divisor,  \\divisor,  lsr #1\n+3:\tcmp\t\\dividend, \\divisor\n+\tsubhs\t\\dividend, \\dividend, \\divisor\n+\tmov\t\\divisor,  \\divisor,  lsr #1\n+4:\tcmp\t\\dividend, \\divisor\n+\tsubhs\t\\dividend, \\dividend, \\divisor\n+5:\n .endm\n /* ------------------------------------------------------------------------ */\n .macro THUMB_DIV_MOD_BODY modulo\n@@ -495,19 +574,29 @@ LSYM(Lgot_result):\n \tRET\n \n #else /* ARM version.  */\n+\n+\tsubs\tr2, r1, #1\n+\tRETc(eq)\n+\tbcc\tLSYM(Ldiv0)\n+\tcmp\tr0, r1\n+\tbls\t11f\n+\ttst\tr1, r2\n+\tbeq\t12f\n \t\n-\tcmp\tdivisor, #0\n-\tbeq\tLSYM(Ldiv0)\n-\tmov\tcurbit, #1\n-\tmov\tresult, #0\n-\tcmp\tdividend, divisor\n-\tblo\tLSYM(Lgot_result)\n-\t\n-\tARM_DIV_MOD_BODY 0\n+\tARM_DIV_BODY r0, r1, r2, r3\n \t\n-\tmov\tr0, result\n+\tmov\tr0, r2\n \tRET\t\n \n+11:\tmoveq\tr0, #1\n+\tmovne\tr0, #0\n+\tRET\n+\n+12:\tARM_DIV2_ORDER r1, r2\n+\n+\tmov\tr0, r0, lsr r2\n+\tRET\n+\n #endif /* ARM version */\n \n \tDIV_FUNC_END udivsi3\n@@ -537,15 +626,15 @@ LSYM(Lover10):\n \t\n #else  /* ARM version.  */\n \t\n-\tcmp\tdivisor, #0\n-\tbeq\tLSYM(Ldiv0)\n-\tcmp     divisor, #1\n-\tcmpne\tdividend, divisor\n-\tmoveq   dividend, #0\n-\tRETc(lo)\n-\tmov\tcurbit, #1\n+\tsubs\tr2, r1, #1\t\t\t@ compare divisor with 1\n+\tbcc\tLSYM(Ldiv0)\n+\tcmpne\tr0, r1\t\t\t\t@ compare dividend with divisor\n+\tmoveq   r0, #0\n+\ttsthi\tr1, r2\t\t\t\t@ see if divisor is power of 2\n+\tandeq\tr0, r0, r2\n+\tRETc(ls)\n \n-\tARM_DIV_MOD_BODY 1\n+\tARM_MOD_BODY r0, r1, r2, r3\n \t\n \tRET\t\n \n@@ -593,24 +682,41 @@ LSYM(Lover12):\n \n #else /* ARM version.  */\n \t\n-\teor\tip, dividend, divisor\t\t@ Save the sign of the result.\n-\tmov\tcurbit, #1\n-\tmov\tresult, #0\n-\tcmp\tdivisor, #0\n-\trsbmi\tdivisor, divisor, #0\t\t@ Loops below use unsigned.\n+\tcmp\tr1, #0\n+\teor\tip, r0, r1\t\t\t@ save the sign of the result.\n \tbeq\tLSYM(Ldiv0)\n-\tcmp\tdividend, #0\n-\trsbmi\tdividend, dividend, #0\n-\tcmp\tdividend, divisor\n-\tblo\tLSYM(Lgot_result)\n-\n-\tARM_DIV_MOD_BODY 0\n+\trsbmi\tr1, r1, #0\t\t\t@ loops below use unsigned.\n+\tsubs\tr2, r1, #1\t\t\t@ division by 1 or -1 ?\n+\tbeq\t10f\n+\tmovs\tr3, r0\n+\trsbmi\tr3, r0, #0\t\t\t@ positive dividend value\n+\tcmp\tr3, r1\n+\tbls\t11f\n+\ttst\tr1, r2\t\t\t\t@ divisor is power of 2 ?\n+\tbeq\t12f\n+\n+\tARM_DIV_BODY r3, r1, r0, r2\n \t\n-\tmov\tr0, result\n \tcmp\tip, #0\n \trsbmi\tr0, r0, #0\n \tRET\t\n \n+10:\tteq\tip, r0\t\t\t\t@ same sign ?\n+\trsbmi\tr0, r0, #0\n+\tRET\t\n+\n+11:\tmovlo\tr0, #0\n+\tmoveq\tr0, ip, asr #31\n+\torreq\tr0, r0, #1\n+\tRET\n+\n+12:\tARM_DIV2_ORDER r1, r2\n+\n+\tcmp\tip, #0\n+\tmov\tr0, r3, lsr r2\n+\trsbmi\tr0, r0, #0\n+\tRET\n+\n #endif /* ARM version */\n \t\n \tDIV_FUNC_END divsi3\n@@ -653,23 +759,22 @@ LSYM(Lover12):\n \n #else /* ARM version.  */\n \t\n-\tcmp\tdivisor, #0\n-\trsbmi\tdivisor, divisor, #0\t\t@ Loops below use unsigned.\n+\tcmp\tr1, #0\n \tbeq\tLSYM(Ldiv0)\n-\t@ Need to save the sign of the dividend, unfortunately, we need\n-\t@ ip later on; this is faster than pushing lr and using that.\n-\tstr\tdividend, [sp, #-4]!\n-\tcmp\tdividend, #0\t\t\t@ Test dividend against zero\n-\trsbmi\tdividend, dividend, #0\t\t@ If negative make positive\n-\tcmp\tdividend, divisor\t\t@ else if zero return zero\n-\tblo\tLSYM(Lgot_result)\t\t@ if smaller return dividend\n-\tmov\tcurbit, #1\n-\n-\tARM_DIV_MOD_BODY 1\n-\n-\tldr\tip, [sp], #4\n-\tcmp\tip, #0\n-\trsbmi\tdividend, dividend, #0\n+\trsbmi\tr1, r1, #0\t\t\t@ loops below use unsigned.\n+\tmovs\tip, r0\t\t\t\t@ preserve sign of dividend\n+\trsbmi\tr0, r0, #0\t\t\t@ if negative make positive\n+\tsubs\tr2, r1, #1\t\t\t@ compare divisor with 1\n+\tcmpne\tr0, r1\t\t\t\t@ compare dividend with divisor\n+\tmoveq\tr0, #0\n+\ttsthi\tr1, r2\t\t\t\t@ see if divisor is power of 2\n+\tandeq\tr0, r0, r2\n+\tbls\t10f\n+\n+\tARM_MOD_BODY r0, r1, r2, r3\n+\n+10:\tcmp\tip, #0\n+\trsbmi\tr0, r0, #0\n \tRET\t\n \n #endif /* ARM version */"}]}