{"sha": "6775f1f3a749256c99544d13f7ea581edba6a585", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc3NWYxZjNhNzQ5MjU2Yzk5NTQ0ZDEzZjdlYTU4MWVkYmE2YTU4NQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2004-09-19T18:01:51Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-09-19T18:01:51Z"}, "message": "tree-vectorizer.h (stmt_vec_info): Add vect_dr_base field.\n\n2004-09-19  Ira Rosen  <irar@il.ibm.com>\n\n        * tree-vectorizer.h (stmt_vec_info): Add vect_dr_base field.\n        (STMT_VINFO_VECT_DR_BASE): Declare.\n        (VECT_SMODULO): Declare.\n        * tree-vectorizer.c (vect_compute_array_ref_alignment): New function.\n        (vect_compute_array_base_alignment): New function.\n        (vect_analyze_data_ref_access): Check array indices. Remove one\n        dimensional arrays restriction.\n        (vect_get_ptr_offset): New function.\n        (vect_get_symbl_and_dr): New function.\n        (vect_get_base_and_bit_offset): Support additional data refs. Renamed\n        (former name vect_get_base_decl_and_bit_offset).\n        (vect_create_index_for_array_ref): Removed.\n        (vect_create_index_for_vector_ref): New function.\n        (vect_create_addr_base_for_vector_ref): New function.\n        (vect_create_data_ref): Handle additional data refs. Call\n        vect_create_index_for_vector_ref and vect_create_addr_base_for_vector_ref.\n        (vect_compute_data_ref_alignment): Support the changes. Call\n        vect_get_base_and_bit_offset.\n        (vect_analyze_data_refs): Call vect_get_symbl_and_dr. Support additional\n        data refs. Store vect_dr_base.\n        (vect_analyze_data_ref_accesses): Support nonconstant init.\n        (new_stmt_vec_info): Initialize vect_dr_base field.\n        (vect_is_simple_iv_evolution): Call initial_condition_in_loop_num.\n        (get_vectype_for_scalar_type): Check for BLKmode.\n        * tree-chrec.h (initial_condition_in_loop_num): Declare.\n        * tree-chrec.c (initial_condition_in_loop_num): New function.\n        (chrec_component_in_loop_num): New function.\n        (evolution_part_in_loop_num): Call chrec_component_in_loop_num.\n        * tree-data-ref.c (analyze_array_indexes): Change parameter (access_fns)\n        to be pointer to varray_type.\n\nFrom-SVN: r87731", "tree": {"sha": "f964f19e04649f4ccaa0fd898211cec33894eb32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f964f19e04649f4ccaa0fd898211cec33894eb32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6775f1f3a749256c99544d13f7ea581edba6a585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6775f1f3a749256c99544d13f7ea581edba6a585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6775f1f3a749256c99544d13f7ea581edba6a585", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6775f1f3a749256c99544d13f7ea581edba6a585/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "15db5571d1567a4d05812f85853b9b95766b8f2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15db5571d1567a4d05812f85853b9b95766b8f2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15db5571d1567a4d05812f85853b9b95766b8f2e"}], "stats": {"total": 1746, "additions": 1362, "deletions": 384}, "files": [{"sha": "dc54f66bcafa83f61ee312344ce198999cb88b7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -1,3 +1,36 @@\n+2004-09-19  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.h (stmt_vec_info): Add vect_dr_base field.\n+\t(STMT_VINFO_VECT_DR_BASE): Declare.\n+\t(VECT_SMODULO): Declare.\n+\t* tree-vectorizer.c (vect_compute_array_ref_alignment): New function.\n+\t(vect_compute_array_base_alignment): New function.\n+\t(vect_analyze_data_ref_access): Check array indices. Remove one\n+\tdimensional arrays restriction.\n+\t(vect_get_ptr_offset): New function.\n+\t(vect_get_symbl_and_dr): New function.\n+\t(vect_get_base_and_bit_offset): Support additional data refs. Renamed\n+\t(former name vect_get_base_decl_and_bit_offset).\n+\t(vect_create_index_for_array_ref): Removed.\n+\t(vect_create_index_for_vector_ref): New function.\n+\t(vect_create_addr_base_for_vector_ref): New function.\n+\t(vect_create_data_ref): Handle additional data refs. Call\n+\tvect_create_index_for_vector_ref and vect_create_addr_base_for_vector_ref.\n+\t(vect_compute_data_ref_alignment): Support the changes. Call\n+\tvect_get_base_and_bit_offset.\n+\t(vect_analyze_data_refs): Call vect_get_symbl_and_dr. Support additional\n+\tdata refs. Store vect_dr_base.\n+\t(vect_analyze_data_ref_accesses): Support nonconstant init.\n+\t(new_stmt_vec_info): Initialize vect_dr_base field.\n+\t(vect_is_simple_iv_evolution): Call initial_condition_in_loop_num.\n+\t(get_vectype_for_scalar_type): Check for BLKmode.\n+\t* tree-chrec.h (initial_condition_in_loop_num): Declare.\n+\t* tree-chrec.c (initial_condition_in_loop_num): New function.\n+\t(chrec_component_in_loop_num): New function.\n+\t(evolution_part_in_loop_num): Call chrec_component_in_loop_num.\n+\t* tree-data-ref.c (analyze_array_indexes): Change parameter (access_fns)\n+\tto be pointer to varray_type.\n+\n 2004-09-19  Jan Hubicka  <jh@suse.cz>\n \n \t* basic-block.h (update_bb_profile_after_threading): Declare."}, {"sha": "199ae8e18e79eaa9f5bacf18950c5c65121dae12", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -1,3 +1,13 @@\n+2004-09-19  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-13.c: Now vectorized on ppc*.\n+\t* gcc.dg/vect/vect-73.c: New testcase.\n+\t* gcc.dg/vect/vect-74.c: New testcase.\n+\t* gcc.dg/vect/vect-75.c: New testcase.\n+\t* gcc.dg/vect/vect-76.c: New testcase.\n+\t* gcc.dg/vect/vect-77.c: New testcase.\n+\t* gcc.dg/vect/vect-78.c: New testcase\n+\n 2004-09-18  Paul Brook  <paul@codesourcery.com>\n \n \t* g++.old-deja/g++.pt/static11.C: XFAIL on arm*-*-eabi."}, {"sha": "dddfb372ee6e8b0b386125242f58271bf48ffaec", "filename": "gcc/testsuite/gcc.dg/vect/vect-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-13.c?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -22,4 +22,4 @@ int main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "4df315d1f0d599b9cd34ab98ed9b7448c7d9c11b", "filename": "gcc/testsuite/gcc.dg/vect/vect-73.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-73.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-73.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-73.c?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+int ic[N*2];\n+\n+#define ia (ic+N)\n+\n+int main1 ()\n+{\n+  int i, j;\n+  int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+       ia[i] = ib[i];\n+    }\n+\n+  /* check results: */  \n+  for (i = 0; i < N; i++)\n+    {\n+       if (ia[i] != ib[i])\n+         abort();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+\n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "8e6f46fed82656b40f9af75b8803d4e54b144522", "filename": "gcc/testsuite/gcc.dg/vect/vect-74.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-74.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-74.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-74.c?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+typedef float afloat __attribute__ ((__aligned__(16)));\n+\n+afloat a[N];\n+afloat b[N+4] = {0.2, 1.3, 2.3, 3.4, 4.5, 5.6, 7.8, 9.0, 10.11, 11.12, 12.13, 13.14, 14.15, 15.16, 16.17, 17.18, 18.19, 19.20}; \n+afloat c[N] = {0.2, 1.3, 2.3, 3.4, 4.5, 5.6, 7.8, 9.0, 10.11, 11.12, 12.13, 13.14, 14.15, 15.16};\n+\n+float fa[N];\n+float fb[N+4] = {0.2, 1.3, 2.3, 3.4, 4.5, 5.6, 7.8, 9.0, 10.11, 11.12, 12.13, 13.14, 14.15, 15.16, \n+16.17, 17.18, 18.19, 19.20}; \n+float fc[N] = {0.2, 1.3, 2.3, 3.4, 4.5, 5.6, 7.8, 9.0, 10.11, 11.12, 12.13, 13.14, 14.15, 15.16};\n+\n+int\n+main1 (afloat *__restrict__  pa, afloat * __restrict__ pb, afloat * __restrict__ pc)\n+{\n+  int i;\n+  afloat *q = pb + 4;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      pa[i] = q[i] * pc[i];\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (pa[i] != q[i] * pc[i])\n+\tabort();\n+    }\n+  \n+  return 0;\n+}\n+\n+/* Not vectorizable. Alias. */\n+int\n+main2 (afloat *pa, afloat *pb, afloat *pc)\n+{\n+  int i;\n+  afloat *q = pb + 4;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      pa[i] = q[i] * pc[i];\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (pa[i] != q[i] * pc[i])\n+\tabort();\n+    }\n+  \n+  return 0;\n+}\n+\n+/* Not vectorizable: not aligned pointers. */\n+int\n+main3 (float * __restrict__ pa, float * __restrict__ pb, float *__restrict__ pc)\n+{\n+  int i;\n+  afloat *q = pb + 4;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      pa[i] = q[i] * pc[i];\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (pa[i] != q[i] * pc[i])\n+\tabort();\n+    }\n+  \n+  return 0;\n+}\n+\n+\n+int main (void)\n+{ \n+  check_vect ();\n+\n+  main1 (a, b, c);\n+  main2 (a, b, c);\n+  main3 (fa, fb, fc);\n+\n+  return 0;\t\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\" } } */"}, {"sha": "5fcb3abad86b8473b0df0adcf4fbfe30316fcfa3", "filename": "gcc/testsuite/gcc.dg/vect/vect-75.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-75.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-75.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-75.c?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8\n+#define OFF 8\n+\n+typedef int aint __attribute__ ((__aligned__(16)));\n+\n+aint ib[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10, 14, 22, 26, 34};\n+\n+int main1 (aint *ib)\n+{\n+  int i;\n+  int ia[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = ib[i+OFF];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+     if (ia[i] != ib[i+OFF])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (ib);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+"}, {"sha": "11b87e325a823ff778324e16365735c9e77c7650", "filename": "gcc/testsuite/gcc.dg/vect/vect-76.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8\n+#define OFF 4\n+\n+typedef int aint __attribute__ ((__aligned__(16)));\n+\n+aint ib[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+int main1 (aint *pib)\n+{\n+  int i;\n+  int ia[N+OFF];\n+  int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+  for (i = OFF; i < N; i++)\n+    {\n+      ia[i] = pib[i - OFF];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = OFF; i < N; i++)\n+    {\n+     if (ia[i] != pib[i - OFF])\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = pib[i - OFF];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+     if (ia[i] != pib[i - OFF])\n+        abort ();\n+    }\n+\n+  for (i = OFF; i < N; i++)\n+    {\n+      ia[i] = ic[i - OFF];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = OFF; i < N; i++)\n+    {\n+     if (ia[i] != ic[i - OFF])\n+        abort ();  \n+    }\n+\n+  return 0;  \n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (&ib[OFF]);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n+"}, {"sha": "c5dacc5a8811da3fc7b6ae61b674702d9c7eeefb", "filename": "gcc/testsuite/gcc.dg/vect/vect-77.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8\n+#define OFF 8\n+\n+typedef int aint __attribute__ ((__aligned__(16)));\n+\n+aint ib[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10, 14, 22, 26, 34};\n+\n+int main1 (aint *ib, int off)\n+{\n+  int i;\n+  int ia[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = ib[i+off];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+     if (ia[i] != ib[i+off])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (ib, 8);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+"}, {"sha": "6a4eb8c4dc745c15995601c026510dbe0311ecfe", "filename": "gcc/testsuite/gcc.dg/vect/vect-78.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8\n+#define OFF 8\n+\n+typedef int aint __attribute__ ((__aligned__(16)));\n+\n+aint ib[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10, 14, 22, 26, 34};\n+int off = 8;\n+\n+int main1 (aint *ib)\n+{\n+  int i;\n+  int ia[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = ib[i+off];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+     if (ia[i] != ib[i+off])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (ib);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+"}, {"sha": "2d48093c0e29c79b8e44593e155212ac465d5496", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -583,14 +583,16 @@ hide_evolution_in_other_loops_than_loop (tree chrec,\n     }\n }\n \n-/* Returns the evolution part in LOOP_NUM.  Example: the call\n-   get_evolution_in_loop (1, {{0, +, 1}_1, +, 2}_1) returns \n-   {1, +, 2}_1  */\n+/* Returns the evolution part of CHREC in LOOP_NUM when RIGHT is\n+   true, otherwise returns the initial condition in LOOP_NUM.  */\n \n-tree \n-evolution_part_in_loop_num (tree chrec, \n-\t\t\t    unsigned loop_num)\n+static tree \n+chrec_component_in_loop_num (tree chrec, \n+\t\t\t     unsigned loop_num,\n+\t\t\t     bool right)\n {\n+  tree component;\n+\n   if (automatically_generated_chrec_p (chrec))\n     return chrec;\n   \n@@ -599,29 +601,63 @@ evolution_part_in_loop_num (tree chrec,\n     case POLYNOMIAL_CHREC:\n       if (CHREC_VARIABLE (chrec) == loop_num)\n \t{\n+\t  if (right)\n+\t    component = CHREC_RIGHT (chrec);\n+\t  else\n+\t    component = CHREC_LEFT (chrec);\n+\n \t  if (TREE_CODE (CHREC_LEFT (chrec)) != POLYNOMIAL_CHREC\n \t      || CHREC_VARIABLE (CHREC_LEFT (chrec)) != CHREC_VARIABLE (chrec))\n-\t    return CHREC_RIGHT (chrec);\n+\t    return component;\n \t  \n \t  else\n \t    return build_polynomial_chrec\n \t      (loop_num, \n-\t       evolution_part_in_loop_num (CHREC_LEFT (chrec), loop_num), \n-\t       CHREC_RIGHT (chrec));\n+\t       chrec_component_in_loop_num (CHREC_LEFT (chrec), \n+\t\t\t\t\t    loop_num, \n+\t\t\t\t\t    right), \n+\t       component);\n \t}\n       \n       else if (CHREC_VARIABLE (chrec) < loop_num)\n \t/* There is no evolution part in this loop.  */\n \treturn NULL_TREE;\n       \n       else\n-\treturn evolution_part_in_loop_num (CHREC_LEFT (chrec), loop_num);\n+\treturn chrec_component_in_loop_num (CHREC_LEFT (chrec), \n+\t\t\t\t\t    loop_num, \n+\t\t\t\t\t    right);\n       \n-    default:\n-      return NULL_TREE;\n+     default:\n+      if (right)\n+\treturn NULL_TREE;\n+      else\n+\treturn chrec;\n     }\n }\n \n+/* Returns the evolution part in LOOP_NUM.  Example: the call\n+   evolution_part_in_loop_num (1, {{0, +, 1}_1, +, 2}_1) returns \n+   {1, +, 2}_1  */\n+\n+tree \n+evolution_part_in_loop_num (tree chrec, \n+\t\t\t    unsigned loop_num)\n+{\n+  return chrec_component_in_loop_num (chrec, loop_num, true);\n+}\n+\n+/* Returns the initial condition in LOOP_NUM.  Example: the call\n+   initial_condition_in_loop_num ({{0, +, 1}_1, +, 2}_2, 1) returns \n+   {0, +, 1}_1  */\n+\n+tree \n+initial_condition_in_loop_num (tree chrec, \n+\t\t\t       unsigned loop_num)\n+{\n+  return chrec_component_in_loop_num (chrec, loop_num, false);\n+}\n+\n /* Set or reset the evolution of CHREC to NEW_EVOL in loop LOOP_NUM.\n    This function is essentially used for setting the evolution to\n    chrec_dont_know, for example after having determined that it is"}, {"sha": "ee31296c3deca402ba1eaf2687f8afae1abcc66c", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -76,6 +76,7 @@ extern tree chrec_apply (unsigned, tree, tree);\n extern tree chrec_replace_initial_condition (tree, tree);\n extern tree update_initial_condition_to_origin (tree);\n extern tree initial_condition (tree);\n+extern tree initial_condition_in_loop_num (tree, unsigned);\n extern tree evolution_part_in_loop_num (tree, unsigned);\n extern tree hide_evolution_in_other_loops_than_loop (tree, unsigned);\n extern tree reset_evolution_in_loop (unsigned, tree, tree);"}, {"sha": "8e062d074b40664fddd64ced0c560ba763774017", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -498,7 +498,7 @@ dump_data_dependence_direction (FILE *file,\n \n static tree\n analyze_array_indexes (struct loop *loop,\n-\t\t       varray_type access_fns, \n+\t\t       varray_type *access_fns, \n \t\t       tree ref)\n {\n   tree opnd0, opnd1;\n@@ -514,7 +514,7 @@ analyze_array_indexes (struct loop *loop,\n   access_fn = instantiate_parameters \n     (loop, analyze_scalar_evolution (loop, opnd1));\n   \n-  VARRAY_PUSH_TREE (access_fns, access_fn);\n+  VARRAY_PUSH_TREE (*access_fns, access_fn);\n   \n   /* Recursively record other array access functions.  */\n   if (TREE_CODE (opnd0) == ARRAY_REF)\n@@ -549,7 +549,7 @@ analyze_array (tree stmt, tree ref, bool is_read)\n   DR_REF (res) = ref;\n   VARRAY_TREE_INIT (DR_ACCESS_FNS (res), 3, \"access_fns\");\n   DR_BASE_NAME (res) = analyze_array_indexes \n-    (loop_containing_stmt (stmt), DR_ACCESS_FNS (res), ref);\n+    (loop_containing_stmt (stmt), &(DR_ACCESS_FNS (res)), ref);\n   DR_IS_READ (res) = is_read;\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "acabce436e7ebe11110fcd721acd36cd1b478ff0", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 890, "deletions": 360, "changes": 1250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -57,10 +57,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    data: scalars (which are represented by SSA_NAMES), and memory references\n    (\"data-refs\"). These two types of data require different handling both \n    during analysis and transformation. The types of data-refs that the \n-   vectorizer currently supports are ARRAY_REFS that are one dimensional \n-   arrays which base is an array DECL (not a pointer), and INDIRECT_REFS \n-   through pointers; both array and pointer accesses are required to have a \n-   simple (consecutive) access pattern.\n+   vectorizer currently supports are ARRAY_REFS which base is an array DECL \n+   (not a pointer), and INDIRECT_REFS through pointers; both array and pointer\n+   accesses are required to have a  simple (consecutive) access pattern.\n \n    Analysis phase:\n    ===============\n@@ -175,18 +174,28 @@ static bool vect_is_simple_iv_evolution (unsigned, tree, tree *, tree *, bool);\n static void vect_mark_relevant (varray_type, tree);\n static bool vect_stmt_relevant_p (tree, loop_vec_info);\n static tree vect_get_loop_niters (struct loop *, HOST_WIDE_INT *);\n-static void vect_compute_data_ref_alignment \n+static bool vect_compute_data_ref_alignment \n   (struct data_reference *, loop_vec_info);\n static bool vect_analyze_data_ref_access (struct data_reference *);\n static bool vect_get_first_index (tree, tree *);\n static bool vect_can_force_dr_alignment_p (tree, unsigned int);\n-static tree vect_get_base_decl_and_bit_offset (tree, tree *);\n static struct data_reference * vect_analyze_pointer_ref_access (tree, tree, bool);\n+static tree vect_get_base_and_bit_offset\n+  (struct data_reference *, tree, tree, loop_vec_info, tree *, bool*);\n+static struct data_reference * vect_analyze_pointer_ref_access\n+  (tree, tree, bool);\n+static tree vect_compute_array_base_alignment (tree, tree, tree *, tree *);\n+static tree vect_compute_array_ref_alignment\n+  (struct data_reference *, loop_vec_info, tree, tree *);\n+static tree vect_get_ptr_offset (tree, tree, tree *);\n+static tree vect_get_symbl_and_dr\n+  (tree, tree, bool, loop_vec_info, struct data_reference **);\n \n /* Utility functions for the code transformation.  */\n static tree vect_create_destination_var (tree, tree);\n static tree vect_create_data_ref (tree, block_stmt_iterator *);\n-static tree vect_create_index_for_array_ref (tree, block_stmt_iterator *);\n+static tree vect_create_index_for_vector_ref (struct loop *, block_stmt_iterator *);\n+static tree vect_create_addr_base_for_vector_ref (tree, tree *);\n static tree get_vectype_for_scalar_type (tree);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n static tree vect_get_vec_def_for_operand (tree, tree);\n@@ -221,6 +230,7 @@ new_stmt_vec_info (tree stmt, struct loop *loop)\n   STMT_VINFO_VEC_STMT (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;\n   STMT_VINFO_MEMTAG (res) = NULL;\n+  STMT_VINFO_VECT_DR_BASE (res) = NULL;\n \n   return res;\n }\n@@ -402,55 +412,187 @@ vect_debug_details (struct loop *loop)\n   return false;\n }\n \n-/* Function vect_get_base_decl_and_bit_offset\n+\n+/* Function vect_get_ptr_offset\n+\n+   Compute the OFFSET modulo vector-type alignment of pointer REF in bits.  */\n+\n+static tree \n+vect_get_ptr_offset (tree ref ATTRIBUTE_UNUSED, \n+\t\t     tree vectype ATTRIBUTE_UNUSED, \n+\t\t     tree *offset ATTRIBUTE_UNUSED)\n+{\n+  /* TODO: Use alignment information.  */\n+  return NULL_TREE; \n+}\n+\n+\n+/* Function vect_get_base_and_bit_offset\n+\n+   Return the BASE of the data reference EXPR.\n+   If VECTYPE is given, also compute the OFFSET from BASE in bits.\n+   E.g., for EXPR a.b[i] + 4B, BASE is a, and OFFSET is the overall offset in \n+   bits of 'a.b[i] + 4B' from a.\n+\n+   Input:\n+   EXPR - the memory reference that is being analyzed\n+   DR - the data_reference struct of the _original_ memory reference\n+        (Note: DR_REF (DR) is not necessarily EXPR)\n+   VECTYPE - the type that defines the alignment (i.e, we compute\n+             alignment relative to TYPE_ALIGN(VECTYPE))\n    \n-   Get the decl from which the data reference REF is based, \n-   and compute the OFFSET from it in bits on the way.  \n-   FORNOW: Handle only component-refs that consist of\n-   VAR_DECLs (no ARRAY_REF or INDIRECT_REF).  */\n+   Output:\n+   BASE (returned value) - the base of the data reference EXPR.\n+                           E.g, if EXPR is a.b[k].c[i][j] the returned\n+\t\t\t   base is a.\n+   OFFSET - offset of EXPR from BASE in bits\n+   BASE_ALIGNED_P - indicates if BASE is aligned\n+ \n+   If something unexpected is encountered (an unsupported form of data-ref),\n+   or if VECTYPE is given but OFFSET cannot be determined:\n+   then NULL_TREE is returned.  */\n \n static tree \n-vect_get_base_decl_and_bit_offset (tree ref, tree *offset)\n+vect_get_base_and_bit_offset (struct data_reference *dr, \n+\t\t\t      tree expr, \n+\t\t\t      tree vectype, \n+\t\t\t      loop_vec_info loop_vinfo,\n+\t\t\t      tree *offset,\n+\t\t\t      bool *base_aligned_p)\n {\n-  tree decl;\n-  if (TREE_CODE (ref) == VAR_DECL)\n-    return ref;\n+  tree this_offset = size_zero_node;\n+  tree base = NULL_TREE;\n+  tree next_ref;\n+  tree oprnd0, oprnd1;\n+  struct data_reference *array_dr;\n+  enum tree_code code = TREE_CODE (expr);\n+\n+  *base_aligned_p = false;\n \n-  if (TREE_CODE (ref) == COMPONENT_REF)\n+  switch (code)\n     {\n-      tree this_offset;\n-      tree oprnd0 = TREE_OPERAND (ref, 0);\n-      tree oprnd1 = TREE_OPERAND (ref, 1);\n+    /* These cases end the recursion:  */\n+    case VAR_DECL:\n+      *offset = size_zero_node;\n+      if (vectype && DECL_ALIGN (expr) >= TYPE_ALIGN (vectype))\n+\t*base_aligned_p = true;\n+      return expr;\n+\n+    case SSA_NAME:\n+      if (!vectype)\n+\treturn expr;\n+\n+      if (TREE_CODE (TREE_TYPE (expr)) != POINTER_TYPE)\n+\treturn NULL_TREE;\n+      \n+      if (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (expr))) < TYPE_ALIGN (vectype)) \n+\t{\n+\t  base = vect_get_ptr_offset (expr, vectype, offset);\n+\t  if (base)\n+\t    *base_aligned_p = true;\n+\t}\n+      else\n+\t{\t  \n+\t  *base_aligned_p = true;\n+\t  *offset = size_zero_node;\n+\t  base = expr;\n+\t}\n+      return base;\n+      \n+    case INTEGER_CST:      \n+      *offset = int_const_binop (MULT_EXPR, expr,     \n+\t\t\t\t build_int_cst (NULL_TREE, BITS_PER_UNIT), 1);\n+      return expr;\n+\n+    /* These cases continue the recursion:  */\n+    case COMPONENT_REF:\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      oprnd1 = TREE_OPERAND (expr, 1);\n \n       this_offset = bit_position (oprnd1);\n-      if (!host_integerp (this_offset,1))\n+      if (vectype && !host_integerp (this_offset, 1))\n+        return NULL_TREE;\n+      next_ref = oprnd0;\n+      break;\n+\n+    case ADDR_EXPR:\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      next_ref = oprnd0;\n+      break;\n+\n+    case INDIRECT_REF:\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      next_ref = oprnd0;\n+      break;\n+    \n+    case ARRAY_REF:\n+      if (DR_REF (dr) != expr)\n+\t/* Build array data_reference struct if the existing DR_REF \n+\t   doesn't match EXPR. This happens, for example, when the \n+\t   EXPR is *T and T is initialized to &arr[indx]. The DR struct\n+\t   contains information on the access of T, not of arr. In order\n+\t   to continue  the analysis, we create a new DR struct that\n+\t   describes the access of arr.  \n+\t*/\n+\tarray_dr = analyze_array (DR_STMT (dr), expr, DR_IS_READ (dr));\n+      else\n+\tarray_dr = dr;\n+\t  \n+      next_ref = vect_compute_array_ref_alignment (array_dr, loop_vinfo,  \n+\t\t\t\t\t\t   vectype, &this_offset);\n+      if (!next_ref)\n \treturn NULL_TREE;\n- \t\n-      decl = vect_get_base_decl_and_bit_offset (oprnd0, offset);\n \n-      if (decl)\n+      if (vectype &&\n+\t  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (next_ref))) >= TYPE_ALIGN (vectype))\n \t{\n-          *offset = int_const_binop (PLUS_EXPR, *offset, this_offset, 1);\n+\t  *offset = this_offset;\n+\t  *base_aligned_p = true;\n+\t  return next_ref;\n+\t}\n+      break;\n \n-          if (!host_integerp (*offset,1) || TREE_OVERFLOW (*offset)) \n-\t    return NULL_TREE;\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      /* In case we have a PLUS_EXPR of the form\n+\t (oprnd0 + oprnd1), we assume that only oprnd0 determines the base. \n+\t This is verified in  vect_get_symbl_and_dr.  */ \n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      oprnd1 = TREE_OPERAND (expr, 1);\n+\n+      base = vect_get_base_and_bit_offset \n+\t(dr, oprnd1, vectype, loop_vinfo, &this_offset, base_aligned_p);  \n+      if (vectype && !base) \n+\treturn NULL_TREE;\n \n-\t  if (vect_debug_details (NULL))\n-\t    {\n-\t      print_generic_expr (dump_file, ref, TDF_SLIM);\n-\t      fprintf (dump_file, \" --> total offset for ref: \");\n-\t      print_generic_expr (dump_file, *offset, TDF_SLIM);\n-\t    }\n-\t}\n+      next_ref = oprnd0;\n+      break;\n \n-      return decl;\n+    default:\n+      return NULL_TREE;\n     }\n \n-  /* TODO: extend to handle more cases.  */\n-  return NULL_TREE;\n+  base = vect_get_base_and_bit_offset (dr, next_ref, vectype, \n+\t\t\t\t       loop_vinfo, offset, base_aligned_p);  \n+\n+  if (vectype && base)\n+    {\n+      *offset = int_const_binop (PLUS_EXPR, *offset, this_offset, 1);\n+      if (!host_integerp (*offset, 1) || TREE_OVERFLOW (*offset))\n+        return NULL_TREE;\n+\n+      if (vect_debug_details (NULL))\n+        {\n+          print_generic_expr (dump_file, expr, TDF_SLIM);\n+          fprintf (dump_file, \" --> total offset for ref: \");\n+          print_generic_expr (dump_file, *offset, TDF_SLIM);\n+        }\n+    }    \n+  return base;\n }\n \n \n+\n /* Function vect_force_dr_alignment_p.\n \n    Returns whether the alignment of a DECL can be forced to be aligned\n@@ -507,87 +649,164 @@ vect_get_new_vect_var (tree type, enum vect_var_kind var_kind, const char *name)\n }\n \n \n-/* Function create_index_for_array_ref.\n+/* Function vect_create_index_for_vector_ref.\n \n    Create (and return) an index variable, along with it's update chain in the\n    loop. This variable will be used to access a memory location in a vector\n    operation.\n \n    Input:\n-   STMT: The stmt that contains a memory data-ref.\n+   LOOP: The loop being vectorized.\n    BSI: The block_stmt_iterator where STMT is. Any new stmts created by this\n         function can be added here, or in the loop pre-header.\n \n-   FORNOW: We are only handling array accesses with step 1.  */\n+   Output:\n+   Return an index that will be used to index a vector array.  It is expected\n+   that a pointer to the first vector will be used as the base address for the\n+   indexed reference.\n+\n+   FORNOW: we are not trying to be efficient, just creating a new index each\n+   time from scratch.  At this time all vector references could use the same\n+   index.\n+\n+   TODO: create only one index to be used by all vector references.  Record\n+   the index in the LOOP_VINFO the first time this procedure is called and\n+   return it on subsequent calls.  The increment of this index must be placed\n+   just before the conditional expression that ends the single block loop.  */\n \n static tree\n-vect_create_index_for_array_ref (tree stmt, block_stmt_iterator *bsi)\n+vect_create_index_for_vector_ref (struct loop *loop, block_stmt_iterator *bsi)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  tree expr = DR_REF (dr);\n-  tree access_fn;\n   tree init, step;\n-  loop_vec_info loop_info = loop->aux;\n-  int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_info);\n-  tree vf;\n-  tree array_first_index;\n   tree indx_before_incr, indx_after_incr;\n-  int loopnum = loop->num;\n-  bool ok;\n-#ifdef ENABLE_CHECKING\n-  varray_type access_fns = DR_ACCESS_FNS (dr);\n \n-  /* FORNOW: handling only one dimensional arrays.  */\n-  gcc_assert (VARRAY_ACTIVE_SIZE (access_fns) == 1);\n-  gcc_assert (vectorization_factor);\n-#endif\n+  /* It is assumed that the base pointer used for vectorized access contains\n+     the address of the first vector.  Therefore the index used for vectorized\n+     access must be initialized to zero and incremented by 1.  */\n \n-  access_fn = DR_ACCESS_FN (dr, 0);\n-  ok = vect_is_simple_iv_evolution (loopnum, access_fn, &init, &step, true)\n-       && vect_get_first_index (expr, &array_first_index);\n+  init = integer_zero_node;\n+  step = integer_one_node;\n+\n+  /* Assuming that bsi_insert is used with BSI_NEW_STMT  */\n+  create_iv (init, step, NULL_TREE, loop, bsi, false,\n+\t&indx_before_incr, &indx_after_incr);\n \n-  gcc_assert (ok);\n+  return indx_before_incr;\n+}\n \n-  /* FORNOW: Handling only constant 'init'.  */\n-  gcc_assert (TREE_CODE (init) == INTEGER_CST);\n \n-  vf = build_int_cst (unsigned_type_node, vectorization_factor);\n+/* Function vect_create_addr_base_for_vector_ref.\n \n-  if (vect_debug_details (NULL))\n-    {\n-      fprintf (dump_file, \"int vf = %d\",vectorization_factor);\n-      fprintf (dump_file, \", vf:\");\n-      print_generic_expr (dump_file, vf, TDF_SLIM);\n-      fprintf (dump_file, \", init:\");\n-      print_generic_expr (dump_file, init, TDF_SLIM);\n-      fprintf (dump_file, \", array_first_index:\");\n-      print_generic_expr (dump_file, array_first_index, TDF_SLIM);\n-    }\n+   Create an expression that computes the address of the first memory location\n+   that will be accessed for a data reference.\n \n-  /* Calculate the 'init' of the new index.\n-     init = (init - array_first_index) / vectorization_factor  */\n-  init = int_const_binop (TRUNC_DIV_EXPR,\n-\t\t  int_const_binop (MINUS_EXPR, init, array_first_index, 1),\n-\t\t  vf, 1);\n+   Input:\n+   STMT: The statement containing the data reference.\n+   NEW_STMT_LIST: Must be initialized to NULL_TREE or a\n+   statement list.\n \n-  /* Calculate the 'step' of the new index.  FORNOW: always 1.  */\n-  step = size_one_node;\n+   Output:\n+   1. Return an SSA_NAME whose value is the address of the memory location of the\n+      first vector of the data reference.\n+   2. If new_stmt_list is not NULL_TREE after return then the caller must insert\n+      these statement(s) which define the returned SSA_NAME.\n \n-  if (vect_debug_details (NULL))\n-    {\n-      fprintf (dump_file, \"create iv for (\");\n-      print_generic_expr (dump_file, init, TDF_SLIM);\n-      fprintf (dump_file, \", + ,\");\n-      print_generic_expr (dump_file, step, TDF_SLIM);\n-      fprintf (dump_file, \")\");\n-    }\n+   FORNOW: We are only handling array accesses with step 1.  */\n \n-  create_iv (init, step, NULL_TREE, loop, bsi, false, \n-\t     &indx_before_incr, &indx_after_incr); \n+static tree\n+vect_create_addr_base_for_vector_ref (tree stmt,\n+                                      tree *new_stmt_list)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  tree data_ref_base = unshare_expr (STMT_VINFO_VECT_DR_BASE (stmt_info));\n+  tree base_name = unshare_expr (DR_BASE_NAME (dr));\n+  tree ref = DR_REF (dr);\n+  tree data_ref_base_type = TREE_TYPE (data_ref_base);\n+  tree scalar_type = TREE_TYPE (ref);\n+  tree scalar_ptr_type = build_pointer_type (scalar_type);\n+  tree access_fn;\n+  tree init_val, step, init_oval;\n+  bool ok;\n+  bool is_ptr_ref, is_array_ref, is_addr_expr;\n+  tree array_base;\n+  tree vec_stmt;\n+  tree new_temp;\n+  tree array_ref;\n+  tree addr_base, addr_expr;\n+  tree dest, new_stmt;\n \n-  return indx_before_incr;\n+  /* Only the access function of the last index is relevant (i_n in\n+     a[i_1][i_2]...[i_n]), the others correspond to loop invariants. */\n+  access_fn = DR_ACCESS_FN (dr, 0);\n+  ok = vect_is_simple_iv_evolution (loop->num, access_fn, &init_oval, &step, true);\n+  if (!ok)\n+    init_oval = integer_zero_node;\n+\n+  is_ptr_ref = TREE_CODE (data_ref_base_type) == POINTER_TYPE\n+\t       && TREE_CODE (data_ref_base) == SSA_NAME;\n+  is_array_ref = TREE_CODE (data_ref_base_type) == ARRAY_TYPE\n+\t\t && (TREE_CODE (data_ref_base) == VAR_DECL\n+\t\t     || TREE_CODE (data_ref_base) == COMPONENT_REF\n+\t\t     || TREE_CODE (data_ref_base) == ARRAY_REF);\n+  is_addr_expr = TREE_CODE (data_ref_base) == ADDR_EXPR\n+                 || TREE_CODE (data_ref_base) == PLUS_EXPR\n+                 || TREE_CODE (data_ref_base) == MINUS_EXPR;\n+  gcc_assert (is_ptr_ref || is_array_ref || is_addr_expr);\n+\n+  /** Create: &(base[init_val])\n+\n+      if data_ref_base is an ARRAY_TYPE:\n+\t base = data_ref_base\n+\n+      if data_ref_base is the SSA_NAME of a POINTER_TYPE:\n+\t base = *((scalar_array *) data_ref_base)\n+   **/\n+\n+  if (is_array_ref)\n+    array_base = data_ref_base;\n+  else /* is_ptr_ref  or is_addr_expr */\n+    {\n+      /* array_ptr = (scalar_array_ptr_type *) data_ref_base;  */\n+      tree scalar_array_type = build_array_type (scalar_type, 0);\n+      tree scalar_array_ptr_type = build_pointer_type (scalar_array_type);\n+      tree array_ptr = create_tmp_var (scalar_array_ptr_type, \"array_ptr\");\n+      add_referenced_tmp_var (array_ptr);\n+\n+      dest = create_tmp_var (TREE_TYPE (data_ref_base), \"dataref\");\n+      add_referenced_tmp_var (dest);\n+      data_ref_base  = force_gimple_operand (data_ref_base, &new_stmt, false, dest);  \n+      append_to_statement_list_force (new_stmt, new_stmt_list);\n+\n+      vec_stmt = fold_convert (scalar_array_ptr_type, data_ref_base);\n+      vec_stmt = build2 (MODIFY_EXPR, void_type_node, array_ptr, vec_stmt);\n+      new_temp = make_ssa_name (array_ptr, vec_stmt);\n+      TREE_OPERAND (vec_stmt, 0) = new_temp;\n+      append_to_statement_list_force (vec_stmt, new_stmt_list);\n+\n+      /* (*array_ptr)  */\n+      array_base = build_fold_indirect_ref (new_temp);\n+    }\n+\n+  dest = create_tmp_var (TREE_TYPE (init_oval), \"newinit\");\n+  add_referenced_tmp_var (dest);\n+  init_val = force_gimple_operand (init_oval, &new_stmt, false, dest);  \n+  append_to_statement_list_force (new_stmt, new_stmt_list);\n+\n+  array_ref = build4 (ARRAY_REF, scalar_type, array_base, init_val, \n+\t\t      NULL_TREE, NULL_TREE);\n+  addr_base = build_fold_addr_expr (array_ref);\n+\n+  /* addr_expr = addr_base */\n+  addr_expr = vect_get_new_vect_var (scalar_ptr_type, vect_pointer_var,\n+                                     get_name (base_name));\n+  add_referenced_tmp_var (addr_expr);\n+  vec_stmt = build2 (MODIFY_EXPR, void_type_node, addr_expr, addr_base);\n+  new_temp = make_ssa_name (addr_expr, vec_stmt);\n+  TREE_OPERAND (vec_stmt, 0) = new_temp;\n+  append_to_statement_list_force (vec_stmt, new_stmt_list);\n+  return new_temp;\n }\n \n \n@@ -602,6 +821,7 @@ get_vectype_for_scalar_type (tree scalar_type)\n   enum machine_mode inner_mode = TYPE_MODE (scalar_type);\n   int nbytes = GET_MODE_SIZE (inner_mode);\n   int nunits;\n+  tree vectype;\n \n   if (nbytes == 0)\n     return NULL_TREE;\n@@ -610,7 +830,10 @@ get_vectype_for_scalar_type (tree scalar_type)\n      is expected.  */\n   nunits = UNITS_PER_SIMD_WORD / nbytes;\n \n-  return build_vector_type (scalar_type, nunits);\n+  vectype = build_vector_type (scalar_type, nunits);\n+  if (TYPE_MODE (vectype) == BLKmode)\n+    return NULL_TREE;\n+  return vectype;\n }\n \n \n@@ -656,107 +879,116 @@ vect_align_data_ref (tree stmt)\n static tree\n vect_create_data_ref (tree stmt, block_stmt_iterator *bsi)\n {\n-  tree new_base;\n-  tree data_ref;\n-  tree idx;\n-  tree vec_stmt;\n-  tree new_temp;\n+  tree base_name, data_ref_base, data_ref_base_type;\n+  tree array_type;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree vect_ptr_type;\n   tree vect_ptr;\n-  tree addr_ref;\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  tree array_type;\n-  tree base_addr = NULL_TREE;\n-  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n-  edge pe;\n   tree tag;\n-  tree addr_expr;\n-  tree scalar_ptr_type;\n-  tree use;\n-  ssa_op_iter iter;\n+  v_may_def_optype v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n+  v_must_def_optype v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n+  vuse_optype vuses = STMT_VUSE_OPS (stmt);\n+  int nvuses, nv_may_defs, nv_must_defs;\n+  int i;\n+  tree new_temp;\n+  tree vec_stmt;\n+  tree new_stmt_list = NULL_TREE;\n+  tree idx;\n+  tree new_base;\n+  tree data_ref;\n+  edge pe;\n+  basic_block new_bb;\n \n   /* FORNOW: make sure the data reference is aligned.  */\n   vect_align_data_ref (stmt);\n \n-  addr_ref = DR_BASE_NAME (dr);\n+  base_name = unshare_expr (DR_BASE_NAME (dr));\n+  data_ref_base = STMT_VINFO_VECT_DR_BASE (stmt_info);\n+  data_ref_base_type = TREE_TYPE (data_ref_base);\n \n   array_type = build_array_type (vectype, 0);\n-  TYPE_ALIGN (array_type) = TYPE_ALIGN (TREE_TYPE (addr_ref));\n+  TYPE_ALIGN (array_type) = TYPE_ALIGN (data_ref_base_type);\n   vect_ptr_type = build_pointer_type (array_type);\n-  scalar_ptr_type = build_pointer_type (TREE_TYPE (addr_ref));\n \n   if (vect_debug_details (NULL))\n     {\n       fprintf (dump_file, \"create array_ref of type: \");\n       print_generic_expr (dump_file, vectype, TDF_SLIM);\n     }\n \n-  /*** create: vectype_array *p;  ***/\n+  /* Create: vectype *p;  */\n   vect_ptr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var, \n-\t\tget_name (addr_ref));\n+\t\t\t\t    get_name (base_name));\n   add_referenced_tmp_var (vect_ptr);\n \n-  gcc_assert (TREE_CODE (addr_ref) == VAR_DECL\n-\t      || TREE_CODE (addr_ref) == COMPONENT_REF\n-\t      || TREE_CODE (addr_ref) == SSA_NAME);\n-\n   if (vect_debug_details (NULL))\n     {\n-      if (TREE_CODE (addr_ref) == VAR_DECL)\n-\tfprintf (dump_file, \"vectorizing an array ref: \");\n-      else if (TREE_CODE (addr_ref) == SSA_NAME)\n+      if (TREE_CODE (data_ref_base) == VAR_DECL)\n+\tfprintf (dump_file, \"vectorizing a one dimensional array ref: \");\n+      else if (TREE_CODE (data_ref_base) == ARRAY_REF)\n+\tfprintf (dump_file, \"vectorizing a multidimensional array ref: \");\n+      else if (TREE_CODE (data_ref_base) == COMPONENT_REF)\n+\tfprintf (dump_file, \"vectorizing a record based array ref: \");\n+      else if (TREE_CODE (data_ref_base) == SSA_NAME)\n \tfprintf (dump_file, \"vectorizing a pointer ref: \");\n-      else if (TREE_CODE (addr_ref) == COMPONENT_REF)\n-\tfprintf (dump_file, \"vectorizing a record ref: \");\n-      print_generic_expr (dump_file, addr_ref, TDF_SLIM);\n+      else if (TREE_CODE (data_ref_base) == ADDR_EXPR\n+\t       || TREE_CODE (data_ref_base) == PLUS_EXPR\n+\t       || TREE_CODE (data_ref_base) == MINUS_EXPR)\n+\tfprintf (dump_file, \"vectorizing an address expr: \");\n+      print_generic_expr (dump_file, base_name, TDF_SLIM);\n     }\n \n-  /* Get base address:  */\n-  if (TREE_CODE (addr_ref) == SSA_NAME)\n-    base_addr = addr_ref;\n-  else\n-    base_addr = build_fold_addr_expr (addr_ref);\n-\n-  /* Handle aliasing:  */ \n+  /* Handle aliasing:  */\n   tag = STMT_VINFO_MEMTAG (stmt_info);\n   gcc_assert (tag);\n   get_var_ann (vect_ptr)->type_mem_tag = tag;\n-  \n+\n   /* Mark for renaming all aliased variables\n-     (i.e, the may-aliases of the type-mem-tag) */\n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter,\n-\t\t\t     (SSA_OP_VIRTUAL_DEFS | SSA_OP_VUSE))\n+     (i.e, the may-aliases of the type-mem-tag).  */\n+  nvuses = NUM_VUSES (vuses);\n+  nv_may_defs = NUM_V_MAY_DEFS (v_may_defs);\n+  nv_must_defs = NUM_V_MUST_DEFS (v_must_defs);\n+  for (i = 0; i < nvuses; i++)\n     {\n+      tree use = VUSE_OP (vuses, i);\n       if (TREE_CODE (use) == SSA_NAME)\n         bitmap_set_bit (vars_to_rename, var_ann (SSA_NAME_VAR (use))->uid);\n     }\n-\n+  for (i = 0; i < nv_may_defs; i++)\n+    {\n+      tree def = V_MAY_DEF_RESULT (v_may_defs, i);\n+      if (TREE_CODE (def) == SSA_NAME)\n+        bitmap_set_bit (vars_to_rename, var_ann (SSA_NAME_VAR (def))->uid);\n+    }\n+  for (i = 0; i < nv_must_defs; i++)\n+    {\n+      tree def = V_MUST_DEF_OP (v_must_defs, i);\n+      if (TREE_CODE (def) == SSA_NAME)\n+        bitmap_set_bit (vars_to_rename, var_ann (SSA_NAME_VAR (def))->uid);\n+    }\n+  \n   pe = loop_preheader_edge (loop);\n \n-  /*** create: p = (vectype *)&a; ***/\n+  /* Create: (&(base[init_val]) */\n+  new_temp = vect_create_addr_base_for_vector_ref (stmt, &new_stmt_list);\n \n-  /* addr_expr = &a */\n-  addr_expr = vect_get_new_vect_var (scalar_ptr_type, vect_pointer_var,\n-                \t\t\tget_name (addr_ref));\n-  add_referenced_tmp_var (addr_expr);\n-  vec_stmt = build2 (MODIFY_EXPR, void_type_node, addr_expr, base_addr);\n-  new_temp = make_ssa_name (addr_expr, vec_stmt);\n-  TREE_OPERAND (vec_stmt, 0) = new_temp;\n-  bsi_insert_on_edge (pe, vec_stmt);\n+  pe = loop_preheader_edge (loop); \n+  new_bb = bsi_insert_on_edge_immediate (pe, new_stmt_list); \n+  gcc_assert (!new_bb); \n \n-  /* vect_ptr = (vectype_array *)&a; */\n-  vec_stmt = fold_convert (vect_ptr_type, new_temp); \n+  /* p = (vectype_array *) addr_base  */\n+  vec_stmt = fold_convert (vect_ptr_type, new_temp);\n   vec_stmt = build2 (MODIFY_EXPR, void_type_node, vect_ptr, vec_stmt);\n   new_temp = make_ssa_name (vect_ptr, vec_stmt);\n   TREE_OPERAND (vec_stmt, 0) = new_temp;\n-  bsi_insert_on_edge (pe, vec_stmt);\n+  new_bb = bsi_insert_on_edge_immediate (pe, vec_stmt); \n+  gcc_assert (!new_bb); \n \n   /*** create data ref: '(*p)[idx]' ***/\n-\n-  idx = vect_create_index_for_array_ref (stmt, bsi);\n-\n+  idx = vect_create_index_for_vector_ref (loop, bsi);\n   new_base = build_fold_indirect_ref (new_temp);\n   data_ref = build4 (ARRAY_REF, vectype, new_base, idx, NULL_TREE, NULL_TREE);\n \n@@ -809,6 +1041,7 @@ vect_init_vector (tree stmt, tree vector_var)\n   tree vec_oprnd;\n   edge pe;\n   tree new_temp;\n+  basic_block new_bb;\n  \n   new_var = vect_get_new_vect_var (vectype, vect_simple_var, \"cst_\");\n   add_referenced_tmp_var (new_var); \n@@ -818,7 +1051,8 @@ vect_init_vector (tree stmt, tree vector_var)\n   TREE_OPERAND (init_stmt, 0) = new_temp;\n \n   pe = loop_preheader_edge (loop);\n-  bsi_insert_on_edge (pe, init_stmt);\n+  new_bb = bsi_insert_on_edge_immediate (pe, init_stmt);\n+  gcc_assert (!new_bb);\n \n   if (vect_debug_details (NULL))\n     {\n@@ -1935,9 +2169,9 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n          vectorization yet. This property is verified in vect_is_simple_use,\n          during vect_analyze_operations.  */\n \n-      access_fn = instantiate_parameters\n-\t(loop,\n-\t analyze_scalar_evolution (loop, PHI_RESULT (phi)));\n+      access_fn = /* instantiate_parameters\n+\t\t     (loop,*/\n+\t analyze_scalar_evolution (loop, PHI_RESULT (phi));\n \n       if (!access_fn)\n \t{\n@@ -1975,15 +2209,15 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n \t\t\t\t  struct data_reference *drb, \n \t\t\t\t  struct loop *loop)\n {\n-  bool differ_p;\n+  bool differ_p; \n   struct data_dependence_relation *ddr;\n-\n+  \n   if (!array_base_name_differ_p (dra, drb, &differ_p))\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))   \n         {\n-          fprintf (dump_file, \n-\t\t\"not vectorized: can't determine dependence between: \");\n+          fprintf (dump_file,\n+                \"not vectorized: can't determine dependence between: \");\n           print_generic_expr (dump_file, DR_REF (dra), TDF_SLIM);\n           fprintf (dump_file, \" and \");\n           print_generic_expr (dump_file, DR_REF (drb), TDF_SLIM);\n@@ -2105,33 +2339,152 @@ vect_get_first_index (tree ref, tree *array_first_index)\n }\n \n \n+/* Function vect_compute_array_base_alignment.\n+   A utility function of vect_compute_array_ref_alignment.\n+\n+   Compute the misalignment of ARRAY in bits.\n+\n+   Input:\n+   ARRAY - an array_ref (possibly multidimensional) of type ARRAY_TYPE.\n+   VECTYPE - we are interested in the misalignment modulu the size of vectype.\n+\t     if NULL: don't compute misalignment, just return the base of ARRAY.\n+   PREV_DIMENSIONS - initialized to one.\n+   MISALIGNMENT - the computed misalignment in bits.\n+\n+   Output:\n+   If VECTYPE is not NULL:\n+     Return NULL_TREE if the misalignment cannot be computed. Otherwise, return \n+     the base of the array, and put the computed misalignment in MISALIGNMENT. \n+   If VECTYPE is NULL:\n+     Return the base of the array.\n+\n+   For a[idx_N]...[idx_2][idx_1][idx_0], the address of \n+   a[idx_N]...[idx_2][idx_1] is \n+   {&a + idx_1 * dim_0 + idx_2 * dim_0 * dim_1 + ...  \n+    ... + idx_N * dim_0 * ... * dim_N-1}. \n+   (The misalignment of &a is not checked here).\n+   Note, that every term contains dim_0, therefore, if dim_0 is a \n+   multiple of NUNITS, the whole sum is a multiple of NUNITS.\n+   Otherwise, if idx_1 is constant, and dim_1 is a multiple of\n+   NUINTS, we can say that the misalignment of the sum is equal to\n+   the misalignment of {idx_1 * dim_0}.  If idx_1 is not constant,\n+   we can't determine this array misalignment, and we return\n+   false. \n+   We proceed recursively in this manner, accumulating total misalignment\n+   and the multiplication of previous dimensions for correct misalignment\n+   calculation.  */\n+\n+static tree\n+vect_compute_array_base_alignment (tree array,\n+\t\t\t\t   tree vectype,\n+\t\t\t\t   tree *prev_dimensions,\n+\t\t\t\t   tree *misalignment)\n+{\n+  tree index;\n+  tree domain;\n+  tree dimension_size;\n+  tree mis;\n+  tree bits_per_vectype;\n+  tree bits_per_vectype_unit;\n+\n+  /* The 'stop condition' of the recursion.  */\n+  if (TREE_CODE (array) != ARRAY_REF)\n+    return array;\n+  \n+  if (!vectype)\n+    /* Just get the base decl.  */\n+    return vect_compute_array_base_alignment \n+\t\t(TREE_OPERAND (array, 0), NULL, NULL, NULL);\n+\n+  if (!host_integerp (*misalignment, 1) || TREE_OVERFLOW (*misalignment) || \n+      !host_integerp (*prev_dimensions, 1) || TREE_OVERFLOW (*prev_dimensions))\n+    return NULL_TREE;\n+\n+  domain = TYPE_DOMAIN (TREE_TYPE (array));\n+  dimension_size = \n+\tint_const_binop (PLUS_EXPR,\n+\t\tint_const_binop (MINUS_EXPR, TYPE_MAX_VALUE (domain), \n+\t\t\t\t\t     TYPE_MIN_VALUE (domain), 1),\n+\t\tsize_one_node, 1);\n+\n+  /* Check if the dimension size is a multiple of NUNITS, the remaining sum\n+     is a multiple of NUNITS: \n+\n+     dimension_size % GET_MODE_NUNITS (TYPE_MODE (vectype)) == 0 ?\n+   */\n+  mis = int_const_binop (TRUNC_MOD_EXPR, dimension_size,\n+\t build_int_cst (NULL_TREE, GET_MODE_NUNITS (TYPE_MODE (vectype))), 1);\n+  if (integer_zerop (mis))\n+    /* This array is aligned. Continue just in order to get the base decl.  */\n+    return vect_compute_array_base_alignment \n+\t\t(TREE_OPERAND (array, 0), NULL, NULL, NULL);\n+\n+  index = TREE_OPERAND (array, 1);\n+  if (!host_integerp (index, 1))\n+    /* The current index is not constant.  */\n+    return NULL_TREE;\n+   \n+  index = int_const_binop (MINUS_EXPR, index, TYPE_MIN_VALUE (domain), 0);\n+\n+  bits_per_vectype = fold_convert (unsigned_type_node, \n+    build_int_cst (NULL_TREE, BITS_PER_UNIT * \n+\t\t GET_MODE_SIZE (TYPE_MODE (vectype))));\n+  bits_per_vectype_unit =  fold_convert (unsigned_type_node,\n+    build_int_cst (NULL_TREE, BITS_PER_UNIT * \n+\t\t GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (vectype)))));\n+  \n+  /* Add {idx_i * dim_i-1 * ... * dim_0 } to the misalignment computed\n+     earlier:\n+\n+     *misalignment = \n+       (*misalignment + index_val * dimension_size * *prev_dimensions) \n+\t\t\t\t\t\t\t% vectype_nunits;\n+   */\n+\n+  mis = int_const_binop (MULT_EXPR, index, dimension_size, 1);\n+  mis = int_const_binop (MULT_EXPR, mis, *prev_dimensions, 1);\n+  mis = int_const_binop (MULT_EXPR, mis, bits_per_vectype_unit, 1);\n+  mis = int_const_binop (PLUS_EXPR, *misalignment, mis, 1);\n+  *misalignment = int_const_binop (TRUNC_MOD_EXPR, mis, bits_per_vectype, 1);\n+\n+\n+  *prev_dimensions = int_const_binop (MULT_EXPR, \n+\t\t\t\t*prev_dimensions, dimension_size, 1);\n+\n+  return vect_compute_array_base_alignment (TREE_OPERAND (array, 0), vectype,\n+\t\t\t\t\t    prev_dimensions,\n+\t\t\t\t\t    misalignment);\n+}\n+\n+ \n /* Function vect_compute_data_ref_alignment\n \n    Compute the misalignment of the data reference DR.\n \n+   Output:\n+   1. If during the misalignment computation it is found that the data reference\n+      cannot be vectorized then false is returned.\n+   2. DR_MISALIGNMENT (DR) is defined.\n+\n    FOR NOW: No analysis is actually performed. Misalignment is calculated\n    only for trivial cases. TODO.  */\n \n-static void\n+static bool\n vect_compute_data_ref_alignment (struct data_reference *dr, \n-\t\t\t\t loop_vec_info loop_vinfo ATTRIBUTE_UNUSED)\n+\t\t\t\t loop_vec_info loop_vinfo)\n {\n   tree stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);  \n   tree ref = DR_REF (dr);\n   tree vectype;\n-  tree access_fn = DR_ACCESS_FN (dr, 0); /* FORNOW: single access_fn.  */\n-  tree init;\n   tree scalar_type;\n-  tree misalign;\n-  tree array_first_index;\n-  tree array_base = DR_BASE_NAME (dr);\n-  tree base_decl = NULL_TREE;\n-  tree bit_offset = size_zero_node;\n   tree offset = size_zero_node;\n-  tree unit_bits = build_int_cst (unsigned_type_node, BITS_PER_UNIT);\n-  tree nunits;\n-  tree alignment;\n-\n+  tree base, bit_offset, alignment;\n+  tree unit_bits = fold_convert (unsigned_type_node, \n+\t\t\t\t build_int_cst (NULL_TREE, BITS_PER_UNIT));\n+  tree dr_base;\n+  bool base_aligned_p;\n+   \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"vect_compute_data_ref_alignment:\");\n \n@@ -2146,135 +2499,187 @@ vect_compute_data_ref_alignment (struct data_reference *dr,\n         {\n           fprintf (dump_file, \"no vectype for stmt: \");\n           print_generic_expr (dump_file, stmt, TDF_SLIM);\n-          fprintf (dump_file, \"scalar_type: \");\n+          fprintf (dump_file, \" scalar_type: \");\n           print_generic_expr (dump_file, scalar_type, TDF_DETAILS);\n         }\n-      return;\n+      /* It is not possible to vectorize this data reference. */\n+      return false;\n     }\n+  gcc_assert (TREE_CODE (ref) == ARRAY_REF || TREE_CODE (ref) == INDIRECT_REF);\n+  \n+  if (TREE_CODE (ref) == ARRAY_REF)\n+    dr_base = ref;\n+  else\n+    dr_base = STMT_VINFO_VECT_DR_BASE (stmt_info);\n \n-  if (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (array_base))) < TYPE_ALIGN (vectype))\n+  base = vect_get_base_and_bit_offset (dr, dr_base, vectype, \n+\t\t\t  loop_vinfo, &bit_offset, &base_aligned_p);\n+  if (!base)\n     {\n-      base_decl = vect_get_base_decl_and_bit_offset (array_base, &bit_offset);\n-      if (!base_decl)\n+      if (vect_debug_details (NULL)) \n \t{\n-\t  if (vect_debug_details (NULL))\n-\t    fprintf (dump_file, \"Unknown alignment for access\");\n-\t  return;\n+\t  fprintf (dump_file, \"Unknown alignment for access: \");\n+\t  print_generic_expr (dump_file, \n+\t\t\t      STMT_VINFO_VECT_DR_BASE (stmt_info), TDF_SLIM);\n \t}\n+      return true;\n+    }\n \n-      offset = int_const_binop (TRUNC_DIV_EXPR, bit_offset, unit_bits, 1); \n-      bit_offset = int_const_binop (TRUNC_MOD_EXPR, bit_offset, unit_bits, 1); \n-      if (!integer_zerop (bit_offset))\n+  if (!base_aligned_p) \n+    {\n+      if (!vect_can_force_dr_alignment_p (base, TYPE_ALIGN (vectype)))\n \t{\n \t  if (vect_debug_details (NULL))\n-            {\n-              fprintf (dump_file, \"bit offset alignment: \");\n-              print_generic_expr (dump_file, bit_offset, TDF_SLIM);\n-            }\n-\t  return;\n+\t    {\n+\t      fprintf (dump_file, \"can't force alignment of ref: \");\n+\t      print_generic_expr (dump_file, ref, TDF_SLIM);\n+\t    }\n+\t  return true;\n \t}\n+      \n+      /* Force the alignment of the decl.\n+\t NOTE: This is the only change to the code we make during\n+\t the analysis phase, before deciding to vectorize the loop.  */\n+      if (vect_debug_details (NULL))\n+\tfprintf (dump_file, \"force alignment\");\n+      DECL_ALIGN (base) = TYPE_ALIGN (vectype);\n+      DECL_USER_ALIGN (base) = TYPE_ALIGN (vectype);\n+    }\n \n-      if (!base_decl ||\n-\t  (DECL_ALIGN (base_decl) < TYPE_ALIGN (vectype)\n-\t   && !vect_can_force_dr_alignment_p (base_decl, TYPE_ALIGN (vectype))))\n+  /* At this point we assume that the base is aligned, and the offset from it\n+     (including index, if relevant) has been computed and is in BIT_OFFSET.  */\n+  gcc_assert (base_aligned_p \n+\t      || (TREE_CODE (base) == VAR_DECL \n+\t\t  && DECL_ALIGN (base) >= TYPE_ALIGN (vectype)));\n+\n+  /* Convert into bytes.  */\n+  offset = int_const_binop (TRUNC_DIV_EXPR, bit_offset, unit_bits, 1);\n+  /* Check that there is no remainder in bits.  */\n+  bit_offset = int_const_binop (TRUNC_MOD_EXPR, bit_offset, unit_bits, 1);\n+  if (!integer_zerop (bit_offset))\n+    {\n+      if (vect_debug_details (NULL))\n \t{\n-\t  if (vect_debug_details (NULL))\n-\t    {\n-\t      fprintf (dump_file, \"can't force alignment of ref: \"); \n-\t      print_generic_expr (dump_file, array_base, TDF_SLIM);\n-\t    }\n-\t  return;\n+\t  fprintf (dump_file, \"bit offset alignment: \");\n+\t  print_generic_expr (dump_file, bit_offset, TDF_SLIM);\n \t}\n+      return false;\n+    }\n+  \n+  /* Alignment required, in bytes:  */\n+  alignment = fold_convert (unsigned_type_node,\n+\t    build_int_cst (NULL_TREE, TYPE_ALIGN (vectype)/BITS_PER_UNIT));\n \n-       if (DECL_ALIGN (base_decl) < TYPE_ALIGN (vectype))\n-\t {\n-\t   /* Force the alignment of the decl.  \n-\t      NOTE: This is the only change to the code we make during\n-\t      the analysis phase, before deciding to vectorize the loop.  */ \n-\t   if (vect_debug_details (NULL))\n-\t     fprintf (dump_file, \"force alignment\");\n-\t   DECL_ALIGN (base_decl) = TYPE_ALIGN (vectype); \n-\t   DECL_USER_ALIGN (base_decl) = TYPE_ALIGN (vectype);  \n-\t }\n+  /* Modulo alignment.  */\n+  offset = int_const_binop (TRUNC_MOD_EXPR, offset, alignment, 0);\n+  if (!host_integerp (offset, 1) || TREE_OVERFLOW (offset))\n+    {\n+      if (vect_debug_details (NULL))\n+\tfprintf (dump_file, \"unexpected misalign value\");\n+      return false;\n     }\n \n-  /* The misalignement is:\n-     (base_alignment + offset + index_access_fn_init) % alignment.\n-     At this point we already guaranteed that base_alignment == 0,\n-     and computed the offset. \n-     It remains to check the first index accessed.  */\n+  DR_MISALIGNMENT (dr) = tree_low_cst (offset, 1);\n \n+  if (vect_debug_details (NULL))\n+    fprintf (dump_file, \"misalign = %d\", DR_MISALIGNMENT (dr));\n+\n+  return true;\n+}\n+\n+\n+/* Function vect_compute_array_ref_alignment\n+\n+   Compute the alignment of an array-ref.\n+   The alignment we compute here is relative to \n+   TYPE_ALIGN(VECTYPE) boundary.  \n+\n+   Output:\n+   OFFSET - the alignment in bits\n+   Return value - the base of the array-ref. E.g, \n+                  if the array-ref is a.b[k].c[i][j] the returned\n+\t\t  base is a.b[k].c\n+*/\n+\n+static tree\n+vect_compute_array_ref_alignment (struct data_reference *dr,\n+\t\t\t\t  loop_vec_info loop_vinfo,\n+\t\t\t\t  tree vectype,\n+\t\t\t\t  tree *offset)\n+{\n+  tree array_first_index = size_zero_node;\n+  tree init;\n+  tree ref = DR_REF (dr);\n+  tree scalar_type = TREE_TYPE (ref);\n+  tree oprnd0 = TREE_OPERAND (ref, 0);\n+  tree dims = size_one_node;  \n+  tree misalign = size_zero_node;\n+  tree next_ref, this_offset = size_zero_node;\n+  tree nunits;\n+  tree nbits;\n+\n+  if (TREE_CODE (TREE_TYPE (ref)) == ARRAY_TYPE)\n+      /* The reference is an array without its last index. */\n+      next_ref = vect_compute_array_base_alignment (ref, vectype, &dims, &misalign);\n+  else\n+      next_ref = \n+\tvect_compute_array_base_alignment (oprnd0, vectype, &dims, &misalign);\n+  if (!vectype)\n+    /* Alignment is not requested. Just return the base.  */\n+    return next_ref;\n+\n+  /* Compute alignment.  */\n+  if (!host_integerp (misalign, 1) || TREE_OVERFLOW (misalign) || !next_ref)\n+    return NULL_TREE;\n+  this_offset = misalign;\n+\n+  /* Check the first index accessed.  */\n   if (!vect_get_first_index (ref, &array_first_index))\n     {\n       if (vect_debug_details (NULL))\n         fprintf (dump_file, \"no first_index for array.\");\n-      return;\n+      return NULL_TREE;\n     }\n-  \n-  /* Check the index of the array_ref.  */\n \n-  init = initial_condition (access_fn);\n+  /* Check the index of the array_ref.  */\n+  init = initial_condition_in_loop_num (DR_ACCESS_FN (dr, 0), \n+\t\t\t\t\tLOOP_VINFO_LOOP (loop_vinfo)->num);\n \n-  /* FORNOW: In order to simplify the handling of alignment, we make sure \n-     that the first location at which the array is accessed ('init') is on an \n+  /* FORNOW: In order to simplify the handling of alignment, we make sure\n+     that the first location at which the array is accessed ('init') is on an\n      'NUNITS' boundary, since we are assuming here that 'array base' is aligned. \n-     This is too conservative, since we require that \n-     both {'array_base' is a multiple of NUNITS} && {'init' is a multiple of \n+     This is too conservative, since we require that\n+     both {'array_base' is a multiple of NUNITS} && {'init' is a multiple of\n      NUNITS}, instead of just {('array_base' + 'init') is a multiple of NUNITS}.\n      This should be relaxed in the future.  */\n \n-  if (!init || !host_integerp (init,0))\n+  if (!init || !host_integerp (init, 0))\n     {\n       if (vect_debug_details (NULL))\n-        fprintf (dump_file, \"init not simple INTEGER_CST.\");\n-      return;\n+\tfprintf (dump_file, \"non constant init. \");\n+      return NULL_TREE;\n     }\n \n-  /* alignment required, in bytes: */\n-  alignment = build_int_cst (unsigned_type_node, \n-\t\t\t     TYPE_ALIGN (vectype)/BITS_PER_UNIT);\n   /* bytes per scalar element: */\n-  nunits = build_int_cst (unsigned_type_node, \n-\t\t\t  GET_MODE_SIZE (TYPE_MODE (scalar_type)));\n-\n-  /* misalign = (offset + (init-array_first_index)*nunits) % alignment  */\n-  if (vect_debug_details (NULL))\n-    {\n-      fprintf (dump_file, \"misalign = ( offset <\");\n-      print_generic_expr (dump_file, offset, TDF_SLIM);  \n-      fprintf (dump_file, \"> + (init <\");\n-      print_generic_expr (dump_file, init, TDF_SLIM);  \n-      fprintf (dump_file, \"> - first_indx <\");\n-      print_generic_expr (dump_file, array_first_index, TDF_SLIM);  \n-      fprintf (dump_file, \">) * nunits <\");\n-      print_generic_expr (dump_file, nunits, TDF_SLIM);  \n-      fprintf (dump_file, \">)  mod alignment <\");\n-      print_generic_expr (dump_file, alignment, TDF_SLIM);  \n-      fprintf (dump_file, \">\");\n-    }\n+  nunits = fold_convert (unsigned_type_node,\n+\tbuild_int_cst (NULL_TREE, GET_MODE_SIZE (TYPE_MODE (scalar_type))));\n+  nbits = int_const_binop (MULT_EXPR, nunits,     \n+\t\t\t   build_int_cst (NULL_TREE, BITS_PER_UNIT), 1);\n \n+  /* misalign = offset + (init-array_first_index)*nunits*bits_in_byte */\n   misalign = int_const_binop (MINUS_EXPR, init, array_first_index, 0);\n-  misalign = int_const_binop (MULT_EXPR, misalign, nunits, 0);\n-  misalign = int_const_binop (PLUS_EXPR, misalign, offset, 0);\n-  misalign = int_const_binop (TRUNC_MOD_EXPR, misalign, alignment, 0);\n+  misalign = int_const_binop (MULT_EXPR, misalign, nbits, 0);\n+  misalign = int_const_binop (PLUS_EXPR, misalign, this_offset, 0);\n \n-  if (vect_debug_details (NULL))\n-    {\n-      fprintf (dump_file, \"misalign = \");\n-      print_generic_expr (dump_file, misalign, TDF_SLIM);  \n-    }\n-\n-  if (!host_integerp (misalign,1) || TREE_OVERFLOW (misalign))\n+  /* TODO: allow negative misalign values.  */\n+  if (!host_integerp (misalign, 1) || TREE_OVERFLOW (misalign))\n     {\n       if (vect_debug_details (NULL))\n-\tfprintf (dump_file, \"unexpected misalign value\");\n-      return;\n+        fprintf (dump_file, \"unexpected misalign value\");\n+      return NULL_TREE;\n     }\n-\n-  DR_MISALIGNMENT (dr) = tree_low_cst (misalign,1);\n-\n-  if (vect_debug_details (NULL))\n-    fprintf (dump_file, \"misalign = %d\",DR_MISALIGNMENT (dr));\n+  *offset = misalign;\n+  return next_ref;\n }\n \n \n@@ -2293,7 +2698,7 @@ vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n   varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n   unsigned int i;\n-  \n+\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n@@ -2486,28 +2891,45 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n   varray_type access_fns = DR_ACCESS_FNS (dr);\n   tree access_fn;\n   tree init, step;\n+  unsigned int dimensions, i;\n \n-  /* FORNOW: handle only one dimensional arrays.\n-     This restriction will be relaxed in the future.  */\n-  if (VARRAY_ACTIVE_SIZE (access_fns) != 1)\n+  /* Check that in case of multidimensional array ref A[i1][i2]..[iN],\n+     i1, i2, ..., iN-1 are loop invariant (to make sure that the memory\n+     access is contiguous).  */\n+  dimensions = VARRAY_ACTIVE_SIZE (access_fns);\n+\n+  for (i = 1; i < dimensions; i++) /* Not including the last dimension.  */\n     {\n-      if (vect_debug_details (NULL))\n-\tfprintf (dump_file, \"multi dimensional array reference.\");\n-      return false;\n-    }\n-  access_fn = DR_ACCESS_FN (dr, 0);\n+      access_fn = DR_ACCESS_FN (dr, i);\n \n-  if (!vect_is_simple_iv_evolution (loop_containing_stmt (DR_STMT (dr))->num, \n-\t\t\t\t    access_fn, &init, &step, true))\n+      if (evolution_part_in_loop_num (access_fn, \n+\t\t\t\t      loop_containing_stmt (DR_STMT (dr))->num))\n+\t{\n+\t  /* Evolution part is not NULL in this loop (it is neither constant nor \n+\t     invariant). */\n+\t  if (vect_debug_details (NULL))\n+\t    {\n+\t      fprintf (dump_file, \n+\t\t       \"not vectorized: complicated multidimensional array access.\");\n+\t      print_generic_expr (dump_file, access_fn, TDF_SLIM);\n+\t    }\n+\t  return false;\n+\t}\n+    }\n+  \n+  access_fn = DR_ACCESS_FN (dr, 0); /*  The last dimension access function.  */\n+  if (!evolution_function_is_constant_p (access_fn)\n+      && !vect_is_simple_iv_evolution (loop_containing_stmt (DR_STMT (dr))->num,\n+\t\t\t\t       access_fn, &init, &step, true))\n     {\n       if (vect_debug_details (NULL))\n \t{\n-\t  fprintf (dump_file, \"too complicated access function.\");\n+\t  fprintf (dump_file, \"not vectorized: too complicated access function.\");\n \t  print_generic_expr (dump_file, access_fn, TDF_SLIM);\n \t}\n       return false;\n     }\n-\n+  \n   return true;\n }\n \n@@ -2519,7 +2941,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n    FORNOW: the only access pattern that is considered vectorizable is a\n \t   simple step 1 (consecutive) access.\n \n-   FORNOW: handle only one dimensional arrays, and pointer accesses.  */\n+   FORNOW: handle only arrays and pointer accesses.  */\n \n static bool\n vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n@@ -2604,12 +3026,13 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n       return NULL;\n     }\n \t\t\n-  if (TREE_CODE (init) != SSA_NAME \t   /* FORNOW */\n-      || !host_integerp (step,0))\n+  STRIP_NOPS (init);\n+\n+  if (!host_integerp (step,0))\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop)) \n \tfprintf (dump_file, \n-\t\t\"not vectorized: non constant init/step for pointer access.\");\t\n+\t\t\"not vectorized: non constant step for pointer access.\");\t\n       return NULL;\n     }\n \n@@ -2653,11 +3076,150 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n }\n \n \n+/* Function vect_get_symbl_and_dr.  \n+\n+   The function returns SYMBL - the relevant variable for\n+   memory tag (for aliasing purposes). \n+   Also data reference structure DR is created.  \n+\n+   Input:\n+   MEMREF - data reference in STMT\n+   IS_READ - TRUE if STMT reads from MEMREF, FALSE if writes to MEMREF\n+   \n+   Output:\n+   DR - data_reference struct for MEMREF\n+   return value - the relevant variable for memory tag (for aliasing purposes).\n+\n+*/ \n+\n+static tree\n+vect_get_symbl_and_dr (tree memref, tree stmt, bool is_read, \n+\t\t       loop_vec_info loop_vinfo, struct data_reference **dr)\n+{\n+  tree symbl, oprnd0, oprnd1;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree offset;\n+  tree array_base, base;\n+  struct data_reference *new_dr;\n+  bool base_aligned_p;\n+\n+  *dr = NULL;\n+  switch (TREE_CODE (memref))\n+    {\n+    case INDIRECT_REF:\n+      new_dr = vect_analyze_pointer_ref_access (memref, stmt, is_read);\n+      if (! new_dr)\n+\treturn NULL_TREE; \n+      *dr = new_dr;\n+      symbl = DR_BASE_NAME (new_dr);\n+      STMT_VINFO_VECT_DR_BASE (stmt_info) = symbl;\n+\n+      switch (TREE_CODE (symbl))\n+\t{\n+\tcase PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\t  oprnd0 = TREE_OPERAND (symbl, 0);\n+\t  oprnd1 = TREE_OPERAND (symbl, 1);\n+\n+\t  STRIP_NOPS(oprnd1);\n+\t  /* Only {address_base + offset} expressions are supported,  \n+\t     where address_base can be POINTER_TYPE or ARRRAY_TYPE and \n+\t     offset can be anything but POINTER_TYPE or ARRAY_TYPE.  \n+\t     TODO: swap operands if {offset + address_base}.  */\n+\t  if ((TREE_CODE (TREE_TYPE (oprnd1)) == POINTER_TYPE \n+\t       && TREE_CODE (oprnd1) != INTEGER_CST)\n+\t      || TREE_CODE (TREE_TYPE (oprnd1)) == ARRAY_TYPE)\n+\t    return NULL_TREE;\n+\n+\t  if (TREE_CODE (TREE_TYPE (oprnd0)) == POINTER_TYPE)\n+\t    symbl = oprnd0;\n+\t  else\n+\t    symbl = vect_get_symbl_and_dr (oprnd0, stmt, is_read, \n+\t\t\t\t\t   loop_vinfo, &new_dr); \n+\n+\tcase SSA_NAME:\n+\tcase ADDR_EXPR:\n+\t  /* symbl remains unchanged.  */\n+\t  break;\n+\n+\tdefault:\n+\t  if (vect_debug_details (NULL))\n+\t    {\n+\t      fprintf (dump_file, \"unhandled data ref: \");\n+\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t      fprintf (dump_file, \" (symbl \");\n+\t      print_generic_expr (dump_file, symbl, TDF_SLIM);\n+\t      fprintf (dump_file, \") in stmt  \");\n+\t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t    }\n+\t  return NULL_TREE;\t\n+\t}\n+      break;\n+\n+    case ARRAY_REF:\n+      offset = size_zero_node;\n+      array_base = TREE_OPERAND (memref, 0);\n+\n+      /* Store the array base in the stmt info. \n+\t For one dimensional array ref a[i], the base is a,\n+\t for multidimensional a[i1][i2]..[iN], the base is \n+\t a[i1][i2]..[iN-1]. */\n+      array_base = TREE_OPERAND (memref, 0);\n+      STMT_VINFO_VECT_DR_BASE (stmt_info) = array_base;\t     \n+\n+      new_dr = analyze_array (stmt, memref, is_read);\n+      *dr = new_dr;\n+\n+      /* Find the relevant symbol for aliasing purposes.  */\t\n+      base = DR_BASE_NAME (new_dr);\n+      switch (TREE_CODE (base))\t\n+\t{\n+\tcase VAR_DECL:\n+\t  symbl = base;\n+\t  break;\n+\n+\tcase INDIRECT_REF:\n+\t  symbl = TREE_OPERAND (base, 0); \n+\t  break;\n+\n+\tcase COMPONENT_REF:\n+\t  /* Could have recorded more accurate information - \n+\t     i.e, the actual FIELD_DECL that is being referenced -\n+\t     but later passes expect VAR_DECL as the nmt.  */\t\n+\t  symbl = vect_get_base_and_bit_offset (new_dr, base, NULL_TREE, \n+\t\t\t\t\tloop_vinfo, &offset, &base_aligned_p);\n+\t  if (symbl)\n+\t    break;\n+\t  /* fall through */\t\n+\tdefault:\n+\t  if (vect_debug_details (NULL))\n+\t    {\n+\t      fprintf (dump_file, \"unhandled struct/class field access \");\n+\t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n+      break;\n+\n+    default:\n+      if (vect_debug_details (NULL))\n+\t{\n+\t  fprintf (dump_file, \"unhandled data ref: \");\n+\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t  fprintf (dump_file, \" in stmt  \");\n+\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t}\n+      return NULL_TREE;\n+    }\n+  return symbl;\n+}\n+\n+\n /* Function vect_analyze_data_refs.\n \n    Find all the data references in the loop.\n \n-   FORNOW: Handle aligned INDIRECT_REFs and one dimensional ARRAY_REFs \n+   FORNOW: Handle aligned INDIRECT_REFs and ARRAY_REFs \n \t   which base is really an array (not a pointer) and which alignment \n \t   can be forced. This restriction will be relaxed.   */\n \n@@ -2670,6 +3232,8 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n   block_stmt_iterator si;\n   int j;\n   struct data_reference *dr;\n+  tree tag;\n+  tree address_base;\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"\\n<<vect_analyze_data_refs>>\\n\");\n@@ -2688,7 +3252,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  varray_type *datarefs = NULL;\n \t  int nvuses, nv_may_defs, nv_must_defs;\n \t  tree memref = NULL;\n-\t  tree array_base;\n \t  tree symbl;\n \n \t  /* Assumption: there exists a data-ref in stmt, if and only if \n@@ -2734,80 +3297,28 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t      is_read = false;\n \t    }\n \n-\t  if (TREE_CODE (memref) == INDIRECT_REF)\n-            {\n-              dr = vect_analyze_pointer_ref_access (memref, stmt, is_read);\n-              if (! dr)\n-                return false; \n-\t      symbl = DR_BASE_NAME (dr);\t\n-            }\n-\t  else if (TREE_CODE (memref) == ARRAY_REF)\n-\t    {\n-\t      tree base;\n-\t      tree offset = size_zero_node;\t\n-\t      array_base = TREE_OPERAND (memref, 0);\n-   \n-              /* FORNOW: make sure that the array is one dimensional.\n-                 This restriction will be relaxed in the future.  */\n-              if (TREE_CODE (array_base) == ARRAY_REF)\n-                {\n-                  if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\t\t    {\n-                      fprintf (dump_file, \n-\t\t\t\t\"not vectorized: multi-dimensional array.\");\n-                      print_generic_expr (dump_file, stmt, TDF_SLIM);\n-\t\t    }\n-                  return false;\n-                }\n-\n-              dr = analyze_array (stmt, memref, is_read);\n-\n-\t      /* Find the relevant symbol for aliasing purposes.  */\t\n-\t      base = DR_BASE_NAME (dr);\n-\t      switch (TREE_CODE (base))\t\n-\t\t{\n-\t\tcase VAR_DECL:\n-\t\t  symbl = base;\n-\t\t  break;\n-\t\t/* FORNOW: Disabled.  \n-\t\tcase INDIRECT_REF:\n-\t\t  symbl = TREE_OPERAND (base, 0); \n-\t\t  break;\n-\t\t*/\n-\t\tcase COMPONENT_REF:\n-\t\t  /* CHECKME: could have recorded more accurate information - \n-\t\t     i.e, the actual FIELD_DECL that is being referenced -\n-\t\t     but later passes expect VAR_DECL as the nmt.  */\t\n-\t\t  symbl = vect_get_base_decl_and_bit_offset (base, &offset);\n-\t\t  if (symbl)\n-\t\t    break;\n-\t\t  /* fall through */\t\n-\t\tdefault:\n-                  if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\t\t    {\n-                      fprintf (dump_file,\n-                        \"not vectorized: unhandled struct/class field access \");\n-                      print_generic_expr (dump_file, stmt, TDF_SLIM);\n-\t\t    }\n-                  return false;\n-\t\t} /* switch */\n-\t    }\n-\t  else\n+\t  /* Analyze MEMREF. If it is of a supported form, build data_reference\n+\t     struct for it (DR) and find the relevant symbol for aliasing \n+\t     purposes.  */\n+\t  symbl = vect_get_symbl_and_dr (memref, stmt, is_read, loop_vinfo, &dr);\n+\t  if (!symbl)\n \t    {\n \t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n \t\t{\n-\t\t  fprintf (dump_file, \"not vectorized: unhandled data ref: \");\n+\t\t  fprintf (dump_file, \"not vectorized: unhandled data ref: \"); \n \t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n \t\t}\n \t      return false;\n \t    }\n-\t\n+\n \t  /* Find and record the memtag assigned to this data-ref.  */\n-\t  if (TREE_CODE (symbl) == VAR_DECL)\n-\t    STMT_VINFO_MEMTAG (stmt_info) = symbl;\n-\t  else if (TREE_CODE (symbl) == SSA_NAME)\n+\t   switch (TREE_CODE (symbl))\n \t    {\n-\t      tree tag;\n+\t    case VAR_DECL:\n+\t      STMT_VINFO_MEMTAG (stmt_info) = symbl;\n+\t      break;\n+\t      \n+\t    case SSA_NAME:\n \t      symbl = SSA_NAME_VAR (symbl);\n \t      tag = get_var_ann (symbl)->type_mem_tag;\n \t      if (!tag)\n@@ -2823,16 +3334,40 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t\t  return false;\n \t\t}\n \t      STMT_VINFO_MEMTAG (stmt_info) = tag;\n-\t    }\n-\t  else\n-\t    {\n+\t      break;\n+\n+\t    case ADDR_EXPR:\n+\t      address_base = TREE_OPERAND (symbl, 0);\n+\n+\t      switch (TREE_CODE (address_base))\n+\t\t{\n+\t\tcase ARRAY_REF:\n+\t\t  dr = analyze_array (stmt, TREE_OPERAND (symbl, 0), DR_IS_READ(dr));\n+\t\t  STMT_VINFO_MEMTAG (stmt_info) = DR_BASE_NAME (dr);\n+\t\t  break;\n+\t\t  \n+\t\tcase VAR_DECL: \n+\t\t  STMT_VINFO_MEMTAG (stmt_info) = address_base;\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"not vectorized: unhandled address expression: \");\n+\t\t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t\t    }\n+\t\t  return false;\n+\t\t}\n+\t      break;\n+\t      \n+\t    default:\n \t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n \t\t{\n \t\t  fprintf (dump_file, \"not vectorized: unsupported data-ref: \");\n \t\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n \t\t}\n \t      return false;\n-            }\n+\t    }\n \n \t  VARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n \t  STMT_VINFO_DATA_REF (stmt_info) = dr;\n@@ -3235,7 +3770,7 @@ vect_analyze_loop (struct loop *loop)\n   /* Find all data references in the loop (which correspond to vdefs/vuses)\n      and analyze their evolution in the loop.\n \n-     FORNOW: Handle only simple, one-dimensional, array references, which\n+     FORNOW: Handle only simple, array references, which\n      alignment can be forced, and aligned pointer-references.  */\n \n   ok = vect_analyze_data_refs (loop_vinfo);\n@@ -3247,7 +3782,6 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n-\n   /* Data-flow analysis to detect stmts that do not need to be vectorized.  */\n \n   ok = vect_mark_stmts_to_be_vectorized (loop_vinfo);\n@@ -3261,7 +3795,6 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n-\n   /* Check that all cross-iteration scalar data-flow cycles are OK.\n      Cross-iteration cycles caused by virtual phis are analyzed separately.  */\n \n@@ -3274,7 +3807,6 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n-\n   /* Analyze data dependences between the data-refs in the loop. \n      FORNOW: fail at the first data dependence that we encounter.  */\n \n@@ -3287,7 +3819,6 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n-\n   /* Analyze the access patterns of the data-refs in the loop (consecutive,\n      complex, etc.). FORNOW: Only handle consecutive access pattern.  */\n \n@@ -3300,7 +3831,6 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n-\n   /* Analyze the alignment of the data-refs in the loop.\n      FORNOW: Only aligned accesses are handled.  */\n \n@@ -3313,7 +3843,6 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n-\n   /* Scan all the operations in the loop and make sure they are\n      vectorizable.  */\n \n@@ -3400,14 +3929,15 @@ vectorize_loops (struct loops *loops)\n   for (i = 1; i < loops_num; i++)\n     {\n       struct loop *loop = loops->parray[i];\n-      loop_vec_info loop_vinfo = loop->aux;\n+      loop_vec_info loop_vinfo;\n+\n       if (!loop)\n-        continue;\n+\tcontinue;\n+      loop_vinfo = loop->aux;\n       destroy_loop_vec_info (loop_vinfo);\n       loop->aux = NULL;\n     }\n \n-  loop_commit_inserts (); \n   rewrite_into_ssa (false);\n   if (bitmap_first_set_bit (vars_to_rename) >= 0)\n     {"}, {"sha": "405ecb24df2dd3f0477a7cdaf02ed4156de2e262", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6775f1f3a749256c99544d13f7ea581edba6a585/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6775f1f3a749256c99544d13f7ea581edba6a585", "patch": "@@ -76,17 +76,27 @@ typedef struct _stmt_vec_info {\n \n   /* Aliasing information.  */\n   tree memtag;\n+\n+  /* Data reference base. This field holds the entire invariant part of the \n+     data-reference (with respect to the relevant loop), as opposed to the \n+     field DR_BASE of the STMT_VINFO_DATA_REF struct, which holds only the \n+     initial base; e.g:\n+     REF\tBR_BASE\t    VECT_DR_BASE\n+     a[i]\ta\t\ta\n+     a[i][j]\ta\t\ta[i]  */\n+  tree vect_dr_base;\n } *stmt_vec_info;\n \n /* Access Functions.  */\n-#define STMT_VINFO_TYPE(S)       (S)->type\n-#define STMT_VINFO_STMT(S)       (S)->stmt\n-#define STMT_VINFO_LOOP(S)       (S)->loop\n-#define STMT_VINFO_RELEVANT_P(S) (S)->relevant\n-#define STMT_VINFO_VECTYPE(S)    (S)->vectype\n-#define STMT_VINFO_VEC_STMT(S)   (S)->vectorized_stmt\n-#define STMT_VINFO_DATA_REF(S)   (S)->data_ref_info\n-#define STMT_VINFO_MEMTAG(S)     (S)->memtag\n+#define STMT_VINFO_TYPE(S)          (S)->type\n+#define STMT_VINFO_STMT(S)          (S)->stmt\n+#define STMT_VINFO_LOOP(S)          (S)->loop\n+#define STMT_VINFO_RELEVANT_P(S)    (S)->relevant\n+#define STMT_VINFO_VECTYPE(S)       (S)->vectype\n+#define STMT_VINFO_VEC_STMT(S)      (S)->vectorized_stmt\n+#define STMT_VINFO_DATA_REF(S)      (S)->data_ref_info\n+#define STMT_VINFO_MEMTAG(S)        (S)->memtag\n+#define STMT_VINFO_VECT_DR_BASE(S)  (S)->vect_dr_base\n \n static inline void set_stmt_info (stmt_ann_t ann, stmt_vec_info stmt_info);\n static inline stmt_vec_info vinfo_for_stmt (tree stmt);\n@@ -123,6 +133,9 @@ unknown_alignment_for_access_p (struct data_reference *data_ref_info)\n   return (DR_MISALIGNMENT (data_ref_info) == -1);\n }\n \n+/* Perform signed modulo, always returning a non-negative value.  */\n+#define VECT_SMODULO(x,y) ((x) % (y) < 0 ? ((x) % (y) + (y)) : (x) % (y))\n+\n \n /*-----------------------------------------------------------------*/\n /* Info on vectorized loops.                                       */"}]}