{"sha": "a531043b0e792bfecf869565220948de19c7c49d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUzMTA0M2IwZTc5MmJmZWNmODY5NTY1MjIwOTQ4ZGUxOWM3YzQ5ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-05-14T11:47:59Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-05-14T11:47:59Z"}, "message": "decl.c (elaborate_expression_1): Remove GNAT_EXPR parameter and move check for static expression to...\n\n\t* gcc-interface/decl.c (elaborate_expression_1): Remove GNAT_EXPR\n\tparameter and move check for static expression to...\n\t(elaborate_expression): ...here.  Adjust call to above function.\n\t(gnat_to_gnu_entity): Likewise for all calls.  Use correct arguments\n\tin calls to elaborate_expression.\n\t(elaborate_entity): Likewise.\n\t(substitution_list): Likewise.\n\t(maybe_variable): Fix formatting.\n\t(substitute_in_type) <REAL_TYPE>: Merge with INTEGER_TYPE case and add\n\tmissing guard.\n\t* gcc-interface/trans.c (protect_multiple_eval): Minor cleanup.\n\nFrom-SVN: r147530", "tree": {"sha": "a467f66a1e0d7395bb33f12af5d1faed7db4a281", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a467f66a1e0d7395bb33f12af5d1faed7db4a281"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a531043b0e792bfecf869565220948de19c7c49d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a531043b0e792bfecf869565220948de19c7c49d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a531043b0e792bfecf869565220948de19c7c49d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a531043b0e792bfecf869565220948de19c7c49d/comments", "author": null, "committer": null, "parents": [{"sha": "fe04903344e9e5d24c56dbd086e0bd66f1f1902c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe04903344e9e5d24c56dbd086e0bd66f1f1902c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe04903344e9e5d24c56dbd086e0bd66f1f1902c"}], "stats": {"total": 236, "additions": 111, "deletions": 125}, "files": [{"sha": "99806dda7fd8df39f00c902ceecb21a82ed3691a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a531043b0e792bfecf869565220948de19c7c49d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a531043b0e792bfecf869565220948de19c7c49d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a531043b0e792bfecf869565220948de19c7c49d", "patch": "@@ -1,3 +1,17 @@\n+2009-05-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (elaborate_expression_1): Remove GNAT_EXPR\n+\tparameter and move check for static expression to...\n+\t(elaborate_expression): ...here.  Adjust call to above function.\n+\t(gnat_to_gnu_entity): Likewise for all calls.  Use correct arguments\n+\tin calls to elaborate_expression.\n+\t(elaborate_entity): Likewise.\n+\t(substitution_list): Likewise.\n+\t(maybe_variable): Fix formatting.\n+\t(substitute_in_type) <REAL_TYPE>: Merge with INTEGER_TYPE case and add\n+\tmissing guard.\n+\t* gcc-interface/trans.c (protect_multiple_eval): Minor cleanup.\n+\n 2009-05-07  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update dependencies."}, {"sha": "6feadbdece0f5a4f174b68300601dbabfa8c3673", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 78, "deletions": 105, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a531043b0e792bfecf869565220948de19c7c49d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a531043b0e792bfecf869565220948de19c7c49d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=a531043b0e792bfecf869565220948de19c7c49d", "patch": "@@ -128,8 +128,7 @@ static void prepend_one_attribute_to (struct attrib **,\n static void prepend_attributes (Entity_Id, struct attrib **);\n static tree elaborate_expression (Node_Id, Entity_Id, tree, bool, bool, bool);\n static bool is_variable_size (tree);\n-static tree elaborate_expression_1 (Node_Id, Entity_Id, tree, tree,\n-\t\t\t\t    bool, bool);\n+static tree elaborate_expression_1 (tree, Entity_Id, tree, bool, bool);\n static tree make_packable_type (tree, bool);\n static tree gnat_to_gnu_field (Entity_Id, tree, int, bool);\n static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n@@ -1563,15 +1562,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       TYPE_MIN_VALUE (gnu_type)\n \t= convert (TREE_TYPE (gnu_type),\n \t\t   elaborate_expression (Type_Low_Bound (gnat_entity),\n-\t\t\t\t\t gnat_entity,\n-\t\t\t\t\t get_identifier (\"L\"), definition, 1,\n+\t\t\t\t\t gnat_entity, get_identifier (\"L\"),\n+\t\t\t\t\t definition, true,\n \t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n \n       TYPE_MAX_VALUE (gnu_type)\n \t= convert (TREE_TYPE (gnu_type),\n \t\t   elaborate_expression (Type_High_Bound (gnat_entity),\n-\t\t\t\t\t gnat_entity,\n-\t\t\t\t\t get_identifier (\"U\"), definition, 1,\n+\t\t\t\t\t gnat_entity, get_identifier (\"U\"),\n+\t\t\t\t\t definition, true,\n \t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n \n       /* One of the above calls might have caused us to be elaborated,\n@@ -1747,14 +1746,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  = convert (TREE_TYPE (gnu_type),\n \t\t     elaborate_expression (Type_Low_Bound (gnat_entity),\n \t\t\t\t\t   gnat_entity, get_identifier (\"L\"),\n-\t\t\t\t\t   definition, 1,\n+\t\t\t\t\t   definition, true,\n \t\t\t\t\t   Needs_Debug_Info (gnat_entity)));\n \n \tTYPE_MAX_VALUE (gnu_type)\n \t  = convert (TREE_TYPE (gnu_type),\n \t\t     elaborate_expression (Type_High_Bound (gnat_entity),\n \t\t\t\t\t   gnat_entity, get_identifier (\"U\"),\n-\t\t\t\t\t   definition, 1,\n+\t\t\t\t\t   definition, true,\n \t\t\t\t\t   Needs_Debug_Info (gnat_entity)));\n \n \t/* One of the above calls might have caused us to be elaborated,\n@@ -2434,9 +2433,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  tree eltype = TREE_TYPE (gnu_arr_type);\n \n \t\t  TYPE_SIZE (gnu_arr_type)\n-\t\t    = elaborate_expression_1 (gnat_entity, gnat_entity,\n-\t\t\t\t\t      TYPE_SIZE (gnu_arr_type),\n-\t\t\t\t\t      gnu_str_name, definition, 0);\n+\t\t    = elaborate_expression_1 (TYPE_SIZE (gnu_arr_type),\n+\t\t\t\t\t      gnat_entity, gnu_str_name,\n+\t\t\t\t\t      definition, false);\n \n \t\t  /* ??? For now, store the size as a multiple of the\n \t\t     alignment of the element type in bytes so that we\n@@ -2445,12 +2444,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    = build_binary_op\n \t\t      (MULT_EXPR, sizetype,\n \t\t       elaborate_expression_1\n-\t\t       (gnat_entity, gnat_entity,\n-\t\t\tbuild_binary_op (EXACT_DIV_EXPR, sizetype,\n+\t\t       (build_binary_op (EXACT_DIV_EXPR, sizetype,\n \t\t\t\t\t TYPE_SIZE_UNIT (gnu_arr_type),\n \t\t\t\t\t size_int (TYPE_ALIGN (eltype)\n \t\t\t\t\t\t   / BITS_PER_UNIT)),\n-\t\t\tconcat_name (gnu_str_name, \"A_U\"), definition, 0),\n+\t\t\tgnat_entity, concat_name (gnu_str_name, \"A_U\"),\n+\t\t\tdefinition, false),\n \t\t       size_int (TYPE_ALIGN (eltype) / BITS_PER_UNIT));\n \n \t\t  /* ??? create_type_decl is not invoked on the inner types so\n@@ -4515,43 +4514,39 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t  TYPE_SIZE (gnu_type), 0))\n \t    {\n \t      TYPE_SIZE (gnu_type)\n-\t\t= elaborate_expression_1 (gnat_entity, gnat_entity,\n-\t\t\t\t\t  TYPE_SIZE (gnu_type),\n-\t\t\t\t\t  get_identifier (\"SIZE\"),\n-\t\t\t\t\t  definition, 0);\n+\t\t= elaborate_expression_1 (TYPE_SIZE (gnu_type),\n+\t\t\t\t\t  gnat_entity, get_identifier (\"SIZE\"),\n+\t\t\t\t\t  definition, false);\n \t      SET_TYPE_ADA_SIZE (gnu_type, TYPE_SIZE (gnu_type));\n \t    }\n \t  else\n \t    {\n \t      TYPE_SIZE (gnu_type)\n-\t\t= elaborate_expression_1 (gnat_entity, gnat_entity,\n-\t\t\t\t\t  TYPE_SIZE (gnu_type),\n-\t\t\t\t\t  get_identifier (\"SIZE\"),\n-\t\t\t\t\t  definition, 0);\n+\t\t= elaborate_expression_1 (TYPE_SIZE (gnu_type),\n+\t\t\t\t\t  gnat_entity, get_identifier (\"SIZE\"),\n+\t\t\t\t\t  definition, false);\n \n \t      /* ??? For now, store the size as a multiple of the alignment\n \t\t in bytes so that we can see the alignment from the tree.  */\n \t      TYPE_SIZE_UNIT (gnu_type)\n \t\t= build_binary_op\n \t\t  (MULT_EXPR, sizetype,\n \t\t   elaborate_expression_1\n-\t\t   (gnat_entity, gnat_entity,\n-\t\t    build_binary_op (EXACT_DIV_EXPR, sizetype,\n+\t\t   (build_binary_op (EXACT_DIV_EXPR, sizetype,\n \t\t\t\t     TYPE_SIZE_UNIT (gnu_type),\n \t\t\t\t     size_int (TYPE_ALIGN (gnu_type)\n \t\t\t\t\t       / BITS_PER_UNIT)),\n-\t\t    get_identifier (\"SIZE_A_UNIT\"),\n-\t\t    definition, 0),\n+\t\t    gnat_entity, get_identifier (\"SIZE_A_UNIT\"),\n+\t\t    definition, false),\n \t\t   size_int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT));\n \n \t      if (TREE_CODE (gnu_type) == RECORD_TYPE)\n \t\tSET_TYPE_ADA_SIZE\n \t\t  (gnu_type,\n-\t\t   elaborate_expression_1 (gnat_entity,\n+\t\t   elaborate_expression_1 (TYPE_ADA_SIZE (gnu_type),\n \t\t\t\t\t   gnat_entity,\n-\t\t\t\t\t   TYPE_ADA_SIZE (gnu_type),\n \t\t\t\t\t   get_identifier (\"RM_SIZE\"),\n-\t\t\t\t\t   definition, 0));\n+\t\t\t\t\t   definition, false));\n \t\t }\n \t}\n \n@@ -4577,13 +4572,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  = build_binary_op\n \t\t    (MULT_EXPR, sizetype,\n \t\t     elaborate_expression_1\n-\t\t     (gnat_temp, gnat_temp,\n-\t\t      build_binary_op (EXACT_DIV_EXPR, sizetype,\n+\t\t     (build_binary_op (EXACT_DIV_EXPR, sizetype,\n \t\t\t\t       DECL_FIELD_OFFSET (gnu_field),\n \t\t\t\t       size_int (DECL_OFFSET_ALIGN (gnu_field)\n \t\t\t\t\t\t / BITS_PER_UNIT)),\n-\t\t      get_identifier (\"OFFSET\"),\n-\t\t      definition, 0),\n+\t\t      gnat_temp, get_identifier (\"OFFSET\"),\n+\t\t      definition, false),\n \t\t     size_int (DECL_OFFSET_ALIGN (gnu_field) / BITS_PER_UNIT));\n \n \t\t/* ??? The context of gnu_field is not necessarily gnu_type so\n@@ -5265,10 +5259,10 @@ elaborate_entity (Entity_Id gnat_entity)\n \t   conversions on bounds of real types.  */\n \tif (!Raises_Constraint_Error (gnat_lb))\n \t  elaborate_expression (gnat_lb, gnat_entity, get_identifier (\"L\"),\n-\t\t\t\t1, 0, Needs_Debug_Info (gnat_entity));\n+\t\t\t\ttrue, false, Needs_Debug_Info (gnat_entity));\n \tif (!Raises_Constraint_Error (gnat_hb))\n \t  elaborate_expression (gnat_hb, gnat_entity, get_identifier (\"U\"),\n-\t\t\t\t1, 0, Needs_Debug_Info (gnat_entity));\n+\t\t\t\ttrue, false, Needs_Debug_Info (gnat_entity));\n       break;\n       }\n \n@@ -5304,8 +5298,8 @@ elaborate_entity (Entity_Id gnat_entity)\n \t    /* ??? For now, ignore access discriminants.  */\n \t    if (!Is_Access_Type (Etype (Node (gnat_discriminant_expr))))\n \t      elaborate_expression (Node (gnat_discriminant_expr),\n-\t\t\t\t    gnat_entity,\n-\t\t\t\t    get_entity_name (gnat_field), 1, 0, 0);\n+\t\t\t\t    gnat_entity, get_entity_name (gnat_field),\n+\t\t\t\t    true, false, false);\n \t}\n       break;\n \n@@ -5457,7 +5451,7 @@ substitution_list (Entity_Id gnat_subtype, Entity_Id gnat_type,\n \t\t\t      elaborate_expression\n \t\t\t      (Node (gnat_value), gnat_subtype,\n \t\t\t       get_entity_name (gnat_discrim), definition,\n-\t\t\t       1, 0),\n+\t\t\t       true, false),\n \t\t\t      gnu_list);\n \n   return gnu_list;\n@@ -5591,63 +5585,66 @@ prepend_attributes (Entity_Id gnat_entity, struct attrib ** attr_list)\n       }\n }\n \f\n-/* Called when we need to protect a variable object using a save_expr.  */\n+/* Called when we need to protect a variable object using a SAVE_EXPR.  */\n \n tree\n maybe_variable (tree gnu_operand)\n {\n-  if (TREE_CONSTANT (gnu_operand) || TREE_READONLY (gnu_operand)\n+  if (TREE_CONSTANT (gnu_operand)\n+      || TREE_READONLY (gnu_operand)\n       || TREE_CODE (gnu_operand) == SAVE_EXPR\n       || TREE_CODE (gnu_operand) == NULL_EXPR)\n     return gnu_operand;\n \n   if (TREE_CODE (gnu_operand) == UNCONSTRAINED_ARRAY_REF)\n     {\n-      tree gnu_result = build1 (UNCONSTRAINED_ARRAY_REF,\n-\t\t\t\tTREE_TYPE (gnu_operand),\n-\t\t\t\tvariable_size (TREE_OPERAND (gnu_operand, 0)));\n+      tree gnu_result\n+\t= build1 (UNCONSTRAINED_ARRAY_REF, TREE_TYPE (gnu_operand),\n+\t\t  variable_size (TREE_OPERAND (gnu_operand, 0)));\n \n       TREE_READONLY (gnu_result) = TREE_STATIC (gnu_result)\n \t= TYPE_READONLY (TREE_TYPE (TREE_TYPE (gnu_operand)));\n       return gnu_result;\n     }\n-  else\n-    return variable_size (gnu_operand);\n+\n+  return variable_size (gnu_operand);\n }\n \f\n /* Given a GNAT tree GNAT_EXPR, for an expression which is a value within a\n    type definition (either a bound or a discriminant value) for GNAT_ENTITY,\n-   return the GCC tree to use for that expression.  GNU_NAME is the\n-   qualification to use if an external name is appropriate and DEFINITION is\n-   true if this is a definition of GNAT_ENTITY.  If NEED_VALUE is true, we\n-   need a result.  Otherwise, we are just elaborating this for side-effects.\n-   If NEED_DEBUG is true we need the symbol for debugging purposes even if it\n+   return the GCC tree to use for that expression.  GNU_NAME is the suffix\n+   to use if a variable needs to be created and DEFINITION is true if this\n+   is a definition of GNAT_ENTITY.  If NEED_VALUE is true, we need a result;\n+   otherwise, we are just elaborating the expression for side-effects.  If\n+   NEED_DEBUG is true, we need a variable for debugging purposes even if it\n    isn't needed for code generation.  */\n \n static tree\n-elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity,\n-\t\t      tree gnu_name, bool definition, bool need_value,\n-\t\t      bool need_debug)\n+elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity, tree gnu_name,\n+\t\t      bool definition, bool need_value, bool need_debug)\n {\n   tree gnu_expr;\n \n-  /* If we already elaborated this expression (e.g., it was involved\n+  /* If we already elaborated this expression (e.g. it was involved\n      in the definition of a private type), use the old value.  */\n   if (present_gnu_tree (gnat_expr))\n     return get_gnu_tree (gnat_expr);\n \n-  /* If we don't need a value and this is static or a discriminant, we\n-     don't need to do anything.  */\n-  else if (!need_value\n-\t   && (Is_OK_Static_Expression (gnat_expr)\n-\t       || (Nkind (gnat_expr) == N_Identifier\n-\t\t   && Ekind (Entity (gnat_expr)) == E_Discriminant)))\n-    return 0;\n+  /* If we don't need a value and this is static or a discriminant,\n+     we don't need to do anything.  */\n+  if (!need_value\n+      && (Is_OK_Static_Expression (gnat_expr)\n+\t  || (Nkind (gnat_expr) == N_Identifier\n+\t      && Ekind (Entity (gnat_expr)) == E_Discriminant)))\n+    return NULL_TREE;\n+\n+  /* If it's a static expression, we don't need a variable for debugging.  */\n+  if (need_debug && Is_OK_Static_Expression (gnat_expr))\n+    need_debug = false;\n \n-  /* Otherwise, convert this tree to its GCC equivalent.  */\n-  gnu_expr\n-    = elaborate_expression_1 (gnat_expr, gnat_entity, gnat_to_gnu (gnat_expr),\n-\t\t\t      gnu_name, definition, need_debug);\n+  /* Otherwise, convert this tree to its GCC equivalent and elaborate it.  */\n+  gnu_expr = elaborate_expression_1 (gnat_to_gnu (gnat_expr), gnat_entity,\n+\t\t\t\t     gnu_name, definition, need_debug);\n \n   /* Save the expression in case we try to elaborate this entity again.  Since\n      it's not a DECL, don't check it.  Don't save if it's a discriminant.  */\n@@ -5657,29 +5654,27 @@ elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity,\n   return need_value ? gnu_expr : error_mark_node;\n }\n \n-/* Similar, but take a GNU expression.  */\n+/* Similar, but take a GNU expression and always return a result.  */\n \n static tree\n-elaborate_expression_1 (Node_Id gnat_expr, Entity_Id gnat_entity,\n-\t\t\ttree gnu_expr, tree gnu_name, bool definition,\n-\t\t\tbool need_debug)\n+elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n+\t\t\tbool definition, bool need_debug)\n {\n-  tree gnu_decl = NULL_TREE;\n   /* Skip any conversions and simple arithmetics to see if the expression\n      is a read-only variable.\n      ??? This really should remain read-only, but we have to think about\n      the typing of the tree here.  */\n   tree gnu_inner_expr\n     = skip_simple_arithmetic (remove_conversions (gnu_expr, true));\n+  tree gnu_decl = NULL_TREE;\n   bool expr_global = Is_Public (gnat_entity) || global_bindings_p ();\n   bool expr_variable;\n \n-  /* In most cases, we won't see a naked FIELD_DECL here because a\n-     discriminant reference will have been replaced with a COMPONENT_REF\n-     when the type is being elaborated.  However, there are some cases\n-     involving child types where we will.  So convert it to a COMPONENT_REF\n-     here.  We have to hope it will be at the highest level of the\n-     expression in these cases.  */\n+  /* In most cases, we won't see a naked FIELD_DECL because a discriminant\n+     reference will have been replaced with a COMPONENT_REF when the type\n+     is being elaborated.  However, there are some cases involving child\n+     types where we will.  So convert it to a COMPONENT_REF.  We hope it\n+     will be at the highest level of the expression in these cases.  */\n   if (TREE_CODE (gnu_expr) == FIELD_DECL)\n     gnu_expr = build3 (COMPONENT_REF, TREE_TYPE (gnu_expr),\n \t\t       build0 (PLACEHOLDER_EXPR, DECL_CONTEXT (gnu_expr)),\n@@ -5693,19 +5688,14 @@ elaborate_expression_1 (Node_Id gnat_expr, Entity_Id gnat_entity,\n      by the variable; otherwise use a SAVE_EXPR if needed.  Note that we\n      rely here on the fact that an expression cannot contain both the\n      discriminant and some other variable.  */\n-\n   expr_variable = (!CONSTANT_CLASS_P (gnu_expr)\n \t\t   && !(TREE_CODE (gnu_inner_expr) == VAR_DECL\n \t\t\t&& (TREE_READONLY (gnu_inner_expr)\n \t\t\t    || DECL_READONLY_ONCE_ELAB (gnu_inner_expr)))\n \t\t   && !CONTAINS_PLACEHOLDER_P (gnu_expr));\n \n-  /* If this is a static expression or contains a discriminant, we don't\n-     need the variable for debugging (and can't elaborate anyway if a\n-     discriminant).  */\n-  if (need_debug\n-      && (Is_OK_Static_Expression (gnat_expr)\n-\t  || CONTAINS_PLACEHOLDER_P (gnu_expr)))\n+  /* If GNU_EXPR contains a discriminant, we can't elaborate a variable.  */\n+  if (need_debug && CONTAINS_PLACEHOLDER_P (gnu_expr))\n     need_debug = false;\n \n   /* Now create the variable if we need it.  */\n@@ -5721,10 +5711,8 @@ elaborate_expression_1 (Node_Id gnat_expr, Entity_Id gnat_entity,\n      can do the right thing in the local case.  */\n   if (expr_global && expr_variable)\n     return gnu_decl;\n-  else if (!expr_variable)\n-    return gnu_expr;\n-  else\n-    return maybe_variable (gnu_expr);\n+\n+  return expr_variable ? maybe_variable (gnu_expr) : gnu_expr;\n }\n \f\n /* Create a record type that contains a SIZE bytes long field of TYPE with a\n@@ -7714,6 +7702,7 @@ substitute_in_type (tree t, tree f, tree r)\n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n+    case REAL_TYPE:\n       if (CONTAINS_PLACEHOLDER_P (TYPE_MIN_VALUE (t))\n \t  || CONTAINS_PLACEHOLDER_P (TYPE_MAX_VALUE (t)))\n \t{\n@@ -7726,27 +7715,11 @@ substitute_in_type (tree t, tree f, tree r)\n \t  new = copy_type (t);\n \t  TYPE_MIN_VALUE (new) = low;\n \t  TYPE_MAX_VALUE (new) = high;\n-\t  if (TYPE_INDEX_TYPE (t))\n+\n+\t  if (TREE_CODE (t) == INTEGER_TYPE && TYPE_INDEX_TYPE (t))\n \t    SET_TYPE_INDEX_TYPE\n \t      (new, substitute_in_type (TYPE_INDEX_TYPE (t), f, r));\n-\t  return new;\n-\t}\n-\n-      return t;\n-\n-    case REAL_TYPE:\n-      if (CONTAINS_PLACEHOLDER_P (TYPE_MIN_VALUE (t))\n-\t  || CONTAINS_PLACEHOLDER_P (TYPE_MAX_VALUE (t)))\n-\t{\n-\t  tree low = SUBSTITUTE_IN_EXPR (TYPE_MIN_VALUE (t), f, r);\n-\t  tree high = SUBSTITUTE_IN_EXPR (TYPE_MAX_VALUE (t), f, r);\n-\n-\t  if (low == TYPE_MIN_VALUE (t) && high == TYPE_MAX_VALUE (t))\n-\t    return t;\n \n-\t  new = copy_type (t);\n-\t  TYPE_MIN_VALUE (new) = low;\n-\t  TYPE_MAX_VALUE (new) = high;\n \t  return new;\n \t}\n "}, {"sha": "ee65c81503ad5a4ffa5d251ffd9b0dd0b4540a58", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a531043b0e792bfecf869565220948de19c7c49d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a531043b0e792bfecf869565220948de19c7c49d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=a531043b0e792bfecf869565220948de19c7c49d", "patch": "@@ -7246,30 +7246,29 @@ protect_multiple_eval (tree exp)\n   if (!TREE_SIDE_EFFECTS (exp))\n     return exp;\n \n-  /* If it is a conversion, protect what's inside the conversion.\n+  /* If this is a conversion, protect what's inside the conversion.\n      Similarly, if we're indirectly referencing something, we only\n-     actually need to protect the address since the data itself can't\n-     change in these situations.  */\n-  else if (TREE_CODE (exp) == NON_LVALUE_EXPR\n-\t   || CONVERT_EXPR_P (exp)\n-\t   || TREE_CODE (exp) == VIEW_CONVERT_EXPR\n-\t   || TREE_CODE (exp) == INDIRECT_REF\n-\t   || TREE_CODE (exp) == UNCONSTRAINED_ARRAY_REF)\n-    return build1 (TREE_CODE (exp), type,\n-\t\t   protect_multiple_eval (TREE_OPERAND (exp, 0)));\n-\n-  /* If EXP is a fat pointer or something that can be placed into a register,\n-     just make a SAVE_EXPR.  */\n+     need to protect the address since the data itself can't change\n+     in these situations.  */\n+  if (TREE_CODE (exp) == NON_LVALUE_EXPR\n+      || CONVERT_EXPR_P (exp)\n+      || TREE_CODE (exp) == VIEW_CONVERT_EXPR\n+      || TREE_CODE (exp) == INDIRECT_REF\n+      || TREE_CODE (exp) == UNCONSTRAINED_ARRAY_REF)\n+  return build1 (TREE_CODE (exp), type,\n+\t\t protect_multiple_eval (TREE_OPERAND (exp, 0)));\n+\n+  /* If this is a fat pointer or something that can be placed into a\n+     register, just make a SAVE_EXPR.  */\n   if (TYPE_FAT_POINTER_P (type) || TYPE_MODE (type) != BLKmode)\n     return save_expr (exp);\n \n-  /* Otherwise, dereference, protect the address, and re-reference.  */\n-  else\n-    return\n-      build_unary_op (INDIRECT_REF, type,\n-\t\t      save_expr (build_unary_op (ADDR_EXPR,\n-\t\t\t\t\t\t build_reference_type (type),\n-\t\t\t\t\t\t exp)));\n+  /* Otherwise, reference, protect the address and dereference.  */\n+  return\n+    build_unary_op (INDIRECT_REF, type,\n+\t\t    save_expr (build_unary_op (ADDR_EXPR,\n+\t\t\t\t\t       build_reference_type (type),\n+\t\t\t\t\t       exp)));\n }\n \f\n /* This is equivalent to stabilize_reference in tree.c, but we know how to"}]}