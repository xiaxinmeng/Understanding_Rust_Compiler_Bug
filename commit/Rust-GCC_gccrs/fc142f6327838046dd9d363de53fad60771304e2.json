{"sha": "fc142f6327838046dd9d363de53fad60771304e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMxNDJmNjMyNzgzODA0NmRkOWQzNjNkZTUzZmFkNjA3NzEzMDRlMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T10:45:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T10:45:11Z"}, "message": "[multiple changes]\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* atree.h: Add declarations for Flag255-Flag289 Fix declaration\n\tof Field30 (was wrong, but no effect, since not yet referenced by\n\tback end) Add declarations for Field31-Field35 Add declarations\n\tfor Node31-Node35.\n\t* einfo.ads, einfo.adb (Has_Invariants): No longer applies to\n\tprocedures.\n\t(Has_Predicates): No longer applies to functions.\n\t(Is_Predicate_Function): New flag.\n\t(Is_Predicate_Function_M): New flag.\n\t(Is_Invariant_Procedure): New flag.\n\t(Predicate_Function_M): New function.\n\t(Set_Predicate_Function_M): New procedure.\n\t* exp_ch11.adb (Expand_N_Raise_Expression): Take care of special\n\tcase of appearing in predicate used for membership test.\n\t* exp_ch3.adb (Insert_Component_Invariant_Checks): Set\n\tIs_Invariant_Procedure flag.\n\t* exp_ch4.adb (Expand_Op_In): Call special predicate function\n\tthat takes care of raise_expression nodes in the predicate.\n\t* exp_util.ads, exp_util.adb (Make_Predicate_Call): Add argument Mem for\n\tmembership case.\n\t* sem_ch13.adb (Build_Predicate_Functions): New name for\n\tBuild_Predicate_Function.  Major rewrite to take care of raise\n\texpression in predicate for membership tests.\n\t* sem_res.adb (Resolve_Actuals): Include both predicate functions\n\tin defense against infinite predicate function loops.\n\t* sinfo.ads, sinfo.adb (Convert_To_Return_False): New flag.\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb: Minor reformatting.\n\n2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* lib-xref.adb: Generate reference for component of anonymous\n\taccess type.\n\nFrom-SVN: r197766", "tree": {"sha": "a14bcd806f8dac2b6a1d64d38ad4c14ed7f2547b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a14bcd806f8dac2b6a1d64d38ad4c14ed7f2547b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc142f6327838046dd9d363de53fad60771304e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc142f6327838046dd9d363de53fad60771304e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc142f6327838046dd9d363de53fad60771304e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc142f6327838046dd9d363de53fad60771304e2/comments", "author": null, "committer": null, "parents": [{"sha": "2602b64e3a4072c8819cad2f3abffe2d5ae69de3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2602b64e3a4072c8819cad2f3abffe2d5ae69de3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2602b64e3a4072c8819cad2f3abffe2d5ae69de3"}], "stats": {"total": 818, "additions": 650, "deletions": 168}, "files": [{"sha": "d93f15c89dd397f6e27cde52a545814d8ec83d7d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -1,3 +1,41 @@\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* atree.h: Add declarations for Flag255-Flag289 Fix declaration\n+\tof Field30 (was wrong, but no effect, since not yet referenced by\n+\tback end) Add declarations for Field31-Field35 Add declarations\n+\tfor Node31-Node35.\n+\t* einfo.ads, einfo.adb (Has_Invariants): No longer applies to\n+\tprocedures.\n+\t(Has_Predicates): No longer applies to functions.\n+\t(Is_Predicate_Function): New flag.\n+\t(Is_Predicate_Function_M): New flag.\n+\t(Is_Invariant_Procedure): New flag.\n+\t(Predicate_Function_M): New function.\n+\t(Set_Predicate_Function_M): New procedure.\n+\t* exp_ch11.adb (Expand_N_Raise_Expression): Take care of special\n+\tcase of appearing in predicate used for membership test.\n+\t* exp_ch3.adb (Insert_Component_Invariant_Checks): Set\n+\tIs_Invariant_Procedure flag.\n+\t* exp_ch4.adb (Expand_Op_In): Call special predicate function\n+\tthat takes care of raise_expression nodes in the predicate.\n+\t* exp_util.ads, exp_util.adb (Make_Predicate_Call): Add argument Mem for\n+\tmembership case.\n+\t* sem_ch13.adb (Build_Predicate_Functions): New name for\n+\tBuild_Predicate_Function.  Major rewrite to take care of raise\n+\texpression in predicate for membership tests.\n+\t* sem_res.adb (Resolve_Actuals): Include both predicate functions\n+\tin defense against infinite predicate function loops.\n+\t* sinfo.ads, sinfo.adb (Convert_To_Return_False): New flag.\n+\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb: Minor reformatting.\n+\n+2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* lib-xref.adb: Generate reference for component of anonymous\n+\taccess type.\n+\n 2013-04-11  Robert Dewar  <dewar@adacore.com>\n \n \t* stand.ads: Minor reformatting."}, {"sha": "c9fd5e0481b1f94f84ecd5873357bbf5afe1c5f2", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -259,6 +259,45 @@ struct Flag_Word4\n   Boolean      flag215\t    :  1;\n };\n \n+/* Structure used for extra flags in sixth component overlaying Field12 */\n+struct Flag_Word5\n+{\n+  Boolean      flag255\t    :  1;\n+  Boolean      flag256\t    :  1;\n+  Boolean      flag257\t    :  1;\n+  Boolean      flag258\t    :  1;\n+  Boolean      flag259\t    :  1;\n+  Boolean      flag260\t    :  1;\n+  Boolean      flag261\t    :  1;\n+  Boolean      flag262\t    :  1;\n+\n+  Boolean      flag263\t    :  1;\n+  Boolean      flag264\t    :  1;\n+  Boolean      flag265\t    :  1;\n+  Boolean      flag266\t    :  1;\n+  Boolean      flag267\t    :  1;\n+  Boolean      flag268\t    :  1;\n+  Boolean      flag269\t    :  1;\n+  Boolean      flag270\t    :  1;\n+\n+  Boolean      flag271\t    :  1;\n+  Boolean      flag272\t    :  1;\n+  Boolean      flag273\t    :  1;\n+  Boolean      flag274\t    :  1;\n+  Boolean      flag275\t    :  1;\n+  Boolean      flag276\t    :  1;\n+  Boolean      flag277\t    :  1;\n+  Boolean      flag278\t    :  1;\n+\n+  Boolean      flag279      :  1;\n+  Boolean      flag280\t    :  1;\n+  Boolean      flag281\t    :  1;\n+  Boolean      flag282\t    :  1;\n+  Boolean      flag283\t    :  1;\n+  Boolean      flag284\t    :  1;\n+  Boolean      flag285\t    :  1;\n+  Boolean      flag286\t    :  1;\n+};\n struct Non_Extended\n {\n   Source_Ptr   sloc;\n@@ -290,6 +329,7 @@ struct Extended\n       struct   Flag_Word fw;\n       struct   Flag_Word2 fw2;\n       struct   Flag_Word4 fw4;\n+      struct   Flag_Word5 fw5;\n     } U;\n };\n \n@@ -387,7 +427,12 @@ extern Node_Id Current_Error_Node;\n #define Field27(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field9)\n #define Field28(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field10)\n #define Field29(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.field11)\n-#define Field30(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field6)\n+#define Field30(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field6)\n+#define Field31(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field7)\n+#define Field32(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field8)\n+#define Field33(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field9)\n+#define Field34(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field10)\n+#define Field35(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.X.field11)\n \n #define Node1(N)      Field1  (N)\n #define Node2(N)      Field2  (N)\n@@ -419,6 +464,12 @@ extern Node_Id Current_Error_Node;\n #define Node28(N)     Field28 (N)\n #define Node29(N)     Field29 (N)\n #define Node30(N)     Field30 (N)\n+#define Node31(N)     Field31 (N)\n+#define Node32(N)     Field32 (N)\n+#define Node33(N)     Field33 (N)\n+#define Node34(N)     Field34 (N)\n+#define Node35(N)     Field35 (N)\n+#define Node36(N)     Field36 (N)\n \n #define List1(N)      Field1  (N)\n #define List2(N)      Field2  (N)\n@@ -742,6 +793,39 @@ extern Node_Id Current_Error_Node;\n #define Flag253(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.NK.flag71)\n #define Flag254(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.NK.flag72)\n \n+#define Flag255(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag255)\n+#define Flag256(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag256)\n+#define Flag257(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag257)\n+#define Flag258(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag258)\n+#define Flag259(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag259)\n+#define Flag260(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag260)\n+#define Flag261(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag261)\n+#define Flag262(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag262)\n+#define Flag263(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag263)\n+#define Flag264(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag264)\n+#define Flag265(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag265)\n+#define Flag266(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag266)\n+#define Flag267(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag267)\n+#define Flag268(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag268)\n+#define Flag269(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag269)\n+#define Flag270(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag270)\n+#define Flag271(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag271)\n+#define Flag272(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag272)\n+#define Flag273(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag273)\n+#define Flag274(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag274)\n+#define Flag275(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag275)\n+#define Flag276(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag276)\n+#define Flag277(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag277)\n+#define Flag278(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag278)\n+#define Flag279(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag279)\n+#define Flag280(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag280)\n+#define Flag281(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag281)\n+#define Flag282(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag282)\n+#define Flag283(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag283)\n+#define Flag284(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag284)\n+#define Flag285(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag285)\n+#define Flag286(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag286)\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "b81a1c69b0678ffb3dc8eb8258880904399e4c7e", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 106, "deletions": 47, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -542,10 +542,10 @@ package body Einfo is\n    --    Is_Processed_Transient          Flag252\n    --    Has_Anonymous_Master            Flag253\n    --    Is_Implementation_Defined       Flag254\n+   --    Is_Predicate_Function           Flag255\n+   --    Is_Predicate_Function_M         Flag256\n+   --    Is_Invariant_Procedure          Flag257\n \n-   --    (unused)                        Flag255\n-   --    (unused)                        Flag256\n-   --    (unused)                        Flag257\n    --    (unused)                        Flag258\n    --    (unused)                        Flag259\n    --    (unused)                        Flag260\n@@ -578,40 +578,8 @@ package body Einfo is\n    --    (unused)                        Flag284\n    --    (unused)                        Flag285\n    --    (unused)                        Flag286\n-   --    (unused)                        Flag287\n-   --    (unused)                        Flag288\n-   --    (unused)                        Flag289\n-   --    (unused)                        Flag290\n-\n-   --    (unused)                        Flag291\n-   --    (unused)                        Flag292\n-   --    (unused)                        Flag293\n-   --    (unused)                        Flag294\n-   --    (unused)                        Flag295\n-   --    (unused)                        Flag296\n-   --    (unused)                        Flag297\n-   --    (unused)                        Flag298\n-   --    (unused)                        Flag299\n-   --    (unused)                        Flag300\n-\n-   --    (unused)                        Flag301\n-   --    (unused)                        Flag302\n-   --    (unused)                        Flag303\n-   --    (unused)                        Flag304\n-   --    (unused)                        Flag305\n-   --    (unused)                        Flag306\n-   --    (unused)                        Flag307\n-   --    (unused)                        Flag308\n-   --    (unused)                        Flag309\n-   --    (unused)                        Flag310\n-\n-   --    (unused)                        Flag311\n-   --    (unused)                        Flag312\n-   --    (unused)                        Flag313\n-   --    (unused)                        Flag314\n-   --    (unused)                        Flag315\n-   --    (unused)                        Flag316\n-   --    (unused)                        Flag317\n+\n+   --  Note: Flag287-317 are defined in atree.ads/adb, but not yet in atree.h\n \n    -----------------------\n    -- Local subprograms --\n@@ -1488,9 +1456,7 @@ package body Einfo is\n \n    function Has_Invariants (Id : E) return B is\n    begin\n-      pragma Assert (Is_Type (Id)\n-        or else Ekind (Id) = E_Procedure\n-        or else Ekind (Id) = E_Generic_Procedure);\n+      pragma Assert (Is_Type (Id));\n       return Flag232 (Id);\n    end Has_Invariants;\n \n@@ -1614,6 +1580,7 @@ package body Einfo is\n \n    function Has_Predicates (Id : E) return B is\n    begin\n+      pragma Assert (Is_Type (Id));\n       return Flag250 (Id);\n    end Has_Predicates;\n \n@@ -2076,6 +2043,12 @@ package body Einfo is\n       return Flag64 (Id);\n    end Is_Intrinsic_Subprogram;\n \n+   function Is_Invariant_Procedure (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      return Flag257 (Id);\n+   end Is_Invariant_Procedure;\n+\n    function Is_Itype (Id : E) return B is\n    begin\n       return Flag91 (Id);\n@@ -2167,6 +2140,18 @@ package body Einfo is\n       return Flag9 (Id);\n    end Is_Potentially_Use_Visible;\n \n+   function Is_Predicate_Function (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      return Flag255 (Id);\n+   end Is_Predicate_Function;\n+\n+   function Is_Predicate_Function_M (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      return Flag256 (Id);\n+   end Is_Predicate_Function_M;\n+\n    function Is_Preelaborated (Id : E) return B is\n    begin\n       return Flag59 (Id);\n@@ -4037,9 +4022,7 @@ package body Einfo is\n \n    procedure Set_Has_Invariants (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Type (Id)\n-        or else Ekind (Id) = E_Procedure\n-        or else Ekind (Id) = E_Void);\n+      pragma Assert (Is_Type (Id));\n       Set_Flag232 (Id, V);\n    end Set_Has_Invariants;\n \n@@ -4172,6 +4155,7 @@ package body Einfo is\n \n    procedure Set_Has_Predicates (Id : E; V : B := True) is\n    begin\n+      pragma Assert (Is_Type (Id) or else Ekind (Id) = E_Void);\n       Set_Flag250 (Id, V);\n    end Set_Has_Predicates;\n \n@@ -4658,6 +4642,12 @@ package body Einfo is\n       Set_Flag64 (Id, V);\n    end Set_Is_Intrinsic_Subprogram;\n \n+   procedure Set_Is_Invariant_Procedure (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      Set_Flag257 (Id, V);\n+   end Set_Is_Invariant_Procedure;\n+\n    procedure Set_Is_Itype (Id : E; V : B := True) is\n    begin\n       Set_Flag91 (Id, V);\n@@ -4752,6 +4742,18 @@ package body Einfo is\n       Set_Flag9 (Id, V);\n    end Set_Is_Potentially_Use_Visible;\n \n+   procedure Set_Is_Predicate_Function (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      Set_Flag255 (Id, V);\n+   end Set_Is_Predicate_Function;\n+\n+   procedure Set_Is_Predicate_Function_M (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      Set_Flag256 (Id, V);\n+   end Set_Is_Predicate_Function_M;\n+\n    procedure Set_Is_Preelaborated (Id : E; V : B := True) is\n    begin\n       Set_Flag59 (Id, V);\n@@ -6403,7 +6405,7 @@ package body Einfo is\n       else\n          S := Subprograms_For_Type (Id);\n          while Present (S) loop\n-            if Has_Invariants (S) then\n+            if Is_Invariant_Procedure (S) then\n                return S;\n             else\n                S := Subprograms_For_Type (S);\n@@ -7121,7 +7123,7 @@ package body Einfo is\n       else\n          S := Subprograms_For_Type (Id);\n          while Present (S) loop\n-            if Has_Predicates (S) then\n+            if Is_Predicate_Function (S) then\n                return S;\n             else\n                S := Subprograms_For_Type (S);\n@@ -7132,6 +7134,33 @@ package body Einfo is\n       end if;\n    end Predicate_Function;\n \n+   --------------------------\n+   -- Predicate_Function_M --\n+   --------------------------\n+\n+   function Predicate_Function_M (Id : E) return E is\n+      S : Entity_Id;\n+\n+   begin\n+      pragma Assert (Is_Type (Id));\n+\n+      if No (Subprograms_For_Type (Id)) then\n+         return Empty;\n+\n+      else\n+         S := Subprograms_For_Type (Id);\n+         while Present (S) loop\n+            if Is_Predicate_Function_M (S) then\n+               return S;\n+            else\n+               S := Subprograms_For_Type (S);\n+            end if;\n+         end loop;\n+\n+         return Empty;\n+      end if;\n+   end Predicate_Function_M;\n+\n    -------------------------\n    -- Present_In_Rep_Item --\n    -------------------------\n@@ -7365,8 +7394,10 @@ package body Einfo is\n       Set_Subprograms_For_Type (Id, V);\n       Set_Subprograms_For_Type (V, S);\n \n+      --  Check for duplicate entry\n+\n       while Present (S) loop\n-         if Has_Invariants (S) then\n+         if Is_Invariant_Procedure (S) then\n             raise Program_Error;\n          else\n             S := Subprograms_For_Type (S);\n@@ -7389,14 +7420,39 @@ package body Einfo is\n       Set_Subprograms_For_Type (V, S);\n \n       while Present (S) loop\n-         if Has_Predicates (S) then\n+         if Is_Predicate_Function (S) then\n             raise Program_Error;\n          else\n             S := Subprograms_For_Type (S);\n          end if;\n       end loop;\n    end Set_Predicate_Function;\n \n+   ------------------------------\n+   -- Set_Predicate_Function_M --\n+   ------------------------------\n+\n+   procedure Set_Predicate_Function_M (Id : E; V : E) is\n+      S : Entity_Id;\n+\n+   begin\n+      pragma Assert (Is_Type (Id) and then Has_Predicates (Id));\n+\n+      S := Subprograms_For_Type (Id);\n+      Set_Subprograms_For_Type (Id, V);\n+      Set_Subprograms_For_Type (V, S);\n+\n+      --  Check for duplicates\n+\n+      while Present (S) loop\n+         if Is_Predicate_Function_M (S) then\n+            raise Program_Error;\n+         else\n+            S := Subprograms_For_Type (S);\n+         end if;\n+      end loop;\n+   end Set_Predicate_Function_M;\n+\n    -----------------\n    -- Size_Clause --\n    -----------------\n@@ -7783,6 +7839,7 @@ package body Einfo is\n       W (\"Is_Internal\",                     Flag17  (Id));\n       W (\"Is_Interrupt_Handler\",            Flag89  (Id));\n       W (\"Is_Intrinsic_Subprogram\",         Flag64  (Id));\n+      W (\"Is_Invariant_Procedure\",          Flag257 (Id));\n       W (\"Is_Itype\",                        Flag91  (Id));\n       W (\"Is_Known_Non_Null\",               Flag37  (Id));\n       W (\"Is_Known_Null\",                   Flag204 (Id));\n@@ -7800,6 +7857,8 @@ package body Einfo is\n       W (\"Is_Packed\",                       Flag51  (Id));\n       W (\"Is_Packed_Array_Type\",            Flag138 (Id));\n       W (\"Is_Potentially_Use_Visible\",      Flag9   (Id));\n+      W (\"Is_Predicate_Function\",           Flag255 (Id));\n+      W (\"Is_Predicate_Function_M\",         Flag256 (Id));\n       W (\"Is_Preelaborated\",                Flag59  (Id));\n       W (\"Is_Primitive\",                    Flag218 (Id));\n       W (\"Is_Primitive_Wrapper\",            Flag195 (Id));"}, {"sha": "9b32e8b62c353e4c3d3ef7390a101d8709fc65be", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -1587,9 +1587,7 @@ package Einfo is\n --       True, then usually the Invariant_Procedure attribute is set once the\n --       type is frozen, however this may not be true in some error situations.\n --       Note that it might be the full type which has inheritable invariants,\n---       and then the flag will also be set in the private type. Also set in\n---       the invariant procedure entity, to distinguish it among entries in the\n---       Subprograms_For_Type.\n+--       and then the flag will also be set in the private type.\n \n --    Has_Machine_Radix_Clause (Flag83)\n --       Defined in decimal types and subtypes, set if a Machine_Radix\n@@ -1731,11 +1729,9 @@ package Einfo is\n --       such an object and no warning is generated.\n \n --    Has_Predicates (Flag250)\n---       Defined in all entities. Set in type and subtype entities if a pragma\n---       Predicate or Predicate aspect applies to the type, or if it inherits a\n---       Predicate aspect from its parent or progenitor types. Also set in the\n---       predicate function entity, to distinguish it among entries in the\n---       Subprograms_For_Type.\n+--       Defined in type and subtype entities. Set if a pragma Predicate or\n+--       Predicate aspect applies to the type or subtype, or if it inherits a\n+--       Predicate aspect from its parent or progenitor types.\n \n --    Has_Primitive_Operations (Flag120) [base type only]\n --       Defined in all type entities. Set if at least one primitive operation\n@@ -2406,6 +2402,10 @@ package Einfo is\n --       setting of Is_Intrinsic_Subprogram, NOT simply having convention set\n --       to intrinsic, which causes intrinsic code to be generated.\n \n+--    Is_Invariant_Procedure (Flag257)\n+--       Defined in functions an procedures. Set for a generated invariant\n+--       procedure to identify it easily in the\n+\n --    Is_Itype (Flag91)\n --       Defined in all entities. Set to indicate that a type is an Itype,\n --       which means that the declaration for the type does not appear\n@@ -2637,6 +2637,15 @@ package Einfo is\n --       use clause (RM 8.4(8)). Note that potentially use visible entities\n --       are not necessarily use visible (RM 8.4(9-11)).\n \n+--    Is_Predicate_Function (Flag255)\n+--       Present in functions and procedures. Set for generated predicate\n+--       functions.\n+\n+--    Is_Predicate_Function_M (Flag256)\n+--       Present in functions and procedures. Set for special version of\n+--       predicate function generated for use in membership tests, where\n+--       raise expressions are transformed to return False.\n+\n --    Is_Preelaborated (Flag59)\n --       Defined in all entities, set in E_Package and E_Generic_Package\n --       entities to which a pragma Preelaborate is applied, and also in\n@@ -3384,6 +3393,12 @@ package Einfo is\n --       Note: the reason this is marked as a synthesized attribute is that the\n --       way this is stored is as an element of the Subprograms_For_Type field.\n \n+--    Predicate_Function_M (synthesized)\n+--       Defined in all types. Present only if Predicate_Function is present,\n+--       and only if the predicate function has Raise_Expression nodes. It\n+--       is the special version created for membership tests, where if one of\n+--       these raise expressions is executed, the result is to return False.\n+\n --    Primitive_Operations (synthesized)\n --       Defined in concurrent types, tagged record types and subtypes, tagged\n --       private types and tagged incomplete types. For concurrent types whose\n@@ -4844,7 +4859,6 @@ package Einfo is\n    --    Has_Pragma_Thread_Local_Storage     (Flag169)\n    --    Has_Pragma_Unmodified               (Flag233)\n    --    Has_Pragma_Unreferenced             (Flag180)\n-   --    Has_Predicates                      (Flag250)\n    --    Has_Private_Declaration             (Flag155)\n    --    Has_Qualified_Name                  (Flag161)\n    --    Has_Stream_Size_Clause              (Flag184)\n@@ -4961,6 +4975,7 @@ package Einfo is\n    --    Has_Object_Size_Clause              (Flag172)\n    --    Has_Pragma_Preelab_Init             (Flag221)\n    --    Has_Pragma_Unreferenced_Objects     (Flag212)\n+   --    Has_Predicates                      (Flag250)\n    --    Has_Primitive_Operations            (Flag120)  (base type only)\n    --    Has_Size_Clause                     (Flag29)\n    --    Has_Specified_Layout                (Flag100)  (base type only)\n@@ -5006,6 +5021,7 @@ package Einfo is\n    --    Invariant_Procedure                 (synth)\n    --    Is_Access_Protected_Subprogram_Type (synth)\n    --    Predicate_Function                  (synth)\n+   --    Predicate_Function_M                (synth)\n    --    Root_Type                           (synth)\n    --    Size_Clause                         (synth)\n \n@@ -5360,7 +5376,10 @@ package Einfo is\n    --    Is_Eliminated                       (Flag124)\n    --    Is_Instantiated                     (Flag126)  (generic case only)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n+   --    Is_Invariant_Procedure              (Flag257)  (non-generic case only)\n    --    Is_Machine_Code_Subprogram          (Flag137)  (non-generic case only)\n+   --    Is_Predicate_Function               (Flag255)  (non-generic case only)\n+   --    Is_Predicate_Function_M             (Flag256)  (non-generic case only)\n    --    Is_Primitive                        (Flag218)\n    --    Is_Primitive_Wrapper                (Flag195)  (non-generic case only)\n    --    Is_Private_Descendant               (Flag53)\n@@ -5629,8 +5648,11 @@ package Einfo is\n    --    Is_Instantiated                     (Flag126)  (generic case only)\n    --    Is_Interrupt_Handler                (Flag89)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n+   --    Is_Invariant_Procedure              (Flag257)  (non-generic case only)\n    --    Is_Machine_Code_Subprogram          (Flag137)  (non-generic case only)\n    --    Is_Null_Init_Proc                   (Flag178)\n+   --    Is_Predicate_Function               (Flag255)  (non-generic case only)\n+   --    Is_Predicate_Function_M             (Flag256)  (non-generic case only)\n    --    Is_Primitive                        (Flag218)\n    --    Is_Primitive_Wrapper                (Flag195)  (non-generic case only)\n    --    Is_Private_Descendant               (Flag53)\n@@ -6327,6 +6349,7 @@ package Einfo is\n    function Is_Internal                         (Id : E) return B;\n    function Is_Interrupt_Handler                (Id : E) return B;\n    function Is_Intrinsic_Subprogram             (Id : E) return B;\n+   function Is_Invariant_Procedure              (Id : E) return B;\n    function Is_Itype                            (Id : E) return B;\n    function Is_Known_Non_Null                   (Id : E) return B;\n    function Is_Known_Null                       (Id : E) return B;\n@@ -6344,6 +6367,8 @@ package Einfo is\n    function Is_Packed                           (Id : E) return B;\n    function Is_Packed_Array_Type                (Id : E) return B;\n    function Is_Potentially_Use_Visible          (Id : E) return B;\n+   function Is_Predicate_Function               (Id : E) return B;\n+   function Is_Predicate_Function_M             (Id : E) return B;\n    function Is_Preelaborated                    (Id : E) return B;\n    function Is_Primitive                        (Id : E) return B;\n    function Is_Primitive_Wrapper                (Id : E) return B;\n@@ -6933,6 +6958,7 @@ package Einfo is\n    procedure Set_Is_Internal                     (Id : E; V : B := True);\n    procedure Set_Is_Interrupt_Handler            (Id : E; V : B := True);\n    procedure Set_Is_Intrinsic_Subprogram         (Id : E; V : B := True);\n+   procedure Set_Is_Invariant_Procedure          (Id : E; V : B := True);\n    procedure Set_Is_Itype                        (Id : E; V : B := True);\n    procedure Set_Is_Known_Non_Null               (Id : E; V : B := True);\n    procedure Set_Is_Known_Null                   (Id : E; V : B := True);\n@@ -6951,6 +6977,8 @@ package Einfo is\n    procedure Set_Is_Packed                       (Id : E; V : B := True);\n    procedure Set_Is_Packed_Array_Type            (Id : E; V : B := True);\n    procedure Set_Is_Potentially_Use_Visible      (Id : E; V : B := True);\n+   procedure Set_Is_Predicate_Function           (Id : E; V : B := True);\n+   procedure Set_Is_Predicate_Function_M         (Id : E; V : B := True);\n    procedure Set_Is_Preelaborated                (Id : E; V : B := True);\n    procedure Set_Is_Primitive                    (Id : E; V : B := True);\n    procedure Set_Is_Primitive_Wrapper            (Id : E; V : B := True);\n@@ -7104,9 +7132,11 @@ package Einfo is\n \n    function Invariant_Procedure                 (Id : E) return N;\n    function Predicate_Function                  (Id : E) return N;\n+   function Predicate_Function_M                (Id : E) return N;\n \n    procedure Set_Invariant_Procedure            (Id : E; V : E);\n    procedure Set_Predicate_Function             (Id : E; V : E);\n+   procedure Set_Predicate_Function_M           (Id : E; V : E);\n \n    -----------------------------------\n    -- Field Initialization Routines --\n@@ -7649,6 +7679,7 @@ package Einfo is\n    pragma Inline (Is_Internal);\n    pragma Inline (Is_Interrupt_Handler);\n    pragma Inline (Is_Intrinsic_Subprogram);\n+   pragma Inline (Is_Invariant_Procedure);\n    pragma Inline (Is_Itype);\n    pragma Inline (Is_Known_Non_Null);\n    pragma Inline (Is_Known_Null);\n@@ -7673,6 +7704,8 @@ package Einfo is\n    pragma Inline (Is_Packed);\n    pragma Inline (Is_Packed_Array_Type);\n    pragma Inline (Is_Potentially_Use_Visible);\n+   pragma Inline (Is_Predicate_Function);\n+   pragma Inline (Is_Predicate_Function_M);\n    pragma Inline (Is_Preelaborated);\n    pragma Inline (Is_Primitive);\n    pragma Inline (Is_Primitive_Wrapper);\n@@ -8074,6 +8107,7 @@ package Einfo is\n    pragma Inline (Set_Is_Internal);\n    pragma Inline (Set_Is_Interrupt_Handler);\n    pragma Inline (Set_Is_Intrinsic_Subprogram);\n+   pragma Inline (Set_Is_Invariant_Procedure);\n    pragma Inline (Set_Is_Itype);\n    pragma Inline (Set_Is_Known_Non_Null);\n    pragma Inline (Set_Is_Known_Null);\n@@ -8092,6 +8126,8 @@ package Einfo is\n    pragma Inline (Set_Is_Packed);\n    pragma Inline (Set_Is_Packed_Array_Type);\n    pragma Inline (Set_Is_Potentially_Use_Visible);\n+   pragma Inline (Set_Is_Predicate_Function);\n+   pragma Inline (Set_Is_Predicate_Function_M);\n    pragma Inline (Set_Is_Preelaborated);\n    pragma Inline (Set_Is_Primitive);\n    pragma Inline (Set_Is_Primitive_Wrapper);"}, {"sha": "981cd2ad7672e52942fca1d86b7c9c7fce1f32e7", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -1450,21 +1450,39 @@ package body Exp_Ch11 is\n       --     do\n       --       raise X [with string]\n       --     in\n-      --       raise Consraint_Error;\n+      --       raise Constraint_Error;\n+\n+      --  unless the flag Convert_To_Return_False is set, in which case\n+      --  the transformation is to:\n+\n+      --     do\n+      --       return False;\n+      --     in\n+      --       raise Constraint_Error;\n \n       --  The raise constraint error can never be executed. It is just a dummy\n       --  node that can be labeled with an arbitrary type.\n \n       RCE := Make_Raise_Constraint_Error (Loc, Reason => CE_Explicit_Raise);\n       Set_Etype (RCE, Typ);\n \n-      Rewrite (N,\n-        Make_Expression_With_Actions (Loc,\n-          Actions     => New_List (\n-            Make_Raise_Statement (Loc,\n-              Name       => Name (N),\n-              Expression => Expression (N))),\n-           Expression => RCE));\n+      if Convert_To_Return_False (N) then\n+         Rewrite (N,\n+           Make_Expression_With_Actions (Loc,\n+             Actions     => New_List (\n+               Make_Simple_Return_Statement (Loc,\n+                 Expression => New_Occurrence_Of (Standard_False, Loc))),\n+              Expression => RCE));\n+\n+      else\n+         Rewrite (N,\n+           Make_Expression_With_Actions (Loc,\n+             Actions     => New_List (\n+               Make_Raise_Statement (Loc,\n+                 Name       => Name (N),\n+                 Expression => Expression (N))),\n+              Expression => RCE));\n+      end if;\n \n       Analyze_And_Resolve (N, Typ);\n    end Expand_N_Raise_Expression;"}, {"sha": "89ffa2b806947ccb093e98777d42711f06d9bc80", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -7675,7 +7675,7 @@ package body Exp_Ch3 is\n \n          if not Has_Invariants (Typ) then\n             Set_Has_Invariants (Typ);\n-            Set_Has_Invariants (Proc_Id);\n+            Set_Is_Invariant_Procedure (Proc_Id);\n             Set_Invariant_Procedure (Typ, Proc_Id);\n             Insert_After (N, Proc);\n             Analyze (Proc);"}, {"sha": "779466abc0e2b932a066ecadd50b7624343a23d2", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -6338,7 +6338,7 @@ package body Exp_Ch4 is\n             Rewrite (N,\n               Make_And_Then (Loc,\n                 Left_Opnd  => Relocate_Node (N),\n-                Right_Opnd => Make_Predicate_Call (Rtyp, Lop)));\n+                Right_Opnd => Make_Predicate_Call (Rtyp, Lop, Mem => True)));\n \n             --  Analyze new expression, mark left operand as analyzed to\n             --  avoid infinite recursion adding predicate calls. Similarly,"}, {"sha": "cb61a42bb65aa81363988844e0bc4e4a9f29ea85", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -5520,18 +5520,36 @@ package body Exp_Util is\n \n    function Make_Predicate_Call\n      (Typ  : Entity_Id;\n-      Expr : Node_Id) return Node_Id\n+      Expr : Node_Id;\n+      Mem  : Boolean := False) return Node_Id\n    is\n       Loc : constant Source_Ptr := Sloc (Expr);\n \n    begin\n       pragma Assert (Present (Predicate_Function (Typ)));\n \n+      --  Call special membership version if requested and available\n+\n+      if Mem then\n+         declare\n+            PFM : constant Entity_Id := Predicate_Function_M (Typ);\n+         begin\n+            if Present (PFM) then\n+               return\n+                 Make_Function_Call (Loc,\n+                   Name                   => New_Occurrence_Of (PFM, Loc),\n+                   Parameter_Associations => New_List (Relocate_Node (Expr)));\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Case of calling normal predicate function\n+\n       return\n-        Make_Function_Call (Loc,\n-          Name                   =>\n-            New_Occurrence_Of (Predicate_Function (Typ), Loc),\n-          Parameter_Associations => New_List (Relocate_Node (Expr)));\n+          Make_Function_Call (Loc,\n+            Name                   =>\n+              New_Occurrence_Of (Predicate_Function (Typ), Loc),\n+            Parameter_Associations => New_List (Relocate_Node (Expr)));\n    end Make_Predicate_Call;\n \n    --------------------------"}, {"sha": "ce643454f4c7cd7e042f9b7f0f9cd53e16b7f7e9", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -647,9 +647,12 @@ package Exp_Util is\n \n    function Make_Predicate_Call\n      (Typ  : Entity_Id;\n-      Expr : Node_Id) return Node_Id;\n+      Expr : Node_Id;\n+      Mem  : Boolean := False) return Node_Id;\n    --  Typ is a type with Predicate_Function set. This routine builds a call to\n    --  this function passing Expr as the argument, and returns it unanalyzed.\n+   --  If Mem is set True, this is the special call for the membership case,\n+   --  and the function called is the Predicate_Function_M if present.\n \n    function Make_Predicate_Check\n      (Typ  : Entity_Id;"}, {"sha": "bf3f0355620b65a545ee17a340e64a6b5ff211a4", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2047,16 +2047,18 @@ package body Lib.Xref is\n                      Ctyp := '*';\n                   end if;\n \n-                  --  Special handling for access parameters and objects of\n-                  --  an anonymous access type.\n+                  --  Special handling for access parameters and objects and\n+                  --  components of an anonymous access type.\n \n                   if Ekind_In (Etype (XE.Key.Ent),\n                                E_Anonymous_Access_Type,\n                                E_Anonymous_Access_Subprogram_Type,\n                                E_Anonymous_Access_Protected_Subprogram_Type)\n                   then\n                      if Is_Formal (XE.Key.Ent)\n-                       or else Ekind_In (XE.Key.Ent, E_Variable, E_Constant)\n+                       or else\n+                         Ekind_In\n+                           (XE.Key.Ent, E_Variable, E_Constant, E_Component)\n                      then\n                         Ctyp := 'p';\n                      end if;"}, {"sha": "4f2d56c1684239ec3b2d17c4fbece91c7b1c8278", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 271, "deletions": 81, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -82,15 +82,17 @@ package body Sem_Ch13 is\n    --  type whose inherited alignment is no longer appropriate for the new\n    --  size value. In this case, we reset the Alignment to unknown.\n \n-   procedure Build_Predicate_Function (Typ : Entity_Id; N : Node_Id);\n+   procedure Build_Predicate_Functions (Typ : Entity_Id; N : Node_Id);\n    --  If Typ has predicates (indicated by Has_Predicates being set for Typ,\n    --  then either there are pragma Predicate entries on the rep chain for the\n    --  type (note that Predicate aspects are converted to pragma Predicate), or\n    --  there are inherited aspects from a parent type, or ancestor subtypes.\n    --  This procedure builds the spec and body for the Predicate function that\n    --  tests these predicates. N is the freeze node for the type. The spec of\n    --  the function is inserted before the freeze node, and the body of the\n-   --  function is inserted after the freeze node.\n+   --  function is inserted after the freeze node. If the predicate expression\n+   --  has at least one Raise_Expression, then this procedure also builds the\n+   --  M version of the predicate function for ue in membership tests.\n \n    procedure Build_Static_Predicate\n      (Typ  : Entity_Id;\n@@ -4689,12 +4691,12 @@ package body Sem_Ch13 is\n       --  If we have a type with predicates, build predicate function\n \n       if Is_Type (E) and then Has_Predicates (E) then\n-         Build_Predicate_Function (E, N);\n+         Build_Predicate_Functions (E, N);\n       end if;\n \n       --  If type has delayed aspects, this is where we do the preanalysis at\n       --  the freeze point, as part of the consistent visibility check. Note\n-      --  that this must be done after calling Build_Predicate_Function or\n+      --  that this must be done after calling Build_Predicate_Functions or\n       --  Build_Invariant_Procedure since these subprograms fix occurrences of\n       --  the subtype name in the saved expression so that they will not cause\n       --  trouble in the preanalysis.\n@@ -5225,9 +5227,9 @@ package body Sem_Ch13 is\n       SId :=\n         Make_Defining_Identifier (Loc,\n           Chars => New_External_Name (Chars (Typ), \"Invariant\"));\n-      Set_Has_Invariants (SId);\n       Set_Has_Invariants (Typ);\n       Set_Ekind (SId, E_Procedure);\n+      Set_Is_Invariant_Procedure (SId);\n       Set_Invariant_Procedure (Typ, SId);\n \n       Spec :=\n@@ -5597,11 +5599,11 @@ package body Sem_Ch13 is\n       end if;\n    end Build_Invariant_Procedure;\n \n-   ------------------------------\n-   -- Build_Predicate_Function --\n-   ------------------------------\n+   -------------------------------\n+   -- Build_Predicate_Functions --\n+   -------------------------------\n \n-   --  The procedure that is constructed here has the form:\n+   --  The procedures that are constructed here has the form:\n \n    --    function typPredicate (Ixxx : typ) return Boolean is\n    --    begin\n@@ -5618,17 +5620,38 @@ package body Sem_Ch13 is\n    --  inherited. Note that we do NOT generate Check pragmas, that's because we\n    --  use this function even if checks are off, e.g. for membership tests.\n \n-   procedure Build_Predicate_Function (Typ : Entity_Id; N : Node_Id) is\n-      Loc   : constant Source_Ptr := Sloc (Typ);\n-      Spec  : Node_Id;\n-      SId   : Entity_Id;\n-      FDecl : Node_Id;\n-      FBody : Node_Id;\n+   --  If the expression has at least one Raise_Expression, then we also build\n+   --  the typPredicateM version of the function, in which any occurence of a\n+   --  Raise_Expressioon is converted to \"return False\".\n+\n+   procedure Build_Predicate_Functions (Typ : Entity_Id; N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (Typ);\n \n       Expr : Node_Id;\n-      --  This is the expression for the return statement in the function. It\n+      --  This is the expression for the result of the function. It is\n       --  is build by connecting the component predicates with AND THEN.\n \n+      Expr_M : Node_Id;\n+      --  This is the corresponding return expression for the Predicate_M\n+      --  function. It differs in that raise expressions are marked for\n+      --  special expansion (see Process_REs).\n+\n+      Object_Name : constant Name_Id := New_Internal_Name ('I');\n+      --  Name for argument of Predicate procedure. Note that we use the same\n+      --  name for both predicate procedure. That way the reference within the\n+      --  predicate expression is the same in both functions.\n+\n+      Object_Entity : constant Entity_Id :=\n+                        Make_Defining_Identifier (Loc, Chars => Object_Name);\n+      --  Entity for argument of Predicate procedure\n+\n+      Object_Entity_M : constant Entity_Id :=\n+                         Make_Defining_Identifier (Loc, Chars => Object_Name);\n+      --  Entity for argument of Predicate_M procedure\n+\n+      Raise_Expression_Present : Boolean := False;\n+      --  Set True if Expr has at least one Raise_Expression\n+\n       procedure Add_Call (T : Entity_Id);\n       --  Includes a call to the predicate function for type T in Expr if T\n       --  has predicates and Predicate_Function (T) is non-empty.\n@@ -5639,12 +5662,19 @@ package body Sem_Ch13 is\n       --  Inheritance of predicates for the parent type is done by calling the\n       --  Predicate_Function of the parent type, using Add_Call above.\n \n-      Object_Name : constant Name_Id := New_Internal_Name ('I');\n-      --  Name for argument of Predicate procedure\n+      function Test_RE (N : Node_Id) return Traverse_Result;\n+      --  Used in Test_REs, tests one node for being a raise expression, and if\n+      --  so sets Raise_Expression_Present True.\n \n-      Object_Entity : constant Entity_Id :=\n-                        Make_Defining_Identifier (Loc, Object_Name);\n-      --  The entity for the spec entity for the argument\n+      procedure Test_REs is new Traverse_Proc (Test_RE);\n+      --  Tests to see if Expr contains any raise expressions\n+\n+      function Process_RE (N : Node_Id) return Traverse_Result;\n+      --  Used in Process REs, tests if node N is a raise expression, and if\n+      --  so, marks it to be converted to return False.\n+\n+      procedure Process_REs is new Traverse_Proc (Process_RE);\n+      --  Marks any raise expressions in Expr_M to return False\n \n       Dynamic_Predicate_Present : Boolean := False;\n       --  Set True if a dynamic predicate is present, results in the entire\n@@ -5730,8 +5760,8 @@ package body Sem_Ch13 is\n             Rewrite (N, Make_Identifier (Sloc (N), Object_Name));\n             --  Use the Sloc of the usage name, not the defining name\n \n-            Set_Entity (N, Object_Entity);\n             Set_Etype (N, Typ);\n+            Set_Entity (N, Object_Entity);\n \n             --  We want to treat the node as if it comes from source, so that\n             --  ASIS will not ignore it\n@@ -5830,13 +5860,37 @@ package body Sem_Ch13 is\n          end loop;\n       end Add_Predicates;\n \n-   --  Start of processing for Build_Predicate_Function\n+      ----------------\n+      -- Process_RE --\n+      ----------------\n \n-   begin\n-      --  Initialize for construction of statement list\n+      function Process_RE (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) = N_Raise_Expression then\n+            Set_Convert_To_Return_False (N);\n+            return Skip;\n+         else\n+            return OK;\n+         end if;\n+      end Process_RE;\n \n-      Expr := Empty;\n+      -------------\n+      -- Test_RE --\n+      -------------\n \n+      function Test_RE (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) = N_Raise_Expression then\n+            Raise_Expression_Present := True;\n+            return Abandon;\n+         else\n+            return OK;\n+         end if;\n+      end Test_RE;\n+\n+   --  Start of processing for Build_Predicate_Functions\n+\n+   begin\n       --  Return if already built or if type does not have predicates\n \n       if not Has_Predicates (Typ)\n@@ -5845,6 +5899,10 @@ package body Sem_Ch13 is\n          return;\n       end if;\n \n+      --  Prepare to construct predicate expression\n+\n+      Expr := Empty;\n+\n       --  Add Predicates for the current type\n \n       Add_Predicates;\n@@ -5859,69 +5917,198 @@ package body Sem_Ch13 is\n          end if;\n       end;\n \n-      --  If we have predicates, build the function\n+      --  Case where predicates are present\n \n       if Present (Expr) then\n \n-         --  Build function declaration\n+         --  Test for raise expression present\n \n-         SId :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n-         Set_Has_Predicates (SId);\n-         Set_Ekind (SId, E_Function);\n-         Set_Predicate_Function (Typ, SId);\n+         Test_REs (Expr);\n \n-         --  The predicate function is shared between views of a type.\n+         --  If raise expression is present, capture a copy of Expr for use\n+         --  in building the predicateM function version later on. For this\n+         --  copy we replace references to Object_Entity by Object_Entity_M.\n \n-         if Is_Private_Type (Typ) and then Present (Full_View (Typ)) then\n-            Set_Predicate_Function (Full_View (Typ), SId);\n+         if Raise_Expression_Present then\n+            declare\n+               Map : constant Elist_Id := New_Elmt_List;\n+            begin\n+               Append_Elmt (Object_Entity, Map);\n+               Append_Elmt (Object_Entity_M, Map);\n+               Expr_M := New_Copy_Tree (Expr, Map => Map);\n+            end;\n          end if;\n \n-         Spec :=\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       => SId,\n-             Parameter_Specifications => New_List (\n-               Make_Parameter_Specification (Loc,\n-                 Defining_Identifier => Object_Entity,\n-                 Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n-             Result_Definition        =>\n-               New_Occurrence_Of (Standard_Boolean, Loc));\n-\n-         FDecl := Make_Subprogram_Declaration (Loc, Specification => Spec);\n-\n-         --  Build function body\n-\n-         SId :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n-\n-         Spec :=\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       => SId,\n-             Parameter_Specifications => New_List (\n-               Make_Parameter_Specification (Loc,\n-                 Defining_Identifier =>\n-                   Make_Defining_Identifier (Loc, Object_Name),\n-                 Parameter_Type =>\n-                   New_Occurrence_Of (Typ, Loc))),\n-             Result_Definition        =>\n-               New_Occurrence_Of (Standard_Boolean, Loc));\n-\n-         FBody :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              => Spec,\n-             Declarations               => Empty_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (\n-                   Make_Simple_Return_Statement (Loc,\n-                     Expression => Expr))));\n+         --  Build the main predicate function\n+\n+         declare\n+            SId : constant Entity_Id :=\n+                    Make_Defining_Identifier (Loc,\n+                      Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+            --  The entity for the the function spec\n+\n+            SIdB : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+            --  The entity for the function body\n+\n+            Spec  : Node_Id;\n+            FDecl : Node_Id;\n+            FBody : Node_Id;\n+\n+         begin\n+            --  Build function declaration\n+\n+            Set_Ekind (SId, E_Function);\n+            Set_Is_Predicate_Function (SId);\n+            Set_Predicate_Function (Typ, SId);\n+\n+            --  The predicate function is shared between views of a type\n+\n+            if Is_Private_Type (Typ) and then Present (Full_View (Typ)) then\n+               Set_Predicate_Function (Full_View (Typ), SId);\n+            end if;\n+\n+            Spec :=\n+              Make_Function_Specification (Loc,\n+                Defining_Unit_Name       => SId,\n+                Parameter_Specifications => New_List (\n+                  Make_Parameter_Specification (Loc,\n+                    Defining_Identifier => Object_Entity,\n+                    Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n+                Result_Definition        =>\n+                  New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+            FDecl :=\n+              Make_Subprogram_Declaration (Loc,\n+                Specification => Spec);\n \n-         --  Insert declaration before freeze node and body after\n+            --  Build function body\n \n-         Insert_Before_And_Analyze (N, FDecl);\n-         Insert_After_And_Analyze  (N, FBody);\n+            Spec :=\n+              Make_Function_Specification (Loc,\n+                Defining_Unit_Name       => SIdB,\n+                Parameter_Specifications => New_List (\n+                  Make_Parameter_Specification (Loc,\n+                    Defining_Identifier =>\n+                      Make_Defining_Identifier (Loc, Object_Name),\n+                    Parameter_Type =>\n+                      New_Occurrence_Of (Typ, Loc))),\n+                Result_Definition        =>\n+                  New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+            FBody :=\n+              Make_Subprogram_Body (Loc,\n+                Specification              => Spec,\n+                Declarations               => Empty_List,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (\n+                      Make_Simple_Return_Statement (Loc,\n+                        Expression => Expr))));\n+\n+            --  Insert declaration before freeze node and body after\n+\n+            Insert_Before_And_Analyze (N, FDecl);\n+            Insert_After_And_Analyze  (N, FBody);\n+         end;\n+\n+         --  Test for raise expressions present and if so build M version\n+\n+         if Raise_Expression_Present then\n+            declare\n+               SId : constant Entity_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Chars (Typ), \"PredicateM\"));\n+               --  The entity for the the function spec\n+\n+               SIdB : constant Entity_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Chars (Typ), \"PredicateM\"));\n+               --  The entity for the function body\n+\n+               Spec  : Node_Id;\n+               FDecl : Node_Id;\n+               FBody : Node_Id;\n+               BTemp : Entity_Id;\n+\n+            begin\n+               --  Mark any raise expressions for special expansion\n+\n+               Process_REs (Expr_M);\n+\n+               --  Build function declaration\n+\n+               Set_Ekind (SId, E_Function);\n+               Set_Is_Predicate_Function_M (SId);\n+               Set_Predicate_Function_M (Typ, SId);\n+\n+               --  The predicate function is shared between views of a type\n+\n+               if Is_Private_Type (Typ) and then Present (Full_View (Typ)) then\n+                  Set_Predicate_Function_M (Full_View (Typ), SId);\n+               end if;\n+\n+               Spec :=\n+                 Make_Function_Specification (Loc,\n+                   Defining_Unit_Name       => SId,\n+                   Parameter_Specifications => New_List (\n+                     Make_Parameter_Specification (Loc,\n+                       Defining_Identifier => Object_Entity_M,\n+                       Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n+                   Result_Definition        =>\n+                     New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+               FDecl :=\n+                 Make_Subprogram_Declaration (Loc,\n+                   Specification => Spec);\n+\n+               --  Build function body\n+\n+               Spec :=\n+                 Make_Function_Specification (Loc,\n+                   Defining_Unit_Name       => SIdB,\n+                   Parameter_Specifications => New_List (\n+                     Make_Parameter_Specification (Loc,\n+                       Defining_Identifier =>\n+                         Make_Defining_Identifier (Loc, Object_Name),\n+                       Parameter_Type =>\n+                         New_Occurrence_Of (Typ, Loc))),\n+                   Result_Definition        =>\n+                     New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+               --  Build the body, we declare the boolean expression before\n+               --  doing the return, because we are not really confident of\n+               --  what happens if a return appears within a return!\n+\n+               BTemp :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_Internal_Name ('B'));\n+\n+               FBody :=\n+                 Make_Subprogram_Body (Loc,\n+                   Specification              => Spec,\n+\n+                   Declarations               => New_List (\n+                     Make_Object_Declaration (Loc,\n+                       Defining_Identifier => BTemp,\n+                       Constant_Present    => True,\n+                         Object_Definition =>\n+                           New_Reference_To (Standard_Boolean, Loc),\n+                         Expression        => Expr_M)),\n+\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => New_List (\n+                         Make_Simple_Return_Statement (Loc,\n+                           Expression => New_Reference_To (BTemp, Loc)))));\n+\n+               --  Insert declaration before freeze node and body after\n+\n+               Insert_Before_And_Analyze (N, FDecl);\n+               Insert_After_And_Analyze  (N, FBody);\n+            end;\n+         end if;\n \n          --  Deal with static predicate case\n \n@@ -5944,7 +6131,7 @@ package body Sem_Ch13 is\n             end if;\n          end if;\n       end if;\n-   end Build_Predicate_Function;\n+   end Build_Predicate_Functions;\n \n    ----------------------------\n    -- Build_Static_Predicate --\n@@ -6449,7 +6636,10 @@ package body Sem_Ch13 is\n                   declare\n                      Ent : constant Entity_Id := Entity (Name (Exp));\n                   begin\n-                     if Has_Predicates (Ent) then\n+                     if Is_Predicate_Function (Ent)\n+                          or else\n+                        Is_Predicate_Function_M (Ent)\n+                     then\n                         return Stat_Pred (Etype (First_Formal (Ent)));\n                      end if;\n                   end;"}, {"sha": "76eae4c803f564eefe6cf1b7782fef5e3c02c67c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -7896,12 +7896,11 @@ package body Sem_Prag is\n                end if;\n             end if;\n \n-            --  Now you might think we could just do the same with the\n-            --  Boolean expression if checks are off (and expansion is on)\n-            --  and then rewrite the check as a null\n-            --  statement. This would work but we would lose the useful\n-            --  warnings about an assertion being bound to fail even if\n-            --  assertions are turned off.\n+            --  Now you might think we could just do the same with the Boolean\n+            --  expression if checks are off (and expansion is on) and then\n+            --  rewrite the check as a null statement. This would work but we\n+            --  would lose the useful warnings about an assertion being bound\n+            --  to fail even if assertions are turned off.\n \n             --  So instead we wrap the boolean expression in an if statement\n             --  that looks like:"}, {"sha": "c43c4f61d04668e75ee4dd0f9b481affb57f7448", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -3935,7 +3935,9 @@ package body Sem_Res is\n                --  infinite recursion.\n \n                if not (Ekind (Nam) = E_Function\n-                        and then Has_Predicates (Nam))\n+                        and then (Is_Predicate_Function (Nam)\n+                                    or else\n+                                  Is_Predicate_Function_M (Nam)))\n                then\n                   Apply_Predicate_Check (A, F_Typ);\n                end if;\n@@ -9792,7 +9794,9 @@ package body Sem_Res is\n       if Has_Predicates (Target_Typ) then\n          if Nkind (Parent (N)) = N_Function_Call\n            and then Present (Name (Parent (N)))\n-           and then Has_Predicates (Entity (Name (Parent (N))))\n+           and then (Is_Predicate_Function (Entity (Name (Parent (N))))\n+                       or else\n+                     Is_Predicate_Function_M (Entity (Name (Parent (N)))))\n          then\n             null;\n "}, {"sha": "98dbe553faea83097e4500bba5d6a8398173c256", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -602,6 +602,14 @@ package body Sinfo is\n       return Flag14 (N);\n    end Conversion_OK;\n \n+   function Convert_To_Return_False\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Raise_Expression);\n+      return Flag13 (N);\n+   end Convert_To_Return_False;\n+\n    function Corresponding_Aspect\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -3685,6 +3693,14 @@ package body Sinfo is\n       Set_Flag14 (N, Val);\n    end Set_Conversion_OK;\n \n+   procedure Set_Convert_To_Return_False\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Raise_Expression);\n+      Set_Flag13 (N, Val);\n+   end Set_Convert_To_Return_False;\n+\n    procedure Set_Corresponding_Aspect\n       (N : Node_Id; Val : Node_Id) is\n    begin"}, {"sha": "59c60b9644bd4f1e99fb90a3eefffccdcb85fca9", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc142f6327838046dd9d363de53fad60771304e2/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=fc142f6327838046dd9d363de53fad60771304e2", "patch": "@@ -720,6 +720,12 @@ package Sinfo is\n    --    direct conversion of the underlying integer result, with no regard to\n    --    the small operand.\n \n+   --  Convert_To_Return_False (Flag13-Sem)\n+   --    Present in N_Raise_Expression nodes that appear in the body of the\n+   --    special predicateM function used to test a predicate in the context\n+   --    of a membership test, where raise expression results in returning a\n+   --    value of False rather than raising an exception.\n+\n    --  Corresponding_Aspect (Node3-Sem)\n    --    Present in N_Pragma node. Used to point back to the source aspect from\n    --    the corresponding pragma. This field is Empty for source pragmas.\n@@ -6139,6 +6145,7 @@ package Sinfo is\n       --  Sloc points to RAISE\n       --  Name (Node2) (always present)\n       --  Expression (Node3) (set to Empty if no expression present)\n+      --  Convert_To_Return_False (Flag13-Sem)\n       --  plus fields for expression\n \n       -------------------------------\n@@ -8299,6 +8306,9 @@ package Sinfo is\n    function Conversion_OK\n      (N : Node_Id) return Boolean;    -- Flag14\n \n+   function Convert_To_Return_False\n+     (N : Node_Id) return Boolean;    -- Flag13\n+\n    function Corresponding_Aspect\n      (N : Node_Id) return Node_Id;    -- Node3\n \n@@ -9280,6 +9290,9 @@ package Sinfo is\n    procedure Set_Conversion_OK\n      (N : Node_Id; Val : Boolean := True);    -- Flag14\n \n+   procedure Set_Convert_To_Return_False\n+     (N : Node_Id; Val : Boolean := True);    -- Flag13\n+\n    procedure Set_Corresponding_Aspect\n      (N : Node_Id; Val : Node_Id);            -- Node3\n \n@@ -11880,6 +11893,7 @@ package Sinfo is\n    pragma Inline (Context_Items);\n    pragma Inline (Context_Pending);\n    pragma Inline (Controlling_Argument);\n+   pragma Inline (Convert_To_Return_False);\n    pragma Inline (Conversion_OK);\n    pragma Inline (Corresponding_Aspect);\n    pragma Inline (Corresponding_Body);\n@@ -12204,6 +12218,7 @@ package Sinfo is\n    pragma Inline (Set_Context_Items);\n    pragma Inline (Set_Context_Pending);\n    pragma Inline (Set_Controlling_Argument);\n+   pragma Inline (Set_Convert_To_Return_False);\n    pragma Inline (Set_Conversion_OK);\n    pragma Inline (Set_Corresponding_Aspect);\n    pragma Inline (Set_Corresponding_Body);"}]}