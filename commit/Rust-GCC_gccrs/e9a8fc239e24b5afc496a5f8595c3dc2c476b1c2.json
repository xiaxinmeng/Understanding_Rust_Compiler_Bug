{"sha": "e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlhOGZjMjM5ZTI0YjVhZmM0OTZhNWY4NTk1YzNkYzJjNDc2YjFjMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-07-23T09:10:37Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-07-23T09:10:37Z"}, "message": "params.def (PARAM_MAX_COMBINE_INSNS): New.\n\n2014-07-23  Richard Biener  <rguenther@suse.de>\n\n\t* params.def (PARAM_MAX_COMBINE_INSNS): New.\n\t* combine.c: Include statistics.h and params.h.\n\t(combine_instructions): Guard three and four insn combines\n\twith max-combine-insns value.  Record statistics for combines\n\tperformed.\n\t* doc/invoke.texi (max-combine-insns): Document new param.\n\nFrom-SVN: r212923", "tree": {"sha": "efff919dae3e3c39dde168a95ba6b1d9ee02b9df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efff919dae3e3c39dde168a95ba6b1d9ee02b9df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "322a0b39c823f42ee11cbf4c65e9f4a150f9edb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/322a0b39c823f42ee11cbf4c65e9f4a150f9edb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/322a0b39c823f42ee11cbf4c65e9f4a150f9edb6"}], "stats": {"total": 409, "additions": 229, "deletions": 180}, "files": [{"sha": "61dfe55e99ad352a5ecaa450085bf7ee9d9eca2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2", "patch": "@@ -1,3 +1,12 @@\n+2014-07-23  Richard Biener  <rguenther@suse.de>\n+\n+\t* params.def (PARAM_MAX_COMBINE_INSNS): New.\n+\t* combine.c: Include statistics.h and params.h.\n+\t(combine_instructions): Guard three and four insn combines\n+\twith max-combine-insns value.  Record statistics for combines\n+\tperformed.\n+\t* doc/invoke.texi (max-combine-insns): Document new param.\n+\n 2014-07-23  Roman Gareev  <gareevroman@gmail.com>\n \n \t* graphite-isl-ast-to-gimple.c:"}, {"sha": "53ac1d6cca05d15daae7a534d2817a6b42296a36", "filename": "gcc/combine.c", "status": "modified", "additions": 211, "deletions": 180, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2", "patch": "@@ -104,6 +104,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"valtrack.h\"\n #include \"cgraph.h\"\n #include \"obstack.h\"\n+#include \"statistics.h\"\n+#include \"params.h\"\n \n /* Number of attempts to combine instructions in this function.  */\n \n@@ -1209,6 +1211,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   init_reg_last ();\n   setup_incoming_promotions (first);\n   last_bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  int max_combine = PARAM_VALUE (PARAM_MAX_COMBINE_INSNS);\n \n   FOR_EACH_BB_FN (this_basic_block, cfun)\n     {\n@@ -1229,218 +1232,246 @@ combine_instructions (rtx f, unsigned int nregs)\n \t   insn = next ? next : NEXT_INSN (insn))\n \t{\n \t  next = 0;\n-\t  if (NONDEBUG_INSN_P (insn))\n-\t    {\n-\t      while (last_combined_insn\n-\t\t     && INSN_DELETED_P (last_combined_insn))\n-\t\tlast_combined_insn = PREV_INSN (last_combined_insn);\n-\t      if (last_combined_insn == NULL_RTX\n-\t\t  || BARRIER_P (last_combined_insn)\n-\t\t  || BLOCK_FOR_INSN (last_combined_insn) != this_basic_block\n-\t\t  || DF_INSN_LUID (last_combined_insn) <= DF_INSN_LUID (insn))\n-\t\tlast_combined_insn = insn;\n-\n-\t      /* See if we know about function return values before this\n-\t\t insn based upon SUBREG flags.  */\n-\t      check_promoted_subreg (insn, PATTERN (insn));\n-\n-\t      /* See if we can find hardregs and subreg of pseudos in\n-\t\t narrower modes.  This could help turning TRUNCATEs\n-\t\t into SUBREGs.  */\n-\t      note_uses (&PATTERN (insn), record_truncated_values, NULL);\n-\n-\t      /* Try this insn with each insn it links back to.  */\n-\n-\t      FOR_EACH_LOG_LINK (links, insn)\n-\t\tif ((next = try_combine (insn, links->insn, NULL_RTX,\n-\t\t\t\t\t NULL_RTX, &new_direct_jump_p,\n-\t\t\t\t\t last_combined_insn)) != 0)\n-\t\t  goto retry;\n+\t  if (!NONDEBUG_INSN_P (insn))\n+\t    continue;\n+\n+\t  while (last_combined_insn\n+\t\t && INSN_DELETED_P (last_combined_insn))\n+\t    last_combined_insn = PREV_INSN (last_combined_insn);\n+\t  if (last_combined_insn == NULL_RTX\n+\t      || BARRIER_P (last_combined_insn)\n+\t      || BLOCK_FOR_INSN (last_combined_insn) != this_basic_block\n+\t      || DF_INSN_LUID (last_combined_insn) <= DF_INSN_LUID (insn))\n+\t    last_combined_insn = insn;\n+\n+\t  /* See if we know about function return values before this\n+\t     insn based upon SUBREG flags.  */\n+\t  check_promoted_subreg (insn, PATTERN (insn));\n+\n+\t  /* See if we can find hardregs and subreg of pseudos in\n+\t     narrower modes.  This could help turning TRUNCATEs\n+\t     into SUBREGs.  */\n+\t  note_uses (&PATTERN (insn), record_truncated_values, NULL);\n+\n+\t  /* Try this insn with each insn it links back to.  */\n+\n+\t  FOR_EACH_LOG_LINK (links, insn)\n+\t    if ((next = try_combine (insn, links->insn, NULL_RTX,\n+\t\t\t\t     NULL_RTX, &new_direct_jump_p,\n+\t\t\t\t     last_combined_insn)) != 0)\n+\t      {\n+\t\tstatistics_counter_event (cfun, \"two-insn combine\", 1);\n+\t\tgoto retry;\n+\t      }\n \n-\t      /* Try each sequence of three linked insns ending with this one.  */\n+\t  /* Try each sequence of three linked insns ending with this one.  */\n \n-\t      FOR_EACH_LOG_LINK (links, insn)\n-\t\t{\n-\t\t  rtx link = links->insn;\n+\t  if (max_combine >= 3)\n+\t    FOR_EACH_LOG_LINK (links, insn)\n+\t      {\n+\t\trtx link = links->insn;\n \n-\t\t  /* If the linked insn has been replaced by a note, then there\n-\t\t     is no point in pursuing this chain any further.  */\n-\t\t  if (NOTE_P (link))\n-\t\t    continue;\n+\t\t/* If the linked insn has been replaced by a note, then there\n+\t\t   is no point in pursuing this chain any further.  */\n+\t\tif (NOTE_P (link))\n+\t\t  continue;\n \n-\t\t  FOR_EACH_LOG_LINK (nextlinks, link)\n-\t\t    if ((next = try_combine (insn, link, nextlinks->insn,\n-\t\t\t\t\t     NULL_RTX, &new_direct_jump_p,\n-\t\t\t\t\t     last_combined_insn)) != 0)\n+\t\tFOR_EACH_LOG_LINK (nextlinks, link)\n+\t\t  if ((next = try_combine (insn, link, nextlinks->insn,\n+\t\t\t\t\t   NULL_RTX, &new_direct_jump_p,\n+\t\t\t\t\t   last_combined_insn)) != 0)\n+\t\t    {\n+\t\t      statistics_counter_event (cfun, \"three-insn combine\", 1);\n \t\t      goto retry;\n-\t\t}\n+\t\t    }\n+\t      }\n \n #ifdef HAVE_cc0\n-\t      /* Try to combine a jump insn that uses CC0\n-\t\t with a preceding insn that sets CC0, and maybe with its\n-\t\t logical predecessor as well.\n-\t\t This is how we make decrement-and-branch insns.\n-\t\t We need this special code because data flow connections\n-\t\t via CC0 do not get entered in LOG_LINKS.  */\n-\n-\t      if (JUMP_P (insn)\n-\t\t  && (prev = prev_nonnote_insn (insn)) != 0\n-\t\t  && NONJUMP_INSN_P (prev)\n-\t\t  && sets_cc0_p (PATTERN (prev)))\n-\t\t{\n-\t\t  if ((next = try_combine (insn, prev, NULL_RTX, NULL_RTX,\n-\t\t\t\t\t   &new_direct_jump_p,\n+\t  /* Try to combine a jump insn that uses CC0\n+\t     with a preceding insn that sets CC0, and maybe with its\n+\t     logical predecessor as well.\n+\t     This is how we make decrement-and-branch insns.\n+\t     We need this special code because data flow connections\n+\t     via CC0 do not get entered in LOG_LINKS.  */\n+\n+\t  if (JUMP_P (insn)\n+\t      && (prev = prev_nonnote_insn (insn)) != 0\n+\t      && NONJUMP_INSN_P (prev)\n+\t      && sets_cc0_p (PATTERN (prev)))\n+\t    {\n+\t      if ((next = try_combine (insn, prev, NULL_RTX, NULL_RTX,\n+\t\t\t\t       &new_direct_jump_p,\n+\t\t\t\t       last_combined_insn)) != 0)\n+\t\tgoto retry;\n+\n+\t      FOR_EACH_LOG_LINK (nextlinks, prev)\n+\t\t  if ((next = try_combine (insn, prev, nextlinks->insn,\n+\t\t\t\t\t   NULL_RTX, &new_direct_jump_p,\n \t\t\t\t\t   last_combined_insn)) != 0)\n \t\t    goto retry;\n+\t    }\n \n-\t\t  FOR_EACH_LOG_LINK (nextlinks, prev)\n-\t\t    if ((next = try_combine (insn, prev, nextlinks->insn,\n-\t\t\t\t\t     NULL_RTX, &new_direct_jump_p,\n-\t\t\t\t\t     last_combined_insn)) != 0)\n-\t\t      goto retry;\n-\t\t}\n+\t  /* Do the same for an insn that explicitly references CC0.  */\n+\t  if (NONJUMP_INSN_P (insn)\n+\t      && (prev = prev_nonnote_insn (insn)) != 0\n+\t      && NONJUMP_INSN_P (prev)\n+\t      && sets_cc0_p (PATTERN (prev))\n+\t      && GET_CODE (PATTERN (insn)) == SET\n+\t      && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (insn))))\n+\t    {\n+\t      if ((next = try_combine (insn, prev, NULL_RTX, NULL_RTX,\n+\t\t\t\t       &new_direct_jump_p,\n+\t\t\t\t       last_combined_insn)) != 0)\n+\t\tgoto retry;\n \n-\t      /* Do the same for an insn that explicitly references CC0.  */\n-\t      if (NONJUMP_INSN_P (insn)\n-\t\t  && (prev = prev_nonnote_insn (insn)) != 0\n-\t\t  && NONJUMP_INSN_P (prev)\n-\t\t  && sets_cc0_p (PATTERN (prev))\n-\t\t  && GET_CODE (PATTERN (insn)) == SET\n-\t\t  && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (insn))))\n-\t\t{\n-\t\t  if ((next = try_combine (insn, prev, NULL_RTX, NULL_RTX,\n-\t\t\t\t\t   &new_direct_jump_p,\n+\t      FOR_EACH_LOG_LINK (nextlinks, prev)\n+\t\t  if ((next = try_combine (insn, prev, nextlinks->insn,\n+\t\t\t\t\t   NULL_RTX, &new_direct_jump_p,\n \t\t\t\t\t   last_combined_insn)) != 0)\n \t\t    goto retry;\n+\t    }\n \n-\t\t  FOR_EACH_LOG_LINK (nextlinks, prev)\n-\t\t    if ((next = try_combine (insn, prev, nextlinks->insn,\n-\t\t\t\t\t     NULL_RTX, &new_direct_jump_p,\n-\t\t\t\t\t     last_combined_insn)) != 0)\n-\t\t      goto retry;\n-\t\t}\n-\n-\t      /* Finally, see if any of the insns that this insn links to\n-\t\t explicitly references CC0.  If so, try this insn, that insn,\n-\t\t and its predecessor if it sets CC0.  */\n-\t      FOR_EACH_LOG_LINK (links, insn)\n-\t\tif (NONJUMP_INSN_P (links->insn)\n-\t\t    && GET_CODE (PATTERN (links->insn)) == SET\n-\t\t    && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (links->insn)))\n-\t\t    && (prev = prev_nonnote_insn (links->insn)) != 0\n-\t\t    && NONJUMP_INSN_P (prev)\n-\t\t    && sets_cc0_p (PATTERN (prev))\n-\t\t    && (next = try_combine (insn, links->insn,\n-\t\t\t\t\t    prev, NULL_RTX, &new_direct_jump_p,\n-\t\t\t\t\t    last_combined_insn)) != 0)\n-\t\t  goto retry;\n+\t  /* Finally, see if any of the insns that this insn links to\n+\t     explicitly references CC0.  If so, try this insn, that insn,\n+\t     and its predecessor if it sets CC0.  */\n+\t  FOR_EACH_LOG_LINK (links, insn)\n+\t      if (NONJUMP_INSN_P (links->insn)\n+\t\t  && GET_CODE (PATTERN (links->insn)) == SET\n+\t\t  && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (links->insn)))\n+\t\t  && (prev = prev_nonnote_insn (links->insn)) != 0\n+\t\t  && NONJUMP_INSN_P (prev)\n+\t\t  && sets_cc0_p (PATTERN (prev))\n+\t\t  && (next = try_combine (insn, links->insn,\n+\t\t\t\t\t  prev, NULL_RTX, &new_direct_jump_p,\n+\t\t\t\t\t  last_combined_insn)) != 0)\n+\t\tgoto retry;\n #endif\n \n-\t      /* Try combining an insn with two different insns whose results it\n-\t\t uses.  */\n-\t      FOR_EACH_LOG_LINK (links, insn)\n-\t\tfor (nextlinks = links->next; nextlinks;\n-\t\t     nextlinks = nextlinks->next)\n-\t\t  if ((next = try_combine (insn, links->insn,\n-\t\t\t\t\t   nextlinks->insn, NULL_RTX,\n-\t\t\t\t\t   &new_direct_jump_p,\n-\t\t\t\t\t   last_combined_insn)) != 0)\n+\t  /* Try combining an insn with two different insns whose results it\n+\t     uses.  */\n+\t  if (max_combine >= 3)\n+\t    FOR_EACH_LOG_LINK (links, insn)\n+\t      for (nextlinks = links->next; nextlinks;\n+\t\t   nextlinks = nextlinks->next)\n+\t\tif ((next = try_combine (insn, links->insn,\n+\t\t\t\t\t nextlinks->insn, NULL_RTX,\n+\t\t\t\t\t &new_direct_jump_p,\n+\t\t\t\t\t last_combined_insn)) != 0)\n+\n+\t\t  {\n+\t\t    statistics_counter_event (cfun, \"three-insn combine\", 1);\n \t\t    goto retry;\n+\t\t  }\n \n-\t      /* Try four-instruction combinations.  */\n-\t      FOR_EACH_LOG_LINK (links, insn)\n-\t\t{\n-\t\t  struct insn_link *next1;\n-\t\t  rtx link = links->insn;\n+\t  /* Try four-instruction combinations.  */\n+\t  if (max_combine >= 4)\n+\t    FOR_EACH_LOG_LINK (links, insn)\n+\t      {\n+\t\tstruct insn_link *next1;\n+\t\trtx link = links->insn;\n \n-\t\t  /* If the linked insn has been replaced by a note, then there\n-\t\t     is no point in pursuing this chain any further.  */\n-\t\t  if (NOTE_P (link))\n-\t\t    continue;\n+\t\t/* If the linked insn has been replaced by a note, then there\n+\t\t   is no point in pursuing this chain any further.  */\n+\t\tif (NOTE_P (link))\n+\t\t  continue;\n \n-\t\t  FOR_EACH_LOG_LINK (next1, link)\n-\t\t    {\n-\t\t      rtx link1 = next1->insn;\n-\t\t      if (NOTE_P (link1))\n-\t\t\tcontinue;\n-\t\t      /* I0 -> I1 -> I2 -> I3.  */\n-\t\t      FOR_EACH_LOG_LINK (nextlinks, link1)\n-\t\t\tif ((next = try_combine (insn, link, link1,\n-\t\t\t\t\t\t nextlinks->insn,\n-\t\t\t\t\t\t &new_direct_jump_p,\n-\t\t\t\t\t\t last_combined_insn)) != 0)\n+\t\tFOR_EACH_LOG_LINK (next1, link)\n+\t\t  {\n+\t\t    rtx link1 = next1->insn;\n+\t\t    if (NOTE_P (link1))\n+\t\t      continue;\n+\t\t    /* I0 -> I1 -> I2 -> I3.  */\n+\t\t    FOR_EACH_LOG_LINK (nextlinks, link1)\n+\t\t      if ((next = try_combine (insn, link, link1,\n+\t\t\t\t\t       nextlinks->insn,\n+\t\t\t\t\t       &new_direct_jump_p,\n+\t\t\t\t\t       last_combined_insn)) != 0)\n+\t\t\t{\n+\t\t\t  statistics_counter_event (cfun, \"four-insn combine\", 1);\n \t\t\t  goto retry;\n-\t\t      /* I0, I1 -> I2, I2 -> I3.  */\n-\t\t      for (nextlinks = next1->next; nextlinks;\n-\t\t\t   nextlinks = nextlinks->next)\n-\t\t\tif ((next = try_combine (insn, link, link1,\n-\t\t\t\t\t\t nextlinks->insn,\n-\t\t\t\t\t\t &new_direct_jump_p,\n-\t\t\t\t\t\t last_combined_insn)) != 0)\n+\t\t\t}\n+\t\t    /* I0, I1 -> I2, I2 -> I3.  */\n+\t\t    for (nextlinks = next1->next; nextlinks;\n+\t\t\t nextlinks = nextlinks->next)\n+\t\t      if ((next = try_combine (insn, link, link1,\n+\t\t\t\t\t       nextlinks->insn,\n+\t\t\t\t\t       &new_direct_jump_p,\n+\t\t\t\t\t       last_combined_insn)) != 0)\n+\t\t\t{\n+\t\t\t  statistics_counter_event (cfun, \"four-insn combine\", 1);\n \t\t\t  goto retry;\n-\t\t    }\n+\t\t\t}\n+\t\t  }\n \n-\t\t  for (next1 = links->next; next1; next1 = next1->next)\n-\t\t    {\n-\t\t      rtx link1 = next1->insn;\n-\t\t      if (NOTE_P (link1))\n-\t\t\tcontinue;\n-\t\t      /* I0 -> I2; I1, I2 -> I3.  */\n-\t\t      FOR_EACH_LOG_LINK (nextlinks, link)\n-\t\t\tif ((next = try_combine (insn, link, link1,\n-\t\t\t\t\t\t nextlinks->insn,\n-\t\t\t\t\t\t &new_direct_jump_p,\n-\t\t\t\t\t\t last_combined_insn)) != 0)\n+\t\tfor (next1 = links->next; next1; next1 = next1->next)\n+\t\t  {\n+\t\t    rtx link1 = next1->insn;\n+\t\t    if (NOTE_P (link1))\n+\t\t      continue;\n+\t\t    /* I0 -> I2; I1, I2 -> I3.  */\n+\t\t    FOR_EACH_LOG_LINK (nextlinks, link)\n+\t\t      if ((next = try_combine (insn, link, link1,\n+\t\t\t\t\t       nextlinks->insn,\n+\t\t\t\t\t       &new_direct_jump_p,\n+\t\t\t\t\t       last_combined_insn)) != 0)\n+\t\t\t{\n+\t\t\t  statistics_counter_event (cfun, \"four-insn combine\", 1);\n \t\t\t  goto retry;\n-\t\t      /* I0 -> I1; I1, I2 -> I3.  */\n-\t\t      FOR_EACH_LOG_LINK (nextlinks, link1)\n-\t\t\tif ((next = try_combine (insn, link, link1,\n-\t\t\t\t\t\t nextlinks->insn,\n-\t\t\t\t\t\t &new_direct_jump_p,\n-\t\t\t\t\t\t last_combined_insn)) != 0)\n+\t\t\t}\n+\t\t    /* I0 -> I1; I1, I2 -> I3.  */\n+\t\t    FOR_EACH_LOG_LINK (nextlinks, link1)\n+\t\t      if ((next = try_combine (insn, link, link1,\n+\t\t\t\t\t       nextlinks->insn,\n+\t\t\t\t\t       &new_direct_jump_p,\n+\t\t\t\t\t       last_combined_insn)) != 0)\n+\t\t\t{\n+\t\t\t  statistics_counter_event (cfun, \"four-insn combine\", 1);\n \t\t\t  goto retry;\n-\t\t    }\n-\t\t}\n+\t\t\t}\n+\t\t  }\n+\t      }\n \n-\t      /* Try this insn with each REG_EQUAL note it links back to.  */\n-\t      FOR_EACH_LOG_LINK (links, insn)\n+\t  /* Try this insn with each REG_EQUAL note it links back to.  */\n+\t  FOR_EACH_LOG_LINK (links, insn)\n+\t    {\n+\t      rtx set, note;\n+\t      rtx temp = links->insn;\n+\t      if ((set = single_set (temp)) != 0\n+\t\t  && (note = find_reg_equal_equiv_note (temp)) != 0\n+\t\t  && (note = XEXP (note, 0), GET_CODE (note)) != EXPR_LIST\n+\t\t  /* Avoid using a register that may already been marked\n+\t\t     dead by an earlier instruction.  */\n+\t\t  && ! unmentioned_reg_p (note, SET_SRC (set))\n+\t\t  && (GET_MODE (note) == VOIDmode\n+\t\t      ? SCALAR_INT_MODE_P (GET_MODE (SET_DEST (set)))\n+\t\t      : GET_MODE (SET_DEST (set)) == GET_MODE (note)))\n \t\t{\n-\t\t  rtx set, note;\n-\t\t  rtx temp = links->insn;\n-\t\t  if ((set = single_set (temp)) != 0\n-\t\t      && (note = find_reg_equal_equiv_note (temp)) != 0\n-\t\t      && (note = XEXP (note, 0), GET_CODE (note)) != EXPR_LIST\n-\t\t      /* Avoid using a register that may already been marked\n-\t\t\t dead by an earlier instruction.  */\n-\t\t      && ! unmentioned_reg_p (note, SET_SRC (set))\n-\t\t      && (GET_MODE (note) == VOIDmode\n-\t\t\t  ? SCALAR_INT_MODE_P (GET_MODE (SET_DEST (set)))\n-\t\t\t  : GET_MODE (SET_DEST (set)) == GET_MODE (note)))\n+\t\t  /* Temporarily replace the set's source with the\n+\t\t     contents of the REG_EQUAL note.  The insn will\n+\t\t     be deleted or recognized by try_combine.  */\n+\t\t  rtx orig = SET_SRC (set);\n+\t\t  SET_SRC (set) = note;\n+\t\t  i2mod = temp;\n+\t\t  i2mod_old_rhs = copy_rtx (orig);\n+\t\t  i2mod_new_rhs = copy_rtx (note);\n+\t\t  next = try_combine (insn, i2mod, NULL_RTX, NULL_RTX,\n+\t\t\t\t      &new_direct_jump_p,\n+\t\t\t\t      last_combined_insn);\n+\t\t  i2mod = NULL_RTX;\n+\t\t  if (next)\n \t\t    {\n-\t\t      /* Temporarily replace the set's source with the\n-\t\t\t contents of the REG_EQUAL note.  The insn will\n-\t\t\t be deleted or recognized by try_combine.  */\n-\t\t      rtx orig = SET_SRC (set);\n-\t\t      SET_SRC (set) = note;\n-\t\t      i2mod = temp;\n-\t\t      i2mod_old_rhs = copy_rtx (orig);\n-\t\t      i2mod_new_rhs = copy_rtx (note);\n-\t\t      next = try_combine (insn, i2mod, NULL_RTX, NULL_RTX,\n-\t\t\t\t\t  &new_direct_jump_p,\n-\t\t\t\t\t  last_combined_insn);\n-\t\t      i2mod = NULL_RTX;\n-\t\t      if (next)\n-\t\t\tgoto retry;\n-\t\t      SET_SRC (set) = orig;\n+\t\t      statistics_counter_event (cfun, \"insn-with-note combine\", 1);\n+\t\t      goto retry;\n \t\t    }\n+\t\t  SET_SRC (set) = orig;\n \t\t}\n+\t    }\n \n-\t      if (!NOTE_P (insn))\n-\t\trecord_dead_and_set_regs (insn);\n+\t  if (!NOTE_P (insn))\n+\t    record_dead_and_set_regs (insn);\n \n-\t    retry:\n-\t      ;\n-\t    }\n+retry:\n+\t  ;\n \t}\n     }\n "}, {"sha": "fc2d78a055602007e487a1e7740e9592720a4643", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2", "patch": "@@ -10006,6 +10006,10 @@ The maximum size measured as number of RTLs that can be recorded in an expressio\n in combiner for a pseudo register as last known value of that register.  The default\n is 10000.\n \n+@item max-combine-insns\n+The maximum number of instructions the RTL combiner tries to combine.\n+The default value is 2 at @option{-Og} and 4 otherwise.\n+\n @item integer-share-limit\n Small integer constants can use a shared data structure, reducing the\n compiler's memory usage and increasing its speed.  This sets the maximum"}, {"sha": "595a093a88c78783e29e41a3c822a7635fef4eb8", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=e9a8fc239e24b5afc496a5f8595c3dc2c476b1c2", "patch": "@@ -673,6 +673,11 @@ DEFPARAM(PARAM_MAX_LAST_VALUE_RTL,\n \t \"The maximum number of RTL nodes that can be recorded as combiner's last value\",\n \t 10000, 0, 0)\n \n+DEFPARAM(PARAM_MAX_COMBINE_INSNS,\n+\t \"max-combine-insns\",\n+\t \"The maximum number of insns combine tries to combine\",\n+\t 4, 2, 4)\n+\n /* INTEGER_CST nodes are shared for values [{-1,0} .. N) for\n    {signed,unsigned} integral types.  This determines N.\n    Experimentation shows 251 to be a good value that generates the"}]}