{"sha": "e561a9920cce1e638826a53599eb55ec44ce54c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU2MWE5OTIwY2NlMWU2Mzg4MjZhNTM1OTllYjU1ZWM0NGNlNTRjMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2012-10-09T18:20:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-10-09T18:20:45Z"}, "message": "Add support for tracing through shared libraries.\n\n\t* configure.ac: Check for link.h and dl_iterate_phdr.\n\t* elf.c: #include <link.h> if system has dl_iterate_phdr.  #undef\n\tELF macros before #defining them.\n\t(dl_phdr_info, dl_iterate_phdr): Define if system does not have\n\tdl_iterate_phdr.\n\t(struct elf_syminfo_data): Add next field.\n\t(elf_initialize_syminfo): Initialize next field.\n\t(elf_add_syminfo_data): New static function.\n\t(elf_add): New static function, broken out of\n\tbacktrace_initialize.  Call backtrace_dwarf_add instead of\n\tbacktrace_dwarf_initialize.\n\t(struct phdr_data): Define.\n\t(phdr_callback): New static function.\n\t(backtrace_initialize): Call elf_add.\n\t* dwarf.c (struct dwarf_data): Add next and base_address fields.\n\t(add_unit_addr): Add base_address parameter.  Change all callers.\n\t(add_unit_ranges, build_address_map): Likewise.\n\t(add_line): Add ddata parameter.  Change all callers.\n\t(read_line_program, add_function_range): Likewise.\n\t(dwarf_lookup_pc): New static function, broken out of\n\tdwarf_fileline.\n\t(dwarf_fileline): Call dwarf_lookup_pc.\n\t(build_dwarf_data): New static function.\n\t(backtrace_dwarf_add): New function.\n\t(backtrace_dwarf_initialize): Remove.\n\t* internal.h (backtrace_dwarf_initialize): Don't declare.\n\t(backtrace_dwarf_add): Declare.\n\t* configure, config.h.in: Rebuild.\n\nFrom-SVN: r192267", "tree": {"sha": "cf3815f8c8b0babee15a42892364a912abc14de3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf3815f8c8b0babee15a42892364a912abc14de3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e561a9920cce1e638826a53599eb55ec44ce54c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e561a9920cce1e638826a53599eb55ec44ce54c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e561a9920cce1e638826a53599eb55ec44ce54c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e561a9920cce1e638826a53599eb55ec44ce54c2/comments", "author": null, "committer": null, "parents": [{"sha": "1a61077e0ef68c9c4453f86c408a302518dd8075", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a61077e0ef68c9c4453f86c408a302518dd8075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a61077e0ef68c9c4453f86c408a302518dd8075"}], "stats": {"total": 685, "additions": 579, "deletions": 106}, "files": [{"sha": "f9d68627767e1c36ad34f07c207c7a0d9d01721f", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=e561a9920cce1e638826a53599eb55ec44ce54c2", "patch": "@@ -1,7 +1,39 @@\n+2012-10-09  Ian Lance Taylor  <iant@google.com>\n+\n+\tAdd support for tracing through shared libraries.\n+\t* configure.ac: Check for link.h and dl_iterate_phdr.\n+\t* elf.c: #include <link.h> if system has dl_iterate_phdr.  #undef\n+\tELF macros before #defining them.\n+\t(dl_phdr_info, dl_iterate_phdr): Define if system does not have\n+\tdl_iterate_phdr.\n+\t(struct elf_syminfo_data): Add next field.\n+\t(elf_initialize_syminfo): Initialize next field.\n+\t(elf_add_syminfo_data): New static function.\n+\t(elf_add): New static function, broken out of\n+\tbacktrace_initialize.  Call backtrace_dwarf_add instead of\n+\tbacktrace_dwarf_initialize.\n+\t(struct phdr_data): Define.\n+\t(phdr_callback): New static function.\n+\t(backtrace_initialize): Call elf_add.\n+\t* dwarf.c (struct dwarf_data): Add next and base_address fields.\n+\t(add_unit_addr): Add base_address parameter.  Change all callers.\n+\t(add_unit_ranges, build_address_map): Likewise.\n+\t(add_line): Add ddata parameter.  Change all callers.\n+\t(read_line_program, add_function_range): Likewise.\n+\t(dwarf_lookup_pc): New static function, broken out of\n+\tdwarf_fileline.\n+\t(dwarf_fileline): Call dwarf_lookup_pc.\n+\t(build_dwarf_data): New static function.\n+\t(backtrace_dwarf_add): New function.\n+\t(backtrace_dwarf_initialize): Remove.\n+\t* internal.h (backtrace_dwarf_initialize): Don't declare.\n+\t(backtrace_dwarf_add): Declare.\n+\t* configure, config.h.in: Rebuild.\n+\n 2012-10-04  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* btest.c (f23): Avoid uninitialized variable warning.\n-\t\n+\n 2012-10-04  Ian Lance Taylor  <iant@google.com>\n \n \t* dwarf.c: If the system header files do not declare strnlen,"}, {"sha": "ba564a82e85c795ff32a121cf487625045ed77fa", "filename": "libbacktrace/config.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfig.h.in?ref=e561a9920cce1e638826a53599eb55ec44ce54c2", "patch": "@@ -10,6 +10,9 @@\n /* Define to 1 if you have the <dlfcn.h> header file. */\n #undef HAVE_DLFCN_H\n \n+/* Define if dl_iterate_phdr is available. */\n+#undef HAVE_DL_ITERATE_PHDR\n+\n /* Define to 1 if you have the fcntl function */\n #undef HAVE_FCNTL\n \n@@ -19,6 +22,9 @@\n /* Define to 1 if you have the <inttypes.h> header file. */\n #undef HAVE_INTTYPES_H\n \n+/* Define to 1 if you have the <link.h> header file. */\n+#undef HAVE_LINK_H\n+\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n "}, {"sha": "8d34856e693edcdd196a15931a97c0e95096b192", "filename": "libbacktrace/configure", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=e561a9920cce1e638826a53599eb55ec44ce54c2", "patch": "@@ -12182,6 +12182,53 @@ if test \"$ALLOC_FILE\" = \"alloc.lo\"; then\n fi\n \n \n+# Check for dl_iterate_phdr.\n+for ac_header in link.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"link.h\" \"ac_cv_header_link_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_link_h\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_LINK_H 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n+if test \"$ac_cv_header_link_h\" = \"no\"; then\n+  have_dl_iterate_phdr=no\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+    # When built as a GCC target library, we can't do a link test.\n+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <link.h>\n+\n+_ACEOF\n+if (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n+  $EGREP \"dl_iterate_phdr\" >/dev/null 2>&1; then :\n+  have_dl_iterate_phdr=yes\n+else\n+  have_dl_iterate_phdr=no\n+fi\n+rm -f conftest*\n+\n+  else\n+    ac_fn_c_check_func \"$LINENO\" \"dl_iterate_phdr\" \"ac_cv_func_dl_iterate_phdr\"\n+if test \"x$ac_cv_func_dl_iterate_phdr\" = x\"\"yes; then :\n+  have_dl_iterate_phdr=yes\n+else\n+  have_dl_iterate_phdr=no\n+fi\n+\n+  fi\n+fi\n+if test \"$have_dl_iterate_phdr\" = \"yes\"; then\n+\n+$as_echo \"#define HAVE_DL_ITERATE_PHDR 1\" >>confdefs.h\n+\n+fi\n+\n # Check for the fcntl function.\n if test -n \"${with_target_subdir}\"; then\n    case \"${host}\" in"}, {"sha": "083a086c85a35fae5241594b56bc3a6c484ec648", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=e561a9920cce1e638826a53599eb55ec44ce54c2", "patch": "@@ -226,6 +226,24 @@ if test \"$ALLOC_FILE\" = \"alloc.lo\"; then\n fi\n AC_SUBST(BACKTRACE_USES_MALLOC)\n \n+# Check for dl_iterate_phdr.\n+AC_CHECK_HEADERS(link.h)\n+if test \"$ac_cv_header_link_h\" = \"no\"; then\n+  have_dl_iterate_phdr=no\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+    # When built as a GCC target library, we can't do a link test.\n+    AC_EGREP_HEADER([dl_iterate_phdr], [link.h], [have_dl_iterate_phdr=yes],\n+\t\t    [have_dl_iterate_phdr=no])\n+  else\n+    AC_CHECK_FUNC([dl_iterate_phdr], [have_dl_iterate_phdr=yes],\n+\t\t  [have_dl_iterate_phdr=no])\n+  fi\n+fi\n+if test \"$have_dl_iterate_phdr\" = \"yes\"; then\n+  AC_DEFINE(HAVE_DL_ITERATE_PHDR, 1, [Define if dl_iterate_phdr is available.])\n+fi\n+\n # Check for the fcntl function.\n if test -n \"${with_target_subdir}\"; then\n    case \"${host}\" in"}, {"sha": "1b28a8f09b8a6229f14f7eef8054a706603e0fe3", "filename": "libbacktrace/dwarf.c", "status": "modified", "additions": 215, "deletions": 60, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=e561a9920cce1e638826a53599eb55ec44ce54c2", "patch": "@@ -333,6 +333,10 @@ struct unit_addrs_vector\n \n struct dwarf_data\n {\n+  /* The data for the next file we know about.  */\n+  struct dwarf_data *next;\n+  /* The base address for this file.  */\n+  uintptr_t base_address;\n   /* A sorted list of address ranges.  */\n   struct unit_addrs *addrs;\n   /* Number of address ranges in list.  */\n@@ -831,12 +835,18 @@ function_addrs_search (const void *vkey, const void *ventry)\n    success, 0 on failure.  */\n \n static int\n-add_unit_addr (struct backtrace_state *state, struct unit_addrs addrs,\n+add_unit_addr (struct backtrace_state *state, uintptr_t base_address,\n+\t       struct unit_addrs addrs,\n \t       backtrace_error_callback error_callback, void *data,\n \t       struct unit_addrs_vector *vec)\n {\n   struct unit_addrs *p;\n \n+  /* Add in the base address of the module here, so that we can look\n+     up the PC directly.  */\n+  addrs.low += base_address;\n+  addrs.high += base_address;\n+\n   /* Try to merge with the last entry.  */\n   if (vec->count > 0)\n     {\n@@ -1156,9 +1166,10 @@ lookup_abbrev (struct abbrevs *abbrevs, uint64_t code,\n    1 on success, 0 on failure.  */\n \n static int\n-add_unit_ranges (struct backtrace_state *state, struct unit *u,\n-\t\t uint64_t ranges, uint64_t base, int is_bigendian,\n-\t\t const unsigned char *dwarf_ranges, size_t dwarf_ranges_size,\n+add_unit_ranges (struct backtrace_state *state, uintptr_t base_address,\n+\t\t struct unit *u, uint64_t ranges, uint64_t base,\n+\t\t int is_bigendian, const unsigned char *dwarf_ranges,\n+\t\t size_t dwarf_ranges_size,\n \t\t backtrace_error_callback error_callback, void *data,\n \t\t struct unit_addrs_vector *addrs)\n {\n@@ -1202,7 +1213,8 @@ add_unit_ranges (struct backtrace_state *state, struct unit *u,\n \t  a.low = low + base;\n \t  a.high = high + base;\n \t  a.u = u;\n-\t  if (!add_unit_addr (state, a, error_callback, data, addrs))\n+\t  if (!add_unit_addr (state, base_address, a, error_callback, data,\n+\t\t\t      addrs))\n \t    return 0;\n \t}\n     }\n@@ -1218,7 +1230,7 @@ add_unit_ranges (struct backtrace_state *state, struct unit *u,\n    on success, 0 on failure.  */\n \n static int\n-build_address_map (struct backtrace_state *state,\n+build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \t\t   const unsigned char *dwarf_info, size_t dwarf_info_size,\n \t\t   const unsigned char *dwarf_abbrev, size_t dwarf_abbrev_size,\n \t\t   const unsigned char *dwarf_ranges, size_t dwarf_ranges_size,\n@@ -1417,9 +1429,10 @@ build_address_map (struct backtrace_state *state,\n \n \t  if (have_ranges)\n \t    {\n-\t      if (!add_unit_ranges (state, u, ranges, lowpc, is_bigendian,\n-\t\t\t\t    dwarf_ranges, dwarf_ranges_size,\n-\t\t\t\t    error_callback, data, addrs))\n+\t      if (!add_unit_ranges (state, base_address, u, ranges, lowpc,\n+\t\t\t\t    is_bigendian, dwarf_ranges,\n+\t\t\t\t    dwarf_ranges_size, error_callback, data,\n+\t\t\t\t    addrs))\n \t\t{\n \t\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n \t\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n@@ -1434,7 +1447,8 @@ build_address_map (struct backtrace_state *state,\n \t      a.high = highpc;\n \t      a.u = u;\n \n-\t      if (!add_unit_addr (state, a, error_callback, data, addrs))\n+\t      if (!add_unit_addr (state, base_address, a, error_callback, data,\n+\t\t\t\t  addrs))\n \t\t{\n \t\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n \t\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n@@ -1463,8 +1477,9 @@ build_address_map (struct backtrace_state *state,\n    building.  Returns 1 on success, 0 on failure.  */\n \n static int\n-add_line (struct backtrace_state *state, uintptr_t pc, const char *filename,\n-\t  int lineno, backtrace_error_callback error_callback, void *data,\n+add_line (struct backtrace_state *state, struct dwarf_data *ddata,\n+\t  uintptr_t pc, const char *filename, int lineno,\n+\t  backtrace_error_callback error_callback, void *data,\n \t  struct line_vector *vec)\n {\n   struct line *ln;\n@@ -1484,7 +1499,10 @@ add_line (struct backtrace_state *state, uintptr_t pc, const char *filename,\n   if (ln == NULL)\n     return 0;\n \n-  ln->pc = pc;\n+  /* Add in the base address here, so that we can look up the PC\n+     directly.  */\n+  ln->pc = pc + ddata->base_address;\n+\n   ln->filename = filename;\n   ln->lineno = lineno;\n \n@@ -1672,9 +1690,9 @@ read_line_header (struct backtrace_state *state, struct unit *u,\n    success, 0 on failure.  */\n \n static int\n-read_line_program (struct backtrace_state *state, struct unit *u,\n-\t\t   const struct line_header *hdr, struct dwarf_buf *line_buf,\n-\t\t   struct line_vector *vec)\n+read_line_program (struct backtrace_state *state, struct dwarf_data *ddata,\n+\t\t   struct unit *u, const struct line_header *hdr,\n+\t\t   struct dwarf_buf *line_buf, struct line_vector *vec)\n {\n   uint64_t address;\n   unsigned int op_index;\n@@ -1706,8 +1724,8 @@ read_line_program (struct backtrace_state *state, struct unit *u,\n \t\t      / hdr->max_ops_per_insn);\n \t  op_index = (op_index + advance) % hdr->max_ops_per_insn;\n \t  lineno += hdr->line_base + (int) (op % hdr->line_range);\n-\t  add_line (state, address, filename, lineno, line_buf->error_callback,\n-\t\t    line_buf->data, vec);\n+\t  add_line (state, ddata, address, filename, lineno,\n+\t\t    line_buf->error_callback, line_buf->data, vec);\n \t}\n       else if (op == DW_LNS_extended_op)\n \t{\n@@ -1795,7 +1813,7 @@ read_line_program (struct backtrace_state *state, struct unit *u,\n \t  switch (op)\n \t    {\n \t    case DW_LNS_copy:\n-\t      add_line (state, address, filename, lineno,\n+\t      add_line (state, ddata, address, filename, lineno,\n \t\t\tline_buf->error_callback, line_buf->data, vec);\n \t      break;\n \t    case DW_LNS_advance_pc:\n@@ -1923,7 +1941,7 @@ read_line_info (struct backtrace_state *state, struct dwarf_data *ddata,\n   if (!read_line_header (state, u, is_dwarf64, &line_buf, hdr))\n     goto fail;\n \n-  if (!read_line_program (state, u, hdr, &line_buf, &vec))\n+  if (!read_line_program (state, ddata, u, hdr, &line_buf, &vec))\n     goto fail;\n \n   if (line_buf.reported_underflow)\n@@ -2076,13 +2094,18 @@ read_referenced_name (struct dwarf_data *ddata, struct unit *u,\n    success, 0 on error.  */\n \n static int\n-add_function_range (struct backtrace_state *state, struct function *function,\n-\t\t    uint64_t lowpc, uint64_t highpc,\n+add_function_range (struct backtrace_state *state, struct dwarf_data *ddata,\n+\t\t    struct function *function, uint64_t lowpc, uint64_t highpc,\n \t\t    backtrace_error_callback error_callback,\n \t\t    void *data, struct function_vector *vec)\n {\n   struct function_addrs *p;\n \n+  /* Add in the base address here, so that we can look up the PC\n+     directly.  */\n+  lowpc += ddata->base_address;\n+  highpc += ddata->base_address;\n+\n   if (vec->count > 0)\n     {\n       p = (struct function_addrs *) vec->vec.base + vec->count - 1;\n@@ -2153,8 +2176,8 @@ add_function_ranges (struct backtrace_state *state, struct dwarf_data *ddata,\n \tbase = high;\n       else\n \t{\n-\t  if (!add_function_range (state, function, low + base, high + base,\n-\t\t\t\t   error_callback, data, vec))\n+\t  if (!add_function_range (state, ddata, function, low + base,\n+\t\t\t\t   high + base, error_callback, data, vec))\n \t    return 0;\n \t}\n     }\n@@ -2364,7 +2387,7 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \t    {\n \t      if (highpc_is_relative)\n \t\thighpc += lowpc;\n-\t      if (!add_function_range (state, function, lowpc, highpc,\n+\t      if (!add_function_range (state, ddata, function, lowpc, highpc,\n \t\t\t\t       error_callback, data, vec))\n \t\treturn 0;\n \t    }\n@@ -2522,15 +2545,17 @@ report_inlined_functions (uintptr_t pc, struct function *function,\n   return 0;\n }\n \n-/* Return the file/line information for a PC using the DWARF mapping\n-   we built earlier.  */\n+/* Look for a PC in the DWARF mapping for one module.  On success,\n+   call CALLBACK and return whatever it returns.  On error, call\n+   ERROR_CALLBACK and return 0.  Sets *FOUND to 1 if the PC is found,\n+   0 if not.  */\n \n static int\n-dwarf_fileline (struct backtrace_state *state, uintptr_t pc,\n-\t\tbacktrace_full_callback callback,\n-\t\tbacktrace_error_callback error_callback, void *data)\n+dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n+\t\t uintptr_t pc, backtrace_full_callback callback,\n+\t\t backtrace_error_callback error_callback, void *data,\n+\t\t int *found)\n {\n-  struct dwarf_data *ddata;\n   struct unit_addrs *entry;\n   struct unit *u;\n   int new_data;\n@@ -2542,14 +2567,17 @@ dwarf_fileline (struct backtrace_state *state, uintptr_t pc,\n   int lineno;\n   int ret;\n \n-  ddata = (struct dwarf_data *) state->fileline_data;\n+  *found = 1;\n \n   /* Find an address range that includes PC.  */\n   entry = bsearch (&pc, ddata->addrs, ddata->addrs_count,\n \t\t   sizeof (struct unit_addrs), unit_addrs_search);\n \n   if (entry == NULL)\n-    return callback (data, pc, NULL, 0, NULL);\n+    {\n+      *found = 0;\n+      return 0;\n+    }\n \n   /* If there are multiple ranges that contain PC, use the last one,\n      in order to produce predictable results.  If we assume that all\n@@ -2656,7 +2684,8 @@ dwarf_fileline (struct backtrace_state *state, uintptr_t pc,\n \t try again to see if there is a better compilation unit for\n \t this PC.  */\n       if (new_data)\n-\tdwarf_fileline (state, pc, callback, error_callback, data);\n+\treturn dwarf_lookup_pc (state, ddata, pc, callback, error_callback,\n+\t\t\t\tdata, found);\n       return callback (data, pc, NULL, 0, NULL);\n     }\n \n@@ -2705,39 +2734,93 @@ dwarf_fileline (struct backtrace_state *state, uintptr_t pc,\n   return callback (data, pc, filename, lineno, function->name);\n }\n \n-/* Build our data structures from the .debug_info and .debug_line\n-   sections.  Set *FILELINE_FN and *FILELINE_DATA.  Return 1 on\n-   success, 0 on failure.  */\n \n-int\n-backtrace_dwarf_initialize (struct backtrace_state *state,\n-\t\t\t    const unsigned char *dwarf_info,\n-\t\t\t    size_t dwarf_info_size,\n-\t\t\t    const unsigned char *dwarf_line,\n-\t\t\t    size_t dwarf_line_size,\n-\t\t\t    const unsigned char *dwarf_abbrev,\n-\t\t\t    size_t dwarf_abbrev_size,\n-\t\t\t    const unsigned char *dwarf_ranges,\n-\t\t\t    size_t dwarf_ranges_size,\n-\t\t\t    const unsigned char *dwarf_str,\n-\t\t\t    size_t dwarf_str_size,\n-\t\t\t    int is_bigendian,\n-\t\t\t    backtrace_error_callback error_callback,\n-\t\t\t    void *data, fileline *fileline_fn)\n+/* Return the file/line information for a PC using the DWARF mapping\n+   we built earlier.  */\n+\n+static int\n+dwarf_fileline (struct backtrace_state *state, uintptr_t pc,\n+\t\tbacktrace_full_callback callback,\n+\t\tbacktrace_error_callback error_callback, void *data)\n+{\n+  struct dwarf_data *ddata;\n+  int found;\n+  int ret;\n+\n+  if (!state->threaded)\n+    {\n+      for (ddata = (struct dwarf_data *) state->fileline_data;\n+\t   ddata != NULL;\n+\t   ddata = ddata->next)\n+\t{\n+\t  ret = dwarf_lookup_pc (state, ddata, pc, callback, error_callback,\n+\t\t\t\t data, &found);\n+\t  if (ret != 0 || found)\n+\t    return ret;\n+\t}\n+    }\n+  else\n+    {\n+      struct dwarf_data **pp;\n+\n+      pp = (struct dwarf_data **) &state->fileline_data;\n+      while (1)\n+\t{\n+\t  ddata = *pp;\n+\t  /* Atomic load.  */\n+\t  while (!__sync_bool_compare_and_swap (pp, ddata, ddata))\n+\t    ddata = *pp;\n+\n+\t  if (ddata == NULL)\n+\t    break;\n+\n+\t  ret = dwarf_lookup_pc (state, ddata, pc, callback, error_callback,\n+\t\t\t\t data, &found);\n+\t  if (ret != 0 || found)\n+\t    return ret;\n+\n+\t  pp = &ddata->next;\n+\t}\n+    }\n+\n+  /* FIXME: See if any libraries have been dlopen'ed.  */\n+\n+  return callback (data, pc, NULL, 0, NULL);\n+}\n+\n+/* Initialize our data structures from the DWARF debug info for a\n+   file.  Return NULL on failure.  */\n+\n+static struct dwarf_data *\n+build_dwarf_data (struct backtrace_state *state,\n+\t\t  uintptr_t base_address,\n+\t\t  const unsigned char *dwarf_info,\n+\t\t  size_t dwarf_info_size,\n+\t\t  const unsigned char *dwarf_line,\n+\t\t  size_t dwarf_line_size,\n+\t\t  const unsigned char *dwarf_abbrev,\n+\t\t  size_t dwarf_abbrev_size,\n+\t\t  const unsigned char *dwarf_ranges,\n+\t\t  size_t dwarf_ranges_size,\n+\t\t  const unsigned char *dwarf_str,\n+\t\t  size_t dwarf_str_size,\n+\t\t  int is_bigendian,\n+\t\t  backtrace_error_callback error_callback,\n+\t\t  void *data)\n {\n   struct unit_addrs_vector addrs_vec;\n   struct unit_addrs *addrs;\n   size_t addrs_count;\n   struct dwarf_data *fdata;\n \n-  if (!build_address_map (state, dwarf_info, dwarf_info_size, dwarf_abbrev,\n-\t\t\t  dwarf_abbrev_size, dwarf_ranges, dwarf_ranges_size,\n-\t\t\t  dwarf_str, dwarf_str_size, is_bigendian,\n-\t\t\t  error_callback, data, &addrs_vec))\n-    return 0;\n+  if (!build_address_map (state, base_address, dwarf_info, dwarf_info_size,\n+\t\t\t  dwarf_abbrev, dwarf_abbrev_size, dwarf_ranges,\n+\t\t\t  dwarf_ranges_size, dwarf_str, dwarf_str_size,\n+\t\t\t  is_bigendian, error_callback, data, &addrs_vec))\n+    return NULL;\n \n   if (!backtrace_vector_release (state, &addrs_vec.vec, error_callback, data))\n-    return 0;\n+    return NULL;\n   addrs = (struct unit_addrs *) addrs_vec.vec.base;\n   addrs_count = addrs_vec.count;\n   qsort (addrs, addrs_count, sizeof (struct unit_addrs), unit_addrs_compare);\n@@ -2746,8 +2829,10 @@ backtrace_dwarf_initialize (struct backtrace_state *state,\n \t   backtrace_alloc (state, sizeof (struct dwarf_data),\n \t\t\t    error_callback, data));\n   if (fdata == NULL)\n-    return 0;\n+    return NULL;\n \n+  fdata->next = NULL;\n+  fdata->base_address = base_address;\n   fdata->addrs = addrs;\n   fdata->addrs_count = addrs_count;\n   fdata->dwarf_info = dwarf_info;\n@@ -2761,7 +2846,77 @@ backtrace_dwarf_initialize (struct backtrace_state *state,\n   fdata->is_bigendian = is_bigendian;\n   memset (&fdata->fvec, 0, sizeof fdata->fvec);\n \n-  state->fileline_data = fdata;\n+  return fdata;\n+}\n+\n+/* Build our data structures from the DWARF sections for a module.\n+   Set FILELINE_FN and STATE->FILELINE_DATA.  Return 1 on success, 0\n+   on failure.  */\n+\n+int\n+backtrace_dwarf_add (struct backtrace_state *state,\n+\t\t     uintptr_t base_address,\n+\t\t     const unsigned char *dwarf_info,\n+\t\t     size_t dwarf_info_size,\n+\t\t     const unsigned char *dwarf_line,\n+\t\t     size_t dwarf_line_size,\n+\t\t     const unsigned char *dwarf_abbrev,\n+\t\t     size_t dwarf_abbrev_size,\n+\t\t     const unsigned char *dwarf_ranges,\n+\t\t     size_t dwarf_ranges_size,\n+\t\t     const unsigned char *dwarf_str,\n+\t\t     size_t dwarf_str_size,\n+\t\t     int is_bigendian,\n+\t\t     backtrace_error_callback error_callback,\n+\t\t     void *data, fileline *fileline_fn)\n+{\n+  struct dwarf_data *fdata;\n+\n+  fdata = build_dwarf_data (state, base_address, dwarf_info, dwarf_info_size,\n+\t\t\t    dwarf_line, dwarf_line_size, dwarf_abbrev,\n+\t\t\t    dwarf_abbrev_size, dwarf_ranges, dwarf_ranges_size,\n+\t\t\t    dwarf_str, dwarf_str_size, is_bigendian,\n+\t\t\t    error_callback, data);\n+  if (fdata == NULL)\n+    return 0;\n+\n+  if (!state->threaded)\n+    {\n+      struct dwarf_data **pp;\n+\n+      for (pp = (struct dwarf_data **) &state->fileline_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = fdata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct dwarf_data **pp;\n+\n+\t  pp = (struct dwarf_data **) &state->fileline_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct dwarf_data *p;\n+\n+\t      /* Atomic load.  */\n+\t      p = *pp;\n+\t      while (!__sync_bool_compare_and_swap (pp, p, p))\n+\t\tp = *pp;\n+\n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, fdata))\n+\t    break;\n+\t}\n+    }\n \n   *fileline_fn = dwarf_fileline;\n "}, {"sha": "48e88849813ce7224c9fe779e1049d6968b361b2", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 243, "deletions": 29, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=e561a9920cce1e638826a53599eb55ec44ce54c2", "patch": "@@ -36,9 +36,36 @@ POSSIBILITY OF SUCH DAMAGE.  */\n #include <string.h>\n #include <sys/types.h>\n \n+#ifdef HAVE_DL_ITERATE_PHDR\n+#include <link.h>\n+#endif\n+\n #include \"backtrace.h\"\n #include \"internal.h\"\n \n+#ifndef HAVE_DL_ITERATE_PHDR\n+\n+/* Dummy version of dl_iterate_phdr for systems that don't have it.  */\n+\n+#define dl_phdr_info x_dl_phdr_info\n+#define dl_iterate_phdr x_dl_iterate_phdr\n+\n+struct dl_phdr_info\n+{\n+  uintptr_t dlpi_addr;\n+  const char *dlpi_name;\n+};\n+\n+static int\n+dl_iterate_phdr (int (*callback) (struct dl_phdr_info *,\n+\t\t\t\t  size_t, void *) ATTRIBUTE_UNUSED,\n+\t\t void *data ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n+#endif /* ! defined (HAVE_DL_ITERATE_PHDR) */\n+\n /* The configure script must tell us whether we are 32-bit or 64-bit\n    ELF.  We could make this code test and support either possibility,\n    but there is no point.  This code only works for the currently\n@@ -49,6 +76,33 @@ POSSIBILITY OF SUCH DAMAGE.  */\n #error \"Unknown BACKTRACE_ELF_SIZE\"\n #endif\n \n+/* <link.h> might #include <elf.h> which might define our constants\n+   with slightly different values.  Undefine them to be safe.  */\n+\n+#undef EI_NIDENT\n+#undef EI_MAG0\n+#undef EI_MAG1\n+#undef EI_MAG2\n+#undef EI_MAG3\n+#undef EI_CLASS\n+#undef EI_DATA\n+#undef EI_VERSION\n+#undef ELF_MAG0\n+#undef ELF_MAG1\n+#undef ELF_MAG2\n+#undef ELF_MAG3\n+#undef ELFCLASS32\n+#undef ELFCLASS64\n+#undef ELFDATA2LSB\n+#undef ELFDATA2MSB\n+#undef EV_CURRENT\n+#undef SHN_LORESERVE\n+#undef SHN_XINDEX\n+#undef SHT_SYMTAB\n+#undef SHT_STRTAB\n+#undef SHT_DYNSYM\n+#undef STT_FUNC\n+\n /* Basic types.  */\n \n typedef uint16_t Elf_Half;\n@@ -214,6 +268,8 @@ struct elf_symbol\n \n struct elf_syminfo_data\n {\n+  /* Symbols for the next module.  */\n+  struct elf_syminfo_data *next;\n   /* The ELF symbols, sorted by address.  */\n   struct elf_symbol *symbols;\n   /* The number of symbols.  */\n@@ -337,12 +393,58 @@ elf_initialize_syminfo (struct backtrace_state *state,\n   qsort (elf_symbols, elf_symbol_count, sizeof (struct elf_symbol),\n \t elf_symbol_compare);\n \n+  sdata->next = NULL;\n   sdata->symbols = elf_symbols;\n   sdata->count = elf_symbol_count;\n \n   return 1;\n }\n \n+/* Add EDATA to the list in STATE.  */\n+\n+static void\n+elf_add_syminfo_data (struct backtrace_state *state,\n+\t\t      struct elf_syminfo_data *edata)\n+{\n+  if (!state->threaded)\n+    {\n+      struct elf_syminfo_data **pp;\n+\n+      for (pp = (struct elf_syminfo_data **) &state->syminfo_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = edata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct elf_syminfo_data **pp;\n+\n+\t  pp = (struct elf_syminfo_data **) &state->syminfo_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct elf_syminfo_data *p;\n+\n+\t      /* Atomic load.  */\n+\t      p = *pp;\n+\t      while (!__sync_bool_compare_and_swap (pp, p, p))\n+\t\tp = *pp;\n+\n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, edata))\n+\t    break;\n+\t}\n+    }\n+}\n+\n /* Return the symbol name and value for a PC.  */\n \n static void\n@@ -364,14 +466,12 @@ elf_syminfo (struct backtrace_state *state, uintptr_t pc,\n     callback (data, pc, sym->name, sym->address);\n }\n \n-/* Initialize the backtrace data we need from an ELF executable.  At\n-   the ELF level, all we need to do is find the debug info\n-   sections.  */\n+/* Add the backtrace data for one ELF file.  */\n \n-int\n-backtrace_initialize (struct backtrace_state *state, int descriptor,\n-\t\t      backtrace_error_callback error_callback,\n-\t\t      void *data, fileline *fileline_fn)\n+static int\n+elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n+\t backtrace_error_callback error_callback, void *data,\n+\t fileline *fileline_fn, int *found_sym, int *found_dwarf)\n {\n   struct backtrace_view ehdr_view;\n   Elf_Ehdr ehdr;\n@@ -400,6 +500,9 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n   struct backtrace_view debug_view;\n   int debug_view_valid;\n \n+  *found_sym = 0;\n+  *found_dwarf = 0;\n+\n   shdrs_view_valid = 0;\n   names_view_valid = 0;\n   symtab_view_valid = 0;\n@@ -516,6 +619,8 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n   dynsym_shndx = 0;\n \n   memset (sections, 0, sizeof sections);\n+\n+  /* Look for the symbol table.  */\n   for (i = 1; i < shnum; ++i)\n     {\n       const Elf_Shdr *shdr;\n@@ -552,12 +657,7 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n \n   if (symtab_shndx == 0)\n     symtab_shndx = dynsym_shndx;\n-  if (symtab_shndx == 0)\n-    {\n-      state->syminfo_fn = elf_nosyms;\n-      state->syminfo_data = NULL;\n-    }\n-  else\n+  if (symtab_shndx != 0)\n     {\n       const Elf_Shdr *symtab_shdr;\n       unsigned int strtab_shndx;\n@@ -604,8 +704,9 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n \t string table permanently.  */\n       backtrace_release_view (state, &symtab_view, error_callback, data);\n \n-      state->syminfo_fn = elf_syminfo;\n-      state->syminfo_data = sdata;\n+      *found_sym = 1;\n+\n+      elf_add_syminfo_data (state, sdata);\n     }\n \n   /* FIXME: Need to handle compressed debug sections.  */\n@@ -635,7 +736,6 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n       if (!backtrace_close (descriptor, error_callback, data))\n \tgoto fail;\n       *fileline_fn = elf_nodebug;\n-      state->fileline_data = NULL;\n       return 1;\n     }\n \n@@ -654,21 +754,23 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n     sections[i].data = ((const unsigned char *) debug_view.data\n \t\t\t+ (sections[i].offset - min_offset));\n \n-  if (!backtrace_dwarf_initialize (state,\n-\t\t\t\t   sections[DEBUG_INFO].data,\n-\t\t\t\t   sections[DEBUG_INFO].size,\n-\t\t\t\t   sections[DEBUG_LINE].data,\n-\t\t\t\t   sections[DEBUG_LINE].size,\n-\t\t\t\t   sections[DEBUG_ABBREV].data,\n-\t\t\t\t   sections[DEBUG_ABBREV].size,\n-\t\t\t\t   sections[DEBUG_RANGES].data,\n-\t\t\t\t   sections[DEBUG_RANGES].size,\n-\t\t\t\t   sections[DEBUG_STR].data,\n-\t\t\t\t   sections[DEBUG_STR].size,\n-\t\t\t\t   ehdr.e_ident[EI_DATA] == ELFDATA2MSB,\n-\t\t\t\t   error_callback, data, fileline_fn))\n+  if (!backtrace_dwarf_add (state, base_address,\n+\t\t\t    sections[DEBUG_INFO].data,\n+\t\t\t    sections[DEBUG_INFO].size,\n+\t\t\t    sections[DEBUG_LINE].data,\n+\t\t\t    sections[DEBUG_LINE].size,\n+\t\t\t    sections[DEBUG_ABBREV].data,\n+\t\t\t    sections[DEBUG_ABBREV].size,\n+\t\t\t    sections[DEBUG_RANGES].data,\n+\t\t\t    sections[DEBUG_RANGES].size,\n+\t\t\t    sections[DEBUG_STR].data,\n+\t\t\t    sections[DEBUG_STR].size,\n+\t\t\t    ehdr.e_ident[EI_DATA] == ELFDATA2MSB,\n+\t\t\t    error_callback, data, fileline_fn))\n     goto fail;\n \n+  *found_dwarf = 1;\n+\n   return 1;\n \n  fail:\n@@ -686,3 +788,115 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n     backtrace_close (descriptor, error_callback, data);\n   return 0;\n }\n+\n+/* Data passed to phdr_callback.  */\n+\n+struct phdr_data\n+{\n+  struct backtrace_state *state;\n+  backtrace_error_callback error_callback;\n+  void *data;\n+  fileline *fileline_fn;\n+  int *found_sym;\n+  int *found_dwarf;\n+};\n+\n+/* Callback passed to dl_iterate_phdr.  Load debug info from shared\n+   libraries.  */\n+\n+static int\n+phdr_callback (struct dl_phdr_info *info, size_t size ATTRIBUTE_UNUSED,\n+\t       void *pdata)\n+{\n+  struct phdr_data *pd = (struct phdr_data *) pdata;\n+  int descriptor;\n+  fileline elf_fileline_fn;\n+  int found_dwarf;\n+\n+  /* There is not much we can do if we don't have the module name.  If\n+     the base address is 0, this is probably the executable, which we\n+     already loaded.  */\n+  if (info->dlpi_name == NULL\n+      || info->dlpi_name[0] == '\\0'\n+      || info->dlpi_addr == 0)\n+    return 0;\n+\n+  descriptor = backtrace_open (info->dlpi_name, pd->error_callback, pd->data);\n+  if (descriptor < 0)\n+    return 0;\n+\n+  if (elf_add (pd->state, descriptor, info->dlpi_addr, pd->error_callback,\n+\t       pd->data, &elf_fileline_fn, pd->found_sym, &found_dwarf))\n+    {\n+      if (found_dwarf)\n+\t{\n+\t  *pd->found_dwarf = 1;\n+\t  *pd->fileline_fn = elf_fileline_fn;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Initialize the backtrace data we need from an ELF executable.  At\n+   the ELF level, all we need to do is find the debug info\n+   sections.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state, int descriptor,\n+\t\t      backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  int found_sym;\n+  int found_dwarf;\n+  syminfo elf_syminfo_fn;\n+  fileline elf_fileline_fn;\n+  struct phdr_data pd;\n+\n+  if (!elf_add (state, descriptor, 0, error_callback, data, &elf_fileline_fn,\n+\t\t&found_sym, &found_dwarf))\n+    return 0;\n+\n+  pd.state = state;\n+  pd.error_callback = error_callback;\n+  pd.data = data;\n+  pd.fileline_fn = fileline_fn;\n+  pd.found_sym = &found_sym;\n+  pd.found_dwarf = &found_dwarf;\n+\n+  dl_iterate_phdr (phdr_callback, (void *) &pd);\n+\n+  elf_syminfo_fn = found_sym ? elf_syminfo : elf_nosyms;\n+  if (!state->threaded)\n+    {\n+      if (state->syminfo_fn == NULL || found_sym)\n+\tstate->syminfo_fn = elf_syminfo_fn;\n+    }\n+  else\n+    {\n+      __sync_bool_compare_and_swap (&state->syminfo_fn, NULL, elf_syminfo_fn);\n+      if (found_sym)\n+\t__sync_bool_compare_and_swap (&state->syminfo_fn, elf_nosyms,\n+\t\t\t\t      elf_syminfo_fn);\n+    }\n+\n+  if (!state->threaded)\n+    {\n+      if (state->fileline_fn == NULL || state->fileline_fn == elf_nodebug)\n+\t*fileline_fn = elf_fileline_fn;\n+    }\n+  else\n+    {\n+      fileline current_fn;\n+\n+      /* Atomic load.  */\n+      current_fn = state->fileline_fn;\n+      while (!__sync_bool_compare_and_swap (&state->fileline_fn, current_fn,\n+\t\t\t\t\t    current_fn))\n+\tcurrent_fn = state->fileline_fn;\n+      if (current_fn == NULL || current_fn == elf_nodebug)\n+\t*fileline_fn = elf_fileline_fn;\n+    }\n+\n+  return 1;\n+}"}, {"sha": "b1afca0a2d993d6b87fb67c63a60b4fd40d25892", "filename": "libbacktrace/internal.h", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e561a9920cce1e638826a53599eb55ec44ce54c2/libbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Finternal.h?ref=e561a9920cce1e638826a53599eb55ec44ce54c2", "patch": "@@ -215,21 +215,22 @@ extern int backtrace_initialize (struct backtrace_state *state,\n \t\t\t\t void *data,\n \t\t\t\t fileline *fileline_fn);\n \n-/* Prepare to read file/line information from DWARF debug data.  */\n-\n-extern int backtrace_dwarf_initialize (struct backtrace_state *state,\n-\t\t\t\t       const unsigned char* dwarf_info,\n-\t\t\t\t       size_t dwarf_info_size,\n-\t\t\t\t       const unsigned char *dwarf_line,\n-\t\t\t\t       size_t dwarf_line_size,\n-\t\t\t\t       const unsigned char *dwarf_abbrev,\n-\t\t\t\t       size_t dwarf_abbrev_size,\n-\t\t\t\t       const unsigned char *dwarf_ranges,\n-\t\t\t\t       size_t dwarf_range_size,\n-\t\t\t\t       const unsigned char *dwarf_str,\n-\t\t\t\t       size_t dwarf_str_size,\n-\t\t\t\t       int is_bigendian,\n-\t\t\t\t       backtrace_error_callback error_callback,\n-\t\t\t\t       void *data, fileline *fileline_fn);\n+/* Add file/line information for a DWARF module.  */\n+\n+extern int backtrace_dwarf_add (struct backtrace_state *state,\n+\t\t\t\tuintptr_t base_address,\n+\t\t\t\tconst unsigned char* dwarf_info,\n+\t\t\t\tsize_t dwarf_info_size,\n+\t\t\t\tconst unsigned char *dwarf_line,\n+\t\t\t\tsize_t dwarf_line_size,\n+\t\t\t\tconst unsigned char *dwarf_abbrev,\n+\t\t\t\tsize_t dwarf_abbrev_size,\n+\t\t\t\tconst unsigned char *dwarf_ranges,\n+\t\t\t\tsize_t dwarf_range_size,\n+\t\t\t\tconst unsigned char *dwarf_str,\n+\t\t\t\tsize_t dwarf_str_size,\n+\t\t\t\tint is_bigendian,\n+\t\t\t\tbacktrace_error_callback error_callback,\n+\t\t\t\tvoid *data, fileline *fileline_fn);\n \n #endif"}]}