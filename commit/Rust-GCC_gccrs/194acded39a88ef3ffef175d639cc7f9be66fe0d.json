{"sha": "194acded39a88ef3ffef175d639cc7f9be66fe0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk0YWNkZWQzOWE4OGVmM2ZmZWYxNzVkNjM5Y2M3ZjliZTY2ZmUwZA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2004-11-06T18:33:04Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2004-11-06T18:33:04Z"}, "message": "re PR rtl-optimization/17933 (ICE: in schedule_insns, at /sched-rgn.c:2555)\n\n\tPR rtl-optimization/17933\n\t* rtlanal.c (dead_or_set_regno_p): Break out common code to...\n\t(covers_regno_p): New function.  Handle SETs of PARALLEL,\n\tand defer the rest to...\n\t(covers_regno_no_parallel_p): New function.\n\nFrom-SVN: r90183", "tree": {"sha": "0bcebaa3571641fe6d6bfd21cf9c12fde3840964", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bcebaa3571641fe6d6bfd21cf9c12fde3840964"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/194acded39a88ef3ffef175d639cc7f9be66fe0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/194acded39a88ef3ffef175d639cc7f9be66fe0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/194acded39a88ef3ffef175d639cc7f9be66fe0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/194acded39a88ef3ffef175d639cc7f9be66fe0d/comments", "author": null, "committer": null, "parents": [{"sha": "629bf5f9a465caebd2ce90897fb662e5d06003ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/629bf5f9a465caebd2ce90897fb662e5d06003ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/629bf5f9a465caebd2ce90897fb662e5d06003ca"}], "stats": {"total": 110, "additions": 66, "deletions": 44}, "files": [{"sha": "00d25f18f9c422a8690150c0bf5c2759ee85322c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194acded39a88ef3ffef175d639cc7f9be66fe0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194acded39a88ef3ffef175d639cc7f9be66fe0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=194acded39a88ef3ffef175d639cc7f9be66fe0d", "patch": "@@ -1,3 +1,11 @@\n+2004-11-06  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\tPR rtl-optimization/17933\n+\t* rtlanal.c (dead_or_set_regno_p): Break out common code to...\n+\t(covers_regno_p): New function.  Handle SETs of PARALLEL,\n+\tand defer the rest to...\n+\t(covers_regno_no_parallel_p): New function.\n+\n 2004-11-06  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* config/sparc/sparc.c (function_arg_record_value_1): Skip"}, {"sha": "de5478823b221e41cf7b49de299a4f1079bf8fc6", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 58, "deletions": 44, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194acded39a88ef3ffef175d639cc7f9be66fe0d/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194acded39a88ef3ffef175d639cc7f9be66fe0d/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=194acded39a88ef3ffef175d639cc7f9be66fe0d", "patch": "@@ -41,6 +41,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Forward declarations */\n static int global_reg_mentioned_p_1 (rtx *, void *);\n static void set_of_1 (rtx, rtx, void *);\n+static bool covers_regno_p (rtx, unsigned int);\n+static bool covers_regno_no_parallel_p (rtx, unsigned int);\n static int rtx_referenced_p_1 (rtx *, void *);\n static int computed_jump_p_1 (rtx);\n static void parms_set (rtx, rtx, void *);\n@@ -1549,13 +1551,64 @@ dead_or_set_p (rtx insn, rtx x)\n   return 1;\n }\n \n+/* Return TRUE iff DEST is a register or subreg of a register and\n+   doesn't change the number of words of the inner register, and any\n+   part of the register is TEST_REGNO.  */\n+\n+static bool\n+covers_regno_no_parallel_p (rtx dest, unsigned int test_regno)\n+{\n+  unsigned int regno, endregno;\n+\n+  if (GET_CODE (dest) == SUBREG\n+      && (((GET_MODE_SIZE (GET_MODE (dest))\n+\t    + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n+\t       + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n+    dest = SUBREG_REG (dest);\n+\n+  if (!REG_P (dest))\n+    return false;\n+\n+  regno = REGNO (dest);\n+  endregno = (regno >= FIRST_PSEUDO_REGISTER ? regno + 1\n+\t      : regno + hard_regno_nregs[regno][GET_MODE (dest)]);\n+  return (test_regno >= regno && test_regno < endregno);\n+}\n+\n+/* Like covers_regno_no_parallel_p, but also handles PARALLELs where\n+   any member matches the covers_regno_no_parallel_p criteria.  */\n+\n+static bool\n+covers_regno_p (rtx dest, unsigned int test_regno)\n+{\n+  if (GET_CODE (dest) == PARALLEL)\n+    {\n+      /* Some targets place small structures in registers for return\n+\t values of functions, and those registers are wrapped in\n+\t PARALLELs that we may see as the destination of a SET.  */\n+      int i;\n+\n+      for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n+\t{\n+\t  rtx inner = XEXP (XVECEXP (dest, 0, i), 0);\n+\t  if (inner != NULL_RTX\n+\t      && covers_regno_no_parallel_p (inner, test_regno))\n+\t    return true;\n+\t}\n+\n+      return false;\n+    }\n+  else\n+    return covers_regno_no_parallel_p (dest, test_regno);\n+}\n+\n /* Utility function for dead_or_set_p to check an individual register.  Also\n    called from flow.c.  */\n \n int\n dead_or_set_regno_p (rtx insn, unsigned int test_regno)\n {\n-  unsigned int regno, endregno;\n   rtx pattern;\n \n   /* See if there is a death note for something that includes TEST_REGNO.  */\n@@ -1572,28 +1625,7 @@ dead_or_set_regno_p (rtx insn, unsigned int test_regno)\n     pattern = COND_EXEC_CODE (pattern);\n \n   if (GET_CODE (pattern) == SET)\n-    {\n-      rtx dest = SET_DEST (pattern);\n-\n-      /* A value is totally replaced if it is the destination or the\n-\t destination is a SUBREG of REGNO that does not change the number of\n-\t words in it.  */\n-      if (GET_CODE (dest) == SUBREG\n-\t  && (((GET_MODE_SIZE (GET_MODE (dest))\n-\t\t+ UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\t      == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n-\t\t   + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n-\tdest = SUBREG_REG (dest);\n-\n-      if (!REG_P (dest))\n-\treturn 0;\n-\n-      regno = REGNO (dest);\n-      endregno = (regno >= FIRST_PSEUDO_REGISTER ? regno + 1\n-\t\t  : regno + hard_regno_nregs[regno][GET_MODE (dest)]);\n-\n-      return (test_regno >= regno && test_regno < endregno);\n-    }\n+    return covers_regno_p (SET_DEST (pattern), test_regno);\n   else if (GET_CODE (pattern) == PARALLEL)\n     {\n       int i;\n@@ -1605,27 +1637,9 @@ dead_or_set_regno_p (rtx insn, unsigned int test_regno)\n \t  if (GET_CODE (body) == COND_EXEC)\n \t    body = COND_EXEC_CODE (body);\n \n-\t  if (GET_CODE (body) == SET || GET_CODE (body) == CLOBBER)\n-\t    {\n-\t      rtx dest = SET_DEST (body);\n-\n-\t      if (GET_CODE (dest) == SUBREG\n-\t\t  && (((GET_MODE_SIZE (GET_MODE (dest))\n-\t\t\t+ UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\t\t      == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n-\t\t\t   + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n-\t\tdest = SUBREG_REG (dest);\n-\n-\t      if (!REG_P (dest))\n-\t\tcontinue;\n-\n-\t      regno = REGNO (dest);\n-\t      endregno = (regno >= FIRST_PSEUDO_REGISTER ? regno + 1\n-\t\t\t  : regno + hard_regno_nregs[regno][GET_MODE (dest)]);\n-\n-\t      if (test_regno >= regno && test_regno < endregno)\n-\t\treturn 1;\n-\t    }\n+\t  if ((GET_CODE (body) == SET || GET_CODE (body) == CLOBBER)\n+\t      && covers_regno_p (SET_DEST (body), test_regno))\n+\t    return 1;\n \t}\n     }\n "}]}