{"sha": "5505bb43b7b3277354563b69d1287efca21315cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwNWJiNDNiN2IzMjc3MzU0NTYzYjY5ZDEyODdlZmNhMjEzMTVjYg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-12-14T17:15:39Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-12-14T17:15:39Z"}, "message": "vrp_prop: Use dom_walker for -Warray-bounds (PR tree-optimization/83312)\n\ngcc/ChangeLog:\n\tPR tree-optimization/83312\n\t* domwalk.h (dom_walker::dom_walker): Fix typo in comment.\n\t* tree-cfg.c (find_taken_edge): Update to handle NULL_TREE for\n\t\"val\" param, and to cope with arbitrary basic blocks.\n\t(find_taken_edge_cond_expr): Add \"cond_stmt\" param and use it to\n\thandle NULL_TREE for \"val\", dropping \"bb\" param.\n\t(find_taken_edge_switch_expr): Make \"switch_stmt\" param const and\n\tdrop \"bb\" param.  Handle NULL_TREE for \"val\".\n\t(find_case_label_for_value): Make \"switch_stmt\" param const.\n\t* tree-vrp.c (class check_array_bounds_dom_walker): New subclass\n\tof dom_walker.\n\t(vrp_prop::check_all_array_refs): Reimplement as...\n\t(check_array_bounds_dom_walker::before_dom_children): ...this new\n\tvfunc.  Replace linear search through BB block list, excluding\n\tthose with non-executable in-edges via dominator walk.\n\ngcc/testsuite/ChangeLog:\n\tPR tree-optimization/83312\n\t* gcc.dg/pr83312.c: New test case.\n\nFrom-SVN: r255649", "tree": {"sha": "7d33437a2b214b3948aaf13e6a38a38a5cc1a739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d33437a2b214b3948aaf13e6a38a38a5cc1a739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5505bb43b7b3277354563b69d1287efca21315cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5505bb43b7b3277354563b69d1287efca21315cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5505bb43b7b3277354563b69d1287efca21315cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5505bb43b7b3277354563b69d1287efca21315cb/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9de2192154a3d5ec055b535aa143a927fcc2c2ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de2192154a3d5ec055b535aa143a927fcc2c2ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de2192154a3d5ec055b535aa143a927fcc2c2ee"}], "stats": {"total": 210, "additions": 152, "deletions": 58}, "files": [{"sha": "7473263a62c5bc8dcdf241947555663f5696c7d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5505bb43b7b3277354563b69d1287efca21315cb", "patch": "@@ -1,3 +1,21 @@\n+2017-12-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR tree-optimization/83312\n+\t* domwalk.h (dom_walker::dom_walker): Fix typo in comment.\n+\t* tree-cfg.c (find_taken_edge): Update to handle NULL_TREE for\n+\t\"val\" param, and to cope with arbitrary basic blocks.\n+\t(find_taken_edge_cond_expr): Add \"cond_stmt\" param and use it to\n+\thandle NULL_TREE for \"val\", dropping \"bb\" param.\n+\t(find_taken_edge_switch_expr): Make \"switch_stmt\" param const and\n+\tdrop \"bb\" param.  Handle NULL_TREE for \"val\".\n+\t(find_case_label_for_value): Make \"switch_stmt\" param const.\n+\t* tree-vrp.c (class check_array_bounds_dom_walker): New subclass\n+\tof dom_walker.\n+\t(vrp_prop::check_all_array_refs): Reimplement as...\n+\t(check_array_bounds_dom_walker::before_dom_children): ...this new\n+\tvfunc.  Replace linear search through BB block list, excluding\n+\tthose with non-executable in-edges via dominator walk.\n+\n 2017-12-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.opt (mverbose-cost-dump): New option."}, {"sha": "c7e3450cf94593aa1ab3d8caf18ccf7324d79950", "filename": "gcc/domwalk.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=5505bb43b7b3277354563b69d1287efca21315cb", "patch": "@@ -32,7 +32,7 @@ class dom_walker\n public:\n   static const edge STOP;\n \n-  /* Use SKIP_UNREACHBLE_BLOCKS = true when your client can discover\n+  /* Use SKIP_UNREACHABLE_BLOCKS = true when your client can discover\n      that some edges are not executable.\n \n      If a client can discover that a COND, SWITCH or GOTO has a static"}, {"sha": "81d28f1adb6ba35b96b4b347e4f111af92312c55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5505bb43b7b3277354563b69d1287efca21315cb", "patch": "@@ -1,3 +1,8 @@\n+2017-12-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR tree-optimization/83312\n+\t* gcc.dg/pr83312.c: New test case.\n+\n 2017-12-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/alignment13.adb: New test."}, {"sha": "2eb241dfdfe3a249f54cc80285840201edcd5c0b", "filename": "gcc/testsuite/gcc.dg/pr83312.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83312.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83312.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83312.c?ref=5505bb43b7b3277354563b69d1287efca21315cb", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-options \"-O2 -Warray-bounds\" } */\n+\n+struct ptlrpcd_ctl {\n+  char pc_name[20];\n+};\n+struct ptlrpcd {\n+  struct ptlrpcd_ctl pd_threads[6];\n+};\n+struct ptlrpcd *ptlrpcd_init_pd;\n+static void ptlrpcd_ctl_init(struct ptlrpcd_ctl *pc, int index) {\n+  if (index < 0)\n+    __builtin_snprintf(pc->pc_name, sizeof(pc->pc_name), \"ptlrpcd_rcv\");\n+  else\n+    __builtin_snprintf(pc->pc_name, sizeof(pc->pc_name), \"ptlrpcd_%d\", index);\n+}\n+int ptlrpcd_init_ncpts;\n+static int ptlrpcd_init(int nthreads) {\n+  int j;\n+  if (ptlrpcd_init_ncpts) {\n+    ptlrpcd_ctl_init(&ptlrpcd_init_pd->pd_threads[0], -1);\n+    for (j = 1; j < nthreads; j++)\n+      ptlrpcd_ctl_init(&ptlrpcd_init_pd->pd_threads[j], j);\n+  }\n+  return 0;\n+}\n+int ptlrpcd_init_groupsize;\n+void ptlrpcd_addref(void) {\n+    ptlrpcd_init(ptlrpcd_init_groupsize);\n+}\n+"}, {"sha": "3b16c101a6f7c0aa534559d1b3d01a3ba52ef1a5", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=5505bb43b7b3277354563b69d1287efca21315cb", "patch": "@@ -170,9 +170,9 @@ static void gimple_merge_blocks (basic_block, basic_block);\n static bool gimple_can_merge_blocks_p (basic_block, basic_block);\n static void remove_bb (basic_block);\n static edge find_taken_edge_computed_goto (basic_block, tree);\n-static edge find_taken_edge_cond_expr (basic_block, tree);\n-static edge find_taken_edge_switch_expr (gswitch *, basic_block, tree);\n-static tree find_case_label_for_value (gswitch *, tree);\n+static edge find_taken_edge_cond_expr (const gcond *, tree);\n+static edge find_taken_edge_switch_expr (const gswitch *, tree);\n+static tree find_case_label_for_value (const gswitch *, tree);\n static void lower_phi_internal_fn ();\n \n void\n@@ -2278,9 +2278,12 @@ remove_bb (basic_block bb)\n }\n \n \n-/* Given a basic block BB ending with COND_EXPR or SWITCH_EXPR, and a\n-   predicate VAL, return the edge that will be taken out of the block.\n-   If VAL does not match a unique edge, NULL is returned.  */\n+/* Given a basic block BB and a value VAL for use in the final statement\n+   of the block (if a GIMPLE_COND, GIMPLE_SWITCH, or computed goto), return\n+   the edge that will be taken out of the block.\n+   If VAL is NULL_TREE, then the current value of the final statement's\n+   predicate or index is used.\n+   If the value does not match a unique edge, NULL is returned.  */\n \n edge\n find_taken_edge (basic_block bb, tree val)\n@@ -2289,13 +2292,15 @@ find_taken_edge (basic_block bb, tree val)\n \n   stmt = last_stmt (bb);\n \n-  gcc_assert (is_ctrl_stmt (stmt));\n+  /* Handle ENTRY and EXIT.  */\n+  if (!stmt)\n+    return NULL;\n \n   if (gimple_code (stmt) == GIMPLE_COND)\n-    return find_taken_edge_cond_expr (bb, val);\n+    return find_taken_edge_cond_expr (as_a <gcond *> (stmt), val);\n \n   if (gimple_code (stmt) == GIMPLE_SWITCH)\n-    return find_taken_edge_switch_expr (as_a <gswitch *> (stmt), bb, val);\n+    return find_taken_edge_switch_expr (as_a <gswitch *> (stmt), val);\n \n   if (computed_goto_p (stmt))\n     {\n@@ -2309,10 +2314,10 @@ find_taken_edge (basic_block bb, tree val)\n \t  && (TREE_CODE (val) == ADDR_EXPR || TREE_CODE (val) == LABEL_EXPR)\n \t  && TREE_CODE (TREE_OPERAND (val, 0)) == LABEL_DECL)\n \treturn find_taken_edge_computed_goto (bb, TREE_OPERAND (val, 0));\n-      return NULL;\n     }\n \n-  gcc_unreachable ();\n+  /* Otherwise we only know the taken successor edge if it's unique.  */\n+  return single_succ_p (bb) ? single_succ_edge (bb) : NULL;\n }\n \n /* Given a constant value VAL and the entry block BB to a GOTO_EXPR\n@@ -2335,45 +2340,63 @@ find_taken_edge_computed_goto (basic_block bb, tree val)\n   return e;\n }\n \n-/* Given a constant value VAL and the entry block BB to a COND_EXPR\n-   statement, determine which of the two edges will be taken out of the\n-   block.  Return NULL if either edge may be taken.  */\n+/* Given COND_STMT and a constant value VAL for use as the predicate,\n+   determine which of the two edges will be taken out of\n+   the statement's block.  Return NULL if either edge may be taken.\n+   If VAL is NULL_TREE, then the current value of COND_STMT's predicate\n+   is used.  */\n \n static edge\n-find_taken_edge_cond_expr (basic_block bb, tree val)\n+find_taken_edge_cond_expr (const gcond *cond_stmt, tree val)\n {\n   edge true_edge, false_edge;\n \n-  if (val == NULL\n-      || TREE_CODE (val) != INTEGER_CST)\n+  if (val == NULL_TREE)\n+    {\n+      /* Use the current value of the predicate.  */\n+      if (gimple_cond_true_p (cond_stmt))\n+\tval = integer_one_node;\n+      else if (gimple_cond_false_p (cond_stmt))\n+\tval = integer_zero_node;\n+      else\n+\treturn NULL;\n+    }\n+  else if (TREE_CODE (val) != INTEGER_CST)\n     return NULL;\n \n-  extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n+  extract_true_false_edges_from_block (gimple_bb (cond_stmt),\n+\t\t\t\t       &true_edge, &false_edge);\n \n   return (integer_zerop (val) ? false_edge : true_edge);\n }\n \n-/* Given an INTEGER_CST VAL and the entry block BB to a SWITCH_EXPR\n-   statement, determine which edge will be taken out of the block.  Return\n-   NULL if any edge may be taken.  */\n+/* Given SWITCH_STMT and an INTEGER_CST VAL for use as the index, determine\n+   which edge will be taken out of the statement's block.  Return NULL if any\n+   edge may be taken.\n+   If VAL is NULL_TREE, then the current value of SWITCH_STMT's index\n+   is used.  */\n \n static edge\n-find_taken_edge_switch_expr (gswitch *switch_stmt, basic_block bb,\n-\t\t\t     tree val)\n+find_taken_edge_switch_expr (const gswitch *switch_stmt, tree val)\n {\n   basic_block dest_bb;\n   edge e;\n   tree taken_case;\n \n   if (gimple_switch_num_labels (switch_stmt) == 1)\n     taken_case = gimple_switch_default_label (switch_stmt);\n-  else if (! val || TREE_CODE (val) != INTEGER_CST)\n-    return NULL;\n   else\n-    taken_case = find_case_label_for_value (switch_stmt, val);\n+    {\n+      if (val == NULL_TREE)\n+\tval = gimple_switch_index (switch_stmt);\n+      if (TREE_CODE (val) != INTEGER_CST)\n+\treturn NULL;\n+      else\n+\ttaken_case = find_case_label_for_value (switch_stmt, val);\n+    }\n   dest_bb = label_to_block (CASE_LABEL (taken_case));\n \n-  e = find_edge (bb, dest_bb);\n+  e = find_edge (gimple_bb (switch_stmt), dest_bb);\n   gcc_assert (e);\n   return e;\n }\n@@ -2384,7 +2407,7 @@ find_taken_edge_switch_expr (gswitch *switch_stmt, basic_block bb,\n    sorted: We can do a binary search for a case matching VAL.  */\n \n static tree\n-find_case_label_for_value (gswitch *switch_stmt, tree val)\n+find_case_label_for_value (const gswitch *switch_stmt, tree val)\n {\n   size_t low, high, n = gimple_switch_num_labels (switch_stmt);\n   tree default_case = gimple_switch_default_label (switch_stmt);"}, {"sha": "8fa8616c79575c882d5e4f67b6d3b4de929a6d58", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5505bb43b7b3277354563b69d1287efca21315cb/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=5505bb43b7b3277354563b69d1287efca21315cb", "patch": "@@ -5000,44 +5000,62 @@ check_array_bounds (tree *tp, int *walk_subtree, void *data)\n   return NULL_TREE;\n }\n \n-/* Walk over all statements of all reachable BBs and call check_array_bounds\n-   on them.  */\n+/* A dom_walker subclass for use by vrp_prop::check_all_array_refs,\n+   to walk over all statements of all reachable BBs and call\n+   check_array_bounds on them.  */\n \n-void\n-vrp_prop::check_all_array_refs ()\n+class check_array_bounds_dom_walker : public dom_walker\n {\n-  basic_block bb;\n-  gimple_stmt_iterator si;\n+ public:\n+  check_array_bounds_dom_walker (vrp_prop *prop)\n+    : dom_walker (CDI_DOMINATORS, true), m_prop (prop) {}\n+  ~check_array_bounds_dom_walker () {}\n \n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      edge_iterator ei;\n-      edge e;\n-      bool executable = false;\n+  edge before_dom_children (basic_block) FINAL OVERRIDE;\n \n-      /* Skip blocks that were found to be unreachable.  */\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\texecutable |= !!(e->flags & EDGE_EXECUTABLE);\n-      if (!executable)\n-\tcontinue;\n+ private:\n+  vrp_prop *m_prop;\n+};\n \n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-\t{\n-\t  gimple *stmt = gsi_stmt (si);\n-\t  struct walk_stmt_info wi;\n-\t  if (!gimple_has_location (stmt)\n-\t      || is_gimple_debug (stmt))\n-\t    continue;\n+/* Implementation of dom_walker::before_dom_children.\n \n-\t  memset (&wi, 0, sizeof (wi));\n+   Walk over all statements of BB and call check_array_bounds on them,\n+   and determine if there's a unique successor edge.  */\n \n-\t  wi.info = this;\n+edge\n+check_array_bounds_dom_walker::before_dom_children (basic_block bb)\n+{\n+  gimple_stmt_iterator si;\n+  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      gimple *stmt = gsi_stmt (si);\n+      struct walk_stmt_info wi;\n+      if (!gimple_has_location (stmt)\n+\t  || is_gimple_debug (stmt))\n+\tcontinue;\n \n-\t  walk_gimple_op (gsi_stmt (si),\n-\t\t\t  check_array_bounds,\n-\t\t\t  &wi);\n-\t}\n+      memset (&wi, 0, sizeof (wi));\n+\n+      wi.info = m_prop;\n+\n+      walk_gimple_op (stmt, check_array_bounds, &wi);\n     }\n+\n+  /* Determine if there's a unique successor edge, and if so, return\n+     that back to dom_walker, ensuring that we don't visit blocks that\n+     became unreachable during the VRP propagation\n+     (PR tree-optimization/83312).  */\n+  return find_taken_edge (bb, NULL_TREE);\n+}\n+\n+/* Walk over all statements of all reachable BBs and call check_array_bounds\n+   on them.  */\n+\n+void\n+vrp_prop::check_all_array_refs ()\n+{\n+  check_array_bounds_dom_walker w (this);\n+  w.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n }\n \n /* Return true if all imm uses of VAR are either in STMT, or"}]}