{"sha": "b6d627e4724edc68777c8b2f5e11aad99a1dd2e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZkNjI3ZTQ3MjRlZGM2ODc3N2M4YjJmNWUxMWFhZDk5YTFkZDJlMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-04-18T19:36:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-04-18T19:36:01Z"}, "message": "ipa-inline.h (INLINE_HINT_known_hot): New hint.\n\n\t* ipa-inline.h (INLINE_HINT_known_hot): New hint.\n\t* ipa-inline-analysis.c (dump_inline_hints): Dump it.\n\t(do_estimate_edge_time): Compute it.\n\t* ipa-inline.c (want_inline_small_function_p): Bypass\n\tINLINE_INSNS_AUTO/SINGLE limits for calls that are known\n\tto be hot.\n\nFrom-SVN: r209523", "tree": {"sha": "567c2bc65a81805dc3e2d84f184eaba4dbf52d6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/567c2bc65a81805dc3e2d84f184eaba4dbf52d6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3/comments", "author": null, "committer": null, "parents": [{"sha": "e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a"}], "stats": {"total": 40, "additions": 36, "deletions": 4}, "files": [{"sha": "5221338c22da268d1c1a17838488e7ac4d5132d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6d627e4724edc68777c8b2f5e11aad99a1dd2e3", "patch": "@@ -1,3 +1,12 @@\n+2014-04-18  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline.h (INLINE_HINT_known_hot): New hint.\n+\t* ipa-inline-analysis.c (dump_inline_hints): Dump it.\n+\t(do_estimate_edge_time): Compute it.\n+\t* ipa-inline.c (want_inline_small_function_p): Bypass\n+\tINLINE_INSNS_AUTO/SINGLE limits for calls that are known\n+\tto be hot.\n+\n 2014-04-18  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-inline.c (spec_rem): New static variable."}, {"sha": "dfe305810fc5c392bc072da2a1a56c627f8ca016", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=b6d627e4724edc68777c8b2f5e11aad99a1dd2e3", "patch": "@@ -671,6 +671,11 @@ dump_inline_hints (FILE *f, inline_hints hints)\n       hints &= ~INLINE_HINT_array_index;\n       fprintf (f, \" array_index\");\n     }\n+  if (hints & INLINE_HINT_known_hot)\n+    {\n+      hints &= ~INLINE_HINT_known_hot;\n+      fprintf (f, \" known_hot\");\n+    }\n   gcc_assert (!hints);\n }\n \n@@ -3666,6 +3671,17 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n \t\t\t\t&known_aggs);\n   estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n \t\t\t       known_aggs, &size, &min_size, &time, &hints, es->param);\n+\n+  /* When we have profile feedback, we can quite safely identify hot\n+     edges and for those we disable size limits.  Don't do that when\n+     probability that caller will call the callee is low however, since it\n+     may hurt optimization of the caller's hot path.  */\n+  if (edge->count && cgraph_maybe_hot_edge_p (edge)\n+      && (edge->count * 2\n+          > (edge->caller->global.inlined_to\n+\t     ? edge->caller->global.inlined_to->count : edge->caller->count)))\n+    hints |= INLINE_HINT_known_hot;\n+\n   known_vals.release ();\n   known_binfos.release ();\n   known_aggs.release ();"}, {"sha": "65e653320ad42418d7268ff093b41384749ad550", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=b6d627e4724edc68777c8b2f5e11aad99a1dd2e3", "patch": "@@ -578,18 +578,21 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n      inline cnadidate.  At themoment we allow inline hints to\n      promote non-inline function to inline and we increase\n      MAX_INLINE_INSNS_SINGLE 16fold for inline functions.  */\n-  else if (!DECL_DECLARED_INLINE_P (callee->decl)\n+  else if ((!DECL_DECLARED_INLINE_P (callee->decl)\n+\t   && (!e->count || !cgraph_maybe_hot_edge_p (e)))\n \t   && inline_summary (callee)->min_size - inline_edge_summary (e)->call_stmt_size\n \t      > MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n     {\n       e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n       want_inline = false;\n     }\n-  else if (DECL_DECLARED_INLINE_P (callee->decl)\n+  else if ((DECL_DECLARED_INLINE_P (callee->decl) || e->count)\n \t   && inline_summary (callee)->min_size - inline_edge_summary (e)->call_stmt_size\n \t      > 16 * MAX_INLINE_INSNS_SINGLE)\n     {\n-      e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n+      e->inline_failed = (DECL_DECLARED_INLINE_P (callee->decl)\n+\t\t\t  ? CIF_MAX_INLINE_INSNS_SINGLE_LIMIT\n+\t\t\t  : CIF_MAX_INLINE_INSNS_AUTO_LIMIT);\n       want_inline = false;\n     }\n   else\n@@ -606,6 +609,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t       && growth >= MAX_INLINE_INSNS_SINGLE\n \t       && ((!big_speedup\n \t\t    && !(hints & (INLINE_HINT_indirect_call\n+\t\t\t\t  | INLINE_HINT_known_hot\n \t\t\t\t  | INLINE_HINT_loop_iterations\n \t\t\t\t  | INLINE_HINT_array_index\n \t\t\t\t  | INLINE_HINT_loop_stride)))\n@@ -630,6 +634,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t inlining given function is very profitable.  */\n       else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t       && !big_speedup\n+\t       && !(hints & INLINE_HINT_known_hot)\n \t       && growth >= ((hints & (INLINE_HINT_indirect_call\n \t\t\t\t       | INLINE_HINT_loop_iterations\n \t\t\t               | INLINE_HINT_array_index"}, {"sha": "1e9ff4ca0a827090665cf4317801245827111c18", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d627e4724edc68777c8b2f5e11aad99a1dd2e3/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=b6d627e4724edc68777c8b2f5e11aad99a1dd2e3", "patch": "@@ -68,7 +68,9 @@ enum inline_hints_vals {\n   INLINE_HINT_cross_module = 64,\n   /* If array indexes of loads/stores become known there may be room for\n      further optimization.  */\n-  INLINE_HINT_array_index = 128\n+  INLINE_HINT_array_index = 128,\n+  /* We know that the callee is hot by profile.  */\n+  INLINE_HINT_known_hot = 256\n };\n typedef int inline_hints;\n "}]}