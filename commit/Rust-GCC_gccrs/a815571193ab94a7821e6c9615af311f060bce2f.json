{"sha": "a815571193ab94a7821e6c9615af311f060bce2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgxNTU3MTE5M2FiOTRhNzgyMWU2Yzk2MTVhZjMxMWYwNjBiY2UyZg==", "commit": {"author": {"name": "Dhruv Matani", "email": "dhruvbird@gmx.net", "date": "2004-10-17T14:46:29Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-10-17T14:46:29Z"}, "message": "bitmap_allocator.h: Change unsigned int -> size_t...\n\n2004-10-17  Dhruv Matani  <dhruvbird@gmx.net>\n\t    Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/ext/bitmap_allocator.h: Change unsigned int -> size_t: this\n\tmakes the code 64-bit correct and also fixes (together with using at\n\tthe beginning a bitmap 2 * size_t bytes wide) alignment issues: now\n\t8 is guaranteed, easily tunable to 16 via _BALLOC_ALIGN_BYTES.\n\tFix pthread-rope7.cc fail by nulling out __mini_vector<> destructor.\n\t* src/bitmap_allocator.cc: Change to size_t.\n\t* config/linker-map.gnu: Adjust.\n\nCo-Authored-By: Paolo Carlini <pcarlini@suse.de>\n\nFrom-SVN: r89170", "tree": {"sha": "be1b6bd5b751bc3bdce3980e9e7aedd6a86c8e15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be1b6bd5b751bc3bdce3980e9e7aedd6a86c8e15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a815571193ab94a7821e6c9615af311f060bce2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a815571193ab94a7821e6c9615af311f060bce2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a815571193ab94a7821e6c9615af311f060bce2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a815571193ab94a7821e6c9615af311f060bce2f/comments", "author": null, "committer": null, "parents": [{"sha": "05dfb0b0e3c41fa4e3342402af348ef993e65335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05dfb0b0e3c41fa4e3342402af348ef993e65335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05dfb0b0e3c41fa4e3342402af348ef993e65335"}], "stats": {"total": 217, "additions": 116, "deletions": 101}, "files": [{"sha": "cc55893293de25bc7333df1a255060a3225bb7b9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a815571193ab94a7821e6c9615af311f060bce2f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a815571193ab94a7821e6c9615af311f060bce2f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a815571193ab94a7821e6c9615af311f060bce2f", "patch": "@@ -1,3 +1,14 @@\n+2004-10-17  Dhruv Matani  <dhruvbird@gmx.net>\n+\t    Paolo Carlini  <pcarlini@suse.de>\n+\t\t\n+\t* include/ext/bitmap_allocator.h: Change unsigned int -> size_t: this\n+\tmakes the code 64-bit correct and also fixes (together with using at\n+\tthe beginning a bitmap 2 * size_t bytes wide) alignment issues: now\n+\t8 is guaranteed, easily tunable to 16 via _BALLOC_ALIGN_BYTES.\n+\tFix pthread-rope7.cc fail by nulling out __mini_vector<> destructor.\n+\t* src/bitmap_allocator.cc: Change to size_t.\n+\t* config/linker-map.gnu: Adjust.\n+\n 2004-10-16  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/tr1/array: Don't use layout_type."}, {"sha": "565475fda7f69a4593dc849f34e3cd1d701d72a4", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a815571193ab94a7821e6c9615af311f060bce2f/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a815571193ab94a7821e6c9615af311f060bce2f/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=a815571193ab94a7821e6c9615af311f060bce2f", "patch": "@@ -273,7 +273,7 @@ GLIBCXX_3.4.3 {\n \n     _ZN9__gnu_cxx9free_list12_S_free_listE;\n     _ZN9__gnu_cxx9free_list12_S_bfl_mutexE;\n-    _ZN9__gnu_cxx9free_list6_M_getEj;\n+    _ZN9__gnu_cxx9free_list6_M_getE*;\n     _ZN9__gnu_cxx9free_list8_M_clearEv;\n \n     # stub functions from libmath"}, {"sha": "793f4dc81f73d97d614723a7b92293bfbbdaccf3", "filename": "libstdc++-v3/include/ext/bitmap_allocator.h", "status": "modified", "additions": 91, "deletions": 85, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a815571193ab94a7821e6c9615af311f060bce2f/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a815571193ab94a7821e6c9615af311f060bce2f/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h?ref=a815571193ab94a7821e6c9615af311f060bce2f", "patch": "@@ -54,6 +54,10 @@\n // itself(to debug the allocator itself).\n //#define _BALLOC_SANITY_CHECK\n \n+// The constant in the expression below is the alignment required in\n+// bytes.\n+#define _BALLOC_ALIGN_BYTES 8\n+\n #if defined _BALLOC_SANITY_CHECK\n #include <cassert>\n #define _BALLOC_ASSERT(_EXPR) assert(_EXPR)\n@@ -238,6 +242,7 @@ namespace __gnu_cxx\n \t\t\t  _M_end_of_storage(0)\n \t{ }\n \n+#if 0\n \t~__mini_vector()\n \t{\n \t  if (this->_M_start)\n@@ -246,6 +251,7 @@ namespace __gnu_cxx\n \t\t\t       - this->_M_start);\n \t    }\n \t}\n+#endif\n \n \tsize_type\n \tsize() const throw()\n@@ -370,7 +376,7 @@ namespace __gnu_cxx\n     enum \n       { \n \tbits_per_byte = 8, \n-\tbits_per_block = sizeof(unsigned int) * bits_per_byte \n+\tbits_per_block = sizeof(size_t) * bits_per_byte \n       };\n \n     template<typename _ForwardIterator, typename _Tp, typename _Compare>\n@@ -419,7 +425,7 @@ namespace __gnu_cxx\n       { return (__ap.second - __ap.first) + 1; }\n \n     template<typename _AddrPair>\n-      inline size_t \n+      inline size_t\n       __num_bitmaps(_AddrPair __ap)\n       { return __num_blocks(__ap) / bits_per_block; }\n \n@@ -477,8 +483,8 @@ namespace __gnu_cxx\n \ttypedef typename balloc::__mini_vector<_Block_pair> _BPVector;\n \ttypedef typename _BPVector::difference_type _Counter_type;\n \n-\tunsigned int* _M_pbitmap;\n-\tunsigned int _M_data_offset;\n+\tsize_t* _M_pbitmap;\n+\t_Counter_type _M_data_offset;\n \n       public:\n \t_Ffit_finder() : _M_pbitmap(0), _M_data_offset(0)\n@@ -487,10 +493,11 @@ namespace __gnu_cxx\n \tbool \n \toperator()(_Block_pair __bp) throw()\n \t{\n-\t  // Set the _rover to the last unsigned integer, which is the\n-\t  // bitmap to the first free block. Thus, the bitmaps are in exact\n-\t  // reverse order of the actual memory layout. So, we count down\n-\t  // the bimaps, which is the same as moving up the memory.\n+\t  // Set the _rover to the last physical location bitmap,\n+\t  // which is the bitmap which belongs to the first free\n+\t  // block. Thus, the bitmaps are in exact reverse order of\n+\t  // the actual memory layout. So, we count down the bimaps,\n+\t  // which is the same as moving up the memory.\n \n \t  // If the used count stored at the start of the Bit Map headers\n \t  // is equal to the number of Objects that the current Block can\n@@ -499,13 +506,12 @@ namespace __gnu_cxx\n \t  _Counter_type __diff = \n \t    __gnu_cxx::balloc::__num_bitmaps(__bp);\n \n-\t  if (*reinterpret_cast<unsigned int*>\n-\t      (reinterpret_cast<char*>(__bp.first) - (sizeof(unsigned int) * \n-\t\t\t\t\t\t      (__diff+1)))\n+\t  if (*(reinterpret_cast<size_t*>\n+\t\t(__bp.first) - (__diff + 1))\n \t      == __gnu_cxx::balloc::__num_blocks(__bp))\n \t    return false;\n \n-\t  unsigned int* __rover = reinterpret_cast<unsigned int*>(__bp.first) - 1;\n+\t  size_t* __rover = reinterpret_cast<size_t*>(__bp.first) - 1;\n \n \t  for (_Counter_type __i = 0; __i < __diff; ++__i)\n \t    {\n@@ -521,11 +527,11 @@ namespace __gnu_cxx\n \t}\n \n     \n-\tunsigned int*\n+\tsize_t*\n \t_M_get() const throw()\n \t{ return _M_pbitmap; }\n \n-\tunsigned int\n+\t_Counter_type\n \t_M_offset() const throw()\n \t{ return _M_data_offset * bits_per_block; }\n       };\n@@ -542,19 +548,19 @@ namespace __gnu_cxx\n \ttypedef _Tp pointer;\n     \n \t_BPVector& _M_vbp;\n-\tunsigned int* _M_curr_bmap;\n-\tunsigned int* _M_last_bmap_in_block;\n+\tsize_t* _M_curr_bmap;\n+\tsize_t* _M_last_bmap_in_block;\n \t_Index_type _M_curr_index;\n     \n       public:\n \t// Use the 2nd parameter with care. Make sure that such an\n \t// entry exists in the vector before passing that particular\n \t// index to this ctor.\n-\t_Bitmap_counter(_BPVector& Rvbp, int __index = -1) : _M_vbp(Rvbp)\n+\t_Bitmap_counter(_BPVector& Rvbp, long __index = -1) : _M_vbp(Rvbp)\n \t{ this->_M_reset(__index); }\n     \n \tvoid \n-\t_M_reset(int __index = -1) throw()\n+\t_M_reset(long __index = -1) throw()\n \t{\n \t  if (__index == -1)\n \t    {\n@@ -564,10 +570,10 @@ namespace __gnu_cxx\n \t    }\n \n \t  _M_curr_index = __index;\n-\t  _M_curr_bmap = reinterpret_cast<unsigned int*>\n+\t  _M_curr_bmap = reinterpret_cast<size_t*>\n \t    (_M_vbp[_M_curr_index].first) - 1;\n-\n-\t  _BALLOC_ASSERT(__index <= (int)_M_vbp.size() - 1);\n+\t  \n+\t  _BALLOC_ASSERT(__index <= (long)_M_vbp.size() - 1);\n \t\n \t  _M_last_bmap_in_block = _M_curr_bmap\n \t    - ((_M_vbp[_M_curr_index].second \n@@ -579,7 +585,7 @@ namespace __gnu_cxx\n \t// function ONLY those values that are known to be correct,\n \t// otherwise this will mess up big time.\n \tvoid\n-\t_M_set_internal_bitmap(unsigned int* __new_internal_marker) throw()\n+\t_M_set_internal_bitmap(size_t* __new_internal_marker) throw()\n \t{ _M_curr_bmap = __new_internal_marker; }\n     \n \tbool\n@@ -601,58 +607,59 @@ namespace __gnu_cxx\n \t  return *this;\n \t}\n     \n-\tunsigned int*\n+\tsize_t*\n \t_M_get() const throw()\n \t{ return _M_curr_bmap; }\n     \n \tpointer \n \t_M_base() const throw()\n \t{ return _M_vbp[_M_curr_index].first; }\n \n-\tunsigned int \n+\t_Index_type\n \t_M_offset() const throw()\n \t{\n \t  return bits_per_block\n-\t    * ((reinterpret_cast<unsigned int*>(this->_M_base()) \n+\t    * ((reinterpret_cast<size_t*>(this->_M_base()) \n \t\t- _M_curr_bmap) - 1);\n \t}\n     \n-\tunsigned int\n+\t_Index_type\n \t_M_where() const throw()\n \t{ return _M_curr_index; }\n       };\n \n     inline void \n-    __bit_allocate(unsigned int* __pbmap, unsigned int __pos) throw()\n+    __bit_allocate(size_t* __pbmap, size_t __pos) throw()\n     {\n-      unsigned int __mask = 1 << __pos;\n+      size_t __mask = 1 << __pos;\n       __mask = ~__mask;\n       *__pbmap &= __mask;\n     }\n   \n     inline void \n-    __bit_free(unsigned int* __pbmap, unsigned int __pos) throw()\n+    __bit_free(size_t* __pbmap, size_t __pos) throw()\n     {\n-      unsigned int __mask = 1 << __pos;\n+      size_t __mask = 1 << __pos;\n       *__pbmap |= __mask;\n     }\n   } // namespace balloc\n \n   // Generic Version of the bsf instruction.\n-  inline unsigned int \n-  _Bit_scan_forward(register unsigned int __num)\n-  { return static_cast<unsigned int>(__builtin_ctz(__num)); }\n+  inline size_t \n+  _Bit_scan_forward(size_t __num)\n+  { return static_cast<size_t>(__builtin_ctzl(__num)); }\n \n   class free_list\n   {\n-    typedef unsigned int* value_type;\n+    typedef size_t* value_type;\n     typedef balloc::__mini_vector<value_type> vector_type;\n     typedef vector_type::iterator iterator;\n \n     struct _LT_pointer_compare\n     {\n       bool\n-      operator()(const unsigned int* __pui, const unsigned int __cui) const throw()\n+      operator()(const size_t* __pui, \n+\t\t const size_t __cui) const throw()\n       { return *__pui < __cui; }\n     };\n \n@@ -662,9 +669,9 @@ namespace __gnu_cxx\n     static vector_type _S_free_list;\n     \n     void\n-    _M_validate(unsigned int* __addr) throw()\n+    _M_validate(size_t* __addr) throw()\n     {\n-      const unsigned int __max_size = 64;\n+      const vector_type::size_type __max_size = 64;\n       if (_S_free_list.size() >= __max_size)\n \t{\n \t  // Ok, the threshold value has been reached.  We determine\n@@ -696,10 +703,10 @@ namespace __gnu_cxx\n     }\n \n     bool \n-    _M_should_i_give(unsigned int __block_size, \n-\t\t     unsigned int __required_size) throw()\n+    _M_should_i_give(size_t __block_size, \n+\t\t     size_t __required_size) throw()\n     {\n-      const unsigned int __max_wastage_percentage = 36;\n+      const size_t __max_wastage_percentage = 36;\n       if (__block_size >= __required_size && \n \t  (((__block_size - __required_size) * 100 / __block_size)\n \t   < __max_wastage_percentage))\n@@ -710,20 +717,19 @@ namespace __gnu_cxx\n \n   public:\n     inline void \n-    _M_insert(unsigned int* __addr) throw()\n+    _M_insert(size_t* __addr) throw()\n     {\n #if defined __GTHREADS\n       _Auto_Lock __bfl_lock(&_S_bfl_mutex);\n #endif\n       // Call _M_validate to decide what should be done with\n       // this particular free list.\n-      this->_M_validate(reinterpret_cast<unsigned int*>\n-\t\t\t(reinterpret_cast<char*>(__addr) \n-\t\t\t - sizeof(unsigned int)));\n+      this->_M_validate(reinterpret_cast<size_t*>(__addr) - 1);\n+      // See discussion as to why this is 1!\n     }\n     \n-    unsigned int*\n-    _M_get(unsigned int __sz) throw(std::bad_alloc);\n+    size_t*\n+    _M_get(size_t __sz) throw(std::bad_alloc);\n \n     // This function just clears the internal Free List, and gives back\n     // all the memory to the OS.\n@@ -771,7 +777,7 @@ namespace __gnu_cxx\n \t};\n \n     private:\n-      template<unsigned int _BSize, unsigned int _AlignSize>\n+      template<size_t _BSize, size_t _AlignSize>\n         struct aligned_size\n \t{\n \t  enum\n@@ -783,7 +789,8 @@ namespace __gnu_cxx\n \n       struct _Alloc_block\n       {\n-\tchar __M_unused[aligned_size<sizeof(value_type), 8>::value];\n+\tchar __M_unused[aligned_size<sizeof(value_type),\n+\t\t\t_BALLOC_ALIGN_BYTES>::value];\n       };\n \n \n@@ -824,17 +831,16 @@ namespace __gnu_cxx\n \t_S_check_for_free_blocks();\n #endif\n \n-\tconst unsigned int __num_bitmaps = _S_block_size / balloc::bits_per_block;\n-\tconst unsigned int __size_to_allocate = sizeof(unsigned int)\n+\tconst size_t __num_bitmaps = _S_block_size / balloc::bits_per_block;\n+\tconst size_t __size_to_allocate = sizeof(size_t) \n \t  + _S_block_size * sizeof(_Alloc_block) \n-\t  + __num_bitmaps * sizeof(unsigned int);\n+\t  + __num_bitmaps * sizeof(size_t);\n \n-\tunsigned int* __temp = \n-\t  reinterpret_cast<unsigned int*>(this->_M_get(__size_to_allocate));\n+\tsize_t* __temp = \n+\t  reinterpret_cast<size_t*>\n+\t  (this->_M_get(__size_to_allocate));\n \t*__temp = 0;\n-\t// ++__temp;\n-\t__temp = reinterpret_cast<unsigned int*>\n-\t  (reinterpret_cast<char*>(__temp) + sizeof(unsigned int));\n+\t++__temp;\n \n \t// The Header information goes at the Beginning of the Block.\n \t_Block_pair __bp = \n@@ -847,18 +853,18 @@ namespace __gnu_cxx\n \t// Fill the Vector with this information.\n \t_S_mem_blocks.push_back(__bp);\n \n-\tunsigned int __bit_mask = 0; // 0 Indicates all Allocated.\n+\tsize_t __bit_mask = 0; // 0 Indicates all Allocated.\n \t__bit_mask = ~__bit_mask; // 1 Indicates all Free.\n \n-\tfor (unsigned int __i = 0; __i < __num_bitmaps; ++__i)\n+\tfor (size_t __i = 0; __i < __num_bitmaps; ++__i)\n \t  __temp[__i] = __bit_mask;\n \n \t_S_block_size *= 2;\n       }\n \n \n       static _BPVector _S_mem_blocks;\n-      static unsigned int _S_block_size;\n+      static size_t _S_block_size;\n       static __gnu_cxx::balloc::\n       _Bitmap_counter<_Alloc_block*> _S_last_request;\n       static typename _BPVector::size_type _S_last_dealloc_index;\n@@ -918,18 +924,18 @@ namespace __gnu_cxx\n \t\t// Search was successful. Ok, now mark the first bit from\n \t\t// the right as 0, meaning Allocated. This bit is obtained\n \t\t// by calling _M_get() on __fff.\n-\t\tunsigned int __nz_bit = _Bit_scan_forward(*__fff._M_get());\n+\t\tsize_t __nz_bit = _Bit_scan_forward(*__fff._M_get());\n \t\tballoc::__bit_allocate(__fff._M_get(), __nz_bit);\n \n \t\t_S_last_request._M_reset(__bpi - _S_mem_blocks.begin());\n \n \t\t// Now, get the address of the bit we marked as allocated.\n \t\tpointer __ret = reinterpret_cast<pointer>\n \t\t  (__bpi->first + __fff._M_offset() + __nz_bit);\n-\t\tunsigned int* __puse_count = reinterpret_cast<unsigned int*>\n-\t\t  (reinterpret_cast<char*>\n-\t\t   (__bpi->first) - (sizeof(unsigned int) * \n-\t\t\t\t     (__gnu_cxx::balloc::__num_bitmaps(*__bpi)+1)));\n+\t\tsize_t* __puse_count = \n+\t\t  reinterpret_cast<size_t*>\n+\t\t  (__bpi->first) \n+\t\t  - (__gnu_cxx::balloc::__num_bitmaps(*__bpi) + 1);\n \t\t\n \t\t++(*__puse_count);\n \t\treturn __ret;\n@@ -950,18 +956,16 @@ namespace __gnu_cxx\n \n \t// _S_last_request holds a pointer to a valid bit map, that\n \t// points to a free block in memory.\n-\tunsigned int __nz_bit = _Bit_scan_forward(*_S_last_request._M_get());\n+\tsize_t __nz_bit = _Bit_scan_forward(*_S_last_request._M_get());\n \tballoc::__bit_allocate(_S_last_request._M_get(), __nz_bit);\n \n \tpointer __ret = reinterpret_cast<pointer>\n \t  (_S_last_request._M_base() + _S_last_request._M_offset() + __nz_bit);\n \n-\tunsigned int* __puse_count = reinterpret_cast<unsigned int*>\n-\t  (reinterpret_cast<char*>\n-\t   (_S_mem_blocks[_S_last_request._M_where()].first)\n-\t   - (sizeof(unsigned int) * \n-\t      (__gnu_cxx::balloc::\n-\t       __num_bitmaps(_S_mem_blocks[_S_last_request._M_where()])+1)));\n+\tsize_t* __puse_count = reinterpret_cast<size_t*>\n+\t  (_S_mem_blocks[_S_last_request._M_where()].first)\n+\t  - (__gnu_cxx::balloc::\n+\t     __num_bitmaps(_S_mem_blocks[_S_last_request._M_where()]) + 1);\n \n \t++(*__puse_count);\n \treturn __ret;\n@@ -982,7 +986,7 @@ namespace __gnu_cxx\n \ttypedef typename _BPVector::difference_type _Difference_type;\n \n \t_Difference_type __diff;\n-\tint __displacement;\n+\tlong __displacement;\n \n \t_BALLOC_ASSERT(_S_last_dealloc_index >= 0);\n \n@@ -1000,10 +1004,12 @@ namespace __gnu_cxx\n \telse\n \t  {\n \t    _Iterator _iter = \n-\t      __gnu_cxx::balloc::__find_if(_S_mem_blocks.begin(), \n-\t\t\t\t\t   _S_mem_blocks.end(), \n-\t\t\t\t\t   __gnu_cxx::balloc::\n-\t\t\t\t\t   _Inclusive_between<_Alloc_block*>(__real_p));\n+\t      __gnu_cxx::balloc::\n+\t      __find_if(_S_mem_blocks.begin(), \n+\t\t\t_S_mem_blocks.end(), \n+\t\t\t__gnu_cxx::balloc::\n+\t\t\t_Inclusive_between<_Alloc_block*>(__real_p));\n+\n \t    _BALLOC_ASSERT(_iter != _S_mem_blocks.end());\n \n \t    __diff = _iter - _S_mem_blocks.begin();\n@@ -1012,17 +1018,16 @@ namespace __gnu_cxx\n \t  }\n \n \t// Get the position of the iterator that has been found.\n-\tconst unsigned int __rotate = __displacement % balloc::bits_per_block;\n-\tunsigned int* __bitmapC = \n-\t  reinterpret_cast<unsigned int*>(_S_mem_blocks[__diff].first) - 1;\n+\tconst size_t __rotate = __displacement % balloc::bits_per_block;\n+\tsize_t* __bitmapC = \n+\t  reinterpret_cast<size_t*>\n+\t  (_S_mem_blocks[__diff].first) - 1;\n \t__bitmapC -= (__displacement / balloc::bits_per_block);\n       \n \tballoc::__bit_free(__bitmapC, __rotate);\n-\tunsigned int* __puse_count = reinterpret_cast<unsigned int*>\n-\t\t  (reinterpret_cast<char*>\n-\t\t   (_S_mem_blocks[__diff].first)\n-\t\t   - (sizeof(unsigned int) * \n-\t\t      (__gnu_cxx::balloc::__num_bitmaps(_S_mem_blocks[__diff])+1)));\n+\tsize_t* __puse_count = reinterpret_cast<size_t*>\n+\t  (_S_mem_blocks[__diff].first)\n+\t  - (__gnu_cxx::balloc::__num_bitmaps(_S_mem_blocks[__diff]) + 1);\n \t\n \t_BALLOC_ASSERT(*__puse_count != 0);\n \n@@ -1143,7 +1148,8 @@ namespace __gnu_cxx\n     bitmap_allocator<_Tp>::_S_mem_blocks;\n \n   template<typename _Tp>\n-    unsigned int bitmap_allocator<_Tp>::_S_block_size = balloc::bits_per_block;\n+    size_t bitmap_allocator<_Tp>::_S_block_size = \n+    2 * balloc::bits_per_block;\n \n   template<typename _Tp>\n     typename __gnu_cxx::bitmap_allocator<_Tp>::_BPVector::size_type "}, {"sha": "b953ffdd876ba6835ec1be3278101e8af63ae4cb", "filename": "libstdc++-v3/src/bitmap_allocator.cc", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a815571193ab94a7821e6c9615af311f060bce2f/libstdc%2B%2B-v3%2Fsrc%2Fbitmap_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a815571193ab94a7821e6c9615af311f060bce2f/libstdc%2B%2B-v3%2Fsrc%2Fbitmap_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fbitmap_allocator.cc?ref=a815571193ab94a7821e6c9615af311f060bce2f", "patch": "@@ -41,21 +41,21 @@ namespace __gnu_cxx\n     <bitmap_allocator<wchar_t>::_Alloc_block*, \n      bitmap_allocator<wchar_t>::_Alloc_block*> >;\n \n-    template class __mini_vector<unsigned int*>;\n+    template class __mini_vector<size_t*>;\n \n-    template unsigned int** __lower_bound\n-    (unsigned int**, unsigned int**, \n-     unsigned int const&, free_list::_LT_pointer_compare);\n+    template size_t** __lower_bound\n+    (size_t**, size_t**, \n+     size_t const&, free_list::_LT_pointer_compare);\n   }\n \n #if defined __GTHREADS\n   _Mutex free_list::_S_bfl_mutex;\n #endif\n   free_list::vector_type free_list::_S_free_list;\n \n-  unsigned int*\n+  size_t*\n   free_list::\n-  _M_get(unsigned int __sz) throw(std::bad_alloc)\n+  _M_get(size_t __sz) throw(std::bad_alloc)\n   {\n #if defined __GTHREADS\n     _Lock __bfl_lock(&_S_bfl_mutex);\n@@ -77,15 +77,15 @@ namespace __gnu_cxx\n \t// Try twice to get the memory: once directly, and the 2nd\n \t// time after clearing the free list. If both fail, then\n \t// throw std::bad_alloc().\n-\tunsigned int __ctr = 2;\n+\tint __ctr = 2;\n \twhile (__ctr)\n \t  {\n-\t    unsigned int* __ret = 0;\n+\t    size_t* __ret = 0;\n \t    --__ctr;\n \t    try\n \t      {\n-\t\t__ret = reinterpret_cast<unsigned int*>\n-\t\t  (::operator new(__sz + sizeof(unsigned int)));\n+\t\t__ret = reinterpret_cast<size_t*>\n+\t\t  (::operator new(__sz + sizeof(size_t)));\n \t      }\n \t    catch(...)\n \t      {\n@@ -94,20 +94,18 @@ namespace __gnu_cxx\n \t    if (!__ret)\n \t      continue;\n \t    *__ret = __sz;\n-\t    return reinterpret_cast<unsigned int*>\n-\t      (reinterpret_cast<char*>(__ret) + sizeof(unsigned int));\n+\t    return __ret + 1;\n \t  }\n \tthrow std::bad_alloc();\n       }\n     else\n       {\n-\tunsigned int* __ret = *__temp;\n+\tsize_t* __ret = *__temp;\n \t_S_free_list.erase(__temp);\n #if defined __GTHREADS\n \t__bfl_lock._M_unlock();\n #endif\n-\treturn reinterpret_cast<unsigned int*>\n-\t  (reinterpret_cast<char*>(__ret) + sizeof(unsigned int));\n+\treturn __ret + 1;\n       }\n   }\n "}]}