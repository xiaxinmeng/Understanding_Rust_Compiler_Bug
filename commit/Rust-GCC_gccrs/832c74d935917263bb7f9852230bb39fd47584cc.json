{"sha": "832c74d935917263bb7f9852230bb39fd47584cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMyYzc0ZDkzNTkxNzI2M2JiN2Y5ODUyMjMwYmIzOWZkNDc1ODRjYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-08-23T10:21:21Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-08-23T10:21:21Z"}, "message": "[libiberty patch] Fix PGO bootstrap\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-08/msg01386.html\n\tPR driver/87056\n\t* pex-unix.c (pex_unix_exec_child): Duplicate bad_fn into local\n\tscopes to avoid potential clobber.\n\nCo-Authored-By: Martin Liska <mliska@suse.cz>\n\nFrom-SVN: r263807", "tree": {"sha": "bedb8d11024b94f9e213dd63f64b4b7bafcb7ca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bedb8d11024b94f9e213dd63f64b4b7bafcb7ca5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/832c74d935917263bb7f9852230bb39fd47584cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/832c74d935917263bb7f9852230bb39fd47584cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/832c74d935917263bb7f9852230bb39fd47584cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/832c74d935917263bb7f9852230bb39fd47584cc/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ebdb6f237772df251378d2c08350d345135bcb9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebdb6f237772df251378d2c08350d345135bcb9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebdb6f237772df251378d2c08350d345135bcb9e"}], "stats": {"total": 170, "additions": 90, "deletions": 80}, "files": [{"sha": "ed07acfa73a8ffb5a3e333aee1244649e5a72dee", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832c74d935917263bb7f9852230bb39fd47584cc/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832c74d935917263bb7f9852230bb39fd47584cc/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=832c74d935917263bb7f9852230bb39fd47584cc", "patch": "@@ -1,3 +1,10 @@\n+2018-08-23  Nathan Sidwell  <nathan@acm.org>\n+\t    Martin Liska  <mliska@suse.cz>\n+\n+\tPR driver/87056\n+\t* pex-unix.c (pex_unix_exec_child): Duplicate bad_fn into local\n+\tscopes to avoid potential clobber.\n+\n 2018-08-20  Nathan Sidwell  <nathan@acm.org>\n \n \t* pex-unix.c (pex_child_error): Delete."}, {"sha": "703010bdeae873877c1f3fa123fa8c15b078ef27", "filename": "libiberty/pex-unix.c", "status": "modified", "additions": 83, "deletions": 80, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832c74d935917263bb7f9852230bb39fd47584cc/libiberty%2Fpex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832c74d935917263bb7f9852230bb39fd47584cc/libiberty%2Fpex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-unix.c?ref=832c74d935917263bb7f9852230bb39fd47584cc", "patch": "@@ -582,8 +582,6 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n      issues.   */\n   char **save_environ = environ;\n \n-  const char *bad_fn = NULL;\n-\n   for (retries = 0; retries < 4; ++retries)\n     {\n       pid = vfork ();\n@@ -602,70 +600,72 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \n     case 0:\n       /* Child process.  */\n-      if (!bad_fn && in != STDIN_FILE_NO)\n-\t{\n-\t  if (dup2 (in, STDIN_FILE_NO) < 0)\n-\t    bad_fn = \"dup2\";\n-\t  else if (close (in) < 0)\n-\t    bad_fn = \"close\";\n-\t}\n-      if (!bad_fn && out != STDOUT_FILE_NO)\n-\t{\n-\t  if (dup2 (out, STDOUT_FILE_NO) < 0)\n-\t    bad_fn = \"dup2\";\n-\t  else if (close (out) < 0)\n-\t    bad_fn = \"close\";\n-\t}\n-      if (!bad_fn && errdes != STDERR_FILE_NO)\n-\t{\n-\t  if (dup2 (errdes, STDERR_FILE_NO) < 0)\n-\t    bad_fn = \"dup2\";\n-\t  else if (close (errdes) < 0)\n-\t    bad_fn = \"close\";\n-\t}\n-      if (!bad_fn && toclose >= 0)\n-\t{\n-\t  if (close (toclose) < 0)\n-\t    bad_fn = \"close\";\n-\t}\n-      if (!bad_fn && (flags & PEX_STDERR_TO_STDOUT) != 0)\n-\t{\n-\t  if (dup2 (STDOUT_FILE_NO, STDERR_FILE_NO) < 0)\n-\t    bad_fn = \"dup2\";\n-\t}\n-      if (!bad_fn)\n-\t{\n-\t  if (env)\n-\t    /* NOTE: In a standard vfork implementation this clobbers\n-\t       the parent's copy of environ \"too\" (in reality there's\n-\t       only one copy).  This is ok as we restore it below.  */\n-\t    environ = (char**) env;\n-\t  if ((flags & PEX_SEARCH) != 0)\n-\t    {\n-\t      execvp (executable, to_ptr32 (argv));\n-\t      bad_fn = \"execvp\";\n-\t    }\n-\t  else\n-\t    {\n-\t      execv (executable, to_ptr32 (argv));\n-\t      bad_fn = \"execv\";\n-\t    }\n-\t}\n-\n-      /* Something failed, report an error.  We don't use stdio\n-\t routines, because we might be here due to a vfork call.  */\n       {\n+\tconst char *bad_fn = NULL;\n+\n+\tif (!bad_fn && in != STDIN_FILE_NO)\n+\t  {\n+\t    if (dup2 (in, STDIN_FILE_NO) < 0)\n+\t      bad_fn = \"dup2\";\n+\t    else if (close (in) < 0)\n+\t      bad_fn = \"close\";\n+\t  }\n+\tif (!bad_fn && out != STDOUT_FILE_NO)\n+\t  {\n+\t    if (dup2 (out, STDOUT_FILE_NO) < 0)\n+\t      bad_fn = \"dup2\";\n+\t    else if (close (out) < 0)\n+\t      bad_fn = \"close\";\n+\t  }\n+\tif (!bad_fn && errdes != STDERR_FILE_NO)\n+\t  {\n+\t    if (dup2 (errdes, STDERR_FILE_NO) < 0)\n+\t      bad_fn = \"dup2\";\n+\t    else if (close (errdes) < 0)\n+\t      bad_fn = \"close\";\n+\t  }\n+\tif (!bad_fn && toclose >= 0)\n+\t  {\n+\t    if (close (toclose) < 0)\n+\t      bad_fn = \"close\";\n+\t  }\n+\tif (!bad_fn && (flags & PEX_STDERR_TO_STDOUT) != 0)\n+\t  {\n+\t    if (dup2 (STDOUT_FILE_NO, STDERR_FILE_NO) < 0)\n+\t      bad_fn = \"dup2\";\n+\t  }\n+\tif (!bad_fn)\n+\t  {\n+\t    if (env)\n+\t      /* NOTE: In a standard vfork implementation this clobbers\n+\t\t the parent's copy of environ \"too\" (in reality there's\n+\t\t only one copy).  This is ok as we restore it below.  */\n+\t      environ = (char**) env;\n+\t    if ((flags & PEX_SEARCH) != 0)\n+\t      {\n+\t\texecvp (executable, to_ptr32 (argv));\n+\t\tbad_fn = \"execvp\";\n+\t      }\n+\t    else\n+\t      {\n+\t\texecv (executable, to_ptr32 (argv));\n+\t\tbad_fn = \"execv\";\n+\t      }\n+\t  }\n+\n+\t/* Something failed, report an error.  We don't use stdio\n+\t   routines, because we might be here due to a vfork call.  */\n \tssize_t retval = 0;\n-\tint err = errno;\n-\n+\tint eno = errno;\n+\t\n #define writeerr(s) (retval |= write (STDERR_FILE_NO, s, strlen (s)))\n \twriteerr (obj->pname);\n \twriteerr (\": error trying to exec '\");\n \twriteerr (executable);\n \twriteerr (\"': \");\n \twriteerr (bad_fn);\n \twriteerr (\": \");\n-\twriteerr (xstrerror (err));\n+\twriteerr (xstrerror (eno));\n \twriteerr (\"\\n\");\n #undef writeerr\n \n@@ -677,30 +677,33 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \n     default:\n       /* Parent process.  */\n+      {\n+\tconst char *bad_fn = NULL;\n+\t\n+\t/* Restore environ.  Note that the parent either doesn't run\n+\t   until the child execs/exits (standard vfork behaviour), or\n+\t   if it does run then vfork is behaving more like fork.  In\n+\t   either case we needn't worry about clobbering the child's\n+\t   copy of environ.  */\n+\tenviron = save_environ;\n+\n+\tif (!bad_fn && in != STDIN_FILE_NO)\n+\t  if (close (in) < 0)\n+\t    bad_fn = \"close\";\n+\tif (!bad_fn && out != STDOUT_FILE_NO)\n+\t  if (close (out) < 0)\n+\t    bad_fn = \"close\";\n+\tif (!bad_fn && errdes != STDERR_FILE_NO)\n+\t  if (close (errdes) < 0)\n+\t    bad_fn = \"close\";\n \n-      /* Restore environ.\n-\t Note that the parent either doesn't run until the child execs/exits\n-\t (standard vfork behaviour), or if it does run then vfork is behaving\n-\t more like fork.  In either case we needn't worry about clobbering\n-\t the child's copy of environ.  */\n-      environ = save_environ;\n-\n-      if (!bad_fn && in != STDIN_FILE_NO)\n-\tif (close (in) < 0)\n-\t  bad_fn = \"close\";\n-      if (!bad_fn && out != STDOUT_FILE_NO)\n-\tif (close (out) < 0)\n-\t  bad_fn = \"close\";\n-      if (!bad_fn && errdes != STDERR_FILE_NO)\n-\tif (close (errdes) < 0)\n-\t  bad_fn = \"close\";\n-\n-      if (bad_fn)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = bad_fn;\n-\t  return (pid_t) -1;\n-\t}\n+\tif (bad_fn)\n+\t  {\n+\t    *err = errno;\n+\t    *errmsg = bad_fn;\n+\t    return (pid_t) -1;\n+\t  }\n+      }\n \n       return pid;\n     }"}]}