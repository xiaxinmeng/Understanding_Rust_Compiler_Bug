{"sha": "64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRjZmE2YzBkYmYxODk4NWY0ZmNmMjU5OGNiZDJhMDA5YzU1YTZhMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-05-09T15:37:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-05-09T15:37:12Z"}, "message": "Jan Hubicka  <jh@suse.cz>\n\tRichard Biener  <rguenther@suse.de>\n\n\tPR lto/54095\n\t* symtab.c (symtab_make_decl_local): Do not add private names.\n\n\t* lto.c (lto_register_var_decl_in_symtab): Don't do renaming.\n\t(lto_register_var_decl_in_symtab): Likewise.\n\t(lto_main): Promote statics.\n\t* lto-partition.c (privatize_symbol_name): New function.\n\t(promote_symbol): Use it.\n\t(may_need_named_section_p): New predicate.\n\t(rename_statics): New functions.\n\t(lto_promote_cross_file_statics): Simplify; do renaming.\n\t(lto_promote_statics_nonwpa): New function.\n\t* lto-partition.h (lto_promote_statics_nonwpa): New function.\n\nCo-Authored-By: Richard Biener <rguenther@suse.de>\n\nFrom-SVN: r198741", "tree": {"sha": "5bec71a52459958db61953abca4983cf0be11acc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bec71a52459958db61953abca4983cf0be11acc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/comments", "author": null, "committer": null, "parents": [{"sha": "c3167b004d64be32e926e053e83e34774ad0e2bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3167b004d64be32e926e053e83e34774ad0e2bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3167b004d64be32e926e053e83e34774ad0e2bd"}], "stats": {"total": 244, "additions": 172, "deletions": 72}, "files": [{"sha": "d22b31d1d638a4324a840a3f9805e0ed7b04df52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2", "patch": "@@ -1,3 +1,9 @@\n+2013-05-09  Jan Hubicka  <jh@suse.cz>\n+\t    Richard Biener  <rguenther@suse.de>\n+\n+\tPR lto/54095\n+\t* symtab.c (symtab_make_decl_local): Do not add private names.\n+\n 2013-05-09  Jan Hubicka  <jh@suse.cz>\n \n \tPR lto/54095"}, {"sha": "87320693361ad5c5f0cd7ad015d896c6f8c25558", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2", "patch": "@@ -1,3 +1,17 @@\n+2013-05-09  Jan Hubicka  <jh@suse.cz>\n+\t    Richard Biener  <rguenther@suse.de>\n+\n+\t* lto.c (lto_register_var_decl_in_symtab): Don't do renaming.\n+\t(lto_register_var_decl_in_symtab): Likewise.\n+\t(lto_main): Promote statics.\n+\t* lto-partition.c (privatize_symbol_name): New function.\n+\t(promote_symbol): Use it.\n+\t(may_need_named_section_p): New predicate.\n+\t(rename_statics): New functions.\n+\t(lto_promote_cross_file_statics): Simplify; do renaming.\n+\t(lto_promote_statics_nonwpa): New function.\n+\t* lto-partition.h (lto_promote_statics_nonwpa): New function.\n+\n 2013-02-08  Richard Biener  <rguenther@suse.de>\n \n \tPR lto/56231"}, {"sha": "652272ac1efdecebcc318560aca946e631521e23", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 148, "deletions": 4, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2", "patch": "@@ -755,6 +755,56 @@ lto_balanced_map (void)\n   free (order);\n }\n \n+/* Mangle NODE symbol name into a local name.  \n+   This is necessary to do\n+   1) if two or more static vars of same assembler name\n+      are merged into single ltrans unit.\n+   2) if prevoiusly static var was promoted hidden to avoid possible conflict\n+      with symbols defined out of the LTO world.\n+*/\n+\n+static void\n+privatize_symbol_name (symtab_node node)\n+{\n+  tree decl = node->symbol.decl;\n+  const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  char *label;\n+\n+  /* Our renaming machinery do not handle more than one change of assembler name.\n+     We should not need more than one anyway.  */\n+  if (node->symbol.lto_file_data\n+      && lto_get_decl_name_mapping (node->symbol.lto_file_data, name) != name)\n+    {\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file,\n+\t\t\"Not privatizing symbol name: %s. It privatized already.\\n\",\n+\t\tname);\n+      return;\n+    }\n+  /* Avoid mangling of already mangled clones. \n+     ???  should have a flag whether a symbol has a 'private' name already,\n+     since we produce some symbols like that i.e. for global constructors\n+     that are not really clones.  */\n+  if (node->symbol.unique_name)\n+    {\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file,\n+\t\t\"Not privatizing symbol name: %s. Has unique name.\\n\",\n+\t\tname);\n+      return;\n+    }\n+  ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n+  change_decl_assembler_name (decl, clone_function_name (decl, \"lto_priv\"));\n+  if (node->symbol.lto_file_data)\n+    lto_record_renamed_decl (node->symbol.lto_file_data, name,\n+\t\t\t     IDENTIFIER_POINTER\n+\t\t\t     (DECL_ASSEMBLER_NAME (decl)));\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file,\n+\t    \"Privatizing symbol name: %s -> %s\\n\",\n+\t    name, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n+}\n+\n /* Promote variable VNODE to be static.  */\n \n static void\n@@ -768,6 +818,9 @@ promote_symbol (symtab_node node)\n \n   gcc_checking_assert (!TREE_PUBLIC (node->symbol.decl)\n \t\t       && !DECL_EXTERNAL (node->symbol.decl));\n+  /* Be sure that newly public symbol does not conflict with anything already\n+     defined by the non-LTO part.  */\n+  privatize_symbol_name (node);\n   TREE_PUBLIC (node->symbol.decl) = 1;\n   DECL_VISIBILITY (node->symbol.decl) = VISIBILITY_HIDDEN;\n   DECL_VISIBILITY_SPECIFIED (node->symbol.decl) = true;\n@@ -776,6 +829,85 @@ promote_symbol (symtab_node node)\n \t    \"Promoting as hidden: %s\\n\", symtab_node_name (node));\n }\n \n+/* Return true if NODE needs named section even if it won't land in the partition\n+   symbol table.\n+   FIXME: we should really not use named sections for inline clones and master clones.  */\n+\n+static bool\n+may_need_named_section_p (lto_symtab_encoder_t encoder, symtab_node node)\n+{\n+  struct cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+  if (!cnode)\n+    return false;\n+  if (symtab_real_symbol_p (node))\n+    return false;\n+  if (!cnode->global.inlined_to && !cnode->clones)\n+    return false;\n+  return (!encoder\n+\t  || (lto_symtab_encoder_lookup (encoder, node) != LCC_NOT_FOUND\n+              && lto_symtab_encoder_encode_body_p (encoder,\n+\t\t\t\t                   cnode)));\n+}\n+\n+/* If NODE represents a static variable.  See if there are other variables\n+   of the same name in partition ENCODER (or in whole compilation unit if\n+   ENCODER is NULL) and if so, mangle the statics.  Always mangle all\n+   conflicting statics, so we reduce changes of silently miscompiling\n+   asm statemnets refering to them by symbol name.  */\n+\n+static void\n+rename_statics (lto_symtab_encoder_t encoder, symtab_node node)\n+{\n+  tree decl = node->symbol.decl;\n+  symtab_node s;\n+  tree name = DECL_ASSEMBLER_NAME (decl);\n+\n+  /* See if this is static symbol. */\n+  if ((node->symbol.externally_visible\n+      /* FIXME: externally_visible is somewhat illogically not set for\n+\t external symbols (i.e. those not defined).  Remove this test\n+\t once this is fixed.  */\n+        || DECL_EXTERNAL (node->symbol.decl)\n+        || !symtab_real_symbol_p (node))\n+       && !may_need_named_section_p (encoder, node))\n+    return;\n+\n+  /* Now walk symbols sharing the same name and see if there are any conflicts.\n+     (all types of symbols counts here, since we can not have static of the\n+     same name as external or public symbol.)  */\n+  for (s = symtab_node_for_asm (name);\n+       s; s = s->symbol.next_sharing_asm_name)\n+    if ((symtab_real_symbol_p (s) || may_need_named_section_p (encoder, s))\n+\t&& s->symbol.decl != node->symbol.decl\n+\t&& (!encoder\n+\t    || lto_symtab_encoder_lookup (encoder, s) != LCC_NOT_FOUND))\n+       break;\n+\n+  /* OK, no confict, so we have nothing to do.  */\n+  if (!s)\n+    return;\n+\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file,\n+\t    \"Renaming statics with asm name: %s\\n\", symtab_node_name (node));\n+\n+  /* Assign every symbol in the set that shares the same ASM name an unique\n+     mangled name.  */\n+  for (s = symtab_node_for_asm (name); s;)\n+    if (!s->symbol.externally_visible\n+\t&& ((symtab_real_symbol_p (s)\n+             && !DECL_EXTERNAL (node->symbol.decl)\n+\t     && !TREE_PUBLIC (node->symbol.decl))\n+ \t    || may_need_named_section_p (encoder, s))\n+\t&& (!encoder\n+\t    || lto_symtab_encoder_lookup (encoder, s) != LCC_NOT_FOUND))\n+      {\n+        privatize_symbol_name (s);\n+\t/* Re-start from beggining since we do not know how many symbols changed a name.  */\n+\ts = symtab_node_for_asm (name);\n+      }\n+   else s = s->symbol.next_sharing_asm_name;\n+}\n \n /* Find out all static decls that need to be promoted to global because\n    of cross file sharing.  This function must be run in the WPA mode after\n@@ -801,16 +933,17 @@ lto_promote_cross_file_statics (void)\n   for (i = 0; i < n_sets; i++)\n     {\n       lto_symtab_encoder_iterator lsei;\n-      lto_symtab_encoder_t encoder;\n-      ltrans_partition part\n-\t= ltrans_partitions[i];\n+      lto_symtab_encoder_t encoder = ltrans_partitions[i]->encoder;\n \n-      encoder = part->encoder;\n       for (lsei = lsei_start (encoder); !lsei_end_p (lsei);\n \t   lsei_next (&lsei))\n         {\n           symtab_node node = lsei_node (lsei);\n \n+\t  /* If symbol is static, rename it if its assembler name clash with\n+\t     anything else in this unit.  */\n+\t  rename_statics (encoder, node);\n+\n \t  /* No need to promote if symbol already is externally visible ... */\n \t  if (node->symbol.externally_visible\n  \t      /* ... or if it is part of current partition ... */\n@@ -824,3 +957,14 @@ lto_promote_cross_file_statics (void)\n         }\n     }\n }\n+\n+/* Rename statics in the whole unit in the case that \n+   we do -flto-partition=none.  */\n+\n+void\n+lto_promote_statics_nonwpa (void)\n+{\n+  symtab_node node;\n+  FOR_EACH_SYMBOL (node)\n+    rename_statics (NULL, node);\n+}"}, {"sha": "73c131f9c166ffe266ceaf949565b549434051c5", "filename": "gcc/lto/lto-partition.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2Flto%2Flto-partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2Flto%2Flto-partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.h?ref=64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2", "patch": "@@ -37,3 +37,4 @@ void lto_max_map (void);\n void lto_balanced_map (void);\n void lto_promote_cross_file_statics (void);\n void free_ltrans_partitions (void);\n+void lto_promote_statics_nonwpa (void);"}, {"sha": "09433353e88820f7073d4ca8527b03d988edda3d", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2", "patch": "@@ -1748,23 +1748,11 @@ lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl)\n {\n   tree context;\n \n-  /* Variable has file scope, not local. Need to ensure static variables\n-     between different files don't clash unexpectedly.  */\n+  /* Variable has file scope, not local.  */\n   if (!TREE_PUBLIC (decl)\n       && !((context = decl_function_context (decl))\n \t   && auto_var_in_fn_p (decl, context)))\n     {\n-      /* ??? We normally pre-mangle names before we serialize them\n-\t out.  Here, in lto1, we do not know the language, and\n-\t thus cannot do the mangling again. Instead, we just\n-\t append a suffix to the mangled name.  The resulting name,\n-\t however, is not a properly-formed mangled name, and will\n-\t confuse any attempt to unmangle it.  */\n-      const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-      char *label;\n-\n-      ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n-      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n       rest_of_decl_compilation (decl, 1, 0);\n     }\n \n@@ -1788,44 +1776,6 @@ lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl)\n static void\n lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl)\n {\n-  /* Need to ensure static entities between different files\n-     don't clash unexpectedly.  */\n-  if (!TREE_PUBLIC (decl))\n-    {\n-      /* We must not use the DECL_ASSEMBLER_NAME macro here, as it\n-\t may set the assembler name where it was previously empty.  */\n-      tree old_assembler_name = decl->decl_with_vis.assembler_name;\n-\n-      /* FIXME lto: We normally pre-mangle names before we serialize\n-\t them out.  Here, in lto1, we do not know the language, and\n-\t thus cannot do the mangling again. Instead, we just append a\n-\t suffix to the mangled name.  The resulting name, however, is\n-\t not a properly-formed mangled name, and will confuse any\n-\t attempt to unmangle it.  */\n-      const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-      char *label;\n-\n-      ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n-      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n-\n-      /* We may arrive here with the old assembler name not set\n-\t if the function body is not needed, e.g., it has been\n-\t inlined away and does not appear in the cgraph.  */\n-      if (old_assembler_name)\n-\t{\n-\t  tree new_assembler_name = DECL_ASSEMBLER_NAME (decl);\n-\n-\t  /* Make the original assembler name available for later use.\n-\t     We may have used it to indicate the section within its\n-\t     object file where the function body may be found.\n-\t     FIXME lto: Find a better way to maintain the function decl\n-\t     to body section mapping so we don't need this hack.  */\n-\t  lto_record_renamed_decl (data_in->file_data,\n-\t\t\t\t   IDENTIFIER_POINTER (old_assembler_name),\n-\t\t\t\t   IDENTIFIER_POINTER (new_assembler_name));\n-\t}\n-    }\n-\n   /* If this variable has already been declared, queue the\n      declaration for merging.  */\n   if (TREE_PUBLIC (decl) && !DECL_ABSTRACT (decl))\n@@ -3396,6 +3346,8 @@ lto_main (void)\n \t  timevar_start (TV_PHASE_OPT_GEN);\n \n \t  materialize_cgraph ();\n+\t  if (!flag_ltrans)\n+\t    lto_promote_statics_nonwpa ();\n \n \t  /* Let the middle end know that we have read and merged all of\n \t     the input files.  */ "}, {"sha": "56f0de94d9c26ab3ce53f3c5836b1050154ff504", "filename": "gcc/symtab.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=64cfa6c0dbf18985f4fcf2598cbd2a009c55a6a2", "patch": "@@ -756,23 +756,6 @@ symtab_make_decl_local (tree decl)\n \n   if (DECL_ONE_ONLY (decl) || DECL_COMDAT (decl))\n     {\n-      /* It is possible that we are linking against library defining same COMDAT\n-\t function.  To avoid conflict we need to rename our local name of the\n-\t function just in the case WHOPR partitioning decide to make it hidden\n-\t to avoid cross partition references.  */\n-      if (flag_wpa)\n-\t{\n-\t  const char *old_name;\n-          symtab_node node = symtab_get_node (decl);\n-\t  old_name  = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-\t  change_decl_assembler_name (decl,\n-\t\t\t\t      clone_function_name (decl, \"local\"));\n-\t  if (node->symbol.lto_file_data)\n-\t    lto_record_renamed_decl (node->symbol.lto_file_data,\n-\t\t\t\t     old_name,\n-\t\t\t\t     IDENTIFIER_POINTER\n-\t\t\t\t       (DECL_ASSEMBLER_NAME (decl)));\n-\t}\n       DECL_SECTION_NAME (decl) = 0;\n       DECL_COMDAT (decl) = 0;\n     }"}]}