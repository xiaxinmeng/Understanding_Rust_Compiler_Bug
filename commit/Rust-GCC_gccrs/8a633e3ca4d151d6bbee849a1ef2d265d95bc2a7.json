{"sha": "8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE2MzNlM2NhNGQxNTFkNmJiZWU4NDlhMWVmMmQyNjVkOTViYzJhNw==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-09-02T06:05:31Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:20Z"}, "message": "Attempt to modify buffered_queue to take ownership of a source rather than reference, other cleanup\n\nAttempt to fix compile errors caused by make_shared with private constructor\n\nAttempt to fix compile errors\n\nAttempt to fix appearance of no characters in lexer", "tree": {"sha": "a4ad4b385fa736a030c11940d6a197386ea7e733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4ad4b385fa736a030c11940d6a197386ea7e733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "318a91e6baec6dfb406bc069866789c0a11b01e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/318a91e6baec6dfb406bc069866789c0a11b01e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/318a91e6baec6dfb406bc069866789c0a11b01e0"}], "stats": {"total": 9592, "additions": 3934, "deletions": 5658}, "files": [{"sha": "75ea74dd068137a9e9a4670ee6fea27d9898e929", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 574, "deletions": 585, "changes": 1159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7"}, {"sha": "0d89d51411764eef9c27c5a94fe26f74059bd6a2", "filename": "gcc/rust/ast/rust-ast-visitor.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-visitor.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -7,8 +7,8 @@\n \n namespace Rust {\n namespace AST {\n-// Pure abstract class that provides an interface for accessing different\n-// classes of the AST.\n+/* Pure abstract class that provides an interface for accessing different\n+ * classes of the AST. */\n class ASTVisitor\n {\n public:"}, {"sha": "4c115b22ae51fab0dab263e26af30b714e86f964", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 356, "deletions": 416, "changes": 772, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -4,15 +4,12 @@\n \n // GCC imports\n #include \"config.h\"\n-//#define INCLUDE_UNIQUE_PTR\n-// should allow including the gcc emulation of std::unique_ptr\n #include \"system.h\"\n-#include \"coretypes.h\" // order: config, INCLUDE, system, coretypes\n+#include \"coretypes.h\" // order: config, system, coretypes\n \n #include \"rust-system.h\"\n \n // STL imports\n-// with C++11, now can use actual std::unique_ptr\n #include <memory>\n #include <string>\n #include <vector>\n@@ -25,9 +22,7 @@\n \n namespace Rust {\n // TODO: remove typedefs and make actual types for these\n-// typedef int Location;\n-// typedef ::std::string SimplePath;\n-typedef ::std::string Identifier;\n+typedef std::string Identifier;\n typedef int TupleIndex;\n \n struct Session;\n@@ -59,7 +54,7 @@ enum DelimType\n     }\n \n     // Get node output as a string. Pure virtual.\n-    virtual ::std::string as_string() const = 0;\n+    virtual std::string as_string() const = 0;\n \n     virtual ~Node() {}\n \n@@ -79,19 +74,19 @@ class AttrInput\n   virtual ~AttrInput () {}\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<AttrInput> clone_attr_input () const\n+  std::unique_ptr<AttrInput> clone_attr_input () const\n   {\n-    return ::std::unique_ptr<AttrInput> (clone_attr_input_impl ());\n+    return std::unique_ptr<AttrInput> (clone_attr_input_impl ());\n   }\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n   virtual bool check_cfg_predicate (const Session &session) const = 0;\n \n   // Parse attribute input to meta item, if possible\n-  virtual AttrInput *parse_to_meta_item () const { return NULL; }\n+  virtual AttrInput *parse_to_meta_item () const { return nullptr; }\n \n protected:\n   // pure virtual clone implementation\n@@ -108,19 +103,18 @@ class TokenTree\n   virtual ~TokenTree () {}\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<TokenTree> clone_token_tree () const\n+  std::unique_ptr<TokenTree> clone_token_tree () const\n   {\n-    return ::std::unique_ptr<TokenTree> (clone_token_tree_impl ());\n+    return std::unique_ptr<TokenTree> (clone_token_tree_impl ());\n   }\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n   /* Converts token tree to a flat token stream. Tokens must be pointer to avoid\n    * mutual dependency with Token. */\n-  virtual ::std::vector< ::std::unique_ptr<Token> >\n-  to_token_stream () const = 0;\n+  virtual std::vector<std::unique_ptr<Token>> to_token_stream () const = 0;\n \n protected:\n   // pure virtual clone implementation\n@@ -133,12 +127,12 @@ class MacroMatch\n public:\n   virtual ~MacroMatch () {}\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<MacroMatch> clone_macro_match () const\n+  std::unique_ptr<MacroMatch> clone_macro_match () const\n   {\n-    return ::std::unique_ptr<MacroMatch> (clone_macro_match_impl ());\n+    return std::unique_ptr<MacroMatch> (clone_macro_match_impl ());\n   }\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n@@ -165,23 +159,23 @@ class Token : public TokenTree, public MacroMatch\n \n public:\n   // Unique pointer custom clone function\n-  ::std::unique_ptr<Token> clone_token () const\n+  std::unique_ptr<Token> clone_token () const\n   {\n-    return ::std::unique_ptr<Token> (clone_token_impl ());\n+    return std::unique_ptr<Token> (clone_token_impl ());\n   }\n \n-  // constructor from general text - avoid using if lexer const_TokenPtr is\n-  // available\n-  Token (TokenId token_id, Location locus, ::std::string str,\n+  /* constructor from general text - avoid using if lexer const_TokenPtr is\n+   * available */\n+  Token (TokenId token_id, Location locus, std::string str,\n \t PrimitiveCoreType type_hint)\n-    : token_id (token_id), locus (locus), str (::std::move (str)),\n+    : token_id (token_id), locus (locus), str (std::move (str)),\n       type_hint (type_hint)\n   {}\n \n   // Constructor from lexer const_TokenPtr\n-  /* TODO: find workaround for std::string being NULL - probably have to\n+  /* TODO: find workaround for std::string being nullptr - probably have to\n    * introduce new method in lexer Token, or maybe make conversion method\n-   * there*/\n+   * there */\n   Token (const_TokenPtr lexer_token_ptr)\n     : token_id (lexer_token_ptr->get_id ()),\n       locus (lexer_token_ptr->get_locus ()), str (\"\"),\n@@ -213,7 +207,7 @@ class Token : public TokenTree, public MacroMatch\n       }\n   }\n \n-  inline bool is_string_lit () const\n+  bool is_string_lit () const\n   {\n     switch (token_id)\n       {\n@@ -225,13 +219,12 @@ class Token : public TokenTree, public MacroMatch\n       }\n   }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n   // Return copy of itself but in token stream form.\n-  virtual ::std::vector< ::std::unique_ptr<Token> >\n-  to_token_stream () const OVERRIDE;\n+  std::vector<std::unique_ptr<Token>> to_token_stream () const override;\n \n   TokenId get_id () const { return token_id; }\n \n@@ -241,18 +234,15 @@ class Token : public TokenTree, public MacroMatch\n   // No virtual for now as not polymorphic but can be in future\n   /*virtual*/ Token *clone_token_impl () const { return new Token (*this); }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual Token *clone_token_tree_impl () const OVERRIDE\n-  {\n-    return new Token (*this);\n-  }\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Token *clone_token_tree_impl () const override { return clone_token_impl (); }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual Token *clone_macro_match_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Token *clone_macro_match_impl () const override\n   {\n-    return new Token (*this);\n+    return clone_token_impl ();\n   }\n };\n \n@@ -274,18 +264,18 @@ struct Literal\n   };\n \n private:\n-  // TODO: maybe make subclasses of each type of literal with their typed values\n-  // (or generics)\n-  ::std::string value_as_string;\n+  /* TODO: maybe make subclasses of each type of literal with their typed values\n+   * (or generics) */\n+  std::string value_as_string;\n   LitType type;\n \n public:\n-  ::std::string as_string () const { return value_as_string; }\n+  std::string as_string () const { return value_as_string; }\n \n-  inline LitType get_lit_type () const { return type; }\n+  LitType get_lit_type () const { return type; }\n \n-  Literal (::std::string value_as_string, LitType type)\n-    : value_as_string (::std::move (value_as_string)), type (type)\n+  Literal (std::string value_as_string, LitType type)\n+    : value_as_string (std::move (value_as_string)), type (type)\n   {}\n \n   static Literal create_error () { return Literal (\"\", CHAR); }\n@@ -298,65 +288,45 @@ struct Literal\n class DelimTokenTree : public TokenTree, public AttrInput\n {\n   DelimType delim_type;\n-  ::std::vector< ::std::unique_ptr<TokenTree> > token_trees;\n-\n+  std::vector<std::unique_ptr<TokenTree>> token_trees;\n   Location locus;\n \n-  // TODO: move all the \"parse\" functions into a separate class that has the\n-  // token stream reference - will be cleaner Parse a meta item inner.\n-  //::std::unique_ptr<MetaItemInner> parse_meta_item_inner(const ::std::vector<\n-  //::std::unique_ptr<Token> >& token_stream, int& i) const; SimplePath\n-  // parse_simple_path(const ::std::vector< ::std::unique_ptr<Token> >&\n-  // token_stream, int& i) const; SimplePathSegment\n-  // parse_simple_path_segment(const ::std::vector<\n-  // ::std::unique_ptr<Token> >& token_stream, int& i) const;\n-  //::std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit(const\n-  //::std::unique_ptr<Token>&\n-  // tok) const;\n-  //::std::vector< ::std::unique_ptr<MetaItemInner> > parse_meta_item_seq(const\n-  //::std::vector< ::std::unique_ptr<Token> >& token_stream, int& i) const;\n-  // Literal\n-  // parse_literal(const ::std::unique_ptr<Token>& tok) const;\n-  //::std::unique_ptr<MetaItem> parse_path_meta_item(const ::std::vector<\n-  //::std::unique_ptr<Token> >& token_stream, int& i) const; bool\n-  // is_end_meta_item_tok(TokenId tok) const;\n-\n protected:\n-  // Use covariance to implement clone function as returning a DelimTokenTree\n-  // object\n-  virtual DelimTokenTree *clone_attr_input_impl () const OVERRIDE\n+  DelimTokenTree *clone_delim_tok_tree_impl () const\n   {\n     return new DelimTokenTree (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual DelimTokenTree *clone_token_tree_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_attr_input_impl () const override\n   {\n-    return new DelimTokenTree (*this);\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_token_tree_impl () const override\n+  {\n+    return clone_delim_tok_tree_impl ();\n   }\n \n public:\n   DelimTokenTree (DelimType delim_type,\n-\t\t  ::std::vector< ::std::unique_ptr<TokenTree> > token_trees\n-\t\t  = ::std::vector< ::std::unique_ptr<TokenTree> > (),\n+\t\t  std::vector<std::unique_ptr<TokenTree>> token_trees\n+\t\t  = std::vector<std::unique_ptr<TokenTree>> (),\n \t\t  Location locus = Location ())\n-    : delim_type (delim_type), token_trees (::std::move (token_trees)),\n+    : delim_type (delim_type), token_trees (std::move (token_trees)),\n       locus (locus)\n   {}\n \n   // Copy constructor with vector clone\n   DelimTokenTree (DelimTokenTree const &other)\n     : delim_type (other.delim_type), locus (other.locus)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     token_trees.reserve (other.token_trees.size ());\n-\n     for (const auto &e : other.token_trees)\n-      {\n-\ttoken_trees.push_back (e->clone_token_tree ());\n-      }\n+      token_trees.push_back (e->clone_token_tree ());\n   }\n \n   // overloaded assignment operator with vector clone\n@@ -365,14 +335,9 @@ class DelimTokenTree : public TokenTree, public AttrInput\n     delim_type = other.delim_type;\n     locus = other.locus;\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     token_trees.reserve (other.token_trees.size ());\n-\n     for (const auto &e : other.token_trees)\n-      {\n-\ttoken_trees.push_back (e->clone_token_tree ());\n-      }\n+      token_trees.push_back (e->clone_token_tree ());\n \n     return *this;\n   }\n@@ -383,65 +348,69 @@ class DelimTokenTree : public TokenTree, public AttrInput\n \n   static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n-  virtual bool\n-  check_cfg_predicate (const Session &session ATTRIBUTE_UNUSED) const OVERRIDE\n+  bool\n+  check_cfg_predicate (const Session &session ATTRIBUTE_UNUSED) const override\n   {\n     // this should never be called - should be converted first\n     return false;\n   }\n \n-  virtual AttrInput *parse_to_meta_item () const OVERRIDE;\n+  AttrInput *parse_to_meta_item () const override;\n+\n+  std::vector<std::unique_ptr<Token>> to_token_stream () const override;\n \n-  virtual ::std::vector< ::std::unique_ptr<Token> >\n-  to_token_stream () const OVERRIDE;\n+  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n+  {\n+    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n+  }\n };\n \n-// Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n-// be defined\n+/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n+ * be defined */\n class AttrInputLiteral;\n \n-// TODO: move applicable stuff into here or just don't include it because\n-// nothing uses it A segment of a path (maybe)\n+/* TODO: move applicable stuff into here or just don't include it because\n+ * nothing uses it A segment of a path (maybe) */\n class PathSegment\n {\n public:\n   virtual ~PathSegment () {}\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   // TODO: add visitor here?\n };\n \n // A segment of a simple path without generic or type arguments\n class SimplePathSegment : public PathSegment\n {\n-  ::std::string segment_name;\n+  std::string segment_name;\n   Location locus;\n \n   // only allow identifiers, \"super\", \"self\", \"crate\", or \"$crate\"\n public:\n   // TODO: put checks in constructor to enforce this rule?\n-  SimplePathSegment (::std::string segment_name, Location locus = Location ())\n-    : segment_name (::std::move (segment_name)), locus (locus)\n+  SimplePathSegment (std::string segment_name, Location locus = Location ())\n+    : segment_name (std::move (segment_name)), locus (locus)\n   {}\n \n-  // Returns whether simple path segment is in an invalid state (currently, if\n-  // empty).\n-  inline bool is_error () const { return segment_name.empty (); }\n+  /* Returns whether simple path segment is in an invalid state (currently, if\n+   * empty). */\n+  bool is_error () const { return segment_name.empty (); }\n \n   // Creates an error SimplePathSegment\n   static SimplePathSegment create_error ()\n   {\n-    return SimplePathSegment (::std::string (\"\"));\n+    return SimplePathSegment (std::string (\"\"));\n   }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  inline Location get_locus () const { return locus; }\n+  Location get_locus () const { return locus; }\n \n   // TODO: visitor pattern?\n };\n@@ -450,35 +419,35 @@ class SimplePathSegment : public PathSegment\n class SimplePath\n {\n   bool has_opening_scope_resolution;\n-  ::std::vector<SimplePathSegment> segments;\n+  std::vector<SimplePathSegment> segments;\n   Location locus;\n \n public:\n   // Constructor\n-  SimplePath (::std::vector<SimplePathSegment> path_segments,\n+  SimplePath (std::vector<SimplePathSegment> path_segments,\n \t      bool has_opening_scope_resolution = false,\n \t      Location locus = Location ())\n     : has_opening_scope_resolution (has_opening_scope_resolution),\n-      segments (::std::move (path_segments)), locus (locus)\n+      segments (std::move (path_segments)), locus (locus)\n   {}\n \n   // Creates an empty SimplePath.\n   static SimplePath create_empty ()\n   {\n-    return SimplePath (::std::vector<SimplePathSegment> ());\n+    return SimplePath (std::vector<SimplePathSegment> ());\n   }\n \n   // Returns whether the SimplePath is empty, i.e. has path segments.\n-  inline bool is_empty () const { return segments.empty (); }\n+  bool is_empty () const { return segments.empty (); }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n \n   // does this need visitor if not polymorphic? probably not\n \n   // path-to-string comparison operator\n-  bool operator== (const ::std::string &rhs)\n+  bool operator== (const std::string &rhs)\n   {\n     return !has_opening_scope_resolution && segments.size () == 1\n \t   && segments[0].as_string () == rhs;\n@@ -488,11 +457,11 @@ class SimplePath\n    * ensure that this is a valid identifier in path, so be careful. Also, this\n    * will have no location data.\n    * TODO have checks? */\n-  static SimplePath from_str (::std::string str)\n+  static SimplePath from_str (std::string str)\n   {\n-    ::std::vector<AST::SimplePathSegment> single_segments\n-      = {AST::SimplePathSegment (::std::move (str))};\n-    return SimplePath (::std::move (single_segments));\n+    std::vector<AST::SimplePathSegment> single_segments\n+      = {AST::SimplePathSegment (std::move (str))};\n+    return SimplePath (std::move (single_segments));\n   }\n };\n \n@@ -504,46 +473,41 @@ struct Attribute\n   SimplePath path;\n \n   // bool has_attr_input;\n-  // AttrInput* attr_input;\n-  ::std::unique_ptr<AttrInput> attr_input;\n+  std::unique_ptr<AttrInput> attr_input;\n \n   Location locus;\n \n   // TODO: maybe a variable storing whether attr input is parsed or not\n \n public:\n   // Returns whether Attribute has AttrInput\n-  inline bool has_attr_input () const { return attr_input != NULL; }\n+  bool has_attr_input () const { return attr_input != nullptr; }\n \n   // Constructor has pointer AttrInput for polymorphism reasons\n-  Attribute (SimplePath path, ::std::unique_ptr<AttrInput> input,\n+  Attribute (SimplePath path, std::unique_ptr<AttrInput> input,\n \t     Location locus = Location ())\n-    : path (::std::move (path)), attr_input (::std::move (input)), locus (locus)\n+    : path (std::move (path)), attr_input (std::move (input)), locus (locus)\n   {}\n \n+  // default destructor\n+  ~Attribute () = default;\n+\n   // Copy constructor must deep copy attr_input as unique pointer\n   Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n   {\n     // guard to protect from null pointer dereference\n-    if (other.attr_input != NULL)\n-      {\n-\tattr_input = other.attr_input->clone_attr_input ();\n-      }\n+    if (other.attr_input != nullptr)\n+      attr_input = other.attr_input->clone_attr_input ();\n   }\n \n-  // default destructor\n-  ~Attribute () = default;\n-\n   // overload assignment operator to use custom clone method\n   Attribute &operator= (Attribute const &other)\n   {\n     path = other.path;\n     locus = other.locus;\n     // guard to protect from null pointer dereference\n-    if (other.attr_input != NULL)\n-      {\n-\tattr_input = other.attr_input->clone_attr_input ();\n-      }\n+    if (other.attr_input != nullptr)\n+      attr_input = other.attr_input->clone_attr_input ();\n \n     return *this;\n   }\n@@ -553,26 +517,19 @@ struct Attribute\n   Attribute &operator= (Attribute &&other) = default;\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<Attribute> clone_attribute () const\n+  std::unique_ptr<Attribute> clone_attribute () const\n   {\n-    return ::std::unique_ptr<Attribute> (clone_attribute_impl ());\n+    return std::unique_ptr<Attribute> (clone_attribute_impl ());\n   }\n \n-  /*~Attribute() {\n-      delete attr_input;\n-  }*/\n-\n   // Creates an empty attribute (which is invalid)\n   static Attribute create_empty ()\n   {\n-    return Attribute (SimplePath::create_empty (), NULL);\n+    return Attribute (SimplePath::create_empty (), nullptr);\n   }\n \n   // Returns whether the attribute is considered an \"empty\" attribute.\n-  inline bool is_empty () const\n-  {\n-    return attr_input == NULL && path.is_empty ();\n-  }\n+  bool is_empty () const { return attr_input == nullptr && path.is_empty (); }\n \n   /* e.g.:\n       #![crate_type = \"lib\"]\n@@ -626,7 +583,7 @@ struct Attribute\n    *   windows_subsystem\n    *   feature     */\n \n-  ::std::string as_string () const;\n+  std::string as_string () const;\n \n   // TODO: does this require visitor pattern as not polymorphic?\n \n@@ -636,17 +593,15 @@ struct Attribute\n   // Call to parse attribute body to meta item syntax.\n   void parse_attr_to_meta_item ();\n \n-  // Determines whether cfg predicate is true and item with attribute should not\n-  // be stripped.\n+  /* Determines whether cfg predicate is true and item with attribute should not\n+   * be stripped. */\n   bool check_cfg_predicate (const Session &session)\n   {\n-    // assume that cfg predicate actually can exist, i.e. attribute has cfg or\n-    // cfg_attr path\n+    /* assume that cfg predicate actually can exist, i.e. attribute has cfg or\n+     * cfg_attr path */\n \n     if (!has_attr_input ())\n-      {\n-\treturn false;\n-      }\n+      return false;\n \n     // TODO: maybe replace with storing a \"has been parsed\" variable?\n     parse_attr_to_meta_item ();\n@@ -675,20 +630,20 @@ class MetaItemInner\n \n public:\n   // Unique pointer custom clone function\n-  ::std::unique_ptr<MetaItemInner> clone_meta_item_inner () const\n+  std::unique_ptr<MetaItemInner> clone_meta_item_inner () const\n   {\n-    return ::std::unique_ptr<MetaItemInner> (clone_meta_item_inner_impl ());\n+    return std::unique_ptr<MetaItemInner> (clone_meta_item_inner_impl ());\n   }\n \n   virtual ~MetaItemInner () {}\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n-  // HACK: used to simplify parsing - creates a copy of that type, or returns\n-  // null\n-  virtual MetaNameValueStr *to_meta_name_value_str () const { return NULL; }\n+  /* HACK: used to simplify parsing - creates a copy of that type, or returns\n+   * null */\n+  virtual MetaNameValueStr *to_meta_name_value_str () const { return nullptr; }\n \n   // HACK: used to simplify parsing - same thing\n   virtual SimplePath to_path_item () const\n@@ -702,63 +657,67 @@ class MetaItemInner\n // Container used to store MetaItems as AttrInput (bridge-ish kinda thing)\n class AttrInputMetaItemContainer : public AttrInput\n {\n-  ::std::vector< ::std::unique_ptr<MetaItemInner> > items;\n+  std::vector<std::unique_ptr<MetaItemInner>> items;\n \n public:\n   AttrInputMetaItemContainer (\n-    ::std::vector< ::std::unique_ptr<MetaItemInner> > items)\n-    : items (::std::move (items))\n+    std::vector<std::unique_ptr<MetaItemInner>> items)\n+    : items (std::move (items))\n   {}\n \n+  // no destructor definition required\n+\n+  // default move constructors\n+  AttrInputMetaItemContainer (AttrInputMetaItemContainer &&other) = default;\n+  AttrInputMetaItemContainer &operator= (AttrInputMetaItemContainer &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool check_cfg_predicate (const Session &session) const override;\n+\n+  // Clones this object.\n+  std::unique_ptr<AttrInputMetaItemContainer>\n+  clone_attr_input_meta_item_container () const\n+  {\n+    return std::unique_ptr<AttrInputMetaItemContainer> (\n+      clone_attr_input_meta_item_container_impl ());\n+  }\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  AttrInputMetaItemContainer *clone_attr_input_impl () const override\n+  {\n+    return clone_attr_input_meta_item_container_impl ();\n+  }\n+\n+  AttrInputMetaItemContainer *clone_attr_input_meta_item_container_impl () const\n+  {\n+    return new AttrInputMetaItemContainer (*this);\n+  }\n+\n   // copy constructor with vector clone\n   AttrInputMetaItemContainer (const AttrInputMetaItemContainer &other)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     items.reserve (other.items.size ());\n-\n     for (const auto &e : other.items)\n-      {\n-\titems.push_back (e->clone_meta_item_inner ());\n-      }\n+      items.push_back (e->clone_meta_item_inner ());\n   }\n \n-  // no destructor definition required\n-\n   // copy assignment operator with vector clone\n   AttrInputMetaItemContainer &\n   operator= (const AttrInputMetaItemContainer &other)\n   {\n     AttrInput::operator= (other);\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n-    items.reserve (other.items.size ());\n \n+    items.reserve (other.items.size ());\n     for (const auto &e : other.items)\n-      {\n-\titems.push_back (e->clone_meta_item_inner ());\n-      }\n+      items.push_back (e->clone_meta_item_inner ());\n \n     return *this;\n   }\n-\n-  // default move constructors\n-  AttrInputMetaItemContainer (AttrInputMetaItemContainer &&other) = default;\n-  AttrInputMetaItemContainer &operator= (AttrInputMetaItemContainer &&other)\n-    = default;\n-\n-  ::std::string as_string () const OVERRIDE;\n-\n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n-\n-  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n-\n-protected:\n-  // Use covariance to implement clone function as returning this type\n-  virtual AttrInputMetaItemContainer *clone_attr_input_impl () const OVERRIDE\n-  {\n-    return new AttrInputMetaItemContainer (*this);\n-  }\n };\n \n // abstract base meta item class\n@@ -793,19 +752,19 @@ class Stmt\n {\n public:\n   // Unique pointer custom clone function\n-  ::std::unique_ptr<Stmt> clone_stmt () const\n+  std::unique_ptr<Stmt> clone_stmt () const\n   {\n-    return ::std::unique_ptr<Stmt> (clone_stmt_impl ());\n+    return std::unique_ptr<Stmt> (clone_stmt_impl ());\n   }\n \n   virtual ~Stmt () {}\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n-  // HACK: slow way of getting location from base expression through virtual\n-  // methods.\n+  /* HACK: slow way of getting location from base expression through virtual\n+   * methods. */\n   virtual Location get_locus_slow () const { return Location (); }\n \n protected:\n@@ -816,31 +775,31 @@ class Stmt\n // Rust \"item\" AST node (declaration of top-level/module-level allowed stuff)\n class Item : public Stmt\n {\n-  ::std::vector<Attribute> outer_attrs;\n+  std::vector<Attribute> outer_attrs;\n \n   // TODO: should outer attrs be defined here or in each derived class?\n \n public:\n   // Unique pointer custom clone function\n-  ::std::unique_ptr<Item> clone_item () const\n+  std::unique_ptr<Item> clone_item () const\n   {\n-    return ::std::unique_ptr<Item> (clone_item_impl ());\n+    return std::unique_ptr<Item> (clone_item_impl ());\n   }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const;\n \n-  // Adds crate names to the vector passed by reference, if it can\n-  // (polymorphism).\n+  /* Adds crate names to the vector passed by reference, if it can\n+   * (polymorphism). */\n   virtual void\n-  add_crate_name (::std::vector< ::std::string> &names ATTRIBUTE_UNUSED) const\n+  add_crate_name (std::vector<std::string> &names ATTRIBUTE_UNUSED) const\n   {}\n \n   virtual void accept_vis (ASTVisitor &vis ATTRIBUTE_UNUSED) {}\n \n protected:\n   // Constructor\n-  Item (::std::vector<Attribute> outer_attribs = ::std::vector<Attribute> ())\n-    : outer_attrs (::std::move (outer_attribs))\n+  Item (std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+    : outer_attrs (std::move (outer_attribs))\n   {}\n \n   // Clone function implementation as pure virtual method\n@@ -849,7 +808,7 @@ class Item : public Stmt\n   /* Save having to specify two clone methods in derived classes by making\n    * statement clone return item clone. Hopefully won't affect performance too\n    * much. */\n-  virtual Item *clone_stmt_impl () const OVERRIDE { return clone_item_impl (); }\n+  Item *clone_stmt_impl () const override { return clone_item_impl (); }\n };\n \n // forward decl of ExprWithoutBlock\n@@ -859,62 +818,51 @@ class ExprWithoutBlock;\n class Expr\n {\n   // TODO: move outer attribute data to derived classes?\n-  ::std::vector<Attribute> outer_attrs;\n+  std::vector<Attribute> outer_attrs;\n \n public:\n-  inline const ::std::vector<Attribute> &get_outer_attrs () const\n-  {\n-    return outer_attrs;\n-  }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<Expr> clone_expr () const\n+  std::unique_ptr<Expr> clone_expr () const\n   {\n-    return ::std::unique_ptr<Expr> (clone_expr_impl ());\n+    return std::unique_ptr<Expr> (clone_expr_impl ());\n   }\n \n   /* TODO: public methods that could be useful:\n    *  - get_type() - returns type of expression. set_type() may also be useful\n    * for some?\n    *  - evaluate() - evaluates expression if constant? can_evaluate()? */\n \n-  // HACK: downcasting without dynamic_cast (if possible) via polymorphism -\n-  // overrided in subclasses of ExprWithoutBlock\n-  virtual ExprWithoutBlock *as_expr_without_block () const\n-  {\n-    // DEBUG\n-    fprintf (\n-      stderr,\n-      \"clone expr without block returns null and has not been overriden\\n\");\n-\n-    return NULL;\n-  }\n+  /* HACK: downcasting without dynamic_cast (if possible) via polymorphism -\n+   * overrided in subclasses of ExprWithoutBlock */\n+  virtual ExprWithoutBlock *as_expr_without_block () const { return nullptr; }\n \n   // TODO: make pure virtual if move out outer attributes to derived classes\n-  virtual ::std::string as_string () const;\n+  virtual std::string as_string () const;\n \n   virtual ~Expr () {}\n \n-  // HACK: slow way of getting location from base expression through virtual\n-  // methods.\n+  /* HACK: slow way of getting location from base expression through virtual\n+   * methods. */\n   virtual Location get_locus_slow () const { return Location (); }\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n protected:\n   // Constructor\n-  Expr (::std::vector<Attribute> outer_attribs = ::std::vector<Attribute> ())\n-    : outer_attrs (::std::move (outer_attribs))\n+  Expr (std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+    : outer_attrs (std::move (outer_attribs))\n   {}\n \n   // Clone function implementation as pure virtual method\n   virtual Expr *clone_expr_impl () const = 0;\n \n   // TODO: think of less hacky way to implement this kind of thing\n   // Sets outer attributes.\n-  void set_outer_attrs (::std::vector<Attribute> outer_attrs_to_set)\n+  void set_outer_attrs (std::vector<Attribute> outer_attrs_to_set)\n   {\n-    outer_attrs = ::std::move (outer_attrs_to_set);\n+    outer_attrs = std::move (outer_attrs_to_set);\n   }\n };\n \n@@ -923,45 +871,41 @@ class ExprWithoutBlock : public Expr\n {\n protected:\n   // Constructor\n-  ExprWithoutBlock (::std::vector<Attribute> outer_attribs\n-\t\t    = ::std::vector<Attribute> ())\n-    : Expr (::std::move (outer_attribs))\n+  ExprWithoutBlock (std::vector<Attribute> outer_attribs\n+\t\t    = std::vector<Attribute> ())\n+    : Expr (std::move (outer_attribs))\n   {}\n \n   // pure virtual clone implementation\n   virtual ExprWithoutBlock *clone_expr_without_block_impl () const = 0;\n \n   /* Save having to specify two clone methods in derived classes by making expr\n-   * clone\n-   * return exprwithoutblock clone. Hopefully won't affect performance too much.\n-   */\n-  virtual ExprWithoutBlock *clone_expr_impl () const OVERRIDE\n+   * clone return exprwithoutblock clone. Hopefully won't affect performance too\n+   * much. */\n+  ExprWithoutBlock *clone_expr_impl () const override\n   {\n     return clone_expr_without_block_impl ();\n   }\n \n public:\n   // Unique pointer custom clone function\n-  ::std::unique_ptr<ExprWithoutBlock> clone_expr_without_block () const\n+  std::unique_ptr<ExprWithoutBlock> clone_expr_without_block () const\n   {\n-    return ::std::unique_ptr<ExprWithoutBlock> (\n-      clone_expr_without_block_impl ());\n+    return std::unique_ptr<ExprWithoutBlock> (clone_expr_without_block_impl ());\n   }\n \n-  // downcasting hack from expr to use pratt parsing with\n-  // parse_expr_without_block\n-  virtual ExprWithoutBlock *as_expr_without_block () const OVERRIDE\n+  /* downcasting hack from expr to use pratt parsing with\n+   * parse_expr_without_block */\n+  ExprWithoutBlock *as_expr_without_block () const override\n   {\n-    // DEBUG\n-    fprintf (stderr, \"about to call the impl for clone expr without block\\n\");\n-\n     return clone_expr_without_block_impl ();\n   }\n };\n \n-// HACK: IdentifierExpr, delete when figure out identifier vs expr problem in\n-// Pratt parser Alternatively, identifiers could just be represented as\n-// single-segment paths\n+/* HACK: IdentifierExpr, delete when figure out identifier vs expr problem in\n+ * Pratt parser */\n+/* Alternatively, identifiers could just be represented as single-segment paths\n+ */\n class IdentifierExpr : public ExprWithoutBlock\n {\n public:\n@@ -970,43 +914,56 @@ class IdentifierExpr : public ExprWithoutBlock\n   Location locus;\n \n   IdentifierExpr (Identifier ident, Location locus = Location (),\n-\t\t  ::std::vector<Attribute> outer_attrs\n-\t\t  = ::std::vector<Attribute> ())\n-    : ExprWithoutBlock (::std::move (outer_attrs)), ident (::std::move (ident)),\n+\t\t  std::vector<Attribute> outer_attrs\n+\t\t  = std::vector<Attribute> ())\n+    : ExprWithoutBlock (std::move (outer_attrs)), ident (std::move (ident)),\n       locus (locus)\n   {}\n \n-  ::std::string as_string () const OVERRIDE { return ident; }\n+  std::string as_string () const override { return ident; }\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n \n-  Location get_locus_slow () const OVERRIDE { return get_locus (); }\n+  void accept_vis (ASTVisitor &vis) override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  // Clones this object.\n+  std::unique_ptr<IdentifierExpr> clone_identifier_expr () const\n+  {\n+    return std::unique_ptr<IdentifierExpr> (clone_identifier_expr_impl ());\n+  }\n \n protected:\n   // Clone method implementation\n-  virtual IdentifierExpr *clone_expr_without_block_impl () const OVERRIDE\n+  IdentifierExpr *clone_expr_without_block_impl () const override\n+  {\n+    return clone_identifier_expr_impl ();\n+  }\n+\n+  IdentifierExpr *clone_identifier_expr_impl () const\n   {\n     return new IdentifierExpr (*this);\n   }\n+\n+  IdentifierExpr (IdentifierExpr const &other) = default;\n+  IdentifierExpr &operator= (IdentifierExpr const &other) = default;\n };\n \n // Pattern base AST node\n class Pattern\n {\n public:\n   // Unique pointer custom clone function\n-  ::std::unique_ptr<Pattern> clone_pattern () const\n+  std::unique_ptr<Pattern> clone_pattern () const\n   {\n-    return ::std::unique_ptr<Pattern> (clone_pattern_impl ());\n+    return std::unique_ptr<Pattern> (clone_pattern_impl ());\n   }\n \n   // possible virtual methods: is_refutable()\n \n   virtual ~Pattern () {}\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n@@ -1023,24 +980,24 @@ class Type\n {\n public:\n   // Unique pointer custom clone function\n-  ::std::unique_ptr<Type> clone_type () const\n+  std::unique_ptr<Type> clone_type () const\n   {\n-    return ::std::unique_ptr<Type> (clone_type_impl ());\n+    return std::unique_ptr<Type> (clone_type_impl ());\n   }\n \n   // virtual destructor\n   virtual ~Type () {}\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n-  // HACK: convert to trait bound. Virtual method overriden by classes that\n-  // enable this.\n+  /* HACK: convert to trait bound. Virtual method overriden by classes that\n+   * enable this. */\n   virtual TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const\n   {\n-    return NULL;\n+    return nullptr;\n   }\n-  // as pointer, shouldn't require definition beforehand, only forward\n-  // declaration.\n+  /* as pointer, shouldn't require definition beforehand, only forward\n+   * declaration. */\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n@@ -1054,9 +1011,9 @@ class TypeNoBounds : public Type\n {\n public:\n   // Unique pointer custom clone function\n-  ::std::unique_ptr<TypeNoBounds> clone_type_no_bounds () const\n+  std::unique_ptr<TypeNoBounds> clone_type_no_bounds () const\n   {\n-    return ::std::unique_ptr<TypeNoBounds> (clone_type_no_bounds_impl ());\n+    return std::unique_ptr<TypeNoBounds> (clone_type_no_bounds_impl ());\n   }\n \n protected:\n@@ -1066,26 +1023,26 @@ class TypeNoBounds : public Type\n   /* Save having to specify two clone methods in derived classes by making type\n    * clone return typenobounds clone. Hopefully won't affect performance too\n    * much. */\n-  virtual TypeNoBounds *clone_type_impl () const OVERRIDE\n+  TypeNoBounds *clone_type_impl () const override\n   {\n     return clone_type_no_bounds_impl ();\n   }\n };\n \n-// Abstract base class representing a type param bound - Lifetime and TraitBound\n-// extends it\n+/* Abstract base class representing a type param bound - Lifetime and TraitBound\n+ * extends it */\n class TypeParamBound\n {\n public:\n   virtual ~TypeParamBound () {}\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<TypeParamBound> clone_type_param_bound () const\n+  std::unique_ptr<TypeParamBound> clone_type_param_bound () const\n   {\n-    return ::std::unique_ptr<TypeParamBound> (clone_type_param_bound_impl ());\n+    return std::unique_ptr<TypeParamBound> (clone_type_param_bound_impl ());\n   }\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n@@ -1110,54 +1067,54 @@ class Lifetime : public TypeParamBound\n \n   // TODO: LIFETIME_OR_LABEL (aka lifetime token) is only field\n   // find way of enclosing token or something\n-  ::std::string lifetime_name;\n+  std::string lifetime_name;\n   // only applies for NAMED lifetime_type\n \n   Location locus;\n \n public:\n   // Constructor\n-  Lifetime (LifetimeType type, ::std::string name = ::std::string (),\n+  Lifetime (LifetimeType type, std::string name = std::string (),\n \t    Location locus = Location ())\n-    : lifetime_type (type), lifetime_name (::std::move (name)), locus (locus)\n+    : lifetime_type (type), lifetime_name (std::move (name)), locus (locus)\n   {}\n \n   // Creates an \"error\" lifetime.\n-  static Lifetime error () { return Lifetime (NAMED, ::std::string (\"\")); }\n+  static Lifetime error () { return Lifetime (NAMED, std::string (\"\")); }\n \n   // Returns true if the lifetime is in an error state.\n-  inline bool is_error () const\n+  bool is_error () const\n   {\n     return lifetime_type == NAMED && lifetime_name.empty ();\n   }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual Lifetime *clone_type_param_bound_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Lifetime *clone_type_param_bound_impl () const override\n   {\n     return new Lifetime (*this);\n   }\n };\n \n-// Base generic parameter in AST. Abstract - can be represented by a Lifetime or\n-// Type param\n+/* Base generic parameter in AST. Abstract - can be represented by a Lifetime or\n+ * Type param */\n class GenericParam\n {\n public:\n   virtual ~GenericParam () {}\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<GenericParam> clone_generic_param () const\n+  std::unique_ptr<GenericParam> clone_generic_param () const\n   {\n-    return ::std::unique_ptr<GenericParam> (clone_generic_param_impl ());\n+    return std::unique_ptr<GenericParam> (clone_generic_param_impl ());\n   }\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n@@ -1173,20 +1130,20 @@ class LifetimeParam : public GenericParam\n \n   // bool has_lifetime_bounds;\n   // LifetimeBounds lifetime_bounds;\n-  ::std::vector<Lifetime> lifetime_bounds; // inlined LifetimeBounds\n+  std::vector<Lifetime> lifetime_bounds; // inlined LifetimeBounds\n \n   // bool has_outer_attribute;\n-  //::std::unique_ptr<Attribute> outer_attr;\n+  // std::unique_ptr<Attribute> outer_attr;\n   Attribute outer_attr;\n \n   Location locus;\n \n public:\n   // Returns whether the lifetime param has any lifetime bounds.\n-  inline bool has_lifetime_bounds () const { return !lifetime_bounds.empty (); }\n+  bool has_lifetime_bounds () const { return !lifetime_bounds.empty (); }\n \n   // Returns whether the lifetime param has an outer attribute.\n-  inline bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n+  bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n \n   // Creates an error state lifetime param.\n   static LifetimeParam create_error ()\n@@ -1195,16 +1152,16 @@ class LifetimeParam : public GenericParam\n   }\n \n   // Returns whether the lifetime param is in an error state.\n-  inline bool is_error () const { return lifetime.is_error (); }\n+  bool is_error () const { return lifetime.is_error (); }\n \n   // Constructor\n   LifetimeParam (Lifetime lifetime, Location locus = Location (),\n-\t\t ::std::vector<Lifetime> lifetime_bounds\n-\t\t = ::std::vector<Lifetime> (),\n+\t\t std::vector<Lifetime> lifetime_bounds\n+\t\t = std::vector<Lifetime> (),\n \t\t Attribute outer_attr = Attribute::create_empty ())\n-    : lifetime (::std::move (lifetime)),\n-      lifetime_bounds (::std::move (lifetime_bounds)),\n-      outer_attr (::std::move (outer_attr)), locus (locus)\n+    : lifetime (std::move (lifetime)),\n+      lifetime_bounds (std::move (lifetime_bounds)),\n+      outer_attr (std::move (outer_attr)), locus (locus)\n   {}\n \n   // TODO: remove copy and assignment operator definitions - not required\n@@ -1215,8 +1172,6 @@ class LifetimeParam : public GenericParam\n       outer_attr (other.outer_attr), locus (other.locus)\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overloaded assignment operator to clone attribute\n   LifetimeParam &operator= (LifetimeParam const &other)\n   {\n@@ -1232,14 +1187,14 @@ class LifetimeParam : public GenericParam\n   LifetimeParam (LifetimeParam &&other) = default;\n   LifetimeParam &operator= (LifetimeParam &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual LifetimeParam *clone_generic_param_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  LifetimeParam *clone_generic_param_impl () const override\n   {\n     return new LifetimeParam (*this);\n   }\n@@ -1249,10 +1204,10 @@ class LifetimeParam : public GenericParam\n class MacroItem : public Item\n {\n   /*public:\n-  ::std::string as_string() const;*/\n+  std::string as_string() const;*/\n protected:\n-  MacroItem (::std::vector<Attribute> outer_attribs)\n-    : Item (::std::move (outer_attribs))\n+  MacroItem (std::vector<Attribute> outer_attribs)\n+    : Item (std::move (outer_attribs))\n   {}\n };\n \n@@ -1261,14 +1216,14 @@ class TraitItem\n {\n   // bool has_outer_attrs;\n   // TODO: remove and rely on virtual functions and VisItem-derived attributes?\n-  //::std::vector<Attribute> outer_attrs;\n+  // std::vector<Attribute> outer_attrs;\n \n   // NOTE: all children should have outer attributes\n \n protected:\n   // Constructor\n-  /*TraitItem(::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>())\n-    : outer_attrs(::std::move(outer_attrs)) {}*/\n+  /*TraitItem(std::vector<Attribute> outer_attrs = std::vector<Attribute>())\n+    : outer_attrs(std::move(outer_attrs)) {}*/\n \n   // Clone function implementation as pure virtual method\n   virtual TraitItem *clone_trait_item_impl () const = 0;\n@@ -1277,23 +1232,23 @@ class TraitItem\n   virtual ~TraitItem () {}\n \n   // Returns whether TraitItem has outer attributes.\n-  /*inline bool has_outer_attrs() const {\n+  /*bool has_outer_attrs() const {\n       return !outer_attrs.empty();\n   }*/\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<TraitItem> clone_trait_item () const\n+  std::unique_ptr<TraitItem> clone_trait_item () const\n   {\n-    return ::std::unique_ptr<TraitItem> (clone_trait_item_impl ());\n+    return std::unique_ptr<TraitItem> (clone_trait_item_impl ());\n   }\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n };\n \n-// Abstract base class for items used within an inherent impl block (the impl\n-// name {} one)\n+/* Abstract base class for items used within an inherent impl block (the impl\n+ * name {} one) */\n class InherentImplItem\n {\n protected:\n@@ -1304,13 +1259,12 @@ class InherentImplItem\n   virtual ~InherentImplItem () {}\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<InherentImplItem> clone_inherent_impl_item () const\n+  std::unique_ptr<InherentImplItem> clone_inherent_impl_item () const\n   {\n-    return ::std::unique_ptr<InherentImplItem> (\n-      clone_inherent_impl_item_impl ());\n+    return std::unique_ptr<InherentImplItem> (clone_inherent_impl_item_impl ());\n   }\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n };\n@@ -1325,42 +1279,37 @@ class TraitImplItem\n   virtual ~TraitImplItem (){};\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<TraitImplItem> clone_trait_impl_item () const\n+  std::unique_ptr<TraitImplItem> clone_trait_impl_item () const\n   {\n-    return ::std::unique_ptr<TraitImplItem> (clone_trait_impl_item_impl ());\n+    return std::unique_ptr<TraitImplItem> (clone_trait_impl_item_impl ());\n   }\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n };\n \n-// A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n-// invocation)\n+/* A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n+ * invocation) */\n class MacroInvocationSemi : public MacroItem,\n \t\t\t    public TraitItem,\n \t\t\t    public InherentImplItem,\n \t\t\t    public TraitImplItem\n-/*, public Statement*/ {\n-  // already inherits from statement indirectly via item as item is a subclass\n-  // of statement\n+{\n   SimplePath path;\n   // all delim types except curly must have invocation end with a semicolon\n   DelimType delim_type;\n-  //::std::vector<TokenTree> token_trees;\n-  ::std::vector< ::std::unique_ptr<TokenTree> > token_trees;\n-\n+  std::vector<std::unique_ptr<TokenTree>> token_trees;\n   Location locus;\n \n public:\n-  ::std::string as_string () const;\n-\n-  MacroInvocationSemi (\n-    SimplePath macro_path, DelimType delim_type,\n-    ::std::vector< ::std::unique_ptr<TokenTree> > token_trees,\n-    ::std::vector<Attribute> outer_attribs, Location locus)\n-    : MacroItem (::std::move (outer_attribs)), path (::std::move (macro_path)),\n-      delim_type (delim_type), token_trees (::std::move (token_trees)),\n+  std::string as_string () const override;\n+\n+  MacroInvocationSemi (SimplePath macro_path, DelimType delim_type,\n+\t\t       std::vector<std::unique_ptr<TokenTree>> token_trees,\n+\t\t       std::vector<Attribute> outer_attribs, Location locus)\n+    : MacroItem (std::move (outer_attribs)), path (std::move (macro_path)),\n+      delim_type (delim_type), token_trees (std::move (token_trees)),\n       locus (locus)\n   {}\n   /* TODO: possible issue with Item and TraitItem hierarchies both having outer\n@@ -1371,20 +1320,29 @@ class MacroInvocationSemi : public MacroItem,\n    * approach, but then this prevents polymorphism and would entail redoing\n    * quite a bit of the parser. */\n \n+  // Move constructors\n+  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n+  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Clones this macro invocation semi.\n+  std::unique_ptr<MacroInvocationSemi> clone_macro_invocation_semi () const\n+  {\n+    return std::unique_ptr<MacroInvocationSemi> (\n+      clone_macro_invocation_semi_impl ());\n+  }\n+\n+protected:\n   // Copy constructor with vector clone\n   MacroInvocationSemi (MacroInvocationSemi const &other)\n     : MacroItem (other), TraitItem (other), InherentImplItem (other),\n       TraitImplItem (other), path (other.path), delim_type (other.delim_type),\n       locus (other.locus)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     token_trees.reserve (other.token_trees.size ());\n-\n     for (const auto &e : other.token_trees)\n-      {\n-\ttoken_trees.push_back (e->clone_token_tree ());\n-      }\n+      token_trees.push_back (e->clone_token_tree ());\n   }\n \n   // Overloaded assignment operator to vector clone\n@@ -1398,58 +1356,51 @@ class MacroInvocationSemi : public MacroItem,\n     delim_type = other.delim_type;\n     locus = other.locus;\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     token_trees.reserve (other.token_trees.size ());\n-\n     for (const auto &e : other.token_trees)\n-      {\n-\ttoken_trees.push_back (e->clone_token_tree ());\n-      }\n+      token_trees.push_back (e->clone_token_tree ());\n \n     return *this;\n   }\n \n-  // Move constructors\n-  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n-  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n-\n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n-\n-protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroInvocationSemi *clone_item_impl () const OVERRIDE\n+  MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n   {\n     return new MacroInvocationSemi (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroInvocationSemi *clone_inherent_impl_item_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_item_impl () const override\n   {\n-    return new MacroInvocationSemi (*this);\n+    return clone_macro_invocation_semi_impl ();\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroInvocationSemi *clone_trait_impl_item_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_inherent_impl_item_impl () const override\n   {\n-    return new MacroInvocationSemi (*this);\n+    return clone_macro_invocation_semi_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_trait_impl_item_impl () const override\n+  {\n+    return clone_macro_invocation_semi_impl ();\n   }\n \n   // FIXME: remove if item impl virtual override works properly\n   // Use covariance to implement clone function as returning this object rather\n   // than base\n-  /*virtual MacroInvocationSemi* clone_statement_impl() const OVERRIDE {\n-      return new MacroInvocationSemi(*this);\n+  /*MacroInvocationSemi* clone_statement_impl() const override {\n+      return clone_macro_invocation_semi_impl ();\n   }*/\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroInvocationSemi *clone_trait_item_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_trait_item_impl () const override\n   {\n-    return new MacroInvocationSemi (*this);\n+    return clone_macro_invocation_semi_impl ();\n   }\n };\n \n@@ -1459,35 +1410,29 @@ struct Crate\n   bool has_utf8bom;\n   bool has_shebang;\n \n-  ::std::vector<Attribute> inner_attrs;\n-  //::std::vector<Item> items;\n+  std::vector<Attribute> inner_attrs;\n   // dodgy spacing required here\n-  // TODO: is it better to have a vector of items here or a module (implicit\n-  // top-level one)?\n-  ::std::vector< ::std::unique_ptr<Item> > items;\n+  /* TODO: is it better to have a vector of items here or a module (implicit\n+   * top-level one)? */\n+  std::vector<std::unique_ptr<Item>> items;\n \n public:\n   // Constructor\n-  Crate (::std::vector< ::std::unique_ptr<Item> > items,\n-\t ::std::vector<Attribute> inner_attrs, bool has_utf8bom = false,\n+  Crate (std::vector<std::unique_ptr<Item>> items,\n+\t std::vector<Attribute> inner_attrs, bool has_utf8bom = false,\n \t bool has_shebang = false)\n     : has_utf8bom (has_utf8bom), has_shebang (has_shebang),\n-      inner_attrs (::std::move (inner_attrs)), items (::std::move (items))\n+      inner_attrs (std::move (inner_attrs)), items (std::move (items))\n   {}\n \n   // Copy constructor with vector clone\n   Crate (Crate const &other)\n     : has_utf8bom (other.has_utf8bom), has_shebang (other.has_shebang),\n       inner_attrs (other.inner_attrs)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     items.reserve (other.items.size ());\n-\n     for (const auto &e : other.items)\n-      {\n-\titems.push_back (e->clone_item ());\n-      }\n+      items.push_back (e->clone_item ());\n   }\n \n   ~Crate () = default;\n@@ -1499,14 +1444,9 @@ struct Crate\n     has_shebang = other.has_shebang;\n     has_utf8bom = other.has_utf8bom;\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     items.reserve (other.items.size ());\n-\n     for (const auto &e : other.items)\n-      {\n-\titems.push_back (e->clone_item ());\n-      }\n+      items.push_back (e->clone_item ());\n \n     return *this;\n   }\n@@ -1516,25 +1456,25 @@ struct Crate\n   Crate &operator= (Crate &&other) = default;\n \n   // Get crate representation as string (e.g. for debugging).\n-  ::std::string as_string () const;\n+  std::string as_string () const;\n };\n \n // Base path expression AST node - abstract\n class PathExpr : public ExprWithoutBlock\n {\n protected:\n-  PathExpr (::std::vector<Attribute> outer_attribs)\n-    : ExprWithoutBlock (::std::move (outer_attribs))\n+  PathExpr (std::vector<Attribute> outer_attribs)\n+    : ExprWithoutBlock (std::move (outer_attribs))\n   {}\n \n public:\n   // TODO: think of a better and less hacky way to allow this\n \n-  // Replaces the outer attributes of this path expression with the given outer\n-  // attributes.\n-  void replace_outer_attrs (::std::vector<Attribute> outer_attrs)\n+  /* Replaces the outer attributes of this path expression with the given outer\n+   * attributes. */\n+  void replace_outer_attrs (std::vector<Attribute> outer_attrs)\n   {\n-    set_outer_attrs (::std::move (outer_attrs));\n+    set_outer_attrs (std::move (outer_attrs));\n   }\n };\n } // namespace AST"}, {"sha": "cef8ebb715e0bea173cd2b050fda4f584f25974c", "filename": "gcc/rust/ast/rust-cond-compilation.h", "status": "modified", "additions": 39, "deletions": 47, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-cond-compilation.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -13,10 +13,9 @@ class ConfigurationPredicate\n   virtual ~ConfigurationPredicate () {}\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<ConfigurationPredicate>\n-  clone_configuration_predicate () const\n+  std::unique_ptr<ConfigurationPredicate> clone_configuration_predicate () const\n   {\n-    return ::std::unique_ptr<ConfigurationPredicate> (\n+    return std::unique_ptr<ConfigurationPredicate> (\n       clone_configuration_predicate_impl ());\n   }\n \n@@ -35,28 +34,27 @@ class ConfigurationOption : public ConfigurationPredicate\n   Identifier option_name;\n \n   // bool has_string_literal_option_body;\n-  ::std::string option_value; // technically a string or raw string literal\n+  std::string option_value; // technically a string or raw string literal\n \n public:\n-  // Returns whether the configuration option has a \"value\" part of the\n-  // key-value pair.\n-  inline bool has_option_value () const { return !option_value.empty (); }\n+  /* Returns whether the configuration option has a \"value\" part of the\n+   * key-value pair. */\n+  bool has_option_value () const { return !option_value.empty (); }\n \n   // Key-value pair constructor\n-  ConfigurationOption (Identifier option_name, ::std::string option_value)\n+  ConfigurationOption (Identifier option_name, std::string option_value)\n     : option_name (option_name), option_value (option_value)\n   {}\n \n   // Name-only constructor\n   ConfigurationOption (Identifier option_name) : option_name (option_name) {}\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ConfigurationOption *\n-  clone_configuration_predicate_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationOption *clone_configuration_predicate_impl () const override\n   {\n     return new ConfigurationOption (*this);\n   }\n@@ -65,27 +63,27 @@ class ConfigurationOption : public ConfigurationPredicate\n // TODO: inline\n struct ConfigurationPredicateList\n {\n-  ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list;\n+  std::vector<std::unique_ptr<ConfigurationPredicate>> predicate_list;\n };\n \n // Predicate that returns true if all of the supplied predicates return true.\n class ConfigurationAll : public ConfigurationPredicate\n {\n-  ::std::vector< ::std::unique_ptr<ConfigurationPredicate> >\n+  std::vector<std::unique_ptr<ConfigurationPredicate>>\n     predicate_list; // inlined form\n \n public:\n   ConfigurationAll (\n-    ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list)\n+    std::vector<std::unique_ptr<ConfigurationPredicate>> predicate_list)\n     : predicate_list (predicate_list)\n   {}\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ConfigurationAll *clone_configuration_predicate_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationAll *clone_configuration_predicate_impl () const override\n   {\n     return new ConfigurationAll (*this);\n   }\n@@ -94,31 +92,31 @@ class ConfigurationAll : public ConfigurationPredicate\n // Predicate that returns true if any of the supplied predicates are true.\n class ConfigurationAny : public ConfigurationPredicate\n {\n-  ::std::vector< ::std::unique_ptr<ConfigurationPredicate> >\n+  std::vector<std::unique_ptr<ConfigurationPredicate>>\n     predicate_list; // inlined form\n \n public:\n   ConfigurationAny (\n-    ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list)\n+    std::vector<std::unique_ptr<ConfigurationPredicate>> predicate_list)\n     : predicate_list (predicate_list)\n   {}\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ConfigurationAny *clone_configuration_predicate_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationAny *clone_configuration_predicate_impl () const override\n   {\n     return new ConfigurationAny (*this);\n   }\n };\n \n-// Predicate that produces the negation of a supplied other configuration\n-// predicate.\n+/* Predicate that produces the negation of a supplied other configuration\n+ * predicate. */\n class ConfigurationNot : public ConfigurationPredicate\n {\n-  ::std::unique_ptr<ConfigurationPredicate> config_to_negate;\n+  std::unique_ptr<ConfigurationPredicate> config_to_negate;\n \n public:\n   ConfigurationNot (ConfigurationPredicate *config_to_negate)\n@@ -128,11 +126,9 @@ class ConfigurationNot : public ConfigurationPredicate\n   // Copy constructor with clone\n   ConfigurationNot (ConfigurationNot const &other)\n     : config_to_negate (\n-\tother.config_to_negate->clone_configuration_predicate ())\n+      other.config_to_negate->clone_configuration_predicate ())\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overloaded assignment operator to clone\n   ConfigurationNot &operator= (ConfigurationNot const &other)\n   {\n@@ -145,12 +141,12 @@ class ConfigurationNot : public ConfigurationPredicate\n   ConfigurationNot (ConfigurationNot &&other) = default;\n   ConfigurationNot &operator= (ConfigurationNot &&other) = default;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ConfigurationNot *clone_configuration_predicate_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationNot *clone_configuration_predicate_impl () const override\n   {\n     return new ConfigurationNot (*this);\n   }\n@@ -159,7 +155,7 @@ class ConfigurationNot : public ConfigurationPredicate\n // TODO: relationship to other attributes?\n class CfgAttribute\n {\n-  ::std::unique_ptr<ConfigurationPredicate> config_to_include;\n+  std::unique_ptr<ConfigurationPredicate> config_to_include;\n \n public:\n   CfgAttribute (ConfigurationPredicate *config_to_include)\n@@ -169,11 +165,9 @@ class CfgAttribute\n   // Copy constructor with clone\n   CfgAttribute (CfgAttribute const &other)\n     : config_to_include (\n-\tother.config_to_include->clone_configuration_predicate ())\n+      other.config_to_include->clone_configuration_predicate ())\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overloaded assignment operator to clone\n   CfgAttribute &operator= (CfgAttribute const &other)\n   {\n@@ -195,30 +189,28 @@ class CfgAttribute\n // TODO: inline\n struct CfgAttrs\n {\n-  ::std::vector<Attribute> cfg_attrs;\n+  std::vector<Attribute> cfg_attrs;\n };\n \n // TODO: relationship to other attributes?\n class CfgAttrAttribute\n {\n-  ::std::unique_ptr<ConfigurationPredicate> config_to_include;\n-  ::std::vector<Attribute> cfg_attrs;\n+  std::unique_ptr<ConfigurationPredicate> config_to_include;\n+  std::vector<Attribute> cfg_attrs;\n \n public:\n   CfgAttrAttribute (ConfigurationPredicate *config_to_include,\n-\t\t    ::std::vector<Attribute> cfg_attrs)\n+\t\t    std::vector<Attribute> cfg_attrs)\n     : config_to_include (config_to_include), cfg_attrs (cfg_attrs)\n   {}\n \n   // Copy constructor with clone\n   CfgAttrAttribute (CfgAttrAttribute const &other)\n     : config_to_include (\n-\tother.config_to_include->clone_configuration_predicate ()),\n+      other.config_to_include->clone_configuration_predicate ()),\n       cfg_attrs (cfg_attrs)\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overloaded assignment operator to clone\n   CfgAttrAttribute &operator= (CfgAttrAttribute const &other)\n   {"}, {"sha": "727cf3c62fc3fb1e0465bcec1a750bda80867e03", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 1147, "deletions": 2047, "changes": 3194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7"}, {"sha": "b5d9247023aadefea94770e7a858f540fa2bd971", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 816, "deletions": 1230, "changes": 2046, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7"}, {"sha": "6e34c3ecf9eeba08c6233327b9286c5cd21b2214", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 127, "deletions": 167, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -28,7 +28,7 @@ enum MacroFragSpec\n };\n \n inline MacroFragSpec\n-get_frag_spec_from_str (::std::string str)\n+get_frag_spec_from_str (std::string str)\n {\n   if (str == \"block\")\n     return BLOCK;\n@@ -74,26 +74,26 @@ class MacroMatchFragment : public MacroMatch\n \n public:\n   MacroMatchFragment (Identifier ident, MacroFragSpec frag_spec)\n-    : ident (::std::move (ident)), frag_spec (frag_spec)\n+    : ident (std::move (ident)), frag_spec (frag_spec)\n   {}\n \n   // Returns whether macro match fragment is in an error state.\n-  inline bool is_error () const { return frag_spec == INVALID; }\n+  bool is_error () const { return frag_spec == INVALID; }\n \n   // Creates an error state macro match fragment.\n   static MacroMatchFragment create_error ()\n   {\n-    return MacroMatchFragment (::std::string (\"\"), INVALID);\n+    return MacroMatchFragment (std::string (\"\"), INVALID);\n   }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroMatchFragment *clone_macro_match_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatchFragment *clone_macro_match_impl () const override\n   {\n     return new MacroMatchFragment (*this);\n   }\n@@ -112,57 +112,43 @@ class MacroMatchRepetition : public MacroMatch\n   };\n \n private:\n-  //::std::vector<MacroMatch> matches;\n-  ::std::vector< ::std::unique_ptr<MacroMatch> > matches;\n+  std::vector<std::unique_ptr<MacroMatch>> matches;\n   MacroRepOp op;\n \n   // bool has_sep;\n   typedef Token MacroRepSep;\n   // any token except delimiters and repetition operators\n-  ::std::unique_ptr<MacroRepSep> sep;\n+  std::unique_ptr<MacroRepSep> sep;\n \n   // TODO: should store location information?\n \n public:\n   // Returns whether macro match repetition has separator token.\n-  inline bool has_sep () const { return sep != NULL; }\n+  bool has_sep () const { return sep != NULL; }\n \n-  MacroMatchRepetition (::std::vector< ::std::unique_ptr<MacroMatch> > matches,\n-\t\t\tMacroRepOp op, ::std::unique_ptr<MacroRepSep> sep)\n-    : matches (::std::move (matches)), op (op), sep (::std::move (sep))\n+  MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch>> matches,\n+\t\t\tMacroRepOp op, std::unique_ptr<MacroRepSep> sep)\n+    : matches (std::move (matches)), op (op), sep (std::move (sep))\n   {}\n \n   // Copy constructor with clone\n   MacroMatchRepetition (MacroMatchRepetition const &other)\n-    : /*matches(other.matches),*/ op (other.op), sep (other.sep->clone_token ())\n+    : op (other.op), sep (other.sep->clone_token ())\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     matches.reserve (other.matches.size ());\n-\n     for (const auto &e : other.matches)\n-      {\n-\tmatches.push_back (e->clone_macro_match ());\n-      }\n+      matches.push_back (e->clone_macro_match ());\n   }\n \n-  // Destructor - define here if required\n-\n   // Overloaded assignment operator to clone\n   MacroMatchRepetition &operator= (MacroMatchRepetition const &other)\n   {\n-    // matches = other.matches; // TODO: this needs to clone somehow?\n     op = other.op;\n     sep = other.sep->clone_token ();\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     matches.reserve (other.matches.size ());\n-\n     for (const auto &e : other.matches)\n-      {\n-\tmatches.push_back (e->clone_macro_match ());\n-      }\n+      matches.push_back (e->clone_macro_match ());\n \n     return *this;\n   }\n@@ -171,14 +157,14 @@ class MacroMatchRepetition : public MacroMatch\n   MacroMatchRepetition (MacroMatchRepetition &&other) = default;\n   MacroMatchRepetition &operator= (MacroMatchRepetition &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroMatchRepetition *clone_macro_match_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatchRepetition *clone_macro_match_impl () const override\n   {\n     return new MacroMatchRepetition (*this);\n   }\n@@ -188,8 +174,7 @@ class MacroMatchRepetition : public MacroMatch\n class MacroMatcher : public MacroMatch\n {\n   DelimType delim_type;\n-  //::std::vector<MacroMatch> matches;\n-  ::std::vector< ::std::unique_ptr<MacroMatch> > matches;\n+  std::vector<std::unique_ptr<MacroMatch>> matches;\n \n   // TODO: think of way to mark invalid that doesn't take up more space\n   bool is_invalid;\n@@ -198,37 +183,26 @@ class MacroMatcher : public MacroMatch\n \n public:\n   MacroMatcher (DelimType delim_type,\n-\t\t::std::vector< ::std::unique_ptr<MacroMatch> > matches)\n-    : delim_type (delim_type), matches (::std::move (matches)),\n-      is_invalid (false)\n+\t\tstd::vector<std::unique_ptr<MacroMatch>> matches)\n+    : delim_type (delim_type), matches (std::move (matches)), is_invalid (false)\n   {}\n \n   // copy constructor with vector clone\n   MacroMatcher (MacroMatcher const &other) : delim_type (other.delim_type)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     matches.reserve (other.matches.size ());\n-\n     for (const auto &e : other.matches)\n-      {\n-\tmatches.push_back (e->clone_macro_match ());\n-      }\n+      matches.push_back (e->clone_macro_match ());\n   }\n \n   // overloaded assignment operator with vector clone\n   MacroMatcher &operator= (MacroMatcher const &other)\n   {\n     delim_type = other.delim_type;\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     matches.reserve (other.matches.size ());\n-\n     for (const auto &e : other.matches)\n-      {\n-\tmatches.push_back (e->clone_macro_match ());\n-      }\n+      matches.push_back (e->clone_macro_match ());\n \n     return *this;\n   }\n@@ -241,16 +215,16 @@ class MacroMatcher : public MacroMatch\n   static MacroMatcher create_error () { return MacroMatcher (true); }\n \n   // Returns whether MacroMatcher is in an error state.\n-  inline bool is_error () const { return is_invalid; }\n+  bool is_error () const { return is_invalid; }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroMatcher *clone_macro_match_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatcher *clone_macro_match_impl () const override\n   {\n     return new MacroMatcher (*this);\n   }\n@@ -270,10 +244,10 @@ struct MacroTranscriber\n \n public:\n   MacroTranscriber (DelimTokenTree token_tree)\n-    : token_tree (::std::move (token_tree))\n+    : token_tree (std::move (token_tree))\n   {}\n \n-  ::std::string as_string () const { return token_tree.as_string (); }\n+  std::string as_string () const { return token_tree.as_string (); }\n };\n \n // A macro rule? Matcher and transcriber pair?\n@@ -287,11 +261,11 @@ struct MacroRule\n \n public:\n   MacroRule (MacroMatcher matcher, MacroTranscriber transcriber)\n-    : matcher (::std::move (matcher)), transcriber (::std::move (transcriber))\n+    : matcher (std::move (matcher)), transcriber (std::move (transcriber))\n   {}\n \n   // Returns whether macro rule is in error state.\n-  inline bool is_error () const { return matcher.is_error (); }\n+  bool is_error () const { return matcher.is_error (); }\n \n   // Creates an error state macro rule.\n   static MacroRule create_error ()\n@@ -300,7 +274,7 @@ struct MacroRule\n \t\t      MacroTranscriber (DelimTokenTree::create_empty ()));\n   }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const;\n };\n \n // A macro rules definition item AST node\n@@ -311,90 +285,87 @@ class MacroRulesDefinition : public MacroItem\n   // only curly without required semicolon at end\n   DelimType delim_type;\n   // MacroRules rules;\n-  ::std::vector<MacroRule> rules; // inlined form\n+  std::vector<MacroRule> rules; // inlined form\n \n   Location locus;\n \n public:\n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   MacroRulesDefinition (Identifier rule_name, DelimType delim_type,\n-\t\t\t::std::vector<MacroRule> rules,\n-\t\t\t::std::vector<Attribute> outer_attrs, Location locus)\n-    : MacroItem (::std::move (outer_attrs)),\n-      rule_name (::std::move (rule_name)), delim_type (delim_type),\n-      rules (::std::move (rules)), locus (locus)\n+\t\t\tstd::vector<MacroRule> rules,\n+\t\t\tstd::vector<Attribute> outer_attrs, Location locus)\n+    : MacroItem (std::move (outer_attrs)), rule_name (std::move (rule_name)),\n+      delim_type (delim_type), rules (std::move (rules)), locus (locus)\n   {}\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroRulesDefinition *clone_item_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroRulesDefinition *clone_item_impl () const override\n   {\n     return new MacroRulesDefinition (*this);\n   }\n };\n \n-// AST node of a macro invocation, which is replaced by the macro result at\n-// compile time\n+/* AST node of a macro invocation, which is replaced by the macro result at\n+ * compile time */\n class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic Pattern,\n \t\t\tpublic ExprWithoutBlock\n {\n   SimplePath path;\n   DelimTokenTree token_tree;\n-\n   Location locus;\n \n public:\n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   MacroInvocation (SimplePath path, DelimTokenTree token_tree,\n-\t\t   ::std::vector<Attribute> outer_attrs, Location locus)\n-    : ExprWithoutBlock (::std::move (outer_attrs)), path (::std::move (path)),\n-      token_tree (::std::move (token_tree)), locus (locus)\n+\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : ExprWithoutBlock (std::move (outer_attrs)), path (std::move (path)),\n+      token_tree (std::move (token_tree)), locus (locus)\n   {}\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n \n-  Location get_locus_slow () const OVERRIDE { return get_locus (); }\n-\n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroInvocation *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_pattern_impl () const override\n   {\n     return new MacroInvocation (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroInvocation *clone_expr_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_expr_impl () const override\n   {\n     return new MacroInvocation (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroInvocation *clone_expr_without_block_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_expr_without_block_impl () const override\n   {\n     return new MacroInvocation (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroInvocation *clone_type_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_type_impl () const override\n   {\n     return new MacroInvocation (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual MacroInvocation *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_type_no_bounds_impl () const override\n   {\n     return new MacroInvocation (*this);\n   }\n@@ -406,24 +377,24 @@ class MetaItemPath : public MetaItem\n   SimplePath path;\n \n public:\n-  MetaItemPath (SimplePath path) : path (::std::move (path)) {}\n+  MetaItemPath (SimplePath path) : path (std::move (path)) {}\n \n-  ::std::string as_string () const OVERRIDE { return path.as_string (); }\n+  std::string as_string () const override { return path.as_string (); }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n   // HACK: used to simplify parsing - returns non-empty only in this case\n-  virtual SimplePath to_path_item () const OVERRIDE\n+  SimplePath to_path_item () const override\n   {\n     // this should copy construct - TODO ensure it does\n     return path;\n   }\n \n-  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+  bool check_cfg_predicate (const Session &session) const override;\n \n protected:\n   // Use covariance to implement clone function as returning this type\n-  virtual MetaItemPath *clone_meta_item_inner_impl () const OVERRIDE\n+  MetaItemPath *clone_meta_item_inner_impl () const override\n   {\n     return new MetaItemPath (*this);\n   }\n@@ -433,42 +404,31 @@ class MetaItemPath : public MetaItem\n class MetaItemSeq : public MetaItem\n {\n   SimplePath path;\n-  ::std::vector< ::std::unique_ptr<MetaItemInner> > seq;\n+  std::vector<std::unique_ptr<MetaItemInner>> seq;\n \n public:\n   MetaItemSeq (SimplePath path,\n-\t       ::std::vector< ::std::unique_ptr<MetaItemInner> > seq)\n-    : path (::std::move (path)), seq (::std::move (seq))\n+\t       std::vector<std::unique_ptr<MetaItemInner>> seq)\n+    : path (std::move (path)), seq (std::move (seq))\n   {}\n \n   // copy constructor with vector clone\n   MetaItemSeq (const MetaItemSeq &other) : path (other.path)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     seq.reserve (other.seq.size ());\n-\n     for (const auto &e : other.seq)\n-      {\n-\tseq.push_back (e->clone_meta_item_inner ());\n-      }\n+      seq.push_back (e->clone_meta_item_inner ());\n   }\n \n-  // destructor definition not required\n-\n   // overloaded assignment operator with vector clone\n   MetaItemSeq &operator= (const MetaItemSeq &other)\n   {\n     MetaItem::operator= (other);\n     path = other.path;\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n-    seq.reserve (other.seq.size ());\n \n+    seq.reserve (other.seq.size ());\n     for (const auto &e : other.seq)\n-      {\n-\tseq.push_back (e->clone_meta_item_inner ());\n-      }\n+      seq.push_back (e->clone_meta_item_inner ());\n \n     return *this;\n   }\n@@ -477,15 +437,15 @@ class MetaItemSeq : public MetaItem\n   MetaItemSeq (MetaItemSeq &&other) = default;\n   MetaItemSeq &operator= (MetaItemSeq &&other) = default;\n \n-  ::std::string as_string () const OVERRIDE;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n-  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+  bool check_cfg_predicate (const Session &session) const override;\n \n protected:\n   // Use covariance to implement clone function as returning this type\n-  virtual MetaItemSeq *clone_meta_item_inner_impl () const OVERRIDE\n+  MetaItemSeq *clone_meta_item_inner_impl () const override\n   {\n     return new MetaItemSeq (*this);\n   }\n@@ -497,17 +457,17 @@ class MetaWord : public MetaItem\n   Identifier ident;\n \n public:\n-  MetaWord (Identifier ident) : ident (::std::move (ident)) {}\n+  MetaWord (Identifier ident) : ident (std::move (ident)) {}\n \n-  ::std::string as_string () const OVERRIDE { return ident; }\n+  std::string as_string () const override { return ident; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n-  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+  bool check_cfg_predicate (const Session &session) const override;\n \n protected:\n   // Use covariance to implement clone function as returning this type\n-  virtual MetaWord *clone_meta_item_inner_impl () const OVERRIDE\n+  MetaWord *clone_meta_item_inner_impl () const override\n   {\n     return new MetaWord (*this);\n   }\n@@ -517,28 +477,28 @@ class MetaWord : public MetaItem\n class MetaNameValueStr : public MetaItem\n {\n   Identifier ident;\n-  ::std::string str;\n+  std::string str;\n \n public:\n-  MetaNameValueStr (Identifier ident, ::std::string str)\n-    : ident (::std::move (ident)), str (::std::move (str))\n+  MetaNameValueStr (Identifier ident, std::string str)\n+    : ident (std::move (ident)), str (std::move (str))\n   {}\n \n-  ::std::string as_string () const OVERRIDE { return ident + \" = \" + str; }\n+  std::string as_string () const override { return ident + \" = \" + str; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n   // HACK: used to simplify parsing - creates a copy of this\n-  virtual MetaNameValueStr *to_meta_name_value_str () const OVERRIDE\n+  MetaNameValueStr *to_meta_name_value_str () const override\n   {\n     return clone_meta_item_inner_impl ();\n   }\n \n-  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+  bool check_cfg_predicate (const Session &session) const override;\n \n protected:\n   // Use covariance to implement clone function as returning this type\n-  virtual MetaNameValueStr *clone_meta_item_inner_impl () const OVERRIDE\n+  MetaNameValueStr *clone_meta_item_inner_impl () const override\n   {\n     return new MetaNameValueStr (*this);\n   }\n@@ -549,26 +509,26 @@ class MetaNameValueStr : public MetaItem\n class MetaListPaths : public MetaItem\n {\n   Identifier ident;\n-  ::std::vector<SimplePath> paths;\n+  std::vector<SimplePath> paths;\n \n public:\n-  MetaListPaths (Identifier ident, ::std::vector<SimplePath> paths)\n-    : ident (::std::move (ident)), paths (::std::move (paths))\n+  MetaListPaths (Identifier ident, std::vector<SimplePath> paths)\n+    : ident (std::move (ident)), paths (std::move (paths))\n   {}\n \n-  ::std::string as_string () const OVERRIDE;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n-  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+  bool check_cfg_predicate (const Session &session) const override;\n \n private:\n   bool check_path_exists_in_cfg (const Session &session,\n \t\t\t\t const SimplePath &path) const;\n \n protected:\n   // Use covariance to implement clone function as returning this type\n-  virtual MetaListPaths *clone_meta_item_inner_impl () const OVERRIDE\n+  MetaListPaths *clone_meta_item_inner_impl () const override\n   {\n     return new MetaListPaths (*this);\n   }\n@@ -578,22 +538,22 @@ class MetaListPaths : public MetaItem\n class MetaListNameValueStr : public MetaItem\n {\n   Identifier ident;\n-  ::std::vector<MetaNameValueStr> strs;\n+  std::vector<MetaNameValueStr> strs;\n \n public:\n-  MetaListNameValueStr (Identifier ident, ::std::vector<MetaNameValueStr> strs)\n-    : ident (::std::move (ident)), strs (::std::move (strs))\n+  MetaListNameValueStr (Identifier ident, std::vector<MetaNameValueStr> strs)\n+    : ident (std::move (ident)), strs (std::move (strs))\n   {}\n \n-  ::std::string as_string () const OVERRIDE;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n-  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+  bool check_cfg_predicate (const Session &session) const override;\n \n protected:\n   // Use covariance to implement clone function as returning this type\n-  virtual MetaListNameValueStr *clone_meta_item_inner_impl () const OVERRIDE\n+  MetaListNameValueStr *clone_meta_item_inner_impl () const override\n   {\n     return new MetaListNameValueStr (*this);\n   }\n@@ -603,41 +563,41 @@ class MetaListNameValueStr : public MetaItem\n struct MacroParser\n {\n private:\n-  ::std::vector< ::std::unique_ptr<Token> > token_stream;\n-  // probably have to make this mutable (mutable int stream_pos) otherwise const\n-  // has to be removed up to DelimTokenTree or further ok since this changing\n-  // would have an effect on the results of the methods run (i.e. not logically\n-  // const), the parsing methods shouldn't be const\n+  std::vector<std::unique_ptr<Token>> token_stream;\n+  /* probably have to make this mutable (mutable int stream_pos) otherwise const\n+   * has to be removed up to DelimTokenTree or further ok since this changing\n+   * would have an effect on the results of the methods run (i.e. not logically\n+   * const), the parsing methods shouldn't be const */\n   int stream_pos;\n \n public:\n-  MacroParser (::std::vector< ::std::unique_ptr<Token> > token_stream,\n+  MacroParser (std::vector<std::unique_ptr<Token>> token_stream,\n \t       int stream_start_pos = 0)\n-    : token_stream (::std::move (token_stream)), stream_pos (stream_start_pos)\n+    : token_stream (std::move (token_stream)), stream_pos (stream_start_pos)\n   {}\n \n   ~MacroParser () = default;\n \n-  ::std::vector< ::std::unique_ptr<MetaItemInner> > parse_meta_item_seq ();\n+  std::vector<std::unique_ptr<MetaItemInner>> parse_meta_item_seq ();\n \n private:\n   // Parses a MetaItemInner.\n-  ::std::unique_ptr<MetaItemInner> parse_meta_item_inner ();\n+  std::unique_ptr<MetaItemInner> parse_meta_item_inner ();\n   // Returns whether token can end a meta item.\n   bool is_end_meta_item_tok (TokenId id) const;\n   // Parses a simple path.\n   SimplePath parse_simple_path ();\n   // Parses a segment of a simple path (but not scope resolution operator).\n   SimplePathSegment parse_simple_path_segment ();\n   // Parses a MetaItemLitExpr.\n-  ::std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit ();\n+  std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit ();\n   // Parses a literal.\n   Literal parse_literal ();\n   // Parses a meta item that begins with a simple path.\n-  ::std::unique_ptr<MetaItem> parse_path_meta_item ();\n+  std::unique_ptr<MetaItem> parse_path_meta_item ();\n \n   // TODO: should this be const?\n-  ::std::unique_ptr<Token> &peek_token (int i = 0)\n+  std::unique_ptr<Token> &peek_token (int i = 0)\n   {\n     return token_stream[stream_pos + i];\n   }"}, {"sha": "3006780024158004d5448c6548e88ba91d745916", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 200, "deletions": 273, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -10,69 +10,62 @@\n \n namespace Rust {\n namespace AST {\n-// make intellisense calm\n-/*typedef ::std::string Symbol;\n-typedef int Lifetime;\n-typedef int Type;\n-typedef int Binding;*/\n \n // The \"identifier\" (not generic args) aspect of each path expression segment\n class PathIdentSegment\n {\n-  ::std::string segment_name;\n+  std::string segment_name;\n \n   // TODO: should this have location info stored?\n \n   // only allow identifiers, \"super\", \"self\", \"Self\", \"crate\", or \"$crate\"\n public:\n-  PathIdentSegment (::std::string segment_name)\n-    : segment_name (::std::move (segment_name))\n+  PathIdentSegment (std::string segment_name)\n+    : segment_name (std::move (segment_name))\n   {}\n \n   /* TODO: insert check in constructor for this? Or is this a semantic error\n    * best handled then? */\n \n-  // TODO: does this require visitor. pretty sure this isn't polymorphic, but\n-  // not entirely sure\n+  /* TODO: does this require visitor? pretty sure this isn't polymorphic, but\n+   * not entirely sure */\n \n   // Creates an error PathIdentSegment.\n   static PathIdentSegment create_error () { return PathIdentSegment (\"\"); }\n \n   // Returns whether PathIdentSegment is in an error state.\n-  inline bool is_error () const { return segment_name.empty (); }\n+  bool is_error () const { return segment_name.empty (); }\n \n-  ::std::string as_string () const { return segment_name; }\n+  std::string as_string () const { return segment_name; }\n };\n \n // A binding of an identifier to a type used in generic arguments in paths\n struct GenericArgsBinding\n {\n private:\n   Identifier identifier;\n-  // Type type;\n-  ::std::unique_ptr<Type> type;\n+  std::unique_ptr<Type> type;\n \n   Location locus;\n \n public:\n   // Returns whether binding is in an error state.\n-  inline bool is_error () const\n+  bool is_error () const\n   {\n-    return type\n-\t   == NULL; // and also identifier is empty, but cheaper computation\n+    return type == nullptr;\n+    // and also identifier is empty, but cheaper computation\n   }\n \n   // Creates an error state generic args binding.\n   static GenericArgsBinding create_error ()\n   {\n-    return GenericArgsBinding (\"\", NULL);\n+    return GenericArgsBinding (\"\", nullptr);\n   }\n \n   // Pointer type for type in constructor to enable polymorphism\n-  GenericArgsBinding (Identifier ident, ::std::unique_ptr<Type> type_ptr,\n+  GenericArgsBinding (Identifier ident, std::unique_ptr<Type> type_ptr,\n \t\t      Location locus = Location ())\n-    : identifier (::std::move (ident)), type (::std::move (type_ptr)),\n-      locus (locus)\n+    : identifier (std::move (ident)), type (std::move (type_ptr)), locus (locus)\n   {}\n \n   // Copy constructor has to deep copy the type as it is a unique pointer\n@@ -97,49 +90,42 @@ struct GenericArgsBinding\n   GenericArgsBinding (GenericArgsBinding &&other) = default;\n   GenericArgsBinding &operator= (GenericArgsBinding &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const;\n };\n \n // Generic arguments allowed in each path expression segment - inline?\n struct GenericArgs\n {\n-  ::std::vector<Lifetime> lifetime_args;\n-  //::std::vector<Type> type_args;\n-  ::std::vector< ::std::unique_ptr<Type> > type_args;\n-  ::std::vector<GenericArgsBinding> binding_args;\n-\n+  std::vector<Lifetime> lifetime_args;\n+  std::vector<std::unique_ptr<Type>> type_args;\n+  std::vector<GenericArgsBinding> binding_args;\n   Location locus;\n \n public:\n   // Returns true if there are any generic arguments\n-  inline bool has_generic_args () const\n+  bool has_generic_args () const\n   {\n     return !(lifetime_args.empty () && type_args.empty ()\n \t     && binding_args.empty ());\n   }\n \n-  GenericArgs (::std::vector<Lifetime> lifetime_args,\n-\t       ::std::vector< ::std::unique_ptr<Type> > type_args,\n-\t       ::std::vector<GenericArgsBinding> binding_args,\n+  GenericArgs (std::vector<Lifetime> lifetime_args,\n+\t       std::vector<std::unique_ptr<Type>> type_args,\n+\t       std::vector<GenericArgsBinding> binding_args,\n \t       Location locus = Location ())\n-    : lifetime_args (::std::move (lifetime_args)),\n-      type_args (::std::move (type_args)),\n-      binding_args (::std::move (binding_args)), locus (locus)\n+    : lifetime_args (std::move (lifetime_args)),\n+      type_args (std::move (type_args)),\n+      binding_args (std::move (binding_args)), locus (locus)\n   {}\n \n   // copy constructor with vector clone\n   GenericArgs (GenericArgs const &other)\n     : lifetime_args (other.lifetime_args), binding_args (other.binding_args),\n       locus (other.locus)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     type_args.reserve (other.type_args.size ());\n-\n     for (const auto &e : other.type_args)\n-      {\n-\ttype_args.push_back (e->clone_type ());\n-      }\n+      type_args.push_back (e->clone_type ());\n   }\n \n   ~GenericArgs () = default;\n@@ -151,14 +137,9 @@ struct GenericArgs\n     binding_args = other.binding_args;\n     locus = other.locus;\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     type_args.reserve (other.type_args.size ());\n-\n     for (const auto &e : other.type_args)\n-      {\n-\ttype_args.push_back (e->clone_type ());\n-      }\n+      type_args.push_back (e->clone_type ());\n \n     return *this;\n   }\n@@ -170,16 +151,16 @@ struct GenericArgs\n   // Creates an empty GenericArgs (no arguments)\n   static GenericArgs create_empty ()\n   {\n-    return GenericArgs (::std::vector<Lifetime> (),\n-\t\t\t::std::vector< ::std::unique_ptr<Type> > (),\n-\t\t\t::std::vector<GenericArgsBinding> ());\n+    return GenericArgs (std::vector<Lifetime> (),\n+\t\t\tstd::vector<std::unique_ptr<Type>> (),\n+\t\t\tstd::vector<GenericArgsBinding> ());\n   }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const;\n };\n \n-// A segment of a path in expression, including an identifier aspect and maybe\n-// generic args\n+/* A segment of a path in expression, including an identifier aspect and maybe\n+ * generic args */\n class PathExprSegment\n { // or should this extend PathIdentSegment?\n private:\n@@ -194,60 +175,57 @@ class PathExprSegment\n \n public:\n   // Returns true if there are any generic arguments\n-  inline bool has_generic_args () const\n-  {\n-    return generic_args.has_generic_args ();\n-  }\n+  bool has_generic_args () const { return generic_args.has_generic_args (); }\n \n   // Constructor for segment (from IdentSegment and GenericArgs)\n   PathExprSegment (PathIdentSegment segment_name, Location locus = Location (),\n \t\t   GenericArgs generic_args = GenericArgs::create_empty ())\n-    : segment_name (::std::move (segment_name)),\n-      generic_args (::std::move (generic_args)), locus (locus)\n+    : segment_name (std::move (segment_name)),\n+      generic_args (std::move (generic_args)), locus (locus)\n   {}\n \n-  // Constructor for segment with generic arguments (from segment name and all\n-  // args)\n-  PathExprSegment (::std::string segment_name, Location locus,\n-\t\t   ::std::vector<Lifetime> lifetime_args\n-\t\t   = ::std::vector<Lifetime> (),\n-\t\t   ::std::vector< ::std::unique_ptr<Type> > type_args\n-\t\t   = ::std::vector< ::std::unique_ptr<Type> > (),\n-\t\t   ::std::vector<GenericArgsBinding> binding_args\n-\t\t   = ::std::vector<GenericArgsBinding> ())\n-    : segment_name (PathIdentSegment (::std::move (segment_name))),\n-      generic_args (GenericArgs (::std::move (lifetime_args),\n-\t\t\t\t ::std::move (type_args),\n-\t\t\t\t ::std::move (binding_args))),\n+  /* Constructor for segment with generic arguments (from segment name and all\n+   * args) */\n+  PathExprSegment (std::string segment_name, Location locus,\n+\t\t   std::vector<Lifetime> lifetime_args\n+\t\t   = std::vector<Lifetime> (),\n+\t\t   std::vector<std::unique_ptr<Type>> type_args\n+\t\t   = std::vector<std::unique_ptr<Type>> (),\n+\t\t   std::vector<GenericArgsBinding> binding_args\n+\t\t   = std::vector<GenericArgsBinding> ())\n+    : segment_name (PathIdentSegment (std::move (segment_name))),\n+      generic_args (GenericArgs (std::move (lifetime_args),\n+\t\t\t\t std::move (type_args),\n+\t\t\t\t std::move (binding_args))),\n       locus (locus)\n   {}\n \n   // Returns whether path expression segment is in an error state.\n-  inline bool is_error () const { return segment_name.is_error (); }\n+  bool is_error () const { return segment_name.is_error (); }\n \n   // Creates an error-state path expression segment.\n   static PathExprSegment create_error ()\n   {\n     return PathExprSegment (PathIdentSegment::create_error ());\n   }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const;\n \n-  inline Location get_locus () const { return locus; }\n+  Location get_locus () const { return locus; }\n };\n \n // AST node representing a pattern that involves a \"path\" - abstract base class\n class PathPattern : public Pattern\n {\n-  ::std::vector<PathExprSegment> segments;\n+  std::vector<PathExprSegment> segments;\n \n protected:\n-  PathPattern (::std::vector<PathExprSegment> segments)\n-    : segments (::std::move (segments))\n+  PathPattern (std::vector<PathExprSegment> segments)\n+    : segments (std::move (segments))\n   {}\n \n   // Returns whether path has segments.\n-  inline bool has_segments () const { return !segments.empty (); }\n+  bool has_segments () const { return !segments.empty (); }\n \n   /* Converts path segments to their equivalent SimplePath segments if possible,\n    * and creates a SimplePath from them. */\n@@ -256,45 +234,44 @@ class PathPattern : public Pattern\n public:\n   /* Returns whether the path is a single segment (excluding qualified path\n    * initial as segment). */\n-  inline bool is_single_segment () const { return segments.size () == 1; }\n+  bool is_single_segment () const { return segments.size () == 1; }\n \n-  virtual ::std::string as_string () const;\n+  std::string as_string () const override;\n };\n \n-// AST node representing a path-in-expression pattern (path that allows generic\n-// arguments)\n+/* AST node representing a path-in-expression pattern (path that allows generic\n+ * arguments) */\n class PathInExpression : public PathPattern, public PathExpr\n {\n   bool has_opening_scope_resolution;\n-\n   Location locus;\n \n public:\n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   // Constructor\n-  PathInExpression (::std::vector<PathExprSegment> path_segments,\n+  PathInExpression (std::vector<PathExprSegment> path_segments,\n \t\t    Location locus = Location (),\n \t\t    bool has_opening_scope_resolution = false,\n-\t\t    ::std::vector<Attribute> outer_attrs\n-\t\t    = ::std::vector<Attribute> ())\n-    : PathPattern (::std::move (path_segments)),\n-      PathExpr (::std::move (outer_attrs)),\n+\t\t    std::vector<Attribute> outer_attrs\n+\t\t    = std::vector<Attribute> ())\n+    : PathPattern (std::move (path_segments)),\n+      PathExpr (std::move (outer_attrs)),\n       has_opening_scope_resolution (has_opening_scope_resolution), locus (locus)\n   {}\n \n   // Creates an error state path in expression.\n   static PathInExpression create_error ()\n   {\n-    return PathInExpression (::std::vector<PathExprSegment> ());\n+    return PathInExpression (std::vector<PathExprSegment> ());\n   }\n \n   // Returns whether path in expression is in an error state.\n-  inline bool is_error () const { return !has_segments (); }\n+  bool is_error () const { return !has_segments (); }\n \n   /* Converts PathInExpression to SimplePath if possible (i.e. no generic\n    * arguments). Otherwise returns an empty SimplePath. */\n-  inline SimplePath as_simple_path () const\n+  SimplePath as_simple_path () const\n   {\n     /* delegate to parent class as can't access segments. however,\n      * QualifiedPathInExpression conversion to simple path wouldn't make sense,\n@@ -305,29 +282,28 @@ class PathInExpression : public PathPattern, public PathExpr\n   }\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n \n-  Location get_locus_slow () const OVERRIDE { return get_locus (); }\n-\n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual PathInExpression *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  PathInExpression *clone_pattern_impl () const override\n   {\n     return new PathInExpression (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual PathInExpression *clone_expr_without_block_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  PathInExpression *clone_expr_without_block_impl () const override\n   {\n     return new PathInExpression (*this);\n   }\n };\n \n-// Base class for segments used in type paths - not abstract (represents an\n-// ident-only segment)\n+/* Base class for segments used in type paths - not abstract (represents an\n+ * ident-only segment) */\n class TypePathSegment\n {\n   /* TODO: may have to unify TypePathSegment and PathExprSegment (which are\n@@ -340,8 +316,8 @@ class TypePathSegment\n   Location locus;\n \n protected:\n-  // This is protected because it is only really used by derived classes, not\n-  // the base.\n+  /* This is protected because it is only really used by derived classes, not\n+   * the base. */\n   bool has_separating_scope_resolution;\n \n   // Clone function implementation - not pure virtual as overrided by subclasses\n@@ -354,38 +330,35 @@ class TypePathSegment\n   virtual ~TypePathSegment () {}\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<TypePathSegment> clone_type_path_segment () const\n+  std::unique_ptr<TypePathSegment> clone_type_path_segment () const\n   {\n-    return ::std::unique_ptr<TypePathSegment> (clone_type_path_segment_impl ());\n+    return std::unique_ptr<TypePathSegment> (clone_type_path_segment_impl ());\n   }\n \n   TypePathSegment (PathIdentSegment ident_segment,\n \t\t   bool has_separating_scope_resolution, Location locus)\n-    : ident_segment (::std::move (ident_segment)), locus (locus),\n+    : ident_segment (std::move (ident_segment)), locus (locus),\n       has_separating_scope_resolution (has_separating_scope_resolution)\n   {}\n \n-  TypePathSegment (::std::string segment_name,\n+  TypePathSegment (std::string segment_name,\n \t\t   bool has_separating_scope_resolution, Location locus)\n-    : ident_segment (PathIdentSegment (::std::move (segment_name))),\n+    : ident_segment (PathIdentSegment (std::move (segment_name))),\n       locus (locus),\n       has_separating_scope_resolution (has_separating_scope_resolution)\n   {}\n \n-  virtual ::std::string as_string () const\n-  {\n-    return ident_segment.as_string ();\n-  }\n+  virtual std::string as_string () const { return ident_segment.as_string (); }\n \n-  // Returns whether the type path segment is in an error state. May be virtual\n-  // in future.\n-  inline bool is_error () const { return ident_segment.is_error (); }\n+  /* Returns whether the type path segment is in an error state. May be virtual\n+   * in future. */\n+  bool is_error () const { return ident_segment.is_error (); }\n \n   /* Returns whether segment is identifier only (as opposed to generic args or\n-  function). Overriden in derived classes with other segments. */\n+   * function). Overriden in derived classes with other segments. */\n   virtual bool is_ident_only () const { return true; }\n \n-  inline Location get_locus () const { return locus; }\n+  Location get_locus () const { return locus; }\n \n   // not pure virtual as class not abstract\n   virtual void accept_vis (ASTVisitor &vis);\n@@ -397,43 +370,40 @@ class TypePathSegmentGeneric : public TypePathSegment\n   GenericArgs generic_args;\n \n public:\n-  inline bool has_generic_args () const\n-  {\n-    return generic_args.has_generic_args ();\n-  }\n+  bool has_generic_args () const { return generic_args.has_generic_args (); }\n \n-  bool is_ident_only () const { return false; }\n+  bool is_ident_only () const override { return false; }\n \n   // Constructor with PathIdentSegment and GenericArgs\n   TypePathSegmentGeneric (PathIdentSegment ident_segment,\n \t\t\t  bool has_separating_scope_resolution,\n \t\t\t  GenericArgs generic_args, Location locus)\n-    : TypePathSegment (::std::move (ident_segment),\n+    : TypePathSegment (std::move (ident_segment),\n \t\t       has_separating_scope_resolution, locus),\n-      generic_args (::std::move (generic_args))\n+      generic_args (std::move (generic_args))\n   {}\n \n   // Constructor from segment name and all args\n-  TypePathSegmentGeneric (::std::string segment_name,\n+  TypePathSegmentGeneric (std::string segment_name,\n \t\t\t  bool has_separating_scope_resolution,\n-\t\t\t  ::std::vector<Lifetime> lifetime_args,\n-\t\t\t  ::std::vector< ::std::unique_ptr<Type> > type_args,\n-\t\t\t  ::std::vector<GenericArgsBinding> binding_args,\n+\t\t\t  std::vector<Lifetime> lifetime_args,\n+\t\t\t  std::vector<std::unique_ptr<Type>> type_args,\n+\t\t\t  std::vector<GenericArgsBinding> binding_args,\n \t\t\t  Location locus)\n-    : TypePathSegment (::std::move (segment_name),\n+    : TypePathSegment (std::move (segment_name),\n \t\t       has_separating_scope_resolution, locus),\n-      generic_args (GenericArgs (::std::move (lifetime_args),\n-\t\t\t\t ::std::move (type_args),\n-\t\t\t\t ::std::move (binding_args)))\n+      generic_args (GenericArgs (std::move (lifetime_args),\n+\t\t\t\t std::move (type_args),\n+\t\t\t\t std::move (binding_args)))\n   {}\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n   // Use covariance to override base class method\n-  virtual TypePathSegmentGeneric *clone_type_path_segment_impl () const OVERRIDE\n+  TypePathSegmentGeneric *clone_type_path_segment_impl () const override\n   {\n     return new TypePathSegmentGeneric (*this);\n   }\n@@ -446,12 +416,11 @@ struct TypePathFunction\n   // TODO: remove\n   /*bool has_inputs;\n   TypePathFnInputs inputs;*/\n-  //::std::vector<Type> inputs; // inlined from TypePathFnInputs\n-  ::std::vector< ::std::unique_ptr<Type> > inputs;\n+  // inlined from TypePathFnInputs\n+  std::vector<std::unique_ptr<Type>> inputs;\n \n   // bool has_type;\n-  // Type type;\n-  ::std::unique_ptr<Type> return_type;\n+  std::unique_ptr<Type> return_type;\n \n   // FIXME: think of better way to mark as invalid than taking up storage\n   bool is_invalid;\n@@ -464,63 +433,52 @@ struct TypePathFunction\n \n public:\n   // Returns whether the return type of the function has been specified.\n-  inline bool has_return_type () const { return return_type != NULL; }\n+  bool has_return_type () const { return return_type != nullptr; }\n \n   // Returns whether the function has inputs.\n-  inline bool has_inputs () const { return !inputs.empty (); }\n+  bool has_inputs () const { return !inputs.empty (); }\n \n   // Returns whether function is in an error state.\n-  inline bool is_error () const { return is_invalid; }\n+  bool is_error () const { return is_invalid; }\n \n   // Creates an error state function.\n   static TypePathFunction create_error () { return TypePathFunction (true); }\n \n   // Constructor\n-  TypePathFunction (::std::vector< ::std::unique_ptr<Type> > inputs,\n-\t\t    Type *type = NULL)\n-    : inputs (::std::move (inputs)), return_type (type), is_invalid (false)\n+  TypePathFunction (std::vector<std::unique_ptr<Type>> inputs,\n+\t\t    Type *type = nullptr)\n+    : inputs (std::move (inputs)), return_type (type), is_invalid (false)\n   {}\n   // FIXME: deprecated\n \n   // Constructor\n-  TypePathFunction (::std::vector< ::std::unique_ptr<Type> > inputs,\n-\t\t    ::std::unique_ptr<Type> type = NULL)\n-    : inputs (::std::move (inputs)), return_type (::std::move (type)),\n+  TypePathFunction (std::vector<std::unique_ptr<Type>> inputs,\n+\t\t    std::unique_ptr<Type> type = nullptr)\n+    : inputs (std::move (inputs)), return_type (std::move (type)),\n       is_invalid (false)\n   {}\n \n   // Copy constructor with clone\n   TypePathFunction (TypePathFunction const &other)\n-    : /*inputs(other.inputs),*/ return_type (other.return_type->clone_type ()),\n+    : return_type (other.return_type->clone_type ()),\n       is_invalid (other.is_invalid)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     inputs.reserve (other.inputs.size ());\n-\n     for (const auto &e : other.inputs)\n-      {\n-\tinputs.push_back (e->clone_type ());\n-      }\n+      inputs.push_back (e->clone_type ());\n   }\n \n   ~TypePathFunction () = default;\n \n   // Overloaded assignment operator to clone type\n   TypePathFunction &operator= (TypePathFunction const &other)\n   {\n-    // inputs = other.inputs;\n     return_type = other.return_type->clone_type ();\n     is_invalid = other.is_invalid;\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     inputs.reserve (other.inputs.size ());\n-\n     for (const auto &e : other.inputs)\n-      {\n-\tinputs.push_back (e->clone_type ());\n-      }\n+      inputs.push_back (e->clone_type ());\n \n     return *this;\n   }\n@@ -529,7 +487,7 @@ struct TypePathFunction\n   TypePathFunction (TypePathFunction &&other) = default;\n   TypePathFunction &operator= (TypePathFunction &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const;\n };\n \n // Segment used in type path with a function argument\n@@ -542,30 +500,29 @@ class TypePathSegmentFunction : public TypePathSegment\n   TypePathSegmentFunction (PathIdentSegment ident_segment,\n \t\t\t   bool has_separating_scope_resolution,\n \t\t\t   TypePathFunction function_path, Location locus)\n-    : TypePathSegment (::std::move (ident_segment),\n+    : TypePathSegment (std::move (ident_segment),\n \t\t       has_separating_scope_resolution, locus),\n-      function_path (::std::move (function_path))\n+      function_path (std::move (function_path))\n   {}\n \n   // Constructor with segment name and TypePathFn\n-  TypePathSegmentFunction (::std::string segment_name,\n+  TypePathSegmentFunction (std::string segment_name,\n \t\t\t   bool has_separating_scope_resolution,\n \t\t\t   TypePathFunction function_path, Location locus)\n-    : TypePathSegment (::std::move (segment_name),\n+    : TypePathSegment (std::move (segment_name),\n \t\t       has_separating_scope_resolution, locus),\n-      function_path (::std::move (function_path))\n+      function_path (std::move (function_path))\n   {}\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  bool is_ident_only () const { return false; }\n+  bool is_ident_only () const override { return false; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n   // Use covariance to override base class method\n-  virtual TypePathSegmentFunction *\n-  clone_type_path_segment_impl () const OVERRIDE\n+  TypePathSegmentFunction *clone_type_path_segment_impl () const override\n   {\n     return new TypePathSegmentFunction (*this);\n   }\n@@ -576,63 +533,54 @@ class TypePath : public TypeNoBounds\n {\n public:\n   bool has_opening_scope_resolution;\n-  ::std::vector< ::std::unique_ptr<TypePathSegment> > segments;\n-\n+  std::vector<std::unique_ptr<TypePathSegment>> segments;\n   Location locus;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TypePath *clone_type_impl () const OVERRIDE\n-  {\n-    return new TypePath (*this);\n-  }\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TypePath *clone_type_impl () const override { return new TypePath (*this); }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TypePath *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TypePath *clone_type_no_bounds_impl () const override\n   {\n     return new TypePath (*this);\n   }\n \n public:\n   /* Returns whether the TypePath has an opening scope resolution operator (i.e.\n    * is global path or crate-relative path, not module-relative) */\n-  inline bool has_opening_scope_resolution_op () const\n+  bool has_opening_scope_resolution_op () const\n   {\n     return has_opening_scope_resolution;\n   }\n \n   // Returns whether the TypePath is in an invalid state.\n-  inline bool is_error () const { return segments.empty (); }\n+  bool is_error () const { return segments.empty (); }\n \n   // Creates an error state TypePath.\n   static TypePath create_error ()\n   {\n-    return TypePath (::std::vector< ::std::unique_ptr<TypePathSegment> > (),\n+    return TypePath (std::vector<std::unique_ptr<TypePathSegment>> (),\n \t\t     Location ());\n   }\n \n   // Constructor\n-  TypePath (::std::vector< ::std::unique_ptr<TypePathSegment> > segments,\n+  TypePath (std::vector<std::unique_ptr<TypePathSegment>> segments,\n \t    Location locus, bool has_opening_scope_resolution = false)\n     : has_opening_scope_resolution (has_opening_scope_resolution),\n-      segments (::std::move (segments)), locus (locus)\n+      segments (std::move (segments)), locus (locus)\n   {}\n \n   // Copy constructor with vector clone\n   TypePath (TypePath const &other)\n     : has_opening_scope_resolution (other.has_opening_scope_resolution),\n       locus (other.locus)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     segments.reserve (other.segments.size ());\n-\n     for (const auto &e : other.segments)\n-      {\n-\tsegments.push_back (e->clone_type_path_segment ());\n-      }\n+      segments.push_back (e->clone_type_path_segment ());\n   }\n \n   // Overloaded assignment operator with clone\n@@ -641,14 +589,9 @@ class TypePath : public TypeNoBounds\n     has_opening_scope_resolution = other.has_opening_scope_resolution;\n     locus = other.locus;\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     segments.reserve (other.segments.size ());\n-\n     for (const auto &e : other.segments)\n-      {\n-\tsegments.push_back (e->clone_type_path_segment ());\n-      }\n+      segments.push_back (e->clone_type_path_segment ());\n \n     return *this;\n   }\n@@ -657,25 +600,24 @@ class TypePath : public TypeNoBounds\n   TypePath (TypePath &&other) = default;\n   TypePath &operator= (TypePath &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   /* Converts TypePath to SimplePath if possible (i.e. no generic or function\n    * arguments). Otherwise returns an empty SimplePath. */\n   SimplePath as_simple_path () const;\n \n   // Creates a trait bound with a clone of this type path as its only element.\n-  virtual TraitBound *to_trait_bound (bool in_parens) const OVERRIDE;\n+  TraitBound *to_trait_bound (bool in_parens) const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n };\n \n struct QualifiedPathType\n {\n private:\n-  // Type type_to_invoke_on;\n-  ::std::unique_ptr<Type> type_to_invoke_on;\n+  std::unique_ptr<Type> type_to_invoke_on;\n \n   // bool has_as_clause;\n   TypePath trait_path;\n@@ -684,11 +626,11 @@ struct QualifiedPathType\n \n public:\n   // Constructor\n-  QualifiedPathType (::std::unique_ptr<Type> invoke_on_type,\n+  QualifiedPathType (std::unique_ptr<Type> invoke_on_type,\n \t\t     Location locus = Location (),\n \t\t     TypePath trait_path = TypePath::create_error ())\n-    : type_to_invoke_on (::std::move (invoke_on_type)),\n-      trait_path (::std::move (trait_path)), locus (locus)\n+    : type_to_invoke_on (std::move (invoke_on_type)),\n+      trait_path (std::move (trait_path)), locus (locus)\n   {}\n \n   // Copy constructor uses custom deep copy for Type to preserve polymorphism\n@@ -714,128 +656,118 @@ struct QualifiedPathType\n   QualifiedPathType &operator= (QualifiedPathType &&other) = default;\n \n   // Returns whether the qualified path type has a rebind as clause.\n-  inline bool has_as_clause () const { return !trait_path.is_error (); }\n+  bool has_as_clause () const { return !trait_path.is_error (); }\n \n   // Returns whether the qualified path type is in an error state.\n-  inline bool is_error () const { return type_to_invoke_on == NULL; }\n+  bool is_error () const { return type_to_invoke_on == nullptr; }\n \n   // Creates an error state qualified path type.\n-  static QualifiedPathType create_error () { return QualifiedPathType (NULL); }\n+  static QualifiedPathType create_error ()\n+  {\n+    return QualifiedPathType (nullptr);\n+  }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const;\n \n-  inline Location get_locus () const { return locus; }\n+  Location get_locus () const { return locus; }\n };\n \n /* AST node representing a qualified path-in-expression pattern (path that\n  * allows specifying trait functions) */\n class QualifiedPathInExpression : public PathPattern, public PathExpr\n {\n   QualifiedPathType path_type;\n-\n   Location locus;\n \n public:\n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   QualifiedPathInExpression (QualifiedPathType qual_path_type,\n-\t\t\t     ::std::vector<PathExprSegment> path_segments,\n+\t\t\t     std::vector<PathExprSegment> path_segments,\n \t\t\t     Location locus = Location (),\n-\t\t\t     ::std::vector<Attribute> outer_attrs\n-\t\t\t     = ::std::vector<Attribute> ())\n-    : PathPattern (::std::move (path_segments)),\n-      PathExpr (::std::move (outer_attrs)),\n-      path_type (::std::move (qual_path_type)), locus (locus)\n+\t\t\t     std::vector<Attribute> outer_attrs\n+\t\t\t     = std::vector<Attribute> ())\n+    : PathPattern (std::move (path_segments)),\n+      PathExpr (std::move (outer_attrs)),\n+      path_type (std::move (qual_path_type)), locus (locus)\n   {}\n \n-  // TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n-  // as params\n-\n-  // Copy constructor, destructor, and assignment operator overload shouldn't be\n-  // required\n+  /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n+   * as params */\n \n   // Returns whether qualified path in expression is in an error state.\n-  inline bool is_error () const { return path_type.is_error (); }\n+  bool is_error () const { return path_type.is_error (); }\n \n   // Creates an error qualified path in expression.\n   static QualifiedPathInExpression create_error ()\n   {\n     return QualifiedPathInExpression (QualifiedPathType::create_error (),\n-\t\t\t\t      ::std::vector<PathExprSegment> ());\n+\t\t\t\t      std::vector<PathExprSegment> ());\n   }\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n \n-  Location get_locus_slow () const OVERRIDE { return get_locus (); }\n-\n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual QualifiedPathInExpression *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInExpression *clone_pattern_impl () const override\n   {\n     return new QualifiedPathInExpression (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual QualifiedPathInExpression *\n-  clone_expr_without_block_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInExpression *clone_expr_without_block_impl () const override\n   {\n     return new QualifiedPathInExpression (*this);\n   }\n };\n \n-// Represents a qualified path in a type; used for disambiguating trait function\n-// calls\n+/* Represents a qualified path in a type; used for disambiguating trait function\n+ * calls */\n class QualifiedPathInType : public TypeNoBounds\n {\n   QualifiedPathType path_type;\n-  // ::std::vector<TypePathSegment> segments;\n-  ::std::vector< ::std::unique_ptr<TypePathSegment> > segments;\n-\n+  std::vector<std::unique_ptr<TypePathSegment>> segments;\n   Location locus;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual QualifiedPathInType *clone_type_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInType *clone_type_impl () const override\n   {\n     return new QualifiedPathInType (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual QualifiedPathInType *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInType *clone_type_no_bounds_impl () const override\n   {\n     return new QualifiedPathInType (*this);\n   }\n \n public:\n   QualifiedPathInType (\n     QualifiedPathType qual_path_type,\n-    ::std::vector< ::std::unique_ptr<TypePathSegment> > path_segments,\n+    std::vector<std::unique_ptr<TypePathSegment>> path_segments,\n     Location locus = Location ())\n-    : path_type (::std::move (qual_path_type)),\n-      segments (::std::move (path_segments)), locus (locus)\n+    : path_type (std::move (qual_path_type)),\n+      segments (std::move (path_segments)), locus (locus)\n   {}\n \n-  // TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n-  // as params\n+  /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n+   * as params */\n \n   // Copy constructor with vector clone\n   QualifiedPathInType (QualifiedPathInType const &other)\n     : path_type (other.path_type), locus (other.locus)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     segments.reserve (other.segments.size ());\n-\n     for (const auto &e : other.segments)\n-      {\n-\tsegments.push_back (e->clone_type_path_segment ());\n-      }\n+      segments.push_back (e->clone_type_path_segment ());\n   }\n \n   // Overloaded assignment operator with vector clone\n@@ -844,14 +776,9 @@ class QualifiedPathInType : public TypeNoBounds\n     path_type = other.path_type;\n     locus = other.locus;\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     segments.reserve (other.segments.size ());\n-\n     for (const auto &e : other.segments)\n-      {\n-\tsegments.push_back (e->clone_type_path_segment ());\n-      }\n+      segments.push_back (e->clone_type_path_segment ());\n \n     return *this;\n   }\n@@ -861,19 +788,19 @@ class QualifiedPathInType : public TypeNoBounds\n   QualifiedPathInType &operator= (QualifiedPathInType &&other) = default;\n \n   // Returns whether qualified path in type is in an error state.\n-  inline bool is_error () const { return path_type.is_error (); }\n+  bool is_error () const { return path_type.is_error (); }\n \n   // Creates an error state qualified path in type.\n   static QualifiedPathInType create_error ()\n   {\n     return QualifiedPathInType (\n       QualifiedPathType::create_error (),\n-      ::std::vector< ::std::unique_ptr<TypePathSegment> > ());\n+      std::vector<std::unique_ptr<TypePathSegment>> ());\n   }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n };\n } // namespace AST\n } // namespace Rust"}, {"sha": "4e639a515b62aead9c6b4e234dd2d2452072e5e4", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 235, "deletions": 414, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -8,10 +8,10 @@ namespace AST {\n // Literal pattern AST node (comparing to a literal)\n class LiteralPattern : public Pattern\n {\n-  Literal lit; // make literal have a type given by enum, etc. rustc uses an\n-\t       // extended form\n-  // of its literal token implementation\n-  // FIXME: literal representation - use LiteralExpr? or another thing?\n+  Literal lit;\n+  /* make literal have a type given by enum, etc. rustc uses an extended form of\n+   * its literal token implementation */\n+  // TODO: literal representation - use LiteralExpr? or another thing?\n \n   // Minus prefixed to literal (if integer or floating-point)\n   bool has_minus;\n@@ -20,27 +20,27 @@ class LiteralPattern : public Pattern\n   Location locus;\n \n public:\n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   // Constructor for a literal pattern\n   LiteralPattern (Literal lit, Location locus, bool has_minus = false)\n-    : lit (::std::move (lit)), has_minus (has_minus), locus (locus)\n+    : lit (std::move (lit)), has_minus (has_minus), locus (locus)\n   {}\n \n-  LiteralPattern (::std::string val, Literal::LitType type, Location locus,\n+  LiteralPattern (std::string val, Literal::LitType type, Location locus,\n \t\t  bool has_minus = false)\n-    : lit (Literal (::std::move (val), type)), has_minus (has_minus),\n+    : lit (Literal (std::move (val), type)), has_minus (has_minus),\n       locus (locus)\n   {}\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual LiteralPattern *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  virtual LiteralPattern *clone_pattern_impl () const override\n   {\n     return new LiteralPattern (*this);\n   }\n@@ -55,26 +55,21 @@ class IdentifierPattern : public Pattern\n   bool is_mut;\n \n   // bool has_pattern;\n-  // Pattern* to_bind;\n-  ::std::unique_ptr<Pattern> to_bind;\n+  std::unique_ptr<Pattern> to_bind;\n \n   Location locus;\n \n-  /*~IdentifierPattern() {\n-      delete to_bind;\n-  }*/\n-\n-  ::std::string as_string () const;\n+  std::string as_string () const;\n \n   // Returns whether the IdentifierPattern has a pattern to bind.\n-  inline bool has_pattern_to_bind () const { return to_bind != NULL; }\n+  bool has_pattern_to_bind () const { return to_bind != nullptr; }\n \n   // Constructor\n   IdentifierPattern (Identifier ident, Location locus, bool is_ref = false,\n \t\t     bool is_mut = false,\n-\t\t     ::std::unique_ptr<Pattern> to_bind = NULL)\n-    : variable_ident (::std::move (ident)), is_ref (is_ref), is_mut (is_mut),\n-      to_bind (::std::move (to_bind)), locus (locus)\n+\t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n+    : variable_ident (std::move (ident)), is_ref (is_ref), is_mut (is_mut),\n+      to_bind (std::move (to_bind)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n@@ -83,26 +78,21 @@ class IdentifierPattern : public Pattern\n       is_mut (other.is_mut), locus (other.locus)\n   {\n     // fix to get prevent null pointer dereference\n-    if (other.to_bind != NULL)\n-      {\n-\tto_bind = other.to_bind->clone_pattern ();\n-      }\n+    if (other.to_bind != nullptr)\n+      to_bind = other.to_bind->clone_pattern ();\n   }\n \n-  // Destructor - define here if required\n-\n   // Overload assignment operator to use clone\n   IdentifierPattern &operator= (IdentifierPattern const &other)\n   {\n     variable_ident = other.variable_ident;\n     is_ref = other.is_ref;\n     is_mut = other.is_mut;\n     locus = other.locus;\n+\n     // fix to get prevent null pointer dereference\n-    if (other.to_bind != NULL)\n-      {\n-\tto_bind = other.to_bind->clone_pattern ();\n-      }\n+    if (other.to_bind != nullptr)\n+      to_bind = other.to_bind->clone_pattern ();\n \n     return *this;\n   }\n@@ -113,12 +103,12 @@ class IdentifierPattern : public Pattern\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual IdentifierPattern *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  IdentifierPattern *clone_pattern_impl () const override\n   {\n     return new IdentifierPattern (*this);\n   }\n@@ -130,18 +120,18 @@ class WildcardPattern : public Pattern\n   Location locus;\n \n public:\n-  ::std::string as_string () const { return ::std::string (1, '_'); }\n+  std::string as_string () const override { return std::string (1, '_'); }\n \n   WildcardPattern (Location locus) : locus (locus) {}\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual WildcardPattern *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  WildcardPattern *clone_pattern_impl () const override\n   {\n     return new WildcardPattern (*this);\n   }\n@@ -150,25 +140,17 @@ class WildcardPattern : public Pattern\n // Base range pattern bound (lower or upper limit) - abstract\n class RangePatternBound\n {\n-  /*union {\n-      CharLiteral char_lit;\n-      ByteLiteral byte_lit;\n-      IntLiteral int_lit;\n-      FloatLiteral float_lit;\n-      PathInExpression path;\n-      QualifiedPathInExpression qual_path;\n-  } pattern;*/\n public:\n   virtual ~RangePatternBound () {}\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<RangePatternBound> clone_range_pattern_bound () const\n+  std::unique_ptr<RangePatternBound> clone_range_pattern_bound () const\n   {\n-    return ::std::unique_ptr<RangePatternBound> (\n+    return std::unique_ptr<RangePatternBound> (\n       clone_range_pattern_bound_impl ());\n   }\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n@@ -181,8 +163,8 @@ class RangePatternBound\n class RangePatternBoundLiteral : public RangePatternBound\n {\n   Literal literal;\n-  // Can only be a char, byte, int, or float literal - same impl here as\n-  // previously\n+  /* Can only be a char, byte, int, or float literal - same impl here as\n+   * previously */\n \n   // Minus prefixed to literal (if integer or floating-point)\n   bool has_minus;\n@@ -196,17 +178,16 @@ class RangePatternBoundLiteral : public RangePatternBound\n     : literal (literal), has_minus (has_minus), locus (locus)\n   {}\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual RangePatternBoundLiteral *\n-  clone_range_pattern_bound_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundLiteral *clone_range_pattern_bound_impl () const override\n   {\n     return new RangePatternBoundLiteral (*this);\n   }\n@@ -217,23 +198,22 @@ class RangePatternBoundPath : public RangePatternBound\n {\n   PathInExpression path;\n \n-  // TODO: should this be refactored so that PathInExpression is a subclass of\n-  // RangePatternBound?\n+  /* TODO: should this be refactored so that PathInExpression is a subclass of\n+   * RangePatternBound? */\n \n public:\n-  RangePatternBoundPath (PathInExpression path) : path (::std::move (path)) {}\n+  RangePatternBoundPath (PathInExpression path) : path (std::move (path)) {}\n \n-  ::std::string as_string () const { return path.as_string (); }\n+  std::string as_string () const override { return path.as_string (); }\n \n   Location get_locus () const { return path.get_locus (); }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual RangePatternBoundPath *\n-  clone_range_pattern_bound_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundPath *clone_range_pattern_bound_impl () const override\n   {\n     return new RangePatternBoundPath (*this);\n   }\n@@ -249,20 +229,19 @@ class RangePatternBoundQualPath : public RangePatternBound\n \n public:\n   RangePatternBoundQualPath (QualifiedPathInExpression path)\n-    : path (::std::move (path))\n+    : path (std::move (path))\n   {}\n \n-  ::std::string as_string () const { return path.as_string (); }\n+  std::string as_string () const override { return path.as_string (); }\n \n   Location get_locus () const { return path.get_locus (); }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual RangePatternBoundQualPath *\n-  clone_range_pattern_bound_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundQualPath *clone_range_pattern_bound_impl () const override\n   {\n     return new RangePatternBoundQualPath (*this);\n   }\n@@ -271,25 +250,23 @@ class RangePatternBoundQualPath : public RangePatternBound\n // AST node for matching within a certain range (range pattern)\n class RangePattern : public Pattern\n {\n-  /*RangePatternBound lower;\n-  RangePatternBound upper;*/\n-  ::std::unique_ptr<RangePatternBound> lower;\n-  ::std::unique_ptr<RangePatternBound> upper;\n+  std::unique_ptr<RangePatternBound> lower;\n+  std::unique_ptr<RangePatternBound> upper;\n \n   bool has_ellipsis_syntax;\n \n-  // location only stored to avoid a dereference - lower pattern should give\n-  // correct location so maybe change in future\n+  /* location only stored to avoid a dereference - lower pattern should give\n+   * correct location so maybe change in future */\n   Location locus;\n \n public:\n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   // Constructor\n-  RangePattern (::std::unique_ptr<RangePatternBound> lower,\n-\t\t::std::unique_ptr<RangePatternBound> upper, Location locus,\n+  RangePattern (std::unique_ptr<RangePatternBound> lower,\n+\t\tstd::unique_ptr<RangePatternBound> upper, Location locus,\n \t\tbool has_ellipsis_syntax = false)\n-    : lower (::std::move (lower)), upper (::std::move (upper)),\n+    : lower (std::move (lower)), upper (std::move (upper)),\n       has_ellipsis_syntax (has_ellipsis_syntax), locus (locus)\n   {}\n \n@@ -300,8 +277,6 @@ class RangePattern : public Pattern\n       has_ellipsis_syntax (other.has_ellipsis_syntax), locus (other.locus)\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overloaded assignment operator to clone\n   RangePattern &operator= (RangePattern const &other)\n   {\n@@ -319,12 +294,12 @@ class RangePattern : public Pattern\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual RangePattern *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePattern *clone_pattern_impl () const override\n   {\n     return new RangePattern (*this);\n   }\n@@ -335,22 +310,16 @@ class ReferencePattern : public Pattern\n {\n   bool has_two_amps;\n   bool is_mut;\n-  // Pattern* pattern;\n-  ::std::unique_ptr<Pattern> pattern;\n-\n+  std::unique_ptr<Pattern> pattern;\n   Location locus;\n \n public:\n-  /*~ReferencePattern() {\n-      delete pattern;\n-  }*/\n+  std::string as_string () const override;\n \n-  ::std::string as_string () const;\n-\n-  ReferencePattern (::std::unique_ptr<Pattern> pattern, bool is_mut_reference,\n+  ReferencePattern (std::unique_ptr<Pattern> pattern, bool is_mut_reference,\n \t\t    bool ref_has_two_amps, Location locus)\n     : has_two_amps (ref_has_two_amps), is_mut (is_mut_reference),\n-      pattern (::std::move (pattern)), locus (locus)\n+      pattern (std::move (pattern)), locus (locus)\n   {}\n \n   // Copy constructor requires clone\n@@ -359,8 +328,6 @@ class ReferencePattern : public Pattern\n       pattern (other.pattern->clone_pattern ()), locus (other.locus)\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overload assignment operator to clone\n   ReferencePattern &operator= (ReferencePattern const &other)\n   {\n@@ -376,12 +343,12 @@ class ReferencePattern : public Pattern\n   ReferencePattern (ReferencePattern &&other) = default;\n   ReferencePattern &operator= (ReferencePattern &&other) = default;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ReferencePattern *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferencePattern *clone_pattern_impl () const override\n   {\n     return new ReferencePattern (*this);\n   }\n@@ -391,63 +358,47 @@ class ReferencePattern : public Pattern\n struct StructPatternEtc\n {\n private:\n-  ::std::vector<Attribute> outer_attrs;\n+  std::vector<Attribute> outer_attrs;\n \n   // should this store location data?\n \n public:\n-  StructPatternEtc (::std::vector<Attribute> outer_attribs)\n-    : outer_attrs (::std::move (outer_attribs))\n+  StructPatternEtc (std::vector<Attribute> outer_attribs)\n+    : outer_attrs (std::move (outer_attribs))\n   {}\n \n   // Creates an empty StructPatternEtc\n   static StructPatternEtc create_empty ()\n   {\n-    return StructPatternEtc (::std::vector<Attribute> ());\n+    return StructPatternEtc (std::vector<Attribute> ());\n   }\n };\n \n // Base class for a single field in a struct pattern - abstract\n class StructPatternField\n {\n-  ::std::vector<Attribute> outer_attrs;\n-  /*union {\n-      struct {\n-\t  //TupleIndex index;\n-\t  Pattern tuple_pattern;\n-      } tuple_pattern;\n-      struct {\n-\t  //Identifier ident;\n-\t  Pattern ident_pattern;\n-      } ident_pattern;\n-      struct {\n-\t  bool has_ref;\n-\t  bool has_mut;\n-\t  //Identifier ident;\n-      } ident;\n-  } pattern;*/\n-\n+  std::vector<Attribute> outer_attrs;\n   Location locus;\n \n public:\n   virtual ~StructPatternField () {}\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<StructPatternField> clone_struct_pattern_field () const\n+  std::unique_ptr<StructPatternField> clone_struct_pattern_field () const\n   {\n-    return ::std::unique_ptr<StructPatternField> (\n+    return std::unique_ptr<StructPatternField> (\n       clone_struct_pattern_field_impl ());\n   }\n \n-  virtual ::std::string as_string () const;\n+  virtual std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n protected:\n-  StructPatternField (::std::vector<Attribute> outer_attribs, Location locus)\n-    : outer_attrs (::std::move (outer_attribs)), locus (locus)\n+  StructPatternField (std::vector<Attribute> outer_attribs, Location locus)\n+    : outer_attrs (std::move (outer_attribs)), locus (locus)\n   {}\n \n   // Clone function implementation as pure virtual method\n@@ -458,20 +409,15 @@ class StructPatternField\n class StructPatternFieldTuplePat : public StructPatternField\n {\n   TupleIndex index;\n-  // Pattern* tuple_pattern;\n-  ::std::unique_ptr<Pattern> tuple_pattern;\n+  std::unique_ptr<Pattern> tuple_pattern;\n \n public:\n-  /*~StructPatternFieldTuplePat() {\n-      delete tuple_pattern;\n-  }*/\n-\n   StructPatternFieldTuplePat (TupleIndex index,\n-\t\t\t      ::std::unique_ptr<Pattern> tuple_pattern,\n-\t\t\t      ::std::vector<Attribute> outer_attribs,\n+\t\t\t      std::unique_ptr<Pattern> tuple_pattern,\n+\t\t\t      std::vector<Attribute> outer_attribs,\n \t\t\t      Location locus)\n-    : StructPatternField (::std::move (outer_attribs), locus), index (index),\n-      tuple_pattern (::std::move (tuple_pattern))\n+    : StructPatternField (std::move (outer_attribs), locus), index (index),\n+      tuple_pattern (std::move (tuple_pattern))\n   {}\n \n   // Copy constructor requires clone\n@@ -480,8 +426,6 @@ class StructPatternFieldTuplePat : public StructPatternField\n       tuple_pattern (other.tuple_pattern->clone_pattern ())\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overload assignment operator to perform clone\n   StructPatternFieldTuplePat &\n   operator= (StructPatternFieldTuplePat const &other)\n@@ -499,15 +443,14 @@ class StructPatternFieldTuplePat : public StructPatternField\n   StructPatternFieldTuplePat &operator= (StructPatternFieldTuplePat &&other)\n     = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual StructPatternFieldTuplePat *\n-  clone_struct_pattern_field_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldTuplePat *clone_struct_pattern_field_impl () const override\n   {\n     return new StructPatternFieldTuplePat (*this);\n   }\n@@ -517,20 +460,15 @@ class StructPatternFieldTuplePat : public StructPatternField\n class StructPatternFieldIdentPat : public StructPatternField\n {\n   Identifier ident;\n-  // Pattern* ident_pattern;\n-  ::std::unique_ptr<Pattern> ident_pattern;\n+  std::unique_ptr<Pattern> ident_pattern;\n \n public:\n-  /*~StructPatternFieldIdentPat() {\n-      delete ident_pattern;\n-  }*/\n-\n   StructPatternFieldIdentPat (Identifier ident,\n-\t\t\t      ::std::unique_ptr<Pattern> ident_pattern,\n-\t\t\t      ::std::vector<Attribute> outer_attrs,\n+\t\t\t      std::unique_ptr<Pattern> ident_pattern,\n+\t\t\t      std::vector<Attribute> outer_attrs,\n \t\t\t      Location locus)\n-    : StructPatternField (::std::move (outer_attrs), locus),\n-      ident (::std::move (ident)), ident_pattern (::std::move (ident_pattern))\n+    : StructPatternField (std::move (outer_attrs), locus),\n+      ident (std::move (ident)), ident_pattern (std::move (ident_pattern))\n   {}\n \n   // Copy constructor requires clone\n@@ -539,8 +477,6 @@ class StructPatternFieldIdentPat : public StructPatternField\n       ident_pattern (other.ident_pattern->clone_pattern ())\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overload assignment operator to clone\n   StructPatternFieldIdentPat &\n   operator= (StructPatternFieldIdentPat const &other)\n@@ -558,15 +494,14 @@ class StructPatternFieldIdentPat : public StructPatternField\n   StructPatternFieldIdentPat &operator= (StructPatternFieldIdentPat &&other)\n     = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual StructPatternFieldIdentPat *\n-  clone_struct_pattern_field_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldIdentPat *clone_struct_pattern_field_impl () const override\n   {\n     return new StructPatternFieldIdentPat (*this);\n   }\n@@ -577,25 +512,23 @@ class StructPatternFieldIdent : public StructPatternField\n {\n   bool has_ref;\n   bool has_mut;\n-\n   Identifier ident;\n \n public:\n   StructPatternFieldIdent (Identifier ident, bool is_ref, bool is_mut,\n-\t\t\t   ::std::vector<Attribute> outer_attrs, Location locus)\n-    : StructPatternField (::std::move (outer_attrs), locus), has_ref (is_ref),\n-      has_mut (is_mut), ident (::std::move (ident))\n+\t\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : StructPatternField (std::move (outer_attrs), locus), has_ref (is_ref),\n+      has_mut (is_mut), ident (std::move (ident))\n   {}\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual StructPatternFieldIdent *\n-  clone_struct_pattern_field_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldIdent *clone_struct_pattern_field_impl () const override\n   {\n     return new StructPatternFieldIdent (*this);\n   }\n@@ -606,8 +539,7 @@ struct StructPatternElements\n {\n private:\n   // bool has_struct_pattern_fields;\n-  //::std::vector<StructPatternField> fields;\n-  ::std::vector< ::std::unique_ptr<StructPatternField> > fields;\n+  std::vector<std::unique_ptr<StructPatternField>> fields;\n \n   bool has_struct_pattern_etc;\n   StructPatternEtc etc;\n@@ -618,42 +550,37 @@ struct StructPatternElements\n \n public:\n   // Returns whether there are any struct pattern fields\n-  inline bool has_struct_pattern_fields () const { return !fields.empty (); }\n+  bool has_struct_pattern_fields () const { return !fields.empty (); }\n \n-  // Returns whether the struct pattern elements is entirely empty (no fields,\n-  // no etc).\n-  inline bool is_empty () const\n+  /* Returns whether the struct pattern elements is entirely empty (no fields,\n+   * no etc). */\n+  bool is_empty () const\n   {\n     return !has_struct_pattern_fields () && !has_struct_pattern_etc;\n   }\n \n   // Constructor for StructPatternElements with both (potentially)\n   StructPatternElements (\n-    ::std::vector< ::std::unique_ptr<StructPatternField> > fields,\n+    std::vector<std::unique_ptr<StructPatternField>> fields,\n     StructPatternEtc etc)\n-    : fields (::std::move (fields)), has_struct_pattern_etc (true),\n-      etc (::std::move (etc))\n+    : fields (std::move (fields)), has_struct_pattern_etc (true),\n+      etc (std::move (etc))\n   {}\n \n   // Constructor for StructPatternElements with no StructPatternEtc\n   StructPatternElements (\n-    ::std::vector< ::std::unique_ptr<StructPatternField> > fields)\n-    : fields (::std::move (fields)), has_struct_pattern_etc (false),\n+    std::vector<std::unique_ptr<StructPatternField>> fields)\n+    : fields (std::move (fields)), has_struct_pattern_etc (false),\n       etc (StructPatternEtc::create_empty ())\n   {}\n \n   // Copy constructor with vector clone\n   StructPatternElements (StructPatternElements const &other)\n     : has_struct_pattern_etc (other.has_struct_pattern_etc), etc (other.etc)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     fields.reserve (other.fields.size ());\n-\n     for (const auto &e : other.fields)\n-      {\n-\tfields.push_back (e->clone_struct_pattern_field ());\n-      }\n+      fields.push_back (e->clone_struct_pattern_field ());\n   }\n \n   // Overloaded assignment operator with vector clone\n@@ -662,14 +589,9 @@ struct StructPatternElements\n     etc = other.etc;\n     has_struct_pattern_etc = other.has_struct_pattern_etc;\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     fields.reserve (other.fields.size ());\n-\n     for (const auto &e : other.fields)\n-      {\n-\tfields.push_back (e->clone_struct_pattern_field ());\n-      }\n+      fields.push_back (e->clone_struct_pattern_field ());\n \n     return *this;\n   }\n@@ -682,10 +604,10 @@ struct StructPatternElements\n   static StructPatternElements create_empty ()\n   {\n     return StructPatternElements (\n-      ::std::vector< ::std::unique_ptr<StructPatternField> > ());\n+      std::vector<std::unique_ptr<StructPatternField>> ());\n   }\n \n-  ::std::string as_string () const;\n+  std::string as_string () const;\n };\n \n // Struct pattern AST node representation\n@@ -699,30 +621,30 @@ class StructPattern : public Pattern\n   // TODO: should this store location data? Accessor uses path location data.\n \n public:\n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   // Constructs a struct pattern from specified StructPatternElements\n   StructPattern (PathInExpression struct_path,\n \t\t StructPatternElements elems\n \t\t = StructPatternElements::create_empty ())\n-    : path (::std::move (struct_path)), elems (::std::move (elems))\n+    : path (std::move (struct_path)), elems (std::move (elems))\n   {}\n \n-  // TODO: constructor to construct via elements included in\n-  // StructPatternElements\n+  /* TODO: constructor to construct via elements included in\n+   * StructPatternElements */\n \n-  // Returns whether struct pattern has any struct pattern elements (if not, it\n-  // is empty).\n-  inline bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n+  /* Returns whether struct pattern has any struct pattern elements (if not, it\n+   * is empty). */\n+  bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n \n   Location get_locus () const { return path.get_locus (); }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual StructPattern *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPattern *clone_pattern_impl () const override\n   {\n     return new StructPattern (*this);\n   }\n@@ -737,13 +659,12 @@ class TupleStructItems\n   // TODO: should this store location data?\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<TupleStructItems> clone_tuple_struct_items () const\n+  std::unique_ptr<TupleStructItems> clone_tuple_struct_items () const\n   {\n-    return ::std::unique_ptr<TupleStructItems> (\n-      clone_tuple_struct_items_impl ());\n+    return std::unique_ptr<TupleStructItems> (clone_tuple_struct_items_impl ());\n   }\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n@@ -755,38 +676,27 @@ class TupleStructItems\n // Class for non-ranged tuple struct pattern patterns\n class TupleStructItemsNoRange : public TupleStructItems\n {\n-  //::std::vector<Pattern> patterns;\n-  ::std::vector< ::std::unique_ptr<Pattern> > patterns;\n+  std::vector<std::unique_ptr<Pattern>> patterns;\n \n public:\n-  TupleStructItemsNoRange (::std::vector< ::std::unique_ptr<Pattern> > patterns)\n-    : patterns (::std::move (patterns))\n+  TupleStructItemsNoRange (std::vector<std::unique_ptr<Pattern>> patterns)\n+    : patterns (std::move (patterns))\n   {}\n \n   // Copy constructor with vector clone\n   TupleStructItemsNoRange (TupleStructItemsNoRange const &other)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     patterns.reserve (other.patterns.size ());\n-\n     for (const auto &e : other.patterns)\n-      {\n-\tpatterns.push_back (e->clone_pattern ());\n-      }\n+      patterns.push_back (e->clone_pattern ());\n   }\n \n   // Overloaded assignment operator with vector clone\n   TupleStructItemsNoRange &operator= (TupleStructItemsNoRange const &other)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     patterns.reserve (other.patterns.size ());\n-\n     for (const auto &e : other.patterns)\n-      {\n-\tpatterns.push_back (e->clone_pattern ());\n-      }\n+      patterns.push_back (e->clone_pattern ());\n \n     return *this;\n   }\n@@ -796,15 +706,14 @@ class TupleStructItemsNoRange : public TupleStructItems\n   TupleStructItemsNoRange &operator= (TupleStructItemsNoRange &&other)\n     = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TupleStructItemsNoRange *\n-  clone_tuple_struct_items_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructItemsNoRange *clone_tuple_struct_items_impl () const override\n   {\n     return new TupleStructItemsNoRange (*this);\n   }\n@@ -813,61 +722,38 @@ class TupleStructItemsNoRange : public TupleStructItems\n // Class for ranged tuple struct pattern patterns\n class TupleStructItemsRange : public TupleStructItems\n {\n-  /*::std::vector<Pattern> lower_patterns;\n-  ::std::vector<Pattern> upper_patterns;*/\n-  ::std::vector< ::std::unique_ptr<Pattern> > lower_patterns;\n-  ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns;\n+  std::vector<std::unique_ptr<Pattern>> lower_patterns;\n+  std::vector<std::unique_ptr<Pattern>> upper_patterns;\n \n public:\n-  TupleStructItemsRange (\n-    ::std::vector< ::std::unique_ptr<Pattern> > lower_patterns,\n-    ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns)\n-    : lower_patterns (::std::move (lower_patterns)),\n-      upper_patterns (::std::move (upper_patterns))\n+  TupleStructItemsRange (std::vector<std::unique_ptr<Pattern>> lower_patterns,\n+\t\t\t std::vector<std::unique_ptr<Pattern>> upper_patterns)\n+    : lower_patterns (std::move (lower_patterns)),\n+      upper_patterns (std::move (upper_patterns))\n   {}\n \n   // Copy constructor with vector clone\n   TupleStructItemsRange (TupleStructItemsRange const &other)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     lower_patterns.reserve (other.lower_patterns.size ());\n-\n     for (const auto &e : other.lower_patterns)\n-      {\n-\tlower_patterns.push_back (e->clone_pattern ());\n-      }\n+      lower_patterns.push_back (e->clone_pattern ());\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     upper_patterns.reserve (other.upper_patterns.size ());\n-\n     for (const auto &e : other.upper_patterns)\n-      {\n-\tupper_patterns.push_back (e->clone_pattern ());\n-      }\n+      upper_patterns.push_back (e->clone_pattern ());\n   }\n \n   // Overloaded assignment operator to clone\n   TupleStructItemsRange &operator= (TupleStructItemsRange const &other)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     lower_patterns.reserve (other.lower_patterns.size ());\n-\n     for (const auto &e : other.lower_patterns)\n-      {\n-\tlower_patterns.push_back (e->clone_pattern ());\n-      }\n+      lower_patterns.push_back (e->clone_pattern ());\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     upper_patterns.reserve (other.upper_patterns.size ());\n-\n     for (const auto &e : other.upper_patterns)\n-      {\n-\tupper_patterns.push_back (e->clone_pattern ());\n-      }\n+      upper_patterns.push_back (e->clone_pattern ());\n \n     return *this;\n   }\n@@ -876,14 +762,14 @@ class TupleStructItemsRange : public TupleStructItems\n   TupleStructItemsRange (TupleStructItemsRange &&other) = default;\n   TupleStructItemsRange &operator= (TupleStructItemsRange &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TupleStructItemsRange *clone_tuple_struct_items_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructItemsRange *clone_tuple_struct_items_impl () const override\n   {\n     return new TupleStructItemsRange (*this);\n   }\n@@ -893,27 +779,24 @@ class TupleStructItemsRange : public TupleStructItems\n class TupleStructPattern : public Pattern\n {\n   PathInExpression path;\n-  // TupleStructItems items;\n-  ::std::unique_ptr<TupleStructItems> items;\n+  std::unique_ptr<TupleStructItems> items;\n \n-  // TOOD: should this store location data? current accessor uses path location\n-  // data\n+  /* TOOD: should this store location data? current accessor uses path location\n+   * data */\n \n public:\n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   TupleStructPattern (PathInExpression tuple_struct_path,\n-\t\t      ::std::unique_ptr<TupleStructItems> items)\n-    : path (::std::move (tuple_struct_path)), items (::std::move (items))\n+\t\t      std::unique_ptr<TupleStructItems> items)\n+    : path (std::move (tuple_struct_path)), items (std::move (items))\n   {}\n \n   // Copy constructor required to clone\n   TupleStructPattern (TupleStructPattern const &other)\n     : path (other.path), items (other.items->clone_tuple_struct_items ())\n   {}\n \n-  // Destructor - define here if required\n-\n   // Operator overload assignment operator to clone\n   TupleStructPattern &operator= (TupleStructPattern const &other)\n   {\n@@ -929,12 +812,12 @@ class TupleStructPattern : public Pattern\n \n   Location get_locus () const { return path.get_locus (); }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TupleStructPattern *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructPattern *clone_pattern_impl () const override\n   {\n     return new TupleStructPattern (*this);\n   }\n@@ -949,13 +832,13 @@ class TuplePatternItems\n   // TODO: should this store location data?\n \n   // Unique pointer custom clone function\n-  ::std::unique_ptr<TuplePatternItems> clone_tuple_pattern_items () const\n+  std::unique_ptr<TuplePatternItems> clone_tuple_pattern_items () const\n   {\n-    return ::std::unique_ptr<TuplePatternItems> (\n+    return std::unique_ptr<TuplePatternItems> (\n       clone_tuple_pattern_items_impl ());\n   }\n \n-  virtual ::std::string as_string () const = 0;\n+  virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n@@ -967,7 +850,7 @@ class TuplePatternItems\n // Class representing TuplePattern patterns where there is only a single pattern\n /*class TuplePatternItemsSingle : public TuplePatternItems {\n     // Pattern pattern;\n-    ::std::unique_ptr<Pattern> pattern;\n+    std::unique_ptr<Pattern> pattern;\n \n   public:\n     TuplePatternItemsSingle(Pattern* pattern) : pattern(pattern) {}\n@@ -993,7 +876,7 @@ default;\n   protected:\n     // Use covariance to implement clone function as returning this object\n rather than base virtual TuplePatternItemsSingle*\n-clone_tuple_pattern_items_impl() const OVERRIDE { return new\n+clone_tuple_pattern_items_impl() const override { return new\n TuplePatternItemsSingle(*this);\n     }\n };*/\n@@ -1002,39 +885,27 @@ TuplePatternItemsSingle(*this);\n // Class representing TuplePattern patterns where there are multiple patterns\n class TuplePatternItemsMultiple : public TuplePatternItems\n {\n-  //::std::vector<Pattern> patterns;\n-  ::std::vector< ::std::unique_ptr<Pattern> > patterns;\n+  std::vector<std::unique_ptr<Pattern>> patterns;\n \n public:\n-  TuplePatternItemsMultiple (\n-    ::std::vector< ::std::unique_ptr<Pattern> > patterns)\n-    : patterns (::std::move (patterns))\n+  TuplePatternItemsMultiple (std::vector<std::unique_ptr<Pattern>> patterns)\n+    : patterns (std::move (patterns))\n   {}\n \n   // Copy constructor with vector clone\n   TuplePatternItemsMultiple (TuplePatternItemsMultiple const &other)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     patterns.reserve (other.patterns.size ());\n-\n     for (const auto &e : other.patterns)\n-      {\n-\tpatterns.push_back (e->clone_pattern ());\n-      }\n+      patterns.push_back (e->clone_pattern ());\n   }\n \n   // Overloaded assignment operator to vector clone\n   TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple const &other)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     patterns.reserve (other.patterns.size ());\n-\n     for (const auto &e : other.patterns)\n-      {\n-\tpatterns.push_back (e->clone_pattern ());\n-      }\n+      patterns.push_back (e->clone_pattern ());\n \n     return *this;\n   }\n@@ -1044,15 +915,14 @@ class TuplePatternItemsMultiple : public TuplePatternItems\n   TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple &&other)\n     = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TuplePatternItemsMultiple *\n-  clone_tuple_pattern_items_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePatternItemsMultiple *clone_tuple_pattern_items_impl () const override\n   {\n     return new TuplePatternItemsMultiple (*this);\n   }\n@@ -1061,61 +931,39 @@ class TuplePatternItemsMultiple : public TuplePatternItems\n // Class representing TuplePattern patterns where there are a range of patterns\n class TuplePatternItemsRanged : public TuplePatternItems\n {\n-  /*::std::vector<Pattern> lower_patterns;\n-  ::std::vector<Pattern> upper_patterns;*/\n-  ::std::vector< ::std::unique_ptr<Pattern> > lower_patterns;\n-  ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns;\n+  std::vector<std::unique_ptr<Pattern>> lower_patterns;\n+  std::vector<std::unique_ptr<Pattern>> upper_patterns;\n \n public:\n   TuplePatternItemsRanged (\n-    ::std::vector< ::std::unique_ptr<Pattern> > lower_patterns,\n-    ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns)\n-    : lower_patterns (::std::move (lower_patterns)),\n-      upper_patterns (::std::move (upper_patterns))\n+    std::vector<std::unique_ptr<Pattern>> lower_patterns,\n+    std::vector<std::unique_ptr<Pattern>> upper_patterns)\n+    : lower_patterns (std::move (lower_patterns)),\n+      upper_patterns (std::move (upper_patterns))\n   {}\n \n   // Copy constructor with vector clone\n   TuplePatternItemsRanged (TuplePatternItemsRanged const &other)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     lower_patterns.reserve (other.lower_patterns.size ());\n-\n     for (const auto &e : other.lower_patterns)\n-      {\n-\tlower_patterns.push_back (e->clone_pattern ());\n-      }\n+      lower_patterns.push_back (e->clone_pattern ());\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     upper_patterns.reserve (other.upper_patterns.size ());\n-\n     for (const auto &e : other.upper_patterns)\n-      {\n-\tupper_patterns.push_back (e->clone_pattern ());\n-      }\n+      upper_patterns.push_back (e->clone_pattern ());\n   }\n \n   // Overloaded assignment operator to clone\n   TuplePatternItemsRanged &operator= (TuplePatternItemsRanged const &other)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     lower_patterns.reserve (other.lower_patterns.size ());\n-\n     for (const auto &e : other.lower_patterns)\n-      {\n-\tlower_patterns.push_back (e->clone_pattern ());\n-      }\n+      lower_patterns.push_back (e->clone_pattern ());\n \n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     upper_patterns.reserve (other.upper_patterns.size ());\n-\n     for (const auto &e : other.upper_patterns)\n-      {\n-\tupper_patterns.push_back (e->clone_pattern ());\n-      }\n+      upper_patterns.push_back (e->clone_pattern ());\n \n     return *this;\n   }\n@@ -1125,15 +973,14 @@ class TuplePatternItemsRanged : public TuplePatternItems\n   TuplePatternItemsRanged &operator= (TuplePatternItemsRanged &&other)\n     = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TuplePatternItemsRanged *\n-  clone_tuple_pattern_items_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePatternItemsRanged *clone_tuple_pattern_items_impl () const override\n   {\n     return new TuplePatternItemsRanged (*this);\n   }\n@@ -1143,28 +990,25 @@ class TuplePatternItemsRanged : public TuplePatternItems\n class TuplePattern : public Pattern\n {\n   // bool has_tuple_pattern_items;\n-  // TuplePatternItems items;\n-  ::std::unique_ptr<TuplePatternItems> items;\n+  std::unique_ptr<TuplePatternItems> items;\n \n   Location locus;\n \n public:\n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   // Returns true if the tuple pattern has items\n-  inline bool has_tuple_pattern_items () const { return items != NULL; }\n+  bool has_tuple_pattern_items () const { return items != nullptr; }\n \n-  TuplePattern (::std::unique_ptr<TuplePatternItems> items, Location locus)\n-    : items (::std::move (items)), locus (locus)\n+  TuplePattern (std::unique_ptr<TuplePatternItems> items, Location locus)\n+    : items (std::move (items)), locus (locus)\n   {}\n \n   // Copy constructor requires clone\n   TuplePattern (TuplePattern const &other)\n     : items (other.items->clone_tuple_pattern_items ()), locus (other.locus)\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overload assignment operator to clone\n   TuplePattern &operator= (TuplePattern const &other)\n   {\n@@ -1176,12 +1020,12 @@ class TuplePattern : public Pattern\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TuplePattern *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePattern *clone_pattern_impl () const override\n   {\n     return new TuplePattern (*this);\n   }\n@@ -1190,19 +1034,17 @@ class TuplePattern : public Pattern\n // AST node representing a pattern in parentheses, used to control precedence\n class GroupedPattern : public Pattern\n {\n-  // Pattern pattern_in_parens;\n-  ::std::unique_ptr<Pattern> pattern_in_parens;\n-\n+  std::unique_ptr<Pattern> pattern_in_parens;\n   Location locus;\n \n public:\n-  ::std::string as_string () const\n+  std::string as_string () const override\n   {\n     return \"(\" + pattern_in_parens->as_string () + \")\";\n   }\n \n-  GroupedPattern (::std::unique_ptr<Pattern> pattern_in_parens, Location locus)\n-    : pattern_in_parens (::std::move (pattern_in_parens)), locus (locus)\n+  GroupedPattern (std::unique_ptr<Pattern> pattern_in_parens, Location locus)\n+    : pattern_in_parens (std::move (pattern_in_parens)), locus (locus)\n   {}\n \n   // Copy constructor uses clone\n@@ -1211,8 +1053,6 @@ class GroupedPattern : public Pattern\n       locus (other.locus)\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overload assignment operator to clone\n   GroupedPattern &operator= (GroupedPattern const &other)\n   {\n@@ -1228,12 +1068,12 @@ class GroupedPattern : public Pattern\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual GroupedPattern *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  GroupedPattern *clone_pattern_impl () const override\n   {\n     return new GroupedPattern (*this);\n   }\n@@ -1242,44 +1082,32 @@ class GroupedPattern : public Pattern\n // AST node representing patterns that can match slices and arrays\n class SlicePattern : public Pattern\n {\n-  //::std::vector<Pattern> items;\n-  ::std::vector< ::std::unique_ptr<Pattern> > items;\n-\n+  std::vector<std::unique_ptr<Pattern>> items;\n   Location locus;\n \n public:\n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  SlicePattern (::std::vector< ::std::unique_ptr<Pattern> > items,\n-\t\tLocation locus)\n-    : items (::std::move (items)), locus (locus)\n+  SlicePattern (std::vector<std::unique_ptr<Pattern>> items, Location locus)\n+    : items (std::move (items)), locus (locus)\n   {}\n \n   // Copy constructor with vector clone\n   SlicePattern (SlicePattern const &other) : locus (other.locus)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     items.reserve (other.items.size ());\n-\n     for (const auto &e : other.items)\n-      {\n-\titems.push_back (e->clone_pattern ());\n-      }\n+      items.push_back (e->clone_pattern ());\n   }\n \n   // Overloaded assignment operator to vector clone\n   SlicePattern &operator= (SlicePattern const &other)\n   {\n     locus = other.locus;\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n-    items.reserve (other.items.size ());\n \n+    items.reserve (other.items.size ());\n     for (const auto &e : other.items)\n-      {\n-\titems.push_back (e->clone_pattern ());\n-      }\n+      items.push_back (e->clone_pattern ());\n \n     return *this;\n   }\n@@ -1290,20 +1118,17 @@ class SlicePattern : public Pattern\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual SlicePattern *clone_pattern_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SlicePattern *clone_pattern_impl () const override\n   {\n     return new SlicePattern (*this);\n   }\n };\n \n-// forward decl PathExprSegment\n-// class PathExprSegment;\n-\n // Moved definition to rust-path.h\n class PathPattern;\n \n@@ -1313,10 +1138,6 @@ class QualifiedPathInExpression;\n \n // Replaced with forward decl - defined in rust-macro.h\n class MacroInvocation;\n-/*class MacroInvocation : public Pattern {\n-  public:\n-    ::std::string as_string() const;\n-};*/\n } // namespace AST\n } // namespace Rust\n "}, {"sha": "89b4d87921b7b053956cd7d25973aee3f82d67d6", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 49, "deletions": 96, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -13,82 +13,57 @@ class EmptyStmt : public Stmt\n   Location locus;\n \n public:\n-  ::std::string as_string () const { return ::std::string (1, ';'); }\n+  std::string as_string () const override { return std::string (1, ';'); }\n \n   EmptyStmt (Location locus) : locus (locus) {}\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual EmptyStmt *clone_stmt_impl () const OVERRIDE\n-  {\n-    return new EmptyStmt (*this);\n-  }\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  EmptyStmt *clone_stmt_impl () const override { return new EmptyStmt (*this); }\n };\n \n-/* This is syntactically identical to declaring an item inside a module BUT it\n- * has block scope. Type of \"declaration statement\" as it introduces new name\n- * into scope */\n-/*class ItemStatement : public Statement {\n-    // TODO: put in same params as regular item\n-    // maybe even merge data structure with module item?\n-\n-  public:\n-    ::std::string as_string() const;\n-};*/\n-// removed - just made item inherit from statement\n-\n /* Variable assignment let statement - type of \"declaration statement\" as it\n  * introduces new name into scope */\n class LetStmt : public Stmt\n {\n public:\n   // bool has_outer_attrs;\n-  ::std::vector<Attribute> outer_attrs;\n+  std::vector<Attribute> outer_attrs;\n \n-  // Pattern variables_pattern;\n-  ::std::unique_ptr<Pattern> variables_pattern;\n+  std::unique_ptr<Pattern> variables_pattern;\n \n   // bool has_type;\n-  // Type type;\n-  ::std::unique_ptr<Type> type;\n+  std::unique_ptr<Type> type;\n \n   // bool has_init_expr;\n-  // Expr* init_expr;\n-  ::std::unique_ptr<Expr> init_expr;\n+  std::unique_ptr<Expr> init_expr;\n \n   Location locus;\n \n   Type *inferedType;\n \n   // Returns whether let statement has outer attributes.\n-  inline bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n \n   // Returns whether let statement has a given return type.\n-  inline bool has_type () const { return type != NULL; }\n+  bool has_type () const { return type != nullptr; }\n \n   // Returns whether let statement has an initialisation expression.\n-  inline bool has_init_expr () const { return init_expr != NULL; }\n-\n-  /*~LetStatement() {\n-      if (has_init_expr) {\n-\t  delete init_expr;\n-      }\n-  }*/\n-\n-  ::std::string as_string () const;\n-\n-  LetStmt (::std::unique_ptr<Pattern> variables_pattern,\n-\t   ::std::unique_ptr<Expr> init_expr, ::std::unique_ptr<Type> type,\n-\t   ::std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (::std::move (outer_attrs)),\n-      variables_pattern (::std::move (variables_pattern)),\n-      type (::std::move (type)), init_expr (::std::move (init_expr)),\n-      locus (locus)\n+  bool has_init_expr () const { return init_expr != nullptr; }\n+\n+  std::string as_string () const override;\n+\n+  LetStmt (std::unique_ptr<Pattern> variables_pattern,\n+\t   std::unique_ptr<Expr> init_expr, std::unique_ptr<Type> type,\n+\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)),\n+      variables_pattern (std::move (variables_pattern)),\n+      type (std::move (type)), init_expr (std::move (init_expr)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n@@ -99,8 +74,6 @@ class LetStmt : public Stmt\n       init_expr (other.init_expr->clone_expr ()), locus (other.locus)\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overloaded assignment operator to clone\n   LetStmt &operator= (LetStmt const &other)\n   {\n@@ -119,19 +92,16 @@ class LetStmt : public Stmt\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual LetStmt *clone_stmt_impl () const OVERRIDE\n-  {\n-    return new LetStmt (*this);\n-  }\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  LetStmt *clone_stmt_impl () const override { return new LetStmt (*this); }\n };\n \n-// Abstract base class for expression statements (statements containing an\n-// expression)\n+/* Abstract base class for expression statements (statements containing an\n+ * expression) */\n class ExprStmt : public Stmt\n {\n   // TODO: add any useful virtual functions\n@@ -154,28 +124,22 @@ class ExprStmtWithoutBlock : public ExprStmt\n   /* HACK: cannot ensure type safety of ExprWithoutBlock due to Pratt parsing,\n    * so have to store more general type of Expr. FIXME: fix this issue somehow\n    * or redesign AST. */\n-  //::std::unique_ptr<ExprWithoutBlock> expr;\n-  ::std::unique_ptr<Expr> expr;\n-\n-  /*~ExpressionStatementWithoutBlock() {\n-      delete expr;\n-  }*/\n+  // std::unique_ptr<ExprWithoutBlock> expr;\n+  std::unique_ptr<Expr> expr;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  // ExprStmtWithoutBlock(::std::unique_ptr<ExprWithoutBlock> expr) :\n-  // expr(::std::move(expr)) {}\n-  ExprStmtWithoutBlock (::std::unique_ptr<Expr> expr, Location locus)\n-    : ExprStmt (locus), expr (::std::move (expr))\n+  // ExprStmtWithoutBlock(std::unique_ptr<ExprWithoutBlock> expr) :\n+  // expr(std::move(expr)) {}\n+  ExprStmtWithoutBlock (std::unique_ptr<Expr> expr, Location locus)\n+    : ExprStmt (locus), expr (std::move (expr))\n   {}\n \n   // Copy constructor with clone\n   ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n     : ExprStmt (other), expr (other.expr->clone_expr /*_without_block*/ ())\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overloaded assignment operator to clone\n   ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock const &other)\n   {\n@@ -189,12 +153,12 @@ class ExprStmtWithoutBlock : public ExprStmt\n   ExprStmtWithoutBlock (ExprStmtWithoutBlock &&other) = default;\n   ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock &&other) = default;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ExprStmtWithoutBlock *clone_stmt_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ExprStmtWithoutBlock *clone_stmt_impl () const override\n   {\n     return new ExprStmtWithoutBlock (*this);\n   }\n@@ -204,28 +168,21 @@ class ExprStmtWithoutBlock : public ExprStmt\n class ExprStmtWithBlock : public ExprStmt\n {\n public:\n-  // ExprWithBlock* expr;\n-  ::std::unique_ptr<ExprWithBlock> expr;\n-\n-  /*~ExpressionStatementWithBlock() {\n-      delete expr;\n-  }*/\n+  std::unique_ptr<ExprWithBlock> expr;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n-  ::std::vector<LetStmt *> locals;\n+  std::vector<LetStmt *> locals;\n \n-  ExprStmtWithBlock (::std::unique_ptr<ExprWithBlock> expr, Location locus)\n-    : ExprStmt (locus), expr (::std::move (expr))\n+  ExprStmtWithBlock (std::unique_ptr<ExprWithBlock> expr, Location locus)\n+    : ExprStmt (locus), expr (std::move (expr))\n   {}\n \n   // Copy constructor with clone\n   ExprStmtWithBlock (ExprStmtWithBlock const &other)\n     : ExprStmt (other), expr (other.expr->clone_expr_with_block ())\n   {}\n \n-  // Destructor - define here if required\n-\n   // Overloaded assignment operator to clone\n   ExprStmtWithBlock &operator= (ExprStmtWithBlock const &other)\n   {\n@@ -239,24 +196,20 @@ class ExprStmtWithBlock : public ExprStmt\n   ExprStmtWithBlock (ExprStmtWithBlock &&other) = default;\n   ExprStmtWithBlock &operator= (ExprStmtWithBlock &&other) = default;\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ExprStmtWithBlock *clone_stmt_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ExprStmtWithBlock *clone_stmt_impl () const override\n   {\n     return new ExprStmtWithBlock (*this);\n   }\n };\n \n-// Replaced definition of MacroInvocationSemi with forward decl - defined in\n-// rust-macro.h\n+/* Replaced definition of MacroInvocationSemi with forward decl - defined in\n+ * rust-macro.h */\n class MacroInvocationSemi;\n-/*class MacroInvocationSemi : public Statement {\n-  public:\n-    ::std::string as_string() const;\n-};*/\n } // namespace AST\n } // namespace Rust\n "}, {"sha": "b396a44edb4a269a481575f5302160e9b5cecf18", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 179, "deletions": 259, "changes": 438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -18,34 +18,35 @@ class TraitBound : public TypeParamBound\n \n   // bool has_for_lifetimes;\n   // LifetimeParams for_lifetimes;\n-  ::std::vector<LifetimeParam> for_lifetimes; // inlined LifetimeParams\n+  std::vector<LifetimeParam> for_lifetimes; // inlined LifetimeParams\n \n   TypePath type_path;\n \n   Location locus;\n \n public:\n   // Returns whether trait bound has \"for\" lifetimes\n-  inline bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+  bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n \n   TraitBound (TypePath type_path, Location locus, bool in_parens = false,\n \t      bool opening_question_mark = false,\n-\t      ::std::vector<LifetimeParam> for_lifetimes\n-\t      = ::std::vector<LifetimeParam> ())\n+\t      std::vector<LifetimeParam> for_lifetimes\n+\t      = std::vector<LifetimeParam> ())\n     : in_parens (in_parens), opening_question_mark (opening_question_mark),\n-      for_lifetimes (::std::move (for_lifetimes)),\n-      type_path (::std::move (type_path)), locus (locus)\n+      for_lifetimes (std::move (for_lifetimes)),\n+      type_path (std::move (type_path)), locus (locus)\n   {}\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Clone function implementation as (not pure) virtual method\n-  virtual TraitBound *clone_type_param_bound_impl () const\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitBound *clone_type_param_bound_impl () const override\n   {\n     return new TraitBound (*this);\n   }\n@@ -58,51 +59,42 @@ class TypeNoBounds;\n class ImplTraitType : public Type\n {\n   // TypeParamBounds type_param_bounds;\n-  ::std::vector< ::std::unique_ptr<TypeParamBound> >\n-    type_param_bounds; // inlined form\n+  // inlined form\n+  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n \n   Location locus;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ImplTraitType *clone_type_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitType *clone_type_impl () const override\n   {\n     return new ImplTraitType (*this);\n   }\n \n public:\n   ImplTraitType (\n-    ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n+    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n     Location locus)\n-    : type_param_bounds (::std::move (type_param_bounds)), locus (locus)\n+    : type_param_bounds (std::move (type_param_bounds)), locus (locus)\n   {}\n \n   // copy constructor with vector clone\n   ImplTraitType (ImplTraitType const &other) : locus (other.locus)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n-\n     for (const auto &e : other.type_param_bounds)\n-      {\n-\ttype_param_bounds.push_back (e->clone_type_param_bound ());\n-      }\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n   }\n \n   // overloaded assignment operator to clone\n   ImplTraitType &operator= (ImplTraitType const &other)\n   {\n     locus = other.locus;\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n-    type_param_bounds.reserve (other.type_param_bounds.size ());\n \n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n-      {\n-\ttype_param_bounds.push_back (e->clone_type_param_bound ());\n-      }\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n \n     return *this;\n   }\n@@ -111,66 +103,56 @@ class ImplTraitType : public Type\n   ImplTraitType (ImplTraitType &&other) = default;\n   ImplTraitType &operator= (ImplTraitType &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n };\n \n // An opaque value of another type that implements a set of traits\n class TraitObjectType : public Type\n {\n   bool has_dyn;\n   // TypeParamBounds type_param_bounds;\n-  ::std::vector< ::std::unique_ptr<TypeParamBound> >\n+  std::vector<std::unique_ptr<TypeParamBound>>\n     type_param_bounds; // inlined form\n \n   Location locus;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TraitObjectType *clone_type_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectType *clone_type_impl () const override\n   {\n     return new TraitObjectType (*this);\n   }\n \n public:\n   TraitObjectType (\n-    ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n+    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n     Location locus, bool is_dyn_dispatch = false)\n     : has_dyn (is_dyn_dispatch),\n-      type_param_bounds (::std::move (type_param_bounds)), locus (locus)\n+      type_param_bounds (std::move (type_param_bounds)), locus (locus)\n   {}\n \n   // copy constructor with vector clone\n   TraitObjectType (TraitObjectType const &other)\n     : has_dyn (other.has_dyn), locus (other.locus)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n-\n     for (const auto &e : other.type_param_bounds)\n-      {\n-\ttype_param_bounds.push_back (e->clone_type_param_bound ());\n-      }\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n   }\n \n   // overloaded assignment operator to clone\n   TraitObjectType &operator= (TraitObjectType const &other)\n   {\n     has_dyn = other.has_dyn;\n     locus = other.locus;\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n-\n     for (const auto &e : other.type_param_bounds)\n-      {\n-\ttype_param_bounds.push_back (e->clone_type_param_bound ());\n-      }\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n \n     return *this;\n   }\n@@ -179,50 +161,46 @@ class TraitObjectType : public Type\n   TraitObjectType (TraitObjectType &&other) = default;\n   TraitObjectType &operator= (TraitObjectType &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n };\n \n // A type with parentheses around it, used to avoid ambiguity.\n class ParenthesisedType : public TypeNoBounds\n {\n-  // Type type_in_parens;\n-  ::std::unique_ptr<Type> type_in_parens;\n-\n+  std::unique_ptr<Type> type_in_parens;\n   Location locus;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ParenthesisedType *clone_type_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ParenthesisedType *clone_type_impl () const override\n   {\n     return new ParenthesisedType (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ParenthesisedType *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ParenthesisedType *clone_type_no_bounds_impl () const override\n   {\n     return new ParenthesisedType (*this);\n   }\n \n public:\n   // Constructor uses Type pointer for polymorphism\n-  ParenthesisedType (::std::unique_ptr<Type> type_inside_parens, Location locus)\n-    : type_in_parens (::std::move (type_inside_parens)), locus (locus)\n+  ParenthesisedType (std::unique_ptr<Type> type_inside_parens, Location locus)\n+    : type_in_parens (std::move (type_inside_parens)), locus (locus)\n   {}\n \n-  // Copy constructor uses custom deep copy method for type to preserve\n-  // polymorphism\n+  /* Copy constructor uses custom deep copy method for type to preserve\n+   * polymorphism */\n   ParenthesisedType (ParenthesisedType const &other)\n     : type_in_parens (other.type_in_parens->clone_type ()), locus (other.locus)\n   {}\n \n-  // define destructor here if required\n-\n   // overload assignment operator to use custom clone method\n   ParenthesisedType &operator= (ParenthesisedType const &other)\n   {\n@@ -235,14 +213,13 @@ class ParenthesisedType : public TypeNoBounds\n   ParenthesisedType (ParenthesisedType &&other) = default;\n   ParenthesisedType &operator= (ParenthesisedType &&other) = default;\n \n-  ::std::string as_string () const\n+  std::string as_string () const override\n   {\n     return \"(\" + type_in_parens->as_string () + \")\";\n   }\n \n   // Creates a trait bound (clone of this one's trait bound) - HACK\n-  virtual TraitBound *\n-  to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const OVERRIDE\n+  TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const override\n   {\n     /* NOTE: obviously it is unknown whether the internal type is a trait bound\n      * due to polymorphism, so just let the internal type handle it. As\n@@ -252,7 +229,7 @@ class ParenthesisedType : public TypeNoBounds\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n };\n \n // Impl trait with a single bound? Poor reference material here.\n@@ -263,30 +240,30 @@ class ImplTraitTypeOneBound : public TypeNoBounds\n   Location locus;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ImplTraitTypeOneBound *clone_type_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitTypeOneBound *clone_type_impl () const override\n   {\n     return new ImplTraitTypeOneBound (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ImplTraitTypeOneBound *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitTypeOneBound *clone_type_no_bounds_impl () const override\n   {\n     return new ImplTraitTypeOneBound (*this);\n   }\n \n public:\n   ImplTraitTypeOneBound (TraitBound trait_bound, Location locus)\n-    : trait_bound (::std::move (trait_bound)), locus (locus)\n+    : trait_bound (std::move (trait_bound)), locus (locus)\n   {}\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n };\n \n /* A trait object with a single trait bound. The \"trait bound\" is really just\n@@ -299,32 +276,31 @@ class TraitObjectTypeOneBound : public TypeNoBounds\n   Location locus;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TraitObjectTypeOneBound *clone_type_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectTypeOneBound *clone_type_impl () const override\n   {\n     return new TraitObjectTypeOneBound (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TraitObjectTypeOneBound *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectTypeOneBound *clone_type_no_bounds_impl () const override\n   {\n     return new TraitObjectTypeOneBound (*this);\n   }\n \n public:\n   TraitObjectTypeOneBound (TraitBound trait_bound, Location locus,\n \t\t\t   bool is_dyn_dispatch = false)\n-    : has_dyn (is_dyn_dispatch), trait_bound (::std::move (trait_bound)),\n+    : has_dyn (is_dyn_dispatch), trait_bound (std::move (trait_bound)),\n       locus (locus)\n   {}\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   // Creates a trait bound (clone of this one's trait bound) - HACK\n-  virtual TraitBound *\n-  to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const OVERRIDE\n+  TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const override\n   {\n     /* NOTE: this assumes there is no dynamic dispatch specified- if there was,\n      * this cloning would not be required as parsing is unambiguous. */\n@@ -333,53 +309,42 @@ class TraitObjectTypeOneBound : public TypeNoBounds\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n };\n \n class TypePath; // definition moved to \"rust-path.h\"\n \n-// A type consisting of the \"product\" of others (the tuple's elements) in a\n-// specific order\n+/* A type consisting of the \"product\" of others (the tuple's elements) in a\n+ * specific order */\n class TupleType : public TypeNoBounds\n {\n-  //::std::vector<Type> elems;\n-  ::std::vector< ::std::unique_ptr<Type> > elems;\n-\n+  std::vector<std::unique_ptr<Type>> elems;\n   Location locus;\n \n public:\n   // Returns whether the tuple type is the unit type, i.e. has no elements.\n-  inline bool is_unit_type () const { return elems.empty (); }\n+  bool is_unit_type () const { return elems.empty (); }\n \n-  TupleType (::std::vector< ::std::unique_ptr<Type> > elems, Location locus)\n-    : elems (::std::move (elems)), locus (locus)\n+  TupleType (std::vector<std::unique_ptr<Type>> elems, Location locus)\n+    : elems (std::move (elems)), locus (locus)\n   {}\n \n   // copy constructor with vector clone\n   TupleType (TupleType const &other) : locus (other.locus)\n   {\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n     elems.reserve (other.elems.size ());\n-\n     for (const auto &e : other.elems)\n-      {\n-\telems.push_back (e->clone_type ());\n-      }\n+      elems.push_back (e->clone_type ());\n   }\n \n   // overloaded assignment operator to clone\n   TupleType &operator= (TupleType const &other)\n   {\n     locus = other.locus;\n-    // crappy vector unique pointer clone - TODO is there a better way of doing\n-    // this?\n-    elems.reserve (other.elems.size ());\n \n+    elems.reserve (other.elems.size ());\n     for (const auto &e : other.elems)\n-      {\n-\telems.push_back (e->clone_type ());\n-      }\n+      elems.push_back (e->clone_type ());\n \n     return *this;\n   }\n@@ -388,23 +353,20 @@ class TupleType : public TypeNoBounds\n   TupleType (TupleType &&other) = default;\n   TupleType &operator= (TupleType &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TupleType *clone_type_impl () const OVERRIDE\n-  {\n-    return new TupleType (*this);\n-  }\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleType *clone_type_impl () const override { return new TupleType (*this); }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual TupleType *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleType *clone_type_no_bounds_impl () const override\n   {\n     return new TupleType (*this);\n   }\n@@ -418,28 +380,25 @@ class NeverType : public TypeNoBounds\n   Location locus;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual NeverType *clone_type_impl () const OVERRIDE\n-  {\n-    return new NeverType (*this);\n-  }\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  NeverType *clone_type_impl () const override { return new NeverType (*this); }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual NeverType *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  NeverType *clone_type_no_bounds_impl () const override\n   {\n     return new NeverType (*this);\n   }\n \n public:\n   NeverType (Location locus) : locus (locus) {}\n \n-  ::std::string as_string () const { return \"! (never type)\"; }\n+  std::string as_string () const override { return \"! (never type)\"; }\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n };\n \n // A type consisting of a pointer without safety or liveness guarantees\n@@ -454,21 +413,17 @@ class RawPointerType : public TypeNoBounds\n \n private:\n   PointerType pointer_type;\n-\n-  // TypeNoBounds type;\n-  ::std::unique_ptr<TypeNoBounds> type;\n-\n+  std::unique_ptr<TypeNoBounds> type;\n   Location locus;\n \n public:\n   // Returns whether the pointer is mutable or constant.\n-  inline PointerType get_pointer_type () const { return pointer_type; }\n+  PointerType get_pointer_type () const { return pointer_type; }\n \n   // Constructor requires pointer for polymorphism reasons\n   RawPointerType (PointerType pointer_type,\n-\t\t  ::std::unique_ptr<TypeNoBounds> type_no_bounds,\n-\t\t  Location locus)\n-    : pointer_type (pointer_type), type (::std::move (type_no_bounds)),\n+\t\t  std::unique_ptr<TypeNoBounds> type_no_bounds, Location locus)\n+    : pointer_type (pointer_type), type (std::move (type_no_bounds)),\n       locus (locus)\n   {}\n \n@@ -478,8 +433,6 @@ class RawPointerType : public TypeNoBounds\n       type (other.type->clone_type_no_bounds ()), locus (other.locus)\n   {}\n \n-  // no destructor required?\n-\n   // overload assignment operator to use custom clone method\n   RawPointerType &operator= (RawPointerType const &other)\n   {\n@@ -493,23 +446,23 @@ class RawPointerType : public TypeNoBounds\n   RawPointerType (RawPointerType &&other) = default;\n   RawPointerType &operator= (RawPointerType &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual RawPointerType *clone_type_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RawPointerType *clone_type_impl () const override\n   {\n     return new RawPointerType (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual RawPointerType *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RawPointerType *clone_type_no_bounds_impl () const override\n   {\n     return new RawPointerType (*this);\n   }\n@@ -522,24 +475,21 @@ class ReferenceType : public TypeNoBounds\n   Lifetime lifetime;\n \n   bool has_mut;\n-\n-  // TypeNoBounds type;\n-  ::std::unique_ptr<TypeNoBounds> type;\n-\n+  std::unique_ptr<TypeNoBounds> type;\n   Location locus;\n \n public:\n   // Returns whether the reference is mutable or immutable.\n-  inline bool is_mut () const { return has_mut; }\n+  bool is_mut () const { return has_mut; }\n \n   // Returns whether the reference has a lifetime.\n-  inline bool has_lifetime () const { return !lifetime.is_error (); }\n+  bool has_lifetime () const { return !lifetime.is_error (); }\n \n   // Constructor\n-  ReferenceType (bool is_mut, ::std::unique_ptr<TypeNoBounds> type_no_bounds,\n+  ReferenceType (bool is_mut, std::unique_ptr<TypeNoBounds> type_no_bounds,\n \t\t Location locus, Lifetime lifetime = Lifetime::error ())\n-    : lifetime (::std::move (lifetime)), has_mut (is_mut),\n-      type (::std::move (type_no_bounds)), locus (locus)\n+    : lifetime (std::move (lifetime)), has_mut (is_mut),\n+      type (std::move (type_no_bounds)), locus (locus)\n   {}\n \n   // Copy constructor with custom clone method\n@@ -548,8 +498,6 @@ class ReferenceType : public TypeNoBounds\n       type (other.type->clone_type_no_bounds ()), locus (other.locus)\n   {}\n \n-  // Destructor not required?\n-\n   // Operator overload assignment operator to custom clone the unique pointer\n   ReferenceType &operator= (ReferenceType const &other)\n   {\n@@ -565,23 +513,23 @@ class ReferenceType : public TypeNoBounds\n   ReferenceType (ReferenceType &&other) = default;\n   ReferenceType &operator= (ReferenceType &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ReferenceType *clone_type_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferenceType *clone_type_impl () const override\n   {\n     return new ReferenceType (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ReferenceType *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferenceType *clone_type_no_bounds_impl () const override\n   {\n     return new ReferenceType (*this);\n   }\n@@ -590,19 +538,15 @@ class ReferenceType : public TypeNoBounds\n // A fixed-size sequence of elements of a specified type\n class ArrayType : public TypeNoBounds\n {\n-  // Type elem_type;\n-  ::std::unique_ptr<Type> elem_type;\n-  // Expr* size;\n-  ::std::unique_ptr<Expr> size;\n-\n+  std::unique_ptr<Type> elem_type;\n+  std::unique_ptr<Expr> size;\n   Location locus;\n \n public:\n   // Constructor requires pointers for polymorphism\n-  ArrayType (::std::unique_ptr<Type> type, ::std::unique_ptr<Expr> array_size,\n+  ArrayType (std::unique_ptr<Type> type, std::unique_ptr<Expr> array_size,\n \t     Location locus)\n-    : elem_type (::std::move (type)), size (::std::move (array_size)),\n-      locus (locus)\n+    : elem_type (std::move (type)), size (std::move (array_size)), locus (locus)\n   {}\n \n   // Copy constructor requires deep copies of both unique pointers\n@@ -611,8 +555,6 @@ class ArrayType : public TypeNoBounds\n       size (other.size->clone_expr ()), locus (other.locus)\n   {}\n \n-  // destructor not required?\n-\n   // Overload assignment operator to deep copy pointers\n   ArrayType &operator= (ArrayType const &other)\n   {\n@@ -626,53 +568,43 @@ class ArrayType : public TypeNoBounds\n   ArrayType (ArrayType &&other) = default;\n   ArrayType &operator= (ArrayType &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n-  /*~ArrayType() {\n-      delete size;\n-  }*/\n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ArrayType *clone_type_impl () const OVERRIDE\n-  {\n-    return new ArrayType (*this);\n-  }\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ArrayType *clone_type_impl () const override { return new ArrayType (*this); }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual ArrayType *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ArrayType *clone_type_no_bounds_impl () const override\n   {\n     return new ArrayType (*this);\n   }\n };\n \n-// A dynamically-sized type representing a \"view\" into a sequence of elements of\n-// a type\n+/* A dynamically-sized type representing a \"view\" into a sequence of elements of\n+ * a type */\n class SliceType : public TypeNoBounds\n {\n-  // Type elem_type;\n-  ::std::unique_ptr<Type> elem_type;\n-\n+  std::unique_ptr<Type> elem_type;\n   Location locus;\n \n public:\n   // Constructor requires pointer for polymorphism\n-  SliceType (::std::unique_ptr<Type> type, Location locus)\n-    : elem_type (::std::move (type)), locus (locus)\n+  SliceType (std::unique_ptr<Type> type, Location locus)\n+    : elem_type (std::move (type)), locus (locus)\n   {}\n \n   // Copy constructor requires deep copy of Type smart pointer\n   SliceType (SliceType const &other)\n     : elem_type (other.elem_type->clone_type ()), locus (other.locus)\n   {}\n \n-  // destructor not required?\n-\n   // Overload assignment operator to deep copy\n   SliceType &operator= (SliceType const &other)\n   {\n@@ -686,58 +618,55 @@ class SliceType : public TypeNoBounds\n   SliceType (SliceType &&other) = default;\n   SliceType &operator= (SliceType &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual SliceType *clone_type_impl () const OVERRIDE\n-  {\n-    return new SliceType (*this);\n-  }\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SliceType *clone_type_impl () const override { return new SliceType (*this); }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual SliceType *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SliceType *clone_type_no_bounds_impl () const override\n   {\n     return new SliceType (*this);\n   }\n };\n \n-// Type used in generic arguments to explicitly request type inference (wildcard\n-// pattern)\n+/* Type used in generic arguments to explicitly request type inference (wildcard\n+ * pattern) */\n class InferredType : public TypeNoBounds\n {\n   Location locus;\n \n   // e.g. Vec<_> = whatever\n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual InferredType *clone_type_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  InferredType *clone_type_impl () const override\n   {\n     return new InferredType (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual InferredType *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  InferredType *clone_type_no_bounds_impl () const override\n   {\n     return new InferredType (*this);\n   }\n \n public:\n   InferredType (Location locus) : locus (locus) {}\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n };\n \n class QualifiedPathInType; // definition moved to \"rust-path.h\"\n@@ -754,8 +683,7 @@ struct MaybeNamedParam\n   };\n \n private:\n-  // Type param_type;\n-  ::std::unique_ptr<Type> param_type;\n+  std::unique_ptr<Type> param_type;\n \n   ParamKind param_kind;\n   Identifier name; // technically, can be an identifier or '_'\n@@ -764,9 +692,9 @@ struct MaybeNamedParam\n \n public:\n   MaybeNamedParam (Identifier name, ParamKind param_kind,\n-\t\t   ::std::unique_ptr<Type> param_type, Location locus)\n-    : param_type (::std::move (param_type)), param_kind (param_kind),\n-      name (::std::move (name)), locus (locus)\n+\t\t   std::unique_ptr<Type> param_type, Location locus)\n+    : param_type (std::move (param_type)), param_kind (param_kind),\n+      name (std::move (name)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n@@ -792,15 +720,15 @@ struct MaybeNamedParam\n   MaybeNamedParam (MaybeNamedParam &&other) = default;\n   MaybeNamedParam &operator= (MaybeNamedParam &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const;\n \n   // Returns whether the param is in an error state.\n-  inline bool is_error () const { return param_type == NULL; }\n+  bool is_error () const { return param_type == nullptr; }\n \n   // Creates an error state param.\n   static MaybeNamedParam create_error ()\n   {\n-    return MaybeNamedParam (\"\", UNNAMED, NULL, Location ());\n+    return MaybeNamedParam (\"\", UNNAMED, nullptr, Location ());\n   }\n \n   Location get_locus () const { return locus; }\n@@ -812,34 +740,33 @@ class BareFunctionType : public TypeNoBounds\n {\n   // bool has_for_lifetimes;\n   // ForLifetimes for_lifetimes;\n-  ::std::vector<LifetimeParam> for_lifetimes; // inlined version\n+  std::vector<LifetimeParam> for_lifetimes; // inlined version\n \n   FunctionQualifiers function_qualifiers;\n-  ::std::vector<MaybeNamedParam> params;\n+  std::vector<MaybeNamedParam> params;\n   bool is_variadic;\n \n   // bool has_return_type;\n   // BareFunctionReturnType return_type;\n-  ::std::unique_ptr<TypeNoBounds> return_type; // inlined version\n+  std::unique_ptr<TypeNoBounds> return_type; // inlined version\n \n   Location locus;\n \n public:\n   // Whether a return type is defined with the function.\n-  inline bool has_return_type () const { return return_type != NULL; }\n+  bool has_return_type () const { return return_type != nullptr; }\n \n   // Whether the function has ForLifetimes.\n-  inline bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+  bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n \n-  BareFunctionType (::std::vector<LifetimeParam> lifetime_params,\n+  BareFunctionType (std::vector<LifetimeParam> lifetime_params,\n \t\t    FunctionQualifiers qualifiers,\n-\t\t    ::std::vector<MaybeNamedParam> named_params,\n-\t\t    bool is_variadic, ::std::unique_ptr<TypeNoBounds> type,\n-\t\t    Location locus)\n-    : for_lifetimes (::std::move (lifetime_params)),\n-      function_qualifiers (::std::move (qualifiers)),\n-      params (::std::move (named_params)), is_variadic (is_variadic),\n-      return_type (::std::move (type)), locus (locus)\n+\t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n+\t\t    std::unique_ptr<TypeNoBounds> type, Location locus)\n+    : for_lifetimes (std::move (lifetime_params)),\n+      function_qualifiers (std::move (qualifiers)),\n+      params (std::move (named_params)), is_variadic (is_variadic),\n+      return_type (std::move (type)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n@@ -851,8 +778,6 @@ class BareFunctionType : public TypeNoBounds\n       locus (other.locus)\n   {}\n \n-  // destructor - define here if required\n-\n   // Overload assignment operator to deep copy\n   BareFunctionType &operator= (BareFunctionType const &other)\n   {\n@@ -870,23 +795,23 @@ class BareFunctionType : public TypeNoBounds\n   BareFunctionType (BareFunctionType &&other) = default;\n   BareFunctionType &operator= (BareFunctionType &&other) = default;\n \n-  ::std::string as_string () const;\n+  std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n \n-  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+  void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual BareFunctionType *clone_type_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  BareFunctionType *clone_type_impl () const override\n   {\n     return new BareFunctionType (*this);\n   }\n \n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  virtual BareFunctionType *clone_type_no_bounds_impl () const OVERRIDE\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  BareFunctionType *clone_type_no_bounds_impl () const override\n   {\n     return new BareFunctionType (*this);\n   }\n@@ -895,11 +820,6 @@ class BareFunctionType : public TypeNoBounds\n // Forward decl - defined in rust-macro.h\n class MacroInvocation;\n \n-/*// AST node of a macro invocation, which is replaced by the macro result at\n-compile time class MacroInvocation : public TypeNoBounds, public Pattern, public\n-ExprWithoutBlock { SimplePath path; DelimTokenTree token_tree;\n-};*/\n-\n /* TODO: possible types\n  * struct type?\n  * \"enum\" (tagged union) type?"}, {"sha": "ac174ad6bef45937d595ebb2828bcb2f8af62b43", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -95,10 +95,13 @@ is_whitespace (char character)\n   return ISSPACE (character);\n }\n \n-Lexer::Lexer (const char *filename, FILE *input, Linemap *linemap)\n-  : input (input), current_line (1), current_column (1), line_map (linemap),\n-    input_source (input), input_queue (input_source), token_source (this),\n-    token_queue (token_source)\n+// this compiles fine, so any intellisense saying otherwise is fake news\n+Lexer::Lexer (const char *filename, RAIIFile file_input, Linemap *linemap)\n+  : input (std::move (file_input)), current_line (1), current_column (1), line_map (linemap),\n+    /*input_source (input.get_raw ()), */\n+    input_queue {InputSource (input.get_raw ())},\n+    /*token_source (this),*/\n+    token_queue (TokenSource (this))\n {\n   // inform line_table that file is being entered and is in line 1\n   line_map->start_file (filename, current_line);\n@@ -156,6 +159,8 @@ void\n Lexer::replace_current_token (TokenPtr replacement)\n {\n   token_queue.replace_current_value (replacement);\n+\n+  fprintf(stderr, \"called 'replace_current_token' - this is deprecated\");\n }\n \n /* shitty anonymous namespace that can only be accessed inside the compilation\n@@ -1000,8 +1005,8 @@ Lexer::parse_escape (char opening_char)\n   return std::make_tuple (output_char, additional_length_offset, false);\n }\n \n-// Parses an escape (or string continue) in a string or character. Supports\n-// unicode escapes.\n+/* Parses an escape (or string continue) in a string or character. Supports\n+ * unicode escapes. */\n std::tuple<Codepoint, int, bool>\n Lexer::parse_utf8_escape (char opening_char)\n {\n@@ -1983,6 +1988,7 @@ Lexer::parse_char_or_lifetime (Location loc)\n \t{\n \t  rust_error_at (get_current_location (),\n \t\t\t \"expected ' after character constant in char literal\");\n+    return nullptr;\n \t}\n     }\n }\n@@ -2289,4 +2295,15 @@ Lexer::test_peek_codepoint_input (int n)\n      UTF-8 (too long)\"); return 0xFFFE;\n \t  }*/\n }\n+\n+void \n+Lexer::split_current_token (TokenId new_left, TokenId new_right) {\n+  // TODO: assert that this TokenId is a \"simple token\" like punctuation and not like \"IDENTIFIER\"?\n+  Location current_loc = peek_token ()->get_locus();\n+  TokenPtr new_left_tok = Token::make (new_left, current_loc);\n+  TokenPtr new_right_tok = Token::make (new_right, current_loc + 1);\n+\n+  token_queue.replace_current_value (std::move (new_left_tok));\n+  token_queue.insert (1, std::move (new_right_tok));\n+}\n } // namespace Rust"}, {"sha": "5ac3a4b2b3396081bc520714ab034bf9b4056d02", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -9,6 +9,36 @@\n #include <tuple>\n \n namespace Rust {\n+// Simple wrapper for FILE* that simplifies destruction.\n+struct RAIIFile\n+{\n+private:\n+  FILE *file;\n+\n+public:\n+  RAIIFile (const char *filename) : file (fopen (filename, \"r\")) {}\n+  RAIIFile (const RAIIFile &other) = delete;\n+  RAIIFile &operator= (const RAIIFile &other) = delete;\n+\n+  // have to specify setting file to nullptr, otherwise unintended fclose occurs\n+  RAIIFile (RAIIFile &&other) : file (other.file) { other.file = nullptr; }\n+  RAIIFile &operator= (RAIIFile &&other)\n+  {\n+    file = other.file;\n+    other.file = nullptr;\n+\n+    return *this;\n+  }\n+\n+  ~RAIIFile ()\n+  {\n+    if (file != nullptr)\n+      fclose (file);\n+  }\n+\n+  FILE *get_raw () { return file; }\n+};\n+\n class Lexer\n {\n private:\n@@ -65,7 +95,7 @@ class Lexer\n \n public:\n   // Construct lexer with input file and filename provided\n-  Lexer (const char *filename, FILE *input, Linemap *linemap);\n+  Lexer (const char *filename, RAIIFile input, Linemap *linemap);\n   ~Lexer ();\n \n   // don't allow copy semantics (for now, at least)\n@@ -88,12 +118,19 @@ class Lexer\n \n   // Replaces the current token with a specified token.\n   void replace_current_token (TokenPtr replacement);\n+  // FIXME: don't use anymore\n+\n+  /* Splits the current token into two. Intended for use with nested generics\n+   * closes (i.e. T<U<X>> where >> is wrongly lexed as one token). Note that\n+   * this will only work with \"simple\" tokens like punctuation. */\n+  void split_current_token (TokenId new_left, TokenId new_right);\n \n   Linemap *get_line_map () { return line_map; }\n \n private:\n   // File for use as input.\n-  FILE *input;\n+  RAIIFile input;\n+  // TODO is this actually required? could just have file storage in InputSource\n \n   // Current line number.\n   int current_line;\n@@ -104,8 +141,8 @@ class Lexer\n   // Line map.\n   Linemap *line_map;\n \n-  // Max column number that can be quickly allocated - higher may require\n-  // allocating new linemap\n+  /* Max column number that can be quickly allocated - higher may require\n+   * allocating new linemap */\n   static const int max_column_hint = 80;\n \n   // Input source wrapper thing.\n@@ -122,7 +159,7 @@ class Lexer\n   };\n \n   // The input source for the lexer.\n-  InputSource input_source;\n+  // InputSource input_source;\n   // Input file queue.\n   buffered_queue<int, InputSource> input_queue;\n \n@@ -140,7 +177,7 @@ class Lexer\n   };\n \n   // The token source for the lexer.\n-  TokenSource token_source;\n+  // TokenSource token_source;\n   // Token stream queue.\n   buffered_queue<std::shared_ptr<Token>, TokenSource> token_queue;\n };"}, {"sha": "84462e6671c34079f31d9cfb6cb1d0e88fd8ee4d", "filename": "gcc/rust/lex/rust-token.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Flex%2Frust-token.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Flex%2Frust-token.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.cc?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -21,8 +21,8 @@ get_token_description (TokenId id)\n     }\n }\n \n-// Hackily defined way to get token description as a string for enum value using\n-// x-macros\n+/* Hackily defined way to get token description as a string for enum value using\n+ * x-macros */\n const char *\n token_id_to_str (TokenId id)\n {\n@@ -93,14 +93,14 @@ Token::get_type_hint_str () const\n   return get_type_hint_string (type_hint);\n }\n \n-const ::std::string &\n+const std::string &\n Token::get_str () const\n {\n   // FIXME: attempt to return null again\n   // gcc_assert(str != NULL);\n \n   // HACK: allow referencing an empty string\n-  static const ::std::string empty = \"\";\n+  static const std::string empty = \"\";\n \n   if (str == NULL)\n     {"}, {"sha": "219318198349237dc9622b1d63b79471b056e560", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 65, "deletions": 48, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -8,8 +8,6 @@\n // order: config, system, coretypes, input\n \n #include <string>\n-//#include <tr1/memory> // as shared_ptr is not available in std memory in c++03\n-// replace with proper std::memory in c++11\n #include <memory>\n \n #include \"rust-linemap.h\"\n@@ -51,8 +49,8 @@ enum PrimitiveCoreType\n //\n // Keep RS_TOKEN_KEYWORD sorted\n \n-// note that abstract, async, become, box, do, final, macro, override, priv,\n-// try, typeof, unsized, virtual, and yield are unused\n+/* note that abstract, async, become, box, do, final, macro, override, priv,\n+ * try, typeof, unsized, virtual, and yield are unused */\n #define RS_TOKEN_LIST                                                          \\\n   RS_TOKEN (FIRST_TOKEN, \"<first-token-marker>\")                               \\\n   RS_TOKEN (END_OF_FILE, \"end of file\")                                        \\\n@@ -146,7 +144,7 @@ enum PrimitiveCoreType\n   RS_TOKEN_KEYWORD (AS, \"as\")                                                  \\\n   RS_TOKEN_KEYWORD (ASYNC, \"async\")   /* unused */                             \\\n   RS_TOKEN_KEYWORD (BECOME, \"become\") /* unused */                             \\\n-  RS_TOKEN_KEYWORD (BOX, \"box\")       /* unused */                             \\\n+  RS_TOKEN_KEYWORD (BOX, \"box\")\t      /* unused */                             \\\n   RS_TOKEN_KEYWORD (BREAK, \"break\")                                            \\\n   RS_TOKEN_KEYWORD (CONST, \"const\")                                            \\\n   RS_TOKEN_KEYWORD (CONTINUE, \"continue\")                                      \\\n@@ -171,7 +169,7 @@ enum PrimitiveCoreType\n   RS_TOKEN_KEYWORD (MOVE, \"move\")                                              \\\n   RS_TOKEN_KEYWORD (MUT, \"mut\")                                                \\\n   RS_TOKEN_KEYWORD (OVERRIDE_TOK, \"override\") /* unused */                     \\\n-  RS_TOKEN_KEYWORD (PRIV, \"priv\")\t     /* unused */                     \\\n+  RS_TOKEN_KEYWORD (PRIV, \"priv\")\t      /* unused */                     \\\n   RS_TOKEN_KEYWORD (PUB, \"pub\")                                                \\\n   RS_TOKEN_KEYWORD (REF, \"ref\")                                                \\\n   RS_TOKEN_KEYWORD (RETURN_TOK, \"return\")                                      \\\n@@ -209,15 +207,15 @@ enum TokenId\n // dodgy \"TokenPtr\" declaration with Token forward declaration\n class Token;\n // A smart pointer (shared_ptr) to Token.\n-typedef ::std::shared_ptr<Token> TokenPtr;\n+typedef std::shared_ptr<Token> TokenPtr;\n // A smart pointer (shared_ptr) to a constant Token.\n-typedef ::std::shared_ptr<const Token> const_TokenPtr;\n+typedef std::shared_ptr<const Token> const_TokenPtr;\n \n // Hackily defined way to get token description for enum value using x-macros\n const char *\n get_token_description (TokenId id);\n-// Hackily defined way to get token description as a string for enum value using\n-// x-macros\n+/* Hackily defined way to get token description as a string for enum value using\n+ * x-macros */\n const char *\n token_id_to_str (TokenId id);\n // Get type hint description as a string.\n@@ -233,117 +231,136 @@ class Token\n   // Token location.\n   Location locus;\n   // Associated text (if any) of token.\n-  ::std::string *str;\n-  // Type hint for token based on lexer data (e.g. type suffix). Does not exist\n-  // for most tokens.\n+  std::string *str;\n+  // TODO: maybe remove issues and just store std::string as value?\n+  /* Type hint for token based on lexer data (e.g. type suffix). Does not exist\n+   * for most tokens. */\n   PrimitiveCoreType type_hint;\n \n   // Token constructor from token id and location. Has a null string.\n   Token (TokenId token_id, Location location)\n-    : token_id (token_id), locus (location), str (NULL),\n+    : token_id (token_id), locus (location), str (nullptr),\n       type_hint (CORETYPE_UNKNOWN)\n   {}\n \n   // Token constructor from token id, location, and a string.\n-  Token (TokenId token_id, Location location, const ::std::string &paramStr)\n-    : token_id (token_id), locus (location), str (new ::std::string (paramStr)),\n+  Token (TokenId token_id, Location location, const std::string &paramStr)\n+    : token_id (token_id), locus (location), str (new std::string (paramStr)),\n       type_hint (CORETYPE_UNKNOWN)\n   {}\n \n   // Token constructor from token id, location, and a char.\n   Token (TokenId token_id, Location location, char paramChar)\n     : token_id (token_id), locus (location),\n-      str (new ::std::string (1, paramChar)), type_hint (CORETYPE_UNKNOWN)\n+      str (new std::string (1, paramChar)), type_hint (CORETYPE_UNKNOWN)\n   {}\n \n   // Token constructor from token id, location, and a \"codepoint\".\n   Token (TokenId token_id, Location location, Codepoint paramCodepoint)\n     : token_id (token_id), locus (location),\n-      str (new ::std::string (paramCodepoint.as_string ())),\n+      str (new std::string (paramCodepoint.as_string ())),\n       type_hint (CORETYPE_UNKNOWN)\n   {}\n \n   // Token constructor from token id, location, a string, and type hint.\n-  Token (TokenId token_id, Location location, const ::std::string &paramStr,\n+  Token (TokenId token_id, Location location, const std::string &paramStr,\n \t PrimitiveCoreType parType)\n-    : token_id (token_id), locus (location), str (new ::std::string (paramStr)),\n+    : token_id (token_id), locus (location), str (new std::string (paramStr)),\n       type_hint (parType)\n   {}\n \n-  // No default initialiser.\n-  Token ();\n+public:\n+  // No default constructor.\n+  Token () = delete;\n   // Do not copy/assign tokens.\n-  Token (const Token &);\n-  Token &operator= (const Token &);\n+  Token (const Token &) = delete;\n+  Token &operator= (const Token &) = delete;\n+\n+  // Allow moving tokens.\n+  Token (Token &&other) = default;\n+  Token &operator= (Token &&other) = default;\n \n-public:\n   ~Token () { delete str; }\n \n+  /* TODO: make_shared (which saves a heap allocation) does not work with the\n+   * private constructor */\n+\n   // Makes and returns a new TokenPtr (with null string).\n   static TokenPtr make (TokenId token_id, Location locus)\n   {\n+    // return std::make_shared<Token> (token_id, locus);\n     return TokenPtr (new Token (token_id, locus));\n   }\n \n   // Makes and returns a new TokenPtr of type IDENTIFIER.\n-  static TokenPtr make_identifier (Location locus, const ::std::string &str)\n+  static TokenPtr make_identifier (Location locus, const std::string &str)\n   {\n+    // return std::make_shared<Token> (IDENTIFIER, locus, str);\n     return TokenPtr (new Token (IDENTIFIER, locus, str));\n   }\n \n   // Makes and returns a new TokenPtr of type INT_LITERAL.\n-  static TokenPtr make_int (Location locus, const ::std::string &str)\n+  /*static TokenPtr make_int (Location locus, const std::string &str)\n   {\n-    return TokenPtr (new Token (INT_LITERAL, locus, str));\n-  }\n+    //return TokenPtr (new Token (INT_LITERAL, locus, str));\n+    return std::make_shared<Token>(INT_LITERAL, locus, str);\n+  }*/\n \n   // Makes and returns a new TokenPtr of type INT_LITERAL.\n-  static TokenPtr make_int (Location locus, const ::std::string &str,\n-\t\t\t    PrimitiveCoreType type_hint)\n+  static TokenPtr make_int (Location locus, const std::string &str,\n+\t\t\t    PrimitiveCoreType type_hint = CORETYPE_UNKNOWN)\n   {\n+    // return std::make_shared<Token> (INT_LITERAL, locus, str, type_hint);\n     return TokenPtr (new Token (INT_LITERAL, locus, str, type_hint));\n   }\n \n   // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n-  static TokenPtr make_float (Location locus, const ::std::string &str)\n+  /*static TokenPtr make_float (Location locus, const std::string &str)\n   {\n     return TokenPtr (new Token (FLOAT_LITERAL, locus, str));\n-  }\n+    return std::make_shared<Token>(FLOAT_LITERAL, locus, str);\n+  }*/\n \n   // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n-  static TokenPtr make_float (Location locus, const ::std::string &str,\n-\t\t\t      PrimitiveCoreType type_hint)\n+  static TokenPtr make_float (Location locus, const std::string &str,\n+\t\t\t      PrimitiveCoreType type_hint = CORETYPE_UNKNOWN)\n   {\n+    // return std::make_shared<Token> (FLOAT_LITERAL, locus, str, type_hint);\n     return TokenPtr (new Token (FLOAT_LITERAL, locus, str, type_hint));\n   }\n \n   // Makes and returns a new TokenPtr of type STRING_LITERAL.\n-  static TokenPtr make_string (Location locus, const ::std::string &str)\n+  static TokenPtr make_string (Location locus, const std::string &str)\n   {\n+    // return std::make_shared<Token> (STRING_LITERAL, locus, str, CORETYPE_STR);\n     return TokenPtr (new Token (STRING_LITERAL, locus, str, CORETYPE_STR));\n   }\n \n-  // Makes and returns a new TokenPtr of type CHAR_LITERAL (fix).\n+  // Makes and returns a new TokenPtr of type CHAR_LITERAL.\n   static TokenPtr make_char (Location locus, Codepoint char_lit)\n   {\n+    // return std::make_shared<Token> (CHAR_LITERAL, locus, char_lit);\n     return TokenPtr (new Token (CHAR_LITERAL, locus, char_lit));\n   }\n \n-  // Makes and returns a new TokenPtr of type BYTE_CHAR_LITERAL (fix).\n+  // Makes and returns a new TokenPtr of type BYTE_CHAR_LITERAL.\n   static TokenPtr make_byte_char (Location locus, char byte_char)\n   {\n+    // return std::make_shared<Token> (BYTE_CHAR_LITERAL, locus, byte_char);\n     return TokenPtr (new Token (BYTE_CHAR_LITERAL, locus, byte_char));\n   }\n \n   // Makes and returns a new TokenPtr of type BYTE_STRING_LITERAL (fix).\n-  static TokenPtr make_byte_string (Location locus, const ::std::string &str)\n+  static TokenPtr make_byte_string (Location locus, const std::string &str)\n   {\n+    // return std::make_shared<Token> (BYTE_STRING_LITERAL, locus, str); \n     return TokenPtr (new Token (BYTE_STRING_LITERAL, locus, str));\n   }\n \n   // Makes and returns a new TokenPtr of type LIFETIME.\n-  static TokenPtr make_lifetime (Location locus, const ::std::string &str)\n+  static TokenPtr make_lifetime (Location locus, const std::string &str)\n   {\n+    // return std::make_shared<Token> (LIFETIME, locus, str);\n     return TokenPtr (new Token (LIFETIME, locus, str));\n   }\n \n@@ -354,11 +371,11 @@ class Token\n   Location get_locus () const { return locus; }\n \n   // Gets string description of the token.\n-  const ::std::string &\n+  const std::string &\n   get_str () const; /*{\n // FIXME: put in header again when fix null problem\n-//gcc_assert(str != NULL);\n-if (str == NULL) {\n+//gcc_assert(str != nullptr);\n+if (str == nullptr) {\n error_at(get_locus(), \"attempted to get string for '%s', which has no string.\n returning empty string instead.\", get_token_description()); return \"\";\n }\n@@ -385,7 +402,7 @@ return *str;\n \n   /* Returns whether the token is a literal of any type (int, float, char,\n    * string, byte char, byte string). */\n-  inline bool is_literal () const\n+  bool is_literal () const\n   {\n     switch (token_id)\n       {\n@@ -401,12 +418,12 @@ return *str;\n       }\n   }\n \n-  // Returns whether the token actually has a string (regardless of whether it\n-  // should or not).\n-  inline bool has_str () const { return str != NULL; }\n+  /* Returns whether the token actually has a string (regardless of whether it\n+   * should or not). */\n+  bool has_str () const { return str != nullptr; }\n \n   // Returns whether the token should have a string.\n-  inline bool should_have_str () const\n+  bool should_have_str () const\n   {\n     return is_literal () || token_id == IDENTIFIER || token_id == LIFETIME;\n   }"}, {"sha": "ac9ffa13231c04035dfbb5d00827d2ea02fddb03", "filename": "gcc/rust/rust-buffered-queue.h", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Frust-buffered-queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Frust-buffered-queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-buffered-queue.h?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -8,13 +8,25 @@\n // order: config, system\n \n namespace Rust {\n-// Buffered queue implementation. Items are of type T, queue source is of type\n-// Source.\n+/* Buffered queue implementation. Items are of type T, queue source is of type\n+ * Source. Note that this is owning of the source. */\n template <typename T, typename Source> class buffered_queue\n {\n public:\n-  // Construct empty queue from Source& src.\n-  buffered_queue (Source &src) : source (src), start (0), end (0), buffer () {}\n+  // Construct empty queue from Source src.\n+  buffered_queue (Source src)\n+    : source (std::move (src)), start (0), end (0), buffer ()\n+  {}\n+\n+  /* disable copying (since source is probably non-copyable)\n+   * TODO is this actually a good idea? If source is non-copyable, it would\n+   * just delete the copy constructor anyway.*/\n+  buffered_queue (const buffered_queue &other) = delete;\n+  buffered_queue &operator= (const buffered_queue &other) = delete;\n+\n+  // enable moving\n+  buffered_queue (buffered_queue &&other) = default;\n+  buffered_queue &operator= (buffered_queue &&other) = default;\n \n   // Returns token at position start + n (i.e. n tokens ahead).\n   T peek (int n)\n@@ -30,8 +42,8 @@ template <typename T, typename Source> class buffered_queue\n       {\n \tint num_items_to_read = num_items_required - num_queued_items;\n \n-\t// if queue length + extra items is larger than buffer size, expand\n-\t// buffer\n+\t/* if queue length + extra items is larger than buffer size, expand\n+\t * buffer */\n \tif (end + num_items_to_read > (int) buffer.size ())\n \t  {\n \t    // Resize the buffer by 1.5x\n@@ -44,6 +56,8 @@ template <typename T, typename Source> class buffered_queue\n \t\t       new_queue.begin ());\n \t    start = 0;\n \t    end = num_queued_items;\n+\t    // TODO: would move be better here? optimisation for move with\n+\t    // shared pointer?\n \n \t    // swap member buffer and new queue buffer\n \t    std::swap (buffer, new_queue);\n@@ -52,12 +66,10 @@ template <typename T, typename Source> class buffered_queue\n \t    gcc_assert (end + num_queued_items < (int) buffer.size ());\n \t  }\n \n-\t// iterate through buffer and invoke operator () on source on values\n-\t// past original end\n+\t/* iterate through buffer and invoke operator () on source on values\n+\t * past original end */\n \tfor (int i = 0; i < num_items_to_read; i++)\n-\t  {\n-\t    buffer[end + i] = source ();\n-\t  }\n+\t  buffer[end + i] = source ();\n \n \t// move end based on additional items added\n \tend += num_items_to_read;\n@@ -73,21 +85,18 @@ template <typename T, typename Source> class buffered_queue\n     return buffer[start + n];\n   }\n \n-  // TODO: add faster peek current token to remove overhead of conditional\n-  // branches?\n+  /* TODO: add faster peek current token to remove overhead of conditional\n+   * branches? */\n \n   // Advances start by n + 1.\n   void skip (int n)\n   {\n     // Call peek to ensure requested n is actually in queue.\n     peek (n);\n \n-    // Clear values from start to n (inclusive).\n+    // Clear queue values from start to n (inclusive).\n     for (int i = 0; i < (n + 1); i++)\n-      {\n-\t// Clear value at index\n \tbuffer[start + i] = T ();\n-      }\n \n     // Move start forward by n + 1.\n     start += (n + 1);\n@@ -98,9 +107,7 @@ template <typename T, typename Source> class buffered_queue\n \n     // Compact buffer if empty\n     if (start == end)\n-      {\n-\tstart = end = 0;\n-      }\n+      start = end = 0;\n   }\n \n   /* Inserts element at front of vector. Really dirty hack with terrible\n@@ -110,10 +117,29 @@ template <typename T, typename Source> class buffered_queue\n     // TODO: test as this may not work properly\n \n     // Insert actual element in buffer at start.\n-    buffer.insert (buffer.begin (), 1, elem_to_insert);\n+    buffer.insert (buffer.begin (), elem_to_insert);\n+\n+    /* Increase the end number since added element means all others have shifted\n+     * one along */\n+    end++;\n+  }\n+\n+  // Insert at arbitrary position (attempt)\n+  void insert (int index, T elem_to_insert) \n+  {\n+    // TODO: test as this may not work properly\n+\n+    // n should not be behind\n+    gcc_assert (index >= 0);\n+\n+    // call peek to ensure that the items behind this (at least) are in queue\n+    if (index >= 1)\n+      peek (index - 1);\n+    else\n+      peek (index);\n+\n+    buffer.insert (buffer.begin () + start + index, std::move (elem_to_insert));\n \n-    // Increase the end number since added element means all others have shifted\n-    // one along\n     end++;\n   }\n \n@@ -123,14 +149,14 @@ template <typename T, typename Source> class buffered_queue\n     // call peek to ensure value exists\n     peek (0);\n \n-    buffer[start] = replacement;\n+    buffer[start] = std::move (replacement);\n \n     // don't move start or end\n   }\n \n private:\n   // Source of tokens for queue.\n-  Source &source;\n+  Source source;\n \n   // Begin of range in buffer, inclusive.\n   int start;"}, {"sha": "6ba496d745dc5d6a73261ada51e462f3fc5d8e30", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=8a633e3ca4d151d6bbee849a1ef2d265d95bc2a7", "patch": "@@ -25,19 +25,10 @@ extern Backend *\n rust_get_backend ();\n \n namespace Rust {\n-// Simple wrapper for FILE* that simplifies destruction.\n-struct RAIIFile\n-{\n-  FILE *file;\n-\n-  RAIIFile (const char *filename) : file (fopen (filename, \"r\")) {}\n-\n-  ~RAIIFile () { fclose (file); }\n-};\n \n // Implicitly enable a target_feature (and recursively enable dependencies).\n void\n-Session::implicitly_enable_feature (::std::string feature_name)\n+Session::implicitly_enable_feature (std::string feature_name)\n {\n   // TODO: is this really required since features added would be complete via\n   // target spec?\n@@ -91,7 +82,7 @@ Session::implicitly_enable_feature (::std::string feature_name)\n \t}\n \n       options.target_data.insert_key_value_pair (\"target_feature\",\n-\t\t\t\t\t\t ::std::move (feature_name));\n+\t\t\t\t\t\t std::move (feature_name));\n     }\n }\n \n@@ -235,7 +226,7 @@ Session::enable_features ()\n       }\n   }\n   options.target_data.features.shrink_to_fit();\n-  ::std::sort(options.target_data.features.begin(),\n+  std::sort(options.target_data.features.begin(),\n   options.target_data.features.end());*/\n }\n \n@@ -313,7 +304,7 @@ Session::handle_option (\n       // enable dump and return whether this was successful\n       if (arg != NULL)\n \t{\n-\t  ret = enable_dump (::std::string (arg));\n+\t  ret = enable_dump (std::string (arg));\n \t}\n       else\n \t{\n@@ -332,7 +323,7 @@ Session::handle_option (\n /* Enables a certain dump depending on the name passed in. Returns true if name\n  * is valid, false otherwise. */\n bool\n-Session::enable_dump (::std::string arg)\n+Session::enable_dump (std::string arg)\n {\n   // FIXME: change dumping algorithm when new non-inhibiting dump system is\n   // created\n@@ -411,18 +402,18 @@ Session::parse_file (const char *filename)\n {\n   RAIIFile file_wrap (filename);\n \n-  if (file_wrap.file == NULL)\n+  if (file_wrap.get_raw() == NULL)\n     {\n       fatal_error (UNKNOWN_LOCATION, \"cannot open filename %s: %m\", filename);\n     }\n \n   Backend *backend = rust_get_backend ();\n \n   // parse file here\n-  // create lexer and parser - these are file-specific and so aren't instance\n-  // variables\n-  Rust::Lexer lex (filename, file_wrap.file, rust_get_linemap ());\n-  Rust::Parser parser (lex);\n+  /* create lexer and parser - these are file-specific and so aren't instance\n+   * variables */\n+  Rust::Lexer lex (filename, std::move (file_wrap), rust_get_linemap ());\n+  Rust::Parser parser (/*std::move (*/lex/*)*/);\n \n   // generate crate from parser\n   auto parsed_crate = parser.parse_crate ();\n@@ -518,7 +509,7 @@ check_cfg (const AST::Attribute &attr ATTRIBUTE_UNUSED)\n // Checks whether any 'cfg' attribute on the item prevents compilation of that\n // item.\n bool\n-check_item_cfg (::std::vector<AST::Attribute> attrs)\n+check_item_cfg (std::vector<AST::Attribute> attrs)\n {\n   for (const auto &attr : attrs)\n     {\n@@ -534,7 +525,7 @@ check_item_cfg (::std::vector<AST::Attribute> attrs)\n \n // TODO: actually implement method\n void\n-load_extern_crate (::std::string crate_name ATTRIBUTE_UNUSED)\n+load_extern_crate (std::string crate_name ATTRIBUTE_UNUSED)\n {}\n // TODO: deprecated - don't use\n \n@@ -555,7 +546,7 @@ Session::debug_dump_load_crates (Parser &parser)\n    * enable using Option and Copy without qualifying it or importing it via\n    * 'use' manually) */\n \n-  ::std::vector< ::std::string> crate_names;\n+  std::vector<std::string> crate_names;\n   for (const auto &item : crate.items)\n     {\n       // if item is extern crate, add name? to list of stuff ONLY IF config is\n@@ -656,7 +647,7 @@ Session::injection (AST::Crate &crate)\n    * test should be prioritised since they seem to be used the most. */\n \n   // crate injection\n-  ::std::vector< ::std::string> names;\n+  std::vector<std::string> names;\n   if (contains_name (crate.inner_attrs, \"no_core\"))\n     {\n       // no prelude\n@@ -689,33 +680,33 @@ Session::injection (AST::Crate &crate)\n       AST::Attribute attr (AST::SimplePath::from_str (\"macro_use\"), NULL);\n \n       // create \"extern crate\" item with the name\n-      ::std::unique_ptr<AST::ExternCrate> extern_crate (\n+      std::unique_ptr<AST::ExternCrate> extern_crate (\n \tnew AST::ExternCrate (*it, AST::Visibility::create_error (),\n-\t\t\t      {::std::move (attr)},\n+\t\t\t      {std::move (attr)},\n \t\t\t      Linemap::unknown_location ()));\n \n       // insert at beginning\n-      crate.items.insert (crate.items.begin (), ::std::move (extern_crate));\n+      crate.items.insert (crate.items.begin (), std::move (extern_crate));\n     }\n \n   // create use tree path\n   // prelude is injected_crate_name\n-  ::std::vector<AST::SimplePathSegment> segments\n+  std::vector<AST::SimplePathSegment> segments\n     = {AST::SimplePathSegment (injected_crate_name),\n        AST::SimplePathSegment (\"prelude\"), AST::SimplePathSegment (\"v1\")};\n   // create use tree and decl\n-  ::std::unique_ptr<AST::UseTreeGlob> use_tree (\n+  std::unique_ptr<AST::UseTreeGlob> use_tree (\n     new AST::UseTreeGlob (AST::UseTreeGlob::PATH_PREFIXED,\n-\t\t\t  AST::SimplePath (::std::move (segments)),\n+\t\t\t  AST::SimplePath (std::move (segments)),\n \t\t\t  Location ()));\n   AST::Attribute prelude_attr (AST::SimplePath::from_str (\"prelude_import\"),\n \t\t\t       NULL);\n-  ::std::unique_ptr<AST::UseDeclaration> use_decl (\n-    new AST::UseDeclaration (::std::move (use_tree),\n+  std::unique_ptr<AST::UseDeclaration> use_decl (\n+    new AST::UseDeclaration (std::move (use_tree),\n \t\t\t     AST::Visibility::create_error (),\n-\t\t\t     {::std::move (prelude_attr)}, Location ()));\n+\t\t\t     {std::move (prelude_attr)}, Location ()));\n \n-  crate.items.insert (crate.items.begin (), ::std::move (use_decl));\n+  crate.items.insert (crate.items.begin (), std::move (use_decl));\n \n   /* TODO: potentially add checking attribute crate type? I can't figure out\n    * what this does currently comment says \"Unconditionally collect crate types"}]}