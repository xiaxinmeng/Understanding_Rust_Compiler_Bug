{"sha": "b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRhYjdkMzRmNWVlODllMjNmNzVjYjI1NTg1YmM4NTFjN2Y3MTNiMw==", "commit": {"author": {"name": "Kostya Serebryany", "email": "kcc@google.com", "date": "2013-02-13T10:46:01Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2013-02-13T10:46:01Z"}, "message": "libsanitizer merge from upstream r175049\n\nFrom-SVN: r196009", "tree": {"sha": "c4504a71a4de65630ff00dd7aa8e062235fc5076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4504a71a4de65630ff00dd7aa8e062235fc5076"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/comments", "author": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bdcbe80c52f4cec942890eda8520d553edff998f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdcbe80c52f4cec942890eda8520d553edff998f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdcbe80c52f4cec942890eda8520d553edff998f"}], "stats": {"total": 3169, "additions": 2142, "deletions": 1027}, "files": [{"sha": "8dff131c7eede92dd5bb334f51699a3cdc876af0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -1,3 +1,9 @@\n+2013-02-13  Kostya Serebryany  <kcc@google.com>\n+\n+\t* config/i386/i386.c: Use 0x7fff8000 as asan_shadow_offset on x86_64\n+\tlinux.\n+\t* sanitizer.def: Rename __asan_init to __asan_init_v1.\n+\n 2013-02-12  Dodji Seketeli  <dodji@redhat.com>\n \n \tAvoid instrumenting duplicated memory access in the same basic block"}, {"sha": "b8ef1c33efc95b76f30913f65ec87149845b2159", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -5436,7 +5436,9 @@ ix86_legitimate_combined_insn (rtx insn)\n static unsigned HOST_WIDE_INT\n ix86_asan_shadow_offset (void)\n {\n-  return (unsigned HOST_WIDE_INT) 1 << (TARGET_LP64 ? 44 : 29);\n+  return TARGET_LP64 ? (TARGET_MACHO ? (HOST_WIDE_INT_1 << 44)\n+\t\t\t\t     : HOST_WIDE_INT_C (0x7fff8000))\n+\t\t     : (HOST_WIDE_INT_1 << 29);\n }\n \f\n /* Argument support functions.  */"}, {"sha": "99f87e5c84b8158c7fe269c540844bdcb13569aa", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n    for other FEs by asan.c.  */\n \n /* Address Sanitizer */\n-DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_INIT, \"__asan_init\",\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_INIT, \"__asan_init_v1\",\n \t\t      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n /* Do not reorder the BUILT_IN_ASAN_REPORT* builtins, e.g. cfgcleanup.c\n    relies on this order.  */"}, {"sha": "b9d72a1cbd97fa351352fbcf5cf5b82ae57c58ed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -1,3 +1,9 @@\n+2013-02-13  Kostya Serebryany  <kcc@google.com>\n+\n+\t* c-c++-common/asan/strncpy-overflow-1.c: Update the test\n+\tto match the fresh asan run-time.\n+\t* c-c++-common/asan/rlimit-mmap-test-1.c: Ditto.\n+\n 2013-02-12  Dodji Seketeli  <dodji@redhat.com>\n \n \tAvoid instrumenting duplicated memory access in the same basic block"}, {"sha": "0b3d2ae6fa0c215197d497c0d9eec312a509fd61", "filename": "gcc/testsuite/c-c++-common/asan/rlimit-mmap-test-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Frlimit-mmap-test-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Frlimit-mmap-test-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Frlimit-mmap-test-1.c?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -18,4 +18,4 @@ int main(int argc, char **argv) {\n   return 0;\n }\n \n-/* { dg-output \"AddressSanitizer is unable to mmap\" } */\n+/* { dg-output \"ERROR: Failed to mmap\" } */"}, {"sha": "10b3ad76d0400af6aa907f201f336a3de7488d9d", "filename": "gcc/testsuite/c-c++-common/asan/strncpy-overflow-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstrncpy-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstrncpy-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstrncpy-overflow-1.c?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -12,7 +12,7 @@ int main(int argc, char **argv) {\n   return short_buffer[8];\n }\n \n-/* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"WRITE of size \\[0-9\\]* at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #0 0x\\[0-9a-f\\]+ (in _*(interceptor_|)strncpy|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #1 0x\\[0-9a-f\\]+ (in _*main (\\[^\\n\\r]*strncpy-overflow-1.c:11|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"0x\\[0-9a-f\\]+ is located 0 bytes to the right of 9-byte region\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "db1e6e119de4115bfea7ac2fbfa9e726daefa6dd", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -1,3 +1,10 @@\n+2013-02-13  Kostya Serebryany  <kcc@google.com>\n+\n+        PR sanitizer/56128\n+\t* All source files: Merge from upstream r175049.\n+\t* interception/Makefile.am: added include path.\n+\t* interception/Makefile.in: Regenerated.\n+\n 2013-02-11  Jack Howarth  <howarth@bromo.med.uc.edu>\n \n \t* configure.tgt: Disable build on darwin9 and earlier."}, {"sha": "02d2bfcf51278e921c66f12bf3d3e016759161bb", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -1,4 +1,4 @@\n-173241\n+175049\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "4e97ff57530223d01f1831772beefb65e9a44278", "filename": "libsanitizer/asan/asan_allocator.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -32,7 +32,7 @@\n #include \"asan_report.h\"\n #include \"asan_thread.h\"\n #include \"asan_thread_registry.h\"\n-#include \"sanitizer/asan_interface.h\"\n+#include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n \n@@ -367,7 +367,7 @@ class MallocInfo {\n         left_chunk->chunk_state != CHUNK_AVAILABLE)\n       return left_chunk;\n     // Choose based on offset.\n-    uptr l_offset = 0, r_offset = 0;\n+    sptr l_offset = 0, r_offset = 0;\n     CHECK(AsanChunkView(left_chunk).AddrIsAtRight(addr, 1, &l_offset));\n     CHECK(AsanChunkView(right_chunk).AddrIsAtLeft(addr, 1, &r_offset));\n     if (l_offset < r_offset)\n@@ -387,7 +387,7 @@ class MallocInfo {\n     CHECK(m->chunk_state == CHUNK_ALLOCATED ||\n           m->chunk_state == CHUNK_AVAILABLE ||\n           m->chunk_state == CHUNK_QUARANTINE);\n-    uptr offset = 0;\n+    sptr offset = 0;\n     AsanChunkView m_view(m);\n     if (m_view.AddrIsInside(addr, 1, &offset))\n       return m;\n@@ -685,6 +685,8 @@ void __asan_free_hook(void *ptr) {\n \n namespace __asan {\n \n+void InitializeAllocator() { }\n+\n void PrintInternalAllocatorStats() {\n }\n \n@@ -710,6 +712,7 @@ void *asan_malloc(uptr size, StackTrace *stack) {\n }\n \n void *asan_calloc(uptr nmemb, uptr size, StackTrace *stack) {\n+  if (__sanitizer::CallocShouldReturnNullDueToOverflow(size, nmemb)) return 0;\n   void *ptr = (void*)Allocate(0, nmemb * size, stack, FROM_MALLOC);\n   if (ptr)\n     REAL(memset)(ptr, 0, nmemb * size);"}, {"sha": "df2f520c41a4847f461110bf5e7de536174e4ca6", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 8, "deletions": 54, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -22,7 +22,7 @@\n // will co-exist in the source base for a while. The actual allocator is chosen\n // at build time by redefining this macro.\n #ifndef ASAN_ALLOCATOR_VERSION\n-# if ASAN_LINUX && !ASAN_ANDROID\n+# if (ASAN_LINUX && !ASAN_ANDROID) || ASAN_MAC || ASAN_WINDOWS\n #  define ASAN_ALLOCATOR_VERSION 2\n # else\n #  define ASAN_ALLOCATOR_VERSION 1\n@@ -40,6 +40,8 @@ enum AllocType {\n static const uptr kNumberOfSizeClasses = 255;\n struct AsanChunk;\n \n+void InitializeAllocator();\n+\n class AsanChunkView {\n  public:\n   explicit AsanChunkView(AsanChunk *chunk) : chunk_(chunk) {}\n@@ -51,27 +53,24 @@ class AsanChunkView {\n   uptr FreeTid();\n   void GetAllocStack(StackTrace *stack);\n   void GetFreeStack(StackTrace *stack);\n-  bool AddrIsInside(uptr addr, uptr access_size, uptr *offset) {\n+  bool AddrIsInside(uptr addr, uptr access_size, sptr *offset) {\n     if (addr >= Beg() && (addr + access_size) <= End()) {\n       *offset = addr - Beg();\n       return true;\n     }\n     return false;\n   }\n-  bool AddrIsAtLeft(uptr addr, uptr access_size, uptr *offset) {\n+  bool AddrIsAtLeft(uptr addr, uptr access_size, sptr *offset) {\n     (void)access_size;\n     if (addr < Beg()) {\n       *offset = Beg() - addr;\n       return true;\n     }\n     return false;\n   }\n-  bool AddrIsAtRight(uptr addr, uptr access_size, uptr *offset) {\n-    if (addr + access_size >= End()) {\n-      if (addr <= End())\n-        *offset = 0;\n-      else\n-        *offset = addr - End();\n+  bool AddrIsAtRight(uptr addr, uptr access_size, sptr *offset) {\n+    if (addr + access_size > End()) {\n+      *offset = addr - End();\n       return true;\n     }\n     return false;\n@@ -225,50 +224,5 @@ void asan_mz_force_unlock();\n \n void PrintInternalAllocatorStats();\n \n-// Log2 and RoundUpToPowerOfTwo should be inlined for performance.\n-#if defined(_WIN32) && !defined(__clang__)\n-extern \"C\" {\n-unsigned char _BitScanForward(unsigned long *index, unsigned long mask);  // NOLINT\n-unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);  // NOLINT\n-#if defined(_WIN64)\n-unsigned char _BitScanForward64(unsigned long *index, unsigned __int64 mask);  // NOLINT\n-unsigned char _BitScanReverse64(unsigned long *index, unsigned __int64 mask);  // NOLINT\n-#endif\n-}\n-#endif\n-\n-static inline uptr Log2(uptr x) {\n-  CHECK(IsPowerOfTwo(x));\n-#if !defined(_WIN32) || defined(__clang__)\n-  return __builtin_ctzl(x);\n-#elif defined(_WIN64)\n-  unsigned long ret;  // NOLINT\n-  _BitScanForward64(&ret, x);\n-  return ret;\n-#else\n-  unsigned long ret;  // NOLINT\n-  _BitScanForward(&ret, x);\n-  return ret;\n-#endif\n-}\n-\n-static inline uptr RoundUpToPowerOfTwo(uptr size) {\n-  CHECK(size);\n-  if (IsPowerOfTwo(size)) return size;\n-\n-  unsigned long up;  // NOLINT\n-#if !defined(_WIN32) || defined(__clang__)\n-  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(size);\n-#elif defined(_WIN64)\n-  _BitScanReverse64(&up, size);\n-#else\n-  _BitScanReverse(&up, size);\n-#endif\n-  CHECK(size < (1ULL << (up + 1)));\n-  CHECK(size > (1ULL << up));\n-  return 1UL << (up + 1);\n-}\n-\n-\n }  // namespace __asan\n #endif  // ASAN_ALLOCATOR_H"}, {"sha": "1ff120e555c74eeb00a0f5946e70437570bc29bb", "filename": "libsanitizer/asan/asan_allocator2.cc", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_allocator2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_allocator2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator2.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -20,7 +20,6 @@\n #include \"asan_report.h\"\n #include \"asan_thread.h\"\n #include \"asan_thread_registry.h\"\n-#include \"sanitizer/asan_interface.h\"\n #include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_list.h\"\n@@ -55,7 +54,11 @@ struct AsanMapUnmapCallback {\n };\n \n #if SANITIZER_WORDSIZE == 64\n+#if defined(__powerpc64__)\n+const uptr kAllocatorSpace =  0xa0000000000ULL;\n+#else\n const uptr kAllocatorSpace = 0x600000000000ULL;\n+#endif\n const uptr kAllocatorSize  =  0x10000000000ULL;  // 1T.\n typedef DefaultSizeClassMap SizeClassMap;\n typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize, 0 /*metadata*/,\n@@ -89,8 +92,6 @@ static const uptr kMaxAllowedMallocSize =\n static const uptr kMaxThreadLocalQuarantine =\n   FIRST_32_SECOND_64(1 << 18, 1 << 20);\n \n-static const uptr kReturnOnZeroMalloc = 2048;  // Zero page is protected.\n-\n // Every chunk of memory allocated by this allocator can be in one of 3 states:\n // CHUNK_AVAILABLE: the chunk is in the free list and ready to be allocated.\n // CHUNK_ALLOCATED: the chunk is allocated and not yet freed.\n@@ -112,7 +113,7 @@ static u32 RZSize2Log(u32 rz_size) {\n   CHECK_GE(rz_size, 16);\n   CHECK_LE(rz_size, 2048);\n   CHECK(IsPowerOfTwo(rz_size));\n-  u32 res = __builtin_ctz(rz_size) - 4;\n+  u32 res = Log2(rz_size) - 4;\n   CHECK_EQ(rz_size, RZLog2Size(res));\n   return res;\n }\n@@ -289,27 +290,26 @@ struct QuarantineCallback {\n   AllocatorCache *cache_;\n };\n \n-static void Init() {\n-  static int inited = 0;\n-  if (inited) return;\n-  __asan_init();\n-  inited = true;  // this must happen before any threads are created.\n+void InitializeAllocator() {\n   allocator.Init();\n   quarantine.Init((uptr)flags()->quarantine_size, kMaxThreadLocalQuarantine);\n }\n \n static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n                       AllocType alloc_type) {\n-  Init();\n+  if (!asan_inited)\n+    __asan_init();\n   CHECK(stack);\n   const uptr min_alignment = SHADOW_GRANULARITY;\n   if (alignment < min_alignment)\n     alignment = min_alignment;\n   if (size == 0) {\n-    if (alignment <= kReturnOnZeroMalloc)\n-      return reinterpret_cast<void *>(kReturnOnZeroMalloc);\n-    else\n-      return 0;  // 0 bytes with large alignment requested. Just return 0.\n+    // We'd be happy to avoid allocating memory for zero-size requests, but\n+    // some programs/tests depend on this behavior and assume that malloc would\n+    // not return NULL even for zero-size allocations. Moreover, it looks like\n+    // operator new should never return NULL, and results of consecutive \"new\"\n+    // calls must be different even if the allocated size is zero.\n+    size = 1;\n   }\n   CHECK(IsPowerOfTwo(alignment));\n   uptr rz_log = ComputeRZLog(size);\n@@ -415,7 +415,8 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n \n static void Deallocate(void *ptr, StackTrace *stack, AllocType alloc_type) {\n   uptr p = reinterpret_cast<uptr>(ptr);\n-  if (p == 0 || p == kReturnOnZeroMalloc) return;\n+  if (p == 0) return;\n+  ASAN_FREE_HOOK(ptr);\n   uptr chunk_beg = p - kChunkHeaderSize;\n   AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n \n@@ -465,8 +466,6 @@ static void Deallocate(void *ptr, StackTrace *stack, AllocType alloc_type) {\n     quarantine.Put(&fallback_quarantine_cache, QuarantineCallback(ac),\n                    m, m->UsedSize());\n   }\n-\n-  ASAN_FREE_HOOK(ptr);\n }\n \n static void *Reallocate(void *old_ptr, uptr new_size, StackTrace *stack) {\n@@ -546,7 +545,7 @@ AsanChunk *ChooseChunk(uptr addr,\n       return right_chunk;\n   }\n   // Same chunk_state: choose based on offset.\n-  uptr l_offset = 0, r_offset = 0;\n+  sptr l_offset = 0, r_offset = 0;\n   CHECK(AsanChunkView(left_chunk).AddrIsAtRight(addr, 1, &l_offset));\n   CHECK(AsanChunkView(right_chunk).AddrIsAtLeft(addr, 1, &r_offset));\n   if (l_offset < r_offset)\n@@ -557,7 +556,7 @@ AsanChunk *ChooseChunk(uptr addr,\n AsanChunkView FindHeapChunkByAddress(uptr addr) {\n   AsanChunk *m1 = GetAsanChunkByAddr(addr);\n   if (!m1) return AsanChunkView(m1);\n-  uptr offset = 0;\n+  sptr offset = 0;\n   if (AsanChunkView(m1).AddrIsAtLeft(addr, 1, &offset)) {\n     // The address is in the chunk's left redzone, so maybe it is actually\n     // a right buffer overflow from the other chunk to the left.\n@@ -601,6 +600,7 @@ void *asan_malloc(uptr size, StackTrace *stack) {\n }\n \n void *asan_calloc(uptr nmemb, uptr size, StackTrace *stack) {\n+  if (CallocShouldReturnNullDueToOverflow(size, nmemb)) return 0;\n   void *ptr = Allocate(nmemb * size, 8, stack, FROM_MALLOC);\n   if (ptr)\n     REAL(memset)(ptr, 0, nmemb * size);\n@@ -649,16 +649,17 @@ uptr asan_malloc_usable_size(void *ptr, StackTrace *stack) {\n }\n \n uptr asan_mz_size(const void *ptr) {\n-  UNIMPLEMENTED();\n-  return 0;\n+  return AllocationSize(reinterpret_cast<uptr>(ptr));\n }\n \n void asan_mz_force_lock() {\n-  UNIMPLEMENTED();\n+  allocator.ForceLock();\n+  fallback_mutex.Lock();\n }\n \n void asan_mz_force_unlock() {\n-  UNIMPLEMENTED();\n+  fallback_mutex.Unlock();\n+  allocator.ForceUnlock();\n }\n \n }  // namespace __asan\n@@ -674,15 +675,15 @@ uptr __asan_get_estimated_allocated_size(uptr size) {\n \n bool __asan_get_ownership(const void *p) {\n   uptr ptr = reinterpret_cast<uptr>(p);\n-  return (ptr == kReturnOnZeroMalloc) || (AllocationSize(ptr) > 0);\n+  return (AllocationSize(ptr) > 0);\n }\n \n uptr __asan_get_allocated_size(const void *p) {\n   if (p == 0) return 0;\n   uptr ptr = reinterpret_cast<uptr>(p);\n   uptr allocated_size = AllocationSize(ptr);\n   // Die if p is not malloced or if it is already freed.\n-  if (allocated_size == 0 && ptr != kReturnOnZeroMalloc) {\n+  if (allocated_size == 0) {\n     GET_STACK_TRACE_FATAL_HERE;\n     ReportAsanGetAllocatedSizeNotOwned(ptr, &stack);\n   }"}, {"sha": "1fc0415750bac09b0e73732f90d2fe83abda8479", "filename": "libsanitizer/asan/asan_fake_stack.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -12,7 +12,6 @@\n #include \"asan_allocator.h\"\n #include \"asan_thread.h\"\n #include \"asan_thread_registry.h\"\n-#include \"sanitizer/asan_interface.h\"\n \n namespace __asan {\n "}, {"sha": "b05fdc3acc6c4ad7a883cb5a8c228c8370de5a58", "filename": "libsanitizer/asan/asan_flags.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -13,7 +13,7 @@\n #ifndef ASAN_FLAGS_H\n #define ASAN_FLAGS_H\n \n-#include \"sanitizer/common_interface_defs.h\"\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n \n // ASan flag values can be defined in three ways:\n // 1) initialized with default values at startup.\n@@ -50,8 +50,6 @@ struct Flags {\n   bool replace_str;\n   // If set, uses custom wrappers for memset/memcpy/memmove intinsics.\n   bool replace_intrin;\n-  // Used on Mac only. See comments in asan_mac.cc and asan_malloc_mac.cc.\n-  bool replace_cfallocator;\n   // Used on Mac only.\n   bool mac_ignore_invalid_free;\n   // ASan allocator flag. See asan_allocator.cc.\n@@ -77,6 +75,10 @@ struct Flags {\n   bool unmap_shadow_on_exit;\n   // If set, calls abort() instead of _exit() after printing an error report.\n   bool abort_on_error;\n+  // Print various statistics after printing an error message or if atexit=1.\n+  bool print_stats;\n+  // Print the legend for the shadow bytes.\n+  bool print_legend;\n   // If set, prints ASan exit stats even after program terminates successfully.\n   bool atexit;\n   // By default, disable core dumper on 64-bit - it makes little sense"}, {"sha": "7093c445588693259e4a84283422cc21d42984b7", "filename": "libsanitizer/asan/asan_globals.cc", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -16,7 +16,6 @@\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n #include \"asan_thread.h\"\n-#include \"sanitizer/asan_interface.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n \n namespace __asan {\n@@ -34,26 +33,20 @@ static ListOfGlobals *list_of_all_globals;\n static ListOfGlobals *list_of_dynamic_init_globals;\n \n void PoisonRedZones(const Global &g)  {\n-  uptr shadow_rz_size = kGlobalAndStackRedzone >> SHADOW_SCALE;\n-  CHECK(shadow_rz_size == 1 || shadow_rz_size == 2 || shadow_rz_size == 4);\n-  // full right redzone\n-  uptr g_aligned_size = kGlobalAndStackRedzone *\n-      ((g.size + kGlobalAndStackRedzone - 1) / kGlobalAndStackRedzone);\n-  PoisonShadow(g.beg + g_aligned_size,\n-               kGlobalAndStackRedzone, kAsanGlobalRedzoneMagic);\n-  if ((g.size % kGlobalAndStackRedzone) != 0) {\n+  uptr aligned_size = RoundUpTo(g.size, SHADOW_GRANULARITY);\n+  PoisonShadow(g.beg + aligned_size, g.size_with_redzone - aligned_size,\n+               kAsanGlobalRedzoneMagic);\n+  if (g.size != aligned_size) {\n     // partial right redzone\n-    u64 g_aligned_down_size = kGlobalAndStackRedzone *\n-        (g.size / kGlobalAndStackRedzone);\n-    CHECK(g_aligned_down_size == g_aligned_size - kGlobalAndStackRedzone);\n-    PoisonShadowPartialRightRedzone(g.beg + g_aligned_down_size,\n-                                    g.size % kGlobalAndStackRedzone,\n-                                    kGlobalAndStackRedzone,\n-                                    kAsanGlobalRedzoneMagic);\n+    PoisonShadowPartialRightRedzone(\n+        g.beg + RoundDownTo(g.size, SHADOW_GRANULARITY),\n+        g.size % SHADOW_GRANULARITY,\n+        SHADOW_GRANULARITY,\n+        kAsanGlobalRedzoneMagic);\n   }\n }\n \n-bool DescribeAddressIfGlobal(uptr addr) {\n+bool DescribeAddressIfGlobal(uptr addr, uptr size) {\n   if (!flags()->report_globals) return false;\n   BlockingMutexLock lock(&mu_for_globals);\n   bool res = false;\n@@ -62,7 +55,7 @@ bool DescribeAddressIfGlobal(uptr addr) {\n     if (flags()->report_globals >= 2)\n       Report(\"Search Global: beg=%p size=%zu name=%s\\n\",\n              (void*)g.beg, g.size, (char*)g.name);\n-    res |= DescribeAddressRelativeToGlobal(addr, g);\n+    res |= DescribeAddressRelativeToGlobal(addr, size, g);\n   }\n   return res;\n }"}, {"sha": "45c913c1894f3a963e93bb70b90bf2d668aaf623", "filename": "libsanitizer/asan/asan_intercepted_functions.h", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_intercepted_functions.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -17,6 +17,7 @@\n #include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n \n #include <stdarg.h>\n+#include <stddef.h>\n \n using __sanitizer::uptr;\n \n@@ -64,9 +65,7 @@ using __sanitizer::uptr;\n # define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 0\n #endif\n \n-// On Darwin siglongjmp tailcalls longjmp, so we don't want to intercept it\n-// there.\n-#if !defined(_WIN32) && (!defined(__APPLE__) || MAC_INTERPOSE_FUNCTIONS)\n+#if !defined(_WIN32)\n # define ASAN_INTERCEPT_SIGLONGJMP 1\n #else\n # define ASAN_INTERCEPT_SIGLONGJMP 0\n@@ -169,7 +168,8 @@ DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, pread64, int fd, void *buf,\n DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, write, int fd, void *ptr, SIZE_T count);\n # endif\n # if SANITIZER_INTERCEPT_PWRITE\n-DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, pwrite, int fd, void *ptr, SIZE_T count);\n+DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, pwrite,\n+                             int fd, void *ptr, SIZE_T count, OFF_T offset);\n # endif\n \n # if ASAN_INTERCEPT_MLOCKX\n@@ -193,6 +193,8 @@ DECLARE_FUNCTION_AND_WRAPPER(int, pthread_create,\n                              void *(*start_routine)(void*), void *arg);\n # endif\n \n+// stdio.h\n+# if SANITIZER_INTERCEPT_SCANF\n DECLARE_FUNCTION_AND_WRAPPER(int, vscanf, const char *format, va_list ap);\n DECLARE_FUNCTION_AND_WRAPPER(int, vsscanf, const char *str, const char *format,\n                              va_list ap);\n@@ -203,6 +205,18 @@ DECLARE_FUNCTION_AND_WRAPPER(int, fscanf,\n                              void* stream, const char *format, ...);\n DECLARE_FUNCTION_AND_WRAPPER(int, sscanf,  // NOLINT\n                              const char *str, const char *format, ...);\n+DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_vscanf, const char *format,\n+                             va_list ap);\n+DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_vsscanf, const char *str,\n+                             const char *format, va_list ap);\n+DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_vfscanf, void *stream,\n+                             const char *format, va_list ap);\n+DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_scanf, const char *format, ...);\n+DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_fscanf,\n+                             void* stream, const char *format, ...);\n+DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_sscanf,  // NOLINT\n+                             const char *str, const char *format, ...);\n+# endif\n \n # if defined(__APPLE__)\n typedef void* pthread_workqueue_t;\n@@ -231,7 +245,7 @@ DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_group_async_f,\n                              dispatch_group_t group, dispatch_queue_t dq,\n                              void *ctxt, dispatch_function_t func);\n \n-#  if MAC_INTERPOSE_FUNCTIONS && !defined(MISSING_BLOCKS_SUPPORT)\n+#  if !defined(MISSING_BLOCKS_SUPPORT)\n DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_group_async,\n                              dispatch_group_t dg,\n                              dispatch_queue_t dq, void (^work)(void));\n@@ -243,7 +257,7 @@ DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_source_set_event_handler,\n                              dispatch_source_t ds, void (^work)(void));\n DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_source_set_cancel_handler,\n                              dispatch_source_t ds, void (^work)(void));\n-#  endif  // MAC_INTERPOSE_FUNCTIONS\n+#  endif  // MISSING_BLOCKS_SUPPORT\n \n typedef void malloc_zone_t;\n typedef size_t vm_size_t;"}, {"sha": "f4c56830d8ae5b57a6ef206140b84040f024704c", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 16, "deletions": 38, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -20,7 +20,6 @@\n #include \"asan_stats.h\"\n #include \"asan_thread_registry.h\"\n #include \"interception/interception.h\"\n-#include \"sanitizer/asan_interface.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n namespace __asan {\n@@ -30,12 +29,14 @@ namespace __asan {\n // that no extra frames are created, and stack trace contains\n // relevant information only.\n // We check all shadow bytes.\n-#define ACCESS_MEMORY_RANGE(offset, size, isWrite) do {                  \\\n-  if (uptr __ptr = __asan_region_is_poisoned((uptr)(offset), size)) {    \\\n-    GET_CURRENT_PC_BP_SP;                                                \\\n-    __asan_report_error(pc, bp, sp, __ptr, isWrite, /* access_size */1); \\\n-  }                                                                      \\\n-} while (0)\n+#define ACCESS_MEMORY_RANGE(offset, size, isWrite) do {                 \\\n+    uptr __offset = (uptr)(offset);                                     \\\n+    uptr __size = (uptr)(size);                                         \\\n+    if (__asan_region_is_poisoned(__offset, __size)) {                  \\\n+      GET_CURRENT_PC_BP_SP;                                             \\\n+      __asan_report_error(pc, bp, sp, __offset, isWrite, __size);       \\\n+    }                                                                   \\\n+  } while (0)\n \n #define ASAN_READ_RANGE(offset, size) ACCESS_MEMORY_RANGE(offset, size, false)\n #define ASAN_WRITE_RANGE(offset, size) ACCESS_MEMORY_RANGE(offset, size, true);\n@@ -275,13 +276,9 @@ INTERCEPTOR(void*, memcpy, void *to, const void *from, uptr size) {\n     ASAN_READ_RANGE(from, size);\n     ASAN_WRITE_RANGE(to, size);\n   }\n-#if MAC_INTERPOSE_FUNCTIONS\n   // Interposing of resolver functions is broken on Mac OS 10.7 and 10.8.\n   // See also http://code.google.com/p/address-sanitizer/issues/detail?id=116.\n   return internal_memcpy(to, from, size);\n-#else\n-  return REAL(memcpy)(to, from, size);\n-#endif\n }\n \n INTERCEPTOR(void*, memmove, void *to, const void *from, uptr size) {\n@@ -294,13 +291,9 @@ INTERCEPTOR(void*, memmove, void *to, const void *from, uptr size) {\n     ASAN_READ_RANGE(from, size);\n     ASAN_WRITE_RANGE(to, size);\n   }\n-#if MAC_INTERPOSE_FUNCTIONS\n   // Interposing of resolver functions is broken on Mac OS 10.7 and 10.8.\n   // See also http://code.google.com/p/address-sanitizer/issues/detail?id=116.\n   return internal_memmove(to, from, size);\n-#else\n-  return REAL(memmove)(to, from, size);\n-#endif\n }\n \n INTERCEPTOR(void*, memset, void *block, int c, uptr size) {\n@@ -398,7 +391,7 @@ INTERCEPTOR(int, strcmp, const char *s1, const char *s2) {\n }\n \n INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n-#if MAC_INTERPOSE_FUNCTIONS\n+#if defined(__APPLE__)\n   if (!asan_inited) return REAL(strcpy)(to, from);  // NOLINT\n #endif\n   // strcpy is called from malloc_default_purgeable_zone()\n@@ -418,7 +411,7 @@ INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n \n #if ASAN_INTERCEPT_STRDUP\n INTERCEPTOR(char*, strdup, const char *s) {\n-#if MAC_INTERPOSE_FUNCTIONS\n+#if defined(__APPLE__)\n   // FIXME: because internal_strdup() uses InternalAlloc(), which currently\n   // just calls malloc() on Mac, we can't use internal_strdup() with the\n   // dynamic runtime. We can remove the call to REAL(strdup) once InternalAlloc\n@@ -559,7 +552,7 @@ INTERCEPTOR(long, strtol, const char *nptr,  // NOLINT\n }\n \n INTERCEPTOR(int, atoi, const char *nptr) {\n-#if MAC_INTERPOSE_FUNCTIONS\n+#if defined(__APPLE__)\n   if (!asan_inited) return REAL(atoi)(nptr);\n #endif\n   ENSURE_ASAN_INITED();\n@@ -578,7 +571,7 @@ INTERCEPTOR(int, atoi, const char *nptr) {\n }\n \n INTERCEPTOR(long, atol, const char *nptr) {  // NOLINT\n-#if MAC_INTERPOSE_FUNCTIONS\n+#if defined(__APPLE__)\n   if (!asan_inited) return REAL(atol)(nptr);\n #endif\n   ENSURE_ASAN_INITED();\n@@ -659,10 +652,9 @@ void InitializeAsanInterceptors() {\n   static bool was_called_once;\n   CHECK(was_called_once == false);\n   was_called_once = true;\n-#if MAC_INTERPOSE_FUNCTIONS\n+#if defined(__APPLE__)\n   return;\n-#endif\n-\n+#else\n   SANITIZER_COMMON_INTERCEPTORS_INIT;\n \n   // Intercept mem* functions.\n@@ -671,12 +663,6 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(memset);\n   if (PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE) {\n     ASAN_INTERCEPT_FUNC(memcpy);\n-  } else {\n-#if !MAC_INTERPOSE_FUNCTIONS\n-    // If we're using dynamic interceptors on Mac, these two are just plain\n-    // functions.\n-    internal_memcpy(&REAL(memcpy), &REAL(memmove), sizeof(REAL(memmove)));\n-#endif\n   }\n \n   // Intercept str* functions.\n@@ -698,12 +684,8 @@ void InitializeAsanInterceptors() {\n #if ASAN_INTERCEPT_STRNLEN\n   ASAN_INTERCEPT_FUNC(strnlen);\n #endif\n-#if ASAN_INTERCEPT_INDEX\n-# if ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX\n+#if ASAN_INTERCEPT_INDEX && ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX\n   ASAN_INTERCEPT_FUNC(index);\n-# else\n-  CHECK(OVERRIDE_FUNCTION(index, WRAP(strchr)));\n-# endif\n #endif\n \n   ASAN_INTERCEPT_FUNC(atoi);\n@@ -753,14 +735,10 @@ void InitializeAsanInterceptors() {\n   InitializeWindowsInterceptors();\n #endif\n \n-  // Some Mac-specific interceptors.\n-#if defined(__APPLE__)\n-  InitializeMacInterceptors();\n-#endif\n-\n   if (flags()->verbosity > 0) {\n     Report(\"AddressSanitizer: libc interceptors initialized\\n\");\n   }\n+#endif  // __APPLE__\n }\n \n }  // namespace __asan"}, {"sha": "cae4c7f01258f031ad596b337276d403f42fc501", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -30,9 +30,6 @@ DECLARE_REAL(int, sigaction, int signum, const struct sigaction *act,\n namespace __asan {\n \n void InitializeAsanInterceptors();\n-#if defined(__APPLE__)\n-void InitializeMacInterceptors();\n-#endif  // __APPLE__\n \n }  // namespace __asan\n "}, {"sha": "2fd58b856bcf974b0403aac268965b005710380d", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -0,0 +1,133 @@\n+//===-- asan_interface_internal.h -------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// This header can be included by the instrumented program to fetch\n+// data (mostly allocator statistics) from ASan runtime library.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_INTERFACE_INTERNAL_H\n+#define ASAN_INTERFACE_INTERNAL_H\n+\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n+\n+using __sanitizer::uptr;\n+\n+extern \"C\" {\n+  // This function should be called at the very beginning of the process,\n+  // before any instrumented code is executed and before any call to malloc.\n+  // Everytime the asan ABI changes we also change the version number in this\n+  // name. Objects build with incompatible asan ABI version\n+  // will not link with run-time.\n+  void __asan_init_v1() SANITIZER_INTERFACE_ATTRIBUTE;\n+  #define __asan_init __asan_init_v1\n+\n+  // This structure describes an instrumented global variable.\n+  struct __asan_global {\n+    uptr beg;                // The address of the global.\n+    uptr size;               // The original size of the global.\n+    uptr size_with_redzone;  // The size with the redzone.\n+    const char *name;        // Name as a C string.\n+    uptr has_dynamic_init;   // Non-zero if the global has dynamic initializer.\n+  };\n+\n+  // These two functions should be called by the instrumented code.\n+  // 'globals' is an array of structures describing 'n' globals.\n+  void __asan_register_globals(__asan_global *globals, uptr n)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_unregister_globals(__asan_global *globals, uptr n)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // These two functions should be called before and after dynamic initializers\n+  // run, respectively.  They should be called with parameters describing all\n+  // dynamically initialized globals defined in the calling TU.\n+  void __asan_before_dynamic_init(uptr first_addr, uptr last_addr)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_after_dynamic_init()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // These two functions are used by the instrumented code in the\n+  // use-after-return mode. __asan_stack_malloc allocates size bytes of\n+  // fake stack and __asan_stack_free poisons it. real_stack is a pointer to\n+  // the real stack region.\n+  uptr __asan_stack_malloc(uptr size, uptr real_stack)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_stack_free(uptr ptr, uptr size, uptr real_stack)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // These two functions are used by instrumented code in the\n+  // use-after-scope mode. They mark memory for local variables as\n+  // unaddressable when they leave scope and addressable before the\n+  // function exits.\n+  void __asan_poison_stack_memory(uptr addr, uptr size)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_unpoison_stack_memory(uptr addr, uptr size)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // Performs cleanup before a NoReturn function. Must be called before things\n+  // like _exit and execl to avoid false positives on stack.\n+  void __asan_handle_no_return() SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  void __asan_poison_memory_region(void const volatile *addr, uptr size)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_unpoison_memory_region(void const volatile *addr, uptr size)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  bool __asan_address_is_poisoned(void const volatile *addr)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  uptr __asan_region_is_poisoned(uptr beg, uptr size)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  void __asan_describe_address(uptr addr)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  void __asan_report_error(uptr pc, uptr bp, uptr sp,\n+                           uptr addr, bool is_write, uptr access_size)\n+    SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  int __asan_set_error_exit_code(int exit_code)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_set_death_callback(void (*callback)(void))\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_set_error_report_callback(void (*callback)(const char*))\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  /* OPTIONAL */ void __asan_on_error()\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  /* OPTIONAL */ bool __asan_symbolize(const void *pc, char *out_buffer,\n+                                       int out_size)\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  uptr __asan_get_estimated_allocated_size(uptr size)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  bool __asan_get_ownership(const void *p)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  uptr __asan_get_allocated_size(const void *p)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  uptr __asan_get_current_allocated_bytes()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  uptr __asan_get_heap_size()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  uptr __asan_get_free_bytes()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  uptr __asan_get_unmapped_bytes()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_print_accumulated_stats()\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  /* OPTIONAL */ const char* __asan_default_options()\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  /* OPTIONAL */ void __asan_malloc_hook(void *ptr, uptr size)\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+  /* OPTIONAL */ void __asan_free_hook(void *ptr)\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+}  // extern \"C\"\n+\n+#endif  // ASAN_INTERFACE_INTERNAL_H"}, {"sha": "0fe620e2e4c5cfa260483590413162cbe6429126", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -13,6 +13,7 @@\n #define ASAN_INTERNAL_H\n \n #include \"asan_flags.h\"\n+#include \"asan_interface_internal.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\""}, {"sha": "c5fc7de10c036dde9af144dec2a38da606b25bd3", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 4, "deletions": 77, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -89,10 +89,9 @@ static const char kDyldInsertLibraries[] = \"DYLD_INSERT_LIBRARIES\";\n \n void MaybeReexec() {\n   if (!flags()->allow_reexec) return;\n-#if MAC_INTERPOSE_FUNCTIONS\n-  // If the program is linked with the dynamic ASan runtime library, make sure\n-  // the library is preloaded so that the wrappers work. If it is not, set\n-  // DYLD_INSERT_LIBRARIES and re-exec ourselves.\n+  // Make sure the dynamic ASan runtime library is preloaded so that the\n+  // wrappers work. If it is not, set DYLD_INSERT_LIBRARIES and re-exec\n+  // ourselves.\n   Dl_info info;\n   CHECK(dladdr((void*)((uptr)__asan_init), &info));\n   const char *dyld_insert_libraries = GetEnv(kDyldInsertLibraries);\n@@ -114,8 +113,6 @@ void MaybeReexec() {\n     }\n     execv(program_name, *_NSGetArgv());\n   }\n-#endif  // MAC_INTERPOSE_FUNCTIONS\n-  // If we're not using the dynamic runtime, do nothing.\n }\n \n // No-op. Mac does not support static linkage anyway.\n@@ -146,57 +143,6 @@ void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n \n-// The range of pages to be used for escape islands.\n-// TODO(glider): instead of mapping a fixed range we must find a range of\n-// unmapped pages in vmmap and take them.\n-// These constants were chosen empirically and may not work if the shadow\n-// memory layout changes. Unfortunately they do necessarily depend on\n-// kHighMemBeg or kHighMemEnd.\n-static void *island_allocator_pos = 0;\n-\n-#if SANITIZER_WORDSIZE == 32\n-# define kIslandEnd (0xffdf0000 - GetPageSizeCached())\n-# define kIslandBeg (kIslandEnd - 256 * GetPageSizeCached())\n-#else\n-# define kIslandEnd (0x7fffffdf0000 - GetPageSizeCached())\n-# define kIslandBeg (kIslandEnd - 256 * GetPageSizeCached())\n-#endif\n-\n-extern \"C\"\n-mach_error_t __interception_allocate_island(void **ptr,\n-                                            uptr unused_size,\n-                                            void *unused_hint) {\n-  if (!island_allocator_pos) {\n-    island_allocator_pos =\n-        internal_mmap((void*)kIslandBeg, kIslandEnd - kIslandBeg,\n-                      PROT_READ | PROT_WRITE | PROT_EXEC,\n-                      MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n-                      -1, 0);\n-    if (island_allocator_pos != (void*)kIslandBeg) {\n-      return KERN_NO_SPACE;\n-    }\n-    if (flags()->verbosity) {\n-      Report(\"Mapped pages %p--%p for branch islands.\\n\",\n-             (void*)kIslandBeg, (void*)kIslandEnd);\n-    }\n-    // Should not be very performance-critical.\n-    internal_memset(island_allocator_pos, 0xCC, kIslandEnd - kIslandBeg);\n-  };\n-  *ptr = island_allocator_pos;\n-  island_allocator_pos = (char*)island_allocator_pos + GetPageSizeCached();\n-  if (flags()->verbosity) {\n-    Report(\"Branch island allocated at %p\\n\", *ptr);\n-  }\n-  return err_none;\n-}\n-\n-extern \"C\"\n-mach_error_t __interception_deallocate_island(void *ptr) {\n-  // Do nothing.\n-  // TODO(glider): allow to free and reuse the island memory.\n-  return err_none;\n-}\n-\n // Support for the following functions from libdispatch on Mac OS:\n //   dispatch_async_f()\n //   dispatch_async()\n@@ -350,14 +296,7 @@ INTERCEPTOR(void, dispatch_group_async_f, dispatch_group_t group,\n                                asan_dispatch_call_block_and_release);\n }\n \n-#if MAC_INTERPOSE_FUNCTIONS && !defined(MISSING_BLOCKS_SUPPORT)\n-// dispatch_async, dispatch_group_async and others tailcall the corresponding\n-// dispatch_*_f functions. When wrapping functions with mach_override, those\n-// dispatch_*_f are intercepted automatically. But with dylib interposition\n-// this does not work, because the calls within the same library are not\n-// interposed.\n-// Therefore we need to re-implement dispatch_async and friends.\n-\n+#if !defined(MISSING_BLOCKS_SUPPORT)\n extern \"C\" {\n // FIXME: consolidate these declarations with asan_intercepted_functions.h.\n void dispatch_async(dispatch_queue_t dq, void(^work)(void));\n@@ -410,16 +349,4 @@ INTERCEPTOR(void, dispatch_source_set_event_handler,\n }\n #endif\n \n-namespace __asan {\n-\n-void InitializeMacInterceptors() {\n-  CHECK(INTERCEPT_FUNCTION(dispatch_async_f));\n-  CHECK(INTERCEPT_FUNCTION(dispatch_sync_f));\n-  CHECK(INTERCEPT_FUNCTION(dispatch_after_f));\n-  CHECK(INTERCEPT_FUNCTION(dispatch_barrier_async_f));\n-  CHECK(INTERCEPT_FUNCTION(dispatch_group_async_f));\n-}\n-\n-}  // namespace __asan\n-\n #endif  // __APPLE__"}, {"sha": "18e6a3be865ce82b131a883680d23fc18c6d95ae", "filename": "libsanitizer/asan/asan_malloc_linux.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -18,7 +18,6 @@\n #include \"asan_internal.h\"\n #include \"asan_stack.h\"\n #include \"asan_thread_registry.h\"\n-#include \"sanitizer/asan_interface.h\"\n \n #if ASAN_ANDROID\n DECLARE_REAL_AND_INTERCEPTOR(void*, malloc, uptr size)"}, {"sha": "3e7fc6bd43b40a3f26247240f960c99bcdf82631", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -1,5 +1,7 @@\n //===-- asan_mapping.h ------------------------------------------*- C++ -*-===//\n //\n+//                     The LLVM Compiler Infrastructure\n+//\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n //\n@@ -34,27 +36,20 @@ extern SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_mapping_offset;\n #   if defined(__powerpc64__)\n #    define SHADOW_OFFSET (1ULL << 41)\n #   else\n-#    define SHADOW_OFFSET (1ULL << 44)\n+#    if ASAN_MAC\n+#     define SHADOW_OFFSET (1ULL << 44)\n+#    else\n+#     define SHADOW_OFFSET 0x7fff8000ULL\n+#    endif\n #   endif\n #  endif\n # endif\n #endif  // ASAN_FLEXIBLE_MAPPING_AND_OFFSET\n \n #define SHADOW_GRANULARITY (1ULL << SHADOW_SCALE)\n-#define MEM_TO_SHADOW(mem) (((mem) >> SHADOW_SCALE) | (SHADOW_OFFSET))\n+#define MEM_TO_SHADOW(mem) (((mem) >> SHADOW_SCALE) + (SHADOW_OFFSET))\n #define SHADOW_TO_MEM(shadow) (((shadow) - SHADOW_OFFSET) << SHADOW_SCALE)\n \n-#if SANITIZER_WORDSIZE == 64\n-# if defined(__powerpc64__)\n-  static const uptr kHighMemEnd = 0x00000fffffffffffUL;\n-# else\n-  static const uptr kHighMemEnd = 0x00007fffffffffffUL;\n-# endif\n-#else  // SANITIZER_WORDSIZE == 32\n-  static const uptr kHighMemEnd = 0xffffffff;\n-#endif  // SANITIZER_WORDSIZE\n-\n-\n #define kLowMemBeg      0\n #define kLowMemEnd      (SHADOW_OFFSET ? SHADOW_OFFSET - 1 : 0)\n \n@@ -74,11 +69,11 @@ extern SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_mapping_offset;\n                                        : kZeroBaseShadowStart)\n #define kShadowGapEnd   (kHighShadowBeg - 1)\n \n-#define kGlobalAndStackRedzone \\\n-      (SHADOW_GRANULARITY < 32 ? 32 : SHADOW_GRANULARITY)\n-\n namespace __asan {\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n+extern uptr kHighMemEnd;  // Initialized in __asan_init.\n+\n static inline bool AddrIsInLowMem(uptr a) {\n   return a < kLowMemEnd;\n }"}, {"sha": "fd47eee42058e79bb33a672d3b5daac7f9b9342b", "filename": "libsanitizer/asan/asan_new_delete.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -25,9 +25,9 @@ void ReplaceOperatorsNewAndDelete() { }\n \n using namespace __asan;  // NOLINT\n \n-// On Mac and Android new() goes through malloc interceptors.\n+// On Android new() goes through malloc interceptors.\n // See also https://code.google.com/p/address-sanitizer/issues/detail?id=131.\n-#if !ASAN_ANDROID && !ASAN_MAC\n+#if !ASAN_ANDROID\n \n // Fake std::nothrow_t to avoid including <new>.\n namespace std {"}, {"sha": "7e930034bef0cdcd17c4d7462de0135e7e5266f7", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -13,7 +13,6 @@\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n-#include \"sanitizer/asan_interface.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n namespace __asan {"}, {"sha": "663e8f3b74888303877969e7d4a9a19a8d65795b", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 71, "deletions": 33, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -118,19 +118,7 @@ static void PrintShadowBytes(const char *before, u8 *bytes,\n   Printf(\"\\n\");\n }\n \n-static void PrintShadowMemoryForAddress(uptr addr) {\n-  if (!AddrIsInMem(addr))\n-    return;\n-  uptr shadow_addr = MemToShadow(addr);\n-  const uptr n_bytes_per_row = 16;\n-  uptr aligned_shadow = shadow_addr & ~(n_bytes_per_row - 1);\n-  Printf(\"Shadow bytes around the buggy address:\\n\");\n-  for (int i = -5; i <= 5; i++) {\n-    const char *prefix = (i == 0) ? \"=>\" : \"  \";\n-    PrintShadowBytes(prefix,\n-                     (u8*)(aligned_shadow + i * n_bytes_per_row),\n-                     (u8*)shadow_addr, n_bytes_per_row);\n-  }\n+static void PrintLegend() {\n   Printf(\"Shadow byte legend (one shadow byte represents %d \"\n          \"application bytes):\\n\", (int)SHADOW_GRANULARITY);\n   PrintShadowByte(\"  Addressable:           \", 0);\n@@ -153,6 +141,23 @@ static void PrintShadowMemoryForAddress(uptr addr) {\n   PrintShadowByte(\"  ASan internal:         \", kAsanInternalHeapMagic);\n }\n \n+static void PrintShadowMemoryForAddress(uptr addr) {\n+  if (!AddrIsInMem(addr))\n+    return;\n+  uptr shadow_addr = MemToShadow(addr);\n+  const uptr n_bytes_per_row = 16;\n+  uptr aligned_shadow = shadow_addr & ~(n_bytes_per_row - 1);\n+  Printf(\"Shadow bytes around the buggy address:\\n\");\n+  for (int i = -5; i <= 5; i++) {\n+    const char *prefix = (i == 0) ? \"=>\" : \"  \";\n+    PrintShadowBytes(prefix,\n+                     (u8*)(aligned_shadow + i * n_bytes_per_row),\n+                     (u8*)shadow_addr, n_bytes_per_row);\n+  }\n+  if (flags()->print_legend)\n+    PrintLegend();\n+}\n+\n static void PrintZoneForPointer(uptr ptr, uptr zone_ptr,\n                                 const char *zone_name) {\n   if (zone_ptr) {\n@@ -183,18 +188,23 @@ static void PrintGlobalNameIfASCII(const __asan_global &g) {\n   Printf(\"  '%s' is ascii string '%s'\\n\", g.name, (char*)g.beg);\n }\n \n-bool DescribeAddressRelativeToGlobal(uptr addr, const __asan_global &g) {\n-  if (addr < g.beg - kGlobalAndStackRedzone) return false;\n+bool DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n+                                     const __asan_global &g) {\n+  static const uptr kMinimalDistanceFromAnotherGlobal = 64;\n+  if (addr <= g.beg - kMinimalDistanceFromAnotherGlobal) return false;\n   if (addr >= g.beg + g.size_with_redzone) return false;\n   Decorator d;\n   Printf(\"%s\", d.Location());\n-  Printf(\"%p is located \", (void*)addr);\n   if (addr < g.beg) {\n-    Printf(\"%zd bytes to the left\", g.beg - addr);\n-  } else if (addr >= g.beg + g.size) {\n-    Printf(\"%zd bytes to the right\", addr - (g.beg + g.size));\n+    Printf(\"%p is located %zd bytes to the left\", (void*)addr, g.beg - addr);\n+  } else if (addr + size > g.beg + g.size) {\n+    if (addr < g.beg + g.size)\n+      addr = g.beg + g.size;\n+    Printf(\"%p is located %zd bytes to the right\", (void*)addr,\n+           addr - (g.beg + g.size));\n   } else {\n-    Printf(\"%zd bytes inside\", addr - g.beg);  // Can it happen?\n+    // Can it happen?\n+    Printf(\"%p is located %zd bytes inside\", (void*)addr, addr - g.beg);\n   }\n   Printf(\" of global variable '%s' (0x%zx) of size %zu\\n\",\n              g.name, g.beg, g.size);\n@@ -280,18 +290,22 @@ bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n \n static void DescribeAccessToHeapChunk(AsanChunkView chunk, uptr addr,\n                                       uptr access_size) {\n-  uptr offset;\n+  sptr offset;\n   Decorator d;\n   Printf(\"%s\", d.Location());\n-  Printf(\"%p is located \", (void*)addr);\n-  if (chunk.AddrIsInside(addr, access_size, &offset)) {\n-    Printf(\"%zu bytes inside of\", offset);\n-  } else if (chunk.AddrIsAtLeft(addr, access_size, &offset)) {\n-    Printf(\"%zu bytes to the left of\", offset);\n+  if (chunk.AddrIsAtLeft(addr, access_size, &offset)) {\n+    Printf(\"%p is located %zd bytes to the left of\", (void*)addr, offset);\n   } else if (chunk.AddrIsAtRight(addr, access_size, &offset)) {\n-    Printf(\"%zu bytes to the right of\", offset);\n+    if (offset < 0) {\n+      addr -= offset;\n+      offset = 0;\n+    }\n+    Printf(\"%p is located %zd bytes to the right of\", (void*)addr, offset);\n+  } else if (chunk.AddrIsInside(addr, access_size, &offset)) {\n+    Printf(\"%p is located %zd bytes inside of\", (void*)addr, offset);\n   } else {\n-    Printf(\" somewhere around (this is AddressSanitizer bug!)\");\n+    Printf(\"%p is located somewhere around (this is AddressSanitizer bug!)\",\n+           (void*)addr);\n   }\n   Printf(\" %zu-byte region [%p,%p)\\n\", chunk.UsedSize(),\n          (void*)(chunk.Beg()), (void*)(chunk.End()));\n@@ -364,7 +378,7 @@ void DescribeAddress(uptr addr, uptr access_size) {\n   if (DescribeAddressIfShadow(addr))\n     return;\n   CHECK(AddrIsInMem(addr));\n-  if (DescribeAddressIfGlobal(addr))\n+  if (DescribeAddressIfGlobal(addr, access_size))\n     return;\n   if (DescribeAddressIfStack(addr, access_size))\n     return;\n@@ -443,7 +457,8 @@ class ScopedInErrorReport {\n       DescribeThread(curr_thread->summary());\n     }\n     // Print memory stats.\n-    __asan_print_accumulated_stats();\n+    if (flags()->print_stats)\n+      __asan_print_accumulated_stats();\n     if (error_report_callback) {\n       error_report_callback(error_message_buffer);\n     }\n@@ -452,6 +467,20 @@ class ScopedInErrorReport {\n   }\n };\n \n+static void ReportSummary(const char *error_type, StackTrace *stack) {\n+  if (!stack->size) return;\n+  if (IsSymbolizerAvailable()) {\n+    AddressInfo ai;\n+    // Currently, we include the first stack frame into the report summary.\n+    // Maybe sometimes we need to choose another frame (e.g. skip memcpy/etc).\n+    SymbolizeCode(stack->trace[0], &ai, 1);\n+    ReportErrorSummary(error_type,\n+                       StripPathPrefix(ai.file, flags()->strip_path_prefix),\n+                       ai.line, ai.function);\n+  }\n+  // FIXME: do we need to print anything at all if there is no symbolizer?\n+}\n+\n void ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n@@ -464,6 +493,7 @@ void ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr) {\n   Printf(\"AddressSanitizer can not provide additional info.\\n\");\n   GET_STACK_TRACE_FATAL(pc, bp);\n   PrintStack(&stack);\n+  ReportSummary(\"SEGV\", &stack);\n }\n \n void ReportDoubleFree(uptr addr, StackTrace *stack) {\n@@ -474,6 +504,7 @@ void ReportDoubleFree(uptr addr, StackTrace *stack) {\n   Printf(\"%s\", d.EndWarning());\n   PrintStack(stack);\n   DescribeHeapAddress(addr, 1);\n+  ReportSummary(\"double-free\", stack);\n }\n \n void ReportFreeNotMalloced(uptr addr, StackTrace *stack) {\n@@ -485,6 +516,7 @@ void ReportFreeNotMalloced(uptr addr, StackTrace *stack) {\n   Printf(\"%s\", d.EndWarning());\n   PrintStack(stack);\n   DescribeHeapAddress(addr, 1);\n+  ReportSummary(\"bad-free\", stack);\n }\n \n void ReportAllocTypeMismatch(uptr addr, StackTrace *stack,\n@@ -503,6 +535,7 @@ void ReportAllocTypeMismatch(uptr addr, StackTrace *stack,\n   Printf(\"%s\", d.EndWarning());\n   PrintStack(stack);\n   DescribeHeapAddress(addr, 1);\n+  ReportSummary(\"alloc-dealloc-mismatch\", stack);\n   Report(\"HINT: if you don't care about these warnings you may set \"\n          \"ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n\");\n }\n@@ -517,6 +550,7 @@ void ReportMallocUsableSizeNotOwned(uptr addr, StackTrace *stack) {\n   Printf(\"%s\", d.EndWarning());\n   PrintStack(stack);\n   DescribeHeapAddress(addr, 1);\n+  ReportSummary(\"bad-malloc_usable_size\", stack);\n }\n \n void ReportAsanGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack) {\n@@ -529,21 +563,25 @@ void ReportAsanGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack) {\n   Printf(\"%s\", d.EndWarning());\n   PrintStack(stack);\n   DescribeHeapAddress(addr, 1);\n+  ReportSummary(\"bad-__asan_get_allocated_size\", stack);\n }\n \n void ReportStringFunctionMemoryRangesOverlap(\n     const char *function, const char *offset1, uptr length1,\n     const char *offset2, uptr length2, StackTrace *stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n+  char bug_type[100];\n+  internal_snprintf(bug_type, sizeof(bug_type), \"%s-param-overlap\", function);\n   Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: %s-param-overlap: \"\n+  Report(\"ERROR: AddressSanitizer: %s: \"\n              \"memory ranges [%p,%p) and [%p, %p) overlap\\n\", \\\n-             function, offset1, offset1 + length1, offset2, offset2 + length2);\n+             bug_type, offset1, offset1 + length1, offset2, offset2 + length2);\n   Printf(\"%s\", d.EndWarning());\n   PrintStack(stack);\n   DescribeAddress((uptr)offset1, length1);\n   DescribeAddress((uptr)offset2, length2);\n+  ReportSummary(bug_type, stack);\n }\n \n // ----------------------- Mac-specific reports ----------------- {{{1\n@@ -653,7 +691,7 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp,\n   PrintStack(&stack);\n \n   DescribeAddress(addr, access_size);\n-\n+  ReportSummary(bug_descr, &stack);\n   PrintShadowMemoryForAddress(addr);\n }\n "}, {"sha": "13724dab9eead8a17444f81e8a10bfffd31ef293", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -13,15 +13,15 @@\n #include \"asan_allocator.h\"\n #include \"asan_internal.h\"\n #include \"asan_thread.h\"\n-#include \"sanitizer/asan_interface.h\"\n \n namespace __asan {\n \n // The following functions prints address description depending\n // on the memory type (shadow/heap/stack/global).\n void DescribeHeapAddress(uptr addr, uptr access_size);\n-bool DescribeAddressIfGlobal(uptr addr);\n-bool DescribeAddressRelativeToGlobal(uptr addr, const __asan_global &g);\n+bool DescribeAddressIfGlobal(uptr addr, uptr access_size);\n+bool DescribeAddressRelativeToGlobal(uptr addr, uptr access_size,\n+                                     const __asan_global &g);\n bool DescribeAddressIfShadow(uptr addr);\n bool DescribeAddressIfStack(uptr addr, uptr access_size);\n // Determines memory type on its own."}, {"sha": "175d37788c2920dd816be18151132319a45ea149", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -18,7 +18,6 @@\n #include \"asan_stats.h\"\n #include \"asan_thread.h\"\n #include \"asan_thread_registry.h\"\n-#include \"sanitizer/asan_interface.h\"\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n@@ -83,7 +82,6 @@ static void ParseFlagsFromString(Flags *f, const char *str) {\n \n   ParseFlag(str, &f->replace_str, \"replace_str\");\n   ParseFlag(str, &f->replace_intrin, \"replace_intrin\");\n-  ParseFlag(str, &f->replace_cfallocator, \"replace_cfallocator\");\n   ParseFlag(str, &f->mac_ignore_invalid_free, \"mac_ignore_invalid_free\");\n   ParseFlag(str, &f->use_fake_stack, \"use_fake_stack\");\n   ParseFlag(str, &f->max_malloc_fill_size, \"max_malloc_fill_size\");\n@@ -95,6 +93,8 @@ static void ParseFlagsFromString(Flags *f, const char *str) {\n   ParseFlag(str, &f->check_malloc_usable_size, \"check_malloc_usable_size\");\n   ParseFlag(str, &f->unmap_shadow_on_exit, \"unmap_shadow_on_exit\");\n   ParseFlag(str, &f->abort_on_error, \"abort_on_error\");\n+  ParseFlag(str, &f->print_stats, \"print_stats\");\n+  ParseFlag(str, &f->print_legend, \"print_legend\");\n   ParseFlag(str, &f->atexit, \"atexit\");\n   ParseFlag(str, &f->disable_core, \"disable_core\");\n   ParseFlag(str, &f->strip_path_prefix, \"strip_path_prefix\");\n@@ -121,7 +121,6 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->malloc_context_size = kDeafultMallocContextSize;\n   f->replace_str = true;\n   f->replace_intrin = true;\n-  f->replace_cfallocator = true;\n   f->mac_ignore_invalid_free = false;\n   f->use_fake_stack = true;\n   f->max_malloc_fill_size = 0;\n@@ -133,6 +132,8 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->check_malloc_usable_size = true;\n   f->unmap_shadow_on_exit = false;\n   f->abort_on_error = false;\n+  f->print_stats = false;\n+  f->print_legend = true;\n   f->atexit = false;\n   f->disable_core = (SANITIZER_WORDSIZE == 64);\n   f->strip_path_prefix = \"\";\n@@ -142,9 +143,7 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->fast_unwind_on_fatal = false;\n   f->fast_unwind_on_malloc = true;\n   f->poison_heap = true;\n-  // Turn off alloc/dealloc mismatch checker on Mac for now.\n-  // TODO(glider): Fix known issues and enable this back.\n-  f->alloc_dealloc_mismatch = (ASAN_MAC == 0);\n+  f->alloc_dealloc_mismatch = true;\n   f->use_stack_depot = true;  // Only affects allocator2.\n \n   // Override from user-specified string.\n@@ -162,6 +161,7 @@ void InitializeFlags(Flags *f, const char *env) {\n int asan_inited;\n bool asan_init_is_running;\n void (*death_callback)(void);\n+uptr kHighMemEnd;\n \n // -------------------------- Misc ---------------- {{{1\n void ShowStatsAndAbort() {\n@@ -261,6 +261,24 @@ static void asan_atexit() {\n   __asan_print_accumulated_stats();\n }\n \n+static void InitializeHighMemEnd() {\n+#if SANITIZER_WORDSIZE == 64\n+# if defined(__powerpc64__)\n+  // FIXME:\n+  // On PowerPC64 we have two different address space layouts: 44- and 46-bit.\n+  // We somehow need to figure our which one we are using now and choose\n+  // one of 0x00000fffffffffffUL and 0x00003fffffffffffUL.\n+  // Note that with 'ulimit -s unlimited' the stack is moved away from the top\n+  // of the address space, so simply checking the stack address is not enough.\n+  kHighMemEnd = (1ULL << 44) - 1;  // 0x00000fffffffffffUL\n+# else\n+  kHighMemEnd = (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n+# endif\n+#else  // SANITIZER_WORDSIZE == 32\n+  kHighMemEnd = (1ULL << 32) - 1;  // 0xffffffff;\n+#endif  // SANITIZER_WORDSIZE\n+}\n+\n }  // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n@@ -295,8 +313,10 @@ void NOINLINE __asan_set_death_callback(void (*callback)(void)) {\n \n void __asan_init() {\n   if (asan_inited) return;\n+  SanitizerToolName = \"AddressSanitizer\";\n   CHECK(!asan_init_is_running && \"ASan init calls itself!\");\n   asan_init_is_running = true;\n+  InitializeHighMemEnd();\n \n   // Make sure we are not statically linked.\n   AsanDoesNotSupportStaticLinkage();\n@@ -400,6 +420,8 @@ void __asan_init() {\n   asanThreadRegistry().GetMain()->ThreadStart();\n   force_interface_symbols();  // no-op.\n \n+  InitializeAllocator();\n+\n   if (flags()->verbosity) {\n     Report(\"AddressSanitizer Init done\\n\");\n   }"}, {"sha": "999cbfba757dae858efa0e8069ac815261339e1a", "filename": "libsanitizer/asan/asan_stack.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -9,9 +9,9 @@\n //\n // Code for ASan stack trace.\n //===----------------------------------------------------------------------===//\n+#include \"asan_internal.h\"\n #include \"asan_flags.h\"\n #include \"asan_stack.h\"\n-#include \"sanitizer/asan_interface.h\"\n \n namespace __asan {\n "}, {"sha": "935b33e20acd22352133dea8c1044a8795af3d32", "filename": "libsanitizer/asan/asan_stats.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_stats.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fasan_stats.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -13,7 +13,6 @@\n #include \"asan_internal.h\"\n #include \"asan_stats.h\"\n #include \"asan_thread_registry.h\"\n-#include \"sanitizer/asan_interface.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n \n namespace __asan {"}, {"sha": "727edf2b43b94e4dc9ab72ce9a5ac9da079056a9", "filename": "libsanitizer/asan/dynamic/asan_interceptors_dynamic.cc", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -17,11 +17,6 @@\n \n namespace __asan {\n \n-#if !MAC_INTERPOSE_FUNCTIONS\n-# error \\\n-  Dynamic interposing library should be built with -DMAC_INTERPOSE_FUNCTIONS\n-#endif\n-\n #define INTERPOSE_FUNCTION(function) \\\n     { reinterpret_cast<const uptr>(WRAP(function)), \\\n       reinterpret_cast<const uptr>(function) }"}, {"sha": "18696a681eda3ee0234b2bb8d1fa2275f0a6109c", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 31, "deletions": 106, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -5,69 +5,18 @@\n //\n //===----------------------------------------------------------------------===//\n //\n-// This file is a part of AddressSanitizer, an address sanity checker.\n+// This file is a part of AddressSanitizer.\n //\n-// This header can be included by the instrumented program to fetch\n-// data (mostly allocator statistics) from ASan runtime library.\n+// Public interface header.\n //===----------------------------------------------------------------------===//\n #ifndef SANITIZER_ASAN_INTERFACE_H\n #define SANITIZER_ASAN_INTERFACE_H\n \n #include <sanitizer/common_interface_defs.h>\n \n-// ----------- ATTENTION -------------\n-// This header should NOT include any other headers from ASan runtime.\n-// All functions in this header are extern \"C\" and start with __asan_.\n-\n-using __sanitizer::uptr;\n-\n+#ifdef __cplusplus\n extern \"C\" {\n-  // This function should be called at the very beginning of the process,\n-  // before any instrumented code is executed and before any call to malloc.\n-  void __asan_init() SANITIZER_INTERFACE_ATTRIBUTE;\n-\n-  // This structure describes an instrumented global variable.\n-  struct __asan_global {\n-    uptr beg;                // The address of the global.\n-    uptr size;               // The original size of the global.\n-    uptr size_with_redzone;  // The size with the redzone.\n-    const char *name;        // Name as a C string.\n-    uptr has_dynamic_init;   // Non-zero if the global has dynamic initializer.\n-  };\n-\n-  // These two functions should be called by the instrumented code.\n-  // 'globals' is an array of structures describing 'n' globals.\n-  void __asan_register_globals(__asan_global *globals, uptr n)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_unregister_globals(__asan_global *globals, uptr n)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-\n-  // These two functions should be called before and after dynamic initializers\n-  // run, respectively.  They should be called with parameters describing all\n-  // dynamically initialized globals defined in the calling TU.\n-  void __asan_before_dynamic_init(uptr first_addr, uptr last_addr)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_after_dynamic_init()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-\n-  // These two functions are used by the instrumented code in the\n-  // use-after-return mode. __asan_stack_malloc allocates size bytes of\n-  // fake stack and __asan_stack_free poisons it. real_stack is a pointer to\n-  // the real stack region.\n-  uptr __asan_stack_malloc(uptr size, uptr real_stack)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_stack_free(uptr ptr, uptr size, uptr real_stack)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-\n-  // These two functions are used by instrumented code in the\n-  // use-after-scope mode. They mark memory for local variables as\n-  // unaddressable when they leave scope and addressable before the\n-  // function exits.\n-  void __asan_poison_stack_memory(uptr addr, uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-  void __asan_unpoison_stack_memory(uptr addr, uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-\n+#endif\n   // Marks memory region [addr, addr+size) as unaddressable.\n   // This memory must be previously allocated by the user program. Accessing\n   // addresses in this region from instrumented code is forbidden until\n@@ -76,23 +25,17 @@ extern \"C\" {\n   // to ASan alignment restrictions.\n   // Method is NOT thread-safe in the sense that no two threads can\n   // (un)poison memory in the same memory region simultaneously.\n-  void __asan_poison_memory_region(void const volatile *addr, uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_poison_memory_region(void const volatile *addr, size_t size);\n   // Marks memory region [addr, addr+size) as addressable.\n   // This memory must be previously allocated by the user program. Accessing\n   // addresses in this region is allowed until this region is poisoned again.\n   // This function may unpoison a superregion of [addr, addr+size) due to\n   // ASan alignment restrictions.\n   // Method is NOT thread-safe in the sense that no two threads can\n   // (un)poison memory in the same memory region simultaneously.\n-  void __asan_unpoison_memory_region(void const volatile *addr, uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-\n-  // Performs cleanup before a NoReturn function. Must be called before things\n-  // like _exit and execl to avoid false positives on stack.\n-  void __asan_handle_no_return() SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_unpoison_memory_region(void const volatile *addr, size_t size);\n \n-// User code should use macro instead of functions.\n+  // User code should use macro instead of functions.\n #if __has_feature(address_sanitizer)\n #define ASAN_POISON_MEMORY_REGION(addr, size) \\\n   __asan_poison_memory_region((addr), (size))\n@@ -107,104 +50,86 @@ extern \"C\" {\n \n   // Returns true iff addr is poisoned (i.e. 1-byte read/write access to this\n   // address will result in error report from AddressSanitizer).\n-  bool __asan_address_is_poisoned(void const volatile *addr)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  bool __asan_address_is_poisoned(void const volatile *addr);\n \n   // If at least on byte in [beg, beg+size) is poisoned, return the address\n   // of the first such byte. Otherwise return 0.\n-  uptr __asan_region_is_poisoned(uptr beg, uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void *__asan_region_is_poisoned(void *beg, size_t size);\n \n   // Print the description of addr (useful when debugging in gdb).\n-  void __asan_describe_address(uptr addr)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_describe_address(void *addr);\n \n   // This is an internal function that is called to report an error.\n   // However it is still a part of the interface because users may want to\n   // set a breakpoint on this function in a debugger.\n-  void __asan_report_error(uptr pc, uptr bp, uptr sp,\n-                           uptr addr, bool is_write, uptr access_size)\n-    SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_report_error(void *pc, void *bp, void *sp,\n+                           void *addr, bool is_write, size_t access_size);\n \n   // Sets the exit code to use when reporting an error.\n   // Returns the old value.\n-  int __asan_set_error_exit_code(int exit_code)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  int __asan_set_error_exit_code(int exit_code);\n \n   // Sets the callback to be called right before death on error.\n   // Passing 0 will unset the callback.\n-  void __asan_set_death_callback(void (*callback)(void))\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_set_death_callback(void (*callback)(void));\n \n-  void __asan_set_error_report_callback(void (*callback)(const char*))\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_set_error_report_callback(void (*callback)(const char*));\n \n   // User may provide function that would be called right when ASan detects\n   // an error. This can be used to notice cases when ASan detects an error, but\n   // the program crashes before ASan report is printed.\n-  /* OPTIONAL */ void __asan_on_error()\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_on_error();\n \n   // User may provide its own implementation for symbolization function.\n   // It should print the description of instruction at address \"pc\" to\n   // \"out_buffer\". Description should be at most \"out_size\" bytes long.\n   // User-specified function should return true if symbolization was\n   // successful.\n-  /* OPTIONAL */ bool __asan_symbolize(const void *pc, char *out_buffer,\n-                                       int out_size)\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+  bool __asan_symbolize(const void *pc, char *out_buffer,\n+                                       int out_size);\n \n   // Returns the estimated number of bytes that will be reserved by allocator\n   // for request of \"size\" bytes. If ASan allocator can't allocate that much\n   // memory, returns the maximal possible allocation size, otherwise returns\n   // \"size\".\n-  uptr __asan_get_estimated_allocated_size(uptr size)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  size_t __asan_get_estimated_allocated_size(size_t size);\n   // Returns true if p was returned by the ASan allocator and\n   // is not yet freed.\n-  bool __asan_get_ownership(const void *p)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  bool __asan_get_ownership(const void *p);\n   // Returns the number of bytes reserved for the pointer p.\n   // Requires (get_ownership(p) == true) or (p == 0).\n-  uptr __asan_get_allocated_size(const void *p)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  size_t __asan_get_allocated_size(const void *p);\n   // Number of bytes, allocated and not yet freed by the application.\n-  uptr __asan_get_current_allocated_bytes()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  size_t __asan_get_current_allocated_bytes();\n   // Number of bytes, mmaped by asan allocator to fulfill allocation requests.\n   // Generally, for request of X bytes, allocator can reserve and add to free\n   // lists a large number of chunks of size X to use them for future requests.\n   // All these chunks count toward the heap size. Currently, allocator never\n   // releases memory to OS (instead, it just puts freed chunks to free lists).\n-  uptr __asan_get_heap_size()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  size_t __asan_get_heap_size();\n   // Number of bytes, mmaped by asan allocator, which can be used to fulfill\n   // allocation requests. When a user program frees memory chunk, it can first\n   // fall into quarantine and will count toward __asan_get_free_bytes() later.\n-  uptr __asan_get_free_bytes()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  size_t __asan_get_free_bytes();\n   // Number of bytes in unmapped pages, that are released to OS. Currently,\n   // always returns 0.\n-  uptr __asan_get_unmapped_bytes()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  size_t __asan_get_unmapped_bytes();\n   // Prints accumulated stats to stderr. Used for debugging.\n-  void __asan_print_accumulated_stats()\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_print_accumulated_stats();\n \n   // This function may be optionally provided by user and should return\n   // a string containing ASan runtime options. See asan_flags.h for details.\n-  /* OPTIONAL */ const char* __asan_default_options()\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+  const char* __asan_default_options();\n \n   // Malloc hooks that may be optionally provided by user.\n   // __asan_malloc_hook(ptr, size) is called immediately after\n   //   allocation of \"size\" bytes, which returned \"ptr\".\n   // __asan_free_hook(ptr) is called immediately before\n   //   deallocation of \"ptr\".\n-  /* OPTIONAL */ void __asan_malloc_hook(void *ptr, uptr size)\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-  /* OPTIONAL */ void __asan_free_hook(void *ptr)\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __asan_malloc_hook(void *ptr, size_t size);\n+  void __asan_free_hook(void *ptr);\n+#ifdef __cplusplus\n }  // extern \"C\"\n+#endif\n \n #endif  // SANITIZER_ASAN_INTERFACE_H"}, {"sha": "b61b8a1a63651477b101fefad677bfea99c2b1cd", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 16, "deletions": 65, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -5,86 +5,37 @@\n //\n //===----------------------------------------------------------------------===//\n //\n-// This file is shared between AddressSanitizer and ThreadSanitizer.\n-// It contains basic macro and types.\n-// NOTE: This file may be included into user code.\n+// Common part of the public sanitizer interface.\n //===----------------------------------------------------------------------===//\n \n #ifndef SANITIZER_COMMON_INTERFACE_DEFS_H\n #define SANITIZER_COMMON_INTERFACE_DEFS_H\n \n-// ----------- ATTENTION -------------\n-// This header should NOT include any other headers to avoid portability issues.\n-\n-#if defined(_WIN32)\n-// FIXME find out what we need on Windows. __declspec(dllexport) ?\n-# define SANITIZER_INTERFACE_ATTRIBUTE\n-# define SANITIZER_WEAK_ATTRIBUTE\n-#elif defined(SANITIZER_GO)\n-# define SANITIZER_INTERFACE_ATTRIBUTE\n-# define SANITIZER_WEAK_ATTRIBUTE\n-#else\n-# define SANITIZER_INTERFACE_ATTRIBUTE __attribute__((visibility(\"default\")))\n-# define SANITIZER_WEAK_ATTRIBUTE  __attribute__((weak))\n-#endif\n-\n-#ifdef __linux__\n-# define SANITIZER_SUPPORTS_WEAK_HOOKS 1\n-#else\n-# define SANITIZER_SUPPORTS_WEAK_HOOKS 0\n-#endif\n-\n-// __has_feature\n-#if !defined(__has_feature)\n-# define __has_feature(x) 0\n-#endif\n-\n-// For portability reasons we do not include stddef.h, stdint.h or any other\n-// system header, but we do need some basic types that are not defined\n-// in a portable way by the language itself.\n-namespace __sanitizer {\n-\n-#if defined(_WIN64)\n-// 64-bit Windows uses LLP64 data model.\n-typedef unsigned long long uptr;  // NOLINT\n-typedef signed   long long sptr;  // NOLINT\n-#else\n-typedef unsigned long uptr;  // NOLINT\n-typedef signed   long sptr;  // NOLINT\n-#endif  // defined(_WIN64)\n-#if defined(__x86_64__)\n-// Since x32 uses ILP32 data model in 64-bit hardware mode,  we must use\n-// 64-bit pointer to unwind stack frame.\n-typedef unsigned long long uhwptr;  // NOLINT\n-#else\n-typedef uptr uhwptr;   // NOLINT\n-#endif\n-typedef unsigned char u8;\n-typedef unsigned short u16;  // NOLINT\n-typedef unsigned int u32;\n-typedef unsigned long long u64;  // NOLINT\n-typedef signed   char s8;\n-typedef signed   short s16;  // NOLINT\n-typedef signed   int s32;\n-typedef signed   long long s64;  // NOLINT\n-\n-}  // namespace __sanitizer\n+#include <stddef.h>\n+#include <stdint.h>\n \n+#ifdef __cplusplus\n extern \"C\" {\n+#endif\n   // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n-  void __sanitizer_set_report_path(const char *path)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __sanitizer_set_report_path(const char *path);\n \n   // Tell the tools to write their reports to given file descriptor instead of\n   // stderr.\n-  void __sanitizer_set_report_fd(int fd)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __sanitizer_set_report_fd(int fd);\n \n   // Notify the tools that the sandbox is going to be turned on. The reserved\n   // parameter will be used in the future to hold a structure with functions\n   // that the tools may call to bypass the sandbox.\n-  void __sanitizer_sandbox_on_notify(void *reserved)\n-      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+  void __sanitizer_sandbox_on_notify(void *reserved);\n+\n+  // This function is called by the tool when it has just finished reporting\n+  // an error. 'error_summary' is a one-line string that summarizes\n+  // the error message. This function can be overridden by the client.\n+  void __sanitizer_report_error_summary(const char *error_summary);\n+\n+#ifdef __cplusplus\n }  // extern \"C\"\n+#endif\n \n #endif  // SANITIZER_COMMON_INTERFACE_DEFS_H"}, {"sha": "4218983160b49c788afb21ab62801e1f5eecab4e", "filename": "libsanitizer/interception/Makefile.am", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.am?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -1,4 +1,4 @@\n-AM_CPPFLAGS = -I $(top_srcdir)/include \n+AM_CPPFLAGS = -I $(top_srcdir)/include -I $(top_srcdir)\n  \n # May be used by toolexeclibdir.\n gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n@@ -13,7 +13,8 @@ noinst_LTLIBRARIES = libinterception.la\n interception_files = \\\n         interception_linux.cc \\\n         interception_mac.cc \\\n-        interception_win.cc\n+        interception_win.cc \\\n+\tinterception_type_test.cc\n \n libinterception_la_SOURCES = $(interception_files)\n "}, {"sha": "f7c715b5c909015e345ffd72904bf4b4525c63c0", "filename": "libsanitizer/interception/Makefile.in", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.in?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -56,7 +56,7 @@ CONFIG_CLEAN_VPATH_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n libinterception_la_LIBADD =\n am__objects_1 = interception_linux.lo interception_mac.lo \\\n-\tinterception_win.lo\n+\tinterception_win.lo interception_type_test.lo\n am_libinterception_la_OBJECTS = $(am__objects_1)\n libinterception_la_OBJECTS = $(am_libinterception_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n@@ -208,7 +208,7 @@ toolexeclibdir = @toolexeclibdir@\n top_build_prefix = @top_build_prefix@\n top_builddir = @top_builddir@\n top_srcdir = @top_srcdir@\n-AM_CPPFLAGS = -I $(top_srcdir)/include \n+AM_CPPFLAGS = -I $(top_srcdir)/include -I $(top_srcdir)\n \n # May be used by toolexeclibdir.\n gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n@@ -221,7 +221,8 @@ noinst_LTLIBRARIES = libinterception.la\n interception_files = \\\n         interception_linux.cc \\\n         interception_mac.cc \\\n-        interception_win.cc\n+        interception_win.cc \\\n+\tinterception_type_test.cc\n \n libinterception_la_SOURCES = $(interception_files)\n \n@@ -318,6 +319,7 @@ distclean-compile:\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_type_test.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_win.Plo@am__quote@\n \n .cc.o:"}, {"sha": "b4c4137e88ef06256d36e3bab4ee90d778f94b56", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -17,29 +17,25 @@\n # error \"Interception doesn't work on this operating system.\"\n #endif\n \n-#include \"sanitizer/common_interface_defs.h\"\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n \n // These typedefs should be used only in the interceptor definitions to replace\n // the standard system types (e.g. SSIZE_T instead of ssize_t)\n typedef __sanitizer::uptr SIZE_T;\n typedef __sanitizer::sptr SSIZE_T;\n typedef __sanitizer::sptr PTRDIFF_T;\n typedef __sanitizer::s64  INTMAX_T;\n-typedef __sanitizer::u64  OFF_T;\n+// WARNING: OFF_T may be different from OS type off_t, depending on the value of\n+// _FILE_OFFSET_BITS. This definition of OFF_T matches the ABI of system calls\n+// like pread and mmap, as opposed to pread64 and mmap64.\n+// Mac is special.\n+#ifdef __APPLE__\n+typedef __sanitizer::u64 OFF_T;\n+#else\n+typedef __sanitizer::uptr OFF_T;\n+#endif\n typedef __sanitizer::u64  OFF64_T;\n \n-// How to use this library:\n-//      1) Include this header to define your own interceptors\n-//         (see details below).\n-//      2) Build all *.cc files and link against them.\n-// On Mac you will also need to:\n-//      3) Provide your own implementation for the following functions:\n-//           mach_error_t __interception::allocate_island(void **ptr,\n-//                                                      size_t size,\n-//                                                      void *hint);\n-//           mach_error_t __interception::deallocate_island(void *ptr);\n-//         See \"interception_mac.h\" for more details.\n-\n // How to add an interceptor:\n // Suppose you need to wrap/replace system function (generally, from libc):\n //      int foo(const char *bar, double baz);\n@@ -80,20 +76,12 @@ typedef __sanitizer::u64  OFF64_T;\n // This is not so on Mac OS, where the two-level namespace makes\n // our replacement functions invisible to other libraries. This may be overcomed\n // using the DYLD_FORCE_FLAT_NAMESPACE, but some errors loading the shared\n-// libraries in Chromium were noticed when doing so. Instead we use\n-// mach_override, a handy framework for patching functions at runtime.\n-// To avoid possible name clashes, our replacement functions have\n-// the \"wrap_\" prefix on Mac.\n-// An alternative to function patching is to create a dylib containing a\n-// __DATA,__interpose section that associates library functions with their\n-// wrappers. When this dylib is preloaded before an executable using\n-// DYLD_INSERT_LIBRARIES, it routes all the calls to interposed functions done\n-// through stubs to the wrapper functions. Such a library is built with\n-// -DMAC_INTERPOSE_FUNCTIONS=1.\n-\n-#if !defined(MAC_INTERPOSE_FUNCTIONS) || !defined(__APPLE__)\n-# define MAC_INTERPOSE_FUNCTIONS 0\n-#endif\n+// libraries in Chromium were noticed when doing so.\n+// Instead we create a dylib containing a __DATA,__interpose section that\n+// associates library functions with their wrappers. When this dylib is\n+// preloaded before an executable using DYLD_INSERT_LIBRARIES, it routes all\n+// the calls to interposed functions done through stubs to the wrapper\n+// functions.\n \n #if defined(__APPLE__)\n # define WRAP(x) wrap_##x\n@@ -120,7 +108,7 @@ typedef __sanitizer::u64  OFF64_T;\n     __attribute__((weak, alias(\"__interceptor_\" #func), visibility(\"default\")));\n #endif\n \n-#if !MAC_INTERPOSE_FUNCTIONS\n+#if !defined(__APPLE__)\n # define PTR_TO_REAL(x) real_##x\n # define REAL(x) __interception::PTR_TO_REAL(x)\n # define FUNC_TYPE(x) x##_f\n@@ -130,11 +118,11 @@ typedef __sanitizer::u64  OFF64_T;\n     namespace __interception { \\\n       extern FUNC_TYPE(func) PTR_TO_REAL(func); \\\n     }\n-#else  // MAC_INTERPOSE_FUNCTIONS\n+#else  // __APPLE__\n # define REAL(x) x\n # define DECLARE_REAL(ret_type, func, ...) \\\n     extern \"C\" ret_type func(__VA_ARGS__);\n-#endif  // MAC_INTERPOSE_FUNCTIONS\n+#endif  // __APPLE__\n \n #define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...) \\\n   DECLARE_REAL(ret_type, func, __VA_ARGS__) \\\n@@ -144,7 +132,7 @@ typedef __sanitizer::u64  OFF64_T;\n // macros does its job. In exceptional cases you may need to call REAL(foo)\n // without defining INTERCEPTOR(..., foo, ...). For example, if you override\n // foo with an interceptor for other function.\n-#if !MAC_INTERPOSE_FUNCTIONS\n+#if !defined(__APPLE__)\n # define DEFINE_REAL(ret_type, func, ...) \\\n     typedef ret_type (*FUNC_TYPE(func))(__VA_ARGS__); \\\n     namespace __interception { \\"}, {"sha": "801dcba3d13465153faeb80f2ac84da1f2229141", "filename": "libsanitizer/interception/interception_mac.cc", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2Finterception_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2Finterception_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_mac.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -13,17 +13,6 @@\n #ifdef __APPLE__\n \n #include \"interception.h\"\n-#include \"mach_override/mach_override.h\"\n \n-namespace __interception {\n-bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func) {\n-  *orig_old_func = 0;\n-  int res = __asan_mach_override_ptr_custom((void*)old_func, (void*)new_func,\n-                                            (void**)orig_old_func,\n-                                            __interception_allocate_island,\n-                                            __interception_deallocate_island);\n-  return (res == 0) && (*orig_old_func != 0);\n-}\n-}  // namespace __interception\n \n #endif  // __APPLE__"}, {"sha": "1b11182da98ae15e4569de9b7c12f3c721f909a0", "filename": "libsanitizer/interception/interception_mac.h", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2Finterception_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2Finterception_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_mac.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -19,29 +19,7 @@\n #ifndef INTERCEPTION_MAC_H\n #define INTERCEPTION_MAC_H\n \n-#include <mach/mach_error.h>\n-#include <stddef.h>\n-\n-// Allocate memory for the escape island. This cannot be moved to\n-// mach_override, because each user of interceptors may specify its\n-// own memory range for escape islands.\n-extern \"C\" {\n-mach_error_t __interception_allocate_island(void **ptr, size_t unused_size,\n-                                            void *unused_hint);\n-mach_error_t __interception_deallocate_island(void *ptr);\n-}  // extern \"C\"\n-\n-namespace __interception {\n-// returns true if the old function existed.\n-bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func);\n-}  // namespace __interception\n-\n-# define OVERRIDE_FUNCTION_MAC(old_func, new_func) \\\n-    ::__interception::OverrideFunction( \\\n-          (::__interception::uptr)old_func, \\\n-          (::__interception::uptr)new_func, \\\n-          (::__interception::uptr*)((::__interception::uptr)&REAL(old_func)))\n-# define INTERCEPT_FUNCTION_MAC(func) OVERRIDE_FUNCTION_MAC(func, WRAP(func))\n+#define INTERCEPT_FUNCTION_MAC(func)\n \n #endif  // INTERCEPTION_MAC_H\n #endif  // __APPLE__"}, {"sha": "f664eeeb04fe622565be498cb3520c34cd065637", "filename": "libsanitizer/interception/interception_type_test.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2Finterception_type_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Finterception%2Finterception_type_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_type_test.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -0,0 +1,37 @@\n+//===-- interception_type_test.cc -------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Compile-time tests of the internal type definitions.\n+//===----------------------------------------------------------------------===//\n+\n+#if defined(__linux__) || defined(__APPLE__)\n+\n+#include \"interception.h\"\n+#include <sys/types.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+COMPILER_CHECK(sizeof(SIZE_T) == sizeof(size_t));\n+COMPILER_CHECK(sizeof(SSIZE_T) == sizeof(ssize_t));\n+COMPILER_CHECK(sizeof(PTRDIFF_T) == sizeof(ptrdiff_t));\n+COMPILER_CHECK(sizeof(INTMAX_T) == sizeof(intmax_t));\n+\n+#ifndef __APPLE__\n+COMPILER_CHECK(sizeof(OFF64_T) == sizeof(off64_t));\n+#endif\n+\n+// The following are the cases when pread (and friends) is used instead of\n+// pread64. In those cases we need OFF_T to match off_t. We don't care about the\n+// rest (they depend on _FILE_OFFSET_BITS setting when building an application).\n+# if defined(__ANDROID__) || !defined _FILE_OFFSET_BITS || \\\n+  _FILE_OFFSET_BITS != 64\n+COMPILER_CHECK(sizeof(OFF_T) == sizeof(off_t));\n+# endif\n+\n+#endif"}, {"sha": "a54de9d6f9a61bcfeb75770198e66da6f930f316", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -73,4 +73,10 @@ void SetLowLevelAllocateCallback(LowLevelAllocateCallback callback) {\n   low_level_alloc_callback = callback;\n }\n \n+bool CallocShouldReturnNullDueToOverflow(uptr size, uptr n) {\n+  if (!size) return false;\n+  uptr max = (uptr)-1L;\n+  return (max / size) < n;\n+}\n+\n }  // namespace __sanitizer"}, {"sha": "889281216fc79215ec6a708f4647b2d50af89a0d", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 233, "deletions": 50, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -23,9 +23,9 @@ namespace __sanitizer {\n \n // SizeClassMap maps allocation sizes into size classes and back.\n // Class 0 corresponds to size 0.\n-// Classes 1 - 16 correspond to sizes 8 - 128 (size = class_id * 8).\n-// Next 8 classes: 128 + i * 16 (i = 1 to 8).\n+// Classes 1 - 16 correspond to sizes 16 to 256 (size = class_id * 16).\n // Next 8 classes: 256 + i * 32 (i = 1 to 8).\n+// Next 8 classes: 512 + i * 64 (i = 1 to 8).\n // ...\n // Next 8 classes: 2^k + i * 2^(k-3) (i = 1 to 8).\n // Last class corresponds to kMaxSize = 1 << kMaxSizeLog.\n@@ -40,33 +40,48 @@ namespace __sanitizer {\n //  - (1 << kMaxBytesCachedLog) is the maximal number of bytes per size class.\n //\n // Part of output of SizeClassMap::Print():\n-//    c00 => s: 0 diff: +0 00% l 0 cached: 0 0; id 0\n-//    c01 => s: 8 diff: +8 00% l 3 cached: 256 2048; id 1\n-//    c02 => s: 16 diff: +8 100% l 4 cached: 256 4096; id 2\n-//    ...\n-//    c07 => s: 56 diff: +8 16% l 5 cached: 256 14336; id 7\n+// c00 => s: 0 diff: +0 00% l 0 cached: 0 0; id 0\n+// c01 => s: 16 diff: +16 00% l 4 cached: 256 4096; id 1\n+// c02 => s: 32 diff: +16 100% l 5 cached: 256 8192; id 2\n+// c03 => s: 48 diff: +16 50% l 5 cached: 256 12288; id 3\n+// c04 => s: 64 diff: +16 33% l 6 cached: 256 16384; id 4\n+// c05 => s: 80 diff: +16 25% l 6 cached: 256 20480; id 5\n+// c06 => s: 96 diff: +16 20% l 6 cached: 256 24576; id 6\n+// c07 => s: 112 diff: +16 16% l 6 cached: 256 28672; id 7\n //\n-//    c08 => s: 64 diff: +8 14% l 6 cached: 256 16384; id 8\n-//    ...\n-//    c15 => s: 120 diff: +8 07% l 6 cached: 256 30720; id 15\n+// c08 => s: 128 diff: +16 14% l 7 cached: 256 32768; id 8\n+// c09 => s: 144 diff: +16 12% l 7 cached: 256 36864; id 9\n+// c10 => s: 160 diff: +16 11% l 7 cached: 256 40960; id 10\n+// c11 => s: 176 diff: +16 10% l 7 cached: 256 45056; id 11\n+// c12 => s: 192 diff: +16 09% l 7 cached: 256 49152; id 12\n+// c13 => s: 208 diff: +16 08% l 7 cached: 256 53248; id 13\n+// c14 => s: 224 diff: +16 07% l 7 cached: 256 57344; id 14\n+// c15 => s: 240 diff: +16 07% l 7 cached: 256 61440; id 15\n //\n-//    c16 => s: 128 diff: +8 06% l 7 cached: 256 32768; id 16\n-//    c17 => s: 144 diff: +16 12% l 7 cached: 227 32688; id 17\n-//    ...\n-//    c23 => s: 240 diff: +16 07% l 7 cached: 136 32640; id 23\n+// c16 => s: 256 diff: +16 06% l 8 cached: 256 65536; id 16\n+// c17 => s: 288 diff: +32 12% l 8 cached: 227 65376; id 17\n+// c18 => s: 320 diff: +32 11% l 8 cached: 204 65280; id 18\n+// c19 => s: 352 diff: +32 10% l 8 cached: 186 65472; id 19\n+// c20 => s: 384 diff: +32 09% l 8 cached: 170 65280; id 20\n+// c21 => s: 416 diff: +32 08% l 8 cached: 157 65312; id 21\n+// c22 => s: 448 diff: +32 07% l 8 cached: 146 65408; id 22\n+// c23 => s: 480 diff: +32 07% l 8 cached: 136 65280; id 23\n //\n-//    c24 => s: 256 diff: +16 06% l 8 cached: 128 32768; id 24\n-//    c25 => s: 288 diff: +32 12% l 8 cached: 113 32544; id 25\n-//    ...\n-//    c31 => s: 480 diff: +32 07% l 8 cached: 68 32640; id 31\n+// c24 => s: 512 diff: +32 06% l 9 cached: 128 65536; id 24\n+// c25 => s: 576 diff: +64 12% l 9 cached: 113 65088; id 25\n+// c26 => s: 640 diff: +64 11% l 9 cached: 102 65280; id 26\n+// c27 => s: 704 diff: +64 10% l 9 cached: 93 65472; id 27\n+// c28 => s: 768 diff: +64 09% l 9 cached: 85 65280; id 28\n+// c29 => s: 832 diff: +64 08% l 9 cached: 78 64896; id 29\n+// c30 => s: 896 diff: +64 07% l 9 cached: 73 65408; id 30\n+// c31 => s: 960 diff: +64 07% l 9 cached: 68 65280; id 31\n //\n-//    c32 => s: 512 diff: +32 06% l 9 cached: 64 32768; id 32\n-\n+// c32 => s: 1024 diff: +64 06% l 10 cached: 64 65536; id 32\n \n template <uptr kMaxSizeLog, uptr kMaxNumCachedT, uptr kMaxBytesCachedLog,\n           uptr kMinBatchClassT>\n class SizeClassMap {\n-  static const uptr kMinSizeLog = 3;\n+  static const uptr kMinSizeLog = 4;\n   static const uptr kMidSizeLog = kMinSizeLog + 4;\n   static const uptr kMinSize = 1 << kMinSizeLog;\n   static const uptr kMidSize = 1 << kMidSizeLog;\n@@ -104,7 +119,7 @@ class SizeClassMap {\n     if (size <= kMidSize)\n       return (size + kMinSize - 1) >> kMinSizeLog;\n     if (size > kMaxSize) return 0;\n-    uptr l = SANITIZER_WORDSIZE - 1 - __builtin_clzl(size);\n+    uptr l = MostSignificantSetBitIndex(size);\n     uptr hbits = (size >> (l - S)) & M;\n     uptr lbits = size & ((1 << (l - S)) - 1);\n     uptr l1 = l - kMidSizeLog;\n@@ -114,7 +129,7 @@ class SizeClassMap {\n   static uptr MaxCached(uptr class_id) {\n     if (class_id == 0) return 0;\n     uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);\n-    return Max(1UL, Min(kMaxNumCached, n));\n+    return Max<uptr>(1, Min(kMaxNumCached, n));\n   }\n \n   static void Print() {\n@@ -126,7 +141,7 @@ class SizeClassMap {\n         Printf(\"\\n\");\n       uptr d = s - prev_s;\n       uptr p = prev_s ? (d * 100 / prev_s) : 0;\n-      uptr l = SANITIZER_WORDSIZE - 1 - __builtin_clzl(s);\n+      uptr l = MostSignificantSetBitIndex(s);\n       uptr cached = MaxCached(i) * s;\n       Printf(\"c%02zd => s: %zd diff: +%zd %02zd%% l %zd \"\n              \"cached: %zd %zd; id %zd\\n\",\n@@ -172,12 +187,92 @@ class SizeClassMap {\n   }\n };\n \n-typedef SizeClassMap<17, 256, 16, FIRST_32_SECOND_64(33, 36)>\n+typedef SizeClassMap<17, 256, 16, FIRST_32_SECOND_64(25, 28)>\n     DefaultSizeClassMap;\n-typedef SizeClassMap<17, 64, 14, FIRST_32_SECOND_64(25, 28)>\n+typedef SizeClassMap<17, 64, 14, FIRST_32_SECOND_64(17, 20)>\n     CompactSizeClassMap;\n template<class SizeClassAllocator> struct SizeClassAllocatorLocalCache;\n \n+// Memory allocator statistics\n+enum AllocatorStat {\n+  AllocatorStatMalloced,\n+  AllocatorStatFreed,\n+  AllocatorStatMmapped,\n+  AllocatorStatUnmapped,\n+  AllocatorStatCount\n+};\n+\n+typedef u64 AllocatorStatCounters[AllocatorStatCount];\n+\n+// Per-thread stats, live in per-thread cache.\n+class AllocatorStats {\n+ public:\n+  void Init() {\n+    internal_memset(this, 0, sizeof(*this));\n+  }\n+\n+  void Add(AllocatorStat i, u64 v) {\n+    v += atomic_load(&stats_[i], memory_order_relaxed);\n+    atomic_store(&stats_[i], v, memory_order_relaxed);\n+  }\n+\n+  void Set(AllocatorStat i, u64 v) {\n+    atomic_store(&stats_[i], v, memory_order_relaxed);\n+  }\n+\n+  u64 Get(AllocatorStat i) const {\n+    return atomic_load(&stats_[i], memory_order_relaxed);\n+  }\n+\n+ private:\n+  friend class AllocatorGlobalStats;\n+  AllocatorStats *next_;\n+  AllocatorStats *prev_;\n+  atomic_uint64_t stats_[AllocatorStatCount];\n+};\n+\n+// Global stats, used for aggregation and querying.\n+class AllocatorGlobalStats : public AllocatorStats {\n+ public:\n+  void Init() {\n+    internal_memset(this, 0, sizeof(*this));\n+    next_ = this;\n+    prev_ = this;\n+  }\n+\n+  void Register(AllocatorStats *s) {\n+    SpinMutexLock l(&mu_);\n+    s->next_ = next_;\n+    s->prev_ = this;\n+    next_->prev_ = s;\n+    next_ = s;\n+  }\n+\n+  void Unregister(AllocatorStats *s) {\n+    SpinMutexLock l(&mu_);\n+    s->prev_->next_ = s->next_;\n+    s->next_->prev_ = s->prev_;\n+    for (int i = 0; i < AllocatorStatCount; i++)\n+      Add(AllocatorStat(i), s->Get(AllocatorStat(i)));\n+  }\n+\n+  void Get(AllocatorStatCounters s) const {\n+    internal_memset(s, 0, AllocatorStatCount * sizeof(u64));\n+    SpinMutexLock l(&mu_);\n+    const AllocatorStats *stats = this;\n+    for (;;) {\n+      for (int i = 0; i < AllocatorStatCount; i++)\n+        s[i] += stats->Get(AllocatorStat(i));\n+      stats = stats->next_;\n+      if (stats == this)\n+        break;\n+    }\n+  }\n+\n+ private:\n+  mutable SpinMutex mu_;\n+};\n+\n // Allocators call these callbacks on mmap/munmap.\n struct NoOpMapUnmapCallback {\n   void OnMap(uptr p, uptr size) const { }\n@@ -231,17 +326,18 @@ class SizeClassAllocator64 {\n       alignment <= SizeClassMap::kMaxSize;\n   }\n \n-  Batch *NOINLINE AllocateBatch(AllocatorCache *c, uptr class_id) {\n+  NOINLINE Batch* AllocateBatch(AllocatorStats *stat, AllocatorCache *c,\n+                                uptr class_id) {\n     CHECK_LT(class_id, kNumClasses);\n     RegionInfo *region = GetRegionInfo(class_id);\n     Batch *b = region->free_list.Pop();\n     if (b == 0)\n-      b = PopulateFreeList(c, class_id, region);\n+      b = PopulateFreeList(stat, c, class_id, region);\n     region->n_allocated += b->count;\n     return b;\n   }\n \n-  void NOINLINE DeallocateBatch(uptr class_id, Batch *b) {\n+  NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id, Batch *b) {\n     RegionInfo *region = GetRegionInfo(class_id);\n     region->free_list.Push(b);\n     region->n_freed += b->count;\n@@ -320,6 +416,20 @@ class SizeClassAllocator64 {\n     }\n   }\n \n+  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n+  // introspection API.\n+  void ForceLock() {\n+    for (uptr i = 0; i < kNumClasses; i++) {\n+      GetRegionInfo(i)->mutex.Lock();\n+    }\n+  }\n+\n+  void ForceUnlock() {\n+    for (int i = (int)kNumClasses - 1; i >= 0; i--) {\n+      GetRegionInfo(i)->mutex.Unlock();\n+    }\n+  }\n+\n   typedef SizeClassMap SizeClassMapT;\n   static const uptr kNumClasses = SizeClassMap::kNumClasses;\n   static const uptr kNumClassesRounded = SizeClassMap::kNumClassesRounded;\n@@ -334,7 +444,7 @@ class SizeClassAllocator64 {\n   // or with one element if its size is greater.\n   static const uptr kPopulateSize = 1 << 14;\n   // Call mmap for user memory with at least this size.\n-  static const uptr kUserMapSize = 1 << 15;\n+  static const uptr kUserMapSize = 1 << 16;\n   // Call mmap for metadata memory with at least this size.\n   static const uptr kMetaMapSize = 1 << 16;\n \n@@ -368,8 +478,8 @@ class SizeClassAllocator64 {\n     return offset / (u32)size;\n   }\n \n-  Batch *NOINLINE PopulateFreeList(AllocatorCache *c, uptr class_id,\n-                                   RegionInfo *region) {\n+  NOINLINE Batch* PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,\n+                                   uptr class_id, RegionInfo *region) {\n     BlockingMutexLock l(&region->mutex);\n     Batch *b = region->free_list.Pop();\n     if (b)\n@@ -386,6 +496,7 @@ class SizeClassAllocator64 {\n         map_size += kUserMapSize;\n       CHECK_GE(region->mapped_user + map_size, end_idx);\n       MapWithCallback(region_beg + region->mapped_user, map_size);\n+      stat->Add(AllocatorStatMmapped, map_size);\n       region->mapped_user += map_size;\n     }\n     uptr total_count = (region->mapped_user - beg_idx - size)\n@@ -467,6 +578,7 @@ class SizeClassAllocator32 {\n     MapUnmapCallback().OnMap((uptr)res, size);\n     return res;\n   }\n+\n   void UnmapWithCallback(uptr beg, uptr size) {\n     MapUnmapCallback().OnUnmap(beg, size);\n     UnmapOrDie(reinterpret_cast<void *>(beg), size);\n@@ -488,19 +600,20 @@ class SizeClassAllocator32 {\n     return reinterpret_cast<void*>(meta);\n   }\n \n-  Batch *NOINLINE AllocateBatch(AllocatorCache *c, uptr class_id) {\n+  NOINLINE Batch* AllocateBatch(AllocatorStats *stat, AllocatorCache *c,\n+                                uptr class_id) {\n     CHECK_LT(class_id, kNumClasses);\n     SizeClassInfo *sci = GetSizeClassInfo(class_id);\n     SpinMutexLock l(&sci->mutex);\n     if (sci->free_list.empty())\n-      PopulateFreeList(c, sci, class_id);\n+      PopulateFreeList(stat, c, sci, class_id);\n     CHECK(!sci->free_list.empty());\n     Batch *b = sci->free_list.front();\n     sci->free_list.pop_front();\n     return b;\n   }\n \n-  void NOINLINE DeallocateBatch(uptr class_id, Batch *b) {\n+  NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id, Batch *b) {\n     CHECK_LT(class_id, kNumClasses);\n     SizeClassInfo *sci = GetSizeClassInfo(class_id);\n     SpinMutexLock l(&sci->mutex);\n@@ -549,6 +662,20 @@ class SizeClassAllocator32 {\n     UnmapWithCallback(reinterpret_cast<uptr>(state_), sizeof(State));\n   }\n \n+  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n+  // introspection API.\n+  void ForceLock() {\n+    for (uptr i = 0; i < kNumClasses; i++) {\n+      GetSizeClassInfo(i)->mutex.Lock();\n+    }\n+  }\n+\n+  void ForceUnlock() {\n+    for (int i = kNumClasses - 1; i >= 0; i--) {\n+      GetSizeClassInfo(i)->mutex.Unlock();\n+    }\n+  }\n+\n   void PrintStats() {\n   }\n \n@@ -577,11 +704,12 @@ class SizeClassAllocator32 {\n     return mem & ~(kRegionSize - 1);\n   }\n \n-  uptr AllocateRegion(uptr class_id) {\n+  uptr AllocateRegion(AllocatorStats *stat, uptr class_id) {\n     CHECK_LT(class_id, kNumClasses);\n     uptr res = reinterpret_cast<uptr>(MmapAlignedOrDie(kRegionSize, kRegionSize,\n                                       \"SizeClassAllocator32\"));\n     MapUnmapCallback().OnMap(res, kRegionSize);\n+    stat->Add(AllocatorStatMmapped, kRegionSize);\n     CHECK_EQ(0U, (res & (kRegionSize - 1)));\n     CHECK_EQ(0U, state_->possible_regions[ComputeRegionId(res)]);\n     state_->possible_regions[ComputeRegionId(res)] = class_id;\n@@ -593,9 +721,10 @@ class SizeClassAllocator32 {\n     return &state_->size_class_info_array[class_id];\n   }\n \n-  void PopulateFreeList(AllocatorCache *c, SizeClassInfo *sci, uptr class_id) {\n+  void PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,\n+                        SizeClassInfo *sci, uptr class_id) {\n     uptr size = SizeClassMap::Size(class_id);\n-    uptr reg = AllocateRegion(class_id);\n+    uptr reg = AllocateRegion(stat, class_id);\n     uptr n_chunks = kRegionSize / (size + kMetadataSize);\n     uptr max_count = SizeClassMap::MaxCached(class_id);\n     Batch *b = 0;\n@@ -632,14 +761,22 @@ struct SizeClassAllocatorLocalCache {\n   typedef SizeClassAllocator Allocator;\n   static const uptr kNumClasses = SizeClassAllocator::kNumClasses;\n \n-  // Don't need to call Init if the object is a global (i.e. zero-initialized).\n-  void Init() {\n-    internal_memset(this, 0, sizeof(*this));\n+  void Init(AllocatorGlobalStats *s) {\n+    stats_.Init();\n+    if (s)\n+      s->Register(&stats_);\n+  }\n+\n+  void Destroy(SizeClassAllocator *allocator, AllocatorGlobalStats *s) {\n+    Drain(allocator);\n+    if (s)\n+      s->Unregister(&stats_);\n   }\n \n   void *Allocate(SizeClassAllocator *allocator, uptr class_id) {\n     CHECK_NE(class_id, 0UL);\n     CHECK_LT(class_id, kNumClasses);\n+    stats_.Add(AllocatorStatMalloced, SizeClassMap::Size(class_id));\n     PerClass *c = &per_class_[class_id];\n     if (UNLIKELY(c->count == 0))\n       Refill(allocator, class_id);\n@@ -651,6 +788,7 @@ struct SizeClassAllocatorLocalCache {\n   void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {\n     CHECK_NE(class_id, 0UL);\n     CHECK_LT(class_id, kNumClasses);\n+    stats_.Add(AllocatorStatFreed, SizeClassMap::Size(class_id));\n     PerClass *c = &per_class_[class_id];\n     if (UNLIKELY(c->count == c->max_count))\n       Drain(allocator, class_id);\n@@ -674,6 +812,7 @@ struct SizeClassAllocatorLocalCache {\n     void *batch[2 * SizeClassMap::kMaxNumCached];\n   };\n   PerClass per_class_[kNumClasses];\n+  AllocatorStats stats_;\n \n   void InitCache() {\n     if (per_class_[0].max_count)\n@@ -684,18 +823,19 @@ struct SizeClassAllocatorLocalCache {\n     }\n   }\n \n-  void NOINLINE Refill(SizeClassAllocator *allocator, uptr class_id) {\n+  NOINLINE void Refill(SizeClassAllocator *allocator, uptr class_id) {\n     InitCache();\n     PerClass *c = &per_class_[class_id];\n-    Batch *b = allocator->AllocateBatch(this, class_id);\n+    Batch *b = allocator->AllocateBatch(&stats_, this, class_id);\n+    CHECK_GT(b->count, 0);\n     for (uptr i = 0; i < b->count; i++)\n       c->batch[i] = b->batch[i];\n     c->count = b->count;\n     if (class_id < SizeClassMap::kMinBatchClass)\n       Deallocate(allocator, SizeClassMap::ClassID(sizeof(Batch)), b);\n   }\n \n-  void NOINLINE Drain(SizeClassAllocator *allocator, uptr class_id) {\n+  NOINLINE void Drain(SizeClassAllocator *allocator, uptr class_id) {\n     InitCache();\n     PerClass *c = &per_class_[class_id];\n     Batch *b;\n@@ -710,7 +850,7 @@ struct SizeClassAllocatorLocalCache {\n     }\n     b->count = cnt;\n     c->count -= cnt;\n-    allocator->DeallocateBatch(class_id, b);\n+    allocator->DeallocateBatch(&stats_, class_id, b);\n   }\n };\n \n@@ -725,7 +865,7 @@ class LargeMmapAllocator {\n     page_size_ = GetPageSizeCached();\n   }\n \n-  void *Allocate(uptr size, uptr alignment) {\n+  void *Allocate(AllocatorStats *stat, uptr size, uptr alignment) {\n     CHECK(IsPowerOfTwo(alignment));\n     uptr map_size = RoundUpMapSize(size);\n     if (alignment > page_size_)\n@@ -744,7 +884,7 @@ class LargeMmapAllocator {\n     h->size = size;\n     h->map_beg = map_beg;\n     h->map_size = map_size;\n-    uptr size_log = SANITIZER_WORDSIZE - __builtin_clzl(map_size) - 1;\n+    uptr size_log = MostSignificantSetBitIndex(map_size);\n     CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));\n     {\n       SpinMutexLock l(&mutex_);\n@@ -756,11 +896,13 @@ class LargeMmapAllocator {\n       stats.currently_allocated += map_size;\n       stats.max_allocated = Max(stats.max_allocated, stats.currently_allocated);\n       stats.by_size_log[size_log]++;\n+      stat->Add(AllocatorStatMalloced, map_size);\n+      stat->Add(AllocatorStatMmapped, map_size);\n     }\n     return reinterpret_cast<void*>(res);\n   }\n \n-  void Deallocate(void *p) {\n+  void Deallocate(AllocatorStats *stat, void *p) {\n     Header *h = GetHeader(p);\n     {\n       SpinMutexLock l(&mutex_);\n@@ -772,6 +914,8 @@ class LargeMmapAllocator {\n       n_chunks_--;\n       stats.n_frees++;\n       stats.currently_allocated -= h->map_size;\n+      stat->Add(AllocatorStatFreed, h->map_size);\n+      stat->Add(AllocatorStatUnmapped, h->map_size);\n     }\n     MapUnmapCallback().OnUnmap(h->map_beg, h->map_size);\n     UnmapOrDie(reinterpret_cast<void*>(h->map_beg), h->map_size);\n@@ -838,6 +982,16 @@ class LargeMmapAllocator {\n     Printf(\"\\n\");\n   }\n \n+  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n+  // introspection API.\n+  void ForceLock() {\n+    mutex_.Lock();\n+  }\n+\n+  void ForceUnlock() {\n+    mutex_.Unlock();\n+  }\n+\n  private:\n   static const int kMaxNumChunks = 1 << FIRST_32_SECOND_64(15, 18);\n   struct Header {\n@@ -884,6 +1038,7 @@ class CombinedAllocator {\n   void Init() {\n     primary_.Init();\n     secondary_.Init();\n+    stats_.Init();\n   }\n \n   void *Allocate(AllocatorCache *cache, uptr size, uptr alignment,\n@@ -899,7 +1054,7 @@ class CombinedAllocator {\n     if (primary_.CanAllocate(size, alignment))\n       res = cache->Allocate(&primary_, primary_.ClassID(size));\n     else\n-      res = secondary_.Allocate(size, alignment);\n+      res = secondary_.Allocate(&stats_, size, alignment);\n     if (alignment > 8)\n       CHECK_EQ(reinterpret_cast<uptr>(res) & (alignment - 1), 0);\n     if (cleared && res)\n@@ -912,7 +1067,7 @@ class CombinedAllocator {\n     if (primary_.PointerIsMine(p))\n       cache->Deallocate(&primary_, primary_.GetSizeClass(p), p);\n     else\n-      secondary_.Deallocate(p);\n+      secondary_.Deallocate(&stats_, p);\n   }\n \n   void *Reallocate(AllocatorCache *cache, void *p, uptr new_size,\n@@ -967,20 +1122,48 @@ class CombinedAllocator {\n \n   void TestOnlyUnmap() { primary_.TestOnlyUnmap(); }\n \n+  void InitCache(AllocatorCache *cache) {\n+    cache->Init(&stats_);\n+  }\n+\n+  void DestroyCache(AllocatorCache *cache) {\n+    cache->Destroy(&primary_, &stats_);\n+  }\n+\n   void SwallowCache(AllocatorCache *cache) {\n     cache->Drain(&primary_);\n   }\n \n+  void GetStats(AllocatorStatCounters s) const {\n+    stats_.Get(s);\n+  }\n+\n   void PrintStats() {\n     primary_.PrintStats();\n     secondary_.PrintStats();\n   }\n \n+  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n+  // introspection API.\n+  void ForceLock() {\n+    primary_.ForceLock();\n+    secondary_.ForceLock();\n+  }\n+\n+  void ForceUnlock() {\n+    secondary_.ForceUnlock();\n+    primary_.ForceUnlock();\n+  }\n+\n  private:\n   PrimaryAllocator primary_;\n   SecondaryAllocator secondary_;\n+  AllocatorGlobalStats stats_;\n };\n \n+// Returns true if calloc(size, n) should return 0 due to overflow in size*n.\n+bool CallocShouldReturnNullDueToOverflow(uptr size, uptr n);\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_ALLOCATOR_H"}, {"sha": "4447c346eba063ca4a29927ef248f05162b7cbae", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -14,6 +14,8 @@\n \n namespace __sanitizer {\n \n+const char *SanitizerToolName = \"SanitizerTool\";\n+\n uptr GetPageSizeCached() {\n   static uptr PageSize;\n   if (!PageSize)\n@@ -64,7 +66,7 @@ static void MaybeOpenReportFile() {\n   InternalScopedBuffer<char> report_path_full(4096);\n   internal_snprintf(report_path_full.data(), report_path_full.size(),\n                     \"%s.%d\", report_path_prefix, GetPid());\n-  fd_t fd = internal_open(report_path_full.data(), true);\n+  fd_t fd = OpenFile(report_path_full.data(), true);\n   if (fd == kInvalidFd) {\n     report_fd = kStderrFd;\n     log_to_file = false;\n@@ -103,7 +105,7 @@ uptr ReadFileToBuffer(const char *file_name, char **buff,\n   *buff_size = 0;\n   // The files we usually open are not seekable, so try different buffer sizes.\n   for (uptr size = kMinFileLen; size <= max_len; size *= 2) {\n-    fd_t fd = internal_open(file_name, /*write*/ false);\n+    fd_t fd = OpenFile(file_name, /*write*/ false);\n     if (fd == kInvalidFd) return 0;\n     UnmapOrDie(*buff, *buff_size);\n     *buff = (char*)MmapOrDie(size, __FUNCTION__);\n@@ -188,6 +190,16 @@ void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type) {\n   return (void*)res;\n }\n \n+void ReportErrorSummary(const char *error_type, const char *file,\n+                        int line, const char *function) {\n+  const int kMaxSize = 1024;  // We don't want a summary too long.\n+  InternalScopedBuffer<char> buff(kMaxSize);\n+  internal_snprintf(buff.data(), kMaxSize, \"%s: %s %s:%d %s\",\n+                    SanitizerToolName, error_type,\n+                    file ? file : \"??\", line, function ? function : \"??\");\n+  __sanitizer_report_error_summary(buff.data());\n+}\n+\n }  // namespace __sanitizer\n \n using namespace __sanitizer;  // NOLINT\n@@ -220,4 +232,8 @@ void NOINLINE __sanitizer_sandbox_on_notify(void *reserved) {\n   (void)reserved;\n   PrepareForSandboxing();\n }\n+\n+void __sanitizer_report_error_summary(const char *error_summary) {\n+  Printf(\"SUMMARY: %s\\n\", error_summary);\n+}\n }  // extern \"C\""}, {"sha": "109966ba3608df87aac619de692cd5bc1b850c52", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -17,6 +17,7 @@\n #include \"sanitizer_internal_defs.h\"\n \n namespace __sanitizer {\n+struct StackTrace;\n \n // Constants.\n const uptr kWordSize = SANITIZER_WORDSIZE / 8;\n@@ -28,6 +29,8 @@ const uptr kCacheLineSize = 128;\n const uptr kCacheLineSize = 64;\n #endif\n \n+extern const char *SanitizerToolName;  // Can be changed by the tool.\n+\n uptr GetPageSize();\n uptr GetPageSizeCached();\n uptr GetMmapGranularity();\n@@ -103,6 +106,7 @@ void Printf(const char *format, ...);\n void Report(const char *format, ...);\n void SetPrintfAndReportCallback(void (*callback)(const char *));\n \n+fd_t OpenFile(const char *filename, bool write);\n // Opens the file 'file_name\" and reads up to 'max_len' bytes.\n // The resulting buffer is mmaped and stored in '*buff'.\n // The size of the mmaped region is stored in '*buff_size',\n@@ -152,20 +156,79 @@ typedef void (*CheckFailedCallbackType)(const char *, int, const char *,\n                                        u64, u64);\n void SetCheckFailedCallback(CheckFailedCallbackType callback);\n \n+// Construct a one-line string like\n+//  SanitizerToolName: error_type file:line function\n+// and call __sanitizer_report_error_summary on it.\n+void ReportErrorSummary(const char *error_type, const char *file,\n+                        int line, const char *function);\n+\n // Math\n+#if defined(_WIN32) && !defined(__clang__)\n+extern \"C\" {\n+unsigned char _BitScanForward(unsigned long *index, unsigned long mask);  // NOLINT\n+unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);  // NOLINT\n+#if defined(_WIN64)\n+unsigned char _BitScanForward64(unsigned long *index, unsigned __int64 mask);  // NOLINT\n+unsigned char _BitScanReverse64(unsigned long *index, unsigned __int64 mask);  // NOLINT\n+#endif\n+}\n+#endif\n+\n+INLINE uptr MostSignificantSetBitIndex(uptr x) {\n+  CHECK(x != 0);\n+  unsigned long up;  // NOLINT\n+#if !defined(_WIN32) || defined(__clang__)\n+  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);\n+#elif defined(_WIN64)\n+  _BitScanReverse64(&up, x);\n+#else\n+  _BitScanReverse(&up, x);\n+#endif\n+  return up;\n+}\n+\n INLINE bool IsPowerOfTwo(uptr x) {\n   return (x & (x - 1)) == 0;\n }\n+\n+INLINE uptr RoundUpToPowerOfTwo(uptr size) {\n+  CHECK(size);\n+  if (IsPowerOfTwo(size)) return size;\n+\n+  uptr up = MostSignificantSetBitIndex(size);\n+  CHECK(size < (1ULL << (up + 1)));\n+  CHECK(size > (1ULL << up));\n+  return 1UL << (up + 1);\n+}\n+\n INLINE uptr RoundUpTo(uptr size, uptr boundary) {\n   CHECK(IsPowerOfTwo(boundary));\n   return (size + boundary - 1) & ~(boundary - 1);\n }\n+\n INLINE uptr RoundDownTo(uptr x, uptr boundary) {\n   return x & ~(boundary - 1);\n }\n+\n INLINE bool IsAligned(uptr a, uptr alignment) {\n   return (a & (alignment - 1)) == 0;\n }\n+\n+INLINE uptr Log2(uptr x) {\n+  CHECK(IsPowerOfTwo(x));\n+#if !defined(_WIN32) || defined(__clang__)\n+  return __builtin_ctzl(x);\n+#elif defined(_WIN64)\n+  unsigned long ret;  // NOLINT\n+  _BitScanForward64(&ret, x);\n+  return ret;\n+#else\n+  unsigned long ret;  // NOLINT\n+  _BitScanForward(&ret, x);\n+  return ret;\n+#endif\n+}\n+\n // Don't use std::min, std::max or std::swap, to minimize dependency\n // on libstdc++.\n template<class T> T Min(T a, T b) { return a < b ? a : b; }"}, {"sha": "4ba7b8fee9f62ba6c30f943a61cf140750eee784", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 113, "deletions": 97, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -22,9 +22,13 @@\n \n #include <stdarg.h>\n \n+#ifdef _WIN32\n+#define va_copy(dst, src) ((dst) = (src))\n+#endif // _WIN32\n+\n #if SANITIZER_INTERCEPT_READ\n INTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {\n-  void* ctx;\n+  void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, read, fd, ptr, count);\n   SSIZE_T res = REAL(read)(fd, ptr, count);\n   if (res > 0)\n@@ -33,14 +37,14 @@ INTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {\n     COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n   return res;\n }\n-# define INIT_READ INTERCEPT_FUNCTION(read)\n+#define INIT_READ INTERCEPT_FUNCTION(read)\n #else\n-# define INIT_READ\n+#define INIT_READ\n #endif\n \n #if SANITIZER_INTERCEPT_PREAD\n INTERCEPTOR(SSIZE_T, pread, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n-  void* ctx;\n+  void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pread, fd, ptr, count, offset);\n   SSIZE_T res = REAL(pread)(fd, ptr, count, offset);\n   if (res > 0)\n@@ -49,14 +53,14 @@ INTERCEPTOR(SSIZE_T, pread, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n     COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n   return res;\n }\n-# define INIT_PREAD INTERCEPT_FUNCTION(pread)\n+#define INIT_PREAD INTERCEPT_FUNCTION(pread)\n #else\n-# define INIT_PREAD\n+#define INIT_PREAD\n #endif\n \n #if SANITIZER_INTERCEPT_PREAD64\n INTERCEPTOR(SSIZE_T, pread64, int fd, void *ptr, SIZE_T count, OFF64_T offset) {\n-  void* ctx;\n+  void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pread64, fd, ptr, count, offset);\n   SSIZE_T res = REAL(pread64)(fd, ptr, count, offset);\n   if (res > 0)\n@@ -65,14 +69,14 @@ INTERCEPTOR(SSIZE_T, pread64, int fd, void *ptr, SIZE_T count, OFF64_T offset) {\n     COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n   return res;\n }\n-# define INIT_PREAD64 INTERCEPT_FUNCTION(pread64)\n+#define INIT_PREAD64 INTERCEPT_FUNCTION(pread64)\n #else\n-# define INIT_PREAD64\n+#define INIT_PREAD64\n #endif\n \n #if SANITIZER_INTERCEPT_WRITE\n INTERCEPTOR(SSIZE_T, write, int fd, void *ptr, SIZE_T count) {\n-  void* ctx;\n+  void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, write, fd, ptr, count);\n   if (fd >= 0)\n     COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n@@ -81,142 +85,154 @@ INTERCEPTOR(SSIZE_T, write, int fd, void *ptr, SIZE_T count) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n   return res;\n }\n-# define INIT_WRITE INTERCEPT_FUNCTION(write)\n+#define INIT_WRITE INTERCEPT_FUNCTION(write)\n #else\n-# define INIT_WRITE\n+#define INIT_WRITE\n #endif\n \n #if SANITIZER_INTERCEPT_PWRITE\n-INTERCEPTOR(SSIZE_T, pwrite, int fd, void *ptr, SIZE_T count) {\n-  void* ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, pwrite, fd, ptr, count);\n+INTERCEPTOR(SSIZE_T, pwrite, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pwrite, fd, ptr, count, offset);\n   if (fd >= 0)\n     COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n-  SSIZE_T res = REAL(pwrite)(fd, ptr, count);\n+  SSIZE_T res = REAL(pwrite)(fd, ptr, count, offset);\n   if (res > 0)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n   return res;\n }\n-# define INIT_PWRITE INTERCEPT_FUNCTION(pwrite)\n+#define INIT_PWRITE INTERCEPT_FUNCTION(pwrite)\n #else\n-# define INIT_PWRITE\n+#define INIT_PWRITE\n #endif\n \n #if SANITIZER_INTERCEPT_PWRITE64\n-INTERCEPTOR(SSIZE_T, pwrite64, int fd, void *ptr, OFF64_T count) {\n-  void* ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, pwrite64, fd, ptr, count);\n+INTERCEPTOR(SSIZE_T, pwrite64, int fd, void *ptr, OFF64_T count,\n+            OFF64_T offset) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pwrite64, fd, ptr, count, offset);\n   if (fd >= 0)\n     COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n-  SSIZE_T res = REAL(pwrite64)(fd, ptr, count);\n+  SSIZE_T res = REAL(pwrite64)(fd, ptr, count, offset);\n   if (res > 0)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n   return res;\n }\n-# define INIT_PWRITE64 INTERCEPT_FUNCTION(pwrite64)\n+#define INIT_PWRITE64 INTERCEPT_FUNCTION(pwrite64)\n #else\n-# define INIT_PWRITE64\n+#define INIT_PWRITE64\n #endif\n \n #if SANITIZER_INTERCEPT_PRCTL\n-INTERCEPTOR(int, prctl, int option,\n-            unsigned long arg2, unsigned long arg3,  // NOLINT\n-            unsigned long arg4, unsigned long arg5) {  // NOLINT\n-  void* ctx;\n+INTERCEPTOR(int, prctl, int option, unsigned long arg2,\n+            unsigned long arg3,                       // NOLINT\n+            unsigned long arg4, unsigned long arg5) { // NOLINT\n+  void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, prctl, option, arg2, arg3, arg4, arg5);\n   static const int PR_SET_NAME = 15;\n   int res = REAL(prctl(option, arg2, arg3, arg4, arg5));\n   if (option == PR_SET_NAME) {\n     char buff[16];\n-    internal_strncpy(buff, (char*)arg2, 15);\n+    internal_strncpy(buff, (char *)arg2, 15);\n     buff[15] = 0;\n     COMMON_INTERCEPTOR_SET_THREAD_NAME(ctx, buff);\n   }\n   return res;\n }\n-# define INIT_PRCTL INTERCEPT_FUNCTION(prctl)\n+#define INIT_PRCTL INTERCEPT_FUNCTION(prctl)\n #else\n-# define INIT_PRCTL\n-#endif  // SANITIZER_INTERCEPT_PRCTL\n-\n+#define INIT_PRCTL\n+#endif // SANITIZER_INTERCEPT_PRCTL\n \n #if SANITIZER_INTERCEPT_SCANF\n \n #include \"sanitizer_common_interceptors_scanf.inc\"\n \n-INTERCEPTOR(int, vscanf, const char *format, va_list ap) {  // NOLINT\n-  void* ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, vscanf, format, ap);\n-  scanf_common(ctx, format, ap);\n-  int res = REAL(vscanf)(format, ap);  // NOLINT\n-  return res;\n-}\n+#define VSCANF_INTERCEPTOR_IMPL(vname, allowGnuMalloc, ...)                    \\\n+  {                                                                            \\\n+    void *ctx;                                                                 \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, vname, __VA_ARGS__);                         \\\n+    va_list aq;                                                                \\\n+    va_copy(aq, ap);                                                           \\\n+    int res = REAL(vname)(__VA_ARGS__);                                        \\\n+    if (res > 0)                                                               \\\n+      scanf_common(ctx, res, allowGnuMalloc, format, aq);                      \\\n+    va_end(aq);                                                                \\\n+    return res;                                                                \\\n+  }\n \n-INTERCEPTOR(int, vsscanf, const char *str, const char *format,  // NOLINT\n-    va_list ap) {\n-  void* ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, vsscanf, str, format, ap);\n-  scanf_common(ctx, format, ap);\n-  int res = REAL(vsscanf)(str, format, ap);  // NOLINT\n-  // FIXME: read of str\n-  return res;\n-}\n+INTERCEPTOR(int, vscanf, const char *format, va_list ap)\n+VSCANF_INTERCEPTOR_IMPL(vscanf, true, format, ap)\n \n-INTERCEPTOR(int, vfscanf, void *stream, const char *format,  // NOLINT\n-    va_list ap) {\n-  void* ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, vfscanf, stream, format, ap);\n-  scanf_common(ctx, format, ap);\n-  int res = REAL(vfscanf)(stream, format, ap);  // NOLINT\n-  return res;\n-}\n+INTERCEPTOR(int, vsscanf, const char *str, const char *format, va_list ap)\n+VSCANF_INTERCEPTOR_IMPL(vsscanf, true, str, format, ap)\n \n-INTERCEPTOR(int, scanf, const char *format, ...) {  // NOLINT\n-  void* ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, scanf, format);\n-  va_list ap;\n-  va_start(ap, format);\n-  int res = vscanf(format, ap);  // NOLINT\n-  va_end(ap);\n-  return res;\n-}\n+INTERCEPTOR(int, vfscanf, void *stream, const char *format, va_list ap)\n+VSCANF_INTERCEPTOR_IMPL(vfscanf, true, stream, format, ap)\n \n-INTERCEPTOR(int, fscanf, void* stream, const char *format, ...) {  // NOLINT\n-  void* ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, fscanf, stream, format);\n-  va_list ap;\n-  va_start(ap, format);\n-  int res = vfscanf(stream, format, ap);  // NOLINT\n-  va_end(ap);\n-  return res;\n-}\n+INTERCEPTOR(int, __isoc99_vscanf, const char *format, va_list ap)\n+VSCANF_INTERCEPTOR_IMPL(__isoc99_vscanf, false, format, ap)\n \n-INTERCEPTOR(int, sscanf, const char *str, const char *format, ...) {  // NOLINT\n-  void* ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, sscanf, str, format);  // NOLINT\n-  va_list ap;\n-  va_start(ap, format);\n-  int res = vsscanf(str, format, ap);  // NOLINT\n-  va_end(ap);\n-  return res;\n-}\n+INTERCEPTOR(int, __isoc99_vsscanf, const char *str, const char *format,\n+            va_list ap)\n+VSCANF_INTERCEPTOR_IMPL(__isoc99_vsscanf, false, str, format, ap)\n+\n+INTERCEPTOR(int, __isoc99_vfscanf, void *stream, const char *format, va_list ap)\n+VSCANF_INTERCEPTOR_IMPL(__isoc99_vfscanf, false, stream, format, ap)\n+\n+#define SCANF_INTERCEPTOR_IMPL(name, vname, ...)                               \\\n+  {                                                                            \\\n+    void *ctx;                                                                 \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, name, __VA_ARGS__);                          \\\n+    va_list ap;                                                                \\\n+    va_start(ap, format);                                                      \\\n+    int res = vname(__VA_ARGS__, ap);                                          \\\n+    va_end(ap);                                                                \\\n+    return res;                                                                \\\n+  }\n+\n+INTERCEPTOR(int, scanf, const char *format, ...)\n+SCANF_INTERCEPTOR_IMPL(scanf, vscanf, format)\n+\n+INTERCEPTOR(int, fscanf, void *stream, const char *format, ...)\n+SCANF_INTERCEPTOR_IMPL(fscanf, vfscanf, stream, format)\n+\n+INTERCEPTOR(int, sscanf, const char *str, const char *format, ...)\n+SCANF_INTERCEPTOR_IMPL(sscanf, vsscanf, str, format)\n+\n+INTERCEPTOR(int, __isoc99_scanf, const char *format, ...)\n+SCANF_INTERCEPTOR_IMPL(__isoc99_scanf, __isoc99_vscanf, format)\n+\n+INTERCEPTOR(int, __isoc99_fscanf, void *stream, const char *format, ...)\n+SCANF_INTERCEPTOR_IMPL(__isoc99_fscanf, __isoc99_vfscanf, stream, format)\n+\n+INTERCEPTOR(int, __isoc99_sscanf, const char *str, const char *format, ...)\n+SCANF_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n \n-#define INIT_SCANF \\\n-  INTERCEPT_FUNCTION(scanf);                    \\\n-  INTERCEPT_FUNCTION(sscanf);  /* NOLINT */     \\\n-  INTERCEPT_FUNCTION(fscanf);                   \\\n-  INTERCEPT_FUNCTION(vscanf);                   \\\n-  INTERCEPT_FUNCTION(vsscanf);                  \\\n-  INTERCEPT_FUNCTION(vfscanf)\n+#define INIT_SCANF                                                             \\\n+  INTERCEPT_FUNCTION(scanf);                                                   \\\n+  INTERCEPT_FUNCTION(sscanf);                                                  \\\n+  INTERCEPT_FUNCTION(fscanf);                                                  \\\n+  INTERCEPT_FUNCTION(vscanf);                                                  \\\n+  INTERCEPT_FUNCTION(vsscanf);                                                 \\\n+  INTERCEPT_FUNCTION(vfscanf);                                                 \\\n+  INTERCEPT_FUNCTION(__isoc99_scanf);                                          \\\n+  INTERCEPT_FUNCTION(__isoc99_sscanf);                                         \\\n+  INTERCEPT_FUNCTION(__isoc99_fscanf);                                         \\\n+  INTERCEPT_FUNCTION(__isoc99_vscanf);                                         \\\n+  INTERCEPT_FUNCTION(__isoc99_vsscanf);                                        \\\n+  INTERCEPT_FUNCTION(__isoc99_vfscanf);\n \n #else\n #define INIT_SCANF\n #endif\n \n-#define SANITIZER_COMMON_INTERCEPTORS_INIT \\\n-  INIT_READ;                               \\\n-  INIT_PREAD;                              \\\n-  INIT_PREAD64;                            \\\n-  INIT_PRCTL;                              \\\n-  INIT_WRITE;                              \\\n+#define SANITIZER_COMMON_INTERCEPTORS_INIT                                     \\\n+  INIT_READ;                                                                   \\\n+  INIT_PREAD;                                                                  \\\n+  INIT_PREAD64;                                                                \\\n+  INIT_PRCTL;                                                                  \\\n+  INIT_WRITE;                                                                  \\\n+  INIT_PWRITE;                                                                 \\\n+  INIT_PWRITE64;                                                               \\\n   INIT_SCANF;"}, {"sha": "5b761382d3e31453037aa0f2642e04e0eb939bc4", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_scanf.inc", "status": "modified", "additions": 264, "deletions": 101, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -6,139 +6,302 @@\n //===----------------------------------------------------------------------===//\n //\n // Scanf implementation for use in *Sanitizer interceptors.\n+// Follows http://pubs.opengroup.org/onlinepubs/9699919799/functions/fscanf.html\n+// with a few common GNU extensions.\n //\n //===----------------------------------------------------------------------===//\n #include <stdarg.h>\n \n-#ifdef _WIN32\n-#define va_copy(dst, src) ((dst) = (src))\n-#endif  // _WIN32\n-\n-struct ScanfSpec {\n-  char c;\n-  unsigned size;\n-};\n-\n-// One-letter specs.\n-static const ScanfSpec scanf_specs[] = {\n-  {'p', sizeof(void *)},\n-  {'e', sizeof(float)},\n-  {'E', sizeof(float)},\n-  {'a', sizeof(float)},\n-  {'f', sizeof(float)},\n-  {'g', sizeof(float)},\n-  {'d', sizeof(int)},\n-  {'i', sizeof(int)},\n-  {'o', sizeof(int)},\n-  {'u', sizeof(int)},\n-  {'x', sizeof(int)},\n-  {'X', sizeof(int)},\n-  {'n', sizeof(int)},\n-  {'t', sizeof(PTRDIFF_T)},\n-  {'z', sizeof(SIZE_T)},\n-  {'j', sizeof(INTMAX_T)},\n-  {'h', sizeof(short)}\n-};\n-\n-static const unsigned scanf_specs_cnt =\n-  sizeof(scanf_specs) / sizeof(scanf_specs[0]);\n-\n-// %ll?, %L?, %q? specs\n-static const ScanfSpec scanf_llspecs[] = {\n-  {'e', sizeof(long double)},\n-  {'f', sizeof(long double)},\n-  {'g', sizeof(long double)},\n-  {'d', sizeof(long long)},\n-  {'i', sizeof(long long)},\n-  {'o', sizeof(long long)},\n-  {'u', sizeof(long long)},\n-  {'x', sizeof(long long)}\n+struct ScanfDirective {\n+  int argIdx; // argument index, or -1 of not specified (\"%n$\")\n+  int fieldWidth;\n+  bool suppressed; // suppress assignment (\"*\")\n+  bool allocate;   // allocate space (\"m\")\n+  char lengthModifier[2];\n+  char convSpecifier;\n+  bool maybeGnuMalloc;\n };\n \n-static const unsigned scanf_llspecs_cnt =\n-  sizeof(scanf_llspecs) / sizeof(scanf_llspecs[0]);\n-\n-// %l? specs\n-static const ScanfSpec scanf_lspecs[] = {\n-  {'e', sizeof(double)},\n-  {'f', sizeof(double)},\n-  {'g', sizeof(double)},\n-  {'d', sizeof(long)},\n-  {'i', sizeof(long)},\n-  {'o', sizeof(long)},\n-  {'u', sizeof(long)},\n-  {'x', sizeof(long)},\n-  {'X', sizeof(long)},\n-};\n-\n-static const unsigned scanf_lspecs_cnt =\n-  sizeof(scanf_lspecs) / sizeof(scanf_lspecs[0]);\n-\n-static unsigned match_spec(const struct ScanfSpec *spec, unsigned n, char c) {\n-  for (unsigned i = 0; i < n; ++i)\n-    if (spec[i].c == c)\n-      return spec[i].size;\n-  return 0;\n+static const char *parse_number(const char *p, int *out) {\n+  *out = internal_atoll(p);\n+  while (*p >= '0' && *p <= '9')\n+    ++p;\n+  return p;\n }\n \n-static void scanf_common(void *ctx, const char *format, va_list ap_const) {\n-  va_list aq;\n-  va_copy(aq, ap_const);\n+static bool char_is_one_of(char c, const char *s) {\n+  return !!internal_strchr(s, c);\n+}\n \n-  const char *p = format;\n-  unsigned size;\n+// Parse scanf format string. If a valid directive in encountered, it is\n+// returned in dir. This function returns the pointer to the first\n+// unprocessed character, or 0 in case of error.\n+// In case of the end-of-string, a pointer to the closing \\0 is returned.\n+static const char *scanf_parse_next(const char *p, bool allowGnuMalloc,\n+                                    ScanfDirective *dir) {\n+  internal_memset(dir, 0, sizeof(*dir));\n+  dir->argIdx = -1;\n \n   while (*p) {\n     if (*p != '%') {\n       ++p;\n       continue;\n     }\n     ++p;\n-    if (*p == '*' || *p == '%' || *p == 0) {\n+    // %%\n+    if (*p == '%') {\n       ++p;\n       continue;\n     }\n-    if (*p == '0' || (*p >= '1' && *p <= '9')) {\n-      size = internal_atoll(p);\n-      // +1 for the \\0 at the end\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), size + 1);\n+    if (*p == '\\0') {\n+      return 0;\n+    }\n+    // %n$\n+    if (*p >= '0' && *p <= '9') {\n+      int number;\n+      const char *q = parse_number(p, &number);\n+      if (*q == '$') {\n+        dir->argIdx = number;\n+        p = q + 1;\n+      }\n+      // Otherwise, do not change p. This will be re-parsed later as the field\n+      // width.\n+    }\n+    // *\n+    if (*p == '*') {\n+      dir->suppressed = true;\n       ++p;\n-      continue;\n     }\n-\n-    if (*p == 'L' || *p == 'q') {\n+    // Field width.\n+    if (*p >= '0' && *p <= '9') {\n+      p = parse_number(p, &dir->fieldWidth);\n+      if (dir->fieldWidth <= 0)\n+        return 0;\n+    }\n+    // m\n+    if (*p == 'm') {\n+      dir->allocate = true;\n       ++p;\n-      size = match_spec(scanf_llspecs, scanf_llspecs_cnt, *p);\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), size);\n-      continue;\n     }\n-\n-    if (*p == 'l') {\n+    // Length modifier.\n+    if (char_is_one_of(*p, \"jztLq\")) {\n+      dir->lengthModifier[0] = *p;\n+      ++p;\n+    } else if (*p == 'h') {\n+      dir->lengthModifier[0] = 'h';\n+      ++p;\n+      if (*p == 'h') {\n+        dir->lengthModifier[1] = 'h';\n+        ++p;\n+      }\n+    } else if (*p == 'l') {\n+      dir->lengthModifier[0] = 'l';\n       ++p;\n       if (*p == 'l') {\n+        dir->lengthModifier[1] = 'l';\n         ++p;\n-        size = match_spec(scanf_llspecs, scanf_llspecs_cnt, *p);\n-        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), size);\n-        continue;\n-      } else {\n-        size = match_spec(scanf_lspecs, scanf_lspecs_cnt, *p);\n-        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), size);\n-        continue;\n       }\n     }\n+    // Conversion specifier.\n+    dir->convSpecifier = *p++;\n+    // Consume %[...] expression.\n+    if (dir->convSpecifier == '[') {\n+      if (*p == '^')\n+        ++p;\n+      if (*p == ']')\n+        ++p;\n+      while (*p && *p != ']')\n+        ++p;\n+      if (*p == 0)\n+        return 0; // unexpected end of string\n+                  // Consume the closing ']'.\n+      ++p;\n+    }\n+    // This is unfortunately ambiguous between old GNU extension\n+    // of %as, %aS and %a[...] and newer POSIX %a followed by\n+    // letters s, S or [.\n+    if (allowGnuMalloc && dir->convSpecifier == 'a' &&\n+        !dir->lengthModifier[0]) {\n+      if (*p == 's' || *p == 'S') {\n+        dir->maybeGnuMalloc = true;\n+        ++p;\n+      } else if (*p == '[') {\n+        // Watch for %a[h-j%d], if % appears in the\n+        // [...] range, then we need to give up, we don't know\n+        // if scanf will parse it as POSIX %a [h-j %d ] or\n+        // GNU allocation of string with range dh-j plus %.\n+        const char *q = p + 1;\n+        if (*q == '^')\n+          ++q;\n+        if (*q == ']')\n+          ++q;\n+        while (*q && *q != ']' && *q != '%')\n+          ++q;\n+        if (*q == 0 || *q == '%')\n+          return 0;\n+        p = q + 1; // Consume the closing ']'.\n+        dir->maybeGnuMalloc = true;\n+      }\n+    }\n+    break;\n+  }\n+  return p;\n+}\n \n-    if (*p == 'h' && *(p + 1) == 'h') {\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), sizeof(char));\n-      p += 2;\n-      continue;\n+// Returns true if the character is an integer conversion specifier.\n+static bool scanf_is_integer_conv(char c) {\n+  return char_is_one_of(c, \"diouxXn\");\n+}\n+\n+// Returns true if the character is an floating point conversion specifier.\n+static bool scanf_is_float_conv(char c) {\n+  return char_is_one_of(c, \"aAeEfFgG\");\n+}\n+\n+// Returns string output character size for string-like conversions,\n+// or 0 if the conversion is invalid.\n+static int scanf_get_char_size(ScanfDirective *dir) {\n+  if (char_is_one_of(dir->convSpecifier, \"CS\")) {\n+    // wchar_t\n+    return 0;\n+  }\n+\n+  if (char_is_one_of(dir->convSpecifier, \"cs[\")) {\n+    if (dir->lengthModifier[0] == 'l')\n+      // wchar_t\n+      return 0;\n+    else if (dir->lengthModifier[0] == 0)\n+      return sizeof(char);\n+    else\n+      return 0;\n+  }\n+\n+  return 0;\n+}\n+\n+enum ScanfStoreSize {\n+  // Store size not known in advance; can be calculated as strlen() of the\n+  // destination buffer.\n+  SSS_STRLEN = -1,\n+  // Invalid conversion specifier.\n+  SSS_INVALID = 0\n+};\n+\n+// Returns the store size of a scanf directive (if >0), or a value of\n+// ScanfStoreSize.\n+static int scanf_get_store_size(ScanfDirective *dir) {\n+  if (dir->allocate) {\n+    if (!char_is_one_of(dir->convSpecifier, \"cCsS[\"))\n+      return SSS_INVALID;\n+    return sizeof(char *);\n+  }\n+\n+  if (dir->maybeGnuMalloc) {\n+    if (dir->convSpecifier != 'a' || dir->lengthModifier[0])\n+      return SSS_INVALID;\n+    // This is ambiguous, so check the smaller size of char * (if it is\n+    // a GNU extension of %as, %aS or %a[...]) and float (if it is\n+    // POSIX %a followed by s, S or [ letters).\n+    return sizeof(char *) < sizeof(float) ? sizeof(char *) : sizeof(float);\n+  }\n+\n+  if (scanf_is_integer_conv(dir->convSpecifier)) {\n+    switch (dir->lengthModifier[0]) {\n+    case 'h':\n+      return dir->lengthModifier[1] == 'h' ? sizeof(char) : sizeof(short);\n+    case 'l':\n+      return dir->lengthModifier[1] == 'l' ? sizeof(long long) : sizeof(long);\n+    case 'L':\n+      return sizeof(long long);\n+    case 'j':\n+      return sizeof(INTMAX_T);\n+    case 'z':\n+      return sizeof(SIZE_T);\n+    case 't':\n+      return sizeof(PTRDIFF_T);\n+    case 0:\n+      return sizeof(int);\n+    default:\n+      return SSS_INVALID;\n     }\n+  }\n \n-    size = match_spec(scanf_specs, scanf_specs_cnt, *p);\n-    if (size) {\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), size);\n-      ++p;\n+  if (scanf_is_float_conv(dir->convSpecifier)) {\n+    switch (dir->lengthModifier[0]) {\n+    case 'L':\n+    case 'q':\n+      return sizeof(long double);\n+    case 'l':\n+      return dir->lengthModifier[1] == 'l' ? sizeof(long double)\n+                                           : sizeof(double);\n+    case 0:\n+      return sizeof(float);\n+    default:\n+      return SSS_INVALID;\n+    }\n+  }\n+\n+  if (char_is_one_of(dir->convSpecifier, \"sS[\")) {\n+    unsigned charSize = scanf_get_char_size(dir);\n+    if (charSize == 0)\n+      return SSS_INVALID;\n+    if (dir->fieldWidth == 0)\n+      return SSS_STRLEN;\n+    return (dir->fieldWidth + 1) * charSize;\n+  }\n+\n+  if (char_is_one_of(dir->convSpecifier, \"cC\")) {\n+    unsigned charSize = scanf_get_char_size(dir);\n+    if (charSize == 0)\n+      return SSS_INVALID;\n+    if (dir->fieldWidth == 0)\n+      return charSize;\n+    return dir->fieldWidth * charSize;\n+  }\n+\n+  if (dir->convSpecifier == 'p') {\n+    if (dir->lengthModifier[1] != 0)\n+      return SSS_INVALID;\n+    return sizeof(void *);\n+  }\n+\n+  return SSS_INVALID;\n+}\n+\n+// Common part of *scanf interceptors.\n+// Process format string and va_list, and report all store ranges.\n+// Stops when \"consuming\" n_inputs input items.\n+static void scanf_common(void *ctx, int n_inputs, bool allowGnuMalloc,\n+                         const char *format, va_list aq) {\n+  CHECK_GT(n_inputs, 0);\n+  const char *p = format;\n+\n+  while (*p && n_inputs) {\n+    ScanfDirective dir;\n+    p = scanf_parse_next(p, allowGnuMalloc, &dir);\n+    if (!p)\n+      break;\n+    if (dir.convSpecifier == 0) {\n+      // This can only happen at the end of the format string.\n+      CHECK_EQ(*p, 0);\n+      break;\n+    }\n+    // Here the directive is valid. Do what it says.\n+    if (dir.argIdx != -1) {\n+      // Unsupported.\n+      break;\n+    }\n+    if (dir.suppressed)\n       continue;\n+    int size = scanf_get_store_size(&dir);\n+    if (size == SSS_INVALID)\n+      break;\n+    void *argp = va_arg(aq, void *);\n+    if (dir.convSpecifier != 'n')\n+      --n_inputs;\n+    if (size == SSS_STRLEN) {\n+      size = internal_strlen((const char *)argp) + 1;\n     }\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, argp, size);\n   }\n-  va_end(aq);\n }"}, {"sha": "1a25b70c23ec3cf0588fa4ded87bed62dba3567e", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -11,7 +11,85 @@\n #ifndef SANITIZER_DEFS_H\n #define SANITIZER_DEFS_H\n \n-#include \"sanitizer/common_interface_defs.h\"\n+#if defined(_WIN32)\n+// FIXME find out what we need on Windows. __declspec(dllexport) ?\n+# define SANITIZER_INTERFACE_ATTRIBUTE\n+# define SANITIZER_WEAK_ATTRIBUTE\n+#elif defined(SANITIZER_GO)\n+# define SANITIZER_INTERFACE_ATTRIBUTE\n+# define SANITIZER_WEAK_ATTRIBUTE\n+#else\n+# define SANITIZER_INTERFACE_ATTRIBUTE __attribute__((visibility(\"default\")))\n+# define SANITIZER_WEAK_ATTRIBUTE  __attribute__((weak))\n+#endif\n+\n+#ifdef __linux__\n+# define SANITIZER_SUPPORTS_WEAK_HOOKS 1\n+#else\n+# define SANITIZER_SUPPORTS_WEAK_HOOKS 0\n+#endif\n+\n+// __has_feature\n+#if !defined(__has_feature)\n+# define __has_feature(x) 0\n+#endif\n+\n+// For portability reasons we do not include stddef.h, stdint.h or any other\n+// system header, but we do need some basic types that are not defined\n+// in a portable way by the language itself.\n+namespace __sanitizer {\n+\n+#if defined(_WIN64)\n+// 64-bit Windows uses LLP64 data model.\n+typedef unsigned long long uptr;  // NOLINT\n+typedef signed   long long sptr;  // NOLINT\n+#else\n+typedef unsigned long uptr;  // NOLINT\n+typedef signed   long sptr;  // NOLINT\n+#endif  // defined(_WIN64)\n+#if defined(__x86_64__)\n+// Since x32 uses ILP32 data model in 64-bit hardware mode,  we must use\n+// 64-bit pointer to unwind stack frame.\n+typedef unsigned long long uhwptr;  // NOLINT\n+#else\n+typedef uptr uhwptr;   // NOLINT\n+#endif\n+typedef unsigned char u8;\n+typedef unsigned short u16;  // NOLINT\n+typedef unsigned int u32;\n+typedef unsigned long long u64;  // NOLINT\n+typedef signed   char s8;\n+typedef signed   short s16;  // NOLINT\n+typedef signed   int s32;\n+typedef signed   long long s64;  // NOLINT\n+typedef int fd_t;\n+\n+}  // namespace __sanitizer\n+\n+extern \"C\" {\n+  // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n+  void __sanitizer_set_report_path(const char *path)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // Tell the tools to write their reports to given file descriptor instead of\n+  // stderr.\n+  void __sanitizer_set_report_fd(int fd)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // Notify the tools that the sandbox is going to be turned on. The reserved\n+  // parameter will be used in the future to hold a structure with functions\n+  // that the tools may call to bypass the sandbox.\n+  void __sanitizer_sandbox_on_notify(void *reserved)\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // This function is called by the tool when it has just finished reporting\n+  // an error. 'error_summary' is a one-line string that summarizes\n+  // the error message. This function can be overridden by the client.\n+  void __sanitizer_report_error_summary(const char *error_summary)\n+      SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+}  // extern \"C\"\n+\n+\n using namespace __sanitizer;  // NOLINT\n // ----------- ATTENTION -------------\n // This header should NOT include any other headers to avoid portability issues."}, {"sha": "8033b9a7f9cf54621e1330081fd3b5859b4b0dc5", "filename": "libsanitizer/sanitizer_common/sanitizer_lfstack.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -66,6 +66,6 @@ struct LFStack {\n \n   atomic_uint64_t head_;\n };\n-}\n+}  // namespace __sanitizer\n \n #endif  // #ifndef SANITIZER_LFSTACK_H"}, {"sha": "c57128a54cbd06641cab81db1f5cdea57503aed8", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -204,7 +204,7 @@ s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {\n }\n \n bool mem_is_zero(const char *beg, uptr size) {\n-  CHECK_LE(size, 1UL << FIRST_32_SECOND_64(30, 40));  // Sanity check.\n+  CHECK_LE(size, 1ULL << FIRST_32_SECOND_64(30, 40));  // Sanity check.\n   const char *end = beg + size;\n   uptr *aligned_beg = (uptr *)RoundUpTo((uptr)beg, sizeof(uptr));\n   uptr *aligned_end = (uptr *)RoundDownTo((uptr)end, sizeof(uptr));"}, {"sha": "7a9774406fa4113c1649341d676417899298b444", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -9,14 +9,13 @@\n // run-time libraries.\n // These tools can not use some of the libc functions directly because those\n // functions are intercepted. Instead, we implement a tiny subset of libc here.\n-// NOTE: This file may be included into user code.\n //===----------------------------------------------------------------------===//\n #ifndef SANITIZER_LIBC_H\n #define SANITIZER_LIBC_H\n \n // ----------- ATTENTION -------------\n // This header should NOT include any other headers from sanitizer runtime.\n-#include \"sanitizer/common_interface_defs.h\"\n+#include \"sanitizer_internal_defs.h\"\n \n namespace __sanitizer {\n \n@@ -56,17 +55,24 @@ void *internal_mmap(void *addr, uptr length, int prot, int flags,\n int internal_munmap(void *addr, uptr length);\n \n // I/O\n-typedef int fd_t;\n const fd_t kInvalidFd = -1;\n const fd_t kStdinFd = 0;\n const fd_t kStdoutFd = 1;\n const fd_t kStderrFd = 2;\n int internal_close(fd_t fd);\n int internal_isatty(fd_t fd);\n-fd_t internal_open(const char *filename, bool write);\n+\n+// Use __sanitizer::OpenFile() instead.\n+fd_t internal_open(const char *filename, int flags);\n+fd_t internal_open(const char *filename, int flags, u32 mode);\n+\n uptr internal_read(fd_t fd, void *buf, uptr count);\n uptr internal_write(fd_t fd, const void *buf, uptr count);\n uptr internal_filesize(fd_t fd);  // -1 on error.\n+int internal_stat(const char *path, void *buf);\n+int internal_lstat(const char *path, void *buf);\n+int internal_fstat(fd_t fd, void *buf);\n+\n int internal_dup2(int oldfd, int newfd);\n uptr internal_readlink(const char *path, char *buf, uptr bufsize);\n int internal_snprintf(char *buffer, uptr length, const char *format, ...);"}, {"sha": "3d3aa0b00bdcb8f93f7aa28778b206a08afb8a26", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -28,11 +28,14 @@\n #include <sys/syscall.h>\n #include <sys/time.h>\n #include <sys/types.h>\n+#include <sys/prctl.h>\n #include <unistd.h>\n #include <unwind.h>\n #include <errno.h>\n-#include <sys/prctl.h>\n-#include <linux/futex.h>\n+\n+// <linux/futex.h> is broken on some linux distributions.\n+const int FUTEX_WAIT = 0;\n+const int FUTEX_WAKE = 1;\n \n // Are we using 32-bit or 64-bit syscalls?\n // x32 (which defines __x86_64__) has SANITIZER_WORDSIZE == 32\n@@ -63,8 +66,16 @@ int internal_close(fd_t fd) {\n   return syscall(__NR_close, fd);\n }\n \n-fd_t internal_open(const char *filename, bool write) {\n-  return syscall(__NR_open, filename,\n+fd_t internal_open(const char *filename, int flags) {\n+  return syscall(__NR_open, filename, flags);\n+}\n+\n+fd_t internal_open(const char *filename, int flags, u32 mode) {\n+  return syscall(__NR_open, filename, flags, mode);\n+}\n+\n+fd_t OpenFile(const char *filename, bool write) {\n+  return internal_open(filename,\n       write ? O_WRONLY | O_CREAT /*| O_CLOEXEC*/ : O_RDONLY, 0660);\n }\n \n@@ -80,16 +91,38 @@ uptr internal_write(fd_t fd, const void *buf, uptr count) {\n   return res;\n }\n \n+int internal_stat(const char *path, void *buf) {\n+#if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+  return syscall(__NR_stat, path, buf);\n+#else\n+  return syscall(__NR_stat64, path, buf);\n+#endif\n+}\n+\n+int internal_lstat(const char *path, void *buf) {\n+#if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+  return syscall(__NR_lstat, path, buf);\n+#else\n+  return syscall(__NR_lstat64, path, buf);\n+#endif\n+}\n+\n+int internal_fstat(fd_t fd, void *buf) {\n+#if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+  return syscall(__NR_fstat, fd, buf);\n+#else\n+  return syscall(__NR_fstat64, fd, buf);\n+#endif\n+}\n+\n uptr internal_filesize(fd_t fd) {\n #if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n   struct stat st;\n-  if (syscall(__NR_fstat, fd, &st))\n-    return -1;\n #else\n   struct stat64 st;\n-  if (syscall(__NR_fstat64, fd, &st))\n-    return -1;\n #endif\n+  if (internal_fstat(fd, &st))\n+    return -1;\n   return (uptr)st.st_size;\n }\n "}, {"sha": "309b5a94005ad89bb2f93d397a51dbc4374606ca", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -11,6 +11,12 @@\n //===----------------------------------------------------------------------===//\n \n #ifdef __APPLE__\n+// Use 64-bit inodes in file operations. ASan does not support OS X 10.5, so\n+// the clients will most certainly use 64-bit ones as well.\n+#ifndef _DARWIN_USE_64_BIT_INODE\n+#define _DARWIN_USE_64_BIT_INODE 1\n+#endif\n+#include <stdio.h>\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n@@ -46,9 +52,17 @@ int internal_close(fd_t fd) {\n   return close(fd);\n }\n \n-fd_t internal_open(const char *filename, bool write) {\n-  return open(filename,\n-              write ? O_WRONLY | O_CREAT : O_RDONLY, 0660);\n+fd_t internal_open(const char *filename, int flags) {\n+  return open(filename, flags);\n+}\n+\n+fd_t internal_open(const char *filename, int flags, u32 mode) {\n+  return open(filename, flags, mode);\n+}\n+\n+fd_t OpenFile(const char *filename, bool write) {\n+  return internal_open(filename,\n+      write ? O_WRONLY | O_CREAT : O_RDONLY, 0660);\n }\n \n uptr internal_read(fd_t fd, void *buf, uptr count) {\n@@ -59,9 +73,21 @@ uptr internal_write(fd_t fd, const void *buf, uptr count) {\n   return write(fd, buf, count);\n }\n \n+int internal_stat(const char *path, void *buf) {\n+  return stat(path, (struct stat *)buf);\n+}\n+\n+int internal_lstat(const char *path, void *buf) {\n+  return lstat(path, (struct stat *)buf);\n+}\n+\n+int internal_fstat(fd_t fd, void *buf) {\n+  return fstat(fd, (struct stat *)buf);\n+}\n+\n uptr internal_filesize(fd_t fd) {\n   struct stat st;\n-  if (fstat(fd, &st))\n+  if (internal_fstat(fd, &st))\n     return -1;\n   return (uptr)st.st_size;\n }"}, {"sha": "2c60253c5330c566776e1e93089d7d53124ab9f1", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -33,4 +33,4 @@\n # define SANITIZER_INTERCEPT_PWRITE64 SI_LINUX_NOT_ANDROID\n # define SANITIZER_INTERCEPT_PRCTL   SI_LINUX_NOT_ANDROID\n \n-# define SANITIZER_INTERCEPT_SCANF 0\n+# define SANITIZER_INTERCEPT_SCANF SI_NOT_WINDOWS"}, {"sha": "48c5ebaef3e49a3c62fce57dc9efd15da29c5b50", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -56,12 +56,12 @@ void *MmapOrDie(uptr size, const char *mem_type) {\n     if (recursion_count) {\n       // The Report() and CHECK calls below may call mmap recursively and fail.\n       // If we went into recursion, just die.\n-      RawWrite(\"AddressSanitizer is unable to mmap\\n\");\n+      RawWrite(\"ERROR: Failed to mmap\\n\");\n       Die();\n     }\n     recursion_count++;\n-    Report(\"ERROR: Failed to allocate 0x%zx (%zd) bytes of %s: %s\\n\",\n-           size, size, mem_type, strerror(errno));\n+    Report(\"ERROR: %s failed to allocate 0x%zx (%zd) bytes of %s: %s\\n\",\n+           SanitizerToolName, size, size, mem_type, strerror(errno));\n     DumpProcessMap();\n     CHECK(\"unable to mmap\" && 0);\n   }\n@@ -72,8 +72,8 @@ void UnmapOrDie(void *addr, uptr size) {\n   if (!addr || !size) return;\n   int res = internal_munmap(addr, size);\n   if (res != 0) {\n-    Report(\"ERROR: Failed to deallocate 0x%zx (%zd) bytes at address %p\\n\",\n-           size, size, addr);\n+    Report(\"ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\\n\",\n+           SanitizerToolName, size, size, addr);\n     CHECK(\"unable to unmap\" && 0);\n   }\n }\n@@ -86,8 +86,9 @@ void *MmapFixedNoReserve(uptr fixed_addr, uptr size) {\n       MAP_PRIVATE | MAP_ANON | MAP_FIXED | MAP_NORESERVE,\n       -1, 0);\n   if (p == (void*)-1)\n-    Report(\"ERROR: Failed to allocate 0x%zx (%zd) bytes at address %p (%d)\\n\",\n-           size, size, fixed_addr, errno);\n+    Report(\"ERROR: \"\n+           \"%s failed to allocate 0x%zx (%zd) bytes at address %p (%d)\\n\",\n+           SanitizerToolName, size, size, fixed_addr, errno);\n   return p;\n }\n \n@@ -99,8 +100,9 @@ void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n       MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n       -1, 0);\n   if (p == (void*)-1) {\n-    Report(\"ERROR: Failed to allocate 0x%zx (%zd) bytes at address %p (%d)\\n\",\n-           size, size, fixed_addr, errno);\n+    Report(\"ERROR:\"\n+           \" %s failed to allocate 0x%zx (%zd) bytes at address %p (%d)\\n\",\n+           SanitizerToolName, size, size, fixed_addr, errno);\n     CHECK(\"unable to mmap\" && 0);\n   }\n   return p;\n@@ -118,7 +120,7 @@ void FlushUnneededShadowMemory(uptr addr, uptr size) {\n }\n \n void *MapFileToMemory(const char *file_name, uptr *buff_size) {\n-  fd_t fd = internal_open(file_name, false);\n+  fd_t fd = OpenFile(file_name, false);\n   CHECK_NE(fd, kInvalidFd);\n   uptr fsize = internal_filesize(fd);\n   CHECK_NE(fsize, (uptr)-1);\n@@ -187,7 +189,7 @@ void SetStackSizeLimitInBytes(uptr limit) {\n   rlim.rlim_cur = limit;\n   rlim.rlim_max = limit;\n   if (setrlimit(RLIMIT_STACK, &rlim)) {\n-    Report(\"setrlimit() failed %d\\n\", errno);\n+    Report(\"ERROR: %s setrlimit() failed %d\\n\", SanitizerToolName, errno);\n     Die();\n   }\n   CHECK(!StackSizeIsUnlimited());"}, {"sha": "f3ad91a9cc21aa1a76535453acd2dc51ff3cdb67", "filename": "libsanitizer/sanitizer_common/sanitizer_quarantine.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -157,14 +157,14 @@ class QuarantineCache {\n     atomic_store(&size_, Size() + add, memory_order_relaxed);\n   }\n \n-  QuarantineBatch *NOINLINE AllocBatch(Callback cb) {\n+  NOINLINE QuarantineBatch* AllocBatch(Callback cb) {\n     QuarantineBatch *b = (QuarantineBatch *)cb.Allocate(sizeof(*b));\n     b->count = 0;\n     b->size = 0;\n     list_.push_back(b);\n     return b;\n   }\n };\n-}\n+}  // namespace __sanitizer\n \n #endif  // #ifndef SANITIZER_QUARANTINE_H"}, {"sha": "bf73cf14aad29e8ceec89d97792d3c3e2d275a0b", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -11,7 +11,7 @@\n #ifndef SANITIZER_STACKDEPOT_H\n #define SANITIZER_STACKDEPOT_H\n \n-#include \"sanitizer/common_interface_defs.h\"\n+#include \"sanitizer_internal_defs.h\"\n \n namespace __sanitizer {\n "}, {"sha": "259da0082e3e84ba6ead769188f690e4889eb73e", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -15,8 +15,9 @@\n #include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n-static const char *StripPathPrefix(const char *filepath,\n-                                   const char *strip_file_prefix) {\n+const char *StripPathPrefix(const char *filepath,\n+                            const char *strip_file_prefix) {\n+  if (filepath == 0) return 0;\n   if (filepath == internal_strstr(filepath, strip_file_prefix))\n     return filepath + internal_strlen(strip_file_prefix);\n   return filepath;"}, {"sha": "fd0c4671a61fbc2c7fad702e1b25d70ae208b2d6", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -55,6 +55,10 @@ struct StackTrace {\n                               u32 *compressed, uptr size);\n };\n \n+\n+const char *StripPathPrefix(const char *filepath,\n+                            const char *strip_file_prefix);\n+\n }  // namespace __sanitizer\n \n // Use this macro if you want to print stack trace with the caller"}, {"sha": "2c9cb2b0a55d4a2e18362a1405f265f60afc703e", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -174,6 +174,53 @@ class ExternalSymbolizer {\n \n static LowLevelAllocator symbolizer_allocator;  // Linker initialized.\n \n+#if SANITIZER_SUPPORTS_WEAK_HOOKS\n+extern \"C\" {\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+bool __sanitizer_symbolize_code(const char *ModuleName, u64 ModuleOffset,\n+                                char *Buffer, int MaxLength);\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+bool __sanitizer_symbolize_data(const char *ModuleName, u64 ModuleOffset,\n+                                char *Buffer, int MaxLength);\n+}  // extern \"C\"\n+\n+class InternalSymbolizer {\n+ public:\n+  typedef bool (*SanitizerSymbolizeFn)(const char*, u64, char*, int);\n+  static InternalSymbolizer *get() {\n+    if (__sanitizer_symbolize_code != 0 &&\n+        __sanitizer_symbolize_data != 0) {\n+      void *mem = symbolizer_allocator.Allocate(sizeof(InternalSymbolizer));\n+      return new(mem) InternalSymbolizer();\n+    }\n+    return 0;\n+  }\n+  char *SendCommand(bool is_data, const char *module_name, uptr module_offset) {\n+    SanitizerSymbolizeFn symbolize_fn = is_data ? __sanitizer_symbolize_data\n+                                                : __sanitizer_symbolize_code;\n+    if (symbolize_fn(module_name, module_offset, buffer_, kBufferSize))\n+      return buffer_;\n+    return 0;\n+  }\n+\n+ private:\n+  InternalSymbolizer() { }\n+\n+  static const int kBufferSize = 16 * 1024;\n+  char buffer_[kBufferSize];\n+};\n+#else  // SANITIZER_SUPPORTS_WEAK_HOOKS\n+\n+class InternalSymbolizer {\n+ public:\n+  static InternalSymbolizer *get() { return 0; }\n+  char *SendCommand(bool is_data, const char *module_name, uptr module_offset) {\n+    return 0;\n+  }\n+};\n+\n+#endif  // SANITIZER_SUPPORTS_WEAK_HOOKS\n+\n class Symbolizer {\n  public:\n   uptr SymbolizeCode(uptr addr, AddressInfo *frames, uptr max_frames) {\n@@ -266,8 +313,23 @@ class Symbolizer {\n     return true;\n   }\n \n+  bool IsSymbolizerAvailable() {\n+    if (internal_symbolizer_ == 0)\n+      internal_symbolizer_ = InternalSymbolizer::get();\n+    return internal_symbolizer_ || external_symbolizer_;\n+  }\n+\n  private:\n   char *SendCommand(bool is_data, const char *module_name, uptr module_offset) {\n+    // First, try to use internal symbolizer.\n+    if (internal_symbolizer_ == 0) {\n+      internal_symbolizer_ = InternalSymbolizer::get();\n+    }\n+    if (internal_symbolizer_) {\n+      return internal_symbolizer_->SendCommand(is_data, module_name,\n+                                               module_offset);\n+    }\n+    // Otherwise, fall back to external symbolizer.\n     if (external_symbolizer_ == 0) {\n       ReportExternalSymbolizerError(\n           \"WARNING: Trying to symbolize code, but external \"\n@@ -322,6 +384,7 @@ class Symbolizer {\n   uptr n_modules_;\n \n   ExternalSymbolizer *external_symbolizer_;  // Leaked.\n+  InternalSymbolizer *internal_symbolizer_;  // Leaked.\n };\n \n static Symbolizer symbolizer;  // Linker initialized.\n@@ -338,4 +401,8 @@ bool InitializeExternalSymbolizer(const char *path_to_symbolizer) {\n   return symbolizer.InitializeExternalSymbolizer(path_to_symbolizer);\n }\n \n+bool IsSymbolizerAvailable() {\n+  return symbolizer.IsSymbolizerAvailable();\n+}\n+\n }  // namespace __sanitizer"}, {"sha": "751806e84722f47188f03932374f215c9c70cfef", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -67,6 +67,8 @@ struct DataInfo {\n uptr SymbolizeCode(uptr address, AddressInfo *frames, uptr max_frames);\n bool SymbolizeData(uptr address, DataInfo *info);\n \n+bool IsSymbolizerAvailable();\n+\n // Attempts to demangle the provided C++ mangled name.\n const char *Demangle(const char *Name);\n "}, {"sha": "3d5cde11cf816aae5da9faa71114c06836ff5e75", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -95,6 +95,11 @@ void *Mprotect(uptr fixed_addr, uptr size) {\n                       MEM_RESERVE | MEM_COMMIT, PAGE_NOACCESS);\n }\n \n+void FlushUnneededShadowMemory(uptr addr, uptr size) {\n+  // This is almost useless on 32-bits.\n+  // FIXME: add madvice-analog when we move to 64-bits.\n+}\n+\n bool MemoryRangeIsAvailable(uptr range_start, uptr range_end) {\n   // FIXME: shall we do anything here on Windows?\n   return true;\n@@ -189,7 +194,15 @@ int internal_isatty(fd_t fd) {\n   return _isatty(fd);\n }\n \n-fd_t internal_open(const char *filename, bool write) {\n+fd_t internal_open(const char *filename, int flags) {\n+  UNIMPLEMENTED();\n+}\n+\n+fd_t internal_open(const char *filename, int flags, u32 mode) {\n+  UNIMPLEMENTED();\n+}\n+\n+fd_t OpenFile(const char *filename, bool write) {\n   UNIMPLEMENTED();\n }\n \n@@ -209,6 +222,18 @@ uptr internal_write(fd_t fd, const void *buf, uptr count) {\n   return ret;\n }\n \n+int internal_stat(const char *path, void *buf) {\n+  UNIMPLEMENTED();\n+}\n+\n+int internal_lstat(const char *path, void *buf) {\n+  UNIMPLEMENTED();\n+}\n+\n+int internal_fstat(fd_t fd, void *buf) {\n+  UNIMPLEMENTED();\n+}\n+\n uptr internal_filesize(fd_t fd) {\n   UNIMPLEMENTED();\n }\n@@ -227,10 +252,8 @@ int internal_sched_yield() {\n }\n \n // ---------------------- BlockingMutex ---------------- {{{1\n-enum LockState {\n-  LOCK_UNINITIALIZED = 0,\n-  LOCK_READY = -1,\n-};\n+const uptr LOCK_UNINITIALIZED = 0;\n+const uptr LOCK_READY = (uptr)-1;\n \n BlockingMutex::BlockingMutex(LinkerInitialized li) {\n   // FIXME: see comments in BlockingMutex::Lock() for the details.\n@@ -252,12 +275,12 @@ void BlockingMutex::Lock() {\n     // locks while we're starting in one thread to avoid double-init races.\n   }\n   EnterCriticalSection((LPCRITICAL_SECTION)opaque_storage_);\n-  CHECK(owner_ == LOCK_READY);\n+  CHECK_EQ(owner_, LOCK_READY);\n   owner_ = GetThreadSelf();\n }\n \n void BlockingMutex::Unlock() {\n-  CHECK(owner_ == GetThreadSelf());\n+  CHECK_EQ(owner_, GetThreadSelf());\n   owner_ = LOCK_READY;\n   LeaveCriticalSection((LPCRITICAL_SECTION)opaque_storage_);\n }"}, {"sha": "b2937a428f3d27a24722fd746e8b553e2ec034c6", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -26,16 +26,19 @@ namespace __tsan {\n const bool kGoMode = true;\n const bool kCppMode = false;\n const char *const kTsanOptionsEnv = \"GORACE\";\n+// Go linker does not support weak symbols.\n+#define CPP_WEAK\n #else\n const bool kGoMode = false;\n const bool kCppMode = true;\n const char *const kTsanOptionsEnv = \"TSAN_OPTIONS\";\n+#define CPP_WEAK WEAK\n #endif\n \n const int kTidBits = 13;\n const unsigned kMaxTid = 1 << kTidBits;\n const unsigned kMaxTidInClock = kMaxTid * 2;  // This includes msb 'freed' bit.\n-const int kClkBits = 43;\n+const int kClkBits = 42;\n #ifndef TSAN_GO\n const int kShadowStackSize = 4 * 1024;\n const int kTraceStackSize = 256;"}, {"sha": "a75d9bde08ade9801b12cf80426a02aebe23d8cc", "filename": "libsanitizer/tsan/tsan_fd.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -148,7 +148,7 @@ void FdAcquire(ThreadState *thr, uptr pc, int fd) {\n   FdDesc *d = fddesc(thr, pc, fd);\n   FdSync *s = d->sync;\n   DPrintf(\"#%d: FdAcquire(%d) -> %p\\n\", thr->tid, fd, s);\n-  MemoryRead8Byte(thr, pc, (uptr)d);\n+  MemoryRead(thr, pc, (uptr)d, kSizeLog8);\n   if (s)\n     Acquire(thr, pc, (uptr)s);\n }\n@@ -159,20 +159,20 @@ void FdRelease(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdRelease(%d) -> %p\\n\", thr->tid, fd, s);\n   if (s)\n     Release(thr, pc, (uptr)s);\n-  MemoryRead8Byte(thr, pc, (uptr)d);\n+  MemoryRead(thr, pc, (uptr)d, kSizeLog8);\n }\n \n void FdAccess(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdAccess(%d)\\n\", thr->tid, fd);\n   FdDesc *d = fddesc(thr, pc, fd);\n-  MemoryRead8Byte(thr, pc, (uptr)d);\n+  MemoryRead(thr, pc, (uptr)d, kSizeLog8);\n }\n \n void FdClose(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdClose(%d)\\n\", thr->tid, fd);\n   FdDesc *d = fddesc(thr, pc, fd);\n   // To catch races between fd usage and close.\n-  MemoryWrite8Byte(thr, pc, (uptr)d);\n+  MemoryWrite(thr, pc, (uptr)d, kSizeLog8);\n   // We need to clear it, because if we do not intercept any call out there\n   // that creates fd, we will hit false postives.\n   MemoryResetRange(thr, pc, (uptr)d, 8);\n@@ -191,7 +191,7 @@ void FdDup(ThreadState *thr, uptr pc, int oldfd, int newfd) {\n   DPrintf(\"#%d: FdDup(%d, %d)\\n\", thr->tid, oldfd, newfd);\n   // Ignore the case when user dups not yet connected socket.\n   FdDesc *od = fddesc(thr, pc, oldfd);\n-  MemoryRead8Byte(thr, pc, (uptr)od);\n+  MemoryRead(thr, pc, (uptr)od, kSizeLog8);\n   FdClose(thr, pc, newfd);\n   init(thr, pc, newfd, ref(od->sync));\n }"}, {"sha": "ae748a13e150d5dd69a2eb73b6661142974331f5", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -43,6 +43,7 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->report_thread_leaks = true;\n   f->report_destroy_locked = true;\n   f->report_signal_unsafe = true;\n+  f->report_atomic_races = true;\n   f->force_seq_cst_atomics = false;\n   f->strip_path_prefix = \"\";\n   f->suppressions = \"\";\n@@ -70,6 +71,7 @@ void InitializeFlags(Flags *f, const char *env) {\n   ParseFlag(env, &f->report_thread_leaks, \"report_thread_leaks\");\n   ParseFlag(env, &f->report_destroy_locked, \"report_destroy_locked\");\n   ParseFlag(env, &f->report_signal_unsafe, \"report_signal_unsafe\");\n+  ParseFlag(env, &f->report_atomic_races, \"report_atomic_races\");\n   ParseFlag(env, &f->force_seq_cst_atomics, \"force_seq_cst_atomics\");\n   ParseFlag(env, &f->strip_path_prefix, \"strip_path_prefix\");\n   ParseFlag(env, &f->suppressions, \"suppressions\");"}, {"sha": "480b41538f941ef57bf706bcb6af4ff4dc610539", "filename": "libsanitizer/tsan/tsan_flags.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -41,6 +41,8 @@ struct Flags {\n   // Report violations of async signal-safety\n   // (e.g. malloc() call from a signal handler).\n   bool report_signal_unsafe;\n+  // Report races between atomic and plain memory accesses.\n+  bool report_atomic_races;\n   // If set, all atomics are effectively sequentially consistent (seq_cst),\n   // regardless of what user actually specified.\n   bool force_seq_cst_atomics;\n@@ -84,6 +86,6 @@ struct Flags {\n \n Flags *flags();\n void InitializeFlags(Flags *flags, const char *env);\n-}\n+}  // namespace __tsan\n \n #endif  // TSAN_FLAGS_H"}, {"sha": "8a54511b6e076583a246ade590818210acec6720", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 176, "deletions": 14, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -51,9 +51,12 @@ extern \"C\" int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);\n extern \"C\" int sigfillset(sigset_t *set);\n extern \"C\" void *pthread_self();\n extern \"C\" void _exit(int status);\n-extern \"C\" int __cxa_atexit(void (*func)(void *arg), void *arg, void *dso);\n extern \"C\" int *__errno_location();\n extern \"C\" int fileno_unlocked(void *stream);\n+extern \"C\" void *__libc_malloc(uptr size);\n+extern \"C\" void *__libc_calloc(uptr size, uptr n);\n+extern \"C\" void *__libc_realloc(void *ptr, uptr size);\n+extern \"C\" void __libc_free(void *ptr);\n const int PTHREAD_MUTEX_RECURSIVE = 1;\n const int PTHREAD_MUTEX_RECURSIVE_NP = 1;\n const int kPthreadAttrSize = 56;\n@@ -122,7 +125,7 @@ struct SignalContext {\n   int pending_signal_count;\n   SignalDesc pending_signals[kSigCount];\n };\n-}\n+}  // namespace __tsan\n \n static SignalContext *SigCtx(ThreadState *thr) {\n   SignalContext *ctx = (SignalContext*)thr->signal_ctx;\n@@ -238,12 +241,15 @@ class AtExitContext {\n \n   typedef void(*atexit_t)();\n \n-  int atexit(ThreadState *thr, uptr pc, atexit_t f) {\n+  int atexit(ThreadState *thr, uptr pc, bool is_on_exit,\n+             atexit_t f, void *arg) {\n     Lock l(&mtx_);\n     if (pos_ == kMaxAtExit)\n       return 1;\n     Release(thr, pc, (uptr)this);\n     stack_[pos_] = f;\n+    args_[pos_] = arg;\n+    is_on_exits_[pos_] = is_on_exit;\n     pos_++;\n     return 0;\n   }\n@@ -252,11 +258,15 @@ class AtExitContext {\n     CHECK_EQ(thr->in_rtl, 0);\n     for (;;) {\n       atexit_t f = 0;\n+      void *arg = 0;\n+      bool is_on_exit = false;\n       {\n         Lock l(&mtx_);\n         if (pos_) {\n           pos_--;\n           f = stack_[pos_];\n+          arg = args_[pos_];\n+          is_on_exit = is_on_exits_[pos_];\n           ScopedInRtl in_rtl;\n           Acquire(thr, pc, (uptr)this);\n         }\n@@ -265,14 +275,19 @@ class AtExitContext {\n         break;\n       DPrintf(\"#%d: executing atexit func %p\\n\", thr->tid, f);\n       CHECK_EQ(thr->in_rtl, 0);\n-      f();\n+      if (is_on_exit)\n+        ((void(*)(int status, void *arg))f)(0, arg);\n+      else\n+        ((void(*)(void *arg, void *dso))f)(arg, 0);\n     }\n   }\n \n  private:\n   static const int kMaxAtExit = 128;\n   Mutex mtx_;\n   atexit_t stack_[kMaxAtExit];\n+  void *args_[kMaxAtExit];\n+  bool is_on_exits_[kMaxAtExit];\n   int pos_;\n };\n \n@@ -282,18 +297,32 @@ static void finalize(void *arg) {\n   ThreadState * thr = cur_thread();\n   uptr pc = 0;\n   atexit_ctx->exit(thr, pc);\n-  {\n-    ScopedInRtl in_rtl;\n-    DestroyAndFree(atexit_ctx);\n-  }\n   int status = Finalize(cur_thread());\n   if (status)\n     _exit(status);\n }\n \n TSAN_INTERCEPTOR(int, atexit, void (*f)()) {\n+  if (cur_thread()->in_symbolizer)\n+    return 0;\n   SCOPED_TSAN_INTERCEPTOR(atexit, f);\n-  return atexit_ctx->atexit(thr, pc, f);\n+  return atexit_ctx->atexit(thr, pc, false, (void(*)())f, 0);\n+}\n+\n+TSAN_INTERCEPTOR(int, on_exit, void(*f)(int, void*), void *arg) {\n+  if (cur_thread()->in_symbolizer)\n+    return 0;\n+  SCOPED_TSAN_INTERCEPTOR(on_exit, f, arg);\n+  return atexit_ctx->atexit(thr, pc, true, (void(*)())f, arg);\n+}\n+\n+TSAN_INTERCEPTOR(int, __cxa_atexit, void (*f)(void *a), void *arg, void *dso) {\n+  if (cur_thread()->in_symbolizer)\n+    return 0;\n+  SCOPED_TSAN_INTERCEPTOR(__cxa_atexit, f, arg, dso);\n+  if (dso)\n+    return REAL(__cxa_atexit)(f, arg, dso);\n+  return atexit_ctx->atexit(thr, pc, false, (void(*)())f, arg);\n }\n \n TSAN_INTERCEPTOR(void, longjmp, void *env, int val) {\n@@ -309,6 +338,8 @@ TSAN_INTERCEPTOR(void, siglongjmp, void *env, int val) {\n }\n \n TSAN_INTERCEPTOR(void*, malloc, uptr size) {\n+  if (cur_thread()->in_symbolizer)\n+    return __libc_malloc(size);\n   void *p = 0;\n   {\n     SCOPED_INTERCEPTOR_RAW(malloc, size);\n@@ -324,6 +355,9 @@ TSAN_INTERCEPTOR(void*, __libc_memalign, uptr align, uptr sz) {\n }\n \n TSAN_INTERCEPTOR(void*, calloc, uptr size, uptr n) {\n+  if (cur_thread()->in_symbolizer)\n+    return __libc_calloc(size, n);\n+  if (__sanitizer::CallocShouldReturnNullDueToOverflow(size, n)) return 0;\n   void *p = 0;\n   {\n     SCOPED_INTERCEPTOR_RAW(calloc, size, n);\n@@ -335,6 +369,8 @@ TSAN_INTERCEPTOR(void*, calloc, uptr size, uptr n) {\n }\n \n TSAN_INTERCEPTOR(void*, realloc, void *p, uptr size) {\n+  if (cur_thread()->in_symbolizer)\n+    return __libc_realloc(p, size);\n   if (p)\n     invoke_free_hook(p);\n   {\n@@ -348,6 +384,8 @@ TSAN_INTERCEPTOR(void*, realloc, void *p, uptr size) {\n TSAN_INTERCEPTOR(void, free, void *p) {\n   if (p == 0)\n     return;\n+  if (cur_thread()->in_symbolizer)\n+    return __libc_free(p);\n   invoke_free_hook(p);\n   SCOPED_INTERCEPTOR_RAW(free, p);\n   user_free(thr, pc, p);\n@@ -356,12 +394,16 @@ TSAN_INTERCEPTOR(void, free, void *p) {\n TSAN_INTERCEPTOR(void, cfree, void *p) {\n   if (p == 0)\n     return;\n+  if (cur_thread()->in_symbolizer)\n+    return __libc_free(p);\n   invoke_free_hook(p);\n   SCOPED_INTERCEPTOR_RAW(cfree, p);\n   user_free(thr, pc, p);\n }\n \n #define OPERATOR_NEW_BODY(mangled_name) \\\n+  if (cur_thread()->in_symbolizer) \\\n+    return __libc_malloc(size); \\\n   void *p = 0; \\\n   {  \\\n     SCOPED_INTERCEPTOR_RAW(mangled_name, size); \\\n@@ -385,6 +427,8 @@ void *operator new[](__sanitizer::uptr size, std::nothrow_t const&) {\n \n #define OPERATOR_DELETE_BODY(mangled_name) \\\n   if (ptr == 0) return;  \\\n+  if (cur_thread()->in_symbolizer) \\\n+    return __libc_free(ptr); \\\n   invoke_free_hook(ptr);  \\\n   SCOPED_INTERCEPTOR_RAW(mangled_name, ptr);  \\\n   user_free(thr, pc, ptr);\n@@ -549,6 +593,8 @@ TSAN_INTERCEPTOR(void*, mmap, void *addr, long_t sz, int prot,\n     return MAP_FAILED;\n   void *res = REAL(mmap)(addr, sz, prot, flags, fd, off);\n   if (res != MAP_FAILED) {\n+    if (fd > 0)\n+      FdAccess(thr, pc, fd);\n     MemoryResetRange(thr, pc, (uptr)res, sz);\n   }\n   return res;\n@@ -561,6 +607,8 @@ TSAN_INTERCEPTOR(void*, mmap64, void *addr, long_t sz, int prot,\n     return MAP_FAILED;\n   void *res = REAL(mmap64)(addr, sz, prot, flags, fd, off);\n   if (res != MAP_FAILED) {\n+    if (fd > 0)\n+      FdAccess(thr, pc, fd);\n     MemoryResetRange(thr, pc, (uptr)res, sz);\n   }\n   return res;\n@@ -958,24 +1006,24 @@ TSAN_INTERCEPTOR(int, pthread_cond_timedwait, void *c, void *m, void *abstime) {\n \n TSAN_INTERCEPTOR(int, pthread_barrier_init, void *b, void *a, unsigned count) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_barrier_init, b, a, count);\n-  MemoryWrite1Byte(thr, pc, (uptr)b);\n+  MemoryWrite(thr, pc, (uptr)b, kSizeLog1);\n   int res = REAL(pthread_barrier_init)(b, a, count);\n   return res;\n }\n \n TSAN_INTERCEPTOR(int, pthread_barrier_destroy, void *b) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_barrier_destroy, b);\n-  MemoryWrite1Byte(thr, pc, (uptr)b);\n+  MemoryWrite(thr, pc, (uptr)b, kSizeLog1);\n   int res = REAL(pthread_barrier_destroy)(b);\n   return res;\n }\n \n TSAN_INTERCEPTOR(int, pthread_barrier_wait, void *b) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_barrier_wait, b);\n   Release(thr, pc, (uptr)b);\n-  MemoryRead1Byte(thr, pc, (uptr)b);\n+  MemoryRead(thr, pc, (uptr)b, kSizeLog1);\n   int res = REAL(pthread_barrier_wait)(b);\n-  MemoryRead1Byte(thr, pc, (uptr)b);\n+  MemoryRead(thr, pc, (uptr)b, kSizeLog1);\n   if (res == 0 || res == PTHREAD_BARRIER_SERIAL_THREAD) {\n     Acquire(thr, pc, (uptr)b);\n   }\n@@ -1062,6 +1110,74 @@ TSAN_INTERCEPTOR(int, sem_getvalue, void *s, int *sval) {\n   return res;\n }\n \n+TSAN_INTERCEPTOR(int, __xstat, int version, const char *path, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__xstat, version, path, buf);\n+  return REAL(__xstat)(version, path, buf);\n+}\n+\n+TSAN_INTERCEPTOR(int, stat, const char *path, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__xstat, 0, path, buf);\n+  return REAL(__xstat)(0, path, buf);\n+}\n+\n+TSAN_INTERCEPTOR(int, __xstat64, int version, const char *path, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__xstat64, version, path, buf);\n+  return REAL(__xstat64)(version, path, buf);\n+}\n+\n+TSAN_INTERCEPTOR(int, stat64, const char *path, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__xstat64, 0, path, buf);\n+  return REAL(__xstat64)(0, path, buf);\n+}\n+\n+TSAN_INTERCEPTOR(int, __lxstat, int version, const char *path, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__lxstat, version, path, buf);\n+  return REAL(__lxstat)(version, path, buf);\n+}\n+\n+TSAN_INTERCEPTOR(int, lstat, const char *path, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__lxstat, 0, path, buf);\n+  return REAL(__lxstat)(0, path, buf);\n+}\n+\n+TSAN_INTERCEPTOR(int, __lxstat64, int version, const char *path, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__lxstat64, version, path, buf);\n+  return REAL(__lxstat64)(version, path, buf);\n+}\n+\n+TSAN_INTERCEPTOR(int, lstat64, const char *path, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__lxstat64, 0, path, buf);\n+  return REAL(__lxstat64)(0, path, buf);\n+}\n+\n+TSAN_INTERCEPTOR(int, __fxstat, int version, int fd, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__fxstat, version, fd, buf);\n+  if (fd > 0)\n+    FdAccess(thr, pc, fd);\n+  return REAL(__fxstat)(version, fd, buf);\n+}\n+\n+TSAN_INTERCEPTOR(int, fstat, int fd, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__fxstat, 0, fd, buf);\n+  if (fd > 0)\n+    FdAccess(thr, pc, fd);\n+  return REAL(__fxstat)(0, fd, buf);\n+}\n+\n+TSAN_INTERCEPTOR(int, __fxstat64, int version, int fd, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__fxstat64, version, fd, buf);\n+  if (fd > 0)\n+    FdAccess(thr, pc, fd);\n+  return REAL(__fxstat64)(version, fd, buf);\n+}\n+\n+TSAN_INTERCEPTOR(int, fstat64, int fd, void *buf) {\n+  SCOPED_TSAN_INTERCEPTOR(__fxstat64, 0, fd, buf);\n+  if (fd > 0)\n+    FdAccess(thr, pc, fd);\n+  return REAL(__fxstat64)(0, fd, buf);\n+}\n+\n TSAN_INTERCEPTOR(int, open, const char *name, int flags, int mode) {\n   SCOPED_TSAN_INTERCEPTOR(open, name, flags, mode);\n   int fd = REAL(open)(name, flags, mode);\n@@ -1177,6 +1293,22 @@ TSAN_INTERCEPTOR(int, connect, int fd, void *addr, unsigned addrlen) {\n   return res;\n }\n \n+TSAN_INTERCEPTOR(int, bind, int fd, void *addr, unsigned addrlen) {\n+  SCOPED_TSAN_INTERCEPTOR(bind, fd, addr, addrlen);\n+  int res = REAL(bind)(fd, addr, addrlen);\n+  if (fd > 0 && res == 0)\n+    FdAccess(thr, pc, fd);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, listen, int fd, int backlog) {\n+  SCOPED_TSAN_INTERCEPTOR(listen, fd, backlog);\n+  int res = REAL(listen)(fd, backlog);\n+  if (fd > 0 && res == 0)\n+    FdAccess(thr, pc, fd);\n+  return res;\n+}\n+\n TSAN_INTERCEPTOR(int, accept, int fd, void *addr, unsigned *addrlen) {\n   SCOPED_TSAN_INTERCEPTOR(accept, fd, addr, addrlen);\n   int fd2 = REAL(accept)(fd, addr, addrlen);\n@@ -1223,6 +1355,18 @@ TSAN_INTERCEPTOR(int, __close, int fd) {\n   return REAL(__close)(fd);\n }\n \n+// glibc guts\n+TSAN_INTERCEPTOR(void, __res_iclose, void *state, bool free_addr) {\n+  SCOPED_TSAN_INTERCEPTOR(__res_iclose, state, free_addr);\n+  int fds[64];\n+  int cnt = ExtractResolvFDs(state, fds, ARRAY_SIZE(fds));\n+  for (int i = 0; i < cnt; i++) {\n+    if (fds[i] > 0)\n+      FdClose(thr, pc, fds[i]);\n+  }\n+  REAL(__res_iclose)(state, free_addr);\n+}\n+\n TSAN_INTERCEPTOR(int, pipe, int *pipefd) {\n   SCOPED_TSAN_INTERCEPTOR(pipe, pipefd);\n   int res = REAL(pipe)(pipefd);\n@@ -1765,6 +1909,18 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(sem_post);\n   TSAN_INTERCEPT(sem_getvalue);\n \n+  TSAN_INTERCEPT(stat);\n+  TSAN_INTERCEPT(__xstat);\n+  TSAN_INTERCEPT(stat64);\n+  TSAN_INTERCEPT(__xstat64);\n+  TSAN_INTERCEPT(lstat);\n+  TSAN_INTERCEPT(__lxstat);\n+  TSAN_INTERCEPT(lstat64);\n+  TSAN_INTERCEPT(__lxstat64);\n+  TSAN_INTERCEPT(fstat);\n+  TSAN_INTERCEPT(__fxstat);\n+  TSAN_INTERCEPT(fstat64);\n+  TSAN_INTERCEPT(__fxstat64);\n   TSAN_INTERCEPT(open);\n   TSAN_INTERCEPT(open64);\n   TSAN_INTERCEPT(creat);\n@@ -1779,11 +1935,15 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(socket);\n   TSAN_INTERCEPT(socketpair);\n   TSAN_INTERCEPT(connect);\n+  TSAN_INTERCEPT(bind);\n+  TSAN_INTERCEPT(listen);\n   TSAN_INTERCEPT(accept);\n   TSAN_INTERCEPT(accept4);\n   TSAN_INTERCEPT(epoll_create);\n   TSAN_INTERCEPT(epoll_create1);\n   TSAN_INTERCEPT(close);\n+  TSAN_INTERCEPT(__close);\n+  TSAN_INTERCEPT(__res_iclose);\n   TSAN_INTERCEPT(pipe);\n   TSAN_INTERCEPT(pipe2);\n \n@@ -1826,14 +1986,16 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(munlockall);\n \n   TSAN_INTERCEPT(fork);\n+  TSAN_INTERCEPT(on_exit);\n+  TSAN_INTERCEPT(__cxa_atexit);\n \n   // Need to setup it, because interceptors check that the function is resolved.\n   // But atexit is emitted directly into the module, so can't be resolved.\n   REAL(atexit) = (int(*)(void(*)()))unreachable;\n   atexit_ctx = new(internal_alloc(MBlockAtExit, sizeof(AtExitContext)))\n       AtExitContext();\n \n-  if (__cxa_atexit(&finalize, 0, 0)) {\n+  if (REAL(__cxa_atexit)(&finalize, 0, 0)) {\n     Printf(\"ThreadSanitizer: failed to setup atexit callback\\n\");\n     Die();\n   }"}, {"sha": "992e3834aae56c4338a74c01e0882b8acdea251e", "filename": "libsanitizer/tsan/tsan_interface.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -22,13 +22,13 @@ void __tsan_init() {\n }\n \n void __tsan_read16(void *addr) {\n-  MemoryRead8Byte(cur_thread(), CALLERPC, (uptr)addr);\n-  MemoryRead8Byte(cur_thread(), CALLERPC, (uptr)addr + 8);\n+  MemoryRead(cur_thread(), CALLERPC, (uptr)addr, kSizeLog8);\n+  MemoryRead(cur_thread(), CALLERPC, (uptr)addr + 8, kSizeLog8);\n }\n \n void __tsan_write16(void *addr) {\n-  MemoryWrite8Byte(cur_thread(), CALLERPC, (uptr)addr);\n-  MemoryWrite8Byte(cur_thread(), CALLERPC, (uptr)addr + 8);\n+  MemoryWrite(cur_thread(), CALLERPC, (uptr)addr, kSizeLog8);\n+  MemoryWrite(cur_thread(), CALLERPC, (uptr)addr + 8, kSizeLog8);\n }\n \n void __tsan_acquire(void *addr) {"}, {"sha": "2cfd7684183286f57a81d2a09c5140638121377c", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -14,7 +14,7 @@\n #ifndef TSAN_INTERFACE_H\n #define TSAN_INTERFACE_H\n \n-#include <sanitizer/common_interface_defs.h>\n+#include <sanitizer_common/sanitizer_internal_defs.h>\n \n // This header should NOT include any other headers.\n // All functions in this header are extern \"C\" and start with __tsan_."}, {"sha": "b65003294285d1c4a992602acd07f8948c1c4f8e", "filename": "libsanitizer/tsan/tsan_interface_ann.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface_ann.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface_ann.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -12,7 +12,7 @@\n #ifndef TSAN_INTERFACE_ANN_H\n #define TSAN_INTERFACE_ANN_H\n \n-#include <sanitizer/common_interface_defs.h>\n+#include <sanitizer_common/sanitizer_internal_defs.h>\n \n // This header should NOT include any other headers.\n // All functions in this header are extern \"C\" and start with __tsan_."}, {"sha": "2c8b2ab049c0f50cca37205fbedaf418ba621723", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -18,25 +18,42 @@\n // http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/\n \n #include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"tsan_interface_atomic.h\"\n #include \"tsan_flags.h\"\n #include \"tsan_rtl.h\"\n \n using namespace __tsan;  // NOLINT\n \n+#define SCOPED_ATOMIC(func, ...) \\\n+    const uptr callpc = (uptr)__builtin_return_address(0); \\\n+    uptr pc = __sanitizer::StackTrace::GetCurrentPc(); \\\n+    pc = __sanitizer::StackTrace::GetPreviousInstructionPc(pc); \\\n+    mo = ConvertOrder(mo); \\\n+    mo = flags()->force_seq_cst_atomics ? (morder)mo_seq_cst : mo; \\\n+    ThreadState *const thr = cur_thread(); \\\n+    AtomicStatInc(thr, sizeof(*a), mo, StatAtomic##func); \\\n+    ScopedAtomic sa(thr, callpc, __FUNCTION__); \\\n+    return Atomic##func(thr, pc, __VA_ARGS__); \\\n+/**/\n+\n class ScopedAtomic {\n  public:\n   ScopedAtomic(ThreadState *thr, uptr pc, const char *func)\n       : thr_(thr) {\n-    CHECK_EQ(thr_->in_rtl, 1);  // 1 due to our own ScopedInRtl member.\n+    CHECK_EQ(thr_->in_rtl, 0);\n+    ProcessPendingSignals(thr);\n+    FuncEntry(thr_, pc);\n     DPrintf(\"#%d: %s\\n\", thr_->tid, func);\n+    thr_->in_rtl++;\n   }\n   ~ScopedAtomic() {\n-    CHECK_EQ(thr_->in_rtl, 1);\n+    thr_->in_rtl--;\n+    CHECK_EQ(thr_->in_rtl, 0);\n+    FuncExit(thr_);\n   }\n  private:\n   ThreadState *thr_;\n-  ScopedInRtl in_rtl_;\n };\n \n // Some shortcuts.\n@@ -210,38 +227,45 @@ a128 func_cas(volatile a128 *v, a128 cmp, a128 xch) {\n }\n #endif\n \n-#define SCOPED_ATOMIC(func, ...) \\\n-    mo = ConvertOrder(mo); \\\n-    mo = flags()->force_seq_cst_atomics ? (morder)mo_seq_cst : mo; \\\n-    ThreadState *const thr = cur_thread(); \\\n-    ProcessPendingSignals(thr); \\\n-    const uptr pc = (uptr)__builtin_return_address(0); \\\n-    AtomicStatInc(thr, sizeof(*a), mo, StatAtomic##func); \\\n-    ScopedAtomic sa(thr, pc, __FUNCTION__); \\\n-    return Atomic##func(thr, pc, __VA_ARGS__); \\\n-/**/\n+template<typename T>\n+static int SizeLog() {\n+  if (sizeof(T) <= 1)\n+    return kSizeLog1;\n+  else if (sizeof(T) <= 2)\n+    return kSizeLog2;\n+  else if (sizeof(T) <= 4)\n+    return kSizeLog4;\n+  else\n+    return kSizeLog8;\n+  // For 16-byte atomics we also use 8-byte memory access,\n+  // this leads to false negatives only in very obscure cases.\n+}\n \n template<typename T>\n static T AtomicLoad(ThreadState *thr, uptr pc, const volatile T *a,\n     morder mo) {\n   CHECK(IsLoadOrder(mo));\n   // This fast-path is critical for performance.\n   // Assume the access is atomic.\n-  if (!IsAcquireOrder(mo) && sizeof(T) <= sizeof(a))\n+  if (!IsAcquireOrder(mo) && sizeof(T) <= sizeof(a)) {\n+    MemoryReadAtomic(thr, pc, (uptr)a, SizeLog<T>());\n     return *a;\n+  }\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, (uptr)a, false);\n   thr->clock.set(thr->tid, thr->fast_state.epoch());\n   thr->clock.acquire(&s->clock);\n   T v = *a;\n   s->mtx.ReadUnlock();\n   __sync_synchronize();\n+  MemoryReadAtomic(thr, pc, (uptr)a, SizeLog<T>());\n   return v;\n }\n \n template<typename T>\n static void AtomicStore(ThreadState *thr, uptr pc, volatile T *a, T v,\n     morder mo) {\n   CHECK(IsStoreOrder(mo));\n+  MemoryWriteAtomic(thr, pc, (uptr)a, SizeLog<T>());\n   // This fast-path is critical for performance.\n   // Assume the access is atomic.\n   // Strictly saying even relaxed store cuts off release sequence,\n@@ -263,6 +287,7 @@ static void AtomicStore(ThreadState *thr, uptr pc, volatile T *a, T v,\n \n template<typename T, T (*F)(volatile T *v, T op)>\n static T AtomicRMW(ThreadState *thr, uptr pc, volatile T *a, T v, morder mo) {\n+  MemoryWriteAtomic(thr, pc, (uptr)a, SizeLog<T>());\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, (uptr)a, true);\n   thr->clock.set(thr->tid, thr->fast_state.epoch());\n   if (IsAcqRelOrder(mo))\n@@ -322,6 +347,7 @@ template<typename T>\n static bool AtomicCAS(ThreadState *thr, uptr pc,\n     volatile T *a, T *c, T v, morder mo, morder fmo) {\n   (void)fmo;  // Unused because llvm does not pass it yet.\n+  MemoryWriteAtomic(thr, pc, (uptr)a, SizeLog<T>());\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, (uptr)a, true);\n   thr->clock.set(thr->tid, thr->fast_state.epoch());\n   if (IsAcqRelOrder(mo))"}, {"sha": "92796d1178fe8102cf583f248df7406f33600423", "filename": "libsanitizer/tsan/tsan_interface_inl.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_inl.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -17,41 +17,41 @@\n using namespace __tsan;  // NOLINT\n \n void __tsan_read1(void *addr) {\n-  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 0, 0);\n+  MemoryRead(cur_thread(), CALLERPC, (uptr)addr, kSizeLog1);\n }\n \n void __tsan_read2(void *addr) {\n-  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 1, 0);\n+  MemoryRead(cur_thread(), CALLERPC, (uptr)addr, kSizeLog2);\n }\n \n void __tsan_read4(void *addr) {\n-  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 2, 0);\n+  MemoryRead(cur_thread(), CALLERPC, (uptr)addr, kSizeLog4);\n }\n \n void __tsan_read8(void *addr) {\n-  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 3, 0);\n+  MemoryRead(cur_thread(), CALLERPC, (uptr)addr, kSizeLog8);\n }\n \n void __tsan_write1(void *addr) {\n-  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 0, 1);\n+  MemoryWrite(cur_thread(), CALLERPC, (uptr)addr, kSizeLog1);\n }\n \n void __tsan_write2(void *addr) {\n-  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 1, 1);\n+  MemoryWrite(cur_thread(), CALLERPC, (uptr)addr, kSizeLog2);\n }\n \n void __tsan_write4(void *addr) {\n-  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 2, 1);\n+  MemoryWrite(cur_thread(), CALLERPC, (uptr)addr, kSizeLog4);\n }\n \n void __tsan_write8(void *addr) {\n-  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 3, 1);\n+  MemoryWrite(cur_thread(), CALLERPC, (uptr)addr, kSizeLog8);\n }\n \n void __tsan_vptr_update(void **vptr_p, void *new_val) {\n   CHECK_EQ(sizeof(vptr_p), 8);\n   if (*vptr_p != new_val)\n-    MemoryAccess(cur_thread(), CALLERPC, (uptr)vptr_p, 3, 1);\n+    MemoryWrite(cur_thread(), CALLERPC, (uptr)vptr_p, kSizeLog8);\n }\n \n void __tsan_func_entry(void *pc) {"}, {"sha": "f8c0b4eb635cd3722730f1771218e1ea2f181883", "filename": "libsanitizer/tsan/tsan_interface_java.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -150,7 +150,7 @@ SyncVar* GetAndRemoveJavaSync(ThreadState *thr, uptr pc, uptr addr) {\n   return 0;\n }\n \n-}  // namespace __tsan {\n+}  // namespace __tsan\n \n #define SCOPED_JAVA_FUNC(func) \\\n   ThreadState *thr = cur_thread(); \\"}, {"sha": "883239c2e7141b8e611a506eb45ec9dd38f5a38f", "filename": "libsanitizer/tsan/tsan_md5.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_md5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_md5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_md5.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -240,4 +240,4 @@ MD5Hash md5_hash(const void *data, uptr size) {\n   MD5_Final((unsigned char*)&res.hash[0], &ctx);\n   return res;\n }\n-}\n+}  // namespace __tsan"}, {"sha": "23c73c50cc10b07034cf192e5161173f9fb429b5", "filename": "libsanitizer/tsan/tsan_mman.cc", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_mman.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_mman.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -36,8 +36,16 @@ void InitializeAllocator() {\n   allocator()->Init();\n }\n \n-void AlloctorThreadFinish(ThreadState *thr) {\n-  allocator()->SwallowCache(&thr->alloc_cache);\n+void AllocatorThreadStart(ThreadState *thr) {\n+  allocator()->InitCache(&thr->alloc_cache);\n+}\n+\n+void AllocatorThreadFinish(ThreadState *thr) {\n+  allocator()->DestroyCache(&thr->alloc_cache);\n+}\n+\n+void AllocatorPrintStats() {\n+  allocator()->PrintStats();\n }\n \n static void SignalUnsafeCall(ThreadState *thr, uptr pc) {\n@@ -162,3 +170,49 @@ void internal_free(void *p) {\n }\n \n }  // namespace __tsan\n+\n+using namespace __tsan;\n+\n+extern \"C\" {\n+uptr __tsan_get_current_allocated_bytes() {\n+  u64 stats[AllocatorStatCount];\n+  allocator()->GetStats(stats);\n+  u64 m = stats[AllocatorStatMalloced];\n+  u64 f = stats[AllocatorStatFreed];\n+  return m >= f ? m - f : 1;\n+}\n+\n+uptr __tsan_get_heap_size() {\n+  u64 stats[AllocatorStatCount];\n+  allocator()->GetStats(stats);\n+  u64 m = stats[AllocatorStatMmapped];\n+  u64 f = stats[AllocatorStatUnmapped];\n+  return m >= f ? m - f : 1;\n+}\n+\n+uptr __tsan_get_free_bytes() {\n+  return 1;\n+}\n+\n+uptr __tsan_get_unmapped_bytes() {\n+  return 1;\n+}\n+\n+uptr __tsan_get_estimated_allocated_size(uptr size) {\n+  return size;\n+}\n+\n+bool __tsan_get_ownership(void *p) {\n+  return allocator()->GetBlockBegin(p) != 0;\n+}\n+\n+uptr __tsan_get_allocated_size(void *p) {\n+  if (p == 0)\n+    return 0;\n+  p = allocator()->GetBlockBegin(p);\n+  if (p == 0)\n+    return 0;\n+  MBlock *b = (MBlock*)allocator()->GetMetaData(p);\n+  return b->size;\n+}\n+}  // extern \"C\""}, {"sha": "7a657e124bf8e3355540752f96ea9d8cb416d7a6", "filename": "libsanitizer/tsan/tsan_mman.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_mman.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_mman.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -18,7 +18,9 @@ namespace __tsan {\n const uptr kDefaultAlignment = 16;\n \n void InitializeAllocator();\n-void AlloctorThreadFinish(ThreadState *thr);\n+void AllocatorThreadStart(ThreadState *thr);\n+void AllocatorThreadFinish(ThreadState *thr);\n+void AllocatorPrintStats();\n \n // For user allocations.\n void *user_alloc(ThreadState *thr, uptr pc, uptr sz,"}, {"sha": "78c1a7d8195832a6a22b7c8d75ff88cff280ae01", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -149,6 +149,7 @@ bool IsGlobalVar(uptr addr);\n uptr GetTlsSize();\n void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n                           uptr *tls_addr, uptr *tls_size);\n+int ExtractResolvFDs(void *state, int *fds, int nfd);\n \n }  // namespace __tsan\n "}, {"sha": "def91559d5ea511279fa86411dba2ce48b113069", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -38,6 +38,8 @@\n #include <errno.h>\n #include <sched.h>\n #include <dlfcn.h>\n+#define __need_res_state\n+#include <resolv.h>\n \n extern \"C\" int arch_prctl(int code, __sanitizer::uptr *addr);\n \n@@ -287,6 +289,19 @@ bool IsGlobalVar(uptr addr) {\n   return g_data_start && addr >= g_data_start && addr < g_data_end;\n }\n \n+#ifndef TSAN_GO\n+int ExtractResolvFDs(void *state, int *fds, int nfd) {\n+  int cnt = 0;\n+  __res_state *statp = (__res_state*)state;\n+  for (int i = 0; i < MAXNS && cnt < nfd; i++) {\n+    if (statp->_u._ext.nsaddrs[i] && statp->_u._ext.nssocks[i] != -1)\n+      fds[cnt++] = statp->_u._ext.nssocks[i];\n+  }\n+  return cnt;\n+}\n+#endif\n+\n+\n }  // namespace __tsan\n \n #endif  // #ifdef __linux__"}, {"sha": "098d8262ba13725bc29c468d136ba88c99e3e79c", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 44, "deletions": 19, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -41,23 +41,20 @@ const char *thread_name(char *buf, int tid) {\n   return buf;\n }\n \n-static void PrintHeader(ReportType typ) {\n-  Printf(\"WARNING: ThreadSanitizer: \");\n-\n+static const char *ReportTypeString(ReportType typ) {\n   if (typ == ReportTypeRace)\n-    Printf(\"data race\");\n-  else if (typ == ReportTypeUseAfterFree)\n-    Printf(\"heap-use-after-free\");\n-  else if (typ == ReportTypeThreadLeak)\n-    Printf(\"thread leak\");\n-  else if (typ == ReportTypeMutexDestroyLocked)\n-    Printf(\"destroy of a locked mutex\");\n-  else if (typ == ReportTypeSignalUnsafe)\n-    Printf(\"signal-unsafe call inside of a signal\");\n-  else if (typ == ReportTypeErrnoInSignal)\n-    Printf(\"signal handler spoils errno\");\n-\n-  Printf(\" (pid=%d)\\n\", GetPid());\n+    return \"data race\";\n+  if (typ == ReportTypeUseAfterFree)\n+    return \"heap-use-after-free\";\n+  if (typ == ReportTypeThreadLeak)\n+    return \"thread leak\";\n+  if (typ == ReportTypeMutexDestroyLocked)\n+    return \"destroy of a locked mutex\";\n+  if (typ == ReportTypeSignalUnsafe)\n+    return \"signal-unsafe call inside of a signal\";\n+  if (typ == ReportTypeErrnoInSignal)\n+    return \"signal handler spoils errno\";\n+  return \"\";\n }\n \n void PrintStack(const ReportStack *ent) {\n@@ -87,11 +84,17 @@ static void PrintMutexSet(Vector<ReportMopMutex> const& mset) {\n   }\n }\n \n+static const char *MopDesc(bool first, bool write, bool atomic) {\n+  return atomic ? (first ? (write ? \"Atomic write\" : \"Atomic read\")\n+                : (write ? \"Previous atomic write\" : \"Previous atomic read\"))\n+                : (first ? (write ? \"Write\" : \"Read\")\n+                : (write ? \"Previous write\" : \"Previous read\"));\n+}\n+\n static void PrintMop(const ReportMop *mop, bool first) {\n   char thrbuf[kThreadBufSize];\n   Printf(\"  %s of size %d at %p by %s\",\n-      (first ? (mop->write ? \"Write\" : \"Read\")\n-             : (mop->write ? \"Previous write\" : \"Previous read\")),\n+      MopDesc(first, mop->write, mop->atomic),\n       mop->size, (void*)mop->addr,\n       thread_name(thrbuf, mop->tid));\n   PrintMutexSet(mop->mset);\n@@ -150,9 +153,28 @@ static void PrintSleep(const ReportStack *s) {\n   PrintStack(s);\n }\n \n+static ReportStack *ChooseSummaryStack(const ReportDesc *rep) {\n+  if (rep->mops.Size())\n+    return rep->mops[0]->stack;\n+  if (rep->stacks.Size())\n+    return rep->stacks[0];\n+  if (rep->mutexes.Size())\n+    return rep->mutexes[0]->stack;\n+  if (rep->threads.Size())\n+    return rep->threads[0]->stack;\n+  return 0;\n+}\n+\n+ReportStack *SkipTsanInternalFrames(ReportStack *ent) {\n+  while (FrameIsInternal(ent) && ent->next)\n+    ent = ent->next;\n+  return ent;\n+}\n+\n void PrintReport(const ReportDesc *rep) {\n   Printf(\"==================\\n\");\n-  PrintHeader(rep->typ);\n+  const char *rep_typ_str = ReportTypeString(rep->typ);\n+  Printf(\"WARNING: ThreadSanitizer: %s (pid=%d)\\n\", rep_typ_str, GetPid());\n \n   for (uptr i = 0; i < rep->stacks.Size(); i++) {\n     if (i)\n@@ -175,6 +197,9 @@ void PrintReport(const ReportDesc *rep) {\n   for (uptr i = 0; i < rep->threads.Size(); i++)\n     PrintThread(rep->threads[i]);\n \n+  if (ReportStack *ent = SkipTsanInternalFrames(ChooseSummaryStack(rep)))\n+    ReportErrorSummary(rep_typ_str, ent->file, ent->line, ent->func);\n+\n   Printf(\"==================\\n\");\n }\n "}, {"sha": "eae2b3c721f677b4ab879a4caeef406af709cd73", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -46,6 +46,7 @@ struct ReportMop {\n   uptr addr;\n   int size;\n   bool write;\n+  bool atomic;\n   Vector<ReportMopMutex> mset;\n   ReportStack *stack;\n "}, {"sha": "673a355f1dc3f6e5d41fb237537e1f6d229d0593", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -35,6 +35,11 @@ THREADLOCAL char cur_thread_placeholder[sizeof(ThreadState)] ALIGNED(64);\n #endif\n static char ctx_placeholder[sizeof(Context)] ALIGNED(64);\n \n+// Can be overriden by a front-end.\n+bool CPP_WEAK OnFinalize(bool failed) {\n+  return failed;\n+}\n+\n static Context *ctx;\n Context *CTX() {\n   return ctx;\n@@ -136,7 +141,7 @@ static void InitializeMemoryProfile() {\n   InternalScopedBuffer<char> filename(4096);\n   internal_snprintf(filename.data(), filename.size(), \"%s.%d\",\n       flags()->profile_memory, GetPid());\n-  fd_t fd = internal_open(filename.data(), true);\n+  fd_t fd = OpenFile(filename.data(), true);\n   if (fd == kInvalidFd) {\n     Printf(\"Failed to open memory profile file '%s'\\n\", &filename[0]);\n     Die();\n@@ -180,6 +185,7 @@ void Initialize(ThreadState *thr) {\n   if (is_initialized)\n     return;\n   is_initialized = true;\n+  SanitizerToolName = \"ThreadSanitizer\";\n   // Install tool-specific callbacks in sanitizer_common.\n   SetCheckFailedCallback(TsanCheckFailed);\n \n@@ -237,7 +243,7 @@ void Initialize(ThreadState *thr) {\n     Printf(\"ThreadSanitizer is suspended at startup (pid %d).\"\n            \" Call __tsan_resume().\\n\",\n            GetPid());\n-    while (__tsan_resumed == 0);\n+    while (__tsan_resumed == 0) {}\n   }\n }\n \n@@ -253,6 +259,11 @@ int Finalize(ThreadState *thr) {\n   ctx->report_mtx.Lock();\n   ctx->report_mtx.Unlock();\n \n+#ifndef TSAN_GO\n+  if (ctx->flags.verbosity)\n+    AllocatorPrintStats();\n+#endif\n+\n   ThreadFinalize(thr);\n \n   if (ctx->nreported) {\n@@ -270,6 +281,8 @@ int Finalize(ThreadState *thr) {\n         ctx->nmissed_expected);\n   }\n \n+  failed = OnFinalize(failed);\n+\n   StatAggregate(ctx->stat, thr->stat);\n   StatOutput(ctx->stat);\n   return failed ? flags()->exitcode : 0;\n@@ -356,18 +369,6 @@ static inline void HandleRace(ThreadState *thr, u64 *shadow_mem,\n #endif\n }\n \n-static inline bool BothReads(Shadow s, int kAccessIsWrite) {\n-  return !kAccessIsWrite && !s.is_write();\n-}\n-\n-static inline bool OldIsRWNotWeaker(Shadow old, int kAccessIsWrite) {\n-  return old.is_write() || !kAccessIsWrite;\n-}\n-\n-static inline bool OldIsRWWeakerOrEqual(Shadow old, int kAccessIsWrite) {\n-  return !old.is_write() || kAccessIsWrite;\n-}\n-\n static inline bool OldIsInSameSynchEpoch(Shadow old, ThreadState *thr) {\n   return old.epoch() >= thr->fast_synch_epoch;\n }\n@@ -378,7 +379,7 @@ static inline bool HappensBefore(Shadow old, ThreadState *thr) {\n \n ALWAYS_INLINE\n void MemoryAccessImpl(ThreadState *thr, uptr addr,\n-    int kAccessSizeLog, bool kAccessIsWrite,\n+    int kAccessSizeLog, bool kAccessIsWrite, bool kIsAtomic,\n     u64 *shadow_mem, Shadow cur) {\n   StatInc(thr, StatMop);\n   StatInc(thr, kAccessIsWrite ? StatMopWrite : StatMopRead);\n@@ -452,7 +453,7 @@ void MemoryAccessImpl(ThreadState *thr, uptr addr,\n \n ALWAYS_INLINE\n void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n-    int kAccessSizeLog, bool kAccessIsWrite) {\n+    int kAccessSizeLog, bool kAccessIsWrite, bool kIsAtomic) {\n   u64 *shadow_mem = (u64*)MemToShadow(addr);\n   DPrintf2(\"#%d: MemoryAccess: @%p %p size=%d\"\n       \" is_write=%d shadow_mem=%p {%zx, %zx, %zx, %zx}\\n\",\n@@ -479,12 +480,13 @@ void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n   Shadow cur(fast_state);\n   cur.SetAddr0AndSizeLog(addr & 7, kAccessSizeLog);\n   cur.SetWrite(kAccessIsWrite);\n+  cur.SetAtomic(kIsAtomic);\n \n   // We must not store to the trace if we do not store to the shadow.\n   // That is, this call must be moved somewhere below.\n   TraceAddEvent(thr, fast_state, EventTypeMop, pc);\n \n-  MemoryAccessImpl(thr, addr, kAccessSizeLog, kAccessIsWrite,\n+  MemoryAccessImpl(thr, addr, kAccessSizeLog, kAccessIsWrite, kIsAtomic,\n       shadow_mem, cur);\n }\n \n@@ -531,7 +533,10 @@ void MemoryResetRange(ThreadState *thr, uptr pc, uptr addr, uptr size) {\n }\n \n void MemoryRangeFreed(ThreadState *thr, uptr pc, uptr addr, uptr size) {\n+  CHECK_EQ(thr->is_freeing, false);\n+  thr->is_freeing = true;\n   MemoryAccessRange(thr, pc, addr, size, true);\n+  thr->is_freeing = false;\n   Shadow s(thr->fast_state);\n   s.ClearIgnoreBit();\n   s.MarkAsFreed();"}, {"sha": "717f4599705288e78ad22a7e1896ccfe084ade17", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 91, "deletions": 15, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -171,7 +171,8 @@ class FastState {\n //   freed           : 1\n //   tid             : kTidBits\n //   epoch           : kClkBits\n-//   is_write        : 1\n+//   is_atomic       : 1\n+//   is_read         : 1\n //   size_log        : 2\n //   addr0           : 3\n class Shadow : public FastState {\n@@ -195,13 +196,26 @@ class Shadow : public FastState {\n   }\n \n   void SetWrite(unsigned kAccessIsWrite) {\n-    DCHECK_EQ(x_ & 32, 0);\n-    if (kAccessIsWrite)\n-      x_ |= 32;\n-    DCHECK_EQ(kAccessIsWrite, is_write());\n+    DCHECK_EQ(x_ & kReadBit, 0);\n+    if (!kAccessIsWrite)\n+      x_ |= kReadBit;\n+    DCHECK_EQ(kAccessIsWrite, IsWrite());\n   }\n \n-  bool IsZero() const { return x_ == 0; }\n+  void SetAtomic(bool kIsAtomic) {\n+    DCHECK(!IsAtomic());\n+    if (kIsAtomic)\n+      x_ |= kAtomicBit;\n+    DCHECK_EQ(IsAtomic(), kIsAtomic);\n+  }\n+\n+  bool IsAtomic() const {\n+    return x_ & kAtomicBit;\n+  }\n+\n+  bool IsZero() const {\n+    return x_ == 0;\n+  }\n \n   static inline bool TidsAreEqual(const Shadow s1, const Shadow s2) {\n     u64 shifted_xor = (s1.x_ ^ s2.x_) >> kTidShift;\n@@ -248,7 +262,8 @@ class Shadow : public FastState {\n   }\n   u64 addr0() const { return x_ & 7; }\n   u64 size() const { return 1ull << size_log(); }\n-  bool is_write() const { return x_ & 32; }\n+  bool IsWrite() const { return !IsRead(); }\n+  bool IsRead() const { return x_ & kReadBit; }\n \n   // The idea behind the freed bit is as follows.\n   // When the memory is freed (or otherwise unaccessible) we write to the shadow\n@@ -263,13 +278,46 @@ class Shadow : public FastState {\n      x_ |= kFreedBit;\n   }\n \n+  bool IsFreed() const {\n+    return x_ & kFreedBit;\n+  }\n+\n   bool GetFreedAndReset() {\n     bool res = x_ & kFreedBit;\n     x_ &= ~kFreedBit;\n     return res;\n   }\n \n+  bool IsBothReadsOrAtomic(bool kIsWrite, bool kIsAtomic) const {\n+    // analyzes 5-th bit (is_read) and 6-th bit (is_atomic)\n+    bool v = x_ & u64(((kIsWrite ^ 1) << kReadShift)\n+        | (kIsAtomic << kAtomicShift));\n+    DCHECK_EQ(v, (!IsWrite() && !kIsWrite) || (IsAtomic() && kIsAtomic));\n+    return v;\n+  }\n+\n+  bool IsRWNotWeaker(bool kIsWrite, bool kIsAtomic) const {\n+    bool v = ((x_ >> kReadShift) & 3)\n+        <= u64((kIsWrite ^ 1) | (kIsAtomic << 1));\n+    DCHECK_EQ(v, (IsAtomic() < kIsAtomic) ||\n+        (IsAtomic() == kIsAtomic && !IsWrite() <= !kIsWrite));\n+    return v;\n+  }\n+\n+  bool IsRWWeakerOrEqual(bool kIsWrite, bool kIsAtomic) const {\n+    bool v = ((x_ >> kReadShift) & 3)\n+        >= u64((kIsWrite ^ 1) | (kIsAtomic << 1));\n+    DCHECK_EQ(v, (IsAtomic() > kIsAtomic) ||\n+        (IsAtomic() == kIsAtomic && !IsWrite() >= !kIsWrite));\n+    return v;\n+  }\n+\n  private:\n+  static const u64 kReadShift   = 5;\n+  static const u64 kReadBit     = 1ull << kReadShift;\n+  static const u64 kAtomicShift = 6;\n+  static const u64 kAtomicBit   = 1ull << kAtomicShift;\n+\n   u64 size_log() const { return (x_ >> 3) & 3; }\n \n   static bool TwoRangesIntersectSLOW(const Shadow s1, const Shadow s2) {\n@@ -324,7 +372,9 @@ struct ThreadState {\n   const int tid;\n   const int unique_id;\n   int in_rtl;\n+  bool in_symbolizer;\n   bool is_alive;\n+  bool is_freeing;\n   const uptr stk_addr;\n   const uptr stk_size;\n   const uptr tls_addr;\n@@ -501,11 +551,14 @@ void InitializeDynamicAnnotations();\n void ReportRace(ThreadState *thr);\n bool OutputReport(Context *ctx,\n                   const ScopedReport &srep,\n-                  const ReportStack *suppress_stack = 0);\n+                  const ReportStack *suppress_stack1 = 0,\n+                  const ReportStack *suppress_stack2 = 0);\n bool IsFiredSuppression(Context *ctx,\n                         const ScopedReport &srep,\n                         const StackTrace &trace);\n bool IsExpectedReport(uptr addr, uptr size);\n+bool FrameIsInternal(const ReportStack *frame);\n+ReportStack *SkipTsanInternalFrames(ReportStack *ent);\n \n #if defined(TSAN_DEBUG_OUTPUT) && TSAN_DEBUG_OUTPUT >= 1\n # define DPrintf Printf\n@@ -521,6 +574,7 @@ bool IsExpectedReport(uptr addr, uptr size);\n \n u32 CurrentStackId(ThreadState *thr, uptr pc);\n void PrintCurrentStack(ThreadState *thr, uptr pc);\n+void PrintCurrentStackSlow();  // uses libunwind\n \n void Initialize(ThreadState *thr);\n int Finalize(ThreadState *thr);\n@@ -530,16 +584,38 @@ SyncVar* GetJavaSync(ThreadState *thr, uptr pc, uptr addr,\n SyncVar* GetAndRemoveJavaSync(ThreadState *thr, uptr pc, uptr addr);\n \n void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n-    int kAccessSizeLog, bool kAccessIsWrite);\n+    int kAccessSizeLog, bool kAccessIsWrite, bool kIsAtomic);\n void MemoryAccessImpl(ThreadState *thr, uptr addr,\n-    int kAccessSizeLog, bool kAccessIsWrite,\n+    int kAccessSizeLog, bool kAccessIsWrite, bool kIsAtomic,\n     u64 *shadow_mem, Shadow cur);\n-void MemoryRead1Byte(ThreadState *thr, uptr pc, uptr addr);\n-void MemoryWrite1Byte(ThreadState *thr, uptr pc, uptr addr);\n-void MemoryRead8Byte(ThreadState *thr, uptr pc, uptr addr);\n-void MemoryWrite8Byte(ThreadState *thr, uptr pc, uptr addr);\n void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n-                       uptr size, bool is_write);\n+    uptr size, bool is_write);\n+\n+const int kSizeLog1 = 0;\n+const int kSizeLog2 = 1;\n+const int kSizeLog4 = 2;\n+const int kSizeLog8 = 3;\n+\n+void ALWAYS_INLINE INLINE MemoryRead(ThreadState *thr, uptr pc,\n+                                     uptr addr, int kAccessSizeLog) {\n+  MemoryAccess(thr, pc, addr, kAccessSizeLog, false, false);\n+}\n+\n+void ALWAYS_INLINE INLINE MemoryWrite(ThreadState *thr, uptr pc,\n+                                      uptr addr, int kAccessSizeLog) {\n+  MemoryAccess(thr, pc, addr, kAccessSizeLog, true, false);\n+}\n+\n+void ALWAYS_INLINE INLINE MemoryReadAtomic(ThreadState *thr, uptr pc,\n+                                           uptr addr, int kAccessSizeLog) {\n+  MemoryAccess(thr, pc, addr, kAccessSizeLog, false, true);\n+}\n+\n+void ALWAYS_INLINE INLINE MemoryWriteAtomic(ThreadState *thr, uptr pc,\n+                                            uptr addr, int kAccessSizeLog) {\n+  MemoryAccess(thr, pc, addr, kAccessSizeLog, true, true);\n+}\n+\n void MemoryResetRange(ThreadState *thr, uptr pc, uptr addr, uptr size);\n void MemoryRangeFreed(ThreadState *thr, uptr pc, uptr addr, uptr size);\n void MemoryRangeImitateWrite(ThreadState *thr, uptr pc, uptr addr, uptr size);"}, {"sha": "22a71503c5c484bfeb1d5a8642fd729675a80e9f", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -24,8 +24,12 @@ void MutexCreate(ThreadState *thr, uptr pc, uptr addr,\n   CHECK_GT(thr->in_rtl, 0);\n   DPrintf(\"#%d: MutexCreate %zx\\n\", thr->tid, addr);\n   StatInc(thr, StatMutexCreate);\n-  if (!linker_init && IsAppMem(addr))\n-    MemoryWrite1Byte(thr, pc, addr);\n+  if (!linker_init && IsAppMem(addr)) {\n+    CHECK(!thr->is_freeing);\n+    thr->is_freeing = true;\n+    MemoryWrite(thr, pc, addr, kSizeLog1);\n+    thr->is_freeing = false;\n+  }\n   SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n   s->is_rw = rw;\n   s->is_recursive = recursive;\n@@ -47,8 +51,12 @@ void MutexDestroy(ThreadState *thr, uptr pc, uptr addr) {\n   SyncVar *s = ctx->synctab.GetAndRemove(thr, pc, addr);\n   if (s == 0)\n     return;\n-  if (IsAppMem(addr))\n-    MemoryWrite1Byte(thr, pc, addr);\n+  if (IsAppMem(addr)) {\n+    CHECK(!thr->is_freeing);\n+    thr->is_freeing = true;\n+    MemoryWrite(thr, pc, addr, kSizeLog1);\n+    thr->is_freeing = false;\n+  }\n   if (flags()->report_destroy_locked\n       && s->owner_tid != SyncVar::kInvalidTid\n       && !s->is_broken) {\n@@ -73,7 +81,7 @@ void MutexLock(ThreadState *thr, uptr pc, uptr addr) {\n   CHECK_GT(thr->in_rtl, 0);\n   DPrintf(\"#%d: MutexLock %zx\\n\", thr->tid, addr);\n   if (IsAppMem(addr))\n-    MemoryRead1Byte(thr, pc, addr);\n+    MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeLock, s->GetId());\n@@ -106,7 +114,7 @@ void MutexUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   CHECK_GT(thr->in_rtl, 0);\n   DPrintf(\"#%d: MutexUnlock %zx\\n\", thr->tid, addr);\n   if (IsAppMem(addr))\n-    MemoryRead1Byte(thr, pc, addr);\n+    MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeUnlock, s->GetId());\n@@ -144,7 +152,7 @@ void MutexReadLock(ThreadState *thr, uptr pc, uptr addr) {\n   DPrintf(\"#%d: MutexReadLock %zx\\n\", thr->tid, addr);\n   StatInc(thr, StatMutexReadLock);\n   if (IsAppMem(addr))\n-    MemoryRead1Byte(thr, pc, addr);\n+    MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, addr, false);\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeRLock, s->GetId());\n@@ -165,7 +173,7 @@ void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   DPrintf(\"#%d: MutexReadUnlock %zx\\n\", thr->tid, addr);\n   StatInc(thr, StatMutexReadUnlock);\n   if (IsAppMem(addr))\n-    MemoryRead1Byte(thr, pc, addr);\n+    MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeRUnlock, s->GetId());\n@@ -186,7 +194,7 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   CHECK_GT(thr->in_rtl, 0);\n   DPrintf(\"#%d: MutexReadOrWriteUnlock %zx\\n\", thr->tid, addr);\n   if (IsAppMem(addr))\n-    MemoryRead1Byte(thr, pc, addr);\n+    MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n   bool write = true;\n   if (s->owner_tid == SyncVar::kInvalidTid) {"}, {"sha": "ff1d43bc9e8afdf6cf7cf42fa14c3f34864869f8", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 57, "deletions": 14, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -13,6 +13,7 @@\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"tsan_platform.h\"\n #include \"tsan_rtl.h\"\n #include \"tsan_suppressions.h\"\n@@ -27,12 +28,15 @@ namespace __tsan {\n \n using namespace __sanitizer;  // NOLINT\n \n+static ReportStack *SymbolizeStack(const StackTrace& trace);\n+\n void TsanCheckFailed(const char *file, int line, const char *cond,\n                      u64 v1, u64 v2) {\n   ScopedInRtl in_rtl;\n   Printf(\"FATAL: ThreadSanitizer CHECK failed: \"\n          \"%s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\",\n          file, line, cond, (uptr)v1, (uptr)v2);\n+  PrintCurrentStackSlow();\n   Die();\n }\n \n@@ -144,7 +148,8 @@ void ScopedReport::AddMemoryAccess(uptr addr, Shadow s,\n   mop->tid = s.tid();\n   mop->addr = addr + s.addr0();\n   mop->size = s.size();\n-  mop->write = s.is_write();\n+  mop->write = s.IsWrite();\n+  mop->atomic = s.IsAtomic();\n   mop->stack = SymbolizeStack(*stack);\n   for (uptr i = 0; i < mset->Size(); i++) {\n     MutexSet::Desc d = mset->Get(i);\n@@ -458,9 +463,12 @@ static void AddRacyStacks(ThreadState *thr, const StackTrace (&traces)[2],\n \n bool OutputReport(Context *ctx,\n                   const ScopedReport &srep,\n-                  const ReportStack *suppress_stack) {\n+                  const ReportStack *suppress_stack1,\n+                  const ReportStack *suppress_stack2) {\n   const ReportDesc *rep = srep.GetReport();\n-  const uptr suppress_pc = IsSuppressed(rep->typ, suppress_stack);\n+  uptr suppress_pc = IsSuppressed(rep->typ, suppress_stack1);\n+  if (suppress_pc == 0)\n+    suppress_pc = IsSuppressed(rep->typ, suppress_stack2);\n   if (suppress_pc != 0) {\n     FiredSuppression supp = {srep.GetReport()->typ, suppress_pc};\n     ctx->fired_suppressions.PushBack(supp);\n@@ -486,6 +494,13 @@ bool IsFiredSuppression(Context *ctx,\n   return false;\n }\n \n+bool FrameIsInternal(const ReportStack *frame) {\n+  return frame != 0 && frame->file != 0\n+      && (internal_strstr(frame->file, \"tsan_interceptors.cc\") ||\n+          internal_strstr(frame->file, \"sanitizer_common_interceptors.inc\") ||\n+          internal_strstr(frame->file, \"tsan_interface_\"));\n+}\n+\n // On programs that use Java we see weird reports like:\n // WARNING: ThreadSanitizer: data race (pid=22512)\n //   Read of size 8 at 0x7d2b00084318 by thread 100:\n@@ -495,22 +510,20 @@ bool IsFiredSuppression(Context *ctx,\n //     #0 strncpy tsan_interceptors.cc:501 (foo+0x00000d8e0919)\n //     #1 <null> <null>:0 (0x7f7ad9b42707)\n static bool IsJavaNonsense(const ReportDesc *rep) {\n+#ifndef TSAN_GO\n   for (uptr i = 0; i < rep->mops.Size(); i++) {\n     ReportMop *mop = rep->mops[i];\n     ReportStack *frame = mop->stack;\n-    if (frame != 0 && frame->func != 0\n-        && (internal_strcmp(frame->func, \"memset\") == 0\n-        || internal_strcmp(frame->func, \"memcpy\") == 0\n-        || internal_strcmp(frame->func, \"memmove\") == 0\n-        || internal_strcmp(frame->func, \"strcmp\") == 0\n-        || internal_strcmp(frame->func, \"strncpy\") == 0\n-        || internal_strcmp(frame->func, \"strlen\") == 0\n-        || internal_strcmp(frame->func, \"free\") == 0\n-        || internal_strcmp(frame->func, \"pthread_mutex_lock\") == 0)) {\n+    if (frame == 0\n+        || (frame->func == 0 && frame->file == 0 && frame->line == 0\n+          && frame->module == 0)) {\n+      return true;\n+    }\n+    if (FrameIsInternal(frame)) {\n       frame = frame->next;\n       if (frame == 0\n           || (frame->func == 0 && frame->file == 0 && frame->line == 0\n-            && frame->module == 0)) {\n+          && frame->module == 0)) {\n         if (frame) {\n           FiredSuppression supp = {rep->typ, frame->pc};\n           CTX()->fired_suppressions.PushBack(supp);\n@@ -519,6 +532,20 @@ static bool IsJavaNonsense(const ReportDesc *rep) {\n       }\n     }\n   }\n+#endif\n+  return false;\n+}\n+\n+static bool RaceBetweenAtomicAndFree(ThreadState *thr) {\n+  Shadow s0(thr->racy_state[0]);\n+  Shadow s1(thr->racy_state[1]);\n+  CHECK(!(s0.IsAtomic() && s1.IsAtomic()));\n+  if (!s0.IsAtomic() && !s1.IsAtomic())\n+    return true;\n+  if (s0.IsAtomic() && s1.IsFreed())\n+    return true;\n+  if (s1.IsAtomic() && thr->is_freeing)\n+    return true;\n   return false;\n }\n \n@@ -527,6 +554,9 @@ void ReportRace(ThreadState *thr) {\n     return;\n   ScopedInRtl in_rtl;\n \n+  if (!flags()->report_atomic_races && !RaceBetweenAtomicAndFree(thr))\n+    return;\n+\n   if (thr->in_signal_handler)\n     Printf(\"ThreadSanitizer: printing report from signal handler.\"\n            \" Can crash or hang.\\n\");\n@@ -597,7 +627,8 @@ void ReportRace(ThreadState *thr) {\n   }\n #endif\n \n-  if (!OutputReport(ctx, rep, rep.GetReport()->mops[0]->stack))\n+  if (!OutputReport(ctx, rep, rep.GetReport()->mops[0]->stack,\n+                              rep.GetReport()->mops[1]->stack))\n     return;\n \n   AddRacyStacks(thr, traces, addr_min, addr_max);\n@@ -609,4 +640,16 @@ void PrintCurrentStack(ThreadState *thr, uptr pc) {\n   PrintStack(SymbolizeStack(trace));\n }\n \n+void PrintCurrentStackSlow() {\n+#ifndef TSAN_GO\n+  __sanitizer::StackTrace *ptrace = new(internal_alloc(MBlockStackTrace,\n+      sizeof(__sanitizer::StackTrace))) __sanitizer::StackTrace;\n+  ptrace->SlowUnwindStack(__sanitizer::StackTrace::GetCurrentPc(),\n+      kStackTraceMax);\n+  StackTrace trace;\n+  trace.Init(ptrace->trace, ptrace->size);\n+  PrintStack(SymbolizeStack(trace));\n+#endif\n+}\n+\n }  // namespace __tsan"}, {"sha": "9c89417ad68036be7e967c3b32052d1c97e20132", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -206,6 +206,9 @@ void ThreadStart(ThreadState *thr, int tid, uptr os_id) {\n       kInitStackSize * sizeof(uptr));\n   thr->shadow_stack_pos = thr->shadow_stack;\n   thr->shadow_stack_end = thr->shadow_stack + kInitStackSize;\n+#endif\n+#ifndef TSAN_GO\n+  AllocatorThreadStart(thr);\n #endif\n   tctx->thr = thr;\n   thr->fast_synch_epoch = tctx->epoch0;\n@@ -267,7 +270,7 @@ void ThreadFinish(ThreadState *thr) {\n   tctx->epoch1 = thr->fast_state.epoch();\n \n #ifndef TSAN_GO\n-  AlloctorThreadFinish(thr);\n+  AllocatorThreadFinish(thr);\n #endif\n   thr->~ThreadState();\n   StatAggregate(ctx->stat, thr->stat);\n@@ -392,7 +395,7 @@ void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n     Shadow cur(fast_state);\n     cur.SetWrite(is_write);\n     cur.SetAddr0AndSizeLog(addr & (kShadowCell - 1), kAccessSizeLog);\n-    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write,\n+    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write, false,\n         shadow_mem, cur);\n   }\n   if (unaligned)\n@@ -403,7 +406,7 @@ void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n     Shadow cur(fast_state);\n     cur.SetWrite(is_write);\n     cur.SetAddr0AndSizeLog(0, kAccessSizeLog);\n-    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write,\n+    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write, false,\n         shadow_mem, cur);\n     shadow_mem += kShadowCnt;\n   }\n@@ -413,24 +416,8 @@ void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n     Shadow cur(fast_state);\n     cur.SetWrite(is_write);\n     cur.SetAddr0AndSizeLog(addr & (kShadowCell - 1), kAccessSizeLog);\n-    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write,\n+    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write, false,\n         shadow_mem, cur);\n   }\n }\n-\n-void MemoryRead1Byte(ThreadState *thr, uptr pc, uptr addr) {\n-  MemoryAccess(thr, pc, addr, 0, 0);\n-}\n-\n-void MemoryWrite1Byte(ThreadState *thr, uptr pc, uptr addr) {\n-  MemoryAccess(thr, pc, addr, 0, 1);\n-}\n-\n-void MemoryRead8Byte(ThreadState *thr, uptr pc, uptr addr) {\n-  MemoryAccess(thr, pc, addr, 3, 0);\n-}\n-\n-void MemoryWrite8Byte(ThreadState *thr, uptr pc, uptr addr) {\n-  MemoryAccess(thr, pc, addr, 3, 1);\n-}\n }  // namespace __tsan"}, {"sha": "cd88d2df9281d15d88102e2b2f2019776c23e87b", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -179,6 +179,18 @@ void StatOutput(u64 *stat) {\n   name[StatInt_sem_timedwait]            = \"  sem_timedwait                   \";\n   name[StatInt_sem_post]                 = \"  sem_post                        \";\n   name[StatInt_sem_getvalue]             = \"  sem_getvalue                    \";\n+  name[StatInt_stat]                     = \"  stat                            \";\n+  name[StatInt___xstat]                  = \"  __xstat                         \";\n+  name[StatInt_stat64]                   = \"  stat64                          \";\n+  name[StatInt___xstat64]                = \"  __xstat64                       \";\n+  name[StatInt_lstat]                    = \"  lstat                           \";\n+  name[StatInt___lxstat]                 = \"  __lxstat                        \";\n+  name[StatInt_lstat64]                  = \"  lstat64                         \";\n+  name[StatInt___lxstat64]               = \"  __lxstat64                      \";\n+  name[StatInt_fstat]                    = \"  fstat                           \";\n+  name[StatInt___fxstat]                 = \"  __fxstat                        \";\n+  name[StatInt_fstat64]                  = \"  fstat64                         \";\n+  name[StatInt___fxstat64]               = \"  __fxstat64                      \";\n   name[StatInt_open]                     = \"  open                            \";\n   name[StatInt_open64]                   = \"  open64                          \";\n   name[StatInt_creat]                    = \"  creat                           \";\n@@ -193,12 +205,15 @@ void StatOutput(u64 *stat) {\n   name[StatInt_socket]                   = \"  socket                          \";\n   name[StatInt_socketpair]               = \"  socketpair                      \";\n   name[StatInt_connect]                  = \"  connect                         \";\n+  name[StatInt_bind]                     = \"  bind                            \";\n+  name[StatInt_listen]                   = \"  listen                          \";\n   name[StatInt_accept]                   = \"  accept                          \";\n   name[StatInt_accept4]                  = \"  accept4                         \";\n   name[StatInt_epoll_create]             = \"  epoll_create                    \";\n   name[StatInt_epoll_create1]            = \"  epoll_create1                   \";\n   name[StatInt_close]                    = \"  close                           \";\n   name[StatInt___close]                  = \"  __close                         \";\n+  name[StatInt___res_iclose]             = \"  __res_iclose                    \";\n   name[StatInt_pipe]                     = \"  pipe                            \";\n   name[StatInt_pipe2]                    = \"  pipe2                           \";\n   name[StatInt_read]                     = \"  read                            \";\n@@ -240,6 +255,14 @@ void StatOutput(u64 *stat) {\n   name[StatInt_scanf]                    = \"  scanf                           \";\n   name[StatInt_sscanf]                   = \"  sscanf                          \";\n   name[StatInt_fscanf]                   = \"  fscanf                          \";\n+  name[StatInt___isoc99_vscanf]          = \"  vscanf                          \";\n+  name[StatInt___isoc99_vsscanf]         = \"  vsscanf                         \";\n+  name[StatInt___isoc99_vfscanf]         = \"  vfscanf                         \";\n+  name[StatInt___isoc99_scanf]           = \"  scanf                           \";\n+  name[StatInt___isoc99_sscanf]          = \"  sscanf                          \";\n+  name[StatInt___isoc99_fscanf]          = \"  fscanf                          \";\n+  name[StatInt_on_exit]                  = \"  on_exit                         \";\n+  name[StatInt___cxa_atexit]             = \"  __cxa_atexit                    \";\n \n   name[StatAnnotation]                   = \"Dynamic annotations               \";\n   name[StatAnnotateHappensBefore]        = \"  HappensBefore                   \";\n@@ -285,6 +308,7 @@ void StatOutput(u64 *stat) {\n   name[StatMtxAnnotations]               = \"  Annotations                     \";\n   name[StatMtxMBlock]                    = \"  MBlock                          \";\n   name[StatMtxJavaMBlock]                = \"  JavaMBlock                      \";\n+  name[StatMtxFD]                        = \"  FD                              \";\n \n   Printf(\"Statistics:\\n\");\n   for (int i = 0; i < StatCnt; i++)"}, {"sha": "1d6c54cdd4f7c76d31a6100d3ad873f350c291cd", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -174,6 +174,18 @@ enum StatType {\n   StatInt_sem_timedwait,\n   StatInt_sem_post,\n   StatInt_sem_getvalue,\n+  StatInt_stat,\n+  StatInt___xstat,\n+  StatInt_stat64,\n+  StatInt___xstat64,\n+  StatInt_lstat,\n+  StatInt___lxstat,\n+  StatInt_lstat64,\n+  StatInt___lxstat64,\n+  StatInt_fstat,\n+  StatInt___fxstat,\n+  StatInt_fstat64,\n+  StatInt___fxstat64,\n   StatInt_open,\n   StatInt_open64,\n   StatInt_creat,\n@@ -188,12 +200,15 @@ enum StatType {\n   StatInt_socket,\n   StatInt_socketpair,\n   StatInt_connect,\n+  StatInt_bind,\n+  StatInt_listen,\n   StatInt_accept,\n   StatInt_accept4,\n   StatInt_epoll_create,\n   StatInt_epoll_create1,\n   StatInt_close,\n   StatInt___close,\n+  StatInt___res_iclose,\n   StatInt_pipe,\n   StatInt_pipe2,\n   StatInt_read,\n@@ -239,6 +254,14 @@ enum StatType {\n   StatInt_scanf,\n   StatInt_sscanf,\n   StatInt_fscanf,\n+  StatInt___isoc99_vscanf,\n+  StatInt___isoc99_vsscanf,\n+  StatInt___isoc99_vfscanf,\n+  StatInt___isoc99_scanf,\n+  StatInt___isoc99_sscanf,\n+  StatInt___isoc99_fscanf,\n+  StatInt_on_exit,\n+  StatInt___cxa_atexit,\n \n   // Dynamic annotations.\n   StatAnnotation,\n@@ -287,6 +310,7 @@ enum StatType {\n   StatMtxAtExit,\n   StatMtxMBlock,\n   StatMtxJavaMBlock,\n+  StatMtxFD,\n \n   // This must be the last.\n   StatCnt"}, {"sha": "b6c54db2c51323b25f1b5e56158599a587962b4a", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -17,6 +17,13 @@\n #include \"tsan_mman.h\"\n #include \"tsan_platform.h\"\n \n+// Can be overriden in frontend.\n+#ifndef TSAN_GO\n+extern \"C\" const char *WEAK __tsan_default_suppressions() {\n+  return 0;\n+}\n+#endif\n+\n namespace __tsan {\n \n static Suppression *g_suppressions;\n@@ -29,7 +36,7 @@ static char *ReadFile(const char *filename) {\n     internal_snprintf(tmp.data(), tmp.size(), \"%s\", filename);\n   else\n     internal_snprintf(tmp.data(), tmp.size(), \"%s/%s\", GetPwd(), filename);\n-  fd_t fd = internal_open(tmp.data(), false);\n+  fd_t fd = OpenFile(tmp.data(), false);\n   if (fd == kInvalidFd) {\n     Printf(\"ThreadSanitizer: failed to open suppressions file '%s'\\n\",\n                tmp.data());\n@@ -78,8 +85,7 @@ bool SuppressionMatch(char *templ, const char *str) {\n   return true;\n }\n \n-Suppression *SuppressionParse(const char* supp) {\n-  Suppression *head = 0;\n+Suppression *SuppressionParse(Suppression *head, const char* supp) {\n   const char *line = supp;\n   while (line) {\n     while (line[0] == ' ' || line[0] == '\\t')\n@@ -128,8 +134,12 @@ Suppression *SuppressionParse(const char* supp) {\n }\n \n void InitializeSuppressions() {\n-  char *supp = ReadFile(flags()->suppressions);\n-  g_suppressions = SuppressionParse(supp);\n+  const char *supp = ReadFile(flags()->suppressions);\n+  g_suppressions = SuppressionParse(0, supp);\n+#ifndef TSAN_GO\n+  supp = __tsan_default_suppressions();\n+  g_suppressions = SuppressionParse(0, supp);\n+#endif\n }\n \n uptr IsSuppressed(ReportType typ, const ReportStack *stack) {\n@@ -150,7 +160,8 @@ uptr IsSuppressed(ReportType typ, const ReportStack *stack) {\n     for (Suppression *supp = g_suppressions; supp; supp = supp->next) {\n       if (stype == supp->type &&\n           (SuppressionMatch(supp->templ, frame->func) ||\n-          SuppressionMatch(supp->templ, frame->file))) {\n+           SuppressionMatch(supp->templ, frame->file) ||\n+           SuppressionMatch(supp->templ, frame->module))) {\n         DPrintf(\"ThreadSanitizer: matched suppression '%s'\\n\", supp->templ);\n         return frame->pc;\n       }"}, {"sha": "d44d8dd35297c89dfd9332da6036e1e75cb032e6", "filename": "libsanitizer/tsan/tsan_suppressions.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -33,7 +33,7 @@ struct Suppression {\n   char *templ;\n };\n \n-Suppression *SuppressionParse(const char* supp);\n+Suppression *SuppressionParse(Suppression *head, const char* supp);\n bool SuppressionMatch(char *templ, const char *str);\n \n }  // namespace __tsan"}, {"sha": "65a994670b5c5298cf90e2fd84c51a355a959aa2", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -16,9 +16,24 @@\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n #include \"tsan_flags.h\"\n #include \"tsan_report.h\"\n+#include \"tsan_rtl.h\"\n \n namespace __tsan {\n \n+struct ScopedInSymbolizer {\n+  ScopedInSymbolizer() {\n+    ThreadState *thr = cur_thread();\n+    CHECK(!thr->in_symbolizer);\n+    thr->in_symbolizer = true;\n+  }\n+\n+  ~ScopedInSymbolizer() {\n+    ThreadState *thr = cur_thread();\n+    CHECK(thr->in_symbolizer);\n+    thr->in_symbolizer = false;\n+  }\n+};\n+\n ReportStack *NewReportStackEntry(uptr addr) {\n   ReportStack *ent = (ReportStack*)internal_alloc(MBlockReportStack,\n                                                   sizeof(ReportStack));\n@@ -53,35 +68,36 @@ static ReportStack *NewReportStackEntry(const AddressInfo &info) {\n }\n \n ReportStack *SymbolizeCode(uptr addr) {\n-  if (flags()->external_symbolizer_path[0]) {\n-    static const uptr kMaxAddrFrames = 16;\n-    InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n-    for (uptr i = 0; i < kMaxAddrFrames; i++)\n-      new(&addr_frames[i]) AddressInfo();\n-    uptr addr_frames_num = __sanitizer::SymbolizeCode(addr, addr_frames.data(),\n-                                                      kMaxAddrFrames);\n-    if (addr_frames_num == 0)\n-      return NewReportStackEntry(addr);\n-    ReportStack *top = 0;\n-    ReportStack *bottom = 0;\n-    for (uptr i = 0; i < addr_frames_num; i++) {\n-      ReportStack *cur_entry = NewReportStackEntry(addr_frames[i]);\n-      CHECK(cur_entry);\n-      addr_frames[i].Clear();\n-      if (i == 0)\n-        top = cur_entry;\n-      else\n-        bottom->next = cur_entry;\n-      bottom = cur_entry;\n-    }\n-    return top;\n+  if (!IsSymbolizerAvailable())\n+    return SymbolizeCodeAddr2Line(addr);\n+  ScopedInSymbolizer in_symbolizer;\n+  static const uptr kMaxAddrFrames = 16;\n+  InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n+  for (uptr i = 0; i < kMaxAddrFrames; i++)\n+    new(&addr_frames[i]) AddressInfo();\n+  uptr addr_frames_num = __sanitizer::SymbolizeCode(addr, addr_frames.data(),\n+                                                    kMaxAddrFrames);\n+  if (addr_frames_num == 0)\n+    return NewReportStackEntry(addr);\n+  ReportStack *top = 0;\n+  ReportStack *bottom = 0;\n+  for (uptr i = 0; i < addr_frames_num; i++) {\n+    ReportStack *cur_entry = NewReportStackEntry(addr_frames[i]);\n+    CHECK(cur_entry);\n+    addr_frames[i].Clear();\n+    if (i == 0)\n+      top = cur_entry;\n+    else\n+      bottom->next = cur_entry;\n+    bottom = cur_entry;\n   }\n-  return SymbolizeCodeAddr2Line(addr);\n+  return top;\n }\n \n ReportLocation *SymbolizeData(uptr addr) {\n-  if (flags()->external_symbolizer_path[0] == 0)\n+  if (!IsSymbolizerAvailable())\n     return 0;\n+  ScopedInSymbolizer in_symbolizer;\n   DataInfo info;\n   if (!__sanitizer::SymbolizeData(addr, &info))\n     return 0;"}, {"sha": "b9aa51c7957542e64390a2062bc601759bf237b0", "filename": "libsanitizer/tsan/tsan_update_shadow_word_inl.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -32,7 +32,7 @@ do {\n     if (Shadow::TidsAreEqual(old, cur)) {\n       StatInc(thr, StatShadowSameThread);\n       if (OldIsInSameSynchEpoch(old, thr)) {\n-        if (OldIsRWNotWeaker(old, kAccessIsWrite)) {\n+        if (old.IsRWNotWeaker(kAccessIsWrite, kIsAtomic)) {\n           // found a slot that holds effectively the same info\n           // (that is, same tid, same sync epoch and same size)\n           StatInc(thr, StatMopSame);\n@@ -41,7 +41,7 @@ do {\n         StoreIfNotYetStored(sp, &store_word);\n         break;\n       }\n-      if (OldIsRWWeakerOrEqual(old, kAccessIsWrite))\n+      if (old.IsRWWeakerOrEqual(kAccessIsWrite, kIsAtomic))\n         StoreIfNotYetStored(sp, &store_word);\n       break;\n     }\n@@ -50,25 +50,23 @@ do {\n       StoreIfNotYetStored(sp, &store_word);\n       break;\n     }\n-    if (BothReads(old, kAccessIsWrite))\n+    if (old.IsBothReadsOrAtomic(kAccessIsWrite, kIsAtomic))\n       break;\n     goto RACE;\n   }\n-\n   // Do the memory access intersect?\n-  if (Shadow::TwoRangesIntersect(old, cur, kAccessSize)) {\n+  // In Go all memory accesses are 1 byte, so there can be no intersections.\n+  if (kCppMode && Shadow::TwoRangesIntersect(old, cur, kAccessSize)) {\n     StatInc(thr, StatShadowIntersect);\n     if (Shadow::TidsAreEqual(old, cur)) {\n       StatInc(thr, StatShadowSameThread);\n       break;\n     }\n     StatInc(thr, StatShadowAnotherThread);\n-    if (HappensBefore(old, thr))\n+    if (old.IsBothReadsOrAtomic(kAccessIsWrite, kIsAtomic))\n       break;\n-\n-    if (BothReads(old, kAccessIsWrite))\n+    if (HappensBefore(old, thr))\n       break;\n-\n     goto RACE;\n   }\n   // The accesses do not intersect."}, {"sha": "99e9f792c20cb1c8248e84e6dd70753b8c1b2023", "filename": "libsanitizer/tsan/tsan_vector.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3/libsanitizer%2Ftsan%2Ftsan_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_vector.h?ref=b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "patch": "@@ -103,6 +103,6 @@ class Vector {\n   Vector(const Vector&);\n   void operator=(const Vector&);\n };\n-}\n+}  // namespace __tsan\n \n #endif  // #ifndef TSAN_VECTOR_H"}]}