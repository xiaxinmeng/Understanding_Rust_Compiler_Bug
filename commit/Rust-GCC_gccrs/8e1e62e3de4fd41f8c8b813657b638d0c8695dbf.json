{"sha": "8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUxZTYyZTNkZTRmZDQxZjhjOGI4MTM2NTdiNjM4ZDBjODY5NWRiZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-06T10:04:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-06T10:04:39Z"}, "message": "[multiple changes]\n\n2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Depends_In_Decl_Part): Add\n\tlocal variable Expr. Flag clauses with extra parenthesis as this\n\tis not allowed by the syntax of the pragma. Code reformatting.\n\n2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Alphabetize\n\tvariables. Rename variabme Tnn to Temp. Do not create a temporary\n\tif assertions are disabled. Find enclosing routine _Postconditions\n\tand insert the temporary that captures the value of the prefix\n\tbefore the routine.\n\t* exp_ch6.adb (Build_Postconditions_Procedure):\n\tInsert the generated _Postconditions routine\n\tbefore the first source declaration of the related\n\tsubprogram.\n\t(Insert_After_Last_Declaration): Removed.\n\t(Insert_Before_First_Source_Declaration): New routine.\n\n2014-02-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.adb, exp_util.ads (Within_Internal_Subprogram):\n\tUtility to determine whether current expansion is for the body\n\tof a predefined primitive operation.\n\t(Make_Predicate_Check): Use Within_Internal_Subpgram\n\t* checks.adb (Apply_Predicate_Check): Use\n\tWithin_Internal_Subprogram\n\t* sem_ch13.adb (Freeze_Entity_Checks): Ditto.\n\n2014-02-06  Pascal Obry  <obry@adacore.com>\n\n\t* prj.ads, prj-util.adb: Minor reformatting.\n\nFrom-SVN: r207537", "tree": {"sha": "491a47bc58c76025bad512392a2cce5249ee6fd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/491a47bc58c76025bad512392a2cce5249ee6fd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/comments", "author": null, "committer": null, "parents": [{"sha": "cbee4f7497366895219ee4caa04b9d2f4c45ce83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbee4f7497366895219ee4caa04b9d2f4c45ce83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbee4f7497366895219ee4caa04b9d2f4c45ce83"}], "stats": {"total": 372, "additions": 261, "deletions": 111}, "files": [{"sha": "2b58fce30ebc7c80c4e704a2d2728e1498746741", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "patch": "@@ -1,3 +1,37 @@\n+2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Depends_In_Decl_Part): Add\n+\tlocal variable Expr. Flag clauses with extra parenthesis as this\n+\tis not allowed by the syntax of the pragma. Code reformatting.\n+\n+2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Alphabetize\n+\tvariables. Rename variabme Tnn to Temp. Do not create a temporary\n+\tif assertions are disabled. Find enclosing routine _Postconditions\n+\tand insert the temporary that captures the value of the prefix\n+\tbefore the routine.\n+\t* exp_ch6.adb (Build_Postconditions_Procedure):\n+\tInsert the generated _Postconditions routine\n+\tbefore the first source declaration of the related\n+\tsubprogram.\n+\t(Insert_After_Last_Declaration): Removed.\n+\t(Insert_Before_First_Source_Declaration): New routine.\n+\n+2014-02-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.adb, exp_util.ads (Within_Internal_Subprogram):\n+\tUtility to determine whether current expansion is for the body\n+\tof a predefined primitive operation.\n+\t(Make_Predicate_Check): Use Within_Internal_Subpgram\n+\t* checks.adb (Apply_Predicate_Check): Use\n+\tWithin_Internal_Subprogram\n+\t* sem_ch13.adb (Freeze_Entity_Checks): Ditto.\n+\n+2014-02-06  Pascal Obry  <obry@adacore.com>\n+\n+\t* prj.ads, prj-util.adb: Minor reformatting.\n+\n 2014-02-06  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_ch6.adb (Expand_Subprogram_Contract, Append_Enabled_Item):"}, {"sha": "71960ce87c26874c95af6f8225e62df010844470", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "patch": "@@ -32,7 +32,6 @@ with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch4;  use Exp_Ch4;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Pakd; use Exp_Pakd;\n-with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Elists;   use Elists;\n with Expander; use Expander;\n@@ -2574,23 +2573,23 @@ package body Checks is\n    begin\n       if Present (Predicate_Function (Typ)) then\n \n-         --  A predicate check does not apply within internally generated\n-         --  subprograms, such as TSS functions.\n-\n          S := Current_Scope;\n          while Present (S) and then not Is_Subprogram (S) loop\n             S := Scope (S);\n          end loop;\n \n-         if Present (S) and then Get_TSS_Name (S) /= TSS_Null then\n+         --  A predicate check does not apply within internally generated\n+         --  subprograms, such as TSS functions.\n+\n+         if Within_Internal_Subprogram then\n             return;\n \n          --  If the check appears within the predicate function itself, it\n          --  means that the user specified a check whose formal is the\n          --  predicated subtype itself, rather than some covering type. This\n          --  is likely to be a common error, and thus deserves a warning.\n \n-         elsif S = Predicate_Function (Typ) then\n+         elsif Present (S) and then  S = Predicate_Function (Typ) then\n             Error_Msg_N\n               (\"predicate check includes a function call that \"\n                & \"requires a predicate check??\", Parent (N));\n@@ -3208,6 +3207,13 @@ package body Checks is\n       elsif Serious_Errors_Detected > 0 then\n          return;\n \n+      --  Never generate discriminant checks for Unchecked_Union types\n+\n+      elsif Present (Expr_Type)\n+        and then Is_Unchecked_Union (Expr_Type)\n+      then\n+         return;\n+\n       --  Scalar type conversions of the form Target_Type (Expr) require a\n       --  range check if we cannot be sure that Expr is in the base type of\n       --  Target_Typ and also that Expr is in the range of Target_Typ. These\n@@ -3218,8 +3224,8 @@ package body Checks is\n          declare\n             Conv_OK  : constant Boolean := Conversion_OK (N);\n             --  If the Conversion_OK flag on the type conversion is set and no\n-            --  floating point type is involved in the type conversion then\n-            --  fixed point values must be read as integral values.\n+            --  floating-point type is involved in the type conversion then\n+            --  fixed-point values must be read as integral values.\n \n             Float_To_Int : constant Boolean :=\n               Is_Floating_Point_Type (Expr_Type)\n@@ -3245,9 +3251,9 @@ package body Checks is\n                     (Expr, Target_Type, Fixed_Int => Conv_OK);\n \n                   --  If the target type has predicates, we need to indicate\n-                  --  the need for a check, even if Determine_Range finds\n-                  --  that the value is within bounds. This may be the case\n-                  --  e.g for a division with a constant denominator.\n+                  --  the need for a check, even if Determine_Range finds that\n+                  --  the value is within bounds. This may be the case e.g for\n+                  --  a division with a constant denominator.\n \n                   if Has_Predicates (Target_Type) then\n                      Enable_Range_Check (Expr);\n@@ -3267,9 +3273,9 @@ package body Checks is\n          --  An unconstrained derived type may have inherited discriminant.\n          --  Build an actual discriminant constraint list using the stored\n          --  constraint, to verify that the expression of the parent type\n-         --  satisfies the constraints imposed by the (unconstrained)\n-         --  derived type. This applies to value conversions, not to view\n-         --  conversions of tagged types.\n+         --  satisfies the constraints imposed by the (unconstrained) derived\n+         --  type. This applies to value conversions, not to view conversions\n+         --  of tagged types.\n \n          declare\n             Loc         : constant Source_Ptr := Sloc (N);\n@@ -3794,11 +3800,11 @@ package body Checks is\n \n    begin\n       pragma Assert\n-        (K = N_Component_Declaration\n-           or else K = N_Discriminant_Specification\n-           or else K = N_Function_Specification\n-           or else K = N_Object_Declaration\n-           or else K = N_Parameter_Specification);\n+        (Nkind_In (K, N_Component_Declaration,\n+                      N_Discriminant_Specification,\n+                      N_Function_Specification,\n+                      N_Object_Declaration,\n+                      N_Parameter_Specification));\n \n       if K = N_Function_Specification then\n          Typ := Etype (Defining_Entity (N));"}, {"sha": "624661ca753ecf1be0a3e4f1c9f6603c88e61543", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "patch": "@@ -3806,9 +3806,9 @@ package body Exp_Attr is\n       ---------\n \n       when Attribute_Old => Old : declare\n-         Tnn     : constant Entity_Id := Make_Temporary (Loc, 'T', Pref);\n-         Subp    : Node_Id;\n          Asn_Stm : Node_Id;\n+         Subp    : Node_Id;\n+         Temp    : Entity_Id;\n \n       begin\n          --  If assertions are disabled, no need to create the declaration\n@@ -3818,41 +3818,46 @@ package body Exp_Attr is\n             return;\n          end if;\n \n-         --  Find the nearest subprogram body, ignoring _Preconditions\n+         Temp := Make_Temporary (Loc, 'T', Pref);\n+\n+         --  Climb the parent chain looking for subprogram _Postconditions\n \n          Subp := N;\n-         loop\n-            Subp := Parent (Subp);\n+         while Present (Subp) loop\n             exit when Nkind (Subp) = N_Subprogram_Body\n-              and then Chars (Defining_Entity (Subp)) /= Name_uPostconditions;\n+              and then Chars (Defining_Entity (Subp)) = Name_uPostconditions;\n+\n+            Subp := Parent (Subp);\n          end loop;\n \n-         --  Insert the initialized object declaration at the start of the\n-         --  subprogram's declarations.\n+         --  'Old can only appear in a postcondition, the generated body of\n+         --  _Postconditions must be in the tree.\n+\n+         pragma Assert (Present (Subp));\n+\n+         --  Generate:\n+         --    Temp : constant <Pref type> := <Pref>;\n \n          Asn_Stm :=\n            Make_Object_Declaration (Loc,\n-             Defining_Identifier => Tnn,\n+             Defining_Identifier => Temp,\n              Constant_Present    => True,\n              Object_Definition   => New_Occurrence_Of (Etype (N), Loc),\n              Expression          => Pref);\n \n-         --  Push the subprogram's scope, so that the object will be analyzed\n-         --  in that context (rather than the context of the Precondition\n-         --  subprogram) and will have its Scope set properly.\n+         --  Push the scope of the related subprogram where _Postcondition\n+         --  resides as this ensures that the object will be analyzed in the\n+         --  proper context.\n \n-         if Present (Corresponding_Spec (Subp)) then\n-            Push_Scope (Corresponding_Spec (Subp));\n-         else\n-            Push_Scope (Defining_Entity (Subp));\n-         end if;\n+         Push_Scope (Scope (Defining_Entity (Subp)));\n \n-         if Is_Empty_List (Declarations (Subp)) then\n-            Set_Declarations (Subp, New_List (Asn_Stm));\n-            Analyze (Asn_Stm);\n-         else\n-            Insert_Action (First (Declarations (Subp)), Asn_Stm);\n-         end if;\n+         --  The object declaration is inserted before the body of subprogram\n+         --  _Postconditions. This ensures that any precondition-like actions\n+         --  are still executed before any parameter values are captured and\n+         --  the multiple 'Old occurrences appear in order of declaration.\n+\n+         Insert_Before_And_Analyze (Subp, Asn_Stm);\n+         Pop_Scope;\n \n          --  Ensure that the prefix of attribute 'Old is valid. The check must\n          --  be inserted after the expansion of the attribute has taken place\n@@ -3862,9 +3867,7 @@ package body Exp_Attr is\n             Ensure_Valid (Pref);\n          end if;\n \n-         Pop_Scope;\n-\n-         Rewrite (N, New_Occurrence_Of (Tnn, Loc));\n+         Rewrite (N, New_Occurrence_Of (Temp, Loc));\n       end Old;\n \n       ----------------------"}, {"sha": "7ee0115ef9c5d049e92b8f9f0c33db5e7788a298", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "patch": "@@ -8911,26 +8911,46 @@ package body Exp_Ch6 is\n          Stmts   : List_Id;\n          Result  : Entity_Id)\n       is\n-         procedure Insert_After_Last_Declaration (Stmt : Node_Id);\n-         --  Insert node Stmt after the last declaration of the subprogram body\n+         procedure Insert_Before_First_Source_Declaration (Stmt : Node_Id);\n+         --  Insert node Stmt before the first source declaration of the\n+         --  related subprogram's body. If no such declaration exists, Stmt\n+         --  becomes the last declaration.\n \n-         -----------------------------------\n-         -- Insert_After_Last_Declaration --\n-         -----------------------------------\n+         --------------------------------------------\n+         -- Insert_Before_First_Source_Declaration --\n+         --------------------------------------------\n \n-         procedure Insert_After_Last_Declaration (Stmt : Node_Id) is\n-            Decls : List_Id := Declarations (N);\n+         procedure Insert_Before_First_Source_Declaration (Stmt : Node_Id) is\n+            Decls : constant List_Id := Declarations (N);\n+            Decl  : Node_Id;\n \n          begin\n+            --  Inspect the declarations of the related subprogram body looking\n+            --  for the first source declaration.\n+\n+            if Present (Decls) then\n+               Decl := First (Decls);\n+               while Present (Decl) loop\n+                  if Comes_From_Source (Decl) then\n+                     Insert_Before (Decl, Stmt);\n+                     return;\n+                  end if;\n+\n+                  Next (Decl);\n+               end loop;\n+\n+               --  If we get there, then the subprogram body lacks any source\n+               --  declarations. The body of _Postconditions now acts as the\n+               --  last declaration.\n+\n+               Append (Stmt, Decls);\n+\n             --  Ensure that the body has a declaration list\n \n-            if No (Decls) then\n-               Decls := New_List;\n-               Set_Declarations (N, Decls);\n+            else\n+               Set_Declarations (N, New_List (Stmt));\n             end if;\n-\n-            Append_To (Decls, Stmt);\n-         end Insert_After_Last_Declaration;\n+         end Insert_Before_First_Source_Declaration;\n \n          --  Local variables\n \n@@ -8965,9 +8985,9 @@ package body Exp_Ch6 is\n                   New_Reference_To (Etype (Result), Loc)));\n          end if;\n \n-         --  Insert _Postconditions after the last declaration of the body.\n-         --  This ensures that the body will not cause any premature freezing\n-         --  as it may mention types:\n+         --  Insert _Postconditions before the first source declaration of the\n+         --  body. This ensures that the body will not cause any premature\n+         --  freezing as it may mention types:\n \n          --    procedure Proc (Obj : Array_Typ) is\n          --       procedure _postconditions is\n@@ -8983,7 +9003,7 @@ package body Exp_Ch6 is\n          --  order reference. The body of _Postconditions must be placed after\n          --  the declaration of Temp to preserve correct visibility.\n \n-         Insert_After_Last_Declaration (\n+         Insert_Before_First_Source_Declaration (\n            Make_Subprogram_Body (Loc,\n              Specification              =>\n                Make_Procedure_Specification (Loc,"}, {"sha": "dd5766b469eefad513dbf49794381308102c2583", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "patch": "@@ -5752,6 +5752,13 @@ package body Exp_Util is\n          return Make_Null_Statement (Loc);\n       end if;\n \n+      --  Do not generate a check within an internal subprogram (stream\n+      --  functions and the like, including including predicate functions).\n+\n+      if Within_Internal_Subprogram then\n+         return Make_Null_Statement (Loc);\n+      end if;\n+\n       --  Compute proper name to use, we need to get this right so that the\n       --  right set of check policies apply to the Check pragma we are making.\n \n@@ -8213,6 +8220,24 @@ package body Exp_Util is\n       return False;\n    end Within_Case_Or_If_Expression;\n \n+   --------------------------------\n+   -- Within_Internal_Subprogram --\n+   --------------------------------\n+\n+   function Within_Internal_Subprogram return Boolean is\n+      S : Entity_Id;\n+\n+   begin\n+      S := Current_Scope;\n+      while Present (S) and then not Is_Subprogram (S) loop\n+         S := Scope (S);\n+      end loop;\n+\n+      return Present (S)\n+        and then Get_TSS_Name (S) /= TSS_Null\n+        and then not Is_Predicate_Function (S);\n+   end Within_Internal_Subprogram;\n+\n    ----------------------------\n    -- Wrap_Cleanup_Procedure --\n    ----------------------------"}, {"sha": "8fa66a9eae1c4ed4985b559dce7035407e054def", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "patch": "@@ -834,6 +834,11 @@ package Exp_Util is\n    function Within_Case_Or_If_Expression (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N is within a case or an if expression\n \n+   function Within_Internal_Subprogram  return Boolean;\n+   --  Indicates that some expansion is taking place within the body of a\n+   --  predefined primitive operation. Some expansion activity (e.g. predicate\n+   --  checks) is disabled in such.\n+\n    procedure Wrap_Cleanup_Procedure (N : Node_Id);\n    --  Given an N_Subprogram_Body node, this procedure adds an Abort_Defer call\n    --  at the start of the statement sequence, and an Abort_Undefer call at the"}, {"sha": "1cea3163d7f0ad98337d6068ee668754d1434289", "filename": "gcc/ada/prj-util.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -469,7 +469,7 @@ package body Prj.Util is\n          if Sid.Kind = Spec\n            and then not Sid.Locally_Removed\n            and then (Project.Standalone_Library = No\n-                      or else Sid.Declared_In_Interfaces)\n+                     or else Sid.Declared_In_Interfaces)\n          then\n             Action (Sid);\n "}, {"sha": "5607502a34c2a6ce2c01c50b38b6e1ad7bff7982", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "patch": "@@ -1353,7 +1353,7 @@ package Prj is\n       --  Indicate that this is a Standalone Library Project File\n \n       Lib_Interface_ALIs : String_List_Id := Nil_String;\n-      --  For Standalone Library Project Files, list of Interface ALI files.\n+      --  For Standalone Library Project Files, list of Interface ALI files\n \n       Other_Interfaces : String_List_Id := Nil_String;\n       --  List of non unit based sources in attribute Interfaces"}, {"sha": "c603419398004db8c5b83b7806f5d97444205aa6", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "patch": "@@ -6686,6 +6686,7 @@ package body Sem_Ch13 is\n             --  Build function declaration\n \n             Set_Ekind (SId, E_Function);\n+            Set_Is_Internal (SId);\n             Set_Is_Predicate_Function (SId);\n             Set_Predicate_Function (Typ, SId);\n \n@@ -9429,9 +9430,14 @@ package body Sem_Ch13 is\n       Inside_Freezing_Actions := Inside_Freezing_Actions - 1;\n \n       --  If we have a type with predicates, build predicate function. This\n-      --  is not needed in the generic casee\n+      --  is not needed in the generic casee, and is not needed within TSS\n+      --  subprograms and other predefined primitives.\n \n-      if Non_Generic_Case and then Is_Type (E) and then Has_Predicates (E) then\n+      if Non_Generic_Case\n+        and then Is_Type (E)\n+        and then Has_Predicates (E)\n+        and then not Within_Internal_Subprogram\n+      then\n          Build_Predicate_Functions (E, N);\n       end if;\n "}, {"sha": "04759e708134777af7ccdad11dbb8ba38f2739a3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 95, "deletions": 44, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1e62e3de4fd41f8c8b813657b638d0c8695dbf/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8e1e62e3de4fd41f8c8b813657b638d0c8695dbf", "patch": "@@ -1597,6 +1597,7 @@ package body Sem_Prag is\n \n       Clause      : Node_Id;\n       Errors      : Nat;\n+      Expr        : Node_Id;\n       Last_Clause : Node_Id;\n       Subp_Decl   : Node_Id;\n \n@@ -1653,72 +1654,122 @@ package body Sem_Prag is\n \n       --  Dependency clauses appear as component associations of an aggregate\n \n-      elsif Nkind (Clause) = N_Aggregate\n-        and then Present (Component_Associations (Clause))\n-      then\n-         Last_Clause := Last (Component_Associations (Clause));\n+      elsif Nkind (Clause) = N_Aggregate then\n \n-         --  Gather all states, variables and formal parameters that the\n-         --  subprogram may depend on. These items are obtained from the\n-         --  parameter profile or pragma [Refined_]Global (if available).\n+         --  The aggregate should not have an expression list because a clause\n+         --  is always interpreted as a component association. The only way an\n+         --  expression list can sneak in is by adding extra parenthesis around\n+         --  the individual clauses:\n \n-         Collect_Subprogram_Inputs_Outputs\n-           (Subp_Id      => Subp_Id,\n-            Subp_Inputs  => Subp_Inputs,\n-            Subp_Outputs => Subp_Outputs,\n-            Global_Seen  => Global_Seen);\n+         --    Depends  (Output => Input)   --  proper form\n+         --    Depends ((Output => Input))  --  extra parenthesis\n \n-         --  Ensure that the formal parameters are visible when analyzing all\n-         --  clauses. This falls out of the general rule of aspects pertaining\n-         --  to subprogram declarations. Skip the installation for subprogram\n-         --  bodies because the formals are already visible.\n+         --  Since the extra parenthesis are not allowed by the syntax of the\n+         --  pragma, flag them now to avoid emitting misleading errors down the\n+         --  line.\n \n-         if not In_Open_Scopes (Spec_Id) then\n-            Restore_Scope := True;\n-            Push_Scope (Spec_Id);\n-            Install_Formals (Spec_Id);\n+         if Present (Expressions (Clause)) then\n+            Expr := First (Expressions (Clause));\n+            while Present (Expr) loop\n+\n+               --  A dependency clause surrounded by extra parenthesis appears\n+               --  as an aggregate of component associations with an optional\n+               --  Paren_Count set.\n+\n+               if Nkind (Expr) = N_Aggregate\n+                 and then Present (Component_Associations (Expr))\n+               then\n+                  Error_Msg_N\n+                    (\"dependency clause contains extra parenthesis\", Expr);\n+\n+               --  Otherwise the expression is a malformed construct\n+\n+               else\n+                  Error_Msg_N (\"malformed dependency clause\", Expr);\n+               end if;\n+\n+               Next (Expr);\n+            end loop;\n+\n+            --  Do not attempt to perform analysis of syntactically illegal\n+            --  clauses as this will lead to misleading errors.\n+\n+            return;\n          end if;\n \n-         Clause := First (Component_Associations (Clause));\n-         while Present (Clause) loop\n-            Errors := Serious_Errors_Detected;\n+         if Present (Component_Associations (Clause)) then\n+            Last_Clause := Last (Component_Associations (Clause));\n \n-            --  Normalization may create extra clauses that contain replicated\n-            --  input and output names. There is no need to reanalyze them.\n+            --  Gather all states, variables and formal parameters that the\n+            --  subprogram may depend on. These items are obtained from the\n+            --  parameter profile or pragma [Refined_]Global (if available).\n \n-            if not Analyzed (Clause) then\n-               Set_Analyzed (Clause);\n+            Collect_Subprogram_Inputs_Outputs\n+              (Subp_Id      => Subp_Id,\n+               Subp_Inputs  => Subp_Inputs,\n+               Subp_Outputs => Subp_Outputs,\n+               Global_Seen  => Global_Seen);\n \n-               Analyze_Dependency_Clause\n-                 (Clause  => Clause,\n-                  Is_Last => Clause = Last_Clause);\n+            --  Ensure that the formal parameters are visible when analyzing\n+            --  all clauses. This falls out of the general rule of aspects\n+            --  pertaining to subprogram declarations. Skip the installation\n+            --  for subprogram bodies because the formals are already visible.\n+\n+            if not In_Open_Scopes (Spec_Id) then\n+               Restore_Scope := True;\n+               Push_Scope (Spec_Id);\n+               Install_Formals (Spec_Id);\n             end if;\n \n-            --  Do not normalize an erroneous clause because the inputs and/or\n-            --  outputs may denote illegal items.\n+            Clause := First (Component_Associations (Clause));\n+            while Present (Clause) loop\n+               Errors := Serious_Errors_Detected;\n+\n+               --  Normalization may create extra clauses that contain\n+               --  replicated input and output names. There is no need to\n+               --  reanalyze them.\n+\n+               if not Analyzed (Clause) then\n+                  Set_Analyzed (Clause);\n+\n+                  Analyze_Dependency_Clause\n+                    (Clause  => Clause,\n+                     Is_Last => Clause = Last_Clause);\n+               end if;\n+\n+               --  Do not normalize an erroneous clause because the inputs\n+               --  and/or outputs may denote illegal items.\n+\n+               if Serious_Errors_Detected = Errors then\n+                  Normalize_Clause (Clause);\n+               end if;\n+\n+               Next (Clause);\n+            end loop;\n \n-            if Serious_Errors_Detected = Errors then\n-               Normalize_Clause (Clause);\n+            if Restore_Scope then\n+               End_Scope;\n             end if;\n \n-            Next (Clause);\n-         end loop;\n+            --  Verify that every input or output of the subprogram appear in a\n+            --  dependency.\n \n-         if Restore_Scope then\n-            End_Scope;\n-         end if;\n+            Check_Usage (Subp_Inputs, All_Inputs_Seen, True);\n+            Check_Usage (Subp_Outputs, All_Outputs_Seen, False);\n+            Check_Function_Return;\n \n-         --  Verify that every input or output of the subprogram appear in a\n-         --  dependency.\n+         --  The dependency list is malformed\n \n-         Check_Usage (Subp_Inputs, All_Inputs_Seen, True);\n-         Check_Usage (Subp_Outputs, All_Outputs_Seen, False);\n-         Check_Function_Return;\n+         else\n+            Error_Msg_N (\"malformed dependency relation\", Clause);\n+            return;\n+         end if;\n \n       --  The top level dependency relation is malformed\n \n       else\n          Error_Msg_N (\"malformed dependency relation\", Clause);\n+         return;\n       end if;\n \n       --  Ensure that a state and a corresponding constituent do not appear"}]}