{"sha": "691aed8cce63e0211c26f1b5f905c7c5a37c4a90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkxYWVkOGNjZTYzZTAyMTFjMjZmMWI1ZjkwNWM3YzVhMzdjNGE5MA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-16T18:10:20Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-16T18:10:20Z"}, "message": "tree-ssa-copy.c (copy_prop_visit_assignment): Clean up by folding a COND_EXPR_COND in a nondestructive manner.\n\n\t* tree-ssa-copy.c (copy_prop_visit_assignment): Clean up by\n\tfolding a COND_EXPR_COND in a nondestructive manner.\n\nFrom-SVN: r99782", "tree": {"sha": "190b74b60da193369716ce267136a6cac2bec1b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/190b74b60da193369716ce267136a6cac2bec1b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/691aed8cce63e0211c26f1b5f905c7c5a37c4a90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/691aed8cce63e0211c26f1b5f905c7c5a37c4a90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/691aed8cce63e0211c26f1b5f905c7c5a37c4a90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/691aed8cce63e0211c26f1b5f905c7c5a37c4a90/comments", "author": null, "committer": null, "parents": [{"sha": "fe2d45c77f86ebbed8a1ef8c6c59e61daace584f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe2d45c77f86ebbed8a1ef8c6c59e61daace584f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe2d45c77f86ebbed8a1ef8c6c59e61daace584f"}], "stats": {"total": 55, "additions": 22, "deletions": 33}, "files": [{"sha": "a576233c1f43f037e1b2d8aedf205e649c42dd70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691aed8cce63e0211c26f1b5f905c7c5a37c4a90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691aed8cce63e0211c26f1b5f905c7c5a37c4a90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=691aed8cce63e0211c26f1b5f905c7c5a37c4a90", "patch": "@@ -1,3 +1,8 @@\n+2005-05-16  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-ssa-copy.c (copy_prop_visit_assignment): Clean up by\n+\tfolding a COND_EXPR_COND in a nondestructive manner.\n+\n 2005-05-16  Fariborz Jahanian <fjahanian@apple.com>\n \n \t* config/rs6000/altivec.md (altivec_vmrghb, altivec_vmrghh, "}, {"sha": "5f4033d3a9b0c7c13364952340a2293d5790ac71", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 17, "deletions": 33, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691aed8cce63e0211c26f1b5f905c7c5a37c4a90/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691aed8cce63e0211c26f1b5f905c7c5a37c4a90/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=691aed8cce63e0211c26f1b5f905c7c5a37c4a90", "patch": "@@ -594,32 +594,18 @@ copy_prop_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n {\n   enum ssa_prop_result retval;\n   tree cond;\n-  use_operand_p use_p;\n-  ssa_op_iter iter;\n-  unsigned num;\n-\n \n   cond = COND_EXPR_COND (stmt);\n   retval = SSA_PROP_VARYING;\n-  num = NUM_SSA_OPERANDS (stmt, SSA_OP_USE);\n \n   /* The only conditionals that we may be able to compute statically\n-     are predicates involving at least one SSA_NAME.  */\n+     are predicates involving two SSA_NAMEs.  */\n   if (COMPARISON_CLASS_P (cond)\n-      && num >= 1)\n+      && TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME\n+      && TREE_CODE (TREE_OPERAND (cond, 1)) == SSA_NAME)\n     {\n-      unsigned i;\n-      tree *orig;\n-\n-      /* Save the original operands.  */\n-      orig = xmalloc (sizeof (tree) * num);\n-      i = 0;\n-      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n-\t{\n-\t  tree use = USE_FROM_PTR (use_p);\n-\t  orig[i++] = use;\n-\t  SET_USE (use_p, get_last_copy_of (use));\n-\t}\n+      tree op0 = get_last_copy_of (TREE_OPERAND (cond, 0));\n+      tree op1 = get_last_copy_of (TREE_OPERAND (cond, 1));\n \n       /* See if we can determine the predicate's value.  */\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -629,22 +615,20 @@ copy_prop_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n \t  print_generic_stmt (dump_file, cond, 0);\n \t}\n \n-      /* We can fold COND only and get a useful result only when we\n-\t have the same SSA_NAME on both sides of a comparison\n-\t operator.  */\n-      if (TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME\n-\t  && TREE_OPERAND (cond, 0) == TREE_OPERAND (cond, 1))\n+      /* We can fold COND and get a useful result only when we have\n+\t the same SSA_NAME on both sides of a comparison operator.  */\n+      if (op0 == op1)\n \t{\n-\t  *taken_edge_p = find_taken_edge (bb_for_stmt (stmt), fold (cond));\n-\t  if (*taken_edge_p)\n-\t    retval = SSA_PROP_INTERESTING;\n+\t  tree folded_cond = fold_binary (TREE_CODE (cond), boolean_type_node,\n+\t\t\t\t\t  op0, op1);\n+\t  if (folded_cond)\n+\t    {\n+\t      basic_block bb = bb_for_stmt (stmt);\n+\t      *taken_edge_p = find_taken_edge (bb, folded_cond);\n+\t      if (*taken_edge_p)\n+\t\tretval = SSA_PROP_INTERESTING;\n+\t    }\n \t}\n-\n-      /* Restore the original operands.  */\n-      i = 0;\n-      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n-\tSET_USE (use_p, orig[i++]);\n-      free (orig);\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS) && *taken_edge_p)"}]}