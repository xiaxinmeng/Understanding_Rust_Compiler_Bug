{"sha": "57d1dd8704212031da1e646aa672720262aa4352", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdkMWRkODcwNDIxMjAzMWRhMWU2NDZhYTY3MjcyMDI2MmFhNDM1Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-12T03:54:11Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-12T03:54:11Z"}, "message": "gimplify.c (struct gimplify_init_ctor_preeval_data): New.\n\n        * gimplify.c (struct gimplify_init_ctor_preeval_data): New.\n        (gimplify_init_ctor_preeval_1): New.\n        (gimplify_init_ctor_preeval): New.\n        (gimplify_init_ctor_eval): New.\n        (gimplify_init_constructor): Use them.  Always gimplify the LHS\n        object first.\n\nFrom-SVN: r85845", "tree": {"sha": "fb9952a6f24661bff504ccdae2f97f00e333074e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb9952a6f24661bff504ccdae2f97f00e333074e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57d1dd8704212031da1e646aa672720262aa4352", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d1dd8704212031da1e646aa672720262aa4352", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57d1dd8704212031da1e646aa672720262aa4352", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d1dd8704212031da1e646aa672720262aa4352/comments", "author": null, "committer": null, "parents": [{"sha": "6e40af1ab06b897d05a0f980156406ac5635b1e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e40af1ab06b897d05a0f980156406ac5635b1e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e40af1ab06b897d05a0f980156406ac5635b1e7"}], "stats": {"total": 252, "additions": 199, "deletions": 53}, "files": [{"sha": "2ab0e90305db0ed0543377792938b6c092082a9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d1dd8704212031da1e646aa672720262aa4352/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d1dd8704212031da1e646aa672720262aa4352/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57d1dd8704212031da1e646aa672720262aa4352", "patch": "@@ -1,3 +1,12 @@\n+2004-08-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* gimplify.c (struct gimplify_init_ctor_preeval_data): New.\n+\t(gimplify_init_ctor_preeval_1): New.\n+\t(gimplify_init_ctor_preeval): New.\n+\t(gimplify_init_ctor_eval): New.\n+\t(gimplify_init_constructor): Use them.  Always gimplify the LHS\n+\tobject first.\n+\n 2004-08-12  Ziemowit Laski  <zlaski@apple.com>\n \n \t(This patch is part of merge of objc-improvements-branch"}, {"sha": "21d8f453e22101b4c9171582cd9a29187108b4ae", "filename": "gcc/gimplify.c", "status": "modified", "additions": 190, "deletions": 53, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d1dd8704212031da1e646aa672720262aa4352/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d1dd8704212031da1e646aa672720262aa4352/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=57d1dd8704212031da1e646aa672720262aa4352", "patch": "@@ -2363,6 +2363,167 @@ gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value)\n   return GS_OK;\n }\n \n+/* A subroutine of gimplify_init_ctor_preeval.  Called via walk_tree,\n+   determine, cautiously, if a CONSTRUCTOR overlaps the lhs of an\n+   assignment.  Returns non-null if we detect a potential overlap.  */\n+\n+struct gimplify_init_ctor_preeval_data\n+{\n+  /* The base decl of the lhs object.  May be NULL, in which case we\n+     have to assume the lhs is indirect.  */\n+  tree lhs_base_decl;\n+\n+  /* The alias set of the lhs object.  */\n+  int lhs_alias_set;\n+};\n+\n+static tree\n+gimplify_init_ctor_preeval_1 (tree *tp, int *walk_subtrees, void *xdata)\n+{\n+  struct gimplify_init_ctor_preeval_data *data\n+    = (struct gimplify_init_ctor_preeval_data *) xdata;\n+  tree t = *tp;\n+\n+  /* If we find the base object, obviously we have overlap.  */\n+  if (data->lhs_base_decl == t)\n+    return t;\n+\n+  /* If the constructor component is indirect, determine if we have a\n+     potential overlap with the lhs.  The only bits of information we\n+     have to go on at this point are addressability and alias sets.  */\n+  if (TREE_CODE (t) == INDIRECT_REF\n+      && (!data->lhs_base_decl || TREE_ADDRESSABLE (data->lhs_base_decl))\n+      && alias_sets_conflict_p (data->lhs_alias_set, get_alias_set (t)))\n+    return t;\n+\n+  if (DECL_P (t) || TYPE_P (t))\n+    *walk_subtrees = 0;\n+  return NULL;\n+}\n+\n+/* A subroutine of gimplify_init_constructor.  Pre-evaluate *EXPR_P,\n+   force values that overlap with the lhs (as described by *DATA)\n+   into temporaries.  */\n+\n+static void\n+gimplify_init_ctor_preeval (tree *expr_p, tree *pre_p, tree *post_p,\n+\t\t\t    struct gimplify_init_ctor_preeval_data *data)\n+{\n+  enum gimplify_status one;\n+\n+  /* If the value is invariant, then there's nothing to pre-evaluate.\n+     But ensure it doesn't have any side-effects since a SAVE_EXPR is\n+     invariant but has side effects and might contain a reference to\n+     the object we're initializing.  */\n+  if (TREE_INVARIANT (*expr_p) && !TREE_SIDE_EFFECTS (*expr_p))\n+    return;\n+\n+  /* If the type has non-trivial constructors, we can't pre-evaluate.  */\n+  if (TREE_ADDRESSABLE (TREE_TYPE (*expr_p)))\n+    return;\n+\n+  /* Recurse for nested constructors.  */\n+  if (TREE_CODE (*expr_p) == CONSTRUCTOR)\n+    {\n+      tree list;\n+      for (list = CONSTRUCTOR_ELTS (*expr_p); list ; list = TREE_CHAIN (list))\n+\tgimplify_init_ctor_preeval (&TREE_VALUE (list), pre_p, post_p, data);\n+      return;\n+    }\n+\n+  /* We can't preevaluate if the type contains a placeholder.  */\n+  if (type_contains_placeholder_p (TREE_TYPE (*expr_p)))\n+    return;\n+\n+  /* Gimplify the constructor element to something appropriate for the rhs\n+     of a MODIFY_EXPR.  Given that we know the lhs is an aggregate, we know\n+     the gimplifier will consider this a store to memory.  Doing this \n+     gimplification now means that we won't have to deal with complicated\n+     language-specific trees, nor trees like SAVE_EXPR that can induce\n+     exponential search behaviour.  */\n+  one = gimplify_expr (expr_p, pre_p, post_p, is_gimple_mem_rhs, fb_rvalue);\n+  if (one == GS_ERROR)\n+    {\n+      *expr_p = NULL;\n+      return;\n+    }\n+\n+  /* If we gimplified to a bare decl, we can be sure that it doesn't overlap\n+     with the lhs, since \"a = { .x=a }\" doesn't make sense.  This will\n+     always be true for all scalars, since is_gimple_mem_rhs insists on a\n+     temporary variable for them.  */\n+  if (DECL_P (*expr_p))\n+    return;\n+\n+  /* If this is of variable size, we have no choice but to assume it doesn't\n+     overlap since we can't make a temporary for it.  */\n+  if (!TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (*expr_p))))\n+    return;\n+\n+  /* Otherwise, we must search for overlap ...  */\n+  if (!walk_tree (expr_p, gimplify_init_ctor_preeval_1, data, NULL))\n+    return;\n+\n+  /* ... and if found, force the value into a temporary.  */\n+  *expr_p = get_formal_tmp_var (*expr_p, pre_p);\n+}\n+\n+/* A subroutine of gimplify_init_constructor.  Generate individual\n+   MODIFY_EXPRs for a CONSTRUCTOR.  OBJECT is the LHS against which the\n+   assignments should happen.  LIST is the CONSTRUCTOR_ELTS of the\n+   CONSTRUCTOR.  CLEARED is true if the entire LHS object has been\n+   zeroed first.  */\n+\n+static void\n+gimplify_init_ctor_eval (tree object, tree list, tree *pre_p, bool cleared)\n+{\n+  tree array_elt_type = NULL;\n+\n+  if (TREE_CODE (TREE_TYPE (object)) == ARRAY_TYPE)\n+    array_elt_type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (object)));\n+\n+  for (; list; list = TREE_CHAIN (list))\n+    {\n+      tree purpose, value, cref, init;\n+\n+      purpose = TREE_PURPOSE (list);\n+      value = TREE_VALUE (list);\n+\n+      /* NULL values are created above for gimplification errors.  */\n+      if (value == NULL)\n+\tcontinue;\n+\n+      if (cleared && initializer_zerop (value))\n+\tcontinue;\n+\n+      if (array_elt_type)\n+\t{\n+\t  /* ??? Here's to hoping the front end fills in all of the indicies,\n+\t     so we don't have to figure out what's missing ourselves.  */\n+\t  if (!purpose)\n+\t    abort ();\n+\t  /* ??? Need to handle this.  */\n+\t  if (TREE_CODE (purpose) == RANGE_EXPR)\n+\t    abort ();\n+\n+\t  cref = build (ARRAY_REF, array_elt_type, unshare_expr (object),\n+\t\t\tpurpose, NULL_TREE, NULL_TREE);\n+\t}\n+      else\n+\tcref = build (COMPONENT_REF, TREE_TYPE (purpose),\n+\t\t      unshare_expr (object), purpose, NULL_TREE);\n+\n+      if (TREE_CODE (value) == CONSTRUCTOR)\n+\tgimplify_init_ctor_eval (cref, CONSTRUCTOR_ELTS (value),\n+\t\t\t\t pre_p, cleared);\n+      else\n+\t{\n+\t  init = build (MODIFY_EXPR, TREE_TYPE (cref), cref, value);\n+\t  gimplify_and_add (init, pre_p);\n+\t}\n+    }\n+}\n+\n /* A subroutine of gimplify_modify_expr.  Break out elements of a\n    CONSTRUCTOR used as an initializer into separate MODIFY_EXPRs.\n \n@@ -2374,7 +2535,7 @@ static enum gimplify_status\n gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t\t\t   tree *post_p, bool want_value)\n {\n-  tree object = TREE_OPERAND (*expr_p, 0);\n+  tree object;\n   tree ctor = TREE_OPERAND (*expr_p, 1);\n   tree type = TREE_TYPE (ctor);\n   enum gimplify_status ret;\n@@ -2383,6 +2544,12 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n   if (TREE_CODE (ctor) != CONSTRUCTOR)\n     return GS_UNHANDLED;\n \n+  ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n+\t\t       is_gimple_lvalue, fb_lvalue);\n+  if (ret == GS_ERROR)\n+    return ret;\n+  object = TREE_OPERAND (*expr_p, 0);\n+\n   elt_list = CONSTRUCTOR_ELTS (ctor);\n \n   ret = GS_ALL_DONE;\n@@ -2393,27 +2560,19 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n     case QUAL_UNION_TYPE:\n     case ARRAY_TYPE:\n       {\n-\tHOST_WIDE_INT i, num_elements, num_nonzero_elements;\n+\tstruct gimplify_init_ctor_preeval_data preeval_data;\n+\tHOST_WIDE_INT num_elements, num_nonzero_elements;\n \tHOST_WIDE_INT num_nonconstant_elements;\n \tbool cleared;\n \n \t/* Aggregate types must lower constructors to initialization of\n \t   individual elements.  The exception is that a CONSTRUCTOR node\n \t   with no elements indicates zero-initialization of the whole.  */\n \tif (elt_list == NULL)\n-\t  {\n-\t    if (want_value)\n-\t      {\n-\t\t*expr_p = object;\n-\t\treturn GS_OK;\n-\t      }\n-\t    else\n-\t      return GS_UNHANDLED;\n-\t  }\n+\t  break;\n \n \tcategorize_ctor_elements (ctor, &num_nonzero_elements,\n \t\t\t\t  &num_nonconstant_elements);\n-\tnum_elements = count_type_elements (TREE_TYPE (ctor));\n \n \t/* If a const aggregate variable is being initialized, then it\n \t   should never be a lose to promote the variable to be static.  */\n@@ -2468,6 +2627,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t    if (size > 0 && !can_move_by_pieces (size, align))\n \t      {\n \t\ttree new = create_tmp_var_raw (type, \"C\");\n+\n \t\tgimple_add_tmp_var (new);\n \t\tTREE_STATIC (new) = 1;\n \t\tTREE_READONLY (new) = 1;\n@@ -2480,7 +2640,11 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t        walk_tree (&DECL_INITIAL (new), force_labels_r, NULL, NULL);\n \n \t\tTREE_OPERAND (*expr_p, 1) = new;\n-\t\tbreak;\n+\n+\t\t/* This is no longer an assignment of a CONSTRUCTOR, but\n+\t\t   we still may have processing to do on the LHS.  So\n+\t\t   pretend we didn't do anything here to let that happen.  */\n+\t\treturn GS_UNHANDLED;\n \t      }\n \t  }\n \n@@ -2491,6 +2655,8 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t   parts in, then generate code for the non-constant parts.  */\n \t/* TODO.  There's code in cp/typeck.c to do this.  */\n \n+\tnum_elements = count_type_elements (TREE_TYPE (ctor));\n+\n \t/* If there are \"lots\" of zeros, then block clear the object first.  */\n \tcleared = false;\n \tif (num_elements - num_nonzero_elements > CLEAR_RATIO\n@@ -2510,60 +2676,31 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t\ttree nelts = array_type_nelts (type);\n \t\tif (!host_integerp (nelts, 1)\n \t\t    || tree_low_cst (nelts, 1) + 1 != len)\n-\t\t  cleared = 1;;\n+\t\t  cleared = true;\n \t      }\n \t    else if (len != fields_length (type))\n-\t      cleared = 1;\n+\t      cleared = true;\n \t  }\n \n \tif (cleared)\n \t  {\n \t    /* Zap the CONSTRUCTOR element list, which simplifies this case.\n \t       Note that we still have to gimplify, in order to handle the\n-\t       case of variable sized types.  Make an unshared copy of\n-\t       OBJECT before that so we can match a PLACEHOLDER_EXPR to it\n-\t       later, if needed.  */\n+\t       case of variable sized types.  Avoid shared tree structures.  */\n \t    CONSTRUCTOR_ELTS (ctor) = NULL_TREE;\n-\t    object = unshare_expr (TREE_OPERAND (*expr_p, 0));\n+\t    object = unshare_expr (object);\n \t    gimplify_stmt (expr_p);\n \t    append_to_statement_list (*expr_p, pre_p);\n \t  }\n \n-\tfor (i = 0; elt_list; i++, elt_list = TREE_CHAIN (elt_list))\n-\t  {\n-\t    tree purpose, value, cref, init;\n-\n-\t    purpose = TREE_PURPOSE (elt_list);\n-\t    value = TREE_VALUE (elt_list);\n-\n-\t    if (cleared && initializer_zerop (value))\n-\t      continue;\n+\tpreeval_data.lhs_base_decl = get_base_address (object);\n+\tif (!DECL_P (preeval_data.lhs_base_decl))\n+\t  preeval_data.lhs_base_decl = NULL;\n+\tpreeval_data.lhs_alias_set = get_alias_set (object);\n \n-\t    if (TREE_CODE (type) == ARRAY_TYPE)\n-\t      {\n-\t\ttree t = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (object)));\n-\n-\t\t/* ??? Here's to hoping the front end fills in all of the\n-\t\t   indicies, so we don't have to figure out what's missing\n-\t\t   ourselves.  */\n-\t\tif (!purpose)\n-\t\t  abort ();\n-\t\t/* ??? Need to handle this.  */\n-\t\tif (TREE_CODE (purpose) == RANGE_EXPR)\n-\t\t  abort ();\n-\n-\t\tcref = build (ARRAY_REF, t, unshare_expr (object), purpose,\n-\t\t\t      NULL_TREE, NULL_TREE);\n-\t      }\n-\t    else\n-\t      cref = build (COMPONENT_REF, TREE_TYPE (purpose),\n-\t\t\t    unshare_expr (object), purpose, NULL_TREE);\n-\n-\t    init = build (MODIFY_EXPR, TREE_TYPE (purpose), cref, value);\n-\n-\t    /* Each member initialization is a full-expression.  */\n-\t    gimplify_and_add (init, pre_p);\n-\t  }\n+\tgimplify_init_ctor_preeval (&TREE_OPERAND (*expr_p, 1),\n+\t\t\t\t    pre_p, post_p, &preeval_data);\n+\tgimplify_init_ctor_eval (object, elt_list, pre_p, cleared);\n \n \t*expr_p = NULL_TREE;\n       }"}]}