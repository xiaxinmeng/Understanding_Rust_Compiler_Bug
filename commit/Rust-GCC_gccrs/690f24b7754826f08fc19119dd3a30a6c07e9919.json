{"sha": "690f24b7754826f08fc19119dd3a30a6c07e9919", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkwZjI0Yjc3NTQ4MjZmMDhmYzE5MTE5ZGQzYTMwYTZjMDdlOTkxOQ==", "commit": {"author": {"name": "Jose E. Marchesi", "email": "jose.marchesi@oracle.com", "date": "2016-06-06T11:40:02Z"}, "committer": {"name": "Jose E. Marchesi", "email": "jemarch@gcc.gnu.org", "date": "2016-06-06T11:40:02Z"}, "message": "sparc: support for the SPARC M7 and VIS 4.0\n    \ngcc/ChangeLog:\n    \n2016-06-06  Jose E. Marchesi  <jose.marchesi@oracle.com>\n    \n    \t* config/sparc/sparc.md (cpu): Add niagara7 cpu type.\n    \tInclude the M7 SPARC DFA scheduler.\n    \tNew attribute v3pipe.\n    \tAnnotate insns with v3pipe where appropriate.\n    \tDefine cpu_feature vis4.\n    \tAdd lzd instruction type and set it on clzdi_sp64 and clzsi_sp64.\n    \tAdd (V8QI \"8\") to vbits.\n    \tAdd insns {add,sub}v8qi3\n    \tAdd insns ss{add,sub}v8qi3\n    \tAdd insns us{add,sub}{v8qi,v4hi}3\n    \tAdd insns {min,max}{v8qi,v4hi,v2si}3\n    \tAdd insns {minu,maxu}{v8qi,v4hi,v2si}3\n    \tAdd insns fpcmp{le,gt,ule,ug,ule,ugt}{8,16,32}_vis.\n    \t* config/sparc/niagara4.md: Add a comment explaining the\n    \tdiscrepancy between the documented latenty numbers and the\n    \timplemented ones.\n    \t* config/sparc/niagara7.md: New file.\n    \t* configure.ac (HAVE_AS_SPARC5_VIS4): Define if the assembler\n    \tsupports SPARC5 and VIS 4.0 instructions.\n    \t* configure: Regenerate.\n    \t* config.in: Likewise.\n    \t* config.gcc: niagara7 is a supported cpu in sparc*-*-* targets.\n    \t* config/sparc/sol2.h (ASM_CPU32_DEFAUILT_SPEC): Set for\n    \tTARGET_CPU_niagara7.\n    \t(ASM_CPU64_DEFAULT_SPEC): Likewise.\n    \t(CPP_CPU_SPEC): Handle niagara7.\n    \t(ASM_CPU_SPEC): Likewise.\n    \t* config/sparc/sparc-opts.h (processor_type): Add\n    \tPROCESSOR_NIAGARA7.\n    \t(mvis4): New option.\n    \t* config/sparc/sparc.h (TARGET_CPU_niagara7): Define.\n    \t(AS_NIAGARA7_FLAG): Define.\n    \t(ASM_CPU64_DEFAULT_SPEC): Set for niagara7.\n    \t(CPP_CPU64_DEFAULT_SPEC): Likewise.\n    \t(CPP_CPU_SPEC): Handle niagara7.\n    \t(ASM_CPU_SPEC): Likewise.\n    \t* config/sparc/sparc.c (niagara7_costs): Define.\n    \t(sparc_option_override): Handle niagara7 and adjust cache-related\n    \tparameters with better values for niagara cpus.  Also support VIS4.\n    \t(sparc32_initialize_trampoline): Likewise.\n    \t(sparc_use_sched_lookahead): Likewise.\n    \t(sparc_issue_rate): Likewise.\n    \t(sparc_register_move_cost): Likewise.\n    \t(dump_target_flag_bits): Support VIS4.\n    \t(sparc_vis_init_builtins): Likewise.\n    \t(sparc_builtins): Likewise.\n    \t* config/sparc/sparc-c.c (sparc_target_macros): Define __VIS__ for\n    \tVIS4 4.0.\n    \t* config/sparc/driver-sparc.c (cpu_names): Add SPARC-M7 and\n    \tUltraSparc M7.\n    \t* config/sparc/sparc.opt (sparc_processor_type): New value\n    \tniagara7.\n    \t* config/sparc/visintrin.h (__attribute__): Prototypes for the\n    \tVIS4 builtins.\n    \t* doc/invoke.texi (SPARC Options): Document -mcpu=niagara7 and\n    \t-mvis4.\n    \t* doc/extend.texi (SPARC VIS Built-in Functions): Document the\n    \tVIS4 builtins.\n    \ngcc/testsuite/ChangeLog:\n    \n2016-06-06  Jose E. Marchesi  <jose.marchesi@oracle.com>\n    \n    \t* gcc.target/sparc/vis4misc.c: New file.\n    \t* gcc.target/sparc/fpcmp.c: Likewise.\n    \t* gcc.target/sparc/fpcmpu.c: Likewise.\n\nFrom-SVN: r237132", "tree": {"sha": "33a768ccda3b7f5ea19725b06f28d532462b4833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33a768ccda3b7f5ea19725b06f28d532462b4833"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/690f24b7754826f08fc19119dd3a30a6c07e9919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/690f24b7754826f08fc19119dd3a30a6c07e9919", "html_url": "https://github.com/Rust-GCC/gccrs/commit/690f24b7754826f08fc19119dd3a30a6c07e9919", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/690f24b7754826f08fc19119dd3a30a6c07e9919/comments", "author": {"login": "jemarch", "id": 7061875, "node_id": "MDQ6VXNlcjcwNjE4NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jemarch", "html_url": "https://github.com/jemarch", "followers_url": "https://api.github.com/users/jemarch/followers", "following_url": "https://api.github.com/users/jemarch/following{/other_user}", "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions", "organizations_url": "https://api.github.com/users/jemarch/orgs", "repos_url": "https://api.github.com/users/jemarch/repos", "events_url": "https://api.github.com/users/jemarch/events{/privacy}", "received_events_url": "https://api.github.com/users/jemarch/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8964d5aaafdba5169577f671165850c40d5107e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8964d5aaafdba5169577f671165850c40d5107e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8964d5aaafdba5169577f671165850c40d5107e5"}], "stats": {"total": 1139, "additions": 1094, "deletions": 45}, "files": [{"sha": "a0255b1d3990ca160bcac3a592234ff14087fadf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -1,3 +1,64 @@\n+2016-06-06  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* config/sparc/sparc.md (cpu): Add niagara7 cpu type.\n+\tInclude the M7 SPARC DFA scheduler.\n+\tNew attribute v3pipe.\n+\tAnnotate insns with v3pipe where appropriate.\n+\tDefine cpu_feature vis4.\n+\tAdd lzd instruction type and set it on clzdi_sp64 and clzsi_sp64.\n+\tAdd (V8QI \"8\") to vbits.\n+\tAdd insns {add,sub}v8qi3\n+\tAdd insns ss{add,sub}v8qi3\n+\tAdd insns us{add,sub}{v8qi,v4hi}3\n+\tAdd insns {min,max}{v8qi,v4hi,v2si}3\n+\tAdd insns {minu,maxu}{v8qi,v4hi,v2si}3\n+\tAdd insns fpcmp{le,gt,ule,ug,ule,ugt}{8,16,32}_vis.\n+\t* config/sparc/niagara4.md: Add a comment explaining the\n+\tdiscrepancy between the documented latenty numbers and the\n+\timplemented ones.\n+\t* config/sparc/niagara7.md: New file.\n+\t* configure.ac (HAVE_AS_SPARC5_VIS4): Define if the assembler\n+\tsupports SPARC5 and VIS 4.0 instructions.\n+\t* configure: Regenerate.\n+\t* config.in: Likewise.\n+\t* config.gcc: niagara7 is a supported cpu in sparc*-*-* targets.\n+\t* config/sparc/sol2.h (ASM_CPU32_DEFAUILT_SPEC): Set for\n+\tTARGET_CPU_niagara7.\n+\t(ASM_CPU64_DEFAULT_SPEC): Likewise.\n+\t(CPP_CPU_SPEC): Handle niagara7.\n+\t(ASM_CPU_SPEC): Likewise.\n+\t* config/sparc/sparc-opts.h (processor_type): Add\n+\tPROCESSOR_NIAGARA7.\n+\t(mvis4): New option.\n+\t* config/sparc/sparc.h (TARGET_CPU_niagara7): Define.\n+\t(AS_NIAGARA7_FLAG): Define.\n+\t(ASM_CPU64_DEFAULT_SPEC): Set for niagara7.\n+\t(CPP_CPU64_DEFAULT_SPEC): Likewise.\n+\t(CPP_CPU_SPEC): Handle niagara7.\n+\t(ASM_CPU_SPEC): Likewise.\n+\t* config/sparc/sparc.c (niagara7_costs): Define.\n+\t(sparc_option_override): Handle niagara7 and adjust cache-related\n+\tparameters with better values for niagara cpus.  Also support VIS4.\n+\t(sparc32_initialize_trampoline): Likewise.\n+\t(sparc_use_sched_lookahead): Likewise.\n+\t(sparc_issue_rate): Likewise.\n+\t(sparc_register_move_cost): Likewise.\n+\t(dump_target_flag_bits): Support VIS4.\n+\t(sparc_vis_init_builtins): Likewise.\n+\t(sparc_builtins): Likewise.\n+\t* config/sparc/sparc-c.c (sparc_target_macros): Define __VIS__ for\n+\tVIS4 4.0.\n+\t* config/sparc/driver-sparc.c (cpu_names): Add SPARC-M7 and\n+\tUltraSparc M7.\n+\t* config/sparc/sparc.opt (sparc_processor_type): New value\n+\tniagara7.\n+\t* config/sparc/visintrin.h (__attribute__): Prototypes for the\n+\tVIS4 builtins.\n+\t* doc/invoke.texi (SPARC Options): Document -mcpu=niagara7 and\n+\t-mvis4.\n+\t* doc/extend.texi (SPARC VIS Built-in Functions): Document the\n+\tVIS4 builtins.\n+\n 2016-06-06  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* doc/sourcebuild.texi (Directives): Remove extra closing braces."}, {"sha": "e47535bb764f318e843906d88b8e6eea48be2747", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -4259,7 +4259,7 @@ case \"${target}\" in\n \t\t\t| sparclite | f930 | f934 | sparclite86x \\\n \t\t\t| sparclet | tsc701 \\\n \t\t\t| v9 | ultrasparc | ultrasparc3 | niagara | niagara2 \\\n-\t\t\t| niagara3 | niagara4)\n+\t\t\t| niagara3 | niagara4 | niagara7)\n \t\t\t\t# OK\n \t\t\t\t;;\n \t\t\t*)"}, {"sha": "2deb8edf681cc26b09d396b2764005ac642eb1bc", "filename": "gcc/config.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -628,6 +628,11 @@\n #undef HAVE_AS_SPARC4\n #endif\n \n+/* Define if your assembler supports SPARC5 and VIS4.0 instructions. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_SPARC5_VIS4\n+#endif\n+\n \n /* Define if your assembler and linker support GOTDATA_OP relocs. */\n #ifndef USED_FOR_TARGET"}, {"sha": "b81763e4c4fbab14c894ef252175411951d9da17", "filename": "gcc/config/sparc/driver-sparc.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fdriver-sparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fdriver-sparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fdriver-sparc.c?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -57,6 +57,7 @@ static const struct cpu_names {\n   { \"UltraSPARC-T2+\",\t\"niagara2\" },\n   { \"SPARC-T3\",\t\t\"niagara3\" },\n   { \"SPARC-T4\",\t\t\"niagara4\" },\n+  { \"SPARC-M7\",\t\t\"niagara7\" },\n #else\n   { \"SuperSparc\",\t\"supersparc\" },\n   { \"HyperSparc\",\t\"hypersparc\" },\n@@ -73,6 +74,7 @@ static const struct cpu_names {\n   { \"UltraSparc T2\",\t\"niagara2\" },\n   { \"UltraSparc T3\",\t\"niagara3\" },\n   { \"UltraSparc T4\",\t\"niagara4\" },\n+  { \"UltraSparc M7\",\t\"niagara7\" },\n   { \"LEON\",\t\t\"leon3\" },\n #endif\n   { NULL,\tNULL }"}, {"sha": "925fc6c800b3c13e1a55dcabdf324722d10fedcb", "filename": "gcc/config/sparc/niagara4.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fniagara4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fniagara4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fniagara4.md?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -75,6 +75,13 @@\n       (eq_attr \"fptype\" \"double\")))\n   \"n4_slot1\")\n \n+;; The latency numbers for VIS instructions in the reservations below\n+;; reflect empirical results, and don't match with the documented\n+;; latency numbers in the T4 Processor Supplement.  This is because\n+;; the HW chaps didn't feel it necessary to document the complexity in\n+;; the PRM, and just assigned a latency of 11 to all/most of the VIS\n+;; instructions.\n+\n (define_insn_reservation \"n4_vis_move_11cycle\" 11\n   (and (eq_attr \"cpu\" \"niagara4\")\n     (and (eq_attr \"type\" \"vismv\")"}, {"sha": "56a4edb80c62979dc2fce856698295b72c842b87", "filename": "gcc/config/sparc/niagara7.md", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fniagara7.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fniagara7.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fniagara7.md?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -0,0 +1,136 @@\n+;; Scheduling description for Niagara-7\n+;;   Copyright (C) 2016 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_automaton \"niagara7_0\")\n+\n+(define_cpu_unit \"n7_slot0,n7_slot1,n7_slot2\" \"niagara7_0\")\n+(define_reservation \"n7_single_issue\" \"n7_slot0 + n7_slot1 + n7_slot2\")\n+\n+(define_cpu_unit \"n7_load_store\" \"niagara7_0\")\n+\n+(define_insn_reservation \"n7_single\" 1\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"multi,savew,flushw,trap\"))\n+  \"n7_single_issue\")\n+\n+(define_insn_reservation \"n7_iflush\" 27\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+       (eq_attr \"type\" \"iflush\"))\n+  \"(n7_slot0 | n7_slot1), nothing*26\")\n+\n+(define_insn_reservation \"n7_integer\" 1\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"ialu,ialuX,shift,cmove,compare\"))\n+  \"(n7_slot0 | n7_slot1)\")\n+\n+(define_insn_reservation \"n7_imul\" 12\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"imul\"))\n+  \"n7_slot1, nothing*11\")\n+\n+(define_insn_reservation \"n7_idiv\" 35\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"idiv\"))\n+  \"n7_slot1, nothing*34\")\n+\n+(define_insn_reservation \"n7_load\" 5\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"load,fpload,sload\"))\n+  \"(n7_slot0 + n7_load_store), nothing*4\")\n+\n+(define_insn_reservation \"n7_store\" 1\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"store,fpstore\"))\n+  \"(n7_slot0 | n7_slot2) + n7_load_store\")\n+\n+(define_insn_reservation \"n7_cti\" 1\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"cbcond,uncond_cbcond,branch,call,sibcall,call_no_delay_slot,uncond_branch,return\"))\n+  \"n7_slot1\")\n+\n+(define_insn_reservation \"n7_fp\" 11\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"fpmove,fpcmove,fpcrmove,fp,fpcmp,fpmul\"))\n+  \"n7_slot1, nothing*10\")\n+\n+(define_insn_reservation \"n7_array\" 12\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"array,edge,edgen\"))\n+  \"n7_slot1, nothing*11\")\n+\n+(define_insn_reservation \"n7_fpdivs\" 24\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"fpdivs,fpsqrts\"))\n+  \"n7_slot1, nothing*23\")\n+\n+(define_insn_reservation \"n7_fpdivd\" 37\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"fpdivd,fpsqrtd\"))\n+  \"n7_slot1, nothing*36\")\n+\n+(define_insn_reservation \"n7_lzd\" 12\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+       (eq_attr \"type\" \"lzd\"))\n+  \"(n7_slot0 | n7_slot1), nothing*11\")\n+\n+;; There is an internal unit called the \"V3 pipe\", that was originally\n+;; intended to process some of the short cryptographic instructions.\n+;; However, as soon as in the T4 several of the VIS instructions\n+;; (notably non-FP instructions) have been moved to the V3 pipe.\n+;; Consequently, these instructions feature a latency of 3 instead of\n+;; 11 or 12 cycles, provided their consumers also execute in the V3\n+;; pipe.\n+;;\n+;; This is modelled here with a bypass.\n+\n+(define_insn_reservation \"n7_vis_fga\" 11\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"fga,gsr\"))\n+  \"n7_slot1, nothing*10\")\n+\n+(define_insn_reservation \"n7_vis_fgm\" 11\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (eq_attr \"type\" \"fgm_pack,fgm_mul,pdist\"))\n+  \"n7_slot1, nothing*10\")\n+\n+(define_insn_reservation \"n7_vis_move_v3pipe\" 11\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (and (eq_attr \"type\" \"vismv\")\n+         (eq_attr \"v3pipe\" \"true\")))\n+  \"n7_slot1\")\n+\n+(define_insn_reservation \"n7_vis_move_11cycle\" 11\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (and (eq_attr \"type\" \"vismv\")\n+         (eq_attr \"v3pipe\" \"false\")))\n+  \"n7_slot1, nothing*10\")\n+\n+(define_insn_reservation \"n7_vis_logical_v3pipe\" 11\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (and (eq_attr \"type\" \"visl,pdistn\")\n+         (eq_attr \"v3pipe\" \"true\")))\n+  \"n7_slot1, nothing*2\")\n+\n+(define_insn_reservation \"n7_vis_logical_11cycle\" 11\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+    (and (eq_attr \"type\" \"visl\")\n+      (eq_attr \"v3pipe\" \"false\")))\n+  \"n7_slot1, nothing*10\")\n+\n+(define_bypass 3 \"*_v3pipe\" \"*_v3pipe\")"}, {"sha": "2a843c5c26289caa3461ca8befd8cb241153d9a0", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -165,13 +165,22 @@ along with GCC; see the file COPYING3.  If not see\n #define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG AS_NIAGARA4_FLAG\n #endif\n \n+#if TARGET_CPU_DEFAULT == TARGET_CPU_niagara7\n+#undef CPP_CPU64_DEFAULT_SPEC\n+#define CPP_CPU64_DEFAULT_SPEC \"\"\n+#undef ASM_CPU32_DEFAULT_SPEC\n+#define ASM_CPU32_DEFAUILT_SPEC AS_SPARC32_FLAG AS_NIAGARA7_FLAG\n+#undef ASM_CPU64_DEFAULT_SPEC\n+#define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG AS_NIAGARA7_FLAG\n+#endif\n+\n #undef CPP_CPU_SPEC\n #define CPP_CPU_SPEC \"\\\n %{mcpu=sparclet|mcpu=tsc701:-D__sparclet__} \\\n %{mcpu=sparclite|mcpu-f930|mcpu=f934:-D__sparclite__} \\\n %{mcpu=v8:\" DEF_ARCH32_SPEC(\"-D__sparcv8\") \"} \\\n %{mcpu=supersparc:-D__supersparc__ \" DEF_ARCH32_SPEC(\"-D__sparcv8\") \"} \\\n-%{mcpu=v9|mcpu=ultrasparc|mcpu=ultrasparc3|mcpu=niagara|mcpu=niagara2|mcpu=niagara3|mcpu=niagara4:\" DEF_ARCH32_SPEC(\"-D__sparcv8\") \"} \\\n+%{mcpu=v9|mcpu=ultrasparc|mcpu=ultrasparc3|mcpu=niagara|mcpu=niagara2|mcpu=niagara3|mcpu=niagara4|mcpu=niagara7:\" DEF_ARCH32_SPEC(\"-D__sparcv8\") \"} \\\n %{!mcpu*:%(cpp_cpu_default)} \\\n \"\n \n@@ -280,7 +289,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n %{mcpu=niagara2:\" DEF_ARCH32_SPEC(\"-xarch=v8plusb\") DEF_ARCH64_SPEC(\"-xarch=v9b\") \"} \\\n %{mcpu=niagara3:\" DEF_ARCH32_SPEC(\"-xarch=v8plus\" AS_NIAGARA3_FLAG) DEF_ARCH64_SPEC(\"-xarch=v9\" AS_NIAGARA3_FLAG) \"} \\\n %{mcpu=niagara4:\" DEF_ARCH32_SPEC(AS_SPARC32_FLAG AS_NIAGARA4_FLAG) DEF_ARCH64_SPEC(AS_SPARC64_FLAG AS_NIAGARA4_FLAG) \"} \\\n-%{!mcpu=niagara4:%{!mcpu=niagara3:%{!mcpu=niagara2:%{!mcpu=niagara:%{!mcpu=ultrasparc3:%{!mcpu=ultrasparc:%{!mcpu=v9:%{mcpu*:\" DEF_ARCH32_SPEC(\"-xarch=v8\") DEF_ARCH64_SPEC(\"-xarch=v9\") \"}}}}}}}} \\\n+%{mcpu=niagara7:\" DEF_ARCH32_SPEC(AS_SPARC32_FLAG AS_NIAGARA7_FLAG) DEF_ARCH64_SPEC(AS_SPARC64_FLAG AS_NIAGARA7_FLAG) \"} \\\n+%{!mcpu=niagara7:%{!mcpu=niagara4:%{!mcpu=niagara3:%{!mcpu=niagara2:%{!mcpu=niagara:%{!mcpu=ultrasparc3:%{!mcpu=ultrasparc:%{!mcpu=v9:%{mcpu*:\" DEF_ARCH32_SPEC(\"-xarch=v8\") DEF_ARCH64_SPEC(\"-xarch=v9\") \"}}}}}}}}} \\\n %{!mcpu*:%(asm_cpu_default)} \\\n \"\n "}, {"sha": "d9f9c15d2e3df2bd1d1146dc2a4032cb8e9a1e10", "filename": "gcc/config/sparc/sparc-c.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-c.c?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -40,7 +40,12 @@ sparc_target_macros (void)\n       cpp_assert (parse_in, \"machine=sparc\");\n     }\n \n-  if (TARGET_VIS3)\n+  if (TARGET_VIS4)\n+    {\n+      cpp_define (parse_in, \"__VIS__=0x400\");\n+      cpp_define (parse_in, \"__VIS__=0x400\");\n+    }\n+  else if (TARGET_VIS3)\n     {\n       cpp_define (parse_in, \"__VIS__=0x300\");\n       cpp_define (parse_in, \"__VIS=0x300\");"}, {"sha": "40d23a223e38a7663546757adfcbcf6526377034", "filename": "gcc/config/sparc/sparc-opts.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-opts.h?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -45,6 +45,7 @@ enum processor_type {\n   PROCESSOR_NIAGARA2,\n   PROCESSOR_NIAGARA3,\n   PROCESSOR_NIAGARA4,\n+  PROCESSOR_NIAGARA7,\n   PROCESSOR_NATIVE\n };\n "}, {"sha": "1d2ecaaf3dc1afdb6bcff670c6778d03d701e6d1", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 221, "deletions": 11, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -423,6 +423,30 @@ struct processor_costs niagara4_costs = {\n   0, /* shift penalty */\n };\n \n+static const\n+struct processor_costs niagara7_costs = {\n+  COSTS_N_INSNS (5), /* int load */\n+  COSTS_N_INSNS (5), /* int signed load */\n+  COSTS_N_INSNS (5), /* int zeroed load */\n+  COSTS_N_INSNS (5), /* float load */\n+  COSTS_N_INSNS (11), /* fmov, fneg, fabs */\n+  COSTS_N_INSNS (11), /* fadd, fsub */\n+  COSTS_N_INSNS (11), /* fcmp */\n+  COSTS_N_INSNS (11), /* fmov, fmovr */\n+  COSTS_N_INSNS (11), /* fmul */\n+  COSTS_N_INSNS (24), /* fdivs */\n+  COSTS_N_INSNS (37), /* fdivd */\n+  COSTS_N_INSNS (24), /* fsqrts */\n+  COSTS_N_INSNS (37), /* fsqrtd */\n+  COSTS_N_INSNS (12), /* imul */\n+  COSTS_N_INSNS (12), /* imulX */\n+  0, /* imul bit factor */\n+  COSTS_N_INSNS (51), /* idiv, average of 42 - 61 cycle range */\n+  COSTS_N_INSNS (35), /* idivX, average of 26 - 44 cycle range */\n+  COSTS_N_INSNS (1), /* movcc/movr */\n+  0, /* shift penalty */\n+};\n+\n static const struct processor_costs *sparc_costs = &cypress_costs;\n \n #ifdef HAVE_AS_RELAX_OPTION\n@@ -1175,6 +1199,8 @@ dump_target_flag_bits (const int flags)\n     fprintf (stderr, \"VIS2 \");\n   if (flags & MASK_VIS3)\n     fprintf (stderr, \"VIS3 \");\n+  if (flags & MASK_VIS4)\n+    fprintf (stderr, \"VIS4 \");\n   if (flags & MASK_CBCOND)\n     fprintf (stderr, \"CBCOND \");\n   if (flags & MASK_DEPRECATED_V8_INSNS)\n@@ -1238,6 +1264,7 @@ sparc_option_override (void)\n     { TARGET_CPU_niagara2, PROCESSOR_NIAGARA2 },\n     { TARGET_CPU_niagara3, PROCESSOR_NIAGARA3 },\n     { TARGET_CPU_niagara4, PROCESSOR_NIAGARA4 },\n+    { TARGET_CPU_niagara7, PROCESSOR_NIAGARA7 },\n     { -1, PROCESSOR_V7 }\n   };\n   const struct cpu_default *def;\n@@ -1287,6 +1314,9 @@ sparc_option_override (void)\n     /* UltraSPARC T4 */\n     { \"niagara4\",\tMASK_ISA,\n       MASK_V9|MASK_POPC|MASK_VIS2|MASK_VIS3|MASK_FMAF|MASK_CBCOND },\n+    /* UltraSPARC M7 */\n+    { \"niagara7\",\tMASK_ISA,\n+      MASK_V9|MASK_POPC|MASK_VIS2|MASK_VIS3|MASK_VIS4|MASK_FMAF|MASK_CBCOND },\n   };\n   const struct cpu_table *cpu;\n   unsigned int i;\n@@ -1416,6 +1446,9 @@ sparc_option_override (void)\n #ifndef HAVE_AS_SPARC4\n \t\t   & ~MASK_CBCOND\n #endif\n+#ifndef HAVE_AS_SPARC5_VIS4\n+\t\t   & ~MASK_VIS4\n+#endif\n #ifndef HAVE_AS_LEON\n \t\t   & ~(MASK_LEON | MASK_LEON3)\n #endif\n@@ -1434,10 +1467,15 @@ sparc_option_override (void)\n   if (TARGET_VIS3)\n     target_flags |= MASK_VIS2 | MASK_VIS;\n \n-  /* Don't allow -mvis, -mvis2, -mvis3, or -mfmaf if FPU is\n+  /* -mvis4 implies -mvis3, -mvis2 and -mvis */\n+  if (TARGET_VIS4)\n+    target_flags |= MASK_VIS3 | MASK_VIS2 | MASK_VIS;\n+\n+  /* Don't allow -mvis, -mvis2, -mvis3, -mvis4 or -mfmaf if FPU is\n      disabled.  */\n   if (! TARGET_FPU)\n-    target_flags &= ~(MASK_VIS | MASK_VIS2 | MASK_VIS3 | MASK_FMAF);\n+    target_flags &= ~(MASK_VIS | MASK_VIS2 | MASK_VIS3 | MASK_VIS4\n+\t\t      | MASK_FMAF);\n \n   /* -mvis assumes UltraSPARC+, so we are sure v9 instructions\n      are available.\n@@ -1471,7 +1509,8 @@ sparc_option_override (void)\n \t  || sparc_cpu == PROCESSOR_NIAGARA\n \t  || sparc_cpu == PROCESSOR_NIAGARA2\n \t  || sparc_cpu == PROCESSOR_NIAGARA3\n-\t  || sparc_cpu == PROCESSOR_NIAGARA4))\n+\t  || sparc_cpu == PROCESSOR_NIAGARA4\n+\t  || sparc_cpu == PROCESSOR_NIAGARA7))\n     align_functions = 32;\n \n   /* Validate PCC_STRUCT_RETURN.  */\n@@ -1535,6 +1574,9 @@ sparc_option_override (void)\n     case PROCESSOR_NIAGARA4:\n       sparc_costs = &niagara4_costs;\n       break;\n+    case PROCESSOR_NIAGARA7:\n+      sparc_costs = &niagara7_costs;\n+      break;\n     case PROCESSOR_NATIVE:\n       gcc_unreachable ();\n     };\n@@ -1566,6 +1608,29 @@ sparc_option_override (void)\n   if (TARGET_DEBUG_OPTIONS)\n     dump_target_flags (\"Final target_flags\", target_flags);\n \n+  /* PARAM_SIMULTANEOUS_PREFETCHES is the number of prefetches that\n+     can run at the same time.  More important, it is the threshold\n+     defining when additional prefetches will be dropped by the\n+     hardware.\n+\n+     The UltraSPARC-III features a documented prefetch queue with a\n+     size of 8.  Additional prefetches issued in the cpu are\n+     dropped.\n+\n+     Niagara processors are different.  In these processors prefetches\n+     are handled much like regular loads.  The L1 miss buffer is 32\n+     entries, but prefetches start getting affected when 30 entries\n+     become occupied.  That occupation could be a mix of regular loads\n+     and prefetches though.  And that buffer is shared by all threads.\n+     Once the threshold is reached, if the core is running a single\n+     thread the prefetch will retry.  If more than one thread is\n+     running, the prefetch will be dropped.\n+\n+     All this makes it very difficult to determine how many\n+     simultaneous prefetches can be issued simultaneously, even in a\n+     single-threaded program.  Experimental results show that setting\n+     this parameter to 32 works well when the number of threads is not\n+     high.  */\n   maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,\n \t\t\t ((sparc_cpu == PROCESSOR_ULTRASPARC\n \t\t\t   || sparc_cpu == PROCESSOR_NIAGARA\n@@ -1574,20 +1639,55 @@ sparc_option_override (void)\n \t\t\t   || sparc_cpu == PROCESSOR_NIAGARA4)\n \t\t\t  ? 2\n \t\t\t  : (sparc_cpu == PROCESSOR_ULTRASPARC3\n-\t\t\t     ? 8 : 3)),\n+\t\t\t     ? 8 : (sparc_cpu == PROCESSOR_NIAGARA7\n+\t\t\t\t    ? 32 : 3))),\n \t\t\t global_options.x_param_values,\n \t\t\t global_options_set.x_param_values);\n-  maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,\n+\n+  /* For PARAM_L1_CACHE_LINE_SIZE we use the default 32 bytes (see\n+     params.def), so no maybe_set_param_value is needed.\n+\n+     The Oracle SPARC Architecture (previously the UltraSPARC\n+     Architecture) specification states that when a PREFETCH[A]\n+     instruction is executed an implementation-specific amount of data\n+     is prefetched, and that it is at least 64 bytes long (aligned to\n+     at least 64 bytes).\n+\n+     However, this is not correct.  The M7 (and implementations prior\n+     to that) does not guarantee a 64B prefetch into a cache if the\n+     line size is smaller.  A single cache line is all that is ever\n+     prefetched.  So for the M7, where the L1D$ has 32B lines and the\n+     L2D$ and L3 have 64B lines, a prefetch will prefetch 64B into the\n+     L2 and L3, but only 32B are brought into the L1D$. (Assuming it\n+     is a read_n prefetch, which is the only type which allocates to\n+     the L1.)  */\n+\n+  /* PARAM_L1_CACHE_SIZE is the size of the L1D$ (most SPARC chips use\n+     Hardvard level-1 caches) in kilobytes.  Both UltraSPARC and\n+     Niagara processors feature a L1D$ of 16KB.  */\n+  maybe_set_param_value (PARAM_L1_CACHE_SIZE,\n \t\t\t ((sparc_cpu == PROCESSOR_ULTRASPARC\n \t\t\t   || sparc_cpu == PROCESSOR_ULTRASPARC3\n \t\t\t   || sparc_cpu == PROCESSOR_NIAGARA\n \t\t\t   || sparc_cpu == PROCESSOR_NIAGARA2\n \t\t\t   || sparc_cpu == PROCESSOR_NIAGARA3\n-\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA4)\n-\t\t\t  ? 64 : 32),\n+\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA4\n+\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA7)\n+\t\t\t  ? 16 : 64),\n \t\t\t global_options.x_param_values,\n \t\t\t global_options_set.x_param_values);\n \n+\n+  /* PARAM_L2_CACHE_SIZE is the size fo the L2 in kilobytes.  Note\n+     that 512 is the default in params.def.  */\n+  maybe_set_param_value (PARAM_L2_CACHE_SIZE,\n+\t\t\t (sparc_cpu == PROCESSOR_NIAGARA4\n+\t\t\t  ? 128 : (sparc_cpu == PROCESSOR_NIAGARA7\n+\t\t\t\t   ? 256 : 512)),\n+\t\t\t global_options.x_param_values,\n+\t\t\t global_options_set.x_param_values);\n+  \n+\n   /* Disable save slot sharing for call-clobbered registers by default.\n      The IRA sharing algorithm works on single registers only and this\n      pessimizes for double floating-point registers.  */\n@@ -9178,7 +9278,8 @@ sparc32_initialize_trampoline (rtx m_tramp, rtx fnaddr, rtx cxt)\n       && sparc_cpu != PROCESSOR_NIAGARA\n       && sparc_cpu != PROCESSOR_NIAGARA2\n       && sparc_cpu != PROCESSOR_NIAGARA3\n-      && sparc_cpu != PROCESSOR_NIAGARA4)\n+      && sparc_cpu != PROCESSOR_NIAGARA4\n+      && sparc_cpu != PROCESSOR_NIAGARA7)\n     emit_insn (gen_flushsi (validize_mem (adjust_address (m_tramp, SImode, 8))));\n \n   /* Call __enable_execute_stack after writing onto the stack to make sure\n@@ -9223,7 +9324,8 @@ sparc64_initialize_trampoline (rtx m_tramp, rtx fnaddr, rtx cxt)\n       && sparc_cpu != PROCESSOR_NIAGARA\n       && sparc_cpu != PROCESSOR_NIAGARA2\n       && sparc_cpu != PROCESSOR_NIAGARA3\n-      && sparc_cpu != PROCESSOR_NIAGARA4)\n+      && sparc_cpu != PROCESSOR_NIAGARA4\n+      && sparc_cpu != PROCESSOR_NIAGARA7)\n     emit_insn (gen_flushdi (validize_mem (adjust_address (m_tramp, DImode, 8))));\n \n   /* Call __enable_execute_stack after writing onto the stack to make sure\n@@ -9419,7 +9521,8 @@ sparc_use_sched_lookahead (void)\n       || sparc_cpu == PROCESSOR_NIAGARA2\n       || sparc_cpu == PROCESSOR_NIAGARA3)\n     return 0;\n-  if (sparc_cpu == PROCESSOR_NIAGARA4)\n+  if (sparc_cpu == PROCESSOR_NIAGARA4\n+      || sparc_cpu == PROCESSOR_NIAGARA7)\n     return 2;\n   if (sparc_cpu == PROCESSOR_ULTRASPARC\n       || sparc_cpu == PROCESSOR_ULTRASPARC3)\n@@ -9442,6 +9545,7 @@ sparc_issue_rate (void)\n     default:\n       return 1;\n     case PROCESSOR_NIAGARA4:\n+    case PROCESSOR_NIAGARA7:\n     case PROCESSOR_V9:\n       /* Assume V9 processors are capable of at least dual-issue.  */\n       return 2;\n@@ -10007,6 +10111,34 @@ enum sparc_builtins\n   SPARC_BUILTIN_XMULX,\n   SPARC_BUILTIN_XMULXHI,\n \n+  /* VIS 4.0 builtins.  */\n+  SPARC_BUILTIN_FPADD8,\n+  SPARC_BUILTIN_FPADDS8,\n+  SPARC_BUILTIN_FPADDUS8,\n+  SPARC_BUILTIN_FPADDUS16,\n+  SPARC_BUILTIN_FPCMPLE8,\n+  SPARC_BUILTIN_FPCMPGT8,\n+  SPARC_BUILTIN_FPCMPULE16,\n+  SPARC_BUILTIN_FPCMPUGT16,\n+  SPARC_BUILTIN_FPCMPULE32,\n+  SPARC_BUILTIN_FPCMPUGT32,\n+  SPARC_BUILTIN_FPMAX8,\n+  SPARC_BUILTIN_FPMAX16,\n+  SPARC_BUILTIN_FPMAX32,\n+  SPARC_BUILTIN_FPMAXU8,\n+  SPARC_BUILTIN_FPMAXU16,\n+  SPARC_BUILTIN_FPMAXU32,\n+  SPARC_BUILTIN_FPMIN8,\n+  SPARC_BUILTIN_FPMIN16,\n+  SPARC_BUILTIN_FPMIN32,\n+  SPARC_BUILTIN_FPMINU8,\n+  SPARC_BUILTIN_FPMINU16,\n+  SPARC_BUILTIN_FPMINU32,\n+  SPARC_BUILTIN_FPSUB8,\n+  SPARC_BUILTIN_FPSUBS8,\n+  SPARC_BUILTIN_FPSUBUS8,\n+  SPARC_BUILTIN_FPSUBUS16,\n+  \n   SPARC_BUILTIN_MAX\n };\n \n@@ -10483,6 +10615,83 @@ sparc_vis_init_builtins (void)\n       def_builtin_const (\"__builtin_vis_xmulxhi\", CODE_FOR_xmulxhi_vis,\n \t\t\t SPARC_BUILTIN_XMULXHI, di_ftype_di_di);\n     }\n+\n+  if (TARGET_VIS4)\n+    {\n+      def_builtin_const (\"__builtin_vis_fpadd8\", CODE_FOR_addv8qi3,\n+\t\t\t SPARC_BUILTIN_FPADD8, v8qi_ftype_v8qi_v8qi);\n+      def_builtin_const (\"__builtin_vis_fpadds8\", CODE_FOR_ssaddv8qi3,\n+\t\t\t SPARC_BUILTIN_FPADDS8, v8qi_ftype_v8qi_v8qi);\n+      def_builtin_const (\"__builtin_vis_fpaddus8\", CODE_FOR_usaddv8qi3,\n+\t\t\t SPARC_BUILTIN_FPADDUS8, v8qi_ftype_v8qi_v8qi);\n+      def_builtin_const (\"__builtin_vis_fpaddus16\", CODE_FOR_usaddv4hi3,\n+\t\t\t SPARC_BUILTIN_FPADDUS16, v4hi_ftype_v4hi_v4hi);\n+\n+\n+      if (TARGET_ARCH64)\n+\t{\n+\t  def_builtin_const (\"__builtin_vis_fpcmple8\", CODE_FOR_fpcmple8di_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPLE8, di_ftype_v8qi_v8qi);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpgt8\", CODE_FOR_fpcmpgt8di_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPGT8, di_ftype_v8qi_v8qi);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpule16\", CODE_FOR_fpcmpule16di_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPULE16, di_ftype_v4hi_v4hi);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpugt16\", CODE_FOR_fpcmpugt16di_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPUGT16, di_ftype_v4hi_v4hi);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpule32\", CODE_FOR_fpcmpule32di_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPULE32, di_ftype_v2si_v2si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpugt32\", CODE_FOR_fpcmpugt32di_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPUGT32, di_ftype_v2si_v2si);\n+\t}\n+      else\n+\t{\n+\t  def_builtin_const (\"__builtin_vis_fpcmple8\", CODE_FOR_fpcmple8si_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPLE8, si_ftype_v8qi_v8qi);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpgt8\", CODE_FOR_fpcmpgt8si_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPGT8, si_ftype_v8qi_v8qi);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpule16\", CODE_FOR_fpcmpule16si_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPULE16, si_ftype_v4hi_v4hi);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpugt16\", CODE_FOR_fpcmpugt16si_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPUGT16, si_ftype_v4hi_v4hi);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpule32\", CODE_FOR_fpcmpule32si_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPULE32, di_ftype_v2si_v2si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpugt32\", CODE_FOR_fpcmpugt32si_vis,\n+\t\t\t     SPARC_BUILTIN_FPCMPUGT32, di_ftype_v2si_v2si);\n+\t}\n+      \n+      def_builtin_const (\"__builtin_vis_fpmax8\", CODE_FOR_maxv8qi3,\n+\t\t\t SPARC_BUILTIN_FPMAX8, v8qi_ftype_v8qi_v8qi);\n+      def_builtin_const (\"__builtin_vis_fpmax16\", CODE_FOR_maxv4hi3,\n+\t\t\t SPARC_BUILTIN_FPMAX16, v4hi_ftype_v4hi_v4hi);\n+      def_builtin_const (\"__builtin_vis_fpmax32\", CODE_FOR_maxv2si3,\n+\t\t\t SPARC_BUILTIN_FPMAX32, v2si_ftype_v2si_v2si);\n+      def_builtin_const (\"__builtin_vis_fpmaxu8\", CODE_FOR_maxuv8qi3,\n+\t\t\t SPARC_BUILTIN_FPMAXU8, v8qi_ftype_v8qi_v8qi);\n+      def_builtin_const (\"__builtin_vis_fpmaxu16\", CODE_FOR_maxuv4hi3,\n+\t\t\t SPARC_BUILTIN_FPMAXU16, v4hi_ftype_v4hi_v4hi);\n+      def_builtin_const (\"__builtin_vis_fpmaxu32\", CODE_FOR_maxuv2si3,\n+\t\t\t SPARC_BUILTIN_FPMAXU32, v2si_ftype_v2si_v2si);\n+      def_builtin_const (\"__builtin_vis_fpmin8\", CODE_FOR_minv8qi3,\n+\t\t\t SPARC_BUILTIN_FPMIN8, v8qi_ftype_v8qi_v8qi);\n+      def_builtin_const (\"__builtin_vis_fpmin16\", CODE_FOR_minv4hi3,\n+\t\t\t SPARC_BUILTIN_FPMIN16, v4hi_ftype_v4hi_v4hi);\n+      def_builtin_const (\"__builtin_vis_fpmin32\", CODE_FOR_minv2si3,\n+\t\t\t SPARC_BUILTIN_FPMIN32, v2si_ftype_v2si_v2si);\n+      def_builtin_const (\"__builtin_vis_fpminu8\", CODE_FOR_minuv8qi3,\n+\t\t\t SPARC_BUILTIN_FPMINU8, v8qi_ftype_v8qi_v8qi);\n+      def_builtin_const (\"__builtin_vis_fpminu16\", CODE_FOR_minuv4hi3,\n+\t\t\t SPARC_BUILTIN_FPMINU16, v4hi_ftype_v4hi_v4hi);\n+      def_builtin_const (\"__builtin_vis_fpminu32\", CODE_FOR_minuv2si3,\n+\t\t\t SPARC_BUILTIN_FPMINU32, v2si_ftype_v2si_v2si);\n+      def_builtin_const (\"__builtin_vis_fpsub8\", CODE_FOR_subv8qi3,\n+\t\t\t SPARC_BUILTIN_FPSUB8, v8qi_ftype_v8qi_v8qi);\n+      def_builtin_const (\"__builtin_vis_fpsubs8\", CODE_FOR_sssubv8qi3,\n+\t\t\t SPARC_BUILTIN_FPSUBS8, v8qi_ftype_v8qi_v8qi);\n+      def_builtin_const (\"__builtin_vis_fpsubus8\", CODE_FOR_ussubv8qi3,\n+\t\t\t SPARC_BUILTIN_FPSUBUS8, v8qi_ftype_v8qi_v8qi);\n+      def_builtin_const (\"__builtin_vis_fpsubus16\", CODE_FOR_ussubv4hi3,\n+\t\t\t SPARC_BUILTIN_FPSUBUS16, v4hi_ftype_v4hi_v4hi);\n+    }\n }\n \n /* Implement TARGET_BUILTIN_DECL hook.  */\n@@ -11042,7 +11251,8 @@ sparc_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t  || sparc_cpu == PROCESSOR_NIAGARA\n \t  || sparc_cpu == PROCESSOR_NIAGARA2\n \t  || sparc_cpu == PROCESSOR_NIAGARA3\n-\t  || sparc_cpu == PROCESSOR_NIAGARA4)\n+\t  || sparc_cpu == PROCESSOR_NIAGARA4\n+\t  || sparc_cpu == PROCESSOR_NIAGARA7)\n \treturn 12;\n \n       return 6;"}, {"sha": "d91496ab6abb7f21ac06456b4ead25b873749ea5", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -142,14 +142,16 @@ extern enum cmodel sparc_cmodel;\n #define TARGET_CPU_niagara2\t14\n #define TARGET_CPU_niagara3\t15\n #define TARGET_CPU_niagara4\t16\n+#define TARGET_CPU_niagara7\t19\n \n #if TARGET_CPU_DEFAULT == TARGET_CPU_v9 \\\n  || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc \\\n  || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc3 \\\n  || TARGET_CPU_DEFAULT == TARGET_CPU_niagara \\\n  || TARGET_CPU_DEFAULT == TARGET_CPU_niagara2 \\\n  || TARGET_CPU_DEFAULT == TARGET_CPU_niagara3 \\\n- || TARGET_CPU_DEFAULT == TARGET_CPU_niagara4\n+ || TARGET_CPU_DEFAULT == TARGET_CPU_niagara4 \\\n+ || TARGET_CPU_DEFAULT == TARGET_CPU_niagara7\n \n #define CPP_CPU32_DEFAULT_SPEC \"\"\n #define ASM_CPU32_DEFAULT_SPEC \"\"\n@@ -186,6 +188,10 @@ extern enum cmodel sparc_cmodel;\n #define CPP_CPU64_DEFAULT_SPEC \"-D__sparc_v9__\"\n #define ASM_CPU64_DEFAULT_SPEC AS_NIAGARA4_FLAG\n #endif\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_niagara7\n+#define CPP_CPU64_DEFAULT_SPEC \"-D__sparc_v9__\"\n+#define ASM_CPU64_DEFAULT_SPEC AS_NIAGARA7_FLAG\n+#endif\n \n #else\n \n@@ -288,6 +294,7 @@ extern enum cmodel sparc_cmodel;\n %{mcpu=niagara2:-D__sparc_v9__} \\\n %{mcpu=niagara3:-D__sparc_v9__} \\\n %{mcpu=niagara4:-D__sparc_v9__} \\\n+%{mcpu=niagara7:-D__sparc_v9__} \\\n %{!mcpu*:%(cpp_cpu_default)} \\\n \"\n #define CPP_ARCH32_SPEC \"\"\n@@ -339,6 +346,7 @@ extern enum cmodel sparc_cmodel;\n %{mcpu=niagara2:%{!mv8plus:-Av9b}} \\\n %{mcpu=niagara3:%{!mv8plus:-Av9\" AS_NIAGARA3_FLAG \"}} \\\n %{mcpu=niagara4:%{!mv8plus:\" AS_NIAGARA4_FLAG \"}} \\\n+%{mcpu=niagara7:%{!mv8plus:\" AS_NIAGARA7_FLAG \"}} \\\n %{!mcpu*:%(asm_cpu_default)} \\\n \"\n \n@@ -1777,6 +1785,12 @@ extern int sparc_indent_opcode;\n #define AS_NIAGARA4_FLAG \"-Av9\" AS_NIAGARA3_FLAG\n #endif\n \n+#ifdef HAVE_AS_SPARC5_VIS4\n+#define AS_NIAGARA7_FLAG \"-xarch=sparc5\"\n+#else\n+#define AS_NIAGARA7_FLAG AS_NIAGARA4_FLAG\n+#endif\n+\n #ifdef HAVE_AS_LEON\n #define AS_LEON_FLAG \"-Aleon\"\n #define AS_LEONV7_FLAG \"-Aleon\""}, {"sha": "29e4966fccb738dc55a6d3e4f5d3c0074e3f2a72", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 144, "deletions": 20, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -234,7 +234,8 @@\n    niagara,\n    niagara2,\n    niagara3,\n-   niagara4\"\n+   niagara4,\n+   niagara7\"\n   (const (symbol_ref \"sparc_cpu_attr\")))\n \n ;; Attribute for the instruction set.\n@@ -247,15 +248,16 @@\n \t (symbol_ref \"TARGET_SPARCLET\") (const_string \"sparclet\")]\n \t(const_string \"v7\"))))\n \n-(define_attr \"cpu_feature\" \"none,fpu,fpunotv9,v9,vis,vis3\" (const_string \"none\"))\n+(define_attr \"cpu_feature\" \"none,fpu,fpunotv9,v9,vis,vis3,vis4\" (const_string \"none\"))\n \n (define_attr \"enabled\" \"\"\n   (cond [(eq_attr \"cpu_feature\" \"none\") (const_int 1)\n          (eq_attr \"cpu_feature\" \"fpu\") (symbol_ref \"TARGET_FPU\")\n \t (eq_attr \"cpu_feature\" \"fpunotv9\") (symbol_ref \"TARGET_FPU && ! TARGET_V9\")\n          (eq_attr \"cpu_feature\" \"v9\") (symbol_ref \"TARGET_V9\")\n          (eq_attr \"cpu_feature\" \"vis\") (symbol_ref \"TARGET_VIS\")\n-         (eq_attr \"cpu_feature\" \"vis3\") (symbol_ref \"TARGET_VIS3\")]\n+         (eq_attr \"cpu_feature\" \"vis3\") (symbol_ref \"TARGET_VIS3\")\n+         (eq_attr \"cpu_feature\" \"vis4\") (symbol_ref \"TARGET_VIS4\")]\n         (const_int 0)))\n \n ;; Insn type.\n@@ -274,7 +276,7 @@\n    fga,visl,vismv,fgm_pack,fgm_mul,pdist,pdistn,edge,edgen,gsr,array,\n    cmove,\n    ialuX,\n-   multi,savew,flushw,iflush,trap\"\n+   multi,savew,flushw,iflush,trap,lzd\"\n   (const_string \"ialu\"))\n \n ;; True if branch/call has empty delay slot and will emit a nop in it\n@@ -476,6 +478,10 @@\n \t   (const_string \"true\")\n \t] (const_string \"false\")))\n \n+;; True if the instruction executes in the V3 pipeline, in M7 and\n+;; later processors.\n+(define_attr \"v3pipe\" \"false,true\" (const_string \"false\"))\n+\n (define_delay (eq_attr \"type\" \"call\")\n   [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n@@ -504,6 +510,7 @@\n (include \"niagara.md\")\n (include \"niagara2.md\")\n (include \"niagara4.md\")\n+(include \"niagara7.md\")\n \n \n ;; Operand and operator predicates and constraints\n@@ -1457,6 +1464,7 @@\n    fzeros\\t%0\n    fones\\t%0\"\n   [(set_attr \"type\" \"*,*,load,store,vismv,vismv,fpmove,fpload,fpstore,visl,visl\")\n+   (set_attr \"v3pipe\" \"*,*,*,*,true,true,*,*,*,true,true\")\n    (set_attr \"cpu_feature\" \"*,*,*,*,vis3,vis3,*,*,*,vis,vis\")])\n \n (define_insn \"*movsi_lo_sum\"\n@@ -1622,6 +1630,7 @@\n    fzero\\t%0\n    fone\\t%0\"\n   [(set_attr \"type\" \"store,store,store,load,*,*,*,*,fpstore,fpload,*,*,fpmove,*,*,*,fpload,fpstore,visl,visl\")\n+   (set_attr \"v3pipe\" \"false, false, false, false,false,false,false,false,false,false,false,false,false,false,false,false,false,false, true, true\")\n    (set_attr \"length\" \"*,2,*,*,2,2,2,2,*,*,2,2,*,2,2,2,*,*,*,*\")\n    (set_attr \"fptype\" \"*,*,*,*,*,*,*,*,*,*,*,*,double,*,*,*,*,*,double,double\")\n    (set_attr \"cpu_feature\" \"v9,*,*,*,*,*,*,*,fpu,fpu,fpu,fpu,v9,fpunotv9,vis3,vis3,fpu,fpu,vis,vis\")])\n@@ -1645,6 +1654,7 @@\n    fzero\\t%0\n    fone\\t%0\"\n   [(set_attr \"type\" \"*,*,load,store,vismv,vismv,fpmove,fpload,fpstore,visl,visl\")\n+   (set_attr \"v3pipe\" \"*, *, *, *, *, *, *, *, *, true, true\")\n    (set_attr \"fptype\" \"*,*,*,*,*,*,double,*,*,double,double\")\n    (set_attr \"cpu_feature\" \"*,*,*,*,vis3,vis3,*,*,*,vis,vis\")])\n \n@@ -2208,6 +2218,7 @@\n     }\n }\n   [(set_attr \"type\" \"visl,visl,fpmove,*,*,*,vismv,vismv,fpload,load,fpstore,store\")\n+   (set_attr \"v3pipe\" \"true, true, *, *, *, *, true, true, *, *, *, *\")\n    (set_attr \"cpu_feature\" \"vis,vis,fpu,*,*,*,vis3,vis3,fpu,*,fpu,*\")])\n \n ;; The following 3 patterns build SFmode constants in integer registers.\n@@ -2276,6 +2287,7 @@\n   #\n   #\"\n   [(set_attr \"type\" \"visl,visl,fpmove,*,*,*,fpload,store,fpstore,load,store,*,*,*,*\")\n+   (set_attr \"v3pipe\" \"true, true, *, *, *, *, *, *, *, *, *, *, *, *, *\")\n    (set_attr \"length\" \"*,*,*,2,2,2,*,*,*,*,*,2,2,2,2\")\n    (set_attr \"fptype\" \"double,double,double,*,*,*,*,*,*,*,*,*,*,*,*\")\n    (set_attr \"cpu_feature\" \"vis,vis,v9,fpunotv9,vis3,vis3,fpu,v9,fpu,*,*,fpu,*,*,fpu\")])\n@@ -2299,6 +2311,7 @@\n   stx\\t%r1, %0\n   #\"\n   [(set_attr \"type\" \"visl,visl,fpmove,vismv,vismv,load,store,*,load,store,*\")\n+   (set_attr \"v3pipe\" \"true, true, *, *, *, *, *, *, *, *, *\")\n    (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,2\")\n    (set_attr \"fptype\" \"double,double,double,double,double,*,*,*,*,*,*\")\n    (set_attr \"cpu_feature\" \"vis,vis,fpu,vis3,vis3,fpu,fpu,*,*,*,*\")])\n@@ -2980,6 +2993,7 @@\n    lduw\\t%1, %0\n    movstouw\\t%1, %0\"\n   [(set_attr \"type\" \"shift,load,*\")\n+   (set_attr \"v3pipe\" \"*,*,true\")\n    (set_attr \"cpu_feature\" \"*,*,vis3\")])\n \n (define_insn_and_split \"*zero_extendsidi2_insn_sp32\"\n@@ -3294,6 +3308,7 @@\n   ldsw\\t%1, %0\n   movstosw\\t%1, %0\"\n   [(set_attr \"type\" \"shift,sload,*\")\n+   (set_attr \"v3pipe\" \"*,*,true\")\n    (set_attr \"us3load_type\" \"*,3cycle,*\")\n    (set_attr \"cpu_feature\" \"*,*,vis3\")])\n \n@@ -6770,7 +6785,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (clz:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n   \"TARGET_VIS3 && TARGET_ARCH64\"\n-  \"lzd\\t%1, %0\")\n+  \"lzd\\t%1, %0\"\n+  [(set_attr \"type\" \"lzd\")])\n \n (define_insn \"clzdi_v8plus\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -6811,7 +6827,8 @@\n         (truncate:SI\n           (clz:DI (match_operand:DI 1 \"register_operand\" \"r\"))))]\n   \"TARGET_VIS3 && TARGET_ARCH64\"\n-  \"lzd\\t%1, %0\")\n+  \"lzd\\t%1, %0\"\n+  [(set_attr \"type\" \"lzd\")])\n \n (define_insn \"clzsi_v8plus\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -7777,7 +7794,7 @@\n (define_mode_iterator VM64 [V1DI V2SI V4HI V8QI])\n (define_mode_iterator VMALL [V1SI V2HI V4QI V1DI V2SI V4HI V8QI])\n \n-(define_mode_attr vbits [(V2SI \"32\") (V4HI \"16\") (V1SI \"32s\") (V2HI \"16s\")])\n+(define_mode_attr vbits [(V2SI \"32\") (V4HI \"16\") (V1SI \"32s\") (V2HI \"16s\") (V8QI \"8\")])\n (define_mode_attr vconstr [(V1SI \"f\") (V2HI \"f\") (V4QI \"f\")\n \t\t\t   (V1DI \"e\") (V2SI \"e\") (V4HI \"e\") (V8QI \"e\")])\n (define_mode_attr vfptype [(V1SI \"single\") (V2HI \"single\") (V4QI \"single\")\n@@ -7812,6 +7829,7 @@\n   movstouw\\t%1, %0\n   movwtos\\t%1, %0\"\n   [(set_attr \"type\" \"visl,visl,vismv,fpload,fpstore,store,load,store,*,vismv,vismv\")\n+   (set_attr \"v3pipe\" \"true,true,true,false,false,false,false,false,false,true,true\")\n    (set_attr \"cpu_feature\" \"vis,vis,vis,*,*,*,*,*,*,vis3,vis3\")])\n \n (define_insn \"*mov<VM64:mode>_insn_sp64\"\n@@ -7834,6 +7852,7 @@\n   movxtod\\t%1, %0\n   mov\\t%1, %0\"\n   [(set_attr \"type\" \"visl,visl,vismv,fpload,fpstore,store,load,store,vismv,vismv,*\")\n+   (set_attr \"v3pipe\" \"true, true, true, false, false, false, false, false, false, false, false\")\n    (set_attr \"cpu_feature\" \"vis,vis,vis,*,*,*,*,*,vis3,vis3,*\")])\n \n (define_insn \"*mov<VM64:mode>_insn_sp32\"\n@@ -7857,6 +7876,7 @@\n   #\n   #\"\n   [(set_attr \"type\" \"visl,visl,vismv,*,*,fpload,fpstore,store,load,store,*,*\")\n+   (set_attr \"v3pipe\" \"true, true, true, false, false, false, false, false, false, false, false, false\")\n    (set_attr \"length\" \"*,*,*,2,2,*,*,*,*,*,2,2\")\n    (set_attr \"cpu_feature\" \"vis,vis,vis,vis3,vis3,*,*,*,*,*,*,*\")])\n \n@@ -7936,7 +7956,8 @@\n   \"TARGET_VIS\"\n   \"fp<plusminus_insn><vbits>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"fptype\" \"<vfptype>\")])\n+   (set_attr \"fptype\" \"<vfptype>\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n (define_mode_iterator VL [V1SI V2HI V4QI V1DI V2SI V4HI V8QI])\n (define_mode_attr vlsuf [(V1SI \"s\") (V2HI \"s\") (V4QI \"s\")\n@@ -7952,6 +7973,7 @@\n   \"TARGET_VIS\"\n   \"f<vlinsn><vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"visl\")\n+   (set_attr \"v3pipe\" \"true\")\n    (set_attr \"fptype\" \"<vfptype>\")])\n \n (define_insn \"*not_<code><mode>3\"\n@@ -7961,6 +7983,7 @@\n   \"TARGET_VIS\"\n   \"f<vlninsn><vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"visl\")\n+   (set_attr \"v3pipe\" \"true\")\n    (set_attr \"fptype\" \"<vfptype>\")])\n \n ;; (ior (not (op1)) (not (op2))) is the canonical form of NAND.\n@@ -7971,6 +7994,7 @@\n   \"TARGET_VIS\"\n   \"fnand<vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"visl\")\n+   (set_attr \"v3pipe\" \"true\")\n    (set_attr \"fptype\" \"<vfptype>\")])\n \n (define_code_iterator vlnotop [ior and])\n@@ -7982,6 +8006,7 @@\n   \"TARGET_VIS\"\n   \"f<vlinsn>not1<vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"visl\")\n+   (set_attr \"v3pipe\" \"true\")\n    (set_attr \"fptype\" \"<vfptype>\")])\n \n (define_insn \"*<code>_not2<mode>_vis\"\n@@ -7991,6 +8016,7 @@\n   \"TARGET_VIS\"\n   \"f<vlinsn>not2<vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"visl\")\n+   (set_attr \"v3pipe\" \"true\")\n    (set_attr \"fptype\" \"<vfptype>\")])\n \n (define_insn \"one_cmpl<mode>2\"\n@@ -7999,6 +8025,7 @@\n   \"TARGET_VIS\"\n   \"fnot1<vlsuf>\\t%1, %0\"\n   [(set_attr \"type\" \"visl\")\n+   (set_attr \"v3pipe\" \"true\")\n    (set_attr \"fptype\" \"<vfptype>\")])\n \n ;; Hard to generate VIS instructions.  We have builtins for these.\n@@ -8225,7 +8252,8 @@\n   \"TARGET_VIS\"\n   \"faligndata\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"double\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n (define_insn \"alignaddrsi_vis\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -8235,7 +8263,8 @@\n         (zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n   \"TARGET_VIS\"\n   \"alignaddr\\t%r1, %r2, %0\"\n-  [(set_attr \"type\" \"gsr\")])\n+  [(set_attr \"type\" \"gsr\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n (define_insn \"alignaddrdi_vis\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -8245,7 +8274,8 @@\n         (plus:DI (match_dup 1) (match_dup 2)))]\n   \"TARGET_VIS\"\n   \"alignaddr\\t%r1, %r2, %0\"\n-  [(set_attr \"type\" \"gsr\")])\n+  [(set_attr \"type\" \"gsr\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n (define_insn \"alignaddrlsi_vis\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -8256,7 +8286,8 @@\n                 (const_int 7)))]\n   \"TARGET_VIS\"\n   \"alignaddrl\\t%r1, %r2, %0\"\n-  [(set_attr \"type\" \"gsr\")])\n+  [(set_attr \"type\" \"gsr\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n (define_insn \"alignaddrldi_vis\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -8267,7 +8298,8 @@\n                 (const_int 7)))]\n   \"TARGET_VIS\"\n   \"alignaddrl\\t%r1, %r2, %0\"\n-  [(set_attr \"type\" \"gsr\")])\n+  [(set_attr \"type\" \"gsr\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n (define_insn \"pdist_vis\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n@@ -8359,6 +8391,17 @@\n \t UNSPEC_FCMP))]\n   \"TARGET_VIS\"\n   \"fcmp<code><GCM:gcm_name>\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"visl\")\n+   (set_attr \"v3pipe\" \"true\")\n+   (set_attr \"fptype\" \"double\")])\n+\n+(define_insn \"fpcmp<code>8<P:mode>_vis\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+  \t(unspec:P [(gcond:V8QI (match_operand:V8QI 1 \"register_operand\" \"e\")\n+\t\t               (match_operand:V8QI 2 \"register_operand\" \"e\"))]\n+\t UNSPEC_FCMP))]\n+  \"TARGET_VIS4\"\n+  \"fpcmp<code>8\\t%1, %2, %0\"\n   [(set_attr \"type\" \"visl\")\n    (set_attr \"fptype\" \"double\")])\n \n@@ -8427,7 +8470,8 @@\n         (plus:DI (match_dup 1) (match_dup 2)))]\n   \"TARGET_VIS2\"\n   \"bmask\\t%r1, %r2, %0\"\n-  [(set_attr \"type\" \"array\")])\n+  [(set_attr \"type\" \"array\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n (define_insn \"bmasksi_vis\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -8437,7 +8481,8 @@\n         (zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n   \"TARGET_VIS2\"\n   \"bmask\\t%r1, %r2, %0\"\n-  [(set_attr \"type\" \"array\")])\n+  [(set_attr \"type\" \"array\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n (define_insn \"bshuffle<VM64:mode>_vis\"\n   [(set (match_operand:VM64 0 \"register_operand\" \"=e\")\n@@ -8448,7 +8493,8 @@\n   \"TARGET_VIS2\"\n   \"bshuffle\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"double\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n ;; The rtl expanders will happily convert constant permutations on other\n ;; modes down to V8QI.  Rely on this to avoid the complexity of the byte\n@@ -8550,7 +8596,8 @@\n                    UNSPEC_CMASK8))]\n   \"TARGET_VIS3\"\n   \"cmask8\\t%r0\"\n-  [(set_attr \"type\" \"fga\")])\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n (define_insn \"cmask16<P:mode>_vis\"\n   [(set (reg:DI GSR_REG)\n@@ -8559,7 +8606,8 @@\n                    UNSPEC_CMASK16))]\n   \"TARGET_VIS3\"\n   \"cmask16\\t%r0\"\n-  [(set_attr \"type\" \"fga\")])\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n (define_insn \"cmask32<P:mode>_vis\"\n   [(set (reg:DI GSR_REG)\n@@ -8568,7 +8616,8 @@\n                    UNSPEC_CMASK32))]\n   \"TARGET_VIS3\"\n   \"cmask32\\t%r0\"\n-  [(set_attr \"type\" \"fga\")])\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"v3pipe\" \"true\")])\n \n (define_insn \"fchksm16_vis\"\n   [(set (match_operand:V4HI 0 \"register_operand\" \"=e\")\n@@ -8601,6 +8650,7 @@\n   \"TARGET_VIS3\"\n   \"pdistn\\t%1, %2, %0\"\n   [(set_attr \"type\" \"pdistn\")\n+   (set_attr \"v3pipe\" \"true\")\n    (set_attr \"fptype\" \"double\")])\n \n (define_insn \"fmean16_vis\"\n@@ -8628,6 +8678,14 @@\n   \"fp<plusminus_insn>64\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")])\n \n+(define_insn \"<plusminus_insn>v8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=e\")\n+        (plusminus:V8QI (match_operand:V8QI 1 \"register_operand\" \"e\")\n+                        (match_operand:V8QI 2 \"register_operand\" \"e\")))]\n+  \"TARGET_VIS4\"\n+  \"fp<plusminus_insn>8\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"fga\")])\n+\n (define_mode_iterator VASS [V4HI V2SI V2HI V1SI])\n (define_code_iterator vis3_addsub_ss [ss_plus ss_minus])\n (define_code_attr vis3_addsub_ss_insn\n@@ -8641,16 +8699,82 @@\n                              (match_operand:VASS 2 \"register_operand\" \"<vconstr>\")))]\n   \"TARGET_VIS3\"\n   \"<vis3_addsub_ss_insn><vbits>\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"v3pipe\" \"true\")])\n+\n+(define_mode_iterator VMMAX [V8QI V4HI V2SI])\n+(define_code_iterator vis4_minmax [smin smax])\n+(define_code_attr vis4_minmax_insn\n+  [(smin \"fpmin\") (smax \"fpmax\")])\n+(define_code_attr vis4_minmax_patname\n+  [(smin \"min\") (smax \"max\")])\n+\n+(define_insn \"<vis4_minmax_patname><mode>3\"\n+  [(set (match_operand:VMMAX 0 \"register_operand\" \"=<vconstr>\")\n+        (vis4_minmax:VMMAX (match_operand:VMMAX 1 \"register_operand\" \"<vconstr>\")\n+                           (match_operand:VMMAX 2 \"register_operand\" \"<vconstr>\")))]\n+  \"TARGET_VIS4\"\n+  \"<vis4_minmax_insn><vbits>\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"fga\")])\n+\n+(define_code_iterator vis4_uminmax [umin umax])\n+(define_code_attr vis4_uminmax_insn\n+  [(umin \"fpminu\") (umax \"fpmaxu\")])\n+(define_code_attr vis4_uminmax_patname\n+ [(umin \"minu\") (umax \"maxu\")])\n+\n+(define_insn \"<vis4_uminmax_patname><mode>3\"\n+  [(set (match_operand:VMMAX 0 \"register_operand\" \"=<vconstr>\")\n+        (vis4_uminmax:VMMAX (match_operand:VMMAX 1 \"register_operand\" \"<vconstr>\")\n+                            (match_operand:VMMAX 2 \"register_operand\" \"<vconstr>\")))]\n+  \"TARGET_VIS4\"\n+  \"<vis4_uminmax_insn><vbits>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")])\n \n+;; The use of vis3_addsub_ss_patname in the VIS4 instruction below is\n+;; intended.\n+(define_insn \"<vis3_addsub_ss_patname>v8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=e\")\n+        (vis3_addsub_ss:V8QI (match_operand:V8QI 1 \"register_operand\" \"e\")\n+                             (match_operand:V8QI 2 \"register_operand\" \"e\")))]\n+  \"TARGET_VIS4\"\n+  \"<vis3_addsub_ss_insn>8\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"fga\")])\n+\n+(define_mode_iterator VAUS [V4HI V8QI])\n+(define_code_iterator vis4_addsub_us [us_plus us_minus])\n+(define_code_attr vis4_addsub_us_insn\n+  [(us_plus \"fpaddus\") (us_minus \"fpsubus\")])\n+(define_code_attr vis4_addsub_us_patname\n+  [(us_plus \"usadd\") (us_minus \"ussub\")])\n+\n+(define_insn \"<vis4_addsub_us_patname><mode>3\"\n+ [(set (match_operand:VAUS 0 \"register_operand\" \"=<vconstr>\")\n+       (vis4_addsub_us:VAUS (match_operand:VAUS 1 \"register_operand\" \"<vconstr>\")\n+                            (match_operand:VAUS 2 \"register_operand\" \"<vconstr>\")))]\n+ \"TARGET_VIS4\"\n+ \"<vis4_addsub_us_insn><vbits>\\t%1, %2, %0\"\n+ [(set_attr \"type\" \"fga\")])\n+\n (define_insn \"fucmp<code>8<P:mode>_vis\"\n   [(set (match_operand:P 0 \"register_operand\" \"=r\")\n   \t(unspec:P [(gcond:V8QI (match_operand:V8QI 1 \"register_operand\" \"e\")\n \t\t               (match_operand:V8QI 2 \"register_operand\" \"e\"))]\n \t UNSPEC_FUCMP))]\n   \"TARGET_VIS3\"\n   \"fucmp<code>8\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"visl\")])\n+  [(set_attr \"type\" \"visl\")\n+   (set_attr \"v3pipe\" \"true\")])\n+\n+(define_insn \"fpcmpu<code><GCM:gcm_name><P:mode>_vis\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+  \t(unspec:P [(gcond:GCM (match_operand:GCM 1 \"register_operand\" \"e\")\n+\t\t              (match_operand:GCM 2 \"register_operand\" \"e\"))]\n+\t UNSPEC_FUCMP))]\n+  \"TARGET_VIS4\"\n+  \"fpcmpu<code><GCM:gcm_name>\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"visl\")\n+   (set_attr \"fptype\" \"double\")])\n \n (define_insn \"*naddsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")"}, {"sha": "13d41515f0072cf336611fc83e1a2f27e67cc9cb", "filename": "gcc/config/sparc/sparc.opt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.opt?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -73,6 +73,10 @@ mvis3\n Target Report Mask(VIS3)\n Use UltraSPARC Visual Instruction Set version 3.0 extensions.\n \n+mvis4\n+Target Report Mask(VIS4)\n+Use UltraSPARC Visual Instruction Set version 4.0 extensions.\n+\n mcbcond\n Target Report Mask(CBCOND)\n Use UltraSPARC Compare-and-Branch extensions.\n@@ -194,6 +198,9 @@ Enum(sparc_processor_type) String(niagara3) Value(PROCESSOR_NIAGARA3)\n EnumValue\n Enum(sparc_processor_type) String(niagara4) Value(PROCESSOR_NIAGARA4)\n \n+EnumValue\n+Enum(sparc_processor_type) String(niagara7) Value(PROCESSOR_NIAGARA7)\n+\n mcmodel=\n Target RejectNegative Joined Var(sparc_cmodel_string)\n Use given SPARC-V9 code model."}, {"sha": "8b80cc1e56b42bdbf6f54d259b9aeae9e9e5081d", "filename": "gcc/config/sparc/visintrin.h", "status": "modified", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fvisintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfig%2Fsparc%2Fvisintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fvisintrin.h?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -704,6 +704,192 @@ __vis_xmulxhi (__i64 __A, __i64 __B)\n \n #endif /* __VIS__ >= 0x300 */\n \n+#if __VIS__ >= 0x400\n+\n+extern __inline __v8qi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpadd8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpadd8 (__A, __B);\n+}\n+\n+extern __inline __v8qi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpadds8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpadds8 (__A, __B);\n+}\n+\n+extern __inline __v8qi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpaddus8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpaddus8 (__A, __B);\n+}\n+\n+extern __inline __v4hi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpaddus16 (__v4hi __A, __v4hi __B)\n+{\n+  return __builtin_vis_fpaddus16 (__A, __B);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpcmple8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpcmple8 (__A, __B);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpcmpgt8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpcmpgt8 (__A, __B);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpcmpule16 (__v4hi __A, __v4hi __B)\n+{\n+  return __builtin_vis_fpcmpule16 (__A, __B);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpcmpugt16 (__v4hi __A, __v4hi __B)\n+{\n+  return __builtin_vis_fpcmpugt16 (__A, __B);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpcmpule32 (__v2si __A, __v2si __B)\n+{\n+  return __builtin_vis_fpcmpule32 (__A, __B);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpcmpugt32 (__v2si __A, __v2si __B)\n+{\n+  return __builtin_vis_fpcmpugt32 (__A, __B);\n+}\n+\n+extern __inline __v8qi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpmax8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpmax8 (__A, __B);\n+}\n+\n+extern __inline __v4hi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpmax16 (__v4hi __A, __v4hi __B)\n+{\n+  return __builtin_vis_fpmax16 (__A, __B);\n+}\n+\n+extern __inline __v2si\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpmax32 (__v2si __A, __v2si __B)\n+{\n+  return __builtin_vis_fpmax32 (__A, __B);\n+}\n+\n+extern __inline __v8qi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpmaxu8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpmaxu8 (__A, __B);\n+}\n+\n+extern __inline __v4hi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpmaxu16 (__v4hi __A, __v4hi __B)\n+{\n+  return __builtin_vis_fpmaxu16 (__A, __B);\n+}\n+\n+extern __inline __v2si\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpmaxu32 (__v2si __A, __v2si __B)\n+{\n+  return __builtin_vis_fpmaxu32 (__A, __B);\n+}\n+\n+extern __inline __v8qi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpmin8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpmin8 (__A, __B);\n+}\n+\n+extern __inline __v4hi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpmin16 (__v4hi __A, __v4hi __B)\n+{\n+  return __builtin_vis_fpmin16 (__A, __B);\n+}\n+\n+extern __inline __v2si\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpmin32 (__v2si __A, __v2si __B)\n+{\n+  return __builtin_vis_fpmin32 (__A, __B);\n+}\n+\n+extern __inline __v8qi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpminu8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpminu8 (__A, __B);\n+}\n+\n+extern __inline __v4hi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpminu16 (__v4hi __A, __v4hi __B)\n+{\n+  return __builtin_vis_fpminu16 (__A, __B);\n+}\n+\n+extern __inline __v2si\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpminu32 (__v2si __A, __v2si __B)\n+{\n+  return __builtin_vis_fpminu32 (__A, __B);\n+}\n+\n+extern __inline __v8qi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpsub8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpsub8 (__A, __B);\n+}\n+\n+extern __inline __v8qi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpsubs8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpsubs8 (__A, __B);\n+}\n+\n+extern __inline __v8qi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpsubus8 (__v8qi __A, __v8qi __B)\n+{\n+  return __builtin_vis_fpsubus8 (__A, __B);\n+}\n+\n+extern __inline __v4hi\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__vis_fpsubus16 (__v4hi __A, __v4hi __B)\n+{\n+  return __builtin_vis_fpsubus16 (__A, __B);\n+}\n+\n+#endif /* __VIS__ >= 0x400 */\n+\n #endif /* __VIS__ */\n \n #endif  /* _VISINTRIN_H_INCLUDED */"}, {"sha": "bce9ea03c874ea322b50a2f60414ff63bf7c2ff2", "filename": "gcc/configure", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -25122,6 +25122,42 @@ if test $gcc_cv_as_sparc_sparc4 = yes; then\n \n $as_echo \"#define HAVE_AS_SPARC4 1\" >>confdefs.h\n \n+fi\n+\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for SPARC5 and VIS 4.0 instructions\" >&5\n+$as_echo_n \"checking assembler for SPARC5 and VIS 4.0 instructions... \" >&6; }\n+if test \"${gcc_cv_as_sparc_sparc5+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_sparc_sparc5=no\n+  if test x$gcc_cv_as != x; then\n+    $as_echo '.text\n+       .register %g2, #scratch\n+       .register %g3, #scratch\n+       .align 4\n+       subxc %g1, %g2, %g3\n+       fpadd8 %f0, %f2, %f4' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -xarch=sparc5 -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_sparc_sparc5=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_sparc_sparc5\" >&5\n+$as_echo \"$gcc_cv_as_sparc_sparc5\" >&6; }\n+if test $gcc_cv_as_sparc_sparc5 = yes; then\n+\n+$as_echo \"#define HAVE_AS_SPARC5_VIS4 1\" >>confdefs.h\n+\n fi\n \n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for LEON instructions\" >&5"}, {"sha": "6607e760c6a0d7e17c077377e160b407700c4250", "filename": "gcc/configure.ac", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -3928,6 +3928,18 @@ foo:\n       [AC_DEFINE(HAVE_AS_SPARC4, 1,\n                 [Define if your assembler supports SPARC4 instructions.])])\n \n+    gcc_GAS_CHECK_FEATURE([SPARC5 and VIS 4.0 instructions],\n+      gcc_cv_as_sparc_sparc5,,\n+      [-xarch=sparc5],\n+      [.text\n+       .register %g2, #scratch\n+       .register %g3, #scratch\n+       .align 4\n+       subxc %g1, %g2, %g3\n+       fpadd8 %f0, %f2, %f4],,\n+      [AC_DEFINE(HAVE_AS_SPARC5_VIS4, 1,\n+                [Define if your assembler supports SPARC5 and VIS 4.0 instructions.])])\n+\n     gcc_GAS_CHECK_FEATURE([LEON instructions],\n       gcc_cv_as_sparc_leon,,\n       [-Aleon],"}, {"sha": "c85e6dbb5fe39628e83de68e51f066e8bf08109c", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -18163,6 +18163,45 @@ int64_t __builtin_vis_xmulx (int64_t, int64_t);\n int64_t __builtin_vis_xmulxhi (int64_t, int64_t);\n @end smallexample\n \n+When you use the @option{-mvis4} switch, the VIS version 4.0 built-in\n+functions also become available:\n+\n+@smallexample\n+v8qi __builtin_vis_fpadd8 (v8qi, v8qi);\n+v8qi __builtin_vis_fpadds8 (v8qi, v8qi);\n+v8qi __builtin_vis_fpaddus8 (v8qi, v8qi);\n+v4hi __builtin_vis_fpaddus16 (v4hi, v4hi);\n+\n+v8qi __builtin_vis_fpsub8 (v8qi, v8qi);\n+v8qi __builtin_vis_fpsubs8 (v8qi, v8qi);\n+v8qi __builtin_vis_fpsubus8 (v8qi, v8qi);\n+v4hi __builtin_vis_fpsubus16 (v4hi, v4hi);\n+\n+long __builtin_vis_fpcmple8 (v8qi, v8qi);\n+long __builtin_vis_fpcmpgt8 (v8qi, v8qi);\n+long __builtin_vis_fpcmpule16 (v4hi, v4hi);\n+long __builtin_vis_fpcmpugt16 (v4hi, v4hi);\n+long __builtin_vis_fpcmpule32 (v2si, v2si);\n+long __builtin_vis_fpcmpugt32 (v2si, v2si);\n+\n+v8qi __builtin_vis_fpmax8 (v8qi, v8qi);\n+v4hi __builtin_vis_fpmax16 (v4hi, v4hi);\n+v2si __builtin_vis_fpmax32 (v2si, v2si);\n+\n+v8qi __builtin_vis_fpmaxu8 (v8qi, v8qi);\n+v4hi __builtin_vis_fpmaxu16 (v4hi, v4hi);\n+v2si __builtin_vis_fpmaxu32 (v2si, v2si);\n+\n+\n+v8qi __builtin_vis_fpmin8 (v8qi, v8qi);\n+v4hi __builtin_vis_fpmin16 (v4hi, v4hi);\n+v2si __builtin_vis_fpmin32 (v2si, v2si);\n+\n+v8qi __builtin_vis_fpminu8 (v8qi, v8qi);\n+v4hi __builtin_vis_fpminu16 (v4hi, v4hi);\n+v2si __builtin_vis_fpminu32 (v2si, v2si);\n+@end smallexample\n+\n @node SPU Built-in Functions\n @subsection SPU Built-in Functions\n "}, {"sha": "4a28935ccd1e5be626330c8be59d95494ca62e5f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -22197,7 +22197,7 @@ for machine type @var{cpu_type}.  Supported values for @var{cpu_type} are\n @samp{leon}, @samp{leon3}, @samp{leon3v7}, @samp{sparclite}, @samp{f930},\n @samp{f934}, @samp{sparclite86x}, @samp{sparclet}, @samp{tsc701}, @samp{v9},\n @samp{ultrasparc}, @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2},\n-@samp{niagara3} and @samp{niagara4}.\n+@samp{niagara3}, @samp{niagara4} and @samp{niagara7}.\n \n Native Solaris and GNU/Linux toolchains also support the value @samp{native},\n which selects the best architecture option for the host processor.\n@@ -22225,7 +22225,7 @@ f930, f934, sparclite86x\n tsc701\n \n @item v9\n-ultrasparc, ultrasparc3, niagara, niagara2, niagara3, niagara4\n+ultrasparc, ultrasparc3, niagara, niagara2, niagara3, niagara4, niagara7\n @end table\n \n By default (unless configured otherwise), GCC generates code for the V7\n@@ -22267,7 +22267,9 @@ Sun UltraSPARC T1 chips.  With @option{-mcpu=niagara2}, the compiler\n additionally optimizes it for Sun UltraSPARC T2 chips. With\n @option{-mcpu=niagara3}, the compiler additionally optimizes it for Sun\n UltraSPARC T3 chips.  With @option{-mcpu=niagara4}, the compiler\n-additionally optimizes it for Sun UltraSPARC T4 chips.\n+additionally optimizes it for Sun UltraSPARC T4 chips.  With\n+@option{-mcpu=niagara7}, the compiler additionally optimizes it for\n+Oracle SPARC M7 chips.\n \n @item -mtune=@var{cpu_type}\n @opindex mtune\n@@ -22277,12 +22279,13 @@ option @option{-mcpu=@var{cpu_type}} does.\n \n The same values for @option{-mcpu=@var{cpu_type}} can be used for\n @option{-mtune=@var{cpu_type}}, but the only useful values are those\n-that select a particular CPU implementation.  Those are @samp{cypress},\n-@samp{supersparc}, @samp{hypersparc}, @samp{leon}, @samp{leon3},\n-@samp{leon3v7}, @samp{f930}, @samp{f934}, @samp{sparclite86x}, @samp{tsc701},\n-@samp{ultrasparc}, @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2},\n-@samp{niagara3} and @samp{niagara4}.  With native Solaris and GNU/Linux\n-toolchains, @samp{native} can also be used.\n+that select a particular CPU implementation.  Those are\n+@samp{cypress}, @samp{supersparc}, @samp{hypersparc}, @samp{leon},\n+@samp{leon3}, @samp{leon3v7}, @samp{f930}, @samp{f934},\n+@samp{sparclite86x}, @samp{tsc701}, @samp{ultrasparc},\n+@samp{ultrasparc3}, @samp{niagara}, @samp{niagara2}, @samp{niagara3},\n+@samp{niagara4} and @samp{niagara7}.  With native Solaris and\n+GNU/Linux toolchains, @samp{native} can also be used.\n \n @item -mv8plus\n @itemx -mno-v8plus\n@@ -22320,6 +22323,16 @@ default is @option{-mvis3} when targeting a cpu that supports such\n instructions, such as niagara-3 and later.  Setting @option{-mvis3}\n also sets @option{-mvis2} and @option{-mvis}.\n \n+@item -mvis4\n+@itemx -mno-vis4\n+@opindex mvis4\n+@opindex mno-vis4\n+With @option{-mvis4}, GCC generates code that takes advantage of\n+version 4.0 of the UltraSPARC Visual Instruction Set extensions.  The\n+default is @option{-mvis4} when targeting a cpu that supports such\n+instructions, such as niagara-7 and later.  Setting @option{-mvis4}\n+also sets @option{-mvis3}, @option{-mvis2} and @option{-mvis}.\n+\n @item -mcbcond\n @itemx -mno-cbcond\n @opindex mcbcond"}, {"sha": "e5d1407c9e33c50fefe2d3cc1e7372a926a01347", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -1,3 +1,9 @@\n+2016-06-06  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* gcc.target/sparc/vis4misc.c: New file.\n+\t* gcc.target/sparc/fpcmp.c: Likewise.\n+\t* gcc.target/sparc/fpcmpu.c: Likewise.\n+\n 2016-06-06  Alan Hayward  <alan.hayward@arm.com>\n \n \t* gcc.dg/vect/vect-live-1.c: Use additional-options."}, {"sha": "1255d67442f294820e08942dccb0f724c3012be1", "filename": "gcc/testsuite/gcc.target/sparc/fpcmp.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmp.c?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mvis4\" } */\n+\n+typedef unsigned char vec8 __attribute__((vector_size(8)));\n+\n+long test_fpcmple8 (vec8 a, vec8 b)\n+{\n+  return __builtin_vis_fpcmple8 (a, b);\n+}\n+\n+long test_fpcmpgt8 (vec8 a, vec8 b)\n+{\n+  return __builtin_vis_fpcmpgt8 (a, b);\n+}\n+\n+/* { dg-final { scan-assembler \"fpcmple8\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpgt8\\t%\" } } */\n+"}, {"sha": "816a22d7078c544971f500e07ca17768f67181cb", "filename": "gcc/testsuite/gcc.target/sparc/fpcmpu.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpu.c?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mvis4\" } */\n+\n+\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int vec32 __attribute__((vector_size(8)));\n+\n+long test_fpcmpule16 (vec16 a, vec16 b)\n+{\n+  return __builtin_vis_fpcmpule16 (a, b);\n+}\n+\n+long test_fpcmpugt16 (vec16 a, vec16 b)\n+{\n+  return __builtin_vis_fpcmpugt16 (a, b);\n+}\n+\n+long test_fpcmpule32 (vec32 a, vec32 b)\n+{\n+  return __builtin_vis_fpcmpule32 (a, b);\n+}\n+\n+long test_fpcmpugt32 (vec32 a, vec32 b)\n+{\n+  return __builtin_vis_fpcmpugt32 (a, b);\n+}\n+\n+/* { dg-final { scan-assembler \"fpcmpule16\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpugt16\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpule32\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpugt32\\t%\" } } */"}, {"sha": "b520b12b381b9cfd17db87905d7ec7c99d84f467", "filename": "gcc/testsuite/gcc.target/sparc/vis4misc.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvis4misc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690f24b7754826f08fc19119dd3a30a6c07e9919/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvis4misc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvis4misc.c?ref=690f24b7754826f08fc19119dd3a30a6c07e9919", "patch": "@@ -0,0 +1,126 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mvis4\" } */\n+typedef int __v2si __attribute__((vector_size(8)));\n+typedef short __v4hi __attribute__((vector_size(8)));\n+typedef unsigned char __v8qi __attribute__((vector_size(8)));\n+\n+__v8qi test_fpadd8 (__v8qi x, __v8qi y)\n+{\n+  return __builtin_vis_fpadd8 (x, y);\n+}\n+\n+__v8qi test_fpadds8 (__v8qi x, __v8qi y)\n+{\n+  return __builtin_vis_fpadds8 (x, y);\n+}\n+\n+__v8qi test_fpaddus8 (__v8qi x, __v8qi y)\n+{\n+  return __builtin_vis_fpaddus8 (x, y);\n+}\n+\n+__v4hi test_fpaddus16 (__v4hi x, __v4hi y)\n+{\n+  return __builtin_vis_fpaddus16 (x, y);\n+}\n+\n+__v8qi test_fpsub8 (__v8qi x, __v8qi y)\n+{\n+  return __builtin_vis_fpsub8 (x, y);\n+}\n+\n+__v8qi test_fpsubs8 (__v8qi x, __v8qi y)\n+{\n+  return __builtin_vis_fpsubs8 (x, y);\n+}\n+\n+__v8qi test_fpsubus8 (__v8qi x, __v8qi y)\n+{\n+  return __builtin_vis_fpsubus8 (x, y);\n+}\n+\n+__v4hi test_fpsubus16 (__v4hi x, __v4hi y)\n+{\n+  return __builtin_vis_fpsubus16 (x, y);\n+}\n+\n+__v8qi test_fpmax8 (__v8qi x, __v8qi y)\n+{\n+  return __builtin_vis_fpmax8 (x, y);\n+}\n+\n+__v4hi test_fpmax16 (__v4hi x, __v4hi y)\n+{\n+  return __builtin_vis_fpmax16 (x, y);\n+}\n+\n+__v2si test_fpmax32 (__v2si x, __v2si y)\n+{\n+  return __builtin_vis_fpmax32 (x, y);\n+}\n+\n+__v8qi test_fpmaxu8 (__v8qi x, __v8qi y)\n+{\n+  return __builtin_vis_fpmaxu8 (x, y);\n+}\n+\n+__v4hi test_fpmaxu16 (__v4hi x, __v4hi y)\n+{\n+  return __builtin_vis_fpmaxu16 (x, y);\n+}\n+\n+__v2si test_fpmaxu32 (__v2si x, __v2si y)\n+{\n+  return __builtin_vis_fpmaxu32 (x, y);\n+}\n+\n+__v8qi test_fpmin8 (__v8qi x, __v8qi y)\n+{\n+  return __builtin_vis_fpmin8 (x, y);\n+}\n+\n+__v4hi test_fpmin16 (__v4hi x, __v4hi y)\n+{\n+  return __builtin_vis_fpmin16 (x, y);\n+}\n+\n+__v2si test_fpmin32 (__v2si x, __v2si y)\n+{\n+  return __builtin_vis_fpmin32 (x, y);\n+}\n+\n+__v8qi test_fpminu8 (__v8qi x, __v8qi y)\n+{\n+  return __builtin_vis_fpminu8 (x, y);\n+}\n+\n+__v4hi test_fpminu16 (__v4hi x, __v4hi y)\n+{\n+  return __builtin_vis_fpminu16 (x, y);\n+}\n+\n+__v2si test_fpminu32 (__v2si x, __v2si y)\n+{\n+  return __builtin_vis_fpminu32 (x, y);\n+}\n+\n+/* { dg-final { scan-assembler \"fpadd8\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpadds8\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpaddus8\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpaddus16\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpsub8\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpsubs8\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpsubus8\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpsubus16\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpmax8\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpmax16\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpmax32\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpmaxu8\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpmaxu16\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpmaxu32\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpmin8\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpmin16\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpmin32\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpminu8\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpminu16\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpminu32\\t%\" } } */"}]}