{"sha": "279b805713fd498afb7986698a2e3406bc947d87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc5YjgwNTcxM2ZkNDk4YWZiNzk4NjY5OGEyZTM0MDZiYzk0N2Q4Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-02T18:26:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-02T18:26:16Z"}, "message": "Refactor expand_vec_perm\n\nThis patch splits the variable handling out of expand_vec_perm into\na subroutine, so that the next patch can use a different interface\nfor expanding constant permutes.  expand_vec_perm now does all the\nCONST_VECTOR handling directly and defers to expand_vec_perm_var\nfor other rtx codes.  Handling CONST_VECTORs includes handling the\nfallback to variable permutes.\n\nThe patch also adds an assert for valid optab modes to expand_vec_perm_1,\nso that we get it when using optabs for CONST_VECTORs.  The MODE_VECTOR_INT\npart was previously in expand_vec_perm and the mode_for_int_vector part\nis new.\n\nMost of the patch is just reindentation.\n\n2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* optabs.c (expand_vec_perm_1): Assert that SEL has an integer\n\tvector mode and that that mode matches the mode of the data\n\tbeing permuted.\n\t(expand_vec_perm): Split handling of non-CONST_VECTOR selectors\n\tout into expand_vec_perm_var.  Do all CONST_VECTOR handling here,\n\tdirectly using expand_vec_perm_1 when forcing selectors into\n\tregisters.\n\t(expand_vec_perm_var): New function, split out from expand_vec_perm.\n\nFrom-SVN: r256092", "tree": {"sha": "93129a39bf65aef7a97f30ca8329f00826514d79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93129a39bf65aef7a97f30ca8329f00826514d79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/279b805713fd498afb7986698a2e3406bc947d87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279b805713fd498afb7986698a2e3406bc947d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/279b805713fd498afb7986698a2e3406bc947d87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279b805713fd498afb7986698a2e3406bc947d87/comments", "author": null, "committer": null, "parents": [{"sha": "7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac7e2868d450dfb9080166ddc4abcc21b86fab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ac7e2868d450dfb9080166ddc4abcc21b86fab3"}], "stats": {"total": 269, "additions": 163, "deletions": 106}, "files": [{"sha": "b82ea04f0f4b3ffe7dcb364b197ac13c1c5b4690", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279b805713fd498afb7986698a2e3406bc947d87/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279b805713fd498afb7986698a2e3406bc947d87/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=279b805713fd498afb7986698a2e3406bc947d87", "patch": "@@ -1,3 +1,14 @@\n+2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* optabs.c (expand_vec_perm_1): Assert that SEL has an integer\n+\tvector mode and that that mode matches the mode of the data\n+\tbeing permuted.\n+\t(expand_vec_perm): Split handling of non-CONST_VECTOR selectors\n+\tout into expand_vec_perm_var.  Do all CONST_VECTOR handling here,\n+\tdirectly using expand_vec_perm_1 when forcing selectors into\n+\tregisters.\n+\t(expand_vec_perm_var): New function, split out from expand_vec_perm.\n+\n 2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* optabs-query.h (can_vec_perm_p): Delete."}, {"sha": "3549b4a8495989d3723164c4fb7a3af932688a35", "filename": "gcc/optabs.c", "status": "modified", "additions": 152, "deletions": 106, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279b805713fd498afb7986698a2e3406bc947d87/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279b805713fd498afb7986698a2e3406bc947d87/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=279b805713fd498afb7986698a2e3406bc947d87", "patch": "@@ -5425,6 +5425,8 @@ expand_vec_perm_1 (enum insn_code icode, rtx target,\n   machine_mode smode = GET_MODE (sel);\n   struct expand_operand ops[4];\n \n+  gcc_assert (GET_MODE_CLASS (smode) == MODE_VECTOR_INT\n+\t      || mode_for_int_vector (tmode).require () == smode);\n   create_output_operand (&ops[0], target, tmode);\n   create_input_operand (&ops[3], sel, smode);\n \n@@ -5451,8 +5453,13 @@ expand_vec_perm_1 (enum insn_code icode, rtx target,\n   return NULL_RTX;\n }\n \n-/* Generate instructions for vec_perm optab given its mode\n-   and three operands.  */\n+static rtx expand_vec_perm_var (machine_mode, rtx, rtx, rtx, rtx);\n+\n+/* Implement a permutation of vectors v0 and v1 using the permutation\n+   vector in SEL and return the result.  Use TARGET to hold the result\n+   if nonnull and convenient.\n+\n+   MODE is the mode of the vectors being permuted (V0 and V1).  */\n \n rtx\n expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n@@ -5463,6 +5470,9 @@ expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   rtx tmp, sel_qi = NULL;\n   rtvec vec;\n \n+  if (GET_CODE (sel) != CONST_VECTOR)\n+    return expand_vec_perm_var (mode, v0, v1, sel, target);\n+\n   if (!target || GET_MODE (target) != mode)\n     target = gen_reg_rtx (mode);\n \n@@ -5475,86 +5485,125 @@ expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   if (!qimode_for_vec_perm (mode).exists (&qimode))\n     qimode = VOIDmode;\n \n-  /* If the input is a constant, expand it specially.  */\n-  gcc_assert (GET_MODE_CLASS (GET_MODE (sel)) == MODE_VECTOR_INT);\n-  if (GET_CODE (sel) == CONST_VECTOR)\n-    {\n-      /* See if this can be handled with a vec_shr.  We only do this if the\n-\t second vector is all zeroes.  */\n-      enum insn_code shift_code = optab_handler (vec_shr_optab, mode);\n-      enum insn_code shift_code_qi = ((qimode != VOIDmode && qimode != mode)\n-\t\t\t\t      ? optab_handler (vec_shr_optab, qimode)\n-\t\t\t\t      : CODE_FOR_nothing);\n-      rtx shift_amt = NULL_RTX;\n-      if (v1 == CONST0_RTX (GET_MODE (v1))\n-\t  && (shift_code != CODE_FOR_nothing\n-\t      || shift_code_qi != CODE_FOR_nothing))\n+  /* See if this can be handled with a vec_shr.  We only do this if the\n+     second vector is all zeroes.  */\n+  insn_code shift_code = optab_handler (vec_shr_optab, mode);\n+  insn_code shift_code_qi = ((qimode != VOIDmode && qimode != mode)\n+\t\t\t     ? optab_handler (vec_shr_optab, qimode)\n+\t\t\t     : CODE_FOR_nothing);\n+\n+  if (v1 == CONST0_RTX (GET_MODE (v1))\n+      && (shift_code != CODE_FOR_nothing\n+\t  || shift_code_qi != CODE_FOR_nothing))\n+    {\n+      rtx shift_amt = shift_amt_for_vec_perm_mask (sel);\n+      if (shift_amt)\n \t{\n-\t  shift_amt = shift_amt_for_vec_perm_mask (sel);\n-\t  if (shift_amt)\n+\t  struct expand_operand ops[3];\n+\t  if (shift_code != CODE_FOR_nothing)\n \t    {\n-\t      struct expand_operand ops[3];\n-\t      if (shift_code != CODE_FOR_nothing)\n-\t\t{\n-\t\t  create_output_operand (&ops[0], target, mode);\n-\t\t  create_input_operand (&ops[1], v0, mode);\n-\t\t  create_convert_operand_from_type (&ops[2], shift_amt,\n-\t\t\t\t\t\t    sizetype);\n-\t\t  if (maybe_expand_insn (shift_code, 3, ops))\n-\t\t    return ops[0].value;\n-\t\t}\n-\t      if (shift_code_qi != CODE_FOR_nothing)\n-\t\t{\n-\t\t  tmp = gen_reg_rtx (qimode);\n-\t\t  create_output_operand (&ops[0], tmp, qimode);\n-\t\t  create_input_operand (&ops[1], gen_lowpart (qimode, v0),\n-\t\t\t\t\tqimode);\n-\t\t  create_convert_operand_from_type (&ops[2], shift_amt,\n-\t\t\t\t\t\t    sizetype);\n-\t\t  if (maybe_expand_insn (shift_code_qi, 3, ops))\n-\t\t    return gen_lowpart (mode, ops[0].value);\n-\t\t}\n+\t      create_output_operand (&ops[0], target, mode);\n+\t      create_input_operand (&ops[1], v0, mode);\n+\t      create_convert_operand_from_type (&ops[2], shift_amt, sizetype);\n+\t      if (maybe_expand_insn (shift_code, 3, ops))\n+\t\treturn ops[0].value;\n+\t    }\n+\t  if (shift_code_qi != CODE_FOR_nothing)\n+\t    {\n+\t      rtx tmp = gen_reg_rtx (qimode);\n+\t      create_output_operand (&ops[0], tmp, qimode);\n+\t      create_input_operand (&ops[1], gen_lowpart (qimode, v0), qimode);\n+\t      create_convert_operand_from_type (&ops[2], shift_amt, sizetype);\n+\t      if (maybe_expand_insn (shift_code_qi, 3, ops))\n+\t\treturn gen_lowpart (mode, ops[0].value);\n \t    }\n \t}\n+    }\n \n-      icode = direct_optab_handler (vec_perm_const_optab, mode);\n-      if (icode != CODE_FOR_nothing)\n+  icode = direct_optab_handler (vec_perm_const_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      tmp = expand_vec_perm_1 (icode, target, v0, v1, sel);\n+      if (tmp)\n+\treturn tmp;\n+    }\n+\n+  /* Fall back to a constant byte-based permutation.  */\n+  if (qimode != VOIDmode)\n+    {\n+      vec = rtvec_alloc (w);\n+      for (i = 0; i < e; ++i)\n \t{\n-\t  tmp = expand_vec_perm_1 (icode, target, v0, v1, sel);\n-\t  if (tmp)\n-\t    return tmp;\n+\t  unsigned int j, this_e;\n+\n+\t  this_e = INTVAL (CONST_VECTOR_ELT (sel, i));\n+\t  this_e &= 2 * e - 1;\n+\t  this_e *= u;\n+\n+\t  for (j = 0; j < u; ++j)\n+\t    RTVEC_ELT (vec, i * u + j) = GEN_INT (this_e + j);\n \t}\n+      sel_qi = gen_rtx_CONST_VECTOR (qimode, vec);\n \n-      /* Fall back to a constant byte-based permutation.  */\n-      if (qimode != VOIDmode)\n+      icode = direct_optab_handler (vec_perm_const_optab, qimode);\n+      if (icode != CODE_FOR_nothing)\n \t{\n-\t  vec = rtvec_alloc (w);\n-\t  for (i = 0; i < e; ++i)\n-\t    {\n-\t      unsigned int j, this_e;\n+\t  tmp = gen_reg_rtx (qimode);\n+\t  tmp = expand_vec_perm_1 (icode, tmp, gen_lowpart (qimode, v0),\n+\t\t\t\t   gen_lowpart (qimode, v1), sel_qi);\n+\t  if (tmp)\n+\t    return gen_lowpart (mode, tmp);\n+\t}\n+    }\n \n-\t      this_e = INTVAL (CONST_VECTOR_ELT (sel, i));\n-\t      this_e &= 2 * e - 1;\n-\t      this_e *= u;\n+  /* Otherwise expand as a fully variable permuation.  */\n \n-\t      for (j = 0; j < u; ++j)\n-\t\tRTVEC_ELT (vec, i * u + j) = GEN_INT (this_e + j);\n-\t    }\n-\t  sel_qi = gen_rtx_CONST_VECTOR (qimode, vec);\n+  icode = direct_optab_handler (vec_perm_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      rtx tmp = expand_vec_perm_1 (icode, target, v0, v1, sel);\n+      if (tmp)\n+\treturn tmp;\n+    }\n \n-\t  icode = direct_optab_handler (vec_perm_const_optab, qimode);\n-\t  if (icode != CODE_FOR_nothing)\n-\t    {\n-\t      tmp = mode != qimode ? gen_reg_rtx (qimode) : target;\n-\t      tmp = expand_vec_perm_1 (icode, tmp, gen_lowpart (qimode, v0),\n-\t\t\t\t       gen_lowpart (qimode, v1), sel_qi);\n-\t      if (tmp)\n-\t\treturn gen_lowpart (mode, tmp);\n-\t    }\n+  if (qimode != VOIDmode)\n+    {\n+      icode = direct_optab_handler (vec_perm_optab, qimode);\n+      if (icode != CODE_FOR_nothing)\n+\t{\n+\t  rtx tmp = gen_reg_rtx (qimode);\n+\t  tmp = expand_vec_perm_1 (icode, tmp, gen_lowpart (qimode, v0),\n+\t\t\t\t   gen_lowpart (qimode, v1), sel_qi);\n+\t  if (tmp)\n+\t    return gen_lowpart (mode, tmp);\n \t}\n     }\n \n-  /* Otherwise expand as a fully variable permuation.  */\n+  return NULL_RTX;\n+}\n+\n+/* Implement a permutation of vectors v0 and v1 using the permutation\n+   vector in SEL and return the result.  Use TARGET to hold the result\n+   if nonnull and convenient.\n+\n+   MODE is the mode of the vectors being permuted (V0 and V1).\n+   SEL must have the integer equivalent of MODE and is known to be\n+   unsuitable for permutes with a constant permutation vector.  */\n+\n+static rtx\n+expand_vec_perm_var (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n+{\n+  enum insn_code icode;\n+  unsigned int i, w, u;\n+  rtx tmp, sel_qi;\n+  rtvec vec;\n+\n+  w = GET_MODE_SIZE (mode);\n+  u = GET_MODE_UNIT_SIZE (mode);\n+\n+  if (!target || GET_MODE (target) != mode)\n+    target = gen_reg_rtx (mode);\n+\n   icode = direct_optab_handler (vec_perm_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n@@ -5565,51 +5614,48 @@ expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n \n   /* As a special case to aid several targets, lower the element-based\n      permutation to a byte-based permutation and try again.  */\n-  if (qimode == VOIDmode)\n+  machine_mode qimode;\n+  if (!qimode_for_vec_perm (mode).exists (&qimode))\n     return NULL_RTX;\n   icode = direct_optab_handler (vec_perm_optab, qimode);\n   if (icode == CODE_FOR_nothing)\n     return NULL_RTX;\n \n-  if (sel_qi == NULL)\n-    {\n-      /* Multiply each element by its byte size.  */\n-      machine_mode selmode = GET_MODE (sel);\n-      if (u == 2)\n-\tsel = expand_simple_binop (selmode, PLUS, sel, sel,\n-\t\t\t\t   NULL, 0, OPTAB_DIRECT);\n-      else\n-\tsel = expand_simple_binop (selmode, ASHIFT, sel,\n-\t\t\t\t   gen_int_shift_amount (selmode,\n-\t\t\t\t\t\t\t exact_log2 (u)),\n-\t\t\t\t   NULL, 0, OPTAB_DIRECT);\n-      gcc_assert (sel != NULL);\n+  /* Multiply each element by its byte size.  */\n+  machine_mode selmode = GET_MODE (sel);\n+  if (u == 2)\n+    sel = expand_simple_binop (selmode, PLUS, sel, sel,\n+\t\t\t       NULL, 0, OPTAB_DIRECT);\n+  else\n+    sel = expand_simple_binop (selmode, ASHIFT, sel,\n+\t\t\t       gen_int_shift_amount (selmode, exact_log2 (u)),\n+\t\t\t       NULL, 0, OPTAB_DIRECT);\n+  gcc_assert (sel != NULL);\n \n-      /* Broadcast the low byte each element into each of its bytes.  */\n-      vec = rtvec_alloc (w);\n-      for (i = 0; i < w; ++i)\n-\t{\n-\t  int this_e = i / u * u;\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    this_e += u - 1;\n-\t  RTVEC_ELT (vec, i) = GEN_INT (this_e);\n-\t}\n-      tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n-      sel = gen_lowpart (qimode, sel);\n-      sel = expand_vec_perm (qimode, sel, sel, tmp, NULL);\n-      gcc_assert (sel != NULL);\n-\n-      /* Add the byte offset to each byte element.  */\n-      /* Note that the definition of the indicies here is memory ordering,\n-\t so there should be no difference between big and little endian.  */\n-      vec = rtvec_alloc (w);\n-      for (i = 0; i < w; ++i)\n-\tRTVEC_ELT (vec, i) = GEN_INT (i % u);\n-      tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n-      sel_qi = expand_simple_binop (qimode, PLUS, sel, tmp,\n-\t\t\t\t    sel, 0, OPTAB_DIRECT);\n-      gcc_assert (sel_qi != NULL);\n-    }\n+  /* Broadcast the low byte each element into each of its bytes.  */\n+  vec = rtvec_alloc (w);\n+  for (i = 0; i < w; ++i)\n+    {\n+      int this_e = i / u * u;\n+      if (BYTES_BIG_ENDIAN)\n+\tthis_e += u - 1;\n+      RTVEC_ELT (vec, i) = GEN_INT (this_e);\n+    }\n+  tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n+  sel = gen_lowpart (qimode, sel);\n+  sel = expand_vec_perm (qimode, sel, sel, tmp, NULL);\n+  gcc_assert (sel != NULL);\n+\n+  /* Add the byte offset to each byte element.  */\n+  /* Note that the definition of the indicies here is memory ordering,\n+     so there should be no difference between big and little endian.  */\n+  vec = rtvec_alloc (w);\n+  for (i = 0; i < w; ++i)\n+    RTVEC_ELT (vec, i) = GEN_INT (i % u);\n+  tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n+  sel_qi = expand_simple_binop (qimode, PLUS, sel, tmp,\n+\t\t\t\tsel, 0, OPTAB_DIRECT);\n+  gcc_assert (sel_qi != NULL);\n \n   tmp = mode != qimode ? gen_reg_rtx (qimode) : target;\n   tmp = expand_vec_perm_1 (icode, tmp, gen_lowpart (qimode, v0),"}]}