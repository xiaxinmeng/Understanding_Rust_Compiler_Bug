{"sha": "0527bc4ebf78a3e1ae984f978fb4f7118a180add", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUyN2JjNGViZjc4YTNlMWFlOTg0Zjk3OGZiNGY3MTE4YTE4MGFkZA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-11-01T22:56:54Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-11-01T22:56:54Z"}, "message": "re PR preprocessor/12847 (xxx.c:1:20: xxxx.h: No such file or directory)\n\n\tPR preprocessor/12847\n\t* cppfiles.c, cppexp.c, cpperror.c, cpplib.h, cpplib.c, cpplex.c,\n\tcppinit.c, cpptrad.c, cppmacro.c, fix-header.c, cpppch.c, c-pch.c,\n\tc-incpath.c, cppcharset.c (DL_WARNING, DL_WARNING_SYSHDR, DL_PEDWARN,\n\tDL_ERROR, DL_ICE, DL_EXTRACT, DL_WARNING_P): Prefix macro names with\n\t\"CPP_\".\n\nFrom-SVN: r73183", "tree": {"sha": "968c051f5c6b85312c57b38b07efd46743674b3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/968c051f5c6b85312c57b38b07efd46743674b3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0527bc4ebf78a3e1ae984f978fb4f7118a180add", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0527bc4ebf78a3e1ae984f978fb4f7118a180add", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0527bc4ebf78a3e1ae984f978fb4f7118a180add", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0527bc4ebf78a3e1ae984f978fb4f7118a180add/comments", "author": null, "committer": null, "parents": [{"sha": "2f7b62efc51dd853ab5fa6e36cc0d15c831d6796", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7b62efc51dd853ab5fa6e36cc0d15c831d6796", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f7b62efc51dd853ab5fa6e36cc0d15c831d6796"}], "stats": {"total": 447, "additions": 237, "deletions": 210}, "files": [{"sha": "76ef0df3caf340e7ae36d4baa4fe474e07ed80d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -1,3 +1,12 @@\n+2003-11-01  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR preprocessor/12847\n+\t* cppfiles.c, cppexp.c, cpperror.c, cpplib.h, cpplib.c, cpplex.c,\n+\tcppinit.c, cpptrad.c, cppmacro.c, fix-header.c, cpppch.c, c-pch.c,\n+\tc-incpath.c, cppcharset.c (DL_WARNING, DL_WARNING_SYSHDR, DL_PEDWARN,\n+\tDL_ERROR, DL_ICE, DL_EXTRACT, DL_WARNING_P): Prefix macro names with\n+\t\"CPP_\".\n+\n 2003-11-01  Fariborz Jahanian  <fjahanian@apple.com>\n \n \t* config/rs6000/rs6000.c (rs6000_mixed_function_arg): Correct"}, {"sha": "7b08c1a12a3ccb7231eadf278a629377e704fc38", "filename": "gcc/c-incpath.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -187,12 +187,12 @@ remove_duplicates (cpp_reader *pfile, struct cpp_dir *head,\n \t{\n \t  /* Dirs that don't exist are silently ignored, unless verbose.  */\n \t  if (errno != ENOENT)\n-\t    cpp_errno (pfile, DL_ERROR, cur->name);\n+\t    cpp_errno (pfile, CPP_DL_ERROR, cur->name);\n \t  else\n \t    reason = REASON_NOENT;\n \t}\n       else if (!S_ISDIR (st.st_mode))\n-\tcpp_error_with_line (pfile, DL_ERROR, 0, 0,\n+\tcpp_error_with_line (pfile, CPP_DL_ERROR, 0, 0,\n \t\t\t     \"%s: not a directory\", cur->name);\n       else\n \t{"}, {"sha": "a30310226ff4bd3b6e8e8c13cb5844e9ed9ca2e9", "filename": "gcc/c-pch.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -225,15 +225,15 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n \t  if (memcmp (ident, pch_ident, 5) == 0)\n \t    /* It's a PCH, for the right language, but has the wrong version.\n \t     */\n-\t    cpp_error (pfile, DL_WARNING, \n+\t    cpp_error (pfile, CPP_DL_WARNING, \n \t\t       \"%s: not compatible with this GCC version\", name);\n \t  else if (memcmp (ident, pch_ident, 4) == 0)\n \t    /* It's a PCH for the wrong language.  */\n-\t    cpp_error (pfile, DL_WARNING, \"%s: not for %s\", name,\n+\t    cpp_error (pfile, CPP_DL_WARNING, \"%s: not for %s\", name,\n \t\t       lang_hooks.name);\n \t  else \n \t    /* Not any kind of PCH.  */\n-\t    cpp_error (pfile, DL_WARNING, \"%s: not a PCH file\", name);\n+\t    cpp_error (pfile, CPP_DL_WARNING, \"%s: not a PCH file\", name);\n \t}\n       return 2;\n     }\n@@ -251,7 +251,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n       || memcmp (host_machine, short_strings, strlen (host_machine)) != 0)\n     {\n       if (cpp_get_options (pfile)->warn_invalid_pch)\n-\tcpp_error (pfile, DL_WARNING, \n+\tcpp_error (pfile, CPP_DL_WARNING, \n \t\t   \"%s: created on host `%.*s', but used on host `%s'\", name,\n \t\t   v.host_machine_length, short_strings, host_machine);\n       return 2;\n@@ -261,7 +261,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n \t\t strlen (target_machine)) != 0)\n     {\n       if (cpp_get_options (pfile)->warn_invalid_pch)\n-\tcpp_error (pfile, DL_WARNING, \n+\tcpp_error (pfile, CPP_DL_WARNING, \n \t\t   \"%s: created for target `%.*s', but used for target `%s'\", \n \t\t   name, v.target_machine_length, \n \t\t   short_strings + v.host_machine_length, target_machine);\n@@ -274,7 +274,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n \t\t v.version_length) != 0)\n     {\n       if (cpp_get_options (pfile)->warn_invalid_pch)\n-\tcpp_error (pfile, DL_WARNING,\n+\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t   \"%s: created by version `%.*s', but this is version `%s'\", \n \t\t   name, v.version_length, \n \t\t   (short_strings + v.host_machine_length \n@@ -290,7 +290,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n       && write_symbols != NO_DEBUG)\n     {\n       if (cpp_get_options (pfile)->warn_invalid_pch)\n-\tcpp_error (pfile, DL_WARNING, \n+\tcpp_error (pfile, CPP_DL_WARNING, \n \t\t   \"%s: created with -g%s, but used with -g%s\", name,\n \t\t   debug_type_names[v.debug_info_type],\n \t\t   debug_type_names[write_symbols]);\n@@ -304,7 +304,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n   if (v.pch_init != &pch_init)\n     {\n       if (cpp_get_options (pfile)->warn_invalid_pch)\n-\tcpp_error (pfile, DL_WARNING, \n+\tcpp_error (pfile, CPP_DL_WARNING, \n \t\t   \"%s: had text segment at different address\", name);\n       return 2;\n     }\n@@ -322,7 +322,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n     if (msg != NULL)\n       {\n \tif (cpp_get_options (pfile)->warn_invalid_pch)\n-\t  cpp_error (pfile, DL_WARNING, \"%s: %s\", name, msg);\n+\t  cpp_error (pfile, CPP_DL_WARNING, \"%s: %s\", name, msg);\n \treturn 2;\n       }\n   }\n@@ -353,15 +353,15 @@ c_common_read_pch (cpp_reader *pfile, const char *name,\n   f = fdopen (fd, \"rb\");\n   if (f == NULL)\n     {\n-      cpp_errno (pfile, DL_ERROR, \"calling fdopen\");\n+      cpp_errno (pfile, CPP_DL_ERROR, \"calling fdopen\");\n       return;\n     }\n \n   cpp_get_callbacks (parse_in)->valid_pch = NULL;\n \n   if (fread (&h, sizeof (h), 1, f) != 1)\n     {\n-      cpp_errno (pfile, DL_ERROR, \"reading\");\n+      cpp_errno (pfile, CPP_DL_ERROR, \"reading\");\n       return;\n     }\n \n@@ -373,7 +373,7 @@ c_common_read_pch (cpp_reader *pfile, const char *name,\n \tsize = 16384;\n       if (fread (buf, size, 1, f) != 1\n \t  || fwrite (buf, size, 1, asm_out_file) != 1)\n-\tcpp_errno (pfile, DL_ERROR, \"reading\");\n+\tcpp_errno (pfile, CPP_DL_ERROR, \"reading\");\n       written += size;\n     }\n   free (buf);"}, {"sha": "6b69fed639e304aca3ac88beff504dd86fda19ed", "filename": "gcc/cppcharset.c", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcppcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcppcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppcharset.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -649,18 +649,18 @@ init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n       if (ret.cd == (iconv_t) -1)\n \t{\n \t  if (errno == EINVAL)\n-\t    cpp_error (pfile, DL_ERROR, /* XXX should be DL_SORRY */\n+\t    cpp_error (pfile, CPP_DL_ERROR, /* XXX should be DL_SORRY */\n \t\t       \"conversion from %s to %s not supported by iconv\",\n \t\t       from, to);\n \t  else\n-\t    cpp_errno (pfile, DL_ERROR, \"iconv_open\");\n+\t    cpp_errno (pfile, CPP_DL_ERROR, \"iconv_open\");\n \n \t  ret.func = convert_no_conversion;\n \t}\n     }\n   else\n     {\n-      cpp_error (pfile, DL_ERROR, /* XXX should be DL_SORRY */\n+      cpp_error (pfile, CPP_DL_ERROR, /* XXX should be DL_SORRY */\n \t\t \"no iconv implementation, cannot convert from %s to %s\",\n \t\t from, to);\n       ret.func = convert_no_conversion;\n@@ -804,10 +804,10 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n   const uchar *base = str - 2;\n \n   if (!CPP_OPTION (pfile, cplusplus) && !CPP_OPTION (pfile, c99))\n-    cpp_error (pfile, DL_WARNING,\n+    cpp_error (pfile, CPP_DL_WARNING,\n \t       \"universal character names are only valid in C++ and C99\");\n   else if (CPP_WTRADITIONAL (pfile) && identifier_pos == 0)\n-    cpp_error (pfile, DL_WARNING,\n+    cpp_error (pfile, CPP_DL_WARNING,\n \t       \"the meaning of '\\\\%c' is different in traditional C\",\n \t       (int) str[-1]);\n \n@@ -833,7 +833,8 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n   if (length)\n     {\n       /* We'll error when we try it out as the start of an identifier.  */\n-      cpp_error (pfile, DL_ERROR, \"incomplete universal character name %.*s\",\n+      cpp_error (pfile, CPP_DL_ERROR,\n+\t\t \"incomplete universal character name %.*s\",\n \t\t (int) (str - base), base);\n       result = 1;\n     }\n@@ -844,7 +845,8 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n \t   || (result & 0x80000000)\n \t   || (result >= 0xD800 && result <= 0xDFFF))\n     {\n-      cpp_error (pfile, DL_ERROR, \"%.*s is not a valid universal character\",\n+      cpp_error (pfile, CPP_DL_ERROR,\n+\t\t \"%.*s is not a valid universal character\",\n \t\t (int) (str - base), base);\n       result = 1;\n     }\n@@ -853,11 +855,11 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n       int validity = ucn_valid_in_identifier (pfile, result);\n \n       if (validity == 0)\n-\tcpp_error (pfile, DL_ERROR,\n+\tcpp_error (pfile, CPP_DL_ERROR,\n \t\t   \"universal character %.*s is not valid in an identifier\",\n \t\t   (int) (str - base), base);\n       else if (validity == 2 && identifier_pos == 1)\n-\tcpp_error (pfile, DL_ERROR,\n+\tcpp_error (pfile, CPP_DL_ERROR,\n    \"universal character %.*s is not valid at the start of an identifier\",\n \t\t   (int) (str - base), base);\n     }\n@@ -892,10 +894,12 @@ convert_ucn (cpp_reader *pfile, const uchar *from, const uchar *limit,\n   if (rval)\n     {\n       errno = rval;\n-      cpp_errno (pfile, DL_ERROR, \"converting UCN to source character set\");\n+      cpp_errno (pfile, CPP_DL_ERROR,\n+\t\t \"converting UCN to source character set\");\n     }\n   else if (!APPLY_CONVERSION (cvt, buf, 6 - bytesleft, tbuf))\n-    cpp_errno (pfile, DL_ERROR, \"converting UCN to execution character set\");\n+    cpp_errno (pfile, CPP_DL_ERROR,\n+\t       \"converting UCN to execution character set\");\n \n   return from;\n }\n@@ -959,7 +963,7 @@ convert_hex (cpp_reader *pfile, const uchar *from, const uchar *limit,\n   size_t mask = width_to_mask (width);\n \n   if (CPP_WTRADITIONAL (pfile))\n-    cpp_error (pfile, DL_WARNING,\n+    cpp_error (pfile, CPP_DL_WARNING,\n \t       \"the meaning of '\\\\x' is different in traditional C\");\n \n   from++;  /* skip 'x' */\n@@ -976,14 +980,14 @@ convert_hex (cpp_reader *pfile, const uchar *from, const uchar *limit,\n \n   if (!digits_found)\n     {\n-      cpp_error (pfile, DL_ERROR,\n+      cpp_error (pfile, CPP_DL_ERROR,\n \t\t \"\\\\x used with no following hex digits\");\n       return from;\n     }\n \n   if (overflow | (n != (n & mask)))\n     {\n-      cpp_error (pfile, DL_PEDWARN,\n+      cpp_error (pfile, CPP_DL_PEDWARN,\n \t\t \"hex escape sequence out of range\");\n       n &= mask;\n     }\n@@ -1022,7 +1026,7 @@ convert_oct (cpp_reader *pfile, const uchar *from, const uchar *limit,\n \n   if (n != (n & mask))\n     {\n-      cpp_error (pfile, DL_PEDWARN,\n+      cpp_error (pfile, CPP_DL_PEDWARN,\n \t\t \"octal escape sequence out of range\");\n       n &= mask;\n     }\n@@ -1090,31 +1094,31 @@ convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n \n     case 'a':\n       if (CPP_WTRADITIONAL (pfile))\n-\tcpp_error (pfile, DL_WARNING,\n+\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t   \"the meaning of '\\\\a' is different in traditional C\");\n       c = charconsts[0];\n       break;\n \n     case 'e': case 'E':\n       if (CPP_PEDANTIC (pfile))\n-\tcpp_error (pfile, DL_PEDWARN,\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t   \"non-ISO-standard escape sequence, '\\\\%c'\", (int) c);\n       c = charconsts[2];\n       break;\n \n     default:\n     unknown:\n       if (ISGRAPH (c))\n-\tcpp_error (pfile, DL_PEDWARN,\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t   \"unknown escape sequence '\\\\%c'\", (int) c);\n       else\n-\tcpp_error (pfile, DL_PEDWARN,\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t   \"unknown escape sequence: '\\\\%03o'\", (int) c);\n     }\n \n   /* Now convert what we have to the execution character set.  */\n   if (!APPLY_CONVERSION (cvt, &c, 1, tbuf))\n-    cpp_errno (pfile, DL_ERROR,\n+    cpp_errno (pfile, CPP_DL_ERROR,\n \t       \"converting escape sequence to execution character set\");\n \n   return from + 1;\n@@ -1174,7 +1178,7 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n   return true;\n \n  fail:\n-  cpp_errno (pfile, DL_ERROR, \"converting to execution character set\");\n+  cpp_errno (pfile, CPP_DL_ERROR, \"converting to execution character set\");\n   free (tbuf.text);\n   return false;\n }\n@@ -1236,10 +1240,11 @@ narrow_str_to_charconst (cpp_reader *pfile, cpp_string str,\n   if (i > max_chars)\n     {\n       i = max_chars;\n-      cpp_error (pfile, DL_WARNING, \"character constant too long for its type\");\n+      cpp_error (pfile, CPP_DL_WARNING,\n+\t\t \"character constant too long for its type\");\n     }\n   else if (i > 1 && CPP_OPTION (pfile, warn_multichar))\n-    cpp_error (pfile, DL_WARNING, \"multi-character character constant\");\n+    cpp_error (pfile, CPP_DL_WARNING, \"multi-character character constant\");\n \n   /* Multichar constants are of type int and therefore signed.  */\n   if (i > 1)\n@@ -1298,7 +1303,8 @@ wide_str_to_charconst (cpp_reader *pfile, cpp_string str,\n      character exactly fills a wchar_t, so a multi-character wide\n      character constant is guaranteed to overflow.  */\n   if (off > 0)\n-    cpp_error (pfile, DL_WARNING, \"character constant too long for its type\");\n+    cpp_error (pfile, CPP_DL_WARNING,\n+\t       \"character constant too long for its type\");\n \n   /* Truncate the constant to its natural width, and simultaneously\n      sign- or zero-extend to the full width of cppchar_t.  */\n@@ -1330,7 +1336,7 @@ cpp_interpret_charconst (cpp_reader *pfile, const cpp_token *token,\n   /* an empty constant will appear as L'' or '' */\n   if (token->val.str.len == (size_t) (2 + wide))\n     {\n-      cpp_error (pfile, DL_ERROR, \"empty character constant\");\n+      cpp_error (pfile, CPP_DL_ERROR, \"empty character constant\");\n       return 0;\n     }\n   else if (!cpp_interpret_string (pfile, &token->val.str, 1, &str, wide))"}, {"sha": "61763cc1826f7e53c14139c2f84f65a3b657d431", "filename": "gcc/cpperror.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -72,43 +72,43 @@ int\n _cpp_begin_message (cpp_reader *pfile, int code, fileline line,\n \t\t    unsigned int column)\n {\n-  int level = DL_EXTRACT (code);\n+  int level = CPP_DL_EXTRACT (code);\n \n   switch (level)\n     {\n-    case DL_WARNING:\n-    case DL_PEDWARN:\n+    case CPP_DL_WARNING:\n+    case CPP_DL_PEDWARN:\n       if (CPP_IN_SYSTEM_HEADER (pfile)\n \t  && ! CPP_OPTION (pfile, warn_system_headers))\n \treturn 0;\n       /* Fall through.  */\n \n-    case DL_WARNING_SYSHDR:\n+    case CPP_DL_WARNING_SYSHDR:\n       if (CPP_OPTION (pfile, warnings_are_errors)\n-\t  || (level == DL_PEDWARN && CPP_OPTION (pfile, pedantic_errors)))\n+\t  || (level == CPP_DL_PEDWARN && CPP_OPTION (pfile, pedantic_errors)))\n \t{\n \t  if (CPP_OPTION (pfile, inhibit_errors))\n \t    return 0;\n-\t  level = DL_ERROR;\n+\t  level = CPP_DL_ERROR;\n \t  pfile->errors++;\n \t}\n       else if (CPP_OPTION (pfile, inhibit_warnings))\n \treturn 0;\n       break;\n \n-    case DL_ERROR:\n+    case CPP_DL_ERROR:\n       if (CPP_OPTION (pfile, inhibit_errors))\n \treturn 0;\n       /* ICEs cannot be inhibited.  */\n-    case DL_ICE:\n+    case CPP_DL_ICE:\n       pfile->errors++;\n       break;\n     }\n \n   print_location (pfile, line, column);\n-  if (DL_WARNING_P (level))\n+  if (CPP_DL_WARNING_P (level))\n     fputs (_(\"warning: \"), stderr);\n-  else if (level == DL_ICE)\n+  else if (level == CPP_DL_ICE)\n     fputs (_(\"internal error: \"), stderr);\n \n   return 1;"}, {"sha": "c6f1f1d39a5ff8ef2e2f73bb94f92c54c2c0c510", "filename": "gcc/cppexp.c", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -71,9 +71,10 @@ static void check_promotion (cpp_reader *, const struct op *);\n /* With -O2, gcc appears to produce nice code, moving the error\n    message load and subsequent jump completely out of the main path.  */\n #define SYNTAX_ERROR(msgid) \\\n-  do { cpp_error (pfile, DL_ERROR, msgid); goto syntax_error; } while(0)\n+  do { cpp_error (pfile, CPP_DL_ERROR, msgid); goto syntax_error; } while(0)\n #define SYNTAX_ERROR2(msgid, arg) \\\n-  do { cpp_error (pfile, DL_ERROR, msgid, arg); goto syntax_error; } while(0)\n+  do { cpp_error (pfile, CPP_DL_ERROR, msgid, arg); goto syntax_error; } \\\n+  while(0)\n \n /* Subroutine of cpp_classify_number.  S points to a float suffix of\n    length LEN, possibly zero.  Returns 0 for an invalid suffix, or a\n@@ -213,7 +214,7 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n   if (float_flag != NOT_FLOAT)\n     {\n       if (radix == 16 && CPP_PEDANTIC (pfile) && !CPP_OPTION (pfile, c99))\n-\tcpp_error (pfile, DL_PEDWARN,\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t   \"use of C99 hexadecimal floating constant\");\n \n       if (float_flag == AFTER_EXPON)\n@@ -235,7 +236,7 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n       result = interpret_float_suffix (str, limit - str);\n       if (result == 0)\n \t{\n-\t  cpp_error (pfile, DL_ERROR,\n+\t  cpp_error (pfile, CPP_DL_ERROR,\n \t\t     \"invalid suffix \\\"%.*s\\\" on floating constant\",\n \t\t     (int) (limit - str), str);\n \t  return CPP_N_INVALID;\n@@ -245,7 +246,7 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n       if (limit != str\n \t  && CPP_WTRADITIONAL (pfile)\n \t  && ! cpp_sys_macro_p (pfile))\n-\tcpp_error (pfile, DL_WARNING,\n+\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t   \"traditional C rejects the \\\"%.*s\\\" suffix\",\n \t\t   (int) (limit - str), str);\n \n@@ -256,7 +257,7 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n       result = interpret_int_suffix (str, limit - str);\n       if (result == 0)\n \t{\n-\t  cpp_error (pfile, DL_ERROR,\n+\t  cpp_error (pfile, CPP_DL_ERROR,\n \t\t     \"invalid suffix \\\"%.*s\\\" on integer constant\",\n \t\t     (int) (limit - str), str);\n \t  return CPP_N_INVALID;\n@@ -270,21 +271,23 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n \t  int large = (result & CPP_N_WIDTH) == CPP_N_LARGE;\n \n \t  if (u_or_i || (large && CPP_OPTION (pfile, warn_long_long)))\n-\t    cpp_error (pfile, DL_WARNING,\n+\t    cpp_error (pfile, CPP_DL_WARNING,\n \t\t       \"traditional C rejects the \\\"%.*s\\\" suffix\",\n \t\t       (int) (limit - str), str);\n \t}\n \n       if ((result & CPP_N_WIDTH) == CPP_N_LARGE\n \t  && ! CPP_OPTION (pfile, c99)\n \t  && CPP_OPTION (pfile, warn_long_long))\n-\tcpp_error (pfile, DL_PEDWARN, \"use of C99 long long integer constant\");\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t   \"use of C99 long long integer constant\");\n \n       result |= CPP_N_INTEGER;\n     }\n \n   if ((result & CPP_N_IMAGINARY) && CPP_PEDANTIC (pfile))\n-    cpp_error (pfile, DL_PEDWARN, \"imaginary constants are a GCC extension\");\n+    cpp_error (pfile, CPP_DL_PEDWARN,\n+\t       \"imaginary constants are a GCC extension\");\n \n   if (radix == 10)\n     result |= CPP_N_DECIMAL;\n@@ -369,7 +372,7 @@ cpp_interpret_integer (cpp_reader *pfile, const cpp_token *token,\n \t}\n \n       if (overflow)\n-\tcpp_error (pfile, DL_PEDWARN,\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t   \"integer constant is too large for its type\");\n       /* If too big to be signed, consider it unsigned.  Only warn for\n \t decimal numbers.  Traditional numbers were always signed (but\n@@ -381,7 +384,7 @@ cpp_interpret_integer (cpp_reader *pfile, const cpp_token *token,\n \t       && !num_positive (result, precision))\n \t{\n \t  if (base == 10)\n-\t    cpp_error (pfile, DL_WARNING,\n+\t    cpp_error (pfile, CPP_DL_WARNING,\n \t\t       \"integer constant is so large that it is unsigned\");\n \t  result.unsignedp = true;\n \t}\n@@ -464,21 +467,21 @@ parse_defined (cpp_reader *pfile)\n       node = token->val.node;\n       if (paren && cpp_get_token (pfile)->type != CPP_CLOSE_PAREN)\n \t{\n-\t  cpp_error (pfile, DL_ERROR, \"missing ')' after \\\"defined\\\"\");\n+\t  cpp_error (pfile, CPP_DL_ERROR, \"missing ')' after \\\"defined\\\"\");\n \t  node = 0;\n \t}\n     }\n   else\n     {\n-      cpp_error (pfile, DL_ERROR,\n+      cpp_error (pfile, CPP_DL_ERROR,\n \t\t \"operator \\\"defined\\\" requires an identifier\");\n       if (token->flags & NAMED_OP)\n \t{\n \t  cpp_token op;\n \n \t  op.flags = 0;\n \t  op.type = token->type;\n-\t  cpp_error (pfile, DL_ERROR,\n+\t  cpp_error (pfile, CPP_DL_ERROR,\n \t\t     \"(\\\"%s\\\" is an alternative token for \\\"%s\\\" in C++)\",\n \t\t     cpp_token_as_text (pfile, token),\n \t\t     cpp_token_as_text (pfile, &op));\n@@ -488,7 +491,7 @@ parse_defined (cpp_reader *pfile)\n   if (node)\n     {\n       if (pfile->context != initial_context && CPP_PEDANTIC (pfile))\n-\tcpp_error (pfile, DL_WARNING,\n+\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t   \"this use of \\\"defined\\\" may not be portable\");\n \n       _cpp_mark_macro_used (node);\n@@ -524,13 +527,13 @@ eval_token (cpp_reader *pfile, const cpp_token *token)\n       switch (temp & CPP_N_CATEGORY)\n \t{\n \tcase CPP_N_FLOATING:\n-\t  cpp_error (pfile, DL_ERROR,\n+\t  cpp_error (pfile, CPP_DL_ERROR,\n \t\t     \"floating constant in preprocessor expression\");\n \t  break;\n \tcase CPP_N_INTEGER:\n \t  if (!(temp & CPP_N_IMAGINARY))\n \t    return cpp_interpret_integer (pfile, token, temp);\n-\t  cpp_error (pfile, DL_ERROR,\n+\t  cpp_error (pfile, CPP_DL_ERROR,\n \t\t     \"imaginary number in preprocessor expression\");\n \t  break;\n \n@@ -576,7 +579,7 @@ eval_token (cpp_reader *pfile, const cpp_token *token)\n \t  result.high = 0;\n \t  result.low = 0;\n \t  if (CPP_OPTION (pfile, warn_undef) && !pfile->state.skip_eval)\n-\t    cpp_error (pfile, DL_WARNING, \"\\\"%s\\\" is not defined\",\n+\t    cpp_error (pfile, CPP_DL_WARNING, \"\\\"%s\\\" is not defined\",\n \t\t       NODE_NAME (token->val.node));\n \t}\n       break;\n@@ -805,7 +808,7 @@ _cpp_parse_expr (cpp_reader *pfile)\n \n   if (top != pfile->op_stack)\n     {\n-      cpp_error (pfile, DL_ICE, \"unbalanced stack in #if\");\n+      cpp_error (pfile, CPP_DL_ICE, \"unbalanced stack in #if\");\n     syntax_error:\n       return false;  /* Return false on syntax error.  */\n     }\n@@ -824,7 +827,7 @@ reduce (cpp_reader *pfile, struct op *top, enum cpp_ttype op)\n   if (top->op <= CPP_EQ || top->op > CPP_LAST_CPP_OP + 2)\n     {\n     bad_op:\n-      cpp_error (pfile, DL_ICE, \"impossible operator '%u'\", top->op);\n+      cpp_error (pfile, CPP_DL_ICE, \"impossible operator '%u'\", top->op);\n       return 0;\n     }\n \n@@ -916,7 +919,7 @@ reduce (cpp_reader *pfile, struct op *top, enum cpp_ttype op)\n \tcase CPP_OPEN_PAREN:\n \t  if (op != CPP_CLOSE_PAREN)\n \t    {\n-\t      cpp_error (pfile, DL_ERROR, \"missing ')' in expression\");\n+\t      cpp_error (pfile, CPP_DL_ERROR, \"missing ')' in expression\");\n \t      return 0;\n \t    }\n \t  top--;\n@@ -937,7 +940,7 @@ reduce (cpp_reader *pfile, struct op *top, enum cpp_ttype op)\n \t  continue;\n \n \tcase CPP_QUERY:\n-\t  cpp_error (pfile, DL_ERROR, \"'?' without following ':'\");\n+\t  cpp_error (pfile, CPP_DL_ERROR, \"'?' without following ':'\");\n \t  return 0;\n \n \tdefault:\n@@ -946,13 +949,13 @@ reduce (cpp_reader *pfile, struct op *top, enum cpp_ttype op)\n \n       top--;\n       if (top->value.overflow && !pfile->state.skip_eval)\n-\tcpp_error (pfile, DL_PEDWARN,\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t   \"integer overflow in preprocessor expression\");\n     }\n \n   if (op == CPP_CLOSE_PAREN)\n     {\n-      cpp_error (pfile, DL_ERROR, \"missing '(' in expression\");\n+      cpp_error (pfile, CPP_DL_ERROR, \"missing '(' in expression\");\n       return 0;\n     }\n \n@@ -983,12 +986,12 @@ check_promotion (cpp_reader *pfile, const struct op *op)\n   if (op->value.unsignedp)\n     {\n       if (!num_positive (op[-1].value, CPP_OPTION (pfile, precision)))\n-\tcpp_error (pfile, DL_WARNING,\n+\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t   \"the left operand of \\\"%s\\\" changes sign when promoted\",\n \t\t   cpp_token_as_text (pfile, op->token));\n     }\n   else if (!num_positive (op->value, CPP_OPTION (pfile, precision)))\n-    cpp_error (pfile, DL_WARNING,\n+    cpp_error (pfile, CPP_DL_WARNING,\n \t       \"the right operand of \\\"%s\\\" changes sign when promoted\",\n \t       cpp_token_as_text (pfile, op->token));\n }\n@@ -1246,7 +1249,7 @@ num_unary_op (cpp_reader *pfile, cpp_num num, enum cpp_ttype op)\n     {\n     case CPP_UPLUS:\n       if (CPP_WTRADITIONAL (pfile) && !pfile->state.skip_eval)\n-\tcpp_error (pfile, DL_WARNING,\n+\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t   \"traditional C rejects the unary plus operator\");\n       num.overflow = false;\n       break;\n@@ -1345,7 +1348,7 @@ num_binary_op (cpp_reader *pfile, cpp_num lhs, cpp_num rhs, enum cpp_ttype op)\n       /* Comma.  */\n     default: /* case CPP_COMMA: */\n       if (CPP_PEDANTIC (pfile) && !pfile->state.skip_eval)\n-\tcpp_error (pfile, DL_PEDWARN,\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t   \"comma operator in operand of #if\");\n       lhs = rhs;\n       break;\n@@ -1477,7 +1480,7 @@ num_div_op (cpp_reader *pfile, cpp_num lhs, cpp_num rhs, enum cpp_ttype op)\n   else\n     {\n       if (!pfile->state.skip_eval)\n-\tcpp_error (pfile, DL_ERROR, \"division by zero in #if\");\n+\tcpp_error (pfile, CPP_DL_ERROR, \"division by zero in #if\");\n       return lhs;\n     }\n "}, {"sha": "9db981c099ad28ff4bf9555e3ef89bf5e04de586", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -354,7 +354,7 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir, bool f\n \n   /* Ensure we get no confusion between cached files and directories.  */\n   if (start_dir == NULL)\n-    cpp_error (pfile, DL_ICE, \"NULL directory in find_file\");\n+    cpp_error (pfile, CPP_DL_ICE, \"NULL directory in find_file\");\n \n   hash_slot = (struct file_hash_entry **)\n     htab_find_slot (pfile->file_hash, fname, INSERT);\n@@ -432,7 +432,7 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file)\n   \n   if (S_ISBLK (file->st.st_mode))\n     {\n-      cpp_error (pfile, DL_ERROR, \"%s is a block device\", file->path);\n+      cpp_error (pfile, CPP_DL_ERROR, \"%s is a block device\", file->path);\n       return false;\n     }\n \n@@ -449,7 +449,7 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file)\n \t does not bite us.  */\n       if (file->st.st_size > INTTYPE_MAXIMUM (ssize_t))\n \t{\n-\t  cpp_error (pfile, DL_ERROR, \"%s is too large\", file->path);\n+\t  cpp_error (pfile, CPP_DL_ERROR, \"%s is too large\", file->path);\n \t  return false;\n \t}\n \n@@ -478,12 +478,13 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file)\n \n   if (count < 0)\n     {\n-      cpp_errno (pfile, DL_ERROR, file->path);\n+      cpp_errno (pfile, CPP_DL_ERROR, file->path);\n       return false;\n     }\n \n   if (regular && total != size && STAT_SIZE_RELIABLE (file->st))\n-    cpp_error (pfile, DL_WARNING, \"%s is shorter than expected\", file->path);\n+    cpp_error (pfile, CPP_DL_WARNING,\n+\t       \"%s is shorter than expected\", file->path);\n \n   /* Shrink buffer if we allocated substantially too much.  */\n   if (total + 4096 < size)\n@@ -675,7 +676,7 @@ search_path_head (cpp_reader *pfile, const char *fname, int angle_brackets,\n     return make_cpp_dir (pfile, dir_name_of_file (file), pfile->map->sysp);\n \n   if (dir == NULL)\n-    cpp_error (pfile, DL_ERROR,\n+    cpp_error (pfile, CPP_DL_ERROR,\n \t       \"no include path in which to search for %s\", fname);\n \n   return dir;\n@@ -732,9 +733,9 @@ open_file_failed (cpp_reader *pfile, _cpp_file *file)\n       /* If we are outputting dependencies but not for this file then\n \t don't error because we can still produce correct output.  */\n       if (CPP_OPTION (pfile, deps.style) && ! print_dep)\n-\tcpp_errno (pfile, DL_WARNING, file->path);\n+\tcpp_errno (pfile, CPP_DL_WARNING, file->path);\n       else\n-\tcpp_errno (pfile, DL_ERROR, file->path);\n+\tcpp_errno (pfile, CPP_DL_ERROR, file->path);\n     }\n }\n "}, {"sha": "13326886778a1f378cb8fd2f95bec80934750b75", "filename": "gcc/cppinit.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -383,36 +383,37 @@ static void sanity_checks (cpp_reader *pfile)\n      type precisions made by cpplib.  */\n   test--;\n   if (test < 1)\n-    cpp_error (pfile, DL_ICE, \"cppchar_t must be an unsigned type\");\n+    cpp_error (pfile, CPP_DL_ICE, \"cppchar_t must be an unsigned type\");\n \n   if (CPP_OPTION (pfile, precision) > max_precision)\n-    cpp_error (pfile, DL_ICE,\n+    cpp_error (pfile, CPP_DL_ICE,\n \t       \"preprocessor arithmetic has maximum precision of %lu bits;\"\n \t       \" target requires %lu bits\",\n \t       (unsigned long) max_precision,\n \t       (unsigned long) CPP_OPTION (pfile, precision));\n \n   if (CPP_OPTION (pfile, precision) < CPP_OPTION (pfile, int_precision))\n-    cpp_error (pfile, DL_ICE,\n+    cpp_error (pfile, CPP_DL_ICE,\n \t       \"CPP arithmetic must be at least as precise as a target int\");\n \n   if (CPP_OPTION (pfile, char_precision) < 8)\n-    cpp_error (pfile, DL_ICE, \"target char is less than 8 bits wide\");\n+    cpp_error (pfile, CPP_DL_ICE, \"target char is less than 8 bits wide\");\n \n   if (CPP_OPTION (pfile, wchar_precision) < CPP_OPTION (pfile, char_precision))\n-    cpp_error (pfile, DL_ICE,\n+    cpp_error (pfile, CPP_DL_ICE,\n \t       \"target wchar_t is narrower than target char\");\n \n   if (CPP_OPTION (pfile, int_precision) < CPP_OPTION (pfile, char_precision))\n-    cpp_error (pfile, DL_ICE,\n+    cpp_error (pfile, CPP_DL_ICE,\n \t       \"target int is narrower than target char\");\n \n   /* This is assumed in eval_token() and could be fixed if necessary.  */\n   if (sizeof (cppchar_t) > sizeof (cpp_num_part))\n-    cpp_error (pfile, DL_ICE, \"CPP half-integer narrower than CPP character\");\n+    cpp_error (pfile, CPP_DL_ICE,\n+\t       \"CPP half-integer narrower than CPP character\");\n \n   if (CPP_OPTION (pfile, wchar_precision) > BITS_PER_CPPCHAR_T)\n-    cpp_error (pfile, DL_ICE,\n+    cpp_error (pfile, CPP_DL_ICE,\n \t       \"CPP on this host cannot handle wide character constants over\"\n \t       \" %lu bits, but the target requires %lu bits\",\n \t       (unsigned long) BITS_PER_CPPCHAR_T,"}, {"sha": "783732fa444c6063ce8ab6b012c766f021b71e5a", "filename": "gcc/cpplex.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -270,12 +270,12 @@ _cpp_process_line_notes (cpp_reader *pfile, int in_comment)\n       if (note->type == '\\\\' || note->type == ' ')\n \t{\n \t  if (note->type == ' ' && !in_comment)\n-\t    cpp_error_with_line (pfile, DL_WARNING, pfile->line, col,\n+\t    cpp_error_with_line (pfile, CPP_DL_WARNING, pfile->line, col,\n \t\t\t\t \"backslash and newline separated by space\");\n \n \t  if (buffer->next_line > buffer->rlimit)\n \t    {\n-\t      cpp_error_with_line (pfile, DL_PEDWARN, pfile->line, col,\n+\t      cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line, col,\n \t\t\t\t   \"backslash-newline at end of file\");\n \t      /* Prevent \"no newline at end of file\" warning.  */\n \t      buffer->next_line = buffer->rlimit;\n@@ -290,14 +290,14 @@ _cpp_process_line_notes (cpp_reader *pfile, int in_comment)\n \t      && (!in_comment || warn_in_comment (pfile, note)))\n \t    {\n \t      if (CPP_OPTION (pfile, trigraphs))\n-\t\tcpp_error_with_line (pfile, DL_WARNING, pfile->line, col,\n+\t\tcpp_error_with_line (pfile, CPP_DL_WARNING, pfile->line, col,\n \t\t\t\t     \"trigraph ??%c converted to %c\",\n \t\t\t\t     note->type,\n \t\t\t\t     (int) _cpp_trigraph_map[note->type]);\n \t      else\n \t\t{\n \t\t  cpp_error_with_line \n-\t\t    (pfile, DL_WARNING, pfile->line, col,\n+\t\t    (pfile, CPP_DL_WARNING, pfile->line, col,\n \t\t     \"trigraph ??%c ignored, use -trigraphs to enable\",\n \t\t     note->type);\n \t\t}\n@@ -342,7 +342,7 @@ _cpp_skip_block_comment (cpp_reader *pfile)\n \t      && cur[0] == '*' && cur[1] != '/')\n \t    {\n \t      buffer->cur = cur;\n-\t      cpp_error_with_line (pfile, DL_WARNING,\n+\t      cpp_error_with_line (pfile, CPP_DL_WARNING,\n \t\t\t\t   pfile->line, CPP_BUF_COL (buffer),\n \t\t\t\t   \"\\\"/*\\\" within comment\");\n \t    }\n@@ -396,7 +396,7 @@ skip_whitespace (cpp_reader *pfile, cppchar_t c)\n       else if (c == '\\0')\n \tsaw_NUL = true;\n       else if (pfile->state.in_directive && CPP_PEDANTIC (pfile))\n-\tcpp_error_with_line (pfile, DL_PEDWARN, pfile->line,\n+\tcpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line,\n \t\t\t     CPP_BUF_COL (buffer),\n \t\t\t     \"%s in preprocessing directive\",\n \t\t\t     c == '\\f' ? \"form feed\" : \"vertical tab\");\n@@ -407,7 +407,7 @@ skip_whitespace (cpp_reader *pfile, cppchar_t c)\n   while (is_nvspace (c));\n \n   if (saw_NUL)\n-    cpp_error (pfile, DL_WARNING, \"null character(s) ignored\");\n+    cpp_error (pfile, CPP_DL_WARNING, \"null character(s) ignored\");\n \n   buffer->cur--;\n }\n@@ -442,7 +442,7 @@ forms_identifier_p (cpp_reader *pfile, int first)\n       if (CPP_OPTION (pfile, warn_dollars) && !pfile->state.skipping)\n \t{\n \t  CPP_OPTION (pfile, warn_dollars) = 0;\n-\t  cpp_error (pfile, DL_PEDWARN, \"'$' in identifier or number\");\n+\t  cpp_error (pfile, CPP_DL_PEDWARN, \"'$' in identifier or number\");\n \t}\n \n       return true;\n@@ -489,14 +489,14 @@ lex_identifier (cpp_reader *pfile, const uchar *base)\n     {\n       /* It is allowed to poison the same identifier twice.  */\n       if ((result->flags & NODE_POISONED) && !pfile->state.poisoned_ok)\n-\tcpp_error (pfile, DL_ERROR, \"attempt to use poisoned \\\"%s\\\"\",\n+\tcpp_error (pfile, CPP_DL_ERROR, \"attempt to use poisoned \\\"%s\\\"\",\n \t\t   NODE_NAME (result));\n \n       /* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n \t replacement list of a variadic macro.  */\n       if (result == pfile->spec_nodes.n__VA_ARGS__\n \t  && !pfile->state.va_args_ok)\n-\tcpp_error (pfile, DL_PEDWARN,\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t   \"__VA_ARGS__ can only appear in the expansion\"\n \t\t   \" of a C99 variadic macro\");\n     }\n@@ -592,7 +592,8 @@ lex_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n     }\n \n   if (saw_NUL && !pfile->state.skipping)\n-    cpp_error (pfile, DL_WARNING, \"null character(s) preserved in literal\");\n+    cpp_error (pfile, CPP_DL_WARNING,\n+\t       \"null character(s) preserved in literal\");\n \n   pfile->buffer->cur = cur;\n   create_literal (pfile, token, base, cur - base, type);\n@@ -771,7 +772,7 @@ _cpp_get_fresh_line (cpp_reader *pfile)\n \t{\n \t  /* Only warn once.  */\n \t  buffer->next_line = buffer->rlimit;\n-\t  cpp_error_with_line (pfile, DL_PEDWARN, pfile->line - 1,\n+\t  cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line - 1,\n \t\t\t       CPP_BUF_COLUMN (buffer, buffer->cur),\n \t\t\t       \"no newline at end of file\");\n \t}\n@@ -912,7 +913,7 @@ _cpp_lex_direct (cpp_reader *pfile)\n       if (c == '*')\n \t{\n \t  if (_cpp_skip_block_comment (pfile))\n-\t    cpp_error (pfile, DL_ERROR, \"unterminated comment\");\n+\t    cpp_error (pfile, CPP_DL_ERROR, \"unterminated comment\");\n \t}\n       else if (c == '/' && (CPP_OPTION (pfile, cplusplus_comments)\n \t\t\t    || CPP_IN_SYSTEM_HEADER (pfile)))\n@@ -922,15 +923,15 @@ _cpp_lex_direct (cpp_reader *pfile)\n \t  if (CPP_OPTION (pfile, lang) == CLK_GNUC89 && CPP_PEDANTIC (pfile)\n \t      && ! buffer->warned_cplusplus_comments)\n \t    {\n-\t      cpp_error (pfile, DL_PEDWARN,\n+\t      cpp_error (pfile, CPP_DL_PEDWARN,\n \t\t\t \"C++ style comments are not allowed in ISO C90\");\n-\t      cpp_error (pfile, DL_PEDWARN,\n+\t      cpp_error (pfile, CPP_DL_PEDWARN,\n \t\t\t \"(this will be reported only once per input file)\");\n \t      buffer->warned_cplusplus_comments = 1;\n \t    }\n \n \t  if (skip_line_comment (pfile) && CPP_OPTION (pfile, warn_comments))\n-\t    cpp_error (pfile, DL_WARNING, \"multi-line comment\");\n+\t    cpp_error (pfile, CPP_DL_WARNING, \"multi-line comment\");\n \t}\n       else if (c == '=')\n \t{\n@@ -1193,7 +1194,8 @@ cpp_spell_token (cpp_reader *pfile, const cpp_token *token,\n       break;\n \n     case SPELL_NONE:\n-      cpp_error (pfile, DL_ICE, \"unspellable token %s\", TOKEN_NAME (token));\n+      cpp_error (pfile, CPP_DL_ICE,\n+\t\t \"unspellable token %s\", TOKEN_NAME (token));\n       break;\n     }\n "}, {"sha": "69995d49363b9201189f8c5ca6a4ba219170288a", "filename": "gcc/cpplib.c", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -215,7 +215,7 @@ static void\n check_eol (cpp_reader *pfile)\n {\n   if (! SEEN_EOL () && _cpp_lex_token (pfile)->type != CPP_EOF)\n-    cpp_error (pfile, DL_PEDWARN, \"extra tokens at end of #%s directive\",\n+    cpp_error (pfile, CPP_DL_PEDWARN, \"extra tokens at end of #%s directive\",\n \t       pfile->directive->name);\n }\n \n@@ -298,7 +298,7 @@ directive_diagnostics (cpp_reader *pfile, const directive *dir, int indented)\n   if (CPP_PEDANTIC (pfile)\n       && ! pfile->state.skipping\n       && dir->origin == EXTENSION)\n-    cpp_error (pfile, DL_PEDWARN, \"#%s is a GCC extension\", dir->name);\n+    cpp_error (pfile, CPP_DL_PEDWARN, \"#%s is a GCC extension\", dir->name);\n \n   /* Traditionally, a directive is ignored unless its # is in\n      column 1.  Therefore in code intended to work with K+R\n@@ -309,14 +309,14 @@ directive_diagnostics (cpp_reader *pfile, const directive *dir, int indented)\n   if (CPP_WTRADITIONAL (pfile))\n     {\n       if (dir == &dtable[T_ELIF])\n-\tcpp_error (pfile, DL_WARNING,\n+\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t   \"suggest not using #elif in traditional C\");\n       else if (indented && dir->origin == KANDR)\n-\tcpp_error (pfile, DL_WARNING,\n+\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t   \"traditional C ignores #%s with the # indented\",\n \t\t   dir->name);\n       else if (!indented && dir->origin != KANDR)\n-\tcpp_error (pfile, DL_WARNING,\n+\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t   \"suggest hiding #%s from traditional C with an indented #\",\n \t\t   dir->name);\n     }\n@@ -338,7 +338,7 @@ _cpp_handle_directive (cpp_reader *pfile, int indented)\n   if (was_parsing_args)\n     {\n       if (CPP_OPTION (pfile, pedantic))\n-\tcpp_error (pfile, DL_PEDWARN,\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n \t     \"embedding a directive within macro arguments is not portable\");\n       pfile->state.parsing_args = 0;\n       pfile->state.prevent_expansion = 0;\n@@ -358,7 +358,7 @@ _cpp_handle_directive (cpp_reader *pfile, int indented)\n       dir = &linemarker_dir;\n       if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, preprocessed)\n \t  && ! pfile->state.skipping)\n-\tcpp_error (pfile, DL_PEDWARN,\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t   \"style of line directive is a GCC extension\");\n     }\n \n@@ -409,7 +409,7 @@ _cpp_handle_directive (cpp_reader *pfile, int indented)\n       if (CPP_OPTION (pfile, lang) == CLK_ASM)\n \tskip = 0;\n       else if (!pfile->state.skipping)\n-\tcpp_error (pfile, DL_ERROR, \"invalid preprocessing directive #%s\",\n+\tcpp_error (pfile, CPP_DL_ERROR, \"invalid preprocessing directive #%s\",\n \t\t   cpp_token_as_text (pfile, dname));\n     }\n \n@@ -477,20 +477,20 @@ lex_macro_node (cpp_reader *pfile)\n       cpp_hashnode *node = token->val.node;\n \n       if (node == pfile->spec_nodes.n_defined)\n-\tcpp_error (pfile, DL_ERROR,\n+\tcpp_error (pfile, CPP_DL_ERROR,\n \t\t   \"\\\"defined\\\" cannot be used as a macro name\");\n       else if (! (node->flags & NODE_POISONED))\n \treturn node;\n     }\n   else if (token->flags & NAMED_OP)\n-    cpp_error (pfile, DL_ERROR,\n+    cpp_error (pfile, CPP_DL_ERROR,\n        \"\\\"%s\\\" cannot be used as a macro name as it is an operator in C++\",\n \t       NODE_NAME (token->val.node));\n   else if (token->type == CPP_EOF)\n-    cpp_error (pfile, DL_ERROR, \"no macro name given in #%s directive\",\n+    cpp_error (pfile, CPP_DL_ERROR, \"no macro name given in #%s directive\",\n \t       pfile->directive->name);\n   else\n-    cpp_error (pfile, DL_ERROR, \"macro names must be identifiers\");\n+    cpp_error (pfile, CPP_DL_ERROR, \"macro names must be identifiers\");\n \n   return NULL;\n }\n@@ -528,7 +528,8 @@ do_undef (cpp_reader *pfile)\n \tpfile->cb.undef (pfile, pfile->directive_line, node);\n \n       if (node->flags & NODE_WARN)\n-\tcpp_error (pfile, DL_WARNING, \"undefining \\\"%s\\\"\", NODE_NAME (node));\n+\tcpp_error (pfile, CPP_DL_WARNING,\n+\t\t   \"undefining \\\"%s\\\"\", NODE_NAME (node));\n \n       if (CPP_OPTION (pfile, warn_unused_macros))\n \t_cpp_warn_if_unused_macro (pfile, node, NULL);\n@@ -598,7 +599,7 @@ glue_header_name (cpp_reader *pfile)\n \tbreak;\n       if (token->type == CPP_EOF)\n \t{\n-\t  cpp_error (pfile, DL_ERROR, \"missing terminating > character\");\n+\t  cpp_error (pfile, CPP_DL_ERROR, \"missing terminating > character\");\n \t  break;\n \t}\n \n@@ -651,7 +652,7 @@ parse_include (cpp_reader *pfile, int *pangle_brackets)\n \tdir = U\"pragma dependency\";\n       else\n \tdir = pfile->directive->name;\n-      cpp_error (pfile, DL_ERROR, \"#%s expects \\\"FILENAME\\\" or <FILENAME>\",\n+      cpp_error (pfile, CPP_DL_ERROR, \"#%s expects \\\"FILENAME\\\" or <FILENAME>\",\n \t\t dir);\n \n       return NULL;\n@@ -674,7 +675,7 @@ do_include_common (cpp_reader *pfile, enum include_type type)\n \n   /* Prevent #include recursion.  */\n   if (pfile->line_maps.depth >= CPP_STACK_MAX)\n-    cpp_error (pfile, DL_ERROR, \"#include nested too deeply\");\n+    cpp_error (pfile, CPP_DL_ERROR, \"#include nested too deeply\");\n   else\n     {\n       /* Get out of macro context, if we are.  */\n@@ -711,7 +712,7 @@ do_include_next (cpp_reader *pfile)\n      search logic.  */\n   if (! pfile->buffer->prev)\n     {\n-      cpp_error (pfile, DL_WARNING,\n+      cpp_error (pfile, CPP_DL_WARNING,\n \t\t \"#include_next in primary source file\");\n       type = IT_INCLUDE;\n     }\n@@ -738,7 +739,7 @@ read_flag (cpp_reader *pfile, unsigned int last)\n     }\n \n   if (token->type != CPP_EOF)\n-    cpp_error (pfile, DL_ERROR, \"invalid flag \\\"%s\\\" in line directive\",\n+    cpp_error (pfile, CPP_DL_ERROR, \"invalid flag \\\"%s\\\" in line directive\",\n \t       cpp_token_as_text (pfile, token));\n   return 0;\n }\n@@ -782,14 +783,14 @@ do_line (cpp_reader *pfile)\n       || strtoul_for_line (token->val.str.text, token->val.str.len,\n \t\t\t   &new_lineno))\n     {\n-      cpp_error (pfile, DL_ERROR,\n+      cpp_error (pfile, CPP_DL_ERROR,\n \t\t \"\\\"%s\\\" after #line is not a positive integer\",\n \t\t cpp_token_as_text (pfile, token));\n       return;\n     }\n \n   if (CPP_PEDANTIC (pfile) && (new_lineno == 0 || new_lineno > cap))\n-    cpp_error (pfile, DL_PEDWARN, \"line number out of range\");\n+    cpp_error (pfile, CPP_DL_PEDWARN, \"line number out of range\");\n \n   token = cpp_get_token (pfile);\n   if (token->type == CPP_STRING)\n@@ -801,7 +802,7 @@ do_line (cpp_reader *pfile)\n     }\n   else if (token->type != CPP_EOF)\n     {\n-      cpp_error (pfile, DL_ERROR, \"\\\"%s\\\" is not a valid filename\",\n+      cpp_error (pfile, CPP_DL_ERROR, \"\\\"%s\\\" is not a valid filename\",\n \t\t cpp_token_as_text (pfile, token));\n       return;\n     }\n@@ -835,7 +836,8 @@ do_linemarker (cpp_reader *pfile)\n       || strtoul_for_line (token->val.str.text, token->val.str.len,\n \t\t\t   &new_lineno))\n     {\n-      cpp_error (pfile, DL_ERROR, \"\\\"%s\\\" after # is not a positive integer\",\n+      cpp_error (pfile, CPP_DL_ERROR,\n+\t\t \"\\\"%s\\\" after # is not a positive integer\",\n \t\t cpp_token_as_text (pfile, token));\n       return;\n     }\n@@ -873,7 +875,7 @@ do_linemarker (cpp_reader *pfile)\n     }\n   else if (token->type != CPP_EOF)\n     {\n-      cpp_error (pfile, DL_ERROR, \"\\\"%s\\\" is not a valid filename\",\n+      cpp_error (pfile, CPP_DL_ERROR, \"\\\"%s\\\" is not a valid filename\",\n \t\t cpp_token_as_text (pfile, token));\n       return;\n     }\n@@ -918,14 +920,14 @@ do_diagnostic (cpp_reader *pfile, int code, int print_dir)\n static void\n do_error (cpp_reader *pfile)\n {\n-  do_diagnostic (pfile, DL_ERROR, 1);\n+  do_diagnostic (pfile, CPP_DL_ERROR, 1);\n }\n \n static void\n do_warning (cpp_reader *pfile)\n {\n   /* We want #warning diagnostics to be emitted in system headers too.  */\n-  do_diagnostic (pfile, DL_WARNING_SYSHDR, 1);\n+  do_diagnostic (pfile, CPP_DL_WARNING_SYSHDR, 1);\n }\n \n /* Report program identification.  */\n@@ -935,7 +937,7 @@ do_ident (cpp_reader *pfile)\n   const cpp_token *str = cpp_get_token (pfile);\n \n   if (str->type != CPP_STRING)\n-    cpp_error (pfile, DL_ERROR, \"invalid #ident directive\");\n+    cpp_error (pfile, CPP_DL_ERROR, \"invalid #ident directive\");\n   else if (pfile->cb.ident)\n     pfile->cb.ident (pfile, pfile->directive_line, &str->val.str);\n \n@@ -1014,14 +1016,14 @@ cpp_register_pragma (cpp_reader *pfile, const char *space, const char *name,\n     {\n       if (entry->is_nspace)\n \tclash:\n-\tcpp_error (pfile, DL_ICE,\n+\tcpp_error (pfile, CPP_DL_ICE,\n \t\t \"registering \\\"%s\\\" as both a pragma and a pragma namespace\",\n \t\t NODE_NAME (node));\n       else if (space)\n-\tcpp_error (pfile, DL_ICE, \"#pragma %s %s is already registered\",\n+\tcpp_error (pfile, CPP_DL_ICE, \"#pragma %s %s is already registered\",\n \t\t   space, name);\n       else\n-\tcpp_error (pfile, DL_ICE, \"#pragma %s is already registered\", name);\n+\tcpp_error (pfile, CPP_DL_ICE, \"#pragma %s is already registered\", name);\n     }\n   else\n     insert_pragma_entry (pfile, chain, node, handler);\n@@ -1166,7 +1168,7 @@ static void\n do_pragma_once (cpp_reader *pfile)\n {\n   if (pfile->buffer->prev == NULL)\n-    cpp_error (pfile, DL_WARNING, \"#pragma once in main file\");\n+    cpp_error (pfile, CPP_DL_WARNING, \"#pragma once in main file\");\n \n   check_eol (pfile);\n   _cpp_mark_file_once_only (pfile, pfile->buffer->file);\n@@ -1188,7 +1190,8 @@ do_pragma_poison (cpp_reader *pfile)\n \tbreak;\n       if (tok->type != CPP_NAME)\n \t{\n-\t  cpp_error (pfile, DL_ERROR, \"invalid #pragma GCC poison directive\");\n+\t  cpp_error (pfile, CPP_DL_ERROR,\n+\t\t     \"invalid #pragma GCC poison directive\");\n \t  break;\n \t}\n \n@@ -1197,7 +1200,7 @@ do_pragma_poison (cpp_reader *pfile)\n \tcontinue;\n \n       if (hp->type == NT_MACRO)\n-\tcpp_error (pfile, DL_WARNING, \"poisoning existing macro \\\"%s\\\"\",\n+\tcpp_error (pfile, CPP_DL_WARNING, \"poisoning existing macro \\\"%s\\\"\",\n \t\t   NODE_NAME (hp));\n       _cpp_free_definition (hp);\n       hp->flags |= NODE_POISONED | NODE_DIAGNOSTIC;\n@@ -1217,7 +1220,7 @@ do_pragma_system_header (cpp_reader *pfile)\n   cpp_buffer *buffer = pfile->buffer;\n \n   if (buffer->prev == 0)\n-    cpp_error (pfile, DL_WARNING,\n+    cpp_error (pfile, CPP_DL_WARNING,\n \t       \"#pragma system_header ignored outside include file\");\n   else\n     {\n@@ -1242,14 +1245,15 @@ do_pragma_dependency (cpp_reader *pfile)\n \n   ordering = _cpp_compare_file_date (pfile, fname, angle_brackets);\n   if (ordering < 0)\n-    cpp_error (pfile, DL_WARNING, \"cannot find source file %s\", fname);\n+    cpp_error (pfile, CPP_DL_WARNING, \"cannot find source file %s\", fname);\n   else if (ordering > 0)\n     {\n-      cpp_error (pfile, DL_WARNING, \"current file is older than %s\", fname);\n+      cpp_error (pfile, CPP_DL_WARNING,\n+\t\t \"current file is older than %s\", fname);\n       if (cpp_get_token (pfile)->type != CPP_EOF)\n \t{\n \t  _cpp_backup_tokens (pfile, 1);\n-\t  do_diagnostic (pfile, DL_WARNING, 0);\n+\t  do_diagnostic (pfile, CPP_DL_WARNING, 0);\n \t}\n     }\n \n@@ -1358,7 +1362,7 @@ _cpp_do__Pragma (cpp_reader *pfile)\n   if (string)\n     destringize_and_run (pfile, &string->val.str);\n   else\n-    cpp_error (pfile, DL_ERROR,\n+    cpp_error (pfile, CPP_DL_ERROR,\n \t       \"_Pragma takes a parenthesized string literal\");\n }\n \n@@ -1437,13 +1441,13 @@ do_else (cpp_reader *pfile)\n   struct if_stack *ifs = buffer->if_stack;\n \n   if (ifs == NULL)\n-    cpp_error (pfile, DL_ERROR, \"#else without #if\");\n+    cpp_error (pfile, CPP_DL_ERROR, \"#else without #if\");\n   else\n     {\n       if (ifs->type == T_ELSE)\n \t{\n-\t  cpp_error (pfile, DL_ERROR, \"#else after #else\");\n-\t  cpp_error_with_line (pfile, DL_ERROR, ifs->line, 0,\n+\t  cpp_error (pfile, CPP_DL_ERROR, \"#else after #else\");\n+\t  cpp_error_with_line (pfile, CPP_DL_ERROR, ifs->line, 0,\n \t\t\t       \"the conditional began here\");\n \t}\n       ifs->type = T_ELSE;\n@@ -1470,13 +1474,13 @@ do_elif (cpp_reader *pfile)\n   struct if_stack *ifs = buffer->if_stack;\n \n   if (ifs == NULL)\n-    cpp_error (pfile, DL_ERROR, \"#elif without #if\");\n+    cpp_error (pfile, CPP_DL_ERROR, \"#elif without #if\");\n   else\n     {\n       if (ifs->type == T_ELSE)\n \t{\n-\t  cpp_error (pfile, DL_ERROR, \"#elif after #else\");\n-\t  cpp_error_with_line (pfile, DL_ERROR, ifs->line, 0,\n+\t  cpp_error (pfile, CPP_DL_ERROR, \"#elif after #else\");\n+\t  cpp_error_with_line (pfile, CPP_DL_ERROR, ifs->line, 0,\n \t\t\t       \"the conditional began here\");\n \t}\n       ifs->type = T_ELIF;\n@@ -1505,7 +1509,7 @@ do_endif (cpp_reader *pfile)\n   struct if_stack *ifs = buffer->if_stack;\n \n   if (ifs == NULL)\n-    cpp_error (pfile, DL_ERROR, \"#endif without #if\");\n+    cpp_error (pfile, CPP_DL_ERROR, \"#endif without #if\");\n   else\n     {\n       /* Only check EOL if was not originally skipping.  */\n@@ -1582,7 +1586,7 @@ parse_answer (cpp_reader *pfile, struct answer **answerp, int type)\n       if (type == T_UNASSERT && paren->type == CPP_EOF)\n \treturn 0;\n \n-      cpp_error (pfile, DL_ERROR, \"missing '(' after predicate\");\n+      cpp_error (pfile, CPP_DL_ERROR, \"missing '(' after predicate\");\n       return 1;\n     }\n \n@@ -1597,7 +1601,7 @@ parse_answer (cpp_reader *pfile, struct answer **answerp, int type)\n \n       if (token->type == CPP_EOF)\n \t{\n-\t  cpp_error (pfile, DL_ERROR, \"missing ')' to complete answer\");\n+\t  cpp_error (pfile, CPP_DL_ERROR, \"missing ')' to complete answer\");\n \t  return 1;\n \t}\n \n@@ -1617,7 +1621,7 @@ parse_answer (cpp_reader *pfile, struct answer **answerp, int type)\n \n   if (acount == 0)\n     {\n-      cpp_error (pfile, DL_ERROR, \"predicate's answer is empty\");\n+      cpp_error (pfile, CPP_DL_ERROR, \"predicate's answer is empty\");\n       return 1;\n     }\n \n@@ -1644,9 +1648,9 @@ parse_assertion (cpp_reader *pfile, struct answer **answerp, int type)\n   *answerp = 0;\n   predicate = cpp_get_token (pfile);\n   if (predicate->type == CPP_EOF)\n-    cpp_error (pfile, DL_ERROR, \"assertion without predicate\");\n+    cpp_error (pfile, CPP_DL_ERROR, \"assertion without predicate\");\n   else if (predicate->type != CPP_NAME)\n-    cpp_error (pfile, DL_ERROR, \"predicate must be an identifier\");\n+    cpp_error (pfile, CPP_DL_ERROR, \"predicate must be an identifier\");\n   else if (parse_answer (pfile, answerp, type) == 0)\n     {\n       unsigned int len = NODE_LEN (predicate->val.node);\n@@ -1730,7 +1734,7 @@ do_assert (cpp_reader *pfile)\n \t{\n \t  if (*find_answer (node, new_answer))\n \t    {\n-\t      cpp_error (pfile, DL_WARNING, \"\\\"%s\\\" re-asserted\",\n+\t      cpp_error (pfile, CPP_DL_WARNING, \"\\\"%s\\\" re-asserted\",\n \t\t\t NODE_NAME (node) + 1);\n \t      return;\n \t    }\n@@ -1940,7 +1944,7 @@ _cpp_pop_buffer (cpp_reader *pfile)\n   /* Walk back up the conditional stack till we reach its level at\n      entry to this file, issuing error messages.  */\n   for (ifs = buffer->if_stack; ifs; ifs = ifs->next)\n-    cpp_error_with_line (pfile, DL_ERROR, ifs->line, 0,\n+    cpp_error_with_line (pfile, CPP_DL_ERROR, ifs->line, 0,\n \t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n \n   /* In case of a missing #endif.  */"}, {"sha": "b1042957aa1443971a06524d736dc8a43c355929", "filename": "gcc/cpplib.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -655,21 +655,21 @@ cpp_num cpp_num_sign_extend (cpp_num, size_t);\n    with a line number of zero.  */\n \n /* Warning, an error with -Werror.  */\n-#define DL_WARNING\t\t0x00\n-/* Same as DL_WARNING, except it is not suppressed in system headers.  */\n-#define DL_WARNING_SYSHDR\t0x01\n+#define CPP_DL_WARNING\t\t0x00\n+/* Same as CPP_DL_WARNING, except it is not suppressed in system headers.  */\n+#define CPP_DL_WARNING_SYSHDR\t0x01\n /* Warning, an error with -pedantic-errors or -Werror.  */\n-#define DL_PEDWARN\t\t0x02\n+#define CPP_DL_PEDWARN\t\t0x02\n /* An error.  */\n-#define DL_ERROR\t\t0x03\n+#define CPP_DL_ERROR\t\t0x03\n /* An internal consistency check failed.  Prints \"internal error: \",\n-   otherwise the same as DL_ERROR.  */\n-#define DL_ICE\t\t\t0x04\n+   otherwise the same as CPP_DL_ERROR.  */\n+#define CPP_DL_ICE\t\t0x04\n /* Extracts a diagnostic level from an int.  */\n-#define DL_EXTRACT(l)\t\t(l & 0xf)\n+#define CPP_DL_EXTRACT(l)\t(l & 0xf)\n /* Nonzero if a diagnostic level is one of the warnings.  */\n-#define DL_WARNING_P(l)\t\t(DL_EXTRACT (l) >= DL_WARNING \\\n-\t\t\t\t && DL_EXTRACT (l) <= DL_PEDWARN)\n+#define CPP_DL_WARNING_P(l)\t(CPP_DL_EXTRACT (l) >= CPP_DL_WARNING \\\n+\t\t\t\t && CPP_DL_EXTRACT (l) <= CPP_DL_PEDWARN)\n \n /* N.B. The error-message-printer prototypes have not been nicely\n    formatted because exgettext needs to see 'msgid' on the same line"}, {"sha": "efae0f094e1d448d8ed53481c9420052f5da4c1f", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -81,7 +81,7 @@ _cpp_warn_if_unused_macro (cpp_reader *pfile, cpp_hashnode *node,\n \n       if (!macro->used\n \t  && MAIN_FILE_P (linemap_lookup (&pfile->line_maps, macro->line)))\n-\tcpp_error_with_line (pfile, DL_WARNING, macro->line, 0,\n+\tcpp_error_with_line (pfile, CPP_DL_WARNING, macro->line, 0,\n \t\t\t     \"macro \\\"%s\\\" is not used\", NODE_NAME (node));\n     }\n \n@@ -122,7 +122,7 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n   switch (node->value.builtin)\n     {\n     default:\n-      cpp_error (pfile, DL_ICE, \"invalid built-in macro \\\"%s\\\"\",\n+      cpp_error (pfile, CPP_DL_ICE, \"invalid built-in macro \\\"%s\\\"\",\n \t\t NODE_NAME (node));\n       break;\n \n@@ -217,7 +217,7 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n \t    }\n \t  else\n \t    {\n-\t      cpp_errno (pfile, DL_WARNING,\n+\t      cpp_errno (pfile, CPP_DL_WARNING,\n \t\t\t \"could not determine date and time\");\n \t\t\n \t      pfile->date = U\"\\\"??? ?? ????\\\"\";\n@@ -277,7 +277,7 @@ builtin_macro (cpp_reader *pfile, cpp_hashnode *node)\n   pfile->cur_token = _cpp_temp_token (pfile);\n   push_token_context (pfile, NULL, _cpp_lex_direct (pfile), 1);\n   if (pfile->buffer->cur != pfile->buffer->rlimit)\n-    cpp_error (pfile, DL_ICE, \"invalid built-in macro \\\"%s\\\"\",\n+    cpp_error (pfile, CPP_DL_ICE, \"invalid built-in macro \\\"%s\\\"\",\n \t       NODE_NAME (node));\n   _cpp_pop_buffer (pfile);\n \n@@ -389,7 +389,7 @@ stringify_arg (cpp_reader *pfile, macro_arg *arg)\n   /* Ignore the final \\ of invalid string literals.  */\n   if (backslash_count & 1)\n     {\n-      cpp_error (pfile, DL_WARNING,\n+      cpp_error (pfile, CPP_DL_WARNING,\n \t\t \"invalid string literal, ignoring final '\\\\'\");\n       dest--;\n     }\n@@ -472,7 +472,7 @@ paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)\n \n \t  /* Mandatory error for all apart from assembler.  */\n \t  if (CPP_OPTION (pfile, lang) != CLK_ASM)\n-\t    cpp_error (pfile, DL_ERROR,\n+\t    cpp_error (pfile, CPP_DL_ERROR,\n \t \"pasting \\\"%s\\\" and \\\"%s\\\" does not give a valid preprocessing token\",\n \t\t       cpp_token_as_text (pfile, lhs),\n \t\t       cpp_token_as_text (pfile, rhs));\n@@ -510,17 +510,17 @@ _cpp_arguments_ok (cpp_reader *pfile, cpp_macro *macro, const cpp_hashnode *node\n       if (argc + 1 == macro->paramc && macro->variadic)\n \t{\n \t  if (CPP_PEDANTIC (pfile) && ! macro->syshdr)\n-\t    cpp_error (pfile, DL_PEDWARN,\n+\t    cpp_error (pfile, CPP_DL_PEDWARN,\n \t\t       \"ISO C99 requires rest arguments to be used\");\n \t  return true;\n \t}\n \n-      cpp_error (pfile, DL_ERROR,\n+      cpp_error (pfile, CPP_DL_ERROR,\n \t\t \"macro \\\"%s\\\" requires %u arguments, but only %u given\",\n \t\t NODE_NAME (node), macro->paramc, argc);\n     }\n   else\n-    cpp_error (pfile, DL_ERROR,\n+    cpp_error (pfile, CPP_DL_ERROR,\n \t       \"macro \\\"%s\\\" passed %u arguments, but takes just %u\",\n \t       NODE_NAME (node), argc, macro->paramc);\n \n@@ -631,7 +631,7 @@ collect_args (cpp_reader *pfile, const cpp_hashnode *node)\n \t callers at the end of an -include-d file.  */\n       if (pfile->context->prev || pfile->state.in_directive)\n \t_cpp_backup_tokens (pfile, 1);\n-      cpp_error (pfile, DL_ERROR,\n+      cpp_error (pfile, CPP_DL_ERROR,\n \t\t \"unterminated argument list invoking macro \\\"%s\\\"\",\n \t\t NODE_NAME (node));\n     }\n@@ -734,7 +734,7 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node)\n \t  if (buff == NULL)\n \t    {\n \t      if (CPP_WTRADITIONAL (pfile) && ! node->value.macro->syshdr)\n-\t\tcpp_error (pfile, DL_WARNING,\n+\t\tcpp_error (pfile, CPP_DL_WARNING,\n  \"function-like macro \\\"%s\\\" must be used with arguments in traditional C\",\n \t\t\t   NODE_NAME (node));\n \n@@ -1238,7 +1238,7 @@ _cpp_save_parameter (cpp_reader *pfile, cpp_macro *macro, cpp_hashnode *node)\n   /* Constraint 6.10.3.6 - duplicate parameter names.  */\n   if (node->flags & NODE_MACRO_ARG)\n     {\n-      cpp_error (pfile, DL_ERROR, \"duplicate macro parameter \\\"%s\\\"\",\n+      cpp_error (pfile, CPP_DL_ERROR, \"duplicate macro parameter \\\"%s\\\"\",\n \t\t NODE_NAME (node));\n       return true;\n     }\n@@ -1282,15 +1282,15 @@ parse_params (cpp_reader *pfile, cpp_macro *macro)\n \t      && ! CPP_OPTION (pfile, discard_comments_in_macro_exp))\n \t    continue;\n \n-\t  cpp_error (pfile, DL_ERROR,\n+\t  cpp_error (pfile, CPP_DL_ERROR,\n \t\t     \"\\\"%s\\\" may not appear in macro parameter list\",\n \t\t     cpp_token_as_text (pfile, token));\n \t  return false;\n \n \tcase CPP_NAME:\n \t  if (prev_ident)\n \t    {\n-\t      cpp_error (pfile, DL_ERROR,\n+\t      cpp_error (pfile, CPP_DL_ERROR,\n \t\t\t \"macro parameters must be comma-separated\");\n \t      return false;\n \t    }\n@@ -1308,7 +1308,7 @@ parse_params (cpp_reader *pfile, cpp_macro *macro)\n \tcase CPP_COMMA:\n \t  if (!prev_ident)\n \t    {\n-\t      cpp_error (pfile, DL_ERROR, \"parameter name missing\");\n+\t      cpp_error (pfile, CPP_DL_ERROR, \"parameter name missing\");\n \t      return false;\n \t    }\n \t  prev_ident = 0;\n@@ -1322,11 +1322,11 @@ parse_params (cpp_reader *pfile, cpp_macro *macro)\n \t\t\t\t   pfile->spec_nodes.n__VA_ARGS__);\n \t      pfile->state.va_args_ok = 1;\n \t      if (! CPP_OPTION (pfile, c99) && CPP_OPTION (pfile, pedantic))\n-\t\tcpp_error (pfile, DL_PEDWARN,\n+\t\tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t\t   \"anonymous variadic macros were introduced in C99\");\n \t    }\n \t  else if (CPP_OPTION (pfile, pedantic))\n-\t    cpp_error (pfile, DL_PEDWARN,\n+\t    cpp_error (pfile, CPP_DL_PEDWARN,\n \t\t       \"ISO C does not permit named variadic macros\");\n \n \t  /* We're at the end, and just expect a closing parenthesis.  */\n@@ -1336,7 +1336,7 @@ parse_params (cpp_reader *pfile, cpp_macro *macro)\n \t  /* Fall through.  */\n \n \tcase CPP_EOF:\n-\t  cpp_error (pfile, DL_ERROR, \"missing ')' in macro parameter list\");\n+\t  cpp_error (pfile, CPP_DL_ERROR, \"missing ')' in macro parameter list\");\n \t  return false;\n \t}\n     }\n@@ -1398,7 +1398,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n       macro->fun_like = 1;\n     }\n   else if (ctoken->type != CPP_EOF && !(ctoken->flags & PREV_WHITE))\n-    cpp_error (pfile, DL_PEDWARN,\n+    cpp_error (pfile, CPP_DL_PEDWARN,\n \t       \"ISO C requires whitespace after the macro name\");\n \n   if (macro->fun_like)\n@@ -1426,7 +1426,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n \t  /* Let assembler get away with murder.  */\n \t  else if (CPP_OPTION (pfile, lang) != CLK_ASM)\n \t    {\n-\t      cpp_error (pfile, DL_ERROR,\n+\t      cpp_error (pfile, CPP_DL_ERROR,\n \t\t\t \"'#' is not followed by a macro parameter\");\n \t      return false;\n \t    }\n@@ -1445,7 +1445,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n \n \t  if (macro->count == 0 || token->type == CPP_EOF)\n \t    {\n-\t      cpp_error (pfile, DL_ERROR,\n+\t      cpp_error (pfile, CPP_DL_ERROR,\n \t\t \"'##' cannot appear at either end of a macro expansion\");\n \t      return false;\n \t    }\n@@ -1529,11 +1529,11 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n \n       if (warn_of_redefinition (pfile, node, macro))\n \t{\n-\t  cpp_error_with_line (pfile, DL_PEDWARN, pfile->directive_line, 0,\n+\t  cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->directive_line, 0,\n \t\t\t       \"\\\"%s\\\" redefined\", NODE_NAME (node));\n \n \t  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n-\t    cpp_error_with_line (pfile, DL_PEDWARN,\n+\t    cpp_error_with_line (pfile, CPP_DL_PEDWARN,\n \t\t\t\t node->value.macro->line, 0,\n \t\t\t \"this is the location of the previous definition\");\n \t}\n@@ -1584,7 +1584,7 @@ check_trad_stringification (cpp_reader *pfile, const cpp_macro *macro,\n \t  if (NODE_LEN (node) == len\n \t      && !memcmp (p, NODE_NAME (node), len))\n \t    {\n-\t      cpp_error (pfile, DL_WARNING,\n+\t      cpp_error (pfile, CPP_DL_WARNING,\n \t   \"macro argument \\\"%s\\\" would be stringified in traditional C\",\n \t\t\t NODE_NAME (node));\n \t      break;\n@@ -1607,7 +1607,7 @@ cpp_macro_definition (cpp_reader *pfile, const cpp_hashnode *node)\n \n   if (node->type != NT_MACRO || (node->flags & NODE_BUILTIN))\n     {\n-      cpp_error (pfile, DL_ICE,\n+      cpp_error (pfile, CPP_DL_ICE,\n \t\t \"invalid hash type %d in cpp_macro_definition\", node->type);\n       return 0;\n     }"}, {"sha": "872908de0bd57c15886acb0596340bec4ee63351", "filename": "gcc/cpppch.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpppch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpppch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpppch.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -80,7 +80,8 @@ write_macdef (cpp_reader *pfile, cpp_hashnode *hn, void *file_p)\n \tif (fwrite (&s, sizeof (s), 1, f) != 1\n \t    || fwrite (defn, 1, s.definition_length, f) != s.definition_length)\n \t  {\n-\t    cpp_errno (pfile, DL_ERROR, \"while writing precompiled header\");\n+\t    cpp_errno (pfile, CPP_DL_ERROR,\n+\t\t       \"while writing precompiled header\");\n \t    return 0;\n \t  }\n       }\n@@ -328,7 +329,7 @@ cpp_write_pch_deps (cpp_reader *r, FILE *f)\n   if (fwrite (&z, sizeof (z), 1, f) != 1\n       || fwrite (ss->definedstrs, ss->hashsize, 1, f) != 1)\n     {\n-      cpp_errno (r, DL_ERROR, \"while writing precompiled header\");\n+      cpp_errno (r, CPP_DL_ERROR, \"while writing precompiled header\");\n       return -1;\n     }\n   free (ss->definedstrs);\n@@ -352,7 +353,7 @@ cpp_write_pch_state (cpp_reader *r, FILE *f)\n   memset (&z, 0, sizeof (z));\n   if (fwrite (&z, sizeof (z), 1, f) != 1)\n     {\n-      cpp_errno (r, DL_ERROR, \"while writing precompiled header\");\n+      cpp_errno (r, CPP_DL_ERROR, \"while writing precompiled header\");\n       return -1;\n     }\n \n@@ -361,7 +362,7 @@ cpp_write_pch_state (cpp_reader *r, FILE *f)\n \n   if (deps_save (r->deps, f) != 0)\n     {\n-      cpp_errno (r, DL_ERROR, \"while writing precompiled header\");\n+      cpp_errno (r, CPP_DL_ERROR, \"while writing precompiled header\");\n       return -1;\n     }\n \n@@ -458,7 +459,7 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n \t  || h->flags & NODE_POISONED)\n \t{\n \t  if (CPP_OPTION (r, warn_invalid_pch))\n-\t    cpp_error (r, DL_WARNING_SYSHDR,\n+\t    cpp_error (r, CPP_DL_WARNING_SYSHDR,\n \t\t       \"%s: not used because `%.*s' not defined\",\n \t\t       name, m.name_length, namebuf);\n \t  goto fail;\n@@ -470,7 +471,7 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n \t  || memcmp (namebuf, newdefn, m.definition_length) != 0)\n \t{\n \t  if (CPP_OPTION (r, warn_invalid_pch))\n-\t    cpp_error (r, DL_WARNING_SYSHDR,\n+\t    cpp_error (r, CPP_DL_WARNING_SYSHDR,\n \t       \"%s: not used because `%.*s' defined as `%s' not `%.*s'\",\n \t\t       name, m.name_length, namebuf, newdefn + m.name_length,\n \t\t       m.definition_length - m.name_length,\n@@ -511,7 +512,7 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n       else\n \t{\n \t  if (CPP_OPTION (r, warn_invalid_pch))\n-\t    cpp_error (r, DL_WARNING_SYSHDR, \n+\t    cpp_error (r, CPP_DL_WARNING_SYSHDR, \n \t\t       \"%s: not used because `%s' is defined\",\n \t\t       name, first);\n \t  goto fail;\n@@ -525,7 +526,7 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n   return 0;\n \n  error:\n-  cpp_errno (r, DL_ERROR, \"while reading precompiled header\");\n+  cpp_errno (r, CPP_DL_ERROR, \"while reading precompiled header\");\n   return -1;\n \n  fail:\n@@ -711,6 +712,6 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n   return 0;\n   \n  error:\n-  cpp_errno (r, DL_ERROR, \"while reading precompiled header\");\n+  cpp_errno (r, CPP_DL_ERROR, \"while reading precompiled header\");\n   return -1;\n }"}, {"sha": "0f98a8ad3dda8e655f00c9586ca076787406a226", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -158,7 +158,7 @@ copy_comment (cpp_reader *pfile, const uchar *cur, int in_define)\n     unterminated = _cpp_skip_block_comment (pfile);\n     \n   if (unterminated)\n-    cpp_error_with_line (pfile, DL_ERROR, from_line, 0,\n+    cpp_error_with_line (pfile, CPP_DL_ERROR, from_line, 0,\n \t\t\t \"unterminated comment\");\n \n   /* Comments in directives become spaces so that tokens are properly\n@@ -667,7 +667,7 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n     _cpp_release_buff (pfile, fmacro.buff);\n \n   if (lex_state == ls_fun_close)\n-    cpp_error_with_line (pfile, DL_ERROR, fmacro.line, 0,\n+    cpp_error_with_line (pfile, CPP_DL_ERROR, fmacro.line, 0,\n \t\t\t \"unterminated argument list invoking macro \\\"%s\\\"\",\n \t\t\t NODE_NAME (fmacro.node));\n   return result;\n@@ -736,7 +736,7 @@ recursive_macro (cpp_reader *pfile, cpp_hashnode *node)\n     }\n \n   if (recursing)\n-    cpp_error (pfile, DL_ERROR,\n+    cpp_error (pfile, CPP_DL_ERROR,\n \t       \"detected recursion whilst expanding macro \\\"%s\\\"\",\n \t       NODE_NAME (node));\n "}, {"sha": "ad23793a4068640f2646ce964ab536780b793729", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0527bc4ebf78a3e1ae984f978fb4f7118a180add/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=0527bc4ebf78a3e1ae984f978fb4f7118a180add", "patch": "@@ -645,7 +645,7 @@ read_scan_file (char *in_fname, int argc, char **argv)\n     }\n \n   if (i < argc)\n-    cpp_error (scan_in, DL_ERROR, \"invalid option `%s'\", argv[i]);\n+    cpp_error (scan_in, CPP_DL_ERROR, \"invalid option `%s'\", argv[i]);\n   if (cpp_errors (scan_in))\n     exit (FATAL_EXIT_CODE);\n "}]}