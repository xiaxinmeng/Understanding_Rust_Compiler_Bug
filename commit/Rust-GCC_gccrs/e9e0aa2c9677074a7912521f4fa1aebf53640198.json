{"sha": "e9e0aa2c9677074a7912521f4fa1aebf53640198", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTllMGFhMmM5Njc3MDc0YTc5MTI1MjFmNGZhMWFlYmY1MzY0MDE5OA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2007-04-11T16:14:06Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2007-04-11T16:14:06Z"}, "message": "re PR tree-optimization/30735 (50% slow down due to mem-ssa merge)\n\n\n\tPR 30735\n\tPR 31090\n\t* doc/invoke.texi: Document --params max-aliased-vops and\n\tavg-aliased-vops.\n\t* tree-ssa-operands.h (get_mpt_for, dump_memory_partitions,\n\tdebug_memory_partitions): Move to tree-flow.h\n\t* params.h (AVG_ALIASED_VOPS): Define.\n\t* tree-ssa-alias.c (struct mp_info_def): Remove.  Update all\n\tusers.\n\t(mp_info_t): Likewise.\n\t(get_mem_sym_stats_for): New.\n\t(set_memory_partition): Move from tree-flow-inline.h.\n\t(mark_non_addressable): Only clear the set of symbols for the\n\tpartition if it exists.\n\t(dump_memory_partitions): Move from tree-ssa-operands.c\n\t(debug_memory_partitions): Likewise.\n\t(need_to_partition_p): New.\n\t(dump_mem_ref_stats): New.\n\t(debug_mem_ref_stats): New.\n\t(dump_mem_sym_stats): New.\n\t(debug_mem_sym_stats): New.\n\t(update_mem_sym_stats_from_stmt): New.\n\t(compare_mp_info_entries): New.\n\t(mp_info_cmp): Call it.\n\t(sort_mp_info): Change argument to a list of mem_sym_stats_t\n\tobjects.\n\t(get_mpt_for): Move from tree-ssa-operands.c.\n\t(find_partition_for): New.\n\t(create_partition_for): Remove.\n\t(estimate_vop_reduction): New.\n\t(update_reference_counts): New.\n\t(build_mp_info): New.\n\t(compute_memory_partitions): Refactor.\n\tDocument new heuristic.\n\tCall build_mp_info, update_reference_counts,\n\tfind_partition_for and estimate_vop_reduction.\n\t(compute_may_aliases): Populate virtual operands before\n\tcalling debugging dumps.\n\t(delete_mem_sym_stats): New.\n\t(delete_mem_ref_stats): New.\n\t(init_mem_ref_stats): New.\n\t(init_alias_info): Call it.\n\t(maybe_create_global_var): Remove alias_info argument.\n\tGet number of call sites and number of pure/const call sites\n\tfrom gimple_mem_ref_stats().\n\t(dump_alias_info): Call dump_memory_partitions first.\n\t(dump_points_to_info_for): Show how many times a pointer has\n\tbeen dereferenced.\n\t* opts.c (decode_options): For -O2 set --param\n\tmax-aliased-vops to 500.\n\tFor -O3 set --param max-aliased-vops to 1000 and --param\n\tavg-aliased-vops to 3.\n\t* fortran/options.c (gfc_init_options): Remove assignment to\n\tMAX_ALIASED_VOPS.\n\t* tree-flow-inline.h (gimple_mem_ref_stats): New.\n\t* tree-dfa.c (dump_variable): Dump memory reference\n\tstatistics.\n\tDump NO_ALIAS* settings.\n\t(referenced_var_lookup): Tidy.\n\t(mem_sym_stats): New.\n\t* tree-ssa-copy.c (may_propagate_copy): Return true if DEST\n\tand ORIG are different SSA names for a memory partition.\n\t* tree-ssa.c (delete_tree_ssa): Call delete_mem_ref_stats.\n\t* tree-flow.h (struct mem_sym_stats_d): Define.\n\t(mem_sym_stats_t): Define.\n\t(struct mem_ref_stats_d): Define.\n\t(struct gimple_df): Add field mem_ref_stats.\n\t(enum noalias_state): Define.\n\t(struct var_ann_d): Add bitfield noalias_state.\n\t(mem_sym_stats, delete_mem_ref_stats, dump_mem_ref_stats,\n\tdebug_mem_ref_stats, debug_memory_partitions,\n\tdebug_mem_sym_stats): Declare.\n\t* tree-ssa-structalias.c (update_alias_info): Update call\n\tsites, pure/const call sites and asm sites in structure\n\treturned by gimple_mem_ref_stats.\n\tRemove local variable IS_POTENTIAL_DEREF.\n\tIncrease NUM_DEREFS if the memory expression is a potential\n\tdereference.\n\tCall update_mem_sym_stats_from_stmt.\n\tIf the memory references memory, call\n\tupdate_mem_sym_stats_from_stmt for all the direct memory\n\tsymbol references found.\n\t(intra_create_variable_infos): Set noalias_state field for\n\tpointer arguments according to the value of\n\tflag_argument_noalias.\n\t* tree-ssa-structalias.h (struct alias_info): Remove fields\n\tnum_calls_found and num_pure_const_calls_found.\n\t(update_mem_sym_stats_from_stmt): Declare.\n\t* params.def (PARAM_MAX_ALIASED_VOPS): Change description.\n\tSet default value to 100.\n\t(PARAM_AVG_ALIASED_VOPS): Define.\n\nFrom-SVN: r123719", "tree": {"sha": "40007b60a5085028843a5b427234f0fd32072b58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40007b60a5085028843a5b427234f0fd32072b58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9e0aa2c9677074a7912521f4fa1aebf53640198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e0aa2c9677074a7912521f4fa1aebf53640198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9e0aa2c9677074a7912521f4fa1aebf53640198", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e0aa2c9677074a7912521f4fa1aebf53640198/comments", "author": null, "committer": null, "parents": [{"sha": "574e75f5fb8c1ee2e38d6da90a88bb6c546ebb84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574e75f5fb8c1ee2e38d6da90a88bb6c546ebb84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/574e75f5fb8c1ee2e38d6da90a88bb6c546ebb84"}], "stats": {"total": 1920, "additions": 1461, "deletions": 459}, "files": [{"sha": "87ce15410e44e4d32b229de575991f97b84ee614", "filename": "gcc/ChangeLog", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -1,3 +1,97 @@\n+2007-04-11  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 30735\n+\tPR 31090\n+\t* doc/invoke.texi: Document --params max-aliased-vops and\n+\tavg-aliased-vops.\n+\t* tree-ssa-operands.h (get_mpt_for, dump_memory_partitions,\n+\tdebug_memory_partitions): Move to tree-flow.h\n+\t* params.h (AVG_ALIASED_VOPS): Define.\n+\t* tree-ssa-alias.c (struct mp_info_def): Remove.  Update all\n+\tusers.\n+\t(mp_info_t): Likewise.\n+\t(get_mem_sym_stats_for): New.\n+\t(set_memory_partition): Move from tree-flow-inline.h.\n+\t(mark_non_addressable): Only clear the set of symbols for the\n+\tpartition if it exists.\n+\t(dump_memory_partitions): Move from tree-ssa-operands.c\n+\t(debug_memory_partitions): Likewise.\n+\t(need_to_partition_p): New.\n+\t(dump_mem_ref_stats): New.\n+\t(debug_mem_ref_stats): New.\n+\t(dump_mem_sym_stats): New.\n+\t(debug_mem_sym_stats): New.\n+\t(update_mem_sym_stats_from_stmt): New.\n+\t(compare_mp_info_entries): New.\n+\t(mp_info_cmp): Call it.\n+\t(sort_mp_info): Change argument to a list of mem_sym_stats_t\n+\tobjects.\n+\t(get_mpt_for): Move from tree-ssa-operands.c.\n+\t(find_partition_for): New.\n+\t(create_partition_for): Remove.\n+\t(estimate_vop_reduction): New.\n+\t(update_reference_counts): New.\n+\t(build_mp_info): New.\n+\t(compute_memory_partitions): Refactor.\n+\tDocument new heuristic.\n+\tCall build_mp_info, update_reference_counts,\n+\tfind_partition_for and estimate_vop_reduction.\n+\t(compute_may_aliases): Populate virtual operands before\n+\tcalling debugging dumps.\n+\t(delete_mem_sym_stats): New.\n+\t(delete_mem_ref_stats): New.\n+\t(init_mem_ref_stats): New.\n+\t(init_alias_info): Call it.\n+\t(maybe_create_global_var): Remove alias_info argument.\n+\tGet number of call sites and number of pure/const call sites\n+\tfrom gimple_mem_ref_stats().\n+\t(dump_alias_info): Call dump_memory_partitions first.\n+\t(dump_points_to_info_for): Show how many times a pointer has\n+\tbeen dereferenced.\n+\t* opts.c (decode_options): For -O2 set --param\n+\tmax-aliased-vops to 500.\n+\tFor -O3 set --param max-aliased-vops to 1000 and --param\n+\tavg-aliased-vops to 3.\n+\t* fortran/options.c (gfc_init_options): Remove assignment to\n+\tMAX_ALIASED_VOPS.\n+\t* tree-flow-inline.h (gimple_mem_ref_stats): New.\n+\t* tree-dfa.c (dump_variable): Dump memory reference\n+\tstatistics.\n+\tDump NO_ALIAS* settings.\n+\t(referenced_var_lookup): Tidy.\n+\t(mem_sym_stats): New.\n+\t* tree-ssa-copy.c (may_propagate_copy): Return true if DEST\n+\tand ORIG are different SSA names for a memory partition.\n+\t* tree-ssa.c (delete_tree_ssa): Call delete_mem_ref_stats.\n+\t* tree-flow.h (struct mem_sym_stats_d): Define.\n+\t(mem_sym_stats_t): Define.\n+\t(struct mem_ref_stats_d): Define.\n+\t(struct gimple_df): Add field mem_ref_stats.\n+\t(enum noalias_state): Define.\n+\t(struct var_ann_d): Add bitfield noalias_state.\n+\t(mem_sym_stats, delete_mem_ref_stats, dump_mem_ref_stats,\n+\tdebug_mem_ref_stats, debug_memory_partitions,\n+\tdebug_mem_sym_stats): Declare.\n+\t* tree-ssa-structalias.c (update_alias_info): Update call\n+\tsites, pure/const call sites and asm sites in structure\n+\treturned by gimple_mem_ref_stats.\n+\tRemove local variable IS_POTENTIAL_DEREF.\n+\tIncrease NUM_DEREFS if the memory expression is a potential\n+\tdereference.\n+\tCall update_mem_sym_stats_from_stmt.\n+\tIf the memory references memory, call\n+\tupdate_mem_sym_stats_from_stmt for all the direct memory\n+\tsymbol references found.\n+\t(intra_create_variable_infos): Set noalias_state field for\n+\tpointer arguments according to the value of\n+\tflag_argument_noalias.\n+\t* tree-ssa-structalias.h (struct alias_info): Remove fields\n+\tnum_calls_found and num_pure_const_calls_found.\n+\t(update_mem_sym_stats_from_stmt): Declare.\n+\t* params.def (PARAM_MAX_ALIASED_VOPS): Change description.\n+\tSet default value to 100.\n+\t(PARAM_AVG_ALIASED_VOPS): Define.\n+\n 2007-04-11  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/31530"}, {"sha": "5b104ccbbc450e21478160b683ffa60fb8e0a5d2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -6588,10 +6588,29 @@ The maximum instructions CSE process before flushing. The default is 1000.\n \n @item max-aliased-vops\n \n-Maximum number of virtual operands per statement allowed to represent\n-aliases before triggering the alias grouping heuristic.  Alias\n-grouping reduces compile times and memory consumption needed for\n-aliasing at the expense of precision loss in alias information.\n+Maximum number of virtual operands per function allowed to represent\n+aliases before triggering the alias partitioning heuristic.  Alias\n+partitioning reduces compile times and memory consumption needed for\n+aliasing at the expense of precision loss in alias information.  The\n+default value for this parameter is 100 for -O1, 500 for -O2 and 1000\n+for -O3.\n+\n+Notice that if a function contains more memory statements than the\n+value of this parameter, it is not really possible to achieve this\n+reduction.  In this case, the compiler will use the number of memory\n+statements as the value for @option{max-aliased-vops}.\n+\n+@item avg-aliased-vops\n+\n+Average number of virtual operands per statement allowed to represent\n+aliases before triggering the alias partitioning heuristic.  This\n+works in conjunction with @option{max-aliased-vops}.  If a function\n+contains more than @option{max-aliased-vops} virtual operators, then\n+memory symbols will be grouped into memory partitions until either the\n+total number of virtual operators is below @option{max-aliased-vops}\n+or the average number of virtual operators per memory statement is\n+below @option{avg-aliased-vops}.  The default value for this parameter\n+is 1 for -O1 and -O2, and 3 for -O3.\n \n @item ggc-min-expand\n "}, {"sha": "31c40768624ef2c29631d5d94583ac9071668689", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -117,10 +117,6 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n   /* -fshort-enums can be default on some targets.  */\n   gfc_option.fshort_enums = targetm.default_short_enums ();\n \n-  /* Increase MAX_ALIASED_VOPS to account for different characteristics\n-     of Fortran regarding VOPs.  */\n-  MAX_ALIASED_VOPS = 50;\n-\n   return CL_Fortran;\n }\n "}, {"sha": "195e4e18c3ca63c7e3ffdfa11c8e59b3127a8834", "filename": "gcc/opts.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -506,13 +506,20 @@ decode_options (unsigned int argc, const char **argv)\n           /* PRE tends to generate bigger code.  */\n           flag_tree_pre = 1;\n \t}\n+\n+      /* Allow more virtual operators to increase alias precision.  */\n+      set_param_value (\"max-aliased-vops\", 500);\n     }\n \n   if (optimize >= 3)\n     {\n       flag_inline_functions = 1;\n       flag_unswitch_loops = 1;\n       flag_gcse_after_reload = 1;\n+\n+      /* Allow even more virtual operators.  */\n+      set_param_value (\"max-aliased-vops\", 1000);\n+      set_param_value (\"avg-aliased-vops\", 3);\n     }\n \n   if (optimize < 2 || optimize_size)"}, {"sha": "72d51f8e75b9c6f44f9568f7ff347beba09b17c8", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -530,8 +530,13 @@ DEFPARAM(PARAM_MAX_RELOAD_SEARCH_INSNS,\n \n DEFPARAM(PARAM_MAX_ALIASED_VOPS,\n          \"max-aliased-vops\",\n-\t \"The maximum number of virtual operators per statement allowed to represent aliases before triggering alias grouping\",\n-\t 10, 0, 0)\n+\t \"The maximum number of virtual operators that a function is allowed to have before triggering memory partitioning heuristics\",\n+\t 100, 0, 0)\n+\n+DEFPARAM(PARAM_AVG_ALIASED_VOPS,\n+    \t \"avg-aliased-vops\",\n+\t \"The average number of virtual operators that memory statements are allowed to have before triggering memory partitioning heuristics\",\n+\t 1, 0, 0)\n \n DEFPARAM(PARAM_MAX_SCHED_REGION_BLOCKS,\n \t \"max-sched-region-blocks\","}, {"sha": "386e781c26ab7bdd7b1bc81e7a5443f32af261a3", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -146,6 +146,8 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_SMS_LOOP_AVERAGE_COUNT_THRESHOLD)\n #define MAX_ALIASED_VOPS \\\n   PARAM_VALUE (PARAM_MAX_ALIASED_VOPS)\n+#define AVG_ALIASED_VOPS \\\n+  PARAM_VALUE (PARAM_AVG_ALIASED_VOPS)\n #define INTEGER_SHARE_LIMIT \\\n   PARAM_VALUE (PARAM_INTEGER_SHARE_LIMIT)\n #define MAX_LAST_VALUE_RTL \\"}, {"sha": "bc070233198f675ec9f937930ead36c2fc940e16", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 55, "deletions": 12, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -346,34 +346,54 @@ dump_variable (FILE *file, tree var)\n   if (TREE_THIS_VOLATILE (var))\n     fprintf (file, \", is volatile\");\n \n+  if (mem_sym_stats (cfun, var))\n+    {\n+      mem_sym_stats_t stats = mem_sym_stats (cfun, var);\n+      fprintf (file, \", direct reads: %ld\", stats->num_direct_reads);\n+      fprintf (file, \", direct writes: %ld\", stats->num_direct_writes);\n+      fprintf (file, \", indirect reads: %ld\", stats->num_indirect_reads);\n+      fprintf (file, \", indirect writes: %ld\", stats->num_indirect_writes);\n+      fprintf (file, \", read frequency: %ld\", stats->frequency_reads);\n+      fprintf (file, \", write frequency: %ld\", stats->frequency_writes);\n+    }\n+\n   if (is_call_clobbered (var))\n     {\n+      const char *s = \"\";\n       var_ann_t va = var_ann (var);\n       unsigned int escape_mask = va->escape_mask;\n \n       fprintf (file, \", call clobbered\");\n       fprintf (file, \" (\");\n       if (escape_mask & ESCAPE_STORED_IN_GLOBAL)\n-\tfprintf (file, \", stored in global\");\n+\t{ fprintf (file, \"%sstored in global\", s); s = \", \"; }\n       if (escape_mask & ESCAPE_TO_ASM)\n-\tfprintf (file, \", goes through ASM\");\n+\t{ fprintf (file, \"%sgoes through ASM\", s); s = \", \"; }\n       if (escape_mask & ESCAPE_TO_CALL)\n-\tfprintf (file, \", passed to call\");\n+\t{ fprintf (file, \"%spassed to call\", s); s = \", \"; }\n       if (escape_mask & ESCAPE_BAD_CAST)\n-\tfprintf (file, \", bad cast\");\n+\t{ fprintf (file, \"%sbad cast\", s); s = \", \"; }\n       if (escape_mask & ESCAPE_TO_RETURN)\n-\tfprintf (file, \", returned from func\");\n+\t{ fprintf (file, \"%sreturned from func\", s); s = \", \"; }\n       if (escape_mask & ESCAPE_TO_PURE_CONST)\n-\tfprintf (file, \", passed to pure/const\");\n+\t{ fprintf (file, \"%spassed to pure/const\", s); s = \", \"; }\n       if (escape_mask & ESCAPE_IS_GLOBAL)\n-\tfprintf (file, \", is global var\");\n+\t{ fprintf (file, \"%sis global var\", s); s = \", \"; }\n       if (escape_mask & ESCAPE_IS_PARM)\n-\tfprintf (file, \", is incoming pointer\");\n+\t{ fprintf (file, \"%sis incoming pointer\", s); s = \", \"; }\n       if (escape_mask & ESCAPE_UNKNOWN)\n-\tfprintf (file, \", unknown escape\");\n-      fprintf (file, \" )\");\n+\t{ fprintf (file, \"%sunknown escape\", s); s = \", \"; }\n+      fprintf (file, \")\");\n     }\n \n+  if (ann->noalias_state == NO_ALIAS)\n+    fprintf (file, \", NO_ALIAS (does not alias other NO_ALIAS symbols)\");\n+  else if (ann->noalias_state == NO_ALIAS_GLOBAL)\n+    fprintf (file, \", NO_ALIAS_GLOBAL (does not alias other NO_ALIAS symbols\"\n+\t           \" and global vars)\");\n+  else if (ann->noalias_state == NO_ALIAS_ANYTHING)\n+    fprintf (file, \", NO_ALIAS_ANYTHING (does not alias any other symbols)\");\n+\n   if (gimple_default_def (cfun, var))\n     {\n       fprintf (file, \", default def: \");\n@@ -618,8 +638,8 @@ referenced_var_lookup (unsigned int uid)\n {\n   struct int_tree_map *h, in;\n   in.uid = uid;\n-  h = (struct int_tree_map *) htab_find_with_hash (gimple_referenced_vars (cfun),\n-\t\t\t\t\t\t   &in, uid);\n+  h = (struct int_tree_map *)\n+\thtab_find_with_hash (gimple_referenced_vars (cfun), &in, uid);\n   gcc_assert (h || uid == 0);\n   if (h)\n     return h->to;\n@@ -1011,3 +1031,26 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \n   return exp;\n }\n+\n+\n+/* Return memory reference statistics for variable VAR in function FN.\n+   This is computed by alias analysis, but it is not kept\n+   incrementally up-to-date.  So, these stats are only accurate if\n+   pass_may_alias has been run recently.  If no alias information\n+   exists, this function returns NULL.  */\n+\n+mem_sym_stats_t\n+mem_sym_stats (struct function *fn, tree var)\n+{\n+  void **slot;\n+  struct pointer_map_t *stats_map = gimple_mem_ref_stats (fn)->mem_sym_stats;\n+\n+  if (stats_map == NULL)\n+    return NULL;\n+\n+  slot = pointer_map_contains (stats_map, var);\n+  if (slot == NULL)\n+    return NULL;\n+\n+  return (mem_sym_stats_t) *slot;\n+}"}, {"sha": "054ddfa28ad6c2dac9e8100605cf90ad279eac7b", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -871,31 +871,6 @@ memory_partition (tree sym)\n   return tag;\n }\n \n-\n-/* Set MPT to be the memory partition associated with symbol SYM.  */\n-\n-static inline void\n-set_memory_partition (tree sym, tree mpt)\n-{\n-#if defined ENABLE_CHECKING\n-  if (mpt)\n-    gcc_assert (TREE_CODE (mpt) == MEMORY_PARTITION_TAG\n-\t        && !is_gimple_reg (sym));\n-#endif\n-  var_ann (sym)->mpt = mpt;\n-  if (mpt)\n-    {\n-      bitmap_set_bit (MPT_SYMBOLS (mpt), DECL_UID (sym));\n-\n-      /* MPT inherits the call-clobbering attributes from SYM.  */\n-      if (is_call_clobbered (sym))\n-\t{\n-\t  MTAG_GLOBAL (mpt) = 1;\n-\t  mark_call_clobbered (mpt, ESCAPE_IS_GLOBAL);\n-\t}\n-    }\n-}\n-\n /* Return true if NAME is a memory factoring SSA name (i.e., an SSA\n    name for a memory partition.  */\n \n@@ -1810,4 +1785,11 @@ gimple_ssa_operands (struct function *fun)\n {\n   return &fun->gimple_df->ssa_operands;\n }\n+\n+/* Map describing reference statistics for function FN.  */\n+static inline struct mem_ref_stats_d *\n+gimple_mem_ref_stats (struct function *fn)\n+{\n+  return &fn->gimple_df->mem_ref_stats;\n+}\n #endif /* _TREE_FLOW_INLINE_H  */"}, {"sha": "4d9b36e4ab885c2fb3a0d64bdcd2d02212c0ee4f", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 121, "deletions": 4, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -41,10 +41,85 @@ typedef struct basic_block_def *basic_block;\n #endif\n struct static_var_ann_d;\n \n+/* Memory reference statistics for individual memory symbols,\n+   collected during alias analysis.  */\n+struct mem_sym_stats_d GTY(())\n+{\n+  /* Memory symbol.  */\n+  tree var;\n+\n+  /* Nonzero if this entry has been assigned a partition.  */\n+  unsigned int partitioned_p : 1;\n+\n+  /* Nonzero if VAR is a memory partition tag that already contains\n+     call-clobbered variables in its partition set.  */\n+  unsigned int has_call_clobbered_vars : 1;\n+\n+  /* Number of direct reference sites.  A direct reference to VAR is any\n+     reference of the form 'VAR = ' or ' = VAR'.  For GIMPLE reg\n+     pointers, this is the number of sites where the pointer is\n+     dereferenced.  */\n+  long num_direct_writes;\n+  long num_direct_reads;\n+\n+  /* Number of indirect reference sites.  An indirect reference to VAR\n+     is any reference via a pointer that contains VAR in its points-to\n+     set or, in the case of call-clobbered symbols, a function call.  */\n+  long num_indirect_writes;\n+  long num_indirect_reads;\n+\n+  /* Execution frequency.  This is the sum of the execution\n+     frequencies of all the statements that reference this object\n+     weighted by the number of references in each statement.  This is\n+     the main key used to sort the list of symbols to partition.\n+     Symbols with high execution frequencies are put at the bottom of\n+     the work list (ie, they are partitioned last).\n+     Execution frequencies are taken directly from each basic block,\n+     so compiling with PGO enabled will increase the precision of this\n+     estimate.  */\n+  long frequency_reads;\n+  long frequency_writes;\n+\n+  /* Set of memory tags that contain VAR in their alias set.  */\n+  bitmap parent_tags;\n+};\n+\n+typedef struct mem_sym_stats_d *mem_sym_stats_t;\n+DEF_VEC_P(mem_sym_stats_t);\n+DEF_VEC_ALLOC_P(mem_sym_stats_t, heap);\n+\n+/* Memory reference statistics collected during alias analysis.  */\n+struct mem_ref_stats_d GTY(())\n+{\n+  /* Number of statements that make memory references.  */\n+  long num_mem_stmts;\n+\n+  /* Number of statements that make function calls.  */\n+  long num_call_sites;\n+\n+  /* Number of statements that make calls to pure/const functions.  */\n+  long num_pure_const_call_sites;\n+\n+  /* Number of ASM statements.  */\n+  long num_asm_sites;\n+\n+  /* Estimated number of virtual operands needed as computed by\n+   compute_memory_partitions.  */\n+  long num_vuses;\n+  long num_vdefs;\n+\n+  /* This maps every symbol used to make \"memory\" references\n+     (pointers, arrays, structures, etc) to an instance of struct\n+     mem_sym_stats_d describing reference statistics for the symbol.  */\n+  struct pointer_map_t * GTY((skip)) mem_sym_stats;\n+};\n+\n+\n /* Gimple dataflow datastructure. All publicly available fields shall have\n    gimple_ accessor defined in tree-flow-inline.h, all publicly modifiable\n    fields should have gimple_set accessor.  */\n-struct gimple_df GTY(()) {\n+struct gimple_df GTY(())\n+{\n   /* Array of all variables referenced in the function.  */\n   htab_t GTY((param_is (struct int_tree_map))) referenced_vars;\n \n@@ -98,6 +173,11 @@ struct gimple_df GTY(()) {\n   /* Hashtable of variables annotations.  Used for static variables only;\n      local variables have direct pointer in the tree node.  */\n   htab_t GTY((param_is (struct static_var_ann_d))) var_anns;\n+\n+  /* Memory reference statistics collected during alias analysis.\n+     This information is used to drive the memory partitioning\n+     heuristics in compute_memory_partitions.  */\n+  struct mem_ref_stats_d mem_ref_stats;\n };\n \n /* Accessors for internal use only.  Generic code should use abstraction\n@@ -205,6 +285,30 @@ enum need_phi_state {\n   NEED_PHI_STATE_MAYBE\n };\n \n+\n+/* The \"no alias\" attribute allows alias analysis to make more\n+   aggressive assumptions when assigning alias sets, computing\n+   points-to information and memory partitions.  These attributes\n+   are the result of user annotations or flags (e.g.,\n+   -fargument-noalias).  */\n+enum noalias_state {\n+    /* Default state.  No special assumptions can be made about this\n+       symbol.  */\n+    MAY_ALIAS = 0,\n+\n+    /* The symbol does not alias with other symbols that have a\n+       NO_ALIAS* attribute.  */\n+    NO_ALIAS,\n+\n+    /* The symbol does not alias with other symbols that have a\n+       NO_ALIAS*, and it may not alias with global symbols.  */\n+    NO_ALIAS_GLOBAL,\n+\n+    /* The symbol does not alias with any other symbols.  */\n+    NO_ALIAS_ANYTHING\n+};\n+\n+\n struct subvar;\n typedef struct subvar *subvar_t;\n \n@@ -246,12 +350,18 @@ struct var_ann_d GTY(())\n      in the VDEF list.  */\n   unsigned in_vdef_list : 1;\n \n-  /* True for HEAP and PARM_NOALIAS artificial variables.  */\n+  /* True for HEAP artificial variables.  These variables represent\n+     the memory area allocated by a call to malloc.  */\n   unsigned is_heapvar : 1;\n \n   /* True if the variable is call clobbered.  */\n   unsigned int call_clobbered : 1;\n \n+  /* This field describes several \"no alias\" attributes that some\n+     symbols are known to have.  See the enum's definition for more\n+     information on each attribute.  */\n+  ENUM_BITFIELD (noalias_state) noalias_state : 2;\n+\n   /* Memory partition tag assigned to this symbol.  */\n   tree mpt;\n \n@@ -694,10 +804,10 @@ extern void add_referenced_var (tree);\n extern void remove_referenced_var (tree);\n extern void mark_symbols_for_renaming (tree);\n extern void find_new_referenced_vars (tree *);\n-\n extern tree make_rename_temp (tree, const char *);\n extern void set_default_def (tree, tree);\n extern tree gimple_default_def (struct function *, tree);\n+extern struct mem_sym_stats_d *mem_sym_stats (struct function *, tree);\n \n /* In tree-phinodes.c  */\n extern void reserve_phi_args_for_new_edge (basic_block);\n@@ -725,7 +835,8 @@ extern bool may_be_aliased (tree);\n extern bool is_aliased_with (tree, tree);\n extern struct ptr_info_def *get_ptr_info (tree);\n extern void new_type_alias (tree, tree, tree);\n-extern void count_uses_and_derefs (tree, tree, unsigned *, unsigned *, bool *);\n+extern void count_uses_and_derefs (tree, tree, unsigned *, unsigned *,\n+\t\t\t\t   unsigned *);\n static inline subvar_t get_subvars_for_var (tree);\n static inline tree get_subvar_at (tree, unsigned HOST_WIDE_INT);\n static inline bool ref_contains_array_ref (tree);\n@@ -737,6 +848,12 @@ static inline bool overlap_subvar (unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   tree, bool *);\n extern tree create_tag_raw (enum tree_code, tree, const char *);\n+extern void delete_mem_ref_stats (struct function *);\n+extern void dump_mem_ref_stats (FILE *);\n+extern void debug_mem_ref_stats (void);\n+extern void debug_memory_partitions (void);\n+extern void debug_mem_sym_stats (tree var);\n+extern void debug_all_mem_sym_stats (void);\n \n /* Call-back function for walk_use_def_chains().  At each reaching\n    definition, a function with this prototype is called.  */"}, {"sha": "7fc8f455bcce08041607df1c52004c1664a4fb37", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 998, "deletions": 275, "changes": 1273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -58,21 +58,6 @@ struct alias_map_d\n };\n \n \n-/* Data structures used for computing memory partitions.  */\n-\n-struct mp_info_def\n-{\n-  /* Symbol or memory tag.  */\n-  tree var;\n-\n-  /* Number of virtual operators needed to represent references to VAR.  */\n-  long num_vops;\n-};\n-\n-typedef struct mp_info_def *mp_info_t;\n-DEF_VEC_P(mp_info_t);\n-DEF_VEC_ALLOC_P(mp_info_t, heap);\n-\n /* Counters used to display statistics on alias analysis.  */\n struct alias_stats_d\n {\n@@ -106,13 +91,66 @@ static void delete_alias_info (struct alias_info *);\n static void compute_flow_sensitive_aliasing (struct alias_info *);\n static void setup_pointers_and_addressables (struct alias_info *);\n static void create_global_var (void);\n-static void maybe_create_global_var (struct alias_info *ai);\n-static void set_pt_anything (tree ptr);\n+static void maybe_create_global_var (void);\n+static void set_pt_anything (tree);\n+\n+void debug_mp_info (VEC(mem_sym_stats_t,heap) *);\n+\n+\n+/* Return memory reference stats for symbol VAR.  Create a new slot in\n+   cfun->gimple_df->mem_sym_stats if needed.  */\n+\n+static struct mem_sym_stats_d *\n+get_mem_sym_stats_for (tree var)\n+{\n+  void **slot;\n+  struct mem_sym_stats_d *stats;\n+  struct pointer_map_t *map = gimple_mem_ref_stats (cfun)->mem_sym_stats;\n+  \n+  gcc_assert (map);\n+\n+  slot = pointer_map_insert (map, var);\n+  if (*slot == NULL)\n+    {\n+      stats = XCNEW (struct mem_sym_stats_d);\n+      stats->var = var;\n+      *slot = (void *) stats;\n+    }\n+  else\n+    stats = (struct mem_sym_stats_d *) *slot;\n+\n+  return stats;\n+}\n+\n+\n+/* Set MPT to be the memory partition associated with symbol SYM.  */\n+\n+static inline void\n+set_memory_partition (tree sym, tree mpt)\n+{\n+#if defined ENABLE_CHECKING\n+  if (mpt)\n+    gcc_assert (TREE_CODE (mpt) == MEMORY_PARTITION_TAG\n+\t        && !is_gimple_reg (sym));\n+#endif\n+\n+  var_ann (sym)->mpt = mpt;\n+  if (mpt)\n+    {\n+      if (MPT_SYMBOLS (mpt) == NULL)\n+\tMPT_SYMBOLS (mpt) = BITMAP_ALLOC (&alias_bitmap_obstack);\n+\n+      bitmap_set_bit (MPT_SYMBOLS (mpt), DECL_UID (sym));\n \n-void dump_mp_info (FILE *, VEC(mp_info_t,heap) *mp_info_t);\n-void debug_mp_info (VEC(mp_info_t,heap) *mp_info_t);\n+      /* MPT inherits the call-clobbering attributes from SYM.  */\n+      if (is_call_clobbered (sym))\n+\t{\n+\t  MTAG_GLOBAL (mpt) = 1;\n+\t  mark_call_clobbered (mpt, ESCAPE_IS_GLOBAL);\n+\t}\n+    }\n+}\n \n-/* Global declarations.  */\n \n /* Mark variable VAR as being non-addressable.  */\n \n@@ -134,7 +172,15 @@ mark_non_addressable (tree var)\n \n   if (mpt)\n     {\n-      bitmap_clear_bit (MPT_SYMBOLS (mpt), DECL_UID (var));\n+      /* Note that it's possible for a symbol to have an associated\n+\t MPT and the MPT have a NULL empty set.  During\n+\t init_alias_info, all MPTs get their sets cleared out, but the\n+\t symbols still point to the old MPTs that used to hold them.\n+\t This is done so that compute_memory_partitions can now which\n+\t symbols are losing or changing partitions and mark them for\n+\t renaming.  */\n+      if (MPT_SYMBOLS (mpt))\n+\tbitmap_clear_bit (MPT_SYMBOLS (mpt), DECL_UID (var));\n       set_memory_partition (var, NULL_TREE);\n     }\n }\n@@ -425,174 +471,475 @@ compute_call_clobbered (struct alias_info *ai)\n   compute_tag_properties ();\n }\n \n-/* Dump the MP_INFO array to FILE.  */\n \n-void\n-dump_mp_info (FILE *file, VEC(mp_info_t,heap) *mp_info)\n+/* Dump memory partition information to FILE.  */\n+\n+static void\n+dump_memory_partitions (FILE *file)\n {\n-  unsigned i;\n-  mp_info_t mp_p;\n+  unsigned i, npart;\n+  unsigned long nsyms;\n+  tree mpt;\n \n-  for (i = 0; VEC_iterate (mp_info_t, mp_info, i, mp_p); i++)\n+  fprintf (file, \"\\nMemory partitions\\n\\n\");\n+  for (i = 0, npart = 0, nsyms = 0;\n+       VEC_iterate (tree, gimple_ssa_operands (cfun)->mpt_table, i, mpt);\n+       i++)\n     {\n-      fprintf (file, \"%6lu\\t\", mp_p->num_vops);\n-      if (mp_p->var == NULL_TREE)\n+      if (mpt)\n \t{\n-\t  fprintf (file, \"CALL-CLOBBERED SYMBOLS: \");\n-\t  dump_decl_set (file, gimple_call_clobbered_vars (cfun));\n+\t  bitmap syms = MPT_SYMBOLS (mpt);\n+\t  unsigned long n = (syms) ? bitmap_count_bits (syms) : 0;\n+\n+\t  fprintf (file, \"#%u: \", i);\n+\t  print_generic_expr (file, mpt, 0);\n+\t  fprintf (file, \": %lu elements: \", n);\n+\t  dump_decl_set (file, syms);\n+\t  npart++;\n+\t  nsyms += n;\n \t}\n-      else\n-\tdump_variable (file, mp_p->var);\n     }\n+\n+  fprintf (file, \"\\n%u memory partitions holding %lu symbols\\n\", npart, nsyms);\n+}\n+\n+\n+/* Dump memory partition information to stderr.  */\n+\n+void\n+debug_memory_partitions (void)\n+{\n+  dump_memory_partitions (stderr);\n+}\n+\n+\n+/* Return true if memory partitioning is required given the memory\n+   reference estimates in STATS.  */\n+\n+static inline bool\n+need_to_partition_p (struct mem_ref_stats_d *stats)\n+{\n+  long num_vops = stats->num_vuses + stats->num_vdefs;\n+  long avg_vops = CEIL (num_vops, stats->num_mem_stmts);\n+  return (num_vops > (long) MAX_ALIASED_VOPS\n+          && avg_vops > (long) AVG_ALIASED_VOPS);\n+}\n+\n+\n+/* Count the actual number of virtual operators in CFUN.  Note that\n+   this is only meaningful after virtual operands have been populated,\n+   so it should be invoked at the end of compute_may_aliases.\n+\n+   The number of virtual operators are stored in *NUM_VDEFS_P and\n+   *NUM_VUSES_P, the number of partitioned symbols in\n+   *NUM_PARTITIONED_P and the number of unpartitioned symbols in\n+   *NUM_UNPARTITIONED_P.\n+\n+   If any of these pointers is NULL the corresponding count is not\n+   computed.  */\n+\n+static void\n+count_mem_refs (long *num_vuses_p, long *num_vdefs_p,\n+\t\tlong *num_partitioned_p, long *num_unpartitioned_p)\n+{\n+  block_stmt_iterator bsi;\n+  basic_block bb;\n+  long num_vdefs, num_vuses, num_partitioned, num_unpartitioned;\n+  referenced_var_iterator rvi;\n+  tree sym;\n+\n+  num_vuses = num_vdefs = num_partitioned = num_unpartitioned = 0;\n+\n+  if (num_vuses_p || num_vdefs_p)\n+    FOR_EACH_BB (bb)\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  if (stmt_references_memory_p (stmt))\n+\t    {\n+\t      num_vuses += NUM_SSA_OPERANDS (stmt, SSA_OP_VUSE);\n+\t      num_vdefs += NUM_SSA_OPERANDS (stmt, SSA_OP_VDEF);\n+\t    }\n+\t}\n+\n+  if (num_partitioned_p || num_unpartitioned_p)\n+    FOR_EACH_REFERENCED_VAR (sym, rvi)\n+      {\n+\tif (is_gimple_reg (sym))\n+\t  continue;\n+\n+\tif (memory_partition (sym))\n+\t  num_partitioned++;\n+\telse\n+\t  num_unpartitioned++;\n+      }\n+\n+  if (num_vdefs_p)\n+    *num_vdefs_p = num_vdefs;\n+\n+  if (num_vuses_p)\n+    *num_vuses_p = num_vuses;\n+\n+  if (num_partitioned_p)\n+    *num_partitioned_p = num_partitioned;\n+\n+  if (num_unpartitioned_p)\n+    *num_unpartitioned_p = num_unpartitioned;\n+}\n+\n+\n+/* Dump memory reference stats for function CFUN to FILE.  */\n+\n+void\n+dump_mem_ref_stats (FILE *file)\n+{\n+  long actual_num_vuses, actual_num_vdefs;\n+  long num_partitioned, num_unpartitioned;\n+  struct mem_ref_stats_d *stats;\n+  \n+  stats = gimple_mem_ref_stats (cfun);\n+\n+  count_mem_refs (&actual_num_vuses, &actual_num_vdefs, &num_partitioned,\n+                  &num_unpartitioned);\n+\n+  fprintf (file, \"\\nMemory reference statistics for %s\\n\\n\", \n+\t   lang_hooks.decl_printable_name (current_function_decl, 2));\n+\n+  fprintf (file, \"Number of memory statements:     %ld\\n\",\n+           stats->num_mem_stmts);\n+  fprintf (file, \"Number of call sites:            %ld\\n\",\n+\t   stats->num_call_sites);\n+  fprintf (file, \"Number of pure/const call sites: %ld\\n\",\n+\t   stats->num_pure_const_call_sites);\n+  fprintf (file, \"Number of asm sites:             %ld\\n\",\n+\t   stats->num_asm_sites);\n+  fprintf (file, \"Estimated number of loads:       %ld (%ld/stmt)\\n\",\n+\t   stats->num_vuses,\n+\t   (stats->num_mem_stmts)\n+\t   ? CEIL (stats->num_vuses, stats->num_mem_stmts)\n+\t   : 0);\n+  fprintf (file, \"Actual number of loads:          %ld (%ld/stmt)\\n\",\n+\t   actual_num_vuses, \n+\t   (stats->num_mem_stmts)\n+\t   ? CEIL (actual_num_vuses, stats->num_mem_stmts)\n+\t   : 0);\n+\n+  if (actual_num_vuses > stats->num_vuses + (stats->num_vuses / 25))\n+    fprintf (file, \"\\t(warning: estimation is lower by more than 25%%)\\n\");\n+\n+  fprintf (file, \"Estimated number of stores:      %ld (%ld/stmt)\\n\",\n+\t   stats->num_vdefs,\n+\t   (stats->num_mem_stmts)\n+\t   ? CEIL (stats->num_vdefs, stats->num_mem_stmts)\n+\t   : 0);\n+  fprintf (file, \"Actual number of stores:         %ld (%ld/stmt)\\n\",\n+\t   actual_num_vdefs, \n+\t   (stats->num_mem_stmts)\n+\t   ? CEIL (actual_num_vdefs, stats->num_mem_stmts)\n+\t   : 0);\n+\n+  if (actual_num_vdefs > stats->num_vdefs + (stats->num_vdefs / 25))\n+    fprintf (file, \"\\t(warning: estimation is lower by more than 25%%)\\n\");\n+\n+  fprintf (file, \"Partitioning thresholds:         MAX = %d   AVG = %d \"\n+           \"(%sNEED TO PARTITION)\\n\", MAX_ALIASED_VOPS, AVG_ALIASED_VOPS,\n+\t   need_to_partition_p (stats) ? \"\" : \"NO \");\n+  fprintf (file, \"Number of partitioned symbols:   %ld\\n\", num_partitioned);\n+  fprintf (file, \"Number of unpartitioned symbols: %ld\\n\", num_unpartitioned);\n+}\n+\n+\n+/* Dump memory reference stats for function FN to stderr.  */\n+\n+void\n+debug_mem_ref_stats (void)\n+{\n+  dump_mem_ref_stats (stderr);\n+}\n+\n+\n+/* Dump memory reference stats for variable VAR to FILE.  */\n+\n+static void\n+dump_mem_sym_stats (FILE *file, tree var)\n+{\n+  mem_sym_stats_t stats = mem_sym_stats (cfun, var);\n+\n+  if (stats == NULL)\n+    return;\n+\n+  fprintf (file, \"read frequency: %6ld, write frequency: %6ld, \"\n+           \"direct reads: %3ld, direct writes: %3ld, \"\n+\t   \"indirect reads: %4ld, indirect writes: %4ld, symbol: \",\n+\t   stats->frequency_reads, stats->frequency_writes,\n+\t   stats->num_direct_reads, stats->num_direct_writes,\n+\t   stats->num_indirect_reads, stats->num_indirect_writes);\n+  print_generic_expr (file, stats->var, 0);\n+  fprintf (file, \", tags: \");\n+  dump_decl_set (file, stats->parent_tags);\n+}\n+\n+\n+/* Dump memory reference stats for variable VAR to stderr.  */\n+\n+void\n+debug_mem_sym_stats (tree var)\n+{\n+  dump_mem_sym_stats (stderr, var);\n+}\n+\n+\n+/* Dump memory reference stats for all memory symbols to FILE.  */\n+\n+static void\n+dump_all_mem_sym_stats (FILE *file)\n+{\n+  referenced_var_iterator rvi;\n+  tree sym;\n+\n+  FOR_EACH_REFERENCED_VAR (sym, rvi)\n+    {\n+      if (is_gimple_reg (sym))\n+\tcontinue;\n+\n+      dump_mem_sym_stats (file, sym);\n+    }\n+}\n+\n+\n+/* Dump memory reference stats for all memory symbols to stderr.  */\n+\n+void\n+debug_all_mem_sym_stats (void)\n+{\n+  dump_all_mem_sym_stats (stderr);\n+}\n+\n+\n+/* Dump the MP_INFO array to FILE.  */\n+\n+static void\n+dump_mp_info (FILE *file, VEC(mem_sym_stats_t,heap) *mp_info)\n+{\n+  unsigned i;\n+  mem_sym_stats_t mp_p;\n+\n+  for (i = 0; VEC_iterate (mem_sym_stats_t, mp_info, i, mp_p); i++)\n+    if (!mp_p->partitioned_p)\n+      dump_mem_sym_stats (file, mp_p->var);\n }\n \n \n /* Dump the MP_INFO array to stderr.  */\n \n void\n-debug_mp_info (VEC(mp_info_t,heap) *mp_info)\n+debug_mp_info (VEC(mem_sym_stats_t,heap) *mp_info)\n {\n   dump_mp_info (stderr, mp_info);\n }\n \n \n-/* Comparison function for qsort used in sort_mp_info.  */\n+/* Update memory reference stats for symbol VAR in statement STMT.\n+   NUM_DIRECT_READS and NUM_DIRECT_WRITES specify the number of times\n+   that VAR is read/written in STMT (indirect reads/writes are not\n+   recorded by this function, see compute_memory_partitions).  */\n \n-static int\n-mp_info_cmp (const void *p, const void *q)\n+void\n+update_mem_sym_stats_from_stmt (tree var, tree stmt, long num_direct_reads,\n+                                long num_direct_writes)\n {\n-  mp_info_t e1 = *((const mp_info_t *) p);\n-  mp_info_t e2 = *((const mp_info_t *) q);\n+  mem_sym_stats_t stats;\n \n-  /* We want to sort in decreasing order.  */\n-  if (e1->num_vops < e2->num_vops)\n-    return 1;\n-  else if (e1->num_vops > e2->num_vops)\n+  gcc_assert (num_direct_reads >= 0 && num_direct_writes >= 0);\n+\n+  stats = get_mem_sym_stats_for (var);\n+\n+  stats->num_direct_reads += num_direct_reads;\n+  stats->frequency_reads += ((long) bb_for_stmt (stmt)->frequency\n+                             * num_direct_reads);\n+\n+  stats->num_direct_writes += num_direct_writes;\n+  stats->frequency_writes += ((long) bb_for_stmt (stmt)->frequency\n+                              * num_direct_writes);\n+}\n+\n+\n+/* The list is sorted by increasing partitioning score (PSCORE).\n+   This score is computed such that symbols with high scores are\n+   those that are least likely to be partitioned.  Given a symbol\n+   MP->VAR, PSCORE(S) is the result of the following weighted sum\n+\n+   PSCORE(S) =   FW * 64 + FR * 32\n+   \t       + DW * 16 + DR *  8 \n+   \t       + IW *  4 + IR *  2\n+               + NO_ALIAS\n+\n+   where\n+\n+   FW\t\tExecution frequency of writes to S\n+   FR\t\tExecution frequency of reads from S\n+   DW\t\tNumber of direct writes to S\n+   DR\t\tNumber of direct reads from S\n+   IW\t\tNumber of indirect writes to S\n+   IR\t\tNumber of indirect reads from S\n+   NO_ALIAS\tState of the NO_ALIAS* flags\n+\n+   The basic idea here is that symbols that are frequently\n+   written-to in hot paths of the code are the last to be considered\n+   for partitioning.  */\n+\n+static inline long\n+pscore (mem_sym_stats_t mp)\n+{\n+  return mp->frequency_writes * 64 + mp->frequency_reads * 32\n+         + mp->num_direct_writes * 16 + mp->num_direct_reads * 8\n+\t + mp->num_indirect_writes * 4 + mp->num_indirect_reads * 2\n+\t + var_ann (mp->var)->noalias_state;\n+}\n+\n+\n+/* Given two MP_INFO entries MP1 and MP2, return -1 if MP1->VAR should\n+   be partitioned before MP2->VAR, 0 if they are the same or 1 if\n+   MP1->VAR should be partitioned after MP2->VAR.  */\n+\n+static inline int\n+compare_mp_info_entries (mem_sym_stats_t mp1, mem_sym_stats_t mp2)\n+{\n+  long pscore1 = pscore (mp1);\n+  long pscore2 = pscore (mp2);\n+\n+  if (pscore1 < pscore2)\n     return -1;\n+  else if (pscore1 > pscore2)\n+    return 1;\n   else\n     return 0;\n }\n \n \n+/* Comparison routine for qsort.  The list is sorted by increasing\n+   partitioning score (PSCORE).  This score is computed such that\n+   symbols with high scores are those that are least likely to be\n+   partitioned.  */\n+\n+static int\n+mp_info_cmp (const void *p, const void *q)\n+{\n+  mem_sym_stats_t e1 = *((const mem_sym_stats_t *) p);\n+  mem_sym_stats_t e2 = *((const mem_sym_stats_t *) q);\n+  return compare_mp_info_entries (e1, e2);\n+}\n+\n+\n /* Sort the array of reference counts used to compute memory partitions.\n-   Elements are sorted in descending order of virtual operators needed.  */\n+   Elements are sorted in ascending order of execution frequency and \n+   descending order of virtual operators needed.  */\n \n static inline void\n-sort_mp_info (VEC(mp_info_t,heap) *list)\n+sort_mp_info (VEC(mem_sym_stats_t,heap) *list)\n {\n-  unsigned num = VEC_length (mp_info_t, list);\n+  unsigned num = VEC_length (mem_sym_stats_t, list);\n \n   if (num < 2)\n     return;\n \n   if (num == 2)\n     {\n-      if (VEC_index (mp_info_t, list, 0)->num_vops\n-\t  < VEC_index (mp_info_t, list, 1)->num_vops)\n+      if (compare_mp_info_entries (VEC_index (mem_sym_stats_t, list, 0),\n+\t                           VEC_index (mem_sym_stats_t, list, 1)) > 0)\n \t{  \n \t  /* Swap elements if they are in the wrong order.  */\n-\t  mp_info_t tmp = VEC_index (mp_info_t, list, 0);\n-\t  VEC_replace (mp_info_t, list, 0, VEC_index (mp_info_t, list, 1));\n-\t  VEC_replace (mp_info_t, list, 1, tmp);\n+\t  mem_sym_stats_t tmp = VEC_index (mem_sym_stats_t, list, 0);\n+\t  VEC_replace (mem_sym_stats_t, list, 0,\n+\t               VEC_index (mem_sym_stats_t, list, 1));\n+\t  VEC_replace (mem_sym_stats_t, list, 1, tmp);\n \t}\n \n       return;\n     }\n \n   /* There are 3 or more elements, call qsort.  */\n-  qsort (VEC_address (mp_info_t, list), VEC_length (mp_info_t, list), \n-\t sizeof (mp_info_t), mp_info_cmp);\n+  qsort (VEC_address (mem_sym_stats_t, list),\n+         VEC_length (mem_sym_stats_t, list), \n+\t sizeof (mem_sym_stats_t),\n+\t mp_info_cmp);\n }\n \n \n-/* Create a new partition to hold all the symbols aliased with\n-   MP_P->VAR.  If MP_P->VAR is NULL, it partitions the call-clobbered\n-   variables. Only symbols that are not already in another partition\n-   are added to the new partition created for MP_P->VAR.  */\n+/* Return the memory partition tag (MPT) associated with memory\n+   symbol SYM.  */\n \n-static void\n-create_partition_for (mp_info_t mp_p)\n+static tree\n+get_mpt_for (tree sym)\n {\n-  bitmap_iterator bi;\n-  tree mpt, sym;\n-  bitmap aliases;\n-  unsigned i;\n-\n-  if (mp_p->num_vops <= (long) MAX_ALIASED_VOPS)\n-    return;\n+  tree mpt;\n \n-  if (mp_p->var == NULL_TREE)\n+  /* Don't create a new tag unnecessarily.  */\n+  mpt = memory_partition (sym);\n+  if (mpt == NULL_TREE)\n     {\n-      bitmap_iterator bi;\n-      bitmap tmp;\n+      mpt = create_tag_raw (MEMORY_PARTITION_TAG, TREE_TYPE (sym), \"MPT\");\n+      TREE_ADDRESSABLE (mpt) = 0;\n+      add_referenced_var (mpt);\n+      VEC_safe_push (tree, heap, gimple_ssa_operands (cfun)->mpt_table, mpt);\n+      gcc_assert (MPT_SYMBOLS (mpt) == NULL);\n+      set_memory_partition (sym, mpt);\n+    }\n \n-      /* Since the partitions we create for call-clobbered variables\n-\t will also be marked call-clobbered, make a copy of the\n-\t original set to avoid confusing the iterator.  */\n-      tmp = BITMAP_ALLOC (NULL);\n-      bitmap_copy (tmp, gimple_call_clobbered_vars (cfun));\n+  return mpt;\n+}\n \n-      /* Process call-clobbered symbols when no MP_P->VAR is given.  */\n-      mpt = NULL_TREE;\n-      EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)\n-\t{\n-\t  tree sym = referenced_var (i);\n-\t  if (memory_partition (sym) == NULL_TREE)\n-\t    {\n-\t      if (mpt == NULL_TREE)\n-\t\t{\n-\t\t  mpt = get_mpt_for (sym);\n-\t\t  mp_p->num_vops++;\n-\t\t}\n \n-\t      mark_sym_for_renaming (mpt);\n-\t      mark_sym_for_renaming (sym);\n-\t      set_memory_partition (sym, mpt);\n-\t    }\n+/* Add MP_P->VAR to a memory partition and return the partition.  */\n \n-\t  mp_p->num_vops--;\n+static tree\n+find_partition_for (mem_sym_stats_t mp_p)\n+{\n+  unsigned i;\n+  VEC(tree,heap) *mpt_table;\n+  tree mpt;\n \n-\t  /* If we have already grouped enough, stop.  */\n-\t  if (mp_p->num_vops <= (long) MAX_ALIASED_VOPS)\n-\t    break;\n-\t}\n+  mpt_table = gimple_ssa_operands (cfun)->mpt_table;\n+  mpt = NULL_TREE;\n \n-      BITMAP_FREE (tmp);\n-    }\n-  else\n+  /* Find an existing partition for MP_P->VAR.  */\n+  for (i = 0; VEC_iterate (tree, mpt_table, i, mpt); i++)\n     {\n-      aliases = may_aliases (mp_p->var);\n-      gcc_assert (!bitmap_empty_p (aliases));\n+      mem_sym_stats_t mpt_stats;\n \n-      mpt = NULL_TREE;\n-      EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n-\t{\n-\t  sym = referenced_var (i);\n-\t  /* Only set the memory partition for aliased symbol SYM if\n-\t     SYM does not belong to another partition.  */\n-\t  if (memory_partition (sym) == NULL_TREE)\n-\t    {\n-\t      if (mpt == NULL_TREE)\n-\t\t{\n-\t\t  mpt = get_mpt_for (mp_p->var);\n-\t\t  mp_p->num_vops++;\n-\t\t}\n+      /* If MPT does not have any symbols yet, use it.  */\n+      if (MPT_SYMBOLS (mpt) == NULL)\n+\tbreak;\n \n-\t      mark_sym_for_renaming (mpt);\n-\t      mark_sym_for_renaming (sym);\n-\t      set_memory_partition (sym, mpt);\n-\t    }\n+      /* Otherwise, see if MPT has common parent tags with MP_P->VAR,\n+\t but avoid grouping clobbered variables with non-clobbered\n+\t variables (otherwise, this tends to creates a single memory\n+\t partition because other call-clobbered variables may have\n+\t common parent tags with non-clobbered ones).  */\n+      mpt_stats = get_mem_sym_stats_for (mpt);\n+      if (mp_p->parent_tags\n+\t  && mpt_stats->parent_tags\n+\t  && is_call_clobbered (mpt) == is_call_clobbered (mp_p->var)\n+\t  && bitmap_intersect_p (mpt_stats->parent_tags, mp_p->parent_tags))\n+\tbreak;\n \n-\t  mp_p->num_vops--;\n+      /* If no common parent tags are found, see if both MPT and\n+\t MP_P->VAR are call-clobbered.  */\n+      if (is_call_clobbered (mpt) && is_call_clobbered (mp_p->var))\n+\tbreak;\n+    }\n \n-\t  /* If we have already grouped enough, stop.  */\n-\t  if (mp_p->num_vops <= (long) MAX_ALIASED_VOPS)\n-\t    break;\n-\t}\n+  if (mpt == NULL_TREE)\n+    mpt = get_mpt_for (mp_p->var);\n+  else\n+    set_memory_partition (mp_p->var, mpt);\n \n-      if (mpt)\n-\tmark_call_clobbered (mpt, ESCAPE_UNKNOWN);\n-    }\n+  mp_p->partitioned_p = true;\n+\n+  mark_sym_for_renaming (mp_p->var);\n+  mark_sym_for_renaming (mpt);\n+\n+  return mpt;\n }\n \n \n@@ -608,170 +955,449 @@ rewrite_alias_set_for (tree tag, bitmap new_aliases)\n   unsigned i;\n   tree mpt, sym;\n \n-  if (tag == NULL_TREE)\n+  EXECUTE_IF_SET_IN_BITMAP (MTAG_ALIASES (tag), 0, i, bi)\n     {\n-      /* Do not rewrite CALL_CLOBBERED_VARS.  If a symbol S is taken\n-\t out of this set, the optimizers will no longer consider S as\n-\t call-clobbered, and that may lead to wrong transformations\n-\t (e.g., pass_tail_calls explicitly examines all the symbols in\n-\t the function to determine if it should enable tail-call\n-\t marking).  */\n-      return;\n+      sym = referenced_var (i);\n+      mpt = memory_partition (sym);\n+      if (mpt)\n+\tbitmap_set_bit (new_aliases, DECL_UID (mpt));\n+      else\n+\tbitmap_set_bit (new_aliases, DECL_UID (sym));\n     }\n-  else\n+\n+  /* Rebuild the may-alias array for TAG.  */\n+  bitmap_copy (MTAG_ALIASES (tag), new_aliases);\n+}\n+\n+\n+/* Determine how many virtual operands can be saved by partitioning\n+   MP_P->VAR into MPT.  When a symbol S is thrown inside a partition\n+   P, every virtual operand that used to reference S will now\n+   reference P.  Whether it reduces the number of virtual operands\n+   depends on:\n+\n+   1- Direct references to S are never saved.  Instead of the virtual\n+      operand to S, we will now have a virtual operand to P.\n+\n+   2- Indirect references to S are reduced only for those memory tags\n+      holding S that already had other symbols partitioned into P.\n+      For instance, if a memory tag T has the alias set { a b S c },\n+      the first time we partition S into P, the alias set will become\n+      { a b P c }, so no virtual operands will be saved. However, if\n+      we now partition symbol 'c' into P, then the alias set for T\n+      will become { a b P }, so we will be saving one virtual operand\n+      for every indirect reference to 'c'.\n+\n+   3- Is S is call-clobbered, we save as many virtual operands as\n+      call/asm sites exist in the code, but only if other\n+      call-clobbered symbols have been grouped into P.  The first\n+      call-clobbered symbol that we group does not produce any\n+      savings.\n+\n+   MEM_REF_STATS points to CFUN's memory reference information.  */\n+\n+static void\n+estimate_vop_reduction (struct mem_ref_stats_d *mem_ref_stats,\n+                        mem_sym_stats_t mp_p, tree mpt)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+  mem_sym_stats_t mpt_stats;\n+\n+  /* We should only get symbols with indirect references here.  */\n+  gcc_assert (mp_p->num_indirect_reads > 0 || mp_p->num_indirect_writes > 0);\n+\n+  /* Note that the only statistics we keep for MPT is the set of\n+     parent tags to know which memory tags have had alias members\n+     partitioned, and the indicator has_call_clobbered_vars.\n+     Reference counts are not important for MPT.  */\n+  mpt_stats = get_mem_sym_stats_for (mpt);\n+\n+  /* Traverse all the parent tags for MP_P->VAR.  For every tag T, if\n+     partition P is already grouping aliases of T, then reduce the\n+     number of virtual operands by the number of direct references\n+     to T.  */\n+  if (mp_p->parent_tags)\n     {\n-      /* Create a new alias set for TAG with the new partitions.  */\n+      if (mpt_stats->parent_tags == NULL)\n+\tmpt_stats->parent_tags = BITMAP_ALLOC (&alias_bitmap_obstack);\n \n-      EXECUTE_IF_SET_IN_BITMAP (MTAG_ALIASES (tag), 0, i, bi)\n+      EXECUTE_IF_SET_IN_BITMAP (mp_p->parent_tags, 0, i, bi)\n \t{\n-\t  sym = referenced_var (i);\n-\t  mpt = memory_partition (sym);\n-\t  if (mpt)\n-\t    bitmap_set_bit (new_aliases, DECL_UID (mpt));\n+\t  if (bitmap_bit_p (mpt_stats->parent_tags, i))\n+\t    {\n+\t      /* Partition MPT is already partitioning symbols in the\n+\t\t alias set for TAG.  This means that we are now saving\n+\t\t 1 virtual operand for every direct reference to TAG.  */\n+\t      tree tag = referenced_var (i);\n+\t      mem_sym_stats_t tag_stats = mem_sym_stats (cfun, tag);\n+\t      mem_ref_stats->num_vuses -= tag_stats->num_direct_reads;\n+\t      mem_ref_stats->num_vdefs -= tag_stats->num_direct_writes;\n+\t    }\n \t  else\n-\t    bitmap_set_bit (new_aliases, DECL_UID (sym));\n+\t    {\n+\t      /* This is the first symbol in tag I's alias set that is\n+\t\t being grouped under MPT.  We will not save any\n+\t\t virtual operands this time, but record that MPT is\n+\t\t grouping a symbol from TAG's alias set so that the\n+\t\t next time we get the savings.  */\n+\t      bitmap_set_bit (mpt_stats->parent_tags, i);\n+\t    }\n \t}\n+    }\n \n-      /* Rebuild the may-alias array for TAG.  */\n-      bitmap_copy (MTAG_ALIASES (tag), new_aliases);\n+  /* If MP_P->VAR is call-clobbered, and MPT is already grouping\n+     call-clobbered symbols, then we will save as many virtual\n+     operands as asm/call sites there are.  */\n+  if (is_call_clobbered (mp_p->var))\n+    {\n+      if (mpt_stats->has_call_clobbered_vars)\n+\tmem_ref_stats->num_vdefs -= mem_ref_stats->num_call_sites\n+\t                            + mem_ref_stats->num_asm_sites;\n+      else\n+\tmpt_stats->has_call_clobbered_vars = true;\n     }\n }\n \n \n-/* Compute memory partitions.\n-\n-   The partitioning is straightforward:\n-   \n-   1- All the memory tags and call-clobbered that cause virtual\n-      operators are collected into the MP_INFO table together with the\n-      number of virtual operands that would be needed to represent all\n-      the members in the alias set.\n-\n-   2- MP_INFO is sorted in decreasing order of virtual operators.\n-\n-   3- For every memory tag T in MP_INFO, a new partition MP is created.  \n-\n-   4- All the symbols S in T's alias set are examined.  If S is not\n-      already in another partition then S is added to partition MP.\n-\n-   6- The estimate of VOPS is updated, if it falls below\n-      MAX_ALIASED_VOPS, we stop.  */\n+/* Helper for compute_memory_partitions.  Transfer reference counts\n+   from pointers to their pointed-to sets.  Counters for pointers were\n+   computed by update_alias_info.  MEM_REF_STATS points to CFUN's\n+   memory reference information.  */\n \n static void\n-compute_memory_partitions (void)\n+update_reference_counts (struct mem_ref_stats_d *mem_ref_stats)\n {\n-  referenced_var_iterator rvi;\n-  tree var;\n   unsigned i;\n-  struct mp_info_def mp;\n-  mp_info_t mp_p;\n-  VEC(mp_info_t,heap) *mp_info;\n-  long max_num_vops = 0;\n-  bitmap new_aliases;\n+  bitmap_iterator bi;\n+  mem_sym_stats_t sym_stats;\n \n-  timevar_push (TV_MEMORY_PARTITIONING);\n+  for (i = 1; i < num_ssa_names; i++)\n+    {\n+      tree ptr;\n+      struct ptr_info_def *pi;\n \n-  mp_info = NULL;\n-  max_num_vops = 0;\n+      ptr = ssa_name (i);\n+      if (ptr\n+\t  && POINTER_TYPE_P (TREE_TYPE (ptr))\n+\t  && (pi = SSA_NAME_PTR_INFO (ptr)) != NULL\n+\t  && pi->is_dereferenced)\n+\t{\n+\t  unsigned j;\n+\t  bitmap_iterator bj;\n+\t  tree tag;\n+\t  mem_sym_stats_t ptr_stats, tag_stats;\n+\n+\t  /* If PTR has flow-sensitive points-to information, use\n+\t     PTR's name tag, otherwise use the symbol tag associated\n+\t     with PTR's symbol.  */\n+\t  if (pi->name_mem_tag)\n+\t    tag = pi->name_mem_tag;\n+\t  else\n+\t    tag = symbol_mem_tag (SSA_NAME_VAR (ptr));\n+\n+\t  ptr_stats = get_mem_sym_stats_for (ptr);\n+\t  tag_stats = get_mem_sym_stats_for (tag);\n+\n+\t  /* TAG has as many direct references as dereferences we\n+\t     found for its parent pointer.  */\n+\t  tag_stats->num_direct_reads += ptr_stats->num_direct_reads;\n+\t  tag_stats->num_direct_writes += ptr_stats->num_direct_writes;\n+\n+\t  /* All the dereferences of pointer PTR are considered direct\n+\t     references to PTR's memory tag (TAG).  In turn,\n+\t     references to TAG will become virtual operands for every\n+\t     symbol in TAG's alias set.  So, for every symbol ALIAS in\n+\t     TAG's alias set, add as many indirect references to ALIAS\n+\t     as direct references there are for TAG.  */\n+\t  if (MTAG_ALIASES (tag))\n+\t    EXECUTE_IF_SET_IN_BITMAP (MTAG_ALIASES (tag), 0, j, bj)\n+\t      {\n+\t\ttree alias = referenced_var (j);\n+\t\tsym_stats = get_mem_sym_stats_for (alias);\n+\n+\t\t/* All the direct references to TAG are indirect references\n+\t\t   to ALIAS.  */\n+\t\tsym_stats->num_indirect_reads += ptr_stats->num_direct_reads;\n+\t\tsym_stats->num_indirect_writes += ptr_stats->num_direct_writes;\n+\t\tsym_stats->frequency_reads += ptr_stats->frequency_reads;\n+\t\tsym_stats->frequency_writes += ptr_stats->frequency_writes;\n+\n+\t\t/* Indicate that TAG is one of ALIAS's parent tags.  */\n+\t\tif (sym_stats->parent_tags == NULL)\n+\t\t  sym_stats->parent_tags = BITMAP_ALLOC (&alias_bitmap_obstack);\n+\t\tbitmap_set_bit (sym_stats->parent_tags, DECL_UID (tag));\n+\t      }\n+\t}\n+    }\n+\n+  /* Call-clobbered symbols are indirectly written at every\n+     call/asm site.  */\n+  EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, i, bi)\n+    {\n+      tree sym = referenced_var (i);\n+      sym_stats = get_mem_sym_stats_for (sym);\n+      sym_stats->num_indirect_writes += mem_ref_stats->num_call_sites\n+\t                                + mem_ref_stats->num_asm_sites;\n+    }\n \n-  /* Add reference counts for all the call-clobbered variables.  */\n-  if (!bitmap_empty_p (gimple_call_clobbered_vars (cfun)))\n+  /* Addressable symbols are indirectly written at some ASM sites.\n+     Since only ASM sites that clobber memory actually affect\n+     addressable symbols, this is an over-estimation.  */\n+  EXECUTE_IF_SET_IN_BITMAP (gimple_addressable_vars (cfun), 0, i, bi)\n     {\n-      mp.var = NULL_TREE;\n-      mp.num_vops = bitmap_count_bits (gimple_call_clobbered_vars (cfun));\n-      max_num_vops = mp.num_vops;\n-      mp_p = xcalloc (1, sizeof (*mp_p));\n-      *mp_p = mp;\n-      VEC_safe_push (mp_info_t, heap, mp_info, mp_p);\n+      tree sym = referenced_var (i);\n+      sym_stats = get_mem_sym_stats_for (sym);\n+      sym_stats->num_indirect_writes += mem_ref_stats->num_asm_sites;\n     }\n+}\n+\n+\n+/* Helper for compute_memory_partitions.  Add all memory symbols to\n+   *MP_INFO_P and compute the initial estimate for the total number of\n+   virtual operands needed.  MEM_REF_STATS points to CFUN's memory\n+   reference information.  On exit, *TAGS_P will contain the list of\n+   memory tags whose alias set need to be rewritten after\n+   partitioning.  */\n+\n+static void\n+build_mp_info (struct mem_ref_stats_d *mem_ref_stats,\n+                 VEC(mem_sym_stats_t,heap) **mp_info_p,\n+\t\t VEC(tree,heap) **tags_p)\n+{\n+  tree var;\n+  referenced_var_iterator rvi;\n \n-  /* Add reference counts for all the symbol tags.  */\n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      if (TREE_CODE (var) != SYMBOL_MEMORY_TAG\n-\t  && TREE_CODE (var) != NAME_MEMORY_TAG)\n+      mem_sym_stats_t sym_stats;\n+      tree old_mpt;\n+\n+      /* We are only interested in memory symbols other than MPTs.  */\n+      if (is_gimple_reg (var) || TREE_CODE (var) == MEMORY_PARTITION_TAG)\n \tcontinue;\n \n-      /* Each reference to VAR will produce as many VOPs as elements\n-\t exist in its alias set.  */\n-      mp.var = var;\n-      if (!may_aliases (var))\n-\tmp.num_vops = 0;\n-      else\n-\tmp.num_vops = bitmap_count_bits (may_aliases (var));\n+      /* Collect memory tags into the TAGS array so that we can\n+\t rewrite their alias sets after partitioning.  */\n+      if (MTAG_P (var) && MTAG_ALIASES (var))\n+\tVEC_safe_push (tree, heap, *tags_p, var);\n \n-      /* No point grouping singleton alias sets.  */\n-      if (mp.num_vops <= 1)\n-\tcontinue;\n+      /* Since we are going to re-compute partitions, any symbols that\n+\t used to belong to a partition must be detached from it and\n+\t marked for renaming.  */\n+      if ((old_mpt = memory_partition (var)) != NULL)\n+\t{\n+\t  mark_sym_for_renaming (old_mpt);\n+\t  set_memory_partition (var, NULL_TREE);\n+\t  mark_sym_for_renaming (var);\n+\t}\n \n-      mp_p = xcalloc (1, sizeof (*mp_p));\n-      *mp_p = mp;\n-      VEC_safe_push (mp_info_t, heap, mp_info, mp_p);\n+      sym_stats = get_mem_sym_stats_for (var);\n+\n+      /* Add VAR's reference info to MP_INFO.  Note that the only\n+\t symbols that make sense to partition are those that have\n+\t indirect references.  If a symbol S is always directly\n+\t referenced, partitioning it will not reduce the number of\n+\t virtual operators.  The only symbols that are profitable to\n+\t partition are those that belong to alias sets and/or are\n+\t call-clobbered.  */\n+      if (sym_stats->num_indirect_reads > 0\n+\t  || sym_stats->num_indirect_writes > 0)\n+\tVEC_safe_push (mem_sym_stats_t, heap, *mp_info_p, sym_stats);\n+\n+      /* Update the number of estimated VOPS.  Note that direct\n+\t references to memory tags are always counted as indirect\n+\t references to their alias set members, so if a memory tag has\n+\t aliases, do not count its direct references to avoid double\n+\t accounting.  */\n+      if (!MTAG_P (var) || !MTAG_ALIASES (var))\n+\t{\n+\t  mem_ref_stats->num_vuses += sym_stats->num_direct_reads;\n+\t  mem_ref_stats->num_vdefs += sym_stats->num_direct_writes;\n+\t}\n \n-      if (mp.num_vops > max_num_vops)\n-\tmax_num_vops = mp.num_vops;\n+      mem_ref_stats->num_vuses += sym_stats->num_indirect_reads;\n+      mem_ref_stats->num_vdefs += sym_stats->num_indirect_writes;\n     }\n+}\n \n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\n%s: Maximum number of VOPS needed per statement: \"\n-\t       \"%ld\\n\", get_name (current_function_decl), max_num_vops);\n-    }\n+\n+/* Compute memory partitions.  A memory partition (MPT) is an\n+   arbitrary grouping of memory symbols, such that references to one\n+   member of the group is considered a reference to all the members of\n+   the group.\n+   \n+   As opposed to alias sets in memory tags, the grouping into\n+   partitions is completely arbitrary and only done to reduce the\n+   number of virtual operands.  The only rule that needs to be\n+   observed when creating memory partitions is that given two memory\n+   partitions MPT.i and MPT.j, they must not contain symbols in\n+   common.\n+\n+   Memory partitions are used when putting the program into Memory-SSA\n+   form.  In particular, in Memory-SSA PHI nodes are not computed for\n+   individual memory symbols.  They are computed for memory\n+   partitions.  This reduces the amount of PHI nodes in the SSA graph\n+   at the expense of precision (i.e., it makes unrelated stores affect\n+   each other).\n+   \n+   However, it is possible to increase precision by changing this\n+   partitioning scheme.  For instance, if the partitioning scheme is\n+   such that get_mpt_for is the identity function (that is,\n+   get_mpt_for (s) = s), this will result in ultimate precision at the\n+   expense of huge SSA webs.\n+\n+   At the other extreme, a partitioning scheme that groups all the\n+   symbols in the same set results in minimal SSA webs and almost\n+   total loss of precision.\n+\n+   There partitioning heuristic uses three parameters to decide the\n+   order in which symbols are processed.  The list of symbols is\n+   sorted so that symbols that are more likely to be partitioned are\n+   near the top of the list:\n+\n+   - Execution frequency.  If a memory references is in a frequently\n+     executed code path, grouping it into a partition may block useful\n+     transformations and cause sub-optimal code generation.  So, the\n+     partition heuristic tries to avoid grouping symbols with high\n+     execution frequency scores.  Execution frequency is taken\n+     directly from the basic blocks where every reference is made (see\n+     update_mem_sym_stats_from_stmt), which in turn uses the\n+     profile guided machinery, so if the program is compiled with PGO\n+     enabled, more accurate partitioning decisions will be made.\n+\n+   - Number of references.  Symbols with few references in the code,\n+     are partitioned before symbols with many references.\n+\n+   - NO_ALIAS attributes.  Symbols with any of the NO_ALIAS*\n+     attributes are partitioned after symbols marked MAY_ALIAS.\n+\n+   Once the list is sorted, the partitioning proceeds as follows:\n+\n+   1- For every symbol S in MP_INFO, create a new memory partition MP,\n+      if necessary.  To avoid memory partitions that contain symbols\n+      from non-conflicting alias sets, memory partitions are\n+      associated to the memory tag that holds S in its alias set.  So,\n+      when looking for a memory partition for S, the memory partition\n+      associated with one of the memory tags holding S is chosen.  If\n+      none exists, a new one is created.\n+\n+   2- Add S to memory partition MP.\n+\n+   3- Reduce by 1 the number of VOPS for every memory tag holding S.\n+\n+   4- If the total number of VOPS is less than MAX_ALIASED_VOPS or the\n+      average number of VOPS per statement is less than\n+      AVG_ALIASED_VOPS, stop.  Otherwise, go to the next symbol in the\n+      list.  */\n+\n+static void\n+compute_memory_partitions (void)\n+{\n+  tree tag;\n+  unsigned i;\n+  mem_sym_stats_t mp_p;\n+  VEC(mem_sym_stats_t,heap) *mp_info;\n+  bitmap new_aliases;\n+  VEC(tree,heap) *tags;\n+  struct mem_ref_stats_d *mem_ref_stats;\n+  int prev_max_aliased_vops;\n+\n+  mem_ref_stats = gimple_mem_ref_stats (cfun);\n+  gcc_assert (mem_ref_stats->num_vuses == 0 && mem_ref_stats->num_vdefs == 0);\n+\n+  if (mem_ref_stats->num_mem_stmts == 0)\n+    return;\n+\n+  timevar_push (TV_MEMORY_PARTITIONING);\n+\n+  mp_info = NULL;\n+  tags = NULL;\n+  prev_max_aliased_vops = MAX_ALIASED_VOPS;\n+\n+  /* Since we clearly cannot lower the number of virtual operators\n+     below the total number of memory statements in the function, we\n+     may need to adjust MAX_ALIASED_VOPS beforehand.  */\n+  if (MAX_ALIASED_VOPS < mem_ref_stats->num_mem_stmts)\n+    MAX_ALIASED_VOPS = mem_ref_stats->num_mem_stmts;\n+\n+  /* Update reference stats for all the pointed-to variables and\n+     memory tags.  */\n+  update_reference_counts (mem_ref_stats);\n+\n+  /* Add all the memory symbols to MP_INFO.  */\n+  build_mp_info (mem_ref_stats, &mp_info, &tags);\n \n   /* No partitions required if we are below the threshold.  */\n-  if (max_num_vops <= (long) MAX_ALIASED_VOPS)\n-    goto done;\n+  if (!need_to_partition_p (mem_ref_stats))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\nMemory partitioning NOT NEEDED for %s\\n\",\n+\t         get_name (current_function_decl));\n+      goto done;\n+    }\n \n-  /* Sort the MP_INFO array in order of decreasing number of\n-     virtual operands.  */\n+  /* Sort the MP_INFO array so that symbols that should be partitioned\n+     first are near the top of the list.  */\n   sort_mp_info (mp_info);\n \n   if (dump_file)\n     {\n-      fprintf (dump_file, \"\\nVOPS generated by pointer dereferences \"\n-\t\t\t  \"before partitioning:\\n\");\n+      fprintf (dump_file, \"\\nMemory partitioning NEEDED for %s\\n\\n\",\n+\t       get_name (current_function_decl));\n+      fprintf (dump_file, \"Memory symbol references before partitioning:\\n\");\n       dump_mp_info (dump_file, mp_info);\n     }\n \n-  /* Now that we have all the VOP generating tags in the MP_INFO array\n-     sorted by decreasing number of VOPS, create memory partitions and\n-     group aliased symbols into those partitions.  */\n-  for (i = 0; VEC_iterate (mp_info_t, mp_info, i, mp_p); i++)\n+  /* Create partitions for variables in MP_INFO until we have enough\n+     to lower the total number of VOPS below MAX_ALIASED_VOPS or if\n+     the average number of VOPS per statement is below\n+     AVG_ALIASED_VOPS.  */\n+  for (i = 0; VEC_iterate (mem_sym_stats_t, mp_info, i, mp_p); i++)\n     {\n-      /* Stop processing if we are already below the threshold.  */\n-      if (mp_p->num_vops <= (long) MAX_ALIASED_VOPS)\n+      tree mpt;\n+\n+      /* If we are below the threshold, stop.  */\n+      if (!need_to_partition_p (mem_ref_stats))\n \tbreak;\n \n-      create_partition_for (mp_p);\n+      mpt = find_partition_for (mp_p);\n+      estimate_vop_reduction (mem_ref_stats, mp_p, mpt);\n     }\n \n   /* After partitions have been created, rewrite alias sets to use\n      them instead of the original symbols.  This way, if the alias set\n      was computed as { a b c d e f }, and the subset { b e f } was\n      grouped into partition MPT.3, then the new alias set for the tag\n-     will be  { a c d MPT.3 }.  */\n+     will be  { a c d MPT.3 }.\n+     \n+     Note that this is not strictly necessary.  The operand scanner\n+     will always check if a symbol belongs to a partition when adding\n+     virtual operands.  However, by reducing the size of the alias\n+     sets to be scanned, the work needed inside the operand scanner is\n+     significantly reduced.  */\n   new_aliases = BITMAP_ALLOC (NULL);\n \n-  for (i = 0; VEC_iterate (mp_info_t, mp_info, i, mp_p); i++)\n+  for (i = 0; VEC_iterate (tree, tags, i, tag); i++)\n     {\n-      rewrite_alias_set_for (mp_p->var, new_aliases);\n+      rewrite_alias_set_for (tag, new_aliases);\n       bitmap_clear (new_aliases);\n     }\n \n   BITMAP_FREE (new_aliases);\n \n   if (dump_file)\n     {\n-      fprintf (dump_file, \"\\nVOPS generated by pointer dereferences \"\n-\t\t\t  \"after partitioning:\\n\");\n+      fprintf (dump_file, \"\\nMemory symbol references after partitioning:\\n\");\n       dump_mp_info (dump_file, mp_info);\n     }\n \n done:\n   /* Free allocated memory.  */\n-  for (i = 0; VEC_iterate (mp_info_t, mp_info, i, mp_p); i++)\n-    free (mp_p);\n-  VEC_free (mp_info_t, heap, mp_info);\n+  VEC_free (mem_sym_stats_t, heap, mp_info);\n+  VEC_free (tree, heap, tags);\n+\n+  MAX_ALIASED_VOPS = prev_max_aliased_vops;\n \n   timevar_pop (TV_MEMORY_PARTITIONING);\n }\n@@ -882,9 +1508,10 @@ compute_memory_partitions (void)\n    compilation time.\n \n    When the number of virtual operands needed to represent aliased\n-   loads and stores grows too large (configurable with @option{--param\n-   max-aliased-vops}), alias sets are grouped to avoid severe\n-   compile-time slow downs and memory consumption.  See group_aliases.  */\n+   loads and stores grows too large (configurable with option --param\n+   max-aliased-vops and --param avg-aliased-vops), alias sets are\n+   grouped to avoid severe compile-time slow downs and memory\n+   consumption. See compute_memory_partitions.  */\n \n static unsigned int\n compute_may_aliases (void)\n@@ -923,7 +1550,7 @@ compute_may_aliases (void)\n      contains a mixture of pure and non-pure functions, then we need\n      to create use-def and def-def links between these functions to\n      avoid invalid transformations on them.  */\n-  maybe_create_global_var (ai);\n+  maybe_create_global_var ();\n \n   /* If the program contains ref-all pointers, finalize may-alias information\n      for them.  This pass needs to be run after call-clobbering information\n@@ -934,30 +1561,53 @@ compute_may_aliases (void)\n   /* Compute memory partitions for every memory variable.  */\n   compute_memory_partitions ();\n \n+  /* Remove partitions with no symbols.  Partitions may end up with an\n+     empty MPT_SYMBOLS set if a previous round of alias analysis\n+     needed to partition more symbols.  Since we don't need those\n+     partitions anymore, remove them to free up the space.  */\n+  {\n+    tree mpt;\n+    unsigned i;\n+    VEC(tree,heap) *mpt_table;\n+\n+    mpt_table = gimple_ssa_operands (cfun)->mpt_table;\n+    i = 0;\n+    while (i < VEC_length (tree, mpt_table))\n+      {\n+\tmpt = VEC_index (tree, mpt_table, i);\n+\tif (MPT_SYMBOLS (mpt) == NULL)\n+\t  VEC_unordered_remove (tree, mpt_table, i);\n+\telse\n+\t  i++;\n+      }\n+  }\n+\n+  /* Populate all virtual operands and newly promoted register operands.  */\n+  {\n+    block_stmt_iterator bsi;\n+    basic_block bb;\n+    FOR_EACH_BB (bb)\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\tupdate_stmt_if_modified (bsi_stmt (bsi));\n+  }\n+\n   /* Debugging dumps.  */\n   if (dump_file)\n     {\n-      dump_referenced_vars (dump_file);\n+      dump_mem_ref_stats (dump_file);\n+      dump_alias_info (dump_file);\n+      dump_points_to_info (dump_file);\n+\n       if (dump_flags & TDF_STATS)\n \tdump_alias_stats (dump_file);\n-      dump_points_to_info (dump_file);\n-      dump_alias_info (dump_file);\n+\n+      if (dump_flags & TDF_DETAILS)\n+\tdump_referenced_vars (dump_file);\n     }\n-  \n+\n   /* Deallocate memory used by aliasing data structures.  */\n   delete_alias_info (ai);\n-\n-  {\n-    block_stmt_iterator bsi;\n-    basic_block bb;\n-    FOR_EACH_BB (bb)\n-      {\n-        for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-          {\n-            update_stmt_if_modified (bsi_stmt (bsi));\n-          }\n-      }\n-  }\n+  \n   return 0;\n }\n \n@@ -975,8 +1625,10 @@ struct tree_opt_pass pass_may_alias =\n   PROP_alias,\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_update_ssa\n-    | TODO_ggc_collect | TODO_verify_ssa\n+  TODO_dump_func\n+    | TODO_update_ssa\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa\n     | TODO_verify_stmts, \t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n@@ -1016,20 +1668,21 @@ count_ptr_derefs (tree *tp, int *walk_subtrees, void *data)\n \n \n /* Count the number of direct and indirect uses for pointer PTR in\n-   statement STMT.  The two counts are stored in *NUM_USES_P and\n-   *NUM_DEREFS_P respectively.  *IS_STORE_P is set to 'true' if at\n-   least one of those dereferences is a store operation.  */\n+   statement STMT.  The number of direct uses is stored in\n+   *NUM_USES_P.  Indirect references are counted separately depending\n+   on whether they are store or load operations.  The counts are\n+   stored in *NUM_STORES_P and *NUM_LOADS_P.  */\n \n void\n count_uses_and_derefs (tree ptr, tree stmt, unsigned *num_uses_p,\n-\t\t       unsigned *num_derefs_p, bool *is_store)\n+\t\t       unsigned *num_loads_p, unsigned *num_stores_p)\n {\n   ssa_op_iter i;\n   tree use;\n \n   *num_uses_p = 0;\n-  *num_derefs_p = 0;\n-  *is_store = false;\n+  *num_loads_p = 0;\n+  *num_stores_p = 0;\n \n   /* Find out the total number of uses of PTR in STMT.  */\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, i, SSA_OP_USE)\n@@ -1073,31 +1726,79 @@ count_uses_and_derefs (tree ptr, tree stmt, unsigned *num_uses_p,\n \t  rhs = stmt;\n \t}\n \n-      if (lhs && (TREE_CODE (lhs) == TREE_LIST\n-\t\t  || EXPR_P (lhs) || GIMPLE_STMT_P (lhs)))\n+      if (lhs\n+\t  && (TREE_CODE (lhs) == TREE_LIST\n+\t      || EXPR_P (lhs)\n+\t      || GIMPLE_STMT_P (lhs)))\n \t{\n \t  struct count_ptr_d count;\n \t  count.ptr = ptr;\n \t  count.count = 0;\n \t  walk_tree (&lhs, count_ptr_derefs, &count, NULL);\n-\t  *is_store = true;\n-\t  *num_derefs_p = count.count;\n+\t  *num_stores_p = count.count;\n \t}\n \n-      if (rhs && (TREE_CODE (rhs) == TREE_LIST\n-\t\t  || EXPR_P (rhs) || GIMPLE_STMT_P (rhs)))\n+      if (rhs\n+\t  && (TREE_CODE (rhs) == TREE_LIST\n+\t      || EXPR_P (rhs)\n+\t      || GIMPLE_STMT_P (rhs)))\n \t{\n \t  struct count_ptr_d count;\n \t  count.ptr = ptr;\n \t  count.count = 0;\n \t  walk_tree (&rhs, count_ptr_derefs, &count, NULL);\n-\t  *num_derefs_p += count.count;\n+\t  *num_loads_p = count.count;\n \t}\n     }\n \n-  gcc_assert (*num_uses_p >= *num_derefs_p);\n+  gcc_assert (*num_uses_p >= *num_loads_p + *num_stores_p);\n+}\n+\n+\n+/* Helper for delete_mem_ref_stats.  Free all the slots in the\n+   mem_sym_stats map.  */\n+\n+static bool\n+delete_mem_sym_stats (void *key ATTRIBUTE_UNUSED, void **value,\n+\t\t       void *data ATTRIBUTE_UNUSED)\n+{\n+  XDELETE (*value);\n+  *value = NULL;\n+  return false;\n+}\n+\n+\n+/* Remove memory references stats for function FN.  */\n+\n+void\n+delete_mem_ref_stats (struct function *fn)\n+{\n+  if (gimple_mem_ref_stats (fn)->mem_sym_stats)\n+    {\n+      pointer_map_traverse (gimple_mem_ref_stats (fn)->mem_sym_stats,\n+\t\t\t    delete_mem_sym_stats, NULL);\n+      pointer_map_destroy (gimple_mem_ref_stats (fn)->mem_sym_stats);\n+    }\n+\n+  gimple_mem_ref_stats (fn)->mem_sym_stats = NULL;\n }\n \n+\n+/* Initialize memory reference stats.  */\n+\n+static void\n+init_mem_ref_stats (void)\n+{\n+  struct mem_ref_stats_d *mem_ref_stats = gimple_mem_ref_stats (cfun);\n+\n+  if (mem_ref_stats->mem_sym_stats)\n+    delete_mem_ref_stats (cfun);\n+\n+  memset (mem_ref_stats, 0, sizeof (struct mem_ref_stats_d));\n+  mem_ref_stats->mem_sym_stats = pointer_map_create ();\n+}\n+\n+\n /* Initialize the data structures used for alias analysis.  */\n \n static struct alias_info *\n@@ -1115,6 +1816,9 @@ init_alias_info (void)\n   ai->dereferenced_ptrs_store = pointer_set_create ();\n   ai->dereferenced_ptrs_load = pointer_set_create ();\n \n+  /* Clear out all memory reference stats.  */\n+  init_mem_ref_stats ();\n+\n   /* If aliases have been computed before, clear existing information.  */\n   if (gimple_aliases_computed_p (cfun))\n     {\n@@ -1130,21 +1834,29 @@ init_alias_info (void)\n       /* Clear flow-insensitive alias information from each symbol.  */\n       FOR_EACH_REFERENCED_VAR (var, rvi)\n \t{\n+\t  if (is_gimple_reg (var))\n+\t    continue;\n+\n \t  if (MTAG_P (var))\n \t    MTAG_ALIASES (var) = NULL;\n \n+\t  /* Memory partition information will be computed from scratch.  */\n+\t  if (TREE_CODE (var) == MEMORY_PARTITION_TAG)\n+\t    MPT_SYMBOLS (var) = NULL;\n+\n \t  /* Since we are about to re-discover call-clobbered\n \t     variables, clear the call-clobbered flag.  Variables that\n \t     are intrinsically call-clobbered (globals, local statics,\n \t     etc) will not be marked by the aliasing code, so we can't\n \t     remove them from CALL_CLOBBERED_VARS.  \n \n-\t     NB: STRUCT_FIELDS are still call clobbered if they are for\n-\t     a global variable, so we *don't* clear their call clobberedness\n-\t     just because they are tags, though we will clear it if they\n-\t     aren't for global variables.  */\n+\t     NB: STRUCT_FIELDS are still call clobbered if they are\n+\t     for a global variable, so we *don't* clear their call\n+\t     clobberedness just because they are tags, though we will\n+\t     clear it if they aren't for global variables.  */\n \t  if (TREE_CODE (var) == NAME_MEMORY_TAG\n \t      || TREE_CODE (var) == SYMBOL_MEMORY_TAG\n+\t      || TREE_CODE (var) == MEMORY_PARTITION_TAG\n \t      || !is_global_var (var))\n \t    clear_call_clobbered (var);\n \t}\n@@ -1220,8 +1932,10 @@ delete_alias_info (struct alias_info *ai)\n   delete_points_to_sets ();\n }\n \n+\n /* Used for hashing to identify pointer infos with identical\n    pt_vars bitmaps.  */\n+\n static int\n eq_ptr_info (const void *p1, const void *p2)\n {\n@@ -1237,6 +1951,7 @@ ptr_info_hash (const void *p)\n   return bitmap_hash (n->pt_vars);\n }\n \n+\n /* Create name tags for all the pointers that have been dereferenced.\n    We only create a name tag for a pointer P if P is found to point to\n    a set of variables (so that we can alias them to *P) or if it is\n@@ -1288,6 +2003,7 @@ create_name_tags (void)\n     return;\n \n   ptr_hash = htab_create (10, ptr_info_hash, eq_ptr_info, NULL);\n+\n   /* Now go through the pointers with pt_vars, and find a name tag\n      with the same pt_vars as this pointer, or create one if one\n      doesn't exist.  */\n@@ -1308,7 +2024,6 @@ create_name_tags (void)\n \t problems if they both had different name tags because\n \t they would have different SSA version numbers (which\n \t would force us to take the name tags in and out of SSA).  */\n-\n       slot = (struct ptr_info_def **) htab_find_slot (ptr_hash, pi, INSERT);\n       if (*slot)\n         pi->name_mem_tag = (*slot)->name_mem_tag;\n@@ -1334,12 +2049,14 @@ create_name_tags (void)\n       /* Mark the new name tag for renaming.  */\n       mark_sym_for_renaming (pi->name_mem_tag);\n     }\n+\n   htab_delete (ptr_hash);\n \n   VEC_free (tree, heap, with_ptvars);\n }\n \n-/* Union the alias set SET into the may-aliases for TAG */\n+\n+/* Union the alias set SET into the may-aliases for TAG.  */\n \n static void\n union_alias_set_into (tree tag, bitmap set)\n@@ -1784,11 +2501,13 @@ setup_pointers_and_addressables (struct alias_info *ai)\n    to represent all possible global memory referenced by the callee.  */\n \n static void\n-maybe_create_global_var (struct alias_info *ai)\n+maybe_create_global_var (void)\n {\n   /* No need to create it, if we have one already.  */\n   if (gimple_global_var (cfun) == NULL_TREE)\n     {\n+      struct mem_ref_stats_d *stats = gimple_mem_ref_stats (cfun);\n+\n       /* Create .GLOBAL_VAR if there are no call-clobbered\n \t variables and the program contains a mixture of pure/const\n \t and regular function calls.  This is to avoid the problem\n@@ -1813,9 +2532,9 @@ maybe_create_global_var (struct alias_info *ai)\n \t program we create .GLOBAL_VAR to avoid missing these\n \t relations.  */\n       if (bitmap_count_bits (gimple_call_clobbered_vars (cfun)) == 0\n-\t  && ai->num_calls_found > 0\n-\t  && ai->num_pure_const_calls_found > 0\n-\t  && ai->num_calls_found > ai->num_pure_const_calls_found)\n+\t  && stats->num_call_sites > 0\n+\t  && stats->num_pure_const_call_sites > 0\n+\t  && stats->num_call_sites > stats->num_pure_const_call_sites)\n \tcreate_global_var ();\n     }\n }\n@@ -1956,7 +2675,6 @@ may_alias_p (tree ptr, HOST_WIDE_INT mem_alias_set,\n static void\n add_may_alias (tree var, tree alias)\n {\n-\n   /* Don't allow self-referential aliases.  */\n   gcc_assert (var != alias);\n \n@@ -2285,6 +3003,10 @@ dump_alias_info (FILE *file)\n   referenced_var_iterator rvi;\n   tree var;\n \n+  fprintf (file, \"\\nAlias information for %s\\n\\n\", funcname);\n+\n+  dump_memory_partitions (file);\n+\n   fprintf (file, \"\\nFlow-insensitive alias information for %s\\n\\n\", funcname);\n \n   fprintf (file, \"Aliased symbols\\n\\n\");\n@@ -2335,8 +3057,6 @@ dump_alias_info (FILE *file)\n \tdump_variable (file, var);\n     }\n \n-  dump_memory_partitions (file);\n-\n   fprintf (file, \"\\n\");\n }\n \n@@ -2389,7 +3109,9 @@ dump_points_to_info_for (FILE *file, tree ptr)\n \t}\n \n       if (pi->is_dereferenced)\n-\tfprintf (file, \", is dereferenced\");\n+\tfprintf (file, \", is dereferenced (R=%ld, W=%ld)\",\n+\t\t get_mem_sym_stats_for (ptr)->num_direct_reads,\n+\t\t get_mem_sym_stats_for (ptr)->num_direct_writes);\n \n       if (pi->value_escapes_p)\n \tfprintf (file, \", its value escapes\");\n@@ -2466,7 +3188,8 @@ dump_points_to_info (FILE *file)\n \t    tree stmt = bsi_stmt (si);\n \t    tree def;\n \t    FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n-\t      if (POINTER_TYPE_P (TREE_TYPE (def)))\n+\t      if (TREE_CODE (def) == SSA_NAME\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (def)))\n \t\tdump_points_to_info_for (file, def);\n \t  }\n     }"}, {"sha": "0bf85e5616bbf374ea47ea4ddbd9c99ce8de4c72", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -69,17 +69,17 @@ may_propagate_copy (tree dest, tree orig)\n       && TREE_CODE (SSA_NAME_VAR (dest)) == MEMORY_PARTITION_TAG)\n     return (TREE_CODE (orig) == SSA_NAME\n             && !is_gimple_reg (orig)\n-\t    && (bitmap_bit_p (MPT_SYMBOLS (SSA_NAME_VAR (dest)),\n-\t                      DECL_UID (SSA_NAME_VAR (orig)))\n-\t        || SSA_NAME_VAR (dest) == SSA_NAME_VAR (orig)));\n+\t    && (SSA_NAME_VAR (dest) == SSA_NAME_VAR (orig)\n+\t        || bitmap_bit_p (MPT_SYMBOLS (SSA_NAME_VAR (dest)),\n+\t                         DECL_UID (SSA_NAME_VAR (orig)))));\n \n   if (TREE_CODE (orig) == SSA_NAME\n       && TREE_CODE (SSA_NAME_VAR (orig)) == MEMORY_PARTITION_TAG)\n     return (TREE_CODE (dest) == SSA_NAME\n             && !is_gimple_reg (dest)\n-\t    && (bitmap_bit_p (MPT_SYMBOLS (SSA_NAME_VAR (orig)),\n-\t                      DECL_UID (SSA_NAME_VAR (dest)))\n-\t        || SSA_NAME_VAR (dest) == SSA_NAME_VAR (orig)));\n+\t    && (SSA_NAME_VAR (dest) == SSA_NAME_VAR (orig)\n+                || bitmap_bit_p (MPT_SYMBOLS (SSA_NAME_VAR (orig)),\n+\t                         DECL_UID (SSA_NAME_VAR (dest)))));\n   \n   /* Do not copy between types for which we *do* need a conversion.  */\n   if (!tree_ssa_useless_type_conversion_1 (type_d, type_o))"}, {"sha": "28464f939fc8c2b54d8cb848e38b825d5e7f87e6", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -2980,89 +2980,3 @@ stmt_references_memory_p (tree stmt)\n \n   return stmt_ann (stmt)->references_memory;\n }\n-\n-\n-/* Return the memory partition tag (MPT) associated with memory\n-   symbol SYM.  From a correctness standpoint, memory partitions can\n-   be assigned in any arbitrary fashion as long as this rule is\n-   observed: Given two memory partitions MPT.i and MPT.j, they must\n-   not contain symbols in common.\n-\n-   Memory partitions are used when putting the program into Memory-SSA\n-   form.  In particular, in Memory-SSA PHI nodes are not computed for\n-   individual memory symbols.  They are computed for memory\n-   partitions.  This reduces the amount of PHI nodes in the SSA graph\n-   at the expense of precision (i.e., it makes unrelated stores affect\n-   each other).\n-   \n-   However, it is possible to increase precision by changing this\n-   partitioning scheme.  For instance, if the partitioning scheme is\n-   such that get_mpt_for is the identity function (that is,\n-   get_mpt_for (s) = s), this will result in ultimate precision at the\n-   expense of huge SSA webs.\n-\n-   At the other extreme, a partitioning scheme that groups all the\n-   symbols in the same set results in minimal SSA webs and almost\n-   total loss of precision.  */\n-\n-tree\n-get_mpt_for (tree sym)\n-{\n-  tree mpt;\n-\n-  /* Don't create a new tag unnecessarily.  */\n-  mpt = memory_partition (sym);\n-  if (mpt == NULL_TREE)\n-    {\n-      mpt = create_tag_raw (MEMORY_PARTITION_TAG, TREE_TYPE (sym), \"MPT\");\n-      TREE_ADDRESSABLE (mpt) = 0;\n-      MTAG_GLOBAL (mpt) = 1;\n-      add_referenced_var (mpt);\n-      VEC_safe_push (tree, heap, gimple_ssa_operands (cfun)->mpt_table, mpt);\n-      MPT_SYMBOLS (mpt) = BITMAP_ALLOC (&operands_bitmap_obstack);\n-      set_memory_partition (sym, mpt);\n-    }\n-\n-  return mpt;\n-}\n-\n-\n-/* Dump memory partition information to FILE.  */\n-\n-void\n-dump_memory_partitions (FILE *file)\n-{\n-  unsigned i, npart;\n-  unsigned long nsyms;\n-  tree mpt;\n-\n-  fprintf (file, \"\\nMemory partitions\\n\\n\");\n-  for (i = 0, npart = 0, nsyms = 0;\n-      VEC_iterate (tree, gimple_ssa_operands (cfun)->mpt_table, i, mpt);\n-      i++)\n-    {\n-      if (mpt)\n-\t{\n-\t  bitmap syms = MPT_SYMBOLS (mpt);\n-\t  unsigned long n = bitmap_count_bits (syms);\n-\n-\t  fprintf (file, \"#%u: \", i);\n-\t  print_generic_expr (file, mpt, 0);\n-\t  fprintf (file, \": %lu elements: \", n);\n-\t  dump_decl_set (file, syms);\n-\t  npart++;\n-\t  nsyms += n;\n-\t}\n-    }\n-\n-  fprintf (file, \"\\n%u memory partitions holding %lu symbols\\n\", npart, nsyms);\n-}\n-\n-\n-/* Dump memory partition information to stderr.  */\n-\n-void\n-debug_memory_partitions (void)\n-{\n-  dump_memory_partitions (stderr);\n-}"}, {"sha": "09b3b7bfabcf99f88bcc7bc1555b1c341566a78a", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -357,8 +357,4 @@ typedef struct ssa_operand_iterator_d\n /* This macro counts the number of operands in STMT matching FLAGS.  */\n #define NUM_SSA_OPERANDS(STMT, FLAGS)\tnum_ssa_operands (STMT, FLAGS)\n \n-extern tree get_mpt_for (tree);\n-extern void dump_memory_partitions (FILE *);\n-extern void debug_memory_partitions (void);\n-\n #endif  /* GCC_TREE_SSA_OPERANDS_H  */"}, {"sha": "865770ad8a844cbdadaac163126804450d450878", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 90, "deletions": 27, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -3011,15 +3011,21 @@ update_alias_info (tree stmt, struct alias_info *ai)\n   bitmap addr_taken;\n   use_operand_p use_p;\n   ssa_op_iter iter;\n+  bool stmt_dereferences_ptr_p;\n   enum escape_type stmt_escape_type = is_escape_site (stmt);\n+  struct mem_ref_stats_d *mem_ref_stats = gimple_mem_ref_stats (cfun);\n+\n+  stmt_dereferences_ptr_p = false;\n \n   if (stmt_escape_type == ESCAPE_TO_CALL\n       || stmt_escape_type == ESCAPE_TO_PURE_CONST)\n     {\n-      ai->num_calls_found++;\n+      mem_ref_stats->num_call_sites++;\n       if (stmt_escape_type == ESCAPE_TO_PURE_CONST)\n-\tai->num_pure_const_calls_found++;\n+\tmem_ref_stats->num_pure_const_call_sites++;\n     }\n+  else if (stmt_escape_type == ESCAPE_TO_ASM)\n+    mem_ref_stats->num_asm_sites++;\n \n   /* Mark all the variables whose address are taken by the statement.  */\n   addr_taken = addresses_taken (stmt);\n@@ -3043,17 +3049,15 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t}\n     }\n \n-  /* Process each operand use.  If an operand may be aliased, keep\n-     track of how many times it's being used.  For pointers, determine\n-     whether they are dereferenced by the statement, or whether their\n-     value escapes, etc.  */\n+  /* Process each operand use.  For pointers, determine whether they\n+     are dereferenced by the statement, or whether their value\n+     escapes, etc.  */\n   FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n     {\n       tree op, var;\n       var_ann_t v_ann;\n       struct ptr_info_def *pi;\n-      bool is_store, is_potential_deref;\n-      unsigned num_uses, num_derefs;\n+      unsigned num_uses, num_loads, num_stores;\n \n       op = USE_FROM_PTR (use_p);\n \n@@ -3073,12 +3077,11 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t     so that they can be treated like regular statements?\n \t     Currently, they are treated as second-class\n \t     statements.  */\n-\t  add_to_addressable_set (TREE_OPERAND (op, 0),\n-\t\t\t\t  &addressable_vars);\n+\t  add_to_addressable_set (TREE_OPERAND (op, 0), &addressable_vars);\n \t  continue;\n \t}\n \n-      /* Ignore constants.  */\n+      /* Ignore constants (they may occur in PHI node arguments).  */\n       if (TREE_CODE (op) != SSA_NAME)\n \tcontinue;\n \n@@ -3109,7 +3112,7 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \n       /* Determine whether OP is a dereferenced pointer, and if STMT\n \t is an escape point, whether OP escapes.  */\n-      count_uses_and_derefs (op, stmt, &num_uses, &num_derefs, &is_store);\n+      count_uses_and_derefs (op, stmt, &num_uses, &num_loads, &num_stores);\n \n       /* Handle a corner case involving address expressions of the\n \t form '&PTR->FLD'.  The problem with these expressions is that\n@@ -3132,7 +3135,6 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t are not GIMPLE invariants), they can only appear on the RHS\n \t of an assignment and their base address is always an\n \t INDIRECT_REF expression.  */\n-      is_potential_deref = false;\n       if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n \t  && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == ADDR_EXPR\n \t  && !is_gimple_val (GIMPLE_STMT_OPERAND (stmt, 1)))\n@@ -3143,10 +3145,10 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t  tree base = get_base_address (TREE_OPERAND (rhs, 0));\n \t  if (TREE_CODE (base) == INDIRECT_REF\n \t      && TREE_OPERAND (base, 0) == op)\n-\t    is_potential_deref = true;\n+\t    num_loads++;\n \t}\n \n-      if (num_derefs > 0 || is_potential_deref)\n+      if (num_loads + num_stores > 0)\n \t{\n \t  /* Mark OP as dereferenced.  In a subsequent pass,\n \t     dereferenced pointers that point to a set of\n@@ -3157,13 +3159,20 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t  /* If this is a store operation, mark OP as being\n \t     dereferenced to store, otherwise mark it as being\n \t     dereferenced to load.  */\n-\t  if (is_store)\n+\t  if (num_stores > 0)\n \t    pointer_set_insert (ai->dereferenced_ptrs_store, var);\n \t  else\n \t    pointer_set_insert (ai->dereferenced_ptrs_load, var);\n+\n+\t  /* Update the frequency estimate for all the dereferences of\n+\t     pointer OP.  */\n+\t  update_mem_sym_stats_from_stmt (op, stmt, num_loads, num_stores);\n+\t  \n+\t  /* Indicate that STMT contains pointer dereferences.  */\n+\t  stmt_dereferences_ptr_p = true;\n \t}\n \n-      if (stmt_escape_type != NO_ESCAPE && num_derefs < num_uses)\n+      if (stmt_escape_type != NO_ESCAPE && num_loads + num_stores < num_uses)\n \t{\n \t  /* If STMT is an escape point and STMT contains at\n \t     least one direct use of OP, then the value of OP\n@@ -3188,13 +3197,55 @@ update_alias_info (tree stmt, struct alias_info *ai)\n     return;\n \n   /* Mark stored variables in STMT as being written to and update the\n-     reference counter for potentially aliased symbols in STMT.  */\n-  if (stmt_references_memory_p (stmt) && STORED_SYMS (stmt))\n+     memory reference stats for all memory symbols referenced by STMT.  */\n+  if (stmt_references_memory_p (stmt))\n     {\n       unsigned i;\n       bitmap_iterator bi;\n-      EXECUTE_IF_SET_IN_BITMAP (STORED_SYMS (stmt), 0, i, bi)\n-\tpointer_set_insert (ai->written_vars, referenced_var (i));\n+\n+      mem_ref_stats->num_mem_stmts++;\n+\n+      /* Notice that we only update memory reference stats for symbols\n+\t loaded and stored by the statement if the statement does not\n+\t contain pointer dereferences and it is not a call/asm site.\n+\t This is to avoid double accounting problems when creating\n+\t memory partitions.  After computing points-to information,\n+\t pointer dereference statistics are used to update the\n+\t reference stats of the pointed-to variables, so here we\n+\t should only update direct references to symbols.\n+\n+\t Indirect references are not updated here for two reasons: (1)\n+\t The first time we compute alias information, the sets\n+\t LOADED/STORED are empty for pointer dereferences, (2) After\n+\t partitioning, LOADED/STORED may have references to\n+\t partitions, not the original pointed-to variables.  So, if we\n+\t always counted LOADED/STORED here and during partitioning, we\n+\t would count many symbols more than once.\n+\n+\t This does cause some imprecision when a statement has a\n+\t combination of direct symbol references and pointer\n+\t dereferences (e.g., MEMORY_VAR = *PTR) or if a call site has\n+\t memory symbols in its argument list, but these cases do not\n+\t occur so frequently as to constitue a serious problem.  */\n+      if (STORED_SYMS (stmt))\n+\tEXECUTE_IF_SET_IN_BITMAP (STORED_SYMS (stmt), 0, i, bi)\n+\t  {\n+\t    tree sym = referenced_var (i);\n+\t    pointer_set_insert (ai->written_vars, sym);\n+\t    if (!stmt_dereferences_ptr_p\n+\t\t&& stmt_escape_type != ESCAPE_TO_CALL\n+\t\t&& stmt_escape_type != ESCAPE_TO_PURE_CONST\n+\t\t&& stmt_escape_type != ESCAPE_TO_ASM)\n+\t      update_mem_sym_stats_from_stmt (sym, stmt, 0, 1);\n+\t  }\n+\n+      if (!stmt_dereferences_ptr_p\n+\t  && LOADED_SYMS (stmt)\n+\t  && stmt_escape_type != ESCAPE_TO_CALL\n+\t  && stmt_escape_type != ESCAPE_TO_PURE_CONST\n+\t  && stmt_escape_type != ESCAPE_TO_ASM)\n+\tEXECUTE_IF_SET_IN_BITMAP (LOADED_SYMS (stmt), 0, i, bi)\n+\t  update_mem_sym_stats_from_stmt (referenced_var (i), stmt, 1, 0);\n     }\n }\n \n@@ -4108,11 +4159,11 @@ intra_create_variable_infos (void)\n       if (!could_have_pointers (t))\n \tcontinue;\n \n-      /* With flag_argument_noalias greater than two means that the incoming\n-\t argument cannot alias anything except for itself so create a HEAP\n-\t variable.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (t))\n-\t  && flag_argument_noalias > 2)\n+      /* If flag_argument_noalias is set, then function pointer\n+\t arguments are guaranteed not to point to each other.  In that\n+\t case, create an artificial variable PARM_NOALIAS and the\n+\t constraint ARG = &PARM_NOALIAS.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (t)) && flag_argument_noalias > 0)\n \t{\n \t  varinfo_t vi;\n \t  tree heapvar = heapvar_lookup (t);\n@@ -4123,14 +4174,26 @@ intra_create_variable_infos (void)\n \n \t  if (heapvar == NULL_TREE)\n \t    {\n+\t      var_ann_t ann;\n \t      heapvar = create_tmp_var_raw (TREE_TYPE (TREE_TYPE (t)),\n \t\t\t\t\t    \"PARM_NOALIAS\");\n-\t      get_var_ann (heapvar)->is_heapvar = 1;\n \t      DECL_EXTERNAL (heapvar) = 1;\n \t      if (gimple_referenced_vars (cfun))\n \t\tadd_referenced_var (heapvar);\n+\n \t      heapvar_insert (t, heapvar);\n+\n+\t      ann = get_var_ann (heapvar);\n+\t      if (flag_argument_noalias == 1)\n+\t\tann->noalias_state = NO_ALIAS;\n+\t      else if (flag_argument_noalias == 2)\n+\t\tann->noalias_state = NO_ALIAS_GLOBAL;\n+\t      else if (flag_argument_noalias == 3)\n+\t\tann->noalias_state = NO_ALIAS_ANYTHING;\n+\t      else\n+\t\tgcc_unreachable ();\n \t    }\n+\n \t  vi = get_vi_for_tree (heapvar);\n \t  vi->is_artificial_var = 1;\n \t  vi->is_heap_var = 1;"}, {"sha": "0f09be2cd812f8fc2c9c7cb29d8eadc0b284807a", "filename": "gcc/tree-ssa-structalias.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-structalias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa-structalias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.h?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -49,12 +49,6 @@ struct alias_info\n   struct alias_map_d **pointers;\n   size_t num_pointers;\n \n-  /* Number of function calls found in the program.  */\n-  size_t num_calls_found;\n-\n-  /* Number of const/pure function calls found in the program.  */\n-  size_t num_pure_const_calls_found;\n-\n   /* Variables that have been written to directly (i.e., not through a\n      pointer dereference).  */\n   struct pointer_set_t *written_vars;\n@@ -71,6 +65,7 @@ struct alias_info\n \n /* In tree-ssa-alias.c.  */\n enum escape_type is_escape_site (tree);\n+void update_mem_sym_stats_from_stmt (tree, tree, long, long);\n \n /* In tree-ssa-structalias.c.  */\n extern void compute_points_to_sets (struct alias_info *);"}, {"sha": "1eb407d52b5f0f3a3eb9de456caef4f702cd9a9e", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -538,6 +538,51 @@ verify_call_clobbering (void)\n     internal_error (\"verify_call_clobbering failed\");\n }\n \n+\n+/* Verify invariants in memory partitions.  */\n+\n+static void\n+verify_memory_partitions (void)\n+{\n+  unsigned i;\n+  tree mpt;\n+  VEC(tree,heap) *mpt_table = gimple_ssa_operands (cfun)->mpt_table;\n+  struct pointer_set_t *partitioned_syms = pointer_set_create ();\n+\n+  for (i = 0; VEC_iterate (tree, mpt_table, i, mpt); i++)\n+    {\n+      unsigned j;\n+      bitmap_iterator bj;\n+\n+      if (MPT_SYMBOLS (mpt) == NULL)\n+\t{\n+\t  error (\"Memory partitions should have at least one symbol\");\n+\t  debug_variable (mpt);\n+\t  goto err;\n+\t}\n+\n+      EXECUTE_IF_SET_IN_BITMAP (MPT_SYMBOLS (mpt), 0, j, bj)\n+\t{\n+\t  tree var = referenced_var (j);\n+\t  if (pointer_set_insert (partitioned_syms, var))\n+\t    {\n+\t      error (\"Partitioned symbols should belong to exactly one \"\n+\t\t     \"partition\");\n+\t      debug_variable (var);\n+\t      goto err;\n+\t    }\n+\t}\n+    }\n+\n+  pointer_set_destroy (partitioned_syms);\n+\n+  return;\n+\n+err:\n+  internal_error (\"verify_memory_partitions failed\");\n+}\n+\n+\n /* Verify the consistency of aliasing information.  */\n \n static void\n@@ -546,6 +591,7 @@ verify_alias_info (void)\n   verify_flow_sensitive_alias_info ();\n   verify_call_clobbering ();\n   verify_flow_insensitive_alias_info ();\n+  verify_memory_partitions ();\n }\n \n \n@@ -835,6 +881,7 @@ delete_tree_ssa (void)\n       gcc_assert (!need_ssa_update_p ());\n     }\n   cfun->gimple_df->aliases_computed_p = false;\n+  delete_mem_ref_stats (cfun);\n \n   cfun->gimple_df = NULL;\n }"}, {"sha": "102d2be1a9db256ab6723246944346019ad90a0d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e0aa2c9677074a7912521f4fa1aebf53640198/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=e9e0aa2c9677074a7912521f4fa1aebf53640198", "patch": "@@ -3121,11 +3121,10 @@ infer_value_range (tree stmt, tree op, enum tree_code *comp_code_p, tree *val_p)\n      non-NULL if -fdelete-null-pointer-checks is enabled.  */\n   if (flag_delete_null_pointer_checks && POINTER_TYPE_P (TREE_TYPE (op)))\n     {\n-      bool is_store;\n-      unsigned num_uses, num_derefs;\n+      unsigned num_uses, num_loads, num_stores;\n \n-      count_uses_and_derefs (op, stmt, &num_uses, &num_derefs, &is_store);\n-      if (num_derefs > 0)\n+      count_uses_and_derefs (op, stmt, &num_uses, &num_loads, &num_stores);\n+      if (num_loads + num_stores > 0)\n \t{\n \t  *val_p = build_int_cst (TREE_TYPE (op), 0);\n \t  *comp_code_p = NE_EXPR;"}]}