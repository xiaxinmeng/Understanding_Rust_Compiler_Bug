{"sha": "ff852b44545f35144c7f30d9f1216df05cb39b55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY4NTJiNDQ1NDVmMzUxNDRjN2YzMGQ5ZjEyMTZkZjA1Y2IzOWI1NQ==", "commit": {"author": {"name": "Craig Burley", "email": "craig@jcb-sc.com", "date": "1999-05-15T15:46:16Z"}, "committer": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-05-15T15:46:16Z"}, "message": "fix INTEGER*8 subscripts, add -fflatten-arrays\n\nFrom-SVN: r26948", "tree": {"sha": "e34430028463cc12d8cccfae35f3b14838e3bfdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e34430028463cc12d8cccfae35f3b14838e3bfdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff852b44545f35144c7f30d9f1216df05cb39b55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff852b44545f35144c7f30d9f1216df05cb39b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff852b44545f35144c7f30d9f1216df05cb39b55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff852b44545f35144c7f30d9f1216df05cb39b55/comments", "author": null, "committer": null, "parents": [{"sha": "1907bb7c749b14c8e7636a36615e69b14e66a8b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1907bb7c749b14c8e7636a36615e69b14e66a8b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1907bb7c749b14c8e7636a36615e69b14e66a8b6"}], "stats": {"total": 317, "additions": 248, "deletions": 69}, "files": [{"sha": "21c9a3608660ec5886f14039ae4d886756ef3a5b", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=ff852b44545f35144c7f30d9f1216df05cb39b55", "patch": "@@ -1,3 +1,31 @@\n+Thu May 13 12:23:20 1999  Craig Burley  <craig@jcb-sc.com>\n+\n+\tFix INTEGER*8 subscripts in array references:\n+\t* com.c (ffecom_subscript_check_): Convert low, high, and\n+\telement as necessary to make comparison work.\n+\t(ffecom_arrayref_): Do more of the work.\n+\tProperly handle subscript expr that's wider than int,\n+\tif pointers are wider than int.\n+\t(ffecom_expr_): Leave more work to ffecom_arrayref_.\n+\t(ffecom_init_0): Record sizes of pointers and ints for\n+\tconvenience.\n+\tUse set_sizetype etc. as done by gcc front end.\n+\t(ffecom_ptr_to_expr): Leave more work to ffecom_arrayref_.\n+\t* expr.c (ffeexpr_finished_): Don't convert INTEGER subscript\n+\texpressions in run-time contexts.\n+\t(ffeexpr_token_elements_, ffeexpr_token_substring_1_): Cope with\n+\tnon-default INTEGER subscript expressions.\n+\t* news.texi: Announce.\n+\n+\tFinish accepting -fflatten-arrays option:\n+\t* com.c (ffecom_arrayref_): Flatten references if requested.\n+\t* g77.texi: Describe.\n+\t* lang-options.h: Allow.\n+\t* news.texi: Announce.\n+\t* top.c, top.h: Recognize.\n+\n+\t* version.c: Bump version.\n+\n Wed May 12 07:30:05 1999  Craig Burley  <craig@jcb-sc.com>\n \n \t* com.c (lang_init_options): Disable back end's maintenance"}, {"sha": "a3e0eb1b3a0c966b58dc0314a07c9ff3c78a7cde", "filename": "gcc/f/com.c", "status": "modified", "additions": 119, "deletions": 59, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=ff852b44545f35144c7f30d9f1216df05cb39b55", "patch": "@@ -556,6 +556,8 @@ static tree\n static bool ffecom_member_namelisted_;\t/* _member_phase1_ namelisted? */\n static bool ffecom_doing_entry_ = FALSE;\n static bool ffecom_transform_only_dummies_ = FALSE;\n+static int ffecom_typesize_pointer_;\n+static int ffecom_typesize_integer1_;\n \n /* Holds pointer-to-function expressions.  */\n \n@@ -628,8 +630,9 @@ static const char *ffecom_gfrt_argstring_[FFECOM_gfrt]\n    it would be best to do something here to figure out automatically\n    from other information what type to use.  */\n \n-/* NOTE: g77 currently doesn't use these; see setting of sizetype and\n-   change that if you need to.\t-- jcb 09/01/91. */\n+#ifndef SIZE_TYPE\n+#define SIZE_TYPE \"long unsigned int\"\n+#endif\n \n #define ffecom_concat_list_count_(catlist) ((catlist).count)\n #define ffecom_concat_list_expr_(catlist,i) ((catlist).exprs[(i)])\n@@ -766,6 +769,19 @@ ffecom_subscript_check_ (tree array, tree element, int dim, int total_dims,\n   if (element == error_mark_node)\n     return element;\n \n+  if (TREE_TYPE (low) != TREE_TYPE (element))\n+    {\n+      if (TYPE_PRECISION (TREE_TYPE (low))\n+\t  > TYPE_PRECISION (TREE_TYPE (element)))\n+\telement = convert (TREE_TYPE (low), element);\n+      else\n+\t{\n+\t  low = convert (TREE_TYPE (element), low);\n+\t  if (high)\n+\t    high = convert (TREE_TYPE (element), high);\n+\t}\n+    }\n+\n   element = ffecom_save_tree (element);\n   cond = ffecom_2 (LE_EXPR, integer_type_node,\n \t\t   low,\n@@ -889,10 +905,10 @@ ffecom_subscript_check_ (tree array, tree element, int dim, int total_dims,\n \n /* Return the computed element of an array reference.\n \n-   `item' is the array or a pointer to the array.  It must be a pointer\n-     to the array if ffe_is_flat_arrays ().\n-   `expr' is the original opARRAYREF expression.\n-   `want_ptr' is non-zero if `item' is a pointer to the element, instead of\n+   `item' is NULL_TREE, or the transformed pointer to the array.\n+   `expr' is the original opARRAYREF expression, which is transformed\n+     if `item' is NULL_TREE.\n+   `want_ptr' is non-zero if a pointer to the element, instead of\n      the element itself, is to be returned.  */\n \n static tree\n@@ -901,11 +917,15 @@ ffecom_arrayref_ (tree item, ffebld expr, int want_ptr)\n   ffebld dims[FFECOM_dimensionsMAX];\n   int i;\n   int total_dims;\n-  int flatten = 0 /* ~~~ ffe_is_flat_arrays () */;\n-  int need_ptr = want_ptr || flatten;\n+  int flatten = ffe_is_flatten_arrays ();\n+  int need_ptr;\n   tree array;\n   tree element;\n+  tree tree_type;\n+  tree tree_type_x;\n   char *array_name;\n+  ffetype type;\n+  ffebld list;\n \n   if (ffebld_op (ffebld_left (expr)) == FFEBLD_opSYMTER)\n     array_name = ffesymbol_text (ffebld_symter (ffebld_left (expr)));\n@@ -915,33 +935,84 @@ ffecom_arrayref_ (tree item, ffebld expr, int want_ptr)\n   /* Build up ARRAY_REFs in reverse order (since we're column major\n      here in Fortran land). */\n \n-  for (i = 0, expr = ffebld_right (expr);\n-       expr != NULL;\n-       expr = ffebld_trail (expr))\n-    dims[i++] = ffebld_head (expr);\n+  for (i = 0, list = ffebld_right (expr);\n+       list != NULL;\n+       ++i, list = ffebld_trail (list))\n+    {\n+      dims[i] = ffebld_head (list);\n+      type = ffeinfo_type (ffebld_basictype (dims[i]),\n+\t\t\t   ffebld_kindtype (dims[i]));\n+      if (! flatten\n+\t  && ffecom_typesize_pointer_ > ffecom_typesize_integer1_\n+\t  && ffetype_size (type) > ffecom_typesize_integer1_)\n+\t/* E.g. ARRAY(INDEX), given INTEGER*8 INDEX, on a system with 64-bit\n+\t   pointers and 32-bit integers.  Do the full 64-bit pointer\n+\t   arithmetic, for codes using arrays for nonstandard heap-like\n+\t   work.  */\n+\tflatten = 1;\n+    }\n \n   total_dims = i;\n \n+  need_ptr = want_ptr || flatten;\n+\n+  if (! item)\n+    {\n+      if (need_ptr)\n+\titem = ffecom_ptr_to_expr (ffebld_left (expr));\n+      else\n+\titem = ffecom_expr (ffebld_left (expr));\n+\n+      if (item == error_mark_node)\n+\treturn item;\n+\n+      if (ffeinfo_where (ffebld_info (expr)) == FFEINFO_whereFLEETING\n+\t  && ! mark_addressable (item))\n+\treturn error_mark_node;\n+    }\n+\n+  if (item == error_mark_node)\n+    return item;\n+\n   if (need_ptr)\n     {\n+      tree min;\n+\n       for (--i, array = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (item)));\n \t   i >= 0;\n \t   --i, array = TYPE_MAIN_VARIANT (TREE_TYPE (array)))\n \t{\n-\t  element = ffecom_expr (dims[i]);\n+\t  min = TYPE_MIN_VALUE (TYPE_DOMAIN (array));\n+\t  element = ffecom_expr_ (dims[i], NULL, NULL, NULL, FALSE, TRUE);\n \t  if (ffe_is_subscript_check ())\n \t    element = ffecom_subscript_check_ (array, element, i, total_dims,\n \t\t\t\t\t       array_name);\n+\t  if (element == error_mark_node)\n+\t    return element;\n+\n+\t  /* Widen integral arithmetic as desired while preserving\n+\t     signedness.  */\n+\t  tree_type = TREE_TYPE (element);\n+\t  tree_type_x = tree_type;\n+\t  if (tree_type\n+\t      && GET_MODE_CLASS (TYPE_MODE (tree_type)) == MODE_INT\n+\t      && TYPE_PRECISION (tree_type) < TYPE_PRECISION (sizetype))\n+\t    tree_type_x = (TREE_UNSIGNED (tree_type) ? usizetype : ssizetype);\n+\n+\t  if (TREE_TYPE (min) != tree_type_x)\n+\t    min = convert (tree_type_x, min);\n+\t  if (TREE_TYPE (element) != tree_type_x)\n+\t    element = convert (tree_type_x, element);\n+\n \t  item = ffecom_2 (PLUS_EXPR,\n \t\t\t   build_pointer_type (TREE_TYPE (array)),\n \t\t\t   item,\n \t\t\t   size_binop (MULT_EXPR,\n \t\t\t\t       size_in_bytes (TREE_TYPE (array)),\n-\t\t\t\t       convert (sizetype,\n-\t\t\t\t\t\tfold (build (MINUS_EXPR,\n-\t\t\t\t\t\t\t     TREE_TYPE (TYPE_MIN_VALUE (TYPE_DOMAIN (array))),\n-\t\t\t\t\t\t\t     element,\n-\t\t\t\t\t\t\t     TYPE_MIN_VALUE (TYPE_DOMAIN (array)))))));\n+\t\t\t\t       fold (build (MINUS_EXPR,\n+\t\t\t\t\t\t    tree_type_x,\n+\t\t\t\t\t\t    element,\n+\t\t\t\t\t\t    min))));\n \t}\n       if (! want_ptr)\n \t{\n@@ -962,6 +1033,20 @@ ffecom_arrayref_ (tree item, ffebld expr, int want_ptr)\n \t  if (ffe_is_subscript_check ())\n \t    element = ffecom_subscript_check_ (array, element, i, total_dims,\n \t\t\t\t\t       array_name);\n+\t  if (element == error_mark_node)\n+\t    return element;\n+\n+\t  /* Widen integral arithmetic as desired while preserving\n+\t     signedness.  */\n+\t  tree_type = TREE_TYPE (element);\n+\t  tree_type_x = tree_type;\n+\t  if (tree_type\n+\t      && GET_MODE_CLASS (TYPE_MODE (tree_type)) == MODE_INT\n+\t      && TYPE_PRECISION (tree_type) < TYPE_PRECISION (sizetype))\n+\t    tree_type_x = (TREE_UNSIGNED (tree_type) ? usizetype : ssizetype);\n+\n+\t  element = convert (tree_type_x, element);\n+\n \t  item = ffecom_2 (ARRAY_REF,\n \t\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (item))),\n \t\t\t   item,\n@@ -2064,6 +2149,8 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n \n \tarray = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (item)));\n \n+\t/* ~~~~Handle INTEGER*8 start/end, a la FFEBLD_opARRAYREF.  */\n+\n \tif (start == NULL)\n \t  {\n \t    if (end == NULL)\n@@ -3245,24 +3332,7 @@ ffecom_expr_ (ffebld expr, tree dest_tree, ffebld dest,\n       return t;\n \n     case FFEBLD_opARRAYREF:\n-      {\n-\tif (0 /* ~~~~~ ffe_is_flat_arrays () */)\n-\t  t = ffecom_ptr_to_expr (ffebld_left (expr));\n-\telse\n-\t  t = ffecom_expr (ffebld_left (expr));\n-\n-\tif (t == error_mark_node)\n-\t  return t;\n-\n-\tif ((ffeinfo_where (ffebld_info (expr)) == FFEINFO_whereFLEETING)\n-\t    && !mark_addressable (t))\n-\t  return error_mark_node;\t/* Make sure non-const ref is to\n-\t\t\t\t\t   non-reg. */\n-\n-\tt = ffecom_arrayref_ (t, expr, 0);\n-\n-\treturn t;\n-      }\n+      return ffecom_arrayref_ (NULL_TREE, expr, 0);\n \n     case FFEBLD_opUPLUS:\n       left = ffecom_expr_ (ffebld_left (expr), NULL, NULL, NULL, FALSE, widenp);\n@@ -11608,12 +11678,6 @@ ffecom_init_0 ()\n \t}\n     }\n \n-  /* Set the sizetype before we do anything else.  This _should_ be the\n-     first type we create.  */\n-\n-  t = make_unsigned_type (POINTER_SIZE);\n-  assert (t == sizetype);\n-\n #if FFECOM_GCC_INCLUDE\n   ffecom_initialize_char_syntax_ ();\n #endif\n@@ -11658,9 +11722,6 @@ ffecom_init_0 ()\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"long long unsigned int\"),\n \t\t\tlong_long_unsigned_type_node));\n \n-  error_mark_node = make_node (ERROR_MARK);\n-  TREE_TYPE (error_mark_node) = error_mark_node;\n-\n   short_integer_type_node = make_signed_type (SHORT_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"short int\"),\n \t\t\tshort_integer_type_node));\n@@ -11669,6 +11730,17 @@ ffecom_init_0 ()\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"short unsigned int\"),\n \t\t\tshort_unsigned_type_node));\n \n+  /* Set the sizetype before we make other types.  This *should* be the\n+     first type we create.  */\n+\n+  set_sizetype\n+    (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE))));\n+  ffecom_typesize_pointer_\n+    = TREE_INT_CST_LOW (TYPE_SIZE (sizetype)) / BITS_PER_UNIT;\n+\n+  error_mark_node = make_node (ERROR_MARK);\n+  TREE_TYPE (error_mark_node) = error_mark_node;\n+\n   /* Define both `signed char' and `unsigned char'.  */\n   signed_char_type_node = make_signed_type (CHAR_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"signed char\"),\n@@ -11787,6 +11859,7 @@ ffecom_init_0 ()\n \t\t    TREE_INT_CST_LOW (TYPE_SIZE (t)) / CHAR_TYPE_SIZE,\n \t\t    type);\n   ffetype_set_kind (base_type, 1, type);\n+  ffecom_typesize_integer1_ = ffetype_size (type);\n   assert (ffetype_size (type) == sizeof (ffetargetInteger1));\n \n   ffecom_tree_type[FFEINFO_basictypeHOLLERITH][FFEINFO_kindtypeINTEGER1]\n@@ -12798,20 +12871,7 @@ ffecom_ptr_to_expr (ffebld expr)\n       return item;\n \n     case FFEBLD_opARRAYREF:\n-      {\n-\titem = ffecom_ptr_to_expr (ffebld_left (expr));\n-\n-\tif (item == error_mark_node)\n-\t  return item;\n-\n-\tif ((ffebld_where (expr) == FFEINFO_whereFLEETING)\n-\t    && !mark_addressable (item))\n-\t  return error_mark_node;\t/* Make sure non-const ref is to\n-\t\t\t\t\t   non-reg. */\n-\n-\titem = ffecom_arrayref_ (item, expr, 1);\n-      }\n-      return item;\n+      return ffecom_arrayref_ (NULL_TREE, expr, 1);\n \n     case FFEBLD_opCONTER:\n "}, {"sha": "67b3765bd2a01ea3fe6cd826fe94e2d7d52ac571", "filename": "gcc/f/expr.c", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fexpr.c?ref=ff852b44545f35144c7f30d9f1216df05cb39b55", "patch": "@@ -12267,7 +12267,6 @@ ffeexpr_finished_ (ffelexToken t)\n \n     case FFEEXPR_contextINDEX_:\n     case FFEEXPR_contextSFUNCDEFINDEX_:\n-    case FFEEXPR_contextRETURN:\n       if ((error = (expr != NULL) && (ffeinfo_rank (info) != 0)))\n \tbreak;\n       switch ((expr == NULL) ? FFEINFO_basictypeNONE\n@@ -12290,7 +12289,6 @@ ffeexpr_finished_ (ffelexToken t)\n \t      break;\n \t    }\n \t  /* Fall through. */\n-\tcase FFEINFO_basictypeINTEGER:\n \tcase FFEINFO_basictypeHOLLERITH:\n \tcase FFEINFO_basictypeTYPELESS:\n \t  error = FALSE;\n@@ -12299,13 +12297,56 @@ ffeexpr_finished_ (ffelexToken t)\n \t\t\t\t  FFEEXPR_contextLET);\n \t  break;\n \n+\tcase FFEINFO_basictypeINTEGER:\n+\t  /* Specifically, allow INTEGER(KIND=2), aka INTEGER*8, through\n+\t     unmolested.  Leave it to downstream to handle kinds.  */\n+\t  break;\n+\n \tdefault:\n \t  error = TRUE;\n \t  break;\n \t}\n       break;\t\t\t/* expr==NULL ok for substring; element case\n \t\t\t\t   caught by callback. */\n \n+    case FFEEXPR_contextRETURN:\n+      if ((error = (expr != NULL) && (ffeinfo_rank (info) != 0)))\n+\tbreak;\n+      switch ((expr == NULL) ? FFEINFO_basictypeNONE\n+\t      : ffeinfo_basictype (info))\n+\t{\n+\tcase FFEINFO_basictypeNONE:\n+\t  error = FALSE;\n+\t  break;\n+\n+\tcase FFEINFO_basictypeLOGICAL:\n+\t  expr = ffeexpr_convert (expr, ft, ft, FFEINFO_basictypeLOGICAL,\n+\t     FFEINFO_kindtypeLOGICALDEFAULT, 0, FFETARGET_charactersizeNONE,\n+\t\t\t\t  FFEEXPR_contextLET);\n+\t  /* Fall through. */\n+\tcase FFEINFO_basictypeREAL:\n+\tcase FFEINFO_basictypeCOMPLEX:\n+\t  if (ffe_is_pedantic ())\n+\t    {\n+\t      error = TRUE;\n+\t      break;\n+\t    }\n+\t  /* Fall through. */\n+\tcase FFEINFO_basictypeINTEGER:\n+\tcase FFEINFO_basictypeHOLLERITH:\n+\tcase FFEINFO_basictypeTYPELESS:\n+\t  error = FALSE;\n+\t  expr = ffeexpr_convert (expr, ft, ft, FFEINFO_basictypeINTEGER,\n+\t     FFEINFO_kindtypeINTEGERDEFAULT, 0, FFETARGET_charactersizeNONE,\n+\t\t\t\t  FFEEXPR_contextLET);\n+\t  break;\n+\n+\tdefault:\n+\t  error = TRUE;\n+\t  break;\n+\t}\n+      break;\n+\n     case FFEEXPR_contextDO:\n       if ((error = (expr == NULL) || (ffeinfo_rank (info) != 0)))\n \tbreak;\n@@ -18602,7 +18643,8 @@ ffeexpr_token_elements_ (ffelexToken ft, ffebld expr, ffelexToken t)\n \t      ffeexpr_stack_->immediate = FALSE;\n \t      break;\n \t    }\n-\t  if (ffebld_op (expr) == FFEBLD_opCONTER)\n+\t  if (ffebld_op (expr) == FFEBLD_opCONTER\n+\t      && ffebld_kindtype (expr) == FFEINFO_kindtypeINTEGERDEFAULT)\n \t    {\n \t      val = ffebld_constant_integerdefault (ffebld_conter (expr));\n \n@@ -18913,26 +18955,33 @@ ffeexpr_token_substring_1_ (ffelexToken ft, ffebld last, ffelexToken t)\n   ffetargetIntegerDefault last_val;\n   ffetargetCharacterSize size;\n   ffetargetCharacterSize strop_size_max;\n+  bool first_known;\n \n   string = ffeexpr_stack_->exprstack;\n   strop = string->u.operand;\n   info = ffebld_info (strop);\n \n-  if ((first == NULL) || (ffebld_op (first) == FFEBLD_opCONTER))\n+  if (first == NULL\n+      || (ffebld_op (first) == FFEBLD_opCONTER\n+\t  && ffebld_kindtype (first) == FFEINFO_kindtypeINTEGERDEFAULT))\n     {\t\t\t\t/* The starting point is known. */\n       first_val = (first == NULL) ? 1\n \t: ffebld_constant_integerdefault (ffebld_conter (first));\n+      first_known = TRUE;\n     }\n   else\n     {\t\t\t\t/* Assume start of the entity. */\n       first_val = 1;\n+      first_known = FALSE;\n     }\n \n-  if ((last != NULL) && (ffebld_op (last) == FFEBLD_opCONTER))\n+  if (last != NULL\n+      && (ffebld_op (last) == FFEBLD_opCONTER\n+\t  && ffebld_kindtype (last) == FFEINFO_kindtypeINTEGERDEFAULT))\n     {\t\t\t\t/* The ending point is known. */\n       last_val = ffebld_constant_integerdefault (ffebld_conter (last));\n \n-      if ((first == NULL) || (ffebld_op (first) == FFEBLD_opCONTER))\n+      if (first_known)\n \t{\t\t\t/* The beginning point is a constant. */\n \t  if (first_val <= last_val)\n \t    size = last_val - first_val + 1;"}, {"sha": "25070dbd5f897fd4dbf53c90d5d3f294584dbf71", "filename": "gcc/f/g77.texi", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Fg77.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Fg77.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fg77.texi?ref=ff852b44545f35144c7f30d9f1216df05cb39b55", "patch": "@@ -2,7 +2,7 @@\n @c %**start of header\n @setfilename g77.info\n \n-@set last-update 1999-05-10\n+@set last-update 1999-05-13\n @set copyrights-g77 1995-1999\n \n @include root.texi\n@@ -1470,7 +1470,7 @@ by type.  Explanations are in the following sections.\n -fdebug-kludge  -femulate-complex\n -falias-check  -fargument-alias\n -fargument-noalias  -fno-argument-noalias-global\n--fno-globals\n+-fno-globals  -fflatten-arrays\n -fsubscript-check  -ff2c-subscript-check\n @end smallexample\n @end table\n@@ -3372,6 +3372,20 @@ that are currently believed to not\n likely to result in the compiler later crashing\n or producing incorrect code.\n \n+@cindex -fflatten-arrays option\n+@item -fflatten-arrays\n+@cindex array performance\n+@cindex arrays, flattening\n+Use back end's C-like constructs\n+(pointer plus offset)\n+instead of its @code{ARRAY_REF} construct\n+to handle all array references.\n+\n+@emph{Note:} This option is not supported.\n+It is intended for use only by @code{g77} developers,\n+to evaluate code-generation issues.\n+It might be removed at any time.\n+\n @cindex -fsubscript-check option\n @cindex -ff2c-subscript-check option\n @item -fsubscript-check"}, {"sha": "417159cd4b4ecd645b4567078ea36262f6de059d", "filename": "gcc/f/lang-options.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flang-options.h?ref=ff852b44545f35144c7f30d9f1216df05cb39b55", "patch": "@@ -51,6 +51,8 @@ FTNOPT( \"-ff2c\", \"\" )\n FTNOPT( \"-fno-f2c\", \"f2c-compatible code need not be generated\" )\n FTNOPT( \"-ff2c-library\", \"\" )\n FTNOPT( \"-fno-f2c-library\", \"Unsupported; do not generate libf2c-calling code\" )\n+FTNOPT( \"-fflatten-arrays\", \"Unsupported; affects code-generation of arrays\" )\n+FTNOPT( \"-fno-flatten-arrays\", \"\" )\n FTNOPT( \"-ffree-form\", \"Program is written in Fortran-90-ish free form\" )\n FTNOPT( \"-fno-free-form\", \"\" )\n FTNOPT( \"-ffixed-form\", \"\" )"}, {"sha": "0a4b8e4e137909e6e242ec32d6745b2b0188eb1d", "filename": "gcc/f/news.texi", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Fnews.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Fnews.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fnews.texi?ref=ff852b44545f35144c7f30d9f1216df05cb39b55", "patch": "@@ -9,7 +9,7 @@\n @c in the standalone derivations of this file (e.g. NEWS).\n @set copyrights-news 1995-1999\n \n-@set last-update-news 1999-05-12\n+@set last-update-news 1999-05-13\n \n @include root.texi\n \n@@ -164,6 +164,15 @@ to type @code{INTEGER(KIND=2)}\n For example, @samp{INTEGER*8 J; J = 4E10} now works as documented.\n @end ifclear\n \n+@ifclear USERVISONLY\n+@item\n+@code{g77} no longer truncates @code{INTEGER(KIND=2)}\n+(usually @code{INTEGER*8})\n+subscript expressions when evaluating array references\n+on systems with pointers widers than @code{INTEGER(KIND=1)}\n+(such as Alphas).\n+@end ifclear\n+\n @ifclear USERVISONLY\n @item\n @code{g77} no longer generates bad code\n@@ -278,6 +287,15 @@ and not @code{SAVE}'d.\n a C-language concept,\n when performing operations such as the @code{SqRt} intrinsic.\n \n+@ifclear USERVISONLY\n+@item\n+@code{g77} developers can temporarily use\n+the @samp{-fflatten-arrays} option\n+to compare how the compiler handles code generation\n+using C-like constructs as compared to the\n+Fortran-like method constructs normally used.\n+@end ifclear\n+\n @ifclear USERVISONLY\n @item\n A substantial portion of the @code{g77} front end's code-generation component"}, {"sha": "0d6fb35e2143e0f4f5a7a3e11fcb6b8ad68f1f7c", "filename": "gcc/f/top.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Ftop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Ftop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftop.c?ref=ff852b44545f35144c7f30d9f1216df05cb39b55", "patch": "@@ -74,6 +74,7 @@ bool ffe_is_dollar_ok_ = FFETARGET_defaultIS_DOLLAR_OK;\n bool ffe_is_f2c_ = FFETARGET_defaultIS_F2C;\n bool ffe_is_f2c_library_ = FFETARGET_defaultIS_F2C_LIBRARY;\n bool ffe_is_ffedebug_ = FALSE;\n+bool ffe_is_flatten_arrays_ = FALSE;\n bool ffe_is_free_form_ = FFETARGET_defaultIS_FREE_FORM;\n bool ffe_is_globals_ = TRUE;\n bool ffe_is_init_local_zero_ = FFETARGET_defaultIS_INIT_LOCAL_ZERO;\n@@ -216,6 +217,10 @@ ffe_decode_option (argc, argv)\n \tffe_set_is_f2c_library (TRUE);\n       else if (strcmp (&opt[2], \"no-f2c-library\") == 0)\n \tffe_set_is_f2c_library (FALSE);\n+      else if (strcmp (&opt[2], \"flatten-arrays\") == 0)\n+\tffe_set_is_flatten_arrays (TRUE);\n+      else if (strcmp (&opt[2], \"no-flatten-arrays\") == 0)\n+\tffe_set_is_flatten_arrays (FALSE);\n       else if (strcmp (&opt[2], \"free-form\") == 0)\n \tffe_set_is_free_form (TRUE);\n       else if (strcmp (&opt[2], \"no-free-form\") == 0)"}, {"sha": "c5deea8a7001f2e597b8a44e347409294dddbff9", "filename": "gcc/f/top.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Ftop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Ftop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftop.h?ref=ff852b44545f35144c7f30d9f1216df05cb39b55", "patch": "@@ -90,6 +90,7 @@ extern bool ffe_is_dollar_ok_;\n extern bool ffe_is_f2c_;\n extern bool ffe_is_f2c_library_;\n extern bool ffe_is_ffedebug_;\n+extern bool ffe_is_flatten_arrays_;\n extern bool ffe_is_free_form_;\n extern bool ffe_is_globals_;\n extern bool ffe_is_init_local_zero_;\n@@ -178,6 +179,7 @@ void ffe_terminate_4 (void);\n #define ffe_is_f2c() ffe_is_f2c_\n #define ffe_is_f2c_library() ffe_is_f2c_library_\n #define ffe_is_ffedebug() ffe_is_ffedebug_\n+#define ffe_is_flatten_arrays() ffe_is_flatten_arrays_\n #define ffe_is_free_form() ffe_is_free_form_\n #define ffe_is_globals() ffe_is_globals_\n #define ffe_is_init_local_zero() ffe_is_init_local_zero_\n@@ -230,6 +232,7 @@ void ffe_terminate_4 (void);\n #define ffe_set_is_f2c(f) (ffe_is_f2c_ = (f))\n #define ffe_set_is_f2c_library(f) (ffe_is_f2c_library_ = (f))\n #define ffe_set_is_ffedebug(f) (ffe_is_ffedebug_ = (f))\n+#define ffe_set_is_flatten_arrays(f) (ffe_is_flatten_arrays_ = (f))\n #define ffe_set_is_free_form(f) (ffe_is_free_form_ = (f))\n #define ffe_set_is_globals(f) (ffe_is_globals_ = (f))\n #define ffe_set_is_init_local_zero(f) (ffe_is_init_local_zero_ = (f))"}, {"sha": "6705384221df5c6ca7a502c7fdf3b0b1c7bd7f67", "filename": "gcc/f/version.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Fversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff852b44545f35144c7f30d9f1216df05cb39b55/gcc%2Ff%2Fversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fversion.c?ref=ff852b44545f35144c7f30d9f1216df05cb39b55", "patch": "@@ -1 +1 @@\n-const char *ffe_version_string = \"0.5.24-19990503\";\n+const char *ffe_version_string = \"0.5.24-19990513\";"}]}