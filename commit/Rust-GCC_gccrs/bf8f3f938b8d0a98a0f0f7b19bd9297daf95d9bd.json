{"sha": "bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY4ZjNmOTM4YjhkMGE5OGEwZjBmN2IxOWJkOTI5N2RhZjk1ZDliZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-03-02T23:44:49Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-03-02T23:44:49Z"}, "message": "cp-tree.h (determine_specialization): Don't declare.\n\n\t* cp-tree.h (determine_specialization): Don't declare.\n\t* pt.c (determine_specialization): Make it static.  Eliminate\n\tcomplain parameter.  Note that decl is always non-NULL now, and\n\tsimplify accordingly.\n\nFrom-SVN: r25554", "tree": {"sha": "7085745fd31bd2a1d210951b137012b5c9673124", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7085745fd31bd2a1d210951b137012b5c9673124"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd/comments", "author": null, "committer": null, "parents": [{"sha": "642b32a58a733af03e442b602612666254d94677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642b32a58a733af03e442b602612666254d94677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/642b32a58a733af03e442b602612666254d94677"}], "stats": {"total": 108, "additions": 55, "deletions": 53}, "files": [{"sha": "e5098588e76346a36253535bcc778cde833a5265", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd", "patch": "@@ -1,5 +1,10 @@\n 1999-03-02  Mark Mitchell  <mark@markmitchell.com>\n \n+\t* cp-tree.h (determine_specialization): Don't declare.\n+\t* pt.c (determine_specialization): Make it static.  Eliminate\n+\tcomplain parameter.  Note that decl is always non-NULL now, and\n+\tsimplify accordingly.\n+\n \t* decl.c (maybe_push_to_top_level): Always call\n \tpush_cp_function_context.\n \t(pop_from_top_level): Always call pop_cp_function_context."}, {"sha": "935f8f9ff4aa41243011df35ab26befb639e4db0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd", "patch": "@@ -3053,7 +3053,6 @@ extern void reset_specialization                PROTO((void));\n extern void end_specialization                  PROTO((void));\n extern void begin_explicit_instantiation        PROTO((void));\n extern void end_explicit_instantiation          PROTO((void));\n-extern tree determine_specialization            PROTO((tree, tree, tree *, int, int));\n extern tree check_explicit_specialization       PROTO((tree, tree, int, int));\n extern tree process_template_parm\t\tPROTO((tree, tree));\n extern tree end_template_parm_list\t\tPROTO((tree));"}, {"sha": "a79b027d0f3262c2d6ba3bda3ff1d395925c8b4b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 35, "deletions": 52, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd", "patch": "@@ -148,6 +148,7 @@ static tree get_template_base PROTO((tree, tree, tree, tree));\n static tree try_class_unification PROTO((tree, tree, tree, tree));\n static int coerce_template_template_parms PROTO((tree, tree, int,\n \t\t\t\t\t\t tree, tree));\n+static tree determine_specialization PROTO((tree, tree, tree *, int));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -917,18 +918,15 @@ print_candidates (fns)\n    are output in a newly created vector *TARGS_OUT.\n \n    If it is impossible to determine the result, an error message is\n-   issued, unless COMPLAIN is 0.  In any case, error_mark_node is\n-   returned to indicate failure.  */\n+   issued.  The error_mark_node is returned to indicate failure.  */\n \n tree\n determine_specialization (template_id, decl, targs_out, \n-\t\t\t  need_member_template,\n-\t\t\t  complain)\n+\t\t\t  need_member_template)\n      tree template_id;\n      tree decl;\n      tree* targs_out;\n      int need_member_template;\n-     int complain;\n {\n   tree fn;\n   tree fns;\n@@ -973,10 +971,6 @@ determine_specialization (template_id, decl, targs_out,\n \t/* This is just an ordinary non-member function.  Nothing can\n \t   be a specialization of that.  */\n \tcontinue;\n-      else if (!decl)\n-\t/* When there's no DECL to match, we know we're looking for\n-\t   non-members.  */\n-\tcontinue;\n       else\n \t{\n \t  tree decl_arg_types;\n@@ -1010,33 +1004,20 @@ determine_specialization (template_id, decl, targs_out,\n \t  continue;\n \t}\n \n-      if (decl == NULL_TREE)\n-\t{\n-\t  /* Unify against ourselves to make sure that the args we have\n-\t     make sense and there aren't any undeducible parms.  It's OK if\n-\t     not all the parms are specified; they might be deduced\n-\t     later. */\n-\t  targs = get_bindings_overload (tmpl, DECL_RESULT (tmpl),\n-\t\t\t\t\t explicit_targs);\n-\t  if (uses_template_parms (targs))\n-\t    /* We couldn't deduce all the arguments.  */\n-\t    continue;\n-\t}\n-      else\n-\t/* See whether this function might be a specialization of this\n-\t   template.  */\n-\ttargs = get_bindings (tmpl, decl, explicit_targs);\n+      /* See whether this function might be a specialization of this\n+\t template.  */\n+      targs = get_bindings (tmpl, decl, explicit_targs);\n \n       if (!targs)\n-\t/* Wwe cannot deduce template arguments that when used to\n+\t/* We cannot deduce template arguments that when used to\n \t   specialize TMPL will produce DECL.  */\n \tcontinue;\n \n       /* Save this template, and the arguments deduced.  */\n       templates = scratch_tree_cons (targs, tmpl, templates);\n     }\n \n-  if (decl && templates && TREE_CHAIN (templates))\n+  if (templates && TREE_CHAIN (templates))\n     {\n       /* We have:\n \t \n@@ -1079,21 +1060,18 @@ determine_specialization (template_id, decl, targs_out,\n \n   if (templates == NULL_TREE && candidates == NULL_TREE)\n     {\n-      if (complain)\n-\tcp_error_at (\"template-id `%D' for `%+D' does not match any template declaration\",\n-\t\t     template_id, decl);\n+      cp_error_at (\"template-id `%D' for `%+D' does not match any template declaration\",\n+\t\t   template_id, decl);\n       return error_mark_node;\n     }\n   else if ((templates && TREE_CHAIN (templates))\n-\t   || (candidates && TREE_CHAIN (candidates)))\n+\t   || (candidates && TREE_CHAIN (candidates))\n+\t   || (templates && candidates))\n     {\n-      if (complain)\n-\t{\n-\t  cp_error_at (\"ambiguous template specialization `%D' for `%+D'\",\n-\t\t       template_id, decl);\n-\t  chainon (candidates, templates);\n-\t  print_candidates (candidates);\n-\t}\n+      cp_error_at (\"ambiguous template specialization `%D' for `%+D'\",\n+\t\t   template_id, decl);\n+      chainon (candidates, templates);\n+      print_candidates (candidates);\n       return error_mark_node;\n     }\n \n@@ -1445,8 +1423,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t declaration.  */\n       tmpl = determine_specialization (declarator, decl,\n \t\t\t\t       &targs, \n-\t\t\t\t       member_specialization,\n-\t\t\t\t       1);\n+\t\t\t\t       member_specialization);\n \t    \n       if (!tmpl || tmpl == error_mark_node)\n \t/* We couldn't figure out what this declaration was\n@@ -4366,8 +4343,7 @@ tsubst_friend_function (decl, args)\n       new_friend = tsubst (decl, args, /*complain=*/1, NULL_TREE);\n       tmpl = determine_specialization (template_id, new_friend,\n \t\t\t\t       &new_args, \n-\t\t\t\t       /*need_member_template=*/0, \n-\t\t\t\t       /*complain=*/1);\n+\t\t\t\t       /*need_member_template=*/0);\n       new_friend = instantiate_template (tmpl, new_args);\n       goto done;\n     }\n@@ -6045,8 +6021,8 @@ tsubst (t, args, complain, in_decl)\n \t       Type deduction may fail for any of the following\n \t       reasons:  \n \n-\t         Attempting to create an array with a size that is\n-\t         zero or negative.  */\n+\t\t Attempting to create an array with a size that is\n+\t\t zero or negative.  */\n \t    if (complain)\n \t      cp_error (\"creating array with size `%E'\", max);\n \n@@ -6409,16 +6385,23 @@ tsubst (t, args, complain, in_decl)\n \tif (ctx == error_mark_node || f == error_mark_node)\n \t  return error_mark_node;\n \n-\t/* Normally, make_typename_type does not require that the CTX\n-\t   have complete type in order to allow things like:\n+\tif (!IS_AGGR_TYPE (ctx))\n+\t  {\n+\t    if (complain)\n+\t      cp_error (\"`%T' is not a class, struct, or union type\",\n+\t\t\tctx);\n+\t    return error_mark_node;\n+\t  }\n+\telse if (!uses_template_parms (ctx) && !TYPE_BEING_DEFINED (ctx))\n+\t  {\n+\t    /* Normally, make_typename_type does not require that the CTX\n+\t       have complete type in order to allow things like:\n \t     \n-             template <class T> struct S { typename S<T>::X Y; };\n+\t         template <class T> struct S { typename S<T>::X Y; };\n \n-\t   But, such constructs have already been resolved by this\n-\t   point, so here CTX really should have complete type, unless\n-\t   it's a partial instantiation.  */\n-\tif (!uses_template_parms (ctx) && !TYPE_BEING_DEFINED (ctx))\n-\t  {\n+\t       But, such constructs have already been resolved by this\n+\t       point, so here CTX really should have complete type, unless\n+\t       it's a partial instantiation.  */\n \t    ctx = complete_type (ctx);\n \t    if (!TYPE_SIZE (ctx))\n \t      {"}, {"sha": "13dc37af68d795b820bbbc703565e312da00a80d", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash30.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash30.C?ref=bf8f3f938b8d0a98a0f0f7b19bd9297daf95d9bd", "patch": "@@ -0,0 +1,15 @@\n+// Build don't link:\n+\n+extern \"C\" int printf(const char *, ...);\n+template <class T> struct A {\n+  typedef typename T::X B; // ERROR - not a class\n+  A(double);\n+};\n+ \n+template <class T> void xxx(typename A<T>::B);\n+ \n+template <class T> struct B {\n+  friend void xxx<T>(T); // ERROR - does not match any template\n+};\n+ \n+template struct B<double>; // ERROR - "}]}