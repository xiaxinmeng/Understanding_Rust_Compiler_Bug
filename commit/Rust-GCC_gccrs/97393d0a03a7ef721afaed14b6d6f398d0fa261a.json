{"sha": "97393d0a03a7ef721afaed14b6d6f398d0fa261a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTczOTNkMGEwM2E3ZWY3MjFhZmFlZDE0YjZkNmYzOThkMGZhMjYxYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-09-26T20:55:10Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-09-26T20:55:10Z"}, "message": "libiberty.h (expandargv): New function.\n\n\t* libiberty.h (expandargv): New function.\n\n\t* argv.c (safe-ctype.h): Include it.\n\t(ISBLANK): Remove.\n\t(stdio.h): Include.\n\t(buildargv): Use ISSPACE instead of ISBLANK.\n\t(expandargv): New function.\n\nFrom-SVN: r104664", "tree": {"sha": "296846fb789e3b49e2547f212dd678d9e57512c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/296846fb789e3b49e2547f212dd678d9e57512c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97393d0a03a7ef721afaed14b6d6f398d0fa261a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97393d0a03a7ef721afaed14b6d6f398d0fa261a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97393d0a03a7ef721afaed14b6d6f398d0fa261a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97393d0a03a7ef721afaed14b6d6f398d0fa261a/comments", "author": null, "committer": null, "parents": [{"sha": "18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18623faed15aed3cc1ecbca0e7323bbc02b4d44b"}], "stats": {"total": 142, "additions": 134, "deletions": 8}, "files": [{"sha": "bdd47bb98c2727ad30f73823bba837f988067ad4", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97393d0a03a7ef721afaed14b6d6f398d0fa261a/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97393d0a03a7ef721afaed14b6d6f398d0fa261a/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=97393d0a03a7ef721afaed14b6d6f398d0fa261a", "patch": "@@ -1,3 +1,7 @@\n+2005-09-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* libiberty.h (expandargv): New function.\n+\n 2005-08-17  Mark Kettenis  <kettenis@gnu.org>\n \n \t* floatformat.h (struct floatformat): Change type of large"}, {"sha": "c264cb2ab0ee0df21284133adda17ad30743bcdb", "filename": "include/libiberty.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97393d0a03a7ef721afaed14b6d6f398d0fa261a/include%2Flibiberty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97393d0a03a7ef721afaed14b6d6f398d0fa261a/include%2Flibiberty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Flibiberty.h?ref=97393d0a03a7ef721afaed14b6d6f398d0fa261a", "patch": "@@ -82,6 +82,9 @@ extern void freeargv (char **);\n \n extern char **dupargv (char **) ATTRIBUTE_MALLOC;\n \n+/* Expand \"@file\" arguments in argv.  */\n+\n+extern void expandargv PARAMS ((int *, char ***));\n \n /* Return the last component of a path name.  Note that we can't use a\n    prototype here because the parameter is declared inconsistently"}, {"sha": "bf64ee9da92cd0f277734775c32fad1518907ef2", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97393d0a03a7ef721afaed14b6d6f398d0fa261a/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97393d0a03a7ef721afaed14b6d6f398d0fa261a/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=97393d0a03a7ef721afaed14b6d6f398d0fa261a", "patch": "@@ -1,3 +1,11 @@\n+2005-09-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* argv.c (safe-ctype.h): Include it.\n+\t(ISBLANK): Remove.\n+\t(stdio.h): Include.\n+\t(buildargv): Use ISSPACE instead of ISBLANK.\n+\t(expandargv): New function.\n+\n 2005-09-14  Christopher Faylor  <cgf@timesys.com>\n \n \t* pex-win32.c: Include \"windows.h\"."}, {"sha": "dcd5ebd86d1674168243f148e5e54497422e56b4", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97393d0a03a7ef721afaed14b6d6f398d0fa261a/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97393d0a03a7ef721afaed14b6d6f398d0fa261a/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=97393d0a03a7ef721afaed14b6d6f398d0fa261a", "patch": "@@ -441,7 +441,8 @@ $(CONFIGURED_OFILES): stamp-picdir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/alloca.c $(OUTPUT_OPTION)\n \n-./argv.o: $(srcdir)/argv.c config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n+./argv.o: $(srcdir)/argv.c config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n+\t$(INCDIR)/safe-ctype.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\\n \t  $(COMPILE.c) $(PICFLAG) $(srcdir)/argv.c -o pic/$@; \\\n \telse true; fi\n@@ -601,7 +602,7 @@ $(CONFIGURED_OFILES): stamp-picdir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/getcwd.c $(OUTPUT_OPTION)\n \n-./getopt.o: $(srcdir)/getopt.c config.h $(INCDIR)/getopt.h\n+./getopt.o: $(srcdir)/getopt.c config.h $(INCDIR)/ansidecl.h $(INCDIR)/getopt.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\\n \t  $(COMPILE.c) $(PICFLAG) $(srcdir)/getopt.c -o pic/$@; \\\n \telse true; fi\n@@ -996,8 +997,8 @@ $(CONFIGURED_OFILES): stamp-picdir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/strtoul.c $(OUTPUT_OPTION)\n \n-./strverscmp.o: $(srcdir)/strverscmp.c $(INCDIR)/safe-ctype.h \\\n-\t$(INCDIR)/libiberty.h\n+./strverscmp.o: $(srcdir)/strverscmp.c $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n+\t$(INCDIR)/safe-ctype.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\\n \t  $(COMPILE.c) $(PICFLAG) $(srcdir)/strverscmp.c -o pic/$@; \\\n \telse true; fi"}, {"sha": "71f164acf7ded1cf482a936f89a96749b294b738", "filename": "libiberty/argv.c", "status": "modified", "additions": 114, "deletions": 4, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97393d0a03a7ef721afaed14b6d6f398d0fa261a/libiberty%2Fargv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97393d0a03a7ef721afaed14b6d6f398d0fa261a/libiberty%2Fargv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fargv.c?ref=97393d0a03a7ef721afaed14b6d6f398d0fa261a", "patch": "@@ -27,14 +27,14 @@ Boston, MA 02110-1301, USA.  */\n #endif\n #include \"ansidecl.h\"\n #include \"libiberty.h\"\n-\n-#define ISBLANK(ch) ((ch) == ' ' || (ch) == '\\t')\n+#include \"safe-ctype.h\"\n \n /*  Routines imported from standard C runtime libraries. */\n \n #include <stddef.h>\n #include <string.h>\n #include <stdlib.h>\n+#include <stdio.h>\n \n #ifndef NULL\n #define NULL 0\n@@ -212,7 +212,7 @@ char **buildargv (const char *input)\n \t  arg = copybuf;\n \t  while (*input != EOS)\n \t    {\n-\t      if (ISBLANK (*input) && !squote && !dquote && !bsquote)\n+\t      if (ISSPACE (*input) && !squote && !dquote && !bsquote)\n \t\t{\n \t\t  break;\n \t\t}\n@@ -278,7 +278,7 @@ char **buildargv (const char *input)\n \t  argc++;\n \t  argv[argc] = NULL;\n \n-\t  while (ISBLANK (*input))\n+\t  while (ISSPACE (*input))\n \t    {\n \t      input++;\n \t    }\n@@ -288,6 +288,116 @@ char **buildargv (const char *input)\n   return (argv);\n }\n \n+/*\n+\n+@deftypefn Extension void expandargv (int *@var{argcp}, char ***@var{argvp})\n+\n+The @var{argcp} and @code{argvp} arguments are pointers to the usual\n+@code{argc} and @code{argv} arguments to @code{main}.  This function\n+looks for arguments that begin with the character @samp{@@}.  Any such\n+arguments are interpreted as ``response files''.  The contents of the\n+response file are interpreted as additional command line options.  In\n+particular, the file is separated into whitespace-separated strings;\n+each such string is taken as a command-line option.  The new options\n+are inserted in place of the option naming the response file, and\n+@code{*argcp} and @code{*argvp} will be updated.  If the value of\n+@code{*argvp} is modified by this function, then the new value has\n+been dynamically allocated and can be deallocated by the caller with\n+@code{freeargv}.  However, most callers will simply call\n+@code{expandargv} near the beginning of @code{main} and allow the\n+operating system to free the memory when the program exits.\n+\n+@end deftypefn\n+\n+*/\n+\n+void\n+expandargv (argcp, argvp)\n+     int *argcp;\n+     char ***argvp;\n+{\n+  /* The argument we are currently processing.  */\n+  int i = 0;\n+  /* Non-zero if ***argvp has been dynamically allocated.  */\n+  int argv_dynamic = 0;\n+  /* Loop over the arguments, handling response files.  We always skip\n+     ARGVP[0], as that is the name of the program being run.  */\n+  while (++i < *argcp)\n+    {\n+      /* The name of the response file.  */\n+      const char *filename;\n+      /* The response file.  */\n+      FILE *f;\n+      /* The number of characters in the response file.  */\n+      long pos;\n+      /* A dynamically allocated buffer used to hold options read from a\n+\t response file.  */\n+      char *buffer;\n+      /* Dynamically allocated storage for the options read from the\n+\t response file.  */\n+      char **file_argv;\n+      /* The number of options read from the response file, if any.  */\n+     size_t file_argc;\n+      /* We are only interested in options of the form \"@file\".  */\n+      filename = (*argvp)[i];\n+      if (filename[0] != '@')\n+\tcontinue;\n+      /* Read the contents of the file.  */\n+      f = fopen (++filename, \"r\");\n+      if (!f)\n+\tcontinue;\n+      if (fseek (f, 0L, SEEK_END) == -1)\n+\tgoto error;\n+      pos = ftell (f);\n+      if (pos == -1)\n+\tgoto error;\n+      if (fseek (f, 0L, SEEK_SET) == -1)\n+\tgoto error;\n+      buffer = (char *) xmalloc (pos * sizeof (char) + 1);\n+      if (fread (buffer, sizeof (char), pos, f) != (size_t) pos)\n+\tgoto error;\n+      /* Add a NUL terminator.  */\n+      buffer[pos] = '\\0';\n+      /* Parse the string.  */\n+      file_argv = buildargv (buffer);\n+      /* If *ARGVP is not already dynamically allocated, copy it.  */\n+      if (!argv_dynamic)\n+\t{\n+\t  *argvp = dupargv (*argvp);\n+\t  if (!*argvp)\n+\t    /* We do not know exactly many bytes dupargv tried to\n+\t       allocate, so make a guess.  */\n+\t    xmalloc_failed (*argcp * 32);\n+\t}\n+      /* Count the number of arguments.  */\n+      file_argc = 0;\n+      while (file_argv[file_argc] && *file_argv[file_argc])\n+\t++file_argc;\n+      /* Now, insert FILE_ARGV into ARGV.  The \"+1\" below handles the\n+\t NULL terminator at the end of ARGV.  */ \n+      *argvp = ((char **) \n+\t\txrealloc (*argvp, \n+\t\t\t  (*argcp + file_argc + 1) * sizeof (char *)));\n+      memmove (*argvp + i + file_argc, *argvp + i + 1, \n+\t       (*argcp - i) * sizeof (char *));\n+      memcpy (*argvp + i, file_argv, file_argc * sizeof (char *));\n+      /* The original option has been replaced by all the new\n+\t options.  */\n+      *argcp += file_argc - 1;\n+      /* Free up memory allocated to process the response file.  We do\n+\t not use freeargv because the individual options in FILE_ARGV\n+\t are now in the main ARGV.  */\n+      free (file_argv);\n+      free (buffer);\n+      /* Rescan all of the arguments just read to support response\n+\t files that include other response files.  */\n+      --i;\n+    error:\n+      /* We're all done with the file now.  */\n+      fclose (f);\n+    }\n+}\n+\n #ifdef MAIN\n \n /* Simple little test driver. */"}]}