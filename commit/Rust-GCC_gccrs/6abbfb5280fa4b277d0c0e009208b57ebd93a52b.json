{"sha": "6abbfb5280fa4b277d0c0e009208b57ebd93a52b", "node_id": "C_kwDOANBUbNoAKDZhYmJmYjUyODBmYTRiMjc3ZDBjMGUwMDkyMDhiNTdlYmQ5M2E1MmI", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-01-14T23:36:47Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-04-06T08:47:20Z"}, "message": "gccrs: Refactor all substitution mapper code implementation into its own CC file\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-substitution-mapper.cc (SubstMapper::SubstMapper): refactor\n\t(SubstMapper::Resolve): likewise\n\t(SubstMapper::InferSubst): likewise\n\t(SubstMapper::have_generic_args): likewise\n\t(SubstMapper::visit): likewise\n\t(SubstMapperInternal::visit): likewise\n\t(SubstMapperFromExisting::SubstMapperFromExisting): likewise\n\t(SubstMapperFromExisting::Resolve): likewise\n\t(SubstMapperFromExisting::visit): likewise\n\t(GetUsedSubstArgs::GetUsedSubstArgs): likewise\n\t(GetUsedSubstArgs::From): likewise\n\t(GetUsedSubstArgs::visit): likewise\n\t* typecheck/rust-substitution-mapper.h: refactor\n\t* typecheck/rust-tyty-subst.cc (SubstitutionParamMapping::get_generic_param): likewise", "tree": {"sha": "066c9b155fe75f1246aca39dd16435522f9d65ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/066c9b155fe75f1246aca39dd16435522f9d65ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6abbfb5280fa4b277d0c0e009208b57ebd93a52b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6abbfb5280fa4b277d0c0e009208b57ebd93a52b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6abbfb5280fa4b277d0c0e009208b57ebd93a52b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6abbfb5280fa4b277d0c0e009208b57ebd93a52b/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42118c327f8f3501f034b6febda67dc058ae60c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e42118c327f8f3501f034b6febda67dc058ae60c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e42118c327f8f3501f034b6febda67dc058ae60c"}], "stats": {"total": 631, "additions": 387, "deletions": 244}, "files": [{"sha": "dc93857e60f09a24176852d1b18682cad4ddb8a4", "filename": "gcc/rust/typecheck/rust-substitution-mapper.cc", "status": "modified", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abbfb5280fa4b277d0c0e009208b57ebd93a52b/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abbfb5280fa4b277d0c0e009208b57ebd93a52b/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc?ref=6abbfb5280fa4b277d0c0e009208b57ebd93a52b", "patch": "@@ -22,6 +22,116 @@\n namespace Rust {\n namespace Resolver {\n \n+SubstMapper::SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus)\n+  : resolved (new TyTy::ErrorType (ref)), generics (generics), locus (locus)\n+{}\n+\n+TyTy::BaseType *\n+SubstMapper::Resolve (TyTy::BaseType *base, Location locus,\n+\t\t      HIR::GenericArgs *generics)\n+{\n+  SubstMapper mapper (base->get_ref (), generics, locus);\n+  base->accept_vis (mapper);\n+  rust_assert (mapper.resolved != nullptr);\n+  return mapper.resolved;\n+}\n+\n+TyTy::BaseType *\n+SubstMapper::InferSubst (TyTy::BaseType *base, Location locus)\n+{\n+  return SubstMapper::Resolve (base, locus, nullptr);\n+}\n+\n+bool\n+SubstMapper::have_generic_args () const\n+{\n+  return generics != nullptr;\n+}\n+\n+void\n+SubstMapper::visit (TyTy::FnType &type)\n+{\n+  TyTy::FnType *concrete = nullptr;\n+  if (!have_generic_args ())\n+    {\n+      TyTy::BaseType *substs = type.infer_substitions (locus);\n+      rust_assert (substs->get_kind () == TyTy::TypeKind::FNDEF);\n+      concrete = static_cast<TyTy::FnType *> (substs);\n+    }\n+  else\n+    {\n+      TyTy::SubstitutionArgumentMappings mappings\n+\t= type.get_mappings_from_generic_args (*generics);\n+      if (mappings.is_error ())\n+\treturn;\n+\n+      concrete = type.handle_substitions (mappings);\n+    }\n+\n+  if (concrete != nullptr)\n+    resolved = concrete;\n+}\n+\n+void\n+SubstMapper::visit (TyTy::ADTType &type)\n+{\n+  TyTy::ADTType *concrete = nullptr;\n+  if (!have_generic_args ())\n+    {\n+      TyTy::BaseType *substs = type.infer_substitions (locus);\n+      rust_assert (substs->get_kind () == TyTy::TypeKind::ADT);\n+      concrete = static_cast<TyTy::ADTType *> (substs);\n+    }\n+  else\n+    {\n+      TyTy::SubstitutionArgumentMappings mappings\n+\t= type.get_mappings_from_generic_args (*generics);\n+      if (mappings.is_error ())\n+\treturn;\n+\n+      concrete = type.handle_substitions (mappings);\n+    }\n+\n+  if (concrete != nullptr)\n+    resolved = concrete;\n+}\n+\n+void\n+SubstMapper::visit (TyTy::PlaceholderType &type)\n+{\n+  rust_assert (type.can_resolve ());\n+  resolved = SubstMapper::Resolve (type.resolve (), locus, generics);\n+}\n+\n+void\n+SubstMapper::visit (TyTy::ProjectionType &type)\n+{\n+  TyTy::ProjectionType *concrete = nullptr;\n+  if (!have_generic_args ())\n+    {\n+      TyTy::BaseType *substs = type.infer_substitions (locus);\n+      rust_assert (substs->get_kind () == TyTy::TypeKind::PROJECTION);\n+      concrete = static_cast<TyTy::ProjectionType *> (substs);\n+    }\n+  else\n+    {\n+      TyTy::SubstitutionArgumentMappings mappings\n+\t= type.get_mappings_from_generic_args (*generics);\n+      if (mappings.is_error ())\n+\treturn;\n+\n+      concrete = type.handle_substitions (mappings);\n+    }\n+\n+  if (concrete != nullptr)\n+    resolved = concrete;\n+}\n+\n+SubstMapperInternal::SubstMapperInternal (\n+  HirId ref, TyTy::SubstitutionArgumentMappings &mappings)\n+  : resolved (new TyTy::ErrorType (ref)), mappings (mappings)\n+{}\n+\n TyTy::BaseType *\n SubstMapperInternal::Resolve (TyTy::BaseType *base,\n \t\t\t      TyTy::SubstitutionArgumentMappings &mappings)\n@@ -73,5 +183,238 @@ SubstMapperInternal::mappings_are_bound (\n   return false;\n }\n \n+void\n+SubstMapperInternal::visit (TyTy::FnType &type)\n+{\n+  TyTy::SubstitutionArgumentMappings adjusted\n+    = type.adjust_mappings_for_this (mappings);\n+  if (adjusted.is_error ())\n+    return;\n+\n+  TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n+  if (concrete != nullptr)\n+    resolved = concrete;\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ADTType &type)\n+{\n+  TyTy::SubstitutionArgumentMappings adjusted\n+    = type.adjust_mappings_for_this (mappings);\n+  if (adjusted.is_error ())\n+    return;\n+\n+  TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n+  if (concrete != nullptr)\n+    resolved = concrete;\n+}\n+\n+// these don't support generic arguments but might contain a type param\n+void\n+SubstMapperInternal::visit (TyTy::TupleType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ReferenceType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::PointerType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ParamType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::PlaceholderType &type)\n+{\n+  rust_assert (type.can_resolve ());\n+  if (mappings.trait_item_mode ())\n+    {\n+      resolved = type.resolve ();\n+    }\n+  else\n+    {\n+      resolved = SubstMapperInternal::Resolve (type.resolve (), mappings);\n+    }\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ProjectionType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ClosureType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ArrayType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::SliceType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+// nothing to do for these\n+void\n+SubstMapperInternal::visit (TyTy::InferType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::FnPtr &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::BoolType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::IntType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::UintType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::FloatType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::USizeType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::ISizeType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::ErrorType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::CharType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::StrType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::NeverType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::DynamicObjectType &type)\n+{\n+  resolved = type.clone ();\n+}\n+\n+// SubstMapperFromExisting\n+\n+SubstMapperFromExisting::SubstMapperFromExisting (TyTy::BaseType *concrete,\n+\t\t\t\t\t\t  TyTy::BaseType *receiver)\n+  : concrete (concrete), receiver (receiver), resolved (nullptr)\n+{}\n+\n+TyTy::BaseType *\n+SubstMapperFromExisting::Resolve (TyTy::BaseType *concrete,\n+\t\t\t\t  TyTy::BaseType *receiver)\n+{\n+  rust_assert (concrete->get_kind () == receiver->get_kind ());\n+\n+  SubstMapperFromExisting mapper (concrete, receiver);\n+  concrete->accept_vis (mapper);\n+  return mapper.resolved;\n+}\n+\n+void\n+SubstMapperFromExisting::visit (TyTy::FnType &type)\n+{\n+  rust_assert (type.was_substituted ());\n+\n+  TyTy::FnType *to_sub = static_cast<TyTy::FnType *> (receiver);\n+  resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n+}\n+\n+void\n+SubstMapperFromExisting::visit (TyTy::ADTType &type)\n+{\n+  rust_assert (type.was_substituted ());\n+\n+  TyTy::ADTType *to_sub = static_cast<TyTy::ADTType *> (receiver);\n+  resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n+}\n+\n+void\n+SubstMapperFromExisting::visit (TyTy::ClosureType &type)\n+{\n+  rust_assert (type.was_substituted ());\n+\n+  TyTy::ClosureType *to_sub = static_cast<TyTy::ClosureType *> (receiver);\n+  resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n+}\n+\n+// GetUsedSubstArgs\n+\n+GetUsedSubstArgs::GetUsedSubstArgs ()\n+  : args (TyTy::SubstitutionArgumentMappings::error ())\n+{}\n+\n+TyTy::SubstitutionArgumentMappings\n+GetUsedSubstArgs::From (const TyTy::BaseType *from)\n+{\n+  GetUsedSubstArgs mapper;\n+  from->accept_vis (mapper);\n+  return mapper.args;\n+}\n+\n+void\n+GetUsedSubstArgs::visit (const TyTy::FnType &type)\n+{\n+  args = type.get_substitution_arguments ();\n+}\n+\n+void\n+GetUsedSubstArgs::visit (const TyTy::ADTType &type)\n+{\n+  args = type.get_substitution_arguments ();\n+}\n+\n+void\n+GetUsedSubstArgs::visit (const TyTy::ClosureType &type)\n+{\n+  args = type.get_substitution_arguments ();\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "43b80b36713748092eff3c18976b5c6194e2bbef", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 43, "deletions": 243, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abbfb5280fa4b277d0c0e009208b57ebd93a52b/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abbfb5280fa4b277d0c0e009208b57ebd93a52b/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=6abbfb5280fa4b277d0c0e009208b57ebd93a52b", "patch": "@@ -29,95 +29,16 @@ class SubstMapper : public TyTy::TyVisitor\n {\n public:\n   static TyTy::BaseType *Resolve (TyTy::BaseType *base, Location locus,\n-\t\t\t\t  HIR::GenericArgs *generics = nullptr)\n-  {\n-    SubstMapper mapper (base->get_ref (), generics, locus);\n-    base->accept_vis (mapper);\n-    rust_assert (mapper.resolved != nullptr);\n-    return mapper.resolved;\n-  }\n+\t\t\t\t  HIR::GenericArgs *generics = nullptr);\n \n-  static TyTy::BaseType *InferSubst (TyTy::BaseType *base, Location locus)\n-  {\n-    return SubstMapper::Resolve (base, locus, nullptr);\n-  }\n+  static TyTy::BaseType *InferSubst (TyTy::BaseType *base, Location locus);\n \n-  bool have_generic_args () const { return generics != nullptr; }\n+  bool have_generic_args () const;\n \n-  void visit (TyTy::FnType &type) override\n-  {\n-    TyTy::FnType *concrete = nullptr;\n-    if (!have_generic_args ())\n-      {\n-\tTyTy::BaseType *substs = type.infer_substitions (locus);\n-\trust_assert (substs->get_kind () == TyTy::TypeKind::FNDEF);\n-\tconcrete = static_cast<TyTy::FnType *> (substs);\n-      }\n-    else\n-      {\n-\tTyTy::SubstitutionArgumentMappings mappings\n-\t  = type.get_mappings_from_generic_args (*generics);\n-\tif (mappings.is_error ())\n-\t  return;\n-\n-\tconcrete = type.handle_substitions (mappings);\n-      }\n-\n-    if (concrete != nullptr)\n-      resolved = concrete;\n-  }\n-\n-  void visit (TyTy::ADTType &type) override\n-  {\n-    TyTy::ADTType *concrete = nullptr;\n-    if (!have_generic_args ())\n-      {\n-\tTyTy::BaseType *substs = type.infer_substitions (locus);\n-\trust_assert (substs->get_kind () == TyTy::TypeKind::ADT);\n-\tconcrete = static_cast<TyTy::ADTType *> (substs);\n-      }\n-    else\n-      {\n-\tTyTy::SubstitutionArgumentMappings mappings\n-\t  = type.get_mappings_from_generic_args (*generics);\n-\tif (mappings.is_error ())\n-\t  return;\n-\n-\tconcrete = type.handle_substitions (mappings);\n-      }\n-\n-    if (concrete != nullptr)\n-      resolved = concrete;\n-  }\n-\n-  void visit (TyTy::PlaceholderType &type) override\n-  {\n-    rust_assert (type.can_resolve ());\n-    resolved = SubstMapper::Resolve (type.resolve (), locus, generics);\n-  }\n-\n-  void visit (TyTy::ProjectionType &type) override\n-  {\n-    TyTy::ProjectionType *concrete = nullptr;\n-    if (!have_generic_args ())\n-      {\n-\tTyTy::BaseType *substs = type.infer_substitions (locus);\n-\trust_assert (substs->get_kind () == TyTy::TypeKind::PROJECTION);\n-\tconcrete = static_cast<TyTy::ProjectionType *> (substs);\n-      }\n-    else\n-      {\n-\tTyTy::SubstitutionArgumentMappings mappings\n-\t  = type.get_mappings_from_generic_args (*generics);\n-\tif (mappings.is_error ())\n-\t  return;\n-\n-\tconcrete = type.handle_substitions (mappings);\n-      }\n-\n-    if (concrete != nullptr)\n-      resolved = concrete;\n-  }\n+  void visit (TyTy::FnType &type) override;\n+  void visit (TyTy::ADTType &type) override;\n+  void visit (TyTy::PlaceholderType &type) override;\n+  void visit (TyTy::ProjectionType &type) override;\n \n   // nothing to do for these\n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n@@ -142,9 +63,7 @@ class SubstMapper : public TyTy::TyVisitor\n   void visit (TyTy::ClosureType &) override { gcc_unreachable (); }\n \n private:\n-  SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus)\n-    : resolved (new TyTy::ErrorType (ref)), generics (generics), locus (locus)\n-  {}\n+  SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus);\n \n   TyTy::BaseType *resolved;\n   HIR::GenericArgs *generics;\n@@ -160,106 +79,33 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   static bool mappings_are_bound (TyTy::BaseType *ty,\n \t\t\t\t  TyTy::SubstitutionArgumentMappings &mappings);\n \n-  void visit (TyTy::FnType &type) override\n-  {\n-    TyTy::SubstitutionArgumentMappings adjusted\n-      = type.adjust_mappings_for_this (mappings);\n-    if (adjusted.is_error ())\n-      return;\n-\n-    TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n-    if (concrete != nullptr)\n-      resolved = concrete;\n-  }\n-\n-  void visit (TyTy::ADTType &type) override\n-  {\n-    TyTy::SubstitutionArgumentMappings adjusted\n-      = type.adjust_mappings_for_this (mappings);\n-    if (adjusted.is_error ())\n-      return;\n-\n-    TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n-    if (concrete != nullptr)\n-      resolved = concrete;\n-  }\n-\n-  // these don't support generic arguments but might contain a type param\n-  void visit (TyTy::TupleType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::ReferenceType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::PointerType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::ParamType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::PlaceholderType &type) override\n-  {\n-    rust_assert (type.can_resolve ());\n-    if (mappings.trait_item_mode ())\n-      {\n-\tresolved = type.resolve ();\n-      }\n-    else\n-      {\n-\tresolved = SubstMapperInternal::Resolve (type.resolve (), mappings);\n-      }\n-  }\n-\n-  void visit (TyTy::ProjectionType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::ClosureType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::ArrayType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::SliceType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  // nothing to do for these\n-  void visit (TyTy::InferType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::FnPtr &type) override { resolved = type.clone (); }\n-  void visit (TyTy::BoolType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::IntType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::UintType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::FloatType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::USizeType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::ISizeType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::ErrorType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::CharType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::StrType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::NeverType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::DynamicObjectType &type) override\n-  {\n-    resolved = type.clone ();\n-  }\n+  void visit (TyTy::FnType &type) override;\n+  void visit (TyTy::ADTType &type) override;\n+  void visit (TyTy::TupleType &type) override;\n+  void visit (TyTy::ReferenceType &type) override;\n+  void visit (TyTy::PointerType &type) override;\n+  void visit (TyTy::ParamType &type) override;\n+  void visit (TyTy::PlaceholderType &type) override;\n+  void visit (TyTy::ProjectionType &type) override;\n+  void visit (TyTy::ClosureType &type) override;\n+  void visit (TyTy::ArrayType &type) override;\n+  void visit (TyTy::SliceType &type) override;\n+  void visit (TyTy::InferType &type) override;\n+  void visit (TyTy::FnPtr &type) override;\n+  void visit (TyTy::BoolType &type) override;\n+  void visit (TyTy::IntType &type) override;\n+  void visit (TyTy::UintType &type) override;\n+  void visit (TyTy::FloatType &type) override;\n+  void visit (TyTy::USizeType &type) override;\n+  void visit (TyTy::ISizeType &type) override;\n+  void visit (TyTy::ErrorType &type) override;\n+  void visit (TyTy::CharType &type) override;\n+  void visit (TyTy::StrType &type) override;\n+  void visit (TyTy::NeverType &type) override;\n+  void visit (TyTy::DynamicObjectType &type) override;\n \n private:\n-  SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings)\n-    : resolved (new TyTy::ErrorType (ref)), mappings (mappings)\n-  {}\n+  SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings);\n \n   TyTy::BaseType *resolved;\n   TyTy::SubstitutionArgumentMappings &mappings;\n@@ -269,38 +115,11 @@ class SubstMapperFromExisting : public TyTy::TyVisitor\n {\n public:\n   static TyTy::BaseType *Resolve (TyTy::BaseType *concrete,\n-\t\t\t\t  TyTy::BaseType *receiver)\n-  {\n-    rust_assert (concrete->get_kind () == receiver->get_kind ());\n-\n-    SubstMapperFromExisting mapper (concrete, receiver);\n-    concrete->accept_vis (mapper);\n-    return mapper.resolved;\n-  }\n+\t\t\t\t  TyTy::BaseType *receiver);\n \n-  void visit (TyTy::FnType &type) override\n-  {\n-    rust_assert (type.was_substituted ());\n-\n-    TyTy::FnType *to_sub = static_cast<TyTy::FnType *> (receiver);\n-    resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n-  }\n-\n-  void visit (TyTy::ADTType &type) override\n-  {\n-    rust_assert (type.was_substituted ());\n-\n-    TyTy::ADTType *to_sub = static_cast<TyTy::ADTType *> (receiver);\n-    resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n-  }\n-\n-  void visit (TyTy::ClosureType &type) override\n-  {\n-    rust_assert (type.was_substituted ());\n-\n-    TyTy::ClosureType *to_sub = static_cast<TyTy::ClosureType *> (receiver);\n-    resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n-  }\n+  void visit (TyTy::FnType &type) override;\n+  void visit (TyTy::ADTType &type) override;\n+  void visit (TyTy::ClosureType &type) override;\n \n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n   void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n@@ -325,40 +144,21 @@ class SubstMapperFromExisting : public TyTy::TyVisitor\n   void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n \n private:\n-  SubstMapperFromExisting (TyTy::BaseType *concrete, TyTy::BaseType *receiver)\n-    : concrete (concrete), receiver (receiver), resolved (nullptr)\n-  {}\n+  SubstMapperFromExisting (TyTy::BaseType *concrete, TyTy::BaseType *receiver);\n \n   TyTy::BaseType *concrete;\n   TyTy::BaseType *receiver;\n-\n   TyTy::BaseType *resolved;\n };\n \n class GetUsedSubstArgs : public TyTy::TyConstVisitor\n {\n public:\n-  static TyTy::SubstitutionArgumentMappings From (const TyTy::BaseType *from)\n-  {\n-    GetUsedSubstArgs mapper;\n-    from->accept_vis (mapper);\n-    return mapper.args;\n-  }\n-\n-  void visit (const TyTy::FnType &type) override\n-  {\n-    args = type.get_substitution_arguments ();\n-  }\n-\n-  void visit (const TyTy::ADTType &type) override\n-  {\n-    args = type.get_substitution_arguments ();\n-  }\n+  static TyTy::SubstitutionArgumentMappings From (const TyTy::BaseType *from);\n \n-  void visit (const TyTy::ClosureType &type) override\n-  {\n-    args = type.get_substitution_arguments ();\n-  }\n+  void visit (const TyTy::FnType &type) override;\n+  void visit (const TyTy::ADTType &type) override;\n+  void visit (const TyTy::ClosureType &type) override;\n \n   void visit (const TyTy::InferType &) override {}\n   void visit (const TyTy::TupleType &) override {}\n@@ -383,7 +183,7 @@ class GetUsedSubstArgs : public TyTy::TyConstVisitor\n   void visit (const TyTy::DynamicObjectType &) override {}\n \n private:\n-  GetUsedSubstArgs () : args (TyTy::SubstitutionArgumentMappings::error ()) {}\n+  GetUsedSubstArgs ();\n \n   TyTy::SubstitutionArgumentMappings args;\n };"}, {"sha": "aceed29ff0348012e7b9a932e57bea405ec246db", "filename": "gcc/rust/typecheck/rust-tyty-subst.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abbfb5280fa4b277d0c0e009208b57ebd93a52b/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abbfb5280fa4b277d0c0e009208b57ebd93a52b/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc?ref=6abbfb5280fa4b277d0c0e009208b57ebd93a52b", "patch": "@@ -68,7 +68,7 @@ const HIR::TypeParam &\n SubstitutionParamMapping::get_generic_param ()\n {\n   return generic;\n-};\n+}\n \n bool\n SubstitutionParamMapping::needs_substitution () const"}]}