{"sha": "16734677674ae7f58f4339fa97a91411a347e5db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY3MzQ2Nzc2NzRhZTdmNThmNDMzOWZhOTdhOTE0MTFhMzQ3ZTVkYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-11-09T09:19:59Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-11-09T09:19:59Z"}, "message": "i386: Disallow address spaces with string insns\n\nWhile cmps and movs allow a segment override of the ds:esi\nsource, the es:edi source/destination cannot be overriden.\nSimplify things in the backend for now by disallowing\nsegments for string insns entirely.\n\n\t* config/i386/i386.c (ix86_check_no_addr_space): New.\n\t(decide_alg): Add have_as parameter.\n\t(alg_usable_p): Likewise; disable rep algorithms if set.\n\t(ix86_expand_set_or_movmem): Notice if either MEM has a\n\tnon-default address space.\n\t(ix86_expand_strlen): Likewise.\n\t* config/i386/i386.md (strmov, strset): Likewise.\n\t(*strmovdi_rex_1): Use ix86_check_no_addr_space.\n\t(*strmovsi_1, *strmovqi_1, *rep_movdi_rex64, *rep_movsi, *rep_movqi,\n\t*strsetdi_rex_1, *strsetsi_1, *strsethi_1, *strsetqi_1,\n\t*rep_stosdi_rex64, *rep_stossi, *rep_stosqi, *cmpstrnqi_nz_1,\n\t*cmpstrnqi_1, *strlenqi_1): Likewise.\n\nFrom-SVN: r230002", "tree": {"sha": "968f69548931b685eae5707facf5b72c95bd3683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/968f69548931b685eae5707facf5b72c95bd3683"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16734677674ae7f58f4339fa97a91411a347e5db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16734677674ae7f58f4339fa97a91411a347e5db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16734677674ae7f58f4339fa97a91411a347e5db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16734677674ae7f58f4339fa97a91411a347e5db/comments", "author": null, "committer": null, "parents": [{"sha": "fe5f926316422c9c3bbcec1a412cd5fc14cd47d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe5f926316422c9c3bbcec1a412cd5fc14cd47d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe5f926316422c9c3bbcec1a412cd5fc14cd47d7"}], "stats": {"total": 134, "additions": 102, "deletions": 32}, "files": [{"sha": "c7e5728d29ff3ba1d3b9ded662d35e9905c2896f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16734677674ae7f58f4339fa97a91411a347e5db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16734677674ae7f58f4339fa97a91411a347e5db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16734677674ae7f58f4339fa97a91411a347e5db", "patch": "@@ -1,5 +1,18 @@\n 2015-11-09  Richard Henderson  <rth@redhat.com>\n \n+\t* config/i386/i386.c (ix86_check_no_addr_space): New.\n+\t(decide_alg): Add have_as parameter.\n+\t(alg_usable_p): Likewise; disable rep algorithms if set.\n+\t(ix86_expand_set_or_movmem): Notice if either MEM has a\n+\tnon-default address space.\n+\t(ix86_expand_strlen): Likewise.\n+\t* config/i386/i386.md (strmov, strset): Likewise.\n+\t(*strmovdi_rex_1): Use ix86_check_no_addr_space.\n+\t(*strmovsi_1, *strmovqi_1, *rep_movdi_rex64, *rep_movsi, *rep_movqi,\n+\t*strsetdi_rex_1, *strsetsi_1, *strsethi_1, *strsetqi_1,\n+\t*rep_stosdi_rex64, *rep_stossi, *rep_stosqi, *cmpstrnqi_nz_1,\n+\t*cmpstrnqi_1, *strlenqi_1): Likewise.\n+\n \t* config/i386/i386.md (*movabs<mode>_1): Print the full memory rtx.\n \t(*movabs<mode>_2): Likewise.\n "}, {"sha": "5e46833ff3a82d46c52f50ebfc7c0514afa0e397", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16734677674ae7f58f4339fa97a91411a347e5db/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16734677674ae7f58f4339fa97a91411a347e5db/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=16734677674ae7f58f4339fa97a91411a347e5db", "patch": "@@ -141,6 +141,7 @@ extern void ix86_split_ashr (rtx *, rtx, machine_mode);\n extern void ix86_split_lshr (rtx *, rtx, machine_mode);\n extern rtx ix86_find_base_term (rtx);\n extern bool ix86_check_movabs (rtx, int);\n+extern bool ix86_check_no_addr_space (rtx);\n extern void ix86_split_idivmod (machine_mode, rtx[], bool);\n \n extern rtx assign_386_stack_local (machine_mode, enum ix86_stack_slot);"}, {"sha": "159e1d19a10ba7de81a6bb4155e35af0d958505b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 46, "deletions": 15, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16734677674ae7f58f4339fa97a91411a347e5db/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16734677674ae7f58f4339fa97a91411a347e5db/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=16734677674ae7f58f4339fa97a91411a347e5db", "patch": "@@ -10538,6 +10538,20 @@ ix86_check_movabs (rtx insn, int opnum)\n   gcc_assert (MEM_P (mem));\n   return volatile_ok || !MEM_VOLATILE_P (mem);\n }\n+\n+/* Return false if INSN contains a MEM with a non-default address space.  */\n+bool\n+ix86_check_no_addr_space (rtx insn)\n+{\n+  subrtx_var_iterator::array_type array;\n+  FOR_EACH_SUBRTX_VAR (iter, array, PATTERN (insn), ALL)\n+    {\n+      rtx x = *iter;\n+      if (MEM_P (x) && !ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (x)))\n+\treturn false;\n+    }\n+  return true;\n+}\n \f\n /* Initialize the table of extra 80387 mathematical constants.  */\n \n@@ -25665,7 +25679,7 @@ expand_set_or_movmem_constant_prologue (rtx dst, rtx *srcp, rtx destreg,\n /* Return true if ALG can be used in current context.  \n    Assume we expand memset if MEMSET is true.  */\n static bool\n-alg_usable_p (enum stringop_alg alg, bool memset)\n+alg_usable_p (enum stringop_alg alg, bool memset, bool have_as)\n {\n   if (alg == no_stringop)\n     return false;\n@@ -25674,20 +25688,28 @@ alg_usable_p (enum stringop_alg alg, bool memset)\n   /* Algorithms using the rep prefix want at least edi and ecx;\n      additionally, memset wants eax and memcpy wants esi.  Don't\n      consider such algorithms if the user has appropriated those\n-     registers for their own purposes.\t*/\n+     registers for their own purposes, or if we have a non-default\n+     address space, since some string insns cannot override the segment.  */\n   if (alg == rep_prefix_1_byte\n       || alg == rep_prefix_4_byte\n       || alg == rep_prefix_8_byte)\n-    return !(fixed_regs[CX_REG] || fixed_regs[DI_REG]\n-             || (memset ? fixed_regs[AX_REG] : fixed_regs[SI_REG]));\n+    {\n+      if (have_as)\n+\treturn false;\n+      if (fixed_regs[CX_REG]\n+\t  || fixed_regs[DI_REG]\n+\t  || (memset ? fixed_regs[AX_REG] : fixed_regs[SI_REG]))\n+\treturn false;\n+    }\n   return true;\n }\n \n /* Given COUNT and EXPECTED_SIZE, decide on codegen of string operation.  */\n static enum stringop_alg\n decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size,\n \t    unsigned HOST_WIDE_INT min_size, unsigned HOST_WIDE_INT max_size,\n-\t    bool memset, bool zero_memset, int *dynamic_check, bool *noalign)\n+\t    bool memset, bool zero_memset, bool have_as,\n+\t    int *dynamic_check, bool *noalign)\n {\n   const struct stringop_algs * algs;\n   bool optimize_for_speed;\n@@ -25719,7 +25741,7 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size,\n   for (i = 0; i < MAX_STRINGOP_ALGS; i++)\n     {\n       enum stringop_alg candidate = algs->size[i].alg;\n-      bool usable = alg_usable_p (candidate, memset);\n+      bool usable = alg_usable_p (candidate, memset, have_as);\n       any_alg_usable_p |= usable;\n \n       if (candidate != libcall && candidate && usable)\n@@ -25735,17 +25757,17 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size,\n \n   /* If user specified the algorithm, honnor it if possible.  */\n   if (ix86_stringop_alg != no_stringop\n-      && alg_usable_p (ix86_stringop_alg, memset))\n+      && alg_usable_p (ix86_stringop_alg, memset, have_as))\n     return ix86_stringop_alg;\n   /* rep; movq or rep; movl is the smallest variant.  */\n   else if (!optimize_for_speed)\n     {\n       *noalign = true;\n       if (!count || (count & 3) || (memset && !zero_memset))\n-\treturn alg_usable_p (rep_prefix_1_byte, memset)\n+\treturn alg_usable_p (rep_prefix_1_byte, memset, have_as)\n \t       ? rep_prefix_1_byte : loop_1_byte;\n       else\n-\treturn alg_usable_p (rep_prefix_4_byte, memset)\n+\treturn alg_usable_p (rep_prefix_4_byte, memset, have_as)\n \t       ? rep_prefix_4_byte : loop;\n     }\n   /* Very tiny blocks are best handled via the loop, REP is expensive to\n@@ -25768,7 +25790,8 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size,\n \t    {\n \t      enum stringop_alg candidate = algs->size[i].alg;\n \n-\t      if (candidate != libcall && alg_usable_p (candidate, memset))\n+\t      if (candidate != libcall\n+\t\t  && alg_usable_p (candidate, memset, have_as))\n \t\t{\n \t\t  alg = candidate;\n \t\t  alg_noalign = algs->size[i].noalign;\n@@ -25788,7 +25811,7 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size,\n \t\t  else if (!any_alg_usable_p)\n \t\t    break;\n \t\t}\n-\t      else if (alg_usable_p (candidate, memset))\n+\t      else if (alg_usable_p (candidate, memset, have_as))\n \t\t{\n \t\t  *noalign = algs->size[i].noalign;\n \t\t  return candidate;\n@@ -25805,7 +25828,7 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size,\n      choice in ix86_costs.  */\n   if ((TARGET_INLINE_ALL_STRINGOPS || TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n       && (algs->unknown_size == libcall\n-\t  || !alg_usable_p (algs->unknown_size, memset)))\n+\t  || !alg_usable_p (algs->unknown_size, memset, have_as)))\n     {\n       enum stringop_alg alg;\n \n@@ -25822,15 +25845,15 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size,\n       if (max <= 0)\n \tmax = 4096;\n       alg = decide_alg (count, max / 2, min_size, max_size, memset,\n-\t\t\tzero_memset, dynamic_check, noalign);\n+\t\t\tzero_memset, have_as, dynamic_check, noalign);\n       gcc_assert (*dynamic_check == -1);\n       if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n \t*dynamic_check = max;\n       else\n \tgcc_assert (alg != libcall);\n       return alg;\n     }\n-  return (alg_usable_p (algs->unknown_size, memset)\n+  return (alg_usable_p (algs->unknown_size, memset, have_as)\n \t  ? algs->unknown_size : libcall);\n }\n \n@@ -26036,6 +26059,7 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n   unsigned HOST_WIDE_INT max_size = -1;\n   unsigned HOST_WIDE_INT probable_max_size = -1;\n   bool misaligned_prologue_used = false;\n+  bool have_as;\n \n   if (CONST_INT_P (align_exp))\n     align = INTVAL (align_exp);\n@@ -26073,11 +26097,15 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n   if (count > (HOST_WIDE_INT_1U << 30))\n     return false;\n \n+  have_as = !ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (dst));\n+  if (!issetmem)\n+    have_as |= !ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (src));\n+\n   /* Step 0: Decide on preferred algorithm, desired alignment and\n      size of chunks to be copied by main loop.  */\n   alg = decide_alg (count, expected_size, min_size, probable_max_size,\n \t\t    issetmem,\n-\t\t    issetmem && val_exp == const0_rtx,\n+\t\t    issetmem && val_exp == const0_rtx, have_as,\n \t\t    &dynamic_check, &noalign);\n   if (alg == libcall)\n     return false;\n@@ -26691,6 +26719,9 @@ ix86_expand_strlen (rtx out, rtx src, rtx eoschar, rtx align)\n       /* Can't use this if the user has appropriated eax, ecx, or edi.  */\n       if (fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])\n         return false;\n+      /* Can't use this for non-default address spaces.  */\n+      if (!ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (src)))\n+\treturn false;\n \n       scratch2 = gen_reg_rtx (Pmode);\n       scratch3 = gen_reg_rtx (Pmode);"}, {"sha": "2cb94fec34ee3d0fead945dd920752865a7af0a0", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16734677674ae7f58f4339fa97a91411a347e5db/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16734677674ae7f58f4339fa97a91411a347e5db/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=16734677674ae7f58f4339fa97a91411a347e5db", "patch": "@@ -16159,6 +16159,10 @@\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"\"\n {\n+  /* Can't use this for non-default address spaces.  */\n+  if (!ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (operands[3])))\n+    FAIL;\n+\n   rtx adjust = GEN_INT (GET_MODE_SIZE (GET_MODE (operands[1])));\n \n   /* If .md ever supports :P for Pmode, these can be directly\n@@ -16199,7 +16203,8 @@\n \t(plus:P (match_dup 3)\n \t\t(const_int 8)))]\n   \"TARGET_64BIT\n-   && !(fixed_regs[SI_REG] || fixed_regs[DI_REG])\"\n+   && !(fixed_regs[SI_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^movsq\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"memory\" \"both\")\n@@ -16214,7 +16219,8 @@\n    (set (match_operand:P 1 \"register_operand\" \"=S\")\n \t(plus:P (match_dup 3)\n \t\t(const_int 4)))]\n-  \"!(fixed_regs[SI_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[SI_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^movs{l|d}\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"memory\" \"both\")\n@@ -16229,7 +16235,8 @@\n    (set (match_operand:P 1 \"register_operand\" \"=S\")\n \t(plus:P (match_dup 3)\n \t\t(const_int 2)))]\n-  \"!(fixed_regs[SI_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[SI_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^movsw\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"memory\" \"both\")\n@@ -16245,7 +16252,8 @@\n \t(plus:P (match_dup 3)\n \t\t(const_int 1)))]\n   \"!(fixed_regs[SI_REG] || fixed_regs[DI_REG])\"\n-  \"%^movsb\"\n+  \"%^movsb\n+   && ix86_check_no_addr_space (insn)\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"memory\" \"both\")\n    (set (attr \"prefix_rex\")\n@@ -16280,7 +16288,8 @@\n \t(mem:BLK (match_dup 4)))\n    (use (match_dup 5))]\n   \"TARGET_64BIT\n-   && !(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\"\n+   && !(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^rep{%;} movsq\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"prefix_rep\" \"1\")\n@@ -16299,7 +16308,8 @@\n    (set (mem:BLK (match_dup 3))\n \t(mem:BLK (match_dup 4)))\n    (use (match_dup 5))]\n-  \"!(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^rep{%;} movs{l|d}\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"prefix_rep\" \"1\")\n@@ -16316,7 +16326,8 @@\n    (set (mem:BLK (match_dup 3))\n \t(mem:BLK (match_dup 4)))\n    (use (match_dup 5))]\n-  \"!(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^rep{%;} movsb\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"prefix_rep\" \"1\")\n@@ -16356,6 +16367,10 @@\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"\"\n {\n+  /* Can't use this for non-default address spaces.  */\n+  if (!ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (operands[1])))\n+    FAIL;\n+\n   if (GET_MODE (operands[1]) != GET_MODE (operands[2]))\n     operands[1] = adjust_address_nv (operands[1], GET_MODE (operands[2]), 0);\n \n@@ -16391,7 +16406,8 @@\n \t\t(const_int 8)))\n    (unspec [(const_int 0)] UNSPEC_STOS)]\n   \"TARGET_64BIT\n-   && !(fixed_regs[AX_REG] || fixed_regs[DI_REG])\"\n+   && !(fixed_regs[AX_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^stosq\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"memory\" \"store\")\n@@ -16404,7 +16420,8 @@\n \t(plus:P (match_dup 1)\n \t\t(const_int 4)))\n    (unspec [(const_int 0)] UNSPEC_STOS)]\n-  \"!(fixed_regs[AX_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[AX_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^stos{l|d}\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"memory\" \"store\")\n@@ -16417,7 +16434,8 @@\n \t(plus:P (match_dup 1)\n \t\t(const_int 2)))\n    (unspec [(const_int 0)] UNSPEC_STOS)]\n-  \"!(fixed_regs[AX_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[AX_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^stosw\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"memory\" \"store\")\n@@ -16430,7 +16448,8 @@\n \t(plus:P (match_dup 1)\n \t\t(const_int 1)))\n    (unspec [(const_int 0)] UNSPEC_STOS)]\n-  \"!(fixed_regs[AX_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[AX_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^stosb\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"memory\" \"store\")\n@@ -16462,7 +16481,8 @@\n    (use (match_operand:DI 2 \"register_operand\" \"a\"))\n    (use (match_dup 4))]\n   \"TARGET_64BIT\n-   && !(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])\"\n+   && !(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^rep{%;} stosq\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"prefix_rep\" \"1\")\n@@ -16479,7 +16499,8 @@\n \t(const_int 0))\n    (use (match_operand:SI 2 \"register_operand\" \"a\"))\n    (use (match_dup 4))]\n-  \"!(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^rep{%;} stos{l|d}\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"prefix_rep\" \"1\")\n@@ -16495,7 +16516,8 @@\n \t(const_int 0))\n    (use (match_operand:QI 2 \"register_operand\" \"a\"))\n    (use (match_dup 4))]\n-  \"!(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^rep{%;} stosb\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"prefix_rep\" \"1\")\n@@ -16616,7 +16638,8 @@\n    (clobber (match_operand:P 0 \"register_operand\" \"=S\"))\n    (clobber (match_operand:P 1 \"register_operand\" \"=D\"))\n    (clobber (match_operand:P 2 \"register_operand\" \"=c\"))]\n-  \"!(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^repz{%;} cmpsb\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"mode\" \"QI\")\n@@ -16656,7 +16679,8 @@\n    (clobber (match_operand:P 0 \"register_operand\" \"=S\"))\n    (clobber (match_operand:P 1 \"register_operand\" \"=D\"))\n    (clobber (match_operand:P 2 \"register_operand\" \"=c\"))]\n-  \"!(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^repz{%;} cmpsb\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"mode\" \"QI\")\n@@ -16697,7 +16721,8 @@\n \t\t   (match_operand:P 4 \"register_operand\" \"0\")] UNSPEC_SCAS))\n    (clobber (match_operand:P 1 \"register_operand\" \"=D\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])\"\n+  \"!(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])\n+   && ix86_check_no_addr_space (insn)\"\n   \"%^repnz{%;} scasb\"\n   [(set_attr \"type\" \"str\")\n    (set_attr \"mode\" \"QI\")"}]}