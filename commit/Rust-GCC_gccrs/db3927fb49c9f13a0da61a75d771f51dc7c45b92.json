{"sha": "db3927fb49c9f13a0da61a75d771f51dc7c45b92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIzOTI3ZmI0OWM5ZjEzYTBkYTYxYTc1ZDc3MWY1MWRjN2M0NWI5Mg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2009-07-16T22:29:52Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2009-07-16T22:29:52Z"}, "message": "re PR c/40435 (Revision 148442 caused many regressions on trunk)\n\n2009-07-17  Aldy Hernandez  <aldyh@redhat.com>\n\t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR 40435 \n\t* tree-complex.c, tree-loop-distribution.c,\n\ttree.c, tree.h, builtins.c, fold-const.c, omp-low.c,\n\tcgraphunit.c, tree-ssa-ccp.c, tree-ssa-dom.c,\n\tgimple-low.c, expr.c, tree-ssa-ifcombine.c, c-decl.c,\n\tstor-layout.c, tree-if-conv.c, c-typeck.c,\n\tgimplify.c, calls.c, tree-sra.c, tree-mudflap.c,\n\ttree-ssa-copy.c, tree-ssa-forwprop.c, c-convert.c, c-omp.c,\n\tvarasm.c, tree-inline.c, c-common.c,\n\tc-common.h, gimple.c, tree-switch-conversion.c, gimple.h,\n\ttree-cfg.c, c-parser.c, convert.c: Add location\n\targument to fold_{unary,binary,ternary}, fold_build[123],\n\tbuild_call_expr, build_size_arg, build_fold_addr_expr,\n\tbuild_call_array, non_lvalue, size_diffop,\n\tfold_build1_initializer, fold_build2_initializer,\n\tfold_build3_initializer, fold_build_call_array,\n\tfold_build_call_array_initializer, fold_single_bit_test,\n\tomit_one_operand, omit_two_operands, invert_truthvalue,\n\tfold_truth_not_expr, build_fold_indirect_ref, fold_indirect_ref,\n\tcombine_comparisons, fold_builtin_*, fold_call_expr,\n\tbuild_range_check, maybe_fold_offset_to_address, round_up,\n\tround_down.\nobjc/\n\t* objc-act.c: Add location argument to all calls to\n\tbuild_fold_addr_expr.\ntestsuite/\n\t* gcc.dg/pr36902.c: Add column info.\n\t* g++.dg/gcov/gcov-2.C: Change count for definition.\ncp/\n\t* typeck.c, init.c, class.c, method.c, rtti.c, except.c, error.c,\n\ttree.c, cp-gimplify.c, cxx-pretty-print.c, pt.c, semantics.c,\n\tcall.c, cvt.c, mangle.c: Add location argument to\n\tfold_{unary,binary,ternary}, fold_build[123], build_call_expr,\n\tbuild_size_arg, build_fold_addr_expr, build_call_array,\n\tnon_lvalue, size_diffop, fold_build1_initializer,\n\tfold_build2_initializer, fold_build3_initializer,\n\tfold_build_call_array, fold_build_call_array_initializer,\n\tfold_single_bit_test, omit_one_operand, omit_two_operands,\n\tinvert_truthvalue, fold_truth_not_expr, build_fold_indirect_ref,\n\tfold_indirect_ref, combine_comparisons, fold_builtin_*,\n\tfold_call_expr, build_range_check, maybe_fold_offset_to_address,\n\tround_up, round_down.\nfortran/\n\t* trans-expr.c, trans-array.c, trans-openmp.c, trans-stmt.c,\n\ttrans.c, trans-io.c, trans-decl.c, trans-intrinsic.c: Add location\n\targument to fold_{unary,binary,ternary}, fold_build[123],\n\tbuild_call_expr, build_size_arg, build_fold_addr_expr,\n\tbuild_call_array, non_lvalue, size_diffop,\n\tfold_build1_initializer, fold_build2_initializer,\n\tfold_build3_initializer, fold_build_call_array,\n\tfold_build_call_array_initializer, fold_single_bit_test,\n\tomit_one_operand, omit_two_operands, invert_truthvalue,\n\tfold_truth_not_expr, build_fold_indirect_ref, fold_indirect_ref,\n\tcombine_comparisons, fold_builtin_*, fold_call_expr,\n\tbuild_range_check, maybe_fold_offset_to_address, round_up,\n\tround_down.\n\nCo-Authored-By: Manuel L\u00f3pez-Ib\u00e1\u00f1ez <manu@gcc.gnu.org>\n\nFrom-SVN: r149722", "tree": {"sha": "e4de0ffc0a0ca77f35b03bf9e8a248a4b5735f6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4de0ffc0a0ca77f35b03bf9e8a248a4b5735f6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db3927fb49c9f13a0da61a75d771f51dc7c45b92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3927fb49c9f13a0da61a75d771f51dc7c45b92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db3927fb49c9f13a0da61a75d771f51dc7c45b92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3927fb49c9f13a0da61a75d771f51dc7c45b92/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c32097d8b4fb21997c571cf6520431fa7d06090f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c32097d8b4fb21997c571cf6520431fa7d06090f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c32097d8b4fb21997c571cf6520431fa7d06090f"}], "stats": {"total": 6151, "additions": 3546, "deletions": 2605}, "files": [{"sha": "c6eb42afe211abf84fe92343bd57cf5c6aedc978", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1,3 +1,27 @@\n+2009-07-17  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR 40435 \n+\t* tree-complex.c, tree-loop-distribution.c, tree.c, tree.h,\n+\tbuiltins.c, fold-const.c, omp-low.c, cgraphunit.c, tree-ssa-ccp.c,\n+\ttree-ssa-dom.c, gimple-low.c, expr.c, tree-ssa-ifcombine.c,\n+\tc-decl.c, stor-layout.c, tree-if-conv.c, c-typeck.c, gimplify.c,\n+\tcalls.c, tree-sra.c, tree-mudflap.c, tree-ssa-copy.c,\n+\ttree-ssa-forwprop.c, c-convert.c, c-omp.c, varasm.c,\n+\ttree-inline.c, c-common.c, c-common.h, gimple.c,\n+\ttree-switch-conversion.c, gimple.h, tree-cfg.c, c-parser.c,\n+\tconvert.c: Add location argument to fold_{unary,binary,ternary},\n+\tfold_build[123], build_call_expr, build_size_arg,\n+\tbuild_fold_addr_expr, build_call_array, non_lvalue, size_diffop,\n+\tfold_build1_initializer, fold_build2_initializer,\n+\tfold_build3_initializer, fold_build_call_array,\n+\tfold_build_call_array_initializer, fold_single_bit_test,\n+\tomit_one_operand, omit_two_operands, invert_truthvalue,\n+\tfold_truth_not_expr, build_fold_indirect_ref, fold_indirect_ref,\n+\tcombine_comparisons, fold_builtin_*, fold_call_expr,\n+\tbuild_range_check, maybe_fold_offset_to_address, round_up,\n+\tround_down.\n+\n 2009-07-16  Jason Merrill  <jason@redhat.com>\n \n \tPR libstdc++/37907"}, {"sha": "5a474cd0eaa1690100bd91650ab1127694027c42", "filename": "gcc/builtins.c", "status": "modified", "additions": 693, "deletions": 600, "changes": 1293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92"}, {"sha": "3aa8ed95851a51ee6c91f6fdd05c7cd80430535b", "filename": "gcc/c-common.c", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1086,6 +1086,7 @@ c_fully_fold (tree expr, bool in_init, bool *maybe_const)\n   tree eptype = NULL_TREE;\n   bool dummy = true;\n   bool maybe_const_itself = true;\n+  location_t loc = EXPR_LOCATION (expr);\n \n   /* This function is not relevant to C++ because C++ folds while\n      parsing, and may need changes to be correct for C++ when C++\n@@ -1103,7 +1104,7 @@ c_fully_fold (tree expr, bool in_init, bool *maybe_const)\n   ret = c_fully_fold_internal (expr, in_init, maybe_const,\n \t\t\t       &maybe_const_itself);\n   if (eptype)\n-    ret = fold_convert (eptype, ret);\n+    ret = fold_convert_loc (loc, eptype, ret);\n   *maybe_const &= maybe_const_itself;\n   return ret;\n }\n@@ -1300,8 +1301,8 @@ c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,\n       op1 = decl_constant_value_for_optimization (op1);\n       if (op0 != orig_op0 || op1 != orig_op1 || in_init)\n \tret = in_init\n-\t  ? fold_build2_initializer (code, TREE_TYPE (expr), op0, op1)\n-\t  : fold_build2 (code, TREE_TYPE (expr), op0, op1);\n+\t  ? fold_build2_initializer_loc (loc, code, TREE_TYPE (expr), op0, op1)\n+\t  : fold_build2_loc (loc, code, TREE_TYPE (expr), op0, op1);\n       else\n \tret = fold (expr);\n       goto out;\n@@ -1326,8 +1327,8 @@ c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,\n \top0 = decl_constant_value_for_optimization (op0);\n       if (op0 != orig_op0 || in_init)\n \tret = in_init\n-\t  ? fold_build1_initializer (code, TREE_TYPE (expr), op0)\n-\t  : fold_build1 (code, TREE_TYPE (expr), op0);\n+\t  ? fold_build1_initializer_loc (loc, code, TREE_TYPE (expr), op0)\n+\t  : fold_build1_loc (loc, code, TREE_TYPE (expr), op0);\n       else\n \tret = fold (expr);\n       if (code == INDIRECT_REF\n@@ -1350,8 +1351,8 @@ c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,\n       op1 = c_fully_fold_internal (op1, in_init, &op1_const, &op1_const_self);\n       if (op0 != orig_op0 || op1 != orig_op1 || in_init)\n \tret = in_init\n-\t  ? fold_build2_initializer (code, TREE_TYPE (expr), op0, op1)\n-\t  : fold_build2 (code, TREE_TYPE (expr), op0, op1);\n+\t  ? fold_build2_initializer_loc (loc, code, TREE_TYPE (expr), op0, op1)\n+\t  : fold_build2_loc (loc, code, TREE_TYPE (expr), op0, op1);\n       else\n \tret = fold (expr);\n       *maybe_const_operands &= op0_const;\n@@ -1379,7 +1380,7 @@ c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,\n       op1 = c_fully_fold_internal (op1, in_init, &op1_const, &op1_const_self);\n       op2 = c_fully_fold_internal (op2, in_init, &op2_const, &op2_const_self);\n       if (op0 != orig_op0 || op1 != orig_op1 || op2 != orig_op2)\n-\tret = fold_build3 (code, TREE_TYPE (expr), op0, op1, op2);\n+\tret = fold_build3_loc (loc, code, TREE_TYPE (expr), op0, op1, op2);\n       else\n \tret = fold (expr);\n       *maybe_const_operands &= op0_const;\n@@ -1620,7 +1621,8 @@ warn_logical_operator (location_t location, enum tree_code code, tree type,\n   if (lhs && rhs && operand_equal_p (lhs, rhs, 0)\n       && merge_ranges (&in_p, &low, &high, in0_p, low0, high0,\n \t\t       in1_p, low1, high1)\n-      && 0 != (tem = build_range_check (type, lhs, in_p, low, high)))\n+      && 0 != (tem = build_range_check (UNKNOWN_LOCATION,\n+\t\t\t\t\ttype, lhs, in_p, low, high)))\n     {\n       if (TREE_CODE (tem) != INTEGER_CST)\n \treturn;\n@@ -3658,7 +3660,8 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n    of pointer PTROP and integer INTOP.  */\n \n tree\n-pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n+pointer_int_sum (location_t loc, enum tree_code resultcode,\n+\t\t tree ptrop, tree intop)\n {\n   tree size_exp, ret;\n \n@@ -3667,19 +3670,19 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n \n   if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n     {\n-      pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+      pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t       \"pointer of type %<void *%> used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE)\n     {\n-      pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+      pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t       \"pointer to a function used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == METHOD_TYPE)\n     {\n-      pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+      pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t       \"pointer to member function used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n@@ -3734,15 +3737,15 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n      Do this multiplication as signed, then convert to the appropriate\n      type for the pointer operation.  */\n   intop = convert (sizetype,\n-\t\t   build_binary_op (EXPR_LOCATION (intop),\n+\t\t   build_binary_op (loc,\n \t\t\t\t    MULT_EXPR, intop,\n \t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n \n   /* Create the sum or difference.  */\n   if (resultcode == MINUS_EXPR)\n-    intop = fold_build1 (NEGATE_EXPR, sizetype, intop);\n+    intop = fold_build1_loc (loc, NEGATE_EXPR, sizetype, intop);\n \n-  ret = fold_build2 (POINTER_PLUS_EXPR, result_type, ptrop, intop);\n+  ret = fold_build2_loc (loc, POINTER_PLUS_EXPR, result_type, ptrop, intop);\n \n   fold_undefer_and_ignore_overflow_warnings ();\n \n@@ -3925,7 +3928,7 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n       if (c_dialect_cxx ())\n \t{\n-\t  expr = fold_build3 (COND_EXPR, truthvalue_type_node,\n+\t  expr = fold_build3_loc (location, COND_EXPR, truthvalue_type_node,\n \t\t\t      TREE_OPERAND (expr, 0),\n \t\t\t      c_common_truthvalue_conversion (location,\n \t\t\t\t\t\t\t      TREE_OPERAND (expr,\n@@ -4290,9 +4293,9 @@ c_sizeof_or_alignof_type (location_t loc,\n     {\n       if (is_sizeof)\n \t/* Convert in case a char is more than one unit.  */\n-\tvalue = size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n-\t\t\t    size_int (TYPE_PRECISION (char_type_node)\n-\t\t\t\t      / BITS_PER_UNIT));\n+\tvalue = size_binop_loc (loc, CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t\t\tsize_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t\t  / BITS_PER_UNIT));\n       else\n \tvalue = size_int (TYPE_ALIGN_UNIT (type));\n     }\n@@ -4301,7 +4304,7 @@ c_sizeof_or_alignof_type (location_t loc,\n      TYPE_IS_SIZETYPE means that certain things (like overflow) will\n      never happen.  However, this node should really have type\n      `size_t', which is just a typedef for an ordinary integer type.  */\n-  value = fold_convert (size_type_node, value);\n+  value = fold_convert_loc (loc, size_type_node, value);\n   gcc_assert (!TYPE_IS_SIZETYPE (TREE_TYPE (value)));\n \n   return value;\n@@ -4352,7 +4355,7 @@ c_alignof_expr (location_t loc, tree expr)\n   else\n     return c_alignof (loc, TREE_TYPE (expr));\n \n-  return fold_convert (size_type_node, t);\n+  return fold_convert_loc (loc, size_type_node, t);\n }\n \f\n /* Handle C and C++ default attributes.  */\n@@ -5628,11 +5631,11 @@ boolean_increment (enum tree_code code, tree arg)\n       break;\n     case PREDECREMENT_EXPR:\n       val = build2 (MODIFY_EXPR, TREE_TYPE (arg), arg,\n-\t\t    invert_truthvalue (arg));\n+\t\t    invert_truthvalue_loc (input_location, arg));\n       break;\n     case POSTDECREMENT_EXPR:\n       val = build2 (MODIFY_EXPR, TREE_TYPE (arg), arg,\n-\t\t    invert_truthvalue (arg));\n+\t\t    invert_truthvalue_loc (input_location, arg));\n       arg = save_expr (arg);\n       val = build2 (COMPOUND_EXPR, TREE_TYPE (arg), val, arg);\n       val = build2 (COMPOUND_EXPR, TREE_TYPE (arg), arg, val);\n@@ -8357,9 +8360,10 @@ fold_offsetof_1 (tree expr, tree stop_ref)\n \t\t \"member %qD\", t);\n \t  return error_mark_node;\n \t}\n-      off = size_binop (PLUS_EXPR, DECL_FIELD_OFFSET (t),\n-\t\t\tsize_int (tree_low_cst (DECL_FIELD_BIT_OFFSET (t), 1)\n-\t\t\t\t  / BITS_PER_UNIT));\n+      off = size_binop_loc (input_location, PLUS_EXPR, DECL_FIELD_OFFSET (t),\n+\t\t\t    size_int (tree_low_cst (DECL_FIELD_BIT_OFFSET (t),\n+\t\t\t\t\t\t    1)\n+\t\t\t\t      / BITS_PER_UNIT));\n       break;\n \n     case ARRAY_REF:\n@@ -8371,7 +8375,7 @@ fold_offsetof_1 (tree expr, tree stop_ref)\n       if (TREE_CODE (t) == INTEGER_CST && tree_int_cst_sgn (t) < 0)\n \t{\n \t  code = MINUS_EXPR;\n-\t  t = fold_build1 (NEGATE_EXPR, TREE_TYPE (t), t);\n+\t  t = fold_build1_loc (input_location, NEGATE_EXPR, TREE_TYPE (t), t);\n \t}\n       t = convert (sizetype, t);\n       off = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (TREE_TYPE (expr)), t);\n@@ -8464,9 +8468,9 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t      bool fold_p = false;\n \n \t      if (VEC_index (constructor_elt, v, 0)->index)\n-\t\tmaxindex = fold_convert (sizetype,\n-\t\t\t\t\t VEC_index (constructor_elt,\n-\t\t\t\t\t\t    v, 0)->index);\n+\t\tmaxindex = fold_convert_loc (input_location, sizetype,\n+\t\t\t\t\t     VEC_index (constructor_elt,\n+\t\t\t\t\t\t\tv, 0)->index);\n \t      curindex = maxindex;\n \n \t      for (cnt = 1;\n@@ -8480,7 +8484,8 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t\t    {\n \t\t      if (fold_p)\n \t\t        curindex = fold_convert (sizetype, curindex);\n-\t\t      curindex = size_binop (PLUS_EXPR, curindex, size_one_node);\n+\t\t      curindex = size_binop (PLUS_EXPR, curindex,\n+\t\t\t\t\t     size_one_node);\n \t\t    }\n \t\t  if (tree_int_cst_lt (maxindex, curindex))\n \t\t    maxindex = curindex, fold_p = curfold_p;"}, {"sha": "21d3648c70ba09210d8ab34ad3c451093d219222", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -830,7 +830,7 @@ extern tree shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwis\n    and, if so, perhaps change them both back to their original type.  */\n extern tree shorten_compare (tree *, tree *, tree *, enum tree_code *);\n \n-extern tree pointer_int_sum (enum tree_code, tree, tree);\n+extern tree pointer_int_sum (location_t, enum tree_code, tree, tree);\n \n /* Add qualifiers to a type, in the fashion for C.  */\n extern tree c_build_qualified_type (tree, int);"}, {"sha": "09638d5b151cc45bb8930e78b2dd82e844b8da8c", "filename": "gcc/c-convert.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -71,6 +71,7 @@ convert (tree type, tree expr)\n   enum tree_code code = TREE_CODE (type);\n   const char *invalid_conv_diag;\n   tree ret;\n+  location_t loc = EXPR_LOCATION (expr);\n \n   if (type == error_mark_node\n       || expr == error_mark_node\n@@ -93,7 +94,7 @@ convert (tree type, tree expr)\n   STRIP_TYPE_NOPS (e);\n \n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n-    return fold_convert (type, expr);\n+    return fold_convert_loc (loc, type, expr);\n   if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n     return error_mark_node;\n   if (TREE_CODE (TREE_TYPE (expr)) == VOID_TYPE)\n@@ -105,16 +106,16 @@ convert (tree type, tree expr)\n   switch (code)\n     {\n     case VOID_TYPE:\n-      return fold_convert (type, e);\n+      return fold_convert_loc (loc, type, e);\n \n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n       ret = convert_to_integer (type, e);\n       goto maybe_fold;\n \n     case BOOLEAN_TYPE:\n-      return fold_convert \n-\t(type, c_objc_common_truthvalue_conversion (input_location, expr));\n+      return fold_convert_loc\n+\t(loc, type, c_objc_common_truthvalue_conversion (input_location, expr));\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:"}, {"sha": "7ed646c257bb16e523607497e1c939e49ad78925", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -5224,10 +5224,10 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t       - 1.  Do the calculation in index_type, so that\n \t\t       if it is a variable the computations will be\n \t\t       done in the proper mode.  */\n-\t\t    itype = fold_build2 (MINUS_EXPR, index_type,\n-\t\t\t\t\t convert (index_type, size),\n-\t\t\t\t\t convert (index_type,\n-\t\t\t\t\t\t  size_one_node));\n+\t\t    itype = fold_build2_loc (loc, MINUS_EXPR, index_type,\n+\t\t\t\t\t     convert (index_type, size),\n+\t\t\t\t\t     convert (index_type,\n+\t\t\t\t\t\t      size_one_node));\n \n \t\t    /* If that overflowed, the array is too big.  ???\n \t\t       While a size of INT_MAX+1 technically shouldn't"}, {"sha": "b949501d52b0750228788a9a7753e22ea6ca2a29", "filename": "gcc/c-omp.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-omp.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -81,8 +81,7 @@ c_finish_omp_barrier (location_t loc)\n   tree x;\n \n   x = built_in_decls[BUILT_IN_GOMP_BARRIER];\n-  x = build_call_expr (x, 0);\n-  SET_EXPR_LOCATION (x, loc);\n+  x = build_call_expr_loc (loc, x, 0);\n   add_stmt (x);\n }\n \n@@ -96,8 +95,7 @@ c_finish_omp_taskwait (location_t loc)\n   tree x;\n \n   x = built_in_decls[BUILT_IN_GOMP_TASKWAIT];\n-  x = build_call_expr (x, 0);\n-  SET_EXPR_LOCATION (x, loc);\n+  x = build_call_expr_loc (loc, x, 0);\n   add_stmt (x);\n }\n \n@@ -175,8 +173,7 @@ c_finish_omp_flush (location_t loc)\n   tree x;\n \n   x = built_in_decls[BUILT_IN_SYNCHRONIZE];\n-  x = build_call_expr (x, 0);\n-  SET_EXPR_LOCATION (x, loc);\n+  x = build_call_expr_loc (loc, x, 0);\n   add_stmt (x);\n }\n \n@@ -185,7 +182,7 @@ c_finish_omp_flush (location_t loc)\n    Helper function for c_finish_omp_for.  */\n \n static tree\n-check_omp_for_incr_expr (tree exp, tree decl)\n+check_omp_for_incr_expr (location_t loc, tree exp, tree decl)\n {\n   tree t;\n \n@@ -199,22 +196,25 @@ check_omp_for_incr_expr (tree exp, tree decl)\n   switch (TREE_CODE (exp))\n     {\n     CASE_CONVERT:\n-      t = check_omp_for_incr_expr (TREE_OPERAND (exp, 0), decl);\n+      t = check_omp_for_incr_expr (loc, TREE_OPERAND (exp, 0), decl);\n       if (t != error_mark_node)\n-        return fold_convert (TREE_TYPE (exp), t);\n+        return fold_convert_loc (loc, TREE_TYPE (exp), t);\n       break;\n     case MINUS_EXPR:\n-      t = check_omp_for_incr_expr (TREE_OPERAND (exp, 0), decl);\n+      t = check_omp_for_incr_expr (loc, TREE_OPERAND (exp, 0), decl);\n       if (t != error_mark_node)\n-        return fold_build2 (MINUS_EXPR, TREE_TYPE (exp), t, TREE_OPERAND (exp, 1));\n+        return fold_build2_loc (loc, MINUS_EXPR,\n+\t\t\t    TREE_TYPE (exp), t, TREE_OPERAND (exp, 1));\n       break;\n     case PLUS_EXPR:\n-      t = check_omp_for_incr_expr (TREE_OPERAND (exp, 0), decl);\n+      t = check_omp_for_incr_expr (loc, TREE_OPERAND (exp, 0), decl);\n       if (t != error_mark_node)\n-        return fold_build2 (PLUS_EXPR, TREE_TYPE (exp), t, TREE_OPERAND (exp, 1));\n-      t = check_omp_for_incr_expr (TREE_OPERAND (exp, 1), decl);\n+        return fold_build2_loc (loc, PLUS_EXPR,\n+\t\t\t    TREE_TYPE (exp), t, TREE_OPERAND (exp, 1));\n+      t = check_omp_for_incr_expr (loc, TREE_OPERAND (exp, 1), decl);\n       if (t != error_mark_node)\n-        return fold_build2 (PLUS_EXPR, TREE_TYPE (exp), TREE_OPERAND (exp, 0), t);\n+        return fold_build2_loc (loc, PLUS_EXPR,\n+\t\t\t    TREE_TYPE (exp), TREE_OPERAND (exp, 0), t);\n       break;\n     default:\n       break;\n@@ -322,15 +322,15 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \t\t{\n \t\t  TREE_OPERAND (cond, 0) = TREE_OPERAND (op0, 0);\n \t\t  TREE_OPERAND (cond, 1)\n-\t\t    = fold_build1 (NOP_EXPR, TREE_TYPE (decl),\n+\t\t    = fold_build1_loc (elocus, NOP_EXPR, TREE_TYPE (decl),\n \t\t\t\t   TREE_OPERAND (cond, 1));\n \t\t}\n \t      else if (TREE_CODE (op1) == NOP_EXPR\n \t\t       && decl == TREE_OPERAND (op1, 0))\n \t\t{\n \t\t  TREE_OPERAND (cond, 1) = TREE_OPERAND (op1, 0);\n \t\t  TREE_OPERAND (cond, 0)\n-\t\t    = fold_build1 (NOP_EXPR, TREE_TYPE (decl),\n+\t\t    = fold_build1_loc (elocus, NOP_EXPR, TREE_TYPE (decl),\n \t\t\t\t   TREE_OPERAND (cond, 0));\n \t\t}\n \n@@ -396,11 +396,12 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \t      if (POINTER_TYPE_P (TREE_TYPE (decl))\n \t\t  && TREE_OPERAND (incr, 1))\n \t\t{\n-\t\t  tree t = fold_convert (sizetype, TREE_OPERAND (incr, 1));\n+\t\t  tree t = fold_convert_loc (elocus,\n+\t\t\t\t\t     sizetype, TREE_OPERAND (incr, 1));\n \n \t\t  if (TREE_CODE (incr) == POSTDECREMENT_EXPR\n \t\t      || TREE_CODE (incr) == PREDECREMENT_EXPR)\n-\t\t    t = fold_build1 (NEGATE_EXPR, sizetype, t);\n+\t\t    t = fold_build1_loc (elocus, NEGATE_EXPR, sizetype, t);\n \t\t  t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (decl), decl, t);\n \t\t  incr = build2 (MODIFY_EXPR, void_type_node, decl, t);\n \t\t}\n@@ -422,7 +423,8 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \t\tincr_ok = true;\n \t      else\n \t\t{\n-\t\t  tree t = check_omp_for_incr_expr (TREE_OPERAND (incr, 1),\n+\t\t  tree t = check_omp_for_incr_expr (elocus,\n+\t\t\t\t\t\t    TREE_OPERAND (incr, 1),\n \t\t\t\t\t\t    decl);\n \t\t  if (t != error_mark_node)\n \t\t    {"}, {"sha": "43b0c8ce38cf13f7c3ee9c0735f04b854dfb3662", "filename": "gcc/c-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -7338,7 +7338,7 @@ c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n \t}\n \n       /* Attempt to statically determine when the number isn't positive.  */\n-      c = fold_build2 (LE_EXPR, boolean_type_node, t,\n+      c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,\n \t\t       build_int_cst (TREE_TYPE (t), 0));\n       if (CAN_HAVE_LOCATION_P (c))\n \tSET_EXPR_LOCATION (c, expr_loc);"}, {"sha": "42bebe3543cbc04a8bd091a9c7d604317ee7d1ef", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 62, "deletions": 51, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -86,7 +86,7 @@ static int type_lists_compatible_p (const_tree, const_tree, bool *);\n static tree lookup_field (tree, tree);\n static int convert_arguments (tree, VEC(tree,gc) *, VEC(tree,gc) *, tree,\n \t\t\t      tree);\n-static tree pointer_diff (tree, tree);\n+static tree pointer_diff (location_t, tree, tree);\n static tree convert_for_assignment (location_t, tree, tree, tree,\n \t\t\t\t    enum impl_conv, bool, tree, tree, int);\n static tree valid_compound_expr_initializer (tree, tree);\n@@ -1625,9 +1625,9 @@ c_size_in_bytes (const_tree type)\n     }\n \n   /* Convert in case a char is more than one unit.  */\n-  return size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n-\t\t     size_int (TYPE_PRECISION (char_type_node)\n-\t\t\t       / BITS_PER_UNIT));\n+  return size_binop_loc (input_location, CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t\t size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t   / BITS_PER_UNIT));\n }\n \f\n /* Return either DECL or its known constant value (if it has one).  */\n@@ -2586,7 +2586,7 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n       if (VOID_TYPE_P (return_type))\n \t{\n \t  if (TYPE_QUALS (return_type) != TYPE_UNQUALIFIED)\n-\t    pedwarn (input_location, 0,\n+\t    pedwarn (loc, 0,\n \t\t     \"function with qualified void return type called\");\n \t  return trap;\n \t}\n@@ -2599,7 +2599,7 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n \t\t\t\t\t  build_constructor (return_type, 0),\n \t\t\t\t\t  false);\n \t  else\n-\t    rhs = fold_convert (return_type, integer_zero_node);\n+\t    rhs = fold_convert_loc (loc, return_type, integer_zero_node);\n \n \t  return require_complete_type (build2 (COMPOUND_EXPR, return_type,\n \t\t\t\t\t\ttrap, rhs));\n@@ -2623,23 +2623,24 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n       && !strncmp (IDENTIFIER_POINTER (name), \"__builtin_\", 10))\n     {\n       if (require_constant_value)\n-\tresult = fold_build_call_array_initializer (TREE_TYPE (fntype),\n-\t\t\t\t\t\t    function, nargs, argarray);\n+\tresult = \n+\t  fold_build_call_array_initializer_loc (loc, TREE_TYPE (fntype),\n+\t\t\t\t\t\t function, nargs, argarray);\n       else\n-\tresult = fold_build_call_array (TREE_TYPE (fntype),\n-\t\t\t\t\tfunction, nargs, argarray);\n+\tresult = fold_build_call_array_loc (loc, TREE_TYPE (fntype),\n+\t\t\t\t\t    function, nargs, argarray);\n       if (TREE_CODE (result) == NOP_EXPR\n \t  && TREE_CODE (TREE_OPERAND (result, 0)) == INTEGER_CST)\n \tSTRIP_TYPE_NOPS (result);\n     }\n   else\n-    result = build_call_array (TREE_TYPE (fntype),\n-\t\t\t       function, nargs, argarray);\n+    result = build_call_array_loc (loc, TREE_TYPE (fntype),\n+\t\t\t\t   function, nargs, argarray);\n \n   if (VOID_TYPE_P (TREE_TYPE (result)))\n     {\n       if (TYPE_QUALS (TREE_TYPE (result)) != TYPE_UNQUALIFIED)\n-\tpedwarn (input_location, 0,\n+\tpedwarn (loc, 0,\n \t\t \"function with qualified void return type called\");\n       return result;\n     }\n@@ -3058,7 +3059,7 @@ parser_build_binary_op (location_t location, enum tree_code code,\n    The resulting tree has type int.  */\n \n static tree\n-pointer_diff (tree op0, tree op1)\n+pointer_diff (location_t loc, tree op0, tree op1)\n {\n   tree restype = ptrdiff_type_node;\n \n@@ -3067,10 +3068,10 @@ pointer_diff (tree op0, tree op1)\n   tree orig_op1 = op1;\n \n   if (TREE_CODE (target_type) == VOID_TYPE)\n-    pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+    pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t     \"pointer of type %<void *%> used in subtraction\");\n   if (TREE_CODE (target_type) == FUNCTION_TYPE)\n-    pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+    pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t     \"pointer to a function used in subtraction\");\n \n   /* If the conversion to ptrdiff_type does anything like widening or\n@@ -3122,18 +3123,19 @@ pointer_diff (tree op0, tree op1)\n      Do not do default conversions on the minus operator\n      in case restype is a short type.  */\n \n-  op0 = build_binary_op (input_location,\n+  op0 = build_binary_op (loc,\n \t\t\t MINUS_EXPR, convert (restype, op0),\n \t\t\t convert (restype, op1), 0);\n   /* This generates an error if op1 is pointer to incomplete type.  */\n   if (!COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (TREE_TYPE (orig_op1))))\n-    error (\"arithmetic on pointer to an incomplete type\");\n+    error_at (loc, \"arithmetic on pointer to an incomplete type\");\n \n   /* This generates an error if op0 is pointer to incomplete type.  */\n   op1 = c_size_in_bytes (target_type);\n \n   /* Divide by the size, in easiest possible way.  */\n-  return fold_build2 (EXACT_DIV_EXPR, restype, op0, convert (restype, op1));\n+  return fold_build2_loc (loc, EXACT_DIV_EXPR, restype,\n+\t\t\t  op0, convert (restype, op1));\n }\n \f\n /* Construct and perhaps optimize a tree representation\n@@ -3203,7 +3205,7 @@ build_unary_op (location_t location,\n \t}\n       else if (!noconvert)\n \targ = default_conversion (arg);\n-      arg = non_lvalue (arg);\n+      arg = non_lvalue_loc (location, arg);\n       break;\n \n     case NEGATE_EXPR:\n@@ -3274,7 +3276,7 @@ build_unary_op (location_t location,\n \t  return error_mark_node;\n \t}\n       arg = c_objc_common_truthvalue_conversion (location, arg);\n-      ret = invert_truthvalue (arg);\n+      ret = invert_truthvalue_loc (location, arg);\n       /* If the TRUTH_NOT_EXPR has been folded, reset the location.  */\n       if (EXPR_P (ret) && EXPR_HAS_LOCATION (ret))\n \tlocation = EXPR_LOCATION (ret);\n@@ -3284,7 +3286,8 @@ build_unary_op (location_t location,\n       if (TREE_CODE (arg) == COMPLEX_CST)\n \tret = TREE_REALPART (arg);\n       else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n-\tret = fold_build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n+\tret = fold_build1_loc (location,\n+\t\t\t       REALPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n       else\n \tret = arg;\n       if (eptype && TREE_CODE (eptype) == COMPLEX_TYPE)\n@@ -3295,9 +3298,11 @@ build_unary_op (location_t location,\n       if (TREE_CODE (arg) == COMPLEX_CST)\n \tret = TREE_IMAGPART (arg);\n       else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n-\tret = fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n+\tret = fold_build1_loc (location,\n+\t\t\t       IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n       else\n-\tret = omit_one_operand (TREE_TYPE (arg), integer_zero_node, arg);\n+\tret = omit_one_operand_loc (location, TREE_TYPE (arg),\n+\t\t\t\tinteger_zero_node, arg);\n       if (eptype && TREE_CODE (eptype) == COMPLEX_TYPE)\n \teptype = TREE_TYPE (eptype);\n       goto return_build_unary_op;\n@@ -3405,7 +3410,7 @@ build_unary_op (location_t location,\n \t      }\n \n \t    inc = c_size_in_bytes (TREE_TYPE (argtype));\n-\t    inc = fold_convert (sizetype, inc);\n+\t    inc = fold_convert_loc (location, sizetype, inc);\n \t  }\n \telse if (FRACT_MODE_P (TYPE_MODE (argtype)))\n \t  {\n@@ -3475,7 +3480,7 @@ build_unary_op (location_t location,\n \t{\n \t  /* Don't let this be an lvalue.  */\n \t  if (lvalue_p (TREE_OPERAND (arg, 0)))\n-\t    return non_lvalue (TREE_OPERAND (arg, 0));\n+\t    return non_lvalue_loc (location, TREE_OPERAND (arg, 0));\n \t  ret = TREE_OPERAND (arg, 0);\n \t  goto return_build_unary_op;\n \t}\n@@ -3541,10 +3546,11 @@ build_unary_op (location_t location,\n       if (val && TREE_CODE (val) == INDIRECT_REF\n           && TREE_CONSTANT (TREE_OPERAND (val, 0)))\n \t{\n-\t  tree op0 = fold_convert (sizetype, fold_offsetof (arg, val)), op1;\n+\t  tree op0 = fold_convert_loc (location, sizetype,\n+\t\t\t\t       fold_offsetof (arg, val)), op1;\n \n-\t  op1 = fold_convert (argtype, TREE_OPERAND (val, 0));\n-\t  ret = fold_build2 (POINTER_PLUS_EXPR, argtype, op1, op0);\n+\t  op1 = fold_convert_loc (location, argtype, TREE_OPERAND (val, 0));\n+\t  ret = fold_build2_loc (location, POINTER_PLUS_EXPR, argtype, op1, op0);\n \t  goto return_build_unary_op;\n \t}\n \n@@ -3561,8 +3567,8 @@ build_unary_op (location_t location,\n     argtype = TREE_TYPE (arg);\n   if (TREE_CODE (arg) == INTEGER_CST)\n     ret = (require_constant_value\n-\t   ? fold_build1_initializer (code, argtype, arg)\n-\t   : fold_build1 (code, argtype, arg));\n+\t   ? fold_build1_initializer_loc (location, code, argtype, arg)\n+\t   : fold_build1_loc (location, code, argtype, arg));\n   else\n     ret = build1 (code, argtype, arg);\n  return_build_unary_op:\n@@ -4048,7 +4054,7 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \t\t       && !TREE_OVERFLOW (orig_op2)));\n     }\n   if (int_const || (ifexp_bcp && TREE_CODE (ifexp) == INTEGER_CST))\n-    ret = fold_build3 (COND_EXPR, result_type, ifexp, op1, op2);\n+    ret = fold_build3_loc (colon_loc, COND_EXPR, result_type, ifexp, op1, op2);\n   else\n     {\n       ret = build3 (COND_EXPR, result_type, ifexp, op1, op2);\n@@ -4402,7 +4408,7 @@ build_c_cast (location_t loc, tree type, tree expr)\n \n   /* Don't let a cast be an lvalue.  */\n   if (value == expr)\n-    value = non_lvalue (value);\n+    value = non_lvalue_loc (loc, value);\n \n   /* Don't allow the results of casting to floating-point or complex\n      types be confused with actual constants, or casts involving\n@@ -4939,7 +4945,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t    pedwarn (location, OPT_pedantic, \n \t\t     \"ISO C prohibits argument conversion to union type\");\n \n-\t  rhs = fold_convert (TREE_TYPE (memb), rhs);\n+\t  rhs = fold_convert_loc (location, TREE_TYPE (memb), rhs);\n \t  return build_constructor_single (type, memb, rhs);\n \t}\n     }\n@@ -7316,8 +7322,8 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n   /* Advance the variable that indicates sequential elements output.  */\n   if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     constructor_unfilled_index\n-      = size_binop (PLUS_EXPR, constructor_unfilled_index,\n-\t\t    bitsize_one_node);\n+      = size_binop_loc (input_location, PLUS_EXPR, constructor_unfilled_index,\n+\t\t\tbitsize_one_node);\n   else if (TREE_CODE (constructor_type) == RECORD_TYPE)\n     {\n       constructor_unfilled_fields\n@@ -7632,9 +7638,9 @@ process_init_element (struct c_expr value, bool implicit)\n \t      /* For a record, keep track of end position of last field.  */\n \t      if (DECL_SIZE (constructor_fields))\n \t\tconstructor_bit_index\n-\t\t  = size_binop (PLUS_EXPR,\n-\t\t\t\tbit_position (constructor_fields),\n-\t\t\t\tDECL_SIZE (constructor_fields));\n+\t\t  = size_binop_loc (input_location, PLUS_EXPR,\n+\t\t\t\t    bit_position (constructor_fields),\n+\t\t\t\t    DECL_SIZE (constructor_fields));\n \n \t      /* If the current field was the first one not yet written out,\n \t\t it isn't now, so update.  */\n@@ -7769,7 +7775,8 @@ process_init_element (struct c_expr value, bool implicit)\n \t    }\n \n \t  constructor_index\n-\t    = size_binop (PLUS_EXPR, constructor_index, bitsize_one_node);\n+\t    = size_binop_loc (input_location, PLUS_EXPR,\n+\t\t\t      constructor_index, bitsize_one_node);\n \n \t  if (!value.value)\n \t    /* If we are doing the bookkeeping for an element that was\n@@ -7801,7 +7808,8 @@ process_init_element (struct c_expr value, bool implicit)\n \t    }\n \n \t  constructor_index\n-\t    = size_binop (PLUS_EXPR, constructor_index, bitsize_one_node);\n+\t    = size_binop_loc (input_location,\n+\t\t\t      PLUS_EXPR, constructor_index, bitsize_one_node);\n \n \t  if (!value.value)\n \t    /* If we are doing the bookkeeping for an element that was\n@@ -7850,7 +7858,8 @@ process_init_element (struct c_expr value, bool implicit)\n \t      process_init_element (pop_init_level (1), true);\n \t    }\n \n-\t  p->index = size_binop (PLUS_EXPR, p->index, bitsize_one_node);\n+\t  p->index = size_binop_loc (input_location,\n+\t\t\t\t     PLUS_EXPR, p->index, bitsize_one_node);\n \t  if (tree_int_cst_equal (p->index, p->range_end) && !p->prev)\n \t    finish = 1;\n \n@@ -8416,11 +8425,12 @@ c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n \t    }\n \n \t  t = build_and_jump (&blab);\n-\t  exit = fold_build3 (COND_EXPR, void_type_node, cond, exit, t);\n \t  if (cond_is_first)\n-\t    SET_EXPR_LOCATION (exit, start_locus);\n+\t    exit = fold_build3_loc (start_locus,\n+\t\t\t\tCOND_EXPR, void_type_node, cond, exit, t);\n \t  else\n-\t    SET_EXPR_LOCATION (exit, input_location);\n+\t    exit = fold_build3_loc (input_location,\n+\t\t\t\tCOND_EXPR, void_type_node, cond, exit, t);\n \t}\n \n       add_stmt (top);\n@@ -8935,12 +8945,12 @@ build_binary_op (location_t location, enum tree_code code,\n       /* Handle the pointer + int case.  */\n       if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n-\t  ret = pointer_int_sum (PLUS_EXPR, op0, op1);\n+\t  ret = pointer_int_sum (location, PLUS_EXPR, op0, op1);\n \t  goto return_build_binary_op;\n \t}\n       else if (code1 == POINTER_TYPE && code0 == INTEGER_TYPE)\n \t{\n-\t  ret = pointer_int_sum (PLUS_EXPR, op1, op0);\n+\t  ret = pointer_int_sum (location, PLUS_EXPR, op1, op0);\n \t  goto return_build_binary_op;\n \t}\n       else\n@@ -8953,13 +8963,13 @@ build_binary_op (location_t location, enum tree_code code,\n       if (code0 == POINTER_TYPE && code1 == POINTER_TYPE\n \t  && comp_target_types (location, type0, type1))\n \t{\n-\t  ret = pointer_diff (op0, op1);\n+\t  ret = pointer_diff (location, op0, op1);\n \t  goto return_build_binary_op;\n \t}\n       /* Handle pointer minus int.  Just like pointer plus int.  */\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n-\t  ret = pointer_int_sum (MINUS_EXPR, op0, op1);\n+\t  ret = pointer_int_sum (location, MINUS_EXPR, op0, op1);\n \t  goto return_build_binary_op;\n \t}\n       else\n@@ -9572,8 +9582,9 @@ build_binary_op (location_t location, enum tree_code code,\n   /* Treat expressions in initializers specially as they can't trap.  */\n   if (int_const_or_overflow)\n     ret = (require_constant_value\n-\t   ? fold_build2_initializer (resultcode, build_type, op0, op1)\n-\t   : fold_build2 (resultcode, build_type, op0, op1));\n+\t   ? fold_build2_initializer_loc (location, resultcode, build_type,\n+\t\t\t\t\t  op0, op1)\n+\t   : fold_build2_loc (location, resultcode, build_type, op0, op1));\n   else\n     ret = build2 (resultcode, build_type, op0, op1);\n   if (final_type != 0)"}, {"sha": "bac4f8bb5d99480aba0469edb1c3f306a774e0f5", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -949,6 +949,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t\t\t int *must_preallocate, int *ecf_flags,\n \t\t\t\t bool *may_tailcall, bool call_from_thunk_p)\n {\n+  location_t loc = EXPR_LOCATION (exp);\n   /* 1 if scanning parms front to back, -1 if scanning back to front.  */\n   int inc;\n \n@@ -1062,7 +1063,8 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t      if (!call_from_thunk_p && DECL_P (base) && !TREE_STATIC (base))\n \t\t*may_tailcall = false;\n \n-\t      args[i].tree_value = build_fold_addr_expr (args[i].tree_value);\n+\t      args[i].tree_value = build_fold_addr_expr_loc (loc,\n+\t\t\t\t\t\t\t args[i].tree_value);\n \t      type = TREE_TYPE (args[i].tree_value);\n \n \t      if (*ecf_flags & ECF_CONST)\n@@ -1114,7 +1116,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t*ecf_flags &= ~(ECF_PURE | ECF_LOOPING_CONST_OR_PURE);\n \n \t      args[i].tree_value\n-\t\t= build_fold_addr_expr (make_tree (type, copy));\n+\t\t= build_fold_addr_expr_loc (loc, make_tree (type, copy));\n \t      type = TREE_TYPE (args[i].tree_value);\n \t      *may_tailcall = false;\n \t    }"}, {"sha": "0a3cc6c3811bfca3969eeea7c4cbc758a1732e0f", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -208,7 +208,8 @@ build_cdtor (bool ctor_p, tree *cdtors, size_t len)\n \t    priority = p;\n \t  else if (p != priority)\n \t    break;\n-\t  append_to_statement_list (build_function_call_expr (fn, 0),\n+\t  append_to_statement_list (build_function_call_expr (UNKNOWN_LOCATION,\n+\t\t\t\t\t\t\t      fn, 0),\n \t\t\t\t    &body);\n \t  ++i;\n \t}"}, {"sha": "a1ac3300cac5db4b71f5a9d85cc9a5d2df1dea34", "filename": "gcc/convert.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n tree\n convert_to_pointer (tree type, tree expr)\n {\n+  location_t loc = EXPR_LOCATION (expr);\n   if (TREE_TYPE (expr) == type)\n     return expr;\n \n@@ -53,16 +54,16 @@ convert_to_pointer (tree type, tree expr)\n     {\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-      return fold_build1 (NOP_EXPR, type, expr);\n+      return fold_build1_loc (loc, NOP_EXPR, type, expr);\n \n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n       if (TYPE_PRECISION (TREE_TYPE (expr)) != POINTER_SIZE)\n-\texpr = fold_build1 (NOP_EXPR,\n+\texpr = fold_build1_loc (loc, NOP_EXPR,\n                             lang_hooks.types.type_for_size (POINTER_SIZE, 0),\n \t\t\t    expr);\n-      return fold_build1 (CONVERT_EXPR, type, expr);\n+      return fold_build1_loc (loc, CONVERT_EXPR, type, expr);\n \n \n     default:"}, {"sha": "71d2105f08b94102a895300a02212be11c6855cc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1,3 +1,21 @@\n+2009-07-17  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR 40435 \n+\t* typeck.c, init.c, class.c, method.c, rtti.c, except.c, error.c,\n+\ttree.c, cp-gimplify.c, cxx-pretty-print.c, pt.c, semantics.c,\n+\tcall.c, cvt.c, mangle.c: Add location argument to\n+\tfold_{unary,binary,ternary}, fold_build[123], build_call_expr,\n+\tbuild_size_arg, build_fold_addr_expr, build_call_array,\n+\tnon_lvalue, size_diffop, fold_build1_initializer,\n+\tfold_build2_initializer, fold_build3_initializer,\n+\tfold_build_call_array, fold_build_call_array_initializer,\n+\tfold_single_bit_test, omit_one_operand, omit_two_operands,\n+\tinvert_truthvalue, fold_truth_not_expr, build_fold_indirect_ref,\n+\tfold_indirect_ref, combine_comparisons, fold_builtin_*,\n+\tfold_call_expr, build_range_check, maybe_fold_offset_to_address,\n+\tround_up, round_down.\n+\n 2009-07-16  Jason Merrill  <jason@redhat.com>\n \n \tPR libstdc++/37907"}, {"sha": "f4b5b02bb45ded48037fd7768053ddbf74211497", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -362,7 +362,8 @@ build_call_a (tree function, int n, tree *argarray)\n \t\t\t\targarray[i], t);\n \t}\n \n-  function = build_call_array (result_type, function, n, argarray);\n+  function = build_call_array_loc (input_location,\n+\t\t\t\t   result_type, function, n, argarray);\n   TREE_HAS_CONSTRUCTOR (function) = is_constructor;\n   TREE_NOTHROW (function) = nothrow;\n \n@@ -5365,8 +5366,9 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t    alcarray[ix + 1] = arg;\n \t  argarray = alcarray;\n \t}\n-      expr = build_call_array (return_type, build_addr_func (fn), nargs,\n-\t\t\t       argarray);\n+      expr = build_call_array_loc (input_location,\n+\t\t\t\t   return_type, build_addr_func (fn), nargs,\n+\t\t\t\t   argarray);\n       if (TREE_THIS_VOLATILE (fn) && cfun)\n \tcurrent_function_returns_abnormally = 1;\n       if (!VOID_TYPE_P (return_type))"}, {"sha": "9a768831621d0cb25de34251cd9500276526be8e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -333,7 +333,7 @@ build_base_path (enum tree_code code,\n   if (null_test)\n     {\n       tree zero = cp_convert (TREE_TYPE (expr), integer_zero_node);\n-      null_test = fold_build2 (NE_EXPR, boolean_type_node,\n+      null_test = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n \t\t\t       expr, zero);\n     }\n \n@@ -385,7 +385,7 @@ build_base_path (enum tree_code code,\n       TREE_CONSTANT (v_offset) = 1;\n \n       offset = convert_to_integer (ptrdiff_type_node,\n-\t\t\t\t   size_diffop (offset,\n+\t\t\t\t   size_diffop_loc (input_location, offset,\n \t\t\t\t\t\tBINFO_OFFSET (v_binfo)));\n \n       if (!integer_zerop (offset))\n@@ -417,7 +417,7 @@ build_base_path (enum tree_code code,\n     {\n       offset = fold_convert (sizetype, offset);\n       if (code == MINUS_EXPR)\n-\toffset = fold_build1 (NEGATE_EXPR, sizetype, offset);\n+\toffset = fold_build1_loc (input_location, NEGATE_EXPR, sizetype, offset);\n       expr = build2 (POINTER_PLUS_EXPR, ptr_target_type, expr, offset);\n     }\n   else\n@@ -428,8 +428,8 @@ build_base_path (enum tree_code code,\n \n  out:\n   if (null_test)\n-    expr = fold_build3 (COND_EXPR, target_type, null_test, expr,\n-\t\t\tfold_build1 (NOP_EXPR, target_type,\n+    expr = fold_build3_loc (input_location, COND_EXPR, target_type, null_test, expr,\n+\t\t\tfold_build1_loc (input_location, NOP_EXPR, target_type,\n \t\t\t\t     integer_zero_node));\n \n   return expr;\n@@ -553,10 +553,11 @@ convert_to_base_statically (tree expr, tree base)\n       expr = cp_build_unary_op (ADDR_EXPR, expr, /*noconvert=*/1, \n                              tf_warning_or_error);\n       if (!integer_zerop (BINFO_OFFSET (base)))\n-        expr = fold_build2 (POINTER_PLUS_EXPR, pointer_type, expr,\n+        expr = fold_build2_loc (input_location,\n+\t\t\t    POINTER_PLUS_EXPR, pointer_type, expr,\n \t\t\t    fold_convert (sizetype, BINFO_OFFSET (base)));\n       expr = fold_convert (build_pointer_type (BINFO_TYPE (base)), expr);\n-      expr = build_fold_indirect_ref (expr);\n+      expr = build_fold_indirect_ref_loc (input_location, expr);\n     }\n \n   return expr;\n@@ -1396,7 +1397,8 @@ determine_primary_bases (tree t)\n \t      /* A virtual binfo might have been copied from within\n \t\t another hierarchy. As we're about to use it as a\n \t\t primary base, make sure the offsets match.  */\n-\t      delta = size_diffop (convert (ssizetype,\n+\t      delta = size_diffop_loc (input_location,\n+\t\t\t\t   convert (ssizetype,\n \t\t\t\t\t    BINFO_OFFSET (base_binfo)),\n \t\t\t\t   convert (ssizetype,\n \t\t\t\t\t    BINFO_OFFSET (this_primary)));\n@@ -1459,7 +1461,7 @@ determine_primary_bases (tree t)\n \t  /* A virtual binfo might have been copied from within\n \t     another hierarchy. As we're about to use it as a primary\n \t     base, make sure the offsets match.  */\n-\t  delta = size_diffop (ssize_int (0),\n+\t  delta = size_diffop_loc (input_location, ssize_int (0),\n \t\t\t       convert (ssizetype, BINFO_OFFSET (primary)));\n \n \t  propagate_binfo_offsets (primary, delta);\n@@ -2162,9 +2164,10 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t\t{\n \t\t  /* We convert via virtual base.  Adjust the fixed\n \t\t     offset to be from there.  */\n-\t\t  offset = size_diffop\n-\t\t    (offset, convert\n-\t\t     (ssizetype, BINFO_OFFSET (virtual_offset)));\n+\t\t  offset = \n+\t\t    size_diffop (offset,\n+\t\t\t\t convert (ssizetype,\n+\t\t\t\t\t  BINFO_OFFSET (virtual_offset)));\n \t\t}\n \t      if (fixed_offset)\n \t\t/* There was an existing fixed offset, this must be\n@@ -2247,7 +2250,8 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n   if (virtual_base)\n     /* The `this' pointer needs to be adjusted from the declaration to\n        the nearest virtual base.  */\n-    delta = size_diffop (convert (ssizetype, BINFO_OFFSET (virtual_base)),\n+    delta = size_diffop_loc (input_location,\n+\t\t\t convert (ssizetype, BINFO_OFFSET (virtual_base)),\n \t\t\t convert (ssizetype, BINFO_OFFSET (first_defn)));\n   else if (lost)\n     /* If the nearest definition is in a lost primary, we don't need an\n@@ -2260,7 +2264,8 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n        BINFO to pointing at the base where the final overrider\n        appears.  */\n     virtual_covariant:\n-    delta = size_diffop (convert (ssizetype,\n+    delta = size_diffop_loc (input_location,\n+\t\t\t convert (ssizetype,\n \t\t\t\t  BINFO_OFFSET (TREE_VALUE (overrider))),\n \t\t\t convert (ssizetype, BINFO_OFFSET (binfo)));\n \n@@ -3574,7 +3579,8 @@ layout_nonempty_base_or_field (record_layout_info rli,\n        hierarchy.  Therefore, we may not need to add the entire\n        OFFSET.  */\n     propagate_binfo_offsets (binfo,\n-\t\t\t     size_diffop (convert (ssizetype, offset),\n+\t\t\t     size_diffop_loc (input_location,\n+\t\t\t\t\t  convert (ssizetype, offset),\n \t\t\t\t\t  convert (ssizetype,\n \t\t\t\t\t\t   BINFO_OFFSET (binfo))));\n }\n@@ -3611,7 +3617,8 @@ layout_empty_base (record_layout_info rli, tree binfo,\n     {\n       if (abi_version_at_least (2))\n \tpropagate_binfo_offsets\n-\t  (binfo, size_diffop (size_zero_node, BINFO_OFFSET (binfo)));\n+\t  (binfo, size_diffop_loc (input_location,\n+\t\t\t       size_zero_node, BINFO_OFFSET (binfo)));\n       else\n \twarning (OPT_Wabi,\n \t\t \"offset of empty base %qT may not be ABI-compliant and may\"\n@@ -3717,7 +3724,8 @@ build_base_field (record_layout_info rli, tree binfo,\n \n       /* On some platforms (ARM), even empty classes will not be\n \t byte-aligned.  */\n-      eoc = round_up (rli_size_unit_so_far (rli),\n+      eoc = round_up_loc (input_location,\n+\t\t      rli_size_unit_so_far (rli),\n \t\t      CLASSTYPE_ALIGN_UNIT (basetype));\n       atend = layout_empty_base (rli, binfo, eoc, offsets);\n       /* A nearly-empty class \"has no proper base class that is empty,\n@@ -4637,7 +4645,8 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n \t      && first_vbase\n \t      && (tree_int_cst_lt\n \t\t  (size_binop (CEIL_DIV_EXPR,\n-\t\t\t       round_up (CLASSTYPE_SIZE (t),\n+\t\t\t       round_up_loc (input_location,\n+\t\t\t\t\t CLASSTYPE_SIZE (t),\n \t\t\t\t\t CLASSTYPE_ALIGN (basetype)),\n \t\t\t       bitsize_unit_node),\n \t\t   BINFO_OFFSET (vbase))))\n@@ -5070,7 +5079,7 @@ layout_class_type (tree t, tree *virtuals_p)\n       /* Make sure that we are on a byte boundary so that the size of\n \t the class without virtual bases will always be a round number\n \t of bytes.  */\n-      rli->bitpos = round_up (rli->bitpos, BITS_PER_UNIT);\n+      rli->bitpos = round_up_loc (input_location, rli->bitpos, BITS_PER_UNIT);\n       normalize_rli (rli);\n     }\n \n@@ -7765,11 +7774,12 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n \t The vbase offsets go in reverse inheritance-graph order, and\n \t we are walking in inheritance graph order so these end up in\n \t the right order.  */\n-      delta = size_diffop (BINFO_OFFSET (b), BINFO_OFFSET (non_primary_binfo));\n+      delta = size_diffop_loc (input_location,\n+\t\t\t   BINFO_OFFSET (b), BINFO_OFFSET (non_primary_binfo));\n \n       *vid->last_init\n \t= build_tree_list (NULL_TREE,\n-\t\t\t   fold_build1 (NOP_EXPR,\n+\t\t\t   fold_build1_loc (input_location, NOP_EXPR,\n \t\t\t\t\tvtable_entry_type,\n \t\t\t\t\tdelta));\n       vid->last_init = &TREE_CHAIN (*vid->last_init);\n@@ -7999,9 +8009,11 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n \t     vid->binfo.  But it might be a lost primary, so its\n \t     BINFO_OFFSET might be wrong, so we just use the\n \t     BINFO_OFFSET from vid->binfo.  */\n-\t  vcall_offset = size_diffop (BINFO_OFFSET (base),\n+\t  vcall_offset = size_diffop_loc (input_location,\n+\t\t\t\t      BINFO_OFFSET (base),\n \t\t\t\t      BINFO_OFFSET (vid->binfo));\n-\t  vcall_offset = fold_build1 (NOP_EXPR, vtable_entry_type,\n+\t  vcall_offset = fold_build1_loc (input_location,\n+\t\t\t\t      NOP_EXPR, vtable_entry_type,\n \t\t\t\t      vcall_offset);\n \t}\n       /* Add the initializer to the vtable.  */\n@@ -8040,7 +8052,8 @@ build_rtti_vtbl_entries (tree binfo, vtbl_init_data* vid)\n \t\t  && BINFO_INHERITANCE_CHAIN (primary_base) == b);\n       b = primary_base;\n     }\n-  offset = size_diffop (BINFO_OFFSET (vid->rtti_binfo), BINFO_OFFSET (b));\n+  offset = size_diffop_loc (input_location,\n+\t\t\tBINFO_OFFSET (vid->rtti_binfo), BINFO_OFFSET (b));\n \n   /* The second entry is the address of the typeinfo object.  */\n   if (flag_rtti)"}, {"sha": "4cf78dfd4a5e58bf2969bf683a99daf5c744fd9d", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -924,9 +924,9 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n \t\t\t     size_zero_node, NULL, NULL);\n \t}\n       while (TREE_CODE (inner_type) == ARRAY_TYPE);\n-      start1 = build_fold_addr_expr (start1);\n+      start1 = build_fold_addr_expr_loc (input_location, start1);\n       if (arg2)\n-\tstart2 = build_fold_addr_expr (start2);\n+\tstart2 = build_fold_addr_expr_loc (input_location, start2);\n \n       end1 = TYPE_SIZE_UNIT (TREE_TYPE (arg1));\n       end1 = build2 (POINTER_PLUS_EXPR, TREE_TYPE (start1), start1, end1);\n@@ -980,9 +980,9 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n     }\n   else\n     {\n-      argarray[i++] = build_fold_addr_expr (arg1);\n+      argarray[i++] = build_fold_addr_expr_loc (input_location, arg1);\n       if (arg2)\n-\targarray[i++] = build_fold_addr_expr (arg2);\n+\targarray[i++] = build_fold_addr_expr_loc (input_location, arg2);\n       /* Handle default arguments.  */\n       for (parm = defparm; parm && parm != void_list_node;\n \t   parm = TREE_CHAIN (parm), i++)"}, {"sha": "c42d21cb3cd5fec9ebe08a7e0d8740c71c12a75f", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -936,10 +936,11 @@ convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n \t      && !AGGR_INIT_VIA_CTOR_P (init))\n \t    {\n \t      tree fn = AGGR_INIT_EXPR_FN (init);\n-\t      expr = build_call_array (TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n-\t\t\t\t       fn,\n-\t\t\t\t       aggr_init_expr_nargs (init),\n-\t\t\t\t       AGGR_INIT_EXPR_ARGP (init));\n+\t      expr = build_call_array_loc (input_location,\n+\t\t\t\t\t   TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n+\t\t\t\t\t   fn,\n+\t\t\t\t\t   aggr_init_expr_nargs (init),\n+\t\t\t\t\t   AGGR_INIT_EXPR_ARGP (init));\n \t    }\n \t}\n       break;"}, {"sha": "1d7f9cf2caf401b37f514247fe0283898f52f092", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -659,7 +659,8 @@ pp_cxx_new_expression (cxx_pretty_printer *pp, tree t)\n       if (TREE_CODE (type) == ARRAY_REF)\n \ttype = build_cplus_array_type\n \t  (TREE_OPERAND (type, 0),\n-\t   build_index_type (fold_build2 (MINUS_EXPR, integer_type_node,\n+\t   build_index_type (fold_build2_loc (input_location,\n+\t\t\t\t\t  MINUS_EXPR, integer_type_node,\n \t\t\t\t\t  TREE_OPERAND (type, 1),\n \t\t\t\t\t  integer_one_node)));\n       pp_cxx_type_id (pp, type);"}, {"sha": "939400bd2c42660550cd5c720cb3469c4fa55d6f", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -770,7 +770,8 @@ dump_type_suffix (tree t, int flags)\n \t    dump_expr (TREE_OPERAND (max, 0),\n \t\t       flags & ~TFF_EXPR_IN_PARENS);\n \t  else\n-\t    dump_expr (fold_build2 (PLUS_EXPR, dtype, max,\n+\t    dump_expr (fold_build2_loc (input_location,\n+\t\t\t\t    PLUS_EXPR, dtype, max,\n \t\t\t\t    build_int_cst (dtype, 1)),\n \t\t       flags & ~TFF_EXPR_IN_PARENS);\n \t}"}, {"sha": "fdef154f5d1c91f5ee3d1f956fbff60bef04600a", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -450,7 +450,8 @@ expand_start_catch_block (tree decl)\n       exp = build_exc_ptr ();\n       exp = build1 (NOP_EXPR, build_pointer_type (type), exp);\n       exp = build2 (POINTER_PLUS_EXPR, TREE_TYPE (exp), exp,\n-\t\t    fold_build1 (NEGATE_EXPR, sizetype,\n+\t\t    fold_build1_loc (input_location,\n+\t\t\t\t NEGATE_EXPR, sizetype,\n \t\t\t \t TYPE_SIZE_UNIT (TREE_TYPE (exp))));\n       exp = cp_build_indirect_ref (exp, NULL, tf_warning_or_error);\n       initialize_handler_parm (decl, exp);"}, {"sha": "73403e9113aec10e5040fe9b239c203b004f8cd0", "filename": "gcc/cp/init.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -219,7 +219,8 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \n       /* Iterate over the array elements, building initializations.  */\n       if (nelts)\n-\tmax_index = fold_build2 (MINUS_EXPR, TREE_TYPE (nelts),\n+\tmax_index = fold_build2_loc (input_location,\n+\t\t\t\t MINUS_EXPR, TREE_TYPE (nelts),\n \t\t\t\t nelts, integer_one_node);\n       else\n \tmax_index = array_type_nelts (type);\n@@ -965,7 +966,8 @@ expand_cleanup_for_base (tree binfo, tree flag)\n \t\t\t\t    LOOKUP_NORMAL | LOOKUP_NONVIRTUAL,\n                                     tf_warning_or_error);\n   if (flag)\n-    expr = fold_build3 (COND_EXPR, void_type_node,\n+    expr = fold_build3_loc (input_location,\n+\t\t\tCOND_EXPR, void_type_node,\n \t\t\tc_common_truthvalue_conversion (input_location, flag),\n \t\t\texpr, integer_zero_node);\n \n@@ -2048,7 +2050,8 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \t many elements to destroy later.  We use the last sizeof\n \t (size_t) bytes to store the number of elements.  */\n       cookie_ptr = size_binop (MINUS_EXPR, cookie_size, size_in_bytes (sizetype));\n-      cookie_ptr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (alloc_node),\n+      cookie_ptr = fold_build2_loc (input_location,\n+\t\t\t\tPOINTER_PLUS_EXPR, TREE_TYPE (alloc_node),\n \t\t\t\talloc_node, cookie_ptr);\n       size_ptr_type = build_pointer_type (sizetype);\n       cookie_ptr = fold_convert (size_ptr_type, cookie_ptr);\n@@ -2060,7 +2063,8 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \t{\n \t  /* Also store the element size.  */\n \t  cookie_ptr = build2 (POINTER_PLUS_EXPR, size_ptr_type, cookie_ptr,\n-\t\t\t       fold_build1 (NEGATE_EXPR, sizetype,\n+\t\t\t       fold_build1_loc (input_location,\n+\t\t\t\t\t    NEGATE_EXPR, sizetype,\n \t\t\t\t\t    size_in_bytes (sizetype)));\n \n \t  cookie = cp_build_indirect_ref (cookie_ptr, NULL, complain);\n@@ -2498,7 +2502,8 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \n   tbase = create_temporary_var (ptype);\n   tbase_init = cp_build_modify_expr (tbase, NOP_EXPR,\n-\t\t\t\t     fold_build2 (POINTER_PLUS_EXPR, ptype,\n+\t\t\t\t     fold_build2_loc (input_location,\n+\t\t\t\t\t\t  POINTER_PLUS_EXPR, ptype,\n \t\t\t\t\t\t  fold_convert (ptype, base),\n \t\t\t\t\t\t  virtual_size),\n \t\t\t\t     tf_warning_or_error);\n@@ -2510,7 +2515,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   body = build1 (EXIT_EXPR, void_type_node,\n \t\t build2 (EQ_EXPR, boolean_type_node, tbase,\n \t\t\t fold_convert (ptype, base)));\n-  tmp = fold_build1 (NEGATE_EXPR, sizetype, size_exp);\n+  tmp = fold_build1_loc (input_location, NEGATE_EXPR, sizetype, size_exp);\n   body = build_compound_expr\n     (input_location, \n      body, cp_build_modify_expr (tbase, NOP_EXPR,\n@@ -2575,8 +2580,9 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n     body = integer_zero_node;\n \n   /* Outermost wrapper: If pointer is null, punt.  */\n-  body = fold_build3 (COND_EXPR, void_type_node,\n-\t\t      fold_build2 (NE_EXPR, boolean_type_node, base,\n+  body = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t      fold_build2_loc (input_location,\n+\t\t\t\t   NE_EXPR, boolean_type_node, base,\n \t\t\t\t   convert (TREE_TYPE (base),\n \t\t\t\t\t    integer_zero_node)),\n \t\t      body, integer_zero_node);\n@@ -3279,7 +3285,8 @@ build_vec_delete (tree base, tree maxindex,\n \t  base = TARGET_EXPR_SLOT (base_init);\n \t}\n       type = strip_array_types (TREE_TYPE (type));\n-      cookie_addr = fold_build1 (NEGATE_EXPR, sizetype, TYPE_SIZE_UNIT (sizetype));\n+      cookie_addr = fold_build1_loc (input_location, NEGATE_EXPR,\n+\t\t\t\t sizetype, TYPE_SIZE_UNIT (sizetype));\n       cookie_addr = build2 (POINTER_PLUS_EXPR,\n \t\t\t    size_ptr_type,\n \t\t\t    fold_convert (size_ptr_type, base),"}, {"sha": "1c79dcc31744f3d3c5729c2ab100b1df1c4113ac", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1264,16 +1264,16 @@ write_integer_cst (const tree cst)\n       if (sign < 0)\n \t{\n \t  write_char ('n');\n-\t  n = fold_build1 (NEGATE_EXPR, type, n);\n+\t  n = fold_build1_loc (input_location, NEGATE_EXPR, type, n);\n \t}\n       do\n \t{\n-\t  tree d = fold_build2 (FLOOR_DIV_EXPR, type, n, base);\n-\t  tree tmp = fold_build2 (MULT_EXPR, type, d, base);\n+\t  tree d = fold_build2_loc (input_location, FLOOR_DIV_EXPR, type, n, base);\n+\t  tree tmp = fold_build2_loc (input_location, MULT_EXPR, type, d, base);\n \t  unsigned c;\n \n \t  done = integer_zerop (d);\n-\t  tmp = fold_build2 (MINUS_EXPR, type, n, tmp);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR, type, n, tmp);\n \t  c = hwint_to_ascii (TREE_INT_CST_LOW (tmp), 10, ptr,\n \t\t\t      done ? 1 : chunk_digits);\n \t  ptr -= c;"}, {"sha": "c1da08b690ffd9e38253561701fd1a07fd68edd1", "filename": "gcc/cp/method.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -221,7 +221,8 @@ thunk_adjust (tree ptr, bool this_adjusting,\n {\n   if (this_adjusting)\n     /* Adjust the pointer by the constant.  */\n-    ptr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+    ptr = fold_build2_loc (input_location,\n+\t\t       POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n \t\t       size_int (fixed_offset));\n \n   /* If there's a virtual offset, look up that value in the vtable and\n@@ -239,18 +240,21 @@ thunk_adjust (tree ptr, bool this_adjusting,\n       /* Form the vtable address.  */\n       vtable = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (vtable)), vtable);\n       /* Find the entry with the vcall offset.  */\n-      vtable = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (vtable), vtable,\n-\t\t       fold_convert (sizetype, virtual_offset));\n+      vtable = fold_build2_loc (input_location,\n+\t\t\t    POINTER_PLUS_EXPR, TREE_TYPE (vtable), vtable,\n+\t\t\t    fold_convert (sizetype, virtual_offset));\n       /* Get the offset itself.  */\n       vtable = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (vtable)), vtable);\n       /* Adjust the `this' pointer.  */\n-      ptr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+      ptr = fold_build2_loc (input_location,\n+\t\t\t POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n \t\t\t fold_convert (sizetype, vtable));\n     }\n \n   if (!this_adjusting)\n     /* Adjust the pointer by the constant.  */\n-    ptr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+    ptr = fold_build2_loc (input_location,\n+\t\t       POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n \t\t       size_int (fixed_offset));\n \n   return ptr;"}, {"sha": "de9f828c645512e155e419cb79a1da6ee93e2861", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -9850,7 +9850,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (e1 == error_mark_node || e2 == error_mark_node)\n \t  return error_mark_node;\n \n-\treturn fold_build2 (TREE_CODE (t), TREE_TYPE (t), e1, e2);\n+\treturn fold_build2_loc (input_location,\n+\t\t\t    TREE_CODE (t), TREE_TYPE (t), e1, e2);\n       }\n \n     case NEGATE_EXPR:\n@@ -9860,7 +9861,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (e == error_mark_node)\n \t  return error_mark_node;\n \n-\treturn fold_build1 (TREE_CODE (t), TREE_TYPE (t), e);\n+\treturn fold_build1_loc (input_location, TREE_CODE (t), TREE_TYPE (t), e);\n       }\n \n     case TYPENAME_TYPE:\n@@ -14073,12 +14074,12 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t  /* If only one of the bounds used a MINUS_EXPR, compensate\n \t     by adding one to the other bound.  */\n \t  if (parm_cst && !arg_cst)\n-\t    parm_max = fold_build2 (PLUS_EXPR,\n+\t    parm_max = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t    integer_type_node,\n \t\t\t\t    parm_max,\n \t\t\t\t    integer_one_node);\n \t  else if (arg_cst && !parm_cst)\n-\t    arg_max = fold_build2 (PLUS_EXPR,\n+\t    arg_max = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t   integer_type_node,\n \t\t\t\t   arg_max,\n \t\t\t\t   integer_one_node);"}, {"sha": "01bba3477df88db1c0105f3b1c39dbee31a54b7a", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1099,9 +1099,11 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \n \t    /* Combine offset and flags into one field.  */\n \t    offset = fold_convert (offset_type, offset);\n-\t    offset = fold_build2 (LSHIFT_EXPR, offset_type, offset,\n+\t    offset = fold_build2_loc (input_location,\n+\t\t\t\t  LSHIFT_EXPR, offset_type, offset,\n \t\t\t\t  build_int_cst (offset_type, 8));\n-\t    offset = fold_build2 (BIT_IOR_EXPR, offset_type, offset,\n+\t    offset = fold_build2_loc (input_location,\n+\t\t\t\t  BIT_IOR_EXPR, offset_type, offset,\n \t\t\t\t  build_int_cst (offset_type, flags));\n \t    base_init = tree_cons (NULL_TREE, offset, base_init);\n \t    base_init = tree_cons (NULL_TREE, tinfo, base_init);"}, {"sha": "9ac88fd7b65d80d09d9da36e66190d0dad69a0b1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -3129,10 +3129,11 @@ simplify_aggr_init_expr (tree *tp)\n       style = arg;\n     }\n \n-  call_expr = build_call_array (TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n-\t\t\t\tfn,\n-\t\t\t\taggr_init_expr_nargs (aggr_init_expr),\n-\t\t\t\tAGGR_INIT_EXPR_ARGP (aggr_init_expr));\n+  call_expr = build_call_array_loc (input_location,\n+\t\t\t\t    TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n+\t\t\t\t    fn,\n+\t\t\t\t    aggr_init_expr_nargs (aggr_init_expr),\n+\t\t\t\t    AGGR_INIT_EXPR_ARGP (aggr_init_expr));\n \n   if (style == ctor)\n     {"}, {"sha": "83869c17a1b51e850bf2969c0c95ddea61e7d69a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1595,7 +1595,8 @@ cxx_print_statistics (void)\n tree\n array_type_nelts_top (tree type)\n {\n-  return fold_build2 (PLUS_EXPR, sizetype,\n+  return fold_build2_loc (input_location,\n+\t\t      PLUS_EXPR, sizetype,\n \t\t      array_type_nelts (type),\n \t\t      size_one_node);\n }\n@@ -1612,7 +1613,8 @@ array_type_nelts_total (tree type)\n   while (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree n = array_type_nelts_top (type);\n-      sz = fold_build2 (MULT_EXPR, sizetype, sz, n);\n+      sz = fold_build2_loc (input_location,\n+\t\t\tMULT_EXPR, sizetype, sz, n);\n       type = TREE_TYPE (type);\n     }\n   return sz;"}, {"sha": "8b684dd795e48c8276afcd7452dd707472307ab2", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -2429,7 +2429,8 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n \t\t\t  /*want_type=*/false);\n   member_type = cp_build_qualified_type (TREE_TYPE (member),\n \t\t\t\t\t cp_type_quals (ptrmem_type));\n-  return fold_build3 (COMPONENT_REF, member_type,\n+  return fold_build3_loc (input_location,\n+\t\t      COMPONENT_REF, member_type,\n \t\t      ptrmem, member, NULL_TREE);\n }\n \n@@ -2836,7 +2837,8 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n       TREE_NO_WARNING (vtbl) = 1;\n \n       /* Finally, extract the function pointer from the vtable.  */\n-      e2 = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (vtbl), vtbl,\n+      e2 = fold_build2_loc (input_location,\n+\t\t\tPOINTER_PLUS_EXPR, TREE_TYPE (vtbl), vtbl,\n \t\t\tfold_convert (sizetype, idx));\n       e2 = cp_build_indirect_ref (e2, NULL, tf_warning_or_error);\n       TREE_CONSTANT (e2) = 1;\n@@ -4095,7 +4097,7 @@ cp_pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n      pointer_int_sum() anyway.  */\n   complete_type (TREE_TYPE (res_type));\n \n-  return pointer_int_sum (resultcode, ptrop,\n+  return pointer_int_sum (input_location, resultcode, ptrop,\n \t\t\t  fold_if_not_in_template (intop));\n }\n \n@@ -4393,7 +4395,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n     case TRUTH_NOT_EXPR:\n       arg = perform_implicit_conversion (boolean_type_node, arg,\n \t\t\t\t\t complain);\n-      val = invert_truthvalue (arg);\n+      val = invert_truthvalue_loc (input_location, arg);\n       if (arg != error_mark_node)\n \treturn val;\n       errstring = \"in argument to unary !\";\n@@ -5201,7 +5203,8 @@ convert_ptrmem (tree type, tree expr, bool allow_inverse_p,\n \t\t\t\t    PLUS_EXPR, op1, delta,\n \t\t\t\t    tf_warning_or_error);\n \n-\t  expr = fold_build3 (COND_EXPR, ptrdiff_type_node, cond, op1, op2);\n+\t  expr = fold_build3_loc (input_location,\n+\t\t\t      COND_EXPR, ptrdiff_type_node, cond, op1, op2);\n \t\t\t \n \t}\n \n@@ -6384,7 +6387,8 @@ get_delta_difference (tree from, tree to,\n \tresult = get_delta_difference_1 (to, from, c_cast_p);\n \n \tif (result)\n-\t  result = size_diffop (size_zero_node, result);\n+\t  result = size_diffop_loc (input_location,\n+\t\t\t\tsize_zero_node, result);\n \telse\n \t  {\n \t    error_not_base_type (from, to);"}, {"sha": "aafa1aaca4a153b49b81e1288b0bf2e16bc7b8e8", "filename": "gcc/expr.c", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -4486,6 +4486,7 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n   rtx temp;\n   rtx alt_rtl = NULL_RTX;\n   int dont_return_target = 0;\n+  location_t loc = EXPR_LOCATION (exp);\n \n   if (VOID_TYPE_P (TREE_TYPE (exp)))\n     {\n@@ -4561,13 +4562,13 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t\t  (TYPE_MODE (TREE_TYPE (exp)),\n \t\t   SUBREG_PROMOTED_UNSIGNED_P (target));\n \n-\t      exp = fold_convert (ntype, exp);\n+\t      exp = fold_convert_loc (loc, ntype, exp);\n \t    }\n \n-\t  exp = fold_convert (lang_hooks.types.type_for_mode\n-\t\t\t\t(GET_MODE (SUBREG_REG (target)),\n-\t\t\t\t SUBREG_PROMOTED_UNSIGNED_P (target)),\n-\t\t\t      exp);\n+\t  exp = fold_convert_loc (loc, lang_hooks.types.type_for_mode\n+\t\t\t\t  (GET_MODE (SUBREG_REG (target)),\n+\t\t\t\t   SUBREG_PROMOTED_UNSIGNED_P (target)),\n+\t\t\t\t  exp);\n \n \t  inner_target = SUBREG_REG (target);\n \t}\n@@ -4741,9 +4742,9 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t    {\n \t      /* Compute the size of the data to copy from the string.  */\n \t      tree copy_size\n-\t\t= size_binop (MIN_EXPR,\n-\t\t\t      make_tree (sizetype, size),\n-\t\t\t      size_int (TREE_STRING_LENGTH (exp)));\n+\t\t= size_binop_loc (loc, MIN_EXPR,\n+\t\t\t\t  make_tree (sizetype, size),\n+\t\t\t\t  size_int (TREE_STRING_LENGTH (exp)));\n \t      rtx copy_size_rtx\n \t\t= expand_expr (copy_size, NULL_RTX, VOIDmode,\n \t\t\t       (call_param_p\n@@ -6171,6 +6172,7 @@ array_ref_element_size (tree exp)\n {\n   tree aligned_size = TREE_OPERAND (exp, 3);\n   tree elmt_type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+  location_t loc = EXPR_LOCATION (exp);\n \n   /* If a size was specified in the ARRAY_REF, it's the size measured\n      in alignment units of the element type.  So multiply by that value.  */\n@@ -6179,9 +6181,9 @@ array_ref_element_size (tree exp)\n       /* ??? tree_ssa_useless_type_conversion will eliminate casts to\n \t sizetype from another type of the same width and signedness.  */\n       if (TREE_TYPE (aligned_size) != sizetype)\n-\taligned_size = fold_convert (sizetype, aligned_size);\n-      return size_binop (MULT_EXPR, aligned_size,\n-\t\t         size_int (TYPE_ALIGN_UNIT (elmt_type)));\n+\taligned_size = fold_convert_loc (loc, sizetype, aligned_size);\n+      return size_binop_loc (loc, MULT_EXPR, aligned_size,\n+\t\t\t     size_int (TYPE_ALIGN_UNIT (elmt_type)));\n     }\n \n   /* Otherwise, take the size from that of the element type.  Substitute\n@@ -6236,6 +6238,7 @@ component_ref_field_offset (tree exp)\n {\n   tree aligned_offset = TREE_OPERAND (exp, 2);\n   tree field = TREE_OPERAND (exp, 1);\n+  location_t loc = EXPR_LOCATION (exp);\n \n   /* If an offset was specified in the COMPONENT_REF, it's the offset measured\n      in units of DECL_OFFSET_ALIGN / BITS_PER_UNIT.  So multiply by that\n@@ -6245,9 +6248,10 @@ component_ref_field_offset (tree exp)\n       /* ??? tree_ssa_useless_type_conversion will eliminate casts to\n \t sizetype from another type of the same width and signedness.  */\n       if (TREE_TYPE (aligned_offset) != sizetype)\n-\taligned_offset = fold_convert (sizetype, aligned_offset);\n-      return size_binop (MULT_EXPR, aligned_offset,\n-\t\t         size_int (DECL_OFFSET_ALIGN (field) / BITS_PER_UNIT));\n+\taligned_offset = fold_convert_loc (loc, sizetype, aligned_offset);\n+      return size_binop_loc (loc, MULT_EXPR, aligned_offset,\n+\t\t\t     size_int (DECL_OFFSET_ALIGN (field)\n+\t\t\t\t       / BITS_PER_UNIT));\n     }\n \n   /* Otherwise, take the offset from that of the field.  Substitute\n@@ -6755,7 +6759,7 @@ emutls_var_address (tree var)\n   tree fn = built_in_decls [BUILT_IN_EMUTLS_GET_ADDRESS];\n   tree arg = build_fold_addr_expr_with_type (emuvar, ptr_type_node);\n   tree arglist = build_tree_list (NULL_TREE, arg);\n-  tree call = build_function_call_expr (fn, arglist);\n+  tree call = build_function_call_expr (UNKNOWN_LOCATION, fn, arglist);\n   return fold_convert (build_pointer_type (TREE_TYPE (var)), call);\n }\n \f\n@@ -7221,6 +7225,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n   bool reduce_bit_field;\n   gimple subexp0_def, subexp1_def;\n   tree top0, top1;\n+  location_t loc = EXPR_LOCATION (exp);\n #define REDUCE_BIT_FIELD(expr)\t(reduce_bit_field\t\t\t  \\\n \t\t\t\t ? reduce_to_bit_field_precision ((expr), \\\n \t\t\t\t\t\t\t\t  target, \\\n@@ -7347,7 +7352,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  && TREE_CODE (exp) == VAR_DECL\n \t  && DECL_THREAD_LOCAL_P (exp))\n \t{\n-\t  exp = build_fold_indirect_ref (emutls_var_address (exp));\n+\t  exp = build_fold_indirect_ref_loc (loc, emutls_var_address (exp));\n \t  return expand_expr_real_1 (exp, target, tmode, modifier, NULL);\n \t}\n \n@@ -7457,7 +7462,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  {\n \t    tree type_for_mode = lang_hooks.types.type_for_mode (mode, 1);\n \t    if (type_for_mode)\n-\t      tmp = fold_unary (VIEW_CONVERT_EXPR, type_for_mode, exp);\n+\t      tmp = fold_unary_loc (loc, VIEW_CONVERT_EXPR, type_for_mode, exp);\n \t  }\n \tif (!tmp)\n \t  tmp = build_constructor_from_list (type,\n@@ -7738,7 +7743,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t  {\n \t\t    tree index1 = index;\n \t\t    tree low_bound = array_ref_low_bound (exp);\n-\t\t    index1 = fold_convert (sizetype, TREE_OPERAND (exp, 1));\n+\t\t    index1 = fold_convert_loc (loc, sizetype,\n+\t\t\t\t\t       TREE_OPERAND (exp, 1));\n \n \t\t    /* Optimize the special-case of a zero lower bound.\n \n@@ -7749,8 +7755,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t       +INDEX), which becomes (ARRAY+255+INDEX).  Opps!)  */\n \n \t\t    if (! integer_zerop (low_bound))\n-\t\t      index1 = size_diffop (index1, fold_convert (sizetype,\n-\t\t\t\t\t\t\t\t  low_bound));\n+\t\t      index1 = size_diffop_loc (loc, index1,\n+\t\t\t\t\t    fold_convert_loc (loc, sizetype,\n+\t\t\t\t\t\t\t      low_bound));\n \n \t\t    if (0 > compare_tree_int (index1,\n \t\t\t\t\t      TREE_STRING_LENGTH (init)))\n@@ -8403,11 +8410,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* Make sure to sign-extend the sizetype offset in a POINTER_PLUS_EXPR\n          if sizetype precision is smaller than pointer precision.  */\n       if (TYPE_PRECISION (sizetype) < TYPE_PRECISION (type))\n-\texp = build2 (PLUS_EXPR, type,\n-\t\t      TREE_OPERAND (exp, 0),\n-\t\t      fold_convert (type,\n-\t\t\t\t    fold_convert (ssizetype,\n-\t\t\t\t\t\t  TREE_OPERAND (exp, 1))));\n+\texp\n+\t  = build2 (PLUS_EXPR, type,\n+\t\t    TREE_OPERAND (exp, 0),\n+\t\t    fold_convert_loc (loc, type,\n+\t\t\t\t      fold_convert_loc (loc, ssizetype,\n+\t\t\t\t\t\t\tTREE_OPERAND (exp, 1))));\n     case PLUS_EXPR:\n \n       /* Check if this is a case for multiplication and addition.  */\n@@ -9738,6 +9746,7 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode)\n   int unsignedp;\n   rtx op0, op1;\n   rtx subtarget = target;\n+  location_t loc = EXPR_LOCATION (exp);\n \n   arg0 = TREE_OPERAND (exp, 0);\n   arg1 = TREE_OPERAND (exp, 1);\n@@ -9862,7 +9871,8 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode)\n       && integer_pow2p (TREE_OPERAND (arg0, 1)))\n     {\n       tree type = lang_hooks.types.type_for_mode (mode, unsignedp);\n-      return expand_expr (fold_single_bit_test (code == NE ? NE_EXPR : EQ_EXPR,\n+      return expand_expr (fold_single_bit_test (loc,\n+\t\t\t\t\t\tcode == NE ? NE_EXPR : EQ_EXPR,\n \t\t\t\t\t\targ0, arg1, type),\n \t\t\t  target, VOIDmode, EXPAND_NORMAL);\n     }"}, {"sha": "803c7a549afbfa4ec6293bc3ec835abfb5ec1b97", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1648, "deletions": 1283, "changes": 2931, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92"}, {"sha": "953e681dd8ef6c0624583cb85ca67006f2d0e14b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1,3 +1,21 @@\n+2009-07-17  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR 40435 \n+\t* trans-expr.c, trans-array.c, trans-openmp.c, trans-stmt.c,\n+\ttrans.c, trans-io.c, trans-decl.c, trans-intrinsic.c: Add location\n+\targument to fold_{unary,binary,ternary}, fold_build[123],\n+\tbuild_call_expr, build_size_arg, build_fold_addr_expr,\n+\tbuild_call_array, non_lvalue, size_diffop,\n+\tfold_build1_initializer, fold_build2_initializer,\n+\tfold_build3_initializer, fold_build_call_array,\n+\tfold_build_call_array_initializer, fold_single_bit_test,\n+\tomit_one_operand, omit_two_operands, invert_truthvalue,\n+\tfold_truth_not_expr, build_fold_indirect_ref, fold_indirect_ref,\n+\tcombine_comparisons, fold_builtin_*, fold_call_expr,\n+\tbuild_range_check, maybe_fold_offset_to_address, round_up,\n+\tround_down.\n+\n 2009-07-15  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/40743"}, {"sha": "270835556bac01e0bbb80202d8312326ed024182", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -620,11 +620,13 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n \t      gcc_assert (tmp == gfc_get_element_type (TREE_TYPE (desc)));\n \t      packed = gfc_create_var (build_pointer_type (tmp), \"data\");\n \n-\t      tmp = build_call_expr (gfor_fndecl_in_pack, 1, initial);\n+\t      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t     gfor_fndecl_in_pack, 1, initial);\n \t      tmp = fold_convert (TREE_TYPE (packed), tmp);\n \t      gfc_add_modify (pre, packed, tmp);\n \n-\t      tmp = build_fold_indirect_ref (initial);\n+\t      tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t     initial);\n \t      source_data = gfc_conv_descriptor_data_get (tmp);\n \n \t      /* internal_pack may return source->data without any allocation\n@@ -1084,7 +1086,8 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n   gfc_conv_expr (se, expr);\n \n   /* Store the value.  */\n-  tmp = build_fold_indirect_ref (gfc_conv_descriptor_data_get (desc));\n+  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t gfc_conv_descriptor_data_get (desc));\n   tmp = gfc_build_array_ref (tmp, offset, NULL);\n \n   if (expr->ts.type == BT_CHARACTER)\n@@ -1353,14 +1356,16 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \n \t      /* Use BUILTIN_MEMCPY to assign the values.  */\n \t      tmp = gfc_conv_descriptor_data_get (desc);\n-\t      tmp = build_fold_indirect_ref (tmp);\n+\t      tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t     tmp);\n \t      tmp = gfc_build_array_ref (tmp, *poffset, NULL);\n \t      tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n \t      init = gfc_build_addr_expr (NULL_TREE, init);\n \n \t      size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type));\n \t      bound = build_int_cst (NULL_TREE, n * size);\n-\t      tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t     built_in_decls[BUILT_IN_MEMCPY], 3,\n \t\t\t\t     tmp, init, bound);\n \t      gfc_add_expr_to_block (&body, tmp);\n \n@@ -2408,7 +2413,8 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \t\t\t       index, gfc_conv_array_stride (desc, 0));\n \n \t  /* Read the vector to get an index into info->descriptor.  */\n-\t  data = build_fold_indirect_ref (gfc_conv_array_data (desc));\n+\t  data = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t  gfc_conv_array_data (desc));\n \t  index = gfc_build_array_ref (data, index, NULL);\n \t  index = gfc_evaluate_now (index, &se->pre);\n \n@@ -2482,7 +2488,8 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n   if (se->ss->expr && is_subref_array (se->ss->expr))\n     decl = se->ss->expr->symtree->n.sym->backend_decl;\n \n-  tmp = build_fold_indirect_ref (info->data);\n+  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t info->data);\n   se->expr = gfc_build_array_ref (tmp, index, decl);\n }\n \n@@ -4461,7 +4468,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   type = TREE_TYPE (tmpdesc);\n   gcc_assert (GFC_ARRAY_TYPE_P (type));\n   dumdesc = GFC_DECL_SAVED_DESCRIPTOR (tmpdesc);\n-  dumdesc = build_fold_indirect_ref (dumdesc);\n+  dumdesc = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t     dumdesc);\n   gfc_start_block (&block);\n \n   if (sym->ts.type == BT_CHARACTER\n@@ -4513,7 +4521,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       gcc_assert (integer_onep (GFC_TYPE_ARRAY_STRIDE (type, 0)));\n       /* A library call to repack the array if necessary.  */\n       tmp = GFC_DECL_SAVED_DESCRIPTOR (tmpdesc);\n-      stmt_unpacked = build_call_expr (gfor_fndecl_in_pack, 1, tmp);\n+      stmt_unpacked = build_call_expr_loc (input_location,\n+\t\t\t\t       gfor_fndecl_in_pack, 1, tmp);\n \n       stride = gfc_index_one_node;\n \n@@ -4699,7 +4708,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       if (sym->attr.intent != INTENT_IN)\n \t{\n \t  /* Copy the data back.  */\n-\t  tmp = build_call_expr (gfor_fndecl_in_unpack, 2, dumdesc, tmpdesc);\n+\t  tmp = build_call_expr_loc (input_location,\n+\t\t\t\t gfor_fndecl_in_unpack, 2, dumdesc, tmpdesc);\n \t  gfc_add_expr_to_block (&cleanup, tmp);\n \t}\n \n@@ -4710,7 +4720,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       stmt = gfc_finish_block (&cleanup);\n \t\n       /* Only do the cleanup if the array was repacked.  */\n-      tmp = build_fold_indirect_ref (dumdesc);\n+      tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t     dumdesc);\n       tmp = gfc_conv_descriptor_data_get (tmp);\n       tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp, tmpdesc);\n       stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt (input_location));\n@@ -4753,7 +4764,8 @@ gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,\n     }\n \n   tmp = gfc_conv_array_data (desc);\n-  tmp = build_fold_indirect_ref (tmp);\n+  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t tmp);\n   tmp = gfc_build_array_ref (tmp, offset, NULL);\n \n   /* Offset the data pointer for pointer assignments from arrays with\n@@ -5178,7 +5190,8 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t{\n \t  gfc_conv_expr (&rse, expr);\n \t  if (POINTER_TYPE_P (TREE_TYPE (rse.expr)))\n-\t    rse.expr = build_fold_indirect_ref (rse.expr);\n+\t    rse.expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\trse.expr);\n \t}\n       else\n         gfc_conv_expr_val (&rse, expr);\n@@ -5408,7 +5421,8 @@ array_parameter_size (tree desc, gfc_expr *expr, tree *size)\n   if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n     *size = GFC_TYPE_ARRAY_SIZE (TREE_TYPE (desc));\n   else if (expr->rank > 1)\n-    *size = build_call_expr (gfor_fndecl_size0, 1,\n+    *size = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_size0, 1,\n \t\t\t     gfc_build_addr_expr (NULL, desc));\n   else\n     {\n@@ -5509,7 +5523,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n \n       if (g77 && TREE_TYPE (TREE_TYPE (se->expr)) != NULL_TREE\n \t      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (se->expr))))\n-\tse->expr = gfc_conv_array_data (build_fold_indirect_ref (se->expr));\n+\tse->expr = gfc_conv_array_data (build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\t\t se->expr));\n \n       return;\n     }\n@@ -5519,7 +5534,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n       se->want_pointer = 1;\n       gfc_conv_expr_descriptor (se, expr, ss);\n       if (size)\n-\tarray_parameter_size (build_fold_indirect_ref (se->expr),\n+\tarray_parameter_size (build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t       se->expr),\n \t\t\t\t  expr, size);\n     }\n \n@@ -5529,7 +5545,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n \t&& expr->ts.derived->attr.alloc_comp\n \t&& expr->expr_type != EXPR_VARIABLE)\n     {\n-      tmp = build_fold_indirect_ref (se->expr);\n+      tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t     se->expr);\n       tmp = gfc_deallocate_alloc_comp (expr->ts.derived, tmp, expr->rank);\n       gfc_add_expr_to_block (&se->post, tmp);\n     }\n@@ -5548,7 +5565,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n \t    gfc_warning (\"Creating array temporary at %L\", &expr->where);\n \t}\n \n-      ptr = build_call_expr (gfor_fndecl_in_pack, 1, desc);\n+      ptr = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_in_pack, 1, desc);\n \n       if (fsym && fsym->attr.optional && sym && sym->attr.optional)\n \t{\n@@ -5572,7 +5590,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n \t  else\n \t    asprintf (&msg, \"An array temporary was created\");\n \n-\t  tmp = build_fold_indirect_ref (desc);\n+\t  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t desc);\n \t  tmp = gfc_conv_array_data (tmp);\n \t  tmp = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t     fold_convert (TREE_TYPE (tmp), ptr), tmp);\n@@ -5591,7 +5610,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n       /* Copy the data back.  */\n       if (fsym == NULL || fsym->attr.intent != INTENT_IN)\n \t{\n-\t  tmp = build_call_expr (gfor_fndecl_in_unpack, 2, desc, ptr);\n+\t  tmp = build_call_expr_loc (input_location,\n+\t\t\t\t gfor_fndecl_in_unpack, 2, desc, ptr);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n \n@@ -5604,7 +5624,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n       gfc_init_block (&block);\n       /* Only if it was repacked.  This code needs to be executed before the\n          loop cleanup code.  */\n-      tmp = build_fold_indirect_ref (desc);\n+      tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t     desc);\n       tmp = gfc_conv_array_data (tmp);\n       tmp = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t fold_convert (TREE_TYPE (tmp), ptr), tmp);\n@@ -5707,7 +5728,8 @@ gfc_duplicate_allocatable(tree dest, tree src, tree type, int rank)\n   /* We know the temporary and the value will be the same length,\n      so can use memcpy.  */\n   tmp = built_in_decls[BUILT_IN_MEMCPY];\n-  tmp = build_call_expr (tmp, 3, gfc_conv_descriptor_data_get (dest),\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t tmp, 3, gfc_conv_descriptor_data_get (dest),\n   \t\t\t gfc_conv_descriptor_data_get (src), size);\n   gfc_add_expr_to_block (&block, tmp);\n   tmp = gfc_finish_block (&block);\n@@ -5750,15 +5772,17 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n   gfc_init_block (&fnblock);\n \n   if (POINTER_TYPE_P (TREE_TYPE (decl)))\n-    decl = build_fold_indirect_ref (decl);\n+    decl = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t    decl);\n \n   /* If this an array of derived types with allocatable components\n      build a loop and recursively call this function.  */\n   if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n \t|| GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n     {\n       tmp = gfc_conv_array_data (decl);\n-      var = build_fold_indirect_ref (tmp);\n+      var = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t     tmp);\n \t\n       /* Get the number of elements - 1 and set the counter.  */\n       if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n@@ -5797,7 +5821,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      tmp = gfc_duplicate_allocatable (dest, decl, TREE_TYPE(decl), rank);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n-\t  tmp = build_fold_indirect_ref (gfc_conv_array_data (dest));\n+\t  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t gfc_conv_array_data (dest));\n \t  dref = gfc_build_array_ref (tmp, index, NULL);\n \t  tmp = structure_alloc_comps (der_type, vref, dref, rank, purpose);\n \t}\n@@ -6022,7 +6047,8 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n     {\n       /* If the backend_decl is not a descriptor, we must have a pointer\n \t to one.  */\n-      descriptor = build_fold_indirect_ref (sym->backend_decl);\n+      descriptor = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t    sym->backend_decl);\n       type = TREE_TYPE (descriptor);\n     }\n   "}, {"sha": "5ea24c54b458fb16fced158371582a1f753feaf8", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -408,7 +408,8 @@ gfc_finish_cray_pointee (tree decl, gfc_symbol *sym)\n \n   /* Parameters need to be dereferenced.  */\n   if (sym->cp_pointer->attr.dummy) \n-    ptr_decl = build_fold_indirect_ref (ptr_decl);\n+    ptr_decl = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\tptr_decl);\n \n   /* Check to see if we're dealing with a variable-sized array.  */\n   if (sym->attr.dimension\n@@ -422,7 +423,8 @@ gfc_finish_cray_pointee (tree decl, gfc_symbol *sym)\n     {\n       ptr_decl = convert (build_pointer_type (TREE_TYPE (decl)),\n \t\t\t  ptr_decl);\n-      value = build_fold_indirect_ref (ptr_decl);\n+      value = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t       ptr_decl);\n     }\n \n   SET_DECL_VALUE_EXPR (decl, value);\n@@ -1991,7 +1993,7 @@ build_entry_thunks (gfc_namespace * ns)\n       args = nreverse (args);\n       args = chainon (args, nreverse (string_args));\n       tmp = ns->proc_name->backend_decl;\n-      tmp = build_function_call_expr (tmp, args);\n+      tmp = build_function_call_expr (input_location, tmp, args);\n       if (ns->proc_name->attr.mixed_entry_master)\n \t{\n \t  tree union_decl, field;\n@@ -4012,7 +4014,8 @@ create_main_function (tree fndecl)\n   /* Call _gfortran_set_args (argc, argv).  */\n   TREE_USED (argc) = 1;\n   TREE_USED (argv) = 1;\n-  tmp = build_call_expr (gfor_fndecl_set_args, 2, argc, argv);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t gfor_fndecl_set_args, 2, argc, argv);\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Add a call to set_options to set up the runtime library Fortran\n@@ -4060,7 +4063,8 @@ create_main_function (tree fndecl)\n     DECL_INITIAL (var) = array;\n     var = gfc_build_addr_expr (build_pointer_type (integer_type_node), var);\n \n-    tmp = build_call_expr (gfor_fndecl_set_options, 2,\n+    tmp = build_call_expr_loc (input_location,\n+\t\t\t   gfor_fndecl_set_options, 2,\n \t\t\t   build_int_cst (integer_type_node, 8), var);\n     gfc_add_expr_to_block (&body, tmp);\n   }\n@@ -4069,7 +4073,8 @@ create_main_function (tree fndecl)\n      the library will raise a FPE when needed.  */\n   if (gfc_option.fpe != 0)\n     {\n-      tmp = build_call_expr (gfor_fndecl_set_fpe, 1,\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_set_fpe, 1,\n \t\t\t     build_int_cst (integer_type_node,\n \t\t\t\t\t    gfc_option.fpe));\n       gfc_add_expr_to_block (&body, tmp);\n@@ -4080,7 +4085,8 @@ create_main_function (tree fndecl)\n \n   if (gfc_option.convert != GFC_CONVERT_NATIVE)\n     {\n-      tmp = build_call_expr (gfor_fndecl_set_convert, 1,\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_set_convert, 1,\n \t\t\t     build_int_cst (integer_type_node,\n \t\t\t\t\t    gfc_option.convert));\n       gfc_add_expr_to_block (&body, tmp);\n@@ -4091,22 +4097,25 @@ create_main_function (tree fndecl)\n \n   if (gfc_option.record_marker != 0)\n     {\n-      tmp = build_call_expr (gfor_fndecl_set_record_marker, 1,\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_set_record_marker, 1,\n \t\t\t     build_int_cst (integer_type_node,\n \t\t\t\t\t    gfc_option.record_marker));\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n   if (gfc_option.max_subrecord_length != 0)\n     {\n-      tmp = build_call_expr (gfor_fndecl_set_max_subrecord_length, 1,\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_set_max_subrecord_length, 1,\n \t\t\t     build_int_cst (integer_type_node,\n \t\t\t\t\t    gfc_option.max_subrecord_length));\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n   /* Call MAIN__().  */\n-  tmp = build_call_expr (fndecl, 0);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t fndecl, 0);\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Mark MAIN__ as used.  */\n@@ -4461,7 +4470,8 @@ gfc_generate_constructors (void)\n \n   for (; gfc_static_ctors; gfc_static_ctors = TREE_CHAIN (gfc_static_ctors))\n     {\n-      tmp = build_call_expr (TREE_VALUE (gfc_static_ctors), 0);\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     TREE_VALUE (gfc_static_ctors), 0);\n       DECL_SAVED_TREE (fndecl) = build_stmt (input_location, EXPR_STMT, tmp);\n     }\n "}, {"sha": "03902420e045aa262951040c319596421b12e499", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 63, "deletions": 32, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -158,7 +158,8 @@ gfc_conv_missing_dummy (gfc_se * se, gfc_expr * arg, gfc_typespec ts, int kind)\n     {\n       /* Create a temporary and convert it to the correct type.  */\n       tmp = gfc_get_int_type (kind);\n-      tmp = fold_convert (tmp, build_fold_indirect_ref (se->expr));\n+      tmp = fold_convert (tmp, build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\tse->expr));\n     \n       /* Test for a NULL value.  */\n       tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present, tmp,\n@@ -381,7 +382,8 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       if (TYPE_STRING_FLAG (TREE_TYPE (se->expr)))\n \ttmp = se->expr;\n       else\n-\ttmp = build_fold_indirect_ref (se->expr);\n+\ttmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t       se->expr);\n       tmp = gfc_build_array_ref (tmp, start.expr, NULL);\n       se->expr = gfc_build_addr_expr (type, tmp);\n     }\n@@ -478,7 +480,8 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n \n   if ((c->attr.pointer && c->attr.dimension == 0 && c->ts.type != BT_CHARACTER)\n       || c->attr.proc_pointer)\n-    se->expr = build_fold_indirect_ref (se->expr);\n+    se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\tse->expr);\n }\n \n \n@@ -621,21 +624,24 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t      && (sym->attr.dummy\n \t\t  || sym->attr.function\n \t\t  || sym->attr.result))\n-\t    se->expr = build_fold_indirect_ref (se->expr);\n+\t    se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\tse->expr);\n \n \t}\n       else if (!sym->attr.value)\n \t{\n           /* Dereference non-character scalar dummy arguments.  */\n \t  if (sym->attr.dummy && !sym->attr.dimension)\n-\t    se->expr = build_fold_indirect_ref (se->expr);\n+\t    se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\tse->expr);\n \n           /* Dereference scalar hidden result.  */\n \t  if (gfc_option.flag_f2c && sym->ts.type == BT_COMPLEX\n \t      && (sym->attr.function || sym->attr.result)\n \t      && !sym->attr.dimension && !sym->attr.pointer\n \t      && !sym->attr.always_explicit)\n-\t    se->expr = build_fold_indirect_ref (se->expr);\n+\t    se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\tse->expr);\n \n           /* Dereference non-character pointer variables. \n \t     These must be dummies, results, or scalars.  */\n@@ -644,7 +650,8 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t\t  || sym->attr.function\n \t\t  || sym->attr.result\n \t\t  || !sym->attr.dimension))\n-\t    se->expr = build_fold_indirect_ref (se->expr);\n+\t    se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\tse->expr);\n \t}\n \n       ref = expr->ref;\n@@ -1080,7 +1087,8 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n       break;\n     }\n \n-  se->expr = build_call_expr (fndecl, 2, lse.expr, rse.expr);\n+  se->expr = build_call_expr_loc (input_location,\n+\t\t\t      fndecl, 2, lse.expr, rse.expr);\n }\n \n \n@@ -1171,7 +1179,8 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n   else\n     gcc_unreachable ();\n \n-  tmp = build_call_expr (fndecl, 6, len, var, lse.string_length, lse.expr,\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t fndecl, 6, len, var, lse.string_length, lse.expr,\n \t\t\t rse.string_length, rse.expr);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -1378,7 +1387,8 @@ string_to_single_character (tree len, tree str, int kind)\n       && TREE_INT_CST_HIGH (len) == 0)\n     {\n       str = fold_convert (gfc_get_pchar_type (kind), str);\n-      return build_fold_indirect_ref (str);\n+      return build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t      str);\n     }\n \n   return NULL_TREE;\n@@ -1481,7 +1491,8 @@ gfc_build_compare_string (tree len1, tree str1, tree len2, tree str2, int kind)\n       else\n \tgcc_unreachable ();\n \n-      tmp = build_call_expr (fndecl, 4, len1, str1, len2, str2);\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     fndecl, 4, len1, str1, len2, str2);\n     }\n \n   return tmp;\n@@ -1498,7 +1509,8 @@ conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)\n     {\n       tmp = gfc_get_symbol_decl (sym);\n       if (sym->attr.proc_pointer)\n-        tmp = build_fold_indirect_ref (tmp);\n+        tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t       tmp);\n       gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE\n \t      && TREE_CODE (TREE_TYPE (TREE_TYPE (tmp))) == FUNCTION_TYPE);\n     }\n@@ -1738,7 +1750,8 @@ gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n       tmp = gfc_get_character_type_len (sym->ts.kind, NULL);\n       tmp = build_pointer_type (tmp);\n       if (sym->attr.pointer)\n-        value = build_fold_indirect_ref (se->expr);\n+        value = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t se->expr);\n       else\n         value = se->expr;\n       value = fold_convert (tmp, value);\n@@ -1747,19 +1760,22 @@ gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n   /* If the argument is a scalar, a pointer to an array or an allocatable,\n      dereference it.  */\n   else if (!sym->attr.dimension || sym->attr.pointer || sym->attr.allocatable)\n-    value = build_fold_indirect_ref (se->expr);\n+    value = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t     se->expr);\n   \n   /* For character(*), use the actual argument's descriptor.  */  \n   else if (sym->ts.type == BT_CHARACTER && !new_sym->ts.cl->length)\n-    value = build_fold_indirect_ref (se->expr);\n+    value = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t     se->expr);\n \n   /* If the argument is an array descriptor, use it to determine\n      information about the actual argument's shape.  */\n   else if (POINTER_TYPE_P (TREE_TYPE (se->expr))\n \t   && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (se->expr))))\n     {\n       /* Get the actual argument's descriptor.  */\n-      desc = build_fold_indirect_ref (se->expr);\n+      desc = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t      se->expr);\n \n       /* Create the replacement variable.  */\n       tmp = gfc_conv_descriptor_data_get (desc);\n@@ -2294,7 +2310,8 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n \t\t\t   rse.loop->loopvar[0], offset);\n \n   /* Now use the offset for the reference.  */\n-  tmp = build_fold_indirect_ref (info->data);\n+  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t info->data);\n   rse.expr = gfc_build_array_ref (tmp, tmp_index, NULL);\n \n   if (expr->ts.type == BT_CHARACTER)\n@@ -2703,7 +2720,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n               if (fsym && fsym->attr.allocatable\n                   && fsym->attr.intent == INTENT_OUT)\n                 {\n-                  tmp = build_fold_indirect_ref (parmse.expr);\n+                  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t parmse.expr);\n                   tmp = gfc_trans_dealloc_allocated (tmp);\n                   gfc_add_expr_to_block (&se->pre, tmp);\n                 }\n@@ -2757,7 +2775,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    && (e->expr_type != EXPR_VARIABLE && !e->rank))\n         {\n \t  int parm_rank;\n-\t  tmp = build_fold_indirect_ref (parmse.expr);\n+\t  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t parmse.expr);\n \t  parm_rank = e->rank;\n \t  switch (parm_kind)\n \t    {\n@@ -2767,7 +2786,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      break;\n \n \t    case (SCALAR_POINTER):\n-              tmp = build_fold_indirect_ref (tmp);\n+              tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t     tmp);\n \t      break;\n \t    }\n \n@@ -2948,7 +2968,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t&& TREE_TYPE (TREE_TYPE (TREE_TYPE (se->expr)))\n \t\t&& GFC_DESCRIPTOR_TYPE_P\n \t\t\t(TREE_TYPE (TREE_TYPE (TREE_TYPE (se->expr)))))\n-\t    se->expr = build_fold_indirect_ref (se->expr);\n+\t    se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\tse->expr);\n \n \t  retargs = gfc_chainon_list (retargs, se->expr);\n \t}\n@@ -3076,7 +3097,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n      where f is pointer valued, we have to dereference the result.  */\n   if (!se->want_pointer && !byref && sym->attr.pointer\n       && !gfc_is_proc_ptr_comp (expr, NULL))\n-    se->expr = build_fold_indirect_ref (se->expr);\n+    se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\tse->expr);\n \n   /* f2c calling conventions require a scalar default real function to\n      return a double precision result.  Convert this back to default\n@@ -3123,7 +3145,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    {\n \t      /* Dereference for character pointer results.  */\n \t      if (sym->attr.pointer || sym->attr.allocatable)\n-\t\tse->expr = build_fold_indirect_ref (var);\n+\t\tse->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t    var);\n \t      else\n \t        se->expr = var;\n \n@@ -3132,7 +3155,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  else\n \t    {\n \t      gcc_assert (sym->ts.type == BT_COMPLEX && gfc_option.flag_f2c);\n-\t      se->expr = build_fold_indirect_ref (var);\n+\t      se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t  var);\n \t    }\n \t}\n     }\n@@ -3157,7 +3181,8 @@ fill_with_spaces (tree start, tree type, tree size)\n \n   /* For a simple char type, we can call memset().  */\n   if (compare_tree_int (TYPE_SIZE_UNIT (type), 1) == 0)\n-    return build_call_expr (built_in_decls[BUILT_IN_MEMSET], 3, start,\n+    return build_call_expr_loc (input_location,\n+\t\t\t    built_in_decls[BUILT_IN_MEMSET], 3, start,\n \t\t\t    build_int_cst (gfc_get_int_type (gfc_c_int_kind),\n \t\t\t\t\t   lang_hooks.to_target_charset (' ')),\n \t\t\t    size);\n@@ -3318,11 +3343,13 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n \n   /* Truncate string if source is too long.  */\n   cond2 = fold_build2 (GE_EXPR, boolean_type_node, slen, dlen);\n-  tmp2 = build_call_expr (built_in_decls[BUILT_IN_MEMMOVE],\n+  tmp2 = build_call_expr_loc (input_location,\n+\t\t\t  built_in_decls[BUILT_IN_MEMMOVE],\n \t\t\t  3, dest, src, dlen);\n \n   /* Else copy and pad with spaces.  */\n-  tmp3 = build_call_expr (built_in_decls[BUILT_IN_MEMMOVE],\n+  tmp3 = build_call_expr_loc (input_location,\n+\t\t\t  built_in_decls[BUILT_IN_MEMMOVE],\n \t\t\t  3, dest, src, slen);\n \n   tmp4 = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (dest), dest,\n@@ -3465,7 +3492,7 @@ gfc_get_proc_ptr_comp (gfc_se *se, gfc_expr *e)\n   e2 = gfc_copy_expr (e);\n   e2->expr_type = EXPR_VARIABLE;\n   gfc_conv_expr (&comp_se, e2);\n-  comp_se.expr = build_fold_addr_expr (comp_se.expr);\n+  comp_se.expr = build_fold_addr_expr_loc (input_location, comp_se.expr);\n   return gfc_evaluate_now (comp_se.expr, &se->pre);  \n }\n \n@@ -4192,11 +4219,13 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \n       if (expr1->symtree->n.sym->attr.proc_pointer\n \t  && expr1->symtree->n.sym->attr.dummy)\n-\tlse.expr = build_fold_indirect_ref (lse.expr);\n+\tlse.expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t    lse.expr);\n \n       if (expr2->symtree && expr2->symtree->n.sym->attr.proc_pointer\n \t  && expr2->symtree->n.sym->attr.dummy)\n-\trse.expr = build_fold_indirect_ref (rse.expr);\n+\trse.expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t    rse.expr);\n \n       gfc_add_block_to_block (&block, &lse.pre);\n       gfc_add_block_to_block (&block, &rse.pre);\n@@ -4594,7 +4623,8 @@ gfc_trans_zero_assign (gfc_expr * expr)\n   len = fold_convert (size_type_node, len);\n \n   /* Construct call to __builtin_memset.  */\n-  tmp = build_call_expr (built_in_decls[BUILT_IN_MEMSET],\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[BUILT_IN_MEMSET],\n \t\t\t 3, dest, integer_zero_node, len);\n   return fold_convert (void_type_node, tmp);\n }\n@@ -4622,7 +4652,8 @@ gfc_build_memcpy_call (tree dst, tree src, tree len)\n   len = fold_convert (size_type_node, len);\n \n   /* Construct call to __builtin_memcpy.  */\n-  tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3, dst, src, len);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[BUILT_IN_MEMCPY], 3, dst, src, len);\n   return fold_convert (void_type_node, tmp);\n }\n "}, {"sha": "bf8768e05720a9bed43e60d7ce8c833d34d19971", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 104, "deletions": 54, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -273,7 +273,8 @@ gfc_conv_intrinsic_conversion (gfc_se * se, gfc_expr * expr)\n \n       /* Call the library function that will perform the conversion.  */\n       gcc_assert (nargs >= 2);\n-      tmp = build_call_expr (fndecl, 3, addr, args[0], args[1]);\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     fndecl, 3, addr, args[0], args[1]);\n       gfc_add_expr_to_block (&se->pre, tmp);\n \n       /* Free the temporary afterwards.  */\n@@ -363,7 +364,8 @@ build_round_expr (tree arg, tree restype)\n   else\n     gcc_unreachable ();\n \n-  return fold_convert (restype, build_call_expr (fn, 1, arg));\n+  return fold_convert (restype, build_call_expr_loc (input_location,\n+\t\t\t\t\t\t fn, 1, arg));\n }\n \n \n@@ -475,7 +477,8 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n   if (n != END_BUILTINS)\n     {\n       tmp = built_in_decls[n];\n-      se->expr = build_call_expr (tmp, 1, arg[0]);\n+      se->expr = build_call_expr_loc (input_location,\n+\t\t\t\t  tmp, 1, arg[0]);\n       return;\n     }\n \n@@ -745,7 +748,7 @@ gfc_conv_intrinsic_lib_function (gfc_se * se, gfc_expr * expr)\n   rettype = TREE_TYPE (TREE_TYPE (fndecl));\n \n   fndecl = build_addr (fndecl, current_function_decl);\n-  se->expr = build_call_array (rettype, fndecl, num_args, args);\n+  se->expr = build_call_array_loc (input_location, rettype, fndecl, num_args, args);\n }\n \n \n@@ -808,7 +811,8 @@ gfc_conv_intrinsic_exponent (gfc_se *se, gfc_expr *expr)\n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n \n   res = gfc_create_var (integer_type_node, NULL);\n-  tmp = build_call_expr (built_in_decls[frexp], 2, arg,\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[frexp], 2, arg,\n \t\t\t gfc_build_addr_expr (NULL_TREE, res));\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -1054,7 +1058,8 @@ gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      se->expr = build_call_expr (built_in_decls[n], 1, arg);\n+      se->expr = build_call_expr_loc (input_location,\n+\t\t\t\t  built_in_decls[n], 1, arg);\n       break;\n \n     default:\n@@ -1150,7 +1155,8 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       if (n != END_BUILTINS)\n \t{\n   \t  tmp = build_addr (built_in_decls[n], current_function_decl);\n-\t  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (built_in_decls[n])),\n+\t  se->expr = build_call_array_loc (input_location,\n+\t\t\t\t       TREE_TYPE (TREE_TYPE (built_in_decls[n])),\n                                        tmp, 2, args);\n \t  if (modulo == 0)\n \t    return;\n@@ -1297,7 +1303,8 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n \t\t\t\t  build_call_expr (tmp, 2, args[0], args[1]));\n \t}\n       else\n-\tse->expr = build_call_expr (tmp, 2, args[0], args[1]);\n+        se->expr = build_call_expr_loc (input_location,\n+\t\t\t\t  tmp, 2, args[0], args[1]);\n       return;\n     }\n \n@@ -1400,7 +1407,8 @@ gfc_conv_intrinsic_ctime (gfc_se * se, gfc_expr * expr)\n   args[1] = gfc_build_addr_expr (NULL_TREE, len);\n \n   fndecl = build_addr (gfor_fndecl_ctime, current_function_decl);\n-  tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_ctime)),\n+  tmp = build_call_array_loc (input_location,\n+\t\t\t  TREE_TYPE (TREE_TYPE (gfor_fndecl_ctime)),\n \t\t\t  fndecl, num_args, args);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -1438,7 +1446,8 @@ gfc_conv_intrinsic_fdate (gfc_se * se, gfc_expr * expr)\n   args[1] = gfc_build_addr_expr (NULL_TREE, len);\n \n   fndecl = build_addr (gfor_fndecl_fdate, current_function_decl);\n-  tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_fdate)),\n+  tmp = build_call_array_loc (input_location,\n+\t\t\t  TREE_TYPE (TREE_TYPE (gfor_fndecl_fdate)),\n \t\t\t  fndecl, num_args, args);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -1478,7 +1487,8 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n   args[1] = gfc_build_addr_expr (NULL_TREE, len);\n \n   fndecl = build_addr (gfor_fndecl_ttynam, current_function_decl);\n-  tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_ttynam)),\n+  tmp = build_call_array_loc (input_location,\n+\t\t\t  TREE_TYPE (TREE_TYPE (gfor_fndecl_ttynam)),\n \t\t\t  fndecl, num_args, args);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -1546,9 +1556,10 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       if (argexpr->expr->expr_type == EXPR_VARIABLE\n \t  && argexpr->expr->symtree->n.sym->attr.optional\n \t  && TREE_CODE (val) == INDIRECT_REF)\n-\tcond = fold_build2\n-\t         (NE_EXPR, boolean_type_node, TREE_OPERAND (val, 0),\n-\t\t  build_int_cst (TREE_TYPE (TREE_OPERAND (val, 0)), 0));\n+\tcond = fold_build2_loc (input_location,\n+\t\t\t\tNE_EXPR, boolean_type_node,\n+\t\t\t\tTREE_OPERAND (val, 0), \n+\t\t\tbuild_int_cst (TREE_TYPE (TREE_OPERAND (val, 0)), 0));\n       else\n       {\n \tcond = NULL_TREE;\n@@ -1567,7 +1578,8 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t to help performance of programs that don't rely on IEEE semantics.  */\n       if (FLOAT_TYPE_P (TREE_TYPE (mvar)))\n \t{\n-\t  isnan = build_call_expr (built_in_decls[BUILT_IN_ISNAN], 1, mvar);\n+\t  isnan = build_call_expr_loc (input_location,\n+\t\t\t\t   built_in_decls[BUILT_IN_ISNAN], 1, mvar);\n \t  tmp = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, tmp,\n \t\t\t     fold_convert (boolean_type_node, isnan));\n \t}\n@@ -1615,7 +1627,8 @@ gfc_conv_intrinsic_minmax_char (gfc_se * se, gfc_expr * expr, int op)\n \n   /* Make the function call.  */\n   fndecl = build_addr (function, current_function_decl);\n-  tmp = build_call_array (TREE_TYPE (TREE_TYPE (function)), fndecl,\n+  tmp = build_call_array_loc (input_location,\n+\t\t\t  TREE_TYPE (TREE_TYPE (function)), fndecl,\n \t\t\t  nargs + 4, args);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -2692,7 +2705,8 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      se->expr = build_call_expr (tmp, 3, args[0], args[1], args[2]);\n+      se->expr = build_call_expr_loc (input_location,\n+\t\t\t\t  tmp, 3, args[0], args[1], args[2]);\n       /* Convert the result back to the original type, if we extended\n \t the first argument's width above.  */\n       if (expr->ts.kind < 4)\n@@ -2840,7 +2854,8 @@ gfc_conv_intrinsic_trailz (gfc_se * se, gfc_expr *expr)\n   result_type = gfc_get_int_type (gfc_default_integer_kind);\n \n   /* Compute TRAILZ for the case i .ne. 0.  */\n-  trailz = fold_convert (result_type, build_call_expr (func, 1, arg));\n+  trailz = fold_convert (result_type, build_call_expr_loc (input_location,\n+\t\t\t\t\t\t       func, 1, arg));\n \n   /* Build BIT_SIZE.  */\n   bit_size = build_int_cst (result_type, argsize);\n@@ -2991,7 +3006,8 @@ gfc_conv_intrinsic_len_trim (gfc_se * se, gfc_expr * expr)\n   else\n     gcc_unreachable ();\n \n-  se->expr = build_call_expr (fndecl, 2, args[0], args[1]);\n+  se->expr = build_call_expr_loc (input_location,\n+\t\t\t      fndecl, 2, args[0], args[1]);\n   se->expr = convert (type, se->expr);\n }\n \n@@ -3027,7 +3043,8 @@ gfc_conv_intrinsic_index_scan_verify (gfc_se * se, gfc_expr * expr,\n     args[4] = convert (logical4_type_node, args[4]);\n \n   fndecl = build_addr (function, current_function_decl);\n-  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (function)), fndecl,\n+  se->expr = build_call_array_loc (input_location,\n+\t\t\t       TREE_TYPE (TREE_TYPE (function)), fndecl,\n \t\t\t       5, args);\n   se->expr = convert (type, se->expr);\n \n@@ -3045,7 +3062,8 @@ gfc_conv_intrinsic_ichar (gfc_se * se, gfc_expr * expr)\n   args[1] = fold_build1 (NOP_EXPR, pchartype, args[1]);\n   type = gfc_typenode_for_spec (&expr->ts);\n \n-  se->expr = build_fold_indirect_ref (args[1]);\n+  se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t      args[1]);\n   se->expr = convert (type, se->expr);\n }\n \n@@ -3058,7 +3076,8 @@ gfc_conv_intrinsic_isnan (gfc_se * se, gfc_expr * expr)\n   tree arg;\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n-  se->expr = build_call_expr (built_in_decls[BUILT_IN_ISNAN], 1, arg);\n+  se->expr = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[BUILT_IN_ISNAN], 1, arg);\n   STRIP_TYPE_NOPS (se->expr);\n   se->expr = fold_convert (gfc_typenode_for_spec (&expr->ts), se->expr);\n }\n@@ -3149,7 +3168,8 @@ gfc_conv_intrinsic_fraction (gfc_se * se, gfc_expr * expr)\n   type = gfc_typenode_for_spec (&expr->ts);\n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n   tmp = gfc_create_var (integer_type_node, NULL);\n-  se->expr = build_call_expr (built_in_decls[frexp], 2,\n+  se->expr = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[frexp], 2,\n \t\t\t      fold_convert (type, arg),\n \t\t\t      gfc_build_addr_expr (NULL_TREE, tmp));\n   se->expr = fold_convert (type, se->expr);\n@@ -3190,10 +3210,13 @@ gfc_conv_intrinsic_nearest (gfc_se * se, gfc_expr * expr)\n \n   type = gfc_typenode_for_spec (&expr->ts);\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  tmp = build_call_expr (built_in_decls[copysign], 2,\n-\t\t\t build_call_expr (built_in_decls[huge_val], 0),\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[copysign], 2,\n+\t\t\t build_call_expr_loc (input_location,\n+\t\t\t\t\t  built_in_decls[huge_val], 0),\n \t\t\t fold_convert (type, args[1]));\n-  se->expr = build_call_expr (built_in_decls[nextafter], 2,\n+  se->expr = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[nextafter], 2,\n \t\t\t      fold_convert (type, args[0]), tmp);\n   se->expr = fold_convert (type, se->expr);\n }\n@@ -3258,15 +3281,17 @@ gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n \n   /* Build the block for s /= 0.  */\n   gfc_start_block (&block);\n-  tmp = build_call_expr (built_in_decls[frexp], 2, arg,\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[frexp], 2, arg,\n \t\t\t gfc_build_addr_expr (NULL_TREE, e));\n   gfc_add_expr_to_block (&block, tmp);\n \n   tmp = fold_build2 (MINUS_EXPR, integer_type_node, e, prec);\n   gfc_add_modify (&block, e, fold_build2 (MAX_EXPR, integer_type_node,\n-\t\t\t\t\t       tmp, emin));\n+\t\t\t\t\t  tmp, emin));\n \n-  tmp = build_call_expr (built_in_decls[scalbn], 2,\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[scalbn], 2,\n \t\t\t build_real_from_int_cst (type, integer_one_node), e);\n   gfc_add_modify (&block, res, tmp);\n \n@@ -3332,17 +3357,20 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n   e = gfc_create_var (integer_type_node, NULL);\n   x = gfc_create_var (type, NULL);\n   gfc_add_modify (&se->pre, x,\n-\t\t       build_call_expr (built_in_decls[fabs], 1, arg));\n+\t\t  build_call_expr_loc (input_location,\n+\t\t\t\t   built_in_decls[fabs], 1, arg));\n \n \n   gfc_start_block (&block);\n-  tmp = build_call_expr (built_in_decls[frexp], 2, arg,\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[frexp], 2, arg,\n \t\t\t gfc_build_addr_expr (NULL_TREE, e));\n   gfc_add_expr_to_block (&block, tmp);\n \n   tmp = fold_build2 (MINUS_EXPR, integer_type_node,\n \t\t     build_int_cst (NULL_TREE, prec), e);\n-  tmp = build_call_expr (built_in_decls[scalbn], 2, x, tmp);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[scalbn], 2, x, tmp);\n   gfc_add_modify (&block, x, tmp);\n   stmt = gfc_finish_block (&block);\n \n@@ -3380,7 +3408,8 @@ gfc_conv_intrinsic_scale (gfc_se * se, gfc_expr * expr)\n \n   type = gfc_typenode_for_spec (&expr->ts);\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  se->expr = build_call_expr (built_in_decls[scalbn], 2,\n+  se->expr = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[scalbn], 2,\n \t\t\t      fold_convert (type, args[0]),\n \t\t\t      fold_convert (integer_type_node, args[1]));\n   se->expr = fold_convert (type, se->expr);\n@@ -3418,10 +3447,12 @@ gfc_conv_intrinsic_set_exponent (gfc_se * se, gfc_expr * expr)\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n \n   tmp = gfc_create_var (integer_type_node, NULL);\n-  tmp = build_call_expr (built_in_decls[frexp], 2,\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[frexp], 2,\n \t\t\t fold_convert (type, args[0]),\n \t\t\t gfc_build_addr_expr (NULL_TREE, tmp));\n-  se->expr = build_call_expr (built_in_decls[scalbn], 2, tmp,\n+  se->expr = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[scalbn], 2, tmp,\n \t\t\t      fold_convert (integer_type_node, args[1]));\n   se->expr = fold_convert (type, se->expr);\n }\n@@ -3451,7 +3482,8 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n   arg1 = gfc_evaluate_now (argse.expr, &se->pre);\n \n   /* Build the call to size0.  */\n-  fncall0 = build_call_expr (gfor_fndecl_size0, 1, arg1);\n+  fncall0 = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_size0, 1, arg1);\n \n   actual = actual->next;\n \n@@ -3470,7 +3502,8 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n \t{\n \t  tree tmp;\n \t  /* Build the call to size1.  */\n-\t  fncall1 = build_call_expr (gfor_fndecl_size1, 2,\n+\t  fncall1 = build_call_expr_loc (input_location,\n+\t\t\t\t     gfor_fndecl_size1, 2,\n \t\t\t\t     arg1, argse.expr);\n \n \t  gfc_init_se (&argse, NULL);\n@@ -3503,7 +3536,8 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n     {\n       tree ubound, lbound;\n \n-      arg1 = build_fold_indirect_ref (arg1);\n+      arg1 = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t      arg1);\n       ubound = gfc_conv_descriptor_ubound_get (arg1, argse.expr);\n       lbound = gfc_conv_descriptor_lbound_get (arg1, argse.expr);\n       se->expr = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n@@ -3561,7 +3595,8 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n       gfc_conv_expr_reference (&argse, arg);\n       source = argse.expr;\n \n-      type = TREE_TYPE (build_fold_indirect_ref (argse.expr));\n+      type = TREE_TYPE (build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t argse.expr));\n \n       /* Obtain the source word length.  */\n       if (arg->ts.type == BT_CHARACTER)\n@@ -3641,7 +3676,8 @@ gfc_conv_intrinsic_adjust (gfc_se * se, gfc_expr * expr, tree fndecl)\n   var = gfc_conv_string_tmp (se, type, len);\n   args[0] = var;\n \n-  tmp = build_call_expr (fndecl, 3, args[0], args[1], args[2]);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t fndecl, 3, args[0], args[1], args[2]);\n   gfc_add_expr_to_block (&se->pre, tmp);\n   se->expr = var;\n   se->string_length = len;\n@@ -3719,7 +3755,8 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n       gfc_conv_expr_reference (&argse, arg->expr);\n       source = argse.expr;\n \n-      source_type = TREE_TYPE (build_fold_indirect_ref (argse.expr));\n+      source_type = TREE_TYPE (build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\targse.expr));\n \n       /* Obtain the source word length.  */\n       if (arg->expr->ts.type == BT_CHARACTER)\n@@ -3745,7 +3782,8 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \t  if (gfc_option.warn_array_temp)\n \t    gfc_warning (\"Creating array temporary at %L\", &expr->where);\n \n-\t  source = build_call_expr (gfor_fndecl_in_pack, 1, tmp);\n+\t  source = build_call_expr_loc (input_location,\n+\t\t\t\t    gfor_fndecl_in_pack, 1, tmp);\n \t  source = gfc_evaluate_now (source, &argse.pre);\n \n \t  /* Free the temporary.  */\n@@ -3811,7 +3849,8 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   if (ss == gfc_ss_terminator)\n     {\n       gfc_conv_expr_reference (&argse, arg->expr);\n-      mold_type = TREE_TYPE (build_fold_indirect_ref (argse.expr));\n+      mold_type = TREE_TYPE (build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t      argse.expr));\n     }\n   else\n     {\n@@ -3853,7 +3892,8 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n       gfc_init_se (&argse, NULL);\n       gfc_conv_expr_reference (&argse, arg->expr);\n       tmp = convert (gfc_array_index_type,\n-\t\t\t build_fold_indirect_ref (argse.expr));\n+\t\t     build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t      argse.expr));\n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       gfc_add_block_to_block (&se->post, &argse.post);\n     }\n@@ -3918,7 +3958,8 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   tmp = fold_convert (pvoid_type_node, tmp);\n \n   /* Use memcpy to do the transfer.  */\n-  tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY],\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[BUILT_IN_MEMCPY],\n \t\t\t 3,\n \t\t\t tmp,\n \t\t\t fold_convert (pvoid_type_node, source),\n@@ -3959,7 +4000,8 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n       tmp = gfc_call_malloc (&block, tmp, dest_word_len);\n       gfc_add_modify (&block, tmpdecl,\n \t\t      fold_convert (TREE_TYPE (ptr), tmp));\n-      tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     built_in_decls[BUILT_IN_MEMCPY], 3,\n \t\t\t     fold_convert (pvoid_type_node, tmpdecl),\n \t\t\t     fold_convert (pvoid_type_node, ptr),\n \t\t\t     extent);\n@@ -3983,7 +4025,8 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \n       /* Use memcpy to do the transfer.  */\n       tmp = gfc_build_addr_expr (NULL_TREE, tmpdecl);\n-      tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     built_in_decls[BUILT_IN_MEMCPY], 3,\n \t\t\t     fold_convert (pvoid_type_node, tmp),\n \t\t\t     fold_convert (pvoid_type_node, ptr),\n \t\t\t     extent);\n@@ -4113,7 +4156,8 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n           gfc_conv_expr_descriptor (&arg2se, arg2->expr, ss2);\n           gfc_add_block_to_block (&se->pre, &arg2se.pre);\n           gfc_add_block_to_block (&se->post, &arg2se.post);\n-          se->expr = build_call_expr (gfor_fndecl_associated, 2,\n+          se->expr = build_call_expr_loc (input_location,\n+\t\t\t\t      gfor_fndecl_associated, 2,\n \t\t\t\t      arg1se.expr, arg2se.expr);\n \t  se->expr = convert (boolean_type_node, se->expr);\n \t  se->expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n@@ -4139,7 +4183,8 @@ gfc_conv_intrinsic_sc_kind (gfc_se *se, gfc_expr *expr)\n   tree args[2];\n \n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  se->expr = build_call_expr (gfor_fndecl_sc_kind, 2, args[0], args[1]);\n+  se->expr = build_call_expr_loc (input_location,\n+\t\t\t      gfor_fndecl_sc_kind, 2, args[0], args[1]);\n   se->expr = fold_convert (gfc_typenode_for_spec (&expr->ts), se->expr);\n }\n \n@@ -4159,7 +4204,8 @@ gfc_conv_intrinsic_si_kind (gfc_se *se, gfc_expr *expr)\n \n   /* Convert it to the required type.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n-  se->expr = build_call_expr (gfor_fndecl_si_kind, 1, arg);\n+  se->expr = build_call_expr_loc (input_location,\n+\t\t\t      gfor_fndecl_si_kind, 1, arg);\n   se->expr = fold_convert (type, se->expr);\n }\n \n@@ -4203,7 +4249,8 @@ gfc_conv_intrinsic_sr_kind (gfc_se *se, gfc_expr *expr)\n \n   /* Convert it to the required type.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n-  se->expr = build_function_call_expr (gfor_fndecl_sr_kind, args);\n+  se->expr = build_function_call_expr (input_location,\n+\t\t\t\t       gfor_fndecl_sr_kind, args);\n   se->expr = fold_convert (type, se->expr);\n }\n \n@@ -4242,7 +4289,8 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n     gcc_unreachable ();\n \n   fndecl = build_addr (function, current_function_decl);\n-  tmp = build_call_array (TREE_TYPE (TREE_TYPE (function)), fndecl,\n+  tmp = build_call_array_loc (input_location,\n+\t\t\t  TREE_TYPE (TREE_TYPE (function)), fndecl,\n \t\t\t  num_args, args);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -4353,7 +4401,8 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   tmp = fold_build2 (POINTER_PLUS_EXPR, pvoid_type_node,\n \t\t     fold_convert (pvoid_type_node, dest),\n \t\t     fold_convert (sizetype, tmp));\n-  tmp = build_call_expr (built_in_decls[BUILT_IN_MEMMOVE], 3, tmp, src,\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[BUILT_IN_MEMMOVE], 3, tmp, src,\n \t\t\t fold_build2 (MULT_EXPR, size_type_node, slen,\n \t\t\t\t      fold_convert (size_type_node, size)));\n   gfc_add_expr_to_block (&body, tmp);\n@@ -4392,7 +4441,8 @@ gfc_conv_intrinsic_iargc (gfc_se * se, gfc_expr * expr)\n \n   /* Call the library function.  This always returns an INTEGER(4).  */\n   fndecl = gfor_fndecl_iargc;\n-  tmp = build_call_expr (fndecl, 0);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t fndecl, 0);\n \n   /* Convert it to the required type.  */\n   type = gfc_typenode_for_spec (&expr->ts);"}, {"sha": "35f87bc3e56d60d2748b016bdadcb7a53a8dda02", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -246,7 +246,8 @@ gfc_trans_io_runtime_check (tree cond, tree var, int error_code,\n \t\t\t      gfc_build_localized_cstring_const (message));\n   gfc_free(message);\n   \n-  tmp = build_call_expr (gfor_fndecl_generate_error, 3, arg1, arg2, arg3);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t gfor_fndecl_generate_error, 3, arg1, arg2, arg3);\n \n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -261,7 +262,8 @@ gfc_trans_io_runtime_check (tree cond, tree var, int error_code,\n       /* Tell the compiler that this isn't likely.  */\n       cond = fold_convert (long_integer_type_node, cond);\n       tmp = build_int_cst (long_integer_type_node, 0);\n-      cond = build_call_expr (built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n+      cond = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n       cond = fold_convert (boolean_type_node, cond);\n \n       tmp = build3_v (COND_EXPR, cond, body, build_empty_stmt (input_location));\n@@ -740,7 +742,8 @@ set_internal_unit (stmtblock_t * block, stmtblock_t * post_block,\n \t     or substring array references.  */\n \t  gfc_conv_subref_array_arg (&se, e, 0,\n \t\tlast_dt == READ ? INTENT_IN : INTENT_OUT);\n-\t  tmp = build_fold_indirect_ref (se.expr);\n+\t  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t se.expr);\n \t  se.expr = gfc_build_addr_expr (pchar_type_node, tmp);\n \t  tmp = gfc_conv_descriptor_data_get (tmp);\n \t}\n@@ -964,7 +967,8 @@ gfc_trans_open (gfc_code * code)\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n   tmp = gfc_build_addr_expr (NULL_TREE, var);\n-  tmp = build_call_expr (iocall[IOCALL_OPEN], 1, tmp);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t iocall[IOCALL_OPEN], 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n@@ -1016,7 +1020,8 @@ gfc_trans_close (gfc_code * code)\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n   tmp = gfc_build_addr_expr (NULL_TREE, var);\n-  tmp = build_call_expr (iocall[IOCALL_CLOSE], 1, tmp);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t iocall[IOCALL_CLOSE], 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n@@ -1066,7 +1071,8 @@ build_filepos (tree function, gfc_code * code)\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n   tmp = gfc_build_addr_expr (NULL_TREE, var);\n-  tmp = build_call_expr (function, 1, tmp);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t function, 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n@@ -1323,7 +1329,8 @@ gfc_trans_inquire (gfc_code * code)\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n   tmp = gfc_build_addr_expr (NULL_TREE, var);\n-  tmp = build_call_expr (iocall[IOCALL_INQUIRE], 1, tmp);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t iocall[IOCALL_INQUIRE], 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n@@ -1372,7 +1379,8 @@ gfc_trans_wait (gfc_code * code)\n     set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n \n   tmp = gfc_build_addr_expr (NULL_TREE, var);\n-  tmp = build_call_expr (iocall[IOCALL_WAIT], 1, tmp);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t iocall[IOCALL_WAIT], 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n@@ -1458,7 +1466,8 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n \n   dummy_arg_flagged = POINTER_TYPE_P (TREE_TYPE(tmp));\n \n-  itmp = (dummy_arg_flagged) ? build_fold_indirect_ref (tmp) : tmp;\n+  itmp = (dummy_arg_flagged) ? build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\ttmp) : tmp;\n \n   /* If an array, set flag and use indirect ref. if built.  */\n \n@@ -1490,7 +1499,8 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n   /* If scalar dummy, resolve indirect reference now.  */\n \n   if (dummy_arg_flagged && !array_flagged)\n-    tmp = build_fold_indirect_ref (tmp);\n+    tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t   tmp);\n \n   gcc_assert (tmp && POINTER_TYPE_P (TREE_TYPE (tmp)));\n \n@@ -1584,7 +1594,8 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n     tmp = ts->cl->backend_decl;\n   else\n     tmp = build_int_cst (gfc_charlen_type_node, 0);\n-  tmp = build_call_expr (iocall[IOCALL_SET_NML_VAL], 6,\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t iocall[IOCALL_SET_NML_VAL], 6,\n \t\t\t dt_parm_addr, addr_expr, string,\n \t\t\t IARG (ts->kind), tmp, dtype);\n   gfc_add_expr_to_block (block, tmp);\n@@ -1594,7 +1605,8 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n \n   for ( n_dim = 0 ; n_dim < rank ; n_dim++ )\n     {\n-      tmp = build_call_expr (iocall[IOCALL_SET_NML_VAL_DIM], 5,\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     iocall[IOCALL_SET_NML_VAL_DIM], 5,\n \t\t\t     dt_parm_addr,\n \t\t\t     IARG (n_dim),\n \t\t\t     GFC_TYPE_ARRAY_STRIDE (dt, n_dim),\n@@ -1609,7 +1621,8 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n \n       /* Provide the RECORD_TYPE to build component references.  */\n \n-      tree expr = build_fold_indirect_ref (addr_expr);\n+      tree expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t   addr_expr);\n \n       for (cmp = ts->derived->components; cmp; cmp = cmp->next)\n \t{\n@@ -1789,7 +1802,8 @@ build_dt (tree function, gfc_code * code)\n     set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   tmp = gfc_build_addr_expr (NULL_TREE, var);\n-  tmp = build_call_expr (function, 1, tmp);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t function, 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n@@ -1869,7 +1883,8 @@ gfc_trans_dt_end (gfc_code * code)\n     }\n \n   tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n-  tmp = build_call_expr (function, 1, tmp);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t function, 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, dt_post_end_block);\n   gfc_init_block (dt_post_end_block);\n@@ -2043,15 +2058,17 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n \t    arg2 = se->string_length;\n \t  else\n \t    {\n-\t      tmp = build_fold_indirect_ref (addr_expr);\n+\t      tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t     addr_expr);\n \t      gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE);\n \t      arg2 = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (tmp)));\n \t      arg2 = fold_convert (gfc_charlen_type_node, arg2);\n \t    }\n \t  arg3 = build_int_cst (NULL_TREE, kind);\n \t  function = iocall[IOCALL_X_CHARACTER_WIDE];\n \t  tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n-\t  tmp = build_call_expr (function, 4, tmp, addr_expr, arg2, arg3);\n+\t  tmp = build_call_expr_loc (input_location,\n+\t\t\t\t function, 4, tmp, addr_expr, arg2, arg3);\n \t  gfc_add_expr_to_block (&se->pre, tmp);\n \t  gfc_add_block_to_block (&se->pre, &se->post);\n \t  return;\n@@ -2062,7 +2079,8 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n \targ2 = se->string_length;\n       else\n \t{\n-\t  tmp = build_fold_indirect_ref (addr_expr);\n+\t  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t addr_expr);\n \t  gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE);\n \t  arg2 = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (tmp)));\n \t}\n@@ -2072,14 +2090,16 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n     case BT_DERIVED:\n       /* Recurse into the elements of the derived type.  */\n       expr = gfc_evaluate_now (addr_expr, &se->pre);\n-      expr = build_fold_indirect_ref (expr);\n+      expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t      expr);\n \n       for (c = ts->derived->components; c; c = c->next)\n \t{\n \t  field = c->backend_decl;\n \t  gcc_assert (field && TREE_CODE (field) == FIELD_DECL);\n \n-\t  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t  tmp = fold_build3_loc (UNKNOWN_LOCATION,\n+\t\t\t     COMPONENT_REF, TREE_TYPE (field),\n \t\t\t     expr, field, NULL_TREE);\n \n           if (c->attr.dimension)\n@@ -2101,7 +2121,8 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n     }\n \n   tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n-  tmp = build_call_expr (function, 3, tmp, addr_expr, arg2);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t function, 3, tmp, addr_expr, arg2);\n   gfc_add_expr_to_block (&se->pre, tmp);\n   gfc_add_block_to_block (&se->pre, &se->post);\n \n@@ -2124,7 +2145,8 @@ transfer_array_desc (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n   kind_arg = build_int_cst (NULL_TREE, ts->kind);\n \n   tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n-  tmp = build_call_expr (iocall[IOCALL_X_ARRAY], 4,\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t iocall[IOCALL_X_ARRAY], 4,\n \t\t\t tmp, addr_expr, kind_arg, charlen_arg);\n   gfc_add_expr_to_block (&se->pre, tmp);\n   gfc_add_block_to_block (&se->pre, &se->post);"}, {"sha": "56534ccdd38a4f3e19d78d60d0e94969169ae7e7", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -218,7 +218,8 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n \t\t\t\t\tbuild_int_cst (pvoid_type_node, 0),\n \t\t\t\t\tsize, NULL, NULL);\n   gfc_conv_descriptor_data_set (&block, dest, ptr);\n-  call = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3, ptr,\n+  call = build_call_expr_loc (input_location,\n+\t\t\t  built_in_decls[BUILT_IN_MEMCPY], 3, ptr,\n \t\t\t  fold_convert (pvoid_type_node,\n \t\t\t\t\tgfc_conv_descriptor_data_get (src)),\n \t\t\t  size);\n@@ -255,7 +256,8 @@ gfc_omp_clause_assign_op (tree clause ATTRIBUTE_UNUSED, tree dest, tree src)\n \t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n   size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, esize);\n   size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n-  call = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+  call = build_call_expr_loc (input_location,\n+\t\t\t  built_in_decls[BUILT_IN_MEMCPY], 3,\n \t\t\t  fold_convert (pvoid_type_node,\n \t\t\t\t\tgfc_conv_descriptor_data_get (dest)),\n \t\t\t  fold_convert (pvoid_type_node,\n@@ -1084,7 +1086,8 @@ gfc_trans_omp_atomic (gfc_code *code)\n \n   lhsaddr = save_expr (lhsaddr);\n   rhs = gfc_evaluate_now (rse.expr, &block);\n-  x = convert (TREE_TYPE (rhs), build_fold_indirect_ref (lhsaddr));\n+  x = convert (TREE_TYPE (rhs), build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\t lhsaddr));\n \n   if (var_on_left)\n     x = fold_build2 (op, TREE_TYPE (rhs), x, rhs);\n@@ -1108,7 +1111,7 @@ static tree\n gfc_trans_omp_barrier (void)\n {\n   tree decl = built_in_decls [BUILT_IN_GOMP_BARRIER];\n-  return build_call_expr (decl, 0);\n+  return build_call_expr_loc (input_location, decl, 0);\n }\n \n static tree\n@@ -1357,7 +1360,7 @@ static tree\n gfc_trans_omp_flush (void)\n {\n   tree decl = built_in_decls [BUILT_IN_SYNCHRONIZE];\n-  return build_call_expr (decl, 0);\n+  return build_call_expr_loc (input_location, decl, 0);\n }\n \n static tree\n@@ -1541,7 +1544,7 @@ static tree\n gfc_trans_omp_taskwait (void)\n {\n   tree decl = built_in_decls [BUILT_IN_GOMP_TASKWAIT];\n-  return build_call_expr (decl, 0);\n+  return build_call_expr_loc (input_location, decl, 0);\n }\n \n static tree"}, {"sha": "6a1fb01cc60f13820cfa71b0aa2c55e3c2fd423b", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -314,13 +314,14 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n \t\t\t\t loopse->loop->from[n], tmp);\n \t      offset = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t\t  offset, tmp);\n+\t\t\t\t    offset, tmp);\n \t    }\n \t  info->offset = gfc_create_var (gfc_array_index_type, NULL);\t  \n \t  gfc_add_modify (&se->pre, info->offset, offset);\n \n \t  /* Copy the result back using unpack.  */\n-\t  tmp = build_call_expr (gfor_fndecl_in_unpack, 2, parmse.expr, data);\n+\t  tmp = build_call_expr_loc (input_location,\n+\t\t\t\t gfor_fndecl_in_unpack, 2, parmse.expr, data);\n \t  gfc_add_expr_to_block (&se->post, tmp);\n \n \t  /* parmse.pre is already added above.  */\n@@ -539,12 +540,14 @@ gfc_trans_pause (gfc_code * code)\n   if (code->expr1 == NULL)\n     {\n       tmp = build_int_cst (gfc_int4_type_node, code->ext.stop_code);\n-      tmp = build_call_expr (gfor_fndecl_pause_numeric, 1, tmp);\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_pause_numeric, 1, tmp);\n     }\n   else\n     {\n       gfc_conv_expr_reference (&se, code->expr1);\n-      tmp = build_call_expr (gfor_fndecl_pause_string, 2,\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_pause_string, 2,\n \t\t\t     se.expr, se.string_length);\n     }\n \n@@ -574,12 +577,14 @@ gfc_trans_stop (gfc_code * code)\n   if (code->expr1 == NULL)\n     {\n       tmp = build_int_cst (gfc_int4_type_node, code->ext.stop_code);\n-      tmp = build_call_expr (gfor_fndecl_stop_numeric, 1, tmp);\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_stop_numeric, 1, tmp);\n     }\n   else\n     {\n       gfc_conv_expr_reference (&se, code->expr1);\n-      tmp = build_call_expr (gfor_fndecl_stop_string, 2,\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_stop_string, 2,\n \t\t\t     se.expr, se.string_length);\n     }\n \n@@ -1614,7 +1619,8 @@ gfc_trans_character_select (gfc_code *code)\n   else\n     gcc_unreachable ();\n \n-  tmp = build_call_expr (fndecl, 4, init, build_int_cst (NULL_TREE, n),\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t fndecl, 4, init, build_int_cst (NULL_TREE, n),\n \t\t\t se.expr, se.string_length);\n   case_num = gfc_create_var (integer_type_node, \"case_num\");\n   gfc_add_modify (&block, case_num, tmp);\n@@ -1741,7 +1747,7 @@ forall_make_variable_temp (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n       gfc_conv_subref_array_arg (&tse, e, 0, INTENT_IN);\n       gfc_add_block_to_block (pre, &tse.pre);\n       gfc_add_block_to_block (post, &tse.post);\n-      tse.expr = build_fold_indirect_ref (tse.expr);\n+      tse.expr = build_fold_indirect_ref_loc (input_location, tse.expr);\n \n       if (e->ts.type != BT_CHARACTER)\n \t{\n@@ -2441,7 +2447,7 @@ allocate_temp_for_forall_nest_1 (tree type, tree size, stmtblock_t * block,\n   tmp = gfc_do_allocate (bytesize, size, ptemp1, block, type);\n \n   if (*ptemp1)\n-    tmp = build_fold_indirect_ref (tmp);\n+    tmp = build_fold_indirect_ref_loc (input_location, tmp);\n   return tmp;\n }\n \n@@ -4020,7 +4026,7 @@ gfc_trans_allocate (gfc_code * code)\n \n \t  if (expr->ts.type == BT_DERIVED && expr->ts.derived->attr.alloc_comp)\n \t    {\n-\t      tmp = build_fold_indirect_ref (se.expr);\n+\t      tmp = build_fold_indirect_ref_loc (input_location, se.expr);\n \t      tmp = gfc_nullify_alloc_comp (expr->ts.derived, tmp, 0);\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n@@ -4063,7 +4069,8 @@ gfc_trans_allocate (gfc_code * code)\n       dlen = gfc_get_expr_charlen (code->expr2);\n       slen = fold_build2 (MIN_EXPR, TREE_TYPE (slen), dlen, slen);\n \n-      dlen = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+      dlen = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[BUILT_IN_MEMCPY], 3,\n \t\tgfc_build_addr_expr (pvoid_type_node, se.expr), errmsg, slen);\n \n       tmp = fold_build2 (NE_EXPR, boolean_type_node, stat,\n@@ -4197,7 +4204,8 @@ gfc_trans_deallocate (gfc_code *code)\n       dlen = gfc_get_expr_charlen (code->expr2);\n       slen = fold_build2 (MIN_EXPR, TREE_TYPE (slen), dlen, slen);\n \n-      dlen = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+      dlen = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[BUILT_IN_MEMCPY], 3,\n \t\tgfc_build_addr_expr (pvoid_type_node, se.expr), errmsg, slen);\n \n       tmp = fold_build2 (NE_EXPR, boolean_type_node, astat,"}, {"sha": "35a786aef29c2a2ed26e411228ed3bfe93b893b2", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -339,7 +339,7 @@ gfc_build_array_ref (tree base, tree offset, tree decl)\n \t\t\t tmp, fold_convert (sizetype, offset));\n       tmp = fold_convert (build_pointer_type (type), tmp);\n       if (!TYPE_STRING_FLAG (type))\n-\ttmp = build_fold_indirect_ref (tmp);\n+\ttmp = build_fold_indirect_ref_loc (input_location, tmp);\n       return tmp;\n     }\n   else\n@@ -413,13 +413,14 @@ gfc_trans_runtime_error_vararg (bool error, locus* where, const char* msgid,\n   va_end (ap);\n   \n   /* Build the function call to runtime_(warning,error)_at; because of the\n-     variable number of arguments, we can't use build_call_expr directly.  */\n+     variable number of arguments, we can't use build_call_expr_loc dinput_location,\n+     irectly.  */\n   if (error)\n     fntype = TREE_TYPE (gfor_fndecl_runtime_error_at);\n   else\n     fntype = TREE_TYPE (gfor_fndecl_runtime_warning_at);\n \n-  tmp = fold_builtin_call_array (TREE_TYPE (fntype),\n+  tmp = fold_builtin_call_array (input_location, TREE_TYPE (fntype),\n \t\t\t\t fold_build1 (ADDR_EXPR,\n \t\t\t\t\t      build_pointer_type (fntype),\n \t\t\t\t\t      error\n@@ -482,7 +483,8 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n \tcond = fold_convert (long_integer_type_node, cond);\n \n       tmp = build_int_cst (long_integer_type_node, 0);\n-      cond = build_call_expr (built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n+      cond = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n       cond = fold_convert (boolean_type_node, cond);\n \n       tmp = build3_v (COND_EXPR, cond, body, build_empty_stmt (input_location));\n@@ -515,7 +517,8 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n       (\"Attempt to allocate a negative amount of memory.\"));\n   tmp = fold_build3 (COND_EXPR, void_type_node, negative,\n-\t\t     build_call_expr (gfor_fndecl_runtime_error, 1, msg),\n+\t\t     build_call_expr_loc (input_location,\n+\t\t\t\t      gfor_fndecl_runtime_error, 1, msg),\n \t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n \n@@ -526,14 +529,16 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n \t\t      build_int_cst (size_type_node, 1));\n \n   gfc_add_modify (&block2, res,\n-\t\t       build_call_expr (built_in_decls[BUILT_IN_MALLOC], 1,\n+\t\t  build_call_expr_loc (input_location,\n+\t\t\t\t   built_in_decls[BUILT_IN_MALLOC], 1,\n \t\t       size));\n   null_result = fold_build2 (EQ_EXPR, boolean_type_node, res,\n \t\t\t     build_int_cst (pvoid_type_node, 0));\n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n       (\"Memory allocation failed\"));\n   tmp = fold_build3 (COND_EXPR, void_type_node, null_result,\n-\t\t     build_call_expr (gfor_fndecl_os_error, 1, msg),\n+\t\t     build_call_expr_loc (input_location,\n+\t\t\t\t      gfor_fndecl_os_error, 1, msg),\n \t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&block2, tmp);\n   malloc_result = gfc_finish_block (&block2);\n@@ -615,7 +620,8 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n \t\t\t(\"Attempt to allocate negative amount of memory. \"\n \t\t\t \"Possible integer overflow\"));\n-  error = build_call_expr (gfor_fndecl_runtime_error, 1, msg);\n+  error = build_call_expr_loc (input_location,\n+\t\t\t   gfor_fndecl_runtime_error, 1, msg);\n \n   if (status != NULL_TREE && !integer_zerop (status))\n     {\n@@ -624,7 +630,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n \n       gfc_start_block (&set_status_block);\n       gfc_add_modify (&set_status_block,\n-\t\t\t   fold_build1 (INDIRECT_REF, status_type, status),\n+\t\t      fold_build1 (INDIRECT_REF, status_type, status),\n \t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n       gfc_add_modify (&set_status_block, res,\n \t\t\t   build_int_cst (pvoid_type_node, 0));\n@@ -638,14 +644,16 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n   /* The allocation itself.  */\n   gfc_start_block (&alloc_block);\n   gfc_add_modify (&alloc_block, res,\n-\t\t       build_call_expr (built_in_decls[BUILT_IN_MALLOC], 1,\n+\t\t  build_call_expr_loc (input_location,\n+\t\t\t\t   built_in_decls[BUILT_IN_MALLOC], 1,\n \t\t\t\t\tfold_build2 (MAX_EXPR, size_type_node,\n \t\t\t\t\t\t     size,\n \t\t\t\t\t\t     build_int_cst (size_type_node, 1))));\n \n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n \t\t\t\t\t\t(\"Out of memory\"));\n-  tmp = build_call_expr (gfor_fndecl_os_error, 1, msg);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t gfor_fndecl_os_error, 1, msg);\n \n   if (status != NULL_TREE && !integer_zerop (status))\n     {\n@@ -750,7 +758,8 @@ gfc_allocate_array_with_status (stmtblock_t * block, tree mem, tree size,\n       stmtblock_t set_status_block;\n \n       gfc_start_block (&set_status_block);\n-      tmp = build_call_expr (built_in_decls[BUILT_IN_FREE], 1,\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t     built_in_decls[BUILT_IN_FREE], 1,\n \t\t\t     fold_convert (pvoid_type_node, mem));\n       gfc_add_expr_to_block (&set_status_block, tmp);\n \n@@ -788,7 +797,8 @@ gfc_call_free (tree var)\n   var = gfc_evaluate_now (var, &block);\n   cond = fold_build2 (NE_EXPR, boolean_type_node, var,\n \t\t      build_int_cst (pvoid_type_node, 0));\n-  call = build_call_expr (built_in_decls[BUILT_IN_FREE], 1, var);\n+  call = build_call_expr_loc (input_location,\n+\t\t\t  built_in_decls[BUILT_IN_FREE], 1, var);\n   tmp = fold_build3 (COND_EXPR, void_type_node, cond, call,\n \t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&block, tmp);\n@@ -873,7 +883,8 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail,\n \n   /* When POINTER is not NULL, we free it.  */\n   gfc_start_block (&non_null);\n-  tmp = build_call_expr (built_in_decls[BUILT_IN_FREE], 1,\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[BUILT_IN_FREE], 1,\n \t\t\t fold_convert (pvoid_type_node, pointer));\n   gfc_add_expr_to_block (&non_null, tmp);\n \n@@ -935,12 +946,14 @@ gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n       (\"Attempt to allocate a negative amount of memory.\"));\n   tmp = fold_build3 (COND_EXPR, void_type_node, negative,\n-\t\t     build_call_expr (gfor_fndecl_runtime_error, 1, msg),\n+\t\t     build_call_expr_loc (input_location,\n+\t\t\t\t      gfor_fndecl_runtime_error, 1, msg),\n \t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n \n   /* Call realloc and check the result.  */\n-  tmp = build_call_expr (built_in_decls[BUILT_IN_REALLOC], 2,\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t built_in_decls[BUILT_IN_REALLOC], 2,\n \t\t\t fold_convert (pvoid_type_node, mem), size);\n   gfc_add_modify (block, res, fold_convert (type, tmp));\n   null_result = fold_build2 (EQ_EXPR, boolean_type_node, res,\n@@ -952,7 +965,8 @@ gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n \t\t\t\t\t\t(\"Out of memory\"));\n   tmp = fold_build3 (COND_EXPR, void_type_node, null_result,\n-\t\t     build_call_expr (gfor_fndecl_os_error, 1, msg),\n+\t\t     build_call_expr_loc (input_location,\n+\t\t\t\t      gfor_fndecl_os_error, 1, msg),\n \t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n "}, {"sha": "8d7ead680ce4b584ea5abd0a8f89c3238eab6e3c", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -813,16 +813,16 @@ lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n   arg = build_addr (next_label, current_function_decl);\n   t = implicit_built_in_decls[BUILT_IN_SETJMP_SETUP];\n   g = gimple_build_call (t, 2, gimple_call_arg (stmt, 0), arg);\n-  gimple_set_location (g, gimple_location (stmt));\n+  gimple_set_location (g, loc);\n   gimple_set_block (g, gimple_block (stmt));\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n   /* Build 'DEST = 0' and insert.  */\n   if (dest)\n     {\n-      g = gimple_build_assign (dest, fold_convert (TREE_TYPE (dest),\n-\t\t\t\t\t\t   integer_zero_node));\n-      gimple_set_location (g, gimple_location (stmt));\n+      g = gimple_build_assign (dest, fold_convert_loc (loc, TREE_TYPE (dest),\n+\t\t\t\t\t\t       integer_zero_node));\n+      gimple_set_location (g, loc);\n       gimple_set_block (g, gimple_block (stmt));\n       gsi_insert_before (gsi, g, GSI_SAME_STMT);\n     }\n@@ -839,16 +839,16 @@ lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n   arg = build_addr (next_label, current_function_decl);\n   t = implicit_built_in_decls[BUILT_IN_SETJMP_RECEIVER];\n   g = gimple_build_call (t, 1, arg);\n-  gimple_set_location (g, gimple_location (stmt));\n+  gimple_set_location (g, loc);\n   gimple_set_block (g, gimple_block (stmt));\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n   /* Build 'DEST = 1' and insert.  */\n   if (dest)\n     {\n-      g = gimple_build_assign (dest, fold_convert (TREE_TYPE (dest),\n-\t\t\t\t\t\t   integer_one_node));\n-      gimple_set_location (g, gimple_location (stmt));\n+      g = gimple_build_assign (dest, fold_convert_loc (loc, TREE_TYPE (dest),\n+\t\t\t\t\t\t       integer_one_node));\n+      gimple_set_location (g, loc);\n       gimple_set_block (g, gimple_block (stmt));\n       gsi_insert_before (gsi, g, GSI_SAME_STMT);\n     }"}, {"sha": "aa30a2e31c0cd2090a67cc6abba10bf2104f1573", "filename": "gcc/gimple.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -487,6 +487,7 @@ void\n gimple_cond_get_ops_from_tree (tree cond, enum tree_code *code_p,\n                                tree *lhs_p, tree *rhs_p)\n {\n+  location_t loc = EXPR_LOCATION (cond);\n   gcc_assert (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison\n \t      || TREE_CODE (cond) == TRUTH_NOT_EXPR\n \t      || is_gimple_min_invariant (cond)\n@@ -499,14 +500,14 @@ gimple_cond_get_ops_from_tree (tree cond, enum tree_code *code_p,\n     {\n       *code_p = EQ_EXPR;\n       gcc_assert (*lhs_p && *rhs_p == NULL_TREE);\n-      *rhs_p = fold_convert (TREE_TYPE (*lhs_p), integer_zero_node);\n+      *rhs_p = fold_convert_loc (loc, TREE_TYPE (*lhs_p), integer_zero_node);\n     }\n   /* Canonicalize conditionals of the form 'if (VAL)'  */\n   else if (TREE_CODE_CLASS (*code_p) != tcc_comparison)\n     {\n       *code_p = NE_EXPR;\n       gcc_assert (*lhs_p && *rhs_p == NULL_TREE);\n-      *rhs_p = fold_convert (TREE_TYPE (*lhs_p), integer_zero_node);\n+      *rhs_p = fold_convert_loc (loc, TREE_TYPE (*lhs_p), integer_zero_node);\n     }\n }\n \n@@ -1897,10 +1898,11 @@ gimple_set_bb (gimple stmt, basic_block bb)\n tree\n gimple_fold (const_gimple stmt)\n {\n+  location_t loc = gimple_location (stmt);\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_COND:\n-      return fold_binary (gimple_cond_code (stmt),\n+      return fold_binary_loc (loc, gimple_cond_code (stmt),\n \t\t\t  boolean_type_node,\n \t\t\t  gimple_cond_lhs (stmt),\n \t\t\t  gimple_cond_rhs (stmt));\n@@ -1909,11 +1911,11 @@ gimple_fold (const_gimple stmt)\n       switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n \t{\n \tcase GIMPLE_UNARY_RHS:\n-\t  return fold_unary (gimple_assign_rhs_code (stmt),\n+\t  return fold_unary_loc (loc, gimple_assign_rhs_code (stmt),\n \t\t\t     TREE_TYPE (gimple_assign_lhs (stmt)),\n \t\t\t     gimple_assign_rhs1 (stmt));\n \tcase GIMPLE_BINARY_RHS:\n-\t  return fold_binary (gimple_assign_rhs_code (stmt),\n+\t  return fold_binary_loc (loc, gimple_assign_rhs_code (stmt),\n \t\t\t      TREE_TYPE (gimple_assign_lhs (stmt)),\n \t\t\t      gimple_assign_rhs1 (stmt),\n \t\t\t      gimple_assign_rhs2 (stmt));"}, {"sha": "0f8b1c86bd63f60a7593df3da6e012672ded3082", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1884,7 +1884,7 @@ gimple_call_set_fndecl (gimple gs, tree decl)\n {\n   GIMPLE_CHECK (gs, GIMPLE_CALL);\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n-  gimple_set_op (gs, 1, build_fold_addr_expr (decl));\n+  gimple_set_op (gs, 1, build_fold_addr_expr_loc (gimple_location (gs), decl));\n }\n \n "}, {"sha": "cd3de9d5c6a49e17838a7a27dccd2ea2af9ea078", "filename": "gcc/gimplify.c", "status": "modified", "additions": 50, "deletions": 36, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1786,6 +1786,7 @@ static enum gimplify_status\n gimplify_conversion (tree *expr_p)\n {\n   tree tem;\n+  location_t loc = EXPR_LOCATION (*expr_p);\n   gcc_assert (CONVERT_EXPR_P (*expr_p));\n \n   /* Then strip away all but the outermost conversion.  */\n@@ -1827,7 +1828,7 @@ gimplify_conversion (tree *expr_p)\n   /* If we have a conversion to a non-register type force the\n      use of a VIEW_CONVERT_EXPR instead.  */\n   if (!is_gimple_reg_type (TREE_TYPE (*expr_p)))\n-    *expr_p = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*expr_p),\n+    *expr_p = fold_build1_loc (loc, VIEW_CONVERT_EXPR, TREE_TYPE (*expr_p),\n \t\t\t   TREE_OPERAND (*expr_p, 0));\n \n   return GS_OK;\n@@ -1933,6 +1934,7 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   VEC(tree,heap) *stack;\n   enum gimplify_status ret = GS_OK, tret;\n   int i;\n+  location_t loc = EXPR_LOCATION (*expr_p);\n \n   /* Create a stack of the subexpressions so later we can walk them in\n      order from inner to outer.  */\n@@ -1944,7 +1946,7 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n     restart:\n       /* Fold INDIRECT_REFs now to turn them into ARRAY_REFs.  */\n       if (TREE_CODE (*p) == INDIRECT_REF)\n-\t*p = fold_indirect_ref (*p);\n+\t*p = fold_indirect_ref_loc (loc, *p);\n \n       if (handled_component_p (*p))\n \t;\n@@ -2003,7 +2005,7 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \t      /* Divide the element size by the alignment of the element\n \t\t type (above).  */\n-\t      elmt_size = size_binop (EXACT_DIV_EXPR, elmt_size, factor);\n+\t      elmt_size = size_binop_loc (loc, EXACT_DIV_EXPR, elmt_size, factor);\n \n \t      if (!is_gimple_min_invariant (elmt_size))\n \t\t{\n@@ -2026,7 +2028,7 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t= size_int (DECL_OFFSET_ALIGN (field) / BITS_PER_UNIT);\n \n \t      /* Divide the offset by its alignment.  */\n-\t      offset = size_binop (EXACT_DIV_EXPR, offset, factor);\n+\t      offset = size_binop_loc (loc, EXACT_DIV_EXPR, offset, factor);\n \n \t      if (!is_gimple_min_invariant (offset))\n \t\t{\n@@ -2116,6 +2118,7 @@ gimplify_self_mod_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   bool postfix;\n   enum tree_code arith_code;\n   enum gimplify_status ret;\n+  location_t loc = EXPR_LOCATION (*expr_p);\n \n   code = TREE_CODE (*expr_p);\n \n@@ -2159,9 +2162,9 @@ gimplify_self_mod_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       if (!is_gimple_min_lval (lvalue))\n \t{\n \t  mark_addressable (lvalue);\n-\t  lvalue = build_fold_addr_expr (lvalue);\n+\t  lvalue = build_fold_addr_expr_loc (input_location, lvalue);\n \t  gimplify_expr (&lvalue, pre_p, post_p, is_gimple_val, fb_rvalue);\n-\t  lvalue = build_fold_indirect_ref (lvalue);\n+\t  lvalue = build_fold_indirect_ref_loc (input_location, lvalue);\n \t}\n       ret = gimplify_expr (&lhs, pre_p, post_p, is_gimple_val, fb_rvalue);\n       if (ret == GS_ERROR)\n@@ -2171,9 +2174,9 @@ gimplify_self_mod_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   /* For POINTERs increment, use POINTER_PLUS_EXPR.  */\n   if (POINTER_TYPE_P (TREE_TYPE (lhs)))\n     {\n-      rhs = fold_convert (sizetype, rhs);\n+      rhs = fold_convert_loc (loc, sizetype, rhs);\n       if (arith_code == MINUS_EXPR)\n-\trhs = fold_build1 (NEGATE_EXPR, TREE_TYPE (rhs), rhs);\n+\trhs = fold_build1_loc (loc, NEGATE_EXPR, TREE_TYPE (rhs), rhs);\n       arith_code = POINTER_PLUS_EXPR;\n     }\n \n@@ -2268,6 +2271,7 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   int i, nargs;\n   gimple call;\n   bool builtin_va_start_p = FALSE;\n+  location_t loc = EXPR_LOCATION (*expr_p);\n \n   gcc_assert (TREE_CODE (*expr_p) == CALL_EXPR);\n \n@@ -2291,7 +2295,7 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   fndecl = get_callee_fndecl (*expr_p);\n   if (fndecl && DECL_BUILT_IN (fndecl))\n     {\n-      tree new_tree = fold_call_expr (*expr_p, !want_value);\n+      tree new_tree = fold_call_expr (input_location, *expr_p, !want_value);\n \n       if (new_tree && new_tree != *expr_p)\n \t{\n@@ -2364,8 +2368,9 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n \t  tree call = *expr_p;\n \n \t  --nargs;\n-\t  *expr_p = build_call_array (TREE_TYPE (call), CALL_EXPR_FN (call),\n-\t\t\t\t      nargs, CALL_EXPR_ARGP (call));\n+\t  *expr_p = build_call_array_loc (loc, TREE_TYPE (call),\n+\t\t\t\t\t  CALL_EXPR_FN (call),\n+\t\t\t\t\t  nargs, CALL_EXPR_ARGP (call));\n \n \t  /* Copy all CALL_EXPR flags, location and block, except\n \t     CALL_EXPR_VA_ARG_PACK flag.  */\n@@ -2408,7 +2413,7 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   /* Try this again in case gimplification exposed something.  */\n   if (ret != GS_ERROR)\n     {\n-      tree new_tree = fold_call_expr (*expr_p, !want_value);\n+      tree new_tree = fold_call_expr (input_location, *expr_p, !want_value);\n \n       if (new_tree && new_tree != *expr_p)\n \t{\n@@ -2749,6 +2754,7 @@ tree\n gimple_boolify (tree expr)\n {\n   tree type = TREE_TYPE (expr);\n+  location_t loc = EXPR_LOCATION (expr);\n \n   if (TREE_CODE (type) == BOOLEAN_TYPE)\n     return expr;\n@@ -2777,7 +2783,7 @@ gimple_boolify (tree expr)\n     default:\n       /* Other expressions that get here must have boolean values, but\n \t might need to be converted to the appropriate mode.  */\n-      return fold_convert (boolean_type_node, expr);\n+      return fold_convert_loc (loc, boolean_type_node, expr);\n     }\n }\n \n@@ -2860,6 +2866,7 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n   gimple gimple_cond;\n   enum tree_code pred_code;\n   gimple_seq seq = NULL;\n+  location_t loc = EXPR_LOCATION (*expr_p);\n \n   type = TREE_TYPE (expr);\n \n@@ -2893,18 +2900,18 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n \n \t  if (TREE_TYPE (TREE_OPERAND (expr, 1)) != void_type_node)\n \t    TREE_OPERAND (expr, 1) =\n-\t      build_fold_addr_expr (TREE_OPERAND (expr, 1));\n+\t      build_fold_addr_expr_loc (loc, TREE_OPERAND (expr, 1));\n \n \t  if (TREE_TYPE (TREE_OPERAND (expr, 2)) != void_type_node)\n \t    TREE_OPERAND (expr, 2) =\n-\t      build_fold_addr_expr (TREE_OPERAND (expr, 2));\n+\t      build_fold_addr_expr_loc (loc, TREE_OPERAND (expr, 2));\n \n \t  tmp = create_tmp_var (type, \"iftmp\");\n \n \t  expr = build3 (COND_EXPR, void_type_node, TREE_OPERAND (expr, 0),\n \t\t\t TREE_OPERAND (expr, 1), TREE_OPERAND (expr, 2));\n \n-\t  result = build_fold_indirect_ref (tmp);\n+\t  result = build_fold_indirect_ref_loc (loc, tmp);\n \t}\n \n       /* Build the then clause, 't1 = a;'.  But don't build an assignment\n@@ -3083,17 +3090,18 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, tree size, bool want_value,\n {\n   tree t, to, to_ptr, from, from_ptr;\n   gimple gs;\n+  location_t loc = EXPR_LOCATION (*expr_p);\n \n   to = TREE_OPERAND (*expr_p, 0);\n   from = TREE_OPERAND (*expr_p, 1);\n \n   mark_addressable (from);\n-  from_ptr = build_fold_addr_expr (from);\n-  gimplify_arg (&from_ptr, seq_p, EXPR_LOCATION (*expr_p));\n+  from_ptr = build_fold_addr_expr_loc (loc, from);\n+  gimplify_arg (&from_ptr, seq_p, loc);\n \n   mark_addressable (to);\n-  to_ptr = build_fold_addr_expr (to);\n-  gimplify_arg (&to_ptr, seq_p, EXPR_LOCATION (*expr_p));\n+  to_ptr = build_fold_addr_expr_loc (loc, to);\n+  gimplify_arg (&to_ptr, seq_p, loc);\n \n   t = implicit_built_in_decls[BUILT_IN_MEMCPY];\n \n@@ -3125,6 +3133,7 @@ gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value,\n {\n   tree t, from, to, to_ptr;\n   gimple gs;\n+  location_t loc = EXPR_LOCATION (*expr_p);\n \n   /* Assert our assumptions, to abort instead of producing wrong code\n      silently if they are not met.  Beware that the RHS CONSTRUCTOR might\n@@ -3139,8 +3148,8 @@ gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value,\n   /* Now proceed.  */\n   to = TREE_OPERAND (*expr_p, 0);\n \n-  to_ptr = build_fold_addr_expr (to);\n-  gimplify_arg (&to_ptr, seq_p, EXPR_LOCATION (*expr_p));\n+  to_ptr = build_fold_addr_expr_loc (loc, to);\n+  gimplify_arg (&to_ptr, seq_p, loc);\n   t = implicit_built_in_decls[BUILT_IN_MEMSET];\n \n   gs = gimple_build_call (t, 3, to_ptr, integer_zero_node, size);\n@@ -4296,6 +4305,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   tree *to_p = &TREE_OPERAND (*expr_p, 0);\n   enum gimplify_status ret = GS_UNHANDLED;\n   gimple assign;\n+  location_t loc = EXPR_LOCATION (*expr_p);\n \n   gcc_assert (TREE_CODE (*expr_p) == MODIFY_EXPR\n \t      || TREE_CODE (*expr_p) == INIT_EXPR);\n@@ -4308,7 +4318,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n     {\n       STRIP_USELESS_TYPE_CONVERSION (*from_p);\n       if (!useless_type_conversion_p (TREE_TYPE (*to_p), TREE_TYPE (*from_p)))\n-\t*from_p = fold_convert (TREE_TYPE (*to_p), *from_p);\n+\t*from_p = fold_convert_loc (loc, TREE_TYPE (*to_p), *from_p);\n     }\n \n   /* See if any simplifications can be done based on what the RHS is.  */\n@@ -4450,14 +4460,15 @@ gimplify_variable_sized_compare (tree *expr_p)\n   tree op0 = TREE_OPERAND (*expr_p, 0);\n   tree op1 = TREE_OPERAND (*expr_p, 1);\n   tree t, arg, dest, src;\n+  location_t loc = EXPR_LOCATION (*expr_p);\n \n   arg = TYPE_SIZE_UNIT (TREE_TYPE (op0));\n   arg = unshare_expr (arg);\n   arg = SUBSTITUTE_PLACEHOLDER_IN_EXPR (arg, op0);\n-  src = build_fold_addr_expr (op1);\n-  dest = build_fold_addr_expr (op0);\n+  src = build_fold_addr_expr_loc (loc, op1);\n+  dest = build_fold_addr_expr_loc (loc, op0);\n   t = implicit_built_in_decls[BUILT_IN_MEMCMP];\n-  t = build_call_expr (t, 3, dest, src, arg);\n+  t = build_call_expr_loc (loc, t, 3, dest, src, arg);\n   *expr_p\n     = build2 (TREE_CODE (*expr_p), TREE_TYPE (*expr_p), t, integer_zero_node);\n \n@@ -4470,17 +4481,18 @@ gimplify_variable_sized_compare (tree *expr_p)\n static enum gimplify_status\n gimplify_scalar_mode_aggregate_compare (tree *expr_p)\n {\n+  location_t loc = EXPR_LOCATION (*expr_p);\n   tree op0 = TREE_OPERAND (*expr_p, 0);\n   tree op1 = TREE_OPERAND (*expr_p, 1);\n \n   tree type = TREE_TYPE (op0);\n   tree scalar_type = lang_hooks.types.type_for_mode (TYPE_MODE (type), 1);\n \n-  op0 = fold_build1 (VIEW_CONVERT_EXPR, scalar_type, op0);\n-  op1 = fold_build1 (VIEW_CONVERT_EXPR, scalar_type, op1);\n+  op0 = fold_build1_loc (loc, VIEW_CONVERT_EXPR, scalar_type, op0);\n+  op1 = fold_build1_loc (loc, VIEW_CONVERT_EXPR, scalar_type, op1);\n \n   *expr_p\n-    = fold_build2 (TREE_CODE (*expr_p), TREE_TYPE (*expr_p), op0, op1);\n+    = fold_build2_loc (loc, TREE_CODE (*expr_p), TREE_TYPE (*expr_p), op0, op1);\n \n   return GS_OK;\n }\n@@ -4502,8 +4514,8 @@ gimplify_boolean_expr (tree *expr_p, location_t locus)\n   tree type = TREE_TYPE (*expr_p);\n \n   *expr_p = build3 (COND_EXPR, type, *expr_p,\n-\t\t    fold_convert (type, boolean_true_node),\n-\t\t    fold_convert (type, boolean_false_node));\n+\t\t    fold_convert_loc (locus, type, boolean_true_node),\n+\t\t    fold_convert_loc (locus, type, boolean_false_node));\n \n   SET_EXPR_LOCATION (*expr_p, locus);\n \n@@ -4607,6 +4619,7 @@ gimplify_addr_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n   tree expr = *expr_p;\n   tree op0 = TREE_OPERAND (expr, 0);\n   enum gimplify_status ret;\n+  location_t loc = EXPR_LOCATION (*expr_p);\n \n   switch (TREE_CODE (op0))\n     {\n@@ -4628,7 +4641,7 @@ gimplify_addr_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \ttree t_op00 = TREE_TYPE (op00);\n \n         if (!useless_type_conversion_p (t_expr, t_op00))\n-\t  op00 = fold_convert (TREE_TYPE (expr), op00);\n+\t  op00 = fold_convert_loc (loc, TREE_TYPE (expr), op00);\n         *expr_p = op00;\n         ret = GS_OK;\n       }\n@@ -4647,8 +4660,9 @@ gimplify_addr_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       if (tree_ssa_useless_type_conversion (TREE_OPERAND (op0, 0)))\n \top0 = TREE_OPERAND (op0, 0);\n \n-      *expr_p = fold_convert (TREE_TYPE (expr),\n-\t\t\t      build_fold_addr_expr (TREE_OPERAND (op0, 0)));\n+      *expr_p = fold_convert_loc (loc, TREE_TYPE (expr),\n+\t\t\t\t  build_fold_addr_expr_loc (loc,\n+\t\t\t\t\t\t\tTREE_OPERAND (op0, 0)));\n       ret = GS_OK;\n       break;\n \n@@ -6556,7 +6570,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  break;\n \n \tcase INDIRECT_REF:\n-\t  *expr_p = fold_indirect_ref (*expr_p);\n+\t  *expr_p = fold_indirect_ref_loc (input_location, *expr_p);\n \t  if (*expr_p != save_expr)\n \t    break;\n \t  /* else fall through.  */\n@@ -7161,7 +7175,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       /* An lvalue will do.  Take the address of the expression, store it\n \t in a temporary, and replace the expression with an INDIRECT_REF of\n \t that temporary.  */\n-      tmp = build_fold_addr_expr (*expr_p);\n+      tmp = build_fold_addr_expr_loc (input_location, *expr_p);\n       gimplify_expr (&tmp, pre_p, post_p, is_gimple_reg, fb_rvalue);\n       *expr_p = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (tmp)), tmp);\n     }"}, {"sha": "55065e33636a568d98ab871db2512d65d227225a", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1,3 +1,10 @@\n+2009-07-17  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR 40435 \n+\t* objc-act.c: Add location argument to all calls to\n+\tbuild_fold_addr_expr.\n+\t\n 2009-07-14  Taras Glek  <tglek@mozilla.com>\n \t    Rafael Espindola  <espindola@google.com>\n "}, {"sha": "c110c79d331f882dda9549e85e7b7e558df307dd", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -3554,7 +3554,7 @@ static tree\n next_sjlj_build_try_exit (void)\n {\n   tree t;\n-  t = build_fold_addr_expr (cur_try_context->stack_decl);\n+  t = build_fold_addr_expr_loc (input_location, cur_try_context->stack_decl);\n   t = tree_cons (NULL, t, NULL);\n   t = build_function_call (input_location,\n \t\t\t   objc_exception_try_exit_decl, t);\n@@ -3575,14 +3575,14 @@ next_sjlj_build_enter_and_setjmp (void)\n {\n   tree t, enter, sj, cond;\n \n-  t = build_fold_addr_expr (cur_try_context->stack_decl);\n+  t = build_fold_addr_expr_loc (input_location, cur_try_context->stack_decl);\n   t = tree_cons (NULL, t, NULL);\n   enter = build_function_call (input_location,\n \t\t\t       objc_exception_try_enter_decl, t);\n \n   t = objc_build_component_ref (cur_try_context->stack_decl,\n \t\t\t\tget_identifier (\"buf\"));\n-  t = build_fold_addr_expr (t);\n+  t = build_fold_addr_expr_loc (input_location, t);\n #ifdef OBJCPLUS\n   /* Convert _setjmp argument to type that is expected.  */\n   if (TYPE_ARG_TYPES (TREE_TYPE (objc_setjmp_decl)))\n@@ -3611,7 +3611,7 @@ next_sjlj_build_exc_extract (tree decl)\n {\n   tree t;\n \n-  t = build_fold_addr_expr (cur_try_context->stack_decl);\n+  t = build_fold_addr_expr_loc (input_location, cur_try_context->stack_decl);\n   t = tree_cons (NULL, t, NULL);\n   t = build_function_call (input_location,\n \t\t\t   objc_exception_extract_decl, t);\n@@ -6623,7 +6623,7 @@ build_objc_method_call (location_t loc, int super_flag, tree method_prototype,\n       method_params = tree_cons (NULL_TREE, lookup_object,\n \t\t\t\t tree_cons (NULL_TREE, selector,\n \t\t\t\t\t    method_params));\n-      method = build_fold_addr_expr (sender);\n+      method = build_fold_addr_expr_loc (input_location, sender);\n     }\n   else\n     {\n@@ -6637,8 +6637,7 @@ build_objc_method_call (location_t loc, int super_flag, tree method_prototype,\n \n       t = tree_cons (NULL_TREE, selector, NULL_TREE);\n       t = tree_cons (NULL_TREE, lookup_object, t);\n-      method = build_function_call (loc,\n-\t\t\t\t    sender, t);\n+      method = build_function_call (loc, sender, t);\n \n       /* Pass the object to the method.  */\n       method_params = tree_cons (NULL_TREE, object,"}, {"sha": "1c20931cf75efa4aa55a21b291d9d442ea43a533", "filename": "gcc/omp-low.c", "status": "modified", "additions": 129, "deletions": 87, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -222,6 +222,7 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n   struct omp_for_data_loop *loop;\n   int i;\n   struct omp_for_data_loop dummy_loop;\n+  location_t loc = gimple_location (for_stmt);\n \n   fd->for_stmt = for_stmt;\n   fd->pre = NULL;\n@@ -309,19 +310,23 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n \t  break;\n \tcase LE_EXPR:\n \t  if (POINTER_TYPE_P (TREE_TYPE (loop->n2)))\n-\t    loop->n2 = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (loop->n2),\n+\t    loop->n2 = fold_build2_loc (loc,\n+\t\t\t\t    POINTER_PLUS_EXPR, TREE_TYPE (loop->n2),\n \t\t\t\t    loop->n2, size_one_node);\n \t  else\n-\t    loop->n2 = fold_build2 (PLUS_EXPR, TREE_TYPE (loop->n2), loop->n2,\n+\t    loop->n2 = fold_build2_loc (loc,\n+\t\t\t\t    PLUS_EXPR, TREE_TYPE (loop->n2), loop->n2,\n \t\t\t\t    build_int_cst (TREE_TYPE (loop->n2), 1));\n \t  loop->cond_code = LT_EXPR;\n \t  break;\n \tcase GE_EXPR:\n \t  if (POINTER_TYPE_P (TREE_TYPE (loop->n2)))\n-\t    loop->n2 = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (loop->n2),\n+\t    loop->n2 = fold_build2_loc (loc,\n+\t\t\t\t    POINTER_PLUS_EXPR, TREE_TYPE (loop->n2),\n \t\t\t\t    loop->n2, size_int (-1));\n \t  else\n-\t    loop->n2 = fold_build2 (MINUS_EXPR, TREE_TYPE (loop->n2), loop->n2,\n+\t    loop->n2 = fold_build2_loc (loc,\n+\t\t\t\t    MINUS_EXPR, TREE_TYPE (loop->n2), loop->n2,\n \t\t\t\t    build_int_cst (TREE_TYPE (loop->n2), 1));\n \t  loop->cond_code = GT_EXPR;\n \t  break;\n@@ -339,7 +344,8 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n \t  break;\n \tcase MINUS_EXPR:\n \t  loop->step = TREE_OPERAND (t, 1);\n-\t  loop->step = fold_build1 (NEGATE_EXPR, TREE_TYPE (loop->step),\n+\t  loop->step = fold_build1_loc (loc,\n+\t\t\t\t    NEGATE_EXPR, TREE_TYPE (loop->step),\n \t\t\t\t    loop->step);\n \t  break;\n \tdefault:\n@@ -357,7 +363,8 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n \t      tree n;\n \n \t      if (loop->cond_code == LT_EXPR)\n-\t\tn = fold_build2 (PLUS_EXPR, TREE_TYPE (loop->v),\n+\t\tn = fold_build2_loc (loc,\n+\t\t\t\t PLUS_EXPR, TREE_TYPE (loop->v),\n \t\t\t\t loop->n2, loop->step);\n \t      else\n \t\tn = loop->n1;\n@@ -373,12 +380,14 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n \t      if (loop->cond_code == LT_EXPR)\n \t\t{\n \t\t  n1 = loop->n1;\n-\t\t  n2 = fold_build2 (PLUS_EXPR, TREE_TYPE (loop->v),\n+\t\t  n2 = fold_build2_loc (loc,\n+\t\t\t\t    PLUS_EXPR, TREE_TYPE (loop->v),\n \t\t\t\t    loop->n2, loop->step);\n \t\t}\n \t      else\n \t\t{\n-\t\t  n1 = fold_build2 (MINUS_EXPR, TREE_TYPE (loop->v),\n+\t\t  n1 = fold_build2_loc (loc,\n+\t\t\t\t    MINUS_EXPR, TREE_TYPE (loop->v),\n \t\t\t\t    loop->n2, loop->step);\n \t\t  n2 = loop->n1;\n \t\t}\n@@ -404,24 +413,26 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n \t\titype\n \t\t  = lang_hooks.types.type_for_size (TYPE_PRECISION (itype), 0);\n \t      t = build_int_cst (itype, (loop->cond_code == LT_EXPR ? -1 : 1));\n-\t      t = fold_build2 (PLUS_EXPR, itype,\n-\t\t\t       fold_convert (itype, loop->step), t);\n-\t      t = fold_build2 (PLUS_EXPR, itype, t,\n-\t\t\t       fold_convert (itype, loop->n2));\n-\t      t = fold_build2 (MINUS_EXPR, itype, t,\n-\t\t\t       fold_convert (itype, loop->n1));\n+\t      t = fold_build2_loc (loc,\n+\t\t\t       PLUS_EXPR, itype,\n+\t\t\t       fold_convert_loc (loc, itype, loop->step), t);\n+\t      t = fold_build2_loc (loc, PLUS_EXPR, itype, t,\n+\t\t\t       fold_convert_loc (loc, itype, loop->n2));\n+\t      t = fold_build2_loc (loc, MINUS_EXPR, itype, t,\n+\t\t\t       fold_convert_loc (loc, itype, loop->n1));\n \t      if (TYPE_UNSIGNED (itype) && loop->cond_code == GT_EXPR)\n-\t\tt = fold_build2 (TRUNC_DIV_EXPR, itype,\n-\t\t\t\t fold_build1 (NEGATE_EXPR, itype, t),\n-\t\t\t\t fold_build1 (NEGATE_EXPR, itype,\n-\t\t\t\t\t      fold_convert (itype,\n-\t\t\t\t\t\t\t    loop->step)));\n+\t\tt = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype,\n+\t\t\t\t fold_build1_loc (loc, NEGATE_EXPR, itype, t),\n+\t\t\t\t fold_build1_loc (loc, NEGATE_EXPR, itype,\n+\t\t\t\t\t      fold_convert_loc (loc, itype,\n+\t\t\t\t\t\t\t\tloop->step)));\n \t      else\n-\t\tt = fold_build2 (TRUNC_DIV_EXPR, itype, t,\n-\t\t\t\t fold_convert (itype, loop->step));\n-\t      t = fold_convert (long_long_unsigned_type_node, t);\n+\t\tt = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype, t,\n+\t\t\t\t fold_convert_loc (loc, itype, loop->step));\n+\t      t = fold_convert_loc (loc, long_long_unsigned_type_node, t);\n \t      if (count != NULL_TREE)\n-\t\tcount = fold_build2 (MULT_EXPR, long_long_unsigned_type_node,\n+\t\tcount = fold_build2_loc (loc,\n+\t\t\t\t     MULT_EXPR, long_long_unsigned_type_node,\n \t\t\t\t     count, t);\n \t      else\n \t\tcount = t;\n@@ -448,7 +459,7 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n   if (collapse_count && *collapse_count == NULL)\n     {\n       if (count)\n-\t*collapse_count = fold_convert (iter_type, count);\n+\t*collapse_count = fold_convert_loc (loc, iter_type, count);\n       else\n \t*collapse_count = create_tmp_var (iter_type, \".count\");\n     }\n@@ -550,6 +561,7 @@ static tree\n get_ws_args_for (gimple ws_stmt)\n {\n   tree t;\n+  location_t loc = gimple_location (ws_stmt);\n \n   if (gimple_code (ws_stmt) == GIMPLE_OMP_FOR)\n     {\n@@ -561,17 +573,17 @@ get_ws_args_for (gimple ws_stmt)\n       ws_args = NULL_TREE;\n       if (fd.chunk_size)\n \t{\n-\t  t = fold_convert (long_integer_type_node, fd.chunk_size);\n+\t  t = fold_convert_loc (loc, long_integer_type_node, fd.chunk_size);\n \t  ws_args = tree_cons (NULL, t, ws_args);\n \t}\n \n-      t = fold_convert (long_integer_type_node, fd.loop.step);\n+      t = fold_convert_loc (loc, long_integer_type_node, fd.loop.step);\n       ws_args = tree_cons (NULL, t, ws_args);\n \n-      t = fold_convert (long_integer_type_node, fd.loop.n2);\n+      t = fold_convert_loc (loc, long_integer_type_node, fd.loop.n2);\n       ws_args = tree_cons (NULL, t, ws_args);\n \n-      t = fold_convert (long_integer_type_node, fd.loop.n1);\n+      t = fold_convert_loc (loc, long_integer_type_node, fd.loop.n1);\n       ws_args = tree_cons (NULL, t, ws_args);\n \n       return ws_args;\n@@ -1669,6 +1681,7 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n   omp_context *ctx;\n   tree name, t;\n   gimple stmt = gsi_stmt (*gsi);\n+  location_t loc = gimple_location (stmt);\n \n   /* Ignore task directives with empty bodies.  */\n   if (optimize > 0\n@@ -1733,7 +1746,7 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n       fixup_child_record_type (ctx);\n       if (ctx->srecord_type)\n \tlayout_type (ctx->srecord_type);\n-      t = fold_convert (long_integer_type_node,\n+      t = fold_convert_loc (loc, long_integer_type_node,\n \t\t\tTYPE_SIZE_UNIT (ctx->record_type));\n       gimple_omp_task_set_arg_size (stmt, t);\n       t = build_int_cst (long_integer_type_node,\n@@ -2142,6 +2155,7 @@ maybe_lookup_decl_in_outer_ctx (tree decl, omp_context *ctx)\n tree\n omp_reduction_init (tree clause, tree type)\n {\n+  location_t loc = OMP_CLAUSE_LOCATION (clause);\n   switch (OMP_CLAUSE_REDUCTION_CODE (clause))\n     {\n     case PLUS_EXPR:\n@@ -2152,16 +2166,16 @@ omp_reduction_init (tree clause, tree type)\n     case TRUTH_ORIF_EXPR:\n     case TRUTH_XOR_EXPR:\n     case NE_EXPR:\n-      return fold_convert (type, integer_zero_node);\n+      return fold_convert_loc (loc, type, integer_zero_node);\n \n     case MULT_EXPR:\n     case TRUTH_AND_EXPR:\n     case TRUTH_ANDIF_EXPR:\n     case EQ_EXPR:\n-      return fold_convert (type, integer_one_node);\n+      return fold_convert_loc (loc, type, integer_one_node);\n \n     case BIT_AND_EXPR:\n-      return fold_convert (type, integer_minus_one_node);\n+      return fold_convert_loc (loc, type, integer_minus_one_node);\n \n     case MAX_EXPR:\n       if (SCALAR_FLOAT_TYPE_P (type))\n@@ -2233,6 +2247,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t  enum omp_clause_code c_kind = OMP_CLAUSE_CODE (c);\n \t  tree var, new_var;\n \t  bool by_ref;\n+\t  location_t clause_loc = OMP_CLAUSE_LOCATION (c);\n \n \t  switch (c_kind)\n \t    {\n@@ -2299,7 +2314,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n \t\t  gimple_seq_add_stmt (ilist, stmt);\n \n-\t\t  x = fold_convert (TREE_TYPE (ptr), tmp);\n+\t\t  x = fold_convert_loc (clause_loc, TREE_TYPE (ptr), tmp);\n \t\t  gimplify_assign (ptr, x, ilist);\n \t\t}\n \t    }\n@@ -2320,7 +2335,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      if (c_kind == OMP_CLAUSE_FIRSTPRIVATE && is_task_ctx (ctx))\n \t\t{\n \t\t  x = build_receiver_ref (var, false, ctx);\n-\t\t  x = build_fold_addr_expr (x);\n+\t\t  x = build_fold_addr_expr_loc (clause_loc, x);\n \t\t}\n \t      else if (TREE_CONSTANT (x))\n \t\t{\n@@ -2332,17 +2347,18 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t\t\t  name);\n \t\t  gimple_add_tmp_var (x);\n \t\t  TREE_ADDRESSABLE (x) = 1;\n-\t\t  x = build_fold_addr_expr (x);\n+\t\t  x = build_fold_addr_expr_loc (clause_loc, x);\n \t\t}\n \t      else\n \t\t{\n-\t\t  x = build_call_expr (built_in_decls[BUILT_IN_ALLOCA], 1, x);\n+\t\t  x = build_call_expr_loc (clause_loc,\n+\t\t\t\t       built_in_decls[BUILT_IN_ALLOCA], 1, x);\n \t\t}\n \n-\t      x = fold_convert (TREE_TYPE (new_var), x);\n+\t      x = fold_convert_loc (clause_loc, TREE_TYPE (new_var), x);\n \t      gimplify_assign (new_var, x, ilist);\n \n-\t      new_var = build_fold_indirect_ref (new_var);\n+\t      new_var = build_fold_indirect_ref_loc (clause_loc, new_var);\n \t    }\n \t  else if (c_kind == OMP_CLAUSE_REDUCTION\n \t\t   && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n@@ -2446,7 +2462,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  x = build_outer_var_ref (var, ctx);\n \n \t\t  if (is_reference (var))\n-\t\t    x = build_fold_addr_expr (x);\n+\t\t    x = build_fold_addr_expr_loc (clause_loc, x);\n \t\t  SET_DECL_VALUE_EXPR (placeholder, x);\n \t\t  DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n \t\t  lower_omp (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c), ctx);\n@@ -2543,6 +2559,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n   for (c = clauses; c ;)\n     {\n       tree var, new_var;\n+      location_t clause_loc = OMP_CLAUSE_LOCATION (c);\n \n       if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n \t{\n@@ -2559,7 +2576,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \n \t  x = build_outer_var_ref (var, ctx);\n \t  if (is_reference (var))\n-\t    new_var = build_fold_indirect_ref (new_var);\n+\t    new_var = build_fold_indirect_ref_loc (clause_loc, new_var);\n \t  x = lang_hooks.decls.omp_clause_assign_op (c, x, new_var);\n \t  gimplify_and_add (x, stmt_list);\n \t}\n@@ -2618,14 +2635,15 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n     {\n       tree var, ref, new_var;\n       enum tree_code code;\n+      location_t clause_loc = OMP_CLAUSE_LOCATION (c);\n \n       if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n \tcontinue;\n \n       var = OMP_CLAUSE_DECL (c);\n       new_var = lookup_decl (var, ctx);\n       if (is_reference (var))\n-\tnew_var = build_fold_indirect_ref (new_var);\n+\tnew_var = build_fold_indirect_ref_loc (clause_loc, new_var);\n       ref = build_outer_var_ref (var, ctx);\n       code = OMP_CLAUSE_REDUCTION_CODE (c);\n \n@@ -2636,11 +2654,11 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \n       if (count == 1)\n \t{\n-\t  tree addr = build_fold_addr_expr (ref);\n+\t  tree addr = build_fold_addr_expr_loc (clause_loc, ref);\n \n \t  addr = save_expr (addr);\n \t  ref = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (addr)), addr);\n-\t  x = fold_build2 (code, TREE_TYPE (ref), ref, new_var);\n+\t  x = fold_build2_loc (clause_loc, code, TREE_TYPE (ref), ref, new_var);\n \t  x = build2 (OMP_ATOMIC, void_type_node, addr, x);\n \t  gimplify_and_add (x, stmt_seqp);\n \t  return;\n@@ -2651,7 +2669,7 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \t  tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n \n \t  if (is_reference (var))\n-\t    ref = build_fold_addr_expr (ref);\n+\t    ref = build_fold_addr_expr_loc (clause_loc, ref);\n \t  SET_DECL_VALUE_EXPR (placeholder, ref);\n \t  DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n \t  lower_omp (OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c), ctx);\n@@ -2689,6 +2707,7 @@ lower_copyprivate_clauses (tree clauses, gimple_seq *slist, gimple_seq *rlist,\n     {\n       tree var, ref, x;\n       bool by_ref;\n+      location_t clause_loc = OMP_CLAUSE_LOCATION (c);\n \n       if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_COPYPRIVATE)\n \tcontinue;\n@@ -2698,14 +2717,14 @@ lower_copyprivate_clauses (tree clauses, gimple_seq *slist, gimple_seq *rlist,\n \n       ref = build_sender_ref (var, ctx);\n       x = lookup_decl_in_outer_ctx (var, ctx);\n-      x = by_ref ? build_fold_addr_expr (x) : x;\n+      x = by_ref ? build_fold_addr_expr_loc (clause_loc, x) : x;\n       gimplify_assign (ref, x, slist);\n \n       ref = build_receiver_ref (var, by_ref, ctx);\n       if (is_reference (var))\n \t{\n-\t  ref = build_fold_indirect_ref (ref);\n-\t  var = build_fold_indirect_ref (var);\n+\t  ref = build_fold_indirect_ref_loc (clause_loc, ref);\n+\t  var = build_fold_indirect_ref_loc (clause_loc, var);\n \t}\n       x = lang_hooks.decls.omp_clause_assign_op (c, var, ref);\n       gimplify_and_add (x, rlist);\n@@ -2726,6 +2745,7 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,\n     {\n       tree val, ref, x, var;\n       bool by_ref, do_in = false, do_out = false;\n+      location_t clause_loc = OMP_CLAUSE_LOCATION (c);\n \n       switch (OMP_CLAUSE_CODE (c))\n \t{\n@@ -2787,7 +2807,7 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,\n       if (do_in)\n \t{\n \t  ref = build_sender_ref (val, ctx);\n-\t  x = by_ref ? build_fold_addr_expr (var) : var;\n+\t  x = by_ref ? build_fold_addr_expr_loc (clause_loc, var) : var;\n \t  gimplify_assign (ref, x, ilist);\n \t  if (is_task_ctx (ctx))\n \t    DECL_ABSTRACT_ORIGIN (TREE_OPERAND (ref, 1)) = NULL;\n@@ -2883,6 +2903,7 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n   int start_ix;\n+  location_t clause_loc;\n \n   clauses = gimple_omp_parallel_clauses (entry_stmt);\n \n@@ -2919,10 +2940,15 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \n   c = find_omp_clause (clauses, OMP_CLAUSE_NUM_THREADS);\n   if (c)\n-    val = OMP_CLAUSE_NUM_THREADS_EXPR (c);\n+    {\n+      val = OMP_CLAUSE_NUM_THREADS_EXPR (c);\n+      clause_loc = OMP_CLAUSE_LOCATION (c);\n+    }\n+  else\n+    clause_loc = gimple_location (entry_stmt);\n \n   /* Ensure 'val' is of the correct type.  */\n-  val = fold_convert (unsigned_type_node, val);\n+  val = fold_convert_loc (clause_loc, unsigned_type_node, val);\n \n   /* If we found the clause 'if (cond)', build either\n      (cond != 0) or (cond ? val : 1u).  */\n@@ -2933,7 +2959,8 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n       cond = gimple_boolify (cond);\n \n       if (integer_zerop (val))\n-\tval = fold_build2 (EQ_EXPR, unsigned_type_node, cond,\n+\tval = fold_build2_loc (clause_loc,\n+\t\t\t   EQ_EXPR, unsigned_type_node, cond,\n \t\t\t   build_int_cst (TREE_TYPE (cond), 0));\n       else\n \t{\n@@ -3012,7 +3039,8 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n       tree args = tree_cons (NULL, t2,\n \t\t\t     tree_cons (NULL, t1,\n \t\t\t\t\ttree_cons (NULL, val, ws_args)));\n-      t = build_function_call_expr (built_in_decls[start_ix], args);\n+      t = build_function_call_expr (UNKNOWN_LOCATION,\n+\t\t\t\t    built_in_decls[start_ix], args);\n     }\n   else\n     t = build_call_expr (built_in_decls[start_ix], 3, t2, t1, val);\n@@ -3025,11 +3053,13 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n     t = null_pointer_node;\n   else\n     t = build_fold_addr_expr (t);\n-  t = build_call_expr (gimple_omp_parallel_child_fn (entry_stmt), 1, t);\n+  t = build_call_expr_loc (gimple_location (entry_stmt),\n+\t\t\t   gimple_omp_parallel_child_fn (entry_stmt), 1, t);\n   force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t    false, GSI_CONTINUE_LINKING);\n \n-  t = build_call_expr (built_in_decls[BUILT_IN_GOMP_PARALLEL_END], 0);\n+  t = build_call_expr_loc (gimple_location (entry_stmt),\n+\t\t\t   built_in_decls[BUILT_IN_GOMP_PARALLEL_END], 0);\n   force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t    false, GSI_CONTINUE_LINKING);\n }\n@@ -3043,6 +3073,7 @@ expand_task_call (basic_block bb, gimple entry_stmt)\n {\n   tree t, t1, t2, t3, flags, cond, c, clauses;\n   gimple_stmt_iterator gsi;\n+  location_t loc = gimple_location (entry_stmt);\n \n   clauses = gimple_omp_task_clauses (entry_stmt);\n \n@@ -3060,13 +3091,13 @@ expand_task_call (basic_block bb, gimple entry_stmt)\n   if (t == NULL)\n     t2 = null_pointer_node;\n   else\n-    t2 = build_fold_addr_expr (t);\n-  t1 = build_fold_addr_expr (gimple_omp_task_child_fn (entry_stmt));\n+    t2 = build_fold_addr_expr_loc (loc, t);\n+  t1 = build_fold_addr_expr_loc (loc, gimple_omp_task_child_fn (entry_stmt));\n   t = gimple_omp_task_copy_fn (entry_stmt);\n   if (t == NULL)\n     t3 = null_pointer_node;\n   else\n-    t3 = build_fold_addr_expr (t);\n+    t3 = build_fold_addr_expr_loc (loc, t);\n \n   t = build_call_expr (built_in_decls[BUILT_IN_GOMP_TASK], 7, t1, t2, t3,\n \t\t       gimple_omp_task_arg_size (entry_stmt),\n@@ -4887,6 +4918,7 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n   basic_block store_bb = single_succ (load_bb);\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n+  location_t loc;\n \n   /* We expect to find the following sequences:\n    \n@@ -4904,6 +4936,7 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n \n   gsi = gsi_after_labels (store_bb);\n   stmt = gsi_stmt (gsi);\n+  loc = gimple_location (stmt);\n   if (!is_gimple_assign (stmt))\n     return false;\n   gsi_next (&gsi);\n@@ -4957,8 +4990,10 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n \n   gsi = gsi_last_bb (load_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_ATOMIC_LOAD);\n-  call = build_call_expr (decl, 2, addr, fold_convert (itype, rhs));\n-  call = fold_convert (void_type_node, call);\n+  call = build_call_expr_loc (loc,\n+\t\t\t  decl, 2, addr,\n+\t\t\t  fold_convert_loc (loc, itype, rhs));\n+  call = fold_convert_loc (loc, void_type_node, call);\n   force_gimple_operand_gsi (&gsi, call, true, NULL_TREE, true, GSI_SAME_STMT);\n   gsi_remove (&gsi, true);\n \n@@ -5180,7 +5215,7 @@ expand_omp_atomic_mutex (basic_block load_bb, basic_block store_bb,\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_ATOMIC_LOAD);\n \n   t = built_in_decls[BUILT_IN_GOMP_ATOMIC_START];\n-  t = build_function_call_expr (t, 0);\n+  t = build_function_call_expr (UNKNOWN_LOCATION, t, 0);\n   force_gimple_operand_gsi (&si, t, true, NULL_TREE, true, GSI_SAME_STMT);\n \n   stmt = gimple_build_assign (loaded_val, build_fold_indirect_ref (addr));\n@@ -5195,7 +5230,7 @@ expand_omp_atomic_mutex (basic_block load_bb, basic_block store_bb,\n   gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n \n   t = built_in_decls[BUILT_IN_GOMP_ATOMIC_END];\n-  t = build_function_call_expr (t, 0);\n+  t = build_function_call_expr (UNKNOWN_LOCATION, t, 0);\n   force_gimple_operand_gsi (&si, t, true, NULL_TREE, true, GSI_SAME_STMT);\n   gsi_remove (&si, true);\n \n@@ -5618,7 +5653,8 @@ lower_omp_single_simple (gimple single_stmt, gimple_seq *pre_p)\n   gimple_seq_add_stmt (pre_p, call);\n \n   cond = gimple_build_cond (EQ_EXPR, lhs,\n-\t\t\t    fold_convert (TREE_TYPE (lhs), boolean_true_node),\n+\t\t\t    fold_convert_loc (loc, TREE_TYPE (lhs),\n+\t\t\t\t\t      boolean_true_node),\n \t\t\t    tlabel, flabel);\n   gimple_seq_add_stmt (pre_p, cond);\n   gimple_seq_add_stmt (pre_p, gimple_build_label (tlabel));\n@@ -5672,8 +5708,8 @@ lower_omp_single_copy (gimple single_stmt, gimple_seq *pre_p, omp_context *ctx)\n   l1 = create_artificial_label (loc);\n   l2 = create_artificial_label (loc);\n \n-  t = build_call_expr (built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_START], 0);\n-  t = fold_convert (ptr_type, t);\n+  t = build_call_expr_loc (loc, built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_START], 0);\n+  t = fold_convert_loc (loc, ptr_type, t);\n   gimplify_assign (ctx->receiver_decl, t, pre_p);\n \n   t = build2 (EQ_EXPR, boolean_type_node, ctx->receiver_decl,\n@@ -5690,8 +5726,9 @@ lower_omp_single_copy (gimple single_stmt, gimple_seq *pre_p, omp_context *ctx)\n   lower_copyprivate_clauses (gimple_omp_single_clauses (single_stmt), pre_p,\n \t\t\t      &copyin_seq, ctx);\n \n-  t = build_fold_addr_expr (ctx->sender_decl);\n-  t = build_call_expr (built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_END], 1, t);\n+  t = build_fold_addr_expr_loc (loc, ctx->sender_decl);\n+  t = build_call_expr_loc (loc, built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_END],\n+\t\t       1, t);\n   gimplify_and_add (t, pre_p);\n \n   t = build_and_jump (&l2);\n@@ -5760,6 +5797,7 @@ lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree block, lab = NULL, x;\n   gimple stmt = gsi_stmt (*gsi_p), bind;\n+  location_t loc = gimple_location (stmt);\n   gimple_seq tseq;\n   struct gimplify_ctx gctx;\n \n@@ -5769,7 +5807,7 @@ lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   bind = gimple_build_bind (NULL, gimple_seq_alloc_with_stmt (stmt),\n       \t\t\t\t block);\n \n-  x = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n+  x = build_call_expr_loc (loc, built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n   x = build2 (EQ_EXPR, boolean_type_node, x, integer_zero_node);\n   x = build3 (COND_EXPR, void_type_node, x, NULL, build_and_jump (&lab));\n   tseq = NULL;\n@@ -5843,6 +5881,7 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   tree block;\n   tree name, lock, unlock;\n   gimple stmt = gsi_stmt (*gsi_p), bind;\n+  location_t loc = gimple_location (stmt);\n   gimple_seq tbody;\n   struct gimplify_ctx gctx;\n \n@@ -5880,18 +5919,19 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \tdecl = (tree) n->value;\n \n       lock = built_in_decls[BUILT_IN_GOMP_CRITICAL_NAME_START];\n-      lock = build_call_expr (lock, 1, build_fold_addr_expr (decl));\n+      lock = build_call_expr_loc (loc, lock, 1, build_fold_addr_expr_loc (loc, decl));\n \n       unlock = built_in_decls[BUILT_IN_GOMP_CRITICAL_NAME_END];\n-      unlock = build_call_expr (unlock, 1, build_fold_addr_expr (decl));\n+      unlock = build_call_expr_loc (loc, unlock, 1,\n+\t\t\t\tbuild_fold_addr_expr_loc (loc, decl));\n     }\n   else\n     {\n       lock = built_in_decls[BUILT_IN_GOMP_CRITICAL_START];\n-      lock = build_call_expr (lock, 0);\n+      lock = build_call_expr_loc (loc, lock, 0);\n \n       unlock = built_in_decls[BUILT_IN_GOMP_CRITICAL_END];\n-      unlock = build_call_expr (unlock, 0);\n+      unlock = build_call_expr_loc (loc, unlock, 0);\n     }\n \n   push_gimplify_context (&gctx);\n@@ -6152,6 +6192,7 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n   splay_tree_node n;\n   struct omp_taskcopy_context tcctx;\n   struct gimplify_ctx gctx;\n+  location_t loc = gimple_location (task_stmt);\n \n   child_fn = gimple_omp_task_copy_fn (task_stmt);\n   child_cfun = DECL_STRUCT_FUNCTION (child_fn);\n@@ -6233,7 +6274,7 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t  n = splay_tree_lookup (ctx->sfield_map, (splay_tree_key) decl);\n \t  sf = (tree) n->value;\n \t  sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n-\t  src = build_fold_indirect_ref (sarg);\n+\t  src = build_fold_indirect_ref_loc (loc, sarg);\n \t  src = build3 (COMPONENT_REF, TREE_TYPE (sf), src, sf, NULL);\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (*p), *p, src);\n \t  append_to_statement_list (t, &list);\n@@ -6256,9 +6297,9 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \tsf = (tree) n->value;\n \tif (tcctx.cb.decl_map)\n \t  sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n-\tsrc = build_fold_indirect_ref (sarg);\n+\tsrc = build_fold_indirect_ref_loc (loc, sarg);\n \tsrc = build3 (COMPONENT_REF, TREE_TYPE (sf), src, sf, NULL);\n-\tdst = build_fold_indirect_ref (arg);\n+\tdst = build_fold_indirect_ref_loc (loc, arg);\n \tdst = build3 (COMPONENT_REF, TREE_TYPE (f), dst, f, NULL);\n \tt = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n \tappend_to_statement_list (t, &list);\n@@ -6279,14 +6320,14 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t    sf = (tree) n->value;\n \t    if (tcctx.cb.decl_map)\n \t      sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n-\t    src = build_fold_indirect_ref (sarg);\n+\t    src = build_fold_indirect_ref_loc (loc, sarg);\n \t    src = build3 (COMPONENT_REF, TREE_TYPE (sf), src, sf, NULL);\n \t    if (use_pointer_for_field (decl, NULL) || is_reference (decl))\n-\t      src = build_fold_indirect_ref (src);\n+\t      src = build_fold_indirect_ref_loc (loc, src);\n \t  }\n \telse\n \t  src = decl;\n-\tdst = build_fold_indirect_ref (arg);\n+\tdst = build_fold_indirect_ref_loc (loc, arg);\n \tdst = build3 (COMPONENT_REF, TREE_TYPE (f), dst, f, NULL);\n \tt = lang_hooks.decls.omp_clause_copy_ctor (c, dst, src);\n \tappend_to_statement_list (t, &list);\n@@ -6305,14 +6346,14 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t    sf = (tree) n->value;\n \t    if (tcctx.cb.decl_map)\n \t      sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n-\t    src = build_fold_indirect_ref (sarg);\n+\t    src = build_fold_indirect_ref_loc (loc, sarg);\n \t    src = build3 (COMPONENT_REF, TREE_TYPE (sf), src, sf, NULL);\n \t    if (use_pointer_for_field (decl, NULL))\n-\t      src = build_fold_indirect_ref (src);\n+\t      src = build_fold_indirect_ref_loc (loc, src);\n \t  }\n \telse\n \t  src = decl;\n-\tdst = build_fold_indirect_ref (arg);\n+\tdst = build_fold_indirect_ref_loc (loc, arg);\n \tdst = build3 (COMPONENT_REF, TREE_TYPE (f), dst, f, NULL);\n \tt = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n \tappend_to_statement_list (t, &list);\n@@ -6344,21 +6385,21 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t\t\t\t (splay_tree_key) TREE_OPERAND (ind, 0));\n \t  sf = (tree) n->value;\n \t  sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n-\t  src = build_fold_indirect_ref (sarg);\n+\t  src = build_fold_indirect_ref_loc (loc, sarg);\n \t  src = build3 (COMPONENT_REF, TREE_TYPE (sf), src, sf, NULL);\n-\t  src = build_fold_indirect_ref (src);\n-\t  dst = build_fold_indirect_ref (arg);\n+\t  src = build_fold_indirect_ref_loc (loc, src);\n+\t  dst = build_fold_indirect_ref_loc (loc, arg);\n \t  dst = build3 (COMPONENT_REF, TREE_TYPE (f), dst, f, NULL);\n \t  t = lang_hooks.decls.omp_clause_copy_ctor (c, dst, src);\n \t  append_to_statement_list (t, &list);\n \t  n = splay_tree_lookup (ctx->field_map,\n \t\t\t\t (splay_tree_key) TREE_OPERAND (ind, 0));\n \t  df = (tree) n->value;\n \t  df = *(tree *) pointer_map_contains (tcctx.cb.decl_map, df);\n-\t  ptr = build_fold_indirect_ref (arg);\n+\t  ptr = build_fold_indirect_ref_loc (loc, arg);\n \t  ptr = build3 (COMPONENT_REF, TREE_TYPE (df), ptr, df, NULL);\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (ptr), ptr,\n-\t\t      build_fold_addr_expr (dst));\n+\t\t      build_fold_addr_expr_loc (loc, dst));\n \t  append_to_statement_list (t, &list);\n \t}\n \n@@ -6385,6 +6426,7 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gimple par_bind, bind;\n   gimple_seq par_body, olist, ilist, par_olist, par_ilist, new_body;\n   struct gimplify_ctx gctx;\n+  location_t loc = gimple_location (stmt);\n \n   clauses = gimple_omp_taskreg_clauses (stmt);\n   par_bind = gimple_seq_first_stmt (gimple_omp_body (stmt));\n@@ -6441,9 +6483,9 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   if (ctx->record_type)\n     {\n-      t = build_fold_addr_expr (ctx->sender_decl);\n+      t = build_fold_addr_expr_loc (loc, ctx->sender_decl);\n       /* fixup_child_record_type might have changed receiver_decl's type.  */\n-      t = fold_convert (TREE_TYPE (ctx->receiver_decl), t);\n+      t = fold_convert_loc (loc, TREE_TYPE (ctx->receiver_decl), t);\n       gimple_seq_add_stmt (&new_body,\n \t  \t\t   gimple_build_assign (ctx->receiver_decl, t));\n     }"}, {"sha": "47ce848b170f506a3f41fc749cd9b3d7b7721321", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -342,7 +342,7 @@ self_referential_size (tree size)\n   VEC_safe_push (tree, gc, size_functions, fndecl);\n \n   /* Replace the original expression with a call to the size function.  */\n-  return build_function_call_expr (fndecl, arg_list);\n+  return build_function_call_expr (input_location, fndecl, arg_list);\n }\n \n /* Take, queue and compile all the size functions.  It is essential that\n@@ -515,6 +515,7 @@ layout_decl (tree decl, unsigned int known_align)\n   tree type = TREE_TYPE (decl);\n   enum tree_code code = TREE_CODE (decl);\n   rtx rtl = NULL_RTX;\n+  location_t loc = DECL_SOURCE_LOCATION (decl);\n \n   if (code == CONST_DECL)\n     return;\n@@ -548,8 +549,9 @@ layout_decl (tree decl, unsigned int known_align)\n     }\n   else if (DECL_SIZE_UNIT (decl) == 0)\n     DECL_SIZE_UNIT (decl)\n-      = fold_convert (sizetype, size_binop (CEIL_DIV_EXPR, DECL_SIZE (decl),\n-\t\t\t\t\t    bitsize_unit_node));\n+      = fold_convert_loc (loc, sizetype,\n+\t\t\t  size_binop_loc (loc, CEIL_DIV_EXPR, DECL_SIZE (decl),\n+\t\t\t\t\t  bitsize_unit_node));\n \n   if (code != FIELD_DECL)\n     /* For non-fields, update the alignment from the type.  */\n@@ -994,7 +996,7 @@ place_union_field (record_layout_info rli, tree field)\n   if (TREE_CODE (rli->t) == UNION_TYPE)\n     rli->offset = size_binop (MAX_EXPR, rli->offset, DECL_SIZE_UNIT (field));\n   else if (TREE_CODE (rli->t) == QUAL_UNION_TYPE)\n-    rli->offset = fold_build3 (COND_EXPR, sizetype,\n+    rli->offset = fold_build3_loc (input_location, COND_EXPR, sizetype,\n \t\t\t       DECL_QUALIFIER (field),\n \t\t\t       DECL_SIZE_UNIT (field), rli->offset);\n }\n@@ -1181,7 +1183,7 @@ place_field (record_layout_info rli, tree field)\n \t\t   field);\n \t    }\n \t  else\n-\t    rli->bitpos = round_up (rli->bitpos, type_align);\n+\t    rli->bitpos = round_up_loc (input_location, rli->bitpos, type_align);\n \t}\n \n       if (! DECL_PACKED (field))\n@@ -1361,7 +1363,7 @@ place_field (record_layout_info rli, tree field)\n \t  if (maximum_field_alignment != 0)\n \t    type_align = MIN (type_align, maximum_field_alignment);\n \n-\t  rli->bitpos = round_up (rli->bitpos, type_align);\n+\t  rli->bitpos = round_up_loc (input_location, rli->bitpos, type_align);\n \n           /* If we really aligned, don't allow subsequent bitfields\n \t     to undo that.  */\n@@ -1475,9 +1477,10 @@ finalize_record_size (record_layout_info rli)\n       = size_binop (PLUS_EXPR, unpadded_size_unit, size_one_node);\n \n   /* Round the size up to be a multiple of the required alignment.  */\n-  TYPE_SIZE (rli->t) = round_up (unpadded_size, TYPE_ALIGN (rli->t));\n+  TYPE_SIZE (rli->t) = round_up_loc (input_location, unpadded_size,\n+\t\t\t\t TYPE_ALIGN (rli->t));\n   TYPE_SIZE_UNIT (rli->t)\n-    = round_up (unpadded_size_unit, TYPE_ALIGN_UNIT (rli->t));\n+    = round_up_loc (input_location, unpadded_size_unit, TYPE_ALIGN_UNIT (rli->t));\n \n   if (TREE_CONSTANT (unpadded_size)\n       && simple_cst_equal (unpadded_size, TYPE_SIZE (rli->t)) == 0)\n@@ -1496,7 +1499,7 @@ finalize_record_size (record_layout_info rli)\n       rli->unpacked_align = MAX (TYPE_ALIGN (rli->t), rli->unpacked_align);\n #endif\n \n-      unpacked_size = round_up (TYPE_SIZE (rli->t), rli->unpacked_align);\n+      unpacked_size = round_up_loc (input_location, TYPE_SIZE (rli->t), rli->unpacked_align);\n       if (simple_cst_equal (unpacked_size, TYPE_SIZE (rli->t)))\n \t{\n \t  TYPE_PACKED (rli->t) = 0;\n@@ -1650,8 +1653,9 @@ finalize_type_size (tree type)\n \n   if (TYPE_SIZE (type) != 0)\n     {\n-      TYPE_SIZE (type) = round_up (TYPE_SIZE (type), TYPE_ALIGN (type));\n-      TYPE_SIZE_UNIT (type) = round_up (TYPE_SIZE_UNIT (type),\n+      TYPE_SIZE (type) = round_up_loc (input_location,\n+\t\t\t\t   TYPE_SIZE (type), TYPE_ALIGN (type));\n+      TYPE_SIZE_UNIT (type) = round_up_loc (input_location, TYPE_SIZE_UNIT (type),\n \t\t\t\t\tTYPE_ALIGN_UNIT (type));\n     }\n \n@@ -1959,7 +1963,8 @@ layout_type (tree type)\n \t       that (possible) negative values are handled appropriately.  */\n \t    length = size_binop (PLUS_EXPR, size_one_node,\n \t\t\t\t fold_convert (sizetype,\n-\t\t\t\t\t       fold_build2 (MINUS_EXPR,\n+\t\t\t\t\t       fold_build2_loc (input_location,\n+\t\t\t\t\t\t\t    MINUS_EXPR,\n \t\t\t\t\t\t\t    TREE_TYPE (lb),\n \t\t\t\t\t\t\t    ub, lb)));\n "}, {"sha": "19a26f72603f6adec1caf0e77f4bb096b3e76cac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1,3 +1,10 @@\n+2009-07-17  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR 40435 \n+\t* gcc.dg/pr36902.c: Add column info.\n+\t* g++.dg/gcov/gcov-2.C: Change count for definition.\n+\n 2009-07-16  Jason Merrill  <jason@redhat.com>\n \n \tPR libstdc++/37907"}, {"sha": "6d002f5d2cd01d7818d14c45ae7092924d2fa8d8", "filename": "gcc/testsuite/g++.dg/gcov/gcov-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-2.C?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -20,7 +20,7 @@ private:\n \n void foo()\n {\n-  C c;\t\t\t\t\t/* count(1) */\n+  C c;\t\t\t\t\t/* count(2) */\n   c.seti (1);\t\t\t\t/* count(1) */\n }\n "}, {"sha": "8b4ba6fcdb224fceb72cb59114d0677ea31566eb", "filename": "gcc/testsuite/gcc.dg/pr36902.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -44,7 +44,7 @@ foo2(unsigned char * to, const unsigned char * from, int n)\n       *to = *from;\n       break;\n     case 5:\n-      to[4] = from [4]; /* { dg-warning \"array subscript is above array bounds\" } */\n+      to[4] = from [4]; /* { dg-warning \"20:array subscript is above array bounds\" } */\n       break;\n     }\n   return to;"}, {"sha": "bd6940f6fa71c5c99ba5f0ea93709a422cd4fa04", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -476,11 +476,12 @@ fold_cond_expr_cond (void)\n \n       if (stmt && gimple_code (stmt) == GIMPLE_COND)\n \t{\n+\t  location_t loc = gimple_location (stmt);\n \t  tree cond;\n \t  bool zerop, onep;\n \n \t  fold_defer_overflow_warnings ();\n-\t  cond = fold_binary (gimple_cond_code (stmt), boolean_type_node,\n+\t  cond = fold_binary_loc (loc, gimple_cond_code (stmt), boolean_type_node,\n \t\t\t      gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n \t  if (cond)\n \t    {\n@@ -7196,8 +7197,9 @@ gimplify_build3 (gimple_stmt_iterator *gsi, enum tree_code code,\n \t\t tree type, tree a, tree b, tree c)\n {\n   tree ret;\n+  location_t loc = gimple_location (gsi_stmt (*gsi));\n \n-  ret = fold_build3 (code, type, a, b, c);\n+  ret = fold_build3_loc (loc, code, type, a, b, c);\n   STRIP_NOPS (ret);\n \n   return force_gimple_operand_gsi (gsi, ret, true, NULL, true,\n@@ -7213,7 +7215,7 @@ gimplify_build2 (gimple_stmt_iterator *gsi, enum tree_code code,\n {\n   tree ret;\n \n-  ret = fold_build2 (code, type, a, b);\n+  ret = fold_build2_loc (gimple_location (gsi_stmt (*gsi)), code, type, a, b);\n   STRIP_NOPS (ret);\n \n   return force_gimple_operand_gsi (gsi, ret, true, NULL, true,\n@@ -7229,7 +7231,7 @@ gimplify_build1 (gimple_stmt_iterator *gsi, enum tree_code code, tree type,\n {\n   tree ret;\n \n-  ret = fold_build1 (code, type, a);\n+  ret = fold_build1_loc (gimple_location (gsi_stmt (*gsi)), code, type, a);\n   STRIP_NOPS (ret);\n \n   return force_gimple_operand_gsi (gsi, ret, true, NULL, true,"}, {"sha": "f6918056a68278553e867d5c80129b4455fd4747", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1109,7 +1109,8 @@ expand_complex_div_wide (gimple_stmt_iterator *gsi, tree inner_type,\n   /* Examine |br| < |bi|, and branch.  */\n   t1 = gimplify_build1 (gsi, ABS_EXPR, inner_type, br);\n   t2 = gimplify_build1 (gsi, ABS_EXPR, inner_type, bi);\n-  compare = fold_build2 (LT_EXPR, boolean_type_node, t1, t2);\n+  compare = fold_build2_loc (gimple_location (gsi_stmt (*gsi)),\n+\t\t\t LT_EXPR, boolean_type_node, t1, t2);\n   STRIP_NOPS (compare);\n \n   bb_cond = bb_true = bb_false = bb_join = NULL;\n@@ -1130,7 +1131,8 @@ expand_complex_div_wide (gimple_stmt_iterator *gsi, tree inner_type,\n \n       gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n \n-      cond = fold_build2 (EQ_EXPR, boolean_type_node, tmp, boolean_true_node);\n+      cond = fold_build2_loc (gimple_location (stmt),\n+\t\t\t  EQ_EXPR, boolean_type_node, tmp, boolean_true_node);\n       stmt = gimple_build_cond_from_tree (cond, NULL_TREE, NULL_TREE);\n       gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n "}, {"sha": "bfd0c293156f9aa3eb5147714390ac06b6ccf399", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -271,10 +271,11 @@ tree_if_convert_cond_stmt (struct loop *loop, gimple stmt, tree cond,\n {\n   tree c, c2;\n   edge true_edge, false_edge;\n+  location_t loc = gimple_location (stmt);\n \n   gcc_assert (gimple_code (stmt) == GIMPLE_COND);\n \n-  c = fold_build2 (gimple_cond_code (stmt), boolean_type_node,\n+  c = fold_build2_loc (loc, gimple_cond_code (stmt), boolean_type_node,\n \t\t   gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n \n   extract_true_false_edges_from_block (gimple_bb (stmt),\n@@ -286,7 +287,7 @@ tree_if_convert_cond_stmt (struct loop *loop, gimple stmt, tree cond,\n   add_to_dst_predicate_list (loop, true_edge, cond, c, gsi);\n \n   /* If 'c' is false then FALSE_EDGE is taken.  */\n-  c2 = invert_truthvalue (unshare_expr (c));\n+  c2 = invert_truthvalue_loc (loc, unshare_expr (c));\n   add_to_dst_predicate_list (loop, false_edge, cond, c2, gsi);\n \n   /* Now this conditional statement is redundant. Remove it.\n@@ -615,7 +616,8 @@ add_to_predicate_list (basic_block bb, tree new_cond)\n   tree cond = (tree) bb->aux;\n \n   if (cond)\n-    cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+    cond = fold_build2_loc (EXPR_LOCATION (cond),\n+\t\t\tTRUTH_OR_EXPR, boolean_type_node,\n \t\t\tunshare_expr (cond), new_cond);\n   else\n     cond = new_cond;"}, {"sha": "ed947da759a0ba20cfbe3bd7b76533aabc794eb5", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -778,7 +778,8 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t        {\n \t\t  if (TREE_CODE (new_tree) == ADDR_EXPR)\n \t\t    {\n-\t\t      *tp = fold_indirect_ref_1 (type, new_tree);\n+\t\t      *tp = fold_indirect_ref_1 (EXPR_LOCATION (new_tree),\n+\t\t\t\t\t\t type, new_tree);\n \t\t      /* ???  We should either assert here or build\n \t\t\t a VIEW_CONVERT_EXPR instead of blindly leaking\n \t\t\t incompatible types to our IL.  */\n@@ -1010,7 +1011,8 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t        {\n \t\t  if (TREE_CODE (new_tree) == ADDR_EXPR)\n \t\t    {\n-\t\t      *tp = fold_indirect_ref_1 (type, new_tree);\n+\t\t      *tp = fold_indirect_ref_1 (EXPR_LOCATION (new_tree),\n+\t\t\t\t\t\t type, new_tree);\n \t\t      /* ???  We should either assert here or build\n \t\t\t a VIEW_CONVERT_EXPR instead of blindly leaking\n \t\t\t incompatible types to our IL.  */"}, {"sha": "575025473cbc07235d31cd00e735775c4861f4c1", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -219,15 +219,15 @@ generate_loops_for_partition (struct loop *loop, bitmap partition, bool copy_p)\n /* Build the size argument for a memset call.  */\n \n static inline tree\n-build_size_arg (tree nb_iter, tree op, gimple_seq* stmt_list)\n+build_size_arg_loc (location_t loc, tree nb_iter, tree op, gimple_seq* stmt_list)\n {\n     tree nb_bytes;\n     gimple_seq stmts = NULL;\n \n-    nb_bytes = fold_build2 (MULT_EXPR, size_type_node,\n-\t\t\t    fold_convert (size_type_node, nb_iter),\n-\t\t\t    fold_convert (size_type_node,\n-\t\t\t\t\t  TYPE_SIZE_UNIT (TREE_TYPE (op))));\n+    nb_bytes = fold_build2_loc (loc, MULT_EXPR, size_type_node,\n+\t\t\t    fold_convert_loc (loc, size_type_node, nb_iter),\n+\t\t\t    fold_convert_loc (loc, size_type_node,\n+\t\t\t\t\t      TYPE_SIZE_UNIT (TREE_TYPE (op))));\n     nb_bytes = force_gimple_operand (nb_bytes, &stmts, true, NULL);\n     gimple_seq_add_seq (stmt_list, stmts);\n \n@@ -248,38 +248,40 @@ generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n   tree mem, fndecl, fntype, fn;\n   gimple_stmt_iterator i;\n   struct data_reference *dr = XCNEW (struct data_reference);\n+  location_t loc = gimple_location (stmt);\n \n   DR_STMT (dr) = stmt;\n   DR_REF (dr) = op0;\n   if (!dr_analyze_innermost (dr))\n     goto end;\n \n   /* Test for a positive stride, iterating over every element.  */\n-  if (integer_zerop (fold_build2 (MINUS_EXPR, integer_type_node, DR_STEP (dr),\n+  if (integer_zerop (fold_build2_loc (loc,\n+\t\t\t\t  MINUS_EXPR, integer_type_node, DR_STEP (dr),\n \t\t\t\t  TYPE_SIZE_UNIT (TREE_TYPE (op0)))))\n     {\n-      tree offset = fold_convert (sizetype,\n-\t\t\t\t  size_binop (PLUS_EXPR,\n-\t\t\t\t\t      DR_OFFSET (dr),\n-\t\t\t\t\t      DR_INIT (dr)));\n-      addr_base = fold_build2 (POINTER_PLUS_EXPR,\n+      tree offset = fold_convert_loc (loc, sizetype,\n+\t\t\t\t      size_binop_loc (loc, PLUS_EXPR,\n+\t\t\t\t\t\t      DR_OFFSET (dr),\n+\t\t\t\t\t\t      DR_INIT (dr)));\n+      addr_base = fold_build2_loc (loc, POINTER_PLUS_EXPR,\n \t\t\t       TREE_TYPE (DR_BASE_ADDRESS (dr)),\n \t\t\t       DR_BASE_ADDRESS (dr), offset);\n     }\n \n   /* Test for a negative stride, iterating over every element.  */\n-  else if (integer_zerop (fold_build2 (PLUS_EXPR, integer_type_node,\n+  else if (integer_zerop (fold_build2_loc (loc, PLUS_EXPR, integer_type_node,\n \t\t\t\t       TYPE_SIZE_UNIT (TREE_TYPE (op0)),\n \t\t\t\t       DR_STEP (dr))))\n     {\n-      nb_bytes = build_size_arg (nb_iter, op0, &stmt_list);\n-      addr_base = size_binop (PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));\n-      addr_base = fold_build2 (MINUS_EXPR, sizetype, addr_base,\n-\t\t\t       fold_convert (sizetype, nb_bytes));\n+      nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);\n+      addr_base = size_binop_loc (loc, PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));\n+      addr_base = fold_build2_loc (loc, MINUS_EXPR, sizetype, addr_base,\n+\t\t\t       fold_convert_loc (loc, sizetype, nb_bytes));\n       addr_base = force_gimple_operand (addr_base, &stmts, true, NULL);\n       gimple_seq_add_seq (&stmt_list, stmts);\n \n-      addr_base = fold_build2 (POINTER_PLUS_EXPR,\n+      addr_base = fold_build2_loc (loc, POINTER_PLUS_EXPR,\n \t\t\t       TREE_TYPE (DR_BASE_ADDRESS (dr)),\n \t\t\t       DR_BASE_ADDRESS (dr), addr_base);\n     }\n@@ -294,7 +296,7 @@ generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n   fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n \n   if (!nb_bytes)\n-    nb_bytes = build_size_arg (nb_iter, op0, &stmt_list);\n+    nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);\n   fn_call = gimple_build_call (fn, 3, mem, integer_zero_node, nb_bytes);\n   gimple_seq_add_stmt (&stmt_list, fn_call);\n "}, {"sha": "381b029d45f06a524e4299bb5d05eaabc4983c96", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -581,15 +581,17 @@ mf_build_check_statement_for (tree base, tree limit,\n \n   /* Build: __mf_base = (uintptr_t) <base address expression>.  */\n   seq = gimple_seq_alloc ();\n-  t = fold_convert (mf_uintptr_type, unshare_expr (base));\n+  t = fold_convert_loc (location, mf_uintptr_type,\n+\t\t\tunshare_expr (base));\n   t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n   gimple_seq_add_seq (&seq, stmts);\n   g = gimple_build_assign (mf_base, t);\n   gimple_set_location (g, location);\n   gimple_seq_add_stmt (&seq, g);\n \n   /* Build: __mf_limit = (uintptr_t) <limit address expression>.  */\n-  t = fold_convert (mf_uintptr_type, unshare_expr (limit));\n+  t = fold_convert_loc (location, mf_uintptr_type,\n+\t\t\tunshare_expr (limit));\n   t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n   gimple_seq_add_seq (&seq, stmts);\n   g = gimple_build_assign (mf_limit, t);\n@@ -693,8 +695,9 @@ mf_build_check_statement_for (tree base, tree limit,\n   /* u is a string, so it is already a gimple value.  */\n   u = mf_file_function_line_tree (location);\n   /* NB: we pass the overall [base..limit] range to mf_check.  */\n-  v = fold_build2 (PLUS_EXPR, mf_uintptr_type,\n-\t\t   fold_build2 (MINUS_EXPR, mf_uintptr_type, mf_limit, mf_base),\n+  v = fold_build2_loc (location, PLUS_EXPR, mf_uintptr_type,\n+\t\t   fold_build2_loc (location,\n+\t\t\t\tMINUS_EXPR, mf_uintptr_type, mf_limit, mf_base),\n \t\t   build_int_cst (mf_uintptr_type, 1));\n   v = force_gimple_operand (v, &stmts, true, NULL_TREE);\n   gimple_seq_add_seq (&seq, stmts);\n@@ -863,16 +866,16 @@ mf_xform_derefs_1 (gimple_stmt_iterator *iter, tree *tp,\n \t    if (elt)\n \t      elt = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (elt)),\n \t\t\t    elt);\n-            addr = fold_convert (ptr_type_node, elt ? elt : base);\n-            addr = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n-\t\t\t\taddr, fold_convert (sizetype,\n-\t\t\t\t\t\t    byte_position (field)));\n+            addr = fold_convert_loc (location, ptr_type_node, elt ? elt : base);\n+            addr = fold_build2_loc (location, POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t\taddr, fold_convert_loc (location, sizetype,\n+\t\t\t\t\t\t\tbyte_position (field)));\n           }\n         else\n           addr = build1 (ADDR_EXPR, build_pointer_type (type), t);\n \n-        limit = fold_build2 (MINUS_EXPR, mf_uintptr_type,\n-                             fold_build2 (PLUS_EXPR, mf_uintptr_type,\n+        limit = fold_build2_loc (location, MINUS_EXPR, mf_uintptr_type,\n+                             fold_build2_loc (location, PLUS_EXPR, mf_uintptr_type,\n \t\t\t\t\t  convert (mf_uintptr_type, addr),\n \t\t\t\t\t  size),\n                              integer_one_node);\n@@ -882,17 +885,19 @@ mf_xform_derefs_1 (gimple_stmt_iterator *iter, tree *tp,\n     case INDIRECT_REF:\n       addr = TREE_OPERAND (t, 0);\n       base = addr;\n-      limit = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n-\t\t\t   fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, base,\n+      limit = fold_build2_loc (location, POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t   fold_build2_loc (location,\n+\t\t\t\t\tPOINTER_PLUS_EXPR, ptr_type_node, base,\n \t\t\t\t\tsize),\n \t\t\t   size_int (-1));\n       break;\n \n     case TARGET_MEM_REF:\n       addr = tree_mem_ref_addr (ptr_type_node, t);\n       base = addr;\n-      limit = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n-\t\t\t   fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, base,\n+      limit = fold_build2_loc (location, POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t   fold_build2_loc (location,\n+\t\t\t\t\tPOINTER_PLUS_EXPR, ptr_type_node, base,\n \t\t\t\t\tsize),\n \t\t\t   size_int (-1));\n       break;\n@@ -914,21 +919,26 @@ mf_xform_derefs_1 (gimple_stmt_iterator *iter, tree *tp,\n \n         bpu = bitsize_int (BITS_PER_UNIT);\n         ofs = convert (bitsizetype, TREE_OPERAND (t, 2));\n-        rem = size_binop (TRUNC_MOD_EXPR, ofs, bpu);\n-        ofs = fold_convert (sizetype, size_binop (TRUNC_DIV_EXPR, ofs, bpu));\n+        rem = size_binop_loc (location, TRUNC_MOD_EXPR, ofs, bpu);\n+        ofs = fold_convert_loc (location,\n+\t\t\t\tsizetype,\n+\t\t\t\tsize_binop_loc (location,\n+\t\t\t\t\t\tTRUNC_DIV_EXPR, ofs, bpu));\n \n         size = convert (bitsizetype, TREE_OPERAND (t, 1));\n-        size = size_binop (PLUS_EXPR, size, rem);\n-        size = size_binop (CEIL_DIV_EXPR, size, bpu);\n+        size = size_binop_loc (location, PLUS_EXPR, size, rem);\n+        size = size_binop_loc (location, CEIL_DIV_EXPR, size, bpu);\n         size = convert (sizetype, size);\n \n         addr = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n         addr = convert (ptr_type_node, addr);\n-        addr = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, addr, ofs);\n+        addr = fold_build2_loc (location, POINTER_PLUS_EXPR,\n+\t\t\t    ptr_type_node, addr, ofs);\n \n         base = addr;\n-        limit = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n-                             fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+        limit = fold_build2_loc (location, POINTER_PLUS_EXPR, ptr_type_node,\n+                             fold_build2_loc (location,\n+\t\t\t\t\t  POINTER_PLUS_EXPR, ptr_type_node,\n \t\t\t\t\t   base, size),\n                              size_int (-1));\n       }"}, {"sha": "a7bb017b476f6ce232d8837ee19f943974b166ad", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1123,11 +1123,13 @@ static bool\n build_ref_for_offset (tree *expr, tree type, HOST_WIDE_INT offset,\n \t\t      tree exp_type, bool allow_ptr)\n {\n+  location_t loc = expr ? EXPR_LOCATION (*expr) : UNKNOWN_LOCATION;\n+\n   if (allow_ptr && POINTER_TYPE_P (type))\n     {\n       type = TREE_TYPE (type);\n       if (expr)\n-\t*expr = fold_build1 (INDIRECT_REF, type, *expr);\n+\t*expr = fold_build1_loc (loc, INDIRECT_REF, type, *expr);\n     }\n \n   return build_ref_for_offset_1 (expr, type, offset, exp_type);\n@@ -1968,6 +1970,7 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t\t\t\t enum unscalarized_data_handling *refreshed,\n \t\t\t\t tree lhs)\n {\n+  location_t loc = EXPR_LOCATION (lacc->expr);\n   do\n     {\n       if (lacc->grp_to_be_replaced)\n@@ -1982,7 +1985,7 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t    {\n \t      rhs = get_access_replacement (racc);\n \t      if (!useless_type_conversion_p (lacc->type, racc->type))\n-\t\trhs = fold_build1 (VIEW_CONVERT_EXPR, lacc->type, rhs);\n+\t\trhs = fold_build1_loc (loc, VIEW_CONVERT_EXPR, lacc->type, rhs);\n \t    }\n \t  else\n \t    {\n@@ -2080,6 +2083,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree lhs, rhs;\n   bool modify_this_stmt = false;\n   bool force_gimple_rhs = false;\n+  location_t loc = gimple_location (*stmt);\n \n   if (!gimple_assign_single_p (*stmt))\n     return SRA_SA_NONE;\n@@ -2152,7 +2156,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    }\n \t  if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n \t    {\n-\t      rhs = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (lhs), rhs);\n+\t      rhs = fold_build1_loc (loc, VIEW_CONVERT_EXPR, TREE_TYPE (lhs), rhs);\n \t      if (!is_gimple_reg (lhs))\n \t\tforce_gimple_rhs = true;\n \t    }"}, {"sha": "c507f4572e628d536a1498807e6ead65794ca75b", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -910,6 +910,7 @@ may_propagate_address_into_dereference (tree addr, tree deref)\n static tree\n ccp_fold (gimple stmt)\n {\n+  location_t loc = gimple_location (stmt);\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_ASSIGN:\n@@ -992,7 +993,8 @@ ccp_fold (gimple stmt)\n \t\t    {\n \t\t      prop_value_t *val = get_value (TREE_OPERAND (rhs, 0));\n \t\t      if (val->lattice_val == CONSTANT)\n-\t\t\treturn fold_unary (TREE_CODE (rhs),\n+\t\t\treturn fold_unary_loc (EXPR_LOCATION (rhs),\n+\t\t\t\t\t   TREE_CODE (rhs),\n \t\t\t\t\t   TREE_TYPE (rhs), val->value);\n \t\t    }\n \t\t  else if (TREE_CODE (rhs) == INDIRECT_REF\n@@ -1048,15 +1050,16 @@ ccp_fold (gimple stmt)\n \t\t  if (!useless_type_conversion_p (TREE_TYPE (lhs),\n \t\t\t\t\t\t  TREE_TYPE (op0))\n \t\t      && ((tem = maybe_fold_offset_to_address\n-\t\t\t   (gimple_location (stmt),\n+\t\t\t   (loc,\n \t\t\t    op0, integer_zero_node, TREE_TYPE (lhs)))\n \t\t\t  != NULL_TREE))\n \t\t    return tem;\n \t\t  return op0;\n \t\t}\n \n-              return fold_unary_ignore_overflow (subcode,\n-\t\t\t\t\t\t gimple_expr_type (stmt), op0);\n+              return \n+\t\tfold_unary_ignore_overflow_loc (loc, subcode,\n+\t\t\t\t\t\tgimple_expr_type (stmt), op0);\n             }\n \n           case GIMPLE_BINARY_RHS:\n@@ -1087,12 +1090,13 @@ ccp_fold (gimple stmt)\n \t\t{\n \t\t  tree lhs = gimple_assign_lhs (stmt);\n \t\t  tree tem = maybe_fold_offset_to_address\n-\t\t    (gimple_location (stmt), op0, op1, TREE_TYPE (lhs));\n+\t\t    (loc, op0, op1, TREE_TYPE (lhs));\n \t\t  if (tem != NULL_TREE)\n \t\t    return tem;\n \t\t}\n \n-              return fold_binary (subcode, gimple_expr_type (stmt), op0, op1);\n+              return fold_binary_loc (loc, subcode,\n+\t\t\t\t  gimple_expr_type (stmt), op0, op1);\n             }\n \n           default:\n@@ -1129,9 +1133,10 @@ ccp_fold (gimple stmt)\n \t\t      args[i] = val->value;\n \t\t  }\n \t      }\n-\t    call = build_call_array (gimple_call_return_type (stmt),\n-\t\t\t\t     fn, gimple_call_num_args (stmt), args);\n-\t    retval = fold_call_expr (call, false);\n+\t    call = build_call_array_loc (loc,\n+\t\t\t\t\t gimple_call_return_type (stmt),\n+\t\t\t\t\t fn, gimple_call_num_args (stmt), args);\n+\t    retval = fold_call_expr (EXPR_LOCATION (call), call, false);\n \t    if (retval)\n \t      /* fold_call_expr wraps the result inside a NOP_EXPR.  */\n \t      STRIP_NOPS (retval);\n@@ -1162,7 +1167,7 @@ ccp_fold (gimple stmt)\n               op1 = val->value;\n           }\n \n-        return fold_binary (code, boolean_type_node, op0, op1);\n+        return fold_binary_loc (loc, code, boolean_type_node, op0, op1);\n       }\n \n     case GIMPLE_SWITCH:\n@@ -1344,7 +1349,8 @@ fold_const_aggregate_ref (tree t)\n       {\n \ttree c = fold_const_aggregate_ref (TREE_OPERAND (t, 0));\n \tif (c && TREE_CODE (c) == COMPLEX_CST)\n-\t  return fold_build1 (TREE_CODE (t), TREE_TYPE (t), c);\n+\t  return fold_build1_loc (EXPR_LOCATION (t),\n+\t\t\t      TREE_CODE (t), TREE_TYPE (t), c);\n \tbreak;\n       }\n \n@@ -2049,9 +2055,7 @@ maybe_fold_offset_to_address (location_t loc, tree addr, tree offset,\n       ptr_type = build_pointer_type (TREE_TYPE (t));\n       if (!useless_type_conversion_p (orig_type, ptr_type))\n \treturn NULL_TREE;\n-      t = build_fold_addr_expr_with_type (t, ptr_type);\n-      protected_set_expr_location (t, loc);\n-      return t;\n+      return build_fold_addr_expr_with_type_loc (loc, t, ptr_type);\n     }\n \n   return NULL_TREE;\n@@ -2471,6 +2475,7 @@ ccp_fold_builtin (gimple stmt)\n   bitmap visited;\n   bool ignore;\n   int nargs;\n+  location_t loc = gimple_location (stmt);\n \n   gcc_assert (is_gimple_call (stmt));\n \n@@ -2567,15 +2572,15 @@ ccp_fold_builtin (gimple stmt)\n \n     case BUILT_IN_STRCPY:\n       if (val[1] && is_gimple_val (val[1]) && nargs == 2)\n-\tresult = fold_builtin_strcpy (callee,\n+\tresult = fold_builtin_strcpy (loc, callee,\n                                       gimple_call_arg (stmt, 0),\n                                       gimple_call_arg (stmt, 1),\n \t\t\t\t      val[1]);\n       break;\n \n     case BUILT_IN_STRNCPY:\n       if (val[1] && is_gimple_val (val[1]) && nargs == 3)\n-\tresult = fold_builtin_strncpy (callee,\n+\tresult = fold_builtin_strncpy (loc, callee,\n                                        gimple_call_arg (stmt, 0),\n                                        gimple_call_arg (stmt, 1),\n                                        gimple_call_arg (stmt, 2),\n@@ -2584,14 +2589,14 @@ ccp_fold_builtin (gimple stmt)\n \n     case BUILT_IN_FPUTS:\n       if (nargs == 2)\n-\tresult = fold_builtin_fputs (gimple_call_arg (stmt, 0),\n+\tresult = fold_builtin_fputs (loc, gimple_call_arg (stmt, 0),\n \t\t\t\t     gimple_call_arg (stmt, 1),\n \t\t\t\t     ignore, false, val[0]);\n       break;\n \n     case BUILT_IN_FPUTS_UNLOCKED:\n       if (nargs == 2)\n-\tresult = fold_builtin_fputs (gimple_call_arg (stmt, 0),\n+\tresult = fold_builtin_fputs (loc, gimple_call_arg (stmt, 0),\n \t\t\t\t     gimple_call_arg (stmt, 1),\n \t\t\t\t     ignore, true, val[0]);\n       break;\n@@ -2601,7 +2606,7 @@ ccp_fold_builtin (gimple stmt)\n     case BUILT_IN_MEMMOVE_CHK:\n     case BUILT_IN_MEMSET_CHK:\n       if (val[2] && is_gimple_val (val[2]) && nargs == 4)\n-\tresult = fold_builtin_memory_chk (callee,\n+\tresult = fold_builtin_memory_chk (loc, callee,\n                                           gimple_call_arg (stmt, 0),\n                                           gimple_call_arg (stmt, 1),\n                                           gimple_call_arg (stmt, 2),\n@@ -2613,7 +2618,7 @@ ccp_fold_builtin (gimple stmt)\n     case BUILT_IN_STRCPY_CHK:\n     case BUILT_IN_STPCPY_CHK:\n       if (val[1] && is_gimple_val (val[1]) && nargs == 3)\n-\tresult = fold_builtin_stxcpy_chk (callee,\n+\tresult = fold_builtin_stxcpy_chk (loc, callee,\n                                           gimple_call_arg (stmt, 0),\n                                           gimple_call_arg (stmt, 1),\n                                           gimple_call_arg (stmt, 2),\n@@ -2623,7 +2628,7 @@ ccp_fold_builtin (gimple stmt)\n \n     case BUILT_IN_STRNCPY_CHK:\n       if (val[2] && is_gimple_val (val[2]) && nargs == 4)\n-\tresult = fold_builtin_strncpy_chk (gimple_call_arg (stmt, 0),\n+\tresult = fold_builtin_strncpy_chk (loc, gimple_call_arg (stmt, 0),\n                                            gimple_call_arg (stmt, 1),\n                                            gimple_call_arg (stmt, 2),\n                                            gimple_call_arg (stmt, 3),\n@@ -2656,6 +2661,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n {\n   gimple stmt = gsi_stmt (*si);\n   enum tree_code subcode = gimple_assign_rhs_code (stmt);\n+  location_t loc = gimple_location (stmt);\n \n   tree result = NULL_TREE;\n \n@@ -2671,11 +2677,13 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t    tree op0 = COND_EXPR_COND (rhs);\n \t    tree tem;\n \t    bool set = false;\n+\t    location_t cond_loc = EXPR_LOCATION (rhs);\n \n \t    if (COMPARISON_CLASS_P (op0))\n \t      {\n \t\tfold_defer_overflow_warnings ();\n-\t\ttem = fold_binary (TREE_CODE (op0), TREE_TYPE (op0),\n+\t\ttem = fold_binary_loc (cond_loc,\n+\t\t\t\t   TREE_CODE (op0), TREE_TYPE (op0),\n \t\t\t\t   TREE_OPERAND (op0, 0),\n \t\t\t\t   TREE_OPERAND (op0, 1));\n \t\t/* This is actually a conditional expression, not a GIMPLE\n@@ -2694,7 +2702,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t      return NULL_TREE;\n \n \t    if (set)\n-\t      result = fold_build3 (COND_EXPR, TREE_TYPE (rhs), tem,\n+\t      result = fold_build3_loc (cond_loc, COND_EXPR, TREE_TYPE (rhs), tem,\n \t\t\t\t    COND_EXPR_THEN (rhs), COND_EXPR_ELSE (rhs));\n           }\n \n@@ -2709,7 +2717,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t    tree tem = maybe_fold_reference (TREE_OPERAND (rhs, 0), true);\n \t    if (tem)\n \t      result = fold_convert (TREE_TYPE (rhs),\n-\t\t\t\t     build_fold_addr_expr (tem));\n+\t\t\t\t     build_fold_addr_expr_loc (loc, tem));\n \t  }\n \n \telse if (TREE_CODE (rhs) == CONSTRUCTOR\n@@ -2752,7 +2760,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n       {\n \ttree rhs = gimple_assign_rhs1 (stmt);\n \n-\tresult = fold_unary (subcode, gimple_expr_type (stmt), rhs);\n+\tresult = fold_unary_loc (loc, subcode, gimple_expr_type (stmt), rhs);\n \tif (result)\n \t  {\n \t    /* If the operation was a conversion do _not_ mark a\n@@ -2774,7 +2782,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t\t && POINTER_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n \t  {\n \t    tree type = gimple_expr_type (stmt);\n-\t    tree t = maybe_fold_offset_to_address (gimple_location (stmt),\n+\t    tree t = maybe_fold_offset_to_address (loc,\n \t\t\t\t\t\t   gimple_assign_rhs1 (stmt),\n \t\t\t\t\t\t   integer_zero_node, type);\n \t    if (t)\n@@ -2802,7 +2810,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t}\n \n       if (!result)\n-        result = fold_binary (subcode,\n+        result = fold_binary_loc (loc, subcode,\n                               TREE_TYPE (gimple_assign_lhs (stmt)),\n                               gimple_assign_rhs1 (stmt),\n                               gimple_assign_rhs2 (stmt));\n@@ -2841,7 +2849,8 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n static bool\n fold_gimple_cond (gimple stmt)\n {\n-  tree result = fold_binary (gimple_cond_code (stmt),\n+  tree result = fold_binary_loc (gimple_location (stmt),\n+\t\t\t     gimple_cond_code (stmt),\n                              boolean_type_node,\n                              gimple_cond_lhs (stmt),\n                              gimple_cond_rhs (stmt));\n@@ -3120,6 +3129,7 @@ optimize_stdarg_builtin (gimple call)\n {\n   tree callee, lhs, rhs, cfun_va_list;\n   bool va_list_simple_ptr;\n+  location_t loc = gimple_location (call);\n \n   if (gimple_code (call) != GIMPLE_CALL)\n     return NULL_TREE;\n@@ -3148,10 +3158,10 @@ optimize_stdarg_builtin (gimple call)\n \t     != TYPE_MAIN_VARIANT (cfun_va_list))\n \treturn NULL_TREE;\n       \n-      lhs = build_fold_indirect_ref (lhs);\n-      rhs = build_call_expr (built_in_decls[BUILT_IN_NEXT_ARG],\n+      lhs = build_fold_indirect_ref_loc (loc, lhs);\n+      rhs = build_call_expr_loc (loc, built_in_decls[BUILT_IN_NEXT_ARG],\n                              1, integer_zero_node);\n-      rhs = fold_convert (TREE_TYPE (lhs), rhs);\n+      rhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);\n       return build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, rhs);\n \n     case BUILT_IN_VA_COPY:\n@@ -3167,13 +3177,13 @@ optimize_stdarg_builtin (gimple call)\n \t     != TYPE_MAIN_VARIANT (cfun_va_list))\n \treturn NULL_TREE;\n \n-      lhs = build_fold_indirect_ref (lhs);\n+      lhs = build_fold_indirect_ref_loc (loc, lhs);\n       rhs = gimple_call_arg (call, 1);\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (rhs))\n \t  != TYPE_MAIN_VARIANT (cfun_va_list))\n \treturn NULL_TREE;\n \n-      rhs = fold_convert (TREE_TYPE (lhs), rhs);\n+      rhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);\n       return build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, rhs);\n \n     case BUILT_IN_VA_END:"}, {"sha": "ea0291c49c5b7fec081d6fdb7d599d9d2861e710", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -514,6 +514,7 @@ static enum ssa_prop_result\n copy_prop_visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n {\n   enum ssa_prop_result retval = SSA_PROP_VARYING;\n+  location_t loc = gimple_location (stmt);\n \n   tree op0 = gimple_cond_lhs (stmt);\n   tree op1 = gimple_cond_rhs (stmt);\n@@ -537,7 +538,7 @@ copy_prop_visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n \t the same SSA_NAME on both sides of a comparison operator.  */\n       if (op0 == op1)\n \t{\n-\t  tree folded_cond = fold_binary (gimple_cond_code (stmt),\n+\t  tree folded_cond = fold_binary_loc (loc, gimple_cond_code (stmt),\n                                           boolean_type_node, op0, op1);\n \t  if (folded_cond)\n \t    {"}, {"sha": "2fa8da25eb6132f33e085ad9c9bfd746f0742330", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -1485,6 +1485,7 @@ record_edge_info (basic_block bb)\n   if (! gsi_end_p (gsi))\n     {\n       gimple stmt = gsi_stmt (gsi);\n+      location_t loc = gimple_location (stmt);\n \n       if (gimple_code (stmt) == GIMPLE_SWITCH)\n \t{\n@@ -1517,7 +1518,8 @@ record_edge_info (basic_block bb)\n \n \t\t  if (label != NULL && label != error_mark_node)\n \t\t    {\n-\t\t      tree x = fold_convert (TREE_TYPE (index), CASE_LOW (label));\n+\t\t      tree x = fold_convert_loc (loc, TREE_TYPE (index),\n+\t\t\t\t\t\t CASE_LOW (label));\n \t\t      edge_info = allocate_edge_info (e);\n \t\t      edge_info->lhs = index;\n \t\t      edge_info->rhs = x;\n@@ -1581,7 +1583,7 @@ record_edge_info (basic_block bb)\n                        || is_gimple_min_invariant (op1)))\n             {\n               tree cond = build2 (code, boolean_type_node, op0, op1);\n-              tree inverted = invert_truthvalue (cond);\n+              tree inverted = invert_truthvalue_loc (loc, cond);\n               struct edge_info *edge_info;\n \n               edge_info = allocate_edge_info (true_edge);\n@@ -1608,7 +1610,7 @@ record_edge_info (basic_block bb)\n                        || TREE_CODE (op1) == SSA_NAME))\n             {\n               tree cond = build2 (code, boolean_type_node, op0, op1);\n-              tree inverted = invert_truthvalue (cond);\n+              tree inverted = invert_truthvalue_loc (loc, cond);\n               struct edge_info *edge_info;\n \n               edge_info = allocate_edge_info (true_edge);\n@@ -2218,7 +2220,8 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n       tree val = NULL;\n \n       if (gimple_code (stmt) == GIMPLE_COND)\n-        val = fold_binary (gimple_cond_code (stmt), boolean_type_node,\n+        val = fold_binary_loc (gimple_location (stmt),\n+\t\t\t   gimple_cond_code (stmt), boolean_type_node,\n                            gimple_cond_lhs (stmt),  gimple_cond_rhs (stmt));\n       else if (gimple_code (stmt) == GIMPLE_SWITCH)\n \tval = gimple_switch_index (stmt);\n@@ -2637,7 +2640,8 @@ propagate_rhs_into_lhs (gimple stmt, tree lhs, tree rhs, bitmap interesting_name\n \t      tree val;\n \n \t      if (gimple_code (use_stmt) == GIMPLE_COND)\n-                val = fold_binary (gimple_cond_code (use_stmt),\n+                val = fold_binary_loc (gimple_location (use_stmt),\n+\t\t\t\t   gimple_cond_code (use_stmt),\n                                    boolean_type_node,\n                                    gimple_cond_lhs (use_stmt),\n                                    gimple_cond_rhs (use_stmt));"}, {"sha": "26a82461600cfe8c8a7599397d3e976d9bc253a6", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -339,9 +339,10 @@ remove_prop_source_from_use (tree name, gimple up_to_stmt)\n static tree\n rhs_to_tree (tree type, gimple stmt)\n {\n+  location_t loc = gimple_location (stmt);\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   if (get_gimple_rhs_class (code) == GIMPLE_BINARY_RHS)\n-    return fold_build2 (code, type, gimple_assign_rhs1 (stmt),\n+    return fold_build2_loc (loc, code, type, gimple_assign_rhs1 (stmt),\n \t\t\tgimple_assign_rhs2 (stmt));\n   else if (get_gimple_rhs_class (code) == GIMPLE_UNARY_RHS)\n     return build1 (code, type, gimple_assign_rhs1 (stmt));\n@@ -358,14 +359,14 @@ rhs_to_tree (tree type, gimple stmt)\n    considered simplified.  */\n \n static tree\n-combine_cond_expr_cond (enum tree_code code, tree type,\n+combine_cond_expr_cond (location_t loc, enum tree_code code, tree type,\n \t\t\ttree op0, tree op1, bool invariant_only)\n {\n   tree t;\n \n   gcc_assert (TREE_CODE_CLASS (code) == tcc_comparison);\n \n-  t = fold_binary (code, type, op0, op1);\n+  t = fold_binary_loc (loc, code, type, op0, op1);\n   if (!t)\n     return NULL_TREE;\n \n@@ -392,7 +393,8 @@ combine_cond_expr_cond (enum tree_code code, tree type,\n static int\n forward_propagate_into_gimple_cond (gimple stmt)\n {\n-   int did_something = 0;\n+  int did_something = 0;\n+  location_t loc = gimple_location (stmt); \n \n   do {\n     tree tmp = NULL_TREE;\n@@ -413,7 +415,7 @@ forward_propagate_into_gimple_cond (gimple stmt)\n \t  {\n \t    tree op1 = gimple_cond_rhs (stmt);\n \t    rhs0 = rhs_to_tree (TREE_TYPE (op1), def_stmt);\n-\t    tmp = combine_cond_expr_cond (code, boolean_type_node, rhs0,\n+\t    tmp = combine_cond_expr_cond (loc, code, boolean_type_node, rhs0,\n \t\t\t\t\t  op1, !single_use0_p);\n \t  }\n \t/* If that wasn't successful, try the second operand.  */\n@@ -427,15 +429,17 @@ forward_propagate_into_gimple_cond (gimple stmt)\n \t      return did_something;\n \n \t    rhs1 = rhs_to_tree (TREE_TYPE (op0), def_stmt);\n-\t    tmp = combine_cond_expr_cond (code, boolean_type_node, op0, rhs1,\n-\t\t\t\t\t  !single_use1_p);\n+\t    tmp = combine_cond_expr_cond (loc, code, boolean_type_node, op0,\n+\t\t\t\t\t  rhs1, !single_use1_p);\n \t  }\n \t/* If that wasn't successful either, try both operands.  */\n \tif (tmp == NULL_TREE\n \t    && rhs0 != NULL_TREE\n \t    && rhs1 != NULL_TREE)\n-\t  tmp = combine_cond_expr_cond (code, boolean_type_node, rhs0,\n-\t\t\t\t\tfold_convert (TREE_TYPE (rhs0), rhs1),\n+\t  tmp = combine_cond_expr_cond (loc, code, boolean_type_node, rhs0,\n+\t\t\t\t\tfold_convert_loc (loc,\n+\t\t\t\t\t\t\t  TREE_TYPE (rhs0),\n+\t\t\t\t\t\t\t  rhs1),\n \t\t\t\t\t!(single_use0_p && single_use1_p));\n       }\n \n@@ -487,6 +491,7 @@ static int\n forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n {\n   gimple stmt = gsi_stmt (*gsi_p);\n+  location_t loc = gimple_location (stmt);\n   int did_something = 0;\n \n   do {\n@@ -508,7 +513,8 @@ forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n \t  {\n \t    tree op1 = TREE_OPERAND (cond, 1);\n \t    rhs0 = rhs_to_tree (TREE_TYPE (op1), def_stmt);\n-\t    tmp = combine_cond_expr_cond (TREE_CODE (cond), boolean_type_node,\n+\t    tmp = combine_cond_expr_cond (loc, TREE_CODE (cond),\n+\t\t\t\t\t  boolean_type_node,\n \t\t\t\t\t  rhs0, op1, !single_use0_p);\n \t  }\n \t/* If that wasn't successful, try the second operand.  */\n@@ -522,16 +528,20 @@ forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n \t      return did_something;\n \n \t    rhs1 = rhs_to_tree (TREE_TYPE (op0), def_stmt);\n-\t    tmp = combine_cond_expr_cond (TREE_CODE (cond), boolean_type_node,\n+\t    tmp = combine_cond_expr_cond (loc, TREE_CODE (cond),\n+\t\t\t\t\t  boolean_type_node,\n \t\t\t\t\t  op0, rhs1, !single_use1_p);\n \t  }\n \t/* If that wasn't successful either, try both operands.  */\n \tif (tmp == NULL_TREE\n \t    && rhs0 != NULL_TREE\n \t    && rhs1 != NULL_TREE)\n-\t  tmp = combine_cond_expr_cond (TREE_CODE (cond), boolean_type_node,\n-\t\t\t\t\trhs0, fold_convert (TREE_TYPE (rhs0),\n-\t\t\t\t\t\t\t    rhs1),\n+\t  tmp = combine_cond_expr_cond (loc, TREE_CODE (cond),\n+\t\t\t\t\tboolean_type_node,\n+\t\t\t\t\trhs0,\n+\t\t\t\t\tfold_convert_loc (loc,\n+\t\t\t\t\t\t\t  TREE_TYPE (rhs0),\n+\t\t\t\t\t\t\t  rhs1),\n \t\t\t\t\t!(single_use0_p && single_use1_p));\n       }\n     else if (TREE_CODE (cond) == SSA_NAME)\n@@ -542,7 +552,7 @@ forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n \t  return did_something;\n \n \trhs0 = gimple_assign_rhs1 (def_stmt);\n-\ttmp = combine_cond_expr_cond (NE_EXPR, boolean_type_node, rhs0,\n+\ttmp = combine_cond_expr_cond (loc, NE_EXPR, boolean_type_node, rhs0,\n \t\t\t\t      build_int_cst (TREE_TYPE (rhs0), 0),\n \t\t\t\t      false);\n       }\n@@ -1042,7 +1052,9 @@ forward_propagate_comparison (gimple stmt)\n \t\t       gimple_assign_rhs1 (stmt),\n \t\t       gimple_assign_rhs2 (stmt));\n \n-        tmp = combine_cond_expr_cond (code, TREE_TYPE (lhs), cond, cst, false);\n+        tmp = combine_cond_expr_cond (gimple_location (use_stmt),\n+\t\t\t\t      code, TREE_TYPE (lhs),\n+\t\t\t\t      cond, cst, false);\n         if (tmp == NULL_TREE)\n           return false;\n       }\n@@ -1214,7 +1226,8 @@ simplify_bitwise_and (gimple_stmt_iterator *gsi, gimple stmt)\n \t}\n     }\n \n-  res = fold_binary (BIT_AND_EXPR, TREE_TYPE (gimple_assign_lhs (stmt)),\n+  res = fold_binary_loc (gimple_location (stmt),\n+\t\t     BIT_AND_EXPR, TREE_TYPE (gimple_assign_lhs (stmt)),\n \t\t     arg1, arg2);\n   if (res && is_gimple_min_invariant (res))\n     {"}, {"sha": "8cb9c1e494404da16c5ed8d5b998032dd9bba92e", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -392,7 +392,8 @@ ifcombine_ifandif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n       enum tree_code code2 = gimple_cond_code (outer_cond);\n       tree t;\n \n-      if (!(t = combine_comparisons (TRUTH_ANDIF_EXPR, code1, code2,\n+      if (!(t = combine_comparisons (UNKNOWN_LOCATION,\n+\t      \t\t\t     TRUTH_ANDIF_EXPR, code1, code2,\n \t\t\t\t     boolean_type_node,\n \t\t\t\t     gimple_cond_lhs (outer_cond),\n \t\t\t\t     gimple_cond_rhs (outer_cond))))\n@@ -541,7 +542,8 @@ ifcombine_iforif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n       enum tree_code code2 = gimple_cond_code (outer_cond);\n       tree t;\n \n-      if (!(t = combine_comparisons (TRUTH_ORIF_EXPR, code1, code2,\n+      if (!(t = combine_comparisons (UNKNOWN_LOCATION,\n+\t      \t\t\t     TRUTH_ORIF_EXPR, code1, code2,\n \t\t\t\t     boolean_type_node,\n \t\t\t\t     gimple_cond_lhs (outer_cond),\n \t\t\t\t     gimple_cond_rhs (outer_cond))))"}, {"sha": "a5494827b37f23306b75d87e2c7f9b801bd91d2e", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -552,16 +552,18 @@ build_arrays (gimple swtch)\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n   int i;\n+  location_t loc = gimple_location (swtch);\n \n   gsi = gsi_for_stmt (swtch);\n \n   arr_index_type = build_index_type (info.range_size);\n   tmp = create_tmp_var (TREE_TYPE (info.index_expr), \"csti\");\n   add_referenced_var (tmp);\n   tidx = make_ssa_name (tmp, NULL);\n-  sub = fold_build2 (MINUS_EXPR, TREE_TYPE (info.index_expr), info.index_expr,\n-\t\t     fold_convert (TREE_TYPE (info.index_expr),\n-\t\t\t\t   info.range_min));\n+  sub = fold_build2_loc (loc, MINUS_EXPR,\n+\t\t     TREE_TYPE (info.index_expr), info.index_expr,\n+\t\t     fold_convert_loc (loc, TREE_TYPE (info.index_expr),\n+\t\t\t\t       info.range_min));\n   sub = force_gimple_operand_gsi (&gsi, sub,\n \t\t\t\t  false, NULL, true, GSI_SAME_STMT);\n   stmt = gimple_build_assign (tidx, sub);\n@@ -684,6 +686,7 @@ gen_inbound_check (gimple swtch)\n   gimple_stmt_iterator gsi;\n   basic_block bb0, bb1, bb2, bbf, bbd;\n   edge e01, e02, e21, e1d, e1f, e2f;\n+  location_t loc = gimple_location (swtch);\n \n   gcc_assert (info.default_values);\n   bb0 = gimple_bb (swtch);\n@@ -700,14 +703,14 @@ gen_inbound_check (gimple swtch)\n   add_referenced_var (tmp_u_var);\n   tmp_u_1 = make_ssa_name (tmp_u_var, NULL);\n \n-  cast = fold_convert (utype, info.index_expr);\n+  cast = fold_convert_loc (loc, utype, info.index_expr);\n   cast_assign = gimple_build_assign (tmp_u_1, cast);\n   SSA_NAME_DEF_STMT (tmp_u_1) = cast_assign;\n   gsi_insert_before (&gsi, cast_assign, GSI_SAME_STMT);\n   update_stmt (cast_assign);\n \n-  ulb = fold_convert (utype, info.range_min);\n-  minus = fold_build2 (MINUS_EXPR, utype, tmp_u_1, ulb);\n+  ulb = fold_convert_loc (loc, utype, info.range_min);\n+  minus = fold_build2_loc (loc, MINUS_EXPR, utype, tmp_u_1, ulb);\n   minus = force_gimple_operand_gsi (&gsi, minus, false, NULL, true,\n \t\t\t\t    GSI_SAME_STMT);\n   tmp_u_2 = make_ssa_name (tmp_u_var, NULL);\n@@ -716,7 +719,7 @@ gen_inbound_check (gimple swtch)\n   gsi_insert_before (&gsi, minus_assign, GSI_SAME_STMT);\n   update_stmt (minus_assign);\n \n-  bound = fold_convert (utype, info.range_size);\n+  bound = fold_convert_loc (loc, utype, info.range_size);\n   cond_stmt = gimple_build_cond (LE_EXPR, tmp_u_2, bound, NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n   update_stmt (cond_stmt);"}, {"sha": "b32e209e83e1fbb01e6af945ad5304320658ea7e", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -8537,7 +8537,8 @@ build_call_valist (tree return_type, tree fn, int nargs, va_list args)\n    which are specified as a tree array ARGS.  */\n \n tree\n-build_call_array (tree return_type, tree fn, int nargs, const tree *args)\n+build_call_array_loc (location_t loc, tree return_type, tree fn,\n+\t\t      int nargs, const tree *args)\n {\n   tree t;\n   int i;\n@@ -8549,6 +8550,7 @@ build_call_array (tree return_type, tree fn, int nargs, const tree *args)\n   for (i = 0; i < nargs; i++)\n     CALL_EXPR_ARG (t, i) = args[i];\n   process_call_operands (t);\n+  SET_EXPR_LOCATION (t, loc);\n   return t;\n }\n "}, {"sha": "fbae2080c042e125e0b573be79e2d8941ce7e720", "filename": "gcc/tree.h", "status": "modified", "additions": 96, "deletions": 45, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -3838,7 +3838,9 @@ extern tree build_vl_exp_stat (enum tree_code, int MEM_STAT_DECL);\n extern tree build_call_list (tree, tree, tree);\n extern tree build_call_nary (tree, tree, int, ...);\n extern tree build_call_valist (tree, tree, int, va_list);\n-extern tree build_call_array (tree, tree, int, const tree *);\n+#define build_call_array(T1,T2,N,T3)\\\n+   build_call_array_loc (UNKNOWN_LOCATION, T1, T2, N, T3)\n+extern tree build_call_array_loc (location_t, tree, tree, int, const tree *);\n extern tree build_call_vec (tree, tree, VEC(tree,gc) *);\n \n /* Construct various nodes representing data types.  */\n@@ -4166,7 +4168,8 @@ extern enum machine_mode mode_for_size_tree (const_tree, enum mode_class, int);\n \n /* Return an expr equal to X but certainly not valid as an lvalue.  */\n \n-extern tree non_lvalue (tree);\n+#define non_lvalue(T) non_lvalue_loc (UNKNOWN_LOCATION, T)\n+extern tree non_lvalue_loc (location_t, tree);\n \n extern tree convert (tree, tree);\n extern unsigned int expr_align (const_tree);\n@@ -4199,16 +4202,22 @@ extern GTY(()) tree sizetype_tab[(int) TYPE_KIND_LAST];\n #define sbitsizetype sizetype_tab[(int) SBITSIZETYPE]\n \n extern tree size_int_kind (HOST_WIDE_INT, enum size_type_kind);\n-extern tree size_binop (enum tree_code, tree, tree);\n-extern tree size_diffop (tree, tree);\n+#define size_binop(CODE,T1,T2)\\\n+   size_binop_loc (UNKNOWN_LOCATION, CODE, T1, T2)\n+extern tree size_binop_loc (location_t, enum tree_code, tree, tree);\n+#define size_diffop(T1,T2)\\\n+   size_diffop_loc (UNKNOWN_LOCATION, T1, T2)\n+extern tree size_diffop_loc (location_t, tree, tree);\n \n #define size_int(L) size_int_kind (L, SIZETYPE)\n #define ssize_int(L) size_int_kind (L, SSIZETYPE)\n #define bitsize_int(L) size_int_kind (L, BITSIZETYPE)\n #define sbitsize_int(L) size_int_kind (L, SBITSIZETYPE)\n \n-extern tree round_up (tree, int);\n-extern tree round_down (tree, int);\n+#define round_up(T,N) round_up_loc (UNKNOWN_LOCATION, T, N)\n+extern tree round_up_loc (location_t, tree, int);\n+#define round_down(T,N) round_down_loc (UNKNOWN_LOCATION, T, N)\n+extern tree round_down_loc (location_t, tree, int);\n extern tree get_pending_sizes (void);\n extern void put_pending_size (tree);\n extern void put_pending_sizes (tree);\n@@ -4649,27 +4658,53 @@ extern tree native_interpret_expr (tree, const unsigned char *, int);\n    subexpressions are not changed.  */\n \n extern tree fold (tree);\n-extern tree fold_unary (enum tree_code, tree, tree);\n-extern tree fold_unary_ignore_overflow (enum tree_code, tree, tree);\n-extern tree fold_binary (enum tree_code, tree, tree, tree);\n-extern tree fold_ternary (enum tree_code, tree, tree, tree, tree);\n-extern tree fold_build1_stat (enum tree_code, tree, tree MEM_STAT_DECL);\n-#define fold_build1(c,t1,t2) fold_build1_stat (c, t1, t2 MEM_STAT_INFO)\n-extern tree fold_build2_stat (enum tree_code, tree, tree, tree MEM_STAT_DECL);\n-#define fold_build2(c,t1,t2,t3) fold_build2_stat (c, t1, t2, t3 MEM_STAT_INFO)\n-extern tree fold_build3_stat (enum tree_code, tree, tree, tree, tree MEM_STAT_DECL);\n-#define fold_build3(c,t1,t2,t3,t4) fold_build3_stat (c, t1, t2, t3, t4 MEM_STAT_INFO)\n-extern tree fold_build1_initializer (enum tree_code, tree, tree);\n-extern tree fold_build2_initializer (enum tree_code, tree, tree, tree);\n-extern tree fold_build3_initializer (enum tree_code, tree, tree, tree, tree);\n-extern tree fold_build_call_array (tree, tree, int, tree *);\n-extern tree fold_build_call_array_initializer (tree, tree, int, tree *);\n+#define fold_unary(CODE,T1,T2)\\\n+   fold_unary_loc (UNKNOWN_LOCATION, CODE, T1, T2)\n+extern tree fold_unary_loc (location_t, enum tree_code, tree, tree);\n+#define fold_unary_ignore_overflow(CODE,T1,T2)\\\n+   fold_unary_ignore_overflow_loc (UNKNOWN_LOCATION, CODE, T1, T2)\n+extern tree fold_unary_ignore_overflow_loc (location_t, enum tree_code, tree, tree);\n+#define fold_binary(CODE,T1,T2,T3)\\\n+   fold_binary_loc (UNKNOWN_LOCATION, CODE, T1, T2, T3)\n+extern tree fold_binary_loc (location_t, enum tree_code, tree, tree, tree);\n+#define fold_ternary(CODE,T1,T2,T3,T4)\\\n+   fold_ternary_loc (UNKNOWN_LOCATION, CODE, T1, T2, T3, T4)\n+extern tree fold_ternary_loc (location_t, enum tree_code, tree, tree, tree, tree);\n+#define fold_build1(c,t1,t2)\\\n+   fold_build1_stat_loc (UNKNOWN_LOCATION, c, t1, t2 MEM_STAT_INFO)\n+#define fold_build1_loc(l,c,t1,t2)\\\n+   fold_build1_stat_loc (l, c, t1, t2 MEM_STAT_INFO)\n+extern tree fold_build1_stat_loc (location_t, enum tree_code, tree,\n+\t\t\t\t  tree MEM_STAT_DECL);\n+#define fold_build2(c,t1,t2,t3)\\\n+   fold_build2_stat_loc (UNKNOWN_LOCATION, c, t1, t2, t3 MEM_STAT_INFO)\n+#define fold_build2_loc(l,c,t1,t2,t3)\\\n+   fold_build2_stat_loc (l, c, t1, t2, t3 MEM_STAT_INFO)\n+extern tree fold_build2_stat_loc (location_t, enum tree_code, tree, tree,\n+\t\t\t\t  tree MEM_STAT_DECL);\n+#define fold_build3(c,t1,t2,t3,t4)\\\n+   fold_build3_stat_loc (UNKNOWN_LOCATION, c, t1, t2, t3, t4 MEM_STAT_INFO)\n+#define fold_build3_loc(l,c,t1,t2,t3,t4)\\\n+   fold_build3_stat_loc (l, c, t1, t2, t3, t4 MEM_STAT_INFO)\n+extern tree fold_build3_stat_loc (location_t, enum tree_code, tree, tree, tree,\n+\t\t\t\t  tree MEM_STAT_DECL);\n+extern tree fold_build1_initializer_loc (location_t, enum tree_code, tree, tree);\n+extern tree fold_build2_initializer_loc (location_t, enum tree_code, tree, tree, tree);\n+extern tree fold_build3_initializer_loc (location_t, enum tree_code, tree, tree, tree, tree);\n+#define fold_build_call_array(T1,T2,N,T4)\\\n+   fold_build_call_array_loc (UNKNOWN_LOCATION, T1, T2, N, T4)\n+extern tree fold_build_call_array_loc (location_t, tree, tree, int, tree *);\n+#define fold_build_call_array_initializer(T1,T2,N,T4)\\\n+   fold_build_call_array_initializer_loc (UNKNOWN_LOCATION, T1, T2, N, T4)\n+extern tree fold_build_call_array_initializer_loc (location_t, tree, tree, int, tree *);\n extern bool fold_convertible_p (const_tree, const_tree);\n-extern tree fold_convert (tree, tree);\n-extern tree fold_single_bit_test (enum tree_code, tree, tree, tree);\n+#define fold_convert(T1,T2)\\\n+   fold_convert_loc(UNKNOWN_LOCATION, T1, T2)\n+extern tree fold_convert_loc (location_t, tree, tree);\n+extern tree fold_single_bit_test (location_t, enum tree_code, tree, tree, tree);\n extern tree fold_ignored_result (tree);\n extern tree fold_abs_const (tree, tree);\n-extern tree fold_indirect_ref_1 (tree, tree);\n+extern tree fold_indirect_ref_1 (location_t, tree, tree);\n extern void fold_defer_overflow_warnings (void);\n extern void fold_undefer_overflow_warnings (bool, const_gimple, int);\n extern void fold_undefer_and_ignore_overflow_warnings (void);\n@@ -4721,20 +4756,34 @@ enum operand_equal_flag\n \n extern int operand_equal_p (const_tree, const_tree, unsigned int);\n extern int multiple_of_p (tree, const_tree, const_tree);\n-extern tree omit_one_operand (tree, tree, tree);\n-extern tree omit_two_operands (tree, tree, tree, tree);\n-extern tree invert_truthvalue (tree);\n-extern tree fold_truth_not_expr (tree);\n+#define omit_one_operand(T1,T2,T3)\\\n+   omit_one_operand_loc (UNKNOWN_LOCATION, T1, T2, T3)\n+extern tree omit_one_operand_loc (location_t, tree, tree, tree);\n+#define omit_two_operands(T1,T2,T3,T4)\\\n+   omit_two_operands_loc (UNKNOWN_LOCATION, T1, T2, T3, T4)\n+extern tree omit_two_operands_loc (location_t, tree, tree, tree, tree);\n+#define invert_truthvalue(T)\\\n+   invert_truthvalue_loc(UNKNOWN_LOCATION, T)\n+extern tree invert_truthvalue_loc (location_t, tree);\n+extern tree fold_truth_not_expr (location_t, tree);\n extern tree fold_unary_to_constant (enum tree_code, tree, tree);\n extern tree fold_binary_to_constant (enum tree_code, tree, tree, tree);\n extern tree fold_read_from_constant_string (tree);\n extern tree int_const_binop (enum tree_code, const_tree, const_tree, int);\n-extern tree build_fold_addr_expr (tree);\n+#define build_fold_addr_expr(T)\\\n+        build_fold_addr_expr_loc (UNKNOWN_LOCATION, (T))\n+extern tree build_fold_addr_expr_loc (location_t, tree);\n+#define build_fold_addr_expr_with_type(T,TYPE)\\\n+        build_fold_addr_expr_with_type_loc (UNKNOWN_LOCATION, (T), TYPE)\n+extern tree build_fold_addr_expr_with_type_loc (location_t, tree, tree);\n extern tree fold_build_cleanup_point_expr (tree type, tree expr);\n extern tree fold_strip_sign_ops (tree);\n-extern tree build_fold_addr_expr_with_type (tree, tree);\n-extern tree build_fold_indirect_ref (tree);\n-extern tree fold_indirect_ref (tree);\n+#define build_fold_indirect_ref(T)\\\n+        build_fold_indirect_ref_loc (UNKNOWN_LOCATION, T)\n+extern tree build_fold_indirect_ref_loc (location_t, tree);\n+#define fold_indirect_ref(T)\\\n+        fold_indirect_ref_loc (UNKNOWN_LOCATION, T)\n+extern tree fold_indirect_ref_loc (location_t, tree);\n extern tree constant_boolean_node (int, tree);\n extern tree div_if_zero_remainder (enum tree_code, const_tree, const_tree);\n \n@@ -4759,7 +4808,7 @@ extern bool tree_call_nonnegative_warnv_p (tree, tree, tree, tree, bool *);\n extern bool tree_expr_nonzero_warnv_p (tree, bool *);\n \n extern bool fold_real_zero_addition_p (const_tree, const_tree, int);\n-extern tree combine_comparisons (enum tree_code, enum tree_code,\n+extern tree combine_comparisons (location_t, enum tree_code, enum tree_code,\n \t\t\t\t enum tree_code, tree, tree, tree);\n extern void debug_fold_checksum (const_tree);\n \n@@ -4775,21 +4824,23 @@ truth_value_p (enum tree_code code)\n \n \n /* In builtins.c */\n-extern tree fold_call_expr (tree, bool);\n-extern tree fold_builtin_fputs (tree, tree, bool, bool, tree);\n-extern tree fold_builtin_strcpy (tree, tree, tree, tree);\n-extern tree fold_builtin_strncpy (tree, tree, tree, tree, tree);\n-extern tree fold_builtin_memory_chk (tree, tree, tree, tree, tree, tree, bool,\n+extern tree fold_call_expr (location_t, tree, bool);\n+extern tree fold_builtin_fputs (location_t, tree, tree, bool, bool, tree);\n+extern tree fold_builtin_strcpy (location_t, tree, tree, tree, tree);\n+extern tree fold_builtin_strncpy (location_t, tree, tree, tree, tree, tree);\n+extern tree fold_builtin_memory_chk (location_t, tree, tree, tree, tree, tree, tree, bool,\n \t\t\t\t     enum built_in_function);\n-extern tree fold_builtin_stxcpy_chk (tree, tree, tree, tree, tree, bool,\n+extern tree fold_builtin_stxcpy_chk (location_t, tree, tree, tree, tree, tree, bool,\n \t\t\t\t     enum built_in_function);\n-extern tree fold_builtin_strncpy_chk (tree, tree, tree, tree, tree);\n-extern tree fold_builtin_snprintf_chk (tree, tree, enum built_in_function);\n+extern tree fold_builtin_strncpy_chk (location_t, tree, tree, tree, tree, tree);\n+extern tree fold_builtin_snprintf_chk (location_t, tree, tree, enum built_in_function);\n extern bool fold_builtin_next_arg (tree, bool);\n extern enum built_in_function builtin_mathfn_code (const_tree);\n-extern tree build_function_call_expr (tree, tree);\n-extern tree fold_builtin_call_array (tree, tree, int, tree *);\n-extern tree build_call_expr (tree, int, ...);\n+extern tree build_function_call_expr (location_t, tree, tree);\n+extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);\n+#define build_call_expr(...)\\\n+   build_call_expr_loc (UNKNOWN_LOCATION, __VA_ARGS__)\n+extern tree build_call_expr_loc (location_t, tree, int, ...);\n extern tree mathfn_built_in (tree, enum built_in_function fn);\n extern tree c_strlen (tree, int);\n extern tree std_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n@@ -4804,7 +4855,7 @@ extern int get_object_alignment (tree, unsigned int, unsigned int);\n extern tree fold_call_stmt (gimple, bool);\n extern tree gimple_fold_builtin_snprintf_chk (gimple, tree, enum built_in_function);\n extern tree make_range (tree, int *, tree *, tree *, bool *);\n-extern tree build_range_check (tree, tree, int, tree, tree);\n+extern tree build_range_check (location_t, tree, tree, int, tree, tree);\n extern bool merge_ranges (int *, tree *, tree *, int, tree, tree, int, \n \t\t\t  tree, tree);\n "}, {"sha": "729cc0780668c4941b35992702032fdd827003ce", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3927fb49c9f13a0da61a75d771f51dc7c45b92/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=db3927fb49c9f13a0da61a75d771f51dc7c45b92", "patch": "@@ -445,7 +445,7 @@ emutls_common_1 (void **loc, void *xstmts)\n   args = tree_cons (NULL, x, args);\n \n   x = built_in_decls[BUILT_IN_EMUTLS_REGISTER_COMMON];\n-  x = build_function_call_expr (x, args);\n+  x = build_function_call_expr (UNKNOWN_LOCATION, x, args);\n \n   append_to_statement_list (x, pstmts);\n   return 1;"}]}