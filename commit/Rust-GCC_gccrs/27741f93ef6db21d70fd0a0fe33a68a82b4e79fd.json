{"sha": "27741f93ef6db21d70fd0a0fe33a68a82b4e79fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc3NDFmOTNlZjZkYjIxZDcwZmQwYTBmZTMzYTY4YTgyYjRlNzlmZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-01-30T22:24:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-01-30T22:24:40Z"}, "message": "runtime: In backtraces, get inline functions, skip split-stack fns.\n\nFrom-SVN: r195591", "tree": {"sha": "1764d8d318ba67622aefbf3e311749a6744bfa02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1764d8d318ba67622aefbf3e311749a6744bfa02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/comments", "author": null, "committer": null, "parents": [{"sha": "e60e09a0e0e8c1b17fc35cf25b739666a96010b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e60e09a0e0e8c1b17fc35cf25b739666a96010b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e60e09a0e0e8c1b17fc35cf25b739666a96010b9"}], "stats": {"total": 196, "additions": 143, "deletions": 53}, "files": [{"sha": "d84580fa594b98eea23bee346c5ba9dd208cd55d", "filename": "libgo/runtime/go-caller.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fgo-caller.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fgo-caller.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-caller.c?ref=27741f93ef6db21d70fd0a0fe33a68a82b4e79fd", "patch": "@@ -166,16 +166,16 @@ struct caller_ret\n Caller (int skip)\n {\n   struct caller_ret ret;\n-  uintptr pc;\n+  Location loc;\n   int32 n;\n-  String fn;\n \n   runtime_memclr (&ret, sizeof ret);\n-  n = runtime_callers (skip + 1, &pc, 1);\n+  n = runtime_callers (skip + 1, &loc, 1);\n   if (n < 1)\n     return ret;\n-  ret.pc = pc;\n-  __go_file_line (pc, &fn, &ret.file, &ret.line);\n+  ret.pc = loc.pc;\n+  ret.file = loc.filename;\n+  ret.line = loc.lineno;\n   ret.ok = 1;\n   return ret;\n }"}, {"sha": "ea6b5db1bcb2b8f6462bc7d387d6758545532afc", "filename": "libgo/runtime/go-callers.c", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fgo-callers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fgo-callers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-callers.c?ref=27741f93ef6db21d70fd0a0fe33a68a82b4e79fd", "patch": "@@ -15,20 +15,37 @@\n \n struct callers_data\n {\n-  uintptr *pcbuf;\n+  Location *locbuf;\n   int index;\n   int max;\n };\n \n-/* Callback function for backtrace_simple.  Just collect the PC\n-   values.  Return zero to continue, non-zero to stop.  */\n+/* Callback function for backtrace_full.  Just collect the locations.\n+   Return zero to continue, non-zero to stop.  */\n \n static int\n-callback (void *data, uintptr_t pc)\n+callback (void *data, uintptr_t pc, const char *filename, int lineno,\n+\t  const char *function)\n {\n   struct callers_data *arg = (struct callers_data *) data;\n-\n-  arg->pcbuf[arg->index] = pc;\n+  Location *loc;\n+\n+  /* Skip split stack functions.  */\n+  if (function != NULL)\n+    {\n+      const char *p = function;\n+\n+      if (__builtin_strncmp (p, \"___\", 3) == 0)\n+\t++p;\n+      if (__builtin_strncmp (p, \"__morestack_\", 12) == 0)\n+\treturn 0;\n+    }\n+\n+  loc = &arg->locbuf[arg->index];\n+  loc->pc = pc;\n+  loc->filename = runtime_gostring ((const byte *) filename);\n+  loc->function = runtime_gostring ((const byte *) function);\n+  loc->lineno = lineno;\n   ++arg->index;\n   return arg->index >= arg->max;\n }\n@@ -47,15 +64,15 @@ error_callback (void *data __attribute__ ((unused)),\n /* Gather caller PC's.  */\n \n int32\n-runtime_callers (int32 skip, uintptr *pcbuf, int32 m)\n+runtime_callers (int32 skip, Location *locbuf, int32 m)\n {\n   struct callers_data data;\n \n-  data.pcbuf = pcbuf;\n+  data.locbuf = locbuf;\n   data.index = 0;\n   data.max = m;\n-  backtrace_simple (__go_get_backtrace_state (), skip + 1, callback,\n-\t\t    error_callback, &data);\n+  backtrace_full (__go_get_backtrace_state (), skip + 1, callback,\n+\t\t  error_callback, &data);\n   return data.index;\n }\n \n@@ -65,8 +82,19 @@ int Callers (int, struct __go_open_array)\n int\n Callers (int skip, struct __go_open_array pc)\n {\n+  Location *locbuf;\n+  int ret;\n+  int i;\n+\n+  locbuf = (Location *) runtime_mal (pc.__count * sizeof (Location));\n+\n   /* In the Go 1 release runtime.Callers has an off-by-one error,\n      which we can not correct because it would break backward\n      compatibility.  Adjust SKIP here to be compatible.  */\n-  return runtime_callers (skip - 1, (uintptr *) pc.__values, pc.__count);\n+  ret = runtime_callers (skip - 1, locbuf, pc.__count);\n+\n+  for (i = 0; i < ret; i++)\n+    ((uintptr *) pc.__values)[i] = locbuf[i].pc;\n+\n+  return ret;\n }"}, {"sha": "f397f07523131583bc8d2591600a20cfb2bdbaa1", "filename": "libgo/runtime/go-traceback.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fgo-traceback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fgo-traceback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-traceback.c?ref=27741f93ef6db21d70fd0a0fe33a68a82b4e79fd", "patch": "@@ -13,29 +13,25 @@\n void\n runtime_traceback ()\n {\n-  uintptr pcbuf[100];\n+  Location locbuf[100];\n   int32 c;\n \n-  c = runtime_callers (1, pcbuf, sizeof pcbuf / sizeof pcbuf[0]);\n-  runtime_printtrace (pcbuf, c, true);\n+  c = runtime_callers (1, locbuf, nelem (locbuf));\n+  runtime_printtrace (locbuf, c, true);\n }\n \n void\n-runtime_printtrace (uintptr *pcbuf, int32 c, bool current)\n+runtime_printtrace (Location *locbuf, int32 c, bool current)\n {\n   int32 i;\n \n   for (i = 0; i < c; ++i)\n     {\n-      String fn;\n-      String file;\n-      intgo line;\n-\n-      if (__go_file_line (pcbuf[i], &fn, &file, &line)\n-\t  && runtime_showframe (fn, current))\n+      if (runtime_showframe (locbuf[i].function, current))\n \t{\n-\t  runtime_printf (\"%S\\n\", fn);\n-\t  runtime_printf (\"\\t%S:%D\\n\", file, (int64) line);\n+\t  runtime_printf (\"%S\\n\", locbuf[i].function);\n+\t  runtime_printf (\"\\t%S:%D\\n\", locbuf[i].filename,\n+\t\t\t  (int64) locbuf[i].lineno);\n \t}\n     }\n }"}, {"sha": "c1b09bea7f516fbc13ad260c1d974364ff9c5f1b", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=27741f93ef6db21d70fd0a0fe33a68a82b4e79fd", "patch": "@@ -11,6 +11,7 @@ package runtime\n #include \"malloc.h\"\n #include \"defs.h\"\n #include \"go-type.h\"\n+#include \"go-string.h\"\n \n // NOTE(rsc): Everything here could use cas if contention became an issue.\n static Lock proflock;\n@@ -46,7 +47,7 @@ struct Bucket\n \t};\n \tuintptr\thash;\n \tuintptr\tnstk;\n-\tuintptr\tstk[1];\n+\tLocation stk[1];\n };\n enum {\n \tBuckHashSize = 179999,\n@@ -58,9 +59,9 @@ static uintptr bucketmem;\n \n // Return the bucket for stk[0:nstk], allocating new bucket if needed.\n static Bucket*\n-stkbucket(int32 typ, uintptr *stk, int32 nstk, bool alloc)\n+stkbucket(int32 typ, Location *stk, int32 nstk, bool alloc)\n {\n-\tint32 i;\n+\tint32 i, j;\n \tuintptr h;\n \tBucket *b;\n \n@@ -72,18 +73,26 @@ stkbucket(int32 typ, uintptr *stk, int32 nstk, bool alloc)\n \t// Hash stack.\n \th = 0;\n \tfor(i=0; i<nstk; i++) {\n-\t\th += stk[i];\n+\t\th += stk[i].pc;\n \t\th += h<<10;\n \t\th ^= h>>6;\n \t}\n \th += h<<3;\n \th ^= h>>11;\n \n \ti = h%BuckHashSize;\n-\tfor(b = buckhash[i]; b; b=b->next)\n-\t\tif(b->typ == typ && b->hash == h && b->nstk == (uintptr)nstk &&\n-\t\t   runtime_mcmp((byte*)b->stk, (byte*)stk, nstk*sizeof stk[0]) == 0)\n-\t\t\treturn b;\n+\tfor(b = buckhash[i]; b; b=b->next) {\n+\t\tif(b->typ == typ && b->hash == h && b->nstk == (uintptr)nstk) {\n+\t\t\tfor(j = 0; j < nstk; j++) {\n+\t\t\t\tif(b->stk[j].pc != stk[j].pc ||\n+\t\t\t\t   b->stk[j].lineno != stk[j].lineno ||\n+\t\t\t\t   !__go_strings_equal(b->stk[j].filename, stk[j].filename))\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (j == nstk)\n+\t\t\t\treturn b;\n+\t\t}\n+\t}\n \n \tif(!alloc)\n \t\treturn nil;\n@@ -241,7 +250,7 @@ runtime_MProf_Malloc(void *p, uintptr size)\n {\n \tM *m;\n \tint32 nstk;\n-\tuintptr stk[32];\n+\tLocation stk[32];\n \tBucket *b;\n \n \tm = runtime_m();\n@@ -298,7 +307,7 @@ runtime_blockevent(int64 cycles, int32 skip)\n {\n \tint32 nstk;\n \tint64 rate;\n-\tuintptr stk[32];\n+\tLocation stk[32];\n \tBucket *b;\n \n \tif(cycles <= 0)\n@@ -336,7 +345,7 @@ record(Record *r, Bucket *b)\n \tr->alloc_objects = b->allocs;\n \tr->free_objects = b->frees;\n \tfor(i=0; i<b->nstk && i<nelem(r->stk); i++)\n-\t\tr->stk[i] = b->stk[i];\n+\t\tr->stk[i] = b->stk[i].pc;\n \tfor(; i<nelem(r->stk); i++)\n \t\tr->stk[i] = 0;\n }\n@@ -396,7 +405,7 @@ func BlockProfile(p Slice) (n int, ok bool) {\n \t\t\tr->count = b->count;\n \t\t\tr->cycles = b->cycles;\n \t\t\tfor(i=0; (uintptr)i<b->nstk && (uintptr)i<nelem(r->stk); i++)\n-\t\t\t\tr->stk[i] = b->stk[i];\n+\t\t\t\tr->stk[i] = b->stk[i].pc;\n \t\t\tfor(; (uintptr)i<nelem(r->stk); i++)\n \t\t\t\tr->stk[i] = 0;\t\t\t\n \t\t}\n@@ -413,6 +422,7 @@ struct TRecord {\n func ThreadCreateProfile(p Slice) (n int, ok bool) {\n \tTRecord *r;\n \tM *first, *mp;\n+\tint32 i;\n \t\n \tfirst = runtime_atomicloadp(&runtime_allm);\n \tn = 0;\n@@ -423,7 +433,9 @@ func ThreadCreateProfile(p Slice) (n int, ok bool) {\n \t\tok = true;\n \t\tr = (TRecord*)p.__values;\n \t\tfor(mp=first; mp; mp=mp->alllink) {\n-\t\t\truntime_memmove(r->stk, mp->createstack, sizeof r->stk);\n+\t\t\tfor(i = 0; (uintptr)i < nelem(r->stk); i++) {\n+\t\t\t\tr->stk[i] = mp->createstack[i].pc;\n+\t\t\t}\n \t\t\tr++;\n \t\t}\n \t}\n@@ -473,10 +485,14 @@ func Stack(b Slice, all bool) (n int) {\n static void\n saveg(G *gp, TRecord *r)\n {\n-\tint32 n;\n+\tint32 n, i;\n+\tLocation locstk[nelem(r->stk)];\n \n-\tif(gp == runtime_g())\n-\t\tn = runtime_callers(0, r->stk, nelem(r->stk));\n+\tif(gp == runtime_g()) {\n+\t\tn = runtime_callers(0, locstk, nelem(r->stk));\n+\t\tfor(i = 0; i < n; i++)\n+\t\t\tr->stk[i] = locstk[i].pc;\n+\t}\n \telse {\n \t\t// FIXME: Not implemented.\n \t\tn = 0;"}, {"sha": "6d9007614b92cb283e2d24379fe235b61b76d76b", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=27741f93ef6db21d70fd0a0fe33a68a82b4e79fd", "patch": "@@ -631,7 +631,7 @@ runtime_goroutinetrailer(G *g)\n struct Traceback\n {\n \tG* gp;\n-\tuintptr pcbuf[100];\n+\tLocation locbuf[100];\n \tint32 c;\n };\n \n@@ -677,7 +677,7 @@ runtime_tracebackothers(G * volatile me)\n \t\t\truntime_gogo(gp);\n \t\t}\n \n-\t\truntime_printtrace(tb.pcbuf, tb.c, false);\n+\t\truntime_printtrace(tb.locbuf, tb.c, false);\n \t\truntime_goroutinetrailer(gp);\n \t}\n }\n@@ -692,8 +692,8 @@ gtraceback(G* gp)\n \n \ttraceback = gp->traceback;\n \tgp->traceback = nil;\n-\ttraceback->c = runtime_callers(1, traceback->pcbuf,\n-\t\tsizeof traceback->pcbuf / sizeof traceback->pcbuf[0]);\n+\ttraceback->c = runtime_callers(1, traceback->locbuf,\n+\t\tsizeof traceback->locbuf / sizeof traceback->locbuf[0]);\n \truntime_gogo(traceback->gp);\n }\n \n@@ -1742,13 +1742,14 @@ static struct {\n \tvoid (*fn)(uintptr*, int32);\n \tint32 hz;\n \tuintptr pcbuf[100];\n+\tLocation locbuf[100];\n } prof;\n \n // Called if we receive a SIGPROF signal.\n void\n runtime_sigprof()\n {\n-\tint32 n;\n+\tint32 n, i;\n \n \tif(prof.fn == nil || prof.hz == 0)\n \t\treturn;\n@@ -1758,7 +1759,9 @@ runtime_sigprof()\n \t\truntime_unlock(&prof);\n \t\treturn;\n \t}\n-\tn = runtime_callers(0, prof.pcbuf, nelem(prof.pcbuf));\n+\tn = runtime_callers(0, prof.locbuf, nelem(prof.locbuf));\n+\tfor(i = 0; i < n; i++)\n+\t\tprof.pcbuf[i] = prof.locbuf[i].pc;\n \tif(n > 0)\n \t\tprof.fn(prof.pcbuf, n);\n \truntime_unlock(&prof);"}, {"sha": "9392df162bffb5ab368b64ce42ccd36f664e6fe2", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=27741f93ef6db21d70fd0a0fe33a68a82b4e79fd", "patch": "@@ -83,6 +83,8 @@ typedef struct\t__go_map_type\t\tMapType;\n \n typedef struct  Traceback\tTraceback;\n \n+typedef struct\tLocation\tLocation;\n+\n /*\n  * Per-CPU declaration.\n  */\n@@ -155,6 +157,16 @@ struct\tGCStats\n \tuint64\tnosyield;\n \tuint64\tnsleep;\n };\n+\n+// A location in the program, used for backtraces.\n+struct\tLocation\n+{\n+\tuintptr\tpc;\n+\tString\tfilename;\n+\tString\tfunction;\n+\tintgo\tlineno;\n+};\n+\n struct\tG\n {\n \tDefer*\tdefer;\n@@ -226,7 +238,7 @@ struct\tM\n \tMCache\t*mcache;\n \tG*\tlockedg;\n \tG*\tidleg;\n-\tuintptr\tcreatestack[32];\t// Stack that created this thread.\n+\tLocation createstack[32];\t// Stack that created this thread.\n \tM*\tnextwaitm;\t// next M waiting for lock\n \tuintptr\twaitsema;\t// semaphore for parking on locks\n \tuint32\twaitsemacount;\n@@ -391,7 +403,8 @@ void\truntime_goroutineheader(G*);\n void\truntime_goroutinetrailer(G*);\n void\truntime_traceback();\n void\truntime_tracebackothers(G*);\n-void\truntime_printtrace(uintptr*, int32, bool);\n+void\truntime_printtrace(Location*, int32, bool);\n+String\truntime_gostring(const byte*);\n String\truntime_gostringnocopy(const byte*);\n void*\truntime_mstart(void*);\n G*\truntime_malg(int32, byte**, size_t*);\n@@ -406,7 +419,7 @@ void\truntime_entersyscall(void) __asm__ (GOSYM_PREFIX \"syscall.Entersyscall\");\n void\truntime_exitsyscall(void) __asm__ (GOSYM_PREFIX \"syscall.Exitsyscall\");\n void\tsiginit(void);\n bool\t__go_sigsend(int32 sig);\n-int32\truntime_callers(int32, uintptr*, int32);\n+int32\truntime_callers(int32, Location*, int32);\n int64\truntime_nanotime(void);\n int64\truntime_cputicks(void);\n int64\truntime_tickspersecond(void);"}, {"sha": "04ecbe6f73ac46be1eac61d84c6961cf8841a6ca", "filename": "libgo/runtime/string.goc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fstring.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27741f93ef6db21d70fd0a0fe33a68a82b4e79fd/libgo%2Fruntime%2Fstring.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fstring.goc?ref=27741f93ef6db21d70fd0a0fe33a68a82b4e79fd", "patch": "@@ -10,6 +10,8 @@ package runtime\n \n #define charntorune(pv, str, len) __go_get_rune(str, len, pv)\n \n+const String\truntime_emptystring;\n+\n intgo\n runtime_findnull(const byte *s)\n {\n@@ -18,6 +20,38 @@ runtime_findnull(const byte *s)\n \treturn __builtin_strlen((const char*) s);\n }\n \n+static String\n+gostringsize(intgo l, byte** pmem)\n+{\n+\tString s;\n+\tbyte *mem;\n+\n+\tif(l == 0) {\n+\t\t*pmem = nil;\n+\t\treturn runtime_emptystring;\n+\t}\n+\t// leave room for NUL for C runtime (e.g., callers of getenv)\n+\tmem = runtime_mallocgc(l+1, FlagNoPointers, 1, 0);\n+\ts.str = mem;\n+\ts.len = l;\n+\tmem[l] = 0;\n+\t*pmem = mem;\n+\treturn s;\n+}\n+\n+String\n+runtime_gostring(const byte *str)\n+{\n+\tintgo l;\n+\tString s;\n+\tbyte *mem;\n+\n+\tl = runtime_findnull(str);\n+\ts = gostringsize(l, &mem);\n+\truntime_memmove(mem, str, l);\n+\treturn s;\n+}\n+\n String\n runtime_gostringnocopy(const byte *str)\n {"}]}