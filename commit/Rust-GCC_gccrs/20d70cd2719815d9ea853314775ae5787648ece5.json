{"sha": "20d70cd2719815d9ea853314775ae5787648ece5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBkNzBjZDI3MTk4MTVkOWVhODUzMzE0Nzc1YWU1Nzg3NjQ4ZWNlNQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2019-05-08T23:07:26Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2019-05-08T23:07:26Z"}, "message": "[RS6000] PR89271, gcc.target/powerpc/vsx-simode2.c\n\nThis patch makes a number of corrections to rs6000_register_move_cost,\nadds a new register union class, GEN_OR_VSX_REGS, and adjusts insn\nalternative costs to suit.\n\nThe patch initially just corrected register move cost when direct\nmoves are available, but that resulted in regressions.  Inspection of\nthose regressions showed ALL_REGS being used as the register allocno\nclass, which isn't ideal.  gcc/doc/tm.texi says: \"You should define a\nclass for the union of two classes whenever some instruction allows\nboth classes\".  Thus, define GEN_OR_VSX_REGS for the register\nallocator.  (IRA wants to use the union of two register classes when\nthe costs of the classes are below memory cost, which happens more\noften with the low direct move cost.)\n\nAs per https://gcc.gnu.org/bugzilla/show_bug.cgi?id=89271#c11 we ought\nto be returning the minimal cost for union classes.  That can be done\nby rs6000_register_move_cost testing for vsx first, where the number\nof regs for a given mode might be smaller than the same mode in gprs,\nand changing the LINK_OR_CTR_REGS case to exclude SPEC_OR_GEN_REGS and\nNON_FLOAT_REGS.\n\nI removed the VECTOR_MEM_VSX_P test since that leads to silly results\nfor scalar mode moves between altivec and float when TARGET_VSX.  eg.\nrs6000_register_move_cost:, ret=2, mode=DF, from=FLOAT_REGS, to=FLOAT_REGS\nrs6000_register_move_cost:, ret=16, mode=DF, from=FLOAT_REGS, to=ALTIVEC_REGS\nrs6000_register_move_cost:, ret=2, mode=DF, from=FLOAT_REGS, to=VSX_REGS\n\nThe patch also fixes wrong results for moves within and between any of\nthe non-gpr, non-vsx special reg classes.  The comment about \"moving\nbetween two similar registers is just one instruction\" is false.  We\ncan't move lr to ctr directly, for example.  I believe the intent of\nthe \"reg_classes_intersect_p (to, from)\" was to cover moves within\nfloat or altivec, so I moved that test inside the code handling vsx,\nand made sure the intersection wasn't anything besides vsx by masking\noff everything else.  Masking isn't strictly necessary at the moment,\nbut would be if we create a GEN_OR_ALTIVEC_REGS class some time in the\nfuture.\n\nTARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS is needed for rs6000 in order\nto fix the 20% cactus_adm spec regression when using GEN_OR_VSX_REGS\nas an allocno class.  It is similar to the aarch64 version but without\nany selection by regno mode if the best class is a union class.\n\n\tPR target/89271\n\t* config/rs6000/rs6000.h (enum reg_class, REG_CLASS_NAMES),\n\t(REG_CLASS_CONTENTS): Add GEN_OR_VSX_REGS class.\n\t* config/rs6000/rs6000.c (rs6000_register_move_cost): Correct\n\tcost for general <-> vsx when direct moves are available.\n\tCost union classes at minimal cost for any reg in the class.\n\tCorrect calculation for moves between vsx, float, and altivec.\n\tDon't return a low cost for moves between special regs.  Don't\n\tuse hard coded register numbers.\n\t(TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS): Define.\n\t(rs6000_ira_change_pseudo_allocno_class): New function.\n\t* config/rs6000/rs6000.md (movsi_internal1, mov<mode>_internal),\n\t(movdi_internal32, movdi_internal64): Remove '*' from vsx register\n\talternatives.\n\t(movsi_internal1): Don't disparage vector alternatives.\n\t(mov<mode>_internal): Likewise, excepting alternative that\n\twill be split.\n\t* config/rs6000/vsx.md (vsx_splat_<mode>_reg): Don't disparage\n\twe <- b alternative.\n\nFrom-SVN: r271022", "tree": {"sha": "a39f6103672abd88d4ded48d127cb65355f1c2d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a39f6103672abd88d4ded48d127cb65355f1c2d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20d70cd2719815d9ea853314775ae5787648ece5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20d70cd2719815d9ea853314775ae5787648ece5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20d70cd2719815d9ea853314775ae5787648ece5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20d70cd2719815d9ea853314775ae5787648ece5/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3407d1658f7d60cfb78293d61dfc21258efb0074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3407d1658f7d60cfb78293d61dfc21258efb0074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3407d1658f7d60cfb78293d61dfc21258efb0074"}], "stats": {"total": 181, "additions": 145, "deletions": 36}, "files": [{"sha": "37447f854c0d76e1047c130bd1b2021a7d776b79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d70cd2719815d9ea853314775ae5787648ece5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d70cd2719815d9ea853314775ae5787648ece5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20d70cd2719815d9ea853314775ae5787648ece5", "patch": "@@ -1,3 +1,25 @@\n+2019-05-09  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/89271\n+\t* config/rs6000/rs6000.h (enum reg_class, REG_CLASS_NAMES),\n+\t(REG_CLASS_CONTENTS): Add GEN_OR_VSX_REGS class.\n+\t* config/rs6000/rs6000.c (rs6000_register_move_cost): Correct\n+\tcost for general <-> vsx when direct moves are available.\n+\tCost union classes at minimal cost for any reg in the class.\n+\tCorrect calculation for moves between vsx, float, and altivec.\n+\tDon't return a low cost for moves between special regs.  Don't\n+\tuse hard coded register numbers.\n+\t(TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS): Define.\n+\t(rs6000_ira_change_pseudo_allocno_class): New function.\n+\t* config/rs6000/rs6000.md (movsi_internal1, mov<mode>_internal),\n+\t(movdi_internal32, movdi_internal64): Remove '*' from vsx register\n+\talternatives.\n+\t(movsi_internal1): Don't disparage vector alternatives.\n+\t(mov<mode>_internal): Likewise, excepting alternative that\n+\twill be split.\n+\t* config/rs6000/vsx.md (vsx_splat_<mode>_reg): Don't disparage\n+\twe <- b alternative.\n+\n 2019-05-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/59813"}, {"sha": "3d1af9f1bc9e4eaa018c9e1ef9d6130f00fe8eb3", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 105, "deletions": 22, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d70cd2719815d9ea853314775ae5787648ece5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d70cd2719815d9ea853314775ae5787648ece5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=20d70cd2719815d9ea853314775ae5787648ece5", "patch": "@@ -1729,6 +1729,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #define TARGET_REGISTER_MOVE_COST rs6000_register_move_cost\n #undef TARGET_MEMORY_MOVE_COST\n #define TARGET_MEMORY_MOVE_COST rs6000_memory_move_cost\n+#undef TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS\n+#define TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS \\\n+  rs6000_ira_change_pseudo_allocno_class\n #undef TARGET_CANNOT_COPY_INSN_P\n #define TARGET_CANNOT_COPY_INSN_P rs6000_cannot_copy_insn_p\n #undef TARGET_RTX_COSTS\n@@ -34648,22 +34651,54 @@ rs6000_register_move_cost (machine_mode mode,\n \t\t\t   reg_class_t from, reg_class_t to)\n {\n   int ret;\n+  reg_class_t rclass;\n \n   if (TARGET_DEBUG_COST)\n     dbg_cost_ctrl++;\n \n+  /* If we have VSX, we can easily move between FPR or Altivec registers,\n+     otherwise we can only easily move within classes.\n+     Do this first so we give best-case answers for union classes\n+     containing both gprs and vsx regs.  */\n+  HARD_REG_SET to_vsx, from_vsx;\n+  COPY_HARD_REG_SET (to_vsx, reg_class_contents[to]);\n+  AND_HARD_REG_SET (to_vsx, reg_class_contents[VSX_REGS]);\n+  COPY_HARD_REG_SET (from_vsx, reg_class_contents[from]);\n+  AND_HARD_REG_SET (from_vsx, reg_class_contents[VSX_REGS]);\n+  if (!hard_reg_set_empty_p (to_vsx)\n+      && !hard_reg_set_empty_p (from_vsx)\n+      && (TARGET_VSX\n+\t  || hard_reg_set_intersect_p (to_vsx, from_vsx)))\n+    {\n+      int reg = FIRST_FPR_REGNO;\n+      if (TARGET_VSX\n+\t  || (TEST_HARD_REG_BIT (to_vsx, FIRST_ALTIVEC_REGNO)\n+\t      && TEST_HARD_REG_BIT (from_vsx, FIRST_ALTIVEC_REGNO)))\n+\treg = FIRST_ALTIVEC_REGNO;\n+      ret = 2 * hard_regno_nregs (reg, mode);\n+    }\n+\n   /*  Moves from/to GENERAL_REGS.  */\n-  if (reg_classes_intersect_p (to, GENERAL_REGS)\n-      || reg_classes_intersect_p (from, GENERAL_REGS))\n+  else if ((rclass = from, reg_classes_intersect_p (to, GENERAL_REGS))\n+\t   || (rclass = to, reg_classes_intersect_p (from, GENERAL_REGS)))\n     {\n-      reg_class_t rclass = from;\n-\n-      if (! reg_classes_intersect_p (to, GENERAL_REGS))\n-\trclass = to;\n-\n       if (rclass == FLOAT_REGS || rclass == ALTIVEC_REGS || rclass == VSX_REGS)\n-\tret = (rs6000_memory_move_cost (mode, rclass, false)\n-\t       + rs6000_memory_move_cost (mode, GENERAL_REGS, false));\n+\t{\n+\t  if (TARGET_DIRECT_MOVE)\n+\t    {\n+\t      if (rs6000_tune == PROCESSOR_POWER9)\n+\t\tret = 2 * hard_regno_nregs (FIRST_GPR_REGNO, mode);\n+\t      else\n+\t\tret = 4 * hard_regno_nregs (FIRST_GPR_REGNO, mode);\n+\t      /* SFmode requires a conversion when moving between gprs\n+\t\t and vsx.  */\n+\t      if (mode == SFmode)\n+\t\tret += 2;\n+\t    }\n+\t  else\n+\t    ret = (rs6000_memory_move_cost (mode, rclass, false)\n+\t\t   + rs6000_memory_move_cost (mode, GENERAL_REGS, false));\n+\t}\n \n       /* It's more expensive to move CR_REGS than CR0_REGS because of the\n \t shift.  */\n@@ -34676,24 +34711,14 @@ rs6000_register_move_cost (machine_mode mode,\n \t\t|| rs6000_tune == PROCESSOR_POWER7\n \t\t|| rs6000_tune == PROCESSOR_POWER8\n \t\t|| rs6000_tune == PROCESSOR_POWER9)\n-\t       && reg_classes_intersect_p (rclass, LINK_OR_CTR_REGS))\n-        ret = 6 * hard_regno_nregs (0, mode);\n+\t       && reg_class_subset_p (rclass, SPECIAL_REGS))\n+        ret = 6 * hard_regno_nregs (FIRST_GPR_REGNO, mode);\n \n       else\n \t/* A move will cost one instruction per GPR moved.  */\n-\tret = 2 * hard_regno_nregs (0, mode);\n+\tret = 2 * hard_regno_nregs (FIRST_GPR_REGNO, mode);\n     }\n \n-  /* If we have VSX, we can easily move between FPR or Altivec registers.  */\n-  else if (VECTOR_MEM_VSX_P (mode)\n-\t   && reg_classes_intersect_p (to, VSX_REGS)\n-\t   && reg_classes_intersect_p (from, VSX_REGS))\n-    ret = 2 * hard_regno_nregs (FIRST_FPR_REGNO, mode);\n-\n-  /* Moving between two similar registers is just one instruction.  */\n-  else if (reg_classes_intersect_p (to, from))\n-    ret = (FLOAT128_2REG_P (mode)) ? 4 : 2;\n-\n   /* Everything else has to go through GENERAL_REGS.  */\n   else\n     ret = (rs6000_register_move_cost (mode, GENERAL_REGS, to)\n@@ -34746,6 +34771,64 @@ rs6000_memory_move_cost (machine_mode mode, reg_class_t rclass,\n   return ret;\n }\n \n+/* Implement TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS.\n+\n+   The register allocator chooses GEN_OR_VSX_REGS for the allocno\n+   class if GENERAL_REGS and VSX_REGS cost is lower than the memory\n+   cost.  This happens a lot when TARGET_DIRECT_MOVE makes the register\n+   move cost between GENERAL_REGS and VSX_REGS low.\n+\n+   It might seem reasonable to use a union class.  After all, if usage\n+   of vsr is low and gpr high, it might make sense to spill gpr to vsr\n+   rather than memory.  However, in cases where register pressure of\n+   both is high, like the cactus_adm spec test, allowing\n+   GEN_OR_VSX_REGS as the allocno class results in bad decisions in\n+   the first scheduling pass.  This is partly due to an allocno of\n+   GEN_OR_VSX_REGS wrongly contributing to the GENERAL_REGS pressure\n+   class, which gives too high a pressure for GENERAL_REGS and too low\n+   for VSX_REGS.  So, force a choice of the subclass here.\n+\n+   The best class is also the union if GENERAL_REGS and VSX_REGS have\n+   the same cost.  In that case we do use GEN_OR_VSX_REGS as the\n+   allocno class, since trying to narrow down the class by regno mode\n+   is prone to error.  For example, SImode is allowed in VSX regs and\n+   in some cases (eg. gcc.target/powerpc/p9-xxbr-3.c do_bswap32_vect)\n+   it would be wrong to choose an allocno of GENERAL_REGS based on\n+   SImode.  */\n+\n+static reg_class_t\n+rs6000_ira_change_pseudo_allocno_class (int regno ATTRIBUTE_UNUSED,\n+\t\t\t\t\treg_class_t allocno_class,\n+\t\t\t\t\treg_class_t best_class)\n+{\n+  switch (allocno_class)\n+    {\n+    case GEN_OR_VSX_REGS:\n+      /* best_class must be a subset of allocno_class.  */\n+      gcc_checking_assert (best_class == GEN_OR_VSX_REGS\n+\t\t\t   || best_class == GEN_OR_FLOAT_REGS\n+\t\t\t   || best_class == VSX_REGS\n+\t\t\t   || best_class == ALTIVEC_REGS\n+\t\t\t   || best_class == FLOAT_REGS\n+\t\t\t   || best_class == GENERAL_REGS\n+\t\t\t   || best_class == BASE_REGS);\n+      /* Use best_class but choose wider classes when copying from the\n+\t wider class to best_class is cheap.  This mimics IRA choice\n+\t of allocno class.  */\n+      if (best_class == BASE_REGS)\n+\treturn GENERAL_REGS;\n+      if (TARGET_VSX\n+\t  && (best_class == FLOAT_REGS || best_class == ALTIVEC_REGS))\n+\treturn VSX_REGS;\n+      return best_class;\n+\n+    default:\n+      break;\n+    }\n+\n+  return allocno_class;\n+}\n+\n /* Returns a code for a target-specific builtin that implements\n    reciprocal of the function, or NULL_TREE if not available.  */\n "}, {"sha": "68ef491ac0cc9b9ed84363de4cf5b21604caf947", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d70cd2719815d9ea853314775ae5787648ece5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d70cd2719815d9ea853314775ae5787648ece5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=20d70cd2719815d9ea853314775ae5787648ece5", "patch": "@@ -1141,6 +1141,7 @@ enum reg_class\n   VRSAVE_REGS,\n   VSCR_REGS,\n   GEN_OR_FLOAT_REGS,\n+  GEN_OR_VSX_REGS,\n   LINK_REGS,\n   CTR_REGS,\n   LINK_OR_CTR_REGS,\n@@ -1169,6 +1170,7 @@ enum reg_class\n   \"VRSAVE_REGS\",\t\t\t\t\t\t\t\\\n   \"VSCR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"GEN_OR_FLOAT_REGS\",\t\t\t\t\t\t\t\\\n+  \"GEN_OR_VSX_REGS\",\t\t\t\t\t\t\t\\\n   \"LINK_REGS\",\t\t\t\t\t\t\t\t\\\n   \"CTR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"LINK_OR_CTR_REGS\",\t\t\t\t\t\t\t\\\n@@ -1205,6 +1207,8 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000000, 0x00002000 },\t\t\t\\\n   /* GEN_OR_FLOAT_REGS.  */\t\t\t\t\t\t\\\n   { 0xffffffff, 0xffffffff, 0x00000000, 0x00004008 },\t\t\t\\\n+  /* GEN_OR_VSX_REGS.  */\t\t\t\t\t\t\\\n+  { 0xffffffff, 0xffffffff, 0xffffffff, 0x00004008 },\t\t\t\\\n   /* LINK_REGS.  */\t\t\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000001 },\t\t\t\\\n   /* CTR_REGS.  */\t\t\t\t\t\t\t\\"}, {"sha": "8da7aba408048ce5cc6ebe7c3754ea7830dd24a7", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d70cd2719815d9ea853314775ae5787648ece5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d70cd2719815d9ea853314775ae5787648ece5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=20d70cd2719815d9ea853314775ae5787648ece5", "patch": "@@ -6830,10 +6830,10 @@\n ;;\t\tMF%1         MT%0         NOP\n (define_insn \"*movsi_internal1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\"=r,         r,           r,           ?*wI,        ?*wH,\n-\t\t m,          ?Z,          ?Z,          r,           r,\n-\t\t r,          ?*wIwH,      ?*wJwK,      ?*wJwK,      ?*wu,\n-\t\t ?*wJwK,     ?*wH,        ?*wK,        ?*wIwH,      ?r,\n+\t\t\"=r,         r,           r,           wI,          wH,\n+\t\t m,          Z,           Z,           r,           r,\n+\t\t r,          wIwH,        wJwK,        wJwK,        wu,\n+\t\t wJwK,       wH,          wK,          wIwH,        r,\n \t\t r,          *h,          *h\")\n \n \t(match_operand:SI 1 \"input_operand\"\n@@ -7104,13 +7104,13 @@\n ;;\t\tMTVSRWZ     MF%1       MT%1       NOP\n (define_insn \"*mov<mode>_internal\"\n   [(set (match_operand:QHI 0 \"nonimmediate_operand\"\n-\t\t\"=r,        r,         ?*wJwK,    m,         Z,         r,\n-\t\t ?*wJwK,    ?*wJwK,    ?*wJwK,    ?*wK,      ?*wK,      r,\n-\t\t ?*wJwK,    r,         *c*l,      *h\")\n+\t\t\"=r,        r,         wJwK,      m,         Z,         r,\n+\t\t wJwK,      wJwK,      wJwK,      wK,        ?wK,       r,\n+\t\t wJwK,      r,         *c*l,      *h\")\n \n \t(match_operand:QHI 1 \"input_operand\"\n \t\t\"r,         m,         Z,         r,         wJwK,      i,\n-\t\t wJwK,      O,         wM,        wB,        wS,        ?*wJwK,\n+\t\t wJwK,      O,         wM,        wB,        wS,        wJwK,\n \t\t r,         *h,        r,         0\"))]\n \n   \"gpc_reg_operand (operands[0], <MODE>mode)\n@@ -8671,8 +8671,8 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n          \"=Y,        r,         r,         m,         ^d,        ^d,\n           r,         wY,        Z,         ^wb,       $wv,       ^wi,\n-          *wo,       *wo,       *wv,       *wi,       *wi,       *wv,\n-          *wv\")\n+          wo,        wo,        wv,        wi,        *i,        wv,\n+          wv\")\n \n \t(match_operand:DI 1 \"input_operand\"\n          \"r,         Y,         r,         ^d,        m,         ^d,\n@@ -8751,9 +8751,9 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n                \"=YZ,       r,         r,         r,         r,          r,\n                 m,         ^d,        ^d,        wY,        Z,          $wb,\n-                $wv,       ^wi,       *wo,       *wo,       *wv,        *wi,\n-                *wi,       *wv,       *wv,       r,         *h,         *h,\n-                ?*r,       ?*wg,      ?*r,       ?*wj\")\n+                $wv,       ^wi,       wo,        wo,        wv,         wi,\n+                wi,        wv,        wv,        r,         *h,         *h,\n+                ?r,        ?wg,       ?r,        ?wj\")\n \n \t(match_operand:DI 1 \"input_operand\"\n                \"r,         YZ,        r,         I,         L,          nF,"}, {"sha": "80434d102474b4dcb192abf80a1b35ab8f17b882", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d70cd2719815d9ea853314775ae5787648ece5/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d70cd2719815d9ea853314775ae5787648ece5/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=20d70cd2719815d9ea853314775ae5787648ece5", "patch": "@@ -4106,7 +4106,7 @@\n })\n \n (define_insn \"vsx_splat_<mode>_reg\"\n-  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=<VSX_D:VSa>,?we\")\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=<VSX_D:VSa>,we\")\n \t(vec_duplicate:VSX_D\n \t (match_operand:<VS_scalar> 1 \"gpc_reg_operand\" \"<VSX_D:VS_64reg>,b\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\""}]}