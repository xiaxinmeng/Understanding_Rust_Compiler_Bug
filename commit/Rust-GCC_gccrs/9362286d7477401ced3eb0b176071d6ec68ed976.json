{"sha": "9362286d7477401ced3eb0b176071d6ec68ed976", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM2MjI4NmQ3NDc3NDAxY2VkM2ViMGIxNzYwNzFkNmVjNjhlZDk3Ng==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-07-22T21:54:27Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-07-22T21:54:27Z"}, "message": "alias.c (true_dependence_1): New function, merged version of true_dependence and canon_true_dependence.\n\n\t* alias.c (true_dependence_1): New function, merged version of\n\ttrue_dependence and canon_true_dependence.\n\t(true_dependence): Simplify.\n\t(canon_true_dependence): Simplify.\n\nFrom-SVN: r162430", "tree": {"sha": "f3163fbca6d296f50350ec0cbb9ba4959a37b15d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3163fbca6d296f50350ec0cbb9ba4959a37b15d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9362286d7477401ced3eb0b176071d6ec68ed976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9362286d7477401ced3eb0b176071d6ec68ed976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9362286d7477401ced3eb0b176071d6ec68ed976", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9362286d7477401ced3eb0b176071d6ec68ed976/comments", "author": null, "committer": null, "parents": [{"sha": "b78cb618ae222272b2569a31ab9e72e21c6b209a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78cb618ae222272b2569a31ab9e72e21c6b209a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b78cb618ae222272b2569a31ab9e72e21c6b209a"}], "stats": {"total": 143, "additions": 57, "deletions": 86}, "files": [{"sha": "1086c1fe0e2d12b104224173618add459d3afca5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9362286d7477401ced3eb0b176071d6ec68ed976/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9362286d7477401ced3eb0b176071d6ec68ed976/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9362286d7477401ced3eb0b176071d6ec68ed976", "patch": "@@ -1,3 +1,10 @@\n+2010-07-22  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* alias.c (true_dependence_1): New function, merged version of\n+\ttrue_dependence and canon_true_dependence.\n+\t(true_dependence): Simplify.\n+\t(canon_true_dependence): Simplify.\n+\n 2010-07-22  Richard Henderson  <rth@redhat.com>\n \n \tPR target/45027"}, {"sha": "dd846f3c99617c0d7e718e9e5d122eeae9998eac", "filename": "gcc/alias.c", "status": "modified", "additions": 50, "deletions": 86, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9362286d7477401ced3eb0b176071d6ec68ed976/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9362286d7477401ced3eb0b176071d6ec68ed976/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=9362286d7477401ced3eb0b176071d6ec68ed976", "patch": "@@ -2318,16 +2318,30 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y)\n   return sizex >= 0 && offsety >= offsetx + sizex;\n }\n \n-/* True dependence: X is read after store in MEM takes place.  */\n+/* Helper for true_dependence and canon_true_dependence.\n+   Checks for true dependence: X is read after store in MEM takes place.\n \n-int\n-true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n-\t\t bool (*varies) (const_rtx, bool))\n+   VARIES is the function that should be used as rtx_varies function.\n+\n+   If MEM_CANONICALIZED is FALSE, then X_ADDR and MEM_ADDR should be\n+   NULL_RTX, and the canonical addresses of MEM and X are both computed\n+   here.  If MEM_CANONICALIZED, then MEM must be already canonicalized.\n+\n+   If X_ADDR is non-NULL, it is used in preference of XEXP (x, 0).\n+\n+   Returns 1 if there is a true dependence, 0 otherwise.  */\n+\n+static int\n+true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n+\t\t   const_rtx x, rtx x_addr, bool (*varies) (const_rtx, bool),\n+\t\t   bool mem_canonicalized)\n {\n-  rtx x_addr, mem_addr;\n   rtx base;\n   int ret;\n \n+  gcc_checking_assert (mem_canonicalized ? (mem_addr != NULL_RTX)\n+\t\t       : (mem_addr == NULL_RTX && x_addr == NULL_RTX));\n+\n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n \n@@ -2353,11 +2367,16 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n     return 1;\n \n-  if (mem_mode == VOIDmode)\n-    mem_mode = GET_MODE (mem);\n+  if (! mem_addr)\n+    {\n+      mem_addr = XEXP (mem, 0);\n+      if (mem_mode == VOIDmode)\n+\tmem_mode = GET_MODE (mem);\n+    }\n+\n+  if (! x_addr)\n+    x_addr = XEXP (x, 0);\n \n-  x_addr = XEXP (x, 0);\n-  mem_addr = XEXP (mem, 0);\n   if (!((GET_CODE (x_addr) == VALUE\n \t && GET_CODE (mem_addr) != VALUE\n \t && reg_mentioned_p (x_addr, mem_addr))\n@@ -2366,7 +2385,8 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n \t    && reg_mentioned_p (mem_addr, x_addr))))\n     {\n       x_addr = get_addr (x_addr);\n-      mem_addr = get_addr (mem_addr);\n+      if (!mem_canonicalized)\n+\tmem_addr = get_addr (mem_addr);\n     }\n \n   base = find_base_term (x_addr);\n@@ -2379,7 +2399,8 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n     return 0;\n \n   x_addr = canon_rtx (x_addr);\n-  mem_addr = canon_rtx (mem_addr);\n+  if (!mem_canonicalized)\n+    mem_addr = canon_rtx (mem_addr);\n \n   if ((ret = memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n \t\t\t\t SIZE_FOR_MODE (x), x_addr, 0)) != -1)\n@@ -2395,11 +2416,11 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n     return 1;\n \n   /* We cannot use aliases_everything_p to test MEM, since we must look\n-     at MEM_MODE, rather than GET_MODE (MEM).  */\n+     at MEM_ADDR, rather than XEXP (mem, 0).  */\n   if (mem_mode == QImode || GET_CODE (mem_addr) == AND)\n     return 1;\n \n-  /* In true_dependence we also allow BLKmode to alias anything.  Why\n+  /* ??? In true_dependence we also allow BLKmode to alias anything.  Why\n      don't we do this in anti_dependence and output_dependence?  */\n   if (mem_mode == BLKmode || GET_MODE (x) == BLKmode)\n     return 1;\n@@ -2410,87 +2431,30 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n   return rtx_refs_may_alias_p (x, mem, true);\n }\n \n+/* True dependence: X is read after store in MEM takes place.  */\n+\n+int\n+true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n+\t\t bool (*varies) (const_rtx, bool))\n+{\n+  return true_dependence_1 (mem, mem_mode, NULL_RTX,\n+\t\t\t    x, NULL_RTX, varies,\n+\t\t\t    /*mem_canonicalized=*/false);\n+}\n+\n /* Canonical true dependence: X is read after store in MEM takes place.\n    Variant of true_dependence which assumes MEM has already been\n    canonicalized (hence we no longer do that here).\n-   The mem_addr argument has been added, since true_dependence computed\n-   this value prior to canonicalizing.\n-   If x_addr is non-NULL, it is used in preference of XEXP (x, 0).  */\n+   The mem_addr argument has been added, since true_dependence_1 computed\n+   this value prior to canonicalizing.  */\n \n int\n canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n \t\t       const_rtx x, rtx x_addr, bool (*varies) (const_rtx, bool))\n {\n-  int ret;\n-\n-  if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n-    return 1;\n-\n-  /* (mem:BLK (scratch)) is a special mechanism to conflict with everything.\n-     This is used in epilogue deallocation functions.  */\n-  if (GET_MODE (x) == BLKmode && GET_CODE (XEXP (x, 0)) == SCRATCH)\n-    return 1;\n-  if (GET_MODE (mem) == BLKmode && GET_CODE (XEXP (mem, 0)) == SCRATCH)\n-    return 1;\n-  if (MEM_ALIAS_SET (x) == ALIAS_SET_MEMORY_BARRIER\n-      || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)\n-    return 1;\n-\n-  /* Read-only memory is by definition never modified, and therefore can't\n-     conflict with anything.  We don't expect to find read-only set on MEM,\n-     but stupid user tricks can produce them, so don't die.  */\n-  if (MEM_READONLY_P (x))\n-    return 0;\n-\n-  /* If we have MEMs refering to different address spaces (which can\n-     potentially overlap), we cannot easily tell from the addresses\n-     whether the references overlap.  */\n-  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n-    return 1;\n-\n-  if (! x_addr)\n-    {\n-      x_addr = XEXP (x, 0);\n-      if (!((GET_CODE (x_addr) == VALUE\n-\t     && GET_CODE (mem_addr) != VALUE\n-\t     && reg_mentioned_p (x_addr, mem_addr))\n-\t    || (GET_CODE (x_addr) != VALUE\n-\t\t&& GET_CODE (mem_addr) == VALUE\n-\t\t&& reg_mentioned_p (mem_addr, x_addr))))\n-\tx_addr = get_addr (x_addr);\n-    }\n-\n-  if (! base_alias_check (x_addr, mem_addr, GET_MODE (x), mem_mode))\n-    return 0;\n-\n-  x_addr = canon_rtx (x_addr);\n-  if ((ret = memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n-\t\t\t\t SIZE_FOR_MODE (x), x_addr, 0)) != -1)\n-    return ret;\n-\n-  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n-    return 0;\n-\n-  if (nonoverlapping_memrefs_p (x, mem))\n-    return 0;\n-\n-  if (aliases_everything_p (x))\n-    return 1;\n-\n-  /* We cannot use aliases_everything_p to test MEM, since we must look\n-     at MEM_MODE, rather than GET_MODE (MEM).  */\n-  if (mem_mode == QImode || GET_CODE (mem_addr) == AND)\n-    return 1;\n-\n-  /* In true_dependence we also allow BLKmode to alias anything.  Why\n-     don't we do this in anti_dependence and output_dependence?  */\n-  if (mem_mode == BLKmode || GET_MODE (x) == BLKmode)\n-    return 1;\n-\n-  if (fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr, varies))\n-    return 0;\n-\n-  return rtx_refs_may_alias_p (x, mem, true);\n+  return true_dependence_1 (mem, mem_mode, mem_addr,\n+\t\t\t    x, x_addr, varies,\n+\t\t\t    /*mem_canonicalized=*/true);\n }\n \n /* Returns nonzero if a write to X might alias a previous read from"}]}