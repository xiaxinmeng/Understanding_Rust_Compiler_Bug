{"sha": "04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRmOTJmZjRmY2IwZjFmZDQ2YjJjY2E2NWVhMDRmODk2YWQ3ODNmMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-08-10T14:19:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-08-10T14:19:09Z"}, "message": "Makefile.in (OBJS): Remove matrix-reorg.o.\n\n2012-08-10  Richard Guenther  <rguenther@suse.de>\n\n\t* Makefile.in (OBJS): Remove matrix-reorg.o.\n\t(matrix-reorg.o): Remove dependence rule.\n\t(GTFILES): Remove matrix-reorg.c.\n\t* matrix-reorg.c: Remove.\n\t* passes.c (init_optimization_passes): Do not schedule\n\tpass_ipa_matrix_reorg.\n\t* tree-pass.h (pass_ipa_matrix_reorg): Remove.\n\t* common.opt (fipa-matrix-reorg): Stub out.\n\t* doc/invoke.texi (fipa-matrix-reorg): Remove documentation.\n\n\t* gcc.dg/matrix/*.c: Adjust and move ...\n\t* gcc.dg/torture/: ... here.\n\t* gcc.dg/matrix: Remove directory.\n\nFrom-SVN: r190298", "tree": {"sha": "7000f8a8ed0b24b0c42339f1de301bd16d4340e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7000f8a8ed0b24b0c42339f1de301bd16d4340e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "09e4850d7e5ab207bf04c389c80ff9bc548f8298", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e4850d7e5ab207bf04c389c80ff9bc548f8298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09e4850d7e5ab207bf04c389c80ff9bc548f8298"}], "stats": {"total": 2560, "additions": 46, "deletions": 2514}, "files": [{"sha": "0ba7d42cf251a58926d9b68005f71fed57593876", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,3 +1,15 @@\n+2012-08-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* Makefile.in (OBJS): Remove matrix-reorg.o.\n+\t(matrix-reorg.o): Remove dependence rule.\n+\t(GTFILES): Remove matrix-reorg.c.\n+\t* matrix-reorg.c: Remove.\n+\t* passes.c (init_optimization_passes): Do not schedule\n+\tpass_ipa_matrix_reorg.\n+\t* tree-pass.h (pass_ipa_matrix_reorg): Remove.\n+\t* common.opt (fipa-matrix-reorg): Stub out.\n+\t* doc/invoke.texi (fipa-matrix-reorg): Remove documentation.\n+\n 2012-08-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/54219"}, {"sha": "ba0287f38cecd40e36a11f6e89e4bfc414be1f9a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1301,7 +1301,6 @@ OBJS = \\\n \tlto-symtab.o \\\n \tlto-opts.o \\\n \tlto-compress.o \\\n-\tmatrix-reorg.o \\\n \tmcf.o \\\n \tmode-switching.o \\\n \tmodulo-sched.o \\\n@@ -2893,13 +2892,6 @@ ipa-split.o : ipa-split.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TREE_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \\\n    $(TREE_PASS_H) $(FLAGS_H) $(DIAGNOSTIC_H) $(TREE_DUMP_H) \\\n    $(TREE_INLINE_H) $(PARAMS_H) $(GIMPLE_PRETTY_PRINT_H) ipa-inline.h\n-matrix-reorg.o : matrix-reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n-   $(TM_H) $(TREE_H) $(RTL_H) $(TREE_INLINE_H) $(TREE_FLOW_H) \\\n-   tree-flow-inline.h langhooks.h $(HASHTAB_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) \\\n-   debug.h $(TARGET_H) $(CGRAPH_H) $(DIAGNOSTIC_CORE_H) \\\n-   $(PARAMS_H) intl.h $(FUNCTION_H) $(BASIC_BLOCK_H) \\\n-   $(CFGLOOP_H) tree-iterator.h $(TREE_PASS_H) $(OPTS_H) $(TREE_DATA_REF_H) \\\n-   tree-ssa-sccvn.h\n ipa-inline.o : ipa-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TREE_PASS_H) \\\n@@ -3657,7 +3649,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/ipa-ref.h $(srcdir)/cgraph.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c $(srcdir)/symtab.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n-  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/matrix-reorg.c \\\n+  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c \\\n   $(srcdir)/dbxout.c \\\n   $(srcdir)/dwarf2out.h \\\n   $(srcdir)/dwarf2asm.c \\"}, {"sha": "deb89e32e39300fc26d1854437a0a78cc822c593", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1349,9 +1349,8 @@ Common Report Var(flag_ipa_reference) Init(0) Optimization\n Discover readonly and non addressable static variables\n \n fipa-matrix-reorg\n-Common Report Var(flag_ipa_matrix_reorg) Optimization\n-Perform matrix layout flattening and transposing based\n-on profiling information.\n+Common Ignore\n+Does nothing. Preserved for backward compatibility.\n \n fipa-struct-reorg\n Common Ignore"}, {"sha": "f0d8a4a863f7c8381d3af26154b974e1eb28fb25", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -367,7 +367,7 @@ Objective-C and Objective-C++ Dialects}.\n -fgcse-sm -fhoist-adjacent-loads -fif-conversion @gol\n -fif-conversion2 -findirect-inlining @gol\n -finline-functions -finline-functions-called-once -finline-limit=@var{n} @gol\n--finline-small-functions -fipa-cp -fipa-cp-clone -fipa-matrix-reorg @gol\n+-finline-small-functions -fipa-cp -fipa-cp-clone @gol\n -fipa-pta -fipa-profile -fipa-pure-const -fipa-reference @gol\n -fira-algorithm=@var{algorithm} @gol\n -fira-region=@var{region} @gol\n@@ -7195,18 +7195,6 @@ it may significantly increase code size\n (see @option{--param ipcp-unit-growth=@var{value}}).\n This flag is enabled by default at @option{-O3}.\n \n-@item -fipa-matrix-reorg\n-@opindex fipa-matrix-reorg\n-Perform matrix flattening and transposing.\n-Matrix flattening tries to replace an @math{m}-dimensional matrix\n-with its equivalent @math{n}-dimensional matrix, where @math{n < m}.\n-This reduces the level of indirection needed for accessing the elements\n-of the matrix. The second optimization is matrix transposing, which\n-attempts to change the order of the matrix's dimensions in order to\n-improve cache locality.\n-Both optimizations need the @option{-fwhole-program} flag.\n-Transposing is enabled only if profiling information is available.\n-\n @item -ftree-sink\n @opindex ftree-sink\n Perform forward store motion  on trees.  This flag is"}, {"sha": "6fe561369606ee2309d7773f8d1f09460ebd8233", "filename": "gcc/matrix-reorg.c", "status": "removed", "additions": 0, "deletions": 2384, "changes": 2384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e4850d7e5ab207bf04c389c80ff9bc548f8298/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e4850d7e5ab207bf04c389c80ff9bc548f8298/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=09e4850d7e5ab207bf04c389c80ff9bc548f8298", "patch": "@@ -1,2384 +0,0 @@\n-/* Matrix layout transformations.\n-   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by Razya Ladelsky <razya@il.ibm.com>\n-   Originally written by Revital Eres and Mustafa Hagog.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/*\n-   Matrix flattening optimization tries to replace a N-dimensional\n-   matrix with its equivalent M-dimensional matrix, where M < N.\n-   This first implementation focuses on global matrices defined dynamically.\n-\n-   When N==1, we actually flatten the whole matrix.\n-   For instance consider a two-dimensional array a [dim1] [dim2].\n-   The code for allocating space for it usually looks like:\n-\n-     a = (int **)  malloc(dim1 * sizeof(int *));\n-     for (i=0; i<dim1; i++)\n-        a[i] = (int *) malloc (dim2 * sizeof(int));\n-\n-   If the array \"a\" is found suitable for this optimization,\n-   its allocation is replaced by:\n-\n-     a = (int *) malloc (dim1 * dim2 *sizeof(int));\n-\n-   and all the references to a[i][j] are replaced by a[i * dim2 + j].\n-\n-   The two main phases of the optimization are the analysis\n-   and transformation.\n-   The driver of the optimization is matrix_reorg ().\n-\n-\n-\n-   Analysis phase:\n-   ===============\n-\n-   We'll number the dimensions outside-in, meaning the most external\n-   is 0, then 1, and so on.\n-   The analysis part of the optimization determines K, the escape\n-   level of a N-dimensional matrix (K <= N), that allows flattening of\n-   the external dimensions 0,1,..., K-1. Escape level 0 means that the\n-   whole matrix escapes and no flattening is possible.\n-\n-   The analysis part is implemented in analyze_matrix_allocation_site()\n-   and analyze_matrix_accesses().\n-\n-   Transformation phase:\n-   =====================\n-   In this phase we define the new flattened matrices that replace the\n-   original matrices in the code.\n-   Implemented in transform_allocation_sites(),\n-   transform_access_sites().\n-\n-   Matrix Transposing\n-   ==================\n-   The idea of Matrix Transposing is organizing the matrix in a different\n-   layout such that the dimensions are reordered.\n-   This could produce better cache behavior in some cases.\n-\n-   For example, lets look at the matrix accesses in the following loop:\n-\n-   for (i=0; i<N; i++)\n-    for (j=0; j<M; j++)\n-     access to a[i][j]\n-\n-   This loop can produce good cache behavior because the elements of\n-   the inner dimension are accessed sequentially.\n-\n-  However, if the accesses of the matrix were of the following form:\n-\n-  for (i=0; i<N; i++)\n-   for (j=0; j<M; j++)\n-     access to a[j][i]\n-\n-  In this loop we iterate the columns and not the rows.\n-  Therefore, replacing the rows and columns\n-  would have had an organization with better (cache) locality.\n-  Replacing the dimensions of the matrix is called matrix transposing.\n-\n-  This  example, of course, could be enhanced to multiple dimensions matrices\n-  as well.\n-\n-  Since a program could include all kind of accesses, there is a decision\n-  mechanism, implemented in analyze_transpose(), which implements a\n-  heuristic that tries to determine whether to transpose the matrix or not,\n-  according to the form of the more dominant accesses.\n-  This decision is transferred to the flattening mechanism, and whether\n-  the matrix was transposed or not, the matrix is flattened (if possible).\n-\n-  This decision making is based on profiling information and loop information.\n-  If profiling information is available, decision making mechanism will be\n-  operated, otherwise the matrix will only be flattened (if possible).\n-\n-  Both optimizations are described in the paper \"Matrix flattening and\n-  transposing in GCC\" which was presented in GCC summit 2006.\n-  http://www.gccsummit.org/2006/2006-GCC-Summit-Proceedings.pdf.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"tree-inline.h\"\n-#include \"tree-flow.h\"\n-#include \"tree-flow-inline.h\"\n-#include \"langhooks.h\"\n-#include \"hashtab.h\"\n-#include \"flags.h\"\n-#include \"ggc.h\"\n-#include \"debug.h\"\n-#include \"target.h\"\n-#include \"cgraph.h\"\n-#include \"diagnostic-core.h\"\n-#include \"params.h\"\n-#include \"intl.h\"\n-#include \"function.h\"\n-#include \"basic-block.h\"\n-#include \"cfgloop.h\"\n-#include \"tree-iterator.h\"\n-#include \"tree-pass.h\"\n-#include \"opts.h\"\n-#include \"tree-data-ref.h\"\n-#include \"tree-chrec.h\"\n-#include \"tree-scalar-evolution.h\"\n-#include \"tree-ssa-sccvn.h\"\n-\n-/* We need to collect a lot of data from the original malloc,\n-   particularly as the gimplifier has converted:\n-\n-   orig_var = (struct_type *) malloc (x * sizeof (struct_type *));\n-\n-   into\n-\n-   T3 = <constant> ;  ** <constant> is amount to malloc; precomputed **\n-   T4 = malloc (T3);\n-   T5 = (struct_type *) T4;\n-   orig_var = T5;\n-\n-   The following struct fields allow us to collect all the necessary data from\n-   the gimplified program.  The comments in the struct below are all based\n-   on the gimple example above.  */\n-\n-struct malloc_call_data\n-{\n-  gimple call_stmt;\t\t/* Tree for \"T4 = malloc (T3);\"                     */\n-  tree size_var;\t\t/* Var decl for T3.                                 */\n-  tree malloc_size;\t\t/* Tree for \"<constant>\", the rhs assigned to T3.   */\n-};\n-\n-static tree can_calculate_expr_before_stmt (tree, sbitmap);\n-static tree can_calculate_stmt_before_stmt (gimple, sbitmap);\n-\n-/* The front end of the compiler, when parsing statements of the form:\n-\n-   var = (type_cast) malloc (sizeof (type));\n-\n-   always converts this single statement into the following statements\n-   (GIMPLE form):\n-\n-   T.1 = sizeof (type);\n-   T.2 = malloc (T.1);\n-   T.3 = (type_cast) T.2;\n-   var = T.3;\n-\n-   Since we need to create new malloc statements and modify the original\n-   statements somewhat, we need to find all four of the above statements.\n-   Currently record_call_1 (called for building cgraph edges) finds and\n-   records the statements containing the actual call to malloc, but we\n-   need to find the rest of the variables/statements on our own.  That\n-   is what the following function does.  */\n-static void\n-collect_data_for_malloc_call (gimple stmt, struct malloc_call_data *m_data)\n-{\n-  tree size_var = NULL;\n-  tree malloc_fn_decl;\n-  tree arg1;\n-\n-  gcc_assert (is_gimple_call (stmt));\n-\n-  malloc_fn_decl = gimple_call_fndecl (stmt);\n-  if (malloc_fn_decl == NULL\n-      || DECL_FUNCTION_CODE (malloc_fn_decl) != BUILT_IN_MALLOC)\n-    return;\n-\n-  arg1 = gimple_call_arg (stmt, 0);\n-  size_var = arg1;\n-\n-  m_data->call_stmt = stmt;\n-  m_data->size_var = size_var;\n-  if (TREE_CODE (size_var) != VAR_DECL)\n-    m_data->malloc_size = size_var;\n-  else\n-    m_data->malloc_size = NULL_TREE;\n-}\n-\n-/* Information about matrix access site.\n-   For example: if an access site of matrix arr is arr[i][j]\n-   the ACCESS_SITE_INFO structure will have the address\n-   of arr as its stmt.  The INDEX_INFO will hold information about the\n-   initial address and index of each dimension.  */\n-struct access_site_info\n-{\n-  /* The statement (MEM_REF or POINTER_PLUS_EXPR).  */\n-  gimple stmt;\n-\n-  /* In case of POINTER_PLUS_EXPR, what is the offset.  */\n-  tree offset;\n-\n-  /* The index which created the offset.  */\n-  tree index;\n-\n-  /* The indirection level of this statement.  */\n-  int level;\n-\n-  /* TRUE for allocation site FALSE for access site.  */\n-  bool is_alloc;\n-\n-  /* The function containing the access site.  */\n-  tree function_decl;\n-\n-  /* This access is iterated in the inner most loop */\n-  bool iterated_by_inner_most_loop_p;\n-};\n-\n-typedef struct access_site_info *access_site_info_p;\n-DEF_VEC_P (access_site_info_p);\n-DEF_VEC_ALLOC_P (access_site_info_p, heap);\n-\n-/* Calls to free when flattening a matrix.  */\n-\n-struct free_info\n-{\n-  gimple stmt;\n-  tree func;\n-};\n-\n-/* Information about matrix to flatten.  */\n-struct matrix_info\n-{\n-  /* Decl tree of this matrix.  */\n-  tree decl;\n-  /* Number of dimensions; number\n-     of \"*\" in the type declaration.  */\n-  int num_dims;\n-\n-  /* Minimum indirection level that escapes, 0 means that\n-     the whole matrix escapes, k means that dimensions\n-     0 to ACTUAL_DIM - k escapes.  */\n-  int min_indirect_level_escape;\n-\n-  gimple min_indirect_level_escape_stmt;\n-\n-  /* Hold the allocation site for each level (dimension).\n-     We can use NUM_DIMS as the upper bound and allocate the array\n-     once with this number of elements and no need to use realloc and\n-     MAX_MALLOCED_LEVEL.  */\n-  gimple *malloc_for_level;\n-\n-  int max_malloced_level;\n-\n-  /* Is the matrix transposed.  */\n-  bool is_transposed_p;\n-\n-  /* The location of the allocation sites (they must be in one\n-     function).  */\n-  tree allocation_function_decl;\n-\n-  /* The calls to free for each level of indirection.  */\n-  struct free_info *free_stmts;\n-\n-  /* An array which holds for each dimension its size. where\n-     dimension 0 is the outer most (one that contains all the others).\n-   */\n-  tree *dimension_size;\n-\n-  /* An array which holds for each dimension it's original size\n-     (before transposing and flattening take place).  */\n-  tree *dimension_size_orig;\n-\n-  /* An array which holds for each dimension the size of the type of\n-     of elements accessed in that level (in bytes).  */\n-  HOST_WIDE_INT *dimension_type_size;\n-\n-  int dimension_type_size_len;\n-\n-  /* An array collecting the count of accesses for each dimension.  */\n-  gcov_type *dim_hot_level;\n-\n-  /* An array of the accesses to be flattened.\n-     elements are of type \"struct access_site_info *\".  */\n-  VEC (access_site_info_p, heap) * access_l;\n-\n-  /* A map of how the dimensions will be organized at the end of\n-     the analyses.  */\n-  int *dim_map;\n-};\n-\n-/* In each phi node we want to record the indirection level we have when we\n-   get to the phi node.  Usually we will have phi nodes with more than two\n-   arguments, then we must assure that all of them get to the phi node with\n-   the same indirection level, otherwise it's not safe to do the flattening.\n-   So we record the information regarding the indirection level each time we\n-   get to the phi node in this hash table.  */\n-\n-struct matrix_access_phi_node\n-{\n-  gimple phi;\n-  int indirection_level;\n-};\n-\n-/* We use this structure to find if the SSA variable is accessed inside the\n-   tree and record the tree containing it.  */\n-\n-struct ssa_acc_in_tree\n-{\n-  /* The variable whose accesses in the tree we are looking for.  */\n-  tree ssa_var;\n-  /* The tree and code inside it the ssa_var is accessed, currently\n-     it could be an MEM_REF or CALL_EXPR.  */\n-  enum tree_code t_code;\n-  tree t_tree;\n-  /* The place in the containing tree.  */\n-  tree *tp;\n-  tree second_op;\n-  bool var_found;\n-};\n-\n-static void analyze_matrix_accesses (struct matrix_info *, tree, int, bool,\n-\t\t\t\t     sbitmap, bool);\n-static int transform_allocation_sites (void **, void *);\n-static int transform_access_sites (void **, void *);\n-static int analyze_transpose (void **, void *);\n-static int dump_matrix_reorg_analysis (void **, void *);\n-\n-static bool check_transpose_p;\n-\n-/* Hash function used for the phi nodes.  */\n-\n-static hashval_t\n-mat_acc_phi_hash (const void *p)\n-{\n-  const struct matrix_access_phi_node *const ma_phi =\n-    (const struct matrix_access_phi_node *) p;\n-\n-  return htab_hash_pointer (ma_phi->phi);\n-}\n-\n-/* Equality means phi node pointers are the same.  */\n-\n-static int\n-mat_acc_phi_eq (const void *p1, const void *p2)\n-{\n-  const struct matrix_access_phi_node *const phi1 =\n-    (const struct matrix_access_phi_node *) p1;\n-  const struct matrix_access_phi_node *const phi2 =\n-    (const struct matrix_access_phi_node *) p2;\n-\n-  if (phi1->phi == phi2->phi)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Hold the PHI nodes we visit during the traversal for escaping\n-   analysis.  */\n-static htab_t htab_mat_acc_phi_nodes = NULL;\n-\n-/* This hash-table holds the information about the matrices we are\n-   going to handle.  */\n-static htab_t matrices_to_reorg = NULL;\n-\n-/* Return a hash for MTT, which is really a \"matrix_info *\".  */\n-static hashval_t\n-mtt_info_hash (const void *mtt)\n-{\n-  return htab_hash_pointer (((const struct matrix_info *) mtt)->decl);\n-}\n-\n-/* Return true if MTT1 and MTT2 (which are really both of type\n-   \"matrix_info *\") refer to the same decl.  */\n-static int\n-mtt_info_eq (const void *mtt1, const void *mtt2)\n-{\n-  const struct matrix_info *const i1 = (const struct matrix_info *) mtt1;\n-  const struct matrix_info *const i2 = (const struct matrix_info *) mtt2;\n-\n-  if (i1->decl == i2->decl)\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Return false if STMT may contain a vector expression.\n-   In this situation, all matrices should not be flattened.  */\n-static bool\n-may_flatten_matrices_1 (gimple stmt)\n-{\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_ASSIGN:\n-    case GIMPLE_CALL:\n-      if (!gimple_has_lhs (stmt))\n-\treturn true;\n-      if (TREE_CODE (TREE_TYPE (gimple_get_lhs (stmt))) == VECTOR_TYPE)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Found vector type, don't flatten matrix\\n\");\n-\t  return false;\n-\t}\n-      break;\n-    case GIMPLE_ASM:\n-      /* Asm code could contain vector operations.  */\n-      return false;\n-      break;\n-    default:\n-      break;\n-    }\n-  return true;\n-}\n-\n-/* Return false if there are hand-written vectors in the program.\n-   We disable the flattening in such a case.  */\n-static bool\n-may_flatten_matrices (struct cgraph_node *node)\n-{\n-  tree decl;\n-  struct function *func;\n-  basic_block bb;\n-  gimple_stmt_iterator gsi;\n-\n-  decl = node->symbol.decl;\n-  if (node->analyzed)\n-    {\n-      func = DECL_STRUCT_FUNCTION (decl);\n-      FOR_EACH_BB_FN (bb, func)\n-\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\tif (!may_flatten_matrices_1 (gsi_stmt (gsi)))\n-\t  return false;\n-    }\n-  return true;\n-}\n-\n-/* Given a VAR_DECL, check its type to determine whether it is\n-   a definition of a dynamic allocated matrix and therefore is\n-   a suitable candidate for the matrix flattening optimization.\n-   Return NULL if VAR_DECL is not such decl.  Otherwise, allocate\n-   a MATRIX_INFO structure, fill it with the relevant information\n-   and return a pointer to it.\n-   TODO: handle also statically defined arrays.  */\n-static struct matrix_info *\n-analyze_matrix_decl (tree var_decl)\n-{\n-  struct matrix_info *m_node, tmpmi, *mi;\n-  tree var_type;\n-  int dim_num = 0;\n-\n-  gcc_assert (matrices_to_reorg);\n-\n-  if (TREE_CODE (var_decl) == PARM_DECL)\n-    var_type = DECL_ARG_TYPE (var_decl);\n-  else if (TREE_CODE (var_decl) == VAR_DECL)\n-    var_type = TREE_TYPE (var_decl);\n-  else\n-    return NULL;\n-\n-  if (!POINTER_TYPE_P (var_type))\n-    return NULL;\n-\n-  while (POINTER_TYPE_P (var_type))\n-    {\n-      var_type = TREE_TYPE (var_type);\n-      dim_num++;\n-    }\n-\n-  if (dim_num <= 1)\n-    return NULL;\n-\n-  if (!COMPLETE_TYPE_P (var_type)\n-      || TREE_CODE (TYPE_SIZE_UNIT (var_type)) != INTEGER_CST)\n-    return NULL;\n-\n-  /* Check to see if this pointer is already in there.  */\n-  tmpmi.decl = var_decl;\n-  mi = (struct matrix_info *) htab_find (matrices_to_reorg, &tmpmi);\n-\n-  if (mi)\n-    return NULL;\n-\n-  /* Record the matrix.  */\n-\n-  m_node = (struct matrix_info *) xcalloc (1, sizeof (struct matrix_info));\n-  m_node->decl = var_decl;\n-  m_node->num_dims = dim_num;\n-  m_node->free_stmts\n-    = (struct free_info *) xcalloc (dim_num, sizeof (struct free_info));\n-\n-  /* Init min_indirect_level_escape to -1 to indicate that no escape\n-     analysis has been done yet.  */\n-  m_node->min_indirect_level_escape = -1;\n-  m_node->is_transposed_p = false;\n-\n-  return m_node;\n-}\n-\n-/* Free matrix E.  */\n-static void\n-mat_free (void *e)\n-{\n-  struct matrix_info *mat = (struct matrix_info *) e;\n-\n-  if (!mat)\n-    return;\n-\n-  free (mat->free_stmts);\n-  free (mat->dim_hot_level);\n-  free (mat->malloc_for_level);\n-}\n-\n-/* Find all potential matrices.\n-   TODO: currently we handle only multidimensional\n-   dynamically allocated arrays.  */\n-static void\n-find_matrices_decl (void)\n-{\n-  struct matrix_info *tmp;\n-  PTR *slot;\n-  struct varpool_node *vnode;\n-\n-  gcc_assert (matrices_to_reorg);\n-\n-  /* For every global variable in the program:\n-     Check to see if it's of a candidate type and record it.  */\n-  FOR_EACH_DEFINED_VARIABLE (vnode)\n-    {\n-      tree var_decl = vnode->symbol.decl;\n-\n-      if (!var_decl || TREE_CODE (var_decl) != VAR_DECL)\n-\tcontinue;\n-\n-      if (matrices_to_reorg)\n-\tif ((tmp = analyze_matrix_decl (var_decl)))\n-\t  {\n-\t    if (!TREE_ADDRESSABLE (var_decl))\n-\t      {\n-\t\tslot = htab_find_slot (matrices_to_reorg, tmp, INSERT);\n-\t\t*slot = tmp;\n-\t      }\n-\t  }\n-    }\n-  return;\n-}\n-\n-/* Mark that the matrix MI escapes at level L.  */\n-static void\n-mark_min_matrix_escape_level (struct matrix_info *mi, int l, gimple s)\n-{\n-  if (mi->min_indirect_level_escape == -1\n-      || (mi->min_indirect_level_escape > l))\n-    {\n-      mi->min_indirect_level_escape = l;\n-      mi->min_indirect_level_escape_stmt = s;\n-    }\n-}\n-\n-/* Find if the SSA variable is accessed inside the\n-   tree and record the tree containing it.\n-   The only relevant uses are the case of SSA_NAME, or SSA inside\n-   MEM_REF, PLUS_EXPR, POINTER_PLUS_EXPR, MULT_EXPR.  */\n-static void\n-ssa_accessed_in_tree (tree t, struct ssa_acc_in_tree *a)\n-{\n-  a->t_code = TREE_CODE (t);\n-  switch (a->t_code)\n-    {\n-    case SSA_NAME:\n-      if (t == a->ssa_var)\n-\ta->var_found = true;\n-      break;\n-    case MEM_REF:\n-      if (SSA_VAR_P (TREE_OPERAND (t, 0))\n-\t  && TREE_OPERAND (t, 0) == a->ssa_var)\n-\ta->var_found = true;\n-      break;\n-    default:\n-      break;\n-    }\n-}\n-\n-/* Find if the SSA variable is accessed on the right hand side of\n-   gimple call STMT. */\n-\n-static void\n-ssa_accessed_in_call_rhs (gimple stmt, struct ssa_acc_in_tree *a)\n-{\n-  tree decl;\n-  tree arg;\n-  size_t i;\n-\n-  a->t_code = CALL_EXPR;\n-  for (i = 0; i < gimple_call_num_args (stmt); i++)\n-    {\n-      arg = gimple_call_arg (stmt, i);\n-      if (arg == a->ssa_var)\n-\t{\n-\t  a->var_found = true;\n-\t  decl = gimple_call_fndecl (stmt);\n-\t  a->t_tree = decl;\n-\t  break;\n-\t}\n-    }\n-}\n-\n-/* Find if the SSA variable is accessed on the right hand side of\n-   gimple assign STMT. */\n-\n-static void\n-ssa_accessed_in_assign_rhs (gimple stmt, struct ssa_acc_in_tree *a)\n-{\n-\n-  a->t_code = gimple_assign_rhs_code (stmt);\n-  switch (a->t_code)\n-    {\n-      tree op1, op2;\n-\n-    case SSA_NAME:\n-    case MEM_REF:\n-    CASE_CONVERT:\n-    case VIEW_CONVERT_EXPR:\n-      ssa_accessed_in_tree (gimple_assign_rhs1 (stmt), a);\n-      break;\n-    case POINTER_PLUS_EXPR:\n-    case PLUS_EXPR:\n-    case MULT_EXPR:\n-      op1 = gimple_assign_rhs1 (stmt);\n-      op2 = gimple_assign_rhs2 (stmt);\n-\n-      if (op1 == a->ssa_var)\n-\t{\n-\t  a->var_found = true;\n-\t  a->second_op = op2;\n-\t}\n-      else if (op2 == a->ssa_var)\n-\t{\n-\t  a->var_found = true;\n-\t  a->second_op = op1;\n-\t}\n-      break;\n-    default:\n-      break;\n-    }\n-}\n-\n-/* Record the access/allocation site information for matrix MI so we can\n-   handle it later in transformation.  */\n-static void\n-record_access_alloc_site_info (struct matrix_info *mi, gimple stmt, tree offset,\n-\t\t\t       tree index, int level, bool is_alloc)\n-{\n-  struct access_site_info *acc_info;\n-\n-  if (!mi->access_l)\n-    mi->access_l = VEC_alloc (access_site_info_p, heap, 100);\n-\n-  acc_info\n-    = (struct access_site_info *)\n-    xcalloc (1, sizeof (struct access_site_info));\n-  acc_info->stmt = stmt;\n-  acc_info->offset = offset;\n-  acc_info->index = index;\n-  acc_info->function_decl = current_function_decl;\n-  acc_info->level = level;\n-  acc_info->is_alloc = is_alloc;\n-\n-  VEC_safe_push (access_site_info_p, heap, mi->access_l, acc_info);\n-\n-}\n-\n-/* Record the malloc as the allocation site of the given LEVEL.  But\n-   first we Make sure that all the size parameters passed to malloc in\n-   all the allocation sites could be pre-calculated before the call to\n-   the malloc of level 0 (the main malloc call).  */\n-static void\n-add_allocation_site (struct matrix_info *mi, gimple stmt, int level)\n-{\n-  struct malloc_call_data mcd;\n-\n-  /* Make sure that the allocation sites are in the same function.  */\n-  if (!mi->allocation_function_decl)\n-    mi->allocation_function_decl = current_function_decl;\n-  else if (mi->allocation_function_decl != current_function_decl)\n-    {\n-      int min_malloc_level;\n-\n-      gcc_assert (mi->malloc_for_level);\n-\n-      /* Find the minimum malloc level that already has been seen;\n-         we known its allocation function must be\n-         MI->allocation_function_decl since it's different than\n-         CURRENT_FUNCTION_DECL then the escaping level should be\n-         MIN (LEVEL, MIN_MALLOC_LEVEL) - 1 , and the allocation function\n-         must be set accordingly.  */\n-      for (min_malloc_level = 0;\n-\t   min_malloc_level < mi->max_malloced_level\n-\t   && mi->malloc_for_level[min_malloc_level]; min_malloc_level++)\n-\t;\n-      if (level < min_malloc_level)\n-\t{\n-\t  mi->allocation_function_decl = current_function_decl;\n-\t  mark_min_matrix_escape_level (mi, min_malloc_level, stmt);\n-\t}\n-      else\n-\t{\n-\t  mark_min_matrix_escape_level (mi, level, stmt);\n-\t  /* cannot be that (level == min_malloc_level)\n-\t     we would have returned earlier.  */\n-\t  return;\n-\t}\n-    }\n-\n-  /* Find the correct malloc information.  */\n-  collect_data_for_malloc_call (stmt, &mcd);\n-\n-  /* We accept only calls to malloc function; we do not accept\n-     calls like calloc and realloc.  */\n-  if (!mi->malloc_for_level)\n-    {\n-      mi->malloc_for_level = XCNEWVEC (gimple, level + 1);\n-      mi->max_malloced_level = level + 1;\n-    }\n-  else if (mi->max_malloced_level <= level)\n-    {\n-      mi->malloc_for_level\n-\t= XRESIZEVEC (gimple, mi->malloc_for_level, level + 1);\n-\n-      /* Zero the newly allocated items.  */\n-      memset (&(mi->malloc_for_level[mi->max_malloced_level + 1]),\n-\t      0, (level - mi->max_malloced_level) * sizeof (tree));\n-\n-      mi->max_malloced_level = level + 1;\n-    }\n-  mi->malloc_for_level[level] = stmt;\n-}\n-\n-/* Given an assignment statement STMT that we know that its\n-   left-hand-side is the matrix MI variable, we traverse the immediate\n-   uses backwards until we get to a malloc site.  We make sure that\n-   there is one and only one malloc site that sets this variable.  When\n-   we are performing the flattening we generate a new variable that\n-   will hold the size for each dimension; each malloc that allocates a\n-   dimension has the size parameter; we use that parameter to\n-   initialize the dimension size variable so we can use it later in\n-   the address calculations.  LEVEL is the dimension we're inspecting.\n-   Return if STMT is related to an allocation site.  */\n-\n-static void\n-analyze_matrix_allocation_site (struct matrix_info *mi, gimple stmt,\n-\t\t\t\tint level, sbitmap visited)\n-{\n-  if (gimple_assign_copy_p (stmt) || gimple_assign_cast_p (stmt))\n-    {\n-      tree rhs = gimple_assign_rhs1 (stmt);\n-\n-      if (TREE_CODE (rhs) == SSA_NAME)\n-\t{\n-\t  gimple def = SSA_NAME_DEF_STMT (rhs);\n-\n-\t  analyze_matrix_allocation_site (mi, def, level, visited);\n-\t  return;\n-\t}\n-      /* If we are back to the original matrix variable then we\n-         are sure that this is analyzed as an access site.  */\n-      else if (rhs == mi->decl)\n-\treturn;\n-    }\n-  /* A result of call to malloc.  */\n-  else if (is_gimple_call (stmt))\n-    {\n-      int call_flags = gimple_call_flags (stmt);\n-\n-      if (!(call_flags & ECF_MALLOC))\n-\t{\n-\t  mark_min_matrix_escape_level (mi, level, stmt);\n-\t  return;\n-\t}\n-      else\n-\t{\n-\t  tree malloc_fn_decl;\n-\n-\t  malloc_fn_decl = gimple_call_fndecl (stmt);\n-\t  if (malloc_fn_decl == NULL_TREE)\n-\t    {\n-\t      mark_min_matrix_escape_level (mi, level, stmt);\n-\t      return;\n-\t    }\n-\t  if (DECL_FUNCTION_CODE (malloc_fn_decl) != BUILT_IN_MALLOC)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Matrix %s is an argument to function %s\\n\",\n-\t\t\t get_name (mi->decl), get_name (malloc_fn_decl));\n-\t      mark_min_matrix_escape_level (mi, level, stmt);\n-\t      return;\n-\t    }\n-\t}\n-      /* This is a call to malloc of level 'level'.\n-\t mi->max_malloced_level-1 == level  means that we've\n-\t seen a malloc statement of level 'level' before.\n-\t If the statement is not the same one that we've\n-\t seen before, then there's another malloc statement\n-\t for the same level, which means that we need to mark\n-\t it escaping.  */\n-      if (mi->malloc_for_level\n-\t  && mi->max_malloced_level-1 == level\n-\t  && mi->malloc_for_level[level] != stmt)\n-\t{\n-\t  mark_min_matrix_escape_level (mi, level, stmt);\n-\t  return;\n-\t}\n-      else\n-\tadd_allocation_site (mi, stmt, level);\n-      return;\n-    }\n-  /* Looks like we don't know what is happening in this\n-     statement so be in the safe side and mark it as escaping.  */\n-  mark_min_matrix_escape_level (mi, level, stmt);\n-}\n-\n-/* The transposing decision making.\n-   In order to calculate the profitability of transposing, we collect two\n-   types of information regarding the accesses:\n-   1. profiling information used to express the hotness of an access, that\n-   is how often the matrix is accessed by this access site (count of the\n-   access site).\n-   2. which dimension in the access site is iterated by the inner\n-   most loop containing this access.\n-\n-   The matrix will have a calculated value of weighted hotness for each\n-   dimension.\n-   Intuitively the hotness level of a dimension is a function of how\n-   many times it was the most frequently accessed dimension in the\n-   highly executed access sites of this matrix.\n-\n-   As computed by following equation:\n-   m      n\n-   __   __\n-   \\    \\  dim_hot_level[i] +=\n-   /_   /_\n-   j     i\n-                 acc[j]->dim[i]->iter_by_inner_loop * count(j)\n-\n-  Where n is the number of dims and m is the number of the matrix\n-  access sites. acc[j]->dim[i]->iter_by_inner_loop is 1 if acc[j]\n-  iterates over dim[i] in innermost loop, and is 0 otherwise.\n-\n-  The organization of the new matrix should be according to the\n-  hotness of each dimension. The hotness of the dimension implies\n-  the locality of the elements.*/\n-static int\n-analyze_transpose (void **slot, void *data ATTRIBUTE_UNUSED)\n-{\n-  struct matrix_info *mi = (struct matrix_info *) *slot;\n-  int min_escape_l = mi->min_indirect_level_escape;\n-  struct loop *loop;\n-  affine_iv iv;\n-  struct access_site_info *acc_info;\n-  int i;\n-\n-  if (min_escape_l < 2 || !mi->access_l)\n-    {\n-      if (mi->access_l)\n-\t{\n-\t  FOR_EACH_VEC_ELT (access_site_info_p, mi->access_l, i, acc_info)\n-\t    free (acc_info);\n-\t  VEC_free (access_site_info_p, heap, mi->access_l);\n-\n-\t}\n-      return 1;\n-    }\n-  if (!mi->dim_hot_level)\n-    mi->dim_hot_level =\n-      (gcov_type *) xcalloc (min_escape_l, sizeof (gcov_type));\n-\n-\n-  for (i = 0; VEC_iterate (access_site_info_p, mi->access_l, i, acc_info);\n-       i++)\n-    {\n-      if (gimple_assign_rhs_code (acc_info->stmt) == POINTER_PLUS_EXPR\n-\t  && acc_info->level < min_escape_l)\n-\t{\n-\t  loop = loop_containing_stmt (acc_info->stmt);\n-\t  if (!loop || loop->inner)\n-\t    {\n-\t      free (acc_info);\n-\t      continue;\n-\t    }\n-\t  if (simple_iv (loop, loop, acc_info->offset, &iv, true))\n-\t    {\n-\t      if (iv.step != NULL)\n-\t\t{\n-\t\t  HOST_WIDE_INT istep;\n-\n-\t\t  istep = int_cst_value (iv.step);\n-\t\t  if (istep != 0)\n-\t\t    {\n-\t\t      acc_info->iterated_by_inner_most_loop_p = 1;\n-\t\t      mi->dim_hot_level[acc_info->level] +=\n-\t\t\tgimple_bb (acc_info->stmt)->count;\n-\t\t    }\n-\n-\t\t}\n-\t    }\n-\t}\n-      free (acc_info);\n-    }\n-  VEC_free (access_site_info_p, heap, mi->access_l);\n-\n-  return 1;\n-}\n-\n-/* Find the index which defines the OFFSET from base.\n-   We walk from use to def until we find how the offset was defined.  */\n-static tree\n-get_index_from_offset (tree offset, gimple def_stmt)\n-{\n-  tree op1, op2, index;\n-\n-  if (gimple_code (def_stmt) == GIMPLE_PHI)\n-    return NULL;\n-  if ((gimple_assign_copy_p (def_stmt) || gimple_assign_cast_p (def_stmt))\n-      && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)\n-    return get_index_from_offset (offset,\n-\t\t\t\t  SSA_NAME_DEF_STMT (gimple_assign_rhs1 (def_stmt)));\n-  else if (is_gimple_assign (def_stmt)\n-\t   && gimple_assign_rhs_code (def_stmt) == MULT_EXPR)\n-    {\n-      op1 = gimple_assign_rhs1 (def_stmt);\n-      op2 = gimple_assign_rhs2 (def_stmt);\n-      if (TREE_CODE (op1) != INTEGER_CST && TREE_CODE (op2) != INTEGER_CST)\n-\treturn NULL;\n-      index = (TREE_CODE (op1) == INTEGER_CST) ? op2 : op1;\n-      return index;\n-    }\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* update MI->dimension_type_size[CURRENT_INDIRECT_LEVEL] with the size\n-   of the type related to the SSA_VAR, or the type related to the\n-   lhs of STMT, in the case that it is an MEM_REF.  */\n-static void\n-update_type_size (struct matrix_info *mi, gimple stmt, tree ssa_var,\n-\t\t  int current_indirect_level)\n-{\n-  tree lhs;\n-  HOST_WIDE_INT type_size;\n-\n-  /* Update type according to the type of the MEM_REF expr.   */\n-  if (is_gimple_assign (stmt)\n-      && TREE_CODE (gimple_assign_lhs (stmt)) == MEM_REF)\n-    {\n-      lhs = gimple_assign_lhs (stmt);\n-      gcc_assert (POINTER_TYPE_P\n-\t\t  (TREE_TYPE (TREE_OPERAND (lhs, 0))));\n-      type_size =\n-\tint_size_in_bytes (TREE_TYPE\n-\t\t\t   (TREE_TYPE (TREE_OPERAND (lhs, 0))));\n-    }\n-  else\n-    type_size = int_size_in_bytes (TREE_TYPE (ssa_var));\n-\n-  /* Record the size of elements accessed (as a whole)\n-     in the current indirection level (dimension).  If the size of\n-     elements is not known at compile time, mark it as escaping.  */\n-  if (type_size <= 0)\n-    mark_min_matrix_escape_level (mi, current_indirect_level, stmt);\n-  else\n-    {\n-      int l = current_indirect_level;\n-\n-      if (!mi->dimension_type_size)\n-\t{\n-\t  mi->dimension_type_size\n-\t    = (HOST_WIDE_INT *) xcalloc (l + 1, sizeof (HOST_WIDE_INT));\n-\t  mi->dimension_type_size_len = l + 1;\n-\t}\n-      else if (mi->dimension_type_size_len < l + 1)\n-\t{\n-\t  mi->dimension_type_size\n-\t    = (HOST_WIDE_INT *) xrealloc (mi->dimension_type_size,\n-\t\t\t\t\t  (l + 1) * sizeof (HOST_WIDE_INT));\n-\t  memset (&mi->dimension_type_size[mi->dimension_type_size_len],\n-\t\t  0, (l + 1 - mi->dimension_type_size_len)\n-\t\t  * sizeof (HOST_WIDE_INT));\n-\t  mi->dimension_type_size_len = l + 1;\n-\t}\n-      /* Make sure all the accesses in the same level have the same size\n-         of the type.  */\n-      if (!mi->dimension_type_size[l])\n-\tmi->dimension_type_size[l] = type_size;\n-      else if (mi->dimension_type_size[l] != type_size)\n-\tmark_min_matrix_escape_level (mi, l, stmt);\n-    }\n-}\n-\n-/* USE_STMT represents a GIMPLE_CALL, where one of the arguments is the\n-   ssa var that we want to check because it came from some use of matrix\n-   MI.  CURRENT_INDIRECT_LEVEL is the indirection level we reached so\n-   far.  */\n-\n-static int\n-analyze_accesses_for_call_stmt (struct matrix_info *mi, tree ssa_var,\n-\t\t\t\tgimple use_stmt, int current_indirect_level)\n-{\n-  tree fndecl = gimple_call_fndecl (use_stmt);\n-\n-  if (gimple_call_lhs (use_stmt))\n-    {\n-      tree lhs = gimple_call_lhs (use_stmt);\n-      struct ssa_acc_in_tree lhs_acc, rhs_acc;\n-\n-      memset (&lhs_acc, 0, sizeof (lhs_acc));\n-      memset (&rhs_acc, 0, sizeof (rhs_acc));\n-\n-      lhs_acc.ssa_var = ssa_var;\n-      lhs_acc.t_code = ERROR_MARK;\n-      ssa_accessed_in_tree (lhs, &lhs_acc);\n-      rhs_acc.ssa_var = ssa_var;\n-      rhs_acc.t_code = ERROR_MARK;\n-      ssa_accessed_in_call_rhs (use_stmt, &rhs_acc);\n-\n-      /* The SSA must be either in the left side or in the right side,\n-\t to understand what is happening.\n-\t In case the SSA_NAME is found in both sides we should be escaping\n-\t at this level because in this case we cannot calculate the\n-\t address correctly.  */\n-      if ((lhs_acc.var_found && rhs_acc.var_found\n-\t   && lhs_acc.t_code == MEM_REF)\n-\t  || (!rhs_acc.var_found && !lhs_acc.var_found))\n-\t{\n-\t  mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n-\t  return current_indirect_level;\n-\t}\n-      gcc_assert (!rhs_acc.var_found || !lhs_acc.var_found);\n-\n-      /* If we are storing to the matrix at some level, then mark it as\n-\t escaping at that level.  */\n-      if (lhs_acc.var_found)\n-\t{\n-\t  int l = current_indirect_level + 1;\n-\n-\t  gcc_assert (lhs_acc.t_code == MEM_REF);\n-\t  mark_min_matrix_escape_level (mi, l, use_stmt);\n-\t  return current_indirect_level;\n-\t}\n-    }\n-\n-  if (fndecl)\n-    {\n-      if (DECL_FUNCTION_CODE (fndecl) != BUILT_IN_FREE)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Matrix %s: Function call %s, level %d escapes.\\n\",\n-\t\t     get_name (mi->decl), get_name (fndecl),\n-\t\t     current_indirect_level);\n-\t  mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n-\t}\n-      else if (mi->free_stmts[current_indirect_level].stmt != NULL\n-\t       && mi->free_stmts[current_indirect_level].stmt != use_stmt)\n-\tmark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n-      else\n-\t{\n-\t  /*Record the free statements so we can delete them\n-\t     later. */\n-\t  int l = current_indirect_level;\n-\n-\t  mi->free_stmts[l].stmt = use_stmt;\n-\t  mi->free_stmts[l].func = current_function_decl;\n-\t}\n-    }\n-  return current_indirect_level;\n-}\n-\n-/* USE_STMT represents a phi node of the ssa var that we want to\n-   check  because it came from some use of matrix\n-   MI.\n-   We check all the escaping levels that get to the PHI node\n-   and make sure they are all the same escaping;\n-   if not (which is rare) we let the escaping level be the\n-   minimum level that gets into that PHI because starting from\n-   that level we cannot expect the behavior of the indirections.\n-   CURRENT_INDIRECT_LEVEL is the indirection level we reached so far.  */\n-\n-static void\n-analyze_accesses_for_phi_node (struct matrix_info *mi, gimple use_stmt,\n-\t\t\t       int current_indirect_level, sbitmap visited,\n-\t\t\t       bool record_accesses)\n-{\n-\n-  struct matrix_access_phi_node tmp_maphi, *maphi, **pmaphi;\n-\n-  tmp_maphi.phi = use_stmt;\n-  if ((maphi = (struct matrix_access_phi_node *)\n-       htab_find (htab_mat_acc_phi_nodes, &tmp_maphi)))\n-    {\n-      if (maphi->indirection_level == current_indirect_level)\n-\treturn;\n-      else\n-\t{\n-\t  int level = MIN (maphi->indirection_level,\n-\t\t\t   current_indirect_level);\n-\t  size_t j;\n-\t  gimple stmt = NULL;\n-\n-\t  maphi->indirection_level = level;\n-\t  for (j = 0; j < gimple_phi_num_args (use_stmt); j++)\n-\t    {\n-\t      tree def = PHI_ARG_DEF (use_stmt, j);\n-\n-\t      if (gimple_code (SSA_NAME_DEF_STMT (def)) != GIMPLE_PHI)\n-\t\tstmt = SSA_NAME_DEF_STMT (def);\n-\t    }\n-\t  mark_min_matrix_escape_level (mi, level, stmt);\n-\t}\n-      return;\n-    }\n-  maphi = (struct matrix_access_phi_node *)\n-    xcalloc (1, sizeof (struct matrix_access_phi_node));\n-  maphi->phi = use_stmt;\n-  maphi->indirection_level = current_indirect_level;\n-\n-  /* Insert to hash table.  */\n-  pmaphi = (struct matrix_access_phi_node **)\n-    htab_find_slot (htab_mat_acc_phi_nodes, maphi, INSERT);\n-  gcc_assert (pmaphi);\n-  *pmaphi = maphi;\n-\n-  if (!TEST_BIT (visited, SSA_NAME_VERSION (PHI_RESULT (use_stmt))))\n-    {\n-      SET_BIT (visited, SSA_NAME_VERSION (PHI_RESULT (use_stmt)));\n-      analyze_matrix_accesses (mi, PHI_RESULT (use_stmt),\n-\t\t\t       current_indirect_level, false, visited,\n-\t\t\t       record_accesses);\n-      RESET_BIT (visited, SSA_NAME_VERSION (PHI_RESULT (use_stmt)));\n-    }\n-}\n-\n-/* USE_STMT represents an assign statement (the rhs or lhs include\n-   the ssa var that we want to check  because it came from some use of matrix\n-   MI.  CURRENT_INDIRECT_LEVEL is the indirection level we reached so far.  */\n-\n-static int\n-analyze_accesses_for_assign_stmt (struct matrix_info *mi, tree ssa_var,\n-\t\t\t\t  gimple use_stmt, int current_indirect_level,\n-\t\t\t\t  bool last_op, sbitmap visited,\n-\t\t\t\t  bool record_accesses)\n-{\n-  tree lhs = gimple_get_lhs (use_stmt);\n-  struct ssa_acc_in_tree lhs_acc, rhs_acc;\n-\n-  memset (&lhs_acc, 0, sizeof (lhs_acc));\n-  memset (&rhs_acc, 0, sizeof (rhs_acc));\n-\n-  lhs_acc.ssa_var = ssa_var;\n-  lhs_acc.t_code = ERROR_MARK;\n-  ssa_accessed_in_tree (lhs, &lhs_acc);\n-  rhs_acc.ssa_var = ssa_var;\n-  rhs_acc.t_code = ERROR_MARK;\n-  ssa_accessed_in_assign_rhs (use_stmt, &rhs_acc);\n-\n-  /* The SSA must be either in the left side or in the right side,\n-     to understand what is happening.\n-     In case the SSA_NAME is found in both sides we should be escaping\n-     at this level because in this case we cannot calculate the\n-     address correctly.  */\n-  if ((lhs_acc.var_found && rhs_acc.var_found\n-       && lhs_acc.t_code == MEM_REF)\n-      || (!rhs_acc.var_found && !lhs_acc.var_found))\n-    {\n-      mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n-      return current_indirect_level;\n-    }\n-  gcc_assert (!rhs_acc.var_found || !lhs_acc.var_found);\n-\n-  /* If we are storing to the matrix at some level, then mark it as\n-     escaping at that level.  */\n-  if (lhs_acc.var_found)\n-    {\n-      int l = current_indirect_level + 1;\n-\n-      gcc_assert (lhs_acc.t_code == MEM_REF);\n-\n-      if (!(gimple_assign_copy_p (use_stmt)\n-\t    || gimple_assign_cast_p (use_stmt))\n-\t  || (TREE_CODE (gimple_assign_rhs1 (use_stmt)) != SSA_NAME))\n-\tmark_min_matrix_escape_level (mi, l, use_stmt);\n-      else\n-\t{\n-\t  gimple def_stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (use_stmt));\n-\t  analyze_matrix_allocation_site (mi, def_stmt, l, visited);\n-\t  if (record_accesses)\n-\t    record_access_alloc_site_info (mi, use_stmt, NULL_TREE,\n-\t\t\t\t\t   NULL_TREE, l, true);\n-\t  update_type_size (mi, use_stmt, NULL, l);\n-\t}\n-      return current_indirect_level;\n-    }\n-  /* Now, check the right-hand-side, to see how the SSA variable\n-     is used.  */\n-  if (rhs_acc.var_found)\n-    {\n-      if (rhs_acc.t_code != MEM_REF\n-\t  && rhs_acc.t_code != POINTER_PLUS_EXPR && rhs_acc.t_code != SSA_NAME)\n-\t{\n-\t  mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n-\t  return current_indirect_level;\n-\t}\n-      /* If the access in the RHS has an indirection increase the\n-         indirection level.  */\n-      if (rhs_acc.t_code == MEM_REF)\n-\t{\n-\t  if (record_accesses)\n-\t    record_access_alloc_site_info (mi, use_stmt, NULL_TREE,\n-\t\t\t\t\t   NULL_TREE,\n-\t\t\t\t\t   current_indirect_level, true);\n-\t  current_indirect_level += 1;\n-\t}\n-      else if (rhs_acc.t_code == POINTER_PLUS_EXPR)\n-\t{\n-\t  gcc_assert (rhs_acc.second_op);\n-\t  if (last_op)\n-\t    /* Currently we support only one PLUS expression on the\n-\t       SSA_NAME that holds the base address of the current\n-\t       indirection level; to support more general case there\n-\t       is a need to hold a stack of expressions and regenerate\n-\t       the calculation later.  */\n-\t    mark_min_matrix_escape_level (mi, current_indirect_level,\n-\t\t\t\t\t  use_stmt);\n-\t  else\n-\t    {\n-\t      tree index;\n-\t      tree op1, op2;\n-\n-\t      op1 = gimple_assign_rhs1 (use_stmt);\n-\t      op2 = gimple_assign_rhs2 (use_stmt);\n-\n-\t      op2 = (op1 == ssa_var) ? op2 : op1;\n-\t      if (TREE_CODE (op2) == INTEGER_CST)\n-\t\tindex =\n-\t\t  build_int_cst (TREE_TYPE (op1),\n-\t\t\t\t TREE_INT_CST_LOW (op2) /\n-\t\t\t\t int_size_in_bytes (TREE_TYPE (op1)));\n-\t      else\n-\t\t{\n-\t\t  index =\n-\t\t    get_index_from_offset (op2, SSA_NAME_DEF_STMT (op2));\n-\t\t  if (index == NULL_TREE)\n-\t\t    {\n-\t\t      mark_min_matrix_escape_level (mi,\n-\t\t\t\t\t\t    current_indirect_level,\n-\t\t\t\t\t\t    use_stmt);\n-\t\t      return current_indirect_level;\n-\t\t    }\n-\t\t}\n-\t      if (record_accesses)\n-\t\trecord_access_alloc_site_info (mi, use_stmt, op2,\n-\t\t\t\t\t       index,\n-\t\t\t\t\t       current_indirect_level, false);\n-\t    }\n-\t}\n-      /* If we are storing this level of indirection mark it as\n-         escaping.  */\n-      if (lhs_acc.t_code == MEM_REF || TREE_CODE (lhs) != SSA_NAME)\n-\t{\n-\t  int l = current_indirect_level;\n-\n-\t  /* One exception is when we are storing to the matrix\n-\t     variable itself; this is the case of malloc, we must make\n-\t     sure that it's the one and only one call to malloc so\n-\t     we call analyze_matrix_allocation_site to check\n-\t     this out.  */\n-\t  if (TREE_CODE (lhs) != VAR_DECL || lhs != mi->decl)\n-\t    mark_min_matrix_escape_level (mi, current_indirect_level,\n-\t\t\t\t\t  use_stmt);\n-\t  else\n-\t    {\n-\t      /* Also update the escaping level.  */\n-\t      analyze_matrix_allocation_site (mi, use_stmt, l, visited);\n-\t      if (record_accesses)\n-\t\trecord_access_alloc_site_info (mi, use_stmt, NULL_TREE,\n-\t\t\t\t\t       NULL_TREE, l, true);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* We are placing it in an SSA, follow that SSA.  */\n-\t  analyze_matrix_accesses (mi, lhs,\n-\t\t\t\t   current_indirect_level,\n-\t\t\t\t   rhs_acc.t_code == POINTER_PLUS_EXPR,\n-\t\t\t\t   visited, record_accesses);\n-\t}\n-    }\n-  return current_indirect_level;\n-}\n-\n-/* Given a SSA_VAR (coming from a use statement of the matrix MI),\n-   follow its uses and level of indirection and find out the minimum\n-   indirection level it escapes in (the highest dimension) and the maximum\n-   level it is accessed in (this will be the actual dimension of the\n-   matrix).  The information is accumulated in MI.\n-   We look at the immediate uses, if one escapes we finish; if not,\n-   we make a recursive call for each one of the immediate uses of the\n-   resulting SSA name.  */\n-static void\n-analyze_matrix_accesses (struct matrix_info *mi, tree ssa_var,\n-\t\t\t int current_indirect_level, bool last_op,\n-\t\t\t sbitmap visited, bool record_accesses)\n-{\n-  imm_use_iterator imm_iter;\n-  use_operand_p use_p;\n-\n-  update_type_size (mi, SSA_NAME_DEF_STMT (ssa_var), ssa_var,\n-\t\t    current_indirect_level);\n-\n-  /* We don't go beyond the escaping level when we are performing the\n-     flattening.  NOTE: we keep the last indirection level that doesn't\n-     escape.  */\n-  if (mi->min_indirect_level_escape > -1\n-      && mi->min_indirect_level_escape <= current_indirect_level)\n-    return;\n-\n-/* Now go over the uses of the SSA_NAME and check how it is used in\n-   each one of them.  We are mainly looking for the pattern MEM_REF,\n-   then a POINTER_PLUS_EXPR, then MEM_REF etc.  while in between there could\n-   be any number of copies and casts.  */\n-  gcc_assert (TREE_CODE (ssa_var) == SSA_NAME);\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, ssa_var)\n-  {\n-    gimple use_stmt = USE_STMT (use_p);\n-    if (gimple_code (use_stmt) == GIMPLE_PHI)\n-      /* We check all the escaping levels that get to the PHI node\n-         and make sure they are all the same escaping;\n-         if not (which is rare) we let the escaping level be the\n-         minimum level that gets into that PHI because starting from\n-         that level we cannot expect the behavior of the indirections.  */\n-\n-      analyze_accesses_for_phi_node (mi, use_stmt, current_indirect_level,\n-\t\t\t\t     visited, record_accesses);\n-\n-    else if (is_gimple_call (use_stmt))\n-      analyze_accesses_for_call_stmt (mi, ssa_var, use_stmt,\n-\t\t\t\t      current_indirect_level);\n-    else if (is_gimple_assign (use_stmt))\n-      current_indirect_level =\n-\tanalyze_accesses_for_assign_stmt (mi, ssa_var, use_stmt,\n-\t\t\t\t\t  current_indirect_level, last_op,\n-\t\t\t\t\t  visited, record_accesses);\n-  }\n-}\n-\n-typedef struct\n-{\n-  tree fn;\n-  gimple stmt;\n-} check_var_data;\n-\n-/* A walk_tree function to go over the VAR_DECL, PARM_DECL nodes of\n-   the malloc size expression and check that those aren't changed\n-   over the function.  */\n-static tree\n-check_var_notmodified_p (tree * tp, int *walk_subtrees, void *data)\n-{\n-  basic_block bb;\n-  tree t = *tp;\n-  check_var_data *callback_data = (check_var_data*) data;\n-  tree fn = callback_data->fn;\n-  gimple_stmt_iterator gsi;\n-  gimple stmt;\n-\n-  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n-    return NULL_TREE;\n-\n-  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (fn))\n-  {\n-    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-      {\n-\tstmt = gsi_stmt (gsi);\n-\tif (!is_gimple_assign (stmt) && !is_gimple_call (stmt))\n-\t  continue;\n-\tif (gimple_get_lhs (stmt) == t)\n-\t  {\n-\t    callback_data->stmt = stmt;\n-\t    return t;\n-\t  }\n-      }\n-  }\n-  *walk_subtrees = 1;\n-  return NULL_TREE;\n-}\n-\n-/* Go backwards in the use-def chains and find out the expression\n-   represented by the possible SSA name in STMT, until it is composed\n-   of only VAR_DECL, PARM_DECL and INT_CST.  In case of phi nodes\n-   we make sure that all the arguments represent the same subexpression,\n-   otherwise we fail.  */\n-\n-static tree\n-can_calculate_stmt_before_stmt (gimple stmt, sbitmap visited)\n-{\n-  tree op1, op2, res;\n-  enum tree_code code;\n-\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_ASSIGN:\n-      code = gimple_assign_rhs_code (stmt);\n-      op1 = gimple_assign_rhs1 (stmt);\n-\n-      switch (code)\n-\t{\n-\tcase POINTER_PLUS_EXPR:\n-\tcase PLUS_EXPR:\n-\tcase MINUS_EXPR:\n-\tcase MULT_EXPR:\n-\n-\t  op2 = gimple_assign_rhs2 (stmt);\n-\t  op1 = can_calculate_expr_before_stmt (op1, visited);\n-\t  if (!op1)\n-\t    return NULL_TREE;\n-\t  op2 = can_calculate_expr_before_stmt (op2, visited);\n-\t  if (op2)\n-\t    return fold_build2 (code, gimple_expr_type (stmt), op1, op2);\n-\t  return NULL_TREE;\n-\n-\tCASE_CONVERT:\n-\t  res = can_calculate_expr_before_stmt (op1, visited);\n-\t  if (res != NULL_TREE)\n-\t    return build1 (code, gimple_expr_type (stmt), res);\n-\t  else\n-\t    return NULL_TREE;\n-\n-\tdefault:\n-\t  if (gimple_assign_single_p (stmt))\n-\t    return can_calculate_expr_before_stmt (op1, visited);\n-\t  else\n-\t    return NULL_TREE;\n-\t}\n-\n-    case GIMPLE_PHI:\n-      {\n-\tsize_t j;\n-\n-\tres = NULL_TREE;\n-\t/* Make sure all the arguments represent the same value.  */\n-\tfor (j = 0; j < gimple_phi_num_args (stmt); j++)\n-\t  {\n-\t    tree new_res;\n-\t    tree def = PHI_ARG_DEF (stmt, j);\n-\n-\t    new_res = can_calculate_expr_before_stmt (def, visited);\n-\t    if (res == NULL_TREE)\n-\t      res = new_res;\n-\t    else if (!new_res || !expressions_equal_p (res, new_res))\n-\t      return NULL_TREE;\n-\t  }\n-\treturn res;\n-      }\n-\n-    default:\n-      return NULL_TREE;\n-    }\n-}\n-\n-/* Go backwards in the use-def chains and find out the expression\n-   represented by the possible SSA name in EXPR, until it is composed\n-   of only VAR_DECL, PARM_DECL and INT_CST.  In case of phi nodes\n-   we make sure that all the arguments represent the same subexpression,\n-   otherwise we fail.  */\n-static tree\n-can_calculate_expr_before_stmt (tree expr, sbitmap visited)\n-{\n-  gimple def_stmt;\n-  tree res;\n-\n-  switch (TREE_CODE (expr))\n-    {\n-    case SSA_NAME:\n-      /* Case of loop, we don't know to represent this expression.  */\n-      if (TEST_BIT (visited, SSA_NAME_VERSION (expr)))\n-\treturn NULL_TREE;\n-\n-      SET_BIT (visited, SSA_NAME_VERSION (expr));\n-      def_stmt = SSA_NAME_DEF_STMT (expr);\n-      res = can_calculate_stmt_before_stmt (def_stmt, visited);\n-      RESET_BIT (visited, SSA_NAME_VERSION (expr));\n-      return res;\n-    case VAR_DECL:\n-    case PARM_DECL:\n-    case INTEGER_CST:\n-      return expr;\n-\n-    default:\n-      return NULL_TREE;\n-    }\n-}\n-\n-/* There should be only one allocation function for the dimensions\n-   that don't escape. Here we check the allocation sites in this\n-   function. We must make sure that all the dimensions are allocated\n-   using malloc and that the malloc size parameter expression could be\n-   pre-calculated before the call to the malloc of dimension 0.\n-\n-   Given a candidate matrix for flattening -- MI -- check if it's\n-   appropriate for flattening -- we analyze the allocation\n-   sites that we recorded in the previous analysis.  The result of the\n-   analysis is a level of indirection (matrix dimension) in which the\n-   flattening is safe.  We check the following conditions:\n-   1. There is only one allocation site for each dimension.\n-   2. The allocation sites of all the dimensions are in the same\n-      function.\n-      (The above two are being taken care of during the analysis when\n-      we check the allocation site).\n-   3. All the dimensions that we flatten are allocated at once; thus\n-      the total size must be known before the allocation of the\n-      dimension 0 (top level) -- we must make sure we represent the\n-      size of the allocation as an expression of global parameters or\n-      constants and that those doesn't change over the function.  */\n-\n-static int\n-check_allocation_function (void **slot, void *data ATTRIBUTE_UNUSED)\n-{\n-  int level;\n-  struct matrix_info *mi = (struct matrix_info *) *slot;\n-  sbitmap visited;\n-\n-  if (!mi->malloc_for_level)\n-    return 1;\n-\n-  visited = sbitmap_alloc (num_ssa_names);\n-\n-  /* Do nothing if the current function is not the allocation\n-     function of MI.  */\n-  if (mi->allocation_function_decl != current_function_decl\n-      /* We aren't in the main allocation function yet.  */\n-      || !mi->malloc_for_level[0])\n-    return 1;\n-\n-  for (level = 1; level < mi->max_malloced_level; level++)\n-    if (!mi->malloc_for_level[level])\n-      break;\n-\n-  mark_min_matrix_escape_level (mi, level, NULL);\n-\n-  /* Check if the expression of the size passed to malloc could be\n-     pre-calculated before the malloc of level 0.  */\n-  for (level = 1; level < mi->min_indirect_level_escape; level++)\n-    {\n-      gimple call_stmt;\n-      tree size;\n-      struct malloc_call_data mcd = {NULL, NULL_TREE, NULL_TREE};\n-\n-      call_stmt = mi->malloc_for_level[level];\n-\n-      /* Find the correct malloc information.  */\n-      collect_data_for_malloc_call (call_stmt, &mcd);\n-\n-      /* No need to check anticipation for constants.  */\n-      if (TREE_CODE (mcd.size_var) == INTEGER_CST)\n-\t{\n-\t  if (!mi->dimension_size)\n-\t    {\n-\t      mi->dimension_size =\n-\t\t(tree *) xcalloc (mi->min_indirect_level_escape,\n-\t\t\t\t  sizeof (tree));\n-\t      mi->dimension_size_orig =\n-\t\t(tree *) xcalloc (mi->min_indirect_level_escape,\n-\t\t\t\t  sizeof (tree));\n-\t    }\n-\t  mi->dimension_size[level] = mcd.size_var;\n-\t  mi->dimension_size_orig[level] = mcd.size_var;\n-\t  continue;\n-\t}\n-      /* ??? Here we should also add the way to calculate the size\n-         expression not only know that it is anticipated.  */\n-      sbitmap_zero (visited);\n-      size = can_calculate_expr_before_stmt (mcd.size_var, visited);\n-      if (size == NULL_TREE)\n-\t{\n-\t  mark_min_matrix_escape_level (mi, level, call_stmt);\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Matrix %s: Cannot calculate the size of allocation, escaping at level %d\\n\",\n-\t\t     get_name (mi->decl), level);\n-\t  break;\n-\t}\n-      if (!mi->dimension_size)\n-\t{\n-\t  mi->dimension_size =\n-\t    (tree *) xcalloc (mi->min_indirect_level_escape, sizeof (tree));\n-\t  mi->dimension_size_orig =\n-\t    (tree *) xcalloc (mi->min_indirect_level_escape, sizeof (tree));\n-\t}\n-      mi->dimension_size[level] = size;\n-      mi->dimension_size_orig[level] = size;\n-    }\n-\n-  /* We don't need those anymore.  */\n-  for (level = mi->min_indirect_level_escape;\n-       level < mi->max_malloced_level; level++)\n-    mi->malloc_for_level[level] = NULL;\n-  return 1;\n-}\n-\n-/* Track all access and allocation sites.  */\n-static void\n-find_sites_in_func (bool record)\n-{\n-  sbitmap visited_stmts_1;\n-\n-  gimple_stmt_iterator gsi;\n-  gimple stmt;\n-  basic_block bb;\n-  struct matrix_info tmpmi, *mi;\n-\n-  visited_stmts_1 = sbitmap_alloc (num_ssa_names);\n-\n-  FOR_EACH_BB (bb)\n-  {\n-    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-      {\n-\ttree lhs;\n-\n-\tstmt = gsi_stmt (gsi);\n-\tlhs = gimple_get_lhs (stmt);\n-\tif (lhs != NULL_TREE\n-\t    && TREE_CODE (lhs) == VAR_DECL)\n-\t  {\n-\t    tmpmi.decl = lhs;\n-\t    if ((mi = (struct matrix_info *) htab_find (matrices_to_reorg,\n-\t\t\t\t\t\t\t&tmpmi)))\n-\t      {\n-\t\tsbitmap_zero (visited_stmts_1);\n-\t\tanalyze_matrix_allocation_site (mi, stmt, 0, visited_stmts_1);\n-\t      }\n-\t  }\n-\tif (is_gimple_assign (stmt)\n-\t    && gimple_assign_single_p (stmt)\n-\t    && TREE_CODE (lhs) == SSA_NAME\n-\t    && TREE_CODE (gimple_assign_rhs1 (stmt)) == VAR_DECL)\n-\t  {\n-\t    tmpmi.decl = gimple_assign_rhs1 (stmt);\n-\t    if ((mi = (struct matrix_info *) htab_find (matrices_to_reorg,\n-\t\t\t\t\t\t\t&tmpmi)))\n-\t      {\n-\t\tsbitmap_zero (visited_stmts_1);\n-\t\tanalyze_matrix_accesses (mi, lhs, 0,\n-\t\t\t\t\t false, visited_stmts_1, record);\n-\t      }\n-\t  }\n-      }\n-  }\n-  sbitmap_free (visited_stmts_1);\n-}\n-\n-/* Traverse the use-def chains to see if there are matrices that\n-   are passed through pointers and we cannot know how they are accessed.\n-   For each SSA-name defined by a global variable of our interest,\n-   we traverse the use-def chains of the SSA and follow the indirections,\n-   and record in what level of indirection the use of the variable\n-   escapes.  A use of a pointer escapes when it is passed to a function,\n-   stored into memory or assigned (except in malloc and free calls).  */\n-\n-static void\n-record_all_accesses_in_func (void)\n-{\n-  unsigned i;\n-  sbitmap visited_stmts_1;\n-\n-  visited_stmts_1 = sbitmap_alloc (num_ssa_names);\n-\n-  for (i = 0; i < num_ssa_names; i++)\n-    {\n-      struct matrix_info tmpmi, *mi;\n-      tree ssa_var = ssa_name (i);\n-      tree rhs, lhs;\n-\n-      if (!ssa_var\n-\t  || !is_gimple_assign (SSA_NAME_DEF_STMT (ssa_var))\n-\t  || !gimple_assign_single_p (SSA_NAME_DEF_STMT (ssa_var)))\n-\tcontinue;\n-      rhs = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (ssa_var));\n-      lhs = gimple_assign_lhs (SSA_NAME_DEF_STMT (ssa_var));\n-      if (TREE_CODE (rhs) != VAR_DECL && TREE_CODE (lhs) != VAR_DECL)\n-\tcontinue;\n-\n-      /* If the RHS is a matrix that we want to analyze, follow the def-use\n-         chain for this SSA_VAR and check for escapes or apply the\n-         flattening.  */\n-      tmpmi.decl = rhs;\n-      if ((mi = (struct matrix_info *) htab_find (matrices_to_reorg, &tmpmi)))\n-\t{\n-\t  /* This variable will track the visited PHI nodes, so we can limit\n-\t     its size to the maximum number of SSA names.  */\n-\t  sbitmap_zero (visited_stmts_1);\n-\t  analyze_matrix_accesses (mi, ssa_var,\n-\t\t\t\t   0, false, visited_stmts_1, true);\n-\n-\t}\n-    }\n-  sbitmap_free (visited_stmts_1);\n-}\n-\n-/* Used when we want to convert the expression: RESULT = something *\n-   ORIG to RESULT = something * NEW_VAL. If ORIG and NEW_VAL are power\n-   of 2, shift operations can be done, else division and\n-   multiplication.  */\n-\n-static tree\n-compute_offset (HOST_WIDE_INT orig, HOST_WIDE_INT new_val, tree result)\n-{\n-\n-  int x, y;\n-  tree result1, ratio, log, orig_tree, new_tree;\n-\n-  x = exact_log2 (orig);\n-  y = exact_log2 (new_val);\n-\n-  if (x != -1 && y != -1)\n-    {\n-      if (x == y)\n-        return result;\n-      else if (x > y)\n-        {\n-          log = build_int_cst (TREE_TYPE (result), x - y);\n-          result1 =\n-            fold_build2 (LSHIFT_EXPR, TREE_TYPE (result), result, log);\n-          return result1;\n-        }\n-      log = build_int_cst (TREE_TYPE (result), y - x);\n-      result1 = fold_build2 (RSHIFT_EXPR, TREE_TYPE (result), result, log);\n-\n-      return result1;\n-    }\n-  orig_tree = build_int_cst (TREE_TYPE (result), orig);\n-  new_tree = build_int_cst (TREE_TYPE (result), new_val);\n-  ratio = fold_build2 (TRUNC_DIV_EXPR, TREE_TYPE (result), result, orig_tree);\n-  result1 = fold_build2 (MULT_EXPR, TREE_TYPE (result), ratio, new_tree);\n-\n-  return result1;\n-}\n-\n-\n-/* We know that we are allowed to perform matrix flattening (according to the\n-   escape analysis), so we traverse the use-def chains of the SSA vars\n-   defined by the global variables pointing to the matrices of our interest.\n-   in each use of the SSA we calculate the offset from the base address\n-   according to the following equation:\n-\n-     a[I1][I2]...[Ik] , where D1..Dk is the length of each dimension and the\n-     escaping level is m <= k, and a' is the new allocated matrix,\n-     will be translated to :\n-\n-       b[I(m+1)]...[Ik]\n-\n-       where\n-       b = a' + I1*D2...*Dm + I2*D3...Dm + ... + Im\n-                                                      */\n-\n-static int\n-transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n-{\n-  gimple_stmt_iterator gsi;\n-  struct matrix_info *mi = (struct matrix_info *) *slot;\n-  int min_escape_l = mi->min_indirect_level_escape;\n-  struct access_site_info *acc_info;\n-  enum tree_code code;\n-  int i;\n-\n-  if (min_escape_l < 2 || !mi->access_l)\n-    return 1;\n-  for (i = 0; VEC_iterate (access_site_info_p, mi->access_l, i, acc_info);\n-       i++)\n-    {\n-      /* This is possible because we collect the access sites before\n-         we determine the final minimum indirection level.  */\n-      if (acc_info->level >= min_escape_l)\n-\t{\n-\t  free (acc_info);\n-\t  continue;\n-\t}\n-      if (acc_info->is_alloc)\n-\t{\n-\t  if (acc_info->level >= 0 && gimple_bb (acc_info->stmt))\n-\t    {\n-\t      gimple stmt = acc_info->stmt;\n-\t      tree lhs;\n-\n-\t      gsi = gsi_for_stmt (stmt);\n-\t      gcc_assert (is_gimple_assign (acc_info->stmt));\n-\t      lhs = gimple_assign_lhs (acc_info->stmt);\n-\t      if (TREE_CODE (lhs) == SSA_NAME\n-\t\t  && acc_info->level < min_escape_l - 1)\n-\t\t{\n-\t\t  imm_use_iterator imm_iter;\n-\t\t  use_operand_p use_p;\n-\t\t  gimple use_stmt;\n-\n-\t\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, lhs)\n-\t\t    FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\t\t  {\n-\t\t    tree rhs, tmp;\n-\t\t    gimple new_stmt;\n-\n-\t\t    gcc_assert (gimple_assign_rhs_code (acc_info->stmt)\n-\t\t\t\t== MEM_REF);\n-\t\t    /* Emit convert statement to convert to type of use.  */\n-\t\t    tmp = create_tmp_var (TREE_TYPE (lhs), \"new\");\n-\t\t    rhs = gimple_assign_rhs1 (acc_info->stmt);\n-\t\t    rhs = fold_convert (TREE_TYPE (tmp),\n-\t\t\t\t\tTREE_OPERAND (rhs, 0));\n-\t\t    new_stmt = gimple_build_assign (tmp, rhs);\n-\t\t    tmp = make_ssa_name (tmp, new_stmt);\n-\t\t    gimple_assign_set_lhs (new_stmt, tmp);\n-\t\t    gsi = gsi_for_stmt (acc_info->stmt);\n-\t\t    gsi_insert_after (&gsi, new_stmt, GSI_SAME_STMT);\n-\t\t    SET_USE (use_p, tmp);\n-\t\t  }\n-\t\t}\n-\t      if (acc_info->level < min_escape_l - 1)\n-\t\tgsi_remove (&gsi, true);\n-\t    }\n-\t  free (acc_info);\n-\t  continue;\n-\t}\n-      code = gimple_assign_rhs_code (acc_info->stmt);\n-      if (code == MEM_REF\n-\t  && acc_info->level < min_escape_l - 1)\n-\t{\n-\t  /* Replace the MEM_REF with NOP (cast) usually we are casting\n-\t     from \"pointer to type\" to \"type\".  */\n-\t  tree t =\n-\t    build1 (NOP_EXPR, TREE_TYPE (gimple_assign_rhs1 (acc_info->stmt)),\n-\t\t    TREE_OPERAND (gimple_assign_rhs1 (acc_info->stmt), 0));\n-\t  gimple_assign_set_rhs_code (acc_info->stmt, NOP_EXPR);\n-\t  gimple_assign_set_rhs1 (acc_info->stmt, t);\n-\t}\n-      else if (code == POINTER_PLUS_EXPR\n-\t       && acc_info->level < (min_escape_l))\n-\t{\n-\t  imm_use_iterator imm_iter;\n-\t  use_operand_p use_p;\n-\n-\t  tree offset;\n-\t  int k = acc_info->level;\n-\t  tree num_elements, total_elements;\n-\t  tree tmp1;\n-\t  tree d_size = mi->dimension_size[k];\n-\n-\t  /* We already make sure in the analysis that the first operand\n-\t     is the base and the second is the offset.  */\n-\t  offset = acc_info->offset;\n-\t  if (mi->dim_map[k] == min_escape_l - 1)\n-\t    {\n-\t      if (!check_transpose_p || mi->is_transposed_p == false)\n-\t\ttmp1 = offset;\n-\t      else\n-\t\t{\n-\t\t  tree new_offset;\n-\n-\t\t  new_offset =\n-\t\t    compute_offset (mi->dimension_type_size[min_escape_l],\n-\t\t\t\t    mi->dimension_type_size[k + 1], offset);\n-\n-\t\t  total_elements = new_offset;\n-\t\t  if (new_offset != offset)\n-\t\t    {\n-\t\t      gsi = gsi_for_stmt (acc_info->stmt);\n-\t\t      tmp1 = force_gimple_operand_gsi (&gsi, total_elements,\n-\t\t\t\t\t\t       true, NULL,\n-\t\t\t\t\t\t       true, GSI_SAME_STMT);\n-\t\t    }\n-\t\t  else\n-\t\t    tmp1 = offset;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      d_size = mi->dimension_size[mi->dim_map[k] + 1];\n-\t      num_elements =\n-\t\tfold_build2 (MULT_EXPR, sizetype, fold_convert (sizetype, acc_info->index),\n-\t\t\t    fold_convert (sizetype, d_size));\n-\t      gsi = gsi_for_stmt (acc_info->stmt);\n-\t      tmp1 = force_gimple_operand_gsi (&gsi, num_elements, true,\n-\t\t\t\t\t       NULL, true, GSI_SAME_STMT);\n-\t    }\n-\t  /* Replace the offset if needed.  */\n-\t  if (tmp1 != offset)\n-\t    {\n-\t      if (TREE_CODE (offset) == SSA_NAME)\n-\t\t{\n-\t\t  gimple use_stmt;\n-\n-\t\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, offset)\n-\t\t    FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\t\t      if (use_stmt == acc_info->stmt)\n-\t\t        SET_USE (use_p, tmp1);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  gcc_assert (TREE_CODE (offset) == INTEGER_CST);\n-\t\t  gimple_assign_set_rhs2 (acc_info->stmt, tmp1);\n-\t\t  update_stmt (acc_info->stmt);\n-\t\t}\n-\t    }\n-\t}\n-      /* ??? meanwhile this happens because we record the same access\n-         site more than once; we should be using a hash table to\n-         avoid this and insert the STMT of the access site only\n-         once.\n-         else\n-         gcc_unreachable (); */\n-      free (acc_info);\n-    }\n-  VEC_free (access_site_info_p, heap, mi->access_l);\n-\n-  update_ssa (TODO_update_ssa);\n-#ifdef ENABLE_CHECKING\n-  verify_ssa (true);\n-#endif\n-  return 1;\n-}\n-\n-/* Sort A array of counts. Arrange DIM_MAP to reflect the new order.  */\n-\n-static void\n-sort_dim_hot_level (gcov_type * a, int *dim_map, int n)\n-{\n-  int i, j, tmp1;\n-  gcov_type tmp;\n-\n-  for (i = 0; i < n - 1; i++)\n-    {\n-      for (j = 0; j < n - 1 - i; j++)\n-\t{\n-\t  if (a[j + 1] < a[j])\n-\t    {\n-\t      tmp = a[j];\t/* swap a[j] and a[j+1]      */\n-\t      a[j] = a[j + 1];\n-\t      a[j + 1] = tmp;\n-\t      tmp1 = dim_map[j];\n-\t      dim_map[j] = dim_map[j + 1];\n-\t      dim_map[j + 1] = tmp1;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Replace multiple mallocs (one for each dimension) to one malloc\n-   with the size of DIM1*DIM2*...*DIMN*size_of_element\n-   Make sure that we hold the size in the malloc site inside a\n-   new global variable; this way we ensure that the size doesn't\n-   change and it is accessible from all the other functions that\n-   uses the matrix.  Also, the original calls to free are deleted,\n-   and replaced by a new call to free the flattened matrix.  */\n-\n-static int\n-transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n-{\n-  int i;\n-  struct matrix_info *mi;\n-  tree type, oldfn, prev_dim_size;\n-  gimple call_stmt_0, use_stmt;\n-  struct cgraph_node *c_node;\n-  struct cgraph_edge *e;\n-  gimple_stmt_iterator gsi;\n-  struct malloc_call_data mcd = {NULL, NULL_TREE, NULL_TREE};\n-  HOST_WIDE_INT element_size;\n-\n-  imm_use_iterator imm_iter;\n-  use_operand_p use_p;\n-  tree old_size_0, tmp;\n-  int min_escape_l;\n-  int id;\n-\n-  mi = (struct matrix_info *) *slot;\n-\n-  min_escape_l = mi->min_indirect_level_escape;\n-\n-  if (!mi->malloc_for_level)\n-    mi->min_indirect_level_escape = 0;\n-\n-  if (mi->min_indirect_level_escape < 2)\n-    return 1;\n-\n-  mi->dim_map = (int *) xcalloc (mi->min_indirect_level_escape, sizeof (int));\n-  for (i = 0; i < mi->min_indirect_level_escape; i++)\n-    mi->dim_map[i] = i;\n-  if (check_transpose_p)\n-    {\n-      int i;\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"Matrix %s:\\n\", get_name (mi->decl));\n-\t  for (i = 0; i < min_escape_l; i++)\n-\t    {\n-\t      fprintf (dump_file, \"dim %d before sort \", i);\n-\t      if (mi->dim_hot_level)\n-\t\tfprintf (dump_file,\n-\t\t\t \"count is  \" HOST_WIDEST_INT_PRINT_DEC \"  \\n\",\n-\t\t\t mi->dim_hot_level[i]);\n-\t    }\n-\t}\n-      sort_dim_hot_level (mi->dim_hot_level, mi->dim_map,\n-\t\t\t  mi->min_indirect_level_escape);\n-      if (dump_file)\n-\tfor (i = 0; i < min_escape_l; i++)\n-\t  {\n-\t    fprintf (dump_file, \"dim %d after sort\\n\", i);\n-\t    if (mi->dim_hot_level)\n-\t      fprintf (dump_file, \"count is  \" HOST_WIDE_INT_PRINT_DEC\n-\t\t       \"  \\n\", (HOST_WIDE_INT) mi->dim_hot_level[i]);\n-\t  }\n-      for (i = 0; i < mi->min_indirect_level_escape; i++)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"dim_map[%d] after sort %d\\n\", i,\n-\t\t     mi->dim_map[i]);\n-\t  if (mi->dim_map[i] != i)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Transposed dimensions: dim %d is now dim %d\\n\",\n-\t\t\t mi->dim_map[i], i);\n-\t      mi->is_transposed_p = true;\n-\t    }\n-\t}\n-    }\n-  else\n-    {\n-      for (i = 0; i < mi->min_indirect_level_escape; i++)\n-\tmi->dim_map[i] = i;\n-    }\n-  /* Call statement of allocation site of level 0.  */\n-  call_stmt_0 = mi->malloc_for_level[0];\n-\n-  /* Finds the correct malloc information.  */\n-  collect_data_for_malloc_call (call_stmt_0, &mcd);\n-\n-  mi->dimension_size[0] = mcd.size_var;\n-  mi->dimension_size_orig[0] = mcd.size_var;\n-  /* Make sure that the variables in the size expression for\n-     all the dimensions (above level 0) aren't modified in\n-     the allocation function.  */\n-  for (i = 1; i < mi->min_indirect_level_escape; i++)\n-    {\n-      tree t;\n-      check_var_data data;\n-\n-      /* mi->dimension_size must contain the expression of the size calculated\n-         in check_allocation_function.  */\n-      gcc_assert (mi->dimension_size[i]);\n-\n-      data.fn = mi->allocation_function_decl;\n-      data.stmt = NULL;\n-      t = walk_tree_without_duplicates (&(mi->dimension_size[i]),\n-\t\t\t\t\tcheck_var_notmodified_p,\n-\t\t\t\t\t&data);\n-      if (t != NULL_TREE)\n-\t{\n-\t  mark_min_matrix_escape_level (mi, i, data.stmt);\n-\t  break;\n-\t}\n-    }\n-\n-  if (mi->min_indirect_level_escape < 2)\n-    return 1;\n-\n-  /* Since we should make sure that the size expression is available\n-     before the call to malloc of level 0.  */\n-  gsi = gsi_for_stmt (call_stmt_0);\n-\n-  /* Find out the size of each dimension by looking at the malloc\n-     sites and create a global variable to hold it.\n-     We add the assignment to the global before the malloc of level 0.  */\n-\n-  /* To be able to produce gimple temporaries.  */\n-  oldfn = current_function_decl;\n-  current_function_decl = mi->allocation_function_decl;\n-  push_cfun (DECL_STRUCT_FUNCTION (mi->allocation_function_decl));\n-\n-  /* Set the dimension sizes as follows:\n-     DIM_SIZE[i] = DIM_SIZE[n] * ... * DIM_SIZE[i]\n-     where n is the maximum non escaping level.  */\n-  element_size = mi->dimension_type_size[mi->min_indirect_level_escape];\n-  prev_dim_size = NULL_TREE;\n-\n-  for (i = mi->min_indirect_level_escape - 1; i >= 0; i--)\n-    {\n-      tree dim_size, dim_var;\n-      gimple stmt;\n-      tree d_type_size;\n-\n-      /* Now put the size expression in a global variable and initialize it to\n-         the size expression before the malloc of level 0.  */\n-      dim_var =\n-\tadd_new_static_var (TREE_TYPE\n-\t\t\t    (mi->dimension_size_orig[mi->dim_map[i]]));\n-      type = TREE_TYPE (mi->dimension_size_orig[mi->dim_map[i]]);\n-\n-      /* DIM_SIZE = MALLOC_SIZE_PARAM / TYPE_SIZE.  */\n-      /* Find which dim ID becomes dim I.  */\n-      for (id = 0; id < mi->min_indirect_level_escape; id++)\n-\tif (mi->dim_map[id] == i)\n-\t  break;\n-       d_type_size =\n-        build_int_cst (type, mi->dimension_type_size[id + 1]);\n-      if (!prev_dim_size)\n-\tprev_dim_size = build_int_cst (type, element_size);\n-      if (!check_transpose_p && i == mi->min_indirect_level_escape - 1)\n-\t{\n-\t  dim_size = mi->dimension_size_orig[id];\n-\t}\n-      else\n-\t{\n-\t  dim_size =\n-\t    fold_build2 (TRUNC_DIV_EXPR, type, mi->dimension_size_orig[id],\n-\t\t\t d_type_size);\n-\n-\t  dim_size = fold_build2 (MULT_EXPR, type, dim_size, prev_dim_size);\n-\t}\n-      dim_size = force_gimple_operand_gsi (&gsi, dim_size, true, NULL,\n-\t\t\t\t\t   true, GSI_SAME_STMT);\n-      /* GLOBAL_HOLDING_THE_SIZE = DIM_SIZE.  */\n-      stmt = gimple_build_assign (dim_var, dim_size);\n-      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-\n-      prev_dim_size = mi->dimension_size[i] = dim_var;\n-    }\n-  update_ssa (TODO_update_ssa);\n-  /* Replace the malloc size argument in the malloc of level 0 to be\n-     the size of all the dimensions.  */\n-  c_node = cgraph_get_node (mi->allocation_function_decl);\n-  gcc_checking_assert (c_node);\n-  old_size_0 = gimple_call_arg (call_stmt_0, 0);\n-  tmp = force_gimple_operand_gsi (&gsi, mi->dimension_size[0], true,\n-\t\t\t\t  NULL, true, GSI_SAME_STMT);\n-  if (TREE_CODE (old_size_0) == SSA_NAME)\n-    {\n-      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, old_size_0)\n-\tFOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\tif (use_stmt == call_stmt_0)\n-\tSET_USE (use_p, tmp);\n-    }\n-  /* When deleting the calls to malloc we need also to remove the edge from\n-     the call graph to keep it consistent.  Notice that cgraph_edge may\n-     create a new node in the call graph if there is no node for the given\n-     declaration; this shouldn't be the case but currently there is no way to\n-     check this outside of \"cgraph.c\".  */\n-  for (i = 1; i < mi->min_indirect_level_escape; i++)\n-    {\n-      gimple_stmt_iterator gsi;\n-\n-      gimple call_stmt = mi->malloc_for_level[i];\n-      gcc_assert (is_gimple_call (call_stmt));\n-      e = cgraph_edge (c_node, call_stmt);\n-      gcc_assert (e);\n-      cgraph_remove_edge (e);\n-      gsi = gsi_for_stmt (call_stmt);\n-      /* Remove the call stmt.  */\n-      gsi_remove (&gsi, true);\n-      /* Remove the assignment of the allocated area.  */\n-      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n-\t\t\t     gimple_call_lhs (call_stmt))\n-      {\n-\tgsi = gsi_for_stmt (use_stmt);\n-\tgsi_remove (&gsi, true);\n-      }\n-    }\n-  update_ssa (TODO_update_ssa);\n-#ifdef ENABLE_CHECKING\n-  verify_ssa (true);\n-#endif\n-  /* Delete the calls to free.  */\n-  for (i = 1; i < mi->min_indirect_level_escape; i++)\n-    {\n-      gimple_stmt_iterator gsi;\n-\n-      /* ??? wonder why this case is possible but we failed on it once.  */\n-      if (!mi->free_stmts[i].stmt)\n-\tcontinue;\n-\n-      c_node = cgraph_get_node (mi->free_stmts[i].func);\n-      gcc_checking_assert (c_node);\n-      gcc_assert (is_gimple_call (mi->free_stmts[i].stmt));\n-      e = cgraph_edge (c_node, mi->free_stmts[i].stmt);\n-      gcc_assert (e);\n-      cgraph_remove_edge (e);\n-      current_function_decl = mi->free_stmts[i].func;\n-      set_cfun (DECL_STRUCT_FUNCTION (mi->free_stmts[i].func));\n-      gsi = gsi_for_stmt (mi->free_stmts[i].stmt);\n-      gsi_remove (&gsi, true);\n-    }\n-  /* Return to the previous situation.  */\n-  current_function_decl = oldfn;\n-  pop_cfun ();\n-  return 1;\n-\n-}\n-\n-\n-/* Print out the results of the escape analysis.  */\n-static int\n-dump_matrix_reorg_analysis (void **slot, void *data ATTRIBUTE_UNUSED)\n-{\n-  struct matrix_info *mi = (struct matrix_info *) *slot;\n-\n-  if (!dump_file)\n-    return 1;\n-  fprintf (dump_file, \"Matrix \\\"%s\\\"; Escaping Level: %d, Num Dims: %d,\",\n-\t   get_name (mi->decl), mi->min_indirect_level_escape, mi->num_dims);\n-  fprintf (dump_file, \" Malloc Dims: %d, \", mi->max_malloced_level);\n-  fprintf (dump_file, \"\\n\");\n-  if (mi->min_indirect_level_escape >= 2)\n-    fprintf (dump_file, \"Flattened %d dimensions \\n\",\n-\t     mi->min_indirect_level_escape);\n-  return 1;\n-}\n-\n-/* Perform matrix flattening.  */\n-\n-static unsigned int\n-matrix_reorg (void)\n-{\n-  struct cgraph_node *node;\n-\n-  if (profile_info)\n-    check_transpose_p = true;\n-  else\n-    check_transpose_p = false;\n-  /* If there are hand written vectors, we skip this optimization.  */\n-  FOR_EACH_FUNCTION (node)\n-    if (!may_flatten_matrices (node))\n-      return 0;\n-  matrices_to_reorg = htab_create (37, mtt_info_hash, mtt_info_eq, mat_free);\n-  /* Find and record all potential matrices in the program.  */\n-  find_matrices_decl ();\n-  /* Analyze the accesses of the matrices (escaping analysis).  */\n-  FOR_EACH_DEFINED_FUNCTION (node)\n-    {\n-      tree temp_fn;\n-\n-      temp_fn = current_function_decl;\n-      current_function_decl = node->symbol.decl;\n-      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n-      bitmap_obstack_initialize (NULL);\n-      gimple_register_cfg_hooks ();\n-\n-      if (!gimple_in_ssa_p (cfun))\n-\t{\n-\t  free_dominance_info (CDI_DOMINATORS);\n-\t  free_dominance_info (CDI_POST_DOMINATORS);\n-\t  pop_cfun ();\n-\t  current_function_decl = temp_fn;\n-\t  bitmap_obstack_release (NULL);\n-\n-\t  return 0;\n-\t}\n-\n-#ifdef ENABLE_CHECKING\n-      verify_flow_info ();\n-#endif\n-\n-      if (!matrices_to_reorg)\n-\t{\n-\t  free_dominance_info (CDI_DOMINATORS);\n-\t  free_dominance_info (CDI_POST_DOMINATORS);\n-\t  pop_cfun ();\n-\t  current_function_decl = temp_fn;\n-\t  bitmap_obstack_release (NULL);\n-\n-\t  return 0;\n-\t}\n-\n-      /* Create htap for phi nodes.  */\n-      htab_mat_acc_phi_nodes = htab_create (37, mat_acc_phi_hash,\n-\t\t\t\t\t    mat_acc_phi_eq, free);\n-      if (!check_transpose_p)\n-\tfind_sites_in_func (false);\n-      else\n-\t{\n-\t  find_sites_in_func (true);\n-\t  loop_optimizer_init (LOOPS_NORMAL);\n-\t  if (current_loops)\n-\t    scev_initialize ();\n-\t  htab_traverse (matrices_to_reorg, analyze_transpose, NULL);\n-\t  if (current_loops)\n-\t    {\n-\t      scev_finalize ();\n-\t      loop_optimizer_finalize ();\n-\t      current_loops = NULL;\n-\t    }\n-\t}\n-      /* If the current function is the allocation function for any of\n-\t the matrices we check its allocation and the escaping level.  */\n-      htab_traverse (matrices_to_reorg, check_allocation_function, NULL);\n-      free_dominance_info (CDI_DOMINATORS);\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-      pop_cfun ();\n-      current_function_decl = temp_fn;\n-      bitmap_obstack_release (NULL);\n-    }\n-  htab_traverse (matrices_to_reorg, transform_allocation_sites, NULL);\n-  /* Now transform the accesses.  */\n-  FOR_EACH_DEFINED_FUNCTION (node)\n-    {\n-      /* Remember that allocation sites have been handled.  */\n-      tree temp_fn;\n-\n-      temp_fn = current_function_decl;\n-      current_function_decl = node->symbol.decl;\n-      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n-      bitmap_obstack_initialize (NULL);\n-      gimple_register_cfg_hooks ();\n-      record_all_accesses_in_func ();\n-      htab_traverse (matrices_to_reorg, transform_access_sites, NULL);\n-      cgraph_rebuild_references ();\n-      free_dominance_info (CDI_DOMINATORS);\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-      pop_cfun ();\n-      current_function_decl = temp_fn;\n-      bitmap_obstack_release (NULL);\n-    }\n-  htab_traverse (matrices_to_reorg, dump_matrix_reorg_analysis, NULL);\n-\n-  current_function_decl = NULL;\n-  set_cfun (NULL);\n-  matrices_to_reorg = NULL;\n-  return 0;\n-}\n-\n-\n-/* The condition for matrix flattening to be performed.  */\n-static bool\n-gate_matrix_reorg (void)\n-{\n-  return flag_ipa_matrix_reorg && flag_whole_program;\n-}\n-\n-struct simple_ipa_opt_pass pass_ipa_matrix_reorg =\n-{\n- {\n-  SIMPLE_IPA_PASS,\n-  \"matrix-reorg\",\t\t/* name */\n-  gate_matrix_reorg,\t\t/* gate */\n-  matrix_reorg,\t\t\t/* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t/* tv_id */\n-  0,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  TODO_dump_symtab      \t/* todo_flags_finish */\n- }\n-};"}, {"sha": "876aa5cc30da92a513633d6945bae4491a3e54ae", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1330,7 +1330,6 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_feedback_split_functions);\n     }\n   NEXT_PASS (pass_ipa_increase_alignment);\n-  NEXT_PASS (pass_ipa_matrix_reorg);\n   NEXT_PASS (pass_ipa_tm);\n   NEXT_PASS (pass_ipa_lower_emutls);\n   *p = NULL;"}, {"sha": "0602c043a29b0fc63b941ddc3df96f050657475f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,3 +1,9 @@\n+2012-08-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/matrix/*.c: Adjust and move ...\n+\t* gcc.dg/torture/: ... here.\n+\t* gcc.dg/matrix: Remove directory.\n+\n 2012-08-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/54219"}, {"sha": "d2e13449ba4fffb39634b6907592020d356fb881", "filename": "gcc/testsuite/gcc.dg/matrix/matrix.exp", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e4850d7e5ab207bf04c389c80ff9bc548f8298/gcc%2Ftestsuite%2Fgcc.dg%2Fmatrix%2Fmatrix.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e4850d7e5ab207bf04c389c80ff9bc548f8298/gcc%2Ftestsuite%2Fgcc.dg%2Fmatrix%2Fmatrix.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmatrix%2Fmatrix.exp?ref=09e4850d7e5ab207bf04c389c80ff9bc548f8298", "patch": "@@ -1,67 +0,0 @@\n-#   Copyright (C) 2001, 2002, 2004, 2005, 2007, 2010, 2011\n-#   Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-# \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-# Test the functionality of programs compiled with profile-directed block\n-# ordering using -fprofile-generate followed by -fbranch-use.\n-load_lib gcc-dg.exp\n-load_lib target-supports.exp\n-\n-set DEFAULT_MATCFLAGS \"-O3 -fipa-matrix-reorg -fdump-ipa-matrix-reorg -fwhole-program -fno-tree-fre\"\n-\n-# Initialize `dg'.\n-dg-init\n-\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/matrix-\\[1-6\\].\\[cS\\]]]  \\\n-        \"\" $DEFAULT_MATCFLAGS\n-\n-dg-final\n-\n-# Some targets don't support tree profiling.\n-if { ![check_profiling_available \"-fprofile-generate\"] } {\n-    return\n-}\n-\n-# The procedures in profopt.exp need these parameters.\n-set tool gcc\n-set prof_ext \"gcda\"\n-\n-if $tracelevel then {\n-    strace $tracelevel\n-}\n-\n-# Load support procs.\n-load_lib profopt.exp\n-\n-# Save and override the default list defined in profopt.exp.\n-set matrix_save_profopt_options $PROFOPT_OPTIONS\n-set PROFOPT_OPTIONS [list {}]\n-\n-# These are globals used by profopt-execute.  The first is options\n-# needed to generate profile data, the second is options to use the\n-# profile data.\n-set profile_option \"-fprofile-generate -O3 -fno-tree-fre\"\n-set feedback_option \"-fprofile-use -fipa-matrix-reorg -fdump-ipa-matrix-reorg -O3 -fwhole-program -fno-tree-fre\"\n-\n-foreach src [lsort [glob -nocomplain $srcdir/$subdir/transpose-*.c]] {\n-    # If we're only testing specific files and this isn't one of them, skip it.\n-    if ![runtest_file_p $runtests $src] then {\n-        continue\n-    }\n-    profopt-execute $src\n-}\n-\n-set PROFOPT_OPTIONS $matrix_save_profopt_options"}, {"sha": "1b88599bdcd16621137b0272f1323e16c05f7c89", "filename": "gcc/testsuite/gcc.dg/torture/matrix-1.c", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-1.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do compile } */\n /* { dg-do run } */\n+/* { dg-options \"-fwhole-program\" } */\n \n #include <stdio.h>\n #include <stdlib.h>\n@@ -88,5 +88,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump-times \"Flattened 3 dimensions\" 1 \"matrix-reorg\"  } } */\n-/* { dg-final { cleanup-ipa-dump \"matrix-reorg\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/matrix/matrix-1.c"}, {"sha": "5013671af5cb22388f660d801319d5d38c4d366e", "filename": "gcc/testsuite/gcc.dg/torture/matrix-2.c", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-2.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do compile } */\n /* { dg-do run } */\n+/* { dg-options \"-fwhole-program\" } */\n \n \n #include <stdio.h>\n@@ -111,5 +111,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump-times \"Flattened 2 dimensions\" 1 \"matrix-reorg\"  } } */\n-/* { dg-final { cleanup-ipa-dump \"matrix-reorg\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/matrix/matrix-2.c"}, {"sha": "c646899a326756fddd8e85df71ee1cc3e6b55509", "filename": "gcc/testsuite/gcc.dg/torture/matrix-3.c", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-3.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -95,5 +95,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump-times \"Flattened 2 dimensions\" 1 \"matrix-reorg\"  } } */\n-/* { dg-final { cleanup-ipa-dump \"matrix-reorg\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/matrix/matrix-3.c"}, {"sha": "586443ce28733031c1aa91abda27fc4cc524d714", "filename": "gcc/testsuite/gcc.dg/torture/matrix-4.c", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-4.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -93,5 +93,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump-times \"Flattened\" 0 \"matrix-reorg\"  } } */\n-/* { dg-final { cleanup-ipa-dump \"matrix-reorg\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/matrix/matrix-4.c"}, {"sha": "9b17567f442187581384578566b7f22ab72eb635", "filename": "gcc/testsuite/gcc.dg/torture/matrix-5.c", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-5.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do compile } */\n /* { dg-do run } */\n+/* { dg-options \"-fwhole-program\" } */\n \n \n #include <stdio.h>\n@@ -94,5 +94,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump-times \"Flattened\" 0 \"matrix-reorg\"  } } */\n-/* { dg-final { cleanup-ipa-dump \"matrix-reorg\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/matrix/matrix-5.c"}, {"sha": "cad63ddabfc6dccf30223b0b87e86a1e72055647", "filename": "gcc/testsuite/gcc.dg/torture/matrix-6.c", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmatrix-6.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,4 +1,5 @@\n-/* { dg-do compile } */\n+/* { dg-do run } */\n+/* { dg-options \"-fwhole-program\" } */\n \n \n #include <stdio.h>\n@@ -40,7 +41,8 @@ main (int argc, char **argv)\n     }\n   for (i = 0; i < ARCHnodes; i++)\n     for (j = 0; j < 3; j++)\n-      free (vel[i][j]);\n+      if (!(i == 1 && j == 0))\n+\tfree (vel[i][j]);\n \n   for (i = 0; i < ARCHnodes; i++)\n     free (vel[i]);\n@@ -93,5 +95,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump-times \"Flattened 2 dimensions\" 1 \"matrix-reorg\"  } } */\n-/* { dg-final { cleanup-ipa-dump \"matrix-reorg\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/matrix/matrix-6.c"}, {"sha": "188f3b51b13d5c7d369d1e131443f2c6c073f1a8", "filename": "gcc/testsuite/gcc.dg/torture/transpose-1.c", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-1.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,3 +1,6 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fwhole-program\" } */\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <math.h>\n@@ -92,7 +95,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump-times \"Flattened 3 dimensions\" 1 \"matrix-reorg\"  } } */\n-/* { dg-final-use { scan-ipa-dump-times \"Transposed\" 3 \"matrix-reorg\"  } } */\n-/* { dg-final-use { cleanup-ipa-dump \"matrix-reorg\" } } */\n-", "previous_filename": "gcc/testsuite/gcc.dg/matrix/transpose-1.c"}, {"sha": "bff6a3ababcd720e6a2d0e7ed10eaab29c59c810", "filename": "gcc/testsuite/gcc.dg/torture/transpose-2.c", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-2.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,3 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fwhole-program\" } */\n \n #include <stdio.h>\n #include <stdlib.h>\n@@ -90,6 +92,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump-times \"Flattened 3 dimensions\" 1 \"matrix-reorg\"  } } */\n-/* { dg-final-use { scan-ipa-dump-times \"Transposed\" 0 \"matrix-reorg\"  } } */\n-/* { dg-final-use { cleanup-ipa-dump \"matrix-reorg\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/matrix/transpose-2.c"}, {"sha": "da7e887013c9ebf3db0b6ccaa655dc4cbbdb65bf", "filename": "gcc/testsuite/gcc.dg/torture/transpose-3.c", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-3.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,3 +1,6 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fwhole-program\" } */\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <math.h>\n@@ -96,6 +99,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump-times \"Flattened 2 dimensions\" 1 \"matrix-reorg\"  } } */\n-/* { dg-final-use { scan-ipa-dump-times \"Transposed\" 2 \"matrix-reorg\"  } } */\n-/* { dg-final-use { cleanup-ipa-dump \"matrix-reorg\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/matrix/transpose-3.c"}, {"sha": "5a96a5163fd97a6b7cfeca4968059a52a2ca180a", "filename": "gcc/testsuite/gcc.dg/torture/transpose-4.c", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-4.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,3 +1,6 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fwhole-program\" } */\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <math.h>\n@@ -95,6 +98,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump-times \"Flattened 3 dimensions\" 1 \"matrix-reorg\"  } } */\n-/* { dg-final-use { scan-ipa-dump-times \"Transposed\" 2 \"matrix-reorg\"  } } */\n-/* { dg-final-use { cleanup-ipa-dump \"matrix-reorg\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/matrix/transpose-4.c"}, {"sha": "049d7b03e23f29e980799986cc37cbe8e741b887", "filename": "gcc/testsuite/gcc.dg/torture/transpose-5.c", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-5.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,3 +1,6 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fwhole-program\" } */\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <math.h>\n@@ -91,6 +94,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump-times \"Flattened 3 dimensions\" 1 \"matrix-reorg\"  } } */\n-/* { dg-final-use { scan-ipa-dump-times \"Transposed\" 0 \"matrix-reorg\"  } } */\n-/* { dg-final-use { cleanup-ipa-dump \"matrix-reorg\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/matrix/transpose-5.c"}, {"sha": "9b3329b536183bbbba311435a1d7dcb1e714ff4f", "filename": "gcc/testsuite/gcc.dg/torture/transpose-6.c", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftranspose-6.c?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -1,3 +1,6 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fwhole-program\" } */\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <math.h>\n@@ -91,6 +94,3 @@ mem_init (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump-times \"Flattened 3 dimensions\" 1 \"matrix-reorg\"  } } */\n-/* { dg-final-use { scan-ipa-dump-times \"Transposed\" 0 \"matrix-reorg\"  } } */\n-/* { dg-final-use { cleanup-ipa-dump \"matrix-reorg\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/matrix/transpose-6.c"}, {"sha": "66319c7d9c9233073fbfd73896ed997ca3503283", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=04f92ff4fcb0f1fd46b2cca65ea04f896ad783f2", "patch": "@@ -372,7 +372,6 @@ extern struct simple_ipa_opt_pass pass_early_local_passes;\n extern struct ipa_opt_pass_d pass_ipa_whole_program_visibility;\n extern struct ipa_opt_pass_d pass_ipa_lto_gimple_out;\n extern struct simple_ipa_opt_pass pass_ipa_increase_alignment;\n-extern struct simple_ipa_opt_pass pass_ipa_matrix_reorg;\n extern struct ipa_opt_pass_d pass_ipa_inline;\n extern struct simple_ipa_opt_pass pass_ipa_free_lang_data;\n extern struct simple_ipa_opt_pass pass_ipa_free_inline_summary;"}]}