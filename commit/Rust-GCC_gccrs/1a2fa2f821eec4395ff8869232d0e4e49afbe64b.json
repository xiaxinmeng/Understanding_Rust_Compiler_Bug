{"sha": "1a2fa2f821eec4395ff8869232d0e4e49afbe64b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEyZmEyZjgyMWVlYzQzOTVmZjg4NjkyMzJkMGU0ZTQ5YWZiZTY0Yg==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2017-05-24T17:06:55Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2017-05-24T17:06:55Z"}, "message": "When lra-remat rematerializes an instruction with a clobber, it checks that the clobber does not kill live registers.\n\nWhen lra-remat rematerializes an instruction with a clobber, it checks\nthat the clobber does not kill live registers.  However it fails to check\nthat the clobber also doesn't overlap with the destination register of the\nfinal rematerialized instruction.  As a result it is possible to generate\nillegal instructions with the same hard register as the destination and a\nclobber.  Fix this by also checking for overlaps with the destination\nregister.\n\n    gcc/\n\tPR rtl-optimization/80754\n\t* lra-remat.c (do_remat): Add overlap checks for dst_regno.\n\nFrom-SVN: r248424", "tree": {"sha": "3947dcce7024d126e21371e663b2a9aa5f9c6d78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3947dcce7024d126e21371e663b2a9aa5f9c6d78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a2fa2f821eec4395ff8869232d0e4e49afbe64b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a2fa2f821eec4395ff8869232d0e4e49afbe64b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a2fa2f821eec4395ff8869232d0e4e49afbe64b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a2fa2f821eec4395ff8869232d0e4e49afbe64b/comments", "author": null, "committer": null, "parents": [{"sha": "c0edbb32c15b1c5c2145294641e1dec688d23adc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0edbb32c15b1c5c2145294641e1dec688d23adc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0edbb32c15b1c5c2145294641e1dec688d23adc"}], "stats": {"total": 27, "additions": 24, "deletions": 3}, "files": [{"sha": "1b70fa034b26b6c5c199b3b5379e618e09f135e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2fa2f821eec4395ff8869232d0e4e49afbe64b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2fa2f821eec4395ff8869232d0e4e49afbe64b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a2fa2f821eec4395ff8869232d0e4e49afbe64b", "patch": "@@ -1,3 +1,8 @@\n+2017-05-24  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\tPR rtl-optimization/80754\n+\t* lra-remat.c (do_remat): Add overlap checks for dst_regno.\n+\n 2017-05-24  Sheldon Lobo  <smlobo@sheldon.us.oracle.com>\n \n \t* config/sparc/sparc.md (length): Return the correct value for -mflat"}, {"sha": "f28993e818d1eff2f5742731628b10f0184f7639", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2fa2f821eec4395ff8869232d0e4e49afbe64b/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2fa2f821eec4395ff8869232d0e4e49afbe64b/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=1a2fa2f821eec4395ff8869232d0e4e49afbe64b", "patch": "@@ -1117,6 +1117,7 @@ do_remat (void)\n \t\t  break;\n \t    }\n \t  int i, hard_regno, nregs;\n+\t  int dst_hard_regno, dst_nregs;\n \t  rtx_insn *remat_insn = NULL;\n \t  HOST_WIDE_INT cand_sp_offset = 0;\n \t  if (cand != NULL)\n@@ -1131,6 +1132,12 @@ do_remat (void)\n \t      gcc_assert (REG_P (saved_op));\n \t      int ignore_regno = REGNO (saved_op); \n \n+\t      dst_hard_regno = dst_regno < FIRST_PSEUDO_REGISTER\n+\t\t? dst_regno : reg_renumber[dst_regno];\n+\t      gcc_assert (dst_hard_regno >= 0);\n+\t      machine_mode mode = GET_MODE (SET_DEST (set));\n+\t      dst_nregs = hard_regno_nregs[dst_hard_regno][mode];\n+\n \t      for (reg = cand_id->regs; reg != NULL; reg = reg->next)\n \t\tif (reg->type != OP_IN && reg->regno != ignore_regno)\n \t\t  {\n@@ -1141,16 +1148,25 @@ do_remat (void)\n \t\t\tbreak;\n \t\t    if (i < nregs)\n \t\t      break;\n+\t\t    /* Ensure the clobber also doesn't overlap dst_regno.  */\n+\t\t    if (hard_regno + nregs > dst_hard_regno\n+\t\t\t&& hard_regno < dst_hard_regno + dst_nregs)\n+\t\t      break;\n \t\t  }\n \n \t      if (reg == NULL)\n \t\t{\n \t\t  for (reg = static_cand_id->hard_regs;\n \t\t       reg != NULL;\n \t\t       reg = reg->next)\n-\t\t    if (reg->type != OP_IN\n-\t\t\t&& TEST_HARD_REG_BIT (live_hard_regs, reg->regno))\n-\t\t      break;\n+\t\t    if (reg->type != OP_IN)\n+\t\t      {\n+\t\t\tif (TEST_HARD_REG_BIT (live_hard_regs, reg->regno))\n+\t\t\t  break;\n+\t\t\tif (reg->regno >= dst_hard_regno\n+\t\t\t    && reg->regno < dst_hard_regno + dst_nregs)\n+\t\t\t  break;\n+\t\t      }\n \t\t}\n \n \t      if (reg == NULL)"}]}