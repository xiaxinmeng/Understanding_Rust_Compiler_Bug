{"sha": "37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdiYmYyYjhjYmQ0NTc4ZjBmYmU3Y2JiZDU3MzQ5MzQ4MWY2MmE0NQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-11-10T04:22:20Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:26Z"}, "message": "Added cfg stripping for some expressions\n\nAttempt to fix compile error", "tree": {"sha": "0adb716f3dc73607e30175d1b55267f01d4341f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0adb716f3dc73607e30175d1b55267f01d4341f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "164e38246f0f469fa83f5fa3f56fc53fa1b46450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/164e38246f0f469fa83f5fa3f56fc53fa1b46450", "html_url": "https://github.com/Rust-GCC/gccrs/commit/164e38246f0f469fa83f5fa3f56fc53fa1b46450"}], "stats": {"total": 1111, "additions": 951, "deletions": 160}, "files": [{"sha": "87cf828091aab960e41c34f4d398f18bd747483c", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "patch": "@@ -158,7 +158,7 @@ void\n TypeResolution::visit (AST::IdentifierExpr &ident_expr)\n {\n   AST::Type *type = NULL;\n-  bool ok = scope.LookupType (ident_expr.ident, &type);\n+  bool ok = scope.LookupType (ident_expr.get_ident (), &type);\n   if (!ok)\n     {\n       rust_error_at (ident_expr.get_locus (), \"unknown identifier\");\n@@ -235,7 +235,7 @@ void\n TypeResolution::visit (AST::LiteralExpr &expr)\n {\n   std::string type;\n-  switch (expr.literal.get_lit_type ())\n+  switch (expr.get_lit_type ())\n     {\n     case AST::Literal::CHAR:\n       type = \"char\";\n@@ -273,7 +273,7 @@ TypeResolution::visit (AST::LiteralExpr &expr)\n   if (type.empty ())\n     {\n       rust_error_at (expr.get_locus (), \"unknown literal: %s\",\n-\t\t     expr.literal.as_string ().c_str ());\n+\t\t     expr.get_literal ().as_string ().c_str ());\n       return;\n     }\n \n@@ -338,7 +338,7 @@ TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n   // scope will require knowledge of the type\n \n   // do the lhsType and the rhsType match\n-  typesAreCompatible (lhsType, rhsType, expr.right_expr->get_locus_slow ());\n+  typesAreCompatible (lhsType, rhsType, expr.get_right_expr ()->get_locus_slow ());\n }\n \n void\n@@ -382,7 +382,7 @@ TypeResolution::visit (AST::AssignmentExpr &expr)\n \n   // do the lhsType and the rhsType match\n   if (!typesAreCompatible (lhsType, rhsType,\n-\t\t\t   expr.right_expr->get_locus_slow ()))\n+\t\t\t   expr.get_right_expr ()->get_locus_slow ()))\n     return;\n \n   // is the lhs mutable?\n@@ -469,7 +469,7 @@ TypeResolution::visit (AST::StructExprStructFields &expr)\n       if (identifierBuffer != NULL)\n \t{\n \t  AST::StructField *declField = NULL;\n-\t  for (auto &df : decl->fields)\n+\t  for (auto &df : decl->get_fields ())\n \t    {\n \t      if (identifierBuffer->compare (df.field_name) == 0)\n \t\t{\n@@ -493,9 +493,9 @@ TypeResolution::visit (AST::StructExprStructFields &expr)\n       else if (tupleIndexBuffer != NULL)\n \t{\n \t  AST::StructField *declField = NULL;\n-\t  if (*tupleIndexBuffer < decl->fields.size ())\n+\t  if (*tupleIndexBuffer < decl->get_fields ().size ())\n \t    {\n-\t      declField = &decl->fields[*tupleIndexBuffer];\n+\t      declField = &decl->get_fields ()[*tupleIndexBuffer];\n \t    }\n \t  tupleIndexBuffer = NULL;\n \n@@ -811,7 +811,7 @@ TypeResolution::visit (AST::TypeAlias &type_alias)\n void\n TypeResolution::visit (AST::StructStruct &struct_item)\n {\n-  for (auto &field : struct_item.fields)\n+  for (auto &field : struct_item.get_fields ())\n     {\n       if (!isTypeInScope (field.field_type.get (),\n \t\t\t  Linemap::unknown_location ()))"}, {"sha": "c186f22661b09c704c006862ed0deecdb58db5ac", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "patch": "@@ -810,7 +810,9 @@ class Expr\n   std::vector<Attribute> outer_attrs;\n \n public:\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n   // Unique pointer custom clone function\n   std::unique_ptr<Expr> clone_expr () const\n@@ -905,11 +907,10 @@ class ExprWithoutBlock : public Expr\n  */\n class IdentifierExpr : public ExprWithoutBlock\n {\n-public:\n   Identifier ident;\n-\n   Location locus;\n \n+public:\n   IdentifierExpr (Identifier ident, Location locus = Location (),\n \t\t  std::vector<Attribute> outer_attrs\n \t\t  = std::vector<Attribute> ())\n@@ -922,6 +923,8 @@ class IdentifierExpr : public ExprWithoutBlock\n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const override { return get_locus (); }\n \n+  Identifier get_ident () const { return ident; }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Clones this object.\n@@ -1385,6 +1388,10 @@ class MacroInvocationSemi : public MacroItem,\n   void mark_for_strip () override { path = SimplePath::create_empty (); }\n   bool is_marked_for_strip () const override { return path.is_empty (); }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n protected:\n   MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n   {"}, {"sha": "a92a8ad4c5c12c04de74fd710a62dbfce6ce5f09", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 139, "deletions": 14, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "patch": "@@ -41,10 +41,10 @@ class ExprWithBlock : public Expr\n // Literals? Or literal base?\n class LiteralExpr : public ExprWithoutBlock\n {\n-public:\n   Literal literal;\n   Location locus;\n \n+public:\n   std::string as_string () const override { return literal.as_string (); }\n \n   Literal::LitType get_lit_type () const { return literal.get_lit_type (); }\n@@ -71,6 +71,8 @@ class LiteralExpr : public ExprWithoutBlock\n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const override { return get_locus (); }\n \n+  Literal get_literal () const { return literal; }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if literal is in error state, so base stripping on that.\n@@ -118,10 +120,7 @@ class AttrInputLiteral : public AttrInput\n   /* this can never be a cfg predicate - cfg and cfg_attr require a token-tree\n    * cfg */\n   bool\n-  check_cfg_predicate (const Session&) const override\n-  {\n-    return false;\n-  }\n+  check_cfg_predicate (const Session&) const override { return false; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -264,6 +263,12 @@ class BorrowExpr : public OperatorExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_borrowed_expr () {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -287,6 +292,12 @@ class DereferenceExpr : public OperatorExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_dereferenced_expr () {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -311,6 +322,12 @@ class ErrorPropagationExpr : public OperatorExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_propagating_expr () {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -330,6 +347,7 @@ class NegationExpr : public OperatorExpr\n     NOT\n   };\n \n+private:\n   /* Note: overload negation via std::ops::Neg and not via std::ops::Not\n    * Negation only works for signed integer and floating-point types, NOT only\n    * works for boolean and integer types (via bitwise NOT) */\n@@ -350,7 +368,11 @@ class NegationExpr : public OperatorExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  Expr *get_expr () { return main_or_left_expr.get (); }\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_negated_expr () {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -379,6 +401,7 @@ class ArithmeticOrLogicalExpr : public OperatorExpr\n     RIGHT_SHIFT\t // std::ops::Shr\n   };\n \n+private:\n   // Note: overloading trait specified in comments\n   ExprType expr_type;\n \n@@ -422,7 +445,17 @@ class ArithmeticOrLogicalExpr : public OperatorExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  Expr *get_lhs () { return main_or_left_expr.get (); }\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_left_expr () {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_right_expr () {\n+    rust_assert (right_expr != nullptr);\n+    return right_expr;\n+  }\n \n   void visit_lhs (ASTVisitor &vis) { main_or_left_expr->accept_vis (vis); }\n   void visit_rhs (ASTVisitor &vis) { right_expr->accept_vis (vis); }\n@@ -450,6 +483,7 @@ class ComparisonExpr : public OperatorExpr\n     LESS_OR_EQUAL     // std::cmp::PartialEq::le\n   };\n \n+private:\n   // Note: overloading trait specified in comments\n   ExprType expr_type;\n \n@@ -493,7 +527,17 @@ class ComparisonExpr : public OperatorExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  Expr *get_lhs () { return main_or_left_expr.get (); }\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_left_expr () {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_right_expr () {\n+    rust_assert (right_expr != nullptr);\n+    return right_expr;\n+  }\n \n   /* TODO: implement via a function call to std::cmp::PartialEq::eq(&op1, &op2)\n    * maybe? */\n@@ -516,6 +560,7 @@ class LazyBooleanExpr : public OperatorExpr\n     LOGICAL_AND\n   };\n \n+private:\n   ExprType expr_type;\n \n   std::unique_ptr<Expr> right_expr;\n@@ -558,7 +603,17 @@ class LazyBooleanExpr : public OperatorExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  Expr *get_lhs () { return main_or_left_expr.get (); }\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_left_expr () {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_right_expr () {\n+    rust_assert (right_expr != nullptr);\n+    return right_expr;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -602,12 +657,18 @@ class TypeCastExpr : public OperatorExpr\n     return *this;\n   }\n \n-  // move constructors as not supported in c++03\n+  // move constructors \n   TypeCastExpr (TypeCastExpr &&other) = default;\n   TypeCastExpr &operator= (TypeCastExpr &&other) = default;\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_casted_expr () {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -620,9 +681,9 @@ class TypeCastExpr : public OperatorExpr\n // Binary assignment expression.\n class AssignmentExpr : public OperatorExpr\n {\n-public:\n   std::unique_ptr<Expr> right_expr;\n \n+public:\n   std::string as_string () const override;\n \n   // Call OperatorExpr constructor to initialise left_expr\n@@ -659,7 +720,17 @@ class AssignmentExpr : public OperatorExpr\n   void visit_lhs (ASTVisitor &vis) { main_or_left_expr->accept_vis (vis); }\n   void visit_rhs (ASTVisitor &vis) { right_expr->accept_vis (vis); }\n \n-  Expr *get_lhs () { return main_or_left_expr.get (); }\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_left_expr () {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_right_expr () {\n+    rust_assert (right_expr != nullptr);\n+    return right_expr;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -733,6 +804,18 @@ class CompoundAssignmentExpr : public OperatorExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_left_expr () {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_right_expr () {\n+    rust_assert (right_expr != nullptr);\n+    return right_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -753,7 +836,8 @@ class GroupedExpr : public ExprWithoutBlock\n public:\n   std::string as_string () const override;\n \n-  std::vector<Attribute> get_inner_attrs () const { return inner_attrs; }\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n   GroupedExpr (std::unique_ptr<Expr> parenthesised_expr,\n \t       std::vector<Attribute> inner_attribs,\n@@ -803,6 +887,12 @@ class GroupedExpr : public ExprWithoutBlock\n   void mark_for_strip () override { expr_in_parens = nullptr; }\n   bool is_marked_for_strip () const override { return expr_in_parens == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_expr_in_parens () {\n+    rust_assert (expr_in_parens != nullptr);\n+    return expr_in_parens;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -872,6 +962,10 @@ class ArrayElemsValues : public ArrayElems\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<std::unique_ptr<Expr> > &get_values () const { return values; }\n+  std::vector<std::unique_ptr<Expr> > &get_values () { return values; }\n+\n protected:\n   ArrayElemsValues *clone_array_elems_impl () const override\n   {\n@@ -918,6 +1012,18 @@ class ArrayElemsCopied : public ArrayElems\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_elem_to_copy () {\n+    rust_assert (elem_to_copy != nullptr);\n+    return elem_to_copy;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_num_copies () {\n+    rust_assert (num_copies != nullptr);\n+    return num_copies;\n+  }\n+\n protected:\n   ArrayElemsCopied *clone_array_elems_impl () const override\n   {\n@@ -939,7 +1045,8 @@ class ArrayExpr : public ExprWithoutBlock\n public:\n   std::string as_string () const override;\n \n-  std::vector<Attribute> get_inner_attrs () const { return inner_attrs; }\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n   // Returns whether array expr has array elems or if it is just empty.\n   bool has_array_elems () const { return internal_elements != nullptr; }\n@@ -992,6 +1099,12 @@ class ArrayExpr : public ExprWithoutBlock\n   void mark_for_strip () override { marked_for_strip = true; }\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<ArrayElems> &get_array_elems () {\n+    rust_assert (internal_elements != nullptr);\n+    return internal_elements;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1068,6 +1181,18 @@ class ArrayIndexExpr : public ExprWithoutBlock\n   void mark_for_strip () override { array_expr = nullptr; index_expr = nullptr; }\n   bool is_marked_for_strip () const override { return array_expr == nullptr && index_expr == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_array_expr () {\n+    rust_assert (array_expr != nullptr);\n+    return array_expr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_index_expr () {\n+    rust_assert (index_expr != nullptr);\n+    return index_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "8a85edad651b72d5a1e9acbae9716d0a170b3b77", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 99, "deletions": 5, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "patch": "@@ -733,6 +733,19 @@ class Method : public InherentImplItem, public TraitImplItem\n   void mark_for_strip () override { function_body = nullptr; }\n   bool is_marked_for_strip () const override { return function_body == nullptr; }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  std::vector<FunctionParam> &get_function_params () { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_definition () {\n+    rust_assert (function_body != nullptr);\n+    return function_body;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -879,6 +892,13 @@ class ModuleBodied : public Module\n    * the module. */\n   void add_crate_name (std::vector<std::string> &names) const override;\n \n+  // TODO: think of better way to do this - mutable getter seems dodgy\n+  const std::vector<Attribute>& get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute>& get_inner_attrs () { return inner_attrs; }\n+\n+  const std::vector<std::unique_ptr<Item>>& get_items () const { return items; }\n+  std::vector<std::unique_ptr<Item>>& get_items () { return items; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1366,6 +1386,16 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n   void mark_for_strip () override { function_body = nullptr; }\n   bool is_marked_for_strip () const override { return function_body == nullptr; }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<FunctionParam> &get_function_params () { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_definition () {\n+    rust_assert (function_body != nullptr);\n+    return function_body;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1637,10 +1667,10 @@ struct StructField\n // Rust struct declaration with true struct type AST node\n class StructStruct : public Struct\n {\n-public:\n   std::vector<StructField> fields;\n   bool is_unit;\n \n+public:\n   std::string as_string () const override;\n \n   // Mega-constructor with all possible fields\n@@ -1672,6 +1702,10 @@ class StructStruct : public Struct\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<StructField> &get_fields () { return fields; }\n+  const std::vector<StructField> &get_fields () const { return fields; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1712,19 +1746,27 @@ struct TupleField\n \n   // Copy constructor with clone\n   TupleField (TupleField const &other)\n-    : outer_attrs (other.outer_attrs), visibility (other.visibility),\n-      field_type (other.field_type->clone_type ())\n-  {}\n+    : outer_attrs (other.outer_attrs), visibility (other.visibility)\n+  {\n+    // guard to prevent null dereference (only required if error)\n+    if (other.field_type != nullptr)\n+      field_type = other.field_type->clone_type ();\n+  }\n \n   ~TupleField () = default;\n \n   // Overloaded assignment operator to clone\n   TupleField &operator= (TupleField const &other)\n   {\n-    field_type = other.field_type->clone_type ();\n     visibility = other.visibility;\n     outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error)\n+    if (other.field_type != nullptr)\n+      field_type = other.field_type->clone_type ();\n+    else\n+      field_type = nullptr;\n+\n     return *this;\n   }\n \n@@ -1742,6 +1784,10 @@ struct TupleField\n   }\n \n   std::string as_string () const;\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n };\n \n // Rust tuple declared using struct keyword AST node\n@@ -1765,6 +1811,10 @@ class TupleStruct : public Struct\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<TupleField> &get_fields () { return fields; }\n+  const std::vector<TupleField> &get_fields () const { return fields; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1808,6 +1858,14 @@ class EnumItem\n   // not pure virtual as not abstract\n   virtual void accept_vis (ASTVisitor &vis);\n \n+  // Based on idea that name is never empty.\n+  void mark_for_strip () { variant_name = \"\"; }\n+  bool is_marked_for_strip () const { return variant_name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   virtual EnumItem *clone_enum_item_impl () const\n@@ -1836,6 +1894,10 @@ class EnumItemTuple : public EnumItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<TupleField> &get_tuple_fields () { return tuple_fields; }\n+  const std::vector<TupleField> &get_tuple_fields () const { return tuple_fields; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   EnumItemTuple *clone_enum_item_impl () const override\n@@ -1865,6 +1927,10 @@ class EnumItemStruct : public EnumItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<StructField> &get_struct_fields () { return struct_fields; }\n+  const std::vector<StructField> &get_struct_fields () const { return struct_fields; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   EnumItemStruct *clone_enum_item_impl () const override\n@@ -1909,6 +1975,12 @@ class EnumItemDiscriminant : public EnumItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_expr () {\n+    rust_assert (expression != nullptr);\n+    return expression;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   EnumItemDiscriminant *clone_enum_item_impl () const override\n@@ -2005,6 +2077,10 @@ class Enum : public VisItem\n   void mark_for_strip () override { enum_name = \"\"; }\n   bool is_marked_for_strip () const override { return enum_name.empty (); }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<std::unique_ptr<EnumItem>> &get_variants () { return items; }\n+  const std::vector<std::unique_ptr<EnumItem>> &get_variants () const { return items; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2169,6 +2245,12 @@ class ConstantItem : public VisItem,\n   void mark_for_strip () override { type = nullptr; const_expr = nullptr; }\n   bool is_marked_for_strip () const override { return type == nullptr && const_expr == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_expr () {\n+    rust_assert (const_expr != nullptr);\n+    return const_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2258,6 +2340,12 @@ class StaticItem : public VisItem\n   void mark_for_strip () override { type = nullptr; expr = nullptr; }\n   bool is_marked_for_strip () const override { return type == nullptr && expr == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_expr () {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2715,6 +2803,12 @@ class TraitItemConst : public TraitItem\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_expr () {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemConst *clone_trait_item_impl () const override"}, {"sha": "2a97854c1bf358a5f70162e1ee20f0db00e2efff", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "patch": "@@ -315,6 +315,10 @@ class MacroRulesDefinition : public MacroItem\n   void mark_for_strip () override { rule_name = \"\"; }\n   bool is_marked_for_strip () const override { return rule_name.empty (); }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "c59e6bd269b8983c97f13edfaf22ab8d1312f7f1", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "patch": "@@ -328,7 +328,6 @@ class TypePathSegment\n    * GenericArgs are, so could disallow that in constructor, which won't give\n    * that much size overhead. */\n   PathIdentSegment ident_segment;\n-\n   Location locus;\n \n protected:"}, {"sha": "f7c47d7191b96847ec4e7ee338668f036703b0f8", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "patch": "@@ -38,10 +38,10 @@ class EmptyStmt : public Stmt\n  * introduces new name into scope */\n class LetStmt : public Stmt\n {\n-public:\n   // bool has_outer_attrs;\n   std::vector<Attribute> outer_attrs;\n \n+public:\n   std::unique_ptr<Pattern> variables_pattern;\n \n   // bool has_type;\n@@ -125,6 +125,16 @@ class LetStmt : public Stmt\n   void mark_for_strip () override { variables_pattern = nullptr; }\n   bool is_marked_for_strip () const override { return variables_pattern == nullptr; }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_init_expr () {\n+    rust_assert (init_expr != nullptr);\n+    return init_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -204,6 +214,12 @@ class ExprStmtWithoutBlock : public ExprStmt\n   void mark_for_strip () override { expr = nullptr; }\n   bool is_marked_for_strip () const override { return expr == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<ExprWithoutBlock> &get_expr () {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -260,6 +276,12 @@ class ExprStmtWithBlock : public ExprStmt\n   void mark_for_strip () override { expr = nullptr; }\n   bool is_marked_for_strip () const override { return expr == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<ExprWithBlock> &get_expr () {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "0589347c18d83cc883ff382239d3a05caab2d4ad", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "patch": "@@ -246,7 +246,7 @@ void\n Compilation::visit (AST::LiteralExpr &expr)\n {\n   Bexpression *compiled;\n-  switch (expr.literal.get_lit_type ())\n+  switch (expr.get_lit_type ())\n     {\n     case AST::Literal::BOOL:\n       compiled = compileBooleanLiteral (expr.as_string ());\n@@ -293,16 +293,16 @@ void\n Compilation::visit (AST::NegationExpr &expr)\n {\n   Bexpression *root = NULL;\n-  VISIT_POP (expr.get_expr ()->get_locus_slow (), expr.get_expr (), root,\n+  VISIT_POP (expr.get_negated_expr ()->get_locus_slow (), expr.get_negated_expr ().get (), root,\n \t     exprs);\n   if (root == NULL)\n     {\n-      rust_error_at (expr.get_expr ()->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_negated_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Operator op;\n-  switch (expr.negation_type)\n+  switch (expr.get_negation_type ())\n     {\n     case AST::NegationExpr::NEGATE:\n       op = OPERATOR_MINUS;\n@@ -323,23 +323,23 @@ void\n Compilation::visit (AST::ArithmeticOrLogicalExpr &expr)\n {\n   Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_lhs ()->get_locus_slow (), expr.get_lhs (), lhs, exprs);\n+  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n   if (lhs == NULL)\n     {\n-      rust_error_at (expr.get_lhs ()->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Bexpression *rhs = NULL;\n-  VISIT_POP (expr.right_expr->get_locus_slow (), expr.right_expr, rhs, exprs);\n+  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n   if (rhs == NULL)\n     {\n-      rust_error_at (expr.right_expr->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Operator op;\n-  switch (expr.expr_type)\n+  switch (expr.get_expr_type ())\n     {\n     case AST::ArithmeticOrLogicalExpr::ADD:\n       op = OPERATOR_PLUS;\n@@ -385,23 +385,23 @@ void\n Compilation::visit (AST::ComparisonExpr &expr)\n {\n   Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_lhs ()->get_locus_slow (), expr.get_lhs (), lhs, exprs);\n+  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n   if (lhs == NULL)\n     {\n-      rust_error_at (expr.get_lhs ()->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Bexpression *rhs = NULL;\n-  VISIT_POP (expr.right_expr->get_locus_slow (), expr.right_expr, rhs, exprs);\n+  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n   if (rhs == NULL)\n     {\n-      rust_error_at (expr.right_expr->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Operator op;\n-  switch (expr.expr_type)\n+  switch (expr.get_expr_type ())\n     {\n     case AST::ComparisonExpr::EQUAL:\n       op = OPERATOR_EQEQ;\n@@ -435,23 +435,23 @@ void\n Compilation::visit (AST::LazyBooleanExpr &expr)\n {\n   Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_lhs ()->get_locus_slow (), expr.get_lhs (), lhs, exprs);\n+  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n   if (lhs == NULL)\n     {\n-      rust_error_at (expr.get_lhs ()->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Bexpression *rhs = NULL;\n-  VISIT_POP (expr.right_expr->get_locus_slow (), expr.right_expr, rhs, exprs);\n+  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n   if (rhs == NULL)\n     {\n-      rust_error_at (expr.right_expr->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Operator op;\n-  switch (expr.expr_type)\n+  switch (expr.get_expr_type ())\n     {\n     case AST::LazyBooleanExpr::LOGICAL_OR:\n       op = OPERATOR_OROR;\n@@ -477,18 +477,18 @@ void\n Compilation::visit (AST::AssignmentExpr &expr)\n {\n   Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_lhs ()->get_locus_slow (), expr.get_lhs (), lhs, exprs);\n+  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n   if (lhs == NULL)\n     {\n-      rust_error_at (expr.get_lhs ()->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n   Bexpression *rhs = NULL;\n-  VISIT_POP (expr.right_expr->get_locus_slow (), expr.right_expr, rhs, exprs);\n+  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n   if (rhs == NULL)\n     {\n-      rust_error_at (expr.right_expr->get_locus_slow (), \"failed to compile\");\n+      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n       return;\n     }\n \n@@ -536,7 +536,7 @@ Compilation::visit (AST::StructExprFieldIdentifierValue &field)\n   AST::StructStruct *decl = structBuffer.back ();\n   size_t index = 0;\n   bool found = false;\n-  for (auto &df : decl->fields)\n+  for (auto &df : decl->get_fields ())\n     {\n       if (field.field_name.compare (df.field_name) == 0)\n \t{\n@@ -1089,7 +1089,7 @@ void\n Compilation::visit (AST::StructStruct &struct_item)\n {\n   std::vector<Backend::Btyped_identifier> fields;\n-  for (auto &field : struct_item.fields)\n+  for (auto &field : struct_item.get_fields ())\n     {\n       translatedType = NULL;\n       field.field_type->accept_vis (*this);"}, {"sha": "164b5a53fb3d238caab946ea8eaf8c936e59f526", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 643, "deletions": 103, "changes": 746, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "patch": "@@ -13,62 +13,338 @@ namespace Rust {\n         AttrVisitor(MacroExpander& expander) : expander(expander) {}\n \n         void expand_struct_fields(std::vector<AST::StructField>& fields) {\n-            for (int i = 0; i < fields.size(); ) {\n-                auto& field_attrs = fields[i].get_outer_attrs ();\n+            for (int i = 0; i < fields.size();) {\n+                auto& field_attrs = fields[i].get_outer_attrs();\n                 expander.expand_cfg_attrs(field_attrs);\n-                if (expander.fails_cfg (field_attrs))\n-                    fields.erase (fields.begin() + i);\n+                if (expander.fails_cfg(field_attrs))\n+                    fields.erase(fields.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+\n+        void expand_tuple_fields(std::vector<AST::TupleField>& fields) {\n+            for (int i = 0; i < fields.size();) {\n+                auto& field_attrs = fields[i].get_outer_attrs();\n+                expander.expand_cfg_attrs(field_attrs);\n+                if (expander.fails_cfg(field_attrs))\n+                    fields.erase(fields.begin() + i);\n                 else\n                     i++;\n             }\n         }\n \n         void expand_function_params(std::vector<AST::FunctionParam>& params) {\n-            for (int i = 0; i < params.size(); ) {\n-                auto& param_attrs = params[i].get_outer_attrs ();\n+            for (int i = 0; i < params.size();) {\n+                auto& param_attrs = params[i].get_outer_attrs();\n                 expander.expand_cfg_attrs(param_attrs);\n-                if (expander.fails_cfg (param_attrs))\n-                    params.erase (params.begin() + i);\n+                if (expander.fails_cfg(param_attrs))\n+                    params.erase(params.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+\n+        void visit(AST::Token& tok) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::DelimTokenTree& delim_tok_tree) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::AttrInputMetaItemContainer& input) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::IdentifierExpr& ident_expr) override {\n+            // strip test based on outer attrs\n+            expander.expand_cfg_attrs(ident_expr.get_outer_attrs());\n+            if (expander.fails_cfg(ident_expr.get_outer_attrs())) {\n+                ident_expr.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::Lifetime& lifetime) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::LifetimeParam& lifetime_param) override {\n+            // supposedly does not require - cfg does nothing\n+        }\n+        void visit(AST::MacroInvocationSemi& macro_invoc) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(macro_invoc.get_outer_attrs());\n+            if (expander.fails_cfg(macro_invoc.get_outer_attrs())) {\n+                macro_invoc.mark_for_strip();\n+                return;\n+            }\n+\n+            // I don't think any macro token trees can be stripped in any way\n+        }\n+\n+        void visit(AST::PathInExpression& path) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(path.get_outer_attrs());\n+            if (expander.fails_cfg(path.get_outer_attrs())) {\n+                path.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::TypePathSegment& segment) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::TypePathSegmentGeneric& segment) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::TypePathSegmentFunction& segment) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::TypePath& path) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::QualifiedPathInExpression& path) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(path.get_outer_attrs());\n+            if (expander.fails_cfg(path.get_outer_attrs())) {\n+                path.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::QualifiedPathInType& path) override {\n+            // shouldn't require?\n+        }\n+\n+        void visit(AST::LiteralExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::AttrInputLiteral& attr_input) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::MetaItemLitExpr& meta_item) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::MetaItemPathLit& meta_item) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::BorrowExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip any internal sub-expressions - expression itself isn't\n+             * allowed to have external attributes in this position so can't be\n+             * stripped. */\n+            expr.get_borrowed_expr()->accept_vis(*this);\n+        }\n+        void visit(AST::DereferenceExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip any internal sub-expressions - expression itself isn't\n+             * allowed to have external attributes in this position so can't be\n+             * stripped. */\n+            expr.get_dereferenced_expr()->accept_vis(*this);\n+        }\n+        void visit(AST::ErrorPropagationExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip any internal sub-expressions - expression itself isn't\n+             * allowed to have external attributes in this position so can't be\n+             * stripped. */\n+            expr.get_propagating_expr()->accept_vis(*this);\n+        }\n+        void visit(AST::NegationExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip any internal sub-expressions - expression itself isn't\n+             * allowed to have external attributes in this position so can't be\n+             * stripped. */\n+            expr.get_negated_expr()->accept_vis(*this);\n+        }\n+        void visit(AST::ArithmeticOrLogicalExpr& expr) override {\n+            /* outer attributes never allowed before these. while cannot strip \n+             * two direct descendant expressions, can strip ones below that */\n+\n+            /* should have no possibility for outer attrs as would be parsed \n+             * with outer expr */\n+            expr.get_left_expr()->accept_vis(*this);\n+            /* should syntactically not have outer attributes, though this may \n+             * not have worked in practice */\n+            expr.get_right_expr()->accept_vis(*this);\n+\n+            // ensure that they are not marked for strip\n+            rust_assert(!expr.get_left_expr()->is_marked_for_strip());\n+            rust_assert(!expr.get_right_expr()->is_marked_for_strip());\n+        }\n+        void visit(AST::ComparisonExpr& expr) override {\n+            /* outer attributes never allowed before these. while cannot strip \n+             * two direct descendant expressions, can strip ones below that */\n+\n+            /* should have no possibility for outer attrs as would be parsed \n+             * with outer expr */\n+            expr.get_left_expr()->accept_vis(*this);\n+            /* should syntactically not have outer attributes, though this may \n+             * not have worked in practice */\n+            expr.get_right_expr()->accept_vis(*this);\n+\n+            // ensure that they are not marked for strip\n+            rust_assert(!expr.get_left_expr()->is_marked_for_strip());\n+            rust_assert(!expr.get_right_expr()->is_marked_for_strip());\n+        }\n+        void visit(AST::LazyBooleanExpr& expr) override {\n+            /* outer attributes never allowed before these. while cannot strip \n+             * two direct descendant expressions, can strip ones below that */\n+\n+            /* should have no possibility for outer attrs as would be parsed \n+             * with outer expr */\n+            expr.get_left_expr()->accept_vis(*this);\n+            /* should syntactically not have outer attributes, though this may \n+             * not have worked in practice */\n+            expr.get_right_expr()->accept_vis(*this);\n+\n+            // ensure that they are not marked for strip\n+            rust_assert(!expr.get_left_expr()->is_marked_for_strip());\n+            rust_assert(!expr.get_right_expr()->is_marked_for_strip());\n+        }\n+        void visit(AST::TypeCastExpr& expr) override {\n+            /* outer attributes never allowed before these. while cannot strip \n+             * two direct descendant expressions, can strip ones below that */\n+\n+            /* should have no possibility for outer attrs as would be parsed \n+             * with outer expr */\n+            expr.get_casted_expr()->accept_vis(*this);\n+\n+            // ensure that they are not marked for strip\n+            rust_assert(!expr.get_casted_expr()->is_marked_for_strip());\n+        }\n+        void visit(AST::AssignmentExpr& expr) override {\n+            /* outer attributes never allowed before these. while cannot strip \n+             * two direct descendant expressions, can strip ones below that */\n+\n+            /* should have no possibility for outer attrs as would be parsed \n+             * with outer expr */\n+            expr.get_left_expr()->accept_vis(*this);\n+            /* should syntactically not have outer attributes, though this may \n+             * not have worked in practice */\n+            expr.get_right_expr()->accept_vis(*this);\n+\n+            // ensure that they are not marked for strip\n+            rust_assert(!expr.get_left_expr()->is_marked_for_strip());\n+            rust_assert(!expr.get_right_expr()->is_marked_for_strip());\n+        }\n+        void visit(AST::CompoundAssignmentExpr& expr) override {\n+            /* outer attributes never allowed before these. while cannot strip \n+             * two direct descendant expressions, can strip ones below that */\n+\n+            /* should have no possibility for outer attrs as would be parsed \n+             * with outer expr */\n+            expr.get_left_expr()->accept_vis(*this);\n+            /* should syntactically not have outer attributes, though this may \n+             * not have worked in practice */\n+            expr.get_right_expr()->accept_vis(*this);\n+\n+            // ensure that they are not marked for strip\n+            rust_assert(!expr.get_left_expr()->is_marked_for_strip());\n+            rust_assert(!expr.get_right_expr()->is_marked_for_strip());\n+        }\n+        void visit(AST::GroupedExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip test based on inner attrs - spec says these are inner \n+             * attributes, not outer attributes of inner expr */\n+            expander.expand_cfg_attrs(expr.get_inner_attrs());\n+            if (expander.fails_cfg(expr.get_inner_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip any internal sub-expressions - expression itself isn't\n+             * allowed to have external attributes in this position so can't be\n+             * stripped. */\n+            expr.get_expr_in_parens()->accept_vis(*this);\n+        }\n+        void visit(AST::ArrayElemsValues& elems) override {\n+            /* apparently outer attributes are allowed in \"elements of array \n+             * expressions\" according to spec */\n+            auto& values = elems.get_values();\n+            for (int i = 0; i < values.size();) {\n+                auto& value = values[i];\n+\n+                // mark for stripping if required\n+                value->accept_vis(*this);\n+\n+                if (value->is_marked_for_strip())\n+                    values.erase(values.begin() + i);\n                 else\n                     i++;\n             }\n         }\n+        void visit(AST::ArrayElemsCopied& elems) override {\n+            /* apparently outer attributes are allowed in \"elements of array \n+             * expressions\" according to spec. on the other hand, it would not\n+             * make conceptual sense to be able to remove either expression. As\n+             * such, not implementing. TODO clear up the ambiguity here */\n+\n+            // only intend stripping for internal sub-expressions\n+            elems.get_elem_to_copy()->accept_vis(*this);\n+            elems.get_num_copies()->accept_vis(*this);\n+        }\n+        void visit(AST::ArrayExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip test based on inner attrs - spec says there are separate \n+             * inner attributes, not just outer attributes of inner exprs */\n+            expander.expand_cfg_attrs(expr.get_inner_attrs());\n+            if (expander.fails_cfg(expr.get_inner_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* assuming you can't strip away the ArrayElems type, but can strip \n+             * internal expressions and whatever */\n+            if (expr.has_array_elems())\n+                expr.get_array_elems()->accept_vis(*this);\n+        }\n+        void visit(AST::ArrayIndexExpr& expr) override {\n+            /* it is unclear whether outer attributes are supposed to be \n+             * allowed, but conceptually it wouldn't make much sense, so \n+             * assuming no. TODO */\n \n-        void visit(AST::Token& tok) override {}\n-        void visit(AST::DelimTokenTree& delim_tok_tree) override {}\n-        void visit(AST::AttrInputMetaItemContainer& input) override {}\n-        void visit(AST::IdentifierExpr& ident_expr) override {}\n-        void visit(AST::Lifetime& lifetime) override {}\n-        void visit(AST::LifetimeParam& lifetime_param) override {}\n-        void visit(AST::MacroInvocationSemi& macro) override {}\n-\n-        void visit(AST::PathInExpression& path) override {}\n-        void visit(AST::TypePathSegment& segment) override {}\n-        void visit(AST::TypePathSegmentGeneric& segment) override {}\n-        void visit(AST::TypePathSegmentFunction& segment) override {}\n-        void visit(AST::TypePath& path) override {}\n-        void visit(AST::QualifiedPathInExpression& path) override {}\n-        void visit(AST::QualifiedPathInType& path) override {}\n-\n-        void visit(AST::LiteralExpr& expr) override {}\n-        void visit(AST::AttrInputLiteral& attr_input) override {}\n-        void visit(AST::MetaItemLitExpr& meta_item) override {}\n-        void visit(AST::MetaItemPathLit& meta_item) override {}\n-        void visit(AST::BorrowExpr& expr) override {}\n-        void visit(AST::DereferenceExpr& expr) override {}\n-        void visit(AST::ErrorPropagationExpr& expr) override {}\n-        void visit(AST::NegationExpr& expr) override {}\n-        void visit(AST::ArithmeticOrLogicalExpr& expr) override {}\n-        void visit(AST::ComparisonExpr& expr) override {}\n-        void visit(AST::LazyBooleanExpr& expr) override {}\n-        void visit(AST::TypeCastExpr& expr) override {}\n-        void visit(AST::AssignmentExpr& expr) override {}\n-        void visit(AST::CompoundAssignmentExpr& expr) override {}\n-        void visit(AST::GroupedExpr& expr) override {}\n-        void visit(AST::ArrayElemsValues& elems) override {}\n-        void visit(AST::ArrayElemsCopied& elems) override {}\n-        void visit(AST::ArrayExpr& expr) override {}\n-        void visit(AST::ArrayIndexExpr& expr) override {}\n+            /* strip any internal sub-expressions - expression itself isn't\n+             * allowed to have external attributes in this position so can't be\n+             * stripped. */\n+            expr.get_array_expr()->accept_vis(*this);\n+            expr.get_index_expr()->accept_vis(*this);\n+        }\n         void visit(AST::TupleExpr& expr) override {}\n         void visit(AST::TupleIndexExpr& expr) override {}\n         void visit(AST::StructExprStruct& expr) override {}\n@@ -117,16 +393,90 @@ namespace Rust {\n         void visit(AST::AwaitExpr& expr) override {}\n         void visit(AST::AsyncBlockExpr& expr) override {}\n \n-        void visit(AST::TypeParam& param) override {}\n-        void visit(AST::LifetimeWhereClauseItem& item) override {}\n-        void visit(AST::TypeBoundWhereClauseItem& item) override {}\n-        void visit(AST::Method& method) override {}\n-        void visit(AST::ModuleBodied& module) override {}\n-        void visit(AST::ModuleNoBody& module) override {}\n-        void visit(AST::ExternCrate& crate) override {}\n-        void visit(AST::UseTreeGlob& use_tree) override {}\n-        void visit(AST::UseTreeList& use_tree) override {}\n-        void visit(AST::UseTreeRebind& use_tree) override {}\n+        void visit(AST::TypeParam& param) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::LifetimeWhereClauseItem& item) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::TypeBoundWhereClauseItem& item) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::Method& method) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(method.get_outer_attrs());\n+            if (expander.fails_cfg(method.get_outer_attrs())) {\n+                method.mark_for_strip();\n+                return;\n+            }\n+\n+            /* assuming you can't strip self param - wouldn't be a method\n+             * anymore. spec allows outer attrs on self param, but doesn't\n+             * specify whether cfg is used. */\n+\n+            /* strip method parameters if required - this is specifically\n+             * allowed by spec */\n+            expand_function_params(method.get_function_params());\n+\n+            /* body should always exist - if error state, should have returned\n+             * before now */\n+            method.get_definition()->accept_vis(*this);\n+            // TODO: can block as a whole be invalidated here? Assuming no\n+        }\n+        void visit(AST::ModuleBodied& module) override {\n+            // strip test based on outer attrs\n+            expander.expand_cfg_attrs(module.get_outer_attrs());\n+            if (expander.fails_cfg(module.get_outer_attrs())) {\n+                module.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip test based on inner attrs\n+            expander.expand_cfg_attrs(module.get_inner_attrs());\n+            if (expander.fails_cfg(module.get_inner_attrs())) {\n+                module.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip items if required\n+            auto& items = module.get_items();\n+            for (int i = 0; i < items.size();) {\n+                auto& item = items[i];\n+\n+                // mark for stripping if required\n+                item->accept_vis(*this);\n+\n+                if (item->is_marked_for_strip())\n+                    items.erase(items.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+        void visit(AST::ModuleNoBody& module) override {\n+            // strip test based on outer attrs\n+            expander.expand_cfg_attrs(module.get_outer_attrs());\n+            if (expander.fails_cfg(module.get_outer_attrs())) {\n+                module.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::ExternCrate& crate) override {\n+            // strip test based on outer attrs\n+            expander.expand_cfg_attrs(crate.get_outer_attrs());\n+            if (expander.fails_cfg(crate.get_outer_attrs())) {\n+                crate.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::UseTreeGlob& use_tree) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::UseTreeList& use_tree) override {\n+            // shouldn't require?\n+        }\n+        void visit(AST::UseTreeRebind& use_tree) override {\n+            // shouldn't require?\n+        }\n         void visit(AST::UseDeclaration& use_decl) override {\n             // strip test based on outer attrs\n             expander.expand_cfg_attrs(use_decl.get_outer_attrs());\n@@ -135,23 +485,131 @@ namespace Rust {\n                 return;\n             }\n         }\n-        void visit(AST::Function& function) override {}\n-        void visit(AST::TypeAlias& type_alias) override {}\n-        void visit(AST::StructStruct& struct_item) override {}\n-        void visit(AST::TupleStruct& tuple_struct) override {}\n-        void visit(AST::EnumItem& item) override {}\n-        void visit(AST::EnumItemTuple& item) override {}\n-        void visit(AST::EnumItemStruct& item) override {}\n-        void visit(AST::EnumItemDiscriminant& item) override {}\n-        void visit(AST::Enum& enum_item) override {}\n+        void visit(AST::Function& function) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(function.get_outer_attrs());\n+            if (expander.fails_cfg(function.get_outer_attrs())) {\n+                function.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip function parameters if required - this is specifically\n+             * allowed by spec */\n+            expand_function_params(function.get_function_params());\n+\n+            /* body should always exist - if error state, should have returned\n+             * before now */\n+            function.get_definition()->accept_vis(*this);\n+            // TODO: can block as a whole be invalidated here? Assuming no\n+        }\n+        void visit(AST::TypeAlias& type_alias) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(type_alias.get_outer_attrs());\n+            if (expander.fails_cfg(type_alias.get_outer_attrs())) {\n+                type_alias.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::StructStruct& struct_item) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(struct_item.get_outer_attrs());\n+            if (expander.fails_cfg(struct_item.get_outer_attrs())) {\n+                struct_item.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip struct fields if required - this is presumably\n+             * allowed by spec */\n+            expand_struct_fields(struct_item.get_fields());\n+        }\n+        void visit(AST::TupleStruct& tuple_struct) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(tuple_struct.get_outer_attrs());\n+            if (expander.fails_cfg(tuple_struct.get_outer_attrs())) {\n+                tuple_struct.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip struct fields if required - this is presumably\n+             * allowed by spec */\n+            expand_tuple_fields(tuple_struct.get_fields());\n+        }\n+        void visit(AST::EnumItem& item) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(item.get_outer_attrs());\n+            if (expander.fails_cfg(item.get_outer_attrs())) {\n+                item.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::EnumItemTuple& item) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(item.get_outer_attrs());\n+            if (expander.fails_cfg(item.get_outer_attrs())) {\n+                item.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip item fields if required - this is presumably\n+             * allowed by spec */\n+            expand_tuple_fields(item.get_tuple_fields());\n+        }\n+        void visit(AST::EnumItemStruct& item) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(item.get_outer_attrs());\n+            if (expander.fails_cfg(item.get_outer_attrs())) {\n+                item.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip item fields if required - this is presumably\n+             * allowed by spec */\n+            expand_struct_fields(item.get_struct_fields());\n+        }\n+        void visit(AST::EnumItemDiscriminant& item) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(item.get_outer_attrs());\n+            if (expander.fails_cfg(item.get_outer_attrs())) {\n+                item.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip any internal sub-expressions - expression itself isn't\n+             * allowed to have external attributes in this position so can't be\n+             * stripped. */\n+            item.get_expr()->accept_vis(*this);\n+        }\n+        void visit(AST::Enum& enum_item) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(enum_item.get_outer_attrs());\n+            if (expander.fails_cfg(enum_item.get_outer_attrs())) {\n+                enum_item.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip enum fields if required - this is presumably\n+             * allowed by spec */\n+            auto& variants = enum_item.get_variants();\n+            for (int i = 0; i < variants.size();) {\n+                auto& variant = variants[i];\n+\n+                // mark for stripping if required\n+                variant->accept_vis(*this);\n+\n+                if (variant->is_marked_for_strip())\n+                    variants.erase(variants.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n         void visit(AST::Union& union_item) override {\n             // initial test based on outer attrs\n             expander.expand_cfg_attrs(union_item.get_outer_attrs());\n             if (expander.fails_cfg(union_item.get_outer_attrs())) {\n                 union_item.mark_for_strip();\n                 return;\n             }\n-            \n+\n             /* strip union fields if required - this is presumably\n              * allowed by spec */\n             expand_struct_fields(union_item.get_variants());\n@@ -163,8 +621,11 @@ namespace Rust {\n                 const_item.mark_for_strip();\n                 return;\n             }\n-            /* TODO: is there any way to invalidate the expr? Are attributes \n-             * even allowed on it? */\n+\n+            /* strip any internal sub-expressions - expression itself isn't\n+             * allowed to have external attributes in this position so can't be\n+             * stripped. */\n+            const_item.get_expr()->accept_vis(*this);\n         }\n         void visit(AST::StaticItem& static_item) override {\n             // initial test based on outer attrs\n@@ -173,8 +634,11 @@ namespace Rust {\n                 static_item.mark_for_strip();\n                 return;\n             }\n-            /* TODO: is there any way to invalidate the expr? Are attributes \n-             * even allowed on it? */\n+\n+            /* strip any internal sub-expressions - expression itself isn't\n+             * allowed to have external attributes in this position so can't be\n+             * stripped. */\n+            static_item.get_expr()->accept_vis(*this);\n         }\n         void visit(AST::TraitItemFunc& item) override {\n             // initial test based on outer attrs\n@@ -184,7 +648,7 @@ namespace Rust {\n                 return;\n             }\n \n-            /* strip function parameters if required - this is specifically \n+            /* strip function parameters if required - this is specifically\n              * allowed by spec */\n             expand_function_params(item.get_function_params());\n \n@@ -201,11 +665,11 @@ namespace Rust {\n                 return;\n             }\n \n-            /* assuming you can't strip self param - wouldn't be a method \n+            /* assuming you can't strip self param - wouldn't be a method\n              * anymore. spec allows outer attrs on self param, but doesn't\n              * specify whether cfg is used. */\n \n-            /* strip function parameters if required - this is specifically \n+            /* strip function parameters if required - this is specifically\n              * allowed by spec */\n             expand_function_params(item.get_function_params());\n \n@@ -221,8 +685,12 @@ namespace Rust {\n                 item.mark_for_strip();\n                 return;\n             }\n-            /* TODO: is there any way to invalidate the expr? Are attributes \n-             * even allowed on it? */\n+\n+            /* strip any internal sub-expressions - expression itself isn't\n+             * allowed to have external attributes in this position so can't be\n+             * stripped */\n+            if (item.has_expression())\n+                item.get_expr()->accept_vis(*this);\n         }\n         void visit(AST::TraitItemType& item) override {\n             // initial test based on outer attrs\n@@ -249,14 +717,14 @@ namespace Rust {\n \n             // strip trait items if required\n             auto& trait_items = trait.get_trait_items();\n-            for (int i = 0; i < trait_items.size(); ) {\n+            for (int i = 0; i < trait_items.size();) {\n                 auto& item = trait_items[i];\n \n                 // mark for stripping if required\n                 item->accept_vis(*this);\n \n-                if (item->is_marked_for_strip ())\n-                    trait_items.erase (trait_items.begin() + i);\n+                if (item->is_marked_for_strip())\n+                    trait_items.erase(trait_items.begin() + i);\n                 else\n                     i++;\n             }\n@@ -276,16 +744,16 @@ namespace Rust {\n                 return;\n             }\n \n-            // strip external items if required\n+            // strip inherent impl items if required\n             auto& impl_items = impl.get_impl_items();\n-            for (int i = 0; i < impl_items.size(); ) {\n+            for (int i = 0; i < impl_items.size();) {\n                 auto& item = impl_items[i];\n \n                 // mark for stripping if required\n                 item->accept_vis(*this);\n \n-                if (item->is_marked_for_strip ())\n-                    impl_items.erase (impl_items.begin() + i);\n+                if (item->is_marked_for_strip())\n+                    impl_items.erase(impl_items.begin() + i);\n                 else\n                     i++;\n             }\n@@ -305,16 +773,16 @@ namespace Rust {\n                 return;\n             }\n \n-            // strip external items if required\n+            // strip trait impl items if required\n             auto& impl_items = impl.get_impl_items();\n-            for (int i = 0; i < impl_items.size(); ) {\n+            for (int i = 0; i < impl_items.size();) {\n                 auto& item = impl_items[i];\n \n                 // mark for stripping if required\n                 item->accept_vis(*this);\n \n-                if (item->is_marked_for_strip ())\n-                    impl_items.erase (impl_items.begin() + i);\n+                if (item->is_marked_for_strip())\n+                    impl_items.erase(impl_items.begin() + i);\n                 else\n                     i++;\n             }\n@@ -335,22 +803,22 @@ namespace Rust {\n                 return;\n             }\n \n-            /* strip function parameters if required - this is specifically \n+            /* strip function parameters if required - this is specifically\n              * allowed by spec */\n             auto& params = item.get_function_params();\n-            for (int i = 0; i < params.size(); ) {\n-                auto& param_attrs = params[i].get_outer_attrs ();\n+            for (int i = 0; i < params.size();) {\n+                auto& param_attrs = params[i].get_outer_attrs();\n                 expander.expand_cfg_attrs(param_attrs);\n-                if (expander.fails_cfg (param_attrs))\n-                    params.erase (params.begin() + i);\n+                if (expander.fails_cfg(param_attrs))\n+                    params.erase(params.begin() + i);\n                 else\n                     i++;\n             }\n-            /* NOTE: these are extern function params, which may have different \n-             * rules and restrictions to \"normal\" function params. So expansion \n+            /* NOTE: these are extern function params, which may have different\n+             * rules and restrictions to \"normal\" function params. So expansion\n              * handled separately. */\n \n-            /* TODO: assuming that variadic nature cannot be stripped. If this \n+            /* TODO: assuming that variadic nature cannot be stripped. If this\n              * is not true, then have code here to do so. */\n         }\n         void visit(AST::ExternBlock& block) override {\n@@ -370,14 +838,14 @@ namespace Rust {\n \n             // strip external items if required\n             auto& extern_items = block.get_extern_items();\n-            for (int i = 0; i < extern_items.size(); ) {\n+            for (int i = 0; i < extern_items.size();) {\n                 auto& item = extern_items[i];\n \n                 // mark for stripping if required\n                 item->accept_vis(*this);\n \n-                if (item->is_marked_for_strip ())\n-                    extern_items.erase (extern_items.begin() + i);\n+                if (item->is_marked_for_strip())\n+                    extern_items.erase(extern_items.begin() + i);\n                 else\n                     i++;\n             }\n@@ -386,15 +854,34 @@ namespace Rust {\n         void visit(AST::MacroMatchFragment& match) override {}\n         void visit(AST::MacroMatchRepetition& match) override {}\n         void visit(AST::MacroMatcher& matcher) override {}\n-        void visit(AST::MacroRulesDefinition& rules_def) override {}\n-        void visit(AST::MacroInvocation& macro_invoc) override {}\n+        void visit(AST::MacroRulesDefinition& rules_def) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(rules_def.get_outer_attrs());\n+            if (expander.fails_cfg(rules_def.get_outer_attrs())) {\n+                rules_def.mark_for_strip();\n+                return;\n+            }\n+\n+            // I don't think any macro rules can be stripped in any way\n+        }\n+        void visit(AST::MacroInvocation& macro_invoc) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(macro_invoc.get_outer_attrs());\n+            if (expander.fails_cfg(macro_invoc.get_outer_attrs())) {\n+                macro_invoc.mark_for_strip();\n+                return;\n+            }\n+\n+            // I don't think any macro token trees can be stripped in any way\n+        }\n         void visit(AST::MetaItemPath& meta_item) override {}\n         void visit(AST::MetaItemSeq& meta_item) override {}\n         void visit(AST::MetaWord& meta_item) override {}\n         void visit(AST::MetaNameValueStr& meta_item) override {}\n         void visit(AST::MetaListPaths& meta_item) override {}\n         void visit(AST::MetaListNameValueStr& meta_item) override {}\n \n+        // stripping shouldn't be required or possible for patterns\n         void visit(AST::LiteralPattern& pattern) override {}\n         void visit(AST::IdentifierPattern& pattern) override {}\n         void visit(AST::WildcardPattern& pattern) override {}\n@@ -416,11 +903,55 @@ namespace Rust {\n         void visit(AST::GroupedPattern& pattern) override {}\n         void visit(AST::SlicePattern& pattern) override {}\n \n-        void visit(AST::EmptyStmt& stmt) override {}\n-        void visit(AST::LetStmt& stmt) override {}\n-        void visit(AST::ExprStmtWithoutBlock& stmt) override {}\n-        void visit(AST::ExprStmtWithBlock& stmt) override {}\n+        void visit(AST::EmptyStmt& stmt) override {\n+            // assuming no outer attributes, so nothing can happen\n+        }\n+        void visit(AST::LetStmt& stmt) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(stmt.get_outer_attrs());\n+            if (expander.fails_cfg(stmt.get_outer_attrs())) {\n+                stmt.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip any internal sub-expressions - expression itself isn't\n+             * allowed to have external attributes in this position so can't be\n+             * stripped */\n+            if (stmt.has_init_expr())\n+                stmt.get_init_expr()->accept_vis(*this);\n+        }\n+        void visit(AST::ExprStmtWithoutBlock& stmt) override {\n+            // outer attributes associated with expr, so rely on expr\n \n+            // guard - should prevent null pointer expr\n+            if (stmt.is_marked_for_strip())\n+                return;\n+\n+            // strip if expr is to be stripped\n+            auto& expr = stmt.get_expr();\n+            expr->accept_vis(*this);\n+            if (expr->is_marked_for_strip()) {\n+                stmt.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::ExprStmtWithBlock& stmt) override {\n+            // outer attributes associated with expr, so rely on expr\n+\n+            // guard - should prevent null pointer expr\n+            if (stmt.is_marked_for_strip())\n+                return;\n+\n+            // strip if expr is to be stripped\n+            auto& expr = stmt.get_expr();\n+            expr->accept_vis(*this);\n+            if (expr->is_marked_for_strip()) {\n+                stmt.mark_for_strip();\n+                return;\n+            }\n+        }\n+\n+        // stripping shouldn't be required or possible for types\n         void visit(AST::TraitBound& bound) override {}\n         void visit(AST::ImplTraitType& type) override {}\n         void visit(AST::TraitObjectType& type) override {}\n@@ -515,10 +1046,19 @@ namespace Rust {\n         }\n         // expand module attributes?\n \n-        // expand attributes recursively\n+        // expand attributes recursively and strip items if required\n         AttrVisitor attr_visitor(*this);\n-        for (auto& i : crate.items) {\n-            i->accept_vis(attr_visitor);\n+        auto& items = crate.items;\n+        for (int i = 0; i < items.size();) {\n+            auto& item = items[i];\n+\n+            // mark for stripping if required\n+            item->accept_vis(attr_visitor);\n+\n+            if (item->is_marked_for_strip())\n+                items.erase(items.begin() + i);\n+            else\n+                i++;\n         }\n         // TODO: should recursive attribute and macro expansion be done in the same transversal? Or in\n         // separate ones like currently?"}]}