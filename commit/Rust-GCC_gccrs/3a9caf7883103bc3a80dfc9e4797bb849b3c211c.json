{"sha": "3a9caf7883103bc3a80dfc9e4797bb849b3c211c", "node_id": "C_kwDOANBUbNoAKDNhOWNhZjc4ODMxMDNiYzNhODBkZmM5ZTQ3OTdiYjg0OWIzYzIxMWM", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2023-03-21T06:22:37Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2023-03-21T06:22:37Z"}, "message": "Fortran: Fix regression caused by PR37336 patch [PR109209]\n\n2023-03-21  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/109209\n\t* resolve.cc (generate_component_assignments): Restore the\n\texclusion of allocatable components from the loop.\n\ngcc/testsuite/\n\tPR fortran/109209\n\t* gfortran.dg/pr109209.f90: New test.", "tree": {"sha": "f03539e063a8462281667b45c5242e6783933291", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f03539e063a8462281667b45c5242e6783933291"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a9caf7883103bc3a80dfc9e4797bb849b3c211c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a9caf7883103bc3a80dfc9e4797bb849b3c211c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a9caf7883103bc3a80dfc9e4797bb849b3c211c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a9caf7883103bc3a80dfc9e4797bb849b3c211c/comments", "author": null, "committer": null, "parents": [{"sha": "76dda10584011fa8156d13cb24b3649f1765b68f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76dda10584011fa8156d13cb24b3649f1765b68f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76dda10584011fa8156d13cb24b3649f1765b68f"}], "stats": {"total": 81, "additions": 81, "deletions": 0}, "files": [{"sha": "1a03e458d9931c13c7d5ec2cada369f19a48dafa", "filename": "gcc/fortran/resolve.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9caf7883103bc3a80dfc9e4797bb849b3c211c/gcc%2Ffortran%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9caf7883103bc3a80dfc9e4797bb849b3c211c/gcc%2Ffortran%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.cc?ref=3a9caf7883103bc3a80dfc9e4797bb849b3c211c", "patch": "@@ -11760,6 +11760,7 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n \t of all kinds and allocatable components.  */\n       if (!gfc_bt_struct (comp1->ts.type)\n \t  || comp1->attr.pointer\n+\t  || comp1->attr.allocatable\n \t  || comp1->attr.proc_pointer_comp\n \t  || comp1->attr.class_pointer\n \t  || comp1->attr.proc_pointer)"}, {"sha": "5ee7389400ee34f283b82f68674d44eae451cfc2", "filename": "gcc/testsuite/gfortran.dg/pr109209.f90", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9caf7883103bc3a80dfc9e4797bb849b3c211c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr109209.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9caf7883103bc3a80dfc9e4797bb849b3c211c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr109209.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr109209.f90?ref=3a9caf7883103bc3a80dfc9e4797bb849b3c211c", "patch": "@@ -0,0 +1,80 @@\n+! { dg-do compile }\n+!\n+! Fix for a regression caused by\n+! r13-6747-gd7caf313525a46f200d7f5db1ba893f853774aee\n+!\n+! Contributed by Juergen Reuter  <juergen.reuter@desy.de>\n+!\n+module resonances\n+  implicit none\n+  private\n+\n+  type :: t1_t\n+     integer, dimension(:), allocatable :: c\n+   contains\n+     procedure, private :: t1_assign\n+     generic :: assignment(=) => t1_assign\n+  end type t1_t\n+\n+  type :: t3_t\n+     type(t1_t), dimension(:), allocatable :: resonances\n+     integer :: n_resonances = 0\n+  contains\n+     procedure, private :: t3_assign\n+     generic :: assignment(=) => t3_assign\n+  end type t3_t\n+\n+  type :: resonance_branch_t\n+     integer :: i = 0\n+     integer, dimension(:), allocatable :: r_child\n+     integer, dimension(:), allocatable :: o_child\n+  end type resonance_branch_t\n+\n+  type :: resonance_tree_t\n+     private\n+     integer :: n = 0\n+     type(resonance_branch_t), dimension(:), allocatable :: branch\n+  end type resonance_tree_t\n+\n+  type :: t3_set_t\n+     private\n+     type(t3_t), dimension(:), allocatable :: history\n+     type(resonance_tree_t), dimension(:), allocatable :: tree\n+     integer :: last = 0\n+   contains\n+     procedure, private :: expand => t3_set_expand\n+  end type t3_set_t\n+\n+contains\n+\n+  pure subroutine t1_assign &\n+       (t1_out, t1_in)\n+    class(t1_t), intent(inout) :: t1_out\n+    class(t1_t), intent(in) :: t1_in\n+    if (allocated (t1_out%c))  deallocate (t1_out%c)\n+    if (allocated (t1_in%c)) then\n+       allocate (t1_out%c (size (t1_in%c)))\n+       t1_out%c = t1_in%c\n+    end if\n+  end subroutine t1_assign\n+\n+  subroutine t3_assign (res_hist_out, res_hist_in)\n+    class(t3_t), intent(out) :: res_hist_out\n+    class(t3_t), intent(in) :: res_hist_in\n+    if (allocated (res_hist_in%resonances)) then\n+       res_hist_out%resonances = res_hist_in%resonances\n+       res_hist_out%n_resonances = res_hist_in%n_resonances\n+    end if\n+  end subroutine t3_assign\n+\n+  subroutine t3_set_expand (res_set)\n+    class(t3_set_t), intent(inout) :: res_set\n+    type(t3_t), dimension(:), allocatable :: history_new\n+    integer :: s\n+    s = size (res_set%history)\n+    allocate (history_new (2 * s))\n+    history_new(1:s) = res_set%history(1:s)\n+    call move_alloc (history_new, res_set%history)\n+  end subroutine t3_set_expand\n+\n+end module resonances"}]}