{"sha": "cb6da767b099d8cb044b255b58ca34ba02e8cd38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I2ZGE3NjdiMDk5ZDhjYjA0NGIyNTViNThjYTM0YmEwMmU4Y2QzOA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2013-03-26T20:05:55Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2013-03-26T20:05:55Z"}, "message": "cp-gimplify.c (cp_genericize_r): Use VAR_OR_FUNCTION_DECL_P.\n\n\t* cp-gimplify.c (cp_genericize_r): Use VAR_OR_FUNCTION_DECL_P.\n\t* decl.c (duplicate_decls): Likewise.\n\t(cp_finish_decl): Likewise.\n\t(check_class_member_definition_namespace): Likewise.\n\t* decl2.c (grokfield): Likewise.\n\t(decl_needed_p): Likewise.\n\t(import_export_decl): Likewise.\n\t(mark_used): Likewise.\n\t* name-lookup.c (pushdecl_maybe_friend_1): Likewise.\n\t* pt.c (push_access_scope): Likewise.\n\t(instantiate_decl): Likewise.\n\t* ptree.c (cxx_print_decl): Likewise.\n\t* repo.c (repo_emit_p): Likewise.\n\t* semantics.c (note_decl_for_pch): Likewise.\n\t* tree.c (decl_linkage): Likewise.\n\nFrom-SVN: r197119", "tree": {"sha": "f3e18bdb2050b0a57cf4c1c26efbb635fde19e95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3e18bdb2050b0a57cf4c1c26efbb635fde19e95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb6da767b099d8cb044b255b58ca34ba02e8cd38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb6da767b099d8cb044b255b58ca34ba02e8cd38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb6da767b099d8cb044b255b58ca34ba02e8cd38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb6da767b099d8cb044b255b58ca34ba02e8cd38/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e10b7560160f11829aaa8b920d9cc8cf260c63b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e10b7560160f11829aaa8b920d9cc8cf260c63b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e10b7560160f11829aaa8b920d9cc8cf260c63b"}], "stats": {"total": 68, "additions": 37, "deletions": 31}, "files": [{"sha": "8bddaf2dfa4343de7733b1b7cb1f64e4e04cdfab", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cb6da767b099d8cb044b255b58ca34ba02e8cd38", "patch": "@@ -1,3 +1,21 @@\n+2013-03-26  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* cp-gimplify.c (cp_genericize_r): Use VAR_OR_FUNCTION_DECL_P.\n+\t* decl.c (duplicate_decls): Likewise.\n+\t(cp_finish_decl): Likewise.\n+\t(check_class_member_definition_namespace): Likewise.\n+\t* decl2.c (grokfield): Likewise.\n+\t(decl_needed_p): Likewise.\n+\t(import_export_decl): Likewise.\n+\t(mark_used): Likewise.\n+\t* name-lookup.c (pushdecl_maybe_friend_1): Likewise.\n+\t* pt.c (push_access_scope): Likewise.\n+\t(instantiate_decl): Likewise.\n+\t* ptree.c (cxx_print_decl): Likewise.\n+\t* repo.c (repo_emit_p): Likewise.\n+\t* semantics.c (note_decl_for_pch): Likewise.\n+\t* tree.c (decl_linkage): Likewise.\n+\n 2013-03-26  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/55951"}, {"sha": "765fb2f67da3926d9d5c5bc054bb3bacabb2ae06", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=cb6da767b099d8cb044b255b58ca34ba02e8cd38", "patch": "@@ -857,7 +857,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n   /* Map block scope extern declarations to visible declarations with the\n      same name and type in outer scopes if any.  */\n   if (cp_function_chain->extern_decl_map\n-      && (TREE_CODE (stmt) == FUNCTION_DECL || TREE_CODE (stmt) == VAR_DECL)\n+      && VAR_OR_FUNCTION_DECL_P (stmt)\n       && DECL_EXTERNAL (stmt))\n     {\n       struct cxx_int_tree_map *h, in;"}, {"sha": "d5e86a05fad5d3bd0235a8f7138b5ea20d687160", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cb6da767b099d8cb044b255b58ca34ba02e8cd38", "patch": "@@ -1620,8 +1620,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t  warning_at (DECL_SOURCE_LOCATION (olddecl), 0,\n \t\t      \"follows non-prototype definition here\");\n \t}\n-      else if ((TREE_CODE (olddecl) == FUNCTION_DECL\n-\t\t|| TREE_CODE (olddecl) == VAR_DECL)\n+      else if (VAR_OR_FUNCTION_DECL_P (olddecl)\n \t       && DECL_LANGUAGE (newdecl) != DECL_LANGUAGE (olddecl))\n \t{\n \t  /* [dcl.link]\n@@ -6408,8 +6407,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \n   /* Let the middle end know about variables and functions -- but not\n      static data members in uninstantiated class templates.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      || TREE_CODE (decl) == FUNCTION_DECL)\n+  if (VAR_OR_FUNCTION_DECL_P (decl))\n     {\n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n@@ -7230,8 +7228,7 @@ check_class_member_definition_namespace (tree decl)\n {\n   /* These checks only apply to member functions and static data\n      members.  */\n-  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n-\t      || TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (VAR_OR_FUNCTION_DECL_P (decl));\n   /* We check for problems with specializations in pt.c in\n      check_specialization_namespace, where we can issue better\n      diagnostics.  */"}, {"sha": "60fad44eecde9b258f7bfe6ffc1fb578eab42e23", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cb6da767b099d8cb044b255b58ca34ba02e8cd38", "patch": "@@ -955,8 +955,7 @@ grokfield (const cp_declarator *declarator,\n \t}\n     }\n \n-  if (processing_template_decl\n-      && (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == FUNCTION_DECL))\n+  if (processing_template_decl && VAR_OR_FUNCTION_DECL_P (value))\n     {\n       value = push_template_decl (value);\n       if (error_operand_p (value))\n@@ -1799,8 +1798,7 @@ mark_needed (tree decl)\n bool\n decl_needed_p (tree decl)\n {\n-  gcc_assert (TREE_CODE (decl) == VAR_DECL\n-\t      || TREE_CODE (decl) == FUNCTION_DECL);\n+  gcc_assert (VAR_OR_FUNCTION_DECL_P (decl));\n   /* This function should only be called at the end of the translation\n      unit.  We cannot be sure of whether or not something will be\n      COMDAT until that point.  */\n@@ -2002,8 +2000,7 @@ constrain_visibility_for_template (tree decl, tree targs)\n \t  STRIP_NOPS (arg);\n \t  if (TREE_CODE (arg) == ADDR_EXPR)\n \t    arg = TREE_OPERAND (arg, 0);\n-\t  if (TREE_CODE (arg) == VAR_DECL\n-\t      || TREE_CODE (arg) == FUNCTION_DECL)\n+\t  if (VAR_OR_FUNCTION_DECL_P (arg))\n \t    {\n \t      if (! TREE_PUBLIC (arg))\n \t\tvis = VISIBILITY_ANON;\n@@ -2419,8 +2416,7 @@ import_export_decl (tree decl)\n      definition available in this translation unit.\n \n      The following assertions check these conditions.  */\n-  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n-\t      || TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (VAR_OR_FUNCTION_DECL_P (decl));\n   /* Any code that creates entities with TREE_PUBLIC cleared should\n      also set DECL_INTERFACE_KNOWN.  */\n   gcc_assert (TREE_PUBLIC (decl));\n@@ -4528,7 +4524,7 @@ mark_used (tree decl)\n   /* We can only check DECL_ODR_USED on variables or functions with\n      DECL_LANG_SPECIFIC set, and these are also the only decls that we\n      might need special handling for.  */\n-  if ((TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)\n+  if (!VAR_OR_FUNCTION_DECL_P (decl)\n       || DECL_LANG_SPECIFIC (decl) == NULL\n       || DECL_THUNK_P (decl))\n     {\n@@ -4664,7 +4660,7 @@ mark_used (tree decl)\n       /* If this is a synthesized method we don't need to\n \t do the instantiation test below.  */\n     }\n-  else if ((TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)\n+  else if (VAR_OR_FUNCTION_DECL_P (decl)\n \t   && DECL_TEMPLATE_INFO (decl)\n \t   && (!DECL_EXPLICIT_INSTANTIATION (decl)\n \t       || always_instantiate_p (decl)))"}, {"sha": "0a0915af8a9118feedeb058088a8058162dcc589", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=cb6da767b099d8cb044b255b58ca34ba02e8cd38", "patch": "@@ -678,7 +678,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t block scope declaration declares that same entity and\n \t receives the linkage of the previous declaration.  */\n       if (! t && current_function_decl && x != current_function_decl\n-\t  && (TREE_CODE (x) == FUNCTION_DECL || TREE_CODE (x) == VAR_DECL)\n+\t  && VAR_OR_FUNCTION_DECL_P (x)\n \t  && DECL_EXTERNAL (x))\n \t{\n \t  /* Look in block scope.  */"}, {"sha": "bb690c5009ff97bcb744d8176474ba3fa0fcb9fd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cb6da767b099d8cb044b255b58ca34ba02e8cd38", "patch": "@@ -213,9 +213,8 @@ static tree instantiate_alias_template (tree, tree, tsubst_flags_t);\n static void\n push_access_scope (tree t)\n {\n-  gcc_assert (TREE_CODE (t) == FUNCTION_DECL\n-\t      || TREE_CODE (t) == TYPE_DECL\n-\t      || TREE_CODE (t) == VAR_DECL);\n+  gcc_assert (VAR_OR_FUNCTION_DECL_P (t)\n+\t      || TREE_CODE (t) == TYPE_DECL);\n \n   if (DECL_FRIEND_CONTEXT (t))\n     push_nested_class (DECL_FRIEND_CONTEXT (t));\n@@ -18598,8 +18597,7 @@ instantiate_decl (tree d, int defer_ok,\n \n   /* This function should only be used to instantiate templates for\n      functions and static member variables.  */\n-  gcc_assert (TREE_CODE (d) == FUNCTION_DECL\n-\t      || TREE_CODE (d) == VAR_DECL);\n+  gcc_assert (VAR_OR_FUNCTION_DECL_P (d));\n \n   /* Variables are never deferred; if instantiation is required, they\n      are instantiated right away.  That allows for better code in the"}, {"sha": "f4ca003be983f3fb5dd4ee930dd6aad3fc6d200d", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=cb6da767b099d8cb044b255b58ca34ba02e8cd38", "patch": "@@ -63,7 +63,7 @@ cxx_print_decl (FILE *file, tree node, int indent)\n       && DECL_PENDING_INLINE_INFO (node))\n     fprintf (file, \" pending-inline-info %p\",\n \t     (void *) DECL_PENDING_INLINE_INFO (node));\n-  if ((TREE_CODE (node) == FUNCTION_DECL || TREE_CODE (node) == VAR_DECL)\n+  if (VAR_OR_FUNCTION_DECL_P (node)\n       && DECL_TEMPLATE_INFO (node))\n     fprintf (file, \" template-info %p\",\n \t     (void *) DECL_TEMPLATE_INFO (node));"}, {"sha": "8c524adbf2b245844aa2c23eea2eea325f61447f", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=cb6da767b099d8cb044b255b58ca34ba02e8cd38", "patch": "@@ -291,8 +291,7 @@ repo_emit_p (tree decl)\n {\n   int ret = 0;\n   gcc_assert (TREE_PUBLIC (decl));\n-  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n-\t      || TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (VAR_OR_FUNCTION_DECL_P (decl));\n   gcc_assert (!DECL_REALLY_EXTERN (decl));\n \n   /* When not using the repository, emit everything.  */"}, {"sha": "333980e88e7a4bf029ecc708b1afda046bb934f4", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cb6da767b099d8cb044b255b58ca34ba02e8cd38", "patch": "@@ -2771,8 +2771,7 @@ note_decl_for_pch (tree decl)\n \n   /* There's a good chance that we'll have to mangle names at some\n      point, even if only for emission in debugging information.  */\n-  if ((TREE_CODE (decl) == VAR_DECL\n-       || TREE_CODE (decl) == FUNCTION_DECL)\n+  if (VAR_OR_FUNCTION_DECL_P (decl)\n       && !processing_template_decl)\n     mangle_decl (decl);\n }"}, {"sha": "0306db10770b6f3ac21af1a397dd702fe0966a6b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb6da767b099d8cb044b255b58ca34ba02e8cd38/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=cb6da767b099d8cb044b255b58ca34ba02e8cd38", "patch": "@@ -3579,8 +3579,7 @@ decl_linkage (tree decl)\n      template instantiations have internal linkage (in the object\n      file), but the symbols should still be treated as having external\n      linkage from the point of view of the language.  */\n-  if ((TREE_CODE (decl) == FUNCTION_DECL\n-       || TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_OR_FUNCTION_DECL_P (decl)\n       && DECL_COMDAT (decl))\n     return lk_external;\n \n@@ -3594,7 +3593,7 @@ decl_linkage (tree decl)\n      really meant to have internal linkage have DECL_THIS_STATIC set.  */\n   if (TREE_CODE (decl) == TYPE_DECL)\n     return lk_external;\n-  if (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == FUNCTION_DECL)\n+  if (VAR_OR_FUNCTION_DECL_P (decl))\n     {\n       if (!DECL_THIS_STATIC (decl))\n \treturn lk_external;"}]}