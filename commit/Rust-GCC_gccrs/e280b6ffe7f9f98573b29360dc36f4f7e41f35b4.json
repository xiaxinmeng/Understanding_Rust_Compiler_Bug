{"sha": "e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI4MGI2ZmZlN2Y5Zjk4NTczYjI5MzYwZGMzNmY0ZjdlNDFmMzViNA==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-08-22T09:01:38Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-08-22T09:01:38Z"}, "message": "regex.h: Replace 8 spaces in indentation with a tab.\n\n2013-08-22  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex.h: Replace 8 spaces in indentation with a tab.\n\t* include/bits/regex_automaton.h: Same.\n\t* include/bits/regex_automaton.tcc: Same.\n\t* include/bits/regex_compiler.h: Same.\n\t* include/bits/regex_compiler.tcc: Same.\n\t* include/bits/regex_constants.h: Same.\n\t* include/bits/regex_executor.h: Same.\n\t* include/bits/regex_executor.tcc: Same.\n\nFrom-SVN: r201916", "tree": {"sha": "280ee892c44e536b7389f8d4c439b05a84b05b88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/280ee892c44e536b7389f8d4c439b05a84b05b88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f97cb0b278d59b8923d0b10edfd60d357dc55a7"}], "stats": {"total": 1909, "additions": 960, "deletions": 949}, "files": [{"sha": "0e34fb9416495ad4aeda4bd273d6950e5e9f2c7f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "patch": "@@ -1,3 +1,14 @@\n+2013-08-22  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex.h: Replace 8 spaces in indentation with a tab.\n+\t* include/bits/regex_automaton.h: Same.\n+\t* include/bits/regex_automaton.tcc: Same.\n+\t* include/bits/regex_compiler.h: Same.\n+\t* include/bits/regex_compiler.tcc: Same.\n+\t* include/bits/regex_constants.h: Same.\n+\t* include/bits/regex_executor.h: Same.\n+\t* include/bits/regex_executor.tcc: Same.\n+\n 2013-08-22  Tim Shen  <timshen91@gmail.com>\n \n \t* include/bits/regex.h: Executor caller."}, {"sha": "555dfc6e1fb6cc02da87621197f7850fd52124ed", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 484, "deletions": 484, "changes": 968, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "patch": "@@ -56,71 +56,71 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef std::locale                  \tlocale_type;\n     private:\n       struct _RegexMask\n-        {\n-          typedef typename std::ctype<char_type>::mask _BaseType;\n-          _BaseType _M_base;\n-          unsigned char _M_extended;\n-          static constexpr unsigned char _S_under = 1 << 0;\n-          // FIXME: _S_blank should be removed in the future,\n-          // when locale's complete.\n-          static constexpr unsigned char _S_blank = 1 << 1;\n-          static constexpr unsigned char _S_valid_mask = 0x3;\n-\n-          constexpr _RegexMask(_BaseType __base = 0,\n-                               unsigned char __extended = 0)\n-          : _M_base(__base), _M_extended(__extended)\n-          { }\n-\n-          constexpr _RegexMask\n-          operator&(_RegexMask __other) const\n-          {\n-            return _RegexMask(_M_base & __other._M_base,\n-                              _M_extended & __other._M_extended);\n-          }\n-\n-          constexpr _RegexMask\n-          operator|(_RegexMask __other) const\n-          {\n-            return _RegexMask(_M_base | __other._M_base,\n-                              _M_extended | __other._M_extended);\n-          }\n-\n-          constexpr _RegexMask\n-          operator^(_RegexMask __other) const\n-          {\n-            return _RegexMask(_M_base ^ __other._M_base,\n-                              _M_extended ^ __other._M_extended);\n-          }\n-\n-          constexpr _RegexMask\n-          operator~() const\n-          { return _RegexMask(~_M_base, ~_M_extended); }\n-\n-          _RegexMask&\n-          operator&=(_RegexMask __other)\n-          { return *this = (*this) & __other; }\n-\n-          _RegexMask&\n-          operator|=(_RegexMask __other)\n-          { return *this = (*this) | __other; }\n-\n-          _RegexMask&\n-          operator^=(_RegexMask __other)\n-          { return *this = (*this) ^ __other; }\n-\n-          constexpr bool\n-          operator==(_RegexMask __other) const\n-          {\n-            return (_M_extended & _S_valid_mask)\n-                   == (__other._M_extended & _S_valid_mask)\n-                     && _M_base == __other._M_base;\n-          }\n-\n-          constexpr bool\n-          operator!=(_RegexMask __other) const\n-          { return !((*this) == __other); }\n-\n-        };\n+\t{\n+\t  typedef typename std::ctype<char_type>::mask _BaseType;\n+\t  _BaseType _M_base;\n+\t  unsigned char _M_extended;\n+\t  static constexpr unsigned char _S_under = 1 << 0;\n+\t  // FIXME: _S_blank should be removed in the future,\n+\t  // when locale's complete.\n+\t  static constexpr unsigned char _S_blank = 1 << 1;\n+\t  static constexpr unsigned char _S_valid_mask = 0x3;\n+\n+\t  constexpr _RegexMask(_BaseType __base = 0,\n+\t\t\t       unsigned char __extended = 0)\n+\t  : _M_base(__base), _M_extended(__extended)\n+\t  { }\n+\n+\t  constexpr _RegexMask\n+\t  operator&(_RegexMask __other) const\n+\t  {\n+\t    return _RegexMask(_M_base & __other._M_base,\n+\t\t\t      _M_extended & __other._M_extended);\n+\t  }\n+\n+\t  constexpr _RegexMask\n+\t  operator|(_RegexMask __other) const\n+\t  {\n+\t    return _RegexMask(_M_base | __other._M_base,\n+\t\t\t      _M_extended | __other._M_extended);\n+\t  }\n+\n+\t  constexpr _RegexMask\n+\t  operator^(_RegexMask __other) const\n+\t  {\n+\t    return _RegexMask(_M_base ^ __other._M_base,\n+\t\t\t      _M_extended ^ __other._M_extended);\n+\t  }\n+\n+\t  constexpr _RegexMask\n+\t  operator~() const\n+\t  { return _RegexMask(~_M_base, ~_M_extended); }\n+\n+\t  _RegexMask&\n+\t  operator&=(_RegexMask __other)\n+\t  { return *this = (*this) & __other; }\n+\n+\t  _RegexMask&\n+\t  operator|=(_RegexMask __other)\n+\t  { return *this = (*this) | __other; }\n+\n+\t  _RegexMask&\n+\t  operator^=(_RegexMask __other)\n+\t  { return *this = (*this) ^ __other; }\n+\n+\t  constexpr bool\n+\t  operator==(_RegexMask __other) const\n+\t  {\n+\t    return (_M_extended & _S_valid_mask)\n+\t\t   == (__other._M_extended & _S_valid_mask)\n+\t\t     && _M_base == __other._M_base;\n+\t  }\n+\n+\t  constexpr bool\n+\t  operator!=(_RegexMask __other) const\n+\t  { return !((*this) == __other); }\n+\n+\t};\n     public:\n       typedef _RegexMask char_class_type;\n \n@@ -193,9 +193,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *         facet.\n        */\n       template<typename _Fwd_iter>\n-        string_type\n-        transform(_Fwd_iter __first, _Fwd_iter __last) const\n-        {\n+\tstring_type\n+\ttransform(_Fwd_iter __first, _Fwd_iter __last) const\n+\t{\n \t  typedef std::collate<char_type> __collate_type;\n \t  const __collate_type& __fclt(use_facet<__collate_type>(_M_locale));\n \t  string_type __s(__first, __last);\n@@ -217,16 +217,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * @todo Implement this function.\n        */\n       template<typename _Fwd_iter>\n-        string_type\n-        transform_primary(_Fwd_iter __first, _Fwd_iter __last) const\n-        {\n-          typedef std::ctype<char_type> __ctype_type;\n-          const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n-          std::vector<char_type> __s(__first, __last);\n-          // FIXME : this is not entirely correct\n-          __fctyp.tolower(__s.data(), __s.data() + __s.size());\n-          return this->transform(__s.data(), __s.data() + __s.size());\n-        }\n+\tstring_type\n+\ttransform_primary(_Fwd_iter __first, _Fwd_iter __last) const\n+\t{\n+\t  typedef std::ctype<char_type> __ctype_type;\n+\t  const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n+\t  std::vector<char_type> __s(__first, __last);\n+\t  // FIXME : this is not entirely correct\n+\t  __fctyp.tolower(__s.data(), __s.data() + __s.size());\n+\t  return this->transform(__s.data(), __s.data() + __s.size());\n+\t}\n \n       /**\n        * @brief Gets a collation element by name.\n@@ -240,8 +240,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * character sequence is not a valid collating element.\n        */\n       template<typename _Fwd_iter>\n-        string_type\n-        lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const;\n+\tstring_type\n+\tlookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const;\n \n       /**\n        * @brief Maps one or more characters to a named character\n@@ -281,9 +281,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * - xdigit\n        */\n       template<typename _Fwd_iter>\n-        char_class_type\n-        lookup_classname(_Fwd_iter __first, _Fwd_iter __last,\n-                         bool __icase = false) const;\n+\tchar_class_type\n+\tlookup_classname(_Fwd_iter __first, _Fwd_iter __last,\n+\t\t\t bool __icase = false) const;\n \n       /**\n        * @brief Determines if @p c is a member of an identified class.\n@@ -353,182 +353,182 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n \n       static const char* __collatenames[] =\n-        {\n-          \"NUL\",\n-          \"SOH\",\n-          \"STX\",\n-          \"ETX\",\n-          \"EOT\",\n-          \"ENQ\",\n-          \"ACK\",\n-          \"alert\",\n-          \"backspace\",\n-          \"tab\",\n-          \"newline\",\n-          \"vertical-tab\",\n-          \"form-feed\",\n-          \"carriage-return\",\n-          \"SO\",\n-          \"SI\",\n-          \"DLE\",\n-          \"DC1\",\n-          \"DC2\",\n-          \"DC3\",\n-          \"DC4\",\n-          \"NAK\",\n-          \"SYN\",\n-          \"ETB\",\n-          \"CAN\",\n-          \"EM\",\n-          \"SUB\",\n-          \"ESC\",\n-          \"IS4\",\n-          \"IS3\",\n-          \"IS2\",\n-          \"IS1\",\n-          \"space\",\n-          \"exclamation-mark\",\n-          \"quotation-mark\",\n-          \"number-sign\",\n-          \"dollar-sign\",\n-          \"percent-sign\",\n-          \"ampersand\",\n-          \"apostrophe\",\n-          \"left-parenthesis\",\n-          \"right-parenthesis\",\n-          \"asterisk\",\n-          \"plus-sign\",\n-          \"comma\",\n-          \"hyphen\",\n-          \"period\",\n-          \"slash\",\n-          \"zero\",\n-          \"one\",\n-          \"two\",\n-          \"three\",\n-          \"four\",\n-          \"five\",\n-          \"six\",\n-          \"seven\",\n-          \"eight\",\n-          \"nine\",\n-          \"colon\",\n-          \"semicolon\",\n-          \"less-than-sign\",\n-          \"equals-sign\",\n-          \"greater-than-sign\",\n-          \"question-mark\",\n-          \"commercial-at\",\n-          \"A\",\n-          \"B\",\n-          \"C\",\n-          \"D\",\n-          \"E\",\n-          \"F\",\n-          \"G\",\n-          \"H\",\n-          \"I\",\n-          \"J\",\n-          \"K\",\n-          \"L\",\n-          \"M\",\n-          \"N\",\n-          \"O\",\n-          \"P\",\n-          \"Q\",\n-          \"R\",\n-          \"S\",\n-          \"T\",\n-          \"U\",\n-          \"V\",\n-          \"W\",\n-          \"X\",\n-          \"Y\",\n-          \"Z\",\n-          \"left-square-bracket\",\n-          \"backslash\",\n-          \"right-square-bracket\",\n-          \"circumflex\",\n-          \"underscore\",\n-          \"grave-accent\",\n-          \"a\",\n-          \"b\",\n-          \"c\",\n-          \"d\",\n-          \"e\",\n-          \"f\",\n-          \"g\",\n-          \"h\",\n-          \"i\",\n-          \"j\",\n-          \"k\",\n-          \"l\",\n-          \"m\",\n-          \"n\",\n-          \"o\",\n-          \"p\",\n-          \"q\",\n-          \"r\",\n-          \"s\",\n-          \"t\",\n-          \"u\",\n-          \"v\",\n-          \"w\",\n-          \"x\",\n-          \"y\",\n-          \"z\",\n-          \"left-curly-bracket\",\n-          \"vertical-line\",\n-          \"right-curly-bracket\",\n-          \"tilde\",\n-          \"DEL\",\n-          \"\"\n-        };\n+\t{\n+\t  \"NUL\",\n+\t  \"SOH\",\n+\t  \"STX\",\n+\t  \"ETX\",\n+\t  \"EOT\",\n+\t  \"ENQ\",\n+\t  \"ACK\",\n+\t  \"alert\",\n+\t  \"backspace\",\n+\t  \"tab\",\n+\t  \"newline\",\n+\t  \"vertical-tab\",\n+\t  \"form-feed\",\n+\t  \"carriage-return\",\n+\t  \"SO\",\n+\t  \"SI\",\n+\t  \"DLE\",\n+\t  \"DC1\",\n+\t  \"DC2\",\n+\t  \"DC3\",\n+\t  \"DC4\",\n+\t  \"NAK\",\n+\t  \"SYN\",\n+\t  \"ETB\",\n+\t  \"CAN\",\n+\t  \"EM\",\n+\t  \"SUB\",\n+\t  \"ESC\",\n+\t  \"IS4\",\n+\t  \"IS3\",\n+\t  \"IS2\",\n+\t  \"IS1\",\n+\t  \"space\",\n+\t  \"exclamation-mark\",\n+\t  \"quotation-mark\",\n+\t  \"number-sign\",\n+\t  \"dollar-sign\",\n+\t  \"percent-sign\",\n+\t  \"ampersand\",\n+\t  \"apostrophe\",\n+\t  \"left-parenthesis\",\n+\t  \"right-parenthesis\",\n+\t  \"asterisk\",\n+\t  \"plus-sign\",\n+\t  \"comma\",\n+\t  \"hyphen\",\n+\t  \"period\",\n+\t  \"slash\",\n+\t  \"zero\",\n+\t  \"one\",\n+\t  \"two\",\n+\t  \"three\",\n+\t  \"four\",\n+\t  \"five\",\n+\t  \"six\",\n+\t  \"seven\",\n+\t  \"eight\",\n+\t  \"nine\",\n+\t  \"colon\",\n+\t  \"semicolon\",\n+\t  \"less-than-sign\",\n+\t  \"equals-sign\",\n+\t  \"greater-than-sign\",\n+\t  \"question-mark\",\n+\t  \"commercial-at\",\n+\t  \"A\",\n+\t  \"B\",\n+\t  \"C\",\n+\t  \"D\",\n+\t  \"E\",\n+\t  \"F\",\n+\t  \"G\",\n+\t  \"H\",\n+\t  \"I\",\n+\t  \"J\",\n+\t  \"K\",\n+\t  \"L\",\n+\t  \"M\",\n+\t  \"N\",\n+\t  \"O\",\n+\t  \"P\",\n+\t  \"Q\",\n+\t  \"R\",\n+\t  \"S\",\n+\t  \"T\",\n+\t  \"U\",\n+\t  \"V\",\n+\t  \"W\",\n+\t  \"X\",\n+\t  \"Y\",\n+\t  \"Z\",\n+\t  \"left-square-bracket\",\n+\t  \"backslash\",\n+\t  \"right-square-bracket\",\n+\t  \"circumflex\",\n+\t  \"underscore\",\n+\t  \"grave-accent\",\n+\t  \"a\",\n+\t  \"b\",\n+\t  \"c\",\n+\t  \"d\",\n+\t  \"e\",\n+\t  \"f\",\n+\t  \"g\",\n+\t  \"h\",\n+\t  \"i\",\n+\t  \"j\",\n+\t  \"k\",\n+\t  \"l\",\n+\t  \"m\",\n+\t  \"n\",\n+\t  \"o\",\n+\t  \"p\",\n+\t  \"q\",\n+\t  \"r\",\n+\t  \"s\",\n+\t  \"t\",\n+\t  \"u\",\n+\t  \"v\",\n+\t  \"w\",\n+\t  \"x\",\n+\t  \"y\",\n+\t  \"z\",\n+\t  \"left-curly-bracket\",\n+\t  \"vertical-line\",\n+\t  \"right-curly-bracket\",\n+\t  \"tilde\",\n+\t  \"DEL\",\n+\t  \"\"\n+\t};\n \n       // same as boost\n       static const char* __digraphs[] =\n-        {\n-          \"ae\",\n-          \"Ae\",\n-          \"AE\",\n-          \"ch\",\n-          \"Ch\",\n-          \"CH\",\n-          \"ll\",\n-          \"Ll\",\n-          \"LL\",\n-          \"ss\",\n-          \"Ss\",\n-          \"SS\",\n-          \"nj\",\n-          \"Nj\",\n-          \"NJ\",\n-          \"dz\",\n-          \"Dz\",\n-          \"DZ\",\n-          \"lj\",\n-          \"Lj\",\n-          \"LJ\",\n-          \"\"\n-        };\n+\t{\n+\t  \"ae\",\n+\t  \"Ae\",\n+\t  \"AE\",\n+\t  \"ch\",\n+\t  \"Ch\",\n+\t  \"CH\",\n+\t  \"ll\",\n+\t  \"Ll\",\n+\t  \"LL\",\n+\t  \"ss\",\n+\t  \"Ss\",\n+\t  \"SS\",\n+\t  \"nj\",\n+\t  \"Nj\",\n+\t  \"NJ\",\n+\t  \"dz\",\n+\t  \"Dz\",\n+\t  \"DZ\",\n+\t  \"lj\",\n+\t  \"Lj\",\n+\t  \"LJ\",\n+\t  \"\"\n+\t};\n \n       std::string __s(__last - __first, '?');\n       __fctyp.narrow(__first, __last, '?', &*__s.begin());\n \n       for (unsigned int __i = 0; *__collatenames[__i]; __i++)\n-        if (__s == __collatenames[__i])\n-          return string_type(1, __fctyp.widen((char)__i));\n+\tif (__s == __collatenames[__i])\n+\t  return string_type(1, __fctyp.widen((char)__i));\n \n       for (unsigned int __i = 0; *__digraphs[__i]; __i++)\n-        {\n-          const char* __now = __digraphs[__i];\n-          if (__s == __now)\n-            {\n-              string_type ret(__s.size(), __fctyp.widen('?'));\n-              __fctyp.widen(__now, __now + 2/* ouch */, &*ret.begin());\n-              return ret;\n-            }\n-        }\n+\t{\n+\t  const char* __now = __digraphs[__i];\n+\t  if (__s == __now)\n+\t    {\n+\t      string_type ret(__s.size(), __fctyp.widen('?'));\n+\t      __fctyp.widen(__now, __now + 2/* ouch */, &*ret.begin());\n+\t      return ret;\n+\t    }\n+\t}\n       return string_type();\n     }\n \n@@ -546,39 +546,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       static _ClassnameEntry __classnames[] =\n       {\n-        {\"d\", ctype_base::digit},\n-        {\"w\", {ctype_base::alnum, _RegexMask::_S_under}},\n-        {\"s\", ctype_base::space},\n-        {\"alnum\", ctype_base::alnum},\n-        {\"alpha\", ctype_base::alpha},\n-        {\"blank\", {0, _RegexMask::_S_blank}},\n-        {\"cntrl\", ctype_base::cntrl},\n-        {\"digit\", ctype_base::digit},\n-        {\"graph\", ctype_base::graph},\n-        {\"lower\", ctype_base::lower},\n-        {\"print\", ctype_base::print},\n-        {\"punct\", ctype_base::punct},\n-        {\"space\", ctype_base::space},\n-        {\"upper\", ctype_base::upper},\n-        {\"xdigit\", ctype_base::xdigit},\n+\t{\"d\", ctype_base::digit},\n+\t{\"w\", {ctype_base::alnum, _RegexMask::_S_under}},\n+\t{\"s\", ctype_base::space},\n+\t{\"alnum\", ctype_base::alnum},\n+\t{\"alpha\", ctype_base::alpha},\n+\t{\"blank\", {0, _RegexMask::_S_blank}},\n+\t{\"cntrl\", ctype_base::cntrl},\n+\t{\"digit\", ctype_base::digit},\n+\t{\"graph\", ctype_base::graph},\n+\t{\"lower\", ctype_base::lower},\n+\t{\"print\", ctype_base::print},\n+\t{\"punct\", ctype_base::punct},\n+\t{\"space\", ctype_base::space},\n+\t{\"upper\", ctype_base::upper},\n+\t{\"xdigit\", ctype_base::xdigit},\n       };\n \n       std::string __s(__last - __first, '?');\n       __fctyp.narrow(__first, __last, '?', &__s[0]);\n       __cctyp.tolower(&*__s.begin(), &*__s.begin() + __s.size());\n       for (_ClassnameEntry* __it = __classnames;\n-           __it < *(&__classnames + 1);\n-           ++__it)\n-        {\n-          if (__s == __it->first)\n-            {\n-              if (__icase\n-                  && ((__it->second\n-                       & (ctype_base::lower | ctype_base::upper)) != 0))\n-                return ctype_base::alpha;\n-              return __it->second;\n-            }\n-        }\n+\t   __it < *(&__classnames + 1);\n+\t   ++__it)\n+\t{\n+\t  if (__s == __it->first)\n+\t    {\n+\t      if (__icase\n+\t\t  && ((__it->second\n+\t\t       & (ctype_base::lower | ctype_base::upper)) != 0))\n+\t\treturn ctype_base::alpha;\n+\t      return __it->second;\n+\t    }\n+\t}\n       return 0;\n     }\n \n@@ -591,13 +591,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n \n       return __fctyp.is(__f._M_base, __c)\n-        // [[:w:]]\n-        || ((__f._M_extended & _RegexMask::_S_under)\n-            && __c == __fctyp.widen('_'))\n-        // [[:blank:]]\n-        || ((__f._M_extended & _RegexMask::_S_blank)\n-            && (__c == __fctyp.widen(' ')\n-                || __c == __fctyp.widen('\\t')));\n+\t// [[:w:]]\n+\t|| ((__f._M_extended & _RegexMask::_S_under)\n+\t    && __c == __fctyp.widen('_'))\n+\t// [[:blank:]]\n+\t|| ((__f._M_extended & _RegexMask::_S_blank)\n+\t    && (__c == __fctyp.widen(' ')\n+\t\t|| __c == __fctyp.widen('\\t')));\n     }\n \n   template<typename _Ch_type>\n@@ -689,7 +689,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * @throws regex_error if @p __p is not a valid regular expression.\n        */\n       basic_regex(const _Ch_type* __p,\n-                  std::size_t __len, flag_type __f = ECMAScript)\n+\t\t  std::size_t __len, flag_type __f = ECMAScript)\n       : basic_regex(__p, __p + __len, __f)\n       { }\n \n@@ -707,7 +707,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       basic_regex(const basic_regex&& __rhs) noexcept\n       : _M_flags(__rhs._M_flags), _M_traits(__rhs._M_traits),\n-        _M_automaton(std::move(__rhs._M_automaton))\n+\t_M_automaton(std::move(__rhs._M_automaton))\n       { }\n \n       /**\n@@ -720,12 +720,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * @throws regex_error if @p __s is not a valid regular expression.\n        */\n       template<typename _Ch_traits, typename _Ch_alloc>\n-        explicit\n-        basic_regex(const std::basic_string<_Ch_type, _Ch_traits,\n+\texplicit\n+\tbasic_regex(const std::basic_string<_Ch_type, _Ch_traits,\n \t\t\t\t\t    _Ch_alloc>& __s,\n \t\t    flag_type __f = ECMAScript)\n \t: basic_regex(__s.begin(), __s.end(), __f)\n-        { }\n+\t{ }\n \n       /**\n        * @brief Constructs a basic regular expression from the range\n@@ -741,12 +741,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *         expression.\n        */\n       template<typename _InputIterator>\n-        basic_regex(_InputIterator __first, _InputIterator __last,\n+\tbasic_regex(_InputIterator __first, _InputIterator __last,\n \t\t    flag_type __f = ECMAScript)\n \t: _M_flags(__f),\n-          _M_automaton(__detail::_Compiler<_InputIterator, _Ch_type, _Rx_traits>\n-                       (__first, __last, _M_traits, _M_flags)._M_get_nfa())\n-        { }\n+\t  _M_automaton(__detail::_Compiler<_InputIterator, _Ch_type, _Rx_traits>\n+\t\t       (__first, __last, _M_traits, _M_flags)._M_get_nfa())\n+\t{ }\n \n       /**\n        * @brief Constructs a basic regular expression from an initializer list.\n@@ -799,9 +799,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * @param __s A pointer to a string containing a regular expression.\n        */\n       template<typename _Ch_typeraits, typename _Alloc>\n-        basic_regex&\n-        operator=(const basic_string<_Ch_type, _Ch_typeraits, _Alloc>& __s)\n-        { return this->assign(__s, flags()); }\n+\tbasic_regex&\n+\toperator=(const basic_string<_Ch_type, _Ch_typeraits, _Alloc>& __s)\n+\t{ return this->assign(__s, flags()); }\n \n       // [7.8.3] assign\n       /**\n@@ -876,10 +876,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * regex_error is thrown, *this remains unchanged.\n        */\n       template<typename _Ch_typeraits, typename _Alloc>\n-        basic_regex&\n-        assign(const basic_string<_Ch_type, _Ch_typeraits, _Alloc>& __s,\n+\tbasic_regex&\n+\tassign(const basic_string<_Ch_type, _Ch_typeraits, _Alloc>& __s,\n \t       flag_type __flags = ECMAScript)\n-        {\n+\t{\n \t  basic_regex __tmp(__s, __flags);\n \t  this->swap(__tmp);\n \t  return *this;\n@@ -899,10 +899,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * regex_error is thrown, the object remains unchanged.\n        */\n       template<typename _InputIterator>\n-        basic_regex&\n-        assign(_InputIterator __first, _InputIterator __last,\n+\tbasic_regex&\n+\tassign(_InputIterator __first, _InputIterator __last,\n \t       flag_type __flags = ECMAScript)\n-        { return this->assign(string_type(__first, __last), __flags); }\n+\t{ return this->assign(string_type(__first, __last), __flags); }\n \n       /**\n        * @brief Assigns a new regular expression to a regex object.\n@@ -976,31 +976,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     protected:\n       typedef std::shared_ptr<__detail::_Automaton<_Ch_type, _Rx_traits>>\n-        _AutomatonPtr;\n+\t_AutomatonPtr;\n \n       template<typename _BiIter, typename _Alloc,\n-        typename _CharT, typename _TraitsT>\n-        friend std::unique_ptr<\n-          __detail::_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n-        __detail::__get_executor(_BiIter,\n-                                 _BiIter,\n-                                 match_results<_BiIter, _Alloc>&,\n-                                 const basic_regex<_CharT, _TraitsT>&,\n-                                 regex_constants::match_flag_type);\n+\ttypename _CharT, typename _TraitsT>\n+\tfriend std::unique_ptr<\n+\t  __detail::_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n+\t__detail::__get_executor(_BiIter,\n+\t\t\t\t _BiIter,\n+\t\t\t\t match_results<_BiIter, _Alloc>&,\n+\t\t\t\t const basic_regex<_CharT, _TraitsT>&,\n+\t\t\t\t regex_constants::match_flag_type);\n \n       template<typename _Bp, typename _Ap, typename _Cp, typename _Rp>\n-        friend bool\n-        regex_match(_Bp, _Bp,\n-                    match_results<_Bp, _Ap>&,\n-                    const basic_regex<_Cp, _Rp>&,\n-                    regex_constants::match_flag_type);\n+\tfriend bool\n+\tregex_match(_Bp, _Bp,\n+\t\t    match_results<_Bp, _Ap>&,\n+\t\t    const basic_regex<_Cp, _Rp>&,\n+\t\t    regex_constants::match_flag_type);\n \n       template<typename _Bp, typename _Ap, typename _Cp, typename _Rp>\n-        friend bool\n-        regex_search(_Bp, _Bp,\n-                     match_results<_Bp, _Ap>&,\n-                     const basic_regex<_Cp, _Rp>&,\n-                     regex_constants::match_flag_type);\n+\tfriend bool\n+\tregex_search(_Bp, _Bp,\n+\t\t     match_results<_Bp, _Ap>&,\n+\t\t     const basic_regex<_Cp, _Rp>&,\n+\t\t     regex_constants::match_flag_type);\n \n       flag_type     _M_flags;\n       _Rx_traits    _M_traits;\n@@ -1220,8 +1220,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Alias for sub_match'd string.\n   template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n     using __sub_match_string = basic_string<\n-                              typename iterator_traits<_Bi_iter>::value_type,\n-                              _Ch_traits, _Ch_alloc>;\n+\t\t\t      typename iterator_traits<_Bi_iter>::value_type,\n+\t\t\t      _Ch_traits, _Ch_alloc>;\n \n   /**\n    * @brief Tests the equivalence of a string and a regular expression\n@@ -2019,50 +2019,50 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * @todo Implement this function.\n        */\n       template<typename _Out_iter>\n-        _Out_iter\n-        format(_Out_iter __out, const char_type* __fmt_first,\n+\t_Out_iter\n+\tformat(_Out_iter __out, const char_type* __fmt_first,\n \t       const char_type* __fmt_last,\n \t       match_flag_type __flags = regex_constants::format_default) const\n-        { return __out; }\n+\t{ return __out; }\n \n       /**\n        * @pre   ready() == true\n        */\n       template<typename _Out_iter, typename _St, typename _Sa>\n-        _Out_iter\n-        format(_Out_iter __out, const basic_string<char_type, _St, _Sa>& __fmt,\n+\t_Out_iter\n+\tformat(_Out_iter __out, const basic_string<char_type, _St, _Sa>& __fmt,\n \t       match_flag_type __flags = regex_constants::format_default) const\n-        {\n-          return format(__out, __fmt.data(), __fmt.data() + __fmt.size(),\n-                        __flags);\n-        }\n+\t{\n+\t  return format(__out, __fmt.data(), __fmt.data() + __fmt.size(),\n+\t\t\t__flags);\n+\t}\n \n       /**\n        * @pre   ready() == true\n        */\n       template<typename _Out_iter, typename _St, typename _Sa>\n-        basic_string<char_type, _St, _Sa>\n-        format(const basic_string<char_type, _St, _Sa>& __fmt,\n+\tbasic_string<char_type, _St, _Sa>\n+\tformat(const basic_string<char_type, _St, _Sa>& __fmt,\n \t       match_flag_type __flags = regex_constants::format_default) const\n-        {\n-          basic_string<char_type, _St, _Sa> __result;\n-          format(std::back_inserter(__result), __fmt, __flags);\n-          return __result;\n-        }\n+\t{\n+\t  basic_string<char_type, _St, _Sa> __result;\n+\t  format(std::back_inserter(__result), __fmt, __flags);\n+\t  return __result;\n+\t}\n \n       /**\n        * @pre   ready() == true\n        */\n       string_type\n       format(const char_type* __fmt,\n-             match_flag_type __flags = regex_constants::format_default) const\n+\t     match_flag_type __flags = regex_constants::format_default) const\n       {\n-        string_type __result;\n-        format(std::back_inserter(__result),\n-               __fmt,\n-               __fmt + char_traits<char_type>::length(__fmt),\n-               __flags);\n-        return __result;\n+\tstring_type __result;\n+\tformat(std::back_inserter(__result),\n+\t       __fmt,\n+\t       __fmt + char_traits<char_type>::length(__fmt),\n+\t       __flags);\n+\treturn __result;\n       }\n \n       //@}\n@@ -2096,27 +2096,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       template<typename, typename, typename, typename>\n-        friend class __detail::_Executor;\n+\tfriend class __detail::_Executor;\n \n       template<typename, typename, typename, typename>\n-        friend class __detail::_DFSExecutor;\n+\tfriend class __detail::_DFSExecutor;\n \n       template<typename, typename, typename, typename>\n-        friend class __detail::_BFSExecutor;\n+\tfriend class __detail::_BFSExecutor;\n \n       template<typename _Bp, typename _Ap, typename _Ch_type, typename _Rx_traits>\n-        friend bool\n-        regex_match(_Bp, _Bp, match_results<_Bp, _Ap>&,\n-                    const basic_regex<_Ch_type,\n-                    _Rx_traits>&,\n-                    regex_constants::match_flag_type);\n+\tfriend bool\n+\tregex_match(_Bp, _Bp, match_results<_Bp, _Ap>&,\n+\t\t    const basic_regex<_Ch_type,\n+\t\t    _Rx_traits>&,\n+\t\t    regex_constants::match_flag_type);\n \n       template<typename _Bp, typename _Ap, typename _Ch_type, typename _Rx_traits>\n-        friend bool\n-        regex_search(_Bp, _Bp, match_results<_Bp, _Ap>&,\n-                     const basic_regex<_Ch_type,\n-                     _Rx_traits>&,\n-                     regex_constants::match_flag_type);\n+\tfriend bool\n+\tregex_search(_Bp, _Bp, match_results<_Bp, _Ap>&,\n+\t\t     const basic_regex<_Ch_type,\n+\t\t     _Rx_traits>&,\n+\t\t     regex_constants::match_flag_type);\n     };\n \n   typedef match_results<const char*>             cmatch;\n@@ -2138,17 +2138,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       const match_results<_Bi_iter, _Alloc>& __m2)\n     {\n       if (__m1.ready() != __m2.ready())\n-        return false;\n+\treturn false;\n       if (!__m1.ready())  // both are not ready\n-        return true;\n+\treturn true;\n       if (__m1.empty() != __m2.empty())\n-        return false;\n+\treturn false;\n       if (__m1.empty())   // both are empty\n-        return true;\n+\treturn true;\n       return __m1.prefix() == __m2.prefix()\n-        && __m1.size() == __m2.size()\n-        && std::equal(__m1.begin(), __m1.end(), __m2.begin())\n-        && __m1.suffix() == __m2.suffix();\n+\t&& __m1.size() == __m2.size()\n+\t&& std::equal(__m1.begin(), __m1.end(), __m2.begin())\n+\t&& __m1.suffix() == __m2.suffix();\n     }\n \n   /**\n@@ -2203,28 +2203,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Ch_type, typename _Rx_traits>\n     bool\n     regex_match(_Bi_iter                                 __s,\n-                _Bi_iter                                 __e,\n-                match_results<_Bi_iter, _Alloc>&         __m,\n-                const basic_regex<_Ch_type, _Rx_traits>& __re,\n-                regex_constants::match_flag_type         __flags\n-                               = regex_constants::match_default)\n+\t\t_Bi_iter                                 __e,\n+\t\tmatch_results<_Bi_iter, _Alloc>&         __m,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type         __flags\n+\t\t\t       = regex_constants::match_default)\n     {\n       if (__re._M_automaton == nullptr)\n-        return false;\n+\treturn false;\n       __detail::__get_executor(__s, __e, __m, __re, __flags)->_M_match();\n       if (__m.size() > 0 && __m[0].matched)\n-        {\n-          for (auto __it : __m)\n-            if (!__it.matched)\n-              __it.first = __it.second = __e;\n-          __m.at(__m.size()).matched = false;\n-          __m.at(__m.size()).first = __s;\n-          __m.at(__m.size()).second = __s;\n-          __m.at(__m.size()+1).matched = false;\n-          __m.at(__m.size()+1).first = __e;\n-          __m.at(__m.size()+1).second = __e;\n-          return true;\n-        }\n+\t{\n+\t  for (auto __it : __m)\n+\t    if (!__it.matched)\n+\t      __it.first = __it.second = __e;\n+\t  __m.at(__m.size()).matched = false;\n+\t  __m.at(__m.size()).first = __s;\n+\t  __m.at(__m.size()).second = __s;\n+\t  __m.at(__m.size()+1).matched = false;\n+\t  __m.at(__m.size()+1).first = __e;\n+\t  __m.at(__m.size()+1).second = __e;\n+\t  return true;\n+\t}\n       return false;\n     }\n \n@@ -2364,18 +2364,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Ch_type, typename _Rx_traits>\n     inline bool\n     regex_search(_Bi_iter __first, _Bi_iter __last,\n-                 match_results<_Bi_iter, _Alloc>& __m,\n-                 const basic_regex<_Ch_type, _Rx_traits>& __re,\n-                 regex_constants::match_flag_type __flags\n-                 = regex_constants::match_default)\n+\t\t match_results<_Bi_iter, _Alloc>& __m,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\t regex_constants::match_flag_type __flags\n+\t\t = regex_constants::match_default)\n     {\n       if (__re._M_automaton == nullptr)\n-        return false;\n+\treturn false;\n       for (auto __cur = __first; __cur != __last; ++__cur) // Any KMP-like algo?\n-        {\n-          __detail::__get_executor(__cur, __last, __m, __re, __flags)\n-            ->_M_search_from_first();\n-          if (__m.size() > 0 && __m[0].matched)\n+\t{\n+\t  __detail::__get_executor(__cur, __last, __m, __re, __flags)\n+\t    ->_M_search_from_first();\n+\t  if (__m.size() > 0 && __m[0].matched)\n \t    {\n \t      for (auto __it : __m)\n \t\tif (!__it.matched)\n@@ -2390,7 +2390,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t(__m.suffix().first != __m.suffix().second);\n \t      return true;\n \t    }\n-        }\n+\t}\n       return false;\n     }\n \n@@ -2641,9 +2641,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       regex_iterator\n       operator++(int)\n       {\n-        auto __tmp = *this;\n-        ++(*this);\n-        return __tmp;\n+\tauto __tmp = *this;\n+\t++(*this);\n+\treturn __tmp;\n       }\n \n     private:\n@@ -2662,11 +2662,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator==(const regex_iterator& __rhs) const\n     {\n       return (_M_match.empty() && __rhs._M_match.empty())\n-        || (_M_begin == __rhs._M_begin\n-            && _M_end == __rhs._M_end\n-            && _M_pregex == __rhs._M_pregex\n-            && _M_flags == __rhs._M_flags\n-            && _M_match[0] == __rhs._M_match[0]);\n+\t|| (_M_begin == __rhs._M_begin\n+\t    && _M_end == __rhs._M_end\n+\t    && _M_pregex == __rhs._M_pregex\n+\t    && _M_flags == __rhs._M_flags\n+\t    && _M_match[0] == __rhs._M_match[0]);\n     }\n \n   template<typename _Bi_iter,\n@@ -2683,27 +2683,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // match[i].position() shall return distance(begin, match[i].first).\n       // [28.12.1.4.5]\n       if (_M_match[0].matched)\n-        {\n-          auto __start = _M_match[0].second;\n-          if (_M_match[0].first == _M_match[0].second)\n-            if (__start == _M_end)\n-              {\n-                _M_match = value_type();\n-                return *this;\n-              }\n-            else\n-              {\n-                if (regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags\n-                                 | regex_constants::match_not_null\n-                                 | regex_constants::match_continuous))\n-                  return *this;\n-                else\n-                  ++__start;\n-              }\n-          _M_flags |= regex_constants::match_prev_avail;\n-          if (!regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags))\n-            _M_match = value_type();\n-        }\n+\t{\n+\t  auto __start = _M_match[0].second;\n+\t  if (_M_match[0].first == _M_match[0].second)\n+\t    if (__start == _M_end)\n+\t      {\n+\t\t_M_match = value_type();\n+\t\treturn *this;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags\n+\t\t\t\t | regex_constants::match_not_null\n+\t\t\t\t | regex_constants::match_continuous))\n+\t\t  return *this;\n+\t\telse\n+\t\t  ++__start;\n+\t      }\n+\t  _M_flags |= regex_constants::match_prev_avail;\n+\t  if (!regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags))\n+\t    _M_match = value_type();\n+\t}\n       return *this;\n     }\n \n@@ -2723,8 +2723,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * value of an iterator of this class is a std::sub_match object.\n    */\n   template<typename _Bi_iter,\n-           typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n-           typename _Rx_traits = regex_traits<_Ch_type> >\n+\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n+\t   typename _Rx_traits = regex_traits<_Ch_type> >\n     class regex_token_iterator\n     {\n     public:\n@@ -2799,7 +2799,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n \t\t\t   const regex_type& __re,\n-                           initializer_list<int> __submatches,\n+\t\t\t   initializer_list<int> __submatches,\n \t\t\t   regex_constants::match_flag_type __m\n \t\t\t     = regex_constants::match_default)\n       : _M_position(__a, __b, __re, __m), _M_subs(__submatches), _M_n(0)\n@@ -2815,7 +2815,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * @param __m          [IN] Policy flags for match rules.\n        */\n       template<std::size_t _Nm>\n-        regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n+\tregex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n \t\t\t     const regex_type& __re,\n \t\t\t     const int (&__submatches)[_Nm],\n \t\t\t     regex_constants::match_flag_type __m\n@@ -2833,8 +2833,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_result(__rhs.result), _M_suffix(__rhs.suffix),\n       _M_has_m1(__rhs._M_has_m1)\n       {\n-        if (__rhs._M_result == &__rhs._M_suffix)\n-          _M_result = &_M_suffix;\n+\tif (__rhs._M_result == &__rhs._M_suffix)\n+\t  _M_result = &_M_suffix;\n       }\n \n       /**\n@@ -2883,9 +2883,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       regex_token_iterator\n       operator++(int)\n       {\n-        auto __tmp = *this;\n-        ++(*this);\n-        return __tmp;\n+\tauto __tmp = *this;\n+\t++(*this);\n+\treturn __tmp;\n       }\n \n     private:\n@@ -2897,10 +2897,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       const value_type&\n       _M_current_match() const\n       {\n-        if (_M_subs[_M_n] == -1)\n-          return (*_M_position).prefix();\n-        else\n-          return (*_M_position)[_M_subs[_M_n]];\n+\tif (_M_subs[_M_n] == -1)\n+\t  return (*_M_position).prefix();\n+\telse\n+\t  return (*_M_position)[_M_subs[_M_n]];\n       }\n \n       bool\n@@ -2918,8 +2918,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   template<typename _Bi_iter,\n-           typename _Ch_type,\n-           typename _Rx_traits>\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n     regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n     regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n     operator=(const regex_token_iterator& __rhs)\n@@ -2931,88 +2931,88 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_suffix = __rhs._M_suffix;\n       _M_has_m1 = __rhs._M_has_m1;\n       if (__rhs._M_result == &__rhs._M_suffix)\n-        _M_result = &_M_suffix;\n+\t_M_result = &_M_suffix;\n     }\n \n   template<typename _Bi_iter,\n-           typename _Ch_type,\n-           typename _Rx_traits>\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n     bool\n     regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n     operator==(const regex_token_iterator& __rhs) const\n     {\n       if (_M_end_of_seq() && __rhs._M_end_of_seq())\n-        return true;\n+\treturn true;\n       if (_M_suffix.matched && __rhs._M_suffix.matched\n-          && _M_suffix == __rhs._M_suffix)\n-        return true;\n+\t  && _M_suffix == __rhs._M_suffix)\n+\treturn true;\n       if (_M_end_of_seq() || _M_suffix.matched\n-          || __rhs._M_end_of_seq() || __rhs._M_suffix.matched)\n-        return false;\n+\t  || __rhs._M_end_of_seq() || __rhs._M_suffix.matched)\n+\treturn false;\n       return _M_position == __rhs._M_position\n-        && _M_n == __rhs._M_n\n-        && _M_subs == __rhs._M_subs;\n+\t&& _M_n == __rhs._M_n\n+\t&& _M_subs == __rhs._M_subs;\n     }\n \n   template<typename _Bi_iter,\n-           typename _Ch_type,\n-           typename _Rx_traits>\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n     regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n     regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n     operator++()\n     {\n       _Position __prev = _M_position;\n       if (_M_suffix.matched)\n-        *this = regex_token_iterator();\n+\t*this = regex_token_iterator();\n       else if (_M_n + 1 < _M_subs.size())\n-        {\n-          _M_n++;\n-          _M_result = &_M_current_match();\n-        }\n+\t{\n+\t  _M_n++;\n+\t  _M_result = &_M_current_match();\n+\t}\n       else\n-        {\n-          _M_n = 0;\n-          ++_M_position;\n-          if (_M_position != _Position())\n-            _M_result = &_M_current_match();\n-          else if (_M_has_m1 && __prev->suffix().length() != 0)\n-            {\n-              _M_suffix.matched = true;\n-              _M_suffix.first = __prev->suffix().first;\n-              _M_suffix.second = __prev->suffix().second;\n-              _M_result = &_M_suffix;\n-            }\n-          else\n-            *this = regex_token_iterator();\n-        }\n+\t{\n+\t  _M_n = 0;\n+\t  ++_M_position;\n+\t  if (_M_position != _Position())\n+\t    _M_result = &_M_current_match();\n+\t  else if (_M_has_m1 && __prev->suffix().length() != 0)\n+\t    {\n+\t      _M_suffix.matched = true;\n+\t      _M_suffix.first = __prev->suffix().first;\n+\t      _M_suffix.second = __prev->suffix().second;\n+\t      _M_result = &_M_suffix;\n+\t    }\n+\t  else\n+\t    *this = regex_token_iterator();\n+\t}\n       return *this;\n     }\n \n   template<typename _Bi_iter,\n-           typename _Ch_type,\n-           typename _Rx_traits>\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n     void\n     regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n     _M_init(_Bi_iter __a, _Bi_iter __b)\n     {\n       _M_has_m1 = false;\n       for (auto __it : _M_subs)\n-        if (__it == -1)\n-          {\n-            _M_has_m1 = true;\n-            break;\n-          }\n+\tif (__it == -1)\n+\t  {\n+\t    _M_has_m1 = true;\n+\t    break;\n+\t  }\n       if (_M_position != _Position())\n-        _M_result = &_M_current_match();\n+\t_M_result = &_M_current_match();\n       else if (_M_has_m1)\n-        {\n-          _M_suffix.matched = true;\n-          _M_suffix.first = __a;\n-          _M_suffix.second = __b;\n-          _M_result = &_M_suffix;\n-        }\n+\t{\n+\t  _M_suffix.matched = true;\n+\t  _M_suffix.first = __a;\n+\t  _M_suffix.second = __b;\n+\t  _M_result = &_M_suffix;\n+\t}\n       else\n-        _M_result = nullptr;\n+\t_M_result = nullptr;\n     }\n \n   /** @brief Token iterator for C-style NULL-terminated strings. */"}, {"sha": "f9e9630636b26a74ab188954fbe307fab335afd3", "filename": "libstdc++-v3/include/bits/regex_automaton.h", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h?ref=e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "patch": "@@ -71,9 +71,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _StateIdT    _M_next;             // outgoing transition\n       union // Since they are mutual exclusive.\n       {\n-        _StateIdT    _M_alt;            // for _S_opcode_alternative\n-        unsigned int _M_subexpr;        // for _S_opcode_subexpr_*\n-        unsigned int _M_backref_index;  // for _S_opcode_backref\n+\t_StateIdT    _M_alt;            // for _S_opcode_alternative\n+\tunsigned int _M_subexpr;        // for _S_opcode_subexpr_*\n+\tunsigned int _M_backref_index;  // for _S_opcode_backref\n       };\n       _MatcherT    _M_matches;          // for _S_opcode_match\n \n@@ -83,17 +83,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _State(const _MatcherT& __m)\n       : _M_opcode(_S_opcode_match), _M_next(_S_invalid_state_id),\n-        _M_matches(__m)\n+\t_M_matches(__m)\n       { }\n \n       _State(_OpcodeT __opcode, unsigned __index)\n       : _M_opcode(__opcode), _M_next(_S_invalid_state_id)\n       {\n-        if (__opcode == _S_opcode_subexpr_begin\n-            || __opcode == _S_opcode_subexpr_end)\n-          _M_subexpr = __index;\n-        else if (__opcode == _S_opcode_backref)\n-          _M_backref_index = __index;\n+\tif (__opcode == _S_opcode_subexpr_begin\n+\t    || __opcode == _S_opcode_subexpr_end)\n+\t  _M_subexpr = __index;\n+\telse if (__opcode == _S_opcode_backref)\n+\t  _M_backref_index = __index;\n       }\n \n       _State(_StateIdT __next, _StateIdT __alt)\n@@ -162,40 +162,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _StateIdT\n       _M_insert_accept()\n       {\n-        this->push_back(_StateT(_S_opcode_accept));\n-        _M_accepting_states.insert(this->size()-1);\n-        return this->size()-1;\n+\tthis->push_back(_StateT(_S_opcode_accept));\n+\t_M_accepting_states.insert(this->size()-1);\n+\treturn this->size()-1;\n       }\n \n       _StateIdT\n       _M_insert_alt(_StateIdT __next, _StateIdT __alt)\n       {\n-        this->push_back(_StateT(__next, __alt));\n-        return this->size()-1;\n+\tthis->push_back(_StateT(__next, __alt));\n+\treturn this->size()-1;\n       }\n \n       _StateIdT\n       _M_insert_matcher(_MatcherT __m)\n       {\n-        this->push_back(_StateT(__m));\n-        return this->size()-1;\n+\tthis->push_back(_StateT(__m));\n+\treturn this->size()-1;\n       }\n \n       _StateIdT\n       _M_insert_subexpr_begin()\n       {\n-        auto __id = _M_subexpr_count++;\n-        _M_paren_stack.push_back(__id);\n-        this->push_back(_StateT(_S_opcode_subexpr_begin, __id));\n-        return this->size()-1;\n+\tauto __id = _M_subexpr_count++;\n+\t_M_paren_stack.push_back(__id);\n+\tthis->push_back(_StateT(_S_opcode_subexpr_begin, __id));\n+\treturn this->size()-1;\n       }\n \n       _StateIdT\n       _M_insert_subexpr_end()\n       {\n-        this->push_back(_StateT(_S_opcode_subexpr_end, _M_paren_stack.back()));\n-        _M_paren_stack.pop_back();\n-        return this->size()-1;\n+\tthis->push_back(_StateT(_S_opcode_subexpr_end, _M_paren_stack.back()));\n+\t_M_paren_stack.pop_back();\n+\treturn this->size()-1;\n       }\n \n       _StateIdT\n@@ -225,27 +225,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     public:\n       // Constructs a single-node sequence\n       _StateSeq(_RegexT& __ss, _StateIdT __s,\n-                _StateIdT __e = _S_invalid_state_id)\n+\t\t_StateIdT __e = _S_invalid_state_id)\n       : _M_nfa(__ss), _M_start(__s), _M_end1(__s), _M_end2(__e)\n       { }\n       // Constructs a split sequence from two other sequencces\n       _StateSeq(const _StateSeq& __e1, const _StateSeq& __e2)\n       : _M_nfa(__e1._M_nfa),\n-        _M_start(_M_nfa._M_insert_alt(__e1._M_start, __e2._M_start)),\n-        _M_end1(__e1._M_end1), _M_end2(__e2._M_end1)\n+\t_M_start(_M_nfa._M_insert_alt(__e1._M_start, __e2._M_start)),\n+\t_M_end1(__e1._M_end1), _M_end2(__e2._M_end1)\n       { }\n \n       // Constructs a split sequence from a single sequence\n       _StateSeq(const _StateSeq& __e, _StateIdT __id)\n       : _M_nfa(__e._M_nfa),\n-        _M_start(_M_nfa._M_insert_alt(__id, __e._M_start)),\n-        _M_end1(__id), _M_end2(__e._M_end1)\n+\t_M_start(_M_nfa._M_insert_alt(__id, __e._M_start)),\n+\t_M_end1(__id), _M_end2(__e._M_end1)\n       { }\n \n       // Constructs a copy of a %_StateSeq\n       _StateSeq(const _StateSeq& __rhs)\n       : _M_nfa(__rhs._M_nfa), _M_start(__rhs._M_start),\n-        _M_end1(__rhs._M_end1), _M_end2(__rhs._M_end2)\n+\t_M_end1(__rhs._M_end1), _M_end2(__rhs._M_end2)\n       { }\n \n       _StateSeq& operator=(const _StateSeq& __rhs);"}, {"sha": "2c25d97549cf6e4c8002fcbed359090b21856bb3", "filename": "libstdc++-v3/include/bits/regex_automaton.tcc", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc?ref=e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "patch": "@@ -41,27 +41,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       switch (_M_opcode)\n       {\n-        case _S_opcode_alternative:\n-          ostr << \"alt next=\" << _M_next << \" alt=\" << _M_alt;\n-          break;\n-        case _S_opcode_subexpr_begin:\n-          ostr << \"subexpr begin next=\" << _M_next << \" index=\" << _M_subexpr;\n-          break;\n-        case _S_opcode_subexpr_end:\n-          ostr << \"subexpr end next=\" << _M_next << \" index=\" << _M_subexpr;\n-          break;\n-        case _S_opcode_backref:\n-          ostr << \"backref next=\" << _M_next << \" index=\" << _M_backref_index;\n-          break;\n-        case _S_opcode_match:\n-          ostr << \"match next=\" << _M_next;\n-          break;\n-        case _S_opcode_accept:\n-          ostr << \"accept next=\" << _M_next;\n-          break;\n-        default:\n-          ostr << \"unknown next=\" << _M_next;\n-          break;\n+\tcase _S_opcode_alternative:\n+\t  ostr << \"alt next=\" << _M_next << \" alt=\" << _M_alt;\n+\t  break;\n+\tcase _S_opcode_subexpr_begin:\n+\t  ostr << \"subexpr begin next=\" << _M_next << \" index=\" << _M_subexpr;\n+\t  break;\n+\tcase _S_opcode_subexpr_end:\n+\t  ostr << \"subexpr end next=\" << _M_next << \" index=\" << _M_subexpr;\n+\t  break;\n+\tcase _S_opcode_backref:\n+\t  ostr << \"backref next=\" << _M_next << \" index=\" << _M_backref_index;\n+\t  break;\n+\tcase _S_opcode_match:\n+\t  ostr << \"match next=\" << _M_next;\n+\t  break;\n+\tcase _S_opcode_accept:\n+\t  ostr << \"accept next=\" << _M_next;\n+\t  break;\n+\tdefault:\n+\t  ostr << \"unknown next=\" << _M_next;\n+\t  break;\n       }\n       return ostr;\n     }\n@@ -73,39 +73,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       switch (_M_opcode)\n       {\n-        case _S_opcode_alternative:\n-          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nALT\\\"];\\n\"\n-                 << __id << \" -> \" << _M_next\n-                 << \" [label=\\\"epsilon\\\", tailport=\\\"s\\\"];\\n\"\n-                 << __id << \" -> \" << _M_alt\n-                 << \" [label=\\\"epsilon\\\", tailport=\\\"n\\\"];\\n\";\n-          break;\n-        case _S_opcode_subexpr_begin:\n-          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSBEGIN \"\n-                 << _M_subexpr << \"\\\"];\\n\"\n-                 << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n-          break;\n-        case _S_opcode_subexpr_end:\n-          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSEND \"\n-                 << _M_subexpr << \"\\\"];\\n\"\n-                 << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n-          break;\n-        case _S_opcode_backref:\n-          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nBACKREF \"\n-                 << _M_subexpr << \"\\\"];\\n\"\n-                 << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n-          break;\n-        case _S_opcode_match:\n-          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nMATCH\\\"];\\n\"\n-                 << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n-          break;\n-        case _S_opcode_accept:\n-          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nACC\\\"];\\n\" ;\n-          break;\n-        default:\n-          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nUNK\\\"];\\n\"\n-                 << __id << \" -> \" << _M_next << \" [label=\\\"?\\\"];\\n\";\n-          break;\n+\tcase _S_opcode_alternative:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nALT\\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_next\n+\t\t << \" [label=\\\"epsilon\\\", tailport=\\\"s\\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_alt\n+\t\t << \" [label=\\\"epsilon\\\", tailport=\\\"n\\\"];\\n\";\n+\t  break;\n+\tcase _S_opcode_subexpr_begin:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSBEGIN \"\n+\t\t << _M_subexpr << \"\\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+\t  break;\n+\tcase _S_opcode_subexpr_end:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSEND \"\n+\t\t << _M_subexpr << \"\\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+\t  break;\n+\tcase _S_opcode_backref:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nBACKREF \"\n+\t\t << _M_subexpr << \"\\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n+\t  break;\n+\tcase _S_opcode_match:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nMATCH\\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n+\t  break;\n+\tcase _S_opcode_accept:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nACC\\\"];\\n\" ;\n+\t  break;\n+\tdefault:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nUNK\\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_next << \" [label=\\\"?\\\"];\\n\";\n+\t  break;\n       }\n       return __ostr;\n     }\n@@ -135,10 +135,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // _M_paren_stack is {1, 3}, for incomplete \"(a..\" and \"(c..\". At this\n       // time, \"\\\\2\" is valid, but \"\\\\1\" and \"\\\\3\" are not.\n       if (__index >= _M_subexpr_count)\n-        __throw_regex_error(regex_constants::error_backref);\n+\t__throw_regex_error(regex_constants::error_backref);\n       for (auto __it : _M_paren_stack)\n-        if (__index == __it)\n-          __throw_regex_error(regex_constants::error_backref);\n+\tif (__index == __it)\n+\t  __throw_regex_error(regex_constants::error_backref);\n       _M_has_backref = true;\n       this->push_back(_StateT(_S_opcode_backref, __index));\n       return this->size()-1;\n@@ -159,7 +159,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_push_back(_StateIdT __id)\n     {\n       if (_M_end1 != _S_invalid_state_id)\n-        _M_nfa[_M_end1]._M_next = __id;\n+\t_M_nfa[_M_end1]._M_next = __id;\n       _M_end1 = __id;\n     }\n \n@@ -169,14 +169,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (_M_end2 != _S_invalid_state_id)\n       {\n-        if (_M_end2 == _M_end1)\n-          _M_nfa[_M_end2]._M_alt = __id;\n-        else\n-          _M_nfa[_M_end2]._M_next = __id;\n-        _M_end2 = _S_invalid_state_id;\n+\tif (_M_end2 == _M_end1)\n+\t  _M_nfa[_M_end2]._M_alt = __id;\n+\telse\n+\t  _M_nfa[_M_end2]._M_next = __id;\n+\t_M_end2 = _S_invalid_state_id;\n       }\n       if (_M_end1 != _S_invalid_state_id)\n-        _M_nfa[_M_end1]._M_next = __id;\n+\t_M_nfa[_M_end1]._M_next = __id;\n       _M_end1 = __id;\n     }\n \n@@ -186,16 +186,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (_M_end2 != _S_invalid_state_id)\n       {\n-        if (_M_end2 == _M_end1)\n-          _M_nfa[_M_end2]._M_alt = __rhs._M_start;\n-        else\n-          _M_nfa[_M_end2]._M_next = __rhs._M_start;\n-        _M_end2 = _S_invalid_state_id;\n+\tif (_M_end2 == _M_end1)\n+\t  _M_nfa[_M_end2]._M_alt = __rhs._M_start;\n+\telse\n+\t  _M_nfa[_M_end2]._M_next = __rhs._M_start;\n+\t_M_end2 = _S_invalid_state_id;\n       }\n       if (__rhs._M_end2 != _S_invalid_state_id)\n-        _M_end2 = __rhs._M_end2;\n+\t_M_end2 = __rhs._M_end2;\n       if (_M_end1 != _S_invalid_state_id)\n-        _M_nfa[_M_end1]._M_next = __rhs._M_start;\n+\t_M_nfa[_M_end1]._M_next = __rhs._M_start;\n       _M_end1 = __rhs._M_end1;\n     }\n "}, {"sha": "4ab36d28d2b3bd5617d1c780f48d2bae120b9be3", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "patch": "@@ -49,10 +49,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       explicit\n       _BracketMatcher(bool __is_non_matching,\n-                      const _TraitsT& __t,\n-                      _FlagT __flags)\n+\t\t      const _TraitsT& __t,\n+\t\t      _FlagT __flags)\n       : _M_is_non_matching(__is_non_matching), _M_traits(__t),\n-        _M_flags(__flags), _M_class_set(0)\n+\t_M_flags(__flags), _M_class_set(0)\n       { }\n \n       bool\n@@ -61,40 +61,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_add_char(_CharT __c)\n       {\n-        if (_M_flags & regex_constants::collate)\n-          if (_M_is_icase())\n-            _M_char_set.push_back(_M_traits.translate_nocase(__c));\n-          else\n-            _M_char_set.push_back(_M_traits.translate(__c));\n-        else\n-          _M_char_set.push_back(__c);\n+\tif (_M_flags & regex_constants::collate)\n+\t  if (_M_is_icase())\n+\t    _M_char_set.push_back(_M_traits.translate_nocase(__c));\n+\t  else\n+\t    _M_char_set.push_back(_M_traits.translate(__c));\n+\telse\n+\t  _M_char_set.push_back(__c);\n       }\n \n       void\n       _M_add_collating_element(const _StringT& __s)\n       {\n-        auto __st = _M_traits.lookup_collatename(&*__s.begin(), &*__s.end());\n-        if (__st.empty())\n-          __throw_regex_error(regex_constants::error_collate);\n-        // TODO: digraph\n-        _M_char_set.push_back(__st[0]);\n+\tauto __st = _M_traits.lookup_collatename(&*__s.begin(), &*__s.end());\n+\tif (__st.empty())\n+\t  __throw_regex_error(regex_constants::error_collate);\n+\t// TODO: digraph\n+\t_M_char_set.push_back(__st[0]);\n       }\n \n       void\n       _M_add_equivalence_class(const _StringT& __s)\n       {\n-        _M_add_character_class(\n-          _M_traits.transform_primary(&*__s.begin(), &*__s.end()));\n+\t_M_add_character_class(\n+\t  _M_traits.transform_primary(&*__s.begin(), &*__s.end()));\n       }\n \n       void\n       _M_add_character_class(const _StringT& __s)\n       {\n-        auto __st = _M_traits.\n-          lookup_classname(&*__s.begin(), &*__s.end(), _M_is_icase());\n-        if (__st == 0)\n-          __throw_regex_error(regex_constants::error_ctype);\n-        _M_class_set |= __st;\n+\tauto __st = _M_traits.\n+\t  lookup_classname(&*__s.begin(), &*__s.end(), _M_is_icase());\n+\tif (__st == 0)\n+\t  __throw_regex_error(regex_constants::error_ctype);\n+\t_M_class_set |= __st;\n       }\n \n       void\n@@ -108,11 +108,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _StringT\n       _M_get_str(_CharT __c) const\n       {\n-        auto __s = _StringT(1,\n-                            _M_is_icase()\n-                            ? _M_traits.translate_nocase(__c)\n-                            : _M_traits.translate(__c));\n-        return _M_traits.transform(__s.begin(), __s.end());\n+\tauto __s = _StringT(1,\n+\t\t\t    _M_is_icase()\n+\t\t\t    ? _M_traits.translate_nocase(__c)\n+\t\t\t    : _M_traits.translate(__c));\n+\treturn _M_traits.transform(__s.begin(), __s.end());\n       }\n \n       _TraitsT                              _M_traits;\n@@ -177,9 +177,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       };\n \n       _Scanner(_InputIter __begin, _InputIter __end,\n-               _FlagT __flags, std::locale __loc)\n+\t       _FlagT __flags, std::locale __loc)\n       : _M_current(__begin) , _M_end(__end) , _M_flags(__flags),\n-        _M_ctype(std::use_facet<_CtypeT>(__loc)), _M_state(0)\n+\t_M_ctype(std::use_facet<_CtypeT>(__loc)), _M_state(0)\n       { _M_advance(); }\n \n       void\n@@ -238,7 +238,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef regex_constants::syntax_option_type _FlagT;\n \n       _Compiler(_InputIter __b, _InputIter __e,\n-                const _TraitsT& __traits, _FlagT __flags);\n+\t\tconst _TraitsT& __traits, _FlagT __flags);\n \n       std::shared_ptr<_RegexT>\n       _M_get_nfa() const"}, {"sha": "5755c2a0e86ae3f7f1dcec309909f4c7117204a6", "filename": "libstdc++-v3/include/bits/regex_compiler.tcc", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc?ref=e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "patch": "@@ -98,13 +98,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       else if (__c == _M_ctype.widen('['))\n \t{\n-          if (*++_M_current == _M_ctype.widen('^'))\n-            {\n-              _M_curToken = _S_token_bracket_inverse_begin;\n-              ++_M_current;\n-            }\n-          else\n-            _M_curToken = _S_token_bracket_begin;\n+\t  if (*++_M_current == _M_ctype.widen('^'))\n+\t    {\n+\t      _M_curToken = _S_token_bracket_inverse_begin;\n+\t      ++_M_current;\n+\t    }\n+\t  else\n+\t    _M_curToken = _S_token_bracket_begin;\n \t  _M_state |= _S_state_in_bracket;\n \t  return;\n \t}\n@@ -223,16 +223,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       else if (*_M_current == _M_ctype.widen(']'))\n \t{\n-          _M_curToken = _S_token_bracket_end;\n-          _M_state &= ~_S_state_in_bracket;\n-          ++_M_current;\n-          return;\n+\t  _M_curToken = _S_token_bracket_end;\n+\t  _M_state &= ~_S_state_in_bracket;\n+\t  ++_M_current;\n+\t  return;\n \t}\n       else if (*_M_current == _M_ctype.widen('\\\\'))\n-        {\n+\t{\n \t  _M_eat_escape();\n \t  return;\n-        }\n+\t}\n       _M_curToken = _S_token_collelem_single;\n       _M_curValue.assign(1, *_M_current);\n       ++_M_current;\n@@ -341,23 +341,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_curValue.assign(1, __c);\n \t}\n       else if (_M_state & _S_state_in_bracket)\n-        {\n-          if (__c == _M_ctype.widen('-')\n-              || __c == _M_ctype.widen('[')\n-              || __c == _M_ctype.widen(']'))\n-            {\n-              _M_curToken = _S_token_ord_char;\n-              _M_curValue.assign(1, __c);\n-            }\n-          else if ((_M_flags & regex_constants::ECMAScript)\n-                   && __c == _M_ctype.widen('b'))\n-            {\n-              _M_curToken = _S_token_ord_char;\n-              _M_curValue.assign(1, _M_ctype.widen(' '));\n-            }\n-          else\n-            __throw_regex_error(regex_constants::error_escape);\n-        }\n+\t{\n+\t  if (__c == _M_ctype.widen('-')\n+\t      || __c == _M_ctype.widen('[')\n+\t      || __c == _M_ctype.widen(']'))\n+\t    {\n+\t      _M_curToken = _S_token_ord_char;\n+\t      _M_curValue.assign(1, __c);\n+\t    }\n+\t  else if ((_M_flags & regex_constants::ECMAScript)\n+\t\t   && __c == _M_ctype.widen('b'))\n+\t    {\n+\t      _M_curToken = _S_token_ord_char;\n+\t      _M_curValue.assign(1, _M_ctype.widen(' '));\n+\t    }\n+\t  else\n+\t    __throw_regex_error(regex_constants::error_escape);\n+\t}\n       else\n \t__throw_regex_error(regex_constants::error_escape);\n     }\n@@ -444,8 +444,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  ostr << \"bracket-begin\\n\";\n \t  break;\n \tcase _S_token_bracket_inverse_begin:\n-          ostr << \"bracket-inverse-begin\\n\";\n-          break;\n+\t  ostr << \"bracket-inverse-begin\\n\";\n+\t  break;\n \tcase _S_token_bracket_end:\n \t  ostr << \"bracket-end\\n\";\n \t  break;\n@@ -518,8 +518,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tcase _S_token_unknown:\n \t  ostr << \"-- unknown token --\\n\";\n \t  break;\n-        default:\n-          _GLIBCXX_DEBUG_ASSERT(false);\n+\tdefault:\n+\t  _GLIBCXX_DEBUG_ASSERT(false);\n       }\n       return ostr;\n     }\n@@ -528,7 +528,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _InputIter, typename _CharT, typename _TraitsT>\n     _Compiler<_InputIter, _CharT, _TraitsT>::\n     _Compiler(_InputIter __b, _InputIter __e,\n-              const _TraitsT& __traits, _FlagT __flags)\n+\t      const _TraitsT& __traits, _FlagT __flags)\n     : _M_traits(__traits), _M_scanner(__b, __e, __flags, _M_traits.getloc()),\n       _M_state_store(__flags), _M_flags(__flags)\n     {\n@@ -551,8 +551,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (token == _M_scanner._M_token())\n \t{\n-          _M_cur_value = _M_scanner._M_value();\n-          _M_scanner._M_advance();\n+\t  _M_cur_value = _M_scanner._M_value();\n+\t  _M_scanner._M_advance();\n \t  return true;\n \t}\n       return false;\n@@ -714,39 +714,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (_M_match_token(_ScannerT::_S_token_anychar))\n \t{\n-          const static auto&\n-          __any_matcher = [](_CharT) -> bool\n-          { return true; };\n+\t  const static auto&\n+\t  __any_matcher = [](_CharT) -> bool\n+\t  { return true; };\n \n \t  _M_stack.push(_StateSeqT(_M_state_store,\n-                                  _M_state_store._M_insert_matcher\n-                                  (__any_matcher)));\n+\t\t\t\t  _M_state_store._M_insert_matcher\n+\t\t\t\t  (__any_matcher)));\n \t  return true;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_ord_char))\n \t{\n-          auto __c = _M_cur_value[0];\n-          __detail::_Matcher<_CharT> f;\n-          if (_M_flags & regex_constants::icase)\n-            {\n-              auto __traits = this->_M_traits;\n-              __c = __traits.translate_nocase(__c);\n-              f = [__traits, __c](_CharT __ch) -> bool\n-              { return __traits.translate_nocase(__ch) == __c; };\n-            }\n-          else\n-            f = [__c](_CharT __ch) -> bool\n-            { return __ch == __c; };\n+\t  auto __c = _M_cur_value[0];\n+\t  __detail::_Matcher<_CharT> f;\n+\t  if (_M_flags & regex_constants::icase)\n+\t    {\n+\t      auto __traits = this->_M_traits;\n+\t      __c = __traits.translate_nocase(__c);\n+\t      f = [__traits, __c](_CharT __ch) -> bool\n+\t      { return __traits.translate_nocase(__ch) == __c; };\n+\t    }\n+\t  else\n+\t    f = [__c](_CharT __ch) -> bool\n+\t    { return __ch == __c; };\n \n \t  _M_stack.push(_StateSeqT(_M_state_store,\n-                                   _M_state_store._M_insert_matcher(f)));\n+\t\t\t\t   _M_state_store._M_insert_matcher(f)));\n \t  return true;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_backref))\n \t{\n \t  // __m.push(_Matcher::_S_opcode_ordchar, _M_cur_value);\n \t  _M_stack.push(_StateSeqT(_M_state_store, _M_state_store.\n-                                   _M_insert_backref(_M_cur_int_value(10))));\n+\t\t\t\t   _M_insert_backref(_M_cur_int_value(10))));\n \t  return true;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_subexpr_begin))\n@@ -776,17 +776,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_bracket_expression()\n     {\n       bool __inverse =\n-        _M_match_token(_ScannerT::_S_token_bracket_inverse_begin);\n+\t_M_match_token(_ScannerT::_S_token_bracket_inverse_begin);\n       if (!(__inverse || _M_match_token(_ScannerT::_S_token_bracket_begin)))\n-        return false;\n+\treturn false;\n       _BMatcherT __matcher( __inverse, _M_traits, _M_flags);\n       // special case: only if  _not_ chr first after\n       // '[' or '[^' or if ECMAscript\n       if (!_M_bracket_list(__matcher) // list is empty\n-          && !(_M_flags & regex_constants::ECMAScript))\n-        __throw_regex_error(regex_constants::error_brack);\n+\t  && !(_M_flags & regex_constants::ECMAScript))\n+\t__throw_regex_error(regex_constants::error_brack);\n       _M_stack.push(_StateSeqT(_M_state_store,\n-                              _M_state_store._M_insert_matcher(__matcher)));\n+\t\t\t      _M_state_store._M_insert_matcher(__matcher)));\n       return true;\n     }\n \n@@ -796,7 +796,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_bracket_list(_BMatcherT& __matcher)\n     {\n       if (_M_match_token(_ScannerT::_S_token_bracket_end))\n-        return false;\n+\treturn false;\n       _M_expression_term(__matcher);\n       _M_bracket_list(__matcher);\n       return true;\n@@ -823,25 +823,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_collelem_single)) // [a\n-        {\n-          auto __ch = _M_cur_value[0];\n-          if (_M_match_token(_ScannerT::_S_token_dash)) // [a-\n-            {\n-              // If the dash is the last character in the bracket expression,\n-              // it is not special.\n-              if (_M_scanner._M_token() == _ScannerT::_S_token_bracket_end)\n-                __matcher._M_add_char(_M_cur_value[0]); // [a-] <=> [a\\-]\n-              else // [a-z]\n-                {\n-                  if (!_M_match_token(_ScannerT::_S_token_collelem_single))\n-                    __throw_regex_error(regex_constants::error_range);\n-                  __matcher._M_make_range(__ch, _M_cur_value[0]);\n-                }\n-            }\n-          else // [a]\n-            __matcher._M_add_char(__ch);\n-          return;\n-        }\n+\t{\n+\t  auto __ch = _M_cur_value[0];\n+\t  if (_M_match_token(_ScannerT::_S_token_dash)) // [a-\n+\t    {\n+\t      // If the dash is the last character in the bracket expression,\n+\t      // it is not special.\n+\t      if (_M_scanner._M_token() == _ScannerT::_S_token_bracket_end)\n+\t\t__matcher._M_add_char(_M_cur_value[0]); // [a-] <=> [a\\-]\n+\t      else // [a-z]\n+\t\t{\n+\t\t  if (!_M_match_token(_ScannerT::_S_token_collelem_single))\n+\t\t    __throw_regex_error(regex_constants::error_range);\n+\t\t  __matcher._M_make_range(__ch, _M_cur_value[0]);\n+\t\t}\n+\t    }\n+\t  else // [a]\n+\t    __matcher._M_add_char(__ch);\n+\t  return;\n+\t}\n       __throw_regex_error(regex_constants::error_brack);\n     }\n \n@@ -863,32 +863,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       auto __oldch = __ch;\n       if (_M_flags & regex_constants::collate)\n-        if (_M_is_icase())\n-          __ch = _M_traits.translate_nocase(__ch);\n-        else\n-          __ch = _M_traits.translate(__ch);\n+\tif (_M_is_icase())\n+\t  __ch = _M_traits.translate_nocase(__ch);\n+\telse\n+\t  __ch = _M_traits.translate(__ch);\n \n       bool __ret = false;\n       for (auto __c : _M_char_set)\n-        if (__c == __ch)\n-          {\n-            __ret = true;\n-            break;\n-          }\n+\tif (__c == __ch)\n+\t  {\n+\t    __ret = true;\n+\t    break;\n+\t  }\n       if (!__ret && _M_traits.isctype(__oldch, _M_class_set))\n-        __ret = true;\n+\t__ret = true;\n       else\n-        {\n-          _StringT __s = _M_get_str(__ch);\n-          for (auto& __it : _M_range_set)\n-            if (__it.first <= __s && __s <= __it.second)\n-              {\n-                __ret = true;\n-                break;\n-              }\n-        }\n+\t{\n+\t  _StringT __s = _M_get_str(__ch);\n+\t  for (auto& __it : _M_range_set)\n+\t    if (__it.first <= __s && __s <= __it.second)\n+\t      {\n+\t\t__ret = true;\n+\t\tbreak;\n+\t      }\n+\t}\n       if (_M_is_non_matching)\n-        __ret = !__ret;\n+\t__ret = !__ret;\n       return __ret;\n     }\n "}, {"sha": "23174becdf9655373884b2ec8db12d31f7eef24d", "filename": "libstdc++-v3/include/bits/regex_constants.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h?ref=e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "patch": "@@ -164,21 +164,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   operator&(syntax_option_type __a, syntax_option_type __b)\n   {\n     return (syntax_option_type)(static_cast<unsigned int>(__a)\n-                                & static_cast<unsigned int>(__b));\n+\t\t\t\t& static_cast<unsigned int>(__b));\n   }\n \n   constexpr inline syntax_option_type\n   operator|(syntax_option_type __a, syntax_option_type __b)\n   {\n     return (syntax_option_type)(static_cast<unsigned int>(__a)\n-                                | static_cast<unsigned int>(__b));\n+\t\t\t\t| static_cast<unsigned int>(__b));\n   }\n \n   constexpr inline syntax_option_type\n   operator^(syntax_option_type __a, syntax_option_type __b)\n   {\n     return (syntax_option_type)(static_cast<unsigned int>(__a)\n-                                ^ static_cast<unsigned int>(__b));\n+\t\t\t\t^ static_cast<unsigned int>(__b));\n   }\n \n   constexpr inline syntax_option_type"}, {"sha": "23998ed064d99f869ced4b795c55d51229c17f03", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "patch": "@@ -76,17 +76,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     protected:\n       typedef typename _NFA<_CharT, _TraitsT>::_SizeT _SizeT;\n       _Executor(_BiIter    __begin,\n-                _BiIter    __end,\n-                _ResultsT& __results,\n-                _FlagT     __flags,\n-                _SizeT     __size)\n+\t\t_BiIter    __end,\n+\t\t_ResultsT& __results,\n+\t\t_FlagT     __flags,\n+\t\t_SizeT     __size)\n       : _M_current(__begin), _M_end(__end), _M_results(__results),\n-        _M_flags(__flags)\n+\t_M_flags(__flags)\n       {\n-        __size += 2;\n-        _M_results.resize(__size);\n-        for (auto __i = 0; __i < __size; __i++)\n-          _M_results[__i].matched = false;\n+\t__size += 2;\n+\t_M_results.resize(__size);\n+\tfor (auto __i = 0; __i < __size; __i++)\n+\t  _M_results[__i].matched = false;\n       }\n \n       _BiIter       _M_current;\n@@ -121,12 +121,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef regex_constants::match_flag_type             _FlagT;\n \n       _DFSExecutor(_BiIter        __begin,\n-                   _BiIter        __end,\n-                   _ResultsT&     __results,\n-                   const _RegexT& __nfa,\n-                   _FlagT         __flags)\n+\t\t   _BiIter        __end,\n+\t\t   _ResultsT&     __results,\n+\t\t   const _RegexT& __nfa,\n+\t\t   _FlagT         __flags)\n       : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count()),\n-        _M_traits(_TraitsT()), _M_nfa(__nfa), _M_results_ret(this->_M_results)\n+\t_M_traits(_TraitsT()), _M_nfa(__nfa), _M_results_ret(this->_M_results)\n       { }\n \n       void\n@@ -139,8 +139,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       template<bool __match_mode>\n-        bool\n-        _M_dfs(_StateIdT __i);\n+\tbool\n+\t_M_dfs(_StateIdT __i);\n \n       _ResultsVec    _M_results_ret;\n       _TraitsT       _M_traits;\n@@ -174,17 +174,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef regex_constants::match_flag_type             _FlagT;\n \n       _BFSExecutor(_BiIter        __begin,\n-                   _BiIter        __end,\n-                   _ResultsT&     __results,\n-                   const _RegexT& __nfa,\n-                   _FlagT         __flags)\n+\t\t   _BiIter        __end,\n+\t\t   _ResultsT&     __results,\n+\t\t   const _RegexT& __nfa,\n+\t\t   _FlagT         __flags)\n       : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count()),\n-        _M_nfa(__nfa)\n+\t_M_nfa(__nfa)\n       {\n-        if (_M_nfa._M_start() != _S_invalid_state_id)\n-          _M_covered[_M_nfa._M_start()] =\n-            _ResultsPtr(new _ResultsVec(this->_M_results));\n-        _M_e_closure();\n+\tif (_M_nfa._M_start() != _S_invalid_state_id)\n+\t  _M_covered[_M_nfa._M_start()] =\n+\t    _ResultsPtr(new _ResultsVec(this->_M_results));\n+\t_M_e_closure();\n       }\n \n       void\n@@ -197,8 +197,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       template<bool __match_mode>\n-        void\n-        _M_main_loop();\n+\tvoid\n+\t_M_main_loop();\n \n       void\n       _M_e_closure();"}, {"sha": "bc99331ce8e9d0d3ee60f12a3ef0954b5e230584", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 204, "deletions": 204, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "patch": "@@ -41,97 +41,97 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_dfs(_StateIdT __i)\n     {\n       if (__i == _S_invalid_state_id)\n-        // This is not that certain. Need deeper investigate.\n-        return false;\n+\t// This is not that certain. Need deeper investigate.\n+\treturn false;\n       auto& __current = this->_M_current;\n       auto& __end = this->_M_end;\n       auto& __results = _M_results_ret;\n       const auto& __state = _M_nfa[__i];\n       bool __ret = false;\n       switch (__state._M_opcode)\n-        {\n-        case _S_opcode_alternative:\n-          // Greedy mode by default. For non-greedy mode,\n-          // swap _M_alt and _M_next.\n-          // TODO: Add greedy mode option.\n-          __ret = _M_dfs<__match_mode>(__state._M_alt)\n-            || _M_dfs<__match_mode>(__state._M_next);\n-          break;\n-        case _S_opcode_subexpr_begin:\n-          // Here's the critical part: if there's nothing changed since last\n-          // visit, do NOT continue. This prevents the executor from get into\n-          // infinite loop when use \"()*\" to match \"\".\n-          //\n-          // Every change on __results will be roll back after the recursion\n-          // step finished.\n-          if (!__results[__state._M_subexpr].matched\n-              || __results[__state._M_subexpr].first != __current)\n-            {\n-              auto __back = __current;\n-              __results[__state._M_subexpr].first = __current;\n-              __ret = _M_dfs<__match_mode>(__state._M_next);\n-              __results[__state._M_subexpr].first = __back;\n-            }\n-          break;\n-        case _S_opcode_subexpr_end:\n-          if (__results[__state._M_subexpr].second != __current\n-              || __results[__state._M_subexpr].matched != true)\n-            {\n-              auto __back = __results[__state._M_subexpr];\n-              __results[__state._M_subexpr].second = __current;\n-              __results[__state._M_subexpr].matched = true;\n-              __ret = _M_dfs<__match_mode>(__state._M_next);\n-              __results[__state._M_subexpr] = __back;\n-            }\n-          else\n-            __ret = _M_dfs<__match_mode>(__state._M_next);\n-          break;\n-        case _S_opcode_match:\n-          if (__current != __end && __state._M_matches(*__current))\n-            {\n-              ++__current;\n-              __ret = _M_dfs<__match_mode>(__state._M_next);\n-              --__current;\n-            }\n-          break;\n-        // First fetch the matched result from __results as __submatch;\n-        // then compare it with\n-        // (__current, __current + (__submatch.second - __submatch.first))\n-        // If matched, keep going; else just return to try another state.\n-        case _S_opcode_backref:\n-          {\n-            auto& __submatch = __results[__state._M_backref_index];\n-            if (!__submatch.matched)\n-              break;\n-            auto __last = __current;\n-            for (auto __tmp = __submatch.first;\n-                 __last != __end && __tmp != __submatch.second;\n-                 ++__tmp)\n-              ++__last;\n-            if (_M_traits.transform(__submatch.first, __submatch.second)\n-                == _M_traits.transform(__current, __last))\n-              if (__last != __current)\n-                {\n-                  auto __backup = __current;\n-                  __current = __last;\n-                  __ret = _M_dfs<__match_mode>(__state._M_next);\n-                  __current = __backup;\n-                }\n-              else\n-                __ret = _M_dfs<__match_mode>(__state._M_next);\n-          }\n-          break;\n-        case _S_opcode_accept:\n-          if (__match_mode)\n-            __ret = __current == __end;\n-          else\n-            __ret = true;\n-          if (__ret)\n-            this->_M_results = __results;\n-          break;\n-        default:\n-          _GLIBCXX_DEBUG_ASSERT(false);\n-        }\n+\t{\n+\tcase _S_opcode_alternative:\n+\t  // Greedy mode by default. For non-greedy mode,\n+\t  // swap _M_alt and _M_next.\n+\t  // TODO: Add greedy mode option.\n+\t  __ret = _M_dfs<__match_mode>(__state._M_alt)\n+\t    || _M_dfs<__match_mode>(__state._M_next);\n+\t  break;\n+\tcase _S_opcode_subexpr_begin:\n+\t  // Here's the critical part: if there's nothing changed since last\n+\t  // visit, do NOT continue. This prevents the executor from get into\n+\t  // infinite loop when use \"()*\" to match \"\".\n+\t  //\n+\t  // Every change on __results will be roll back after the recursion\n+\t  // step finished.\n+\t  if (!__results[__state._M_subexpr].matched\n+\t      || __results[__state._M_subexpr].first != __current)\n+\t    {\n+\t      auto __back = __current;\n+\t      __results[__state._M_subexpr].first = __current;\n+\t      __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t      __results[__state._M_subexpr].first = __back;\n+\t    }\n+\t  break;\n+\tcase _S_opcode_subexpr_end:\n+\t  if (__results[__state._M_subexpr].second != __current\n+\t      || __results[__state._M_subexpr].matched != true)\n+\t    {\n+\t      auto __back = __results[__state._M_subexpr];\n+\t      __results[__state._M_subexpr].second = __current;\n+\t      __results[__state._M_subexpr].matched = true;\n+\t      __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t      __results[__state._M_subexpr] = __back;\n+\t    }\n+\t  else\n+\t    __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t  break;\n+\tcase _S_opcode_match:\n+\t  if (__current != __end && __state._M_matches(*__current))\n+\t    {\n+\t      ++__current;\n+\t      __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t      --__current;\n+\t    }\n+\t  break;\n+\t// First fetch the matched result from __results as __submatch;\n+\t// then compare it with\n+\t// (__current, __current + (__submatch.second - __submatch.first))\n+\t// If matched, keep going; else just return to try another state.\n+\tcase _S_opcode_backref:\n+\t  {\n+\t    auto& __submatch = __results[__state._M_backref_index];\n+\t    if (!__submatch.matched)\n+\t      break;\n+\t    auto __last = __current;\n+\t    for (auto __tmp = __submatch.first;\n+\t\t __last != __end && __tmp != __submatch.second;\n+\t\t ++__tmp)\n+\t      ++__last;\n+\t    if (_M_traits.transform(__submatch.first, __submatch.second)\n+\t\t== _M_traits.transform(__current, __last))\n+\t      if (__last != __current)\n+\t\t{\n+\t\t  auto __backup = __current;\n+\t\t  __current = __last;\n+\t\t  __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t\t  __current = __backup;\n+\t\t}\n+\t      else\n+\t\t__ret = _M_dfs<__match_mode>(__state._M_next);\n+\t  }\n+\t  break;\n+\tcase _S_opcode_accept:\n+\t  if (__match_mode)\n+\t    __ret = __current == __end;\n+\t  else\n+\t    __ret = true;\n+\t  if (__ret)\n+\t    this->_M_results = __results;\n+\t  break;\n+\tdefault:\n+\t  _GLIBCXX_DEBUG_ASSERT(false);\n+\t}\n       return __ret;\n     }\n \n@@ -142,14 +142,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_main_loop()\n     {\n       while (this->_M_current != this->_M_end)\n-        {\n-          if (!__match_mode)\n-            if (_M_includes_some())\n-              return;\n-          _M_move();\n-          ++this->_M_current;\n-          _M_e_closure();\n-        }\n+\t{\n+\t  if (!__match_mode)\n+\t    if (_M_includes_some())\n+\t      return;\n+\t  _M_move();\n+\t  ++this->_M_current;\n+\t  _M_e_closure();\n+\t}\n       _M_includes_some();\n     }\n \n@@ -162,73 +162,73 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::queue<_StateIdT> __q;\n       std::vector<bool> __in_q(_M_nfa.size(), false);\n       for (auto& __it : _M_covered)\n-        {\n-          __in_q[__it.first] = true;\n-          __q.push(__it.first);\n-        }\n+\t{\n+\t  __in_q[__it.first] = true;\n+\t  __q.push(__it.first);\n+\t}\n       while (!__q.empty())\n-        {\n-          auto __u = __q.front();\n-          __q.pop();\n-          __in_q[__u] = false;\n-          const auto& __state = _M_nfa[__u];\n+\t{\n+\t  auto __u = __q.front();\n+\t  __q.pop();\n+\t  __in_q[__u] = false;\n+\t  const auto& __state = _M_nfa[__u];\n \n-          // Can be implemented using method, but there're too much arguments.\n-          // I would use macro function before C++11, but lambda is a better\n-          // choice, since hopefully compiler can inline it.\n-          auto __add_visited_state = [&](_StateIdT __v)\n-          {\n-            if (__v == _S_invalid_state_id)\n-              return;\n-            if (_M_covered.count(__u) != 0\n-                && (_M_covered.count(__v) == 0\n-                    || _M_match_less_than(*_M_covered[__u], *_M_covered[__v])))\n-              {\n-                _M_covered[__v] = _ResultsPtr(new _ResultsVec(*_M_covered[__u]));\n-                // if a state is updated, it's outgoing neighbors should be\n-                // reconsidered too. Push them to the queue.\n-                if (!__in_q[__v])\n-                  {\n-                    __in_q[__v] = true;\n-                    __q.push(__v);\n-                  }\n-              }\n-          };\n+\t  // Can be implemented using method, but there're too much arguments.\n+\t  // I would use macro function before C++11, but lambda is a better\n+\t  // choice, since hopefully compiler can inline it.\n+\t  auto __add_visited_state = [&](_StateIdT __v)\n+\t  {\n+\t    if (__v == _S_invalid_state_id)\n+\t      return;\n+\t    if (_M_covered.count(__u) != 0\n+\t\t&& (_M_covered.count(__v) == 0\n+\t\t    || _M_match_less_than(*_M_covered[__u], *_M_covered[__v])))\n+\t      {\n+\t\t_M_covered[__v] = _ResultsPtr(new _ResultsVec(*_M_covered[__u]));\n+\t\t// if a state is updated, it's outgoing neighbors should be\n+\t\t// reconsidered too. Push them to the queue.\n+\t\tif (!__in_q[__v])\n+\t\t  {\n+\t\t    __in_q[__v] = true;\n+\t\t    __q.push(__v);\n+\t\t  }\n+\t      }\n+\t  };\n \n-          switch (__state._M_opcode)\n-            {\n-              case _S_opcode_alternative:\n-                __add_visited_state(__state._M_next);\n-                __add_visited_state(__state._M_alt);\n-                break;\n-              case _S_opcode_subexpr_begin:\n-                {\n-                  auto& __cu = *_M_covered[__u];\n-                  auto __back = __cu[__state._M_subexpr].first;\n-                  __cu[__state._M_subexpr].first = __current;\n-                  __add_visited_state(__state._M_next);\n-                  __cu[__state._M_subexpr].first = __back;\n-                }\n-                break;\n-              case _S_opcode_subexpr_end:\n-                {\n-                  auto& __cu = *_M_covered[__u];\n-                  auto __back = __cu[__state._M_subexpr];\n-                  __cu[__state._M_subexpr].second = __current;\n-                  __cu[__state._M_subexpr].matched = true;\n-                  __add_visited_state(__state._M_next);\n-                  __cu[__state._M_subexpr] = __back;\n-                }\n-                break;\n-              case _S_opcode_match:\n-                break;\n-              case _S_opcode_accept:\n-                __add_visited_state(__state._M_next);\n-                break;\n-              default:\n-                _GLIBCXX_DEBUG_ASSERT(false);\n-            }\n-        }\n+\t  switch (__state._M_opcode)\n+\t    {\n+\t      case _S_opcode_alternative:\n+\t\t__add_visited_state(__state._M_next);\n+\t\t__add_visited_state(__state._M_alt);\n+\t\tbreak;\n+\t      case _S_opcode_subexpr_begin:\n+\t\t{\n+\t\t  auto& __cu = *_M_covered[__u];\n+\t\t  auto __back = __cu[__state._M_subexpr].first;\n+\t\t  __cu[__state._M_subexpr].first = __current;\n+\t\t  __add_visited_state(__state._M_next);\n+\t\t  __cu[__state._M_subexpr].first = __back;\n+\t\t}\n+\t\tbreak;\n+\t      case _S_opcode_subexpr_end:\n+\t\t{\n+\t\t  auto& __cu = *_M_covered[__u];\n+\t\t  auto __back = __cu[__state._M_subexpr];\n+\t\t  __cu[__state._M_subexpr].second = __current;\n+\t\t  __cu[__state._M_subexpr].matched = true;\n+\t\t  __add_visited_state(__state._M_next);\n+\t\t  __cu[__state._M_subexpr] = __back;\n+\t\t}\n+\t\tbreak;\n+\t      case _S_opcode_match:\n+\t\tbreak;\n+\t      case _S_opcode_accept:\n+\t\t__add_visited_state(__state._M_next);\n+\t\tbreak;\n+\t      default:\n+\t\t_GLIBCXX_DEBUG_ASSERT(false);\n+\t    }\n+\t}\n     }\n \n   template<typename _BiIter, typename _Alloc,\n@@ -238,15 +238,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       decltype(_M_covered) __next;\n       for (auto& __it : _M_covered)\n-        {\n-          const auto& __state = _M_nfa[__it.first];\n-          if (__state._M_opcode == _S_opcode_match\n-              && __state._M_matches(*this->_M_current))\n-            if (__state._M_next != _S_invalid_state_id)\n-              if (__next.count(__state._M_next) == 0\n-                  || _M_match_less_than(*__it.second, *__next[__state._M_next]))\n-                __next[__state._M_next] = move(__it.second);\n-        }\n+\t{\n+\t  const auto& __state = _M_nfa[__it.first];\n+\t  if (__state._M_opcode == _S_opcode_match\n+\t      && __state._M_matches(*this->_M_current))\n+\t    if (__state._M_next != _S_invalid_state_id)\n+\t      if (__next.count(__state._M_next) == 0\n+\t\t  || _M_match_less_than(*__it.second, *__next[__state._M_next]))\n+\t\t__next[__state._M_next] = move(__it.second);\n+\t}\n       _M_covered = move(__next);\n     }\n \n@@ -259,21 +259,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _GLIBCXX_DEBUG_ASSERT(__u.size() == __v.size());\n       auto __size = __u.size();\n       for (auto __i = 0; __i < __size; __i++)\n-        {\n-          auto& __uit = __u[__i], __vit = __v[__i];\n-          if (__uit.matched && !__vit.matched)\n-            return true;\n-          if (!__uit.matched && __vit.matched)\n-            return false;\n-          if (__uit.matched && __vit.matched)\n-            {\n-              // GREEDY\n-              if (__uit.first != __vit.first)\n-                return __uit.first < __vit.first;\n-              if (__uit.second != __vit.second)\n-                return __uit.second > __vit.second;\n-            }\n-        }\n+\t{\n+\t  auto& __uit = __u[__i], __vit = __v[__i];\n+\t  if (__uit.matched && !__vit.matched)\n+\t    return true;\n+\t  if (!__uit.matched && __vit.matched)\n+\t    return false;\n+\t  if (__uit.matched && __vit.matched)\n+\t    {\n+\t      // GREEDY\n+\t      if (__uit.first != __vit.first)\n+\t\treturn __uit.first < __vit.first;\n+\t      if (__uit.second != __vit.second)\n+\t\treturn __uit.second > __vit.second;\n+\t    }\n+\t}\n       return false;\n     }\n \n@@ -285,42 +285,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       auto& __s = _M_nfa._M_final_states();\n       auto& __t = _M_covered;\n       if (__s.size() > 0 && __t.size() > 0)\n-        {\n-          auto __first = __s.begin();\n-          auto __second = __t.begin();\n-          while (__first != __s.end() && __second != __t.end())\n-            {\n-              if (*__first < __second->first)\n-                ++__first;\n-              else if (__second->first < *__first)\n-                ++__second;\n-              else\n-                {\n-                  this->_M_results = *__second->second;\n-                  return true;\n-                }\n-            }\n-        }\n+\t{\n+\t  auto __first = __s.begin();\n+\t  auto __second = __t.begin();\n+\t  while (__first != __s.end() && __second != __t.end())\n+\t    {\n+\t      if (*__first < __second->first)\n+\t\t++__first;\n+\t      else if (__second->first < *__first)\n+\t\t++__second;\n+\t      else\n+\t\t{\n+\t\t  this->_M_results = *__second->second;\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t}\n       return false;\n     }\n \n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n     std::unique_ptr<_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n     __get_executor(_BiIter __b,\n-                   _BiIter __e,\n-                   match_results<_BiIter, _Alloc>& __m,\n-                   const basic_regex<_CharT, _TraitsT>& __re,\n-                   regex_constants::match_flag_type __flags)\n+\t\t   _BiIter __e,\n+\t\t   match_results<_BiIter, _Alloc>& __m,\n+\t\t   const basic_regex<_CharT, _TraitsT>& __re,\n+\t\t   regex_constants::match_flag_type __flags)\n     {\n       typedef std::unique_ptr<_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n-        _ExecutorPtr;\n+\t_ExecutorPtr;\n       typedef _DFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT> _DFSExecutorT;\n       typedef _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT> _BFSExecutorT;\n       auto __p = std::static_pointer_cast<_NFA<_CharT, _TraitsT>>\n-        (__re._M_automaton);\n+\t(__re._M_automaton);\n       if (__p->_M_has_backref)\n-        return _ExecutorPtr(new _DFSExecutorT(__b, __e, __m, *__p, __flags));\n+\treturn _ExecutorPtr(new _DFSExecutorT(__b, __e, __m, *__p, __flags));\n       return _ExecutorPtr(new _BFSExecutorT(__b, __e, __m, *__p, __flags));\n     }\n "}]}