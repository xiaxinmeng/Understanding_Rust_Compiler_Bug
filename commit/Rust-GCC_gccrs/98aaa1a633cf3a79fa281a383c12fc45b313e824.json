{"sha": "98aaa1a633cf3a79fa281a383c12fc45b313e824", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThhYWExYTYzM2NmM2E3OWZhMjgxYTM4M2MxMmZjNDViMzEzZTgyNA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2019-05-14T01:18:53Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2019-05-14T01:18:53Z"}, "message": "gimple-ssa-strength-reduction.c (lookup_cand): Adjust index by 1.\n\n\t* gimple-ssa-strength-reduction.c (lookup_cand): Adjust index by 1.\n\t(alloc_cand_and_find_basis): Ditto.\n\t(backtrace_base_for_ref, create_mul_ssa_cand): Remove if-then-else.\n\t(create_mul_imm_cand, create_add_ssa_cand): Ditto.\n\t(create_add_imm_cand, slsr_process_cast): Ditto.\n\t(slsr_process_copy, replace_mult_candidate): Ditto.\n\t(replace_rhs_if_not_dup, replace_one_candidate): Ditto.\n\t(dump_cand_vec, analyze_candidates_and_replace): Skip NULL element.\n\t(pass_strength_reduction::execute): Init the first NULL element.\n\nFrom-SVN: r271145", "tree": {"sha": "86f2df0811fde35ba8b048e92db3574db9808f01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86f2df0811fde35ba8b048e92db3574db9808f01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98aaa1a633cf3a79fa281a383c12fc45b313e824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98aaa1a633cf3a79fa281a383c12fc45b313e824", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98aaa1a633cf3a79fa281a383c12fc45b313e824", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98aaa1a633cf3a79fa281a383c12fc45b313e824/comments", "author": null, "committer": null, "parents": [{"sha": "5900c71041337f4495f6490f433175980244c3ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5900c71041337f4495f6490f433175980244c3ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5900c71041337f4495f6490f433175980244c3ad"}], "stats": {"total": 87, "additions": 38, "deletions": 49}, "files": [{"sha": "0985651503a3ca8a1982de78280d31830d4d36f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98aaa1a633cf3a79fa281a383c12fc45b313e824/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98aaa1a633cf3a79fa281a383c12fc45b313e824/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98aaa1a633cf3a79fa281a383c12fc45b313e824", "patch": "@@ -1,3 +1,15 @@\n+2019-05-14  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\t* gimple-ssa-strength-reduction.c (lookup_cand): Adjust index by 1.\n+\t(alloc_cand_and_find_basis): Ditto.\n+\t(backtrace_base_for_ref, create_mul_ssa_cand): Remove if-then-else.\n+\t(create_mul_imm_cand, create_add_ssa_cand): Ditto.\n+\t(create_add_imm_cand, slsr_process_cast): Ditto.\n+\t(slsr_process_copy, replace_mult_candidate): Ditto.\n+\t(replace_rhs_if_not_dup, replace_one_candidate): Ditto.\n+\t(dump_cand_vec, analyze_candidates_and_replace): Skip NULL element.\n+\t(pass_strength_reduction::execute): Init the first NULL element.\n+\n 2019-05-13  Nathan Sidwell  <nathan@acm.org>\n \n \t* gcc.c (execute): Simplify cond-expr into if.  Reformat comment."}, {"sha": "bfda44a102881f51a473ddd0177bac8de96c74af", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 26, "deletions": 49, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98aaa1a633cf3a79fa281a383c12fc45b313e824/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98aaa1a633cf3a79fa281a383c12fc45b313e824/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=98aaa1a633cf3a79fa281a383c12fc45b313e824", "patch": "@@ -418,7 +418,7 @@ static bool legal_cast_p_1 (tree, tree);\n static slsr_cand_t\n lookup_cand (cand_idx idx)\n {\n-  return cand_vec[idx - 1];\n+  return cand_vec[idx];\n }\n \n /* Helper for hashing a candidate chain header.  */\n@@ -688,7 +688,7 @@ alloc_cand_and_find_basis (enum cand_kind kind, gimple *gs, tree base,\n   c->cand_type = ctype;\n   c->stride_type = stype;\n   c->kind = kind;\n-  c->cand_num = cand_vec.length () + 1;\n+  c->cand_num = cand_vec.length ();\n   c->next_interp = 0;\n   c->first_interp = c->cand_num;\n   c->dependent = 0;\n@@ -933,10 +933,7 @@ backtrace_base_for_ref (tree *pbase)\n \t  return base_cand->index;\n \t}\n \n-      if (base_cand->next_interp)\n-\tbase_cand = lookup_cand (base_cand->next_interp);\n-      else\n-\tbase_cand = NULL;\n+      base_cand = lookup_cand (base_cand->next_interp);\n     }\n \n   return 0;\n@@ -1124,10 +1121,7 @@ create_mul_ssa_cand (gimple *gs, tree base_in, tree stride_in, bool speed)\n \t\t       + stmt_cost (base_cand->cand_stmt, speed));\n \t}\n \n-      if (base_cand->next_interp)\n-\tbase_cand = lookup_cand (base_cand->next_interp);\n-      else\n-\tbase_cand = NULL;\n+      base_cand = lookup_cand (base_cand->next_interp);\n     }\n \n   if (!base)\n@@ -1214,10 +1208,7 @@ create_mul_imm_cand (gimple *gs, tree base_in, tree stride_in, bool speed)\n \t\t       + stmt_cost (base_cand->cand_stmt, speed));\n \t}\n \n-      if (base_cand->next_interp)\n-\tbase_cand = lookup_cand (base_cand->next_interp);\n-      else\n-\tbase_cand = NULL;\n+      base_cand = lookup_cand (base_cand->next_interp);\n     }\n \n   if (!base)\n@@ -1320,10 +1311,7 @@ create_add_ssa_cand (gimple *gs, tree base_in, tree addend_in,\n \t\t       + stmt_cost (addend_cand->cand_stmt, speed));\n \t}\n \n-      if (addend_cand->next_interp)\n-\taddend_cand = lookup_cand (addend_cand->next_interp);\n-      else\n-\taddend_cand = NULL;\n+      addend_cand = lookup_cand (addend_cand->next_interp);\n     }\n \n   while (base_cand && !base && base_cand->kind != CAND_PHI)\n@@ -1371,18 +1359,12 @@ create_add_ssa_cand (gimple *gs, tree base_in, tree addend_in,\n \t\t    savings = (subtrahend_cand->dead_savings \n \t\t\t       + stmt_cost (subtrahend_cand->cand_stmt, speed));\n \t\t}\n-\t      \n-\t      if (subtrahend_cand->next_interp)\n-\t\tsubtrahend_cand = lookup_cand (subtrahend_cand->next_interp);\n-\t      else\n-\t\tsubtrahend_cand = NULL;\n+\n+\t      subtrahend_cand = lookup_cand (subtrahend_cand->next_interp);\n \t    }\n \t}\n       \n-      if (base_cand->next_interp)\n-\tbase_cand = lookup_cand (base_cand->next_interp);\n-      else\n-\tbase_cand = NULL;\n+      base_cand = lookup_cand (base_cand->next_interp);\n     }\n \n   if (!base)\n@@ -1446,10 +1428,7 @@ create_add_imm_cand (gimple *gs, tree base_in, const widest_int &index_in,\n \t\t       + stmt_cost (base_cand->cand_stmt, speed));\n \t}\n \n-      if (base_cand->next_interp)\n-\tbase_cand = lookup_cand (base_cand->next_interp);\n-      else\n-\tbase_cand = NULL;\n+      base_cand = lookup_cand (base_cand->next_interp);\n     }\n \n   if (!base)\n@@ -1652,10 +1631,7 @@ slsr_process_cast (gimple *gs, tree rhs1, bool speed)\n \t  if (first_cand != c)\n \t    c->first_interp = first_cand->cand_num;\n \n-\t  if (base_cand->next_interp)\n-\t    base_cand = lookup_cand (base_cand->next_interp);\n-\t  else\n-\t    base_cand = NULL;\n+\t  base_cand = lookup_cand (base_cand->next_interp);\n \t}\n     }\n   else \n@@ -1719,10 +1695,7 @@ slsr_process_copy (gimple *gs, tree rhs1, bool speed)\n \t  if (first_cand != c)\n \t    c->first_interp = first_cand->cand_num;\n \n-\t  if (base_cand->next_interp)\n-\t    base_cand = lookup_cand (base_cand->next_interp);\n-\t  else\n-\t    base_cand = NULL;\n+\t  base_cand = lookup_cand (base_cand->next_interp);\n \t}\n     }\n   else \n@@ -1933,7 +1906,8 @@ dump_cand_vec (void)\n   fprintf (dump_file, \"\\nStrength reduction candidate vector:\\n\\n\");\n   \n   FOR_EACH_VEC_ELT (cand_vec, i, c)\n-    dump_candidate (c);\n+    if (c != NULL)\n+      dump_candidate (c);\n }\n \n /* Callback used to dump the candidate chains hash table.  */\n@@ -2181,7 +2155,7 @@ replace_mult_candidate (slsr_cand_t c, tree basis_name, widest_int bump)\n       while (cc)\n \t{\n \t  cc->cand_stmt = copy_stmt;\n-\t  cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n+\t  cc = lookup_cand (cc->next_interp);\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tstmt_to_print = copy_stmt;\n@@ -2214,7 +2188,7 @@ replace_mult_candidate (slsr_cand_t c, tree basis_name, widest_int bump)\n \t  while (cc)\n \t    {\n \t      cc->cand_stmt = gsi_stmt (gsi);\n-\t      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n+\t      cc = lookup_cand (cc->next_interp);\n \t    }\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    stmt_to_print = gsi_stmt (gsi);\n@@ -3654,7 +3628,7 @@ replace_rhs_if_not_dup (enum tree_code new_code, tree new_rhs1, tree new_rhs2,\n       while (cc)\n \t{\n \t  cc->cand_stmt = gsi_stmt (gsi);\n-\t  cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n+\t  cc = lookup_cand (cc->next_interp);\n \t}\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3770,7 +3744,7 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)\n \t  while (cc)\n \t    {\n \t      cc->cand_stmt = gsi_stmt (gsi);\n-\t      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n+\t      cc = lookup_cand (cc->next_interp);\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3796,7 +3770,7 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)\n \t  while (cc)\n \t    {\n \t      cc->cand_stmt = copy_stmt;\n-\t      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n+\t      cc = lookup_cand (cc->next_interp);\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3812,7 +3786,7 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)\n \t  while (cc)\n \t    {\n \t      cc->cand_stmt = cast_stmt;\n-\t      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;\n+\t      cc = lookup_cand (cc->next_interp);\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3902,8 +3876,10 @@ analyze_candidates_and_replace (void)\n   /* Each candidate that has a null basis and a non-null\n      dependent is the root of a tree of related statements.\n      Analyze each tree to determine a subset of those\n-     statements that can be replaced with maximum benefit.  */\n-  FOR_EACH_VEC_ELT (cand_vec, i, c)\n+     statements that can be replaced with maximum benefit.\n+\n+     Note the first NULL element is skipped.  */\n+  FOR_EACH_VEC_ELT_FROM (cand_vec, i, c, 1)\n     {\n       slsr_cand_t first_dep;\n \n@@ -4010,8 +3986,9 @@ pass_strength_reduction::execute (function *fun)\n   /* Create the obstack where candidates will reside.  */\n   gcc_obstack_init (&cand_obstack);\n \n-  /* Allocate the candidate vector.  */\n+  /* Allocate the candidate vector and initialize the first NULL element.  */\n   cand_vec.create (128);\n+  cand_vec.safe_push (NULL);\n \n   /* Allocate the mapping from statements to candidate indices.  */\n   stmt_cand_map = new hash_map<gimple *, slsr_cand_t>;"}]}