{"sha": "45d78e7f76382d08aeec6c4237e149d2d364ed1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVkNzhlN2Y3NjM4MmQwOGFlZWM2YzQyMzdlMTQ5ZDJkMzY0ZWQxYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2004-08-10T13:28:26Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2004-08-10T13:28:26Z"}, "message": "re PR libgcj/3144 (java.lang.Date.compareTo() not supported)\n\n\tPR target/3144\n\t* expr.c (move_by_pieces_ninsns): Add max_size argument.\n\t(MOVE_BY_PIECES_P): Pass MOVE_MAX_PIECES + 1 to it.\n\t(CLEAR_BY_PIECES_P): Pass STORE_MAX_PIECES + 1 to it.\n\t(STORE_BY_PIECES_P): Define similarly to CLEAR_BY_PIECES_P,\n\tbut using MOVE_RATIO.\n\t(move_by_pieces): Pass max_size to move_by_pieces_ninsns.\n\t(can_store_by_pieces): Change max_size type to unsigned int.\n\t(store_by_pieces_1): Likewise.  Pass max_size to\n\tmove_by_pieces_ninsns.\n\t* config/s390/s390.h (STORE_BY_PIECES_P): Define.\n\t* config/sh/sh.c (MOVE_BY_PIECES_P): Pass MOVE_MAX_PIECES + 1\n\tto move_by_pieces_ninsns.\n\t(STORE_BY_PIECES_P): Define.\n\t* config/ns32k/ns32k.h (STORE_BY_PIECES_P): Pass STORE_MAX_PIECES + 1\n\tto move_by_pieces_ninsns.\n\t* doc/tm.texi (STORE_BY_PIECES_P): Document changed default.\n\n\t* config/i386/i386.h (CLEAR_RATIO): Define.\n\nFrom-SVN: r85750", "tree": {"sha": "9647ac9edda8c048aa7fbe29d2b9727b756bb40d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9647ac9edda8c048aa7fbe29d2b9727b756bb40d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45d78e7f76382d08aeec6c4237e149d2d364ed1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d78e7f76382d08aeec6c4237e149d2d364ed1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d78e7f76382d08aeec6c4237e149d2d364ed1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d78e7f76382d08aeec6c4237e149d2d364ed1c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "25f3e06c7c272acfe17d2502a03330dcf5447b97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25f3e06c7c272acfe17d2502a03330dcf5447b97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25f3e06c7c272acfe17d2502a03330dcf5447b97"}], "stats": {"total": 74, "additions": 59, "deletions": 15}, "files": [{"sha": "2523fc55f112b4401ca02f6d6858bfef5b2e7232", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45d78e7f76382d08aeec6c4237e149d2d364ed1c", "patch": "@@ -1,3 +1,25 @@\n+2004-08-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/3144\n+\t* expr.c (move_by_pieces_ninsns): Add max_size argument.\n+\t(MOVE_BY_PIECES_P): Pass MOVE_MAX_PIECES + 1 to it.\n+\t(CLEAR_BY_PIECES_P): Pass STORE_MAX_PIECES + 1 to it.\n+\t(STORE_BY_PIECES_P): Define similarly to CLEAR_BY_PIECES_P,\n+\tbut using MOVE_RATIO.\n+\t(move_by_pieces): Pass max_size to move_by_pieces_ninsns.\n+\t(can_store_by_pieces): Change max_size type to unsigned int.\n+\t(store_by_pieces_1): Likewise.  Pass max_size to\n+\tmove_by_pieces_ninsns.\n+\t* config/s390/s390.h (STORE_BY_PIECES_P): Define.\n+\t* config/sh/sh.c (MOVE_BY_PIECES_P): Pass MOVE_MAX_PIECES + 1\n+\tto move_by_pieces_ninsns.\n+\t(STORE_BY_PIECES_P): Define.\n+\t* config/ns32k/ns32k.h (STORE_BY_PIECES_P): Pass STORE_MAX_PIECES + 1\n+\tto move_by_pieces_ninsns.\n+\t* doc/tm.texi (STORE_BY_PIECES_P): Document changed default.\n+\n+\t* config/i386/i386.h (CLEAR_RATIO): Define.\n+\n 2004-08-09  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* expr.c (expand_expr_real_1): Add back code that was not dead."}, {"sha": "588b669825eabe9a5787c4fc55e76ad1dc0cf609", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=45d78e7f76382d08aeec6c4237e149d2d364ed1c", "patch": "@@ -2518,6 +2518,12 @@ enum ix86_builtins\n \n #define MOVE_RATIO (optimize_size ? 3 : ix86_cost->move_ratio)\n \n+/* If a clear memory operation would take CLEAR_RATIO or more simple\n+   move-instruction sequences, we will do a clrmem or libcall instead.  */\n+\n+#define CLEAR_RATIO (optimize_size ? 2 \\\n+\t\t     : ix86_cost->move_ratio > 6 ? 6 : ix86_cost->move_ratio)\n+\n /* Define if shifts truncate the shift count\n    which implies one can omit a sign-extension or zero-extension\n    of a shift count.  */"}, {"sha": "a5819f4947873c802c2caef351058e114f679b74", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=45d78e7f76382d08aeec6c4237e149d2d364ed1c", "patch": "@@ -1109,8 +1109,8 @@ __transfer_from_trampoline ()\t\t\\\n \n #define STORE_RATIO (optimize_size ? 3 : 15)\n #define STORE_BY_PIECES_P(SIZE, ALIGN) \\\n-  (move_by_pieces_ninsns (SIZE, ALIGN) < (unsigned int) STORE_RATIO)\n-\n+  (move_by_pieces_ninsns (SIZE, ALIGN, STORE_MAX_PIECES + 1) \\\n+   < (unsigned int) STORE_RATIO)\n \n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n #define SLOW_BYTE_ACCESS 0"}, {"sha": "3d9180578a578281b8cefec480d4a64b89c84e60", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=45d78e7f76382d08aeec6c4237e149d2d364ed1c", "patch": "@@ -855,6 +855,11 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n   ( (SIZE) == 1 || (SIZE) == 2 || (SIZE) == 4\t\\\n     || (TARGET_64BIT && (SIZE) == 8) )\n \n+/* This macro is used to determine whether store_by_pieces should be\n+   called to \"memset\" storage with byte values other than zero, or\n+   to \"memcpy\" storage when the source is a constant string.  */\n+#define STORE_BY_PIECES_P(SIZE, ALIGN) MOVE_BY_PIECES_P (SIZE, ALIGN)\n+\n /* Don't perform CSE on function addresses.  */\n #define NO_FUNCTION_CSE\n "}, {"sha": "9519634c1f0ccdb40ffb740a45dc87abfcd5568d", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=45d78e7f76382d08aeec6c4237e149d2d364ed1c", "patch": "@@ -2368,9 +2368,13 @@ struct sh_args {\n #define USE_STORE_PRE_DECREMENT(mode)    ((mode == SImode || mode == DImode) \\\n                                            ? 0 : TARGET_SH1)\n \n-#define MOVE_BY_PIECES_P(SIZE, ALIGN)  (move_by_pieces_ninsns (SIZE, ALIGN) \\\n-                                        < (TARGET_SMALLCODE ? 2 :           \\\n-                                           ((ALIGN >= 32) ? 16 : 2)))\n+#define MOVE_BY_PIECES_P(SIZE, ALIGN) \\\n+  (move_by_pieces_ninsns (SIZE, ALIGN, MOVE_MAX_PIECES + 1) \\\n+   < (TARGET_SMALLCODE ? 2 : ((ALIGN >= 32) ? 16 : 2)))\n+\n+#define STORE_BY_PIECES_P(SIZE, ALIGN) \\\n+  (move_by_pieces_ninsns (SIZE, ALIGN, STORE_MAX_PIECES + 1) \\\n+   < (TARGET_SMALLCODE ? 2 : ((ALIGN >= 32) ? 16 : 2)))\n \n /* Macros to check register numbers against specific register classes.  */\n "}, {"sha": "5192bd6e0aaede9e3f3c9b1d9969fdcede270882", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=45d78e7f76382d08aeec6c4237e149d2d364ed1c", "patch": "@@ -5399,7 +5399,8 @@ used to set a chunk of memory to a constant value, or whether some other\n mechanism will be used.  Used by @code{__builtin_memset} when storing\n values other than constant zero and by @code{__builtin_strcpy} when\n when called with a constant source string.\n-Defaults to @code{MOVE_BY_PIECES_P}.\n+Defaults to to 1 if @code{move_by_pieces_ninsns} returns less\n+than @code{MOVE_RATIO}.\n @end defmac\n \n @defmac USE_LOAD_POST_INCREMENT (@var{mode})"}, {"sha": "7741830033ec740cacdf5024302b62e19a222aaa", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d78e7f76382d08aeec6c4237e149d2d364ed1c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=45d78e7f76382d08aeec6c4237e149d2d364ed1c", "patch": "@@ -120,6 +120,7 @@ struct store_by_pieces\n };\n \n static unsigned HOST_WIDE_INT move_by_pieces_ninsns (unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t     unsigned int,\n \t\t\t\t\t\t     unsigned int);\n static void move_by_pieces_1 (rtx (*) (rtx, ...), enum machine_mode,\n \t\t\t      struct move_by_pieces *);\n@@ -174,21 +175,25 @@ static bool float_extend_from_mem[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n    to perform a structure copy.  */\n #ifndef MOVE_BY_PIECES_P\n #define MOVE_BY_PIECES_P(SIZE, ALIGN) \\\n-  (move_by_pieces_ninsns (SIZE, ALIGN) < (unsigned int) MOVE_RATIO)\n+  (move_by_pieces_ninsns (SIZE, ALIGN, MOVE_MAX_PIECES + 1) \\\n+   < (unsigned int) MOVE_RATIO)\n #endif\n \n /* This macro is used to determine whether clear_by_pieces should be\n    called to clear storage.  */\n #ifndef CLEAR_BY_PIECES_P\n #define CLEAR_BY_PIECES_P(SIZE, ALIGN) \\\n-  (move_by_pieces_ninsns (SIZE, ALIGN) < (unsigned int) CLEAR_RATIO)\n+  (move_by_pieces_ninsns (SIZE, ALIGN, STORE_MAX_PIECES + 1) \\\n+   < (unsigned int) CLEAR_RATIO)\n #endif\n \n /* This macro is used to determine whether store_by_pieces should be\n    called to \"memset\" storage with byte values other than zero, or\n    to \"memcpy\" storage when the source is a constant string.  */\n #ifndef STORE_BY_PIECES_P\n-#define STORE_BY_PIECES_P(SIZE, ALIGN)\tMOVE_BY_PIECES_P (SIZE, ALIGN)\n+#define STORE_BY_PIECES_P(SIZE, ALIGN) \\\n+  (move_by_pieces_ninsns (SIZE, ALIGN, STORE_MAX_PIECES + 1) \\\n+   < (unsigned int) MOVE_RATIO)\n #endif\n \n /* This array records the insn_code of insns to perform block moves.  */\n@@ -882,7 +887,7 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n      copy addresses to registers (to make displacements shorter)\n      and use post-increment if available.  */\n   if (!(data.autinc_from && data.autinc_to)\n-      && move_by_pieces_ninsns (len, align) > 2)\n+      && move_by_pieces_ninsns (len, align, max_size) > 2)\n     {\n       /* Find the mode of the largest move...  */\n       for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n@@ -983,10 +988,10 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n    ALIGN (in bits) is maximum alignment we can assume.  */\n \n static unsigned HOST_WIDE_INT\n-move_by_pieces_ninsns (unsigned HOST_WIDE_INT l, unsigned int align)\n+move_by_pieces_ninsns (unsigned HOST_WIDE_INT l, unsigned int align,\n+\t\t       unsigned int max_size)\n {\n   unsigned HOST_WIDE_INT n_insns = 0;\n-  unsigned HOST_WIDE_INT max_size = MOVE_MAX + 1;\n \n   if (! SLOW_UNALIGNED_ACCESS (word_mode, align)\n       || align > MOVE_MAX * BITS_PER_UNIT || align >= BIGGEST_ALIGNMENT)\n@@ -1980,7 +1985,8 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n \t\t     rtx (*constfun) (void *, HOST_WIDE_INT, enum machine_mode),\n \t\t     void *constfundata, unsigned int align)\n {\n-  unsigned HOST_WIDE_INT max_size, l;\n+  unsigned HOST_WIDE_INT l;\n+  unsigned int max_size;\n   HOST_WIDE_INT offset = 0;\n   enum machine_mode mode, tmode;\n   enum insn_code icode;\n@@ -2148,7 +2154,7 @@ store_by_pieces_1 (struct store_by_pieces *data ATTRIBUTE_UNUSED,\n \t\t   unsigned int align ATTRIBUTE_UNUSED)\n {\n   rtx to_addr = XEXP (data->to, 0);\n-  unsigned HOST_WIDE_INT max_size = STORE_MAX_PIECES + 1;\n+  unsigned int max_size = STORE_MAX_PIECES + 1;\n   enum machine_mode mode = VOIDmode, tmode;\n   enum insn_code icode;\n \n@@ -2168,7 +2174,7 @@ store_by_pieces_1 (struct store_by_pieces *data ATTRIBUTE_UNUSED,\n      copy addresses to registers (to make displacements shorter)\n      and use post-increment if available.  */\n   if (!data->autinc_to\n-      && move_by_pieces_ninsns (data->len, align) > 2)\n+      && move_by_pieces_ninsns (data->len, align, max_size) > 2)\n     {\n       /* Determine the main mode we'll be using.  */\n       for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);"}]}