{"sha": "df2ef49bbf1d8e81db688fb49ddaf7e614b71961", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYyZWY0OWJiZjFkOGU4MWRiNjg4ZmI0OWRkYWY3ZTYxNGI3MTk2MQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2003-12-06T12:22:31Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2003-12-06T12:22:31Z"}, "message": "re PR rtl-optimization/13169 (asm using r30 or r31 confuses global_alloc)\n\n\tPR 13169\n\t* basic-block.h (PROP_ASM_SCAN): Define.\n\t* final.c (regs_asm_clobbered): New array.\n\t* regs.h (regs_asm_clobbered): Declare.\n\t* flow.c (life_analysis): Init it.\n\t(mark_set_regs): Set PROP_ASM_SCAN for asms.\n\t(mark_set_1): Set regs_asm_clobbered.\n\t* global.c (global_alloc): Don't set eliminable_regset when\n\tregs_asm_clobbered.\n\nFrom-SVN: r74363", "tree": {"sha": "806d63a055d1e8b44cd4e930d2d4c903a4cfaee2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/806d63a055d1e8b44cd4e930d2d4c903a4cfaee2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df2ef49bbf1d8e81db688fb49ddaf7e614b71961", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df2ef49bbf1d8e81db688fb49ddaf7e614b71961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df2ef49bbf1d8e81db688fb49ddaf7e614b71961", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/comments", "author": null, "committer": null, "parents": [{"sha": "929a3294725cb55f539bde39b50672cf24055c07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/929a3294725cb55f539bde39b50672cf24055c07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/929a3294725cb55f539bde39b50672cf24055c07"}], "stats": {"total": 106, "additions": 87, "deletions": 19}, "files": [{"sha": "0cf45b6c3ec91662582981d603e54340a9f37d8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df2ef49bbf1d8e81db688fb49ddaf7e614b71961", "patch": "@@ -1,3 +1,15 @@\n+2003-12-06  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR 13169\n+\t* basic-block.h (PROP_ASM_SCAN): Define.\n+\t* final.c (regs_asm_clobbered): New array.\n+\t* regs.h (regs_asm_clobbered): Declare.\n+\t* flow.c (life_analysis): Init it.\n+\t(mark_set_regs): Set PROP_ASM_SCAN for asms.\n+\t(mark_set_1): Set regs_asm_clobbered.\n+\t* global.c (global_alloc): Don't set eliminable_regset when\n+\tregs_asm_clobbered.\n+\n 2003-12-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* config/ia64/ia64.h (MUST_PASS_IN_STACK): Define."}, {"sha": "365711a541dc6abcd4705fdf87c0149743f7a425", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=df2ef49bbf1d8e81db688fb49ddaf7e614b71961", "patch": "@@ -477,6 +477,8 @@ enum update_life_extent\n #define PROP_AUTOINC\t\t64\t/* Create autoinc mem references.  */\n #define PROP_EQUAL_NOTES\t128\t/* Take into account REG_EQUAL notes.  */\n #define PROP_SCAN_DEAD_STORES\t256\t/* Scan for dead code.  */\n+#define PROP_ASM_SCAN\t\t512\t/* Internal flag used within flow.c\n+\t\t\t\t\t   to flag analysis of asms.  */\n #define PROP_FINAL\t\t(PROP_DEATH_NOTES | PROP_LOG_LINKS  \\\n \t\t\t\t | PROP_REG_INFO | PROP_KILL_DEAD_CODE  \\\n \t\t\t\t | PROP_SCAN_DEAD_CODE | PROP_AUTOINC \\"}, {"sha": "53c9359232c56bd93409b57096656abc0ef210cd", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=df2ef49bbf1d8e81db688fb49ddaf7e614b71961", "patch": "@@ -170,6 +170,12 @@ CC_STATUS cc_prev_status;\n \n char regs_ever_live[FIRST_PSEUDO_REGISTER];\n \n+/* Like regs_ever_live, but 1 if a reg is set or clobbered from an asm.\n+   Unlike regs_ever_live, elements of this array corresponding to\n+   eliminable regs like the frame pointer are set if an asm sets them.  */\n+\n+char regs_asm_clobbered[FIRST_PSEUDO_REGISTER];\n+\n /* Nonzero means current function must be given a frame pointer.\n    Initialized in function.c to 0.  Set only in reload1.c as per\n    the needs of the function.  */"}, {"sha": "952e7d9eb9252e4470f5836ab992086f3adaa53d", "filename": "gcc/flow.c", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=df2ef49bbf1d8e81db688fb49ddaf7e614b71961", "patch": "@@ -464,7 +464,10 @@ life_analysis (rtx f, FILE *file, int flags)\n      is not immediately handy.  */\n \n   if (flags & PROP_REG_INFO)\n-    memset (regs_ever_live, 0, sizeof (regs_ever_live));\n+    {\n+      memset (regs_ever_live, 0, sizeof (regs_ever_live));\n+      memset (regs_asm_clobbered, 0, sizeof (regs_asm_clobbered));\n+    }\n   update_life_info (NULL, UPDATE_LIFE_GLOBAL, flags);\n \n   /* Clean up.  */\n@@ -2445,6 +2448,7 @@ mark_set_regs (struct propagate_block_info *pbi, rtx x, rtx insn)\n   rtx cond = NULL_RTX;\n   rtx link;\n   enum rtx_code code;\n+  int flags = pbi->flags;\n \n   if (insn)\n     for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n@@ -2453,14 +2457,17 @@ mark_set_regs (struct propagate_block_info *pbi, rtx x, rtx insn)\n \t  mark_set_1 (pbi, SET, XEXP (link, 0),\n \t\t      (GET_CODE (x) == COND_EXEC\n \t\t       ? COND_EXEC_TEST (x) : NULL_RTX),\n-\t\t      insn, pbi->flags);\n+\t\t      insn, flags);\n       }\n  retry:\n   switch (code = GET_CODE (x))\n     {\n     case SET:\n+      if (GET_CODE (XEXP (x, 1)) == ASM_OPERANDS)\n+\tflags |= PROP_ASM_SCAN;\n+      /* Fall thru */\n     case CLOBBER:\n-      mark_set_1 (pbi, code, SET_DEST (x), cond, insn, pbi->flags);\n+      mark_set_1 (pbi, code, SET_DEST (x), cond, insn, flags);\n       return;\n \n     case COND_EXEC:\n@@ -2483,13 +2490,20 @@ mark_set_regs (struct propagate_block_info *pbi, rtx x, rtx insn)\n \n \t\tcond = COND_EXEC_TEST (sub);\n \t\tsub = COND_EXEC_CODE (sub);\n-\t\tif (GET_CODE (sub) != SET && GET_CODE (sub) != CLOBBER)\n-\t\t  break;\n-\t\t/* Fall through.  */\n+\t\tif (GET_CODE (sub) == SET)\n+\t\t  goto mark_set;\n+\t\tif (GET_CODE (sub) == CLOBBER)\n+\t\t  goto mark_clob;\n+\t\tbreak;\n \n \t      case SET:\n+\t      mark_set:\n+\t\tif (GET_CODE (XEXP (sub, 1)) == ASM_OPERANDS)\n+\t\t  flags |= PROP_ASM_SCAN;\n+\t\t/* Fall thru */\n \t      case CLOBBER:\n-\t\tmark_set_1 (pbi, code, SET_DEST (sub), cond, insn, pbi->flags);\n+\t      mark_clob:\n+\t\tmark_set_1 (pbi, code, SET_DEST (sub), cond, insn, flags);\n \t\tbreak;\n \n \t      default:\n@@ -2713,6 +2727,9 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n \t\t{\n \t\t  for (i = regno_first; i <= regno_last; i++)\n \t\t    regs_ever_live[i] = 1;\n+\t\t  if (flags & PROP_ASM_SCAN)\n+\t\t    for (i = regno_first; i <= regno_last; i++)\n+\t\t      regs_asm_clobbered[i] = 1;\n \t\t}\n \t      else\n \t\t{\n@@ -2798,6 +2815,14 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n     {\n       if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n \tpbi->reg_next_use[regno_first] = 0;\n+\n+      if ((flags & PROP_REG_INFO) != 0\n+\t  && (flags & PROP_ASM_SCAN) != 0\n+\t  &&  regno_first < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  for (i = regno_first; i <= regno_last; i++)\n+\t    regs_asm_clobbered[i] = 1;\n+\t}\n     }\n \n   /* If this is the last pass and this is a SCRATCH, show it will be dying"}, {"sha": "c337cd41cfc87d3280e8c05a5073667dadfae0f3", "filename": "gcc/global.c", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=df2ef49bbf1d8e81db688fb49ddaf7e614b71961", "patch": "@@ -343,22 +343,42 @@ global_alloc (FILE *file)\n #ifdef ELIMINABLE_REGS\n   for (i = 0; i < ARRAY_SIZE (eliminables); i++)\n     {\n-      SET_HARD_REG_BIT (eliminable_regset, eliminables[i].from);\n+      bool cannot_elim\n+\t= (! CAN_ELIMINATE (eliminables[i].from, eliminables[i].to)\n+\t   || (eliminables[i].to == STACK_POINTER_REGNUM && need_fp));\n \n-      if (! CAN_ELIMINATE (eliminables[i].from, eliminables[i].to)\n-\t  || (eliminables[i].to == STACK_POINTER_REGNUM && need_fp))\n-\tSET_HARD_REG_BIT (no_global_alloc_regs, eliminables[i].from);\n+      if (!regs_asm_clobbered[eliminables[i].from])\n+\t{\n+\t  SET_HARD_REG_BIT (eliminable_regset, eliminables[i].from);\n+\n+\t  if (cannot_elim)\n+\t    SET_HARD_REG_BIT (no_global_alloc_regs, eliminables[i].from);\n+\t}\n+      else if (cannot_elim)\n+\terror (\"%s cannot be used in asm here\",\n+\t       reg_names[eliminables[i].from]);\n     }\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-  SET_HARD_REG_BIT (eliminable_regset, HARD_FRAME_POINTER_REGNUM);\n-  if (need_fp)\n-    SET_HARD_REG_BIT (no_global_alloc_regs, HARD_FRAME_POINTER_REGNUM);\n+  if (!regs_asm_clobbered[HARD_FRAME_POINTER_REGNUM])\n+    {\n+      SET_HARD_REG_BIT (eliminable_regset, HARD_FRAME_POINTER_REGNUM);\n+      if (need_fp)\n+\tSET_HARD_REG_BIT (no_global_alloc_regs, HARD_FRAME_POINTER_REGNUM);\n+    }\n+  else if (need_fp)\n+    error (\"%s cannot be used in asm here\",\n+\t   reg_names[HARD_FRAME_POINTER_REGNUM]);\n #endif\n \n #else\n-  SET_HARD_REG_BIT (eliminable_regset, FRAME_POINTER_REGNUM);\n-  if (need_fp)\n-    SET_HARD_REG_BIT (no_global_alloc_regs, FRAME_POINTER_REGNUM);\n+  if (!regs_asm_clobbered[FRAME_POINTER_REGNUM])\n+    {\n+      SET_HARD_REG_BIT (eliminable_regset, FRAME_POINTER_REGNUM);\n+      if (need_fp)\n+\tSET_HARD_REG_BIT (no_global_alloc_regs, FRAME_POINTER_REGNUM);\n+    }\n+  else if (need_fp)\n+    error (\"%s cannot be used in asm here\", reg_names[FRAME_POINTER_REGNUM]);\n #endif\n \n   /* Track which registers have already been used.  Start with registers"}, {"sha": "9c9edccb26b8c7acc41c815ec643344307252b8a", "filename": "gcc/regs.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2ef49bbf1d8e81db688fb49ddaf7e614b71961/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=df2ef49bbf1d8e81db688fb49ddaf7e614b71961", "patch": "@@ -153,11 +153,14 @@ extern bitmap_head subregs_of_mode;\n \n extern short *reg_renumber;\n \n-/* Vector indexed by hardware reg\n-   saying whether that reg is ever used.  */\n+/* Vector indexed by hardware reg saying whether that reg is ever used.  */\n \n extern char regs_ever_live[FIRST_PSEUDO_REGISTER];\n \n+/* Like regs_ever_live, but saying whether reg is set by asm statements.  */\n+\n+extern char regs_asm_clobbered[FIRST_PSEUDO_REGISTER];\n+\n /* For each hard register, the widest mode object that it can contain.\n    This will be a MODE_INT mode if the register can hold integers.  Otherwise\n    it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the"}]}