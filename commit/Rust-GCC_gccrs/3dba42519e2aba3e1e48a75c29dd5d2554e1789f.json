{"sha": "3dba42519e2aba3e1e48a75c29dd5d2554e1789f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RiYTQyNTE5ZTJhYmEzZTFlNDhhNzVjMjlkZDVkMjU1NGUxNzg5Zg==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "2001-12-12T05:01:32Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "2001-12-12T05:01:32Z"}, "message": "basic-block.h (flow_preorder_transversal_compute): Declare.\n\n\t* basic-block.h (flow_preorder_transversal_compute): Declare.\n\t* cfganal.c (flow_preorder_transversal_compute): Implement.\n\nFrom-SVN: r47920", "tree": {"sha": "084ce425b04f551cac185ff25ad613ecc346d389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/084ce425b04f551cac185ff25ad613ecc346d389"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dba42519e2aba3e1e48a75c29dd5d2554e1789f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dba42519e2aba3e1e48a75c29dd5d2554e1789f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dba42519e2aba3e1e48a75c29dd5d2554e1789f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dba42519e2aba3e1e48a75c29dd5d2554e1789f/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f5f53ae35dfa8763a87ccd11cb06cd478fdb49e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5f53ae35dfa8763a87ccd11cb06cd478fdb49e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5f53ae35dfa8763a87ccd11cb06cd478fdb49e6"}], "stats": {"total": 132, "additions": 132, "deletions": 0}, "files": [{"sha": "53cd3069d4256db1acfa3c2e974cd54a3fc9f431", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dba42519e2aba3e1e48a75c29dd5d2554e1789f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dba42519e2aba3e1e48a75c29dd5d2554e1789f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3dba42519e2aba3e1e48a75c29dd5d2554e1789f", "patch": "@@ -1,3 +1,8 @@\n+Tue Dec 11 23:58:39 EST 2001  John Wehle  (john@feith.com)\n+\n+\t* basic-block.h (flow_preorder_transversal_compute): Declare.\n+\t* cfganal.c (flow_preorder_transversal_compute): Implement.\n+\n Tue Dec 11 23:54:27 EST 2001  John Wehle  (john@feith.com)\n \n \t* cfganal.c (flow_depth_first_order_compute): Always"}, {"sha": "f31b465698228cb87372742e5462414db9c5f672", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dba42519e2aba3e1e48a75c29dd5d2554e1789f/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dba42519e2aba3e1e48a75c29dd5d2554e1789f/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3dba42519e2aba3e1e48a75c29dd5d2554e1789f", "patch": "@@ -321,6 +321,7 @@ extern void tidy_fallthru_edge\t\tPARAMS ((edge, basic_block,\n extern void tidy_fallthru_edges\t\tPARAMS ((void));\n extern void flow_reverse_top_sort_order_compute\tPARAMS ((int *));\n extern int flow_depth_first_order_compute\tPARAMS ((int *, int *));\n+extern void flow_preorder_transversal_compute\tPARAMS ((int *));\n extern void dump_edge_info\t\tPARAMS ((FILE *, edge, int));\n extern void clear_edges\t\t\tPARAMS ((void));\n extern void mark_critical_edges\t\tPARAMS ((void));"}, {"sha": "0175a94892f75164e12a9b0282d2e1f96a7f7103", "filename": "gcc/cfganal.c", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dba42519e2aba3e1e48a75c29dd5d2554e1789f/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dba42519e2aba3e1e48a75c29dd5d2554e1789f/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=3dba42519e2aba3e1e48a75c29dd5d2554e1789f", "patch": "@@ -923,6 +923,132 @@ flow_depth_first_order_compute (dfs_order, rc_order)\n   return dfsnum;\n }\n \n+struct dfst_node {\n+    unsigned nnodes;\n+    struct dfst_node **node;\n+    struct dfst_node *up;\n+};\n+\n+/* Compute a preorder transversal ordering such that a sub-tree which\n+   is the source of a cross edge appears before the sub-tree which is\n+   the destination of the cross edge.  This allows for easy detection\n+   of all the entry blocks for a loop.\n+\n+   The ordering is compute by:\n+\n+     1) Generating a depth first spanning tree.\n+\n+     2) Walking the resulting tree from right to left.  */\n+\n+void\n+flow_preorder_transversal_compute (pot_order)\n+     int *pot_order;\n+{\n+  edge e;\n+  edge *stack;\n+  int i;\n+  int max_successors;\n+  int sp;\n+  sbitmap visited;\n+  struct dfst_node *node;\n+  struct dfst_node *dfst;\n+\n+  /* Allocate stack for back-tracking up CFG.  */\n+  stack = (edge *) xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  sp = 0;\n+\n+  /* Allocate the tree.  */\n+  dfst\n+    = (struct dfst_node *) xcalloc (n_basic_blocks, sizeof (struct dfst_node));\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      max_successors = 0;\n+      for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n+\tmax_successors++;\n+      dfst[i].node = max_successors ? (struct dfst_node **)\n+\t\t\t\t      xcalloc (max_successors,\n+\t\t\t\t\t       sizeof (struct dfst_node *))\n+\t\t\t    : NULL;\n+    }\n+\n+  /* Allocate bitmap to track nodes that have been visited.  */\n+  visited = sbitmap_alloc (n_basic_blocks);\n+\n+  /* None of the nodes in the CFG have been visited yet.  */\n+  sbitmap_zero (visited);\n+\n+  /* Push the first edge on to the stack.  */\n+  stack[sp++] = ENTRY_BLOCK_PTR->succ;\n+\n+  while (sp)\n+    {\n+      basic_block src;\n+      basic_block dest;\n+\n+      /* Look at the edge on the top of the stack.  */\n+      e = stack[sp - 1];\n+      src = e->src;\n+      dest = e->dest;\n+\n+      /* Check if the edge destination has been visited yet.  */\n+      if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n+\t{\n+\t  /* Mark that we have visited the destination.  */\n+\t  SET_BIT (visited, dest->index);\n+\n+\t  /* Add the destination to the preorder tree.  */\n+\t  if (src != ENTRY_BLOCK_PTR)\n+\t    {\n+\t      dfst[src->index].node[dfst[src->index].nnodes++]\n+\t\t= &dfst[dest->index];\n+\t      dfst[dest->index].up = &dfst[src->index];\n+\t    }\n+\n+\t  if (dest->succ)\n+\t    {\n+\t      /* Since the DEST node has been visited for the first\n+\t\t time, check its successors.  */\n+\t      stack[sp++] = dest->succ;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (e->succ_next)\n+\t    stack[sp - 1] = e->succ_next;\n+\t  else\n+\t    sp--;\n+\t}\n+    }\n+\n+  free (stack);\n+  sbitmap_free (visited);\n+\n+  /* Record the preorder transversal order by\n+     walking the tree from right to left.  */\n+\n+  i = 0;\n+  node = &dfst[0];\n+  pot_order[i++] = 0;\n+\n+  while (node)\n+    {\n+      if (node->nnodes)\n+\t{\n+\t  node = node->node[--node->nnodes];\n+\t  pot_order[i++] = node - dfst;\n+\t}\n+      else\n+\tnode = node->up;\n+    }\n+\n+  /* Free the tree.  */\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    if (dfst[i].node)\n+      free (dfst[i].node);\n+  free (dfst);\n+}\n+\n /* Compute the depth first search order on the _reverse_ graph and\n    store in the array DFS_ORDER, marking the nodes visited in VISITED.\n    Returns the number of nodes visited."}]}