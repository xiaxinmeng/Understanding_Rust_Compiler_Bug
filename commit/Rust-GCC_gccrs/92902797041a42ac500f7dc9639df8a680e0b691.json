{"sha": "92902797041a42ac500f7dc9639df8a680e0b691", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI5MDI3OTcwNDFhNDJhYzUwMGY3ZGM5NjM5ZGY4YTY4MGUwYjY5MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2010-06-03T00:06:12Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2010-06-03T00:06:12Z"}, "message": "PR target/44218, improve -mrecip on powerpc\n\nFrom-SVN: r160199", "tree": {"sha": "d55e7fa0ae623e1c748075d3f81edeb35fb123fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d55e7fa0ae623e1c748075d3f81edeb35fb123fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92902797041a42ac500f7dc9639df8a680e0b691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92902797041a42ac500f7dc9639df8a680e0b691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92902797041a42ac500f7dc9639df8a680e0b691", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92902797041a42ac500f7dc9639df8a680e0b691/comments", "author": null, "committer": null, "parents": [{"sha": "6c07d08b90b124d8d3be8015726caf799e2e2a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c07d08b90b124d8d3be8015726caf799e2e2a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c07d08b90b124d8d3be8015726caf799e2e2a13"}], "stats": {"total": 2566, "additions": 2112, "deletions": 454}, "files": [{"sha": "ecfdab1044dc2f5837584fd558046e5a9570345f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -1,3 +1,139 @@\n+2010-06-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/44218\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Delete obsolete\n+\t-mswdiv option.  Add -mrecip, -mrecip=<xxx>, -mrecip-precision\n+\toptions.\n+\n+\t* doc/extend.texi (powerpc builtins): Document vec_recip,\n+\tvec_rsqrt, vec_rsqrte altivec/vsx builtins.\n+\n+\t* config/rs6000/rs60000-protos.h (rs6000_emit_swdiv): New\n+\tfunction.\n+\t(rs6000_emit_swrsqrt): Ditto.\n+\t(rs6000_emit_swdivsf): Delete.\n+\t(rs6000_emit_swdivdf): Ditto.\n+\t(rs6000_emit_swrsqrtsf): Ditto.\n+\n+\t* config/rs6000/rs6000.c (rs6000_recip_bits): New global to\n+\tdescribe the reciprocal estimate support for each type.\n+\t(recip_options): Map -mrecip=<opt> into option bits.\n+\t(gen_2arg_fn_t): New typedef for binary rtx gen function.\n+\t(rs6000_debug_reg_global): If -mdebug=reg, print the state of the\n+\treciprocal estimate instructions.\n+\t(rs6000_init_hard_regno_mode_ok): Key ws constraint off of the\n+\tdebug -mvsx-scalar-memory switch instead of -mvsx-scalar-double.\n+\tSet up rs6000_recip_bits based on the -mrecip* options.  Print the\n+\tcost information if -mdebug=cost or -mdebug=reg.\n+\t(rs6000_override_options): Set -mrecip-precision for power6, and\n+\tpower7 machines.  If -mvsx or -mdfp, enable various options that\n+\tcame in previous instruction set ISAs, unless the option was\n+\texplicitly disabled by the command line option.  Parse\n+\t-mrecip=<opt> options.\n+\t(rs6000_builtin_vectorized_function): Add support for vectorizing\n+\tthe reciprocal estimate builtins and expansions.\n+\t(rs6000_handle_option): Add -mrecip, -mrecip=<opt> support.\n+\t(bdesc_2arg): Add reciprocal estimate builtins.\n+\t(bdesc_1arg): Add reciprocal square root estimate builtins.\n+\t(rs6000_expand_builtin): Rewrite to use a switch statement,\n+\tinstead of multiple if/then/elses.  Add reciprocal estimate\n+\tbuiltins.\n+\t(rs6000_init_builtins): Create declarations for reciprocal\n+\testimate builtins.\n+\t(rs6000_preferred_reload_class): Simplify VSX preferences, if scalar\n+\tsized, prefer traditional floating point registers, if integer\n+\tvector types, prefer altivec registers.  Don't actually look at\n+\tthe memory address any more.\n+\t(rs6000_builtin_reciprocal): Add new builtin reciprocal estimate\n+\tbuiltins.\n+\t(rs6000_load_constant_and_splat): New helper function to load up\n+\tthe constant for reciprocal estimate instructions.\n+\t(rs6000_emit_madd): New helper function for generating\n+\tmultiply/add type instructions, based on the current switches.\n+\t(rs6000_emit_msub): Ditto.\n+\t(rs6000_emit_mnsub): Ditto.\n+\t(rs6000_emit_swdiv_high_precision): Replace rs6000_emit_swdivsf to\n+\treplace a divide with a reciprocal estimate and fixup, adding\n+\tsupport for machines with high precision and vectors.\n+\t(rs6000_emit_swdiv_low_precision): Rewrite rs6000_emit_swdivdf for\n+\tlow precision machines.\n+\t(rs6000_emit_swdiv): New common function to be called to replace a\n+\tdivision with reciprocal estimate and fixup.\n+\t(rs6000_emit_swrsqrt): Replace rs6000_emit_swrsqrtsf.  Add support\n+\tfor double and vector types.  Add support for high precision\n+\tmachines.\n+\n+\t* config/rs6000/rs6000.h (TARGET_FRES): New macro to say whether\n+\tthe reciprocal estimate instructions can be generated.\n+\t(TARGET_FRE): Ditto.\n+\t(TARGET_FRSQRTES): Ditto.\n+\t(TARGET_FRSQRTE): Ditto.\n+\t(RS6000_RECIP_*): New macros for reciprocal estimate support.\n+\n+\t* config/rs6000/vector.md (rsqrte<mode>2): New insn for reciprocal\n+\tsquare root estimate on vectors.\n+\t(re<mode>2): New insn for reciprocal division estimate on vectors.\n+\n+\t* config/rs6000/rs6000-buitlins.def (ALTIVEC_BUILTIN_VRSQRTFP):\n+\tNew builtin.\n+\t(ALTIVEC_BUILTIN_VRECIPFP): Ditto.\n+\t(ALTIVEC_BUITLIN_VEC_RE): Ditto.\n+\t(ALTIVEC_BUILTIN_VEC_RSQRT): Ditto.\n+\t(VSX_BUILTIN_RSQRT_V4SF): Ditto.\n+\t(VSX_BUITLIN_RSQRT_V2DF): Ditto.\n+\t(RS6000_BUILTIN_RSQRT): Ditto.\n+\t(ALTIVEC_BUILTIN_VEC_RSQRTE): Denote that the builtin is a\n+\tfloating point builtin.\n+\n+\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Define\n+\tmacros __RECIP__, __RECIPF__, __RSQRTE__, __RSQRTEF__,\n+\t__RECIP_PRECISION__ based on the command line switches.\n+\t(altivec_overloaded_builtins): Add reciprocal estimate builtins.\n+\n+\t* config/rs6000/rs6000.opt (-mrecip): Document add support for\n+\treplacing division instructions with reciprocal estimate and\n+\tfixup.\n+\t(-mrecip=<opt>): New option.\n+\t(-mrecip-precision): Ditto.\n+\n+\t* config/rs6000/vsx.md (UNSPEC_VSX_RSQRTE): Delete.\n+\t(vsx_rsqrte<mode>2): Use UNSPEC_RSQRT not UNSPEC_VSX_RSQRTE.\n+\t(vsx_copysignsf3): If -mvsx, use double precision cpsign on single\n+\tprecision scalar.\n+\n+\t* config/rs6000/altivec.md (UNSPEC_RSQRTEFP): Delete.\n+\t(UNSPEC_VREFP): Ditto.\n+\t(altivec_vnmsubfp*): Make altivec nmsub mirror the scalar and VSX\n+\tconterparts with regard to support of -mno-fused-madd and\n+\t-ffast-math.\n+\t(altivec_vrsqrtefp): Use common UNSPEC to allow scalar/vector\n+\treciprocal estimate instructions to be generated.\n+\t(altivec_vrefp): Ditto.\n+\n+\t* config/rs6000/rs6000.md (RECIPF): New iterator for reciprocal\n+\testimate support.\n+\t(rreg): New mode attribute for reciprocal estimate support.\n+\t(recip<mode>3): New insn for division using reciprocal estimate\n+\tand fixup builtins.\n+\t(divide define_split): New define_split to convert floating point\n+\tdivision to use reciprocal estimate if the user used the\n+\tappropriate options and the split is run when we can add new\n+\tpseudo registers for the fixup.\n+\t(rsqrt<mode>2): New insn for reciprocal square root support.\n+\t(recipsf3): Move into recip<mode>3.\n+\t(recipdf3): Ditto.\n+\t(fres): Use TARGET_FRES.\n+\t(rsqrtsf2): Move into rsqrt<mode>2.\n+\t(rsqrtsf_internal1): Use TARGET_FRSQRTSES.\n+\t(copysignsf3): Add support for VSX.\n+\t(fred): Use TARGET_FRE.\n+\t(fred_fpr): Ditto.\n+\t(rsqrtdf_internal1): New function for frsqrte instruciton.\n+\n+\t* config/rs6000/altivec.h (vec_recipdiv): Define new vector\n+\tbuiltin.\n+\t(vec_rsqrt): Ditto.\n+\n 2010-06-03  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/44291"}, {"sha": "5f4510adc30bdbc475ec32410fbb715843e0f1bc", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -163,6 +163,8 @@\n #define vec_vpkshus __builtin_vec_vpkshus\n #define vec_re __builtin_vec_re\n #define vec_round __builtin_vec_round\n+#define vec_recipdiv __builtin_vec_recipdiv\n+#define vec_rsqrt __builtin_vec_rsqrt\n #define vec_rsqrte __builtin_vec_rsqrte\n #define vec_vsubfp __builtin_vec_vsubfp\n #define vec_subc __builtin_vec_subc"}, {"sha": "7bf3c660312bbe24c32fa92262193430a504f807", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 68, "deletions": 16, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -75,9 +75,7 @@\n    (UNSPEC_VCTSXS       154)\n    (UNSPEC_VLOGEFP      155)\n    (UNSPEC_VEXPTEFP     156)\n-   (UNSPEC_VRSQRTEFP    157)\n-   (UNSPEC_VREFP        158)\n-   ;; 159-162 deleted\n+   ;; 157-162 deleted\n    (UNSPEC_VLSDOI       163)\n    (UNSPEC_VUPKHSB      167)\n    (UNSPEC_VUPKHPX      168)\n@@ -141,10 +139,11 @@\n    (UNSPEC_VPERMHI\t321)\n    (UNSPEC_INTERHI      322)\n    (UNSPEC_INTERLO      323)\n-   (UNSPEC_VUPKHS_V4SF   324)\n-   (UNSPEC_VUPKLS_V4SF   325)\n-   (UNSPEC_VUPKHU_V4SF   326)\n-   (UNSPEC_VUPKLU_V4SF   327)\n+   (UNSPEC_VUPKHS_V4SF  324)\n+   (UNSPEC_VUPKLS_V4SF  325)\n+   (UNSPEC_VUPKHU_V4SF  326)\n+   (UNSPEC_VUPKLU_V4SF  327)\n+   (UNSPEC_VNMSUBFP\t328)\n ])\n \n (define_constants\n@@ -628,11 +627,64 @@\n }\")\n \n ;; Fused multiply subtract \n-(define_insn \"altivec_vnmsubfp\"\n+(define_expand \"altivec_vnmsubfp\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand:V4SF 1 \"register_operand\" \"\")\n+   (match_operand:V4SF 2 \"register_operand\" \"\")\n+   (match_operand:V4SF 3 \"register_operand\" \"\")]\n+  \"VECTOR_UNIT_ALTIVEC_P (V4SFmode)\"\n+{\n+  if (TARGET_FUSED_MADD && HONOR_SIGNED_ZEROS (SFmode))\n+    {\n+       emit_insn (gen_altivec_vnmsubfp_1 (operands[0], operands[1],\n+\t\t\t\t\t  operands[2], operands[3]));\n+       DONE;\n+    }\n+  else if (TARGET_FUSED_MADD && !HONOR_SIGNED_ZEROS (DFmode))\n+    {\n+       emit_insn (gen_altivec_vnmsubfp_2 (operands[0], operands[1],\n+\t\t\t\t\t  operands[2], operands[3]));\n+       DONE;\n+    }\n+  else\n+    {\n+       emit_insn (gen_altivec_vnmsubfp_3 (operands[0], operands[1],\n+\t\t\t\t\t  operands[2], operands[3]));\n+       DONE;\n+    }\n+})\n+\n+(define_insn \"altivec_vnmsubfp_1\"\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n-\t(neg:V4SF (minus:V4SF (mult:V4SF (match_operand:V4SF 1 \"register_operand\" \"v\")\n-\t\t\t       (match_operand:V4SF 2 \"register_operand\" \"v\"))\n-\t  \t    (match_operand:V4SF 3 \"register_operand\" \"v\"))))]\n+\t(neg:V4SF\n+\t (minus:V4SF\n+\t  (mult:V4SF\n+\t   (match_operand:V4SF 1 \"register_operand\" \"v\")\n+\t   (match_operand:V4SF 2 \"register_operand\" \"v\"))\n+\t  (match_operand:V4SF 3 \"register_operand\" \"v\"))))]\n+  \"VECTOR_UNIT_ALTIVEC_P (V4SFmode) && TARGET_FUSED_MADD\n+   && HONOR_SIGNED_ZEROS (SFmode)\"\n+  \"vnmsubfp %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"altivec_vnmsubfp_2\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t(minus:V4SF\n+\t (match_operand:V4SF 3 \"register_operand\" \"v\")\n+\t (mult:V4SF\n+\t  (match_operand:V4SF 1 \"register_operand\" \"v\")\n+\t  (match_operand:V4SF 2 \"register_operand\" \"v\"))))]\n+  \"VECTOR_UNIT_ALTIVEC_P (V4SFmode) && TARGET_FUSED_MADD\n+   && !HONOR_SIGNED_ZEROS (SFmode)\"\n+  \"vnmsubfp %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"altivec_vnmsubfp_3\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t(unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")\n+\t\t       (match_operand:V4SF 2 \"register_operand\" \"v\")\n+\t\t       (match_operand:V4SF 3 \"register_operand\" \"v\")]\n+\t\t      UNSPEC_VNMSUBFP))]\n   \"VECTOR_UNIT_ALTIVEC_P (V4SFmode)\"\n   \"vnmsubfp %0,%1,%2,%3\"\n   [(set_attr \"type\" \"vecfloat\")])\n@@ -1444,19 +1496,19 @@\n   \"vexptefp %0,%1\"\n   [(set_attr \"type\" \"vecfloat\")])\n \n-(define_insn \"altivec_vrsqrtefp\"\n+(define_insn \"*altivec_vrsqrtefp\"\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n         (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")]\n-\t\t     UNSPEC_VRSQRTEFP))]\n-  \"TARGET_ALTIVEC\"\n+\t\t     UNSPEC_RSQRT))]\n+  \"VECTOR_UNIT_ALTIVEC_P (V4SFmode)\"\n   \"vrsqrtefp %0,%1\"\n   [(set_attr \"type\" \"vecfloat\")])\n \n (define_insn \"altivec_vrefp\"\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n         (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")]\n-\t\t     UNSPEC_VREFP))]\n-  \"TARGET_ALTIVEC\"\n+\t\t     UNSPEC_FRES))]\n+  \"VECTOR_UNIT_ALTIVEC_P (V4SFmode)\"\n   \"vrefp %0,%1\"\n   [(set_attr \"type\" \"vecfloat\")])\n "}, {"sha": "9f45a72e2c029abf6862d06b2a620230ad3528a9", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -159,6 +159,7 @@ RS6000_BUILTIN(ALTIVEC_BUILTIN_VRFIZ,\t\t\tRS6000_BTC_FP_PURE)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VRLB,\t\t\tRS6000_BTC_CONST)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VRLH,\t\t\tRS6000_BTC_CONST)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VRLW,\t\t\tRS6000_BTC_CONST)\n+RS6000_BUILTIN(ALTIVEC_BUILTIN_VRSQRTFP,\t\tRS6000_BTC_FP_PURE)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VRSQRTEFP,\t\tRS6000_BTC_FP_PURE)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VSLB,\t\t\tRS6000_BTC_CONST)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VSLH,\t\t\tRS6000_BTC_CONST)\n@@ -269,6 +270,7 @@ RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_EXT_V8HI,\t\tRS6000_BTC_CONST)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_EXT_V16QI,\t\tRS6000_BTC_CONST)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_EXT_V4SF,\t\tRS6000_BTC_CONST)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_COPYSIGN_V4SF,\t\tRS6000_BTC_CONST)\n+RS6000_BUILTIN(ALTIVEC_BUILTIN_VRECIPFP,\t\tRS6000_BTC_FP_PURE)\n \n /* Altivec overloaded builtins.  */\n /* For now, don't set the classification for overloaded functions.\n@@ -351,10 +353,12 @@ RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_PACKS,\t\tRS6000_BTC_MISC)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_PACKSU,\t\tRS6000_BTC_MISC)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_PERM,\t\tRS6000_BTC_MISC)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_RE,\t\t\tRS6000_BTC_MISC)\n+RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_RECIP,\t\tRS6000_BTC_FP_PURE)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_RL,\t\t\tRS6000_BTC_MISC)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_RINT,\t\tRS6000_BTC_MISC)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_ROUND,\t\tRS6000_BTC_MISC)\n-RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_RSQRTE,\t\tRS6000_BTC_MISC)\n+RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_RSQRT,\t\tRS6000_BTC_FP_PURE)\n+RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_RSQRTE,\t\tRS6000_BTC_FP_PURE)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_SEL,\t\t\tRS6000_BTC_MISC)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_SL,\t\t\tRS6000_BTC_MISC)\n RS6000_BUILTIN(ALTIVEC_BUILTIN_VEC_SLD,\t\t\tRS6000_BTC_MISC)\n@@ -959,6 +963,10 @@ RS6000_BUILTIN(VSX_BUILTIN_VEC_MERGEL_V2DF,\t\tRS6000_BTC_CONST)\n RS6000_BUILTIN(VSX_BUILTIN_VEC_MERGEL_V2DI,\t\tRS6000_BTC_CONST)\n RS6000_BUILTIN(VSX_BUILTIN_VEC_MERGEH_V2DF,\t\tRS6000_BTC_CONST)\n RS6000_BUILTIN(VSX_BUILTIN_VEC_MERGEH_V2DI,\t\tRS6000_BTC_CONST)\n+RS6000_BUILTIN(VSX_BUILTIN_VEC_RSQRT_V4SF,\t\tRS6000_BTC_FP_PURE)\n+RS6000_BUILTIN(VSX_BUILTIN_VEC_RSQRT_V2DF,\t\tRS6000_BTC_FP_PURE)\n+RS6000_BUILTIN(VSX_BUILTIN_RECIP_V4SF,\t\t\tRS6000_BTC_FP_PURE)\n+RS6000_BUILTIN(VSX_BUILTIN_RECIP_V2DF,\t\t\tRS6000_BTC_FP_PURE)\n \n /* VSX overloaded builtins, add the overloaded functions not present in\n    Altivec.  */\n@@ -991,4 +999,5 @@ RS6000_BUILTIN(POWER7_BUILTIN_BPERMD,\t\t\tRS6000_BTC_CONST)\n RS6000_BUILTIN(RS6000_BUILTIN_RECIP,\t\t\tRS6000_BTC_FP_PURE)\n RS6000_BUILTIN(RS6000_BUILTIN_RECIPF,\t\t\tRS6000_BTC_FP_PURE)\n RS6000_BUILTIN(RS6000_BUILTIN_RSQRTF,\t\t\tRS6000_BTC_FP_PURE)\n+RS6000_BUILTIN(RS6000_BUILTIN_RSQRT,\t\t\tRS6000_BTC_FP_PURE)\n RS6000_BUILTIN(RS6000_BUILTIN_BSWAP_HI,\t\t\tRS6000_BTC_CONST)"}, {"sha": "7a197c1fbcc247bef7011c04f3e3b5afa0c99468", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -362,6 +362,16 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n       builtin_define (\"__builtin_vsx_xvnmsubasp=__builtin_vsx_xvnmsubsp\");\n       builtin_define (\"__builtin_vsx_xvnmsubmsp=__builtin_vsx_xvnmsubsp\");\n     }\n+  if (RS6000_RECIP_HAVE_RE_P (DFmode))\n+    builtin_define (\"__RECIP__\");\n+  if (RS6000_RECIP_HAVE_RE_P (SFmode))\n+    builtin_define (\"__RECIPF__\");\n+  if (RS6000_RECIP_HAVE_RSQRTE_P (DFmode))\n+    builtin_define (\"__RSQRTE__\");\n+  if (RS6000_RECIP_HAVE_RSQRTE_P (SFmode))\n+    builtin_define (\"__RSQRTEF__\");\n+  if (TARGET_RECIP_PRECISION)\n+    builtin_define (\"__RECIP_PRECISION__\");\n \n   /* Tell users they can use __builtin_bswap{16,64}.  */\n   builtin_define (\"__HAVE_BSWAP__\");\n@@ -479,10 +489,22 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_void, RS6000_BTI_bool_V16QI, 0, 0 },\n   { ALTIVEC_BUILTIN_VEC_RE, ALTIVEC_BUILTIN_VREFP,\n     RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0, 0 },\n+  { ALTIVEC_BUILTIN_VEC_RE, VSX_BUILTIN_XVREDP,\n+    RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0, 0 },\n   { ALTIVEC_BUILTIN_VEC_ROUND, ALTIVEC_BUILTIN_VRFIN,\n     RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0, 0 },\n+  { ALTIVEC_BUILTIN_VEC_RECIP, ALTIVEC_BUILTIN_VRECIPFP,\n+    RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n+  { ALTIVEC_BUILTIN_VEC_RECIP, VSX_BUILTIN_RECIP_V2DF,\n+    RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },\n+  { ALTIVEC_BUILTIN_VEC_RSQRT, ALTIVEC_BUILTIN_VRSQRTFP,\n+    RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0, 0 },\n+  { ALTIVEC_BUILTIN_VEC_RSQRT, VSX_BUILTIN_VEC_RSQRT_V2DF,\n+    RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0, 0 },\n   { ALTIVEC_BUILTIN_VEC_RSQRTE, ALTIVEC_BUILTIN_VRSQRTEFP,\n     RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0, 0 },\n+  { ALTIVEC_BUILTIN_VEC_RSQRTE, VSX_BUILTIN_XVRSQRTEDP,\n+    RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0, 0 },\n   { ALTIVEC_BUILTIN_VEC_TRUNC, ALTIVEC_BUILTIN_VRFIZ,\n     RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0, 0 },\n   { ALTIVEC_BUILTIN_VEC_TRUNC, VSX_BUILTIN_XVRDPIZ,"}, {"sha": "3f02286233284dc78fbabf460d351449801cc888", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -106,9 +106,8 @@ extern void rs6000_split_compare_and_swap (rtx, rtx, rtx, rtx, rtx);\n extern void rs6000_expand_compare_and_swapqhi (rtx, rtx, rtx, rtx);\n extern void rs6000_split_compare_and_swapqhi (rtx, rtx, rtx, rtx, rtx, rtx);\n extern void rs6000_split_lock_test_and_set (rtx, rtx, rtx, rtx);\n-extern void rs6000_emit_swdivsf (rtx, rtx, rtx);\n-extern void rs6000_emit_swdivdf (rtx, rtx, rtx);\n-extern void rs6000_emit_swrsqrtsf (rtx, rtx);\n+extern void rs6000_emit_swdiv (rtx, rtx, rtx, bool);\n+extern void rs6000_emit_swrsqrt (rtx, rtx);\n extern void output_toc (FILE *, rtx, int, enum machine_mode);\n extern rtx rs6000_longcall_ref (rtx);\n extern void rs6000_fatal_bad_address (rtx);"}, {"sha": "9bfaf54c2a2afe37d8839df9dc96ef41cdd18628", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 810, "deletions": 368, "changes": 1178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -316,6 +316,61 @@ int rs6000_vector_align[NUM_MACHINE_MODES];\n \n /* Map selected modes to types for builtins.  */\n static GTY(()) tree builtin_mode_to_type[MAX_MACHINE_MODE][2];\n+\n+/* What modes to automatically generate reciprocal divide estimate (fre) and\n+   reciprocal sqrt (frsqrte) for.  */\n+unsigned char rs6000_recip_bits[MAX_MACHINE_MODE];\n+\n+/* Masks to determine which reciprocal esitmate instructions to generate\n+   automatically.  */\n+enum rs6000_recip_mask {\n+  RECIP_SF_DIV\t\t= 0x001,\t/* Use divide estimate */\n+  RECIP_DF_DIV\t\t= 0x002,\n+  RECIP_V4SF_DIV\t= 0x004,\n+  RECIP_V2DF_DIV\t= 0x008,\n+\n+  RECIP_SF_RSQRT\t= 0x010,\t/* Use reciprocal sqrt estimate.  */\n+  RECIP_DF_RSQRT\t= 0x020,\n+  RECIP_V4SF_RSQRT\t= 0x040,\n+  RECIP_V2DF_RSQRT\t= 0x080,\n+\n+  /* Various combination of flags for -mrecip=xxx.  */\n+  RECIP_NONE\t\t= 0,\n+  RECIP_ALL\t\t= (RECIP_SF_DIV | RECIP_DF_DIV | RECIP_V4SF_DIV\n+\t\t\t   | RECIP_V2DF_DIV | RECIP_SF_RSQRT | RECIP_DF_RSQRT\n+\t\t\t   | RECIP_V4SF_RSQRT | RECIP_V2DF_RSQRT),\n+\n+  RECIP_HIGH_PRECISION\t= RECIP_ALL,\n+\n+  /* On low precision machines like the power5, don't enable double precision\n+     reciprocal square root estimate, since it isn't accurate enough.  */\n+  RECIP_LOW_PRECISION\t= (RECIP_ALL & ~(RECIP_DF_RSQRT | RECIP_V2DF_RSQRT))\n+};\n+\n+static unsigned int rs6000_recip_control;\n+static const char *rs6000_recip_name;\n+\n+/* -mrecip options.  */\n+static struct\n+{\n+  const char *string;\t\t/* option name */\n+  unsigned int mask;\t\t/* mask bits to set */\n+} recip_options[] = {\n+  { \"all\",\t RECIP_ALL },\n+  { \"none\",\t RECIP_NONE },\n+  { \"div\",\t (RECIP_SF_DIV | RECIP_DF_DIV | RECIP_V4SF_DIV\n+\t\t  | RECIP_V2DF_DIV) },\n+  { \"divf\",\t (RECIP_SF_DIV | RECIP_V4SF_DIV) },\n+  { \"divd\",\t (RECIP_DF_DIV | RECIP_V2DF_DIV) },\n+  { \"rsqrt\",\t (RECIP_SF_RSQRT | RECIP_DF_RSQRT | RECIP_V4SF_RSQRT\n+\t\t  | RECIP_V2DF_RSQRT) },\n+  { \"rsqrtf\",\t (RECIP_SF_RSQRT | RECIP_V4SF_RSQRT) },\n+  { \"rsqrtd\",\t (RECIP_DF_RSQRT | RECIP_V2DF_RSQRT) },\n+};\n+\n+/* 2 argument gen function typedef.  */\n+typedef rtx (*gen_2arg_fn_t) (rtx, rtx, rtx);\n+\n \f\n /* Target cpu costs.  */\n \n@@ -1807,6 +1862,27 @@ rs6000_debug_reg_global (void)\n   if (nl)\n     fputs (nl, stderr);\n \n+  if (rs6000_recip_control)\n+    {\n+      fprintf (stderr, \"\\nReciprocal mask = 0x%x\\n\", rs6000_recip_control);\n+\n+      for (m = 0; m < NUM_MACHINE_MODES; ++m)\n+\tif (rs6000_recip_bits[m])\n+\t  {\n+\t    fprintf (stderr,\n+\t\t     \"Reciprocal estimate mode: %-5s divide: %s rsqrt: %s\\n\",\n+\t\t     GET_MODE_NAME (m),\n+\t\t     (RS6000_RECIP_AUTO_RE_P (m)\n+\t\t      ? \"auto\"\n+\t\t      : (RS6000_RECIP_HAVE_RE_P (m) ? \"have\" : \"none\")),\n+\t\t     (RS6000_RECIP_AUTO_RSQRTE_P (m)\n+\t\t      ? \"auto\"\n+\t\t      : (RS6000_RECIP_HAVE_RSQRTE_P (m) ? \"have\" : \"none\")));\n+\t  }\n+\n+      fputs (\"\\n\", stderr);\n+    }\n+\n   switch (rs6000_sched_costly_dep)\n     {\n     case max_dep_latency:\n@@ -2014,8 +2090,9 @@ rs6000_init_hard_regno_mode_ok (void)\n       rs6000_constraints[RS6000_CONSTRAINT_wa] = VSX_REGS;\n       rs6000_constraints[RS6000_CONSTRAINT_wf] = VSX_REGS;\n       rs6000_constraints[RS6000_CONSTRAINT_wd] = VSX_REGS;\n-      if (TARGET_VSX_SCALAR_DOUBLE)\n-\trs6000_constraints[RS6000_CONSTRAINT_ws] = VSX_REGS;\n+      rs6000_constraints[RS6000_CONSTRAINT_ws] = (TARGET_VSX_SCALAR_MEMORY\n+\t\t\t\t\t\t  ? VSX_REGS\n+\t\t\t\t\t\t  : FLOAT_REGS);\n     }\n \n   if (TARGET_ALTIVEC)\n@@ -2093,8 +2170,111 @@ rs6000_init_hard_regno_mode_ok (void)\n   if (TARGET_E500_DOUBLE)\n     rs6000_class_max_nregs[DFmode][GENERAL_REGS] = 1;\n \n+  /* Calculate which modes to automatically generate code to use a the\n+     reciprocal divide and square root instructions.  In the future, possibly\n+     automatically generate the instructions even if the user did not specify\n+     -mrecip.  The older machines double precision reciprocal sqrt estimate is\n+     not accurate enough.  */\n+  memset (rs6000_recip_bits, 0, sizeof (rs6000_recip_bits));\n+  if (TARGET_FRES)\n+    rs6000_recip_bits[SFmode] = RS6000_RECIP_MASK_HAVE_RE;\n+  if (TARGET_FRE)\n+    rs6000_recip_bits[DFmode] = RS6000_RECIP_MASK_HAVE_RE;\n+  if (VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode))\n+    rs6000_recip_bits[V4SFmode] = RS6000_RECIP_MASK_HAVE_RE;\n+  if (VECTOR_UNIT_VSX_P (V2DFmode))\n+    rs6000_recip_bits[V2DFmode] = RS6000_RECIP_MASK_HAVE_RE;\n+\n+  if (TARGET_FRSQRTES)\n+    rs6000_recip_bits[SFmode] |= RS6000_RECIP_MASK_HAVE_RSQRTE;\n+  if (TARGET_FRSQRTE)\n+    rs6000_recip_bits[DFmode] |= RS6000_RECIP_MASK_HAVE_RSQRTE;\n+  if (VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode))\n+    rs6000_recip_bits[V4SFmode] |= RS6000_RECIP_MASK_HAVE_RSQRTE;\n+  if (VECTOR_UNIT_VSX_P (V2DFmode))\n+    rs6000_recip_bits[V2DFmode] |= RS6000_RECIP_MASK_HAVE_RSQRTE;\n+\n+  if (rs6000_recip_control)\n+    {\n+      if (!TARGET_FUSED_MADD)\n+\twarning (0, \"-mrecip requires -mfused-madd\");\n+      if (!flag_finite_math_only)\n+\twarning (0, \"-mrecip requires -ffinite-math or -ffast-math\");\n+      if (flag_trapping_math)\n+\twarning (0, \"-mrecip requires -fno-trapping-math or -ffast-math\");\n+      if (!flag_reciprocal_math)\n+\twarning (0, \"-mrecip requires -freciprocal-math or -ffast-math\");\n+      if (TARGET_FUSED_MADD && flag_finite_math_only && !flag_trapping_math\n+\t  && flag_reciprocal_math)\n+\t{\n+\t  if (RS6000_RECIP_HAVE_RE_P (SFmode)\n+\t      && (rs6000_recip_control & RECIP_SF_DIV) != 0)\n+\t    rs6000_recip_bits[SFmode] |= RS6000_RECIP_MASK_AUTO_RE;\n+\n+\t  if (RS6000_RECIP_HAVE_RE_P (DFmode)\n+\t      && (rs6000_recip_control & RECIP_DF_DIV) != 0)\n+\t    rs6000_recip_bits[DFmode] |= RS6000_RECIP_MASK_AUTO_RE;\n+\n+\t  if (RS6000_RECIP_HAVE_RE_P (V4SFmode)\n+\t      && (rs6000_recip_control & RECIP_V4SF_DIV) != 0)\n+\t    rs6000_recip_bits[V4SFmode] |= RS6000_RECIP_MASK_AUTO_RE;\n+\n+\t  if (RS6000_RECIP_HAVE_RE_P (V2DFmode)\n+\t      && (rs6000_recip_control & RECIP_V2DF_DIV) != 0)\n+\t    rs6000_recip_bits[V2DFmode] |= RS6000_RECIP_MASK_AUTO_RE;\n+\n+\t  if (RS6000_RECIP_HAVE_RSQRTE_P (SFmode)\n+\t      && (rs6000_recip_control & RECIP_SF_RSQRT) != 0)\n+\t    rs6000_recip_bits[SFmode] |= RS6000_RECIP_MASK_AUTO_RSQRTE;\n+\n+\t  if (RS6000_RECIP_HAVE_RSQRTE_P (DFmode)\n+\t      && (rs6000_recip_control & RECIP_DF_RSQRT) != 0)\n+\t    rs6000_recip_bits[DFmode] |= RS6000_RECIP_MASK_AUTO_RSQRTE;\n+\n+\t  if (RS6000_RECIP_HAVE_RSQRTE_P (V4SFmode)\n+\t      && (rs6000_recip_control & RECIP_V4SF_RSQRT) != 0)\n+\t    rs6000_recip_bits[V4SFmode] |= RS6000_RECIP_MASK_AUTO_RSQRTE;\n+\n+\t  if (RS6000_RECIP_HAVE_RSQRTE_P (V2DFmode)\n+\t      && (rs6000_recip_control & RECIP_V2DF_RSQRT) != 0)\n+\t    rs6000_recip_bits[V2DFmode] |= RS6000_RECIP_MASK_AUTO_RSQRTE;\n+\t}\n+    }\n+\n   if (TARGET_DEBUG_REG)\n     rs6000_debug_reg_global ();\n+\n+  if (TARGET_DEBUG_COST || TARGET_DEBUG_REG)\n+    fprintf (stderr,\n+\t     \"SImode variable mult cost       = %d\\n\"\n+\t     \"SImode constant mult cost       = %d\\n\"\n+\t     \"SImode short constant mult cost = %d\\n\"\n+\t     \"DImode multipliciation cost     = %d\\n\"\n+\t     \"SImode division cost            = %d\\n\"\n+\t     \"DImode division cost            = %d\\n\"\n+\t     \"Simple fp operation cost        = %d\\n\"\n+\t     \"DFmode multiplication cost      = %d\\n\"\n+\t     \"SFmode division cost            = %d\\n\"\n+\t     \"DFmode division cost            = %d\\n\"\n+\t     \"cache line size                 = %d\\n\"\n+\t     \"l1 cache size                   = %d\\n\"\n+\t     \"l2 cache size                   = %d\\n\"\n+\t     \"simultaneous prefetches         = %d\\n\"\n+\t     \"\\n\",\n+\t     rs6000_cost->mulsi,\n+\t     rs6000_cost->mulsi_const,\n+\t     rs6000_cost->mulsi_const9,\n+\t     rs6000_cost->muldi,\n+\t     rs6000_cost->divsi,\n+\t     rs6000_cost->divdi,\n+\t     rs6000_cost->fp,\n+\t     rs6000_cost->dmul,\n+\t     rs6000_cost->sdiv,\n+\t     rs6000_cost->ddiv,\n+\t     rs6000_cost->cache_line_size,\n+\t     rs6000_cost->l1_cache_size,\n+\t     rs6000_cost->l2_cache_size,\n+\t     rs6000_cost->simultaneous_prefetches);\n }\n \n #if TARGET_MACHO\n@@ -2271,15 +2451,16 @@ rs6000_override_options (const char *default_cpu)\n \t  | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND},\n  \t {\"power6\", PROCESSOR_POWER6,\n \t  POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n-\t  | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP},\n+\t  | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP\n+\t  | MASK_RECIP_PRECISION},\n \t {\"power6x\", PROCESSOR_POWER6,\n \t  POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n \t  | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP\n-\t  | MASK_MFPGPR},\n+\t  | MASK_MFPGPR | MASK_RECIP_PRECISION},\n \t {\"power7\", PROCESSOR_POWER7,\n \t  POWERPC_7400_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_MFCRF\n \t  | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP | MASK_POPCNTD\n-\t  | MASK_VSX},\t\t/* Don't add MASK_ISEL by default */\n+\t  | MASK_VSX| MASK_RECIP_PRECISION},\t/* Don't add MASK_ISEL by default */\n \t {\"powerpc\", PROCESSOR_POWERPC, POWERPC_BASE_MASK},\n \t {\"powerpc64\", PROCESSOR_POWERPC64,\n \t  POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64},\n@@ -2307,7 +2488,24 @@ rs6000_override_options (const char *default_cpu)\n \t\t     | MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_ALTIVEC\n \t\t     | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_MULHW\n \t\t     | MASK_DLMZB | MASK_CMPB | MASK_MFPGPR | MASK_DFP\n-\t\t     | MASK_POPCNTD | MASK_VSX | MASK_ISEL | MASK_NO_UPDATE)\n+\t\t     | MASK_POPCNTD | MASK_VSX | MASK_ISEL | MASK_NO_UPDATE\n+\t\t     | MASK_RECIP_PRECISION)\n+  };\n+\n+  /* Masks for instructions set at various powerpc ISAs.  */\n+  enum {\n+    ISA_2_1_MASKS = MASK_MFCRF,\n+    ISA_2_2_MASKS = (ISA_2_1_MASKS | MASK_POPCNTB | MASK_FPRND),\n+\n+    /* For ISA 2.05, do not add MFPGPR, since it isn't in ISA 2.06, and\n+       don't add ALTIVEC, since in general it isn't a win on power6.  */\n+    ISA_2_5_MASKS = (ISA_2_2_MASKS | MASK_CMPB | MASK_RECIP_PRECISION\n+\t\t     | MASK_DFP),\n+\n+    /* For ISA 2.06, don't add ISEL, since in general it isn't a win, but\n+       altivec is a win so enable it.  */\n+    ISA_2_6_MASKS = (ISA_2_5_MASKS | MASK_ALTIVEC | MASK_POPCNTD\n+\t\t     | MASK_VSX | MASK_RECIP_PRECISION)\n   };\n \n   /* Numerous experiment shows that IRA based loop pressure\n@@ -2449,10 +2647,17 @@ rs6000_override_options (const char *default_cpu)\n \t  warning (0, msg);\n \t  target_flags &= ~ MASK_VSX;\n \t}\n-      else if (TARGET_VSX && !TARGET_ALTIVEC)\n-\ttarget_flags |= MASK_ALTIVEC;\n     }\n \n+  /* For the newer switches (vsx, dfp, etc.) set some of the older options,\n+     unless the user explicitly used the -mno-<option> to disable the code.  */\n+  if (TARGET_VSX)\n+    target_flags |= (ISA_2_6_MASKS & (target_flags_explicit & ~ISA_2_6_MASKS));\n+  else if (TARGET_DFP)\n+    target_flags |= (ISA_2_5_MASKS & (target_flags_explicit & ~ISA_2_5_MASKS));\n+  else if (TARGET_ALTIVEC)\n+    target_flags |= (MASK_PPC_GFXOPT & (target_flags_explicit & ~MASK_PPC_GFXOPT));\n+\n   /* Set debug flags */\n   if (rs6000_debug_name)\n     {\n@@ -2875,6 +3080,52 @@ rs6000_override_options (const char *default_cpu)\n      the DERAT mispredict penalty.  */\n     TARGET_AVOID_XFORM = (rs6000_cpu == PROCESSOR_POWER6 && TARGET_CMPB);\n \n+  /* Set the -mrecip options.  */\n+  if (rs6000_recip_name)\n+    {\n+      char *p = ASTRDUP (rs6000_recip_name);\n+      char *q;\n+      unsigned int mask, i;\n+      bool invert;\n+\n+      while ((q = strtok (p, \",\")) != NULL)\n+\t{\n+\t  p = NULL;\n+\t  if (*q == '!')\n+\t    {\n+\t      invert = true;\n+\t      q++;\n+\t    }\n+\t  else\n+\t    invert = false;\n+\n+\t  if (!strcmp (q, \"default\"))\n+\t    mask = ((TARGET_RECIP_PRECISION)\n+\t\t    ? RECIP_HIGH_PRECISION : RECIP_LOW_PRECISION);\n+\t  else\n+\t    {\n+\t      for (i = 0; i < ARRAY_SIZE (recip_options); i++)\n+\t\tif (!strcmp (q, recip_options[i].string))\n+\t\t  {\n+\t\t    mask = recip_options[i].mask;\n+\t\t    break;\n+\t\t  }\n+\n+\t      if (i == ARRAY_SIZE (recip_options))\n+\t\t{\n+\t\t  error (\"Unknown option for -mrecip=%s\", q);\n+\t\t  invert = false;\n+\t\t  mask = 0;\n+\t\t}\n+\t    }\n+\n+\t  if (invert)\n+\t    rs6000_recip_control &= ~mask;\n+\t  else\n+\t    rs6000_recip_control |= mask;\n+\t}\n+    }\n+\n   rs6000_init_hard_regno_mode_ok ();\n }\n \n@@ -3191,124 +3442,162 @@ rs6000_builtin_vectorized_function (tree fndecl, tree type_out,\n {\n   enum machine_mode in_mode, out_mode;\n   int in_n, out_n;\n-  enum built_in_function fn = DECL_FUNCTION_CODE (fndecl);\n \n   if (TREE_CODE (type_out) != VECTOR_TYPE\n       || TREE_CODE (type_in) != VECTOR_TYPE\n-      || !TARGET_VECTORIZE_BUILTINS\n-      || DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_NORMAL)\n+      || !TARGET_VECTORIZE_BUILTINS)\n     return NULL_TREE;\n \n   out_mode = TYPE_MODE (TREE_TYPE (type_out));\n   out_n = TYPE_VECTOR_SUBPARTS (type_out);\n   in_mode = TYPE_MODE (TREE_TYPE (type_in));\n   in_n = TYPE_VECTOR_SUBPARTS (type_in);\n \n-  switch (fn)\n+  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n     {\n-    case BUILT_IN_COPYSIGN:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_CPSGNDP];\n-      break;\n-    case BUILT_IN_COPYSIGNF:\n-      if (out_mode != SFmode || out_n != 4\n-\t  || in_mode != SFmode || in_n != 4)\n-\tbreak;\n-      if (VECTOR_UNIT_VSX_P (V4SFmode))\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_CPSGNSP];\n-      if (VECTOR_UNIT_ALTIVEC_P (V4SFmode))\n-\treturn rs6000_builtin_decls[ALTIVEC_BUILTIN_COPYSIGN_V4SF];\n-      break;\n-    case BUILT_IN_SQRT:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVSQRTDP];\n-      break;\n-    case BUILT_IN_SQRTF:\n-      if (VECTOR_UNIT_VSX_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVSQRTSP];\n-      break;\n-    case BUILT_IN_CEIL:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRDPIP];\n-      break;\n-    case BUILT_IN_CEILF:\n-      if (out_mode != SFmode || out_n != 4\n-\t  || in_mode != SFmode || in_n != 4)\n-\tbreak;\n-      if (VECTOR_UNIT_VSX_P (V4SFmode))\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRSPIP];\n-      if (VECTOR_UNIT_ALTIVEC_P (V4SFmode))\n-\treturn rs6000_builtin_decls[ALTIVEC_BUILTIN_VRFIP];\n-      break;\n-    case BUILT_IN_FLOOR:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRDPIM];\n-      break;\n-    case BUILT_IN_FLOORF:\n-      if (out_mode != SFmode || out_n != 4\n-\t  || in_mode != SFmode || in_n != 4)\n-\tbreak;\n-      if (VECTOR_UNIT_VSX_P (V4SFmode))\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRSPIM];\n-      if (VECTOR_UNIT_ALTIVEC_P (V4SFmode))\n-\treturn rs6000_builtin_decls[ALTIVEC_BUILTIN_VRFIM];\n-      break;\n-    case BUILT_IN_TRUNC:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRDPIZ];\n-      break;\n-    case BUILT_IN_TRUNCF:\n-      if (out_mode != SFmode || out_n != 4\n-\t  || in_mode != SFmode || in_n != 4)\n-\tbreak;\n-      if (VECTOR_UNIT_VSX_P (V4SFmode))\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRSPIZ];\n-      if (VECTOR_UNIT_ALTIVEC_P (V4SFmode))\n-\treturn rs6000_builtin_decls[ALTIVEC_BUILTIN_VRFIZ];\n-      break;\n-    case BUILT_IN_NEARBYINT:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && flag_unsafe_math_optimizations\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRDPI];\n-      break;\n-    case BUILT_IN_NEARBYINTF:\n-      if (VECTOR_UNIT_VSX_P (V4SFmode)\n-\t  && flag_unsafe_math_optimizations\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRSPI];\n-      break;\n-    case BUILT_IN_RINT:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && !flag_trapping_math\n-          && out_mode == DFmode && out_n == 2\n-          && in_mode == DFmode && in_n == 2)\n-        return rs6000_builtin_decls[VSX_BUILTIN_XVRDPIC];\n-      break;\n-    case BUILT_IN_RINTF:\n-      if (VECTOR_UNIT_VSX_P (V4SFmode)\n-\t  && !flag_trapping_math\n-          && out_mode == SFmode && out_n == 4\n-          && in_mode == SFmode && in_n == 4)\n-        return rs6000_builtin_decls[VSX_BUILTIN_XVRSPIC];\n-      break;\n-    default:\n-      break;\n+      enum built_in_function fn = DECL_FUNCTION_CODE (fndecl);\n+      switch (fn)\n+\t{\n+\tcase BUILT_IN_COPYSIGN:\n+\t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n+\t      && out_mode == DFmode && out_n == 2\n+\t      && in_mode == DFmode && in_n == 2)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_CPSGNDP];\n+\t  break;\n+\tcase BUILT_IN_COPYSIGNF:\n+\t  if (out_mode != SFmode || out_n != 4\n+\t      || in_mode != SFmode || in_n != 4)\n+\t    break;\n+\t  if (VECTOR_UNIT_VSX_P (V4SFmode))\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_CPSGNSP];\n+\t  if (VECTOR_UNIT_ALTIVEC_P (V4SFmode))\n+\t    return rs6000_builtin_decls[ALTIVEC_BUILTIN_COPYSIGN_V4SF];\n+\t  break;\n+\tcase BUILT_IN_SQRT:\n+\t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n+\t      && out_mode == DFmode && out_n == 2\n+\t      && in_mode == DFmode && in_n == 2)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVSQRTDP];\n+\t  break;\n+\tcase BUILT_IN_SQRTF:\n+\t  if (VECTOR_UNIT_VSX_P (V4SFmode)\n+\t      && out_mode == SFmode && out_n == 4\n+\t      && in_mode == SFmode && in_n == 4)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVSQRTSP];\n+\t  break;\n+\tcase BUILT_IN_CEIL:\n+\t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n+\t      && out_mode == DFmode && out_n == 2\n+\t      && in_mode == DFmode && in_n == 2)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVRDPIP];\n+\t  break;\n+\tcase BUILT_IN_CEILF:\n+\t  if (out_mode != SFmode || out_n != 4\n+\t      || in_mode != SFmode || in_n != 4)\n+\t    break;\n+\t  if (VECTOR_UNIT_VSX_P (V4SFmode))\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVRSPIP];\n+\t  if (VECTOR_UNIT_ALTIVEC_P (V4SFmode))\n+\t    return rs6000_builtin_decls[ALTIVEC_BUILTIN_VRFIP];\n+\t  break;\n+\tcase BUILT_IN_FLOOR:\n+\t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n+\t      && out_mode == DFmode && out_n == 2\n+\t      && in_mode == DFmode && in_n == 2)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVRDPIM];\n+\t  break;\n+\tcase BUILT_IN_FLOORF:\n+\t  if (out_mode != SFmode || out_n != 4\n+\t      || in_mode != SFmode || in_n != 4)\n+\t    break;\n+\t  if (VECTOR_UNIT_VSX_P (V4SFmode))\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVRSPIM];\n+\t  if (VECTOR_UNIT_ALTIVEC_P (V4SFmode))\n+\t    return rs6000_builtin_decls[ALTIVEC_BUILTIN_VRFIM];\n+\t  break;\n+\tcase BUILT_IN_TRUNC:\n+\t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n+\t      && out_mode == DFmode && out_n == 2\n+\t      && in_mode == DFmode && in_n == 2)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVRDPIZ];\n+\t  break;\n+\tcase BUILT_IN_TRUNCF:\n+\t  if (out_mode != SFmode || out_n != 4\n+\t      || in_mode != SFmode || in_n != 4)\n+\t    break;\n+\t  if (VECTOR_UNIT_VSX_P (V4SFmode))\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVRSPIZ];\n+\t  if (VECTOR_UNIT_ALTIVEC_P (V4SFmode))\n+\t    return rs6000_builtin_decls[ALTIVEC_BUILTIN_VRFIZ];\n+\t  break;\n+\tcase BUILT_IN_NEARBYINT:\n+\t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n+\t      && flag_unsafe_math_optimizations\n+\t      && out_mode == DFmode && out_n == 2\n+\t      && in_mode == DFmode && in_n == 2)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVRDPI];\n+\t  break;\n+\tcase BUILT_IN_NEARBYINTF:\n+\t  if (VECTOR_UNIT_VSX_P (V4SFmode)\n+\t      && flag_unsafe_math_optimizations\n+\t      && out_mode == SFmode && out_n == 4\n+\t      && in_mode == SFmode && in_n == 4)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVRSPI];\n+\t  break;\n+\tcase BUILT_IN_RINT:\n+\t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n+\t      && !flag_trapping_math\n+\t      && out_mode == DFmode && out_n == 2\n+\t      && in_mode == DFmode && in_n == 2)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVRDPIC];\n+\t  break;\n+\tcase BUILT_IN_RINTF:\n+\t  if (VECTOR_UNIT_VSX_P (V4SFmode)\n+\t      && !flag_trapping_math\n+\t      && out_mode == SFmode && out_n == 4\n+\t      && in_mode == SFmode && in_n == 4)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_XVRSPIC];\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n     }\n+\n+  else if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n+    {\n+      enum rs6000_builtins fn\n+\t= (enum rs6000_builtins)DECL_FUNCTION_CODE (fndecl);\n+      switch (fn)\n+\t{\n+\tcase RS6000_BUILTIN_RSQRTF:\n+\t  if (VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\n+\t      && out_mode == SFmode && out_n == 4\n+\t      && in_mode == SFmode && in_n == 4)\n+\t    return rs6000_builtin_decls[ALTIVEC_BUILTIN_VRSQRTFP];\n+\t  break;\n+\tcase RS6000_BUILTIN_RSQRT:\n+\t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n+\t      && out_mode == DFmode && out_n == 2\n+\t      && in_mode == DFmode && in_n == 2)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_VEC_RSQRT_V2DF];\n+\t  break;\n+\tcase RS6000_BUILTIN_RECIPF:\n+\t  if (VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\n+\t      && out_mode == SFmode && out_n == 4\n+\t      && in_mode == SFmode && in_n == 4)\n+\t    return rs6000_builtin_decls[ALTIVEC_BUILTIN_VRECIPFP];\n+\t  break;\n+\tcase RS6000_BUILTIN_RECIP:\n+\t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n+\t      && out_mode == DFmode && out_n == 2\n+\t      && in_mode == DFmode && in_n == 2)\n+\t    return rs6000_builtin_decls[VSX_BUILTIN_RECIP_V2DF];\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n   return NULL_TREE;\n }\n \n@@ -3668,6 +3957,13 @@ rs6000_handle_option (size_t code, const char *arg, int value)\n         target_flags_explicit |= MASK_SOFT_FLOAT;\n         rs6000_single_float = rs6000_double_float = 0;\n       }\n+\n+    case OPT_mrecip:\n+      rs6000_recip_name = (value) ? \"default\" : \"none\";\n+      break;\n+\n+    case OPT_mrecip_:\n+      rs6000_recip_name = arg;\n       break;\n     }\n   return true;\n@@ -8865,6 +9161,7 @@ static struct builtin_description bdesc_2arg[] =\n   { MASK_ALTIVEC, CODE_FOR_altivec_vpkshus, \"__builtin_altivec_vpkshus\", ALTIVEC_BUILTIN_VPKSHUS },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vpkuwus, \"__builtin_altivec_vpkuwus\", ALTIVEC_BUILTIN_VPKUWUS },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vpkswus, \"__builtin_altivec_vpkswus\", ALTIVEC_BUILTIN_VPKSWUS },\n+  { MASK_ALTIVEC, CODE_FOR_recipv4sf3, \"__builtin_altivec_vrecipdivfp\", ALTIVEC_BUILTIN_VRECIPFP },\n   { MASK_ALTIVEC, CODE_FOR_vrotlv16qi3, \"__builtin_altivec_vrlb\", ALTIVEC_BUILTIN_VRLB },\n   { MASK_ALTIVEC, CODE_FOR_vrotlv8hi3, \"__builtin_altivec_vrlh\", ALTIVEC_BUILTIN_VRLH },\n   { MASK_ALTIVEC, CODE_FOR_vrotlv4si3, \"__builtin_altivec_vrlw\", ALTIVEC_BUILTIN_VRLW },\n@@ -8907,6 +9204,7 @@ static struct builtin_description bdesc_2arg[] =\n   { MASK_VSX, CODE_FOR_subv2df3, \"__builtin_vsx_xvsubdp\", VSX_BUILTIN_XVSUBDP },\n   { MASK_VSX, CODE_FOR_mulv2df3, \"__builtin_vsx_xvmuldp\", VSX_BUILTIN_XVMULDP },\n   { MASK_VSX, CODE_FOR_divv2df3, \"__builtin_vsx_xvdivdp\", VSX_BUILTIN_XVDIVDP },\n+  { MASK_VSX, CODE_FOR_recipv2df3, \"__builtin_vsx_xvrecipdivdp\", VSX_BUILTIN_RECIP_V2DF },\n   { MASK_VSX, CODE_FOR_sminv2df3, \"__builtin_vsx_xvmindp\", VSX_BUILTIN_XVMINDP },\n   { MASK_VSX, CODE_FOR_smaxv2df3, \"__builtin_vsx_xvmaxdp\", VSX_BUILTIN_XVMAXDP },\n   { MASK_VSX, CODE_FOR_vsx_tdivv2df3_fe, \"__builtin_vsx_xvtdivdp_fe\", VSX_BUILTIN_XVTDIVDP_FE },\n@@ -8919,6 +9217,7 @@ static struct builtin_description bdesc_2arg[] =\n   { MASK_VSX, CODE_FOR_subv4sf3, \"__builtin_vsx_xvsubsp\", VSX_BUILTIN_XVSUBSP },\n   { MASK_VSX, CODE_FOR_mulv4sf3, \"__builtin_vsx_xvmulsp\", VSX_BUILTIN_XVMULSP },\n   { MASK_VSX, CODE_FOR_divv4sf3, \"__builtin_vsx_xvdivsp\", VSX_BUILTIN_XVDIVSP },\n+  { MASK_VSX, CODE_FOR_recipv4sf3, \"__builtin_vsx_xvrecipdivsp\", VSX_BUILTIN_RECIP_V4SF },\n   { MASK_VSX, CODE_FOR_sminv4sf3, \"__builtin_vsx_xvminsp\", VSX_BUILTIN_XVMINSP },\n   { MASK_VSX, CODE_FOR_smaxv4sf3, \"__builtin_vsx_xvmaxsp\", VSX_BUILTIN_XVMAXSP },\n   { MASK_VSX, CODE_FOR_vsx_tdivv4sf3_fe, \"__builtin_vsx_xvtdivsp_fe\", VSX_BUILTIN_XVTDIVSP_FE },\n@@ -9035,6 +9334,7 @@ static struct builtin_description bdesc_2arg[] =\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_packsu\", ALTIVEC_BUILTIN_VEC_PACKSU },\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_vpkswus\", ALTIVEC_BUILTIN_VEC_VPKSWUS },\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_vpkshus\", ALTIVEC_BUILTIN_VEC_VPKSHUS },\n+  { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_recipdiv\", ALTIVEC_BUILTIN_VEC_RECIP },\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_rl\", ALTIVEC_BUILTIN_VEC_RL },\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_vrlw\", ALTIVEC_BUILTIN_VEC_VRLW },\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_vrlh\", ALTIVEC_BUILTIN_VEC_VRLH },\n@@ -9364,12 +9664,13 @@ static struct builtin_description bdesc_1arg[] =\n {\n   { MASK_ALTIVEC, CODE_FOR_altivec_vexptefp, \"__builtin_altivec_vexptefp\", ALTIVEC_BUILTIN_VEXPTEFP },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vlogefp, \"__builtin_altivec_vlogefp\", ALTIVEC_BUILTIN_VLOGEFP },\n-  { MASK_ALTIVEC, CODE_FOR_altivec_vrefp, \"__builtin_altivec_vrefp\", ALTIVEC_BUILTIN_VREFP },\n+  { MASK_ALTIVEC, CODE_FOR_rev4sf2, \"__builtin_altivec_vrefp\", ALTIVEC_BUILTIN_VREFP },\n   { MASK_ALTIVEC, CODE_FOR_vector_floorv4sf2, \"__builtin_altivec_vrfim\", ALTIVEC_BUILTIN_VRFIM },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vrfin, \"__builtin_altivec_vrfin\", ALTIVEC_BUILTIN_VRFIN },\n   { MASK_ALTIVEC, CODE_FOR_vector_ceilv4sf2, \"__builtin_altivec_vrfip\", ALTIVEC_BUILTIN_VRFIP },\n   { MASK_ALTIVEC, CODE_FOR_vector_btruncv4sf2, \"__builtin_altivec_vrfiz\", ALTIVEC_BUILTIN_VRFIZ },\n-  { MASK_ALTIVEC, CODE_FOR_altivec_vrsqrtefp, \"__builtin_altivec_vrsqrtefp\", ALTIVEC_BUILTIN_VRSQRTEFP },\n+  { MASK_ALTIVEC, CODE_FOR_rsqrtv4sf2, \"__builtin_altivec_vrsqrtfp\", ALTIVEC_BUILTIN_VRSQRTFP },\n+  { MASK_ALTIVEC, CODE_FOR_rsqrtev4sf2, \"__builtin_altivec_vrsqrtefp\", ALTIVEC_BUILTIN_VRSQRTEFP },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vspltisb, \"__builtin_altivec_vspltisb\", ALTIVEC_BUILTIN_VSPLTISB },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vspltish, \"__builtin_altivec_vspltish\", ALTIVEC_BUILTIN_VSPLTISH },\n   { MASK_ALTIVEC, CODE_FOR_altivec_vspltisw, \"__builtin_altivec_vspltisw\", ALTIVEC_BUILTIN_VSPLTISW },\n@@ -9382,14 +9683,16 @@ static struct builtin_description bdesc_1arg[] =\n \n   { MASK_VSX, CODE_FOR_negv2df2, \"__builtin_vsx_xvnegdp\", VSX_BUILTIN_XVNEGDP },\n   { MASK_VSX, CODE_FOR_sqrtv2df2, \"__builtin_vsx_xvsqrtdp\", VSX_BUILTIN_XVSQRTDP },\n-  { MASK_VSX, CODE_FOR_vsx_rsqrtev2df2, \"__builtin_vsx_xvrsqrtedp\", VSX_BUILTIN_XVRSQRTEDP },\n+  { MASK_VSX, CODE_FOR_rsqrtv2df2, \"__builtin_vsx_xvrsqrtdp\", VSX_BUILTIN_VEC_RSQRT_V2DF },\n+  { MASK_VSX, CODE_FOR_rsqrtev2df2, \"__builtin_vsx_xvrsqrtedp\", VSX_BUILTIN_XVRSQRTEDP },\n   { MASK_VSX, CODE_FOR_vsx_tsqrtv2df2_fe, \"__builtin_vsx_xvtsqrtdp_fe\", VSX_BUILTIN_XVTSQRTDP_FE },\n   { MASK_VSX, CODE_FOR_vsx_tsqrtv2df2_fg, \"__builtin_vsx_xvtsqrtdp_fg\", VSX_BUILTIN_XVTSQRTDP_FG },\n   { MASK_VSX, CODE_FOR_vsx_frev2df2, \"__builtin_vsx_xvredp\", VSX_BUILTIN_XVREDP },\n \n   { MASK_VSX, CODE_FOR_negv4sf2, \"__builtin_vsx_xvnegsp\", VSX_BUILTIN_XVNEGSP },\n   { MASK_VSX, CODE_FOR_sqrtv4sf2, \"__builtin_vsx_xvsqrtsp\", VSX_BUILTIN_XVSQRTSP },\n-  { MASK_VSX, CODE_FOR_vsx_rsqrtev4sf2, \"__builtin_vsx_xvrsqrtesp\", VSX_BUILTIN_XVRSQRTESP },\n+  { MASK_VSX, CODE_FOR_rsqrtv4sf2, \"__builtin_vsx_xvrsqrtsp\", VSX_BUILTIN_VEC_RSQRT_V4SF },\n+  { MASK_VSX, CODE_FOR_rsqrtev4sf2, \"__builtin_vsx_xvrsqrtesp\", VSX_BUILTIN_XVRSQRTESP },\n   { MASK_VSX, CODE_FOR_vsx_tsqrtv4sf2_fe, \"__builtin_vsx_xvtsqrtsp_fe\", VSX_BUILTIN_XVTSQRTSP_FE },\n   { MASK_VSX, CODE_FOR_vsx_tsqrtv4sf2_fg, \"__builtin_vsx_xvtsqrtsp_fg\", VSX_BUILTIN_XVTSQRTSP_FG },\n   { MASK_VSX, CODE_FOR_vsx_frev4sf2, \"__builtin_vsx_xvresp\", VSX_BUILTIN_XVRESP },\n@@ -9448,6 +9751,7 @@ static struct builtin_description bdesc_1arg[] =\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_mtvscr\", ALTIVEC_BUILTIN_VEC_MTVSCR },\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_re\", ALTIVEC_BUILTIN_VEC_RE },\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_round\", ALTIVEC_BUILTIN_VEC_ROUND },\n+  { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_rsqrt\", ALTIVEC_BUILTIN_VEC_RSQRT },\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_rsqrte\", ALTIVEC_BUILTIN_VEC_RSQRTE },\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_trunc\", ALTIVEC_BUILTIN_VEC_TRUNC },\n   { MASK_ALTIVEC, CODE_FOR_nothing, \"__builtin_vec_unpackh\", ALTIVEC_BUILTIN_VEC_UNPACKH },\n@@ -10963,73 +11267,83 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   rtx ret;\n   bool success;\n \n-  if (fcode == RS6000_BUILTIN_RECIP)\n+  switch (fcode)\n+    {\n+    case RS6000_BUILTIN_RECIP:\n       return rs6000_expand_binop_builtin (CODE_FOR_recipdf3, exp, target);\n \n-  if (fcode == RS6000_BUILTIN_RECIPF)\n+    case RS6000_BUILTIN_RECIPF:\n       return rs6000_expand_binop_builtin (CODE_FOR_recipsf3, exp, target);\n \n-  if (fcode == RS6000_BUILTIN_RSQRTF)\n+    case RS6000_BUILTIN_RSQRTF:\n       return rs6000_expand_unop_builtin (CODE_FOR_rsqrtsf2, exp, target);\n \n-  if (fcode == RS6000_BUILTIN_BSWAP_HI)\n-    return rs6000_expand_unop_builtin (CODE_FOR_bswaphi2, exp, target);\n-\n-  if (fcode == POWER7_BUILTIN_BPERMD)\n-    return rs6000_expand_binop_builtin (((TARGET_64BIT)\n-\t\t\t\t\t ? CODE_FOR_bpermd_di\n-\t\t\t\t\t : CODE_FOR_bpermd_si), exp, target);\n+    case RS6000_BUILTIN_RSQRT:\n+      return rs6000_expand_unop_builtin (CODE_FOR_rsqrtdf2, exp, target);\n \n-  if (fcode == ALTIVEC_BUILTIN_MASK_FOR_LOAD\n-      || fcode == ALTIVEC_BUILTIN_MASK_FOR_STORE)\n-    {\n-      int icode = (int) CODE_FOR_altivec_lvsr;\n-      enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-      enum machine_mode mode = insn_data[icode].operand[1].mode;\n-      tree arg;\n-      rtx op, addr, pat;\n+    case RS6000_BUILTIN_BSWAP_HI:\n+      return rs6000_expand_unop_builtin (CODE_FOR_bswaphi2, exp, target);\n \n-      gcc_assert (TARGET_ALTIVEC);\n+    case POWER7_BUILTIN_BPERMD:\n+      return rs6000_expand_binop_builtin (((TARGET_64BIT)\n+\t\t\t\t\t   ? CODE_FOR_bpermd_di\n+\t\t\t\t\t   : CODE_FOR_bpermd_si), exp, target);\n \n-      arg = CALL_EXPR_ARG (exp, 0);\n-      gcc_assert (TREE_CODE (TREE_TYPE (arg)) == POINTER_TYPE);\n-      op = expand_expr (arg, NULL_RTX, Pmode, EXPAND_NORMAL);\n-      addr = memory_address (mode, op);\n-      if (fcode == ALTIVEC_BUILTIN_MASK_FOR_STORE)\n-\top = addr;\n-      else\n-\t{\n-\t  /* For the load case need to negate the address.  */\n-\t  op = gen_reg_rtx (GET_MODE (addr));\n-\t  emit_insn (gen_rtx_SET (VOIDmode, op,\n-\t\t\t gen_rtx_NEG (GET_MODE (addr), addr)));\n-\t}\n-      op = gen_rtx_MEM (mode, op);\n+    case ALTIVEC_BUILTIN_MASK_FOR_LOAD:\n+    case ALTIVEC_BUILTIN_MASK_FOR_STORE:\n+      {\n+\tint icode = (int) CODE_FOR_altivec_lvsr;\n+\tenum machine_mode tmode = insn_data[icode].operand[0].mode;\n+\tenum machine_mode mode = insn_data[icode].operand[1].mode;\n+\ttree arg;\n+\trtx op, addr, pat;\n+\n+\tgcc_assert (TARGET_ALTIVEC);\n+\n+\targ = CALL_EXPR_ARG (exp, 0);\n+\tgcc_assert (TREE_CODE (TREE_TYPE (arg)) == POINTER_TYPE);\n+\top = expand_expr (arg, NULL_RTX, Pmode, EXPAND_NORMAL);\n+\taddr = memory_address (mode, op);\n+\tif (fcode == ALTIVEC_BUILTIN_MASK_FOR_STORE)\n+\t  op = addr;\n+\telse\n+\t  {\n+\t    /* For the load case need to negate the address.  */\n+\t    op = gen_reg_rtx (GET_MODE (addr));\n+\t    emit_insn (gen_rtx_SET (VOIDmode, op,\n+\t\t\t\t    gen_rtx_NEG (GET_MODE (addr), addr)));\n+\t  }\n+\top = gen_rtx_MEM (mode, op);\n \n-      if (target == 0\n-\t  || GET_MODE (target) != tmode\n-\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n-\ttarget = gen_reg_rtx (tmode);\n+\tif (target == 0\n+\t    || GET_MODE (target) != tmode\n+\t    || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\t  target = gen_reg_rtx (tmode);\n \n-      /*pat = gen_altivec_lvsr (target, op);*/\n-      pat = GEN_FCN (icode) (target, op);\n-      if (!pat)\n-\treturn 0;\n-      emit_insn (pat);\n+\t/*pat = gen_altivec_lvsr (target, op);*/\n+\tpat = GEN_FCN (icode) (target, op);\n+\tif (!pat)\n+\t  return 0;\n+\temit_insn (pat);\n \n-      return target;\n-    }\n+\treturn target;\n+      }\n \n+    case ALTIVEC_BUILTIN_VCFUX:\n+    case ALTIVEC_BUILTIN_VCFSX:\n+    case ALTIVEC_BUILTIN_VCTUXS:\n+    case ALTIVEC_BUILTIN_VCTSXS:\n   /* FIXME: There's got to be a nicer way to handle this case than\n      constructing a new CALL_EXPR.  */\n-  if (fcode == ALTIVEC_BUILTIN_VCFUX\n-      || fcode == ALTIVEC_BUILTIN_VCFSX\n-      || fcode == ALTIVEC_BUILTIN_VCTUXS\n-      || fcode == ALTIVEC_BUILTIN_VCTSXS)\n-    {\n       if (call_expr_nargs (exp) == 1)\n-\texp = build_call_nary (TREE_TYPE (exp), CALL_EXPR_FN (exp),\n-\t\t\t       2, CALL_EXPR_ARG (exp, 0), integer_zero_node);\n+\t{\n+\t  exp = build_call_nary (TREE_TYPE (exp), CALL_EXPR_FN (exp),\n+\t\t\t\t 2, CALL_EXPR_ARG (exp, 0), integer_zero_node);\n+\t}\n+      break;\n+\n+    default:\n+      break;\n     }\n \n   if (TARGET_ALTIVEC)\n@@ -11081,6 +11395,7 @@ static void\n rs6000_init_builtins (void)\n {\n   tree tdecl;\n+  tree ftype;\n \n   V2SI_type_node = build_vector_type (intSI_type_node, 2);\n   V2SF_type_node = build_vector_type (float_type_node, 2);\n@@ -11270,29 +11585,38 @@ rs6000_init_builtins (void)\n     altivec_init_builtins ();\n   if (TARGET_ALTIVEC || TARGET_SPE || TARGET_PAIRED_FLOAT || TARGET_VSX)\n     rs6000_common_init_builtins ();\n-  if (TARGET_PPC_GFXOPT)\n+  if (TARGET_FRE)\n+    {\n+      ftype = builtin_function_type (DFmode, DFmode, DFmode, VOIDmode,\n+\t\t\t\t     RS6000_BUILTIN_RECIP,\n+\t\t\t\t     \"__builtin_recipdiv\");\n+      def_builtin (MASK_POPCNTB, \"__builtin_recipdiv\", ftype,\n+\t\t   RS6000_BUILTIN_RECIP);\n+    }\n+  if (TARGET_FRES)\n     {\n-      tree ftype = builtin_function_type (SFmode, SFmode, SFmode, VOIDmode,\n-\t\t\t\t\t  RS6000_BUILTIN_RECIPF,\n-\t\t\t\t\t  \"__builtin_recipdivf\");\n+      ftype = builtin_function_type (SFmode, SFmode, SFmode, VOIDmode,\n+\t\t\t\t     RS6000_BUILTIN_RECIPF,\n+\t\t\t\t     \"__builtin_recipdivf\");\n       def_builtin (MASK_PPC_GFXOPT, \"__builtin_recipdivf\", ftype,\n \t\t   RS6000_BUILTIN_RECIPF);\n-\n+    }\n+  if (TARGET_FRSQRTE)\n+    {\n+      ftype = builtin_function_type (DFmode, DFmode, VOIDmode, VOIDmode,\n+\t\t\t\t     RS6000_BUILTIN_RSQRT,\n+\t\t\t\t     \"__builtin_rsqrt\");\n+      def_builtin (MASK_PPC_GFXOPT, \"__builtin_rsqrt\", ftype,\n+\t\t   RS6000_BUILTIN_RSQRT);\n+    }\n+  if (TARGET_FRSQRTES)\n+    {\n       ftype = builtin_function_type (SFmode, SFmode, VOIDmode, VOIDmode,\n \t\t\t\t     RS6000_BUILTIN_RSQRTF,\n \t\t\t\t     \"__builtin_rsqrtf\");\n       def_builtin (MASK_PPC_GFXOPT, \"__builtin_rsqrtf\", ftype,\n \t\t   RS6000_BUILTIN_RSQRTF);\n     }\n-  if (TARGET_POPCNTB)\n-    {\n-      tree ftype = builtin_function_type (DFmode, DFmode, DFmode, VOIDmode,\n-\t\t\t\t\t  RS6000_BUILTIN_RECIP,\n-\t\t\t\t\t  \"__builtin_recipdiv\");\n-      def_builtin (MASK_POPCNTB, \"__builtin_recipdiv\", ftype,\n-\t\t   RS6000_BUILTIN_RECIP);\n-\n-    }\n   if (TARGET_POPCNTD)\n     {\n       enum machine_mode mode = (TARGET_64BIT) ? DImode : SImode;\n@@ -13800,30 +14124,16 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n   if (GET_MODE_CLASS (mode) == MODE_INT && rclass == NON_SPECIAL_REGS)\n     return GENERAL_REGS;\n \n-  /* For VSX, prefer the traditional registers for DF if the address is of the\n-     form reg+offset because we can use the non-VSX loads.  Prefer the Altivec\n-     registers if Altivec is handling the vector operations (i.e. V16QI, V8HI,\n-     and V4SI).  */\n-  if (rclass == VSX_REGS && VECTOR_MEM_VSX_P (mode))\n+  /* For VSX, prefer the traditional registers for 64-bit values because we can\n+     use the non-VSX loads.  Prefer the Altivec registers if Altivec is\n+     handling the vector operations (i.e. V16QI, V8HI, and V4SI), or if we\n+     prefer Altivec loads..  */\n+  if (rclass == VSX_REGS)\n     {\n-      if (mode == DFmode && GET_CODE (x) == MEM)\n-\t{\n-\t  rtx addr = XEXP (x, 0);\n-\n-\t  if (legitimate_indirect_address_p (addr, false))\t/* reg */\n-\t    return VSX_REGS;\n-\n-\t  if (legitimate_indexed_address_p (addr, false))\t/* reg+reg */\n-\t    return VSX_REGS;\n+      if (GET_MODE_SIZE (mode) <= 8)\n+\treturn FLOAT_REGS;\n \n-\t  if (GET_CODE (addr) == PRE_MODIFY\n-\t      && legitimate_indexed_address_p (XEXP (addr, 0), false))\n-\t    return VSX_REGS;\n-\n-\t  return FLOAT_REGS;\n-\t}\n-\n-      if (VECTOR_UNIT_ALTIVEC_P (mode))\n+      if (VECTOR_UNIT_ALTIVEC_P (mode) || VECTOR_MEM_ALTIVEC_P (mode))\n \treturn ALTIVEC_REGS;\n \n       return rclass;\n@@ -25110,210 +25420,342 @@ static tree\n rs6000_builtin_reciprocal (unsigned int fn, bool md_fn,\n \t\t\t   bool sqrt ATTRIBUTE_UNUSED)\n {\n-  if (! (TARGET_RECIP && TARGET_PPC_GFXOPT && !optimize_size\n-\t && flag_finite_math_only && !flag_trapping_math\n-\t && flag_unsafe_math_optimizations))\n+  if (optimize_insn_for_size_p ())\n     return NULL_TREE;\n \n   if (md_fn)\n-    return NULL_TREE;\n+    switch (fn)\n+      {\n+      case VSX_BUILTIN_XVSQRTDP:\n+\tif (!RS6000_RECIP_AUTO_RSQRTE_P (V2DFmode))\n+\t  return NULL_TREE;\n+\n+\treturn rs6000_builtin_decls[VSX_BUILTIN_VEC_RSQRT_V2DF];\n+\n+      case VSX_BUILTIN_XVSQRTSP:\n+\tif (!RS6000_RECIP_AUTO_RSQRTE_P (V4SFmode))\n+\t  return NULL_TREE;\n+\n+\treturn rs6000_builtin_decls[VSX_BUILTIN_VEC_RSQRT_V4SF];\n+\n+      default:\n+\treturn NULL_TREE;\n+      }\n+\n   else\n     switch (fn)\n       {\n+      case BUILT_IN_SQRT:\n+\tif (!RS6000_RECIP_AUTO_RSQRTE_P (DFmode))\n+\t  return NULL_TREE;\n+\n+\treturn rs6000_builtin_decls[RS6000_BUILTIN_RSQRT];\n+\n       case BUILT_IN_SQRTF:\n+\tif (!RS6000_RECIP_AUTO_RSQRTE_P (SFmode))\n+\t  return NULL_TREE;\n+\n \treturn rs6000_builtin_decls[RS6000_BUILTIN_RSQRTF];\n \n       default:\n \treturn NULL_TREE;\n       }\n }\n \n-/* Newton-Raphson approximation of single-precision floating point divide n/d.\n-   Assumes no trapping math and finite arguments.  */\n+/* Load up a constant.  If the mode is a vector mode, splat the value across\n+   all of the vector elements.  */\n \n-void\n-rs6000_emit_swdivsf (rtx dst, rtx n, rtx d)\n+static rtx\n+rs6000_load_constant_and_splat (enum machine_mode mode, REAL_VALUE_TYPE dconst)\n+{\n+  rtx reg;\n+\n+  if (mode == SFmode || mode == DFmode)\n+    {\n+      rtx d = CONST_DOUBLE_FROM_REAL_VALUE (dconst, mode);\n+      reg = force_reg (mode, d);\n+    }\n+  else if (mode == V4SFmode)\n+    {\n+      rtx d = CONST_DOUBLE_FROM_REAL_VALUE (dconst, SFmode);\n+      rtvec v = gen_rtvec (4, d, d, d, d);\n+      reg = gen_reg_rtx (mode);\n+      rs6000_expand_vector_init (reg, gen_rtx_PARALLEL (mode, v));\n+    }\n+  else if (mode == V2DFmode)\n+    {\n+      rtx d = CONST_DOUBLE_FROM_REAL_VALUE (dconst, DFmode);\n+      rtvec v = gen_rtvec (2, d, d);\n+      reg = gen_reg_rtx (mode);\n+      rs6000_expand_vector_init (reg, gen_rtx_PARALLEL (mode, v));\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  return reg;\n+}\n+\n+/* Generate a FMADD instruction:\n+\tdst = (m1 * m2) + a\n+\n+   generating different RTL based on the fused multiply/add switch.  */\n+\n+static void\n+rs6000_emit_madd (rtx dst, rtx m1, rtx m2, rtx a)\n+{\n+  enum machine_mode mode = GET_MODE (dst);\n+\n+  if (!TARGET_FUSED_MADD)\n+    {\n+      /* For the simple ops, use the generator function, rather than assuming\n+\t that the RTL is standard.  */\n+      enum insn_code mcode = optab_handler (smul_optab, mode)->insn_code;\n+      enum insn_code acode = optab_handler (add_optab, mode)->insn_code;\n+      gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (mcode);\n+      gen_2arg_fn_t gen_add = (gen_2arg_fn_t) GEN_FCN (acode);\n+      rtx mreg = gen_reg_rtx (mode);\n+\n+      gcc_assert (mcode != CODE_FOR_nothing && acode != CODE_FOR_nothing);\n+      emit_insn (gen_mul (mreg, m1, m2));\n+      emit_insn (gen_add (dst, mreg, a));\n+    }\n+\n+  else\n+    emit_insn (gen_rtx_SET (VOIDmode, dst,\n+\t\t\t    gen_rtx_PLUS (mode,\n+\t\t\t\t\t  gen_rtx_MULT (mode, m1, m2),\n+\t\t\t\t\t  a)));\n+}\n+\n+/* Generate a FMSUB instruction:\n+\tdst = (m1 * m2) - a\n+\n+   generating different RTL based on the fused multiply/add switch.  */\n+\n+static void\n+rs6000_emit_msub (rtx dst, rtx m1, rtx m2, rtx a)\n+{\n+  enum machine_mode mode = GET_MODE (dst);\n+\n+  if (!TARGET_FUSED_MADD\n+      || (mode == V4SFmode && VECTOR_UNIT_ALTIVEC_P (V4SFmode)))\n+    {\n+      /* For the simple ops, use the generator function, rather than assuming\n+\t that the RTL is standard.  */\n+      enum insn_code mcode = optab_handler (smul_optab, mode)->insn_code;\n+      enum insn_code scode = optab_handler (add_optab, mode)->insn_code;\n+      gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (mcode);\n+      gen_2arg_fn_t gen_sub = (gen_2arg_fn_t) GEN_FCN (scode);\n+      rtx mreg = gen_reg_rtx (mode);\n+\n+      gcc_assert (mcode != CODE_FOR_nothing && scode != CODE_FOR_nothing);\n+      emit_insn (gen_mul (mreg, m1, m2));\n+      emit_insn (gen_sub (dst, mreg, a));\n+    }\n+\n+  else\n+    emit_insn (gen_rtx_SET (VOIDmode, dst,\n+\t\t\t    gen_rtx_MINUS (mode,\n+\t\t\t\t\t   gen_rtx_MULT (mode, m1, m2),\n+\t\t\t\t\t   a)));\n+}\n+\n+/* Generate a FNMSUB instruction:\n+\tdst = - ((m1 * m2) - a)\n+\n+   Which is equivalent to (except in the prescence of -0.0):\n+\tdst = a - (m1 * m2)\n+\n+   generating different RTL based on the fast-math and fused multiply/add\n+   switches.  */\n+\n+static void\n+rs6000_emit_nmsub (rtx dst, rtx m1, rtx m2, rtx a)\n {\n-  rtx x0, e0, e1, y1, u0, v0, one;\n+  enum machine_mode mode = GET_MODE (dst);\n+\n+  if (!TARGET_FUSED_MADD)\n+    {\n+      /* For the simple ops, use the generator function, rather than assuming\n+\t that the RTL is standard.  */\n+      enum insn_code mcode = optab_handler (smul_optab, mode)->insn_code;\n+      enum insn_code scode = optab_handler (sub_optab, mode)->insn_code;\n+      gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (mcode);\n+      gen_2arg_fn_t gen_sub = (gen_2arg_fn_t) GEN_FCN (scode);\n+      rtx mreg = gen_reg_rtx (mode);\n \n-  x0 = gen_reg_rtx (SFmode);\n-  e0 = gen_reg_rtx (SFmode);\n-  e1 = gen_reg_rtx (SFmode);\n-  y1 = gen_reg_rtx (SFmode);\n-  u0 = gen_reg_rtx (SFmode);\n-  v0 = gen_reg_rtx (SFmode);\n-  one = force_reg (SFmode, CONST_DOUBLE_FROM_REAL_VALUE (dconst1, SFmode));\n+      gcc_assert (mcode != CODE_FOR_nothing && scode != CODE_FOR_nothing);\n+      emit_insn (gen_mul (mreg, m1, m2));\n+      emit_insn (gen_sub (dst, a, mreg));\n+    }\n+\n+  else\n+    {\n+      rtx m = gen_rtx_MULT (mode, m1, m2);\n+\n+      if (!HONOR_SIGNED_ZEROS (mode))\n+\temit_insn (gen_rtx_SET (VOIDmode, dst, gen_rtx_MINUS (mode, a, m)));\n+\n+      else\n+\temit_insn (gen_rtx_SET (VOIDmode, dst,\n+\t\t\t\tgen_rtx_NEG (mode,\n+\t\t\t\t\t     gen_rtx_MINUS (mode, m, a))));\n+    }\n+}\n+\n+/* Newton-Raphson approximation of floating point divide with just 2 passes\n+   (either single precision floating point, or newer machines with higher\n+   accuracy estimates).  Support both scalar and vector divide.  Assumes no\n+   trapping math and finite arguments.  */\n+\n+static void\n+rs6000_emit_swdiv_high_precision (rtx dst, rtx n, rtx d)\n+{\n+  enum machine_mode mode = GET_MODE (dst);\n+  rtx x0, e0, e1, y1, u0, v0;\n+  enum insn_code code = optab_handler (smul_optab, mode)->insn_code;\n+  gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (code);\n+  rtx one = rs6000_load_constant_and_splat (mode, dconst1);\n+\n+  gcc_assert (code != CODE_FOR_nothing);\n \n   /* x0 = 1./d estimate */\n+  x0 = gen_reg_rtx (mode);\n   emit_insn (gen_rtx_SET (VOIDmode, x0,\n-\t\t\t  gen_rtx_UNSPEC (SFmode, gen_rtvec (1, d),\n+\t\t\t  gen_rtx_UNSPEC (mode, gen_rtvec (1, d),\n \t\t\t\t\t  UNSPEC_FRES)));\n-  /* e0 = 1. - d * x0 */\n-  emit_insn (gen_rtx_SET (VOIDmode, e0,\n-\t\t\t  gen_rtx_MINUS (SFmode, one,\n-\t\t\t\t\t gen_rtx_MULT (SFmode, d, x0))));\n-  /* e1 = e0 + e0 * e0 */\n-  emit_insn (gen_rtx_SET (VOIDmode, e1,\n-\t\t\t  gen_rtx_PLUS (SFmode,\n-\t\t\t\t\tgen_rtx_MULT (SFmode, e0, e0), e0)));\n-  /* y1 = x0 + e1 * x0 */\n-  emit_insn (gen_rtx_SET (VOIDmode, y1,\n-\t\t\t  gen_rtx_PLUS (SFmode,\n-\t\t\t\t\tgen_rtx_MULT (SFmode, e1, x0), x0)));\n-  /* u0 = n * y1 */\n-  emit_insn (gen_rtx_SET (VOIDmode, u0,\n-\t\t\t  gen_rtx_MULT (SFmode, n, y1)));\n-  /* v0 = n - d * u0 */\n-  emit_insn (gen_rtx_SET (VOIDmode, v0,\n-\t\t\t  gen_rtx_MINUS (SFmode, n,\n-\t\t\t\t\t gen_rtx_MULT (SFmode, d, u0))));\n-  /* dst = u0 + v0 * y1 */\n-  emit_insn (gen_rtx_SET (VOIDmode, dst,\n-\t\t\t  gen_rtx_PLUS (SFmode,\n-\t\t\t\t\tgen_rtx_MULT (SFmode, v0, y1), u0)));\n-}\n-\n-/* Newton-Raphson approximation of double-precision floating point divide n/d.\n-   Assumes no trapping math and finite arguments.  */\n \n-void\n-rs6000_emit_swdivdf (rtx dst, rtx n, rtx d)\n+  e0 = gen_reg_rtx (mode);\n+  rs6000_emit_nmsub (e0, d, x0, one);\t\t/* e0 = 1. - (d * x0) */\n+\n+  e1 = gen_reg_rtx (mode);\n+  rs6000_emit_madd (e1, e0, e0, e0);\t\t/* e1 = (e0 * e0) + e0 */\n+\n+  y1 = gen_reg_rtx (mode);\n+  rs6000_emit_madd (y1, e1, x0, x0);\t\t/* y1 = (e1 * x0) + x0 */\n+\n+  u0 = gen_reg_rtx (mode);\n+  emit_insn (gen_mul (u0, n, y1));\t\t/* u0 = n * y1 */\n+\n+  v0 = gen_reg_rtx (mode);\n+  rs6000_emit_nmsub (v0, d, u0, n);\t\t/* v0 = n - (d * u0) */\n+\n+  rs6000_emit_madd (dst, v0, y1, u0);\t\t/* dst = (v0 * y1) + u0 */\n+}\n+\n+/* Newton-Raphson approximation of floating point divide that has a low\n+   precision estimate.  Assumes no trapping math and finite arguments.  */\n+\n+static void\n+rs6000_emit_swdiv_low_precision (rtx dst, rtx n, rtx d)\n {\n+  enum machine_mode mode = GET_MODE (dst);\n   rtx x0, e0, e1, e2, y1, y2, y3, u0, v0, one;\n+  enum insn_code code = optab_handler (smul_optab, mode)->insn_code;\n+  gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (code);\n \n-  x0 = gen_reg_rtx (DFmode);\n-  e0 = gen_reg_rtx (DFmode);\n-  e1 = gen_reg_rtx (DFmode);\n-  e2 = gen_reg_rtx (DFmode);\n-  y1 = gen_reg_rtx (DFmode);\n-  y2 = gen_reg_rtx (DFmode);\n-  y3 = gen_reg_rtx (DFmode);\n-  u0 = gen_reg_rtx (DFmode);\n-  v0 = gen_reg_rtx (DFmode);\n-  one = force_reg (DFmode, CONST_DOUBLE_FROM_REAL_VALUE (dconst1, DFmode));\n+  gcc_assert (code != CODE_FOR_nothing);\n+\n+  one = rs6000_load_constant_and_splat (mode, dconst1);\n \n   /* x0 = 1./d estimate */\n+  x0 = gen_reg_rtx (mode);\n   emit_insn (gen_rtx_SET (VOIDmode, x0,\n-\t\t\t  gen_rtx_UNSPEC (DFmode, gen_rtvec (1, d),\n+\t\t\t  gen_rtx_UNSPEC (mode, gen_rtvec (1, d),\n \t\t\t\t\t  UNSPEC_FRES)));\n-  /* e0 = 1. - d * x0 */\n-  emit_insn (gen_rtx_SET (VOIDmode, e0,\n-\t\t\t  gen_rtx_MINUS (DFmode, one,\n-\t\t\t\t\t gen_rtx_MULT (SFmode, d, x0))));\n-  /* y1 = x0 + e0 * x0 */\n-  emit_insn (gen_rtx_SET (VOIDmode, y1,\n-\t\t\t  gen_rtx_PLUS (DFmode,\n-\t\t\t\t\tgen_rtx_MULT (DFmode, e0, x0), x0)));\n-  /* e1 = e0 * e0 */\n-  emit_insn (gen_rtx_SET (VOIDmode, e1,\n-\t\t\t  gen_rtx_MULT (DFmode, e0, e0)));\n-  /* y2 = y1 + e1 * y1 */\n-  emit_insn (gen_rtx_SET (VOIDmode, y2,\n-\t\t\t  gen_rtx_PLUS (DFmode,\n-\t\t\t\t\tgen_rtx_MULT (DFmode, e1, y1), y1)));\n-  /* e2 = e1 * e1 */\n-  emit_insn (gen_rtx_SET (VOIDmode, e2,\n-\t\t\t  gen_rtx_MULT (DFmode, e1, e1)));\n-  /* y3 = y2 + e2 * y2 */\n-  emit_insn (gen_rtx_SET (VOIDmode, y3,\n-\t\t\t  gen_rtx_PLUS (DFmode,\n-\t\t\t\t\tgen_rtx_MULT (DFmode, e2, y2), y2)));\n-  /* u0 = n * y3 */\n-  emit_insn (gen_rtx_SET (VOIDmode, u0,\n-\t\t\t  gen_rtx_MULT (DFmode, n, y3)));\n-  /* v0 = n - d * u0 */\n-  emit_insn (gen_rtx_SET (VOIDmode, v0,\n-\t\t\t  gen_rtx_MINUS (DFmode, n,\n-\t\t\t\t\t gen_rtx_MULT (DFmode, d, u0))));\n-  /* dst = u0 + v0 * y3 */\n-  emit_insn (gen_rtx_SET (VOIDmode, dst,\n-\t\t\t  gen_rtx_PLUS (DFmode,\n-\t\t\t\t\tgen_rtx_MULT (DFmode, v0, y3), u0)));\n-}\n-\n-\n-/* Newton-Raphson approximation of single-precision floating point rsqrt.\n-   Assumes no trapping math and finite arguments.  */\n+\n+  e0 = gen_reg_rtx (mode);\n+  rs6000_emit_nmsub (e0, d, x0, one);\t\t/* e0 = 1. - d * x0 */\n+\n+  y1 = gen_reg_rtx (mode);\n+  rs6000_emit_madd (y1, e0, x0, x0);\t\t/* y1 = x0 + e0 * x0 */\n+\n+  e1 = gen_reg_rtx (mode);\n+  emit_insn (gen_mul (e1, e0, e0));\t\t/* e1 = e0 * e0 */\n+\n+  y2 = gen_reg_rtx (mode);\n+  rs6000_emit_madd (y2, e1, y1, y1);\t\t/* y2 = y1 + e1 * y1 */\n+\n+  e2 = gen_reg_rtx (mode);\n+  emit_insn (gen_mul (e2, e1, e1));\t\t/* e2 = e1 * e1 */\n+\n+  y3 = gen_reg_rtx (mode);\n+  rs6000_emit_madd (y3, e2, y2, y2);\t\t/* y3 = y2 + e2 * y2 */\n+\n+  u0 = gen_reg_rtx (mode);\n+  emit_insn (gen_mul (u0, n, y3));\t\t/* u0 = n * y3 */\n+\n+  v0 = gen_reg_rtx (mode);\n+  rs6000_emit_nmsub (v0, d, u0, n);\t\t/* v0 = n - d * u0 */\n+\n+  rs6000_emit_madd (dst, v0, y3, u0);\t\t/* dst = u0 + v0 * y3 */\n+}\n+\n+/* Newton-Raphson approximation of floating point divide DST = N/D.  If NOTE_P,\n+   add a reg_note saying that this was a division.  Support both scalar and\n+   vector divide.  Assumes no trapping math and finite arguments.  */\n \n void\n-rs6000_emit_swrsqrtsf (rtx dst, rtx src)\n-{\n-  rtx x0, x1, x2, y1, u0, u1, u2, v0, v1, v2, t0,\n-    half, one, halfthree, c1, cond, label;\n-\n-  x0 = gen_reg_rtx (SFmode);\n-  x1 = gen_reg_rtx (SFmode);\n-  x2 = gen_reg_rtx (SFmode);\n-  y1 = gen_reg_rtx (SFmode);\n-  u0 = gen_reg_rtx (SFmode);\n-  u1 = gen_reg_rtx (SFmode);\n-  u2 = gen_reg_rtx (SFmode);\n-  v0 = gen_reg_rtx (SFmode);\n-  v1 = gen_reg_rtx (SFmode);\n-  v2 = gen_reg_rtx (SFmode);\n-  t0 = gen_reg_rtx (SFmode);\n-  halfthree = gen_reg_rtx (SFmode);\n-  cond = gen_rtx_REG (CCFPmode, CR1_REGNO);\n-  label = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+rs6000_emit_swdiv (rtx dst, rtx n, rtx d, bool note_p)\n+{\n+  enum machine_mode mode = GET_MODE (dst);\n \n-  /* check 0.0, 1.0, NaN, Inf by testing src * src = src */\n-  emit_insn (gen_rtx_SET (VOIDmode, t0,\n-\t\t\t  gen_rtx_MULT (SFmode, src, src)));\n+  if (RS6000_RECIP_HIGH_PRECISION_P (mode))\n+    rs6000_emit_swdiv_high_precision (dst, n, d);\n+  else\n+    rs6000_emit_swdiv_low_precision (dst, n, d);\n \n-  emit_insn (gen_rtx_SET (VOIDmode, cond,\n-\t\t\t  gen_rtx_COMPARE (CCFPmode, t0, src)));\n-  c1 = gen_rtx_EQ (VOIDmode, cond, const0_rtx);\n-  emit_unlikely_jump (c1, label);\n+  if (note_p)\n+    add_reg_note (get_last_insn (), REG_EQUAL, gen_rtx_DIV (mode, n, d));\n+}\n \n-  half = force_reg (SFmode, CONST_DOUBLE_FROM_REAL_VALUE (dconsthalf, SFmode));\n-  one = force_reg (SFmode, CONST_DOUBLE_FROM_REAL_VALUE (dconst1, SFmode));\n+/* Newton-Raphson approximation of single/double-precision floating point\n+   rsqrt.  Assumes no trapping math and finite arguments.  */\n+\n+void\n+rs6000_emit_swrsqrt (rtx dst, rtx src)\n+{\n+  enum machine_mode mode = GET_MODE (src);\n+  rtx x0 = gen_reg_rtx (mode);\n+  rtx y = gen_reg_rtx (mode);\n+  int passes = (TARGET_RECIP_PRECISION) ? 2 : 3;\n+  REAL_VALUE_TYPE dconst3_2;\n+  int i;\n+  rtx halfthree;\n+  enum insn_code code = optab_handler (smul_optab, mode)->insn_code;\n+  gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (code);\n \n-  /* halfthree = 1.5 = 1.0 + 0.5 */\n-  emit_insn (gen_rtx_SET (VOIDmode, halfthree,\n-\t\t\t  gen_rtx_PLUS (SFmode, one, half)));\n+  gcc_assert (code != CODE_FOR_nothing);\n+\n+  /* Load up the constant 1.5 either as a scalar, or as a vector.  */\n+  real_from_integer (&dconst3_2, VOIDmode, 3, 0, 0);\n+  SET_REAL_EXP (&dconst3_2, REAL_EXP (&dconst3_2) - 1);\n+\n+  halfthree = rs6000_load_constant_and_splat (mode, dconst3_2);\n \n   /* x0 = rsqrt estimate */\n   emit_insn (gen_rtx_SET (VOIDmode, x0,\n-\t\t\t  gen_rtx_UNSPEC (SFmode, gen_rtvec (1, src),\n+\t\t\t  gen_rtx_UNSPEC (mode, gen_rtvec (1, src),\n \t\t\t\t\t  UNSPEC_RSQRT)));\n \n-  /* y1 = 0.5 * src = 1.5 * src - src -> fewer constants */\n-  emit_insn (gen_rtx_SET (VOIDmode, y1,\n-\t\t\t  gen_rtx_MINUS (SFmode,\n-\t\t\t\t\t gen_rtx_MULT (SFmode, src, halfthree),\n-\t\t\t\t\t src)));\n-\n-  /* x1 = x0 * (1.5 - y1 * (x0 * x0)) */\n-  emit_insn (gen_rtx_SET (VOIDmode, u0,\n-\t\t\t  gen_rtx_MULT (SFmode, x0, x0)));\n-  emit_insn (gen_rtx_SET (VOIDmode, v0,\n-\t\t\t  gen_rtx_MINUS (SFmode,\n-\t\t\t\t\t halfthree,\n-\t\t\t\t\t gen_rtx_MULT (SFmode, y1, u0))));\n-  emit_insn (gen_rtx_SET (VOIDmode, x1,\n-\t\t\t  gen_rtx_MULT (SFmode, x0, v0)));\n-\n-  /* x2 = x1 * (1.5 - y1 * (x1 * x1)) */\n-  emit_insn (gen_rtx_SET (VOIDmode, u1,\n-\t\t\t  gen_rtx_MULT (SFmode, x1, x1)));\n-  emit_insn (gen_rtx_SET (VOIDmode, v1,\n-\t\t\t  gen_rtx_MINUS (SFmode,\n-\t\t\t\t\t halfthree,\n-\t\t\t\t\t gen_rtx_MULT (SFmode, y1, u1))));\n-  emit_insn (gen_rtx_SET (VOIDmode, x2,\n-\t\t\t  gen_rtx_MULT (SFmode, x1, v1)));\n-\n-  /* dst = x2 * (1.5 - y1 * (x2 * x2)) */\n-  emit_insn (gen_rtx_SET (VOIDmode, u2,\n-\t\t\t  gen_rtx_MULT (SFmode, x2, x2)));\n-  emit_insn (gen_rtx_SET (VOIDmode, v2,\n-\t\t\t  gen_rtx_MINUS (SFmode,\n-\t\t\t\t\t halfthree,\n-\t\t\t\t\t gen_rtx_MULT (SFmode, y1, u2))));\n-  emit_insn (gen_rtx_SET (VOIDmode, dst,\n-\t\t\t  gen_rtx_MULT (SFmode, x2, v2)));\n+  /* y = 0.5 * src = 1.5 * src - src -> fewer constants */\n+  rs6000_emit_msub (y, src, halfthree, src);\n \n-  emit_label (XEXP (label, 0));\n+  for (i = 0; i < passes; i++)\n+    {\n+      rtx x1 = gen_reg_rtx (mode);\n+      rtx u = gen_reg_rtx (mode);\n+      rtx v = gen_reg_rtx (mode);\n+\n+      /* x1 = x0 * (1.5 - y * (x0 * x0)) */\n+      emit_insn (gen_mul (u, x0, x0));\n+      rs6000_emit_nmsub (v, y, u, halfthree);\n+      emit_insn (gen_mul (x1, x0, v));\n+      x0 = x1;\n+    }\n+\n+  emit_move_insn (dst, x0);\n+  return;\n }\n \n /* Emit popcount intrinsic on TARGET_POPCNTB (Power5) and TARGET_POPCNTD"}, {"sha": "5a1d7eeed68c866b2eda826904e65239322d882a", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -543,6 +543,46 @@ extern int rs6000_vector_align[];\n /* E500 processors only support plain \"sync\", not lwsync.  */\n #define TARGET_NO_LWSYNC TARGET_E500\n \n+/* Which machine supports the various reciprocal estimate instructions.  */\n+#define TARGET_FRES\t(TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT \\\n+\t\t\t && TARGET_FPRS && TARGET_SINGLE_FLOAT)\n+\n+#define TARGET_FRE\t(TARGET_HARD_FLOAT && TARGET_FPRS \\\n+\t\t\t && TARGET_DOUBLE_FLOAT \\\n+\t\t\t && (TARGET_POPCNTB || VECTOR_UNIT_VSX_P (DFmode)))\n+\n+#define TARGET_FRSQRTES\t(TARGET_HARD_FLOAT && TARGET_POPCNTB \\\n+\t\t\t && TARGET_FPRS && TARGET_SINGLE_FLOAT)\n+\n+#define TARGET_FRSQRTE\t(TARGET_HARD_FLOAT && TARGET_FPRS \\\n+\t\t\t && TARGET_DOUBLE_FLOAT \\\n+\t\t\t && (TARGET_PPC_GFXOPT || VECTOR_UNIT_VSX_P (DFmode)))\n+\n+/* Whether the various reciprocal divide/square root estimate instructions\n+   exist, and whether we should automatically generate code for the instruction\n+   by default.  */\n+#define RS6000_RECIP_MASK_HAVE_RE\t0x1\t/* have RE instruction.  */\n+#define RS6000_RECIP_MASK_AUTO_RE\t0x2\t/* generate RE by default.  */\n+#define RS6000_RECIP_MASK_HAVE_RSQRTE\t0x4\t/* have RSQRTE instruction.  */\n+#define RS6000_RECIP_MASK_AUTO_RSQRTE\t0x8\t/* gen. RSQRTE by default.  */\n+\n+extern unsigned char rs6000_recip_bits[];\n+\n+#define RS6000_RECIP_HAVE_RE_P(MODE) \\\n+  (rs6000_recip_bits[(int)(MODE)] & RS6000_RECIP_MASK_HAVE_RE)\n+\n+#define RS6000_RECIP_AUTO_RE_P(MODE) \\\n+  (rs6000_recip_bits[(int)(MODE)] & RS6000_RECIP_MASK_AUTO_RE)\n+\n+#define RS6000_RECIP_HAVE_RSQRTE_P(MODE) \\\n+  (rs6000_recip_bits[(int)(MODE)] & RS6000_RECIP_MASK_HAVE_RSQRTE)\n+\n+#define RS6000_RECIP_AUTO_RSQRTE_P(MODE) \\\n+  (rs6000_recip_bits[(int)(MODE)] & RS6000_RECIP_MASK_AUTO_RSQRTE)\n+\n+#define RS6000_RECIP_HIGH_PRECISION_P(MODE) \\\n+  ((MODE) == SFmode || (MODE) == V4SFmode || TARGET_RECIP_PRECISION)\n+\n /* Sometimes certain combinations of command options do not make sense\n    on a particular target machine.  You can define a macro\n    `OVERRIDE_OPTIONS' to take account of this.  This macro, if"}, {"sha": "8f7093a67351082bfa7ce8471890cd165fadea7d", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 71, "deletions": 48, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -220,6 +220,9 @@\n ; These modes do not fit in integer registers in 32-bit mode.\n (define_mode_iterator DIFD [DI DF DD])\n \n+;; Iterator for reciprocal estimate instructions\n+(define_mode_iterator RECIPF [SF DF V4SF V2DF])\n+\n ; Various instructions that come in SI and DI forms.\n ; A generic w/d attribute, for things like cmpw/cmpd.\n (define_mode_attr wd [(QI \"b\") (HI \"h\") (SI \"w\") (DI \"d\")])\n@@ -240,6 +243,11 @@\n (define_mode_attr mptrsize [(SI \"si\")\n \t\t\t    (DI \"di\")])\n \n+(define_mode_attr rreg [(SF   \"f\")\n+\t\t\t(DF   \"Ws\")\n+\t\t\t(V4SF \"Wf\")\n+\t\t\t(V2DF \"Wd\")])\n+\n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n@@ -5563,6 +5571,45 @@\n   [(set_attr \"type\" \"var_delayed_compare,delayed_compare,var_delayed_compare,delayed_compare\")\n    (set_attr \"length\" \"4,4,8,8\")])\n \f\n+;; Builtins to replace a division to generate FRE reciprocal estimate\n+;; instructions and the necessary fixup instructions\n+(define_expand \"recip<mode>3\"\n+  [(match_operand:RECIPF 0 \"gpc_reg_operand\" \"\")\n+   (match_operand:RECIPF 1 \"gpc_reg_operand\" \"\")\n+   (match_operand:RECIPF 2 \"gpc_reg_operand\" \"\")]\n+  \"RS6000_RECIP_HAVE_RE_P (<MODE>mode)\"\n+{\n+   rs6000_emit_swdiv (operands[0], operands[1], operands[2], false);\n+   DONE;\n+})\n+\n+;; Split to create division from FRE/FRES/etc. and fixup instead of the normal\n+;; hardware division.  This is only done before register allocation and with\n+;; -ffast-math.  This must appear before the divsf3/divdf3 insns.\n+(define_split\n+  [(set (match_operand:RECIPF 0 \"gpc_reg_operand\" \"\")\n+\t(div:RECIPF (match_operand 1 \"gpc_reg_operand\" \"\")\n+\t\t    (match_operand 2 \"gpc_reg_operand\" \"\")))]\n+  \"RS6000_RECIP_AUTO_RE_P (<MODE>mode)\n+   && can_create_pseudo_p () && optimize_insn_for_speed_p ()\n+   && flag_finite_math_only && !flag_trapping_math && flag_reciprocal_math\"\n+  [(const_int 0)]\n+{\n+  rs6000_emit_swdiv (operands[0], operands[1], operands[2], true);\n+  DONE;\n+})\n+\n+;; Builtins to replace 1/sqrt(x) with instructions using RSQRTE and the\n+;; appropriate fixup.\n+(define_expand \"rsqrt<mode>2\"\n+  [(match_operand:RECIPF 0 \"gpc_reg_operand\" \"\")\n+   (match_operand:RECIPF 1 \"gpc_reg_operand\" \"\")]\n+  \"RS6000_RECIP_HAVE_RSQRT_P (<MODE>mode)\"\n+{\n+  rs6000_emit_swrsqrt (operands[0], operands[1]);\n+  DONE;\n+})\n+\f\n (define_split\n   [(set (match_operand:CC 3 \"cc_reg_not_micro_cr0_operand\" \"\")\n \t(compare:CC (ashiftrt:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n@@ -5766,22 +5813,10 @@\n   \"{fd|fdiv} %0,%1,%2\"\n   [(set_attr \"type\" \"ddiv\")])\n \n-(define_expand \"recipsf3\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec:SF [(match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t    (match_operand:SF 2 \"gpc_reg_operand\" \"f\")]\n-\t\t   UNSPEC_FRES))]\n-  \"TARGET_RECIP && TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT && !optimize_size\n-   && flag_finite_math_only && !flag_trapping_math\"\n-{\n-   rs6000_emit_swdivsf (operands[0], operands[1], operands[2]);\n-   DONE;\n-})\n-\n (define_insn \"fres\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(unspec:SF [(match_operand:SF 1 \"gpc_reg_operand\" \"f\")] UNSPEC_FRES))]\n-  \"TARGET_PPC_GFXOPT && flag_finite_math_only\"\n+  \"TARGET_FRES\"\n   \"fres %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -5931,23 +5966,12 @@\n   \"fsqrt %0,%1\"\n   [(set_attr \"type\" \"dsqrt\")])\n \n-(define_expand \"rsqrtsf2\"\n+(define_insn \"*rsqrtsf_internal1\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(unspec:SF [(match_operand:SF 1 \"gpc_reg_operand\" \"f\")]\n \t\t   UNSPEC_RSQRT))]\n-  \"TARGET_RECIP && TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT && !optimize_size\n-   && flag_finite_math_only && !flag_trapping_math\"\n-{\n-  rs6000_emit_swrsqrtsf (operands[0], operands[1]);\n-  DONE;\n-})\n-\n-(define_insn \"*rsqrt_internal1\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec:SF [(match_operand:SF 1 \"gpc_reg_operand\" \"f\")]\n-\t\t   UNSPEC_RSQRT))]\n-  \"TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT\"\n-  \"frsqrte %0,%1\"\n+  \"TARGET_FRSQRTES\"\n+  \"frsqrtes %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_expand \"copysignsf3\"\n@@ -5960,9 +5984,18 @@\n \t                     (match_dup 5))\n \t\t\t (match_dup 3)\n \t\t\t (match_dup 4)))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n-   && !HONOR_NANS (SFmode) && !HONOR_SIGNED_ZEROS (SFmode)\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+   && ((TARGET_PPC_GFXOPT\n+        && !HONOR_NANS (SFmode)\n+        && !HONOR_SIGNED_ZEROS (SFmode))\n+       || VECTOR_UNIT_VSX_P (DFmode))\"\n   {\n+     if (VECTOR_UNIT_VSX_P (DFmode))\n+       {\n+\t emit_insn (gen_vsx_copysignsf3 (operands[0], operands[1], operands[2],\n+\t\t\t\t\t CONST0_RTX (SFmode)));\n+\t DONE;\n+       }\n      operands[3] = gen_reg_rtx (SFmode);\n      operands[4] = gen_reg_rtx (SFmode);\n      operands[5] = CONST0_RTX (SFmode);\n@@ -6222,31 +6255,21 @@\n   \"{fd|fdiv} %0,%1,%2\"\n   [(set_attr \"type\" \"ddiv\")])\n \n-(define_expand \"recipdf3\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"d\")\n-\t\t    (match_operand:DF 2 \"gpc_reg_operand\" \"d\")]\n-\t\t   UNSPEC_FRES))]\n-  \"TARGET_RECIP && TARGET_HARD_FLOAT && TARGET_POPCNTB && !optimize_size\n-   && flag_finite_math_only && !flag_trapping_math\"\n-{\n-   rs6000_emit_swdivdf (operands[0], operands[1], operands[2]);\n-   DONE;\n-})\n-\n-(define_expand \"fred\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"d\")] UNSPEC_FRES))]\n-  \"(TARGET_POPCNTB || VECTOR_UNIT_VSX_P (DFmode)) && flag_finite_math_only\"\n-  \"\")\n-\n (define_insn \"*fred_fpr\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n \t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"f\")] UNSPEC_FRES))]\n-  \"TARGET_POPCNTB && flag_finite_math_only && !VECTOR_UNIT_VSX_P (DFmode)\"\n+  \"TARGET_FRE && !VECTOR_UNIT_VSX_P (DFmode)\"\n   \"fre %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_insn \"*rsqrtdf_internal1\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"d\")]\n+\t\t   UNSPEC_RSQRT))]\n+  \"TARGET_FRSQRTE && !VECTOR_UNIT_VSX_P (DFmode)\"\n+  \"frsqrte %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n (define_insn \"*fmadddf4_fpr\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n \t(plus:DF (mult:DF (match_operand:DF 1 \"gpc_reg_operand\" \"%d\")"}, {"sha": "e70172a19a61936bc4abbb7a647123c075283f1d", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -195,8 +195,16 @@ Target Report Var(TARGET_XL_COMPAT)\n Conform more closely to IBM XLC semantics\n \n mrecip\n-Target Report Var(TARGET_RECIP)\n-Generate software reciprocal sqrt for better throughput\n+Target Report\n+Generate software reciprocal divide and square root for better throughput.\n+\n+mrecip=\n+Target Report RejectNegative Joined\n+Generate software reciprocal divide and square root for better throughput.\n+\n+mrecip-precision\n+Target Report Mask(RECIP_PRECISION)\n+Assume that the reciprocal estimate instructions provide more accuracy.\n \n mno-fp-in-toc\n Target Report RejectNegative Var(TARGET_NO_FP_IN_TOC)"}, {"sha": "760baeb458dcd22045ac9573ca9b988dc44170e8", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -267,6 +267,20 @@\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"\")\n \n+(define_expand \"rsqrte<mode>2\"\n+  [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n+        (unspec:VEC_F [(match_operand:VEC_F 1 \"vfloat_operand\" \"\")]\n+\t\t      UNSPEC_RSQRT))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"\")\n+\n+(define_expand \"re<mode>2\"\n+  [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n+\t(unspec:VEC_F [(match_operand:VEC_F 1 \"vfloat_operand\" \"f\")]\n+\t\t      UNSPEC_FRES))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"\")\n+\n (define_expand \"ftrunc<mode>2\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n   \t(fix:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\" \"\")))]"}, {"sha": "213d53ae5d19bc652ffa9be87058ff61124810fa", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -195,7 +195,7 @@\n    (UNSPEC_VSX_MSUB\t\t511)\n    (UNSPEC_VSX_NMADD\t\t512)\n    (UNSPEC_VSX_NMSUB\t\t513)\n-   (UNSPEC_VSX_RSQRTE\t\t514)\n+   ;; 514 deleted\n    (UNSPEC_VSX_TDIV\t\t515)\n    (UNSPEC_VSX_TSQRT\t\t516)\n    (UNSPEC_VSX_XXPERMDI\t\t517)\n@@ -446,10 +446,10 @@\n   [(set_attr \"type\" \"<VStype_sqrt>\")\n    (set_attr \"fp_type\" \"<VSfptype_sqrt>\")])\n \n-(define_insn \"vsx_rsqrte<mode>2\"\n+(define_insn \"*vsx_rsqrte<mode>2\"\n   [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n \t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n-\t\t      UNSPEC_VSX_RSQRTE))]\n+\t\t      UNSPEC_RSQRT))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>rsqrte<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n@@ -862,6 +862,20 @@\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n+;; Special version of copysign for single precision that knows internally\n+;; scalar single values are kept as double\n+(define_insn \"vsx_copysignsf3\"\n+  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=f\")\n+\t(if_then_else:SF\n+\t (ge:SF (match_operand:SF 2 \"vsx_register_operand\" \"f\")\n+\t\t(match_operand:SF 3 \"zero_constant\" \"j\"))\n+\t (abs:SF (match_operand:SF 1 \"vsx_register_operand\" \"f\"))\n+\t (neg:SF (abs:SF (match_dup 1)))))]\n+  \"VECTOR_UNIT_VSX_P (DFmode)\"\n+  \"xscpsgndp %x0,%x2,%x1\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_type\" \"fp_addsub_d\")])\n+\n ;; For the conversions, limit the register class for the integer value to be\n ;; the fprs because we don't want to add the altivec registers to movdi/movsi.\n ;; For the unsigned tests, there isn't a generic double -> unsigned conversion"}, {"sha": "5f0d7624a0479401ad739cd292bdd13b202dcd7e", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -10994,6 +10994,10 @@ vector unsigned char vec_vrlb (vector unsigned char,\n \n vector float vec_round (vector float);\n \n+vector float vec_recip (vector float, vector float);\n+\n+vector float vec_rsqrt (vector float);\n+\n vector float vec_rsqrte (vector float);\n \n vector float vec_sel (vector float, vector float, vector bool int);\n@@ -11922,8 +11926,10 @@ vector double vec_or (vector bool long, vector double);\n vector double vec_perm (vector double,\n                         vector double,\n                         vector unsigned char);\n-vector float vec_rint (vector float);\n vector double vec_rint (vector double);\n+vector double vec_recip (vector double, vector double);\n+vector double vec_rsqrt (vector double);\n+vector double vec_rsqrte (vector double);\n vector double vec_sel (vector double, vector double, vector bool long);\n vector double vec_sel (vector double, vector double, vector unsigned long);\n vector double vec_sub (vector double, vector double);\n@@ -11964,10 +11970,20 @@ GCC provides a few other builtins on Powerpc to access certain instructions:\n float __builtin_recipdivf (float, float);\n float __builtin_rsqrtf (float);\n double __builtin_recipdiv (double, double);\n+double __builtin_rsqrt (double);\n long __builtin_bpermd (long, long);\n int __builtin_bswap16 (int);\n @end smallexample\n \n+The @code{vec_rsqrt}, @code{__builtin_rsqrt}, and\n+@code{__builtin_rsqrtf} functions generate multiple instructions to\n+implement the reciprocal sqrt functionality using reciprocal sqrt\n+estimate instructions.\n+\n+The @code{__builtin_recipdiv}, and @code{__builtin_recipdivf}\n+functions generate multiple instructions to implement division using\n+the reciprocal estimate instructions.\n+\n @node RX Built-in Functions\n @subsection RX Built-in Functions\n GCC supports some of the RX instructions which cannot be expressed in"}, {"sha": "d8c0c22bed6d2c3f77066e690b99a404255fbe36", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -783,7 +783,8 @@ See RS/6000 and PowerPC Options.\n -mfloat-gprs=yes  -mfloat-gprs=no -mfloat-gprs=single -mfloat-gprs=double @gol\n -mprototype  -mno-prototype @gol\n -msim  -mmvme  -mads  -myellowknife  -memb  -msdata @gol\n--msdata=@var{opt}  -mvxworks  -G @var{num}  -pthread}\n+-msdata=@var{opt}  -mvxworks  -G @var{num}  -pthread @gol\n+-mrecip -mrecip=@var{opt} -mno-recip -mrecip-precision -mno-recip-precision}\n \n @emph{RX Options}\n @gccoptlist{-m64bit-doubles  -m32bit-doubles  -fpu  -nofpu@gol\n@@ -14975,17 +14976,6 @@ values for @var{cpu_type} are used for @option{-mtune} as for\n architecture, registers, and mnemonics set by @option{-mcpu}, but the\n scheduling parameters set by @option{-mtune}.\n \n-@item -mswdiv\n-@itemx -mno-swdiv\n-@opindex mswdiv\n-@opindex mno-swdiv\n-Generate code to compute division as reciprocal estimate and iterative\n-refinement, creating opportunities for increased throughput.  This\n-feature requires: optional PowerPC Graphics instruction set for single\n-precision and FRE instruction for double precision, assuming divides\n-cannot generate user-visible traps, and the domain values not include\n-Infinities, denormals or zero denominator.\n-\n @item -maltivec\n @itemx -mno-altivec\n @opindex maltivec\n@@ -15641,6 +15631,52 @@ sequence.\n Adds support for multithreading with the @dfn{pthreads} library.\n This option sets flags for both the preprocessor and linker.\n \n+@item -mrecip\n+@itemx -mno-recip\n+@opindex mrecip\n+This option will enable GCC to use the reciprocal estimate and\n+reciprocal square root estimate instructions with additional\n+Newton-Raphson steps to increase precision instead of doing a divide or\n+square root and divide for floating point arguments.  You should use\n+the @option{-ffast-math} option when using @option{-mrecip} (or at\n+least @option{-funsafe-math-optimizations},\n+@option{-finite-math-only}, @option{-freciprocal-math} and\n+@option{-fno-trapping-math}).  Note that while the throughput of the\n+sequence is generally higher than the throughput of the non-reciprocal\n+instruction, the precision of the sequence can be decreased by up to 2\n+ulp (i.e. the inverse of 1.0 equals 0.99999994) for reciprocal square\n+roots.\n+\n+@item -mrecip=@var{opt}\n+@opindex mrecip=opt\n+This option allows to control which reciprocal estimate instructions\n+may be used.  @var{opt} is a comma separated list of options, that may\n+be preceeded by a @code{!} to invert the option:\n+@code{all}: enable all estimate instructions,\n+@code{default}: enable the default instructions, equvalent to @option{-mrecip},\n+@code{none}: disable all estimate instructions, equivalent to @option{-mno-recip};\n+@code{div}: enable the reciprocal approximation instructions for both single and double precision;\n+@code{divf}: enable the single precision reciprocal approximation instructions;\n+@code{divd}: enable the double precision reciprocal approximation instructions;\n+@code{rsqrt}: enable the reciprocal square root approximation instructions for both single and double precision;\n+@code{rsqrtf}: enable the single precision reciprocal square root approximation instructions;\n+@code{rsqrtd}: enable the double precision reciprocal square root approximation instructions;\n+\n+So for example, @option{-mrecip=all,!rsqrtd} would enable the\n+all of the reciprocal estimate instructions, except for the\n+@code{FRSQRTE}, @code{XSRSQRTEDP}, and @code{XVRSQRTEDP} instructions\n+which handle the double precision reciprocal square root calculations.\n+\n+@item -mrecip-precision\n+@itemx -mno-recip-precision\n+@opindex mrecip-precision\n+Assume (do not assume) that the reciprocal estimate instructions\n+provide higher precision estimates than is mandated by the powerpc\n+ABI.  Selecting @option{-mcpu=power6} or @option{-mcpu=power7}\n+automatically selects @option{-mrecip-precision}.  The double\n+precision square root estimate instructions are not generated by\n+default on low precision machines, since they do not provide an\n+estimate that converges after three steps.\n @end table\n \n @node RX Options"}, {"sha": "ccbd30c6fdc2ed902ed860e9aff6008960b06e98", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -1,3 +1,16 @@\n+2010-06-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/44218\n+\t* gcc.target/powerpc/recip-1.c: New test for -mrecip support.\n+\t* gcc.target/powerpc/recip-2.c: Ditto.\n+\t* gcc.target/powerpc/recip-3.c: Ditto.\n+\t* gcc.target/powerpc/recip-4.c: Ditto.\n+\t* gcc.target/powerpc/recip-5.c: Ditto.\n+\t* gcc.target/powerpc/recip-6.c: Ditto.\n+\t* gcc.target/powerpc/recip-7.c: Ditto.\n+\t* gcc.target/powerpc/recip-test.h: Ditto.\n+\t* gcc.target/powerpc/recip-test2.h: Ditto.\n+\n 2010-06-02  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* g++.dg/torture/pr44295.C (size_t): Use __SIZE_TYPE__."}, {"sha": "d1e383dc4eaf3719f9b2d4f3865919ff0b6b42ed", "filename": "gcc/testsuite/gcc.target/powerpc/recip-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-1.c?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-options \"-O2 -mrecip -ffast-math -mcpu=power6\" } */\n+/* { dg-final { scan-assembler-times \"frsqrte\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fmsub\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fmul\" 8 } } */\n+/* { dg-final { scan-assembler-times \"fnmsub\" 4 } } */\n+\n+double\n+rsqrt_d (double a)\n+{\n+  return 1.0 / __builtin_sqrt (a);\n+}\n+\n+float\n+rsqrt_f (float a)\n+{\n+  return 1.0f / __builtin_sqrtf (a);\n+}"}, {"sha": "69442733aabb4fb5df06bf5321efb8704ae0ec9b", "filename": "gcc/testsuite/gcc.target/powerpc/recip-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-2.c?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-options \"-O2 -mrecip -ffast-math -mcpu=power5\" } */\n+/* { dg-final { scan-assembler-times \"frsqrtes\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmsubs\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmuls\" 6 } } */\n+/* { dg-final { scan-assembler-times \"fnmsubs\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fsqrt\" 1 } } */\n+\n+/* power5 resqrte is not accurate enough, and should not be generated by\n+   default for -mrecip.  */\n+double\n+rsqrt_d (double a)\n+{\n+  return 1.0 / __builtin_sqrt (a);\n+}\n+\n+float\n+rsqrt_f (float a)\n+{\n+  return 1.0f / __builtin_sqrtf (a);\n+}"}, {"sha": "80a34e8ee5935cc304685537b70090933766f148", "filename": "gcc/testsuite/gcc.target/powerpc/recip-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-3.c?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-options \"-O2 -mrecip -ffast-math -mcpu=power7\" } */\n+/* { dg-final { scan-assembler-times \"xsrsqrtedp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xsmsub.dp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xsmuldp\" 4 } } */\n+/* { dg-final { scan-assembler-times \"xsnmsub.dp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"frsqrtes\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmsubs\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmuls\" 4 } } */\n+/* { dg-final { scan-assembler-times \"fnmsubs\" 2 } } */\n+\n+double\n+rsqrt_d (double a)\n+{\n+  return 1.0 / __builtin_sqrt (a);\n+}\n+\n+float\n+rsqrt_f (float a)\n+{\n+  return 1.0f / __builtin_sqrtf (a);\n+}"}, {"sha": "bd496d70e254263c3331c8c22bf299a7ca20f3e3", "filename": "gcc/testsuite/gcc.target/powerpc/recip-4.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-4.c?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-options \"-O3 -ftree-vectorize -mrecip -ffast-math -mcpu=power7 -fno-unroll-loops\" } */\n+/* { dg-final { scan-assembler-times \"xvrsqrtedp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xvmsub.dp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xvmuldp\" 4 } } */\n+/* { dg-final { scan-assembler-times \"xvnmsub.dp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xvrsqrtesp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xvmsub.sp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"xvmulsp\" 4 } } */\n+/* { dg-final { scan-assembler-times \"xvnmsub.sp\" 2 } } */\n+\n+#define SIZE 1024\n+\n+extern double a_d[SIZE] __attribute__((__aligned__(32)));\n+extern double b_d[SIZE] __attribute__((__aligned__(32)));\n+\n+void\n+vectorize_rsqrt_d (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a_d[i] = 1.0 / __builtin_sqrt (b_d[i]);\n+}\n+\n+extern float a_f[SIZE] __attribute__((__aligned__(32)));\n+extern float b_f[SIZE] __attribute__((__aligned__(32)));\n+\n+void\n+vectorize_rsqrt_f (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a_f[i] = 1.0f / __builtin_sqrtf (b_f[i]);\n+}"}, {"sha": "4a9c496201a3a201f66015fa28ce319eaf11e9c0", "filename": "gcc/testsuite/gcc.target/powerpc/recip-5.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-5.c?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-options \"-O3 -ftree-vectorize -mrecip=all -ffast-math -mcpu=power7 -fno-unroll-loops\" } */\n+/* { dg-final { scan-assembler-times \"xvredp\" 4 } } */\n+/* { dg-final { scan-assembler-times \"xvresp\" 5 } } */\n+/* { dg-final { scan-assembler-times \"xsredp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fres\" 2 } } */\n+\n+#include <altivec.h>\n+\n+float f_recip (float a, float b) { return __builtin_recipdivf (a, b); }\n+double d_recip (double a, double b) { return __builtin_recipdiv (a, b); }\n+\n+float f_div (float a, float b) { return a / b; }\n+double d_div (double a, double b) { return a / b; }\n+\n+#define SIZE 1024\n+\n+double d_a[SIZE] __attribute__((__aligned__(32)));\n+double d_b[SIZE] __attribute__((__aligned__(32)));\n+double d_c[SIZE] __attribute__((__aligned__(32)));\n+\n+float f_a[SIZE] __attribute__((__aligned__(32)));\n+float f_b[SIZE] __attribute__((__aligned__(32)));\n+float f_c[SIZE] __attribute__((__aligned__(32)));\n+\n+void vec_f_recip (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    f_a[i] = __builtin_recipdivf (f_b[i], f_c[i]);\n+}\n+\n+void vec_d_recip (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    d_a[i] = __builtin_recipdiv (d_b[i], d_c[i]);\n+}\n+\n+void vec_f_div (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    f_a[i] = f_b[i] / f_c[i];\n+}\n+\n+void vec_f_div2 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    f_a[i] = f_b[i] / 2.0f;\n+}\n+\n+void vec_f_div53 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    f_a[i] = f_b[i] / 53.0f;\n+}\n+\n+void vec_d_div (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    d_a[i] = d_b[i] / d_c[i];\n+}\n+\n+void vec_d_div2 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    d_a[i] = d_b[i] / 2.0;\n+}\n+\n+void vec_d_div53 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    d_a[i] = d_b[i] / 53.0;\n+}\n+\n+vector float v4sf_recip1 (vector float a, vector float b) { return vec_recipdiv (a, b); }\n+vector float v4sf_recip2 (vector float a, vector float b) { return __builtin_altivec_vrecipdivfp (a, b); }\n+vector double v2df_recip1 (vector double a, vector double b) { return vec_recipdiv (a, b); }\n+vector float v4sf_recip3 (vector float a, vector float b) { return __builtin_vsx_xvrecipdivsp (a, b); }\n+vector double v2df_recip2 (vector double a, vector double b) { return __builtin_vsx_xvrecipdivdp (a, b); }"}, {"sha": "7d71df6709de29b56a921f3aef31a542b1a5ffc9", "filename": "gcc/testsuite/gcc.target/powerpc/recip-6.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-6.c?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mcpu=power7 -O3 -ftree-vectorize -ffast-math -mrecip=all -mrecip-precision\" } */\n+\n+/* Check reciprocal estimate functions for accuracy.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <math.h>\n+#include <float.h>\n+#include <string.h>\n+\n+#include \"recip-test.h\""}, {"sha": "7b32ba076a352639699bef1f604652d46712863c", "filename": "gcc/testsuite/gcc.target/powerpc/recip-7.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-7.c?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target ppc_recip_hw } */\n+/* { dg-options \"-O3 -ftree-vectorize -ffast-math -mrecip -mpowerpc-gfxopt -mpowerpc-gpopt -mpopcntb\" } */\n+\n+/* Check reciprocal estimate functions for accuracy.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <math.h>\n+#include <float.h>\n+#include <string.h>\n+\n+#include \"recip-test.h\""}, {"sha": "7a42df5757d0c78b94189c46a0ecab1535b42449", "filename": "gcc/testsuite/gcc.target/powerpc/recip-test.h", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-test.h?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -0,0 +1,149 @@\n+/* Check reciprocal estimate functions for accuracy.  */\n+\n+#ifdef _ARCH_PPC64\n+typedef unsigned long uns64_t;\n+#define UNUM64(x) x ## L\n+\n+#else\n+typedef unsigned long long uns64_t;\n+#define UNUM64(x) x ## LL\n+#endif\n+\n+typedef unsigned int uns32_t;\n+\n+#define TNAME2(x) #x\n+#define TNAME(x) TNAME2(x)\n+\n+/*\n+ * Float functions.\n+ */\n+\n+#define TYPE float\n+#define NAME(PREFIX) PREFIX ## _float\n+#define UNS_TYPE uns32_t\n+#define UNS_ABS __builtin_abs\n+#define EXP_SIZE 8\n+#define MAN_SIZE 23\n+#define FABS __builtin_fabsf\n+#define FMAX __builtin_fmaxf\n+#define FMIN __builtin_fminf\n+#define SQRT __builtin_sqrtf\n+#define RMIN 1.0e-10\n+#define RMAX 1.0e+10\n+#define BDIV 1\n+#define BRSQRT 2\n+#define ASMDIV \"fdivs\"\n+#define ASMSQRT \"fsqrts\"\n+\n+#define INIT_DIV\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { 0x4fffffff },\t/* 8589934080 */\t\t\t\t\\\n+  { 0x4effffff },\t/* 2147483520 */\t\t\t\t\\\n+  { 0x40ffffff },\t/* 7.99999952316284 */\t\t\t\t\\\n+  { 0x3fffffff },\t/* 1.99999988079071 */\t\t\t\t\\\n+  { 0x417fffff },\t/* 15.9999990463257 */\t\t\t\t\\\n+  { 0x42ffffff },\t/* 127.999992370605 */\t\t\t\t\\\n+  { 0x3dffffff },\t/* 0.124999992549419 */\t\t\t\t\\\n+  { 0x3effffff },\t/* 0.499999970197678 */\t\t\t\t\\\n+}\n+\n+#define INIT_RSQRT\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { 0x457ffffe },\t/* 4096 - small amount */\t\t\t\\\n+  { 0x4c7fffff },\t/* 6.71089e+07 */\t\t\t\t\\\n+  { 0x3d7fffff },\t/* 0.0625 - small amount */\t\t\t\\\n+  { 0x307ffffe },\t/* 9.31322e-10 */\t\t\t\t\\\n+  { 0x4c7ffffe },\t/* 6.71089e+07 */\t\t\t\t\\\n+  { 0x397ffffe },\t/* 0.000244141 */\t\t\t\t\\\n+  { 0x2e7fffff },\t/* 5.82077e-11 */\t\t\t\t\\\n+  { 0x2f7fffff },\t/* 2.32831e-10 */\t\t\t\t\\\n+}\n+\n+\n+#include \"recip-test2.h\"\n+\n+/*\n+ * Double functions.\n+ */\n+\n+#undef TYPE\n+#undef NAME\n+#undef UNS_TYPE\n+#undef UNS_ABS\n+#undef EXP_SIZE\n+#undef MAN_SIZE\n+#undef FABS\n+#undef FMAX\n+#undef FMIN\n+#undef SQRT\n+#undef RMIN\n+#undef RMAX\n+#undef BDIV\n+#undef BRSQRT\n+#undef ASMDIV\n+#undef ASMSQRT\n+#undef INIT_DIV\n+#undef INIT_RSQRT\n+\n+#define TYPE double\n+#define NAME(PREFIX) PREFIX ## _double\n+#define UNS_TYPE uns64_t\n+#define UNS_ABS __builtin_imaxabs\n+#define EXP_SIZE 11\n+#define MAN_SIZE 52\n+#define FABS __builtin_fabs\n+#define FMAX __builtin_fmax\n+#define FMIN __builtin_fmin\n+#define SQRT __builtin_sqrt\n+#define RMIN 1.0e-100\n+#define RMAX 1.0e+100\n+#define BDIV 1\n+#define BRSQRT 2\n+#define ASMDIV \"fdiv\"\n+#define ASMSQRT \"fsqrt\"\n+\n+#define INIT_DIV\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { UNUM64 (0x2b57be53f2a2f3a0) },\t/* 6.78462e-100 */\t\t\\\n+  { UNUM64 (0x2b35f8e8ea553e52) },\t/* 1.56963e-100 */\t\t\\\n+  { UNUM64 (0x2b5b9d861d2fe4fb) },\t/* 7.89099e-100 */\t\t\\\n+  { UNUM64 (0x2b45dc44a084e682) },\t/* 3.12327e-100 */\t\t\\\n+  { UNUM64 (0x2b424ce16945d777) },\t/* 2.61463e-100 */\t\t\\\n+  { UNUM64 (0x2b20b5023d496b50) },\t/* 5.96749e-101 */\t\t\\\n+  { UNUM64 (0x2b61170547f57caa) },\t/* 9.76678e-100 */\t\t\\\n+  { UNUM64 (0x2b543b9d498aac37) },\t/* 5.78148e-100 */\t\t\\\n+}\n+\n+#define INIT_RSQRT\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { UNUM64 (0x2b616f2d8cbbc646) },\t/* 9.96359e-100 */\t\t\\\n+  { UNUM64 (0x2b5c4db2da0a011d) },\t/* 8.08764e-100 */\t\t\\\n+  { UNUM64 (0x2b55a82d5735b262) },\t/* 6.1884e-100 */\t\t\\\n+  { UNUM64 (0x2b50b52908258cb8) },\t/* 4.77416e-100 */\t\t\\\n+  { UNUM64 (0x2b363989a4fb29af) },\t/* 1.58766e-100 */\t\t\\\n+  { UNUM64 (0x2b508b9f6f4180a9) },\t/* 4.7278e-100 */\t\t\\\n+  { UNUM64 (0x2b4f7a1d48accb40) },\t/* 4.49723e-100 */\t\t\\\n+  { UNUM64 (0x2b1146a37372a81f) },\t/* 3.08534e-101 */\t\t\\\n+  { UNUM64 (0x2b33f876a8c48050) },\t/* 1.42663e-100 */\t\t\\\n+}\n+\n+#include \"recip-test2.h\"\n+\n+int\n+main (int argc __attribute__((__unused__)),\n+      char *argv[] __attribute__((__unused__)))\n+{\n+  srand48 (1);\n+  run_float ();\n+\n+#ifdef VERBOSE\n+  printf (\"\\n\");\n+#endif\n+\n+  run_double ();\n+\n+  if (error_count_float != 0 || error_count_double != 0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "3ec356cdfd863b24c10c22097225114162d376b3", "filename": "gcc/testsuite/gcc.target/powerpc/recip-test2.h", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-test2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-test2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Frecip-test2.h?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -0,0 +1,432 @@\n+/*\n+ * Included file to common source float/double checking\n+ * The following macros should be defined:\n+ *\tTYPE\t   -- floating point type\n+ *\tNAME\t   -- convert a name to include the type\n+ *\tUNS_TYPE   -- type to hold TYPE as an unsigned number\n+ *\tEXP_SIZE   -- size in bits of the exponent\n+ *\tMAN_SIZE   -- size in bits of the mantissa\n+ *\tUNS_ABS\t   -- absolute value for UNS_TYPE\n+ *\tFABS\t   -- absolute value function for TYPE\n+ *\tFMAX\t   -- maximum function for TYPE\n+ *\tFMIN\t   -- minimum function for TYPE\n+ *\tSQRT\t   -- square root function for TYPE\n+ *\tRMIN\t   -- minimum random number to generate\n+ *\tRMAX\t   -- maximum random number to generate\n+ *\tASMDIV\t   -- assembler instruction to do divide\n+ *\tASMSQRT\t   -- assembler instruction to do square root\n+ *\tBDIV\t   -- # of bits of inaccuracy to allow for division\n+ *\tBRSQRT\t   -- # of bits of inaccuracy to allow for 1/sqrt\n+ *\tINIT_DIV   -- Initial values to test 1/x against\n+ *\tINIT_RSQRT -- Initial values to test 1/sqrt(x) against\n+ */\n+\n+typedef union\n+{\n+  UNS_TYPE i;\n+  TYPE x;\n+} NAME (union);\n+\n+/*\n+ * Input/output arrays.\n+ */\n+\n+static NAME (union) NAME (div_input)  [] __attribute__((__aligned__(32))) = INIT_DIV;\n+static NAME (union) NAME (rsqrt_input)[] __attribute__((__aligned__(32))) = INIT_RSQRT;\n+\n+#define DIV_SIZE   (sizeof (NAME (div_input))   / sizeof (TYPE))\n+#define RSQRT_SIZE (sizeof (NAME (rsqrt_input)) / sizeof (TYPE))\n+\n+static TYPE NAME (div_expected)[DIV_SIZE] __attribute__((__aligned__(32)));\n+static TYPE NAME (div_output)  [DIV_SIZE] __attribute__((__aligned__(32)));\n+\n+static TYPE NAME (rsqrt_expected)[RSQRT_SIZE] __attribute__((__aligned__(32)));\n+static TYPE NAME (rsqrt_output)  [RSQRT_SIZE] __attribute__((__aligned__(32)));\n+\n+\f\n+/*\n+ * Crack a floating point number into sign bit, exponent, and mantissa.\n+ */\n+\n+static void\n+NAME (crack) (TYPE number, unsigned int *p_sign, unsigned *p_exponent, UNS_TYPE *p_mantissa)\n+{\n+  NAME (union) u;\n+  UNS_TYPE bits;\n+\n+  u.x = number;\n+  bits = u.i;\n+\n+  *p_sign = (unsigned int)((bits >> (EXP_SIZE + MAN_SIZE)) & 0x1);\n+  *p_exponent = (unsigned int)((bits >> MAN_SIZE) & ((((UNS_TYPE)1) << EXP_SIZE) - 1));\n+  *p_mantissa = bits & ((((UNS_TYPE)1) << MAN_SIZE) - 1);\n+  return;\n+}\n+\n+\f\n+/*\n+ * Prevent optimizer from eliminating + 0.0 to remove -0.0.\n+ */\n+\n+volatile TYPE NAME (math_diff_0) = ((TYPE) 0.0);\n+\n+/*\n+ * Return negative if two numbers are significanly different or return the\n+ * number of bits that are different in the mantissa.\n+ */\n+\n+static int\n+NAME (math_diff) (TYPE a, TYPE b, int bits)\n+{\n+  TYPE zero = NAME (math_diff_0);\n+  unsigned int sign_a, sign_b;\n+  unsigned int exponent_a, exponent_b;\n+  UNS_TYPE mantissa_a, mantissa_b, diff;\n+  int i;\n+\n+  /* eliminate signed zero.  */\n+  a += zero;\n+  b += zero;\n+\n+  /* special case Nan.  */\n+  if (__builtin_isnan (a))\n+    return (__builtin_isnan (b) ? 0 : -1);\n+\n+  if (a == b)\n+    return 0;\n+\n+  /* special case infinity.  */\n+  if (__builtin_isinf (a))\n+    return (__builtin_isinf (b) ? 0 : -1);\n+\n+  /* punt on denormal numbers.  */\n+  if (!__builtin_isnormal (a) || !__builtin_isnormal (b))\n+    return -1;\n+\n+  NAME (crack) (a, &sign_a, &exponent_a, &mantissa_a);\n+  NAME (crack) (b, &sign_b, &exponent_b, &mantissa_b);\n+\n+  /* If the sign is different, there is no hope.  */\n+  if (sign_a != sign_b)\n+    return -1;\n+\n+  /* If the exponent is off by 1, see if the values straddle the power of two,\n+     and adjust things to do the mantassa check if we can.  */\n+  if ((exponent_a == (exponent_b+1)) || (exponent_a == (exponent_b-1)))\n+    {\n+      TYPE big = FMAX (a, b);\n+      TYPE small = FMIN (a, b);\n+      TYPE diff = FABS (a - b);\n+      unsigned int sign_big, sign_small, sign_test;\n+      unsigned int exponent_big, exponent_small, exponent_test;\n+      UNS_TYPE mantissa_big, mantissa_small, mantissa_test;\n+\n+      NAME (crack) (big, &sign_big, &exponent_big, &mantissa_big);\n+      NAME (crack) (small, &sign_small, &exponent_small, &mantissa_small);\n+\n+      NAME (crack) (small - diff, &sign_test, &exponent_test, &mantissa_test);\n+      if ((sign_test == sign_small) && (exponent_test == exponent_small))\n+\t{\n+\t  mantissa_a = mantissa_small;\n+\t  mantissa_b = mantissa_test;\n+\t}\n+\n+      else\n+\t{\n+\t  NAME (crack) (big + diff, &sign_test, &exponent_test, &mantissa_test);\n+\t  if ((sign_test == sign_big) && (exponent_test == exponent_big))\n+\t    {\n+\t      mantissa_a = mantissa_big;\n+\t      mantissa_b = mantissa_test;\n+\t    }\n+\n+\t  else\n+\t    return -1;\n+\t}\n+    }\n+\n+  else if (exponent_a != exponent_b)\n+    return -1;\n+\n+  diff = UNS_ABS (mantissa_a - mantissa_b);\n+  for (i = MAN_SIZE; i > 0; i--)\n+    {\n+      if ((diff & ((UNS_TYPE)1) << (i-1)) != 0)\n+\treturn i;\n+    }\n+\n+  return -1;\n+}\n+\n+\f\n+/*\n+ * Turn off inlining to make code inspection easier.\n+ */\n+\n+static void NAME (asm_div) (void) __attribute__((__noinline__));\n+static void NAME (vector_div) (void) __attribute__((__noinline__));\n+static void NAME (scalar_div) (void) __attribute__((__noinline__));\n+static void NAME (asm_rsqrt) (void) __attribute__((__noinline__));\n+static void NAME (vector_rsqrt) (void) __attribute__((__noinline__));\n+static void NAME (scalar_rsqrt) (void) __attribute__((__noinline__));\n+static void NAME (check_div) (const char *) __attribute__((__noinline__));\n+static void NAME (check_rsqrt) (const char *) __attribute__((__noinline__));\n+static void NAME (run) (void) __attribute__((__noinline__));\n+\n+\f\n+/*\n+ * Division function that might be vectorized.\n+ */\n+\n+static void\n+NAME (vector_div) (void)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < DIV_SIZE; i++)\n+    NAME (div_output)[i] = ((TYPE) 1.0) / NAME (div_input)[i].x;\n+}\n+\n+/*\n+ * Division function that is not vectorized.\n+ */\n+\n+static void\n+NAME (scalar_div) (void)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < DIV_SIZE; i++)\n+    {\n+      TYPE x = ((TYPE) 1.0) / NAME (div_input)[i].x;\n+      TYPE y;\n+      __asm__ (\"\" : \"=d\" (y) : \"0\" (x));\n+      NAME (div_output)[i] = y;\n+    }\n+}\n+\n+/*\n+ * Generate the division instruction via asm.\n+ */\n+\n+static void\n+NAME (asm_div) (void)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < DIV_SIZE; i++)\n+    {\n+      TYPE x;\n+      __asm__ (ASMDIV \" %0,%1,%2\"\n+\t       : \"=d\" (x)\n+\t       : \"d\" ((TYPE) 1.0), \"d\" (NAME (div_input)[i].x));\n+      NAME (div_expected)[i] = x;\n+    }\n+}\n+\n+/*\n+ * Reciprocal square root function that might be vectorized.\n+ */\n+\n+static void\n+NAME (vector_rsqrt) (void)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < RSQRT_SIZE; i++)\n+    NAME (rsqrt_output)[i] = ((TYPE) 1.0) / SQRT (NAME (rsqrt_input)[i].x);\n+}\n+\n+/*\n+ * Reciprocal square root function that is not vectorized.\n+ */\n+\n+static void\n+NAME (scalar_rsqrt) (void)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < RSQRT_SIZE; i++)\n+    {\n+      TYPE x = ((TYPE) 1.0) / SQRT (NAME (rsqrt_input)[i].x);\n+      TYPE y;\n+      __asm__ (\"\" : \"=d\" (y) : \"0\" (x));\n+      NAME (rsqrt_output)[i] = y;\n+    }\n+}\n+\n+/*\n+ * Generate the 1/sqrt instructions via asm.\n+ */\n+\n+static void\n+NAME (asm_rsqrt) (void)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < RSQRT_SIZE; i++)\n+    {\n+      TYPE x;\n+      TYPE y;\n+      __asm__ (ASMSQRT \" %0,%1\" : \"=d\" (x) : \"d\" (NAME (rsqrt_input)[i].x));\n+      __asm__ (ASMDIV \" %0,%1,%2\" : \"=d\" (y) : \"d\" ((TYPE) 1.0), \"d\" (x));\n+      NAME (rsqrt_expected)[i] = y;\n+    }\n+}\n+\n+\f\n+/*\n+ * Functions to abort or report errors.\n+ */\n+\n+static int NAME (error_count) = 0;\n+\n+#ifdef VERBOSE\n+static int NAME (max_bits_div)   = 0;\n+static int NAME (max_bits_rsqrt) = 0;\n+#endif\n+\n+\f\n+/*\n+ * Compare the expected value with the value we got.\n+ */\n+\n+static void\n+NAME (check_div) (const char *test)\n+{\n+  size_t i;\n+  int b;\n+\n+  for (i = 0; i < DIV_SIZE; i++)\n+    {\n+      TYPE exp = NAME (div_expected)[i];\n+      TYPE out = NAME (div_output)[i];\n+      b = NAME (math_diff) (exp, out, BDIV);\n+\n+#ifdef VERBOSE\n+      if (b != 0)\n+\t{\n+\t  NAME (union) u_in = NAME (div_input)[i];\n+\t  NAME (union) u_exp;\n+\t  NAME (union) u_out;\n+\t  char explanation[64];\n+\t  const char *p_exp;\n+\n+\t  if (b < 0)\n+\t    p_exp = \"failed\";\n+\t  else\n+\t    {\n+\t      p_exp = explanation;\n+\t      sprintf (explanation, \"%d bit error%s\", b, (b > BDIV) ? \", failed\" : \"\");\n+\t    }\n+\n+\t  u_exp.x = exp;\n+\t  u_out.x = out;\n+\t  printf (\"%s %s %s for 1.0 / %g [0x%llx], expected %g [0x%llx], got %g [0x%llx]\\n\",\n+\t\t  TNAME (TYPE), test, p_exp,\n+\t\t  (double) u_in.x, (unsigned long long) u_in.i,\n+\t\t  (double) exp,    (unsigned long long) u_exp.i,\n+\t\t  (double) out,    (unsigned long long) u_out.i);\n+\t}\n+#endif\n+\n+      if (b < 0 || b > BDIV)\n+\tNAME (error_count)++;\n+\n+#ifdef VERBOSE\n+      if (b > NAME (max_bits_div))\n+\tNAME (max_bits_div) = b;\n+#endif\n+    }\n+}\n+\n+static void\n+NAME (check_rsqrt) (const char *test)\n+{\n+  size_t i;\n+  int b;\n+\n+  for (i = 0; i < RSQRT_SIZE; i++)\n+    {\n+      TYPE exp = NAME (rsqrt_expected)[i];\n+      TYPE out = NAME (rsqrt_output)[i];\n+      b = NAME (math_diff) (exp, out, BRSQRT);\n+\n+#ifdef VERBOSE\n+      if (b != 0)\n+\t{\n+\t  NAME (union) u_in = NAME (rsqrt_input)[i];\n+\t  NAME (union) u_exp;\n+\t  NAME (union) u_out;\n+\t  char explanation[64];\n+\t  const char *p_exp;\n+\n+\t  if (b < 0)\n+\t    p_exp = \"failed\";\n+\t  else\n+\t    {\n+\t      p_exp = explanation;\n+\t      sprintf (explanation, \"%d bit error%s\", b, (b > BDIV) ? \", failed\" : \"\");\n+\t    }\n+\n+\t  u_exp.x = exp;\n+\t  u_out.x = out;\n+\t  printf (\"%s %s %s for 1 / sqrt (%g) [0x%llx], expected %g [0x%llx], got %g [0x%llx]\\n\",\n+\t\t  TNAME (TYPE), test, p_exp,\n+\t\t  (double) u_in.x, (unsigned long long) u_in.i,\n+\t\t  (double) exp,    (unsigned long long) u_exp.i,\n+\t\t  (double) out,    (unsigned long long) u_out.i);\n+\t}\n+#endif\n+\n+      if (b < 0 || b > BRSQRT)\n+\tNAME (error_count)++;\n+\n+#ifdef VERBOSE\n+      if (b > NAME (max_bits_rsqrt))\n+\tNAME (max_bits_rsqrt) = b;\n+#endif\n+    }\n+}\n+\n+\f\n+/*\n+ * Now do everything.\n+ */\n+\n+static void\n+NAME (run) (void)\n+{\n+#ifdef VERBOSE\n+  printf (\"start run_%s, divide size = %ld, rsqrt size = %ld, %d bit%s for a/b, %d bit%s for 1/sqrt(a)\\n\",\n+\t  TNAME (TYPE),\n+\t  (long)DIV_SIZE,\n+\t  (long)RSQRT_SIZE,\n+\t  BDIV, (BDIV == 1) ? \"\" : \"s\",\n+\t  BRSQRT, (BRSQRT == 1) ? \"\" : \"s\");\n+#endif\n+\n+  NAME (asm_div) ();\n+\n+  NAME (scalar_div) ();\n+  NAME (check_div) (\"scalar\");\n+\n+  NAME (vector_div) ();\n+  NAME (check_div) (\"vector\");\n+\n+  NAME (asm_rsqrt) ();\n+\n+  NAME (scalar_rsqrt) ();\n+  NAME (check_rsqrt) (\"scalar\");\n+\n+  NAME (vector_rsqrt) ();\n+  NAME (check_rsqrt) (\"vector\");\n+\n+#ifdef VERBOSE\n+  printf (\"end run_%s, errors = %d, max div bits = %d, max rsqrt bits = %d\\n\",\n+\t  TNAME (TYPE),\n+\t  NAME (error_count),\n+\t  NAME (max_bits_div),\n+\t  NAME (max_bits_rsqrt));\n+#endif\n+}"}, {"sha": "6ad8c344585e0134c7b3ebd132e7e8cf73ba5243", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92902797041a42ac500f7dc9639df8a680e0b691/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=92902797041a42ac500f7dc9639df8a680e0b691", "patch": "@@ -992,6 +992,30 @@ proc check_vmx_hw_available { } {\n     }]\n }\n \n+proc check_ppc_recip_hw_available { } {\n+    return [check_cached_effective_target ppc_recip_hw_available {\n+\t# Some simulators may not support FRE/FRES/FRSQRTE/FRSQRTES\n+\t# For now, disable on Darwin\n+\tif { [istarget powerpc-*-eabi] || [istarget powerpc*-*-eabispe] || [istarget *-*-darwin*]} {\n+\t    expr 0\n+\t} else {\n+\t    set options \"-mpowerpc-gfxopt -mpowerpc-gpopt -mpopcntb\"\n+\t    check_runtime_nocache ppc_recip_hw_available {\n+\t\tvolatile double d_recip, d_rsqrt, d_four = 4.0;\n+\t\tvolatile float f_recip, f_rsqrt, f_four = 4.0f;\n+\t\tint main()\n+\t\t{\n+\t\t  asm volatile (\"fres %0,%1\" : \"=f\" (f_recip) : \"f\" (f_four));\n+\t\t  asm volatile (\"fre %0,%1\" : \"=d\" (d_recip) : \"d\" (d_four));\n+\t\t  asm volatile (\"frsqrtes %0,%1\" : \"=f\" (f_rsqrt) : \"f\" (f_four));\n+\t\t  asm volatile (\"frsqrte %0,%1\" : \"=f\" (d_rsqrt) : \"d\" (d_four));\n+\t\t  return 0;\n+\t\t}\n+\t    } $options\n+\t}\n+    }]\n+}\n+\n # Return 1 if the target supports executing AltiVec and Cell PPU\n # instructions, 0 otherwise.  Cache the result.\n \n@@ -2972,6 +2996,8 @@ proc is-effective-target { arg } {\n     } else {\n \tswitch $arg {\n \t  \"vmx_hw\"         { set selected [check_vmx_hw_available] }\n+\t  \"vsx_hw\"         { set selected [check_vsx_hw_available] }\n+\t  \"ppc_recip_hw\"   { set selected [check_ppc_recip_hw_available] }\n \t  \"named_sections\" { set selected [check_named_sections_available] }\n \t  \"gc_sections\"    { set selected [check_gc_sections_available] }\n \t  \"cxa_atexit\"     { set selected [check_cxa_atexit_available] }\n@@ -2991,6 +3017,8 @@ proc is-effective-target-keyword { arg } {\n \t# These have different names for their check_* procs.\n \tswitch $arg {\n \t  \"vmx_hw\"         { return 1 }\n+\t  \"vsx_hw\"         { return 1 }\n+\t  \"ppc_recip_hw\"   { return 1 }\n \t  \"named_sections\" { return 1 }\n \t  \"gc_sections\"    { return 1 }\n \t  \"cxa_atexit\"     { return 1 }"}]}