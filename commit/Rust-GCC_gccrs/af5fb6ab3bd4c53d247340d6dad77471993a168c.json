{"sha": "af5fb6ab3bd4c53d247340d6dad77471993a168c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY1ZmI2YWIzYmQ0YzUzZDI0NzM0MGQ2ZGFkNzc0NzE5OTNhMTY4Yw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-11-16T17:16:31Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-11-16T17:16:31Z"}, "message": "re PR libstdc++/8230 (Buggy allocator behaviour)\n\n\n2002-11-15  Benjamin Kosnik  <bkoz@redhat.com>\n            Gabriel Dos Reis  <gdr@integrable-solutions.net>\n\n\tPR libstdc++/8230\n\t* include/bits/stl_alloc.h: Use builtin_expect for the most\n\tobvious limit checks.\n\t(__default_alloc_template::allocate): Check for null, throw\n\tbad_alloc.\n\t* include/bits/vector.tcc: Formatting tweaks.\n\t* include/bits/stl_vector.h: Same.\n\t* testsuite/20_util/allocator_members.cc (test02): Add.\n\t* testsuite/23_containers/vector_capacity.cc (test03): Add.\n\nCo-Authored-By: Gabriel Dos Reis <gdr@integrable-solutions.net>\n\nFrom-SVN: r59169", "tree": {"sha": "9116ad3d6ab5006834ba2be5cc51cdeae19f0f3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9116ad3d6ab5006834ba2be5cc51cdeae19f0f3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af5fb6ab3bd4c53d247340d6dad77471993a168c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af5fb6ab3bd4c53d247340d6dad77471993a168c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af5fb6ab3bd4c53d247340d6dad77471993a168c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af5fb6ab3bd4c53d247340d6dad77471993a168c/comments", "author": null, "committer": null, "parents": [{"sha": "5dab517fa0e86ba726a45bf01a8a1cf8284bbfb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dab517fa0e86ba726a45bf01a8a1cf8284bbfb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dab517fa0e86ba726a45bf01a8a1cf8284bbfb1"}], "stats": {"total": 1866, "additions": 985, "deletions": 881}, "files": [{"sha": "69d6d1ba1baed4df2b4a3fd1af4165107b3c5a0c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=af5fb6ab3bd4c53d247340d6dad77471993a168c", "patch": "@@ -1,3 +1,16 @@\n+2002-11-15  Benjamin Kosnik  <bkoz@redhat.com>\n+            Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tPR libstdc++/8230\n+\t* include/bits/stl_alloc.h: Use builtin_expect for the most\n+\tobvious limit checks.\n+\t(__default_alloc_template::allocate): Check for null, throw\n+\tbad_alloc.\n+\t* include/bits/vector.tcc: Formatting tweaks.\n+\t* include/bits/stl_vector.h: Same.\t\n+\t* testsuite/20_util/allocator_members.cc (test02): Add.\n+\t* testsuite/23_containers/vector_capacity.cc (test03): Add.\n+\t\n 2002-11-15  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* src/ios.cc [_GLIBCPP_HAVE_UNISTD_H]: Include unistd.h."}, {"sha": "bab39fb7150cd208dcfc4721ad06768abbfc0aca", "filename": "libstdc++-v3/include/bits/stl_alloc.h", "status": "modified", "additions": 78, "deletions": 60, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h?ref=af5fb6ab3bd4c53d247340d6dad77471993a168c", "patch": "@@ -139,7 +139,8 @@ namespace std\n       allocate(size_t __n)\n       {\n         void* __result = malloc(__n);\n-        if (0 == __result) __result = _S_oom_malloc(__n);\n+        if (__builtin_expect(__result == 0, 0))\n+\t  __result = _S_oom_malloc(__n);\n         return __result;\n       }\n \n@@ -152,7 +153,7 @@ namespace std\n       reallocate(void* __p, size_t /* old_sz */, size_t __new_sz)\n       {\n         void* __result = realloc(__p, __new_sz);\n-        if (0 == __result)\n+        if (__builtin_expect(__result == 0, 0))\n           __result = _S_oom_realloc(__p, __new_sz);\n         return __result;\n       }\n@@ -181,8 +182,8 @@ namespace std\n       for (;;)\n         {\n           __my_malloc_handler = __malloc_alloc_oom_handler;\n-          if (0 == __my_malloc_handler)\n-            std::__throw_bad_alloc();\n+          if (__builtin_expect(__my_malloc_handler == 0, 0))\n+            __throw_bad_alloc();\n           (*__my_malloc_handler)();\n           __result = malloc(__n);\n           if (__result)\n@@ -202,8 +203,8 @@ namespace std\n       for (;;)\n         {\n           __my_malloc_handler = __malloc_alloc_oom_handler;\n-          if (0 == __my_malloc_handler)\n-            std::__throw_bad_alloc();\n+          if (__builtin_expect(__my_malloc_handler == 0, 0))\n+            __throw_bad_alloc();\n           (*__my_malloc_handler)();\n           __result = realloc(__p, __n);\n           if (__result)\n@@ -232,7 +233,12 @@ namespace std\n     public:\n       static _Tp*\n       allocate(size_t __n)\n-      { return 0 == __n ? 0 : (_Tp*) _Alloc::allocate(__n * sizeof (_Tp)); }\n+      {\n+\t_Tp* __ret = 0;\n+\tif (__n)\n+\t  __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n+\treturn __ret;\n+      }\n   \n       static _Tp*\n       allocate()\n@@ -293,9 +299,9 @@ namespace std\n       {\n         char* __real_p = (char*)__p - (int) _S_extra;\n         assert(*(size_t*)__real_p == __old_sz);\n-        char* __result = (char*)\n-          _Alloc::reallocate(__real_p, __old_sz + (int) _S_extra,\n-                             __new_sz + (int) _S_extra);\n+        char* __result = (char*) _Alloc::reallocate(__real_p, \n+\t\t\t\t\t\t    __old_sz + (int) _S_extra,\n+\t\t\t\t\t\t    __new_sz + (int) _S_extra);\n         *(size_t*)__result = __new_sz;\n         return __result + (int) _S_extra;\n       }\n@@ -362,7 +368,7 @@ namespace std\n \n       static size_t\n       _S_freelist_index(size_t __bytes)\n-      { return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1); }\n+      { return (((__bytes) + (size_t)_ALIGN - 1)/(size_t)_ALIGN - 1); }\n \n       // Returns an object of size __n, and optionally adds to size __n\n       // free list.\n@@ -402,7 +408,7 @@ namespace std\n \t    else\n \t      __atomic_add(&_S_force_new, -1);\n \t    // Trust but verify...\n-\t    assert (_S_force_new != 0);\n+\t    assert(_S_force_new != 0);\n \t  }\n \n \tif ((__n > (size_t) _MAX_BYTES) || (_S_force_new > 0))\n@@ -416,13 +422,15 @@ namespace std\n \t    // unwinding.\n \t    _Lock __lock_instance;\n \t    _Obj* __restrict__ __result = *__my_free_list;\n-\t    if (__result == 0)\n+\t    if (__builtin_expect(__result == 0, 0))\n \t      __ret = _S_refill(_S_round_up(__n));\n \t    else\n \t      {\n \t\t*__my_free_list = __result -> _M_free_list_link;\n \t\t__ret = __result;\n-\t      }\n+\t      }\t    \n+\t    if (__builtin_expect(__ret == 0, 0))\n+\t      __throw_bad_alloc();\n \t  }\n \treturn __ret;\n       }\n@@ -510,7 +518,7 @@ namespace std\n               *__my_free_list = (_Obj*)_S_start_free;\n             }\n           _S_start_free = (char*) __new_alloc::allocate(__bytes_to_get);\n-          if (0 == _S_start_free)\n+          if (_S_start_free == 0)\n             {\n               size_t __i;\n               _Obj* volatile* __my_free_list;\n@@ -523,7 +531,7 @@ namespace std\n                 {\n                   __my_free_list = _S_free_list + _S_freelist_index(__i);\n                   __p = *__my_free_list;\n-                  if (0 != __p)\n+                  if (__p != 0)\n                     {\n                       *__my_free_list = __p -> _M_free_list_link;\n                       _S_start_free = (char*)__p;\n@@ -569,17 +577,17 @@ namespace std\n       *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);\n       for (__i = 1; ; __i++)\n         {\n-          __current_obj = __next_obj;\n+\t  __current_obj = __next_obj;\n           __next_obj = (_Obj*)((char*)__next_obj + __n);\n-          if (__nobjs - 1 == __i)\n-            {\n-              __current_obj -> _M_free_list_link = 0;\n-              break;\n-            }\n-          else\n-            __current_obj -> _M_free_list_link = __next_obj;\n-        }\n-      return(__result);\n+\t  if (__nobjs - 1 == __i)\n+\t    {\n+\t      __current_obj -> _M_free_list_link = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    __current_obj -> _M_free_list_link = __next_obj;\n+\t}\n+      return __result;\n     }\n \n \n@@ -600,7 +608,7 @@ namespace std\n       __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;\n       memcpy(__result, __p, __copy_sz);\n       deallocate(__p, __old_sz);\n-      return(__result);\n+      return __result;\n     }\n #endif\n \n@@ -669,13 +677,20 @@ namespace std\n       const_pointer\n       address(const_reference __x) const { return &__x; }\n \n-      // __n is permitted to be 0.  The C++ standard says nothing about what\n-      // the return value is when __n == 0.\n+      // NB: __n is permitted to be 0.  The C++ standard says nothing\n+      // about what the return value is when __n == 0.\n       _Tp*\n       allocate(size_type __n, const void* = 0)\n       {\n-        return __n != 0\n-          ? static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp))) : 0;\n+\t_Tp* __ret = 0;\n+\tif (__n)\n+\t  {\n+\t    if (__n <= this->max_size())\n+\t      __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n+\t    else\n+\t      __throw_bad_alloc();\n+\t  }\n+\treturn __ret;\n       }\n \n       // __p is not permitted to be a null pointer.\n@@ -719,20 +734,21 @@ namespace std\n \n   /**\n    *  @if maint\n-   *  Allocator adaptor to turn an \"SGI\" style allocator (e.g., __alloc,\n-   *  __malloc_alloc_template) into a \"standard\" conforming allocator.  Note\n-   *  that this adaptor does *not* assume that all objects of the underlying\n-   *  alloc class are identical, nor does it assume that all of the underlying\n-   *  alloc's member functions are static member functions.  Note, also, that\n-   *  __allocator<_Tp, __alloc> is essentially the same thing as allocator<_Tp>.\n+   *  Allocator adaptor to turn an \"SGI\" style allocator (e.g.,\n+   *  __alloc, __malloc_alloc_template) into a \"standard\" conforming\n+   *  allocator.  Note that this adaptor does *not* assume that all\n+   *  objects of the underlying alloc class are identical, nor does it\n+   *  assume that all of the underlying alloc's member functions are\n+   *  static member functions.  Note, also, that __allocator<_Tp,\n+   *  __alloc> is essentially the same thing as allocator<_Tp>.\n    *  @endif\n    *  (See @link Allocators allocators info @endlink for more.)\n    */\n   template<typename _Tp, typename _Alloc>\n     struct __allocator\n     {\n       _Alloc __underlying_alloc;\n-\n+      \n       typedef size_t    size_type;\n       typedef ptrdiff_t difference_type;\n       typedef _Tp*       pointer;\n@@ -761,29 +777,31 @@ namespace std\n       const_pointer\n       address(const_reference __x) const { return &__x; }\n \n-    // __n is permitted to be 0.\n-    _Tp*\n-    allocate(size_type __n, const void* = 0)\n-    {\n-      return __n != 0\n-        ? static_cast<_Tp*>(__underlying_alloc.allocate(__n * sizeof(_Tp)))\n-        : 0;\n-    }\n-\n-    // __p is not permitted to be a null pointer.\n-    void\n-    deallocate(pointer __p, size_type __n)\n-    { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }\n-\n-    size_type\n-    max_size() const throw() { return size_t(-1) / sizeof(_Tp); }\n-\n-    void\n-    construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n+      // NB: __n is permitted to be 0.  The C++ standard says nothing\n+      // about what the return value is when __n == 0.\n+      _Tp*\n+      allocate(size_type __n, const void* = 0)\n+      {\n+\t_Tp* __ret = 0;\n+\tif (__n)\n+\t  __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n+\treturn __ret;\n+      }\n \n-    void\n-    destroy(pointer __p) { __p->~_Tp(); }\n-  };\n+      // __p is not permitted to be a null pointer.\n+      void\n+      deallocate(pointer __p, size_type __n)\n+      { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }\n+      \n+      size_type\n+      max_size() const throw() { return size_t(-1) / sizeof(_Tp); }\n+      \n+      void\n+      construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n+      \n+      void\n+      destroy(pointer __p) { __p->~_Tp(); }\n+    };\n \n   template<typename _Alloc>\n     struct __allocator<void, _Alloc>"}, {"sha": "53547322d651cb9f9a887f601eee7461d596ed7d", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 781, "deletions": 758, "changes": 1539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=af5fb6ab3bd4c53d247340d6dad77471993a168c", "patch": "@@ -73,92 +73,94 @@ namespace std\n    *  See bits/stl_deque.h's _Deque_alloc_base for an explanation.\n    *  @endif\n   */\n-  template <typename _Tp, typename _Allocator, bool _IsStatic>\n+  template<typename _Tp, typename _Allocator, bool _IsStatic>\n     class _Vector_alloc_base\n-  {\n-  public:\n-    typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-            allocator_type;\n-  \n-    allocator_type\n-    get_allocator() const { return _M_data_allocator; }\n+    {\n+    public:\n+      typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+      allocator_type;\n+\n+      allocator_type\n+      get_allocator() const { return _M_data_allocator; }\n   \n-    _Vector_alloc_base(const allocator_type& __a)\n+      _Vector_alloc_base(const allocator_type& __a)\n       : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n-    {}\n+      { }\n   \n-  protected:\n-    allocator_type _M_data_allocator;\n-    _Tp*           _M_start;\n-    _Tp*           _M_finish;\n-    _Tp*           _M_end_of_storage;\n+    protected:\n+      allocator_type _M_data_allocator;\n+      _Tp*           _M_start;\n+      _Tp*           _M_finish;\n+      _Tp*           _M_end_of_storage;\n   \n-    _Tp*\n-    _M_allocate(size_t __n) { return _M_data_allocator.allocate(__n); }\n+      _Tp*\n+      _M_allocate(size_t __n) { return _M_data_allocator.allocate(__n); }\n   \n-    void\n-    _M_deallocate(_Tp* __p, size_t __n)\n-    { if (__p) _M_data_allocator.deallocate(__p, __n); }\n-  };\n+      void\n+      _M_deallocate(_Tp* __p, size_t __n)\n+      { if (__p) _M_data_allocator.deallocate(__p, __n); }\n+    };\n   \n   /// @if maint Specialization for instanceless allocators.  @endif\n-  template <typename _Tp, typename _Allocator>\n+  template<typename _Tp, typename _Allocator>\n     class _Vector_alloc_base<_Tp, _Allocator, true>\n-  {\n-  public:\n-    typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-            allocator_type;\n-  \n-    allocator_type\n-    get_allocator() const { return allocator_type(); }\n-  \n-    _Vector_alloc_base(const allocator_type&)\n+    {\n+    public:\n+      typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+             allocator_type;\n+  \n+      allocator_type\n+      get_allocator() const { return allocator_type(); }\n+      \n+      _Vector_alloc_base(const allocator_type&)\n       : _M_start(0), _M_finish(0), _M_end_of_storage(0)\n-    {}\n-  \n-  protected:\n-    _Tp* _M_start;\n-    _Tp* _M_finish;\n-    _Tp* _M_end_of_storage;\n+      { }\n   \n-    typedef typename _Alloc_traits<_Tp, _Allocator>::_Alloc_type _Alloc_type;\n+    protected:\n+      _Tp* _M_start;\n+      _Tp* _M_finish;\n+      _Tp* _M_end_of_storage;\n   \n-    _Tp*\n-    _M_allocate(size_t __n) { return _Alloc_type::allocate(__n); }\n+      typedef typename _Alloc_traits<_Tp, _Allocator>::_Alloc_type _Alloc_type;\n+      \n+      _Tp*\n+      _M_allocate(size_t __n) { return _Alloc_type::allocate(__n); }\n   \n-    void\n-    _M_deallocate(_Tp* __p, size_t __n) { _Alloc_type::deallocate(__p, __n);}\n-  };\n+      void\n+      _M_deallocate(_Tp* __p, size_t __n) { _Alloc_type::deallocate(__p, __n);}\n+    };\n   \n   \n   /**\n    *  @if maint\n    *  See bits/stl_deque.h's _Deque_base for an explanation.\n    *  @endif\n   */\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     struct _Vector_base\n     : public _Vector_alloc_base<_Tp, _Alloc,\n                                 _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-  {\n-  public:\n-    typedef _Vector_alloc_base<_Tp, _Alloc,\n-                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-            _Base;\n-    typedef typename _Base::allocator_type allocator_type;\n-  \n-    _Vector_base(const allocator_type& __a)\n-      : _Base(__a) {}\n-    _Vector_base(size_t __n, const allocator_type& __a)\n-      : _Base(__a)\n     {\n-      _M_start = _M_allocate(__n);\n-      _M_finish = _M_start;\n-      _M_end_of_storage = _M_start + __n;\n-    }\n-  \n-    ~_Vector_base() { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }\n-  };\n+    public:\n+      typedef _Vector_alloc_base<_Tp, _Alloc,\n+\t\t\t\t _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+         _Base;\n+      typedef typename _Base::allocator_type allocator_type;\n+\n+      _Vector_base(const allocator_type& __a)\n+      : _Base(__a) { }\n+      \n+      _Vector_base(size_t __n, const allocator_type& __a)\n+      : _Base(__a)\n+      {\n+\t_M_start = _M_allocate(__n);\n+\t_M_finish = _M_start;\n+\t_M_end_of_storage = _M_start + __n;\n+      }\n+      \n+      ~_Vector_base() \n+      { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }\n+    };\n   \n   \n   /**\n@@ -179,723 +181,744 @@ namespace std\n    *  and saves the user from worrying about memory and size allocation.\n    *  Subscripting ( @c [] ) access is also provided as with C-style arrays.\n   */\n-  template <typename _Tp, typename _Alloc = allocator<_Tp> >\n+  template<typename _Tp, typename _Alloc = allocator<_Tp> >\n     class vector : protected _Vector_base<_Tp, _Alloc>\n-  {\n-    // concept requirements\n-    __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-  \n-    typedef _Vector_base<_Tp, _Alloc>                     _Base;\n-    typedef vector<_Tp, _Alloc>                           vector_type;\n-  \n-  public:\n-    typedef _Tp \t\t\t\t\t\tvalue_type;\n-    typedef value_type* \t\t\t\t\tpointer;\n-    typedef const value_type* \t\t\t\tconst_pointer;\n-    typedef __gnu_cxx::__normal_iterator<pointer, vector_type> \titerator;\n-    typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>\n-                                                          const_iterator;\n-    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n-    typedef std::reverse_iterator<iterator>                reverse_iterator;\n-    typedef value_type& \t\t\t\t\treference;\n-    typedef const value_type& \t\t\t\tconst_reference;\n-    typedef size_t \t\t\t\t\tsize_type;\n-    typedef ptrdiff_t \t\t\t\t\tdifference_type;\n-    typedef typename _Base::allocator_type                allocator_type;\n-  \n-  protected:\n-    /** @if maint\n-     *  These two functions and three data members are all from the top-most\n-     *  base class, which varies depending on the type of %allocator.  They\n-     *  should be pretty self-explanatory, as %vector uses a simple contiguous \n-     *  allocation scheme.\n-     *  @endif\n-    */\n-    using _Base::_M_allocate;\n-    using _Base::_M_deallocate;\n-    using _Base::_M_start;\n-    using _Base::_M_finish;\n-    using _Base::_M_end_of_storage;\n-  \n-  public:\n-    // [23.2.4.1] construct/copy/destroy\n-    // (assign() and get_allocator() are also listed in this section)\n-    /**\n-     *  @brief  Default constructor creates no elements.\n-    */\n-    explicit\n-    vector(const allocator_type& __a = allocator_type())\n-      : _Base(__a) {}\n-  \n-    /**\n-     *  @brief  Create a %vector with copies of an exemplar element.\n-     *  @param  n  The number of elements to initially create.\n-     *  @param  value  An element to copy.\n-     * \n-     *  This constructor fills the %vector with @a n copies of @a value.\n-    */\n-    vector(size_type __n, const value_type& __value,\n-           const allocator_type& __a = allocator_type())\n+    {\n+      // Concept requirements.\n+      __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n+  \n+      typedef _Vector_base<_Tp, _Alloc>                     _Base;\n+      typedef vector<_Tp, _Alloc>                           vector_type;\n+  \n+    public:\n+      typedef _Tp \t\t\t\t\t\tvalue_type;\n+      typedef value_type* \t\t\t\t\tpointer;\n+      typedef const value_type* \t\t\t\tconst_pointer;\n+      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;\n+      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>\n+      const_iterator;\n+      typedef std::reverse_iterator<const_iterator>    \tconst_reverse_iterator;\n+      typedef std::reverse_iterator<iterator>                reverse_iterator;\n+      typedef value_type& \t\t\t\t\treference;\n+      typedef const value_type& \t\t\t\tconst_reference;\n+      typedef size_t \t\t\t\t\tsize_type;\n+      typedef ptrdiff_t \t\t\t\t\tdifference_type;\n+      typedef typename _Base::allocator_type                allocator_type;\n+      \n+    protected:\n+      /** @if maint\n+       *  These two functions and three data members are all from the\n+       *  top-most base class, which varies depending on the type of\n+       *  %allocator.  They should be pretty self-explanatory, as\n+       *  %vector uses a simple contiguous allocation scheme.  @endif\n+       */\n+      using _Base::_M_allocate;\n+      using _Base::_M_deallocate;\n+      using _Base::_M_start;\n+      using _Base::_M_finish;\n+      using _Base::_M_end_of_storage;\n+      \n+    public:\n+      // [23.2.4.1] construct/copy/destroy\n+      // (assign() and get_allocator() are also listed in this section)\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n+      explicit\n+      vector(const allocator_type& __a = allocator_type())\n+      : _Base(__a) { }\n+  \n+      /**\n+       *  @brief  Create a %vector with copies of an exemplar element.\n+       *  @param  n  The number of elements to initially create.\n+       *  @param  value  An element to copy.\n+       * \n+       *  This constructor fills the %vector with @a n copies of @a value.\n+       */\n+      vector(size_type __n, const value_type& __value,\n+\t     const allocator_type& __a = allocator_type())\n       : _Base(__n, __a)\n       { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }\n   \n-    /**\n-     *  @brief  Create a %vector with default elements.\n-     *  @param  n  The number of elements to initially create.\n-     * \n-     *  This constructor fills the %vector with @a n copies of a\n-     *  default-constructed element.\n-    */\n-    explicit\n-    vector(size_type __n)\n+      /**\n+       *  @brief  Create a %vector with default elements.\n+       *  @param  n  The number of elements to initially create.\n+       * \n+       *  This constructor fills the %vector with @a n copies of a\n+       *  default-constructed element.\n+       */\n+      explicit\n+      vector(size_type __n)\n       : _Base(__n, allocator_type())\n       { _M_finish = uninitialized_fill_n(_M_start, __n, value_type()); }\n-  \n-    /**\n-     *  @brief  %Vector copy constructor.\n-     *  @param  x  A %vector of identical element and allocator types.\n-     * \n-     *  The newly-created %vector uses a copy of the allocation object used\n-     *  by @a x.  All the elements of @a x are copied, but any extra memory in\n-     *  @a x (for fast expansion) will not be copied.\n-    */\n-    vector(const vector& __x)\n+      \n+      /**\n+       *  @brief  %Vector copy constructor.\n+       *  @param  x  A %vector of identical element and allocator types.\n+       * \n+       *  The newly-created %vector uses a copy of the allocation\n+       *  object used by @a x.  All the elements of @a x are copied,\n+       *  but any extra memory in\n+       *  @a x (for fast expansion) will not be copied.\n+       */\n+      vector(const vector& __x)\n       : _Base(__x.size(), __x.get_allocator())\n       { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n   \n-    /**\n-     *  @brief  Builds a %vector from a range.\n-     *  @param  first  An input iterator.\n-     *  @param  last  An input iterator.\n-     * \n-     *  Create a %vector consisting of copies of the elements from [first,last).\n-     *\n-     *  If the iterators are forward, bidirectional, or random-access, then\n-     *  this will call the elements' copy constructor N times (where N is\n-     *  distance(first,last)) and do no memory reallocation.  But if only\n-     *  input iterators are used, then this will do at most 2N calls to the\n-     *  copy constructor, and logN memory reallocations.\n-    */\n-    template <typename _InputIterator>\n-      vector(_InputIterator __first, _InputIterator __last,\n-             const allocator_type& __a = allocator_type())\n-        : _Base(__a)\n-      {\n-        // Check whether it's an integral type.  If so, it's not an iterator.\n-        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-        _M_initialize_dispatch(__first, __last, _Integral());\n-      }\n-  \n-    /**\n-     *  The dtor only erases the elements, and note that if the elements\n-     *  themselves are pointers, the pointed-to memory is not touched in any\n-     *  way.  Managing the pointer is the user's responsibilty.\n-    */\n-    ~vector() { _Destroy(_M_start, _M_finish); }\n-  \n-    /**\n-     *  @brief  %Vector assignment operator.\n-     *  @param  x  A %vector of identical element and allocator types.\n-     * \n-     *  All the elements of @a x are copied, but any extra memory in @a x (for\n-     *  fast expansion) will not be copied.  Unlike the copy constructor, the\n-     *  allocator object is not copied.\n-    */\n-    vector&\n-    operator=(const vector& __x);\n-  \n-    /**\n-     *  @brief  Assigns a given value to a %vector.\n-     *  @param  n  Number of elements to be assigned.\n-     *  @param  val  Value to be assigned.\n-     *\n-     *  This function fills a %vector with @a n copies of the given value.\n-     *  Note that the assignment completely changes the %vector and that the\n-     *  resulting %vector's size is the same as the number of elements assigned.\n-     *  Old data may be lost.\n-    */\n-    void\n-    assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }\n-  \n-    /**\n-     *  @brief  Assigns a range to a %vector.\n-     *  @param  first  An input iterator.\n-     *  @param  last   An input iterator.\n-     *\n-     *  This function fills a %vector with copies of the elements in the\n-     *  range [first,last).\n-     *\n-     *  Note that the assignment completely changes the %vector and that the\n-     *  resulting %vector's size is the same as the number of elements assigned.\n-     *  Old data may be lost.\n-    */\n-    template<typename _InputIterator>\n-      void\n-      assign(_InputIterator __first, _InputIterator __last)\n-      {\n-        // Check whether it's an integral type.  If so, it's not an iterator.\n-        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-        _M_assign_dispatch(__first, __last, _Integral());\n-      }\n-  \n-    /// Get a copy of the memory allocation object.\n-    allocator_type\n-    get_allocator() const { return _Base::get_allocator(); }\n-  \n-    // iterators\n-    /**\n-     *  Returns a read/write iterator that points to the first element in the\n-     *  %vector.  Iteration is done in ordinary element order.\n-    */\n-    iterator\n-    begin() { return iterator (_M_start); }\n-  \n-    /**\n-     *  Returns a read-only (constant) iterator that points to the first element\n-     *  in the %vector.  Iteration is done in ordinary element order.\n-    */\n-    const_iterator\n-    begin() const { return const_iterator (_M_start); }\n-  \n-    /**\n-     *  Returns a read/write iterator that points one past the last element in\n-     *  the %vector.  Iteration is done in ordinary element order.\n-    */\n-    iterator\n-    end() { return iterator (_M_finish); }\n-  \n-    /**\n-     *  Returns a read-only (constant) iterator that points one past the last\n-     *  element in the %vector.  Iteration is done in ordinary element order.\n-    */\n-    const_iterator\n-    end() const { return const_iterator (_M_finish); }\n-  \n-    /**\n-     *  Returns a read/write reverse iterator that points to the last element in\n-     *  the %vector.  Iteration is done in reverse element order.\n-    */\n-    reverse_iterator\n-    rbegin() { return reverse_iterator(end()); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reverse iterator that points to the last\n-     *  element in the %vector.  Iteration is done in reverse element order.\n-    */\n-    const_reverse_iterator\n-    rbegin() const { return const_reverse_iterator(end()); }\n-  \n-    /**\n-     *  Returns a read/write reverse iterator that points to one before the\n-     *  first element in the %vector.  Iteration is done in reverse element\n-     *  order.\n-    */\n-    reverse_iterator\n-    rend() { return reverse_iterator(begin()); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reverse iterator that points to one\n-     *  before the first element in the %vector.  Iteration is done in reverse\n-     *  element order.\n-    */\n-    const_reverse_iterator\n-    rend() const { return const_reverse_iterator(begin()); }\n-  \n-    // [23.2.4.2] capacity\n-    /**  Returns the number of elements in the %vector.  */\n-    size_type\n-    size() const { return size_type(end() - begin()); }\n-  \n-    /**  Returns the size() of the largest possible %vector.  */\n-    size_type\n-    max_size() const { return size_type(-1) / sizeof(value_type); }\n-  \n-    /**\n-     *  @brief  Resizes the %vector to the specified number of elements.\n-     *  @param  new_size  Number of elements the %vector should contain.\n-     *  @param  x  Data with which new elements should be populated.\n-     *\n-     *  This function will %resize the %vector to the specified number of\n-     *  elements.  If the number is smaller than the %vector's current size the\n-     *  %vector is truncated, otherwise the %vector is extended and new elements\n-     *  are populated with given data.\n-    */\n-    void\n-    resize(size_type __new_size, const value_type& __x)\n-    {\n-      if (__new_size < size())\n-        erase(begin() + __new_size, end());\n-      else\n-        insert(end(), __new_size - size(), __x);\n-    }\n-  \n-    /**\n-     *  @brief  Resizes the %vector to the specified number of elements.\n-     *  @param  new_size  Number of elements the %vector should contain.\n-     *\n-     *  This function will resize the %vector to the specified number of\n-     *  elements.  If the number is smaller than the %vector's current size the\n-     *  %vector is truncated, otherwise the %vector is extended and new elements\n-     *  are default-constructed.\n-    */\n-    void\n-    resize(size_type __new_size) { resize(__new_size, value_type()); }\n-  \n-    /**\n-     *  Returns the total number of elements that the %vector can hold before\n-     *  needing to allocate more memory.\n-    */\n-    size_type\n-    capacity() const\n-    { return size_type(const_iterator(_M_end_of_storage) - begin()); }\n-  \n-    /**\n-     *  Returns true if the %vector is empty.  (Thus begin() would equal end().)\n-    */\n-    bool\n-    empty() const { return begin() == end(); }\n-  \n-    /**\n-     *  @brief  Attempt to preallocate enough memory for specified number of\n-     *          elements.\n-     *  @param  n  Number of elements required.\n-     *  @throw  std::length_error  If @a n exceeds @c max_size().\n-     *\n-     *  This function attempts to reserve enough memory for the %vector to hold\n-     *  the specified number of elements.  If the number requested is more than\n-     *  max_size(), length_error is thrown.\n-     *\n-     *  The advantage of this function is that if optimal code is a necessity\n-     *  and the user can determine the number of elements that will be required,\n-     *  the user can reserve the memory in %advance, and thus prevent a possible\n-     *  reallocation of memory and copying of %vector data.\n-    */\n-    void\n-    reserve(size_type __n);\n-  \n-    // element access\n-    /**\n-     *  @brief  Subscript access to the data contained in the %vector.\n-     *  @param  n  The index of the element for which data should be accessed.\n-     *  @return  Read/write reference to data.\n-     *\n-     *  This operator allows for easy, array-style, data access.\n-     *  Note that data access with this operator is unchecked and out_of_range\n-     *  lookups are not defined. (For checked lookups see at().)\n-    */\n-    reference\n-    operator[](size_type __n) { return *(begin() + __n); }\n-  \n-    /**\n-     *  @brief  Subscript access to the data contained in the %vector.\n-     *  @param  n  The index of the element for which data should be accessed.\n-     *  @return  Read-only (constant) reference to data.\n-     *\n-     *  This operator allows for easy, array-style, data access.\n-     *  Note that data access with this operator is unchecked and out_of_range\n-     *  lookups are not defined. (For checked lookups see at().)\n-    */\n-    const_reference\n-    operator[](size_type __n) const { return *(begin() + __n); }\n-  \n-  protected:\n-    /// @if maint Safety check used only from at().  @endif\n-    void\n-    _M_range_check(size_type __n) const\n-    {\n-      if (__n >= this->size())\n-        __throw_out_of_range(\"vector [] access out of range\");\n-    }\n-  \n-  public:\n-    /**\n-     *  @brief  Provides access to the data contained in the %vector.\n-     *  @param  n  The index of the element for which data should be accessed.\n-     *  @return  Read/write reference to data.\n-     *  @throw  std::out_of_range  If @a n is an invalid index.\n-     *\n-     *  This function provides for safer data access.  The parameter is first\n-     *  checked that it is in the range of the vector.  The function throws\n-     *  out_of_range if the check fails.\n-    */\n-    reference\n-    at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }\n-  \n-    /**\n-     *  @brief  Provides access to the data contained in the %vector.\n-     *  @param  n  The index of the element for which data should be accessed.\n-     *  @return  Read-only (constant) reference to data.\n-     *  @throw  std::out_of_range  If @a n is an invalid index.\n-     *\n-     *  This function provides for safer data access.  The parameter is first\n-     *  checked that it is in the range of the vector.  The function throws\n-     *  out_of_range if the check fails.\n-    */\n-    const_reference\n-    at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }\n-  \n-    /**\n-     *  Returns a read/write reference to the data at the first element of the\n-     *  %vector.\n-    */\n-    reference\n-    front() { return *begin(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reference to the data at the first\n-     *  element of the %vector.\n-    */\n-    const_reference\n-    front() const { return *begin(); }\n-  \n-    /**\n-     *  Returns a read/write reference to the data at the last element of the\n-     *  %vector.\n-    */\n-    reference\n-    back() { return *(end() - 1); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reference to the data at the last\n-     *  element of the %vector.\n-    */\n-    const_reference\n-    back() const { return *(end() - 1); }\n-  \n-    // [23.2.4.3] modifiers\n-    /**\n-     *  @brief  Add data to the end of the %vector.\n-     *  @param  x  Data to be added.\n-     *\n-     *  This is a typical stack operation.  The function creates an element at\n-     *  the end of the %vector and assigns the given data to it.\n-     *  Due to the nature of a %vector this operation can be done in constant\n-     *  time if the %vector has preallocated space available.\n-    */\n-    void\n-    push_back(const value_type& __x)\n-    {\n-      if (_M_finish != _M_end_of_storage)\n-      {\n-        _Construct(_M_finish, __x);\n-        ++_M_finish;\n-      }\n-      else\n-        _M_insert_aux(end(), __x);\n-    }\n-  \n-    /**\n-     *  @brief  Removes last element.\n-     *\n-     *  This is a typical stack operation. It shrinks the %vector by one.\n-     *\n-     *  Note that no data is returned, and if the last element's data is\n-     *  needed, it should be retrieved before pop_back() is called.\n-    */\n-    void\n-    pop_back()\n-    {\n-      --_M_finish;\n-      _Destroy(_M_finish);\n-    }\n-  \n-    /**\n-     *  @brief  Inserts given value into %vector before specified iterator.\n-     *  @param  position  An iterator into the %vector.\n-     *  @param  x  Data to be inserted.\n-     *  @return  An iterator that points to the inserted data.\n-     *\n-     *  This function will insert a copy of the given value before the specified\n-     *  location.\n-     *  Note that this kind of operation could be expensive for a %vector and if\n-     *  it is frequently used the user should consider using std::list.\n-    */\n-    iterator\n-    insert(iterator __position, const value_type& __x);\n-  \n-  #ifdef _GLIBCPP_DEPRECATED\n-    /**\n-     *  @brief  Inserts an element into the %vector.\n-     *  @param  position  An iterator into the %vector.\n-     *  @return  An iterator that points to the inserted element.\n-     *\n-     *  This function will insert a default-constructed element before the\n-     *  specified location.  You should consider using\n-     *  insert(position,value_type()) instead.\n-     *  Note that this kind of operation could be expensive for a vector and if\n-     *  it is frequently used the user should consider using std::list.\n-     *\n-     *  @note This was deprecated in 3.2 and will be removed in 3.4.  You must\n-     *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n-     *        c++config.h.\n-    */\n-    iterator\n-    insert(iterator __position)\n-    { return insert(__position, value_type()); }\n-  #endif\n-  \n-    /**\n-     *  @brief  Inserts a number of copies of given data into the %vector.\n-     *  @param  position  An iterator into the %vector.\n-     *  @param  n  Number of elements to be inserted.\n-     *  @param  x  Data to be inserted.\n-     *\n-     *  This function will insert a specified number of copies of the given data\n-     *  before the location specified by @a position.\n-     *\n-     *  Note that this kind of operation could be expensive for a %vector and if\n-     *  it is frequently used the user should consider using std::list.\n-    */\n-    void\n-    insert (iterator __pos, size_type __n, const value_type& __x)\n-    { _M_fill_insert(__pos, __n, __x); }\n-  \n-    /**\n-     *  @brief  Inserts a range into the %vector.\n-     *  @param  pos  An iterator into the %vector.\n-     *  @param  first  An input iterator.\n-     *  @param  last   An input iterator.\n-     *\n-     *  This function will insert copies of the data in the range [first,last)\n-     *  into the %vector before the location specified by @a pos.\n-     *\n-     *  Note that this kind of operation could be expensive for a %vector and if\n-     *  it is frequently used the user should consider using std::list.\n-    */\n-    template<typename _InputIterator>\n-      void\n-      insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n-        {\n-          // Check whether it's an integral type.  If so, it's not an iterator.\n-          typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-          _M_insert_dispatch(__pos, __first, __last, _Integral());\n-        }\n-  \n-    /**\n-     *  @brief  Remove element at given position.\n-     *  @param  position  Iterator pointing to element to be erased.\n-     *  @return  An iterator pointing to the next element (or end()).\n-     *\n-     *  This function will erase the element at the given position and thus\n-     *  shorten the %vector by one.\n-     *\n-     *  Note This operation could be expensive and if it is frequently used the\n-     *  user should consider using std::list.  The user is also cautioned that\n-     *  this function only erases the element, and that if the element is itself\n-     *  a pointer, the pointed-to memory is not touched in any way.  Managing\n-     *  the pointer is the user's responsibilty.\n-    */\n-    iterator\n-    erase(iterator __position);\n-  \n-    /**\n-     *  @brief  Remove a range of elements.\n-     *  @param  first  Iterator pointing to the first element to be erased.\n-     *  @param  last  Iterator pointing to one past the last element to be\n-     *                erased.\n-     *  @return  An iterator pointing to the element pointed to by @a last\n-     *           prior to erasing (or end()).\n-     *\n-     *  This function will erase the elements in the range [first,last) and\n-     *  shorten the %vector accordingly.\n-     *\n-     *  Note This operation could be expensive and if it is frequently used the\n-     *  user should consider using std::list.  The user is also cautioned that\n-     *  this function only erases the elements, and that if the elements\n-     *  themselves are pointers, the pointed-to memory is not touched in any\n-     *  way.  Managing the pointer is the user's responsibilty.\n-    */\n-    iterator\n-    erase(iterator __first, iterator __last);\n-  \n-    /**\n-     *  @brief  Swaps data with another %vector.\n-     *  @param  x  A %vector of the same element and allocator types.\n-     *\n-     *  This exchanges the elements between two vectors in constant time.\n-     *  (Three pointers, so it should be quite fast.)\n-     *  Note that the global std::swap() function is specialized such that\n-     *  std::swap(v1,v2) will feed to this function.\n-    */\n-    void\n-    swap(vector& __x)\n-    {\n-      std::swap(_M_start, __x._M_start);\n-      std::swap(_M_finish, __x._M_finish);\n-      std::swap(_M_end_of_storage, __x._M_end_of_storage);\n-    }\n-  \n-    /**\n-     *  Erases all the elements.  Note that this function only erases the\n-     *  elements, and that if the elements themselves are pointers, the\n-     *  pointed-to memory is not touched in any way.  Managing the pointer is\n-     *  the user's responsibilty.\n-    */\n-    void\n-    clear() { erase(begin(), end()); }\n-  \n-  protected:\n-    /**\n-     *  @if maint\n-     *  Memory expansion handler.  Uses the member allocation function to\n-     *  obtain @a n bytes of memory, and then copies [first,last) into it.\n-     *  @endif\n-    */\n-    template <typename _ForwardIterator>\n-    pointer\n-      _M_allocate_and_copy(size_type __n,\n-                           _ForwardIterator __first, _ForwardIterator __last)\n-    {\n-      pointer __result = _M_allocate(__n);\n-      try\n+      /**\n+       *  @brief  Builds a %vector from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       * \n+       *  Create a %vector consisting of copies of the elements from\n+       *  [first,last).\n+       *\n+       *  If the iterators are forward, bidirectional, or random-access, then\n+       *  this will call the elements' copy constructor N times (where N is\n+       *  distance(first,last)) and do no memory reallocation.  But if only\n+       *  input iterators are used, then this will do at most 2N calls to the\n+       *  copy constructor, and logN memory reallocations.\n+       */\n+      template<typename _InputIterator>\n+        vector(_InputIterator __first, _InputIterator __last,\n+\t       const allocator_type& __a = allocator_type())\n+\t: _Base(__a)\n         {\n-          uninitialized_copy(__first, __last, __result);\n-          return __result;\n-        }\n-      catch(...)\n+\t  // Check whether it's an integral type.  If so, it's not an iterator.\n+\t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t  _M_initialize_dispatch(__first, __last, _Integral());\n+\t}\n+      \n+      /**\n+       *  The dtor only erases the elements, and note that if the elements\n+       *  themselves are pointers, the pointed-to memory is not touched in any\n+       *  way.  Managing the pointer is the user's responsibilty.\n+       */\n+      ~vector() { _Destroy(_M_start, _M_finish); }\n+  \n+      /**\n+       *  @brief  %Vector assignment operator.\n+       *  @param  x  A %vector of identical element and allocator types.\n+       * \n+       *  All the elements of @a x are copied, but any extra memory in\n+       *  @a x (for fast expansion) will not be copied.  Unlike the\n+       *  copy constructor, the allocator object is not copied.\n+       */\n+      vector&\n+      operator=(const vector& __x);\n+  \n+      /**\n+       *  @brief  Assigns a given value to a %vector.\n+       *  @param  n  Number of elements to be assigned.\n+       *  @param  val  Value to be assigned.\n+       *\n+       *  This function fills a %vector with @a n copies of the given\n+       *  value.  Note that the assignment completely changes the\n+       *  %vector and that the resulting %vector's size is the same as\n+       *  the number of elements assigned.  Old data may be lost.\n+       */\n+      void\n+      assign(size_type __n, const value_type& __val) \n+      { _M_fill_assign(__n, __val); }\n+  \n+      /**\n+       *  @brief  Assigns a range to a %vector.\n+       *  @param  first  An input iterator.\n+       *  @param  last   An input iterator.\n+       *\n+       *  This function fills a %vector with copies of the elements in the\n+       *  range [first,last).\n+       *\n+       *  Note that the assignment completely changes the %vector and\n+       *  that the resulting %vector's size is the same as the number\n+       *  of elements assigned.  Old data may be lost.\n+       */\n+      template<typename _InputIterator>\n+        void\n+        assign(_InputIterator __first, _InputIterator __last)\n         {\n-  \t_M_deallocate(__result, __n);\n-  \t__throw_exception_again;\n-        }\n-    }\n-  \n-  \n-    // Internal constructor functions follow.\n-  \n-    // called by the range constructor to implement [23.1.1]/9\n-    template<typename _Integer>\n+\t  // Check whether it's an integral type.  If so, it's not an iterator.\n+\t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t  _M_assign_dispatch(__first, __last, _Integral());\n+\t}\n+  \n+      /// Get a copy of the memory allocation object.\n+      allocator_type\n+      get_allocator() const { return _Base::get_allocator(); }\n+      \n+      // iterators\n+      /**\n+       *  Returns a read/write iterator that points to the first element in the\n+       *  %vector.  Iteration is done in ordinary element order.\n+       */\n+      iterator\n+      begin() { return iterator (_M_start); }\n+      \n+      /**\n+       *  Returns a read-only (constant) iterator that points to the\n+       *  first element in the %vector.  Iteration is done in ordinary\n+       *  element order.\n+       */\n+      const_iterator\n+      begin() const { return const_iterator (_M_start); }\n+      \n+      /**\n+       *  Returns a read/write iterator that points one past the last\n+       *  element in the %vector.  Iteration is done in ordinary\n+       *  element order.\n+       */\n+      iterator\n+      end() { return iterator (_M_finish); }\n+      \n+      /**\n+       *  Returns a read-only (constant) iterator that points one past the last\n+       *  element in the %vector.  Iteration is done in ordinary element order.\n+       */\n+      const_iterator\n+      end() const { return const_iterator (_M_finish); }\n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to the\n+       *  last element in the %vector.  Iteration is done in reverse\n+       *  element order.\n+       */\n+      reverse_iterator\n+      rbegin() { return reverse_iterator(end()); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points\n+       *  to the last element in the %vector.  Iteration is done in\n+       *  reverse element order.\n+       */\n+      const_reverse_iterator\n+      rbegin() const { return const_reverse_iterator(end()); }\n+      \n+      /**\n+       *  Returns a read/write reverse iterator that points to one before the\n+       *  first element in the %vector.  Iteration is done in reverse element\n+       *  order.\n+       */\n+      reverse_iterator\n+      rend() { return reverse_iterator(begin()); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points\n+       *  to one before the first element in the %vector.  Iteration\n+       *  is done in reverse element order.\n+       */\n+      const_reverse_iterator\n+      rend() const { return const_reverse_iterator(begin()); }\n+  \n+      // [23.2.4.2] capacity\n+      /**  Returns the number of elements in the %vector.  */\n+      size_type\n+      size() const { return size_type(end() - begin()); }\n+      \n+      /**  Returns the size() of the largest possible %vector.  */\n+      size_type\n+      max_size() const { return size_type(-1) / sizeof(value_type); }\n+      \n+      /**\n+       *  @brief  Resizes the %vector to the specified number of elements.\n+       *  @param  new_size  Number of elements the %vector should contain.\n+       *  @param  x  Data with which new elements should be populated.\n+       *\n+       *  This function will %resize the %vector to the specified\n+       *  number of elements.  If the number is smaller than the\n+       *  %vector's current size the %vector is truncated, otherwise\n+       *  the %vector is extended and new elements are populated with\n+       *  given data.\n+       */\n       void\n-      _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n+      resize(size_type __new_size, const value_type& __x)\n       {\n-        _M_start = _M_allocate(__n);\n-        _M_end_of_storage = _M_start + __n;\n-        _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n+\tif (__new_size < size())\n+\t  erase(begin() + __new_size, end());\n+\telse\n+\t  insert(end(), __new_size - size(), __x);\n       }\n-  \n-    // called by the range constructor to implement [23.1.1]/9\n-    template<typename _InputIter>\n+      \n+      /**\n+       *  @brief  Resizes the %vector to the specified number of elements.\n+       *  @param  new_size  Number of elements the %vector should contain.\n+       *\n+       *  This function will resize the %vector to the specified\n+       *  number of elements.  If the number is smaller than the\n+       *  %vector's current size the %vector is truncated, otherwise\n+       *  the %vector is extended and new elements are\n+       *  default-constructed.\n+       */\n+      void\n+      resize(size_type __new_size) { resize(__new_size, value_type()); }\n+      \n+      /**\n+       *  Returns the total number of elements that the %vector can hold before\n+       *  needing to allocate more memory.\n+       */\n+      size_type\n+      capacity() const\n+      { return size_type(const_iterator(_M_end_of_storage) - begin()); }\n+      \n+      /**\n+       *  Returns true if the %vector is empty.  (Thus begin() would\n+       *  equal end().)\n+       */\n+      bool\n+      empty() const { return begin() == end(); }\n+      \n+      /**\n+       *  @brief  Attempt to preallocate enough memory for specified number of\n+       *          elements.\n+       *  @param  n  Number of elements required.\n+       *  @throw  std::length_error  If @a n exceeds @c max_size().\n+       *\n+       *  This function attempts to reserve enough memory for the\n+       *  %vector to hold the specified number of elements.  If the\n+       *  number requested is more than max_size(), length_error is\n+       *  thrown.\n+       *\n+       *  The advantage of this function is that if optimal code is a\n+       *  necessity and the user can determine the number of elements\n+       *  that will be required, the user can reserve the memory in\n+       *  %advance, and thus prevent a possible reallocation of memory\n+       *  and copying of %vector data.\n+       */\n+      void\n+      reserve(size_type __n);\n+      \n+      // element access\n+      /**\n+       *  @brief  Subscript access to the data contained in the %vector.\n+       *  @param  n  The index of the element for which data should be accessed.\n+       *  @return  Read/write reference to data.\n+       *\n+       *  This operator allows for easy, array-style, data access.\n+       *  Note that data access with this operator is unchecked and\n+       *  out_of_range lookups are not defined. (For checked lookups\n+       *  see at().)\n+       */\n+      reference\n+      operator[](size_type __n) { return *(begin() + __n); }\n+      \n+      /**\n+       *  @brief  Subscript access to the data contained in the %vector.\n+       *  @param n The index of the element for which data should be\n+       *  accessed.\n+       *  @return  Read-only (constant) reference to data.\n+       *\n+       *  This operator allows for easy, array-style, data access.\n+       *  Note that data access with this operator is unchecked and\n+       *  out_of_range lookups are not defined. (For checked lookups\n+       *  see at().)\n+       */\n+      const_reference\n+      operator[](size_type __n) const { return *(begin() + __n); }\n+  \n+    protected:\n+      /// @if maint Safety check used only from at().  @endif\n       void\n-      _M_initialize_dispatch(_InputIter __first, _InputIter __last,\n-\t                     __false_type)\n+      _M_range_check(size_type __n) const\n       {\n-        typedef typename iterator_traits<_InputIter>::iterator_category\n-                         _IterCategory;\n-        _M_range_initialize(__first, __last, _IterCategory());\n+\tif (__n >= this->size())\n+\t  __throw_out_of_range(\"vector [] access out of range\");\n       }\n-  \n-    // called by the second initialize_dispatch above\n-    template <typename _InputIterator>\n-    void\n-      _M_range_initialize(_InputIterator __first,\n-                          _InputIterator __last, input_iterator_tag)\n-    {\n-      for ( ; __first != __last; ++__first)\n-        push_back(*__first);\n-    }\n-  \n-    // called by the second initialize_dispatch above\n-    template <typename _ForwardIterator>\n-    void _M_range_initialize(_ForwardIterator __first,\n-                             _ForwardIterator __last, forward_iterator_tag)\n-    {\n-      size_type __n = distance(__first, __last);\n-      _M_start = _M_allocate(__n);\n-      _M_end_of_storage = _M_start + __n;\n-      _M_finish = uninitialized_copy(__first, __last, _M_start);\n-    }\n-  \n-  \n-    // Internal assign functions follow.  The *_aux functions do the actual\n-    // assignment work for the range versions.\n-  \n-    // called by the range assign to implement [23.1.1]/9\n-    template<typename _Integer>\n-      void\n-       _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-       {\n-         _M_fill_assign(static_cast<size_type>(__n),\n-                        static_cast<value_type>(__val));\n-       }\n-  \n-    // called by the range assign to implement [23.1.1]/9\n-    template<typename _InputIter>\n+      \n+    public:\n+      /**\n+       *  @brief  Provides access to the data contained in the %vector.\n+       *  @param n The index of the element for which data should be\n+       *  accessed.\n+       *  @return  Read/write reference to data.\n+       *  @throw  std::out_of_range  If @a n is an invalid index.\n+       *\n+       *  This function provides for safer data access.  The parameter is first\n+       *  checked that it is in the range of the vector.  The function throws\n+       *  out_of_range if the check fails.\n+       */\n+      reference\n+      at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }\n+      \n+      /**\n+       *  @brief  Provides access to the data contained in the %vector.\n+       *  @param n The index of the element for which data should be\n+       *  accessed.\n+       *  @return  Read-only (constant) reference to data.\n+       *  @throw  std::out_of_range  If @a n is an invalid index.\n+       *\n+       *  This function provides for safer data access.  The parameter\n+       *  is first checked that it is in the range of the vector.  The\n+       *  function throws out_of_range if the check fails.\n+       */\n+      const_reference\n+      at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }\n+      \n+      /**\n+       *  Returns a read/write reference to the data at the first\n+       *  element of the %vector.\n+       */\n+      reference\n+      front() { return *begin(); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reference to the data at the first\n+       *  element of the %vector.\n+       */\n+      const_reference\n+      front() const { return *begin(); }\n+      \n+      /**\n+       *  Returns a read/write reference to the data at the last element of the\n+       *  %vector.\n+       */\n+      reference\n+      back() { return *(end() - 1); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reference to the data at the last\n+       *  element of the %vector.\n+       */\n+      const_reference\n+      back() const { return *(end() - 1); }\n+  \n+      // [23.2.4.3] modifiers\n+      /**\n+       *  @brief  Add data to the end of the %vector.\n+       *  @param  x  Data to be added.\n+       *\n+       *  This is a typical stack operation.  The function creates an\n+       *  element at the end of the %vector and assigns the given data\n+       *  to it.  Due to the nature of a %vector this operation can be\n+       *  done in constant time if the %vector has preallocated space\n+       *  available.\n+       */\n       void\n-      _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+      push_back(const value_type& __x)\n       {\n-        typedef typename iterator_traits<_InputIter>::iterator_category\n-                         _IterCategory;\n-        _M_assign_aux(__first, __last, _IterCategory());\n+\tif (_M_finish != _M_end_of_storage)\n+\t  {\n+\t    _Construct(_M_finish, __x);\n+\t    ++_M_finish;\n+\t  }\n+\telse\n+\t  _M_insert_aux(end(), __x);\n       }\n-  \n-    // called by the second assign_dispatch above\n-    template <typename _InputIterator>\n-      void \n-      _M_assign_aux(_InputIterator __first, _InputIterator __last,\n-  \t\t  input_iterator_tag);\n-  \n-    // called by the second assign_dispatch above\n-    template <typename _ForwardIterator>\n-      void \n-      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-  \t\t  forward_iterator_tag);\n-  \n-    // Called by assign(n,t), and the range assign when it turns out to be the\n-    // same thing.\n-    void\n-    _M_fill_assign(size_type __n, const value_type& __val);\n-  \n-  \n-    // Internal insert functions follow.\n-  \n-    // called by the range insert to implement [23.1.1]/9\n-    template<typename _Integer>\n+      \n+      /**\n+       *  @brief  Removes last element.\n+       *\n+       *  This is a typical stack operation. It shrinks the %vector by one.\n+       *\n+       *  Note that no data is returned, and if the last element's data is\n+       *  needed, it should be retrieved before pop_back() is called.\n+       */\n       void\n-      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n-                         __true_type)\n+      pop_back()\n       {\n-        _M_fill_insert(__pos, static_cast<size_type>(__n),\n-                              static_cast<value_type>(__val));\n+\t--_M_finish;\n+\t_Destroy(_M_finish);\n       }\n-  \n-    // called by the range insert to implement [23.1.1]/9\n-    template<typename _InputIterator>\n+      \n+      /**\n+       *  @brief  Inserts given value into %vector before specified iterator.\n+       *  @param  position  An iterator into the %vector.\n+       *  @param  x  Data to be inserted.\n+       *  @return  An iterator that points to the inserted data.\n+       *\n+       *  This function will insert a copy of the given value before\n+       *  the specified location.  Note that this kind of operation\n+       *  could be expensive for a %vector and if it is frequently\n+       *  used the user should consider using std::list.\n+       */\n+      iterator\n+      insert(iterator __position, const value_type& __x);\n+  \n+#ifdef _GLIBCPP_DEPRECATED\n+      /**\n+       *  @brief  Inserts an element into the %vector.\n+       *  @param  position  An iterator into the %vector.\n+       *  @return  An iterator that points to the inserted element.\n+       *\n+       *  This function will insert a default-constructed element\n+       *  before the specified location.  You should consider using\n+       *  insert(position,value_type()) instead.  Note that this kind\n+       *  of operation could be expensive for a vector and if it is\n+       *  frequently used the user should consider using std::list.\n+       *\n+       *  @note This was deprecated in 3.2 and will be removed in 3.4.\n+       *  You must define @c _GLIBCPP_DEPRECATED to make this visible\n+       *  in 3.2; see c++config.h.\n+       */\n+      iterator\n+      insert(iterator __position)\n+      { return insert(__position, value_type()); }\n+#endif\n+      \n+      /**\n+       *  @brief  Inserts a number of copies of given data into the %vector.\n+       *  @param  position  An iterator into the %vector.\n+       *  @param  n  Number of elements to be inserted.\n+       *  @param  x  Data to be inserted.\n+       *\n+       *  This function will insert a specified number of copies of\n+       *  the given data before the location specified by @a position.\n+       *\n+       *  Note that this kind of operation could be expensive for a\n+       *  %vector and if it is frequently used the user should\n+       *  consider using std::list.\n+       */\n+      void\n+      insert(iterator __pos, size_type __n, const value_type& __x)\n+      { _M_fill_insert(__pos, __n, __x); }\n+      \n+      /**\n+       *  @brief  Inserts a range into the %vector.\n+       *  @param  pos  An iterator into the %vector.\n+       *  @param  first  An input iterator.\n+       *  @param  last   An input iterator.\n+       *\n+       *  This function will insert copies of the data in the range\n+       *  [first,last) into the %vector before the location specified\n+       *  by @a pos.\n+       *\n+       *  Note that this kind of operation could be expensive for a\n+       *  %vector and if it is frequently used the user should\n+       *  consider using std::list.\n+       */\n+      template<typename _InputIterator>\n+        void\n+        insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n+        {\n+\t  // Check whether it's an integral type.  If so, it's not an iterator.\n+\t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t  _M_insert_dispatch(__pos, __first, __last, _Integral());\n+\t}\n+      \n+      /**\n+       *  @brief  Remove element at given position.\n+       *  @param  position  Iterator pointing to element to be erased.\n+       *  @return  An iterator pointing to the next element (or end()).\n+       *\n+       *  This function will erase the element at the given position and thus\n+       *  shorten the %vector by one.\n+       *\n+       *  Note This operation could be expensive and if it is\n+       *  frequently used the user should consider using std::list.\n+       *  The user is also cautioned that this function only erases\n+       *  the element, and that if the element is itself a pointer,\n+       *  the pointed-to memory is not touched in any way.  Managing\n+       *  the pointer is the user's responsibilty.\n+       */\n+      iterator\n+      erase(iterator __position);\n+  \n+      /**\n+       *  @brief  Remove a range of elements.\n+       *  @param  first  Iterator pointing to the first element to be erased.\n+       *  @param  last  Iterator pointing to one past the last element to be\n+       *                erased.\n+       *  @return  An iterator pointing to the element pointed to by @a last\n+       *           prior to erasing (or end()).\n+       *\n+       *  This function will erase the elements in the range [first,last) and\n+       *  shorten the %vector accordingly.\n+       *\n+       *  Note This operation could be expensive and if it is\n+       *  frequently used the user should consider using std::list.\n+       *  The user is also cautioned that this function only erases\n+       *  the elements, and that if the elements themselves are\n+       *  pointers, the pointed-to memory is not touched in any way.\n+       *  Managing the pointer is the user's responsibilty.\n+       */\n+      iterator\n+      erase(iterator __first, iterator __last);\n+      \n+      /**\n+       *  @brief  Swaps data with another %vector.\n+       *  @param  x  A %vector of the same element and allocator types.\n+       *\n+       *  This exchanges the elements between two vectors in constant time.\n+       *  (Three pointers, so it should be quite fast.)\n+       *  Note that the global std::swap() function is specialized such that\n+       *  std::swap(v1,v2) will feed to this function.\n+       */\n       void\n-      _M_insert_dispatch(iterator __pos, _InputIterator __first,\n-                         _InputIterator __last, __false_type)\n+      swap(vector& __x)\n       {\n-        typedef typename iterator_traits<_InputIterator>::iterator_category\n-                         _IterCategory;\n-        _M_range_insert(__pos, __first, __last, _IterCategory());\n+\tstd::swap(_M_start, __x._M_start);\n+\tstd::swap(_M_finish, __x._M_finish);\n+\tstd::swap(_M_end_of_storage, __x._M_end_of_storage);\n       }\n-  \n-    // called by the second insert_dispatch above\n-    template <typename _InputIterator>\n+      \n+      /**\n+       *  Erases all the elements.  Note that this function only erases the\n+       *  elements, and that if the elements themselves are pointers, the\n+       *  pointed-to memory is not touched in any way.  Managing the pointer is\n+       *  the user's responsibilty.\n+       */\n       void\n-      _M_range_insert(iterator __pos,\n-                      _InputIterator __first, _InputIterator __last,\n-                      input_iterator_tag);\n-  \n-    // called by the second insert_dispatch above\n-    template <typename _ForwardIterator>\n+      clear() { erase(begin(), end()); }\n+      \n+    protected:\n+      /**\n+       *  @if maint\n+       *  Memory expansion handler.  Uses the member allocation function to\n+       *  obtain @a n bytes of memory, and then copies [first,last) into it.\n+       *  @endif\n+       */\n+      template<typename _ForwardIterator>\n+        pointer\n+        _M_allocate_and_copy(size_type __n,\n+\t\t\t     _ForwardIterator __first, _ForwardIterator __last)\n+        {\n+\t  pointer __result = _M_allocate(__n);\n+\t  try\n+\t    {\n+\t      uninitialized_copy(__first, __last, __result);\n+\t      return __result;\n+\t    }\n+\t  catch(...)\n+\t    {\n+\t      _M_deallocate(__result, __n);\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n+      \n+      \n+      // Internal constructor functions follow.\n+      \n+      // Called by the range constructor to implement [23.1.1]/9\n+      template<typename _Integer>\n+        void\n+        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n+        {\n+\t  _M_start = _M_allocate(__n);\n+\t  _M_end_of_storage = _M_start + __n;\n+\t  _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n+\t}\n+      \n+      // Called by the range constructor to implement [23.1.1]/9\n+      template<typename _InputIter>\n+        void\n+        _M_initialize_dispatch(_InputIter __first, _InputIter __last,\n+\t\t\t       __false_type)\n+        {\n+\t  typedef typename iterator_traits<_InputIter>::iterator_category\n+\t    _IterCategory;\n+\t  _M_range_initialize(__first, __last, _IterCategory());\n+\t}\n+      \n+      // Called by the second initialize_dispatch above\n+      template<typename _InputIterator>\n+        void\n+        _M_range_initialize(_InputIterator __first,\n+\t\t\t    _InputIterator __last, input_iterator_tag)\n+        {\n+\t  for ( ; __first != __last; ++__first)\n+\t    push_back(*__first);\n+\t}\n+      \n+      // Called by the second initialize_dispatch above\n+      template<typename _ForwardIterator>\n+        void \n+        _M_range_initialize(_ForwardIterator __first,\n+\t\t\t    _ForwardIterator __last, forward_iterator_tag)\n+        {\n+\t  size_type __n = distance(__first, __last);\n+\t  _M_start = _M_allocate(__n);\n+\t  _M_end_of_storage = _M_start + __n;\n+\t  _M_finish = uninitialized_copy(__first, __last, _M_start);\n+\t}\n+      \n+      \n+      // Internal assign functions follow.  The *_aux functions do the actual\n+      // assignment work for the range versions.\n+      \n+      // Called by the range assign to implement [23.1.1]/9\n+      template<typename _Integer>\n+        void\n+        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+        {\n+\t  _M_fill_assign(static_cast<size_type>(__n),\n+\t\t\t static_cast<value_type>(__val));\n+\t}\n+      \n+      // Called by the range assign to implement [23.1.1]/9\n+      template<typename _InputIter>\n+        void\n+        _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+        {\n+\t  typedef typename iterator_traits<_InputIter>::iterator_category\n+\t    _IterCategory;\n+\t  _M_assign_aux(__first, __last, _IterCategory());\n+\t}\n+      \n+      // Called by the second assign_dispatch above\n+      template<typename _InputIterator>\n+        void \n+        _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+\t\t      input_iterator_tag);\n+  \n+      // Called by the second assign_dispatch above\n+      template<typename _ForwardIterator>\n+        void \n+        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t      forward_iterator_tag);\n+  \n+      // Called by assign(n,t), and the range assign when it turns out\n+      // to be the same thing.\n       void\n-      _M_range_insert(iterator __pos,\n-                      _ForwardIterator __first, _ForwardIterator __last,\n-                      forward_iterator_tag);\n-  \n-    // Called by insert(p,n,x), and the range insert when it turns out to be\n-    // the same thing.\n-    void\n-    _M_fill_insert (iterator __pos, size_type __n, const value_type& __x);\n-  \n-    // called by insert(p,x)\n-    void\n-    _M_insert_aux(iterator __position, const value_type& __x);\n-  \n-  #ifdef _GLIBCPP_DEPRECATED\n-    // unused now (same situation as in deque)\n-    void _M_insert_aux(iterator __position);\n-  #endif\n-  };\n+      _M_fill_assign(size_type __n, const value_type& __val);\n+  \n+      \n+      // Internal insert functions follow.\n+      \n+      // Called by the range insert to implement [23.1.1]/9\n+      template<typename _Integer>\n+        void\n+        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n+\t\t\t   __true_type)\n+        {\n+\t  _M_fill_insert(__pos, static_cast<size_type>(__n),\n+\t\t\t static_cast<value_type>(__val));\n+\t}\n+      \n+      // Called by the range insert to implement [23.1.1]/9\n+      template<typename _InputIterator>\n+        void\n+        _M_insert_dispatch(iterator __pos, _InputIterator __first,\n+\t\t\t   _InputIterator __last, __false_type)\n+        {\n+\t  typedef typename iterator_traits<_InputIterator>::iterator_category\n+\t    _IterCategory;\n+\t  _M_range_insert(__pos, __first, __last, _IterCategory());\n+\t}\n+      \n+      // Called by the second insert_dispatch above\n+      template<typename _InputIterator>\n+        void\n+        _M_range_insert(iterator __pos, _InputIterator __first, \n+\t\t\t_InputIterator __last, input_iterator_tag);\n+      \n+      // Called by the second insert_dispatch above\n+      template<typename _ForwardIterator>\n+        void\n+        _M_range_insert(iterator __pos, _ForwardIterator __first, \n+\t\t\t_ForwardIterator __last, forward_iterator_tag);\n+      \n+      // Called by insert(p,n,x), and the range insert when it turns out to be\n+      // the same thing.\n+      void\n+      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);\n+      \n+      // Called by insert(p,x)\n+      void\n+      _M_insert_aux(iterator __position, const value_type& __x);\n+      \n+#ifdef _GLIBCPP_DEPRECATED\n+      // Unused now (same situation as in deque)\n+      void _M_insert_aux(iterator __position);\n+#endif\n+    };\n   \n   \n   /**\n@@ -908,7 +931,7 @@ namespace std\n    *  vectors.  Vectors are considered equivalent if their sizes are equal,\n    *  and if corresponding elements compare equal.\n   */\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     inline bool\n     operator==(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n     {\n@@ -927,7 +950,7 @@ namespace std\n    *\n    *  See std::lexographical_compare() for how the determination is made.\n   */\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n     {\n@@ -936,31 +959,31 @@ namespace std\n     }\n   \n   /// Based on operator==\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     inline bool\n     operator!=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n     { return !(__x == __y); }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n     { return __y < __x; }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n     { return !(__y < __x); }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n     { return !(__x < __y); }\n   \n   /// See std::vector::swap().\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     inline void\n     swap(vector<_Tp,_Alloc>& __x, vector<_Tp,_Alloc>& __y)\n     { __x.swap(__y); }"}, {"sha": "da5cf7edf8322970e530aa2b55138471b2c7ef02", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=af5fb6ab3bd4c53d247340d6dad77471993a168c", "patch": "@@ -63,7 +63,7 @@\n \n namespace std\n {\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     void\n     vector<_Tp,_Alloc>::\n     reserve(size_type __n)\n@@ -82,7 +82,7 @@ namespace std\n \t}\n     }\n   \n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     typename vector<_Tp,_Alloc>::iterator\n     vector<_Tp,_Alloc>::\n     insert(iterator __position, const value_type& __x)\n@@ -98,7 +98,7 @@ namespace std\n       return begin() + __n;\n     }\n   \n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     typename vector<_Tp,_Alloc>::iterator\n     vector<_Tp,_Alloc>::\n     erase(iterator __position)\n@@ -110,7 +110,7 @@ namespace std\n       return __position;\n     }\n   \n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     typename vector<_Tp,_Alloc>::iterator\n     vector<_Tp,_Alloc>::\n     erase(iterator __first, iterator __last)\n@@ -121,7 +121,7 @@ namespace std\n       return __first;\n     }\n   \n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     vector<_Tp,_Alloc>&\n     vector<_Tp,_Alloc>::\n     operator=(const vector<_Tp,_Alloc>& __x)\n@@ -152,7 +152,7 @@ namespace std\n       return *this;\n     }\n   \n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     void\n     vector<_Tp,_Alloc>::\n     _M_fill_assign(size_t __n, const value_type& __val)\n@@ -171,7 +171,7 @@ namespace std\n         erase(fill_n(begin(), __n, __val), end());\n     }\n   \n-  template <typename _Tp, typename _Alloc> template <typename _InputIter>\n+  template<typename _Tp, typename _Alloc> template<typename _InputIter>\n     void\n     vector<_Tp,_Alloc>::\n     _M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)\n@@ -185,7 +185,7 @@ namespace std\n         insert(end(), __first, __last);\n     }\n   \n-  template <typename _Tp, typename _Alloc> template <typename _ForwardIter>\n+  template<typename _Tp, typename _Alloc> template<typename _ForwardIter>\n     void\n     vector<_Tp,_Alloc>::\n     _M_assign_aux(_ForwardIter __first, _ForwardIter __last,\n@@ -216,7 +216,7 @@ namespace std\n       }\n     }\n   \n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     void\n     vector<_Tp,_Alloc>::\n     _M_insert_aux(iterator __position, const _Tp& __x)\n@@ -259,7 +259,7 @@ namespace std\n     }\n   \n   #ifdef _GLIBCPP_DEPRECATED\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     void\n     vector<_Tp,_Alloc>::\n     _M_insert_aux(iterator __position)\n@@ -302,63 +302,64 @@ namespace std\n     }\n   #endif\n   \n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     void\n     vector<_Tp,_Alloc>::\n     _M_fill_insert(iterator __position, size_type __n, const value_type& __x)\n     {\n       if (__n != 0)\n       {\n-        if (size_type(_M_end_of_storage - _M_finish) >= __n) {\n-          value_type __x_copy = __x;\n-          const size_type __elems_after = end() - __position;\n-          iterator __old_finish(_M_finish);\n-          if (__elems_after > __n)\n-          {\n-            uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n-            _M_finish += __n;\n-            copy_backward(__position, __old_finish - __n, __old_finish);\n-            fill(__position, __position + __n, __x_copy);\n-          }\n-          else\n-          {\n-            uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);\n-            _M_finish += __n - __elems_after;\n-            uninitialized_copy(__position, __old_finish, _M_finish);\n-            _M_finish += __elems_after;\n-            fill(__position, __old_finish, __x_copy);\n-          }\n-        }\n+        if (size_type(_M_end_of_storage - _M_finish) >= __n) \n+\t  {\n+           value_type __x_copy = __x;\n+\t   const size_type __elems_after = end() - __position;\n+\t   iterator __old_finish(_M_finish);\n+\t   if (__elems_after > __n)\n+\t     {\n+\t       uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n+\t       _M_finish += __n;\n+\t       copy_backward(__position, __old_finish - __n, __old_finish);\n+\t       fill(__position, __position + __n, __x_copy);\n+\t     }\n+\t   else\n+\t     {\n+\t       uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);\n+\t       _M_finish += __n - __elems_after;\n+\t       uninitialized_copy(__position, __old_finish, _M_finish);\n+\t       _M_finish += __elems_after;\n+\t       fill(__position, __old_finish, __x_copy);\n+\t     }\n+\t  }\n         else\n-        {\n-          const size_type __old_size = size();\n-          const size_type __len = __old_size + max(__old_size, __n);\n-          iterator __new_start(_M_allocate(__len));\n-          iterator __new_finish(__new_start);\n-          try\n-            {\n-              __new_finish = uninitialized_copy(begin(), __position,\n-                                                __new_start);\n-              __new_finish = uninitialized_fill_n(__new_finish, __n, __x);\n-              __new_finish\n-                = uninitialized_copy(__position, end(), __new_finish);\n-            }\n-          catch(...)\n-            {\n-              _Destroy(__new_start,__new_finish);\n-              _M_deallocate(__new_start.base(),__len);\n-              __throw_exception_again;\n-            }\n-          _Destroy(_M_start, _M_finish);\n-          _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-          _M_start = __new_start.base();\n-          _M_finish = __new_finish.base();\n-          _M_end_of_storage = __new_start.base() + __len;\n-        }\n+\t  {\n+\t    const size_type __old_size = size();\n+\t    const size_type __len = __old_size + max(__old_size, __n);\n+\t    iterator __new_start(_M_allocate(__len));\n+\t    iterator __new_finish(__new_start);\n+\t    try\n+\t      {\n+\t\t__new_finish = uninitialized_copy(begin(), __position,\n+\t\t\t\t\t\t  __new_start);\n+\t\t__new_finish = uninitialized_fill_n(__new_finish, __n, __x);\n+\t\t__new_finish = uninitialized_copy(__position, end(), \n+\t\t\t\t\t\t  __new_finish);\n+\t      }\n+\t    catch(...)\n+\t      {\n+\t\t_Destroy(__new_start,__new_finish);\n+\t\t_M_deallocate(__new_start.base(),__len);\n+\t\t__throw_exception_again;\n+\t      }\n+\t    _Destroy(_M_start, _M_finish);\n+\t    _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+\t    _M_start = __new_start.base();\n+\t    _M_finish = __new_finish.base();\n+\t    _M_end_of_storage = __new_start.base() + __len;\n+\t  }\n       }\n     }\n   \n-  template <typename _Tp, typename _Alloc> template <typename _InputIterator>\n+  template<typename _Tp, typename _Alloc> template<typename _InputIterator>\n     void\n     vector<_Tp,_Alloc>::\n     _M_range_insert(iterator __pos,\n@@ -372,12 +373,11 @@ namespace std\n       }\n     }\n   \n-  template <typename _Tp, typename _Alloc> template <typename _ForwardIterator>\n+  template<typename _Tp, typename _Alloc> template<typename _ForwardIterator>\n     void\n     vector<_Tp,_Alloc>::\n-    _M_range_insert(iterator __position,\n-                    _ForwardIterator __first, _ForwardIterator __last,\n-                    forward_iterator_tag)\n+    _M_range_insert(iterator __position,_ForwardIterator __first, \n+\t\t    _ForwardIterator __last, forward_iterator_tag)\n     {\n       if (__first != __last)\n       {"}, {"sha": "8c40ab760f7fc051a2bb7707f0cf31a9f33c3e8b", "filename": "libstdc++-v3/testsuite/20_util/allocator_members.cc", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_members.cc?ref=af5fb6ab3bd4c53d247340d6dad77471993a168c", "patch": "@@ -1,6 +1,6 @@\n // 2001-06-14  Benjamin Kosnik  <bkoz@redhat.com>\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -21,6 +21,7 @@\n // 20.4.1.1 allocator members\n \n #include <memory>\n+#include <stdexcept>\n #include <cstdlib>\n #include <testsuite_hooks.h>\n \n@@ -42,7 +43,7 @@ void operator delete(void *v) throw()\n   return std::free(v);\n }\n \n-int main(void)\n+void test01()\n {\n   bool test = true;\n   std::allocator<gnu> obj;\n@@ -55,6 +56,34 @@ int main(void)\n \n   obj.deallocate(pobj, 256);\n   VERIFY( check_delete );\n+}\n+\n+// libstdc++/8230\n+void test02()\n+{\n+  bool test = true;\n+  try \n+    {\n+      std::allocator<int> alloc;\n+      const std::allocator<int>::size_type n = alloc.max_size();\n+      int* p = alloc.allocate(n + 1);\n+      p[n] = 2002;\n+    } \n+  catch(const std::bad_alloc& e) \n+    {\n+      // Allowed.\n+      test = true;\n+    }\n+  catch(...) \n+    {\n+      test = false;\n+    }\n+  VERIFY( test );\n+}\n \n+int main()\n+{\n+  test01();\n+  test02();\n   return 0;\n }"}, {"sha": "8e9b6a8b1ab205e146331c90d5fa8f490b12e919", "filename": "libstdc++-v3/testsuite/23_containers/vector_capacity.cc", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_capacity.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af5fb6ab3bd4c53d247340d6dad77471993a168c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_capacity.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_capacity.cc?ref=af5fb6ab3bd4c53d247340d6dad77471993a168c", "patch": "@@ -99,9 +99,30 @@ void test02()\n   }\n }\n \n+void test03()\n+{\n+  bool test = true;\n+  std::vector<int> v;\n+  try\n+    {\n+      v.resize(v.max_size());  \n+      v[v.max_size() - 1] = 2002;\n+    }\n+  catch (const std::bad_alloc& error)\n+    {\n+      test = true;\n+    }\n+  catch (...)\n+    {\n+      test = false;\n+    }\n+  VERIFY( test );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}]}