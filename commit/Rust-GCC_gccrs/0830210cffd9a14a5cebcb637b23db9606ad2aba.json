{"sha": "0830210cffd9a14a5cebcb637b23db9606ad2aba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgzMDIxMGNmZmQ5YTE0YTVjZWJjYjYzN2IyM2RiOTYwNmFkMmFiYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-29T15:27:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-29T15:27:54Z"}, "message": "[multiple changes]\n\n2014-01-29  Emmanuel Briot  <briot@adacore.com>\n\n\t* s-regexp.adb (Create_Secondary_Table): Automatically grow the state\n\tmachine as needed.\n\t(Dump): New subprogram.\n\n2014-01-29  Tristan Gingold  <gingold@adacore.com>\n\n\t* exp_ch9.adb (Expand_N_Protected_Type_Declaration): Add\n\tExpand_Entry_Declaration to factorize code.\n\nFrom-SVN: r207250", "tree": {"sha": "20e5399cd1a07be2ebd433d2a058167bced8af50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20e5399cd1a07be2ebd433d2a058167bced8af50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0830210cffd9a14a5cebcb637b23db9606ad2aba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0830210cffd9a14a5cebcb637b23db9606ad2aba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0830210cffd9a14a5cebcb637b23db9606ad2aba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0830210cffd9a14a5cebcb637b23db9606ad2aba/comments", "author": null, "committer": null, "parents": [{"sha": "85c13695d2833005729f317b6b4f4a0c7fc39cc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85c13695d2833005729f317b6b4f4a0c7fc39cc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85c13695d2833005729f317b6b4f4a0c7fc39cc2"}], "stats": {"total": 398, "additions": 244, "deletions": 154}, "files": [{"sha": "126caade912f6b9c6ff2ee200a94030a20c8c59b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0830210cffd9a14a5cebcb637b23db9606ad2aba/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0830210cffd9a14a5cebcb637b23db9606ad2aba/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0830210cffd9a14a5cebcb637b23db9606ad2aba", "patch": "@@ -1,3 +1,14 @@\n+2014-01-29  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* s-regexp.adb (Create_Secondary_Table): Automatically grow the state\n+\tmachine as needed.\n+\t(Dump): New subprogram.\n+\n+2014-01-29  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* exp_ch9.adb (Expand_N_Protected_Type_Declaration): Add\n+\tExpand_Entry_Declaration to factorize code.\n+\n 2014-01-29  Ed Schonberg  <schonberg@adacore.com>\n \n \t* checks.adb: minor clarification."}, {"sha": "04277ec04d1d87497a0cbb3e2ec4c39ff61d4390", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 69, "deletions": 109, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0830210cffd9a14a5cebcb637b23db9606ad2aba/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0830210cffd9a14a5cebcb637b23db9606ad2aba/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=0830210cffd9a14a5cebcb637b23db9606ad2aba", "patch": "@@ -8795,8 +8795,6 @@ package body Exp_Ch9 is\n       Comp_Id      : Entity_Id;\n       Sub          : Node_Id;\n       Current_Node : Node_Id := N;\n-      Bdef         : Entity_Id := Empty; -- avoid uninit warning\n-      Edef         : Entity_Id := Empty; -- avoid uninit warning\n       Entries_Aggr : Node_Id;\n       Body_Id      : Entity_Id;\n       Body_Arr     : Node_Id;\n@@ -8808,6 +8806,10 @@ package body Exp_Ch9 is\n       --  to the internal body, for possible inlining later on. The source\n       --  operation is invisible to the back-end and is never actually called.\n \n+      procedure Expand_Entry_Declaration (Comp : Entity_Id);\n+      --  Create the subprograms for the barrier and for the body, and append\n+      --  then to Entry_Bodies_Array.\n+\n       function Static_Component_Size (Comp : Entity_Id) return Boolean;\n       --  When compiling under the Ravenscar profile, private components must\n       --  have a static size, or else a protected object  will require heap\n@@ -8865,6 +8867,67 @@ package body Exp_Ch9 is\n          end if;\n       end Static_Component_Size;\n \n+      ------------------------------\n+      -- Expand_Entry_Declaration --\n+      ------------------------------\n+\n+      procedure Expand_Entry_Declaration (Comp : Entity_Id) is\n+         Bdef : Entity_Id;\n+         Edef : Entity_Id;\n+      begin\n+         E_Count := E_Count + 1;\n+         Comp_Id := Defining_Identifier (Comp);\n+\n+         Edef :=\n+           Make_Defining_Identifier (Loc,\n+             Build_Selected_Name (Prot_Typ, Comp_Id, 'E'));\n+         Sub :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification =>\n+               Build_Protected_Entry_Specification (Loc, Edef, Comp_Id));\n+\n+         Insert_After (Current_Node, Sub);\n+         Analyze (Sub);\n+\n+         --  Build wrapper procedure for pre/postconditions\n+\n+         Build_PPC_Wrapper (Comp_Id, N);\n+\n+         Set_Protected_Body_Subprogram\n+           (Defining_Identifier (Comp),\n+            Defining_Unit_Name (Specification (Sub)));\n+\n+         Current_Node := Sub;\n+\n+         Bdef :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => Build_Selected_Name (Prot_Typ, Comp_Id, 'B'));\n+         Sub :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification =>\n+               Build_Barrier_Function_Specification (Loc, Bdef));\n+\n+         Insert_After (Current_Node, Sub);\n+         Analyze (Sub);\n+         Set_Protected_Body_Subprogram (Bdef, Bdef);\n+         Set_Barrier_Function (Comp_Id, Bdef);\n+         Set_Scope (Bdef, Scope (Comp_Id));\n+         Current_Node := Sub;\n+\n+         --  Collect pointers to the protected subprogram and the barrier\n+         --  of the current entry, for insertion into Entry_Bodies_Array.\n+\n+         Append_To (Expressions (Entries_Aggr),\n+           Make_Aggregate (Loc,\n+             Expressions => New_List (\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         => New_Reference_To (Bdef, Loc),\n+                 Attribute_Name => Name_Unrestricted_Access),\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         => New_Reference_To (Edef, Loc),\n+                 Attribute_Name => Name_Unrestricted_Access))));\n+      end Expand_Entry_Declaration;\n+\n       ----------------------\n       -- Register_Handler --\n       ----------------------\n@@ -9054,7 +9117,7 @@ package body Exp_Ch9 is\n          end loop;\n       end if;\n \n-      --  Except for the lock-free implementation, prepend the _Object field\n+      --  Except for the lock-free implementation, append the _Object field\n       --  with the right type to the component list. We need to compute the\n       --  number of entries, and in some cases the number of Attach_Handler\n       --  pragmas.\n@@ -9258,57 +9321,9 @@ package body Exp_Ch9 is\n             end if;\n \n          elsif Nkind (Comp) = N_Entry_Declaration then\n-            E_Count := E_Count + 1;\n-            Comp_Id := Defining_Identifier (Comp);\n \n-            Edef :=\n-              Make_Defining_Identifier (Loc,\n-                Build_Selected_Name (Prot_Typ, Comp_Id, 'E'));\n-            Sub :=\n-              Make_Subprogram_Declaration (Loc,\n-                Specification =>\n-                  Build_Protected_Entry_Specification (Loc, Edef, Comp_Id));\n+            Expand_Entry_Declaration (Comp);\n \n-            Insert_After (Current_Node, Sub);\n-            Analyze (Sub);\n-\n-            --  Build wrapper procedure for pre/postconditions\n-\n-            Build_PPC_Wrapper (Comp_Id, N);\n-\n-            Set_Protected_Body_Subprogram\n-              (Defining_Identifier (Comp),\n-               Defining_Unit_Name (Specification (Sub)));\n-\n-            Current_Node := Sub;\n-\n-            Bdef :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => Build_Selected_Name (Prot_Typ, Comp_Id, 'B'));\n-            Sub :=\n-              Make_Subprogram_Declaration (Loc,\n-                Specification =>\n-                  Build_Barrier_Function_Specification (Loc, Bdef));\n-\n-            Insert_After (Current_Node, Sub);\n-            Analyze (Sub);\n-            Set_Protected_Body_Subprogram (Bdef, Bdef);\n-            Set_Barrier_Function (Comp_Id, Bdef);\n-            Set_Scope (Bdef, Scope (Comp_Id));\n-            Current_Node := Sub;\n-\n-            --  Collect pointers to the protected subprogram and the barrier\n-            --  of the current entry, for insertion into Entry_Bodies_Array.\n-\n-            Append_To (Expressions (Entries_Aggr),\n-              Make_Aggregate (Loc,\n-                Expressions => New_List (\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix         => New_Reference_To (Bdef, Loc),\n-                    Attribute_Name => Name_Unrestricted_Access),\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix         => New_Reference_To (Edef, Loc),\n-                    Attribute_Name => Name_Unrestricted_Access))));\n          end if;\n \n          Next (Comp);\n@@ -9321,54 +9336,7 @@ package body Exp_Ch9 is\n          Comp := First (Private_Declarations (Pdef));\n          while Present (Comp) loop\n             if Nkind (Comp) = N_Entry_Declaration then\n-               E_Count := E_Count + 1;\n-               Comp_Id := Defining_Identifier (Comp);\n-\n-               Edef :=\n-                 Make_Defining_Identifier (Loc,\n-                  Build_Selected_Name (Prot_Typ, Comp_Id, 'E'));\n-               Sub :=\n-                 Make_Subprogram_Declaration (Loc,\n-                   Specification =>\n-                     Build_Protected_Entry_Specification (Loc, Edef, Comp_Id));\n-\n-               Insert_After (Current_Node, Sub);\n-               Analyze (Sub);\n-\n-               Set_Protected_Body_Subprogram\n-                 (Defining_Identifier (Comp),\n-                  Defining_Unit_Name (Specification (Sub)));\n-\n-               Current_Node := Sub;\n-\n-               Bdef :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => Build_Selected_Name (Prot_Typ, Comp_Id, 'E'));\n-\n-               Sub :=\n-                 Make_Subprogram_Declaration (Loc,\n-                   Specification =>\n-                     Build_Barrier_Function_Specification (Loc, Bdef));\n-\n-               Insert_After (Current_Node, Sub);\n-               Analyze (Sub);\n-               Set_Protected_Body_Subprogram (Bdef, Bdef);\n-               Set_Barrier_Function (Comp_Id, Bdef);\n-               Set_Scope (Bdef, Scope (Comp_Id));\n-               Current_Node := Sub;\n-\n-               --  Collect pointers to the protected subprogram and the barrier\n-               --  of the current entry, for insertion into Entry_Bodies_Array.\n-\n-               Append_To (Expressions (Entries_Aggr),\n-                 Make_Aggregate (Loc,\n-                   Expressions => New_List (\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix => New_Reference_To (Bdef, Loc),\n-                       Attribute_Name => Name_Unrestricted_Access),\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix => New_Reference_To (Edef, Loc),\n-                       Attribute_Name => Name_Unrestricted_Access))));\n+               Expand_Entry_Declaration (Comp);\n             end if;\n \n             Next (Comp);\n@@ -9406,15 +9374,7 @@ package body Exp_Ch9 is\n                  Aliased_Present => True,\n                  Object_Definition => New_Reference_To\n                                         (RTE (RE_Entry_Body), Loc),\n-                 Expression =>\n-                   Make_Aggregate (Loc,\n-                     Expressions => New_List (\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix => New_Reference_To (Bdef, Loc),\n-                         Attribute_Name => Name_Unrestricted_Access),\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix => New_Reference_To (Edef, Loc),\n-                         Attribute_Name => Name_Unrestricted_Access))));\n+                 Expression => Remove_Head (Expressions (Entries_Aggr)));\n \n             when others =>\n                raise Program_Error;"}, {"sha": "fe720669ff7e8b821042d89322feaf56cef0fc6e", "filename": "gcc/ada/s-regexp.adb", "status": "modified", "additions": 164, "deletions": 45, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0830210cffd9a14a5cebcb637b23db9606ad2aba/gcc%2Fada%2Fs-regexp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0830210cffd9a14a5cebcb637b23db9606ad2aba/gcc%2Fada%2Fs-regexp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regexp.adb?ref=0830210cffd9a14a5cebcb637b23db9606ad2aba", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1999-2012, AdaCore                     --\n+--                     Copyright (C) 1999-2013, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,11 +30,19 @@\n ------------------------------------------------------------------------------\n \n with Ada.Unchecked_Deallocation;\n+with Ada.Text_IO; use Ada.Text_IO;\n \n with System.Case_Util;\n \n package body System.Regexp is\n \n+   Initial_Max_States_In_Primary_Table : constant := 100;\n+   --  Initial size for the number of states in the indefinite state\n+   --  machine. The number of states will be increased as needed.\n+   --\n+   --  This is also used as the maximal number of meta states (groups of\n+   --  states) in the secondary table.\n+\n    Open_Paren    : constant Character := '(';\n    Close_Paren   : constant Character := ')';\n    Open_Bracket  : constant Character := '[';\n@@ -69,6 +77,56 @@ package body System.Regexp is\n    end record;\n    --  Deterministic finite-state machine\n \n+   procedure Dump\n+      (Table         : Regexp_Array_Access;\n+       Map           : Mapping;\n+       Alphabet_Size : Column_Index;\n+       Num_States    : State_Index;\n+       Start_State   : State_Index;\n+       End_State     : State_Index);\n+   --  Display the state machine (indeterministic, from the first pass) on\n+   --  stdout.\n+\n+   ----------\n+   -- Dump --\n+   ----------\n+\n+   procedure Dump\n+      (Table         : Regexp_Array_Access;\n+       Map           : Mapping;\n+       Alphabet_Size : Column_Index;\n+       Num_States    : State_Index;\n+       Start_State   : State_Index;\n+       End_State     : State_Index)\n+   is\n+      Empty_Char : constant Column_Index := Alphabet_Size + 1;\n+      Col : Column_Index;\n+   begin\n+      for S in Table'First (1) .. Num_States loop\n+         if S = Start_State then\n+            Put (\"Start\" & S'Img & \" => \");\n+         elsif S = End_State then\n+            Put (\"End  \" & S'Img);\n+         else\n+            Put (\"State\" & S'Img & \" => \");\n+         end if;\n+\n+         for C in Map'Range loop\n+            Col := Map (C);\n+            if Table (S, Col) /= 0 then\n+               Put (Table (S, Col)'Img & \"(\" & C'Img & \")\");\n+            end if;\n+         end loop;\n+\n+         for Col in Empty_Char .. Table'Last (2) loop\n+            exit when Table (S, Col) = 0;\n+            Put (Table (S, Col)'Img & \" (empty)\");\n+         end loop;\n+\n+         New_Line;\n+      end loop;\n+   end Dump;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -1373,83 +1431,134 @@ package body System.Regexp is\n          Start_State : State_Index;\n          End_State   : State_Index) return Regexp\n       is\n-         pragma Warnings (Off, Num_States);\n-\n          Last_Index : constant State_Index := First_Table'Last (1);\n-         type Meta_State is array (1 .. Last_Index) of Boolean;\n-\n-         Table : Regexp_Array (1 .. Last_Index, 0 .. Alphabet_Size) :=\n-                   (others => (others => 0));\n \n-         Meta_States : array (1 .. Last_Index + 1) of Meta_State :=\n-                         (others => (others => False));\n+         type Meta_State is array (0 .. Last_Index) of Boolean;\n+         pragma Pack (Meta_State);\n+         --  Whether a state from first_table belongs to a metastate.\n+\n+         No_States : constant Meta_State := (others => False);\n+\n+         type Meta_States_Array is array (State_Index range <>) of Meta_State;\n+         type Meta_States_List is access all Meta_States_Array;\n+         procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+            (Meta_States_Array, Meta_States_List);\n+         Meta_States : Meta_States_List;\n+         --  Components of meta-states. A given state might belong to\n+         --  several meta-states.\n+         --  This array grows dynamically.\n+\n+         type Char_To_State is array (0 .. Alphabet_Size) of State_Index;\n+         type Meta_States_Transition_Arr is\n+            array (State_Index range <>) of Char_To_State;\n+         type Meta_States_Transition is access all Meta_States_Transition_Arr;\n+         procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+           (Meta_States_Transition_Arr, Meta_States_Transition);\n+         Table : Meta_States_Transition;\n+         --  Documents the transitions between each meta-state. The\n+         --  first index is the meta-state, the second column is the\n+         --  character seen in the input, the value is the new meta-state.\n \n          Temp_State_Not_Null : Boolean;\n \n-         Is_Final : Boolean_Array (1 .. Last_Index) := (others => False);\n-\n          Current_State       : State_Index := 1;\n+         --  The current meta-state we are creating\n+\n          Nb_State            : State_Index := 1;\n+         --  The total number of meta-states created so far.\n \n          procedure Closure\n-           (State : in out Meta_State;\n-            Item  :        State_Index);\n+           (Meta_State : State_Index;\n+            State      : State_Index);\n          --  Compute the closure of the state (that is every other state which\n          --  has a empty-character transition) and add it to the state\n \n+         procedure Ensure_Meta_State (Meta : State_Index);\n+         --  grows the Meta_States array as needed to make sure that there\n+         --  is enough space to store the new meta state.\n+\n+         -----------------------\n+         -- Ensure_Meta_State --\n+         -----------------------\n+\n+         procedure Ensure_Meta_State (Meta : State_Index) is\n+            Tmp : Meta_States_List := Meta_States;\n+            Tmp2 : Meta_States_Transition := Table;\n+         begin\n+            if Meta_States = null then\n+               Meta_States := new Meta_States_Array\n+                  (1 .. State_Index'Max (Last_Index, Meta) + 1);\n+               Meta_States (Meta_States'Range) := (others => No_States);\n+\n+               Table := new Meta_States_Transition_Arr\n+                  (1 .. State_Index'Max (Last_Index, Meta) + 1);\n+               Table.all := (others => (others => 0));\n+\n+            elsif Meta > Meta_States'Last then\n+               Meta_States := new Meta_States_Array\n+                  (1 .. State_Index'Max (2 * Tmp'Last, Meta));\n+               Meta_States (Tmp'Range) := Tmp.all;\n+               Meta_States (Tmp'Last + 1 .. Meta_States'Last) :=\n+                  (others => No_States);\n+               Unchecked_Free (Tmp);\n+\n+               Table := new Meta_States_Transition_Arr\n+                  (1 .. State_Index'Max (2 * Tmp2'Last, Meta) + 1);\n+               Table (Tmp2'Range) := Tmp2.all;\n+               Table (Tmp2'Last + 1 .. Table'Last) :=\n+                  (others => (others => 0));\n+               Unchecked_Free (Tmp2);\n+            end if;\n+         end Ensure_Meta_State;\n+\n          -------------\n          -- Closure --\n          -------------\n \n          procedure Closure\n-           (State : in out Meta_State;\n-            Item  : State_Index)\n-         is\n+           (Meta_State : State_Index;\n+            State      : State_Index) is\n          begin\n-            if State (Item) then\n-               return;\n-            end if;\n-\n-            State (Item) := True;\n+            if not Meta_States (Meta_State)(State) then\n+               Meta_States (Meta_State)(State) := True;\n \n-            for Column in Alphabet_Size + 1 .. First_Table'Last (2) loop\n-               if First_Table (Item, Column) = 0 then\n-                  return;\n-               end if;\n+               --  For each transition on empty-character\n \n-               Closure (State, First_Table (Item, Column));\n-            end loop;\n+               for Column in Alphabet_Size + 1 .. First_Table'Last (2) loop\n+                  exit when First_Table (State, Column) = 0;\n+                  Closure (Meta_State, First_Table (State, Column));\n+               end loop;\n+            end if;\n          end Closure;\n \n       --  Start of processing for Create_Secondary_Table\n \n       begin\n          --  Create a new state\n \n-         Closure (Meta_States (Current_State), Start_State);\n-\n-         while Current_State <= Nb_State loop\n+         Ensure_Meta_State (Current_State);\n+         Closure (Current_State, Start_State);\n \n-            --  If this new meta-state includes the primary table end state,\n-            --  then this meta-state will be a final state in the regexp\n+         if False then\n+            Dump (First_Table, Map, Alphabet_Size, Num_States,\n+                  Start_State, End_State);\n+         end if;\n \n-            if Meta_States (Current_State)(End_State) then\n-               Is_Final (Current_State) := True;\n-            end if;\n+         while Current_State <= Nb_State loop\n+            --  We will be trying, below, to create the next meta-state\n+            Ensure_Meta_State (Nb_State + 1);\n \n             --  For every character in the regexp, calculate the possible\n             --  transitions from Current_State\n \n             for Column in 0 .. Alphabet_Size loop\n-               Meta_States (Nb_State + 1) := (others => False);\n                Temp_State_Not_Null := False;\n \n                for K in Meta_States (Current_State)'Range loop\n                   if Meta_States (Current_State)(K)\n                     and then First_Table (K, Column) /= 0\n                   then\n-                     Closure\n-                       (Meta_States (Nb_State + 1), First_Table (K, Column));\n+                     Closure (Nb_State + 1, First_Table (K, Column));\n                      Temp_State_Not_Null := True;\n                   end if;\n                end loop;\n@@ -1462,16 +1571,20 @@ package body System.Regexp is\n \n                   for K in 1 .. Nb_State loop\n                      if Meta_States (K) = Meta_States (Nb_State + 1) then\n-                        Table (Current_State, Column) := K;\n+                        Table (Current_State)(Column) := K;\n+\n+                        --  reset data, for the next time we try that state\n+                        Meta_States (Nb_State + 1) := No_States;\n                         exit;\n                      end if;\n                   end loop;\n \n                   --  If not, create a new state\n \n-                  if Table (Current_State, Column) = 0 then\n+                  if Table (Current_State)(Column) = 0 then\n                      Nb_State := Nb_State + 1;\n-                     Table (Current_State, Column) := Nb_State;\n+                     Ensure_Meta_State (Nb_State + 1);\n+                     Table (Current_State)(Column) := Nb_State;\n                   end if;\n                end if;\n             end loop;\n@@ -1488,15 +1601,21 @@ package body System.Regexp is\n             R := new Regexp_Value (Alphabet_Size => Alphabet_Size,\n                                    Num_States    => Nb_State);\n             R.Map            := Map;\n-            R.Is_Final       := Is_Final (1 .. Nb_State);\n             R.Case_Sensitive := Case_Sensitive;\n \n+            for S in 1 .. Nb_State loop\n+               R.Is_Final (S) := Meta_States (S)(End_State);\n+            end loop;\n+\n             for State in 1 .. Nb_State loop\n                for K in 0 .. Alphabet_Size loop\n-                  R.States (State, K) := Table (State, K);\n+                  R.States (State, K) := Table (State)(K);\n                end loop;\n             end loop;\n \n+            Unchecked_Free (Meta_States);\n+            Unchecked_Free (Table);\n+\n             return (Ada.Finalization.Controlled with R => R);\n          end;\n       end Create_Secondary_Table;\n@@ -1546,7 +1665,7 @@ package body System.Regexp is\n          R           : Regexp;\n \n       begin\n-         Table := new Regexp_Array (1 .. 100,\n+         Table := new Regexp_Array (1 .. Initial_Max_States_In_Primary_Table,\n                                     0 .. Alphabet_Size + 10);\n          if not Glob then\n             Create_Primary_Table (Table, Num_States, Start_State, End_State);\n@@ -1558,7 +1677,7 @@ package body System.Regexp is\n          --  Creates the secondary table\n \n          R := Create_Secondary_Table\n-           (Table, Num_States, Start_State, End_State);\n+            (Table, Num_States, Start_State, End_State);\n          Free (Table);\n          return R;\n       end;"}]}