{"sha": "46de64cad15d3673b13bc6d9a9d9f31e84da3ef6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZkZTY0Y2FkMTVkMzY3M2IxM2JjNmQ5YTlkOWYzMWU4NGRhM2VmNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-20T14:08:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-20T14:08:31Z"}, "message": "[multiple changes]\n\n2014-02-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Add_Item_To_Name_Buffer): New routine.\n\t(Analyze_Contract_Case): Remove the use of\n\t\"may\". Replace \"aspect Contract_Cases\" to avoid categorization\n\tof aspect vs pragma.\n\t(Analyze_External_Property_In_Decl_Part): Remove the use of \"formal\".\n\t(Analyze_Global_Item): Remove\n\tthe use of \"formal\", specify the subprogram.  Split the\n\terror message about a state with visible refinement into\n\ttwo. Remove the use of \"global\" from \"volatile global item\".\n\t(Analyze_Initialization_Item): Ensure that the SPARK RM reference\n\tis on one line.\n\t(Analyze_Input_Output): Update the call to\n\tCheck_Mode. Specify the duplicated item. Reword the error\n\tmessage concerning an input of a null output list. Use \"\\\"\n\tfor error message continuation.\n\t(Analyze_Part_Of): Remove\n\tthe use of \"may\". Use \"\\\" for error message continuation.\n\t(Analyze_Refined_Depends_In_Decl_Part): Update the error\n\tmessage concerning a useless refinement to match the format\n\tof Refined_Global.\n\t(Analyze_Refined_Global_In_Decl_Part): Reword the error message\n\tconcerning a useless refinement.\n\t(Analyze_Refinement_Clause): Use \"\\\" for error message continuation.\n\t(Check_Constituent_Usage): Use \"\\\" for error message continuation.\n\t(Check_Dependency_Clause): Use \"\\\" for error message continuation.\n\t(Check_Matching_Constituent): Use \"\\\" for error message continuation.\n\t(Check_Missing_Part_Of): Use \"\\\" for error message continuation.\n\t(Check_Mode): Renamed to\n\tCheck_Role. Update the comment on usage. Redo the error reporting\n\tto use Role_Error.\n\t(Check_Mode_Restriction_In_Enclosing_Context): Use \"\\\" for error\n\tmessage continuation.\n\t(Find_Mode): Renamed to Find_Role. Update the parameter profile along\n\twith comment on usage. Update all occurrences of Is_Input and Is_Output.\n\t(Inconsistent_Mode_Error): Use \"\\\" for error message continuation.\n\t(Input_Match): Use \"\\\" for error message continuation.\n\t(Role_Error): New routine.\n\t(Set_Convention_From_Pragma): Use \"\\\" for error message continuation.\n\t(Usage_Error): Add local variable Error_Msg. Build specialized error\n\tmessage showcasing the offending item kind. Redo the diagnostics for\n\tunconstrained types.\n\n2014-02-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.adb (Is_Iterated_Container): Use high-level primitives\n\tto determine whether a type is a container type, rather than\n\texamining only its type declaration, so that subtypes and derived\n\ttypes are handled properly.\n\n2014-02-20  Sergey Rybin  <rybin@adacore.com frybin>\n\n\t* gnat_ugn.texi: gnatmetric: add description of project-specific\n\toptions.\n\n2014-02-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute, case 'Update): Verify that\n\tall choices in an association for a record type have the same\n\ttype, as is done for record aggregates.\n\nFrom-SVN: r207952", "tree": {"sha": "d134b6245be3389f605040c20af158db624f2c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d134b6245be3389f605040c20af158db624f2c1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6/comments", "author": null, "committer": null, "parents": [{"sha": "923e95e77732b24d17d1bb8c335084213255f718", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/923e95e77732b24d17d1bb8c335084213255f718", "html_url": "https://github.com/Rust-GCC/gccrs/commit/923e95e77732b24d17d1bb8c335084213255f718"}], "stats": {"total": 594, "additions": 410, "deletions": 184}, "files": [{"sha": "68e414c1043b958fea4dc85e075d39be738404fd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=46de64cad15d3673b13bc6d9a9d9f31e84da3ef6", "patch": "@@ -1,3 +1,65 @@\n+2014-02-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Add_Item_To_Name_Buffer): New routine.\n+\t(Analyze_Contract_Case): Remove the use of\n+\t\"may\". Replace \"aspect Contract_Cases\" to avoid categorization\n+\tof aspect vs pragma.\n+\t(Analyze_External_Property_In_Decl_Part): Remove the use of \"formal\".\n+\t(Analyze_Global_Item): Remove\n+\tthe use of \"formal\", specify the subprogram.  Split the\n+\terror message about a state with visible refinement into\n+\ttwo. Remove the use of \"global\" from \"volatile global item\".\n+\t(Analyze_Initialization_Item): Ensure that the SPARK RM reference\n+\tis on one line.\n+\t(Analyze_Input_Output): Update the call to\n+\tCheck_Mode. Specify the duplicated item. Reword the error\n+\tmessage concerning an input of a null output list. Use \"\\\"\n+\tfor error message continuation.\n+\t(Analyze_Part_Of): Remove\n+\tthe use of \"may\". Use \"\\\" for error message continuation.\n+\t(Analyze_Refined_Depends_In_Decl_Part): Update the error\n+\tmessage concerning a useless refinement to match the format\n+\tof Refined_Global.\n+\t(Analyze_Refined_Global_In_Decl_Part): Reword the error message\n+\tconcerning a useless refinement.\n+\t(Analyze_Refinement_Clause): Use \"\\\" for error message continuation.\n+\t(Check_Constituent_Usage): Use \"\\\" for error message continuation.\n+\t(Check_Dependency_Clause): Use \"\\\" for error message continuation.\n+\t(Check_Matching_Constituent): Use \"\\\" for error message continuation.\n+\t(Check_Missing_Part_Of): Use \"\\\" for error message continuation.\n+\t(Check_Mode): Renamed to\n+\tCheck_Role. Update the comment on usage. Redo the error reporting\n+\tto use Role_Error.\n+\t(Check_Mode_Restriction_In_Enclosing_Context): Use \"\\\" for error\n+\tmessage continuation.\n+\t(Find_Mode): Renamed to Find_Role. Update the parameter profile along\n+\twith comment on usage. Update all occurrences of Is_Input and Is_Output.\n+\t(Inconsistent_Mode_Error): Use \"\\\" for error message continuation.\n+\t(Input_Match): Use \"\\\" for error message continuation.\n+\t(Role_Error): New routine.\n+\t(Set_Convention_From_Pragma): Use \"\\\" for error message continuation.\n+\t(Usage_Error): Add local variable Error_Msg. Build specialized error\n+\tmessage showcasing the offending item kind. Redo the diagnostics for\n+\tunconstrained types.\n+\n+2014-02-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.adb (Is_Iterated_Container): Use high-level primitives\n+\tto determine whether a type is a container type, rather than\n+\texamining only its type declaration, so that subtypes and derived\n+\ttypes are handled properly.\n+\n+2014-02-20  Sergey Rybin  <rybin@adacore.com frybin>\n+\n+\t* gnat_ugn.texi: gnatmetric: add description of project-specific\n+\toptions.\n+\n+2014-02-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute, case 'Update): Verify that\n+\tall choices in an association for a record type have the same\n+\ttype, as is done for record aggregates.\n+\n 2014-02-20  Robert Dewar  <dewar@adacore.com>\n \n \t* a-cborma.adb, a-cbhama.adb, a-cbdlli.adb, a-cbmutr.adb: Use pragma"}, {"sha": "ddbc98ffdf65364b360c92ad02c9550dc8f43101", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=46de64cad15d3673b13bc6d9a9d9f31e84da3ef6", "patch": "@@ -4481,57 +4481,57 @@ package body Exp_Util is\n             Typ := Designated_Type (Typ);\n          end if;\n \n-         --  Look for aspect Default_Iterator\n+         --  Look for aspect Default_Iterator. It may be part of a type\n+         --  declaration for a container, or inherited from a base type\n+         --  or parent type.\n \n-         if Has_Aspects (Parent (Typ)) then\n-            Aspect := Find_Value_Of_Aspect (Typ, Aspect_Default_Iterator);\n+         Aspect := Find_Value_Of_Aspect (Typ, Aspect_Default_Iterator);\n \n-            if Present (Aspect) then\n-               Iter := Entity (Aspect);\n+         if Present (Aspect) then\n+            Iter := Entity (Aspect);\n \n-               --  Examine the statements following the container object and\n-               --  look for a call to the default iterate routine where the\n-               --  first parameter is the transient. Such a call appears as:\n+            --  Examine the statements following the container object and\n+            --  look for a call to the default iterate routine where the\n+            --  first parameter is the transient. Such a call appears as:\n \n-               --     It : Access_To_CW_Iterator :=\n-               --            Iterate (Tran_Id.all, ...)'reference;\n+            --     It : Access_To_CW_Iterator :=\n+            --            Iterate (Tran_Id.all, ...)'reference;\n \n-               Stmt := First_Stmt;\n-               while Present (Stmt) loop\n+            Stmt := First_Stmt;\n+            while Present (Stmt) loop\n \n-                  --  Detect an object declaration which is initialized by a\n-                  --  secondary stack function call.\n+               --  Detect an object declaration which is initialized by a\n+               --  secondary stack function call.\n \n-                  if Nkind (Stmt) = N_Object_Declaration\n-                    and then Present (Expression (Stmt))\n-                    and then Nkind (Expression (Stmt)) = N_Reference\n-                    and then Nkind (Prefix (Expression (Stmt))) =\n-                               N_Function_Call\n-                  then\n-                     Call := Prefix (Expression (Stmt));\n+               if Nkind (Stmt) = N_Object_Declaration\n+                 and then Present (Expression (Stmt))\n+                 and then Nkind (Expression (Stmt)) = N_Reference\n+                 and then Nkind (Prefix (Expression (Stmt))) =\n+                            N_Function_Call\n+               then\n+                  Call := Prefix (Expression (Stmt));\n \n-                     --  The call must invoke the default iterate routine of\n-                     --  the container and the transient object must appear as\n-                     --  the first actual parameter. Skip any calls whose names\n-                     --  are not entities.\n+                  --  The call must invoke the default iterate routine of\n+                  --  the container and the transient object must appear as\n+                  --  the first actual parameter. Skip any calls whose names\n+                  --  are not entities.\n \n-                     if Is_Entity_Name (Name (Call))\n-                       and then Entity (Name (Call)) = Iter\n-                       and then Present (Parameter_Associations (Call))\n-                     then\n-                        Param := First (Parameter_Associations (Call));\n+                  if Is_Entity_Name (Name (Call))\n+                    and then Entity (Name (Call)) = Iter\n+                    and then Present (Parameter_Associations (Call))\n+                  then\n+                     Param := First (Parameter_Associations (Call));\n \n-                        if Nkind (Param) = N_Explicit_Dereference\n-                          and then Entity (Prefix (Param)) = Trans_Id\n-                        then\n-                           return True;\n-                        end if;\n+                     if Nkind (Param) = N_Explicit_Dereference\n+                       and then Entity (Prefix (Param)) = Trans_Id\n+                     then\n+                        return True;\n                      end if;\n                   end if;\n+               end if;\n \n-                  Next (Stmt);\n-               end loop;\n-            end if;\n+               Next (Stmt);\n+            end loop;\n          end if;\n \n          return False;"}, {"sha": "d6fe3f51e8385df64d88c16f34d025bd22c77e40", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 60, "deletions": 7, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=46de64cad15d3673b13bc6d9a9d9f31e84da3ef6", "patch": "@@ -15773,7 +15773,8 @@ in files with names that do not follow the GNAT file naming rules, you have to\n provide the configuration file describing the corresponding naming scheme (see\n the description of the @command{gnatmetric} switches below.)\n Alternatively, you may use a project file and invoke @command{gnatmetric}\n-through the @command{gnat} driver (see @ref{The GNAT Driver and Project Files}).\n+through the @command{gnat} driver (see @ref{The GNAT Driver and Project Files}),\n+or you can directly specify a project file as a @command{gnatmetric} parameter.\n \n The @command{gnatmetric} command has the form\n \n@@ -15822,7 +15823,9 @@ The following subsections describe the various switches accepted by\n * Disable Metrics For Local Units::\n * Specifying a set of metrics to compute::\n * Other gnatmetric Switches::\n+@ignore\n * Generate project-wide metrics::\n+@end ignore\n @end menu\n \n @node Output Files Control\n@@ -15839,14 +15842,22 @@ for each Ada source file a corresponding text file\n containing the computed metrics, except for the case when the set of metrics\n specified by gnatmetric parameters consists only of metrics that are computed\n for the whole set of analyzed sources, but not for each Ada source.\n-By default, this file is placed in the same directory as where the source\n-file is located, and its name is obtained\n-by appending the ^@file{.metrix}^@file{$METRIX}^ suffix to the name of the\n-input file.\n+By default, the name of the file containing metric information for a source\n+is obtained by appending the ^@file{.metrix}^@file{$METRIX}^ suffix to the\n+name of the input source file. If not otherwise specified and no project file\n+is specified as @command{gnatmetric} option this file is placed in the same\n+directory as where the source file is located. If @command{gnatmetric} has a\n+project  file as its parameter, it places all the generated files in the\n+object directory of the project (or in the project source directory if the\n+project does not define an objects directory), if @option{--subdirs} option\n+is specified, the files are placed in the subrirectory of this directory\n+specified by this option.\n \n All the output information generated in XML format is placed in a single\n-file. By default this file is placed in the current directory and has the\n-name ^@file{metrix.xml}^@file{METRIX$XML}^.\n+file. By default the name of this file is ^@file{metrix.xml}^@file{METRIX$XML}^.\n+If not otherwise specified and if no project file is specified\n+as @command{gnatmetric} option  this file is placed in the\n+current directory.\n \n Some of the computed metrics are summed over the units passed to\n @command{gnatmetric}; for example, the total number of lines of code.\n@@ -16643,6 +16654,39 @@ Display Copyright and version, then exit disregarding all other options.\n @cindex @option{--help} @command{gnatmetric}\n Display usage, then exit disregarding all other options.\n \n+@item -P @var{file}\n+@cindex @option{-P @var{file}} @command{gnatmetric}\n+Indicates the name of the project file that describes the set of sources\n+to be processed. The exact set of argument sources depends on other options\n+specified, see below.\n+\n+@item -U\n+@cindex @option{-U} @command{gnatmetric}\n+If a project file is specified and no argument source is explicitly\n+specified (either directly or by means of @option{-files} option), process\n+all the units of the closure of the argument project. Otherwise this option\n+has no effect.\n+\n+@item -U @var{main_unit}\n+@cindex @option{-U @var{main_unit}} @command{gnatmetric}\n+If a project file is specified and no argument source is explicitly\n+specified (either directly or by means of @option{-files} option), process\n+the closure of units rooted at @var{main_unit}. Otherwise this option\n+has no effect.\n+\n+@item -X@var{name}=@var{value}\n+@cindex @option{-X@var{name}=@var{value}} @command{gnatmetric}\n+Indicates that external variable @var{name} in the argument project\n+has the @var{value} value. Has no effect if no project is specified as\n+tool argument.\n+\n+@item --subdirs=@var{dir}\n+@cindex @option{--subdirs=@var{dir}} @command{gnatmetric}\n+Use the specified subdirectory of the project objects file (or of the\n+project file directory if the project does not specify an object directory)\n+for tool output files. Has no effect if no project is specified as\n+tool argument.\n+\n @item ^-files @var{filename}^/FILES=@var{filename}^\n @cindex @option{^-files^/FILES^} (@code{gnatmetric})\n Take the argument source files from the specified file. This file should be an\n@@ -16673,6 +16717,14 @@ a trace of sources being processed.\n Quiet mode.\n @end table\n \n+@noindent\n+If a project file is specified and no argument source is explicitly\n+specified (either directly or by means of @option{-files} option), and no\n+@option{-U} is specified, then the set of processed sources is\n+all the immediate units of the argument project.\n+\n+\n+@ignore\n @node Generate project-wide metrics\n @subsection Generate project-wide metrics\n \n@@ -16697,6 +16749,7 @@ the @option{-U} option followed by the name of the main unit:\n @smallexample\n    gnat metric -Pproj -U main\n @end smallexample\n+@end ignore\n \n \n @c ***********************************"}, {"sha": "f8a22ccbf2dbd2f85c5eaf3bbfc103a8457f3441", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=46de64cad15d3673b13bc6d9a9d9f31e84da3ef6", "patch": "@@ -6204,8 +6204,9 @@ package body Sem_Attr is\n \n          --  Local variables\n \n-         Assoc : Node_Id;\n-         Comp  : Node_Id;\n+         Assoc     : Node_Id;\n+         Comp      : Node_Id;\n+         Comp_Type : Entity_Id;\n \n       --  Start of processing for Update\n \n@@ -6240,6 +6241,7 @@ package body Sem_Attr is\n          while Present (Assoc) loop\n             Comp := First (Choices (Assoc));\n             Analyze (Expression (Assoc));\n+            Comp_Type := Empty;\n             while Present (Comp) loop\n                if Nkind (Comp) = N_Others_Choice then\n                   Error_Attr\n@@ -6304,6 +6306,17 @@ package body Sem_Attr is\n                      Error_Msg_N (\"name should be identifier or OTHERS\", Comp);\n                   else\n                      Check_Component_Reference (Comp, P_Type);\n+\n+                     --  Verify that all choices in an association denote\n+                     --  components of the same type.\n+\n+                     if No (Comp_Type) then\n+                        Comp_Type := Base_Type (Etype (Comp));\n+                     elsif Comp_Type /= Base_Type (Etype (Comp)) then\n+                        Error_Msg_N\n+                          (\"components in choice list must have same type\",\n+                             Assoc);\n+                     end if;\n                   end if;\n                end if;\n "}, {"sha": "a7d543e51edcf3a254b1a33d6248909c8fb9082f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 235, "deletions": 137, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=46de64cad15d3673b13bc6d9a9d9f31e84da3ef6", "patch": "@@ -399,23 +399,24 @@ package body Sem_Prag is\n \n             if Present (Extra_Guard) then\n                Error_Msg_N\n-                 (\"contract case may have only one case guard\", Extra_Guard);\n+                 (\"contract case must have exactly one case guard\",\n+                  Extra_Guard);\n             end if;\n \n             --  Check the placement of \"others\" (if available)\n \n             if Nkind (Case_Guard) = N_Others_Choice then\n                if Others_Seen then\n                   Error_Msg_N\n-                    (\"only one others choice allowed in aspect Contract_Cases \"\n+                    (\"only one others choice allowed in contract cases \"\n                      & \"(SPARK RM 6.1.3(1))\", Case_Guard);\n                else\n                   Others_Seen := True;\n                end if;\n \n             elsif Others_Seen then\n                Error_Msg_N\n-                 (\"others must be the last choice in aspect Contract_Cases \"\n+                 (\"others must be the last choice in contract cases \"\n                   & \"(SPARK RM 6.1.3(1))\", N);\n             end if;\n \n@@ -460,7 +461,7 @@ package body Sem_Prag is\n       pragma Assert (Nkind (All_Cases) = N_Aggregate);\n \n       if No (Component_Associations (All_Cases)) then\n-         Error_Msg_N (\"wrong syntax for aspect Contract_Cases\", N);\n+         Error_Msg_N (\"wrong syntax for constract cases\", N);\n \n       --  Individual contract cases appear as component associations\n \n@@ -536,6 +537,15 @@ package body Sem_Prag is\n       --  Two lists containing the full set of inputs and output of the related\n       --  subprograms. Note that these lists contain both nodes and entities.\n \n+      procedure Add_Item_To_Name_Buffer (Item_Id : Entity_Id);\n+      --  Subsidiary routine to Check_Role and Check_Usage. Add the item kind\n+      --  to the name buffer. The individual kinds are as follows:\n+      --    E_Abstract_State   - \"state\"\n+      --    E_In_Parameter     - \"parameter\"\n+      --    E_In_Out_Parameter - \"parameter\"\n+      --    E_Out_Parameter    - \"parameter\"\n+      --    E_Variable         - \"global\"\n+\n       procedure Analyze_Dependency_Clause\n         (Clause  : Node_Id;\n          Is_Last : Boolean);\n@@ -545,16 +555,17 @@ package body Sem_Prag is\n       procedure Check_Function_Return;\n       --  Verify that Funtion'Result appears as one of the outputs\n \n-      procedure Check_Mode\n+      procedure Check_Role\n         (Item     : Node_Id;\n          Item_Id  : Entity_Id;\n          Is_Input : Boolean;\n          Self_Ref : Boolean);\n-      --  Ensure that an item has a proper IN, IN OUT, or OUT mode depending\n-      --  on its function. If this is not the case, emit an error. Item and\n-      --  Item_Id denote the attributes of an item. Flag Is_Input should be set\n-      --  when item comes from an input list. Flag Self_Ref should be set when\n-      --  the item is an output and the dependency clause has operator \"+\".\n+      --  Ensure that an item fulfils its designated input and/or output role\n+      --  as specified by pragma Global (if any) or the enclosing context. If\n+      --  this is not the case, emit an error. Item and Item_Id denote the\n+      --  attributes of an item. Flag Is_Input should be set when item comes\n+      --  from an input list. Flag Self_Ref should be set when the item is an\n+      --  output and the dependency clause has operator \"+\".\n \n       procedure Check_Usage\n         (Subp_Items : Elist_Id;\n@@ -568,6 +579,28 @@ package body Sem_Prag is\n       --  a clause with multiple outputs into multiple clauses with a single\n       --  output.\n \n+      -----------------------------\n+      -- Add_Item_To_Name_Buffer --\n+      -----------------------------\n+\n+      procedure Add_Item_To_Name_Buffer (Item_Id : Entity_Id) is\n+      begin\n+         if Ekind (Item_Id) = E_Abstract_State then\n+            Add_Str_To_Name_Buffer (\"state\");\n+\n+         elsif Is_Formal (Item_Id) then\n+            Add_Str_To_Name_Buffer (\"parameter\");\n+\n+         elsif Ekind (Item_Id) = E_Variable then\n+            Add_Str_To_Name_Buffer (\"global\");\n+\n+         --  The routine should not be called with non-SPARK items\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+      end Add_Item_To_Name_Buffer;\n+\n       -------------------------------\n       -- Analyze_Dependency_Clause --\n       -------------------------------\n@@ -807,17 +840,19 @@ package body Sem_Prag is\n                                         E_Out_Parameter,\n                                         E_Variable)\n                   then\n-                     --  Ensure that the item is of the correct mode depending\n-                     --  on its function.\n+                     --  Ensure that the item fulfils its role as input and/or\n+                     --  output as specified by pragma Global or the enclosing\n+                     --  context.\n \n-                     Check_Mode (Item, Item_Id, Is_Input, Self_Ref);\n+                     Check_Role (Item, Item_Id, Is_Input, Self_Ref);\n \n                      --  Detect multiple uses of the same state, variable or\n                      --  formal parameter. If this is not the case, add the\n                      --  item to the list of processed relations.\n \n                      if Contains (Seen, Item_Id) then\n-                        Error_Msg_N (\"duplicate use of item\", Item);\n+                        Error_Msg_NE\n+                          (\"duplicate use of item &\", Item, Item_Id);\n                      else\n                         Add_Item (Item_Id, Seen);\n                      end if;\n@@ -831,8 +866,9 @@ package body Sem_Prag is\n                        and then Contains (All_Inputs_Seen, Item_Id)\n                      then\n                         Error_Msg_N\n-                          (\"input of a null output list appears in multiple \"\n-                           & \"input lists (SPARK RM 6.1.5(13))\", Item);\n+                          (\"input of a null output list cannot appear in \"\n+                           & \"multiple input lists (SPARK RM 6.1.5(13))\",\n+                           Item);\n                      end if;\n \n                      --  Add an input or a self-referential output to the list\n@@ -850,7 +886,7 @@ package body Sem_Prag is\n                              (\"cannot mention state & in global refinement\",\n                               Item, Item_Id);\n                            Error_Msg_N\n-                              (\"\\use its constituents instead \"\n+                              (\"\\\\use its constituents instead \"\n                                & \"(SPARK RM 6.1.5(3))\", Item);\n                            return;\n \n@@ -892,15 +928,15 @@ package body Sem_Prag is\n \n                   else\n                      Error_Msg_N\n-                        (\"item must denote variable, state or formal \"\n-                         & \"parameter (SPARK RM 6.1.5(1))\", Item);\n+                       (\"item must denote parameter, variable or state \"\n+                        & \"(SPARK RM 6.1.5(1))\", Item);\n                   end if;\n \n                --  All other input/output items are illegal\n \n                else\n                   Error_Msg_N\n-                    (\"item must denote variable, state or formal parameter \"\n+                    (\"item must denote parameter, variable or state \"\n                      & \"(SPARK RM 6.1.5(1))\", Item);\n                end if;\n             end if;\n@@ -964,36 +1000,39 @@ package body Sem_Prag is\n       end Check_Function_Return;\n \n       ----------------\n-      -- Check_Mode --\n+      -- Check_Role --\n       ----------------\n \n-      procedure Check_Mode\n+      procedure Check_Role\n         (Item     : Node_Id;\n          Item_Id  : Entity_Id;\n          Is_Input : Boolean;\n          Self_Ref : Boolean)\n       is\n-         procedure Find_Mode\n-           (Is_Input    : out Boolean;\n-            Is_Output   : out Boolean;\n-            From_Global : out Boolean);\n-         --  Find the mode of Item_Id. Flags Is_Input and Is_Output are set\n-         --  depending on the mode. Flag From_Global is set when the mode is\n-         --  determined by pragma [Refined_]Global.\n+         procedure Find_Role\n+           (Item_Is_Input  : out Boolean;\n+            Item_Is_Output : out Boolean);\n+         --  Find the input/output role of Item_Id. Flags Item_Is_Input and\n+         --  Item_Is_Output are set depending on the role.\n+\n+         procedure Role_Error\n+           (Item_Is_Input  : Boolean;\n+            Item_Is_Output : Boolean);\n+         --  Emit an error message concerning the incorrect use of Item in\n+         --  pragma [Refined_]Depends. Flags Item_Is_Input and Item_Is_Output\n+         --  denote whether the item is an input and/or an output.\n \n          ---------------\n-         -- Find_Mode --\n+         -- Find_Role --\n          ---------------\n \n-         procedure Find_Mode\n-           (Is_Input    : out Boolean;\n-            Is_Output   : out Boolean;\n-            From_Global : out Boolean)\n+         procedure Find_Role\n+           (Item_Is_Input  : out Boolean;\n+            Item_Is_Output : out Boolean)\n          is\n          begin\n-            Is_Input    := False;\n-            Is_Output   := False;\n-            From_Global := False;\n+            Item_Is_Input  := False;\n+            Item_Is_Output := False;\n \n             --  Abstract state cases\n \n@@ -1004,30 +1043,28 @@ package body Sem_Prag is\n \n                if Global_Seen then\n                   if Appears_In (Subp_Inputs, Item_Id) then\n-                     Is_Input    := True;\n-                     From_Global := True;\n+                     Item_Is_Input := True;\n                   end if;\n \n                   if Appears_In (Subp_Outputs, Item_Id) then\n-                     Is_Output   := True;\n-                     From_Global := True;\n+                     Item_Is_Output := True;\n                   end if;\n \n                --  Otherwise the state has a default IN OUT mode\n \n                else\n-                  Is_Input  := True;\n-                  Is_Output := True;\n+                  Item_Is_Input  := True;\n+                  Item_Is_Output := True;\n                end if;\n \n             --  Parameter cases\n \n             elsif Ekind (Item_Id) = E_In_Parameter then\n-               Is_Input := True;\n+               Item_Is_Input := True;\n \n             elsif Ekind (Item_Id) = E_In_Out_Parameter then\n-               Is_Input  := True;\n-               Is_Output := True;\n+               Item_Is_Input  := True;\n+               Item_Is_Output := True;\n \n             elsif Ekind (Item_Id) = E_Out_Parameter then\n                if Scope (Item_Id) = Spec_Id then\n@@ -1037,17 +1074,17 @@ package body Sem_Prag is\n                   --  bounds, discriminants or tags can be read.\n \n                   if Is_Unconstrained_Or_Tagged_Item (Item_Id) then\n-                     Is_Input := True;\n+                     Item_Is_Input := True;\n                   end if;\n \n-                  Is_Output := True;\n+                  Item_Is_Output := True;\n \n                --  An OUT parameter of an enclosing subprogram behaves as a\n                --  read-write variable in which case the mode is IN OUT.\n \n                else\n-                  Is_Input  := True;\n-                  Is_Output := True;\n+                  Item_Is_Input  := True;\n+                  Item_Is_Output := True;\n                end if;\n \n             --  Variable cases\n@@ -1066,73 +1103,120 @@ package body Sem_Prag is\n                   if Appears_In (Subp_Inputs, Item_Id)\n                     or else Is_Unconstrained_Or_Tagged_Item (Item_Id)\n                   then\n-                     Is_Input    := True;\n-                     From_Global := True;\n+                     Item_Is_Input := True;\n                   end if;\n \n                   if Appears_In (Subp_Outputs, Item_Id) then\n-                     Is_Output   := True;\n-                     From_Global := True;\n+                     Item_Is_Output := True;\n                   end if;\n \n                --  Otherwise the variable has a default IN OUT mode\n \n                else\n-                  Is_Input  := True;\n-                  Is_Output := True;\n+                  Item_Is_Input  := True;\n+                  Item_Is_Output := True;\n+               end if;\n+            end if;\n+         end Find_Role;\n+\n+         ----------------\n+         -- Role_Error --\n+         ----------------\n+\n+         procedure Role_Error\n+           (Item_Is_Input  : Boolean;\n+            Item_Is_Output : Boolean)\n+         is\n+            Error_Msg : Name_Id;\n+\n+         begin\n+            Name_Len := 0;\n+\n+            --  When the item is not part of the input and the output set of\n+            --  the related subprogram, then it appears as extra in pragma\n+            --  [Refined_]Depends.\n+\n+            if not Item_Is_Input and then not Item_Is_Output then\n+               Add_Item_To_Name_Buffer (Item_Id);\n+               Add_Str_To_Name_Buffer\n+                 (\" & cannot appear in dependence relation\");\n+\n+               Error_Msg := Name_Find;\n+               Error_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n+\n+               Error_Msg_Name_1 := Chars (Subp_Id);\n+               Error_Msg_NE\n+                 (\"\\\\& is not part of the input or output set of subprogram %\",\n+                  Item, Item_Id);\n+\n+            --  The mode of the item and its role in pragma [Refined_]Depends\n+            --  are in conflict. Construct a detailed message explaining the\n+            --  illegality.\n+\n+            else\n+               if Item_Is_Input then\n+                  Add_Str_To_Name_Buffer (\"read-only\");\n+               else\n+                  Add_Str_To_Name_Buffer (\"write-only\");\n+               end if;\n+\n+               Add_Char_To_Name_Buffer (' ');\n+               Add_Item_To_Name_Buffer (Item_Id);\n+               Add_Str_To_Name_Buffer  (\" & cannot appear as \");\n+\n+               if Item_Is_Input then\n+                  Add_Str_To_Name_Buffer (\"output\");\n+               else\n+                  Add_Str_To_Name_Buffer (\"input\");\n                end if;\n+\n+               Add_Str_To_Name_Buffer (\" in dependence relation \");\n+\n+               --  Even though the two SPARK references differ by one character\n+               --  they are fully written out to facilitate reference finding\n+               --  and updating.\n+\n+               if Item_Is_Input then\n+                  Add_Str_To_Name_Buffer (\"(SPARK RM 6.1.5(5))\");\n+               else\n+                  Add_Str_To_Name_Buffer (\"(SPARK RM 6.1.5(6))\");\n+               end if;\n+\n+               Error_Msg := Name_Find;\n+               Error_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n             end if;\n-         end Find_Mode;\n+         end Role_Error;\n \n          --  Local variables\n \n          Item_Is_Input  : Boolean;\n          Item_Is_Output : Boolean;\n-         From_Global    : Boolean;\n \n-      --  Start of processing for Check_Mode\n+      --  Start of processing for Check_Role\n \n       begin\n-         Find_Mode (Item_Is_Input, Item_Is_Output, From_Global);\n+         Find_Role (Item_Is_Input, Item_Is_Output);\n \n          --  Input item\n \n          if Is_Input then\n             if not Item_Is_Input then\n-               if From_Global then\n-                  Error_Msg_NE\n-                    (\"item & must have mode `IN` or `IN OUT`\", Item, Item_Id);\n-               else\n-                  Error_Msg_NE\n-                    (\"item & appears as extra in input list\", Item, Item_Id);\n-               end if;\n+               Role_Error (Item_Is_Input, Item_Is_Output);\n             end if;\n \n          --  Self-referential item\n \n          elsif Self_Ref then\n             if not Item_Is_Input or else not Item_Is_Output then\n-               if From_Global then\n-                  Error_Msg_NE\n-                    (\"item & must have mode `IN OUT`\", Item, Item_Id);\n-               else\n-                  Error_Msg_NE\n-                    (\"item & appears as extra in In_Out list\", Item, Item_Id);\n-               end if;\n+               Role_Error (Item_Is_Input, Item_Is_Output);\n             end if;\n \n          --  Output item\n \n          elsif not Item_Is_Output then\n-            if From_Global then\n-               Error_Msg_NE\n-                 (\"item & must have mode `OUT` or `IN OUT`\", Item, Item_Id);\n-            else\n-               Error_Msg_NE\n-                 (\"item & appears as extra in output list\", Item, Item_Id);\n-            end if;\n+            Role_Error (Item_Is_Input, Item_Is_Output);\n          end if;\n-      end Check_Mode;\n+      end Check_Role;\n \n       -----------------\n       -- Check_Usage --\n@@ -1151,46 +1235,52 @@ package body Sem_Prag is\n          -----------------\n \n          procedure Usage_Error (Item : Node_Id; Item_Id : Entity_Id) is\n-            Typ : constant Entity_Id := Etype (Item_Id);\n+            Typ       : constant Entity_Id := Etype (Item_Id);\n+            Error_Msg : Name_Id;\n \n          begin\n+            Name_Len := 0;\n+\n             --  Input case\n \n             if Is_Input then\n-               Error_Msg_NE\n-                 (\"item & must appear in at least one input dependence list \"\n-                  & \"(SPARK RM 6.1.5(8))\", Item, Item_Id);\n+               Add_Item_To_Name_Buffer (Item_Id);\n+               Add_Str_To_Name_Buffer\n+                 (\" & must appear in at least one input dependence list \"\n+                  & \"(SPARK RM 6.1.5(8))\");\n \n-               --  Refine the error message for unconstrained OUT parameters\n-               --  by giving the reason for the illegality.\n+               Error_Msg := Name_Find;\n+               Error_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n+\n+               --  Refine the error message for unconstrained parameters and\n+               --  variables by giving the reason for the illegality.\n \n                if Ekind (Item_Id) = E_Out_Parameter then\n \n-                  --  One case is an unconstrained array where the bounds\n-                  --  must be read, if we have this case, output a message\n-                  --  indicating why the OUT parameter is read.\n+                  --  Unconstrained arrays must appear as inputs because their\n+                  --  bounds must be read.\n \n                   if Is_Array_Type (Typ)\n                     and then not Is_Constrained (Typ)\n                   then\n                      Error_Msg_NE\n-                       (\"\\& is an unconstrained array type, so bounds must be \"\n-                        & \"read\", Item, Typ);\n+                       (\"\\\\type & is an unconstrained array\", Item, Typ);\n+                     Error_Msg_N (\"\\\\array bounds must be read\", Item);\n \n-                  --  Another case is an unconstrained discriminated record\n-                  --  type where the constrained flag must be read (and if\n-                  --  set, the discriminants). Again output a message.\n+                  --  Unconstrained discriminated records must appear as inputs\n+                  --  because their discriminants and constrained flag must be\n+                  --  read.\n \n                   elsif Is_Record_Type (Typ)\n                     and then Has_Discriminants (Typ)\n                     and then not Is_Constrained (Typ)\n                   then\n                      Error_Msg_NE\n-                       (\"\\& is an unconstrained discriminated record type\",\n+                       (\"\\\\type & is an unconstrained discriminated record\",\n                         Item, Typ);\n                      Error_Msg_N\n-                       (\"\\constrained flag and possible discriminants must be \"\n-                        & \"read\", Item);\n+                       (\"\\\\discriminants and constrained flag must be read\",\n+                        Item);\n \n                   --  Not clear if there are other cases. Anyway, we will\n                   --  simply ignore any other cases.\n@@ -1203,9 +1293,13 @@ package body Sem_Prag is\n             --  Output case\n \n             else\n-               Error_Msg_NE\n-                 (\"item & must appear in exactly one output dependence list \"\n-                  & \"(SPARK RM 6.1.5(10))\", Item, Item_Id);\n+               Add_Item_To_Name_Buffer (Item_Id);\n+               Add_Str_To_Name_Buffer\n+                 (\" & must appear in exactly one output dependence list \"\n+                  & \"(SPARK RM 6.1.5(10))\");\n+\n+               Error_Msg := Name_Find;\n+               Error_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n             end if;\n          end Usage_Error;\n \n@@ -1805,7 +1899,7 @@ package body Sem_Prag is\n            and then Is_Formal (Entity (Obj))\n          then\n             Error_Msg_N\n-              (\"external property % cannot apply to a formal parameter \"\n+              (\"external property % cannot apply to parameter \"\n                & \"(SPARK RM 7.1.3(2))\", N);\n          end if;\n       else\n@@ -1943,9 +2037,9 @@ package body Sem_Prag is\n \n                if Is_Formal (Item_Id) then\n                   if Scope (Item_Id) = Spec_Id then\n-                     Error_Msg_N\n-                       (\"global item cannot reference formal parameter \"\n-                        & \"(SPARK RM 6.1.4(6))\", Item);\n+                     Error_Msg_NE\n+                       (\"global item cannot reference parameter of subprogram \"\n+                        & \"& (SPARK RM 6.1.4(6))\", Item, Spec_Id);\n                      return;\n                   end if;\n \n@@ -1977,9 +2071,11 @@ package body Sem_Prag is\n \n                   if Has_Visible_Refinement (Item_Id) then\n                      Error_Msg_NE\n-                       (\"cannot mention state & in global refinement, use its \"\n-                        & \"constituents instead (SPARK RM 6.1.4(8))\",\n+                       (\"cannot mention state & in global refinement\",\n                         Item, Item_Id);\n+                     Error_Msg_N\n+                       (\"\\\\use its constituents instead (SPARK RM 6.1.4(8))\",\n+                        Item);\n                      return;\n \n                   --  If the reference to the abstract state appears in an\n@@ -2003,9 +2099,9 @@ package body Sem_Prag is\n                     and then Global_Mode = Name_Input\n                   then\n                      Error_Msg_NE\n-                       (\"volatile global item & with property Effective_Reads \"\n-                        & \"must have mode In_Out or Output \"\n-                        & \"(SPARK RM 7.1.3(11))\", Item, Item_Id);\n+                       (\"volatile item & with property Effective_Reads must \"\n+                        & \"have mode In_Out or Output (SPARK RM 7.1.3(11))\",\n+                        Item, Item_Id);\n                      return;\n                   end if;\n                end if;\n@@ -2129,7 +2225,7 @@ package body Sem_Prag is\n                        (\"global item & cannot have mode In_Out or Output \"\n                         & \"(SPARK RM 6.1.4(12))\", Item, Item_Id);\n                      Error_Msg_NE\n-                       (\"\\item already appears as input of subprogram &\",\n+                       (\"\\\\item already appears as input of subprogram &\",\n                         Item, Context);\n \n                      --  Stop the traversal once an error has been detected\n@@ -2472,8 +2568,8 @@ package body Sem_Prag is\n \n             else\n                Error_Msg_N\n-                 (\"initialization item must denote variable or state (SPARK \"\n-                  & \"RM 7.1.5(3))\", Item);\n+                 (\"initialization item must denote variable or state \"\n+                  & \"(SPARK RM 7.1.5(3))\", Item);\n             end if;\n          end if;\n       end Analyze_Initialization_Item;\n@@ -3369,11 +3465,11 @@ package body Sem_Prag is\n \n          if Placement = Not_In_Package then\n             Error_Msg_N\n-              (\"indicator Part_Of may not appear in this context \"\n+              (\"indicator Part_Of cannot appear in this context \"\n                & \"(SPARK RM 7.2.6(5))\", Indic);\n             Error_Msg_Name_1 := Chars (Scope (State_Id));\n             Error_Msg_NE\n-              (\"\\& is not part of the hidden state of package %\",\n+              (\"\\\\& is not part of the hidden state of package %\",\n                Indic, Item_Id);\n \n          --  The item appears in the visible state space of some package. In\n@@ -3397,11 +3493,11 @@ package body Sem_Prag is\n \n             else\n                Error_Msg_N\n-                 (\"indicator Part_Of may not appear in this context (SPARK \"\n+                 (\"indicator Part_Of cannot appear in this context (SPARK \"\n                   & \"RM 7.2.6(5))\", Indic);\n                Error_Msg_Name_1 := Chars (Pack_Id);\n                Error_Msg_NE\n-                 (\"\\& is declared in the visible part of package %\",\n+                 (\"\\\\& is declared in the visible part of package %\",\n                   Indic, Item_Id);\n             end if;\n \n@@ -3415,7 +3511,7 @@ package body Sem_Prag is\n                   & \"package & (SPARK RM 7.2.6(2))\", Indic, Pack_Id);\n                Error_Msg_Name_1 := Chars (Pack_Id);\n                Error_Msg_NE\n-                 (\"\\& is declared in the private part of package %\",\n+                 (\"\\\\& is declared in the private part of package %\",\n                   Indic, Item_Id);\n             end if;\n \n@@ -3424,13 +3520,13 @@ package body Sem_Prag is\n \n          else\n             Error_Msg_N\n-              (\"indicator Part_Of may not appear in this context \"\n+              (\"indicator Part_Of cannot appear in this context \"\n                & \"(SPARK RM 7.2.6(5))\", Indic);\n \n             if Scope (State_Id) = Pack_Id then\n                Error_Msg_Name_1 := Chars (Pack_Id);\n                Error_Msg_NE\n-                 (\"\\& is declared in the body of package %\", Indic, Item_Id);\n+                 (\"\\\\& is declared in the body of package %\", Indic, Item_Id);\n             end if;\n          end if;\n \n@@ -6531,7 +6627,8 @@ package body Sem_Prag is\n                Error_Msg_N\n                  (\"& may not have Ghost convention\", E);\n                Error_Msg_N\n-                 (\"\\only functions are permitted to have Ghost convention\", E);\n+                 (\"\\\\only functions are permitted to have Ghost convention\",\n+                  E);\n                return;\n             end if;\n \n@@ -21644,7 +21741,7 @@ package body Sem_Prag is\n \n             if Has_Refined_State then\n                Error_Msg_N\n-                 (\"\\check the use of constituents in dependence refinement\",\n+                 (\"\\\\check the use of constituents in dependence refinement\",\n                   Ref_Clause);\n             end if;\n          end if;\n@@ -21869,7 +21966,7 @@ package body Sem_Prag is\n \n             if Has_Refined_State then\n                Match_Error\n-                 (\"\\check the use of constituents in dependence refinement\",\n+                 (\"\\\\check the use of constituents in dependence refinement\",\n                   Dep_Input);\n             end if;\n \n@@ -22107,8 +22204,8 @@ package body Sem_Prag is\n \n       if No (Depends) then\n          Error_Msg_NE\n-           (\"useless refinement, subprogram & lacks dependence clauses (SPARK \"\n-            & \"RM 7.2.5(2))\", N, Spec_Id);\n+           (\"useless refinement, declaration of subprogram & lacks aspect or \"\n+            & \"pragma Depends (SPARK RM 7.2.5(2))\", N, Spec_Id);\n          return;\n       end if;\n \n@@ -22510,7 +22607,7 @@ package body Sem_Prag is\n                   end if;\n \n                   Error_Msg_NE\n-                    (\"\\  constituent & is missing in output list\",\n+                    (\"\\\\  constituent & is missing in output list\",\n                      N, Constit_Id);\n                end if;\n \n@@ -22670,10 +22767,10 @@ package body Sem_Prag is\n                  (\"global item & has inconsistent modes\", Item, Item_Id);\n \n                Error_Msg_Name_1 := Global_Mode;\n-               Error_Msg_N (\"\\  expected mode %\", Item);\n+               Error_Msg_N (\"\\\\  expected mode %\", Item);\n \n                Error_Msg_Name_1 := Expect;\n-               Error_Msg_N (\"\\  found mode %\", Item);\n+               Error_Msg_N (\"\\\\  found mode %\", Item);\n             end Inconsistent_Mode_Error;\n \n          --  Start of processing for Check_Refined_Global_Item\n@@ -22867,7 +22964,8 @@ package body Sem_Prag is\n \n       if No (Global) then\n          Error_Msg_NE\n-           (\"useless refinement, subprogram & lacks global items\", N, Spec_Id);\n+           (\"useless refinement, declaration of subprogram & lacks aspect or \"\n+            & \"pragma Global\", N, Spec_Id);\n          return;\n       end if;\n \n@@ -22896,8 +22994,8 @@ package body Sem_Prag is\n         and then not Has_Null_State\n       then\n          Error_Msg_NE\n-           (\"useless refinement, subprogram & does not mention abstract state \"\n-            & \"with visible refinement\", N, Spec_Id);\n+           (\"useless refinement, subprogram & does not depends on abstract \"\n+            & \"state with visible refinement (SPARK RM 7.2.4(2))\", N, Spec_Id);\n          return;\n       end if;\n \n@@ -23159,7 +23257,7 @@ package body Sem_Prag is\n                        (\"& cannot act as constituent of state %\",\n                         Constit, Constit_Id);\n                      Error_Msg_NE\n-                       (\"\\Part_Of indicator specifies & as encapsulating \"\n+                       (\"\\\\Part_Of indicator specifies & as encapsulating \"\n                         & \"state\", Constit, Encapsulating_State (Constit_Id));\n                   end if;\n \n@@ -23446,7 +23544,7 @@ package body Sem_Prag is\n                     (\"reference to & not allowed (SPARK RM 6.1.4(8))\",\n                      Body_Ref);\n                   Error_Msg_Sloc := Sloc (State);\n-                  Error_Msg_N (\"\\refinement of & is visible#\", Body_Ref);\n+                  Error_Msg_N (\"\\\\refinement of & is visible#\", Body_Ref);\n \n                   Next_Elmt (Body_Ref_Elmt);\n                end loop;\n@@ -24130,8 +24228,8 @@ package body Sem_Prag is\n                   & \"(SPARK RM 7.2.6(3))\", Item_Id);\n                Error_Msg_Name_1 := Chars (Pack_Id);\n                Error_Msg_N\n-                 (\"\\& is declared in the visible part of private child unit %\",\n-                  Item_Id);\n+                 (\"\\\\& is declared in the visible part of private child \"\n+                  & \"unit %\", Item_Id);\n             end if;\n          end if;\n \n@@ -24163,7 +24261,7 @@ package body Sem_Prag is\n                & \"(SPARK RM 7.2.6(2))\", Item_Id);\n             Error_Msg_Name_1 := Chars (Pack_Id);\n             Error_Msg_N\n-              (\"\\& is declared in the private part of package %\", Item_Id);\n+              (\"\\\\& is declared in the private part of package %\", Item_Id);\n          end if;\n       end if;\n    end Check_Missing_Part_Of;"}]}