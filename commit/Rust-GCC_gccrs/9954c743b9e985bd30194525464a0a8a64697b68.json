{"sha": "9954c743b9e985bd30194525464a0a8a64697b68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk1NGM3NDNiOWU5ODViZDMwMTk0NTI1NDY0YTBhOGE2NDY5N2I2OA==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2013-11-06T22:46:39Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2013-11-06T22:46:39Z"}, "message": "float128-cmp-invalid.c, [...]: New tests.\n\ngcc/testsuite:\n\t* gcc.dg/torture/float128-cmp-invalid.c,\n\tgcc.dg/torture/float128-div-underflow.c,\n\tgcc.dg/torture/float128-extend-nan.c,\n\tgcc.dg/torture/fp-int-convert-float128-timode-3.c: New tests.\n\nlibgcc:\n\t* soft-fp/README: Update.\n\t* soft-fp/adddf3.c: Update from glibc.\n\t* soft-fp/addsf3.c: Likewise.\n\t* soft-fp/addtf3.c: Likewise.\n\t* soft-fp/divdf3.c: Likewise.\n\t* soft-fp/divsf3.c: Likewise.\n\t* soft-fp/divtf3.c: Likewise.\n\t* soft-fp/double.h: Likewise.\n\t* soft-fp/eqdf2.c: Likewise.\n\t* soft-fp/eqsf2.c: Likewise.\n\t* soft-fp/eqtf2.c: Likewise.\n\t* soft-fp/extenddftf2.c: Likewise.\n\t* soft-fp/extended.h: Likewise.\n\t* soft-fp/extendsfdf2.c: Likewise.\n\t* soft-fp/extendsftf2.c: Likewise.\n\t* soft-fp/extendxftf2.c: Likewise.\n\t* soft-fp/fixdfdi.c: Likewise.\n\t* soft-fp/fixdfsi.c: Likewise.\n\t* soft-fp/fixdfti.c: Likewise.\n\t* soft-fp/fixsfdi.c: Likewise.\n\t* soft-fp/fixsfsi.c: Likewise.\n\t* soft-fp/fixsfti.c: Likewise.\n\t* soft-fp/fixtfdi.c: Likewise.\n\t* soft-fp/fixtfsi.c: Likewise.\n\t* soft-fp/fixtfti.c: Likewise.\n\t* soft-fp/fixunsdfdi.c: Likewise.\n\t* soft-fp/fixunsdfsi.c: Likewise.\n\t* soft-fp/fixunsdfti.c: Likewise.\n\t* soft-fp/fixunssfdi.c: Likewise.\n\t* soft-fp/fixunssfsi.c: Likewise.\n\t* soft-fp/fixunssfti.c: Likewise.\n\t* soft-fp/fixunstfdi.c: Likewise.\n\t* soft-fp/fixunstfsi.c: Likewise.\n\t* soft-fp/fixunstfti.c: Likewise.\n\t* soft-fp/floatdidf.c: Likewise.\n\t* soft-fp/floatdisf.c: Likewise.\n\t* soft-fp/floatditf.c: Likewise.\n\t* soft-fp/floatsidf.c: Likewise.\n\t* soft-fp/floatsisf.c: Likewise.\n\t* soft-fp/floatsitf.c: Likewise.\n\t* soft-fp/floattidf.c: Likewise.\n\t* soft-fp/floattisf.c: Likewise.\n\t* soft-fp/floattitf.c: Likewise.\n\t* soft-fp/floatundidf.c: Likewise.\n\t* soft-fp/floatundisf.c: Likewise.\n\t* soft-fp/floatunditf.c: Likewise.\n\t* soft-fp/floatunsidf.c: Likewise.\n\t* soft-fp/floatunsisf.c: Likewise.\n\t* soft-fp/floatunsitf.c: Likewise.\n\t* soft-fp/floatuntidf.c: Likewise.\n\t* soft-fp/floatuntisf.c: Likewise.\n\t* soft-fp/floatuntitf.c: Likewise.\n\t* soft-fp/gedf2.c: Likewise.\n\t* soft-fp/gesf2.c: Likewise.\n\t* soft-fp/getf2.c: Likewise.\n\t* soft-fp/ledf2.c: Likewise.\n\t* soft-fp/lesf2.c: Likewise.\n\t* soft-fp/letf2.c: Likewise.\n\t* soft-fp/muldf3.c: Likewise.\n\t* soft-fp/mulsf3.c: Likewise.\n\t* soft-fp/multf3.c: Likewise.\n\t* soft-fp/negdf2.c: Likewise.\n\t* soft-fp/negsf2.c: Likewise.\n\t* soft-fp/negtf2.c: Likewise.\n\t* soft-fp/op-1.h: Likewise.\n\t* soft-fp/op-2.h: Likewise.\n\t* soft-fp/op-4.h: Likewise.\n\t* soft-fp/op-8.h: Likewise.\n\t* soft-fp/op-common.h: Likewise.\n\t* soft-fp/quad.h: Likewise.\n\t* soft-fp/single.h: Likewise.\n\t* soft-fp/soft-fp.h: Likewise.\n\t* soft-fp/subdf3.c: Likewise.\n\t* soft-fp/subsf3.c: Likewise.\n\t* soft-fp/subtf3.c: Likewise.\n\t* soft-fp/truncdfsf2.c: Likewise.\n\t* soft-fp/trunctfdf2.c: Likewise.\n\t* soft-fp/trunctfsf2.c: Likewise.\n\t* soft-fp/trunctfxf2.c: Likewise.\n\t* soft-fp/unorddf2.c: Likewise.\n\t* soft-fp/unordsf2.c: Likewise.\n\t* soft-fp/unordtf2.c: Likewise.\n\nFrom-SVN: r204489", "tree": {"sha": "a0be3468d26216a37289e1817e7dbfea037f2f7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0be3468d26216a37289e1817e7dbfea037f2f7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9954c743b9e985bd30194525464a0a8a64697b68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9954c743b9e985bd30194525464a0a8a64697b68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9954c743b9e985bd30194525464a0a8a64697b68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9954c743b9e985bd30194525464a0a8a64697b68/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c40bae1c50f4fd8c23ee04d7fe768d7df68f2e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c40bae1c50f4fd8c23ee04d7fe768d7df68f2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c40bae1c50f4fd8c23ee04d7fe768d7df68f2e6"}], "stats": {"total": 8605, "additions": 4803, "deletions": 3802}, "files": [{"sha": "27a76280e5d9450322610eb332dcb8d975a99b9d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,3 +1,10 @@\n+2013-11-06  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/torture/float128-cmp-invalid.c,\n+\tgcc.dg/torture/float128-div-underflow.c,\n+\tgcc.dg/torture/float128-extend-nan.c,\n+\tgcc.dg/torture/fp-int-convert-float128-timode-3.c: New tests.\n+\n 2013-11-06  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* gcc.target/sh/pr51244-11.c: Remove target line."}, {"sha": "53ef7ed01b32d24ed5886aea5e30f76dd1428d45", "filename": "gcc/testsuite/gcc.dg/torture/float128-cmp-invalid.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-cmp-invalid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-cmp-invalid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-cmp-invalid.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -0,0 +1,18 @@\n+/* Test for \"invalid\" exceptions from __float128 comparisons.  */\n+/* { dg-do run { target i?86-*-* x86_64-*-* ia64-*-* } } */\n+/* { dg-options \"\" } */\n+\n+#include <fenv.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  volatile __float128 a = __builtin_nan (\"\"), b = 0;\n+  volatile int r = a < b;\n+  if (!fetestexcept (FE_INVALID))\n+    abort ();\n+  if (r)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "43d350f4e4456efa16861bccd91fb8dab46506c6", "filename": "gcc/testsuite/gcc.dg/torture/float128-div-underflow.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-div-underflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-div-underflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-div-underflow.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -0,0 +1,18 @@\n+/* Test for spurious underflow from __float128 division.  */\n+/* { dg-do run { target i?86-*-* x86_64-*-* ia64-*-* } } */\n+/* { dg-options \"\" } */\n+\n+#include <fenv.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  volatile __float128 a = 0x0.fffp-16382q, b = 0x0.fffp0q, c;\n+  c = a / b;\n+  if (fetestexcept (FE_UNDERFLOW | FE_INEXACT))\n+    abort ();\n+  if (c != 0x1p-16382q)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "1942d80f190db34ed5e7891df70a052636525b7b", "filename": "gcc/testsuite/gcc.dg/torture/float128-extend-nan.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-extend-nan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-extend-nan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-extend-nan.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -0,0 +1,22 @@\n+/* Test extensions to __float128 quiet signaling NaNs.  */\n+/* { dg-do run { target i?86-*-* x86_64-*-* ia64-*-* } } */\n+/* { dg-options \"-fsignaling-nans\" } */\n+\n+#include <fenv.h>\n+#include <float.h>\n+#include <stdlib.h>\n+\n+volatile long double a = __builtin_nansl (\"\");\n+\n+int\n+main (void)\n+{\n+#if LDBL_MANT_DIG < 113\n+  volatile __float128 r = a;\n+  feclearexcept (FE_INVALID);\n+  r += 1;\n+  if (fetestexcept (FE_INVALID))\n+    abort ();\n+#endif\n+  exit (0);\n+}"}, {"sha": "944494d9bcc5c6dc6224e087788d59fc7254e93e", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-timode-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-timode-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-timode-3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -0,0 +1,23 @@\n+/* Test for correct rounding of conversions from __int128 to\n+   __float128.  */\n+/* { dg-do run { target i?86-*-* x86_64-*-* ia64-*-* } } */\n+/* { dg-require-effective-target int128 } */\n+/* { dg-options \"-frounding-math\" } */\n+\n+#include <fenv.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  volatile unsigned long long h = -1ULL;\n+  volatile unsigned __int128 u128 = (((unsigned __int128) h) << 64) | h;\n+  volatile __int128 s128 = u128 >> 1;\n+  fesetround (FE_TOWARDZERO);\n+  __float128 ru = u128, rs = s128;\n+  if (ru != 0x1.ffffffffffffffffffffffffffffp127q)\n+    abort ();\n+  if (rs != 0x1.ffffffffffffffffffffffffffffp126q)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "4da11a0406ba3fb5d152003f3f835cc50898f467", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,3 +1,88 @@\n+2013-11-06  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* soft-fp/README: Update.\n+\t* soft-fp/adddf3.c: Update from glibc.\n+\t* soft-fp/addsf3.c: Likewise.\n+\t* soft-fp/addtf3.c: Likewise.\n+\t* soft-fp/divdf3.c: Likewise.\n+\t* soft-fp/divsf3.c: Likewise.\n+\t* soft-fp/divtf3.c: Likewise.\n+\t* soft-fp/double.h: Likewise.\n+\t* soft-fp/eqdf2.c: Likewise.\n+\t* soft-fp/eqsf2.c: Likewise.\n+\t* soft-fp/eqtf2.c: Likewise.\n+\t* soft-fp/extenddftf2.c: Likewise.\n+\t* soft-fp/extended.h: Likewise.\n+\t* soft-fp/extendsfdf2.c: Likewise.\n+\t* soft-fp/extendsftf2.c: Likewise.\n+\t* soft-fp/extendxftf2.c: Likewise.\n+\t* soft-fp/fixdfdi.c: Likewise.\n+\t* soft-fp/fixdfsi.c: Likewise.\n+\t* soft-fp/fixdfti.c: Likewise.\n+\t* soft-fp/fixsfdi.c: Likewise.\n+\t* soft-fp/fixsfsi.c: Likewise.\n+\t* soft-fp/fixsfti.c: Likewise.\n+\t* soft-fp/fixtfdi.c: Likewise.\n+\t* soft-fp/fixtfsi.c: Likewise.\n+\t* soft-fp/fixtfti.c: Likewise.\n+\t* soft-fp/fixunsdfdi.c: Likewise.\n+\t* soft-fp/fixunsdfsi.c: Likewise.\n+\t* soft-fp/fixunsdfti.c: Likewise.\n+\t* soft-fp/fixunssfdi.c: Likewise.\n+\t* soft-fp/fixunssfsi.c: Likewise.\n+\t* soft-fp/fixunssfti.c: Likewise.\n+\t* soft-fp/fixunstfdi.c: Likewise.\n+\t* soft-fp/fixunstfsi.c: Likewise.\n+\t* soft-fp/fixunstfti.c: Likewise.\n+\t* soft-fp/floatdidf.c: Likewise.\n+\t* soft-fp/floatdisf.c: Likewise.\n+\t* soft-fp/floatditf.c: Likewise.\n+\t* soft-fp/floatsidf.c: Likewise.\n+\t* soft-fp/floatsisf.c: Likewise.\n+\t* soft-fp/floatsitf.c: Likewise.\n+\t* soft-fp/floattidf.c: Likewise.\n+\t* soft-fp/floattisf.c: Likewise.\n+\t* soft-fp/floattitf.c: Likewise.\n+\t* soft-fp/floatundidf.c: Likewise.\n+\t* soft-fp/floatundisf.c: Likewise.\n+\t* soft-fp/floatunditf.c: Likewise.\n+\t* soft-fp/floatunsidf.c: Likewise.\n+\t* soft-fp/floatunsisf.c: Likewise.\n+\t* soft-fp/floatunsitf.c: Likewise.\n+\t* soft-fp/floatuntidf.c: Likewise.\n+\t* soft-fp/floatuntisf.c: Likewise.\n+\t* soft-fp/floatuntitf.c: Likewise.\n+\t* soft-fp/gedf2.c: Likewise.\n+\t* soft-fp/gesf2.c: Likewise.\n+\t* soft-fp/getf2.c: Likewise.\n+\t* soft-fp/ledf2.c: Likewise.\n+\t* soft-fp/lesf2.c: Likewise.\n+\t* soft-fp/letf2.c: Likewise.\n+\t* soft-fp/muldf3.c: Likewise.\n+\t* soft-fp/mulsf3.c: Likewise.\n+\t* soft-fp/multf3.c: Likewise.\n+\t* soft-fp/negdf2.c: Likewise.\n+\t* soft-fp/negsf2.c: Likewise.\n+\t* soft-fp/negtf2.c: Likewise.\n+\t* soft-fp/op-1.h: Likewise.\n+\t* soft-fp/op-2.h: Likewise.\n+\t* soft-fp/op-4.h: Likewise.\n+\t* soft-fp/op-8.h: Likewise.\n+\t* soft-fp/op-common.h: Likewise.\n+\t* soft-fp/quad.h: Likewise.\n+\t* soft-fp/single.h: Likewise.\n+\t* soft-fp/soft-fp.h: Likewise.\n+\t* soft-fp/subdf3.c: Likewise.\n+\t* soft-fp/subsf3.c: Likewise.\n+\t* soft-fp/subtf3.c: Likewise.\n+\t* soft-fp/truncdfsf2.c: Likewise.\n+\t* soft-fp/trunctfdf2.c: Likewise.\n+\t* soft-fp/trunctfsf2.c: Likewise.\n+\t* soft-fp/trunctfxf2.c: Likewise.\n+\t* soft-fp/unorddf2.c: Likewise.\n+\t* soft-fp/unordsf2.c: Likewise.\n+\t* soft-fp/unordtf2.c: Likewise.\n+\n 2013-11-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/32/sfp-machine.h (_FP_MUL_MEAT_S): Define."}, {"sha": "d60e88b7fec28d112cd0d5e2b8e0f2f1bb348840", "filename": "libgcc/soft-fp/README", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2FREADME?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,5 +1,4 @@\n-Except for conversions involving TImode and conversions involving\n-XFmode, the files in this directory are part of the GNU C Library, not part\n-of GCC.  As described at <http://gcc.gnu.org/codingconventions.html>, changes\n-should be made to the GNU C Library and the changed files then imported\n-into GCC.\n+The files in this directory are part of the GNU C Library, not part of\n+GCC.  As described at <http://gcc.gnu.org/codingconventions.html>,\n+changes should be made to the GNU C Library and the changed files then\n+imported into GCC."}, {"sha": "5aadfa3318bd6281872816ab33c84fe27a7e4d5d", "filename": "libgcc/soft-fp/adddf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fadddf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fadddf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fadddf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DFtype __adddf3(DFtype a, DFtype b)\n+DFtype\n+__adddf3 (DFtype a, DFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A); FP_DECL_D(B); FP_DECL_D(R);\n+  FP_DECL_D (A);\n+  FP_DECL_D (B);\n+  FP_DECL_D (R);\n   DFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_SEMIRAW_D(A, a);\n-  FP_UNPACK_SEMIRAW_D(B, b);\n-  FP_ADD_D(R, A, B);\n-  FP_PACK_SEMIRAW_D(r, R);\n+  FP_UNPACK_SEMIRAW_D (A, a);\n+  FP_UNPACK_SEMIRAW_D (B, b);\n+  FP_ADD_D (R, A, B);\n+  FP_PACK_SEMIRAW_D (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "ac571bad06b086c590dba707e0883051c362ec9a", "filename": "libgcc/soft-fp/addsf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Faddsf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Faddsf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Faddsf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SFtype __addsf3(SFtype a, SFtype b)\n+SFtype\n+__addsf3 (SFtype a, SFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A); FP_DECL_S(B); FP_DECL_S(R);\n+  FP_DECL_S (A);\n+  FP_DECL_S (B);\n+  FP_DECL_S (R);\n   SFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_SEMIRAW_S(A, a);\n-  FP_UNPACK_SEMIRAW_S(B, b);\n-  FP_ADD_S(R, A, B);\n-  FP_PACK_SEMIRAW_S(r, R);\n+  FP_UNPACK_SEMIRAW_S (A, a);\n+  FP_UNPACK_SEMIRAW_S (B, b);\n+  FP_ADD_S (R, A, B);\n+  FP_PACK_SEMIRAW_S (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "1c0d266c66c9d9278841728f73cb23200a0e78c8", "filename": "libgcc/soft-fp/addtf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Faddtf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Faddtf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Faddtf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-TFtype __addtf3(TFtype a, TFtype b)\n+TFtype\n+__addtf3 (TFtype a, TFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(R);\n+  FP_DECL_Q (A);\n+  FP_DECL_Q (B);\n+  FP_DECL_Q (R);\n   TFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_SEMIRAW_Q(A, a);\n-  FP_UNPACK_SEMIRAW_Q(B, b);\n-  FP_ADD_Q(R, A, B);\n-  FP_PACK_SEMIRAW_Q(r, R);\n+  FP_UNPACK_SEMIRAW_Q (A, a);\n+  FP_UNPACK_SEMIRAW_Q (B, b);\n+  FP_ADD_Q (R, A, B);\n+  FP_PACK_SEMIRAW_Q (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "d357bf0222c87ce1224babda92e8386ce403fbb1", "filename": "libgcc/soft-fp/divdf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fdivdf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fdivdf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fdivdf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DFtype __divdf3(DFtype a, DFtype b)\n+DFtype\n+__divdf3 (DFtype a, DFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A); FP_DECL_D(B); FP_DECL_D(R);\n+  FP_DECL_D (A);\n+  FP_DECL_D (B);\n+  FP_DECL_D (R);\n   DFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_D(A, a);\n-  FP_UNPACK_D(B, b);\n-  FP_DIV_D(R, A, B);\n-  FP_PACK_D(r, R);\n+  FP_UNPACK_D (A, a);\n+  FP_UNPACK_D (B, b);\n+  FP_DIV_D (R, A, B);\n+  FP_PACK_D (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "b53b4031d7a6c113ff07323d0712c294431cdb35", "filename": "libgcc/soft-fp/divsf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fdivsf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fdivsf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fdivsf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SFtype __divsf3(SFtype a, SFtype b)\n+SFtype\n+__divsf3 (SFtype a, SFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A); FP_DECL_S(B); FP_DECL_S(R);\n+  FP_DECL_S (A);\n+  FP_DECL_S (B);\n+  FP_DECL_S (R);\n   SFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_S(A, a);\n-  FP_UNPACK_S(B, b);\n-  FP_DIV_S(R, A, B);\n-  FP_PACK_S(r, R);\n+  FP_UNPACK_S (A, a);\n+  FP_UNPACK_S (B, b);\n+  FP_DIV_S (R, A, B);\n+  FP_PACK_S (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "5b7175da54c36fec0fce8869e17056927b5c390f", "filename": "libgcc/soft-fp/divtf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fdivtf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fdivtf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fdivtf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-TFtype __divtf3(TFtype a, TFtype b)\n+TFtype\n+__divtf3 (TFtype a, TFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(R);\n+  FP_DECL_Q (A);\n+  FP_DECL_Q (B);\n+  FP_DECL_Q (R);\n   TFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_Q(A, a);\n-  FP_UNPACK_Q(B, b);\n-  FP_DIV_Q(R, A, B);\n-  FP_PACK_Q(r, R);\n+  FP_UNPACK_Q (A, a);\n+  FP_UNPACK_Q (B, b);\n+  FP_DIV_Q (R, A, B);\n+  FP_PACK_Q (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "ef4576707a777e6e79d246c1e8e30c856a834285", "filename": "libgcc/soft-fp/double.h", "status": "modified", "additions": 223, "deletions": 172, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fdouble.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fdouble.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fdouble.h?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,13 +31,15 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #if _FP_W_TYPE_SIZE < 32\n-#error \"Here's a nickel kid.  Go buy yourself a real computer.\"\n+# error \"Here's a nickel kid.  Go buy yourself a real computer.\"\n #endif\n \n #if _FP_W_TYPE_SIZE < 64\n-#define _FP_FRACTBITS_D\t\t(2 * _FP_W_TYPE_SIZE)\n+# define _FP_FRACTBITS_D\t(2 * _FP_W_TYPE_SIZE)\n+# define _FP_FRACTBITS_DW_D\t(4 * _FP_W_TYPE_SIZE)\n #else\n-#define _FP_FRACTBITS_D\t\t_FP_W_TYPE_SIZE\n+# define _FP_FRACTBITS_D\t_FP_W_TYPE_SIZE\n+# define _FP_FRACTBITS_DW_D\t(2 * _FP_W_TYPE_SIZE)\n #endif\n \n #define _FP_FRACBITS_D\t\t53\n@@ -49,215 +51,264 @@\n #define _FP_EXPMAX_D\t\t2047\n \n #define _FP_QNANBIT_D\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_D-2) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_D-2) % _FP_W_TYPE_SIZE)\n #define _FP_QNANBIT_SH_D\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_D-2+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_D-2+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n #define _FP_IMPLBIT_D\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_D-1) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_D-1) % _FP_W_TYPE_SIZE)\n #define _FP_IMPLBIT_SH_D\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_D-1+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_D-1+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n #define _FP_OVERFLOW_D\t\t\\\n-\t((_FP_W_TYPE)1 << _FP_WFRACBITS_D % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << _FP_WFRACBITS_D % _FP_W_TYPE_SIZE)\n \n-typedef float DFtype __attribute__((mode(DF)));\n+#define _FP_WFRACBITS_DW_D\t(2 * _FP_WFRACBITS_D)\n+#define _FP_WFRACXBITS_DW_D\t(_FP_FRACTBITS_DW_D - _FP_WFRACBITS_DW_D)\n+#define _FP_HIGHBIT_DW_D\t\\\n+  ((_FP_W_TYPE) 1 << (_FP_WFRACBITS_DW_D - 1) % _FP_W_TYPE_SIZE)\n+\n+typedef float DFtype __attribute__ ((mode (DF)));\n \n #if _FP_W_TYPE_SIZE < 64\n \n union _FP_UNION_D\n {\n   DFtype flt;\n-  struct _FP_STRUCT_LAYOUT {\n-#if __BYTE_ORDER == __BIG_ENDIAN\n+  struct _FP_STRUCT_LAYOUT\n+  {\n+# if __BYTE_ORDER == __BIG_ENDIAN\n     unsigned sign  : 1;\n     unsigned exp   : _FP_EXPBITS_D;\n     unsigned frac1 : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0) - _FP_W_TYPE_SIZE;\n     unsigned frac0 : _FP_W_TYPE_SIZE;\n-#else\n+# else\n     unsigned frac0 : _FP_W_TYPE_SIZE;\n     unsigned frac1 : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0) - _FP_W_TYPE_SIZE;\n     unsigned exp   : _FP_EXPBITS_D;\n     unsigned sign  : 1;\n-#endif\n-  } bits __attribute__((packed));\n+# endif\n+  } bits __attribute__ ((packed));\n };\n \n-#define FP_DECL_D(X)\t\t_FP_DECL(2,X)\n-#define FP_UNPACK_RAW_D(X,val)\t_FP_UNPACK_RAW_2(D,X,val)\n-#define FP_UNPACK_RAW_DP(X,val)\t_FP_UNPACK_RAW_2_P(D,X,val)\n-#define FP_PACK_RAW_D(val,X)\t_FP_PACK_RAW_2(D,val,X)\n-#define FP_PACK_RAW_DP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_2_P(D,val,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_D(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_2(D,X,val);\t\t\\\n-    _FP_UNPACK_CANONICAL(D,2,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_DP(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_2_P(D,X,val);\t\\\n-    _FP_UNPACK_CANONICAL(D,2,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_D(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_2(D,X,val);\t\t\\\n-    _FP_UNPACK_SEMIRAW(D,2,X);\t\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_DP(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_2_P(D,X,val);\t\\\n-    _FP_UNPACK_SEMIRAW(D,2,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_D(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(D,2,X);\t\t\\\n-    _FP_PACK_RAW_2(D,val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_DP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(D,2,X);\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_2_P(D,val,X);\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_D(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(D,2,X);\t\t\\\n-    _FP_PACK_RAW_2(D,val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_DP(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(D,2,X);\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_2_P(D,val,X);\t\\\n-  } while (0)\n-\n-#define FP_ISSIGNAN_D(X)\t\t_FP_ISSIGNAN(D,2,X)\n-#define FP_NEG_D(R,X)\t\t\t_FP_NEG(D,2,R,X)\n-#define FP_ADD_D(R,X,Y)\t\t\t_FP_ADD(D,2,R,X,Y)\n-#define FP_SUB_D(R,X,Y)\t\t\t_FP_SUB(D,2,R,X,Y)\n-#define FP_MUL_D(R,X,Y)\t\t\t_FP_MUL(D,2,R,X,Y)\n-#define FP_DIV_D(R,X,Y)\t\t\t_FP_DIV(D,2,R,X,Y)\n-#define FP_SQRT_D(R,X)\t\t\t_FP_SQRT(D,2,R,X)\n-#define _FP_SQRT_MEAT_D(R,S,T,X,Q)\t_FP_SQRT_MEAT_2(R,S,T,X,Q)\n-\n-#define FP_CMP_D(r,X,Y,un)\t_FP_CMP(D,2,r,X,Y,un)\n-#define FP_CMP_EQ_D(r,X,Y)\t_FP_CMP_EQ(D,2,r,X,Y)\n-#define FP_CMP_UNORD_D(r,X,Y)\t_FP_CMP_UNORD(D,2,r,X,Y)\n-\n-#define FP_TO_INT_D(r,X,rsz,rsg)\t_FP_TO_INT(D,2,r,X,rsz,rsg)\n-#define FP_FROM_INT_D(X,r,rs,rt)\t_FP_FROM_INT(D,2,X,r,rs,rt)\n-\n-#define _FP_FRAC_HIGH_D(X)\t_FP_FRAC_HIGH_2(X)\n-#define _FP_FRAC_HIGH_RAW_D(X)\t_FP_FRAC_HIGH_2(X)\n+# define FP_DECL_D(X)\t\t_FP_DECL (2, X)\n+# define FP_UNPACK_RAW_D(X, val)\t_FP_UNPACK_RAW_2 (D, X, val)\n+# define FP_UNPACK_RAW_DP(X, val)\t_FP_UNPACK_RAW_2_P (D, X, val)\n+# define FP_PACK_RAW_D(val, X)\t_FP_PACK_RAW_2 (D, val, X)\n+# define FP_PACK_RAW_DP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_2_P (D, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_D(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_2 (D, X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (D, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_DP(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_2_P (D, X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (D, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_D(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_2 (D, X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (D, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_DP(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_2_P (D, X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (D, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_D(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (D, 2, X);\t\t\\\n+      _FP_PACK_RAW_2 (D, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_DP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (D, 2, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_2_P (D, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_D(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (D, 2, X);\t\t\\\n+      _FP_PACK_RAW_2 (D, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_DP(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (D, 2, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_2_P (D, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_ISSIGNAN_D(X)\t\t_FP_ISSIGNAN (D, 2, X)\n+# define FP_NEG_D(R, X)\t\t\t_FP_NEG (D, 2, R, X)\n+# define FP_ADD_D(R, X, Y)\t\t_FP_ADD (D, 2, R, X, Y)\n+# define FP_SUB_D(R, X, Y)\t\t_FP_SUB (D, 2, R, X, Y)\n+# define FP_MUL_D(R, X, Y)\t\t_FP_MUL (D, 2, R, X, Y)\n+# define FP_DIV_D(R, X, Y)\t\t_FP_DIV (D, 2, R, X, Y)\n+# define FP_SQRT_D(R, X)\t\t_FP_SQRT (D, 2, R, X)\n+# define _FP_SQRT_MEAT_D(R, S, T, X, Q)\t_FP_SQRT_MEAT_2 (R, S, T, X, Q)\n+# define FP_FMA_D(R, X, Y, Z)\t\t_FP_FMA (D, 2, 4, R, X, Y, Z)\n+\n+# define FP_CMP_D(r, X, Y, un)\t\t_FP_CMP (D, 2, r, X, Y, un)\n+# define FP_CMP_EQ_D(r, X, Y)\t\t_FP_CMP_EQ (D, 2, r, X, Y)\n+# define FP_CMP_UNORD_D(r, X, Y)\t_FP_CMP_UNORD (D, 2, r, X, Y)\n+\n+# define FP_TO_INT_D(r, X, rsz, rsg)\t_FP_TO_INT (D, 2, r, X, rsz, rsg)\n+# define FP_FROM_INT_D(X, r, rs, rt)\t_FP_FROM_INT (D, 2, X, r, rs, rt)\n+\n+# define _FP_FRAC_HIGH_D(X)\t_FP_FRAC_HIGH_2 (X)\n+# define _FP_FRAC_HIGH_RAW_D(X)\t_FP_FRAC_HIGH_2 (X)\n+\n+# define _FP_FRAC_HIGH_DW_D(X)\t_FP_FRAC_HIGH_4 (X)\n \n #else\n \n union _FP_UNION_D\n {\n   DFtype flt;\n-  struct _FP_STRUCT_LAYOUT {\n-#if __BYTE_ORDER == __BIG_ENDIAN\n+  struct _FP_STRUCT_LAYOUT\n+  {\n+# if __BYTE_ORDER == __BIG_ENDIAN\n     unsigned sign   : 1;\n     unsigned exp    : _FP_EXPBITS_D;\n     _FP_W_TYPE frac : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0);\n-#else\n+# else\n     _FP_W_TYPE frac : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0);\n     unsigned exp    : _FP_EXPBITS_D;\n     unsigned sign   : 1;\n-#endif\n-  } bits __attribute__((packed));\n+# endif\n+  } bits __attribute__ ((packed));\n };\n \n-#define FP_DECL_D(X)\t\t_FP_DECL(1,X)\n-#define FP_UNPACK_RAW_D(X,val)\t_FP_UNPACK_RAW_1(D,X,val)\n-#define FP_UNPACK_RAW_DP(X,val)\t_FP_UNPACK_RAW_1_P(D,X,val)\n-#define FP_PACK_RAW_D(val,X)\t_FP_PACK_RAW_1(D,val,X)\n-#define FP_PACK_RAW_DP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_1_P(D,val,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_D(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_1(D,X,val);\t\t\\\n-    _FP_UNPACK_CANONICAL(D,1,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_DP(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_1_P(D,X,val);\t\\\n-    _FP_UNPACK_CANONICAL(D,1,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_D(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_1(D,X,val);\t\t\\\n-    _FP_UNPACK_SEMIRAW(D,1,X);\t\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_DP(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_1_P(D,X,val);\t\\\n-    _FP_UNPACK_SEMIRAW(D,1,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_D(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(D,1,X);\t\t\\\n-    _FP_PACK_RAW_1(D,val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_DP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(D,1,X);\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_1_P(D,val,X);\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_D(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(D,1,X);\t\t\\\n-    _FP_PACK_RAW_1(D,val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_DP(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(D,1,X);\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_1_P(D,val,X);\t\\\n-  } while (0)\n-\n-#define FP_ISSIGNAN_D(X)\t\t_FP_ISSIGNAN(D,1,X)\n-#define FP_NEG_D(R,X)\t\t\t_FP_NEG(D,1,R,X)\n-#define FP_ADD_D(R,X,Y)\t\t\t_FP_ADD(D,1,R,X,Y)\n-#define FP_SUB_D(R,X,Y)\t\t\t_FP_SUB(D,1,R,X,Y)\n-#define FP_MUL_D(R,X,Y)\t\t\t_FP_MUL(D,1,R,X,Y)\n-#define FP_DIV_D(R,X,Y)\t\t\t_FP_DIV(D,1,R,X,Y)\n-#define FP_SQRT_D(R,X)\t\t\t_FP_SQRT(D,1,R,X)\n-#define _FP_SQRT_MEAT_D(R,S,T,X,Q)\t_FP_SQRT_MEAT_1(R,S,T,X,Q)\n+# define FP_DECL_D(X)\t\t_FP_DECL (1, X)\n+# define FP_UNPACK_RAW_D(X, val)\t_FP_UNPACK_RAW_1 (D, X, val)\n+# define FP_UNPACK_RAW_DP(X, val)\t_FP_UNPACK_RAW_1_P (D, X, val)\n+# define FP_PACK_RAW_D(val, X)\t_FP_PACK_RAW_1 (D, val, X)\n+# define FP_PACK_RAW_DP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_1_P (D, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_D(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1 (D, X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (D, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_DP(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1_P (D, X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (D, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_D(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1 (D, X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (D, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_DP(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1_P (D, X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (D, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_D(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (D, 1, X);\t\t\\\n+      _FP_PACK_RAW_1 (D, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_DP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (D, 1, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_1_P (D, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_D(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (D, 1, X);\t\t\\\n+      _FP_PACK_RAW_1 (D, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_DP(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (D, 1, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_1_P (D, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_ISSIGNAN_D(X)\t\t_FP_ISSIGNAN (D, 1, X)\n+# define FP_NEG_D(R, X)\t\t\t_FP_NEG (D, 1, R, X)\n+# define FP_ADD_D(R, X, Y)\t\t_FP_ADD (D, 1, R, X, Y)\n+# define FP_SUB_D(R, X, Y)\t\t_FP_SUB (D, 1, R, X, Y)\n+# define FP_MUL_D(R, X, Y)\t\t_FP_MUL (D, 1, R, X, Y)\n+# define FP_DIV_D(R, X, Y)\t\t_FP_DIV (D, 1, R, X, Y)\n+# define FP_SQRT_D(R, X)\t\t_FP_SQRT (D, 1, R, X)\n+# define _FP_SQRT_MEAT_D(R, S, T, X, Q)\t_FP_SQRT_MEAT_1 (R, S, T, X, Q)\n+# define FP_FMA_D(R, X, Y, Z)\t\t_FP_FMA (D, 1, 2, R, X, Y, Z)\n \n /* The implementation of _FP_MUL_D and _FP_DIV_D should be chosen by\n    the target machine.  */\n \n-#define FP_CMP_D(r,X,Y,un)\t_FP_CMP(D,1,r,X,Y,un)\n-#define FP_CMP_EQ_D(r,X,Y)\t_FP_CMP_EQ(D,1,r,X,Y)\n-#define FP_CMP_UNORD_D(r,X,Y)\t_FP_CMP_UNORD(D,1,r,X,Y)\n+# define FP_CMP_D(r, X, Y, un)\t\t_FP_CMP (D, 1, r, X, Y, un)\n+# define FP_CMP_EQ_D(r, X, Y)\t\t_FP_CMP_EQ (D, 1, r, X, Y)\n+# define FP_CMP_UNORD_D(r, X, Y)\t_FP_CMP_UNORD (D, 1, r, X, Y)\n+\n+# define FP_TO_INT_D(r, X, rsz, rsg)\t_FP_TO_INT (D, 1, r, X, rsz, rsg)\n+# define FP_FROM_INT_D(X, r, rs, rt)\t_FP_FROM_INT (D, 1, X, r, rs, rt)\n \n-#define FP_TO_INT_D(r,X,rsz,rsg)\t_FP_TO_INT(D,1,r,X,rsz,rsg)\n-#define FP_FROM_INT_D(X,r,rs,rt)\t_FP_FROM_INT(D,1,X,r,rs,rt)\n+# define _FP_FRAC_HIGH_D(X)\t_FP_FRAC_HIGH_1 (X)\n+# define _FP_FRAC_HIGH_RAW_D(X)\t_FP_FRAC_HIGH_1 (X)\n \n-#define _FP_FRAC_HIGH_D(X)\t_FP_FRAC_HIGH_1(X)\n-#define _FP_FRAC_HIGH_RAW_D(X)\t_FP_FRAC_HIGH_1(X)\n+# define _FP_FRAC_HIGH_DW_D(X)\t_FP_FRAC_HIGH_2 (X)\n \n #endif /* W_TYPE_SIZE < 64 */"}, {"sha": "e8cfd7666a9a73f3063506eff736b211ad3fafd6", "filename": "libgcc/soft-fp/eqdf2.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Feqdf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Feqdf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Feqdf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,20 +31,23 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-CMPtype __eqdf2(DFtype a, DFtype b)\n+CMPtype\n+__eqdf2 (DFtype a, DFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A); FP_DECL_D(B);\n+  FP_DECL_D (A);\n+  FP_DECL_D (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_D(A, a);\n-  FP_UNPACK_RAW_D(B, b);\n-  FP_CMP_EQ_D(r, A, B);\n-  if (r && (FP_ISSIGNAN_D(A) || FP_ISSIGNAN_D(B)))\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n+  FP_UNPACK_RAW_D (B, b);\n+  FP_CMP_EQ_D (r, A, B);\n+  if (r && (FP_ISSIGNAN_D (A) || FP_ISSIGNAN_D (B)))\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }\n \n-strong_alias(__eqdf2, __nedf2);\n+strong_alias (__eqdf2, __nedf2);"}, {"sha": "0bdb7fb22372a8c38a91a977524fd5f5ba91c767", "filename": "libgcc/soft-fp/eqsf2.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Feqsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Feqsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Feqsf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,20 +31,23 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-CMPtype __eqsf2(SFtype a, SFtype b)\n+CMPtype\n+__eqsf2 (SFtype a, SFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A); FP_DECL_S(B);\n+  FP_DECL_S (A);\n+  FP_DECL_S (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_S(A, a);\n-  FP_UNPACK_RAW_S(B, b);\n-  FP_CMP_EQ_S(r, A, B);\n-  if (r && (FP_ISSIGNAN_S(A) || FP_ISSIGNAN_S(B)))\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n+  FP_UNPACK_RAW_S (B, b);\n+  FP_CMP_EQ_S (r, A, B);\n+  if (r && (FP_ISSIGNAN_S (A) || FP_ISSIGNAN_S (B)))\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }\n \n-strong_alias(__eqsf2, __nesf2);\n+strong_alias (__eqsf2, __nesf2);"}, {"sha": "edbc6f6832f95ba7e3c402d9ac7dbba5defa9d28", "filename": "libgcc/soft-fp/eqtf2.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Feqtf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Feqtf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Feqtf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,20 +31,23 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-CMPtype __eqtf2(TFtype a, TFtype b)\n+CMPtype\n+__eqtf2 (TFtype a, TFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A); FP_DECL_Q(B);\n+  FP_DECL_Q (A);\n+  FP_DECL_Q (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_Q(A, a);\n-  FP_UNPACK_RAW_Q(B, b);\n-  FP_CMP_EQ_Q(r, A, B);\n-  if (r && (FP_ISSIGNAN_Q(A) || FP_ISSIGNAN_Q(B)))\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_UNPACK_RAW_Q (B, b);\n+  FP_CMP_EQ_Q (r, A, B);\n+  if (r && (FP_ISSIGNAN_Q (A) || FP_ISSIGNAN_Q (B)))\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }\n \n-strong_alias(__eqtf2, __netf2);\n+strong_alias (__eqtf2, __netf2);"}, {"sha": "2471fda954635a452cb9c3cec31c6842110e6bb2", "filename": "libgcc/soft-fp/extenddftf2.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fextenddftf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fextenddftf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fextenddftf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -32,21 +32,22 @@\n #include \"double.h\"\n #include \"quad.h\"\n \n-TFtype __extenddftf2(DFtype a)\n+TFtype\n+__extenddftf2 (DFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n-  FP_DECL_Q(R);\n+  FP_DECL_D (A);\n+  FP_DECL_Q (R);\n   TFtype r;\n \n-  FP_INIT_ROUNDMODE;\n-  FP_UNPACK_RAW_D(A, a);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n #if (2 * _FP_W_TYPE_SIZE) < _FP_FRACBITS_Q\n-  FP_EXTEND(Q,D,4,2,R,A);\n+  FP_EXTEND (Q, D, 4, 2, R, A);\n #else\n-  FP_EXTEND(Q,D,2,1,R,A);\n+  FP_EXTEND (Q, D, 2, 1, R, A);\n #endif\n-  FP_PACK_RAW_Q(r, R);\n+  FP_PACK_RAW_Q (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "1189f7c7d2d64a7506b980ac5f47f6d7b8c7f3fc", "filename": "libgcc/soft-fp/extended.h", "status": "modified", "additions": 407, "deletions": 333, "changes": 740, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fextended.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fextended.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fextended.h?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -28,13 +28,15 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #if _FP_W_TYPE_SIZE < 32\n-#error \"Here's a nickel, kid. Go buy yourself a real computer.\"\n+# error \"Here's a nickel, kid. Go buy yourself a real computer.\"\n #endif\n \n #if _FP_W_TYPE_SIZE < 64\n-#define _FP_FRACTBITS_E         (4*_FP_W_TYPE_SIZE)\n+# define _FP_FRACTBITS_E\t(4*_FP_W_TYPE_SIZE)\n+# define _FP_FRACTBITS_DW_E\t(8*_FP_W_TYPE_SIZE)\n #else\n-#define _FP_FRACTBITS_E\t\t(2*_FP_W_TYPE_SIZE)\n+# define _FP_FRACTBITS_E\t(2*_FP_W_TYPE_SIZE)\n+# define _FP_FRACTBITS_DW_E\t(4*_FP_W_TYPE_SIZE)\n #endif\n \n #define _FP_FRACBITS_E\t\t64\n@@ -46,152 +48,187 @@\n #define _FP_EXPMAX_E\t\t32767\n \n #define _FP_QNANBIT_E\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_E-2) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_E-2) % _FP_W_TYPE_SIZE)\n #define _FP_QNANBIT_SH_E\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_E-2+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_E-2+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n #define _FP_IMPLBIT_E\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_E-1) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_E-1) % _FP_W_TYPE_SIZE)\n #define _FP_IMPLBIT_SH_E\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_E-1+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_E-1+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n #define _FP_OVERFLOW_E\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_WFRACBITS_E % _FP_W_TYPE_SIZE))\n+\t((_FP_W_TYPE) 1 << (_FP_WFRACBITS_E % _FP_W_TYPE_SIZE))\n \n-typedef float XFtype __attribute__((mode(XF)));\n+#define _FP_WFRACBITS_DW_E\t(2 * _FP_WFRACBITS_E)\n+#define _FP_WFRACXBITS_DW_E\t(_FP_FRACTBITS_DW_E - _FP_WFRACBITS_DW_E)\n+#define _FP_HIGHBIT_DW_E\t\\\n+  ((_FP_W_TYPE) 1 << (_FP_WFRACBITS_DW_E - 1) % _FP_W_TYPE_SIZE)\n+\n+typedef float XFtype __attribute__ ((mode (XF)));\n \n #if _FP_W_TYPE_SIZE < 64\n \n union _FP_UNION_E\n {\n-   XFtype flt;\n-   struct _FP_STRUCT_LAYOUT\n-   {\n-#if __BYTE_ORDER == __BIG_ENDIAN\n-      unsigned long pad1 : _FP_W_TYPE_SIZE;\n-      unsigned long pad2 : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);\n-      unsigned long sign : 1;\n-      unsigned long exp : _FP_EXPBITS_E;\n-      unsigned long frac1 : _FP_W_TYPE_SIZE;\n-      unsigned long frac0 : _FP_W_TYPE_SIZE;\n-#else\n-      unsigned long frac0 : _FP_W_TYPE_SIZE;\n-      unsigned long frac1 : _FP_W_TYPE_SIZE;\n-      unsigned exp : _FP_EXPBITS_E;\n-      unsigned sign : 1;\n-#endif /* not bigendian */\n-   } bits __attribute__((packed));\n+  XFtype flt;\n+  struct _FP_STRUCT_LAYOUT\n+  {\n+# if __BYTE_ORDER == __BIG_ENDIAN\n+    unsigned long pad1 : _FP_W_TYPE_SIZE;\n+    unsigned long pad2 : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);\n+    unsigned long sign : 1;\n+    unsigned long exp : _FP_EXPBITS_E;\n+    unsigned long frac1 : _FP_W_TYPE_SIZE;\n+    unsigned long frac0 : _FP_W_TYPE_SIZE;\n+# else\n+    unsigned long frac0 : _FP_W_TYPE_SIZE;\n+    unsigned long frac1 : _FP_W_TYPE_SIZE;\n+    unsigned exp : _FP_EXPBITS_E;\n+    unsigned sign : 1;\n+# endif /* not bigendian */\n+  } bits __attribute__ ((packed));\n };\n \n \n-#define FP_DECL_E(X)\t\t_FP_DECL(4,X)\n-\n-#define FP_UNPACK_RAW_E(X, val)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    union _FP_UNION_E _flo; _flo.flt = (val);\t\t\\\n-\t\t\t\t\t\t\t\\\n-    X##_f[2] = 0; X##_f[3] = 0;\t\t\t\t\\\n-    X##_f[0] = _flo.bits.frac0;\t\t\t\t\\\n-    X##_f[1] = _flo.bits.frac1;\t\t\t\t\\\n-    X##_e  = _flo.bits.exp;\t\t\t\t\\\n-    X##_s  = _flo.bits.sign;\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_RAW_EP(X, val)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    union _FP_UNION_E *_flo =\t\t\t\t\\\n-    (union _FP_UNION_E *)(val);\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-    X##_f[2] = 0; X##_f[3] = 0;\t\t\t\t\\\n-    X##_f[0] = _flo->bits.frac0;\t\t\t\\\n-    X##_f[1] = _flo->bits.frac1;\t\t\t\\\n-    X##_e  = _flo->bits.exp;\t\t\t\t\\\n-    X##_s  = _flo->bits.sign;\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_RAW_E(val, X)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    union _FP_UNION_E _flo;\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-    if (X##_e) X##_f[1] |= _FP_IMPLBIT_E;\t\t\\\n-    else X##_f[1] &= ~(_FP_IMPLBIT_E);\t\t\t\\\n-    _flo.bits.frac0 = X##_f[0];\t\t\t\t\\\n-    _flo.bits.frac1 = X##_f[1];\t\t\t\t\\\n-    _flo.bits.exp   = X##_e;\t\t\t\t\\\n-    _flo.bits.sign  = X##_s;\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-    (val) = _flo.flt;\t\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_RAW_EP(val, X)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tunion _FP_UNION_E *_flo =\t\t\t\\\n-\t  (union _FP_UNION_E *)(val);\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-\tif (X##_e) X##_f[1] |= _FP_IMPLBIT_E;\t\t\\\n-\telse X##_f[1] &= ~(_FP_IMPLBIT_E);\t\t\\\n-\t_flo->bits.frac0 = X##_f[0];\t\t\t\\\n-\t_flo->bits.frac1 = X##_f[1];\t\t\t\\\n-\t_flo->bits.exp   = X##_e;\t\t\t\\\n-\t_flo->bits.sign  = X##_s;\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_E(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    FP_UNPACK_RAW_E(X,val);\t\t\\\n-    _FP_UNPACK_CANONICAL(E,4,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_EP(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    FP_UNPACK_RAW_EP(X,val);\t\t\\\n-    _FP_UNPACK_CANONICAL(E,4,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_E(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    FP_UNPACK_RAW_E(X,val);\t\t\\\n-    _FP_UNPACK_SEMIRAW(E,4,X);\t\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_EP(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    FP_UNPACK_RAW_EP(X,val);\t\t\\\n-    _FP_UNPACK_SEMIRAW(E,4,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_E(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(E,4,X);\t\t\\\n-    FP_PACK_RAW_E(val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_EP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(E,4,X);\t\t\\\n-    FP_PACK_RAW_EP(val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_E(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(E,4,X);\t\t\\\n-    FP_PACK_RAW_E(val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_EP(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(E,4,X);\t\t\\\n-    FP_PACK_RAW_EP(val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_ISSIGNAN_E(X)\t_FP_ISSIGNAN(E,4,X)\n-#define FP_NEG_E(R,X)\t\t_FP_NEG(E,4,R,X)\n-#define FP_ADD_E(R,X,Y)\t\t_FP_ADD(E,4,R,X,Y)\n-#define FP_SUB_E(R,X,Y)\t\t_FP_SUB(E,4,R,X,Y)\n-#define FP_MUL_E(R,X,Y)\t\t_FP_MUL(E,4,R,X,Y)\n-#define FP_DIV_E(R,X,Y)\t\t_FP_DIV(E,4,R,X,Y)\n-#define FP_SQRT_E(R,X)\t\t_FP_SQRT(E,4,R,X)\n+# define FP_DECL_E(X)\t\t_FP_DECL (4, X)\n+\n+# define FP_UNPACK_RAW_E(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      union _FP_UNION_E _flo;\t\t\t\\\n+      _flo.flt = (val);\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+      X##_f[2] = 0;\t\t\t\t\\\n+      X##_f[3] = 0;\t\t\t\t\\\n+      X##_f[0] = _flo.bits.frac0;\t\t\\\n+      X##_f[1] = _flo.bits.frac1;\t\t\\\n+      X##_e  = _flo.bits.exp;\t\t\t\\\n+      X##_s  = _flo.bits.sign;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_RAW_EP(X, val)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      union _FP_UNION_E *_flo = (union _FP_UNION_E *) (val);\t\\\n+\t\t\t\t\t\t\t\t\\\n+      X##_f[2] = 0;\t\t\t\t\t\t\\\n+      X##_f[3] = 0;\t\t\t\t\t\t\\\n+      X##_f[0] = _flo->bits.frac0;\t\t\t\t\\\n+      X##_f[1] = _flo->bits.frac1;\t\t\t\t\\\n+      X##_e  = _flo->bits.exp;\t\t\t\t\t\\\n+      X##_s  = _flo->bits.sign;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_RAW_E(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      union _FP_UNION_E _flo;\t\t\t\\\n+\t\t\t\t\t\t\\\n+      if (X##_e)\t\t\t\t\\\n+\tX##_f[1] |= _FP_IMPLBIT_E;\t\t\\\n+      else\t\t\t\t\t\\\n+\tX##_f[1] &= ~(_FP_IMPLBIT_E);\t\t\\\n+      _flo.bits.frac0 = X##_f[0];\t\t\\\n+      _flo.bits.frac1 = X##_f[1];\t\t\\\n+      _flo.bits.exp   = X##_e;\t\t\t\\\n+      _flo.bits.sign  = X##_s;\t\t\t\\\n+\t\t\t\t\t\t\\\n+      (val) = _flo.flt;\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_RAW_EP(val, X)\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  union _FP_UNION_E *_flo = (union _FP_UNION_E *) (val);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if (X##_e)\t\t\t\t\t\t\t\\\n+\t    X##_f[1] |= _FP_IMPLBIT_E;\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    X##_f[1] &= ~(_FP_IMPLBIT_E);\t\t\t\t\\\n+\t  _flo->bits.frac0 = X##_f[0];\t\t\t\t\t\\\n+\t  _flo->bits.frac1 = X##_f[1];\t\t\t\t\t\\\n+\t  _flo->bits.exp   = X##_e;\t\t\t\t\t\\\n+\t  _flo->bits.sign  = X##_s;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_E(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      FP_UNPACK_RAW_E (X, val);\t\t\t\\\n+      _FP_UNPACK_CANONICAL (E, 4, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_EP(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      FP_UNPACK_RAW_EP (X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (E, 4, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_E(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      FP_UNPACK_RAW_E (X, val);\t\t\t\\\n+      _FP_UNPACK_SEMIRAW (E, 4, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_EP(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      FP_UNPACK_RAW_EP (X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (E, 4, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_E(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (E, 4, X);\t\t\\\n+      FP_PACK_RAW_E (val, X);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_EP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (E, 4, X);\t\t\\\n+      FP_PACK_RAW_EP (val, X);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_E(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (E, 4, X);\t\t\\\n+      FP_PACK_RAW_E (val, X);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_EP(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (E, 4, X);\t\t\\\n+      FP_PACK_RAW_EP (val, X);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_ISSIGNAN_E(X)\t_FP_ISSIGNAN (E, 4, X)\n+# define FP_NEG_E(R, X)\t\t_FP_NEG (E, 4, R, X)\n+# define FP_ADD_E(R, X, Y)\t_FP_ADD (E, 4, R, X, Y)\n+# define FP_SUB_E(R, X, Y)\t_FP_SUB (E, 4, R, X, Y)\n+# define FP_MUL_E(R, X, Y)\t_FP_MUL (E, 4, R, X, Y)\n+# define FP_DIV_E(R, X, Y)\t_FP_DIV (E, 4, R, X, Y)\n+# define FP_SQRT_E(R, X)\t_FP_SQRT (E, 4, R, X)\n+# define FP_FMA_E(R, X, Y, Z)\t_FP_FMA (E, 4, 8, R, X, Y, Z)\n \n /*\n  * Square root algorithms:\n@@ -204,185 +241,218 @@ union _FP_UNION_E\n  * in two UWtype registers instead of four.\n  */\n \n-#define _FP_SQRT_MEAT_E(R, S, T, X, q)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\\\n-    _FP_FRAC_SRL_4(X, (_FP_WORKBITS));\t\t\t\\\n-    while (q)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tT##_f[1] = S##_f[1] + q;\t\t\t\\\n-\tif (T##_f[1] <= X##_f[1])\t\t\t\\\n-\t  {\t\t\t\t\t\t\\\n-\t    S##_f[1] = T##_f[1] + q;\t\t\t\\\n-\t    X##_f[1] -= T##_f[1];\t\t\t\\\n-\t    R##_f[1] += q;\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\\\n-\t_FP_FRAC_SLL_2(X, 1);\t\t\t\t\\\n-\tq >>= 1;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\\\n-    while (q)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tT##_f[0] = S##_f[0] + q;\t\t\t\\\n-\tT##_f[1] = S##_f[1];\t\t\t\t\\\n-\tif (T##_f[1] < X##_f[1] || \t\t\t\\\n-\t    (T##_f[1] == X##_f[1] &&\t\t\t\\\n-\t     T##_f[0] <= X##_f[0]))\t\t\t\\\n-\t  {\t\t\t\t\t\t\\\n-\t    S##_f[0] = T##_f[0] + q;\t\t\t\\\n-\t    S##_f[1] += (T##_f[0] > S##_f[0]);\t\t\\\n-\t    _FP_FRAC_DEC_2(X, T);\t\t\t\\\n-\t    R##_f[0] += q;\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\\\n-\t_FP_FRAC_SLL_2(X, 1);\t\t\t\t\\\n-\tq >>= 1;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    _FP_FRAC_SLL_4(R, (_FP_WORKBITS));\t\t\t\\\n-    if (X##_f[0] | X##_f[1])\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tif (S##_f[1] < X##_f[1] || \t\t\t\\\n-\t    (S##_f[1] == X##_f[1] &&\t\t\t\\\n-\t     S##_f[0] < X##_f[0]))\t\t\t\\\n-\t  R##_f[0] |= _FP_WORK_ROUND;\t\t\t\\\n-\tR##_f[0] |= _FP_WORK_STICKY;\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_CMP_E(r,X,Y,un)\t_FP_CMP(E,4,r,X,Y,un)\n-#define FP_CMP_EQ_E(r,X,Y)\t_FP_CMP_EQ(E,4,r,X,Y)\n-#define FP_CMP_UNORD_E(r,X,Y)\t_FP_CMP_UNORD(E,4,r,X,Y)\n-\n-#define FP_TO_INT_E(r,X,rsz,rsg)\t_FP_TO_INT(E,4,r,X,rsz,rsg)\n-#define FP_FROM_INT_E(X,r,rs,rt)\t_FP_FROM_INT(E,4,X,r,rs,rt)\n-\n-#define _FP_FRAC_HIGH_E(X)\t(X##_f[2])\n-#define _FP_FRAC_HIGH_RAW_E(X)\t(X##_f[1])\n+# define _FP_SQRT_MEAT_E(R, S, T, X, q)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      q = (_FP_W_TYPE) 1 << (_FP_W_TYPE_SIZE - 1);\t\\\n+      _FP_FRAC_SRL_4 (X, (_FP_WORKBITS));\t\t\\\n+      while (q)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  T##_f[1] = S##_f[1] + q;\t\t\t\\\n+\t  if (T##_f[1] <= X##_f[1])\t\t\t\\\n+\t    {\t\t\t\t\t\t\\\n+\t      S##_f[1] = T##_f[1] + q;\t\t\t\\\n+\t      X##_f[1] -= T##_f[1];\t\t\t\\\n+\t      R##_f[1] += q;\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SLL_2 (X, 1);\t\t\t\\\n+\t  q >>= 1;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      q = (_FP_W_TYPE) 1 << (_FP_W_TYPE_SIZE - 1);\t\\\n+      while (q)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  T##_f[0] = S##_f[0] + q;\t\t\t\\\n+\t  T##_f[1] = S##_f[1];\t\t\t\t\\\n+\t  if (T##_f[1] < X##_f[1]\t\t\t\\\n+\t      || (T##_f[1] == X##_f[1]\t\t\t\\\n+\t\t  && T##_f[0] <= X##_f[0]))\t\t\\\n+\t    {\t\t\t\t\t\t\\\n+\t      S##_f[0] = T##_f[0] + q;\t\t\t\\\n+\t      S##_f[1] += (T##_f[0] > S##_f[0]);\t\\\n+\t      _FP_FRAC_DEC_2 (X, T);\t\t\t\\\n+\t      R##_f[0] += q;\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SLL_2 (X, 1);\t\t\t\\\n+\t  q >>= 1;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      _FP_FRAC_SLL_4 (R, (_FP_WORKBITS));\t\t\\\n+      if (X##_f[0] | X##_f[1])\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (S##_f[1] < X##_f[1]\t\t\t\\\n+\t      || (S##_f[1] == X##_f[1]\t\t\t\\\n+\t\t  && S##_f[0] < X##_f[0]))\t\t\\\n+\t    R##_f[0] |= _FP_WORK_ROUND;\t\t\t\\\n+\t  R##_f[0] |= _FP_WORK_STICKY;\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_CMP_E(r, X, Y, un)\t\t_FP_CMP (E, 4, r, X, Y, un)\n+# define FP_CMP_EQ_E(r, X, Y)\t\t_FP_CMP_EQ (E, 4, r, X, Y)\n+# define FP_CMP_UNORD_E(r, X, Y)\t_FP_CMP_UNORD (E, 4, r, X, Y)\n+\n+# define FP_TO_INT_E(r, X, rsz, rsg)\t_FP_TO_INT (E, 4, r, X, rsz, rsg)\n+# define FP_FROM_INT_E(X, r, rs, rt)\t_FP_FROM_INT (E, 4, X, r, rs, rt)\n+\n+# define _FP_FRAC_HIGH_E(X)\t(X##_f[2])\n+# define _FP_FRAC_HIGH_RAW_E(X)\t(X##_f[1])\n+\n+# define _FP_FRAC_HIGH_DW_E(X)\t(X##_f[4])\n \n #else   /* not _FP_W_TYPE_SIZE < 64 */\n union _FP_UNION_E\n {\n   XFtype flt;\n-  struct _FP_STRUCT_LAYOUT {\n-#if __BYTE_ORDER == __BIG_ENDIAN\n+  struct _FP_STRUCT_LAYOUT\n+  {\n+# if __BYTE_ORDER == __BIG_ENDIAN\n     _FP_W_TYPE pad  : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);\n     unsigned sign   : 1;\n     unsigned exp    : _FP_EXPBITS_E;\n     _FP_W_TYPE frac : _FP_W_TYPE_SIZE;\n-#else\n+# else\n     _FP_W_TYPE frac : _FP_W_TYPE_SIZE;\n     unsigned exp    : _FP_EXPBITS_E;\n     unsigned sign   : 1;\n-#endif\n+# endif\n   } bits;\n };\n \n-#define FP_DECL_E(X)\t\t_FP_DECL(2,X)\n-\n-#define FP_UNPACK_RAW_E(X, val)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    union _FP_UNION_E _flo; _flo.flt = (val);\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    X##_f0 = _flo.bits.frac;\t\t\t\t\t\\\n-    X##_f1 = 0;\t\t\t\t\t\t\t\\\n-    X##_e = _flo.bits.exp;\t\t\t\t\t\\\n-    X##_s = _flo.bits.sign;\t\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_RAW_EP(X, val)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    union _FP_UNION_E *_flo =\t\t\t\t\t\\\n-      (union _FP_UNION_E *)(val);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    X##_f0 = _flo->bits.frac;\t\t\t\t\t\\\n-    X##_f1 = 0;\t\t\t\t\t\t\t\\\n-    X##_e = _flo->bits.exp;\t\t\t\t\t\\\n-    X##_s = _flo->bits.sign;\t\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_RAW_E(val, X)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    union _FP_UNION_E _flo;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    if (X##_e) X##_f0 |= _FP_IMPLBIT_E;\t\t\t\t\\\n-    else X##_f0 &= ~(_FP_IMPLBIT_E);\t\t\t\t\\\n-    _flo.bits.frac = X##_f0;\t\t\t\t\t\\\n-    _flo.bits.exp  = X##_e;\t\t\t\t\t\\\n-    _flo.bits.sign = X##_s;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    (val) = _flo.flt;\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_RAW_EP(fs, val, X)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tunion _FP_UNION_E *_flo =\t\t\t\t\\\n-\t  (union _FP_UNION_E *)(val);\t\t\t\t\\\n+# define FP_DECL_E(X)\t\t_FP_DECL (2, X)\n+\n+# define FP_UNPACK_RAW_E(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      union _FP_UNION_E _flo;\t\t\t\\\n+      _flo.flt = (val);\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+      X##_f0 = _flo.bits.frac;\t\t\t\\\n+      X##_f1 = 0;\t\t\t\t\\\n+      X##_e = _flo.bits.exp;\t\t\t\\\n+      X##_s = _flo.bits.sign;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_RAW_EP(X, val)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      union _FP_UNION_E *_flo = (union _FP_UNION_E *) (val);\t\\\n \t\t\t\t\t\t\t\t\\\n-\tif (X##_e) X##_f0 |= _FP_IMPLBIT_E;\t\t\t\\\n-\telse X##_f0 &= ~(_FP_IMPLBIT_E);\t\t\t\\\n-\t_flo->bits.frac = X##_f0;\t\t\t\t\\\n-\t_flo->bits.exp  = X##_e;\t\t\t\t\\\n-\t_flo->bits.sign = X##_s;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-\n-#define FP_UNPACK_E(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    FP_UNPACK_RAW_E(X,val);\t\t\\\n-    _FP_UNPACK_CANONICAL(E,2,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_EP(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    FP_UNPACK_RAW_EP(X,val);\t\t\\\n-    _FP_UNPACK_CANONICAL(E,2,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_E(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    FP_UNPACK_RAW_E(X,val);\t\t\\\n-    _FP_UNPACK_SEMIRAW(E,2,X);\t\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_EP(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    FP_UNPACK_RAW_EP(X,val);\t\t\\\n-    _FP_UNPACK_SEMIRAW(E,2,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_E(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(E,2,X);\t\t\\\n-    FP_PACK_RAW_E(val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_EP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(E,2,X);\t\t\\\n-    FP_PACK_RAW_EP(val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_E(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(E,2,X);\t\t\\\n-    FP_PACK_RAW_E(val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_EP(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(E,2,X);\t\t\\\n-    FP_PACK_RAW_EP(val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_ISSIGNAN_E(X)\t_FP_ISSIGNAN(E,2,X)\n-#define FP_NEG_E(R,X)\t\t_FP_NEG(E,2,R,X)\n-#define FP_ADD_E(R,X,Y)\t\t_FP_ADD(E,2,R,X,Y)\n-#define FP_SUB_E(R,X,Y)\t\t_FP_SUB(E,2,R,X,Y)\n-#define FP_MUL_E(R,X,Y)\t\t_FP_MUL(E,2,R,X,Y)\n-#define FP_DIV_E(R,X,Y)\t\t_FP_DIV(E,2,R,X,Y)\n-#define FP_SQRT_E(R,X)\t\t_FP_SQRT(E,2,R,X)\n+      X##_f0 = _flo->bits.frac;\t\t\t\t\t\\\n+      X##_f1 = 0;\t\t\t\t\t\t\\\n+      X##_e = _flo->bits.exp;\t\t\t\t\t\\\n+      X##_s = _flo->bits.sign;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_RAW_E(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      union _FP_UNION_E _flo;\t\t\t\\\n+\t\t\t\t\t\t\\\n+      if (X##_e)\t\t\t\t\\\n+\tX##_f0 |= _FP_IMPLBIT_E;\t\t\\\n+      else\t\t\t\t\t\\\n+\tX##_f0 &= ~(_FP_IMPLBIT_E);\t\t\\\n+      _flo.bits.frac = X##_f0;\t\t\t\\\n+      _flo.bits.exp  = X##_e;\t\t\t\\\n+      _flo.bits.sign = X##_s;\t\t\t\\\n+\t\t\t\t\t\t\\\n+      (val) = _flo.flt;\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_RAW_EP(fs, val, X)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  union _FP_UNION_E *_flo = (union _FP_UNION_E *) (val);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if (X##_e)\t\t\t\t\t\t\t\\\n+\t    X##_f0 |= _FP_IMPLBIT_E;\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    X##_f0 &= ~(_FP_IMPLBIT_E);\t\t\t\t\t\\\n+\t  _flo->bits.frac = X##_f0;\t\t\t\t\t\\\n+\t  _flo->bits.exp  = X##_e;\t\t\t\t\t\\\n+\t  _flo->bits.sign = X##_s;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+# define FP_UNPACK_E(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      FP_UNPACK_RAW_E (X, val);\t\t\t\\\n+      _FP_UNPACK_CANONICAL (E, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_EP(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      FP_UNPACK_RAW_EP (X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (E, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_E(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      FP_UNPACK_RAW_E (X, val);\t\t\t\\\n+      _FP_UNPACK_SEMIRAW (E, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_EP(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      FP_UNPACK_RAW_EP (X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (E, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_E(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (E, 2, X);\t\t\\\n+      FP_PACK_RAW_E (val, X);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_EP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (E, 2, X);\t\t\\\n+      FP_PACK_RAW_EP (val, X);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_E(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (E, 2, X);\t\t\\\n+      FP_PACK_RAW_E (val, X);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_EP(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (E, 2, X);\t\t\\\n+      FP_PACK_RAW_EP (val, X);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_ISSIGNAN_E(X)\t_FP_ISSIGNAN (E, 2, X)\n+# define FP_NEG_E(R, X)\t\t_FP_NEG (E, 2, R, X)\n+# define FP_ADD_E(R, X, Y)\t_FP_ADD (E, 2, R, X, Y)\n+# define FP_SUB_E(R, X, Y)\t_FP_SUB (E, 2, R, X, Y)\n+# define FP_MUL_E(R, X, Y)\t_FP_MUL (E, 2, R, X, Y)\n+# define FP_DIV_E(R, X, Y)\t_FP_DIV (E, 2, R, X, Y)\n+# define FP_SQRT_E(R, X)\t_FP_SQRT (E, 2, R, X)\n+# define FP_FMA_E(R, X, Y, Z)\t_FP_FMA (E, 2, 4, R, X, Y, Z)\n \n /*\n  * Square root algorithms:\n@@ -392,39 +462,43 @@ union _FP_UNION_E\n  * in one UWtype registers instead of two, although we don't\n  * have to.\n  */\n-#define _FP_SQRT_MEAT_E(R, S, T, X, q)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\\\n-    _FP_FRAC_SRL_2(X, (_FP_WORKBITS));\t\t\t\\\n-    while (q)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-        T##_f0 = S##_f0 + q;\t\t\t\t\\\n-        if (T##_f0 <= X##_f0)\t\t\t\t\\\n-          {\t\t\t\t\t\t\\\n-            S##_f0 = T##_f0 + q;\t\t\t\\\n-            X##_f0 -= T##_f0;\t\t\t\t\\\n-            R##_f0 += q;\t\t\t\t\\\n-          }\t\t\t\t\t\t\\\n-        _FP_FRAC_SLL_1(X, 1);\t\t\t\t\\\n-        q >>= 1;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    _FP_FRAC_SLL_2(R, (_FP_WORKBITS));\t\t\t\\\n-    if (X##_f0)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tif (S##_f0 < X##_f0)\t\t\t\t\\\n-\t  R##_f0 |= _FP_WORK_ROUND;\t\t\t\\\n-\tR##_f0 |= _FP_WORK_STICKY;\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_CMP_E(r,X,Y,un)\t_FP_CMP(E,2,r,X,Y,un)\n-#define FP_CMP_EQ_E(r,X,Y)\t_FP_CMP_EQ(E,2,r,X,Y)\n-#define FP_CMP_UNORD_E(r,X,Y)\t_FP_CMP_UNORD(E,2,r,X,Y)\n-\n-#define FP_TO_INT_E(r,X,rsz,rsg)\t_FP_TO_INT(E,2,r,X,rsz,rsg)\n-#define FP_FROM_INT_E(X,r,rs,rt)\t_FP_FROM_INT(E,2,X,r,rs,rt)\n-\n-#define _FP_FRAC_HIGH_E(X)\t(X##_f1)\n-#define _FP_FRAC_HIGH_RAW_E(X)\t(X##_f0)\n+# define _FP_SQRT_MEAT_E(R, S, T, X, q)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      q = (_FP_W_TYPE) 1 << (_FP_W_TYPE_SIZE - 1);\t\\\n+      _FP_FRAC_SRL_2 (X, (_FP_WORKBITS));\t\t\\\n+      while (q)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  T##_f0 = S##_f0 + q;\t\t\t\t\\\n+\t  if (T##_f0 <= X##_f0)\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\\\n+\t      S##_f0 = T##_f0 + q;\t\t\t\\\n+\t      X##_f0 -= T##_f0;\t\t\t\t\\\n+\t      R##_f0 += q;\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SLL_1 (X, 1);\t\t\t\\\n+\t  q >>= 1;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      _FP_FRAC_SLL_2 (R, (_FP_WORKBITS));\t\t\\\n+      if (X##_f0)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (S##_f0 < X##_f0)\t\t\t\t\\\n+\t    R##_f0 |= _FP_WORK_ROUND;\t\t\t\\\n+\t  R##_f0 |= _FP_WORK_STICKY;\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_CMP_E(r, X, Y, un)\t\t_FP_CMP (E, 2, r, X, Y, un)\n+# define FP_CMP_EQ_E(r, X, Y)\t\t_FP_CMP_EQ (E, 2, r, X, Y)\n+# define FP_CMP_UNORD_E(r, X, Y)\t_FP_CMP_UNORD (E, 2, r, X, Y)\n+\n+# define FP_TO_INT_E(r, X, rsz, rsg)\t_FP_TO_INT (E, 2, r, X, rsz, rsg)\n+# define FP_FROM_INT_E(X, r, rs, rt)\t_FP_FROM_INT (E, 2, X, r, rs, rt)\n+\n+# define _FP_FRAC_HIGH_E(X)\t(X##_f1)\n+# define _FP_FRAC_HIGH_RAW_E(X)\t(X##_f0)\n+\n+# define _FP_FRAC_HIGH_DW_E(X)\t(X##_f[2])\n \n #endif /* not _FP_W_TYPE_SIZE < 64 */"}, {"sha": "2276de527f0d73424155502db83bfb5f3cf4aab6", "filename": "libgcc/soft-fp/extendsfdf2.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fextendsfdf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fextendsfdf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fextendsfdf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -32,21 +32,22 @@\n #include \"single.h\"\n #include \"double.h\"\n \n-DFtype __extendsfdf2(SFtype a)\n+DFtype\n+__extendsfdf2 (SFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n-  FP_DECL_D(R);\n+  FP_DECL_S (A);\n+  FP_DECL_D (R);\n   DFtype r;\n \n-  FP_INIT_ROUNDMODE;\n-  FP_UNPACK_RAW_S(A, a);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n #if _FP_W_TYPE_SIZE < _FP_FRACBITS_D\n-  FP_EXTEND(D,S,2,1,R,A);\n+  FP_EXTEND (D, S, 2, 1, R, A);\n #else\n-  FP_EXTEND(D,S,1,1,R,A);\n+  FP_EXTEND (D, S, 1, 1, R, A);\n #endif\n-  FP_PACK_RAW_D(r, R);\n+  FP_PACK_RAW_D (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "51f60c456985141d530cc07836f077e312add3ce", "filename": "libgcc/soft-fp/extendsftf2.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fextendsftf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fextendsftf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fextendsftf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -32,21 +32,22 @@\n #include \"single.h\"\n #include \"quad.h\"\n \n-TFtype __extendsftf2(SFtype a)\n+TFtype\n+__extendsftf2 (SFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n-  FP_DECL_Q(R);\n+  FP_DECL_S (A);\n+  FP_DECL_Q (R);\n   TFtype r;\n \n-  FP_INIT_ROUNDMODE;\n-  FP_UNPACK_RAW_S(A, a);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n #if (2 * _FP_W_TYPE_SIZE) < _FP_FRACBITS_Q\n-  FP_EXTEND(Q,S,4,1,R,A);\n+  FP_EXTEND (Q, S, 4, 1, R, A);\n #else\n-  FP_EXTEND(Q,S,2,1,R,A);\n+  FP_EXTEND (Q, S, 2, 1, R, A);\n #endif\n-  FP_PACK_RAW_Q(r, R);\n+  FP_PACK_RAW_Q (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "684052d87442215c359468c9cae7019d60033881", "filename": "libgcc/soft-fp/extendxftf2.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fextendxftf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fextendxftf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fextendxftf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Return a converted to IEEE quad\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,29 +24,29 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"extended.h\"\n #include \"quad.h\"\n \n-TFtype __extendxftf2(XFtype a)\n+TFtype\n+__extendxftf2 (XFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_E(A);\n-  FP_DECL_Q(R);\n+  FP_DECL_E (A);\n+  FP_DECL_Q (R);\n   TFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_RAW_E(A, a);\n+  FP_UNPACK_RAW_E (A, a);\n #if (2 * _FP_W_TYPE_SIZE) < _FP_FRACBITS_Q\n-  FP_EXTEND(Q,E,4,4,R,A);\n+  FP_EXTEND (Q, E, 4, 4, R, A);\n #else\n-  FP_EXTEND(Q,E,2,2,R,A);\n+  FP_EXTEND (Q, E, 2, 2, R, A);\n #endif\n-  FP_PACK_RAW_Q(r, R);\n+  FP_PACK_RAW_Q (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "7b926b3d6926f247b22b83821cbe290fd20225cc", "filename": "libgcc/soft-fp/fixdfdi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixdfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixdfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixdfdi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DItype __fixdfdi(DFtype a)\n+DItype\n+__fixdfdi (DFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   UDItype r;\n \n-  FP_UNPACK_RAW_D(A, a);\n-  FP_TO_INT_D(r, A, DI_BITS, 1);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n+  FP_TO_INT_D (r, A, DI_BITS, 1);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "79b2d2150596fb1442564dfcbffd93041876cacf", "filename": "libgcc/soft-fp/fixdfsi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixdfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixdfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixdfsi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-SItype __fixdfsi(DFtype a)\n+SItype\n+__fixdfsi (DFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   USItype r;\n \n-  FP_UNPACK_RAW_D(A, a);\n-  FP_TO_INT_D(r, A, SI_BITS, 1);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n+  FP_TO_INT_D (r, A, SI_BITS, 1);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "b5fe4f99fc1b4fa84466821ba79c0848ceeba1d0", "filename": "libgcc/soft-fp/fixdfti.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixdfti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixdfti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixdfti.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert IEEE double to 128bit signed integer\n-   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-TItype __fixdfti(DFtype a)\n+TItype\n+__fixdfti (DFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   UTItype r;\n \n-  FP_UNPACK_RAW_D(A, a);\n-  FP_TO_INT_D(r, A, TI_BITS, 1);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n+  FP_TO_INT_D (r, A, TI_BITS, 1);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "df6b9c728a256f1e64518e03aaaf9f471df2a41c", "filename": "libgcc/soft-fp/fixsfdi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixsfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixsfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixsfdi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-DItype __fixsfdi(SFtype a)\n+DItype\n+__fixsfdi (SFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   UDItype r;\n \n-  FP_UNPACK_RAW_S(A, a);\n-  FP_TO_INT_S(r, A, DI_BITS, 1);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n+  FP_TO_INT_S (r, A, DI_BITS, 1);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "4c0bfd39db1f6ef030c7dfa72c1388ea18a5baa1", "filename": "libgcc/soft-fp/fixsfsi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixsfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixsfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixsfsi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SItype __fixsfsi(SFtype a)\n+SItype\n+__fixsfsi (SFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   USItype r;\n \n-  FP_UNPACK_RAW_S(A, a);\n-  FP_TO_INT_S(r, A, SI_BITS, 1);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n+  FP_TO_INT_S (r, A, SI_BITS, 1);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "6b5229fe91a8509cd74b742b8a89e6031d6d5693", "filename": "libgcc/soft-fp/fixsfti.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixsfti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixsfti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixsfti.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert IEEE single to 128bit signed integer\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-TItype __fixsfti(SFtype a)\n+TItype\n+__fixsfti (SFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   UTItype r;\n \n-  FP_UNPACK_RAW_S(A, a);\n-  FP_TO_INT_S(r, A, TI_BITS, 1);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n+  FP_TO_INT_S (r, A, TI_BITS, 1);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "a65173aa78183477b70e2ba43a41a1529e6e5082", "filename": "libgcc/soft-fp/fixtfdi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixtfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixtfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixtfdi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-DItype __fixtfdi(TFtype a)\n+DItype\n+__fixtfdi (TFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   UDItype r;\n \n-  FP_UNPACK_RAW_Q(A, a);\n-  FP_TO_INT_Q(r, A, DI_BITS, 1);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_TO_INT_Q (r, A, DI_BITS, 1);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "bc0ea0b87d25a93f9b4e4832addc3ad090fed680", "filename": "libgcc/soft-fp/fixtfsi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixtfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixtfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixtfsi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-SItype __fixtfsi(TFtype a)\n+SItype\n+__fixtfsi (TFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   USItype r;\n \n-  FP_UNPACK_RAW_Q(A, a);\n-  FP_TO_INT_Q(r, A, SI_BITS, 1);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_TO_INT_Q (r, A, SI_BITS, 1);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "573ca0ed11bed3c308d20c163b249a6bee027e36", "filename": "libgcc/soft-fp/fixtfti.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixtfti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixtfti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixtfti.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert IEEE quad to 128bit signed integer\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-TItype __fixtfti(TFtype a)\n+TItype\n+__fixtfti (TFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   UTItype r;\n \n-  FP_UNPACK_RAW_Q(A, a);\n-  FP_TO_INT_Q(r, A, TI_BITS, 1);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_TO_INT_Q (r, A, TI_BITS, 1);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "8831cc3d19ff015e43a5291917a8d417b3f3445c", "filename": "libgcc/soft-fp/fixunsdfdi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunsdfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunsdfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixunsdfdi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-UDItype __fixunsdfdi(DFtype a)\n+UDItype\n+__fixunsdfdi (DFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   UDItype r;\n \n-  FP_UNPACK_RAW_D(A, a);\n-  FP_TO_INT_D(r, A, DI_BITS, 0);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n+  FP_TO_INT_D (r, A, DI_BITS, 0);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "ff3744467a2d2d6505847f787b1c285df3ca8a31", "filename": "libgcc/soft-fp/fixunsdfsi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunsdfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunsdfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixunsdfsi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-USItype __fixunsdfsi(DFtype a)\n+USItype\n+__fixunsdfsi (DFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   USItype r;\n \n-  FP_UNPACK_RAW_D(A, a);\n-  FP_TO_INT_D(r, A, SI_BITS, 0);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n+  FP_TO_INT_D (r, A, SI_BITS, 0);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "f124a7c6a8d0e4bbad8e0c8f670d538914a1c4a4", "filename": "libgcc/soft-fp/fixunsdfti.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunsdfti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunsdfti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixunsdfti.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert IEEE double to 128bit unsigned integer\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-UTItype __fixunsdfti(DFtype a)\n+UTItype\n+__fixunsdfti (DFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   UTItype r;\n \n-  FP_UNPACK_RAW_D(A, a);\n-  FP_TO_INT_D(r, A, TI_BITS, 0);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n+  FP_TO_INT_D (r, A, TI_BITS, 0);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "4261c5e6a7a949bf1666f3c3812493d562a8434c", "filename": "libgcc/soft-fp/fixunssfdi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunssfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunssfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixunssfdi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-UDItype __fixunssfdi(SFtype a)\n+UDItype\n+__fixunssfdi (SFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   UDItype r;\n \n-  FP_UNPACK_RAW_S(A, a);\n-  FP_TO_INT_S(r, A, DI_BITS, 0);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n+  FP_TO_INT_S (r, A, DI_BITS, 0);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "b4bb890299cb479226e0fc97e3b8fe9c3b0df71c", "filename": "libgcc/soft-fp/fixunssfsi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunssfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunssfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixunssfsi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-USItype __fixunssfsi(SFtype a)\n+USItype\n+__fixunssfsi (SFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   USItype r;\n \n-  FP_UNPACK_RAW_S(A, a);\n-  FP_TO_INT_S(r, A, SI_BITS, 0);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n+  FP_TO_INT_S (r, A, SI_BITS, 0);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "36d01b0cfe841877be302145078f9c8c2a88e8db", "filename": "libgcc/soft-fp/fixunssfti.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunssfti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunssfti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixunssfti.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert IEEE single to 128bit unsigned integer\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-UTItype __fixunssfti(SFtype a)\n+UTItype\n+__fixunssfti (SFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   UTItype r;\n \n-  FP_UNPACK_RAW_S(A, a);\n-  FP_TO_INT_S(r, A, TI_BITS, 0);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n+  FP_TO_INT_S (r, A, TI_BITS, 0);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "b2355a2ae9daefd0c16c3246b0b6ce3f6358fc46", "filename": "libgcc/soft-fp/fixunstfdi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunstfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunstfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixunstfdi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-UDItype __fixunstfdi(TFtype a)\n+UDItype\n+__fixunstfdi (TFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   UDItype r;\n \n-  FP_UNPACK_RAW_Q(A, a);\n-  FP_TO_INT_Q(r, A, DI_BITS, 0);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_TO_INT_Q (r, A, DI_BITS, 0);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "efa1418da1d62fbf6a18408c2b0320572c8a3897", "filename": "libgcc/soft-fp/fixunstfsi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunstfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunstfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixunstfsi.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-USItype __fixunstfsi(TFtype a)\n+USItype\n+__fixunstfsi (TFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   USItype r;\n \n-  FP_UNPACK_RAW_Q(A, a);\n-  FP_TO_INT_Q(r, A, SI_BITS, 0);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_TO_INT_Q (r, A, SI_BITS, 0);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "efe0cf5c5d55bac9f9255fefc4b1728b4121a95c", "filename": "libgcc/soft-fp/fixunstfti.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunstfti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffixunstfti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffixunstfti.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert IEEE quad to 128bit unsigned integer\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-UTItype __fixunstfti(TFtype a)\n+UTItype\n+__fixunstfti (TFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   UTItype r;\n \n-  FP_UNPACK_RAW_Q(A, a);\n-  FP_TO_INT_Q(r, A, TI_BITS, 0);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_TO_INT_Q (r, A, TI_BITS, 0);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "fc8719abd732362feacf8913f51da7a67780b9d5", "filename": "libgcc/soft-fp/floatdidf.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatdidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatdidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatdidf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DFtype __floatdidf(DItype i)\n+DFtype\n+__floatdidf (DItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   DFtype a;\n \n-  FP_FROM_INT_D(A, i, DI_BITS, UDItype);\n-  FP_PACK_RAW_D(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_D (A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_D (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "b6b6b42525082cdfe5f30c708a34cb892811edf8", "filename": "libgcc/soft-fp/floatdisf.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatdisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatdisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatdisf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SFtype __floatdisf(DItype i)\n+SFtype\n+__floatdisf (DItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   SFtype a;\n \n-  FP_FROM_INT_S(A, i, DI_BITS, UDItype);\n-  FP_PACK_RAW_S(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_S (A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_S (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "fc3fba361f775c0ed8fbf18c9e0b744ccf9356f3", "filename": "libgcc/soft-fp/floatditf.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatditf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatditf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatditf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -28,18 +28,18 @@\n    License along with the GNU C Library; if not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+#define FP_NO_EXCEPTIONS\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-TFtype __floatditf(DItype i)\n+TFtype\n+__floatditf (DItype i)\n {\n-  FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   TFtype a;\n \n-  FP_FROM_INT_Q(A, i, DI_BITS, UDItype);\n-  FP_PACK_RAW_Q(a, A);\n-  FP_HANDLE_EXCEPTIONS;\n+  FP_FROM_INT_Q (A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_Q (a, A);\n \n   return a;\n }"}, {"sha": "7df5265ffc8dd1ac61d5bc701816a17858da6a9b", "filename": "libgcc/soft-fp/floatsidf.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatsidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatsidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatsidf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -28,18 +28,18 @@\n    License along with the GNU C Library; if not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+#define FP_NO_EXCEPTIONS\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DFtype __floatsidf(SItype i)\n+DFtype\n+__floatsidf (SItype i)\n {\n-  FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   DFtype a;\n \n-  FP_FROM_INT_D(A, i, SI_BITS, USItype);\n-  FP_PACK_RAW_D(a, A);\n-  FP_HANDLE_EXCEPTIONS;\n+  FP_FROM_INT_D (A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_D (a, A);\n \n   return a;\n }"}, {"sha": "b55fd3329ebc30609e1f8a8af2cf0b5d1bd3e093", "filename": "libgcc/soft-fp/floatsisf.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatsisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatsisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatsisf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SFtype __floatsisf(SItype i)\n+SFtype\n+__floatsisf (SItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   SFtype a;\n \n-  FP_FROM_INT_S(A, i, SI_BITS, USItype);\n-  FP_PACK_RAW_S(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_S (A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_S (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "d7c3078e4ba1185c23c7e050daa9397a974821a1", "filename": "libgcc/soft-fp/floatsitf.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatsitf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatsitf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatsitf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -28,18 +28,18 @@\n    License along with the GNU C Library; if not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+#define FP_NO_EXCEPTIONS\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-TFtype __floatsitf(SItype i)\n+TFtype\n+__floatsitf (SItype i)\n {\n-  FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   TFtype a;\n \n-  FP_FROM_INT_Q(A, i, SI_BITS, USItype);\n-  FP_PACK_RAW_Q(a, A);\n-  FP_HANDLE_EXCEPTIONS;\n+  FP_FROM_INT_Q (A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_Q (a, A);\n \n   return a;\n }"}, {"sha": "a28181b23a7e6c3b1b95cd42ae671d927fe57b34", "filename": "libgcc/soft-fp/floattidf.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloattidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloattidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloattidf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert a 128bit signed integer to IEEE double\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DFtype __floattidf(TItype i)\n+DFtype\n+__floattidf (TItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   DFtype a;\n \n-  FP_FROM_INT_D(A, i, TI_BITS, UTItype);\n-  FP_PACK_RAW_D(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_D (A, i, TI_BITS, UTItype);\n+  FP_PACK_RAW_D (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "da8104794502f9bd405a0d6fc683ecaf306ffc2b", "filename": "libgcc/soft-fp/floattisf.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloattisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloattisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloattisf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert a 128bit signed integer to IEEE single\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SFtype __floattisf(TItype i)\n+SFtype\n+__floattisf (TItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   SFtype a;\n \n-  FP_FROM_INT_S(A, i, TI_BITS, UTItype);\n-  FP_PACK_RAW_S(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_S (A, i, TI_BITS, UTItype);\n+  FP_PACK_RAW_S (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "ffe217a6226e9b9a12981cf732028a2b67035ec7", "filename": "libgcc/soft-fp/floattitf.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloattitf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloattitf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloattitf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert a 128bit signed integer to IEEE quad\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-TFtype __floattitf(TItype i)\n+TFtype\n+__floattitf (TItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   TFtype a;\n \n-  FP_FROM_INT_Q(A, i, TI_BITS, UTItype);\n-  FP_PACK_RAW_Q(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_Q (A, i, TI_BITS, UTItype);\n+  FP_PACK_RAW_Q (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "8a041f827a4e8c99a84e043c7a6870e96eb9c6a2", "filename": "libgcc/soft-fp/floatundidf.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatundidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatundidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatundidf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DFtype __floatundidf(UDItype i)\n+DFtype\n+__floatundidf (UDItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   DFtype a;\n \n-  FP_FROM_INT_D(A, i, DI_BITS, UDItype);\n-  FP_PACK_RAW_D(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_D (A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_D (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "8dc750851af83357387e1109376af3a800cc0a11", "filename": "libgcc/soft-fp/floatundisf.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatundisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatundisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatundisf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SFtype __floatundisf(UDItype i)\n+SFtype\n+__floatundisf (UDItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   SFtype a;\n \n-  FP_FROM_INT_S(A, i, DI_BITS, UDItype);\n-  FP_PACK_RAW_S(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_S (A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_S (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "cc8a3fe06c922e6366fa94527334bab833dfacec", "filename": "libgcc/soft-fp/floatunditf.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatunditf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatunditf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatunditf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -28,19 +28,18 @@\n    License along with the GNU C Library; if not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+#define FP_NO_EXCEPTIONS\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n TFtype\n-__floatunditf(UDItype i)\n+__floatunditf (UDItype i)\n {\n-  FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   TFtype a;\n \n-  FP_FROM_INT_Q(A, i, DI_BITS, UDItype);\n-  FP_PACK_RAW_Q(a, A);\n-  FP_HANDLE_EXCEPTIONS;\n+  FP_FROM_INT_Q (A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_Q (a, A);\n \n   return a;\n }"}, {"sha": "059029640c9690c6b33eb4fcae14669f95c601fc", "filename": "libgcc/soft-fp/floatunsidf.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatunsidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatunsidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatunsidf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -28,18 +28,18 @@\n    License along with the GNU C Library; if not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+#define FP_NO_EXCEPTIONS\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DFtype __floatunsidf(USItype i)\n+DFtype\n+__floatunsidf (USItype i)\n {\n-  FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   DFtype a;\n \n-  FP_FROM_INT_D(A, i, SI_BITS, USItype);\n-  FP_PACK_RAW_D(a, A);\n-  FP_HANDLE_EXCEPTIONS;\n+  FP_FROM_INT_D (A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_D (a, A);\n \n   return a;\n }"}, {"sha": "91c1e4d1a96291a7d9904b6358efbe9c47b64479", "filename": "libgcc/soft-fp/floatunsisf.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatunsisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatunsisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatunsisf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,14 +31,16 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SFtype __floatunsisf(USItype i)\n+SFtype\n+__floatunsisf (USItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   SFtype a;\n \n-  FP_FROM_INT_S(A, i, SI_BITS, USItype);\n-  FP_PACK_RAW_S(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_S (A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_S (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "b1eecfd7c95d5845b9a623771ab114af7548e20b", "filename": "libgcc/soft-fp/floatunsitf.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatunsitf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatunsitf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatunsitf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -28,19 +28,18 @@\n    License along with the GNU C Library; if not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+#define FP_NO_EXCEPTIONS\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n TFtype\n-__floatunsitf(USItype i)\n+__floatunsitf (USItype i)\n {\n-  FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   TFtype a;\n \n-  FP_FROM_INT_Q(A, i, SI_BITS, USItype);\n-  FP_PACK_RAW_Q(a, A);\n-  FP_HANDLE_EXCEPTIONS;\n+  FP_FROM_INT_Q (A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_Q (a, A);\n \n   return a;\n }"}, {"sha": "6a8981daec09a47b6cfc14dac5cf192b7d69f7d3", "filename": "libgcc/soft-fp/floatuntidf.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatuntidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatuntidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatuntidf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert a 128bit unsigned integer to IEEE double\n-   Copyright (C) 1997,1999, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 1997-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DFtype __floatuntidf(UTItype i)\n+DFtype\n+__floatuntidf (UTItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n+  FP_DECL_D (A);\n   DFtype a;\n \n-  FP_FROM_INT_D(A, i, TI_BITS, UTItype);\n-  FP_PACK_RAW_D(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_D (A, i, TI_BITS, UTItype);\n+  FP_PACK_RAW_D (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "94d0593f26f933d062ee48a93d2473a70138f618", "filename": "libgcc/soft-fp/floatuntisf.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatuntisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatuntisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatuntisf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert a 128bit unsigned integer to IEEE single\n-   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SFtype __floatuntisf(UTItype i)\n+SFtype\n+__floatuntisf (UTItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A);\n+  FP_DECL_S (A);\n   SFtype a;\n \n-  FP_FROM_INT_S(A, i, TI_BITS, UTItype);\n-  FP_PACK_RAW_S(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_S (A, i, TI_BITS, UTItype);\n+  FP_PACK_RAW_S (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "424bfef8fa8221fbb0e9661311b8ae71661a0791", "filename": "libgcc/soft-fp/floatuntitf.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatuntitf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ffloatuntitf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ffloatuntitf.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Convert a 128bit unsigned integer to IEEE quad\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,21 +24,22 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-TFtype __floatuntitf(UTItype i)\n+TFtype\n+__floatuntitf (UTItype i)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A);\n+  FP_DECL_Q (A);\n   TFtype a;\n \n-  FP_FROM_INT_Q(A, i, TI_BITS, UTItype);\n-  FP_PACK_RAW_Q(a, A);\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_Q (A, i, TI_BITS, UTItype);\n+  FP_PACK_RAW_Q (a, A);\n   FP_HANDLE_EXCEPTIONS;\n \n   return a;"}, {"sha": "5b6fad28492459686b44ea65e48efa5c88bc0a95", "filename": "libgcc/soft-fp/gedf2.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fgedf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fgedf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fgedf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,20 +31,23 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-CMPtype __gedf2(DFtype a, DFtype b)\n+CMPtype\n+__gedf2 (DFtype a, DFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A); FP_DECL_D(B);\n+  FP_DECL_D (A);\n+  FP_DECL_D (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_D(A, a);\n-  FP_UNPACK_RAW_D(B, b);\n-  FP_CMP_D(r, A, B, -2);\n-  if (r == -2 && (FP_ISSIGNAN_D(A) || FP_ISSIGNAN_D(B)))\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n+  FP_UNPACK_RAW_D (B, b);\n+  FP_CMP_D (r, A, B, -2);\n+  if (r == -2)\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }\n \n-strong_alias(__gedf2, __gtdf2);\n+strong_alias (__gedf2, __gtdf2);"}, {"sha": "4e5d9393f1e66ed1958e3dc250bd172a18d30ce6", "filename": "libgcc/soft-fp/gesf2.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fgesf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fgesf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fgesf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,20 +31,23 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-CMPtype __gesf2(SFtype a, SFtype b)\n+CMPtype\n+__gesf2 (SFtype a, SFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A); FP_DECL_S(B);\n+  FP_DECL_S (A);\n+  FP_DECL_S (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_S(A, a);\n-  FP_UNPACK_RAW_S(B, b);\n-  FP_CMP_S(r, A, B, -2);\n-  if (r == -2 && (FP_ISSIGNAN_S(A) || FP_ISSIGNAN_S(B)))\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n+  FP_UNPACK_RAW_S (B, b);\n+  FP_CMP_S (r, A, B, -2);\n+  if (r == -2)\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }\n \n-strong_alias(__gesf2, __gtsf2);\n+strong_alias (__gesf2, __gtsf2);"}, {"sha": "ed02f459ea2b2a1668824e7a284e77a3ae1d3c4b", "filename": "libgcc/soft-fp/getf2.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fgetf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fgetf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fgetf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,20 +31,23 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-CMPtype __getf2(TFtype a, TFtype b)\n+CMPtype\n+__getf2 (TFtype a, TFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A); FP_DECL_Q(B);\n+  FP_DECL_Q (A);\n+  FP_DECL_Q (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_Q(A, a);\n-  FP_UNPACK_RAW_Q(B, b);\n-  FP_CMP_Q(r, A, B, -2);\n-  if (r == -2 && (FP_ISSIGNAN_Q(A) || FP_ISSIGNAN_Q(B)))\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_UNPACK_RAW_Q (B, b);\n+  FP_CMP_Q (r, A, B, -2);\n+  if (r == -2)\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }\n \n-strong_alias(__getf2, __gttf2);\n+strong_alias (__getf2, __gttf2);"}, {"sha": "476f1c47015f361f6c19e060129f93e74041fea5", "filename": "libgcc/soft-fp/ledf2.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fledf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fledf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fledf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,20 +31,23 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-CMPtype __ledf2(DFtype a, DFtype b)\n+CMPtype\n+__ledf2 (DFtype a, DFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A); FP_DECL_D(B);\n+  FP_DECL_D (A);\n+  FP_DECL_D (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_D(A, a);\n-  FP_UNPACK_RAW_D(B, b);\n-  FP_CMP_D(r, A, B, 2);\n-  if (r == 2 && (FP_ISSIGNAN_D(A) || FP_ISSIGNAN_D(B)))\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n+  FP_UNPACK_RAW_D (B, b);\n+  FP_CMP_D (r, A, B, 2);\n+  if (r == 2)\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }\n \n-strong_alias(__ledf2, __ltdf2);\n+strong_alias (__ledf2, __ltdf2);"}, {"sha": "ac2f748a36ca958f808a7094b846084ce3b0ebb4", "filename": "libgcc/soft-fp/lesf2.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Flesf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Flesf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Flesf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,20 +31,23 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-CMPtype __lesf2(SFtype a, SFtype b)\n+CMPtype\n+__lesf2 (SFtype a, SFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A); FP_DECL_S(B);\n+  FP_DECL_S (A);\n+  FP_DECL_S (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_S(A, a);\n-  FP_UNPACK_RAW_S(B, b);\n-  FP_CMP_S(r, A, B, 2);\n-  if (r == 2 && (FP_ISSIGNAN_S(A) || FP_ISSIGNAN_S(B)))\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n+  FP_UNPACK_RAW_S (B, b);\n+  FP_CMP_S (r, A, B, 2);\n+  if (r == 2)\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }\n \n-strong_alias(__lesf2, __ltsf2);\n+strong_alias (__lesf2, __ltsf2);"}, {"sha": "a41055b9494450a57c01c1a86c17cbc4703795bb", "filename": "libgcc/soft-fp/letf2.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fletf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fletf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fletf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,20 +31,23 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-CMPtype __letf2(TFtype a, TFtype b)\n+CMPtype\n+__letf2 (TFtype a, TFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A); FP_DECL_Q(B);\n+  FP_DECL_Q (A);\n+  FP_DECL_Q (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_Q(A, a);\n-  FP_UNPACK_RAW_Q(B, b);\n-  FP_CMP_Q(r, A, B, 2);\n-  if (r == 2 && (FP_ISSIGNAN_Q(A) || FP_ISSIGNAN_Q(B)))\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_UNPACK_RAW_Q (B, b);\n+  FP_CMP_Q (r, A, B, 2);\n+  if (r == 2)\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }\n \n-strong_alias(__letf2, __lttf2);\n+strong_alias (__letf2, __lttf2);"}, {"sha": "dee3f76e5b970daf1525affb63088aa88a34f845", "filename": "libgcc/soft-fp/muldf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fmuldf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fmuldf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fmuldf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DFtype __muldf3(DFtype a, DFtype b)\n+DFtype\n+__muldf3 (DFtype a, DFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A); FP_DECL_D(B); FP_DECL_D(R);\n+  FP_DECL_D (A);\n+  FP_DECL_D (B);\n+  FP_DECL_D (R);\n   DFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_D(A, a);\n-  FP_UNPACK_D(B, b);\n-  FP_MUL_D(R, A, B);\n-  FP_PACK_D(r, R);\n+  FP_UNPACK_D (A, a);\n+  FP_UNPACK_D (B, b);\n+  FP_MUL_D (R, A, B);\n+  FP_PACK_D (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "f983b303479daa01946622468fa5e0408018d84b", "filename": "libgcc/soft-fp/mulsf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fmulsf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fmulsf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fmulsf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SFtype __mulsf3(SFtype a, SFtype b)\n+SFtype\n+__mulsf3 (SFtype a, SFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A); FP_DECL_S(B); FP_DECL_S(R);\n+  FP_DECL_S (A);\n+  FP_DECL_S (B);\n+  FP_DECL_S (R);\n   SFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_S(A, a);\n-  FP_UNPACK_S(B, b);\n-  FP_MUL_S(R, A, B);\n-  FP_PACK_S(r, R);\n+  FP_UNPACK_S (A, a);\n+  FP_UNPACK_S (B, b);\n+  FP_MUL_S (R, A, B);\n+  FP_PACK_S (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "1306c63f8ad7dfc7b80c92a9a682444b9f265568", "filename": "libgcc/soft-fp/multf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fmultf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fmultf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fmultf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-TFtype __multf3(TFtype a, TFtype b)\n+TFtype\n+__multf3 (TFtype a, TFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(R);\n+  FP_DECL_Q (A);\n+  FP_DECL_Q (B);\n+  FP_DECL_Q (R);\n   TFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_Q(A, a);\n-  FP_UNPACK_Q(B, b);\n-  FP_MUL_Q(R, A, B);\n-  FP_PACK_Q(r, R);\n+  FP_UNPACK_Q (A, a);\n+  FP_UNPACK_Q (B, b);\n+  FP_MUL_Q (R, A, B);\n+  FP_PACK_Q (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "d74c16c1ede0b180c75216a9ba85c2da8f1d0090", "filename": "libgcc/soft-fp/negdf2.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fnegdf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fnegdf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fnegdf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,16 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DFtype __negdf2(DFtype a)\n+DFtype\n+__negdf2 (DFtype a)\n {\n-  FP_DECL_EX;\n-  FP_DECL_D(A); FP_DECL_D(R);\n+  FP_DECL_D (A);\n+  FP_DECL_D (R);\n   DFtype r;\n \n-  FP_UNPACK_D(A, a);\n-  FP_NEG_D(R, A);\n-  FP_PACK_D(r, R);\n-  FP_CLEAR_EXCEPTIONS;\n-  FP_HANDLE_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n+  FP_NEG_D (R, A);\n+  FP_PACK_RAW_D (r, R);\n \n   return r;\n }"}, {"sha": "0316105a5dc33dc3fd1d84b9666cc70731c6c4ff", "filename": "libgcc/soft-fp/negsf2.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fnegsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fnegsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fnegsf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,16 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SFtype __negsf2(SFtype a)\n+SFtype\n+__negsf2 (SFtype a)\n {\n-  FP_DECL_EX;\n-  FP_DECL_S(A); FP_DECL_S(R);\n+  FP_DECL_S (A);\n+  FP_DECL_S (R);\n   SFtype r;\n \n-  FP_UNPACK_S(A, a);\n-  FP_NEG_S(R, A);\n-  FP_PACK_S(r, R);\n-  FP_CLEAR_EXCEPTIONS;\n-  FP_HANDLE_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n+  FP_NEG_S (R, A);\n+  FP_PACK_RAW_S (r, R);\n \n   return r;\n }"}, {"sha": "8540af24d27adc19852b5d1090be8944f21950e4", "filename": "libgcc/soft-fp/negtf2.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fnegtf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fnegtf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fnegtf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,16 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-TFtype __negtf2(TFtype a)\n+TFtype\n+__negtf2 (TFtype a)\n {\n-  FP_DECL_EX;\n-  FP_DECL_Q(A); FP_DECL_Q(R);\n+  FP_DECL_Q (A);\n+  FP_DECL_Q (R);\n   TFtype r;\n \n-  FP_UNPACK_Q(A, a);\n-  FP_NEG_Q(R, A);\n-  FP_PACK_Q(r, R);\n-  FP_CLEAR_EXCEPTIONS;\n-  FP_HANDLE_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_NEG_Q (R, A);\n+  FP_PACK_RAW_Q (r, R);\n \n   return r;\n }"}, {"sha": "8ccb46a796223950f7a744a14d822502bf4832cc", "filename": "libgcc/soft-fp/op-1.h", "status": "modified", "additions": 229, "deletions": 178, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fop-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fop-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fop-1.h?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,103 +31,117 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #define _FP_FRAC_DECL_1(X)\t_FP_W_TYPE X##_f\n-#define _FP_FRAC_COPY_1(D,S)\t(D##_f = S##_f)\n-#define _FP_FRAC_SET_1(X,I)\t(X##_f = I)\n+#define _FP_FRAC_COPY_1(D, S)\t(D##_f = S##_f)\n+#define _FP_FRAC_SET_1(X, I)\t(X##_f = I)\n #define _FP_FRAC_HIGH_1(X)\t(X##_f)\n #define _FP_FRAC_LOW_1(X)\t(X##_f)\n-#define _FP_FRAC_WORD_1(X,w)\t(X##_f)\n-\n-#define _FP_FRAC_ADDI_1(X,I)\t(X##_f += I)\n-#define _FP_FRAC_SLL_1(X,N)\t\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    if (__builtin_constant_p(N) && (N) == 1)\t\\\n-      X##_f += X##_f;\t\t\t\t\\\n-    else\t\t\t\t\t\\\n-      X##_f <<= (N);\t\t\t\t\\\n-  } while (0)\n-#define _FP_FRAC_SRL_1(X,N)\t(X##_f >>= N)\n+#define _FP_FRAC_WORD_1(X, w)\t(X##_f)\n+\n+#define _FP_FRAC_ADDI_1(X, I)\t(X##_f += I)\n+#define _FP_FRAC_SLL_1(X, N)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (__builtin_constant_p (N) && (N) == 1)\t\\\n+\tX##_f += X##_f;\t\t\t\t\\\n+      else\t\t\t\t\t\\\n+\tX##_f <<= (N);\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+#define _FP_FRAC_SRL_1(X, N)\t(X##_f >>= N)\n \n /* Right shift with sticky-lsb.  */\n-#define _FP_FRAC_SRST_1(X,S,N,sz)\t__FP_FRAC_SRST_1(X##_f, S, N, sz)\n-#define _FP_FRAC_SRS_1(X,N,sz)\t__FP_FRAC_SRS_1(X##_f, N, sz)\n-\n-#define __FP_FRAC_SRST_1(X,S,N,sz)\t\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-  S = (__builtin_constant_p(N) && (N) == 1\t\t\\\n-       ? X & 1 : (X << (_FP_W_TYPE_SIZE - (N))) != 0);\t\\\n-  X = X >> (N);\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define __FP_FRAC_SRS_1(X,N,sz)\t\t\t\t\t\t\\\n-   (X = (X >> (N) | (__builtin_constant_p(N) && (N) == 1\t\t\\\n-\t\t     ? X & 1 : (X << (_FP_W_TYPE_SIZE - (N))) != 0)))\n-\n-#define _FP_FRAC_ADD_1(R,X,Y)\t(R##_f = X##_f + Y##_f)\n-#define _FP_FRAC_SUB_1(R,X,Y)\t(R##_f = X##_f - Y##_f)\n-#define _FP_FRAC_DEC_1(X,Y)\t(X##_f -= Y##_f)\n-#define _FP_FRAC_CLZ_1(z, X)\t__FP_CLZ(z, X##_f)\n+#define _FP_FRAC_SRST_1(X, S, N, sz)\t__FP_FRAC_SRST_1 (X##_f, S, N, sz)\n+#define _FP_FRAC_SRS_1(X, N, sz)\t__FP_FRAC_SRS_1 (X##_f, N, sz)\n+\n+#define __FP_FRAC_SRST_1(X, S, N, sz)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      S = (__builtin_constant_p (N) && (N) == 1\t\t\\\n+\t   ? X & 1\t\t\t\t\t\\\n+\t   : (X << (_FP_W_TYPE_SIZE - (N))) != 0);\t\\\n+      X = X >> (N);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define __FP_FRAC_SRS_1(X, N, sz)\t\t\t\t\\\n+  (X = (X >> (N) | (__builtin_constant_p (N) && (N) == 1\t\\\n+\t\t    ? X & 1\t\t\t\t\t\\\n+\t\t    : (X << (_FP_W_TYPE_SIZE - (N))) != 0)))\n+\n+#define _FP_FRAC_ADD_1(R, X, Y)\t(R##_f = X##_f + Y##_f)\n+#define _FP_FRAC_SUB_1(R, X, Y)\t(R##_f = X##_f - Y##_f)\n+#define _FP_FRAC_DEC_1(X, Y)\t(X##_f -= Y##_f)\n+#define _FP_FRAC_CLZ_1(z, X)\t__FP_CLZ (z, X##_f)\n \n /* Predicates */\n-#define _FP_FRAC_NEGP_1(X)\t((_FP_WS_TYPE)X##_f < 0)\n+#define _FP_FRAC_NEGP_1(X)\t((_FP_WS_TYPE) X##_f < 0)\n #define _FP_FRAC_ZEROP_1(X)\t(X##_f == 0)\n-#define _FP_FRAC_OVERP_1(fs,X)\t(X##_f & _FP_OVERFLOW_##fs)\n-#define _FP_FRAC_CLEAR_OVERP_1(fs,X)\t(X##_f &= ~_FP_OVERFLOW_##fs)\n+#define _FP_FRAC_OVERP_1(fs, X)\t(X##_f & _FP_OVERFLOW_##fs)\n+#define _FP_FRAC_CLEAR_OVERP_1(fs, X)\t(X##_f &= ~_FP_OVERFLOW_##fs)\n+#define _FP_FRAC_HIGHBIT_DW_1(fs, X)\t(X##_f & _FP_HIGHBIT_DW_##fs)\n #define _FP_FRAC_EQ_1(X, Y)\t(X##_f == Y##_f)\n #define _FP_FRAC_GE_1(X, Y)\t(X##_f >= Y##_f)\n #define _FP_FRAC_GT_1(X, Y)\t(X##_f > Y##_f)\n \n #define _FP_ZEROFRAC_1\t\t0\n #define _FP_MINFRAC_1\t\t1\n-#define _FP_MAXFRAC_1\t\t(~(_FP_WS_TYPE)0)\n+#define _FP_MAXFRAC_1\t\t(~(_FP_WS_TYPE) 0)\n \n /*\n  * Unpack the raw bits of a native fp value.  Do not classify or\n  * normalize the data.\n  */\n \n-#define _FP_UNPACK_RAW_1(fs, X, val)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs _flo; _flo.flt = (val);\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    X##_f = _flo.bits.frac;\t\t\t\t\t\\\n-    X##_e = _flo.bits.exp;\t\t\t\t\t\\\n-    X##_s = _flo.bits.sign;\t\t\t\t\t\\\n-  } while (0)\n-\n-#define _FP_UNPACK_RAW_1_P(fs, X, val)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs *_flo =\t\t\t\t\\\n-      (union _FP_UNION_##fs *)(val);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    X##_f = _flo->bits.frac;\t\t\t\t\t\\\n-    X##_e = _flo->bits.exp;\t\t\t\t\t\\\n-    X##_s = _flo->bits.sign;\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_UNPACK_RAW_1(fs, X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs _flo;\t\t\\\n+      _flo.flt = (val);\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+      X##_f = _flo.bits.frac;\t\t\t\\\n+      X##_e = _flo.bits.exp;\t\t\t\\\n+      X##_s = _flo.bits.sign;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_UNPACK_RAW_1_P(fs, X, val)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs *_flo = (union _FP_UNION_##fs *) (val);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      X##_f = _flo->bits.frac;\t\t\t\t\t\t\\\n+      X##_e = _flo->bits.exp;\t\t\t\t\t\t\\\n+      X##_s = _flo->bits.sign;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /*\n  * Repack the raw bits of a native fp value.\n  */\n \n-#define _FP_PACK_RAW_1(fs, val, X)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs _flo;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    _flo.bits.frac = X##_f;\t\t\t\t\t\\\n-    _flo.bits.exp  = X##_e;\t\t\t\t\t\\\n-    _flo.bits.sign = X##_s;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    (val) = _flo.flt;\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define _FP_PACK_RAW_1_P(fs, val, X)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs *_flo =\t\t\t\t\\\n-      (union _FP_UNION_##fs *)(val);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    _flo->bits.frac = X##_f;\t\t\t\t\t\\\n-    _flo->bits.exp  = X##_e;\t\t\t\t\t\\\n-    _flo->bits.sign = X##_s;\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_PACK_RAW_1(fs, val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs _flo;\t\t\\\n+\t\t\t\t\t\t\\\n+      _flo.bits.frac = X##_f;\t\t\t\\\n+      _flo.bits.exp  = X##_e;\t\t\t\\\n+      _flo.bits.sign = X##_s;\t\t\t\\\n+\t\t\t\t\t\t\\\n+      (val) = _flo.flt;\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_PACK_RAW_1_P(fs, val, X)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs *_flo = (union _FP_UNION_##fs *) (val);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      _flo->bits.frac = X##_f;\t\t\t\t\t\t\\\n+      _flo->bits.exp  = X##_e;\t\t\t\t\t\t\\\n+      _flo->bits.sign = X##_s;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n@@ -137,57 +151,86 @@ do {\t\t\t\t\t\t\t\\\n /* Basic.  Assuming the host word size is >= 2*FRACBITS, we can do the\n    multiplication immediately.  */\n \n+#define _FP_MUL_MEAT_DW_1_imm(wfracbits, R, X, Y)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      R##_f = X##_f * Y##_f;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n #define _FP_MUL_MEAT_1_imm(wfracbits, R, X, Y)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    R##_f = X##_f * Y##_f;\t\t\t\t\t\t\\\n-    /* Normalize since we know where the msb of the multiplicands\t\\\n-       were (bit B), we know that the msb of the of the product is\t\\\n-       at either 2B or 2B-1.  */\t\t\t\t\t\\\n-    _FP_FRAC_SRS_1(R, wfracbits-1, 2*wfracbits);\t\t\t\\\n-  } while (0)\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_MUL_MEAT_DW_1_imm (wfracbits, R, X, Y);\t\t\t\\\n+      /* Normalize since we know where the msb of the multiplicands\t\\\n+\t were (bit B), we know that the msb of the of the product is\t\\\n+\t at either 2B or 2B-1.  */\t\t\t\t\t\\\n+      _FP_FRAC_SRS_1 (R, wfracbits-1, 2*wfracbits);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Given a 1W * 1W => 2W primitive, do the extended multiplication.  */\n \n+#define _FP_MUL_MEAT_DW_1_wide(wfracbits, R, X, Y, doit)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      doit (R##_f1, R##_f0, X##_f, Y##_f);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n #define _FP_MUL_MEAT_1_wide(wfracbits, R, X, Y, doit)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_W_TYPE _Z_f0, _Z_f1;\t\t\t\t\t\t\\\n-    doit(_Z_f1, _Z_f0, X##_f, Y##_f);\t\t\t\t\t\\\n-    /* Normalize since we know where the msb of the multiplicands\t\\\n-       were (bit B), we know that the msb of the of the product is\t\\\n-       at either 2B or 2B-1.  */\t\t\t\t\t\\\n-    _FP_FRAC_SRS_2(_Z, wfracbits-1, 2*wfracbits);\t\t\t\\\n-    R##_f = _Z_f0;\t\t\t\t\t\t\t\\\n-  } while (0)\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_Z);\t\t\t\t\t\t\\\n+      _FP_MUL_MEAT_DW_1_wide (wfracbits, _Z, X, Y, doit);\t\t\\\n+      /* Normalize since we know where the msb of the multiplicands\t\\\n+\t were (bit B), we know that the msb of the of the product is\t\\\n+\t at either 2B or 2B-1.  */\t\t\t\t\t\\\n+      _FP_FRAC_SRS_2 (_Z, wfracbits-1, 2*wfracbits);\t\t\t\\\n+      R##_f = _Z_f0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Finally, a simple widening multiply algorithm.  What fun!  */\n \n-#define _FP_MUL_MEAT_1_hard(wfracbits, R, X, Y)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_W_TYPE _xh, _xl, _yh, _yl, _z_f0, _z_f1, _a_f0, _a_f1;\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* split the words in half */\t\t\t\t\t\\\n-    _xh = X##_f >> (_FP_W_TYPE_SIZE/2);\t\t\t\t\t\\\n-    _xl = X##_f & (((_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE/2)) - 1);\t\t\\\n-    _yh = Y##_f >> (_FP_W_TYPE_SIZE/2);\t\t\t\t\t\\\n-    _yl = Y##_f & (((_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE/2)) - 1);\t\t\\\n+#define _FP_MUL_MEAT_DW_1_hard(wfracbits, R, X, Y)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_W_TYPE _xh, _xl, _yh, _yl;\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_a);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    /* multiply the pieces */\t\t\t\t\t\t\\\n-    _z_f0 = _xl * _yl;\t\t\t\t\t\t\t\\\n-    _a_f0 = _xh * _yl;\t\t\t\t\t\t\t\\\n-    _a_f1 = _xl * _yh;\t\t\t\t\t\t\t\\\n-    _z_f1 = _xh * _yh;\t\t\t\t\t\t\t\\\n+      /* split the words in half */\t\t\t\t\t\\\n+      _xh = X##_f >> (_FP_W_TYPE_SIZE/2);\t\t\t\t\\\n+      _xl = X##_f & (((_FP_W_TYPE) 1 << (_FP_W_TYPE_SIZE/2)) - 1);\t\\\n+      _yh = Y##_f >> (_FP_W_TYPE_SIZE/2);\t\t\t\t\\\n+      _yl = Y##_f & (((_FP_W_TYPE) 1 << (_FP_W_TYPE_SIZE/2)) - 1);\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    /* reassemble into two full words */\t\t\t\t\\\n-    if ((_a_f0 += _a_f1) < _a_f1)\t\t\t\t\t\\\n-      _z_f1 += (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE/2);\t\t\t\\\n-    _a_f1 = _a_f0 >> (_FP_W_TYPE_SIZE/2);\t\t\t\t\\\n-    _a_f0 = _a_f0 << (_FP_W_TYPE_SIZE/2);\t\t\t\t\\\n-    _FP_FRAC_ADD_2(_z, _z, _a);\t\t\t\t\t\t\\\n+      /* multiply the pieces */\t\t\t\t\t\t\\\n+      R##_f0 = _xl * _yl;\t\t\t\t\t\t\\\n+      _a_f0 = _xh * _yl;\t\t\t\t\t\t\\\n+      _a_f1 = _xl * _yh;\t\t\t\t\t\t\\\n+      R##_f1 = _xh * _yh;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    /* normalize */\t\t\t\t\t\t\t\\\n-    _FP_FRAC_SRS_2(_z, wfracbits - 1, 2*wfracbits);\t\t\t\\\n-    R##_f = _z_f0;\t\t\t\t\t\t\t\\\n-  } while (0)\n+      /* reassemble into two full words */\t\t\t\t\\\n+      if ((_a_f0 += _a_f1) < _a_f1)\t\t\t\t\t\\\n+\tR##_f1 += (_FP_W_TYPE) 1 << (_FP_W_TYPE_SIZE/2);\t\t\\\n+      _a_f1 = _a_f0 >> (_FP_W_TYPE_SIZE/2);\t\t\t\t\\\n+      _a_f0 = _a_f0 << (_FP_W_TYPE_SIZE/2);\t\t\t\t\\\n+      _FP_FRAC_ADD_2 (R, R, _a);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_MUL_MEAT_1_hard(wfracbits, R, X, Y)\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_z);\t\t\t\t\\\n+      _FP_MUL_MEAT_DW_1_hard (wfracbits, _z, X, Y);\t\\\n+\t\t\t\t\t\t\t\\\n+      /* normalize */\t\t\t\t\t\\\n+      _FP_FRAC_SRS_2 (_z, wfracbits - 1, 2*wfracbits);\t\\\n+      R##_f = _z_f0;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n@@ -199,62 +242,68 @@ do {\t\t\t\t\t\t\t\\\n    C primitives or _FP_DIV_HELP_ldiv for the ISO function.  Which you\n    choose will depend on what the compiler does with divrem4.  */\n \n-#define _FP_DIV_MEAT_1_imm(fs, R, X, Y, doit)\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    _FP_W_TYPE _q, _r;\t\t\t\t\t\\\n-    X##_f <<= (X##_f < Y##_f\t\t\t\t\\\n-\t       ? R##_e--, _FP_WFRACBITS_##fs\t\t\\\n-\t       : _FP_WFRACBITS_##fs - 1);\t\t\\\n-    doit(_q, _r, X##_f, Y##_f);\t\t\t\t\\\n-    R##_f = _q | (_r != 0);\t\t\t\t\\\n-  } while (0)\n+#define _FP_DIV_MEAT_1_imm(fs, R, X, Y, doit)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_W_TYPE _q, _r;\t\t\t\\\n+      X##_f <<= (X##_f < Y##_f\t\t\t\\\n+\t\t ? R##_e--, _FP_WFRACBITS_##fs\t\\\n+\t\t : _FP_WFRACBITS_##fs - 1);\t\\\n+      doit (_q, _r, X##_f, Y##_f);\t\t\\\n+      R##_f = _q | (_r != 0);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* GCC's longlong.h defines a 2W / 1W => (1W,1W) primitive udiv_qrnnd\n    that may be useful in this situation.  This first is for a primitive\n    that requires normalization, the second for one that does not.  Look\n    for UDIV_NEEDS_NORMALIZATION to tell which your machine needs.  */\n \n #define _FP_DIV_MEAT_1_udiv_norm(fs, R, X, Y)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_W_TYPE _nh, _nl, _q, _r, _y;\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_W_TYPE _nh, _nl, _q, _r, _y;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    /* Normalize Y -- i.e. make the most significant bit set.  */\t\\\n-    _y = Y##_f << _FP_WFRACXBITS_##fs;\t\t\t\t\t\\\n+      /* Normalize Y -- i.e. make the most significant bit set.  */\t\\\n+      _y = Y##_f << _FP_WFRACXBITS_##fs;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    /* Shift X op correspondingly high, that is, up one full word.  */\t\\\n-    if (X##_f < Y##_f)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tR##_e--;\t\t\t\t\t\t\t\\\n-\t_nl = 0;\t\t\t\t\t\t\t\\\n-\t_nh = X##_f;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t_nl = X##_f << (_FP_W_TYPE_SIZE - 1);\t\t\t\t\\\n-\t_nh = X##_f >> 1;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n+      /* Shift X op correspondingly high, that is, up one full word.  */ \\\n+      if (X##_f < Y##_f)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  R##_e--;\t\t\t\t\t\t\t\\\n+\t  _nl = 0;\t\t\t\t\t\t\t\\\n+\t  _nh = X##_f;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _nl = X##_f << (_FP_W_TYPE_SIZE - 1);\t\t\t\t\\\n+\t  _nh = X##_f >> 1;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    udiv_qrnnd(_q, _r, _nh, _nl, _y);\t\t\t\t\t\\\n-    R##_f = _q | (_r != 0);\t\t\t\t\t\t\\\n-  } while (0)\n+      udiv_qrnnd (_q, _r, _nh, _nl, _y);\t\t\t\t\\\n+      R##_f = _q | (_r != 0);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n #define _FP_DIV_MEAT_1_udiv(fs, R, X, Y)\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    _FP_W_TYPE _nh, _nl, _q, _r;\t\t\t\\\n-    if (X##_f < Y##_f)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tR##_e--;\t\t\t\t\t\\\n-\t_nl = X##_f << _FP_WFRACBITS_##fs;\t\t\\\n-\t_nh = X##_f >> _FP_WFRACXBITS_##fs;\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\t_nl = X##_f << (_FP_WFRACBITS_##fs - 1);\t\\\n-\t_nh = X##_f >> (_FP_WFRACXBITS_##fs + 1);\t\\\n-      }\t\t\t\t\t\t\t\\\n-    udiv_qrnnd(_q, _r, _nh, _nl, Y##_f);\t\t\\\n-    R##_f = _q | (_r != 0);\t\t\t\t\\\n-  } while (0)\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      _FP_W_TYPE _nh, _nl, _q, _r;\t\t\t\\\n+      if (X##_f < Y##_f)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  R##_e--;\t\t\t\t\t\\\n+\t  _nl = X##_f << _FP_WFRACBITS_##fs;\t\t\\\n+\t  _nh = X##_f >> _FP_WFRACXBITS_##fs;\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  _nl = X##_f << (_FP_WFRACBITS_##fs - 1);\t\\\n+\t  _nh = X##_f >> (_FP_WFRACXBITS_##fs + 1);\t\\\n+\t}\t\t\t\t\t\t\\\n+      udiv_qrnnd (_q, _r, _nh, _nl, Y##_f);\t\t\\\n+      R##_f = _q | (_r != 0);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n@@ -263,27 +312,29 @@ do {\t\t\t\t\t\t\t\\\n  * should be added for those machines where division is fast.\n  */\n \n-#define _FP_SQRT_MEAT_1(R, S, T, X, q)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    while (q != _FP_WORK_ROUND)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-        T##_f = S##_f + q;\t\t\t\t\\\n-        if (T##_f <= X##_f)\t\t\t\t\\\n-          {\t\t\t\t\t\t\\\n-            S##_f = T##_f + q;\t\t\t\t\\\n-            X##_f -= T##_f;\t\t\t\t\\\n-            R##_f += q;\t\t\t\t\t\\\n-          }\t\t\t\t\t\t\\\n-        _FP_FRAC_SLL_1(X, 1);\t\t\t\t\\\n-        q >>= 1;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    if (X##_f)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tif (S##_f < X##_f)\t\t\t\t\\\n-\t  R##_f |= _FP_WORK_ROUND;\t\t\t\\\n-\tR##_f |= _FP_WORK_STICKY;\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_SQRT_MEAT_1(R, S, T, X, q)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      while (q != _FP_WORK_ROUND)\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  T##_f = S##_f + q;\t\t\t\\\n+\t  if (T##_f <= X##_f)\t\t\t\\\n+\t    {\t\t\t\t\t\\\n+\t      S##_f = T##_f + q;\t\t\\\n+\t      X##_f -= T##_f;\t\t\t\\\n+\t      R##_f += q;\t\t\t\\\n+\t    }\t\t\t\t\t\\\n+\t  _FP_FRAC_SLL_1 (X, 1);\t\t\\\n+\t  q >>= 1;\t\t\t\t\\\n+\t}\t\t\t\t\t\\\n+      if (X##_f)\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  if (S##_f < X##_f)\t\t\t\\\n+\t    R##_f |= _FP_WORK_ROUND;\t\t\\\n+\t  R##_f |= _FP_WORK_STICKY;\t\t\\\n+\t}\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /*\n  * Assembly/disassembly for converting to/from integral types."}, {"sha": "5ef4217de12a9d985f19a4c5cd565631d2065064", "filename": "libgcc/soft-fp/op-2.h", "status": "modified", "additions": 510, "deletions": 471, "changes": 981, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fop-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fop-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fop-2.h?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,109 +31,113 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #define _FP_FRAC_DECL_2(X)\t_FP_W_TYPE X##_f0, X##_f1\n-#define _FP_FRAC_COPY_2(D,S)\t(D##_f0 = S##_f0, D##_f1 = S##_f1)\n-#define _FP_FRAC_SET_2(X,I)\t__FP_FRAC_SET_2(X, I)\n+#define _FP_FRAC_COPY_2(D, S)\t(D##_f0 = S##_f0, D##_f1 = S##_f1)\n+#define _FP_FRAC_SET_2(X, I)\t__FP_FRAC_SET_2 (X, I)\n #define _FP_FRAC_HIGH_2(X)\t(X##_f1)\n #define _FP_FRAC_LOW_2(X)\t(X##_f0)\n-#define _FP_FRAC_WORD_2(X,w)\t(X##_f##w)\n-\n-#define _FP_FRAC_SLL_2(X,N)\t\t\t\t\t\t    \\\n-(void)(((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\t    \\\n-       ? ({\t\t\t\t\t\t\t\t    \\\n-\t    if (__builtin_constant_p(N) && (N) == 1)\t\t\t    \\\n-\t      {\t\t\t\t\t\t\t\t    \\\n-\t\tX##_f1 = X##_f1 + X##_f1 + (((_FP_WS_TYPE)(X##_f0)) < 0);   \\\n-\t\tX##_f0 += X##_f0;\t\t\t\t\t    \\\n-\t      }\t\t\t\t\t\t\t\t    \\\n-\t    else\t\t\t\t\t\t\t    \\\n-\t      {\t\t\t\t\t\t\t\t    \\\n-\t\tX##_f1 = X##_f1 << (N) | X##_f0 >> (_FP_W_TYPE_SIZE - (N)); \\\n-\t\tX##_f0 <<= (N);\t\t\t\t\t\t    \\\n-\t      }\t\t\t\t\t\t\t\t    \\\n-\t    0;\t\t\t\t\t\t\t\t    \\\n-\t  })\t\t\t\t\t\t\t\t    \\\n-       : ({\t\t\t\t\t\t\t\t    \\\n-\t    X##_f1 = X##_f0 << ((N) - _FP_W_TYPE_SIZE);\t\t\t    \\\n-\t    X##_f0 = 0;\t\t\t\t\t\t\t    \\\n-\t  }))\n-\n-\n-#define _FP_FRAC_SRL_2(X,N)\t\t\t\t\t\t\\\n-(void)(((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\t\\\n-       ? ({\t\t\t\t\t\t\t\t\\\n-\t    X##_f0 = X##_f0 >> (N) | X##_f1 << (_FP_W_TYPE_SIZE - (N));\t\\\n-\t    X##_f1 >>= (N);\t\t\t\t\t\t\\\n-\t  })\t\t\t\t\t\t\t\t\\\n-       : ({\t\t\t\t\t\t\t\t\\\n-\t    X##_f0 = X##_f1 >> ((N) - _FP_W_TYPE_SIZE);\t\t\t\\\n-\t    X##_f1 = 0;\t\t\t\t\t\t\t\\\n-\t  }))\n+#define _FP_FRAC_WORD_2(X, w)\t(X##_f##w)\n+\n+#define _FP_FRAC_SLL_2(X, N)\t\t\t\t\t\t\\\n+  (void) (((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\\\n+\t  ? ({\t\t\t\t\t\t\t\t\\\n+\t      if (__builtin_constant_p (N) && (N) == 1)\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  X##_f1 = X##_f1 + X##_f1 + (((_FP_WS_TYPE) (X##_f0)) < 0); \\\n+\t\t  X##_f0 += X##_f0;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  X##_f1 = X##_f1 << (N) | X##_f0 >> (_FP_W_TYPE_SIZE - (N)); \\\n+\t\t  X##_f0 <<= (N);\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      0;\t\t\t\t\t\t\t\\\n+\t    })\t\t\t\t\t\t\t\t\\\n+\t  : ({\t\t\t\t\t\t\t\t\\\n+\t      X##_f1 = X##_f0 << ((N) - _FP_W_TYPE_SIZE);\t\t\\\n+\t      X##_f0 = 0;\t\t\t\t\t\t\\\n+\t    }))\n+\n+\n+#define _FP_FRAC_SRL_2(X, N)\t\t\t\t\t\t\\\n+  (void) (((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\\\n+\t  ? ({\t\t\t\t\t\t\t\t\\\n+\t      X##_f0 = X##_f0 >> (N) | X##_f1 << (_FP_W_TYPE_SIZE - (N)); \\\n+\t      X##_f1 >>= (N);\t\t\t\t\t\t\\\n+\t    })\t\t\t\t\t\t\t\t\\\n+\t  : ({\t\t\t\t\t\t\t\t\\\n+\t      X##_f0 = X##_f1 >> ((N) - _FP_W_TYPE_SIZE);\t\t\\\n+\t      X##_f1 = 0;\t\t\t\t\t\t\\\n+\t    }))\n \n /* Right shift with sticky-lsb.  */\n-#define _FP_FRAC_SRST_2(X,S, N,sz)\t\t\t\t\t  \\\n-(void)(((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\t  \\\n-       ? ({\t\t\t\t\t\t\t\t  \\\n-\t    S = (__builtin_constant_p(N) && (N) == 1\t\t\t  \\\n-\t\t ? X##_f0 & 1\t\t\t\t\t\t  \\\n-\t\t : (X##_f0 << (_FP_W_TYPE_SIZE - (N))) != 0);\t\t  \\\n-\t    X##_f0 = (X##_f1 << (_FP_W_TYPE_SIZE - (N)) | X##_f0 >> (N)); \\\n-\t    X##_f1 >>= (N);\t\t\t\t\t\t  \\\n-\t  })\t\t\t\t\t\t\t\t  \\\n-       : ({\t\t\t\t\t\t\t\t  \\\n-\t    S = ((((N) == _FP_W_TYPE_SIZE\t\t\t\t  \\\n-\t\t   ? 0\t\t\t\t\t\t\t  \\\n-\t\t   : (X##_f1 << (2*_FP_W_TYPE_SIZE - (N))))\t\t  \\\n-\t\t  | X##_f0) != 0);\t\t\t\t\t  \\\n-\t    X##_f0 = (X##_f1 >> ((N) - _FP_W_TYPE_SIZE));\t\t  \\\n-\t    X##_f1 = 0;\t\t\t\t\t\t\t  \\\n-\t  }))\n-\n-#define _FP_FRAC_SRS_2(X,N,sz)\t\t\t\t\t\t  \\\n-(void)(((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\t  \\\n-       ? ({\t\t\t\t\t\t\t\t  \\\n-\t    X##_f0 = (X##_f1 << (_FP_W_TYPE_SIZE - (N)) | X##_f0 >> (N) | \\\n-\t\t      (__builtin_constant_p(N) && (N) == 1\t\t  \\\n-\t\t       ? X##_f0 & 1\t\t\t\t\t  \\\n-\t\t       : (X##_f0 << (_FP_W_TYPE_SIZE - (N))) != 0));\t  \\\n-\t    X##_f1 >>= (N);\t\t\t\t\t\t  \\\n-\t  })\t\t\t\t\t\t\t\t  \\\n-       : ({\t\t\t\t\t\t\t\t  \\\n-\t    X##_f0 = (X##_f1 >> ((N) - _FP_W_TYPE_SIZE) |\t\t  \\\n-\t\t      ((((N) == _FP_W_TYPE_SIZE\t\t\t\t  \\\n-\t\t\t ? 0\t\t\t\t\t\t  \\\n-\t\t\t : (X##_f1 << (2*_FP_W_TYPE_SIZE - (N))))\t  \\\n-\t\t\t| X##_f0) != 0));\t\t\t\t  \\\n-\t    X##_f1 = 0;\t\t\t\t\t\t\t  \\\n-\t  }))\n-\n-#define _FP_FRAC_ADDI_2(X,I)\t\\\n-  __FP_FRAC_ADDI_2(X##_f1, X##_f0, I)\n-\n-#define _FP_FRAC_ADD_2(R,X,Y)\t\\\n-  __FP_FRAC_ADD_2(R##_f1, R##_f0, X##_f1, X##_f0, Y##_f1, Y##_f0)\n-\n-#define _FP_FRAC_SUB_2(R,X,Y)\t\\\n-  __FP_FRAC_SUB_2(R##_f1, R##_f0, X##_f1, X##_f0, Y##_f1, Y##_f0)\n-\n-#define _FP_FRAC_DEC_2(X,Y)\t\\\n-  __FP_FRAC_DEC_2(X##_f1, X##_f0, Y##_f1, Y##_f0)\n-\n-#define _FP_FRAC_CLZ_2(R,X)\t\\\n-  do {\t\t\t\t\\\n-    if (X##_f1)\t\t\t\\\n-      __FP_CLZ(R,X##_f1);\t\\\n-    else \t\t\t\\\n-    {\t\t\t\t\\\n-      __FP_CLZ(R,X##_f0);\t\\\n-      R += _FP_W_TYPE_SIZE;\t\\\n-    }\t\t\t\t\\\n-  } while(0)\n+#define _FP_FRAC_SRST_2(X, S, N, sz)\t\t\t\t\t\\\n+  (void) (((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\\\n+\t  ? ({\t\t\t\t\t\t\t\t\\\n+\t      S = (__builtin_constant_p (N) && (N) == 1\t\t\t\\\n+\t\t   ? X##_f0 & 1\t\t\t\t\t\t\\\n+\t\t   : (X##_f0 << (_FP_W_TYPE_SIZE - (N))) != 0);\t\t\\\n+\t      X##_f0 = (X##_f1 << (_FP_W_TYPE_SIZE - (N)) | X##_f0 >> (N)); \\\n+\t      X##_f1 >>= (N);\t\t\t\t\t\t\\\n+\t    })\t\t\t\t\t\t\t\t\\\n+\t  : ({\t\t\t\t\t\t\t\t\\\n+\t      S = ((((N) == _FP_W_TYPE_SIZE\t\t\t\t\\\n+\t\t     ? 0\t\t\t\t\t\t\\\n+\t\t     : (X##_f1 << (2*_FP_W_TYPE_SIZE - (N))))\t\t\\\n+\t\t    | X##_f0) != 0);\t\t\t\t\t\\\n+\t      X##_f0 = (X##_f1 >> ((N) - _FP_W_TYPE_SIZE));\t\t\\\n+\t      X##_f1 = 0;\t\t\t\t\t\t\\\n+\t    }))\n+\n+#define _FP_FRAC_SRS_2(X, N, sz)\t\t\t\t\t\\\n+  (void) (((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\\\n+\t  ? ({\t\t\t\t\t\t\t\t\\\n+\t      X##_f0 = (X##_f1 << (_FP_W_TYPE_SIZE - (N)) | X##_f0 >> (N) \\\n+\t\t\t| (__builtin_constant_p (N) && (N) == 1\t\t\\\n+\t\t\t   ? X##_f0 & 1\t\t\t\t\t\\\n+\t\t\t   : (X##_f0 << (_FP_W_TYPE_SIZE - (N))) != 0)); \\\n+\t      X##_f1 >>= (N);\t\t\t\t\t\t\\\n+\t    })\t\t\t\t\t\t\t\t\\\n+\t  : ({\t\t\t\t\t\t\t\t\\\n+\t      X##_f0 = (X##_f1 >> ((N) - _FP_W_TYPE_SIZE)\t\t\\\n+\t\t\t| ((((N) == _FP_W_TYPE_SIZE\t\t\t\\\n+\t\t\t     ? 0\t\t\t\t\t\\\n+\t\t\t     : (X##_f1 << (2*_FP_W_TYPE_SIZE - (N))))\t\\\n+\t\t\t    | X##_f0) != 0));\t\t\t\t\\\n+\t      X##_f1 = 0;\t\t\t\t\t\t\\\n+\t    }))\n+\n+#define _FP_FRAC_ADDI_2(X, I)\t\\\n+  __FP_FRAC_ADDI_2 (X##_f1, X##_f0, I)\n+\n+#define _FP_FRAC_ADD_2(R, X, Y)\t\\\n+  __FP_FRAC_ADD_2 (R##_f1, R##_f0, X##_f1, X##_f0, Y##_f1, Y##_f0)\n+\n+#define _FP_FRAC_SUB_2(R, X, Y)\t\\\n+  __FP_FRAC_SUB_2 (R##_f1, R##_f0, X##_f1, X##_f0, Y##_f1, Y##_f0)\n+\n+#define _FP_FRAC_DEC_2(X, Y)\t\\\n+  __FP_FRAC_DEC_2 (X##_f1, X##_f0, Y##_f1, Y##_f0)\n+\n+#define _FP_FRAC_CLZ_2(R, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (X##_f1)\t\t\t\t\\\n+\t__FP_CLZ (R, X##_f1);\t\t\t\\\n+      else\t\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  __FP_CLZ (R, X##_f0);\t\t\t\\\n+\t  R += _FP_W_TYPE_SIZE;\t\t\t\\\n+\t}\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* Predicates */\n-#define _FP_FRAC_NEGP_2(X)\t((_FP_WS_TYPE)X##_f1 < 0)\n+#define _FP_FRAC_NEGP_2(X)\t((_FP_WS_TYPE) X##_f1 < 0)\n #define _FP_FRAC_ZEROP_2(X)\t((X##_f1 | X##_f0) == 0)\n-#define _FP_FRAC_OVERP_2(fs,X)\t(_FP_FRAC_HIGH_##fs(X) & _FP_OVERFLOW_##fs)\n-#define _FP_FRAC_CLEAR_OVERP_2(fs,X)\t(_FP_FRAC_HIGH_##fs(X) &= ~_FP_OVERFLOW_##fs)\n+#define _FP_FRAC_OVERP_2(fs, X)\t(_FP_FRAC_HIGH_##fs (X) & _FP_OVERFLOW_##fs)\n+#define _FP_FRAC_CLEAR_OVERP_2(fs, X)\t(_FP_FRAC_HIGH_##fs (X) &= ~_FP_OVERFLOW_##fs)\n+#define _FP_FRAC_HIGHBIT_DW_2(fs, X)\t\\\n+  (_FP_FRAC_HIGH_DW_##fs (X) & _FP_HIGHBIT_DW_##fs)\n #define _FP_FRAC_EQ_2(X, Y)\t(X##_f1 == Y##_f1 && X##_f0 == Y##_f0)\n #define _FP_FRAC_GT_2(X, Y)\t\\\n   (X##_f1 > Y##_f1 || (X##_f1 == Y##_f1 && X##_f0 > Y##_f0))\n@@ -142,57 +146,62 @@\n \n #define _FP_ZEROFRAC_2\t\t0, 0\n #define _FP_MINFRAC_2\t\t0, 1\n-#define _FP_MAXFRAC_2\t\t(~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0)\n+#define _FP_MAXFRAC_2\t\t(~(_FP_WS_TYPE) 0), (~(_FP_WS_TYPE) 0)\n \n /*\n  * Internals\n  */\n \n-#define __FP_FRAC_SET_2(X,I1,I0)\t(X##_f0 = I0, X##_f1 = I1)\n-\n-#define __FP_CLZ_2(R, xh, xl)\t\\\n-  do {\t\t\t\t\\\n-    if (xh)\t\t\t\\\n-      __FP_CLZ(R,xh);\t\t\\\n-    else \t\t\t\\\n-    {\t\t\t\t\\\n-      __FP_CLZ(R,xl);\t\t\\\n-      R += _FP_W_TYPE_SIZE;\t\\\n-    }\t\t\t\t\\\n-  } while(0)\n+#define __FP_FRAC_SET_2(X, I1, I0)\t(X##_f0 = I0, X##_f1 = I1)\n+\n+#define __FP_CLZ_2(R, xh, xl)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (xh)\t\t\t\t\t\\\n+\t__FP_CLZ (R, xh);\t\t\t\\\n+      else\t\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  __FP_CLZ (R, xl);\t\t\t\\\n+\t  R += _FP_W_TYPE_SIZE;\t\t\t\\\n+\t}\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n #if 0\n \n-#ifndef __FP_FRAC_ADDI_2\n-#define __FP_FRAC_ADDI_2(xh, xl, i)\t\\\n+# ifndef __FP_FRAC_ADDI_2\n+#  define __FP_FRAC_ADDI_2(xh, xl, i)\t\\\n   (xh += ((xl += i) < i))\n-#endif\n-#ifndef __FP_FRAC_ADD_2\n-#define __FP_FRAC_ADD_2(rh, rl, xh, xl, yh, yl)\t\\\n+# endif\n+# ifndef __FP_FRAC_ADD_2\n+#  define __FP_FRAC_ADD_2(rh, rl, xh, xl, yh, yl)\t\\\n   (rh = xh + yh + ((rl = xl + yl) < xl))\n-#endif\n-#ifndef __FP_FRAC_SUB_2\n-#define __FP_FRAC_SUB_2(rh, rl, xh, xl, yh, yl)\t\\\n+# endif\n+# ifndef __FP_FRAC_SUB_2\n+#  define __FP_FRAC_SUB_2(rh, rl, xh, xl, yh, yl)\t\\\n   (rh = xh - yh - ((rl = xl - yl) > xl))\n-#endif\n-#ifndef __FP_FRAC_DEC_2\n-#define __FP_FRAC_DEC_2(xh, xl, yh, yl)\t\\\n-  do {\t\t\t\t\t\\\n-    UWtype _t = xl;\t\t\t\\\n-    xh -= yh + ((xl -= yl) > _t);\t\\\n-  } while (0)\n-#endif\n+# endif\n+# ifndef __FP_FRAC_DEC_2\n+#  define __FP_FRAC_DEC_2(xh, xl, yh, yl)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      UWtype _t = xl;\t\t\t\t\\\n+      xh -= yh + ((xl -= yl) > _t);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+# endif\n \n #else\n \n-#undef __FP_FRAC_ADDI_2\n-#define __FP_FRAC_ADDI_2(xh, xl, i)\tadd_ssaaaa(xh, xl, xh, xl, 0, i)\n-#undef __FP_FRAC_ADD_2\n-#define __FP_FRAC_ADD_2\t\t\tadd_ssaaaa\n-#undef __FP_FRAC_SUB_2\n-#define __FP_FRAC_SUB_2\t\t\tsub_ddmmss\n-#undef __FP_FRAC_DEC_2\n-#define __FP_FRAC_DEC_2(xh, xl, yh, yl)\tsub_ddmmss(xh, xl, xh, xl, yh, yl)\n+# undef __FP_FRAC_ADDI_2\n+# define __FP_FRAC_ADDI_2(xh, xl, i)\tadd_ssaaaa (xh, xl, xh, xl, 0, i)\n+# undef __FP_FRAC_ADD_2\n+# define __FP_FRAC_ADD_2\t\tadd_ssaaaa\n+# undef __FP_FRAC_SUB_2\n+# define __FP_FRAC_SUB_2\t\tsub_ddmmss\n+# undef __FP_FRAC_DEC_2\n+# define __FP_FRAC_DEC_2(xh, xl, yh, yl)\t\\\n+  sub_ddmmss (xh, xl, xh, xl, yh, yl)\n \n #endif\n \n@@ -201,54 +210,61 @@\n  * normalize the data.\n  */\n \n-#define _FP_UNPACK_RAW_2(fs, X, val)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs _flo; _flo.flt = (val);\t\\\n-\t\t\t\t\t\t\t\\\n-    X##_f0 = _flo.bits.frac0;\t\t\t\t\\\n-    X##_f1 = _flo.bits.frac1;\t\t\t\t\\\n-    X##_e  = _flo.bits.exp;\t\t\t\t\\\n-    X##_s  = _flo.bits.sign;\t\t\t\t\\\n-  } while (0)\n-\n-#define _FP_UNPACK_RAW_2_P(fs, X, val)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs *_flo =\t\t\t\\\n-      (union _FP_UNION_##fs *)(val);\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-    X##_f0 = _flo->bits.frac0;\t\t\t\t\\\n-    X##_f1 = _flo->bits.frac1;\t\t\t\t\\\n-    X##_e  = _flo->bits.exp;\t\t\t\t\\\n-    X##_s  = _flo->bits.sign;\t\t\t\t\\\n-  } while (0)\n+#define _FP_UNPACK_RAW_2(fs, X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs _flo;\t\t\\\n+      _flo.flt = (val);\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+      X##_f0 = _flo.bits.frac0;\t\t\t\\\n+      X##_f1 = _flo.bits.frac1;\t\t\t\\\n+      X##_e  = _flo.bits.exp;\t\t\t\\\n+      X##_s  = _flo.bits.sign;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_UNPACK_RAW_2_P(fs, X, val)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs *_flo = (union _FP_UNION_##fs *) (val);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      X##_f0 = _flo->bits.frac0;\t\t\t\t\t\\\n+      X##_f1 = _flo->bits.frac1;\t\t\t\t\t\\\n+      X##_e  = _flo->bits.exp;\t\t\t\t\t\t\\\n+      X##_s  = _flo->bits.sign;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n  * Repack the raw bits of a native fp value.\n  */\n \n-#define _FP_PACK_RAW_2(fs, val, X)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs _flo;\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-    _flo.bits.frac0 = X##_f0;\t\t\t\t\\\n-    _flo.bits.frac1 = X##_f1;\t\t\t\t\\\n-    _flo.bits.exp   = X##_e;\t\t\t\t\\\n-    _flo.bits.sign  = X##_s;\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-    (val) = _flo.flt;\t\t\t\t\t\\\n-  } while (0)\n-\n-#define _FP_PACK_RAW_2_P(fs, val, X)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs *_flo =\t\t\t\\\n-      (union _FP_UNION_##fs *)(val);\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-    _flo->bits.frac0 = X##_f0;\t\t\t\t\\\n-    _flo->bits.frac1 = X##_f1;\t\t\t\t\\\n-    _flo->bits.exp   = X##_e;\t\t\t\t\\\n-    _flo->bits.sign  = X##_s;\t\t\t\t\\\n-  } while (0)\n+#define _FP_PACK_RAW_2(fs, val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs _flo;\t\t\\\n+\t\t\t\t\t\t\\\n+      _flo.bits.frac0 = X##_f0;\t\t\t\\\n+      _flo.bits.frac1 = X##_f1;\t\t\t\\\n+      _flo.bits.exp   = X##_e;\t\t\t\\\n+      _flo.bits.sign  = X##_s;\t\t\t\\\n+\t\t\t\t\t\t\\\n+      (val) = _flo.flt;\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_PACK_RAW_2_P(fs, val, X)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs *_flo = (union _FP_UNION_##fs *) (val);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      _flo->bits.frac0 = X##_f0;\t\t\t\t\t\\\n+      _flo->bits.frac1 = X##_f1;\t\t\t\t\t\\\n+      _flo->bits.exp   = X##_e;\t\t\t\t\t\t\\\n+      _flo->bits.sign  = X##_s;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n@@ -257,92 +273,128 @@\n \n /* Given a 1W * 1W => 2W primitive, do the extended multiplication.  */\n \n-#define _FP_MUL_MEAT_2_wide(wfracbits, R, X, Y, doit)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_FRAC_DECL_4(_z); _FP_FRAC_DECL_2(_b); _FP_FRAC_DECL_2(_c);\t\\\n+#define _FP_MUL_MEAT_DW_2_wide(wfracbits, R, X, Y, doit)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_b);\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_c);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      doit (_FP_FRAC_WORD_4 (R, 1), _FP_FRAC_WORD_4 (R, 0), X##_f0, Y##_f0); \\\n+      doit (_b_f1, _b_f0, X##_f0, Y##_f1);\t\t\t\t\\\n+      doit (_c_f1, _c_f0, X##_f1, Y##_f0);\t\t\t\t\\\n+      doit (_FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2), X##_f1, Y##_f1); \\\n \t\t\t\t\t\t\t\t\t\\\n-    doit(_FP_FRAC_WORD_4(_z,1), _FP_FRAC_WORD_4(_z,0), X##_f0, Y##_f0);\t\\\n-    doit(_b_f1, _b_f0, X##_f0, Y##_f1);\t\t\t\t\t\\\n-    doit(_c_f1, _c_f0, X##_f1, Y##_f0);\t\t\t\t\t\\\n-    doit(_FP_FRAC_WORD_4(_z,3), _FP_FRAC_WORD_4(_z,2), X##_f1, Y##_f1);\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2),\t\\\n+\t\t       _FP_FRAC_WORD_4 (R, 1), 0, _b_f1, _b_f0,\t\t\\\n+\t\t       _FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2),\t\\\n+\t\t       _FP_FRAC_WORD_4 (R, 1));\t\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2),\t\\\n+\t\t       _FP_FRAC_WORD_4 (R, 1), 0, _c_f1, _c_f0,\t\t\\\n+\t\t       _FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2),\t\\\n+\t\t       _FP_FRAC_WORD_4 (R, 1));\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_MUL_MEAT_2_wide(wfracbits, R, X, Y, doit)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_4 (_z);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n-\t\t    _FP_FRAC_WORD_4(_z,1), 0, _b_f1, _b_f0,\t\t\\\n-\t\t    _FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n-\t\t    _FP_FRAC_WORD_4(_z,1));\t\t\t\t\\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n-\t\t    _FP_FRAC_WORD_4(_z,1), 0, _c_f1, _c_f0,\t\t\\\n-\t\t    _FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n-\t\t    _FP_FRAC_WORD_4(_z,1));\t\t\t\t\\\n+      _FP_MUL_MEAT_DW_2_wide (wfracbits, _z, X, Y, doit);\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    /* Normalize since we know where the msb of the multiplicands\t\\\n-       were (bit B), we know that the msb of the of the product is\t\\\n-       at either 2B or 2B-1.  */\t\t\t\t\t\\\n-    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);\t\t\t\\\n-    R##_f0 = _FP_FRAC_WORD_4(_z,0);\t\t\t\t\t\\\n-    R##_f1 = _FP_FRAC_WORD_4(_z,1);\t\t\t\t\t\\\n-  } while (0)\n+      /* Normalize since we know where the msb of the multiplicands\t\\\n+\t were (bit B), we know that the msb of the of the product is\t\\\n+\t at either 2B or 2B-1.  */\t\t\t\t\t\\\n+      _FP_FRAC_SRS_4 (_z, wfracbits-1, 2*wfracbits);\t\t\t\\\n+      R##_f0 = _FP_FRAC_WORD_4 (_z, 0);\t\t\t\t\t\\\n+      R##_f1 = _FP_FRAC_WORD_4 (_z, 1);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Given a 1W * 1W => 2W primitive, do the extended multiplication.\n    Do only 3 multiplications instead of four. This one is for machines\n    where multiplication is much more expensive than subtraction.  */\n \n-#define _FP_MUL_MEAT_2_wide_3mul(wfracbits, R, X, Y, doit)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_FRAC_DECL_4(_z); _FP_FRAC_DECL_2(_b); _FP_FRAC_DECL_2(_c);\t\\\n-    _FP_W_TYPE _d;\t\t\t\t\t\t\t\\\n-    int _c1, _c2;\t\t\t\t\t\t\t\\\n+#define _FP_MUL_MEAT_DW_2_wide_3mul(wfracbits, R, X, Y, doit)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_b);\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_c);\t\t\t\t\t\t\\\n+      _FP_W_TYPE _d;\t\t\t\t\t\t\t\\\n+      int _c1, _c2;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    _b_f0 = X##_f0 + X##_f1;\t\t\t\t\t\t\\\n-    _c1 = _b_f0 < X##_f0;\t\t\t\t\t\t\\\n-    _b_f1 = Y##_f0 + Y##_f1;\t\t\t\t\t\t\\\n-    _c2 = _b_f1 < Y##_f0;\t\t\t\t\t\t\\\n-    doit(_d, _FP_FRAC_WORD_4(_z,0), X##_f0, Y##_f0);\t\t\t\\\n-    doit(_FP_FRAC_WORD_4(_z,2), _FP_FRAC_WORD_4(_z,1), _b_f0, _b_f1);\t\\\n-    doit(_c_f1, _c_f0, X##_f1, Y##_f1);\t\t\t\t\t\\\n+      _b_f0 = X##_f0 + X##_f1;\t\t\t\t\t\t\\\n+      _c1 = _b_f0 < X##_f0;\t\t\t\t\t\t\\\n+      _b_f1 = Y##_f0 + Y##_f1;\t\t\t\t\t\t\\\n+      _c2 = _b_f1 < Y##_f0;\t\t\t\t\t\t\\\n+      doit (_d, _FP_FRAC_WORD_4 (R, 0), X##_f0, Y##_f0);\t\t\\\n+      doit (_FP_FRAC_WORD_4 (R, 2), _FP_FRAC_WORD_4 (R, 1), _b_f0, _b_f1); \\\n+      doit (_c_f1, _c_f0, X##_f1, Y##_f1);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    _b_f0 &= -_c2;\t\t\t\t\t\t\t\\\n-    _b_f1 &= -_c1;\t\t\t\t\t\t\t\\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n-\t\t    _FP_FRAC_WORD_4(_z,1), (_c1 & _c2), 0, _d,\t\t\\\n-\t\t    0, _FP_FRAC_WORD_4(_z,2), _FP_FRAC_WORD_4(_z,1));\t\\\n-    __FP_FRAC_ADDI_2(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n-\t\t     _b_f0);\t\t\t\t\t\t\\\n-    __FP_FRAC_ADDI_2(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n-\t\t     _b_f1);\t\t\t\t\t\t\\\n-    __FP_FRAC_DEC_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n-\t\t    _FP_FRAC_WORD_4(_z,1),\t\t\t\t\\\n-\t\t    0, _d, _FP_FRAC_WORD_4(_z,0));\t\t\t\\\n-    __FP_FRAC_DEC_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n-\t\t    _FP_FRAC_WORD_4(_z,1), 0, _c_f1, _c_f0);\t\t\\\n-    __FP_FRAC_ADD_2(_FP_FRAC_WORD_4(_z,3), _FP_FRAC_WORD_4(_z,2),\t\\\n-\t\t    _c_f1, _c_f0,\t\t\t\t\t\\\n-\t\t    _FP_FRAC_WORD_4(_z,3), _FP_FRAC_WORD_4(_z,2));\t\\\n+      _b_f0 &= -_c2;\t\t\t\t\t\t\t\\\n+      _b_f1 &= -_c1;\t\t\t\t\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2),\t\\\n+\t\t       _FP_FRAC_WORD_4 (R, 1), (_c1 & _c2), 0, _d,\t\\\n+\t\t       0, _FP_FRAC_WORD_4 (R, 2), _FP_FRAC_WORD_4 (R, 1)); \\\n+      __FP_FRAC_ADDI_2 (_FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2),\t\\\n+\t\t\t_b_f0);\t\t\t\t\t\t\\\n+      __FP_FRAC_ADDI_2 (_FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2),\t\\\n+\t\t\t_b_f1);\t\t\t\t\t\t\\\n+      __FP_FRAC_DEC_3 (_FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2),\t\\\n+\t\t       _FP_FRAC_WORD_4 (R, 1),\t\t\t\t\\\n+\t\t       0, _d, _FP_FRAC_WORD_4 (R, 0));\t\t\t\\\n+      __FP_FRAC_DEC_3 (_FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2),\t\\\n+\t\t       _FP_FRAC_WORD_4 (R, 1), 0, _c_f1, _c_f0);\t\\\n+      __FP_FRAC_ADD_2 (_FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2),\t\\\n+\t\t       _c_f1, _c_f0,\t\t\t\t\t\\\n+\t\t       _FP_FRAC_WORD_4 (R, 3), _FP_FRAC_WORD_4 (R, 2));\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_MUL_MEAT_2_wide_3mul(wfracbits, R, X, Y, doit)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_4 (_z);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    /* Normalize since we know where the msb of the multiplicands\t\\\n-       were (bit B), we know that the msb of the of the product is\t\\\n-       at either 2B or 2B-1.  */\t\t\t\t\t\\\n-    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);\t\t\t\\\n-    R##_f0 = _FP_FRAC_WORD_4(_z,0);\t\t\t\t\t\\\n-    R##_f1 = _FP_FRAC_WORD_4(_z,1);\t\t\t\t\t\\\n-  } while (0)\n+      _FP_MUL_MEAT_DW_2_wide_3mul (wfracbits, _z, X, Y, doit);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Normalize since we know where the msb of the multiplicands\t\\\n+\t were (bit B), we know that the msb of the of the product is\t\\\n+\t at either 2B or 2B-1.  */\t\t\t\t\t\\\n+      _FP_FRAC_SRS_4 (_z, wfracbits-1, 2*wfracbits);\t\t\t\\\n+      R##_f0 = _FP_FRAC_WORD_4 (_z, 0);\t\t\t\t\t\\\n+      R##_f1 = _FP_FRAC_WORD_4 (_z, 1);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_MUL_MEAT_DW_2_gmp(wfracbits, R, X, Y)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      _FP_W_TYPE _x[2], _y[2];\t\t\t\t\\\n+      _x[0] = X##_f0;\t\t\t\t\t\\\n+      _x[1] = X##_f1;\t\t\t\t\t\\\n+      _y[0] = Y##_f0;\t\t\t\t\t\\\n+      _y[1] = Y##_f1;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      mpn_mul_n (R##_f, _x, _y, 2);\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n #define _FP_MUL_MEAT_2_gmp(wfracbits, R, X, Y)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_FRAC_DECL_4(_z);\t\t\t\t\t\t\\\n-    _FP_W_TYPE _x[2], _y[2];\t\t\t\t\t\t\\\n-    _x[0] = X##_f0; _x[1] = X##_f1;\t\t\t\t\t\\\n-    _y[0] = Y##_f0; _y[1] = Y##_f1;\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_4 (_z);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    mpn_mul_n(_z_f, _x, _y, 2);\t\t\t\t\t\t\\\n+      _FP_MUL_MEAT_DW_2_gmp (wfracbits, _z, X, Y);\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    /* Normalize since we know where the msb of the multiplicands\t\\\n-       were (bit B), we know that the msb of the of the product is\t\\\n-       at either 2B or 2B-1.  */\t\t\t\t\t\\\n-    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);\t\t\t\\\n-    R##_f0 = _z_f[0];\t\t\t\t\t\t\t\\\n-    R##_f1 = _z_f[1];\t\t\t\t\t\t\t\\\n-  } while (0)\n+      /* Normalize since we know where the msb of the multiplicands\t\\\n+\t were (bit B), we know that the msb of the of the product is\t\\\n+\t at either 2B or 2B-1.  */\t\t\t\t\t\\\n+      _FP_FRAC_SRS_4 (_z, wfracbits-1, 2*wfracbits);\t\t\t\\\n+      R##_f0 = _z_f[0];\t\t\t\t\t\t\t\\\n+      R##_f1 = _z_f[1];\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Do at most 120x120=240 bits multiplication using double floating\n    point multiplication.  This is useful if floating point\n@@ -353,190 +405,173 @@\n    SETFETZ is a macro which will disable all FPU exceptions and set rounding\n    towards zero,  RESETFE should optionally reset it back.  */\n \n-#define _FP_MUL_MEAT_2_120_240_double(wfracbits, R, X, Y, setfetz, resetfe)\t\\\n-  do {\t\t\t\t\t\t\t\t\t\t\\\n-    static const double _const[] = {\t\t\t\t\t\t\\\n-      /* 2^-24 */ 5.9604644775390625e-08,\t\t\t\t\t\\\n-      /* 2^-48 */ 3.5527136788005009e-15,\t\t\t\t\t\\\n-      /* 2^-72 */ 2.1175823681357508e-22,\t\t\t\t\t\\\n-      /* 2^-96 */ 1.2621774483536189e-29,\t\t\t\t\t\\\n-      /* 2^28 */ 2.68435456e+08,\t\t\t\t\t\t\\\n-      /* 2^4 */ 1.600000e+01,\t\t\t\t\t\t\t\\\n-      /* 2^-20 */ 9.5367431640625e-07,\t\t\t\t\t\t\\\n-      /* 2^-44 */ 5.6843418860808015e-14,\t\t\t\t\t\\\n-      /* 2^-68 */ 3.3881317890172014e-21,\t\t\t\t\t\\\n-      /* 2^-92 */ 2.0194839173657902e-28,\t\t\t\t\t\\\n-      /* 2^-116 */ 1.2037062152420224e-35};\t\t\t\t\t\\\n-    double _a240, _b240, _c240, _d240, _e240, _f240, \t\t\t\t\\\n-\t   _g240, _h240, _i240, _j240, _k240;\t\t\t\t\t\\\n-    union { double d; UDItype i; } _l240, _m240, _n240, _o240,\t\t\t\\\n-\t\t\t\t   _p240, _q240, _r240, _s240;\t\t\t\\\n-    UDItype _t240, _u240, _v240, _w240, _x240, _y240 = 0;\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\t\\\n-    if (wfracbits < 106 || wfracbits > 120)\t\t\t\t\t\\\n-      abort();\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\t\\\n-    setfetz;\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\t\\\n-    _e240 = (double)(long)(X##_f0 & 0xffffff);\t\t\t\t\t\\\n-    _j240 = (double)(long)(Y##_f0 & 0xffffff);\t\t\t\t\t\\\n-    _d240 = (double)(long)((X##_f0 >> 24) & 0xffffff);\t\t\t\t\\\n-    _i240 = (double)(long)((Y##_f0 >> 24) & 0xffffff);\t\t\t\t\\\n-    _c240 = (double)(long)(((X##_f1 << 16) & 0xffffff) | (X##_f0 >> 48));\t\\\n-    _h240 = (double)(long)(((Y##_f1 << 16) & 0xffffff) | (Y##_f0 >> 48));\t\\\n-    _b240 = (double)(long)((X##_f1 >> 8) & 0xffffff);\t\t\t\t\\\n-    _g240 = (double)(long)((Y##_f1 >> 8) & 0xffffff);\t\t\t\t\\\n-    _a240 = (double)(long)(X##_f1 >> 32);\t\t\t\t\t\\\n-    _f240 = (double)(long)(Y##_f1 >> 32);\t\t\t\t\t\\\n-    _e240 *= _const[3];\t\t\t\t\t\t\t\t\\\n-    _j240 *= _const[3];\t\t\t\t\t\t\t\t\\\n-    _d240 *= _const[2];\t\t\t\t\t\t\t\t\\\n-    _i240 *= _const[2];\t\t\t\t\t\t\t\t\\\n-    _c240 *= _const[1];\t\t\t\t\t\t\t\t\\\n-    _h240 *= _const[1];\t\t\t\t\t\t\t\t\\\n-    _b240 *= _const[0];\t\t\t\t\t\t\t\t\\\n-    _g240 *= _const[0];\t\t\t\t\t\t\t\t\\\n-    _s240.d =\t\t\t\t\t\t\t      _e240*_j240;\\\n-    _r240.d =\t\t\t\t\t\t_d240*_j240 + _e240*_i240;\\\n-    _q240.d =\t\t\t\t  _c240*_j240 + _d240*_i240 + _e240*_h240;\\\n-    _p240.d =\t\t    _b240*_j240 + _c240*_i240 + _d240*_h240 + _e240*_g240;\\\n-    _o240.d = _a240*_j240 + _b240*_i240 + _c240*_h240 + _d240*_g240 + _e240*_f240;\\\n-    _n240.d = _a240*_i240 + _b240*_h240 + _c240*_g240 + _d240*_f240;\t\t\\\n-    _m240.d = _a240*_h240 + _b240*_g240 + _c240*_f240;\t\t\t\t\\\n-    _l240.d = _a240*_g240 + _b240*_f240;\t\t\t\t\t\\\n-    _k240 =   _a240*_f240;\t\t\t\t\t\t\t\\\n-    _r240.d += _s240.d;\t\t\t\t\t\t\t\t\\\n-    _q240.d += _r240.d;\t\t\t\t\t\t\t\t\\\n-    _p240.d += _q240.d;\t\t\t\t\t\t\t\t\\\n-    _o240.d += _p240.d;\t\t\t\t\t\t\t\t\\\n-    _n240.d += _o240.d;\t\t\t\t\t\t\t\t\\\n-    _m240.d += _n240.d;\t\t\t\t\t\t\t\t\\\n-    _l240.d += _m240.d;\t\t\t\t\t\t\t\t\\\n-    _k240 += _l240.d;\t\t\t\t\t\t\t\t\\\n-    _s240.d -= ((_const[10]+_s240.d)-_const[10]);\t\t\t\t\\\n-    _r240.d -= ((_const[9]+_r240.d)-_const[9]);\t\t\t\t\t\\\n-    _q240.d -= ((_const[8]+_q240.d)-_const[8]);\t\t\t\t\t\\\n-    _p240.d -= ((_const[7]+_p240.d)-_const[7]);\t\t\t\t\t\\\n-    _o240.d += _const[7];\t\t\t\t\t\t\t\\\n-    _n240.d += _const[6];\t\t\t\t\t\t\t\\\n-    _m240.d += _const[5];\t\t\t\t\t\t\t\\\n-    _l240.d += _const[4];\t\t\t\t\t\t\t\\\n-    if (_s240.d != 0.0) _y240 = 1;\t\t\t\t\t\t\\\n-    if (_r240.d != 0.0) _y240 = 1;\t\t\t\t\t\t\\\n-    if (_q240.d != 0.0) _y240 = 1;\t\t\t\t\t\t\\\n-    if (_p240.d != 0.0) _y240 = 1;\t\t\t\t\t\t\\\n-    _t240 = (DItype)_k240;\t\t\t\t\t\t\t\\\n-    _u240 = _l240.i;\t\t\t\t\t\t\t\t\\\n-    _v240 = _m240.i;\t\t\t\t\t\t\t\t\\\n-    _w240 = _n240.i;\t\t\t\t\t\t\t\t\\\n-    _x240 = _o240.i;\t\t\t\t\t\t\t\t\\\n-    R##_f1 = (_t240 << (128 - (wfracbits - 1)))\t\t\t\t\t\\\n-\t     | ((_u240 & 0xffffff) >> ((wfracbits - 1) - 104));\t\t\t\\\n-    R##_f0 = ((_u240 & 0xffffff) << (168 - (wfracbits - 1)))\t\t\t\\\n-\t     | ((_v240 & 0xffffff) << (144 - (wfracbits - 1)))\t\t\t\\\n-\t     | ((_w240 & 0xffffff) << (120 - (wfracbits - 1)))\t\t\t\\\n-\t     | ((_x240 & 0xffffff) >> ((wfracbits - 1) - 96))\t\t\t\\\n-\t     | _y240;\t\t\t\t\t\t\t\t\\\n-    resetfe;\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_MUL_MEAT_2_120_240_double(wfracbits, R, X, Y, setfetz, resetfe) \\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static const double _const[] =\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* 2^-24 */ 5.9604644775390625e-08,\t\t\t\t\\\n+\t  /* 2^-48 */ 3.5527136788005009e-15,\t\t\t\t\\\n+\t  /* 2^-72 */ 2.1175823681357508e-22,\t\t\t\t\\\n+\t  /* 2^-96 */ 1.2621774483536189e-29,\t\t\t\t\\\n+\t  /* 2^28 */ 2.68435456e+08,\t\t\t\t\t\\\n+\t  /* 2^4 */ 1.600000e+01,\t\t\t\t\t\\\n+\t  /* 2^-20 */ 9.5367431640625e-07,\t\t\t\t\\\n+\t  /* 2^-44 */ 5.6843418860808015e-14,\t\t\t\t\\\n+\t  /* 2^-68 */ 3.3881317890172014e-21,\t\t\t\t\\\n+\t  /* 2^-92 */ 2.0194839173657902e-28,\t\t\t\t\\\n+\t  /* 2^-116 */ 1.2037062152420224e-35\t\t\t\t\\\n+\t};\t\t\t\t\t\t\t\t\\\n+      double _a240, _b240, _c240, _d240, _e240, _f240,\t\t\t\\\n+\t_g240, _h240, _i240, _j240, _k240;\t\t\t\t\\\n+      union { double d; UDItype i; } _l240, _m240, _n240, _o240,\t\\\n+\t\t\t\t       _p240, _q240, _r240, _s240;\t\\\n+      UDItype _t240, _u240, _v240, _w240, _x240, _y240 = 0;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (wfracbits < 106 || wfracbits > 120)\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      setfetz;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      _e240 = (double) (long) (X##_f0 & 0xffffff);\t\t\t\\\n+      _j240 = (double) (long) (Y##_f0 & 0xffffff);\t\t\t\\\n+      _d240 = (double) (long) ((X##_f0 >> 24) & 0xffffff);\t\t\\\n+      _i240 = (double) (long) ((Y##_f0 >> 24) & 0xffffff);\t\t\\\n+      _c240 = (double) (long) (((X##_f1 << 16) & 0xffffff) | (X##_f0 >> 48)); \\\n+      _h240 = (double) (long) (((Y##_f1 << 16) & 0xffffff) | (Y##_f0 >> 48)); \\\n+      _b240 = (double) (long) ((X##_f1 >> 8) & 0xffffff);\t\t\\\n+      _g240 = (double) (long) ((Y##_f1 >> 8) & 0xffffff);\t\t\\\n+      _a240 = (double) (long) (X##_f1 >> 32);\t\t\t\t\\\n+      _f240 = (double) (long) (Y##_f1 >> 32);\t\t\t\t\\\n+      _e240 *= _const[3];\t\t\t\t\t\t\\\n+      _j240 *= _const[3];\t\t\t\t\t\t\\\n+      _d240 *= _const[2];\t\t\t\t\t\t\\\n+      _i240 *= _const[2];\t\t\t\t\t\t\\\n+      _c240 *= _const[1];\t\t\t\t\t\t\\\n+      _h240 *= _const[1];\t\t\t\t\t\t\\\n+      _b240 *= _const[0];\t\t\t\t\t\t\\\n+      _g240 *= _const[0];\t\t\t\t\t\t\\\n+      _s240.d =\t\t\t\t\t\t\t      _e240*_j240; \\\n+      _r240.d =\t\t\t\t\t\t_d240*_j240 + _e240*_i240; \\\n+      _q240.d =\t\t\t\t  _c240*_j240 + _d240*_i240 + _e240*_h240; \\\n+      _p240.d =\t\t    _b240*_j240 + _c240*_i240 + _d240*_h240 + _e240*_g240; \\\n+      _o240.d = _a240*_j240 + _b240*_i240 + _c240*_h240 + _d240*_g240 + _e240*_f240; \\\n+      _n240.d = _a240*_i240 + _b240*_h240 + _c240*_g240 + _d240*_f240;\t\\\n+      _m240.d = _a240*_h240 + _b240*_g240 + _c240*_f240;\t\t\\\n+      _l240.d = _a240*_g240 + _b240*_f240;\t\t\t\t\\\n+      _k240 =   _a240*_f240;\t\t\t\t\t\t\\\n+      _r240.d += _s240.d;\t\t\t\t\t\t\\\n+      _q240.d += _r240.d;\t\t\t\t\t\t\\\n+      _p240.d += _q240.d;\t\t\t\t\t\t\\\n+      _o240.d += _p240.d;\t\t\t\t\t\t\\\n+      _n240.d += _o240.d;\t\t\t\t\t\t\\\n+      _m240.d += _n240.d;\t\t\t\t\t\t\\\n+      _l240.d += _m240.d;\t\t\t\t\t\t\\\n+      _k240 += _l240.d;\t\t\t\t\t\t\t\\\n+      _s240.d -= ((_const[10]+_s240.d)-_const[10]);\t\t\t\\\n+      _r240.d -= ((_const[9]+_r240.d)-_const[9]);\t\t\t\\\n+      _q240.d -= ((_const[8]+_q240.d)-_const[8]);\t\t\t\\\n+      _p240.d -= ((_const[7]+_p240.d)-_const[7]);\t\t\t\\\n+      _o240.d += _const[7];\t\t\t\t\t\t\\\n+      _n240.d += _const[6];\t\t\t\t\t\t\\\n+      _m240.d += _const[5];\t\t\t\t\t\t\\\n+      _l240.d += _const[4];\t\t\t\t\t\t\\\n+      if (_s240.d != 0.0)\t\t\t\t\t\t\\\n+\t_y240 = 1;\t\t\t\t\t\t\t\\\n+      if (_r240.d != 0.0)\t\t\t\t\t\t\\\n+\t_y240 = 1;\t\t\t\t\t\t\t\\\n+      if (_q240.d != 0.0)\t\t\t\t\t\t\\\n+\t_y240 = 1;\t\t\t\t\t\t\t\\\n+      if (_p240.d != 0.0)\t\t\t\t\t\t\\\n+\t_y240 = 1;\t\t\t\t\t\t\t\\\n+      _t240 = (DItype) _k240;\t\t\t\t\t\t\\\n+      _u240 = _l240.i;\t\t\t\t\t\t\t\\\n+      _v240 = _m240.i;\t\t\t\t\t\t\t\\\n+      _w240 = _n240.i;\t\t\t\t\t\t\t\\\n+      _x240 = _o240.i;\t\t\t\t\t\t\t\\\n+      R##_f1 = ((_t240 << (128 - (wfracbits - 1)))\t\t\t\\\n+\t\t| ((_u240 & 0xffffff) >> ((wfracbits - 1) - 104)));\t\\\n+      R##_f0 = (((_u240 & 0xffffff) << (168 - (wfracbits - 1)))\t\t\\\n+\t\t| ((_v240 & 0xffffff) << (144 - (wfracbits - 1)))\t\\\n+\t\t| ((_w240 & 0xffffff) << (120 - (wfracbits - 1)))\t\\\n+\t\t| ((_x240 & 0xffffff) >> ((wfracbits - 1) - 96))\t\\\n+\t\t| _y240);\t\t\t\t\t\t\\\n+      resetfe;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /*\n  * Division algorithms:\n  */\n \n #define _FP_DIV_MEAT_2_udiv(fs, R, X, Y)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_W_TYPE _n_f2, _n_f1, _n_f0, _r_f1, _r_f0, _m_f1, _m_f0;\t\t\\\n-    if (_FP_FRAC_GT_2(X, Y))\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t_n_f2 = X##_f1 >> 1;\t\t\t\t\t\t\\\n-\t_n_f1 = X##_f1 << (_FP_W_TYPE_SIZE - 1) | X##_f0 >> 1;\t\t\\\n-\t_n_f0 = X##_f0 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tR##_e--;\t\t\t\t\t\t\t\\\n-\t_n_f2 = X##_f1;\t\t\t\t\t\t\t\\\n-\t_n_f1 = X##_f0;\t\t\t\t\t\t\t\\\n-\t_n_f0 = 0;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* Normalize, i.e. make the most significant bit of the \t\t\\\n-       denominator set. */\t\t\t\t\t\t\\\n-    _FP_FRAC_SLL_2(Y, _FP_WFRACXBITS_##fs);\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_W_TYPE _n_f2, _n_f1, _n_f0, _r_f1, _r_f0, _m_f1, _m_f0;\t\\\n+      if (_FP_FRAC_GE_2 (X, Y))\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _n_f2 = X##_f1 >> 1;\t\t\t\t\t\t\\\n+\t  _n_f1 = X##_f1 << (_FP_W_TYPE_SIZE - 1) | X##_f0 >> 1;\t\\\n+\t  _n_f0 = X##_f0 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  R##_e--;\t\t\t\t\t\t\t\\\n+\t  _n_f2 = X##_f1;\t\t\t\t\t\t\\\n+\t  _n_f1 = X##_f0;\t\t\t\t\t\t\\\n+\t  _n_f0 = 0;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    udiv_qrnnd(R##_f1, _r_f1, _n_f2, _n_f1, Y##_f1);\t\t\t\\\n-    umul_ppmm(_m_f1, _m_f0, R##_f1, Y##_f0);\t\t\t\t\\\n-    _r_f0 = _n_f0;\t\t\t\t\t\t\t\\\n-    if (_FP_FRAC_GT_2(_m, _r))\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tR##_f1--;\t\t\t\t\t\t\t\\\n-\t_FP_FRAC_ADD_2(_r, Y, _r);\t\t\t\t\t\\\n-\tif (_FP_FRAC_GE_2(_r, Y) && _FP_FRAC_GT_2(_m, _r))\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    R##_f1--;\t\t\t\t\t\t\t\\\n-\t    _FP_FRAC_ADD_2(_r, Y, _r);\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    _FP_FRAC_DEC_2(_r, _m);\t\t\t\t\t\t\\\n+      /* Normalize, i.e. make the most significant bit of the\t\t\\\n+\t denominator set. */\t\t\t\t\t\t\\\n+      _FP_FRAC_SLL_2 (Y, _FP_WFRACXBITS_##fs);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    if (_r_f1 == Y##_f1)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t/* This is a special case, not an optimization\t\t\t\\\n-\t   (_r/Y##_f1 would not fit into UWtype).\t\t\t\\\n-\t   As _r is guaranteed to be < Y,  R##_f0 can be either\t\t\\\n-\t   (UWtype)-1 or (UWtype)-2.  But as we know what kind\t\t\\\n-\t   of bits it is (sticky, guard, round),  we don't care.\t\\\n-\t   We also don't care what the reminder is,  because the\t\\\n-\t   guard bit will be set anyway.  -jj */\t\t\t\\\n-\tR##_f0 = -1;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tudiv_qrnnd(R##_f0, _r_f1, _r_f1, _r_f0, Y##_f1);\t\t\\\n-\tumul_ppmm(_m_f1, _m_f0, R##_f0, Y##_f0);\t\t\t\\\n-\t_r_f0 = 0;\t\t\t\t\t\t\t\\\n-\tif (_FP_FRAC_GT_2(_m, _r))\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    R##_f0--;\t\t\t\t\t\t\t\\\n-\t    _FP_FRAC_ADD_2(_r, Y, _r);\t\t\t\t\t\\\n-\t    if (_FP_FRAC_GE_2(_r, Y) && _FP_FRAC_GT_2(_m, _r))\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tR##_f0--;\t\t\t\t\t\t\\\n-\t\t_FP_FRAC_ADD_2(_r, Y, _r);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tif (!_FP_FRAC_EQ_2(_r, _m))\t\t\t\t\t\\\n-\t  R##_f0 |= _FP_WORK_STICKY;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-\n-#define _FP_DIV_MEAT_2_gmp(fs, R, X, Y)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_W_TYPE _x[4], _y[2], _z[4];\t\t\t\t\t\\\n-    _y[0] = Y##_f0; _y[1] = Y##_f1;\t\t\t\t\t\\\n-    _x[0] = _x[3] = 0;\t\t\t\t\t\t\t\\\n-    if (_FP_FRAC_GT_2(X, Y))\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tR##_e++;\t\t\t\t\t\t\t\\\n-\t_x[1] = (X##_f0 << (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE) |\t\\\n-\t\t X##_f1 >> (_FP_W_TYPE_SIZE -\t\t\t\t\\\n-\t\t\t    (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE)));\t\\\n-\t_x[2] = X##_f1 << (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE);\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t_x[1] = (X##_f0 << (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE) |\t\\\n-\t\t X##_f1 >> (_FP_W_TYPE_SIZE -\t\t\t\t\\\n-\t\t\t    (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE)));\t\\\n-\t_x[2] = X##_f1 << (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE);\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n+      udiv_qrnnd (R##_f1, _r_f1, _n_f2, _n_f1, Y##_f1);\t\t\t\\\n+      umul_ppmm (_m_f1, _m_f0, R##_f1, Y##_f0);\t\t\t\t\\\n+      _r_f0 = _n_f0;\t\t\t\t\t\t\t\\\n+      if (_FP_FRAC_GT_2 (_m, _r))\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  R##_f1--;\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_ADD_2 (_r, Y, _r);\t\t\t\t\t\\\n+\t  if (_FP_FRAC_GE_2 (_r, Y) && _FP_FRAC_GT_2 (_m, _r))\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      R##_f1--;\t\t\t\t\t\t\t\\\n+\t      _FP_FRAC_ADD_2 (_r, Y, _r);\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DEC_2 (_r, _m);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    (void) mpn_divrem (_z, 0, _x, 4, _y, 2);\t\t\t\t\\\n-    R##_f1 = _z[1];\t\t\t\t\t\t\t\\\n-    R##_f0 = _z[0] | ((_x[0] | _x[1]) != 0);\t\t\t\t\\\n-  } while (0)\n+      if (_r_f1 == Y##_f1)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* This is a special case, not an optimization\t\t\\\n+\t     (_r/Y##_f1 would not fit into UWtype).\t\t\t\\\n+\t     As _r is guaranteed to be < Y,  R##_f0 can be either\t\\\n+\t     (UWtype)-1 or (UWtype)-2.  But as we know what kind\t\\\n+\t     of bits it is (sticky, guard, round),  we don't care.\t\\\n+\t     We also don't care what the reminder is,  because the\t\\\n+\t     guard bit will be set anyway.  -jj */\t\t\t\\\n+\t  R##_f0 = -1;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  udiv_qrnnd (R##_f0, _r_f1, _r_f1, _r_f0, Y##_f1);\t\t\\\n+\t  umul_ppmm (_m_f1, _m_f0, R##_f0, Y##_f0);\t\t\t\\\n+\t  _r_f0 = 0;\t\t\t\t\t\t\t\\\n+\t  if (_FP_FRAC_GT_2 (_m, _r))\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      R##_f0--;\t\t\t\t\t\t\t\\\n+\t      _FP_FRAC_ADD_2 (_r, Y, _r);\t\t\t\t\\\n+\t      if (_FP_FRAC_GE_2 (_r, Y) && _FP_FRAC_GT_2 (_m, _r))\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  R##_f0--;\t\t\t\t\t\t\\\n+\t\t  _FP_FRAC_ADD_2 (_r, Y, _r);\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  if (!_FP_FRAC_EQ_2 (_r, _m))\t\t\t\t\t\\\n+\t    R##_f0 |= _FP_WORK_STICKY;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n@@ -545,44 +580,46 @@\n  * should be added for those machines where division is fast.\n  */\n \n-#define _FP_SQRT_MEAT_2(R, S, T, X, q)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    while (q)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tT##_f1 = S##_f1 + q;\t\t\t\t\\\n-\tif (T##_f1 <= X##_f1)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\\\n-\t    S##_f1 = T##_f1 + q;\t\t\t\\\n-\t    X##_f1 -= T##_f1;\t\t\t\t\\\n-\t    R##_f1 += q;\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\\\n-\t_FP_FRAC_SLL_2(X, 1);\t\t\t\t\\\n-\tq >>= 1;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\\\n-    while (q != _FP_WORK_ROUND)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tT##_f0 = S##_f0 + q;\t\t\t\t\\\n-\tT##_f1 = S##_f1;\t\t\t\t\\\n-\tif (T##_f1 < X##_f1 || \t\t\t\t\\\n-\t    (T##_f1 == X##_f1 && T##_f0 <= X##_f0))\t\\\n-\t  {\t\t\t\t\t\t\\\n-\t    S##_f0 = T##_f0 + q;\t\t\t\\\n-\t    S##_f1 += (T##_f0 > S##_f0);\t\t\\\n-\t    _FP_FRAC_DEC_2(X, T);\t\t\t\\\n-\t    R##_f0 += q;\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\\\n-\t_FP_FRAC_SLL_2(X, 1);\t\t\t\t\\\n-\tq >>= 1;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    if (X##_f0 | X##_f1)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tif (S##_f1 < X##_f1 || \t\t\t\t\\\n-\t    (S##_f1 == X##_f1 && S##_f0 < X##_f0))\t\\\n-\t  R##_f0 |= _FP_WORK_ROUND;\t\t\t\\\n-\tR##_f0 |= _FP_WORK_STICKY;\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_SQRT_MEAT_2(R, S, T, X, q)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      while (q)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  T##_f1 = S##_f1 + q;\t\t\t\t\t\\\n+\t  if (T##_f1 <= X##_f1)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      S##_f1 = T##_f1 + q;\t\t\t\t\\\n+\t      X##_f1 -= T##_f1;\t\t\t\t\t\\\n+\t      R##_f1 += q;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SLL_2 (X, 1);\t\t\t\t\\\n+\t  q >>= 1;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      q = (_FP_W_TYPE) 1 << (_FP_W_TYPE_SIZE - 1);\t\t\\\n+      while (q != _FP_WORK_ROUND)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  T##_f0 = S##_f0 + q;\t\t\t\t\t\\\n+\t  T##_f1 = S##_f1;\t\t\t\t\t\\\n+\t  if (T##_f1 < X##_f1\t\t\t\t\t\\\n+\t      || (T##_f1 == X##_f1 && T##_f0 <= X##_f0))\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      S##_f0 = T##_f0 + q;\t\t\t\t\\\n+\t      S##_f1 += (T##_f0 > S##_f0);\t\t\t\\\n+\t      _FP_FRAC_DEC_2 (X, T);\t\t\t\t\\\n+\t      R##_f0 += q;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SLL_2 (X, 1);\t\t\t\t\\\n+\t  q >>= 1;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      if (X##_f0 | X##_f1)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (S##_f1 < X##_f1\t\t\t\t\t\\\n+\t      || (S##_f1 == X##_f1 && S##_f0 < X##_f0))\t\t\\\n+\t    R##_f0 |= _FP_WORK_ROUND;\t\t\t\t\\\n+\t  R##_f0 |= _FP_WORK_STICKY;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n@@ -591,19 +628,21 @@\n  */\n \n #define _FP_FRAC_ASSEMBLE_2(r, X, rsize)\t\\\n-(void)((rsize <= _FP_W_TYPE_SIZE)\t\t\\\n-       ? ({ r = X##_f0; })\t\t\t\\\n-       : ({\t\t\t\t\t\\\n-\t    r = X##_f1;\t\t\t\t\\\n-\t    r <<= _FP_W_TYPE_SIZE;\t\t\\\n-\t    r += X##_f0;\t\t\t\\\n-\t  }))\n+  (void) ((rsize <= _FP_W_TYPE_SIZE)\t\t\\\n+\t  ? ({ r = X##_f0; })\t\t\t\\\n+\t  : ({\t\t\t\t\t\\\n+\t      r = X##_f1;\t\t\t\\\n+\t      r <<= _FP_W_TYPE_SIZE;\t\t\\\n+\t      r += X##_f0;\t\t\t\\\n+\t    }))\n \n #define _FP_FRAC_DISASSEMBLE_2(X, r, rsize)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    X##_f0 = r;\t\t\t\t\t\t\t\t\\\n-    X##_f1 = (rsize <= _FP_W_TYPE_SIZE ? 0 : r >> _FP_W_TYPE_SIZE);\t\\\n-  } while (0)\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      X##_f0 = r;\t\t\t\t\t\t\t\\\n+      X##_f1 = (rsize <= _FP_W_TYPE_SIZE ? 0 : r >> _FP_W_TYPE_SIZE);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /*\n  * Convert FP values between word sizes\n@@ -613,4 +652,4 @@\n \n #define _FP_FRAC_COPY_2_1(D, S)\t\t((D##_f0 = S##_f), (D##_f1 = 0))\n \n-#define _FP_FRAC_COPY_2_2(D,S)\t\t_FP_FRAC_COPY_2(D,S)\n+#define _FP_FRAC_COPY_2_2(D, S)\t\t_FP_FRAC_COPY_2 (D, S)"}, {"sha": "3515bdc497baa56abb0a8afb6171174c27e84c4e", "filename": "libgcc/soft-fp/op-4.h", "status": "modified", "additions": 631, "deletions": 556, "changes": 1187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fop-4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fop-4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fop-4.h?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,403 +31,448 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #define _FP_FRAC_DECL_4(X)\t_FP_W_TYPE X##_f[4]\n-#define _FP_FRAC_COPY_4(D,S)\t\t\t\\\n+#define _FP_FRAC_COPY_4(D, S)\t\t\t\\\n   (D##_f[0] = S##_f[0], D##_f[1] = S##_f[1],\t\\\n    D##_f[2] = S##_f[2], D##_f[3] = S##_f[3])\n-#define _FP_FRAC_SET_4(X,I)\t__FP_FRAC_SET_4(X, I)\n+#define _FP_FRAC_SET_4(X, I)\t__FP_FRAC_SET_4 (X, I)\n #define _FP_FRAC_HIGH_4(X)\t(X##_f[3])\n #define _FP_FRAC_LOW_4(X)\t(X##_f[0])\n-#define _FP_FRAC_WORD_4(X,w)\t(X##_f[w])\n-\n-#define _FP_FRAC_SLL_4(X,N)\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\t\t\\\n-    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n-    _up = (N) % _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n-    _down = _FP_W_TYPE_SIZE - _up;\t\t\t\t\t\\\n-    if (!_up)\t\t\t\t\t\t\t\t\\\n-      for (_i = 3; _i >= _skip; --_i)\t\t\t\t\t\\\n-\tX##_f[_i] = X##_f[_i-_skip];\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfor (_i = 3; _i > _skip; --_i)\t\t\t\t\t\\\n-\t  X##_f[_i] = X##_f[_i-_skip] << _up\t\t\t\t\\\n-\t\t      | X##_f[_i-_skip-1] >> _down;\t\t\t\\\n-\tX##_f[_i--] = X##_f[0] << _up; \t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    for (; _i >= 0; --_i)\t\t\t\t\t\t\\\n-      X##_f[_i] = 0;\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_FRAC_WORD_4(X, w)\t(X##_f[w])\n+\n+#define _FP_FRAC_SLL_4(X, N)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\\\n+      _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\\\n+      _up = (N) % _FP_W_TYPE_SIZE;\t\t\t\\\n+      _down = _FP_W_TYPE_SIZE - _up;\t\t\t\\\n+      if (!_up)\t\t\t\t\t\t\\\n+\tfor (_i = 3; _i >= _skip; --_i)\t\t\t\\\n+\t  X##_f[_i] = X##_f[_i-_skip];\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  for (_i = 3; _i > _skip; --_i)\t\t\\\n+\t    X##_f[_i] = (X##_f[_i-_skip] << _up\t\t\\\n+\t\t\t | X##_f[_i-_skip-1] >> _down);\t\\\n+\t  X##_f[_i--] = X##_f[0] << _up;\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      for (; _i >= 0; --_i)\t\t\t\t\\\n+\tX##_f[_i] = 0;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* This one was broken too */\n-#define _FP_FRAC_SRL_4(X,N)\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\t\t\\\n-    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n-    _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n-    _up = _FP_W_TYPE_SIZE - _down;\t\t\t\t\t\\\n-    if (!_down)\t\t\t\t\t\t\t\t\\\n-      for (_i = 0; _i <= 3-_skip; ++_i)\t\t\t\t\t\\\n-\tX##_f[_i] = X##_f[_i+_skip];\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfor (_i = 0; _i < 3-_skip; ++_i)\t\t\t\t\\\n-\t  X##_f[_i] = X##_f[_i+_skip] >> _down\t\t\t\t\\\n-\t\t      | X##_f[_i+_skip+1] << _up;\t\t\t\\\n-\tX##_f[_i++] = X##_f[3] >> _down;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    for (; _i < 4; ++_i)\t\t\t\t\t\t\\\n-      X##_f[_i] = 0;\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_FRAC_SRL_4(X, N)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\\\n+      _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\\\n+      _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\\\n+      _up = _FP_W_TYPE_SIZE - _down;\t\t\t\\\n+      if (!_down)\t\t\t\t\t\\\n+\tfor (_i = 0; _i <= 3-_skip; ++_i)\t\t\\\n+\t  X##_f[_i] = X##_f[_i+_skip];\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  for (_i = 0; _i < 3-_skip; ++_i)\t\t\\\n+\t    X##_f[_i] = (X##_f[_i+_skip] >> _down\t\\\n+\t\t\t | X##_f[_i+_skip+1] << _up);\t\\\n+\t  X##_f[_i++] = X##_f[3] >> _down;\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      for (; _i < 4; ++_i)\t\t\t\t\\\n+\tX##_f[_i] = 0;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /* Right shift with sticky-lsb.\n  * What this actually means is that we do a standard right-shift,\n  * but that if any of the bits that fall off the right hand side\n  * were one then we always set the LSbit.\n  */\n-#define _FP_FRAC_SRST_4(X,S,N,size)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\\\n-    _FP_W_TYPE _s;\t\t\t\t\t\\\n-    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\\\n-    _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\\\n-    _up = _FP_W_TYPE_SIZE - _down;\t\t\t\\\n-    for (_s = _i = 0; _i < _skip; ++_i)\t\t\t\\\n-      _s |= X##_f[_i];\t\t\t\t\t\\\n-    if (!_down)\t\t\t\t\t\t\\\n-      for (_i = 0; _i <= 3-_skip; ++_i)\t\t\t\\\n-\tX##_f[_i] = X##_f[_i+_skip];\t\t\t\\\n-    else\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\t_s |= X##_f[_i] << _up;\t\t\t\t\\\n-\tfor (_i = 0; _i < 3-_skip; ++_i)\t\t\\\n-\t  X##_f[_i] = X##_f[_i+_skip] >> _down\t\t\\\n-\t\t      | X##_f[_i+_skip+1] << _up;\t\\\n-\tX##_f[_i++] = X##_f[3] >> _down;\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    for (; _i < 4; ++_i)\t\t\t\t\\\n-      X##_f[_i] = 0;\t\t\t\t\t\\\n-    S = (_s != 0);\t\t\t\t\t\\\n-  } while (0)\n-\n-#define _FP_FRAC_SRS_4(X,N,size)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    int _sticky;\t\t\t\t\\\n-    _FP_FRAC_SRST_4(X, _sticky, N, size);\t\\\n-    X##_f[0] |= _sticky;\t\t\t\\\n-  } while (0)\n-\n-#define _FP_FRAC_ADD_4(R,X,Y)\t\t\t\t\t\t\\\n-  __FP_FRAC_ADD_4(R##_f[3], R##_f[2], R##_f[1], R##_f[0],\t\t\\\n-\t\t  X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t\t\\\n-\t\t  Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])\n-\n-#define _FP_FRAC_SUB_4(R,X,Y)\t\t\t\t\t\t\\\n-  __FP_FRAC_SUB_4(R##_f[3], R##_f[2], R##_f[1], R##_f[0],\t\t\\\n-\t\t  X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t\t\\\n-\t\t  Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])\n-\n-#define _FP_FRAC_DEC_4(X,Y)\t\t\t\t\t\t\\\n-  __FP_FRAC_DEC_4(X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t\t\\\n-\t\t  Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])\n-\n-#define _FP_FRAC_ADDI_4(X,I)\t\t\t\t\t\t\\\n-  __FP_FRAC_ADDI_4(X##_f[3], X##_f[2], X##_f[1], X##_f[0], I)\n-\n-#define _FP_ZEROFRAC_4  0,0,0,0\n-#define _FP_MINFRAC_4   0,0,0,1\n-#define _FP_MAXFRAC_4\t(~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0)\n+#define _FP_FRAC_SRST_4(X, S, N, size)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\\\n+      _FP_W_TYPE _s;\t\t\t\t\t\\\n+      _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\\\n+      _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\\\n+      _up = _FP_W_TYPE_SIZE - _down;\t\t\t\\\n+      for (_s = _i = 0; _i < _skip; ++_i)\t\t\\\n+\t_s |= X##_f[_i];\t\t\t\t\\\n+      if (!_down)\t\t\t\t\t\\\n+\tfor (_i = 0; _i <= 3-_skip; ++_i)\t\t\\\n+\t  X##_f[_i] = X##_f[_i+_skip];\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  _s |= X##_f[_i] << _up;\t\t\t\\\n+\t  for (_i = 0; _i < 3-_skip; ++_i)\t\t\\\n+\t    X##_f[_i] = (X##_f[_i+_skip] >> _down\t\\\n+\t\t\t | X##_f[_i+_skip+1] << _up);\t\\\n+\t  X##_f[_i++] = X##_f[3] >> _down;\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      for (; _i < 4; ++_i)\t\t\t\t\\\n+\tX##_f[_i] = 0;\t\t\t\t\t\\\n+      S = (_s != 0);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_FRAC_SRS_4(X, N, size)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      int _sticky;\t\t\t\t\\\n+      _FP_FRAC_SRST_4 (X, _sticky, N, size);\t\\\n+      X##_f[0] |= _sticky;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_FRAC_ADD_4(R, X, Y)\t\t\t\t\t\\\n+  __FP_FRAC_ADD_4 (R##_f[3], R##_f[2], R##_f[1], R##_f[0],\t\\\n+\t\t   X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t\\\n+\t\t   Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])\n+\n+#define _FP_FRAC_SUB_4(R, X, Y)\t\t\t\t\t\\\n+  __FP_FRAC_SUB_4 (R##_f[3], R##_f[2], R##_f[1], R##_f[0],\t\\\n+\t\t   X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t\\\n+\t\t   Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])\n+\n+#define _FP_FRAC_DEC_4(X, Y)\t\t\t\t\t\\\n+  __FP_FRAC_DEC_4 (X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t\\\n+\t\t   Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])\n+\n+#define _FP_FRAC_ADDI_4(X, I)\t\t\t\t\t\\\n+  __FP_FRAC_ADDI_4 (X##_f[3], X##_f[2], X##_f[1], X##_f[0], I)\n+\n+#define _FP_ZEROFRAC_4  0, 0, 0, 0\n+#define _FP_MINFRAC_4   0, 0, 0, 1\n+#define _FP_MAXFRAC_4\t(~(_FP_WS_TYPE) 0), (~(_FP_WS_TYPE) 0), (~(_FP_WS_TYPE) 0), (~(_FP_WS_TYPE) 0)\n \n #define _FP_FRAC_ZEROP_4(X)     ((X##_f[0] | X##_f[1] | X##_f[2] | X##_f[3]) == 0)\n-#define _FP_FRAC_NEGP_4(X)      ((_FP_WS_TYPE)X##_f[3] < 0)\n-#define _FP_FRAC_OVERP_4(fs,X)  (_FP_FRAC_HIGH_##fs(X) & _FP_OVERFLOW_##fs)\n-#define _FP_FRAC_CLEAR_OVERP_4(fs,X)  (_FP_FRAC_HIGH_##fs(X) &= ~_FP_OVERFLOW_##fs)\n-\n-#define _FP_FRAC_EQ_4(X,Y)\t\t\t\t\\\n- (X##_f[0] == Y##_f[0] && X##_f[1] == Y##_f[1]\t\t\\\n-  && X##_f[2] == Y##_f[2] && X##_f[3] == Y##_f[3])\n-\n-#define _FP_FRAC_GT_4(X,Y)\t\t\t\t\\\n- (X##_f[3] > Y##_f[3] ||\t\t\t\t\\\n-  (X##_f[3] == Y##_f[3] && (X##_f[2] > Y##_f[2] ||\t\\\n-   (X##_f[2] == Y##_f[2] && (X##_f[1] > Y##_f[1] ||\t\\\n-    (X##_f[1] == Y##_f[1] && X##_f[0] > Y##_f[0])\t\\\n-   ))\t\t\t\t\t\t\t\\\n-  ))\t\t\t\t\t\t\t\\\n- )\n-\n-#define _FP_FRAC_GE_4(X,Y)\t\t\t\t\\\n- (X##_f[3] > Y##_f[3] ||\t\t\t\t\\\n-  (X##_f[3] == Y##_f[3] && (X##_f[2] > Y##_f[2] ||\t\\\n-   (X##_f[2] == Y##_f[2] && (X##_f[1] > Y##_f[1] ||\t\\\n-    (X##_f[1] == Y##_f[1] && X##_f[0] >= Y##_f[0])\t\\\n-   ))\t\t\t\t\t\t\t\\\n-  ))\t\t\t\t\t\t\t\\\n- )\n-\n-\n-#define _FP_FRAC_CLZ_4(R,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    if (X##_f[3])\t\t\t\\\n-    {\t\t\t\t\t\\\n-\t__FP_CLZ(R,X##_f[3]);\t\t\\\n-    }\t\t\t\t\t\\\n-    else if (X##_f[2])\t\t\t\\\n-    {\t\t\t\t\t\\\n-\t__FP_CLZ(R,X##_f[2]);\t\t\\\n-\tR += _FP_W_TYPE_SIZE;\t\t\\\n-    }\t\t\t\t\t\\\n-    else if (X##_f[1])\t\t\t\\\n-    {\t\t\t\t\t\\\n-\t__FP_CLZ(R,X##_f[1]);\t\t\\\n-\tR += _FP_W_TYPE_SIZE*2;\t\t\\\n-    }\t\t\t\t\t\\\n-    else\t\t\t\t\\\n-    {\t\t\t\t\t\\\n-\t__FP_CLZ(R,X##_f[0]);\t\t\\\n-\tR += _FP_W_TYPE_SIZE*3;\t\t\\\n-    }\t\t\t\t\t\\\n-  } while(0)\n-\n-\n-#define _FP_UNPACK_RAW_4(fs, X, val)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs _flo; _flo.flt = (val);\t\t\\\n-    X##_f[0] = _flo.bits.frac0;\t\t\t\t\t\\\n-    X##_f[1] = _flo.bits.frac1;\t\t\t\t\t\\\n-    X##_f[2] = _flo.bits.frac2;\t\t\t\t\t\\\n-    X##_f[3] = _flo.bits.frac3;\t\t\t\t\t\\\n-    X##_e  = _flo.bits.exp;\t\t\t\t\t\\\n-    X##_s  = _flo.bits.sign;\t\t\t\t\t\\\n-  } while (0)\n-\n-#define _FP_UNPACK_RAW_4_P(fs, X, val)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs *_flo =\t\t\t\t\\\n-      (union _FP_UNION_##fs *)(val);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    X##_f[0] = _flo->bits.frac0;\t\t\t\t\\\n-    X##_f[1] = _flo->bits.frac1;\t\t\t\t\\\n-    X##_f[2] = _flo->bits.frac2;\t\t\t\t\\\n-    X##_f[3] = _flo->bits.frac3;\t\t\t\t\\\n-    X##_e  = _flo->bits.exp;\t\t\t\t\t\\\n-    X##_s  = _flo->bits.sign;\t\t\t\t\t\\\n-  } while (0)\n-\n-#define _FP_PACK_RAW_4(fs, val, X)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs _flo;\t\t\t\t\t\\\n-    _flo.bits.frac0 = X##_f[0];\t\t\t\t\t\\\n-    _flo.bits.frac1 = X##_f[1];\t\t\t\t\t\\\n-    _flo.bits.frac2 = X##_f[2];\t\t\t\t\t\\\n-    _flo.bits.frac3 = X##_f[3];\t\t\t\t\t\\\n-    _flo.bits.exp   = X##_e;\t\t\t\t\t\\\n-    _flo.bits.sign  = X##_s;\t\t\t\t\t\\\n-    (val) = _flo.flt;\t\t\t\t   \t\t\\\n-  } while (0)\n-\n-#define _FP_PACK_RAW_4_P(fs, val, X)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    union _FP_UNION_##fs *_flo =\t\t\t\t\\\n-      (union _FP_UNION_##fs *)(val);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    _flo->bits.frac0 = X##_f[0];\t\t\t\t\\\n-    _flo->bits.frac1 = X##_f[1];\t\t\t\t\\\n-    _flo->bits.frac2 = X##_f[2];\t\t\t\t\\\n-    _flo->bits.frac3 = X##_f[3];\t\t\t\t\\\n-    _flo->bits.exp   = X##_e;\t\t\t\t\t\\\n-    _flo->bits.sign  = X##_s;\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_FRAC_NEGP_4(X)      ((_FP_WS_TYPE) X##_f[3] < 0)\n+#define _FP_FRAC_OVERP_4(fs, X)  (_FP_FRAC_HIGH_##fs (X) & _FP_OVERFLOW_##fs)\n+#define _FP_FRAC_HIGHBIT_DW_4(fs, X)\t\\\n+  (_FP_FRAC_HIGH_DW_##fs (X) & _FP_HIGHBIT_DW_##fs)\n+#define _FP_FRAC_CLEAR_OVERP_4(fs, X)  (_FP_FRAC_HIGH_##fs (X) &= ~_FP_OVERFLOW_##fs)\n+\n+#define _FP_FRAC_EQ_4(X, Y)\t\t\t\t\\\n+  (X##_f[0] == Y##_f[0] && X##_f[1] == Y##_f[1]\t\t\\\n+   && X##_f[2] == Y##_f[2] && X##_f[3] == Y##_f[3])\n+\n+#define _FP_FRAC_GT_4(X, Y)\t\t\t\t\\\n+  (X##_f[3] > Y##_f[3]\t\t\t\t\t\\\n+   || (X##_f[3] == Y##_f[3]\t\t\t\t\\\n+       && (X##_f[2] > Y##_f[2]\t\t\t\t\\\n+\t   || (X##_f[2] == Y##_f[2]\t\t\t\\\n+\t       && (X##_f[1] > Y##_f[1]\t\t\t\\\n+\t\t   || (X##_f[1] == Y##_f[1]\t\t\\\n+\t\t       && X##_f[0] > Y##_f[0]))))))\n+\n+#define _FP_FRAC_GE_4(X, Y)\t\t\t\t\\\n+  (X##_f[3] > Y##_f[3]\t\t\t\t\t\\\n+   || (X##_f[3] == Y##_f[3]\t\t\t\t\\\n+       && (X##_f[2] > Y##_f[2]\t\t\t\t\\\n+\t   || (X##_f[2] == Y##_f[2]\t\t\t\\\n+\t       && (X##_f[1] > Y##_f[1]\t\t\t\\\n+\t\t   || (X##_f[1] == Y##_f[1]\t\t\\\n+\t\t       && X##_f[0] >= Y##_f[0]))))))\n+\n+\n+#define _FP_FRAC_CLZ_4(R, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (X##_f[3])\t\t\t\t\\\n+\t__FP_CLZ (R, X##_f[3]);\t\t\t\\\n+      else if (X##_f[2])\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  __FP_CLZ (R, X##_f[2]);\t\t\\\n+\t  R += _FP_W_TYPE_SIZE;\t\t\t\\\n+\t}\t\t\t\t\t\\\n+      else if (X##_f[1])\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  __FP_CLZ (R, X##_f[1]);\t\t\\\n+\t  R += _FP_W_TYPE_SIZE*2;\t\t\\\n+\t}\t\t\t\t\t\\\n+      else\t\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  __FP_CLZ (R, X##_f[0]);\t\t\\\n+\t  R += _FP_W_TYPE_SIZE*3;\t\t\\\n+\t}\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+#define _FP_UNPACK_RAW_4(fs, X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs _flo;\t\t\\\n+      _flo.flt = (val);\t\t\t\t\\\n+      X##_f[0] = _flo.bits.frac0;\t\t\\\n+      X##_f[1] = _flo.bits.frac1;\t\t\\\n+      X##_f[2] = _flo.bits.frac2;\t\t\\\n+      X##_f[3] = _flo.bits.frac3;\t\t\\\n+      X##_e  = _flo.bits.exp;\t\t\t\\\n+      X##_s  = _flo.bits.sign;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_UNPACK_RAW_4_P(fs, X, val)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs *_flo = (union _FP_UNION_##fs *) (val);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      X##_f[0] = _flo->bits.frac0;\t\t\t\t\t\\\n+      X##_f[1] = _flo->bits.frac1;\t\t\t\t\t\\\n+      X##_f[2] = _flo->bits.frac2;\t\t\t\t\t\\\n+      X##_f[3] = _flo->bits.frac3;\t\t\t\t\t\\\n+      X##_e  = _flo->bits.exp;\t\t\t\t\t\t\\\n+      X##_s  = _flo->bits.sign;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_PACK_RAW_4(fs, val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs _flo;\t\t\\\n+      _flo.bits.frac0 = X##_f[0];\t\t\\\n+      _flo.bits.frac1 = X##_f[1];\t\t\\\n+      _flo.bits.frac2 = X##_f[2];\t\t\\\n+      _flo.bits.frac3 = X##_f[3];\t\t\\\n+      _flo.bits.exp   = X##_e;\t\t\t\\\n+      _flo.bits.sign  = X##_s;\t\t\t\\\n+      (val) = _flo.flt;\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_PACK_RAW_4_P(fs, val, X)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      union _FP_UNION_##fs *_flo = (union _FP_UNION_##fs *) (val);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      _flo->bits.frac0 = X##_f[0];\t\t\t\t\t\\\n+      _flo->bits.frac1 = X##_f[1];\t\t\t\t\t\\\n+      _flo->bits.frac2 = X##_f[2];\t\t\t\t\t\\\n+      _flo->bits.frac3 = X##_f[3];\t\t\t\t\t\\\n+      _flo->bits.exp   = X##_e;\t\t\t\t\t\t\\\n+      _flo->bits.sign  = X##_s;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /*\n  * Multiplication algorithms:\n  */\n \n /* Given a 1W * 1W => 2W primitive, do the extended multiplication.  */\n \n-#define _FP_MUL_MEAT_4_wide(wfracbits, R, X, Y, doit)\t\t\t    \\\n-  do {\t\t\t\t\t\t\t\t\t    \\\n-    _FP_FRAC_DECL_8(_z); _FP_FRAC_DECL_2(_b); _FP_FRAC_DECL_2(_c);\t    \\\n-    _FP_FRAC_DECL_2(_d); _FP_FRAC_DECL_2(_e); _FP_FRAC_DECL_2(_f);\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-    doit(_FP_FRAC_WORD_8(_z,1), _FP_FRAC_WORD_8(_z,0), X##_f[0], Y##_f[0]); \\\n-    doit(_b_f1, _b_f0, X##_f[0], Y##_f[1]);\t\t\t\t    \\\n-    doit(_c_f1, _c_f0, X##_f[1], Y##_f[0]);\t\t\t\t    \\\n-    doit(_d_f1, _d_f0, X##_f[1], Y##_f[1]);\t\t\t\t    \\\n-    doit(_e_f1, _e_f0, X##_f[0], Y##_f[2]);\t\t\t\t    \\\n-    doit(_f_f1, _f_f0, X##_f[2], Y##_f[0]);\t\t\t\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,1), 0,_b_f1,_b_f0,\t\t    \\\n-\t\t    0,0,_FP_FRAC_WORD_8(_z,1));\t\t\t\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,1), 0,_c_f1,_c_f0,\t\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,1));\t\t\t\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,2), 0,_d_f1,_d_f0,\t\t    \\\n-\t\t    0,_FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2));\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,2), 0,_e_f1,_e_f0,\t\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,2));\t\t\t\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,2), 0,_f_f1,_f_f0,\t\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,2));\t\t\t\t    \\\n-    doit(_b_f1, _b_f0, X##_f[0], Y##_f[3]);\t\t\t\t    \\\n-    doit(_c_f1, _c_f0, X##_f[3], Y##_f[0]);\t\t\t\t    \\\n-    doit(_d_f1, _d_f0, X##_f[1], Y##_f[2]);\t\t\t\t    \\\n-    doit(_e_f1, _e_f0, X##_f[2], Y##_f[1]);\t\t\t\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,3), 0,_b_f1,_b_f0,\t\t    \\\n-\t\t    0,_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3));\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,3), 0,_c_f1,_c_f0,\t\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,3));\t\t\t\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,3), 0,_d_f1,_d_f0,\t\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,3));\t\t\t\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,3), 0,_e_f1,_e_f0,\t\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,3));\t\t\t\t    \\\n-    doit(_b_f1, _b_f0, X##_f[2], Y##_f[2]);\t\t\t\t    \\\n-    doit(_c_f1, _c_f0, X##_f[1], Y##_f[3]);\t\t\t\t    \\\n-    doit(_d_f1, _d_f0, X##_f[3], Y##_f[1]);\t\t\t\t    \\\n-    doit(_e_f1, _e_f0, X##_f[2], Y##_f[3]);\t\t\t\t    \\\n-    doit(_f_f1, _f_f0, X##_f[3], Y##_f[2]);\t\t\t\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,4), 0,_b_f1,_b_f0,\t\t    \\\n-\t\t    0,_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4));\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,4), 0,_c_f1,_c_f0,\t\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,4));\t\t\t\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,4), 0,_d_f1,_d_f0,\t\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,4));\t\t\t\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,5), 0,_e_f1,_e_f0,\t\t    \\\n-\t\t    0,_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5));\t    \\\n-    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,5), 0,_f_f1,_f_f0,\t\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,5));\t\t\t\t    \\\n-    doit(_b_f1, _b_f0, X##_f[3], Y##_f[3]);\t\t\t\t    \\\n-    __FP_FRAC_ADD_2(_FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),\t    \\\n-\t\t    _b_f1,_b_f0,\t\t\t\t\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6));\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-    /* Normalize since we know where the msb of the multiplicands\t    \\\n-       were (bit B), we know that the msb of the of the product is\t    \\\n-       at either 2B or 2B-1.  */\t\t\t\t\t    \\\n-    _FP_FRAC_SRS_8(_z, wfracbits-1, 2*wfracbits);\t\t\t    \\\n-    __FP_FRAC_SET_4(R, _FP_FRAC_WORD_8(_z,3), _FP_FRAC_WORD_8(_z,2),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,1), _FP_FRAC_WORD_8(_z,0));\t    \\\n-  } while (0)\n-\n-#define _FP_MUL_MEAT_4_gmp(wfracbits, R, X, Y)\t\t\t\t    \\\n-  do {\t\t\t\t\t\t\t\t\t    \\\n-    _FP_FRAC_DECL_8(_z);\t\t\t\t\t\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-    mpn_mul_n(_z_f, _x_f, _y_f, 4);\t\t\t\t\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-    /* Normalize since we know where the msb of the multiplicands\t    \\\n-       were (bit B), we know that the msb of the of the product is\t    \\\n-       at either 2B or 2B-1.  */\t\t\t\t\t    \\\n-    _FP_FRAC_SRS_8(_z, wfracbits-1, 2*wfracbits);\t \t\t    \\\n-    __FP_FRAC_SET_4(R, _FP_FRAC_WORD_8(_z,3), _FP_FRAC_WORD_8(_z,2),\t    \\\n-\t\t    _FP_FRAC_WORD_8(_z,1), _FP_FRAC_WORD_8(_z,0));\t    \\\n-  } while (0)\n+#define _FP_MUL_MEAT_DW_4_wide(wfracbits, R, X, Y, doit)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_b);\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_c);\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_d);\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_e);\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_2 (_f);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      doit (_FP_FRAC_WORD_8 (R, 1), _FP_FRAC_WORD_8 (R, 0), X##_f[0], Y##_f[0]); \\\n+      doit (_b_f1, _b_f0, X##_f[0], Y##_f[1]);\t\t\t\t\\\n+      doit (_c_f1, _c_f0, X##_f[1], Y##_f[0]);\t\t\t\t\\\n+      doit (_d_f1, _d_f0, X##_f[1], Y##_f[1]);\t\t\t\t\\\n+      doit (_e_f1, _e_f0, X##_f[0], Y##_f[2]);\t\t\t\t\\\n+      doit (_f_f1, _f_f0, X##_f[2], Y##_f[0]);\t\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 3), _FP_FRAC_WORD_8 (R, 2),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 1), 0, _b_f1, _b_f0,\t\t\\\n+\t\t       0, 0, _FP_FRAC_WORD_8 (R, 1));\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 3), _FP_FRAC_WORD_8 (R, 2),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 1), 0, _c_f1, _c_f0,\t\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 3), _FP_FRAC_WORD_8 (R, 2),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 1));\t\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 4), _FP_FRAC_WORD_8 (R, 3),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 2), 0, _d_f1, _d_f0,\t\t\\\n+\t\t       0, _FP_FRAC_WORD_8 (R, 3), _FP_FRAC_WORD_8 (R, 2)); \\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 4), _FP_FRAC_WORD_8 (R, 3),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 2), 0, _e_f1, _e_f0,\t\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 4), _FP_FRAC_WORD_8 (R, 3),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 2));\t\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 4), _FP_FRAC_WORD_8 (R, 3),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 2), 0, _f_f1, _f_f0,\t\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 4), _FP_FRAC_WORD_8 (R, 3),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 2));\t\t\t\t\\\n+      doit (_b_f1, _b_f0, X##_f[0], Y##_f[3]);\t\t\t\t\\\n+      doit (_c_f1, _c_f0, X##_f[3], Y##_f[0]);\t\t\t\t\\\n+      doit (_d_f1, _d_f0, X##_f[1], Y##_f[2]);\t\t\t\t\\\n+      doit (_e_f1, _e_f0, X##_f[2], Y##_f[1]);\t\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 5), _FP_FRAC_WORD_8 (R, 4),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 3), 0, _b_f1, _b_f0,\t\t\\\n+\t\t       0, _FP_FRAC_WORD_8 (R, 4), _FP_FRAC_WORD_8 (R, 3)); \\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 5), _FP_FRAC_WORD_8 (R, 4),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 3), 0, _c_f1, _c_f0,\t\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 5), _FP_FRAC_WORD_8 (R, 4),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 3));\t\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 5), _FP_FRAC_WORD_8 (R, 4),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 3), 0, _d_f1, _d_f0,\t\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 5), _FP_FRAC_WORD_8 (R, 4),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 3));\t\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 5), _FP_FRAC_WORD_8 (R, 4),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 3), 0, _e_f1, _e_f0,\t\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 5), _FP_FRAC_WORD_8 (R, 4),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 3));\t\t\t\t\\\n+      doit (_b_f1, _b_f0, X##_f[2], Y##_f[2]);\t\t\t\t\\\n+      doit (_c_f1, _c_f0, X##_f[1], Y##_f[3]);\t\t\t\t\\\n+      doit (_d_f1, _d_f0, X##_f[3], Y##_f[1]);\t\t\t\t\\\n+      doit (_e_f1, _e_f0, X##_f[2], Y##_f[3]);\t\t\t\t\\\n+      doit (_f_f1, _f_f0, X##_f[3], Y##_f[2]);\t\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 6), _FP_FRAC_WORD_8 (R, 5),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 4), 0, _b_f1, _b_f0,\t\t\\\n+\t\t       0, _FP_FRAC_WORD_8 (R, 5), _FP_FRAC_WORD_8 (R, 4)); \\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 6), _FP_FRAC_WORD_8 (R, 5),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 4), 0, _c_f1, _c_f0,\t\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 6), _FP_FRAC_WORD_8 (R, 5),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 4));\t\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 6), _FP_FRAC_WORD_8 (R, 5),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 4), 0, _d_f1, _d_f0,\t\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 6), _FP_FRAC_WORD_8 (R, 5),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 4));\t\t\t\t\\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 7), _FP_FRAC_WORD_8 (R, 6),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 5), 0, _e_f1, _e_f0,\t\t\\\n+\t\t       0, _FP_FRAC_WORD_8 (R, 6), _FP_FRAC_WORD_8 (R, 5)); \\\n+      __FP_FRAC_ADD_3 (_FP_FRAC_WORD_8 (R, 7), _FP_FRAC_WORD_8 (R, 6),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 5), 0, _f_f1, _f_f0,\t\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 7), _FP_FRAC_WORD_8 (R, 6),\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 5));\t\t\t\t\\\n+      doit (_b_f1, _b_f0, X##_f[3], Y##_f[3]);\t\t\t\t\\\n+      __FP_FRAC_ADD_2 (_FP_FRAC_WORD_8 (R, 7), _FP_FRAC_WORD_8 (R, 6),\t\\\n+\t\t       _b_f1, _b_f0,\t\t\t\t\t\\\n+\t\t       _FP_FRAC_WORD_8 (R, 7), _FP_FRAC_WORD_8 (R, 6));\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_MUL_MEAT_4_wide(wfracbits, R, X, Y, doit)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_8 (_z);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      _FP_MUL_MEAT_DW_4_wide (wfracbits, _z, X, Y, doit);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Normalize since we know where the msb of the multiplicands\t\\\n+\t were (bit B), we know that the msb of the of the product is\t\\\n+\t at either 2B or 2B-1.  */\t\t\t\t\t\\\n+      _FP_FRAC_SRS_8 (_z, wfracbits-1, 2*wfracbits);\t\t\t\\\n+      __FP_FRAC_SET_4 (R, _FP_FRAC_WORD_8 (_z, 3), _FP_FRAC_WORD_8 (_z, 2), \\\n+\t\t       _FP_FRAC_WORD_8 (_z, 1), _FP_FRAC_WORD_8 (_z, 0)); \\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_MUL_MEAT_DW_4_gmp(wfracbits, R, X, Y)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      mpn_mul_n (R##_f, _x_f, _y_f, 4);\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_MUL_MEAT_4_gmp(wfracbits, R, X, Y)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_8 (_z);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      _FP_MUL_MEAT_DW_4_gmp (wfracbits, _z, X, Y);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Normalize since we know where the msb of the multiplicands\t\\\n+\t were (bit B), we know that the msb of the of the product is\t\\\n+\t at either 2B or 2B-1.  */\t\t\t\t\t\\\n+      _FP_FRAC_SRS_8 (_z, wfracbits-1, 2*wfracbits);\t\t\t\\\n+      __FP_FRAC_SET_4 (R, _FP_FRAC_WORD_8 (_z, 3), _FP_FRAC_WORD_8 (_z, 2), \\\n+\t\t       _FP_FRAC_WORD_8 (_z, 1), _FP_FRAC_WORD_8 (_z, 0)); \\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /*\n  * Helper utility for _FP_DIV_MEAT_4_udiv:\n  * pppp = m * nnn\n  */\n-#define umul_ppppmnnn(p3,p2,p1,p0,m,n2,n1,n0)\t\t\t\t    \\\n-  do {\t\t\t\t\t\t\t\t\t    \\\n-    UWtype _t;\t\t\t\t\t\t\t\t    \\\n-    umul_ppmm(p1,p0,m,n0);\t\t\t\t\t\t    \\\n-    umul_ppmm(p2,_t,m,n1);\t\t\t\t\t\t    \\\n-    __FP_FRAC_ADDI_2(p2,p1,_t);\t\t\t\t\t\t    \\\n-    umul_ppmm(p3,_t,m,n2);\t\t\t\t\t\t    \\\n-    __FP_FRAC_ADDI_2(p3,p2,_t);\t\t\t\t\t\t    \\\n-  } while (0)\n+#define umul_ppppmnnn(p3, p2, p1, p0, m, n2, n1, n0)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      UWtype _t;\t\t\t\t\t\\\n+      umul_ppmm (p1, p0, m, n0);\t\t\t\\\n+      umul_ppmm (p2, _t, m, n1);\t\t\t\\\n+      __FP_FRAC_ADDI_2 (p2, p1, _t);\t\t\t\\\n+      umul_ppmm (p3, _t, m, n2);\t\t\t\\\n+      __FP_FRAC_ADDI_2 (p3, p2, _t);\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n /*\n  * Division algorithms:\n  */\n \n-#define _FP_DIV_MEAT_4_udiv(fs, R, X, Y)\t\t\t\t    \\\n-  do {\t\t\t\t\t\t\t\t\t    \\\n-    int _i;\t\t\t\t\t\t\t\t    \\\n-    _FP_FRAC_DECL_4(_n); _FP_FRAC_DECL_4(_m);\t\t\t\t    \\\n-    _FP_FRAC_SET_4(_n, _FP_ZEROFRAC_4);\t\t\t\t\t    \\\n-    if (_FP_FRAC_GT_4(X, Y))\t\t\t\t\t\t    \\\n-      {\t\t\t\t\t\t\t\t\t    \\\n-\t_n_f[3] = X##_f[0] << (_FP_W_TYPE_SIZE - 1);\t\t\t    \\\n-\t_FP_FRAC_SRL_4(X, 1);\t\t\t\t\t\t    \\\n-      }\t\t\t\t\t\t\t\t\t    \\\n-    else\t\t\t\t\t\t\t\t    \\\n-      R##_e--;\t\t\t\t\t\t\t\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-    /* Normalize, i.e. make the most significant bit of the \t\t    \\\n-       denominator set. */\t\t\t\t\t\t    \\\n-    _FP_FRAC_SLL_4(Y, _FP_WFRACXBITS_##fs);\t\t\t\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-    for (_i = 3; ; _i--)\t\t\t\t\t\t    \\\n-      {\t\t\t\t\t\t\t\t\t    \\\n-        if (X##_f[3] == Y##_f[3])\t\t\t\t\t    \\\n-          {\t\t\t\t\t\t\t\t    \\\n-            /* This is a special case, not an optimization\t\t    \\\n-               (X##_f[3]/Y##_f[3] would not fit into UWtype).\t\t    \\\n-               As X## is guaranteed to be < Y,  R##_f[_i] can be either\t    \\\n-               (UWtype)-1 or (UWtype)-2.  */\t\t\t\t    \\\n-            R##_f[_i] = -1;\t\t\t\t\t\t    \\\n-            if (!_i)\t\t\t\t\t\t\t    \\\n-\t      break;\t\t\t\t\t\t\t    \\\n-            __FP_FRAC_SUB_4(X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t    \\\n-\t\t\t    Y##_f[2], Y##_f[1], Y##_f[0], 0,\t\t    \\\n-\t\t\t    X##_f[2], X##_f[1], X##_f[0], _n_f[_i]);\t    \\\n-            _FP_FRAC_SUB_4(X, Y, X);\t\t\t\t\t    \\\n-            if (X##_f[3] > Y##_f[3])\t\t\t\t\t    \\\n-              {\t\t\t\t\t\t\t\t    \\\n-                R##_f[_i] = -2;\t\t\t\t\t\t    \\\n-                _FP_FRAC_ADD_4(X, Y, X);\t\t\t\t    \\\n-              }\t\t\t\t\t\t\t\t    \\\n-          }\t\t\t\t\t\t\t\t    \\\n-        else\t\t\t\t\t\t\t\t    \\\n-          {\t\t\t\t\t\t\t\t    \\\n-            udiv_qrnnd(R##_f[_i], X##_f[3], X##_f[3], X##_f[2], Y##_f[3]);  \\\n-            umul_ppppmnnn(_m_f[3], _m_f[2], _m_f[1], _m_f[0],\t\t    \\\n-\t\t\t  R##_f[_i], Y##_f[2], Y##_f[1], Y##_f[0]);\t    \\\n-            X##_f[2] = X##_f[1];\t\t\t\t\t    \\\n-            X##_f[1] = X##_f[0];\t\t\t\t\t    \\\n-            X##_f[0] = _n_f[_i];\t\t\t\t\t    \\\n-            if (_FP_FRAC_GT_4(_m, X))\t\t\t\t\t    \\\n-              {\t\t\t\t\t\t\t\t    \\\n-                R##_f[_i]--;\t\t\t\t\t\t    \\\n-                _FP_FRAC_ADD_4(X, Y, X);\t\t\t\t    \\\n-                if (_FP_FRAC_GE_4(X, Y) && _FP_FRAC_GT_4(_m, X))\t    \\\n-                  {\t\t\t\t\t\t\t    \\\n-\t\t    R##_f[_i]--;\t\t\t\t\t    \\\n-\t\t    _FP_FRAC_ADD_4(X, Y, X);\t\t\t\t    \\\n-                  }\t\t\t\t\t\t\t    \\\n-              }\t\t\t\t\t\t\t\t    \\\n-            _FP_FRAC_DEC_4(X, _m);\t\t\t\t\t    \\\n-            if (!_i)\t\t\t\t\t\t\t    \\\n-\t      {\t\t\t\t\t\t\t\t    \\\n-\t\tif (!_FP_FRAC_EQ_4(X, _m))\t\t\t\t    \\\n-\t\t  R##_f[0] |= _FP_WORK_STICKY;\t\t\t\t    \\\n-\t\tbreak;\t\t\t\t\t\t\t    \\\n-\t      }\t\t\t\t\t\t\t\t    \\\n-          }\t\t\t\t\t\t\t\t    \\\n-      }\t\t\t\t\t\t\t\t\t    \\\n-  } while (0)\n+#define _FP_DIV_MEAT_4_udiv(fs, R, X, Y)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int _i;\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_4 (_n);\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_4 (_m);\t\t\t\t\t\t\\\n+      _FP_FRAC_SET_4 (_n, _FP_ZEROFRAC_4);\t\t\t\t\\\n+      if (_FP_FRAC_GE_4 (X, Y))\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _n_f[3] = X##_f[0] << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n+\t  _FP_FRAC_SRL_4 (X, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tR##_e--;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Normalize, i.e. make the most significant bit of the\t\t\\\n+\t denominator set. */\t\t\t\t\t\t\\\n+      _FP_FRAC_SLL_4 (Y, _FP_WFRACXBITS_##fs);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      for (_i = 3; ; _i--)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (X##_f[3] == Y##_f[3])\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      /* This is a special case, not an optimization\t\t\\\n+\t\t (X##_f[3]/Y##_f[3] would not fit into UWtype).\t\t\\\n+\t\t As X## is guaranteed to be < Y,  R##_f[_i] can be either \\\n+\t\t (UWtype)-1 or (UWtype)-2.  */\t\t\t\t\\\n+\t      R##_f[_i] = -1;\t\t\t\t\t\t\\\n+\t      if (!_i)\t\t\t\t\t\t\t\\\n+\t\tbreak;\t\t\t\t\t\t\t\\\n+\t      __FP_FRAC_SUB_4 (X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t\\\n+\t\t\t       Y##_f[2], Y##_f[1], Y##_f[0], 0,\t\t\\\n+\t\t\t       X##_f[2], X##_f[1], X##_f[0], _n_f[_i]);\t\\\n+\t      _FP_FRAC_SUB_4 (X, Y, X);\t\t\t\t\t\\\n+\t      if (X##_f[3] > Y##_f[3])\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  R##_f[_i] = -2;\t\t\t\t\t\\\n+\t\t  _FP_FRAC_ADD_4 (X, Y, X);\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      udiv_qrnnd (R##_f[_i], X##_f[3], X##_f[3], X##_f[2], Y##_f[3]); \\\n+\t      umul_ppppmnnn (_m_f[3], _m_f[2], _m_f[1], _m_f[0],\t\\\n+\t\t\t     R##_f[_i], Y##_f[2], Y##_f[1], Y##_f[0]);\t\\\n+\t      X##_f[2] = X##_f[1];\t\t\t\t\t\\\n+\t      X##_f[1] = X##_f[0];\t\t\t\t\t\\\n+\t      X##_f[0] = _n_f[_i];\t\t\t\t\t\\\n+\t      if (_FP_FRAC_GT_4 (_m, X))\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  R##_f[_i]--;\t\t\t\t\t\t\\\n+\t\t  _FP_FRAC_ADD_4 (X, Y, X);\t\t\t\t\\\n+\t\t  if (_FP_FRAC_GE_4 (X, Y) && _FP_FRAC_GT_4 (_m, X))\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      R##_f[_i]--;\t\t\t\t\t\\\n+\t\t      _FP_FRAC_ADD_4 (X, Y, X);\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      _FP_FRAC_DEC_4 (X, _m);\t\t\t\t\t\\\n+\t      if (!_i)\t\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  if (!_FP_FRAC_EQ_4 (X, _m))\t\t\t\t\\\n+\t\t    R##_f[0] |= _FP_WORK_STICKY;\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n@@ -436,183 +481,203 @@\n  * should be added for those machines where division is fast.\n  */\n \n-#define _FP_SQRT_MEAT_4(R, S, T, X, q)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    while (q)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tT##_f[3] = S##_f[3] + q;\t\t\t\t\\\n-\tif (T##_f[3] <= X##_f[3])\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    S##_f[3] = T##_f[3] + q;\t\t\t\t\\\n-\t    X##_f[3] -= T##_f[3];\t\t\t\t\\\n-\t    R##_f[3] += q;\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\t_FP_FRAC_SLL_4(X, 1);\t\t\t\t\t\\\n-\tq >>= 1;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n-    while (q)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tT##_f[2] = S##_f[2] + q;\t\t\t\t\\\n-\tT##_f[3] = S##_f[3];\t\t\t\t\t\\\n-\tif (T##_f[3] < X##_f[3] || \t\t\t\t\\\n-\t    (T##_f[3] == X##_f[3] && T##_f[2] <= X##_f[2]))\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    S##_f[2] = T##_f[2] + q;\t\t\t\t\\\n-\t    S##_f[3] += (T##_f[2] > S##_f[2]);\t\t\t\\\n-\t    __FP_FRAC_DEC_2(X##_f[3], X##_f[2],\t\t\t\\\n-\t\t\t    T##_f[3], T##_f[2]);\t\t\\\n-\t    R##_f[2] += q;\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\t_FP_FRAC_SLL_4(X, 1);\t\t\t\t\t\\\n-\tq >>= 1;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n-    while (q)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tT##_f[1] = S##_f[1] + q;\t\t\t\t\\\n-\tT##_f[2] = S##_f[2];\t\t\t\t\t\\\n-\tT##_f[3] = S##_f[3];\t\t\t\t\t\\\n-\tif (T##_f[3] < X##_f[3] || \t\t\t\t\\\n-\t    (T##_f[3] == X##_f[3] && (T##_f[2] < X##_f[2] ||\t\\\n-\t     (T##_f[2] == X##_f[2] && T##_f[1] <= X##_f[1]))))\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    S##_f[1] = T##_f[1] + q;\t\t\t\t\\\n-\t    S##_f[2] += (T##_f[1] > S##_f[1]);\t\t\t\\\n-\t    S##_f[3] += (T##_f[2] > S##_f[2]);\t\t\t\\\n-\t    __FP_FRAC_DEC_3(X##_f[3], X##_f[2], X##_f[1],\t\\\n-\t\t\t    T##_f[3], T##_f[2], T##_f[1]);\t\\\n-\t    R##_f[1] += q;\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\t_FP_FRAC_SLL_4(X, 1);\t\t\t\t\t\\\n-\tq >>= 1;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n-    while (q != _FP_WORK_ROUND)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tT##_f[0] = S##_f[0] + q;\t\t\t\t\\\n-\tT##_f[1] = S##_f[1];\t\t\t\t\t\\\n-\tT##_f[2] = S##_f[2];\t\t\t\t\t\\\n-\tT##_f[3] = S##_f[3];\t\t\t\t\t\\\n-\tif (_FP_FRAC_GE_4(X,T))\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    S##_f[0] = T##_f[0] + q;\t\t\t\t\\\n-\t    S##_f[1] += (T##_f[0] > S##_f[0]);\t\t\t\\\n-\t    S##_f[2] += (T##_f[1] > S##_f[1]);\t\t\t\\\n-\t    S##_f[3] += (T##_f[2] > S##_f[2]);\t\t\t\\\n-\t    _FP_FRAC_DEC_4(X, T);\t\t\t\t\\\n-\t    R##_f[0] += q;\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\t_FP_FRAC_SLL_4(X, 1);\t\t\t\t\t\\\n-\tq >>= 1;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    if (!_FP_FRAC_ZEROP_4(X))\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tif (_FP_FRAC_GT_4(X,S))\t\t\t\t\t\\\n-\t  R##_f[0] |= _FP_WORK_ROUND;\t\t\t\t\\\n-\tR##_f[0] |= _FP_WORK_STICKY;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_SQRT_MEAT_4(R, S, T, X, q)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      while (q)\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  T##_f[3] = S##_f[3] + q;\t\t\t\t\t\\\n+\t  if (T##_f[3] <= X##_f[3])\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      S##_f[3] = T##_f[3] + q;\t\t\t\t\t\\\n+\t      X##_f[3] -= T##_f[3];\t\t\t\t\t\\\n+\t      R##_f[3] += q;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SLL_4 (X, 1);\t\t\t\t\t\\\n+\t  q >>= 1;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      q = (_FP_W_TYPE) 1 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n+      while (q)\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  T##_f[2] = S##_f[2] + q;\t\t\t\t\t\\\n+\t  T##_f[3] = S##_f[3];\t\t\t\t\t\t\\\n+\t  if (T##_f[3] < X##_f[3]\t\t\t\t\t\\\n+\t      || (T##_f[3] == X##_f[3] && T##_f[2] <= X##_f[2]))\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      S##_f[2] = T##_f[2] + q;\t\t\t\t\t\\\n+\t      S##_f[3] += (T##_f[2] > S##_f[2]);\t\t\t\\\n+\t      __FP_FRAC_DEC_2 (X##_f[3], X##_f[2],\t\t\t\\\n+\t\t\t       T##_f[3], T##_f[2]);\t\t\t\\\n+\t      R##_f[2] += q;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SLL_4 (X, 1);\t\t\t\t\t\\\n+\t  q >>= 1;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      q = (_FP_W_TYPE) 1 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n+      while (q)\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  T##_f[1] = S##_f[1] + q;\t\t\t\t\t\\\n+\t  T##_f[2] = S##_f[2];\t\t\t\t\t\t\\\n+\t  T##_f[3] = S##_f[3];\t\t\t\t\t\t\\\n+\t  if (T##_f[3] < X##_f[3]\t\t\t\t\t\\\n+\t      || (T##_f[3] == X##_f[3]\t\t\t\t\t\\\n+\t\t  && (T##_f[2] < X##_f[2]\t\t\t\t\\\n+\t\t      || (T##_f[2] == X##_f[2]\t\t\t\t\\\n+\t\t\t  && T##_f[1] <= X##_f[1]))))\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      S##_f[1] = T##_f[1] + q;\t\t\t\t\t\\\n+\t      S##_f[2] += (T##_f[1] > S##_f[1]);\t\t\t\\\n+\t      S##_f[3] += (T##_f[2] > S##_f[2]);\t\t\t\\\n+\t      __FP_FRAC_DEC_3 (X##_f[3], X##_f[2], X##_f[1],\t\t\\\n+\t\t\t       T##_f[3], T##_f[2], T##_f[1]);\t\t\\\n+\t      R##_f[1] += q;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SLL_4 (X, 1);\t\t\t\t\t\\\n+\t  q >>= 1;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      q = (_FP_W_TYPE) 1 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n+      while (q != _FP_WORK_ROUND)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  T##_f[0] = S##_f[0] + q;\t\t\t\t\t\\\n+\t  T##_f[1] = S##_f[1];\t\t\t\t\t\t\\\n+\t  T##_f[2] = S##_f[2];\t\t\t\t\t\t\\\n+\t  T##_f[3] = S##_f[3];\t\t\t\t\t\t\\\n+\t  if (_FP_FRAC_GE_4 (X, T))\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      S##_f[0] = T##_f[0] + q;\t\t\t\t\t\\\n+\t      S##_f[1] += (T##_f[0] > S##_f[0]);\t\t\t\\\n+\t      S##_f[2] += (T##_f[1] > S##_f[1]);\t\t\t\\\n+\t      S##_f[3] += (T##_f[2] > S##_f[2]);\t\t\t\\\n+\t      _FP_FRAC_DEC_4 (X, T);\t\t\t\t\t\\\n+\t      R##_f[0] += q;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SLL_4 (X, 1);\t\t\t\t\t\\\n+\t  q >>= 1;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (!_FP_FRAC_ZEROP_4 (X))\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (_FP_FRAC_GT_4 (X, S))\t\t\t\t\t\\\n+\t    R##_f[0] |= _FP_WORK_ROUND;\t\t\t\t\t\\\n+\t  R##_f[0] |= _FP_WORK_STICKY;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n  * Internals\n  */\n \n-#define __FP_FRAC_SET_4(X,I3,I2,I1,I0)\t\t\t\t\t\\\n+#define __FP_FRAC_SET_4(X, I3, I2, I1, I0)\t\t\t\\\n   (X##_f[3] = I3, X##_f[2] = I2, X##_f[1] = I1, X##_f[0] = I0)\n \n #ifndef __FP_FRAC_ADD_3\n-#define __FP_FRAC_ADD_3(r2,r1,r0,x2,x1,x0,y2,y1,y0)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    _FP_W_TYPE _c1, _c2;\t\t\t\t\t\\\n-    r0 = x0 + y0;\t\t\t\t\t\t\\\n-    _c1 = r0 < x0;\t\t\t\t\t\t\\\n-    r1 = x1 + y1;\t\t\t\t\t\t\\\n-    _c2 = r1 < x1;\t\t\t\t\t\t\\\n-    r1 += _c1;\t\t\t\t\t\t\t\\\n-    _c2 |= r1 < _c1;\t\t\t\t\t\t\\\n-    r2 = x2 + y2 + _c2;\t\t\t\t\t\t\\\n-  } while (0)\n+# define __FP_FRAC_ADD_3(r2, r1, r0, x2, x1, x0, y2, y1, y0)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      _FP_W_TYPE __FP_FRAC_ADD_3_c1, __FP_FRAC_ADD_3_c2;\t\\\n+      r0 = x0 + y0;\t\t\t\t\t\t\\\n+      __FP_FRAC_ADD_3_c1 = r0 < x0;\t\t\t\t\\\n+      r1 = x1 + y1;\t\t\t\t\t\t\\\n+      __FP_FRAC_ADD_3_c2 = r1 < x1;\t\t\t\t\\\n+      r1 += __FP_FRAC_ADD_3_c1;\t\t\t\t\t\\\n+      __FP_FRAC_ADD_3_c2 |= r1 < __FP_FRAC_ADD_3_c1;\t\t\\\n+      r2 = x2 + y2 + __FP_FRAC_ADD_3_c2;\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n #ifndef __FP_FRAC_ADD_4\n-#define __FP_FRAC_ADD_4(r3,r2,r1,r0,x3,x2,x1,x0,y3,y2,y1,y0)\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    _FP_W_TYPE _c1, _c2, _c3;\t\t\t\t\t\\\n-    r0 = x0 + y0;\t\t\t\t\t\t\\\n-    _c1 = r0 < x0;\t\t\t\t\t\t\\\n-    r1 = x1 + y1;\t\t\t\t\t\t\\\n-    _c2 = r1 < x1;\t\t\t\t\t\t\\\n-    r1 += _c1;\t\t\t\t\t\t\t\\\n-    _c2 |= r1 < _c1;\t\t\t\t\t\t\\\n-    r2 = x2 + y2;\t\t\t\t\t\t\\\n-    _c3 = r2 < x2;\t\t\t\t\t\t\\\n-    r2 += _c2;\t\t\t\t\t\t\t\\\n-    _c3 |= r2 < _c2;\t\t\t\t\t\t\\\n-    r3 = x3 + y3 + _c3;\t\t\t\t\t\t\\\n-  } while (0)\n+# define __FP_FRAC_ADD_4(r3, r2, r1, r0, x3, x2, x1, x0, y3, y2, y1, y0) \\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_W_TYPE _c1, _c2, _c3;\t\t\t\t\t\t\\\n+      r0 = x0 + y0;\t\t\t\t\t\t\t\\\n+      _c1 = r0 < x0;\t\t\t\t\t\t\t\\\n+      r1 = x1 + y1;\t\t\t\t\t\t\t\\\n+      _c2 = r1 < x1;\t\t\t\t\t\t\t\\\n+      r1 += _c1;\t\t\t\t\t\t\t\\\n+      _c2 |= r1 < _c1;\t\t\t\t\t\t\t\\\n+      r2 = x2 + y2;\t\t\t\t\t\t\t\\\n+      _c3 = r2 < x2;\t\t\t\t\t\t\t\\\n+      r2 += _c2;\t\t\t\t\t\t\t\\\n+      _c3 |= r2 < _c2;\t\t\t\t\t\t\t\\\n+      r3 = x3 + y3 + _c3;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n #ifndef __FP_FRAC_SUB_3\n-#define __FP_FRAC_SUB_3(r2,r1,r0,x2,x1,x0,y2,y1,y0)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    _FP_W_TYPE _c1, _c2;\t\t\t\t\t\\\n-    r0 = x0 - y0;\t\t\t\t\t\t\\\n-    _c1 = r0 > x0;\t\t\t\t\t\t\\\n-    r1 = x1 - y1;\t\t\t\t\t\t\\\n-    _c2 = r1 > x1;\t\t\t\t\t\t\\\n-    r1 -= _c1;\t\t\t\t\t\t\t\\\n-    _c2 |= _c1 && (y1 == x1);\t\t\t\t\t\\\n-    r2 = x2 - y2 - _c2;\t\t\t\t\t\t\\\n-  } while (0)\n+# define __FP_FRAC_SUB_3(r2, r1, r0, x2, x1, x0, y2, y1, y0)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      _FP_W_TYPE _c1, _c2;\t\t\t\t\t\\\n+      r0 = x0 - y0;\t\t\t\t\t\t\\\n+      _c1 = r0 > x0;\t\t\t\t\t\t\\\n+      r1 = x1 - y1;\t\t\t\t\t\t\\\n+      _c2 = r1 > x1;\t\t\t\t\t\t\\\n+      r1 -= _c1;\t\t\t\t\t\t\\\n+      _c2 |= _c1 && (y1 == x1);\t\t\t\t\t\\\n+      r2 = x2 - y2 - _c2;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n #ifndef __FP_FRAC_SUB_4\n-#define __FP_FRAC_SUB_4(r3,r2,r1,r0,x3,x2,x1,x0,y3,y2,y1,y0)\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    _FP_W_TYPE _c1, _c2, _c3;\t\t\t\t\t\\\n-    r0 = x0 - y0;\t\t\t\t\t\t\\\n-    _c1 = r0 > x0;\t\t\t\t\t\t\\\n-    r1 = x1 - y1;\t\t\t\t\t\t\\\n-    _c2 = r1 > x1;\t\t\t\t\t\t\\\n-    r1 -= _c1;\t\t\t\t\t\t\t\\\n-    _c2 |= _c1 && (y1 == x1);\t\t\t\t\t\\\n-    r2 = x2 - y2;\t\t\t\t\t\t\\\n-    _c3 = r2 > x2;\t\t\t\t\t\t\\\n-    r2 -= _c2;\t\t\t\t\t\t\t\\\n-    _c3 |= _c2 && (y2 == x2);\t\t\t\t\t\\\n-    r3 = x3 - y3 - _c3;\t\t\t\t\t\t\\\n-  } while (0)\n+# define __FP_FRAC_SUB_4(r3, r2, r1, r0, x3, x2, x1, x0, y3, y2, y1, y0) \\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_W_TYPE _c1, _c2, _c3;\t\t\t\t\t\t\\\n+      r0 = x0 - y0;\t\t\t\t\t\t\t\\\n+      _c1 = r0 > x0;\t\t\t\t\t\t\t\\\n+      r1 = x1 - y1;\t\t\t\t\t\t\t\\\n+      _c2 = r1 > x1;\t\t\t\t\t\t\t\\\n+      r1 -= _c1;\t\t\t\t\t\t\t\\\n+      _c2 |= _c1 && (y1 == x1);\t\t\t\t\t\t\\\n+      r2 = x2 - y2;\t\t\t\t\t\t\t\\\n+      _c3 = r2 > x2;\t\t\t\t\t\t\t\\\n+      r2 -= _c2;\t\t\t\t\t\t\t\\\n+      _c3 |= _c2 && (y2 == x2);\t\t\t\t\t\t\\\n+      r3 = x3 - y3 - _c3;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n #ifndef __FP_FRAC_DEC_3\n-#define __FP_FRAC_DEC_3(x2,x1,x0,y2,y1,y0)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    UWtype _t0, _t1, _t2;\t\t\t\t\t\t\\\n-    _t0 = x0, _t1 = x1, _t2 = x2;\t\t\t\t\t\\\n-    __FP_FRAC_SUB_3 (x2, x1, x0, _t2, _t1, _t0, y2, y1, y0);\t\t\\\n-  } while (0)\n+# define __FP_FRAC_DEC_3(x2, x1, x0, y2, y1, y0)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      UWtype _t0, _t1, _t2;\t\t\t\t\t\\\n+      _t0 = x0, _t1 = x1, _t2 = x2;\t\t\t\t\\\n+      __FP_FRAC_SUB_3 (x2, x1, x0, _t2, _t1, _t0, y2, y1, y0);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n #ifndef __FP_FRAC_DEC_4\n-#define __FP_FRAC_DEC_4(x3,x2,x1,x0,y3,y2,y1,y0)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    UWtype _t0, _t1, _t2, _t3;\t\t\t\t\t\t\\\n-    _t0 = x0, _t1 = x1, _t2 = x2, _t3 = x3;\t\t\t\t\\\n-    __FP_FRAC_SUB_4 (x3,x2,x1,x0,_t3,_t2,_t1,_t0, y3,y2,y1,y0);\t\t\\\n-  } while (0)\n+# define __FP_FRAC_DEC_4(x3, x2, x1, x0, y3, y2, y1, y0)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      UWtype _t0, _t1, _t2, _t3;\t\t\t\t\t\\\n+      _t0 = x0, _t1 = x1, _t2 = x2, _t3 = x3;\t\t\t\t\\\n+      __FP_FRAC_SUB_4 (x3, x2, x1, x0, _t3, _t2, _t1, _t0, y3, y2, y1, y0); \\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n #ifndef __FP_FRAC_ADDI_4\n-#define __FP_FRAC_ADDI_4(x3,x2,x1,x0,i)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    UWtype _t;\t\t\t\t\t\t\t\t\\\n-    _t = ((x0 += i) < i);\t\t\t\t\t\t\\\n-    x1 += _t; _t = (x1 < _t);\t\t\t\t\t\t\\\n-    x2 += _t; _t = (x2 < _t);\t\t\t\t\t\t\\\n-    x3 += _t;\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+# define __FP_FRAC_ADDI_4(x3, x2, x1, x0, i)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      UWtype _t;\t\t\t\t\\\n+      _t = ((x0 += i) < i);\t\t\t\\\n+      x1 += _t;\t\t\t\t\t\\\n+      _t = (x1 < _t);\t\t\t\t\\\n+      x2 += _t;\t\t\t\t\t\\\n+      _t = (x2 < _t);\t\t\t\t\\\n+      x3 += _t;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n /* Convert FP values between word sizes. This appears to be more\n@@ -625,63 +690,73 @@\n #define _FP_FRAC_COPY_1_4(D, S)\t\t(D##_f = S##_f[0])\n \n #define _FP_FRAC_COPY_2_4(D, S)\t\t\t\\\n-do {\t\t\t\t\t\t\\\n-  D##_f0 = S##_f[0];\t\t\t\t\\\n-  D##_f1 = S##_f[1];\t\t\t\t\\\n-} while (0)\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      D##_f0 = S##_f[0];\t\t\t\\\n+      D##_f1 = S##_f[1];\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* Assembly/disassembly for converting to/from integral types.\n  * No shifting or overflow handled here.\n  */\n /* Put the FP value X into r, which is an integer of size rsize. */\n #define _FP_FRAC_ASSEMBLE_4(r, X, rsize)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (rsize <= _FP_W_TYPE_SIZE)\t\t\t\t\t\\\n-      r = X##_f[0];\t\t\t\t\t\t\t\\\n-    else if (rsize <= 2*_FP_W_TYPE_SIZE)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      r = X##_f[1];\t\t\t\t\t\t\t\\\n-      r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\t\\\n-      r += X##_f[0];\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      /* I'm feeling lazy so we deal with int == 3words (implausible)*/\t\\\n-      /* and int == 4words as a single case.\t\t\t */\t\\\n-      r = X##_f[3];\t\t\t\t\t\t\t\\\n-      r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\t\\\n-      r += X##_f[2];\t\t\t\t\t\t\t\\\n-      r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\t\\\n-      r += X##_f[1];\t\t\t\t\t\t\t\\\n-      r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\t\\\n-      r += X##_f[0];\t\t\t\t\t\t\t\\\n+      if (rsize <= _FP_W_TYPE_SIZE)\t\t\t\t\t\\\n+\tr = X##_f[0];\t\t\t\t\t\t\t\\\n+      else if (rsize <= 2*_FP_W_TYPE_SIZE)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  r = X##_f[1];\t\t\t\t\t\t\t\\\n+\t  r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+\t  r += X##_f[0];\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* I'm feeling lazy so we deal with int == 3words (implausible)*/ \\\n+\t  /* and int == 4words as a single case.\t\t\t */ \\\n+\t  r = X##_f[3];\t\t\t\t\t\t\t\\\n+\t  r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+\t  r += X##_f[2];\t\t\t\t\t\t\\\n+\t  r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+\t  r += X##_f[1];\t\t\t\t\t\t\\\n+\t  r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+\t  r += X##_f[0];\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+  while (0)\n \n /* \"No disassemble Number Five!\" */\n /* move an integer of size rsize into X's fractional part. We rely on\n  * the _f[] array consisting of words of size _FP_W_TYPE_SIZE to avoid\n  * having to mask the values we store into it.\n  */\n #define _FP_FRAC_DISASSEMBLE_4(X, r, rsize)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    X##_f[0] = r;\t\t\t\t\t\t\t\\\n-    X##_f[1] = (rsize <= _FP_W_TYPE_SIZE ? 0 : r >> _FP_W_TYPE_SIZE);\t\\\n-    X##_f[2] = (rsize <= 2*_FP_W_TYPE_SIZE ? 0 : r >> 2*_FP_W_TYPE_SIZE); \\\n-    X##_f[3] = (rsize <= 3*_FP_W_TYPE_SIZE ? 0 : r >> 3*_FP_W_TYPE_SIZE); \\\n-  } while (0);\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      X##_f[0] = r;\t\t\t\t\t\t\t\\\n+      X##_f[1] = (rsize <= _FP_W_TYPE_SIZE ? 0 : r >> _FP_W_TYPE_SIZE);\t\\\n+      X##_f[2] = (rsize <= 2*_FP_W_TYPE_SIZE ? 0 : r >> 2*_FP_W_TYPE_SIZE); \\\n+      X##_f[3] = (rsize <= 3*_FP_W_TYPE_SIZE ? 0 : r >> 3*_FP_W_TYPE_SIZE); \\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n #define _FP_FRAC_COPY_4_1(D, S)\t\t\t\\\n-do {\t\t\t\t\t\t\\\n-  D##_f[0] = S##_f;\t\t\t\t\\\n-  D##_f[1] = D##_f[2] = D##_f[3] = 0;\t\t\\\n-} while (0)\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      D##_f[0] = S##_f;\t\t\t\t\\\n+      D##_f[1] = D##_f[2] = D##_f[3] = 0;\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n #define _FP_FRAC_COPY_4_2(D, S)\t\t\t\\\n-do {\t\t\t\t\t\t\\\n-  D##_f[0] = S##_f0;\t\t\t\t\\\n-  D##_f[1] = S##_f1;\t\t\t\t\\\n-  D##_f[2] = D##_f[3] = 0;\t\t\t\\\n-} while (0)\n-\n-#define _FP_FRAC_COPY_4_4(D,S)\t_FP_FRAC_COPY_4(D,S)\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      D##_f[0] = S##_f0;\t\t\t\\\n+      D##_f[1] = S##_f1;\t\t\t\\\n+      D##_f[2] = D##_f[3] = 0;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_FRAC_COPY_4_4(D, S)\t_FP_FRAC_COPY_4 (D, S)"}, {"sha": "f1b23db80dbf94388b64127be306ccd7d4acc16c", "filename": "libgcc/soft-fp/op-8.h", "status": "modified", "additions": 71, "deletions": 64, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fop-8.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fop-8.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fop-8.h?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -34,76 +34,83 @@\n #define _FP_FRAC_DECL_8(X)\t_FP_W_TYPE X##_f[8]\n #define _FP_FRAC_HIGH_8(X)\t(X##_f[7])\n #define _FP_FRAC_LOW_8(X)\t(X##_f[0])\n-#define _FP_FRAC_WORD_8(X,w)\t(X##_f[w])\n+#define _FP_FRAC_WORD_8(X, w)\t(X##_f[w])\n \n-#define _FP_FRAC_SLL_8(X,N)\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\t\t\\\n-    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n-    _up = (N) % _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n-    _down = _FP_W_TYPE_SIZE - _up;\t\t\t\t\t\\\n-    if (!_up)\t\t\t\t\t\t\t\t\\\n-      for (_i = 7; _i >= _skip; --_i)\t\t\t\t\t\\\n-\tX##_f[_i] = X##_f[_i-_skip];\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfor (_i = 7; _i > _skip; --_i)\t\t\t\t\t\\\n-\t  X##_f[_i] = X##_f[_i-_skip] << _up\t\t\t\t\\\n-\t\t      | X##_f[_i-_skip-1] >> _down;\t\t\t\\\n-\tX##_f[_i--] = X##_f[0] << _up; \t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    for (; _i >= 0; --_i)\t\t\t\t\t\t\\\n-      X##_f[_i] = 0;\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_FRAC_SLL_8(X, N)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\\\n+      _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\\\n+      _up = (N) % _FP_W_TYPE_SIZE;\t\t\t\\\n+      _down = _FP_W_TYPE_SIZE - _up;\t\t\t\\\n+      if (!_up)\t\t\t\t\t\t\\\n+\tfor (_i = 7; _i >= _skip; --_i)\t\t\t\\\n+\t  X##_f[_i] = X##_f[_i-_skip];\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  for (_i = 7; _i > _skip; --_i)\t\t\\\n+\t    X##_f[_i] = (X##_f[_i-_skip] << _up\t\t\\\n+\t\t\t | X##_f[_i-_skip-1] >> _down);\t\\\n+\t  X##_f[_i--] = X##_f[0] << _up;\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      for (; _i >= 0; --_i)\t\t\t\t\\\n+\tX##_f[_i] = 0;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n-#define _FP_FRAC_SRL_8(X,N)\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\t\t\\\n-    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n-    _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n-    _up = _FP_W_TYPE_SIZE - _down;\t\t\t\t\t\\\n-    if (!_down)\t\t\t\t\t\t\t\t\\\n-      for (_i = 0; _i <= 7-_skip; ++_i)\t\t\t\t\t\\\n-\tX##_f[_i] = X##_f[_i+_skip];\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfor (_i = 0; _i < 7-_skip; ++_i)\t\t\t\t\\\n-\t  X##_f[_i] = X##_f[_i+_skip] >> _down\t\t\t\t\\\n-\t\t      | X##_f[_i+_skip+1] << _up;\t\t\t\\\n-\tX##_f[_i++] = X##_f[7] >> _down;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    for (; _i < 8; ++_i)\t\t\t\t\t\t\\\n-      X##_f[_i] = 0;\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_FRAC_SRL_8(X, N)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\\\n+      _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\\\n+      _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\\\n+      _up = _FP_W_TYPE_SIZE - _down;\t\t\t\\\n+      if (!_down)\t\t\t\t\t\\\n+\tfor (_i = 0; _i <= 7-_skip; ++_i)\t\t\\\n+\t  X##_f[_i] = X##_f[_i+_skip];\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  for (_i = 0; _i < 7-_skip; ++_i)\t\t\\\n+\t    X##_f[_i] = (X##_f[_i+_skip] >> _down\t\\\n+\t\t\t | X##_f[_i+_skip+1] << _up);\t\\\n+\t  X##_f[_i++] = X##_f[7] >> _down;\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      for (; _i < 8; ++_i)\t\t\t\t\\\n+\tX##_f[_i] = 0;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /* Right shift with sticky-lsb.\n  * What this actually means is that we do a standard right-shift,\n  * but that if any of the bits that fall off the right hand side\n  * were one then we always set the LSbit.\n  */\n-#define _FP_FRAC_SRS_8(X,N,size)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\t\t\\\n-    _FP_W_TYPE _s;\t\t\t\t\t\t\t\\\n-    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n-    _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n-    _up = _FP_W_TYPE_SIZE - _down;\t\t\t\t\t\\\n-    for (_s = _i = 0; _i < _skip; ++_i)\t\t\t\t\t\\\n-      _s |= X##_f[_i];\t\t\t\t\t\t\t\\\n-    if (!_down)\t\t\t\t\t\t\t\t\\\n-      for (_i = 0; _i <= 7-_skip; ++_i)\t\t\t\t\t\\\n-\tX##_f[_i] = X##_f[_i+_skip];\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t_s |= X##_f[_i] << _up;\t\t\t\t\t\t\\\n-\tfor (_i = 0; _i < 7-_skip; ++_i)\t\t\t\t\\\n-\t  X##_f[_i] = X##_f[_i+_skip] >> _down\t\t\t\t\\\n-\t\t      | X##_f[_i+_skip+1] << _up;\t\t\t\\\n-\tX##_f[_i++] = X##_f[7] >> _down;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    for (; _i < 8; ++_i)\t\t\t\t\t\t\\\n-      X##_f[_i] = 0;\t\t\t\t\t\t\t\\\n-    /* don't fix the LSB until the very end when we're sure f[0] is stable */\t\\\n-    X##_f[0] |= (_s != 0);\t\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_FRAC_SRS_8(X, N, size)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\t\t\\\n+      _FP_W_TYPE _s;\t\t\t\t\t\t\t\\\n+      _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+      _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+      _up = _FP_W_TYPE_SIZE - _down;\t\t\t\t\t\\\n+      for (_s = _i = 0; _i < _skip; ++_i)\t\t\t\t\\\n+\t_s |= X##_f[_i];\t\t\t\t\t\t\\\n+      if (!_down)\t\t\t\t\t\t\t\\\n+\tfor (_i = 0; _i <= 7-_skip; ++_i)\t\t\t\t\\\n+\t  X##_f[_i] = X##_f[_i+_skip];\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _s |= X##_f[_i] << _up;\t\t\t\t\t\\\n+\t  for (_i = 0; _i < 7-_skip; ++_i)\t\t\t\t\\\n+\t    X##_f[_i] = (X##_f[_i+_skip] >> _down\t\t\t\\\n+\t\t\t | X##_f[_i+_skip+1] << _up);\t\t\t\\\n+\t  X##_f[_i++] = X##_f[7] >> _down;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      for (; _i < 8; ++_i)\t\t\t\t\t\t\\\n+\tX##_f[_i] = 0;\t\t\t\t\t\t\t\\\n+      /* don't fix the LSB until the very end when we're sure f[0] is\t\\\n+\t stable */\t\t\t\t\t\t\t\\\n+      X##_f[0] |= (_s != 0);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)"}, {"sha": "67cdc33b4cf9eef360780b8506a55af349d7d6b7", "filename": "libgcc/soft-fp/op-common.h", "status": "modified", "additions": 1480, "deletions": 1209, "changes": 2689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fop-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fop-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fop-common.h?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -30,145 +30,157 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #define _FP_DECL(wc, X)\t\t\t\t\\\n-  _FP_I_TYPE X##_c __attribute__((unused));\t\\\n-  _FP_I_TYPE X##_s __attribute__((unused));\t\\\n+  _FP_I_TYPE X##_c __attribute__ ((unused));\t\\\n+  _FP_I_TYPE X##_s __attribute__ ((unused));\t\\\n   _FP_I_TYPE X##_e;\t\t\t\t\\\n-  _FP_FRAC_DECL_##wc(X)\n+  _FP_FRAC_DECL_##wc (X)\n \n /* Test whether the qNaN bit denotes a signaling NaN.  */\n-#define _FP_FRAC_SNANP(fs, X)\t\t\t\t\t\t\\\n-  ((_FP_QNANNEGATEDP)\t\t\t\t\t\t\t\\\n-   ? (_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\t\\\n-   : !(_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs))\n-#define _FP_FRAC_SNANP_SEMIRAW(fs, X)\t\t\t\t\t\\\n-  ((_FP_QNANNEGATEDP)\t\t\t\t\t\t\t\\\n-   ? (_FP_FRAC_HIGH_##fs(X) & _FP_QNANBIT_SH_##fs)\t\t\t\\\n-   : !(_FP_FRAC_HIGH_##fs(X) & _FP_QNANBIT_SH_##fs))\n+#define _FP_FRAC_SNANP(fs, X)\t\t\t\t\\\n+  ((_FP_QNANNEGATEDP)\t\t\t\t\t\\\n+   ? (_FP_FRAC_HIGH_RAW_##fs (X) & _FP_QNANBIT_##fs)\t\\\n+   : !(_FP_FRAC_HIGH_RAW_##fs (X) & _FP_QNANBIT_##fs))\n+#define _FP_FRAC_SNANP_SEMIRAW(fs, X)\t\t\t\\\n+  ((_FP_QNANNEGATEDP)\t\t\t\t\t\\\n+   ? (_FP_FRAC_HIGH_##fs (X) & _FP_QNANBIT_SH_##fs)\t\\\n+   : !(_FP_FRAC_HIGH_##fs (X) & _FP_QNANBIT_SH_##fs))\n \n /*\n- * Finish truely unpacking a native fp value by classifying the kind\n+ * Finish truly unpacking a native fp value by classifying the kind\n  * of fp value and normalizing both the exponent and the fraction.\n  */\n \n-#define _FP_UNPACK_CANONICAL(fs, wc, X)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  switch (X##_e)\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-  default:\t\t\t\t\t\t\t\t\\\n-    _FP_FRAC_HIGH_RAW_##fs(X) |= _FP_IMPLBIT_##fs;\t\t\t\\\n-    _FP_FRAC_SLL_##wc(X, _FP_WORKBITS);\t\t\t\t\t\\\n-    X##_e -= _FP_EXPBIAS_##fs;\t\t\t\t\t\t\\\n-    X##_c = FP_CLS_NORMAL;\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case 0:\t\t\t\t\t\t\t\t\\\n-    if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t\t\t\\\n-      X##_c = FP_CLS_ZERO;\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t/* a denormalized number */\t\t\t\t\t\\\n-\t_FP_I_TYPE _shift;\t\t\t\t\t\t\\\n-\t_FP_FRAC_CLZ_##wc(_shift, X);\t\t\t\t\t\\\n-\t_shift -= _FP_FRACXBITS_##fs;\t\t\t\t\t\\\n-\t_FP_FRAC_SLL_##wc(X, (_shift+_FP_WORKBITS));\t\t\t\\\n-\tX##_e -= _FP_EXPBIAS_##fs - 1 + _shift;\t\t\t\t\\\n-\tX##_c = FP_CLS_NORMAL;\t\t\t\t\t\t\\\n-\tFP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  case _FP_EXPMAX_##fs:\t\t\t\t\t\t\t\\\n-    if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t\t\t\\\n-      X##_c = FP_CLS_INF;\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tX##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n-\t/* Check for signaling NaN */\t\t\t\t\t\\\n-\tif (_FP_FRAC_SNANP(fs, X))\t\t\t\t\t\\\n-\t  FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+#define _FP_UNPACK_CANONICAL(fs, wc, X)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      switch (X##_e)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\tdefault:\t\t\t\t\t\t\\\n+\t  _FP_FRAC_HIGH_RAW_##fs (X) |= _FP_IMPLBIT_##fs;\t\\\n+\t  _FP_FRAC_SLL_##wc (X, _FP_WORKBITS);\t\t\t\\\n+\t  X##_e -= _FP_EXPBIAS_##fs;\t\t\t\t\\\n+\t  X##_c = FP_CLS_NORMAL;\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase 0:\t\t\t\t\t\t\t\\\n+\t  if (_FP_FRAC_ZEROP_##wc (X))\t\t\t\t\\\n+\t    X##_c = FP_CLS_ZERO;\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      /* a denormalized number */\t\t\t\\\n+\t      _FP_I_TYPE _shift;\t\t\t\t\\\n+\t      _FP_FRAC_CLZ_##wc (_shift, X);\t\t\t\\\n+\t      _shift -= _FP_FRACXBITS_##fs;\t\t\t\\\n+\t      _FP_FRAC_SLL_##wc (X, (_shift+_FP_WORKBITS));\t\\\n+\t      X##_e -= _FP_EXPBIAS_##fs - 1 + _shift;\t\t\\\n+\t      X##_c = FP_CLS_NORMAL;\t\t\t\t\\\n+\t      FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_EXPMAX_##fs:\t\t\t\t\t\\\n+\t  if (_FP_FRAC_ZEROP_##wc (X))\t\t\t\t\\\n+\t    X##_c = FP_CLS_INF;\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      X##_c = FP_CLS_NAN;\t\t\t\t\\\n+\t      /* Check for signaling NaN */\t\t\t\\\n+\t      if (_FP_FRAC_SNANP (fs, X))\t\t\t\\\n+\t\tFP_SET_EXCEPTION (FP_EX_INVALID);\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Finish unpacking an fp value in semi-raw mode: the mantissa is\n    shifted by _FP_WORKBITS but the implicit MSB is not inserted and\n    other classification is not done.  */\n-#define _FP_UNPACK_SEMIRAW(fs, wc, X)\t_FP_FRAC_SLL_##wc(X, _FP_WORKBITS)\n+#define _FP_UNPACK_SEMIRAW(fs, wc, X)\t_FP_FRAC_SLL_##wc (X, _FP_WORKBITS)\n \n /* A semi-raw value has overflowed to infinity.  Adjust the mantissa\n    and exponent appropriately.  */\n #define _FP_OVERFLOW_SEMIRAW(fs, wc, X)\t\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-  if (FP_ROUNDMODE == FP_RND_NEAREST\t\t\t\\\n-      || (FP_ROUNDMODE == FP_RND_PINF && !X##_s)\t\\\n-      || (FP_ROUNDMODE == FP_RND_MINF && X##_s))\t\\\n+  do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      X##_e = _FP_EXPMAX_##fs;\t\t\t\t\\\n-      _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\t\\\n+      if (FP_ROUNDMODE == FP_RND_NEAREST\t\t\\\n+\t  || (FP_ROUNDMODE == FP_RND_PINF && !X##_s)\t\\\n+\t  || (FP_ROUNDMODE == FP_RND_MINF && X##_s))\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  X##_e = _FP_EXPMAX_##fs;\t\t\t\\\n+\t  _FP_FRAC_SET_##wc (X, _FP_ZEROFRAC_##wc);\t\\\n+\t}\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  X##_e = _FP_EXPMAX_##fs - 1;\t\t\t\\\n+\t  _FP_FRAC_SET_##wc (X, _FP_MAXFRAC_##wc);\t\\\n+\t}\t\t\t\t\t\t\\\n+      FP_SET_EXCEPTION (FP_EX_INEXACT);\t\t\t\\\n+      FP_SET_EXCEPTION (FP_EX_OVERFLOW);\t\t\\\n     }\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      X##_e = _FP_EXPMAX_##fs - 1;\t\t\t\\\n-      _FP_FRAC_SET_##wc(X, _FP_MAXFRAC_##wc);\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-    FP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\\\n-    FP_SET_EXCEPTION(FP_EX_OVERFLOW);\t\t\t\\\n-} while (0)\n+  while (0)\n \n /* Check for a semi-raw value being a signaling NaN and raise the\n    invalid exception if so.  */\n-#define _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  if (X##_e == _FP_EXPMAX_##fs\t\t\t\t\t\\\n-      && !_FP_FRAC_ZEROP_##wc(X)\t\t\t\t\\\n-      && _FP_FRAC_SNANP_SEMIRAW(fs, X))\t\t\t\t\\\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n-} while (0)\n+#define _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (X##_e == _FP_EXPMAX_##fs\t\t\\\n+\t  && !_FP_FRAC_ZEROP_##wc (X)\t\t\\\n+\t  && _FP_FRAC_SNANP_SEMIRAW (fs, X))\t\\\n+\tFP_SET_EXCEPTION (FP_EX_INVALID);\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* Choose a NaN result from an operation on two semi-raw NaN\n    values.  */\n #define _FP_CHOOSENAN_SEMIRAW(fs, wc, R, X, Y, OP)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  /* _FP_CHOOSENAN expects raw values, so shift as required.  */\t\\\n-  _FP_FRAC_SRL_##wc(X, _FP_WORKBITS);\t\t\t\t\t\\\n-  _FP_FRAC_SRL_##wc(Y, _FP_WORKBITS);\t\t\t\t\t\\\n-  _FP_CHOOSENAN(fs, wc, R, X, Y, OP);\t\t\t\t\t\\\n-  _FP_FRAC_SLL_##wc(R, _FP_WORKBITS);\t\t\t\t\t\\\n-} while (0)\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* _FP_CHOOSENAN expects raw values, so shift as required.  */\t\\\n+      _FP_FRAC_SRL_##wc (X, _FP_WORKBITS);\t\t\t\t\\\n+      _FP_FRAC_SRL_##wc (Y, _FP_WORKBITS);\t\t\t\t\\\n+      _FP_CHOOSENAN (fs, wc, R, X, Y, OP);\t\t\t\t\\\n+      _FP_FRAC_SLL_##wc (R, _FP_WORKBITS);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Make the fractional part a quiet NaN, preserving the payload\n    if possible, otherwise make it the canonical quiet NaN and set\n    the sign bit accordingly.  */\n-#define _FP_SETQNAN(fs, wc, X)\t\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (_FP_QNANNEGATEDP)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      _FP_FRAC_HIGH_RAW_##fs(X) &= _FP_QNANBIT_##fs - 1;\t\t\\\n-      if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  X##_s = _FP_NANSIGN_##fs;\t\t\t\t\t\\\n-\t  _FP_FRAC_SET_##wc(X, _FP_NANFRAC_##fs);\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    _FP_FRAC_HIGH_RAW_##fs(X) |= _FP_QNANBIT_##fs;\t\t\t\\\n-} while (0)\n-#define _FP_SETQNAN_SEMIRAW(fs, wc, X)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (_FP_QNANNEGATEDP)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      _FP_FRAC_HIGH_##fs(X) &= _FP_QNANBIT_SH_##fs - 1;\t\t\t\\\n-      if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  X##_s = _FP_NANSIGN_##fs;\t\t\t\t\t\\\n-\t  _FP_FRAC_SET_##wc(X, _FP_NANFRAC_##fs);\t\t\t\\\n-\t  _FP_FRAC_SLL_##wc(X, _FP_WORKBITS);\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    _FP_FRAC_HIGH_##fs(X) |= _FP_QNANBIT_SH_##fs;\t\t\t\\\n-} while (0)\n+#define _FP_SETQNAN(fs, wc, X)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (_FP_QNANNEGATEDP)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_HIGH_RAW_##fs (X) &= _FP_QNANBIT_##fs - 1;\t\\\n+\t  if (_FP_FRAC_ZEROP_##wc (X))\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      X##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+\t      _FP_FRAC_SET_##wc (X, _FP_NANFRAC_##fs);\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t_FP_FRAC_HIGH_RAW_##fs (X) |= _FP_QNANBIT_##fs;\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+#define _FP_SETQNAN_SEMIRAW(fs, wc, X)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (_FP_QNANNEGATEDP)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_HIGH_##fs (X) &= _FP_QNANBIT_SH_##fs - 1;\t\\\n+\t  if (_FP_FRAC_ZEROP_##wc (X))\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      X##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+\t      _FP_FRAC_SET_##wc (X, _FP_NANFRAC_##fs);\t\t\\\n+\t      _FP_FRAC_SLL_##wc (X, _FP_WORKBITS);\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t_FP_FRAC_HIGH_##fs (X) |= _FP_QNANBIT_SH_##fs;\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Test whether a biased exponent is normal (not zero or maximum).  */\n #define _FP_EXP_NORMAL(fs, wc, X)\t(((X##_e + 1) & _FP_EXPMAX_##fs) > 1)\n@@ -177,34 +189,36 @@ do {\t\t\t\t\t\t\t\t\t\\\n    rounded and shifted right, with the rounding possibly increasing\n    the exponent (including changing a finite value to infinity).  */\n #define _FP_PACK_SEMIRAW(fs, wc, X)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  _FP_ROUND(wc, X);\t\t\t\t\t\t\\\n-  if (X##_e == 0 && !_FP_FRAC_ZEROP_##wc(X))\t\t\t\\\n-\t{ \\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      _FP_ROUND (wc, X);\t\t\t\t\t\\\n+      if (X##_e == 0 && !_FP_FRAC_ZEROP_##wc (X))\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n \t  if ((FP_CUR_EXCEPTIONS & FP_EX_INEXACT)\t\t\\\n \t      || (FP_TRAPPING_EXCEPTIONS & FP_EX_UNDERFLOW))\t\\\n-\t    FP_SET_EXCEPTION(FP_EX_UNDERFLOW);\t\t\t\\\n-\t} \\\n-  if (_FP_FRAC_HIGH_##fs(X)\t\t\t\t\t\\\n-      & (_FP_OVERFLOW_##fs >> 1))\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      _FP_FRAC_HIGH_##fs(X) &= ~(_FP_OVERFLOW_##fs >> 1);\t\\\n-      X##_e++;\t\t\t\t\t\t\t\\\n-      if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t\\\n-\t_FP_OVERFLOW_SEMIRAW(fs, wc, X);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  _FP_FRAC_SRL_##wc(X, _FP_WORKBITS);\t\t\t\t\\\n-  if (X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(X))\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (!_FP_KEEPNANFRACP)\t\t\t\t\t\\\n+\t    FP_SET_EXCEPTION (FP_EX_UNDERFLOW);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      if (_FP_FRAC_HIGH_##fs (X)\t\t\t\t\\\n+\t  & (_FP_OVERFLOW_##fs >> 1))\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  _FP_FRAC_SET_##wc(X, _FP_NANFRAC_##fs);\t\t\\\n-\t  X##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+\t  _FP_FRAC_HIGH_##fs (X) &= ~(_FP_OVERFLOW_##fs >> 1);\t\\\n+\t  X##_e++;\t\t\t\t\t\t\\\n+\t  if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t\\\n+\t    _FP_OVERFLOW_SEMIRAW (fs, wc, X);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      _FP_FRAC_SRL_##wc (X, _FP_WORKBITS);\t\t\t\\\n+      if (X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc (X))\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (!_FP_KEEPNANFRACP)\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      _FP_FRAC_SET_##wc (X, _FP_NANFRAC_##fs);\t\t\\\n+\t      X##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    _FP_SETQNAN (fs, wc, X);\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t_FP_SETQNAN(fs, wc, X);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n-} while (0)\n+  while (0)\n \n /*\n  * Before packing the bits back into the native fp result, take care\n@@ -213,701 +227,927 @@ do {\t\t\t\t\t\t\t\t\\\n  * extracted -- but that is ok, we can regenerate them now.\n  */\n \n-#define _FP_PACK_CANONICAL(fs, wc, X)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  switch (X##_c)\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-  case FP_CLS_NORMAL:\t\t\t\t\t\t\\\n-    X##_e += _FP_EXPBIAS_##fs;\t\t\t\t\t\\\n-    if (X##_e > 0)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\t_FP_ROUND(wc, X);\t\t\t\t\t\\\n-\tif (_FP_FRAC_OVERP_##wc(fs, X))\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    _FP_FRAC_CLEAR_OVERP_##wc(fs, X);\t\t\t\\\n-\t    X##_e++;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\t_FP_FRAC_SRL_##wc(X, _FP_WORKBITS);\t\t\t\\\n-\tif (X##_e >= _FP_EXPMAX_##fs)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    /* overflow */\t\t\t\t\t\\\n-\t    switch (FP_ROUNDMODE)\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\\\n-\t      case FP_RND_NEAREST:\t\t\t\t\\\n-\t\tX##_c = FP_CLS_INF;\t\t\t\t\\\n-\t\tbreak;\t\t\t\t\t\t\\\n-\t      case FP_RND_PINF:\t\t\t\t\t\\\n-\t\tif (!X##_s) X##_c = FP_CLS_INF;\t\t\t\\\n-\t\tbreak;\t\t\t\t\t\t\\\n-\t      case FP_RND_MINF:\t\t\t\t\t\\\n-\t\tif (X##_s) X##_c = FP_CLS_INF;\t\t\t\\\n-\t\tbreak;\t\t\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\\\n-\t    if (X##_c == FP_CLS_INF)\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\\\n-\t\t/* Overflow to infinity */\t\t\t\\\n-\t\tX##_e = _FP_EXPMAX_##fs;\t\t\t\\\n-\t\t_FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\\\n-\t      }\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\\\n-\t\t/* Overflow to maximum normal */\t\t\\\n-\t\tX##_e = _FP_EXPMAX_##fs - 1;\t\t\t\\\n-\t\t_FP_FRAC_SET_##wc(X, _FP_MAXFRAC_##wc);\t\t\\\n-\t      }\t\t\t\t\t\t\t\\\n-\t    FP_SET_EXCEPTION(FP_EX_OVERFLOW);\t\t\t\\\n-            FP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\t/* we've got a denormalized number */\t\t\t\\\n-\tX##_e = -X##_e + 1;\t\t\t\t\t\\\n-\tif (X##_e <= _FP_WFRACBITS_##fs)\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    _FP_FRAC_SRS_##wc(X, X##_e, _FP_WFRACBITS_##fs);\t\\\n-\t    _FP_ROUND(wc, X);\t\t\t\t\t\\\n-\t    if (_FP_FRAC_HIGH_##fs(X)\t\t\t\t\\\n-\t\t& (_FP_OVERFLOW_##fs >> 1))\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\\\n-\t        X##_e = 1;\t\t\t\t\t\\\n-\t        _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\\\n-\t\tFP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\\\n-\t      }\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\\\n-\t\tX##_e = 0;\t\t\t\t\t\\\n-\t\t_FP_FRAC_SRL_##wc(X, _FP_WORKBITS);\t\t\\\n-\t      }\t\t\t\t\t\t\t\\\n-\t    if ((FP_CUR_EXCEPTIONS & FP_EX_INEXACT)\t\t\\\n-\t\t|| (FP_TRAPPING_EXCEPTIONS & FP_EX_UNDERFLOW))\t\\\n-\t      FP_SET_EXCEPTION(FP_EX_UNDERFLOW);\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    /* underflow to zero */\t\t\t\t\\\n-\t    X##_e = 0;\t\t\t\t\t\t\\\n-\t    if (!_FP_FRAC_ZEROP_##wc(X))\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\\\n-\t        _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);\t\t\\\n-\t        _FP_ROUND(wc, X);\t\t\t\t\\\n-\t        _FP_FRAC_LOW_##wc(X) >>= (_FP_WORKBITS);\t\\\n-\t      }\t\t\t\t\t\t\t\\\n-\t    FP_SET_EXCEPTION(FP_EX_UNDERFLOW);\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  case FP_CLS_ZERO:\t\t\t\t\t\t\\\n-    X##_e = 0;\t\t\t\t\t\t\t\\\n-    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\t\t\\\n-    break;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  case FP_CLS_INF:\t\t\t\t\t\t\\\n-    X##_e = _FP_EXPMAX_##fs;\t\t\t\t\t\\\n-    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\t\t\\\n-    break;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  case FP_CLS_NAN:\t\t\t\t\t\t\\\n-    X##_e = _FP_EXPMAX_##fs;\t\t\t\t\t\\\n-    if (!_FP_KEEPNANFRACP)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\t_FP_FRAC_SET_##wc(X, _FP_NANFRAC_##fs);\t\t\t\\\n-\tX##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      _FP_SETQNAN(fs, wc, X);\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\\\n-} while (0)\n+#define _FP_PACK_CANONICAL(fs, wc, X)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      switch (X##_c)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\tcase FP_CLS_NORMAL:\t\t\t\t\t\t\\\n+\t  X##_e += _FP_EXPBIAS_##fs;\t\t\t\t\t\\\n+\t  if (X##_e > 0)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      _FP_ROUND (wc, X);\t\t\t\t\t\\\n+\t      if (_FP_FRAC_OVERP_##wc (fs, X))\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  _FP_FRAC_CLEAR_OVERP_##wc (fs, X);\t\t\t\\\n+\t\t  X##_e++;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      _FP_FRAC_SRL_##wc (X, _FP_WORKBITS);\t\t\t\\\n+\t      if (X##_e >= _FP_EXPMAX_##fs)\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* overflow */\t\t\t\t\t\\\n+\t\t  switch (FP_ROUNDMODE)\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t    case FP_RND_NEAREST:\t\t\t\t\\\n+\t\t      X##_c = FP_CLS_INF;\t\t\t\t\\\n+\t\t      break;\t\t\t\t\t\t\\\n+\t\t    case FP_RND_PINF:\t\t\t\t\t\\\n+\t\t      if (!X##_s)\t\t\t\t\t\\\n+\t\t\tX##_c = FP_CLS_INF;\t\t\t\t\\\n+\t\t      break;\t\t\t\t\t\t\\\n+\t\t    case FP_RND_MINF:\t\t\t\t\t\\\n+\t\t      if (X##_s)\t\t\t\t\t\\\n+\t\t\tX##_c = FP_CLS_INF;\t\t\t\t\\\n+\t\t      break;\t\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  if (X##_c == FP_CLS_INF)\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      /* Overflow to infinity */\t\t\t\\\n+\t\t      X##_e = _FP_EXPMAX_##fs;\t\t\t\t\\\n+\t\t      _FP_FRAC_SET_##wc (X, _FP_ZEROFRAC_##wc);\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      /* Overflow to maximum normal */\t\t\t\\\n+\t\t      X##_e = _FP_EXPMAX_##fs - 1;\t\t\t\\\n+\t\t      _FP_FRAC_SET_##wc (X, _FP_MAXFRAC_##wc);\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  FP_SET_EXCEPTION (FP_EX_OVERFLOW);\t\t\t\\\n+\t\t  FP_SET_EXCEPTION (FP_EX_INEXACT);\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      /* we've got a denormalized number */\t\t\t\\\n+\t      X##_e = -X##_e + 1;\t\t\t\t\t\\\n+\t      if (X##_e <= _FP_WFRACBITS_##fs)\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  _FP_FRAC_SRS_##wc (X, X##_e, _FP_WFRACBITS_##fs);\t\\\n+\t\t  _FP_ROUND (wc, X);\t\t\t\t\t\\\n+\t\t  if (_FP_FRAC_HIGH_##fs (X)\t\t\t\t\\\n+\t\t      & (_FP_OVERFLOW_##fs >> 1))\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      X##_e = 1;\t\t\t\t\t\\\n+\t\t      _FP_FRAC_SET_##wc (X, _FP_ZEROFRAC_##wc);\t\t\\\n+\t\t      FP_SET_EXCEPTION (FP_EX_INEXACT);\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      X##_e = 0;\t\t\t\t\t\\\n+\t\t      _FP_FRAC_SRL_##wc (X, _FP_WORKBITS);\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  if ((FP_CUR_EXCEPTIONS & FP_EX_INEXACT)\t\t\\\n+\t\t      || (FP_TRAPPING_EXCEPTIONS & FP_EX_UNDERFLOW))\t\\\n+\t\t    FP_SET_EXCEPTION (FP_EX_UNDERFLOW);\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* underflow to zero */\t\t\t\t\\\n+\t\t  X##_e = 0;\t\t\t\t\t\t\\\n+\t\t  if (!_FP_FRAC_ZEROP_##wc (X))\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      _FP_FRAC_SET_##wc (X, _FP_MINFRAC_##wc);\t\t\\\n+\t\t      _FP_ROUND (wc, X);\t\t\t\t\\\n+\t\t      _FP_FRAC_LOW_##wc (X) >>= (_FP_WORKBITS);\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  FP_SET_EXCEPTION (FP_EX_UNDERFLOW);\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase FP_CLS_ZERO:\t\t\t\t\t\t\\\n+\t  X##_e = 0;\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SET_##wc (X, _FP_ZEROFRAC_##wc);\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase FP_CLS_INF:\t\t\t\t\t\t\\\n+\t  X##_e = _FP_EXPMAX_##fs;\t\t\t\t\t\\\n+\t  _FP_FRAC_SET_##wc (X, _FP_ZEROFRAC_##wc);\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase FP_CLS_NAN:\t\t\t\t\t\t\\\n+\t  X##_e = _FP_EXPMAX_##fs;\t\t\t\t\t\\\n+\t  if (!_FP_KEEPNANFRACP)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      _FP_FRAC_SET_##wc (X, _FP_NANFRAC_##fs);\t\t\t\\\n+\t      X##_s = _FP_NANSIGN_##fs;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    _FP_SETQNAN (fs, wc, X);\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* This one accepts raw argument and not cooked,  returns\n  * 1 if X is a signaling NaN.\n  */\n-#define _FP_ISSIGNAN(fs, wc, X)\t\t\t\t\t\\\n-({\t\t\t\t\t\t\t\t\\\n-  int __ret = 0;\t\t\t\t\t\t\\\n-  if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (!_FP_FRAC_ZEROP_##wc(X)\t\t\t\t\\\n-\t  && _FP_FRAC_SNANP(fs, X))\t\t\t\t\\\n-\t__ret = 1;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  __ret;\t\t\t\t\t\t\t\\\n-})\n+#define _FP_ISSIGNAN(fs, wc, X)\t\t\t\\\n+  ({\t\t\t\t\t\t\\\n+    int __ret = 0;\t\t\t\t\\\n+    if (X##_e == _FP_EXPMAX_##fs)\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tif (!_FP_FRAC_ZEROP_##wc (X)\t\t\\\n+\t    && _FP_FRAC_SNANP (fs, X))\t\t\\\n+\t  __ret = 1;\t\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+    __ret;\t\t\t\t\t\\\n+  })\n \n \n \n \n \n /* Addition on semi-raw values.  */\n-#define _FP_ADD_INTERNAL(fs, wc, R, X, Y, OP)\t\t\t\t \\\n-do {\t\t\t\t\t\t\t\t\t \\\n-  if (X##_s == Y##_s)\t\t\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      /* Addition.  */\t\t\t\t\t\t\t \\\n-      R##_s = X##_s;\t\t\t\t\t\t\t \\\n-      int ediff = X##_e - Y##_e;\t\t\t\t\t \\\n-      if (ediff > 0)\t\t\t\t\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  R##_e = X##_e;\t\t\t\t\t\t \\\n-\t  if (Y##_e == 0)\t\t\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      /* Y is zero or denormalized.  */\t\t\t\t \\\n-\t      if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n-\t\t  _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n-\t\t  goto add_done;\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t      else\t\t\t\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n-\t\t  ediff--;\t\t\t\t\t\t \\\n-\t\t  if (ediff == 0)\t\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      _FP_FRAC_ADD_##wc(R, X, Y);\t\t\t \\\n-\t\t      goto add3;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t \\\n-\t\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n-\t\t      goto add_done;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  goto add1;\t\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  else if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      /* X is NaN or Inf, Y is normal.  */\t\t\t \\\n-\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n-\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t\t \\\n-\t      goto add_done;\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-\t  /* Insert implicit MSB of Y.  */\t\t\t\t \\\n-\t  _FP_FRAC_HIGH_##fs(Y) |= _FP_IMPLBIT_SH_##fs;\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-\tadd1:\t\t\t\t\t\t\t\t \\\n-\t  /* Shift the mantissa of Y to the right EDIFF steps;\t\t \\\n-\t     remember to account later for the implicit MSB of X.  */\t \\\n-\t  if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t \\\n-\t    _FP_FRAC_SRS_##wc(Y, ediff, _FP_WFRACBITS_##fs);\t\t \\\n-\t  else if (!_FP_FRAC_ZEROP_##wc(Y))\t\t\t\t \\\n-\t    _FP_FRAC_SET_##wc(Y, _FP_MINFRAC_##wc);\t\t\t \\\n-\t  _FP_FRAC_ADD_##wc(R, X, Y);\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-      else if (ediff < 0)\t\t\t\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  ediff = -ediff;\t\t\t\t\t\t \\\n-\t  R##_e = Y##_e;\t\t\t\t\t\t \\\n-\t  if (X##_e == 0)\t\t\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      /* X is zero or denormalized.  */\t\t\t\t \\\n-\t      if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n-\t\t  _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n-\t\t  goto add_done;\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t      else\t\t\t\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n-\t\t  ediff--;\t\t\t\t\t\t \\\n-\t\t  if (ediff == 0)\t\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      _FP_FRAC_ADD_##wc(R, Y, X);\t\t\t \\\n-\t\t      goto add3;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t \\\n-\t\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n-\t\t      goto add_done;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  goto add2;\t\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  else if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      /* Y is NaN or Inf, X is normal.  */\t\t\t \\\n-\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n-\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t\t \\\n-\t      goto add_done;\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-\t  /* Insert implicit MSB of X.  */\t\t\t\t \\\n-\t  _FP_FRAC_HIGH_##fs(X) |= _FP_IMPLBIT_SH_##fs;\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-\tadd2:\t\t\t\t\t\t\t\t \\\n-\t  /* Shift the mantissa of X to the right EDIFF steps;\t\t \\\n-\t     remember to account later for the implicit MSB of Y.  */\t \\\n-\t  if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t \\\n-\t    _FP_FRAC_SRS_##wc(X, ediff, _FP_WFRACBITS_##fs);\t\t \\\n-\t  else if (!_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n-\t    _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);\t\t\t \\\n-\t  _FP_FRAC_ADD_##wc(R, Y, X);\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-      else\t\t\t\t\t\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  /* ediff == 0.  */\t\t\t\t\t\t \\\n-\t  if (!_FP_EXP_NORMAL(fs, wc, X))\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      if (X##_e == 0)\t\t\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  /* X and Y are zero or denormalized.  */\t\t \\\n-\t\t  R##_e = 0;\t\t\t\t\t\t \\\n-\t\t  if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      if (!_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n-\t\t\tFP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n-\t\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n-\t\t      goto add_done;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  else if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n-\t\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n-\t\t      goto add_done;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  else\t\t\t\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n-\t\t      _FP_FRAC_ADD_##wc(R, X, Y);\t\t\t \\\n-\t\t      if (_FP_FRAC_HIGH_##fs(R) & _FP_IMPLBIT_SH_##fs)\t \\\n-\t\t\t{\t\t\t\t\t\t \\\n-\t\t\t  /* Normalized result.  */\t\t\t \\\n-\t\t\t  _FP_FRAC_HIGH_##fs(R)\t\t\t\t \\\n-\t\t\t    &= ~(_FP_W_TYPE)_FP_IMPLBIT_SH_##fs;\t \\\n-\t\t\t  R##_e = 1;\t\t\t\t\t \\\n-\t\t\t}\t\t\t\t\t\t \\\n-\t\t      goto add_done;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t      else\t\t\t\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  /* X and Y are NaN or Inf.  */\t\t\t \\\n-\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n-\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n-\t\t  R##_e = _FP_EXPMAX_##fs;\t\t\t\t \\\n-\t\t  if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n-\t\t    _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n-\t\t  else if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n-\t\t    _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n-\t\t  else\t\t\t\t\t\t\t \\\n-\t\t    _FP_CHOOSENAN_SEMIRAW(fs, wc, R, X, Y, OP);\t\t \\\n-\t\t  goto add_done;\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  /* The exponents of X and Y, both normal, are equal.  The\t \\\n-\t     implicit MSBs will always add to increase the\t\t \\\n-\t     exponent.  */\t\t\t\t\t\t \\\n-\t  _FP_FRAC_ADD_##wc(R, X, Y);\t\t\t\t\t \\\n-\t  R##_e = X##_e + 1;\t\t\t\t\t\t \\\n-\t  _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);\t\t\t \\\n-\t  if (R##_e == _FP_EXPMAX_##fs)\t\t\t\t\t \\\n-\t    /* Overflow to infinity (depending on rounding mode).  */\t \\\n-\t    _FP_OVERFLOW_SEMIRAW(fs, wc, R);\t\t\t\t \\\n-\t  goto add_done;\t\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-    add3:\t\t\t\t\t\t\t\t \\\n-      if (_FP_FRAC_HIGH_##fs(R) & _FP_IMPLBIT_SH_##fs)\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  /* Overflow.  */\t\t\t\t\t\t \\\n-\t  _FP_FRAC_HIGH_##fs(R) &= ~(_FP_W_TYPE)_FP_IMPLBIT_SH_##fs;\t \\\n-\t  R##_e++;\t\t\t\t\t\t\t \\\n-\t  _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);\t\t\t \\\n-\t  if (R##_e == _FP_EXPMAX_##fs)\t\t\t\t\t \\\n-\t    /* Overflow to infinity (depending on rounding mode).  */\t \\\n-\t    _FP_OVERFLOW_SEMIRAW(fs, wc, R);\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-    add_done: ;\t\t\t\t\t\t\t\t \\\n-    }\t\t\t\t\t\t\t\t\t \\\n-  else\t\t\t\t\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      /* Subtraction.  */\t\t\t\t\t\t \\\n-      int ediff = X##_e - Y##_e;\t\t\t\t\t \\\n-      if (ediff > 0)\t\t\t\t\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  R##_e = X##_e;\t\t\t\t\t\t \\\n-\t  R##_s = X##_s;\t\t\t\t\t\t \\\n-\t  if (Y##_e == 0)\t\t\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      /* Y is zero or denormalized.  */\t\t\t\t \\\n-\t      if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n-\t\t  _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n-\t\t  goto sub_done;\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t      else\t\t\t\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n-\t\t  ediff--;\t\t\t\t\t\t \\\n-\t\t  if (ediff == 0)\t\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      _FP_FRAC_SUB_##wc(R, X, Y);\t\t\t \\\n-\t\t      goto sub3;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t \\\n-\t\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n-\t\t      goto sub_done;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  goto sub1;\t\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  else if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      /* X is NaN or Inf, Y is normal.  */\t\t\t \\\n-\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n-\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t\t \\\n-\t      goto sub_done;\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-\t  /* Insert implicit MSB of Y.  */\t\t\t\t \\\n-\t  _FP_FRAC_HIGH_##fs(Y) |= _FP_IMPLBIT_SH_##fs;\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-\tsub1:\t\t\t\t\t\t\t\t \\\n-\t  /* Shift the mantissa of Y to the right EDIFF steps;\t\t \\\n-\t     remember to account later for the implicit MSB of X.  */\t \\\n-\t  if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t \\\n-\t    _FP_FRAC_SRS_##wc(Y, ediff, _FP_WFRACBITS_##fs);\t\t \\\n-\t  else if (!_FP_FRAC_ZEROP_##wc(Y))\t\t\t\t \\\n-\t    _FP_FRAC_SET_##wc(Y, _FP_MINFRAC_##wc);\t\t\t \\\n-\t  _FP_FRAC_SUB_##wc(R, X, Y);\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-      else if (ediff < 0)\t\t\t\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  ediff = -ediff;\t\t\t\t\t\t \\\n-\t  R##_e = Y##_e;\t\t\t\t\t\t \\\n-\t  R##_s = Y##_s;\t\t\t\t\t\t \\\n-\t  if (X##_e == 0)\t\t\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      /* X is zero or denormalized.  */\t\t\t\t \\\n-\t      if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n-\t\t  _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n-\t\t  goto sub_done;\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t      else\t\t\t\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n-\t\t  ediff--;\t\t\t\t\t\t \\\n-\t\t  if (ediff == 0)\t\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      _FP_FRAC_SUB_##wc(R, Y, X);\t\t\t \\\n-\t\t      goto sub3;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t \\\n-\t\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n-\t\t      goto sub_done;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  goto sub2;\t\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  else if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      /* Y is NaN or Inf, X is normal.  */\t\t\t \\\n-\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n-\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t\t \\\n-\t      goto sub_done;\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-\t  /* Insert implicit MSB of X.  */\t\t\t\t \\\n-\t  _FP_FRAC_HIGH_##fs(X) |= _FP_IMPLBIT_SH_##fs;\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-\tsub2:\t\t\t\t\t\t\t\t \\\n-\t  /* Shift the mantissa of X to the right EDIFF steps;\t\t \\\n-\t     remember to account later for the implicit MSB of Y.  */\t \\\n-\t  if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t \\\n-\t    _FP_FRAC_SRS_##wc(X, ediff, _FP_WFRACBITS_##fs);\t\t \\\n-\t  else if (!_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n-\t    _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);\t\t\t \\\n-\t  _FP_FRAC_SUB_##wc(R, Y, X);\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-      else\t\t\t\t\t\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  /* ediff == 0.  */\t\t\t\t\t\t \\\n-\t  if (!_FP_EXP_NORMAL(fs, wc, X))\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      if (X##_e == 0)\t\t\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  /* X and Y are zero or denormalized.  */\t\t \\\n-\t\t  R##_e = 0;\t\t\t\t\t\t \\\n-\t\t  if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n-\t\t      if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n-\t\t\tR##_s = (FP_ROUNDMODE == FP_RND_MINF);\t\t \\\n-\t\t      else\t\t\t\t\t\t \\\n-\t\t\t{\t\t\t\t\t\t \\\n-\t\t\t  FP_SET_EXCEPTION(FP_EX_DENORM);\t\t \\\n-\t\t\t  R##_s = Y##_s;\t\t\t\t \\\n-\t\t\t}\t\t\t\t\t\t \\\n-\t\t      goto sub_done;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  else if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n-\t\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n-\t\t      R##_s = X##_s;\t\t\t\t\t \\\n-\t\t      goto sub_done;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  else\t\t\t\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n-\t\t      _FP_FRAC_SUB_##wc(R, X, Y);\t\t\t \\\n-\t\t      R##_s = X##_s;\t\t\t\t\t \\\n-\t\t      if (_FP_FRAC_HIGH_##fs(R) & _FP_IMPLBIT_SH_##fs)\t \\\n-\t\t\t{\t\t\t\t\t\t \\\n-\t\t\t  /* |X| < |Y|, negate result.  */\t\t \\\n-\t\t\t  _FP_FRAC_SUB_##wc(R, Y, X);\t\t\t \\\n-\t\t\t  R##_s = Y##_s;\t\t\t\t \\\n-\t\t\t}\t\t\t\t\t\t \\\n-\t\t      else if (_FP_FRAC_ZEROP_##wc(R))\t\t\t \\\n-\t\t\tR##_s = (FP_ROUNDMODE == FP_RND_MINF);\t\t \\\n-\t\t      goto sub_done;\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t      else\t\t\t\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  /* X and Y are NaN or Inf, of opposite signs.  */\t \\\n-\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n-\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n-\t\t  R##_e = _FP_EXPMAX_##fs;\t\t\t\t \\\n-\t\t  if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n-\t\t\t{\t\t\t\t\t\t \\\n-\t\t\t  /* Inf - Inf.  */\t\t\t\t \\\n-\t\t\t  R##_s = _FP_NANSIGN_##fs;\t\t\t \\\n-\t\t\t  _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);\t \\\n-\t\t\t  _FP_FRAC_SLL_##wc(R, _FP_WORKBITS);\t\t \\\n-\t\t\t  FP_SET_EXCEPTION(FP_EX_INVALID);\t\t \\\n-\t\t\t}\t\t\t\t\t\t \\\n-\t\t      else\t\t\t\t\t\t \\\n-\t\t\t{\t\t\t\t\t\t \\\n-\t\t\t  /* Inf - NaN.  */\t\t\t\t \\\n-\t\t\t  R##_s = Y##_s;\t\t\t\t \\\n-\t\t\t  _FP_FRAC_COPY_##wc(R, Y);\t\t\t \\\n-\t\t\t}\t\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  else\t\t\t\t\t\t\t \\\n-\t\t    {\t\t\t\t\t\t\t \\\n-\t\t      if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n-\t\t\t{\t\t\t\t\t\t \\\n-\t\t\t  /* NaN - Inf.  */\t\t\t\t \\\n-\t\t\t  R##_s = X##_s;\t\t\t\t \\\n-\t\t\t  _FP_FRAC_COPY_##wc(R, X);\t\t\t \\\n-\t\t\t}\t\t\t\t\t\t \\\n-\t\t      else\t\t\t\t\t\t \\\n-\t\t\t{\t\t\t\t\t\t \\\n-\t\t\t  /* NaN - NaN.  */\t\t\t\t \\\n-\t\t\t  _FP_CHOOSENAN_SEMIRAW(fs, wc, R, X, Y, OP);\t \\\n-\t\t\t}\t\t\t\t\t\t \\\n-\t\t    }\t\t\t\t\t\t\t \\\n-\t\t  goto sub_done;\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  /* The exponents of X and Y, both normal, are equal.  The\t \\\n-\t     implicit MSBs cancel.  */\t\t\t\t\t \\\n-\t  R##_e = X##_e;\t\t\t\t\t\t \\\n-\t  _FP_FRAC_SUB_##wc(R, X, Y);\t\t\t\t\t \\\n-\t  R##_s = X##_s;\t\t\t\t\t\t \\\n-\t  if (_FP_FRAC_HIGH_##fs(R) & _FP_IMPLBIT_SH_##fs)\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      /* |X| < |Y|, negate result.  */\t\t\t\t \\\n-\t      _FP_FRAC_SUB_##wc(R, Y, X);\t\t\t\t \\\n-\t      R##_s = Y##_s;\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  else if (_FP_FRAC_ZEROP_##wc(R))\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      R##_e = 0;\t\t\t\t\t\t \\\n-\t      R##_s = (FP_ROUNDMODE == FP_RND_MINF);\t\t\t \\\n-\t      goto sub_done;\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  goto norm;\t\t\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-    sub3:\t\t\t\t\t\t\t\t \\\n-      if (_FP_FRAC_HIGH_##fs(R) & _FP_IMPLBIT_SH_##fs)\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  int diff;\t\t\t\t\t\t\t \\\n-\t  /* Carry into most significant bit of larger one of X and Y,\t \\\n-\t     canceling it; renormalize.  */\t\t\t\t \\\n-\t  _FP_FRAC_HIGH_##fs(R) &= _FP_IMPLBIT_SH_##fs - 1;\t\t \\\n-\tnorm:\t\t\t\t\t\t\t\t \\\n-\t  _FP_FRAC_CLZ_##wc(diff, R);\t\t\t\t\t \\\n-\t  diff -= _FP_WFRACXBITS_##fs;\t\t\t\t\t \\\n-\t  _FP_FRAC_SLL_##wc(R, diff);\t\t\t\t\t \\\n-\t  if (R##_e <= diff)\t\t\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      /* R is denormalized.  */\t\t\t\t\t \\\n-\t      diff = diff - R##_e + 1;\t\t\t\t\t \\\n-\t      _FP_FRAC_SRS_##wc(R, diff, _FP_WFRACBITS_##fs);\t\t \\\n-\t      R##_e = 0;\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  else\t\t\t\t\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      R##_e -= diff;\t\t\t\t\t\t \\\n-\t      _FP_FRAC_HIGH_##fs(R) &= ~(_FP_W_TYPE)_FP_IMPLBIT_SH_##fs; \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-    sub_done: ;\t\t\t\t\t\t\t\t \\\n-    }\t\t\t\t\t\t\t\t\t \\\n-} while (0)\n+#define _FP_ADD_INTERNAL(fs, wc, R, X, Y, OP)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (X##_s == Y##_s)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* Addition.  */\t\t\t\t\t\t\\\n+\t  R##_s = X##_s;\t\t\t\t\t\t\\\n+\t  int ediff = X##_e - Y##_e;\t\t\t\t\t\\\n+\t  if (ediff > 0)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      R##_e = X##_e;\t\t\t\t\t\t\\\n+\t      if (Y##_e == 0)\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* Y is zero or denormalized.  */\t\t\t\\\n+\t\t  if (_FP_FRAC_ZEROP_##wc (Y))\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, X);\t\t\\\n+\t\t      _FP_FRAC_COPY_##wc (R, X);\t\t\t\\\n+\t\t      goto add_done;\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\t\\\n+\t\t      ediff--;\t\t\t\t\t\t\\\n+\t\t      if (ediff == 0)\t\t\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  _FP_FRAC_ADD_##wc (R, X, Y);\t\t\t\\\n+\t\t\t  goto add3;\t\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      if (X##_e == _FP_EXPMAX_##fs)\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, X);\t\t\\\n+\t\t\t  _FP_FRAC_COPY_##wc (R, X);\t\t\t\\\n+\t\t\t  goto add_done;\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      goto add1;\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else if (X##_e == _FP_EXPMAX_##fs)\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* X is NaN or Inf, Y is normal.  */\t\t\t\\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, X);\t\t\t\\\n+\t\t  _FP_FRAC_COPY_##wc (R, X);\t\t\t\t\\\n+\t\t  goto add_done;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t      /* Insert implicit MSB of Y.  */\t\t\t\t\\\n+\t      _FP_FRAC_HIGH_##fs (Y) |= _FP_IMPLBIT_SH_##fs;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t    add1:\t\t\t\t\t\t\t\\\n+\t      /* Shift the mantissa of Y to the right EDIFF steps;\t\\\n+\t\t remember to account later for the implicit MSB of X.  */ \\\n+\t      if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t\\\n+\t\t_FP_FRAC_SRS_##wc (Y, ediff, _FP_WFRACBITS_##fs);\t\\\n+\t      else if (!_FP_FRAC_ZEROP_##wc (Y))\t\t\t\\\n+\t\t_FP_FRAC_SET_##wc (Y, _FP_MINFRAC_##wc);\t\t\\\n+\t      _FP_FRAC_ADD_##wc (R, X, Y);\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else if (ediff < 0)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      ediff = -ediff;\t\t\t\t\t\t\\\n+\t      R##_e = Y##_e;\t\t\t\t\t\t\\\n+\t      if (X##_e == 0)\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* X is zero or denormalized.  */\t\t\t\\\n+\t\t  if (_FP_FRAC_ZEROP_##wc (X))\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, Y);\t\t\\\n+\t\t      _FP_FRAC_COPY_##wc (R, Y);\t\t\t\\\n+\t\t      goto add_done;\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\t\\\n+\t\t      ediff--;\t\t\t\t\t\t\\\n+\t\t      if (ediff == 0)\t\t\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  _FP_FRAC_ADD_##wc (R, Y, X);\t\t\t\\\n+\t\t\t  goto add3;\t\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, Y);\t\t\\\n+\t\t\t  _FP_FRAC_COPY_##wc (R, Y);\t\t\t\\\n+\t\t\t  goto add_done;\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      goto add2;\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* Y is NaN or Inf, X is normal.  */\t\t\t\\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, Y);\t\t\t\\\n+\t\t  _FP_FRAC_COPY_##wc (R, Y);\t\t\t\t\\\n+\t\t  goto add_done;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t      /* Insert implicit MSB of X.  */\t\t\t\t\\\n+\t      _FP_FRAC_HIGH_##fs (X) |= _FP_IMPLBIT_SH_##fs;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t    add2:\t\t\t\t\t\t\t\\\n+\t      /* Shift the mantissa of X to the right EDIFF steps;\t\\\n+\t\t remember to account later for the implicit MSB of Y.  */ \\\n+\t      if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t\\\n+\t\t_FP_FRAC_SRS_##wc (X, ediff, _FP_WFRACBITS_##fs);\t\\\n+\t      else if (!_FP_FRAC_ZEROP_##wc (X))\t\t\t\\\n+\t\t_FP_FRAC_SET_##wc (X, _FP_MINFRAC_##wc);\t\t\\\n+\t      _FP_FRAC_ADD_##wc (R, Y, X);\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      /* ediff == 0.  */\t\t\t\t\t\\\n+\t      if (!_FP_EXP_NORMAL (fs, wc, X))\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  if (X##_e == 0)\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      /* X and Y are zero or denormalized.  */\t\t\\\n+\t\t      R##_e = 0;\t\t\t\t\t\\\n+\t\t      if (_FP_FRAC_ZEROP_##wc (X))\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  if (!_FP_FRAC_ZEROP_##wc (Y))\t\t\t\\\n+\t\t\t    FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\\\n+\t\t\t  _FP_FRAC_COPY_##wc (R, Y);\t\t\t\\\n+\t\t\t  goto add_done;\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      else if (_FP_FRAC_ZEROP_##wc (Y))\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\\\n+\t\t\t  _FP_FRAC_COPY_##wc (R, X);\t\t\t\\\n+\t\t\t  goto add_done;\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      else\t\t\t\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\\\n+\t\t\t  _FP_FRAC_ADD_##wc (R, X, Y);\t\t\t\\\n+\t\t\t  if (_FP_FRAC_HIGH_##fs (R) & _FP_IMPLBIT_SH_##fs) \\\n+\t\t\t    {\t\t\t\t\t\t\\\n+\t\t\t      /* Normalized result.  */\t\t\t\\\n+\t\t\t      _FP_FRAC_HIGH_##fs (R)\t\t\t\\\n+\t\t\t\t&= ~(_FP_W_TYPE) _FP_IMPLBIT_SH_##fs;\t\\\n+\t\t\t      R##_e = 1;\t\t\t\t\\\n+\t\t\t    }\t\t\t\t\t\t\\\n+\t\t\t  goto add_done;\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      /* X and Y are NaN or Inf.  */\t\t\t\\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, X);\t\t\\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, Y);\t\t\\\n+\t\t      R##_e = _FP_EXPMAX_##fs;\t\t\t\t\\\n+\t\t      if (_FP_FRAC_ZEROP_##wc (X))\t\t\t\\\n+\t\t\t_FP_FRAC_COPY_##wc (R, Y);\t\t\t\\\n+\t\t      else if (_FP_FRAC_ZEROP_##wc (Y))\t\t\t\\\n+\t\t\t_FP_FRAC_COPY_##wc (R, X);\t\t\t\\\n+\t\t      else\t\t\t\t\t\t\\\n+\t\t\t_FP_CHOOSENAN_SEMIRAW (fs, wc, R, X, Y, OP);\t\\\n+\t\t      goto add_done;\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      /* The exponents of X and Y, both normal, are equal.  The\t\\\n+\t\t implicit MSBs will always add to increase the\t\t\\\n+\t\t exponent.  */\t\t\t\t\t\t\\\n+\t      _FP_FRAC_ADD_##wc (R, X, Y);\t\t\t\t\\\n+\t      R##_e = X##_e + 1;\t\t\t\t\t\\\n+\t      _FP_FRAC_SRS_##wc (R, 1, _FP_WFRACBITS_##fs);\t\t\\\n+\t      if (R##_e == _FP_EXPMAX_##fs)\t\t\t\t\\\n+\t\t/* Overflow to infinity (depending on rounding mode).  */ \\\n+\t\t_FP_OVERFLOW_SEMIRAW (fs, wc, R);\t\t\t\\\n+\t      goto add_done;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\tadd3:\t\t\t\t\t\t\t\t\\\n+\t  if (_FP_FRAC_HIGH_##fs (R) & _FP_IMPLBIT_SH_##fs)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      /* Overflow.  */\t\t\t\t\t\t\\\n+\t      _FP_FRAC_HIGH_##fs (R) &= ~(_FP_W_TYPE) _FP_IMPLBIT_SH_##fs; \\\n+\t      R##_e++;\t\t\t\t\t\t\t\\\n+\t      _FP_FRAC_SRS_##wc (R, 1, _FP_WFRACBITS_##fs);\t\t\\\n+\t      if (R##_e == _FP_EXPMAX_##fs)\t\t\t\t\\\n+\t\t/* Overflow to infinity (depending on rounding mode).  */ \\\n+\t\t_FP_OVERFLOW_SEMIRAW (fs, wc, R);\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\tadd_done: ;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* Subtraction.  */\t\t\t\t\t\t\\\n+\t  int ediff = X##_e - Y##_e;\t\t\t\t\t\\\n+\t  if (ediff > 0)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      R##_e = X##_e;\t\t\t\t\t\t\\\n+\t      R##_s = X##_s;\t\t\t\t\t\t\\\n+\t      if (Y##_e == 0)\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* Y is zero or denormalized.  */\t\t\t\\\n+\t\t  if (_FP_FRAC_ZEROP_##wc (Y))\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, X);\t\t\\\n+\t\t      _FP_FRAC_COPY_##wc (R, X);\t\t\t\\\n+\t\t      goto sub_done;\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\t\\\n+\t\t      ediff--;\t\t\t\t\t\t\\\n+\t\t      if (ediff == 0)\t\t\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  _FP_FRAC_SUB_##wc (R, X, Y);\t\t\t\\\n+\t\t\t  goto sub3;\t\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      if (X##_e == _FP_EXPMAX_##fs)\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, X);\t\t\\\n+\t\t\t  _FP_FRAC_COPY_##wc (R, X);\t\t\t\\\n+\t\t\t  goto sub_done;\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      goto sub1;\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else if (X##_e == _FP_EXPMAX_##fs)\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* X is NaN or Inf, Y is normal.  */\t\t\t\\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, X);\t\t\t\\\n+\t\t  _FP_FRAC_COPY_##wc (R, X);\t\t\t\t\\\n+\t\t  goto sub_done;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t      /* Insert implicit MSB of Y.  */\t\t\t\t\\\n+\t      _FP_FRAC_HIGH_##fs (Y) |= _FP_IMPLBIT_SH_##fs;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t    sub1:\t\t\t\t\t\t\t\\\n+\t      /* Shift the mantissa of Y to the right EDIFF steps;\t\\\n+\t\t remember to account later for the implicit MSB of X.  */ \\\n+\t      if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t\\\n+\t\t_FP_FRAC_SRS_##wc (Y, ediff, _FP_WFRACBITS_##fs);\t\\\n+\t      else if (!_FP_FRAC_ZEROP_##wc (Y))\t\t\t\\\n+\t\t_FP_FRAC_SET_##wc (Y, _FP_MINFRAC_##wc);\t\t\\\n+\t      _FP_FRAC_SUB_##wc (R, X, Y);\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else if (ediff < 0)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      ediff = -ediff;\t\t\t\t\t\t\\\n+\t      R##_e = Y##_e;\t\t\t\t\t\t\\\n+\t      R##_s = Y##_s;\t\t\t\t\t\t\\\n+\t      if (X##_e == 0)\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* X is zero or denormalized.  */\t\t\t\\\n+\t\t  if (_FP_FRAC_ZEROP_##wc (X))\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, Y);\t\t\\\n+\t\t      _FP_FRAC_COPY_##wc (R, Y);\t\t\t\\\n+\t\t      goto sub_done;\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\t\\\n+\t\t      ediff--;\t\t\t\t\t\t\\\n+\t\t      if (ediff == 0)\t\t\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  _FP_FRAC_SUB_##wc (R, Y, X);\t\t\t\\\n+\t\t\t  goto sub3;\t\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, Y);\t\t\\\n+\t\t\t  _FP_FRAC_COPY_##wc (R, Y);\t\t\t\\\n+\t\t\t  goto sub_done;\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      goto sub2;\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* Y is NaN or Inf, X is normal.  */\t\t\t\\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, Y);\t\t\t\\\n+\t\t  _FP_FRAC_COPY_##wc (R, Y);\t\t\t\t\\\n+\t\t  goto sub_done;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t      /* Insert implicit MSB of X.  */\t\t\t\t\\\n+\t      _FP_FRAC_HIGH_##fs (X) |= _FP_IMPLBIT_SH_##fs;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t    sub2:\t\t\t\t\t\t\t\\\n+\t      /* Shift the mantissa of X to the right EDIFF steps;\t\\\n+\t\t remember to account later for the implicit MSB of Y.  */ \\\n+\t      if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t\\\n+\t\t_FP_FRAC_SRS_##wc (X, ediff, _FP_WFRACBITS_##fs);\t\\\n+\t      else if (!_FP_FRAC_ZEROP_##wc (X))\t\t\t\\\n+\t\t_FP_FRAC_SET_##wc (X, _FP_MINFRAC_##wc);\t\t\\\n+\t      _FP_FRAC_SUB_##wc (R, Y, X);\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      /* ediff == 0.  */\t\t\t\t\t\\\n+\t      if (!_FP_EXP_NORMAL (fs, wc, X))\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  if (X##_e == 0)\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      /* X and Y are zero or denormalized.  */\t\t\\\n+\t\t      R##_e = 0;\t\t\t\t\t\\\n+\t\t      if (_FP_FRAC_ZEROP_##wc (X))\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  _FP_FRAC_COPY_##wc (R, Y);\t\t\t\\\n+\t\t\t  if (_FP_FRAC_ZEROP_##wc (Y))\t\t\t\\\n+\t\t\t    R##_s = (FP_ROUNDMODE == FP_RND_MINF);\t\\\n+\t\t\t  else\t\t\t\t\t\t\\\n+\t\t\t    {\t\t\t\t\t\t\\\n+\t\t\t      FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\\\n+\t\t\t      R##_s = Y##_s;\t\t\t\t\\\n+\t\t\t    }\t\t\t\t\t\t\\\n+\t\t\t  goto sub_done;\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      else if (_FP_FRAC_ZEROP_##wc (Y))\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\\\n+\t\t\t  _FP_FRAC_COPY_##wc (R, X);\t\t\t\\\n+\t\t\t  R##_s = X##_s;\t\t\t\t\\\n+\t\t\t  goto sub_done;\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      else\t\t\t\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\\\n+\t\t\t  _FP_FRAC_SUB_##wc (R, X, Y);\t\t\t\\\n+\t\t\t  R##_s = X##_s;\t\t\t\t\\\n+\t\t\t  if (_FP_FRAC_HIGH_##fs (R) & _FP_IMPLBIT_SH_##fs) \\\n+\t\t\t    {\t\t\t\t\t\t\\\n+\t\t\t      /* |X| < |Y|, negate result.  */\t\t\\\n+\t\t\t      _FP_FRAC_SUB_##wc (R, Y, X);\t\t\\\n+\t\t\t      R##_s = Y##_s;\t\t\t\t\\\n+\t\t\t    }\t\t\t\t\t\t\\\n+\t\t\t  else if (_FP_FRAC_ZEROP_##wc (R))\t\t\\\n+\t\t\t    R##_s = (FP_ROUNDMODE == FP_RND_MINF);\t\\\n+\t\t\t  goto sub_done;\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      /* X and Y are NaN or Inf, of opposite signs.  */\t\\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, X);\t\t\\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW (fs, wc, Y);\t\t\\\n+\t\t      R##_e = _FP_EXPMAX_##fs;\t\t\t\t\\\n+\t\t      if (_FP_FRAC_ZEROP_##wc (X))\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  if (_FP_FRAC_ZEROP_##wc (Y))\t\t\t\\\n+\t\t\t    {\t\t\t\t\t\t\\\n+\t\t\t      /* Inf - Inf.  */\t\t\t\t\\\n+\t\t\t      R##_s = _FP_NANSIGN_##fs;\t\t\t\\\n+\t\t\t      _FP_FRAC_SET_##wc (R, _FP_NANFRAC_##fs);\t\\\n+\t\t\t      _FP_FRAC_SLL_##wc (R, _FP_WORKBITS);\t\\\n+\t\t\t      FP_SET_EXCEPTION (FP_EX_INVALID);\t\t\\\n+\t\t\t    }\t\t\t\t\t\t\\\n+\t\t\t  else\t\t\t\t\t\t\\\n+\t\t\t    {\t\t\t\t\t\t\\\n+\t\t\t      /* Inf - NaN.  */\t\t\t\t\\\n+\t\t\t      R##_s = Y##_s;\t\t\t\t\\\n+\t\t\t      _FP_FRAC_COPY_##wc (R, Y);\t\t\\\n+\t\t\t    }\t\t\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      else\t\t\t\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  if (_FP_FRAC_ZEROP_##wc (Y))\t\t\t\\\n+\t\t\t    {\t\t\t\t\t\t\\\n+\t\t\t      /* NaN - Inf.  */\t\t\t\t\\\n+\t\t\t      R##_s = X##_s;\t\t\t\t\\\n+\t\t\t      _FP_FRAC_COPY_##wc (R, X);\t\t\\\n+\t\t\t    }\t\t\t\t\t\t\\\n+\t\t\t  else\t\t\t\t\t\t\\\n+\t\t\t    {\t\t\t\t\t\t\\\n+\t\t\t      /* NaN - NaN.  */\t\t\t\t\\\n+\t\t\t      _FP_CHOOSENAN_SEMIRAW (fs, wc, R, X, Y, OP); \\\n+\t\t\t    }\t\t\t\t\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t      goto sub_done;\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      /* The exponents of X and Y, both normal, are equal.  The\t\\\n+\t\t implicit MSBs cancel.  */\t\t\t\t\\\n+\t      R##_e = X##_e;\t\t\t\t\t\t\\\n+\t      _FP_FRAC_SUB_##wc (R, X, Y);\t\t\t\t\\\n+\t      R##_s = X##_s;\t\t\t\t\t\t\\\n+\t      if (_FP_FRAC_HIGH_##fs (R) & _FP_IMPLBIT_SH_##fs)\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* |X| < |Y|, negate result.  */\t\t\t\\\n+\t\t  _FP_FRAC_SUB_##wc (R, Y, X);\t\t\t\t\\\n+\t\t  R##_s = Y##_s;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else if (_FP_FRAC_ZEROP_##wc (R))\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  R##_e = 0;\t\t\t\t\t\t\\\n+\t\t  R##_s = (FP_ROUNDMODE == FP_RND_MINF);\t\t\\\n+\t\t  goto sub_done;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      goto norm;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\tsub3:\t\t\t\t\t\t\t\t\\\n+\t  if (_FP_FRAC_HIGH_##fs (R) & _FP_IMPLBIT_SH_##fs)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      int diff;\t\t\t\t\t\t\t\\\n+\t      /* Carry into most significant bit of larger one of X and Y, \\\n+\t\t canceling it; renormalize.  */\t\t\t\t\\\n+\t      _FP_FRAC_HIGH_##fs (R) &= _FP_IMPLBIT_SH_##fs - 1;\t\\\n+\t    norm:\t\t\t\t\t\t\t\\\n+\t      _FP_FRAC_CLZ_##wc (diff, R);\t\t\t\t\\\n+\t      diff -= _FP_WFRACXBITS_##fs;\t\t\t\t\\\n+\t      _FP_FRAC_SLL_##wc (R, diff);\t\t\t\t\\\n+\t      if (R##_e <= diff)\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  /* R is denormalized.  */\t\t\t\t\\\n+\t\t  diff = diff - R##_e + 1;\t\t\t\t\\\n+\t\t  _FP_FRAC_SRS_##wc (R, diff, _FP_WFRACBITS_##fs);\t\\\n+\t\t  R##_e = 0;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  R##_e -= diff;\t\t\t\t\t\\\n+\t\t  _FP_FRAC_HIGH_##fs (R) &= ~(_FP_W_TYPE) _FP_IMPLBIT_SH_##fs; \\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\tsub_done: ;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n-#define _FP_ADD(fs, wc, R, X, Y) _FP_ADD_INTERNAL(fs, wc, R, X, Y, '+')\n-#define _FP_SUB(fs, wc, R, X, Y)\t\t\t\t\t    \\\n-  do {\t\t\t\t\t\t\t\t\t    \\\n-    if (!(Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(Y))) Y##_s ^= 1; \\\n-    _FP_ADD_INTERNAL(fs, wc, R, X, Y, '-');\t\t\t\t    \\\n-  } while (0)\n+#define _FP_ADD(fs, wc, R, X, Y) _FP_ADD_INTERNAL (fs, wc, R, X, Y, '+')\n+#define _FP_SUB(fs, wc, R, X, Y)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (!(Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc (Y)))\t\\\n+\tY##_s ^= 1;\t\t\t\t\t\t\t\\\n+      _FP_ADD_INTERNAL (fs, wc, R, X, Y, '-');\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n- * Main negation routine.  FIXME -- when we care about setting exception\n- * bits reliably, this will not do.  We should examine all of the fp classes.\n+ * Main negation routine.  The input value is raw.\n  */\n \n-#define _FP_NEG(fs, wc, R, X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_FRAC_COPY_##wc(R, X);\t\t\\\n-    R##_c = X##_c;\t\t\t\\\n-    R##_e = X##_e;\t\t\t\\\n-    R##_s = 1 ^ X##_s;\t\t\t\\\n-  } while (0)\n+#define _FP_NEG(fs, wc, R, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_FRAC_COPY_##wc (R, X);\t\t\\\n+      R##_e = X##_e;\t\t\t\t\\\n+      R##_s = 1 ^ X##_s;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n  * Main multiplication routine.  The input values should be cooked.\n  */\n \n-#define _FP_MUL(fs, wc, R, X, Y)\t\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-  R##_s = X##_s ^ Y##_s;\t\t\t\t\\\n-  R##_e = X##_e + Y##_e + 1;\t\t\t\t\\\n-  switch (_FP_CLS_COMBINE(X##_c, Y##_c))\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):\t\\\n-    R##_c = FP_CLS_NORMAL;\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-    _FP_MUL_MEAT_##fs(R,X,Y);\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-    if (_FP_FRAC_OVERP_##wc(fs, R))\t\t\t\\\n-      _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);\t\\\n-    else\t\t\t\t\t\t\\\n-      R##_e--;\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):\t\t\\\n-    _FP_CHOOSENAN(fs, wc, R, X, Y, '*');\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):\t\t\\\n-    R##_s = X##_s;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):\t\\\n-    _FP_FRAC_COPY_##wc(R, X);\t\t\t\t\\\n-    R##_c = X##_c;\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):\t\t\\\n-    R##_s = Y##_s;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):\t\\\n-    _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t\\\n-    R##_c = Y##_c;\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):\t\t\\\n-    R##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n-    R##_c = FP_CLS_NAN;\t\t\t\t\t\\\n-    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);\t\t\\\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  default:\t\t\t\t\t\t\\\n-    abort();\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\\\n-} while (0)\n+#define _FP_MUL(fs, wc, R, X, Y)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      R##_s = X##_s ^ Y##_s;\t\t\t\t\t\\\n+      R##_e = X##_e + Y##_e + 1;\t\t\t\t\\\n+      switch (_FP_CLS_COMBINE (X##_c, Y##_c))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_NORMAL):\t\\\n+\t  R##_c = FP_CLS_NORMAL;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\t  _FP_MUL_MEAT_##fs (R, X, Y);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\t  if (_FP_FRAC_OVERP_##wc (fs, R))\t\t\t\\\n+\t    _FP_FRAC_SRS_##wc (R, 1, _FP_WFRACBITS_##fs);\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    R##_e--;\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_NAN):\t\t\\\n+\t  _FP_CHOOSENAN (fs, wc, R, X, Y, '*');\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_NORMAL):\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_INF):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_ZERO):\t\t\\\n+\t  R##_s = X##_s;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_INF):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_NORMAL):\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_NORMAL):\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_ZERO):\t\\\n+\t  _FP_FRAC_COPY_##wc (R, X);\t\t\t\t\\\n+\t  R##_c = X##_c;\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_NAN):\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_NAN):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_NAN):\t\t\\\n+\t  R##_s = Y##_s;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_INF):\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_ZERO):\t\\\n+\t  _FP_FRAC_COPY_##wc (R, Y);\t\t\t\t\\\n+\t  R##_c = Y##_c;\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_ZERO):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_INF):\t\t\\\n+\t  R##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+\t  R##_c = FP_CLS_NAN;\t\t\t\t\t\\\n+\t  _FP_FRAC_SET_##wc (R, _FP_NANFRAC_##fs);\t\t\\\n+\t  FP_SET_EXCEPTION (FP_EX_INVALID);\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tdefault:\t\t\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+/* Fused multiply-add.  The input values should be cooked.  */\n+\n+#define _FP_FMA(fs, wc, dwc, R, X, Y, Z)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      FP_DECL_##fs (T);\t\t\t\t\t\t\t\\\n+      T##_s = X##_s ^ Y##_s;\t\t\t\t\t\t\\\n+      T##_e = X##_e + Y##_e + 1;\t\t\t\t\t\\\n+      switch (_FP_CLS_COMBINE (X##_c, Y##_c))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_NORMAL):\t\t\\\n+\t  switch (Z##_c)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t    case FP_CLS_INF:\t\t\t\t\t\t\\\n+\t    case FP_CLS_NAN:\t\t\t\t\t\t\\\n+\t      R##_s = Z##_s;\t\t\t\t\t\t\\\n+\t      _FP_FRAC_COPY_##wc (R, Z);\t\t\t\t\\\n+\t      R##_c = Z##_c;\t\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t    case FP_CLS_ZERO:\t\t\t\t\t\t\\\n+\t      R##_c = FP_CLS_NORMAL;\t\t\t\t\t\\\n+\t      R##_s = T##_s;\t\t\t\t\t\t\\\n+\t      R##_e = T##_e;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t      _FP_MUL_MEAT_##fs (R, X, Y);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t      if (_FP_FRAC_OVERP_##wc (fs, R))\t\t\t\t\\\n+\t\t_FP_FRAC_SRS_##wc (R, 1, _FP_WFRACBITS_##fs);\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\tR##_e--;\t\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t    case FP_CLS_NORMAL:;\t\t\t\t\t\\\n+\t      _FP_FRAC_DECL_##dwc (TD);\t\t\t\t\t\\\n+\t      _FP_FRAC_DECL_##dwc (ZD);\t\t\t\t\t\\\n+\t      _FP_FRAC_DECL_##dwc (RD);\t\t\t\t\t\\\n+\t      _FP_MUL_MEAT_DW_##fs (TD, X, Y);\t\t\t\t\\\n+\t      R##_e = T##_e;\t\t\t\t\t\t\\\n+\t      int tsh = _FP_FRAC_HIGHBIT_DW_##dwc (fs, TD) == 0;\t\\\n+\t      T##_e -= tsh;\t\t\t\t\t\t\\\n+\t      int ediff = T##_e - Z##_e;\t\t\t\t\\\n+\t      if (ediff >= 0)\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  int shift = _FP_WFRACBITS_##fs - tsh - ediff;\t\t\\\n+\t\t  if (shift <= -_FP_WFRACBITS_##fs)\t\t\t\\\n+\t\t    _FP_FRAC_SET_##dwc (ZD, _FP_MINFRAC_##dwc);\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      _FP_FRAC_COPY_##dwc##_##wc (ZD, Z);\t\t\\\n+\t\t      if (shift < 0)\t\t\t\t\t\\\n+\t\t\t_FP_FRAC_SRS_##dwc (ZD, -shift,\t\t\t\\\n+\t\t\t\t\t    _FP_WFRACBITS_DW_##fs);\t\\\n+\t\t      else if (shift > 0)\t\t\t\t\\\n+\t\t\t_FP_FRAC_SLL_##dwc (ZD, shift);\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  R##_s = T##_s;\t\t\t\t\t\\\n+\t\t  if (T##_s == Z##_s)\t\t\t\t\t\\\n+\t\t    _FP_FRAC_ADD_##dwc (RD, TD, ZD);\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      _FP_FRAC_SUB_##dwc (RD, TD, ZD);\t\t\t\\\n+\t\t      if (_FP_FRAC_NEGP_##dwc (RD))\t\t\t\\\n+\t\t\t{\t\t\t\t\t\t\\\n+\t\t\t  R##_s = Z##_s;\t\t\t\t\\\n+\t\t\t  _FP_FRAC_SUB_##dwc (RD, ZD, TD);\t\t\\\n+\t\t\t}\t\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  R##_e = Z##_e;\t\t\t\t\t\\\n+\t\t  R##_s = Z##_s;\t\t\t\t\t\\\n+\t\t  _FP_FRAC_COPY_##dwc##_##wc (ZD, Z);\t\t\t\\\n+\t\t  _FP_FRAC_SLL_##dwc (ZD, _FP_WFRACBITS_##fs);\t\t\\\n+\t\t  int shift = -ediff - tsh;\t\t\t\t\\\n+\t\t  if (shift >= _FP_WFRACBITS_DW_##fs)\t\t\t\\\n+\t\t    _FP_FRAC_SET_##dwc (TD, _FP_MINFRAC_##dwc);\t\t\\\n+\t\t  else if (shift > 0)\t\t\t\t\t\\\n+\t\t    _FP_FRAC_SRS_##dwc (TD, shift,\t\t\t\\\n+\t\t\t\t\t_FP_WFRACBITS_DW_##fs);\t\t\\\n+\t\t  if (Z##_s == T##_s)\t\t\t\t\t\\\n+\t\t    _FP_FRAC_ADD_##dwc (RD, ZD, TD);\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    _FP_FRAC_SUB_##dwc (RD, ZD, TD);\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      if (_FP_FRAC_ZEROP_##dwc (RD))\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  if (T##_s == Z##_s)\t\t\t\t\t\\\n+\t\t    R##_s = Z##_s;\t\t\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    R##_s = (FP_ROUNDMODE == FP_RND_MINF);\t\t\\\n+\t\t  _FP_FRAC_SET_##wc (R, _FP_ZEROFRAC_##wc);\t\t\\\n+\t\t  R##_c = FP_CLS_ZERO;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  int rlz;\t\t\t\t\t\t\\\n+\t\t  _FP_FRAC_CLZ_##dwc (rlz, RD);\t\t\t\t\\\n+\t\t  rlz -= _FP_WFRACXBITS_DW_##fs;\t\t\t\\\n+\t\t  R##_e -= rlz;\t\t\t\t\t\t\\\n+\t\t  int shift = _FP_WFRACBITS_##fs - rlz;\t\t\t\\\n+\t\t  if (shift > 0)\t\t\t\t\t\\\n+\t\t    _FP_FRAC_SRS_##dwc (RD, shift,\t\t\t\\\n+\t\t\t\t\t_FP_WFRACBITS_DW_##fs);\t\t\\\n+\t\t  else if (shift < 0)\t\t\t\t\t\\\n+\t\t    _FP_FRAC_SLL_##dwc (RD, -shift);\t\t\t\\\n+\t\t  _FP_FRAC_COPY_##wc##_##dwc (R, RD);\t\t\t\\\n+\t\t  R##_c = FP_CLS_NORMAL;\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  goto done_fma;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_NAN):\t\t\t\\\n+\t  _FP_CHOOSENAN (fs, wc, T, X, Y, '*');\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_NORMAL):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_INF):\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_ZERO):\t\t\t\\\n+\t  T##_s = X##_s;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_INF):\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_NORMAL):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_NORMAL):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_ZERO):\t\t\\\n+\t  _FP_FRAC_COPY_##wc (T, X);\t\t\t\t\t\\\n+\t  T##_c = X##_c;\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_NAN):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_NAN):\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_NAN):\t\t\t\\\n+\t  T##_s = Y##_s;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_INF):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_ZERO):\t\t\\\n+\t  _FP_FRAC_COPY_##wc (T, Y);\t\t\t\t\t\\\n+\t  T##_c = Y##_c;\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_ZERO):\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_INF):\t\t\t\\\n+\t  T##_s = _FP_NANSIGN_##fs;\t\t\t\t\t\\\n+\t  T##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SET_##wc (T, _FP_NANFRAC_##fs);\t\t\t\\\n+\t  FP_SET_EXCEPTION (FP_EX_INVALID);\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tdefault:\t\t\t\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* T = X * Y is zero, infinity or NaN.  */\t\t\t\\\n+      switch (_FP_CLS_COMBINE (T##_c, Z##_c))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_NAN):\t\t\t\\\n+\t  _FP_CHOOSENAN (fs, wc, R, T, Z, '+');\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_NORMAL):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_INF):\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_ZERO):\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_NORMAL):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_ZERO):\t\t\t\\\n+\t  R##_s = T##_s;\t\t\t\t\t\t\\\n+\t  _FP_FRAC_COPY_##wc (R, T);\t\t\t\t\t\\\n+\t  R##_c = T##_c;\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_NAN):\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_NAN):\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_NORMAL):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_INF):\t\t\t\\\n+\t  R##_s = Z##_s;\t\t\t\t\t\t\\\n+\t  _FP_FRAC_COPY_##wc (R, Z);\t\t\t\t\t\\\n+\t  R##_c = Z##_c;\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_INF):\t\t\t\\\n+\t  if (T##_s == Z##_s)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      R##_s = Z##_s;\t\t\t\t\t\t\\\n+\t      _FP_FRAC_COPY_##wc (R, Z);\t\t\t\t\\\n+\t      R##_c = Z##_c;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      R##_s = _FP_NANSIGN_##fs;\t\t\t\t\t\\\n+\t      R##_c = FP_CLS_NAN;\t\t\t\t\t\\\n+\t      _FP_FRAC_SET_##wc (R, _FP_NANFRAC_##fs);\t\t\t\\\n+\t      FP_SET_EXCEPTION (FP_EX_INVALID);\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_ZERO):\t\t\\\n+\t  if (T##_s == Z##_s)\t\t\t\t\t\t\\\n+\t    R##_s = Z##_s;\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    R##_s = (FP_ROUNDMODE == FP_RND_MINF);\t\t\t\\\n+\t  _FP_FRAC_COPY_##wc (R, Z);\t\t\t\t\t\\\n+\t  R##_c = Z##_c;\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tdefault:\t\t\t\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    done_fma: ;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n  * Main division routine.  The input values should be cooked.\n  */\n \n-#define _FP_DIV(fs, wc, R, X, Y)\t\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-  R##_s = X##_s ^ Y##_s;\t\t\t\t\\\n-  R##_e = X##_e - Y##_e;\t\t\t\t\\\n-  switch (_FP_CLS_COMBINE(X##_c, Y##_c))\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):\t\\\n-    R##_c = FP_CLS_NORMAL;\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-    _FP_DIV_MEAT_##fs(R,X,Y);\t\t\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):\t\t\\\n-    _FP_CHOOSENAN(fs, wc, R, X, Y, '/');\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):\t\t\\\n-    R##_s = X##_s;\t\t\t\t\t\\\n-    _FP_FRAC_COPY_##wc(R, X);\t\t\t\t\\\n-    R##_c = X##_c;\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):\t\t\\\n-    R##_s = Y##_s;\t\t\t\t\t\\\n-    _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t\\\n-    R##_c = Y##_c;\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):\t\\\n-    R##_c = FP_CLS_ZERO;\t\t\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):\t\\\n-    FP_SET_EXCEPTION(FP_EX_DIVZERO);\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):\t\\\n-    R##_c = FP_CLS_INF;\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):\t\t\\\n-  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):\t\\\n-    R##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n-    R##_c = FP_CLS_NAN;\t\t\t\t\t\\\n-    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);\t\t\\\n-    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\\\n-    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  default:\t\t\t\t\t\t\\\n-    abort();\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\\\n-} while (0)\n+#define _FP_DIV(fs, wc, R, X, Y)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      R##_s = X##_s ^ Y##_s;\t\t\t\t\t\\\n+      R##_e = X##_e - Y##_e;\t\t\t\t\t\\\n+      switch (_FP_CLS_COMBINE (X##_c, Y##_c))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_NORMAL):\t\\\n+\t  R##_c = FP_CLS_NORMAL;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\t  _FP_DIV_MEAT_##fs (R, X, Y);\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_NAN):\t\t\\\n+\t  _FP_CHOOSENAN (fs, wc, R, X, Y, '/');\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_NORMAL):\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_INF):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NAN, FP_CLS_ZERO):\t\t\\\n+\t  R##_s = X##_s;\t\t\t\t\t\\\n+\t  _FP_FRAC_COPY_##wc (R, X);\t\t\t\t\\\n+\t  R##_c = X##_c;\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_NAN):\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_NAN):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_NAN):\t\t\\\n+\t  R##_s = Y##_s;\t\t\t\t\t\\\n+\t  _FP_FRAC_COPY_##wc (R, Y);\t\t\t\t\\\n+\t  R##_c = Y##_c;\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_INF):\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_INF):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_NORMAL):\t\\\n+\t  R##_c = FP_CLS_ZERO;\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_NORMAL, FP_CLS_ZERO):\t\\\n+\t  FP_SET_EXCEPTION (FP_EX_DIVZERO);\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_ZERO):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_NORMAL):\t\\\n+\t  R##_c = FP_CLS_INF;\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_INF, FP_CLS_INF):\t\t\\\n+\tcase _FP_CLS_COMBINE (FP_CLS_ZERO, FP_CLS_ZERO):\t\\\n+\t  R##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+\t  R##_c = FP_CLS_NAN;\t\t\t\t\t\\\n+\t  _FP_FRAC_SET_##wc (R, _FP_NANFRAC_##fs);\t\t\\\n+\t  FP_SET_EXCEPTION (FP_EX_INVALID);\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tdefault:\t\t\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /*\n@@ -916,122 +1156,131 @@ do {\t\t\t\t\t\t\t\\\n  */\n \n #define _FP_CMP(fs, wc, ret, X, Y, un)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    /* NANs are unordered */\t\t\t\t\t\t\\\n-    if ((X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(X))\t\t\\\n-\t|| (Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(Y)))\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tret = un;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tint __is_zero_x;\t\t\t\t\t\t\\\n-\tint __is_zero_y;\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* NANs are unordered */\t\t\t\t\t\t\\\n+      if ((X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc (X))\t\\\n+\t  || (Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc (Y)))\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  ret = un;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  int __is_zero_x;\t\t\t\t\t\t\\\n+\t  int __is_zero_y;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\t__is_zero_x = (!X##_e && _FP_FRAC_ZEROP_##wc(X)) ? 1 : 0;\t\\\n-\t__is_zero_y = (!Y##_e && _FP_FRAC_ZEROP_##wc(Y)) ? 1 : 0;\t\\\n+\t  __is_zero_x = (!X##_e && _FP_FRAC_ZEROP_##wc (X)) ? 1 : 0;\t\\\n+\t  __is_zero_y = (!Y##_e && _FP_FRAC_ZEROP_##wc (Y)) ? 1 : 0;\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\tif (__is_zero_x && __is_zero_y)\t\t\t\t\t\\\n-\t\tret = 0;\t\t\t\t\t\t\\\n-\telse if (__is_zero_x)\t\t\t\t\t\t\\\n-\t\tret = Y##_s ? 1 : -1;\t\t\t\t\t\\\n-\telse if (__is_zero_y)\t\t\t\t\t\t\\\n-\t\tret = X##_s ? -1 : 1;\t\t\t\t\t\\\n-\telse if (X##_s != Y##_s)\t\t\t\t\t\\\n-\t  ret = X##_s ? -1 : 1;\t\t\t\t\t\t\\\n-\telse if (X##_e > Y##_e)\t\t\t\t\t\t\\\n-\t  ret = X##_s ? -1 : 1;\t\t\t\t\t\t\\\n-\telse if (X##_e < Y##_e)\t\t\t\t\t\t\\\n-\t  ret = X##_s ? 1 : -1;\t\t\t\t\t\t\\\n-\telse if (_FP_FRAC_GT_##wc(X, Y))\t\t\t\t\\\n-\t  ret = X##_s ? -1 : 1;\t\t\t\t\t\t\\\n-\telse if (_FP_FRAC_GT_##wc(Y, X))\t\t\t\t\\\n-\t  ret = X##_s ? 1 : -1;\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  ret = 0;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+\t  if (__is_zero_x && __is_zero_y)\t\t\t\t\\\n+\t    ret = 0;\t\t\t\t\t\t\t\\\n+\t  else if (__is_zero_x)\t\t\t\t\t\t\\\n+\t    ret = Y##_s ? 1 : -1;\t\t\t\t\t\\\n+\t  else if (__is_zero_y)\t\t\t\t\t\t\\\n+\t    ret = X##_s ? -1 : 1;\t\t\t\t\t\\\n+\t  else if (X##_s != Y##_s)\t\t\t\t\t\\\n+\t    ret = X##_s ? -1 : 1;\t\t\t\t\t\\\n+\t  else if (X##_e > Y##_e)\t\t\t\t\t\\\n+\t    ret = X##_s ? -1 : 1;\t\t\t\t\t\\\n+\t  else if (X##_e < Y##_e)\t\t\t\t\t\\\n+\t    ret = X##_s ? 1 : -1;\t\t\t\t\t\\\n+\t  else if (_FP_FRAC_GT_##wc (X, Y))\t\t\t\t\\\n+\t    ret = X##_s ? -1 : 1;\t\t\t\t\t\\\n+\t  else if (_FP_FRAC_GT_##wc (Y, X))\t\t\t\t\\\n+\t    ret = X##_s ? 1 : -1;\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    ret = 0;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n \n /* Simplification for strict equality.  */\n \n-#define _FP_CMP_EQ(fs, wc, ret, X, Y)\t\t\t\t\t    \\\n-  do {\t\t\t\t\t\t\t\t\t    \\\n-    /* NANs are unordered */\t\t\t\t\t\t    \\\n-    if ((X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(X))\t\t    \\\n-\t|| (Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(Y)))\t    \\\n-      {\t\t\t\t\t\t\t\t\t    \\\n-\tret = 1;\t\t\t\t\t\t\t    \\\n-      }\t\t\t\t\t\t\t\t\t    \\\n-    else\t\t\t\t\t\t\t\t    \\\n-      {\t\t\t\t\t\t\t\t\t    \\\n-\tret = !(X##_e == Y##_e\t\t\t\t\t\t    \\\n-\t\t&& _FP_FRAC_EQ_##wc(X, Y)\t\t\t\t    \\\n-\t\t&& (X##_s == Y##_s || (!X##_e && _FP_FRAC_ZEROP_##wc(X)))); \\\n-      }\t\t\t\t\t\t\t\t\t    \\\n-  } while (0)\n+#define _FP_CMP_EQ(fs, wc, ret, X, Y)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* NANs are unordered */\t\t\t\t\t\t\\\n+      if ((X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc (X))\t\\\n+\t  || (Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc (Y)))\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  ret = 1;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  ret = !(X##_e == Y##_e\t\t\t\t\t\\\n+\t\t  && _FP_FRAC_EQ_##wc (X, Y)\t\t\t\t\\\n+\t\t  && (X##_s == Y##_s || (!X##_e && _FP_FRAC_ZEROP_##wc (X)))); \\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Version to test unordered.  */\n \n #define _FP_CMP_UNORD(fs, wc, ret, X, Y)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    ret = ((X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(X))\t\\\n-\t   || (Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(Y)));\t\\\n-  } while (0)\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      ret = ((X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc (X))\t\\\n+\t     || (Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc (Y))); \\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /*\n  * Main square root routine.  The input value should be cooked.\n  */\n \n-#define _FP_SQRT(fs, wc, R, X)\t\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-    _FP_FRAC_DECL_##wc(T); _FP_FRAC_DECL_##wc(S);\t\t\t\\\n-    _FP_W_TYPE q;\t\t\t\t\t\t\t\\\n-    switch (X##_c)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-    case FP_CLS_NAN:\t\t\t\t\t\t\t\\\n-\t_FP_FRAC_COPY_##wc(R, X);\t\t\t\t\t\\\n-\tR##_s = X##_s;\t\t\t\t\t\t\t\\\n-\tR##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-    case FP_CLS_INF:\t\t\t\t\t\t\t\\\n-\tif (X##_s)\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    R##_s = _FP_NANSIGN_##fs;\t\t\t\t\t\\\n-\t    R##_c = FP_CLS_NAN; /* NAN */\t\t\t\t\\\n-\t    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);\t\t\t\\\n-\t    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    R##_s = 0;\t\t\t\t\t\t\t\\\n-\t    R##_c = FP_CLS_INF; /* sqrt(+inf) = +inf */\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-    case FP_CLS_ZERO:\t\t\t\t\t\t\t\\\n-\tR##_s = X##_s;\t\t\t\t\t\t\t\\\n-\tR##_c = FP_CLS_ZERO; /* sqrt(+-0) = +-0 */\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-    case FP_CLS_NORMAL:\t\t\t\t\t\t\t\\\n-\tR##_s = 0;\t\t\t\t\t\t\t\\\n-        if (X##_s)\t\t\t\t\t\t\t\\\n-          {\t\t\t\t\t\t\t\t\\\n-\t    R##_c = FP_CLS_NAN; /* NAN */\t\t\t\t\\\n-\t    R##_s = _FP_NANSIGN_##fs;\t\t\t\t\t\\\n-\t    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);\t\t\t\\\n-\t    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\t\\\n-          }\t\t\t\t\t\t\t\t\\\n-\tR##_c = FP_CLS_NORMAL;\t\t\t\t\t\t\\\n-        if (X##_e & 1)\t\t\t\t\t\t\t\\\n-          _FP_FRAC_SLL_##wc(X, 1);\t\t\t\t\t\\\n-        R##_e = X##_e >> 1;\t\t\t\t\t\t\\\n-        _FP_FRAC_SET_##wc(S, _FP_ZEROFRAC_##wc);\t\t\t\\\n-        _FP_FRAC_SET_##wc(R, _FP_ZEROFRAC_##wc);\t\t\t\\\n-        q = _FP_OVERFLOW_##fs >> 1;\t\t\t\t\t\\\n-        _FP_SQRT_MEAT_##wc(R, S, T, X, q);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define _FP_SQRT(fs, wc, R, X)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_##wc (T);\t\t\t\t\t\\\n+      _FP_FRAC_DECL_##wc (S);\t\t\t\t\t\\\n+      _FP_W_TYPE q;\t\t\t\t\t\t\\\n+      switch (X##_c)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\tcase FP_CLS_NAN:\t\t\t\t\t\\\n+\t  _FP_FRAC_COPY_##wc (R, X);\t\t\t\t\\\n+\t  R##_s = X##_s;\t\t\t\t\t\\\n+\t  R##_c = FP_CLS_NAN;\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\tcase FP_CLS_INF:\t\t\t\t\t\\\n+\t  if (X##_s)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      R##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+\t      R##_c = FP_CLS_NAN; /* NAN */\t\t\t\\\n+\t      _FP_FRAC_SET_##wc (R, _FP_NANFRAC_##fs);\t\t\\\n+\t      FP_SET_EXCEPTION (FP_EX_INVALID);\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      R##_s = 0;\t\t\t\t\t\\\n+\t      R##_c = FP_CLS_INF; /* sqrt(+inf) = +inf */\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\tcase FP_CLS_ZERO:\t\t\t\t\t\\\n+\t  R##_s = X##_s;\t\t\t\t\t\\\n+\t  R##_c = FP_CLS_ZERO; /* sqrt(+-0) = +-0 */\t\t\\\n+\t  break;\t\t\t\t\t\t\\\n+\tcase FP_CLS_NORMAL:\t\t\t\t\t\\\n+\t  R##_s = 0;\t\t\t\t\t\t\\\n+\t  if (X##_s)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      R##_c = FP_CLS_NAN; /* NAN */\t\t\t\\\n+\t      R##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+\t      _FP_FRAC_SET_##wc (R, _FP_NANFRAC_##fs);\t\t\\\n+\t      FP_SET_EXCEPTION (FP_EX_INVALID);\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  R##_c = FP_CLS_NORMAL;\t\t\t\t\\\n+\t  if (X##_e & 1)\t\t\t\t\t\\\n+\t    _FP_FRAC_SLL_##wc (X, 1);\t\t\t\t\\\n+\t  R##_e = X##_e >> 1;\t\t\t\t\t\\\n+\t  _FP_FRAC_SET_##wc (S, _FP_ZEROFRAC_##wc);\t\t\\\n+\t  _FP_FRAC_SET_##wc (R, _FP_ZEROFRAC_##wc);\t\t\\\n+\t  q = _FP_OVERFLOW_##fs >> 1;\t\t\t\t\\\n+\t  _FP_SQRT_MEAT_##wc (R, S, T, X, q);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /*\n  * Convert from FP to integer.  Input is raw.\n@@ -1049,292 +1298,306 @@ do {\t\t\t\t\t\t\t\t\t\\\n  *     depending on the sign in such case.\n  */\n #define _FP_TO_INT(fs, wc, r, X, rsize, rsigned)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (X##_e < _FP_EXPBIAS_##fs)\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      r = 0;\t\t\t\t\t\t\t\t\\\n-      if (X##_e == 0)\t\t\t\t\t\t\t\\\n+      if (X##_e < _FP_EXPBIAS_##fs)\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (!_FP_FRAC_ZEROP_##wc(X))\t\t\t\t\t\\\n+\t  r = 0;\t\t\t\t\t\t\t\\\n+\t  if (X##_e == 0)\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n-\t      FP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\t\\\n-\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\t\\\n+\t      if (!_FP_FRAC_ZEROP_##wc (X))\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  FP_SET_EXCEPTION (FP_EX_INEXACT);\t\t\t\\\n+\t\t  FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    FP_SET_EXCEPTION (FP_EX_INEXACT);\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tFP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (X##_e >= _FP_EXPBIAS_##fs + rsize - (rsigned > 0 || X##_s)\t\\\n-\t   || (!rsigned && X##_s))\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* Overflow or converting to the most negative integer.  */\t\\\n-      if (rsigned)\t\t\t\t\t\t\t\\\n+      else if (X##_e >= _FP_EXPBIAS_##fs + rsize - (rsigned > 0 || X##_s) \\\n+\t       || (!rsigned && X##_s))\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  r = 1;\t\t\t\t\t\t\t\\\n-\t  r <<= rsize - 1;\t\t\t\t\t\t\\\n-\t  r -= 1 - X##_s;\t\t\t\t\t\t\\\n-\t} else {\t\t\t\t\t\t\t\\\n-\t  r = 0;\t\t\t\t\t\t\t\\\n-\t  if (X##_s)\t\t\t\t\t\t\t\\\n-\t    r = ~r;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n+\t  /* Overflow or converting to the most negative integer.  */\t\\\n+\t  if (rsigned)\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      r = 1;\t\t\t\t\t\t\t\\\n+\t      r <<= rsize - 1;\t\t\t\t\t\t\\\n+\t      r -= 1 - X##_s;\t\t\t\t\t\t\\\n+\t    } else {\t\t\t\t\t\t\t\\\n+\t    r = 0;\t\t\t\t\t\t\t\\\n+\t    if (!X##_s)\t\t\t\t\t\t\t\\\n+\t      r = ~r;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (rsigned && X##_s && X##_e == _FP_EXPBIAS_##fs + rsize - 1)\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  /* Possibly converting to most negative integer; check the\t\\\n-\t     mantissa.  */\t\t\t\t\t\t\\\n-\t  int inexact = 0;\t\t\t\t\t\t\\\n-\t  (void)((_FP_FRACBITS_##fs > rsize)\t\t\t\t\\\n-\t\t ? ({ _FP_FRAC_SRST_##wc(X, inexact,\t\t\t\\\n-\t\t\t\t\t _FP_FRACBITS_##fs - rsize,\t\\\n-\t\t\t\t\t _FP_FRACBITS_##fs); 0; })\t\\\n-\t\t : 0);\t\t\t\t\t\t\t\\\n-\t  if (!_FP_FRAC_ZEROP_##wc(X))\t\t\t\t\t\\\n-\t    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n-\t  else if (inexact)\t\t\t\t\t\t\\\n-\t    FP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\t\\\n+\t  if (rsigned && X##_s && X##_e == _FP_EXPBIAS_##fs + rsize - 1) \\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      /* Possibly converting to most negative integer; check the \\\n+\t\t mantissa.  */\t\t\t\t\t\t\\\n+\t      int inexact = 0;\t\t\t\t\t\t\\\n+\t      (void) ((_FP_FRACBITS_##fs > rsize)\t\t\t\\\n+\t\t      ? ({\t\t\t\t\t\t\\\n+\t\t\t  _FP_FRAC_SRST_##wc (X, inexact,\t\t\\\n+\t\t\t\t\t      _FP_FRACBITS_##fs - rsize, \\\n+\t\t\t\t\t      _FP_FRACBITS_##fs);\t\\\n+\t\t\t  0;\t\t\t\t\t\t\\\n+\t\t\t})\t\t\t\t\t\t\\\n+\t\t      : 0);\t\t\t\t\t\t\\\n+\t      if (!_FP_FRAC_ZEROP_##wc (X))\t\t\t\t\\\n+\t\tFP_SET_EXCEPTION (FP_EX_INVALID);\t\t\t\\\n+\t      else if (inexact)\t\t\t\t\t\t\\\n+\t\tFP_SET_EXCEPTION (FP_EX_INEXACT);\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    FP_SET_EXCEPTION (FP_EX_INVALID);\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n-\tFP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_HIGH_RAW_##fs (X) |= _FP_IMPLBIT_##fs;\t\t\\\n+\t  if (X##_e >= _FP_EXPBIAS_##fs + _FP_FRACBITS_##fs - 1)\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      _FP_FRAC_ASSEMBLE_##wc (r, X, rsize);\t\t\t\\\n+\t      r <<= X##_e - _FP_EXPBIAS_##fs - _FP_FRACBITS_##fs + 1;\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      int inexact;\t\t\t\t\t\t\\\n+\t      _FP_FRAC_SRST_##wc (X, inexact,\t\t\t\t\\\n+\t\t\t\t  (_FP_FRACBITS_##fs + _FP_EXPBIAS_##fs - 1 \\\n+\t\t\t\t   - X##_e),\t\t\t\t\\\n+\t\t\t\t  _FP_FRACBITS_##fs);\t\t\t\\\n+\t      if (inexact)\t\t\t\t\t\t\\\n+\t\tFP_SET_EXCEPTION (FP_EX_INEXACT);\t\t\t\\\n+\t      _FP_FRAC_ASSEMBLE_##wc (r, X, rsize);\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  if (rsigned && X##_s)\t\t\t\t\t\t\\\n+\t    r = -r;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Convert integer to fp.  Output is raw.  RTYPE is unsigned even if\n+   input is signed.  */\n+#define _FP_FROM_INT(fs, wc, X, r, rsize, rtype)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      _FP_FRAC_HIGH_RAW_##fs(X) |= _FP_IMPLBIT_##fs;\t\t\t\\\n-      if (X##_e >= _FP_EXPBIAS_##fs + _FP_FRACBITS_##fs - 1)\t\t\\\n+      if (r)\t\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);\t\t\t\t\\\n-\t  r <<= X##_e - _FP_EXPBIAS_##fs - _FP_FRACBITS_##fs + 1;\t\\\n+\t  rtype ur_;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if ((X##_s = (r < 0)))\t\t\t\t\t\\\n+\t    r = -(rtype) r;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  ur_ = (rtype) r;\t\t\t\t\t\t\\\n+\t  (void) ((rsize <= _FP_W_TYPE_SIZE)\t\t\t\t\\\n+\t\t  ? ({\t\t\t\t\t\t\t\\\n+\t\t      int lz_;\t\t\t\t\t\t\\\n+\t\t      __FP_CLZ (lz_, (_FP_W_TYPE) ur_);\t\t\t\\\n+\t\t      X##_e = _FP_EXPBIAS_##fs + _FP_W_TYPE_SIZE - 1 - lz_; \\\n+\t\t    })\t\t\t\t\t\t\t\\\n+\t\t  : ((rsize <= 2 * _FP_W_TYPE_SIZE)\t\t\t\\\n+\t\t     ? ({\t\t\t\t\t\t\\\n+\t\t\t int lz_;\t\t\t\t\t\\\n+\t\t\t __FP_CLZ_2 (lz_,\t\t\t\t\\\n+\t\t\t\t     (_FP_W_TYPE) (ur_ >> _FP_W_TYPE_SIZE), \\\n+\t\t\t\t     (_FP_W_TYPE) ur_);\t\t\t\\\n+\t\t\t X##_e = (_FP_EXPBIAS_##fs + 2 * _FP_W_TYPE_SIZE - 1 \\\n+\t\t\t\t  - lz_);\t\t\t\t\\\n+\t\t       })\t\t\t\t\t\t\\\n+\t\t     : (abort (), 0)));\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if (rsize - 1 + _FP_EXPBIAS_##fs >= _FP_EXPMAX_##fs\t\t\\\n+\t      && X##_e >= _FP_EXPMAX_##fs)\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      /* Exponent too big; overflow to infinity.  (May also\t\\\n+\t\t happen after rounding below.)  */\t\t\t\\\n+\t      _FP_OVERFLOW_SEMIRAW (fs, wc, X);\t\t\t\t\\\n+\t      goto pack_semiraw;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if (rsize <= _FP_FRACBITS_##fs\t\t\t\t\\\n+\t      || X##_e < _FP_EXPBIAS_##fs + _FP_FRACBITS_##fs)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      /* Exactly representable; shift left.  */\t\t\t\\\n+\t      _FP_FRAC_DISASSEMBLE_##wc (X, ur_, rsize);\t\t\\\n+\t      if (_FP_EXPBIAS_##fs + _FP_FRACBITS_##fs - 1 - X##_e > 0)\t\\\n+\t\t_FP_FRAC_SLL_##wc (X, (_FP_EXPBIAS_##fs\t\t\t\\\n+\t\t\t\t       + _FP_FRACBITS_##fs - 1 - X##_e)); \\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      /* More bits in integer than in floating type; need to\t\\\n+\t\t round.  */\t\t\t\t\t\t\\\n+\t      if (_FP_EXPBIAS_##fs + _FP_WFRACBITS_##fs - 1 < X##_e)\t\\\n+\t\tur_ = ((ur_ >> (X##_e - _FP_EXPBIAS_##fs\t\t\\\n+\t\t\t\t- _FP_WFRACBITS_##fs + 1))\t\t\\\n+\t\t       | ((ur_ << (rsize - (X##_e - _FP_EXPBIAS_##fs\t\\\n+\t\t\t\t\t    - _FP_WFRACBITS_##fs + 1)))\t\\\n+\t\t\t  != 0));\t\t\t\t\t\\\n+\t      _FP_FRAC_DISASSEMBLE_##wc (X, ur_, rsize);\t\t\\\n+\t      if ((_FP_EXPBIAS_##fs + _FP_WFRACBITS_##fs - 1 - X##_e) > 0) \\\n+\t\t_FP_FRAC_SLL_##wc (X, (_FP_EXPBIAS_##fs\t\t\t\\\n+\t\t\t\t       + _FP_WFRACBITS_##fs - 1 - X##_e)); \\\n+\t      _FP_FRAC_HIGH_##fs (X) &= ~(_FP_W_TYPE) _FP_IMPLBIT_SH_##fs; \\\n+\t    pack_semiraw:\t\t\t\t\t\t\\\n+\t      _FP_PACK_SEMIRAW (fs, wc, X);\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  int inexact;\t\t\t\t\t\t\t\\\n-\t  _FP_FRAC_SRST_##wc(X, inexact,\t\t\t\t\\\n-\t\t\t    (_FP_FRACBITS_##fs + _FP_EXPBIAS_##fs - 1\t\\\n-\t\t\t     - X##_e),\t\t\t\t\t\\\n-\t\t\t    _FP_FRACBITS_##fs);\t\t\t\t\\\n-\t  if (inexact)\t\t\t\t\t\t\t\\\n-\t    FP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\t\\\n-\t  _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);\t\t\t\t\\\n+\t  X##_s = 0;\t\t\t\t\t\t\t\\\n+\t  X##_e = 0;\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SET_##wc (X, _FP_ZEROFRAC_##wc);\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-      if (rsigned && X##_s)\t\t\t\t\t\t\\\n-\tr = -r;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* Convert integer to fp.  Output is raw.  RTYPE is unsigned even if\n-   input is signed.  */\n-#define _FP_FROM_INT(fs, wc, X, r, rsize, rtype)\t\t\t     \\\n-  do {\t\t\t\t\t\t\t\t\t     \\\n-    if (r)\t\t\t\t\t\t\t\t     \\\n-      {\t\t\t\t\t\t\t\t\t     \\\n-\trtype ur_;\t\t\t\t\t\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-\tif ((X##_s = (r < 0)))\t\t\t\t\t\t     \\\n-\t  r = -(rtype)r;\t\t\t\t\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-\tur_ = (rtype) r;\t\t\t\t\t\t     \\\n-\t(void)((rsize <= _FP_W_TYPE_SIZE)\t\t\t\t     \\\n-\t       ? ({\t\t\t\t\t\t\t     \\\n-\t\t    int lz_;\t\t\t\t\t\t     \\\n-\t\t    __FP_CLZ(lz_, (_FP_W_TYPE)ur_);\t\t\t     \\\n-\t\t    X##_e = _FP_EXPBIAS_##fs + _FP_W_TYPE_SIZE - 1 - lz_;    \\\n-\t\t  })\t\t\t\t\t\t\t     \\\n-\t       : ((rsize <= 2 * _FP_W_TYPE_SIZE)\t\t\t     \\\n-\t\t  ? ({\t\t\t\t\t\t\t     \\\n-\t\t       int lz_;\t\t\t\t\t\t     \\\n-\t\t       __FP_CLZ_2(lz_, (_FP_W_TYPE)(ur_ >> _FP_W_TYPE_SIZE), \\\n-\t\t\t\t  (_FP_W_TYPE)ur_);\t\t\t     \\\n-\t\t       X##_e = (_FP_EXPBIAS_##fs + 2 * _FP_W_TYPE_SIZE - 1   \\\n-\t\t\t\t- lz_);\t\t\t\t\t     \\\n-\t\t     })\t\t\t\t\t\t\t     \\\n-\t\t  : (abort(), 0)));\t\t\t\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-\tif (rsize - 1 + _FP_EXPBIAS_##fs >= _FP_EXPMAX_##fs\t\t     \\\n-\t    && X##_e >= _FP_EXPMAX_##fs)\t\t\t\t     \\\n-\t  {\t\t\t\t\t\t\t\t     \\\n-\t    /* Exponent too big; overflow to infinity.  (May also\t     \\\n-\t       happen after rounding below.)  */\t\t\t     \\\n-\t    _FP_OVERFLOW_SEMIRAW(fs, wc, X);\t\t\t\t     \\\n-\t    goto pack_semiraw;\t\t\t\t\t\t     \\\n-\t  }\t\t\t\t\t\t\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-\tif (rsize <= _FP_FRACBITS_##fs\t\t\t\t\t     \\\n-\t    || X##_e < _FP_EXPBIAS_##fs + _FP_FRACBITS_##fs)\t\t     \\\n-\t  {\t\t\t\t\t\t\t\t     \\\n-\t    /* Exactly representable; shift left.  */\t\t\t     \\\n-\t    _FP_FRAC_DISASSEMBLE_##wc(X, ur_, rsize);\t\t\t     \\\n-\t    if (_FP_EXPBIAS_##fs + _FP_FRACBITS_##fs - 1 - X##_e > 0)\t     \\\n-\t      _FP_FRAC_SLL_##wc(X, (_FP_EXPBIAS_##fs\t\t\t     \\\n-\t\t\t\t    + _FP_FRACBITS_##fs - 1 - X##_e));\t     \\\n-\t  }\t\t\t\t\t\t\t\t     \\\n-\telse\t\t\t\t\t\t\t\t     \\\n-\t  {\t\t\t\t\t\t\t\t     \\\n-\t    /* More bits in integer than in floating type; need to\t     \\\n-\t       round.  */\t\t\t\t\t\t     \\\n-\t    if (_FP_EXPBIAS_##fs + _FP_WFRACBITS_##fs - 1 < X##_e)\t     \\\n-\t      ur_ = ((ur_ >> (X##_e - _FP_EXPBIAS_##fs\t\t\t     \\\n-\t\t\t      - _FP_WFRACBITS_##fs + 1))\t\t     \\\n-\t\t     | ((ur_ << (rsize - (X##_e - _FP_EXPBIAS_##fs\t     \\\n-\t\t\t\t\t  - _FP_WFRACBITS_##fs + 1)))\t     \\\n-\t\t\t!= 0));\t\t\t\t\t\t     \\\n-\t    _FP_FRAC_DISASSEMBLE_##wc(X, ur_, rsize);\t\t\t     \\\n-\t    if ((_FP_EXPBIAS_##fs + _FP_WFRACBITS_##fs - 1 - X##_e) > 0)     \\\n-\t      _FP_FRAC_SLL_##wc(X, (_FP_EXPBIAS_##fs\t\t\t     \\\n-\t\t\t\t    + _FP_WFRACBITS_##fs - 1 - X##_e));\t     \\\n-\t    _FP_FRAC_HIGH_##fs(X) &= ~(_FP_W_TYPE)_FP_IMPLBIT_SH_##fs;\t     \\\n-\t  pack_semiraw:\t\t\t\t\t\t\t     \\\n-\t    _FP_PACK_SEMIRAW(fs, wc, X);\t\t\t\t     \\\n-\t  }\t\t\t\t\t\t\t\t     \\\n-      }\t\t\t\t\t\t\t\t\t     \\\n-    else\t\t\t\t\t\t\t\t     \\\n-      {\t\t\t\t\t\t\t\t\t     \\\n-\tX##_s = 0;\t\t\t\t\t\t\t     \\\n-\tX##_e = 0;\t\t\t\t\t\t\t     \\\n-\t_FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\t\t     \\\n-      }\t\t\t\t\t\t\t\t\t     \\\n-  } while (0)\n+  while (0)\n \n \n /* Extend from a narrower floating-point format to a wider one.  Input\n    and output are raw.  */\n-#define FP_EXTEND(dfs,sfs,dwc,swc,D,S)\t\t\t\t\t \\\n-do {\t\t\t\t\t\t\t\t\t \\\n-  if (_FP_FRACBITS_##dfs < _FP_FRACBITS_##sfs\t\t\t\t \\\n-      || (_FP_EXPMAX_##dfs - _FP_EXPBIAS_##dfs\t\t\t\t \\\n-\t  < _FP_EXPMAX_##sfs - _FP_EXPBIAS_##sfs)\t\t\t \\\n-      || (_FP_EXPBIAS_##dfs < _FP_EXPBIAS_##sfs + _FP_FRACBITS_##sfs - 1 \\\n-\t  && _FP_EXPBIAS_##dfs != _FP_EXPBIAS_##sfs))\t\t\t \\\n-    abort();\t\t\t\t\t\t\t\t \\\n-  D##_s = S##_s;\t\t\t\t\t\t\t \\\n-  _FP_FRAC_COPY_##dwc##_##swc(D, S);\t\t\t\t\t \\\n-  if (_FP_EXP_NORMAL(sfs, swc, S))\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      D##_e = S##_e + _FP_EXPBIAS_##dfs - _FP_EXPBIAS_##sfs;\t\t \\\n-      _FP_FRAC_SLL_##dwc(D, (_FP_FRACBITS_##dfs - _FP_FRACBITS_##sfs));\t \\\n-    }\t\t\t\t\t\t\t\t\t \\\n-  else\t\t\t\t\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      if (S##_e == 0)\t\t\t\t\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  if (_FP_FRAC_ZEROP_##swc(S))\t\t\t\t\t \\\n-\t    D##_e = 0;\t\t\t\t\t\t\t \\\n-\t  else if (_FP_EXPBIAS_##dfs\t\t\t\t\t \\\n-\t\t   < _FP_EXPBIAS_##sfs + _FP_FRACBITS_##sfs - 1)\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\t \\\n-\t      _FP_FRAC_SLL_##dwc(D, (_FP_FRACBITS_##dfs\t\t\t \\\n-\t\t\t\t     - _FP_FRACBITS_##sfs));\t\t \\\n-\t      D##_e = 0;\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  else\t\t\t\t\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      int _lz;\t\t\t\t\t\t\t \\\n-\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\t \\\n-\t      _FP_FRAC_CLZ_##swc(_lz, S);\t\t\t\t \\\n-\t      _FP_FRAC_SLL_##dwc(D,\t\t\t\t\t \\\n-\t\t\t\t _lz + _FP_FRACBITS_##dfs\t\t \\\n-\t\t\t\t - _FP_FRACTBITS_##sfs);\t\t \\\n-\t      D##_e = (_FP_EXPBIAS_##dfs - _FP_EXPBIAS_##sfs + 1\t \\\n-\t\t       + _FP_FRACXBITS_##sfs - _lz);\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-      else\t\t\t\t\t\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  D##_e = _FP_EXPMAX_##dfs;\t\t\t\t\t \\\n-\t  if (!_FP_FRAC_ZEROP_##swc(S))\t\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      if (_FP_FRAC_SNANP(sfs, S))\t\t\t\t \\\n-\t\tFP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t \\\n-\t      _FP_FRAC_SLL_##dwc(D, (_FP_FRACBITS_##dfs\t\t\t \\\n-\t\t\t\t     - _FP_FRACBITS_##sfs));\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-    }\t\t\t\t\t\t\t\t\t \\\n-} while (0)\n+#define FP_EXTEND(dfs, sfs, dwc, swc, D, S)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (_FP_FRACBITS_##dfs < _FP_FRACBITS_##sfs\t\t\t\\\n+\t  || (_FP_EXPMAX_##dfs - _FP_EXPBIAS_##dfs\t\t\t\\\n+\t      < _FP_EXPMAX_##sfs - _FP_EXPBIAS_##sfs)\t\t\t\\\n+\t  || (_FP_EXPBIAS_##dfs < _FP_EXPBIAS_##sfs + _FP_FRACBITS_##sfs - 1 \\\n+\t      && _FP_EXPBIAS_##dfs != _FP_EXPBIAS_##sfs))\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+      D##_s = S##_s;\t\t\t\t\t\t\t\\\n+      _FP_FRAC_COPY_##dwc##_##swc (D, S);\t\t\t\t\\\n+      if (_FP_EXP_NORMAL (sfs, swc, S))\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  D##_e = S##_e + _FP_EXPBIAS_##dfs - _FP_EXPBIAS_##sfs;\t\\\n+\t  _FP_FRAC_SLL_##dwc (D, (_FP_FRACBITS_##dfs - _FP_FRACBITS_##sfs)); \\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (S##_e == 0)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (_FP_FRAC_ZEROP_##swc (S))\t\t\t\t\\\n+\t\tD##_e = 0;\t\t\t\t\t\t\\\n+\t      else if (_FP_EXPBIAS_##dfs\t\t\t\t\\\n+\t\t       < _FP_EXPBIAS_##sfs + _FP_FRACBITS_##sfs - 1)\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\t\\\n+\t\t  _FP_FRAC_SLL_##dwc (D, (_FP_FRACBITS_##dfs\t\t\\\n+\t\t\t\t\t  - _FP_FRACBITS_##sfs));\t\\\n+\t\t  D##_e = 0;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  int _lz;\t\t\t\t\t\t\\\n+\t\t  FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\t\\\n+\t\t  _FP_FRAC_CLZ_##swc (_lz, S);\t\t\t\t\\\n+\t\t  _FP_FRAC_SLL_##dwc (D,\t\t\t\t\\\n+\t\t\t\t      _lz + _FP_FRACBITS_##dfs\t\t\\\n+\t\t\t\t      - _FP_FRACTBITS_##sfs);\t\t\\\n+\t\t  D##_e = (_FP_EXPBIAS_##dfs - _FP_EXPBIAS_##sfs + 1\t\\\n+\t\t\t   + _FP_FRACXBITS_##sfs - _lz);\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      D##_e = _FP_EXPMAX_##dfs;\t\t\t\t\t\\\n+\t      if (!_FP_FRAC_ZEROP_##swc (S))\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  if (_FP_FRAC_SNANP (sfs, S))\t\t\t\t\\\n+\t\t    FP_SET_EXCEPTION (FP_EX_INVALID);\t\t\t\\\n+\t\t  _FP_FRAC_SLL_##dwc (D, (_FP_FRACBITS_##dfs\t\t\\\n+\t\t\t\t\t  - _FP_FRACBITS_##sfs));\t\\\n+\t\t  _FP_SETQNAN (dfs, dwc, D);\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Truncate from a wider floating-point format to a narrower one.\n    Input and output are semi-raw.  */\n-#define FP_TRUNC(dfs,sfs,dwc,swc,D,S)\t\t\t\t\t     \\\n-do {\t\t\t\t\t\t\t\t\t     \\\n-  if (_FP_FRACBITS_##sfs < _FP_FRACBITS_##dfs\t\t\t\t     \\\n-      || (_FP_EXPBIAS_##sfs < _FP_EXPBIAS_##dfs + _FP_FRACBITS_##dfs - 1     \\\n-\t  && _FP_EXPBIAS_##sfs != _FP_EXPBIAS_##dfs))\t\t\t     \\\n-    abort();\t\t\t\t\t\t\t\t     \\\n-  D##_s = S##_s;\t\t\t\t\t\t\t     \\\n-  if (_FP_EXP_NORMAL(sfs, swc, S))\t\t\t\t\t     \\\n-    {\t\t\t\t\t\t\t\t\t     \\\n-      D##_e = S##_e + _FP_EXPBIAS_##dfs - _FP_EXPBIAS_##sfs;\t\t     \\\n-      if (D##_e >= _FP_EXPMAX_##dfs)\t\t\t\t\t     \\\n-\t_FP_OVERFLOW_SEMIRAW(dfs, dwc, D);\t\t\t\t     \\\n-      else\t\t\t\t\t\t\t\t     \\\n-\t{\t\t\t\t\t\t\t\t     \\\n-\t  if (D##_e <= 0)\t\t\t\t\t\t     \\\n-\t    {\t\t\t\t\t\t\t\t     \\\n-\t      if (D##_e < 1 - _FP_FRACBITS_##dfs)\t\t\t     \\\n-\t\t{\t\t\t\t\t\t\t     \\\n-\t\t  _FP_FRAC_SET_##swc(S, _FP_ZEROFRAC_##swc);\t\t     \\\n-\t\t  _FP_FRAC_LOW_##swc(S) |= 1;\t\t\t\t     \\\n-\t\t}\t\t\t\t\t\t\t     \\\n-\t      else\t\t\t\t\t\t\t     \\\n-\t\t{\t\t\t\t\t\t\t     \\\n-\t\t  _FP_FRAC_HIGH_##sfs(S) |= _FP_IMPLBIT_SH_##sfs;\t     \\\n-\t\t  _FP_FRAC_SRS_##swc(S, (_FP_WFRACBITS_##sfs\t\t     \\\n-\t\t\t\t\t - _FP_WFRACBITS_##dfs + 1 - D##_e), \\\n-\t\t\t\t     _FP_WFRACBITS_##sfs);\t\t     \\\n-\t\t}\t\t\t\t\t\t\t     \\\n-\t      D##_e = 0;\t\t\t\t\t\t     \\\n-\t    }\t\t\t\t\t\t\t\t     \\\n-\t  else\t\t\t\t\t\t\t\t     \\\n-\t    _FP_FRAC_SRS_##swc(S, (_FP_WFRACBITS_##sfs\t\t\t     \\\n-\t\t\t\t   - _FP_WFRACBITS_##dfs),\t\t     \\\n-\t\t\t       _FP_WFRACBITS_##sfs);\t\t\t     \\\n-\t  _FP_FRAC_COPY_##dwc##_##swc(D, S);\t\t\t\t     \\\n-\t}\t\t\t\t\t\t\t\t     \\\n-    }\t\t\t\t\t\t\t\t\t     \\\n-  else\t\t\t\t\t\t\t\t\t     \\\n-    {\t\t\t\t\t\t\t\t\t     \\\n-      if (S##_e == 0)\t\t\t\t\t\t\t     \\\n-\t{\t\t\t\t\t\t\t\t     \\\n-\t  D##_e = 0;\t\t\t\t\t\t\t     \\\n-\t  if (_FP_FRAC_ZEROP_##swc(S))\t\t\t\t\t     \\\n-\t    _FP_FRAC_SET_##dwc(D, _FP_ZEROFRAC_##dwc);\t\t\t     \\\n-\t  else\t\t\t\t\t\t\t\t     \\\n-\t    {\t\t\t\t\t\t\t\t     \\\n-\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\t     \\\n-\t      if (_FP_EXPBIAS_##sfs\t\t\t\t\t     \\\n-\t\t  < _FP_EXPBIAS_##dfs + _FP_FRACBITS_##dfs - 1)\t\t     \\\n-\t\t{\t\t\t\t\t\t\t     \\\n-\t\t  _FP_FRAC_SRS_##swc(S, (_FP_WFRACBITS_##sfs\t\t     \\\n-\t\t\t\t\t - _FP_WFRACBITS_##dfs),\t     \\\n-\t\t\t\t     _FP_WFRACBITS_##sfs);\t\t     \\\n-\t\t  _FP_FRAC_COPY_##dwc##_##swc(D, S);\t\t\t     \\\n-\t\t}\t\t\t\t\t\t\t     \\\n-\t      else\t\t\t\t\t\t\t     \\\n-\t\t{\t\t\t\t\t\t\t     \\\n-\t\t  _FP_FRAC_SET_##dwc(D, _FP_ZEROFRAC_##dwc);\t\t     \\\n-\t\t  _FP_FRAC_LOW_##dwc(D) |= 1;\t\t\t\t     \\\n-\t\t}\t\t\t\t\t\t\t     \\\n-\t    }\t\t\t\t\t\t\t\t     \\\n-\t}\t\t\t\t\t\t\t\t     \\\n-      else\t\t\t\t\t\t\t\t     \\\n-\t{\t\t\t\t\t\t\t\t     \\\n-\t  D##_e = _FP_EXPMAX_##dfs;\t\t\t\t\t     \\\n-\t  if (_FP_FRAC_ZEROP_##swc(S))\t\t\t\t\t     \\\n-\t    _FP_FRAC_SET_##dwc(D, _FP_ZEROFRAC_##dwc);\t\t\t     \\\n-\t  else\t\t\t\t\t\t\t\t     \\\n-\t    {\t\t\t\t\t\t\t\t     \\\n-\t      _FP_CHECK_SIGNAN_SEMIRAW(sfs, swc, S);\t\t\t     \\\n-\t      _FP_FRAC_SRL_##swc(S, (_FP_WFRACBITS_##sfs\t\t     \\\n-\t\t\t\t     - _FP_WFRACBITS_##dfs));\t\t     \\\n-\t      _FP_FRAC_COPY_##dwc##_##swc(D, S);\t\t\t     \\\n-\t      /* Semi-raw NaN must have all workbits cleared.  */\t     \\\n-\t      _FP_FRAC_LOW_##dwc(D)\t\t\t\t\t     \\\n-\t\t&= ~(_FP_W_TYPE) ((1 << _FP_WORKBITS) - 1);\t\t     \\\n-\t      _FP_SETQNAN_SEMIRAW(dfs, dwc, D);\t\t\t\t     \\\n-\t    }\t\t\t\t\t\t\t\t     \\\n-\t}\t\t\t\t\t\t\t\t     \\\n-    }\t\t\t\t\t\t\t\t\t     \\\n-} while (0)\n+#define FP_TRUNC(dfs, sfs, dwc, swc, D, S)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (_FP_FRACBITS_##sfs < _FP_FRACBITS_##dfs\t\t\t\\\n+\t  || (_FP_EXPBIAS_##sfs < _FP_EXPBIAS_##dfs + _FP_FRACBITS_##dfs - 1 \\\n+\t      && _FP_EXPBIAS_##sfs != _FP_EXPBIAS_##dfs))\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+      D##_s = S##_s;\t\t\t\t\t\t\t\\\n+      if (_FP_EXP_NORMAL (sfs, swc, S))\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  D##_e = S##_e + _FP_EXPBIAS_##dfs - _FP_EXPBIAS_##sfs;\t\\\n+\t  if (D##_e >= _FP_EXPMAX_##dfs)\t\t\t\t\\\n+\t    _FP_OVERFLOW_SEMIRAW (dfs, dwc, D);\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (D##_e <= 0)\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  if (D##_e < 1 - _FP_FRACBITS_##dfs)\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      _FP_FRAC_SET_##swc (S, _FP_ZEROFRAC_##swc);\t\\\n+\t\t      _FP_FRAC_LOW_##swc (S) |= 1;\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      _FP_FRAC_HIGH_##sfs (S) |= _FP_IMPLBIT_SH_##sfs;\t\\\n+\t\t      _FP_FRAC_SRS_##swc (S, (_FP_WFRACBITS_##sfs\t\\\n+\t\t\t\t\t      - _FP_WFRACBITS_##dfs\t\\\n+\t\t\t\t\t      + 1 - D##_e),\t\t\\\n+\t\t\t\t\t  _FP_WFRACBITS_##sfs);\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  D##_e = 0;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\t_FP_FRAC_SRS_##swc (S, (_FP_WFRACBITS_##sfs\t\t\\\n+\t\t\t\t\t- _FP_WFRACBITS_##dfs),\t\t\\\n+\t\t\t\t    _FP_WFRACBITS_##sfs);\t\t\\\n+\t      _FP_FRAC_COPY_##dwc##_##swc (D, S);\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (S##_e == 0)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      D##_e = 0;\t\t\t\t\t\t\\\n+\t      if (_FP_FRAC_ZEROP_##swc (S))\t\t\t\t\\\n+\t\t_FP_FRAC_SET_##dwc (D, _FP_ZEROFRAC_##dwc);\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  FP_SET_EXCEPTION (FP_EX_DENORM);\t\t\t\\\n+\t\t  if (_FP_EXPBIAS_##sfs\t\t\t\t\t\\\n+\t\t      < _FP_EXPBIAS_##dfs + _FP_FRACBITS_##dfs - 1)\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      _FP_FRAC_SRS_##swc (S, (_FP_WFRACBITS_##sfs\t\\\n+\t\t\t\t\t      - _FP_WFRACBITS_##dfs),\t\\\n+\t\t\t\t\t  _FP_WFRACBITS_##sfs);\t\t\\\n+\t\t      _FP_FRAC_COPY_##dwc##_##swc (D, S);\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t  else\t\t\t\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      _FP_FRAC_SET_##dwc (D, _FP_ZEROFRAC_##dwc);\t\\\n+\t\t      _FP_FRAC_LOW_##dwc (D) |= 1;\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      D##_e = _FP_EXPMAX_##dfs;\t\t\t\t\t\\\n+\t      if (_FP_FRAC_ZEROP_##swc (S))\t\t\t\t\\\n+\t\t_FP_FRAC_SET_##dwc (D, _FP_ZEROFRAC_##dwc);\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW (sfs, swc, S);\t\t\\\n+\t\t  _FP_FRAC_SRL_##swc (S, (_FP_WFRACBITS_##sfs\t\t\\\n+\t\t\t\t\t  - _FP_WFRACBITS_##dfs));\t\\\n+\t\t  _FP_FRAC_COPY_##dwc##_##swc (D, S);\t\t\t\\\n+\t\t  /* Semi-raw NaN must have all workbits cleared.  */\t\\\n+\t\t  _FP_FRAC_LOW_##dwc (D)\t\t\t\t\\\n+\t\t    &= ~(_FP_W_TYPE) ((1 << _FP_WORKBITS) - 1);\t\t\\\n+\t\t  _FP_SETQNAN_SEMIRAW (dfs, dwc, D);\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /*\n  * Helper primitives.\n@@ -1344,64 +1607,72 @@ do {\t\t\t\t\t\t\t\t\t     \\\n \n #ifndef __FP_CLZ\n /* GCC 3.4 and later provide the builtins for us.  */\n-#define __FP_CLZ(r, x)\t\t\t\t\t\t\t      \\\n-  do {\t\t\t\t\t\t\t\t\t      \\\n-    if (sizeof (_FP_W_TYPE) == sizeof (unsigned int))\t\t\t      \\\n-      r = __builtin_clz (x);\t\t\t\t\t\t      \\\n-    else if (sizeof (_FP_W_TYPE) == sizeof (unsigned long))\t\t      \\\n-      r = __builtin_clzl (x);\t\t\t\t\t\t      \\\n-    else if (sizeof (_FP_W_TYPE) == sizeof (unsigned long long))\t      \\\n-      r = __builtin_clzll (x);\t\t\t\t\t\t      \\\n-    else\t\t\t\t\t\t\t\t      \\\n-      abort ();\t\t\t\t\t\t\t\t      \\\n-  } while (0)\n+# define __FP_CLZ(r, x)\t\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (sizeof (_FP_W_TYPE) == sizeof (unsigned int))\t\t\t\\\n+\tr = __builtin_clz (x);\t\t\t\t\t\t\\\n+      else if (sizeof (_FP_W_TYPE) == sizeof (unsigned long))\t\t\\\n+\tr = __builtin_clzl (x);\t\t\t\t\t\t\\\n+      else if (sizeof (_FP_W_TYPE) == sizeof (unsigned long long))\t\\\n+\tr = __builtin_clzll (x);\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif /* ndef __FP_CLZ */\n \n #define _FP_DIV_HELP_imm(q, r, n, d)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    q = n / d, r = n % d;\t\t\t\\\n-  } while (0)\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      q = n / d, r = n % d;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n \n /* A restoring bit-by-bit division primitive.  */\n \n #define _FP_DIV_MEAT_N_loop(fs, wc, R, X, Y)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    int count = _FP_WFRACBITS_##fs;\t\t\t\t\t\\\n-    _FP_FRAC_DECL_##wc (u);\t\t\t\t\t\t\\\n-    _FP_FRAC_DECL_##wc (v);\t\t\t\t\t\t\\\n-    _FP_FRAC_COPY_##wc (u, X);\t\t\t\t\t\t\\\n-    _FP_FRAC_COPY_##wc (v, Y);\t\t\t\t\t\t\\\n-    _FP_FRAC_SET_##wc (R, _FP_ZEROFRAC_##wc);\t\t\t\t\\\n-    /* Normalize U and V.  */\t\t\t\t\t\t\\\n-    _FP_FRAC_SLL_##wc (u, _FP_WFRACXBITS_##fs);\t\t\t\t\\\n-    _FP_FRAC_SLL_##wc (v, _FP_WFRACXBITS_##fs);\t\t\t\t\\\n-    /* First round.  Since the operands are normalized, either the\t\\\n-       first or second bit will be set in the fraction.  Produce a\t\\\n-       normalized result by checking which and adjusting the loop\t\\\n-       count and exponent accordingly.  */\t\t\t\t\\\n-    if (_FP_FRAC_GE_1 (u, v))\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t_FP_FRAC_SUB_##wc (u, u, v);\t\t\t\t\t\\\n-\t_FP_FRAC_LOW_##wc (R) |= 1;\t\t\t\t\t\\\n-\tcount--;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      R##_e--;\t\t\t\t\t\t\t\t\\\n-    /* Subsequent rounds.  */\t\t\t\t\t\t\\\n-    do {\t\t\t\t\t\t\t\t\\\n-      int msb = (_FP_WS_TYPE) _FP_FRAC_HIGH_##wc (u) < 0;\t\t\\\n-      _FP_FRAC_SLL_##wc (u, 1);\t\t\t\t\t\t\\\n-      _FP_FRAC_SLL_##wc (R, 1);\t\t\t\t\t\t\\\n-      if (msb || _FP_FRAC_GE_1 (u, v))\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int count = _FP_WFRACBITS_##fs;\t\t\t\t\t\\\n+      _FP_FRAC_DECL_##wc (u);\t\t\t\t\t\t\\\n+      _FP_FRAC_DECL_##wc (v);\t\t\t\t\t\t\\\n+      _FP_FRAC_COPY_##wc (u, X);\t\t\t\t\t\\\n+      _FP_FRAC_COPY_##wc (v, Y);\t\t\t\t\t\\\n+      _FP_FRAC_SET_##wc (R, _FP_ZEROFRAC_##wc);\t\t\t\t\\\n+      /* Normalize U and V.  */\t\t\t\t\t\t\\\n+      _FP_FRAC_SLL_##wc (u, _FP_WFRACXBITS_##fs);\t\t\t\\\n+      _FP_FRAC_SLL_##wc (v, _FP_WFRACXBITS_##fs);\t\t\t\\\n+      /* First round.  Since the operands are normalized, either the\t\\\n+\t first or second bit will be set in the fraction.  Produce a\t\\\n+\t normalized result by checking which and adjusting the loop\t\\\n+\t count and exponent accordingly.  */\t\t\t\t\\\n+      if (_FP_FRAC_GE_1 (u, v))\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  _FP_FRAC_SUB_##wc (u, u, v);\t\t\t\t\t\\\n \t  _FP_FRAC_LOW_##wc (R) |= 1;\t\t\t\t\t\\\n+\t  count--;\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-    } while (--count > 0);\t\t\t\t\t\t\\\n-    /* If there's anything left in U, the result is inexact.  */\t\\\n-    _FP_FRAC_LOW_##wc (R) |= !_FP_FRAC_ZEROP_##wc (u);\t\t\t\\\n-  } while (0)\n+      else\t\t\t\t\t\t\t\t\\\n+\tR##_e--;\t\t\t\t\t\t\t\\\n+      /* Subsequent rounds.  */\t\t\t\t\t\t\\\n+      do\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  int msb = (_FP_WS_TYPE) _FP_FRAC_HIGH_##wc (u) < 0;\t\t\\\n+\t  _FP_FRAC_SLL_##wc (u, 1);\t\t\t\t\t\\\n+\t  _FP_FRAC_SLL_##wc (R, 1);\t\t\t\t\t\\\n+\t  if (msb || _FP_FRAC_GE_1 (u, v))\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      _FP_FRAC_SUB_##wc (u, u, v);\t\t\t\t\\\n+\t      _FP_FRAC_LOW_##wc (R) |= 1;\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      while (--count > 0);\t\t\t\t\t\t\\\n+      /* If there's anything left in U, the result is inexact.  */\t\\\n+      _FP_FRAC_LOW_##wc (R) |= !_FP_FRAC_ZEROP_##wc (u);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n #define _FP_DIV_MEAT_1_loop(fs, R, X, Y)  _FP_DIV_MEAT_N_loop (fs, 1, R, X, Y)\n #define _FP_DIV_MEAT_2_loop(fs, R, X, Y)  _FP_DIV_MEAT_N_loop (fs, 2, R, X, Y)"}, {"sha": "5002da5a533accd11be91ff96927643b86be01b0", "filename": "libgcc/soft-fp/quad.h", "status": "modified", "additions": 241, "deletions": 190, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fquad.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fquad.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fquad.h?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,13 +31,15 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #if _FP_W_TYPE_SIZE < 32\n-#error \"Here's a nickel, kid. Go buy yourself a real computer.\"\n+# error \"Here's a nickel, kid. Go buy yourself a real computer.\"\n #endif\n \n #if _FP_W_TYPE_SIZE < 64\n-#define _FP_FRACTBITS_Q         (4*_FP_W_TYPE_SIZE)\n+# define _FP_FRACTBITS_Q\t(4*_FP_W_TYPE_SIZE)\n+# define _FP_FRACTBITS_DW_Q\t(8*_FP_W_TYPE_SIZE)\n #else\n-#define _FP_FRACTBITS_Q\t\t(2*_FP_W_TYPE_SIZE)\n+# define _FP_FRACTBITS_Q\t\t(2*_FP_W_TYPE_SIZE)\n+# define _FP_FRACTBITS_DW_Q\t(4*_FP_W_TYPE_SIZE)\n #endif\n \n #define _FP_FRACBITS_Q\t\t113\n@@ -49,222 +51,271 @@\n #define _FP_EXPMAX_Q\t\t32767\n \n #define _FP_QNANBIT_Q\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_Q-2) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_Q-2) % _FP_W_TYPE_SIZE)\n #define _FP_QNANBIT_SH_Q\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_Q-2+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_Q-2+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n #define _FP_IMPLBIT_Q\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_Q-1) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_Q-1) % _FP_W_TYPE_SIZE)\n #define _FP_IMPLBIT_SH_Q\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_FRACBITS_Q-1+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_Q-1+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n #define _FP_OVERFLOW_Q\t\t\\\n-\t((_FP_W_TYPE)1 << (_FP_WFRACBITS_Q % _FP_W_TYPE_SIZE))\n+\t((_FP_W_TYPE) 1 << (_FP_WFRACBITS_Q % _FP_W_TYPE_SIZE))\n \n-typedef float TFtype __attribute__((mode(TF)));\n+#define _FP_WFRACBITS_DW_Q\t(2 * _FP_WFRACBITS_Q)\n+#define _FP_WFRACXBITS_DW_Q\t(_FP_FRACTBITS_DW_Q - _FP_WFRACBITS_DW_Q)\n+#define _FP_HIGHBIT_DW_Q\t\\\n+  ((_FP_W_TYPE) 1 << (_FP_WFRACBITS_DW_Q - 1) % _FP_W_TYPE_SIZE)\n+\n+typedef float TFtype __attribute__ ((mode (TF)));\n \n #if _FP_W_TYPE_SIZE < 64\n \n union _FP_UNION_Q\n {\n-   TFtype flt;\n-   struct _FP_STRUCT_LAYOUT\n-   {\n-#if __BYTE_ORDER == __BIG_ENDIAN\n-      unsigned sign : 1;\n-      unsigned exp : _FP_EXPBITS_Q;\n-      unsigned long frac3 : _FP_FRACBITS_Q - (_FP_IMPLBIT_Q != 0)-(_FP_W_TYPE_SIZE * 3);\n-      unsigned long frac2 : _FP_W_TYPE_SIZE;\n-      unsigned long frac1 : _FP_W_TYPE_SIZE;\n-      unsigned long frac0 : _FP_W_TYPE_SIZE;\n-#else\n-      unsigned long frac0 : _FP_W_TYPE_SIZE;\n-      unsigned long frac1 : _FP_W_TYPE_SIZE;\n-      unsigned long frac2 : _FP_W_TYPE_SIZE;\n-      unsigned long frac3 : _FP_FRACBITS_Q - (_FP_IMPLBIT_Q != 0)-(_FP_W_TYPE_SIZE * 3);\n-      unsigned exp : _FP_EXPBITS_Q;\n-      unsigned sign : 1;\n-#endif /* not bigendian */\n-   } bits __attribute__((packed));\n+  TFtype flt;\n+  struct _FP_STRUCT_LAYOUT\n+  {\n+# if __BYTE_ORDER == __BIG_ENDIAN\n+    unsigned sign : 1;\n+    unsigned exp : _FP_EXPBITS_Q;\n+    unsigned long frac3 : _FP_FRACBITS_Q - (_FP_IMPLBIT_Q != 0)-(_FP_W_TYPE_SIZE * 3);\n+    unsigned long frac2 : _FP_W_TYPE_SIZE;\n+    unsigned long frac1 : _FP_W_TYPE_SIZE;\n+    unsigned long frac0 : _FP_W_TYPE_SIZE;\n+# else\n+    unsigned long frac0 : _FP_W_TYPE_SIZE;\n+    unsigned long frac1 : _FP_W_TYPE_SIZE;\n+    unsigned long frac2 : _FP_W_TYPE_SIZE;\n+    unsigned long frac3 : _FP_FRACBITS_Q - (_FP_IMPLBIT_Q != 0)-(_FP_W_TYPE_SIZE * 3);\n+    unsigned exp : _FP_EXPBITS_Q;\n+    unsigned sign : 1;\n+# endif /* not bigendian */\n+  } bits __attribute__ ((packed));\n };\n \n \n-#define FP_DECL_Q(X)\t\t_FP_DECL(4,X)\n-#define FP_UNPACK_RAW_Q(X,val)\t_FP_UNPACK_RAW_4(Q,X,val)\n-#define FP_UNPACK_RAW_QP(X,val)\t_FP_UNPACK_RAW_4_P(Q,X,val)\n-#define FP_PACK_RAW_Q(val,X)\t_FP_PACK_RAW_4(Q,val,X)\n-#define FP_PACK_RAW_QP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_4_P(Q,val,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_Q(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_4(Q,X,val);\t\t\\\n-    _FP_UNPACK_CANONICAL(Q,4,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_QP(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_4_P(Q,X,val);\t\\\n-    _FP_UNPACK_CANONICAL(Q,4,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_Q(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_4(Q,X,val);\t\t\\\n-    _FP_UNPACK_SEMIRAW(Q,4,X);\t\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_QP(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_4_P(Q,X,val);\t\\\n-    _FP_UNPACK_SEMIRAW(Q,4,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_Q(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(Q,4,X);\t\t\\\n-    _FP_PACK_RAW_4(Q,val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_QP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(Q,4,X);\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_4_P(Q,val,X);\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_Q(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(Q,4,X);\t\t\\\n-    _FP_PACK_RAW_4(Q,val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_QP(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(Q,4,X);\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_4_P(Q,val,X);\t\\\n-  } while (0)\n-\n-#define FP_ISSIGNAN_Q(X)\t\t_FP_ISSIGNAN(Q,4,X)\n-#define FP_NEG_Q(R,X)\t\t\t_FP_NEG(Q,4,R,X)\n-#define FP_ADD_Q(R,X,Y)\t\t\t_FP_ADD(Q,4,R,X,Y)\n-#define FP_SUB_Q(R,X,Y)\t\t\t_FP_SUB(Q,4,R,X,Y)\n-#define FP_MUL_Q(R,X,Y)\t\t\t_FP_MUL(Q,4,R,X,Y)\n-#define FP_DIV_Q(R,X,Y)\t\t\t_FP_DIV(Q,4,R,X,Y)\n-#define FP_SQRT_Q(R,X)\t\t\t_FP_SQRT(Q,4,R,X)\n-#define _FP_SQRT_MEAT_Q(R,S,T,X,Q)\t_FP_SQRT_MEAT_4(R,S,T,X,Q)\n-\n-#define FP_CMP_Q(r,X,Y,un)\t_FP_CMP(Q,4,r,X,Y,un)\n-#define FP_CMP_EQ_Q(r,X,Y)\t_FP_CMP_EQ(Q,4,r,X,Y)\n-#define FP_CMP_UNORD_Q(r,X,Y)\t_FP_CMP_UNORD(Q,4,r,X,Y)\n-\n-#define FP_TO_INT_Q(r,X,rsz,rsg)\t_FP_TO_INT(Q,4,r,X,rsz,rsg)\n-#define FP_FROM_INT_Q(X,r,rs,rt)\t_FP_FROM_INT(Q,4,X,r,rs,rt)\n-\n-#define _FP_FRAC_HIGH_Q(X)\t_FP_FRAC_HIGH_4(X)\n-#define _FP_FRAC_HIGH_RAW_Q(X)\t_FP_FRAC_HIGH_4(X)\n+# define FP_DECL_Q(X)\t\t_FP_DECL (4, X)\n+# define FP_UNPACK_RAW_Q(X, val)\t_FP_UNPACK_RAW_4 (Q, X, val)\n+# define FP_UNPACK_RAW_QP(X, val)\t_FP_UNPACK_RAW_4_P (Q, X, val)\n+# define FP_PACK_RAW_Q(val, X)\t_FP_PACK_RAW_4 (Q, val, X)\n+# define FP_PACK_RAW_QP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_4_P (Q, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_Q(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_4 (Q, X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (Q, 4, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_QP(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_4_P (Q, X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (Q, 4, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_Q(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_4 (Q, X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (Q, 4, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_QP(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_4_P (Q, X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (Q, 4, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_Q(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (Q, 4, X);\t\t\\\n+      _FP_PACK_RAW_4 (Q, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_QP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (Q, 4, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_4_P (Q, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_Q(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (Q, 4, X);\t\t\\\n+      _FP_PACK_RAW_4 (Q, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_QP(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (Q, 4, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_4_P (Q, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_ISSIGNAN_Q(X)\t\t_FP_ISSIGNAN (Q, 4, X)\n+# define FP_NEG_Q(R, X)\t\t\t_FP_NEG (Q, 4, R, X)\n+# define FP_ADD_Q(R, X, Y)\t\t_FP_ADD (Q, 4, R, X, Y)\n+# define FP_SUB_Q(R, X, Y)\t\t_FP_SUB (Q, 4, R, X, Y)\n+# define FP_MUL_Q(R, X, Y)\t\t_FP_MUL (Q, 4, R, X, Y)\n+# define FP_DIV_Q(R, X, Y)\t\t_FP_DIV (Q, 4, R, X, Y)\n+# define FP_SQRT_Q(R, X)\t\t_FP_SQRT (Q, 4, R, X)\n+# define _FP_SQRT_MEAT_Q(R, S, T, X, Q)\t_FP_SQRT_MEAT_4 (R, S, T, X, Q)\n+# define FP_FMA_Q(R, X, Y, Z)\t\t_FP_FMA (Q, 4, 8, R, X, Y, Z)\n+\n+# define FP_CMP_Q(r, X, Y, un)\t\t_FP_CMP (Q, 4, r, X, Y, un)\n+# define FP_CMP_EQ_Q(r, X, Y)\t\t_FP_CMP_EQ (Q, 4, r, X, Y)\n+# define FP_CMP_UNORD_Q(r, X, Y)\t_FP_CMP_UNORD (Q, 4, r, X, Y)\n+\n+# define FP_TO_INT_Q(r, X, rsz, rsg)\t_FP_TO_INT (Q, 4, r, X, rsz, rsg)\n+# define FP_FROM_INT_Q(X, r, rs, rt)\t_FP_FROM_INT (Q, 4, X, r, rs, rt)\n+\n+# define _FP_FRAC_HIGH_Q(X)\t_FP_FRAC_HIGH_4 (X)\n+# define _FP_FRAC_HIGH_RAW_Q(X)\t_FP_FRAC_HIGH_4 (X)\n+\n+# define _FP_FRAC_HIGH_DW_Q(X)\t_FP_FRAC_HIGH_8 (X)\n \n #else   /* not _FP_W_TYPE_SIZE < 64 */\n union _FP_UNION_Q\n {\n-  TFtype flt /* __attribute__((mode(TF))) */ ;\n-  struct _FP_STRUCT_LAYOUT {\n+  TFtype flt /* __attribute__ ((mode (TF))) */ ;\n+  struct _FP_STRUCT_LAYOUT\n+  {\n     _FP_W_TYPE a, b;\n   } longs;\n-  struct _FP_STRUCT_LAYOUT {\n-#if __BYTE_ORDER == __BIG_ENDIAN\n+  struct _FP_STRUCT_LAYOUT\n+  {\n+# if __BYTE_ORDER == __BIG_ENDIAN\n     unsigned sign    : 1;\n     unsigned exp     : _FP_EXPBITS_Q;\n     _FP_W_TYPE frac1 : _FP_FRACBITS_Q - (_FP_IMPLBIT_Q != 0) - _FP_W_TYPE_SIZE;\n     _FP_W_TYPE frac0 : _FP_W_TYPE_SIZE;\n-#else\n+# else\n     _FP_W_TYPE frac0 : _FP_W_TYPE_SIZE;\n     _FP_W_TYPE frac1 : _FP_FRACBITS_Q - (_FP_IMPLBIT_Q != 0) - _FP_W_TYPE_SIZE;\n     unsigned exp     : _FP_EXPBITS_Q;\n     unsigned sign    : 1;\n-#endif\n+# endif\n   } bits;\n };\n \n-#define FP_DECL_Q(X)\t\t_FP_DECL(2,X)\n-#define FP_UNPACK_RAW_Q(X,val)\t_FP_UNPACK_RAW_2(Q,X,val)\n-#define FP_UNPACK_RAW_QP(X,val)\t_FP_UNPACK_RAW_2_P(Q,X,val)\n-#define FP_PACK_RAW_Q(val,X)\t_FP_PACK_RAW_2(Q,val,X)\n-#define FP_PACK_RAW_QP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_2_P(Q,val,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_Q(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_2(Q,X,val);\t\t\\\n-    _FP_UNPACK_CANONICAL(Q,2,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_QP(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_2_P(Q,X,val);\t\\\n-    _FP_UNPACK_CANONICAL(Q,2,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_Q(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_2(Q,X,val);\t\t\\\n-    _FP_UNPACK_SEMIRAW(Q,2,X);\t\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_QP(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_2_P(Q,X,val);\t\\\n-    _FP_UNPACK_SEMIRAW(Q,2,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_Q(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(Q,2,X);\t\t\\\n-    _FP_PACK_RAW_2(Q,val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_QP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(Q,2,X);\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_2_P(Q,val,X);\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_Q(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(Q,2,X);\t\t\\\n-    _FP_PACK_RAW_2(Q,val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_QP(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(Q,2,X);\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_2_P(Q,val,X);\t\\\n-  } while (0)\n-\n-#define FP_ISSIGNAN_Q(X)\t\t_FP_ISSIGNAN(Q,2,X)\n-#define FP_NEG_Q(R,X)\t\t\t_FP_NEG(Q,2,R,X)\n-#define FP_ADD_Q(R,X,Y)\t\t\t_FP_ADD(Q,2,R,X,Y)\n-#define FP_SUB_Q(R,X,Y)\t\t\t_FP_SUB(Q,2,R,X,Y)\n-#define FP_MUL_Q(R,X,Y)\t\t\t_FP_MUL(Q,2,R,X,Y)\n-#define FP_DIV_Q(R,X,Y)\t\t\t_FP_DIV(Q,2,R,X,Y)\n-#define FP_SQRT_Q(R,X)\t\t\t_FP_SQRT(Q,2,R,X)\n-#define _FP_SQRT_MEAT_Q(R,S,T,X,Q)\t_FP_SQRT_MEAT_2(R,S,T,X,Q)\n-\n-#define FP_CMP_Q(r,X,Y,un)\t_FP_CMP(Q,2,r,X,Y,un)\n-#define FP_CMP_EQ_Q(r,X,Y)\t_FP_CMP_EQ(Q,2,r,X,Y)\n-#define FP_CMP_UNORD_Q(r,X,Y)\t_FP_CMP_UNORD(Q,2,r,X,Y)\n-\n-#define FP_TO_INT_Q(r,X,rsz,rsg)\t_FP_TO_INT(Q,2,r,X,rsz,rsg)\n-#define FP_FROM_INT_Q(X,r,rs,rt)\t_FP_FROM_INT(Q,2,X,r,rs,rt)\n-\n-#define _FP_FRAC_HIGH_Q(X)\t_FP_FRAC_HIGH_2(X)\n-#define _FP_FRAC_HIGH_RAW_Q(X)\t_FP_FRAC_HIGH_2(X)\n+# define FP_DECL_Q(X)\t\t_FP_DECL (2, X)\n+# define FP_UNPACK_RAW_Q(X, val)\t_FP_UNPACK_RAW_2 (Q, X, val)\n+# define FP_UNPACK_RAW_QP(X, val)\t_FP_UNPACK_RAW_2_P (Q, X, val)\n+# define FP_PACK_RAW_Q(val, X)\t_FP_PACK_RAW_2 (Q, val, X)\n+# define FP_PACK_RAW_QP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_2_P (Q, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_Q(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_2 (Q, X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (Q, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_QP(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_2_P (Q, X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (Q, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_Q(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_2 (Q, X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (Q, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_UNPACK_SEMIRAW_QP(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_2_P (Q, X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (Q, 2, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_Q(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (Q, 2, X);\t\t\\\n+      _FP_PACK_RAW_2 (Q, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_QP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (Q, 2, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_2_P (Q, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_Q(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (Q, 2, X);\t\t\\\n+      _FP_PACK_RAW_2 (Q, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_PACK_SEMIRAW_QP(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (Q, 2, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_2_P (Q, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+# define FP_ISSIGNAN_Q(X)\t\t_FP_ISSIGNAN (Q, 2, X)\n+# define FP_NEG_Q(R, X)\t\t\t_FP_NEG (Q, 2, R, X)\n+# define FP_ADD_Q(R, X, Y)\t\t_FP_ADD (Q, 2, R, X, Y)\n+# define FP_SUB_Q(R, X, Y)\t\t_FP_SUB (Q, 2, R, X, Y)\n+# define FP_MUL_Q(R, X, Y)\t\t_FP_MUL (Q, 2, R, X, Y)\n+# define FP_DIV_Q(R, X, Y)\t\t_FP_DIV (Q, 2, R, X, Y)\n+# define FP_SQRT_Q(R, X)\t\t_FP_SQRT (Q, 2, R, X)\n+# define _FP_SQRT_MEAT_Q(R, S, T, X, Q)\t_FP_SQRT_MEAT_2 (R, S, T, X, Q)\n+# define FP_FMA_Q(R, X, Y, Z)\t\t_FP_FMA (Q, 2, 4, R, X, Y, Z)\n+\n+# define FP_CMP_Q(r, X, Y, un)\t\t_FP_CMP (Q, 2, r, X, Y, un)\n+# define FP_CMP_EQ_Q(r, X, Y)\t\t_FP_CMP_EQ (Q, 2, r, X, Y)\n+# define FP_CMP_UNORD_Q(r, X, Y)\t_FP_CMP_UNORD (Q, 2, r, X, Y)\n+\n+# define FP_TO_INT_Q(r, X, rsz, rsg)\t_FP_TO_INT (Q, 2, r, X, rsz, rsg)\n+# define FP_FROM_INT_Q(X, r, rs, rt)\t_FP_FROM_INT (Q, 2, X, r, rs, rt)\n+\n+# define _FP_FRAC_HIGH_Q(X)\t_FP_FRAC_HIGH_2 (X)\n+# define _FP_FRAC_HIGH_RAW_Q(X)\t_FP_FRAC_HIGH_2 (X)\n+\n+# define _FP_FRAC_HIGH_DW_Q(X)\t_FP_FRAC_HIGH_4 (X)\n \n #endif /* not _FP_W_TYPE_SIZE < 64 */"}, {"sha": "af60c96e6820e88e77aeb5de3cb890c154b5ac80", "filename": "libgcc/soft-fp/single.h", "status": "modified", "additions": 129, "deletions": 87, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fsingle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fsingle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fsingle.h?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,33 +31,45 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #if _FP_W_TYPE_SIZE < 32\n-#error \"Here's a nickel kid.  Go buy yourself a real computer.\"\n+# error \"Here's a nickel kid.  Go buy yourself a real computer.\"\n #endif\n \n #define _FP_FRACTBITS_S\t\t_FP_W_TYPE_SIZE\n \n+#if _FP_W_TYPE_SIZE < 64\n+# define _FP_FRACTBITS_DW_S\t(2 * _FP_W_TYPE_SIZE)\n+#else\n+# define _FP_FRACTBITS_DW_S\t_FP_W_TYPE_SIZE\n+#endif\n+\n #define _FP_FRACBITS_S\t\t24\n #define _FP_FRACXBITS_S\t\t(_FP_FRACTBITS_S - _FP_FRACBITS_S)\n #define _FP_WFRACBITS_S\t\t(_FP_WORKBITS + _FP_FRACBITS_S)\n #define _FP_WFRACXBITS_S\t(_FP_FRACTBITS_S - _FP_WFRACBITS_S)\n #define _FP_EXPBITS_S\t\t8\n #define _FP_EXPBIAS_S\t\t127\n #define _FP_EXPMAX_S\t\t255\n-#define _FP_QNANBIT_S\t\t((_FP_W_TYPE)1 << (_FP_FRACBITS_S-2))\n-#define _FP_QNANBIT_SH_S\t((_FP_W_TYPE)1 << (_FP_FRACBITS_S-2+_FP_WORKBITS))\n-#define _FP_IMPLBIT_S\t\t((_FP_W_TYPE)1 << (_FP_FRACBITS_S-1))\n-#define _FP_IMPLBIT_SH_S\t((_FP_W_TYPE)1 << (_FP_FRACBITS_S-1+_FP_WORKBITS))\n-#define _FP_OVERFLOW_S\t\t((_FP_W_TYPE)1 << (_FP_WFRACBITS_S))\n+#define _FP_QNANBIT_S\t\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_S-2))\n+#define _FP_QNANBIT_SH_S\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_S-2+_FP_WORKBITS))\n+#define _FP_IMPLBIT_S\t\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_S-1))\n+#define _FP_IMPLBIT_SH_S\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_S-1+_FP_WORKBITS))\n+#define _FP_OVERFLOW_S\t\t((_FP_W_TYPE) 1 << (_FP_WFRACBITS_S))\n+\n+#define _FP_WFRACBITS_DW_S\t(2 * _FP_WFRACBITS_S)\n+#define _FP_WFRACXBITS_DW_S\t(_FP_FRACTBITS_DW_S - _FP_WFRACBITS_DW_S)\n+#define _FP_HIGHBIT_DW_S\t\\\n+  ((_FP_W_TYPE) 1 << (_FP_WFRACBITS_DW_S - 1) % _FP_W_TYPE_SIZE)\n \n /* The implementation of _FP_MUL_MEAT_S and _FP_DIV_MEAT_S should be\n    chosen by the target machine.  */\n \n-typedef float SFtype __attribute__((mode(SF)));\n+typedef float SFtype __attribute__ ((mode (SF)));\n \n union _FP_UNION_S\n {\n   SFtype flt;\n-  struct _FP_STRUCT_LAYOUT {\n+  struct _FP_STRUCT_LAYOUT\n+  {\n #if __BYTE_ORDER == __BIG_ENDIAN\n     unsigned sign : 1;\n     unsigned exp  : _FP_EXPBITS_S;\n@@ -67,84 +79,114 @@ union _FP_UNION_S\n     unsigned exp  : _FP_EXPBITS_S;\n     unsigned sign : 1;\n #endif\n-  } bits __attribute__((packed));\n+  } bits __attribute__ ((packed));\n };\n \n-#define FP_DECL_S(X)\t\t_FP_DECL(1,X)\n-#define FP_UNPACK_RAW_S(X,val)\t_FP_UNPACK_RAW_1(S,X,val)\n-#define FP_UNPACK_RAW_SP(X,val)\t_FP_UNPACK_RAW_1_P(S,X,val)\n-#define FP_PACK_RAW_S(val,X)\t_FP_PACK_RAW_1(S,val,X)\n-#define FP_PACK_RAW_SP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_1_P(S,val,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_S(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_1(S,X,val);\t\t\\\n-    _FP_UNPACK_CANONICAL(S,1,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SP(X,val)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_1_P(S,X,val);\t\\\n-    _FP_UNPACK_CANONICAL(S,1,X);\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_S(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_1(S,X,val);\t\t\\\n-    _FP_UNPACK_SEMIRAW(S,1,X);\t\t\\\n-  } while (0)\n-\n-#define FP_UNPACK_SEMIRAW_SP(X,val)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_UNPACK_RAW_1_P(S,X,val);\t\\\n-    _FP_UNPACK_SEMIRAW(S,1,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_S(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(S,1,X);\t\t\\\n-    _FP_PACK_RAW_1(S,val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_SP(val,X)\t\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_CANONICAL(S,1,X);\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_1_P(S,val,X);\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_S(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(S,1,X);\t\t\\\n-    _FP_PACK_RAW_1(S,val,X);\t\t\\\n-  } while (0)\n-\n-#define FP_PACK_SEMIRAW_SP(val,X)\t\\\n-  do {\t\t\t\t\t\\\n-    _FP_PACK_SEMIRAW(S,1,X);\t\t\\\n-    if (!FP_INHIBIT_RESULTS)\t\t\\\n-      _FP_PACK_RAW_1_P(S,val,X);\t\\\n-  } while (0)\n-\n-#define FP_ISSIGNAN_S(X)\t\t_FP_ISSIGNAN(S,1,X)\n-#define FP_NEG_S(R,X)\t\t\t_FP_NEG(S,1,R,X)\n-#define FP_ADD_S(R,X,Y)\t\t\t_FP_ADD(S,1,R,X,Y)\n-#define FP_SUB_S(R,X,Y)\t\t\t_FP_SUB(S,1,R,X,Y)\n-#define FP_MUL_S(R,X,Y)\t\t\t_FP_MUL(S,1,R,X,Y)\n-#define FP_DIV_S(R,X,Y)\t\t\t_FP_DIV(S,1,R,X,Y)\n-#define FP_SQRT_S(R,X)\t\t\t_FP_SQRT(S,1,R,X)\n-#define _FP_SQRT_MEAT_S(R,S,T,X,Q)\t_FP_SQRT_MEAT_1(R,S,T,X,Q)\n-\n-#define FP_CMP_S(r,X,Y,un)\t_FP_CMP(S,1,r,X,Y,un)\n-#define FP_CMP_EQ_S(r,X,Y)\t_FP_CMP_EQ(S,1,r,X,Y)\n-#define FP_CMP_UNORD_S(r,X,Y)\t_FP_CMP_UNORD(S,1,r,X,Y)\n-\n-#define FP_TO_INT_S(r,X,rsz,rsg)\t_FP_TO_INT(S,1,r,X,rsz,rsg)\n-#define FP_FROM_INT_S(X,r,rs,rt)\t_FP_FROM_INT(S,1,X,r,rs,rt)\n-\n-#define _FP_FRAC_HIGH_S(X)\t_FP_FRAC_HIGH_1(X)\n-#define _FP_FRAC_HIGH_RAW_S(X)\t_FP_FRAC_HIGH_1(X)\n+#define FP_DECL_S(X)\t\t_FP_DECL (1, X)\n+#define FP_UNPACK_RAW_S(X, val)\t_FP_UNPACK_RAW_1 (S, X, val)\n+#define FP_UNPACK_RAW_SP(X, val)\t_FP_UNPACK_RAW_1_P (S, X, val)\n+#define FP_PACK_RAW_S(val, X)\t_FP_PACK_RAW_1 (S, val, X)\n+#define FP_PACK_RAW_SP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_1_P (S, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_UNPACK_S(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1 (S, X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (S, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_UNPACK_SP(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1_P (S, X, val);\t\t\\\n+      _FP_UNPACK_CANONICAL (S, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_UNPACK_SEMIRAW_S(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1 (S, X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (S, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_UNPACK_SEMIRAW_SP(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1_P (S, X, val);\t\t\\\n+      _FP_UNPACK_SEMIRAW (S, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_PACK_S(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (S, 1, X);\t\t\\\n+      _FP_PACK_RAW_1 (S, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_PACK_SP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (S, 1, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_1_P (S, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_PACK_SEMIRAW_S(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (S, 1, X);\t\t\\\n+      _FP_PACK_RAW_1 (S, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_PACK_SEMIRAW_SP(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (S, 1, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_1_P (S, val, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_ISSIGNAN_S(X)\t\t_FP_ISSIGNAN (S, 1, X)\n+#define FP_NEG_S(R, X)\t\t\t_FP_NEG (S, 1, R, X)\n+#define FP_ADD_S(R, X, Y)\t\t_FP_ADD (S, 1, R, X, Y)\n+#define FP_SUB_S(R, X, Y)\t\t_FP_SUB (S, 1, R, X, Y)\n+#define FP_MUL_S(R, X, Y)\t\t_FP_MUL (S, 1, R, X, Y)\n+#define FP_DIV_S(R, X, Y)\t\t_FP_DIV (S, 1, R, X, Y)\n+#define FP_SQRT_S(R, X)\t\t\t_FP_SQRT (S, 1, R, X)\n+#define _FP_SQRT_MEAT_S(R, S, T, X, Q)\t_FP_SQRT_MEAT_1 (R, S, T, X, Q)\n+\n+#if _FP_W_TYPE_SIZE < 64\n+# define FP_FMA_S(R, X, Y, Z)\t_FP_FMA (S, 1, 2, R, X, Y, Z)\n+#else\n+# define FP_FMA_S(R, X, Y, Z)\t_FP_FMA (S, 1, 1, R, X, Y, Z)\n+#endif\n+\n+#define FP_CMP_S(r, X, Y, un)\t_FP_CMP (S, 1, r, X, Y, un)\n+#define FP_CMP_EQ_S(r, X, Y)\t_FP_CMP_EQ (S, 1, r, X, Y)\n+#define FP_CMP_UNORD_S(r, X, Y)\t_FP_CMP_UNORD (S, 1, r, X, Y)\n+\n+#define FP_TO_INT_S(r, X, rsz, rsg)\t_FP_TO_INT (S, 1, r, X, rsz, rsg)\n+#define FP_FROM_INT_S(X, r, rs, rt)\t_FP_FROM_INT (S, 1, X, r, rs, rt)\n+\n+#define _FP_FRAC_HIGH_S(X)\t_FP_FRAC_HIGH_1 (X)\n+#define _FP_FRAC_HIGH_RAW_S(X)\t_FP_FRAC_HIGH_1 (X)\n+\n+#if _FP_W_TYPE_SIZE < 64\n+# define _FP_FRAC_HIGH_DW_S(X)\t_FP_FRAC_HIGH_2 (X)\n+#else\n+# define _FP_FRAC_HIGH_DW_S(X)\t_FP_FRAC_HIGH_1 (X)\n+#endif"}, {"sha": "696fc8676c75f12e45274b4427f775cc861b6e8c", "filename": "libgcc/soft-fp/soft-fp.h", "status": "modified", "additions": 118, "deletions": 81, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fsoft-fp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fsoft-fp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fsoft-fp.h?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -33,25 +33,25 @@\n #define SOFT_FP_H\n \n #ifdef _LIBC\n-#include <sfp-machine.h>\n+# include <sfp-machine.h>\n #else\n-#include \"sfp-machine.h\"\n+# include \"sfp-machine.h\"\n #endif\n \n /* Allow sfp-machine to have its own byte order definitions. */\n #ifndef __BYTE_ORDER\n-#ifdef _LIBC\n-#include <endian.h>\n-#else\n-#error \"endianness not defined by sfp-machine.h\"\n-#endif\n+# ifdef _LIBC\n+#  include <endian.h>\n+# else\n+#  error \"endianness not defined by sfp-machine.h\"\n+# endif\n #endif\n \n #define _FP_WORKBITS\t\t3\n-#define _FP_WORK_LSB\t\t((_FP_W_TYPE)1 << 3)\n-#define _FP_WORK_ROUND\t\t((_FP_W_TYPE)1 << 2)\n-#define _FP_WORK_GUARD\t\t((_FP_W_TYPE)1 << 1)\n-#define _FP_WORK_STICKY\t\t((_FP_W_TYPE)1 << 0)\n+#define _FP_WORK_LSB\t\t((_FP_W_TYPE) 1 << 3)\n+#define _FP_WORK_ROUND\t\t((_FP_W_TYPE) 1 << 2)\n+#define _FP_WORK_GUARD\t\t((_FP_W_TYPE) 1 << 1)\n+#define _FP_WORK_STICKY\t\t((_FP_W_TYPE) 1 << 0)\n \n #ifndef FP_RND_NEAREST\n # define FP_RND_NEAREST\t\t0\n@@ -65,22 +65,22 @@\n \n /* By default don't care about exceptions. */\n #ifndef FP_EX_INVALID\n-#define FP_EX_INVALID\t\t0\n+# define FP_EX_INVALID\t\t0\n #endif\n #ifndef FP_EX_OVERFLOW\n-#define FP_EX_OVERFLOW\t\t0\n+# define FP_EX_OVERFLOW\t\t0\n #endif\n #ifndef FP_EX_UNDERFLOW\n-#define FP_EX_UNDERFLOW\t\t0\n+# define FP_EX_UNDERFLOW\t0\n #endif\n #ifndef FP_EX_DIVZERO\n-#define FP_EX_DIVZERO\t\t0\n+# define FP_EX_DIVZERO\t\t0\n #endif\n #ifndef FP_EX_INEXACT\n-#define FP_EX_INEXACT\t\t0\n+# define FP_EX_INEXACT\t\t0\n #endif\n #ifndef FP_EX_DENORM\n-#define FP_EX_DENORM\t\t0\n+# define FP_EX_DENORM\t\t0\n #endif\n \n /* _FP_STRUCT_LAYOUT may be defined as an attribute to determine the\n@@ -90,23 +90,31 @@\n    differences in how consecutive bit-fields are laid out from the\n    default expected by soft-fp.  */\n #ifndef _FP_STRUCT_LAYOUT\n-#define _FP_STRUCT_LAYOUT\n+# define _FP_STRUCT_LAYOUT\n #endif\n \n #ifdef _FP_DECL_EX\n-#define FP_DECL_EX\t\t\t\t\t\\\n+# define FP_DECL_EX\t\t\t\t\t\\\n   int _fex = 0;\t\t\t\t\t\t\\\n   _FP_DECL_EX\n #else\n-#define FP_DECL_EX int _fex = 0\n+# define FP_DECL_EX int _fex = 0\n #endif\n \n+/* Initialize any machine-specific state used in FP_ROUNDMODE,\n+   FP_TRAPPING_EXCEPTIONS or FP_HANDLE_EXCEPTIONS.  */\n #ifndef FP_INIT_ROUNDMODE\n-#define FP_INIT_ROUNDMODE do {} while (0)\n+# define FP_INIT_ROUNDMODE do {} while (0)\n+#endif\n+\n+/* Initialize any machine-specific state used in\n+   FP_HANDLE_EXCEPTIONS.  */\n+#ifndef FP_INIT_EXCEPTIONS\n+# define FP_INIT_EXCEPTIONS FP_INIT_ROUNDMODE\n #endif\n \n #ifndef FP_HANDLE_EXCEPTIONS\n-#define FP_HANDLE_EXCEPTIONS do {} while (0)\n+# define FP_HANDLE_EXCEPTIONS do {} while (0)\n #endif\n \n #ifndef FP_INHIBIT_RESULTS\n@@ -115,74 +123,103 @@\n  * check if some exceptions are unmasked\n  * and inhibit it in such a case.\n  */\n-#define FP_INHIBIT_RESULTS 0\n+# define FP_INHIBIT_RESULTS 0\n #endif\n \n #define FP_SET_EXCEPTION(ex)\t\t\t\t\\\n   _fex |= (ex)\n \n-#define FP_UNSET_EXCEPTION(ex)\t\t\t\t\\\n-  _fex &= ~(ex)\n-\n #define FP_CLEAR_EXCEPTIONS\t\t\t\t\\\n   _fex = 0\n \n #define FP_CUR_EXCEPTIONS\t\t\t\t\\\n   (_fex)\n \n #ifndef FP_TRAPPING_EXCEPTIONS\n-#define FP_TRAPPING_EXCEPTIONS 0\n+# define FP_TRAPPING_EXCEPTIONS 0\n #endif\n \n-#define _FP_ROUND_NEAREST(wc, X)\t\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-    if ((_FP_FRAC_LOW_##wc(X) & 15) != _FP_WORK_ROUND)\t\\\n-      _FP_FRAC_ADDI_##wc(X, _FP_WORK_ROUND);\t\t\\\n-} while (0)\n+/* A file using soft-fp may define FP_NO_EXCEPTIONS before including\n+   soft-fp.h to indicate that, although a macro used there could raise\n+   exceptions, or do rounding and potentially thereby raise\n+   exceptions, for some arguments, for the particular arguments used\n+   in that file no exceptions or rounding can occur.  Such a file\n+   should not itself use macros relating to handling exceptions and\n+   rounding modes; this is only for indirect uses (in particular, in\n+   _FP_FROM_INT and the macros it calls).  */\n+#ifdef FP_NO_EXCEPTIONS\n \n-#define _FP_ROUND_ZERO(wc, X)\t\t(void)0\n+# undef FP_SET_EXCEPTION\n+# define FP_SET_EXCEPTION(ex) do {} while (0)\n \n-#define _FP_ROUND_PINF(wc, X)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-    if (!X##_s && (_FP_FRAC_LOW_##wc(X) & 7))\t\t\\\n-      _FP_FRAC_ADDI_##wc(X, _FP_WORK_LSB);\t\t\\\n-} while (0)\n+# undef FP_CUR_EXCEPTIONS\n+# define FP_CUR_EXCEPTIONS 0\n \n-#define _FP_ROUND_MINF(wc, X)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-    if (X##_s && (_FP_FRAC_LOW_##wc(X) & 7))\t\t\\\n-      _FP_FRAC_ADDI_##wc(X, _FP_WORK_LSB);\t\t\\\n-} while (0)\n+# undef FP_TRAPPING_EXCEPTIONS\n+# define FP_TRAPPING_EXCEPTIONS 0\n+\n+# undef FP_ROUNDMODE\n+# define FP_ROUNDMODE FP_RND_ZERO\n+\n+#endif\n+\n+#define _FP_ROUND_NEAREST(wc, X)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((_FP_FRAC_LOW_##wc (X) & 15) != _FP_WORK_ROUND)\t\\\n+\t_FP_FRAC_ADDI_##wc (X, _FP_WORK_ROUND);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_ROUND_ZERO(wc, X)\t\t(void) 0\n+\n+#define _FP_ROUND_PINF(wc, X)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (!X##_s && (_FP_FRAC_LOW_##wc (X) & 7))\t\\\n+\t_FP_FRAC_ADDI_##wc (X, _FP_WORK_LSB);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define _FP_ROUND_MINF(wc, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (X##_s && (_FP_FRAC_LOW_##wc (X) & 7))\t\\\n+\t_FP_FRAC_ADDI_##wc (X, _FP_WORK_LSB);\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n #define _FP_ROUND(wc, X)\t\t\t\\\n-do {\t\t\t\t\t\t\\\n-\tif (_FP_FRAC_LOW_##wc(X) & 7)\t\t\\\n-\t  {\t\t\t\t\t\\\n-\t    FP_SET_EXCEPTION(FP_EX_INEXACT);\t\\\n-\t    switch (FP_ROUNDMODE)\t\t\\\n-\t      {\t\t\t\t\t\\\n-\t      case FP_RND_NEAREST:\t\t\\\n-\t\t_FP_ROUND_NEAREST(wc,X);\t\\\n-\t\tbreak;\t\t\t\t\\\n-\t      case FP_RND_ZERO:\t\t\t\\\n-\t\t_FP_ROUND_ZERO(wc,X);\t\t\\\n-\t\tbreak;\t\t\t\t\\\n-\t      case FP_RND_PINF:\t\t\t\\\n-\t\t_FP_ROUND_PINF(wc,X);\t\t\\\n-\t\tbreak;\t\t\t\t\\\n-\t      case FP_RND_MINF:\t\t\t\\\n-\t\t_FP_ROUND_MINF(wc,X);\t\t\\\n-\t\tbreak;\t\t\t\t\\\n-\t      }\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\\\n-} while (0)\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (_FP_FRAC_LOW_##wc (X) & 7)\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  FP_SET_EXCEPTION (FP_EX_INEXACT);\t\\\n+\t  switch (FP_ROUNDMODE)\t\t\t\\\n+\t    {\t\t\t\t\t\\\n+\t    case FP_RND_NEAREST:\t\t\\\n+\t      _FP_ROUND_NEAREST (wc, X);\t\\\n+\t      break;\t\t\t\t\\\n+\t    case FP_RND_ZERO:\t\t\t\\\n+\t      _FP_ROUND_ZERO (wc, X);\t\t\\\n+\t      break;\t\t\t\t\\\n+\t    case FP_RND_PINF:\t\t\t\\\n+\t      _FP_ROUND_PINF (wc, X);\t\t\\\n+\t      break;\t\t\t\t\\\n+\t    case FP_RND_MINF:\t\t\t\\\n+\t      _FP_ROUND_MINF (wc, X);\t\t\\\n+\t      break;\t\t\t\t\\\n+\t    }\t\t\t\t\t\\\n+\t}\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n #define FP_CLS_NORMAL\t\t0\n #define FP_CLS_ZERO\t\t1\n #define FP_CLS_INF\t\t2\n #define FP_CLS_NAN\t\t3\n \n-#define _FP_CLS_COMBINE(x,y)\t(((x) << 2) | (y))\n+#define _FP_CLS_COMBINE(x, y)\t(((x) << 2) | (y))\n \n #include \"op-1.h\"\n #include \"op-2.h\"\n@@ -194,35 +231,35 @@ do {\t\t\t\t\t\t\\\n #define UWtype\t\t_FP_W_TYPE\n #define W_TYPE_SIZE\t_FP_W_TYPE_SIZE\n \n-typedef int QItype __attribute__((mode(QI)));\n-typedef int SItype __attribute__((mode(SI)));\n-typedef int DItype __attribute__((mode(DI)));\n-typedef unsigned int UQItype __attribute__((mode(QI)));\n-typedef unsigned int USItype __attribute__((mode(SI)));\n-typedef unsigned int UDItype __attribute__((mode(DI)));\n+typedef int QItype __attribute__ ((mode (QI)));\n+typedef int SItype __attribute__ ((mode (SI)));\n+typedef int DItype __attribute__ ((mode (DI)));\n+typedef unsigned int UQItype __attribute__ ((mode (QI)));\n+typedef unsigned int USItype __attribute__ ((mode (SI)));\n+typedef unsigned int UDItype __attribute__ ((mode (DI)));\n #if _FP_W_TYPE_SIZE == 32\n-typedef unsigned int UHWtype __attribute__((mode(HI)));\n+typedef unsigned int UHWtype __attribute__ ((mode (HI)));\n #elif _FP_W_TYPE_SIZE == 64\n typedef USItype UHWtype;\n #endif\n \n #ifndef CMPtype\n-#define CMPtype\t\tint\n+# define CMPtype\tint\n #endif\n \n-#define SI_BITS\t\t(__CHAR_BIT__ * (int)sizeof(SItype))\n-#define DI_BITS\t\t(__CHAR_BIT__ * (int)sizeof(DItype))\n+#define SI_BITS\t\t(__CHAR_BIT__ * (int) sizeof (SItype))\n+#define DI_BITS\t\t(__CHAR_BIT__ * (int) sizeof (DItype))\n \n #ifndef umul_ppmm\n-#ifdef _LIBC\n-#include <stdlib/longlong.h>\n-#else\n-#include \"longlong.h\"\n-#endif\n+# ifdef _LIBC\n+#  include <stdlib/longlong.h>\n+# else\n+#  include \"longlong.h\"\n+# endif\n #endif\n \n #ifdef _LIBC\n-#include <stdlib.h>\n+# include <stdlib.h>\n #else\n extern void abort (void);\n #endif"}, {"sha": "6846e98dbd66f5eee639a33f946b5d6384220005", "filename": "libgcc/soft-fp/subdf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fsubdf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fsubdf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fsubdf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-DFtype __subdf3(DFtype a, DFtype b)\n+DFtype\n+__subdf3 (DFtype a, DFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A); FP_DECL_D(B); FP_DECL_D(R);\n+  FP_DECL_D (A);\n+  FP_DECL_D (B);\n+  FP_DECL_D (R);\n   DFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_SEMIRAW_D(A, a);\n-  FP_UNPACK_SEMIRAW_D(B, b);\n-  FP_SUB_D(R, A, B);\n-  FP_PACK_SEMIRAW_D(r, R);\n+  FP_UNPACK_SEMIRAW_D (A, a);\n+  FP_UNPACK_SEMIRAW_D (B, b);\n+  FP_SUB_D (R, A, B);\n+  FP_PACK_SEMIRAW_D (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "d46ddf58ae6a9806436438a1464d702f0b000be1", "filename": "libgcc/soft-fp/subsf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fsubsf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fsubsf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fsubsf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-SFtype __subsf3(SFtype a, SFtype b)\n+SFtype\n+__subsf3 (SFtype a, SFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_S(A); FP_DECL_S(B); FP_DECL_S(R);\n+  FP_DECL_S (A);\n+  FP_DECL_S (B);\n+  FP_DECL_S (R);\n   SFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_SEMIRAW_S(A, a);\n-  FP_UNPACK_SEMIRAW_S(B, b);\n-  FP_SUB_S(R, A, B);\n-  FP_PACK_SEMIRAW_S(r, R);\n+  FP_UNPACK_SEMIRAW_S (A, a);\n+  FP_UNPACK_SEMIRAW_S (B, b);\n+  FP_SUB_S (R, A, B);\n+  FP_PACK_SEMIRAW_S (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "88c6edeb6120cd54da06bd02c6d464b9ed095ec6", "filename": "libgcc/soft-fp/subtf3.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fsubtf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Fsubtf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fsubtf3.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -31,17 +31,20 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-TFtype __subtf3(TFtype a, TFtype b)\n+TFtype\n+__subtf3 (TFtype a, TFtype b)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(R);\n+  FP_DECL_Q (A);\n+  FP_DECL_Q (B);\n+  FP_DECL_Q (R);\n   TFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_SEMIRAW_Q(A, a);\n-  FP_UNPACK_SEMIRAW_Q(B, b);\n-  FP_SUB_Q(R, A, B);\n-  FP_PACK_SEMIRAW_Q(r, R);\n+  FP_UNPACK_SEMIRAW_Q (A, a);\n+  FP_UNPACK_SEMIRAW_Q (B, b);\n+  FP_SUB_Q (R, A, B);\n+  FP_PACK_SEMIRAW_Q (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "3ec56fdf8adb0830f0cebf267bfe2290a62076de", "filename": "libgcc/soft-fp/truncdfsf2.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ftruncdfsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ftruncdfsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ftruncdfsf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -32,21 +32,22 @@\n #include \"single.h\"\n #include \"double.h\"\n \n-SFtype __truncdfsf2(DFtype a)\n+SFtype\n+__truncdfsf2 (DFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_D(A);\n-  FP_DECL_S(R);\n+  FP_DECL_D (A);\n+  FP_DECL_S (R);\n   SFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_SEMIRAW_D(A, a);\n+  FP_UNPACK_SEMIRAW_D (A, a);\n #if _FP_W_TYPE_SIZE < _FP_FRACBITS_D\n-  FP_TRUNC(S,D,1,2,R,A);\n+  FP_TRUNC (S, D, 1, 2, R, A);\n #else\n-  FP_TRUNC(S,D,1,1,R,A);\n+  FP_TRUNC (S, D, 1, 1, R, A);\n #endif\n-  FP_PACK_SEMIRAW_S(r, R);\n+  FP_PACK_SEMIRAW_S (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "e970210129106f24471d6d70ffa170880e3a4864", "filename": "libgcc/soft-fp/trunctfdf2.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ftrunctfdf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ftrunctfdf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ftrunctfdf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -32,21 +32,22 @@\n #include \"double.h\"\n #include \"quad.h\"\n \n-DFtype __trunctfdf2(TFtype a)\n+DFtype\n+__trunctfdf2 (TFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A);\n-  FP_DECL_D(R);\n+  FP_DECL_Q (A);\n+  FP_DECL_D (R);\n   DFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_SEMIRAW_Q(A, a);\n+  FP_UNPACK_SEMIRAW_Q (A, a);\n #if (2 * _FP_W_TYPE_SIZE) < _FP_FRACBITS_Q\n-  FP_TRUNC(D,Q,2,4,R,A);\n+  FP_TRUNC (D, Q, 2, 4, R, A);\n #else\n-  FP_TRUNC(D,Q,1,2,R,A);\n+  FP_TRUNC (D, Q, 1, 2, R, A);\n #endif\n-  FP_PACK_SEMIRAW_D(r, R);\n+  FP_PACK_SEMIRAW_D (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "d8a3728a0da511cd8317532d7679c4a56080f2b1", "filename": "libgcc/soft-fp/trunctfsf2.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ftrunctfsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ftrunctfsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ftrunctfsf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -32,21 +32,22 @@\n #include \"single.h\"\n #include \"quad.h\"\n \n-SFtype __trunctfsf2(TFtype a)\n+SFtype\n+__trunctfsf2 (TFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A);\n-  FP_DECL_S(R);\n+  FP_DECL_Q (A);\n+  FP_DECL_S (R);\n   SFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_SEMIRAW_Q(A, a);\n+  FP_UNPACK_SEMIRAW_Q (A, a);\n #if (2 * _FP_W_TYPE_SIZE) < _FP_FRACBITS_Q\n-  FP_TRUNC(S,Q,1,4,R,A);\n+  FP_TRUNC (S, Q, 1, 4, R, A);\n #else\n-  FP_TRUNC(S,Q,1,2,R,A);\n+  FP_TRUNC (S, Q, 1, 2, R, A);\n #endif\n-  FP_PACK_SEMIRAW_S(r, R);\n+  FP_PACK_SEMIRAW_S (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "750bec1808e7c214de7cf9f47e76fb6ef630e57f", "filename": "libgcc/soft-fp/trunctfxf2.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ftrunctfxf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Ftrunctfxf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ftrunctfxf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -1,6 +1,6 @@\n /* Software floating-point emulation.\n    Truncate IEEE quad into IEEE extended\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2013 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Uros Bizjak (ubizjak@gmail.com).\n \n@@ -24,29 +24,29 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"soft-fp.h\"\n #include \"extended.h\"\n #include \"quad.h\"\n \n-XFtype __trunctfxf2(TFtype a)\n+XFtype\n+__trunctfxf2 (TFtype a)\n {\n   FP_DECL_EX;\n-  FP_DECL_Q(A);\n-  FP_DECL_E(R);\n+  FP_DECL_Q (A);\n+  FP_DECL_E (R);\n   XFtype r;\n \n   FP_INIT_ROUNDMODE;\n-  FP_UNPACK_SEMIRAW_Q(A, a);\n+  FP_UNPACK_SEMIRAW_Q (A, a);\n #if (2 * _FP_W_TYPE_SIZE) < _FP_FRACBITS_Q\n-  FP_TRUNC(E,Q,4,4,R,A);\n+  FP_TRUNC (E, Q, 4, 4, R, A);\n #else\n-  FP_TRUNC(E,Q,2,2,R,A);\n+  FP_TRUNC (E, Q, 2, 2, R, A);\n #endif\n-  FP_PACK_SEMIRAW_E(r, R);\n+  FP_PACK_SEMIRAW_E (r, R);\n   FP_HANDLE_EXCEPTIONS;\n \n   return r;"}, {"sha": "641c86972512d8f0d526dba002bfeffc072c12e0", "filename": "libgcc/soft-fp/unorddf2.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Funorddf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Funorddf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Funorddf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -30,14 +30,21 @@\n #include \"soft-fp.h\"\n #include \"double.h\"\n \n-CMPtype __unorddf2(DFtype a, DFtype b)\n+CMPtype\n+__unorddf2 (DFtype a, DFtype b)\n {\n-  FP_DECL_D(A); FP_DECL_D(B);\n+  FP_DECL_EX;\n+  FP_DECL_D (A);\n+  FP_DECL_D (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_D(A, a);\n-  FP_UNPACK_RAW_D(B, b);\n-  FP_CMP_UNORD_D(r, A, B);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_D (A, a);\n+  FP_UNPACK_RAW_D (B, b);\n+  FP_CMP_UNORD_D (r, A, B);\n+  if (r && (FP_ISSIGNAN_D (A) || FP_ISSIGNAN_D (B)))\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }"}, {"sha": "f271421283f748f45c67cae65b3564129b36f5e1", "filename": "libgcc/soft-fp/unordsf2.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Funordsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Funordsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Funordsf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -30,15 +30,21 @@\n #include \"soft-fp.h\"\n #include \"single.h\"\n \n-CMPtype __unordsf2(SFtype a, SFtype b)\n+CMPtype\n+__unordsf2 (SFtype a, SFtype b)\n {\n-  FP_DECL_S(A);\n-  FP_DECL_S(B);\n+  FP_DECL_EX;\n+  FP_DECL_S (A);\n+  FP_DECL_S (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_S(A, a);\n-  FP_UNPACK_RAW_S(B, b);\n-  FP_CMP_UNORD_S(r, A, B);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_S (A, a);\n+  FP_UNPACK_RAW_S (B, b);\n+  FP_CMP_UNORD_S (r, A, B);\n+  if (r && (FP_ISSIGNAN_S (A) || FP_ISSIGNAN_S (B)))\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }"}, {"sha": "38cc1a78b26dbe13fa038f45759e49b9518f1531", "filename": "libgcc/soft-fp/unordtf2.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Funordtf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/libgcc%2Fsoft-fp%2Funordtf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Funordtf2.c?ref=9954c743b9e985bd30194525464a0a8a64697b68", "patch": "@@ -30,15 +30,21 @@\n #include \"soft-fp.h\"\n #include \"quad.h\"\n \n-CMPtype __unordtf2(TFtype a, TFtype b)\n+CMPtype\n+__unordtf2 (TFtype a, TFtype b)\n {\n-  FP_DECL_Q(A);\n-  FP_DECL_Q(B);\n+  FP_DECL_EX;\n+  FP_DECL_Q (A);\n+  FP_DECL_Q (B);\n   CMPtype r;\n \n-  FP_UNPACK_RAW_Q(A, a);\n-  FP_UNPACK_RAW_Q(B, b);\n-  FP_CMP_UNORD_Q(r, A, B);\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_UNPACK_RAW_Q (B, b);\n+  FP_CMP_UNORD_Q (r, A, B);\n+  if (r && (FP_ISSIGNAN_Q (A) || FP_ISSIGNAN_Q (B)))\n+    FP_SET_EXCEPTION (FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n \n   return r;\n }"}]}