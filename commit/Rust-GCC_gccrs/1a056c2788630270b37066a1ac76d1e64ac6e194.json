{"sha": "1a056c2788630270b37066a1ac76d1e64ac6e194", "node_id": "C_kwDOANBUbNoAKDFhMDU2YzI3ODg2MzAyNzBiMzcwNjZhMWFjNzZkMWU2NGFjNmUxOTQ", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2021-11-29T16:52:56Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-05T11:32:34Z"}, "message": "[Ada] Rename parameter-dependent constants in generic unit\n\ngcc/ada/\n\n\t* libgnat/s-aridou.adb: Apply replacement.", "tree": {"sha": "0c84e1277c9a656b17727beef7b2d0bf799e8848", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c84e1277c9a656b17727beef7b2d0bf799e8848"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a056c2788630270b37066a1ac76d1e64ac6e194", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a056c2788630270b37066a1ac76d1e64ac6e194", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a056c2788630270b37066a1ac76d1e64ac6e194", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a056c2788630270b37066a1ac76d1e64ac6e194/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50d8b1066a46cc134c1accc270c9be1b1cae8bc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d8b1066a46cc134c1accc270c9be1b1cae8bc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50d8b1066a46cc134c1accc270c9be1b1cae8bc2"}], "stats": {"total": 365, "additions": 194, "deletions": 171}, "files": [{"sha": "c93636a309fe2a61af8a5583816b74f2a0d0b59c", "filename": "gcc/ada/libgnat/s-aridou.adb", "status": "modified", "additions": 194, "deletions": 171, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a056c2788630270b37066a1ac76d1e64ac6e194/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a056c2788630270b37066a1ac76d1e64ac6e194/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.adb?ref=1a056c2788630270b37066a1ac76d1e64ac6e194", "patch": "@@ -64,10 +64,7 @@ is\n         when others => raise Program_Error)\n    with Ghost;\n \n-   --  Power-of-two constants. Use the names Big_2xx32, Big_2xx63 and Big_2xx64\n-   --  even if Single_Size might not be 32 and Double_Size might not be 64, as\n-   --  this facilitates code and proof understanding, compared to more generic\n-   --  names.\n+   --  Power-of-two constants\n \n    pragma Warnings\n      (Off, \"non-preelaborable call not allowed in preelaborated unit\",\n@@ -78,13 +75,13 @@ is\n    Big_0 : constant Big_Integer :=\n      Big (Double_Uns'(0))\n    with Ghost;\n-   Big_2xx32 : constant Big_Integer :=\n+   Big_2xxSingle : constant Big_Integer :=\n      Big (Double_Int'(2 ** Single_Size))\n    with Ghost;\n-   Big_2xx63 : constant Big_Integer :=\n+   Big_2xxDouble_Minus_1 : constant Big_Integer :=\n      Big (Double_Uns'(2 ** (Double_Size - 1)))\n    with Ghost;\n-   Big_2xx64 : constant Big_Integer :=\n+   Big_2xxDouble : constant Big_Integer :=\n      Big (Double_Uns'(2 ** Double_Size - 1)) + 1\n    with Ghost;\n    pragma Warnings\n@@ -137,8 +134,9 @@ is\n    --  2**N as a big integer\n \n    function Big3 (X1, X2, X3 : Single_Uns) return Big_Integer is\n-     (Big_2xx32 * Big_2xx32 * Big (Double_Uns (X1))\n-                + Big_2xx32 * Big (Double_Uns (X2)) + Big (Double_Uns (X3)))\n+     (Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (X1))\n+                    + Big_2xxSingle * Big (Double_Uns (X2))\n+                                    + Big (Double_Uns (X3)))\n    with Ghost;\n    --  X1&X2&X3 as a big integer\n \n@@ -353,8 +351,8 @@ is\n    with\n      Ghost,\n      Pre  => Xhi = Hi (Xu) and Xlo = Lo (Xu),\n-     Post =>\n-       Big (Xu) = Big_2xx32 * Big (Double_Uns (Xhi)) + Big (Double_Uns (Xlo));\n+     Post => Big (Xu) =\n+       Big_2xxSingle * Big (Double_Uns (Xhi)) + Big (Double_Uns (Xlo));\n \n    procedure Lemma_Hi_Lo_3 (Xu : Double_Uns; Xhi, Xlo : Single_Uns)\n    with\n@@ -365,7 +363,7 @@ is\n    procedure Lemma_Lo_Is_Ident (X : Double_Uns)\n    with\n      Ghost,\n-     Pre  => Big (X) < Big_2xx32,\n+     Pre  => Big (X) < Big_2xxSingle,\n      Post => Double_Uns (Lo (X)) = X;\n \n    procedure Lemma_Lt_Commutation (A, B : Double_Uns)\n@@ -396,7 +394,7 @@ is\n    procedure Lemma_Mult_Commutation (X, Y, Z : Double_Uns)\n    with\n      Ghost,\n-     Pre  => Big (X) * Big (Y) < Big_2xx64 and then Z = X * Y,\n+     Pre  => Big (X) * Big (Y) < Big_2xxDouble and then Z = X * Y,\n      Post => Big (X) * Big (Y) = Big (Z);\n \n    procedure Lemma_Mult_Decomposition\n@@ -411,9 +409,9 @@ is\n        and then Yhi = Hi (Yu)\n        and then Ylo = Lo (Yu),\n      Post => Mult =\n-               Big_2xx32 * Big_2xx32 * (Big (Double_Uns'(Xhi * Yhi)))\n-                         + Big_2xx32 * (Big (Double_Uns'(Xhi * Ylo)))\n-                         + Big_2xx32 * (Big (Double_Uns'(Xlo * Yhi)))\n+       Big_2xxSingle * Big_2xxSingle * (Big (Double_Uns'(Xhi * Yhi)))\n+                     + Big_2xxSingle * (Big (Double_Uns'(Xhi * Ylo)))\n+                     + Big_2xxSingle * (Big (Double_Uns'(Xlo * Yhi)))\n                                      + (Big (Double_Uns'(Xlo * Ylo)));\n \n    procedure Lemma_Mult_Distribution (X, Y, Z : Big_Integer)\n@@ -435,8 +433,8 @@ is\n \n    procedure Lemma_Not_In_Range_Big2xx64\n    with\n-     Post => not In_Double_Int_Range (Big_2xx64)\n-       and then not In_Double_Int_Range (-Big_2xx64);\n+     Post => not In_Double_Int_Range (Big_2xxDouble)\n+       and then not In_Double_Int_Range (-Big_2xxDouble);\n \n    procedure Lemma_Powers_Of_2 (M, N : Natural)\n    with\n@@ -446,15 +444,15 @@ is\n        and then M + N <= Double_Size,\n      Post =>\n        Big_2xx (M) * Big_2xx (N) =\n-         (if M + N = Double_Size then Big_2xx64 else Big_2xx (M + N));\n+         (if M + N = Double_Size then Big_2xxDouble else Big_2xx (M + N));\n \n    procedure Lemma_Powers_Of_2_Commutation (M : Natural)\n    with\n      Ghost,\n      Subprogram_Variant => (Decreases => M),\n      Pre  => M <= Double_Size,\n      Post => Big (Double_Uns'(2))**M =\n-              (if M < Double_Size then Big_2xx (M) else Big_2xx64);\n+              (if M < Double_Size then Big_2xx (M) else Big_2xxDouble);\n \n    procedure Lemma_Powers_Of_2_Increasing (M, N : Natural)\n    with\n@@ -541,7 +539,7 @@ is\n    procedure Lemma_Word_Commutation (X : Single_Uns)\n    with\n      Ghost,\n-     Post => Big_2xx32 * Big (Double_Uns (X))\n+     Post => Big_2xxSingle * Big (Double_Uns (X))\n        = Big (2**Single_Size * Double_Uns (X));\n \n    -----------------------------\n@@ -772,9 +770,11 @@ is\n       procedure Prove_Quotient_Zero\n       with\n         Ghost,\n-        Pre  => Mult >= Big_2xx64\n+        Pre  => Mult >= Big_2xxDouble\n           and then\n-            not (Mult = Big_2xx64 and then X = Double_Int'First and then Round)\n+            not (Mult = Big_2xxDouble\n+                   and then X = Double_Int'First\n+                   and then Round)\n           and then Q = 0\n           and then R = X,\n         Post => Big (R) = Big (X) rem (Big (Y) * Big (Z))\n@@ -790,7 +790,7 @@ is\n       procedure Prove_Round_To_One\n       with\n         Ghost,\n-        Pre  => Mult = Big_2xx64\n+        Pre  => Mult = Big_2xxDouble\n           and then X = Double_Int'First\n           and then Q = (if Den_Pos then -1 else 1)\n           and then R = X\n@@ -944,28 +944,32 @@ is\n \n       pragma Assert (Big (T2) = Big (Double_Uns'(Yhi * Zlo))\n                               + Big (Double_Uns'(Ylo * Zhi)));\n-      Lemma_Mult_Distribution (Big_2xx32, Big (Double_Uns'(Yhi * Zlo)),\n-                                          Big (Double_Uns'(Ylo * Zhi)));\n-      pragma Assert (Mult = Big_2xx32 * Big (T2) + Big (T1));\n+      Lemma_Mult_Distribution (Big_2xxSingle,\n+                               Big (Double_Uns'(Yhi * Zlo)),\n+                               Big (Double_Uns'(Ylo * Zhi)));\n+      pragma Assert (Mult = Big_2xxSingle * Big (T2) + Big (T1));\n       Lemma_Hi_Lo (T1, Hi (T1), Lo (T1));\n       pragma Assert\n-        (Mult = Big_2xx32 * Big (T2)\n-              + Big_2xx32 * Big (Double_Uns (Hi (T1)))\n-                          + Big (Double_Uns (Lo (T1))));\n-      Lemma_Mult_Distribution (Big_2xx32, Big (T2),\n-                                          Big (Double_Uns (Hi (T1))));\n+        (Mult = Big_2xxSingle * Big (T2)\n+              + Big_2xxSingle * Big (Double_Uns (Hi (T1)))\n+                              + Big (Double_Uns (Lo (T1))));\n+      Lemma_Mult_Distribution (Big_2xxSingle,\n+                               Big (T2),\n+                               Big (Double_Uns (Hi (T1))));\n       Lemma_Add_Commutation (T2, Hi (T1));\n \n       T2 := T2 + Hi (T1);\n \n-      pragma Assert (Mult = Big_2xx32 * Big (T2) + Big (Double_Uns (Lo (T1))));\n+      pragma Assert\n+        (Mult = Big_2xxSingle * Big (T2) + Big (Double_Uns (Lo (T1))));\n       Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n-      Lemma_Mult_Distribution (Big_2xx32, Big (Double_Uns (Hi (T2))),\n-                                          Big (Double_Uns (Lo (T2))));\n+      Lemma_Mult_Distribution (Big_2xxSingle,\n+                               Big (Double_Uns (Hi (T2))),\n+                               Big (Double_Uns (Lo (T2))));\n       pragma Assert\n-        (Mult = Big_2xx64 * Big (Double_Uns (Hi (T2)))\n-              + Big_2xx32 * Big (Double_Uns (Lo (T2)))\n-                          + Big (Double_Uns (Lo (T1))));\n+        (Mult = Big_2xxDouble * Big (Double_Uns (Hi (T2)))\n+              + Big_2xxSingle * Big (Double_Uns (Lo (T2)))\n+                              + Big (Double_Uns (Lo (T1))));\n \n       if Hi (T2) /= 0 then\n          R := X;\n@@ -988,7 +992,7 @@ is\n             pragma Assert (Big (Double_Uns (Hi (T2))) >= 1);\n             pragma Assert (Big (Double_Uns (Lo (T2))) >= 0);\n             pragma Assert (Big (Double_Uns (Lo (T1))) >= 0);\n-            pragma Assert (Mult >= Big_2xx64);\n+            pragma Assert (Mult >= Big_2xxDouble);\n             if Hi (T2) > 1 then\n                pragma Assert (Big (Double_Uns (Hi (T2))) > 1);\n             elsif Lo (T2) > 0 then\n@@ -1195,22 +1199,24 @@ is\n       Lemma_Hi_Lo (Yu, Yhi, Ylo);\n \n       pragma Assert\n-        (Mult = (Big_2xx32 * Big (Double_Uns (Xhi)) + Big (Double_Uns (Xlo))) *\n-                (Big_2xx32 * Big (Double_Uns (Yhi)) + Big (Double_Uns (Ylo))));\n+        (Mult =\n+           (Big_2xxSingle * Big (Double_Uns (Xhi)) + Big (Double_Uns (Xlo))) *\n+           (Big_2xxSingle * Big (Double_Uns (Yhi)) + Big (Double_Uns (Ylo))));\n       pragma Assert (Mult =\n-        Big_2xx32 * Big_2xx32 * Big (Double_Uns (Xhi)) * Big (Double_Uns (Yhi))\n-                  + Big_2xx32 * Big (Double_Uns (Xhi)) * Big (Double_Uns (Ylo))\n-                  + Big_2xx32 * Big (Double_Uns (Xlo)) * Big (Double_Uns (Yhi))\n-                            + Big (Double_Uns (Xlo)) * Big (Double_Uns (Ylo)));\n-      Lemma_Deep_Mult_Commutation (Big_2xx32 * Big_2xx32, Xhi, Yhi);\n-      Lemma_Deep_Mult_Commutation (Big_2xx32, Xhi, Ylo);\n-      Lemma_Deep_Mult_Commutation (Big_2xx32, Xlo, Yhi);\n+        Big_2xxSingle\n+          * Big_2xxSingle * Big (Double_Uns (Xhi)) * Big (Double_Uns (Yhi))\n+          + Big_2xxSingle * Big (Double_Uns (Xhi)) * Big (Double_Uns (Ylo))\n+          + Big_2xxSingle * Big (Double_Uns (Xlo)) * Big (Double_Uns (Yhi))\n+                          + Big (Double_Uns (Xlo)) * Big (Double_Uns (Ylo)));\n+      Lemma_Deep_Mult_Commutation (Big_2xxSingle * Big_2xxSingle, Xhi, Yhi);\n+      Lemma_Deep_Mult_Commutation (Big_2xxSingle, Xhi, Ylo);\n+      Lemma_Deep_Mult_Commutation (Big_2xxSingle, Xlo, Yhi);\n       Lemma_Mult_Commutation (Xlo, Ylo);\n       pragma Assert (Mult =\n-                       Big_2xx32 * Big_2xx32 * Big (Double_Uns'(Xhi * Yhi))\n-                                 + Big_2xx32 * Big (Double_Uns'(Xhi * Ylo))\n-                                 + Big_2xx32 * Big (Double_Uns'(Xlo * Yhi))\n-                                             + Big (Double_Uns'(Xlo * Ylo)));\n+        Big_2xxSingle * Big_2xxSingle * Big (Double_Uns'(Xhi * Yhi))\n+                      + Big_2xxSingle * Big (Double_Uns'(Xhi * Ylo))\n+                      + Big_2xxSingle * Big (Double_Uns'(Xlo * Yhi))\n+                                      + Big (Double_Uns'(Xlo * Ylo)));\n    end Lemma_Mult_Decomposition;\n \n    -------------------\n@@ -1383,17 +1389,17 @@ is\n         Pre  => Xhi /= 0\n           and then Yhi /= 0\n           and then Mult =\n-            Big_2xx32 * Big_2xx32 * (Big (Double_Uns'(Xhi * Yhi)))\n-                      + Big_2xx32 * (Big (Double_Uns'(Xhi * Ylo)))\n-                      + Big_2xx32 * (Big (Double_Uns'(Xlo * Yhi)))\n+            Big_2xxSingle * Big_2xxSingle * (Big (Double_Uns'(Xhi * Yhi)))\n+                      + Big_2xxSingle * (Big (Double_Uns'(Xhi * Ylo)))\n+                      + Big_2xxSingle * (Big (Double_Uns'(Xlo * Yhi)))\n                                   + (Big (Double_Uns'(Xlo * Ylo))),\n         Post => not In_Double_Int_Range (Big (X) * Big (Y));\n \n       procedure Prove_Final_Decomposition\n       with\n         Ghost,\n         Pre  => In_Double_Int_Range (Big (X) * Big (Y))\n-          and then Mult = Big_2xx32 * Big (T2) + Big (Double_Uns (Lo (T1)))\n+          and then Mult = Big_2xxSingle * Big (T2) + Big (Double_Uns (Lo (T1)))\n           and then Hi (T2) = 0,\n         Post => Mult = Big (Lo (T2) & Lo (T1));\n \n@@ -1416,14 +1422,14 @@ is\n       procedure Prove_Result_Too_Large\n       with\n         Ghost,\n-        Pre  => Mult = Big_2xx32 * Big (T2) + Big (Double_Uns (Lo (T1)))\n+        Pre  => Mult = Big_2xxSingle * Big (T2) + Big (Double_Uns (Lo (T1)))\n           and then Hi (T2) /= 0,\n         Post => not In_Double_Int_Range (Big (X) * Big (Y));\n \n       procedure Prove_Too_Large\n       with\n         Ghost,\n-        Pre  => abs (Big (X) * Big (Y)) >= Big_2xx64,\n+        Pre  => abs (Big (X) * Big (Y)) >= Big_2xxDouble,\n         Post => not In_Double_Int_Range (Big (X) * Big (Y));\n \n       --------------------------\n@@ -1432,10 +1438,10 @@ is\n \n       procedure Prove_Both_Too_Large is\n       begin\n-         pragma Assert\n-           (Mult >= Big_2xx32 * Big_2xx32 * Big (Double_Uns'(Xhi * Yhi)));\n+         pragma Assert (Mult >=\n+           Big_2xxSingle * Big_2xxSingle * Big (Double_Uns'(Xhi * Yhi)));\n          pragma Assert (Double_Uns (Xhi) * Double_Uns (Yhi) >= 1);\n-         pragma Assert (Mult >= Big_2xx32 * Big_2xx32);\n+         pragma Assert (Mult >= Big_2xxSingle * Big_2xxSingle);\n          Prove_Too_Large;\n       end Prove_Both_Too_Large;\n \n@@ -1446,9 +1452,9 @@ is\n       procedure Prove_Final_Decomposition is\n       begin\n          Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n-         pragma Assert (Mult = Big_2xx32 * Big (Double_Uns (Lo (T2)))\n-                                         + Big (Double_Uns (Lo (T1))));\n-         pragma Assert (Mult <= Big_2xx63);\n+         pragma Assert (Mult = Big_2xxSingle * Big (Double_Uns (Lo (T2)))\n+                                             + Big (Double_Uns (Lo (T1))));\n+         pragma Assert (Mult <= Big_2xxDouble_Minus_1);\n          Lemma_Mult_Commutation (X, Y);\n          pragma Assert (Mult = abs (Big (X * Y)));\n          Lemma_Word_Commutation (Lo (T2));\n@@ -1490,12 +1496,12 @@ is\n \n       procedure Prove_Result_Too_Large is\n       begin\n-         pragma Assert (Mult >= Big_2xx32 * Big (T2));\n+         pragma Assert (Mult >= Big_2xxSingle * Big (T2));\n          Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n-         pragma Assert\n-           (Mult >= Big_2xx32 * Big_2xx32 * Big (Double_Uns (Hi (T2))));\n+         pragma Assert (Mult >=\n+           Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T2))));\n          pragma Assert (Double_Uns (Hi (T2)) >= 1);\n-         pragma Assert (Mult >= Big_2xx32 * Big_2xx32);\n+         pragma Assert (Mult >= Big_2xxSingle * Big_2xxSingle);\n          Prove_Too_Large;\n       end Prove_Result_Too_Large;\n \n@@ -1532,17 +1538,18 @@ is\n \n       pragma Assert (Big (T2) = Big (Double_Uns'(Xhi * Ylo))\n                               + Big (Double_Uns'(Xlo * Yhi)));\n-      Lemma_Mult_Distribution (Big_2xx32, Big (Double_Uns'(Xhi * Ylo)),\n+      Lemma_Mult_Distribution (Big_2xxSingle, Big (Double_Uns'(Xhi * Ylo)),\n                                           Big (Double_Uns'(Xlo * Yhi)));\n-      pragma Assert (Mult = Big_2xx32 * Big (T2) + Big (T1));\n+      pragma Assert (Mult = Big_2xxSingle * Big (T2) + Big (T1));\n       Lemma_Add_Commutation (T2, Hi (T1));\n       pragma Assert\n         (Big (T2 + Hi (T1)) = Big (T2) + Big (Double_Uns (Hi (T1))));\n \n       T2 := T2 + Hi (T1);\n \n       Lemma_Hi_Lo (T1, Hi (T1), Lo (T1));\n-      pragma Assert (Mult = Big_2xx32 * Big (T2) + Big (Double_Uns (Lo (T1))));\n+      pragma Assert\n+        (Mult = Big_2xxSingle * Big (T2) + Big (Double_Uns (Lo (T1))));\n \n       if Hi (T2) /= 0 then\n          Prove_Result_Too_Large;\n@@ -1656,19 +1663,21 @@ is\n         Pre  => D'Initialized\n           and then Scale <= Single_Size\n           and then Mult =\n-            Big_2xx32 * Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (1)))\n-                      + Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (2)))\n-                                  + Big_2xx32 * Big (Double_Uns (D (3)))\n+            Big_2xxSingle\n+              * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+              + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                              + Big_2xxSingle * Big (Double_Uns (D (3)))\n                                               + Big (Double_Uns (D (4)))\n-          and then Big (D (1) & D (2)) * Big_2xx (Scale) < Big_2xx64\n+          and then Big (D (1) & D (2)) * Big_2xx (Scale) < Big_2xxDouble\n           and then T1 = Shift_Left (D (1) & D (2), Scale)\n           and then T2 = Shift_Left (Double_Uns (D (3)), Scale)\n           and then T3 = Shift_Left (Double_Uns (D (4)), Scale),\n         Post => Mult * Big_2xx (Scale) =\n-          Big_2xx32 * Big_2xx32 * Big_2xx32 * Big (Double_Uns (Hi (T1)))\n-                    + Big_2xx32 * Big_2xx32 * Big (Double_Uns (Lo (T1) or\n+          Big_2xxSingle\n+            * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T1)))\n+            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Lo (T1) or\n                                                                       Hi (T2)))\n-                                + Big_2xx32 * Big (Double_Uns (Lo (T2) or\n+                            + Big_2xxSingle * Big (Double_Uns (Lo (T2) or\n                                                                       Hi (T3)))\n                                             + Big (Double_Uns (Lo (T3)));\n       --  Proves the scaling of the 4-digit dividend actually multiplies it by\n@@ -1712,7 +1721,8 @@ is\n       procedure Prove_Overflow\n       with\n         Ghost,\n-        Pre  => Z /= 0 and then Mult >= Big_2xx64 * Big (Double_Uns'(abs Z)),\n+        Pre  => Z /= 0\n+          and then Mult >= Big_2xxDouble * Big (Double_Uns'(abs Z)),\n         Post => not In_Double_Int_Range (Big (X) * Big (Y) / Big (Z))\n           and then not In_Double_Int_Range\n             (Round_Quotient (Big (X) * Big (Y), Big (Z),\n@@ -1762,7 +1772,7 @@ is\n       with\n         Ghost,\n         Pre  => In_Double_Int_Range (Big_Q)\n-          and then abs Big_Q = Big_2xx64,\n+          and then abs Big_Q = Big_2xxDouble,\n         Post => False;\n       --  Proves the inconsistency when Q is equal to Big_2xx64\n \n@@ -1833,9 +1843,10 @@ is\n           and then D'Initialized\n           and then Hi (abs Z) = 0\n           and then Lo (abs Z) = Zlo\n-          and then Mult = Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (2)))\n-                                    + Big_2xx32 * Big (Double_Uns (D (3)))\n-                                                + Big (Double_Uns (D (4)))\n+          and then Mult =\n+            Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                          + Big_2xxSingle * Big (Double_Uns (D (3)))\n+                                          + Big (Double_Uns (D (4)))\n           and then D (2) < Zlo\n           and then Quot = (Big (X) * Big (Y)) / Big (Z)\n           and then Big_R = (Big (X) * Big (Y)) rem Big (Z)\n@@ -1855,23 +1866,24 @@ is\n       begin\n          Lemma_Hi_Lo (D (1) & D (2), D (1), D (2));\n          pragma Assert (Mult * Big_2xx (Scale) =\n-           Big_2xx32 * Big_2xx32 * Big_2xx (Scale) * Big (D (1) & D (2))\n-                     + Big_2xx32 * Big_2xx (Scale) * Big (Double_Uns (D (3)))\n-                                 + Big_2xx (Scale) * Big (Double_Uns (D (4))));\n+           Big_2xxSingle\n+             * Big_2xxSingle * Big_2xx (Scale) * Big (D (1) & D (2))\n+             + Big_2xxSingle * Big_2xx (Scale) * Big (Double_Uns (D (3)))\n+                             + Big_2xx (Scale) * Big (Double_Uns (D (4))));\n          pragma Assert (Big_2xx (Scale) > 0);\n-         Lemma_Lt_Mult (Big (Double_Uns (D (3))), Big_2xx32,\n-                        Big_2xx (Scale), Big_2xx64);\n-         Lemma_Lt_Mult (Big (Double_Uns (D (4))), Big_2xx32,\n-                        Big_2xx (Scale), Big_2xx64);\n+         Lemma_Lt_Mult (Big (Double_Uns (D (3))), Big_2xxSingle,\n+                        Big_2xx (Scale), Big_2xxDouble);\n+         Lemma_Lt_Mult (Big (Double_Uns (D (4))), Big_2xxSingle,\n+                        Big_2xx (Scale), Big_2xxDouble);\n          Lemma_Mult_Commutation (2 ** Scale, D (1) & D (2), T1);\n          declare\n             Big_D12 : constant Big_Integer :=\n               Big_2xx (Scale) * Big (D (1) & D (2));\n             Big_T1  : constant Big_Integer := Big (T1);\n          begin\n             pragma Assert (Big_D12 = Big_T1);\n-            pragma Assert (Big_2xx32 * Big_2xx32 * Big_D12\n-                           = Big_2xx32 * Big_2xx32 * Big_T1);\n+            pragma Assert (Big_2xxSingle * Big_2xxSingle * Big_D12\n+                           = Big_2xxSingle * Big_2xxSingle * Big_T1);\n          end;\n          Lemma_Mult_Commutation (2 ** Scale, Double_Uns (D (3)), T2);\n          declare\n@@ -1880,7 +1892,7 @@ is\n             Big_T2 : constant Big_Integer := Big (T2);\n          begin\n             pragma Assert (Big_D3 = Big_T2);\n-            pragma Assert (Big_2xx32 * Big_D3 = Big_2xx32 * Big_T2);\n+            pragma Assert (Big_2xxSingle * Big_D3 = Big_2xxSingle * Big_T2);\n          end;\n          Lemma_Mult_Commutation (2 ** Scale, Double_Uns (D (4)), T3);\n          declare\n@@ -1891,7 +1903,9 @@ is\n             pragma Assert (Big_D4 = Big_T3);\n          end;\n          pragma Assert (Mult * Big_2xx (Scale) =\n-           Big_2xx32 * Big_2xx32 * Big (T1) + Big_2xx32 * Big (T2) + Big (T3));\n+           Big_2xxSingle * Big_2xxSingle * Big (T1)\n+                         + Big_2xxSingle * Big (T2)\n+                                         + Big (T3));\n          Lemma_Hi_Lo (T1, Hi (T1), Lo (T1));\n          Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n          Lemma_Hi_Lo (T3, Hi (T3), Lo (T3));\n@@ -1912,10 +1926,10 @@ is\n          Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n          Lemma_Hi_Lo (T3, Hi (T3), S2);\n          pragma Assert (Big (Double_Uns (Q)) * Big (Zu) =\n-                          Big_2xx32 * Big_2xx32 * Big (Double_Uns (Hi (T2)))\n-                        + Big_2xx32 * Big_2xx32 * Big (Double_Uns (Hi (T3)))\n-                                    + Big_2xx32 * Big (Double_Uns (S2))\n-                                                + Big (Double_Uns (S3)));\n+           Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n+         + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T3)))\n+                         + Big_2xxSingle * Big (Double_Uns (S2))\n+                                         + Big (Double_Uns (S3)));\n          pragma Assert (Double_Uns (Hi (T3)) + Hi (T2) = Double_Uns (S1));\n          Lemma_Add_Commutation (Double_Uns (Hi (T3)), Hi (T2));\n          pragma Assert\n@@ -1938,7 +1952,7 @@ is\n \n       procedure Prove_Overflow is\n       begin\n-         Lemma_Div_Ge (Mult, Big_2xx64, Big (Double_Uns'(abs Z)));\n+         Lemma_Div_Ge (Mult, Big_2xxDouble, Big (Double_Uns'(abs Z)));\n          Lemma_Abs_Commutation (Z);\n          Lemma_Abs_Div_Commutation (Big (X) * Big (Y), Big (Z));\n       end Prove_Overflow;\n@@ -1962,9 +1976,9 @@ is\n          Lemma_Lt_Commutation (Double_Uns (D (J)), Double_Uns (Zhi));\n          Lemma_Gt_Mult (Big (Double_Uns (Zhi)),\n                         Big (Double_Uns (D (J))) + 1,\n-                        Big_2xx32, Big (D (J) & D (J + 1)));\n+                        Big_2xxSingle, Big (D (J) & D (J + 1)));\n          Lemma_Div_Lt\n-           (Big (D (J) & D (J + 1)), Big_2xx32, Big (Double_Uns (Zhi)));\n+           (Big (D (J) & D (J + 1)), Big_2xxSingle, Big (Double_Uns (Zhi)));\n          Lemma_Div_Commutation (D (J) & D (J + 1), Double_Uns (Zhi));\n          Lemma_Lo_Is_Ident ((D (J) & D (J + 1)) / Zhi);\n          Lemma_Div_Definition (D (J) & D (J + 1), Zhi, Double_Uns (Qd (J)),\n@@ -1973,10 +1987,10 @@ is\n            ((D (J) & D (J + 1)) rem Zhi, Double_Uns (Zhi));\n          Lemma_Gt_Mult\n            ((Big (Double_Uns (Qd (J))) + 1) * Big (Double_Uns (Zhi)),\n-            Big (D (J) & D (J + 1)) + 1, Big_2xx32,\n+            Big (D (J) & D (J + 1)) + 1, Big_2xxSingle,\n             Big3 (D (J), D (J + 1), D (J + 2)));\n          Lemma_Hi_Lo (Zu, Zhi, Lo (Zu));\n-         Lemma_Gt_Mult (Big (Zu), Big_2xx32 * Big (Double_Uns (Zhi)),\n+         Lemma_Gt_Mult (Big (Zu), Big_2xxSingle * Big (Double_Uns (Zhi)),\n                         Big (Double_Uns (Qd (J))) + 1,\n                         Big3 (D (J), D (J + 1), D (J + 2)));\n          Lemma_Div_Lt (Big3 (D (J), D (J + 1), D (J + 2)),\n@@ -1989,7 +2003,7 @@ is\n \n       procedure Prove_Q_Too_Big is\n       begin\n-         pragma Assert (Big_Q = Big_2xx64 or Big_Q = -Big_2xx64);\n+         pragma Assert (Big_Q = Big_2xxDouble or Big_Q = -Big_2xxDouble);\n          Lemma_Not_In_Range_Big2xx64;\n       end Prove_Q_Too_Big;\n \n@@ -2055,16 +2069,16 @@ is\n          Lemma_Div_Definition (T2, Zlo, T2 / Zlo, Ru);\n          pragma Assert\n            (Mult = Big (Double_Uns (Zlo)) *\n-                     (Big_2xx32 * Big (T1 / Zlo) + Big (T2 / Zlo)) + Big (Ru));\n-         Lemma_Div_Lt (Big (T1), Big_2xx32, Big (Double_Uns (Zlo)));\n+              (Big_2xxSingle * Big (T1 / Zlo) + Big (T2 / Zlo)) + Big (Ru));\n+         Lemma_Div_Lt (Big (T1), Big_2xxSingle, Big (Double_Uns (Zlo)));\n          Lemma_Div_Commutation (T1, Double_Uns (Zlo));\n          Lemma_Lo_Is_Ident (T1 / Zlo);\n-         Lemma_Div_Lt (Big (T2), Big_2xx32, Big (Double_Uns (Zlo)));\n+         Lemma_Div_Lt (Big (T2), Big_2xxSingle, Big (Double_Uns (Zlo)));\n          Lemma_Div_Commutation (T2, Double_Uns (Zlo));\n          Lemma_Lo_Is_Ident (T2 / Zlo);\n          Lemma_Hi_Lo (Qu, Lo (T1 / Zlo), Lo (T2 / Zlo));\n          Lemma_Substitution (Mult, Big (Double_Uns (Zlo)),\n-                             Big_2xx32 * Big (T1 / Zlo) + Big (T2 / Zlo),\n+                             Big_2xxSingle * Big (T1 / Zlo) + Big (T2 / Zlo),\n                              Big (Qu), Big (Ru));\n          Lemma_Lt_Commutation (Ru, Double_Uns (Zlo));\n          Lemma_Rev_Div_Definition\n@@ -2110,7 +2124,7 @@ is\n \n          T2 := D (3) + Lo (T1);\n \n-         Lemma_Mult_Distribution (Big_2xx32,\n+         Lemma_Mult_Distribution (Big_2xxSingle,\n                                   Big (Double_Uns (D (3))),\n                                   Big (Double_Uns (Lo (T1))));\n          Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n@@ -2159,19 +2173,21 @@ is\n                    Big (Double_Uns (D (1))));\n \n             pragma Assert (Mult =\n-              Big_2xx32 * Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (1)))\n-                        + Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (2)))\n-                                    + Big_2xx32 * Big (Double_Uns (D (3)))\n+              Big_2xxSingle\n+                * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+                + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                                + Big_2xxSingle * Big (Double_Uns (D (3)))\n                                                 + Big (Double_Uns (D (4))));\n \n          else\n             D (1) := 0;\n          end if;\n \n          pragma Assert (Mult =\n-           Big_2xx32 * Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (1)))\n-                     + Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (2)))\n-                                 + Big_2xx32 * Big (Double_Uns (D (3)))\n+           Big_2xxSingle\n+             * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+             + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                             + Big_2xxSingle * Big (Double_Uns (D (3)))\n                                              + Big (Double_Uns (D (4))));\n \n       else\n@@ -2182,7 +2198,7 @@ is\n \n             T2 := D (3) + Lo (T1);\n \n-            Lemma_Mult_Distribution (Big_2xx32,\n+            Lemma_Mult_Distribution (Big_2xxSingle,\n                                      Big (Double_Uns (D (3))),\n                                      Big (Double_Uns (Lo (T1))));\n             Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n@@ -2196,27 +2212,28 @@ is\n             pragma Assert\n               (Big (Double_Uns (Hi (T1))) + Big (Double_Uns (Hi (T2))) =\n                  Big (Double_Uns (D (2))));\n-            pragma Assert\n-              (Mult = Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (2)))\n-                                + Big_2xx32 * Big (Double_Uns (D (3)))\n+            pragma Assert (Mult =\n+              Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                            + Big_2xxSingle * Big (Double_Uns (D (3)))\n                                             + Big (Double_Uns (D (4))));\n          else\n             D (2) := 0;\n \n-            pragma Assert\n-              (Mult = Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (2)))\n-                                + Big_2xx32 * Big (Double_Uns (D (3)))\n+            pragma Assert (Mult =\n+              Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                            + Big_2xxSingle * Big (Double_Uns (D (3)))\n                                             + Big (Double_Uns (D (4))));\n          end if;\n \n          D (1) := 0;\n       end if;\n \n-      pragma Assert\n-        (Mult = Big_2xx32 * Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (1)))\n-                          + Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (2)))\n-                                      + Big_2xx32 * Big (Double_Uns (D (3)))\n-                                                  + Big (Double_Uns (D (4))));\n+      pragma Assert (Mult =\n+        Big_2xxSingle\n+          * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+          + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                          + Big_2xxSingle * Big (Double_Uns (D (3)))\n+                                          + Big (Double_Uns (D (4))));\n \n       --  Now it is time for the dreaded multiple precision division. First an\n       --  easy case, check for the simple case of a one digit divisor.\n@@ -2225,14 +2242,14 @@ is\n          if D (1) /= 0 or else D (2) >= Zlo then\n             if D (1) > 0 then\n                pragma Assert\n-                 (Mult >= Big_2xx32 * Big_2xx32 * Big_2xx32\n+                 (Mult >= Big_2xxSingle * Big_2xxSingle * Big_2xxSingle\n                           * Big (Double_Uns (D (1))));\n-               pragma Assert (Mult >= Big_2xx64 * Big_2xx32);\n+               pragma Assert (Mult >= Big_2xxDouble * Big_2xxSingle);\n                Lemma_Ge_Commutation (2 ** Single_Size, Zu);\n-               pragma Assert (Mult >= Big_2xx64 * Big (Zu));\n+               pragma Assert (Mult >= Big_2xxDouble * Big (Zu));\n             else\n                Lemma_Ge_Commutation (Double_Uns (D (2)), Zu);\n-               pragma Assert (Mult >= Big_2xx64 * Big (Zu));\n+               pragma Assert (Mult >= Big_2xxDouble * Big (Zu));\n             end if;\n \n             Prove_Overflow;\n@@ -2387,7 +2404,7 @@ is\n          Lemma_Lt_Commutation (D (1) & D (2), abs Z);\n          Lemma_Lt_Mult (Big (D (1) & D (2)),\n                         Big (Double_Uns'(abs Z)), Big_2xx (Scale),\n-                        Big_2xx64);\n+                        Big_2xxDouble);\n \n          T1 := Shift_Left (D (1) & D (2), Scale);\n          T2 := Shift_Left (Double_Uns (D (3)), Scale);\n@@ -2401,21 +2418,23 @@ is\n          D (4) := Lo (T3);\n \n          pragma Assert (Mult * Big_2xx (Scale) =\n-           Big_2xx32 * Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (1)))\n-                     + Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (2)))\n-                                 + Big_2xx32 * Big (Double_Uns (D (3)))\n+           Big_2xxSingle\n+             * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+             + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                             + Big_2xxSingle * Big (Double_Uns (D (3)))\n                                              + Big (Double_Uns (D (4))));\n-         Lemma_Substitution (Big_2xx64 * Big (Zu), Big_2xx64, Big (Zu),\n+         Lemma_Substitution (Big_2xxDouble * Big (Zu), Big_2xxDouble, Big (Zu),\n                              Big (Double_Uns'(abs Z)) * Big_2xx (Scale), 0);\n-         Lemma_Lt_Mult (Mult, Big_2xx64 * Big (Double_Uns'(abs Z)),\n-                        Big_2xx (Scale), Big_2xx64 * Big (Zu));\n-         Lemma_Div_Lt (Mult * Big_2xx (Scale), Big (Zu), Big_2xx64);\n-         Lemma_Substitution (Mult * Big_2xx (Scale), Big_2xx32,\n-                             Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (1)))\n-                                       + Big_2xx32 * Big (Double_Uns (D (2)))\n-                                                   + Big (Double_Uns (D (3))),\n-                             Big3 (D (1), D (2), D (3)),\n-                             Big (Double_Uns (D (4))));\n+         Lemma_Lt_Mult (Mult, Big_2xxDouble * Big (Double_Uns'(abs Z)),\n+                        Big_2xx (Scale), Big_2xxDouble * Big (Zu));\n+         Lemma_Div_Lt (Mult * Big_2xx (Scale), Big (Zu), Big_2xxDouble);\n+         Lemma_Substitution\n+           (Mult * Big_2xx (Scale), Big_2xxSingle,\n+            Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+                          + Big_2xxSingle * Big (Double_Uns (D (2)))\n+                                          + Big (Double_Uns (D (3))),\n+            Big3 (D (1), D (2), D (3)),\n+            Big (Double_Uns (D (4))));\n \n          --  Loop to compute quotient digits, runs twice for Qd (1) and Qd (2)\n \n@@ -2427,7 +2446,7 @@ is\n               Ghost,\n               Pre  => X1 = 0,\n               Post =>\n-                Big_2xx32 * Big3 (X1, X2, X3) + Big (Double_Uns (X4))\n+                Big_2xxSingle * Big3 (X1, X2, X3) + Big (Double_Uns (X4))\n                   = Big3 (X2, X3, X4);\n \n             ---------------------------\n@@ -2463,10 +2482,11 @@ is\n                   Qd (J) := Single_Uns'Last;\n \n                   Lemma_Gt_Mult (Big (Zu), Big (D (J) & D (J + 1)) + 1,\n-                                 Big_2xx32,\n+                                 Big_2xxSingle,\n                                  Big3 (D (J), D (J + 1), D (J + 2)));\n                   Lemma_Div_Lt\n-                    (Big3 (D (J), D (J + 1), D (J + 2)), Big_2xx32, Big (Zu));\n+                    (Big3 (D (J), D (J + 1), D (J + 2)),\n+                     Big_2xxSingle, Big (Zu));\n \n                else\n                   Qd (J) := Lo ((D (J) & D (J + 1)) / Zhi);\n@@ -2548,50 +2568,52 @@ is\n \n                pragma Assert (Big3 (D (J), D (J + 1), D (J + 2)) < Big (Zu));\n                if D (J) > 0 then\n-                  pragma Assert (Big_2xx32 * Big_2xx32 = Big_2xx64);\n+                  pragma Assert\n+                    (Big_2xxSingle * Big_2xxSingle = Big_2xxDouble);\n                   pragma Assert (Big3 (D (J), D (J + 1), D (J + 2)) =\n-                                   Big_2xx32 * Big_2xx32\n-                                   * Big (Double_Uns (D (J)))\n-                                 + Big_2xx32 * Big (Double_Uns (D (J + 1)))\n-                                             + Big (Double_Uns (D (J + 2))));\n+                    Big_2xxSingle\n+                      * Big_2xxSingle * Big (Double_Uns (D (J)))\n+                      + Big_2xxSingle * Big (Double_Uns (D (J + 1)))\n+                                      + Big (Double_Uns (D (J + 2))));\n                   pragma Assert (Big3 (D (J), D (J + 1), D (J + 2)) =\n-                                   Big_2xx64 * Big (Double_Uns (D (J)))\n-                                 + Big_2xx32 * Big (Double_Uns (D (J + 1)))\n-                                             + Big (Double_Uns (D (J + 2))));\n+                    Big_2xxDouble * Big (Double_Uns (D (J)))\n+                  + Big_2xxSingle * Big (Double_Uns (D (J + 1)))\n+                                  + Big (Double_Uns (D (J + 2))));\n                   pragma Assert (Big3 (D (J), D (J + 1), D (J + 2)) >=\n-                                   Big_2xx64 * Big (Double_Uns (D (J))));\n+                                   Big_2xxDouble * Big (Double_Uns (D (J))));\n                   Lemma_Ge_Commutation (Double_Uns (D (J)), Double_Uns'(1));\n                   pragma Assert\n-                    (Big3 (D (J), D (J + 1), D (J + 2)) >= Big_2xx64);\n+                    (Big3 (D (J), D (J + 1), D (J + 2)) >= Big_2xxDouble);\n                   pragma Assert (False);\n                end if;\n \n                if J = 1 then\n                   Qd1 := Qd (1);\n                   Lemma_Substitution\n-                    (Mult * Big_2xx (Scale), Big_2xx32, D123,\n+                    (Mult * Big_2xx (Scale), Big_2xxSingle, D123,\n                      Big3 (D (1), D (2), D (3)) + Big3 (S1, S2, S3),\n                      Big (Double_Uns (D (4))));\n                   Prove_First_Iteration (D (1), D (2), D (3), D (4));\n-                  Lemma_Substitution (Mult * Big_2xx (Scale), Big_2xx32,\n+                  Lemma_Substitution (Mult * Big_2xx (Scale), Big_2xxSingle,\n                                       Big3 (S1, S2, S3),\n                                       Big (Double_Uns (Qd1)) * Big (Zu),\n                                       Big3 (D (2), D (3), D (4)));\n                else\n                   pragma Assert (Qd1 = Qd (1));\n                   pragma Assert\n-                    (Big_2xx32 * Big_2xx32 * Big (Double_Uns (D (2))) = 0);\n+                    (Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                     = 0);\n                   pragma Assert\n                     (Mult * Big_2xx (Scale) =\n-                       Big_2xx32 * Big (Double_Uns (Qd (1))) * Big (Zu)\n+                       Big_2xxSingle * Big (Double_Uns (Qd (1))) * Big (Zu)\n                      + Big3 (S1, S2, S3)\n                      + Big3 (D (2), D (3), D (4)));\n                   pragma Assert\n                     (Mult * Big_2xx (Scale) =\n-                       Big_2xx32 * Big (Double_Uns (Qd (1))) * Big (Zu)\n-                                 + Big (Double_Uns (Qd (2))) * Big (Zu)\n-                     + Big_2xx32 * Big (Double_Uns (D (3)))\n-                                 + Big (Double_Uns (D (4))));\n+                       Big_2xxSingle * Big (Double_Uns (Qd (1))) * Big (Zu)\n+                                     + Big (Double_Uns (Qd (2))) * Big (Zu)\n+                     + Big_2xxSingle * Big (Double_Uns (D (3)))\n+                                     + Big (Double_Uns (D (4))));\n                end if;\n             end loop;\n          end;\n@@ -2608,15 +2630,16 @@ is\n \n          pragma Assert\n            (Mult * Big_2xx (Scale) =\n-              Big_2xx32 * Big (Double_Uns (Qd (1))) * Big (Zu)\n-                        + Big (Double_Uns (Qd (2))) * Big (Zu)\n-            + Big_2xx32 * Big (Double_Uns (D (3)))\n-                        + Big (Double_Uns (D (4))));\n+              Big_2xxSingle * Big (Double_Uns (Qd (1))) * Big (Zu)\n+                            + Big (Double_Uns (Qd (2))) * Big (Zu)\n+            + Big_2xxSingle * Big (Double_Uns (D (3)))\n+                            + Big (Double_Uns (D (4))));\n          Lemma_Hi_Lo (Qu, Qd (1), Qd (2));\n          Lemma_Hi_Lo (Ru, D (3), D (4));\n          Lemma_Substitution\n            (Mult * Big_2xx (Scale), Big (Zu),\n-            Big_2xx32 * Big (Double_Uns (Qd (1))) + Big (Double_Uns (Qd (2))),\n+            Big_2xxSingle * Big (Double_Uns (Qd (1)))\n+              + Big (Double_Uns (Qd (2))),\n             Big (Qu), Big (Ru));\n          Prove_Rescaling;\n "}]}