{"sha": "5c3ea8054637ec397cdc68b22f3c06ce7920a205", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMzZWE4MDU0NjM3ZWMzOTdjZGM2OGIyMmYzYzA2Y2U3OTIwYTIwNQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-01-18T22:40:12Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-01-18T22:40:12Z"}, "message": "(CPP_SPEC, CONDITIONAL_REGISTER_USAGE, TARGET_SWITCHES,\n\nOVERRIDE_OPTIONS, FIRST_PSEUDO_REGISTER, FIXED_REGISTERS,\nCALL_USED_REGISTERS, HARD_REGNO_MODE_OK, enum reg_class,\nREG_CLASS_NAMES, REG_CLASS_CONTENTS, REG_ALLOC_ORDER,\nCONST_DOUBLE_OK_FOR_LETTER_P, NPARM_REGS, FUNCTION_VALUE,\nLIBCALL_VALUE, FUNCTION_VALUE_REGNO_P, FUNCTION_ARG_REGNO_P,\nCUMULATIVE_ARGS, ROUND_REG, INIT_CUMULATIVE_ARGS, FUNCTION_ARG_ADVANCE,\nFUNCTION_ARG, FUNCTION_ARG_PARTIAL_NREGS, LEGITIMATE_CONSTANT_P,\nMODE_DISP_OK_4, REGISTER_MOVE_COST, REGISTER_NAMES,\nDBX_REGISTER_NUMBER, enum processor_type): Add SH3E support.\n(SH3E_BIT, TARGET_SH3E, FPUL_REG, FIRST_FP_REG, LAST_FP_REG,\nFIRST_FP_PARM_REG, FIRST_FP_RET_REG, BASE_RETURN_VALUE_REG,\nBASE_ARG_REG, enum sh_arg_class, struct sh_args, GET_SH_ARG_CLASS,\nPASS_IN_REG_P, sh_builtin_saveregs, EXPAND_BUILTIN_SAVEREGS,\nDOUBLE_TYPE_SIZE): New.\n(TARGET_SWITCHES): Delete broken -m3l option.\n\nFrom-SVN: r11067", "tree": {"sha": "4c5674e4059b4ed2bec1d729b62833ebb4ccdd87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c5674e4059b4ed2bec1d729b62833ebb4ccdd87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c3ea8054637ec397cdc68b22f3c06ce7920a205", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c3ea8054637ec397cdc68b22f3c06ce7920a205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c3ea8054637ec397cdc68b22f3c06ce7920a205", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c3ea8054637ec397cdc68b22f3c06ce7920a205/comments", "author": null, "committer": null, "parents": [{"sha": "1979c66c4e4cc0fce3a8c04d3e6830b705f721e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1979c66c4e4cc0fce3a8c04d3e6830b705f721e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1979c66c4e4cc0fce3a8c04d3e6830b705f721e7"}], "stats": {"total": 225, "additions": 177, "deletions": 48}, "files": [{"sha": "0a41c2984f495e260933e186c8171a3b3e96faa8", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 177, "deletions": 48, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c3ea8054637ec397cdc68b22f3c06ce7920a205/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c3ea8054637ec397cdc68b22f3c06ce7920a205/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=5c3ea8054637ec397cdc68b22f3c06ce7920a205", "patch": "@@ -34,7 +34,7 @@ Boston, MA 02111-1307, USA.  */\n \n #define SDB_DELIM \";\"\n \n-#define CPP_SPEC \"%{ml:-D__LITTLE_ENDIAN__}\"\n+#define CPP_SPEC \"%{ml:-D__LITTLE_ENDIAN__} %{m3e:-D__SH3E__}\"\n \n #define CPP_PREDEFINES \"-D__sh__ -Acpu(sh) -Amachine(sh)\"\n \n@@ -46,6 +46,12 @@ Boston, MA 02111-1307, USA.  */\n /* #define CAN_DEBUG_WITHOUT_FP */\n \n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n+  if (! TARGET_SH3E)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      int regno;\t\t\t\t\t\t\\\n+      for (regno = FIRST_FP_REG; regno <= LAST_FP_REG; regno++)\t\\\n+\tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n   /* Hitachi saves and restores mac registers on call.  */\t\\\n   if (TARGET_HITACHI)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n@@ -65,6 +71,7 @@ extern int target_flags;\n #define SH1_BIT\t       \t(1<<8)\n #define SH2_BIT\t       \t(1<<9)\n #define SH3_BIT\t       \t(1<<10)\n+#define SH3E_BIT\t(1<<11)\n #define SPACE_BIT \t(1<<13)\n #define BIGTABLE_BIT  \t(1<<14)\n #define RELAX_BIT\t(1<<15)\n@@ -92,6 +99,9 @@ extern int target_flags;\n /* Nonzero if we should generate code using type 3 insns.  */\n #define TARGET_SH3 (target_flags & SH3_BIT)\n \n+/* Nonzero if we should generate code using type 3E insns.  */\n+#define TARGET_SH3E (target_flags & SH3E_BIT)\n+\n /* Nonzero if we should generate smaller code rather than faster code.  */\n #define TARGET_SMALLCODE   (target_flags & SPACE_BIT)\n \n@@ -120,7 +130,7 @@ extern int target_flags;\n   {\"1\",\t        SH1_BIT},\t\t\t\\\n   {\"2\",\t        SH2_BIT},\t\t\t\\\n   {\"3\",\t        SH3_BIT|SH2_BIT},\t\t\\\n-  {\"3l\",        SH3_BIT|SH2_BIT|LITTLE_ENDIAN_BIT},\t\\\n+  {\"3e\",\tSH3E_BIT|SH3_BIT|SH2_BIT},\t\\\n   {\"b\",\t\t-LITTLE_ENDIAN_BIT},  \t\t\\\n   {\"bigtable\", \tBIGTABLE_BIT},\t\t\t\\\n   {\"dalign\",  \tDALIGN_BIT},\t\t\t\\\n@@ -144,6 +154,8 @@ do {\t\t\t\t\t\t\t\t\\\n     sh_cpu = CPU_SH2;\t\t\t\t\t\t\\\n   if (TARGET_SH3)\t\t\t\t\t\t\\\n     sh_cpu = CPU_SH3;\t\t\t\t\t\t\\\n+  if (TARGET_SH3E)\t\t\t\t\t\t\\\n+    sh_cpu = CPU_SH3E;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n   /* Never run scheduling before reload, since that can\t\t\\\n      break global alloc, and generates slower code anyway due\t\\\n@@ -252,7 +264,12 @@ do {\t\t\t\t\t\t\t\t\\\n \tpr\t\tsubroutine return address\n \tt               t bit\n \tmach\t\tmultiply/accumulate result, high part\n-\tmacl\t\tmultiply/accumulate result, low part.  */\n+\tmacl\t\tmultiply/accumulate result, low part.\n+\tfpul\t\tfp/int communication register\n+\tfr0\t\tfp arg return\n+\tfr1..fr3\tscratch floating point registers\n+\tfr4..fr11\tfp args in\n+\tfr12..fr15\tcall saved floating point registers  */\n \n /* Number of actual hardware registers.\n    The hardware registers are assigned numbers for the compiler\n@@ -267,8 +284,12 @@ do {\t\t\t\t\t\t\t\t\\\n #define MACH_REG 20\n #define MACL_REG 21\n #define SPECIAL_REG(REGNO) ((REGNO) >= 18 && (REGNO) <= 21)\n+#define FPUL_REG 22\n+/* Number 23 is unused.  Reserved for future expansion.  */\n+#define FIRST_FP_REG 24\n+#define LAST_FP_REG 39\n \n-#define FIRST_PSEUDO_REGISTER 22\n+#define FIRST_PSEUDO_REGISTER 40\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -282,7 +303,12 @@ do {\t\t\t\t\t\t\t\t\\\n     0,  0,  0,  0, \t\t\\\n     0,  0,  0,  1, \t\t\\\n     1,  1,  1,  1, \t\t\\\n-    1,  1}\n+    1,  1,  1,  1,\t\t\\\n+    0,  0,  0,  0,\t\t\\\n+    0,  0,  0,  0,\t\t\\\n+    0,  0,  0,  0,\t\t\\\n+    0,  0,  0,  0\t\t\\\n+}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -292,12 +318,17 @@ do {\t\t\t\t\t\t\t\t\\\n    Aside from that, you can include as many other registers as you like.  */\n \n #define CALL_USED_REGISTERS \t\\\n-   { 1,  1,  1,  1,\t\t\\\n-     1,  1,  1,  1, \t\t\\\n-     0,  0,  0,  0,\t\t\\\n-     0,  0,  0,  1,\t\t\\\n-     1,  0,  1,  1,\t\t\\\n-     1,  1}\n+  { 1,  1,  1,  1,\t\t\\\n+    1,  1,  1,  1, \t\t\\\n+    0,  0,  0,  0,\t\t\\\n+    0,  0,  0,  1,\t\t\\\n+    1,  0,  1,  1,\t\t\\\n+    1,  1,  1,  1,\t\t\\\n+    1,  1,  1,  1,\t\t\\\n+    1,  1,  1,  1,\t\t\\\n+    1,  1,  1,  1,\t\t\\\n+    0,  0,  0,  0\t\t\\\n+}\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -315,6 +346,8 @@ do {\t\t\t\t\t\t\t\t\\\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n   (SPECIAL_REG (REGNO) ? (MODE) == SImode\t\\\n+   : (REGNO) == FPUL_REG ? (MODE) == SImode || (MODE) == SFmode\t\\\n+   : (REGNO) >= FIRST_FP_REG && (REGNO) <= LAST_FP_REG ? (MODE) == SFmode \\\n    : (REGNO) == PR_REG ? 0\t\t\t\\\n    : 1)\n \n@@ -427,6 +460,9 @@ enum reg_class\n   T_REGS,\n   MAC_REGS,\n   GENERAL_REGS,\n+  FPUL_REGS,\n+  FP0_REGS,\n+  FP_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n };\n@@ -442,22 +478,28 @@ enum reg_class\n   \"T_REGS\",\t\t\\\n   \"MAC_REGS\",\t\t\\\n   \"GENERAL_REGS\",\t\\\n+  \"FPUL_REGS\",\t\t\\\n+  \"FP0_REGS\",\t\t\\\n+  \"FP_REGS\",\t\t\\\n   \"ALL_REGS\",\t\t\\\n }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS\t\\\n-{\t\t\t\t\\\n-  0x000000,  /* NO_REGS      */\t\\\n-  0x000001,  /* R0_REGS      */\t\\\n-  0x020000,  /* PR_REGS      */\t\\\n-  0x040000,  /* T_REGS       */\t\\\n-  0x300000,  /* MAC_REGS     */\t\\\n-  0x01FFFF,  /* GENERAL_REGS */\t\\\n-  0x37FFFF   /* ALL_REGS     */\t\\\n+#define REG_CLASS_CONTENTS\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000 }, /* NO_REGS\t*/\t\\\n+  { 0x00000001, 0x00000000 }, /* R0_REGS\t*/\t\\\n+  { 0x00020000, 0x00000000 }, /* PR_REGS\t*/\t\\\n+  { 0x00040000, 0x00000000 }, /* T_REGS\t\t*/\t\\\n+  { 0x00300000, 0x00000000 }, /* MAC_REGS\t*/\t\\\n+  { 0x0001FFFF, 0x00000000 }, /* GENERAL_REGS\t*/\t\\\n+  { 0x00400000, 0x00000000 }, /* FPUL_REGS\t*/\t\\\n+  { 0x01000000, 0x00000000 }, /* FP0_REGS\t*/\t\\\n+  { 0xFF000000, 0x000000FF }, /* FP_REGS\t*/\t\\\n+  { 0xFF7FFFFF, 0x000000FF }, /* ALL_REGS\t*/\t\\\n }\n \n /* The same information, inverted:\n@@ -476,7 +518,9 @@ extern int regno_reg_class[];\n \n /* The order in which register should be allocated.  */\n #define REG_ALLOC_ORDER \\\n-  { 1,2,3,7,6,5,4,0,8,9,10,11,12,13,14,15,16,17,18,19,20,21 }\n+  { 1,2,3,7,6,5,4,0,8,9,10,11,12,13,14,\t\t\t\\\n+    24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,\t\\\n+    22,15,16,17,18,19,20,21,23 }\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS  R0_REGS\n@@ -518,6 +562,12 @@ extern enum reg_class reg_class_from_letter[];\n \n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n \n+#undef CONST_DOUBLE_OK_FOR_LETTER_P\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n+((C) == 'G' ? fp_zero_operand (VALUE)\t\t\\\n+ : (C) == 'H' ? fp_one_operand (VALUE)\t\t\\\n+ : 0)\n+\n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n@@ -535,11 +585,17 @@ extern enum reg_class reg_class_from_letter[];\n /* Stack layout; function entry, exit and calling.  */\n \n /* Define the number of registers that can hold parameters.\n-   These three macros are used only in other macro definitions below.  */\n-#define NPARM_REGS 4\n+   These macros are used only in other macro definitions below.  */\n+\n+#define NPARM_REGS(MODE) \\\n+  ((TARGET_SH3E && ((MODE) == SFmode)) ? 8 : 4)\n+\n #define FIRST_PARM_REG 4\n #define FIRST_RET_REG  0\n \n+#define FIRST_FP_PARM_REG (FIRST_FP_REG + 4)\n+#define FIRST_FP_RET_REG FIRST_FP_REG\n+\n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n #define STACK_GROWS_DOWNWARD\n@@ -572,26 +628,39 @@ extern enum reg_class reg_class_from_letter[];\n    on the stack.  */\n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)  0\n \n+/* Some subroutine macros specific to this machine. */\n+\n+#define BASE_RETURN_VALUE_REG(MODE) \\\n+  ((TARGET_SH3E && ((MODE) == SFmode))\t\t\t\\\n+   ? FIRST_FP_RET_REG\t\t\t\t\t\\\n+   : FIRST_RET_REG)\n+\n+#define BASE_ARG_REG(MODE) \\\n+  ((TARGET_SH3E && ((MODE) == SFmode))\t\t\t\\\n+   ? FIRST_FP_PARM_REG\t\t\t\t\t\\\n+   : FIRST_PARM_REG)\n+\n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), FIRST_RET_REG)\n-\n+  LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n+     \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n-#define LIBCALL_VALUE(MODE)\tgen_rtx (REG, MODE, FIRST_RET_REG)\n+#define LIBCALL_VALUE(MODE) \\\n+  gen_rtx (REG, MODE, BASE_RETURN_VALUE_REG (MODE));\n \n-/* 1 if N is a possible register number for a function value.\n-   On the SH, only r0 can return results.  */\n-#define FUNCTION_VALUE_REGNO_P(REGNO)\t((REGNO) == FIRST_RET_REG)\n+/* 1 if N is a possible register number for a function value. */\n+#define FUNCTION_VALUE_REGNO_P(REGNO) \\\n+  ((REGNO) == FIRST_RET_REG || (REGNO) == FIRST_FP_RET_REG)\n \n /* 1 if N is a possible register number for function argument passing.  */\n-\n #define FUNCTION_ARG_REGNO_P(REGNO) \\\n-  ((REGNO) >= FIRST_PARM_REG && (REGNO) < (NPARM_REGS + FIRST_PARM_REG))\n+  (((REGNO) >= FIRST_PARM_REG && (REGNO) < (FIRST_PARM_REG + 4)) \\\n+   || ((REGNO >= FIRST_FP_PARM_REG && (REGNO) < (FIRST_FP_PARM_REG + 8))))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -604,7 +673,15 @@ extern enum reg_class reg_class_from_letter[];\n    if any, which holds the structure-value-address).\n    Thus NARGREGS or more means all following args should go on the stack.  */\n \n-#define CUMULATIVE_ARGS  int\n+enum sh_arg_class { SH_ARG_INT = 0, SH_ARG_FLOAT = 1 };\n+struct sh_args {\n+    int arg_count[2];\n+};\n+\n+#define CUMULATIVE_ARGS  struct sh_args\n+\n+#define GET_SH_ARG_CLASS(MODE) \\\n+  ((TARGET_SH3E && ((MODE) == SFmode)) ? SH_ARG_FLOAT : SH_ARG_INT)\n \n #define ROUND_ADVANCE(SIZE) \\\n   ((SIZE + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n@@ -615,10 +692,12 @@ extern enum reg_class reg_class_from_letter[];\n    The SH doesn't care about double alignment, so we only\n    round doubles to even regs when asked to explicitly.  */\n \n-#define ROUND_REG(X, MODE) \t\t\t\t\t\\\n-  ((TARGET_ALIGN_DOUBLE \t\t\t\t\t\\\n-   && GET_MODE_UNIT_SIZE ((MODE)) > UNITS_PER_WORD) \t\t\\\n-   ? ((X) + ((X) & 1)) : (X))\n+#define ROUND_REG(CUM, MODE) \\\n+   ((TARGET_ALIGN_DOUBLE\t\t\t\t\t\\\n+     && GET_MODE_UNIT_SIZE ((MODE)) > UNITS_PER_WORD)\t\t\\\n+    ? ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)]\t\t\\\n+       + ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)] & 1))\t\\\n+    : (CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)])\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n@@ -628,19 +707,31 @@ extern enum reg_class reg_class_from_letter[];\n    the same reg.  */\n \n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME) \\\n-  ((CUM) = 0)\n+  do {\t\t\t\t\t\t\t\t\\\n+    (CUM).arg_count[(int) SH_ARG_INT] = 0;\t\t\t\\\n+    (CUM).arg_count[(int) SH_ARG_FLOAT] = 0;\t\t\t\\\n+  } while (0)\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be\n    available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) = (ROUND_REG ((CUM), (MODE))\t\t\t\\\n+ ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)] =\t\\\n+\t  (ROUND_REG ((CUM), (MODE))\t\t\t\\\n \t   + ((MODE) != BLKmode\t\t\t\t\\\n \t      ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\\\n \t      : ROUND_ADVANCE (int_size_in_bytes (TYPE)))))\n \n+/* Return boolean indicating arg of mode MODE will be passed in a reg.\n+   This macro is only used in this file. */\n+\n+#define PASS_IN_REG_P(CUM, MODE, TYPE) \\\n+  (ROUND_REG ((CUM), (MODE)) < NPARM_REGS (MODE)\t\t\\\n+  && ((TYPE)==0 || ! TREE_ADDRESSABLE((tree)(TYPE)))\t\t\\\n+  && ((TYPE)==0 || (MODE) != BLKmode))\n+\n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n@@ -660,9 +751,11 @@ extern enum reg_class reg_class_from_letter[];\n    its data type forbids.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  sh_function_arg (CUM, MODE, TYPE, NAMED)\n-\n-extern struct rtx_def *sh_function_arg();\n+  ((PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\\\n+    && (NAMED || TARGET_SH3E))\t\t\t\t\t\\\n+   ? gen_rtx (REG, (MODE), \t\t\t\t\t\\\n+\t      (BASE_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE)))) \\\n+   : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n@@ -671,7 +764,15 @@ extern struct rtx_def *sh_function_arg();\n    We sometimes split args.  */\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  sh_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n+  ((PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\\\n+    && (NAMED || TARGET_SH3E)\t\t\t\t\t\\\n+    && (ROUND_REG ((CUM), (MODE))\t\t\t\t\\\n+\t+ (MODE != BLKmode\t\t\t\t\t\\\n+\t   ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\t\\\n+\t   : ROUND_ADVANCE (int_size_in_bytes (TYPE)))\t\t\\\n+\t- NPARM_REGS (MODE) > 0))\t\t\t\t\\\n+   ? NPARM_REGS (MODE) - ROUND_REG ((CUM), (MODE))\t\t\\\n+   : 0)\n \n extern int current_function_anonymous_args;\n \n@@ -744,6 +845,11 @@ extern int current_function_anonymous_args;\n \t\t  (FNADDR));\t\t\t\t\t\t\\\n }\n \f\n+/* Generate necessary RTL for __builtin_saveregs().\n+   ARGLIST is the argument list; see expr.c.  */\n+extern struct rtx_def *sh_builtin_saveregs ();\n+#define EXPAND_BUILTIN_SAVEREGS(ARGLIST) sh_builtin_saveregs (ARGLIST)\n+\f\n /* Addressing modes, and classification of registers for them.  */\n #define HAVE_POST_INCREMENT  1\n /*#define HAVE_PRE_INCREMENT   1*/\n@@ -778,7 +884,10 @@ extern int current_function_anonymous_args;\n    constant pool table code to fix loads of CONST_DOUBLEs.  If that doesn't\n    work well, then we can at least handle simple CONST_DOUBLEs here\n    such as 0.0.  */\n-#define LEGITIMATE_CONSTANT_P(X)\t(GET_CODE(X) != CONST_DOUBLE)\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+  (GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\t\\\n+   || (TARGET_SH3E && (fp_zero_operand (X) || fp_one_operand (X))))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -840,7 +949,9 @@ extern int current_function_anonymous_args;\n \n    The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n \n-#define MODE_DISP_OK_4(X,MODE) ((GET_MODE_SIZE(MODE)==4) && ((unsigned)INTVAL(X)<64) && (!(INTVAL(X) &3)))\n+#define MODE_DISP_OK_4(X,MODE) \\\n+(GET_MODE_SIZE (MODE) == 4 && (unsigned) INTVAL (X) < 64\t\\\n+ && ! (INTVAL (X) & 3) && ! (TARGET_SH3E && MODE == SFmode))\n #define MODE_DISP_OK_8(X,MODE) ((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<60) && (!(INTVAL(X) &3)))\n \n #define BASE_REGISTER_RTX_P(X)\t\t\t\t\\\n@@ -868,6 +979,11 @@ extern int current_function_anonymous_args;\n \t  REG++\n \t  --REG  */\n \n+/* ??? The SH3e does not have the REG+disp addressing mode when loading values\n+   into the FRx registers.  We implement this by setting the maximum offset\n+   to zero when the value is SFmode.  This also restricts loading of SFmode\n+   values into the integer registers, but that can't be helped.  */\n+\n /* The SH allows a displacement in a QI or HI amode, but only when the\n    other operand is R0. GCC doesn't handle this very well, so we forgo\n    all of that.\n@@ -945,6 +1061,10 @@ extern int current_function_anonymous_args;\n /* This is the kind of divide that is easiest to do in the general case.  */\n #define EASY_DIV_EXPR  TRUNC_DIV_EXPR\n \n+/* Since the SH3e has only `float' support, it is desirable to make all\n+   floating point types equivalent to `float'.  */\n+#define DOUBLE_TYPE_SIZE (TARGET_SH3E ? 32 : 64)\n+\n /* 'char' is signed by default.  */\n #define DEFAULT_SIGNED_CHAR  1\n \n@@ -1094,7 +1214,10 @@ extern int current_function_anonymous_args;\n    from it.  */\n \n #define REGISTER_MOVE_COST(SRCCLASS, DSTCLASS) \\\n-\t(((DSTCLASS == T_REGS) || (DSTCLASS == PR_REG)) ? 10 : 1)\n+  (((DSTCLASS == T_REGS) || (DSTCLASS == PR_REG)) ? 10\t\t\\\n+   : ((DSTCLASS == FP_REGS && SRCCLASS == GENERAL_REGS)\t\t\\\n+      || (DSTCLASS == GENERAL_REGS && SRCCLASS == FP_REGS)) ? 4\t\\\n+   : 1)\n \n /* ??? Perhaps make MEMORY_MOVE_COST depend on compiler option?  This\n    would be so that people would slow memory systems could generate\n@@ -1197,11 +1320,16 @@ dtors_section()\t\t\t\t\t\t\t\\\n {\t\t\t\t                   \t\\\n   \"r0\", \"r1\", \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\", \t\\\n   \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\\\n-  \"ap\", \"pr\", \"t\",  \"gbr\", \"mach\",\"macl\" \t\t\\\n+  \"ap\", \"pr\", \"t\",  \"gbr\", \"mach\",\"macl\", \"fpul\", \"X\",  \\\n+  \"fr0\",\"fr1\",\"fr2\", \"fr3\", \"fr4\", \"fr5\", \"fr6\", \"fr7\", \\\n+  \"fr8\",\"fr9\",\"fr10\",\"fr11\",\"fr12\",\"fr13\",\"fr14\",\"fr15\",\\\n }\n \n /* DBX register number for a given compiler register number.  */\n-#define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n+/* GDB has FPUL at 23 and FP0 at 25, so we must add one to all FP registers\n+   to match gdb.  */\n+#define DBX_REGISTER_NUMBER(REGNO)\t\\\n+  (((REGNO) >= 22 && (REGNO) <= 39) ? ((REGNO) + 1) : (REGNO))\n \n /* Output a label definition.  */\n #define ASM_OUTPUT_LABEL(FILE,NAME) \\\n@@ -1363,7 +1491,8 @@ enum processor_type {\n   PROCESSOR_SH0,\n   PROCESSOR_SH1,\n   PROCESSOR_SH2,\n-  PROCESSOR_SH3\n+  PROCESSOR_SH3,\n+  PROCESSOR_SH3E\n };\n \n #define sh_cpu_attr ((enum attr_cpu)sh_cpu)"}]}