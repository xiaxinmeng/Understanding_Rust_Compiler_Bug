{"sha": "dae424695cc2848b137d7fd1ef7d375928101347", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFlNDI0Njk1Y2MyODQ4YjEzN2Q3ZmQxZWY3ZDM3NTkyODEwMTM0Nw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-07-09T22:42:43Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-07-09T22:42:43Z"}, "message": "md.texi (Processor pipeline description): Mention that the old pipeline description is deprecated.\n\n\t* doc/md.texi (Processor pipeline description): Mention that\n\tthe old pipeline description is deprecated.\n\n\t* config/rs6000/7450.md (automaton ppc7450): Split up, move\n\tmciu_7450 function unit to...\n\t(automaton ppc7450mciu): ...new automaton.\n\n\t* haifa-sched.c (insert_schedule_bubbles_p): Remove.\n\t(schedule_block): Don't consider inserting bubbles.\n\t(sched_init): Don't initialize DFA bubbles.\n\t* target-def.h (TARGET_SCHED_INIT_DFA_BUBBLES,\n\tTARGET_SCHED_DFA_BUBBLE): Remove.\n\t* target.h (init_dfa_bubbles, dfa_bubble): Remove hooks.\n\t* doc/tm.texi (TARGET_SCHED_INIT_DFA_BUBBLES,\n\tTARGET_SCHED_DFA_BUBBLE): Remove documentation.\n\n\t* stmt.c (conditional_context): Remove prototype.\n\t* tree.h (conditional_context): Remove.\n\t* tree-cfg.c (pre_insert_on_edge): Remove.\n\n\t* c-common.h (c_expand_asm_operands): Remove prototype.\n\t* c-typeck.c (c_expand_asm_operands): Remove.\n\ncp/\n\t* typeck.c (c_expand_asm_operands): Remove.\n\nFrom-SVN: r84411", "tree": {"sha": "7643455a8f32d75721933e33a55ab108707148cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7643455a8f32d75721933e33a55ab108707148cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dae424695cc2848b137d7fd1ef7d375928101347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae424695cc2848b137d7fd1ef7d375928101347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dae424695cc2848b137d7fd1ef7d375928101347", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae424695cc2848b137d7fd1ef7d375928101347/comments", "author": null, "committer": null, "parents": [{"sha": "9e9fb0ce6784ad84623738a559b5f67d78c84125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9fb0ce6784ad84623738a559b5f67d78c84125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9fb0ce6784ad84623738a559b5f67d78c84125"}], "stats": {"total": 341, "additions": 45, "deletions": 296}, "files": [{"sha": "c234ec956ff17c3c200c4c73a862e4e1f8b17822", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -1,4 +1,29 @@\n-2004-04-09  Jan Beulich  <jbeulich@novell.com>\n+2004-07-09  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* doc/md.texi (Processor pipeline description): Mention that\n+\tthe old pipeline description is deprecated.\n+\n+\t* config/rs6000/7450.md (automaton ppc7450): Split up, move\n+\tmciu_7450 function unit to...\n+\t(automaton ppc7450mciu): ...new automaton.\n+\n+\t* haifa-sched.c (insert_schedule_bubbles_p): Remove.\n+\t(schedule_block): Don't consider inserting bubbles.\n+\t(sched_init): Don't initialize DFA bubbles.\n+\t* target-def.h (TARGET_SCHED_INIT_DFA_BUBBLES,\n+\tTARGET_SCHED_DFA_BUBBLE): Remove.\n+\t* target.h (init_dfa_bubbles, dfa_bubble): Remove hooks.\n+\t* doc/tm.texi (TARGET_SCHED_INIT_DFA_BUBBLES,\n+\tTARGET_SCHED_DFA_BUBBLE): Remove documentation.\n+\n+\t* stmt.c (conditional_context): Remove prototype.\n+\t* tree.h (conditional_context): Remove.\n+\t* tree-cfg.c (pre_insert_on_edge): Remove.\n+\n+\t* c-common.h (c_expand_asm_operands): Remove prototype.\n+\t* c-typeck.c (c_expand_asm_operands): Remove.\n+\n+2004-07-09  Jan Beulich  <jbeulich@novell.com>\n \n \t* config/i386/i386.c (classify_argument): Treat V1xx modes the same as\n \ttheir base modes. CTImode, TCmode, and XCmode must be passed in memory.\n@@ -17,7 +42,7 @@\n \tMMX areguments and return values are passed in XMM registers).\n \t(sse2_umulsidi3): Correct type and mode.\n \n-2004-04-09  Richard Henderson  <rth@redhat.com>\n+2004-07-09  Richard Henderson  <rth@redhat.com>\n \n \t* tree-cfg.c (dump_cfg_stats): Fix 64-bit format mismatch errors.\n "}, {"sha": "ba7a2f87d241c2f70454d868d8a1fed7e5b7237a", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -798,8 +798,6 @@ extern tree build_case_label (tree, tree, tree);\n extern tree build_continue_stmt (void);\n extern tree build_break_stmt (void);\n \n-extern void c_expand_asm_operands (tree, tree, tree, tree, int, location_t);\n-\n /* These functions must be defined by each front-end which implements\n    a variant of the C language.  They are used in c-common.c.  */\n "}, {"sha": "ca2e6df793e953560403bfe1c5e59d1de83205f4", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -6187,65 +6187,6 @@ build_asm_expr (tree string, tree outputs, tree inputs, tree clobbers,\n     }\n   return args;\n }\n-\n-/* Expand an ASM statement with operands, handling output operands\n-   that are not variables or INDIRECT_REFS by transforming such\n-   cases into cases that expand_asm_operands can handle.\n-\n-   Arguments are same as for expand_asm_operands.  */\n-\n-void\n-c_expand_asm_operands (tree string, tree outputs, tree inputs,\n-\t\t       tree clobbers, int vol, location_t locus)\n-{\n-  int noutputs = list_length (outputs);\n-  int i;\n-  /* o[I] is the place that output number I should be written.  */\n-  tree *o = alloca (noutputs * sizeof (tree));\n-  tree tail;\n-\n-  /* Record the contents of OUTPUTS before it is modified.  */\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-    {\n-      o[i] = TREE_VALUE (tail);\n-      if (o[i] == error_mark_node)\n-\treturn;\n-    }\n-\n-  /* Generate the ASM_OPERANDS insn; store into the TREE_VALUEs of\n-     OUTPUTS some trees for where the values were actually stored.  */\n-  expand_asm_operands (string, outputs, inputs, clobbers, vol, locus);\n-\n-  /* Copy all the intermediate outputs into the specified outputs.  */\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-    {\n-      if (o[i] != TREE_VALUE (tail))\n-\t{\n-\t  expand_expr (build_modify_expr (o[i], NOP_EXPR, TREE_VALUE (tail)),\n-\t\t       NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-\t  free_temp_slots ();\n-\n-\t  /* Restore the original value so that it's correct the next\n-\t     time we expand this function.  */\n-\t  TREE_VALUE (tail) = o[i];\n-\t}\n-      /* Detect modification of read-only values.\n-\t (Otherwise done by build_modify_expr.)  */\n-      else\n-\t{\n-\t  tree type = TREE_TYPE (o[i]);\n-\t  if (TREE_READONLY (o[i])\n-\t      || TYPE_READONLY (type)\n-\t      || ((TREE_CODE (type) == RECORD_TYPE\n-\t\t   || TREE_CODE (type) == UNION_TYPE)\n-\t\t  && C_TYPE_FIELDS_READONLY (type)))\n-\t    readonly_error (o[i], \"modification by `asm'\");\n-\t}\n-    }\n-\n-  /* Those MODIFY_EXPRs could do autoincrements.  */\n-  emit_queue ();\n-}\n \f\n /* Generate a goto statement to LABEL.  */\n "}, {"sha": "bedf41aa888b0e2656c123d20abfc0f21eaa051a", "filename": "gcc/config/rs6000/7450.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fconfig%2Frs6000%2F7450.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fconfig%2Frs6000%2F7450.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2F7450.md?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -18,8 +18,9 @@\n ;; Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n ;; MA 02111-1307, USA.\n \n-(define_automaton \"ppc7450,ppc7450fp,ppc7450vec\")\n-(define_cpu_unit \"iu1_7450,iu2_7450,iu3_7450,mciu_7450\" \"ppc7450\")\n+(define_automaton \"ppc7450,ppc7450mciu,ppc7450fp,ppc7450vec\")\n+(define_cpu_unit \"iu1_7450,iu2_7450,iu3_7450\" \"ppc7450\")\n+(define_cpu_unit \"mciu_7450\" \"ppc7450mciu\")\n (define_cpu_unit \"fpu_7450\" \"ppc7450fp\")\n (define_cpu_unit \"lsu_7450,bpu_7450\" \"ppc7450\")\n (define_cpu_unit \"du1_7450,du2_7450,du3_7450\" \"ppc7450\")"}, {"sha": "a9ac0cb8b8f7a5c7560b030e8d0c6ead509188e1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -1,3 +1,7 @@\n+2004-07-09  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* typeck.c (c_expand_asm_operands): Remove.\n+\n 2004-07-09  Mike Stump  <mrs@apple.com>\n \n \t* typeck.c (build_class_member_access_expr): Skip null deref"}, {"sha": "d1792d4ddfba049788b06bca6eb7dd82e4426e00", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -5774,63 +5774,6 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n   return convert_for_assignment (type, rhs, errtype, fndecl, parmnum);\n }\n \f\n-/* Expand an ASM statement with operands, handling output operands\n-   that are not variables or INDIRECT_REFS by transforming such\n-   cases into cases that expand_asm_operands can handle.\n-\n-   Arguments are same as for expand_asm_operands.\n-\n-   We don't do default conversions on all inputs, because it can screw\n-   up operands that are expected to be in memory.  */\n-\n-void\n-c_expand_asm_operands (tree string, tree outputs, tree inputs, tree clobbers,\n-\t\t       int vol, location_t locus)\n-{\n-  int noutputs = list_length (outputs);\n-  int i;\n-  /* o[I] is the place that output number I should be written.  */\n-  tree *o = alloca (noutputs * sizeof (tree));\n-  tree tail;\n-\n-  /* Record the contents of OUTPUTS before it is modified.  */\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-    o[i] = TREE_VALUE (tail);\n-\n-  /* Generate the ASM_OPERANDS insn;\n-     store into the TREE_VALUEs of OUTPUTS some trees for\n-     where the values were actually stored.  */\n-  expand_asm_operands (string, outputs, inputs, clobbers, vol, locus);\n-\n-  /* Copy all the intermediate outputs into the specified outputs.  */\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-    {\n-      if (o[i] != TREE_VALUE (tail))\n-\t{\n-\t  expand_expr (build_modify_expr (o[i], NOP_EXPR, TREE_VALUE (tail)),\n-\t\t       const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t  free_temp_slots ();\n-\n-\t  /* Restore the original value so that it's correct the next\n-\t     time we expand this function.  */\n-\t  TREE_VALUE (tail) = o[i];\n-\t}\n-      /* Detect modification of read-only values.\n-\t (Otherwise done by build_modify_expr.)  */\n-      else\n-\t{\n-\t  tree type = TREE_TYPE (o[i]);\n-\t  if (type != error_mark_node\n-\t      && (CP_TYPE_CONST_P (type)\n-\t\t  || (CLASS_TYPE_P (type) && C_TYPE_FIELDS_READONLY (type))))\n-\t    readonly_error (o[i], \"modification by `asm'\", 1);\n-\t}\n-    }\n-\n-  /* Those MODIFY_EXPRs could do autoincrements.  */\n-  emit_queue ();\n-}\n-\f\n /* If RETVAL is the address of, or a reference to, a local variable or\n    temporary give an appropriate warning.  */\n "}, {"sha": "5949b8dd1cc1e13526c22324b68209bba1926211", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -5536,10 +5536,15 @@ instruction scheduler has to have an adequate description of the\n processor parallelism (or @dfn{pipeline description}).  Currently GCC\n provides two alternative ways to describe processor parallelism,\n both described below.  The first method is outlined in the next section;\n-it was once the only method provided by GCC, and thus is used in a number\n-of exiting ports.  The second, and preferred method, specifies functional\n-unit reservations for groups of instructions with the aid of @dfn{regular\n-expressions}.  This is called the @dfn{automaton based description}.\n+it specifies functional unit reservations for groups of instructions\n+with the aid of @dfn{regular expressions}.  This is called the\n+@dfn{automaton based description}.  The second method is called the\n+@dfn{old pipeline description}.  This method specifies usage of\n+function units for classes of insns.  This description is not as\n+powerful or accurate as the automaton based description, because it\n+is impossible to model instructions that use more than one function\n+unit.  The second method is deprecated; new ports should use the\n+automaton based description.\n \n The GCC instruction scheduler uses a @dfn{pipeline hazard recognizer} to\n figure out the possibility of the instruction issue by the processor\n@@ -5552,20 +5557,6 @@ generated from the old description.  Furthermore, its speed is not dependent\n on processor complexity.  The instruction issue is possible if there is\n a transition from one automaton state to another one.\n \n-You can use either model to describe processor pipeline\n-characteristics or even mix them.  You could use the old description\n-for some processor submodels and the @acronym{DFA}-based one for other\n-processor submodels.\n-\n-In general, using the automaton based description is preferred.  Its\n-model is richer and makes it possible to more accurately describe\n-pipeline characteristics of processors, which results in improved\n-code quality (although sometimes only marginally).  It will also be\n-used as an infrastructure to implement sophisticated and practical\n-instruction scheduling which will try many instruction sequences to\n-choose the best one.\n-\n-\n @menu\n * Old pipeline description:: Specifying information for insn scheduling.\n * Automaton pipeline description:: Describing insn pipeline characteristics.\n@@ -5579,6 +5570,8 @@ choose the best one.\n @cindex old pipeline description\n @cindex function units, for scheduling\n \n+@emph{Note:}The old pipeline description is deprecated.\n+\n On most @acronym{RISC} machines, there are instructions whose results\n are not available for a specific number of cycles.  Common cases are\n instructions that load data from memory.  On many machines, a pipeline"}, {"sha": "3bc86f33982a5b8ff41281faf7795f2e77f1cb38", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -5746,41 +5746,6 @@ correspondingly processor cycle on which the previous insn has been\n issued and the current processor cycle.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_BUBBLES (void)\n-The @acronym{DFA}-based scheduler could take the insertion of nop\n-operations for better insn scheduling into account.  It can be done\n-only if the multi-pass insn scheduling works (see hook\n-@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD}).\n-\n-Let us consider a @acronym{VLIW} processor insn with 3 slots.  Each\n-insn can be placed only in one of the three slots.  We have 3 ready\n-insns @var{A}, @var{B}, and @var{C}.  @var{A} and @var{C} can be\n-placed only in the 1st slot, @var{B} can be placed only in the 3rd\n-slot.  We described the automaton which does not permit empty slot\n-gaps between insns (usually such description is simpler).  Without\n-this code the scheduler would place each insn in 3 separate\n-@acronym{VLIW} insns.  If the scheduler places a nop insn into the 2nd\n-slot, it could place the 3 insns into 2 @acronym{VLIW} insns.  What is\n-the nop insn is returned by hook @samp{TARGET_SCHED_DFA_BUBBLE}.  Hook\n-@samp{TARGET_SCHED_INIT_DFA_BUBBLES} can be used to initialize or\n-create the nop insns.\n-\n-You should remember that the scheduler does not insert the nop insns.\n-It is not wise because of the following optimizations.  The scheduler\n-only considers such possibility to improve the result schedule.  The\n-nop insns should be inserted lately, e.g. on the final phase.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} rtx TARGET_SCHED_DFA_BUBBLE (int @var{index})\n-This hook @samp{FIRST_CYCLE_MULTIPASS_SCHEDULING} is used to insert\n-nop operations for better insn scheduling when @acronym{DFA}-based\n-scheduler makes multipass insn scheduling (see also description of\n-hook @samp{TARGET_SCHED_INIT_DFA_BUBBLES}).  This hook\n-returns a nop insn with given @var{index}.  The indexes start with\n-zero.  The hook should return @code{NULL} if there are no more nop\n-insns with indexes greater than given index.\n-@end deftypefn\n-\n @deftypefn {Target Hook} bool TARGET_SCHED_IS_COSTLY_DEPENDENCE (rtx @var{insn1}, rtx @var{insn2}, rtx @var{dep_link}, int @var{dep_cost}, int @var{distance})\n This hook is used to define which dependences are considered costly by\n the target, so costly that it is not advisable to schedule the insns that"}, {"sha": "1e29e7f98b04a135c640c03f836e66493d0d75ff", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -159,12 +159,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static int issue_rate;\n \n-/* If the following variable value is nonzero, the scheduler inserts\n-   bubbles (nop insns).  The value of variable affects on scheduler\n-   behavior only if automaton pipeline interface with multipass\n-   scheduling is used and hook dfa_bubble is defined.  */\n-int insert_schedule_bubbles_p = 0;\n-\n /* sched-verbose controls the amount of debugging output the\n    scheduler prints.  It is controlled by -fsched-verbose=N:\n    N>0 and no -DSR : the output is directed to stderr.\n@@ -2462,69 +2456,6 @@ schedule_block (int b, int rgn_n_insns)\n \t      else\n \t\t{\n \t\t  cost = state_transition (temp_state, insn);\n-\n-\t\t  if (targetm.sched.first_cycle_multipass_dfa_lookahead\n-\t\t      && targetm.sched.dfa_bubble)\n-\t\t    {\n-\t\t      if (cost == 0)\n-\t\t\t{\n-\t\t\t  int j;\n-\t\t\t  rtx bubble;\n-\n-\t\t\t  for (j = 0;\n-\t\t\t       (bubble = targetm.sched.dfa_bubble (j))\n-\t\t\t\t != NULL_RTX;\n-\t\t\t       j++)\n-\t\t\t    {\n-\t\t\t      memcpy (temp_state, curr_state, dfa_state_size);\n-\n-\t\t\t      if (state_transition (temp_state, bubble) < 0\n-\t\t\t\t  && state_transition (temp_state, insn) < 0)\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\n-\t\t\t  if (bubble != NULL_RTX)\n-\t\t\t    {\n-\t\t\t      if (insert_schedule_bubbles_p)\n-\t\t\t\t{\n-\t\t\t\t  rtx copy;\n-\n-\t\t\t\t  copy = copy_rtx (PATTERN (bubble));\n-\t\t\t\t  emit_insn_after (copy, last_scheduled_insn);\n-\t\t\t\t  last_scheduled_insn\n-\t\t\t\t    = NEXT_INSN (last_scheduled_insn);\n-\t\t\t\t  INSN_CODE (last_scheduled_insn)\n-\t\t\t\t    = INSN_CODE (bubble);\n-\n-\t\t\t\t  /* Annotate the same for the first insns\n-\t\t\t\t     scheduling by using mode.  */\n-\t\t\t\t  PUT_MODE (last_scheduled_insn,\n-\t\t\t\t\t    (clock_var > last_clock_var\n-\t\t\t\t\t     ? clock_var - last_clock_var\n-\t\t\t\t\t     : VOIDmode));\n-\t\t\t\t  last_clock_var = clock_var;\n-\n-\t\t\t\t  if (sched_verbose >= 2)\n-\t\t\t\t    {\n-\t\t\t\t      fprintf (sched_dump,\n-\t\t\t\t\t       \";;\\t\\t--> scheduling bubble insn <<<%d>>>:reservation \",\n-\t\t\t\t\t       INSN_UID (last_scheduled_insn));\n-\n-\t\t\t\t      if (recog_memoized (last_scheduled_insn)\n-\t\t\t\t\t  < 0)\n-\t\t\t\t\tfprintf (sched_dump, \"nothing\");\n-\t\t\t\t      else\n-\t\t\t\t\tprint_reservation\n-\t\t\t\t\t  (sched_dump, last_scheduled_insn);\n-\n-\t\t\t\t      fprintf (sched_dump, \"\\n\");\n-\t\t\t\t    }\n-\t\t\t\t}\n-\t\t\t      cost = -1;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\n \t\t  if (cost < 0)\n \t\t    cost = 0;\n \t\t  else if (cost == 0)\n@@ -2778,10 +2709,6 @@ sched_init (FILE *dump_file)\n       if (targetm.sched.init_dfa_post_cycle_insn)\n \ttargetm.sched.init_dfa_post_cycle_insn ();\n \n-      if (targetm.sched.first_cycle_multipass_dfa_lookahead\n-\t  && targetm.sched.init_dfa_bubbles)\n-\ttargetm.sched.init_dfa_bubbles ();\n-\n       dfa_start ();\n       dfa_state_size = state_size ();\n       curr_state = xmalloc (dfa_state_size);"}, {"sha": "f3bf87203392d1bd568d326b4811fa14017a3ea2", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -2308,16 +2308,6 @@ is_body_block (tree stmt)\n   return 0;\n }\n \n-/* True if we are currently emitting insns in an area of output code\n-   that is controlled by a conditional expression.  This is used by\n-   the cleanup handling code to generate conditional cleanup actions.  */\n-\n-int\n-conditional_context (void)\n-{\n-  return block_stack && block_stack->data.block.conditional_code;\n-}\n-\n /* Return an opaque pointer to the current nesting level, so frontend code\n    can check its own sanity.  */\n "}, {"sha": "50487f15933b09f41d060632cf7e6661cbf35252", "filename": "gcc/target-def.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -236,8 +236,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD 0\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD 0\n #define TARGET_SCHED_DFA_NEW_CYCLE 0\n-#define TARGET_SCHED_INIT_DFA_BUBBLES 0\n-#define TARGET_SCHED_DFA_BUBBLE 0\n #define TARGET_SCHED_IS_COSTLY_DEPENDENCE 0\n \n #define TARGET_SCHED\t\t\t\t\t\t\\\n@@ -260,8 +258,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD,\t\t\\\n    TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD,\t\\\n    TARGET_SCHED_DFA_NEW_CYCLE,\t\t\t\t\t\\\n-   TARGET_SCHED_INIT_DFA_BUBBLES,\t\t\t\t\\\n-   TARGET_SCHED_DFA_BUBBLE,                                     \\\n    TARGET_SCHED_IS_COSTLY_DEPENDENCE}\n \n /* In tree.c.  */"}, {"sha": "e2c24c67cbffff0d5776f8992945c2a633dd920a", "filename": "gcc/target.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -258,18 +258,6 @@ struct gcc_target\n        the previous insn has been issued and the current processor\n        cycle.  */\n     int (* dfa_new_cycle) (FILE *, int, rtx, int, int, int *);\n-    /* The values of the following members are pointers to functions\n-       used to improve the first cycle multipass scheduling by\n-       inserting nop insns.  dfa_scheduler_bubble gives a function\n-       returning a nop insn with given index.  The indexes start with\n-       zero.  The function should return NULL if there are no more nop\n-       insns with indexes greater than given index.  To initialize the\n-       nop insn the function given by member\n-       init_dfa_scheduler_bubbles is used.  The default values of the\n-       members result in not inserting nop insns during the multipass\n-       scheduling.  */\n-    void (* init_dfa_bubbles) (void);\n-    rtx (* dfa_bubble) (int);\n     /* The following member value is a pointer to a function called\n        by the insn scheduler.  It should return true if there exists a\n        dependence which is considered costly by the target, between "}, {"sha": "bd2ec9af808e953bfd4767020a8c61e19fc1866b", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -3038,27 +3038,6 @@ bsi_insert_on_edge (edge e, tree stmt)\n }\n \n \n-/* Specialized edge insertion for SSA-PRE.  FIXME: This should\n-   probably disappear.  The only reason it's here is because PRE needs\n-   the call to tree_find_edge_insert_loc().  */\n-\n-void pre_insert_on_edge (edge e, tree stmt);\n-\n-void\n-pre_insert_on_edge (edge e, tree stmt)\n-{\n-  block_stmt_iterator bsi;\n-\n-  if (PENDING_STMT (e))\n-    abort ();\n-\n-  if (tree_find_edge_insert_loc (e, &bsi))\n-    bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n-  else\n-    bsi_insert_before (&bsi, stmt, BSI_NEW_STMT);\n-}\n-\n-\n /*---------------------------------------------------------------------------\n \t     Tree specific functions for CFG manipulation\n ---------------------------------------------------------------------------*/"}, {"sha": "f2cfa21de34fe23ed03af63e70e9cd49853d3f67", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae424695cc2848b137d7fd1ef7d375928101347/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=dae424695cc2848b137d7fd1ef7d375928101347", "patch": "@@ -3348,7 +3348,6 @@ extern void expand_end_bindings (tree, int, int);\n extern void warn_about_unused_variables (tree);\n extern int is_body_block (tree);\n \n-extern int conditional_context (void);\n extern struct nesting * current_nesting_level (void);\n extern void expand_start_case (int, tree, tree, const char *);\n extern void expand_end_case_type (tree, tree);"}]}