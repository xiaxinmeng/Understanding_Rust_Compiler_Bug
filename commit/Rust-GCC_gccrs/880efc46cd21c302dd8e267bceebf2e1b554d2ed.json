{"sha": "880efc46cd21c302dd8e267bceebf2e1b554d2ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgwZWZjNDZjZDIxYzMwMmRkOGUyNjdiY2VlYmYyZTFiNTU0ZDJlZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2003-06-13T23:09:48Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2003-06-13T23:09:48Z"}, "message": "re PR bootstrap/10835 (combinatory explosion in scheduler on HyperSPARC)\n\n2003-06-13  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR bootstrap/10835\n\t* haifa-sched.c (max_lookahead_tries,\n        cached_first_cycle_multipass_dfa_lookahead,\n        cached_issue_rate): New variables.\n\t(max_issue): Check the number of tries.\n\t(choose_ready): Calculate max_lookahead_tries.\n\t(sched_init): Check cached_issue_rate.\n\nFrom-SVN: r67918", "tree": {"sha": "af8e35279a94d48b683c7891312afff2b66198e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af8e35279a94d48b683c7891312afff2b66198e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/880efc46cd21c302dd8e267bceebf2e1b554d2ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880efc46cd21c302dd8e267bceebf2e1b554d2ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/880efc46cd21c302dd8e267bceebf2e1b554d2ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880efc46cd21c302dd8e267bceebf2e1b554d2ed/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "792bb204afa4fdde580030e7e4f703fc93395e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792bb204afa4fdde580030e7e4f703fc93395e4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792bb204afa4fdde580030e7e4f703fc93395e4f"}], "stats": {"total": 63, "additions": 56, "deletions": 7}, "files": [{"sha": "f0db24ab8be66b0d3cc83f6fbe8f92aa89ca2755", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880efc46cd21c302dd8e267bceebf2e1b554d2ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880efc46cd21c302dd8e267bceebf2e1b554d2ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=880efc46cd21c302dd8e267bceebf2e1b554d2ed", "patch": "@@ -1,3 +1,13 @@\n+2003-06-13  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR bootstrap/10835\n+\t* haifa-sched.c (max_lookahead_tries,\n+        cached_first_cycle_multipass_dfa_lookahead,\n+        cached_issue_rate): New variables.\n+\t(max_issue): Check the number of tries.\n+\t(choose_ready): Calculate max_lookahead_tries.\n+\t(sched_init): Check cached_issue_rate.\n+\n 2003-06-13  Richard Henderson  <rth@redhat.com>\n \n \t* cfgbuild.c (make_edges): Set ABNORMAL with SIBCALL."}, {"sha": "ee5fb2b2212c9560b42a2236989753b4a48550ac", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880efc46cd21c302dd8e267bceebf2e1b554d2ed/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880efc46cd21c302dd8e267bceebf2e1b554d2ed/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=880efc46cd21c302dd8e267bceebf2e1b554d2ed", "patch": "@@ -1982,6 +1982,26 @@ static struct choice_entry *choice_stack;\n    processors state.  */\n static int cycle_issued_insns;\n \n+/* The following variable value is maximal number of tries of issuing\n+   insns for the first cycle multipass insn scheduling.  We define\n+   this value as constant*(DFA_LOOKAHEAD**ISSUE_RATE).  We would not\n+   need this constraint if all real insns (with non-negative codes)\n+   had reservations because in this case the algorithm complexity is\n+   O(DFA_LOOKAHEAD**ISSUE_RATE).  Unfortunately, the dfa descriptions\n+   might be incomplete and such insn might occur.  For such\n+   descriptions, the complexity of algorithm (without the constraint)\n+   could achieve DFA_LOOKAHEAD ** N , where N is the queue length.  */\n+static int max_lookahead_tries;\n+\n+/* The following value is value of hook\n+   `first_cycle_multipass_dfa_lookahead' at the last call of\n+   `max_issue'.  */\n+static int cached_first_cycle_multipass_dfa_lookahead = 0;\n+\n+/* The following value is value of `issue_rate' at the last call of\n+   `sched_init'.  */\n+static int cached_issue_rate = 0;\n+\n /* The following function returns maximal (or close to maximal) number\n    of insns which can be issued on the same cycle and one of which\n    insns is insns with the best rank (the first insn in READY).  To\n@@ -1995,21 +2015,21 @@ max_issue (ready, index)\n   struct ready_list *ready;\n   int *index;\n {\n-  int n, i, all, n_ready, lookahead, best, delay;\n+  int n, i, all, n_ready, best, delay, tries_num;\n   struct choice_entry *top;\n   rtx insn;\n \n-  lookahead = (*targetm.sched.first_cycle_multipass_dfa_lookahead) ();\n   best = 0;\n   memcpy (choice_stack->state, curr_state, dfa_state_size);\n   top = choice_stack;\n-  top->rest = lookahead;\n+  top->rest = cached_first_cycle_multipass_dfa_lookahead;\n   top->n = 0;\n   n_ready = ready->n_ready;\n   for (all = i = 0; i < n_ready; i++)\n     if (!ready_try [i])\n       all++;\n   i = 0;\n+  tries_num = 0;\n   for (;;)\n     {\n       if (top->rest == 0 || i >= n_ready)\n@@ -2030,6 +2050,9 @@ max_issue (ready, index)\n \t}\n       else if (!ready_try [i])\n \t{\n+\t  tries_num++;\n+\t  if (tries_num > max_lookahead_tries)\n+\t    break;\n \t  insn = ready_element (ready, i);\n \t  delay = state_transition (curr_state, insn);\n \t  if (delay < 0)\n@@ -2042,7 +2065,7 @@ max_issue (ready, index)\n \t      if (memcmp (top->state, curr_state, dfa_state_size) != 0)\n \t\tn++;\n \t      top++;\n-\t      top->rest = lookahead;\n+\t      top->rest = cached_first_cycle_multipass_dfa_lookahead;\n \t      top->index = i;\n \t      top->n = n;\n \t      memcpy (top->state, curr_state, dfa_state_size);\n@@ -2069,16 +2092,25 @@ static rtx\n choose_ready (ready)\n      struct ready_list *ready;\n {\n-  if (!targetm.sched.first_cycle_multipass_dfa_lookahead\n-      || (*targetm.sched.first_cycle_multipass_dfa_lookahead) () <= 0\n-      || SCHED_GROUP_P (ready_element (ready, 0)))\n+  int lookahead = 0;\n+\n+  if (targetm.sched.first_cycle_multipass_dfa_lookahead)\n+    lookahead = (*targetm.sched.first_cycle_multipass_dfa_lookahead) ();\n+  if (lookahead <= 0 || SCHED_GROUP_P (ready_element (ready, 0)))\n     return ready_remove_first (ready);\n   else\n     {\n       /* Try to choose the better insn.  */\n       int index, i;\n       rtx insn;\n \n+      if (cached_first_cycle_multipass_dfa_lookahead != lookahead)\n+\t{\n+\t  cached_first_cycle_multipass_dfa_lookahead = lookahead;\n+\t  max_lookahead_tries = 100;\n+\t  for (i = 0; i < issue_rate; i++)\n+\t    max_lookahead_tries *= lookahead;\n+\t}\n       insn = ready_element (ready, 0);\n       if (INSN_CODE (insn) < 0)\n \treturn ready_remove_first (ready);\n@@ -2606,6 +2638,13 @@ sched_init (dump_file)\n   else\n     issue_rate = 1;\n \n+  if (cached_issue_rate != issue_rate)\n+    {\n+      cached_issue_rate = issue_rate;\n+      /* To invalidate max_lookahead_tries:  */\n+      cached_first_cycle_multipass_dfa_lookahead = 0;\n+    }\n+\n   /* We use LUID 0 for the fake insn (UID 0) which holds dependencies for\n      pseudos which do not cross calls.  */\n   old_max_uid = get_max_uid () + 1;"}]}