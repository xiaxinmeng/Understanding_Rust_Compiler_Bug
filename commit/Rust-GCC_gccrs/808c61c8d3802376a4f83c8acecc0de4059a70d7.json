{"sha": "808c61c8d3802376a4f83c8acecc0de4059a70d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA4YzYxYzhkMzgwMjM3NmE0ZjgzYzhhY2VjYzBkZTQwNTlhNzBkNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "sidwell@codesourcery.com", "date": "2000-01-31T10:21:47Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-01-31T10:21:47Z"}, "message": "cp-tree.h (new_abi_rtti_p): Use flag_new_abi.\n\n\t* cp-tree.h (new_abi_rtti_p): Use flag_new_abi.\n\n\tRuntime support for new-abi rtti.\n\t* inc/typeinfo (type_info::operator!=): Define in class.\n\t(type_info::before, type_info::name, type_info::operator==,\n\ttype_info::operator!=): Define new ABI implementations.\n\t(type_info::is_pointer_p, type_info::is_function_p): Declare\n\tnew virtual functions.\n\t(type_info::do_catch, type_info::do_upcast): Likewise.\n\n\t* tinfo.h (__base_class_info): Define new class.\n\t(__class_type_info): Likewise.\n\t(__si_class_type_info): Likewise.\n\t(__vmi_class_type_info): Likewise.\n\t(__dynamic_cast): Prototype.\n\n\t* tinfo.cc: Conditionalize old and new rtti mechanisms.\n\t(type_info::is_pointer_p): Define new function.\n\t(type_info::is_function_p): Likewise.\n\t(type_info::do_catch): Likewise.\n\t(type_info::do_upcast): Likewise.\n\t(vtable_prefix): New structure for vtable access.\n\t(adjust_pointer): Define new template function.\n\t(contained_p, public_p, virtual_p, contained_public_p,\n\tcontained_nonpublic_p, contained_nonvirtual_p): Define new\n\tfunctions.\n\t(nonvirtual_base_type): New local variable.\n\t(__class_type_info::~__class_type_info): Define.\n\t(__si_class_type_info::~__si_class_type_info): Likewise.\n\t(__vmi_class_type_info::~__vmi_class_type_info): Likewise.\n\t(__class_type_info::do_catch): Define new function.\n\t(__class_type_info::do_upcast): Likewise.\n\t(__class_type_info::find_public_src): Likewise.\n\t(__class_type_info::do_find_public_src): Likewise.\n\t(__si_class_type_info::do_find_public_src): Likewise.\n\t(__vmi_class_type_info::do_find_public_src): Likewise.\n\t(__class_type_info::do_dyncast): Likewise.\n\t(__si_class_type_info::do_dyncast): Likewise.\n\t(__vmi_class_type_info::do_dyncast): Likewise.\n\t(__class_type_info::do_upcast): Likewise.\n\t(__si_class_type_info::do_upcast): Likewise.\n\t(__vmi_class_type_info::do_upcast): Likewise.\n\t(__dynamic_cast): Likewise.\n\n\t* tinfo2.cc (__fundamental_type_info): Define new class.\n\t(__pointer_type_info): Likewise.\n\t(__reference_type_info): Likewise.\n\t(__array_type_info): Likewise.\n\t(__function_type_info): Likewise.\n\t(__enum_type_info): Likewise.\n\t(__ptr_to_member_type_info): Likewise.\n\t(__fundamental_type_info::~__fundamental_type_info): Define.\n\t(__pointer_type_info::~__pointer_type_info): Likewise.\n\t(__reference_type_info::~__reference_type_info): Likewise.\n\t(__array_type_info::~__array_type_info): Likewise.\n\t(__function_type_info::~__function_type_info): Likewise.\n\t(__enum_type_info::~__enum_type_info): Likewise.\n\t(__ptr_to_member_type_info::~__ptr_to_member_type_info): Likewise.\n\t(__pointer_type_info::do_catch): Define new function.\n\t(__ptr_to_member_type_info::do_catch): Define new function.\n\n\t(__throw_type_match_rtti_2): Use new ABI interface, if enabled.\n\t(__is_pointer): Likewise.\n\n\t* exception.cc (__cplus_type_matcher): Deal with new-abi rtti.\n\nFrom-SVN: r31713", "tree": {"sha": "32e728931f1c116b63aabf36f962f86fa7112a38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32e728931f1c116b63aabf36f962f86fa7112a38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/808c61c8d3802376a4f83c8acecc0de4059a70d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/808c61c8d3802376a4f83c8acecc0de4059a70d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/808c61c8d3802376a4f83c8acecc0de4059a70d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/808c61c8d3802376a4f83c8acecc0de4059a70d7/comments", "author": null, "committer": null, "parents": [{"sha": "ab5cffc5e8a1720ad3168310d1e4bb13d430ffc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab5cffc5e8a1720ad3168310d1e4bb13d430ffc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab5cffc5e8a1720ad3168310d1e4bb13d430ffc1"}], "stats": {"total": 1255, "additions": 1234, "deletions": 21}, "files": [{"sha": "192daf4e0a87bd1320aa712ce6467ed3c35f3c45", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=808c61c8d3802376a4f83c8acecc0de4059a70d7", "patch": "@@ -1,3 +1,71 @@\n+2000-01-31  Nathan Sidwell  <sidwell@codesourcery.com>\n+\n+\t* cp-tree.h (new_abi_rtti_p): Use flag_new_abi.\n+\n+\tRuntime support for new-abi rtti.\n+\t* inc/typeinfo (type_info::operator!=): Define in class.\n+\t(type_info::before, type_info::name, type_info::operator==,\n+\ttype_info::operator!=): Define new ABI implementations.\n+\t(type_info::is_pointer_p, type_info::is_function_p): Declare\n+\tnew virtual functions.\n+\t(type_info::do_catch, type_info::do_upcast): Likewise.\n+\t\n+\t* tinfo.h (__base_class_info): Define new class.\n+\t(__class_type_info): Likewise.\n+\t(__si_class_type_info): Likewise.\n+\t(__vmi_class_type_info): Likewise.\n+\t(__dynamic_cast): Prototype.\n+\t\n+\t* tinfo.cc: Conditionalize old and new rtti mechanisms.\n+\t(type_info::is_pointer_p): Define new function.\n+\t(type_info::is_function_p): Likewise.\n+\t(type_info::do_catch): Likewise.\n+\t(type_info::do_upcast): Likewise.\n+\t(vtable_prefix): New structure for vtable access.\n+\t(adjust_pointer): Define new template function.\n+\t(contained_p, public_p, virtual_p, contained_public_p,\n+\tcontained_nonpublic_p, contained_nonvirtual_p): Define new\n+\tfunctions.\n+\t(nonvirtual_base_type): New local variable.\n+\t(__class_type_info::~__class_type_info): Define.\n+\t(__si_class_type_info::~__si_class_type_info): Likewise.\n+\t(__vmi_class_type_info::~__vmi_class_type_info): Likewise.\n+\t(__class_type_info::do_catch): Define new function.\n+\t(__class_type_info::do_upcast): Likewise.\n+\t(__class_type_info::find_public_src): Likewise.\n+\t(__class_type_info::do_find_public_src): Likewise.\n+\t(__si_class_type_info::do_find_public_src): Likewise.\n+\t(__vmi_class_type_info::do_find_public_src): Likewise.\n+\t(__class_type_info::do_dyncast): Likewise.\n+\t(__si_class_type_info::do_dyncast): Likewise.\n+\t(__vmi_class_type_info::do_dyncast): Likewise.\n+\t(__class_type_info::do_upcast): Likewise.\n+\t(__si_class_type_info::do_upcast): Likewise.\n+\t(__vmi_class_type_info::do_upcast): Likewise.\n+\t(__dynamic_cast): Likewise.\n+\t\n+\t* tinfo2.cc (__fundamental_type_info): Define new class.\n+\t(__pointer_type_info): Likewise.\n+\t(__reference_type_info): Likewise.\n+\t(__array_type_info): Likewise.\n+\t(__function_type_info): Likewise.\n+\t(__enum_type_info): Likewise.\n+\t(__ptr_to_member_type_info): Likewise.\n+\t(__fundamental_type_info::~__fundamental_type_info): Define.\n+\t(__pointer_type_info::~__pointer_type_info): Likewise.\n+\t(__reference_type_info::~__reference_type_info): Likewise.\n+\t(__array_type_info::~__array_type_info): Likewise.\n+\t(__function_type_info::~__function_type_info): Likewise.\n+\t(__enum_type_info::~__enum_type_info): Likewise.\n+\t(__ptr_to_member_type_info::~__ptr_to_member_type_info): Likewise.\n+\t(__pointer_type_info::do_catch): Define new function.\n+\t(__ptr_to_member_type_info::do_catch): Define new function.\n+\t\n+\t(__throw_type_match_rtti_2): Use new ABI interface, if enabled.\n+\t(__is_pointer): Likewise.\n+\n+\t* exception.cc (__cplus_type_matcher): Deal with new-abi rtti.\n+\n 2000-01-30  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp/class.c (build_vtable): Rename to build_primary_vtable."}, {"sha": "f1d86e56f173a0d8dd922efc9833f8f9586f230f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=808c61c8d3802376a4f83c8acecc0de4059a70d7", "patch": "@@ -244,7 +244,7 @@ extern int flag_rtti;\n /* Nonzero if we use access type_info objects directly, and use the\n    cross-vendor layout for them. Zero if we use an accessor function\n    to get the type_info object address.  */\n-#define new_abi_rtti_p() (0)\n+#define new_abi_rtti_p() (flag_new_abi)\n \n \f\n /* Language-dependent contents of an identifier.  */"}, {"sha": "0c806e6cf00e19a7ae9ee0f78ed3946a131249ec", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=808c61c8d3802376a4f83c8acecc0de4059a70d7", "patch": "@@ -184,7 +184,11 @@ __cplus_type_matcher (__eh_info *info_, void *match_info,\n \n   /* we don't worry about version info yet, there is only one version! */\n   \n-  void *match_type = ((void *(*)())match_info) ();\n+  void *match_type = match_info;\n+  \n+#if !defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n+  match_type  = ((void *(*)())match_type) ();\n+#endif\n \n   if (__throw_type_match_rtti_2 (match_type, info->type,\n \t\t\t\t info->original_value, &info->value))"}, {"sha": "b631d6e2d24101b29331d967bb202eb03dd3244f", "filename": "gcc/cp/inc/typeinfo", "status": "modified", "additions": 60, "deletions": 14, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Finc%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Finc%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Ftypeinfo?ref=808c61c8d3802376a4f83c8acecc0de4059a70d7", "patch": "@@ -1,5 +1,10 @@\n // RTTI support for -*- C++ -*-\n-// Copyright (C) 1994, 95-97, 1998 Free Software Foundation\n+// Copyright (C) 1994, 95-97, 1998, 2000 Free Software Foundation\n+\n+// __GXX_ABI_VERSION distinguishes the ABI that is being used. Values <100\n+// indicate the `old' abi, which grew as C++ was defined. Values >=100\n+// indicate the `new' abi, which is a cross vendor C++ abi, documented at\n+// `http://reality.sgi.com/dehnert_engr/cxx/'.\n \n #ifndef __TYPEINFO__\n #define __TYPEINFO__\n@@ -12,33 +17,74 @@ extern \"C++\" {\n \n namespace std {\n \n+#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+class __class_type_info;\n+#endif\n+\n class type_info {\n+public:\n+  // Destructor. Being the first non-inline virtual function, this controls in\n+  // which translation unit the vtable is emitted. The compiler makes use of\n+  // that information to know where to emit the runtime-mandated type_info\n+  // structures in the new-abi.\n+  virtual ~type_info ();\n+\n private:\n-  // assigning type_info is not supported.  made private.\n+  // Assigning type_info is not supported.  made private.\n   type_info& operator= (const type_info&);\n   type_info (const type_info&);\n \n protected:\n-  explicit type_info (const char *n): _name (n) { }\n-\n   const char *_name;\n \n+protected:\n+  explicit type_info (const char *n): _name (n) { }\n+\n public:\n-  // destructor\n-  virtual ~type_info ();\n-    \n+  // the public interface\n+#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n+  // In old abi, there can be multiple instances of a type_info object for one\n+  // type. Uniqueness must use the _name value, not object address.\n   bool before (const type_info& arg) const;\n   const char* name () const\n     { return _name; }\n   bool operator== (const type_info& arg) const;\n-  bool operator!= (const type_info& arg) const;\n-};\n+  bool operator!= (const type_info& arg) const\n+    { return !operator== (arg); }\n+\n+#else\n+  // In new abi we can rely on type_info's being unique,\n+  // and therefore address comparisons are sufficient.\n+  bool before (const type_info& arg) const\n+    { return this < &arg; }\n+  const char* name () const\n+    { return _name; }\n+  bool operator== (const type_info& arg) const\n+    { return &arg == this; }\n+  bool operator!= (const type_info& arg) const\n+    { return !operator== (arg); }\n+#endif\n \n-inline bool type_info::\n-operator!= (const type_info& arg) const\n-{\n-  return !operator== (arg);\n-}\n+  // the internal interface\n+#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+public:\n+  // return true if this is a pointer type of some kind\n+  virtual bool is_pointer_p () const;\n+  // return true if this is a function type\n+  virtual bool is_function_p () const;\n+\n+  // Try and catch a thrown type. Store an adjusted pointer to the caught type\n+  // in THR_OBJ. If THR_TYPE is not a pointer type, then THR_OBJ points to the\n+  // thrown object. If THR_TYPE is a pointer type, then THR_OBJ is the pointer\n+  // itself. OUTER indicates the number of outer pointers, and whether they\n+  // were const qualified.\n+  virtual bool do_catch (const type_info *thr_type, void **thr_obj,\n+                         unsigned outer) const;\n+\n+  // internally used during catch matching\n+  virtual bool do_upcast (const __class_type_info *target, void **obj_ptr) const;\n+#endif\n+};\n \n class bad_cast : public exception {\n public:"}, {"sha": "557c88c18073ae91972871886a29243b0dd723e0", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 602, "deletions": 0, "changes": 602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=808c61c8d3802376a4f83c8acecc0de4059a70d7", "patch": "@@ -67,6 +67,9 @@ std::type_info::\n ~type_info ()\n { }\n \n+#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n+// original (old) abi\n+\n // We can't rely on common symbols being shared between shared objects.\n bool std::type_info::\n operator== (const std::type_info& arg) const\n@@ -539,3 +542,602 @@ do_find_public_subobj (int boff, const type_info &subtype, void *objptr, void *s\n   \n   return not_contained;\n }\n+#else\n+// new abi\n+\n+namespace std {\n+\n+// return true if this is a type_info for a pointer type\n+bool type_info::\n+is_pointer_p () const\n+{\n+  return false;\n+}\n+\n+// return true if this is a type_info for a function type\n+bool type_info::\n+is_function_p () const\n+{\n+  return false;\n+}\n+\n+// try and catch a thrown object.\n+bool type_info::\n+do_catch (const type_info *thr_type, void **, unsigned) const\n+{\n+  return *this == *thr_type;\n+}\n+\n+// upcast from this type to the target. __class_type_info will override\n+bool type_info::\n+do_upcast (const __class_type_info *, void **) const\n+{\n+  return false;\n+}\n+\n+};\n+\n+namespace {\n+\n+using namespace std;\n+\n+// initial part of a vtable, this structure is used with offsetof, so we don't\n+// have to keep alignments consistent manually.\n+struct vtable_prefix {\n+  ptrdiff_t whole_object;           // offset to most derived object\n+  const __class_type_info *whole_type;  // pointer to most derived type_info\n+  const void *origin;               // what a class's vptr points to\n+};\n+\n+template <typename T>\n+inline const T *\n+adjust_pointer (const void *base, ptrdiff_t offset)\n+{\n+  return reinterpret_cast <const T *>\n+    (reinterpret_cast <const char *> (base) + offset);\n+}\n+\n+// some predicate functions for __class_type_info::sub_kind\n+inline bool contained_p (__class_type_info::sub_kind access_path)\n+{\n+  return access_path >= __class_type_info::contained_mask;\n+}\n+inline bool public_p (__class_type_info::sub_kind access_path)\n+{\n+  return access_path & __class_type_info::contained_public_mask;\n+}\n+inline bool virtual_p (__class_type_info::sub_kind access_path)\n+{\n+  return (access_path & __class_type_info::contained_virtual_mask);\n+}\n+inline bool contained_public_p (__class_type_info::sub_kind access_path)\n+{\n+  return (access_path & __class_type_info::contained_public) == __class_type_info::contained_public;\n+}\n+inline bool contained_nonpublic_p (__class_type_info::sub_kind access_path)\n+{\n+  return (access_path & __class_type_info::contained_public) == __class_type_info::contained_mask;\n+}\n+inline bool contained_nonvirtual_p (__class_type_info::sub_kind access_path)\n+{\n+  return (access_path & (__class_type_info::contained_mask | __class_type_info::contained_virtual_mask))\n+         == __class_type_info::contained_mask;\n+}\n+\n+static const __class_type_info *const nonvirtual_base_type =\n+    static_cast <const __class_type_info *> (0) + 1;\n+\n+}; // namespace\n+\n+namespace std {\n+\n+__class_type_info::\n+~__class_type_info ()\n+{}\n+\n+__si_class_type_info::\n+~__si_class_type_info ()\n+{}\n+\n+__vmi_class_type_info::\n+~__vmi_class_type_info ()\n+{}\n+\n+bool __class_type_info::\n+do_catch (const type_info *thr_type, void **thr_obj,\n+          unsigned outer) const\n+{\n+  if (*this == *thr_type)\n+    return true;\n+  if (outer >= 4)\n+    // Neither `A' nor `A *'.\n+    return false;\n+  return thr_type->do_upcast (this, thr_obj);\n+}\n+\n+bool __class_type_info::\n+do_upcast (const __class_type_info *dst_type, void **obj_ptr) const\n+{\n+  upcast_result result (details);\n+  \n+  if (do_upcast (contained_public, dst_type, *obj_ptr, result))\n+    return false;\n+  *obj_ptr = const_cast <void *> (result.dst_ptr);\n+  return contained_public_p (result.whole2dst);\n+}\n+\n+inline __class_type_info::sub_kind __class_type_info::\n+find_public_src (ptrdiff_t src2dst,\n+                 const void *obj_ptr,\n+                 const __class_type_info *src_type,\n+                 const void *src_ptr) const\n+{\n+  if (src2dst >= 0)\n+    return adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n+            ? contained_public : not_contained;\n+  if (src2dst == -2)\n+    return not_contained;\n+  return do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n+}\n+\n+__class_type_info::sub_kind __class_type_info::\n+do_find_public_src (ptrdiff_t,\n+                    const void *obj_ptr,\n+                    const __class_type_info *,\n+                    const void *src_ptr) const\n+{\n+  if (src_ptr == obj_ptr)\n+    // Must be our type, as the pointers match.\n+    return contained_public;\n+  return not_contained;\n+}\n+\n+__class_type_info::sub_kind __si_class_type_info::\n+do_find_public_src (ptrdiff_t src2dst,\n+                    const void *obj_ptr,\n+                    const __class_type_info *src_type,\n+                    const void *src_ptr) const\n+{\n+  if (src_ptr == obj_ptr && *this == *src_type)\n+    return contained_public;\n+  return base->do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n+}\n+\n+__class_type_info::sub_kind __vmi_class_type_info::\n+do_find_public_src (ptrdiff_t src2dst,\n+                    const void *obj_ptr,\n+                    const __class_type_info *src_type,\n+                    const void *src_ptr) const\n+{\n+  if (obj_ptr == src_ptr && *this == *src_type)\n+    return contained_public;\n+  \n+  for (size_t i = n_bases; i--;)\n+    {\n+      if (!base_list[i].is_public_p ())\n+        continue; // Not public, can't be here.\n+      \n+      const void *base = obj_ptr;\n+      ptrdiff_t offset = base_list[i].offset;\n+      \n+      if (base_list[i].is_virtual_p ())\n+        {\n+          if (src2dst == -3)\n+            continue; // Not a virtual base, so can't be here.\n+  \t  const ptrdiff_t *vtable = *static_cast <const ptrdiff_t *const *> (base);\n+          \n+\t  offset = vtable[offset];\n+        }\n+      base = adjust_pointer <void> (base, offset);\n+      \n+      sub_kind base_kind = base_list[i].type->do_find_public_src\n+                              (src2dst, base, src_type, src_ptr);\n+      if (contained_p (base_kind))\n+        {\n+          if (base_list[i].is_virtual_p ())\n+            base_kind = sub_kind (base_kind | contained_virtual_mask);\n+          return base_kind;\n+        }\n+    }\n+  \n+  return not_contained;\n+}\n+\n+bool __class_type_info::\n+do_dyncast (ptrdiff_t,\n+            sub_kind access_path,\n+            const __class_type_info *dst_type,\n+            const void *obj_ptr,\n+            const __class_type_info *src_type,\n+            const void *src_ptr,\n+            dyncast_result &__restrict result) const\n+{\n+  if (obj_ptr == src_ptr && *this == *src_type)\n+    {\n+      // The src object we started from. Indicate how we are accessible from\n+      // the most derived object.\n+      result.whole2src = access_path;\n+      return false;\n+    }\n+  if (*this == *dst_type)\n+    {\n+      result.dst_ptr = obj_ptr;\n+      result.whole2dst = access_path;\n+      result.dst2src = not_contained;\n+      return false;\n+    }\n+  return false;\n+}\n+\n+bool __si_class_type_info::\n+do_dyncast (ptrdiff_t src2dst,\n+            sub_kind access_path,\n+            const __class_type_info *dst_type,\n+            const void *obj_ptr,\n+            const __class_type_info *src_type,\n+            const void *src_ptr,\n+            dyncast_result &__restrict result) const\n+{\n+  if (*this == *dst_type)\n+    {\n+      result.dst_ptr = obj_ptr;\n+      result.whole2dst = access_path;\n+      if (src2dst >= 0)\n+        result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n+              ? contained_public : not_contained;\n+      else if (src2dst == -2)\n+        result.dst2src = not_contained;\n+      return false;\n+    }\n+  if (obj_ptr == src_ptr && *this == *src_type)\n+    {\n+      // The src object we started from. Indicate how we are accessible from\n+      // the most derived object.\n+      result.whole2src = access_path;\n+      return false;\n+    }\n+  return base->do_dyncast (src2dst, access_path, dst_type, obj_ptr,\n+                           src_type, src_ptr, result);\n+}\n+\n+// This is a big hairy function. Although the run-time behaviour of\n+// dynamic_cast is simple to describe, it gives rise to some non-obvious\n+// behaviour. We also desire to determine as early as possible any definite\n+// answer we can get. Because it is unknown what the run-time ratio of\n+// succeeding to failing dynamic casts is, we do not know in which direction\n+// to bias any optimizations. To that end we make no particular effort towards\n+// early fail answers or early success answers. Instead we try to minimize\n+// work by filling in things lazily (when we know we need the information),\n+// and opportunisticly take early success or failure results.\n+bool __vmi_class_type_info::\n+do_dyncast (ptrdiff_t src2dst,\n+            sub_kind access_path,\n+            const __class_type_info *dst_type,\n+            const void *obj_ptr,\n+            const __class_type_info *src_type,\n+            const void *src_ptr,\n+            dyncast_result &__restrict result) const\n+{\n+  if (obj_ptr == src_ptr && *this == *src_type)\n+    {\n+      // The src object we started from. Indicate how we are accessible from\n+      // the most derived object.\n+      result.whole2src = access_path;\n+      return false;\n+    }\n+  if (*this == *dst_type)\n+    {\n+      result.dst_ptr = obj_ptr;\n+      result.whole2dst = access_path;\n+      if (src2dst >= 0)\n+        result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n+              ? contained_public : not_contained;\n+      else if (src2dst == -2)\n+        result.dst2src = not_contained;\n+      return false;\n+    }\n+  bool result_ambig = false;\n+  for (size_t i = n_bases; i--;)\n+    {\n+      dyncast_result result2;\n+      void const *base = obj_ptr;\n+      sub_kind base_access = access_path;\n+      ptrdiff_t offset = base_list[i].offset;\n+      \n+      if (base_list[i].is_virtual_p ())\n+        {\n+          base_access = sub_kind (base_access | contained_virtual_mask);\n+  \t  const ptrdiff_t *vtable = *static_cast <const ptrdiff_t *const *> (base);\n+          \n+\t  offset = vtable[offset];\n+\t}\n+      base = adjust_pointer <void> (base, offset);\n+\n+      if (!base_list[i].is_public_p ())\n+        base_access = sub_kind (base_access & ~contained_public_mask);\n+      \n+      bool result2_ambig\n+          = base_list[i].type->do_dyncast (src2dst, base_access,\n+                                           dst_type, base,\n+                                           src_type, src_ptr, result2);\n+      result.whole2src = sub_kind (result.whole2src | result2.whole2src);\n+      if (result2.dst2src == contained_public\n+          || result2.dst2src == contained_ambig)\n+        {\n+          result.dst_ptr = result2.dst_ptr;\n+          result.whole2dst = result2.whole2dst;\n+          result.dst2src = result2.dst2src;\n+          // Found a downcast which can't be bettered or an ambiguous downcast\n+          // which can't be disambiguated\n+          return result2_ambig;\n+        }\n+      \n+      if (!result_ambig && !result.dst_ptr)\n+        {\n+          // Not found anything yet.\n+          result.dst_ptr = result2.dst_ptr;\n+          result.whole2dst = result2.whole2dst;\n+          result_ambig = result2_ambig;\n+        }\n+      else if (result.dst_ptr && result.dst_ptr == result2.dst_ptr)\n+        {\n+          // Found at same address, must be via virtual.  Pick the most\n+          // accessible path.\n+          result.whole2dst =\n+              sub_kind (result.whole2dst | result2.whole2dst);\n+        }\n+      else if ((result.dst_ptr && result2.dst_ptr)\n+               || (result_ambig && result2.dst_ptr)\n+               || (result2_ambig && result.dst_ptr))\n+        {\n+          // Found two different DST_TYPE bases, or a valid one and a set of\n+          // ambiguous ones, must disambiguate. See whether SRC_PTR is\n+          // contained publicly within one of the non-ambiguous choices. If it\n+          // is in only one, then that's the choice. If it is in both, then\n+          // we're ambiguous and fail. If it is in neither, we're ambiguous,\n+          // but don't yet fail as we might later find a third base which does\n+          // contain SRC_PTR.\n+        \n+          sub_kind new_sub_kind = result2.dst2src;\n+          sub_kind old_sub_kind = result.dst2src;\n+          \n+          if (contained_nonvirtual_p (result.whole2src))\n+            {\n+              // We already found SRC_PTR as a non-virtual base of most\n+              // derived. Therefore if it is in either choice, it can only be\n+              // in one of them, and we will already know.\n+              if (old_sub_kind == unknown)\n+                old_sub_kind = not_contained;\n+              if (new_sub_kind == unknown)\n+                new_sub_kind = not_contained;\n+            }\n+          else\n+            {\n+              if (old_sub_kind >= not_contained)\n+                ;// already calculated\n+              else if (contained_nonvirtual_p (new_sub_kind))\n+                // Already found non-virtually inside the other choice,\n+                // cannot be in this.\n+                old_sub_kind = not_contained;\n+              else\n+                old_sub_kind = dst_type->find_public_src\n+                                (src2dst, result.dst_ptr, src_type, src_ptr);\n+          \n+              if (new_sub_kind >= not_contained)\n+                ;// already calculated\n+              else if (contained_nonvirtual_p (old_sub_kind))\n+                // Already found non-virtually inside the other choice,\n+                // cannot be in this.\n+                new_sub_kind = not_contained;\n+              else\n+                new_sub_kind = dst_type->find_public_src\n+                                (src2dst, result2.dst_ptr, src_type, src_ptr);\n+            }\n+          \n+          // Neither sub_kind can be contained_ambig -- we bail out early\n+          // when we find those.\n+          if (contained_p (sub_kind (new_sub_kind ^ old_sub_kind)))\n+            {\n+              // Only on one choice, not ambiguous.\n+              if (contained_p (new_sub_kind))\n+                {\n+                  // Only in new.\n+                  result.dst_ptr = result2.dst_ptr;\n+                  result.whole2dst = result2.whole2dst;\n+                  result_ambig = false;\n+                  old_sub_kind = new_sub_kind;\n+                }\n+              result.dst2src = old_sub_kind;\n+              if (public_p (result.dst2src))\n+                return false; // Can't be an ambiguating downcast for later discovery.\n+              if (!virtual_p (result.dst2src))\n+                return false; // Found non-virtually can't be bettered\n+            }\n+          else if (contained_p (sub_kind (new_sub_kind & old_sub_kind)))\n+            {\n+              // In both.\n+              result.dst_ptr = NULL;\n+              result.dst2src = contained_ambig;\n+              return true;  // Fail.\n+            }\n+          else\n+            {\n+              // In neither publicly, ambiguous for the moment, but keep\n+              // looking. It is possible that it was private in one or\n+              // both and therefore we should fail, but that's just tough.\n+              result.dst_ptr = NULL;\n+              result.dst2src = not_contained;\n+              result_ambig = true;\n+            }\n+        }\n+      \n+      if (result.whole2src == contained_private)\n+        // We found SRC_PTR as a private non-virtual base, therefore all\n+        // cross casts will fail. We have already found a down cast, if\n+        // there is one.\n+        return result_ambig;\n+    }\n+\n+  return result_ambig;\n+}\n+\n+bool __class_type_info::\n+do_upcast (sub_kind access_path,\n+           const __class_type_info *dst, const void *obj,\n+           upcast_result &__restrict result) const\n+{\n+  if (*this == *dst)\n+    {\n+      result.dst_ptr = obj;\n+      result.base_type = nonvirtual_base_type;\n+      result.whole2dst = access_path;\n+      return contained_nonpublic_p (access_path);\n+    }\n+  return false;\n+}\n+\n+bool __si_class_type_info::\n+do_upcast (sub_kind access_path,\n+           const __class_type_info *dst, const void *obj_ptr,\n+           upcast_result &__restrict result) const\n+{\n+  if (*this == *dst)\n+    {\n+      result.dst_ptr = obj_ptr;\n+      result.base_type = nonvirtual_base_type;\n+      result.whole2dst = access_path;\n+      return contained_nonpublic_p (access_path);\n+    }\n+  return base->do_upcast (access_path, dst, obj_ptr, result);\n+}\n+\n+bool __vmi_class_type_info::\n+do_upcast (sub_kind access_path,\n+           const __class_type_info *dst, const void *obj_ptr,\n+           upcast_result &__restrict result) const\n+{\n+  if (*this == *dst)\n+    {\n+      result.dst_ptr = obj_ptr;\n+      result.base_type = nonvirtual_base_type;\n+      result.whole2dst = access_path;\n+      return contained_nonpublic_p (access_path);\n+    }\n+  \n+  for (size_t i = n_bases; i--;)\n+    {\n+      upcast_result result2 (result.src_details);\n+      const void *base = obj_ptr;\n+      sub_kind sub_access = access_path;\n+      ptrdiff_t offset = base_list[i].offset;\n+      \n+      if (!base_list[i].is_public_p ())\n+        {\n+          if (!(result.src_details & multiple_base_mask))\n+            // original cannot have an ambiguous base\n+            continue;\n+          sub_access = sub_kind (sub_access & ~contained_public_mask);\n+        }\n+      if (base_list[i].is_virtual_p ())\n+        {\n+      \t  sub_access = sub_kind (sub_access | contained_virtual_mask);\n+          \n+          if (base)\n+            {\n+    \t      const ptrdiff_t *vtable = *static_cast <const ptrdiff_t *const *> (base);\n+\t      offset = vtable[offset];\n+\t    }\n+        }\n+      if (base)\n+        base = adjust_pointer <void> (base, offset);\n+      \n+      if (base_list[i].type->do_upcast (sub_access, dst, base, result2))\n+        return true; // must fail\n+      if (result2.base_type)\n+        {\n+          if (result2.base_type == nonvirtual_base_type\n+              && base_list[i].is_virtual_p ())\n+            result2.base_type = base_list[i].type;\n+          if (!result.base_type)\n+            {\n+              result = result2;\n+              if (!(details & multiple_base_mask))\n+                // cannot have an ambiguous other base\n+                return false;\n+            }\n+          else if (result.dst_ptr != result2.dst_ptr)\n+            {\n+              // Found an ambiguity.\n+\t      result.dst_ptr = NULL;\n+\t      result.whole2dst = contained_ambig;\n+\t      return true;\n+            }\n+          else if (result.dst_ptr)\n+            {\n+              // Ok, found real object via a virtual path.\n+              result.whole2dst\n+                  = sub_kind (result.whole2dst | result2.whole2dst);\n+            }\n+          else\n+            {\n+              // Dealing with a null pointer, need to check vbase\n+              // containing each of the two choices.\n+              if (result2.base_type == nonvirtual_base_type\n+                  || result.base_type == nonvirtual_base_type\n+                  || !(*result2.base_type == *result.base_type))\n+                {\n+                  // Already ambiguous, not virtual or via different virtuals.\n+                  // Cannot match.\n+                  result.whole2dst = contained_ambig;\n+                  return true;\n+                }\n+            }\n+        }\n+    }\n+  return false;\n+}\n+\n+// this is the external interface to the dynamic cast machinery\n+void *\n+__dynamic_cast (const void *src_ptr,    // object started from\n+                const __class_type_info *src_type, // type of the starting object\n+                const __class_type_info *dst_type, // desired target type\n+                ptrdiff_t src2dst) // how src and dst are related\n+{\n+  const void *vtable = *static_cast <const void *const *> (src_ptr);\n+  const vtable_prefix *prefix =\n+      adjust_pointer <vtable_prefix> (vtable, 0);\n+  // FIXME: the above offset should be -offsetof (vtable_prefix, origin));\n+  // but we don't currently layout vtables correctly.\n+  const void *whole_ptr =\n+      adjust_pointer <void> (src_ptr, prefix->whole_object);\n+  const __class_type_info *whole_type = prefix->whole_type;\n+  __class_type_info::dyncast_result result;\n+  \n+  whole_type->do_dyncast (src2dst, __class_type_info::contained_public,\n+                          dst_type, whole_ptr, src_type, src_ptr, result);\n+  if (!result.dst_ptr)\n+    return NULL;\n+  if (contained_public_p (result.dst2src))\n+    return const_cast <void *> (result.dst_ptr);\n+  if (contained_public_p (__class_type_info::sub_kind (result.whole2src & result.whole2dst)))\n+    // Found a valid cross cast\n+    return const_cast <void *> (result.dst_ptr);\n+  if (contained_nonvirtual_p (result.whole2src))\n+    // Found an invalid cross cast, which cannot also be a down cast\n+    return NULL;\n+  if (!(whole_type->details & __class_type_info::private_base_mask))\n+    // whole type has no private bases\n+    return const_cast <void *> (result.dst_ptr);\n+  if (result.dst2src == __class_type_info::unknown)\n+    result.dst2src = dst_type->find_public_src (src2dst, result.dst_ptr,\n+                                                src_type, src_ptr);\n+  if (contained_public_p (result.dst2src))\n+    // Found a valid down cast\n+    return const_cast <void *> (result.dst_ptr);\n+  // Must be an invalid down cast, or the cross cast wasn't bettered\n+  return NULL;\n+}\n+\n+}; // namespace std\n+#endif"}, {"sha": "2894ed6ca154756c766edd99afba8d8fd53099de", "filename": "gcc/cp/tinfo.h", "status": "modified", "additions": 230, "deletions": 4, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Ftinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Ftinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.h?ref=808c61c8d3802376a4f83c8acecc0de4059a70d7", "patch": "@@ -5,6 +5,9 @@\n \n // Class declarations shared between the typeinfo implementation files.\n \n+#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n+// original (old) abi\n+\n // type_info for a class with no base classes (or an enum).\n \n struct __user_type_info : public std::type_info {\n@@ -167,11 +170,7 @@ class __si_type_info : public __user_type_info {\n \n // type_info for a general class.\n \n-#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n typedef int USItype __attribute__ ((mode (SI)));\n-#else\n-typedef unsigned int USItype\t__attribute__ ((mode (SI)));\n-#endif\n \n struct __class_type_info : public __user_type_info {\n   enum access { PUBLIC = 1, PROTECTED = 2, PRIVATE = 3 };\n@@ -200,3 +199,230 @@ struct __class_type_info : public __user_type_info {\n   virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,\n                                           void *objptr, void *subptr) const;\n };\n+#else\n+// new abi\n+#include \"stddef.h\"\n+\n+typedef int USItype __attribute__ ((mode (SI)));\n+\n+namespace std {\n+\n+class __class_type_info;\n+\n+// helper class for __vmi_class_type\n+struct __base_class_info {\n+  const __class_type_info *type;  // base class type\n+  ptrdiff_t offset;               // offset to the sub object\n+  int vmi_flags;                  // about the base\n+\n+// implementation specific parts\n+  enum vmi_masks {\n+    virtual_mask = 0x1,\n+    public_mask = 0x2,\n+    hwm_bit = 2\n+  };\n+  \n+public:\n+  bool is_virtual_p () const\n+    { return vmi_flags & virtual_mask; }\n+  bool is_public_p () const\n+    { return vmi_flags & public_mask; }\n+};\n+\n+// type information for a class\n+class __class_type_info : public type_info {\n+protected:\n+  virtual ~__class_type_info ();\n+public:\n+  int details;      // details about the class heirarchy\n+\n+// implementation specific parts\n+  enum detail_masks {\n+    multiple_base_mask = 0x1,   // multiple inheritance of the same base type\n+    polymorphic_mask = 0x2,     // is a polymorphic type\n+    virtual_base_mask = 0x4,    // has virtual bases (direct or indirect)\n+    private_base_mask = 0x8     // has private bases (direct or indirect)\n+  };\n+\n+public:\n+  // sub_kind tells us about how a base object is contained within a derived\n+  // object. We often do this lazily, hence the UNKNOWN value. At other times\n+  // we may use NOT_CONTAINED to mean not publicly contained.\n+  enum sub_kind\n+  {\n+    unknown = 0,              // we have no idea\n+    not_contained,            // not contained within us (in some\n+                              // circumstances this might mean not contained\n+                              // publicly)\n+    contained_ambig,          // contained ambiguously\n+    \n+    contained_virtual_mask = __base_class_info::virtual_mask, // via a virtual path\n+    contained_public_mask = __base_class_info::public_mask,   // via a public path\n+    contained_mask = 1 << __base_class_info::hwm_bit,         // contained within us\n+    \n+    contained_private = contained_mask,\n+    contained_public = contained_mask | contained_public_mask\n+  };\n+\n+public:  \n+  struct upcast_result\n+  {\n+    const void *dst_ptr;        // pointer to caught object\n+    sub_kind whole2dst;         // path from most derived object to target\n+    int src_details;            // hints about the source type\n+    const __class_type_info *base_type; // where we found the target,\n+                                // if in vbase the __class_type_info of vbase\n+                                // if a non-virtual base then 1\n+                                // else NULL\n+    public:\n+    upcast_result (int d)\n+      :dst_ptr (NULL), whole2dst (unknown), src_details (d), base_type (NULL)\n+      {}\n+  };\n+\n+public:\n+  // dyncast_result is used to hold information during traversal of a class\n+  // heirarchy when dynamic casting.\n+  struct dyncast_result\n+  {\n+    const void *dst_ptr;        // pointer to target object or NULL\n+    sub_kind whole2dst;         // path from most derived object to target\n+    sub_kind whole2src;         // path from most derived object to sub object\n+    sub_kind dst2src;           // path from target to sub object\n+    \n+    public:\n+    dyncast_result ()\n+      :dst_ptr (NULL), whole2dst (unknown),\n+       whole2src (unknown), dst2src (unknown)\n+      {}\n+  };\n+\n+public:\n+  explicit __class_type_info (const char *n,\n+                              int details_)\n+    : type_info (n), details (details_)\n+    { }\n+\n+protected:\n+  virtual bool do_upcast (const __class_type_info *dst_type, void **obj_ptr) const;\n+\n+protected:\n+  virtual bool do_catch (const type_info *thr_type, void **thr_obj,\n+                         unsigned outer) const;\n+\n+\n+public:\n+  // Helper for upcast. See if DST is us, or one of our bases. ACCESS_PATH\n+  // gives the access from the start object. Return TRUE if we know the upcast\n+  // fails.\n+  virtual bool do_upcast (sub_kind access_path,\n+                          const __class_type_info *dst, const void *obj,\n+                          upcast_result &__restrict result) const;\n+\n+public:\n+  // Indicate whether SRC_PTR of type SRC_TYPE is contained publicly within\n+  // OBJ_PTR. OBJ_PTR points to a base object of our type, which is the\n+  // destination type. SRC2DST indicates how SRC objects might be contained\n+  // within this type.  If SRC_PTR is one of our SRC_TYPE bases, indicate the\n+  // virtuality. Returns not_contained for non containment or private\n+  // containment.\n+  inline sub_kind find_public_src (ptrdiff_t src2dst, const void *obj_ptr,\n+                                   const __class_type_info *src_type,\n+                                   const void *src_ptr) const;\n+\n+public:\n+  // dynamic cast helper. ACCESS_PATH gives the access from the most derived\n+  // object to this base. DST_TYPE indicates the desired type we want. OBJ_PTR\n+  // points to a base of our type within the complete object. SRC_TYPE\n+  // indicates the static type started from and SRC_PTR points to that base\n+  // within the most derived object. Fill in RESULT with what we find. Return\n+  // true if we have located an ambiguous match.\n+  virtual bool do_dyncast (ptrdiff_t src2dst, sub_kind access_path,\n+                           const __class_type_info *dst_type, const void *obj_ptr,\n+                           const __class_type_info *src_type, const void *src_ptr,\n+                           dyncast_result &result) const;\n+public:\n+  // Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE bases are\n+  // inherited by the type started from -- which is not necessarily the\n+  // current type. The current type will be a base of the destination type.\n+  // OBJ_PTR points to the current base.\n+  virtual sub_kind do_find_public_src (ptrdiff_t src2dst, const void *obj_ptr,\n+                                       const __class_type_info *src_type,\n+                                       const void *src_ptr) const;\n+};\n+\n+// type information for a class with a single non-virtual base\n+class __si_class_type_info : public __class_type_info {\n+protected:\n+  virtual ~__si_class_type_info ();\n+protected:\n+  const __class_type_info *base;    // base type\n+\n+public:\n+  explicit __si_class_type_info (const char *n,\n+                                 int details_,\n+                                 const __class_type_info *base_)\n+    : __class_type_info (n, details_), base (base_)\n+    { }\n+\n+// implementation specific parts\n+protected:\n+  virtual bool do_dyncast (ptrdiff_t src2dst, sub_kind access_path,\n+                           const __class_type_info *dst_type, const void *obj_ptr,\n+                           const __class_type_info *src_type, const void *src_ptr,\n+                           dyncast_result &result) const;\n+  virtual sub_kind do_find_public_src (ptrdiff_t src2dst, const void *obj_ptr,\n+                                       const __class_type_info *src_type,\n+                                       const void *sub_ptr) const;\n+  virtual bool do_upcast (sub_kind access_path,\n+                          const __class_type_info *dst, const void *obj,\n+                          upcast_result &__restrict result) const;\n+};\n+\n+// type information for a class with multiple and/or virtual bases\n+class __vmi_class_type_info : public __class_type_info {\n+protected:\n+  virtual ~__vmi_class_type_info ();\n+protected:\n+  int n_bases;      // number of direct bases\n+  __base_class_info base_list[1]; // array of bases\n+  // The array of bases uses the trailing array struct hack\n+  // so this class is not constructable with a normal constructor. It is\n+  // internally generated by the compiler.\n+\n+public:\n+  explicit __vmi_class_type_info (const char *n,\n+                                  int details_)\n+    : __class_type_info (n, details_), n_bases (0)\n+    { }\n+\n+// implementation specific parts\n+protected:\n+  virtual bool do_dyncast (ptrdiff_t src2dst, sub_kind access_path,\n+                           const __class_type_info *dst_type, const void *obj_ptr,\n+                           const __class_type_info *src_type, const void *src_ptr,\n+                           dyncast_result &result) const;\n+  virtual sub_kind do_find_public_src (ptrdiff_t src2dst, const void *obj_ptr,\n+                                       const __class_type_info *src_type,\n+                                       const void *src_ptr) const;\n+  virtual bool do_upcast (sub_kind access_path,\n+                          const __class_type_info *dst, const void *obj,\n+                          upcast_result &__restrict result) const;\n+};\n+\n+// dynamic cast runtime\n+void *__dynamic_cast (const void *src_ptr,    // object started from\n+                      const __class_type_info *src_type, // static type of object\n+                      const __class_type_info *dst_type, // desired target type\n+                      ptrdiff_t src2dst); // how src and dst are related\n+\n+    // src2dst has the following possible values\n+    // >= 0: src_type is a unique public non-virtual base of dst_type\n+    //       dst_ptr + src2dst == src_ptr\n+    // -1: unspecified relationship\n+    // -2: src_type is not a public base of dst_type\n+    // -3: src_type is a multiple public non-virtual base of dst_type\n+\n+}; // namespace std\n+\n+#endif"}, {"sha": "3f879c2e4b92085221cd4063e58728236e9f2529", "filename": "gcc/cp/tinfo2.cc", "status": "modified", "additions": 268, "deletions": 1, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808c61c8d3802376a4f83c8acecc0de4059a70d7/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=808c61c8d3802376a4f83c8acecc0de4059a70d7", "patch": "@@ -31,6 +31,7 @@\n \n using std::type_info;\n \n+#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n bool\n type_info::before (const type_info &arg) const\n {\n@@ -88,6 +89,248 @@ struct __array_type_info : public type_info {\n   __array_type_info (const char *n): type_info (n) {}\n };\n \n+#else\n+\n+namespace std {\n+  \n+// type information for int, float etc\n+class __fundamental_type_info : public type_info {\n+public:\n+  virtual ~__fundamental_type_info ();\n+public:\n+  explicit __fundamental_type_info (const char *n)\n+    : type_info (n)\n+    { }\n+};\n+\n+// type information for pointer to data or function, but not pointer to member\n+class __pointer_type_info : public type_info {\n+public:\n+  virtual ~__pointer_type_info ();\n+// external parts\n+  int quals;                // qualification of the target object\n+  const type_info *target;  // type of object being pointed to\n+\n+// internal parts\n+  enum quals_masks {\n+    const_mask = 0x1,\n+    volatile_mask = 0x2\n+  };\n+  \n+public:\n+  explicit __pointer_type_info (const char *n,\n+                                int quals_,\n+                                const type_info *target_)\n+    : type_info (n), quals (quals_), target (target_)\n+    { }\n+\n+protected:\n+  virtual bool is_pointer_p () const;\n+  virtual bool do_catch (const type_info *thr_type, void **thr_obj,\n+                         unsigned outer) const;\n+};\n+\n+// type information for reference to data\n+class __reference_type_info : public type_info {\n+public:\n+  virtual ~__reference_type_info ();\n+  int quals;                // qualification of the target object\n+  const type_info *target;  // type of object being referenced\n+\n+// internal parts\n+  enum quals_masks {\n+    const_mask = 0x1,\n+    volatile_mask = 0x2\n+  };\n+  \n+public:\n+  explicit __reference_type_info (const char *n,\n+                                  int quals_,\n+                                  const type_info *target_)\n+    : type_info (n), quals (quals_), target (target_)\n+    { }\n+};\n+\n+// type information for array objects\n+class __array_type_info : public type_info {\n+public:\n+  virtual ~__array_type_info ();\n+public:\n+  explicit __array_type_info (const char *n)\n+    : type_info (n)\n+    { }\n+};\n+\n+// type information for functions (both member and non-member)\n+class __function_type_info : public type_info {\n+public:\n+  virtual ~__function_type_info ();\n+public:\n+  explicit __function_type_info (const char *n)\n+    : type_info (n)\n+    { }\n+protected:\n+  virtual bool is_function_p () const;\n+};\n+\n+// type information for enumerations\n+class __enum_type_info : public type_info {\n+public:\n+  virtual ~__enum_type_info ();\n+public:\n+  explicit __enum_type_info (const char *n)\n+    : type_info (n)\n+    { }\n+};\n+\n+// type information for a pointer to member variable (not function)\n+class __ptr_to_member_type_info : public type_info {\n+public:\n+  virtual ~__ptr_to_member_type_info ();\n+// external parts\n+  const __class_type_info *klass;   // class of the member\n+  const type_info *type;            // type of the member\n+  int quals;                        // qualifications of the pointed to type\n+\n+// internal parts\n+  enum quals_masks {\n+    const_mask = 0x1,\n+    volatile_mask = 0x2\n+  };\n+\n+public:\n+  explicit __ptr_to_member_type_info (const char *n,\n+                                      const __class_type_info *klass_,\n+                                      const type_info *type_,\n+                                      int quals_)\n+    : type_info (n), klass (klass_), type (type_), quals (quals_)\n+    { }\n+\n+protected:\n+  virtual bool do_catch (const type_info *thr_type, void **thr_obj,\n+                         unsigned outer) const;\n+};\n+\n+}; // namespace std\n+\n+#endif\n+\n+#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+namespace std {\n+\n+// This has special meaning to the compiler, and will cause it\n+// to emit the type_info structures for the fundamental types which are\n+// mandated to exist in the runtime.\n+__fundamental_type_info::\n+~__fundamental_type_info ()\n+{}\n+\n+__pointer_type_info::\n+~__pointer_type_info ()\n+{}\n+\n+__reference_type_info::\n+~__reference_type_info ()\n+{}\n+\n+__array_type_info::\n+~__array_type_info ()\n+{}\n+\n+__function_type_info::\n+~__function_type_info ()\n+{}\n+\n+__enum_type_info::\n+~__enum_type_info ()\n+{}\n+\n+__ptr_to_member_type_info::\n+~__ptr_to_member_type_info ()\n+{}\n+\n+bool __pointer_type_info::\n+is_pointer_p () const\n+{\n+  return true;\n+}\n+\n+bool __function_type_info::\n+is_function_p () const\n+{\n+  return true;\n+}\n+\n+bool __pointer_type_info::\n+do_catch (const type_info *thr_type,\n+          void **thr_obj,\n+          unsigned outer) const\n+{\n+  if (*this == *thr_type)\n+    return true;      // same type\n+  if (typeid (*this) != typeid (*thr_type))\n+    return false;     // not both pointers\n+  \n+  if (!(outer & 1))\n+    // We're not the same and our outer pointers are not all const qualified\n+    // Therefore there must at least be a qualification conversion involved\n+    // But for that to be valid, our outer pointers must be const qualified.\n+    return false;\n+  \n+  const __pointer_type_info *thrown_type =\n+    static_cast <const __pointer_type_info *> (thr_type);\n+  \n+  if (thrown_type->quals & ~quals)\n+    // We're less qualified.\n+    return false;\n+  \n+  if (!(quals & const_mask))\n+    outer &= ~1;\n+  \n+  if (outer < 2 && *target == typeid (void))\n+    {\n+      // conversion to void\n+      return !thrown_type->is_function_p ();\n+    }\n+  \n+  return target->do_catch (thrown_type->target, thr_obj, outer + 2);\n+}\n+\n+bool __ptr_to_member_type_info::\n+do_catch (const type_info *thr_type,\n+          void **thr_obj,\n+          unsigned outer) const\n+{\n+  if (*this == *thr_type)\n+    return true;      // same type\n+  if (typeid (*this) != typeid (*thr_type))\n+    return false;     // not both pointers to member\n+  \n+  if (!(outer & 1))\n+    // We're not the same and our outer pointers are not all const qualified\n+    // Therefore there must at least be a qualification conversion involved.\n+    // But for that to be valid, our outer pointers must be const qualified.\n+    return false;\n+  \n+  const __ptr_to_member_type_info *thrown_type =\n+    static_cast <const __ptr_to_member_type_info *> (thr_type);\n+  \n+  if (thrown_type->quals & ~quals)\n+    // We're less qualified.\n+    return false;\n+  \n+  if (!(quals & const_mask))\n+    outer &= ~1;\n+  \n+  if (*klass != *thrown_type->klass)\n+    return false;     // not pointers to member of same class\n+  \n+  return type->do_catch (thrown_type->type, thr_obj, outer + 2);\n+}\n+\n+} // namespace std\n+#endif\n+\n // Entry points for the compiler.\n \n /* Low level match routine used by compiler to match types of catch\n@@ -102,6 +345,8 @@ __throw_type_match_rtti_2 (const void *catch_type_r, const void *throw_type_r,\n \n   *valp = objptr;\n \n+#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n+// old abi\n   if (catch_type == throw_type)\n     return 1;\n   \n@@ -213,10 +458,15 @@ __throw_type_match_rtti_2 (const void *catch_type_r, const void *throw_type_r,\n \t    }\n \t}\n     }\n-\n+#else\n+// new abi\n+  \n+  return catch_type.do_catch (&throw_type, valp, 1);\n+#endif\n   return 0;\n }\n \n+#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n /* Backward compatibility wrapper.  */\n \n extern \"C\" void*\n@@ -228,6 +478,7 @@ __throw_type_match_rtti (const void *catch_type_r, const void *throw_type_r,\n     return ret;\n   return NULL;\n }\n+#endif\n \n /* Called from __cp_pop_exception.  Is P the type_info node for a pointer\n    of some kind?  */\n@@ -236,11 +487,20 @@ bool\n __is_pointer (void *p)\n {\n   const type_info *t = reinterpret_cast <const type_info *>(p);\n+#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n+// old abi\n   const __pointer_type_info *pt =\n     dynamic_cast <const __pointer_type_info *> (t);\n   return pt != 0;\n+#else\n+// new abi\n+  return t->is_pointer_p ();\n+#endif\n }\n \n+#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n+// old abi\n+\n extern \"C\" void\n __rtti_ptr (void *addr, const char *n, const type_info *ti)\n { new (addr) __pointer_type_info (n, *ti); }\n@@ -302,3 +562,10 @@ BUILTIN (v); BUILTIN (x); BUILTIN (l); BUILTIN (i); BUILTIN (s); BUILTIN (b);\n BUILTIN (c); BUILTIN (w); BUILTIN (r); BUILTIN (d); BUILTIN (f);\n BUILTIN (Ui); BUILTIN (Ul); BUILTIN (Ux); BUILTIN (Us); BUILTIN (Uc);\n BUILTIN (Sc);\n+#else\n+// new abi\n+\n+// we need to define the fundamental type type_info's, but the name mangling is\n+// not yet defined.\n+\n+#endif"}]}