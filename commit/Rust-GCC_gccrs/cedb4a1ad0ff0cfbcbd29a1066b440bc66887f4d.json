{"sha": "cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VkYjRhMWFkMGZmMGNmYmNiZDI5YTEwNjZiNDQwYmM2Njg4N2Y0ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-11-07T23:11:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-11-07T23:11:55Z"}, "message": "Allow libcalls to be installed for legacy __sync optabs.\n\nThis allows a target which implements the __sync interfaces\nin libgcc to continue to use them transparently with the\nnew __atomic builtins.\n\nIt is assumed that these libgcc routines DO NOT use spinlocks.\nThis is true of all extant libgcc instances.\n\n        * optabs.h (OTI_sync_compare_and_swap, OTI_sync_lock_test_and_set,\n        OTI_sync_old_add, OTI_sync_old_sub, OTI_sync_old_ior,\n        OTI_sync_old_and, OTI_sync_old_xor, OTI_sync_old_nand,\n        OTI_sync_new_add, OTI_sync_new_sub, OTI_sync_new_ior,\n        OTI_sync_new_and, OTI_sync_new_xor, OTI_sync_new_nand): Move and\n        rename from the direct_optab_index enum.\n        (sync_compare_and_swap_optab, sync_lock_test_and_set_optab,\n        sync_old_add_optab, sync_old_sub_optab, sync_old_ior_optab,\n        sync_old_and_optab, sync_old_xor_optab, sync_old_nand_optab,\n        sync_new_add_optab, sync_new_sub_optab, sync_new_ior_optab,\n        sync_new_and_optab, sync_new_xor_optab, sync_new_nand_optab): Read\n        from the optab_table, not the direct_optab_table.\n        (init_sync_libfuncs): Declare.\n        (can_compare_and_swap_p): Update parameters.\n        * optabs.c (init_sync_libfuncs_1, init_sync_libfuncs): New.\n        (can_compare_and_swap_p): Add allow_libcall parameter; if true,\n        test for the legacy compare-and-swap libcall.\n        (expand_atomic_exchange): Use the legacy test-and-set libcall.\n        (expand_atomic_compare_and_swap): Use the legacy CAS libcall.\n        (struct atomic_op_functions): Update for optab type changes.\n        (maybe_emit_op): Likewise.\n        (expand_atomic_fetch_op): Use the legacy fetch-op libcalls.\n        * builtins.c (fold_builtin_atomic_always_lock_free): Update call\n        to can_compare_and_swap_p.\n        * omp-low.c (expand_omp_atomic_fetch_op): Likewise.\n        (expand_omp_atomic_pipeline): Likewise.\n        * genopinit.c (optabs): Make sync_old_*_optab, sync_new_*_optab,\n        sync_compare_and_swap_optab, sync_lock_test_and_set_optab regular\n        optabs.\n\nFrom-SVN: r181134", "tree": {"sha": "52678eae26470ab300ea093fc393e910585625cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52678eae26470ab300ea093fc393e910585625cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/comments", "author": null, "committer": null, "parents": [{"sha": "13fc31c2c49bbe4ca18bb1bf90007d03ba7ab13b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13fc31c2c49bbe4ca18bb1bf90007d03ba7ab13b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13fc31c2c49bbe4ca18bb1bf90007d03ba7ab13b"}], "stats": {"total": 425, "additions": 298, "deletions": 127}, "files": [{"sha": "cfde0b63175c82c06de089c2303c20fa1a63a38d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "patch": "@@ -1,3 +1,36 @@\n+2011-11-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* optabs.h (OTI_sync_compare_and_swap, OTI_sync_lock_test_and_set,\n+\tOTI_sync_old_add, OTI_sync_old_sub, OTI_sync_old_ior,\n+\tOTI_sync_old_and, OTI_sync_old_xor, OTI_sync_old_nand,\n+\tOTI_sync_new_add, OTI_sync_new_sub, OTI_sync_new_ior,\n+\tOTI_sync_new_and, OTI_sync_new_xor, OTI_sync_new_nand): Move and\n+\trename from the direct_optab_index enum.\n+\t(sync_compare_and_swap_optab, sync_lock_test_and_set_optab,\n+\tsync_old_add_optab, sync_old_sub_optab, sync_old_ior_optab,\n+\tsync_old_and_optab, sync_old_xor_optab, sync_old_nand_optab,\n+\tsync_new_add_optab, sync_new_sub_optab, sync_new_ior_optab,\n+\tsync_new_and_optab, sync_new_xor_optab, sync_new_nand_optab): Read\n+\tfrom the optab_table, not the direct_optab_table.\n+\t(init_sync_libfuncs): Declare.\n+\t(can_compare_and_swap_p): Update parameters.\n+\t* optabs.c (init_sync_libfuncs_1, init_sync_libfuncs): New.\n+\t(can_compare_and_swap_p): Add allow_libcall parameter; if true,\n+\ttest for the legacy compare-and-swap libcall.\n+\t(expand_atomic_exchange): Use the legacy test-and-set libcall.\n+\t(expand_atomic_compare_and_swap): Use the legacy CAS libcall.\n+\t(struct atomic_op_functions): Update for optab type changes.\n+\t(maybe_emit_op): Likewise.\n+\t(expand_atomic_fetch_op): Use the legacy fetch-op libcalls.\n+\t* builtins.c (fold_builtin_atomic_always_lock_free): Update call\n+\tto can_compare_and_swap_p.\n+\t* omp-low.c (expand_omp_atomic_fetch_op): Likewise.\n+\t(expand_omp_atomic_pipeline): Likewise.\n+\t* genopinit.c (optabs): Make sync_old_*_optab, sync_new_*_optab,\n+\tsync_compare_and_swap_optab, sync_lock_test_and_set_optab regular\n+\toptabs.\n+\t* doc/md.texi (sync_compare_and_swap): Update docs for libcalls.\n+\n 2011-11-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386-bultin-types.def (V8SI_FTYPE_V4DF_V4DF): Add."}, {"sha": "516292783bc60786163c61a66f150453939cbeb2", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "patch": "@@ -5512,7 +5512,7 @@ fold_builtin_atomic_always_lock_free (tree arg0, tree arg1)\n   /* Check if a compare_and_swap pattern exists for the mode which represents\n      the required size.  The pattern is not allowed to fail, so the existence\n      of the pattern indicates support is present.  */\n-  if (can_compare_and_swap_p (mode))\n+  if (can_compare_and_swap_p (mode, true))\n     return integer_one_node;\n   else\n     return integer_zero_node;"}, {"sha": "64ad83302f5e3040a467b35f0674d7dfb248f429", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "patch": "@@ -5595,6 +5595,17 @@ be able to take the destination of the @code{MODE_CC} set and pass it\n to the @code{cbranchcc4} or @code{cstorecc4} pattern as the first\n operand of the comparison (the second will be @code{(const_int 0)}).\n \n+For targets where the operating system may provide support for this\n+operation via library calls, the @code{sync_compare_and_swap_optab}\n+may be initialized to a function with the same interface as the\n+@code{__sync_val_compare_and_swap_@var{n}} built-in.  If the entire\n+set of @var{__sync} builtins are supported via library calls, the\n+target can initialize all of the optabs at once with\n+@code{init_sync_libfuncs}.\n+For the purposes of C++11 @code{std::atomic::is_lock_free}, it is\n+assumed that these library calls do @emph{not} use any kind of\n+interruptable locking.\n+\n @cindex @code{sync_add@var{mode}} instruction pattern\n @cindex @code{sync_sub@var{mode}} instruction pattern\n @cindex @code{sync_ior@var{mode}} instruction pattern"}, {"sha": "63c58a8237ab8a4f703c9461d820a9445b144e19", "filename": "gcc/genopinit.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "patch": "@@ -228,20 +228,20 @@ static const char * const optabs[] =\n   \"set_direct_optab_handler (sync_and_optab, $A, CODE_FOR_$(sync_and$I$a$))\",\n   \"set_direct_optab_handler (sync_xor_optab, $A, CODE_FOR_$(sync_xor$I$a$))\",\n   \"set_direct_optab_handler (sync_nand_optab, $A, CODE_FOR_$(sync_nand$I$a$))\",\n-  \"set_direct_optab_handler (sync_old_add_optab, $A, CODE_FOR_$(sync_old_add$I$a$))\",\n-  \"set_direct_optab_handler (sync_old_sub_optab, $A, CODE_FOR_$(sync_old_sub$I$a$))\",\n-  \"set_direct_optab_handler (sync_old_ior_optab, $A, CODE_FOR_$(sync_old_ior$I$a$))\",\n-  \"set_direct_optab_handler (sync_old_and_optab, $A, CODE_FOR_$(sync_old_and$I$a$))\",\n-  \"set_direct_optab_handler (sync_old_xor_optab, $A, CODE_FOR_$(sync_old_xor$I$a$))\",\n-  \"set_direct_optab_handler (sync_old_nand_optab, $A, CODE_FOR_$(sync_old_nand$I$a$))\",\n-  \"set_direct_optab_handler (sync_new_add_optab, $A, CODE_FOR_$(sync_new_add$I$a$))\",\n-  \"set_direct_optab_handler (sync_new_sub_optab, $A, CODE_FOR_$(sync_new_sub$I$a$))\",\n-  \"set_direct_optab_handler (sync_new_ior_optab, $A, CODE_FOR_$(sync_new_ior$I$a$))\",\n-  \"set_direct_optab_handler (sync_new_and_optab, $A, CODE_FOR_$(sync_new_and$I$a$))\",\n-  \"set_direct_optab_handler (sync_new_xor_optab, $A, CODE_FOR_$(sync_new_xor$I$a$))\",\n-  \"set_direct_optab_handler (sync_new_nand_optab, $A, CODE_FOR_$(sync_new_nand$I$a$))\",\n-  \"set_direct_optab_handler (sync_compare_and_swap_optab, $A, CODE_FOR_$(sync_compare_and_swap$I$a$))\",\n-  \"set_direct_optab_handler (sync_lock_test_and_set_optab, $A, CODE_FOR_$(sync_lock_test_and_set$I$a$))\",\n+  \"set_optab_handler (sync_old_add_optab, $A, CODE_FOR_$(sync_old_add$I$a$))\",\n+  \"set_optab_handler (sync_old_sub_optab, $A, CODE_FOR_$(sync_old_sub$I$a$))\",\n+  \"set_optab_handler (sync_old_ior_optab, $A, CODE_FOR_$(sync_old_ior$I$a$))\",\n+  \"set_optab_handler (sync_old_and_optab, $A, CODE_FOR_$(sync_old_and$I$a$))\",\n+  \"set_optab_handler (sync_old_xor_optab, $A, CODE_FOR_$(sync_old_xor$I$a$))\",\n+  \"set_optab_handler (sync_old_nand_optab, $A, CODE_FOR_$(sync_old_nand$I$a$))\",\n+  \"set_optab_handler (sync_new_add_optab, $A, CODE_FOR_$(sync_new_add$I$a$))\",\n+  \"set_optab_handler (sync_new_sub_optab, $A, CODE_FOR_$(sync_new_sub$I$a$))\",\n+  \"set_optab_handler (sync_new_ior_optab, $A, CODE_FOR_$(sync_new_ior$I$a$))\",\n+  \"set_optab_handler (sync_new_and_optab, $A, CODE_FOR_$(sync_new_and$I$a$))\",\n+  \"set_optab_handler (sync_new_xor_optab, $A, CODE_FOR_$(sync_new_xor$I$a$))\",\n+  \"set_optab_handler (sync_new_nand_optab, $A, CODE_FOR_$(sync_new_nand$I$a$))\",\n+  \"set_optab_handler (sync_compare_and_swap_optab, $A, CODE_FOR_$(sync_compare_and_swap$I$a$))\",\n+  \"set_optab_handler (sync_lock_test_and_set_optab, $A, CODE_FOR_$(sync_lock_test_and_set$I$a$))\",\n   \"set_direct_optab_handler (sync_lock_release_optab, $A, CODE_FOR_$(sync_lock_release$I$a$))\",\n   \"set_direct_optab_handler (atomic_exchange_optab, $A, CODE_FOR_$(atomic_exchange$I$a$))\",\n   \"set_direct_optab_handler (atomic_compare_and_swap_optab, $A, CODE_FOR_$(atomic_compare_and_swap$I$a$))\","}, {"sha": "27a44f11f7d40998c9f441918071d4b08e4ea0e0", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "patch": "@@ -1,3 +1,10 @@\n+2011-11-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* builtins.c (compareAndSwapInt_builtin): Use can_compare_and_swap_p.\n+\t(compareAndSwapLong_builtin): Likewise.\n+\t(compareAndSwapObject_builtin): Likewise.\n+\t(VMSupportsCS8_builtin): Likewise.\n+\n 2011-11-02  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* Make-lang.in (jvspec.o): Pass SHLIB instead of SHLIB_LINK."}, {"sha": "66addcbcc081504ea1194d784d249b3721ba556b", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "patch": "@@ -319,9 +319,7 @@ compareAndSwapInt_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \t\t\t   tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (int_type_node);\n-  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n-      != CODE_FOR_nothing\n-      || flag_use_atomic_builtins)\n+  if (can_compare_and_swap_p (mode, flag_use_atomic_builtins))\n     {\n       tree addr, stmt;\n       enum built_in_function fncode = BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_4;\n@@ -342,13 +340,12 @@ compareAndSwapLong_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \t\t\t    tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (long_type_node);\n-  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n-      != CODE_FOR_nothing\n-      || (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (word_mode)\n-\t  && flag_use_atomic_builtins))\n-    /* We don't trust flag_use_atomic_builtins for multi-word\n-       compareAndSwap.  Some machines such as ARM have atomic libfuncs\n-       but not the multi-word versions.  */\n+  /* We don't trust flag_use_atomic_builtins for multi-word compareAndSwap.\n+     Some machines such as ARM have atomic libfuncs but not the multi-word\n+     versions.  */\n+  if (can_compare_and_swap_p (mode,\n+\t\t\t      (flag_use_atomic_builtins\n+\t\t\t       && GET_MODE_SIZE (mode) <= UNITS_PER_WORD)))\n     {\n       tree addr, stmt;\n       enum built_in_function fncode = BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_8;\n@@ -368,9 +365,7 @@ compareAndSwapObject_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \t\t\t      tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (ptr_type_node);\n-  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n-      != CODE_FOR_nothing\n-      || flag_use_atomic_builtins)\n+  if (can_compare_and_swap_p (mode, flag_use_atomic_builtins))\n   {\n     tree addr, stmt;\n     enum built_in_function builtin;\n@@ -448,8 +443,7 @@ VMSupportsCS8_builtin (tree method_return_type,\n {\n   enum machine_mode mode = TYPE_MODE (long_type_node);\n   gcc_assert (method_return_type == boolean_type_node);\n-  if (direct_optab_handler (sync_compare_and_swap_optab, mode)\n-      != CODE_FOR_nothing)\n+  if (can_compare_and_swap_p (mode, false))\n     return boolean_true_node;\n   else\n     return boolean_false_node;"}, {"sha": "81459577937322987992c3209771be4e72cba7dd", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "patch": "@@ -5097,7 +5097,7 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n      matter is that (with the exception of i486 vs i586 and xadd) all targets\n      that support any atomic operaton optab also implements compare-and-swap.\n      Let optabs.c take care of expanding any compare-and-swap loop.  */\n-  if (!can_compare_and_swap_p (imode))\n+  if (!can_compare_and_swap_p (imode, true))\n     return false;\n \n   gsi = gsi_last_bb (load_bb);\n@@ -5168,7 +5168,7 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n   type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (addr)));\n   itype = TREE_TYPE (TREE_TYPE (cmpxchg));\n \n-  if (!can_compare_and_swap_p (TYPE_MODE (itype)))\n+  if (!can_compare_and_swap_p (TYPE_MODE (itype), true))\n     return false;\n \n   /* Load the initial value, replacing the GIMPLE_OMP_ATOMIC_LOAD.  */"}, {"sha": "b2388ec5c743be7efcab347a7d907413b9c61e6d", "filename": "gcc/optabs.c", "status": "modified", "additions": 170, "deletions": 47, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "patch": "@@ -6586,6 +6586,57 @@ init_optabs (void)\n   targetm.init_libfuncs ();\n }\n \n+/* A helper function for init_sync_libfuncs.  Using the basename BASE,\n+   install libfuncs into TAB for BASE_N for 1 <= N <= MAX.  */\n+\n+static void\n+init_sync_libfuncs_1 (optab tab, const char *base, int max)\n+{\n+  enum machine_mode mode;\n+  char buf[64];\n+  size_t len = strlen (base);\n+  int i;\n+\n+  gcc_assert (max <= 8);\n+  gcc_assert (len + 3 < sizeof (buf));\n+\n+  memcpy (buf, base, len);\n+  buf[len] = '_';\n+  buf[len + 1] = '0';\n+  buf[len + 2] = '\\0';\n+\n+  mode = QImode;\n+  for (i = 1; i < max; i *= 2)\n+    {\n+      buf[len + 1] = '0' + i;\n+      set_optab_libfunc (tab, mode, buf);\n+      mode = GET_MODE_2XWIDER_MODE (mode);\n+    }\n+}\n+\n+void\n+init_sync_libfuncs (int max)\n+{\n+  init_sync_libfuncs_1 (sync_compare_and_swap_optab,\n+\t\t\t\"__sync_val_compare_and_swap\", max);\n+  init_sync_libfuncs_1 (sync_lock_test_and_set_optab,\n+\t\t\t\"__sync_lock_test_and_set\", max);\n+\n+  init_sync_libfuncs_1 (sync_old_add_optab, \"__sync_fetch_and_add\", max);\n+  init_sync_libfuncs_1 (sync_old_sub_optab, \"__sync_fetch_and_sub\", max);\n+  init_sync_libfuncs_1 (sync_old_ior_optab, \"__sync_fetch_and_ior\", max);\n+  init_sync_libfuncs_1 (sync_old_and_optab, \"__sync_fetch_and_and\", max);\n+  init_sync_libfuncs_1 (sync_old_xor_optab, \"__sync_fetch_and_xor\", max);\n+  init_sync_libfuncs_1 (sync_old_nand_optab, \"__sync_fetch_and_nand\", max);\n+\n+  init_sync_libfuncs_1 (sync_new_add_optab, \"__sync_add_and_fetch\", max);\n+  init_sync_libfuncs_1 (sync_new_sub_optab, \"__sync_sub_and_fetch\", max);\n+  init_sync_libfuncs_1 (sync_new_ior_optab, \"__sync_ior_and_fetch\", max);\n+  init_sync_libfuncs_1 (sync_new_and_optab, \"__sync_and_and_fetch\", max);\n+  init_sync_libfuncs_1 (sync_new_xor_optab, \"__sync_xor_and_fetch\", max);\n+  init_sync_libfuncs_1 (sync_new_nand_optab, \"__sync_nand_and_fetch\", max);\n+}\n+\n /* Print information about the current contents of the optabs on\n    STDERR.  */\n \n@@ -7165,19 +7216,21 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n /* Return true if there is a compare_and_swap pattern.  */\n \n bool\n-can_compare_and_swap_p (enum machine_mode mode)\n+can_compare_and_swap_p (enum machine_mode mode, bool allow_libcall)\n {\n   enum insn_code icode;\n \n-  /* Check for __sync_compare_and_swap.  */\n-  icode = direct_optab_handler (sync_compare_and_swap_optab, mode);\n-  if (icode != CODE_FOR_nothing)\n-      return true;\n-\n   /* Check for __atomic_compare_and_swap.  */\n   icode = direct_optab_handler (atomic_compare_and_swap_optab, mode);\n   if (icode != CODE_FOR_nothing)\n-      return true;\n+    return true;\n+\n+  /* Check for __sync_compare_and_swap.  */\n+  icode = optab_handler (sync_compare_and_swap_optab, mode);\n+  if (icode != CODE_FOR_nothing)\n+    return true;\n+  if (allow_libcall && optab_libfunc (sync_compare_and_swap_optab, mode))\n+    return true;\n \n   /* No inline compare and swap.  */\n   return false;\n@@ -7266,7 +7319,6 @@ expand_atomic_exchange (rtx target, rtx mem, rtx val, enum memmodel model,\n {\n   enum machine_mode mode = GET_MODE (mem);\n   enum insn_code icode;\n-  rtx last_insn;\n \n   /* If the target supports the exchange directly, great.  */\n   icode = direct_optab_handler (atomic_exchange_optab, mode);\n@@ -7296,33 +7348,53 @@ expand_atomic_exchange (rtx target, rtx mem, rtx val, enum memmodel model,\n \n   if (use_test_and_set)\n     {\n-      icode = direct_optab_handler (sync_lock_test_and_set_optab, mode);\n-      last_insn = get_last_insn ();\n-      if ((icode != CODE_FOR_nothing) && (model == MEMMODEL_SEQ_CST || \n-\t\t\t\t\t  model == MEMMODEL_RELEASE ||\n-\t\t\t\t\t  model == MEMMODEL_ACQ_REL))\n-\texpand_builtin_mem_thread_fence (model);\n+      icode = optab_handler (sync_lock_test_and_set_optab, mode);\n \n       if (icode != CODE_FOR_nothing)\n \t{\n \t  struct expand_operand ops[3];\n+\t  rtx last_insn = get_last_insn ();\n+\n+\t  if (model == MEMMODEL_SEQ_CST\n+\t      || model == MEMMODEL_RELEASE\n+\t      || model == MEMMODEL_ACQ_REL)\n+\t    expand_builtin_mem_thread_fence (model);\n \n \t  create_output_operand (&ops[0], target, mode);\n \t  create_fixed_operand (&ops[1], mem);\n \t  /* VAL may have been promoted to a wider mode.  Shrink it if so.  */\n \t  create_convert_operand_to (&ops[2], val, mode, true);\n \t  if (maybe_expand_insn (icode, 3, ops))\n \t    return ops[0].value;\n+\n+\t  delete_insns_since (last_insn);\n \t}\n \n-      /* Remove any fence that was inserted since a compare and swap loop is\n-\t already a full memory barrier.  */\n-      if (last_insn != get_last_insn ())\n-\tdelete_insns_since (last_insn);\n+      /* If an external test-and-set libcall is provided, use that instead of\n+\t any external compare-and-swap that we might get from the compare-and-\n+\t swap-loop expansion below.  */\n+      if (!can_compare_and_swap_p (mode, false))\n+\t{\n+\t  rtx libfunc = optab_libfunc (sync_lock_test_and_set_optab, mode);\n+\t  if (libfunc != NULL)\n+\t    {\n+\t      rtx addr;\n+\n+\t      if (model == MEMMODEL_SEQ_CST\n+\t\t  || model == MEMMODEL_RELEASE\n+\t\t  || model == MEMMODEL_ACQ_REL)\n+\t\texpand_builtin_mem_thread_fence (model);\n+\n+\t      addr = convert_memory_address (ptr_mode, XEXP (mem, 0));\n+\t      return emit_library_call_value (libfunc, target, LCT_NORMAL,\n+\t\t\t\t\t      mode, 2, addr, ptr_mode,\n+\t\t\t\t\t      val, mode);\n+\t    }\n+\t}\n     }\n \n   /* Otherwise, use a compare-and-swap loop for the exchange.  */\n-  if (can_compare_and_swap_p (mode))\n+  if (can_compare_and_swap_p (mode, true))\n     {\n       if (!target || !register_operand (target, mode))\n \ttarget = gen_reg_rtx (mode);\n@@ -7356,7 +7428,8 @@ expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n   enum machine_mode mode = GET_MODE (mem);\n   struct expand_operand ops[8];\n   enum insn_code icode;\n-  rtx target_bool, target_oval;\n+  rtx target_oval, target_bool = NULL_RTX;\n+  rtx libfunc;\n \n   /* Load expected into a register for the compare and swap.  */\n   if (MEM_P (expected))\n@@ -7400,7 +7473,7 @@ expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n \n   /* Otherwise fall back to the original __sync_val_compare_and_swap\n      which is always seq-cst.  */\n-  icode = direct_optab_handler (sync_compare_and_swap_optab, mode);\n+  icode = optab_handler (sync_compare_and_swap_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n       rtx cc_reg;\n@@ -7413,7 +7486,6 @@ expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n \treturn false;\n \n       target_oval = ops[0].value;\n-      target_bool = NULL_RTX;\n \n       /* If the caller isn't interested in the boolean return value,\n \t skip the computation of it.  */\n@@ -7424,17 +7496,37 @@ expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n       cc_reg = NULL_RTX;\n       if (have_insn_for (COMPARE, CCmode))\n \tnote_stores (PATTERN (get_last_insn ()), find_cc_set, &cc_reg);\n+      if (cc_reg)\n+\t{\n+\t  target_bool = emit_store_flag_force (target_bool, EQ, cc_reg,\n+\t\t\t\t\t       const0_rtx, VOIDmode, 0, 1);\n+\t  goto success;\n+\t}\n+      goto success_bool_from_val;\n+    }\n \n-      target_bool\n-\t= (cc_reg\n-\t   ? emit_store_flag_force (target_bool, EQ, cc_reg,\n-\t\t\t\t    const0_rtx, VOIDmode, 0, 1)\n-\t   : emit_store_flag_force (target_bool, EQ, target_oval,\n-\t\t\t\t    expected, VOIDmode, 1, 1));\n-      goto success;\n+  /* Also check for library support for __sync_val_compare_and_swap.  */\n+  libfunc = optab_libfunc (sync_compare_and_swap_optab, mode);\n+  if (libfunc != NULL)\n+    {\n+      rtx addr = convert_memory_address (ptr_mode, XEXP (mem, 0));\n+      target_oval = emit_library_call_value (libfunc, target_oval, LCT_NORMAL,\n+\t\t\t\t\t     mode, 3, addr, ptr_mode,\n+\t\t\t\t\t     expected, mode, desired, mode);\n+\n+      /* Compute the boolean return value only if requested.  */\n+      if (ptarget_bool)\n+\tgoto success_bool_from_val;\n+      else\n+\tgoto success;\n     }\n+\n+  /* Failure.  */\n   return false;\n \n+ success_bool_from_val:\n+   target_bool = emit_store_flag_force (target_bool, EQ, target_oval,\n+\t\t\t\t\texpected, VOIDmode, 1, 1);\n  success:\n   /* Make sure that the oval output winds up where the caller asked.  */\n   if (ptarget_oval)\n@@ -7570,12 +7662,12 @@ expand_atomic_store (rtx mem, rtx val, enum memmodel model, bool use_release)\n \n struct atomic_op_functions\n {\n-  struct direct_optab_d *mem_fetch_before;\n-  struct direct_optab_d *mem_fetch_after;\n-  struct direct_optab_d *mem_no_result;\n-  struct direct_optab_d *fetch_before;\n-  struct direct_optab_d *fetch_after;\n-  struct direct_optab_d *no_result;\n+  direct_optab mem_fetch_before;\n+  direct_optab mem_fetch_after;\n+  direct_optab mem_no_result;\n+  optab fetch_before;\n+  optab fetch_after;\n+  direct_optab no_result;\n   enum rtx_code reverse_code;\n };\n \n@@ -7666,7 +7758,6 @@ maybe_emit_op (const struct atomic_op_functions *optab, rtx target, rtx mem,\n \t       rtx val, bool use_memmodel, enum memmodel model, bool after)\n {\n   enum machine_mode mode = GET_MODE (mem);\n-  struct direct_optab_d *this_optab;\n   struct expand_operand ops[4];\n   enum insn_code icode;\n   int op_counter = 0;\n@@ -7677,13 +7768,13 @@ maybe_emit_op (const struct atomic_op_functions *optab, rtx target, rtx mem,\n     {\n       if (use_memmodel)\n         {\n-\t  this_optab = optab->mem_no_result;\n+\t  icode = direct_optab_handler (optab->mem_no_result, mode);\n \t  create_integer_operand (&ops[2], model);\n \t  num_ops = 3;\n \t}\n       else\n         {\n-\t  this_optab = optab->no_result;\n+\t  icode = direct_optab_handler (optab->no_result, mode);\n \t  num_ops = 2;\n \t}\n     }\n@@ -7692,19 +7783,19 @@ maybe_emit_op (const struct atomic_op_functions *optab, rtx target, rtx mem,\n     {\n       if (use_memmodel)\n         {\n-\t  this_optab = after ? optab->mem_fetch_after : optab->mem_fetch_before;\n+\t  icode = direct_optab_handler (after ? optab->mem_fetch_after\n+\t\t\t\t\t: optab->mem_fetch_before, mode);\n \t  create_integer_operand (&ops[3], model);\n-\t  num_ops= 4;\n+\t  num_ops = 4;\n \t}\n       else\n \t{\n-\t  this_optab = after ? optab->fetch_after : optab->fetch_before;\n+\t  icode = optab_handler (after ? optab->fetch_after\n+\t\t\t\t : optab->fetch_before, mode);\n \t  num_ops = 3;\n \t}\n       create_output_operand (&ops[op_counter++], target, mode);\n     }\n-\n-  icode = direct_optab_handler (this_optab, mode);\n   if (icode == CODE_FOR_nothing)\n     return NULL_RTX;\n \n@@ -7713,7 +7804,7 @@ maybe_emit_op (const struct atomic_op_functions *optab, rtx target, rtx mem,\n   create_convert_operand_to (&ops[op_counter++], val, mode, true);\n \n   if (maybe_expand_insn (icode, num_ops, ops))\n-    return ((target == const0_rtx) ? const0_rtx : ops[0].value);\n+    return (target == const0_rtx ? const0_rtx : ops[0].value);\n \n   return NULL_RTX;\n } \n@@ -7767,7 +7858,7 @@ expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n \n   /* If the fetch value can be calculated from the other variation of fetch,\n      try that operation.  */\n-  if (after || optab.reverse_code != UNKNOWN || target == const0_rtx) \n+  if (after || unused_result || optab.reverse_code != UNKNOWN)\n     {\n       /* Try the __atomic version, then the older __sync version.  */\n       result = maybe_emit_op (&optab, target, mem, val, true, model, !after);\n@@ -7784,14 +7875,46 @@ expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n \t     Fetch_before == after REVERSE_OP val.  */\n \t  if (!after)\n \t    code = optab.reverse_code;\n-\t  result = expand_simple_binop (mode, code, result, val, NULL_RTX, true,\n+\t  result = expand_simple_binop (mode, code, result, val, target, true,\n \t\t\t\t\tOPTAB_LIB_WIDEN);\n \t  return result;\n \t}\n     }\n \n+  /* Try the __sync libcalls only if we can't do compare-and-swap inline.  */\n+  if (!can_compare_and_swap_p (mode, false))\n+    {\n+      rtx libfunc;\n+      bool fixup = false;\n+\n+      libfunc = optab_libfunc (after ? optab.fetch_after\n+\t\t\t       : optab.fetch_before, mode);\n+      if (libfunc == NULL\n+\t  && (after || unused_result || optab.reverse_code != UNKNOWN))\n+\t{\n+\t  fixup = true;\n+\t  if (!after)\n+\t    code = optab.reverse_code;\n+\t  libfunc = optab_libfunc (after ? optab.fetch_before\n+\t\t\t\t   : optab.fetch_after, mode);\n+\t}\n+      if (libfunc != NULL)\n+\t{\n+\t  rtx addr = convert_memory_address (ptr_mode, XEXP (mem, 0));\n+\t  result = emit_library_call_value (libfunc, NULL, LCT_NORMAL, mode,\n+\t\t\t\t\t    2, addr, ptr_mode, val, mode);\n+\n+\t  if (unused_result)\n+\t    return target;\n+\t  if (fixup)\n+\t    result = expand_simple_binop (mode, code, result, val, target,\n+\t\t\t\t\t  true, OPTAB_LIB_WIDEN);\n+\t  return result;\n+\t}\n+    }\n+\n   /* If nothing else has succeeded, default to a compare and swap loop.  */\n-  if (can_compare_and_swap_p (mode))\n+  if (can_compare_and_swap_p (mode, true))\n     {\n       rtx insn;\n       rtx t0 = gen_reg_rtx (mode), t1;"}, {"sha": "bc705dceb61f327c994e4ebd46eef59c0fc18300", "filename": "gcc/optabs.h", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=cedb4a1ad0ff0cfbcbd29a1066b440bc66887f4d", "patch": "@@ -386,6 +386,30 @@ enum optab_index\n   /* Perform a raise to the power of integer.  */\n   OTI_powi,\n \n+  /* Atomic compare and swap.  */\n+  OTI_sync_compare_and_swap,\n+\n+  /* Atomic exchange with acquire semantics.  */\n+  OTI_sync_lock_test_and_set,\n+\n+  /* This second set is atomic operations in which we return the value\n+     that existed in memory before the operation.  */\n+  OTI_sync_old_add,\n+  OTI_sync_old_sub,\n+  OTI_sync_old_ior,\n+  OTI_sync_old_and,\n+  OTI_sync_old_xor,\n+  OTI_sync_old_nand,\n+\n+  /* This third set is atomic operations in which we return the value\n+     that resulted after performing the operation.  */\n+  OTI_sync_new_add,\n+  OTI_sync_new_sub,\n+  OTI_sync_new_ior,\n+  OTI_sync_new_and,\n+  OTI_sync_new_xor,\n+  OTI_sync_new_nand,\n+\n   OTI_MAX\n };\n \n@@ -570,6 +594,23 @@ enum optab_index\n \n #define powi_optab (&optab_table[OTI_powi])\n \n+#define sync_compare_and_swap_optab \\\n+  (&optab_table[(int) OTI_sync_compare_and_swap])\n+#define sync_lock_test_and_set_optab \\\n+  (&optab_table[(int) OTI_sync_lock_test_and_set])\n+#define sync_old_add_optab (&optab_table[(int) OTI_sync_old_add])\n+#define sync_old_sub_optab (&optab_table[(int) OTI_sync_old_sub])\n+#define sync_old_ior_optab (&optab_table[(int) OTI_sync_old_ior])\n+#define sync_old_and_optab (&optab_table[(int) OTI_sync_old_and])\n+#define sync_old_xor_optab (&optab_table[(int) OTI_sync_old_xor])\n+#define sync_old_nand_optab (&optab_table[(int) OTI_sync_old_nand])\n+#define sync_new_add_optab (&optab_table[(int) OTI_sync_new_add])\n+#define sync_new_sub_optab (&optab_table[(int) OTI_sync_new_sub])\n+#define sync_new_ior_optab (&optab_table[(int) OTI_sync_new_ior])\n+#define sync_new_and_optab (&optab_table[(int) OTI_sync_new_and])\n+#define sync_new_xor_optab (&optab_table[(int) OTI_sync_new_xor])\n+#define sync_new_nand_optab (&optab_table[(int) OTI_sync_new_nand])\n+\n /* Conversion optabs have their own table and indexes.  */\n enum convert_optab_index\n {\n@@ -659,42 +700,17 @@ enum direct_optab_index\n   DOI_cmpstrn,\n   DOI_cmpmem,\n \n-  /* Synchronization primitives.  This first set is atomic operation for\n-     which we don't care about the resulting value.  */\n+  /* Atomic clear with release semantics.  */\n+  DOI_sync_lock_release,\n+\n+  /* Atomic operation with no resulting value.  */\n   DOI_sync_add,\n   DOI_sync_sub,\n   DOI_sync_ior,\n   DOI_sync_and,\n   DOI_sync_xor,\n   DOI_sync_nand,\n \n-  /* This second set is atomic operations in which we return the value\n-     that existed in memory before the operation.  */\n-  DOI_sync_old_add,\n-  DOI_sync_old_sub,\n-  DOI_sync_old_ior,\n-  DOI_sync_old_and,\n-  DOI_sync_old_xor,\n-  DOI_sync_old_nand,\n-\n-  /* This third set is atomic operations in which we return the value\n-     that resulted after performing the operation.  */\n-  DOI_sync_new_add,\n-  DOI_sync_new_sub,\n-  DOI_sync_new_ior,\n-  DOI_sync_new_and,\n-  DOI_sync_new_xor,\n-  DOI_sync_new_nand,\n-\n-  /* Atomic compare and swap.  */\n-  DOI_sync_compare_and_swap,\n-\n-  /* Atomic exchange with acquire semantics.  */\n-  DOI_sync_lock_test_and_set,\n-\n-  /* Atomic clear with release semantics.  */\n-  DOI_sync_lock_release,\n-\n   /* Atomic operations with memory model parameters. */\n   DOI_atomic_exchange,\n   DOI_atomic_compare_and_swap,\n@@ -748,30 +764,14 @@ typedef struct direct_optab_d *direct_optab;\n #define cmpstr_optab (&direct_optab_table[(int) DOI_cmpstr])\n #define cmpstrn_optab (&direct_optab_table[(int) DOI_cmpstrn])\n #define cmpmem_optab (&direct_optab_table[(int) DOI_cmpmem])\n+#define sync_lock_release_optab \\\n+  (&direct_optab_table[(int) DOI_sync_lock_release])\n #define sync_add_optab (&direct_optab_table[(int) DOI_sync_add])\n #define sync_sub_optab (&direct_optab_table[(int) DOI_sync_sub])\n #define sync_ior_optab (&direct_optab_table[(int) DOI_sync_ior])\n #define sync_and_optab (&direct_optab_table[(int) DOI_sync_and])\n #define sync_xor_optab (&direct_optab_table[(int) DOI_sync_xor])\n #define sync_nand_optab (&direct_optab_table[(int) DOI_sync_nand])\n-#define sync_old_add_optab (&direct_optab_table[(int) DOI_sync_old_add])\n-#define sync_old_sub_optab (&direct_optab_table[(int) DOI_sync_old_sub])\n-#define sync_old_ior_optab (&direct_optab_table[(int) DOI_sync_old_ior])\n-#define sync_old_and_optab (&direct_optab_table[(int) DOI_sync_old_and])\n-#define sync_old_xor_optab (&direct_optab_table[(int) DOI_sync_old_xor])\n-#define sync_old_nand_optab (&direct_optab_table[(int) DOI_sync_old_nand])\n-#define sync_new_add_optab (&direct_optab_table[(int) DOI_sync_new_add])\n-#define sync_new_sub_optab (&direct_optab_table[(int) DOI_sync_new_sub])\n-#define sync_new_ior_optab (&direct_optab_table[(int) DOI_sync_new_ior])\n-#define sync_new_and_optab (&direct_optab_table[(int) DOI_sync_new_and])\n-#define sync_new_xor_optab (&direct_optab_table[(int) DOI_sync_new_xor])\n-#define sync_new_nand_optab (&direct_optab_table[(int) DOI_sync_new_nand])\n-#define sync_compare_and_swap_optab \\\n-  (&direct_optab_table[(int) DOI_sync_compare_and_swap])\n-#define sync_lock_test_and_set_optab \\\n-  (&direct_optab_table[(int) DOI_sync_lock_test_and_set])\n-#define sync_lock_release_optab \\\n-  (&direct_optab_table[(int) DOI_sync_lock_release])\n \n #define atomic_exchange_optab \\\n   (&direct_optab_table[(int) DOI_atomic_exchange])\n@@ -956,6 +956,9 @@ extern void set_optab_libfunc (optab, enum machine_mode, const char *);\n extern void set_conv_libfunc (convert_optab, enum machine_mode,\n \t\t\t      enum machine_mode, const char *);\n \n+/* Call this to install all of the __sync libcalls up to size MAX.  */\n+extern void init_sync_libfuncs (int max);\n+\n /* Generate code for a FIXED_CONVERT_EXPR.  */\n extern void expand_fixed_convert (rtx, rtx, int, int);\n \n@@ -966,7 +969,7 @@ extern void expand_float (rtx, rtx, int);\n enum insn_code can_float_p (enum machine_mode, enum machine_mode, int);\n \n /* Return true if there is an inline compare and swap pattern.  */\n-extern bool can_compare_and_swap_p (enum machine_mode);\n+extern bool can_compare_and_swap_p (enum machine_mode, bool);\n \n /* Generate code for a compare and swap.  */\n extern bool expand_atomic_compare_and_swap (rtx *, rtx *, rtx, rtx, rtx, bool,"}]}