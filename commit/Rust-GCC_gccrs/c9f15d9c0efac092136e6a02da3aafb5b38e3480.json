{"sha": "c9f15d9c0efac092136e6a02da3aafb5b38e3480", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlmMTVkOWMwZWZhYzA5MjEzNmU2YTAyZGEzYWFmYjViMzhlMzQ4MA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-03-01T06:04:45Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-03-01T06:04:45Z"}, "message": "re PR libfortran/26136 (List directed input with underfilled  (logicals) array read incorrectly)\n\n2006-02-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/26136\n\t* io/io.h: Add flag for reading from line_buffer.\n\t* io/list_read.c (l_push_char): New function to save namelist\n\tinput when reading logicals.\n\t(free_line): New function to free line_buffer memory.\n\t(next_char): Added feature to read from line_buffer.\n\t(read_logical): Use new functions to test for '=' after reading a\n\tlogical value, checking for possible variable name.\n\t(namelist_read): Use free_line when all done.\n\nFrom-SVN: r111597", "tree": {"sha": "f3786ec80f1921a30a225e9c53e69b461495199e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3786ec80f1921a30a225e9c53e69b461495199e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9f15d9c0efac092136e6a02da3aafb5b38e3480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f15d9c0efac092136e6a02da3aafb5b38e3480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f15d9c0efac092136e6a02da3aafb5b38e3480", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f15d9c0efac092136e6a02da3aafb5b38e3480/comments", "author": null, "committer": null, "parents": [{"sha": "ec09c26e3a5bbfe7536746c99e826417b2bf4bfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec09c26e3a5bbfe7536746c99e826417b2bf4bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec09c26e3a5bbfe7536746c99e826417b2bf4bfe"}], "stats": {"total": 154, "additions": 134, "deletions": 20}, "files": [{"sha": "39039a66e9b0cb65d7ceeb0b9a9185a17df35a34", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f15d9c0efac092136e6a02da3aafb5b38e3480/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f15d9c0efac092136e6a02da3aafb5b38e3480/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=c9f15d9c0efac092136e6a02da3aafb5b38e3480", "patch": "@@ -1,3 +1,15 @@\n+2006-02-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/26136\n+\t* io/io.h: Add flag for reading from line_buffer.\n+\t* io/list_read.c (l_push_char): New function to save namelist\n+\tinput when reading logicals.\n+\t(free_line): New function to free line_buffer memory.\n+\t(next_char): Added feature to read from line_buffer.\n+\t(read_logical): Use new functions to test for '=' after reading a\n+\tlogical value, checking for possible variable name.\n+\t(namelist_read): Use free_line when all done.\n+\n 2006-02-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/26464"}, {"sha": "e36debbbaeebae640efdc4e5ea1c54ef8a3695d1", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f15d9c0efac092136e6a02da3aafb5b38e3480/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f15d9c0efac092136e6a02da3aafb5b38e3480/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=c9f15d9c0efac092136e6a02da3aafb5b38e3480", "patch": "@@ -371,7 +371,9 @@ typedef struct st_parameter_dt\n \t  void (*transfer) (struct st_parameter_dt *, bt, void *, int,\n \t\t\t    size_t, size_t);\n \t  struct gfc_unit *current_unit;\n-\t  int item_count; /* Item number in a formatted data transfer.  */\n+\t  /* Item number in a formatted data transfer.  Also used in namelist\n+\t       read_logical as an index into line_buffer.  */\n+\t  int item_count;\n \t  unit_mode mode;\n \t  unit_blank blank_status;\n \t  enum {SIGN_S, SIGN_SS, SIGN_SP} sign_status;\n@@ -409,7 +411,10 @@ typedef struct st_parameter_dt\n \t     character string is being read so don't use commas to shorten a\n \t     formatted field width.  */\n \t  unsigned sf_read_comma : 1;\n-\t  /* 19 unused bits.  */\n+          /* A namelist specific flag used to enable reading input from \n+\t       line_buffer for logical reads.  */\n+\t  unsigned line_buffer_enabled : 1;\n+\t  /* 18 unused bits.  */\n \n \t  char last_char;\n \t  char nml_delim;"}, {"sha": "5ff4cbbc299d2be4d6d7c9acbdb41777cbf076b0", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 115, "deletions": 18, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f15d9c0efac092136e6a02da3aafb5b38e3480/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f15d9c0efac092136e6a02da3aafb5b38e3480/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=c9f15d9c0efac092136e6a02da3aafb5b38e3480", "patch": "@@ -117,6 +117,19 @@ free_saved (st_parameter_dt *dtp)\n }\n \n \n+/* Free the line buffer if necessary.  */\n+\n+static void\n+free_line (st_parameter_dt *dtp)\n+{\n+  if (dtp->u.p.line_buffer == NULL)\n+    return;\n+\n+  free_mem (dtp->u.p.line_buffer);\n+  dtp->u.p.line_buffer = NULL;\n+}\n+\n+\n static char\n next_char (st_parameter_dt *dtp)\n {\n@@ -132,7 +145,23 @@ next_char (st_parameter_dt *dtp)\n       goto done;\n     }\n \n-  length = 1;\n+  /* Read from line_buffer if enabled.  */\n+\n+  if (dtp->u.p.line_buffer_enabled)\n+    {\n+      dtp->u.p.at_eol = 0;\n+\n+      c = dtp->u.p.line_buffer[dtp->u.p.item_count];\n+      if (c != '\\0' && dtp->u.p.item_count < 64)\n+\t{\n+\t  dtp->u.p.line_buffer[dtp->u.p.item_count] = '\\0';\n+\t  dtp->u.p.item_count++;\n+\t  goto done;\n+\t}\n+\n+        dtp->u.p.item_count = 0;\n+\tdtp->u.p.line_buffer_enabled = 0;\n+    }    \n \n   /* Handle the end-of-record condition for internal array unit */\n   if (is_array_io(dtp) && dtp->u.p.current_unit->bytes_left == 0)\n@@ -154,6 +183,9 @@ next_char (st_parameter_dt *dtp)\n     }\n \n   /* Get the next character and handle end-of-record conditions */\n+\n+  length = 1;\n+\n   p = salloc_r (dtp->u.p.current_unit->s, &length);\n \n   if (is_internal_unit(dtp))\n@@ -510,43 +542,73 @@ parse_repeat (st_parameter_dt *dtp)\n }\n \n \n+/* To read a logical we have to look ahead in the input stream to make sure\n+    there is not an equal sign indicating a variable name.  To do this we use \n+    line_buffer to point to a temporary buffer, pushing characters there for\n+    possible later reading. */\n+\n+static void\n+l_push_char (st_parameter_dt *dtp, char c)\n+{\n+  char *new;\n+\n+  if (dtp->u.p.line_buffer == NULL)\n+    {\n+      dtp->u.p.line_buffer = get_mem (SCRATCH_SIZE);\n+      memset (dtp->u.p.line_buffer, 0, SCRATCH_SIZE);\n+    }\n+\n+  dtp->u.p.line_buffer[dtp->u.p.item_count++] = c;\n+}\n+\n+\n /* Read a logical character on the input.  */\n \n static void\n read_logical (st_parameter_dt *dtp, int length)\n {\n   char c, message[100];\n-  int v;\n+  int i, v;\n \n   if (parse_repeat (dtp))\n     return;\n \n-  c = next_char (dtp);\n+  c = tolower (next_char (dtp));\n+  l_push_char (dtp, c);\n   switch (c)\n     {\n     case 't':\n-    case 'T':\n       v = 1;\n+      c = next_char (dtp);\n+      l_push_char (dtp, c);\n+\n+      if (!is_separator(c))\n+\tgoto possible_name;\n+\n+      unget_char (dtp, c);\n       break;\n     case 'f':\n-    case 'F':\n       v = 0;\n-      break;\n+      c = next_char (dtp);\n+      l_push_char (dtp, c);\n \n+      if (!is_separator(c))\n+\tgoto possible_name;\n+\n+      unget_char (dtp, c);\n+      break;\n     case '.':\n-      c = next_char (dtp);\n+      c = tolower (next_char (dtp));\n       switch (c)\n \t{\n-\tcase 't':\n-\tcase 'T':\n-\t  v = 1;\n-\t  break;\n-\tcase 'f':\n-\tcase 'F':\n-\t  v = 0;\n-\t  break;\n-\tdefault:\n-\t  goto bad_logical;\n+\t  case 't':\n+\t    v = 1;\n+\t    break;\n+\t  case 'f':\n+\t    v = 0;\n+\t    break;\n+\t  default:\n+\t    goto bad_logical;\n \t}\n \n       break;\n@@ -572,11 +634,44 @@ read_logical (st_parameter_dt *dtp, int length)\n \n   unget_char (dtp, c);\n   eat_separator (dtp);\n-  free_saved (dtp);\n+  dtp->u.p.item_count = 0;\n+  dtp->u.p.line_buffer_enabled = 0;\n   set_integer ((int *) dtp->u.p.value, v, length);\n \n   return;\n \n+ possible_name:\n+\n+  for(i = 0; i < 63; i++)\n+    {\n+      c = next_char (dtp);\n+      if (is_separator(c))\n+\t{\n+\t  unget_char (dtp, c);\n+\t  eat_separator (dtp);\n+\t  c = next_char (dtp);\n+\t  if (c != '=')\n+\t    {\n+\t      unget_char (dtp, c);\n+\t      dtp->u.p.item_count = 0;\n+\t      dtp->u.p.line_buffer_enabled = 0;\n+\t      dtp->u.p.saved_type = BT_LOGICAL;\n+\t      dtp->u.p.saved_length = length;\n+\t      set_integer ((int *) dtp->u.p.value, v, length);\n+\t      return;\n+\t    }\n+\t}\n+ \n+      l_push_char (dtp, c);\n+      if (c == '=')\n+\t{\n+\t  dtp->u.p.nml_read_error = 1;\n+\t  dtp->u.p.line_buffer_enabled = 1;\n+\t  dtp->u.p.item_count = 0;\n+\t  return;\n+\t}\n+     }\n+\n  bad_logical:\n \n   if (nml_bad_return (dtp, c))\n@@ -2435,6 +2530,7 @@ namelist_read (st_parameter_dt *dtp)\n \n   dtp->u.p.eof_jump = NULL;\n   free_saved (dtp);\n+  free_line (dtp);\n   return;\n \n   /* All namelist error calls return from here */\n@@ -2443,6 +2539,7 @@ namelist_read (st_parameter_dt *dtp)\n \n   dtp->u.p.eof_jump = NULL;\n   free_saved (dtp);\n+  free_line (dtp);\n   generate_error (&dtp->common, ERROR_READ_VALUE, nml_err_msg);\n   return;\n }"}]}