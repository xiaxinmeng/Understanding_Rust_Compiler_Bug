{"sha": "a9429e29f506f5b8c28b28ab387fc2d261a4220c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk0MjllMjlmNTA2ZjViOGMyOGIyOGFiMzg3ZmMyZDI2MWE0MjIwYw==", "commit": {"author": {"name": "Laurynas Biveinis", "email": "laurynas.biveinis@gmail.com", "date": "2010-06-08T07:25:24Z"}, "committer": {"name": "Laurynas Biveinis", "email": "lauras@gcc.gnu.org", "date": "2010-06-08T07:25:24Z"}, "message": "utils.c (init_gnat_to_gnu): Use typed GC allocation.\n\ngcc/ada:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* gcc-interface/utils.c (init_gnat_to_gnu): Use typed GC\n\tallocation.\n\t(init_dummy_type): Likewise.\n\t(gnat_pushlevel): Likewise.\n\n\t* gcc-interface/trans.c (Attribute_to_gnu): Likewise.\n\t(Subprogram_Body_to_gnu): Likewise.\n\t(Compilation_Unit_to_gnu): Likewise.\n\t(start_stmt_group): Likewise.\n\t(extract_encoding): Likewise.\n\t(decode_name): Likewise.\n\n\t* gcc-interface/misc.c (gnat_printable_name): Likewise.\n\n\t* gcc-interface/decl.c (annotate_value): Likewise.\n\n\t* gcc-interface/ada-tree.h (struct lang_type): Add variable_size\n\tGTY option.\n\t(struct lang_decl): Likewise.\n\t(SET_TYPE_LANG_SPECIFIC): Use typed GC allocation.\n\t(SET_DECL_LANG_SPECIFIC): Likewise.\n\ngcc/c-family:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* c-pragma.c (push_alignment): Use typed GC allocation.\n\t(handle_pragma_push_options): Likewise.\n\n\t* c-common.c (parse_optimize_options): Likewise.\n\n\t* c-common.h (struct sorted_fields_type): Add variable_size GTY\n\toption.\n\ngcc/cp:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* typeck2.c (abstract_virtuals_error): Likewise.\n\n\t* pt.c (maybe_process_partial_specialization): Likewise.\n\t(register_specialization): Likewise.\n\t(add_pending_template): Likewise.\n\t(lookup_template_class): Likewise.\n\t(push_tinst_level): Likewise.\n\n\t* parser.c (cp_lexer_new_main): Likewise.\n\t(cp_lexer_new_from_tokens): Likewise.\n\t(cp_token_cache_new): Likewise.\n\t(cp_parser_context_new): Likewise.\n\t(cp_parser_new): Likewise.\n\t(cp_parser_nested_name_specifier_opt): Likewise.\n\t(cp_parser_template_id): Likewise.\n\n\t* name-lookup.c (binding_entry_make): Likewise.\n\t(binding_table_construct): Likewise.\n\t(binding_table_new): Likewise.\n\t(cxx_binding_make): Likewise.\n\t(pushdecl_maybe_friend): Likewise.\n\t(begin_scope): Likewise.\n\t(push_to_top_level): Likewise.\n\n\t* lex.c (init_reswords): Likewise.\n\t(retrofit_lang_decl): Likewise.\n\t(cxx_dup_lang_specific_decl): Likewise.\n\t(copy_lang_type): Likewise.\n\t(cxx_make_type): Likewise.\n\n\t* decl.c (make_label_decl): Likewise.\n\t(check_goto): Likewise.\n\t(start_preparsed_function): Likewise.\n\t(save_function_data): Likewise.\n\n\t* cp-tree.h (TYPE_SET_PTRMEMFUNC_TYPE): Likewise.\n\n\t* cp-objcp-common.c (decl_shadowed_for_var_insert): Likewise.\n\n\t* class.c (finish_struct_1): Likewise.\n\n\t* cp-tree.h (struct lang_type): Add variable_size GTY option.\n\t(struct lang_decl): Likewise.\n\n\t* parser.c (cp_parser_new): Update comment to not reference\n\tggc_alloc.\n\ngcc/fortran:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* trans-types.c (gfc_get_nodesc_array_type): Use typed GC\n\tallocation.\n\t(gfc_get_array_type_bounds): Likewise.\n\n\t* trans-decl.c (gfc_allocate_lang_decl): Likewise.\n\t(gfc_find_module): Likewise.\n\n\t* f95-lang.c (pushlevel): Likewise.\n\n\t* trans.h (struct lang_type): Add variable_size GTY option.\n\t(struct lang_decl): Likewise.\n\ngcc/java:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* jcf-reader.c (jcf_parse_constant_pool): Use typed GC allocation.\n\n\t* jcf-parse.c (java_parse_file): Likewise.\n\t(process_zip_dir): Likewise.\n\n\t* java-tree.h (MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC): Likewise.\n\t(MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC): Likewise.\n\n\t* expr.c (add_type_assertion): Likewise.\n\n\t* decl.c (make_binding_level): Likewise.\n\t(java_dup_lang_specific_decl): Likewise.\n\n\t* constants.c (set_constant_entry): Likewise.\n\t(cpool_for_class): Likewise.\n\n\t* class.c (add_method_1): Likewise.\n\t(java_treetreehash_new): Likewise.\n\n\t* java-tree.h (struct lang_type): Add variable_size GTY option.\n\t(struct lang_decl): Likewise.\n\n\t* jch.h (struct cpool_entry): Likewise.\n\n\t* java-tree.h (java_treetreehash_create): Remove parameter ggc.\n\n\t* except.c (prepare_eh_table_type): Update\n\tjava_treetreehash_create call.\n\n\t* class.c (add_method_1): Update java_treetreehash_create call.\n\t(java_treetreehash_create): Remove parameter gc.  Use\n\thtab_create_ggc.\n\ngcc/lto:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* lto.c (lto_read_in_decl_state): Use typed GC allocation.\n\t(lto_file_read): Likewise.\n\t(new_partition): Likewise.\n\t(read_cgraph_and_symbols): Likewise.\n\ngcc/objc:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* objc-act.h (ALLOC_OBJC_TYPE_LANG_SPECIFIC): Use typed GC\n\tallocation.\n\n\t* objc-act.c (objc_volatilize_decl): Likewise.\n\t(objc_build_string_object): Likewise.\n\t(hash_init): Likewise.\n\t(hash_enter): Likewise.\n\t(hash_add_attr): Likewise.\n\t(add_class): Likewise.\n\t(start_class): Likewise.\n\ngcc/objcp:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* objcp-decl.h (ALLOC_OBJC_TYPE_LANG_SPECIFIC): Use typed GC\n\tallocation.\n\ngcc:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* doc/tm.texi (Per-Function Data): Do not reference ggc_alloc.\n\n\t* doc/gty.texi (GTY Options): Document typed GC allocation and\n\tvariable_size GTY option.\n\n\t* ggc-internal.h: New.\n\n\t* ggc.h: Update copyright year.\n\t(digit_string): Move to stringpool.c.\n\t(ggc_mark_stringpool, ggc_purge_stringpool, ggc_mark_roots)\n\t(gt_pch_save_stringpool, gt_pch_fixup_stringpool)\n\t(gt_pach_restore_stringpool, gt_pch_p_S, gt_pch_note_object)\n\t(init_ggc_pch, ggc_pch_count_object, ggc_pch_total_size)\n\t(ggc_pch_this_base, ggc_pch_alloc_object, ggc_pch_prepare_write)\n\t(ggc_pch_write_object, ggc_pch_finish, ggc_pch_read)\n\t(ggc_force_collect, ggc_get_size, ggc_statistics)\n\t(ggc_print_common_statistics): Move to ggc-internal.h.\n\t(digit_vector, new_ggc_zone, destroy_ggc_zone, ggc_alloc_stat)\n\t(ggc_alloc, ggc_alloc_cleared, ggc_realloc, ggc_calloc, GGC_NEW)\n\t(GGC_CNEW, GGC_NEWVEC, GGC_CNEWVEC, GGC_NEWVAR, ggc_alloc_rtvec)\n\t(ggc_alloc_tree, gt_pch_save, ggc_min_expand_heuristic)\n\t(ggc_min_heapsize_heuristic, ggc_alloc_zone)\n\t(ggc_alloc_zone_pass_stat): Remove.\n\t(ggc_internal_alloc_stat, ggc_internal_alloc)\n\t(ggc_internal_cleared_alloc_stat): New.\n\t(GGC_RESIZEVEC, GGC_RESIZEVAR): Redefine.\n\t(ggc_internal_vec_alloc_stat)\n\t(ggc_internal_cleared_vec_alloc_stat)\n\t(ggc_internal_vec_alloc_stat, ggc_internal_cleared_vec_alloc)\n\t(ggc_alloc_atomic_stat, ggc_alloc_atomic)\n\t(ggc_alloc_cleared_atomic, ggc_cleared_alloc_htab_ignore_args)\n\t(ggc_cleared_alloc_ptr_array_two_args): New.\n\t(htab_create_ggc, splay_tree_new_ggc): Redefine.\n\t(ggc_splay_alloc): Change the type of the first argument to\n\tenum gt_types_enum.\n\t(ggc_alloc_string): Make macro.\n\t(ggc_alloc_string_stat): New.\n\t(ggc_strdup): Redefine.\n\t(rtl_zone, tree_zone, tree_id_zone): Declare unconditionally.\n\t(ggc_alloc_rtvec_sized): New.\n\t(ggc_alloc_zone_stat): Rename to ggc_internal_alloc_zone_stat.\n\t(ggc_internal_alloc_zone_pass_stat, ggc_internal_alloc_zone_stat)\n\t(ggc_internal_cleared_alloc_zone_stat)\n\t(ggc_internal_zone_alloc_stat)\n\t(ggc_internal_zone_cleared_alloc_stat)\n\t(ggc_internal_zone_vec_alloc_stat)\n\t(ggc_alloc_zone_rtx_def_stat)\n\t(ggc_alloc_zone_tree_node_stat)\n\t(ggc_alloc_zone_cleared_tree_node_stat)\n\t(ggc_alloc_cleared_gimple_statement_d_stat): New.\n\n\t* ggc-common.c: Include ggc-internal.h.\n\t(ggc_internal_cleared_alloc_stat): Rename from\n\tggc_alloc_cleared_stat.\n\t(ggc_realloc_stat): Use ggc_internal_alloc_stat.\n\t(ggc_calloc): Remove.\n\t(ggc_cleared_alloc_htab_ignore_args): New.\n\t(ggc_cleared_alloc_ptr_array_two_args): New.\n\t(ggc_splay_alloc): Add obj_type parameter.\n\t(init_ggc_heuristics): Formatting fixes.\n\n\t* ggc-none.c: Update copyright year.\n\t(ggc_alloc_stat): Rename to ggc_alloc_stat.\n\t(ggc_alloc_cleared_stat): Rename to\n\tggc_internal_cleared_alloc_stat.\n\t(struct alloc_zone, rtl_zone, tree_zone, tree_id_zone): New.\n\n\t* ggc-page.c: Update copyright year.  Include ggc-internal.h.\n\tRemove references to ggc_alloc in comments.\n\t(ggc_alloc_typed_stat): Call ggc_internal_alloc_stat.\n\t(ggc_alloc_stat): Rename to ggc_internal_alloc_stat.\n\t(new_ggc_zone, destroy_ggc_zone): Remove.\n\t(struct alloc_zone, rtl_zone, tree_zone, tree_id_zone): New.\n\n\t* ggc-zone.c: Include ggc-internal.h.  Remove references to\n\tggc_alloc in comments.\n\t(ggc_alloc_zone_stat): ggc_internal_alloc_zone_stat.\n\t(ggc_internal_alloc_zone_pass_stat): New.\n\t(ggc_internal_cleared_alloc_zone_stat): New.\n\t(ggc_alloc_typed_stat): Use ggc_internal_alloc_zone_pass_stat.\n\t(ggc_alloc_stat): Rename ggc_internal_alloc_stat.\n\t(new_ggc_zone, destroy_ggc_zone): Remove.\n\n\t* stringpool.c: Update copyright year.  Include ggc-internal.h\n\t(digit_vector): Make static.\n\t(digit_string): Moved from ggc.h.\n\t(stringpool_ggc_alloc): Use ggc_alloc_atomic.\n\t(ggc_alloc_string): Rename to ggc_alloc_string_stat.\n\n\t* Makefile.in (GGC_INTERNAL_H): New.\n\t(ggc_common.o, ggc-page.o, ggc-zone.o, stringpool.o): Add\n\t$(GGC_INTERNAL_H) to dependencies.\n\n\t* gentype.c: Update copyright year.\n\t(walk_type): Accept variable_size GTY option.\n\t(USED_BY_TYPED_GC_P): New macro.\n\t(write_enum_defn): Use USED_BY_TYPED_GC_P.  Do not output\n\twhitespace at the end of strings.\n\t(get_type_specifier, variable_size_p): New functions.\n\t(alloc_quantity, alloc_zone): New enums.\n\t(write_typed_alloc_def): New function.\n\t(write_typed_struct_alloc_def): Likewise.\n\t(write_typed_typed_typedef_alloc_def): Likewise.\n\t(write_typed_alloc_defns): Likewise.\n\t(output_typename, write_splay_tree_allocator_def): Likewise.\n\t(write_splay_tree_allocators): Likewise.\n\t(main): Call write_typed_alloc_defns and\n\twrite_splay_tree_allocators.\n\n\t* lto-streamer.h (lto_file_decl_data_ptr): New.\n\n\t* passes.c (order): Define using cgraph_node_ptr.\n\n\t* strinpool.c (struct string_pool_data): Declare nested_ptr using\n\tht_identifier_ptr.\n\n\t* gimple.h (union gimple_statement_d): Likewise.\n\n\t* rtl.h (struct rtx_def): Likewise.\n\t(struct rtvec_def): Likewise.\n\n\t* tree.h (union tree_node): Likewise.\n\n\t* tree-ssa-operands.h (struct ssa_operand_memory_d): Likewise.\n\n\t* cfgloop.c (record_loop_exits): Use htab_create_ggc.\n\n\t* tree-scalar-evolution.c (scev_initialize): Likewise.\n\n\t* alias.c (record_alias_subset): Update splay_tree_new_ggc call.\n\n\t* dwarf2asm.c (dw2_force_const_mem): Likewise.\n\n\t* omp-low.c (lower_omp_critical): Likewise.\n\n\t* bitmap.h (struct bitmap_head_def): Update comment to not\n\treference ggc_alloc.\n\n\t* config/pa/pa.c (get_deferred_label): Use GGC_RESIZEVEC.\n\n\t* ira.c (fix_reg_equiv_init): Use GGC_RESIZEVEC.\n\n\t* ipa-prop.c (duplicate_ggc_array): Rename to\n\tduplicate_ipa_jump_func_array.  Use typed GC allocation.\n\t(ipa_edge_duplication_hook): Call duplicate_ipa_jump_func_array.\n\n\t* gimple.c (gimple_alloc_stat): Use\n\tggc_alloc_cleared_gimple_statement_d_stat.\n\n\t* varasm.c (create_block_symbol): Use ggc_alloc_zone_rtx_def.\n\n\t* tree.c (make_node_stat): Use\n\tggc_alloc_zone_cleared_tree_node_stat.\n\t(make_tree_vec_stat): Likewise.\n\t(build_vl_exp_stat): Likewise.\n\t(copy_node_stat): Use ggc_alloc_zone_tree_node_stat.\n\t(make_tree_binfo_stat): Likewise.\n\t(tree_cons_stat): Likewise.\n\n\t* rtl.c (rtx_alloc_stat): Use ggc_alloc_zone_rtx_def_stat.\n\t(shallow_copy_rtx_stat): Likewise.\n\t(make_node_stat): Likewise.\n\n\t* lto-symtab.c: Fix comment.\n\n\t* tree-cfg.c (create_bb): Update comment to not reference\n\tggc_alloc_cleared.\n\t* tree-ssa-structalias.c (struct heapvar_for_stmt): Fix param_is\n\tvalue.\n\n\t* varpool.c (varpool_node): Use typed GC allocation.\n\t(varpool_extra_name_alias): Likewise.\n\n\t* varasm.c (emutls_decl): Likewise.\n\t(get_unnamed_section): Likewise.\n\t(get_noswitch_section): Likewise.\n\t(get_section): Likewise.\n\t(get_block_for_section): Likewise.\n\t(build_constant_desc): Likewise.\n\t(create_constant_pool): Likewise.\n\t(force_const_mem): Likewise.\n\n\t* tree.c (build_vl_exp_stat): Likewise.\n\t(build_real): Likewise.\n\t(build_string): Likewise.\n\t(decl_debug_expr_insert): Likewise.\n\t(decl_value_expr_insert): Likewise.\n\t(type_hash_add): Likewise.\n\t(build_omp_clause): Likewise.\n\n\t* tree-ssanames.c (duplicate_ssa_name_ptr_info): Likewise.\n\n\t* tree-ssa.c (init_tree_ssa): Likewise.\n\n\t* tree-ssa-structalias.c (heapvar_insert): Likewise.\n\n\t* tree-ssa-operands.c (ssa_operand_alloc): Likewise.\n\n\t* tree-ssa-loop-niter.c (record_estimate): Likewise.\n\n\t* tree-ssa-alias.c (get_ptr_info): Likewise.\n\n\t* tree-scalar-evolution.c (new_scev_info_str): Likewise.\n\n\t* tree-phinodes.c (allocate_phi_node): Likewise.\n\n\t* tree-iterator.c (tsi_link_before): Likewise.\n\t(tsi_link_after): Likewise.\n\n\t* tree-eh.c (add_stmt_to_eh_lp_fn): Likewise.\n\n\t* tree-dfa.c (create_var_ann): Likewise.\n\n\t* tree-cfg.c (create_bb): Likewise.\n\n\t* toplev.c (alloc_for_identifier_to_locale): Likewise.\n\t(general_init): Likewise.\n\n\t* stringpool.c (stringpool_ggc_alloc): Likewise.\n\t(gt_pch_save_stringpool): Likewise.\n\n\t* sese.c (if_region_set_false_region): Likewise.\n\n\t* passes.c (do_per_function_toporder): Likewise.\n\n\t* optabs.c (set_optab_libfunc): Likewise.\n\t(set_conv_libfunc): Likewise.\n\n\t* lto-symtab.c (lto_symtab_register_decl): Likewise.\n\n\t* lto-streamer-in.c (lto_input_eh_catch_list): Likewise.\n\t(input_eh_region): Likewise.\n\t(input_eh_lp): Likewise.\n\t(make_new_block): Likewise.\n\t(unpack_ts_real_cst_value_fields): Likewise.\n\n\t* lto-section-in.c (lto_new_in_decl_state): Likewise.\n\n\t* lto-cgraph.c (input_node_opt_summary): Likewise.\n\n\t* loop-init.c (loop_optimizer_init): Likewise.\n\n\t* lambda.h (lambda_vector_new): Likewise.\n\n\t* lambda-code.c (replace_uses_equiv_to_x_with_y): Likewise.\n\n\t* ira.c (update_equiv_regs): Likewise.\n\n\t* ipa.c (cgraph_node_set_new): Likewise.\n\t(cgraph_node_set_add): Likewise.\n\t(varpool_node_set_new): Likewise.\n\t(varpool_node_set_add): Likewise.\n\n\t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Likewise.\n\t(duplicate_ipa_jump_func_array): Likewise.\n\t(ipa_read_node_info): Likewise.\n\n\t* ipa-cp.c (ipcp_create_replace_map): Likewise.\n\n\t* integrate.c (get_hard_reg_initial_val): Likewise.\n\n\t* gimple.c (gimple_alloc_stat): Likewise.\n\t(gimple_build_omp_for): Likewise.\n\t(gimple_seq_alloc): Likewise.\n\t(gimple_copy): Likewise.\n\n\t* gimple-iterator.c (gsi_insert_before_without_update): Likewise.\n\t(gsi_insert_after_without_update): Likewise.\n\n\t* function.c (add_frame_space): Likewise.\n\t(insert_temp_slot_address): Likewise.\n\t(assign_stack_temp_for_type): Likewise.\n\t(allocate_struct_function): Likewise.\n\t(types_used_by_var_decl_insert): Likewise.\n\n\t* except.c (init_eh_for_function): Likewise.\n\t(gen_eh_region): Likewise.\n\t(gen_eh_region_catch): Likewise.\n\t(gen_eh_landing_pad): Likewise.\n\t(add_call_site): Likewise.\n\n\t* emit-rtl.c (get_mem_attrs): Likewise.\n\t(get_reg_attrs): Likewise.\n\t(start_sequence): Likewise.\n\t(init_emit): Likewise.\n\n\t* dwarf2out.c (new_cfi): Likewise.\n\t(queue_reg_save): Likewise.\n\t(dwarf2out_frame_init): Likewise.\n\t(new_loc_descr): Likewise.\n\t(find_AT_string): Likewise.\n\t(new_die): Likewise.\n\t(add_var_loc_to_decl): Likewise.\n\t(clone_die): Likewise.\n\t(clone_as_declaration): Likewise.\n\t(break_out_comdat_types): Likewise.\n\t(new_loc_list): Likewise.\n\t(loc_descriptor): Likewise.\n\t(add_loc_descr_to_each): Likewise.\n\t(add_const_value_attribute): Likewise.\n\t(tree_add_const_value_attribute): Likewise.\n\t(add_comp_dir_attribute): Likewise.\n\t(add_name_and_src_coords_attributes): Likewise.\n\t(lookup_filename): Likewise.\n\t(store_vcall_insn): Likewise.\n\t(dwarf2out_init): Likewise.\n\n\t* dbxout.c (dbxout_init): Likewise.\n\n\t* config/xtensa/xtensa.c (xtensa_init_machine_status): Likewise.\n\n\t* config/sparc/sparc.c (sparc_init_machine_status): Likewise.\n\n\t* config/score/score7.c (score7_output_external): Likewise.\n\n\t* config/score/score3.c (score3_output_external): Likewise.\n\n\t* config/s390/s390.c (s390_init_machine_status): Likewise.\n\n\t* config/rs6000/rs6000.c (builtin_function_type): Likewise.\n\t(rs6000_init_machine_status): Likewise.\n\t(output_toc): Likewise.\n\n\t* config/pa/pa.c (pa_init_machine_status): Likewise.\n\t(get_deferred_plabel): Likewise.\n\n\t* config/moxie/moxie.c (moxie_init_machine_status): Likewise.\n\n\t* config/mmix/mmix.c (mmix_init_machine_status): Likewise.\n\n\t* config/mips/mips.c (mflip_mips16_use_mips16_p): Likewise.\n\n\t* config/mep/mep.c (mep_init_machine_status): Likewise.\n\t(mep_note_pragma_flag): Likewise.\n\n\t* config/m32c/m32c.c (m32c_init_machine_status): Likewise.\n\n\t* config/iq2000/iq2000.c (iq2000_init_machine_status): Likewise.\n\n\t* config/ia64/ia64.c (ia64_init_machine_status): Likewise.\n\n\t* config/i386/winnt.c (i386_pe_record_external_function): Likewise.\n\t(i386_pe_maybe_record_exported_symbol): Likewise.\n\n\t* config/i386/i386.c (get_dllimport_decl): Likewise.\n\t(ix86_init_machine_status): Likewise.\n\t(assign_386_stack_local): Likewise.\n\n\t* config/frv/frv.c (frv_init_machine_status): Likewise.\n\n\t* config/darwin.c (machopic_indirection_name): Likewise.\n\n\t* config/cris/cris.c (cris_init_machine_status): Likewise.\n\n\t* config/bfin/bfin.c (bfin_init_machine_status): Likewise.\n\n\t* config/avr/avr.c (avr_init_machine_status): Likewise.\n\n\t* config/arm/arm.c (arm_init_machine_status): Likewise.\n\n\t* config/alpha/alpha.c (alpha_init_machine_status): Likewise.\n\t(alpha_need_linkage): Likewise.\n\t(alpha_use_linkage): Likewise.\n\n\t* cgraph.c (cgraph_allocate_node): Likewise.\n\t(cgraph_create_edge_1): Likewise.\n\t(cgraph_create_indirect_edge): Likewise.\n\t(cgraph_add_asm_node): Likewise.\n\n\t* cfgrtl.c (init_rtl_bb_info): Likewise.\n\n\t* cfgloop.c (alloc_loop): Likewise.\n\t(rescan_loop_exit): Likewise.\n\n\t* cfg.c (init_flow): Likewise.\n\t(alloc_block): Likewise.\n\t(unchecked_make_edge): Likewise.\n\n\t* c-parser.c (c_parse_init): Likewise.\n\t(c_parse_file): Likewise.\n\n\t* c-decl.c (bind): Likewise.\n\t(record_inline_static): Likewise.\n\t(push_scope): Likewise.\n\t(make_label): Likewise.\n\t(lookup_label_for_goto): Likewise.\n\t(finish_struct): Likewise.\n\t(finish_enum): Likewise.\n\t(c_push_function_context): Likewise.\n\n\t* bitmap.c (bitmap_element_allocate): Likewise.\n\t(bitmap_gc_alloc_stat): Likewise.\n\n\t* alias.c (record_alias_subset): Likewise.\n\t(init_alias_analysis): Likewise.\n\ninclude:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* splay-tree.h: Update copyright years.\n\t(splay_tree_s): Document fields.\n\t(splay_tree_new_typed_alloc): New.\n\n\t* hashtab.h: Update copyright years.\n\t(htab_create_typed_alloc): New.\n\nlibcpp:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* include/symtab.h (ht_identifier_ptr): New.\n\nlibiberty:\n\n2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* splay-tree.c: Update copyright years.\n\t(splay_tree_new_typed_alloc): New.\n\t(splay_tree_new_with_allocator): Use it.\n\n\t* hashtab.c: Update copyright years.\n\t(htab_create_typed_alloc): New.\n\t(htab_create_alloc): Use it.\n\n\t* functions.texi: Regenerate.\n\nFrom-SVN: r160425", "tree": {"sha": "221b014255b515c1a1c4f178e540c2f88d7eb42a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/221b014255b515c1a1c4f178e540c2f88d7eb42a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9429e29f506f5b8c28b28ab387fc2d261a4220c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9429e29f506f5b8c28b28ab387fc2d261a4220c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9429e29f506f5b8c28b28ab387fc2d261a4220c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9429e29f506f5b8c28b28ab387fc2d261a4220c/comments", "author": {"login": "laurynas-biveinis", "id": 58894, "node_id": "MDQ6VXNlcjU4ODk0", "avatar_url": "https://avatars.githubusercontent.com/u/58894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/laurynas-biveinis", "html_url": "https://github.com/laurynas-biveinis", "followers_url": "https://api.github.com/users/laurynas-biveinis/followers", "following_url": "https://api.github.com/users/laurynas-biveinis/following{/other_user}", "gists_url": "https://api.github.com/users/laurynas-biveinis/gists{/gist_id}", "starred_url": "https://api.github.com/users/laurynas-biveinis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/laurynas-biveinis/subscriptions", "organizations_url": "https://api.github.com/users/laurynas-biveinis/orgs", "repos_url": "https://api.github.com/users/laurynas-biveinis/repos", "events_url": "https://api.github.com/users/laurynas-biveinis/events{/privacy}", "received_events_url": "https://api.github.com/users/laurynas-biveinis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c064bf1cefe997074dcc4fec96317a63335634af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c064bf1cefe997074dcc4fec96317a63335634af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c064bf1cefe997074dcc4fec96317a63335634af"}], "stats": {"total": 2441, "additions": 1757, "deletions": 684}, "files": [{"sha": "46703abeece468d82b2eb07078f2a926cbf40a80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,401 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* doc/tm.texi (Per-Function Data): Do not reference ggc_alloc.\n+\n+\t* doc/gty.texi (GTY Options): Document typed GC allocation and\n+\tvariable_size GTY option.\n+\n+\t* ggc-internal.h: New.\n+\n+\t* ggc.h: Update copyright year.\n+\t(digit_string): Move to stringpool.c.\n+\t(ggc_mark_stringpool, ggc_purge_stringpool, ggc_mark_roots)\n+\t(gt_pch_save_stringpool, gt_pch_fixup_stringpool)\n+\t(gt_pach_restore_stringpool, gt_pch_p_S, gt_pch_note_object)\n+\t(init_ggc_pch, ggc_pch_count_object, ggc_pch_total_size)\n+\t(ggc_pch_this_base, ggc_pch_alloc_object, ggc_pch_prepare_write)\n+\t(ggc_pch_write_object, ggc_pch_finish, ggc_pch_read)\n+\t(ggc_force_collect, ggc_get_size, ggc_statistics)\n+\t(ggc_print_common_statistics): Move to ggc-internal.h.\n+\t(digit_vector, new_ggc_zone, destroy_ggc_zone, ggc_alloc_stat)\n+\t(ggc_alloc, ggc_alloc_cleared, ggc_realloc, ggc_calloc, GGC_NEW)\n+\t(GGC_CNEW, GGC_NEWVEC, GGC_CNEWVEC, GGC_NEWVAR, ggc_alloc_rtvec)\n+\t(ggc_alloc_tree, gt_pch_save, ggc_min_expand_heuristic)\n+\t(ggc_min_heapsize_heuristic, ggc_alloc_zone)\n+\t(ggc_alloc_zone_pass_stat): Remove.\n+\t(ggc_internal_alloc_stat, ggc_internal_alloc)\n+\t(ggc_internal_cleared_alloc_stat): New.\n+\t(GGC_RESIZEVEC, GGC_RESIZEVAR): Redefine.\n+\t(ggc_internal_vec_alloc_stat)\n+\t(ggc_internal_cleared_vec_alloc_stat)\n+\t(ggc_internal_vec_alloc_stat, ggc_internal_cleared_vec_alloc)\n+\t(ggc_alloc_atomic_stat, ggc_alloc_atomic)\n+\t(ggc_alloc_cleared_atomic, ggc_cleared_alloc_htab_ignore_args)\n+\t(ggc_cleared_alloc_ptr_array_two_args): New.\n+\t(htab_create_ggc, splay_tree_new_ggc): Redefine.\n+\t(ggc_splay_alloc): Change the type of the first argument to\n+\tenum gt_types_enum.\n+\t(ggc_alloc_string): Make macro.\n+\t(ggc_alloc_string_stat): New.\n+\t(ggc_strdup): Redefine.\n+\t(rtl_zone, tree_zone, tree_id_zone): Declare unconditionally.\n+\t(ggc_alloc_rtvec_sized): New.\n+\t(ggc_alloc_zone_stat): Rename to ggc_internal_alloc_zone_stat.\n+\t(ggc_internal_alloc_zone_pass_stat, ggc_internal_alloc_zone_stat)\n+\t(ggc_internal_cleared_alloc_zone_stat)\n+\t(ggc_internal_zone_alloc_stat)\n+\t(ggc_internal_zone_cleared_alloc_stat)\n+\t(ggc_internal_zone_vec_alloc_stat)\n+\t(ggc_alloc_zone_rtx_def_stat)\n+\t(ggc_alloc_zone_tree_node_stat)\n+\t(ggc_alloc_zone_cleared_tree_node_stat)\n+\t(ggc_alloc_cleared_gimple_statement_d_stat): New.\n+\n+\t* ggc-common.c: Include ggc-internal.h.\n+\t(ggc_internal_cleared_alloc_stat): Rename from\n+\tggc_alloc_cleared_stat.\n+\t(ggc_realloc_stat): Use ggc_internal_alloc_stat.\n+\t(ggc_calloc): Remove.\n+\t(ggc_cleared_alloc_htab_ignore_args): New.\n+\t(ggc_cleared_alloc_ptr_array_two_args): New.\n+\t(ggc_splay_alloc): Add obj_type parameter.\n+\t(init_ggc_heuristics): Formatting fixes.\n+\n+\t* ggc-none.c: Update copyright year.\n+\t(ggc_alloc_stat): Rename to ggc_alloc_stat.\n+\t(ggc_alloc_cleared_stat): Rename to\n+\tggc_internal_cleared_alloc_stat.\n+\t(struct alloc_zone, rtl_zone, tree_zone, tree_id_zone): New.\n+\n+\t* ggc-page.c: Update copyright year.  Include ggc-internal.h.\n+\tRemove references to ggc_alloc in comments.\n+\t(ggc_alloc_typed_stat): Call ggc_internal_alloc_stat.\n+\t(ggc_alloc_stat): Rename to ggc_internal_alloc_stat.\n+\t(new_ggc_zone, destroy_ggc_zone): Remove.\n+\t(struct alloc_zone, rtl_zone, tree_zone, tree_id_zone): New.\n+\n+\t* ggc-zone.c: Include ggc-internal.h.  Remove references to\n+\tggc_alloc in comments.\n+\t(ggc_alloc_zone_stat): ggc_internal_alloc_zone_stat.\n+\t(ggc_internal_alloc_zone_pass_stat): New.\n+\t(ggc_internal_cleared_alloc_zone_stat): New.\n+\t(ggc_alloc_typed_stat): Use ggc_internal_alloc_zone_pass_stat.\n+\t(ggc_alloc_stat): Rename ggc_internal_alloc_stat.\n+\t(new_ggc_zone, destroy_ggc_zone): Remove.\n+\n+\t* stringpool.c: Update copyright year.  Include ggc-internal.h\n+\t(digit_vector): Make static.\n+\t(digit_string): Moved from ggc.h.\n+\t(stringpool_ggc_alloc): Use ggc_alloc_atomic.\n+\t(ggc_alloc_string): Rename to ggc_alloc_string_stat.\n+\n+\t* Makefile.in (GGC_INTERNAL_H): New.\n+\t(ggc_common.o, ggc-page.o, ggc-zone.o, stringpool.o): Add\n+\t$(GGC_INTERNAL_H) to dependencies.\n+\n+\t* gentype.c: Update copyright year.\n+\t(walk_type): Accept variable_size GTY option.\n+\t(USED_BY_TYPED_GC_P): New macro.\n+\t(write_enum_defn): Use USED_BY_TYPED_GC_P.  Do not output\n+\twhitespace at the end of strings.\n+\t(get_type_specifier, variable_size_p): New functions.\n+\t(alloc_quantity, alloc_zone): New enums.\n+\t(write_typed_alloc_def): New function.\n+\t(write_typed_struct_alloc_def): Likewise.\n+\t(write_typed_typed_typedef_alloc_def): Likewise.\n+\t(write_typed_alloc_defns): Likewise.\n+\t(output_typename, write_splay_tree_allocator_def): Likewise.\n+\t(write_splay_tree_allocators): Likewise.\n+\t(main): Call write_typed_alloc_defns and\n+\twrite_splay_tree_allocators.\n+\n+\t* lto-streamer.h (lto_file_decl_data_ptr): New.\n+\n+\t* passes.c (order): Define using cgraph_node_ptr.\n+\n+\t* strinpool.c (struct string_pool_data): Declare nested_ptr using\n+\tht_identifier_ptr.\n+\n+\t* gimple.h (union gimple_statement_d): Likewise.\n+\n+\t* rtl.h (struct rtx_def): Likewise.\n+\t(struct rtvec_def): Likewise.\n+\n+\t* tree.h (union tree_node): Likewise.\n+\n+\t* tree-ssa-operands.h (struct ssa_operand_memory_d): Likewise.\n+\n+\t* cfgloop.c (record_loop_exits): Use htab_create_ggc.\n+\n+\t* tree-scalar-evolution.c (scev_initialize): Likewise.\n+\n+\t* alias.c (record_alias_subset): Update splay_tree_new_ggc call.\n+\n+\t* dwarf2asm.c (dw2_force_const_mem): Likewise.\n+\n+\t* omp-low.c (lower_omp_critical): Likewise.\n+\n+\t* bitmap.h (struct bitmap_head_def): Update comment to not\n+\treference ggc_alloc.\n+\n+\t* config/pa/pa.c (get_deferred_label): Use GGC_RESIZEVEC.\n+\n+\t* ira.c (fix_reg_equiv_init): Use GGC_RESIZEVEC.\n+\n+\t* ipa-prop.c (duplicate_ggc_array): Rename to\n+\tduplicate_ipa_jump_func_array.  Use typed GC allocation.\n+\t(ipa_edge_duplication_hook): Call duplicate_ipa_jump_func_array.\n+\n+\t* gimple.c (gimple_alloc_stat): Use\n+\tggc_alloc_cleared_gimple_statement_d_stat.\n+\n+\t* varasm.c (create_block_symbol): Use ggc_alloc_zone_rtx_def.\n+\n+\t* tree.c (make_node_stat): Use\n+\tggc_alloc_zone_cleared_tree_node_stat.\n+\t(make_tree_vec_stat): Likewise.\n+\t(build_vl_exp_stat): Likewise.\n+\t(copy_node_stat): Use ggc_alloc_zone_tree_node_stat.\n+\t(make_tree_binfo_stat): Likewise.\n+\t(tree_cons_stat): Likewise.\n+\n+\t* rtl.c (rtx_alloc_stat): Use ggc_alloc_zone_rtx_def_stat.\n+\t(shallow_copy_rtx_stat): Likewise.\n+\t(make_node_stat): Likewise.\n+\n+\t* lto-symtab.c: Fix comment.\n+\n+\t* tree-cfg.c (create_bb): Update comment to not reference\n+\tggc_alloc_cleared.\n+\t* tree-ssa-structalias.c (struct heapvar_for_stmt): Fix param_is\n+\tvalue.\n+\n+\t* varpool.c (varpool_node): Use typed GC allocation.\n+\t(varpool_extra_name_alias): Likewise.\n+\n+\t* varasm.c (emutls_decl): Likewise.\n+\t(get_unnamed_section): Likewise.\n+\t(get_noswitch_section): Likewise.\n+\t(get_section): Likewise.\n+\t(get_block_for_section): Likewise.\n+\t(build_constant_desc): Likewise.\n+\t(create_constant_pool): Likewise.\n+\t(force_const_mem): Likewise.\n+\n+\t* tree.c (build_vl_exp_stat): Likewise.\n+\t(build_real): Likewise.\n+\t(build_string): Likewise.\n+\t(decl_debug_expr_insert): Likewise.\n+\t(decl_value_expr_insert): Likewise.\n+\t(type_hash_add): Likewise.\n+\t(build_omp_clause): Likewise.\n+\n+\t* tree-ssanames.c (duplicate_ssa_name_ptr_info): Likewise.\n+\n+\t* tree-ssa.c (init_tree_ssa): Likewise.\n+\n+\t* tree-ssa-structalias.c (heapvar_insert): Likewise.\n+\n+\t* tree-ssa-operands.c (ssa_operand_alloc): Likewise.\n+\n+\t* tree-ssa-loop-niter.c (record_estimate): Likewise.\n+\n+\t* tree-ssa-alias.c (get_ptr_info): Likewise.\n+\n+\t* tree-scalar-evolution.c (new_scev_info_str): Likewise.\n+\n+\t* tree-phinodes.c (allocate_phi_node): Likewise.\n+\n+\t* tree-iterator.c (tsi_link_before): Likewise.\n+\t(tsi_link_after): Likewise.\n+\n+\t* tree-eh.c (add_stmt_to_eh_lp_fn): Likewise.\n+\n+\t* tree-dfa.c (create_var_ann): Likewise.\n+\n+\t* tree-cfg.c (create_bb): Likewise.\n+\n+\t* toplev.c (alloc_for_identifier_to_locale): Likewise.\n+\t(general_init): Likewise.\n+\n+\t* stringpool.c (stringpool_ggc_alloc): Likewise.\n+\t(gt_pch_save_stringpool): Likewise.\n+\n+\t* sese.c (if_region_set_false_region): Likewise.\n+\n+\t* passes.c (do_per_function_toporder): Likewise.\n+\n+\t* optabs.c (set_optab_libfunc): Likewise.\n+\t(set_conv_libfunc): Likewise.\n+\n+\t* lto-symtab.c (lto_symtab_register_decl): Likewise.\n+\n+\t* lto-streamer-in.c (lto_input_eh_catch_list): Likewise.\n+\t(input_eh_region): Likewise.\n+\t(input_eh_lp): Likewise.\n+\t(make_new_block): Likewise.\n+\t(unpack_ts_real_cst_value_fields): Likewise.\n+\n+\t* lto-section-in.c (lto_new_in_decl_state): Likewise.\n+\n+\t* lto-cgraph.c (input_node_opt_summary): Likewise.\n+\n+\t* loop-init.c (loop_optimizer_init): Likewise.\n+\n+\t* lambda.h (lambda_vector_new): Likewise.\n+\n+\t* lambda-code.c (replace_uses_equiv_to_x_with_y): Likewise.\n+\n+\t* ira.c (update_equiv_regs): Likewise.\n+\n+\t* ipa.c (cgraph_node_set_new): Likewise.\n+\t(cgraph_node_set_add): Likewise.\n+\t(varpool_node_set_new): Likewise.\n+\t(varpool_node_set_add): Likewise.\n+\n+\t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Likewise.\n+\t(duplicate_ipa_jump_func_array): Likewise.\n+\t(ipa_read_node_info): Likewise.\n+\n+\t* ipa-cp.c (ipcp_create_replace_map): Likewise.\n+\n+\t* integrate.c (get_hard_reg_initial_val): Likewise.\n+\n+\t* gimple.c (gimple_alloc_stat): Likewise.\n+\t(gimple_build_omp_for): Likewise.\n+\t(gimple_seq_alloc): Likewise.\n+\t(gimple_copy): Likewise.\n+\n+\t* gimple-iterator.c (gsi_insert_before_without_update): Likewise.\n+\t(gsi_insert_after_without_update): Likewise.\n+\n+\t* function.c (add_frame_space): Likewise.\n+\t(insert_temp_slot_address): Likewise.\n+\t(assign_stack_temp_for_type): Likewise.\n+\t(allocate_struct_function): Likewise.\n+\t(types_used_by_var_decl_insert): Likewise.\n+\n+\t* except.c (init_eh_for_function): Likewise.\n+\t(gen_eh_region): Likewise.\n+\t(gen_eh_region_catch): Likewise.\n+\t(gen_eh_landing_pad): Likewise.\n+\t(add_call_site): Likewise.\n+\n+\t* emit-rtl.c (get_mem_attrs): Likewise.\n+\t(get_reg_attrs): Likewise.\n+\t(start_sequence): Likewise.\n+\t(init_emit): Likewise.\n+\n+\t* dwarf2out.c (new_cfi): Likewise.\n+\t(queue_reg_save): Likewise.\n+\t(dwarf2out_frame_init): Likewise.\n+\t(new_loc_descr): Likewise.\n+\t(find_AT_string): Likewise.\n+\t(new_die): Likewise.\n+\t(add_var_loc_to_decl): Likewise.\n+\t(clone_die): Likewise.\n+\t(clone_as_declaration): Likewise.\n+\t(break_out_comdat_types): Likewise.\n+\t(new_loc_list): Likewise.\n+\t(loc_descriptor): Likewise.\n+\t(add_loc_descr_to_each): Likewise.\n+\t(add_const_value_attribute): Likewise.\n+\t(tree_add_const_value_attribute): Likewise.\n+\t(add_comp_dir_attribute): Likewise.\n+\t(add_name_and_src_coords_attributes): Likewise.\n+\t(lookup_filename): Likewise.\n+\t(store_vcall_insn): Likewise.\n+\t(dwarf2out_init): Likewise.\n+\n+\t* dbxout.c (dbxout_init): Likewise.\n+\n+\t* config/xtensa/xtensa.c (xtensa_init_machine_status): Likewise.\n+\n+\t* config/sparc/sparc.c (sparc_init_machine_status): Likewise.\n+\n+\t* config/score/score7.c (score7_output_external): Likewise.\n+\n+\t* config/score/score3.c (score3_output_external): Likewise.\n+\n+\t* config/s390/s390.c (s390_init_machine_status): Likewise.\n+\n+\t* config/rs6000/rs6000.c (builtin_function_type): Likewise.\n+\t(rs6000_init_machine_status): Likewise.\n+\t(output_toc): Likewise.\n+\n+\t* config/pa/pa.c (pa_init_machine_status): Likewise.\n+\t(get_deferred_plabel): Likewise.\n+\n+\t* config/moxie/moxie.c (moxie_init_machine_status): Likewise.\n+\n+\t* config/mmix/mmix.c (mmix_init_machine_status): Likewise.\n+\n+\t* config/mips/mips.c (mflip_mips16_use_mips16_p): Likewise.\n+\n+\t* config/mep/mep.c (mep_init_machine_status): Likewise.\n+\t(mep_note_pragma_flag): Likewise.\n+\n+\t* config/m32c/m32c.c (m32c_init_machine_status): Likewise.\n+\n+\t* config/iq2000/iq2000.c (iq2000_init_machine_status): Likewise.\n+\n+\t* config/ia64/ia64.c (ia64_init_machine_status): Likewise.\n+\n+\t* config/i386/winnt.c (i386_pe_record_external_function): Likewise.\n+\t(i386_pe_maybe_record_exported_symbol): Likewise.\n+\n+\t* config/i386/i386.c (get_dllimport_decl): Likewise.\n+\t(ix86_init_machine_status): Likewise.\n+\t(assign_386_stack_local): Likewise.\n+\n+\t* config/frv/frv.c (frv_init_machine_status): Likewise.\n+\n+\t* config/darwin.c (machopic_indirection_name): Likewise.\n+\n+\t* config/cris/cris.c (cris_init_machine_status): Likewise.\n+\n+\t* config/bfin/bfin.c (bfin_init_machine_status): Likewise.\n+\n+\t* config/avr/avr.c (avr_init_machine_status): Likewise.\n+\n+\t* config/arm/arm.c (arm_init_machine_status): Likewise.\n+\n+\t* config/alpha/alpha.c (alpha_init_machine_status): Likewise.\n+\t(alpha_need_linkage): Likewise.\n+\t(alpha_use_linkage): Likewise.\n+\n+\t* cgraph.c (cgraph_allocate_node): Likewise.\n+\t(cgraph_create_edge_1): Likewise.\n+\t(cgraph_create_indirect_edge): Likewise.\n+\t(cgraph_add_asm_node): Likewise.\n+\n+\t* cfgrtl.c (init_rtl_bb_info): Likewise.\n+\n+\t* cfgloop.c (alloc_loop): Likewise.\n+\t(rescan_loop_exit): Likewise.\n+\n+\t* cfg.c (init_flow): Likewise.\n+\t(alloc_block): Likewise.\n+\t(unchecked_make_edge): Likewise.\n+\n+\t* c-parser.c (c_parse_init): Likewise.\n+\t(c_parse_file): Likewise.\n+\n+\t* c-decl.c (bind): Likewise.\n+\t(record_inline_static): Likewise.\n+\t(push_scope): Likewise.\n+\t(make_label): Likewise.\n+\t(lookup_label_for_goto): Likewise.\n+\t(finish_struct): Likewise.\n+\t(finish_enum): Likewise.\n+\t(c_push_function_context): Likewise.\n+\n+\t* bitmap.c (bitmap_element_allocate): Likewise.\n+\t(bitmap_gc_alloc_stat): Likewise.\n+\n+\t* alias.c (record_alias_subset): Likewise.\n+\t(init_alias_analysis): Likewise.\n+\n 2010-06-08  Shujing Zhao  <pearly.zhao@oracle.com>\n \t\n \t* fold-const.c (fold_comparison): Remove redundant parenthesis."}, {"sha": "a19022564b3813b1e58cc4c7320aaf5d21f7217e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -914,6 +914,7 @@ RESOURCE_H = resource.h hard-reg-set.h $(DF_H)\n DDG_H = ddg.h sbitmap.h $(DF_H)\n GCC_H = gcc.h version.h $(DIAGNOSTIC_CORE_H)\n GGC_H = ggc.h gtype-desc.h statistics.h\n+GGC_INTERNAL_H = ggc-internal.h $(GGC_H)\n TIMEVAR_H = timevar.h timevar.def\n INSN_ATTR_H = insn-attr.h $(INSN_ADDR_H)\n INSN_ADDR_H = $(srcdir)/insn-addr.h vecprim.h\n@@ -2246,20 +2247,21 @@ gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\t\\\n \t$(GGC_H) $(HASHTAB_H) $(TOPLEV_H) $(PARAMS_H) hosthooks.h\t\\\n-\t$(HOSTHOOKS_DEF_H) $(VEC_H) $(PLUGIN_H) $(TIMEVAR_H)\n+\t$(HOSTHOOKS_DEF_H) $(VEC_H) $(PLUGIN_H) $(GGC_INTERNAL_H) $(TIMEVAR_H)\n \n ggc-page.o: ggc-page.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n-\t$(FLAGS_H) $(TOPLEV_H) $(GGC_H) $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H) $(TREE_FLOW_H) $(PLUGIN_H)\n+\t$(FLAGS_H) $(TOPLEV_H) $(GGC_H) $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H) \\\n+\t$(TREE_FLOW_H) $(PLUGIN_H) $(GGC_INTERNAL_H)\n \n ggc-zone.o: ggc-zone.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n \t$(TREE_H) $(FLAGS_H) $(TOPLEV_H) $(GGC_H) $(TIMEVAR_H) $(TM_P_H) \\\n-\t$(PARAMS_H) $(BITMAP_H) $(PLUGIN_H)\n+\t$(PARAMS_H) $(BITMAP_H) $(PLUGIN_H) $(GGC_INTERNAL_H)\n \n ggc-none.o: ggc-none.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \\\n \t$(BCONFIG_H)\n \n stringpool.o: stringpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-\t$(TREE_H) $(GGC_H) gt-stringpool.h $(CPPLIB_H) $(SYMTAB_H)\n+\t$(TREE_H) $(GGC_H) $(GGC_INTERNAL_H) gt-stringpool.h $(CPPLIB_H) $(SYMTAB_H)\n \n convert.o: convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(FLAGS_H) convert.h $(TOPLEV_H) langhooks.h"}, {"sha": "accf5bbda62855f062357c8b1251c72538c9f4e1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,27 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* gcc-interface/utils.c (init_gnat_to_gnu): Use typed GC\n+\tallocation.\n+\t(init_dummy_type): Likewise.\n+\t(gnat_pushlevel): Likewise.\n+\n+\t* gcc-interface/trans.c (Attribute_to_gnu): Likewise.\n+\t(Subprogram_Body_to_gnu): Likewise.\n+\t(Compilation_Unit_to_gnu): Likewise.\n+\t(start_stmt_group): Likewise.\n+\t(extract_encoding): Likewise.\n+\t(decode_name): Likewise.\n+\n+\t* gcc-interface/misc.c (gnat_printable_name): Likewise.\n+\n+\t* gcc-interface/decl.c (annotate_value): Likewise.\n+\n+\t* gcc-interface/ada-tree.h (struct lang_type): Add variable_size\n+\tGTY option.\n+\t(struct lang_decl): Likewise.\n+\t(SET_TYPE_LANG_SPECIFIC): Use typed GC allocation.\n+\t(SET_DECL_LANG_SPECIFIC): Likewise.\n+\n 2010-06-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnatlink.adb (gnatlink): Remove support for -fsjlj switch."}, {"sha": "220ed57c215482b083c3b138f4015856ca1c4e6f", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -32,32 +32,37 @@ union GTY((desc (\"0\"),\n \t\t       desc (\"tree_node_structure (&%h)\"))) generic;\n };\n \n-/* Ada uses the lang_decl and lang_type fields to hold a tree.  */\n-struct GTY(()) lang_type { tree t; };\n-struct GTY(()) lang_decl { tree t; };\n+/* Ada uses the lang_decl and lang_type fields to hold a tree.\n+   FIXME: the variable_size annotation here is needed because these types are\n+   variable-sized in some other frontends.  Due to gengtype deficiency the GTY\n+   options of such types have to agree across all frontends. */\n+struct GTY((variable_size)) lang_type { tree t; };\n+struct GTY((variable_size)) lang_decl { tree t; };\n \n /* Macros to get and set the tree in TYPE_LANG_SPECIFIC.  */\n #define GET_TYPE_LANG_SPECIFIC(NODE) \\\n   (TYPE_LANG_SPECIFIC (NODE) ? TYPE_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n \n-#define SET_TYPE_LANG_SPECIFIC(NODE, X)\t\t\t    \\\n-do {\t\t\t\t\t\t\t    \\\n-  tree tmp = (X);\t\t\t\t\t    \\\n-  if (!TYPE_LANG_SPECIFIC (NODE))\t\t\t    \\\n-    TYPE_LANG_SPECIFIC (NODE) = GGC_NEW (struct lang_type); \\\n-  TYPE_LANG_SPECIFIC (NODE)->t = tmp;\t\t\t    \\\n+#define SET_TYPE_LANG_SPECIFIC(NODE, X)\t\t       \\\n+do {\t\t\t\t\t\t       \\\n+  tree tmp = (X);\t\t\t\t       \\\n+  if (!TYPE_LANG_SPECIFIC (NODE))\t\t       \\\n+    TYPE_LANG_SPECIFIC (NODE) = ggc_alloc_lang_type    \\\n+      (sizeof (struct lang_type));\t\t       \\\n+  TYPE_LANG_SPECIFIC (NODE)->t = tmp;\t\t       \\\n } while (0)\n \n /* Macros to get and set the tree in DECL_LANG_SPECIFIC.  */\n #define GET_DECL_LANG_SPECIFIC(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE) ? DECL_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n \n-#define SET_DECL_LANG_SPECIFIC(NODE, X)\t\t\t    \\\n-do {\t\t\t\t\t\t\t    \\\n-  tree tmp = (X);\t\t\t\t\t    \\\n-  if (!DECL_LANG_SPECIFIC (NODE))\t\t\t    \\\n-    DECL_LANG_SPECIFIC (NODE) = GGC_NEW (struct lang_decl); \\\n-  DECL_LANG_SPECIFIC (NODE)->t = tmp;\t\t\t    \\\n+#define SET_DECL_LANG_SPECIFIC(NODE, X)\t\t       \\\n+do {\t\t\t\t\t\t       \\\n+  tree tmp = (X);\t\t\t\t       \\\n+  if (!DECL_LANG_SPECIFIC (NODE))\t\t       \\\n+    DECL_LANG_SPECIFIC (NODE) = ggc_alloc_lang_decl    \\\n+      (sizeof (struct lang_decl));\t\t       \\\n+  DECL_LANG_SPECIFIC (NODE)->t = tmp;\t\t       \\\n } while (0)\n \n "}, {"sha": "fb4769b7bb24aba524a87065fd952fe3210f6b12", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -7296,7 +7296,7 @@ annotate_value (tree gnu_size)\n   /* Save the result in the cache.  */\n   if (h)\n     {\n-      *h = GGC_NEW (struct tree_int_map);\n+      *h = ggc_alloc_tree_int_map ();\n       (*h)->base.from = gnu_size;\n       (*h)->to = ret;\n     }"}, {"sha": "229663b7ce206347bffe458937ecd219942f9cce", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -574,7 +574,7 @@ static const char *\n gnat_printable_name (tree decl, int verbosity)\n {\n   const char *coded_name = IDENTIFIER_POINTER (DECL_NAME (decl));\n-  char *ada_name = (char *) ggc_alloc (strlen (coded_name) * 2 + 60);\n+  char *ada_name = (char *) ggc_alloc_atomic (strlen (coded_name) * 2 + 60);\n \n   __gnat_decode (coded_name, ada_name, 0);\n "}, {"sha": "7a94393b0e0d3ac46fd75acf2ad32c00217d8d71", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1605,7 +1605,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n \t    if (!pa)\n \t      {\n-\t\tpa = GGC_CNEW (struct parm_attr_d);\n+\t\tpa = ggc_alloc_cleared_parm_attr_d ();\n \t\tpa->id = gnat_param;\n \t\tpa->dim = Dimension;\n \t\tVEC_safe_push (parm_attr, gc, f_parm_attr_cache, pa);\n@@ -2441,7 +2441,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   /* Initialize the information structure for the function.  */\n   allocate_struct_function (gnu_subprog_decl, false);\n   DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language\n-    = GGC_CNEW (struct language_function);\n+    = ggc_alloc_cleared_language_function ();\n   set_cfun (NULL);\n \n   begin_subprog_body (gnu_subprog_decl);\n@@ -3626,7 +3626,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n \n   /* Save away what we've made so far and record this potential elaboration\n      procedure.  */\n-  info = (struct elab_info *) ggc_alloc (sizeof (struct elab_info));\n+  info = ggc_alloc_elab_info ();\n   set_current_block_context (gnu_elab_proc_decl);\n   gnat_poplevel ();\n   DECL_SAVED_TREE (gnu_elab_proc_decl) = end_stmt_group ();\n@@ -5722,7 +5722,7 @@ start_stmt_group (void)\n   if (group)\n     stmt_group_free_list = group->previous;\n   else\n-    group = (struct stmt_group *) ggc_alloc (sizeof (struct stmt_group));\n+    group = ggc_alloc_stmt_group ();\n \n   group->previous = current_stmt_group;\n   group->stmt_list = group->block = group->cleanups = NULL_TREE;\n@@ -7498,7 +7498,7 @@ set_expr_location_from_node (tree node, Node_Id gnat_node)\n static const char *\n extract_encoding (const char *name)\n {\n-  char *encoding = GGC_NEWVEC (char, strlen (name));\n+  char *encoding = (char *) ggc_alloc_atomic (strlen (name));\n   get_encoding (name, encoding);\n   return encoding;\n }\n@@ -7508,7 +7508,7 @@ extract_encoding (const char *name)\n static const char *\n decode_name (const char *name)\n {\n-  char *decoded = GGC_NEWVEC (char, strlen (name) * 2 + 60);\n+  char *decoded = (char *) ggc_alloc_atomic (strlen (name) * 2 + 60);\n   __gnat_decode (name, decoded, 0);\n   return decoded;\n }"}, {"sha": "ebb70259c453c84fc504185f9fa9552732a9db2f", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -206,8 +206,7 @@ static void process_attributes (tree, struct attrib *);\n void\n init_gnat_to_gnu (void)\n {\n-  associate_gnat_to_gnu\n-    = (tree *) ggc_alloc_cleared (max_gnat_nodes * sizeof (tree));\n+  associate_gnat_to_gnu = ggc_alloc_cleared_vec_tree (max_gnat_nodes);\n }\n \n /* GNAT_ENTITY is a GNAT tree node for an entity.   GNU_DECL is the GCC tree\n@@ -257,8 +256,7 @@ present_gnu_tree (Entity_Id gnat_entity)\n void\n init_dummy_type (void)\n {\n-  dummy_node_table\n-    = (tree *) ggc_alloc_cleared (max_gnat_nodes * sizeof (tree));\n+  dummy_node_table = ggc_alloc_cleared_vec_tree (max_gnat_nodes);\n }\n \n /* Make a dummy type corresponding to GNAT_TYPE.  */\n@@ -321,9 +319,7 @@ gnat_pushlevel (void)\n       free_binding_level = free_binding_level->chain;\n     }\n   else\n-    newlevel\n-      = (struct gnat_binding_level *)\n-\tggc_alloc (sizeof (struct gnat_binding_level));\n+    newlevel = ggc_alloc_gnat_binding_level ();\n \n   /* Use a free BLOCK, if any; otherwise, allocate one.  */\n   if (free_block_chain)"}, {"sha": "382093161189ee61e849753e006b288ca23e0f8b", "filename": "gcc/alias.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -823,10 +823,12 @@ record_alias_subset (alias_set_type superset, alias_set_type subset)\n     {\n       /* Create an entry for the SUPERSET, so that we have a place to\n \t attach the SUBSET.  */\n-      superset_entry = GGC_NEW (struct alias_set_entry_d);\n+      superset_entry = ggc_alloc_cleared_alias_set_entry_d ();\n       superset_entry->alias_set = superset;\n       superset_entry->children\n-\t= splay_tree_new_ggc (splay_tree_compare_ints);\n+\t= splay_tree_new_ggc (splay_tree_compare_ints,\n+\t\t\t      ggc_alloc_splay_tree_scalar_scalar_splay_tree_s,\n+\t\t\t      ggc_alloc_splay_tree_scalar_scalar_splay_tree_node_s);\n       superset_entry->has_zero_child = 0;\n       VEC_replace (alias_set_entry, alias_sets, superset, superset_entry);\n     }\n@@ -2639,7 +2641,7 @@ init_alias_analysis (void)\n   timevar_push (TV_ALIAS_ANALYSIS);\n \n   reg_known_value_size = maxreg - FIRST_PSEUDO_REGISTER;\n-  reg_known_value = GGC_CNEWVEC (rtx, reg_known_value_size);\n+  reg_known_value = ggc_alloc_cleared_vec_rtx (reg_known_value_size);\n   reg_known_equiv_p = XCNEWVEC (bool, reg_known_value_size);\n \n   /* If we have memory allocated from the previous run, use it.  */"}, {"sha": "21a05fc4fa15b2368545c38cad608de82b4bb209", "filename": "gcc/bitmap.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -230,7 +230,7 @@ bitmap_element_allocate (bitmap head)\n \t  /*  Inner list was just a singleton.  */\n \t  bitmap_ggc_free = element->prev;\n       else\n-\telement = GGC_NEW (bitmap_element);\n+\telement = ggc_alloc_bitmap_element_def ();\n     }\n \n #ifdef GATHER_STATISTICS\n@@ -375,7 +375,7 @@ bitmap_gc_alloc_stat (ALONE_MEM_STAT_DECL)\n {\n   bitmap map;\n \n-  map = GGC_NEW (struct bitmap_head_def);\n+  map = ggc_alloc_bitmap_head_def ();\n   bitmap_initialize_stat (map, NULL PASS_MEM_STAT);\n #ifdef GATHER_STATISTICS\n   register_overhead (map, sizeof (bitmap_head));"}, {"sha": "1163b2f53d18e648f3639f2aecb4564d3f5d2fdc", "filename": "gcc/bitmap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -77,7 +77,7 @@ typedef struct GTY(()) bitmap_head_def {\n   bitmap_element *current;\t/* Last element looked at.  */\n   unsigned int indx;\t\t/* Index of last element looked at.  */\n   bitmap_obstack *obstack;\t/* Obstack to allocate elements from.\n-\t\t\t\t   If NULL, then use ggc_alloc.  */\n+\t\t\t\t   If NULL, then use GGC allocation.  */\n #ifdef GATHER_STATISTICS\n   struct bitmap_descriptor GTY((skip)) *desc;\n #endif"}, {"sha": "740ca3588f0c723d35a7bbafdda32799ad13cae6", "filename": "gcc/c-decl.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -590,7 +590,7 @@ bind (tree name, tree decl, struct c_scope *scope, bool invisible,\n       binding_freelist = b->prev;\n     }\n   else\n-    b = GGC_NEW (struct c_binding);\n+    b = ggc_alloc_c_binding ();\n \n   b->shadowed = 0;\n   b->decl = decl;\n@@ -704,7 +704,7 @@ void\n record_inline_static (location_t loc, tree func, tree decl,\n \t\t      enum c_inline_static_type type)\n {\n-  struct c_inline_static *csi = GGC_NEW (struct c_inline_static);\n+  struct c_inline_static *csi = ggc_alloc_c_inline_static ();\n   csi->location = loc;\n   csi->function = func;\n   csi->static_decl = decl;\n@@ -928,7 +928,7 @@ push_scope (void)\n \t  scope_freelist = scope->outer;\n \t}\n       else\n-\tscope = GGC_CNEW (struct c_scope);\n+\tscope = ggc_alloc_cleared_c_scope ();\n \n       /* The FLOAT_CONST_DECIMAL64 pragma applies to nested scopes.  */\n       if (current_scope)\n@@ -3007,7 +3007,7 @@ make_label (location_t location, tree name, bool defining,\n   DECL_CONTEXT (label) = current_function_decl;\n   DECL_MODE (label) = VOIDmode;\n \n-  label_vars = GGC_NEW (struct c_label_vars);\n+  label_vars = ggc_alloc_c_label_vars ();\n   label_vars->shadowed = NULL;\n   set_spot_bindings (&label_vars->label_bindings, defining);\n   label_vars->decls_in_scope = make_tree_vector ();\n@@ -3105,7 +3105,7 @@ lookup_label_for_goto (location_t loc, tree name)\n     {\n       struct c_goto_bindings *g;\n \n-      g = GGC_NEW (struct c_goto_bindings);\n+      g = ggc_alloc_c_goto_bindings ();\n       g->loc = loc;\n       set_spot_bindings (&g->goto_bindings, true);\n       VEC_safe_push (c_goto_bindings_p, gc, label_vars->gotos, g);\n@@ -6987,9 +6987,9 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \t  ensure that this lives as long as the rest of the struct decl.\n \t  All decls in an inline function need to be saved.  */\n \n-\tspace = GGC_CNEW (struct lang_type);\n-\tspace2 = GGC_NEWVAR (struct sorted_fields_type,\n-\t\t\t     sizeof (struct sorted_fields_type) + len * sizeof (tree));\n+\tspace = ggc_alloc_cleared_lang_type (sizeof (struct lang_type));\n+\tspace2 = ggc_alloc_sorted_fields_type\n+\t  (sizeof (struct sorted_fields_type) + len * sizeof (tree));\n \n \tlen = 0;\n \tspace->s = space2;\n@@ -7270,7 +7270,7 @@ finish_enum (tree enumtype, tree values, tree attributes)\n \n   /* Record the min/max values so that we can warn about bit-field\n      enumerations that are too small for the values.  */\n-  lt = GGC_CNEW (struct lang_type);\n+  lt = ggc_alloc_cleared_lang_type (sizeof (struct lang_type));\n   lt->enum_min = minnode;\n   lt->enum_max = maxnode;\n   TYPE_LANG_SPECIFIC (enumtype) = lt;\n@@ -8293,7 +8293,7 @@ void\n c_push_function_context (void)\n {\n   struct language_function *p;\n-  p = GGC_NEW (struct language_function);\n+  p = ggc_alloc_language_function ();\n   cfun->language = p;\n \n   p->base.x_stmt_tree = c_stmt_tree;"}, {"sha": "5370a8e8b329ab425f8b9bd0c00536a0c10803b0", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,13 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* c-pragma.c (push_alignment): Use typed GC allocation.\n+\t(handle_pragma_push_options): Likewise.\n+\n+\t* c-common.c (parse_optimize_options): Likewise.\n+\n+\t* c-common.h (struct sorted_fields_type): Add variable_size GTY\n+\toption.\n+\n 2010-06-07  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-common.c (flag_preprocess_only, flag_undef, flag_no_builtin,"}, {"sha": "7c841b1d07693c66cb60900a8d9e04820c045d43", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -7684,7 +7684,7 @@ parse_optimize_options (tree args, bool attr_p)\n \t\t  next_p = NULL;\n \t\t}\n \n-\t      r = q = (char *) ggc_alloc (len2 + 3);\n+\t      r = q = (char *) ggc_alloc_atomic (len2 + 3);\n \n \t      /* If the user supplied -Oxxx or -fxxx, only allow -Oxxx or -fxxx\n \t\t options.  */"}, {"sha": "6948b8231e8f31453d01b8acdaf82a7b24f13437", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -373,7 +373,7 @@ extern GTY(()) tree c_global_trees[CTI_MAX];\n \n /* In a RECORD_TYPE, a sorted array of the fields of the type, not a\n    tree for size reasons.  */\n-struct GTY(()) sorted_fields_type {\n+struct GTY((variable_size)) sorted_fields_type {\n   int len;\n   tree GTY((length (\"%h.len\"))) elts[1];\n };"}, {"sha": "ab922696dddba8c4c8055a8aa0aa4e028470fa17", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -77,7 +77,7 @@ push_alignment (int alignment, tree id)\n {\n   align_stack * entry;\n \n-  entry = GGC_NEW (align_stack);\n+  entry = ggc_alloc_align_stack ();\n \n   entry->alignment  = alignment;\n   entry->id\t    = id;\n@@ -914,7 +914,7 @@ handle_pragma_push_options (cpp_reader *ARG_UNUSED(dummy))\n       return;\n     }\n \n-  p = GGC_NEW (opt_stack);\n+  p = ggc_alloc_opt_stack ();\n   p->prev = options_stack;\n   options_stack = p;\n "}, {"sha": "04506df176e25391b20fb31983668cc0619e779a", "filename": "gcc/c-parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -86,7 +86,7 @@ c_parse_init (void)\n   if (!c_dialect_objc ())\n     mask |= D_OBJC | D_CXX_OBJC;\n \n-  ridpointers = GGC_CNEWVEC (tree, (int) RID_MAX);\n+  ridpointers = ggc_alloc_cleared_vec_tree ((int) RID_MAX);\n   for (i = 0; i < num_c_common_reswords; i++)\n     {\n       /* If a keyword is disabled, do not enter it into the table\n@@ -8882,7 +8882,7 @@ c_parse_file (void)\n   if (c_parser_peek_token (&tparser)->pragma_kind == PRAGMA_GCC_PCH_PREPROCESS)\n     c_parser_pragma_pch_preprocess (&tparser);\n \n-  the_parser = GGC_NEW (c_parser);\n+  the_parser = ggc_alloc_c_parser ();\n   *the_parser = tparser;\n \n   /* Initialize EH, if we've been told to do so.  */"}, {"sha": "563582ff29646148a9461bb4c55ea796db2792d8", "filename": "gcc/cfg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -84,13 +84,13 @@ void\n init_flow (struct function *the_fun)\n {\n   if (!the_fun->cfg)\n-    the_fun->cfg = GGC_CNEW (struct control_flow_graph);\n+    the_fun->cfg = ggc_alloc_cleared_control_flow_graph ();\n   n_edges_for_function (the_fun) = 0;\n   ENTRY_BLOCK_PTR_FOR_FUNCTION (the_fun)\n-    = GGC_CNEW (struct basic_block_def);\n+    = ggc_alloc_cleared_basic_block_def ();\n   ENTRY_BLOCK_PTR_FOR_FUNCTION (the_fun)->index = ENTRY_BLOCK;\n   EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun)\n-    = GGC_CNEW (struct basic_block_def);\n+    = ggc_alloc_cleared_basic_block_def ();\n   EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun)->index = EXIT_BLOCK;\n   ENTRY_BLOCK_PTR_FOR_FUNCTION (the_fun)->next_bb\n     = EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun);\n@@ -139,7 +139,7 @@ basic_block\n alloc_block (void)\n {\n   basic_block bb;\n-  bb = GGC_CNEW (struct basic_block_def);\n+  bb = ggc_alloc_cleared_basic_block_def ();\n   return bb;\n }\n \n@@ -277,7 +277,7 @@ edge\n unchecked_make_edge (basic_block src, basic_block dst, int flags)\n {\n   edge e;\n-  e = GGC_CNEW (struct edge_def);\n+  e = ggc_alloc_cleared_edge_def ();\n   n_edges++;\n \n   e->src = src;"}, {"sha": "c0d9a4cacc2649b5d70287fe90f91b48c3be9d8f", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -334,9 +334,9 @@ flow_loop_tree_node_remove (struct loop *loop)\n struct loop *\n alloc_loop (void)\n {\n-  struct loop *loop = GGC_CNEW (struct loop);\n+  struct loop *loop = ggc_alloc_cleared_loop ();\n \n-  loop->exits = GGC_CNEW (struct loop_exit);\n+  loop->exits = ggc_alloc_cleared_loop_exit ();\n   loop->exits->next = loop->exits->prev = loop->exits;\n   loop->can_be_parallel = false;\n   loop->single_iv = NULL_TREE;\n@@ -1026,7 +1026,7 @@ rescan_loop_exit (edge e, bool new_edge, bool removed)\n \t   aloop != cloop;\n \t   aloop = loop_outer (aloop))\n \t{\n-\t  exit = GGC_NEW (struct loop_exit);\n+\t  exit = ggc_alloc_loop_exit ();\n \t  exit->e = e;\n \n \t  exit->next = aloop->exits->next;\n@@ -1076,11 +1076,9 @@ record_loop_exits (void)\n   loops_state_set (LOOPS_HAVE_RECORDED_EXITS);\n \n   gcc_assert (current_loops->exits == NULL);\n-  current_loops->exits = htab_create_alloc (2 * number_of_loops (),\n-\t\t\t\t\t    loop_exit_hash,\n-\t\t\t\t\t    loop_exit_eq,\n-\t\t\t\t\t    loop_exit_free,\n-\t\t\t\t\t    ggc_calloc, ggc_free);\n+  current_loops->exits = htab_create_ggc (2 * number_of_loops (),\n+\t\t\t\t\t  loop_exit_hash, loop_exit_eq,\n+\t\t\t\t\t  loop_exit_free);\n \n   FOR_EACH_BB (bb)\n     {"}, {"sha": "bf617373762c00d9051522ecfc0f35c3fccb3ddb", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -3080,7 +3080,7 @@ void\n init_rtl_bb_info (basic_block bb)\n {\n   gcc_assert (!bb->il.rtl);\n-  bb->il.rtl = GGC_CNEW (struct rtl_bb_info);\n+  bb->il.rtl = ggc_alloc_cleared_rtl_bb_info ();\n }\n \n "}, {"sha": "557c205e3d1f45ff5262feffc831130c94a6a6d1", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -442,7 +442,7 @@ cgraph_allocate_node (void)\n     }\n   else\n     {\n-      node = GGC_CNEW (struct cgraph_node);\n+      node = ggc_alloc_cleared_cgraph_node ();\n       node->uid = cgraph_max_uid++;\n     }\n \n@@ -970,7 +970,7 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n     }\n   else\n     {\n-      edge = GGC_NEW (struct cgraph_edge);\n+      edge = ggc_alloc_cgraph_edge ();\n       edge->uid = cgraph_edge_max_uid++;\n     }\n \n@@ -1045,7 +1045,7 @@ cgraph_create_indirect_edge (struct cgraph_node *caller, gimple call_stmt,\n   edge->indirect_unknown_callee = 1;\n   initialize_inline_failed (edge);\n \n-  edge->indirect_info = GGC_CNEW (struct cgraph_indirect_call_info);\n+  edge->indirect_info = ggc_alloc_cleared_cgraph_indirect_call_info ();\n   edge->indirect_info->param_index = -1;\n   edge->indirect_info->ecf_flags = ecf_flags;\n \n@@ -1973,7 +1973,7 @@ cgraph_add_asm_node (tree asm_str)\n {\n   struct cgraph_asm_node *node;\n \n-  node = GGC_CNEW (struct cgraph_asm_node);\n+  node = ggc_alloc_cleared_cgraph_asm_node ();\n   node->asm_str = asm_str;\n   node->order = cgraph_order++;\n   node->next = NULL;"}, {"sha": "0246d5a5b6d37dfeae61f27f2f0bd791b8f1f007", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -4806,8 +4806,7 @@ struct GTY(()) machine_function\n static struct machine_function *\n alpha_init_machine_status (void)\n {\n-  return ((struct machine_function *)\n-\t\tggc_alloc_cleared (sizeof (struct machine_function)));\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n /* Support for frame based VMS condition handlers.  */\n@@ -9904,7 +9903,7 @@ alpha_need_linkage (const char *name, int is_local)\n         alpha_funcs_tree = splay_tree_new_ggc ((splay_tree_compare_fn)\n \t\t\t\t\t       splay_tree_compare_pointers);\n \n-      cfaf = (struct alpha_funcs *) ggc_alloc (sizeof (struct alpha_funcs));\n+      cfaf = ggc_alloc_alpha_funcs ();\n \n       cfaf->links = 0;\n       cfaf->num = ++alpha_funcs_num;\n@@ -9940,7 +9939,7 @@ alpha_need_linkage (const char *name, int is_local)\n   else\n     alpha_links_tree = splay_tree_new_ggc ((splay_tree_compare_fn) strcmp);\n \n-  al = (struct alpha_links *) ggc_alloc (sizeof (struct alpha_links));\n+  al = ggc_alloc_alpha_links ();\n   name = ggc_strdup (name);\n \n   /* Assume external if no definition.  */\n@@ -10012,7 +10011,7 @@ alpha_use_linkage (rtx func, tree cfundecl, int lflag, int rflag)\n       name_len = strlen (name);\n       linksym = (char *) alloca (name_len + 50);\n \n-      al = (struct alpha_links *) ggc_alloc (sizeof (struct alpha_links));\n+      al = ggc_alloc_alpha_links ();\n       al->num = cfaf->num;\n \n       node = splay_tree_lookup (alpha_links_tree, (splay_tree_key) name);"}, {"sha": "e44e94946fbeddeb981f7ad637f4c6b6642dd79c", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -19280,7 +19280,7 @@ static struct machine_function *\n arm_init_machine_status (void)\n {\n   struct machine_function *machine;\n-  machine = (machine_function *) ggc_alloc_cleared (sizeof (machine_function));\n+  machine = ggc_alloc_cleared_machine_function ();\n \n #if ARM_FT_UNKNOWN != 0\n   machine->func_type = ARM_FT_UNKNOWN;"}, {"sha": "531a4128bf31da100dc43f3637196eddd1bf4761", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -243,8 +243,7 @@ static const enum reg_class reg_class_tab[]={\n static struct machine_function *\n avr_init_machine_status (void)\n {\n-  return ((struct machine_function *) \n-          ggc_alloc_cleared (sizeof (struct machine_function)));\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n /* Return register class for register R.  */"}, {"sha": "c187bf3bbc7dd37037cbb2974acaf05502071d4a", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -2634,11 +2634,7 @@ bfin_handle_option (size_t code, const char *arg, int value)\n static struct machine_function *\n bfin_init_machine_status (void)\n {\n-  struct machine_function *f;\n-\n-  f = GGC_CNEW (struct machine_function);\n-\n-  return f;\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n /* Implement the macro OVERRIDE_OPTIONS.  */"}, {"sha": "9d38d0fee47fdab53ce5884271c4f12e30faf44e", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -2583,7 +2583,7 @@ cris_init_expanders (void)\n static struct machine_function *\n cris_init_machine_status (void)\n {\n-  return GGC_CNEW (struct machine_function);\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n /* Split a 2 word move (DI or presumably DF) into component parts."}, {"sha": "7eedd95eab303745ba64f31eb4d312c4d469eaff", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -429,7 +429,7 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)\n     }\n   else\n     {\n-      p = (machopic_indirection *) ggc_alloc (sizeof (machopic_indirection));\n+      p = ggc_alloc_machopic_indirection ();\n       p->symbol = sym_ref;\n       p->ptr_name = xstrdup (buffer);\n       p->stub_p = stub_p;"}, {"sha": "e72dd2af1f9212d262307e30646548cf1520d0f1", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -7054,7 +7054,7 @@ frv_assemble_integer (rtx value, unsigned int size, int aligned_p)\n static struct machine_function *\n frv_init_machine_status (void)\n {\n-  return GGC_CNEW (struct machine_function);\n+  return ggc_alloc_cleared_machine_function ();\n }\n \f\n /* Implement TARGET_SCHED_ISSUE_RATE.  */"}, {"sha": "1bdc6891df3f5b05c9e0656595a36ea438e4ad56", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -10641,7 +10641,7 @@ get_dllimport_decl (tree decl)\n   if (h)\n     return h->to;\n \n-  *loc = h = GGC_NEW (struct tree_map);\n+  *loc = h = ggc_alloc_tree_map ();\n   h->hash = in.hash;\n   h->base.from = decl;\n   h->to = to = build_decl (DECL_SOURCE_LOCATION (decl),\n@@ -19504,7 +19504,7 @@ ix86_init_machine_status (void)\n {\n   struct machine_function *f;\n \n-  f = GGC_CNEW (struct machine_function);\n+  f = ggc_alloc_cleared_machine_function ();\n   f->use_fast_prologue_epilogue_nregs = -1;\n   f->tls_descriptor_call_expanded_p = 0;\n   f->call_abi = ix86_abi;\n@@ -19532,8 +19532,7 @@ assign_386_stack_local (enum machine_mode mode, enum ix86_stack_slot n)\n     if (s->mode == mode && s->n == n)\n       return copy_rtx (s->rtl);\n \n-  s = (struct stack_local_entry *)\n-    ggc_alloc (sizeof (struct stack_local_entry));\n+  s = ggc_alloc_stack_local_entry ();\n   s->n = n;\n   s->mode = mode;\n   s->rtl = assign_stack_local (mode, GET_MODE_SIZE (mode), 0);"}, {"sha": "c20a2ae89fc3885b70d956a0f3a70c18e928e4de", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -576,7 +576,7 @@ i386_pe_record_external_function (tree decl, const char *name)\n {\n   struct extern_list *p;\n \n-  p = (struct extern_list *) ggc_alloc (sizeof *p);\n+  p = ggc_alloc_extern_list ();\n   p->next = extern_head;\n   p->decl = decl;\n   p->name = name;\n@@ -617,7 +617,7 @@ i386_pe_maybe_record_exported_symbol (tree decl, const char *name, int is_data)\n \n   gcc_assert (TREE_PUBLIC (decl));\n \n-  p = (struct export_list *) ggc_alloc (sizeof *p);\n+  p = ggc_alloc_export_list ();\n   p->next = export_head;\n   p->name = name;\n   p->is_data = is_data;"}, {"sha": "a568ee4f849fdde752a4abf2dc6d1bea9cdbaa6b", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -5540,7 +5540,7 @@ void ia64_init_expanders (void)\n static struct machine_function *\n ia64_init_machine_status (void)\n {\n-  return GGC_CNEW (struct machine_function);\n+  return ggc_alloc_cleared_machine_function ();\n }\n \f\n static enum attr_itanium_class ia64_safe_itanium_class (rtx);"}, {"sha": "fc8c4e56789384ff72616d9339b9f4c73fb8cb25", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1385,11 +1385,7 @@ iq2000_va_start (tree valist, rtx nextarg)\n static struct machine_function *\n iq2000_init_machine_status (void)\n {\n-  struct machine_function *f;\n-\n-  f = GGC_CNEW (struct machine_function);\n-\n-  return f;\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n /* Implement TARGET_HANDLE_OPTION.  */"}, {"sha": "3280d14e78eb09f0b4e0dd1bb5018d88f55c4a51", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -435,11 +435,7 @@ m32c_override_options (void)\n static struct machine_function *\n m32c_init_machine_status (void)\n {\n-  struct machine_function *machine;\n-  machine =\n-    (machine_function *) ggc_alloc_cleared (sizeof (machine_function));\n-\n-  return machine;\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n /* Implements INIT_EXPANDERS.  We just set up to call the above"}, {"sha": "4d5e68218e8b78e502db471381c956de85b943db", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -2369,11 +2369,7 @@ mep_register_move_cost (enum machine_mode mode, enum reg_class from, enum reg_cl\n static struct machine_function *\n mep_init_machine_status (void)\n {\n-  struct machine_function *f;\n-\n-  f = (struct machine_function *) ggc_alloc_cleared (sizeof (struct machine_function));\n-\n-  return f;\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n static rtx\n@@ -4234,7 +4230,7 @@ mep_note_pragma_flag (const char *funcname, int flag)\n \n   if (!*slot)\n     {\n-      *slot = GGC_NEW (pragma_entry);\n+      *slot = ggc_alloc_pragma_entry ();\n       (*slot)->flag = 0;\n       (*slot)->used = 0;\n       (*slot)->funcname = ggc_strdup (funcname);"}, {"sha": "a699238ba1c01539f73437d99a0ca77fe58be729", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1217,7 +1217,7 @@ mflip_mips16_use_mips16_p (tree decl)\n   if (!entry)\n     {\n       mips16_flipper = !mips16_flipper;\n-      entry = GGC_NEW (struct mflip_mips16_entry);\n+      entry = ggc_alloc_mflip_mips16_entry ();\n       entry->name = name;\n       entry->mips16_p = mips16_flipper ? !mips_base_mips16 : mips_base_mips16;\n       *slot = entry;\n@@ -5851,7 +5851,7 @@ mips16_local_alias (rtx func)\n       SYMBOL_REF_FLAGS (local) = SYMBOL_REF_FLAGS (func) | SYMBOL_FLAG_LOCAL;\n \n       /* Create a new structure to represent the mapping.  */\n-      alias = GGC_NEW (struct mips16_local_alias);\n+      alias = ggc_alloc_mips16_local_alias ();\n       alias->func = func;\n       alias->local = local;\n       *slot = alias;\n@@ -15221,8 +15221,7 @@ mips_set_current_function (tree fndecl)\n static struct machine_function *\n mips_init_machine_status (void)\n {\n-  return ((struct machine_function *)\n-\t  ggc_alloc_cleared (sizeof (struct machine_function)));\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n /* Return the processor associated with the given ISA level, or null"}, {"sha": "4b35e06df4f97c31acb6095626b1a19bdc4dbe1b", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -263,7 +263,7 @@ mmix_init_expanders (void)\n static struct machine_function *\n mmix_init_machine_status (void)\n {\n-  return GGC_CNEW (struct machine_function);\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n /* DATA_ALIGNMENT."}, {"sha": "b87b80f4744d6b37ec8176f5c65d411c0e76d97b", "filename": "gcc/config/moxie/moxie.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -205,7 +205,7 @@ struct GTY(()) machine_function\n static struct machine_function *\n moxie_init_machine_status (void)\n {\n-  return GGC_CNEW (struct machine_function);\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n "}, {"sha": "024053e413fd99c4fdfea4d31f64215745792934", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -558,7 +558,7 @@ pa_init_builtins (void)\n static struct machine_function *\n pa_init_machine_status (void)\n {\n-  return GGC_CNEW (machine_function);\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n /* If FROM is a probable pointer register, mark TO as a probable\n@@ -5375,13 +5375,11 @@ get_deferred_plabel (rtx symbol)\n       tree id;\n \n       if (deferred_plabels == 0)\n-\tdeferred_plabels = (struct deferred_plabel *)\n-\t  ggc_alloc (sizeof (struct deferred_plabel));\n+\tdeferred_plabels =  ggc_alloc_deferred_plabel ();\n       else\n-\tdeferred_plabels = (struct deferred_plabel *)\n-\t  ggc_realloc (deferred_plabels,\n-\t\t       ((n_deferred_plabels + 1)\n-\t\t\t* sizeof (struct deferred_plabel)));\n+        deferred_plabels = GGC_RESIZEVEC (struct deferred_plabel,\n+                                          deferred_plabels,\n+                                          n_deferred_plabels + 1);\n \n       i = n_deferred_plabels++;\n       deferred_plabels[i].internal_label = gen_label_rtx ();"}, {"sha": "a4f847d99bdb8593739afab4ae8e6efcec9b83b4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -12569,7 +12569,7 @@ builtin_function_type (enum machine_mode mode_ret, enum machine_mode mode_arg0,\n   found = htab_find_slot (builtin_hash_table, &h, INSERT);\n   if (*found == NULL)\n     {\n-      h2 = GGC_NEW (struct builtin_hash_struct);\n+      h2 = ggc_alloc_builtin_hash_struct ();\n       *h2 = h;\n       *found = (void *)h2;\n       args = void_list_node;\n@@ -14465,7 +14465,7 @@ rs6000_got_register (rtx value ATTRIBUTE_UNUSED)\n static struct machine_function *\n rs6000_init_machine_status (void)\n {\n-  return GGC_CNEW (machine_function);\n+  return ggc_alloc_cleared_machine_function ();\n }\n \f\n /* These macros test for integers and extract the low-order bits.  */\n@@ -21194,7 +21194,7 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \ttoc_hash_table = htab_create_ggc (1021, toc_hash_function,\n \t\t\t\t\t  toc_hash_eq, NULL);\n \n-      h = GGC_NEW (struct toc_hash_struct);\n+      h = ggc_alloc_toc_hash_struct ();\n       h->key = x;\n       h->key_mode = mode;\n       h->labelno = labelno;"}, {"sha": "1b742357f26e57279f3c598c9fbeded901831550", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1453,7 +1453,7 @@ s390_narrow_logical_operator (enum rtx_code code, rtx *memop, rtx *immop)\n static struct machine_function *\n s390_init_machine_status (void)\n {\n-  return GGC_CNEW (struct machine_function);\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n /* Change optimizations to be performed, depending on the"}, {"sha": "3e20f16dc33de478cb149ab3c06667708ff9e7fb", "filename": "gcc/config/score/score3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fscore%2Fscore3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fscore%2Fscore3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1186,7 +1186,7 @@ score3_output_external (FILE *file ATTRIBUTE_UNUSED,\n \n   if (score3_in_small_data_p (decl))\n     {\n-      p = (struct extern_list *) ggc_alloc (sizeof (struct extern_list));\n+      p = ggc_alloc_extern_list ();\n       p->next = extern_head;\n       p->name = name;\n       p->size = int_size_in_bytes (TREE_TYPE (decl));"}, {"sha": "464d97cee22b2901b39d145b8e2fb9a0652f639c", "filename": "gcc/config/score/score7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1174,7 +1174,7 @@ score7_output_external (FILE *file ATTRIBUTE_UNUSED,\n \n   if (score7_in_small_data_p (decl))\n     {\n-      p = (struct extern_list *) ggc_alloc (sizeof (struct extern_list));\n+      p = ggc_alloc_extern_list ();\n       p->next = extern_head;\n       p->name = name;\n       p->size = int_size_in_bytes (TREE_TYPE (decl));"}, {"sha": "8b44dbeb80dd8182f89a5310718cc03c6e64c46b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -9032,7 +9032,7 @@ sparc_can_output_mi_thunk (const_tree thunk_fndecl ATTRIBUTE_UNUSED,\n static struct machine_function *\n sparc_init_machine_status (void)\n {\n-  return GGC_CNEW (struct machine_function);\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n /* Locate some local-dynamic symbol still in use by this function"}, {"sha": "fe66711af3909c78a742808f6c6d9a19225e9054", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1281,7 +1281,7 @@ xtensa_expand_nonlocal_goto (rtx *operands)\n static struct machine_function *\n xtensa_init_machine_status (void)\n {\n-  return GGC_CNEW (struct machine_function);\n+  return ggc_alloc_cleared_machine_function ();\n }\n \n "}, {"sha": "931cbe141ebee3e7ec2c777b7203bad0d120af42", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,52 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* typeck2.c (abstract_virtuals_error): Use typed GC allocation.\n+\n+\t* pt.c (maybe_process_partial_specialization): Likewise.\n+\t(register_specialization): Likewise.\n+\t(add_pending_template): Likewise.\n+\t(lookup_template_class): Likewise.\n+\t(push_tinst_level): Likewise.\n+\n+\t* parser.c (cp_lexer_new_main): Likewise.\n+\t(cp_lexer_new_from_tokens): Likewise.\n+\t(cp_token_cache_new): Likewise.\n+\t(cp_parser_context_new): Likewise.\n+\t(cp_parser_new): Likewise.\n+\t(cp_parser_nested_name_specifier_opt): Likewise.\n+\t(cp_parser_template_id): Likewise.\n+\n+\t* name-lookup.c (binding_entry_make): Likewise.\n+\t(binding_table_construct): Likewise.\n+\t(binding_table_new): Likewise.\n+\t(cxx_binding_make): Likewise.\n+\t(pushdecl_maybe_friend): Likewise.\n+\t(begin_scope): Likewise.\n+\t(push_to_top_level): Likewise.\n+\n+\t* lex.c (init_reswords): Likewise.\n+\t(retrofit_lang_decl): Likewise.\n+\t(cxx_dup_lang_specific_decl): Likewise.\n+\t(copy_lang_type): Likewise.\n+\t(cxx_make_type): Likewise.\n+\n+\t* decl.c (make_label_decl): Likewise.\n+\t(check_goto): Likewise.\n+\t(start_preparsed_function): Likewise.\n+\t(save_function_data): Likewise.\n+\n+\t* cp-tree.h (TYPE_SET_PTRMEMFUNC_TYPE): Likewise.\n+\n+\t* cp-objcp-common.c (decl_shadowed_for_var_insert): Likewise.\n+\n+\t* class.c (finish_struct_1): Likewise.\n+\n+\t* cp-tree.h (struct lang_type): Add variable_size GTY option.\n+\t(struct lang_decl): Likewise.\n+\n+\t* parser.c (cp_parser_new): Update comment to not reference\n+\tggc_alloc.\n+\n 2010-06-07  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/44366"}, {"sha": "14224aa694d4097ab0140420cafb227cb6e883c8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -5437,9 +5437,8 @@ finish_struct_1 (tree t)\n   n_fields = count_fields (TYPE_FIELDS (t));\n   if (n_fields > 7)\n     {\n-      struct sorted_fields_type *field_vec = GGC_NEWVAR\n-\t (struct sorted_fields_type,\n-\t  sizeof (struct sorted_fields_type) + n_fields * sizeof (tree));\n+      struct sorted_fields_type *field_vec = ggc_alloc_sorted_fields_type\n+\t (sizeof (struct sorted_fields_type) + n_fields * sizeof (tree));\n       field_vec->len = n_fields;\n       add_fields_to_record_type (TYPE_FIELDS (t), field_vec, 0);\n       qsort (field_vec->elts, n_fields, sizeof (tree),"}, {"sha": "9cfe7702acade01de38d1a75a4aa506a516248aa", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -203,7 +203,7 @@ decl_shadowed_for_var_insert (tree from, tree to)\n   struct tree_decl_map *h;\n   void **loc;\n \n-  h = GGC_NEW (struct tree_decl_map);\n+  h = ggc_alloc_tree_decl_map ();\n   h->base.from = from;\n   h->to = to;\n   loc = htab_find_slot_with_hash (shadowed_var_for_decl, h, DECL_UID (from),"}, {"sha": "eaf34591cc9ba4cc828da950cfb6e2c0b49f3245", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1333,7 +1333,7 @@ struct GTY(()) lang_type_ptrmem {\n   tree record;\n };\n \n-struct GTY(()) lang_type {\n+struct GTY((variable_size)) lang_type {\n   union lang_type_u\n   {\n     struct lang_type_header GTY((skip (\"\"))) h;\n@@ -1884,7 +1884,7 @@ struct GTY(()) lang_decl_parm {\n    union rather than a struct containing a union as its only field, but\n    tree.h declares it as a struct.  */\n \n-struct GTY(()) lang_decl {\n+struct GTY((variable_size)) lang_decl {\n   union GTY((desc (\"%h.base.selector\"))) lang_decl_u {\n     struct lang_decl_base GTY ((default)) base;\n     struct lang_decl_min GTY((tag (\"0\"))) min;\n@@ -3271,8 +3271,8 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (TYPE_LANG_SPECIFIC (NODE) == NULL)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tTYPE_LANG_SPECIFIC (NODE) = GGC_CNEWVAR\t\t\t\t\\\n-\t (struct lang_type, sizeof (struct lang_type_ptrmem));\t\t\\\n+\tTYPE_LANG_SPECIFIC (NODE) = ggc_alloc_cleared_lang_type\t\t\\\n+\t (sizeof (struct lang_type_ptrmem));\t\t\t\t\\\n \tTYPE_LANG_SPECIFIC (NODE)->u.ptrmem.h.is_lang_type_class = 0;\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     TYPE_LANG_SPECIFIC (NODE)->u.ptrmem.record = (VALUE);\t\t\\"}, {"sha": "706eee9b6669085cd2aedf19b6ac1995915cd6bf", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -2449,7 +2449,7 @@ make_label_decl (tree id, int local_p)\n   /* Record this label on the list of labels used in this function.\n      We do this before calling make_label_decl so that we get the\n      IDENTIFIER_LABEL_VALUE before the new label is declared.  */\n-  ent = GGC_CNEW (struct named_label_entry);\n+  ent = ggc_alloc_cleared_named_label_entry ();\n   ent->label_decl = decl;\n \n   slot = htab_find_slot (named_labels, ent, INSERT);\n@@ -2669,7 +2669,7 @@ check_goto (tree decl)\n \t  && ent->uses->names_in_scope == current_binding_level->names)\n \treturn;\n \n-      new_use = GGC_NEW (struct named_label_use_entry);\n+      new_use = ggc_alloc_named_label_use_entry ();\n       new_use->binding_level = current_binding_level;\n       new_use->names_in_scope = current_binding_level->names;\n       new_use->o_goto_locus = input_location;\n@@ -12016,7 +12016,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \n   /* Initialize the language data structures.  Whenever we start\n      a new function, we destroy temporaries in the usual way.  */\n-  cfun->language = GGC_CNEW (struct language_function);\n+  cfun->language = ggc_alloc_cleared_language_function ();\n   current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n   current_binding_level = bl;\n \n@@ -12317,7 +12317,7 @@ save_function_data (tree decl)\n   gcc_assert (!DECL_PENDING_INLINE_P (decl));\n \n   /* Make a copy.  */\n-  f = GGC_NEW (struct language_function);\n+  f = ggc_alloc_language_function ();\n   memcpy (f, cp_function_chain, sizeof (struct language_function));\n   DECL_SAVED_FUNCTION_DATA (decl) = f;\n "}, {"sha": "9e3b57b75ef8656f4f12acb76debaa6307c89109", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -184,7 +184,7 @@ init_reswords (void)\n   /* The Objective-C keywords are all context-dependent.  */\n   mask |= D_OBJC;\n \n-  ridpointers = GGC_CNEWVEC (tree, (int) RID_MAX);\n+  ridpointers = ggc_alloc_cleared_vec_tree ((int) RID_MAX);\n   for (i = 0; i < num_c_common_reswords; i++)\n     {\n       if (c_common_reswords[i].disable & D_CONLY)\n@@ -540,7 +540,7 @@ retrofit_lang_decl (tree t)\n   else\n     gcc_unreachable ();\n \n-  ld = GGC_CNEWVAR (struct lang_decl, size);\n+  ld = ggc_alloc_cleared_lang_decl (size);\n \n   ld->u.base.selector = sel;\n \n@@ -581,7 +581,7 @@ cxx_dup_lang_specific_decl (tree node)\n   else\n     gcc_unreachable ();\n \n-  ld = GGC_NEWVAR (struct lang_decl, size);\n+  ld = ggc_alloc_lang_decl (size);\n   memcpy (ld, DECL_LANG_SPECIFIC (node), size);\n   DECL_LANG_SPECIFIC (node) = ld;\n \n@@ -618,7 +618,7 @@ copy_lang_type (tree node)\n     size = sizeof (struct lang_type);\n   else\n     size = sizeof (struct lang_type_ptrmem);\n-  lt = GGC_NEWVAR (struct lang_type, size);\n+  lt = ggc_alloc_lang_type (size);\n   memcpy (lt, TYPE_LANG_SPECIFIC (node), size);\n   TYPE_LANG_SPECIFIC (node) = lt;\n \n@@ -649,7 +649,8 @@ cxx_make_type (enum tree_code code)\n   if (RECORD_OR_UNION_CODE_P (code)\n       || code == BOUND_TEMPLATE_TEMPLATE_PARM)\n     {\n-      struct lang_type *pi = GGC_CNEW (struct lang_type);\n+      struct lang_type *pi\n+          = ggc_alloc_cleared_lang_type (sizeof (struct lang_type));\n \n       TYPE_LANG_SPECIFIC (t) = pi;\n       pi->u.c.h.is_lang_type_class = 1;"}, {"sha": "db4246c5f70c1ef719d8c3b8268a30f9c7e0a040", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -102,7 +102,7 @@ binding_entry_make (tree name, tree type)\n       free_binding_entry = entry->chain;\n     }\n   else\n-    entry = GGC_NEW (struct binding_entry_s);\n+    entry = ggc_alloc_binding_entry_s ();\n \n   entry->name = name;\n   entry->type = type;\n@@ -144,7 +144,7 @@ binding_table_construct (binding_table table, size_t chain_count)\n {\n   table->chain_count = chain_count;\n   table->entry_count = 0;\n-  table->chain = GGC_CNEWVEC (binding_entry, table->chain_count);\n+  table->chain = ggc_alloc_cleared_vec_binding_entry (table->chain_count);\n }\n \n /* Make TABLE's entries ready for reuse.  */\n@@ -178,7 +178,7 @@ binding_table_free (binding_table table)\n static inline binding_table\n binding_table_new (size_t chain_count)\n {\n-  binding_table table = GGC_NEW (struct binding_table_s);\n+  binding_table table = ggc_alloc_binding_table_s ();\n   table->chain = NULL;\n   binding_table_construct (table, chain_count);\n   return table;\n@@ -292,7 +292,7 @@ cxx_binding_make (tree value, tree type)\n       free_bindings = binding->previous;\n     }\n   else\n-    binding = GGC_NEW (cxx_binding);\n+    binding = ggc_alloc_cxx_binding ();\n \n   cxx_binding_init (binding, value, type);\n \n@@ -707,7 +707,7 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t\t      = htab_create_ggc (20, cxx_int_tree_map_hash,\n \t\t\t\t\t cxx_int_tree_map_eq, NULL);\n \n-\t\t  h = GGC_NEW (struct cxx_int_tree_map);\n+\t\t  h = ggc_alloc_cxx_int_tree_map ();\n \t\t  h->uid = DECL_UID (x);\n \t\t  h->to = t;\n \t\t  loc = htab_find_slot_with_hash\n@@ -1384,7 +1384,7 @@ begin_scope (scope_kind kind, tree entity)\n       free_binding_level = scope->level_chain;\n     }\n   else\n-    scope = GGC_CNEW (cxx_scope);\n+    scope = ggc_alloc_cleared_cxx_scope ();\n \n   scope->this_entity = entity;\n   scope->more_cleanups_ok = true;\n@@ -5406,7 +5406,7 @@ push_to_top_level (void)\n   bool need_pop;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  s = GGC_CNEW (struct saved_scope);\n+  s = ggc_alloc_cleared_saved_scope ();\n \n   b = scope_chain ? current_binding_level : 0;\n "}, {"sha": "0a7006a7d1bc224a0cc9798bcdba78a7b8ba0a6c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -393,7 +393,7 @@ cp_lexer_new_main (void)\n   c_common_no_more_pch ();\n \n   /* Allocate the memory.  */\n-  lexer = GGC_CNEW (cp_lexer);\n+  lexer = ggc_alloc_cleared_cp_lexer ();\n \n #ifdef ENABLE_CHECKING\n   /* Initially we are not debugging.  */\n@@ -404,7 +404,7 @@ cp_lexer_new_main (void)\n \n   /* Create the buffer.  */\n   alloc = CP_LEXER_BUFFER_SIZE;\n-  buffer = GGC_NEWVEC (cp_token, alloc);\n+  buffer = ggc_alloc_vec_cp_token (alloc);\n \n   /* Put the first token in the buffer.  */\n   space = alloc;\n@@ -445,7 +445,7 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n {\n   cp_token *first = cache->first;\n   cp_token *last = cache->last;\n-  cp_lexer *lexer = GGC_CNEW (cp_lexer);\n+  cp_lexer *lexer = ggc_alloc_cleared_cp_lexer ();\n \n   /* We do not own the buffer.  */\n   lexer->buffer = NULL;\n@@ -946,7 +946,7 @@ cp_lexer_stop_debugging (cp_lexer* lexer)\n static cp_token_cache *\n cp_token_cache_new (cp_token *first, cp_token *last)\n {\n-  cp_token_cache *cache = GGC_NEW (cp_token_cache);\n+  cp_token_cache *cache = ggc_alloc_cp_token_cache ();\n   cache->first = first;\n   cache->last = last;\n   return cache;\n@@ -1496,7 +1496,7 @@ cp_parser_context_new (cp_parser_context* next)\n       memset (context, 0, sizeof (*context));\n     }\n   else\n-    context = GGC_CNEW (cp_parser_context);\n+    context = ggc_alloc_cleared_cp_parser_context ();\n \n   /* No errors have occurred yet in this context.  */\n   context->status = CP_PARSER_STATUS_KIND_NO_ERROR;\n@@ -3093,7 +3093,7 @@ cp_parser_new (void)\n   cp_lexer *lexer;\n   unsigned i;\n \n-  /* cp_lexer_new_main is called before calling ggc_alloc because\n+  /* cp_lexer_new_main is called before doing GC allocation because\n      cp_lexer_new_main might load a PCH file.  */\n   lexer = cp_lexer_new_main ();\n \n@@ -3102,7 +3102,7 @@ cp_parser_new (void)\n   for (i = 0; i < sizeof (binops) / sizeof (binops[0]); i++)\n     binops_by_token[binops[i].token_type] = binops[i];\n \n-  parser = GGC_CNEW (cp_parser);\n+  parser = ggc_alloc_cleared_cp_parser ();\n   parser->lexer = lexer;\n   parser->context = cp_parser_context_new (NULL);\n \n@@ -4605,7 +4605,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n       token->type = CPP_NESTED_NAME_SPECIFIER;\n       /* Retrieve any deferred checks.  Do not pop this access checks yet\n \t so the memory will not be reclaimed during token replacing below.  */\n-      token->u.tree_check_value = GGC_CNEW (struct tree_check);\n+      token->u.tree_check_value = ggc_alloc_cleared_tree_check ();\n       token->u.tree_check_value->value = parser->scope;\n       token->u.tree_check_value->checks = get_deferred_access_checks ();\n       token->u.tree_check_value->qualifying_scope =\n@@ -11275,7 +11275,7 @@ cp_parser_template_id (cp_parser *parser,\n       token->type = CPP_TEMPLATE_ID;\n       /* Retrieve any deferred checks.  Do not pop this access checks yet\n \t so the memory will not be reclaimed during token replacing below.  */\n-      token->u.tree_check_value = GGC_CNEW (struct tree_check);\n+      token->u.tree_check_value = ggc_alloc_cleared_tree_check ();\n       token->u.tree_check_value->value = template_id;\n       token->u.tree_check_value->checks = get_deferred_access_checks ();\n       token->keyword = RID_MAX;"}, {"sha": "58b746fe16db827e746cf6c7767a1b535e4086ca", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -888,7 +888,7 @@ maybe_process_partial_specialization (tree type)\n \n \t\t  slot = (spec_entry **)\n \t\t    htab_find_slot (type_specializations, &elt, INSERT);\n-\t\t  *slot = GGC_NEW (spec_entry);\n+\t\t  *slot = ggc_alloc_spec_entry ();\n \t\t  **slot = elt;\n \t\t}\n \t      else if (COMPLETE_OR_OPEN_TYPE_P (inst))\n@@ -1401,7 +1401,7 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n   if (!optimize_specialization_lookup_p (tmpl))\n     {\n       gcc_assert (tmpl && args && spec);\n-      *slot = GGC_NEW (spec_entry);\n+      *slot = ggc_alloc_spec_entry ();\n       **slot = elt;\n       if (TREE_CODE (spec) == FUNCTION_DECL && DECL_NAMESPACE_SCOPE_P (spec)\n \t  && PRIMARY_TEMPLATE_P (tmpl)\n@@ -6155,7 +6155,7 @@ add_pending_template (tree d)\n   if (level)\n     push_tinst_level (d);\n \n-  pt = GGC_NEW (struct pending_template);\n+  pt = ggc_alloc_pending_template ();\n   pt->next = NULL;\n   pt->tinst = current_tinst_level;\n   if (last_pending_template)\n@@ -6718,7 +6718,7 @@ lookup_template_class (tree d1,\n       elt.spec = t;\n       slot = (spec_entry **) htab_find_slot_with_hash (type_specializations,\n \t\t\t\t\t\t       &elt, hash, INSERT);\n-      *slot = GGC_NEW (spec_entry);\n+      *slot = ggc_alloc_spec_entry ();\n       **slot = elt;\n \n       /* Note this use of the partial instantiation so we can check it\n@@ -7076,7 +7076,7 @@ push_tinst_level (tree d)\n       return 0;\n     }\n \n-  new_level = GGC_NEW (struct tinst_level);\n+  new_level = ggc_alloc_tinst_level ();\n   new_level->decl = d;\n   new_level->locus = input_location;\n   new_level->in_system_header_p = in_system_header;"}, {"sha": "335b1f3499a0b4baaa2d016c69747a2a12c44595", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -352,7 +352,7 @@ abstract_virtuals_error (tree decl, tree type)\n       slot = htab_find_slot_with_hash (abstract_pending_vars, type,\n \t\t\t\t      (hashval_t)TYPE_UID (type), INSERT);\n \n-      pat = GGC_NEW (struct pending_abstract_type);\n+      pat = ggc_alloc_pending_abstract_type ();\n       pat->type = type;\n       pat->decl = decl;\n       pat->locus = ((decl && DECL_P (decl))"}, {"sha": "be1e6fdcd0d8bc6f79c2db119c9a3650a2becaa2", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1004,7 +1004,7 @@ dbxout_init (const char *input_file_name)\n   const char *mapped_name;\n \n   typevec_len = 100;\n-  typevec = GGC_CNEWVEC (struct typeinfo, typevec_len);\n+  typevec = ggc_alloc_cleared_vec_typeinfo (typevec_len);\n \n   /* stabstr_ob contains one string, which will be just fine with\n      1-byte alignment.  */"}, {"sha": "05a279c7d7c14a6bb6b18216f4b03edfb06f80f9", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -149,20 +149,17 @@ option is a fragment of C code that calculates the length.\n The second case is when a structure or a global variable contains a\n pointer to an array, like this:\n @smallexample\n-tree *\n-  GTY ((length (\"%h.regno_pointer_align_length\"))) regno_decl;\n+struct gimple_omp_for_iter * GTY((length (\"%h.collapse\"))) iter;\n @end smallexample\n-In this case, @code{regno_decl} has been allocated by writing something like\n+In this case, @code{iter} has been allocated by writing something like\n @smallexample\n-  x->regno_decl =\n-    ggc_alloc (x->regno_pointer_align_length * sizeof (tree));\n+  x->iter = ggc_alloc_cleared_vec_gimple_omp_for_iter (collapse);\n @end smallexample\n-and the @code{length} provides the length of the field.\n+and the @code{collapse} provides the length of the field.\n \n This second use of @code{length} also works on global variables, like:\n @verbatim\n-  static GTY((length (\"reg_base_value_size\")))\n-    rtx *reg_base_value;\n+static GTY((length(\"reg_known_value_size\"))) rtx *reg_known_value;\n @end verbatim\n \n @findex skip\n@@ -353,6 +350,30 @@ of pointers.  @code{reorder} functions can be expensive.  When\n possible, it is better to depend on properties of the data, like an ID\n number or the hash of a string instead.\n \n+@findex variable_size\n+@item variable_size\n+\n+The type machinery expects the types to be of constant size.  When this\n+is not true, for example, with structs that have array fields or unions,\n+the type machinery cannot tell how many bytes need to be allocated at \n+each allocation.  The @code{variable_size} is used to mark such types.\n+The type machinery then provides allocators that take a parameter \n+indicating an exact size of object being allocated.  \n+\n+For example,\n+@smallexample\n+struct GTY((variable_size)) sorted_fields_type @{\n+  int len;\n+  tree GTY((length (\"%h.len\"))) elts[1];\n+@};\n+@end smallexample\n+\n+Then the objects of @code{struct sorted_fields_type} are allocated in GC \n+memory as follows:\n+@smallexample\n+  field_vec = ggc_alloc_sorted_fields_type (size);\n+@end smallexample\n+\n @findex special\n @item special (\"@var{name}\")\n "}, {"sha": "12f7d81b68f4214a4ec3a1360e5f6e43d7ef164d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -924,7 +924,7 @@ used to initialize the @code{machine} of that structure.\n \n @code{struct machine_function} structures are expected to be freed by GC@.\n Generally, any memory that they reference must be allocated by using\n-@code{ggc_alloc}, including the structure itself.\n+GC allocation, including the structure itself.\n @end deftypevar\n \n @node Storage Layout"}, {"sha": "8e16a21d0314cb8df953f02dc4cdc7471d433e11", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -816,7 +816,9 @@ dw2_force_const_mem (rtx x, bool is_public)\n   if (! indirect_pool)\n     /* We use strcmp, rather than just comparing pointers, so that the\n        sort order will not depend on the host system.  */\n-    indirect_pool = splay_tree_new_ggc (splay_tree_compare_strings);\n+    indirect_pool = splay_tree_new_ggc (splay_tree_compare_strings,\n+\t\t\t\t\tggc_alloc_splay_tree_str_tree_node_splay_tree_s,\n+\t\t\t\t\tggc_alloc_splay_tree_str_tree_node_splay_tree_node_s);\n \n   gcc_assert (GET_CODE (x) == SYMBOL_REF);\n "}, {"sha": "6cbe8dc092c18847b40795c236711d182f6adf8c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -722,7 +722,7 @@ dwarf_cfi_name (unsigned int cfi_opc)\n static inline dw_cfi_ref\n new_cfi (void)\n {\n-  dw_cfi_ref cfi = GGC_NEW (dw_cfi_node);\n+  dw_cfi_ref cfi = ggc_alloc_dw_cfi_node ();\n \n   cfi->dw_cfi_next = NULL;\n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = 0;\n@@ -1694,7 +1694,7 @@ queue_reg_save (const char *label, rtx reg, rtx sreg, HOST_WIDE_INT offset)\n \n   if (q == NULL)\n     {\n-      q = GGC_NEW (struct queued_reg_save);\n+      q = ggc_alloc_queued_reg_save ();\n       q->next = queued_reg_saves;\n       queued_reg_saves = q;\n     }\n@@ -4049,7 +4049,7 @@ void\n dwarf2out_frame_init (void)\n {\n   /* Allocate the initial hunk of the fde_table.  */\n-  fde_table = GGC_CNEWVEC (dw_fde_node, FDE_TABLE_INCREMENT);\n+  fde_table = ggc_alloc_cleared_vec_dw_fde_node (FDE_TABLE_INCREMENT);\n   fde_table_allocated = FDE_TABLE_INCREMENT;\n   fde_table_in_use = 0;\n \n@@ -4605,7 +4605,7 @@ static inline dw_loc_descr_ref\n new_loc_descr (enum dwarf_location_atom op, unsigned HOST_WIDE_INT oprnd1,\n \t       unsigned HOST_WIDE_INT oprnd2)\n {\n-  dw_loc_descr_ref descr = GGC_CNEW (dw_loc_descr_node);\n+  dw_loc_descr_ref descr = ggc_alloc_cleared_dw_loc_descr_node ();\n \n   descr->dw_loc_opc = op;\n   descr->dw_loc_oprnd1.val_class = dw_val_class_unsigned_const;\n@@ -7058,8 +7058,7 @@ find_AT_string (const char *str)\n \t\t\t\t   htab_hash_string (str), INSERT);\n   if (*slot == NULL)\n     {\n-      node = (struct indirect_string_node *)\n-\t       ggc_alloc_cleared (sizeof (struct indirect_string_node));\n+      node = ggc_alloc_cleared_indirect_string_node ();\n       node->str = ggc_strdup (str);\n       *slot = node;\n     }\n@@ -7684,7 +7683,7 @@ splice_child_die (dw_die_ref parent, dw_die_ref child)\n static inline dw_die_ref\n new_die (enum dwarf_tag tag_value, dw_die_ref parent_die, tree t)\n {\n-  dw_die_ref die = GGC_CNEW (die_node);\n+  dw_die_ref die = ggc_alloc_cleared_die_node ();\n \n   die->die_tag = tag_value;\n \n@@ -7694,7 +7693,7 @@ new_die (enum dwarf_tag tag_value, dw_die_ref parent_die, tree t)\n     {\n       limbo_die_node *limbo_node;\n \n-      limbo_node = GGC_CNEW (limbo_die_node);\n+      limbo_node = ggc_alloc_cleared_limbo_die_node ();\n       limbo_node->die = die;\n       limbo_node->created_for = t;\n       limbo_node->next = limbo_die_list;\n@@ -7957,7 +7956,7 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n   slot = htab_find_slot_with_hash (decl_loc_table, decl, decl_id, INSERT);\n   if (*slot == NULL)\n     {\n-      temp = GGC_CNEW (var_loc_list);\n+      temp = ggc_alloc_cleared_var_loc_list ();\n       temp->decl_id = decl_id;\n       *slot = temp;\n     }\n@@ -8047,7 +8046,7 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n \t      memset (loc, '\\0', sizeof (*loc));\n \t    }\n \t  else\n-\t    loc = GGC_CNEW (struct var_loc_node);\n+\t    loc = ggc_alloc_cleared_var_loc_node ();\n \t  if (bitsize == -1 || piece_loc == NULL)\n \t    loc->loc = construct_piece_list (loc_note, bitpos, bitsize);\n \t  else\n@@ -8064,7 +8063,7 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n     }\n   else\n     {\n-      loc = GGC_CNEW (struct var_loc_node);\n+      loc = ggc_alloc_cleared_var_loc_node ();\n       temp->first = loc;\n       temp->last = loc;\n       loc->loc = construct_piece_list (loc_note, bitpos, bitsize);\n@@ -9554,7 +9553,7 @@ clone_die (dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  clone = GGC_CNEW (die_node);\n+  clone = ggc_alloc_cleared_die_node ();\n   clone->die_tag = die->die_tag;\n \n   for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n@@ -9595,7 +9594,7 @@ clone_as_declaration (dw_die_ref die)\n   if (decl != NULL)\n     return clone_die (decl);\n \n-  clone = GGC_CNEW (die_node);\n+  clone = ggc_alloc_cleared_die_node ();\n   clone->die_tag = die->die_tag;\n \n   for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n@@ -9814,7 +9813,7 @@ break_out_comdat_types (dw_die_ref die)\n         unit = new_die (DW_TAG_type_unit, NULL, NULL);\n         add_AT_unsigned (unit, DW_AT_language,\n                          get_AT_unsigned (comp_unit_die, DW_AT_language));\n-        type_node = GGC_CNEW (comdat_type_node);\n+        type_node = ggc_alloc_cleared_comdat_type_node ();\n         type_node->root_die = unit;\n         type_node->next = comdat_type_list;\n         comdat_type_list = type_node;\n@@ -10612,7 +10611,7 @@ static inline dw_loc_list_ref\n new_loc_list (dw_loc_descr_ref expr, const char *begin, const char *end,\n \t      const char *section)\n {\n-  dw_loc_list_ref retlist = GGC_CNEW (dw_loc_list_node);\n+  dw_loc_list_ref retlist = ggc_alloc_cleared_dw_loc_list_node ();\n \n   retlist->begin = begin;\n   retlist->end = end;\n@@ -14133,7 +14132,8 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  if (SCALAR_FLOAT_MODE_P (mode))\n \t    {\n \t      unsigned int length = GET_MODE_SIZE (mode);\n-\t      unsigned char *array = GGC_NEWVEC (unsigned char, length);\n+\t      unsigned char *array\n+                  = (unsigned char*) ggc_alloc_atomic (length);\n \n \t      insert_float (rtl, array);\n \t      loc_result->dw_loc_oprnd2.val_class = dw_val_class_vec;\n@@ -14158,7 +14158,8 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n \t{\n \t  unsigned int elt_size = GET_MODE_UNIT_SIZE (GET_MODE (rtl));\n \t  unsigned int length = CONST_VECTOR_NUNITS (rtl);\n-\t  unsigned char *array = GGC_NEWVEC (unsigned char, length * elt_size);\n+\t  unsigned char *array = (unsigned char *)\n+\t    ggc_alloc_atomic (length * elt_size);\n \t  unsigned int i;\n \t  unsigned char *p;\n \n@@ -14642,12 +14643,12 @@ add_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref)\n   list = list->dw_loc_next;\n   while (list)\n     {\n-      copy = GGC_CNEW (dw_loc_descr_node);\n+      copy = ggc_alloc_dw_loc_descr_node ();\n       memcpy (copy, ref, sizeof (dw_loc_descr_node));\n       add_loc_descr (&list->expr, copy);\n       while (copy->dw_loc_next)\n \t{\n-\t  dw_loc_descr_ref new_copy = GGC_CNEW (dw_loc_descr_node);\n+\t  dw_loc_descr_ref new_copy = ggc_alloc_dw_loc_descr_node ();\n \t  memcpy (new_copy, copy->dw_loc_next, sizeof (dw_loc_descr_node));\n \t  copy->dw_loc_next = new_copy;\n \t  copy = new_copy;\n@@ -15803,7 +15804,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \tif (SCALAR_FLOAT_MODE_P (mode))\n \t  {\n \t    unsigned int length = GET_MODE_SIZE (mode);\n-\t    unsigned char *array = GGC_NEWVEC (unsigned char, length);\n+\t    unsigned char *array = (unsigned char *) ggc_alloc_atomic (length);\n \n \t    insert_float (rtl, array);\n \t    add_AT_vec (die, DW_AT_const_value, length / 4, 4, array);\n@@ -15819,7 +15820,8 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \tenum machine_mode mode = GET_MODE (rtl);\n \tunsigned int elt_size = GET_MODE_UNIT_SIZE (mode);\n \tunsigned int length = CONST_VECTOR_NUNITS (rtl);\n-\tunsigned char *array = GGC_NEWVEC (unsigned char, length * elt_size);\n+\tunsigned char *array = (unsigned char *) ggc_alloc_atomic\n+\t  (length * elt_size);\n \tunsigned int i;\n \tunsigned char *p;\n \n@@ -16569,7 +16571,8 @@ tree_add_const_value_attribute (dw_die_ref die, tree t)\n       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (init));\n       if (size > 0 && (int) size == size)\n \t{\n-\t  unsigned char *array = GGC_CNEWVEC (unsigned char, size);\n+\t  unsigned char *array = (unsigned char *)\n+\t    ggc_alloc_cleared_atomic (size);\n \n \t  if (native_encode_initializer (init, array, size))\n \t    {\n@@ -16757,7 +16760,7 @@ add_comp_dir_attribute (dw_die_ref die)\n       int wdlen;\n \n       wdlen = strlen (wd);\n-      wd1 = GGC_NEWVEC (char, wdlen + 2);\n+      wd1 = (char *) ggc_alloc_atomic (wdlen + 2);\n       strcpy (wd1, wd);\n       wd1 [wdlen] = DIR_SEPARATOR;\n       wd1 [wdlen + 1] = 0;\n@@ -17207,7 +17210,7 @@ add_name_and_src_coords_attributes (dw_die_ref die, tree decl)\n \t    {\n \t      limbo_die_node *asm_name;\n \n-\t      asm_name = GGC_CNEW (limbo_die_node);\n+\t      asm_name = ggc_alloc_cleared_limbo_die_node ();\n \t      asm_name->die = die;\n \t      asm_name->created_for = decl;\n \t      asm_name->next = deferred_asm_name;\n@@ -20678,7 +20681,7 @@ lookup_filename (const char *file_name)\n   if (*slot)\n     return (struct dwarf_file_data *) *slot;\n \n-  created = GGC_NEW (struct dwarf_file_data);\n+  created = ggc_alloc_dwarf_file_data ();\n   created->filename = file_name;\n   created->emitted_number = 0;\n   *slot = created;\n@@ -20834,7 +20837,7 @@ vcall_insn_table_eq (const void *x, const void *y)\n static void\n store_vcall_insn (unsigned int vtable_slot, int insn_uid)\n {\n-  struct vcall_insn *item = GGC_NEW (struct vcall_insn);\n+  struct vcall_insn *item = ggc_alloc_vcall_insn ();\n   struct vcall_insn **slot;\n \n   gcc_assert (item);\n@@ -21192,13 +21195,15 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   decl_scope_table = VEC_alloc (tree, gc, 256);\n \n   /* Allocate the initial hunk of the abbrev_die_table.  */\n-  abbrev_die_table = GGC_CNEWVEC (dw_die_ref, ABBREV_DIE_TABLE_INCREMENT);\n+  abbrev_die_table = ggc_alloc_cleared_vec_dw_die_ref\n+    (ABBREV_DIE_TABLE_INCREMENT);\n   abbrev_die_table_allocated = ABBREV_DIE_TABLE_INCREMENT;\n   /* Zero-th entry is allocated, but unused.  */\n   abbrev_die_table_in_use = 1;\n \n   /* Allocate the initial hunk of the line_info_table.  */\n-  line_info_table = GGC_CNEWVEC (dw_line_info_entry, LINE_INFO_TABLE_INCREMENT);\n+  line_info_table = ggc_alloc_cleared_vec_dw_line_info_entry\n+    (LINE_INFO_TABLE_INCREMENT);\n   line_info_table_allocated = LINE_INFO_TABLE_INCREMENT;\n \n   /* Zero-th entry is allocated, but unused.  */"}, {"sha": "eb3ea93c9b3493bad1653e99b138984824aa19bf", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -341,7 +341,7 @@ get_mem_attrs (alias_set_type alias, tree expr, rtx offset, rtx size,\n   slot = htab_find_slot (mem_attrs_htab, &attrs, INSERT);\n   if (*slot == 0)\n     {\n-      *slot = ggc_alloc (sizeof (mem_attrs));\n+      *slot = ggc_alloc_mem_attrs ();\n       memcpy (*slot, &attrs, sizeof (mem_attrs));\n     }\n \n@@ -390,7 +390,7 @@ get_reg_attrs (tree decl, int offset)\n   slot = htab_find_slot (reg_attrs_htab, &attrs, INSERT);\n   if (*slot == 0)\n     {\n-      *slot = ggc_alloc (sizeof (reg_attrs));\n+      *slot = ggc_alloc_reg_attrs ();\n       memcpy (*slot, &attrs, sizeof (reg_attrs));\n     }\n \n@@ -5240,7 +5240,7 @@ start_sequence (void)\n       free_sequence_stack = tem->next;\n     }\n   else\n-    tem = GGC_NEW (struct sequence_stack);\n+    tem = ggc_alloc_sequence_stack ();\n \n   tem->next = seq_stack;\n   tem->first = get_insns ();\n@@ -5555,8 +5555,7 @@ init_emit (void)\n   crtl->emit.regno_pointer_align\n     = XCNEWVEC (unsigned char, crtl->emit.regno_pointer_align_length);\n \n-  regno_reg_rtx\n-    = GGC_NEWVEC (rtx, crtl->emit.regno_pointer_align_length);\n+  regno_reg_rtx = ggc_alloc_vec_rtx (crtl->emit.regno_pointer_align_length);\n \n   /* Put copies of all the hard registers into regno_reg_rtx.  */\n   memcpy (regno_reg_rtx,"}, {"sha": "cb4d8058ba53f0e07a6048ad3ac7ec52e3d8fc38", "filename": "gcc/except.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -329,7 +329,7 @@ init_eh (void)\n void\n init_eh_for_function (void)\n {\n-  cfun->eh = GGC_CNEW (struct eh_status);\n+  cfun->eh = ggc_alloc_cleared_eh_status ();\n \n   /* Make sure zero'th entries are used.  */\n   VEC_safe_push (eh_region, gc, cfun->eh->region_array, NULL);\n@@ -350,7 +350,7 @@ gen_eh_region (enum eh_region_type type, eh_region outer)\n #endif\n \n   /* Insert a new blank region as a leaf in the tree.  */\n-  new_eh = GGC_CNEW (struct eh_region_d);\n+  new_eh = ggc_alloc_cleared_eh_region_d ();\n   new_eh->type = type;\n   new_eh->outer = outer;\n   if (outer)\n@@ -407,7 +407,7 @@ gen_eh_region_catch (eh_region t, tree type_or_list)\n \tadd_type_for_runtime (TREE_VALUE (type_node));\n     }\n \n-  c = GGC_CNEW (struct eh_catch_d);\n+  c = ggc_alloc_cleared_eh_catch_d ();\n   c->type_list = type_list;\n   l = t->u.eh_try.last_catch;\n   c->prev_catch = l;\n@@ -441,7 +441,7 @@ gen_eh_region_must_not_throw (eh_region outer)\n eh_landing_pad\n gen_eh_landing_pad (eh_region region)\n {\n-  eh_landing_pad lp = GGC_CNEW (struct eh_landing_pad_d);\n+  eh_landing_pad lp = ggc_alloc_cleared_eh_landing_pad_d ();\n \n   lp->next_lp = region->landing_pads;\n   lp->region = region;\n@@ -2368,7 +2368,7 @@ add_call_site (rtx landing_pad, int action, int section)\n {\n   call_site_record record;\n \n-  record = GGC_NEW (struct call_site_record_d);\n+  record = ggc_alloc_call_site_record_d ();\n   record->landing_pad = landing_pad;\n   record->action = action;\n "}, {"sha": "10fe680f6f4197e195969b44bf329869b91796f2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,17 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* trans-types.c (gfc_get_nodesc_array_type): Use typed GC\n+\tallocation.\n+\t(gfc_get_array_type_bounds): Likewise.\n+\n+\t* trans-decl.c (gfc_allocate_lang_decl): Likewise.\n+\t(gfc_find_module): Likewise.\n+\n+\t* f95-lang.c (pushlevel): Likewise.\n+\n+\t* trans.h (struct lang_type): Add variable_size GTY option.\n+\t(struct lang_decl): Likewise.\n+\n 2010-06-08  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/44446"}, {"sha": "f76e75c4b1f56438d26d92274e6034db5e81e829", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -350,8 +350,7 @@ getdecls (void)\n void\n pushlevel (int ignore ATTRIBUTE_UNUSED)\n {\n-  struct binding_level *newlevel\n-    = (struct binding_level *) ggc_alloc (sizeof (struct binding_level));\n+  struct binding_level *newlevel = ggc_alloc_binding_level ();\n \n   *newlevel = clear_binding_level;\n "}, {"sha": "7ebdac4d1cf0506fcb7b014d05b3c3003a0144fe", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -612,8 +612,8 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n void\n gfc_allocate_lang_decl (tree decl)\n {\n-  DECL_LANG_SPECIFIC (decl) = (struct lang_decl *)\n-    ggc_alloc_cleared (sizeof (struct lang_decl));\n+  DECL_LANG_SPECIFIC (decl) = ggc_alloc_cleared_lang_decl(sizeof\n+\t\t\t\t\t\t\t  (struct lang_decl));\n }\n \n /* Remember a symbol to generate initialization/cleanup code at function\n@@ -3410,7 +3410,7 @@ gfc_find_module (const char *name)\n \t\t\t\t   htab_hash_string (name), INSERT);\n   if (*slot == NULL)\n     {\n-      struct module_htab_entry *entry = GGC_CNEW (struct module_htab_entry);\n+      struct module_htab_entry *entry = ggc_alloc_cleared_module_htab_entry ();\n \n       entry->name = gfc_get_string (name);\n       entry->decls = htab_create_ggc (10, module_htab_decls_hash,"}, {"sha": "38bae7d4cea2e7ad4012bd84d052e6007aadaf29", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1390,8 +1390,8 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n   type = make_node (ARRAY_TYPE);\n \n   GFC_ARRAY_TYPE_P (type) = 1;\n-  TYPE_LANG_SPECIFIC (type) = (struct lang_type *)\n-    ggc_alloc_cleared (sizeof (struct lang_type));\n+  TYPE_LANG_SPECIFIC (type)\n+      = ggc_alloc_cleared_lang_type (sizeof (struct lang_type));\n \n   known_stride = (packed != PACKED_NO);\n   known_offset = 1;\n@@ -1631,8 +1631,8 @@ gfc_get_array_type_bounds (tree etype, int dimen, int codimen, tree * lbound,\n   TYPE_NAME (fat_type) = get_identifier (name);\n \n   GFC_DESCRIPTOR_TYPE_P (fat_type) = 1;\n-  TYPE_LANG_SPECIFIC (fat_type) = (struct lang_type *)\n-    ggc_alloc_cleared (sizeof (struct lang_type));\n+  TYPE_LANG_SPECIFIC (fat_type)\n+    = ggc_alloc_cleared_lang_type (sizeof (struct lang_type));\n \n   GFC_TYPE_ARRAY_RANK (fat_type) = dimen;\n   GFC_TYPE_ARRAY_DTYPE (fat_type) = NULL_TREE;"}, {"sha": "72f8a4367886f48a8b804112afeefefe5ae242bc", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -630,7 +630,10 @@ enum gfc_array_kind\n };\n \n /* Array types only.  */\n-struct GTY(())\tlang_type\t {\n+/* FIXME: the variable_size annotation here is needed because these types are\n+   variable-sized in some other frontends.  Due to gengtype deficiency the GTY\n+   options of such types have to agree across all frontends. */\n+struct GTY((variable_size))\tlang_type\t {\n   int rank;\n   enum gfc_array_kind akind;\n   tree lbound[GFC_MAX_DIMENSIONS];\n@@ -644,7 +647,7 @@ struct GTY(())\tlang_type\t {\n   tree base_decl[2];\n };\n \n-struct GTY(()) lang_decl {\n+struct GTY((variable_size)) lang_decl {\n   /* Dummy variables.  */\n   tree saved_descriptor;\n   /* Assigned integer nodes.  Stringlength is the IO format string's length."}, {"sha": "c5b80b0e15358399f65a68369409b2eb13d48c6c", "filename": "gcc/function.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -340,7 +340,7 @@ try_fit_stack_local (HOST_WIDE_INT start, HOST_WIDE_INT length,\n static void\n add_frame_space (HOST_WIDE_INT start, HOST_WIDE_INT end)\n {\n-  struct frame_space *space = GGC_NEW (struct frame_space);\n+  struct frame_space *space = ggc_alloc_frame_space ();\n   space->next = crtl->frame_space_list;\n   crtl->frame_space_list = space;\n   space->start = start;\n@@ -683,7 +683,7 @@ static void\n insert_temp_slot_address (rtx address, struct temp_slot *temp_slot)\n {\n   void **slot;\n-  struct temp_slot_address_entry *t = GGC_NEW (struct temp_slot_address_entry);\n+  struct temp_slot_address_entry *t = ggc_alloc_temp_slot_address_entry ();\n   t->address = address;\n   t->temp_slot = temp_slot;\n   t->hash = temp_slot_address_compute_hash (t);\n@@ -835,7 +835,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n \n \t  if (best_p->size - rounded_size >= alignment)\n \t    {\n-\t      p = GGC_NEW (struct temp_slot);\n+\t      p = ggc_alloc_temp_slot ();\n \t      p->in_use = p->addr_taken = 0;\n \t      p->size = best_p->size - rounded_size;\n \t      p->base_offset = best_p->base_offset + rounded_size;\n@@ -859,7 +859,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n     {\n       HOST_WIDE_INT frame_offset_old = frame_offset;\n \n-      p = GGC_NEW (struct temp_slot);\n+      p = ggc_alloc_temp_slot ();\n \n       /* We are passing an explicit alignment request to assign_stack_local.\n \t One side effect of that is assign_stack_local will not round SIZE\n@@ -4196,7 +4196,7 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n   tree result;\n   tree fntype = fndecl ? TREE_TYPE (fndecl) : NULL_TREE;\n \n-  cfun = GGC_CNEW (struct function);\n+  cfun = ggc_alloc_cleared_function ();\n \n   init_eh_for_function ();\n \n@@ -5623,8 +5623,7 @@ types_used_by_var_decl_insert (tree type, tree var_decl)\n       if (*slot == NULL)\n \t{\n \t  struct types_used_by_vars_entry *entry;\n-\t  entry = (struct types_used_by_vars_entry*) ggc_alloc\n-\t\t    (sizeof (struct types_used_by_vars_entry));\n+\t  entry = ggc_alloc_types_used_by_vars_entry ();\n \t  entry->type = type;\n \t  entry->var_decl = var_decl;\n \t  *slot = entry;"}, {"sha": "b16a33ac04dfe4dc14c44b910ee6ec02b134f41e", "filename": "gcc/gengtype.c", "status": "modified", "additions": 230, "deletions": 11, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1895,9 +1895,8 @@ static void output_escaped_param (struct walk_type_data *d,\n \t\t\t\t  const char *, const char *);\n static void output_mangled_typename (outf_p, const_type_p);\n static void walk_type (type_p t, struct walk_type_data *d);\n-static void write_func_for_structure\n-     (type_p orig_s, type_p s, type_p * param,\n-      const struct write_types_data *wtd);\n+static void write_func_for_structure (type_p orig_s, type_p s, type_p * param,\n+\t\t\t\t      const struct write_types_data *wtd);\n static void write_types_process_field\n      (type_p f, const struct walk_type_data *d);\n static void write_types (outf_p output_header,\n@@ -2088,6 +2087,8 @@ walk_type (type_p t, struct walk_type_data *d)\n       ;\n     else if (strcmp (oo->name, \"reorder\") == 0)\n       ;\n+    else if (strcmp (oo->name, \"variable_size\") == 0)\n+      ;\n     else\n       error_at_line (d->line, \"unknown option `%s'\\n\", oo->name);\n \n@@ -3026,6 +3027,20 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n       }\n }\n \n+/* Nonzero if S is a type for which typed GC allocators should be output.  */\n+\n+#define USED_BY_TYPED_GC_P(s)\t\t\t\t\t\t\\\n+  (((s->kind == TYPE_POINTER)\t\t\t\t\t\t\\\n+    && ((s->u.p->gc_used == GC_POINTED_TO)\t\t\t\t\\\n+\t|| (s->u.p->gc_used == GC_USED)))\t\t\t\t\\\n+   || (UNION_OR_STRUCT_P (s) &&\t\t\t\t\t\t\\\n+       (((s)->gc_used == GC_POINTED_TO)\t\t\t\t\t\\\n+\t|| ((s)->gc_used == GC_MAYBE_POINTED_TO\t\t\t\t\\\n+\t    && s->u.s.line.file != NULL)\t\t\t\t\\\n+\t|| ((s)->gc_used == GC_USED\t\t\t\t\t\\\n+\t    && strncmp (s->u.s.tag, \"anonymous\", strlen (\"anonymous\"))))))\n+\n+\n /* Write out the 'enum' definition for gt_types_enum.  */\n \n static void\n@@ -3038,23 +3053,18 @@ write_enum_defn (type_p structures, type_p param_structs)\n   oprintf (header_file, \"\\n/* Enumeration of types known.  */\\n\");\n   oprintf (header_file, \"enum gt_types_enum {\\n\");\n   for (s = structures; s; s = s->next)\n-    if (s->gc_used == GC_POINTED_TO\n-\t|| s->gc_used == GC_MAYBE_POINTED_TO)\n+    if (USED_BY_TYPED_GC_P (s))\n       {\n-\tif (s->gc_used == GC_MAYBE_POINTED_TO\n-\t    && s->u.s.line.file == NULL)\n-\t  continue;\n-\n \toprintf (header_file, \" gt_ggc_e_\");\n \toutput_mangled_typename (header_file, s);\n-\toprintf (header_file, \", \\n\");\n+\toprintf (header_file, \",\\n\");\n       }\n   for (s = param_structs; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO)\n       {\n \toprintf (header_file, \" gt_e_\");\n \toutput_mangled_typename (header_file, s);\n-\toprintf (header_file, \", \\n\");\n+\toprintf (header_file, \",\\n\");\n       }\n   oprintf (header_file, \" gt_types_enum_last\\n\");\n   oprintf (header_file, \"};\\n\");\n@@ -3701,6 +3711,213 @@ note_def_vec_alloc (const char *type, const char *astrat, struct fileloc *pos)\n   do_typedef (astratname, new_structure (astratname, 0, pos, field, 0), pos);\n }\n \n+/* Returns the specifier keyword for a string or union type S, empty string\n+   otherwise.  */\n+\n+static const char *\n+get_type_specifier (const type_p s)\n+{\n+  if (s->kind == TYPE_STRUCT || s->kind == TYPE_LANG_STRUCT)\n+    return \"struct \";\n+  if (s->kind == TYPE_UNION)\n+    return \"union \";\n+  return \"\";\n+}\n+\n+/* TRUE if type S has the GTY variable_size annotation.  */\n+\n+static bool\n+variable_size_p (const type_p s)\n+{\n+  options_p o;\n+  for (o = s->u.s.opt; o; o = o->next)\n+    if (strcmp (o->name, \"variable_size\") == 0)\n+      return true;\n+  return false;\n+}\n+\n+enum alloc_quantity { single, vector };\n+enum alloc_zone { any_zone, specific_zone };\n+\n+/* Writes one typed allocator definition for type identifier TYPE_NAME with\n+   optional type specifier TYPE_SPECIFIER.  The allocator name will contain\n+   ALLOCATOR_TYPE.  If VARIABLE_SIZE is true, the allocator will have an extra\n+   parameter specifying number of bytes to allocate.  If QUANTITY is set to\n+   VECTOR, a vector allocator will be output, if ZONE is set to SPECIFIC_ZONE,\n+   the allocator will be zone-specific.  */\n+\n+static void\n+write_typed_alloc_def (bool variable_size, const char * type_specifier,\n+\t\t       const char * type_name, const char * allocator_type,\n+\t\t       enum alloc_quantity quantity, enum alloc_zone zone)\n+{\n+  bool two_args = variable_size && (quantity == vector);\n+  bool third_arg = ((zone == specific_zone)\n+\t\t    && (variable_size || (quantity == vector)));\n+\n+  oprintf (header_file, \"#define ggc_alloc_%s%s\",allocator_type, type_name);\n+  oprintf (header_file, \"(%s%s%s%s%s) \",\n+\t   (variable_size ? \"SIZE\" : \"\"),\n+\t   (two_args ? \", \" : \"\"),\n+\t   (quantity == vector) ? \"n\" : \"\",\n+\t   (third_arg ? \", \" : \"\"), (zone == specific_zone) ? \"z\" : \"\");\n+  oprintf (header_file, \"((%s%s *)\", type_specifier, type_name);\n+  oprintf (header_file, \"(ggc_internal_%salloc_stat (\", allocator_type);\n+  if (zone == specific_zone)\n+    oprintf (header_file, \"z, \");\n+  if (variable_size)\n+    oprintf (header_file, \"SIZE\");\n+  else\n+    oprintf (header_file, \"sizeof (%s%s)\", type_specifier, type_name);\n+  if (quantity == vector)\n+    oprintf (header_file, \", n\");\n+  oprintf (header_file, \" MEM_STAT_INFO)))\\n\");\n+}\n+\n+/* Writes a typed allocator definition for a struct or union S.  */\n+\n+static void\n+write_typed_struct_alloc_def (const type_p s, const char * allocator_type,\n+\t\t\t      enum alloc_quantity quantity,\n+\t\t\t      enum alloc_zone zone)\n+{\n+  write_typed_alloc_def (variable_size_p (s), get_type_specifier (s),\n+\t\t\t s->u.s.tag, allocator_type, quantity, zone);\n+}\n+\n+/* Writes a typed allocator definition for a typedef P.  */\n+\n+static void\n+write_typed_typedef_alloc_def (const pair_p p, const char * allocator_type,\n+\t\t\t       enum alloc_quantity quantity,\n+\t\t\t       enum alloc_zone zone)\n+{\n+  write_typed_alloc_def (variable_size_p (p->type), \"\", p->name,\n+\t\t\t allocator_type, quantity, zone);\n+}\n+\n+/* Writes typed allocator definitions for the types in STRUCTURES and\n+   TYPEDEFS that are used by GC.  */\n+\n+static void\n+write_typed_alloc_defns (const type_p structures, const pair_p typedefs)\n+{\n+  type_p s;\n+  pair_p p;\n+\n+  oprintf (header_file,\n+\t   \"\\n/* Allocators for known structs and unions.  */\\n\\n\");\n+  for (s = structures; s; s = s->next)\n+    {\n+      if (!USED_BY_TYPED_GC_P (s))\n+\tcontinue;\n+      write_typed_struct_alloc_def (s, \"\", single, any_zone);\n+      write_typed_struct_alloc_def (s, \"cleared_\", single, any_zone);\n+      write_typed_struct_alloc_def (s, \"vec_\", vector, any_zone);\n+      write_typed_struct_alloc_def (s, \"cleared_vec_\", vector, any_zone);\n+      write_typed_struct_alloc_def (s, \"zone_\", single, specific_zone);\n+      write_typed_struct_alloc_def (s, \"zone_cleared_\", single,\n+\t\t\t\t    specific_zone);\n+      write_typed_struct_alloc_def (s, \"zone_vec_\", vector, specific_zone);\n+      write_typed_struct_alloc_def (s, \"zone_cleared_vec_\", vector,\n+\t\t\t\t    specific_zone);\n+    }\n+\n+  oprintf (header_file, \"\\n/* Allocators for known typedefs.  */\\n\");\n+  for (p = typedefs; p; p = p->next)\n+    {\n+      s = p->type;\n+      if (!USED_BY_TYPED_GC_P (s) || (strcmp (p->name, s->u.s.tag) == 0))\n+\tcontinue;\n+      write_typed_typedef_alloc_def (p, \"\", single, any_zone);\n+      write_typed_typedef_alloc_def (p, \"cleared_\", single, any_zone);\n+      write_typed_typedef_alloc_def (p, \"vec_\", vector, any_zone);\n+      write_typed_typedef_alloc_def (p, \"cleared_vec_\", vector, any_zone);\n+      write_typed_typedef_alloc_def (p, \"zone_\", single, specific_zone);\n+      write_typed_typedef_alloc_def (p, \"zone_cleared_\", single,\n+\t\t\t\t     specific_zone);\n+      write_typed_typedef_alloc_def (p, \"zone_cleared_vec_\", vector,\n+\t\t\t\t     specific_zone);\n+    }\n+}\n+\n+/* Prints not-as-ugly version of a typename of T to OF.  Trades the uniquness\n+   guaranteee for somewhat increased readability.  If name conflicts do happen,\n+   this funcion will have to be adjusted to be more like\n+   output_mangled_typename.  */\n+\n+static void\n+output_typename (outf_p of, const_type_p t)\n+{\n+  switch (t->kind)\n+    {\n+    case TYPE_STRING:\n+      oprintf (of, \"str\");\n+      break;\n+    case TYPE_SCALAR:\n+      oprintf (of, \"scalar\");\n+      break;\n+    case TYPE_POINTER:\n+      output_typename (of, t->u.p);\n+      break;\n+    case TYPE_STRUCT:\n+    case TYPE_UNION:\n+    case TYPE_LANG_STRUCT:\n+      oprintf (of, \"%s\", t->u.s.tag);\n+      break;\n+    case TYPE_PARAM_STRUCT:\n+      {\n+\tint i;\n+\tfor (i = 0; i < NUM_PARAM; i++)\n+\t  if (t->u.param_struct.param[i] != NULL) {\n+\t    output_typename (of, t->u.param_struct.param[i]);\n+\t    oprintf (of, \"_\");\n+\t  }\n+\toutput_typename (of, t->u.param_struct.stru);\n+\tbreak;\n+      }\n+    default:\n+      gcc_unreachable();\n+    }\n+}\n+\n+/* Writes a typed GC allocator for type S that is suitable as a callback for\n+   the splay tree implementation in libiberty.  */\n+\n+static void\n+write_splay_tree_allocator_def (const_type_p s)\n+{\n+  outf_p of = get_output_file_for_structure(s, NULL);\n+  oprintf (of, \"void * ggc_alloc_splay_tree_\");\n+  output_typename (of, s);\n+  oprintf (of, \" (int sz, void * nl)\\n\");\n+  oprintf (of, \"{\\n\");\n+  oprintf (of, \"  return ggc_splay_alloc (\");\n+  oprintf (of, \"gt_e_\");\n+  output_mangled_typename (of, s);\n+  oprintf (of, \", sz, nl);\\n\");\n+  oprintf (of, \"}\\n\\n\");\n+}\n+\n+/* Writes typed GC allocators for PARAM_STRUCTS that are suitable as callbacks\n+   for the splay tree implementation in libiberty.  */\n+\n+static void\n+write_splay_tree_allocators (const_type_p param_structs)\n+{\n+  const_type_p s;\n+\n+  oprintf (header_file, \"\\n/* Splay tree callback allocators.  */\\n\");\n+  for (s = param_structs; s; s = s->next)\n+    if (s->gc_used == GC_POINTED_TO)\n+      {\n+\toprintf (header_file, \"extern void * ggc_alloc_splay_tree_\");\n+\toutput_typename (header_file, s);\n+\toprintf (header_file, \" (int, void *);\\n\");\n+\twrite_splay_tree_allocator_def (s);\n+      }\n+}\n+\n static void dump_pair (int indent, pair_p p);\n static void dump_type (int indent, type_p p);\n static void dump_type_list (int indent, type_p p);\n@@ -4021,13 +4238,15 @@ main (int argc, char **argv)\n \n   open_base_files ();\n   write_enum_defn (structures, param_structs);\n+  write_typed_alloc_defns (structures, typedefs);\n   output_header = plugin_output ? plugin_output : header_file;\n   write_types (output_header, structures, param_structs, &ggc_wtd);\n   if (plugin_files == NULL)\n     {\n       write_types (header_file, structures, param_structs, &pch_wtd);\n       write_local (header_file, structures, param_structs);\n     }\n+  write_splay_tree_allocators (param_structs);\n   write_roots (variables, plugin_files == NULL);\n   write_rtx_next ();\n   close_output_files ();"}, {"sha": "175629b3129a84f91d16da61091f99c637b61934", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"hashtab.h\"\n #include \"ggc.h\"\n+#include \"ggc-internal.h\"\n #include \"toplev.h\"\n #include \"params.h\"\n #include \"hosthooks.h\"\n@@ -193,9 +194,9 @@ ggc_mark_roots (void)\n \n /* Allocate a block of memory, then clear it.  */\n void *\n-ggc_alloc_cleared_stat (size_t size MEM_STAT_DECL)\n+ggc_internal_cleared_alloc_stat (size_t size MEM_STAT_DECL)\n {\n-  void *buf = ggc_alloc_stat (size PASS_MEM_STAT);\n+  void *buf = ggc_internal_alloc_stat (size PASS_MEM_STAT);\n   memset (buf, 0, size);\n   return buf;\n }\n@@ -208,7 +209,7 @@ ggc_realloc_stat (void *x, size_t size MEM_STAT_DECL)\n   size_t old_size;\n \n   if (x == NULL)\n-    return ggc_alloc_stat (size PASS_MEM_STAT);\n+    return ggc_internal_alloc_stat (size PASS_MEM_STAT);\n \n   old_size = ggc_get_size (x);\n \n@@ -230,7 +231,7 @@ ggc_realloc_stat (void *x, size_t size MEM_STAT_DECL)\n       return x;\n     }\n \n-  r = ggc_alloc_stat (size PASS_MEM_STAT);\n+  r = ggc_internal_alloc_stat (size PASS_MEM_STAT);\n \n   /* Since ggc_get_size returns the size of the pool, not the size of the\n      individually allocated object, we'd access parts of the old object\n@@ -246,19 +247,30 @@ ggc_realloc_stat (void *x, size_t size MEM_STAT_DECL)\n   return r;\n }\n \n-/* Like ggc_alloc_cleared, but performs a multiplication.  */\n void *\n-ggc_calloc (size_t s1, size_t s2)\n+ggc_cleared_alloc_htab_ignore_args (size_t c ATTRIBUTE_UNUSED,\n+\t\t\t\t    size_t n ATTRIBUTE_UNUSED)\n {\n-  return ggc_alloc_cleared (s1 * s2);\n+  gcc_assert (c * n == sizeof (struct htab));\n+  return ggc_alloc_cleared_htab ();\n+}\n+\n+/* TODO: once we actually use type information in GGC, create a new tag\n+   gt_gcc_ptr_array and use it for pointer arrays.  */\n+void *\n+ggc_cleared_alloc_ptr_array_two_args (size_t c, size_t n)\n+{\n+  gcc_assert (sizeof (PTR *) == n);\n+  return ggc_internal_cleared_vec_alloc (sizeof (PTR *), c);\n }\n \n /* These are for splay_tree_new_ggc.  */\n void *\n-ggc_splay_alloc (int sz, void *nl)\n+ggc_splay_alloc (enum gt_types_enum obj_type ATTRIBUTE_UNUSED, int sz,\n+\t\t void *nl)\n {\n   gcc_assert (!nl);\n-  return ggc_alloc (sz);\n+  return ggc_internal_alloc (sz);\n }\n \n void\n@@ -516,7 +528,7 @@ gt_pch_save (FILE *f)\n \n   /* Prepare the objects for writing, determine addresses and such.  */\n   state.f = f;\n-  state.d = init_ggc_pch();\n+  state.d = init_ggc_pch ();\n   state.count = 0;\n   htab_traverse (saving_htab, call_count, &state);\n \n@@ -825,7 +837,7 @@ ggc_min_heapsize_heuristic (void)\n      the limit, whichever is larger.  If GCC does hit the data limit,\n      compilation will fail, so this tries to be conservative.  */\n   limit_kbytes = MAX (0, limit_kbytes - MAX (limit_kbytes / 4, 20 * 1024));\n-  limit_kbytes = (limit_kbytes * 100) / (110 + ggc_min_expand_heuristic());\n+  limit_kbytes = (limit_kbytes * 100) / (110 + ggc_min_expand_heuristic ());\n   phys_kbytes = MIN (phys_kbytes, limit_kbytes);\n \n   phys_kbytes = MAX (phys_kbytes, 4 * 1024);\n@@ -839,8 +851,8 @@ void\n init_ggc_heuristics (void)\n {\n #if !defined ENABLE_GC_CHECKING && !defined ENABLE_GC_ALWAYS_COLLECT\n-  set_param_value (\"ggc-min-expand\", ggc_min_expand_heuristic());\n-  set_param_value (\"ggc-min-heapsize\", ggc_min_heapsize_heuristic());\n+  set_param_value (\"ggc-min-expand\", ggc_min_expand_heuristic ());\n+  set_param_value (\"ggc-min-heapsize\", ggc_min_heapsize_heuristic ());\n #endif\n }\n "}, {"sha": "7b875eec9cbe677243fea212f58de77fac12a7f8", "filename": "gcc/ggc-internal.h", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-internal.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -0,0 +1,121 @@\n+/* Garbage collection for the GNU compiler.  Internal definitions\n+   for ggc-*.c and stringpool.c.\n+\n+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GGC_INTERNAL_H\n+#define GCC_GGC_INTERNAL_H\n+\n+#include \"ggc.h\"\n+\n+/* Call ggc_set_mark on all the roots.  */\n+extern void ggc_mark_roots (void);\n+\n+/* Stringpool.  */\n+\n+/* Mark the entries in the string pool.  */\n+extern void ggc_mark_stringpool\t(void);\n+\n+/* Purge the entries in the string pool.  */\n+extern void ggc_purge_stringpool (void);\n+\n+/* Save and restore the string pool entries for PCH.  */\n+\n+extern void gt_pch_save_stringpool (void);\n+extern void gt_pch_fixup_stringpool (void);\n+extern void gt_pch_restore_stringpool (void);\n+\n+/* PCH and GGC handling for strings, mostly trivial.  */\n+extern void gt_pch_p_S (void *, void *, gt_pointer_operator, void *);\n+\n+/* PCH.  */\n+\n+struct ggc_pch_data;\n+\n+/* Return a new ggc_pch_data structure.  */\n+extern struct ggc_pch_data *init_ggc_pch (void);\n+\n+/* The second parameter and third parameters give the address and size\n+   of an object.  Update the ggc_pch_data structure with as much of\n+   that information as is necessary. The bool argument should be true\n+   if the object is a string.  */\n+extern void ggc_pch_count_object (struct ggc_pch_data *, void *, size_t, bool,\n+\t\t\t\t  enum gt_types_enum);\n+\n+/* Return the total size of the data to be written to hold all\n+   the objects previously passed to ggc_pch_count_object.  */\n+extern size_t ggc_pch_total_size (struct ggc_pch_data *);\n+\n+/* The objects, when read, will most likely be at the address\n+   in the second parameter.  */\n+extern void ggc_pch_this_base (struct ggc_pch_data *, void *);\n+\n+/* Assuming that the objects really do end up at the address\n+   passed to ggc_pch_this_base, return the address of this object.\n+   The bool argument should be true if the object is a string.  */\n+extern char *ggc_pch_alloc_object (struct ggc_pch_data *, void *, size_t, bool,\n+\t\t\t\t   enum gt_types_enum);\n+\n+/* Write out any initial information required.  */\n+extern void ggc_pch_prepare_write (struct ggc_pch_data *, FILE *);\n+\n+/* Write out this object, including any padding.  The last argument should be\n+   true if the object is a string.  */\n+extern void ggc_pch_write_object (struct ggc_pch_data *, FILE *, void *,\n+\t\t\t\t  void *, size_t, bool);\n+\n+/* All objects have been written, write out any final information\n+   required.  */\n+extern void ggc_pch_finish (struct ggc_pch_data *, FILE *);\n+\n+/* A PCH file has just been read in at the address specified second\n+   parameter.  Set up the GC implementation for the new objects.  */\n+extern void ggc_pch_read (FILE *, void *);\n+\n+\n+/* Allocation and collection.  */\n+\n+/* When set, ggc_collect will do collection.  */\n+extern bool ggc_force_collect;\n+\n+extern void ggc_record_overhead (size_t, size_t, void * MEM_STAT_DECL);\n+\n+extern void ggc_free_overhead (void *);\n+\n+extern void ggc_prune_overhead_list (void);\n+\n+/* Return the number of bytes allocated at the indicated address.  */\n+extern size_t ggc_get_size (const void *);\n+\n+\n+/* Statistics.  */\n+\n+/* This structure contains the statistics common to all collectors.\n+   Particular collectors can extend this structure.  */\n+typedef struct ggc_statistics\n+{\n+  /* At present, we don't really gather any interesting statistics.  */\n+  int unused;\n+} ggc_statistics;\n+\n+/* Used by the various collectors to gather and print statistics that\n+   do not depend on the collector in use.  */\n+extern void ggc_print_common_statistics (FILE *, ggc_statistics *);\n+\n+#endif"}, {"sha": "f9c48cb8cc5902c3179bafe46e584a39f6ddc4f2", "filename": "gcc/ggc-none.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,5 +1,5 @@\n /* Null garbage collection for the GNU compiler.\n-   Copyright (C) 1998, 1999, 2000, 2003, 2004, 2005, 2007\n+   Copyright (C) 1998, 1999, 2000, 2003, 2004, 2005, 2007, 2010\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -40,13 +40,13 @@ ggc_alloc_typed_stat (enum gt_types_enum ARG_UNUSED (gte), size_t size\n }\n \n void *\n-ggc_alloc_stat (size_t size MEM_STAT_DECL)\n+ggc_internal_alloc_stat (size_t size MEM_STAT_DECL)\n {\n   return xmalloc (size);\n }\n \n void *\n-ggc_alloc_cleared_stat (size_t size MEM_STAT_DECL)\n+ggc_internal_cleared_alloc_stat (size_t size MEM_STAT_DECL)\n {\n   return xcalloc (size, 1);\n }\n@@ -62,3 +62,12 @@ ggc_free (void *p)\n {\n   free (p);\n }\n+\n+struct alloc_zone\n+{\n+  int dummy;\n+};\n+\n+struct alloc_zone rtl_zone;\n+struct alloc_zone tree_zone;\n+struct alloc_zone tree_id_zone;"}, {"sha": "27862be8ef40f63e65d3eee6f3d978716bbdc975", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,6 +1,6 @@\n /* \"Bag-of-pages\" garbage collector for the GNU compiler.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009,\n+   2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"flags.h\"\n #include \"ggc.h\"\n+#include \"ggc-internal.h\"\n #include \"timevar.h\"\n #include \"params.h\"\n #include \"tree-flow.h\"\n@@ -437,9 +438,9 @@ static struct globals\n #ifdef GATHER_STATISTICS\n   struct\n   {\n-    /* Total memory allocated with ggc_alloc.  */\n+    /* Total GC-allocated memory.  */\n     unsigned long long total_allocated;\n-    /* Total overhead for memory to be allocated with ggc_alloc.  */\n+    /* Total overhead for GC-allocated memory.  */\n     unsigned long long total_overhead;\n \n     /* Total allocations and overhead for sizes less than 32, 64 and 128.\n@@ -689,7 +690,7 @@ alloc_anon (char *pref ATTRIBUTE_UNUSED, size_t size)\n   G.bytes_mapped += size;\n \n   /* Pretend we don't have access to the allocated pages.  We'll enable\n-     access to smaller pieces of the area in ggc_alloc.  Discard the\n+     access to smaller pieces of the area in ggc_internal_alloc.  Discard the\n      handle to avoid handle leak.  */\n   VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (page, size));\n \n@@ -1074,13 +1075,13 @@ void *\n ggc_alloc_typed_stat (enum gt_types_enum type ATTRIBUTE_UNUSED, size_t size\n \t\t      MEM_STAT_DECL)\n {\n-  return ggc_alloc_stat (size PASS_MEM_STAT);\n+  return ggc_internal_alloc_stat (size PASS_MEM_STAT);\n }\n \n /* Allocate a chunk of memory of SIZE bytes.  Its contents are undefined.  */\n \n void *\n-ggc_alloc_stat (size_t size MEM_STAT_DECL)\n+ggc_internal_alloc_stat (size_t size MEM_STAT_DECL)\n {\n   size_t order, word, bit, object_offset, object_size;\n   struct page_entry *entry;\n@@ -1605,20 +1606,6 @@ init_ggc (void)\n   G.save_in_use = XNEWVEC (unsigned long *, G.by_depth_max);\n }\n \n-/* Start a new GGC zone.  */\n-\n-struct alloc_zone *\n-new_ggc_zone (const char *name ATTRIBUTE_UNUSED)\n-{\n-  return NULL;\n-}\n-\n-/* Destroy a GGC zone.  */\n-void\n-destroy_ggc_zone (struct alloc_zone *zone ATTRIBUTE_UNUSED)\n-{\n-}\n-\n /* Merge the SAVE_IN_USE_P and IN_USE_P arrays in P so that IN_USE_P\n    reflects reality.  Recalculate NUM_FREE_OBJECTS as well.  */\n \n@@ -2383,3 +2370,12 @@ ggc_pch_read (FILE *f, void *addr)\n   /* Update the statistics.  */\n   G.allocated = G.allocated_last_gc = offs - (char *)addr;\n }\n+\n+struct alloc_zone\n+{\n+  int dummy;\n+};\n+\n+struct alloc_zone rtl_zone;\n+struct alloc_zone tree_zone;\n+struct alloc_zone tree_id_zone;"}, {"sha": "12dc8740529565cadb55a93108ebc28796c977dc", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"flags.h\"\n #include \"ggc.h\"\n+#include \"ggc-internal.h\"\n #include \"timevar.h\"\n #include \"params.h\"\n #include \"bitmap.h\"\n@@ -417,9 +418,9 @@ struct alloc_zone\n #ifdef GATHER_STATISTICS\n   struct\n   {\n-    /* Total memory allocated with ggc_alloc.  */\n+    /* Total GC-allocated memory.  */\n     unsigned long long total_allocated;\n-    /* Total overhead for memory to be allocated with ggc_alloc.  */\n+    /* Total overhead for GC-allocated memory.  */\n     unsigned long long total_overhead;\n \n     /* Total allocations and overhead for sizes less than 32, 64 and 128.\n@@ -860,7 +861,7 @@ alloc_anon (char *pref ATTRIBUTE_UNUSED, size_t size, struct alloc_zone *zone)\n   zone->bytes_mapped += size;\n \n   /* Pretend we don't have access to the allocated pages.  We'll enable\n-     access to smaller pieces of the area in ggc_alloc.  Discard the\n+     access to smaller pieces of the area in ggc_internal_alloc.  Discard the\n      handle to avoid handle leak.  */\n   VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (page, size));\n \n@@ -1089,8 +1090,8 @@ free_chunk (char *ptr, size_t size, struct alloc_zone *zone)\n /* Allocate a chunk of memory of at least ORIG_SIZE bytes, in ZONE.  */\n \n void *\n-ggc_alloc_zone_stat (size_t orig_size, struct alloc_zone *zone\n-\t\t     MEM_STAT_DECL)\n+ggc_internal_alloc_zone_stat (size_t orig_size, struct alloc_zone *zone\n+\t\t\t      MEM_STAT_DECL)\n {\n   size_t bin;\n   size_t csize;\n@@ -1352,6 +1353,19 @@ ggc_alloc_zone_stat (size_t orig_size, struct alloc_zone *zone\n   return result;\n }\n \n+#define ggc_internal_alloc_zone_pass_stat(s,z)          \\\n+    ggc_internal_alloc_zone_stat (s,z PASS_MEM_STAT)\n+\n+void *\n+ggc_internal_cleared_alloc_zone_stat (size_t orig_size,\n+\t\t\t\t      struct alloc_zone *zone MEM_STAT_DECL)\n+{\n+  void * result = ggc_internal_alloc_zone_pass_stat (orig_size, zone);\n+  memset (result, 0, orig_size);\n+  return result;\n+}\n+\n+\n /* Allocate a SIZE of chunk memory of GTE type, into an appropriate zone\n    for that type.  */\n \n@@ -1362,25 +1376,25 @@ ggc_alloc_typed_stat (enum gt_types_enum gte, size_t size\n   switch (gte)\n     {\n     case gt_ggc_e_14lang_tree_node:\n-      return ggc_alloc_zone_pass_stat (size, &tree_zone);\n+      return ggc_internal_alloc_zone_pass_stat (size, &tree_zone);\n \n     case gt_ggc_e_7rtx_def:\n-      return ggc_alloc_zone_pass_stat (size, &rtl_zone);\n+      return ggc_internal_alloc_zone_pass_stat (size, &rtl_zone);\n \n     case gt_ggc_e_9rtvec_def:\n-      return ggc_alloc_zone_pass_stat (size, &rtl_zone);\n+      return ggc_internal_alloc_zone_pass_stat (size, &rtl_zone);\n \n     default:\n-      return ggc_alloc_zone_pass_stat (size, &main_zone);\n+      return ggc_internal_alloc_zone_pass_stat (size, &main_zone);\n     }\n }\n \n-/* Normal ggc_alloc simply allocates into the main zone.  */\n+/* Normal GC allocation simply allocates into the main zone.  */\n \n void *\n-ggc_alloc_stat (size_t size MEM_STAT_DECL)\n+ggc_internal_alloc_stat (size_t size MEM_STAT_DECL)\n {\n-  return ggc_alloc_zone_pass_stat (size, &main_zone);\n+  return ggc_internal_alloc_zone_pass_stat (size, &main_zone);\n }\n \n /* Poison the chunk.  */\n@@ -1715,31 +1729,6 @@ new_ggc_zone_1 (struct alloc_zone *new_zone, const char * name)\n   G.zones->next_zone = new_zone;\n }\n \n-struct alloc_zone *\n-new_ggc_zone (const char * name)\n-{\n-  struct alloc_zone *new_zone = XCNEW (struct alloc_zone);\n-  new_ggc_zone_1 (new_zone, name);\n-  return new_zone;\n-}\n-\n-/* Destroy a GGC zone.  */\n-void\n-destroy_ggc_zone (struct alloc_zone * dead_zone)\n-{\n-  struct alloc_zone *z;\n-\n-  for (z = G.zones; z && z->next_zone != dead_zone; z = z->next_zone)\n-    /* Just find that zone.  */\n-    continue;\n-\n-  /* We should have found the zone in the list.  Anything else is fatal.  */\n-  gcc_assert (z);\n-\n-  /* z is dead, baby. z is dead.  */\n-  z->dead = true;\n-}\n-\n /* Free all empty pages and objects within a page for a given zone  */\n \n static void\n@@ -2488,6 +2477,12 @@ ggc_pch_read (FILE *f, void *addr)\n \n   /* We've just read in a PCH file.  So, every object that used to be\n      allocated is now free.  */\n+#ifdef 0 && GATHER_STATISTICS\n+  zone_allocate_marks ();\n+  ggc_prune_overhead_list ();\n+  zone_free_marks ();\n+#endif\n+\n   for (zone = G.zones; zone; zone = zone->next_zone)\n     {\n       struct small_page_entry *page, *next_page;"}, {"sha": "7f2144c0f122266f2e4476d8e77d5d5d236dce07", "filename": "gcc/ggc.h", "status": "modified", "additions": 158, "deletions": 134, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,7 +1,7 @@\n /* Garbage collection for the GNU compiler.\n \n    Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007,\n-   2008, 2009 Free Software Foundation, Inc.\n+   2008, 2009, 2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -28,11 +28,9 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Constants for general use.  */\n extern const char empty_string[];\t/* empty string */\n-extern const char digit_vector[];\t/* \"0\" .. \"9\" */\n-#define digit_string(d) (digit_vector + ((d) * 2))\n \n /* Internal functions and data structures used by the GTY\n-   machinery.  */\n+   machinery, including the generated gt*.[hc] files.  */\n \n /* The first parameter is a pointer to a pointer, the second a cookie.  */\n typedef void (*gt_pointer_operator) (void *, void *);\n@@ -118,112 +116,48 @@ extern int ggc_set_mark\t(const void *);\n    static objects, stack variables, or memory allocated with malloc.  */\n extern int ggc_marked_p\t(const void *);\n \n-/* Mark the entries in the string pool.  */\n-extern void ggc_mark_stringpool\t(void);\n-\n-/* Purge the entries in the string pool.  */\n-extern void ggc_purge_stringpool (void);\n-\n-/* Call ggc_set_mark on all the roots.  */\n-\n-extern void ggc_mark_roots (void);\n-\n-/* Save and restore the string pool entries for PCH.  */\n-\n-extern void gt_pch_save_stringpool (void);\n-extern void gt_pch_fixup_stringpool (void);\n-extern void gt_pch_restore_stringpool (void);\n-\n /* PCH and GGC handling for strings, mostly trivial.  */\n-\n-extern void gt_pch_p_S (void *, void *, gt_pointer_operator, void *);\n extern void gt_pch_n_S (const void *);\n extern void gt_ggc_m_S (const void *);\n \n-/* Initialize the string pool.  */\n-extern void init_stringpool (void);\n+/* End of GTY machinery API.  */\n \n-/* A GC implementation must provide these functions.  They are internal\n-   to the GC system.  */\n-\n-/* Forward declare the zone structure.  Only ggc_zone implements this.  */\n struct alloc_zone;\n \n+/* Initialize the string pool.  */\n+extern void init_stringpool (void);\n+\n /* Initialize the garbage collector.  */\n extern void init_ggc (void);\n \n-/* Start a new GGC zone.  */\n-extern struct alloc_zone *new_ggc_zone (const char *);\n-\n-/* Free a complete GGC zone, destroying everything in it.  */\n-extern void destroy_ggc_zone (struct alloc_zone *);\n-\n-struct ggc_pch_data;\n-\n-/* Return a new ggc_pch_data structure.  */\n-extern struct ggc_pch_data *init_ggc_pch (void);\n-\n-/* The second parameter and third parameters give the address and size\n-   of an object.  Update the ggc_pch_data structure with as much of\n-   that information as is necessary. The bool argument should be true\n-   if the object is a string.  */\n-extern void ggc_pch_count_object (struct ggc_pch_data *, void *, size_t, bool,\n-\t\t\t\t  enum gt_types_enum);\n-\n-/* Return the total size of the data to be written to hold all\n-   the objects previously passed to ggc_pch_count_object.  */\n-extern size_t ggc_pch_total_size (struct ggc_pch_data *);\n-\n-/* The objects, when read, will most likely be at the address\n-   in the second parameter.  */\n-extern void ggc_pch_this_base (struct ggc_pch_data *, void *);\n-\n-/* Assuming that the objects really do end up at the address\n-   passed to ggc_pch_this_base, return the address of this object.\n-   The bool argument should be true if the object is a string.  */\n-extern char *ggc_pch_alloc_object (struct ggc_pch_data *, void *, size_t, bool,\n-\t\t\t\t   enum gt_types_enum);\n-\n-/* Write out any initial information required.  */\n-extern void ggc_pch_prepare_write (struct ggc_pch_data *, FILE *);\n-/* Write out this object, including any padding.  The last argument should be\n-   true if the object is a string.  */\n-extern void ggc_pch_write_object (struct ggc_pch_data *, FILE *, void *,\n-\t\t\t\t  void *, size_t, bool);\n-/* All objects have been written, write out any final information\n-   required.  */\n-extern void ggc_pch_finish (struct ggc_pch_data *, FILE *);\n-\n-/* A PCH file has just been read in at the address specified second\n-   parameter.  Set up the GC implementation for the new objects.  */\n-extern void ggc_pch_read (FILE *, void *);\n-\n-\f\n-/* Allocation.  */\n-\n-/* When set, ggc_collect will do collection.  */\n-extern bool ggc_force_collect;\n-\n /* When true, identifier nodes are considered as GC roots.  When\n    false, identifier nodes are treated like any other GC-allocated\n    object, and the identifier hash table is treated as a weak\n    hash.  */\n extern bool ggc_protect_identifiers;\n \n+/* Write out all GCed objects to F.  */\n+extern void gt_pch_save (FILE *f);\n+\n+\f\n+/* Allocation.  */\n+\n /* The internal primitive.  */\n-extern void *ggc_alloc_stat (size_t MEM_STAT_DECL);\n-#define ggc_alloc(s) ggc_alloc_stat (s MEM_STAT_INFO)\n+extern void *ggc_internal_alloc_stat (size_t MEM_STAT_DECL);\n+\n+#define ggc_internal_alloc(s) ggc_internal_alloc_stat (s MEM_STAT_INFO)\n+\n /* Allocate an object of the specified type and size.  */\n extern void *ggc_alloc_typed_stat (enum gt_types_enum, size_t MEM_STAT_DECL);\n-#define ggc_alloc_typed(s,z) ggc_alloc_typed_stat (s,z MEM_STAT_INFO)\n-/* Like ggc_alloc, but allocates cleared memory.  */\n-extern void *ggc_alloc_cleared_stat (size_t MEM_STAT_DECL);\n-#define ggc_alloc_cleared(s) ggc_alloc_cleared_stat (s MEM_STAT_INFO)\n+\n+#define ggc_alloc_typed(s, z) ggc_alloc_typed_stat (s, z MEM_STAT_INFO)\n+\n+/* Allocates cleared memory.  */\n+extern void *ggc_internal_cleared_alloc_stat (size_t MEM_STAT_DECL);\n+\n /* Resize a block.  */\n extern void *ggc_realloc_stat (void *, size_t MEM_STAT_DECL);\n-#define ggc_realloc(s,z) ggc_realloc_stat (s,z MEM_STAT_INFO)\n-/* Like ggc_alloc_cleared, but performs a multiplication.  */\n-extern void *ggc_calloc (size_t, size_t);\n+\n /* Free a block.  To be used when known for certain it's not reachable.  */\n extern void ggc_free (void *);\n \n@@ -233,39 +167,67 @@ extern void ggc_prune_overhead_list (void);\n \n extern void dump_ggc_loc_statistics (bool);\n \n-/* Type-safe, C++-friendly versions of ggc_alloc() and gcc_calloc().  */\n-#define GGC_NEW(T)\t\t((T *) ggc_alloc (sizeof (T)))\n-#define GGC_CNEW(T)\t\t((T *) ggc_alloc_cleared (sizeof (T)))\n-#define GGC_NEWVEC(T, N)\t((T *) ggc_alloc ((N) * sizeof(T)))\n-#define GGC_CNEWVEC(T, N)\t((T *) ggc_alloc_cleared ((N) * sizeof(T)))\n-#define GGC_RESIZEVEC(T, P, N)  ((T *) ggc_realloc ((P), (N) * sizeof (T)))\n-#define GGC_NEWVAR(T, S)\t((T *) ggc_alloc ((S)))\n-#define GGC_CNEWVAR(T, S)\t((T *) ggc_alloc_cleared ((S)))\n-#define GGC_RESIZEVAR(T, P, N)  ((T *) ggc_realloc ((P), (N)))\n+/* Reallocators.  */\n+#define GGC_RESIZEVEC(T, P, N) \\\n+    ((T *) ggc_realloc_stat ((P), (N) * sizeof (T) MEM_STAT_INFO))\n+\n+#define GGC_RESIZEVAR(T, P, N)                          \\\n+    ((T *) ggc_realloc_stat ((P), (N) MEM_STAT_INFO))\n+\n+static inline void *\n+ggc_internal_vec_alloc_stat (size_t s, size_t c MEM_STAT_DECL)\n+{\n+    return ggc_internal_alloc_stat (c * s PASS_MEM_STAT);\n+}\n+\n+static inline void *\n+ggc_internal_cleared_vec_alloc_stat (size_t s, size_t c MEM_STAT_DECL)\n+{\n+    return ggc_internal_cleared_alloc_stat (c * s PASS_MEM_STAT);\n+}\n+\n+#define ggc_internal_cleared_vec_alloc(s, c) \\\n+    (ggc_internal_cleared_vec_alloc_stat ((s), (c) MEM_STAT_INFO))\n+\n+static inline void *\n+ggc_alloc_atomic_stat (size_t s MEM_STAT_DECL)\n+{\n+    return ggc_internal_alloc_stat (s PASS_MEM_STAT);\n+}\n+\n+#define ggc_alloc_atomic(S)  (ggc_alloc_atomic_stat ((S) MEM_STAT_INFO))\n+\n+#define ggc_alloc_cleared_atomic(S)             \\\n+    (ggc_internal_cleared_alloc_stat ((S) MEM_STAT_INFO))\n \n-#define ggc_alloc_rtvec(NELT)\t\t\t\t\t\t \\\n-  ((rtvec) ggc_alloc_zone (sizeof (struct rtvec_def) + ((NELT) - 1)\t \\\n-\t\t\t   * sizeof (rtx), &rtl_zone))\n+extern void * ggc_cleared_alloc_htab_ignore_args (size_t, size_t);\n \n-#define ggc_alloc_tree(LENGTH) ((tree) ggc_alloc_zone (LENGTH, &tree_zone))\n+extern void * ggc_cleared_alloc_ptr_array_two_args (size_t, size_t);\n \n #define htab_create_ggc(SIZE, HASH, EQ, DEL) \\\n-  htab_create_alloc (SIZE, HASH, EQ, DEL, ggc_calloc, ggc_free)\n+  htab_create_typed_alloc (SIZE, HASH, EQ, DEL,\t\\\n+\t\t\t   ggc_cleared_alloc_htab_ignore_args,\t\t\\\n+\t\t\t   ggc_cleared_alloc_ptr_array_two_args,\t\\\n+\t\t\t   ggc_free)\n+\n+#define splay_tree_new_ggc(COMPARE, ALLOC_TREE, ALLOC_NODE)\t\t     \\\n+  splay_tree_new_typed_alloc (COMPARE, NULL, NULL, &ALLOC_TREE, &ALLOC_NODE, \\\n+\t\t\t      &ggc_splay_dont_free, NULL)\n+\n+extern void *ggc_splay_alloc (enum gt_types_enum, int, void *);\n \n-#define splay_tree_new_ggc(COMPARE)\t\t\t\t\t \\\n-  splay_tree_new_with_allocator (COMPARE, NULL, NULL,\t\t\t \\\n-                                 &ggc_splay_alloc, &ggc_splay_dont_free, \\\n-\t\t\t\t NULL)\n-extern void *ggc_splay_alloc (int, void *);\n extern void ggc_splay_dont_free (void *, void *);\n \n /* Allocate a gc-able string, and fill it with LENGTH bytes from CONTENTS.\n    If LENGTH is -1, then CONTENTS is assumed to be a\n    null-terminated string and the memory sized accordingly.  */\n-extern const char *ggc_alloc_string (const char *contents, int length);\n+extern const char *ggc_alloc_string_stat (const char *contents, int length\n+                                          MEM_STAT_DECL);\n+\n+#define ggc_alloc_string(c, l) ggc_alloc_string_stat (c, l MEM_STAT_INFO)\n \n /* Make a copy of S, in GC-able memory.  */\n-#define ggc_strdup(S) ggc_alloc_string((S), -1)\n+#define ggc_strdup(S) ggc_alloc_string_stat ((S), -1 MEM_STAT_INFO)\n \n /* Invoke the collector.  Garbage collection occurs only when this\n    function is called, not during allocations.  */\n@@ -279,55 +241,117 @@ extern void ggc_register_root_tab (const struct ggc_root_tab *);\n    plugins.  Does nothing if the passed pointer is NULL. */\n extern void ggc_register_cache_tab (const struct ggc_cache_tab *);\n \n-/* Return the number of bytes allocated at the indicated address.  */\n-extern size_t ggc_get_size (const void *);\n-\n-/* Write out all GCed objects to F.  */\n-extern void gt_pch_save (FILE *f);\n-\n /* Read objects previously saved with gt_pch_save from F.  */\n extern void gt_pch_restore (FILE *f);\n \f\n /* Statistics.  */\n \n-/* This structure contains the statistics common to all collectors.\n-   Particular collectors can extend this structure.  */\n-typedef struct ggc_statistics\n-{\n-  /* At present, we don't really gather any interesting statistics.  */\n-  int unused;\n-} ggc_statistics;\n-\n-/* Used by the various collectors to gather and print statistics that\n-   do not depend on the collector in use.  */\n-extern void ggc_print_common_statistics (FILE *, ggc_statistics *);\n-\n /* Print allocation statistics.  */\n extern void ggc_print_statistics (void);\n+\n extern void stringpool_statistics (void);\n \n /* Heuristics.  */\n extern void init_ggc_heuristics (void);\n \n /* Zone collection.  */\n-#if defined (GGC_ZONE) && !defined (GENERATOR_FILE)\n \n /* For regular rtl allocations.  */\n extern struct alloc_zone rtl_zone;\n+\n /* For regular tree allocations.  */\n extern struct alloc_zone tree_zone;\n+\n /* For IDENTIFIER_NODE allocations.  */\n extern struct alloc_zone tree_id_zone;\n \n+#define ggc_alloc_rtvec_sized(NELT)                                     \\\n+    (ggc_alloc_zone_vec_rtvec_def (sizeof (rtx),                        \\\n+                                   sizeof (struct rtvec_def) + ((NELT) - 1), \\\n+                                   &rtl_zone))\n+\n+#if defined (GGC_ZONE) && !defined (GENERATOR_FILE)\n+\n /* Allocate an object into the specified allocation zone.  */\n-extern void *ggc_alloc_zone_stat (size_t, struct alloc_zone * MEM_STAT_DECL);\n-# define ggc_alloc_zone(s,z) ggc_alloc_zone_stat (s,z MEM_STAT_INFO)\n-# define ggc_alloc_zone_pass_stat(s,z) ggc_alloc_zone_stat (s,z PASS_MEM_STAT)\n+extern void *ggc_internal_alloc_zone_stat (size_t,\n+\t\t\t\t\t  struct alloc_zone * MEM_STAT_DECL);\n+\n+extern void *ggc_internal_cleared_alloc_zone_stat (size_t,\n+\t\t\t\t\t  struct alloc_zone * MEM_STAT_DECL);\n+\n+static inline void *\n+ggc_internal_zone_alloc_stat (struct alloc_zone * z, size_t s MEM_STAT_DECL)\n+{\n+    return ggc_internal_alloc_zone_stat (s, z PASS_MEM_STAT);\n+}\n+\n+static inline void *\n+ggc_internal_zone_cleared_alloc_stat (struct alloc_zone * z, size_t s\n+                                      MEM_STAT_DECL)\n+{\n+    return ggc_internal_cleared_alloc_zone_stat (s, z PASS_MEM_STAT);\n+}\n+\n+static inline void *\n+ggc_internal_zone_vec_alloc_stat (struct alloc_zone * z, size_t s, size_t n\n+                                  MEM_STAT_DECL)\n+{\n+    return ggc_internal_alloc_zone_stat (s * n, z PASS_MEM_STAT);\n+}\n+\n+\n #else\n \n-# define ggc_alloc_zone(s, z) ggc_alloc (s)\n-# define ggc_alloc_zone_pass_stat(s, z) ggc_alloc_stat (s PASS_MEM_STAT)\n+static inline void *\n+ggc_internal_zone_alloc_stat (struct alloc_zone * z ATTRIBUTE_UNUSED,\n+                              size_t s MEM_STAT_DECL)\n+{\n+    return ggc_internal_alloc_stat (s PASS_MEM_STAT);\n+}\n+\n+static inline void *\n+ggc_internal_zone_cleared_alloc_stat (struct alloc_zone * z ATTRIBUTE_UNUSED,\n+                                      size_t s MEM_STAT_DECL)\n+{\n+    return ggc_internal_cleared_alloc_stat (s PASS_MEM_STAT);\n+}\n+\n+static inline void *\n+ggc_internal_zone_vec_alloc_stat (struct alloc_zone * z ATTRIBUTE_UNUSED,\n+                                  size_t s, size_t n MEM_STAT_DECL)\n+{\n+    return ggc_internal_vec_alloc_stat (s, n PASS_MEM_STAT);\n+}\n \n #endif\n \n+/* Memory statistics passing versions of some allocators.  Too few of them to\n+   make gengtype produce them, so just define the needed ones here.  */\n+static inline struct rtx_def *\n+ggc_alloc_zone_rtx_def_stat (struct alloc_zone * z, size_t s MEM_STAT_DECL)\n+{\n+  return (struct rtx_def *) ggc_internal_zone_alloc_stat (z, s PASS_MEM_STAT);\n+}\n+\n+static inline union tree_node *\n+ggc_alloc_zone_tree_node_stat (struct alloc_zone * z, size_t s MEM_STAT_DECL)\n+{\n+  return (union tree_node *) ggc_internal_zone_alloc_stat (z, s PASS_MEM_STAT);\n+}\n+\n+static inline union tree_node *\n+ggc_alloc_zone_cleared_tree_node_stat (struct alloc_zone * z, size_t s\n+                                       MEM_STAT_DECL)\n+{\n+  return (union tree_node *)\n+    ggc_internal_zone_cleared_alloc_stat (z, s PASS_MEM_STAT);\n+}\n+\n+static inline union gimple_statement_d *\n+ggc_alloc_cleared_gimple_statement_d_stat (size_t s MEM_STAT_DECL)\n+{\n+  return (union gimple_statement_d *)\n+    ggc_internal_cleared_alloc_stat (s PASS_MEM_STAT);\n+}\n+\n #endif"}, {"sha": "13b66b6e00780bfb7e82b680cbb37ba08a0cbd2b", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -404,7 +404,7 @@ gsi_insert_before_without_update (gimple_stmt_iterator *i, gimple stmt,\n {\n   gimple_seq_node n;\n \n-  n = GGC_NEW (struct gimple_seq_node_d);\n+  n = ggc_alloc_gimple_seq_node_d ();\n   n->prev = n->next = NULL;\n   n->stmt = stmt;\n   gsi_insert_seq_nodes_before (i, n, n, m);\n@@ -439,7 +439,7 @@ gsi_insert_after_without_update (gimple_stmt_iterator *i, gimple stmt,\n {\n   gimple_seq_node n;\n \n-  n = GGC_NEW (struct gimple_seq_node_d);\n+  n = ggc_alloc_gimple_seq_node_d ();\n   n->prev = n->next = NULL;\n   n->stmt = stmt;\n   gsi_insert_seq_nodes_after (i, n, n, m);"}, {"sha": "b94998540de647b9126a150fff85ae1b7ef0cf38", "filename": "gcc/gimple.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -145,7 +145,7 @@ gimple_alloc_stat (enum gimple_code code, unsigned num_ops MEM_STAT_DECL)\n   }\n #endif\n \n-  stmt = (gimple) ggc_alloc_cleared_stat (size PASS_MEM_STAT);\n+  stmt = ggc_alloc_cleared_gimple_statement_d_stat (size PASS_MEM_STAT);\n   gimple_set_code (stmt, code);\n   gimple_set_num_ops (stmt, num_ops);\n \n@@ -824,7 +824,8 @@ gimple_build_omp_for (gimple_seq body, tree clauses, size_t collapse,\n     gimple_omp_set_body (p, body);\n   gimple_omp_for_set_clauses (p, clauses);\n   p->gimple_omp_for.collapse = collapse;\n-  p->gimple_omp_for.iter = GGC_CNEWVEC (struct gimple_omp_for_iter, collapse);\n+  p->gimple_omp_for.iter\n+      = ggc_alloc_cleared_vec_gimple_omp_for_iter (collapse);\n   if (pre_body)\n     gimple_omp_for_set_pre_body (p, pre_body);\n \n@@ -1074,7 +1075,7 @@ gimple_seq_alloc (void)\n     }\n   else\n     {\n-      seq = (gimple_seq) ggc_alloc_cleared (sizeof (*seq));\n+      seq = ggc_alloc_cleared_gimple_seq_d ();\n #ifdef GATHER_STATISTICS\n       gimple_alloc_counts[(int) gimple_alloc_kind_seq]++;\n       gimple_alloc_sizes[(int) gimple_alloc_kind_seq] += sizeof (*seq);\n@@ -2122,8 +2123,8 @@ gimple_copy (gimple stmt)\n \t  t = unshare_expr (gimple_omp_for_clauses (stmt));\n \t  gimple_omp_for_set_clauses (copy, t);\n \t  copy->gimple_omp_for.iter\n-\t    = GGC_NEWVEC (struct gimple_omp_for_iter,\n-\t\t\t  gimple_omp_for_collapse (stmt));\n+\t    = ggc_alloc_vec_gimple_omp_for_iter\n+\t    (gimple_omp_for_collapse (stmt));\n \t  for (i = 0; i < gimple_omp_for_collapse (stmt); i++)\n \t    {\n \t      gimple_omp_for_set_cond (copy, i,"}, {"sha": "d847e88699737f55733005b846d498849940fe60", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -752,7 +752,7 @@ enum gimple_statement_structure_enum {\n /* Define the overall contents of a gimple tuple.  It may be any of the\n    structures declared above for various types of tuples.  */\n \n-union GTY ((desc (\"gimple_statement_structure (&%h)\"))) gimple_statement_d {\n+union GTY ((desc (\"gimple_statement_structure (&%h)\"), variable_size)) gimple_statement_d {\n   struct gimple_statement_base GTY ((tag (\"GSS_BASE\"))) gsbase;\n   struct gimple_statement_with_ops GTY ((tag (\"GSS_WITH_OPS\"))) gsops;\n   struct gimple_statement_with_memory_ops_base GTY ((tag (\"GSS_WITH_MEM_OPS_BASE\"))) gsmembase;"}, {"sha": "b4c1362b3a157edd098d272429f27f3d906cefbb", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -246,10 +246,10 @@ get_hard_reg_initial_val (enum machine_mode mode, unsigned int regno)\n   ivs = crtl->hard_reg_initial_vals;\n   if (ivs == 0)\n     {\n-      ivs = GGC_NEW (initial_value_struct);\n+      ivs = ggc_alloc_initial_value_struct ();\n       ivs->num_entries = 0;\n       ivs->max_entries = 5;\n-      ivs->entries = GGC_NEWVEC (initial_value_pair, 5);\n+      ivs->entries = ggc_alloc_vec_initial_value_pair (5);\n       crtl->hard_reg_initial_vals = ivs;\n     }\n "}, {"sha": "1c1809b61d05222e921f9d5b5fa7f890c0fc512b", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -838,7 +838,7 @@ ipcp_create_replace_map (tree parm_tree, struct ipcp_lattice *lat)\n   struct ipa_replace_map *replace_map;\n   tree const_val;\n \n-  replace_map = GGC_NEW (struct ipa_replace_map);\n+  replace_map = ggc_alloc_ipa_replace_map ();\n   const_val = build_const_val (lat, TREE_TYPE (parm_tree));\n   if (dump_file)\n     {"}, {"sha": "6aeca33ca804cda20ae106e7a0b34dbf7039771b", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -892,8 +892,8 @@ ipa_compute_jump_functions_for_edge (struct cgraph_edge *cs)\n \n   if (ipa_get_cs_argument_count (arguments) == 0 || arguments->jump_functions)\n     return;\n-  arguments->jump_functions = GGC_CNEWVEC (struct ipa_jump_func,\n-\t\t\t\t\t   ipa_get_cs_argument_count (arguments));\n+  arguments->jump_functions = ggc_alloc_cleared_vec_ipa_jump_func\n+    (ipa_get_cs_argument_count (arguments));\n \n   call = cs->call_stmt;\n   gcc_assert (is_gimple_call (call));\n@@ -1696,18 +1696,16 @@ duplicate_array (void *src, size_t n)\n   return p;\n }\n \n-/* Like duplicate_array byt in GGC memory.  */\n-\n-static void *\n-duplicate_ggc_array (void *src, size_t n)\n+static struct ipa_jump_func *\n+duplicate_ipa_jump_func_array (const struct ipa_jump_func * src, size_t n)\n {\n-  void *p;\n+  struct ipa_jump_func *p;\n \n   if (!src)\n     return NULL;\n \n-  p = ggc_alloc (n);\n-  memcpy (p, src, n);\n+  p = ggc_alloc_vec_ipa_jump_func (n);\n+  memcpy (p, src, n * sizeof (struct ipa_jump_func));\n   return p;\n }\n \n@@ -1727,9 +1725,8 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \n   arg_count = ipa_get_cs_argument_count (old_args);\n   ipa_set_cs_argument_count (new_args, arg_count);\n-  new_args->jump_functions = (struct ipa_jump_func *)\n-    duplicate_ggc_array (old_args->jump_functions,\n-\t\t         sizeof (struct ipa_jump_func) * arg_count);\n+  new_args->jump_functions =\n+    duplicate_ipa_jump_func_array (old_args->jump_functions, arg_count);\n \n   if (iinlining_processed_edges\n       && bitmap_bit_p (iinlining_processed_edges, src->uid))\n@@ -2525,8 +2522,8 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n       if (!count)\n \tcontinue;\n \n-      args->jump_functions = GGC_CNEWVEC (struct ipa_jump_func,\n-\t\t\t\t          ipa_get_cs_argument_count (args));\n+      args->jump_functions = ggc_alloc_cleared_vec_ipa_jump_func\n+\t(ipa_get_cs_argument_count (args));\n       for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n \tipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), data_in);\n     }"}, {"sha": "0cf2987427c71b0f42ef97a11ce5a3d6c567ee2c", "filename": "gcc/ipa.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -887,7 +887,7 @@ cgraph_node_set_new (void)\n {\n   cgraph_node_set new_node_set;\n \n-  new_node_set = GGC_NEW (struct cgraph_node_set_def);\n+  new_node_set = ggc_alloc_cgraph_node_set_def ();\n   new_node_set->hashtab = htab_create_ggc (10,\n \t\t\t\t\t   hash_cgraph_node_set_element,\n \t\t\t\t\t   eq_cgraph_node_set_element,\n@@ -918,8 +918,7 @@ cgraph_node_set_add (cgraph_node_set set, struct cgraph_node *node)\n     }\n \n   /* Insert node into hash table.  */\n-  element =\n-    (cgraph_node_set_element) GGC_NEW (struct cgraph_node_set_element_def);\n+  element = ggc_alloc_cgraph_node_set_element_def ();\n   element->node = node;\n   element->index = VEC_length (cgraph_node_ptr, set->nodes);\n   *slot = element;\n@@ -1045,7 +1044,7 @@ varpool_node_set_new (void)\n {\n   varpool_node_set new_node_set;\n \n-  new_node_set = GGC_NEW (struct varpool_node_set_def);\n+  new_node_set = ggc_alloc_varpool_node_set_def ();\n   new_node_set->hashtab = htab_create_ggc (10,\n \t\t\t\t\t   hash_varpool_node_set_element,\n \t\t\t\t\t   eq_varpool_node_set_element,\n@@ -1076,8 +1075,7 @@ varpool_node_set_add (varpool_node_set set, struct varpool_node *node)\n     }\n \n   /* Insert node into hash table.  */\n-  element =\n-    (varpool_node_set_element) GGC_NEW (struct varpool_node_set_element_def);\n+  element = ggc_alloc_varpool_node_set_element_def ();\n   element->node = node;\n   element->index = VEC_length (varpool_node_ptr, set->nodes);\n   *slot = element;"}, {"sha": "bd65d5471405cee33f6c035554eda0b80326c3e3", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1791,8 +1791,7 @@ fix_reg_equiv_init (void)\n \n   if (reg_equiv_init_size < max_regno)\n     {\n-      reg_equiv_init\n-\t= (rtx *) ggc_realloc (reg_equiv_init, max_regno * sizeof (rtx));\n+      reg_equiv_init = GGC_RESIZEVEC (rtx, reg_equiv_init, max_regno);\n       while (reg_equiv_init_size < max_regno)\n \treg_equiv_init[reg_equiv_init_size++] = NULL_RTX;\n       for (i = FIRST_PSEUDO_REGISTER; i < reg_equiv_init_size; i++)\n@@ -2371,7 +2370,7 @@ update_equiv_regs (void)\n   recorded_label_ref = 0;\n \n   reg_equiv = XCNEWVEC (struct equivalence, max_regno);\n-  reg_equiv_init = GGC_CNEWVEC (rtx, max_regno);\n+  reg_equiv_init = ggc_alloc_cleared_vec_rtx (max_regno);\n   reg_equiv_init_size = max_regno;\n \n   init_alias_analysis ();"}, {"sha": "f06d42006e5b5cc21d69148c4665bd27a7f14f6e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,38 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* jcf-reader.c (jcf_parse_constant_pool): Use typed GC allocation.\n+\n+\t* jcf-parse.c (java_parse_file): Likewise.\n+\t(process_zip_dir): Likewise.\n+\n+\t* java-tree.h (MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC): Likewise.\n+\t(MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC): Likewise.\n+\n+\t* expr.c (add_type_assertion): Likewise.\n+\n+\t* decl.c (make_binding_level): Likewise.\n+\t(java_dup_lang_specific_decl): Likewise.\n+\n+\t* constants.c (set_constant_entry): Likewise.\n+\t(cpool_for_class): Likewise.\n+\n+\t* class.c (add_method_1): Likewise.\n+\t(java_treetreehash_new): Likewise.\n+\n+\t* java-tree.h (struct lang_type): Add variable_size GTY option.\n+\t(struct lang_decl): Likewise.\n+\n+\t* jch.h (struct cpool_entry): Likewise.\n+\n+\t* java-tree.h (java_treetreehash_create): Remove parameter ggc.\n+\n+\t* except.c (prepare_eh_table_type): Update\n+\tjava_treetreehash_create call.\n+\n+\t* class.c (add_method_1): Update java_treetreehash_create call.\n+\t(java_treetreehash_create): Remove parameter gc.  Use\n+\thtab_create_ggc.\n+\n 2010-06-04  Joseph Myers  <joseph@codesourcery.com>\n \n \t* jvspec.c (lang_specific_driver): Use GCC-specific formats in"}, {"sha": "47b721cd7d07e3edcc46540d0b0c5e41d1ad0776", "filename": "gcc/java/class.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -763,13 +763,12 @@ add_method_1 (tree this_class, int access_flags, tree name, tree function_type)\n   DECL_CONTEXT (fndecl) = this_class;\n \n   DECL_LANG_SPECIFIC (fndecl)\n-    = GGC_CNEW (struct lang_decl);\n+    = ggc_alloc_cleared_lang_decl(sizeof (struct lang_decl));\n   DECL_LANG_SPECIFIC (fndecl)->desc = LANG_DECL_FUNC;\n \n   /* Initialize the static initializer test table.  */\n-  \n-  DECL_FUNCTION_INIT_TEST_TABLE (fndecl) = \n-    java_treetreehash_create (10, 1);\n+\n+  DECL_FUNCTION_INIT_TEST_TABLE (fndecl) = java_treetreehash_create (10);\n \n   /* Initialize the initialized (static) class table. */\n   if (access_flags & ACC_STATIC)\n@@ -3144,7 +3143,7 @@ java_treetreehash_new (htab_t ht, tree t)\n   e = htab_find_slot_with_hash (ht, t, hv, INSERT);\n   if (*e == NULL)\n     {\n-      tthe = (struct treetreehash_entry *) (*ht->alloc_f) (1, sizeof (*tthe));\n+      tthe = ggc_alloc_cleared_treetreehash_entry ();\n       tthe->key = t;\n       *e = tthe;\n     }\n@@ -3154,14 +3153,10 @@ java_treetreehash_new (htab_t ht, tree t)\n }\n \n htab_t\n-java_treetreehash_create (size_t size, int gc)\n+java_treetreehash_create (size_t size)\n {\n-  if (gc)\n-    return htab_create_ggc (size, java_treetreehash_hash,\n-\t\t\t    java_treetreehash_compare, NULL);\n-  else\n-    return htab_create_alloc (size, java_treetreehash_hash,\n-\t\t\t      java_treetreehash_compare, free, xcalloc, free);\n+  return htab_create_ggc (size, java_treetreehash_hash,\n+\t\t\t  java_treetreehash_compare, NULL);\n }\n \n /* Break down qualified IDENTIFIER into package and class-name components."}, {"sha": "f018a707911466c94f36008cd9cce1f1039477f7", "filename": "gcc/java/constants.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -44,8 +44,11 @@ set_constant_entry (CPool *cpool, int index, int tag, jword value)\n   if (cpool->data == NULL)\n     {\n       cpool->capacity = 100;\n-      cpool->tags = GGC_CNEWVEC (uint8, cpool->capacity);\n-      cpool->data = GGC_CNEWVEC (union cpool_entry, cpool->capacity);\n+      cpool->tags = (uint8 *) ggc_alloc_cleared_atomic (sizeof (uint8)\n+\t\t\t\t\t\t* cpool->capacity);\n+      cpool->data = ggc_alloc_cleared_vec_cpool_entry (sizeof\n+\t\t\t\t\t\t       (union cpool_entry),\n+\t\t\t\t\t\t       cpool->capacity);\n       cpool->count = 1;\n     }\n   if (index >= cpool->capacity)\n@@ -333,7 +336,7 @@ cpool_for_class (tree klass)\n \n   if (cpool == NULL)\n     {\n-      cpool = GGC_CNEW (struct CPool);\n+      cpool = ggc_alloc_cleared_CPool ();\n       TYPE_CPOOL (klass) = cpool;\n     }\n   return cpool;"}, {"sha": "86ce719213c3b2571f1379f43aaef8269a49b88c", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1354,7 +1354,7 @@ static struct binding_level *\n make_binding_level (void)\n {\n   /* NOSTRICT */\n-  return GGC_CNEW (struct binding_level);\n+  return ggc_alloc_cleared_binding_level ();\n }\n \n void\n@@ -1696,7 +1696,7 @@ java_dup_lang_specific_decl (tree node)\n     return;\n \n   lang_decl_size = sizeof (struct lang_decl);\n-  x = GGC_NEW (struct lang_decl);\n+  x = ggc_alloc_lang_decl (lang_decl_size);\n   memcpy (x, DECL_LANG_SPECIFIC (node), lang_decl_size);\n   DECL_LANG_SPECIFIC (node) = x;\n }"}, {"sha": "f5a64071204fde0ee8cb9a6d71c6a70607576c29", "filename": "gcc/java/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -381,7 +381,7 @@ prepare_eh_table_type (tree type)\n     return NULL_TREE;\n \n   if (TYPE_TO_RUNTIME_MAP (output_class) == NULL)\n-    TYPE_TO_RUNTIME_MAP (output_class) = java_treetreehash_create (10, 1);\n+    TYPE_TO_RUNTIME_MAP (output_class) = java_treetreehash_create (10);\n   \n   slot = java_treetreehash_new (TYPE_TO_RUNTIME_MAP (output_class), type);\n   if (*slot != NULL)"}, {"sha": "042ed1b7297a8b6cf04d0e95b309c3ebbcd99d70", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -463,7 +463,7 @@ add_type_assertion (tree klass, int assertion_code, tree op1, tree op2)\n   if (*as_pp)\n     return;\n \n-  *as_pp = ggc_alloc (sizeof (type_assertion));\n+  *as_pp = ggc_alloc_type_assertion ();\n   **(type_assertion **)as_pp = as;\n }\n "}, {"sha": "282b5802ed9244fd5b9a3cc7c3d91fbfdfde417d", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -750,11 +750,12 @@ union GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n     (DECL_LANG_SPECIFIC (NODE)->u.v.vtable)\n \n /* Create a DECL_LANG_SPECIFIC if necessary. */\n-#define MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC(T)\t\t\t\\\n-  if (DECL_LANG_SPECIFIC (T) == NULL)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      DECL_LANG_SPECIFIC ((T)) = GGC_CNEW (struct lang_decl);\t\\\n-      DECL_LANG_SPECIFIC (T)->desc = LANG_DECL_VAR;\t\t\\\n+#define MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC(T)                       \\\n+  if (DECL_LANG_SPECIFIC (T) == NULL)                                \\\n+    {                                                                \\\n+      DECL_LANG_SPECIFIC ((T))                                       \\\n+        = ggc_alloc_cleared_lang_decl (sizeof (struct lang_decl));   \\\n+      DECL_LANG_SPECIFIC (T)->desc = LANG_DECL_VAR;                  \\\n     }\n \n /* A ConstantExpression, after folding and name resolution. */\n@@ -840,7 +841,7 @@ typedef struct GTY(()) type_assertion {\n \n extern tree java_treetreehash_find (htab_t, tree);\n extern tree * java_treetreehash_new (htab_t, tree);\n-extern htab_t java_treetreehash_create (size_t size, int ggc);\n+extern htab_t java_treetreehash_create (size_t size);\n \n /* DECL_LANG_SPECIFIC for VAR_DECL, PARM_DECL and sometimes FIELD_DECL\n    (access methods on outer class fields) and final fields. */\n@@ -861,7 +862,7 @@ struct GTY(()) lang_decl_var {\n \n enum lang_decl_desc {LANG_DECL_FUNC, LANG_DECL_VAR};\n \n-struct GTY(()) lang_decl {\n+struct GTY((variable_size)) lang_decl {\n   enum lang_decl_desc desc;\n   union lang_decl_u\n     {\n@@ -879,7 +880,7 @@ struct GTY(()) lang_decl {\n #define MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC(T) \\\n   if (TYPE_LANG_SPECIFIC ((T)) == NULL)\t\t\\\n      TYPE_LANG_SPECIFIC ((T))\t\t\t\\\n-     = GGC_CNEW (struct lang_type);\n+       = ggc_alloc_cleared_lang_type (sizeof (struct lang_type));\n \n #define TYPE_DUMMY(T)\t\t(TYPE_LANG_SPECIFIC(T)->dummy_class)\n \n@@ -924,7 +925,10 @@ typedef struct GTY(()) method_entry_d {\n DEF_VEC_O(method_entry);\n DEF_VEC_ALLOC_O(method_entry,gc);\n \n-struct GTY(()) lang_type {\n+/* FIXME: the variable_size annotation here is needed because these types are\n+   variable-sized in some other frontends.  Due to gengtype deficiency the GTY\n+   options of such types have to agree across all frontends. */\n+struct GTY((variable_size)) lang_type {\n   tree signature;\n   struct JCF *jcf;\n   struct CPool *cpool;"}, {"sha": "37d27b41b431df5ea45dc73819b91020d464adfd", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1906,8 +1906,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n       if (magic == 0xcafebabe)\n \t{\n \t  CLASS_FILE_P (node) = 1;\n-\t  current_jcf = GGC_NEW (JCF);\n-\t  JCF_ZERO (current_jcf);\n+\t  current_jcf = ggc_alloc_cleared_JCF ();\n \t  current_jcf->read_state = finput;\n \t  current_jcf->filbuf = jcf_filbuf_from_stdio;\n \t  jcf_parse (current_jcf);\n@@ -1924,8 +1923,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \t}\n       else if (magic == (JCF_u4)ZIPMAGIC)\n \t{\n-\t  main_jcf = GGC_NEW (JCF);\n-\t  JCF_ZERO (main_jcf);\n+\t  main_jcf = ggc_alloc_cleared_JCF ();\n \t  main_jcf->read_state = finput;\n \t  main_jcf->filbuf = jcf_filbuf_from_stdio;\n \t  linemap_add (line_table, LC_ENTER, false, filename, 0);\n@@ -2181,8 +2179,7 @@ process_zip_dir (FILE *finput)\n \n       class_name = compute_class_name (zdir);\n       file_name  = XNEWVEC (char, zdir->filename_length+1);\n-      jcf = GGC_NEW (JCF);\n-      JCF_ZERO (jcf);\n+      jcf = ggc_alloc_cleared_JCF ();\n \n       strncpy (file_name, class_name_in_zip_dir, zdir->filename_length);\n       file_name [zdir->filename_length] = '\\0';"}, {"sha": "069b29bf2771f615ec1d084a11047017b765844c", "filename": "gcc/java/jcf-reader.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -331,8 +331,8 @@ jcf_parse_constant_pool (JCF* jcf)\n {\n   int i, n;\n   JPOOL_SIZE (jcf) = (JCF_FILL (jcf, 2), JCF_readu2 (jcf));\n-  jcf->cpool.tags = GGC_NEWVAR (uint8, JPOOL_SIZE (jcf));\n-  jcf->cpool.data = GGC_NEWVAR (union cpool_entry, sizeof (jword) * JPOOL_SIZE (jcf));\n+  jcf->cpool.tags = (uint8 *) ggc_alloc_atomic (JPOOL_SIZE (jcf));\n+  jcf->cpool.data = ggc_alloc_cpool_entry (sizeof (jword) * JPOOL_SIZE (jcf));\n   jcf->cpool.tags[0] = 0;\n #ifdef HANDLE_START_CONSTANT_POOL\n   HANDLE_START_CONSTANT_POOL (JPOOL_SIZE (jcf));"}, {"sha": "c7a789d6f2b8a6a854f285be5c4aa9a42553fb1a", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -66,7 +66,7 @@ jcf_open_exact_case (const char* filename, int oflag);\n struct JCF;\n typedef int (*jcf_filbuf_t) (struct JCF*, int needed);\n \n-union GTY(()) cpool_entry {\n+union GTY((variable_size)) cpool_entry {\n   jword GTY ((tag (\"0\"))) w;\n   tree GTY ((tag (\"1\"))) t;\n };"}, {"sha": "4a291935fbf6ad8c1d04ad82009467321ff40404", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1703,7 +1703,7 @@ remove_iv (gimple iv_stmt)\n    TRANSFORM is the matrix transform that was applied to OLD_LOOPNEST to get\n    NEW_LOOPNEST.  */\n \n-void\n+void \n lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t\t\t\t VEC(tree,heap) *old_ivs,\n \t\t\t\t VEC(tree,heap) *invariants,\n@@ -2131,7 +2131,7 @@ replace_uses_equiv_to_x_with_y (struct loop *loop, gimple stmt, tree x,\n       gsi_insert_before (firstbsi, setstmt, GSI_SAME_STMT);\n       update_stmt (setstmt);\n       SET_USE (use_p, var);\n-      h = GGC_NEW (struct tree_map);\n+      h = ggc_alloc_tree_map ();\n       h->hash = in.hash;\n       h->base.from = use;\n       h->to = var;"}, {"sha": "8ef11b9dc6caca4f22a798ed98021e2ec4110761", "filename": "gcc/lambda.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -238,7 +238,7 @@ static inline void print_lambda_vector (FILE *, lambda_vector, int);\n static inline lambda_vector\n lambda_vector_new (int size)\n {\n-  return GGC_CNEWVEC (int, size);\n+  return (lambda_vector) ggc_alloc_cleared_atomic (sizeof (int) * size);\n }\n \n "}, {"sha": "2a2fbc359120a120a3b0581db1c6c6504f0eccfd", "filename": "gcc/loop-init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -45,7 +45,7 @@ loop_optimizer_init (unsigned flags)\n   struct loops *loops;\n \n   gcc_assert (!current_loops);\n-  loops = GGC_CNEW (struct loops);\n+  loops = ggc_alloc_cleared_loops ();\n \n   /* Find the loops.  */\n "}, {"sha": "dd7b954344036dd20647a92b531a6b354d69b97c", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1570,7 +1570,7 @@ input_node_opt_summary (struct cgraph_node *node,\n     {\n       int parm_num;\n       tree parm;\n-      struct ipa_replace_map *map = GGC_NEW (struct ipa_replace_map);\n+      struct ipa_replace_map *map = ggc_alloc_ipa_replace_map ();\n \n       VEC_safe_push (ipa_replace_map_p, gc, node->clone.tree_map, map);\n       for (parm_num = 0, parm = DECL_ARGUMENTS (node->decl); parm_num;"}, {"sha": "7f4065e6df6b82c620284464b5bab2a17201d6da", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -433,11 +433,7 @@ lto_get_decl_name_mapping (struct lto_file_decl_data *decl_data,\n struct lto_in_decl_state *\n lto_new_in_decl_state (void)\n {\n-  struct lto_in_decl_state *state;\n-\n-  state = ((struct lto_in_decl_state *) ggc_alloc (sizeof (*state)));\n-  memset (state, 0, sizeof (*state));\n-  return state;\n+  return ggc_alloc_cleared_lto_in_decl_state ();\n }\n \n /* Delete STATE and its components. */"}, {"sha": "0c9f90ae5587aa2654b71a80342ede784850dfc2", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -389,7 +389,7 @@ lto_input_eh_catch_list (struct lto_input_block *ib, struct data_in *data_in,\n       lto_tag_check_range (tag, LTO_eh_catch, LTO_eh_catch);\n \n       /* Read the catch node.  */\n-      n = GGC_CNEW (struct eh_catch_d);\n+      n = ggc_alloc_cleared_eh_catch_d ();\n       n->type_list = lto_input_tree (ib, data_in);\n       n->filter_list = lto_input_tree (ib, data_in);\n       n->label = lto_input_tree (ib, data_in);\n@@ -429,7 +429,7 @@ input_eh_region (struct lto_input_block *ib, struct data_in *data_in, int ix)\n   if (tag == LTO_null)\n     return NULL;\n \n-  r = GGC_CNEW (struct eh_region_d);\n+  r = ggc_alloc_cleared_eh_region_d ();\n   r->index = lto_input_sleb128 (ib);\n \n   gcc_assert (r->index == ix);\n@@ -502,7 +502,7 @@ input_eh_lp (struct lto_input_block *ib, struct data_in *data_in, int ix)\n \n   lto_tag_check_range (tag, LTO_eh_landing_pad, LTO_eh_landing_pad);\n \n-  lp = GGC_CNEW (struct eh_landing_pad_d);\n+  lp = ggc_alloc_cleared_eh_landing_pad_d ();\n   lp->index = lto_input_sleb128 (ib);\n   gcc_assert (lp->index == ix);\n   lp->next_lp = (eh_landing_pad) (intptr_t) lto_input_sleb128 (ib);\n@@ -707,7 +707,7 @@ make_new_block (struct function *fn, unsigned int index)\n   basic_block bb = alloc_block ();\n   bb->index = index;\n   SET_BASIC_BLOCK_FOR_FUNCTION (fn, index, bb);\n-  bb->il.gimple = GGC_CNEW (struct gimple_bb_info);\n+  bb->il.gimple = ggc_alloc_cleared_gimple_bb_info ();\n   n_basic_blocks_for_function (fn)++;\n   bb->flags = 0;\n   set_bb_seq (bb, gimple_seq_alloc ());\n@@ -1621,7 +1621,7 @@ unpack_ts_real_cst_value_fields (struct bitpack_d *bp, tree expr)\n   for (i = 0; i < SIGSZ; i++)\n     r.sig[i] = (unsigned long) bp_unpack_value (bp, HOST_BITS_PER_LONG);\n \n-  rp = GGC_NEW (REAL_VALUE_TYPE);\n+  rp = ggc_alloc_real_value ();\n   memcpy (rp, &r, sizeof (REAL_VALUE_TYPE));\n   TREE_REAL_CST_PTR (expr) = rp;\n }"}, {"sha": "8ff5bf57c787c928c73b68a53a2e4469bb0f2e20", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -605,6 +605,8 @@ struct GTY(()) lto_file_decl_data\n   htab_t GTY((skip)) renaming_hash_table;\n };\n \n+typedef struct lto_file_decl_data *lto_file_decl_data_ptr;\n+\n struct lto_char_ptr_base\n {\n   char *ptr;"}, {"sha": "6f46a733b427588fc793dc34ab9b863eb885d12f", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n-#include \"ggc.h\"\t/* lambda.h needs this */\n+#include \"ggc.h\"\n #include \"lambda.h\"\t/* gcd */\n #include \"hashtab.h\"\n #include \"plugin-api.h\"\n@@ -152,7 +152,7 @@ lto_symtab_register_decl (tree decl,\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     gcc_assert (!DECL_ABSTRACT (decl));\n \n-  new_entry = GGC_CNEW (struct lto_symtab_entry_def);\n+  new_entry = ggc_alloc_cleared_lto_symtab_entry_def ();\n   new_entry->id = DECL_ASSEMBLER_NAME (decl);\n   new_entry->decl = decl;\n   new_entry->resolution = resolution;"}, {"sha": "f021ba8a51ea4608b6fa1d0b751444245214d7f1", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,10 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* lto.c (lto_read_in_decl_state): Use typed GC allocation.\n+\t(lto_file_read): Likewise.\n+\t(new_partition): Likewise.\n+\t(read_cgraph_and_symbols): Likewise.\n+\n 2010-06-07  Joseph Myers  <joseph@codesourcery.com>\n \n \t* lto-lang.c (flag_no_builtin, flag_no_nonansi_builtin): Remove."}, {"sha": "721d8fbc2ff9bffddd761efb02099ac0555c1bbc", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -158,7 +158,7 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n   for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n     {\n       uint32_t size = *data++;\n-      tree *decls = GGC_NEWVEC (tree, size);\n+      tree *decls = ggc_alloc_vec_tree (size);\n \n       for (j = 0; j < size; j++)\n \t{\n@@ -364,7 +364,7 @@ lto_file_read (lto_file *file, FILE *resolution_file)\n   \n   resolutions = lto_resolution_read (resolution_file, file);\n \n-  file_data = GGC_NEW (struct lto_file_decl_data);\n+  file_data = ggc_alloc_lto_file_decl_data ();\n   file_data->file_name = file->filename;\n   file_data->section_hash_table = lto_obj_build_section_table (file);\n   file_data->renaming_hash_table = lto_create_renaming_table ();\n@@ -529,7 +529,7 @@ static GTY (()) VEC(ltrans_partition, gc) *ltrans_partitions;\n static ltrans_partition\n new_partition (const char *name)\n {\n-  ltrans_partition part = GGC_NEW (struct ltrans_partition_def);\n+  ltrans_partition part = ggc_alloc_ltrans_partition_def ();\n   part->cgraph_set = cgraph_node_set_new ();\n   part->varpool_set = varpool_node_set_new ();\n   part->name = name;\n@@ -1435,7 +1435,8 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   timevar_push (TV_IPA_LTO_DECL_IO);\n \n   /* Set the hooks so that all of the ipa passes can read in their data.  */\n-  all_file_decl_data = GGC_CNEWVEC (struct lto_file_decl_data *, nfiles + 1);\n+  all_file_decl_data\n+    = ggc_alloc_cleared_vec_lto_file_decl_data_ptr (nfiles + 1);\n   lto_set_in_hooks (all_file_decl_data, get_section_data, free_section_data);\n \n   /* Read the resolution file.  */"}, {"sha": "a05a140c7cbebfd8a69cc0512c542123279ac73d", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,16 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* objc-act.h (ALLOC_OBJC_TYPE_LANG_SPECIFIC): Use typed GC\n+\tallocation.\n+\n+\t* objc-act.c (objc_volatilize_decl): Likewise.\n+\t(objc_build_string_object): Likewise.\n+\t(hash_init): Likewise.\n+\t(hash_enter): Likewise.\n+\t(hash_add_attr): Likewise.\n+\t(add_class): Likewise.\n+\t(start_class): Likewise.\n+\n 2010-06-05  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* objc-act.c: Update include path for moved files."}, {"sha": "2ec9ca04009caf4a8dd0a94f874c80619c638937", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -976,7 +976,7 @@ objc_volatilize_decl (tree decl)\n \n       if (!*loc)\n \t{\n-\t  *loc = ggc_alloc (sizeof (key));\n+\t  *loc = ggc_alloc_volatilized_type ();\n \t  ((struct volatilized_type *) *loc)->type = t;\n \t}\n \n@@ -1986,7 +1986,7 @@ objc_build_string_object (tree string)\n     {\n       tree var;\n       VEC(constructor_elt,gc) *v = NULL;\n-      *loc = desc = GGC_NEW (struct string_descriptor);\n+      *loc = desc = ggc_alloc_string_descriptor ();\n       desc->literal = string;\n \n       /* GNU:    (NXConstantString *) & ((__builtin_ObjCString) { NULL, string, length })  */\n@@ -6843,10 +6843,8 @@ hash_func (tree sel_name)\n static void\n hash_init (void)\n {\n-  nst_method_hash_list\n-    = (hash *) ggc_alloc_cleared (SIZEHASHTABLE * sizeof (hash));\n-  cls_method_hash_list\n-    = (hash *) ggc_alloc_cleared (SIZEHASHTABLE * sizeof (hash));\n+  nst_method_hash_list = ggc_alloc_cleared_vec_hash (SIZEHASHTABLE);\n+  cls_method_hash_list = ggc_alloc_cleared_vec_hash (SIZEHASHTABLE);\n \n   /* Initialize the hash table used to hold the constant string objects.  */\n   string_htab = htab_create_ggc (31, string_hash,\n@@ -6868,7 +6866,7 @@ hash_enter (hash *hashlist, tree method)\n   hash obj;\n   int slot = hash_func (METHOD_SEL_NAME (method)) % SIZEHASHTABLE;\n \n-  obj = (hash) ggc_alloc (sizeof (struct hashed_entry));\n+  obj = ggc_alloc_hashed_entry ();\n   obj->list = 0;\n   obj->next = hashlist[slot];\n   obj->key = method;\n@@ -6898,7 +6896,7 @@ hash_add_attr (hash entry, tree value)\n {\n   attr obj;\n \n-  obj = (attr) ggc_alloc (sizeof (struct hashed_attribute));\n+  obj = ggc_alloc_hashed_attribute ();\n   obj->next = entry->list;\n   obj->value = value;\n \n@@ -7096,7 +7094,7 @@ add_class (tree class_name, tree name)\n \t\t\t      INSERT);\n   if (!*slot)\n     {\n-      *slot = (struct interface_tuple *) ggc_alloc_cleared (sizeof (struct interface_tuple));\n+      *slot = ggc_alloc_cleared_interface_tuple ();\n       (*slot)->id = name;\n     }\n   (*slot)->class_name = class_name;\n@@ -7735,7 +7733,7 @@ continue_class (tree klass)\n       uprivate_record = CLASS_STATIC_TEMPLATE (implementation_template);\n       objc_instance_type = build_pointer_type (uprivate_record);\n \n-      imp_entry = (struct imp_entry *) ggc_alloc (sizeof (struct imp_entry));\n+      imp_entry = ggc_alloc_imp_entry ();\n \n       imp_entry->next = imp_list;\n       imp_entry->imp_context = klass;"}, {"sha": "c8edd64bcf22140496f0a23f75e1c6210a30a48a", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -81,7 +81,8 @@ tree objc_eh_personality (void);\n #define SIZEOF_OBJC_TYPE_LANG_SPECIFIC sizeof (struct lang_type)\n #define ALLOC_OBJC_TYPE_LANG_SPECIFIC(NODE)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    TYPE_LANG_SPECIFIC (NODE) = GGC_CNEW (struct lang_type);\t\t\\\n+    TYPE_LANG_SPECIFIC (NODE)\t\t\t\t\t\t\\\n+      = ggc_alloc_cleared_lang_type (sizeof (struct lang_type));\t\\\n   } while (0)\n \n #define TYPE_HAS_OBJC_INFO(TYPE)\t\t\t\t\\"}, {"sha": "70731e13c213c3cf975d38a0f5887d9de249a433", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,8 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* objcp-decl.h (ALLOC_OBJC_TYPE_LANG_SPECIFIC): Use typed GC\n+\tallocation.\n+\n 2010-06-05  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* objcp-lang.c: Update include path for moved files."}, {"sha": "1f9f36c6a3f7634e2613010e2cfadb376545f086", "filename": "gcc/objcp/objcp-decl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fobjcp%2Fobjcp-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fobjcp%2Fobjcp-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-decl.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -73,8 +73,8 @@ extern tree objcp_end_compound_stmt (tree, int);\n #undef ALLOC_OBJC_TYPE_LANG_SPECIFIC\n #define ALLOC_OBJC_TYPE_LANG_SPECIFIC(NODE)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    TYPE_LANG_SPECIFIC (NODE) = GGC_CNEWVAR\t                        \\\n-      (struct lang_type, sizeof (struct lang_type_class));\t\t\\\n+    TYPE_LANG_SPECIFIC (NODE) = ggc_alloc_cleared_lang_type\t\t\\\n+      (sizeof (struct lang_type_class));\t\t\\\n     TYPE_LANG_SPECIFIC (NODE)->u.c.h.is_lang_type_class = 1;\t\t\\\n   } while (0)\n "}, {"sha": "52ecd0fbe48ed100ea017b0c496f4e2cf76de688", "filename": "gcc/omp-low.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -5887,7 +5887,9 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n       if (!critical_name_mutexes)\n \tcritical_name_mutexes\n-\t  = splay_tree_new_ggc (splay_tree_compare_pointers);\n+\t  = splay_tree_new_ggc (splay_tree_compare_pointers,\n+\t\t\t\tggc_alloc_splay_tree_tree_node_tree_node_splay_tree_s,\n+\t\t\t\tggc_alloc_splay_tree_tree_node_tree_node_splay_tree_node_s);\n \n       n = splay_tree_lookup (critical_name_mutexes, (splay_tree_key) name);\n       if (n == NULL)"}, {"sha": "f6642fbdafd4d3d51830f3a039dd787f8876885d", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -6132,7 +6132,7 @@ set_optab_libfunc (optab optable, enum machine_mode mode, const char *name)\n     val = 0;\n   slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, INSERT);\n   if (*slot == NULL)\n-    *slot = GGC_NEW (struct libfunc_entry);\n+    *slot = ggc_alloc_libfunc_entry ();\n   (*slot)->optab = (size_t) (optable - &optab_table[0]);\n   (*slot)->mode1 = mode;\n   (*slot)->mode2 = VOIDmode;\n@@ -6159,7 +6159,7 @@ set_conv_libfunc (convert_optab optable, enum machine_mode tmode,\n     val = 0;\n   slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, INSERT);\n   if (*slot == NULL)\n-    *slot = GGC_NEW (struct libfunc_entry);\n+    *slot = ggc_alloc_libfunc_entry ();\n   (*slot)->optab = (size_t) (optable - &convert_optab_table[0]);\n   (*slot)->mode1 = tmode;\n   (*slot)->mode2 = fmode;"}, {"sha": "3c295a033da6116d298e6c903fb6f1c08abf8ec0", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1120,7 +1120,7 @@ do_per_function (void (*callback) (void *data), void *data)\n    keep the array visible to garbage collector to avoid reading collected\n    out nodes.  */\n static int nnodes;\n-static GTY ((length (\"nnodes\"))) struct cgraph_node **order;\n+static GTY ((length (\"nnodes\"))) cgraph_node_ptr *order;\n \n /* If we are in IPA mode (i.e., current_function_decl is NULL), call\n    function CALLBACK for every function in the call graph.  Otherwise,\n@@ -1136,7 +1136,7 @@ do_per_function_toporder (void (*callback) (void *data), void *data)\n   else\n     {\n       gcc_assert (!order);\n-      order = GGC_NEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+      order = ggc_alloc_vec_cgraph_node_ptr (cgraph_n_nodes);\n       nnodes = cgraph_postorder (order);\n       for (i = nnodes - 1; i >= 0; i--)\n         order[i]->process = 1;"}, {"sha": "d886e9381d2f1cb68ab23027882b9e676d12d2ec", "filename": "gcc/rtl.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -149,7 +149,7 @@ rtvec_alloc (int n)\n {\n   rtvec rt;\n \n-  rt = ggc_alloc_rtvec (n);\n+  rt = ggc_alloc_rtvec_sized (n);\n   /* Clear out the vector.  */\n   memset (&rt->elem[0], 0, n * sizeof (rtx));\n \n@@ -193,9 +193,8 @@ rtx_size (const_rtx x)\n rtx\n rtx_alloc_stat (RTX_CODE code MEM_STAT_DECL)\n {\n-  rtx rt;\n-\n-  rt = (rtx) ggc_alloc_zone_pass_stat (RTX_CODE_SIZE (code), &rtl_zone);\n+  rtx rt = ggc_alloc_zone_rtx_def_stat (&rtl_zone, RTX_CODE_SIZE (code)\n+                                        PASS_MEM_STAT);\n \n   /* We want to clear everything up to the FLD array.  Normally, this\n      is one int, but we don't want to assume that and it isn't very\n@@ -337,7 +336,7 @@ rtx\n shallow_copy_rtx_stat (const_rtx orig MEM_STAT_DECL)\n {\n   const unsigned int size = rtx_size (orig);\n-  rtx const copy = (rtx) ggc_alloc_zone_pass_stat (size, &rtl_zone);\n+  rtx const copy = ggc_alloc_zone_rtx_def_stat (&rtl_zone, size PASS_MEM_STAT);\n   return (rtx) memcpy (copy, orig, size);\n }\n \f"}, {"sha": "5d67d27a382dc44b5efc6b69a9b11a7fdd9393c8", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -233,7 +233,7 @@ struct GTY(()) object_block {\n /* RTL expression (\"rtx\").  */\n \n struct GTY((chain_next (\"RTX_NEXT (&%h)\"),\n-\t\t    chain_prev (\"RTX_PREV (&%h)\"))) rtx_def {\n+\t    chain_prev (\"RTX_PREV (&%h)\"), variable_size)) rtx_def {\n   /* The kind of expression this is.  */\n   ENUM_BITFIELD(rtx_code) code: 16;\n \n@@ -352,7 +352,7 @@ struct GTY((chain_next (\"RTX_NEXT (&%h)\"),\n    for a variable number of things.  The principle use is inside\n    PARALLEL expressions.  */\n \n-struct GTY(()) rtvec_def {\n+struct GTY((variable_size)) rtvec_def {\n   int num_elem;\t\t/* number of elements */\n   rtx GTY ((length (\"%h.num_elem\"))) elem[1];\n };"}, {"sha": "2ed6485beed557744d231704f20771b7ee422bb3", "filename": "gcc/sese.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1493,7 +1493,7 @@ if_region_set_false_region (ifsese if_region, sese region)\n \n   if (slot)\n     {\n-      struct loop_exit *loop_exit = GGC_CNEW (struct loop_exit);\n+      struct loop_exit *loop_exit = ggc_alloc_cleared_loop_exit ();\n \n       memcpy (loop_exit, *((struct loop_exit **) slot), sizeof (struct loop_exit));\n       htab_clear_slot (current_loops->exits, slot);"}, {"sha": "8d45a26befcfd8b3ea2245974ca80d5e9fe8ef33", "filename": "gcc/stringpool.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,5 +1,5 @@\n /* String pool for GCC.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"ggc.h\"\n+#include \"ggc-internal.h\"\n #include \"tree.h\"\n #include \"symtab.h\"\n #include \"cpplib.h\"\n@@ -40,11 +41,13 @@ const char empty_string[] = \"\";\n \n /* Character strings, each containing a single decimal digit.\n    Written this way to save space.  */\n-const char digit_vector[] = {\n+static const char digit_vector[] = {\n   '0', 0, '1', 0, '2', 0, '3', 0, '4', 0,\n   '5', 0, '6', 0, '7', 0, '8', 0, '9', 0\n };\n \n+#define digit_string(d) (digit_vector + ((d) * 2))\n+\n struct ht *ident_hash;\n \n static hashnode alloc_node (hash_table *);\n@@ -53,7 +56,7 @@ static int mark_ident (struct cpp_reader *, hashnode, const void *);\n static void *\n stringpool_ggc_alloc (size_t x)\n {\n-  return ggc_alloc (x);\n+  return ggc_alloc_atomic (x);\n }\n \n /* Initialize the string pool.  */\n@@ -78,7 +81,7 @@ alloc_node (hash_table *table ATTRIBUTE_UNUSED)\n    nul-terminated string, and the length is calculated using strlen.  */\n \n const char *\n-ggc_alloc_string (const char *contents, int length)\n+ggc_alloc_string_stat (const char *contents, int length MEM_STAT_DECL)\n {\n   char *result;\n \n@@ -90,7 +93,7 @@ ggc_alloc_string (const char *contents, int length)\n   if (length == 1 && ISDIGIT (contents[0]))\n     return digit_string (contents[0] - '0');\n \n-  result = GGC_NEWVAR (char, length + 1);\n+  result = (char *) ggc_alloc_atomic_stat (length + 1 PASS_MEM_STAT);\n   memcpy (result, contents, length);\n   result[length] = '\\0';\n   return (const char *) result;\n@@ -215,7 +218,7 @@ gt_pch_n_S (const void *x)\n    to restore the string pool.  */\n \n struct GTY(()) string_pool_data {\n-  struct ht_identifier * *\n+  ht_identifier_ptr *\n     GTY((length (\"%h.nslots\"),\n \t nested_ptr (union tree_node, \"%h ? GCC_IDENT_TO_HT_IDENT (%h) : NULL\",\n \t\t     \"%h ? HT_IDENT_TO_GCC_IDENT (%h) : NULL\")))\n@@ -231,10 +234,10 @@ static GTY(()) struct string_pool_data * spd;\n void\n gt_pch_save_stringpool (void)\n {\n-  spd = GGC_NEW (struct string_pool_data);\n+  spd = ggc_alloc_string_pool_data ();\n   spd->nslots = ident_hash->nslots;\n   spd->nelements = ident_hash->nelements;\n-  spd->entries = GGC_NEWVEC (struct ht_identifier *, spd->nslots);\n+  spd->entries = ggc_alloc_vec_ht_identifier_ptr (spd->nslots);\n   memcpy (spd->entries, ident_hash->entries,\n \t  spd->nslots * sizeof (spd->entries[0]));\n }"}, {"sha": "20da382b1dde7107d8220c64d24aebffa5361a6d", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1627,15 +1627,15 @@ default_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n static void *\n realloc_for_line_map (void *ptr, size_t len)\n {\n-  return ggc_realloc (ptr, len);\n+  return GGC_RESIZEVAR (void, ptr, len);\n }\n \n /* A helper function: used as the allocator function for\n    identifier_to_locale.  */\n static void *\n alloc_for_identifier_to_locale (size_t len)\n {\n-  return ggc_alloc (len);\n+  return ggc_alloc_atomic (len);\n }\n \n /* Initialization of the front end environment, before command line\n@@ -1703,7 +1703,7 @@ general_init (const char *argv0)\n      table.  */\n   init_ggc ();\n   init_stringpool ();\n-  line_table = GGC_NEW (struct line_maps);\n+  line_table = ggc_alloc_line_maps ();\n   linemap_init (line_table);\n   line_table->reallocator = realloc_for_line_map;\n   init_ttree ();"}, {"sha": "f46556fe59a902a0b82844c2182c3c823faeb93a", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -436,13 +436,13 @@ create_bb (void *h, void *e, basic_block after)\n   gcc_assert (!e);\n \n   /* Create and initialize a new basic block.  Since alloc_block uses\n-     ggc_alloc_cleared to allocate a basic block, we do not have to\n-     clear the newly allocated basic block here.  */\n+     GC allocation that clears memory to allocate a basic block, we do\n+     not have to clear the newly allocated basic block here.  */\n   bb = alloc_block ();\n \n   bb->index = last_basic_block;\n   bb->flags = BB_NEW;\n-  bb->il.gimple = GGC_CNEW (struct gimple_bb_info);\n+  bb->il.gimple = ggc_alloc_cleared_gimple_bb_info ();\n   set_bb_seq (bb, h ? (gimple_seq) h : gimple_seq_alloc ());\n \n   /* Add the new block to the linked list of blocks.  */"}, {"sha": "485ebcf10fb77050685ac591342a3686cba033ca", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -134,7 +134,7 @@ create_var_ann (tree t)\n \t      || TREE_CODE (t) == PARM_DECL\n \t      || TREE_CODE (t) == RESULT_DECL);\n \n-  ann = GGC_CNEW (struct var_ann_d);\n+  ann = ggc_alloc_cleared_var_ann_d ();\n   *DECL_VAR_ANN_PTR (t) = ann;\n \n   return ann;"}, {"sha": "872d4241dc81b4a40a4033cb49724cace17b8c5a", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -96,7 +96,7 @@ add_stmt_to_eh_lp_fn (struct function *ifun, gimple t, int num)\n \n   gcc_assert (num != 0);\n \n-  n = GGC_NEW (struct throw_stmt_node);\n+  n = ggc_alloc_throw_stmt_node ();\n   n->stmt = t;\n   n->lp_nr = num;\n "}, {"sha": "1d0a40a30abc146559103c48605abbc2c6ff5ed6", "filename": "gcc/tree-iterator.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,5 +1,5 @@\n /* Iterator routines for manipulating GENERIC and GIMPLE tree statements.\n-   Copyright (C) 2003, 2004, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Andrew MacLeod  <amacleod@redhat.com>\n \n This file is part of GCC.\n@@ -130,7 +130,7 @@ tsi_link_before (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n     }\n   else\n     {\n-      head = GGC_NEW (struct tree_statement_list_node);\n+      head = ggc_alloc_tree_statement_list_node ();\n       head->prev = NULL;\n       head->next = NULL;\n       head->stmt = t;\n@@ -206,7 +206,7 @@ tsi_link_after (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n     }\n   else\n     {\n-      head = GGC_NEW (struct tree_statement_list_node);\n+      head = ggc_alloc_tree_statement_list_node ();\n       head->prev = NULL;\n       head->next = NULL;\n       head->stmt = t;"}, {"sha": "05b63fbea88708948b965175abfa1e16621416c2", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -153,7 +153,7 @@ allocate_phi_node (size_t len)\n     }\n   else\n     {\n-      phi = (gimple) ggc_alloc (size);\n+      phi = ggc_alloc_gimple_statement_d (size);\n #ifdef GATHER_STATISTICS\n       phi_nodes_created++;\n \t{"}, {"sha": "5eb61740bee8bbfd28a906bfa53b43c7efcd6318", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -314,7 +314,7 @@ new_scev_info_str (basic_block instantiated_below, tree var)\n {\n   struct scev_info_str *res;\n \n-  res = GGC_NEW (struct scev_info_str);\n+  res = ggc_alloc_scev_info_str ();\n   res->var = var;\n   res->chrec = chrec_not_analyzed_yet;\n   res->instantiated_below = instantiated_below;\n@@ -3017,12 +3017,9 @@ scev_initialize (void)\n   loop_iterator li;\n   struct loop *loop;\n \n-  scalar_evolution_info = htab_create_alloc (100,\n-\t\t\t\t\t     hash_scev_info,\n-\t\t\t\t\t     eq_scev_info,\n-\t\t\t\t\t     del_scev_info,\n-\t\t\t\t\t     ggc_calloc,\n-\t\t\t\t\t     ggc_free);\n+\n+  scalar_evolution_info = htab_create_ggc (100, hash_scev_info, eq_scev_info,\n+\t\t\t\t\t   del_scev_info);\n \n   initialize_scalar_evolutions_analyzer ();\n "}, {"sha": "e6836d77409ba19f24272b43ae47b233fff736a2", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -376,7 +376,7 @@ get_ptr_info (tree t)\n   pi = SSA_NAME_PTR_INFO (t);\n   if (pi == NULL)\n     {\n-      pi = GGC_CNEW (struct ptr_info_def);\n+      pi = ggc_alloc_cleared_ptr_info_def ();\n       pt_solution_reset (&pi->pt);\n       SSA_NAME_PTR_INFO (t) = pi;\n     }"}, {"sha": "accf17a4c237574a1abdca2aa9b2b70d209368fb", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -2521,7 +2521,7 @@ record_estimate (struct loop *loop, tree bound, double_int i_bound,\n      list.  */\n   if (upper)\n     {\n-      struct nb_iter_bound *elt = GGC_NEW (struct nb_iter_bound);\n+      struct nb_iter_bound *elt = ggc_alloc_nb_iter_bound ();\n \n       elt->bound = i_bound;\n       elt->stmt = at_stmt;"}, {"sha": "05e0f6ba2491f4c6766e43c45021654cdbaba978", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -320,9 +320,10 @@ ssa_operand_alloc (unsigned size)\n \t  gcc_unreachable ();\n \t}\n \n-      ptr = (struct ssa_operand_memory_d *)\n-\t      ggc_alloc (sizeof (void *)\n-\t\t\t + gimple_ssa_operands (cfun)->ssa_operand_mem_size);\n+\n+      ptr = ggc_alloc_ssa_operand_memory_d (sizeof (void *)\n+                        + gimple_ssa_operands (cfun)->ssa_operand_mem_size);\n+\n       ptr->next = gimple_ssa_operands (cfun)->operand_memory;\n       gimple_ssa_operands (cfun)->operand_memory = ptr;\n       gimple_ssa_operands (cfun)->operand_memory_index = 0;"}, {"sha": "4c586f7fb27da1462fcc6dd1e6c5b0784bf8b98e", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -54,7 +54,7 @@ typedef struct use_optype_d *use_optype_p;\n    operand memory manager.  Operands are suballocated out of this block.  The\n    MEM array varies in size.  */\n \n-struct GTY((chain_next(\"%h.next\"))) ssa_operand_memory_d {\n+struct GTY((chain_next(\"%h.next\"), variable_size)) ssa_operand_memory_d {\n   struct ssa_operand_memory_d *next;\n   char mem[1];\n };"}, {"sha": "05fd6d971f2456e303a866d1d016863622d8dea5", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -197,8 +197,7 @@\n    keep the set of called functions for indirect calls.\n \n    And probably more.  */\n-\n-static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n+static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct heapvar_map)))\n htab_t heapvar_for_stmt;\n \n static bool use_field_sensitive = true;\n@@ -379,7 +378,7 @@ heapvar_insert (tree from, unsigned HOST_WIDE_INT offset, tree to)\n   struct heapvar_map *h;\n   void **loc;\n \n-  h = GGC_NEW (struct heapvar_map);\n+  h = ggc_alloc_heapvar_map ();\n   h->map.base.from = from;\n   h->offset = offset;\n   h->map.hash = heapvar_map_hash (h);"}, {"sha": "866ce6eb2b7656d09e430a625daee54c017a9131", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1114,7 +1114,7 @@ uid_ssaname_map_hash (const void *item)\n void\n init_tree_ssa (struct function *fn)\n {\n-  fn->gimple_df = GGC_CNEW (struct gimple_df);\n+  fn->gimple_df = ggc_alloc_cleared_gimple_df ();\n   fn->gimple_df->referenced_vars = htab_create_ggc (20, uid_decl_map_hash,\n \t\t\t\t     \t\t    uid_decl_map_eq, NULL);\n   fn->gimple_df->default_defs = htab_create_ggc (20, uid_ssaname_map_hash,"}, {"sha": "79b844ffe7c477597339db00c3593272bd90133f", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -269,7 +269,7 @@ duplicate_ssa_name_ptr_info (tree name, struct ptr_info_def *ptr_info)\n   if (!ptr_info)\n     return;\n \n-  new_ptr_info = GGC_NEW (struct ptr_info_def);\n+  new_ptr_info = ggc_alloc_ptr_info_def ();\n   *new_ptr_info = *ptr_info;\n \n   SSA_NAME_PTR_INFO (name) = new_ptr_info;"}, {"sha": "3c1a8782cbbdd6dc4841726aec7a9928897c8e6f", "filename": "gcc/tree.c", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -853,13 +853,9 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n   tree_node_sizes[(int) kind] += length;\n #endif\n \n-  if (code == IDENTIFIER_NODE)\n-    t = (tree) ggc_alloc_zone_pass_stat (length, &tree_id_zone);\n-  else\n-    t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n-\n-  memset (t, 0, length);\n-\n+  t = ggc_alloc_zone_cleared_tree_node_stat (\n+               (code == IDENTIFIER_NODE) ? &tree_id_zone : &tree_zone,\n+               length PASS_MEM_STAT);\n   TREE_SET_CODE (t, code);\n \n   switch (type)\n@@ -952,7 +948,7 @@ copy_node_stat (tree node MEM_STAT_DECL)\n   gcc_assert (code != STATEMENT_LIST);\n \n   length = tree_size (node);\n-  t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n+  t = ggc_alloc_zone_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n   memcpy (t, node, length);\n \n   TREE_CHAIN (t) = 0;\n@@ -1385,7 +1381,7 @@ build_fixed (tree type, FIXED_VALUE_TYPE f)\n   FIXED_VALUE_TYPE *fp;\n \n   v = make_node (FIXED_CST);\n-  fp = GGC_NEW (FIXED_VALUE_TYPE);\n+  fp = ggc_alloc_fixed_value ();\n   memcpy (fp, &f, sizeof (FIXED_VALUE_TYPE));\n \n   TREE_TYPE (v) = type;\n@@ -1406,7 +1402,7 @@ build_real (tree type, REAL_VALUE_TYPE d)\n      Consider doing it via real_convert now.  */\n \n   v = make_node (REAL_CST);\n-  dp = GGC_NEW (REAL_VALUE_TYPE);\n+  dp = ggc_alloc_real_value ();\n   memcpy (dp, &d, sizeof (REAL_VALUE_TYPE));\n \n   TREE_TYPE (v) = type;\n@@ -1466,7 +1462,7 @@ build_string (int len, const char *str)\n   tree_node_sizes[(int) c_kind] += length;\n #endif\n \n-  s = ggc_alloc_tree (length);\n+  s = ggc_alloc_tree_node (length);\n \n   memset (s, 0, sizeof (struct tree_common));\n   TREE_SET_CODE (s, STRING_CST);\n@@ -1555,7 +1551,7 @@ make_tree_binfo_stat (unsigned base_binfos MEM_STAT_DECL)\n   tree_node_sizes[(int) binfo_kind] += length;\n #endif\n \n-  t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n+  t = ggc_alloc_zone_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n \n   memset (t, 0, offsetof (struct tree_binfo, base_binfos));\n \n@@ -1580,9 +1576,7 @@ make_tree_vec_stat (int len MEM_STAT_DECL)\n   tree_node_sizes[(int) vec_kind] += length;\n #endif\n \n-  t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n-\n-  memset (t, 0, length);\n+  t = ggc_alloc_zone_cleared_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n \n   TREE_SET_CODE (t, TREE_VEC);\n   TREE_VEC_LENGTH (t) = len;\n@@ -2093,13 +2087,13 @@ build_tree_list_vec_stat (const VEC(tree,gc) *vec MEM_STAT_DECL)\n    purpose and value fields are PURPOSE and VALUE\n    and whose TREE_CHAIN is CHAIN.  */\n \n-tree\n+tree \n tree_cons_stat (tree purpose, tree value, tree chain MEM_STAT_DECL)\n {\n   tree node;\n \n-  node = (tree) ggc_alloc_zone_pass_stat (sizeof (struct tree_list), &tree_zone);\n-\n+  node = ggc_alloc_zone_tree_node_stat (&tree_zone, sizeof (struct tree_list)\n+                                        PASS_MEM_STAT);\n   memset (node, 0, sizeof (struct tree_common));\n \n #ifdef GATHER_STATISTICS\n@@ -3578,7 +3572,7 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n \n   gcc_assert (TREE_CODE_LENGTH (code) == 1);\n \n-  t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n+  t = ggc_alloc_zone_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n \n   memset (t, 0, sizeof (struct tree_common));\n \n@@ -5638,7 +5632,7 @@ decl_priority_info (tree decl)\n   h = (struct tree_priority_map *) *loc;\n   if (!h)\n     {\n-      h = GGC_CNEW (struct tree_priority_map);\n+      h = ggc_alloc_cleared_tree_priority_map ();\n       *loc = h;\n       h->base.from = decl;\n       h->init = DEFAULT_INIT_PRIORITY;\n@@ -5717,7 +5711,7 @@ decl_debug_expr_insert (tree from, tree to)\n   struct tree_decl_map *h;\n   void **loc;\n \n-  h = GGC_NEW (struct tree_decl_map);\n+  h = ggc_alloc_tree_decl_map ();\n   h->base.from = from;\n   h->to = to;\n   loc = htab_find_slot_with_hash (debug_expr_for_decl, h, DECL_UID (from),\n@@ -5748,7 +5742,7 @@ decl_value_expr_insert (tree from, tree to)\n   struct tree_decl_map *h;\n   void **loc;\n \n-  h = GGC_NEW (struct tree_decl_map);\n+  h = ggc_alloc_tree_decl_map ();\n   h->base.from = from;\n   h->to = to;\n   loc = htab_find_slot_with_hash (value_expr_for_decl, h, DECL_UID (from),\n@@ -5921,7 +5915,7 @@ type_hash_add (hashval_t hashcode, tree type)\n   struct type_hash *h;\n   void **loc;\n \n-  h = GGC_NEW (struct type_hash);\n+  h = ggc_alloc_type_hash ();\n   h->hash = hashcode;\n   h->type = type;\n   loc = htab_find_slot_with_hash (type_hash_table, h, hashcode, INSERT);\n@@ -9422,7 +9416,7 @@ build_omp_clause (location_t loc, enum omp_clause_code code)\n   length = omp_clause_num_ops[code];\n   size = (sizeof (struct tree_omp_clause) + (length - 1) * sizeof (tree));\n \n-  t = GGC_NEWVAR (union tree_node, size);\n+  t = ggc_alloc_tree_node (size);\n   memset (t, 0, size);\n   TREE_SET_CODE (t, OMP_CLAUSE);\n   OMP_CLAUSE_SET_CODE (t, code);\n@@ -9455,9 +9449,7 @@ build_vl_exp_stat (enum tree_code code, int len MEM_STAT_DECL)\n   tree_node_sizes[(int) e_kind] += length;\n #endif\n \n-  t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n-\n-  memset (t, 0, length);\n+  t = ggc_alloc_zone_cleared_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n \n   TREE_SET_CODE (t, code);\n "}, {"sha": "683eaea4da917f5fdd0fa3a7b9054d473ad4528c", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -3458,7 +3458,7 @@ extern tree build_target_option_node (void);\n    for various types of node.  */\n \n union GTY ((ptr_alias (union lang_tree_node),\n-\t\t      desc (\"tree_node_structure (&%h)\"))) tree_node {\n+\t    desc (\"tree_node_structure (&%h)\"), variable_size)) tree_node {\n   struct tree_base GTY ((tag (\"TS_BASE\"))) base;\n   struct tree_common GTY ((tag (\"TS_COMMON\"))) common;\n   struct tree_int_cst GTY ((tag (\"TS_INT_CST\"))) int_cst;"}, {"sha": "e02126b07d7c158a3ffaa9dd7f869806f8a5804f", "filename": "gcc/varasm.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -378,7 +378,7 @@ emutls_decl (tree decl)\n \t\t       VAR_DECL, get_emutls_object_name (name),\n \t\t       get_emutls_object_type ());\n \n-      h = GGC_NEW (struct tree_map);\n+      h = ggc_alloc_tree_map ();\n       h->hash = in.hash;\n       h->base.from = decl;\n       h->to = to;\n@@ -553,7 +553,7 @@ get_unnamed_section (unsigned int flags, void (*callback) (const void *),\n {\n   section *sect;\n \n-  sect = GGC_NEW (section);\n+  sect = ggc_alloc_section ();\n   sect->unnamed.common.flags = flags | SECTION_UNNAMED;\n   sect->unnamed.callback = callback;\n   sect->unnamed.data = data;\n@@ -570,7 +570,7 @@ get_noswitch_section (unsigned int flags, noswitch_section_callback callback)\n {\n   section *sect;\n \n-  sect = GGC_NEW (section);\n+  sect = ggc_alloc_section ();\n   sect->noswitch.common.flags = flags | SECTION_NOSWITCH;\n   sect->noswitch.callback = callback;\n \n@@ -591,7 +591,7 @@ get_section (const char *name, unsigned int flags, tree decl)\n   flags |= SECTION_NAMED;\n   if (*slot == NULL)\n     {\n-      sect = GGC_NEW (section);\n+      sect = ggc_alloc_section ();\n       sect->named.common.flags = flags;\n       sect->named.name = ggc_strdup (name);\n       sect->named.decl = decl;\n@@ -640,8 +640,7 @@ get_block_for_section (section *sect)\n   block = (struct object_block *) *slot;\n   if (block == NULL)\n     {\n-      block = (struct object_block *)\n-\tggc_alloc_cleared (sizeof (struct object_block));\n+      block = ggc_alloc_cleared_object_block ();\n       block->sect = sect;\n       *slot = block;\n     }\n@@ -661,7 +660,7 @@ create_block_symbol (const char *label, struct object_block *block,\n \n   /* Create the extended SYMBOL_REF.  */\n   size = RTX_HDR_SIZE + sizeof (struct block_symbol);\n-  symbol = (rtx) ggc_alloc_zone (size, &rtl_zone);\n+  symbol = ggc_alloc_zone_rtx_def (size, &rtl_zone);\n \n   /* Initialize the normal SYMBOL_REF fields.  */\n   memset (symbol, 0, size);\n@@ -3324,7 +3323,7 @@ build_constant_desc (tree exp)\n   int labelno;\n   tree decl;\n \n-  desc = GGC_NEW (struct constant_descriptor_tree);\n+  desc = ggc_alloc_constant_descriptor_tree ();\n   desc->value = copy_constant (exp);\n \n   /* Propagate marked-ness to copied constant.  */\n@@ -3724,7 +3723,7 @@ create_constant_pool (void)\n {\n   struct rtx_constant_pool *pool;\n \n-  pool = GGC_NEW (struct rtx_constant_pool);\n+  pool = ggc_alloc_rtx_constant_pool ();\n   pool->const_rtx_htab = htab_create_ggc (31, const_desc_rtx_hash,\n \t\t\t\t\t  const_desc_rtx_eq, NULL);\n   pool->first = NULL;\n@@ -3790,7 +3789,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n     return copy_rtx (desc->mem);\n \n   /* Otherwise, create a new descriptor.  */\n-  desc = GGC_NEW (struct constant_descriptor_rtx);\n+  desc = ggc_alloc_constant_descriptor_rtx ();\n   *slot = desc;\n \n   /* Align the location counter as required by EXP's data type.  */"}, {"sha": "94c949e35508eb9cc4e287cbaadbe6b1c6b61042", "filename": "gcc/varpool.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -139,7 +139,7 @@ varpool_node (tree decl)\n     htab_find_slot (varpool_hash, &key, INSERT);\n   if (*slot)\n     return *slot;\n-  node = GGC_CNEW (struct varpool_node);\n+  node = ggc_alloc_cleared_varpool_node ();\n   node->decl = decl;\n   node->order = cgraph_order++;\n   node->next = varpool_nodes;\n@@ -651,7 +651,7 @@ varpool_extra_name_alias (tree alias, tree decl)\n   if (*slot)\n     return false;\n \n-  alias_node = GGC_CNEW (struct varpool_node);\n+  alias_node = ggc_alloc_cleared_varpool_node ();\n   alias_node->decl = alias;\n   alias_node->alias = 1;\n   alias_node->extra_name = decl_node;"}, {"sha": "0c6f91c9599c5a9350a4b0d4d166a70cc45ab51f", "filename": "include/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,12 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* splay-tree.h: Update copyright years.\n+\t(splay_tree_s): Document fields.\n+\t(splay_tree_new_typed_alloc): New.\n+\n+\t* hashtab.h: Update copyright years.\n+\t(htab_create_typed_alloc): New.\n+\n 2010-06-01  Rafael Espindola  <espindola@google.com>\n \n \t* plugin-api.h (ld_plugin_tag): Add LDPT_OUTPUT_NAME."}, {"sha": "4bb65d6c7a2b4135b8526ca5ec4255987934ed6d", "filename": "include/hashtab.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/include%2Fhashtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/include%2Fhashtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fhashtab.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,5 +1,5 @@\n /* An expandable hash tables datatype.  \n-   Copyright (C) 1999, 2000, 2002, 2003, 2004, 2005, 2009\n+   Copyright (C) 1999, 2000, 2002, 2003, 2004, 2005, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Vladimir Makarov (vmakarov@cygnus.com).\n \n@@ -157,6 +157,9 @@ extern htab_t\thtab_create_alloc_ex (size_t, htab_hash,\n                                       void *, htab_alloc_with_arg,\n                                       htab_free_with_arg);\n \n+extern htab_t  htab_create_typed_alloc (size_t, htab_hash, htab_eq, htab_del,\n+\t\t\t\t\thtab_alloc, htab_alloc, htab_free);\n+\n /* Backward-compatibility functions.  */\n extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);\n extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);"}, {"sha": "480b2c43e7d4d654e971ce77a6ac67dc860ebfcc", "filename": "include/splay-tree.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/include%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/include%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fsplay-tree.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,5 +1,5 @@\n /* A splay-tree datatype.  \n-   Copyright 1998, 1999, 2000, 2002, 2005, 2007, 2009\n+   Copyright 1998, 1999, 2000, 2002, 2005, 2007, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Mark Mitchell (mark@markmitchell.com).\n \n@@ -119,9 +119,13 @@ struct GTY(()) splay_tree_s {\n   /* The deallocate-value function.  NULL if no cleanup is necessary.  */\n   splay_tree_delete_value_fn delete_value;\n \n-  /* Allocate/free functions, and a data pointer to pass to them.  */\n+  /* Node allocate function.  Takes allocate_data as a parameter. */\n   splay_tree_allocate_fn allocate;\n+\n+  /* Free function for nodes and trees.  Takes allocate_data as a parameter.  */\n   splay_tree_deallocate_fn deallocate;\n+\n+  /* Parameter for allocate/free functions.  */\n   void * GTY((skip)) allocate_data;\n };\n \n@@ -136,6 +140,13 @@ extern splay_tree splay_tree_new_with_allocator (splay_tree_compare_fn,\n \t\t\t\t\t\t splay_tree_allocate_fn,\n \t\t\t\t\t\t splay_tree_deallocate_fn,\n \t\t\t\t\t\t void *);\n+extern splay_tree splay_tree_new_typed_alloc (splay_tree_compare_fn,\n+\t\t\t\t\t      splay_tree_delete_key_fn,\n+\t\t\t\t\t      splay_tree_delete_value_fn,\n+\t\t\t\t\t      splay_tree_allocate_fn,\n+\t\t\t\t\t      splay_tree_allocate_fn,\n+\t\t\t\t\t      splay_tree_deallocate_fn,\n+\t\t\t\t\t      void *);\n extern void splay_tree_delete (splay_tree);\n extern splay_tree_node splay_tree_insert (splay_tree,\n \t\t\t\t\t  splay_tree_key,"}, {"sha": "84201a4a5108f1b5605efc97ae6f1e00aab8b86c", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,7 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* include/symtab.h (ht_identifier_ptr): New.\n+\n 2010-06-03  Joern Rennecke <joern.rennecke@embecosm.com>\n \t    Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n "}, {"sha": "b0a2f2697aa0738943eae1ccbd090181fbec6093", "filename": "libcpp/include/symtab.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libcpp%2Finclude%2Fsymtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libcpp%2Finclude%2Fsymtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fsymtab.h?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -28,6 +28,7 @@ along with this program; see the file COPYING3.  If not see\n /* This is what each hash table entry points to.  It may be embedded\n    deeply within another object.  */\n typedef struct ht_identifier ht_identifier;\n+typedef struct ht_identifier *ht_identifier_ptr;\n struct GTY(()) ht_identifier {\n   const unsigned char *str;\n   unsigned int len;"}, {"sha": "3b9fdc9871f56a5f1b2437974c4df93b6038e780", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,3 +1,15 @@\n+2010-06-08  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* splay-tree.c: Update copyright years.\n+\t(splay_tree_new_typed_alloc): New.\n+\t(splay_tree_new_with_allocator): Use it.\n+\n+\t* hashtab.c: Update copyright years.\n+\t(htab_create_typed_alloc): New.\n+\t(htab_create_alloc): Use it.\n+\n+\t* functions.texi: Regenerate.\n+\n 2010-06-03  Joern Rennecke <joern.rennecke@embecosm.com>\n \t    Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n "}, {"sha": "d9fef8cb7b348efe2c8d065747a823beb3ad6475", "filename": "libiberty/functions.texi", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libiberty%2Ffunctions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libiberty%2Ffunctions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffunctions.texi?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -3,7 +3,7 @@\n @c Edit the *.c files, configure with --enable-maintainer-mode,\n @c run 'make stamp-functions' and gather-docs will build a new copy.\n \n-@c safe-ctype.c:25\n+@c splay-tree.c:277\n @defvr Extension HOST_CHARSET\n This macro indicates the basic character set and encoding used by the\n host: more precisely, the encoding used for character constants in\n@@ -24,6 +24,25 @@ The host character set is some variant of EBCDIC.  (Only one of the\n nineteen EBCDIC varying characters is tested; exercise caution.)\n @end ftable\n @end defvr\n+@deftypefn Supplemental splay_tree splay_tree_new_with_typed_alloc\n+(splay_tree_compare_fn @var{compare_fn},\n+splay_tree_delete_key_fn @var{delete_key_fn},\n+splay_tree_delete_value_fn @var{delete_value_fn},\n+splay_tree_allocate_fn @var{tree_allocate_fn},\n+splay_tree_allocate_fn @var{node_allocate_fn},\n+splay_tree_deallocate_fn @var{deallocate_fn},\n+void * @var{allocate_data})\n+\n+This function creates a splay tree that uses two different allocators\n+@var{tree_allocate_fn} and @var{node_allocate_fn} to use for allocating the\n+tree itself and its nodes respectively.  This is useful when variables of\n+different types need to be allocated with different allocators.\n+\n+The splay tree will use @var{compare_fn} to compare nodes,\n+@var{delete_key_fn} to deallocate keys, and @var{delete_value_fn} to\n+deallocate values.\n+\n+@end deftypefn\n \n @c alloca.c:26\n @deftypefn Replacement void* alloca (size_t @var{size})\n@@ -477,6 +496,24 @@ systems.\n \n @end deftypefn\n \n+@c hashtab.c:336\n+@deftypefn Supplemental htab_t htab_create_typed_alloc (size_t @var{size},\n+htab_hash @var{hash_f}, htab_eq @var{eq_f}, htab_del @var{del_f},\n+htab_alloc @var{alloc_tab_f}, htab_alloc @var{alloc_f},\n+htab_free @var{free_f})\n+\n+This function creates a hash table that uses two different allocators\n+@var{alloc_tab_f} and @var{alloc_f} to use for allocating the table itself\n+and its entries respectively.  This is useful when variables of different\n+types need to be allocated with different allocators.\n+\n+The created hash table is slightly larger than @var{size} and it is\n+initially empty (all the hash table entries are @code{HTAB_EMPTY_ENTRY}).\n+The function returns the created hash table, or @code{NULL} if memory\n+allocation fails.\n+\n+@end deftypefn\n+\n @c index.c:5\n @deftypefn Supplemental char* index (char *@var{s}, int @var{c})\n "}, {"sha": "359e3ea569ec084fb58fda182cb0a3526ad20420", "filename": "libiberty/hashtab.c", "status": "modified", "additions": 49, "deletions": 18, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libiberty%2Fhashtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libiberty%2Fhashtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhashtab.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,5 +1,5 @@\n /* An expandable hash tables datatype.  \n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2009\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Vladimir Makarov (vmakarov@cygnus.com).\n \n@@ -290,69 +290,100 @@ htab_mod_m2 (hashval_t hash, htab_t htab)\n htab_t\n htab_create_alloc (size_t size, htab_hash hash_f, htab_eq eq_f,\n                    htab_del del_f, htab_alloc alloc_f, htab_free free_f)\n+{\n+  return htab_create_typed_alloc (size, hash_f, eq_f, del_f, alloc_f, alloc_f,\n+\t\t\t\t  free_f);\n+}\n+\n+/* As above, but uses the variants of ALLOC_F and FREE_F which accept\n+   an extra argument.  */\n+\n+htab_t\n+htab_create_alloc_ex (size_t size, htab_hash hash_f, htab_eq eq_f,\n+\t\t      htab_del del_f, void *alloc_arg,\n+\t\t      htab_alloc_with_arg alloc_f,\n+\t\t      htab_free_with_arg free_f)\n {\n   htab_t result;\n   unsigned int size_prime_index;\n \n   size_prime_index = higher_prime_index (size);\n   size = prime_tab[size_prime_index].prime;\n \n-  result = (htab_t) (*alloc_f) (1, sizeof (struct htab));\n+  result = (htab_t) (*alloc_f) (alloc_arg, 1, sizeof (struct htab));\n   if (result == NULL)\n     return NULL;\n-  result->entries = (PTR *) (*alloc_f) (size, sizeof (PTR));\n+  result->entries = (PTR *) (*alloc_f) (alloc_arg, size, sizeof (PTR));\n   if (result->entries == NULL)\n     {\n       if (free_f != NULL)\n-\t(*free_f) (result);\n+\t(*free_f) (alloc_arg, result);\n       return NULL;\n     }\n   result->size = size;\n   result->size_prime_index = size_prime_index;\n   result->hash_f = hash_f;\n   result->eq_f = eq_f;\n   result->del_f = del_f;\n-  result->alloc_f = alloc_f;\n-  result->free_f = free_f;\n+  result->alloc_arg = alloc_arg;\n+  result->alloc_with_arg_f = alloc_f;\n+  result->free_with_arg_f = free_f;\n   return result;\n }\n \n-/* As above, but use the variants of alloc_f and free_f which accept\n-   an extra argument.  */\n+/*\n+\n+@deftypefn Supplemental htab_t htab_create_typed_alloc (size_t @var{size},\n+htab_hash @var{hash_f}, htab_eq @var{eq_f}, htab_del @var{del_f},\n+htab_alloc @var{alloc_tab_f}, htab_alloc @var{alloc_f},\n+htab_free @var{free_f})\n+\n+This function creates a hash table that uses two different allocators\n+@var{alloc_tab_f} and @var{alloc_f} to use for allocating the table itself\n+and its entries respectively.  This is useful when variables of different\n+types need to be allocated with different allocators.\n+\n+The created hash table is slightly larger than @var{size} and it is\n+initially empty (all the hash table entries are @code{HTAB_EMPTY_ENTRY}).\n+The function returns the created hash table, or @code{NULL} if memory\n+allocation fails.\n+\n+@end deftypefn\n+\n+*/\n \n htab_t\n-htab_create_alloc_ex (size_t size, htab_hash hash_f, htab_eq eq_f,\n-                      htab_del del_f, void *alloc_arg,\n-                      htab_alloc_with_arg alloc_f,\n-\t\t      htab_free_with_arg free_f)\n+htab_create_typed_alloc (size_t size, htab_hash hash_f, htab_eq eq_f,\n+\t\t\t htab_del del_f, htab_alloc alloc_tab_f,\n+\t\t\t htab_alloc alloc_f, htab_free free_f)\n {\n   htab_t result;\n   unsigned int size_prime_index;\n \n   size_prime_index = higher_prime_index (size);\n   size = prime_tab[size_prime_index].prime;\n \n-  result = (htab_t) (*alloc_f) (alloc_arg, 1, sizeof (struct htab));\n+  result = (htab_t) (*alloc_tab_f) (1, sizeof (struct htab));\n   if (result == NULL)\n     return NULL;\n-  result->entries = (PTR *) (*alloc_f) (alloc_arg, size, sizeof (PTR));\n+  result->entries = (PTR *) (*alloc_f) (size, sizeof (PTR));\n   if (result->entries == NULL)\n     {\n       if (free_f != NULL)\n-\t(*free_f) (alloc_arg, result);\n+\t(*free_f) (result);\n       return NULL;\n     }\n   result->size = size;\n   result->size_prime_index = size_prime_index;\n   result->hash_f = hash_f;\n   result->eq_f = eq_f;\n   result->del_f = del_f;\n-  result->alloc_arg = alloc_arg;\n-  result->alloc_with_arg_f = alloc_f;\n-  result->free_with_arg_f = free_f;\n+  result->alloc_f = alloc_f;\n+  result->free_f = free_f;\n   return result;\n }\n \n+\n /* Update the function pointers and allocation parameter in the htab_t.  */\n \n void"}, {"sha": "bf1a0f3f151f36d641510c86de9c592b9b055686", "filename": "libiberty/splay-tree.c", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libiberty%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9429e29f506f5b8c28b28ab387fc2d261a4220c/libiberty%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsplay-tree.c?ref=a9429e29f506f5b8c28b28ab387fc2d261a4220c", "patch": "@@ -1,5 +1,6 @@\n /* A splay-tree datatype.  \n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2009,\n+   2010 Free Software Foundation, Inc.\n    Contributed by Mark Mitchell (mark@markmitchell.com).\n \n This file is part of GNU CC.\n@@ -265,13 +266,53 @@ splay_tree_new_with_allocator (splay_tree_compare_fn compare_fn,\n                                splay_tree_deallocate_fn deallocate_fn,\n                                void *allocate_data)\n {\n-  splay_tree sp = (splay_tree) (*allocate_fn) (sizeof (struct splay_tree_s),\n-                                               allocate_data);\n+  return\n+    splay_tree_new_typed_alloc (compare_fn, delete_key_fn, delete_value_fn,\n+\t\t\t\tallocate_fn, allocate_fn, deallocate_fn,\n+\t\t\t\tallocate_data);\n+}\n+\n+/*\n+\n+@deftypefn Supplemental splay_tree splay_tree_new_with_typed_alloc\n+(splay_tree_compare_fn @var{compare_fn},\n+splay_tree_delete_key_fn @var{delete_key_fn},\n+splay_tree_delete_value_fn @var{delete_value_fn},\n+splay_tree_allocate_fn @var{tree_allocate_fn},\n+splay_tree_allocate_fn @var{node_allocate_fn},\n+splay_tree_deallocate_fn @var{deallocate_fn},\n+void * @var{allocate_data})\n+\n+This function creates a splay tree that uses two different allocators\n+@var{tree_allocate_fn} and @var{node_allocate_fn} to use for allocating the\n+tree itself and its nodes respectively.  This is useful when variables of\n+different types need to be allocated with different allocators.\n+\n+The splay tree will use @var{compare_fn} to compare nodes,\n+@var{delete_key_fn} to deallocate keys, and @var{delete_value_fn} to\n+deallocate values.\n+\n+@end deftypefn\n+\n+*/\n+\n+splay_tree\n+splay_tree_new_typed_alloc (splay_tree_compare_fn compare_fn,\n+\t\t\t    splay_tree_delete_key_fn delete_key_fn,\n+\t\t\t    splay_tree_delete_value_fn delete_value_fn,\n+\t\t\t    splay_tree_allocate_fn tree_allocate_fn,\n+\t\t\t    splay_tree_allocate_fn node_allocate_fn,\n+\t\t\t    splay_tree_deallocate_fn deallocate_fn,\n+\t\t\t    void * allocate_data)\n+{\n+  splay_tree sp = (splay_tree) (*tree_allocate_fn)\n+    (sizeof (struct splay_tree_s), allocate_data);\n+\n   sp->root = 0;\n   sp->comp = compare_fn;\n   sp->delete_key = delete_key_fn;\n   sp->delete_value = delete_value_fn;\n-  sp->allocate = allocate_fn;\n+  sp->allocate = node_allocate_fn;\n   sp->deallocate = deallocate_fn;\n   sp->allocate_data = allocate_data;\n \n@@ -313,10 +354,10 @@ splay_tree_insert (splay_tree sp, splay_tree_key key, splay_tree_value value)\n     {\n       /* Create a new node, and insert it at the root.  */\n       splay_tree_node node;\n-      \n+\n       node = ((splay_tree_node)\n-              (*sp->allocate) (sizeof (struct splay_tree_node_s),\n-                               sp->allocate_data));\n+\t      (*sp->allocate) (sizeof (struct splay_tree_node_s),\n+\t\t\t       sp->allocate_data));\n       node->key = key;\n       node->value = value;\n       "}]}