{"sha": "ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI4N2FjOGQ1M2YzZDkwM2JmYzllZWIwZjBiNWU3ZWVkMWYzOGNiYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-05-08T17:06:46Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-05-08T17:06:46Z"}, "message": "re PR c++/59813 (tail-call elimination didn't fire for left-shift of char to cout)\n\n\tPR c++/59813\n\tPR tree-optimization/89060\n\t* tree-ssa-live.h (live_vars_map): New typedef.\n\t(compute_live_vars, live_vars_at_stmt, destroy_live_vars): Declare.\n\t* tree-ssa-live.c: Include gimple-walk.h and cfganal.h.\n\t(struct compute_live_vars_data): New type.\n\t(compute_live_vars_visit, compute_live_vars_1, compute_live_vars,\n\tlive_vars_at_stmt, destroy_live_vars): New functions.\n\t* tree-tailcall.c: Include tree-ssa-live.h.\n\t(live_vars, live_vars_vec): New global variables.\n\t(find_tail_calls): Perform variable life analysis before punting.\n\t(tree_optimize_tail_calls_1): Clean up live_vars and live_vars_vec.\n\t* tree-inline.h (struct copy_body_data): Add eh_landing_pad_dest\n\tmember.\n\t* tree-inline.c (add_clobbers_to_eh_landing_pad): Remove BB argument.\n\tPerform variable life analysis to select variables that really need\n\tclobbers added.\n\t(copy_edges_for_bb): Don't call add_clobbers_to_eh_landing_pad here,\n\tinstead set id->eh_landing_pad_dest and assert it is the same.\n\t(copy_cfg_body): Call it here if id->eh_landing_pad_dest is non-NULL.\n\n\t* gcc.dg/tree-ssa/pr89060.c: New test.\n\nFrom-SVN: r271013", "tree": {"sha": "82cfaff6222e92d237be7a60aa9a5c1f2f835b38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82cfaff6222e92d237be7a60aa9a5c1f2f835b38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "69708e0afbf3a3757b9f689bb54acff1d7e8d9ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec"}], "stats": {"total": 346, "additions": 341, "deletions": 5}, "files": [{"sha": "1fe31a7d40ec428639910bbf53544b0d279b595f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "patch": "@@ -1,3 +1,26 @@\n+2019-05-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/59813\n+\tPR tree-optimization/89060\n+\t* tree-ssa-live.h (live_vars_map): New typedef.\n+\t(compute_live_vars, live_vars_at_stmt, destroy_live_vars): Declare.\n+\t* tree-ssa-live.c: Include gimple-walk.h and cfganal.h.\n+\t(struct compute_live_vars_data): New type.\n+\t(compute_live_vars_visit, compute_live_vars_1, compute_live_vars,\n+\tlive_vars_at_stmt, destroy_live_vars): New functions.\n+\t* tree-tailcall.c: Include tree-ssa-live.h.\n+\t(live_vars, live_vars_vec): New global variables.\n+\t(find_tail_calls): Perform variable life analysis before punting.\n+\t(tree_optimize_tail_calls_1): Clean up live_vars and live_vars_vec.\n+\t* tree-inline.h (struct copy_body_data): Add eh_landing_pad_dest\n+\tmember.\n+\t* tree-inline.c (add_clobbers_to_eh_landing_pad): Remove BB argument.\n+\tPerform variable life analysis to select variables that really need\n+\tclobbers added.\n+\t(copy_edges_for_bb): Don't call add_clobbers_to_eh_landing_pad here,\n+\tinstead set id->eh_landing_pad_dest and assert it is the same.\n+\t(copy_cfg_body): Call it here if id->eh_landing_pad_dest is non-NULL.\n+\n 2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>\n \t    Richard Earnshaw  <rearnsha@arm.com>\n "}, {"sha": "797a370ef95690c4b3836bea7cb660d0edfad7a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "patch": "@@ -1,3 +1,9 @@\n+2019-05-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/59813\n+\tPR tree-optimization/89060\n+\t* gcc.dg/tree-ssa/pr89060.c: New test.\n+\n 2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>\n \t    Richard Earnshaw  <rearnsha@arm.com>\n "}, {"sha": "baa3a3021256146dc98ff672d647ff7f0ecf161a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr89060.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89060.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89060.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr89060.c?ref=ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "patch": "@@ -0,0 +1,53 @@\n+/* PR tree-optimization/89060 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-tailc\" } */\n+/* { dg-final { scan-tree-dump-not \"baz \\\\\\(1\\\\\\); \\\\\\[tail call\\\\\\]\" \"tailc\" } } */\n+/* { dg-final { scan-tree-dump \"baz \\\\\\(2\\\\\\); \\\\\\[tail call\\\\\\]\" \"tailc\" } } */\n+/* { dg-final { scan-tree-dump \"baz \\\\\\(3\\\\\\); \\\\\\[tail call\\\\\\]\" \"tailc\" } } */\n+/* { dg-final { scan-tree-dump \"baz \\\\\\(4\\\\\\); \\\\\\[tail call\\\\\\]\" \"tailc\" } } */\n+/* { dg-final { scan-tree-dump-not \"baz \\\\\\(5\\\\\\); \\\\\\[tail call\\\\\\]\" \"tailc\" } } */\n+\n+void qux (char *, int n);\n+int baz (int);\n+\n+int\n+foo (int n)\n+{\n+  char buf[64];\n+  qux (buf, n);\n+  return baz (1);\n+}\n+\n+int\n+bar (int n)\n+{\n+  {\n+    char buf[64];\n+    qux (buf, n);\n+  }\n+  return baz (2);\n+}\n+\n+int\n+quux (int n)\n+{\n+  if (n < 10)\n+    {\n+      {\n+        char buf[64];\n+        qux (buf, n);\n+      }\n+      return baz (3);\n+    }\n+  if (n > 20)\n+    {\n+      {\n+        char buf2[64];\n+\tqux (buf2, n + 1);\n+      }\n+      return baz (4);\n+    }\n+  char buf3[64];\n+  qux (buf3, n + 2);\n+  return baz (5);\n+}"}, {"sha": "2d314a7c0c357d8c04f478ac67b9db8ab6314b2d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "patch": "@@ -61,6 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"sreal.h\"\n #include \"tree-cfgcleanup.h\"\n+#include \"tree-ssa-live.h\"\n \n /* I'm not real happy about this, but we need to handle gimple and\n    non-gimple trees.  */\n@@ -2285,12 +2286,15 @@ update_ssa_across_abnormal_edges (basic_block bb, basic_block ret_bb,\n }\n \n /* Insert clobbers for automatic variables of inlined ID->src_fn\n-   function at the start of basic block BB.  */\n+   function at the start of basic block ID->eh_landing_pad_dest.  */\n \n static void\n-add_clobbers_to_eh_landing_pad (basic_block bb, copy_body_data *id)\n+add_clobbers_to_eh_landing_pad (copy_body_data *id)\n {\n   tree var;\n+  basic_block bb = id->eh_landing_pad_dest;\n+  live_vars_map *vars = NULL;\n+  unsigned int cnt = 0;\n   unsigned int i;\n   FOR_EACH_VEC_SAFE_ELT (id->src_cfun->local_decls, i, var)\n     if (VAR_P (var)\n@@ -2312,12 +2316,47 @@ add_clobbers_to_eh_landing_pad (basic_block bb, copy_body_data *id)\n \t    && !is_gimple_reg (new_var)\n \t    && auto_var_in_fn_p (new_var, id->dst_fn))\n \t  {\n+\t    if (vars == NULL)\n+\t      vars = new live_vars_map;\n+            vars->put (DECL_UID (var), cnt++);\n+\t  }\n+      }\n+  if (vars == NULL)\n+    return;\n+\n+  vec<bitmap_head> live = compute_live_vars (id->src_cfun, vars);\n+  FOR_EACH_VEC_SAFE_ELT (id->src_cfun->local_decls, i, var)\n+    if (VAR_P (var))\n+      {\n+\tedge e;\n+\tedge_iterator ei;\n+\tbool needed = false;\n+\tunsigned int *v = vars->get (DECL_UID (var));\n+\tif (v == NULL)\n+\t  continue;\n+\tFOR_EACH_EDGE (e, ei, bb->preds)\n+\t  if ((e->flags & EDGE_EH) != 0\n+\t      && e->src->index >= id->add_clobbers_to_eh_landing_pads)\n+\t    {\n+\t      basic_block src_bb = (basic_block) e->src->aux;\n+\n+\t      if (bitmap_bit_p (&live[src_bb->index], *v))\n+\t\t{\n+\t\t  needed = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\tif (needed)\n+\t  {\n+\t    tree new_var = *id->decl_map->get (var);\n \t    gimple_stmt_iterator gsi = gsi_after_labels (bb);\n \t    tree clobber = build_clobber (TREE_TYPE (new_var));\n \t    gimple *clobber_stmt = gimple_build_assign (new_var, clobber);\n \t    gsi_insert_before (&gsi, clobber_stmt, GSI_NEW_STMT);\n \t  }\n       }\n+  destroy_live_vars (live);\n+  delete vars;\n }\n \n /* Copy edges from BB into its copy constructed earlier, scale profile\n@@ -2452,8 +2491,10 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n \t\t  e->probability = profile_probability::never ();\n \t\tif (e->dest->index < id->add_clobbers_to_eh_landing_pads)\n \t\t  {\n-\t\t    add_clobbers_to_eh_landing_pad (e->dest, id);\n-\t\t    id->add_clobbers_to_eh_landing_pads = 0;\n+\t\t    if (id->eh_landing_pad_dest == NULL)\n+\t\t      id->eh_landing_pad_dest = e->dest;\n+\t\t    else\n+\t\t      gcc_assert (id->eh_landing_pad_dest == e->dest);\n \t\t  }\n \t      }\n         }\n@@ -2893,6 +2934,12 @@ copy_cfg_body (copy_body_data * id,\n       need_debug_cleanup |= copy_edges_for_bb (bb, num, den, exit_block_map,\n \t\t\t\t\t       abnormal_goto_dest, id);\n \n+  if (id->eh_landing_pad_dest)\n+    {\n+      add_clobbers_to_eh_landing_pad (id);\n+      id->eh_landing_pad_dest = NULL;\n+    }\n+\n   if (new_entry)\n     {\n       edge e = make_edge (entry_block_map, (basic_block)new_entry->aux,"}, {"sha": "4c954a0d46f01915d7258409af0c7d530b2167c9", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "patch": "@@ -160,6 +160,10 @@ struct copy_body_data\n      when inlining a call within an OpenMP SIMD-on-SIMT loop.  */\n   vec<tree> *dst_simt_vars;\n \n+  /* Basic block to which clobbers for local variables from the inline\n+     function that need to live in memory should be added.  */\n+  basic_block eh_landing_pad_dest;\n+\n   /* If clobbers for local variables from the inline function\n      that need to live in memory should be added to EH landing pads\n      outside of the inlined function, this should be the number"}, {"sha": "e9ae8e0cf754e4dc63c2800b1c57044437b62dd2", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "patch": "@@ -41,6 +41,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"optinfo.h\"\n+#include \"gimple-walk.h\"\n+#include \"cfganal.h\"\n \n static void verify_live_on_entry (tree_live_info_p);\n \n@@ -1194,8 +1196,149 @@ calculate_live_ranges (var_map map, bool want_livein)\n \n   return live;\n }\n+\f\n+/* Data structure for compute_live_vars* functions.  */\n+\n+struct compute_live_vars_data {\n+  /* Vector of bitmaps for live vars indices at the end of basic blocks,\n+     indexed by bb->index.  ACTIVE[ENTRY_BLOCK] must be empty bitmap,\n+     ACTIVE[EXIT_BLOCK] is used for STOP_AFTER.  */\n+  vec<bitmap_head> active;\n+  /* Work bitmap of currently live variables.  */\n+  bitmap work;\n+  /* Set of interesting variables.  Variables with uids not in this\n+     hash_map are not tracked.  */\n+  live_vars_map *vars;\n+};\n+\n+/* Callback for walk_stmt_load_store_addr_ops.  If OP is a VAR_DECL with\n+   uid set in DATA->vars, enter its corresponding index into bitmap\n+   DATA->work.  */\n \n+static bool\n+compute_live_vars_visit (gimple *, tree op, tree, void *pdata)\n+{\n+  compute_live_vars_data *data = (compute_live_vars_data *) pdata;\n+  op = get_base_address (op);\n+  if (op && VAR_P (op))\n+    if (unsigned int *v = data->vars->get (DECL_UID (op)))\n+      bitmap_set_bit (data->work, *v);\n+  return false;\n+}\n+\n+/* Helper routine for compute_live_vars, calculating the sets of live\n+   variables at the end of BB, leaving the result in DATA->work.\n+   If STOP_AFTER is non-NULL, stop processing after that stmt.  */\n+\n+static void\n+compute_live_vars_1 (basic_block bb, compute_live_vars_data *data,\n+\t\t     gimple *stop_after)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  gimple_stmt_iterator gsi;\n+  walk_stmt_load_store_addr_fn visit = compute_live_vars_visit;\n+\n+  bitmap_clear (data->work);\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    bitmap_ior_into (data->work, &data->active[e->src->index]);\n+\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    walk_stmt_load_store_addr_ops (gsi_stmt (gsi), data, NULL, NULL, visit);\n+  for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+\n+      if (gimple_clobber_p (stmt))\n+\t{\n+\t  tree lhs = gimple_assign_lhs (stmt);\n+\t  if (VAR_P (lhs))\n+\t    if (unsigned int *v = data->vars->get (DECL_UID (lhs)))\n+\t      bitmap_clear_bit (data->work, *v);\n+\t}\n+      else if (!is_gimple_debug (stmt))\n+\twalk_stmt_load_store_addr_ops (stmt, data, visit, visit, visit);\n+      if (stmt == stop_after)\n+\tbreak;\n+    }\n+}\n+\n+/* For function FN and live_vars_map (hash map from DECL_UIDs to a dense set of\n+   indexes of automatic variables VARS, compute which of those variables are\n+   (might be) live at the end of each basic block.  */\n+\n+vec<bitmap_head>\n+compute_live_vars (struct function *fn, live_vars_map *vars)\n+{\n+  vec<bitmap_head> active;\n \n+  /* We approximate the live range of a stack variable by taking the first\n+     mention of its name as starting point(s), and by the end-of-scope\n+     death clobber added by gimplify as ending point(s) of the range.\n+     This overapproximates in the case we for instance moved an address-taken\n+     operation upward, without also moving a dereference to it upwards.\n+     But it's conservatively correct as a variable never can hold values\n+     before its name is mentioned at least once.\n+\n+     We then do a mostly classical bitmap liveness algorithm.  */\n+\n+  active.create (last_basic_block_for_fn (fn));\n+  active.quick_grow (last_basic_block_for_fn (fn));\n+  for (int i = 0; i < last_basic_block_for_fn (fn); i++)\n+    bitmap_initialize (&active[i], &bitmap_default_obstack);\n+\n+  bitmap work = BITMAP_ALLOC (NULL);\n+\n+  int *rpo = XNEWVEC (int, last_basic_block_for_fn (fn));\n+  int n_bbs = pre_and_rev_post_order_compute_fn (fn, NULL, rpo, false);\n+\n+  bool changed = true;\n+  compute_live_vars_data data = { active, work, vars };\n+  while (changed)\n+    {\n+      int i;\n+      changed = false;\n+      for (i = 0; i < n_bbs; i++)\n+\t{\n+\t  basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);\n+\t  compute_live_vars_1 (bb, &data, NULL);\n+\t  if (bitmap_ior_into (&active[bb->index], work))\n+\t    changed = true;\n+\t}\n+    }\n+\n+  free (rpo);\n+  BITMAP_FREE (work);\n+\n+  return active;\n+}\n+\n+/* For ACTIVE computed by compute_live_vars, compute a bitmap of variables\n+   live after the STOP_AFTER statement and return that bitmap.  */\n+\n+bitmap\n+live_vars_at_stmt (vec<bitmap_head> &active, live_vars_map *vars,\n+\t\t   gimple *stop_after)\n+{\n+  bitmap work = BITMAP_ALLOC (NULL);\n+  compute_live_vars_data data = { active, work, vars };\n+  basic_block bb = gimple_bb (stop_after);\n+  compute_live_vars_1 (bb, &data, stop_after);\n+  return work;\n+}\n+\n+/* Destroy what compute_live_vars has returned when it is no longer needed.  */\n+\n+void\n+destroy_live_vars (vec<bitmap_head> &active)\n+{\n+  unsigned len = active.length ();\n+  for (unsigned i = 0; i < len; i++)\n+    bitmap_clear (&active[i]);\n+\n+  active.release ();\n+}\n+\f\n /* Output partition map MAP to file F.  */\n \n void"}, {"sha": "78b033b8ee90fbf61e7bf7617fa202c415870895", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "patch": "@@ -266,6 +266,11 @@ extern void debug (tree_live_info_d &ref);\n extern void debug (tree_live_info_d *ptr);\n extern void dump_live_info (FILE *, tree_live_info_p, int);\n \n+typedef hash_map<int_hash <unsigned int, -1U>, unsigned int> live_vars_map;\n+extern vec<bitmap_head> compute_live_vars (struct function *, live_vars_map *);\n+extern bitmap live_vars_at_stmt (vec<bitmap_head> &, live_vars_map *,\n+\t\t\t\t gimple *);\n+extern void destroy_live_vars (vec<bitmap_head> &);\n \n /*  Return TRUE if P is marked as a global in LIVE.  */\n "}, {"sha": "f4835854e00bda09f817e690e2f26d31de069770", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=ab87ac8d53f3d903bfc9eeb0f0b5e7eed1f38cbc", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"common/common-target.h\"\n #include \"ipa-utils.h\"\n+#include \"tree-ssa-live.h\"\n \n /* The file implements the tail recursion elimination.  It is also used to\n    analyze the tail calls in general, passing the results to the rtl level\n@@ -392,6 +393,11 @@ propagate_through_phis (tree var, edge e)\n   return var;\n }\n \n+/* Argument for compute_live_vars/live_vars_at_stmt and what compute_live_vars\n+   returns.  Computed lazily, but just once for the function.  */\n+static live_vars_map *live_vars;\n+static vec<bitmap_head> live_vars_vec;\n+\n /* Finds tailcalls falling into basic block BB. The list of found tailcalls is\n    added to the start of RET.  */\n \n@@ -519,6 +525,29 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \ttail_recursion = true;\n     }\n \n+  /* Compute live vars if not computed yet.  */\n+  if (live_vars == NULL)\n+    {\n+      unsigned int cnt = 0;\n+      FOR_EACH_LOCAL_DECL (cfun, idx, var)\n+\tif (VAR_P (var)\n+\t    && auto_var_in_fn_p (var, cfun->decl)\n+\t    && may_be_aliased (var))\n+\t  {\n+\t    if (live_vars == NULL)\n+\t      live_vars = new live_vars_map;\n+\t    live_vars->put (DECL_UID (var), cnt++);\n+\t  }\n+      if (live_vars)\n+\tlive_vars_vec = compute_live_vars (cfun, live_vars);\n+    }\n+\n+  /* Determine a bitmap of variables which are still in scope after the\n+     call.  */\n+  bitmap local_live_vars = NULL;\n+  if (live_vars)\n+    local_live_vars = live_vars_at_stmt (live_vars_vec, live_vars, call);\n+\n   /* Make sure the tail invocation of this function does not indirectly\n      refer to local variables.  (Passing variables directly by value\n      is OK.)  */\n@@ -529,9 +558,28 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \t  && may_be_aliased (var)\n \t  && (ref_maybe_used_by_stmt_p (call, var)\n \t      || call_may_clobber_ref_p (call, var)))\n-\treturn;\n+\t{\n+\t  if (!VAR_P (var))\n+\t    {\n+\t      if (local_live_vars)\n+\t\tBITMAP_FREE (local_live_vars);\n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      unsigned int *v = live_vars->get (DECL_UID (var));\n+\t      if (bitmap_bit_p (local_live_vars, *v))\n+\t\t{\n+\t\t  BITMAP_FREE (local_live_vars);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n     }\n \n+  if (local_live_vars)\n+    BITMAP_FREE (local_live_vars);\n+\n   /* Now check the statements after the call.  None of them has virtual\n      operands, so they may only depend on the call through its return\n      value.  The return value should also be dependent on each of them,\n@@ -1032,6 +1080,13 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \tfind_tail_calls (e->src, &tailcalls);\n     }\n \n+  if (live_vars)\n+    {\n+      destroy_live_vars (live_vars_vec);\n+      delete live_vars;\n+      live_vars = NULL;\n+    }\n+\n   /* Construct the phi nodes and accumulators if necessary.  */\n   a_acc = m_acc = NULL_TREE;\n   for (act = tailcalls; act; act = act->next)"}]}