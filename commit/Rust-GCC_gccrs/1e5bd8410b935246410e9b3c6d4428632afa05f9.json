{"sha": "1e5bd8410b935246410e9b3c6d4428632afa05f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU1YmQ4NDEwYjkzNTI0NjQxMGU5YjNjNmQ0NDI4NjMyYWZhMDVmOQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-09-09T21:12:04Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-09T21:12:04Z"}, "message": "reload1.c (reload): Break out several subroutines and make some variables global.\n\n\t* reload1.c (reload): Break out several subroutines and make some\n\tvariables global.\n\t(calculate_needs_all_insns): New function, broken out of reload.\n\t(calculate_needs): Likewise.\n\t(find_reload_regs): Likewise.\n\t(find_group): Likewise.\n\t(find_tworeg_group): Likewise.\n\t(something_needs_reloads): New global variable, formerly in reload.\n\t(something_needs_elimination): Likewise.\n\t(caller_save_spill_class): Likewise.\n\t(caller_save_group_size): Likewise.\n\t(max_needs): Likewise.\n\t(group_size): Likewise.\n\t(max_groups): Likewise.\n\t(max_nongroups): Likewise.\n\t(group_mode): Likewise.\n\t(max_needs_insn): Likewise.\n\t(max_groups_insn): Likewise.\n\t(max_nongroups_insn): Likewise.\n\t(failure): Likewise.\n\nFrom-SVN: r22367", "tree": {"sha": "e4c84ea6bd7c6cba749077f7556358e9d9f34d35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4c84ea6bd7c6cba749077f7556358e9d9f34d35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e5bd8410b935246410e9b3c6d4428632afa05f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e5bd8410b935246410e9b3c6d4428632afa05f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e5bd8410b935246410e9b3c6d4428632afa05f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e5bd8410b935246410e9b3c6d4428632afa05f9/comments", "author": null, "committer": null, "parents": [{"sha": "5a0a1a6674f6973bb8c60fec6857f1f5c1ee472d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0a1a6674f6973bb8c60fec6857f1f5c1ee472d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a0a1a6674f6973bb8c60fec6857f1f5c1ee472d"}], "stats": {"total": 1789, "additions": 938, "deletions": 851}, "files": [{"sha": "5925e0287e1e8c857c0fd48a049bed75f8f2d3bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5bd8410b935246410e9b3c6d4428632afa05f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5bd8410b935246410e9b3c6d4428632afa05f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e5bd8410b935246410e9b3c6d4428632afa05f9", "patch": "@@ -1,5 +1,26 @@\n Wed Sep  9 21:58:41 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n \n+\t* reload1.c (reload): Break out several subroutines and make some\n+\tvariables global.\n+\t(calculate_needs_all_insns): New function, broken out of reload.\n+\t(calculate_needs): Likewise.\n+\t(find_reload_regs): Likewise.\n+\t(find_group): Likewise.\n+\t(find_tworeg_group): Likewise.\n+\t(something_needs_reloads): New global variable, formerly in reload.\n+\t(something_needs_elimination): Likewise.\n+\t(caller_save_spill_class): Likewise.\n+\t(caller_save_group_size): Likewise.\n+\t(max_needs): Likewise.\n+\t(group_size): Likewise.\n+\t(max_groups): Likewise.\n+\t(max_nongroups): Likewise.\n+\t(group_mode): Likewise.\n+\t(max_needs_insn): Likewise.\n+\t(max_groups_insn): Likewise.\n+\t(max_nongroups_insn): Likewise.\n+\t(failure): Likewise.\n+\n \t* print-rtl.c (print_rtx): For MEMs, print MEM_ALIAS_SET.\n \n Wed Sep  9 13:14:41 1998  Richard Henderson  <rth@cygnus.com>"}, {"sha": "5d9b8d102344f1557f6f8b7d19b60c44e05c807a", "filename": "gcc/reload1.c", "status": "modified", "additions": 917, "deletions": 851, "changes": 1768, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5bd8410b935246410e9b3c6d4428632afa05f9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5bd8410b935246410e9b3c6d4428632afa05f9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=1e5bd8410b935246410e9b3c6d4428632afa05f9", "patch": "@@ -351,6 +351,11 @@ static int num_labels;\n \n struct hard_reg_n_uses { int regno; int uses; };\n \f\n+static int calculate_needs_all_insns\tPROTO((rtx, int));\n+static int calculate_needs\t\tPROTO((int, rtx, rtx, int));\n+static int find_reload_regs\t\tPROTO((int, FILE *));\n+static int find_tworeg_group\t\tPROTO((int, int, FILE *));\n+static int find_group\t\t\tPROTO((int, int, FILE *));\n static int possible_group_p\t\tPROTO((int, int *));\n static void count_possible_groups\tPROTO((int *, enum machine_mode *,\n \t\t\t\t\t       int *, int));\n@@ -511,6 +516,49 @@ init_reload ()\n     }\n }\n \n+/* Global variables used by reload and its subroutines.  */\n+\n+/* Set during calculate_needs if an insn needs reloading.  */\n+static int something_needs_reloads;\n+/* Set during calculate_needs if an insn needs register elimination.  */\n+static int something_needs_elimination;\n+\n+/* Indicate whether caller saves need a spill register.  */\n+static enum reg_class caller_save_spill_class = NO_REGS;\n+static int caller_save_group_size = 1;\n+\n+/* For each class, number of reload regs needed in that class.\n+   This is the maximum over all insns of the needs in that class\n+   of the individual insn.  */\n+static int max_needs[N_REG_CLASSES];\n+\n+/* For each class, size of group of consecutive regs\n+   that is needed for the reloads of this class.  */\n+static int group_size[N_REG_CLASSES];\n+\n+/* For each class, max number of consecutive groups needed.\n+   (Each group contains group_size[CLASS] consecutive registers.)  */\n+static int max_groups[N_REG_CLASSES];\n+\n+/* For each class, max number needed of regs that don't belong\n+   to any of the groups.  */\n+static int max_nongroups[N_REG_CLASSES];\n+\n+/* For each class, the machine mode which requires consecutive\n+   groups of regs of that class.\n+   If two different modes ever require groups of one class,\n+   they must be the same size and equally restrictive for that class,\n+   otherwise we can't handle the complexity.  */\n+static enum machine_mode group_mode[N_REG_CLASSES];\n+\n+/* Record the insn where each maximum need is first found.  */\n+static rtx max_needs_insn[N_REG_CLASSES];\n+static rtx max_groups_insn[N_REG_CLASSES];\n+static rtx max_nongroups_insn[N_REG_CLASSES];\n+\n+/* Nonzero means we couldn't get enough spill regs.  */\n+static int failure;\n+\n /* Main entry point for the reload pass.\n \n    FIRST is the first insn of the function being compiled.\n@@ -535,8 +583,7 @@ reload (first, global, dumpfile)\n      int global;\n      FILE *dumpfile;\n {\n-  register int class;\n-  register int i, j, k;\n+  register int i, j;\n   register rtx insn;\n   register struct elim_table *ep;\n \n@@ -546,24 +593,18 @@ reload (first, global, dumpfile)\n   int (*real_at_ptr)[NUM_ELIMINABLE_REGS];\n \n   int something_changed;\n-  int something_needs_reloads;\n-  int something_needs_elimination;\n-  int new_basic_block_needs;\n-  enum reg_class caller_save_spill_class = NO_REGS;\n-  int caller_save_group_size = 1;\n-\n-  /* Nonzero means we couldn't get enough spill regs.  */\n-  int failure = 0;\n-\n-  /* The basic block number currently being processed for INSN.  */\n-  int this_block;\n \n   /* Make sure even insns with volatile mem refs are recognizable.  */\n   init_recog ();\n \n+  failure = 0;\n+\n   /* Enable find_equiv_reg to distinguish insns made by reload.  */\n   reload_first_uid = get_max_uid ();\n \n+  caller_save_spill_class = NO_REGS;\n+  caller_save_group_size = 1;\n+\n   for (i = 0; i < N_REG_CLASSES; i++)\n     basic_block_needs[i] = 0;\n \n@@ -864,31 +905,6 @@ reload (first, global, dumpfile)\n   something_needs_elimination = 0;\n   while (something_changed)\n     {\n-      rtx after_call = 0;\n-\n-      /* For each class, number of reload regs needed in that class.\n-\t This is the maximum over all insns of the needs in that class\n-\t of the individual insn.  */\n-      int max_needs[N_REG_CLASSES];\n-      /* For each class, size of group of consecutive regs\n-\t that is needed for the reloads of this class.  */\n-      int group_size[N_REG_CLASSES];\n-      /* For each class, max number of consecutive groups needed.\n-\t (Each group contains group_size[CLASS] consecutive registers.)  */\n-      int max_groups[N_REG_CLASSES];\n-      /* For each class, max number needed of regs that don't belong\n-\t to any of the groups.  */\n-      int max_nongroups[N_REG_CLASSES];\n-      /* For each class, the machine mode which requires consecutive\n-\t groups of regs of that class.\n-\t If two different modes ever require groups of one class,\n-\t they must be the same size and equally restrictive for that class,\n-\t otherwise we can't handle the complexity.  */\n-      enum machine_mode group_mode[N_REG_CLASSES];\n-      /* Record the insn where each maximum need is first found.  */\n-      rtx max_needs_insn[N_REG_CLASSES];\n-      rtx max_groups_insn[N_REG_CLASSES];\n-      rtx max_nongroups_insn[N_REG_CLASSES];\n       rtx x;\n       HOST_WIDE_INT starting_frame_size;\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n@@ -907,13 +923,6 @@ reload (first, global, dumpfile)\n       for (i = 0; i < N_REG_CLASSES; i++)\n \tgroup_mode[i] = VOIDmode;\n \n-      /* Keep track of which basic blocks are needing the reloads.  */\n-      this_block = 0;\n-\n-      /* Remember whether any element of basic_block_needs\n-\t changes from 0 to 1 in this pass.  */\n-      new_basic_block_needs = 0;\n-\n       /* Round size of stack frame to BIGGEST_ALIGNMENT.  This must be done\n \t here because the stack size may be a part of the offset computation\n \t for register elimination, and there might have been new stack slots\n@@ -1025,511 +1034,7 @@ reload (first, global, dumpfile)\n \t  group_size[(int) caller_save_spill_class] = caller_save_group_size;\n \t}\n \n-      /* Compute the most additional registers needed by any instruction.\n-\t Collect information separately for each class of regs.  */\n-\n-      for (insn = first; insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (global && this_block + 1 < n_basic_blocks\n-\t      && insn == basic_block_head[this_block+1])\n-\t    ++this_block;\n-\n-\t  /* If this is a label, a JUMP_INSN, or has REG_NOTES (which\n-\t     might include REG_LABEL), we need to see what effects this\n-\t     has on the known offsets at labels.  */\n-\n-\t  if (GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == JUMP_INSN\n-\t      || (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t\t  && REG_NOTES (insn) != 0))\n-\t    set_label_offsets (insn, insn, 0);\n-\n-\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t    {\n-\t      /* Nonzero means don't use a reload reg that overlaps\n-\t\t the place where a function value can be returned.  */\n-\t      rtx avoid_return_reg = 0;\n-\n-\t      rtx old_body = PATTERN (insn);\n-\t      int old_code = INSN_CODE (insn);\n- \t      rtx old_notes = REG_NOTES (insn);\n-\t      int did_elimination = 0;\n-\n-\t      /* To compute the number of reload registers of each class \n-\t\t needed for an insn, we must simulate what choose_reload_regs\n-\t\t can do.  We do this by splitting an insn into an \"input\" and\n-\t\t an \"output\" part.  RELOAD_OTHER reloads are used in both. \n-\t\t The input part uses those reloads, RELOAD_FOR_INPUT reloads,\n-\t\t which must be live over the entire input section of reloads,\n-\t\t and the maximum of all the RELOAD_FOR_INPUT_ADDRESS and\n-\t\t RELOAD_FOR_OPERAND_ADDRESS reloads, which conflict with the\n-\t\t inputs.\n-\n-\t\t The registers needed for output are RELOAD_OTHER and\n-\t\t RELOAD_FOR_OUTPUT, which are live for the entire output\n-\t\t portion, and the maximum of all the RELOAD_FOR_OUTPUT_ADDRESS\n-\t\t reloads for each operand.\n-\n-\t\t The total number of registers needed is the maximum of the\n-\t\t inputs and outputs.  */\n-\n-\t      struct needs\n-\t\t{\n-\t\t  /* [0] is normal, [1] is nongroup.  */\n-\t\t  int regs[2][N_REG_CLASSES];\n-\t\t  int groups[N_REG_CLASSES];\n-\t\t};\n-\n-\t      /* Each `struct needs' corresponds to one RELOAD_... type.  */\n-\t      struct {\n-\t\tstruct needs other;\n-\t\tstruct needs input;\n-\t\tstruct needs output;\n-\t\tstruct needs insn;\n-\t\tstruct needs other_addr;\n-\t\tstruct needs op_addr;\n-\t\tstruct needs op_addr_reload;\n-\t\tstruct needs in_addr[MAX_RECOG_OPERANDS];\n-\t\tstruct needs in_addr_addr[MAX_RECOG_OPERANDS];\n-\t\tstruct needs out_addr[MAX_RECOG_OPERANDS];\n-\t\tstruct needs out_addr_addr[MAX_RECOG_OPERANDS];\n-\t      } insn_needs;\n-\n-\t      /* If needed, eliminate any eliminable registers.  */\n-\t      if (num_eliminable)\n-\t\tdid_elimination = eliminate_regs_in_insn (insn, 0);\n-\n-\t      /* Set avoid_return_reg if this is an insn\n-\t\t that might use the value of a function call.  */\n-\t      if (SMALL_REGISTER_CLASSES && GET_CODE (insn) == CALL_INSN)\n-\t\t{\n-\t\t  if (GET_CODE (PATTERN (insn)) == SET)\n-\t\t    after_call = SET_DEST (PATTERN (insn));\n-\t\t  else if (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t\t\t   && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n-\t\t    after_call = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n-\t\t  else\n-\t\t    after_call = 0;\n-\t\t}\n-\t      else if (SMALL_REGISTER_CLASSES && after_call != 0\n-\t\t       && !(GET_CODE (PATTERN (insn)) == SET\n-\t\t\t    && SET_DEST (PATTERN (insn)) == stack_pointer_rtx)\n-\t\t       && GET_CODE (PATTERN (insn)) != USE)\n-\t\t{\n-\t\t  if (reg_referenced_p (after_call, PATTERN (insn)))\n-\t\t    avoid_return_reg = after_call;\n-\t\t  after_call = 0;\n-\t\t}\n-\n-\t      /* Analyze the instruction.  */\n-\t      find_reloads (insn, 0, spill_indirect_levels, global,\n-\t\t\t    spill_reg_order);\n-\n-\t      /* Remember for later shortcuts which insns had any reloads or\n-\t\t register eliminations.\n-\n-\t\t One might think that it would be worthwhile to mark insns\n-\t\t that need register replacements but not reloads, but this is\n-\t\t not safe because find_reloads may do some manipulation of\n-\t\t the insn (such as swapping commutative operands), which would\n-\t\t be lost when we restore the old pattern after register\n-\t\t replacement.  So the actions of find_reloads must be redone in\n-\t\t subsequent passes or in reload_as_needed.\n-\n-\t\t However, it is safe to mark insns that need reloads\n-\t\t but not register replacement.  */\n-\n-\t      PUT_MODE (insn, (did_elimination ? QImode\n-\t\t\t       : n_reloads ? HImode\n-\t\t\t       : GET_MODE (insn) == DImode ? DImode\n-\t\t\t       : VOIDmode));\n-\n-\t      /* Discard any register replacements done.  */\n-\t      if (did_elimination)\n-\t\t{\n-\t\t  obstack_free (&reload_obstack, reload_firstobj);\n-\t\t  PATTERN (insn) = old_body;\n-\t\t  INSN_CODE (insn) = old_code;\n- \t\t  REG_NOTES (insn) = old_notes;\n-\t\t  something_needs_elimination = 1;\n-\t\t}\n-\n-\t      /* If this insn has no reloads, we need not do anything except\n-\t\t in the case of a CALL_INSN when we have caller-saves and\n-\t\t caller-save needs reloads.  */\n-\n-\t      if (n_reloads == 0\n-\t\t  && ! (GET_CODE (insn) == CALL_INSN\n-\t\t\t&& caller_save_spill_class != NO_REGS))\n-\t\tcontinue;\n-\n-\t      something_needs_reloads = 1;\n-\t      bzero ((char *) &insn_needs, sizeof insn_needs);\n-\n-\t      /* Count each reload once in every class\n-\t\t containing the reload's own class.  */\n-\n-\t      for (i = 0; i < n_reloads; i++)\n-\t\t{\n-\t\t  register enum reg_class *p;\n-\t\t  enum reg_class class = reload_reg_class[i];\n-\t\t  int size;\n-\t\t  enum machine_mode mode;\n-\t\t  struct needs *this_needs;\n-\n-\t\t  /* Don't count the dummy reloads, for which one of the\n-\t\t     regs mentioned in the insn can be used for reloading.\n-\t\t     Don't count optional reloads.\n-\t\t     Don't count reloads that got combined with others.  */\n-\t\t  if (reload_reg_rtx[i] != 0\n-\t\t      || reload_optional[i] != 0\n-\t\t      || (reload_out[i] == 0 && reload_in[i] == 0\n-\t\t\t  && ! reload_secondary_p[i]))\n-  \t\t    continue;\n-\n-\t\t  /* Show that a reload register of this class is needed\n-\t\t     in this basic block.  We do not use insn_needs and\n-\t\t     insn_groups because they are overly conservative for\n-\t\t     this purpose.  */\n-\t\t  if (global && ! basic_block_needs[(int) class][this_block])\n-\t\t    {\n-\t\t      basic_block_needs[(int) class][this_block] = 1;\n-\t\t      new_basic_block_needs = 1;\n-\t\t    }\n-\n-\t\t  mode = reload_inmode[i];\n-\t\t  if (GET_MODE_SIZE (reload_outmode[i]) > GET_MODE_SIZE (mode))\n-\t\t    mode = reload_outmode[i];\n-\t\t  size = CLASS_MAX_NREGS (class, mode);\n-\n-\t\t  /* Decide which time-of-use to count this reload for.  */\n-\t\t  switch (reload_when_needed[i])\n-\t\t    {\n-\t\t    case RELOAD_OTHER:\n-\t\t      this_needs = &insn_needs.other;\n-\t\t      break;\n-\t\t    case RELOAD_FOR_INPUT:\n-\t\t      this_needs = &insn_needs.input;\n-\t\t      break;\n-\t\t    case RELOAD_FOR_OUTPUT:\n-\t\t      this_needs = &insn_needs.output;\n-\t\t      break;\n-\t\t    case RELOAD_FOR_INSN:\n-\t\t      this_needs = &insn_needs.insn;\n-\t\t      break;\n-\t\t    case RELOAD_FOR_OTHER_ADDRESS:\n-\t\t      this_needs = &insn_needs.other_addr;\n-\t\t      break;\n-\t\t    case RELOAD_FOR_INPUT_ADDRESS:\n-\t\t      this_needs = &insn_needs.in_addr[reload_opnum[i]];\n-\t\t      break;\n-\t\t    case RELOAD_FOR_INPADDR_ADDRESS:\n-\t\t      this_needs = &insn_needs.in_addr_addr[reload_opnum[i]];\n-\t\t      break;\n-\t\t    case RELOAD_FOR_OUTPUT_ADDRESS:\n-\t\t      this_needs = &insn_needs.out_addr[reload_opnum[i]];\n-\t\t      break;\n-\t\t    case RELOAD_FOR_OUTADDR_ADDRESS:\n-\t\t      this_needs = &insn_needs.out_addr_addr[reload_opnum[i]];\n-\t\t      break;\n-\t\t    case RELOAD_FOR_OPERAND_ADDRESS:\n-\t\t      this_needs = &insn_needs.op_addr;\n-\t\t      break;\n-\t\t    case RELOAD_FOR_OPADDR_ADDR:\n-\t\t      this_needs = &insn_needs.op_addr_reload;\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  if (size > 1)\n-\t\t    {\n-\t\t      enum machine_mode other_mode, allocate_mode;\n-\n-\t\t      /* Count number of groups needed separately from\n-\t\t\t number of individual regs needed.  */\n-\t\t      this_needs->groups[(int) class]++;\n-\t\t      p = reg_class_superclasses[(int) class];\n-\t\t      while (*p != LIM_REG_CLASSES)\n-\t\t\tthis_needs->groups[(int) *p++]++;\n-\n-\t\t      /* Record size and mode of a group of this class.  */\n-\t\t      /* If more than one size group is needed,\n-\t\t\t make all groups the largest needed size.  */\n-\t\t      if (group_size[(int) class] < size)\n-\t\t\t{\n-\t\t\t  other_mode = group_mode[(int) class];\n-\t\t\t  allocate_mode = mode;\n-\n-\t\t\t  group_size[(int) class] = size;\n-\t\t\t  group_mode[(int) class] = mode;\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  other_mode = mode;\n-\t\t\t  allocate_mode = group_mode[(int) class];\n-\t\t\t}\n-\n-\t\t      /* Crash if two dissimilar machine modes both need\n-\t\t\t groups of consecutive regs of the same class.  */\n-\n-\t\t      if (other_mode != VOIDmode && other_mode != allocate_mode\n-\t\t\t  && ! modes_equiv_for_class_p (allocate_mode,\n-\t\t\t\t\t\t\tother_mode, class))\n-\t\t\tfatal_insn (\"Two dissimilar machine modes both need groups of consecutive regs of the same class\",\n-\t\t\t\t    insn);\n-\t\t    }\n-\t\t  else if (size == 1)\n-\t\t    {\n-\t\t      this_needs->regs[reload_nongroup[i]][(int) class] += 1;\n-\t\t      p = reg_class_superclasses[(int) class];\n-\t\t      while (*p != LIM_REG_CLASSES)\n-\t\t\tthis_needs->regs[reload_nongroup[i]][(int) *p++] += 1;\n-\t\t    }\n-\t\t  else\n-\t\t    abort ();\n-\t\t}\n-\n-\t      /* All reloads have been counted for this insn;\n-\t\t now merge the various times of use.\n-\t\t This sets insn_needs, etc., to the maximum total number\n-\t\t of registers needed at any point in this insn.  */\n-\n-\t      for (i = 0; i < N_REG_CLASSES; i++)\n-\t\t{\n-\t\t  int in_max, out_max;\n-\n-\t\t  /* Compute normal and nongroup needs.  */\n-\t\t  for (j = 0; j <= 1; j++)\n-\t\t    {\n-\t\t      for (in_max = 0, out_max = 0, k = 0;\n-\t\t\t   k < reload_n_operands; k++)\n-\t\t\t{\n-\t\t\t  in_max\n-\t\t\t    = MAX (in_max,\n-\t\t\t\t   (insn_needs.in_addr[k].regs[j][i]\n-\t\t\t\t    + insn_needs.in_addr_addr[k].regs[j][i]));\n-\t\t\t  out_max\n-\t\t\t    = MAX (out_max, insn_needs.out_addr[k].regs[j][i]);\n-\t\t\t  out_max\n-\t\t\t    = MAX (out_max,\n-\t\t\t\t   insn_needs.out_addr_addr[k].regs[j][i]);\n-\t\t\t}\n-\n-\t\t      /* RELOAD_FOR_INSN reloads conflict with inputs, outputs,\n-\t\t\t and operand addresses but not things used to reload\n-\t\t\t them.  Similarly, RELOAD_FOR_OPERAND_ADDRESS reloads\n-\t\t\t don't conflict with things needed to reload inputs or\n-\t\t\t outputs.  */\n-\n-\t\t      in_max = MAX (MAX (insn_needs.op_addr.regs[j][i],\n-\t\t\t\t\t insn_needs.op_addr_reload.regs[j][i]),\n-\t\t\t\t    in_max);\n-\n-\t\t      out_max = MAX (out_max, insn_needs.insn.regs[j][i]);\n-\n-\t\t      insn_needs.input.regs[j][i]\n-\t\t\t= MAX (insn_needs.input.regs[j][i]\n-\t\t\t       + insn_needs.op_addr.regs[j][i]\n-\t\t\t       + insn_needs.insn.regs[j][i],\n-\t\t\t       in_max + insn_needs.input.regs[j][i]);\n-\n-\t\t      insn_needs.output.regs[j][i] += out_max;\n-\t\t      insn_needs.other.regs[j][i]\n-\t\t\t+= MAX (MAX (insn_needs.input.regs[j][i],\n-\t\t\t\t     insn_needs.output.regs[j][i]),\n-\t\t\t\tinsn_needs.other_addr.regs[j][i]);\n-\n-\t\t    }\n-\n-\t\t  /* Now compute group needs.  */\n-\t\t  for (in_max = 0, out_max = 0, j = 0;\n-\t\t       j < reload_n_operands; j++)\n-\t\t    {\n-\t\t      in_max = MAX (in_max, insn_needs.in_addr[j].groups[i]);\n-\t\t      in_max = MAX (in_max,\n-\t\t\t\t     insn_needs.in_addr_addr[j].groups[i]);\n-\t\t      out_max\n-\t\t\t= MAX (out_max, insn_needs.out_addr[j].groups[i]);\n-\t\t      out_max\n-\t\t\t= MAX (out_max, insn_needs.out_addr_addr[j].groups[i]);\n-\t\t    }\n-\n-\t\t  in_max = MAX (MAX (insn_needs.op_addr.groups[i],\n-\t\t\t\t     insn_needs.op_addr_reload.groups[i]),\n-\t\t\t\tin_max);\n-\t\t  out_max = MAX (out_max, insn_needs.insn.groups[i]);\n-\n-\t\t  insn_needs.input.groups[i]\n-\t\t    = MAX (insn_needs.input.groups[i]\n-\t\t\t   + insn_needs.op_addr.groups[i]\n-\t\t\t   + insn_needs.insn.groups[i],\n-\t\t\t   in_max + insn_needs.input.groups[i]);\n-\n-\t\t  insn_needs.output.groups[i] += out_max;\n-\t\t  insn_needs.other.groups[i]\n-\t\t    += MAX (MAX (insn_needs.input.groups[i],\n-\t\t\t\t insn_needs.output.groups[i]),\n-\t\t\t    insn_needs.other_addr.groups[i]);\n-\t\t}\n-\n-\t      /* If this is a CALL_INSN and caller-saves will need\n-\t\t a spill register, act as if the spill register is\n-\t\t needed for this insn.   However, the spill register\n-\t\t can be used by any reload of this insn, so we only\n-\t\t need do something if no need for that class has\n-\t\t been recorded.\n-\n-\t\t The assumption that every CALL_INSN will trigger a\n-\t\t caller-save is highly conservative, however, the number\n-\t\t of cases where caller-saves will need a spill register but\n-\t\t a block containing a CALL_INSN won't need a spill register\n-\t\t of that class should be quite rare.\n-\n-\t\t If a group is needed, the size and mode of the group will\n-\t\t have been set up at the beginning of this loop.  */\n-\n-\t      if (GET_CODE (insn) == CALL_INSN\n-\t\t  && caller_save_spill_class != NO_REGS)\n-\t\t{\n-\t\t  /* See if this register would conflict with any reload that\n-\t\t     needs a group or any reload that needs a nongroup.  */\n-\t\t  int nongroup_need = 0;\n-\t\t  int *caller_save_needs;\n-\n-\t\t  for (j = 0; j < n_reloads; j++)\n-\t\t    if (reg_classes_intersect_p (caller_save_spill_class,\n-\t\t\t\t\t\t reload_reg_class[j])\n-\t\t\t&& ((CLASS_MAX_NREGS\n-\t\t\t     (reload_reg_class[j],\n-\t\t\t      (GET_MODE_SIZE (reload_outmode[j])\n-\t\t\t       > GET_MODE_SIZE (reload_inmode[j]))\n-\t\t\t      ? reload_outmode[j] : reload_inmode[j])\n-\t\t\t     > 1)\n-\t\t\t    || reload_nongroup[j]))\n-\t\t      {\n-\t\t\tnongroup_need = 1;\n-\t\t\tbreak;\n-\t\t      }\n-\n-\t\t  caller_save_needs \n-\t\t    = (caller_save_group_size > 1\n-\t\t       ? insn_needs.other.groups\n-\t\t       : insn_needs.other.regs[nongroup_need]); \n-\n-\t\t  if (caller_save_needs[(int) caller_save_spill_class] == 0)\n-\t\t    {\n-\t\t      register enum reg_class *p\n-\t\t\t= reg_class_superclasses[(int) caller_save_spill_class];\n-\n-\t\t      caller_save_needs[(int) caller_save_spill_class]++;\n-\n-\t\t      while (*p != LIM_REG_CLASSES)\n-\t\t\tcaller_save_needs[(int) *p++] += 1;\n-\t\t    }\n-\n-\t\t  /* Show that this basic block will need a register of\n-                   this class.  */\n-\n-\t\t  if (global\n-\t\t      && ! (basic_block_needs[(int) caller_save_spill_class]\n-\t\t\t    [this_block]))\n-\t\t    {\n-\t\t      basic_block_needs[(int) caller_save_spill_class]\n-\t\t\t[this_block] = 1;\n-\t\t      new_basic_block_needs = 1;\n-\t\t    }\n-\t\t}\n-\n-\t      /* If this insn stores the value of a function call,\n-\t\t and that value is in a register that has been spilled,\n-\t\t and if the insn needs a reload in a class\n-\t\t that might use that register as the reload register,\n-\t\t then add an extra need in that class.\n-\t\t This makes sure we have a register available that does\n-\t\t not overlap the return value.  */\n-\n-\t      if (SMALL_REGISTER_CLASSES && avoid_return_reg)\n-\t\t{\n-\t\t  int regno = REGNO (avoid_return_reg);\n-\t\t  int nregs\n-\t\t    = HARD_REGNO_NREGS (regno, GET_MODE (avoid_return_reg));\n-\t\t  int r;\n-\t\t  int basic_needs[N_REG_CLASSES], basic_groups[N_REG_CLASSES];\n-\n-\t\t  /* First compute the \"basic needs\", which counts a\n-\t\t     need only in the smallest class in which it\n-\t\t     is required.  */\n-\n-\t\t  bcopy ((char *) insn_needs.other.regs[0],\n-\t\t\t (char *) basic_needs, sizeof basic_needs);\n-\t\t  bcopy ((char *) insn_needs.other.groups,\n-\t\t\t (char *) basic_groups, sizeof basic_groups);\n-\n-\t\t  for (i = 0; i < N_REG_CLASSES; i++)\n-\t\t    {\n-\t\t      enum reg_class *p;\n-\n-\t\t      if (basic_needs[i] >= 0)\n-\t\t\tfor (p = reg_class_superclasses[i];\n-\t\t\t     *p != LIM_REG_CLASSES; p++)\n-\t\t\t  basic_needs[(int) *p] -= basic_needs[i];\n-\n-\t\t      if (basic_groups[i] >= 0)\n-\t\t\tfor (p = reg_class_superclasses[i];\n-\t\t\t     *p != LIM_REG_CLASSES; p++)\n-\t\t\t  basic_groups[(int) *p] -= basic_groups[i];\n-\t\t    }\n-\n-\t\t  /* Now count extra regs if there might be a conflict with\n-\t\t     the return value register.  */\n-\n-\t\t  for (r = regno; r < regno + nregs; r++)\n-\t\t    if (spill_reg_order[r] >= 0)\n-\t\t      for (i = 0; i < N_REG_CLASSES; i++)\n-\t\t\tif (TEST_HARD_REG_BIT (reg_class_contents[i], r))\n-\t\t\t  {\n-\t\t\t    if (basic_needs[i] > 0)\n-\t\t\t      {\n-\t\t\t\tenum reg_class *p;\n-\n-\t\t\t\tinsn_needs.other.regs[0][i]++;\n-\t\t\t\tp = reg_class_superclasses[i];\n-\t\t\t\twhile (*p != LIM_REG_CLASSES)\n-\t\t\t\t  insn_needs.other.regs[0][(int) *p++]++;\n-\t\t\t      }\n-\t\t\t    if (basic_groups[i] > 0)\n-\t\t\t      {\n-\t\t\t\tenum reg_class *p;\n-\n-\t\t\t\tinsn_needs.other.groups[i]++;\n-\t\t\t\tp = reg_class_superclasses[i];\n-\t\t\t\twhile (*p != LIM_REG_CLASSES)\n-\t\t\t\t  insn_needs.other.groups[(int) *p++]++;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t}\n-\n-\t      /* For each class, collect maximum need of any insn.  */\n-\n-\t      for (i = 0; i < N_REG_CLASSES; i++)\n-\t\t{\n-\t\t  if (max_needs[i] < insn_needs.other.regs[0][i])\n-\t\t    {\n-\t\t      max_needs[i] = insn_needs.other.regs[0][i];\n-\t\t      max_needs_insn[i] = insn;\n-\t\t    }\n-\t\t  if (max_groups[i] < insn_needs.other.groups[i])\n-\t\t    {\n-\t\t      max_groups[i] = insn_needs.other.groups[i];\n-\t\t      max_groups_insn[i] = insn;\n-\t\t    }\n-\t\t  if (max_nongroups[i] < insn_needs.other.regs[1][i])\n-\t\t    {\n-\t\t      max_nongroups[i] = insn_needs.other.regs[1][i];\n-\t\t      max_nongroups_insn[i] = insn;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  /* Note that there is a continue statement above.  */\n-\t}\n+      something_changed |= calculate_needs_all_insns (first, global);\n \n       /* If we allocated any new memory locations, make another pass\n \t since it might have changed elimination offsets.  */\n@@ -1556,7 +1061,7 @@ reload (first, global, dumpfile)\n \t\t       mode_name[(int) group_mode[i]],\n \t\t       reg_class_names[i], INSN_UID (max_groups_insn[i]));\n \t  }\n-\t\t\t \n+\n       /* If we have caller-saves, set up the save areas and see if caller-save\n \t will need a spill register.  */\n \n@@ -1666,7 +1171,7 @@ reload (first, global, dumpfile)\n       for (i = 0; i < N_REG_CLASSES; i++)\n \tif (max_needs[i] > 0 || max_groups[i] > 0 || max_nongroups[i] > 0)\n \t  break;\n-      if (i == N_REG_CLASSES && !new_basic_block_needs && ! something_changed)\n+      if (i == N_REG_CLASSES && ! something_changed)\n \tbreak;\n \n       /* Not all needs are met; must spill some hard regs.  */\n@@ -1708,305 +1213,9 @@ reload (first, global, dumpfile)\n \t  n_spills = 0;\n \t}\n \n-      /* Now find more reload regs to satisfy the remaining need\n-\t Do it by ascending class number, since otherwise a reg\n-\t might be spilled for a big class and might fail to count\n-\t for a smaller class even though it belongs to that class.\n-\n-\t Count spilled regs in `spills', and add entries to\n-\t `spill_regs' and `spill_reg_order'.\n-\n-\t ??? Note there is a problem here.\n-\t When there is a need for a group in a high-numbered class,\n-\t and also need for non-group regs that come from a lower class,\n-\t the non-group regs are chosen first.  If there aren't many regs,\n-\t they might leave no room for a group.\n-\n-\t This was happening on the 386.  To fix it, we added the code\n-\t that calls possible_group_p, so that the lower class won't\n-\t break up the last possible group.\n-\n-\t Really fixing the problem would require changes above\n-\t in counting the regs already spilled, and in choose_reload_regs.\n-\t It might be hard to avoid introducing bugs there.  */\n-\n-      CLEAR_HARD_REG_SET (counted_for_groups);\n-      CLEAR_HARD_REG_SET (counted_for_nongroups);\n-\n-      for (class = 0; class < N_REG_CLASSES; class++)\n-\t{\n-\t  /* First get the groups of registers.\n-\t     If we got single registers first, we might fragment\n-\t     possible groups.  */\n-\t  while (max_groups[class] > 0)\n-\t    {\n-\t      /* If any single spilled regs happen to form groups,\n-\t\t count them now.  Maybe we don't really need\n-\t\t to spill another group.  */\n-\t      count_possible_groups (group_size, group_mode, max_groups,\n-\t\t\t\t     class);\n-\n-\t      if (max_groups[class] <= 0)\n-\t\tbreak;\n-\n-\t      /* Groups of size 2 (the only groups used on most machines)\n-\t\t are treated specially.  */\n-\t      if (group_size[class] == 2)\n-\t\t{\n-\t\t  /* First, look for a register that will complete a group.  */\n-\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t    {\n-\t\t      int other;\n-\n-\t\t      j = potential_reload_regs[i];\n-\t\t      if (j >= 0 && ! TEST_HARD_REG_BIT (bad_spill_regs, j)\n-\t\t\t  &&\n-\t\t\t  ((j > 0 && (other = j - 1, spill_reg_order[other] >= 0)\n-\t\t\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n-\t\t\t    && TEST_HARD_REG_BIT (reg_class_contents[class], other)\n-\t\t\t    && HARD_REGNO_MODE_OK (other, group_mode[class])\n-\t\t\t    && ! TEST_HARD_REG_BIT (counted_for_nongroups,\n-\t\t\t\t\t\t    other)\n-\t\t\t    /* We don't want one part of another group.\n-\t\t\t       We could get \"two groups\" that overlap!  */\n-\t\t\t    && ! TEST_HARD_REG_BIT (counted_for_groups, other))\n-\t\t\t   ||\n-\t\t\t   (j < FIRST_PSEUDO_REGISTER - 1\n-\t\t\t    && (other = j + 1, spill_reg_order[other] >= 0)\n-\t\t\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n-\t\t\t    && TEST_HARD_REG_BIT (reg_class_contents[class], other)\n-\t\t\t    && HARD_REGNO_MODE_OK (j, group_mode[class])\n-\t\t\t    && ! TEST_HARD_REG_BIT (counted_for_nongroups,\n-\t\t\t\t\t\t    other)\n-\t\t\t    && ! TEST_HARD_REG_BIT (counted_for_groups,\n-\t\t\t\t\t\t    other))))\n-\t\t\t{\n-\t\t\t  register enum reg_class *p;\n-\n-\t\t\t  /* We have found one that will complete a group,\n-\t\t\t     so count off one group as provided.  */\n-\t\t\t  max_groups[class]--;\n-\t\t\t  p = reg_class_superclasses[class];\n-\t\t\t  while (*p != LIM_REG_CLASSES)\n-\t\t\t    {\n-\t\t\t      if (group_size [(int) *p] <= group_size [class])\n-\t\t\t\tmax_groups[(int) *p]--;\n-\t\t\t      p++;\n-\t\t\t    }\n-\n-\t\t\t  /* Indicate both these regs are part of a group.  */\n-\t\t\t  SET_HARD_REG_BIT (counted_for_groups, j);\n-\t\t\t  SET_HARD_REG_BIT (counted_for_groups, other);\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t  /* We can't complete a group, so start one.  */\n-\t\t  /* Look for a pair neither of which is explicitly used.  */\n-\t\t  if (SMALL_REGISTER_CLASSES && i == FIRST_PSEUDO_REGISTER)\n-\t\t    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t      {\n-\t\t\tint k;\n-\t\t\tj = potential_reload_regs[i];\n-\t\t\t/* Verify that J+1 is a potential reload reg.  */\n-\t\t\tfor (k = 0; k < FIRST_PSEUDO_REGISTER; k++)\n-\t\t\t  if (potential_reload_regs[k] == j + 1)\n-\t\t\t    break;\n-\t\t\tif (j >= 0 && j + 1 < FIRST_PSEUDO_REGISTER\n-\t\t\t    && k < FIRST_PSEUDO_REGISTER\n-\t\t\t    && spill_reg_order[j] < 0 && spill_reg_order[j + 1] < 0\n-\t\t\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n-\t\t\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j + 1)\n-\t\t\t    && HARD_REGNO_MODE_OK (j, group_mode[class])\n-\t\t\t    && ! TEST_HARD_REG_BIT (counted_for_nongroups,\n-\t\t\t\t\t\t    j + 1)\n-\t\t\t    && ! TEST_HARD_REG_BIT (bad_spill_regs, j + 1)\n-\t\t\t    /* Reject J at this stage\n-\t\t\t       if J+1 was explicitly used.  */\n-\t\t\t    && ! regs_explicitly_used[j + 1])\n-\t\t\t  break;\n-\t\t      }\n-\t\t  /* Now try any group at all\n-\t\t     whose registers are not in bad_spill_regs.  */\n-\t\t  if (i == FIRST_PSEUDO_REGISTER)\n-\t\t    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t      {\n-\t\t\tint k;\n-\t\t\tj = potential_reload_regs[i];\n-\t\t\t/* Verify that J+1 is a potential reload reg.  */\n-\t\t\tfor (k = 0; k < FIRST_PSEUDO_REGISTER; k++)\n-\t\t\t  if (potential_reload_regs[k] == j + 1)\n-\t\t\t    break;\n-\t\t\tif (j >= 0 && j + 1 < FIRST_PSEUDO_REGISTER\n-\t\t\t    && k < FIRST_PSEUDO_REGISTER\n-\t\t\t    && spill_reg_order[j] < 0 && spill_reg_order[j + 1] < 0\n-\t\t\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n-\t\t\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j + 1)\n-\t\t\t    && HARD_REGNO_MODE_OK (j, group_mode[class])\n-\t\t\t    && ! TEST_HARD_REG_BIT (counted_for_nongroups,\n-\t\t\t\t\t\t    j + 1)\n-\t\t\t    && ! TEST_HARD_REG_BIT (bad_spill_regs, j + 1))\n-\t\t\t  break;\n-\t\t      }\n-\n-\t\t  /* I should be the index in potential_reload_regs\n-\t\t     of the new reload reg we have found.  */\n-\n-\t\t  if (i >= FIRST_PSEUDO_REGISTER)\n-\t\t    {\n-\t\t      /* There are no groups left to spill.  */\n-\t\t      spill_failure (max_groups_insn[class]);\n-\t\t      failure = 1;\n-\t\t      goto failed;\n-\t\t    }\n-\t\t  else\n-\t\t    something_changed\n-\t\t      |= new_spill_reg (i, class, max_needs, NULL_PTR,\n-\t\t\t\t\tglobal, dumpfile);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* For groups of more than 2 registers,\n-\t\t     look for a sufficient sequence of unspilled registers,\n-\t\t     and spill them all at once.  */\n-\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t    {\n-\t\t      int k;\n-\n-\t\t      j = potential_reload_regs[i];\n-\t\t      if (j >= 0\n-\t\t\t  && j + group_size[class] <= FIRST_PSEUDO_REGISTER\n-\t\t\t  && HARD_REGNO_MODE_OK (j, group_mode[class]))\n-\t\t\t{\n-\t\t\t  /* Check each reg in the sequence.  */\n-\t\t\t  for (k = 0; k < group_size[class]; k++)\n-\t\t\t    if (! (spill_reg_order[j + k] < 0\n-\t\t\t\t   && ! TEST_HARD_REG_BIT (bad_spill_regs, j + k)\n-\t\t\t\t   && TEST_HARD_REG_BIT (reg_class_contents[class], j + k)))\n-\t\t\t      break;\n-\t\t\t  /* We got a full sequence, so spill them all.  */\n-\t\t\t  if (k == group_size[class])\n-\t\t\t    {\n-\t\t\t      register enum reg_class *p;\n-\t\t\t      for (k = 0; k < group_size[class]; k++)\n-\t\t\t\t{\n-\t\t\t\t  int idx;\n-\t\t\t\t  SET_HARD_REG_BIT (counted_for_groups, j + k);\n-\t\t\t\t  for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n-\t\t\t\t    if (potential_reload_regs[idx] == j + k)\n-\t\t\t\t      break;\n-\t\t\t\t  something_changed\n-\t\t\t\t    |= new_spill_reg (idx, class,\n-\t\t\t\t\t\t      max_needs, NULL_PTR,\n-\t\t\t\t\t\t      global, dumpfile);\n-\t\t\t\t}\n-\n-\t\t\t      /* We have found one that will complete a group,\n-\t\t\t\t so count off one group as provided.  */\n-\t\t\t      max_groups[class]--;\n-\t\t\t      p = reg_class_superclasses[class];\n-\t\t\t      while (*p != LIM_REG_CLASSES)\n-\t\t\t\t{\n-\t\t\t\t  if (group_size [(int) *p]\n-\t\t\t\t      <= group_size [class])\n-\t\t\t\t    max_groups[(int) *p]--;\n-\t\t\t\t  p++;\n-\t\t\t\t}\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t  /* We couldn't find any registers for this reload.\n-\t\t     Avoid going into an infinite loop.  */\n-\t\t  if (i >= FIRST_PSEUDO_REGISTER)\n-\t\t    {\n-\t\t      /* There are no groups left.  */\n-\t\t      spill_failure (max_groups_insn[class]);\n-\t\t      failure = 1;\n-\t\t      goto failed;\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  /* Now similarly satisfy all need for single registers.  */\n-\n-\t  while (max_needs[class] > 0 || max_nongroups[class] > 0)\n-\t    {\n-\t      /* If we spilled enough regs, but they weren't counted\n-\t\t against the non-group need, see if we can count them now.\n-\t\t If so, we can avoid some actual spilling.  */\n-\t      if (max_needs[class] <= 0 && max_nongroups[class] > 0)\n-\t\tfor (i = 0; i < n_spills; i++)\n-\t\t  if (TEST_HARD_REG_BIT (reg_class_contents[class],\n-\t\t\t\t\t spill_regs[i])\n-\t\t      && !TEST_HARD_REG_BIT (counted_for_groups,\n-\t\t\t\t\t     spill_regs[i])\n-\t\t      && !TEST_HARD_REG_BIT (counted_for_nongroups,\n-\t\t\t\t\t     spill_regs[i])\n-\t\t      && max_nongroups[class] > 0)\n-\t\t    {\n-\t\t      register enum reg_class *p;\n-\n-\t\t      SET_HARD_REG_BIT (counted_for_nongroups, spill_regs[i]);\n-\t\t      max_nongroups[class]--;\n-\t\t      p = reg_class_superclasses[class];\n-\t\t      while (*p != LIM_REG_CLASSES)\n-\t\t\tmax_nongroups[(int) *p++]--;\n-\t\t    }\n-\t      if (max_needs[class] <= 0 && max_nongroups[class] <= 0)\n-\t\tbreak;\n-\n-\t      /* Consider the potential reload regs that aren't\n-\t\t yet in use as reload regs, in order of preference.\n-\t\t Find the most preferred one that's in this class.  */\n-\n-\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\tif (potential_reload_regs[i] >= 0\n-\t\t    && TEST_HARD_REG_BIT (reg_class_contents[class],\n-\t\t\t\t\t  potential_reload_regs[i])\n-\t\t    /* If this reg will not be available for groups,\n-\t\t       pick one that does not foreclose possible groups.\n-\t\t       This is a kludge, and not very general,\n-\t\t       but it should be sufficient to make the 386 work,\n-\t\t       and the problem should not occur on machines with\n-\t\t       more registers.  */\n-\t\t    && (max_nongroups[class] == 0\n-\t\t\t|| possible_group_p (potential_reload_regs[i], max_groups)))\n-\t\t  break;\n-\n-\t      /* If we couldn't get a register, try to get one even if we\n-\t\t might foreclose possible groups.  This may cause problems\n-\t\t later, but that's better than aborting now, since it is\n-\t\t possible that we will, in fact, be able to form the needed\n-\t\t group even with this allocation.  */\n-\n-\t      if (i >= FIRST_PSEUDO_REGISTER\n-\t\t  && (asm_noperands (max_needs[class] > 0\n-\t\t\t\t     ? max_needs_insn[class]\n-\t\t\t\t     : max_nongroups_insn[class])\n-\t\t      < 0))\n-\t\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t  if (potential_reload_regs[i] >= 0\n-\t\t      && TEST_HARD_REG_BIT (reg_class_contents[class],\n-\t\t\t\t\t    potential_reload_regs[i]))\n-\t\t    break;\n-\n-\t      /* I should be the index in potential_reload_regs\n-\t\t of the new reload reg we have found.  */\n-\n-\t      if (i >= FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  /* There are no possible registers left to spill.  */\n-\t\t  spill_failure (max_needs[class] > 0 ? max_needs_insn[class]\n-\t\t\t\t : max_nongroups_insn[class]);\n-\t\t  failure = 1;\n-\t\t  goto failed;\n-\t\t}\n-\t      else\n-\t\tsomething_changed\n-\t\t  |= new_spill_reg (i, class, max_needs, max_nongroups,\n-\t\t\t\t    global, dumpfile);\n-\t    }\n-\t}\n+      something_changed |= find_reload_regs (global, dumpfile);\n+      if (failure)\n+\tgoto failed;\n     }\n \n   /* If global-alloc was run, notify it of any register eliminations we have\n@@ -2195,6 +1404,863 @@ reload (first, global, dumpfile)\n \n   return failure;\n }\n+\n+/* Walk the insns of the current function, starting with FIRST, and collect\n+   information about the need to do register elimination and the need to\n+   perform reloads.  */\n+static int\n+calculate_needs_all_insns (first, global)\n+     rtx first;\n+     int global;\n+{\n+  rtx insn;\n+  int something_changed = 0;\n+  rtx after_call = 0;\n+  /* Keep track of which basic blocks are needing the reloads.  */\n+  int this_block = 0;\n+\n+  /* Compute the most additional registers needed by any instruction.\n+     Collect information separately for each class of regs.  */\n+\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (global && this_block + 1 < n_basic_blocks\n+\t  && insn == basic_block_head[this_block+1])\n+\t++this_block;\n+\n+      /* If this is a label, a JUMP_INSN, or has REG_NOTES (which\n+\t might include REG_LABEL), we need to see what effects this\n+\t has on the known offsets at labels.  */\n+\n+      if (GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == JUMP_INSN\n+\t  || (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t      && REG_NOTES (insn) != 0))\n+\tset_label_offsets (insn, insn, 0);\n+\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t{\n+\t  rtx old_body = PATTERN (insn);\n+\t  int old_code = INSN_CODE (insn);\n+\t  rtx old_notes = REG_NOTES (insn);\n+\t  int did_elimination = 0;\n+\n+\t  /* Nonzero means don't use a reload reg that overlaps\n+\t     the place where a function value can be returned.  */\n+\t  rtx avoid_return_reg = 0;\n+\n+\t  /* Set avoid_return_reg if this is an insn\n+\t     that might use the value of a function call.  */\n+\t  if (SMALL_REGISTER_CLASSES && GET_CODE (insn) == CALL_INSN)\n+\t    {\n+\t      if (GET_CODE (PATTERN (insn)) == SET)\n+\t\tafter_call = SET_DEST (PATTERN (insn));\n+\t      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t\t       && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n+\t\tafter_call = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n+\t      else\n+\t\tafter_call = 0;\n+\t    }\n+\t  else if (SMALL_REGISTER_CLASSES && after_call != 0\n+\t\t   && !(GET_CODE (PATTERN (insn)) == SET\n+\t\t\t&& SET_DEST (PATTERN (insn)) == stack_pointer_rtx)\n+\t\t   && GET_CODE (PATTERN (insn)) != USE)\n+\t    {\n+\t      if (reg_referenced_p (after_call, PATTERN (insn)))\n+\t\tavoid_return_reg = after_call;\n+\t      after_call = 0;\n+\t    }\n+\n+\t  /* If needed, eliminate any eliminable registers.  */\n+\t  if (num_eliminable)\n+\t    did_elimination = eliminate_regs_in_insn (insn, 0);\n+\n+\t  /* Analyze the instruction.  */\n+\t  find_reloads (insn, 0, spill_indirect_levels, global,\n+\t\t\tspill_reg_order);\n+\n+\t  /* Remember for later shortcuts which insns had any reloads or\n+\t     register eliminations.\n+\n+\t     One might think that it would be worthwhile to mark insns\n+\t     that need register replacements but not reloads, but this is\n+\t     not safe because find_reloads may do some manipulation of\n+\t     the insn (such as swapping commutative operands), which would\n+\t     be lost when we restore the old pattern after register\n+\t     replacement.  So the actions of find_reloads must be redone in\n+\t     subsequent passes or in reload_as_needed.\n+\n+\t     However, it is safe to mark insns that need reloads\n+\t     but not register replacement.  */\n+\n+\t  PUT_MODE (insn, (did_elimination ? QImode\n+\t\t\t   : n_reloads ? HImode\n+\t\t\t   : GET_MODE (insn) == DImode ? DImode\n+\t\t\t   : VOIDmode));\n+\n+\t  /* Discard any register replacements done.  */\n+\t  if (did_elimination)\n+\t    {\n+\t      obstack_free (&reload_obstack, reload_firstobj);\n+\t      PATTERN (insn) = old_body;\n+\t      INSN_CODE (insn) = old_code;\n+\t      REG_NOTES (insn) = old_notes;\n+\t      something_needs_elimination = 1;\n+\t    }\n+\n+\t  /* If this insn has no reloads, we need not do anything except\n+\t     in the case of a CALL_INSN when we have caller-saves and\n+\t     caller-save needs reloads.  */\n+\n+\t  if (n_reloads != 0\n+\t      || (GET_CODE (insn) == CALL_INSN\n+\t\t  && caller_save_spill_class != NO_REGS))\n+\t    something_changed |= calculate_needs (this_block, insn,\n+\t\t\t\t\t\t  avoid_return_reg, global);\n+\t}\n+\n+      /* Note that there is a continue statement above.  */\n+    }\n+  return something_changed;\n+}\n+\n+/* To compute the number of reload registers of each class \n+   needed for an insn, we must simulate what choose_reload_regs\n+   can do.  We do this by splitting an insn into an \"input\" and\n+   an \"output\" part.  RELOAD_OTHER reloads are used in both. \n+   The input part uses those reloads, RELOAD_FOR_INPUT reloads,\n+   which must be live over the entire input section of reloads,\n+   and the maximum of all the RELOAD_FOR_INPUT_ADDRESS and\n+   RELOAD_FOR_OPERAND_ADDRESS reloads, which conflict with the\n+   inputs.\n+\n+   The registers needed for output are RELOAD_OTHER and\n+   RELOAD_FOR_OUTPUT, which are live for the entire output\n+   portion, and the maximum of all the RELOAD_FOR_OUTPUT_ADDRESS\n+   reloads for each operand.\n+\n+   The total number of registers needed is the maximum of the\n+   inputs and outputs.  */\n+\n+static int\n+calculate_needs (this_block, insn, avoid_return_reg, global)\n+     int this_block;\n+     rtx insn, avoid_return_reg;\n+     int global;\n+{\n+  int something_changed = 0;\n+  int i;\n+\n+  struct needs\n+  {\n+    /* [0] is normal, [1] is nongroup.  */\n+    int regs[2][N_REG_CLASSES];\n+    int groups[N_REG_CLASSES];\n+  };\n+\n+  /* Each `struct needs' corresponds to one RELOAD_... type.  */\n+  struct {\n+    struct needs other;\n+    struct needs input;\n+    struct needs output;\n+    struct needs insn;\n+    struct needs other_addr;\n+    struct needs op_addr;\n+    struct needs op_addr_reload;\n+    struct needs in_addr[MAX_RECOG_OPERANDS];\n+    struct needs in_addr_addr[MAX_RECOG_OPERANDS];\n+    struct needs out_addr[MAX_RECOG_OPERANDS];\n+    struct needs out_addr_addr[MAX_RECOG_OPERANDS];\n+  } insn_needs;\n+\n+  something_needs_reloads = 1;\n+  bzero ((char *) &insn_needs, sizeof insn_needs);\n+\n+  /* Count each reload once in every class\n+     containing the reload's own class.  */\n+\n+  for (i = 0; i < n_reloads; i++)\n+    {\n+      register enum reg_class *p;\n+      enum reg_class class = reload_reg_class[i];\n+      int size;\n+      enum machine_mode mode;\n+      struct needs *this_needs;\n+\n+      /* Don't count the dummy reloads, for which one of the\n+\t regs mentioned in the insn can be used for reloading.\n+\t Don't count optional reloads.\n+\t Don't count reloads that got combined with others.  */\n+      if (reload_reg_rtx[i] != 0\n+\t  || reload_optional[i] != 0\n+\t  || (reload_out[i] == 0 && reload_in[i] == 0\n+\t      && ! reload_secondary_p[i]))\n+\tcontinue;\n+\n+      /* Show that a reload register of this class is needed\n+\t in this basic block.  We do not use insn_needs and\n+\t insn_groups because they are overly conservative for\n+\t this purpose.  */\n+      if (global && ! basic_block_needs[(int) class][this_block])\n+\t{\n+\t  basic_block_needs[(int) class][this_block] = 1;\n+\t  something_changed = 1;\n+\t}\n+\n+      mode = reload_inmode[i];\n+      if (GET_MODE_SIZE (reload_outmode[i]) > GET_MODE_SIZE (mode))\n+\tmode = reload_outmode[i];\n+      size = CLASS_MAX_NREGS (class, mode);\n+\n+      /* Decide which time-of-use to count this reload for.  */\n+      switch (reload_when_needed[i])\n+\t{\n+\tcase RELOAD_OTHER:\n+\t  this_needs = &insn_needs.other;\n+\t  break;\n+\tcase RELOAD_FOR_INPUT:\n+\t  this_needs = &insn_needs.input;\n+\t  break;\n+\tcase RELOAD_FOR_OUTPUT:\n+\t  this_needs = &insn_needs.output;\n+\t  break;\n+\tcase RELOAD_FOR_INSN:\n+\t  this_needs = &insn_needs.insn;\n+\t  break;\n+\tcase RELOAD_FOR_OTHER_ADDRESS:\n+\t  this_needs = &insn_needs.other_addr;\n+\t  break;\n+\tcase RELOAD_FOR_INPUT_ADDRESS:\n+\t  this_needs = &insn_needs.in_addr[reload_opnum[i]];\n+\t  break;\n+\tcase RELOAD_FOR_INPADDR_ADDRESS:\n+\t  this_needs = &insn_needs.in_addr_addr[reload_opnum[i]];\n+\t  break;\n+\tcase RELOAD_FOR_OUTPUT_ADDRESS:\n+\t  this_needs = &insn_needs.out_addr[reload_opnum[i]];\n+\t  break;\n+\tcase RELOAD_FOR_OUTADDR_ADDRESS:\n+\t  this_needs = &insn_needs.out_addr_addr[reload_opnum[i]];\n+\t  break;\n+\tcase RELOAD_FOR_OPERAND_ADDRESS:\n+\t  this_needs = &insn_needs.op_addr;\n+\t  break;\n+\tcase RELOAD_FOR_OPADDR_ADDR:\n+\t  this_needs = &insn_needs.op_addr_reload;\n+\t  break;\n+\t}\n+\n+      if (size > 1)\n+\t{\n+\t  enum machine_mode other_mode, allocate_mode;\n+\n+\t  /* Count number of groups needed separately from\n+\t     number of individual regs needed.  */\n+\t  this_needs->groups[(int) class]++;\n+\t  p = reg_class_superclasses[(int) class];\n+\t  while (*p != LIM_REG_CLASSES)\n+\t    this_needs->groups[(int) *p++]++;\n+\n+\t  /* Record size and mode of a group of this class.  */\n+\t  /* If more than one size group is needed,\n+\t     make all groups the largest needed size.  */\n+\t  if (group_size[(int) class] < size)\n+\t    {\n+\t      other_mode = group_mode[(int) class];\n+\t      allocate_mode = mode;\n+\n+\t      group_size[(int) class] = size;\n+\t      group_mode[(int) class] = mode;\n+\t    }\n+\t  else\n+\t    {\n+\t      other_mode = mode;\n+\t      allocate_mode = group_mode[(int) class];\n+\t    }\n+\n+\t  /* Crash if two dissimilar machine modes both need\n+\t     groups of consecutive regs of the same class.  */\n+\n+\t  if (other_mode != VOIDmode && other_mode != allocate_mode\n+\t      && ! modes_equiv_for_class_p (allocate_mode,\n+\t\t\t\t\t    other_mode, class))\n+\t    fatal_insn (\"Two dissimilar machine modes both need groups of consecutive regs of the same class\",\n+\t\t\tinsn);\n+\t}\n+      else if (size == 1)\n+\t{\n+\t  this_needs->regs[reload_nongroup[i]][(int) class] += 1;\n+\t  p = reg_class_superclasses[(int) class];\n+\t  while (*p != LIM_REG_CLASSES)\n+\t    this_needs->regs[reload_nongroup[i]][(int) *p++] += 1;\n+\t}\n+      else\n+\tabort ();\n+    }\n+\n+  /* All reloads have been counted for this insn;\n+     now merge the various times of use.\n+     This sets insn_needs, etc., to the maximum total number\n+     of registers needed at any point in this insn.  */\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    {\n+      int j, in_max, out_max;\n+\n+      /* Compute normal and nongroup needs.  */\n+      for (j = 0; j <= 1; j++)\n+\t{\n+\t  int k;\n+\t  for (in_max = 0, out_max = 0, k = 0; k < reload_n_operands; k++)\n+\t    {\n+\t      in_max = MAX (in_max,\n+\t\t\t    (insn_needs.in_addr[k].regs[j][i]\n+\t\t\t     + insn_needs.in_addr_addr[k].regs[j][i]));\n+\t      out_max = MAX (out_max, insn_needs.out_addr[k].regs[j][i]);\n+\t      out_max = MAX (out_max,\n+\t\t\t     insn_needs.out_addr_addr[k].regs[j][i]);\n+\t    }\n+\n+\t  /* RELOAD_FOR_INSN reloads conflict with inputs, outputs,\n+\t     and operand addresses but not things used to reload\n+\t     them.  Similarly, RELOAD_FOR_OPERAND_ADDRESS reloads\n+\t     don't conflict with things needed to reload inputs or\n+\t     outputs.  */\n+\n+\t  in_max = MAX (MAX (insn_needs.op_addr.regs[j][i],\n+\t\t\t     insn_needs.op_addr_reload.regs[j][i]),\n+\t\t\tin_max);\n+\n+\t  out_max = MAX (out_max, insn_needs.insn.regs[j][i]);\n+\n+\t  insn_needs.input.regs[j][i]\n+\t    = MAX (insn_needs.input.regs[j][i]\n+\t\t   + insn_needs.op_addr.regs[j][i]\n+\t\t   + insn_needs.insn.regs[j][i],\n+\t\t   in_max + insn_needs.input.regs[j][i]);\n+\n+\t  insn_needs.output.regs[j][i] += out_max;\n+\t  insn_needs.other.regs[j][i]\n+\t    += MAX (MAX (insn_needs.input.regs[j][i],\n+\t\t\t insn_needs.output.regs[j][i]),\n+\t\t    insn_needs.other_addr.regs[j][i]);\n+\n+\t}\n+\n+      /* Now compute group needs.  */\n+      for (in_max = 0, out_max = 0, j = 0; j < reload_n_operands; j++)\n+\t{\n+\t  in_max = MAX (in_max, insn_needs.in_addr[j].groups[i]);\n+\t  in_max = MAX (in_max, insn_needs.in_addr_addr[j].groups[i]);\n+\t  out_max = MAX (out_max, insn_needs.out_addr[j].groups[i]);\n+\t  out_max = MAX (out_max, insn_needs.out_addr_addr[j].groups[i]);\n+\t}\n+\n+      in_max = MAX (MAX (insn_needs.op_addr.groups[i],\n+\t\t\t insn_needs.op_addr_reload.groups[i]),\n+\t\t    in_max);\n+      out_max = MAX (out_max, insn_needs.insn.groups[i]);\n+\n+      insn_needs.input.groups[i]\n+\t= MAX (insn_needs.input.groups[i]\n+\t       + insn_needs.op_addr.groups[i]\n+\t       + insn_needs.insn.groups[i],\n+\t       in_max + insn_needs.input.groups[i]);\n+\n+      insn_needs.output.groups[i] += out_max;\n+      insn_needs.other.groups[i]\n+\t+= MAX (MAX (insn_needs.input.groups[i],\n+\t\t     insn_needs.output.groups[i]),\n+\t\tinsn_needs.other_addr.groups[i]);\n+    }\n+\n+  /* If this is a CALL_INSN and caller-saves will need\n+     a spill register, act as if the spill register is\n+     needed for this insn.   However, the spill register\n+     can be used by any reload of this insn, so we only\n+     need do something if no need for that class has\n+     been recorded.\n+\n+     The assumption that every CALL_INSN will trigger a\n+     caller-save is highly conservative, however, the number\n+     of cases where caller-saves will need a spill register but\n+     a block containing a CALL_INSN won't need a spill register\n+     of that class should be quite rare.\n+\n+     If a group is needed, the size and mode of the group will\n+     have been set up at the beginning of this loop.  */\n+\n+  if (GET_CODE (insn) == CALL_INSN\n+      && caller_save_spill_class != NO_REGS)\n+    {\n+      int j;\n+      /* See if this register would conflict with any reload that\n+\t needs a group or any reload that needs a nongroup.  */\n+      int nongroup_need = 0;\n+      int *caller_save_needs;\n+\n+      for (j = 0; j < n_reloads; j++)\n+\tif (reg_classes_intersect_p (caller_save_spill_class,\n+\t\t\t\t     reload_reg_class[j])\n+\t    && ((CLASS_MAX_NREGS\n+\t\t (reload_reg_class[j],\n+\t\t  (GET_MODE_SIZE (reload_outmode[j])\n+\t\t   > GET_MODE_SIZE (reload_inmode[j]))\n+\t\t  ? reload_outmode[j] : reload_inmode[j])\n+\t\t > 1)\n+\t\t|| reload_nongroup[j]))\n+\t  {\n+\t    nongroup_need = 1;\n+\t    break;\n+\t  }\n+\n+      caller_save_needs \n+\t= (caller_save_group_size > 1\n+\t   ? insn_needs.other.groups\n+\t   : insn_needs.other.regs[nongroup_need]); \n+\n+      if (caller_save_needs[(int) caller_save_spill_class] == 0)\n+\t{\n+\t  register enum reg_class *p\n+\t    = reg_class_superclasses[(int) caller_save_spill_class];\n+\n+\t  caller_save_needs[(int) caller_save_spill_class]++;\n+\n+\t  while (*p != LIM_REG_CLASSES)\n+\t    caller_save_needs[(int) *p++] += 1;\n+\t}\n+\n+      /* Show that this basic block will need a register of\n+\t this class.  */\n+\n+      if (global\n+\t  && ! (basic_block_needs[(int) caller_save_spill_class]\n+\t\t[this_block]))\n+\t{\n+\t  basic_block_needs[(int) caller_save_spill_class]\n+\t    [this_block] = 1;\n+\t  something_changed = 1;\n+\t}\n+    }\n+\n+  /* If this insn stores the value of a function call,\n+     and that value is in a register that has been spilled,\n+     and if the insn needs a reload in a class\n+     that might use that register as the reload register,\n+     then add an extra need in that class.\n+     This makes sure we have a register available that does\n+     not overlap the return value.  */\n+\n+  if (SMALL_REGISTER_CLASSES && avoid_return_reg)\n+    {\n+      int regno = REGNO (avoid_return_reg);\n+      int nregs\n+\t= HARD_REGNO_NREGS (regno, GET_MODE (avoid_return_reg));\n+      int r;\n+      int basic_needs[N_REG_CLASSES], basic_groups[N_REG_CLASSES];\n+\n+      /* First compute the \"basic needs\", which counts a\n+\t need only in the smallest class in which it\n+\t is required.  */\n+\n+      bcopy ((char *) insn_needs.other.regs[0],\n+\t     (char *) basic_needs, sizeof basic_needs);\n+      bcopy ((char *) insn_needs.other.groups,\n+\t     (char *) basic_groups, sizeof basic_groups);\n+\n+      for (i = 0; i < N_REG_CLASSES; i++)\n+\t{\n+\t  enum reg_class *p;\n+\n+\t  if (basic_needs[i] >= 0)\n+\t    for (p = reg_class_superclasses[i];\n+\t\t *p != LIM_REG_CLASSES; p++)\n+\t      basic_needs[(int) *p] -= basic_needs[i];\n+\n+\t  if (basic_groups[i] >= 0)\n+\t    for (p = reg_class_superclasses[i];\n+\t\t *p != LIM_REG_CLASSES; p++)\n+\t      basic_groups[(int) *p] -= basic_groups[i];\n+\t}\n+\n+      /* Now count extra regs if there might be a conflict with\n+\t the return value register.  */\n+\n+      for (r = regno; r < regno + nregs; r++)\n+\tif (spill_reg_order[r] >= 0)\n+\t  for (i = 0; i < N_REG_CLASSES; i++)\n+\t    if (TEST_HARD_REG_BIT (reg_class_contents[i], r))\n+\t      {\n+\t\tif (basic_needs[i] > 0)\n+\t\t  {\n+\t\t    enum reg_class *p;\n+\n+\t\t    insn_needs.other.regs[0][i]++;\n+\t\t    p = reg_class_superclasses[i];\n+\t\t    while (*p != LIM_REG_CLASSES)\n+\t\t      insn_needs.other.regs[0][(int) *p++]++;\n+\t\t  }\n+\t\tif (basic_groups[i] > 0)\n+\t\t  {\n+\t\t    enum reg_class *p;\n+\n+\t\t    insn_needs.other.groups[i]++;\n+\t\t    p = reg_class_superclasses[i];\n+\t\t    while (*p != LIM_REG_CLASSES)\n+\t\t      insn_needs.other.groups[(int) *p++]++;\n+\t\t  }\n+\t      }\n+    }\n+\n+  /* For each class, collect maximum need of any insn.  */\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    {\n+      if (max_needs[i] < insn_needs.other.regs[0][i])\n+\t{\n+\t  max_needs[i] = insn_needs.other.regs[0][i];\n+\t  max_needs_insn[i] = insn;\n+\t}\n+      if (max_groups[i] < insn_needs.other.groups[i])\n+\t{\n+\t  max_groups[i] = insn_needs.other.groups[i];\n+\t  max_groups_insn[i] = insn;\n+\t}\n+      if (max_nongroups[i] < insn_needs.other.regs[1][i])\n+\t{\n+\t  max_nongroups[i] = insn_needs.other.regs[1][i];\n+\t  max_nongroups_insn[i] = insn;\n+\t}\n+    }\n+  return something_changed;\n+}\n+\n+/* Find a group of exactly 2 registers.\n+\n+   First try to fill out the group by spilling a single register which\n+   would allow completion of the group.\n+\n+   Then try to create a new group from a pair of registers, neither of\n+   which are explicitly used.\n+\n+   Then try to create a group from any pair of registers.  */\n+static int\n+find_tworeg_group (global, class, dumpfile)\n+     int global;\n+     int class;\n+     FILE *dumpfile;\n+{\n+  int i;\n+  /* First, look for a register that will complete a group.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      int j, other;\n+\n+      j = potential_reload_regs[i];\n+      if (j >= 0 && ! TEST_HARD_REG_BIT (bad_spill_regs, j)\n+\t  && ((j > 0 && (other = j - 1, spill_reg_order[other] >= 0)\n+\t       && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n+\t       && TEST_HARD_REG_BIT (reg_class_contents[class], other)\n+\t       && HARD_REGNO_MODE_OK (other, group_mode[class])\n+\t       && ! TEST_HARD_REG_BIT (counted_for_nongroups, other)\n+\t       /* We don't want one part of another group.\n+\t\t  We could get \"two groups\" that overlap!  */\n+\t       && ! TEST_HARD_REG_BIT (counted_for_groups, other))\n+\t      || (j < FIRST_PSEUDO_REGISTER - 1\n+\t\t  && (other = j + 1, spill_reg_order[other] >= 0)\n+\t\t  && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n+\t\t  && TEST_HARD_REG_BIT (reg_class_contents[class], other)\n+\t\t  && HARD_REGNO_MODE_OK (j, group_mode[class])\n+\t\t  && ! TEST_HARD_REG_BIT (counted_for_nongroups, other)\n+\t\t  && ! TEST_HARD_REG_BIT (counted_for_groups, other))))\n+\t{\n+\t  register enum reg_class *p;\n+\n+\t  /* We have found one that will complete a group,\n+\t     so count off one group as provided.  */\n+\t  max_groups[class]--;\n+\t  p = reg_class_superclasses[class];\n+\t  while (*p != LIM_REG_CLASSES)\n+\t    {\n+\t      if (group_size [(int) *p] <= group_size [class])\n+\t\tmax_groups[(int) *p]--;\n+\t      p++;\n+\t    }\n+\n+\t  /* Indicate both these regs are part of a group.  */\n+\t  SET_HARD_REG_BIT (counted_for_groups, j);\n+\t  SET_HARD_REG_BIT (counted_for_groups, other);\n+\t  break;\n+\t}\n+    }\n+  /* We can't complete a group, so start one.  */\n+  /* Look for a pair neither of which is explicitly used.  */\n+  if (SMALL_REGISTER_CLASSES && i == FIRST_PSEUDO_REGISTER)\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      {\n+\tint j, k;\n+\tj = potential_reload_regs[i];\n+\t/* Verify that J+1 is a potential reload reg.  */\n+\tfor (k = 0; k < FIRST_PSEUDO_REGISTER; k++)\n+\t  if (potential_reload_regs[k] == j + 1)\n+\t    break;\n+\tif (j >= 0 && j + 1 < FIRST_PSEUDO_REGISTER\n+\t    && k < FIRST_PSEUDO_REGISTER\n+\t    && spill_reg_order[j] < 0 && spill_reg_order[j + 1] < 0\n+\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n+\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j + 1)\n+\t    && HARD_REGNO_MODE_OK (j, group_mode[class])\n+\t    && ! TEST_HARD_REG_BIT (counted_for_nongroups,\n+\t\t\t\t    j + 1)\n+\t    && ! TEST_HARD_REG_BIT (bad_spill_regs, j + 1)\n+\t    /* Reject J at this stage\n+\t       if J+1 was explicitly used.  */\n+\t    && ! regs_explicitly_used[j + 1])\n+\t  break;\n+      }\n+  /* Now try any group at all\n+     whose registers are not in bad_spill_regs.  */\n+  if (i == FIRST_PSEUDO_REGISTER)\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      {\n+\tint j, k;\n+\tj = potential_reload_regs[i];\n+\t/* Verify that J+1 is a potential reload reg.  */\n+\tfor (k = 0; k < FIRST_PSEUDO_REGISTER; k++)\n+\t  if (potential_reload_regs[k] == j + 1)\n+\t    break;\n+\tif (j >= 0 && j + 1 < FIRST_PSEUDO_REGISTER\n+\t    && k < FIRST_PSEUDO_REGISTER\n+\t    && spill_reg_order[j] < 0 && spill_reg_order[j + 1] < 0\n+\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n+\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j + 1)\n+\t    && HARD_REGNO_MODE_OK (j, group_mode[class])\n+\t    && ! TEST_HARD_REG_BIT (counted_for_nongroups, j + 1)\n+\t    && ! TEST_HARD_REG_BIT (bad_spill_regs, j + 1))\n+\t  break;\n+      }\n+\n+  /* I should be the index in potential_reload_regs\n+     of the new reload reg we have found.  */\n+\n+  if (i < FIRST_PSEUDO_REGISTER)\n+    return new_spill_reg (i, class, max_needs, NULL_PTR,\n+\t\t\t  global, dumpfile);\n+\n+  /* There are no groups left to spill.  */\n+  spill_failure (max_groups_insn[class]);\n+  failure = 1;\n+  return 1;\n+}\n+\n+/* Find a group of more than 2 registers.\n+   Look for a sufficient sequence of unspilled registers, and spill them all\n+   at once.  */\n+static int\n+find_group (global, class, dumpfile)\n+     int global;\n+     int class;\n+     FILE *dumpfile;\n+{\n+  int something_changed = 0;\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      int j, k;\n+\n+      j = potential_reload_regs[i];\n+      if (j >= 0\n+\t  && j + group_size[class] <= FIRST_PSEUDO_REGISTER\n+\t  && HARD_REGNO_MODE_OK (j, group_mode[class]))\n+\t{\n+\t  /* Check each reg in the sequence.  */\n+\t  for (k = 0; k < group_size[class]; k++)\n+\t    if (! (spill_reg_order[j + k] < 0\n+\t\t   && ! TEST_HARD_REG_BIT (bad_spill_regs, j + k)\n+\t\t   && TEST_HARD_REG_BIT (reg_class_contents[class], j + k)))\n+\t      break;\n+\t  /* We got a full sequence, so spill them all.  */\n+\t  if (k == group_size[class])\n+\t    {\n+\t      register enum reg_class *p;\n+\t      for (k = 0; k < group_size[class]; k++)\n+\t\t{\n+\t\t  int idx;\n+\t\t  SET_HARD_REG_BIT (counted_for_groups, j + k);\n+\t\t  for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n+\t\t    if (potential_reload_regs[idx] == j + k)\n+\t\t      break;\n+\t\t  something_changed |= new_spill_reg (idx, class, max_needs,\n+\t\t\t\t\t\t      NULL_PTR, global,\n+\t\t\t\t\t\t      dumpfile);\n+\t\t}\n+\n+\t      /* We have found one that will complete a group,\n+\t\t so count off one group as provided.  */\n+\t      max_groups[class]--;\n+\t      p = reg_class_superclasses[class];\n+\t      while (*p != LIM_REG_CLASSES)\n+\t\t{\n+\t\t  if (group_size [(int) *p]\n+\t\t      <= group_size [class])\n+\t\t    max_groups[(int) *p]--;\n+\t\t  p++;\n+\t\t}\n+\t      return something_changed;\n+\t    }\n+\t}\n+    }\n+  /* There are no groups left.  */\n+  spill_failure (max_groups_insn[class]);\n+  failure = 1;\n+  return 1;\n+}\n+\n+/* Find more reload regs to satisfy the remaining need.\n+   Do it by ascending class number, since otherwise a reg\n+   might be spilled for a big class and might fail to count\n+   for a smaller class even though it belongs to that class.\n+\n+   Count spilled regs in `spills', and add entries to\n+   `spill_regs' and `spill_reg_order'.\n+\n+   ??? Note there is a problem here.\n+   When there is a need for a group in a high-numbered class,\n+   and also need for non-group regs that come from a lower class,\n+   the non-group regs are chosen first.  If there aren't many regs,\n+   they might leave no room for a group.\n+\n+   This was happening on the 386.  To fix it, we added the code\n+   that calls possible_group_p, so that the lower class won't\n+   break up the last possible group.\n+\n+   Really fixing the problem would require changes above\n+   in counting the regs already spilled, and in choose_reload_regs.\n+   It might be hard to avoid introducing bugs there.  */\n+\n+static int\n+find_reload_regs (global, dumpfile)\n+     int global;\n+     FILE *dumpfile;\n+{\n+  int class;\n+  int something_changed = 0;\n+\n+  CLEAR_HARD_REG_SET (counted_for_groups);\n+  CLEAR_HARD_REG_SET (counted_for_nongroups);\n+\n+  for (class = 0; class < N_REG_CLASSES; class++)\n+    {\n+      /* First get the groups of registers.\n+\t If we got single registers first, we might fragment\n+\t possible groups.  */\n+      while (max_groups[class] > 0)\n+\t{\n+\t  /* If any single spilled regs happen to form groups,\n+\t     count them now.  Maybe we don't really need\n+\t     to spill another group.  */\n+\t  count_possible_groups (group_size, group_mode, max_groups, class);\n+\n+\t  if (max_groups[class] <= 0)\n+\t    break;\n+\n+\t  /* Groups of size 2 (the only groups used on most machines)\n+\t     are treated specially.  */\n+\t  if (group_size[class] == 2)\n+\t    something_changed |= find_tworeg_group (global, class, dumpfile);\n+\t  else\n+\t    something_changed |= find_group (global, class, dumpfile);\n+\n+\t  if (failure)\n+\t    return 1;\n+\t}\n+\n+      /* Now similarly satisfy all need for single registers.  */\n+\n+      while (max_needs[class] > 0 || max_nongroups[class] > 0)\n+\t{\n+\t  int i;\n+\t  /* If we spilled enough regs, but they weren't counted\n+\t     against the non-group need, see if we can count them now.\n+\t     If so, we can avoid some actual spilling.  */\n+\t  if (max_needs[class] <= 0 && max_nongroups[class] > 0)\n+\t    for (i = 0; i < n_spills; i++)\n+\t      {\n+\t\tint regno = spill_regs[i];\n+\t\tif (TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n+\t\t    && !TEST_HARD_REG_BIT (counted_for_groups, regno)\n+\t\t    && !TEST_HARD_REG_BIT (counted_for_nongroups, regno)\n+\t\t    && max_nongroups[class] > 0)\n+\t\t{\n+\t\t  register enum reg_class *p;\n+\n+\t\t  SET_HARD_REG_BIT (counted_for_nongroups, regno);\n+\t\t  max_nongroups[class]--;\n+\t\t  p = reg_class_superclasses[class];\n+\t\t  while (*p != LIM_REG_CLASSES)\n+\t\t    max_nongroups[(int) *p++]--;\n+\t\t}\n+\t      }\n+\t  if (max_needs[class] <= 0 && max_nongroups[class] <= 0)\n+\t    break;\n+\n+\t  /* Consider the potential reload regs that aren't\n+\t     yet in use as reload regs, in order of preference.\n+\t     Find the most preferred one that's in this class.  */\n+\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    {\n+\t      int regno = potential_reload_regs[i];\n+\t      if (regno >= 0\n+\t\t  && TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n+\t\t  /* If this reg will not be available for groups,\n+\t\t     pick one that does not foreclose possible groups.\n+\t\t     This is a kludge, and not very general,\n+\t\t     but it should be sufficient to make the 386 work,\n+\t\t     and the problem should not occur on machines with\n+\t\t     more registers.  */\n+\t\t  && (max_nongroups[class] == 0\n+\t\t      || possible_group_p (regno, max_groups)))\n+\t\tbreak;\n+\t    }\n+\n+\t  /* If we couldn't get a register, try to get one even if we\n+\t     might foreclose possible groups.  This may cause problems\n+\t     later, but that's better than aborting now, since it is\n+\t     possible that we will, in fact, be able to form the needed\n+\t     group even with this allocation.  */\n+\n+\t  if (i >= FIRST_PSEUDO_REGISTER\n+\t      && (asm_noperands (max_needs[class] > 0\n+\t\t\t\t ? max_needs_insn[class]\n+\t\t\t\t : max_nongroups_insn[class])\n+\t\t  < 0))\n+\t    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t      if (potential_reload_regs[i] >= 0\n+\t\t  && TEST_HARD_REG_BIT (reg_class_contents[class],\n+\t\t\t\t\tpotential_reload_regs[i]))\n+\t\tbreak;\n+\n+\t  /* I should be the index in potential_reload_regs\n+\t     of the new reload reg we have found.  */\n+\n+\t  if (i >= FIRST_PSEUDO_REGISTER)\n+\t    {\n+\t      /* There are no possible registers left to spill.  */\n+\t      spill_failure (max_needs[class] > 0 ? max_needs_insn[class]\n+\t\t\t     : max_nongroups_insn[class]);\n+\t      failure = 1;\n+\t      return 1;\n+\t    }\n+\t  else\n+\t    something_changed |= new_spill_reg (i, class, max_needs,\n+\t\t\t\t\t\tmax_nongroups, global,\n+\t\t\t\t\t\tdumpfile);\n+\t}\n+    }\n+  return something_changed;\n+}\n+\n \f\n /* Nonzero if, after spilling reg REGNO for non-groups,\n    it will still be possible to find a group if we still need one.  */"}]}