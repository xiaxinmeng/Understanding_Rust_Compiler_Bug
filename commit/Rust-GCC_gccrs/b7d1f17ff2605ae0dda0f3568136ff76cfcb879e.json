{"sha": "b7d1f17ff2605ae0dda0f3568136ff76cfcb879e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdkMWYxN2ZmMjYwNWFlMGRkYTBmMzU2ODEzNmZmNzZjZmNiODc5ZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-06-06T10:43:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:43:57Z"}, "message": "sem_res.ads, [...] (Process_Allocator): Do not propagate the chain of coextensions when...\n\n2007-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_res.ads, sem_res.adb (Process_Allocator): Do not propagate the\n\tchain of coextensions when an allocator serves as the root of such a\n\tchain.\n\t(Propagate_Coextensions): Remove the test for the root being an\n\tallocator.\n\t(Resolve_Allocator): Add condition to ensure that all future decoration\n\toccurs on an allocator node. Add processing and cleanup for static\n\tcoextensions.\n\t(Valid_Conversion): If the operand type is the limited view of a\n\tclass-wide type, use the non-limited view is available to determine\n\tlegality of operation.\n\t(Ambiguous_Character): move to spec, for use elsewhere.\n\t(Ambiguous_Character): Handle Wide_Wide_Character in Ada 2005 mode\n\t(Resolve_Range): Diagnose properly an ambiguous range whose bounds are\n\tcharacter literals.\n\t(Resolve_Arithmetic_Op): Call Activate_Division_Check instead of setting\n\tDo_Division_Check flag explicitly.\n\t(Resolve_Actuals): If the actual is of a synchronized type, and the\n\tformal is of the corresponding record type, this is a call to a\n\tprimitive operation of the type, that is declared outside of the type;\n\tthe actual must be unchecked-converted to the type of the actual\n\t(Resolve_Call): Kill all current values for any subprogram call if\n\tflag Suppress_Value_Tracking_On_Call is set.\n\t(Resolve_Type_Conversion): Generate error message the the operand\n\tor target of interface conversions come from a limited view.\n\t(Check_Infinite_Recursion): Ignore generated calls\n\t(Check_Allocator_Discrim_Accessibility): New procedure for checking\n\tthat an expression that constrains an access discriminant in an\n\tallocator does not denote an object with a deeper level than the\n\tallocator's access type.\n\t(Resolve_Allocator): In the case of an allocator initialized by an\n\taggregate of a discriminated type, check that associations for any\n\taccess discriminants satisfy accessibility requirements by calling\n\tCheck_Allocator_Discrim_Accessibility.\n\t(Resolve_Equality_Op): Handle comparisons of anonymous access to\n\tsubprogram types in the same fashion as other anonymous access types.\n\t(Resolve_Concatenation_Arg): Remove initial character '\\' in an error\n\tmessage that is not a continuation message.\n\t(Resolve_Type_Conversion): Add missing support for conversion to\n\tinterface type.\n\t(Resolve_Actuals): Introduce a transient scope around the call if an\n\tactual is a call to a function returning a limited type, because the\n\tresulting value must be finalized after the call.\n\t(Resolve_Actuals): If the call was given in prefix notations, check\n\twhether an implicit 'Access reference or implicit dereference must be\n\tadded to make the actual conform to the controlling formal.\n\nFrom-SVN: r125451", "tree": {"sha": "5969ce2dcf28ba3090bd24c057c150a0bd6ca586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5969ce2dcf28ba3090bd24c057c150a0bd6ca586"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7d1f17ff2605ae0dda0f3568136ff76cfcb879e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d1f17ff2605ae0dda0f3568136ff76cfcb879e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d1f17ff2605ae0dda0f3568136ff76cfcb879e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d1f17ff2605ae0dda0f3568136ff76cfcb879e/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27c489df7577f8ab076d3111e226582779531a91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c489df7577f8ab076d3111e226582779531a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27c489df7577f8ab076d3111e226582779531a91"}], "stats": {"total": 924, "additions": 702, "deletions": 222}, "files": [{"sha": "a2b8b23ca5d26cabb651560f3073bc87fdd70082", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 694, "deletions": 221, "changes": 915, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d1f17ff2605ae0dda0f3568136ff76cfcb879e/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d1f17ff2605ae0dda0f3568136ff76cfcb879e/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=b7d1f17ff2605ae0dda0f3568136ff76cfcb879e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,6 +29,7 @@ with Checks;   use Checks;\n with Debug;    use Debug;\n with Debug_A;  use Debug_A;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Errout;   use Errout;\n with Expander; use Expander;\n with Exp_Disp; use Exp_Disp;\n@@ -67,6 +68,7 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n@@ -86,10 +88,6 @@ package body Sem_Res is\n \n    --  Note that Resolve_Attribute is separated off in Sem_Attr\n \n-   procedure Ambiguous_Character (C : Node_Id);\n-   --  Give list of candidate interpretations when a character literal cannot\n-   --  be resolved.\n-\n    procedure Check_Discriminant_Use (N : Node_Id);\n    --  Enforce the restrictions on the use of discriminants when constraining\n    --  a component of a discriminated type (record or concurrent type).\n@@ -245,8 +243,22 @@ package body Sem_Res is\n    begin\n       if Nkind (C) = N_Character_Literal then\n          Error_Msg_N (\"ambiguous character literal\", C);\n+\n+         --  First the ones in Standard\n+\n          Error_Msg_N\n-           (\"\\\\possible interpretations: Character, Wide_Character!\", C);\n+           (\"\\\\possible interpretation: Character!\", C);\n+         Error_Msg_N\n+           (\"\\\\possible interpretation: Wide_Character!\", C);\n+\n+         --  Include Wide_Wide_Character in Ada 2005 mode\n+\n+         if Ada_Version >= Ada_05 then\n+            Error_Msg_N\n+              (\"\\\\possible interpretation: Wide_Wide_Character!\", C);\n+         end if;\n+\n+         --  Now any other types that match\n \n          E := Current_Entity (C);\n          while Present (E) loop\n@@ -1679,6 +1691,7 @@ package body Sem_Res is\n                      Old_Id  => Designated_Type\n                        (Corresponding_Remote_Type (Typ)),\n                      Err_Loc => N);\n+\n                   if Is_Remote then\n                      Process_Remote_AST_Attribute (N, Typ);\n                   end if;\n@@ -2462,6 +2475,13 @@ package body Sem_Res is\n       F_Typ  : Entity_Id;\n       Prev   : Node_Id := Empty;\n \n+      procedure Check_Prefixed_Call;\n+      --  If the original node is an overloaded call in prefix notation,\n+      --  insert an 'Access or a dereference as needed over the first actual.\n+      --  Try_Object_Operation has already verified that there is a valid\n+      --  interpretation, but the form of the actual can only be determined\n+      --  once the primitive operation is identified.\n+\n       procedure Insert_Default;\n       --  If the actual is missing in a call, insert in the actuals list\n       --  an instance of the default expression. The insertion is always\n@@ -2472,6 +2492,62 @@ package body Sem_Res is\n       --  common type. Used to enforce the restrictions on array conversions\n       --  of AI95-00246.\n \n+      -------------------------\n+      -- Check_Prefixed_Call --\n+      -------------------------\n+\n+      procedure Check_Prefixed_Call is\n+         Act    : constant Node_Id   := First_Actual (N);\n+         A_Type : constant Entity_Id := Etype (Act);\n+         F_Type : constant Entity_Id := Etype (First_Formal (Nam));\n+         Orig   : constant Node_Id := Original_Node (N);\n+         New_A  : Node_Id;\n+\n+      begin\n+         --  Check whether the call is a prefixed call, with or without\n+         --  additional actuals.\n+\n+         if Nkind (Orig) = N_Selected_Component\n+           or else\n+             (Nkind (Orig) = N_Indexed_Component\n+               and then Nkind (Prefix (Orig)) = N_Selected_Component\n+               and then Is_Entity_Name (Prefix (Prefix (Orig)))\n+               and then Is_Entity_Name (Act)\n+               and then Chars (Act) = Chars (Prefix (Prefix (Orig))))\n+         then\n+            if Is_Access_Type (A_Type)\n+              and then not Is_Access_Type (F_Type)\n+            then\n+               --  Introduce dereference on object in prefix\n+\n+               New_A :=\n+                 Make_Explicit_Dereference (Sloc (Act),\n+                   Prefix => Relocate_Node (Act));\n+               Rewrite (Act, New_A);\n+               Analyze (Act);\n+\n+            elsif Is_Access_Type (F_Type)\n+              and then not Is_Access_Type (A_Type)\n+            then\n+               --  Introduce an implicit 'Access in prefix\n+\n+               if not Is_Aliased_View (Act) then\n+                  Error_Msg_NE\n+                    (\"object in prefixed call to& must be aliased\"\n+                         & \" ('R'M'-2005 4.3.1 (13))\",\n+                    Prefix (Act), Nam);\n+               end if;\n+\n+               Rewrite (Act,\n+                 Make_Attribute_Reference (Loc,\n+                   Attribute_Name => Name_Access,\n+                   Prefix         => Relocate_Node (Act)));\n+            end if;\n+\n+            Analyze (Act);\n+         end if;\n+      end Check_Prefixed_Call;\n+\n       --------------------\n       -- Insert_Default --\n       --------------------\n@@ -2493,8 +2569,11 @@ package body Sem_Res is\n             --  formal may be out of bounds of the corresponding actual (see\n             --  cc1311b) and an additional check may be required.\n \n-            Actval := New_Copy_Tree (Default_Value (F),\n-                        New_Scope => Current_Scope, New_Sloc => Loc);\n+            Actval :=\n+              New_Copy_Tree\n+                (Default_Value (F),\n+                 New_Scope => Current_Scope,\n+                 New_Sloc  => Loc);\n \n             if Is_Concurrent_Type (Scope (Nam))\n               and then Has_Discriminants (Scope (Nam))\n@@ -2649,6 +2728,10 @@ package body Sem_Res is\n    --  Start of processing for Resolve_Actuals\n \n    begin\n+      if Present (First_Actual (N)) then\n+         Check_Prefixed_Call;\n+      end if;\n+\n       A := First_Actual (N);\n       F := First_Formal (Nam);\n       while Present (F) loop\n@@ -2730,6 +2813,20 @@ package body Sem_Res is\n                   Resolve (Expression (A));\n                end if;\n \n+            --  If the actual is a function call that returns a limited\n+            --  unconstrained object that needs finalization, create a\n+            --  transient scope for it, so that it can receive the proper\n+            --  finalization list.\n+\n+            elsif Nkind (A) = N_Function_Call\n+              and then Is_Limited_Record (Etype (F))\n+              and then not Is_Constrained (Etype (F))\n+              and then Expander_Active\n+              and then\n+                (Is_Controlled (Etype (F)) or else Has_Task (Etype (F)))\n+            then\n+               Establish_Transient_Scope (A, False);\n+\n             else\n                if Nkind (A) = N_Type_Conversion\n                  and then Is_Array_Type (Etype (F))\n@@ -2778,16 +2875,32 @@ package body Sem_Res is\n \n                      --  Ada 2005, AI-162:If the actual is an allocator, the\n                      --  innermost enclosing statement is the master of the\n-                     --  created object.\n+                     --  created object. This needs to be done with expansion\n+                     --  enabled only, otherwise the transient scope will not\n+                     --  be removed in the expansion of the wrapped construct.\n \n-                     if Is_Controlled (DDT)\n-                       or else Has_Task (DDT)\n+                     if (Is_Controlled (DDT)\n+                          or else Has_Task (DDT))\n+                       and then Expander_Active\n                      then\n                         Establish_Transient_Scope (A, False);\n                      end if;\n                   end;\n                end if;\n \n+               --  (Ada 2005): The call may be to a primitive operation of\n+               --   a tagged synchronized type, declared outside of the type.\n+               --   In this case the controlling actual must be converted to\n+               --   its corresponding record type, which is the formal type.\n+\n+               if Is_Concurrent_Type (Etype (A))\n+                 and then Etype (F) = Corresponding_Record_Type (Etype (A))\n+               then\n+                  Rewrite (A,\n+                    Unchecked_Convert_To\n+                      (Corresponding_Record_Type (Etype (A)), A));\n+               end if;\n+\n                Resolve (A, Etype (F));\n             end if;\n \n@@ -3072,27 +3185,247 @@ package body Sem_Res is\n       Subtyp   : Entity_Id;\n       Discrim  : Entity_Id;\n       Constr   : Node_Id;\n+      Aggr     : Node_Id;\n+      Assoc    : Node_Id := Empty;\n       Disc_Exp : Node_Id;\n \n+      procedure Check_Allocator_Discrim_Accessibility\n+        (Disc_Exp  : Node_Id;\n+         Alloc_Typ : Entity_Id);\n+      --  Check that accessibility level associated with an access discriminant\n+      --  initialized in an allocator by the expression Disc_Exp is not deeper\n+      --  than the level of the allocator type Alloc_Typ. An error message is\n+      --  issued if this condition is violated. Specialized checks are done for\n+      --  the cases of a constraint expression which is an access attribute or\n+      --  an access discriminant.\n+\n       function In_Dispatching_Context return Boolean;\n-      --  If the allocator is an actual in a call, it is allowed to be\n-      --  class-wide when the context is not because it is a controlling\n-      --  actual.\n+      --  If the allocator is an actual in a call, it is allowed to be class-\n+      --  wide when the context is not because it is a controlling actual.\n+\n+      procedure Propagate_Coextensions (Root : Node_Id);\n+      --  Propagate all nested coextensions which are located one nesting\n+      --  level down the tree to the node Root. Example:\n+      --\n+      --    Top_Record\n+      --       Level_1_Coextension\n+      --          Level_2_Coextension\n+      --\n+      --  The algorithm is paired with delay actions done by the Expander. In\n+      --  the above example, assume all coextensions are controlled types.\n+      --  The cycle of analysis, resolution and expansion will yield:\n+      --\n+      --  1) Analyze Top_Record\n+      --  2) Analyze Level_1_Coextension\n+      --  3) Analyze Level_2_Coextension\n+      --  4) Resolve Level_2_Coextnesion. The allocator is marked as a\n+      --       coextension.\n+      --  5) Expand Level_2_Coextension. A temporary variable Temp_1 is\n+      --       generated to capture the allocated object. Temp_1 is attached\n+      --       to the coextension chain of Level_2_Coextension.\n+      --  6) Resolve Level_1_Coextension. The allocator is marked as a\n+      --       coextension. A forward tree traversal is performed which finds\n+      --       Level_2_Coextension's list and copies its contents into its\n+      --       own list.\n+      --  7) Expand Level_1_Coextension. A temporary variable Temp_2 is\n+      --       generated to capture the allocated object. Temp_2 is attached\n+      --       to the coextension chain of Level_1_Coextension. Currently, the\n+      --       contents of the list are [Temp_2, Temp_1].\n+      --  8) Resolve Top_Record. A forward tree traversal is performed which\n+      --       finds Level_1_Coextension's list and copies its contents into\n+      --       its own list.\n+      --  9) Expand Top_Record. Generate finalization calls for Temp_1 and\n+      --       Temp_2 and attach them to Top_Record's finalization list.\n+\n+      -------------------------------------------\n+      -- Check_Allocator_Discrim_Accessibility --\n+      -------------------------------------------\n+\n+      procedure Check_Allocator_Discrim_Accessibility\n+        (Disc_Exp  : Node_Id;\n+         Alloc_Typ : Entity_Id)\n+      is\n+      begin\n+         if Type_Access_Level (Etype (Disc_Exp)) >\n+            Type_Access_Level (Alloc_Typ)\n+         then\n+            Error_Msg_N\n+              (\"operand type has deeper level than allocator type\", Disc_Exp);\n+\n+         --  When the expression is an Access attribute the level of the prefix\n+         --  object must not be deeper than that of the allocator's type.\n+\n+         elsif Nkind (Disc_Exp) = N_Attribute_Reference\n+           and then Get_Attribute_Id (Attribute_Name (Disc_Exp))\n+                      = Attribute_Access\n+           and then Object_Access_Level (Prefix (Disc_Exp))\n+                      > Type_Access_Level (Alloc_Typ)\n+         then\n+            Error_Msg_N\n+              (\"prefix of attribute has deeper level than allocator type\",\n+               Disc_Exp);\n+\n+         --  When the expression is an access discriminant the check is against\n+         --  the level of the prefix object.\n+\n+         elsif Ekind (Etype (Disc_Exp)) = E_Anonymous_Access_Type\n+           and then Nkind (Disc_Exp) = N_Selected_Component\n+           and then Object_Access_Level (Prefix (Disc_Exp))\n+                      > Type_Access_Level (Alloc_Typ)\n+         then\n+            Error_Msg_N\n+              (\"access discriminant has deeper level than allocator type\",\n+               Disc_Exp);\n+\n+         --  All other cases are legal\n+\n+         else\n+            null;\n+         end if;\n+      end Check_Allocator_Discrim_Accessibility;\n \n       ----------------------------\n       -- In_Dispatching_Context --\n       ----------------------------\n \n       function In_Dispatching_Context return Boolean is\n          Par : constant Node_Id := Parent (N);\n-\n       begin\n          return (Nkind (Par) = N_Function_Call\n                    or else Nkind (Par) = N_Procedure_Call_Statement)\n            and then Is_Entity_Name (Name (Par))\n            and then Is_Dispatching_Operation (Entity (Name (Par)));\n       end In_Dispatching_Context;\n \n+      ----------------------------\n+      -- Propagate_Coextensions --\n+      ----------------------------\n+\n+      procedure Propagate_Coextensions (Root : Node_Id) is\n+\n+         procedure Copy_List (From : Elist_Id; To : Elist_Id);\n+         --  Copy the contents of list From into list To, preserving the\n+         --  order of elements.\n+\n+         function Process_Allocator (Nod : Node_Id) return Traverse_Result;\n+         --  Recognize an allocator or a rewritten allocator node and add it\n+         --  allong with its nested coextensions to the list of Root.\n+\n+         ---------------\n+         -- Copy_List --\n+         ---------------\n+\n+         procedure Copy_List (From : Elist_Id; To : Elist_Id) is\n+            From_Elmt : Elmt_Id;\n+         begin\n+            From_Elmt := First_Elmt (From);\n+            while Present (From_Elmt) loop\n+               Append_Elmt (Node (From_Elmt), To);\n+               Next_Elmt (From_Elmt);\n+            end loop;\n+         end Copy_List;\n+\n+         -----------------------\n+         -- Process_Allocator --\n+         -----------------------\n+\n+         function Process_Allocator (Nod : Node_Id) return Traverse_Result is\n+            Orig_Nod : Node_Id := Nod;\n+\n+         begin\n+            --  This is a possible rewritten subtype indication allocator. Any\n+            --  nested coextensions will appear as discriminant constraints.\n+\n+            if Nkind (Nod) = N_Identifier\n+              and then Present (Original_Node (Nod))\n+              and then Nkind (Original_Node (Nod)) = N_Subtype_Indication\n+            then\n+               declare\n+                  Discr      : Node_Id;\n+                  Discr_Elmt : Elmt_Id;\n+\n+               begin\n+                  if Is_Record_Type (Entity (Nod)) then\n+                     Discr_Elmt :=\n+                       First_Elmt (Discriminant_Constraint (Entity (Nod)));\n+                     while Present (Discr_Elmt) loop\n+                        Discr := Node (Discr_Elmt);\n+\n+                        if Nkind (Discr) = N_Identifier\n+                          and then Present (Original_Node (Discr))\n+                          and then Nkind (Original_Node (Discr)) = N_Allocator\n+                          and then Present (Coextensions (\n+                                     Original_Node (Discr)))\n+                        then\n+                           if No (Coextensions (Root)) then\n+                              Set_Coextensions (Root, New_Elmt_List);\n+                           end if;\n+\n+                           Copy_List\n+                             (From => Coextensions (Original_Node (Discr)),\n+                              To   => Coextensions (Root));\n+                        end if;\n+\n+                        Next_Elmt (Discr_Elmt);\n+                     end loop;\n+\n+                     --  There is no need to continue the traversal of this\n+                     --  subtree since all the information has already been\n+                     --  propagated.\n+\n+                     return Skip;\n+                  end if;\n+               end;\n+\n+            --  Case of either a stand alone allocator or a rewritten allocator\n+            --  with an aggregate.\n+\n+            else\n+               if Present (Original_Node (Nod)) then\n+                  Orig_Nod := Original_Node (Nod);\n+               end if;\n+\n+               if Nkind (Orig_Nod) = N_Allocator then\n+\n+                  --  Propagate the list of nested coextensions to the Root\n+                  --  allocator. This is done through list copy since a single\n+                  --  allocator may have multiple coextensions. Do not touch\n+                  --  coextensions roots.\n+\n+                  if not Is_Coextension_Root (Orig_Nod)\n+                    and then Present (Coextensions (Orig_Nod))\n+                  then\n+                     if No (Coextensions (Root)) then\n+                        Set_Coextensions (Root, New_Elmt_List);\n+                     end if;\n+\n+                     Copy_List\n+                       (From => Coextensions (Orig_Nod),\n+                        To   => Coextensions (Root));\n+                  end if;\n+\n+                  --  There is no need to continue the traversal of this\n+                  --  subtree since all the information has already been\n+                  --  propagated.\n+\n+                  return Skip;\n+               end if;\n+            end if;\n+\n+            --  Keep on traversing, looking for the next allocator\n+\n+            return OK;\n+         end Process_Allocator;\n+\n+         procedure Process_Allocators is\n+           new Traverse_Proc (Process_Allocator);\n+\n+      --  Start of processing for Propagate_Coextensions\n+\n+      begin\n+         Process_Allocators (Expression (Root));\n+      end Propagate_Coextensions;\n+\n    --  Start of processing for Resolve_Allocator\n \n    begin\n@@ -3131,6 +3464,78 @@ package body Sem_Res is\n             Wrong_Type (Expression (E), Etype (E));\n          end if;\n \n+         --  A special accessibility check is needed for allocators that\n+         --  constrain access discriminants. The level of the type of the\n+         --  expression used to constrain an access discriminant cannot be\n+         --  deeper than the type of the allocator (in constrast to access\n+         --  parameters, where the level of the actual can be arbitrary).\n+\n+         --  We can't use Valid_Conversion to perform this check because\n+         --  in general the type of the allocator is unrelated to the type\n+         --  of the access discriminant.\n+\n+         if Ekind (Typ) /= E_Anonymous_Access_Type\n+           or else Is_Local_Anonymous_Access (Typ)\n+         then\n+            Subtyp := Entity (Subtype_Mark (E));\n+\n+            Aggr := Original_Node (Expression (E));\n+\n+            if Has_Discriminants (Subtyp)\n+              and then\n+                (Nkind (Aggr) = N_Aggregate\n+                   or else\n+                 Nkind (Aggr) = N_Extension_Aggregate)\n+            then\n+               Discrim := First_Discriminant (Base_Type (Subtyp));\n+\n+               --  Get the first component expression of the aggregate\n+\n+               if Present (Expressions (Aggr)) then\n+                  Disc_Exp := First (Expressions (Aggr));\n+\n+               elsif Present (Component_Associations (Aggr)) then\n+                  Assoc := First (Component_Associations (Aggr));\n+\n+                  if Present (Assoc) then\n+                     Disc_Exp := Expression (Assoc);\n+                  else\n+                     Disc_Exp := Empty;\n+                  end if;\n+\n+               else\n+                  Disc_Exp := Empty;\n+               end if;\n+\n+               while Present (Discrim) and then Present (Disc_Exp) loop\n+                  if Ekind (Etype (Discrim)) = E_Anonymous_Access_Type then\n+                     Check_Allocator_Discrim_Accessibility (Disc_Exp, Typ);\n+                  end if;\n+\n+                  Next_Discriminant (Discrim);\n+\n+                  if Present (Discrim) then\n+                     if Present (Assoc) then\n+                        Next (Assoc);\n+                        Disc_Exp := Expression (Assoc);\n+\n+                     elsif Present (Next (Disc_Exp)) then\n+                        Next (Disc_Exp);\n+\n+                     else\n+                        Assoc := First (Component_Associations (Aggr));\n+\n+                        if Present (Assoc) then\n+                           Disc_Exp := Expression (Assoc);\n+                        else\n+                           Disc_Exp := Empty;\n+                        end if;\n+                     end if;\n+                  end if;\n+               end loop;\n+            end if;\n+         end if;\n+\n       --  For a subtype mark or subtype indication, freeze the subtype\n \n       else\n@@ -3143,17 +3548,16 @@ package body Sem_Res is\n \n          --  A special accessibility check is needed for allocators that\n          --  constrain access discriminants. The level of the type of the\n-         --  expression used to contrain an access discriminant cannot be\n+         --  expression used to constrain an access discriminant cannot be\n          --  deeper than the type of the allocator (in constrast to access\n          --  parameters, where the level of the actual can be arbitrary).\n          --  We can't use Valid_Conversion to perform this check because\n          --  in general the type of the allocator is unrelated to the type\n-         --  of the access discriminant. Note that specialized checks are\n-         --  needed for the cases of a constraint expression which is an\n-         --  access attribute or an access discriminant.\n+         --  of the access discriminant.\n \n          if Nkind (Original_Node (E)) = N_Subtype_Indication\n-           and then Ekind (Typ) /= E_Anonymous_Access_Type\n+           and then (Ekind (Typ) /= E_Anonymous_Access_Type\n+                      or else Is_Local_Anonymous_Access (Typ))\n          then\n             Subtyp := Entity (Subtype_Mark (Original_Node (E)));\n \n@@ -3168,36 +3572,9 @@ package body Sem_Res is\n                         Disc_Exp := Original_Node (Constr);\n                      end if;\n \n-                     if Type_Access_Level (Etype (Disc_Exp))\n-                       > Type_Access_Level (Typ)\n-                     then\n-                        Error_Msg_N\n-                          (\"operand type has deeper level than allocator type\",\n-                           Disc_Exp);\n-\n-                     elsif Nkind (Disc_Exp) = N_Attribute_Reference\n-                       and then Get_Attribute_Id (Attribute_Name (Disc_Exp))\n-                                  = Attribute_Access\n-                       and then Object_Access_Level (Prefix (Disc_Exp))\n-                                  > Type_Access_Level (Typ)\n-                     then\n-                        Error_Msg_N\n-                          (\"prefix of attribute has deeper level than\"\n-                              & \" allocator type\", Disc_Exp);\n-\n-                     --  When the operand is an access discriminant the check\n-                     --  is against the level of the prefix object.\n-\n-                     elsif Ekind (Etype (Disc_Exp)) = E_Anonymous_Access_Type\n-                       and then Nkind (Disc_Exp) = N_Selected_Component\n-                       and then Object_Access_Level (Prefix (Disc_Exp))\n-                                  > Type_Access_Level (Typ)\n-                     then\n-                        Error_Msg_N\n-                          (\"access discriminant has deeper level than\"\n-                              & \" allocator type\", Disc_Exp);\n-                     end if;\n+                     Check_Allocator_Discrim_Accessibility (Disc_Exp, Typ);\n                   end if;\n+\n                   Next_Discriminant (Discrim);\n                   Next (Constr);\n                end loop;\n@@ -3217,7 +3594,7 @@ package body Sem_Res is\n         and then Is_Class_Wide_Type (Designated_Type (Typ))\n       then\n          declare\n-            Exp_Typ   : Entity_Id;\n+            Exp_Typ : Entity_Id;\n \n          begin\n             if Nkind (E) = N_Qualified_Expression then\n@@ -3275,6 +3652,34 @@ package body Sem_Res is\n          Set_Associated_Storage_Pool\n            (Typ, Associated_Storage_Pool (Etype (Parent (N))));\n       end if;\n+\n+      --  An erroneous allocator may be rewritten as a raise Program_Error\n+      --  statement.\n+\n+      if Nkind (N) = N_Allocator then\n+\n+         --  An anonymous access discriminant is the definition of a\n+         --  coextension\n+\n+         if Ekind (Typ) = E_Anonymous_Access_Type\n+           and then Nkind (Associated_Node_For_Itype (Typ)) =\n+                      N_Discriminant_Specification\n+         then\n+            --  Avoid marking an allocator as a dynamic coextension if it is\n+            --  withing a static construct.\n+\n+            if not Is_Static_Coextension (N) then\n+               Set_Is_Coextension (N);\n+            end if;\n+\n+         --  Cleanup for potential static coextensions\n+\n+         else\n+            Set_Is_Static_Coextension (N, False);\n+         end if;\n+\n+         Propagate_Coextensions (N);\n+      end if;\n    end Resolve_Allocator;\n \n    ---------------------------\n@@ -3728,7 +4133,7 @@ package body Sem_Res is\n             --  Otherwise just set the flag to check at run time\n \n             else\n-               Set_Do_Division_Check (N);\n+               Activate_Division_Check (N);\n             end if;\n          end if;\n       end if;\n@@ -3801,10 +4206,10 @@ package body Sem_Res is\n \n          Kill_Current_Values;\n \n-      --  If this is a procedure call which is really an entry call, do the\n-      --  conversion of the procedure call to an entry call. Protected\n-      --  operations use the same circuitry because the name in the call can be\n-      --  an arbitrary expression with special resolution rules.\n+      --  If this is a procedure call which is really an entry call, do\n+      --  the conversion of the procedure call to an entry call. Protected\n+      --  operations use the same circuitry because the name in the call\n+      --  can be an arbitrary expression with special resolution rules.\n \n       elsif Nkind (Subp) = N_Selected_Component\n         or else Nkind (Subp) = N_Indexed_Component\n@@ -3878,12 +4283,6 @@ package body Sem_Res is\n          end;\n       end if;\n \n-      --  Cannot call thread body directly\n-\n-      if Is_Thread_Body (Nam) then\n-         Error_Msg_N (\"cannot call thread body directly\", N);\n-      end if;\n-\n       --  Check that a procedure call does not occur in the context of the\n       --  entry call statement of a conditional or timed entry call. Note that\n       --  the case of a call to a subprogram renaming of an entry will also be\n@@ -4049,100 +4448,104 @@ package body Sem_Res is\n       --  If we are calling the current subprogram from immediately within its\n       --  body, then that is the case where we can sometimes detect cases of\n       --  infinite recursion statically. Do not try this in case restriction\n-      --  No_Recursion is in effect anyway.\n+      --  No_Recursion is in effect anyway, and do it only for source calls.\n \n-      Scop := Current_Scope;\n+      if Comes_From_Source (N) then\n+         Scop := Current_Scope;\n \n-      if Nam = Scop\n-        and then not Restriction_Active (No_Recursion)\n-        and then Check_Infinite_Recursion (N)\n-      then\n-         --  Here we detected and flagged an infinite recursion, so we do\n-         --  not need to test the case below for further warnings.\n+         if Nam = Scop\n+           and then not Restriction_Active (No_Recursion)\n+           and then Check_Infinite_Recursion (N)\n+         then\n+            --  Here we detected and flagged an infinite recursion, so we do\n+            --  not need to test the case below for further warnings.\n \n-         null;\n+            null;\n \n-      --  If call is to immediately containing subprogram, then check for\n-      --  the case of a possible run-time detectable infinite recursion.\n+            --  If call is to immediately containing subprogram, then check for\n+            --  the case of a possible run-time detectable infinite recursion.\n \n-      else\n-         Scope_Loop : while Scop /= Standard_Standard loop\n-            if Nam = Scop then\n-\n-               --  Although in general recursion is not statically checkable,\n-               --  the case of calling an immediately containing subprogram\n-               --  is easy to catch.\n-\n-               Check_Restriction (No_Recursion, N);\n-\n-               --  If the recursive call is to a parameterless subprogram, then\n-               --  even if we can't statically detect infinite recursion, this\n-               --  is pretty suspicious, and we output a warning. Furthermore,\n-               --  we will try later to detect some cases here at run time by\n-               --  expanding checking code (see Detect_Infinite_Recursion in\n-               --  package Exp_Ch6).\n-\n-               --  If the recursive call is within a handler we do not emit a\n-               --  warning, because this is a common idiom: loop until input\n-               --  is correct, catch illegal input in handler and restart.\n-\n-               if No (First_Formal (Nam))\n-                 and then Etype (Nam) = Standard_Void_Type\n-                 and then not Error_Posted (N)\n-                 and then Nkind (Parent (N)) /= N_Exception_Handler\n-               then\n-                  --  For the case of a procedure call. We give the message\n-                  --  only if the call is the first statement in a sequence of\n-                  --  statements, or if all previous statements are simple\n-                  --  assignments. This is simply a heuristic to decrease false\n-                  --  positives, without losing too many good warnings. The\n-                  --  idea is that these previous statements may affect global\n-                  --  variables the procedure depends on.\n-\n-                  if Nkind (N) = N_Procedure_Call_Statement\n-                    and then Is_List_Member (N)\n+         else\n+            Scope_Loop : while Scop /= Standard_Standard loop\n+               if Nam = Scop then\n+\n+                  --  Although in general case, recursion is not statically\n+                  --  checkable, the case of calling an immediately containing\n+                  --  subprogram is easy to catch.\n+\n+                  Check_Restriction (No_Recursion, N);\n+\n+                  --  If the recursive call is to a parameterless subprogram,\n+                  --  then even if we can't statically detect infinite\n+                  --  recursion, this is pretty suspicious, and we output a\n+                  --  warning. Furthermore, we will try later to detect some\n+                  --  cases here at run time by expanding checking code (see\n+                  --  Detect_Infinite_Recursion in package Exp_Ch6).\n+\n+                  --  If the recursive call is within a handler, do not emit a\n+                  --  warning, because this is a common idiom: loop until input\n+                  --  is correct, catch illegal input in handler and restart.\n+\n+                  if No (First_Formal (Nam))\n+                    and then Etype (Nam) = Standard_Void_Type\n+                    and then not Error_Posted (N)\n+                    and then Nkind (Parent (N)) /= N_Exception_Handler\n                   then\n+                     --  For the case of a procedure call. We give the message\n+                     --  only if the call is the first statement in a sequence\n+                     --  of statements, or if all previous statements are\n+                     --  simple assignments. This is simply a heuristic to\n+                     --  decrease false positives, without losing too many good\n+                     --  warnings. The idea is that these previous statements\n+                     --  may affect global variables the procedure depends on.\n+\n+                     if Nkind (N) = N_Procedure_Call_Statement\n+                       and then Is_List_Member (N)\n+                     then\n+                        declare\n+                           P : Node_Id;\n+                        begin\n+                           P := Prev (N);\n+                           while Present (P) loop\n+                              if Nkind (P) /= N_Assignment_Statement then\n+                                 exit Scope_Loop;\n+                              end if;\n+\n+                              Prev (P);\n+                           end loop;\n+                        end;\n+                     end if;\n+\n+                     --  Do not give warning if we are in a conditional context\n+\n                      declare\n-                        P : Node_Id;\n+                        K : constant Node_Kind := Nkind (Parent (N));\n                      begin\n-                        P := Prev (N);\n-                        while Present (P) loop\n-                           if Nkind (P) /= N_Assignment_Statement then\n-                              exit Scope_Loop;\n-                           end if;\n-\n-                           Prev (P);\n-                        end loop;\n+                        if (K = N_Loop_Statement\n+                            and then Present (Iteration_Scheme (Parent (N))))\n+                          or else K = N_If_Statement\n+                          or else K = N_Elsif_Part\n+                          or else K = N_Case_Statement_Alternative\n+                        then\n+                           exit Scope_Loop;\n+                        end if;\n                      end;\n-                  end if;\n-\n-                  --  Do not give warning if we are in a conditional context\n \n-                  declare\n-                     K : constant Node_Kind := Nkind (Parent (N));\n-                  begin\n-                     if (K = N_Loop_Statement\n-                          and then Present (Iteration_Scheme (Parent (N))))\n-                       or else K = N_If_Statement\n-                       or else K = N_Elsif_Part\n-                       or else K = N_Case_Statement_Alternative\n-                     then\n-                        exit Scope_Loop;\n-                     end if;\n-                  end;\n+                     --  Here warning is to be issued\n \n-                  --  Here warning is to be issued\n+                     Set_Has_Recursive_Call (Nam);\n+                     Error_Msg_N\n+                       (\"possible infinite recursion?\", N);\n+                     Error_Msg_N\n+                       (\"\\Storage_Error may be raised at run time?\", N);\n+                  end if;\n \n-                  Set_Has_Recursive_Call (Nam);\n-                  Error_Msg_N (\"possible infinite recursion?\", N);\n-                  Error_Msg_N (\"\\Storage_Error may be raised at run time?\", N);\n+                  exit Scope_Loop;\n                end if;\n \n-               exit Scope_Loop;\n-            end if;\n-\n-            Scop := Scope (Scop);\n-         end loop Scope_Loop;\n+               Scop := Scope (Scop);\n+            end loop Scope_Loop;\n+         end if;\n       end if;\n \n       --  If subprogram name is a predefined operator, it was given in\n@@ -4243,18 +4646,25 @@ package body Sem_Res is\n          return;\n       end if;\n \n-      --  If the subprogram is not global, then kill all checks. This is a bit\n-      --  conservative, since in many cases we could do better, but it is not\n-      --  worth the effort. Similarly, we kill constant values. However we do\n-      --  not need to do this for internal entities (unless they are inherited\n-      --  user-defined subprograms), since they are not in the business of\n-      --  molesting global values.\n+      --  If the subprogram is not global, then kill all saved values and\n+      --  checks. This is a bit conservative, since in many cases we could do\n+      --  better, but it is not worth the effort. Similarly, we kill constant\n+      --  values. However we do not need to do this for internal entities\n+      --  (unless they are inherited user-defined subprograms), since they\n+      --  are not in the business of molesting local values.\n+\n+      --  If the flag Suppress_Value_Tracking_On_Calls is set, then we also\n+      --  kill all checks and values for calls to global subprograms. This\n+      --  takes care of the case where an access to a local subprogram is\n+      --  taken, and could be passed directly or indirectly and then called\n+      --  from almost any context.\n \n       --  Note: we do not do this step till after resolving the actuals. That\n       --  way we still take advantage of the current value information while\n       --  scanning the actuals.\n \n-      if not Is_Library_Level_Entity (Nam)\n+      if (not Is_Library_Level_Entity (Nam)\n+            or else Suppress_Value_Tracking_On_Call (Current_Scope))\n         and then (Comes_From_Source (Nam)\n                    or else (Present (Alias (Nam))\n                              and then Comes_From_Source (Alias (Nam))))\n@@ -5185,13 +5595,19 @@ package body Sem_Res is\n \n          --  Ada 2005:  If one operand is an anonymous access type, convert\n          --  the other operand to it, to ensure that the underlying types\n-         --  match in the back-end.\n+         --  match in the back-end. Same for access_to_subprogram, and the\n+         --  conversion verifies that the types are subtype conformant.\n+\n          --  We apply the same conversion in the case one of the operands is\n          --  a private subtype of the type of the other.\n \n+         --  Why the Expander_Active test here ???\n+\n          if Expander_Active\n-           and then (Ekind (T) =  E_Anonymous_Access_Type\n-                       or else Is_Private_Type (T))\n+           and then\n+             (Ekind (T) =  E_Anonymous_Access_Type\n+               or else Ekind (T) = E_Anonymous_Access_Subprogram_Type\n+               or else Is_Private_Type (T))\n          then\n             if Etype (L) /= T then\n                Rewrite (L,\n@@ -5377,8 +5793,14 @@ package body Sem_Res is\n       end if;\n \n       --  If name was overloaded, set component type correctly now\n+      --  If a misplaced call to an entry family (which has no index typs)\n+      --  return. Error will be diagnosed from calling context.\n \n-      Set_Etype (N, Component_Type (Array_Type));\n+      if Is_Array_Type (Array_Type) then\n+         Set_Etype (N, Component_Type (Array_Type));\n+      else\n+         return;\n+      end if;\n \n       Index := First_Index (Array_Type);\n       Expr  := First (Expressions (N));\n@@ -5793,7 +6215,7 @@ package body Sem_Res is\n \n                      if It.Nam = Func then\n                         Error_Msg_Sloc := Sloc (Func);\n-                        Error_Msg_N (\"\\ambiguous call to function#\", Arg);\n+                        Error_Msg_N (\"ambiguous call to function#\", Arg);\n                         Error_Msg_NE\n                           (\"\\\\interpretation as call yields&\", Arg, Typ);\n                         Error_Msg_NE\n@@ -6134,6 +6556,15 @@ package body Sem_Res is\n       Check_Non_Static_Context (L);\n       Check_Non_Static_Context (H);\n \n+      --  Check for an ambiguous range over character literals. This will\n+      --  happen with a membership test involving only literals.\n+\n+      if Typ = Any_Character then\n+         Ambiguous_Character (L);\n+         Set_Etype (N, Any_Type);\n+         return;\n+      end if;\n+\n       --  If bounds are static, constant-fold them, so size computations\n       --  are identical between front-end and back-end. Do not perform this\n       --  transformation while analyzing generic units, as type information\n@@ -6581,12 +7012,14 @@ package body Sem_Res is\n             --  if Ada.Tags is already loaded to void the addition of an\n             --  undesired dependence on such run-time unit.\n \n-           and then not\n-             (RTU_Loaded (Ada_Tags)\n-              and then Nkind (Prefix (N)) = N_Selected_Component\n-              and then Present (Entity (Selector_Name (Prefix (N))))\n-              and then Entity (Selector_Name (Prefix (N)))\n-                         = RTE_Record_Component (RE_Prims_Ptr))\n+           and then\n+             (VM_Target /= No_VM\n+              or else not\n+                (RTU_Loaded (Ada_Tags)\n+                  and then Nkind (Prefix (N)) = N_Selected_Component\n+                  and then Present (Entity (Selector_Name (Prefix (N))))\n+                  and then Entity (Selector_Name (Prefix (N))) =\n+                                        RTE_Record_Component (RE_Prims_Ptr)))\n          then\n             Apply_Range_Check (Drange, Etype (Index));\n          end if;\n@@ -6877,18 +7310,16 @@ package body Sem_Res is\n \n    procedure Resolve_Type_Conversion (N : Node_Id; Typ : Entity_Id) is\n       Conv_OK     : constant Boolean := Conversion_OK (N);\n-      Target_Type : Entity_Id := Etype (N);\n-      Operand     : Node_Id;\n-      Opnd_Type   : Entity_Id;\n+      Operand     : constant Node_Id := Expression (N);\n+      Operand_Typ : constant Entity_Id := Etype (Operand);\n+      Target_Typ  : constant Entity_Id := Etype (N);\n       Rop         : Node_Id;\n       Orig_N      : Node_Id;\n       Orig_T      : Node_Id;\n \n    begin\n-      Operand := Expression (N);\n-\n       if not Conv_OK\n-        and then not Valid_Conversion (N, Target_Type, Operand)\n+        and then not Valid_Conversion (N, Target_Typ, Operand)\n       then\n          return;\n       end if;\n@@ -6957,7 +7388,6 @@ package body Sem_Res is\n          end if;\n       end if;\n \n-      Opnd_Type := Etype (Operand);\n       Resolve (Operand);\n \n       --  Note: we do the Eval_Type_Conversion call before applying the\n@@ -6973,23 +7403,23 @@ package body Sem_Res is\n       --  Even when evaluation is not possible, we may be able to simplify\n       --  the conversion or its expression. This needs to be done before\n       --  applying checks, since otherwise the checks may use the original\n-      --  expression and defeat the simplifications. The is specifically\n+      --  expression and defeat the simplifications. This is specifically\n       --  the case for elimination of the floating-point Truncation\n       --  attribute in float-to-int conversions.\n \n       Simplify_Type_Conversion (N);\n \n-      --  If after evaluation, we still have a type conversion, then we\n+      --  If after evaluation we still have a type conversion, then we\n       --  may need to apply checks required for a subtype conversion.\n \n       --  Skip these type conversion checks if universal fixed operands\n       --  operands involved, since range checks are handled separately for\n       --  these cases (in the appropriate Expand routines in unit Exp_Fixd).\n \n       if Nkind (N) = N_Type_Conversion\n-        and then not Is_Generic_Type (Root_Type (Target_Type))\n-        and then Target_Type /= Universal_Fixed\n-        and then Opnd_Type /= Universal_Fixed\n+        and then not Is_Generic_Type (Root_Type (Target_Typ))\n+        and then Target_Typ  /= Universal_Fixed\n+        and then Operand_Typ /= Universal_Fixed\n       then\n          Apply_Type_Conversion_Checks (N);\n       end if;\n@@ -7006,7 +7436,7 @@ package body Sem_Res is\n         and then not In_Instance\n       then\n          Orig_N := Original_Node (Expression (Orig_N));\n-         Orig_T := Target_Type;\n+         Orig_T := Target_Typ;\n \n          --  If the node is part of a larger expression, the Target_Type\n          --  may not be the original type of the node if the context is a\n@@ -7026,62 +7456,94 @@ package body Sem_Res is\n          end if;\n       end if;\n \n-      --  Ada 2005 (AI-251): Handle conversions to abstract interface types\n+      --  Ada 2005 (AI-251): Handle class-wide interface type conversions.\n       --  No need to perform any interface conversion if the type of the\n       --  expression coincides with the target type.\n \n       if Ada_Version >= Ada_05\n         and then Expander_Active\n-        and then Opnd_Type /= Target_Type\n+        and then Operand_Typ /= Target_Typ\n       then\n-         if Is_Access_Type (Target_Type) then\n-            Target_Type := Directly_Designated_Type (Target_Type);\n-         end if;\n-\n-         if Is_Class_Wide_Type (Target_Type) then\n-            Target_Type := Etype (Target_Type);\n-         end if;\n+         declare\n+            Opnd   : Entity_Id := Operand_Typ;\n+            Target : Entity_Id := Target_Typ;\n \n-         if Is_Interface (Target_Type) then\n-            if Is_Access_Type (Opnd_Type) then\n-               Opnd_Type := Directly_Designated_Type (Opnd_Type);\n+         begin\n+            if Is_Access_Type (Opnd) then\n+               Opnd := Directly_Designated_Type (Opnd);\n             end if;\n \n-            if Is_Class_Wide_Type (Opnd_Type) then\n-               Opnd_Type := Etype (Opnd_Type);\n+            if Is_Access_Type (Target_Typ) then\n+               Target := Directly_Designated_Type (Target);\n             end if;\n \n-            --  Handle subtypes\n+            if Opnd = Target then\n+               null;\n \n-            if Ekind (Opnd_Type) = E_Protected_Subtype\n-              or else Ekind (Opnd_Type) = E_Task_Subtype\n-            then\n-               Opnd_Type := Etype (Opnd_Type);\n-            end if;\n+            --  Conversion from interface type\n \n-            if not Interface_Present_In_Ancestor\n-                     (Typ   => Opnd_Type,\n-                      Iface => Target_Type)\n-            then\n-               --  The static analysis is not enough to know if the interface\n-               --  is implemented or not. Hence we must pass the work to the\n-               --  expander to generate the required code to evaluate the\n-               --  conversion at run-time.\n+            elsif Is_Interface (Opnd) then\n \n-               Expand_Interface_Conversion (N, Is_Static => False);\n+               --  Ada 2005 (AI-217): Handle entities from limited views\n \n-            else\n-               Expand_Interface_Conversion (N);\n-            end if;\n+               if From_With_Type (Opnd) then\n+                  Error_Msg_Qual_Level := 99;\n+                  Error_Msg_NE (\"missing with-clause on package &\", N,\n+                    Cunit_Entity (Get_Source_Unit (Base_Type (Opnd))));\n+                  Error_Msg_N\n+                    (\"type conversions require visibility of the full view\",\n+                     N);\n \n-         --  Ada 2005 (AI-251): Conversion from a class-wide interface to a\n-         --  tagged type\n+               elsif From_With_Type (Target) then\n+                  Error_Msg_Qual_Level := 99;\n+                  Error_Msg_NE (\"missing with-clause on package &\", N,\n+                    Cunit_Entity (Get_Source_Unit (Base_Type (Target))));\n+                  Error_Msg_N\n+                    (\"type conversions require visibility of the full view\",\n+                     N);\n \n-         elsif Is_Class_Wide_Type (Opnd_Type)\n-            and then Is_Interface (Opnd_Type)\n-         then\n-            Expand_Interface_Conversion (N, Is_Static => False);\n-         end if;\n+               else\n+                  Expand_Interface_Conversion (N, Is_Static => False);\n+               end if;\n+\n+            --  Conversion to interface type\n+\n+            elsif Is_Interface (Target) then\n+\n+               --  Handle subtypes\n+\n+               if Ekind (Opnd) = E_Protected_Subtype\n+                 or else Ekind (Opnd) = E_Task_Subtype\n+               then\n+                  Opnd := Etype (Opnd);\n+               end if;\n+\n+               if not Interface_Present_In_Ancestor\n+                        (Typ   => Opnd,\n+                         Iface => Target)\n+               then\n+                  if Is_Class_Wide_Type (Opnd) then\n+\n+                     --  The static analysis is not enough to know if the\n+                     --  interface is implemented or not. Hence we must pass\n+                     --  the work to the expander to generate code to evaluate\n+                     --  the conversion at run-time.\n+\n+                     Expand_Interface_Conversion (N, Is_Static => False);\n+\n+                  else\n+                     Error_Msg_Name_1 := Chars (Etype (Target));\n+                     Error_Msg_Name_2 := Chars (Opnd);\n+                     Error_Msg_N\n+                       (\"wrong interface conversion (% is not a progenitor \" &\n+                        \"of %)\", N);\n+                  end if;\n+\n+               else\n+                  Expand_Interface_Conversion (N);\n+               end if;\n+            end if;\n+         end;\n       end if;\n    end Resolve_Type_Conversion;\n \n@@ -7097,7 +7559,7 @@ package body Sem_Res is\n       Hi    : Uint;\n \n    begin\n-      --  Deal with intrincis unary operators\n+      --  Deal with intrinsic unary operators\n \n       if Comes_From_Source (N)\n         and then Ekind (Entity (N)) = E_Function\n@@ -7367,8 +7829,8 @@ package body Sem_Res is\n          Set_Entity     (Op_Node, Op);\n          Set_Right_Opnd (Op_Node, Right_Opnd (N));\n \n-         --  Indicate that both the original entity and its renaming\n-         --  are referenced at this point.\n+         --  Indicate that both the original entity and its renaming are\n+         --  referenced at this point.\n \n          Generate_Reference (Entity (N), N);\n          Generate_Reference (Op, N);\n@@ -7403,7 +7865,7 @@ package body Sem_Res is\n         and then Is_Intrinsic_Subprogram (Op)\n       then\n          --  Operator renames a user-defined operator of the same name. Use\n-         --  the original operator in the node, which is the one that gigi\n+         --  the original operator in the node, which is the one that Gigi\n          --  knows about.\n \n          Set_Entity (N, Op);\n@@ -7417,7 +7879,7 @@ package body Sem_Res is\n \n    --  Build an implicit subtype declaration to represent the type delivered\n    --  by the slice. This is an abbreviated version of an array subtype. We\n-   --  define an index subtype for the slice,  using either the subtype name\n+   --  define an index subtype for the slice, using either the subtype name\n    --  or the discrete range of the slice. To be consistent with index usage\n    --  elsewhere, we create a list header to hold the single index. This list\n    --  is not otherwise attached to the syntax tree.\n@@ -7470,8 +7932,8 @@ package body Sem_Res is\n \n       Check_Compile_Time_Size (Slice_Subtype);\n \n-      --  The Etype of the existing Slice node is reset to this slice\n-      --  subtype. Its bounds are obtained from its first index.\n+      --  The Etype of the existing Slice node is reset to this slice subtype.\n+      --  Its bounds are obtained from its first index.\n \n       Set_Etype (N, Slice_Subtype);\n \n@@ -7523,8 +7985,8 @@ package body Sem_Res is\n            (Subtype_Id, Make_Integer_Literal (Loc, 1));\n          Set_Etype (String_Literal_Low_Bound (Subtype_Id), Standard_Positive);\n \n-         --  Build bona fide subtypes for the string, and wrap it in an\n-         --  unchecked conversion, because the backend expects  the\n+         --  Build bona fide subtype for the string, and wrap it in an\n+         --  unchecked conversion, because the backend expects the\n          --  String_Literal_Subtype to have a static lower bound.\n \n          declare\n@@ -7899,7 +8361,7 @@ package body Sem_Res is\n          --  (RM 4.6(23)).\n \n          elsif Is_Class_Wide_Type (Opnd_Type)\n-              and then Covers (Opnd_Type, Target_Type)\n+           and then Covers (Opnd_Type, Target_Type)\n          then\n             return True;\n \n@@ -7916,6 +8378,17 @@ package body Sem_Res is\n          elsif Is_Interface (Target_Type) or else Is_Interface (Opnd_Type) then\n             return True;\n \n+         --  If the operand is a class-wide type obtained through a limited_\n+         --  with clause, and the context includes the non-limited view, use\n+         --  it to determine whether the conversion is legal.\n+\n+         elsif Is_Class_Wide_Type (Opnd_Type)\n+           and then From_With_Type (Opnd_Type)\n+           and then Present (Non_Limited_View (Etype (Opnd_Type)))\n+           and then Is_Interface (Non_Limited_View (Etype (Opnd_Type)))\n+         then\n+            return True;\n+\n          elsif Is_Access_Type (Opnd_Type)\n            and then Is_Interface (Directly_Designated_Type (Opnd_Type))\n          then"}, {"sha": "33b9f40416198677cb21c6506c99b54a90949b7b", "filename": "gcc/ada/sem_res.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d1f17ff2605ae0dda0f3568136ff76cfcb879e/gcc%2Fada%2Fsem_res.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d1f17ff2605ae0dda0f3568136ff76cfcb879e/gcc%2Fada%2Fsem_res.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.ads?ref=b7d1f17ff2605ae0dda0f3568136ff76cfcb879e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -93,6 +93,13 @@ package Sem_Res is\n    --  is not present, then the Etype of the expression after the Analyze\n    --  call is used for the Resolve.\n \n+   procedure Ambiguous_Character (C : Node_Id);\n+   --  Give list of candidate interpretations when a character literal cannot\n+   --  be resolved, for example in a (useless) comparison such as 'A' = 'B'.\n+   --  In Ada95 the literals in question can be of type Character or Wide_\n+   --  Character. In Ada2005 Wide_Wide_Character is also a candidate. The\n+   --  node may also be overloaded with user-defined character types.\n+\n    procedure Check_Parameterless_Call (N : Node_Id);\n    --  Several forms of names can denote calls to entities without para-\n    --  meters. The context determines whether the name denotes the entity"}]}