{"sha": "632ac2b491fd09fe5ac03ef37d259add0222f670", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMyYWMyYjQ5MWZkMDlmZTVhYzAzZWYzN2QyNTlhZGQwMjIyZjY3MA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@apple.com", "date": "2007-01-16T05:34:02Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2007-01-16T05:34:02Z"}, "message": "ifcvt.c: Include vec.h, vecprim.h.\n\n2007-01-15  Eric Christopher  <echristo@apple.com>\n\n        * ifcvt.c: Include vec.h, vecprim.h.\n        (check_cond_move_block): New argument regs.\n        Reorganize. Add registers used to regs.\n        (cond_move_process_if_block): Use regs set above as\n        loop bounds.\n\nFrom-SVN: r120822", "tree": {"sha": "5affa4a145767e604a8e564bf1174dfda47208b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5affa4a145767e604a8e564bf1174dfda47208b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/632ac2b491fd09fe5ac03ef37d259add0222f670", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/632ac2b491fd09fe5ac03ef37d259add0222f670", "html_url": "https://github.com/Rust-GCC/gccrs/commit/632ac2b491fd09fe5ac03ef37d259add0222f670", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/632ac2b491fd09fe5ac03ef37d259add0222f670/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02168f731992209198376dab9d83623b8eb0f54d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02168f731992209198376dab9d83623b8eb0f54d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02168f731992209198376dab9d83623b8eb0f54d"}], "stats": {"total": 118, "additions": 70, "deletions": 48}, "files": [{"sha": "e0fcfbfdd2b6bea69cae2cd92da3698c3fb564eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632ac2b491fd09fe5ac03ef37d259add0222f670/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632ac2b491fd09fe5ac03ef37d259add0222f670/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=632ac2b491fd09fe5ac03ef37d259add0222f670", "patch": "@@ -1,3 +1,11 @@\n+2007-01-15  Eric Christopher  <echristo@apple.com>\n+\n+\t* ifcvt.c: Include vec.h, vecprim.h.\n+\t(check_cond_move_block): New argument regs.\n+\tReorganize. Add registers used to regs.\n+\t(cond_move_process_if_block): Use regs set above as\n+\tloop bounds.\n+\n 2007-01-15  Eric Christopher  <echristo@apple.com>\n \n \t* config/darwin.h: Update copyright."}, {"sha": "9e65a25bd7ba95eafc01684e69b218852906e76a", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632ac2b491fd09fe5ac03ef37d259add0222f670/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632ac2b491fd09fe5ac03ef37d259add0222f670/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=632ac2b491fd09fe5ac03ef37d259add0222f670", "patch": "@@ -43,6 +43,8 @@\n #include \"target.h\"\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n+#include \"vec.h\"\n+#include \"vecprim.h\"\n \n \n #ifndef HAVE_conditional_execution\n@@ -172,7 +174,7 @@ cheap_bb_rtx_cost_p (basic_block bb, int max_cost)\n \t}\n       else if (CALL_P (insn))\n \treturn false;\n- \n+\n       if (insn == BB_END (bb))\n \tbreak;\n       insn = NEXT_INSN (insn);\n@@ -601,7 +603,7 @@ struct noce_if_info\n \n   /* The jump that ends TEST_BB.  */\n   rtx jump;\n- \n+\n   /* The jump condition.  */\n   rtx cond;\n \n@@ -730,9 +732,9 @@ noce_emit_move_insn (rtx x, rtx y)\n \t      unsigned HOST_WIDE_INT size = INTVAL (XEXP (x, 1));\n \t      unsigned HOST_WIDE_INT start = INTVAL (XEXP (x, 2));\n \n-\t      /* store_bit_field expects START to be relative to \n-\t\t BYTES_BIG_ENDIAN and adjusts this value for machines with \n-\t\t BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN.  In order to be able to \n+\t      /* store_bit_field expects START to be relative to\n+\t\t BYTES_BIG_ENDIAN and adjusts this value for machines with\n+\t\t BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN.  In order to be able to\n \t\t invoke store_bit_field again it is necessary to have the START\n \t\t value from the first call.  */\n \t      if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n@@ -768,7 +770,7 @@ noce_emit_move_insn (rtx x, rtx y)\n \t\t  end_sequence ();\n \t\t}\n \t      break;\n-\t      \n+\n \t    case RTX_BIN_ARITH:\n \t    case RTX_COMM_ARITH:\n \t      ot = code_to_optab[GET_CODE (y)];\n@@ -787,12 +789,12 @@ noce_emit_move_insn (rtx x, rtx y)\n \t\t  end_sequence ();\n \t\t}\n \t      break;\n-\t      \n+\n \t    default:\n \t      break;\n \t    }\n \t}\n-      \n+\n       emit_insn (seq);\n       return;\n     }\n@@ -2285,11 +2287,11 @@ noce_process_if_block (struct ce_if_block * ce_info)\n       if (no_new_pseudos || GET_MODE (x) == BLKmode)\n \treturn FALSE;\n \n-      if (GET_MODE (x) == ZERO_EXTRACT \n-\t  && (GET_CODE (XEXP (x, 1)) != CONST_INT \n+      if (GET_MODE (x) == ZERO_EXTRACT\n+\t  && (GET_CODE (XEXP (x, 1)) != CONST_INT\n \t      || GET_CODE (XEXP (x, 2)) != CONST_INT))\n \treturn FALSE;\n-\t  \n+\n       x = gen_reg_rtx (GET_MODE (GET_CODE (x) == STRICT_LOW_PART\n \t\t\t\t ? XEXP (x, 0) : x));\n     }\n@@ -2417,7 +2419,7 @@ noce_process_if_block (struct ce_if_block * ce_info)\n   redirect_edge_and_branch_force (single_succ_edge (test_bb), join_bb);\n   delete_basic_block (then_bb);\n   num_true_changes++;\n-  \n+\n   if (can_merge_blocks_p (test_bb, join_bb))\n     {\n       merge_blocks (test_bb, join_bb);\n@@ -2431,14 +2433,20 @@ noce_process_if_block (struct ce_if_block * ce_info)\n /* Check whether a block is suitable for conditional move conversion.\n    Every insn must be a simple set of a register to a constant or a\n    register.  For each assignment, store the value in the array VALS,\n-   indexed by register number.  COND is the condition we will\n-   test.  */\n+   indexed by register number, then store the register number in\n+   REGS.  COND is the condition we will test.  */\n \n static int\n-check_cond_move_block (basic_block bb, rtx *vals, rtx cond)\n+check_cond_move_block (basic_block bb, rtx *vals, VEC (int, heap) *regs, rtx cond)\n {\n   rtx insn;\n \n+   /* We can only handle simple jumps at the end of the basic block.\n+      It is almost impossible to update the CFG otherwise.  */\n+  insn = BB_END (bb);\n+  if (JUMP_P (insn) && !onlyjump_p (insn))\n+    return FALSE;\n+\n   FOR_BB_INSNS (bb, insn)\n     {\n       rtx set, dest, src;\n@@ -2482,21 +2490,17 @@ check_cond_move_block (basic_block bb, rtx *vals, rtx cond)\n       if (reg_overlap_mentioned_p (dest, cond))\n \treturn FALSE;\n \n-      vals[REGNO (dest)] = src;\n-\n       /* Don't try to handle this if the source register is modified\n \t later in the block.  */\n       if (!CONSTANT_P (src)\n \t  && modified_between_p (src, insn, NEXT_INSN (BB_END (bb))))\n \treturn FALSE;\n+\n+      vals[REGNO (dest)] = src;\n+\n+      VEC_safe_push (int, heap, regs, REGNO (dest));\n     }\n \n-  /* We can only handle simple jumps at the end of the basic block.\n-     It is almost impossible to update the CFG otherwise.  */\n-  insn = BB_END (bb);\n-  if (JUMP_P (insn) && ! onlyjump_p (insn))\n-    return FALSE;\n-  \n   return TRUE;\n }\n \n@@ -2577,9 +2581,12 @@ cond_move_process_if_block (struct ce_if_block *ce_info)\n   basic_block join_bb;\n   struct noce_if_info if_info;\n   rtx jump, cond, seq, loc_insn;\n-  int max_reg, size, c, i;\n+  int max_reg, size, c, reg;\n   rtx *then_vals;\n   rtx *else_vals;\n+  VEC (int, heap) *then_regs = NULL;\n+  VEC (int, heap) *else_regs = NULL;\n+  unsigned int i;\n \n   if (!HAVE_conditional_move || no_new_pseudos)\n     return FALSE;\n@@ -2602,8 +2609,8 @@ cond_move_process_if_block (struct ce_if_block *ce_info)\n   memset (else_vals, 0, size);\n \n   /* Make sure the blocks are suitable.  */\n-  if (!check_cond_move_block (then_bb, then_vals, cond)\n-      || (else_bb && !check_cond_move_block (else_bb, else_vals, cond)))\n+  if (!check_cond_move_block (then_bb, then_vals, then_regs, cond)\n+      || (else_bb && !check_cond_move_block (else_bb, else_vals, else_regs, cond)))\n     return FALSE;\n \n   /* Make sure the blocks can be used together.  If the same register\n@@ -2613,22 +2620,27 @@ cond_move_process_if_block (struct ce_if_block *ce_info)\n      source register does not change after the assignment.  Also count\n      the number of registers set in only one of the blocks.  */\n   c = 0;\n-  for (i = 0; i <= max_reg; ++i)\n+  for (i = 0; VEC_iterate (int, then_regs, i, reg); i++)\n     {\n-      if (!then_vals[i] && !else_vals[i])\n+      if (!then_vals[reg] && !else_vals[reg])\n \tcontinue;\n \n-      if (!then_vals[i] || !else_vals[i])\n+      if (!else_vals[reg])\n \t++c;\n       else\n \t{\n-\t  if (!CONSTANT_P (then_vals[i])\n-\t      && !CONSTANT_P (else_vals[i])\n-\t      && !rtx_equal_p (then_vals[i], else_vals[i]))\n+\t  if (!CONSTANT_P (then_vals[reg])\n+\t      && !CONSTANT_P (else_vals[reg])\n+\t      && !rtx_equal_p (then_vals[reg], else_vals[reg]))\n \t    return FALSE;\n \t}\n     }\n \n+  /* Finish off c for MAX_CONDITIONAL_EXECUTE.  */\n+  for (i = 0; VEC_iterate (int, else_regs, i, reg); ++i)\n+    if (!then_vals[reg])\n+      ++c;\n+\n   /* Make sure it is reasonable to convert this block.  What matters\n      is the number of assignments currently made in only one of the\n      branches, since if we convert we are going to always execute\n@@ -2673,14 +2685,18 @@ cond_move_process_if_block (struct ce_if_block *ce_info)\n   redirect_edge_and_branch_force (single_succ_edge (test_bb), join_bb);\n   delete_basic_block (then_bb);\n   num_true_changes++;\n-  \n+\n   if (can_merge_blocks_p (test_bb, join_bb))\n     {\n       merge_blocks (test_bb, join_bb);\n       num_true_changes++;\n     }\n \n   num_updated_if_blocks++;\n+\n+  VEC_free (int, heap, then_regs);\n+  VEC_free (int, heap, else_regs);\n+\n   return TRUE;\n }\n \n@@ -3053,7 +3069,7 @@ find_if_block (struct ce_if_block * ce_info)\n      other than any || blocks which jump to the THEN block.  */\n   if ((EDGE_COUNT (then_bb->preds) - ce_info->num_or_or_blocks) != 1)\n     return FALSE;\n-    \n+\n   /* The edges of the THEN and ELSE blocks cannot have complex edges.  */\n   FOR_EACH_EDGE (cur_edge, ei, then_bb->preds)\n     {\n@@ -3395,19 +3411,19 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n      and cold sections.\n-  \n+\n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really \n-     must be left untouched (they are required to make it safely across \n-     partition boundaries).  See  the comments at the top of \n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n+     partition boundaries).  See  the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if ((BB_END (then_bb) \n+  if ((BB_END (then_bb)\n        && find_reg_note (BB_END (then_bb), REG_CROSSING_JUMP, NULL_RTX))\n       || (BB_END (test_bb)\n \t  && find_reg_note (BB_END (test_bb), REG_CROSSING_JUMP, NULL_RTX))\n       || (BB_END (else_bb)\n-\t  && find_reg_note (BB_END (else_bb), REG_CROSSING_JUMP, \n+\t  && find_reg_note (BB_END (else_bb), REG_CROSSING_JUMP,\n \t\t\t    NULL_RTX)))\n     return FALSE;\n \n@@ -3501,19 +3517,19 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n      and cold sections.\n-  \n+\n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really \n-     must be left untouched (they are required to make it safely across \n-     partition boundaries).  See  the comments at the top of \n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n+     partition boundaries).  See  the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if ((BB_END (then_bb)\n        && find_reg_note (BB_END (then_bb), REG_CROSSING_JUMP, NULL_RTX))\n       || (BB_END (test_bb)\n \t  && find_reg_note (BB_END (test_bb), REG_CROSSING_JUMP, NULL_RTX))\n-      || (BB_END (else_bb) \n-\t  && find_reg_note (BB_END (else_bb), REG_CROSSING_JUMP, \n+      || (BB_END (else_bb)\n+\t  && find_reg_note (BB_END (else_bb), REG_CROSSING_JUMP,\n \t\t\t    NULL_RTX)))\n     return FALSE;\n \n@@ -4098,5 +4114,3 @@ struct tree_opt_pass pass_if_after_reload =\n   TODO_ggc_collect,                     /* todo_flags_finish */\n   'E'                                   /* letter */\n };\n-\n-"}]}