{"sha": "ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EyN2Q1YWViZDZjNGE0ZmIyNzc2ZjI5MjRkYTYyMWMyNmI1ZmQxYQ==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-07-26T08:47:33Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-07-26T08:47:33Z"}, "message": "re PR fortran/44354 (implied do loop with its own variable name as upper bound)\n\nfortran/\n\tPR fortran/44354\n\t* array.c (sought_symbol): New variable.\n\t(expr_is_sought_symbol_ref, find_symbol_in_expr): New functions.\n\t(resolve_array_list): Check for references to the induction\n\tvariable in the iteration bounds and issue a diagnostic if some\n\tare found.\n\ntestsuite/\n\tPR fortran/44354\n\t* gfortran.dg/array_constructor_38.f90: New test.\n\nFrom-SVN: r189882", "tree": {"sha": "97e486c2daffd632033804f16913b8ac71d1320e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97e486c2daffd632033804f16913b8ac71d1320e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a/comments", "author": null, "committer": null, "parents": [{"sha": "b573c9d6f4a2e4692492894266d1d936b8bd35af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b573c9d6f4a2e4692492894266d1d936b8bd35af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b573c9d6f4a2e4692492894266d1d936b8bd35af"}], "stats": {"total": 112, "additions": 109, "deletions": 3}, "files": [{"sha": "3c68cbfdc33c8d421d00c746e52c9d0f69e8b2d1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a", "patch": "@@ -1,3 +1,12 @@\n+2012-07-26  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/44354\n+\t* array.c (sought_symbol): New variable.\n+\t(expr_is_sought_symbol_ref, find_symbol_in_expr): New functions.\n+\t(resolve_array_list): Check for references to the induction\n+\tvariable in the iteration bounds and issue a diagnostic if some\n+\tare found.\n+\n 2012-07-26  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n \t    Tobias Burnus  <burnus@net-b.de>\n "}, {"sha": "76bd5c3d63ddc774e8b79097160fe78653f28a0c", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a", "patch": "@@ -1748,6 +1748,50 @@ gfc_expanded_ac (gfc_expr *e)\n \n /*************** Type resolution of array constructors ***************/\n \n+\n+/* The symbol expr_is_sought_symbol_ref will try to find.  */\n+static const gfc_symbol *sought_symbol = NULL;\n+\n+\n+/* Tells whether the expression E is a variable reference to the symbol\n+   in the static variable SOUGHT_SYMBOL, and sets the locus pointer WHERE\n+   accordingly.\n+   To be used with gfc_expr_walker: if a reference is found we don't need\n+   to look further so we return 1 to skip any further walk.  */\n+\n+static int\n+expr_is_sought_symbol_ref (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t\t   void *where)\n+{\n+  gfc_expr *expr = *e;\n+  locus *sym_loc = (locus *)where;\n+\n+  if (expr->expr_type == EXPR_VARIABLE\n+      && expr->symtree->n.sym == sought_symbol)\n+    {\n+      *sym_loc = expr->where;\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* Tells whether the expression EXPR contains a reference to the symbol\n+   SYM and in that case sets the position SYM_LOC where the reference is.  */\n+\n+static bool\n+find_symbol_in_expr (gfc_symbol *sym, gfc_expr *expr, locus *sym_loc)\n+{\n+  int ret;\n+\n+  sought_symbol = sym;\n+  ret = gfc_expr_walker (&expr, &expr_is_sought_symbol_ref, sym_loc);\n+  sought_symbol = NULL;\n+  return ret;\n+}\n+\n+\n /* Recursive array list resolution function.  All of the elements must\n    be of the same type.  */\n \n@@ -1756,14 +1800,46 @@ resolve_array_list (gfc_constructor_base base)\n {\n   gfc_try t;\n   gfc_constructor *c;\n+  gfc_iterator *iter;\n \n   t = SUCCESS;\n \n   for (c = gfc_constructor_first (base); c; c = gfc_constructor_next (c))\n     {\n-      if (c->iterator != NULL\n-\t  && gfc_resolve_iterator (c->iterator, false) == FAILURE)\n-\tt = FAILURE;\n+      iter = c->iterator;\n+      if (iter != NULL)\n+        {\n+\t  gfc_symbol *iter_var;\n+\t  locus iter_var_loc;\n+\t \n+\t  if (gfc_resolve_iterator (iter, false) == FAILURE)\n+\t    t = FAILURE;\n+\n+\t  /* Check for bounds referencing the iterator variable.  */\n+\t  gcc_assert (iter->var->expr_type == EXPR_VARIABLE);\n+\t  iter_var = iter->var->symtree->n.sym;\n+\t  if (find_symbol_in_expr (iter_var, iter->start, &iter_var_loc))\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_LEGACY, \"AC-IMPLIED-DO initial \"\n+\t\t\t\t  \"expression references control variable \"\n+\t\t\t\t  \"at %L\", &iter_var_loc) == FAILURE)\n+\t       t = FAILURE;\n+\t    }\n+\t  if (find_symbol_in_expr (iter_var, iter->end, &iter_var_loc))\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_LEGACY, \"AC-IMPLIED-DO final \"\n+\t\t\t\t  \"expression references control variable \"\n+\t\t\t\t  \"at %L\", &iter_var_loc) == FAILURE)\n+\t       t = FAILURE;\n+\t    }\n+\t  if (find_symbol_in_expr (iter_var, iter->step, &iter_var_loc))\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_LEGACY, \"AC-IMPLIED-DO step \"\n+\t\t\t\t  \"expression references control variable \"\n+\t\t\t\t  \"at %L\", &iter_var_loc) == FAILURE)\n+\t       t = FAILURE;\n+\t    }\n+\t}\n \n       if (gfc_resolve_expr (c->expr) == FAILURE)\n \tt = FAILURE;"}, {"sha": "16d56aee9bfcb41aa5c6ccf5684401346022ce10", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a", "patch": "@@ -1,3 +1,8 @@\n+2012-07-26  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/44354\n+\t* gfortran.dg/array_constructor_38.f90: New test.\n+\n 2012-07-25  Janis Johnson  <janisjo@codesourcery.com>\n \n \t* g++.dg/cpp0x/nullptr21.c: Remove printfs, make self-checking."}, {"sha": "961e5803206aeb7eac9f5400dca10670206148e4", "filename": "gcc/testsuite/gfortran.dg/array_constructor_38.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_38.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_38.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_38.f90?ref=ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+!\n+! PR fortran/44354\n+! array constructors were giving unexpected results when the ac-implied-do\n+! variable was used in one of the ac-implied-do bounds.\n+!\n+! Original testcase by Vittorio Zecca <zeccav@gmail.com>\n+!\n+      I=5\n+      print *,(/(i,i=I,8)/) ! { dg-error \"initial expression references control variable\" }\n+      print *,(/(i,i=1,I)/) ! { dg-error \"final expression references control variable\" }\n+      print *,(/(i,i=1,50,I)/) ! { dg-error \"step expression references control variable\" }\n+      end\n+\n+"}]}