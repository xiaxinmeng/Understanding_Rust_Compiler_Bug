{"sha": "eaec70cd8bb0d06d550878428a961a41e755f213", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFlYzcwY2Q4YmIwZDA2ZDU1MDg3ODQyOGE5NjFhNDFlNzU1ZjIxMw==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-10-06T15:56:15Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-10-06T15:56:15Z"}, "message": "remove dead code used by the old cloog scheduler\n\n2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n                Sebastian Pop  <s.pop@samsung.com>\n\n                * graphite-dependences.c (scop_get_transformed_schedule): Remove.\n                (no_violations): Remove.\n                (subtract_commutative_associative_deps): Remove.\n                (compute_deps): Do not call subtract_commutative_associative_deps.\n                (transform_is_safe): Remove.\n                (graphite_legal_transform): Remove.\n                * graphite-poly.h (graphite_legal_transform): Remove.\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r228530", "tree": {"sha": "d89873c73313f7541bcc29c41250cd80e758829d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d89873c73313f7541bcc29c41250cd80e758829d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaec70cd8bb0d06d550878428a961a41e755f213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaec70cd8bb0d06d550878428a961a41e755f213", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaec70cd8bb0d06d550878428a961a41e755f213", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaec70cd8bb0d06d550878428a961a41e755f213/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "216cc294ef714ffc4634e7ac6139550515acae3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/216cc294ef714ffc4634e7ac6139550515acae3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/216cc294ef714ffc4634e7ac6139550515acae3a"}], "stats": {"total": 269, "additions": 12, "deletions": 257}, "files": [{"sha": "c6bc7011dd6fa63e3645f3caa19f994158ff9c79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec70cd8bb0d06d550878428a961a41e755f213/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec70cd8bb0d06d550878428a961a41e755f213/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eaec70cd8bb0d06d550878428a961a41e755f213", "patch": "@@ -1,3 +1,14 @@\n+2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* graphite-dependences.c (scop_get_transformed_schedule): Remove.\n+\t(no_violations): Remove.\n+\t(subtract_commutative_associative_deps): Remove.\n+\t(compute_deps): Do not call subtract_commutative_associative_deps.\n+\t(transform_is_safe): Remove.\n+\t(graphite_legal_transform): Remove.\n+\t* graphite-poly.h (graphite_legal_transform): Remove.\n+\n 2015-10-05  Aditya Kumar  <hiraditya@msn.com>\n \n \t* graphite-sese-to-poly.c (build_loop_iteration_domains): Only loops"}, {"sha": "8829cb40ef7256af3e33a008b6d1b368b5597a94", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 1, "deletions": 254, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec70cd8bb0d06d550878428a961a41e755f213/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec70cd8bb0d06d550878428a961a41e755f213/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=eaec70cd8bb0d06d550878428a961a41e755f213", "patch": "@@ -154,26 +154,6 @@ scop_get_original_schedule (scop_p scop, vec<poly_bb_p> pbbs)\n   return res;\n }\n \n-/* Returns all the transformed schedules in SCOP.  */\n-\n-static isl_union_map *\n-scop_get_transformed_schedule (scop_p scop, vec<poly_bb_p> pbbs)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-  isl_space *space = isl_set_get_space (scop->param_context);\n-  isl_union_map *res = isl_union_map_empty (space);\n-\n-  FOR_EACH_VEC_ELT (pbbs, i, pbb)\n-    {\n-      res = isl_union_map_add_map\n-\t(res, constrain_domain (isl_map_copy (pbb->transformed),\n-\t\t\t\tisl_set_copy (pbb->domain)));\n-    }\n-\n-  return res;\n-}\n-\n /* Helper function used on each MAP of a isl_union_map.  Computes the\n    maximal output dimension.  */\n \n@@ -262,33 +242,6 @@ apply_schedule_on_deps (__isl_keep isl_union_map *schedule,\n   return x;\n }\n \n-/* Return true when SCHEDULE does not violate the data DEPS: that is\n-   when the intersection of LEX with the DEPS transformed by SCHEDULE\n-   is empty.  LEX is the relation in which the outputs occur before\n-   the inputs.  */\n-\n-static bool\n-no_violations (__isl_keep isl_union_map *schedule,\n-\t       __isl_keep isl_union_map *deps)\n-{\n-  bool res;\n-  isl_space *space;\n-  isl_map *lex, *x;\n-\n-  if (isl_union_map_is_empty (deps))\n-    return true;\n-\n-  x = apply_schedule_on_deps (schedule, deps);\n-  space = isl_map_get_space (x);\n-  space = isl_space_range (space);\n-  lex = isl_map_lex_ge (space);\n-  x = isl_map_intersect (x, lex);\n-  res = isl_map_is_empty (x);\n-\n-  isl_map_free (x);\n-  return res;\n-}\n-\n /* Return true when DEPS is non empty and the intersection of LEX with\n    the DEPS transformed by SCHEDULE is non empty.  LEX is the relation\n    in which all the inputs before DEPTH occur at the same time as the\n@@ -332,161 +285,6 @@ carries_deps (__isl_keep isl_union_map *schedule,\n   return res;\n }\n \n-/* Subtract from the RAW, WAR, and WAW dependences those relations\n-   that have been marked as belonging to an associative commutative\n-   reduction.  */\n-\n-static void\n-subtract_commutative_associative_deps (scop_p scop,\n-\t\t\t\t       vec<poly_bb_p> pbbs,\n-\t\t\t\t       isl_union_map *original,\n-\t\t\t\t       isl_union_map **must_raw,\n-\t\t\t\t       isl_union_map **may_raw,\n-\t\t\t\t       isl_union_map **must_raw_no_source,\n-\t\t\t\t       isl_union_map **may_raw_no_source,\n-\t\t\t\t       isl_union_map **must_war,\n-\t\t\t\t       isl_union_map **may_war,\n-\t\t\t\t       isl_union_map **must_war_no_source,\n-\t\t\t\t       isl_union_map **may_war_no_source,\n-\t\t\t\t       isl_union_map **must_waw,\n-\t\t\t\t       isl_union_map **may_waw,\n-\t\t\t\t       isl_union_map **must_waw_no_source,\n-\t\t\t\t       isl_union_map **may_waw_no_source)\n-{\n-  int i, j;\n-  poly_bb_p pbb;\n-  poly_dr_p pdr;\n-  isl_space *space = isl_set_get_space (scop->param_context);\n-\n-  FOR_EACH_VEC_ELT (pbbs, i, pbb)\n-    if (PBB_IS_REDUCTION (pbb))\n-      {\n-\tisl_union_map *r = isl_union_map_empty (isl_space_copy (space));\n-\tisl_union_map *must_w = isl_union_map_empty (isl_space_copy (space));\n-\tisl_union_map *may_w = isl_union_map_empty (isl_space_copy (space));\n-\tisl_union_map *all_w;\n-\tisl_union_map *empty;\n-\tisl_union_map *x_must_raw;\n-\tisl_union_map *x_may_raw;\n-\tisl_union_map *x_must_raw_no_source;\n-\tisl_union_map *x_may_raw_no_source;\n-\tisl_union_map *x_must_war;\n-\tisl_union_map *x_may_war;\n-\tisl_union_map *x_must_war_no_source;\n-\tisl_union_map *x_may_war_no_source;\n-\tisl_union_map *x_must_waw;\n-\tisl_union_map *x_may_waw;\n-\tisl_union_map *x_must_waw_no_source;\n-\tisl_union_map *x_may_waw_no_source;\n-\n-\tFOR_EACH_VEC_ELT (PBB_DRS (pbb), j, pdr)\n-\t  if (pdr_read_p (pdr))\n-\t    r = isl_union_map_add_map (r, add_pdr_constraints (pdr, pbb));\n-\n-\tFOR_EACH_VEC_ELT (PBB_DRS (pbb), j, pdr)\n-\t  if (pdr_write_p (pdr))\n-\t    must_w = isl_union_map_add_map (must_w,\n-\t\t\t\t\t    add_pdr_constraints (pdr, pbb));\n-\n-\tFOR_EACH_VEC_ELT (PBB_DRS (pbb), j, pdr)\n-\t  if (pdr_may_write_p (pdr))\n-\t    may_w = isl_union_map_add_map (may_w,\n-\t\t\t\t\t   add_pdr_constraints (pdr, pbb));\n-\n-\tall_w = isl_union_map_union\n-\t  (isl_union_map_copy (must_w), isl_union_map_copy (may_w));\n-\tempty = isl_union_map_empty (isl_union_map_get_space (all_w));\n-\n-\tisl_union_map_compute_flow (isl_union_map_copy (r),\n-\t\t\t\t    isl_union_map_copy (must_w),\n-\t\t\t\t    isl_union_map_copy (may_w),\n-\t\t\t\t    isl_union_map_copy (original),\n-\t\t\t\t    &x_must_raw, &x_may_raw,\n-\t\t\t\t    &x_must_raw_no_source,\n-\t\t\t\t    &x_may_raw_no_source);\n-\tisl_union_map_compute_flow (isl_union_map_copy (all_w),\n-\t\t\t\t    r, empty,\n-\t\t\t\t    isl_union_map_copy (original),\n-\t\t\t\t    &x_must_war, &x_may_war,\n-\t\t\t\t    &x_must_war_no_source,\n-\t\t\t\t    &x_may_war_no_source);\n-\tisl_union_map_compute_flow (all_w, must_w, may_w,\n-\t\t\t\t    isl_union_map_copy (original),\n-\t\t\t\t    &x_must_waw, &x_may_waw,\n-\t\t\t\t    &x_must_waw_no_source,\n-\t\t\t\t    &x_may_waw_no_source);\n-\n-\tif (must_raw)\n-\t  *must_raw = isl_union_map_subtract (*must_raw, x_must_raw);\n-\telse\n-\t  isl_union_map_free (x_must_raw);\n-\n-\tif (may_raw)\n-\t  *may_raw = isl_union_map_subtract (*may_raw, x_may_raw);\n-\telse\n-\t  isl_union_map_free (x_may_raw);\n-\n-\tif (must_raw_no_source)\n-\t  *must_raw_no_source = isl_union_map_subtract (*must_raw_no_source,\n-\t\t\t\t\t\t        x_must_raw_no_source);\n-\telse\n-\t  isl_union_map_free (x_must_raw_no_source);\n-\n-\tif (may_raw_no_source)\n-\t  *may_raw_no_source = isl_union_map_subtract (*may_raw_no_source,\n-\t\t\t\t\t\t       x_may_raw_no_source);\n-\telse\n-\t  isl_union_map_free (x_may_raw_no_source);\n-\n-\tif (must_war)\n-\t  *must_war = isl_union_map_subtract (*must_war, x_must_war);\n-\telse\n-\t  isl_union_map_free (x_must_war);\n-\n-\tif (may_war)\n-\t  *may_war = isl_union_map_subtract (*may_war, x_may_war);\n-\telse\n-\t  isl_union_map_free (x_may_war);\n-\n-\tif (must_war_no_source)\n-\t  *must_war_no_source = isl_union_map_subtract (*must_war_no_source,\n-\t\t\t\t\t\t        x_must_war_no_source);\n-\telse\n-\t  isl_union_map_free (x_must_war_no_source);\n-\n-\tif (may_war_no_source)\n-\t  *may_war_no_source = isl_union_map_subtract (*may_war_no_source,\n-\t\t\t\t\t\t       x_may_war_no_source);\n-\telse\n-\t  isl_union_map_free (x_may_war_no_source);\n-\n-\tif (must_waw)\n-\t  *must_waw = isl_union_map_subtract (*must_waw, x_must_waw);\n-\telse\n-\t  isl_union_map_free (x_must_waw);\n-\n-\tif (may_waw)\n-\t  *may_waw = isl_union_map_subtract (*may_waw, x_may_waw);\n-\telse\n-\t  isl_union_map_free (x_may_waw);\n-\n-\tif (must_waw_no_source)\n-\t  *must_waw_no_source = isl_union_map_subtract (*must_waw_no_source,\n-\t\t\t\t\t\t        x_must_waw_no_source);\n-\telse\n-\t  isl_union_map_free (x_must_waw_no_source);\n-\n-\tif (may_waw_no_source)\n-\t  *may_waw_no_source = isl_union_map_subtract (*may_waw_no_source,\n-\t\t\t\t\t\t       x_may_waw_no_source);\n-\telse\n-\t  isl_union_map_free (x_may_waw_no_source);\n-      }\n-\n-  isl_union_map_free (original);\n-  isl_space_free (space);\n-}\n-\n /* Compute the original data dependences in SCOP for all the reads and\n    writes in PBBS.  */\n \n@@ -526,44 +324,9 @@ compute_deps (scop_p scop, vec<poly_bb_p> pbbs,\n \t\t\t      must_war, may_war, must_war_no_source,\n \t\t\t      may_war_no_source);\n   isl_union_map_compute_flow (all_writes, must_writes, may_writes,\n-\t\t\t      isl_union_map_copy (original),\n+\t\t\t      original,\n \t\t\t      must_waw, may_waw, must_waw_no_source,\n \t\t\t      may_waw_no_source);\n-\n-  subtract_commutative_associative_deps\n-    (scop, pbbs, original,\n-     must_raw, may_raw, must_raw_no_source, may_raw_no_source,\n-     must_war, may_war, must_war_no_source, may_war_no_source,\n-     must_waw, may_waw, must_waw_no_source, may_waw_no_source);\n-}\n-\n-/* Given a TRANSFORM, check whether it respects the original\n-   dependences in SCOP.  Returns true when TRANSFORM is a safe\n-   transformation.  */\n-\n-static bool\n-transform_is_safe (scop_p scop, isl_union_map *transform)\n-{\n-  bool res;\n-\n-  if (!scop->must_raw)\n-    compute_deps (scop, SCOP_BBS (scop),\n-\t\t  &scop->must_raw, &scop->may_raw,\n-\t\t  &scop->must_raw_no_source, &scop->may_raw_no_source,\n-\t\t  &scop->must_war, &scop->may_war,\n-\t\t  &scop->must_war_no_source, &scop->may_war_no_source,\n-\t\t  &scop->must_waw, &scop->may_waw,\n-\t\t  &scop->must_waw_no_source, &scop->may_waw_no_source);\n-\n-  res = (no_violations (transform, scop->must_raw)\n-\t && no_violations (transform, scop->may_raw)\n-\t && no_violations (transform, scop->must_war)\n-\t && no_violations (transform, scop->may_war)\n-\t && no_violations (transform, scop->must_waw)\n-\t && no_violations (transform, scop->may_waw));\n-\n-  isl_union_map_free (transform);\n-  return res;\n }\n \n isl_union_map *\n@@ -595,20 +358,4 @@ scop_get_dependences (scop_p scop)\n   return dependences;\n }\n \n-/* Return true when the SCOP transformed schedule is correct.  */\n-\n-bool\n-graphite_legal_transform (scop_p scop)\n-{\n-  int res;\n-  isl_union_map *transform;\n-\n-  timevar_push (TV_GRAPHITE_DATA_DEPS);\n-  transform = scop_get_transformed_schedule (scop, SCOP_BBS (scop));\n-  res = transform_is_safe (scop, transform);\n-  timevar_pop (TV_GRAPHITE_DATA_DEPS);\n-\n-  return res;\n-}\n-\n #endif /* HAVE_isl */"}, {"sha": "982fa94894903b6bd2caa08383c1c54cc20dd48c", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec70cd8bb0d06d550878428a961a41e755f213/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec70cd8bb0d06d550878428a961a41e755f213/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=eaec70cd8bb0d06d550878428a961a41e755f213", "patch": "@@ -436,7 +436,6 @@ extern void print_generated_program (FILE *, scop_p);\n extern void debug_generated_program (scop_p);\n extern int unify_scattering_dimensions (scop_p);\n extern bool apply_poly_transforms (scop_p);\n-extern bool graphite_legal_transform (scop_p);\n \n /* Set the region of SCOP to REGION.  */\n \n@@ -462,8 +461,6 @@ scop_set_nb_params (scop_p scop, graphite_dim_t nb_params)\n   scop->nb_params = nb_params;\n }\n \n-bool graphite_legal_transform (scop_p);\n-\n isl_union_map *\n scop_get_dependences (scop_p scop);\n "}]}