{"sha": "aa4759c11cc78443455b69fca236c24ff89c91a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE0NzU5YzExY2M3ODQ0MzQ1NWI2OWZjYTIzNmMyNGZmODljOTFhMQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@cygnus.com", "date": "1999-07-21T14:28:33Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "1999-07-21T14:28:33Z"}, "message": "lang.c (flag_use_divide_subroutine): New variable.\n\n1999-07-15  Andrew Haley  <aph@cygnus.com>\n\n        * lang.c (flag_use_divide_subroutine): New variable.\n        * typeck.c: (convert_ieee_real_to_integer): Bounds check\n        fp-to-integer conversion.\n        (convert): Call convert_ieee_real_to_integer when flag_fast_math\n        is not set.\n\n        * expr.c (build_java_soft_divmod): New function.\n        (build_java_binop): Call build_java_soft_divmod if\n        flag_use_divide_subroutine is set.\n        * decl.c: soft_idiv_node, soft_irem_node, soft_ldiv_node, tree\n        soft_lrem_node: new builtin functions.\n        (init_decl_processing) Initialize the new builtins.\n        * java-tree.h soft_idiv_node, soft_irem_node, soft_ldiv_node, tree\n        soft_lrem_node: new builtin functions.\n        (build_java_soft_divmod): New function.\n        * parse.y: Call build_java_soft_divmod if\n        flag_use_divide_subroutine is set.\n\nFrom-SVN: r28208", "tree": {"sha": "7a86e6410656ef434107be5353da306f7adf35c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a86e6410656ef434107be5353da306f7adf35c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa4759c11cc78443455b69fca236c24ff89c91a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4759c11cc78443455b69fca236c24ff89c91a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa4759c11cc78443455b69fca236c24ff89c91a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4759c11cc78443455b69fca236c24ff89c91a1/comments", "author": null, "committer": null, "parents": [{"sha": "9c1ce4332e0bfc9289296fde205af0eb3a21e50b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c1ce4332e0bfc9289296fde205af0eb3a21e50b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c1ce4332e0bfc9289296fde205af0eb3a21e50b"}], "stats": {"total": 172, "additions": 153, "deletions": 19}, "files": [{"sha": "372d294414fa3372e72be84e8d0dba6e079628d2", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=aa4759c11cc78443455b69fca236c24ff89c91a1", "patch": "@@ -1,3 +1,23 @@\n+1999-07-15  Andrew Haley  <aph@cygnus.com>\n+\n+\t* lang.c (flag_use_divide_subroutine): New variable.\n+\t* typeck.c: (convert_ieee_real_to_integer): Bounds check\n+\tfp-to-integer conversion.\n+\t(convert): Call convert_ieee_real_to_integer when flag_fast_math\n+\tis not set.\n+\n+\t* expr.c (build_java_soft_divmod): New function.\n+\t(build_java_binop): Call build_java_soft_divmod if\n+\tflag_use_divide_subroutine is set.\n+\t* decl.c: soft_idiv_node, soft_irem_node, soft_ldiv_node, tree\n+\tsoft_lrem_node: new builtin functions.\n+\t(init_decl_processing) Initialize the new builtins.\n+\t* java-tree.h soft_idiv_node, soft_irem_node, soft_ldiv_node, tree\n+\tsoft_lrem_node: new builtin functions.\n+\t(build_java_soft_divmod): New function.\n+\t* parse.y: Call build_java_soft_divmod if\n+\tflag_use_divide_subroutine is set.\n+\t\n Tue Jul 20 13:20:05 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (resolve_and_layout): Check methods only once."}, {"sha": "6779747c6aad59e5d3a49882363af0145118268f", "filename": "gcc/java/decl.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=aa4759c11cc78443455b69fca236c24ff89c91a1", "patch": "@@ -365,6 +365,11 @@ tree soft_monitorexit_node;\n tree soft_lookupinterfacemethod_node;\n tree soft_fmod_node;\n tree soft_exceptioninfo_call_node;\n+tree soft_idiv_node;\n+tree soft_irem_node;\n+tree soft_ldiv_node;\n+tree soft_lrem_node;\n+\n \n /* Build (and pushdecl) a \"promoted type\" for all standard\n    types shorter than int.  */\n@@ -812,6 +817,26 @@ init_decl_processing ()\n \t\t\tBUILT_IN_FMOD, \"fmodf\");\n #endif\n     \n+  soft_idiv_node\n+    = builtin_function (\"_Jv_divI\",\n+\t\t\tbuild_function_type (int_type_node, t),\n+\t\t\tNOT_BUILT_IN, NULL_PTR);\n+\n+  soft_irem_node\n+    = builtin_function (\"_Jv_remI\",\n+\t\t\tbuild_function_type (int_type_node, t),\n+\t\t\tNOT_BUILT_IN, NULL_PTR);\n+\n+  soft_ldiv_node\n+    = builtin_function (\"_Jv_divJ\",\n+\t\t\tbuild_function_type (long_type_node, t),\n+\t\t\tNOT_BUILT_IN, NULL_PTR);\n+\n+  soft_lrem_node\n+    = builtin_function (\"_Jv_remJ\",\n+\t\t\tbuild_function_type (long_type_node, t),\n+\t\t\tNOT_BUILT_IN, NULL_PTR);\n+\n   init_class_processing ();\n }\n "}, {"sha": "dbf6db55b7ce9e9ea9afd0bb936d52ef8d301b94", "filename": "gcc/java/expr.c", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=aa4759c11cc78443455b69fca236c24ff89c91a1", "patch": "@@ -1052,6 +1052,53 @@ expand_iinc (local_var_index, ival, pc)\n     expand_assignment (local_var, res, 0, 0);\n }\n \n+      \n+tree\n+build_java_soft_divmod (op, type, op1, op2)\n+    enum tree_code op;\n+    tree type, op1, op2;\n+{\n+  tree call = NULL;\n+  tree arg1 = convert (type, op1);\n+  tree arg2 = convert (type, op2);\n+\n+  if (type == int_type_node)\n+    {\t  \n+      switch (op)\n+\t{\n+\tcase TRUNC_DIV_EXPR:\n+\t  call = soft_idiv_node;\n+\t  break;\n+\tcase TRUNC_MOD_EXPR:\n+\t  call = soft_irem_node;\n+\t  break;\n+\t}\n+    }\n+  else if (type == long_type_node)\n+    {\t  \n+      switch (op)\n+\t{\n+\tcase TRUNC_DIV_EXPR:\n+\t  call = soft_ldiv_node;\n+\t  break;\n+\tcase TRUNC_MOD_EXPR:\n+\t  call = soft_lrem_node;\n+\t  break;\n+\t}\n+    }\n+\n+  if (! call)\n+    fatal (\"Internal compiler error in build_java_soft_divmod\");\n+\t\t  \n+  call = build (CALL_EXPR, type,\n+\t\tbuild_address_of (call),\n+\t\ttree_cons (NULL_TREE, arg1,\n+\t\t\t   build_tree_list (NULL_TREE, arg2)),\n+\t\tNULL_TREE);\n+\t  \n+  return call;\n+}\n+\n tree\n build_java_binop (op, type, arg1, arg2)\n      enum tree_code op;\n@@ -1100,10 +1147,11 @@ build_java_binop (op, type, arg1, arg2)\n \t\t\t\t\t    integer_zero_node));\n \treturn fold (build (COND_EXPR, int_type_node,\n \t\t\t    ifexp1, integer_negative_one_node, second_compare));\n-      }\n-\n+      }      \n+    case TRUNC_DIV_EXPR:\n     case TRUNC_MOD_EXPR:\n-      if (TREE_CODE (type) == REAL_TYPE)\n+      if (TREE_CODE (type) == REAL_TYPE\n+\t  && op == TRUNC_MOD_EXPR)\n \t{\n \t  tree call;\n \t  if (type != double_type_node)\n@@ -1120,6 +1168,12 @@ build_java_binop (op, type, arg1, arg2)\n \t    call = convert (type, call);\n \t  return call;\n \t}\n+      \n+      if (TREE_CODE (type) == INTEGER_TYPE\n+\t  && flag_use_divide_subroutine\n+\t  && ! flag_syntax_only)\n+\treturn build_java_soft_divmod (op, type, arg1, arg2);\n+      \n       break;\n     default:  ;\n     }"}, {"sha": "307218c238044c87e2ae142d749a893eca50956b", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=aa4759c11cc78443455b69fca236c24ff89c91a1", "patch": "@@ -141,6 +141,9 @@ extern int flag_redundant;\n extern int flag_not_overriding;\n extern int flag_static_local_jdk1_1;\n \n+/* When non zero, call a library routine to do integer divisions. */\n+extern int flag_use_divide_subroutine;\n+\n /* The Java .class file that provides main_class;  the main input file. */\n extern struct JCF *current_jcf;\n \n@@ -283,6 +286,10 @@ extern tree soft_monitorexit_node;\n extern tree soft_lookupinterfacemethod_node;\n extern tree soft_fmod_node;\n extern tree soft_exceptioninfo_call_node;\n+extern tree soft_idiv_node;\n+extern tree soft_irem_node;\n+extern tree soft_ldiv_node;\n+extern tree soft_lrem_node;\n \n extern tree access_flags_type_node;\n \n@@ -544,6 +551,7 @@ extern tree invoke_build_dtable PROTO ((int, tree));\n extern tree build_field_ref PROTO ((tree, tree, tree));\n extern void pushdecl_force_head PROTO ((tree));\n extern tree build_java_binop PROTO ((enum tree_code, tree, tree, tree));\n+extern tree build_java_soft_divmod PROTO ((enum tree_code, tree, tree, tree));\n extern tree binary_numeric_promotion PROTO ((tree, tree, tree *, tree *));\n extern tree build_java_arrayaccess PROTO ((tree, tree, tree));\n extern tree build_newarray PROTO ((int, tree));"}, {"sha": "976ed64ab232b6821003bf862f6667cb426cdf8c", "filename": "gcc/java/lang.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=aa4759c11cc78443455b69fca236c24ff89c91a1", "patch": "@@ -105,6 +105,9 @@ int flag_not_overriding = 0;\n /* When non zero, warns that final local are treated as non final.  */\n int flag_static_local_jdk1_1 = 0;\n \n+/* When non zero, call a library routine to do integer divisions. */\n+int flag_use_divide_subroutine = 1;\n+\n /* From gcc/flags.h, and indicates if exceptions are turned on or not.  */\n \n extern int flag_new_exceptions;\n@@ -123,6 +126,7 @@ lang_f_options[] =\n   {\"assume-compiled\", &flag_assume_compiled, 1},\n   {\"emit-class-file\", &flag_emit_class_files, 1},\n   {\"emit-class-files\", &flag_emit_class_files, 1},\n+  {\"use-divide-subroutine\", &flag_use_divide_subroutine, 1},\n };\n \n JCF *current_jcf;"}, {"sha": "23b2c7ad03cf9e3f94efcb46d911b81b1f7e6d73", "filename": "gcc/java/parse.y", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=aa4759c11cc78443455b69fca236c24ff89c91a1", "patch": "@@ -9411,6 +9411,12 @@ patch_binop (node, wfl_op1, wfl_op2)\n       if (code == RDIV_EXPR && TREE_CODE (prom_type) == INTEGER_TYPE)\n \tTREE_SET_CODE (node, TRUNC_DIV_EXPR);\n \n+      if (TREE_CODE (prom_type) == INTEGER_TYPE\n+\t  && flag_use_divide_subroutine\n+\t  && ! flag_emit_class_files\n+\t  && (code == RDIV_EXPR || code == TRUNC_MOD_EXPR))\n+\treturn build_java_soft_divmod (TREE_CODE (node), prom_type, op1, op2);\n+ \n       /* This one is more complicated. FLOATs are processed by a\n \t function call to soft_fmod. Duplicate the value of the\n \t COMPOUND_ASSIGN_P flag. */"}, {"sha": "99536ffa146677ef6882299c25a35aaf0dd1c4c1", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4759c11cc78443455b69fca236c24ff89c91a1/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=aa4759c11cc78443455b69fca236c24ff89c91a1", "patch": "@@ -55,23 +55,43 @@ set_local_type (slot, type)\n \n /* Convert an IEEE real to an integer type.  The result of such a\n    conversion when the source operand is a NaN isn't defined by\n-   IEEE754, but by the Java language standard: it must be zero.  This\n-   conversion produces something like:\n-   \n-   ({ double tmp = expr; (tmp != tmp) ? 0 : (int)tmp; })\n-\n-   */\n+   IEEE754, but by the Java language standard: it must be zero.  Also,\n+   overflows must be clipped to within range.  This conversion\n+   produces something like:\n+\n+      ((expr >= (float)MAX_INT)\n+       ? MAX_INT \n+       : ((expr <= (float)MIN_INT)\n+\t  ? MIN_INT\n+\t  : ((expr != expr)\n+\t     ? 0 \n+\t     : (int)expr))) */\n \n static tree\n convert_ieee_real_to_integer (type, expr)\n      tree type, expr;\n {\n+  tree result;\n   expr = save_expr (expr);\n \n-  return build (COND_EXPR, type, \n-\t\tbuild (NE_EXPR, boolean_type_node, expr, expr),\n-\t\tconvert (type, integer_zero_node),\n-\t\tconvert_to_integer (type, expr));\n+  result = build (COND_EXPR, type,\n+\t\t  build (NE_EXPR, boolean_type_node, expr, expr),\n+\t\t  convert (type, integer_zero_node),\n+\t\t  convert_to_integer (type, expr));\n+\t\t  \n+  result = build (COND_EXPR, type, \n+\t\t  build (LE_EXPR, boolean_type_node, expr, \n+\t\t\t convert (TREE_TYPE (expr), TYPE_MIN_VALUE (type))),\n+\t\t  TYPE_MIN_VALUE (type),\n+\t\t  result);\n+\n+  result = build (COND_EXPR, type,\n+\t\t  build (GE_EXPR, boolean_type_node, expr, \n+\t\t\t convert (TREE_TYPE (expr), TYPE_MAX_VALUE (type))),\t\n+\t\t  TYPE_MAX_VALUE (type),\n+\t\t  result);\n+\n+  return result;\n }  \n \n /* Create an expression whose value is that of EXPR,\n@@ -100,12 +120,9 @@ convert (type, expr)\n     return fold (convert_to_boolean (type, expr));\n   if (code == INTEGER_TYPE)\n     {\n-      if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n-#ifdef TARGET_SOFT_FLOAT\n-\t  && !TARGET_SOFT_FLOAT\n-#endif\n-\t  && !flag_emit_class_files\n-\t  && !flag_fast_math\n+      if (! flag_fast_math\n+\t  && ! flag_emit_class_files\n+\t  && TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n \t  && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n \treturn fold (convert_ieee_real_to_integer (type, expr));\n       else"}]}