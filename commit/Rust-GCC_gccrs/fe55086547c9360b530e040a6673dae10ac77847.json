{"sha": "fe55086547c9360b530e040a6673dae10ac77847", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU1NTA4NjU0N2M5MzYwYjUzMGUwNDBhNjY3M2RhZTEwYWM3Nzg0Nw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-02-15T15:09:27Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-03-05T16:55:16Z"}, "message": "coroutines : Handle exceptions throw before the first await_resume() [PR95615].\n\nThe coroutine body is wrapped in a try-catch block which is responsible for\nhandling any exceptions thrown by the original function body.  Originally, the\ninitial suspend expression was outside this, but an amendement to the standard\nplaces the await_resume call inside and eveything else outside.\n\nThis means that any exception thrown prior to the initial suspend expression\nawait_resume() will propagate to the ramp function.  However, some portion of\nthe coroutine state will exist at that point (how much depends on where the\nexception is thrown from).  For example, we might have some frame parameter\ncopies, or the promise object or the return object any of which might have a\nnon-trivial DTOR.  Also the frame itself needs to be deallocated. This patch\nfixes the handling of these cases.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95615\n\t* coroutines.cc (struct param_info): Track parameter copies that need\n\ta DTOR.\n\t(coro_get_frame_dtor): New helper function factored from build_actor().\n\t(build_actor_fn): Use coro_get_frame_dtor().\n\t(morph_fn_to_coro): Track parameters that need DTORs on exception,\n\tlikewise the frame promise and the return object.  On exception, run the\n\tDTORs for these, destroy the frame and then rethrow the exception.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95615\n\t* g++.dg/coroutines/torture/pr95615-01.C: New test.\n\t* g++.dg/coroutines/torture/pr95615-02.C: New test.\n\t* g++.dg/coroutines/torture/pr95615-03.C: New test.\n\t* g++.dg/coroutines/torture/pr95615-04.C: New test.\n\t* g++.dg/coroutines/torture/pr95615-05.C: New test.", "tree": {"sha": "9cd6ec75144d83d20311bd8574798ab8986e4ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cd6ec75144d83d20311bd8574798ab8986e4ea4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe55086547c9360b530e040a6673dae10ac77847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe55086547c9360b530e040a6673dae10ac77847", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe55086547c9360b530e040a6673dae10ac77847", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe55086547c9360b530e040a6673dae10ac77847/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9105757a59b890194ebf5b4fcbacd58db34ef332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9105757a59b890194ebf5b4fcbacd58db34ef332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9105757a59b890194ebf5b4fcbacd58db34ef332"}], "stats": {"total": 475, "additions": 406, "deletions": 69}, "files": [{"sha": "3f88b077d082b01756c3523c7a4641dc6bb544d6", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 258, "deletions": 69, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=fe55086547c9360b530e040a6673dae10ac77847", "patch": "@@ -1815,6 +1815,8 @@ struct param_info\n   vec<tree *> *body_uses; /* Worklist of uses, void if there are none.  */\n   tree frame_type;   /* The type used to represent this parm in the frame.  */\n   tree orig_type;    /* The original type of the parm (not as passed).  */\n+  tree guard_var;    /* If we need a DTOR on exception, this bool guards it.  */\n+  tree fr_copy_dtor; /* If we need a DTOR on exception, this is it.  */\n   bool by_ref;       /* Was passed by reference.  */\n   bool pt_ref;       /* Was a pointer to object.  */\n   bool rv_ref;       /* Was an rvalue ref.  */\n@@ -1987,6 +1989,73 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n   return NULL_TREE;\n }\n \n+/* A helper to build the frame DTOR.\n+   [dcl.fct.def.coroutine] / 12\n+   The deallocation function\u2019s name is looked up in the scope of the promise\n+   type.  If this lookup fails, the deallocation function\u2019s name is looked up\n+   in the global scope.  If deallocation function lookup finds both a usual\n+   deallocation function with only a pointer parameter and a usual\n+   deallocation function with both a pointer parameter and a size parameter,\n+   then the selected deallocation function shall be the one with two\n+   parameters.  Otherwise, the selected deallocation function shall be the\n+   function with one parameter.  If no usual deallocation function is found\n+   the program is ill-formed.  The selected deallocation function shall be\n+   called with the address of the block of storage to be reclaimed as its\n+   first argument.  If a deallocation function with a parameter of type\n+   std::size_t is used, the size of the block is passed as the corresponding\n+   argument.  */\n+\n+static tree\n+coro_get_frame_dtor (tree coro_fp, tree orig, tree frame_size,\n+\t\t     tree promise_type, location_t loc)\n+{\n+  tree del_coro_fr = NULL_TREE;\n+  tree frame_arg = build1 (CONVERT_EXPR, ptr_type_node, coro_fp);\n+  tree delname = ovl_op_identifier (false, DELETE_EXPR);\n+  tree fns = lookup_promise_method (orig, delname, loc,\n+\t\t\t\t\t/*musthave=*/false);\n+  if (fns && BASELINK_P (fns))\n+    {\n+      /* Look for sized version first, since this takes precedence.  */\n+      vec<tree, va_gc> *args = make_tree_vector ();\n+      vec_safe_push (args, frame_arg);\n+      vec_safe_push (args, frame_size);\n+      tree dummy_promise = build_dummy_object (promise_type);\n+\n+      /* It's OK to fail for this one... */\n+      del_coro_fr = build_new_method_call (dummy_promise, fns, &args,\n+\t\t\t\t\t   NULL_TREE, LOOKUP_NORMAL, NULL,\n+\t\t\t\t\t   tf_none);\n+\n+      if (!del_coro_fr || del_coro_fr == error_mark_node)\n+\t{\n+\t  release_tree_vector (args);\n+\t  args = make_tree_vector_single (frame_arg);\n+\t  del_coro_fr = build_new_method_call (dummy_promise, fns, &args,\n+\t\t\t\t\t       NULL_TREE, LOOKUP_NORMAL, NULL,\n+\t\t\t\t\t       tf_none);\n+\t}\n+\n+      /* But one of them must succeed, or the program is ill-formed.  */\n+      if (!del_coro_fr || del_coro_fr == error_mark_node)\n+\t{\n+\t  error_at (loc, \"%qE is provided by %qT but is not usable with\"\n+\t\t  \" the function signature %qD\", delname, promise_type, orig);\n+\t  del_coro_fr = error_mark_node;\n+\t}\n+    }\n+  else\n+    {\n+      del_coro_fr = build_op_delete_call (DELETE_EXPR, frame_arg, frame_size,\n+\t\t\t\t\t  /*global_p=*/true, /*placement=*/NULL,\n+\t\t\t\t\t  /*alloc_fn=*/NULL,\n+\t\t\t\t\t  tf_warning_or_error);\n+      if (!del_coro_fr || del_coro_fr == error_mark_node)\n+\tdel_coro_fr = error_mark_node;\n+    }\n+  return del_coro_fr;\n+}\n+\n /* The actor transform.  */\n \n static void\n@@ -2283,68 +2352,10 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \t}\n     }\n \n-  /* [dcl.fct.def.coroutine] / 12\n-     The deallocation function\u2019s name is looked up in the scope of the promise\n-     type.  If this lookup fails, the deallocation function\u2019s name is looked up\n-     in the global scope.  If deallocation function lookup finds both a usual\n-     deallocation function with only a pointer parameter and a usual\n-     deallocation function with both a pointer parameter and a size parameter,\n-     then the selected deallocation function shall be the one with two\n-     parameters.  Otherwise, the selected deallocation function shall be the\n-     function with one parameter.  If no usual deallocation function is found\n-     the program is ill-formed.  The selected deallocation function shall be\n-     called with the address of the block of storage to be reclaimed as its\n-     first argument.  If a deallocation function with a parameter of type\n-     std::size_t is used, the size of the block is passed as the corresponding\n-     argument.  */\n-\n-  tree del_coro_fr = NULL_TREE;\n-  tree frame_arg = build1 (CONVERT_EXPR, ptr_type_node, actor_fp);\n-\n-  tree delname = ovl_op_identifier (false, DELETE_EXPR);\n-  tree fns = lookup_promise_method (orig, delname, loc, /*musthave=*/false);\n-  if (fns && BASELINK_P (fns))\n-    {\n-      /* Look for sized version first, since this takes precedence.  */\n-      vec<tree, va_gc> *args = make_tree_vector ();\n-      vec_safe_push (args, frame_arg);\n-      vec_safe_push (args, frame_size);\n-      tree dummy_promise = build_dummy_object (promise_type);\n-\n-      /* It's OK to fail for this one... */\n-      del_coro_fr = build_new_method_call (dummy_promise, fns, &args,\n-\t\t\t\t\t   NULL_TREE, LOOKUP_NORMAL, NULL,\n-\t\t\t\t\t   tf_none);\n-\n-      if (!del_coro_fr || del_coro_fr == error_mark_node)\n-\t{\n-\t  release_tree_vector (args);\n-\t  args = make_tree_vector_single (frame_arg);\n-\t  del_coro_fr = build_new_method_call (dummy_promise, fns, &args,\n-\t\t\t\t\t       NULL_TREE, LOOKUP_NORMAL, NULL,\n-\t\t\t\t\t       tf_none);\n-\t}\n-\n-      /* But one of them must succeed, or the program is ill-formed.  */\n-      if (!del_coro_fr || del_coro_fr == error_mark_node)\n-\t{\n-\t  error_at (loc, \"%qE is provided by %qT but is not usable with\"\n-\t\t  \" the function signature %qD\", delname, promise_type, orig);\n-\t  del_coro_fr = error_mark_node;\n-\t}\n-    }\n-  else\n-    {\n-      del_coro_fr = build_op_delete_call (DELETE_EXPR, frame_arg, frame_size,\n-\t\t\t\t\t  /*global_p=*/true, /*placement=*/NULL,\n-\t\t\t\t\t  /*alloc_fn=*/NULL,\n-\t\t\t\t\t  tf_warning_or_error);\n-      if (!del_coro_fr || del_coro_fr == error_mark_node)\n-\tdel_coro_fr = error_mark_node;\n-    }\n-\n-  del_coro_fr = coro_build_cvt_void_expr_stmt (del_coro_fr, loc);\n-  add_stmt (del_coro_fr);\n+  /* Build the frame DTOR.  */\n+  tree del_coro_fr = coro_get_frame_dtor (actor_fp, orig, frame_size,\n+\t\t\t\t\t  promise_type, loc);\n+  finish_expr_stmt (del_coro_fr);\n   finish_then_clause (need_free_if);\n   tree scope = IF_SCOPE (need_free_if);\n   IF_SCOPE (need_free_if) = NULL;\n@@ -4143,7 +4154,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t  parm.this_ptr = is_this_parameter (arg);\n \t  parm.lambda_cobj = lambda_p && DECL_NAME (arg) == closure_identifier;\n \n-\t  parm.trivial_dtor = TYPE_HAS_TRIVIAL_DESTRUCTOR (parm.frame_type);\n \t  char *buf;\n \t  if (DECL_NAME (arg))\n \t    {\n@@ -4152,6 +4162,20 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t    }\n \t  else\n \t    buf = xasprintf (\"__unnamed_parm.%d\", no_name_parm++);\n+\n+\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (parm.frame_type))\n+\t    {\n+\t      char *gbuf = xasprintf (\"%s.live\", buf);\n+\t      parm.guard_var\n+\t\t= build_lang_decl (VAR_DECL, get_identifier (gbuf),\n+\t\t\t\t   boolean_type_node);\n+\t      free (gbuf);\n+\t      DECL_ARTIFICIAL (parm.guard_var) = true;\n+\t      DECL_INITIAL (parm.guard_var) = boolean_false_node;\n+\t      parm.trivial_dtor = false;\n+\t    }\n+\t  else\n+\t    parm.trivial_dtor = true;\n \t  parm.field_id = coro_make_frame_entry\n \t    (&field_list, buf, actual_type, DECL_SOURCE_LOCATION (arg));\n \t  free (buf);\n@@ -4208,6 +4232,37 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t\t\t\t  coro_frame_ptr);\n   tree varlist = coro_fp;\n \n+  /* To signal that we need to cleanup copied function args.  */\n+  if (flag_exceptions && DECL_ARGUMENTS (orig))\n+    for (tree arg = DECL_ARGUMENTS (orig); arg != NULL;\n+\targ = DECL_CHAIN (arg))\n+      {\n+\tparam_info *parm_i = param_uses->get (arg);\n+\tgcc_checking_assert (parm_i);\n+\tif (parm_i->trivial_dtor)\n+\t  continue;\n+\tDECL_CHAIN (parm_i->guard_var) = varlist;\n+\tvarlist = parm_i->guard_var;\n+      }\n+\n+  /* Signal that we need to clean up the promise object on exception.  */\n+  tree coro_promise_live\n+   = build_lang_decl (VAR_DECL, get_identifier (\"coro.promise.live\"),\n+\t\t      boolean_type_node);\n+  DECL_ARTIFICIAL (coro_promise_live) = true;\n+  DECL_CHAIN (coro_promise_live) = varlist;\n+  varlist = coro_promise_live;\n+  DECL_INITIAL (coro_promise_live) = boolean_false_node;\n+  /* When the get-return-object is in the RETURN slot, we need to arrange for\n+     cleanup on exception.  */\n+  tree coro_gro_live\n+   = build_lang_decl (VAR_DECL, get_identifier (\"coro.gro.live\"),\n+\t\t      boolean_type_node);\n+  DECL_ARTIFICIAL (coro_gro_live) = true;\n+  DECL_CHAIN (coro_gro_live) = varlist;\n+  varlist = coro_gro_live;\n+  DECL_INITIAL (coro_gro_live) = boolean_false_node;\n+\n   /* Collected the scope vars we need ... only one for now. */\n   BIND_EXPR_VARS (ramp_bind) = nreverse (varlist);\n \n@@ -4225,6 +4280,17 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree zeroinit = build1 (CONVERT_EXPR, coro_frame_ptr, integer_zero_node);\n   DECL_INITIAL (coro_fp) = zeroinit;\n   add_decl_expr (coro_fp);\n+  if (flag_exceptions && DECL_ARGUMENTS (orig))\n+    for (tree arg = DECL_ARGUMENTS (orig); arg != NULL;\n+\targ = DECL_CHAIN (arg))\n+      {\n+\tparam_info *parm_i = param_uses->get (arg);\n+\tif (parm_i->trivial_dtor)\n+\t  continue;\n+\tadd_decl_expr (parm_i->guard_var);;\n+      }\n+  add_decl_expr (coro_promise_live);\n+  add_decl_expr (coro_gro_live);\n \n   /* The CO_FRAME internal function is a mechanism to allow the middle end\n      to adjust the allocation in response to optimizations.  We provide the\n@@ -4418,6 +4484,20 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       finish_if_stmt (if_stmt);\n     }\n \n+  /* Up to now any exception thrown will propagate directly to the caller.\n+     This is OK since the only source of such exceptions would be in allocation\n+     of the coroutine frame, and therefore the ramp will not have initialized\n+     any further state.  From here, we will track state that needs explicit\n+     destruction in the case that promise or g.r.o setup fails or an exception\n+     is thrown from the initial suspend expression.  */\n+  tree ramp_cleanup = NULL_TREE;\n+  if (flag_exceptions)\n+    {\n+      ramp_cleanup = build_stmt (fn_start, TRY_BLOCK, NULL, NULL);\n+      add_stmt (ramp_cleanup);\n+      TRY_STMTS (ramp_cleanup) = push_stmt_list ();\n+    }\n+\n   /* deref the frame pointer, to use in member access code.  */\n   tree deref_fp = build_x_arrow (fn_start, coro_fp, tf_warning_or_error);\n \n@@ -4544,13 +4624,23 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t\t\t\t     INIT_EXPR, DECL_SOURCE_LOCATION (arg), r,\n \t\t\t\t     TREE_TYPE (r));\n \t    }\n-\t  r = coro_build_cvt_void_expr_stmt (r, fn_start);\n-\t  add_stmt (r);\n+\t  finish_expr_stmt (r);\n \t  if (!parm.trivial_dtor)\n \t    {\n \t      if (param_dtor_list == NULL)\n \t\tparam_dtor_list = make_tree_vector ();\n \t      vec_safe_push (param_dtor_list, parm.field_id);\n+\t      /* Cleanup this frame copy on exception.  */\n+\t      parm.fr_copy_dtor\n+\t\t= build_special_member_call (fld_idx, complete_dtor_identifier,\n+\t\t\t\t\t     NULL, parm.frame_type,\n+\t\t\t\t\t     LOOKUP_NORMAL,\n+\t\t\t\t\t     tf_warning_or_error);\n+\t      /* This var is now live.  */\n+\t      r = build_modify_expr (fn_start, parm.guard_var,\n+\t\t\t\t     boolean_type_node, INIT_EXPR, fn_start,\n+\t\t\t\t     boolean_true_node, boolean_type_node);\n+\t      finish_expr_stmt (r);\n \t    }\n \t}\n     }\n@@ -4563,6 +4653,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree p = build_class_member_access_expr (deref_fp, promise_m, NULL_TREE,\n \t\t\t\t\t   false, tf_warning_or_error);\n \n+  tree promise_dtor = NULL_TREE;\n   if (TYPE_NEEDS_CONSTRUCTING (promise_type))\n     {\n       /* Do a placement new constructor for the promise type (we never call\n@@ -4589,7 +4680,17 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t\t\t\t       tf_warning_or_error);\n \n       r = coro_build_cvt_void_expr_stmt (r, fn_start);\n-      add_stmt (r);\n+      finish_expr_stmt (r);\n+\n+      r = build_modify_expr (fn_start, coro_promise_live, boolean_type_node,\n+\t\t\t     INIT_EXPR, fn_start, boolean_true_node,\n+\t\t\t     boolean_type_node);\n+      finish_expr_stmt (r);\n+\n+      promise_dtor\n+\t= build_special_member_call (p, complete_dtor_identifier,\n+\t\t\t\t     NULL, promise_type, LOOKUP_NORMAL,\n+\t\t\t\t     tf_warning_or_error);\n     }\n \n   /* Set up a new bind context for the GRO.  */\n@@ -4621,6 +4722,8 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   tree gro = NULL_TREE;\n   tree gro_bind_vars = NULL_TREE;\n+  /* Used for return objects in the RESULT slot.  */\n+  tree gro_ret_dtor = NULL_TREE;\n   tree gro_cleanup_stmt = NULL_TREE;\n   /* We have to sequence the call to get_return_object before initial\n      suspend.  */\n@@ -4644,6 +4747,16 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       else\n \tr = build2_loc (fn_start, INIT_EXPR, gro_type,\n \t\t\tDECL_RESULT (orig), get_ro);\n+\n+      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (gro_type))\n+\t/* If some part of the initalization code (prior to the await_resume\n+\t     of the initial suspend expression), then we need to clean up the\n+\t     return value.  */\n+\tgro_ret_dtor\n+\t  = build_special_member_call (DECL_RESULT (orig),\n+\t\t\t\t       complete_dtor_identifier, NULL,\n+\t\t\t\t       gro_type, LOOKUP_NORMAL,\n+\t\t\t\t       tf_warning_or_error);\n     }\n   else\n     {\n@@ -4668,19 +4781,28 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       /* The constructed object might require a cleanup.  */\n       if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (gro_type))\n \t{\n-\t  tree cleanup\n+\t  gro_cleanup_stmt\n \t    = build_special_member_call (gro, complete_dtor_identifier,\n \t\t\t\t\t NULL, gro_type, LOOKUP_NORMAL,\n \t\t\t\t\t tf_warning_or_error);\n \t  gro_cleanup_stmt = build_stmt (input_location, CLEANUP_STMT, NULL,\n-\t\t\t\t\t cleanup, gro);\n+\t\t\t\t\t gro_cleanup_stmt, gro);\n \t}\n     }\n   finish_expr_stmt (r);\n \n-  if (gro_cleanup_stmt)\n+  if (gro_cleanup_stmt && gro_cleanup_stmt != error_mark_node)\n     CLEANUP_BODY (gro_cleanup_stmt) = push_stmt_list ();\n \n+  /* If we have a live g.r.o in the return slot, then signal this for exception\n+     cleanup.  */\n+  if (gro_ret_dtor)\n+    {\n+       r = build_modify_expr (fn_start, coro_gro_live, boolean_type_node,\n+\t\t\t      INIT_EXPR, fn_start, boolean_true_node,\n+\t\t\t      boolean_type_node);\n+      finish_expr_stmt (r);\n+    }\n   /* Initialize the resume_idx_name to 0, meaning \"not started\".  */\n   tree resume_idx_m\n     = lookup_member (coro_frame_type, resume_idx_name,\n@@ -4759,6 +4881,73 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   BIND_EXPR_VARS (gro_context_bind) = gro_bind_vars;\n   BIND_EXPR_BODY (gro_context_bind) = pop_stmt_list (gro_context_body);\n   TREE_SIDE_EFFECTS (gro_context_bind) = true;\n+\n+  if (flag_exceptions)\n+    {\n+      TRY_HANDLERS (ramp_cleanup) = push_stmt_list ();\n+      tree handler = begin_handler ();\n+      finish_handler_parms (NULL_TREE, handler); /* catch (...) */\n+\n+      /* If we have a live G.R.O in the return slot, then run its DTOR.\n+     When the return object is constructed from a separate g.r.o, this is\n+     already handled by its regular cleanup.  */\n+      if (gro_ret_dtor && gro_ret_dtor != error_mark_node)\n+\t{\n+\t  tree gro_d_if = begin_if_stmt ();\n+\t  finish_if_stmt_cond (coro_gro_live, gro_d_if);\n+\t  finish_expr_stmt (gro_ret_dtor);\n+\t  finish_then_clause (gro_d_if);\n+\t  tree gro_d_if_scope = IF_SCOPE (gro_d_if);\n+\t  IF_SCOPE (gro_d_if) = NULL;\n+\t  gro_d_if = do_poplevel (gro_d_if_scope);\n+\t  add_stmt (gro_d_if);\n+\t}\n+\n+      /* If the promise is live, then run its dtor if that's available.  */\n+      if (promise_dtor && promise_dtor != error_mark_node)\n+\t{\n+\t  tree promise_d_if = begin_if_stmt ();\n+\t  finish_if_stmt_cond (coro_promise_live, promise_d_if);\n+\t  finish_expr_stmt (promise_dtor);\n+\t  finish_then_clause (promise_d_if);\n+\t  tree promise_d_if_scope = IF_SCOPE (promise_d_if);\n+\t  IF_SCOPE (promise_d_if) = NULL;\n+\t  promise_d_if = do_poplevel (promise_d_if_scope);\n+\t  add_stmt (promise_d_if);\n+\t}\n+\n+      /* Clean up any frame copies of parms with non-trivial dtors.  */\n+      if (DECL_ARGUMENTS (orig))\n+\tfor (tree arg = DECL_ARGUMENTS (orig); arg != NULL;\n+\t     arg = DECL_CHAIN (arg))\n+\t  {\n+\t    param_info *parm_i = param_uses->get (arg);\n+\t    if (parm_i->trivial_dtor)\n+\t      continue;\n+\t    if (parm_i->fr_copy_dtor && parm_i->fr_copy_dtor != error_mark_node)\n+\t      {\n+\t\ttree dtor_if = begin_if_stmt ();\n+\t\tfinish_if_stmt_cond (parm_i->guard_var, dtor_if);\n+\t\tfinish_expr_stmt (parm_i->fr_copy_dtor);\n+\t\tfinish_then_clause (dtor_if);\n+\t\ttree parm_d_if_scope = IF_SCOPE (dtor_if);\n+\t\tIF_SCOPE (dtor_if) = NULL;\n+\t\tdtor_if = do_poplevel (parm_d_if_scope);\n+\t\tadd_stmt (dtor_if);\n+\t      }\n+\t  }\n+\n+      /* We always expect to delete the frame.  */\n+      tree del_coro_fr = coro_get_frame_dtor (coro_fp, orig, frame_size,\n+\t\t\t\t\t      promise_type, fn_start);\n+      finish_expr_stmt (del_coro_fr);\n+      tree rethrow = build_throw (fn_start, NULL_TREE);\n+      TREE_NO_WARNING (rethrow) = true;\n+      finish_expr_stmt (rethrow);\n+      finish_handler (handler);\n+      TRY_HANDLERS (ramp_cleanup) = pop_stmt_list (TRY_HANDLERS (ramp_cleanup));\n+    }\n+\n   BIND_EXPR_BODY (ramp_bind) = pop_stmt_list (ramp_body);\n   TREE_SIDE_EFFECTS (ramp_bind) = true;\n "}, {"sha": "cf30c82be5edc4c92e160d1d1fc763e04988aab1", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95615-01.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-01.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-01.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-01.C?ref=fe55086547c9360b530e040a6673dae10ac77847", "patch": "@@ -0,0 +1,4 @@\n+//  { dg-do run }\n+\n+#define INITIAL_SUSPEND_THROWS 1\n+#include \"pr95615.inc\""}, {"sha": "7ec0f33f4859bea0c3c3e4576e7f403e04880e38", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95615-02.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-02.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-02.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-02.C?ref=fe55086547c9360b530e040a6673dae10ac77847", "patch": "@@ -0,0 +1,4 @@\n+//  { dg-do run }\n+\n+#define PROMISE_CTOR_THROWS 1\n+#include \"pr95615.inc\""}, {"sha": "8053335428e83bc2de56678857a0cd301ba79edb", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95615-03.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-03.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-03.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-03.C?ref=fe55086547c9360b530e040a6673dae10ac77847", "patch": "@@ -0,0 +1,4 @@\n+//  { dg-do run }\n+\n+#define GET_RETURN_OBJECT_THROWS 1\n+#include \"pr95615.inc\""}, {"sha": "db5c1285f9a01ca1fd1f566a3d47e0ed1a720c4f", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95615-04.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-04.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-04.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-04.C?ref=fe55086547c9360b530e040a6673dae10ac77847", "patch": "@@ -0,0 +1,4 @@\n+//  { dg-do run }\n+\n+#define INITIAL_AWAIT_READY_THROWS 1\n+#include \"pr95615.inc\""}, {"sha": "5fd62f67be457c9f393a728d5f61e0e281ac7061", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95615-05.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-05.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-05.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615-05.C?ref=fe55086547c9360b530e040a6673dae10ac77847", "patch": "@@ -0,0 +1,4 @@\n+//  { dg-do run }\n+\n+#define INITIAL_AWAIT_SUSPEND_THROWS 1\n+#include \"pr95615.inc\""}, {"sha": "5fc22430e9917c20c5e12435d1da5a08094589b1", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95615.inc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe55086547c9360b530e040a6673dae10ac77847/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95615.inc?ref=fe55086547c9360b530e040a6673dae10ac77847", "patch": "@@ -0,0 +1,128 @@\n+#if __has_include(<coroutine>)\n+#include <coroutine>\n+#else\n+#include <experimental/coroutine>\n+namespace std {\n+    using namespace std::experimental;\n+}\n+#endif\n+#include <cassert>\n+#include <cstdio>\n+#include <cstdlib>\n+\n+bool frame_live = false;\n+bool promise_live = false;\n+bool gro_live = false;\n+\n+struct X {};\n+\n+int Y_live = 0;\n+\n+struct Y\n+{\n+  Y () { std::puts(\"Y ()\"); Y_live++; } \n+  Y (const Y&) { std::puts(\"Y (const Y&)\"); Y_live++; } \n+  ~Y () { std::puts(\"~Y ()\"); Y_live--; }\n+};\n+\n+struct task {\n+    struct promise_type {\n+        void* operator new(size_t sz) {\n+            std::puts(\"operator new()\");\n+            frame_live = true;\n+            return ::operator new(sz);\n+        }\n+\n+        void operator delete(void* p, size_t sz) {\n+            std::puts(\"operator delete\");\n+            frame_live = false;\n+            return ::operator delete(p, sz);\n+        }\n+\n+        promise_type() {\n+            std::puts(\"promise_type()\");\n+#if PROMISE_CTOR_THROWS\n+             throw X{};\n+#endif\n+            promise_live = true;\n+        }\n+\n+        ~promise_type() {\n+            std::puts(\"~promise_type()\");\n+            promise_live = false;\n+        }\n+\n+        struct awaiter {\n+            bool await_ready() {\n+#if INITIAL_AWAIT_READY_THROWS\n+               throw X{};\n+#endif\n+               return false;\n+            }\n+            void await_suspend(std::coroutine_handle<>) {\n+#if INITIAL_AWAIT_SUSPEND_THROWS\n+                throw X{};\n+#endif\n+            }\n+            void await_resume() {\n+#if INITIAL_AWAIT_RESUME_THROWS\n+// this would be caught by unhandled_exception () which is tested\n+// elsewhere.\n+                throw X{};\n+#endif\n+            }\n+        };\n+\n+        awaiter initial_suspend() {\n+#if INITIAL_SUSPEND_THROWS\n+            throw X{};\n+#endif\n+            return {};\n+        }\n+\n+        task get_return_object() {\n+            std::puts(\"get_return_object()\");\n+#if GET_RETURN_OBJECT_THROWS\n+            throw X{};\n+#endif\n+\t    bool gro_live = true;\n+            return task{};\n+        }\n+\n+        std::suspend_never final_suspend() noexcept { return {}; }\n+        void return_void() noexcept {}\n+        void unhandled_exception() noexcept {\n+            std::puts(\"unhandled_exception()\");\n+        }\n+    };\n+\n+    task() { std::puts(\"task()\"); }\n+    ~task() { std::puts(\"~task()\"); }\n+    task(task&&) { std::puts(\"task(task&&)\"); }\n+};\n+\n+task f(Y Val) {\n+    co_return;\n+}\n+\n+int main() {\n+    bool failed = false;\n+    Y Val;\n+    try {\n+        f(Val);\n+    } catch (X) {\n+        std::puts(\"caught X\");\n+        if (gro_live)\n+          std::puts(\"gro live\"), failed = true;\n+        if (promise_live)\n+          std::puts(\"promise live\"), failed = true;\n+        if (frame_live)\n+          std::puts(\"frame live\"), failed = true;\n+    }\n+\n+  if (Y_live != 1)\n+    std::printf(\"Y live %d\\n\", Y_live), failed = true;\n+\n+  if (failed)\n+    abort() ;\n+}"}]}