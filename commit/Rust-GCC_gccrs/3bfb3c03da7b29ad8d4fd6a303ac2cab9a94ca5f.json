{"sha": "3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JmYjNjMDNkYTdiMjlhZDhkNGZkNmEzMDNhYzJjYWI5YTk0Y2E1Zg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2012-10-03T08:09:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-03T08:09:15Z"}, "message": "exp_ch4.adb (Expand_N_Allocator_Expression): Minor code reorganization and cleanup.\n\n2012-10-03  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Allocator_Expression): Minor code\n\treorganization and cleanup. Done to ensure proper management of\n\tthe C++ constructor covering tagged and untagged types and also\n\tnon-default constructors.\n\t* exp_ch6.ads, exp_ch6.adb (Make_CPP_Constructor_Call_In_Allocator):\n\tNew subprogram.\n\nFrom-SVN: r192028", "tree": {"sha": "1e26bac305aa6ddd203a993b2ebc5701dbc88809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e26bac305aa6ddd203a993b2ebc5701dbc88809"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "71fb4dc8c84186168bbb97ec54ce5b20b18946e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71fb4dc8c84186168bbb97ec54ce5b20b18946e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71fb4dc8c84186168bbb97ec54ce5b20b18946e4"}], "stats": {"total": 170, "additions": 118, "deletions": 52}, "files": [{"sha": "7479da699978c5ff091f0c426f6f03a6fd1efd5b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f", "patch": "@@ -1,3 +1,12 @@\n+2012-10-03  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Allocator_Expression): Minor code\n+\treorganization and cleanup. Done to ensure proper management of\n+\tthe C++ constructor covering tagged and untagged types and also\n+\tnon-default constructors.\n+\t* exp_ch6.ads, exp_ch6.adb (Make_CPP_Constructor_Call_In_Allocator):\n+\tNew subprogram.\n+\n 2012-10-03  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_ch6.adb: Minor typo fix."}, {"sha": "9357be68b57d9536d317c346f831a9759619f563", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 9, "deletions": 52, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f", "patch": "@@ -867,6 +867,15 @@ package body Exp_Ch4 is\n    --  Start of processing for Expand_Allocator_Expression\n \n    begin\n+      --  Handle call to C++ constructor\n+\n+      if Is_CPP_Constructor_Call (Exp) then\n+         Make_CPP_Constructor_Call_In_Allocator\n+           (Allocator => N,\n+            Function_Call => Exp);\n+         return;\n+      end if;\n+\n       --  In the case of an Ada 2012 allocator whose initial value comes from a\n       --  function call, pass \"the accessibility level determined by the point\n       --  of call\" (AI05-0234) to the function. Conceptually, this belongs in\n@@ -899,58 +908,6 @@ package body Exp_Ch4 is\n       --  Case of tagged type or type requiring finalization\n \n       if Is_Tagged_Type (T) or else Needs_Finalization (T) then\n-         if Is_CPP_Constructor_Call (Exp) then\n-\n-            --  Generate:\n-            --    Pnnn : constant ptr_T := new (T);\n-            --    Init (Pnnn.all,...);\n-\n-            --  Allocate the object without an expression\n-\n-            Node := Relocate_Node (N);\n-            Set_Expression (Node, New_Reference_To (Etype (Exp), Loc));\n-\n-            --  Avoid its expansion to avoid generating a call to the default\n-            --  C++ constructor.\n-\n-            Set_Analyzed (Node);\n-\n-            Temp := Make_Temporary (Loc, 'P', N);\n-\n-            Temp_Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Temp,\n-                Constant_Present    => True,\n-                Object_Definition   => New_Reference_To (PtrT, Loc),\n-                Expression          => Node);\n-            Insert_Action (N, Temp_Decl);\n-\n-            Apply_Accessibility_Check (Temp);\n-\n-            --  Locate the enclosing list and insert the C++ constructor call\n-\n-            declare\n-               P : Node_Id;\n-\n-            begin\n-               P := Parent (Node);\n-               while not Is_List_Member (P) loop\n-                  P := Parent (P);\n-               end loop;\n-\n-               Insert_List_After_And_Analyze (P,\n-                 Build_Initialization_Call (Loc,\n-                   Id_Ref          =>\n-                     Make_Explicit_Dereference (Loc,\n-                       Prefix => New_Reference_To (Temp, Loc)),\n-                   Typ             => Etype (Exp),\n-                   Constructor_Ref => Exp));\n-            end;\n-\n-            Rewrite (N, New_Reference_To (Temp, Loc));\n-            Analyze_And_Resolve (N, PtrT);\n-            return;\n-         end if;\n \n          --  Ada 2005 (AI-318-02): If the initialization expression is a call\n          --  to a build-in-place function, then access to the allocated object"}, {"sha": "2fac2a3bffc4f963bf25d47119c169a1c4c4d889", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f", "patch": "@@ -9121,6 +9121,96 @@ package body Exp_Ch6 is\n       end if;\n    end Make_Build_In_Place_Call_In_Object_Declaration;\n \n+   --------------------------------------------\n+   -- Make_CPP_Constructor_Call_In_Allocator --\n+   --------------------------------------------\n+\n+   procedure Make_CPP_Constructor_Call_In_Allocator\n+     (Allocator     : Node_Id;\n+      Function_Call : Node_Id)\n+   is\n+      Loc         : constant Source_Ptr := Sloc (Function_Call);\n+      Acc_Type    : constant Entity_Id := Etype (Allocator);\n+      Function_Id : constant Entity_Id := Entity (Name (Function_Call));\n+      Result_Subt : constant Entity_Id := Available_View (Etype (Function_Id));\n+\n+      New_Allocator     : Node_Id;\n+      Return_Obj_Access : Entity_Id;\n+      Tmp_Obj           : Node_Id;\n+\n+   begin\n+      pragma Assert (Nkind (Allocator) = N_Allocator\n+                       and then Nkind (Function_Call) = N_Function_Call);\n+      pragma Assert (Convention (Function_Id) = Convention_CPP\n+                       and then Is_Constructor (Function_Id));\n+      pragma Assert (Is_Constrained (Underlying_Type (Result_Subt)));\n+\n+      --  Replace the initialized allocator of form \"new T'(Func (...))\" with\n+      --  an uninitialized allocator of form \"new T\", where T is the result\n+      --  subtype of the called function. The call to the function is handled\n+      --  separately further below.\n+\n+      New_Allocator :=\n+        Make_Allocator (Loc,\n+          Expression => New_Reference_To (Result_Subt, Loc));\n+      Set_No_Initialization (New_Allocator);\n+\n+      --  Copy attributes to new allocator. Note that the new allocator\n+      --  logically comes from source if the original one did, so copy the\n+      --  relevant flag. This ensures proper treatment of the restriction\n+      --  No_Implicit_Heap_Allocations in this case.\n+\n+      Set_Storage_Pool      (New_Allocator, Storage_Pool      (Allocator));\n+      Set_Procedure_To_Call (New_Allocator, Procedure_To_Call (Allocator));\n+      Set_Comes_From_Source (New_Allocator, Comes_From_Source (Allocator));\n+\n+      Rewrite (Allocator, New_Allocator);\n+\n+      --  Create a new access object and initialize it to the result of the\n+      --  new uninitialized allocator. Note: we do not use Allocator as the\n+      --  Related_Node of Return_Obj_Access in call to Make_Temporary below\n+      --  as this would create a sort of infinite \"recursion\".\n+\n+      Return_Obj_Access := Make_Temporary (Loc, 'R');\n+      Set_Etype (Return_Obj_Access, Acc_Type);\n+\n+      --  Generate:\n+      --    Rnnn : constant ptr_T := new (T);\n+      --    Init (Rnn.all,...);\n+\n+      Tmp_Obj :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Return_Obj_Access,\n+          Constant_Present    => True,\n+          Object_Definition   => New_Reference_To (Acc_Type, Loc),\n+          Expression          => Relocate_Node (Allocator));\n+      Insert_Action (Allocator, Tmp_Obj);\n+\n+      Insert_List_After_And_Analyze (Tmp_Obj,\n+        Build_Initialization_Call (Loc,\n+          Id_Ref =>\n+            Make_Explicit_Dereference (Loc,\n+              Prefix => New_Reference_To (Return_Obj_Access, Loc)),\n+          Typ => Etype (Function_Id),\n+          Constructor_Ref => Function_Call));\n+\n+      --  Finally, replace the allocator node with a reference to the result of\n+      --  the function call itself (which will effectively be an access to the\n+      --  object created by the allocator).\n+\n+      Rewrite (Allocator, New_Reference_To (Return_Obj_Access, Loc));\n+\n+      --  Ada 2005 (AI-251): If the type of the allocator is an interface then\n+      --  generate an implicit conversion to force displacement of the \"this\"\n+      --  pointer.\n+\n+      if Is_Interface (Designated_Type (Acc_Type)) then\n+         Rewrite (Allocator, Convert_To (Acc_Type, Relocate_Node (Allocator)));\n+      end if;\n+\n+      Analyze_And_Resolve (Allocator, Acc_Type);\n+   end Make_CPP_Constructor_Call_In_Allocator;\n+\n    -----------------------------------\n    -- Needs_BIP_Finalization_Master --\n    -----------------------------------"}, {"sha": "0f65a5bf786c0c3d385662f974f02e5270480ef6", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=3bfb3c03da7b29ad8d4fd6a303ac2cab9a94ca5f", "patch": "@@ -205,6 +205,16 @@ package Exp_Ch6 is\n    --  for which Is_Build_In_Place_Call is True, or an N_Qualified_Expression\n    --  node applied to such a function call.\n \n+   procedure Make_CPP_Constructor_Call_In_Allocator\n+     (Allocator     : Node_Id;\n+      Function_Call : Node_Id);\n+   --  Handle a call to a CPP constructor that occurs as the expression that\n+   --  initializes an allocator, by passing access to the allocated object as\n+   --  an additional parameter of the constructor call. A new access object is\n+   --  declared that is initialized to the result of the allocator, passed to\n+   --  the constructor, and the allocator is rewritten to refer to that access\n+   --  object. Function_Call must denote a call to a CPP_Constructor function.\n+\n    function Needs_BIP_Alloc_Form (Func_Id : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Return True if the function needs an implicit\n    --  BIP_Alloc_Form parameter (see type BIP_Formal_Kind)."}]}