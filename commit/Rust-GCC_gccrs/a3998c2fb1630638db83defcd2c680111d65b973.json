{"sha": "a3998c2fb1630638db83defcd2c680111d65b973", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM5OThjMmZiMTYzMDYzOGRiODNkZWZjZDJjNjgwMTExZDY1Yjk3Mw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-12-15T18:05:05Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-12-15T18:05:05Z"}, "message": "Fix use-after-free lexing unterminated raw strings (PR preprocessor/78811)\n\ngcc/ChangeLog:\n\tPR preprocessor/78680\n\tPR preprocessor/78811\n\t* input.c (struct selftest::lexer_test): Add field\n\tm_implicitly_expect_EOF.\n\t(selftest::lexer_error_sink): New class.\n\t(selftest::lexer_error_sink::s_singleton): New global.\n\t(selftest::lexer_test::lexer_test): Initialize new field\n\t\"m_implicitly_expect_EOF\".\n\t(selftest::lexer_test::~lexer_test): Conditionalize the\n\tcheck for the EOF token on the new field.\n\t(selftest::test_lexer_string_locations_raw_string_unterminated):\n\tNew function.\n\t(selftest::input_c_tests): Call the new test.\n\nlibcpp/ChangeLog:\n\tPR preprocessor/78680\n\tPR preprocessor/78811\n\t* lex.c (_cpp_lex_direct): Only determine the end-location of\n\tthe token and build a range for non-reserved start locations.\n\tDo not do it for EOF tokens.\n\nFrom-SVN: r243721", "tree": {"sha": "6691b9007e679032843ddb4ba453fa49409bf3d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6691b9007e679032843ddb4ba453fa49409bf3d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3998c2fb1630638db83defcd2c680111d65b973", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3998c2fb1630638db83defcd2c680111d65b973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3998c2fb1630638db83defcd2c680111d65b973", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3998c2fb1630638db83defcd2c680111d65b973/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3038e190b271744d0b5e2e83d389864fed4d54e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3038e190b271744d0b5e2e83d389864fed4d54e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3038e190b271744d0b5e2e83d389864fed4d54e"}], "stats": {"total": 153, "additions": 129, "deletions": 24}, "files": [{"sha": "f8b7fed4b1f7aaa7823592781b6e0aa5d724d3f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3998c2fb1630638db83defcd2c680111d65b973/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3998c2fb1630638db83defcd2c680111d65b973/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3998c2fb1630638db83defcd2c680111d65b973", "patch": "@@ -1,3 +1,19 @@\n+2016-12-15  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR preprocessor/78680\n+\tPR preprocessor/78811\n+\t* input.c (struct selftest::lexer_test): Add field\n+\tm_implicitly_expect_EOF.\n+\t(selftest::lexer_error_sink): New class.\n+\t(selftest::lexer_error_sink::s_singleton): New global.\n+\t(selftest::lexer_test::lexer_test): Initialize new field\n+\t\"m_implicitly_expect_EOF\".\n+\t(selftest::lexer_test::~lexer_test): Conditionalize the\n+\tcheck for the EOF token on the new field.\n+\t(selftest::test_lexer_string_locations_raw_string_unterminated):\n+\tNew function.\n+\t(selftest::input_c_tests): Call the new test.\n+\n 2016-12-15  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/arm/arm.h (TARGET_BACKTRACE): Use crtl->is_leaf."}, {"sha": "dcb51016a044f71f3bd2cad65ee74229e12bb51e", "filename": "gcc/input.c", "status": "modified", "additions": 84, "deletions": 5, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3998c2fb1630638db83defcd2c680111d65b973/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3998c2fb1630638db83defcd2c680111d65b973/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=a3998c2fb1630638db83defcd2c680111d65b973", "patch": "@@ -1985,6 +1985,7 @@ struct lexer_test\n   cpp_reader_ptr m_parser;\n   temp_source_file m_tempfile;\n   string_concat_db m_concats;\n+  bool m_implicitly_expect_EOF;\n };\n \n /* Use an EBCDIC encoding for the execution charset, specifically\n@@ -2046,6 +2047,54 @@ class ebcdic_execution_charset : public lexer_test_options\n \n ebcdic_execution_charset *ebcdic_execution_charset::s_singleton;\n \n+/* A lexer_test_options subclass that records a list of error\n+   messages emitted by the lexer.  */\n+\n+class lexer_error_sink : public lexer_test_options\n+{\n+ public:\n+  lexer_error_sink ()\n+  {\n+    gcc_assert (s_singleton == NULL);\n+    s_singleton = this;\n+  }\n+  ~lexer_error_sink ()\n+  {\n+    gcc_assert (s_singleton == this);\n+    s_singleton = NULL;\n+\n+    int i;\n+    char *str;\n+    FOR_EACH_VEC_ELT (m_errors, i, str)\n+      free (str);\n+  }\n+\n+  void apply (lexer_test &test) FINAL OVERRIDE\n+  {\n+    cpp_callbacks *callbacks = cpp_get_callbacks (test.m_parser);\n+    callbacks->error = on_error;\n+  }\n+\n+  static bool on_error (cpp_reader *pfile ATTRIBUTE_UNUSED,\n+\t\t\tint level ATTRIBUTE_UNUSED,\n+\t\t\tint reason ATTRIBUTE_UNUSED,\n+\t\t\trich_location *richloc ATTRIBUTE_UNUSED,\n+\t\t\tconst char *msgid, va_list *ap)\n+    ATTRIBUTE_FPTR_PRINTF(5,0)\n+  {\n+    char *msg = xvasprintf (msgid, *ap);\n+    s_singleton->m_errors.safe_push (msg);\n+    return true;\n+  }\n+\n+  auto_vec<char *> m_errors;\n+\n+ private:\n+  static lexer_error_sink *s_singleton;\n+};\n+\n+lexer_error_sink *lexer_error_sink::s_singleton;\n+\n /* Constructor.  Override line_table with a new instance based on CASE_,\n    and write CONTENT to a tempfile.  Create a cpp_reader, and use it to\n    start parsing the tempfile.  */\n@@ -2056,7 +2105,8 @@ lexer_test::lexer_test (const line_table_case &case_, const char *content,\n   m_parser (cpp_create_reader (CLK_GNUC99, NULL, line_table)),\n   /* Create a tempfile and write the text to it.  */\n   m_tempfile (SELFTEST_LOCATION, \".c\", content),\n-  m_concats ()\n+  m_concats (),\n+  m_implicitly_expect_EOF (true)\n {\n   if (options)\n     options->apply (*this);\n@@ -2069,16 +2119,19 @@ lexer_test::lexer_test (const line_table_case &case_, const char *content,\n   ASSERT_NE (fname, NULL);\n }\n \n-/* Destructor.  Verify that the next token in m_parser is EOF.  */\n+/* Destructor.  By default, verify that the next token in m_parser is EOF.  */\n \n lexer_test::~lexer_test ()\n {\n   location_t loc;\n   const cpp_token *tok;\n \n-  tok = cpp_get_token_with_location (m_parser, &loc);\n-  ASSERT_NE (tok, NULL);\n-  ASSERT_EQ (tok->type, CPP_EOF);\n+  if (m_implicitly_expect_EOF)\n+    {\n+      tok = cpp_get_token_with_location (m_parser, &loc);\n+      ASSERT_NE (tok, NULL);\n+      ASSERT_EQ (tok->type, CPP_EOF);\n+    }\n }\n \n /* Get the next token from m_parser.  */\n@@ -3247,6 +3300,31 @@ test_lexer_string_locations_raw_string_multiline (const line_table_case &case_)\n \t\t\t\t  \"range endpoints are on different lines\");\n }\n \n+/* Test of parsing an unterminated raw string.  */\n+\n+static void\n+test_lexer_string_locations_raw_string_unterminated (const line_table_case &case_)\n+{\n+  const char *content = \"R\\\"ouch()ouCh\\\" /* etc */\";\n+\n+  lexer_error_sink errors;\n+  lexer_test test (case_, content, &errors);\n+  test.m_implicitly_expect_EOF = false;\n+\n+  /* Attempt to parse the raw string.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_EOF);\n+\n+  ASSERT_EQ (1, errors.m_errors.length ());\n+  /* We expect the message \"unterminated raw string\"\n+     in the \"cpplib\" translation domain.\n+     It's not clear that dgettext is available on all supported hosts,\n+     so this assertion is commented-out for now.\n+       ASSERT_STREQ (dgettext (\"cpplib\", \"unterminated raw string\"),\n+                     errors.m_errors[0]);\n+  */\n+}\n+\n /* Test of lexing char constants.  */\n \n static void\n@@ -3390,6 +3468,7 @@ input_c_tests ()\n   for_each_line_table_case (test_lexer_string_locations_long_line);\n   for_each_line_table_case (test_lexer_string_locations_raw_string_one_line);\n   for_each_line_table_case (test_lexer_string_locations_raw_string_multiline);\n+  for_each_line_table_case (test_lexer_string_locations_raw_string_unterminated);\n   for_each_line_table_case (test_lexer_char_constants);\n \n   test_reading_source_line ();"}, {"sha": "ba90cfe8018eb8513971796d6b6d1c7b9311d9d8", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3998c2fb1630638db83defcd2c680111d65b973/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3998c2fb1630638db83defcd2c680111d65b973/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=a3998c2fb1630638db83defcd2c680111d65b973", "patch": "@@ -1,3 +1,11 @@\n+2016-12-15  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR preprocessor/78680\n+\tPR preprocessor/78811\n+\t* lex.c (_cpp_lex_direct): Only determine the end-location of\n+\tthe token and build a range for non-reserved start locations.\n+\tDo not do it for EOF tokens.\n+\n 2016-12-12  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR preprocessor/78680"}, {"sha": "9b1bdf8ba30ad6abcdf66c38a24d5419e493cd1c", "filename": "libcpp/lex.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3998c2fb1630638db83defcd2c680111d65b973/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3998c2fb1630638db83defcd2c680111d65b973/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=a3998c2fb1630638db83defcd2c680111d65b973", "patch": "@@ -3089,25 +3089,27 @@ _cpp_lex_direct (cpp_reader *pfile)\n       break;\n     }\n \n-  /* Ensure that any line notes are processed, so that we have the\n-     correct physical line/column for the end-point of the token even\n-     when a logical line is split via one or more backslashes.  */\n-  if (buffer->cur >= buffer->notes[buffer->cur_note].pos\n-      && !pfile->overlaid_buffer)\n-    _cpp_process_line_notes (pfile, false);\n-\n-  source_range tok_range;\n-  tok_range.m_start = result->src_loc;\n-  if (result->src_loc >= RESERVED_LOCATION_COUNT)\n-    tok_range.m_finish\n-      = linemap_position_for_column (pfile->line_table,\n-\t\t\t\t     CPP_BUF_COLUMN (buffer, buffer->cur));\n-  else\n-    tok_range.m_finish = tok_range.m_start;\n-\n-  result->src_loc = COMBINE_LOCATION_DATA (pfile->line_table,\n-\t\t\t\t\t   result->src_loc,\n-\t\t\t\t\t   tok_range, NULL);\n+  /* Potentially convert the location of the token to a range.  */\n+  if (result->src_loc >= RESERVED_LOCATION_COUNT\n+      && result->type != CPP_EOF)\n+    {\n+      /* Ensure that any line notes are processed, so that we have the\n+\t correct physical line/column for the end-point of the token even\n+\t when a logical line is split via one or more backslashes.  */\n+      if (buffer->cur >= buffer->notes[buffer->cur_note].pos\n+\t  && !pfile->overlaid_buffer)\n+\t_cpp_process_line_notes (pfile, false);\n+\n+      source_range tok_range;\n+      tok_range.m_start = result->src_loc;\n+      tok_range.m_finish\n+\t= linemap_position_for_column (pfile->line_table,\n+\t\t\t\t       CPP_BUF_COLUMN (buffer, buffer->cur));\n+\n+      result->src_loc = COMBINE_LOCATION_DATA (pfile->line_table,\n+\t\t\t\t\t       result->src_loc,\n+\t\t\t\t\t       tok_range, NULL);\n+    }\n \n   return result;\n }"}]}