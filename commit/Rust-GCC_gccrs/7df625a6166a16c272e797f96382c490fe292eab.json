{"sha": "7df625a6166a16c272e797f96382c490fe292eab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RmNjI1YTYxNjZhMTZjMjcyZTc5N2Y5NjM4MmM0OTBmZTI5MmVhYg==", "commit": {"author": {"name": "Alex Velenko", "email": "Alex.Velenko@arm.com", "date": "2013-10-09T11:05:15Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2013-10-09T11:05:15Z"}, "message": "[AArch64] vneg ADVSimd intrinsics rewritten in C.\n\nFrom-SVN: r203310", "tree": {"sha": "ba615c12e1ef4862079c3ef1e8cc3413f24148c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba615c12e1ef4862079c3ef1e8cc3413f24148c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7df625a6166a16c272e797f96382c490fe292eab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df625a6166a16c272e797f96382c490fe292eab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7df625a6166a16c272e797f96382c490fe292eab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df625a6166a16c272e797f96382c490fe292eab/comments", "author": null, "committer": null, "parents": [{"sha": "2b86fca7339841d8e1a88cf778e6976ddbfd4b0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b86fca7339841d8e1a88cf778e6976ddbfd4b0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b86fca7339841d8e1a88cf778e6976ddbfd4b0f"}], "stats": {"total": 785, "additions": 676, "deletions": 109}, "files": [{"sha": "e660ca1dce502ef04f7c655a19aaf14f4a830878", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df625a6166a16c272e797f96382c490fe292eab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df625a6166a16c272e797f96382c490fe292eab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7df625a6166a16c272e797f96382c490fe292eab", "patch": "@@ -1,3 +1,18 @@\n+2013-10-09  Alex Velenko  <Alex.Velenko@arm.com>\n+\n+\t* config/aarch64/arm_neon.h (vneg_f32): Asm replaced with C.\n+\t(vneg_f64): New intrinsic.\n+\t(vneg_s8): Asm replaced with C.\n+\t(vneg_s16): Likewise.\n+\t(vneg_s32): Likewise.\n+\t(vneg_s64): New intrinsic.\n+\t(vnegq_f32): Asm replaced with C.\n+\t(vnegq_f64): Likewise.\n+\t(vnegq_s8): Likewise.\n+\t(vnegq_s16): Likewise.\n+\t(vnegq_s32): Likewise.\n+\t(vnegq_s64): Likewise.\n+\n 2013-10-09  Renlin Li  <Renlin.Li@arm.com>\n \n \t* config/arm/arm.c (arm_output_mi_thunk): Use plus_constant."}, {"sha": "1bd098d2a9c3a204c0fb57ee3ef31cbb5f328d8e", "filename": "gcc/config/aarch64/arm_neon.h", "status": "modified", "additions": 74, "deletions": 109, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df625a6166a16c272e797f96382c490fe292eab/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df625a6166a16c272e797f96382c490fe292eab/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Farm_neon.h?ref=7df625a6166a16c272e797f96382c490fe292eab", "patch": "@@ -9785,115 +9785,6 @@ vmvnq_u32 (uint32x4_t a)\n   return result;\n }\n \n-__extension__ static __inline float32x2_t __attribute__ ((__always_inline__))\n-vneg_f32 (float32x2_t a)\n-{\n-  float32x2_t result;\n-  __asm__ (\"fneg %0.2s,%1.2s\"\n-           : \"=w\"(result)\n-           : \"w\"(a)\n-           : /* No clobbers */);\n-  return result;\n-}\n-\n-__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n-vneg_s8 (int8x8_t a)\n-{\n-  int8x8_t result;\n-  __asm__ (\"neg %0.8b,%1.8b\"\n-           : \"=w\"(result)\n-           : \"w\"(a)\n-           : /* No clobbers */);\n-  return result;\n-}\n-\n-__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n-vneg_s16 (int16x4_t a)\n-{\n-  int16x4_t result;\n-  __asm__ (\"neg %0.4h,%1.4h\"\n-           : \"=w\"(result)\n-           : \"w\"(a)\n-           : /* No clobbers */);\n-  return result;\n-}\n-\n-__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n-vneg_s32 (int32x2_t a)\n-{\n-  int32x2_t result;\n-  __asm__ (\"neg %0.2s,%1.2s\"\n-           : \"=w\"(result)\n-           : \"w\"(a)\n-           : /* No clobbers */);\n-  return result;\n-}\n-\n-__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))\n-vnegq_f32 (float32x4_t a)\n-{\n-  float32x4_t result;\n-  __asm__ (\"fneg %0.4s,%1.4s\"\n-           : \"=w\"(result)\n-           : \"w\"(a)\n-           : /* No clobbers */);\n-  return result;\n-}\n-\n-__extension__ static __inline float64x2_t __attribute__ ((__always_inline__))\n-vnegq_f64 (float64x2_t a)\n-{\n-  float64x2_t result;\n-  __asm__ (\"fneg %0.2d,%1.2d\"\n-           : \"=w\"(result)\n-           : \"w\"(a)\n-           : /* No clobbers */);\n-  return result;\n-}\n-\n-__extension__ static __inline int8x16_t __attribute__ ((__always_inline__))\n-vnegq_s8 (int8x16_t a)\n-{\n-  int8x16_t result;\n-  __asm__ (\"neg %0.16b,%1.16b\"\n-           : \"=w\"(result)\n-           : \"w\"(a)\n-           : /* No clobbers */);\n-  return result;\n-}\n-\n-__extension__ static __inline int16x8_t __attribute__ ((__always_inline__))\n-vnegq_s16 (int16x8_t a)\n-{\n-  int16x8_t result;\n-  __asm__ (\"neg %0.8h,%1.8h\"\n-           : \"=w\"(result)\n-           : \"w\"(a)\n-           : /* No clobbers */);\n-  return result;\n-}\n-\n-__extension__ static __inline int32x4_t __attribute__ ((__always_inline__))\n-vnegq_s32 (int32x4_t a)\n-{\n-  int32x4_t result;\n-  __asm__ (\"neg %0.4s,%1.4s\"\n-           : \"=w\"(result)\n-           : \"w\"(a)\n-           : /* No clobbers */);\n-  return result;\n-}\n-\n-__extension__ static __inline int64x2_t __attribute__ ((__always_inline__))\n-vnegq_s64 (int64x2_t a)\n-{\n-  int64x2_t result;\n-  __asm__ (\"neg %0.2d,%1.2d\"\n-           : \"=w\"(result)\n-           : \"w\"(a)\n-           : /* No clobbers */);\n-  return result;\n-}\n \n __extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n vpadal_s8 (int16x4_t a, int8x8_t b)\n@@ -21241,6 +21132,80 @@ vmulq_laneq_u32 (uint32x4_t __a, uint32x4_t __b, const int __lane)\n   return __a * __aarch64_vgetq_lane_u32 (__b, __lane);\n }\n \n+/* vneg  */\n+\n+__extension__ static __inline float32x2_t __attribute__ ((__always_inline__))\n+vneg_f32 (float32x2_t __a)\n+{\n+  return -__a;\n+}\n+\n+__extension__ static __inline float64x1_t __attribute__ ((__always_inline__))\n+vneg_f64 (float64x1_t __a)\n+{\n+  return -__a;\n+}\n+\n+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))\n+vneg_s8 (int8x8_t __a)\n+{\n+  return -__a;\n+}\n+\n+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n+vneg_s16 (int16x4_t __a)\n+{\n+  return -__a;\n+}\n+\n+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n+vneg_s32 (int32x2_t __a)\n+{\n+  return -__a;\n+}\n+\n+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))\n+vneg_s64 (int64x1_t __a)\n+{\n+  return -__a;\n+}\n+\n+__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))\n+vnegq_f32 (float32x4_t __a)\n+{\n+  return -__a;\n+}\n+\n+__extension__ static __inline float64x2_t __attribute__ ((__always_inline__))\n+vnegq_f64 (float64x2_t __a)\n+{\n+  return -__a;\n+}\n+\n+__extension__ static __inline int8x16_t __attribute__ ((__always_inline__))\n+vnegq_s8 (int8x16_t __a)\n+{\n+  return -__a;\n+}\n+\n+__extension__ static __inline int16x8_t __attribute__ ((__always_inline__))\n+vnegq_s16 (int16x8_t __a)\n+{\n+  return -__a;\n+}\n+\n+__extension__ static __inline int32x4_t __attribute__ ((__always_inline__))\n+vnegq_s32 (int32x4_t __a)\n+{\n+  return -__a;\n+}\n+\n+__extension__ static __inline int64x2_t __attribute__ ((__always_inline__))\n+vnegq_s64 (int64x2_t __a)\n+{\n+  return -__a;\n+}\n+\n /* vqabs */\n \n __extension__ static __inline int64x2_t __attribute__ ((__always_inline__))"}, {"sha": "ba5d0ec6e57192b2e62e2fe7a19b022da9b35825", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df625a6166a16c272e797f96382c490fe292eab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df625a6166a16c272e797f96382c490fe292eab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7df625a6166a16c272e797f96382c490fe292eab", "patch": "@@ -1,3 +1,8 @@\n+2013-10-09  Alex Velenko  <Alex.Velenko@arm.com>\n+\n+\t* gcc.target/aarch64/vneg_f.c: New testcase.\n+\t* gcc.target/aarch64/vneg_s.c: New testcase.\n+\n 2013-10-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58568"}, {"sha": "1eaf21d34eb57b4e7e5388a4686fe6341197447a", "filename": "gcc/testsuite/gcc.target/aarch64/vneg_f.c", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df625a6166a16c272e797f96382c490fe292eab/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df625a6166a16c272e797f96382c490fe292eab/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_f.c?ref=7df625a6166a16c272e797f96382c490fe292eab", "patch": "@@ -0,0 +1,273 @@\n+/* Test vneg works correctly.  */\n+/* { dg-do run } */\n+/* { dg-options \"--save-temps\" } */\n+\n+#include <arm_neon.h>\n+\n+#define FLT_EPSILON __FLT_EPSILON__\n+#define DBL_EPSILON __DBL_EPSILON__\n+#define FLT_MAX __FLT_MAX__\n+#define FLT_MIN __FLT_MIN__\n+#define DBL_MAX __DBL_MAX__\n+#define DBL_MIN __DBL_MIN__\n+\n+#define TEST0 0\n+/* 6 digits of pi.  */\n+#define TEST1 3.14159\n+/* 6 digits of -e.  */\n+#define TEST2 -2.71828\n+/* 2^25, float has 24 significand bits\n+   according to Single-precision floating-point format.  */\n+#define TEST3_FLT 33554432\n+/* 2^54, double has 53 significand bits\n+   according to Double-precision floating-point format.  */\n+#define TEST3_DBL 18014398509481984\n+\n+extern void abort (void);\n+\n+#define FLT_INFINITY (__builtin_inff ())\n+#define DBL_INFINITY (__builtin_inf ())\n+\n+#ifndef NAN\n+#define NAN (0.0 / 0.0)\n+#endif\n+\n+#define CONCAT(a, b) a##b\n+#define CONCAT1(a, b) CONCAT (a, b)\n+#define REG_INFEX64 _\n+#define REG_INFEX128 q_\n+#define REG_INFEX(reg_len) REG_INFEX##reg_len\n+#define POSTFIX(reg_len, data_len) \\\n+  CONCAT1 (REG_INFEX (reg_len), f##data_len)\n+\n+#define DATA_TYPE_32 float\n+#define DATA_TYPE_64 double\n+#define DATA_TYPE(data_len) DATA_TYPE_##data_len\n+\n+#define INDEX64_32 [i]\n+#define INDEX64_64\n+#define INDEX128_32 [i]\n+#define INDEX128_64 [i]\n+#define INDEX(reg_len, data_len) \\\n+  CONCAT1 (INDEX, reg_len##_##data_len)\n+\n+#define LOAD_INST(reg_len, data_len) \\\n+  CONCAT1 (vld1, POSTFIX (reg_len, data_len))\n+#define NEG_INST(reg_len, data_len) \\\n+  CONCAT1 (vneg, POSTFIX (reg_len, data_len))\n+\n+#define INHIB_OPTIMIZATION asm volatile (\"\" : : : \"memory\")\n+\n+#define RUN_TEST(test_set, reg_len, data_len, n, a, b) \\\n+  {\t\t\t\t\t\t       \\\n+    int i;\t\t\t\t\t       \\\n+    (a) = LOAD_INST (reg_len, data_len) (test_set);    \\\n+    (b) = NEG_INST (reg_len, data_len) (a);\t       \\\n+    for (i = 0; i < n; i++)\t\t\t       \\\n+      {\t\t\t\t\t\t       \\\n+\tDATA_TYPE (data_len) diff;\t\t       \\\n+\tINHIB_OPTIMIZATION;\t\t\t       \\\n+\tdiff\t\t\t\t\t       \\\n+\t  = a INDEX (reg_len, data_len)\t\t       \\\n+\t    + b INDEX (reg_len, data_len);\t       \\\n+\tif (diff > EPSILON)\t\t\t       \\\n+\t  return 1;\t\t\t\t       \\\n+      }\t\t\t\t\t\t       \\\n+  }\n+\n+#define TEST3 TEST3_FLT\n+#define EPSILON FLT_EPSILON\n+#define VAR_MIN FLT_MIN\n+#define VAR_MAX FLT_MAX\n+#define INFINITY FLT_INFINITY\n+\n+int\n+test_vneg_f32 ()\n+{\n+  float test_set0[2] = { TEST0, TEST1 };\n+  float test_set1[2] = { TEST2, TEST3 };\n+  float test_set2[2] = { VAR_MAX, VAR_MIN };\n+  float test_set3[2] = { INFINITY, NAN };\n+\n+  float32x2_t a;\n+  float32x2_t b;\n+\n+  RUN_TEST (test_set0, 64, 32, 2, a, b);\n+  RUN_TEST (test_set1, 64, 32, 2, a, b);\n+  RUN_TEST (test_set2, 64, 32, 2, a, b);\n+  RUN_TEST (test_set3, 64, 32, 0, a, b);\n+\n+  /* Since last test cannot be checked in a uniform way by adding\n+     negation result to original value, the number of lanes to be\n+     checked in RUN_TEST is 0 (last argument).  Instead, result\n+     will be checked manually.  */\n+\n+  if (b[0] != -INFINITY)\n+    return 1;\n+\n+  if (!__builtin_isnan (b[1]))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"fneg\\\\tv\\[0-9\\]+\\.2s, v\\[0-9\\]+\\.2s\" 4 } } */\n+\n+#undef TEST3\n+#undef EPSILON\n+#undef VAR_MIN\n+#undef VAR_MAX\n+#undef INFINITY\n+\n+#define TEST3 TEST3_DBL\n+#define EPSILON DBL_EPSILON\n+#define VAR_MIN DBL_MIN\n+#define VAR_MAX DBL_MAX\n+#define INFINITY DBL_INFINITY\n+\n+int\n+test_vneg_f64 ()\n+{\n+  float64x1_t a;\n+  float64x1_t b;\n+\n+  double test_set0[1] = { TEST0 };\n+  double test_set1[1] = { TEST1 };\n+  double test_set2[1] = { TEST2 };\n+  double test_set3[1] = { TEST3 };\n+  double test_set4[1] = { VAR_MAX };\n+  double test_set5[1] = { VAR_MIN };\n+  double test_set6[1] = { INFINITY };\n+  double test_set7[1] = { NAN };\n+\n+  RUN_TEST (test_set0, 64, 64, 1, a, b);\n+  RUN_TEST (test_set1, 64, 64, 1, a, b);\n+  RUN_TEST (test_set2, 64, 64, 1, a, b);\n+  RUN_TEST (test_set3, 64, 64, 1, a, b);\n+  RUN_TEST (test_set4, 64, 64, 1, a, b);\n+  RUN_TEST (test_set5, 64, 64, 1, a, b);\n+  RUN_TEST (test_set6, 64, 64, 0, a, b);\n+\n+  /* Since last test cannot be checked in a uniform way by adding\n+     negation result to original value, the number of lanes to be\n+     checked in RUN_TEST is 0 (last argument).  Instead, result\n+     will be checked manually.  */\n+\n+  if (b != -INFINITY)\n+    return 1;\n+\n+  /* Same as above.  */\n+\n+  RUN_TEST (test_set7, 64, 64, 0, a, b);\n+\n+  if (!__builtin_isnan (b))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"fneg\\\\td\\[0-9\\]+, d\\[0-9\\]+\" 8 } } */\n+\n+#undef TEST3\n+#undef EPSILON\n+#undef VAR_MIN\n+#undef VAR_MAX\n+#undef INFINITY\n+\n+#define TEST3 TEST3_FLT\n+#define EPSILON FLT_EPSILON\n+#define VAR_MIN FLT_MIN\n+#define VAR_MAX FLT_MAX\n+#define INFINITY FLT_INFINITY\n+\n+int\n+test_vnegq_f32 ()\n+{\n+  float32x4_t a;\n+  float32x4_t b;\n+\n+  float test_set0[4] = { TEST0, TEST1, TEST2, TEST3 };\n+  float test_set1[4] = { FLT_MAX, FLT_MIN, INFINITY, NAN };\n+\n+  RUN_TEST (test_set0, 128, 32, 4, a, b);\n+  RUN_TEST (test_set1, 128, 32, 2, a, b);\n+\n+  /* Since last test cannot be fully checked in a uniform way by\n+     adding negation result to original value, the number of lanes\n+     to be checked in RUN_TEST is 0 (last argument).  Instead, result\n+     will be checked manually.  */\n+\n+  if (b[2] != -INFINITY)\n+    return 1;\n+\n+  if (!__builtin_isnan (b[3]))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"fneg\\\\tv\\[0-9\\]+\\.4s, v\\[0-9\\]+\\.4s\" 2 } } */\n+\n+#undef TEST3\n+#undef EPSILON\n+#undef VAR_MIN\n+#undef VAR_MAX\n+#undef INFINITY\n+\n+#define TEST3 TEST3_DBL\n+#define EPSILON DBL_EPSILON\n+#define VAR_MIN DBL_MIN\n+#define VAR_MAX DBL_MAX\n+#define INFINITY DBL_INFINITY\n+\n+int\n+test_vnegq_f64 ()\n+{\n+  float64x2_t a;\n+  float64x2_t b;\n+\n+  double test_set0[2] = { TEST0, TEST1 };\n+  double test_set1[2] = { TEST2, TEST3 };\n+  double test_set2[2] = { FLT_MAX, FLT_MIN };\n+  double test_set3[2] = { INFINITY, NAN };\n+\n+  RUN_TEST (test_set0, 128, 64, 2, a, b);\n+  RUN_TEST (test_set1, 128, 64, 2, a, b);\n+  RUN_TEST (test_set2, 128, 64, 2, a, b);\n+  RUN_TEST (test_set3, 128, 64, 0, a, b);\n+\n+  /* Since last test cannot be checked in a uniform way by adding\n+     negation result to original value, the number of lanes to be\n+     checked in RUN_TEST is 0 (last argument).  Instead, result\n+     will be checked manually.  */\n+\n+  if (b[0] != -INFINITY)\n+    return 1;\n+\n+  if (!__builtin_isnan (b[1]))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"fneg\\\\tv\\[0-9\\]+\\.2d, v\\[0-9\\]+\\.2d\" 4 } } */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  if (test_vneg_f32 ())\n+    abort ();\n+\n+  if (test_vneg_f64 ())\n+    abort ();\n+\n+  if (test_vnegq_f32 ())\n+    abort ();\n+\n+  if (test_vnegq_f64 ())\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "accbf14074b9f9569f7e3662b6571075421f6a27", "filename": "gcc/testsuite/gcc.target/aarch64/vneg_s.c", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df625a6166a16c272e797f96382c490fe292eab/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_s.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df625a6166a16c272e797f96382c490fe292eab/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_s.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_s.c?ref=7df625a6166a16c272e797f96382c490fe292eab", "patch": "@@ -0,0 +1,309 @@\n+/* Test vneg works correctly.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -O3 -Wno-div-by-zero --save-temps\" } */\n+\n+#include <arm_neon.h>\n+#include <limits.h>\n+\n+/* Used to force a variable to a SIMD register.  */\n+#define force_simd(V1)   asm volatile (\"mov %d0, %1.d[0]\"\t\\\n+\t   : \"=w\"(V1)\t\t\t\t\t\t\\\n+\t   : \"w\"(V1)\t\t\t\t\t\t\\\n+\t   : /* No clobbers */);\n+#define INHIB_OPTIMIZATION asm volatile (\"\" : : : \"memory\")\n+\n+#define TEST0 0\n+#define TEST1 1\n+#define TEST2 -1\n+#define TEST3 10\n+#define TEST4 -10\n+#define TEST5 0\n+\n+#define ANSW0 0\n+#define ANSW1 -1\n+#define ANSW2 1\n+#define ANSW3 -10\n+#define ANSW4 10\n+#define ANSW5 0\n+\n+extern void abort (void);\n+\n+#define CONCAT(a, b) a##b\n+#define CONCAT1(a, b) CONCAT (a, b)\n+#define REG_INFEX64 _\n+#define REG_INFEX128 q_\n+#define REG_INFEX(reg_len) REG_INFEX##reg_len\n+#define POSTFIX(reg_len, data_len) \\\n+  CONCAT1 (REG_INFEX (reg_len), s##data_len)\n+#define DATA_TYPE_32 float\n+#define DATA_TYPE_64 double\n+#define DATA_TYPE(data_len) DATA_TYPE_##data_len\n+#define INDEX64_8 [i]\n+#define INDEX64_16 [i]\n+#define INDEX64_32 [i]\n+#define INDEX64_64\n+#define INDEX128_8 [i]\n+#define INDEX128_16 [i]\n+#define INDEX128_32 [i]\n+#define INDEX128_64 [i]\n+\n+#define FORCE_SIMD_INST64_8(data)\n+#define FORCE_SIMD_INST64_16(data)\n+#define FORCE_SIMD_INST64_32(data)\n+#define FORCE_SIMD_INST64_64(data) force_simd (data)\n+#define FORCE_SIMD_INST128_8(data)\n+#define FORCE_SIMD_INST128_16(data)\n+#define FORCE_SIMD_INST128_32(data)\n+#define FORCE_SIMD_INST128_64(data)\n+\n+#define INDEX(reg_len, data_len) \\\n+  CONCAT1 (INDEX, reg_len##_##data_len)\n+#define FORCE_SIMD_INST(reg_len, data_len, data) \\\n+  CONCAT1 (FORCE_SIMD_INST, reg_len##_##data_len) (data)\n+#define LOAD_INST(reg_len, data_len) \\\n+  CONCAT1 (vld1, POSTFIX (reg_len, data_len))\n+#define NEG_INST(reg_len, data_len) \\\n+  CONCAT1 (vneg, POSTFIX (reg_len, data_len))\n+\n+#define RUN_TEST(test_set, answ_set, reg_len, data_len, n, a, b)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    INHIB_OPTIMIZATION;\t\t\t\t\t\t\t\\\n+    (a) = LOAD_INST (reg_len, data_len) (test_set);\t\t\t\\\n+    (b) = LOAD_INST (reg_len, data_len) (answ_set);\t\t\t\\\n+    FORCE_SIMD_INST (reg_len, data_len, a)\t\t\t\t\\\n+    a = NEG_INST (reg_len, data_len) (a);\t\t\t\t\\\n+    FORCE_SIMD_INST (reg_len, data_len, a)\t\t\t\t\\\n+    for (i = 0; i < n; i++)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        INHIB_OPTIMIZATION;\t\t\t\t\t\t\\\n+\tif (a INDEX (reg_len, data_len)\t\t\t\t\t\\\n+\t    != b INDEX (reg_len, data_len))\t\t\t\t\\\n+\t  return 1;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int\n+test_vneg_s8 ()\n+{\n+  int8x8_t a;\n+  int8x8_t b;\n+\n+  int8_t test_set0[8] = {\n+    TEST0, TEST1, TEST2, TEST3, TEST4, TEST5, SCHAR_MAX, SCHAR_MIN\n+  };\n+  int8_t answ_set0[8] = {\n+    ANSW0, ANSW1, ANSW2, ANSW3, ANSW4, ANSW5, SCHAR_MIN + 1, SCHAR_MIN\n+  };\n+\n+  RUN_TEST (test_set0, answ_set0, 64, 8, 8, a, b);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"neg\\\\tv\\[0-9\\]+\\.8b, v\\[0-9\\]+\\.8b\" 1 } } */\n+\n+int\n+test_vneg_s16 ()\n+{\n+  int16x4_t a;\n+  int16x4_t b;\n+\n+  int16_t test_set0[4] = { TEST0, TEST1, TEST2, TEST3 };\n+  int16_t test_set1[4] = { TEST4, TEST5, SHRT_MAX, SHRT_MIN };\n+\n+  int16_t answ_set0[4] = { ANSW0, ANSW1, ANSW2, ANSW3 };\n+  int16_t answ_set1[4] = { ANSW4, ANSW5, SHRT_MIN + 1, SHRT_MIN };\n+\n+  RUN_TEST (test_set0, answ_set0, 64, 16, 4, a, b);\n+  RUN_TEST (test_set1, answ_set1, 64, 16, 4, a, b);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"neg\\\\tv\\[0-9\\]+\\.4h, v\\[0-9\\]+\\.4h\" 2 } } */\n+\n+int\n+test_vneg_s32 ()\n+{\n+  int32x2_t a;\n+  int32x2_t b;\n+\n+  int32_t test_set0[2] = { TEST0, TEST1 };\n+  int32_t test_set1[2] = { TEST2, TEST3 };\n+  int32_t test_set2[2] = { TEST4, TEST5 };\n+  int32_t test_set3[2] = { INT_MAX, INT_MIN };\n+\n+  int32_t answ_set0[2] = { ANSW0, ANSW1 };\n+  int32_t answ_set1[2] = { ANSW2, ANSW3 };\n+  int32_t answ_set2[2] = { ANSW4, ANSW5 };\n+  int32_t answ_set3[2] = { INT_MIN + 1, INT_MIN };\n+\n+  RUN_TEST (test_set0, answ_set0, 64, 32, 2, a, b);\n+  RUN_TEST (test_set1, answ_set1, 64, 32, 2, a, b);\n+  RUN_TEST (test_set2, answ_set2, 64, 32, 2, a, b);\n+  RUN_TEST (test_set3, answ_set3, 64, 32, 2, a, b);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"neg\\\\tv\\[0-9\\]+\\.2s, v\\[0-9\\]+\\.2s\" 4 } } */\n+\n+int\n+test_vneg_s64 ()\n+{\n+  int64x1_t a;\n+  int64x1_t b;\n+\n+  int64_t test_set0[1] = { TEST0 };\n+  int64_t test_set1[1] = { TEST1 };\n+  int64_t test_set2[1] = { TEST2 };\n+  int64_t test_set3[1] = { TEST3 };\n+  int64_t test_set4[1] = { TEST4 };\n+  int64_t test_set5[1] = { TEST5 };\n+  int64_t test_set6[1] = { LLONG_MAX };\n+  int64_t test_set7[1] = { LLONG_MIN };\n+\n+  int64_t answ_set0[1] = { ANSW0 };\n+  int64_t answ_set1[1] = { ANSW1 };\n+  int64_t answ_set2[1] = { ANSW2 };\n+  int64_t answ_set3[1] = { ANSW3 };\n+  int64_t answ_set4[1] = { ANSW4 };\n+  int64_t answ_set5[1] = { ANSW5 };\n+  int64_t answ_set6[1] = { LLONG_MIN + 1 };\n+  int64_t answ_set7[1] = { LLONG_MIN };\n+\n+  RUN_TEST (test_set0, answ_set0, 64, 64, 1, a, b);\n+  RUN_TEST (test_set1, answ_set1, 64, 64, 1, a, b);\n+  RUN_TEST (test_set2, answ_set2, 64, 64, 1, a, b);\n+  RUN_TEST (test_set3, answ_set3, 64, 64, 1, a, b);\n+  RUN_TEST (test_set4, answ_set4, 64, 64, 1, a, b);\n+  RUN_TEST (test_set5, answ_set5, 64, 64, 1, a, b);\n+  RUN_TEST (test_set6, answ_set6, 64, 64, 1, a, b);\n+  RUN_TEST (test_set7, answ_set7, 64, 64, 1, a, b);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"neg\\\\td\\[0-9\\]+, d\\[0-9\\]+\" 8 } } */\n+\n+int\n+test_vnegq_s8 ()\n+{\n+  int8x16_t a;\n+  int8x16_t b;\n+\n+  int8_t test_set0[16] = {\n+    TEST0, TEST1, TEST2, TEST3, TEST4, TEST5, SCHAR_MAX, SCHAR_MIN,\n+    4, 8, 15, 16, 23, 42, -1, -2\n+  };\n+\n+  int8_t answ_set0[16] = {\n+    ANSW0, ANSW1, ANSW2, ANSW3, ANSW4, ANSW5, SCHAR_MIN + 1, SCHAR_MIN,\n+    -4, -8, -15, -16, -23, -42, 1, 2\n+  };\n+\n+  RUN_TEST (test_set0, answ_set0, 128, 8, 8, a, b);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"neg\\\\tv\\[0-9\\]+\\.16b, v\\[0-9\\]+\\.16b\" 1 } } */\n+\n+int\n+test_vnegq_s16 ()\n+{\n+  int16x8_t a;\n+  int16x8_t b;\n+\n+  int16_t test_set0[8] = {\n+    TEST0, TEST1, TEST2, TEST3, TEST4, TEST5, SHRT_MAX, SHRT_MIN\n+  };\n+  int16_t answ_set0[8] = {\n+    ANSW0, ANSW1, ANSW2, ANSW3, ANSW4, ANSW5, SHRT_MIN + 1, SHRT_MIN\n+  };\n+\n+  RUN_TEST (test_set0, answ_set0, 128, 16, 8, a, b);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"neg\\\\tv\\[0-9\\]+\\.8h, v\\[0-9\\]+\\.8h\" 1 } } */\n+\n+int\n+test_vnegq_s32 ()\n+{\n+  int32x4_t a;\n+  int32x4_t b;\n+\n+  int32_t test_set0[4] = { TEST0, TEST1, TEST2, TEST3 };\n+  int32_t test_set1[4] = { TEST4, TEST5, INT_MAX, INT_MIN };\n+\n+  int32_t answ_set0[4] = { ANSW0, ANSW1, ANSW2, ANSW3 };\n+  int32_t answ_set1[4] = { ANSW4, ANSW5, INT_MIN + 1, INT_MIN };\n+\n+  RUN_TEST (test_set0, answ_set0, 128, 32, 4, a, b);\n+  RUN_TEST (test_set1, answ_set1, 128, 32, 4, a, b);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"neg\\\\tv\\[0-9\\]+\\.4s, v\\[0-9\\]+\\.4s\" 2 } } */\n+\n+int\n+test_vnegq_s64 ()\n+{\n+  int64x2_t a;\n+  int64x2_t b;\n+\n+  int64_t test_set0[2] = { TEST0, TEST1 };\n+  int64_t test_set1[2] = { TEST2, TEST3 };\n+  int64_t test_set2[2] = { TEST4, TEST5 };\n+  int64_t test_set3[2] = { LLONG_MAX, LLONG_MIN };\n+\n+  int64_t answ_set0[2] = { ANSW0, ANSW1 };\n+  int64_t answ_set1[2] = { ANSW2, ANSW3 };\n+  int64_t answ_set2[2] = { ANSW4, ANSW5 };\n+  int64_t answ_set3[2] = { LLONG_MIN + 1, LLONG_MIN };\n+\n+  RUN_TEST (test_set0, answ_set0, 128, 64, 2, a, b);\n+  RUN_TEST (test_set1, answ_set1, 128, 64, 2, a, b);\n+  RUN_TEST (test_set2, answ_set2, 128, 64, 2, a, b);\n+  RUN_TEST (test_set3, answ_set3, 128, 64, 2, a, b);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"neg\\\\tv\\[0-9\\]+\\.2d, v\\[0-9\\]+\\.2d\" 4 } } */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  if (test_vneg_s8 ())\n+    abort ();\n+\n+  if (test_vneg_s16 ())\n+    abort ();\n+\n+  if (test_vneg_s32 ())\n+    abort ();\n+\n+  if (test_vneg_s64 ())\n+    abort ();\n+\n+  if (test_vnegq_s8 ())\n+    abort ();\n+\n+  if (test_vnegq_s16 ())\n+    abort ();\n+\n+  if (test_vnegq_s32 ())\n+    abort ();\n+\n+  if (test_vnegq_s64 ())\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-saved-temps } } */"}]}