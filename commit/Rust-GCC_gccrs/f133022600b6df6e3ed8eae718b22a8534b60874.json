{"sha": "f133022600b6df6e3ed8eae718b22a8534b60874", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEzMzAyMjYwMGI2ZGY2ZTNlZDhlYWU3MThiMjJhODUzNGI2MDg3NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-08-04T12:08:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-08-04T12:08:43Z"}, "message": "* loop.c (try_copy_prop); Kill invalidated REG_EQUAL notes.\n\n\t* reload1.c (fixup_abnormal_edges): New static function.\n\t(reload): Use it.\n\n\t* flow.c (need_fake_edge_p): New function.\n\t(flow_call_edges_add): Fix handling of noreturn and sibbling calls;\n\tavoid call insn to be very last insn in the insn stream.\n\n\t* profile.c (branch_prob): Call flow_call_edges_add instead of\n\tdoing that by hand; cleanup cfg to re-merge basic blocks once\n\twe are done.\n\nFrom-SVN: r44635", "tree": {"sha": "52edd2af4071bdd3a36e9e4326fda3898b0340fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52edd2af4071bdd3a36e9e4326fda3898b0340fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f133022600b6df6e3ed8eae718b22a8534b60874", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f133022600b6df6e3ed8eae718b22a8534b60874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f133022600b6df6e3ed8eae718b22a8534b60874", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f133022600b6df6e3ed8eae718b22a8534b60874/comments", "author": null, "committer": null, "parents": [{"sha": "ef6e958a8611ff372211d0fd3cd9659614583bb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6e958a8611ff372211d0fd3cd9659614583bb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef6e958a8611ff372211d0fd3cd9659614583bb4"}], "stats": {"total": 184, "additions": 157, "deletions": 27}, "files": [{"sha": "7450115260257eb2960bc696dbabd84e9079b6bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f133022600b6df6e3ed8eae718b22a8534b60874/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f133022600b6df6e3ed8eae718b22a8534b60874/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f133022600b6df6e3ed8eae718b22a8534b60874", "patch": "@@ -1,3 +1,18 @@\n+Sat Aug  4 13:51:36 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* loop.c (try_copy_prop); Kill invalidated REG_EQUAL notes.\n+\n+\t* reload1.c (fixup_abnormal_edges): New static function.\n+\t(reload): Use it.\n+\n+\t* flow.c (need_fake_edge_p): New function.\n+\t(flow_call_edges_add): Fix handling of noreturn and sibbling calls;\n+\tavoid call insn to be very last insn in the insn stream.\n+\n+\t* profile.c (branch_prob): Call flow_call_edges_add instead of\n+\tdoing that by hand; cleanup cfg to re-merge basic blocks once\n+\twe are done.\n+\n 2001-08-04  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n \n \t* Makefile.in (CPPLIB_H): New, so that dependencies on cpplib.h"}, {"sha": "c602fb179d01bc8e7034681b4d7497f49ed9eee1", "filename": "gcc/flow.c", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f133022600b6df6e3ed8eae718b22a8534b60874/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f133022600b6df6e3ed8eae718b22a8534b60874/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f133022600b6df6e3ed8eae718b22a8534b60874", "patch": "@@ -485,6 +485,7 @@ static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n static void delete_dead_jumptables\tPARAMS ((void));\n static bool back_edge_of_syntactic_loop_p PARAMS ((basic_block, basic_block));\n+static bool need_fake_edge_p\t\tPARAMS ((rtx));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -2500,9 +2501,35 @@ commit_edge_insertions ()\n     }\n }\n \n-/* Add fake edges to the function exit for any non constant calls in\n-   the bitmap of blocks specified by BLOCKS or to the whole CFG if\n-   BLOCKS is zero.  Return the nuber of blocks that were split.  */\n+/* Return true if we need to add fake edge to exit.\n+   Helper function for the flow_call_edges_add.  */\n+static bool\n+need_fake_edge_p (insn)\n+     rtx insn;\n+{\n+  if (!INSN_P (insn))\n+    return false;\n+\n+  if ((GET_CODE (insn) == CALL_INSN\n+       && !SIBLING_CALL_P (insn)\n+       && !find_reg_note (insn, REG_NORETURN, NULL) && !CONST_CALL_P (insn)))\n+    return true;\n+\n+  return ((GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n+\t   && MEM_VOLATILE_P (PATTERN (insn)))\n+\t  || (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t      && asm_noperands (insn) != -1\n+\t      && MEM_VOLATILE_P (XVECEXP (PATTERN (insn), 0, 0)))\n+\t  || GET_CODE (PATTERN (insn)) == ASM_INPUT);\n+}\n+\n+/* Add fake edges to the function exit for any non constant and non noreturn\n+   calls, volatile inline assembly in the bitmap of blocks specified by\n+   BLOCKS or to the whole CFG if BLOCKS is zero.  Return the nuber of blocks\n+   that were split. \n+\n+   The goal is to expose cases in which entering a basic block does not imply\n+   that all subsequent instructions must be executed.  */\n \n int\n flow_call_edges_add (blocks)\n@@ -2512,6 +2539,7 @@ flow_call_edges_add (blocks)\n   int blocks_split = 0;\n   int bb_num = 0;\n   basic_block *bbs;\n+  bool check_last_block = false;\n \n   /* Map bb indicies into basic block pointers since split_block\n      will renumber the basic blocks.  */\n@@ -2522,15 +2550,41 @@ flow_call_edges_add (blocks)\n     {\n       for (i = 0; i < n_basic_blocks; i++)\n \tbbs[bb_num++] = BASIC_BLOCK (i);\n+      check_last_block = true;\n     }\n   else\n     {\n       EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i, \n       {\n \tbbs[bb_num++] = BASIC_BLOCK (i);\n+\tif (i == n_basic_blocks - 1)\n+\t  check_last_block = true;\n       });\n     }\n \n+  /* In the last basic block, before epilogue generation, there will be\n+     a fallthru edge to EXIT.  Special care is required if the last insn\n+     of the last basic block is a call because make_edge folds duplicate\n+     edges, which would result in the fallthru edge also being marked\n+     fake, which would result in the fallthru edge being removed by \n+     remove_fake_edges, which would result in an invalid CFG.\n+\n+     Moreover, we can't elide the outgoing fake edge, since the block\n+     profiler needs to take this into account in order to solve the minimal\n+     spanning tree in the case that the call doesn't return.\n+\n+     Handle this by adding a dummy instruction in a new last basic block.  */\n+  if (check_last_block\n+      && need_fake_edge_p (BASIC_BLOCK (n_basic_blocks - 1)->end))\n+    {\n+       edge e;\n+       for (e = BASIC_BLOCK (n_basic_blocks - 1)->succ; e; e = e->succ_next)\n+\t if (e->dest == EXIT_BLOCK_PTR)\n+\t    break;\n+       insert_insn_on_edge (gen_rtx_USE (VOIDmode, const0_rtx), e);\n+       commit_edge_insertions ();\n+    }\n+\n \n   /* Now add fake edges to the function exit for any non constant\n      calls since there is no way that we can determine if they will\n@@ -2545,10 +2599,21 @@ flow_call_edges_add (blocks)\n       for (insn = bb->end; ; insn = prev_insn)\n \t{\n \t  prev_insn = PREV_INSN (insn);\n-\t  if (GET_CODE (insn) == CALL_INSN && ! CONST_CALL_P (insn))\n+\t  if (need_fake_edge_p (insn))\n \t    {\n \t      edge e;\n \n+\t      /* The above condition should be enought to verify that there is\n+\t\t no edge to the exit block in CFG already.  Calling make_edge in\n+\t\t such case would make us to mark that edge as fake and remove it\n+\t\t later.  */\n+#ifdef ENABLE_CHECKING\n+\t      if (insn == bb->end)\n+\t\tfor (e = bb->succ; e; e = e->succ_next)\n+\t\t  if (e->dest == EXIT_BLOCK_PTR)\n+\t\t    abort ();\n+#endif\n+\n \t      /* Note that the following may create a new basic block\n \t\t and renumber the existing basic blocks.  */\n \t      e = split_block (bb, insn);"}, {"sha": "fbbef734b7c70934e6a9d5d4c8327fbea4410ca9", "filename": "gcc/loop.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f133022600b6df6e3ed8eae718b22a8534b60874/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f133022600b6df6e3ed8eae718b22a8534b60874/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=f133022600b6df6e3ed8eae718b22a8534b60874", "patch": "@@ -9289,7 +9289,16 @@ try_copy_prop (loop, replacement, regno)\n \t  arg.set_seen = 0;\n \t  note_stores (PATTERN (insn), note_reg_stored, &arg);\n \t  if (arg.set_seen)\n-\t    break;\n+\t    {\n+\t      rtx note = find_reg_note (insn, REG_EQUAL, NULL);\n+\n+\t      /* It is possible that we've turned previously valid REG_EQUAL to\n+\t         invalid, as we change the REGNO to REPLACEMENT and unlike REGNO,\n+\t         REPLACEMENT is modified, we get different meaning.  */\n+\t      if (note && reg_mentioned_p (replacement, XEXP (note, 0)))\n+\t\tremove_note (insn, note);\n+\t      break;\n+\t    }\n \t}\n     }\n   if (! init_insn)"}, {"sha": "1335e9cd5939556bae3b631cf25851676e607a8c", "filename": "gcc/profile.c", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f133022600b6df6e3ed8eae718b22a8534b60874/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f133022600b6df6e3ed8eae718b22a8534b60874/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=f133022600b6df6e3ed8eae718b22a8534b60874", "patch": "@@ -528,6 +528,8 @@ branch_prob ()\n \n   total_num_times_called++;\n \n+  flow_call_edges_add (NULL);\n+\n   /* We can't handle cyclic regions constructed using abnormal edges.\n      To avoid these we replace every source of abnormal edge by a fake\n      edge from entry node and every destination by fake edge to exit.\n@@ -562,28 +564,6 @@ branch_prob ()\n \t    have_entry_edge = 1;\n \t}\n \n-      /* ??? Not strictly needed unless flag_test_coverage, but adding\n-\t them anyway keeps the .da file consistent.  */\n-      /* ??? Currently inexact for basic blocks with multiple calls. \n-\t We need to split blocks here.  */\n-      for (insn = bb->head;\n-\t   insn != NEXT_INSN (bb->end);\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  rtx set;\n-\t  if (GET_CODE (insn) == CALL_INSN && !CONST_CALL_P (insn))\n-\t    need_exit_edge = 1;\n-\t  else if (GET_CODE (insn) == INSN)\n-\t    {\n-\t      set = PATTERN (insn);\n-\t      if (GET_CODE (set) == PARALLEL)\n-\t\tset = XVECEXP (set, 0, 0);\n-\t      if ((GET_CODE (set) == ASM_OPERANDS && MEM_VOLATILE_P (set))\n-\t\t  || GET_CODE (set) == ASM_INPUT)\n-\t\tneed_exit_edge = 1;\n-\t    }\n-\t}\n-\n       if (need_exit_edge && !have_exit_edge)\n \t{\n \t  if (rtl_dump_file)\n@@ -787,6 +767,12 @@ branch_prob ()\n     }\n \n   remove_fake_edges ();\n+  /* Re-merge split basic blocks and the mess introduced by\n+     insert_insn_on_edge.  */\n+  cleanup_cfg (profile_arc_flag ? CLEANUP_EXPENSIVE : 0);\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+\n   free (edge_infos);\n   free_edge_list (el);\n }"}, {"sha": "09ef4ef99779f7456dcd97f85d96498f6e11f199", "filename": "gcc/reload1.c", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f133022600b6df6e3ed8eae718b22a8534b60874/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f133022600b6df6e3ed8eae718b22a8534b60874/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f133022600b6df6e3ed8eae718b22a8534b60874", "patch": "@@ -461,6 +461,7 @@ static void failed_reload\t\tPARAMS ((rtx, int));\n static int set_reload_reg\t\tPARAMS ((int, int));\n static void reload_cse_delete_noop_set\tPARAMS ((rtx, rtx));\n static void reload_cse_simplify\t\tPARAMS ((rtx));\n+static void fixup_abnormal_edges\tPARAMS ((void));\n extern void dump_needs\t\t\tPARAMS ((struct insn_chain *));\n \f\n /* Initialize the reload pass once per compilation.  */\n@@ -1269,6 +1270,7 @@ reload (first, global)\n   /* Free all the insn_chain structures at once.  */\n   obstack_free (&reload_obstack, reload_startobj);\n   unused_insn_chains = 0;\n+  fixup_abnormal_edges ();\n \n   return failure;\n }\n@@ -9470,3 +9472,56 @@ copy_eh_notes (insn, x)\n     }\n }\n \n+/* This is used by reload pass, that does emit some instructions after\n+   abnormal calls moving basic block end, but in fact it wants to emit\n+   them on the edge.  Looks for abnormal call edges, find backward the\n+   proper call and fix the damage.\n+ \n+   Similar handle instructions throwing exceptions internally.  */\n+static void\n+fixup_abnormal_edges ()\n+{\n+  int i;\n+  bool inserted = false;\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      edge e;\n+\n+      /* Look for cases we are interested in - an calls or instructions causing\n+         exceptions.  */\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  if (e->flags & EDGE_ABNORMAL_CALL)\n+\t    break;\n+\t  if ((e->flags & (EDGE_ABNORMAL | EDGE_EH))\n+\t      == (EDGE_ABNORMAL | EDGE_EH))\n+\t    break;\n+\t}\n+      if (e && GET_CODE (bb->end) != CALL_INSN && !can_throw_internal (bb->end))\n+\t{\n+\t  rtx insn = bb->end;\n+\t  rtx next;\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    if (e->flags & EDGE_FALLTHRU)\n+\t      break;\n+\t  while (GET_CODE (insn) == INSN && !can_throw_internal (insn))\n+\t    insn = PREV_INSN (insn);\n+\t  if (GET_CODE (insn) != CALL_INSN && !can_throw_internal (insn))\n+\t    abort ();\n+\t  bb->end = insn;\n+\t  inserted = true;\n+\t  insn = NEXT_INSN (insn);\n+\t  while (insn && GET_CODE (insn) == INSN)\n+\t    {\n+\t      next = NEXT_INSN (insn);\n+\t      insert_insn_on_edge (PATTERN (insn), e);\n+\t      flow_delete_insn (insn);\n+\t      insn = next;\n+\t    }\n+\t}\n+    }\n+  if (inserted)\n+    commit_edge_insertions ();\n+}"}]}