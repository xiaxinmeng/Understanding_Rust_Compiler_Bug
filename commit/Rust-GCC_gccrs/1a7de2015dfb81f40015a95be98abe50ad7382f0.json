{"sha": "1a7de2015dfb81f40015a95be98abe50ad7382f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE3ZGUyMDE1ZGZiODFmNDAwMTVhOTViZTk4YWJlNTBhZDczODJmMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-10-23T09:57:36Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-23T09:57:36Z"}, "message": "re PR tree-optimization/54967 (ICE in check_loop_closed_ssa_use, at tree-ssa-loop-manip.c:55)\n\n\n\tPR middle-end/54967\n\t* cfgloopmanip.c (fix_bb_placements): Add loop_closed_ssa_invalidated;\n\ttrack basic blocks that moved out of their loops.\n\t(unloop): Likewise.\n\t(remove_path): Update.\n\t(fix_loop_placements): Update.\n\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Add\n\tloop_closed_ssa_invalidated parameter; pass it around.\n\t(canonicalize_loop_induction_variables): Update loop closed\n\tSSA form if needed.\n\t(tree_unroll_loops_completely): Likewise; do irred update out of\n\tthe outer loop; verify that SSA form is closed.\n\t* cfgloop.h (unrloop): Update.\n\n\t* gfortran.dg/pr54967.f90: New testcase.\n\nFrom-SVN: r192709", "tree": {"sha": "dff1e819fae3b996fcd725e178165e8cf066a614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dff1e819fae3b996fcd725e178165e8cf066a614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a7de2015dfb81f40015a95be98abe50ad7382f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a7de2015dfb81f40015a95be98abe50ad7382f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a7de2015dfb81f40015a95be98abe50ad7382f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a7de2015dfb81f40015a95be98abe50ad7382f0/comments", "author": null, "committer": null, "parents": [{"sha": "e8028ecdd02be651ec23cfdbc7e31c5b4b198ce1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8028ecdd02be651ec23cfdbc7e31c5b4b198ce1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8028ecdd02be651ec23cfdbc7e31c5b4b198ce1"}], "stats": {"total": 146, "additions": 122, "deletions": 24}, "files": [{"sha": "d9c294eb2ab451aa897480e2d67b951ffea1e0c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a7de2015dfb81f40015a95be98abe50ad7382f0", "patch": "@@ -1,3 +1,19 @@\n+2012-10-23  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/54967\n+\t* cfgloopmanip.c (fix_bb_placements): Add loop_closed_ssa_invalidated;\n+\ttrack basic blocks that moved out of their loops.\n+\t(unloop): Likewise.\n+\t(remove_path): Update.\n+\t(fix_loop_placements): Update.\n+\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Add\n+\tloop_closed_ssa_invalidated parameter; pass it around.\n+\t(canonicalize_loop_induction_variables): Update loop closed\n+\tSSA form if needed.\n+\t(tree_unroll_loops_completely): Likewise; do irred update out of\n+\tthe outer loop; verify that SSA form is closed.\n+\t* cfgloop.h (unrloop): Update.\n+\n 2012-10-23  Terry Guo  <terry.guo@arm.com>\n \n \tPR target/55019"}, {"sha": "94ad6372d2848e7808b3bb6424f6bd30741fa6a1", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=1a7de2015dfb81f40015a95be98abe50ad7382f0", "patch": "@@ -321,7 +321,7 @@ extern struct loop *loopify (edge, edge,\n struct loop * loop_version (struct loop *, void *,\n \t\t\t    basic_block *, unsigned, unsigned, unsigned, bool);\n extern bool remove_path (edge);\n-extern void unloop (struct loop *, bool *);\n+extern void unloop (struct loop *, bool *, bitmap);\n extern void scale_loop_frequencies (struct loop *, int, int);\n \n /* Induction variable analysis.  */"}, {"sha": "eae68ca43c79b9089d5ccf1c738531f38b432f85", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=1a7de2015dfb81f40015a95be98abe50ad7382f0", "patch": "@@ -36,7 +36,7 @@ static bool rpe_enum_p (const_basic_block, const void *);\n static int find_path (edge, basic_block **);\n static void fix_loop_placements (struct loop *, bool *);\n static bool fix_bb_placement (basic_block);\n-static void fix_bb_placements (basic_block, bool *);\n+static void fix_bb_placements (basic_block, bool *, bitmap);\n \n /* Checks whether basic block BB is dominated by DATA.  */\n static bool\n@@ -159,11 +159,15 @@ fix_loop_placement (struct loop *loop)\n    successors we consider edges coming out of the loops.\n \n    If the changes may invalidate the information about irreducible regions,\n-   IRRED_INVALIDATED is set to true.  */\n+   IRRED_INVALIDATED is set to true.  \n+\n+   If LOOP_CLOSED_SSA_INVLIDATED is non-zero then all basic blocks with\n+   changed loop_father are collected there. */\n \n static void\n fix_bb_placements (basic_block from,\n-\t\t   bool *irred_invalidated)\n+\t\t   bool *irred_invalidated,\n+\t\t   bitmap loop_closed_ssa_invalidated)\n {\n   sbitmap in_queue;\n   basic_block *queue, *qtop, *qbeg, *qend;\n@@ -218,6 +222,8 @@ fix_bb_placements (basic_block from,\n \t  /* Ordinary basic block.  */\n \t  if (!fix_bb_placement (from))\n \t    continue;\n+\t  if (loop_closed_ssa_invalidated)\n+\t    bitmap_set_bit (loop_closed_ssa_invalidated, from->index);\n \t  target_loop = from->loop_father;\n \t}\n \n@@ -312,7 +318,7 @@ remove_path (edge e)\n     {\n       f = loop_outer (l);\n       if (dominated_by_p (CDI_DOMINATORS, l->latch, e->dest))\n-        unloop (l, &irred_invalidated);\n+        unloop (l, &irred_invalidated, NULL);\n     }\n \n   /* Identify the path.  */\n@@ -385,7 +391,7 @@ remove_path (edge e)\n \n   /* Fix placements of basic blocks inside loops and the placement of\n      loops in the loop tree.  */\n-  fix_bb_placements (from, &irred_invalidated);\n+  fix_bb_placements (from, &irred_invalidated, NULL);\n   fix_loop_placements (from->loop_father, &irred_invalidated);\n \n   if (irred_invalidated\n@@ -892,10 +898,14 @@ loopify (edge latch_edge, edge header_edge,\n    have no successor, which caller is expected to fix somehow.\n \n    If this may cause the information about irreducible regions to become\n-   invalid, IRRED_INVALIDATED is set to true.  */\n+   invalid, IRRED_INVALIDATED is set to true.  \n+\n+   LOOP_CLOSED_SSA_INVALIDATED, if non-NULL, is a bitmap where we store\n+   basic blocks that had non-trivial update on their loop_father.*/\n \n void\n-unloop (struct loop *loop, bool *irred_invalidated)\n+unloop (struct loop *loop, bool *irred_invalidated,\n+\tbitmap loop_closed_ssa_invalidated)\n {\n   basic_block *body;\n   struct loop *ploop;\n@@ -937,7 +947,7 @@ unloop (struct loop *loop, bool *irred_invalidated)\n   /* We do not pass IRRED_INVALIDATED to fix_bb_placements here, as even if\n      there is an irreducible region inside the cancelled loop, the flags will\n      be still correct.  */\n-  fix_bb_placements (latch, &dummy);\n+  fix_bb_placements (latch, &dummy, loop_closed_ssa_invalidated);\n }\n \n /* Fix placement of superloops of LOOP inside loop tree, i.e. ensure that\n@@ -965,7 +975,7 @@ fix_loop_placements (struct loop *loop, bool *irred_invalidated)\n \t to the loop.  So call fix_bb_placements to fix up the placement\n \t of the preheader and (possibly) of its predecessors.  */\n       fix_bb_placements (loop_preheader_edge (loop)->src,\n-\t\t\t irred_invalidated);\n+\t\t\t irred_invalidated, NULL);\n       loop = outer;\n     }\n }"}, {"sha": "7daf70e366d55969cb13689409ad39e9fd88fc24", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a7de2015dfb81f40015a95be98abe50ad7382f0", "patch": "@@ -1,3 +1,8 @@\n+2012-10-23  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/54967\n+\t* gfortran.dg/pr54967.f90: New testcase.\n+\n 2012-10-23  Terry Guo  <terry.guo@arm.com>\n \n \tPR target/55019"}, {"sha": "f674e3ec19c8ca89785269e4d85adb2ab0bf12cc", "filename": "gcc/testsuite/gfortran.dg/pr54967.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr54967.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr54967.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr54967.f90?ref=1a7de2015dfb81f40015a95be98abe50ad7382f0", "patch": "@@ -0,0 +1,36 @@\n+ SUBROUTINE calc_S_derivs()\n+    INTEGER, DIMENSION(6, 2)      :: c_map_mat\n+    INTEGER, DIMENSION(:), POINTER:: C_mat\n+    DO j=1,3\n+       DO m=j,3\n+          n=n+1\n+          c_map_mat(n,1)=j\n+          IF(m==j)CYCLE\n+          c_map_mat(n,2)=m\n+       END DO\n+    END DO\n+    DO m=1,6\n+       DO j=1,2\n+          IF(c_map_mat(m,j)==0)CYCLE\n+          CALL foo(C_mat(c_map_mat(m,j))) \n+       END DO\n+    END DO\n+  END SUBROUTINE calc_S_derivs\n+ SUBROUTINE calc_S_derivs()\n+    INTEGER, DIMENSION(6, 2)      :: c_map_mat\n+    INTEGER, DIMENSION(:), POINTER:: C_mat\n+    DO j=1,3\n+       DO m=j,3\n+          n=n+1\n+          c_map_mat(n,1)=j\n+          IF(m==j)CYCLE\n+          c_map_mat(n,2)=m\n+       END DO\n+    END DO\n+    DO m=1,6\n+       DO j=1,2\n+          IF(c_map_mat(m,j)==0)CYCLE\n+          CALL foo(C_mat(c_map_mat(m,j))) \n+       END DO\n+    END DO\n+  END SUBROUTINE calc_S_derivs"}, {"sha": "323045f32eb9f0e3a24331f170a3feac3380e34e", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a7de2015dfb81f40015a95be98abe50ad7382f0/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=1a7de2015dfb81f40015a95be98abe50ad7382f0", "patch": "@@ -390,13 +390,16 @@ loop_edge_to_cancel (struct loop *loop)\n    EXIT is the exit of the loop that should be eliminated.  \n    IRRED_INVALIDATED is used to bookkeep if information about\n    irreducible regions may become invalid as a result\n-   of the transformation.  */\n+   of the transformation.  \n+   LOOP_CLOSED_SSA_INVALIDATED is used to bookkepp the case\n+   when we need to go into loop closed SSA form.  */\n \n static bool\n try_unroll_loop_completely (struct loop *loop,\n \t\t\t    edge exit, tree niter,\n \t\t\t    enum unroll_level ul,\n-\t\t\t    bool *irred_invalidated)\n+\t\t\t    bool *irred_invalidated,\n+\t\t\t    bitmap loop_closed_ssa_invalidated)\n {\n   unsigned HOST_WIDE_INT n_unroll, ninsns, max_unroll, unr_insns;\n   gimple cond;\n@@ -562,7 +565,7 @@ try_unroll_loop_completely (struct loop *loop,\n       locus = latch_edge->goto_locus;\n \n       /* Unloop destroys the latch edge.  */\n-      unloop (loop, irred_invalidated);\n+      unloop (loop, irred_invalidated, loop_closed_ssa_invalidated);\n \n       /* Create new basic block for the latch edge destination and wire\n \t it in.  */\n@@ -615,7 +618,8 @@ static bool\n canonicalize_loop_induction_variables (struct loop *loop,\n \t\t\t\t       bool create_iv, enum unroll_level ul,\n \t\t\t\t       bool try_eval,\n-\t\t\t\t       bool *irred_invalidated)\n+\t\t\t\t       bool *irred_invalidated,\n+\t\t\t\t       bitmap loop_closed_ssa_invalidated)\n {\n   edge exit = NULL;\n   tree niter;\n@@ -663,7 +667,8 @@ canonicalize_loop_induction_variables (struct loop *loop,\n \t       (int)max_loop_iterations_int (loop));\n     }\n \n-  if (try_unroll_loop_completely (loop, exit, niter, ul, irred_invalidated))\n+  if (try_unroll_loop_completely (loop, exit, niter, ul, irred_invalidated,\n+\t\t\t\t  loop_closed_ssa_invalidated))\n     return true;\n \n   if (create_iv\n@@ -683,13 +688,15 @@ canonicalize_induction_variables (void)\n   struct loop *loop;\n   bool changed = false;\n   bool irred_invalidated = false;\n+  bitmap loop_closed_ssa_invalidated = BITMAP_ALLOC (NULL);\n \n   FOR_EACH_LOOP (li, loop, 0)\n     {\n       changed |= canonicalize_loop_induction_variables (loop,\n \t\t\t\t\t\t\ttrue, UL_SINGLE_ITER,\n \t\t\t\t\t\t\ttrue,\n-\t\t\t\t\t\t\t&irred_invalidated);\n+\t\t\t\t\t\t\t&irred_invalidated,\n+\t\t\t\t\t\t\tloop_closed_ssa_invalidated);\n     }\n   gcc_assert (!need_ssa_update_p (cfun));\n \n@@ -701,6 +708,13 @@ canonicalize_induction_variables (void)\n      evaluation could reveal new information.  */\n   scev_reset ();\n \n+  if (!bitmap_empty_p (loop_closed_ssa_invalidated))\n+    {\n+      gcc_checking_assert (loops_state_satisfies_p (LOOP_CLOSED_SSA));\n+      rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+    }\n+  BITMAP_FREE (loop_closed_ssa_invalidated);\n+\n   if (changed)\n     return TODO_cleanup_cfg;\n   return 0;\n@@ -794,11 +808,15 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n   bool changed;\n   enum unroll_level ul;\n   int iteration = 0;\n+  bool irred_invalidated = false;\n \n   do\n     {\n-      bool irred_invalidated = false;\n       changed = false;\n+      bitmap loop_closed_ssa_invalidated = NULL;\n+\n+      if (loops_state_satisfies_p (LOOP_CLOSED_SSA))\n+\tloop_closed_ssa_invalidated = BITMAP_ALLOC (NULL);\n \n       FOR_EACH_LOOP (li, loop, 0)\n \t{\n@@ -812,9 +830,9 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \t  else\n \t    ul = UL_NO_GROWTH;\n \n-\t  if (canonicalize_loop_induction_variables (loop, false, ul,\n-\t\t\t\t\t\t     !flag_tree_loop_ivcanon,\n-\t\t\t\t\t\t     &irred_invalidated))\n+\t  if (canonicalize_loop_induction_variables\n+\t\t (loop, false, ul, !flag_tree_loop_ivcanon,\n+\t\t  &irred_invalidated, loop_closed_ssa_invalidated))\n \t    {\n \t      changed = true;\n \t      /* If we'll continue unrolling, we need to propagate constants\n@@ -834,11 +852,14 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \t  struct loop **iter;\n \t  unsigned i;\n \n-\t  if (irred_invalidated\n-\t      && loops_state_satisfies_p (LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS))\n-\t    mark_irreducible_loops ();\n+\t  /* We can not use TODO_update_ssa_no_phi because VOPS gets confused.  */\n \n-\t  update_ssa (TODO_update_ssa);\n+\t  if (loop_closed_ssa_invalidated\n+\t      && !bitmap_empty_p (loop_closed_ssa_invalidated))\n+            rewrite_into_loop_closed_ssa (loop_closed_ssa_invalidated,\n+\t\t\t\t\t  TODO_update_ssa);\n+\t  else\n+\t    update_ssa (TODO_update_ssa);\n \n \t  /* Propagate the constants within the new basic blocks.  */\n \t  FOR_EACH_VEC_ELT (loop_p, father_stack, i, iter)\n@@ -861,12 +882,22 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \t  /* Clean up the information about numbers of iterations, since\n \t     complete unrolling might have invalidated it.  */\n \t  scev_reset ();\n+#ifdef ENABLE_CHECKING\n+\t  if (loops_state_satisfies_p (LOOP_CLOSED_SSA))\n+\t    verify_loop_closed_ssa (true);\n+#endif\n \t}\n+      if (loop_closed_ssa_invalidated)\n+        BITMAP_FREE (loop_closed_ssa_invalidated);\n     }\n   while (changed\n \t && ++iteration <= PARAM_VALUE (PARAM_MAX_UNROLL_ITERATIONS));\n \n   VEC_free (loop_p, stack, father_stack);\n \n+  if (irred_invalidated\n+      && loops_state_satisfies_p (LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS))\n+    mark_irreducible_loops ();\n+\n   return 0;\n }"}]}