{"sha": "d9b3eb63b2f690c056cecde5d6a4c79aaac942c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDliM2ViNjNiMmY2OTBjMDU2Y2VjZGU1ZDZhNGM3OWFhYWM5NDJjOQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2002-02-12T21:55:29Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2002-02-12T21:55:29Z"}, "message": "explow.c (hard_function_value): Add comment explaining signed/unsigned comparison.\n\n2002-02-12  Eric Christopher  <echristo@redhat.com>\n\n\t* explow.c (hard_function_value): Add comment explaining\n\tsigned/unsigned comparison.\n\nFrom-SVN: r49714", "tree": {"sha": "f41f1bf612c600cbf4e4eb7c7e229aa46899fdf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f41f1bf612c600cbf4e4eb7c7e229aa46899fdf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9b3eb63b2f690c056cecde5d6a4c79aaac942c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b3eb63b2f690c056cecde5d6a4c79aaac942c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9b3eb63b2f690c056cecde5d6a4c79aaac942c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b3eb63b2f690c056cecde5d6a4c79aaac942c9/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "56d4428505c7dd85bf6a49dd9b22497331b39341", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56d4428505c7dd85bf6a49dd9b22497331b39341", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56d4428505c7dd85bf6a49dd9b22497331b39341"}], "stats": {"total": 63, "additions": 36, "deletions": 27}, "files": [{"sha": "a52f4a6becca6463a8a022bbed940a566dff9f4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b3eb63b2f690c056cecde5d6a4c79aaac942c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b3eb63b2f690c056cecde5d6a4c79aaac942c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9b3eb63b2f690c056cecde5d6a4c79aaac942c9", "patch": "@@ -1,3 +1,8 @@\n+2002-02-12  Eric Christopher  <echristo@redhat.com>\n+\n+\t* explow.c (hard_function_value): Add comment explaining\n+\tsigned/unsigned comparison.\n+\n 2002-02-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* jump.c (never_reached_warning): Add finish argument.\n@@ -158,7 +163,7 @@ Sat Feb  9 18:28:02 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* config/sh/sh.c (expand_prologue): Fix mis-applied 2001-11-09's\n \tpatch.\n-\t\n+\n \tContribute sh64-elf.\n \t2002-02-09  Alexandre Oliva  <aoliva@redhat.com>\n \t* config/sh/sh.c (TARGET_CANNOT_MODIFY_JUMPS_P): Define to...\n@@ -559,7 +564,7 @@ Sat Feb  9 18:28:02 CET 2002  Jan Hubicka  <jh@suse.cz>\n \t2000-12-26  Alexandre Oliva  <aoliva@redhat.com>\n \t* config/sh/sh.md (movdi_media split): Don't add REG_LABEL notes.\n \tIncrement LABEL_NUSES.\n-\t\n+\n \t* config/sh/sh.h (SIZE_TYPE): Define as conditional on\n \tTARGET_SH5.\n \t(SUBTARGET_CPP_SPEC): Arrange for __SIZE_TYPE__ to be always\n@@ -664,7 +669,7 @@ Sat Feb  9 18:28:02 CET 2002  Jan Hubicka  <jh@suse.cz>\n \t(call_media, call_value_media, sibcall_media): Use\n \ttarget_reg_operand instead of target_operand.\n \t2000-12-13  Alexandre Oliva  <aoliva@redhat.com>\n-\t* glimits.h (__LONG_MAX__) [SH5 == 64]: Adjust for 64 bits. \n+\t* glimits.h (__LONG_MAX__) [SH5 == 64]: Adjust for 64 bits.\n \t* config/sh/sh.c (target_reg_operand): Match hardware registers\n \tother than branch-target registers.\n \t* config/sh/sh.md (zero_extendqidi2): Input operand is %1."}, {"sha": "a72a03be64c709385e2bd87d225fecc56accac57", "filename": "gcc/explow.c", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b3eb63b2f690c056cecde5d6a4c79aaac942c9/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b3eb63b2f690c056cecde5d6a4c79aaac942c9/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=d9b3eb63b2f690c056cecde5d6a4c79aaac942c9", "patch": "@@ -142,7 +142,7 @@ plus_constant_wide (x, c)\n \t Look for constant term in the sum and combine\n \t with C.  For an integer constant term, we make a combined\n \t integer.  For a constant term that is not an explicit integer,\n-\t we cannot really combine, but group them together anyway.  \n+\t we cannot really combine, but group them together anyway.\n \n \t Restart or use a recursive call in case the remaining operand is\n \t something that we handle specially, such as a SYMBOL_REF.\n@@ -391,7 +391,7 @@ convert_memory_address (to_mode, x)\n \n     case CONST:\n       if (POINTERS_EXTEND_UNSIGNED >= 0)\n-        return gen_rtx_CONST (to_mode, \n+        return gen_rtx_CONST (to_mode,\n \t\t\t      convert_memory_address (to_mode, XEXP (x, 0)));\n       break;\n \n@@ -406,11 +406,11 @@ convert_memory_address (to_mode, x)\n \t      || (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT\n \t\t  && (INTVAL (XEXP (x, 1)) + 20000 < 40000\n \t\t      || CONSTANT_P (XEXP (x, 0))))))\n-\treturn gen_rtx_fmt_ee (GET_CODE (x), to_mode, \n+\treturn gen_rtx_fmt_ee (GET_CODE (x), to_mode,\n \t\t\t       convert_memory_address (to_mode, XEXP (x, 0)),\n \t\t\t       convert_memory_address (to_mode, XEXP (x, 1)));\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -670,12 +670,12 @@ copy_to_reg (x)\n      rtx x;\n {\n   rtx temp = gen_reg_rtx (GET_MODE (x));\n- \n+\n   /* If not an operand, must be an address with PLUS and MULT so\n-     do the computation.  */ \n+     do the computation.  */\n   if (! general_operand (x, VOIDmode))\n     x = force_operand (x, temp);\n-  \n+\n   if (x != temp)\n     emit_move_insn (temp, x);\n \n@@ -701,9 +701,9 @@ copy_to_mode_reg (mode, x)\n      rtx x;\n {\n   rtx temp = gen_reg_rtx (mode);\n-  \n+\n   /* If not an operand, must be an address with PLUS and MULT so\n-     do the computation.  */ \n+     do the computation.  */\n   if (! general_operand (x, VOIDmode))\n     x = force_operand (x, temp);\n \n@@ -731,12 +731,12 @@ force_reg (mode, x)\n \n   if (GET_CODE (x) == REG)\n     return x;\n-  \n+\n   temp = gen_reg_rtx (mode);\n-  \n+\n   if (! general_operand (x, mode))\n     x = force_operand (x, NULL_RTX);\n-  \n+\n   insn = emit_move_insn (temp, x);\n \n   /* Let optimizers know that TEMP's value never changes\n@@ -823,7 +823,7 @@ promote_mode (type, mode, punsignedp, for_call)\n       unsignedp = POINTERS_EXTEND_UNSIGNED;\n       break;\n #endif\n-      \n+\n     default:\n       break;\n     }\n@@ -1010,9 +1010,9 @@ emit_stack_save (save_level, psave, after)\n }\n \n /* Restore the stack pointer for the purpose in SAVE_LEVEL.  SA is the save\n-   area made by emit_stack_save.  If it is zero, we have nothing to do. \n+   area made by emit_stack_save.  If it is zero, we have nothing to do.\n \n-   Put any emitted insns after insn AFTER, if nonzero, otherwise at \n+   Put any emitted insns after insn AFTER, if nonzero, otherwise at\n    current position.  */\n \n void\n@@ -1096,7 +1096,7 @@ optimize_save_area_alloca (insns)\n \n \t      /* If we do not see the note in a pattern matching\n \t\t these precise characteristics, we did something\n-\t\t entirely wrong in allocate_dynamic_stack_space. \n+\t\t entirely wrong in allocate_dynamic_stack_space.\n \n \t\t Note, one way this could happen is if SETJMP_VIA_SAVE_AREA\n \t\t was defined on a machine where stacks grow towards higher\n@@ -1187,7 +1187,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n \n   /* We will need to ensure that the address we return is aligned to\n      BIGGEST_ALIGNMENT.  If STACK_DYNAMIC_OFFSET is defined, we don't\n-     always know its final value at this point in the compilation (it \n+     always know its final value at this point in the compilation (it\n      might depend on the size of the outgoing parameter lists, for\n      example), so we must align the value to be returned in that case.\n      (Note that STACK_DYNAMIC_OFFSET will have a default non-zero value if\n@@ -1206,7 +1206,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n \n   if (MUST_ALIGN)\n     size\n-      = force_operand (plus_constant (size, \n+      = force_operand (plus_constant (size,\n \t\t\t\t      BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),\n \t\t       NULL_RTX);\n \n@@ -1339,11 +1339,11 @@ allocate_dynamic_stack_space (size, target, known_align)\n \t  rtx available;\n \t  rtx space_available = gen_label_rtx ();\n #ifdef STACK_GROWS_DOWNWARD\n-\t  available = expand_binop (Pmode, sub_optab, \n+\t  available = expand_binop (Pmode, sub_optab,\n \t\t\t\t    stack_pointer_rtx, stack_limit_rtx,\n \t\t\t\t    NULL_RTX, 1, OPTAB_WIDEN);\n #else\n-\t  available = expand_binop (Pmode, sub_optab, \n+\t  available = expand_binop (Pmode, sub_optab,\n \t\t\t\t    stack_limit_rtx, stack_pointer_rtx,\n \t\t\t\t    NULL_RTX, 1, OPTAB_WIDEN);\n #endif\n@@ -1391,7 +1391,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n \t\t\t    GEN_INT (BIGGEST_ALIGNMENT / BITS_PER_UNIT),\n \t\t\t    NULL_RTX, 1);\n     }\n-  \n+\n   /* Some systems require a particular insn to refer to the stack\n      to make the pages exist.  */\n #ifdef HAVE_probe\n@@ -1406,7 +1406,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n   return target;\n }\n \f\n-/* A front end may want to override GCC's stack checking by providing a \n+/* A front end may want to override GCC's stack checking by providing a\n    run-time routine to call to check the stack, so provide a mechanism for\n    calling that routine.  */\n \n@@ -1436,7 +1436,7 @@ emit_stack_probe (address)\n     emit_move_insn (memref, const0_rtx);\n }\n \n-/* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive. \n+/* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.\n    FIRST is a constant and size is a Pmode RTX.  These are offsets from the\n    current stack pointer.  STACK_GROWS_DOWNWARD says whether to add or\n    subtract from the stack.  If SIZE is constant, this is done\n@@ -1603,6 +1603,10 @@ hard_function_value (valtype, func, outgoing)\n       unsigned HOST_WIDE_INT bytes = int_size_in_bytes (valtype);\n       enum machine_mode tmpmode;\n \n+      /* int_size_in_bytes can return -1.  We don't need a check here\n+\t since the value of bytes will be large enough that no mode\n+\t will match and we will abort later in this function.  */\n+\n       for (tmpmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n            tmpmode != VOIDmode;\n            tmpmode = GET_MODE_WIDER_MODE (tmpmode))\n@@ -1617,7 +1621,7 @@ hard_function_value (valtype, func, outgoing)\n         abort ();\n \n       PUT_MODE (val, tmpmode);\n-    }      \n+    }\n   return val;\n }\n "}]}