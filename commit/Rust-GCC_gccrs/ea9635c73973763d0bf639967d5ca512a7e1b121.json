{"sha": "ea9635c73973763d0bf639967d5ca512a7e1b121", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE5NjM1YzczOTczNzYzZDBiZjYzOTk2N2Q1Y2E1MTJhN2UxYjEyMQ==", "commit": {"author": {"name": "Martin v. L\u00f6wis", "email": "loewis@informatik.hu-berlin.de", "date": "1998-07-12T15:41:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-07-12T15:41:22Z"}, "message": "decl.c (struct binding_level): New field using_directives.\n\n\t* decl.c (struct binding_level): New field using_directives.\n\t(push_using_decl): Not sorry anymore.\n\t(push_using_directive): New function.\n\t(lookup_tag): Use CP_DECL_CONTEXT to iterate.\n\t(unqualified_namespace_lookup): New function, code from ...\n\t(lookup_name_real): ... here.\n\t* decl2.c (lookup_using_namespace): Pass using list instead of\n\tinitial scope.\n\t(validate_nonmember_using_decl): New function.\n\t(do_nonmember_using_decl): New function.\n\t(do_toplevel_using_decl): Use them.\n\t(do_local_using_decl): New function.\n\t(do_using_directive): Support block-level directives.\n\t* parse.y (simple_stmt): Support using declarations and\n\tdirectives.\n\t(namespace_qualifier, namespace_using_decl): New non-terminals.\n\nFrom-SVN: r21089", "tree": {"sha": "351f1538419b4b23fa0eb6398277f535b5a01bd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/351f1538419b4b23fa0eb6398277f535b5a01bd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea9635c73973763d0bf639967d5ca512a7e1b121", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea9635c73973763d0bf639967d5ca512a7e1b121", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea9635c73973763d0bf639967d5ca512a7e1b121", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea9635c73973763d0bf639967d5ca512a7e1b121/comments", "author": null, "committer": null, "parents": [{"sha": "11b5139c461d247d048eb8f00e035e0293d87b13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11b5139c461d247d048eb8f00e035e0293d87b13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11b5139c461d247d048eb8f00e035e0293d87b13"}], "stats": {"total": 332, "additions": 237, "deletions": 95}, "files": [{"sha": "44343f72f3dc5adcc4a35a09fc1ce46d8c05ee2f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9635c73973763d0bf639967d5ca512a7e1b121/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9635c73973763d0bf639967d5ca512a7e1b121/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ea9635c73973763d0bf639967d5ca512a7e1b121", "patch": "@@ -1,5 +1,22 @@\n 1998-07-12  Martin von L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n+\t* decl.c (struct binding_level): New field using_directives.\n+\t(push_using_decl): Not sorry anymore.\n+\t(push_using_directive): New function.\n+\t(lookup_tag): Use CP_DECL_CONTEXT to iterate.\n+\t(unqualified_namespace_lookup): New function, code from ...\n+\t(lookup_name_real): ... here.\n+\t* decl2.c (lookup_using_namespace): Pass using list instead of\n+\tinitial scope.\n+\t(validate_nonmember_using_decl): New function.\n+\t(do_nonmember_using_decl): New function.\n+\t(do_toplevel_using_decl): Use them.\n+\t(do_local_using_decl): New function.\n+\t(do_using_directive): Support block-level directives.\n+\t* parse.y (simple_stmt): Support using declarations and\n+\tdirectives.\n+\t(namespace_qualifier, namespace_using_decl): New non-terminals.\n+\n \t* xref.c (classname): New function.\n \t(GNU_xref_hier): Change class and base parameters to tree.\n \t* decl.c (xref_baseypes): Change caller."}, {"sha": "e4da3a7a0c44854a61443abc2fd6bf56fc50d45c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9635c73973763d0bf639967d5ca512a7e1b121/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9635c73973763d0bf639967d5ca512a7e1b121/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ea9635c73973763d0bf639967d5ca512a7e1b121", "patch": "@@ -2359,7 +2359,9 @@ extern void pushdecl_nonclass_level\t\tPROTO((tree));\n #endif\n extern tree pushdecl_namespace_level            PROTO((tree));\n extern tree push_using_decl                     PROTO((tree, tree));\n+extern tree push_using_directive                PROTO((tree, tree));\n extern void push_class_level_binding\t\tPROTO((tree, tree));\n+extern tree push_using_decl                     PROTO((tree, tree));\n extern tree implicitly_declare\t\t\tPROTO((tree));\n extern tree lookup_label\t\t\tPROTO((tree));\n extern tree shadow_label\t\t\tPROTO((tree));\n@@ -2489,6 +2491,7 @@ extern void push_decl_namespace                 PROTO((tree));\n extern void pop_decl_namespace                  PROTO((void));\n extern void do_namespace_alias\t\t\tPROTO((tree, tree));\n extern void do_toplevel_using_decl\t\tPROTO((tree));\n+extern void do_local_using_decl                 PROTO((tree));\n extern tree do_class_using_decl\t\t\tPROTO((tree));\n extern void do_using_directive\t\t\tPROTO((tree));\n extern void check_default_args\t\t\tPROTO((tree));"}, {"sha": "90f174e7dbfd2d105db9432c7f948e3d4e2d6cee", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 81, "deletions": 35, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9635c73973763d0bf639967d5ca512a7e1b121/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9635c73973763d0bf639967d5ca512a7e1b121/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ea9635c73973763d0bf639967d5ca512a7e1b121", "patch": "@@ -613,6 +613,10 @@ struct binding_level\n     /* A list of USING_DECL nodes. */\n     tree usings;\n \n+    /* A list of used namespaces. PURPOSE is the namespace,\n+       VALUE the common ancestor with this binding_level's namespace. */\n+    tree using_directives;\n+\n     /* For each level, a list of shadowed outer-level local definitions\n        to be restored when this level is popped.\n        Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n@@ -3822,12 +3826,6 @@ push_using_decl (scope, name)\n {\n   tree decl;\n   \n-  if (!toplevel_bindings_p ())\n-    {\n-      sorry (\"using declaration inside function\");\n-      return NULL_TREE;\n-    }\n-\n   my_friendly_assert (TREE_CODE (scope) == NAMESPACE_DECL, 383);\n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 384);\n   for (decl = current_binding_level->usings; decl; decl = TREE_CHAIN (decl))\n@@ -3842,6 +3840,26 @@ push_using_decl (scope, name)\n   return decl;\n }\n \n+/* Add namespace to using_directives. Return NULL_TREE if nothing was\n+   changed (i.e. there was already a directive), or the fresh\n+   TREE_LIST otherwise.  */\n+\n+tree\n+push_using_directive (used, ancestor)\n+     tree used;\n+     tree ancestor;\n+{\n+  tree ud = current_binding_level->using_directives;\n+  \n+  /* Check if we already have this. */\n+  if (purpose_member (used, ud) != NULL_TREE)\n+    return NULL_TREE;\n+ \n+  ud = perm_tree_cons (used, ancestor, ud);\n+  current_binding_level->using_directives = ud;\n+  return ud;\n+}\n+\n /* DECL is a FUNCTION_DECL which may have other definitions already in\n    place.  We get around this by making the value of the identifier point\n    to a list of all the things that want to be referenced by that name.  It\n@@ -4732,6 +4750,62 @@ select_decl (binding, prefer_type, namespaces_only)\n   return val;\n }\n \n+/* Unscoped lookup of a global, iterate over namespaces, considering\n+   using namespace statements. */\n+\n+static tree\n+unqualified_namespace_lookup (name, prefer_type, namespaces_only)\n+     tree name;\n+     int prefer_type;\n+     int namespaces_only;\n+{\n+  struct tree_binding _binding;\n+  tree b = binding_init (&_binding);\n+  tree initial = current_decl_namespace();\n+  tree scope = initial;\n+  tree siter;\n+  struct binding_level *level;\n+  tree val = NULL_TREE;\n+\n+  while (!val)\n+    {\n+      val = binding_for_name (name, scope);\n+\n+      /* Initialize binding for this context. */\n+      BINDING_VALUE (b) = BINDING_VALUE (val);\n+      BINDING_TYPE (b) = BINDING_TYPE (val);\n+\n+      /* Add all _DECLs seen through local using-directives. */\n+      for (level = current_binding_level; \n+\t   !level->namespace_p;\n+\t   level = level->level_chain)\n+\tif (!lookup_using_namespace (name, b, level->using_directives, scope))\n+\t  /* Give up because of error. */\n+\t  return NULL_TREE;\n+\n+      /* Add all _DECLs seen through global using-directives. */\n+      /* XXX local and global using lists should work equally. */\n+      siter = initial;\n+      while (1)\n+\t{\n+\t  if (!lookup_using_namespace (name, b, DECL_NAMESPACE_USING (siter), \n+\t\t\t\t       scope))\n+\t    /* Give up because of error. */\n+\t    return NULL_TREE;\n+\t  if (siter == scope) break;\n+\t  siter = CP_DECL_CONTEXT (siter);\n+\t}\n+\n+      val = select_decl (b, prefer_type, namespaces_only);\n+      if (scope == global_namespace)\n+\tbreak;\n+      scope = DECL_CONTEXT (scope);\n+      if (scope == NULL_TREE)\n+\tscope = global_namespace;\n+    }\n+  return val;\n+}\n+\n /* Look up NAME in the current binding level and its superiors in the\n    namespace of variables, functions and typedefs.  Return a ..._DECL\n    node of some kind representing its definition if there is only one\n@@ -4903,35 +4977,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n   else if (classval)\n     val = classval;\n   else\n-    {\n-      /* Unscoped lookup of a global, iterate over namespaces,\n-         considering using namespace statements. */\n-      struct tree_binding _binding;\n-      tree b = binding_init (&_binding);\n-      tree initial = current_decl_namespace();\n-      tree scope = initial;\n-      val = NULL_TREE;\n-      while (!val)\n-\t{\n-\t  val = binding_for_name (name, scope);\n-\t  /* Initialize binding for this context. */\n-\t  BINDING_VALUE (b) = BINDING_VALUE (val);\n-\t  BINDING_TYPE (b) = BINDING_TYPE (val);\n-\t  /* Add all _DECLs seen through using-directives. */\n-\t  if (!lookup_using_namespace (name, b, initial, scope))\n-\t    {\n-\t      /* Give up because of error. */\n-\t      val = NULL_TREE;\n-\t      break;\n-\t    }\n-\t  val = select_decl (b, prefer_type, namespaces_only);\n-\t  if (scope == global_namespace)\n-\t    break;\n-\t  scope = DECL_CONTEXT (scope);\n-          if (scope == NULL_TREE)\n-            scope = global_namespace;\n-\t}\n-    }\n+    val = unqualified_namespace_lookup (name, prefer_type, namespaces_only);\n \n  done:\n   if (val)"}, {"sha": "5bf96876259ff27f8004f2d1b2540e31757d9723", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 103, "deletions": 59, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9635c73973763d0bf639967d5ca512a7e1b121/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9635c73973763d0bf639967d5ca512a7e1b121/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ea9635c73973763d0bf639967d5ca512a7e1b121", "patch": "@@ -3940,32 +3940,24 @@ ambiguous_decl (name, old, new)\n }\n \n /* Add the bindings of name in used namespaces to val.\n-   The using list is defined by current, and the lookup goes to scope.\n+   The using list is defined by usings, and the lookup goes to scope.\n    Returns zero on errors. */\n \n int\n-lookup_using_namespace (name, val, current, scope)\n-     tree name, val, current, scope;\n+lookup_using_namespace (name, val, usings, scope)\n+     tree name, val, usings, scope;\n {\n   tree iter;\n   tree val1;\n-  /* Iterate over all namespaces from current to scope. */\n-  while (val != error_mark_node)\n-    {\n-      /* Iterate over all used namespaces in current, searching for\n-\t using directives of scope. */\n-      for (iter = DECL_NAMESPACE_USING (current); \n-\t   iter; iter = TREE_CHAIN (iter))\n-\tif (TREE_VALUE (iter) == scope)\n-\t  {\n-\t    val1 = binding_for_name (name, TREE_PURPOSE (iter));\n-\t    /* Resolve ambiguities. */\n-\t    val = ambiguous_decl (name, val, val1);\n-\t  }\n-      if (current == scope)\n-\tbreak;\n-      current = CP_DECL_CONTEXT (current);\n-    }\n+  /* Iterate over all used namespaces in current, searching for using\n+     directives of scope. */\n+  for (iter = usings; iter; iter = TREE_CHAIN (iter))\n+    if (TREE_VALUE (iter) == scope)\n+      {\n+\tval1 = binding_for_name (name, TREE_PURPOSE (iter));\n+\t/* Resolve ambiguities. */\n+\tval = ambiguous_decl (name, val, val1);\n+      }\n   return val != error_mark_node;\n }\n \n@@ -4405,39 +4397,49 @@ do_namespace_alias (alias, namespace)\n     }\n }\n \n-/* Process a using-declaration not appearing in class or local scope. */\n+/* Check a non-member using-declaration. Return the name and scope\n+   being used, and the USING_DECL, or NULL_TREE on failure. */\n \n-void\n-do_toplevel_using_decl (decl)\n+static tree\n+validate_nonmember_using_decl (decl, scope, name)\n      tree decl;\n+     tree *scope;\n+     tree *name;\n {\n-  tree scope, name, binding, decls, newval, newtype;\n-  struct tree_binding _decls;\n-\n   if (TREE_CODE (decl) == SCOPE_REF\n       && TREE_OPERAND (decl, 0) == std_node)\n-    return;\n+    return NULL_TREE;\n   if (TREE_CODE (decl) == SCOPE_REF)\n     {\n-      scope = TREE_OPERAND (decl, 0);\n-      name = TREE_OPERAND (decl, 1);\n+      *scope = TREE_OPERAND (decl, 0);\n+      *name = TREE_OPERAND (decl, 1);\n     }\n   else if (TREE_CODE (decl) == IDENTIFIER_NODE\n            || TREE_CODE (decl) == TYPE_DECL)\n     {\n-      scope = global_namespace;\n-      name = decl;\n+      *scope = global_namespace;\n+      *name = decl;\n     }\n   else\n     my_friendly_abort (382);\n-  if (TREE_CODE_CLASS (TREE_CODE (name)) == 'd')\n-    name = DECL_NAME (name);\n+  if (TREE_CODE_CLASS (TREE_CODE (*name)) == 'd')\n+    *name = DECL_NAME (*name);\n   /* Make a USING_DECL. */\n-  decl = push_using_decl (scope, name);\n-  if (!decl)\n-    return;\n-  \n-  binding = binding_for_name (name, current_namespace);\n+  return push_using_decl (*scope, *name);\n+}\n+\n+/* Process local and global using-declarations. */\n+\n+static void\n+do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n+     tree scope, name;\n+     tree oldval, oldtype;\n+     tree *newval, *newtype;\n+{\n+  tree decls;\n+  struct tree_binding _decls;\n+\n+  *newval = *newtype = NULL_TREE;\n   decls = binding_init (&_decls);\n   if (!qualified_lookup_using_namespace (name, scope, decls))\n     /* Lookup error */\n@@ -4448,14 +4450,12 @@ do_toplevel_using_decl (decl)\n       cp_error (\"`%D' not declared\", name);\n       return;\n     }\n-  newval = newtype = NULL_TREE;\n \n   /* Check for using functions. */\n   if (BINDING_VALUE (decls) && is_overloaded_fn (BINDING_VALUE (decls)))\n     {\n-      tree oldval = BINDING_VALUE (binding);\n       tree tmp, tmp1;\n-      newval = oldval;\n+      *newval = oldval;\n       for (tmp = BINDING_VALUE (decls); tmp; tmp = OVL_NEXT (tmp))\n \t{\n \n@@ -4473,27 +4473,48 @@ do_toplevel_using_decl (decl)\n \t  if (tmp1)\n \t    continue;\n \t    \n-\t  newval = build_overload (OVL_CURRENT (tmp), newval);\n-\t  if (TREE_CODE (newval) != OVERLOAD)\n-\t    newval = ovl_cons (newval, NULL_TREE);\n-\t  OVL_USED (newval) = 1;\n+\t  *newval = build_overload (OVL_CURRENT (tmp), *newval);\n+\t  if (TREE_CODE (*newval) != OVERLOAD)\n+\t    *newval = ovl_cons (*newval, NULL_TREE);\n+\t  OVL_USED (*newval) = 1;\n \t}\n     }\n   else \n     {\n-      tree oldval = BINDING_VALUE (binding);\n-      newval = BINDING_VALUE (decls);\n-      if (oldval && oldval != newval && !duplicate_decls (newval, oldval))\n-\tnewval = oldval;\n+      *newval = BINDING_VALUE (decls);\n+      if (oldval && oldval != *newval && !duplicate_decls (*newval, oldval))\n+\t*newval = oldval;\n     } \n \n-  newtype = BINDING_TYPE (decls);\n-  if (BINDING_TYPE (binding) && newtype && BINDING_TYPE (binding) != newtype)\n+  *newtype = BINDING_TYPE (decls);\n+  if (oldtype && *newtype && oldtype != *newtype)\n     {\n       cp_error (\"using directive `%D' introduced ambiguous type `%T'\",\n-\t\tname, BINDING_TYPE (decls));\n+\t\tname, oldtype);\n       return;\n     }\n+}\n+\n+/* Process a using-declaration not appearing in class or local scope. */\n+\n+void\n+do_toplevel_using_decl (decl)\n+     tree decl;\n+{\n+  tree scope, name, binding;\n+  tree oldval, oldtype, newval, newtype;\n+\n+  decl = validate_nonmember_using_decl (decl, &scope, &name);\n+  if (decl == NULL_TREE)\n+    return;\n+  \n+  binding = binding_for_name (name, current_namespace);\n+\n+  oldval = BINDING_VALUE (binding);\n+  oldtype = BINDING_TYPE (binding);\n+\n+  do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n+\n   /* Copy declarations found. */\n   if (newval)\n     BINDING_VALUE (binding) = newval;\n@@ -4502,6 +4523,29 @@ do_toplevel_using_decl (decl)\n   return;\n }\n \n+void\n+do_local_using_decl (decl)\n+     tree decl;\n+{\n+  tree scope, name;\n+  tree oldval, oldtype, newval, newtype;\n+  decl = validate_nonmember_using_decl (decl, &scope, &name);\n+  if (decl == NULL_TREE)\n+    return;\n+\n+  /* XXX nested values */\n+  oldval = IDENTIFIER_LOCAL_VALUE (name);\n+  /* XXX get local type */\n+  oldtype = NULL_TREE;\n+\n+  do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n+\n+  if (newval)\n+    /* XXX update bindings */\n+    IDENTIFIER_LOCAL_VALUE (name) = newval;\n+  /* XXX type */\n+}\n+\n tree\n do_class_using_decl (decl)\n      tree decl;\n@@ -4534,11 +4578,6 @@ do_using_directive (namespace)\n {\n   if (namespace == std_node)\n     return;\n-  if (!toplevel_bindings_p ())\n-    {\n-      sorry (\"using directives inside functions\");\n-      return;\n-    }\n   /* using namespace A::B::C; */\n   if (TREE_CODE (namespace) == SCOPE_REF)\n       namespace = TREE_OPERAND (namespace, 1);\n@@ -4554,8 +4593,13 @@ do_using_directive (namespace)\n       return;\n     }\n   namespace = ORIGINAL_NAMESPACE (namespace);\n-  /* direct usage */\n-  add_using_namespace (current_namespace, namespace, 0);\n+  if (!toplevel_bindings_p ())\n+    push_using_directive\n+      (namespace, namespace_ancestor (current_decl_namespace(), \n+\t\t\t\t      current_namespace));\n+  else\n+    /* direct usage */\n+    add_using_namespace (current_namespace, namespace, 0);\n }\n \n void"}, {"sha": "0e0d5fdcfa885c531ea19f84596c8dec0867eb99", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9635c73973763d0bf639967d5ca512a7e1b121/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9635c73973763d0bf639967d5ca512a7e1b121/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=ea9635c73973763d0bf639967d5ca512a7e1b121", "patch": "@@ -222,7 +222,8 @@ empty_parms ()\n %type <ttype> template_id do_id object_template_id notype_template_declarator\n %type <ttype> overqualified_id notype_qualified_id any_id\n %type <ttype> complex_direct_notype_declarator functional_cast\n-%type <ttype> complex_parmlist parms_comma\n+%type <ttype> complex_parmlist parms_comma \n+%type <ttype> namespace_qualifier namespace_using_decl\n \n %type <ftype> type_id new_type_id typed_typespecs typespec typed_declspecs\n %type <ftype> typed_declspecs1 type_specifier_seq nonempty_cv_qualifiers\n@@ -438,6 +439,29 @@ using_decl:\n \t\t{ $$ = $3; }\n \t;\n \n+namespace_using_decl:\n+\t  USING namespace_qualifier identifier\n+\t        { $$ = build_parse_node (SCOPE_REF, $2, $3); }\n+\t| USING global_scope identifier\n+\t        { $$ = build_parse_node (SCOPE_REF, global_namespace, $3); }\n+\t| USING global_scope namespace_qualifier identifier\n+\t        { $$ = build_parse_node (SCOPE_REF, $3, $4); }\n+\t;\n+\n+namespace_qualifier:\n+\t  NSNAME SCOPE\n+\t\t{\n+\t\t  if (TREE_CODE ($$) == IDENTIFIER_NODE)\n+\t\t    $$ = lastiddecl;\n+\t\t  got_scope = $$;\n+\t\t}\n+\t| namespace_qualifier NSNAME SCOPE\n+\t\t{\n+\t\t  if (TREE_CODE ($$) == IDENTIFIER_NODE)\n+\t\t    $$ = lastiddecl;\n+\t\t  got_scope = $$;\n+\t\t}\n+\n any_id:\n \t  unqualified_id\n \t| qualified_id\n@@ -3244,6 +3268,14 @@ simple_stmt:\n \t| ';'\n \t\t{ finish_stmt (); }\n \t| try_block\n+\t| USING NAMESPACE any_id ';'\n+\t\t{ \n+\t\t  if (TREE_CODE ($3) == IDENTIFIER_NODE && lastiddecl)\n+\t\t    $3 = lastiddecl;\n+\t\t  do_using_directive ($3); \n+\t\t}\n+\t| namespace_using_decl\n+\t        { do_local_using_decl ($1); }\n \t;\n \n function_try_block:"}]}