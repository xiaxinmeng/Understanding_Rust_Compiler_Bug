{"sha": "157f3283d6dbdf376bf7a2a2247b644e06551d22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU3ZjMyODNkNmRiZGYzNzZiZjdhMmEyMjQ3YjY0NGUwNjU1MWQyMg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2003-10-28T17:09:03Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-10-28T17:09:03Z"}, "message": "2003-10-28  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.tcc\n\t(money_get<>::do_get(..., string_type&)): Absolutely avoid\n\tdereferencing end iterators; general clean up.\n\nFrom-SVN: r73011", "tree": {"sha": "bf1876f30c3900284a6632b18376b1b4ad3b0166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf1876f30c3900284a6632b18376b1b4ad3b0166"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/157f3283d6dbdf376bf7a2a2247b644e06551d22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157f3283d6dbdf376bf7a2a2247b644e06551d22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/157f3283d6dbdf376bf7a2a2247b644e06551d22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157f3283d6dbdf376bf7a2a2247b644e06551d22/comments", "author": null, "committer": null, "parents": [{"sha": "4e81efd45482da6bdc02076aadce03ca7324521f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e81efd45482da6bdc02076aadce03ca7324521f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e81efd45482da6bdc02076aadce03ca7324521f"}], "stats": {"total": 194, "additions": 95, "deletions": 99}, "files": [{"sha": "40378505d9c837ce0e8ca1d6d87bb3a249c238e4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157f3283d6dbdf376bf7a2a2247b644e06551d22/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157f3283d6dbdf376bf7a2a2247b644e06551d22/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=157f3283d6dbdf376bf7a2a2247b644e06551d22", "patch": "@@ -1,3 +1,9 @@\n+2003-10-28  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.tcc\n+\t(money_get<>::do_get(..., string_type&)): Absolutely avoid\n+\tdereferencing end iterators; general clean up.\n+\n 2003-10-28  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/locale_facets.tcc (time_get::_M_extract_num):"}, {"sha": "6af77a95d94b2a3bf2355f96d7d3f5cfe21ce7f5", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 89, "deletions": 99, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157f3283d6dbdf376bf7a2a2247b644e06551d22/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157f3283d6dbdf376bf7a2a2247b644e06551d22/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=157f3283d6dbdf376bf7a2a2247b644e06551d22", "patch": "@@ -1144,10 +1144,10 @@ namespace std\n       const money_base::pattern __p = __intl ? __mpt.neg_format() \n \t\t\t\t\t     : __mpf.neg_format();\n \n-      const string_type __pos_sign =__intl ? __mpt.positive_sign() \n-\t\t\t\t\t   : __mpf.positive_sign();\n-      const string_type __neg_sign =__intl ? __mpt.negative_sign() \n-\t\t\t\t\t   : __mpf.negative_sign();\n+      const string_type __pos_sign = __intl ? __mpt.positive_sign() \n+\t\t\t\t\t    : __mpf.positive_sign();\n+      const string_type __neg_sign = __intl ? __mpt.negative_sign() \n+\t\t\t\t\t    : __mpf.negative_sign();\n       const char_type __d = __intl ? __mpt.decimal_point() \n   \t    \t       \t\t   : __mpf.decimal_point();\n       const char_type __sep = __intl ? __mpt.thousands_sep() \n@@ -1169,113 +1169,103 @@ namespace std\n       // The tentative returned string is stored here.\n       string_type __tmp_units;\n \n-      char_type __c = *__beg;\n       for (int __i = 0; __beg != __end && __i < 4 && __testvalid; ++__i)\n \t{\n+\t  char_type __c;\n \t  const part __which = static_cast<part>(__p.field[__i]);\n \t  switch (__which)\n+\t    {\n+\t    case money_base::symbol:\n+\t      if (__io.flags() & ios_base::showbase \n+\t\t  || __i < 2 || __sign.size() > 1\n+\t\t  || ((static_cast<part>(__p.field[3]) != money_base::none)\n+\t\t      && __i == 2)) \n \t\t{\n-\t\tcase money_base::symbol:\n-\t\t  if (__io.flags() & ios_base::showbase \n-\t\t      || __i < 2 || __sign.size() > 1\n-\t\t      || ((static_cast<part>(__p.field[3]) != money_base::none)\n-\t\t\t  && __i == 2)) \n-\t\t    {\n-\t\t      // According to 22.2.6.1.2.2, symbol is required\n-\t\t      // if (__io.flags() & ios_base::showbase),\n-\t\t      // otherwise is optional and consumed only if\n-\t\t      // other characters are needed to complete the\n-\t\t      // format.\n-\t\t      const string_type __symbol = __intl ? __mpt.curr_symbol()\n-\t\t\t                                  : __mpf.curr_symbol();\n-\t\t      const size_type __len = __symbol.size();\n-\t\t      size_type __j = 0;\n-\t\t      while (__beg != __end \n-\t\t\t     && __j < __len && __symbol[__j] == __c)\n-\t\t\t{\n-\t\t\t  __c = *(++__beg);\n-\t\t\t  ++__j;\n-\t\t\t}\n-\t\t      // When (__io.flags() & ios_base::showbase)\n-\t\t      // symbol is required.\n-\t\t      if (__j != __len && (__io.flags() & ios_base::showbase))\n+\t\t  // According to 22.2.6.1.2.2, symbol is required\n+\t\t  // if (__io.flags() & ios_base::showbase),\n+\t\t  // otherwise is optional and consumed only if\n+\t\t  // other characters are needed to complete the\n+\t\t  // format.\n+\t\t  const string_type __symbol = __intl ? __mpt.curr_symbol()\n+\t\t                                      : __mpf.curr_symbol();\n+\t\t  const size_type __len = __symbol.size();\n+\t\t  size_type __j = 0;\n+\t\t  for (; __beg != __end && __j < __len\n+\t\t\t && *__beg == __symbol[__j]; ++__beg, ++__j);\n+\t\t  // When (__io.flags() & ios_base::showbase)\n+\t\t  // symbol is required.\n+\t\t  if (__j != __len && (__io.flags() & ios_base::showbase))\n+\t\t    __testvalid = false;\n+\t\t}\n+\t      break;\n+\t    case money_base::sign:\t\t    \n+\t      // Sign might not exist, or be more than one character long.\n+\t      if (__pos_sign.size() && *__beg == __pos_sign[0])\n+\t\t{\n+\t\t  __sign = __pos_sign;\n+\t\t  ++__beg;\n+\t\t}\n+\t      else if (__neg_sign.size() && *__beg == __neg_sign[0])\n+\t\t{\n+\t\t  __sign = __neg_sign;\n+\t\t  ++__beg;\n+\t\t}\n+\t      else if (__pos_sign.size() && __neg_sign.size())\n+\t\t{\n+\t\t  // Sign is mandatory.\n+\t\t  __testvalid = false;\n+\t\t}\n+\t      break;\n+\t    case money_base::value:\n+\t      // Extract digits, remove and stash away the\n+\t      // grouping of found thousands separators.\n+\t      for (; __beg != __end; ++__beg)\n+\t\tif (__ctype.is(ctype_base::digit, __c = *__beg))\n+\t\t  {\n+\t\t    __tmp_units += __c;\n+\t\t    ++__sep_pos;\n+\t\t  }\n+\t\telse if (__c == __d && !__testdecfound)\n+\t\t  {\n+\t\t    __grouping_tmp += static_cast<char>(__sep_pos);\n+\t\t    __sep_pos = 0;\n+\t\t    __testdecfound = true;\n+\t\t  }\n+\t\telse if (__c == __sep)\n+\t\t  {\n+\t\t    if (__grouping.size())\n+\t\t      {\n+\t\t\t// Mark position for later analysis.\n+\t\t\t__grouping_tmp += static_cast<char>(__sep_pos);\n+\t\t\t__sep_pos = 0;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n \t\t\t__testvalid = false;\n-\t\t    }\n-\t\t  break;\n-\t\tcase money_base::sign:\t\t    \n-\t\t  // Sign might not exist, or be more than one character long.\n-\t\t  if (__pos_sign.size() && __c == __pos_sign[0])\n-\t\t    {\n-\t\t      __sign = __pos_sign;\n-\t\t      __c = *(++__beg);\n-\t\t    }\n-\t\t  else if (__neg_sign.size() && __c == __neg_sign[0])\n-\t\t    {\n-\t\t      __sign = __neg_sign;\n-\t\t      __c = *(++__beg);\n-\t\t    }\n-\t\t  else if (__pos_sign.size() && __neg_sign.size())\n-\t\t    {\n-\t\t      // Sign is mandatory.\n-\t\t      __testvalid = false;\n-\t\t    }\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t\telse\n \t\t  break;\n-\t\tcase money_base::value:\n-\t\t  // Extract digits, remove and stash away the\n-\t\t  // grouping of found thousands separators.\n-\t\t  while (__beg != __end \n-\t\t\t && (__ctype.is(ctype_base::digit, __c) \n-\t\t\t     || (__c == __d && !__testdecfound)\n-\t\t\t     || __c == __sep))\n-\t\t    {\n-\t\t      if (__c == __d)\n-\t\t\t{\n-\t\t\t  __grouping_tmp += static_cast<char>(__sep_pos);\n-\t\t\t  __sep_pos = 0;\n-\t\t\t  __testdecfound = true;\n-\t\t\t}\n-\t\t      else if (__c == __sep)\n-\t\t\t{\n-\t\t\t  if (__grouping.size())\n-\t\t\t    {\n-\t\t\t      // Mark position for later analysis.\n-\t\t\t      __grouping_tmp += static_cast<char>(__sep_pos);\n-\t\t\t      __sep_pos = 0;\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      __testvalid = false;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  __tmp_units += __c;\n-\t\t\t  ++__sep_pos;\n-\t\t\t}\n-\t\t      __c = *(++__beg);\n-\t\t    }\n-\t\t  break;\n-\t\tcase money_base::space:\n-\t\tcase money_base::none:\n-\t\t  // Only if not at the end of the pattern.\n-\t\t  if (__i != 3)\n-\t\t    while (__beg != __end \n-\t\t\t   && __ctype.is(ctype_base::space, __c))\n-\t\t      __c = *(++__beg);\n-\t\t  break;\n-\t\t}\n+\t      break;\n+\t    case money_base::space:\n+\t    case money_base::none:\n+\t      // Only if not at the end of the pattern.\n+\t      if (__i != 3)\n+\t\tfor (; __beg != __end \n+\t\t       && __ctype.is(ctype_base::space, *__beg); ++__beg);\n+\t      break;\n+\t    }\n \t}\n-\n+      \n       // Need to get the rest of the sign characters, if they exist.\n-      const char_type __eof = static_cast<char_type>(char_traits<char_type>::eof());\n       if (__sign.size() > 1)\n \t{\n \t  const size_type __len = __sign.size();\n \t  size_type __i = 1;\n-\t  for (; __c != __eof && __i < __len; ++__i)\n-\t    while (__beg != __end && __c != __sign[__i])\n-\t      __c = *(++__beg);\n+\t  for (; __beg != __end && __i < __len; ++__i)\n+\t    for (; __beg != __end\n+\t\t   && *__beg != __sign[__i]; ++__beg);\n \t  \n \t  if (__i != __len)\n \t    __testvalid = false;\n@@ -1320,7 +1310,7 @@ namespace std\n \t__testvalid = false;\n \n       // Iff no more characters are available.      \n-      if (__c == __eof)\n+      if (__beg == __end)\n \t__err |= ios_base::eofbit;\n \n       // Iff valid sequence is not recognized."}]}