{"sha": "9d2299893619255d734fdbc5d147de8eb73dc939", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQyMjk5ODkzNjE5MjU1ZDczNGZkYmM1ZDE0N2RlOGViNzNkYzkzOQ==", "commit": {"author": {"name": "Jim Blandy", "email": "jimb@zwingli.cygnus.com", "date": "1999-04-09T09:01:35Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-09T09:01:35Z"}, "message": "cplus-dem.c: Attempt to handle overflows in counts with some semblance of grace.\n\n1999-04-01  Jim Blandy  <jimb@zwingli.cygnus.com>\n\t* cplus-dem.c: Attempt to handle overflows in counts with some\n\tsemblance of grace.\n\t(consume_count): Detect overflows.  Return -1 to indicate errors,\n\tinstead of zero.\n\t(demangle_template_value_parm, demangle_template): Handle change\n\tto consume_count's return convention.\n\nFrom-SVN: r26309", "tree": {"sha": "4b8a0767d248819901614cbac14922d937b3a33c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b8a0767d248819901614cbac14922d937b3a33c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d2299893619255d734fdbc5d147de8eb73dc939", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d2299893619255d734fdbc5d147de8eb73dc939", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d2299893619255d734fdbc5d147de8eb73dc939", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d2299893619255d734fdbc5d147de8eb73dc939/comments", "author": null, "committer": null, "parents": [{"sha": "d330fd93a91eb39b8a88812980dd9e3a112d1529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d330fd93a91eb39b8a88812980dd9e3a112d1529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d330fd93a91eb39b8a88812980dd9e3a112d1529"}], "stats": {"total": 167, "additions": 125, "deletions": 42}, "files": [{"sha": "2bba3ebad404a49a46821e3f10217fb94477c63f", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2299893619255d734fdbc5d147de8eb73dc939/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2299893619255d734fdbc5d147de8eb73dc939/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=9d2299893619255d734fdbc5d147de8eb73dc939", "patch": "@@ -1,3 +1,12 @@\n+1999-04-01  Jim Blandy  <jimb@zwingli.cygnus.com>\n+\n+\t* cplus-dem.c: Attempt to handle overflows in counts with some\n+\tsemblance of grace.\n+\t(consume_count): Detect overflows.  Return -1 to indicate errors,\n+\tinstead of zero.\n+\t(demangle_template_value_parm, demangle_template): Handle change\n+\tto consume_count's return convention.\n+\n 1999-04-05  Tom Tromey  <tromey@cygnus.com>\n \n \t* testsuite/regress-demangle: New file."}, {"sha": "2e509d891572d525fa41391ac6014db8578f8cfe", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 116, "deletions": 42, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2299893619255d734fdbc5d147de8eb73dc939/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2299893619255d734fdbc5d147de8eb73dc939/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=9d2299893619255d734fdbc5d147de8eb73dc939", "patch": "@@ -420,33 +420,43 @@ qualifier_string PARAMS ((int));\n static const char*\n demangle_qualifier PARAMS ((int));\n \n-/*  Translate count to integer, consuming tokens in the process.\n-    Conversion terminates on the first non-digit character.\n-    Trying to consume something that isn't a count results in\n-    no consumption of input and a return of 0.  */\n+/* Translate count to integer, consuming tokens in the process.\n+   Conversion terminates on the first non-digit character.\n+\n+   Trying to consume something that isn't a count results in no\n+   consumption of input and a return of -1.\n+\n+   Overflow consumes the rest of the digits, and returns -1.  */\n \n static int\n consume_count (type)\n      const char **type;\n {\n-  unsigned int count = 0;\n-  char *save = *type;\n+  int count = 0;\n+\n+  if (! isdigit ((unsigned char)**type))\n+    return -1;\n \n   while (isdigit ((unsigned char)**type))\n     {\n       count *= 10;\n-      count += **type - '0';\n-      /* A sanity check.  Otherwise a symbol like\n-\t `_Utf390_1__1_9223372036854775807__9223372036854775'\n-\t can cause this function to return a negative value.\n-\t In this case we just consume until the end of the string.  */\n-      if (count > strlen (*type))\n+\n+      /* Check for overflow.\n+\t We assume that count is represented using two's-complement;\n+\t no power of two is divisible by ten, so if an overflow occurs\n+\t when multiplying by ten, the result will not be a multiple of\n+\t ten.  */\n+      if ((count % 10) != 0)\n \t{\n-\t  *type = save;\n-\t  return 0;\n+\t  while (isdigit ((unsigned char) **type))\n+\t    (*type)++;\n+\t  return -1;\n \t}\n+\n+      count += **type - '0';\n       (*type)++;\n     }\n+\n   return (count);\n }\n \n@@ -1440,12 +1450,15 @@ demangle_template_value_parm (work, mangled, s, tk)\n \t}\n       string_appendn (s, \"'\", 1);\n       val = consume_count(mangled);\n-      if (val == 0)\n-\treturn -1;\n-      tmp[0] = (char)val;\n-      tmp[1] = '\\0';\n-      string_appendn (s, &tmp[0], 1);\n-      string_appendn (s, \"'\", 1);\n+      if (val <= 0)\n+\tsuccess = 0;\n+      else\n+\t{\n+\t  tmp[0] = (char)val;\n+\t  tmp[1] = '\\0';\n+\t  string_appendn (s, &tmp[0], 1);\n+\t  string_appendn (s, \"'\", 1);\n+\t}\n     }\n   else if (tk == tk_bool)\n     {\n@@ -1493,7 +1506,7 @@ demangle_template_value_parm (work, mangled, s, tk)\n   else if (tk == tk_pointer || tk == tk_reference)\n     {\n       int symbol_len = consume_count (mangled);\n-      if (symbol_len == 0)\n+      if (symbol_len == -1)\n \treturn -1;\n       if (symbol_len == 0)\n \tstring_appendn (s, \"0\", 1);\n@@ -1589,7 +1602,7 @@ demangle_template (work, mangled, tname, trawname, is_type, remember)\n \t}\n       else\n \t{\n-\t  if ((r = consume_count (mangled)) == 0\n+\t  if ((r = consume_count (mangled)) <= 0\n \t      || (int) strlen (*mangled) < r)\n \t    {\n \t      return (0);\n@@ -1768,6 +1781,8 @@ arm_pt (work, mangled, n, anchor, args)\n       int len;\n       *args = *anchor + 6;\n       len = consume_count (args);\n+      if (len == -1)\n+\treturn 0;\n       if (*args + len == mangled + n && **args == '_')\n \t{\n \t  ++*args;\n@@ -1783,6 +1798,8 @@ arm_pt (work, mangled, n, anchor, args)\n           int len;\n           *args = *anchor + 6;\n           len = consume_count (args);\n+\t  if (len == -1)\n+\t    return 0;\n           if (*args + len == mangled + n && **args == '_')\n             {\n               ++*args;\n@@ -1794,6 +1811,8 @@ arm_pt (work, mangled, n, anchor, args)\n  \t  int len;\n  \t  *args = *anchor + 3;\n  \t  len = consume_count (args);\n+\t  if (len == -1)\n+\t    return 0;\n  \t  if (*args + len == mangled + n && **args == '_')\n             {\n               ++*args;\n@@ -1969,7 +1988,9 @@ demangle_class_name (work, mangled, declp)\n   int success = 0;\n \n   n = consume_count (mangled);\n-  if (n > 0)\n+  if (n == -1)\n+    return 0;\n+  if ((int) strlen (*mangled) >= n)\n     {\n       demangle_arm_hp_template (work, mangled, n, declp);\n       success = 1;\n@@ -2417,6 +2438,11 @@ gnu_special (work, mangled, declp)\n \t  break;\n \tdefault:\n \t  n = consume_count (mangled);\n+\t  if (n < 0 || n > strlen (*mangled))\n+\t    {\n+\t      success = 0;\n+\t      break;\n+\t    }\n \t  string_appendn (declp, *mangled, n);\n \t  (*mangled) += n;\n \t}\n@@ -2437,21 +2463,30 @@ gnu_special (work, mangled, declp)\n     }\n   else if (strncmp (*mangled, \"__thunk_\", 8) == 0)\n     {\n-      int delta = ((*mangled) += 8, consume_count (mangled));\n-      char *method = internal_cplus_demangle (work, ++*mangled);\n-      if (method)\n-\t{\n-\t  char buf[50];\n-\t  sprintf (buf, \"virtual function thunk (delta:%d) for \", -delta);\n-\t  string_append (declp, buf);\n-\t  string_append (declp, method);\n-\t  free (method);\n-\t  n = strlen (*mangled);\n-\t  (*mangled) += n;\n-\t}\n+      int delta;\n+\n+      (*mangled) += 8;\n+      delta = consume_count (mangled);\n+      if (delta == -1)\n+\tsuccess = 0;\n       else\n \t{\n-\t  success = 0;\n+\t  char *method = internal_cplus_demangle (work, ++*mangled);\n+\n+\t  if (method)\n+\t    {\n+\t      char buf[50];\n+\t      sprintf (buf, \"virtual function thunk (delta:%d) for \", -delta);\n+\t      string_append (declp, buf);\n+\t      string_append (declp, method);\n+\t      free (method);\n+\t      n = strlen (*mangled);\n+\t      (*mangled) += n;\n+\t    }\n+\t  else\n+\t    {\n+\t      success = 0;\n+\t    }\n \t}\n     }\n   else if (strncmp (*mangled, \"__t\", 3) == 0\n@@ -2555,7 +2590,7 @@ arm_special (mangled, declp)\n       while (*scan != '\\0')        /* first check it can be demangled */\n         {\n           n = consume_count (&scan);\n-          if (n==0)\n+          if (n == -1)\n \t    {\n \t      return (0);           /* no good */\n \t    }\n@@ -2569,6 +2604,9 @@ arm_special (mangled, declp)\n       while (**mangled != '\\0')\n \t{\n \t  n = consume_count (mangled);\n+          if (n == -1\n+\t      || n > strlen (*mangled))\n+\t    return 0;\n \t  string_prependn (declp, *mangled, n);\n \t  (*mangled) += n;\n \t  if ((*mangled)[0] == '_' && (*mangled)[1] == '_')\n@@ -2753,6 +2791,11 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n  \t       * This is necessary to deal with templates in\n  \t       * mangling styles like EDG */\n \t      namelength = consume_count (mangled);\n+\t      if (namelength == -1)\n+\t\t{\n+\t\t  success = 0;\n+\t\t  break;\n+\t\t}\n  \t      recursively_demangle(work, mangled, &temp, namelength);\n             }\n           else\n@@ -2816,7 +2859,37 @@ SYNOPSIS\n \n DESCRIPTION\n \n-\tReturn 0 if no conversion is performed, 1 if a string is converted.\n+\tAssume that *type points at a count in a mangled name; set\n+\t*count to its value, and set *type to the next character after\n+\tthe count.  There are some weird rules in effect here.\n+\n+\tIf *type does not point at a string of digits, return zero.\n+\n+\tIf *type points at a string of digits followed by an\n+\tunderscore, set *count to their value as an integer, advance\n+\t*type to point *after the underscore, and return 1.\n+\n+\tIf *type points at a string of digits not followed by an\n+\tunderscore, consume only the first digit.  Set *count to its\n+\tvalue as an integer, leave *type pointing after that digit,\n+\tand return 1.\n+\n+        The excuse for this odd behavior: in the ARM and HP demangling\n+        styles, a type can be followed by a repeat count of the form\n+        `Nxy', where:\n+\n+        `x' is a single digit specifying how many additional copies\n+            of the type to append to the argument list, and\n+\n+        `y' is one or more digits, specifying the zero-based index of\n+            the first repeated argument in the list.  Yes, as you're\n+            unmangling the name you can figure this out yourself, but\n+            it's there anyway.\n+\n+        So, for example, in `bar__3fooFPiN51', the first argument is a\n+        pointer to an integer (`Pi'), and then the next five arguments\n+        are the same (`N5'), and the first repeat is the function's\n+        second argument (`1').\n */\n \n static int\n@@ -2978,7 +3051,8 @@ do_type (work, mangled, result)\n \t    if (isdigit ((unsigned char)**mangled))\n \t      {\n \t\tn = consume_count (mangled);\n-\t\tif ((int) strlen (*mangled) < n)\n+\t\tif (n == -1\n+\t\t    || (int) strlen (*mangled) < n)\n \t\t  {\n \t\t    success = 0;\n \t\t    break;\n@@ -3423,7 +3497,7 @@ do_hpacc_template_literal (work, mangled, result)\n \n   literal_len = consume_count (mangled);\n \n-  if (!literal_len)\n+  if (literal_len <= 0)\n     return 0;\n \n   /* Literal parameters are names of arrays, functions, etc.  and the\n@@ -3513,7 +3587,7 @@ do_arg (work, mangled, result)\n       (*mangled)++;\n       work->nrepeats = consume_count(mangled);\n \n-      if (work->nrepeats == 0)\n+      if (work->nrepeats <= 0)\n \t/* This was not a repeat count after all.  */\n \treturn 0;\n \n@@ -3800,7 +3874,7 @@ demangle_args (work, mangled, declp)\n                  count but it's impossible to demangle that case properly\n                  anyway. Eg if we already have 12 types is T12Pc \"(..., type1,\n                  Pc, ...)\"  or \"(..., type12, char *, ...)\" */\n-              if ((t = consume_count(mangled)) == 0)\n+              if ((t = consume_count(mangled)) <= 0)\n                 {\n                   return (0);\n                 }"}]}