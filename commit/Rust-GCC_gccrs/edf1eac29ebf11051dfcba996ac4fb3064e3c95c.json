{"sha": "edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRmMWVhYzI5ZWJmMTEwNTFkZmNiYTk5NmFjNGZiMzA2NGUzYzk1Yw==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-01-20T22:01:41Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-01-20T22:01:41Z"}, "message": "openmp.c, [...]: Next installment in the massive whitespace patch.\n\n    * openmp.c, matchexp.c, module.c, scanner.c, resolve.c, st.c,\n    parse.c, primary.c, options.c, misc.c, simplify.c:  Next installment\n    in the massive whitespace patch.\n\nFrom-SVN: r121012", "tree": {"sha": "a5e1dd4c7002a6118aa4d0e313e2d22c3b3aa8ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5e1dd4c7002a6118aa4d0e313e2d22c3b3aa8ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/comments", "author": null, "committer": null, "parents": [{"sha": "70fadd09be30c98ab6fccf3a97eede5f5c253c1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70fadd09be30c98ab6fccf3a97eede5f5c253c1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70fadd09be30c98ab6fccf3a97eede5f5c253c1e"}], "stats": {"total": 3337, "additions": 1623, "deletions": 1714}, "files": [{"sha": "42092481910ddb6bbf154e410b5c68636e500c67", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "patch": "@@ -1,3 +1,9 @@\n+2007-01-20  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* openmp.c, matchexp.c, module.c, scanner.c, resolve.c, st.c,\n+\tparse.c, primary.c, options.c, misc.c, simplify.c:  Next installment\n+\tin the massive whitespace patch.\n+\n 2007-01-20  Roger Sayle  <roger@eyesopen.com>\n \n \t* module.c (mio_array_ref): The dimen_type fields of an array ref"}, {"sha": "6e1a5a4a8d55b5ceb5c421f0041ed94541bb370a", "filename": "gcc/fortran/matchexp.c", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "patch": "@@ -1,6 +1,6 @@\n /* Expression parser.\n-   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -20,7 +20,6 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"gfortran.h\"\n@@ -91,7 +90,7 @@ gfc_match_defined_op_name (char *result, int error_flag)\n    operator already.  */\n \n static match\n-match_defined_operator (gfc_user_op ** result)\n+match_defined_operator (gfc_user_op **result)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   match m;\n@@ -126,6 +125,7 @@ next_operator (gfc_intrinsic_op t)\n /* Call the INTRINSIC_PARENTHESES function.  This is both\n    used explicitly, as below, or by resolve.c to generate\n    temporaries.  */\n+\n gfc_expr *\n gfc_get_parentheses (gfc_expr *e)\n {\n@@ -146,7 +146,7 @@ gfc_get_parentheses (gfc_expr *e)\n /* Match a primary expression.  */\n \n static match\n-match_primary (gfc_expr ** result)\n+match_primary (gfc_expr **result)\n {\n   match m;\n   gfc_expr *e;\n@@ -206,8 +206,8 @@ match_primary (gfc_expr ** result)\n /* Build an operator expression node.  */\n \n static gfc_expr *\n-build_node (gfc_intrinsic_op operator, locus * where,\n-\t    gfc_expr * op1, gfc_expr * op2)\n+build_node (gfc_intrinsic_op operator, locus *where,\n+\t    gfc_expr *op1, gfc_expr *op2)\n {\n   gfc_expr *new;\n \n@@ -226,7 +226,7 @@ build_node (gfc_intrinsic_op operator, locus * where,\n /* Match a level 1 expression.  */\n \n static match\n-match_level_1 (gfc_expr ** result)\n+match_level_1 (gfc_expr **result)\n {\n   gfc_user_op *uop;\n   gfc_expr *e, *f;\n@@ -272,14 +272,12 @@ match_level_1 (gfc_expr ** result)\n \t\t\t       or add-operand\n  */\n \n-static match match_ext_mult_operand (gfc_expr ** result);\n-static match match_ext_add_operand (gfc_expr ** result);\n-\n+static match match_ext_mult_operand (gfc_expr **result);\n+static match match_ext_add_operand (gfc_expr **result);\n \n static int\n match_add_op (void)\n {\n-\n   if (next_operator (INTRINSIC_MINUS))\n     return -1;\n   if (next_operator (INTRINSIC_PLUS))\n@@ -289,7 +287,7 @@ match_add_op (void)\n \n \n static match\n-match_mult_operand (gfc_expr ** result)\n+match_mult_operand (gfc_expr **result)\n {\n   gfc_expr *e, *exp, *r;\n   locus where;\n@@ -332,7 +330,7 @@ match_mult_operand (gfc_expr ** result)\n \n \n static match\n-match_ext_mult_operand (gfc_expr ** result)\n+match_ext_mult_operand (gfc_expr **result)\n {\n   gfc_expr *all, *e;\n   locus where;\n@@ -345,8 +343,8 @@ match_ext_mult_operand (gfc_expr ** result)\n   if (i == 0)\n     return match_mult_operand (result);\n \n-  if (gfc_notify_std (GFC_STD_GNU, \"Extension: Unary operator following\"\n-\t\t      \" arithmetic operator (use parentheses) at %C\")\n+  if (gfc_notify_std (GFC_STD_GNU, \"Extension: Unary operator following \"\n+\t\t      \"arithmetic operator (use parentheses) at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -372,7 +370,7 @@ match_ext_mult_operand (gfc_expr ** result)\n \n \n static match\n-match_add_operand (gfc_expr ** result)\n+match_add_operand (gfc_expr **result)\n {\n   gfc_expr *all, *e, *total;\n   locus where, old_loc;\n@@ -436,7 +434,7 @@ match_add_operand (gfc_expr ** result)\n \n \n static match\n-match_ext_add_operand (gfc_expr ** result)\n+match_ext_add_operand (gfc_expr **result)\n {\n   gfc_expr *all, *e;\n   locus where;\n@@ -449,8 +447,8 @@ match_ext_add_operand (gfc_expr ** result)\n   if (i == 0)\n     return match_add_operand (result);\n \n-  if (gfc_notify_std (GFC_STD_GNU, \"Extension: Unary operator following\"\n-\t\t      \" arithmetic operator (use parentheses) at %C\")\n+  if (gfc_notify_std (GFC_STD_GNU, \"Extension: Unary operator following \"\n+\t\t      \"arithmetic operator (use parentheses) at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -478,7 +476,7 @@ match_ext_add_operand (gfc_expr ** result)\n /* Match a level 2 expression.  */\n \n static match\n-match_level_2 (gfc_expr ** result)\n+match_level_2 (gfc_expr **result)\n {\n   gfc_expr *all, *e, *total;\n   locus where;\n@@ -521,7 +519,7 @@ match_level_2 (gfc_expr ** result)\n \n   all->where = where;\n \n-/* Append add-operands to the sum */\n+  /* Append add-operands to the sum.  */\n \n   for (;;)\n     {\n@@ -563,7 +561,7 @@ match_level_2 (gfc_expr ** result)\n /* Match a level three expression.  */\n \n static match\n-match_level_3 (gfc_expr ** result)\n+match_level_3 (gfc_expr **result)\n {\n   gfc_expr *all, *e, *total;\n   locus where;\n@@ -609,7 +607,7 @@ match_level_3 (gfc_expr ** result)\n /* Match a level 4 expression.  */\n \n static match\n-match_level_4 (gfc_expr ** result)\n+match_level_4 (gfc_expr **result)\n {\n   gfc_expr *left, *right, *r;\n   gfc_intrinsic_op i;\n@@ -693,7 +691,7 @@ match_level_4 (gfc_expr ** result)\n \n \n static match\n-match_and_operand (gfc_expr ** result)\n+match_and_operand (gfc_expr **result)\n {\n   gfc_expr *e, *r;\n   locus where;\n@@ -726,7 +724,7 @@ match_and_operand (gfc_expr ** result)\n \n \n static match\n-match_or_operand (gfc_expr ** result)\n+match_or_operand (gfc_expr **result)\n {\n   gfc_expr *all, *e, *total;\n   locus where;\n@@ -769,7 +767,7 @@ match_or_operand (gfc_expr ** result)\n \n \n static match\n-match_equiv_operand (gfc_expr ** result)\n+match_equiv_operand (gfc_expr **result)\n {\n   gfc_expr *all, *e, *total;\n   locus where;\n@@ -814,7 +812,7 @@ match_equiv_operand (gfc_expr ** result)\n /* Match a level 5 expression.  */\n \n static match\n-match_level_5 (gfc_expr ** result)\n+match_level_5 (gfc_expr **result)\n {\n   gfc_expr *all, *e, *total;\n   locus where;\n@@ -873,7 +871,7 @@ match_level_5 (gfc_expr ** result)\n    level 5 expressions separated by binary operators.  */\n \n match\n-gfc_match_expr (gfc_expr ** result)\n+gfc_match_expr (gfc_expr **result)\n {\n   gfc_expr *all, *e;\n   gfc_user_op *uop;"}, {"sha": "bdc515c609471073a2f969d45e52b166517c7406", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "patch": "@@ -1,6 +1,6 @@\n /* Miscellaneous stuff that doesn't fit anywhere else.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software\n-   Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -20,12 +20,10 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"gfortran.h\"\n \n-\n /* Get a block of memory.  Many callers assume that the memory we\n    return is zeroed.  */\n \n@@ -54,7 +52,6 @@ gfc_getmem (size_t n)\n void\n gfc_free (void *p)\n {\n-\n   if (p != NULL)\n     free (p);\n }\n@@ -63,10 +60,10 @@ gfc_free (void *p)\n #undef temp\n \n \n-/* Get terminal width */\n+/* Get terminal width.  */\n \n int\n-gfc_terminal_width(void)\n+gfc_terminal_width (void)\n {\n   return 80;\n }\n@@ -75,9 +72,8 @@ gfc_terminal_width(void)\n /* Initialize a typespec to unknown.  */\n \n void\n-gfc_clear_ts (gfc_typespec * ts)\n+gfc_clear_ts (gfc_typespec *ts)\n {\n-\n   ts->type = BT_UNKNOWN;\n   ts->kind = 0;\n   ts->derived = NULL;\n@@ -154,9 +150,9 @@ gfc_basic_typename (bt type)\n    the argument list of a single statement.  */\n \n const char *\n-gfc_typename (gfc_typespec * ts)\n+gfc_typename (gfc_typespec *ts)\n {\n-  static char buffer1[60], buffer2[60];\n+  static char buffer1[60], buffer2[60]; /* FIXME:  Buffer overflow.  */\n   static int flag = 0;\n   char *buffer;\n \n@@ -204,9 +200,8 @@ gfc_typename (gfc_typespec * ts)\n    returning a pointer to the string.  */\n \n const char *\n-gfc_code2string (const mstring * m, int code)\n+gfc_code2string (const mstring *m, int code)\n {\n-\n   while (m->string != NULL)\n     {\n       if (m->tag == code)\n@@ -220,13 +215,11 @@ gfc_code2string (const mstring * m, int code)\n \n \n /* Given an mstring array and a string, returns the value of the tag\n-   field.  Returns the final tag if no matches to the string are\n-   found.  */\n+   field.  Returns the final tag if no matches to the string are found.  */\n \n int\n-gfc_string2code (const mstring * m, const char *string)\n+gfc_string2code (const mstring *m, const char *string)\n {\n-\n   for (; m->string != NULL; m++)\n     if (strcmp (m->string, string) == 0)\n       return m->tag;\n@@ -237,10 +230,10 @@ gfc_string2code (const mstring * m, const char *string)\n \n /* Convert an intent code to a string.  */\n /* TODO: move to gfortran.h as define.  */\n+\n const char *\n gfc_intent_string (sym_intent i)\n {\n-\n   return gfc_code2string (intents, i);\n }\n \n@@ -265,7 +258,6 @@ gfc_init_1 (void)\n void\n gfc_init_2 (void)\n {\n-\n   gfc_symbol_init_2 ();\n   gfc_module_init_2 ();\n }\n@@ -289,7 +281,6 @@ gfc_done_1 (void)\n void\n gfc_done_2 (void)\n {\n-\n   gfc_symbol_done_2 ();\n   gfc_module_done_2 ();\n }"}, {"sha": "1eed5e777bf8641f493697e174e36936bd8c4a1c", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 225, "deletions": 254, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "patch": "@@ -1,7 +1,7 @@\n /* Handle modules, which amounts to loading and saving symbols and\n    their attendant structures.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free\n-   Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -199,7 +199,7 @@ static bool in_load_equiv;\n /* Recursively free the tree of pointer structures.  */\n \n static void\n-free_pi_tree (pointer_info * p)\n+free_pi_tree (pointer_info *p)\n {\n   if (p == NULL)\n     return;\n@@ -218,7 +218,7 @@ free_pi_tree (pointer_info * p)\n    module.  */\n \n static int\n-compare_pointers (void * _sn1, void * _sn2)\n+compare_pointers (void *_sn1, void *_sn2)\n {\n   pointer_info *sn1, *sn2;\n \n@@ -238,7 +238,7 @@ compare_pointers (void * _sn1, void * _sn2)\n    module.  */\n \n static int\n-compare_integers (void * _sn1, void * _sn2)\n+compare_integers (void *_sn1, void *_sn2)\n {\n   pointer_info *sn1, *sn2;\n \n@@ -366,7 +366,7 @@ get_integer (int integer)\n /* Recursive function to find a pointer within a tree by brute force.  */\n \n static pointer_info *\n-fp2 (pointer_info * p, const void *target)\n+fp2 (pointer_info *p, const void *target)\n {\n   pointer_info *q;\n \n@@ -390,14 +390,13 @@ fp2 (pointer_info * p, const void *target)\n static pointer_info *\n find_pointer2 (void *p)\n {\n-\n   return fp2 (pi_root, p);\n }\n \n \n /* Resolve any fixups using a known pointer.  */\n static void\n-resolve_fixups (fixup_t *f, void * gp)\n+resolve_fixups (fixup_t *f, void *gp)\n {\n   fixup_t *next;\n \n@@ -409,12 +408,13 @@ resolve_fixups (fixup_t *f, void * gp)\n     }\n }\n \n+\n /* Call here during module reading when we know what pointer to\n    associate with an integer.  Any fixups that exist are resolved at\n    this time.  */\n \n static void\n-associate_integer_pointer (pointer_info * p, void *gp)\n+associate_integer_pointer (pointer_info *p, void *gp)\n {\n   if (p->u.pointer != NULL)\n     gfc_internal_error (\"associate_integer_pointer(): Already associated\");\n@@ -577,7 +577,7 @@ gfc_match_use (void)\n       tail = new;\n \n       /* See what kind of interface we're dealing with.  Assume it is\n-         not an operator.  */\n+\t not an operator.  */\n       new->operator = INTRINSIC_NONE;\n       if (gfc_match_generic_spec (&type, name, &operator) == MATCH_ERROR)\n \tgoto cleanup;\n@@ -681,6 +681,7 @@ find_use_name_n (const char *name, int *inst)\n   return (u->local_name[0] != '\\0') ? u->local_name : name;\n }\n \n+\n /* Given a name, return the name under which to load this symbol.\n    Returns NULL if this symbol shouldn't be loaded.  */\n \n@@ -691,8 +692,8 @@ find_use_name (const char *name)\n   return find_use_name_n (name, &i);\n }\n \n-/* Given a real name, return the number of use names associated\n-   with it.  */\n+\n+/* Given a real name, return the number of use names associated with it.  */\n \n static int\n number_use_names (const char *name)\n@@ -745,7 +746,7 @@ static true_name *true_name_root;\n /* Compare two true_name structures.  */\n \n static int\n-compare_true_names (void * _t1, void * _t2)\n+compare_true_names (void *_t1, void *_t2)\n {\n   true_name *t1, *t2;\n   int c;\n@@ -782,7 +783,7 @@ find_true_name (const char *name, const char *module)\n   p = true_name_root;\n   while (p != NULL)\n     {\n-      c = compare_true_names ((void *)(&t), (void *) p);\n+      c = compare_true_names ((void *) (&t), (void *) p);\n       if (c == 0)\n \treturn p->sym;\n \n@@ -793,11 +794,10 @@ find_true_name (const char *name, const char *module)\n }\n \n \n-/* Given a gfc_symbol pointer that is not in the true name tree, add\n-   it.  */\n+/* Given a gfc_symbol pointer that is not in the true name tree, add it.  */\n \n static void\n-add_true_name (gfc_symbol * sym)\n+add_true_name (gfc_symbol *sym)\n {\n   true_name *t;\n \n@@ -812,9 +812,8 @@ add_true_name (gfc_symbol * sym)\n    recursively traversing the current namespace.  */\n \n static void\n-build_tnt (gfc_symtree * st)\n+build_tnt (gfc_symtree *st)\n {\n-\n   if (st == NULL)\n     return;\n \n@@ -834,17 +833,15 @@ static void\n init_true_name_tree (void)\n {\n   true_name_root = NULL;\n-\n   build_tnt (gfc_current_ns->sym_root);\n }\n \n \n /* Recursively free a true name tree node.  */\n \n static void\n-free_true_name (true_name * t)\n+free_true_name (true_name *t)\n {\n-\n   if (t == NULL)\n     return;\n   free_true_name (t->left);\n@@ -911,9 +908,8 @@ bad_module (const char *msgid)\n /* Set the module's input pointer.  */\n \n static void\n-set_module_locus (module_locus * m)\n+set_module_locus (module_locus *m)\n {\n-\n   module_column = m->column;\n   module_line = m->line;\n   fsetpos (module_fp, &m->pos);\n@@ -923,9 +919,8 @@ set_module_locus (module_locus * m)\n /* Get the module's input pointer so that we can restore it later.  */\n \n static void\n-get_module_locus (module_locus * m)\n+get_module_locus (module_locus *m)\n {\n-\n   m->column = module_column;\n   m->line = module_line;\n   fgetpos (module_fp, &m->pos);\n@@ -978,14 +973,14 @@ parse_string (void)\n \tbad_module (\"Unexpected end of module in string constant\");\n \n       if (c != '\\'')\n-        {\n+\t{\n \t  len++;\n \t  continue;\n \t}\n \n       c = module_char ();\n       if (c == '\\'')\n-        {\n+\t{\n \t  len++;\n \t  continue;\n \t}\n@@ -1001,12 +996,12 @@ parse_string (void)\n     {\n       c = module_char ();\n       if (c == '\\'')\n-\tmodule_char ();\t\t/* Guaranteed to be another \\' */\n+\tmodule_char ();\t\t/* Guaranteed to be another \\'  */\n       *p++ = c;\n     }\n \n-  module_char ();\t\t/* Terminating \\' */\n-  *p = '\\0';\t\t\t/* C-style string for debug purposes */\n+  module_char ();\t\t/* Terminating \\'  */\n+  *p = '\\0';\t\t\t/* C-style string for debug purposes.  */\n }\n \n \n@@ -1239,7 +1234,7 @@ require_atom (atom_type type)\n    be one of the strings in the array.  We return the enum value.  */\n \n static int\n-find_enum (const mstring * m)\n+find_enum (const mstring *m)\n {\n   int i;\n \n@@ -1260,7 +1255,6 @@ find_enum (const mstring * m)\n static void\n write_char (char out)\n {\n-\n   if (fputc (out, module_fp) == EOF)\n     gfc_fatal_error (\"Error writing modules file: %s\", strerror (errno));\n \n@@ -1362,9 +1356,8 @@ static void mio_symtree_ref (gfc_symtree **);\n    pointer because enums are sometimes inside bitfields.  */\n \n static int\n-mio_name (int t, const mstring * m)\n+mio_name (int t, const mstring *m)\n {\n-\n   if (iomode == IO_OUTPUT)\n     write_atom (ATOM_NAME, gfc_code2string (m, t));\n   else\n@@ -1380,16 +1373,15 @@ mio_name (int t, const mstring * m)\n \n #define DECL_MIO_NAME(TYPE) \\\n  static inline TYPE \\\n- MIO_NAME(TYPE) (TYPE t, const mstring * m) \\\n+ MIO_NAME(TYPE) (TYPE t, const mstring *m) \\\n  { \\\n-   return (TYPE)mio_name ((int)t, m); \\\n+   return (TYPE) mio_name ((int) t, m); \\\n  }\n #define MIO_NAME(TYPE) mio_name_##TYPE\n \n static void\n mio_lparen (void)\n {\n-\n   if (iomode == IO_OUTPUT)\n     write_atom (ATOM_LPAREN, NULL);\n   else\n@@ -1400,7 +1392,6 @@ mio_lparen (void)\n static void\n mio_rparen (void)\n {\n-\n   if (iomode == IO_OUTPUT)\n     write_atom (ATOM_RPAREN, NULL);\n   else\n@@ -1411,7 +1402,6 @@ mio_rparen (void)\n static void\n mio_integer (int *ip)\n {\n-\n   if (iomode == IO_OUTPUT)\n     write_atom (ATOM_INTEGER, ip);\n   else\n@@ -1472,7 +1462,6 @@ mio_pool_string (const char **stringp)\n static void\n mio_internal_string (char *string)\n {\n-\n   if (iomode == IO_OUTPUT)\n     write_atom (ATOM_STRING, string);\n   else\n@@ -1529,18 +1518,18 @@ static const mstring attr_bits[] =\n };\n \n /* Specialization of mio_name.  */\n-DECL_MIO_NAME(ab_attribute)\n-DECL_MIO_NAME(ar_type)\n-DECL_MIO_NAME(array_type)\n-DECL_MIO_NAME(bt)\n-DECL_MIO_NAME(expr_t)\n-DECL_MIO_NAME(gfc_access)\n-DECL_MIO_NAME(gfc_intrinsic_op)\n-DECL_MIO_NAME(ifsrc)\n-DECL_MIO_NAME(procedure_type)\n-DECL_MIO_NAME(ref_type)\n-DECL_MIO_NAME(sym_flavor)\n-DECL_MIO_NAME(sym_intent)\n+DECL_MIO_NAME (ab_attribute)\n+DECL_MIO_NAME (ar_type)\n+DECL_MIO_NAME (array_type)\n+DECL_MIO_NAME (bt)\n+DECL_MIO_NAME (expr_t)\n+DECL_MIO_NAME (gfc_access)\n+DECL_MIO_NAME (gfc_intrinsic_op)\n+DECL_MIO_NAME (ifsrc)\n+DECL_MIO_NAME (procedure_type)\n+DECL_MIO_NAME (ref_type)\n+DECL_MIO_NAME (sym_flavor)\n+DECL_MIO_NAME (sym_intent)\n #undef DECL_MIO_NAME\n \n /* Symbol attributes are stored in list with the first three elements\n@@ -1550,86 +1539,85 @@ DECL_MIO_NAME(sym_intent)\n    written.  */\n \n static void\n-mio_symbol_attribute (symbol_attribute * attr)\n+mio_symbol_attribute (symbol_attribute *attr)\n {\n   atom_type t;\n \n   mio_lparen ();\n \n-  attr->flavor = MIO_NAME(sym_flavor) (attr->flavor, flavors);\n-  attr->intent = MIO_NAME(sym_intent) (attr->intent, intents);\n-  attr->proc = MIO_NAME(procedure_type) (attr->proc, procedures);\n-  attr->if_source = MIO_NAME(ifsrc) (attr->if_source, ifsrc_types);\n+  attr->flavor = MIO_NAME (sym_flavor) (attr->flavor, flavors);\n+  attr->intent = MIO_NAME (sym_intent) (attr->intent, intents);\n+  attr->proc = MIO_NAME (procedure_type) (attr->proc, procedures);\n+  attr->if_source = MIO_NAME (ifsrc) (attr->if_source, ifsrc_types);\n \n   if (iomode == IO_OUTPUT)\n     {\n       if (attr->allocatable)\n-\tMIO_NAME(ab_attribute) (AB_ALLOCATABLE, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_ALLOCATABLE, attr_bits);\n       if (attr->dimension)\n-\tMIO_NAME(ab_attribute) (AB_DIMENSION, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_DIMENSION, attr_bits);\n       if (attr->external)\n-\tMIO_NAME(ab_attribute) (AB_EXTERNAL, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_EXTERNAL, attr_bits);\n       if (attr->intrinsic)\n-\tMIO_NAME(ab_attribute) (AB_INTRINSIC, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_INTRINSIC, attr_bits);\n       if (attr->optional)\n-\tMIO_NAME(ab_attribute) (AB_OPTIONAL, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_OPTIONAL, attr_bits);\n       if (attr->pointer)\n-\tMIO_NAME(ab_attribute) (AB_POINTER, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_POINTER, attr_bits);\n       if (attr->protected)\n-\tMIO_NAME(ab_attribute) (AB_PROTECTED, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_PROTECTED, attr_bits);\n       if (attr->save)\n-\tMIO_NAME(ab_attribute) (AB_SAVE, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_SAVE, attr_bits);\n       if (attr->value)\n-\tMIO_NAME(ab_attribute) (AB_VALUE, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_VALUE, attr_bits);\n       if (attr->volatile_)\n-\tMIO_NAME(ab_attribute) (AB_VOLATILE, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_VOLATILE, attr_bits);\n       if (attr->target)\n-\tMIO_NAME(ab_attribute) (AB_TARGET, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_TARGET, attr_bits);\n       if (attr->threadprivate)\n-\tMIO_NAME(ab_attribute) (AB_THREADPRIVATE, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_THREADPRIVATE, attr_bits);\n       if (attr->dummy)\n-\tMIO_NAME(ab_attribute) (AB_DUMMY, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_DUMMY, attr_bits);\n       if (attr->result)\n-\tMIO_NAME(ab_attribute) (AB_RESULT, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_RESULT, attr_bits);\n       /* We deliberately don't preserve the \"entry\" flag.  */\n \n       if (attr->data)\n-\tMIO_NAME(ab_attribute) (AB_DATA, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_DATA, attr_bits);\n       if (attr->in_namelist)\n-\tMIO_NAME(ab_attribute) (AB_IN_NAMELIST, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_IN_NAMELIST, attr_bits);\n       if (attr->in_common)\n-\tMIO_NAME(ab_attribute) (AB_IN_COMMON, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_IN_COMMON, attr_bits);\n \n       if (attr->function)\n-\tMIO_NAME(ab_attribute) (AB_FUNCTION, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_FUNCTION, attr_bits);\n       if (attr->subroutine)\n-\tMIO_NAME(ab_attribute) (AB_SUBROUTINE, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_SUBROUTINE, attr_bits);\n       if (attr->generic)\n-\tMIO_NAME(ab_attribute) (AB_GENERIC, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_GENERIC, attr_bits);\n \n       if (attr->sequence)\n-\tMIO_NAME(ab_attribute) (AB_SEQUENCE, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_SEQUENCE, attr_bits);\n       if (attr->elemental)\n-\tMIO_NAME(ab_attribute) (AB_ELEMENTAL, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_ELEMENTAL, attr_bits);\n       if (attr->pure)\n-\tMIO_NAME(ab_attribute) (AB_PURE, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_PURE, attr_bits);\n       if (attr->recursive)\n-\tMIO_NAME(ab_attribute) (AB_RECURSIVE, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_RECURSIVE, attr_bits);\n       if (attr->always_explicit)\n-        MIO_NAME(ab_attribute) (AB_ALWAYS_EXPLICIT, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_ALWAYS_EXPLICIT, attr_bits);\n       if (attr->cray_pointer)\n-\tMIO_NAME(ab_attribute) (AB_CRAY_POINTER, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_CRAY_POINTER, attr_bits);\n       if (attr->cray_pointee)\n-\tMIO_NAME(ab_attribute) (AB_CRAY_POINTEE, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_CRAY_POINTEE, attr_bits);\n       if (attr->alloc_comp)\n-\tMIO_NAME(ab_attribute) (AB_ALLOC_COMP, attr_bits);\n+\tMIO_NAME (ab_attribute) (AB_ALLOC_COMP, attr_bits);\n \n       mio_rparen ();\n \n     }\n   else\n     {\n-\n       for (;;)\n \t{\n \t  t = parse_atom ();\n@@ -1712,9 +1700,9 @@ mio_symbol_attribute (symbol_attribute * attr)\n \t    case AB_RECURSIVE:\n \t      attr->recursive = 1;\n \t      break;\n-            case AB_ALWAYS_EXPLICIT:\n-              attr->always_explicit = 1;\n-              break;\n+\t    case AB_ALWAYS_EXPLICIT:\n+\t      attr->always_explicit = 1;\n+\t      break;\n \t    case AB_CRAY_POINTER:\n \t      attr->cray_pointer = 1;\n \t      break;\n@@ -1744,7 +1732,7 @@ static const mstring bt_types[] = {\n \n \n static void\n-mio_charlen (gfc_charlen ** clp)\n+mio_charlen (gfc_charlen **clp)\n {\n   gfc_charlen *cl;\n \n@@ -1758,7 +1746,6 @@ mio_charlen (gfc_charlen ** clp)\n     }\n   else\n     {\n-\n       if (peek_atom () != ATOM_RPAREN)\n \t{\n \t  cl = gfc_get_charlen ();\n@@ -1779,7 +1766,7 @@ mio_charlen (gfc_charlen ** clp)\n    within the namespace and corresponds to an illegal fortran name.  */\n \n static gfc_symtree *\n-get_unique_symtree (gfc_namespace * ns)\n+get_unique_symtree (gfc_namespace *ns)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   static int serial = 0;\n@@ -1794,18 +1781,16 @@ get_unique_symtree (gfc_namespace * ns)\n static int\n check_unique_name (const char *name)\n {\n-\n   return *name == '@';\n }\n \n \n static void\n-mio_typespec (gfc_typespec * ts)\n+mio_typespec (gfc_typespec *ts)\n {\n-\n   mio_lparen ();\n \n-  ts->type = MIO_NAME(bt) (ts->type, bt_types);\n+  ts->type = MIO_NAME (bt) (ts->type, bt_types);\n \n   if (ts->type != BT_DERIVED)\n     mio_integer (&ts->kind);\n@@ -1828,7 +1813,7 @@ static const mstring array_spec_types[] = {\n \n \n static void\n-mio_array_spec (gfc_array_spec ** asp)\n+mio_array_spec (gfc_array_spec **asp)\n {\n   gfc_array_spec *as;\n   int i;\n@@ -1853,7 +1838,7 @@ mio_array_spec (gfc_array_spec ** asp)\n     }\n \n   mio_integer (&as->rank);\n-  as->type = MIO_NAME(array_type) (as->type, array_spec_types);\n+  as->type = MIO_NAME (array_type) (as->type, array_spec_types);\n \n   for (i = 0; i < as->rank; i++)\n     {\n@@ -1879,13 +1864,14 @@ static const mstring array_ref_types[] = {\n     minit (NULL, -1)\n };\n \n+\n static void\n-mio_array_ref (gfc_array_ref * ar)\n+mio_array_ref (gfc_array_ref *ar)\n {\n   int i;\n \n   mio_lparen ();\n-  ar->type = MIO_NAME(ar_type) (ar->type, array_ref_types);\n+  ar->type = MIO_NAME (ar_type) (ar->type, array_ref_types);\n   mio_integer (&ar->dimen);\n \n   switch (ar->type)\n@@ -1976,7 +1962,7 @@ mio_pointer_ref (void *gp)\n    the namespace and is not loaded again.  */\n \n static void\n-mio_component_ref (gfc_component ** cp, gfc_symbol * sym)\n+mio_component_ref (gfc_component **cp, gfc_symbol *sym)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_component *q;\n@@ -2020,7 +2006,7 @@ mio_component_ref (gfc_component ** cp, gfc_symbol * sym)\n \n \n static void\n-mio_component (gfc_component * c)\n+mio_component (gfc_component *c)\n {\n   pointer_info *p;\n   int n;\n@@ -2056,7 +2042,7 @@ mio_component (gfc_component * c)\n \n \n static void\n-mio_component_list (gfc_component ** cp)\n+mio_component_list (gfc_component **cp)\n {\n   gfc_component *c, *tail;\n \n@@ -2069,7 +2055,6 @@ mio_component_list (gfc_component ** cp)\n     }\n   else\n     {\n-\n       *cp = NULL;\n       tail = NULL;\n \n@@ -2095,9 +2080,8 @@ mio_component_list (gfc_component ** cp)\n \n \n static void\n-mio_actual_arg (gfc_actual_arglist * a)\n+mio_actual_arg (gfc_actual_arglist *a)\n {\n-\n   mio_lparen ();\n   mio_pool_string (&a->name);\n   mio_expr (&a->expr);\n@@ -2106,7 +2090,7 @@ mio_actual_arg (gfc_actual_arglist * a)\n \n \n static void\n-mio_actual_arglist (gfc_actual_arglist ** ap)\n+mio_actual_arglist (gfc_actual_arglist **ap)\n {\n   gfc_actual_arglist *a, *tail;\n \n@@ -2146,7 +2130,7 @@ mio_actual_arglist (gfc_actual_arglist ** ap)\n /* Read and write formal argument lists.  */\n \n static void\n-mio_formal_arglist (gfc_symbol * sym)\n+mio_formal_arglist (gfc_symbol *sym)\n {\n   gfc_formal_arglist *f, *tail;\n \n@@ -2183,7 +2167,7 @@ mio_formal_arglist (gfc_symbol * sym)\n /* Save or restore a reference to a symbol node.  */\n \n void\n-mio_symbol_ref (gfc_symbol ** symp)\n+mio_symbol_ref (gfc_symbol **symp)\n {\n   pointer_info *p;\n \n@@ -2207,7 +2191,7 @@ mio_symbol_ref (gfc_symbol ** symp)\n /* Save or restore a reference to a symtree node.  */\n \n static void\n-mio_symtree_ref (gfc_symtree ** stp)\n+mio_symtree_ref (gfc_symtree **stp)\n {\n   pointer_info *p;\n   fixup_t *f;\n@@ -2224,29 +2208,30 @@ mio_symtree_ref (gfc_symtree ** stp)\n \treturn;\n       \n       if (p->type == P_UNKNOWN)\n-        p->type = P_SYMBOL;\n+\tp->type = P_SYMBOL;\n \n       if (p->u.rsym.state == UNUSED)\n \tp->u.rsym.state = NEEDED;\n \n       if (p->u.rsym.symtree != NULL)\n-        {\n-          *stp = p->u.rsym.symtree;\n-        }\n+\t{\n+\t  *stp = p->u.rsym.symtree;\n+\t}\n       else\n-        {\n-          f = gfc_getmem (sizeof (fixup_t));\n+\t{\n+\t  f = gfc_getmem (sizeof (fixup_t));\n \n-          f->next = p->u.rsym.stfixup;\n-          p->u.rsym.stfixup = f;\n+\t  f->next = p->u.rsym.stfixup;\n+\t  p->u.rsym.stfixup = f;\n \n-          f->pointer = (void **)stp;\n-        }\n+\t  f->pointer = (void **)stp;\n+\t}\n     }\n }\n \n+\n static void\n-mio_iterator (gfc_iterator ** ip)\n+mio_iterator (gfc_iterator **ip)\n {\n   gfc_iterator *iter;\n \n@@ -2280,9 +2265,8 @@ mio_iterator (gfc_iterator ** ip)\n }\n \n \n-\n static void\n-mio_constructor (gfc_constructor ** cp)\n+mio_constructor (gfc_constructor **cp)\n {\n   gfc_constructor *c, *tail;\n \n@@ -2300,7 +2284,6 @@ mio_constructor (gfc_constructor ** cp)\n     }\n   else\n     {\n-\n       *cp = NULL;\n       tail = NULL;\n \n@@ -2326,7 +2309,6 @@ mio_constructor (gfc_constructor ** cp)\n }\n \n \n-\n static const mstring ref_types[] = {\n     minit (\"ARRAY\", REF_ARRAY),\n     minit (\"COMPONENT\", REF_COMPONENT),\n@@ -2336,14 +2318,14 @@ static const mstring ref_types[] = {\n \n \n static void\n-mio_ref (gfc_ref ** rp)\n+mio_ref (gfc_ref **rp)\n {\n   gfc_ref *r;\n \n   mio_lparen ();\n \n   r = *rp;\n-  r->type = MIO_NAME(ref_type) (r->type, ref_types);\n+  r->type = MIO_NAME (ref_type) (r->type, ref_types);\n \n   switch (r->type)\n     {\n@@ -2368,7 +2350,7 @@ mio_ref (gfc_ref ** rp)\n \n \n static void\n-mio_ref_list (gfc_ref ** rp)\n+mio_ref_list (gfc_ref **rp)\n {\n   gfc_ref *ref, *head, *tail;\n \n@@ -2406,7 +2388,7 @@ mio_ref_list (gfc_ref ** rp)\n /* Read and write an integer value.  */\n \n static void\n-mio_gmp_integer (mpz_t * integer)\n+mio_gmp_integer (mpz_t *integer)\n {\n   char *p;\n \n@@ -2420,7 +2402,6 @@ mio_gmp_integer (mpz_t * integer)\n \tbad_module (\"Error converting integer\");\n \n       gfc_free (atom_string);\n-\n     }\n   else\n     {\n@@ -2432,7 +2413,7 @@ mio_gmp_integer (mpz_t * integer)\n \n \n static void\n-mio_gmp_real (mpfr_t * real)\n+mio_gmp_real (mpfr_t *real)\n {\n   mp_exp_t exponent;\n   char *p;\n@@ -2445,7 +2426,6 @@ mio_gmp_real (mpfr_t * real)\n       mpfr_init (*real);\n       mpfr_set_str (*real, atom_string, 16, GFC_RND_MODE);\n       gfc_free (atom_string);\n-\n     }\n   else\n     {\n@@ -2473,7 +2453,7 @@ mio_gmp_real (mpfr_t * real)\n /* Save and restore the shape of an array constructor.  */\n \n static void\n-mio_shape (mpz_t ** pshape, int rank)\n+mio_shape (mpz_t **pshape, int rank)\n {\n   mpz_t *shape;\n   atom_type t;\n@@ -2573,13 +2553,13 @@ fix_mio_expr (gfc_expr *e)\n \t yet. If so, the latter should be written.  */\n       if (e->symtree->n.sym && check_unique_name(e->symtree->name))\n \tns_st = gfc_find_symtree (gfc_current_ns->sym_root,\n-\t\t\t\t    e->symtree->n.sym->name);\n+\t\t\t\t  e->symtree->n.sym->name);\n \n       /* On the other hand, if the existing symbol is the module name or the\n \t new symbol is a dummy argument, do not do the promotion.  */\n       if (ns_st && ns_st->n.sym\n-\t    && ns_st->n.sym->attr.flavor != FL_MODULE\n-\t    && !e->symtree->n.sym->attr.dummy)\n+\t  && ns_st->n.sym->attr.flavor != FL_MODULE\n+\t  && !e->symtree->n.sym->attr.dummy)\n \te->symtree = ns_st;\n     }\n   else if (e->expr_type == EXPR_FUNCTION && e->value.function.name)\n@@ -2588,8 +2568,8 @@ fix_mio_expr (gfc_expr *e)\n \t expression, in one use associated module, can fail to be\n \t coupled to its symtree when used in a specification\n \t expression in another module.  */\n-      fname = e->value.function.esym ? e->value.function.esym->name :\n-\t\t\t\t       e->value.function.isym->name;\n+      fname = e->value.function.esym ? e->value.function.esym->name\n+\t\t\t\t     : e->value.function.isym->name;\n       e->symtree = gfc_find_symtree (gfc_current_ns->sym_root, fname);\n     }\n }\n@@ -2599,7 +2579,7 @@ fix_mio_expr (gfc_expr *e)\n    NULL expression.  */\n \n static void\n-mio_expr (gfc_expr ** ep)\n+mio_expr (gfc_expr **ep)\n {\n   gfc_expr *e;\n   atom_type t;\n@@ -2616,8 +2596,7 @@ mio_expr (gfc_expr ** ep)\n \t}\n \n       e = *ep;\n-      MIO_NAME(expr_t) (e->expr_type, expr_types);\n-\n+      MIO_NAME (expr_t) (e->expr_type, expr_types);\n     }\n   else\n     {\n@@ -2645,7 +2624,7 @@ mio_expr (gfc_expr ** ep)\n     {\n     case EXPR_OP:\n       e->value.op.operator\n-\t= MIO_NAME(gfc_intrinsic_op) (e->value.op.operator, intrinsics);\n+\t= MIO_NAME (gfc_intrinsic_op) (e->value.op.operator, intrinsics);\n \n       switch (e->value.op.operator)\n \t{\n@@ -2696,7 +2675,6 @@ mio_expr (gfc_expr ** ep)\n \t    mio_symbol_ref (&e->value.function.esym);\n \t  else\n \t    write_atom (ATOM_STRING, e->value.function.isym->name);\n-\n \t}\n       else\n \t{\n@@ -2723,8 +2701,8 @@ mio_expr (gfc_expr ** ep)\n       break;\n \n     case EXPR_SUBSTRING:\n-      e->value.character.string = (char *)\n-\tmio_allocated_string (e->value.character.string);\n+      e->value.character.string\n+\t= (char *) mio_allocated_string (e->value.character.string);\n       mio_ref_list (&e->ref);\n       break;\n \n@@ -2742,12 +2720,12 @@ mio_expr (gfc_expr ** ep)\n \t  break;\n \n \tcase BT_REAL:\n-          gfc_set_model_kind (e->ts.kind);\n+\t  gfc_set_model_kind (e->ts.kind);\n \t  mio_gmp_real (&e->value.real);\n \t  break;\n \n \tcase BT_COMPLEX:\n-          gfc_set_model_kind (e->ts.kind);\n+\t  gfc_set_model_kind (e->ts.kind);\n \t  mio_gmp_real (&e->value.complex.r);\n \t  mio_gmp_real (&e->value.complex.i);\n \t  break;\n@@ -2758,8 +2736,8 @@ mio_expr (gfc_expr ** ep)\n \n \tcase BT_CHARACTER:\n \t  mio_integer (&e->value.character.length);\n-\t  e->value.character.string = (char *)\n-\t    mio_allocated_string (e->value.character.string);\n+\t  e->value.character.string\n+\t    = (char *) mio_allocated_string (e->value.character.string);\n \t  break;\n \n \tdefault:\n@@ -2779,7 +2757,7 @@ mio_expr (gfc_expr ** ep)\n /* Read and write namelists */\n \n static void\n-mio_namelist (gfc_symbol * sym)\n+mio_namelist (gfc_symbol *sym)\n {\n   gfc_namelist *n, *m;\n   const char *check_name;\n@@ -2800,9 +2778,8 @@ mio_namelist (gfc_symbol * sym)\n \t{\n \t  check_name = find_use_name (sym->name);\n \t  if (check_name && strcmp (check_name, sym->name) != 0)\n-\t    gfc_error(\"Namelist %s cannot be renamed by USE\"\n-\t\t      \" association to %s\",\n-\t\t      sym->name, check_name);\n+\t    gfc_error (\"Namelist %s cannot be renamed by USE \"\n+\t\t       \"association to %s\", sym->name, check_name);\n \t}\n \n       m = NULL;\n@@ -2831,7 +2808,7 @@ mio_namelist (gfc_symbol * sym)\n    be done later when all symbols have been loaded.  */\n \n static void\n-mio_interface_rest (gfc_interface ** ip)\n+mio_interface_rest (gfc_interface **ip)\n {\n   gfc_interface *tail, *p;\n \n@@ -2843,7 +2820,6 @@ mio_interface_rest (gfc_interface ** ip)\n     }\n   else\n     {\n-\n       if (*ip == NULL)\n \ttail = NULL;\n       else\n@@ -2878,9 +2854,8 @@ mio_interface_rest (gfc_interface ** ip)\n /* Save/restore a nameless operator interface.  */\n \n static void\n-mio_interface (gfc_interface ** ip)\n+mio_interface (gfc_interface **ip)\n {\n-\n   mio_lparen ();\n   mio_interface_rest (ip);\n }\n@@ -2890,20 +2865,17 @@ mio_interface (gfc_interface ** ip)\n \n static void\n mio_symbol_interface (const char **name, const char **module,\n-\t\t      gfc_interface ** ip)\n+\t\t      gfc_interface **ip)\n {\n-\n   mio_lparen ();\n-\n   mio_pool_string (name);\n   mio_pool_string (module);\n-\n   mio_interface_rest (ip);\n }\n \n \n static void\n-mio_namespace_ref (gfc_namespace ** nsp)\n+mio_namespace_ref (gfc_namespace **nsp)\n {\n   gfc_namespace *ns;\n   pointer_info *p;\n@@ -2915,7 +2887,7 @@ mio_namespace_ref (gfc_namespace ** nsp)\n \n   if (iomode == IO_INPUT && p->integer != 0)\n     {\n-      ns = (gfc_namespace *)p->u.pointer;\n+      ns = (gfc_namespace *) p->u.pointer;\n       if (ns == NULL)\n \t{\n \t  ns = gfc_get_namespace (NULL, 0);\n@@ -2927,12 +2899,11 @@ mio_namespace_ref (gfc_namespace ** nsp)\n }\n \n \n-/* Unlike most other routines, the address of the symbol node is\n-   already fixed on input and the name/module has already been filled\n-   in.  */\n+/* Unlike most other routines, the address of the symbol node is already\n+   fixed on input and the name/module has already been filled in.  */\n \n static void\n-mio_symbol (gfc_symbol * sym)\n+mio_symbol (gfc_symbol *sym)\n {\n   gfc_formal_arglist *formal;\n \n@@ -2985,8 +2956,8 @@ mio_symbol (gfc_symbol * sym)\n   mio_component_list (&sym->components);\n \n   if (sym->components != NULL)\n-    sym->component_access =\n-      MIO_NAME(gfc_access) (sym->component_access, access_types);\n+    sym->component_access\n+      = MIO_NAME (gfc_access) (sym->component_access, access_types);\n \n   mio_namelist (sym);\n   mio_rparen ();\n@@ -3096,7 +3067,7 @@ load_generic_interfaces (void)\n \t  if (p == NULL || gfc_find_symbol (p, NULL, 0, &sym))\n \t    {\n \t      while (parse_atom () != ATOM_RPAREN);\n-\t        continue;\n+\t\tcontinue;\n \t    }\n \n \t  if (sym == NULL)\n@@ -3139,9 +3110,9 @@ load_generic_interfaces (void)\n /* Load common blocks.  */\n \n static void\n-load_commons(void)\n+load_commons (void)\n {\n-  char name[GFC_MAX_SYMBOL_LEN+1];\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_common_head *p;\n \n   mio_lparen ();\n@@ -3162,45 +3133,46 @@ load_commons(void)\n \tp->threadprivate = 1;\n       p->use_assoc = 1;\n \n-      mio_rparen();\n+      mio_rparen ();\n     }\n \n-  mio_rparen();\n+  mio_rparen ();\n }\n \n+\n /* load_equiv()-- Load equivalences. The flag in_load_equiv informs\n    mio_expr_ref of this so that unused variables are not loaded and\n    so that the expression can be safely freed.*/\n \n static void\n-load_equiv(void)\n+load_equiv (void)\n {\n   gfc_equiv *head, *tail, *end, *eq;\n   bool unused;\n \n-  mio_lparen();\n+  mio_lparen ();\n   in_load_equiv = true;\n \n   end = gfc_current_ns->equiv;\n-  while(end != NULL && end->next != NULL)\n+  while (end != NULL && end->next != NULL)\n     end = end->next;\n \n-  while(peek_atom() != ATOM_RPAREN) {\n-    mio_lparen();\n+  while (peek_atom() != ATOM_RPAREN) {\n+    mio_lparen ();\n     head = tail = NULL;\n \n-    while(peek_atom() != ATOM_RPAREN)\n+    while(peek_atom () != ATOM_RPAREN)\n       {\n \tif (head == NULL)\n-\t  head = tail = gfc_get_equiv();\n+\t  head = tail = gfc_get_equiv ();\n \telse\n \t  {\n-\t    tail->eq = gfc_get_equiv();\n+\t    tail->eq = gfc_get_equiv ();\n \t    tail = tail->eq;\n \t  }\n \n-\tmio_pool_string(&tail->module);\n-\tmio_expr(&tail->expr);\n+\tmio_pool_string (&tail->module);\n+\tmio_expr (&tail->expr);\n       }\n \n     /* Unused variables have no symtree.  */\n@@ -3232,10 +3204,10 @@ load_equiv(void)\n     if (head != NULL)\n       end = head;\n \n-    mio_rparen();\n+    mio_rparen ();\n   }\n \n-  mio_rparen();\n+  mio_rparen ();\n   in_load_equiv = false;\n }\n \n@@ -3244,7 +3216,7 @@ load_equiv(void)\n    traversal, because the act of loading can alter the tree.  */\n \n static int\n-load_needed (pointer_info * p)\n+load_needed (pointer_info *p)\n {\n   gfc_namespace *ns;\n   pointer_info *q;\n@@ -3300,7 +3272,7 @@ load_needed (pointer_info * p)\n    read.  */\n \n static void\n-read_cleanup (pointer_info * p)\n+read_cleanup (pointer_info *p)\n {\n   gfc_symtree *st;\n   pointer_info *q;\n@@ -3387,8 +3359,7 @@ read_module (void)\n       sym = find_true_name (info->u.rsym.true_name, info->u.rsym.module);\n \n       if (sym == NULL\n-\t   || (sym->attr.flavor == FL_VARIABLE\n-\t       && info->u.rsym.ns !=1))\n+\t  || (sym->attr.flavor == FL_VARIABLE && info->u.rsym.ns !=1))\n \tcontinue;\n \n       info->u.rsym.state = USED;\n@@ -3438,9 +3409,11 @@ read_module (void)\n \t    }\n \t  else\n \t    {\n-\t      /* Create a symtree node in the current namespace for this symbol.  */\n-\t      st = check_unique_name (p) ? get_unique_symtree (gfc_current_ns) :\n-\t      gfc_new_symtree (&gfc_current_ns->sym_root, p);\n+\t      /* Create a symtree node in the current namespace for this\n+\t\t symbol.  */\n+\t      st = check_unique_name (p)\n+\t\t   ? get_unique_symtree (gfc_current_ns)\n+\t\t   : gfc_new_symtree (&gfc_current_ns->sym_root, p);\n \n \t      st->ambiguous = ambiguous;\n \n@@ -3449,10 +3422,9 @@ read_module (void)\n \t      /* Create a symbol node if it doesn't already exist.  */\n \t      if (sym == NULL)\n \t\t{\n-\t\t  sym = info->u.rsym.sym =\n-\t\t      gfc_new_symbol (info->u.rsym.true_name,\n-\t\t\t\t      gfc_current_ns);\n-\n+\t\t  info->u.rsym.sym = gfc_new_symbol (info->u.rsym.true_name,\n+\t\t\t\t\t\t     gfc_current_ns);\n+\t\t  sym = info->u.rsym.sym;\n \t\t  sym->module = gfc_get_string (info->u.rsym.module);\n \t\t}\n \n@@ -3463,7 +3435,7 @@ read_module (void)\n \t      info->u.rsym.symtree = st;\n \n \t      if (info->u.rsym.state == UNUSED)\n-\t        info->u.rsym.state = NEEDED;\n+\t\tinfo->u.rsym.state = NEEDED;\n \t      info->u.rsym.referenced = 1;\n \t    }\n \t}\n@@ -3508,16 +3480,15 @@ read_module (void)\n   load_generic_interfaces ();\n \n   load_commons ();\n-  load_equiv();\n+  load_equiv ();\n \n   /* At this point, we read those symbols that are needed but haven't\n      been loaded yet.  If one symbol requires another, the other gets\n      marked as NEEDED if its previous state was UNUSED.  */\n \n   while (load_needed (pi_root));\n \n-  /* Make sure all elements of the rename-list were found in the\n-     module.  */\n+  /* Make sure all elements of the rename-list were found in the module.  */\n \n   for (u = gfc_rename_list; u; u = u->next)\n     {\n@@ -3533,15 +3504,14 @@ read_module (void)\n \n       if (u->operator == INTRINSIC_USER)\n \t{\n-\t  gfc_error\n-\t    (\"User operator '%s' referenced at %L not found in module '%s'\",\n-\t     u->use_name, &u->where, module_name);\n+\t  gfc_error (\"User operator '%s' referenced at %L not found \"\n+\t\t     \"in module '%s'\", u->use_name, &u->where, module_name);\n \t  continue;\n \t}\n \n-      gfc_error\n-\t(\"Intrinsic operator '%s' referenced at %L not found in module \"\n-\t \"'%s'\", gfc_op2string (u->operator), &u->where, module_name);\n+      gfc_error (\"Intrinsic operator '%s' referenced at %L not found \"\n+\t\t \"in module '%s'\", gfc_op2string (u->operator), &u->where,\n+\t\t module_name);\n     }\n \n   gfc_check_interfaces (gfc_current_ns);\n@@ -3562,7 +3532,6 @@ read_module (void)\n bool\n gfc_check_access (gfc_access specific_access, gfc_access default_access)\n {\n-\n   if (specific_access == ACCESS_PUBLIC)\n     return TRUE;\n   if (specific_access == ACCESS_PRIVATE)\n@@ -3584,23 +3553,23 @@ write_common (gfc_symtree *st)\n   if (st == NULL)\n     return;\n \n-  write_common(st->left);\n-  write_common(st->right);\n+  write_common (st->left);\n+  write_common (st->right);\n \n-  mio_lparen();\n+  mio_lparen ();\n \n   /* Write the unmangled name.  */\n   name = st->n.common->name;\n \n-  mio_pool_string(&name);\n+  mio_pool_string (&name);\n \n   p = st->n.common;\n-  mio_symbol_ref(&p->head);\n+  mio_symbol_ref (&p->head);\n   flags = p->saved ? 1 : 0;\n   if (p->threadprivate) flags |= 2;\n-  mio_integer(&flags);\n+  mio_integer (&flags);\n \n-  mio_rparen();\n+  mio_rparen ();\n }\n \n /* Write the blank common block to the module */\n@@ -3614,47 +3583,49 @@ write_blank_common (void)\n   if (gfc_current_ns->blank_common.head == NULL)\n     return;\n \n-  mio_lparen();\n+  mio_lparen ();\n \n-  mio_pool_string(&name);\n+  mio_pool_string (&name);\n \n-  mio_symbol_ref(&gfc_current_ns->blank_common.head);\n+  mio_symbol_ref (&gfc_current_ns->blank_common.head);\n   saved = gfc_current_ns->blank_common.saved;\n-  mio_integer(&saved);\n+  mio_integer (&saved);\n \n-  mio_rparen();\n+  mio_rparen ();\n }\n \n+\n /* Write equivalences to the module.  */\n \n static void\n-write_equiv(void)\n+write_equiv (void)\n {\n   gfc_equiv *eq, *e;\n   int num;\n \n   num = 0;\n-  for(eq=gfc_current_ns->equiv; eq; eq=eq->next)\n+  for (eq = gfc_current_ns->equiv; eq; eq = eq->next)\n     {\n-      mio_lparen();\n+      mio_lparen ();\n \n-      for(e=eq; e; e=e->eq)\n+      for (e = eq; e; e = e->eq)\n \t{\n \t  if (e->module == NULL)\n-\t    e->module = gfc_get_string(\"%s.eq.%d\", module_name, num);\n-\t  mio_allocated_string(e->module);\n-\t  mio_expr(&e->expr);\n+\t    e->module = gfc_get_string (\"%s.eq.%d\", module_name, num);\n+\t  mio_allocated_string (e->module);\n+\t  mio_expr (&e->expr);\n \t}\n \n       num++;\n-      mio_rparen();\n+      mio_rparen ();\n     }\n }\n \n+\n /* Write a symbol to the module.  */\n \n static void\n-write_symbol (int n, gfc_symbol * sym)\n+write_symbol (int n, gfc_symbol *sym)\n {\n \n   if (sym->attr.flavor == FL_UNKNOWN || sym->attr.flavor == FL_LABEL)\n@@ -3676,7 +3647,7 @@ write_symbol (int n, gfc_symbol * sym)\n    according to the access specification.  */\n \n static void\n-write_symbol0 (gfc_symtree * st)\n+write_symbol0 (gfc_symtree *st)\n {\n   gfc_symbol *sym;\n   pointer_info *p;\n@@ -3720,9 +3691,8 @@ write_symbol0 (gfc_symtree * st)\n    symbol was written and pass that information upwards.  */\n \n static int\n-write_symbol1 (pointer_info * p)\n+write_symbol1 (pointer_info *p)\n {\n-\n   if (p == NULL)\n     return 0;\n \n@@ -3744,7 +3714,7 @@ write_symbol1 (pointer_info * p)\n /* Write operator interfaces associated with a symbol.  */\n \n static void\n-write_operator (gfc_user_op * uop)\n+write_operator (gfc_user_op *uop)\n {\n   static char nullstring[] = \"\";\n   const char *p = nullstring;\n@@ -3760,9 +3730,8 @@ write_operator (gfc_user_op * uop)\n /* Write generic interfaces associated with a symbol.  */\n \n static void\n-write_generic (gfc_symbol * sym)\n+write_generic (gfc_symbol *sym)\n {\n-\n   if (sym->generic == NULL\n       || !gfc_check_access (sym->attr.access, sym->ns->default_access))\n     return;\n@@ -3775,7 +3744,7 @@ write_generic (gfc_symbol * sym)\n \n \n static void\n-write_symtree (gfc_symtree * st)\n+write_symtree (gfc_symtree *st)\n {\n   gfc_symbol *sym;\n   pointer_info *p;\n@@ -3840,10 +3809,11 @@ write_module (void)\n   write_char ('\\n');\n   write_char ('\\n');\n \n-  mio_lparen();\n-  write_equiv();\n-  mio_rparen();\n-  write_char('\\n');  write_char('\\n');\n+  mio_lparen ();\n+  write_equiv ();\n+  mio_rparen ();\n+  write_char ('\\n');\n+  write_char ('\\n');\n \n   /* Write symbol information.  First we traverse all symbols in the\n      primary namespace, writing those that need to be written.\n@@ -3935,8 +3905,8 @@ gfc_dump_module (const char *name, int dump_flag)\n static void\n create_int_parameter (const char *name, int value, const char *modname)\n {\n-  gfc_symtree * tmp_symtree;\n-  gfc_symbol * sym;\n+  gfc_symtree *tmp_symtree;\n+  gfc_symbol *sym;\n \n   tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root, name);\n   if (tmp_symtree != NULL)\n@@ -3958,7 +3928,9 @@ create_int_parameter (const char *name, int value, const char *modname)\n   sym->attr.use_assoc = 1;\n }\n \n+\n /* USE the ISO_FORTRAN_ENV intrinsic module.  */\n+\n static void\n use_iso_fortran_env_module (void)\n {\n@@ -4063,6 +4035,7 @@ use_iso_fortran_env_module (void)\n     }\n }\n \n+\n /* Process a USE directive.  */\n \n void\n@@ -4073,8 +4046,8 @@ gfc_use_module (void)\n   int c, line, start;\n   gfc_symtree *mod_symtree;\n \n-  filename = (char *) alloca(strlen(module_name) + strlen(MODULE_EXTENSION)\n-\t\t\t     + 1);\n+  filename = (char *) alloca (strlen (module_name) + strlen (MODULE_EXTENSION)\n+\t\t\t      + 1);\n   strcpy (filename, module_name);\n   strcat (filename, MODULE_EXTENSION);\n \n@@ -4089,18 +4062,18 @@ gfc_use_module (void)\n   if (module_fp == NULL && !specified_nonint)\n     {\n       if (strcmp (module_name, \"iso_fortran_env\") == 0\n-         && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: \"\n-                            \"ISO_FORTRAN_ENV intrinsic module at %C\") != FAILURE)\n+\t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ISO_FORTRAN_ENV \"\n+\t\t\t     \"intrinsic module at %C\") != FAILURE)\n        {\n-         use_iso_fortran_env_module ();\n-         return;\n+\t use_iso_fortran_env_module ();\n+\t return;\n        }\n \n       module_fp = gfc_open_intrinsic_module (filename);\n \n       if (module_fp == NULL && specified_int)\n        gfc_fatal_error (\"Can't find an intrinsic module named '%s' at %C\",\n-                        module_name);\n+\t\t\tmodule_name);\n     }\n \n   if (module_fp == NULL)\n@@ -4131,9 +4104,9 @@ gfc_use_module (void)\n       if (start++ < 2)\n \tparse_name (c);\n       if ((start == 1 && strcmp (atom_name, \"GFORTRAN\") != 0)\n-\t    || (start == 2 && strcmp (atom_name, \" module\") != 0))\n+\t  || (start == 2 && strcmp (atom_name, \" module\") != 0))\n \tgfc_fatal_error (\"File '%s' opened at %C is not a GFORTRAN module \"\n-\t\t\t  \"file\", filename);\n+\t\t\t \"file\", filename);\n \n       if (c == '\\n')\n \tline++;\n@@ -4162,14 +4135,12 @@ gfc_use_module (void)\n void\n gfc_module_init_2 (void)\n {\n-\n   last_atom = ATOM_LPAREN;\n }\n \n \n void\n gfc_module_done_2 (void)\n {\n-\n   free_rename ();\n }"}, {"sha": "9694c89743f8f9499370ff128c710bf248719d12", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 76, "deletions": 50, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "patch": "@@ -1,5 +1,6 @@\n /* OpenMP directive matching and resolving.\n-   Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek\n \n This file is part of GCC.\n@@ -19,7 +20,6 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"flags.h\"\n@@ -410,6 +410,7 @@ gfc_match_omp_parallel (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_critical (void)\n {\n@@ -424,6 +425,7 @@ gfc_match_omp_critical (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_do (void)\n {\n@@ -435,6 +437,7 @@ gfc_match_omp_do (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_flush (void)\n {\n@@ -450,6 +453,7 @@ gfc_match_omp_flush (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_threadprivate (void)\n {\n@@ -478,8 +482,8 @@ gfc_match_omp_threadprivate (void)\n \t{\n \tcase MATCH_YES:\n \t  if (sym->attr.in_common)\n-\t    gfc_error_now (\"Threadprivate variable at %C is an element of\"\n-\t\t\t   \" a COMMON block\");\n+\t    gfc_error_now (\"Threadprivate variable at %C is an element of \"\n+\t\t\t   \"a COMMON block\");\n \t  else if (gfc_add_threadprivate (&sym->attr, sym->name,\n \t\t   &sym->declared_at) == FAILURE)\n \t    goto cleanup;\n@@ -525,6 +529,7 @@ gfc_match_omp_threadprivate (void)\n   return MATCH_ERROR;\n }\n \n+\n match\n gfc_match_omp_parallel_do (void)\n {\n@@ -537,6 +542,7 @@ gfc_match_omp_parallel_do (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_parallel_sections (void)\n {\n@@ -549,6 +555,7 @@ gfc_match_omp_parallel_sections (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_parallel_workshare (void)\n {\n@@ -560,6 +567,7 @@ gfc_match_omp_parallel_workshare (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_sections (void)\n {\n@@ -571,6 +579,7 @@ gfc_match_omp_sections (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_single (void)\n {\n@@ -583,6 +592,7 @@ gfc_match_omp_single (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_workshare (void)\n {\n@@ -593,6 +603,7 @@ gfc_match_omp_workshare (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_master (void)\n {\n@@ -603,6 +614,7 @@ gfc_match_omp_master (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_ordered (void)\n {\n@@ -613,6 +625,7 @@ gfc_match_omp_ordered (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_atomic (void)\n {\n@@ -623,6 +636,7 @@ gfc_match_omp_atomic (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_barrier (void)\n {\n@@ -633,6 +647,7 @@ gfc_match_omp_barrier (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_end_nowait (void)\n {\n@@ -646,6 +661,7 @@ gfc_match_omp_end_nowait (void)\n   return MATCH_YES;\n }\n \n+\n match\n gfc_match_omp_end_single (void)\n {\n@@ -663,6 +679,7 @@ gfc_match_omp_end_single (void)\n   return MATCH_YES;\n }\n \n+\n /* OpenMP directive resolving routines.  */\n \n static void\n@@ -691,16 +708,16 @@ resolve_omp_clauses (gfc_code *code)\n       gfc_expr *expr = omp_clauses->num_threads;\n       if (gfc_resolve_expr (expr) == FAILURE\n \t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n-\tgfc_error (\"NUM_THREADS clause at %L requires a scalar\"\n-\t\t   \" INTEGER expression\", &expr->where);\n+\tgfc_error (\"NUM_THREADS clause at %L requires a scalar \"\n+\t\t   \"INTEGER expression\", &expr->where);\n     }\n   if (omp_clauses->chunk_size)\n     {\n       gfc_expr *expr = omp_clauses->chunk_size;\n       if (gfc_resolve_expr (expr) == FAILURE\n \t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n-\tgfc_error (\"SCHEDULE clause's chunk_size at %L requires\"\n-\t\t   \" a scalar INTEGER expression\", &expr->where);\n+\tgfc_error (\"SCHEDULE clause's chunk_size at %L requires \"\n+\t\t   \"a scalar INTEGER expression\", &expr->where);\n     }\n \n   /* Check that no symbol appears on multiple clauses, except that\n@@ -774,19 +791,19 @@ resolve_omp_clauses (gfc_code *code)\n \t    for (; n != NULL; n = n->next)\n \t      {\n \t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n-\t\t  gfc_error (\"Assumed size array '%s' in COPYPRIVATE clause\"\n-\t\t\t     \" at %L\", n->sym->name, &code->loc);\n+\t\t  gfc_error (\"Assumed size array '%s' in COPYPRIVATE clause \"\n+\t\t\t     \"at %L\", n->sym->name, &code->loc);\n \t\tif (n->sym->attr.allocatable)\n-\t\t  gfc_error (\"COPYPRIVATE clause object '%s' is ALLOCATABLE\"\n-\t\t\t     \" at %L\", n->sym->name, &code->loc);\n+\t\t  gfc_error (\"COPYPRIVATE clause object '%s' is ALLOCATABLE \"\n+\t\t\t     \"at %L\", n->sym->name, &code->loc);\n \t      }\n \t    break;\n \t  case OMP_LIST_SHARED:\n \t    for (; n != NULL; n = n->next)\n \t      {\n \t\tif (n->sym->attr.threadprivate)\n-\t\t  gfc_error (\"THREADPRIVATE object '%s' in SHARED clause at\"\n-\t\t\t     \" %L\", n->sym->name, &code->loc);\n+\t\t  gfc_error (\"THREADPRIVATE object '%s' in SHARED clause at \"\n+\t\t\t     \"%L\", n->sym->name, &code->loc);\n \t\tif (n->sym->attr.cray_pointee)\n \t\t  gfc_error (\"Cray pointee '%s' in SHARED clause at %L\",\n \t\t\t    n->sym->name, &code->loc);\n@@ -819,8 +836,8 @@ resolve_omp_clauses (gfc_code *code)\n \t\tif (n->sym->attr.in_namelist\n \t\t    && (list < OMP_LIST_REDUCTION_FIRST\n \t\t\t|| list > OMP_LIST_REDUCTION_LAST))\n-\t\t  gfc_error (\"Variable '%s' in %s clause is used in\"\n-\t\t\t     \" NAMELIST statement at %L\",\n+\t\t  gfc_error (\"Variable '%s' in %s clause is used in \"\n+\t\t\t     \"NAMELIST statement at %L\",\n \t\t\t     n->sym->name, name, &code->loc);\n \t\tswitch (list)\n \t\t  {\n@@ -839,8 +856,8 @@ resolve_omp_clauses (gfc_code *code)\n \t\t  case OMP_LIST_EQV:\n \t\t  case OMP_LIST_NEQV:\n \t\t    if (n->sym->ts.type != BT_LOGICAL)\n-\t\t      gfc_error (\"%s REDUCTION variable '%s' must be LOGICAL\"\n-\t\t\t\t \" at %L\",\n+\t\t      gfc_error (\"%s REDUCTION variable '%s' must be LOGICAL \"\n+\t\t\t\t \"at %L\",\n \t\t\t\t list == OMP_LIST_AND ? \".AND.\"\n \t\t\t\t : list == OMP_LIST_OR ? \".OR.\"\n \t\t\t\t : list == OMP_LIST_EQV ? \".EQV.\" : \".NEQV.\",\n@@ -850,17 +867,17 @@ resolve_omp_clauses (gfc_code *code)\n \t\t  case OMP_LIST_MIN:\n \t\t    if (n->sym->ts.type != BT_INTEGER\n \t\t\t&& n->sym->ts.type != BT_REAL)\n-\t\t      gfc_error (\"%s REDUCTION variable '%s' must be\"\n-\t\t\t\t \" INTEGER or REAL at %L\",\n+\t\t      gfc_error (\"%s REDUCTION variable '%s' must be \"\n+\t\t\t\t \"INTEGER or REAL at %L\",\n \t\t\t\t list == OMP_LIST_MAX ? \"MAX\" : \"MIN\",\n \t\t\t\t n->sym->name, &code->loc);\n \t\t    break;\n \t\t  case OMP_LIST_IAND:\n \t\t  case OMP_LIST_IOR:\n \t\t  case OMP_LIST_IEOR:\n \t\t    if (n->sym->ts.type != BT_INTEGER)\n-\t\t      gfc_error (\"%s REDUCTION variable '%s' must be INTEGER\"\n-\t\t\t\t \" at %L\",\n+\t\t      gfc_error (\"%s REDUCTION variable '%s' must be INTEGER \"\n+\t\t\t\t \"at %L\",\n \t\t\t\t list == OMP_LIST_IAND ? \"IAND\"\n \t\t\t\t : list == OMP_LIST_MULT ? \"IOR\" : \"IEOR\",\n \t\t\t\t n->sym->name, &code->loc);\n@@ -878,6 +895,7 @@ resolve_omp_clauses (gfc_code *code)\n       }\n }\n \n+\n /* Return true if SYM is ever referenced in EXPR except in the SE node.  */\n \n static bool\n@@ -917,6 +935,7 @@ expr_references_sym (gfc_expr *e, gfc_symbol *s, gfc_expr *se)\n     }\n }\n \n+\n /* If EXPR is a conversion function that widens the type\n    if WIDENING is true or narrows the type if WIDENING is false,\n    return the inner expression, otherwise return NULL.  */\n@@ -950,6 +969,7 @@ is_conversion (gfc_expr *expr, bool widening)\n   return NULL;\n }\n \n+\n static void\n resolve_omp_atomic (gfc_code *code)\n {\n@@ -968,8 +988,8 @@ resolve_omp_atomic (gfc_code *code)\n \t  && code->expr->ts.type != BT_COMPLEX\n \t  && code->expr->ts.type != BT_LOGICAL))\n     {\n-      gfc_error (\"!$OMP ATOMIC statement must set a scalar variable of\"\n-\t\t \" intrinsic type at %L\", &code->loc);\n+      gfc_error (\"!$OMP ATOMIC statement must set a scalar variable of \"\n+\t\t \"intrinsic type at %L\", &code->loc);\n       return;\n     }\n \n@@ -1008,8 +1028,8 @@ resolve_omp_atomic (gfc_code *code)\n \t  alt_op = INTRINSIC_EQV;\n \t  break;\n \tdefault:\n-\t  gfc_error (\"!$OMP ATOMIC assignment operator must be\"\n-\t\t     \" +, *, -, /, .AND., .OR., .EQV. or .NEQV. at %L\",\n+\t  gfc_error (\"!$OMP ATOMIC assignment operator must be \"\n+\t\t     \"+, *, -, /, .AND., .OR., .EQV. or .NEQV. at %L\",\n \t\t     &expr2->where);\n \t  return;\n \t}\n@@ -1056,8 +1076,8 @@ resolve_omp_atomic (gfc_code *code)\n \n \t  if (v == NULL)\n \t    {\n-\t      gfc_error (\"!$OMP ATOMIC assignment must be var = var op expr\"\n-\t\t\t \" or var = expr op var at %L\", &expr2->where);\n+\t      gfc_error (\"!$OMP ATOMIC assignment must be var = var op expr \"\n+\t\t\t \"or var = expr op var at %L\", &expr2->where);\n \t      return;\n \t    }\n \n@@ -1070,9 +1090,9 @@ resolve_omp_atomic (gfc_code *code)\n \t\tcase INTRINSIC_DIVIDE:\n \t\tcase INTRINSIC_EQV:\n \t\tcase INTRINSIC_NEQV:\n-\t\t  gfc_error (\"!$OMP ATOMIC var = var op expr not\"\n-\t\t\t     \" mathematically equivalent to var = var op\"\n-\t\t\t     \" (expr) at %L\", &expr2->where);\n+\t\t  gfc_error (\"!$OMP ATOMIC var = var op expr not \"\n+\t\t\t     \"mathematically equivalent to var = var op \"\n+\t\t\t     \"(expr) at %L\", &expr2->where);\n \t\t  break;\n \t\tdefault:\n \t\t  break;\n@@ -1102,8 +1122,8 @@ resolve_omp_atomic (gfc_code *code)\n \n       if (e->rank != 0 || expr_references_sym (code->expr2, var, v))\n \t{\n-\t  gfc_error (\"expr in !$OMP ATOMIC assignment var = var op expr\"\n-\t\t     \" must be scalar and cannot reference var at %L\",\n+\t  gfc_error (\"expr in !$OMP ATOMIC assignment var = var op expr \"\n+\t\t     \"must be scalar and cannot reference var at %L\",\n \t\t     &expr2->where);\n \t  return;\n \t}\n@@ -1126,15 +1146,15 @@ resolve_omp_atomic (gfc_code *code)\n \tcase GFC_ISYM_IEOR:\n \t  if (expr2->value.function.actual->next->next != NULL)\n \t    {\n-\t      gfc_error (\"!$OMP ATOMIC assignment intrinsic IAND, IOR\"\n+\t      gfc_error (\"!$OMP ATOMIC assignment intrinsic IAND, IOR \"\n \t\t\t \"or IEOR must have two arguments at %L\",\n \t\t\t &expr2->where);\n \t      return;\n \t    }\n \t  break;\n \tdefault:\n-\t  gfc_error (\"!$OMP ATOMIC assignment intrinsic must be\"\n-\t\t     \" MIN, MAX, IAND, IOR or IEOR at %L\",\n+\t  gfc_error (\"!$OMP ATOMIC assignment intrinsic must be \"\n+\t\t     \"MIN, MAX, IAND, IOR or IEOR at %L\",\n \t\t     &expr2->where);\n \t  return;\n \t}\n@@ -1149,17 +1169,17 @@ resolve_omp_atomic (gfc_code *code)\n \t      && arg->expr->symtree->n.sym == var)\n \t    var_arg = arg;\n \t  else if (expr_references_sym (arg->expr, var, NULL))\n-\t    gfc_error (\"!$OMP ATOMIC intrinsic arguments except one must not\"\n-\t\t       \" reference '%s' at %L\", var->name, &arg->expr->where);\n+\t    gfc_error (\"!$OMP ATOMIC intrinsic arguments except one must not \"\n+\t\t       \"reference '%s' at %L\", var->name, &arg->expr->where);\n \t  if (arg->expr->rank != 0)\n-\t    gfc_error (\"!$OMP ATOMIC intrinsic arguments must be scalar\"\n-\t\t       \" at %L\", &arg->expr->where);\n+\t    gfc_error (\"!$OMP ATOMIC intrinsic arguments must be scalar \"\n+\t\t       \"at %L\", &arg->expr->where);\n \t}\n \n       if (var_arg == NULL)\n \t{\n-\t  gfc_error (\"First or last !$OMP ATOMIC intrinsic argument must\"\n-\t\t     \" be '%s' at %L\", var->name, &expr2->where);\n+\t  gfc_error (\"First or last !$OMP ATOMIC intrinsic argument must \"\n+\t\t     \"be '%s' at %L\", var->name, &expr2->where);\n \t  return;\n \t}\n \n@@ -1176,10 +1196,11 @@ resolve_omp_atomic (gfc_code *code)\n \t}\n     }\n   else\n-    gfc_error (\"!$OMP ATOMIC assignment must have an operator or intrinsic\"\n-\t       \" on right hand side at %L\", &expr2->where);\n+    gfc_error (\"!$OMP ATOMIC assignment must have an operator or intrinsic \"\n+\t       \"on right hand side at %L\", &expr2->where);\n }\n \n+\n struct omp_context\n {\n   gfc_code *code;\n@@ -1189,6 +1210,7 @@ struct omp_context\n } *omp_current_ctx;\n gfc_code *omp_current_do_code;\n \n+\n void\n gfc_resolve_omp_do_blocks (gfc_code *code, gfc_namespace *ns)\n {\n@@ -1197,6 +1219,7 @@ gfc_resolve_omp_do_blocks (gfc_code *code, gfc_namespace *ns)\n   gfc_resolve_blocks (code->block, ns);\n }\n \n+\n void\n gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n {\n@@ -1225,6 +1248,7 @@ gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n   pointer_set_destroy (ctx.private_iterators);\n }\n \n+\n /* Note a DO iterator variable.  This is special in !$omp parallel\n    construct, where they are predetermined private.  */\n \n@@ -1260,6 +1284,7 @@ gfc_resolve_do_iterator (gfc_code *code, gfc_symbol *sym)\n     }\n }\n \n+\n static void\n resolve_omp_do (gfc_code *code)\n {\n@@ -1273,8 +1298,8 @@ resolve_omp_do (gfc_code *code)\n \n   do_code = code->block->next;\n   if (do_code->op == EXEC_DO_WHILE)\n-    gfc_error (\"!$OMP DO cannot be a DO WHILE or DO without loop control at %L\",\n-\t       &do_code->loc);\n+    gfc_error (\"!$OMP DO cannot be a DO WHILE or DO without loop control \"\n+\t       \"at %L\", &do_code->loc);\n   else\n     {\n       gcc_assert (do_code->op == EXEC_DO);\n@@ -1283,22 +1308,23 @@ resolve_omp_do (gfc_code *code)\n \t\t   &do_code->loc);\n       dovar = do_code->ext.iterator->var->symtree->n.sym;\n       if (dovar->attr.threadprivate)\n-\tgfc_error (\"!$OMP DO iteration variable must not be THREADPRIVATE at %L\",\n-\t\t   &do_code->loc);\n+\tgfc_error (\"!$OMP DO iteration variable must not be THREADPRIVATE \"\n+\t\t   \"at %L\", &do_code->loc);\n       if (code->ext.omp_clauses)\n \tfor (list = 0; list < OMP_LIST_NUM; list++)\n \t  if (list != OMP_LIST_PRIVATE && list != OMP_LIST_LASTPRIVATE)\n \t    for (n = code->ext.omp_clauses->lists[list]; n; n = n->next)\n \t      if (dovar == n->sym)\n \t\t{\n-\t\t  gfc_error (\"!$OMP DO iteration variable present on clause\"\n-\t\t\t     \" other than PRIVATE or LASTPRIVATE at %L\",\n+\t\t  gfc_error (\"!$OMP DO iteration variable present on clause \"\n+\t\t\t     \"other than PRIVATE or LASTPRIVATE at %L\",\n \t\t\t     &do_code->loc);\n \t\t  break;\n \t\t}\n     }\n }\n \n+\n /* Resolve OpenMP directive clauses and check various requirements\n    of each directive.  */\n "}, {"sha": "e3879f006f43ef401f874f2a3f4994639a2b9d41", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "patch": "@@ -1,5 +1,5 @@\n /* Parse and display command line options.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -20,7 +20,6 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -31,7 +30,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"options.h\"\n #include \"params.h\"\n #include \"tree-inline.h\"\n-\n #include \"gfortran.h\"\n #include \"target.h\"\n \n@@ -94,8 +92,7 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n \n   gfc_option.fpe = 0;\n \n-  /* Argument pointers cannot point to anything\n-     but their argument.  */\n+  /* Argument pointers cannot point to anything but their argument.  */\n   flag_argument_noalias = 3;\n \n   flag_errno_math = 0;\n@@ -112,7 +109,7 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n   gfc_option.fshort_enums = targetm.default_short_enums ();\n \n   /* Increase MAX_ALIASED_VOPS to account for different characteristics\n-     of fortran regarding VOPs.  */\n+     of Fortran regarding VOPs.  */\n   MAX_ALIASED_VOPS = 50;\n \n   return CL_Fortran;\n@@ -125,7 +122,6 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n static gfc_source_form\n form_from_filename (const char *filename)\n {\n-\n   static const struct\n   {\n     const char *extension;\n@@ -223,6 +219,7 @@ gfc_post_options (const char **pfilename)\n   i = strlen (canon_source_file);\n   while (i > 0 && !IS_DIR_SEPARATOR (canon_source_file[i]))\n     i--;\n+\n   if (i != 0)\n     {\n       source_path = alloca (i + 1);\n@@ -260,8 +257,7 @@ gfc_post_options (const char **pfilename)\n \tgfc_warning_now (\"'-fd-lines-as-comments' has no effect \"\n \t\t\t \"in free form\");\n       else if (gfc_option.flag_d_lines == 1)\n-\tgfc_warning_now (\"'-fd-lines-as-code' has no effect \"\n-\t\t\t \"in free form\");\n+\tgfc_warning_now (\"'-fd-lines-as-code' has no effect in free form\");\n     }\n \n   flag_inline_trees = 1;\n@@ -304,7 +300,6 @@ gfc_post_options (const char **pfilename)\n static void\n set_Wall (void)\n {\n-\n   gfc_option.warn_aliasing = 1;\n   gfc_option.warn_ampersand = 1;\n   gfc_option.warn_line_truncation = 1;\n@@ -350,12 +345,13 @@ gfc_handle_module_path_options (const char *arg)\n   gfc_add_include_path (gfc_option.module_dir, true);\n }\n \n+\n static void\n gfc_handle_fpe_trap_option (const char *arg)\n {\n   int result, pos = 0, n;\n   static const char * const exception[] = { \"invalid\", \"denormal\", \"zero\",\n-                                            \"overflow\", \"underflow\",\n+\t\t\t\t\t    \"overflow\", \"underflow\",\n \t\t\t\t\t    \"precision\", NULL };\n   static const int opt_exception[] = { GFC_FPE_INVALID, GFC_FPE_DENORMAL,\n \t\t\t\t       GFC_FPE_ZERO, GFC_FPE_OVERFLOW,\n@@ -366,8 +362,10 @@ gfc_handle_fpe_trap_option (const char *arg)\n     {\n       while (*arg == ',')\n \targ++;\n+\n       while (arg[pos] && arg[pos] != ',')\n \tpos++;\n+\n       result = 0;\n       for (n = 0; exception[n] != NULL; n++)\n \t{\n@@ -380,13 +378,15 @@ gfc_handle_fpe_trap_option (const char *arg)\n \t      break;\n \t    }\n \t}\n-      if (! result)\n+      if (!result)\n \tgfc_fatal_error (\"Argument to -ffpe-trap is not valid: %s\", arg);\n     }\n }\n \n+\n /* Handle command-line options.  Returns 0 if unrecognized, 1 if\n    recognized and handled.  */\n+\n int\n gfc_handle_option (size_t scode, const char *arg, int value)\n {\n@@ -665,7 +665,8 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n \n     case OPT_fmax_subrecord_length_:\n       if (value > MAX_SUBRECORD_LENGTH)\n-\tgfc_fatal_error (\"Maximum subrecord length cannot exceed %d\", MAX_SUBRECORD_LENGTH);\n+\tgfc_fatal_error (\"Maximum subrecord length cannot exceed %d\",\n+\t\t\t MAX_SUBRECORD_LENGTH);\n \n       gfc_option.max_subrecord_length = value;\n     }"}, {"sha": "eb7802ed0dc23dd36dfd052bc74fa0d2c2d9eee4", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 146, "deletions": 163, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "patch": "@@ -1,6 +1,6 @@\n /* Main parser.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, \n-   Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -20,17 +20,15 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include <setjmp.h>\n #include \"gfortran.h\"\n #include \"match.h\"\n #include \"parse.h\"\n \n-/* Current statement label.  Zero means no statement label.  Because\n-   new_st can get wiped during statement matching, we have to keep it\n-   separate.  */\n+/* Current statement label.  Zero means no statement label.  Because new_st\n+   can get wiped during statement matching, we have to keep it separate.  */\n \n gfc_st_label *gfc_statement_label;\n \n@@ -51,7 +49,7 @@ static void reject_statement (void);\n    gfc_match_eos().  */\n \n static match\n-match_word (const char *str, match (*subr) (void), locus * old_locus)\n+match_word (const char *str, match (*subr) (void), locus *old_locus)\n {\n   match m;\n \n@@ -79,11 +77,11 @@ match_word (const char *str, match (*subr) (void), locus * old_locus)\n    ambiguity.  */\n \n #define match(keyword, subr, st)\t\t\t\t\\\n-    do {                                                        \\\n+    do {\t\t\t\t\t\t\t\\\n       if (match_word(keyword, subr, &old_locus) == MATCH_YES)\t\\\n-        return st;\t\t\t\t\t\t\\\n+\treturn st;\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n-        undo_new_statement ();                                  \\\n+\tundo_new_statement ();\t\t\t\t  \\\n     } while (0);\n \n static gfc_statement\n@@ -322,7 +320,8 @@ decode_omp_directive (void)\n \n   if (gfc_pure (NULL))\n     {\n-      gfc_error_now (\"OpenMP directives at %C may not appear in PURE or ELEMENTAL procedures\");\n+      gfc_error_now (\"OpenMP directives at %C may not appear in PURE \"\n+\t\t     \"or ELEMENTAL procedures\");\n       gfc_error_recovery ();\n       return ST_NONE;\n     }\n@@ -434,7 +433,7 @@ next_free (void)\n \t{\n \t  gfc_match_small_literal_int (&c, &cnt);\n \n-          if (cnt > 5)\n+\t  if (cnt > 5)\n \t    gfc_error_now (\"Too many digits in statement label at %C\");\n \n \t  if (c == 0)\n@@ -457,16 +456,16 @@ next_free (void)\n \n \t  if (at_bol && gfc_peek_char () == ';')\n \t    {\n-\t      gfc_error_now\n-\t\t(\"Semicolon at %C needs to be preceded by statement\");\n+\t      gfc_error_now (\"Semicolon at %C needs to be preceded by \"\n+\t\t\t     \"statement\");\n \t      gfc_next_char (); /* Eat up the semicolon.  */\n \t      return ST_NONE;\n \t    }\n \n \t  if (gfc_match_eos () == MATCH_YES)\n \t    {\n-\t      gfc_warning_now\n-\t\t(\"Ignoring statement label in empty statement at %C\");\n+\t      gfc_warning_now (\"Ignoring statement label in empty statement \"\n+\t\t\t       \"at %C\");\n \t      gfc_free_st_label (gfc_statement_label);\n \t      gfc_statement_label = NULL;\n \t      return ST_NONE;\n@@ -669,8 +668,7 @@ next_statement (void)\n \t  break;\n \t}\n \n-      st =\n-\t(gfc_current_form == FORM_FIXED) ? next_fixed () : next_free ();\n+      st = (gfc_current_form == FORM_FIXED) ? next_fixed () : next_free ();\n \n       if (st != ST_NONE)\n \tbreak;\n@@ -723,21 +721,19 @@ next_statement (void)\n    are detected in gfc_match_end().  */\n \n #define case_end case ST_END_BLOCK_DATA: case ST_END_FUNCTION: \\\n-                 case ST_END_PROGRAM: case ST_END_SUBROUTINE\n+\t\t case ST_END_PROGRAM: case ST_END_SUBROUTINE\n \n \n /* Push a new state onto the stack.  */\n \n static void\n-push_state (gfc_state_data * p, gfc_compile_state new_state, gfc_symbol * sym)\n+push_state (gfc_state_data *p, gfc_compile_state new_state, gfc_symbol *sym)\n {\n-\n   p->state = new_state;\n   p->previous = gfc_state_stack;\n   p->sym = sym;\n   p->head = p->tail = NULL;\n   p->do_variable = NULL;\n-\n   gfc_state_stack = p;\n }\n \n@@ -747,7 +743,6 @@ push_state (gfc_state_data * p, gfc_compile_state new_state, gfc_symbol * sym)\n static void\n pop_state (void)\n {\n-\n   gfc_state_stack = gfc_state_stack->previous;\n }\n \n@@ -770,7 +765,7 @@ gfc_find_state (gfc_compile_state state)\n /* Starts a new level in the statement list.  */\n \n static gfc_code *\n-new_level (gfc_code * q)\n+new_level (gfc_code *q)\n {\n   gfc_code *p;\n \n@@ -857,8 +852,8 @@ check_statement_label (gfc_statement st)\n       break;\n \n       /* Statement labels are not restricted from appearing on a\n-         particular line.  However, there are plenty of situations\n-         where the resulting label can't be referenced.  */\n+\t particular line.  However, there are plenty of situations\n+\t where the resulting label can't be referenced.  */\n \n     default:\n       type = ST_LABEL_BAD_TARGET;\n@@ -1230,7 +1225,7 @@ gfc_ascii_statement (gfc_statement st)\n /* Create a symbol for the main program and assign it to ns->proc_name.  */\n  \n static void \n-main_program_symbol (gfc_namespace * ns)\n+main_program_symbol (gfc_namespace *ns)\n {\n   gfc_symbol *main_program;\n   symbol_attribute attr;\n@@ -1254,7 +1249,6 @@ main_program_symbol (gfc_namespace * ns)\n static void\n accept_statement (gfc_statement st)\n {\n-\n   switch (st)\n     {\n     case ST_USE:\n@@ -1275,8 +1269,8 @@ accept_statement (gfc_statement st)\n       break;\n \n       /* If the statement is the end of a block, lay down a special code\n-         that allows a branch to the end of the block from within the\n-         construct.  */\n+\t that allows a branch to the end of the block from within the\n+\t construct.  */\n \n     case ST_ENDIF:\n     case ST_END_SELECT:\n@@ -1289,8 +1283,8 @@ accept_statement (gfc_statement st)\n       break;\n \n       /* The end-of-program unit statements do not get the special\n-         marker and require a statement of some sort if they are a\n-         branch target.  */\n+\t marker and require a statement of some sort if they are a\n+\t branch target.  */\n \n     case ST_END_PROGRAM:\n     case ST_END_FUNCTION:\n@@ -1338,7 +1332,6 @@ reject_statement (void)\n static void\n unexpected_statement (gfc_statement st)\n {\n-\n   gfc_error (\"Unexpected %s statement at %C\", gfc_ascii_statement (st));\n \n   reject_statement ();\n@@ -1354,30 +1347,30 @@ unexpected_statement (gfc_statement st)\n    valid before calling here, ie ENTRY statements are not allowed in\n    INTERFACE blocks.  The following diagram is taken from the standard:\n \n-            +---------------------------------------+\n-            | program  subroutine  function  module |\n-            +---------------------------------------+\n-            |                 use                   |\n-            +---------------------------------------+\n-            |                 import                |\n-            +---------------------------------------+\n-            |        |        implicit none         |\n-            |        +-----------+------------------+\n-            |        | parameter |  implicit        |\n-            |        +-----------+------------------+\n-            | format |           |  derived type    |\n-            | entry  | parameter |  interface       |\n-            |        |   data    |  specification   |\n-            |        |           |  statement func  |\n-            |        +-----------+------------------+\n-            |        |   data    |    executable    |\n-            +--------+-----------+------------------+\n-            |                contains               |\n-            +---------------------------------------+\n-            |      internal module/subprogram       |\n-            +---------------------------------------+\n-            |                   end                 |\n-            +---------------------------------------+\n+\t    +---------------------------------------+\n+\t    | program  subroutine  function  module |\n+\t    +---------------------------------------+\n+\t    |\t\t use\t\t   |\n+\t    +---------------------------------------+\n+\t    |\t\t import\t\t|\n+\t    +---------------------------------------+\n+\t    |\t|\timplicit none\t |\n+\t    |\t+-----------+------------------+\n+\t    |\t| parameter |  implicit\t|\n+\t    |\t+-----------+------------------+\n+\t    | format |\t   |  derived type    |\n+\t    | entry  | parameter |  interface       |\n+\t    |\t|   data    |  specification   |\n+\t    |\t|\t   |  statement func  |\n+\t    |\t+-----------+------------------+\n+\t    |\t|   data    |    executable    |\n+\t    +--------+-----------+------------------+\n+\t    |\t\tcontains\t       |\n+\t    +---------------------------------------+\n+\t    |      internal module/subprogram       |\n+\t    +---------------------------------------+\n+\t    |\t\t   end\t\t |\n+\t    +---------------------------------------+\n \n */\n \n@@ -1394,7 +1387,7 @@ typedef struct\n st_state;\n \n static try\n-verify_st_order (st_state * p, gfc_statement st)\n+verify_st_order (st_state *p, gfc_statement st)\n {\n \n   switch (st)\n@@ -1419,10 +1412,10 @@ verify_st_order (st_state * p, gfc_statement st)\n       if (p->state > ORDER_IMPLICIT_NONE)\n \tgoto order;\n \n-   /* The '>' sign cannot be a '>=', because a FORMAT or ENTRY\n-      statement disqualifies a USE but not an IMPLICIT NONE.\n-      Duplicate IMPLICIT NONEs are caught when the implicit types\n-      are set.  */\n+      /* The '>' sign cannot be a '>=', because a FORMAT or ENTRY\n+\t statement disqualifies a USE but not an IMPLICIT NONE.\n+\t Duplicate IMPLICIT NONEs are caught when the implicit types\n+\t are set.  */\n \n       p->state = ORDER_IMPLICIT_NONE;\n       break;\n@@ -1468,9 +1461,8 @@ verify_st_order (st_state * p, gfc_statement st)\n       break;\n \n     default:\n-      gfc_internal_error\n-\t(\"Unexpected %s statement in verify_st_order() at %C\",\n-\t gfc_ascii_statement (st));\n+      gfc_internal_error (\"Unexpected %s statement in verify_st_order() at %C\",\n+\t\t\t  gfc_ascii_statement (st));\n     }\n \n   /* All is well, record the statement in case we need it next time.  */\n@@ -1560,8 +1552,8 @@ parse_derived (void)\n \tcase ST_PRIVATE:\n \t  if (gfc_find_state (COMP_MODULE) == FAILURE)\n \t    {\n-\t      gfc_error\n-\t\t(\"PRIVATE statement in TYPE at %C must be inside a MODULE\");\n+\t      gfc_error (\"PRIVATE statement in TYPE at %C must be inside \"\n+\t\t\t \"a MODULE\");\n \t      error_flag = 1;\n \t      break;\n \t    }\n@@ -1619,8 +1611,8 @@ parse_derived (void)\n   sym = gfc_current_block ();\n   for (c = sym->components; c; c = c->next)\n     {\n-      if (c->allocatable || (c->ts.type == BT_DERIVED\n-\t\t    \t     && c->ts.derived->attr.alloc_comp))\n+      if (c->allocatable\n+\t  || (c->ts.type == BT_DERIVED && c->ts.derived->attr.alloc_comp))\n \t{\n \t  sym->attr.alloc_comp = 1;\n \t  break;\n@@ -1631,7 +1623,6 @@ parse_derived (void)\n }\n \n \n-\n /* Parse an ENUM.  */\n  \n static void\n@@ -1653,35 +1644,36 @@ parse_enum (void)\n     {\n       st = next_statement ();\n       switch (st)\n-        {\n-        case ST_NONE:\n-          unexpected_eof ();\n-          break;\n+\t{\n+\tcase ST_NONE:\n+\t  unexpected_eof ();\n+\t  break;\n \n-        case ST_ENUMERATOR:\n+\tcase ST_ENUMERATOR:\n \t  seen_enumerator = 1;\n-          accept_statement (st);\n-          break;\n+\t  accept_statement (st);\n+\t  break;\n \n-        case ST_END_ENUM:\n-          compiling_enum = 0;\n+\tcase ST_END_ENUM:\n+\t  compiling_enum = 0;\n \t  if (!seen_enumerator)\n-            {\n-              gfc_error (\"ENUM declaration at %C has no ENUMERATORS\");\n+\t    {\n+\t      gfc_error (\"ENUM declaration at %C has no ENUMERATORS\");\n \t      error_flag = 1;\n-            }\n-          accept_statement (st);\n-          break;\n-\n-        default:\n-          gfc_free_enum_history ();\n-          unexpected_statement (st);\n-          break;\n-        }\n+\t    }\n+\t  accept_statement (st);\n+\t  break;\n+\n+\tdefault:\n+\t  gfc_free_enum_history ();\n+\t  unexpected_statement (st);\n+\t  break;\n+\t}\n     }\n   pop_state ();\n }\n \n+\n /* Parse an interface.  We must be able to deal with the possibility\n    of recursive interfaces.  The parse_spec() subroutine is mutually\n    recursive with parse_interface().  */\n@@ -1704,7 +1696,8 @@ parse_interface (void)\n   save = current_interface;\n \n   sym = (current_interface.type == INTERFACE_GENERIC\n-\t || current_interface.type == INTERFACE_USER_OP) ? gfc_new_block : NULL;\n+\t || current_interface.type == INTERFACE_USER_OP)\n+\t? gfc_new_block : NULL;\n \n   push_state (&s1, COMP_INTERFACE, sym);\n   current_state = COMP_NONE;\n@@ -1768,14 +1761,12 @@ parse_interface (void)\n \t  if (new_state != current_state)\n \t    {\n \t      if (new_state == COMP_SUBROUTINE)\n-\t\tgfc_error\n-\t\t  (\"SUBROUTINE at %C does not belong in a generic function \"\n-\t\t   \"interface\");\n+\t\tgfc_error (\"SUBROUTINE at %C does not belong in a \"\n+\t\t\t   \"generic function interface\");\n \n \t      if (new_state == COMP_FUNCTION)\n-\t\tgfc_error\n-\t\t  (\"FUNCTION at %C does not belong in a generic subroutine \"\n-\t\t   \"interface\");\n+\t\tgfc_error (\"FUNCTION at %C does not belong in a \"\n+\t\t\t   \"generic subroutine interface\");\n \t    }\n \t}\n     }\n@@ -1945,7 +1936,7 @@ parse_where_block (void)\n \n \tcase ST_WHERE_BLOCK:\n \t  parse_where_block ();\n-          break;\n+\t  break;\n \n \tcase ST_ASSIGNMENT:\n \tcase ST_WHERE:\n@@ -1955,9 +1946,8 @@ parse_where_block (void)\n \tcase ST_ELSEWHERE:\n \t  if (seen_empty_else)\n \t    {\n-\t      gfc_error\n-\t\t(\"ELSEWHERE statement at %C follows previous unmasked \"\n-\t\t \"ELSEWHERE\");\n+\t      gfc_error (\"ELSEWHERE statement at %C follows previous \"\n+\t\t\t \"unmasked ELSEWHERE\");\n \t      break;\n \t    }\n \n@@ -1982,7 +1972,6 @@ parse_where_block (void)\n \t  reject_statement ();\n \t  break;\n \t}\n-\n     }\n   while (st != ST_END_WHERE);\n \n@@ -2088,9 +2077,8 @@ parse_if_block (void)\n \tcase ST_ELSEIF:\n \t  if (seen_else)\n \t    {\n-\t      gfc_error\n-\t\t(\"ELSE IF statement at %C cannot follow ELSE statement at %L\",\n-\t\t &else_locus);\n+\t      gfc_error (\"ELSE IF statement at %C cannot follow ELSE \"\n+\t\t\t \"statement at %L\", &else_locus);\n \n \t      reject_statement ();\n \t      break;\n@@ -2168,9 +2156,8 @@ parse_select_block (void)\n       if (st == ST_CASE)\n \tbreak;\n \n-      gfc_error\n-\t(\"Expected a CASE or END SELECT statement following SELECT CASE \"\n-\t \"at %C\");\n+      gfc_error (\"Expected a CASE or END SELECT statement following SELECT \"\n+\t\t \"CASE at %C\");\n \n       reject_statement ();\n     }\n@@ -2200,8 +2187,8 @@ parse_select_block (void)\n \tcase ST_END_SELECT:\n \t  break;\n \n-        /* Can't have an executable statement because of\n-           parse_executable().  */\n+\t/* Can't have an executable statement because of\n+\t   parse_executable().  */\n \tdefault:\n \t  unexpected_statement (st);\n \t  break;\n@@ -2261,8 +2248,7 @@ check_do_closure (void)\n       if (p == gfc_state_stack)\n \treturn 1;\n \n-      gfc_error\n-\t(\"End of nonblock DO statement at %C is within another block\");\n+      gfc_error (\"End of nonblock DO statement at %C is within another block\");\n       return 2;\n     }\n \n@@ -2320,8 +2306,8 @@ parse_do_block (void)\n     case ST_ENDDO:\n       if (s.ext.end_do_label != NULL\n \t  && s.ext.end_do_label != gfc_statement_label)\n-\tgfc_error_now\n-\t  (\"Statement label in ENDDO at %C doesn't match DO label\");\n+\tgfc_error_now (\"Statement label in ENDDO at %C doesn't match \"\n+\t\t       \"DO label\");\n \n       if (gfc_statement_label != NULL)\n \t{\n@@ -2336,9 +2322,8 @@ parse_do_block (void)\n \tname, but in that case we must have seen ST_ENDDO first).\n \tWe only complain about this in pedantic mode.  */\n      if (gfc_current_block () != NULL)\n-\tgfc_error_now\n-\t  (\"named block DO at %L requires matching ENDDO name\",\n-\t   &gfc_current_block()->declared_at);\n+\tgfc_error_now (\"named block DO at %L requires matching ENDDO name\",\n+\t\t       &gfc_current_block()->declared_at);\n \n       break;\n \n@@ -2387,12 +2372,12 @@ parse_omp_do (gfc_statement omp_st)\n       && gfc_state_stack->previous->ext.end_do_label == gfc_statement_label)\n     {\n       /* In\n-         DO 100 I=1,10\n-           !$OMP DO\n-             DO J=1,10\n-             ...\n-             100 CONTINUE\n-         there should be no !$OMP END DO.  */\n+\t DO 100 I=1,10\n+\t   !$OMP DO\n+\t     DO J=1,10\n+\t     ...\n+\t     100 CONTINUE\n+\t there should be no !$OMP END DO.  */\n       pop_state ();\n       return ST_IMPLIED_ENDDO;\n     }\n@@ -2593,8 +2578,8 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)\n       if (((cp->ext.omp_name == NULL) ^ (new_st.ext.omp_name == NULL))\n \t  || (new_st.ext.omp_name != NULL\n \t      && strcmp (cp->ext.omp_name, new_st.ext.omp_name) != 0))\n-\tgfc_error (\"Name after !$omp critical and !$omp end critical does\"\n-\t\t   \" not match at %C\");\n+\tgfc_error (\"Name after !$omp critical and !$omp end critical does \"\n+\t\t   \"not match at %C\");\n       gfc_free ((char *) new_st.ext.omp_name);\n       break;\n     case EXEC_OMP_END_SINGLE:\n@@ -2649,9 +2634,8 @@ parse_executable (gfc_statement st)\n \t  case ST_FORALL:\n \t  case ST_WHERE:\n \t  case ST_SELECT_CASE:\n-\t    gfc_error\n-\t      (\"%s statement at %C cannot terminate a non-block DO loop\",\n-\t       gfc_ascii_statement (st));\n+\t    gfc_error (\"%s statement at %C cannot terminate a non-block \"\n+\t\t       \"DO loop\", gfc_ascii_statement (st));\n \t    break;\n \n \t  default:\n@@ -2738,7 +2722,7 @@ static void parse_progunit (gfc_statement);\n    the child namespace as the parser didn't know about this procedure.  */\n \n static void\n-gfc_fixup_sibling_symbols (gfc_symbol * sym, gfc_namespace * siblings)\n+gfc_fixup_sibling_symbols (gfc_symbol *sym, gfc_namespace *siblings)\n {\n   gfc_namespace *ns;\n   gfc_symtree *st;\n@@ -2756,17 +2740,17 @@ gfc_fixup_sibling_symbols (gfc_symbol * sym, gfc_namespace * siblings)\n       if ((old_sym->attr.flavor == FL_PROCEDURE\n \t   || old_sym->ts.type == BT_UNKNOWN)\n \t  && old_sym->ns == ns\n-          && ! old_sym->attr.contained)\n-        {\n-          /* Replace it with the symbol from the parent namespace.  */\n-          st->n.sym = sym;\n-          sym->refs++;\n-\n-          /* Free the old (local) symbol.  */\n-          old_sym->refs--;\n-          if (old_sym->refs == 0)\n-            gfc_free_symbol (old_sym);\n-        }\n+\t  && !old_sym->attr.contained)\n+\t{\n+\t  /* Replace it with the symbol from the parent namespace.  */\n+\t  st->n.sym = sym;\n+\t  sym->refs++;\n+\n+\t  /* Free the old (local) symbol.  */\n+\t  old_sym->refs--;\n+\t  if (old_sym->refs == 0)\n+\t    gfc_free_symbol (old_sym);\n+\t}\n \n       /* Do the same for any contained procedures.  */\n       gfc_fixup_sibling_symbols (sym, ns->contained);\n@@ -2815,9 +2799,8 @@ parse_contained (int module)\n \t  if (!module)\n \t    {\n \t      if (gfc_get_symbol (gfc_new_block->name, parent_ns, &sym))\n-\t\tgfc_error\n-\t\t  (\"Contained procedure '%s' at %C is already ambiguous\",\n-\t\t   gfc_new_block->name);\n+\t\tgfc_error (\"Contained procedure '%s' at %C is already \"\n+\t\t\t   \"ambiguous\", gfc_new_block->name);\n \t      else\n \t\t{\n \t\t  if (gfc_add_procedure (&sym->attr, PROC_INTERNAL, sym->name,\n@@ -2835,18 +2818,18 @@ parse_contained (int module)\n \n \t      gfc_commit_symbols ();\n \t    }\n-          else\n-            sym = gfc_new_block;\n+\t  else\n+\t    sym = gfc_new_block;\n \n-          /* Mark this as a contained function, so it isn't replaced\n-             by other module functions.  */\n-          sym->attr.contained = 1;\n+\t  /* Mark this as a contained function, so it isn't replaced\n+\t     by other module functions.  */\n+\t  sym->attr.contained = 1;\n \t  sym->attr.referenced = 1;\n \n \t  parse_progunit (ST_NONE);\n \n-          /* Fix up any sibling functions that refer to this one.  */\n-          gfc_fixup_sibling_symbols (sym, gfc_current_ns);\n+\t  /* Fix up any sibling functions that refer to this one.  */\n+\t  gfc_fixup_sibling_symbols (sym, gfc_current_ns);\n \t  /* Or refer to any of its alternate entry points.  */\n \t  for (el = gfc_current_ns->entries; el; el = el->next)\n \t    gfc_fixup_sibling_symbols (el->sym, gfc_current_ns);\n@@ -2857,8 +2840,7 @@ parse_contained (int module)\n \t  pop_state ();\n \t  break;\n \n-        /* These statements are associated with the end of the host\n-           unit.  */\n+\t/* These statements are associated with the end of the host unit.  */\n \tcase ST_END_FUNCTION:\n \tcase ST_END_MODULE:\n \tcase ST_END_PROGRAM:\n@@ -2888,9 +2870,8 @@ parse_contained (int module)\n   pop_state ();\n   if (!contains_statements)\n     /* This is valid in Fortran 2008.  */\n-    gfc_notify_std (GFC_STD_GNU, \"Extension: \"\n-                    \"CONTAINS statement without FUNCTION \"\n-                    \"or SUBROUTINE statement at %C\");\n+    gfc_notify_std (GFC_STD_GNU, \"Extension: CONTAINS statement without \"\n+\t\t    \"FUNCTION or SUBROUTINE statement at %C\");\n }\n \n \n@@ -3028,22 +3009,23 @@ parse_block_data (void)\n     {\n       if (blank_block)\n        gfc_error (\"Blank BLOCK DATA at %C conflicts with \"\n-                  \"prior BLOCK DATA at %L\", &blank_locus);\n+\t\t  \"prior BLOCK DATA at %L\", &blank_locus);\n       else\n        {\n-         blank_block = 1;\n-         blank_locus = gfc_current_locus;\n+\t blank_block = 1;\n+\t blank_locus = gfc_current_locus;\n        }\n     }\n   else\n     {\n       s = gfc_get_gsymbol (gfc_new_block->name);\n-      if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_BLOCK_DATA))\n+      if (s->defined\n+\t  || (s->type != GSYM_UNKNOWN && s->type != GSYM_BLOCK_DATA))\n        global_used(s, NULL);\n       else\n        {\n-         s->type = GSYM_BLOCK_DATA;\n-         s->where = gfc_current_locus;\n+\t s->type = GSYM_BLOCK_DATA;\n+\t s->where = gfc_current_locus;\n \t s->defined = 1;\n        }\n     }\n@@ -3115,7 +3097,8 @@ add_global_procedure (int sub)\n   s = gfc_get_gsymbol(gfc_new_block->name);\n \n   if (s->defined\n-\t|| (s->type != GSYM_UNKNOWN && s->type != (sub ? GSYM_SUBROUTINE : GSYM_FUNCTION)))\n+      || (s->type != GSYM_UNKNOWN\n+\t  && s->type != (sub ? GSYM_SUBROUTINE : GSYM_FUNCTION)))\n     global_used(s, NULL);\n   else\n     {\n@@ -3237,7 +3220,7 @@ gfc_parse_file (void)\n       prog_locus = gfc_current_locus;\n \n       push_state (&s, COMP_PROGRAM, gfc_new_block);\n-      main_program_symbol(gfc_current_ns);\n+      main_program_symbol (gfc_current_ns);\n       parse_progunit (st);\n       break;\n     }"}, {"sha": "a2f70a07f93ded077e8440507ccdc993b8aa0045", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 80, "deletions": 86, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "patch": "@@ -1,5 +1,5 @@\n /* Primary expression subroutines\n-   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006\n+   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -20,7 +20,6 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"flags.h\"\n@@ -179,7 +178,7 @@ match_digits (int signflag, int radix, char *buffer)\n    A sign will be accepted if signflag is set.  */\n \n static match\n-match_integer_constant (gfc_expr ** result, int signflag)\n+match_integer_constant (gfc_expr **result, int signflag)\n {\n   int length, kind;\n   locus old_loc;\n@@ -231,24 +230,23 @@ match_integer_constant (gfc_expr ** result, int signflag)\n /* Match a Hollerith constant.  */\n \n static match\n-match_hollerith_constant (gfc_expr ** result)\n+match_hollerith_constant (gfc_expr **result)\n {\n   locus old_loc;\n-  gfc_expr * e = NULL;\n-  const char * msg;\n-  char * buffer;\n+  gfc_expr *e = NULL;\n+  const char *msg;\n+  char *buffer;\n   int num;\n   int i;  \n \n   old_loc = gfc_current_locus;\n   gfc_gobble_whitespace ();\n \n   if (match_integer_constant (&e, 0) == MATCH_YES\n-\t&& gfc_match_char ('h') == MATCH_YES)\n+      && gfc_match_char ('h') == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_LEGACY,\n-\t\t\"Extension: Hollerith constant at %C\")\n-\t\t== FAILURE)\n+      if (gfc_notify_std (GFC_STD_LEGACY, \"Extension: Hollerith constant \"\n+\t\t\t  \"at %C\") == FAILURE)\n \tgoto cleanup;\n \n       msg = gfc_extract_int (e, &num);\n@@ -259,14 +257,14 @@ match_hollerith_constant (gfc_expr ** result)\n \t}\n       if (num == 0)\n \t{\n-\t  gfc_error (\"Invalid Hollerith constant: %L must contain at least one \"\n-\t\t\t\"character\", &old_loc);\n+\t  gfc_error (\"Invalid Hollerith constant: %L must contain at least \"\n+\t\t     \"one character\", &old_loc);\n \t  goto cleanup;\n \t}\n       if (e->ts.kind != gfc_default_integer_kind)\n \t{\n \t  gfc_error (\"Invalid Hollerith constant: Integer kind at %L \"\n-\t\t\"should be default\", &old_loc);\n+\t\t     \"should be default\", &old_loc);\n \t  goto cleanup;\n \t}\n       else\n@@ -277,9 +275,9 @@ match_hollerith_constant (gfc_expr ** result)\n \t      buffer[i] = gfc_next_char_literal (1);\n \t    }\n \t  gfc_free_expr (e);\n-\t  e = gfc_constant_result (BT_HOLLERITH,\n-\t\tgfc_default_character_kind, &gfc_current_locus);\n-\t  e->value.character.string = gfc_getmem (num+1);\n+\t  e = gfc_constant_result (BT_HOLLERITH, gfc_default_character_kind,\n+\t\t\t\t   &gfc_current_locus);\n+\t  e->value.character.string = gfc_getmem (num + 1);\n \t  memcpy (e->value.character.string, buffer, num);\n \t  e->value.character.string[num] = '\\0';\n \t  e->value.character.length = num;\n@@ -305,7 +303,7 @@ match_hollerith_constant (gfc_expr ** result)\n    and 'a1...'z.  An additional extension is the use of x for z.  */\n \n static match\n-match_boz_constant (gfc_expr ** result)\n+match_boz_constant (gfc_expr **result)\n {\n   int post, radix, delim, length, x_hex, kind;\n   locus old_loc, start_loc;\n@@ -435,7 +433,7 @@ match_boz_constant (gfc_expr ** result)\n    is nonzero.  Allow integer constants if allow_int is true.  */\n \n static match\n-match_real_constant (gfc_expr ** result, int signflag)\n+match_real_constant (gfc_expr **result, int signflag)\n {\n   int kind, c, count, seen_dp, seen_digits, exp_char;\n   locus old_loc, temp_loc;\n@@ -472,7 +470,8 @@ match_real_constant (gfc_expr ** result, int signflag)\n \t  if (seen_dp)\n \t    goto done;\n \n-\t  /* Check to see if \".\" goes with a following operator like \".eq.\".  */\n+\t  /* Check to see if \".\" goes with a following operator like \n+\t     \".eq.\".  */\n \t  temp_loc = gfc_current_locus;\n \t  c = gfc_next_char ();\n \n@@ -500,8 +499,7 @@ match_real_constant (gfc_expr ** result, int signflag)\n       break;\n     }\n \n-  if (!seen_digits\n-      || (c != 'e' && c != 'd' && c != 'q'))\n+  if (!seen_digits || (c != 'e' && c != 'd' && c != 'q'))\n     goto done;\n   exp_char = c;\n \n@@ -573,8 +571,8 @@ match_real_constant (gfc_expr ** result, int signflag)\n     case 'd':\n       if (kind != -2)\n \t{\n-\t  gfc_error\n-\t    (\"Real number at %C has a 'd' exponent and an explicit kind\");\n+\t  gfc_error (\"Real number at %C has a 'd' exponent and an explicit \"\n+\t\t     \"kind\");\n \t  goto cleanup;\n \t}\n       kind = gfc_default_double_kind;\n@@ -605,7 +603,7 @@ match_real_constant (gfc_expr ** result, int signflag)\n \n     case ARITH_UNDERFLOW:\n       if (gfc_option.warn_underflow)\n-        gfc_warning (\"Real constant underflows its kind at %C\");\n+\tgfc_warning (\"Real constant underflows its kind at %C\");\n       mpfr_set_ui (e->value.real, 0, GFC_RND_MODE);\n       break;\n \n@@ -625,7 +623,7 @@ match_real_constant (gfc_expr ** result, int signflag)\n /* Match a substring reference.  */\n \n static match\n-match_substring (gfc_charlen * cl, int init, gfc_ref ** result)\n+match_substring (gfc_charlen *cl, int init, gfc_ref **result)\n {\n   gfc_expr *start, *end;\n   locus old_loc;\n@@ -848,7 +846,7 @@ match_charkind_name (char *name)\n    delimiter.  Using match_kind_param() generates errors too quickly.  */\n \n static match\n-match_string_constant (gfc_expr ** result)\n+match_string_constant (gfc_expr **result)\n {\n   char *p, name[GFC_MAX_SYMBOL_LEN + 1];\n   int i, c, kind, length, delimiter;\n@@ -1002,7 +1000,7 @@ match_string_constant (gfc_expr ** result)\n /* Match a .true. or .false.  */\n \n static match\n-match_logical_constant (gfc_expr ** result)\n+match_logical_constant (gfc_expr **result)\n {\n   static mstring logical_ops[] = {\n     minit (\".false.\", 0),\n@@ -1043,7 +1041,7 @@ match_logical_constant (gfc_expr ** result)\n    symbolic constant.  */\n \n static match\n-match_sym_complex_part (gfc_expr ** result)\n+match_sym_complex_part (gfc_expr **result)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n@@ -1101,7 +1099,7 @@ match_sym_complex_part (gfc_expr ** result)\n       gfc_internal_error (\"gfc_match_sym_complex_part(): Bad type\");\n     }\n \n-  *result = e;\t\t\t/* e is a scalar, real, constant expression */\n+  *result = e;\t\t/* e is a scalar, real, constant expression.  */\n   return MATCH_YES;\n \n error:\n@@ -1113,7 +1111,7 @@ match_sym_complex_part (gfc_expr ** result)\n /* Match a real or imaginary part of a complex number.  */\n \n static match\n-match_complex_part (gfc_expr ** result)\n+match_complex_part (gfc_expr **result)\n {\n   match m;\n \n@@ -1132,7 +1130,7 @@ match_complex_part (gfc_expr ** result)\n /* Try to match a complex constant.  */\n \n static match\n-match_complex_constant (gfc_expr ** result)\n+match_complex_constant (gfc_expr **result)\n {\n   gfc_expr *e, *real, *imag;\n   gfc_error_buf old_error;\n@@ -1249,7 +1247,7 @@ match_complex_constant (gfc_expr ** result)\n    match, zero for no match.  */\n \n match\n-gfc_match_literal_constant (gfc_expr ** result, int signflag)\n+gfc_match_literal_constant (gfc_expr **result, int signflag)\n {\n   match m;\n \n@@ -1293,7 +1291,7 @@ gfc_match_literal_constant (gfc_expr ** result, int signflag)\n    fixing things later during resolution.  */\n \n static match\n-match_actual_arg (gfc_expr ** result)\n+match_actual_arg (gfc_expr **result)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symtree *symtree;\n@@ -1325,18 +1323,18 @@ match_actual_arg (gfc_expr ** result)\n       /* Handle error elsewhere.  */\n \n       /* Eliminate a couple of common cases where we know we don't\n-         have a function argument.  */\n+\t have a function argument.  */\n       if (symtree == NULL)\n-        {\n+\t{\n \t  gfc_get_sym_tree (name, NULL, &symtree);\n-          gfc_set_sym_referenced (symtree->n.sym);\n-        }\n+\t  gfc_set_sym_referenced (symtree->n.sym);\n+\t}\n       else\n \t{\n-          gfc_symbol *sym;\n+\t  gfc_symbol *sym;\n \n-          sym = symtree->n.sym;\n-          gfc_set_sym_referenced (sym);\n+\t  sym = symtree->n.sym;\n+\t  gfc_set_sym_referenced (sym);\n \t  if (sym->attr.flavor != FL_PROCEDURE\n \t      && sym->attr.flavor != FL_UNKNOWN)\n \t    break;\n@@ -1384,7 +1382,7 @@ match_actual_arg (gfc_expr ** result)\n /* Match a keyword argument.  */\n \n static match\n-match_keyword_arg (gfc_actual_arglist * actual, gfc_actual_arglist * base)\n+match_keyword_arg (gfc_actual_arglist *actual, gfc_actual_arglist *base)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_actual_arglist *a;\n@@ -1413,9 +1411,8 @@ match_keyword_arg (gfc_actual_arglist * actual, gfc_actual_arglist * base)\n       for (a = base; a; a = a->next)\n \tif (a->name != NULL && strcmp (a->name, name) == 0)\n \t  {\n-\t    gfc_error\n-\t      (\"Keyword '%s' at %C has already appeared in the current \"\n-\t       \"argument list\", name);\n+\t    gfc_error (\"Keyword '%s' at %C has already appeared in the \"\n+\t\t       \"current argument list\", name);\n \t    return MATCH_ERROR;\n \t  }\n     }\n@@ -1455,19 +1452,19 @@ match_arg_list_function (gfc_actual_arglist *result)\n       switch (name[0])\n \t{\n \tcase 'l':\n-\t  if (strncmp(name, \"loc\", 3) == 0)\n+\t  if (strncmp (name, \"loc\", 3) == 0)\n \t    {\n \t      result->name = \"%LOC\";\n \t      break;\n \t    }\n \tcase 'r':\n-\t  if (strncmp(name, \"ref\", 3) == 0)\n+\t  if (strncmp (name, \"ref\", 3) == 0)\n \t    {\n \t      result->name = \"%REF\";\n \t      break;\n \t    }\n \tcase 'v':\n-\t  if (strncmp(name, \"val\", 3) == 0)\n+\t  if (strncmp (name, \"val\", 3) == 0)\n \t    {\n \t      result->name = \"%VAL\";\n \t      break;\n@@ -1511,7 +1508,7 @@ match_arg_list_function (gfc_actual_arglist *result)\n    we're matching the argument list of a subroutine.  */\n \n match\n-gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist ** argp)\n+gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist **argp)\n {\n   gfc_actual_arglist *head, *tail;\n   int seen_keyword;\n@@ -1554,7 +1551,7 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist ** argp)\n \t}\n \n       /* After the first keyword argument is seen, the following\n-         arguments must also have keywords.  */\n+\t arguments must also have keywords.  */\n       if (seen_keyword)\n \t{\n \t  m = match_keyword_arg (tail, head);\n@@ -1563,8 +1560,7 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist ** argp)\n \t    goto cleanup;\n \t  if (m == MATCH_NO)\n \t    {\n-\t      gfc_error\n-\t\t(\"Missing keyword name in actual argument list at %C\");\n+\t      gfc_error (\"Missing keyword name in actual argument list at %C\");\n \t      goto cleanup;\n \t    }\n \n@@ -1623,9 +1619,8 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist ** argp)\n    element.  */\n \n static gfc_ref *\n-extend_ref (gfc_expr * primary, gfc_ref * tail)\n+extend_ref (gfc_expr *primary, gfc_ref *tail)\n {\n-\n   if (primary->ref == NULL)\n     primary->ref = tail = gfc_get_ref ();\n   else\n@@ -1646,7 +1641,7 @@ extend_ref (gfc_expr * primary, gfc_ref * tail)\n    statement.  */\n \n static match\n-match_varspec (gfc_expr * primary, int equiv_flag)\n+match_varspec (gfc_expr *primary, int equiv_flag)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_ref *substring, *tail;\n@@ -1656,13 +1651,11 @@ match_varspec (gfc_expr * primary, int equiv_flag)\n \n   tail = NULL;\n \n-  if ((equiv_flag && gfc_peek_char () == '(')\n-      || sym->attr.dimension)\n+  if ((equiv_flag && gfc_peek_char () == '(') || sym->attr.dimension)\n     {\n       /* In EQUIVALENCE, we don't know yet whether we are seeing\n \t an array, character variable or array of character\n-\t variables.  We'll leave the decision till resolve\n-\t time.  */\n+\t variables.  We'll leave the decision till resolve time.  */\n       tail = extend_ref (primary, tail);\n       tail->type = REF_ARRAY;\n \n@@ -1734,8 +1727,8 @@ match_varspec (gfc_expr * primary, int equiv_flag)\n     {\n       if (gfc_get_default_type (sym, sym->ns)->type == BT_CHARACTER)\n        {\n-         gfc_set_default_type (sym, 0, sym->ns);\n-         primary->ts = sym->ts;\n+\t gfc_set_default_type (sym, 0, sym->ns);\n+\t primary->ts = sym->ts;\n        }\n     }\n \n@@ -1787,7 +1780,7 @@ match_varspec (gfc_expr * primary, int equiv_flag)\n    We can have at most one full array reference.  */\n \n symbol_attribute\n-gfc_variable_attr (gfc_expr * expr, gfc_typespec * ts)\n+gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n {\n   int dimension, pointer, allocatable, target;\n   symbol_attribute attr;\n@@ -1865,7 +1858,7 @@ gfc_variable_attr (gfc_expr * expr, gfc_typespec * ts)\n /* Return the attribute from a general expression.  */\n \n symbol_attribute\n-gfc_expr_attr (gfc_expr * e)\n+gfc_expr_attr (gfc_expr *e)\n {\n   symbol_attribute attr;\n \n@@ -1882,7 +1875,7 @@ gfc_expr_attr (gfc_expr * e)\n \tattr = e->value.function.esym->result->attr;\n \n       /* TODO: NULL() returns pointers.  May have to take care of this\n-         here.  */\n+\t here.  */\n \n       break;\n \n@@ -1899,7 +1892,7 @@ gfc_expr_attr (gfc_expr * e)\n    seen.  */\n \n match\n-gfc_match_structure_constructor (gfc_symbol * sym, gfc_expr ** result)\n+gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n {\n   gfc_constructor *head, *tail;\n   gfc_component *comp;\n@@ -1936,8 +1929,7 @@ gfc_match_structure_constructor (gfc_symbol * sym, gfc_expr ** result)\n \t{\n \t  if (comp->next == NULL)\n \t    {\n-\t      gfc_error\n-\t\t(\"Too many components in structure constructor at %C\");\n+\t      gfc_error (\"Too many components in structure constructor at %C\");\n \t      goto cleanup;\n \t    }\n \n@@ -1982,7 +1974,7 @@ gfc_match_structure_constructor (gfc_symbol * sym, gfc_expr ** result)\n    array reference, argument list of a function, etc.  */\n \n match\n-gfc_match_rvalue (gfc_expr ** result)\n+gfc_match_rvalue (gfc_expr **result)\n {\n   gfc_actual_arglist *actual_arglist;\n   char name[GFC_MAX_SYMBOL_LEN + 1], argname[GFC_MAX_SYMBOL_LEN + 1];\n@@ -2020,8 +2012,8 @@ gfc_match_rvalue (gfc_expr ** result)\n       /* See if this is a directly recursive function call.  */\n       gfc_gobble_whitespace ();\n       if (sym->attr.recursive\n-\t    && gfc_peek_char () == '('\n-\t    && gfc_current_ns->proc_name == sym)\n+\t  && gfc_peek_char () == '('\n+\t  && gfc_current_ns->proc_name == sym)\n \t{\n \t  if (!sym->attr.dimension)\n \t    goto function0;\n@@ -2093,7 +2085,7 @@ gfc_match_rvalue (gfc_expr ** result)\n       if (sym == NULL)\n \tm = MATCH_ERROR;\n       else\n-        m = gfc_match_structure_constructor (sym, &e);\n+\tm = gfc_match_structure_constructor (sym, &e);\n       break;\n \n     /* If we're here, then the name is known to be the name of a\n@@ -2108,9 +2100,9 @@ gfc_match_rvalue (gfc_expr ** result)\n \t}\n \n       /* At this point, the name has to be a non-statement function.\n-         If the name is the same as the current function being\n-         compiled, then we have a variable reference (to the function\n-         result) if the name is non-recursive.  */\n+\t If the name is the same as the current function being\n+\t compiled, then we have a variable reference (to the function\n+\t result) if the name is non-recursive.  */\n \n       st = gfc_enclosing_unit (NULL);\n \n@@ -2176,16 +2168,16 @@ gfc_match_rvalue (gfc_expr ** result)\n     case FL_UNKNOWN:\n \n       /* Special case for derived type variables that get their types\n-         via an IMPLICIT statement.  This can't wait for the\n-         resolution phase.  */\n+\t via an IMPLICIT statement.  This can't wait for the\n+\t resolution phase.  */\n \n       if (gfc_peek_char () == '%'\n \t  && sym->ts.type == BT_UNKNOWN\n \t  && gfc_get_default_type (sym, sym->ns)->type == BT_DERIVED)\n \tgfc_set_default_type (sym, 0, sym->ns);\n \n       /* If the symbol has a dimension attribute, the expression is a\n-         variable.  */\n+\t variable.  */\n \n       if (sym->attr.dimension)\n \t{\n@@ -2204,8 +2196,8 @@ gfc_match_rvalue (gfc_expr ** result)\n \t}\n \n       /* Name is not an array, so we peek to see if a '(' implies a\n-         function call or a substring reference.  Otherwise the\n-         variable is just a scalar.  */\n+\t function call or a substring reference.  Otherwise the\n+\t variable is just a scalar.  */\n \n       gfc_gobble_whitespace ();\n       if (gfc_peek_char () != '(')\n@@ -2310,7 +2302,7 @@ gfc_match_rvalue (gfc_expr ** result)\n \t}\n \n       /* If our new function returns a character, array or structure\n-         type, it might have subsequent references.  */\n+\t type, it might have subsequent references.  */\n \n       m = match_varspec (e, 0);\n       if (m == MATCH_NO)\n@@ -2357,7 +2349,7 @@ gfc_match_rvalue (gfc_expr ** result)\n    match of the symbol to the local scope.  */\n \n static match\n-match_variable (gfc_expr ** result, int equiv_flag, int host_flag)\n+match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n {\n   gfc_symbol *sym;\n   gfc_symtree *st;\n@@ -2387,10 +2379,10 @@ match_variable (gfc_expr ** result, int equiv_flag, int host_flag)\n     {\n     case FL_VARIABLE:\n       if (sym->attr.protected && sym->attr.use_assoc)\n-        {\n+\t{\n \t  gfc_error (\"Assigning to PROTECTED variable at %C\");\n-          return MATCH_ERROR;\n-        }\n+\t  return MATCH_ERROR;\n+\t}\n       break;\n \n     case FL_UNKNOWN:\n@@ -2464,14 +2456,16 @@ match_variable (gfc_expr ** result, int equiv_flag, int host_flag)\n   return MATCH_YES;\n }\n \n+\n match\n-gfc_match_variable (gfc_expr ** result, int equiv_flag)\n+gfc_match_variable (gfc_expr **result, int equiv_flag)\n {\n   return match_variable (result, equiv_flag, 1);\n }\n \n+\n match\n-gfc_match_equiv_variable (gfc_expr ** result)\n+gfc_match_equiv_variable (gfc_expr **result)\n {\n   return match_variable (result, 1, 0);\n }"}, {"sha": "526be48aa05c73260627fe7449e9007a773bf0f6", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 771, "deletions": 797, "changes": 1568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c"}, {"sha": "95d2e81da3b3235010f6835d72bd6c5e0f584244", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "patch": "@@ -113,7 +113,6 @@ gfc_scanner_done_1 (void)\n       gfc_free(file_head);\n       file_head = f;    \n     }\n-\n }\n \n \n@@ -248,12 +247,12 @@ gfc_open_intrinsic_module (const char *name)\n   return open_included_file (name, intrinsic_modules_dirs, true);\n }\n \n+\n /* Test to see if we're at the end of the main source file.  */\n \n int\n gfc_at_end (void)\n {\n-\n   return end_flag;\n }\n \n@@ -263,7 +262,6 @@ gfc_at_end (void)\n int\n gfc_at_eof (void)\n {\n-\n   if (gfc_at_end ())\n     return 1;\n \n@@ -294,7 +292,6 @@ gfc_at_bol (void)\n int\n gfc_at_eol (void)\n {\n-\n   if (gfc_at_eof ())\n     return 1;\n \n@@ -318,7 +315,7 @@ gfc_advance_line (void)\n \n   gfc_current_locus.lb = gfc_current_locus.lb->next;\n \n-  if (gfc_current_locus.lb != NULL)         \n+  if (gfc_current_locus.lb != NULL)\t \n     gfc_current_locus.nextc = gfc_current_locus.lb->line;\n   else \n     {\n@@ -355,6 +352,7 @@ next_char (void)\n   return c;\n }\n \n+\n /* Skip a comment.  When we come here the parse pointer is positioned\n    immediately after the comment character.  If we ever implement\n    compiler directives withing comments, here is where we parse the\n@@ -714,10 +712,9 @@ gfc_next_char_literal (int in_string)\n \t{\n \t  if (++continue_count == gfc_option.max_continue_free)\n \t    {\n-\t      if (gfc_notification_std (GFC_STD_GNU)\n-\t\t  || pedantic)\n-\t\tgfc_warning (\"Limit of %d continuations exceeded in statement at %C\",\n-\t\t\t      gfc_option.max_continue_free);\n+\t      if (gfc_notification_std (GFC_STD_GNU) || pedantic)\n+\t\tgfc_warning (\"Limit of %d continuations exceeded in \"\n+\t\t\t     \"statement at %C\", gfc_option.max_continue_free);\n \t    }\n \t}\n       continue_line = gfc_current_locus.lb->linenum;\n@@ -761,7 +758,8 @@ gfc_next_char_literal (int in_string)\n \t  if (in_string)\n \t    {\n \t      if (gfc_option.warn_ampersand)\n-\t\tgfc_warning_now (\"Missing '&' in continued character constant at %C\");\n+\t\tgfc_warning_now (\"Missing '&' in continued character \"\n+\t\t\t\t \"constant at %C\");\n \t      gfc_current_locus.nextc--;\n \t    }\n \t  /* Both !$omp and !$ -fopenmp continuation lines have & on the\n@@ -835,10 +833,10 @@ gfc_next_char_literal (int in_string)\n \t{\n \t  if (++continue_count == gfc_option.max_continue_fixed)\n \t    {\n-\t      if (gfc_notification_std (GFC_STD_GNU)\n-\t\t  || pedantic)\n-\t\tgfc_warning (\"Limit of %d continuations exceeded in statement at %C\",\n-\t\t\t      gfc_option.max_continue_fixed);\n+\t      if (gfc_notification_std (GFC_STD_GNU) || pedantic)\n+\t\tgfc_warning (\"Limit of %d continuations exceeded in \"\n+\t\t\t     \"statement at %C\",\n+\t\t\t     gfc_option.max_continue_fixed);\n \t    }\n \t}\n \n@@ -997,7 +995,7 @@ gfc_gobble_whitespace (void)\n \t parts of gfortran.  */\n \n static int\n-load_line (FILE * input, char **pbuf, int *pbuflen)\n+load_line (FILE *input, char **pbuf, int *pbuflen)\n {\n   static int linenum = 0, current_line = 1;\n   int c, maxlen, i, preprocessor_flag, buflen = *pbuflen;\n@@ -1052,11 +1050,11 @@ load_line (FILE * input, char **pbuf, int *pbuflen)\n \t\t&& !seen_printable && seen_ampersand)\n \t    {\n \t      if (pedantic)\n-\t\tgfc_error_now\n-\t\t  (\"'&' not allowed by itself in line %d\", current_line);\n+\t\tgfc_error_now (\"'&' not allowed by itself in line %d\",\n+\t\t\t       current_line);\n \t      else\n-\t\tgfc_warning_now\n-\t\t  (\"'&' not allowed by itself in line %d\", current_line);\n+\t\tgfc_warning_now (\"'&' not allowed by itself in line %d\",\n+\t\t\t\t current_line);\n \t    }\n \t  break;\n \t}\n@@ -1084,11 +1082,11 @@ load_line (FILE * input, char **pbuf, int *pbuflen)\n \t    && c == '!' && !seen_printable && seen_ampersand)\n \t{\n \t  if (pedantic)\n-\t    gfc_error_now (\n-\t      \"'&' not allowed by itself with comment in line %d\", current_line);\n+\t    gfc_error_now (\"'&' not allowed by itself with comment in \"\n+\t\t\t   \"line %d\", current_line);\n \t  else\n-\t    gfc_warning_now (\n-\t      \"'&' not allowed by itself with comment in line %d\", current_line);\n+\t    gfc_warning_now (\"'&' not allowed by itself with comment in \"\n+\t\t\t     \"line %d\", current_line);\n \t  seen_printable = 1;\n \t}\n \n@@ -1103,8 +1101,8 @@ load_line (FILE * input, char **pbuf, int *pbuflen)\n \t      && current_line != linenum)\n \t    {\n \t      linenum = current_line;\n-\t      gfc_warning_now (\n-\t\t\"Nonconforming tab character in column 1 of line %d\", linenum);\n+\t      gfc_warning_now (\"Nonconforming tab character in column 1 \"\n+\t\t\t       \"of line %d\", linenum);\n \t    }\n \n \t  while (i <= 6)\n@@ -1127,7 +1125,7 @@ load_line (FILE * input, char **pbuf, int *pbuflen)\n \t\toverlong line.  */\n \t      buflen = buflen * 2;\n \t      *pbuf = xrealloc (*pbuf, buflen + 1);\n-\t      buffer = (*pbuf)+i;\n+\t      buffer = (*pbuf) + i;\n \t    }\n \t}\n       else if (i >= maxlen)\n@@ -1234,10 +1232,10 @@ preprocessor_line (char *c)\n   /* Make filename end at quote.  */\n   unescape = 0;\n   escaped = false;\n-  while (*c && ! (! escaped && *c == '\"'))\n+  while (*c && ! (!escaped && *c == '\"'))\n     {\n       if (escaped)\n-        escaped = false;\n+\tescaped = false;\n       else if (*c == '\\\\')\n \t{\n \t  escaped = true;\n@@ -1407,6 +1405,7 @@ include_line (char *line)\n   return true;\n }\n \n+\n /* Load a file into memory by calling load_line until the file ends.  */\n \n static try\n@@ -1582,7 +1581,7 @@ unescape_filename (const char *ptr)\n       ++p;\n     }\n \n-  if (! *p || p[1])\n+  if (!*p || p[1])\n     return NULL;\n \n   /* Undo effects of cpp_quote_string.  */"}, {"sha": "612bfe3072d543488bb34d1bcf04138ca23208aa", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 234, "deletions": 265, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "patch": "@@ -93,28 +93,30 @@ static int xascii_table[256];\n    node, otherwise returns &gfc_bad_expr and frees the node.  */\n \n static gfc_expr *\n-range_check (gfc_expr * result, const char *name)\n+range_check (gfc_expr *result, const char *name)\n {\n-\n   switch (gfc_range_check (result))\n     {\n       case ARITH_OK:\n \treturn result;\n  \n       case ARITH_OVERFLOW:\n-\tgfc_error (\"Result of %s overflows its kind at %L\", name, &result->where);\n+\tgfc_error (\"Result of %s overflows its kind at %L\", name,\n+\t\t   &result->where);\n \tbreak;\n \n       case ARITH_UNDERFLOW:\n-\tgfc_error (\"Result of %s underflows its kind at %L\", name, &result->where);\n+\tgfc_error (\"Result of %s underflows its kind at %L\", name,\n+\t\t   &result->where);\n \tbreak;\n \n       case ARITH_NAN:\n \tgfc_error (\"Result of %s is NaN at %L\", name, &result->where);\n \tbreak;\n \n       default:\n-\tgfc_error (\"Result of %s gives range error for its kind at %L\", name, &result->where);\n+\tgfc_error (\"Result of %s gives range error for its kind at %L\", name,\n+\t\t   &result->where);\n \tbreak;\n     }\n \n@@ -127,7 +129,7 @@ range_check (gfc_expr * result, const char *name)\n    kind parameter.  Returns the kind, -1 if something went wrong.  */\n \n static int\n-get_kind (bt type, gfc_expr * k, const char *name, int default_kind)\n+get_kind (bt type, gfc_expr *k, const char *name, int default_kind)\n {\n   int kind;\n \n@@ -190,7 +192,6 @@ convert_mpz_to_unsigned (mpz_t x, int bitsize)\n    If the bitsize-1 bit is set, this is taken as a sign bit and\n    the number is converted to the corresponding negative number.  */\n \n-\n static void\n convert_mpz_to_signed (mpz_t x, int bitsize)\n {\n@@ -206,9 +207,9 @@ convert_mpz_to_signed (mpz_t x, int bitsize)\n       mpz_sub_ui (mask, mask, 1);\n \n       /* We negate the number by hand, zeroing the high bits, that is\n-        make it the corresponding positive number, and then have it\n-        negated by GMP, giving the correct representation of the\n-        negative number.  */\n+\t make it the corresponding positive number, and then have it\n+\t negated by GMP, giving the correct representation of the\n+\t negative number.  */\n       mpz_com (x, x);\n       mpz_add_ui (x, x, 1);\n       mpz_and (x, x, mask);\n@@ -223,7 +224,7 @@ convert_mpz_to_signed (mpz_t x, int bitsize)\n /********************** Simplification functions *****************************/\n \n gfc_expr *\n-gfc_simplify_abs (gfc_expr * e)\n+gfc_simplify_abs (gfc_expr *e)\n {\n   gfc_expr *result;\n \n@@ -267,7 +268,7 @@ gfc_simplify_abs (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_achar (gfc_expr * e)\n+gfc_simplify_achar (gfc_expr *e)\n {\n   gfc_expr *result;\n   int index;\n@@ -297,14 +298,15 @@ gfc_simplify_achar (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_acos (gfc_expr * x)\n+gfc_simplify_acos (gfc_expr *x)\n {\n   gfc_expr *result;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (mpfr_cmp_si (x->value.real, 1) > 0 || mpfr_cmp_si (x->value.real, -1) < 0)\n+  if (mpfr_cmp_si (x->value.real, 1) > 0\n+      || mpfr_cmp_si (x->value.real, -1) < 0)\n     {\n       gfc_error (\"Argument of ACOS at %L must be between -1 and 1\",\n \t\t &x->where);\n@@ -319,7 +321,7 @@ gfc_simplify_acos (gfc_expr * x)\n }\n \n gfc_expr *\n-gfc_simplify_acosh (gfc_expr * x)\n+gfc_simplify_acosh (gfc_expr *x)\n {\n   gfc_expr *result;\n \n@@ -341,7 +343,7 @@ gfc_simplify_acosh (gfc_expr * x)\n }\n \n gfc_expr *\n-gfc_simplify_adjustl (gfc_expr * e)\n+gfc_simplify_adjustl (gfc_expr *e)\n {\n   gfc_expr *result;\n   int count, i, len;\n@@ -366,15 +368,10 @@ gfc_simplify_adjustl (gfc_expr * e)\n     }\n \n   for (i = 0; i < len - count; ++i)\n-    {\n-      result->value.character.string[i] =\n-\te->value.character.string[count + i];\n-    }\n+    result->value.character.string[i] = e->value.character.string[count + i];\n \n   for (i = len - count; i < len; ++i)\n-    {\n-      result->value.character.string[i] = ' ';\n-    }\n+    result->value.character.string[i] = ' ';\n \n   result->value.character.string[len] = '\\0';\t/* For debugger */\n \n@@ -383,7 +380,7 @@ gfc_simplify_adjustl (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_adjustr (gfc_expr * e)\n+gfc_simplify_adjustr (gfc_expr *e)\n {\n   gfc_expr *result;\n   int count, i, len;\n@@ -408,15 +405,10 @@ gfc_simplify_adjustr (gfc_expr * e)\n     }\n \n   for (i = 0; i < count; ++i)\n-    {\n-      result->value.character.string[i] = ' ';\n-    }\n+    result->value.character.string[i] = ' ';\n \n   for (i = count; i < len; ++i)\n-    {\n-      result->value.character.string[i] =\n-\te->value.character.string[i - count];\n-    }\n+    result->value.character.string[i] = e->value.character.string[i - count];\n \n   result->value.character.string[len] = '\\0';\t/* For debugger */\n \n@@ -425,9 +417,8 @@ gfc_simplify_adjustr (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_aimag (gfc_expr * e)\n+gfc_simplify_aimag (gfc_expr *e)\n {\n-\n   gfc_expr *result;\n \n   if (e->expr_type != EXPR_CONSTANT)\n@@ -441,7 +432,7 @@ gfc_simplify_aimag (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_aint (gfc_expr * e, gfc_expr * k)\n+gfc_simplify_aint (gfc_expr *e, gfc_expr *k)\n {\n   gfc_expr *rtrunc, *result;\n   int kind;\n@@ -465,7 +456,7 @@ gfc_simplify_aint (gfc_expr * e, gfc_expr * k)\n \n \n gfc_expr *\n-gfc_simplify_dint (gfc_expr * e)\n+gfc_simplify_dint (gfc_expr *e)\n {\n   gfc_expr *rtrunc, *result;\n \n@@ -484,7 +475,7 @@ gfc_simplify_dint (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_anint (gfc_expr * e, gfc_expr * k)\n+gfc_simplify_anint (gfc_expr *e, gfc_expr *k)\n {\n   gfc_expr *result;\n   int kind;\n@@ -505,7 +496,7 @@ gfc_simplify_anint (gfc_expr * e, gfc_expr * k)\n \n \n gfc_expr *\n-gfc_simplify_and (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_and (gfc_expr *x, gfc_expr *y)\n {\n   gfc_expr *result;\n   int kind;\n@@ -530,7 +521,7 @@ gfc_simplify_and (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_dnint (gfc_expr * e)\n+gfc_simplify_dnint (gfc_expr *e)\n {\n   gfc_expr *result;\n \n@@ -546,14 +537,15 @@ gfc_simplify_dnint (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_asin (gfc_expr * x)\n+gfc_simplify_asin (gfc_expr *x)\n {\n   gfc_expr *result;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (mpfr_cmp_si (x->value.real, 1) > 0 || mpfr_cmp_si (x->value.real, -1) < 0)\n+  if (mpfr_cmp_si (x->value.real, 1) > 0\n+      || mpfr_cmp_si (x->value.real, -1) < 0)\n     {\n       gfc_error (\"Argument of ASIN at %L must be between -1 and 1\",\n \t\t &x->where);\n@@ -562,14 +554,14 @@ gfc_simplify_asin (gfc_expr * x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  mpfr_asin(result->value.real, x->value.real, GFC_RND_MODE);\n+  mpfr_asin (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"ASIN\");\n }\n \n \n gfc_expr *\n-gfc_simplify_asinh (gfc_expr * x)\n+gfc_simplify_asinh (gfc_expr *x)\n {\n   gfc_expr *result;\n \n@@ -578,14 +570,14 @@ gfc_simplify_asinh (gfc_expr * x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  mpfr_asinh(result->value.real, x->value.real, GFC_RND_MODE);\n+  mpfr_asinh (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"ASINH\");\n }\n \n \n gfc_expr *\n-gfc_simplify_atan (gfc_expr * x)\n+gfc_simplify_atan (gfc_expr *x)\n {\n   gfc_expr *result;\n \n@@ -594,22 +586,22 @@ gfc_simplify_atan (gfc_expr * x)\n     \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  mpfr_atan(result->value.real, x->value.real, GFC_RND_MODE);\n+  mpfr_atan (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"ATAN\");\n }\n \n \n gfc_expr *\n-gfc_simplify_atanh (gfc_expr * x)\n+gfc_simplify_atanh (gfc_expr *x)\n {\n   gfc_expr *result;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (mpfr_cmp_si (x->value.real, 1) >= 0 ||\n-      mpfr_cmp_si (x->value.real, -1) <= 0)\n+  if (mpfr_cmp_si (x->value.real, 1) >= 0\n+      || mpfr_cmp_si (x->value.real, -1) <= 0)\n     {\n       gfc_error (\"Argument of ATANH at %L must be inside the range -1 to 1\",\n \t\t &x->where);\n@@ -618,14 +610,14 @@ gfc_simplify_atanh (gfc_expr * x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  mpfr_atanh(result->value.real, x->value.real, GFC_RND_MODE);\n+  mpfr_atanh (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"ATANH\");\n }\n \n \n gfc_expr *\n-gfc_simplify_atan2 (gfc_expr * y, gfc_expr * x)\n+gfc_simplify_atan2 (gfc_expr *y, gfc_expr *x)\n {\n   gfc_expr *result;\n \n@@ -636,9 +628,8 @@ gfc_simplify_atan2 (gfc_expr * y, gfc_expr * x)\n \n   if (mpfr_sgn (y->value.real) == 0 && mpfr_sgn (x->value.real) == 0)\n     {\n-      gfc_error\n-\t(\"If first argument of ATAN2 %L is zero, then the second argument \"\n-\t  \"must not be zero\", &x->where);\n+      gfc_error (\"If first argument of ATAN2 %L is zero, then the \"\n+\t\t \"second argument must not be zero\", &x->where);\n       gfc_free_expr (result);\n       return &gfc_bad_expr;\n     }\n@@ -650,7 +641,7 @@ gfc_simplify_atan2 (gfc_expr * y, gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_bit_size (gfc_expr * e)\n+gfc_simplify_bit_size (gfc_expr *e)\n {\n   gfc_expr *result;\n   int i;\n@@ -664,7 +655,7 @@ gfc_simplify_bit_size (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_btest (gfc_expr * e, gfc_expr * bit)\n+gfc_simplify_btest (gfc_expr *e, gfc_expr *bit)\n {\n   int b;\n \n@@ -679,7 +670,7 @@ gfc_simplify_btest (gfc_expr * e, gfc_expr * bit)\n \n \n gfc_expr *\n-gfc_simplify_ceiling (gfc_expr * e, gfc_expr * k)\n+gfc_simplify_ceiling (gfc_expr *e, gfc_expr *k)\n {\n   gfc_expr *ceil, *result;\n   int kind;\n@@ -696,7 +687,7 @@ gfc_simplify_ceiling (gfc_expr * e, gfc_expr * k)\n   ceil = gfc_copy_expr (e);\n \n   mpfr_ceil (ceil->value.real, e->value.real);\n-  gfc_mpfr_to_mpz(result->value.integer, ceil->value.real);\n+  gfc_mpfr_to_mpz (result->value.integer, ceil->value.real);\n \n   gfc_free_expr (ceil);\n \n@@ -705,7 +696,7 @@ gfc_simplify_ceiling (gfc_expr * e, gfc_expr * k)\n \n \n gfc_expr *\n-gfc_simplify_char (gfc_expr * e, gfc_expr * k)\n+gfc_simplify_char (gfc_expr *e, gfc_expr *k)\n {\n   gfc_expr *result;\n   int c, kind;\n@@ -738,7 +729,7 @@ gfc_simplify_char (gfc_expr * e, gfc_expr * k)\n /* Common subroutine for simplifying CMPLX and DCMPLX.  */\n \n static gfc_expr *\n-simplify_cmplx (const char *name, gfc_expr * x, gfc_expr * y, int kind)\n+simplify_cmplx (const char *name, gfc_expr *x, gfc_expr *y, int kind)\n {\n   gfc_expr *result;\n \n@@ -787,7 +778,7 @@ simplify_cmplx (const char *name, gfc_expr * x, gfc_expr * y, int kind)\n \n \n gfc_expr *\n-gfc_simplify_cmplx (gfc_expr * x, gfc_expr * y, gfc_expr * k)\n+gfc_simplify_cmplx (gfc_expr *x, gfc_expr *y, gfc_expr *k)\n {\n   int kind;\n \n@@ -804,7 +795,7 @@ gfc_simplify_cmplx (gfc_expr * x, gfc_expr * y, gfc_expr * k)\n \n \n gfc_expr *\n-gfc_simplify_complex (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_complex (gfc_expr *x, gfc_expr *y)\n {\n   int kind;\n \n@@ -832,7 +823,7 @@ gfc_simplify_complex (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_conjg (gfc_expr * e)\n+gfc_simplify_conjg (gfc_expr *e)\n {\n   gfc_expr *result;\n \n@@ -847,7 +838,7 @@ gfc_simplify_conjg (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_cos (gfc_expr * x)\n+gfc_simplify_cos (gfc_expr *x)\n {\n   gfc_expr *result;\n   mpfr_t xp, xq;\n@@ -869,7 +860,7 @@ gfc_simplify_cos (gfc_expr * x)\n \n       mpfr_cos  (xp, x->value.complex.r, GFC_RND_MODE);\n       mpfr_cosh (xq, x->value.complex.i, GFC_RND_MODE);\n-      mpfr_mul(result->value.complex.r, xp, xq, GFC_RND_MODE);\n+      mpfr_mul (result->value.complex.r, xp, xq, GFC_RND_MODE);\n \n       mpfr_sin  (xp, x->value.complex.r, GFC_RND_MODE);\n       mpfr_sinh (xq, x->value.complex.i, GFC_RND_MODE);\n@@ -889,7 +880,7 @@ gfc_simplify_cos (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_cosh (gfc_expr * x)\n+gfc_simplify_cosh (gfc_expr *x)\n {\n   gfc_expr *result;\n \n@@ -905,7 +896,7 @@ gfc_simplify_cosh (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_dcmplx (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_dcmplx (gfc_expr *x, gfc_expr *y)\n {\n \n   if (x->expr_type != EXPR_CONSTANT\n@@ -917,7 +908,7 @@ gfc_simplify_dcmplx (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_dble (gfc_expr * e)\n+gfc_simplify_dble (gfc_expr *e)\n {\n   gfc_expr *result;\n \n@@ -947,7 +938,7 @@ gfc_simplify_dble (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_digits (gfc_expr * x)\n+gfc_simplify_digits (gfc_expr *x)\n {\n   int i, digits;\n \n@@ -972,7 +963,7 @@ gfc_simplify_digits (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_dim (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_dim (gfc_expr *x, gfc_expr *y)\n {\n   gfc_expr *result;\n   int kind;\n@@ -995,7 +986,8 @@ gfc_simplify_dim (gfc_expr * x, gfc_expr * y)\n \n     case BT_REAL:\n       if (mpfr_cmp (x->value.real, y->value.real) > 0)\n-\tmpfr_sub (result->value.real, x->value.real, y->value.real, GFC_RND_MODE);\n+\tmpfr_sub (result->value.real, x->value.real, y->value.real,\n+\t\t  GFC_RND_MODE);\n       else\n \tmpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n \n@@ -1010,15 +1002,14 @@ gfc_simplify_dim (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_dprod (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_dprod (gfc_expr *x, gfc_expr *y)\n {\n   gfc_expr *a1, *a2, *result;\n \n   if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  result =\n-    gfc_constant_result (BT_REAL, gfc_default_double_kind, &x->where);\n+  result = gfc_constant_result (BT_REAL, gfc_default_double_kind, &x->where);\n \n   a1 = gfc_real2real (x, gfc_default_double_kind);\n   a2 = gfc_real2real (y, gfc_default_double_kind);\n@@ -1033,7 +1024,7 @@ gfc_simplify_dprod (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_epsilon (gfc_expr * e)\n+gfc_simplify_epsilon (gfc_expr *e)\n {\n   gfc_expr *result;\n   int i;\n@@ -1049,7 +1040,7 @@ gfc_simplify_epsilon (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_exp (gfc_expr * x)\n+gfc_simplify_exp (gfc_expr *x)\n {\n   gfc_expr *result;\n   mpfr_t xp, xq;\n@@ -1062,7 +1053,7 @@ gfc_simplify_exp (gfc_expr * x)\n   switch (x->ts.type)\n     {\n     case BT_REAL:\n-      mpfr_exp(result->value.real, x->value.real, GFC_RND_MODE);\n+      mpfr_exp (result->value.real, x->value.real, GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n@@ -1085,9 +1076,8 @@ gfc_simplify_exp (gfc_expr * x)\n   return range_check (result, \"EXP\");\n }\n \n-/* FIXME:  MPFR should be able to do this better */\n gfc_expr *\n-gfc_simplify_exponent (gfc_expr * x)\n+gfc_simplify_exponent (gfc_expr *x)\n {\n   int i;\n   gfc_expr *result;\n@@ -1114,7 +1104,7 @@ gfc_simplify_exponent (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_float (gfc_expr * a)\n+gfc_simplify_float (gfc_expr *a)\n {\n   gfc_expr *result;\n \n@@ -1127,7 +1117,7 @@ gfc_simplify_float (gfc_expr * a)\n \n \n gfc_expr *\n-gfc_simplify_floor (gfc_expr * e, gfc_expr * k)\n+gfc_simplify_floor (gfc_expr *e, gfc_expr *k)\n {\n   gfc_expr *result;\n   mpfr_t floor;\n@@ -1155,7 +1145,7 @@ gfc_simplify_floor (gfc_expr * e, gfc_expr * k)\n \n \n gfc_expr *\n-gfc_simplify_fraction (gfc_expr * x)\n+gfc_simplify_fraction (gfc_expr *x)\n {\n   gfc_expr *result;\n   mpfr_t absv, exp, pow2;\n@@ -1196,7 +1186,7 @@ gfc_simplify_fraction (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_huge (gfc_expr * e)\n+gfc_simplify_huge (gfc_expr *e)\n {\n   gfc_expr *result;\n   int i;\n@@ -1224,7 +1214,7 @@ gfc_simplify_huge (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_iachar (gfc_expr * e)\n+gfc_simplify_iachar (gfc_expr *e)\n {\n   gfc_expr *result;\n   int index;\n@@ -1248,7 +1238,7 @@ gfc_simplify_iachar (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_iand (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_iand (gfc_expr *x, gfc_expr *y)\n {\n   gfc_expr *result;\n \n@@ -1264,7 +1254,7 @@ gfc_simplify_iand (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_ibclr (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_ibclr (gfc_expr *x, gfc_expr *y)\n {\n   gfc_expr *result;\n   int k, pos;\n@@ -1302,7 +1292,7 @@ gfc_simplify_ibclr (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_ibits (gfc_expr * x, gfc_expr * y, gfc_expr * z)\n+gfc_simplify_ibits (gfc_expr *x, gfc_expr *y, gfc_expr *z)\n {\n   gfc_expr *result;\n   int pos, len;\n@@ -1350,17 +1340,11 @@ gfc_simplify_ibits (gfc_expr * x, gfc_expr * y, gfc_expr * z)\n   for (i = 0; i < bitsize; i++)\n     {\n       if (bits[i] == 0)\n-\t{\n-\t  mpz_clrbit (result->value.integer, i);\n-\t}\n+\tmpz_clrbit (result->value.integer, i);\n       else if (bits[i] == 1)\n-\t{\n-\t  mpz_setbit (result->value.integer, i);\n-\t}\n+\tmpz_setbit (result->value.integer, i);\n       else\n-\t{\n-\t  gfc_internal_error (\"IBITS: Bad bit\");\n-\t}\n+\tgfc_internal_error (\"IBITS: Bad bit\");\n     }\n \n   gfc_free (bits);\n@@ -1370,7 +1354,7 @@ gfc_simplify_ibits (gfc_expr * x, gfc_expr * y, gfc_expr * z)\n \n \n gfc_expr *\n-gfc_simplify_ibset (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_ibset (gfc_expr *x, gfc_expr *y)\n {\n   gfc_expr *result;\n   int k, pos;\n@@ -1408,7 +1392,7 @@ gfc_simplify_ibset (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_ichar (gfc_expr * e)\n+gfc_simplify_ichar (gfc_expr *e)\n {\n   gfc_expr *result;\n   int index;\n@@ -1438,7 +1422,7 @@ gfc_simplify_ichar (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_ieor (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_ieor (gfc_expr *x, gfc_expr *y)\n {\n   gfc_expr *result;\n \n@@ -1454,7 +1438,7 @@ gfc_simplify_ieor (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_index (gfc_expr * x, gfc_expr * y, gfc_expr * b)\n+gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b)\n {\n   gfc_expr *result;\n   int back, len, lensub;\n@@ -1482,7 +1466,6 @@ gfc_simplify_index (gfc_expr * x, gfc_expr * y, gfc_expr * b)\n \n   if (back == 0)\n     {\n-\n       if (lensub == 0)\n \t{\n \t  mpz_set_si (result->value.integer, 1);\n@@ -1494,8 +1477,8 @@ gfc_simplify_index (gfc_expr * x, gfc_expr * y, gfc_expr * b)\n \t    {\n \t      for (j = 0; j < lensub; j++)\n \t\t{\n-\t\t  if (y->value.character.string[j] ==\n-\t\t      x->value.character.string[i])\n+\t\t  if (y->value.character.string[j]\n+\t\t      == x->value.character.string[i])\n \t\t    {\n \t\t      index = i + 1;\n \t\t      goto done;\n@@ -1509,16 +1492,16 @@ gfc_simplify_index (gfc_expr * x, gfc_expr * y, gfc_expr * b)\n \t    {\n \t      for (j = 0; j < lensub; j++)\n \t\t{\n-\t\t  if (y->value.character.string[j] ==\n-\t\t      x->value.character.string[i])\n+\t\t  if (y->value.character.string[j]\n+\t\t      == x->value.character.string[i])\n \t\t    {\n \t\t      start = i;\n \t\t      count = 0;\n \n \t\t      for (k = 0; k < lensub; k++)\n \t\t\t{\n-\t\t\t  if (y->value.character.string[k] ==\n-\t\t\t      x->value.character.string[k + start])\n+\t\t\t  if (y->value.character.string[k]\n+\t\t\t      == x->value.character.string[k + start])\n \t\t\t    count++;\n \t\t\t}\n \n@@ -1535,7 +1518,6 @@ gfc_simplify_index (gfc_expr * x, gfc_expr * y, gfc_expr * b)\n     }\n   else\n     {\n-\n       if (lensub == 0)\n \t{\n \t  mpz_set_si (result->value.integer, len + 1);\n@@ -1547,8 +1529,8 @@ gfc_simplify_index (gfc_expr * x, gfc_expr * y, gfc_expr * b)\n \t    {\n \t      for (j = 0; j < lensub; j++)\n \t\t{\n-\t\t  if (y->value.character.string[j] ==\n-\t\t      x->value.character.string[len - i])\n+\t\t  if (y->value.character.string[j]\n+\t\t      == x->value.character.string[len - i])\n \t\t    {\n \t\t      index = len - i + 1;\n \t\t      goto done;\n@@ -1562,16 +1544,16 @@ gfc_simplify_index (gfc_expr * x, gfc_expr * y, gfc_expr * b)\n \t    {\n \t      for (j = 0; j < lensub; j++)\n \t\t{\n-\t\t  if (y->value.character.string[j] ==\n-\t\t      x->value.character.string[len - i])\n+\t\t  if (y->value.character.string[j]\n+\t\t      == x->value.character.string[len - i])\n \t\t    {\n \t\t      start = len - i;\n \t\t      if (start <= len - lensub)\n \t\t\t{\n \t\t\t  count = 0;\n \t\t\t  for (k = 0; k < lensub; k++)\n-\t\t\t    if (y->value.character.string[k] ==\n-\t\t\t\tx->value.character.string[k + start])\n+\t\t\t    if (y->value.character.string[k]\n+\t\t\t        == x->value.character.string[k + start])\n \t\t\t      count++;\n \n \t\t\t  if (count == lensub)\n@@ -1597,7 +1579,7 @@ gfc_simplify_index (gfc_expr * x, gfc_expr * y, gfc_expr * b)\n \n \n gfc_expr *\n-gfc_simplify_int (gfc_expr * e, gfc_expr * k)\n+gfc_simplify_int (gfc_expr *e, gfc_expr *k)\n {\n   gfc_expr *rpart, *rtrunc, *result;\n   int kind;\n@@ -1644,7 +1626,7 @@ gfc_simplify_int (gfc_expr * e, gfc_expr * k)\n \n \n static gfc_expr *\n-gfc_simplify_intconv (gfc_expr * e, int kind, const char *name)\n+gfc_simplify_intconv (gfc_expr *e, int kind, const char *name)\n {\n   gfc_expr *rpart, *rtrunc, *result;\n \n@@ -1684,27 +1666,30 @@ gfc_simplify_intconv (gfc_expr * e, int kind, const char *name)\n   return range_check (result, name);\n }\n \n+\n gfc_expr *\n-gfc_simplify_int2 (gfc_expr * e)\n+gfc_simplify_int2 (gfc_expr *e)\n {\n   return gfc_simplify_intconv (e, 2, \"INT2\");\n }\n \n+\n gfc_expr *\n-gfc_simplify_int8 (gfc_expr * e)\n+gfc_simplify_int8 (gfc_expr *e)\n {\n   return gfc_simplify_intconv (e, 8, \"INT8\");\n }\n \n+\n gfc_expr *\n-gfc_simplify_long (gfc_expr * e)\n+gfc_simplify_long (gfc_expr *e)\n {\n   return gfc_simplify_intconv (e, 4, \"LONG\");\n }\n \n \n gfc_expr *\n-gfc_simplify_ifix (gfc_expr * e)\n+gfc_simplify_ifix (gfc_expr *e)\n {\n   gfc_expr *rtrunc, *result;\n \n@@ -1725,7 +1710,7 @@ gfc_simplify_ifix (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_idint (gfc_expr * e)\n+gfc_simplify_idint (gfc_expr *e)\n {\n   gfc_expr *rtrunc, *result;\n \n@@ -1746,7 +1731,7 @@ gfc_simplify_idint (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_ior (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_ior (gfc_expr *x, gfc_expr *y)\n {\n   gfc_expr *result;\n \n@@ -1761,7 +1746,7 @@ gfc_simplify_ior (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_ishft (gfc_expr * e, gfc_expr * s)\n+gfc_simplify_ishft (gfc_expr *e, gfc_expr *s)\n {\n   gfc_expr *result;\n   int shift, ashift, isize, k, *bits, i;\n@@ -1786,9 +1771,8 @@ gfc_simplify_ishft (gfc_expr * e, gfc_expr * s)\n \n   if (ashift > isize)\n     {\n-      gfc_error\n-\t(\"Magnitude of second argument of ISHFT exceeds bit size at %L\",\n-\t &s->where);\n+      gfc_error (\"Magnitude of second argument of ISHFT exceeds bit size \"\n+\t\t \"at %L\", &s->where);\n       return &gfc_bad_expr;\n     }\n \n@@ -1840,7 +1824,7 @@ gfc_simplify_ishft (gfc_expr * e, gfc_expr * s)\n \n \n gfc_expr *\n-gfc_simplify_ishftc (gfc_expr * e, gfc_expr * s, gfc_expr * sz)\n+gfc_simplify_ishftc (gfc_expr *e, gfc_expr *s, gfc_expr *sz)\n {\n   gfc_expr *result;\n   int shift, ashift, isize, ssize, delta, k;\n@@ -1861,7 +1845,7 @@ gfc_simplify_ishftc (gfc_expr * e, gfc_expr * s, gfc_expr * sz)\n   if (sz != NULL)\n     {\n       if (sz->expr_type != EXPR_CONSTANT)\n-        return NULL;\n+\treturn NULL;\n \n       if (gfc_extract_int (sz, &ssize) != NULL || ssize <= 0)\n \t{\n@@ -1956,7 +1940,7 @@ gfc_simplify_ishftc (gfc_expr * e, gfc_expr * s, gfc_expr * sz)\n \n \n gfc_expr *\n-gfc_simplify_kind (gfc_expr * e)\n+gfc_simplify_kind (gfc_expr *e)\n {\n \n   if (e->ts.type == BT_DERIVED)\n@@ -1970,7 +1954,7 @@ gfc_simplify_kind (gfc_expr * e)\n \n \n static gfc_expr *\n-simplify_bound (gfc_expr * array, gfc_expr * dim, int upper)\n+simplify_bound (gfc_expr *array, gfc_expr *dim, int upper)\n {\n   gfc_ref *ref;\n   gfc_array_spec *as;\n@@ -2077,14 +2061,14 @@ simplify_bound (gfc_expr * array, gfc_expr * dim, int upper)\n \n \n gfc_expr *\n-gfc_simplify_lbound (gfc_expr * array, gfc_expr * dim)\n+gfc_simplify_lbound (gfc_expr *array, gfc_expr *dim)\n {\n   return simplify_bound (array, dim, 0);\n }\n \n \n gfc_expr *\n-gfc_simplify_len (gfc_expr * e)\n+gfc_simplify_len (gfc_expr *e)\n {\n   gfc_expr *result;\n \n@@ -2110,7 +2094,7 @@ gfc_simplify_len (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_len_trim (gfc_expr * e)\n+gfc_simplify_len_trim (gfc_expr *e)\n {\n   gfc_expr *result;\n   int count, len, lentrim, i;\n@@ -2137,9 +2121,8 @@ gfc_simplify_len_trim (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_lge (gfc_expr * a, gfc_expr * b)\n+gfc_simplify_lge (gfc_expr *a, gfc_expr *b)\n {\n-\n   if (a->expr_type != EXPR_CONSTANT || b->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n@@ -2149,9 +2132,8 @@ gfc_simplify_lge (gfc_expr * a, gfc_expr * b)\n \n \n gfc_expr *\n-gfc_simplify_lgt (gfc_expr * a, gfc_expr * b)\n+gfc_simplify_lgt (gfc_expr *a, gfc_expr *b)\n {\n-\n   if (a->expr_type != EXPR_CONSTANT || b->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n@@ -2161,9 +2143,8 @@ gfc_simplify_lgt (gfc_expr * a, gfc_expr * b)\n \n \n gfc_expr *\n-gfc_simplify_lle (gfc_expr * a, gfc_expr * b)\n+gfc_simplify_lle (gfc_expr *a, gfc_expr *b)\n {\n-\n   if (a->expr_type != EXPR_CONSTANT || b->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n@@ -2173,9 +2154,8 @@ gfc_simplify_lle (gfc_expr * a, gfc_expr * b)\n \n \n gfc_expr *\n-gfc_simplify_llt (gfc_expr * a, gfc_expr * b)\n+gfc_simplify_llt (gfc_expr *a, gfc_expr *b)\n {\n-\n   if (a->expr_type != EXPR_CONSTANT || b->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n@@ -2185,7 +2165,7 @@ gfc_simplify_llt (gfc_expr * a, gfc_expr * b)\n \n \n gfc_expr *\n-gfc_simplify_log (gfc_expr * x)\n+gfc_simplify_log (gfc_expr *x)\n {\n   gfc_expr *result;\n   mpfr_t xr, xi;\n@@ -2202,14 +2182,13 @@ gfc_simplify_log (gfc_expr * x)\n     case BT_REAL:\n       if (mpfr_sgn (x->value.real) <= 0)\n \t{\n-\t  gfc_error\n-\t    (\"Argument of LOG at %L cannot be less than or equal to zero\",\n-\t     &x->where);\n+\t  gfc_error (\"Argument of LOG at %L cannot be less than or equal \"\n+\t\t     \"to zero\", &x->where);\n \t  gfc_free_expr (result);\n \t  return &gfc_bad_expr;\n \t}\n \n-      mpfr_log(result->value.real, x->value.real, GFC_RND_MODE);\n+      mpfr_log (result->value.real, x->value.real, GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n@@ -2225,8 +2204,8 @@ gfc_simplify_log (gfc_expr * x)\n       mpfr_init (xr);\n       mpfr_init (xi);\n \n-      mpfr_atan2 (result->value.complex.i, x->value.complex.i, x->value.complex.r,\n-\t\t  GFC_RND_MODE);\n+      mpfr_atan2 (result->value.complex.i, x->value.complex.i,\n+\t\t  x->value.complex.r, GFC_RND_MODE);\n \n       mpfr_mul (xr, x->value.complex.r, x->value.complex.r, GFC_RND_MODE);\n       mpfr_mul (xi, x->value.complex.i, x->value.complex.i, GFC_RND_MODE);\n@@ -2248,7 +2227,7 @@ gfc_simplify_log (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_log10 (gfc_expr * x)\n+gfc_simplify_log10 (gfc_expr *x)\n {\n   gfc_expr *result;\n \n@@ -2259,9 +2238,8 @@ gfc_simplify_log10 (gfc_expr * x)\n \n   if (mpfr_sgn (x->value.real) <= 0)\n     {\n-      gfc_error\n-\t(\"Argument of LOG10 at %L cannot be less than or equal to zero\",\n-\t &x->where);\n+      gfc_error (\"Argument of LOG10 at %L cannot be less than or equal \"\n+\t\t \"to zero\", &x->where);\n       return &gfc_bad_expr;\n     }\n \n@@ -2274,7 +2252,7 @@ gfc_simplify_log10 (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_logical (gfc_expr * e, gfc_expr * k)\n+gfc_simplify_logical (gfc_expr *e, gfc_expr *k)\n {\n   gfc_expr *result;\n   int kind;\n@@ -2302,7 +2280,7 @@ gfc_simplify_logical (gfc_expr * e, gfc_expr * k)\n    MAX(), -1 for MIN().  */\n \n static gfc_expr *\n-simplify_min_max (gfc_expr * expr, int sign)\n+simplify_min_max (gfc_expr *expr, int sign)\n {\n   gfc_actual_arglist *arg, *last, *extremum;\n   gfc_intrinsic_sym * specific;\n@@ -2334,10 +2312,10 @@ simplify_min_max (gfc_expr * expr, int sign)\n \t  break;\n \n \tcase BT_REAL:\n-\t  if (mpfr_cmp (arg->expr->value.real, extremum->expr->value.real) *\n-\t      sign > 0)\n+\t  if (mpfr_cmp (arg->expr->value.real, extremum->expr->value.real)\n+\t      * sign > 0)\n \t    mpfr_set (extremum->expr->value.real, arg->expr->value.real,\n-                      GFC_RND_MODE);\n+\t\t      GFC_RND_MODE);\n \n \t  break;\n \n@@ -2375,21 +2353,21 @@ simplify_min_max (gfc_expr * expr, int sign)\n \n \n gfc_expr *\n-gfc_simplify_min (gfc_expr * e)\n+gfc_simplify_min (gfc_expr *e)\n {\n   return simplify_min_max (e, -1);\n }\n \n \n gfc_expr *\n-gfc_simplify_max (gfc_expr * e)\n+gfc_simplify_max (gfc_expr *e)\n {\n   return simplify_min_max (e, 1);\n }\n \n \n gfc_expr *\n-gfc_simplify_maxexponent (gfc_expr * x)\n+gfc_simplify_maxexponent (gfc_expr *x)\n {\n   gfc_expr *result;\n   int i;\n@@ -2404,7 +2382,7 @@ gfc_simplify_maxexponent (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_minexponent (gfc_expr * x)\n+gfc_simplify_minexponent (gfc_expr *x)\n {\n   gfc_expr *result;\n   int i;\n@@ -2419,7 +2397,7 @@ gfc_simplify_minexponent (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_mod (gfc_expr * a, gfc_expr * p)\n+gfc_simplify_mod (gfc_expr *a, gfc_expr *p)\n {\n   gfc_expr *result;\n   mpfr_t quot, iquot, term;\n@@ -2477,7 +2455,7 @@ gfc_simplify_mod (gfc_expr * a, gfc_expr * p)\n \n \n gfc_expr *\n-gfc_simplify_modulo (gfc_expr * a, gfc_expr * p)\n+gfc_simplify_modulo (gfc_expr *a, gfc_expr *p)\n {\n   gfc_expr *result;\n   mpfr_t quot, iquot, term;\n@@ -2495,7 +2473,7 @@ gfc_simplify_modulo (gfc_expr * a, gfc_expr * p)\n       if (mpz_cmp_ui (p->value.integer, 0) == 0)\n \t{\n \t  /* Result is processor-dependent. This processor just opts\n-             to not handle it at all.  */\n+\t     to not handle it at all.  */\n \t  gfc_error (\"Second argument of MODULO at %L is zero\", &a->where);\n \t  gfc_free_expr (result);\n \t  return &gfc_bad_expr;\n@@ -2538,18 +2516,18 @@ gfc_simplify_modulo (gfc_expr * a, gfc_expr * p)\n \n /* Exists for the sole purpose of consistency with other intrinsics.  */\n gfc_expr *\n-gfc_simplify_mvbits (gfc_expr * f  ATTRIBUTE_UNUSED,\n-\t\t     gfc_expr * fp ATTRIBUTE_UNUSED,\n-\t\t     gfc_expr * l  ATTRIBUTE_UNUSED,\n-\t\t     gfc_expr * to ATTRIBUTE_UNUSED,\n-\t\t     gfc_expr * tp ATTRIBUTE_UNUSED)\n+gfc_simplify_mvbits (gfc_expr *f  ATTRIBUTE_UNUSED,\n+\t\t     gfc_expr *fp ATTRIBUTE_UNUSED,\n+\t\t     gfc_expr *l  ATTRIBUTE_UNUSED,\n+\t\t     gfc_expr *to ATTRIBUTE_UNUSED,\n+\t\t     gfc_expr *tp ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }\n \n \n gfc_expr *\n-gfc_simplify_nearest (gfc_expr * x, gfc_expr * s)\n+gfc_simplify_nearest (gfc_expr *x, gfc_expr *s)\n {\n   gfc_expr *result;\n   mpfr_t tmp;\n@@ -2560,7 +2538,8 @@ gfc_simplify_nearest (gfc_expr * x, gfc_expr * s)\n \n   if (mpfr_sgn (s->value.real) == 0)\n     {\n-      gfc_error (\"Second argument of NEAREST at %L shall not be zero\", &s->where);\n+      gfc_error (\"Second argument of NEAREST at %L shall not be zero\",\n+\t\t &s->where);\n       return &gfc_bad_expr;\n     }\n \n@@ -2571,14 +2550,14 @@ gfc_simplify_nearest (gfc_expr * x, gfc_expr * s)\n   mpfr_init (tmp);\n   mpfr_set_inf (tmp, sgn);\n   mpfr_nexttoward (result->value.real, tmp);\n-  mpfr_clear(tmp);\n+  mpfr_clear (tmp);\n \n   return range_check (result, \"NEAREST\");\n }\n \n \n static gfc_expr *\n-simplify_nint (const char *name, gfc_expr * e, gfc_expr * k)\n+simplify_nint (const char *name, gfc_expr *e, gfc_expr *k)\n {\n   gfc_expr *itrunc, *result;\n   int kind;\n@@ -2594,7 +2573,7 @@ simplify_nint (const char *name, gfc_expr * e, gfc_expr * k)\n \n   itrunc = gfc_copy_expr (e);\n \n-  mpfr_round(itrunc->value.real, e->value.real);\n+  mpfr_round (itrunc->value.real, e->value.real);\n \n   gfc_mpfr_to_mpz (result->value.integer, itrunc->value.real);\n \n@@ -2605,7 +2584,7 @@ simplify_nint (const char *name, gfc_expr * e, gfc_expr * k)\n \n \n gfc_expr *\n-gfc_simplify_new_line (gfc_expr * e)\n+gfc_simplify_new_line (gfc_expr *e)\n {\n   gfc_expr *result;\n \n@@ -2624,21 +2603,21 @@ gfc_simplify_new_line (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_nint (gfc_expr * e, gfc_expr * k)\n+gfc_simplify_nint (gfc_expr *e, gfc_expr *k)\n {\n   return simplify_nint (\"NINT\", e, k);\n }\n \n \n gfc_expr *\n-gfc_simplify_idnint (gfc_expr * e)\n+gfc_simplify_idnint (gfc_expr *e)\n {\n   return simplify_nint (\"IDNINT\", e, NULL);\n }\n \n \n gfc_expr *\n-gfc_simplify_not (gfc_expr * e)\n+gfc_simplify_not (gfc_expr *e)\n {\n   gfc_expr *result;\n \n@@ -2654,7 +2633,7 @@ gfc_simplify_not (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_null (gfc_expr * mold)\n+gfc_simplify_null (gfc_expr *mold)\n {\n   gfc_expr *result;\n \n@@ -2672,7 +2651,7 @@ gfc_simplify_null (gfc_expr * mold)\n \n \n gfc_expr *\n-gfc_simplify_or (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_or (gfc_expr *x, gfc_expr *y)\n {\n   gfc_expr *result;\n   int kind;\n@@ -2697,7 +2676,7 @@ gfc_simplify_or (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_precision (gfc_expr * e)\n+gfc_simplify_precision (gfc_expr *e)\n {\n   gfc_expr *result;\n   int i;\n@@ -2712,7 +2691,7 @@ gfc_simplify_precision (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_radix (gfc_expr * e)\n+gfc_simplify_radix (gfc_expr *e)\n {\n   gfc_expr *result;\n   int i;\n@@ -2740,7 +2719,7 @@ gfc_simplify_radix (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_range (gfc_expr * e)\n+gfc_simplify_range (gfc_expr *e)\n {\n   gfc_expr *result;\n   int i;\n@@ -2771,7 +2750,7 @@ gfc_simplify_range (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_real (gfc_expr * e, gfc_expr * k)\n+gfc_simplify_real (gfc_expr *e, gfc_expr *k)\n {\n   gfc_expr *result;\n   int kind;\n@@ -2811,7 +2790,7 @@ gfc_simplify_real (gfc_expr * e, gfc_expr * k)\n \n \n gfc_expr *\n-gfc_simplify_realpart (gfc_expr * e)\n+gfc_simplify_realpart (gfc_expr *e)\n {\n   gfc_expr *result;\n \n@@ -2825,7 +2804,7 @@ gfc_simplify_realpart (gfc_expr * e)\n }\n \n gfc_expr *\n-gfc_simplify_repeat (gfc_expr * e, gfc_expr * n)\n+gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n {\n   gfc_expr *result;\n   int i, j, len, ncopies, nlen;\n@@ -2857,8 +2836,8 @@ gfc_simplify_repeat (gfc_expr * e, gfc_expr * n)\n \n   for (i = 0; i < ncopies; i++)\n     for (j = 0; j < len; j++)\n-      result->value.character.string[j + i * len] =\n-\te->value.character.string[j];\n+      result->value.character.string[j + i * len]\n+      = e->value.character.string[j];\n \n   result->value.character.string[nlen] = '\\0';\t/* For debugger */\n   return result;\n@@ -2868,10 +2847,9 @@ gfc_simplify_repeat (gfc_expr * e, gfc_expr * n)\n /* This one is a bear, but mainly has to do with shuffling elements.  */\n \n gfc_expr *\n-gfc_simplify_reshape (gfc_expr * source, gfc_expr * shape_exp,\n-\t\t      gfc_expr * pad, gfc_expr * order_exp)\n+gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,\n+\t\t      gfc_expr *pad, gfc_expr *order_exp)\n {\n-\n   int order[GFC_MAX_DIMENSIONS], shape[GFC_MAX_DIMENSIONS];\n   int i, rank, npad, x[GFC_MAX_DIMENSIONS];\n   gfc_constructor *head, *tail;\n@@ -2888,8 +2866,7 @@ gfc_simplify_reshape (gfc_expr * source, gfc_expr * shape_exp,\n     return NULL;\n \n   if (pad != NULL\n-      && (pad->expr_type != EXPR_ARRAY\n-\t  || !gfc_is_constant_expr (pad)))\n+      && (pad->expr_type != EXPR_ARRAY || !gfc_is_constant_expr (pad)))\n     return NULL;\n \n   if (order_exp != NULL\n@@ -2947,11 +2924,9 @@ gfc_simplify_reshape (gfc_expr * source, gfc_expr * shape_exp,\n     {\n       for (i = 0; i < rank; i++)\n \torder[i] = i;\n-\n     }\n   else\n     {\n-\n       for (i = 0; i < rank; i++)\n \tx[i] = 0;\n \n@@ -2960,9 +2935,8 @@ gfc_simplify_reshape (gfc_expr * source, gfc_expr * shape_exp,\n \t  e = gfc_get_array_element (order_exp, i);\n \t  if (e == NULL)\n \t    {\n-\t      gfc_error\n-\t\t(\"ORDER parameter of RESHAPE at %L is not the same size \"\n-\t\t \"as SHAPE parameter\", &order_exp->where);\n+\t      gfc_error (\"ORDER parameter of RESHAPE at %L is not the same \"\n+\t\t\t \"size as SHAPE parameter\", &order_exp->where);\n \t      goto bad_reshape;\n \t    }\n \n@@ -3043,9 +3017,8 @@ gfc_simplify_reshape (gfc_expr * source, gfc_expr * shape_exp,\n \n \t  if (npad == 0)\n \t    {\n-\t      gfc_error\n-\t\t(\"PAD parameter required for short SOURCE parameter at %L\",\n-\t\t &source->where);\n+\t      gfc_error (\"PAD parameter required for short SOURCE parameter \"\n+\t\t\t \"at %L\", &source->where);\n \t      goto bad_reshape;\n \t    }\n \n@@ -3104,7 +3077,7 @@ gfc_simplify_reshape (gfc_expr * source, gfc_expr * shape_exp,\n \n \n gfc_expr *\n-gfc_simplify_rrspacing (gfc_expr * x)\n+gfc_simplify_rrspacing (gfc_expr *x)\n {\n   gfc_expr *result;\n   int i;\n@@ -3119,7 +3092,7 @@ gfc_simplify_rrspacing (gfc_expr * x)\n \n   mpfr_abs (result->value.real, x->value.real, GFC_RND_MODE);\n \n-  /* Special case x = 0 and 0.  */\n+  /* Special case x = -0 and 0.  */\n   if (mpfr_sgn (result->value.real) == 0)\n     {\n       mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n@@ -3138,7 +3111,7 @@ gfc_simplify_rrspacing (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_scale (gfc_expr * x, gfc_expr * i)\n+gfc_simplify_scale (gfc_expr *x, gfc_expr *i)\n {\n   int k, neg_flag, power, exp_range;\n   mpfr_t scale, radix;\n@@ -3197,7 +3170,7 @@ gfc_simplify_scale (gfc_expr * x, gfc_expr * i)\n \n \n gfc_expr *\n-gfc_simplify_scan (gfc_expr * e, gfc_expr * c, gfc_expr * b)\n+gfc_simplify_scan (gfc_expr *e, gfc_expr *c, gfc_expr *b)\n {\n   gfc_expr *result;\n   int back;\n@@ -3225,35 +3198,35 @@ gfc_simplify_scan (gfc_expr * e, gfc_expr * c, gfc_expr * b)\n   else\n     {\n       if (back == 0)\n-        {\n-          indx =\n-            strcspn (e->value.character.string, c->value.character.string) + 1;\n-          if (indx > len)\n-            indx = 0;\n-        }\n+\t{\n+\t  indx = strcspn (e->value.character.string, c->value.character.string)\n+\t       + 1;\n+\t  if (indx > len)\n+\t    indx = 0;\n+\t}\n       else\n-        {\n-          i = 0;\n-          for (indx = len; indx > 0; indx--)\n-            {\n-              for (i = 0; i < lenc; i++)\n-                {\n-                  if (c->value.character.string[i]\n-                        == e->value.character.string[indx - 1])\n-                    break;\n-                }\n-              if (i < lenc)\n-                break;\n-            }\n-        }\n+\t{\n+\t  i = 0;\n+\t  for (indx = len; indx > 0; indx--)\n+\t    {\n+\t      for (i = 0; i < lenc; i++)\n+\t\t{\n+\t\t  if (c->value.character.string[i]\n+\t\t      == e->value.character.string[indx - 1])\n+\t\t    break;\n+\t\t}\n+\t      if (i < lenc)\n+\t\tbreak;\n+\t    }\n+\t}\n     }\n   mpz_set_ui (result->value.integer, indx);\n   return range_check (result, \"SCAN\");\n }\n \n \n gfc_expr *\n-gfc_simplify_selected_int_kind (gfc_expr * e)\n+gfc_simplify_selected_int_kind (gfc_expr *e)\n {\n   int i, kind, range;\n   gfc_expr *result;\n@@ -3279,7 +3252,7 @@ gfc_simplify_selected_int_kind (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_selected_real_kind (gfc_expr * p, gfc_expr * q)\n+gfc_simplify_selected_real_kind (gfc_expr *p, gfc_expr *q)\n {\n   int range, precision, i, kind, found_precision, found_range;\n   gfc_expr *result;\n@@ -3337,7 +3310,7 @@ gfc_simplify_selected_real_kind (gfc_expr * p, gfc_expr * q)\n \n \n gfc_expr *\n-gfc_simplify_set_exponent (gfc_expr * x, gfc_expr * i)\n+gfc_simplify_set_exponent (gfc_expr *x, gfc_expr *i)\n {\n   gfc_expr *result;\n   mpfr_t exp, absv, log2, pow2, frac;\n@@ -3387,7 +3360,7 @@ gfc_simplify_set_exponent (gfc_expr * x, gfc_expr * i)\n \n \n gfc_expr *\n-gfc_simplify_shape (gfc_expr * source)\n+gfc_simplify_shape (gfc_expr *source)\n {\n   mpz_t shape[GFC_MAX_DIMENSIONS];\n   gfc_expr *result, *e, *f;\n@@ -3440,7 +3413,7 @@ gfc_simplify_shape (gfc_expr * source)\n \n \n gfc_expr *\n-gfc_simplify_size (gfc_expr * array, gfc_expr * dim)\n+gfc_simplify_size (gfc_expr *array, gfc_expr *dim)\n {\n   mpz_t size;\n   gfc_expr *result;\n@@ -3471,7 +3444,7 @@ gfc_simplify_size (gfc_expr * array, gfc_expr * dim)\n \n \n gfc_expr *\n-gfc_simplify_sign (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_sign (gfc_expr *x, gfc_expr *y)\n {\n   gfc_expr *result;\n \n@@ -3491,7 +3464,7 @@ gfc_simplify_sign (gfc_expr * x, gfc_expr * y)\n \n     case BT_REAL:\n       /* TODO: Handle -0.0 and +0.0 correctly on machines that support\n-         it.  */\n+\t it.  */\n       mpfr_abs (result->value.real, x->value.real, GFC_RND_MODE);\n       if (mpfr_sgn (y->value.real) < 0)\n \tmpfr_neg (result->value.real, result->value.real, GFC_RND_MODE);\n@@ -3507,7 +3480,7 @@ gfc_simplify_sign (gfc_expr * x, gfc_expr * y)\n \n \n gfc_expr *\n-gfc_simplify_sin (gfc_expr * x)\n+gfc_simplify_sin (gfc_expr *x)\n {\n   gfc_expr *result;\n   mpfr_t xp, xq;\n@@ -3549,7 +3522,7 @@ gfc_simplify_sin (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_sinh (gfc_expr * x)\n+gfc_simplify_sinh (gfc_expr *x)\n {\n   gfc_expr *result;\n \n@@ -3558,7 +3531,7 @@ gfc_simplify_sinh (gfc_expr * x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  mpfr_sinh(result->value.real, x->value.real, GFC_RND_MODE);\n+  mpfr_sinh (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"SINH\");\n }\n@@ -3568,7 +3541,7 @@ gfc_simplify_sinh (gfc_expr * x)\n    single precision.  TODO: Rounding!  */\n \n gfc_expr *\n-gfc_simplify_sngl (gfc_expr * a)\n+gfc_simplify_sngl (gfc_expr *a)\n {\n   gfc_expr *result;\n \n@@ -3581,7 +3554,7 @@ gfc_simplify_sngl (gfc_expr * a)\n \n \n gfc_expr *\n-gfc_simplify_spacing (gfc_expr * x)\n+gfc_simplify_spacing (gfc_expr *x)\n {\n   gfc_expr *result;\n   int i;\n@@ -3619,7 +3592,7 @@ gfc_simplify_spacing (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_sqrt (gfc_expr * e)\n+gfc_simplify_sqrt (gfc_expr *e)\n {\n   gfc_expr *result;\n   mpfr_t ac, ad, s, t, w;\n@@ -3640,7 +3613,7 @@ gfc_simplify_sqrt (gfc_expr * e)\n \n     case BT_COMPLEX:\n       /* Formula taken from Numerical Recipes to avoid over- and\n-         underflow.  */\n+\t underflow.  */\n \n       gfc_set_model (e->value.real);\n       mpfr_init (ac);\n@@ -3652,7 +3625,6 @@ gfc_simplify_sqrt (gfc_expr * e)\n       if (mpfr_cmp_ui (e->value.complex.r, 0) == 0\n \t  && mpfr_cmp_ui (e->value.complex.i, 0) == 0)\n \t{\n-\n \t  mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n \t  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n \t  break;\n@@ -3736,7 +3708,7 @@ gfc_simplify_sqrt (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_tan (gfc_expr * x)\n+gfc_simplify_tan (gfc_expr *x)\n {\n   int i;\n   gfc_expr *result;\n@@ -3755,7 +3727,7 @@ gfc_simplify_tan (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_tanh (gfc_expr * x)\n+gfc_simplify_tanh (gfc_expr *x)\n {\n   gfc_expr *result;\n \n@@ -3772,7 +3744,7 @@ gfc_simplify_tanh (gfc_expr * x)\n \n \n gfc_expr *\n-gfc_simplify_tiny (gfc_expr * e)\n+gfc_simplify_tiny (gfc_expr *e)\n {\n   gfc_expr *result;\n   int i;\n@@ -3787,9 +3759,8 @@ gfc_simplify_tiny (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_transfer (gfc_expr * source, gfc_expr *mold, gfc_expr * size)\n+gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n {\n-\n   /* Reference mold and size to suppress warning.  */\n   if (gfc_init_expr && (mold || size))\n     gfc_error (\"TRANSFER intrinsic not implemented for initialization at %L\",\n@@ -3800,7 +3771,7 @@ gfc_simplify_transfer (gfc_expr * source, gfc_expr *mold, gfc_expr * size)\n \n \n gfc_expr *\n-gfc_simplify_trim (gfc_expr * e)\n+gfc_simplify_trim (gfc_expr *e)\n {\n   gfc_expr *result;\n   int count, i, len, lentrim;\n@@ -3835,14 +3806,14 @@ gfc_simplify_trim (gfc_expr * e)\n \n \n gfc_expr *\n-gfc_simplify_ubound (gfc_expr * array, gfc_expr * dim)\n+gfc_simplify_ubound (gfc_expr *array, gfc_expr *dim)\n {\n   return simplify_bound (array, dim, 1);\n }\n \n \n gfc_expr *\n-gfc_simplify_verify (gfc_expr * s, gfc_expr * set, gfc_expr * b)\n+gfc_simplify_verify (gfc_expr *s, gfc_expr *set, gfc_expr *b)\n {\n   gfc_expr *result;\n   int back;\n@@ -3877,8 +3848,8 @@ gfc_simplify_verify (gfc_expr * s, gfc_expr * set, gfc_expr * b)\n \t  return result;\n \t}\n \n-      index =\n-\tstrspn (s->value.character.string, set->value.character.string) + 1;\n+      index = strspn (s->value.character.string, set->value.character.string)\n+\t    + 1;\n       if (index > len)\n \tindex = 0;\n \n@@ -3891,16 +3862,16 @@ gfc_simplify_verify (gfc_expr * s, gfc_expr * set, gfc_expr * b)\n \t  return result;\n \t}\n       for (index = len; index > 0; index --)\n-        {\n-          for (i = 0; i < lenset; i++)\n-            {\n-              if (s->value.character.string[index - 1]\n-                    == set->value.character.string[i])\n-                break;\n-            }\n-          if (i == lenset)\n-            break;\n-        }\n+\t{\n+\t  for (i = 0; i < lenset; i++)\n+\t    {\n+\t      if (s->value.character.string[index - 1]\n+\t\t  == set->value.character.string[i])\n+\t\tbreak;\n+\t    }\n+\t  if (i == lenset)\n+\t    break;\n+\t}\n     }\n \n   mpz_set_ui (result->value.integer, index);\n@@ -3909,7 +3880,7 @@ gfc_simplify_verify (gfc_expr * s, gfc_expr * set, gfc_expr * b)\n \n \n gfc_expr *\n-gfc_simplify_xor (gfc_expr * x, gfc_expr * y)\n+gfc_simplify_xor (gfc_expr *x, gfc_expr *y)\n {\n   gfc_expr *result;\n   int kind;\n@@ -3926,15 +3897,14 @@ gfc_simplify_xor (gfc_expr * x, gfc_expr * y)\n   else /* BT_LOGICAL */\n     {\n       result = gfc_constant_result (BT_LOGICAL, kind, &x->where);\n-      result->value.logical = (x->value.logical && ! y->value.logical)\n-\t\t\t      || (! x->value.logical && y->value.logical);\n+      result->value.logical = (x->value.logical && !y->value.logical)\n+\t\t\t      || (!x->value.logical && y->value.logical);\n     }\n \n   return range_check (result, \"XOR\");\n }\n \n \n-\n /****************** Constant simplification *****************/\n \n /* Master function to convert one constant to another.  While this is\n@@ -3943,7 +3913,7 @@ gfc_simplify_xor (gfc_expr * x, gfc_expr * y)\n    do_simplify().  */\n \n gfc_expr *\n-gfc_convert_constant (gfc_expr * e, bt type, int kind)\n+gfc_convert_constant (gfc_expr *e, bt type, int kind)\n {\n   gfc_expr *g, *result, *(*f) (gfc_expr *, int);\n   gfc_constructor *head, *c, *tail = NULL;\n@@ -4135,6 +4105,5 @@ invert_table (const int *table, int *xtable)\n void\n gfc_simplify_init_1 (void)\n {\n-\n   invert_table (ascii_table, xascii_table);\n }"}, {"sha": "aba40c772f41acf59e4b3e4e186411949d3121ff", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf1eac29ebf11051dfcba996ac4fb3064e3c95c/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=edf1eac29ebf11051dfcba996ac4fb3064e3c95c", "patch": "@@ -1,5 +1,5 @@\n /* Build executable statement trees.\n-   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006\n+   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -37,7 +37,6 @@ gfc_code new_st;\n void\n gfc_clear_new_st (void)\n {\n-\n   memset (&new_st, '\\0', sizeof (new_st));\n   new_st.op = EXEC_NOP;\n }\n@@ -60,9 +59,8 @@ gfc_get_code (void)\n    its tail, returning a pointer to the new tail.  */\n \n gfc_code *\n-gfc_append_code (gfc_code * tail, gfc_code * new)\n+gfc_append_code (gfc_code *tail, gfc_code *new)\n {\n-\n   if (tail != NULL)\n     {\n       while (tail->next != NULL)\n@@ -81,9 +79,8 @@ gfc_append_code (gfc_code * tail, gfc_code * new)\n /* Free a single code structure, but not the actual structure itself.  */\n \n void\n-gfc_free_statement (gfc_code * p)\n+gfc_free_statement (gfc_code *p)\n {\n-\n   if (p->expr)\n     gfc_free_expr (p->expr);\n   if (p->expr2)\n@@ -157,7 +154,7 @@ gfc_free_statement (gfc_code * p)\n \n     case EXEC_DT_END:\n       /* The ext.dt member is a duplicate pointer and doesn't need to\n-         be freed.  */\n+\t be freed.  */\n       break;\n \n     case EXEC_FORALL:\n@@ -200,7 +197,7 @@ gfc_free_statement (gfc_code * p)\n /* Free a code statement and all other code structures linked to it.  */\n \n void\n-gfc_free_statements (gfc_code * p)\n+gfc_free_statements (gfc_code *p)\n {\n   gfc_code *q;\n "}]}