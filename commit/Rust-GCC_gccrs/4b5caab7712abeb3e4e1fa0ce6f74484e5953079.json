{"sha": "4b5caab7712abeb3e4e1fa0ce6f74484e5953079", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI1Y2FhYjc3MTJhYmViM2U0ZTFmYTBjZTZmNzQ0ODRlNTk1MzA3OQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2010-04-26T06:39:27Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2010-04-26T06:39:27Z"}, "message": "tree-vectorizer.h (struct _stmt_vec_info): Add new field to determine if the statement is vectorizable...\n\n\n\t* tree-vectorizer.h (struct _stmt_vec_info): Add new field to \n\tdetermine if the statement is vectorizable, and a macro to \n\taccess it.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): \n\tSkip statements that can't be vectorized. If the analysis \n\tfails, mark the statement as unvectorizable if vectorizing \n\tbasic block.\n\t(vect_compute_data_refs_alignment): Likewise.\n\t(vect_verify_datarefs_alignment): Skip statements marked as \n\tunvectorizable. Add print.\n\t(vect_analyze_group_access): Skip statements that can't be \n\tvectorized. If the analysis fails, mark the statement as \n\tunvectorizable if vectorizing basic block.\n\t(vect_analyze_data_ref_accesses, vect_analyze_data_refs): \n\tLikewise.\n\t* tree-vect-stmts.c (vectorizable_store): Fix the number of \n\tgenerated stmts for SLP.\n\t(new_stmt_vec_info): Initialize the new field.\n\t* tree-vect-slp.c (vect_build_slp_tree): Fail to vectorize \n\tstatements marked as unvectorizable.\n\nFrom-SVN: r158719", "tree": {"sha": "127816de355ad6eada440e245b181155ca6791c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/127816de355ad6eada440e245b181155ca6791c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b5caab7712abeb3e4e1fa0ce6f74484e5953079", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b5caab7712abeb3e4e1fa0ce6f74484e5953079", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b5caab7712abeb3e4e1fa0ce6f74484e5953079", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2cee01013603d62bf3e8985f0699d562c9efe813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cee01013603d62bf3e8985f0699d562c9efe813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cee01013603d62bf3e8985f0699d562c9efe813"}], "stats": {"total": 206, "additions": 189, "deletions": 17}, "files": [{"sha": "3b4ed3c2f2b311faeaf1ecac4cdaac004d50a4e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b5caab7712abeb3e4e1fa0ce6f74484e5953079", "patch": "@@ -1,3 +1,26 @@\n+2010-04-26  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Add new field to \n+\tdetermine if the statement is vectorizable, and a macro to \n+\taccess it.\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): \n+\tSkip statements that can't be vectorized. If the analysis \n+\tfails, mark the statement as unvectorizable if vectorizing \n+\tbasic block.\n+\t(vect_compute_data_refs_alignment): Likewise.\n+\t(vect_verify_datarefs_alignment): Skip statements marked as \n+\tunvectorizable. Add print.\n+\t(vect_analyze_group_access): Skip statements that can't be \n+\tvectorized. If the analysis fails, mark the statement as \n+\tunvectorizable if vectorizing basic block.\n+\t(vect_analyze_data_ref_accesses, vect_analyze_data_refs): \n+\tLikewise.\n+\t* tree-vect-stmts.c (vectorizable_store): Fix the number of \n+\tgenerated stmts for SLP.\n+\t(new_stmt_vec_info): Initialize the new field.\n+\t* tree-vect-slp.c (vect_build_slp_tree): Fail to vectorize \n+\tstatements marked as unvectorizable.\n+\n 2010-04-25  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-common.c (flag_isoc1x): New."}, {"sha": "badf9107c51fa417c92b0e5d8786a35e6dd74f46", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b5caab7712abeb3e4e1fa0ce6f74484e5953079", "patch": "@@ -1,3 +1,7 @@\n+2010-04-26  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/bb-slp-23.c: New test.\n+\n 2010-04-25  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/c90-float-1.c: Also test that C1X macros are not defined."}, {"sha": "640d81a2560eab36a152b54308e1c29f9b72d1c7", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-23.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-23.c?ref=4b5caab7712abeb3e4e1fa0ce6f74484e5953079", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+int a[N], b[N];\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+\n+  /* This statement is ignored in vectorization of this basic block.  */\n+  a[x] = b [y];\n+\n+  a0 = in[0] + 23;\n+  a1 = in[1] + 142;\n+  a2 = in[2] + 2;\n+  a3 = in[3] + 31;\n+  \n+  out[0] = a0 * x;\n+  out[1] = a1 * y;\n+  out[2] = a2 * x;\n+  out[3] = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect_int_mult } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "cf2ac21fca2673d60a6ce786372abdff493c3d95", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 79, "deletions": 12, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=4b5caab7712abeb3e4e1fa0ce6f74484e5953079", "patch": "@@ -503,6 +503,11 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   lambda_vector dist_v;\n   unsigned int loop_depth;\n \n+  /* Don't bother to analyze statements marked as unvectorizable.  */\n+  if (!STMT_VINFO_VECTORIZABLE (stmtinfo_a)\n+      || !STMT_VINFO_VECTORIZABLE (stmtinfo_b))\n+    return false;\n+\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n     {\n       /* Independent data accesses.  */\n@@ -546,7 +551,11 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n           print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n         }\n \n-      return true;\n+      /* Mark the statements as unvectorizable.  */\n+      STMT_VINFO_VECTORIZABLE (stmtinfo_a) = false;\n+      STMT_VINFO_VECTORIZABLE (stmtinfo_b) = false;\n+\n+      return false;\n     }\n \n   /* Versioning for alias is not yet supported for basic block SLP, and\n@@ -851,8 +860,18 @@ vect_compute_data_refs_alignment (loop_vec_info loop_vinfo,\n     datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n \n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n-    if (!vect_compute_data_ref_alignment (dr))\n-      return false;\n+    if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr)))\n+        && !vect_compute_data_ref_alignment (dr))\n+      {\n+        if (bb_vinfo)\n+          {\n+            /* Mark unsupported statement as unvectorizable.  */\n+            STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) = false;\n+            continue;\n+          }\n+        else\n+          return false;\n+      }\n \n   return true;\n }\n@@ -939,9 +958,11 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       gimple stmt = DR_STMT (dr);\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n-      /* For interleaving, only the alignment of the first access matters.  */\n-      if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n-          && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n+      /* For interleaving, only the alignment of the first access matters. \n+         Skip statements marked as not vectorizable.  */\n+      if ((STMT_VINFO_STRIDED_ACCESS (stmt_info)\n+           && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n+          || !STMT_VINFO_VECTORIZABLE (stmt_info))\n         continue;\n \n       supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n@@ -955,6 +976,8 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n               else\n                 fprintf (vect_dump,\n                          \"not vectorized: unsupported unaligned store.\");\n+\n+              print_generic_expr (vect_dump, DR_REF (dr), TDF_SLIM);\n             }\n           return false;\n         }\n@@ -1564,8 +1587,20 @@ vect_analyze_group_access (struct data_reference *dr)\n \t    }\n \t  return true;\n \t}\n+\n       if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"not consecutive access\");\n+        {\n+ \t  fprintf (vect_dump, \"not consecutive access \");\n+          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+        }\n+\n+      if (bb_vinfo)\n+        {\n+          /* Mark the statement as unvectorizable.  */\n+          STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) = false;\n+          return true;\n+        }\n+    \n       return false;\n     }\n \n@@ -1836,11 +1871,20 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n     datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n \n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n-    if (!vect_analyze_data_ref_access (dr))\n+    if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) \n+        && !vect_analyze_data_ref_access (dr))\n       {\n \tif (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t  fprintf (vect_dump, \"not vectorized: complicated access pattern.\");\n-\treturn false;\n+\n+        if (bb_vinfo)\n+          {\n+            /* Mark the statement as not vectorizable.  */\n+            STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) = false;\n+            continue;\n+          }\n+        else\n+          return false;\n       }\n \n   return true;\n@@ -2013,15 +2057,30 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n               fprintf (vect_dump, \"not vectorized: data ref analysis failed \");\n               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n             }\n-          return false;\n+\n+          if (bb_vinfo)\n+            {\n+              /* Mark the statement as not vectorizable.  */\n+              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n+              continue;\n+            }\n+          else\n+            return false;\n         }\n \n       if (TREE_CODE (DR_BASE_ADDRESS (dr)) == INTEGER_CST)\n         {\n           if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n             fprintf (vect_dump, \"not vectorized: base addr of dr is a \"\n                      \"constant\");\n-          return false;\n+          if (bb_vinfo)\n+            {\n+              /* Mark the statement as not vectorizable.  */\n+              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n+              continue;\n+            }\n+          else\n+            return false;\n         }\n \n       base = unshare_expr (DR_BASE_ADDRESS (dr));\n@@ -2163,7 +2222,15 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n               fprintf (vect_dump, \" scalar_type: \");\n               print_generic_expr (vect_dump, scalar_type, TDF_DETAILS);\n             }\n-          return false;\n+\n+          if (bb_vinfo)\n+            {\n+              /* Mark the statement as not vectorizable.  */\n+              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n+              continue;\n+            }\n+          else\n+            return false;\n         }\n \n       /* Adjust the minimal vectorization factor according to the"}, {"sha": "f313294bd2972b14debfbb7c47f431f9cfd9751f", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=4b5caab7712abeb3e4e1fa0ce6f74484e5953079", "patch": "@@ -344,6 +344,19 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t}\n \n+      /* Fail to vectorize statements marked as unvectorizable.  */\n+      if (!STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)))\n+        {\n+          if (vect_print_dump_info (REPORT_SLP))\n+            {\n+              fprintf (vect_dump,\n+                       \"Build SLP failed: unvectorizable statement \");\n+              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+            }\n+\n+          return false;\n+        }\n+\n       lhs = gimple_get_lhs (stmt);\n       if (lhs == NULL_TREE)\n \t{"}, {"sha": "0dabb6a365b3e1127238d84157e9d1e5b58dcace", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=4b5caab7712abeb3e4e1fa0ce6f74484e5953079", "patch": "@@ -3031,12 +3031,17 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t}\n \n       if (slp)\n-\tstrided_store = false;\n-\n-      /* VEC_NUM is the number of vect stmts to be created for this group.  */\n-      if (slp)\n-\tvec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+        {\n+          strided_store = false;\n+          /* VEC_NUM is the number of vect stmts to be created for this \n+             group.  */\n+          vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+          first_stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0); \n+          first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+        } \n       else\n+        /* VEC_NUM is the number of vect stmts to be created for this \n+           group.  */\n \tvec_num = group_size;\n     }\n   else\n@@ -4327,6 +4332,7 @@ new_stmt_vec_info (gimple stmt, loop_vec_info loop_vinfo,\n   STMT_VINFO_LIVE_P (res) = false;\n   STMT_VINFO_VECTYPE (res) = NULL;\n   STMT_VINFO_VEC_STMT (res) = NULL;\n+  STMT_VINFO_VECTORIZABLE (res) = true;\n   STMT_VINFO_IN_PATTERN_P (res) = false;\n   STMT_VINFO_RELATED_STMT (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;"}, {"sha": "c80c34529e455802229038d0f4f62646d272c06f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b5caab7712abeb3e4e1fa0ce6f74484e5953079/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=4b5caab7712abeb3e4e1fa0ce6f74484e5953079", "patch": "@@ -489,6 +489,10 @@ typedef struct _stmt_vec_info {\n \n   /* The bb_vec_info with respect to which STMT is vectorized.  */\n   bb_vec_info bb_vinfo;\n+\n+  /* Is this statement vectorizable or should it be skipped in (partial)\n+     vectorization.  */\n+  bool vectorizable;\n } *stmt_vec_info;\n \n /* Access Functions.  */\n@@ -500,6 +504,7 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_LIVE_P(S)               (S)->live\n #define STMT_VINFO_VECTYPE(S)              (S)->vectype\n #define STMT_VINFO_VEC_STMT(S)             (S)->vectorized_stmt\n+#define STMT_VINFO_VECTORIZABLE(S)         (S)->vectorizable\n #define STMT_VINFO_DATA_REF(S)             (S)->data_ref_info\n \n #define STMT_VINFO_DR_BASE_ADDRESS(S)      (S)->dr_base_address"}]}