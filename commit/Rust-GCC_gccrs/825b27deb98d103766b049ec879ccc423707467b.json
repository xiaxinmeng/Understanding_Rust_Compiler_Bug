{"sha": "825b27deb98d103766b049ec879ccc423707467b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI1YjI3ZGViOThkMTAzNzY2YjA0OWVjODc5Y2NjNDIzNzA3NDY3Yg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-11T08:36:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-11T08:36:51Z"}, "message": "gimple.c (gimple_canonical_types_compatible_p): Split out from gimple_types_compatible_p and friends.\n\n2011-05-11  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.c (gimple_canonical_types_compatible_p): Split out\n\tfrom gimple_types_compatible_p and friends.  Do not recurse\n\tto pointed-to types.\n\t(gimple_canonical_type_eq): Use it.\n\t(iterative_hash_canonical_type): Split out from\n\titerative_hash_gimple_type and friends.  Do not recurse\n\tto pointed-to types.\n\t(gimple_canonical_type_hash): Use it, allocate the hash here.\n\nFrom-SVN: r173649", "tree": {"sha": "f73b15759f701d7d9b16849be8ec6df75f72acad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f73b15759f701d7d9b16849be8ec6df75f72acad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/825b27deb98d103766b049ec879ccc423707467b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825b27deb98d103766b049ec879ccc423707467b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/825b27deb98d103766b049ec879ccc423707467b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825b27deb98d103766b049ec879ccc423707467b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca7566250ff8874b9bd02fb1215d0ee2ba43eef7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca7566250ff8874b9bd02fb1215d0ee2ba43eef7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca7566250ff8874b9bd02fb1215d0ee2ba43eef7"}], "stats": {"total": 511, "additions": 508, "deletions": 3}, "files": [{"sha": "77dd16db4c0dda51955f07aca61d737f8f2153d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825b27deb98d103766b049ec879ccc423707467b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825b27deb98d103766b049ec879ccc423707467b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=825b27deb98d103766b049ec879ccc423707467b", "patch": "@@ -1,3 +1,14 @@\n+2011-05-11  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.c (gimple_canonical_types_compatible_p): Split out\n+\tfrom gimple_types_compatible_p and friends.  Do not recurse\n+\tto pointed-to types.\n+\t(gimple_canonical_type_eq): Use it.\n+\t(iterative_hash_canonical_type): Split out from\n+\titerative_hash_gimple_type and friends.  Do not recurse\n+\tto pointed-to types.\n+\t(gimple_canonical_type_hash): Use it, allocate the hash here.\n+\n 2011-05-11  Revital Eres  <revital.eres@linaro.org>\n \n \t* modulo-sched.c (doloop_register_get): Ignore DEBUG_INSNs while"}, {"sha": "21269344d86517c7d1db5bb130e50636bea44932", "filename": "gcc/gimple.c", "status": "modified", "additions": 497, "deletions": 3, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825b27deb98d103766b049ec879ccc423707467b/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825b27deb98d103766b049ec879ccc423707467b/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=825b27deb98d103766b049ec879ccc423707467b", "patch": "@@ -4344,10 +4344,148 @@ gimple_type_hash (const void *p)\n   return gimple_type_hash_1 (p, GTC_MERGE);\n }\n \n+/* Returning a hash value for gimple type TYPE combined with VAL.\n+\n+   The hash value returned is equal for types considered compatible\n+   by gimple_canonical_types_compatible_p.  */\n+\n+static hashval_t\n+iterative_hash_canonical_type (tree type, hashval_t val)\n+{\n+  hashval_t v;\n+  void **slot;\n+  struct tree_int_map *mp, m;\n+\n+  m.base.from = type;\n+  if ((slot = htab_find_slot (canonical_type_hash_cache, &m, INSERT))\n+      && *slot)\n+    return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, 0);\n+\n+  /* Combine a few common features of types so that types are grouped into\n+     smaller sets; when searching for existing matching types to merge,\n+     only existing types having the same features as the new type will be\n+     checked.  */\n+  v = iterative_hash_hashval_t (TREE_CODE (type), 0);\n+  v = iterative_hash_hashval_t (TYPE_QUALS (type), v);\n+  v = iterative_hash_hashval_t (TREE_ADDRESSABLE (type), v);\n+\n+  /* Do not hash the types size as this will cause differences in\n+     hash values for the complete vs. the incomplete type variant.  */\n+\n+  /* Incorporate common features of numerical types.  */\n+  if (INTEGRAL_TYPE_P (type)\n+      || SCALAR_FLOAT_TYPE_P (type)\n+      || FIXED_POINT_TYPE_P (type))\n+    {\n+      v = iterative_hash_hashval_t (TYPE_PRECISION (type), v);\n+      v = iterative_hash_hashval_t (TYPE_MODE (type), v);\n+      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n+    }\n+\n+  /* For pointer and reference types, fold in information about the type\n+     pointed to but do not recurse to the pointed-to type.  */\n+  if (POINTER_TYPE_P (type))\n+    {\n+      v = iterative_hash_hashval_t (TYPE_REF_CAN_ALIAS_ALL (type), v);\n+      v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n+    }\n+\n+  /* For integer types hash the types min/max values and the string flag.  */\n+  if (TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      /* OMP lowering can introduce error_mark_node in place of\n+\t random local decls in types.  */\n+      if (TYPE_MIN_VALUE (type) != error_mark_node)\n+\tv = iterative_hash_expr (TYPE_MIN_VALUE (type), v);\n+      if (TYPE_MAX_VALUE (type) != error_mark_node)\n+\tv = iterative_hash_expr (TYPE_MAX_VALUE (type), v);\n+      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n+    }\n+\n+  /* For array types hash their domain and the string flag.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && TYPE_DOMAIN (type))\n+    {\n+      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n+      v = iterative_hash_canonical_type (TYPE_DOMAIN (type), v);\n+    }\n+\n+  /* Recurse for aggregates with a single element type.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      || TREE_CODE (type) == COMPLEX_TYPE\n+      || TREE_CODE (type) == VECTOR_TYPE)\n+    v = iterative_hash_canonical_type (TREE_TYPE (type), v);\n+\n+  /* Incorporate function return and argument types.  */\n+  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      unsigned na;\n+      tree p;\n+\n+      /* For method types also incorporate their parent class.  */\n+      if (TREE_CODE (type) == METHOD_TYPE)\n+\tv = iterative_hash_canonical_type (TYPE_METHOD_BASETYPE (type), v);\n+\n+      /* For result types allow mismatch in completeness.  */\n+      if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n+\t  v = iterative_hash_name\n+\t\t(TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (type))), v);\n+\t}\n+      else\n+\tv = iterative_hash_canonical_type (TREE_TYPE (type), v);\n+\n+      for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n+\t{\n+\t  /* For argument types allow mismatch in completeness.  */\n+\t  if (RECORD_OR_UNION_TYPE_P (TREE_VALUE (p)))\n+\t    {\n+\t      v = iterative_hash_hashval_t (TREE_CODE (TREE_VALUE (p)), v);\n+\t      v = iterative_hash_name\n+\t\t    (TYPE_NAME (TYPE_MAIN_VARIANT (TREE_VALUE (p))), v);\n+\t    }\n+\t  else\n+\t    v = iterative_hash_canonical_type (TREE_VALUE (p), v);\n+\t  na++;\n+\t}\n+\n+      v = iterative_hash_hashval_t (na, v);\n+    }\n+\n+  if (TREE_CODE (type) == RECORD_TYPE\n+      || TREE_CODE (type) == UNION_TYPE\n+      || TREE_CODE (type) == QUAL_UNION_TYPE)\n+    {\n+      unsigned nf;\n+      tree f;\n+\n+      for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n+\t{\n+\t  v = iterative_hash_canonical_type (TREE_TYPE (f), v);\n+\t  nf++;\n+\t}\n+\n+      v = iterative_hash_hashval_t (nf, v);\n+    }\n+\n+  /* Cache the just computed hash value.  */\n+  mp = ggc_alloc_cleared_tree_int_map ();\n+  mp->base.from = type;\n+  mp->to = v;\n+  *slot = (void *) mp;\n+\n+  return iterative_hash_hashval_t (v, val);\n+}\n+\n static hashval_t\n gimple_canonical_type_hash (const void *p)\n {\n-  return gimple_type_hash_1 (p, GTC_DIAG);\n+  if (canonical_type_hash_cache == NULL)\n+    canonical_type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n+\t\t\t\t\t\t tree_int_map_eq, NULL);\n+\n+  return iterative_hash_canonical_type (CONST_CAST_TREE ((const_tree) p), 0);\n }\n \n \n@@ -4479,15 +4617,371 @@ gimple_register_type (tree t)\n }\n \n \n+/* The TYPE_CANONICAL merging machinery.  It should closely resemble\n+   the middle-end types_compatible_p function.  It needs to avoid\n+   claiming types are different for types that should be treated\n+   the same with respect to TBAA.  Canonical types are also used\n+   for IL consistency checks via the useless_type_conversion_p\n+   predicate which does not handle all type kinds itself but falls\n+   back to pointer-comparison of TYPE_CANONICAL for aggregates\n+   for example.  */\n+\n+/* Return true iff T1 and T2 are structurally identical for what\n+   TBAA is concerned.  */\n+\n+static bool\n+gimple_canonical_types_compatible_p (tree t1, tree t2)\n+{\n+  type_pair_t p = NULL;\n+\n+  /* Before starting to set up the SCC machinery handle simple cases.  */\n+\n+  /* Check first for the obvious case of pointer identity.  */\n+  if (t1 == t2)\n+    return true;\n+\n+  /* Check that we have two types to compare.  */\n+  if (t1 == NULL_TREE || t2 == NULL_TREE)\n+    return false;\n+\n+  /* If the types have been previously registered and found equal\n+     they still are.  */\n+  if (TYPE_CANONICAL (t1)\n+      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n+    return true;\n+\n+  /* Can't be the same type if the types don't have the same code.  */\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return false;\n+\n+  /* Can't be the same type if they have different CV qualifiers.  */\n+  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n+    return false;\n+\n+  /* Void types are always the same.  */\n+  if (TREE_CODE (t1) == VOID_TYPE)\n+    return true;\n+\n+  /* Do some simple checks before doing three hashtable queries.  */\n+  if (INTEGRAL_TYPE_P (t1)\n+      || SCALAR_FLOAT_TYPE_P (t1)\n+      || FIXED_POINT_TYPE_P (t1)\n+      || TREE_CODE (t1) == VECTOR_TYPE\n+      || TREE_CODE (t1) == COMPLEX_TYPE\n+      || TREE_CODE (t1) == OFFSET_TYPE)\n+    {\n+      /* Can't be the same type if they have different alignment,\n+\t sign, precision or mode.  */\n+      if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+\t  || TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n+\t  || TYPE_MODE (t1) != TYPE_MODE (t2)\n+\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n+\treturn false;\n+\n+      if (TREE_CODE (t1) == INTEGER_TYPE\n+\t  && (TYPE_IS_SIZETYPE (t1) != TYPE_IS_SIZETYPE (t2)\n+\t      || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)))\n+\treturn false;\n+\n+      /* That's all we need to check for float and fixed-point types.  */\n+      if (SCALAR_FLOAT_TYPE_P (t1)\n+\t  || FIXED_POINT_TYPE_P (t1))\n+\treturn true;\n+\n+      /* For integral types fall thru to more complex checks.  */\n+    }\n+\n+  else if (AGGREGATE_TYPE_P (t1) || POINTER_TYPE_P (t1))\n+    {\n+      /* Can't be the same type if they have different alignment or mode.  */\n+      if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+\t  || TYPE_MODE (t1) != TYPE_MODE (t2))\n+\treturn false;\n+    }\n+\n+  /* If the hash values of t1 and t2 are different the types can't\n+     possibly be the same.  This helps keeping the type-pair hashtable\n+     small, only tracking comparisons for hash collisions.  */\n+  if (gimple_canonical_type_hash (t1) != gimple_canonical_type_hash (t2))\n+    return false;\n+\n+  /* If we've visited this type pair before (in the case of aggregates\n+     with self-referential types), and we made a decision, return it.  */\n+  p = lookup_type_pair (t1, t2, &gtc_visited, &gtc_ob);\n+  if (p->same_p[GTC_DIAG] == 0 || p->same_p[GTC_DIAG] == 1)\n+    {\n+      /* We have already decided whether T1 and T2 are the\n+\t same, return the cached result.  */\n+      return p->same_p[GTC_DIAG] == 1;\n+    }\n+\n+  gcc_assert (p->same_p[GTC_DIAG] == -2);\n+\n+  /* If their attributes are not the same they can't be the same type.  */\n+  if (!attribute_list_equal (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2)))\n+    goto different_types;\n+\n+  /* Do type-specific comparisons.  */\n+  switch (TREE_CODE (t1))\n+    {\n+    case VECTOR_TYPE:\n+    case COMPLEX_TYPE:\n+      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\tgoto different_types;\n+      goto same_types;\n+\n+    case ARRAY_TYPE:\n+      /* Array types are the same if the element types are the same and\n+\t the number of elements are the same.  */\n+      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n+\t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n+\tgoto different_types;\n+      else\n+\t{\n+\t  tree i1 = TYPE_DOMAIN (t1);\n+\t  tree i2 = TYPE_DOMAIN (t2);\n+\n+\t  /* For an incomplete external array, the type domain can be\n+ \t     NULL_TREE.  Check this condition also.  */\n+\t  if (i1 == NULL_TREE && i2 == NULL_TREE)\n+\t    goto same_types;\n+\t  else if (i1 == NULL_TREE || i2 == NULL_TREE)\n+\t    goto different_types;\n+\t  /* If for a complete array type the possibly gimplified sizes\n+\t     are different the types are different.  */\n+\t  else if (((TYPE_SIZE (i1) != NULL) ^ (TYPE_SIZE (i2) != NULL))\n+\t\t   || (TYPE_SIZE (i1)\n+\t\t       && TYPE_SIZE (i2)\n+\t\t       && !operand_equal_p (TYPE_SIZE (i1), TYPE_SIZE (i2), 0)))\n+\t    goto different_types;\n+\t  else\n+\t    {\n+\t      tree min1 = TYPE_MIN_VALUE (i1);\n+\t      tree min2 = TYPE_MIN_VALUE (i2);\n+\t      tree max1 = TYPE_MAX_VALUE (i1);\n+\t      tree max2 = TYPE_MAX_VALUE (i2);\n+\n+\t      /* The minimum/maximum values have to be the same.  */\n+\t      if ((min1 == min2\n+\t\t   || (min1 && min2\n+\t\t       && ((TREE_CODE (min1) == PLACEHOLDER_EXPR\n+\t\t\t    && TREE_CODE (min2) == PLACEHOLDER_EXPR)\n+\t\t           || operand_equal_p (min1, min2, 0))))\n+\t\t  && (max1 == max2\n+\t\t      || (max1 && max2\n+\t\t\t  && ((TREE_CODE (max1) == PLACEHOLDER_EXPR\n+\t\t\t       && TREE_CODE (max2) == PLACEHOLDER_EXPR)\n+\t\t\t      || operand_equal_p (max1, max2, 0)))))\n+\t\tgoto same_types;\n+\t      else\n+\t\tgoto different_types;\n+\t    }\n+\t}\n+\n+    case METHOD_TYPE:\n+      /* Method types should belong to the same class.  */\n+      if (!gimple_canonical_types_compatible_p\n+\t     (TYPE_METHOD_BASETYPE (t1), TYPE_METHOD_BASETYPE (t2)))\n+\tgoto different_types;\n+\n+      /* Fallthru  */\n+\n+    case FUNCTION_TYPE:\n+      /* Function types are the same if the return type and arguments types\n+\t are the same.  */\n+      if (!gimple_compatible_complete_and_incomplete_subtype_p\n+\t     (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t  && !gimple_canonical_types_compatible_p\n+\t        (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\tgoto different_types;\n+\n+      if (!comp_type_attributes (t1, t2))\n+\tgoto different_types;\n+\n+      if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))\n+\tgoto same_types;\n+      else\n+\t{\n+\t  tree parms1, parms2;\n+\n+\t  for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n+\t       parms1 && parms2;\n+\t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n+\t    {\n+\t      if (!gimple_compatible_complete_and_incomplete_subtype_p\n+\t\t         (TREE_VALUE (parms1), TREE_VALUE (parms2))\n+\t\t  && !gimple_canonical_types_compatible_p\n+\t\t        (TREE_VALUE (parms1), TREE_VALUE (parms2)))\n+\t\tgoto different_types;\n+\t    }\n+\n+\t  if (parms1 || parms2)\n+\t    goto different_types;\n+\n+\t  goto same_types;\n+\t}\n+\n+    case OFFSET_TYPE:\n+      {\n+\tif (!gimple_canonical_types_compatible_p\n+\t       (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t    || !gimple_canonical_types_compatible_p\n+\t          (TYPE_OFFSET_BASETYPE (t1), TYPE_OFFSET_BASETYPE (t2)))\n+\t  goto different_types;\n+\n+\tgoto same_types;\n+      }\n+\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      {\n+\t/* If the two pointers have different ref-all attributes,\n+\t   they can't be the same type.  */\n+\tif (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n+\t  goto different_types;\n+\n+\tif (TYPE_ADDR_SPACE (TREE_TYPE (t1))\n+\t    != TYPE_ADDR_SPACE (TREE_TYPE (t2)))\n+\t  goto different_types;\n+\n+\tif (TYPE_RESTRICT (t1) != TYPE_RESTRICT (t2))\n+\t  goto different_types;\n+\n+\t/* For canonical type comparisons we do not want to build SCCs\n+\t   so we cannot compare pointed-to types.  But we can, for now,\n+\t   require the same pointed-to type kind.  */\n+\tif (TREE_CODE (TREE_TYPE (t1)) != TREE_CODE (TREE_TYPE (t2)))\n+\t  goto different_types;\n+\n+\tgoto same_types;\n+      }\n+\n+    case NULLPTR_TYPE:\n+      /* There is only one decltype(nullptr).  */\n+      goto same_types;\n+\n+    case INTEGER_TYPE:\n+    case BOOLEAN_TYPE:\n+      {\n+\ttree min1 = TYPE_MIN_VALUE (t1);\n+\ttree max1 = TYPE_MAX_VALUE (t1);\n+\ttree min2 = TYPE_MIN_VALUE (t2);\n+\ttree max2 = TYPE_MAX_VALUE (t2);\n+\tbool min_equal_p = false;\n+\tbool max_equal_p = false;\n+\n+\t/* If either type has a minimum value, the other type must\n+\t   have the same.  */\n+\tif (min1 == NULL_TREE && min2 == NULL_TREE)\n+\t  min_equal_p = true;\n+\telse if (min1 && min2 && operand_equal_p (min1, min2, 0))\n+\t  min_equal_p = true;\n+\n+\t/* Likewise, if either type has a maximum value, the other\n+\t   type must have the same.  */\n+\tif (max1 == NULL_TREE && max2 == NULL_TREE)\n+\t  max_equal_p = true;\n+\telse if (max1 && max2 && operand_equal_p (max1, max2, 0))\n+\t  max_equal_p = true;\n+\n+\tif (!min_equal_p || !max_equal_p)\n+\t  goto different_types;\n+\n+\tgoto same_types;\n+      }\n+\n+    case ENUMERAL_TYPE:\n+      {\n+\t/* FIXME lto, we cannot check bounds on enumeral types because\n+\t   different front ends will produce different values.\n+\t   In C, enumeral types are integers, while in C++ each element\n+\t   will have its own symbolic value.  We should decide how enums\n+\t   are to be represented in GIMPLE and have each front end lower\n+\t   to that.  */\n+\ttree v1, v2;\n+\n+\t/* For enumeral types, all the values must be the same.  */\n+\tif (TYPE_VALUES (t1) == TYPE_VALUES (t2))\n+\t  goto same_types;\n+\n+\tfor (v1 = TYPE_VALUES (t1), v2 = TYPE_VALUES (t2);\n+\t     v1 && v2;\n+\t     v1 = TREE_CHAIN (v1), v2 = TREE_CHAIN (v2))\n+\t  {\n+\t    tree c1 = TREE_VALUE (v1);\n+\t    tree c2 = TREE_VALUE (v2);\n+\n+\t    if (TREE_CODE (c1) == CONST_DECL)\n+\t      c1 = DECL_INITIAL (c1);\n+\n+\t    if (TREE_CODE (c2) == CONST_DECL)\n+\t      c2 = DECL_INITIAL (c2);\n+\n+\t    if (tree_int_cst_equal (c1, c2) != 1)\n+\t      goto different_types;\n+\t  }\n+\n+\t/* If one enumeration has more values than the other, they\n+\t   are not the same.  */\n+\tif (v1 || v2)\n+\t  goto different_types;\n+\n+\tgoto same_types;\n+      }\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      {\n+\ttree f1, f2;\n+\n+\t/* For aggregate types, all the fields must be the same.  */\n+\tfor (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n+\t     f1 && f2;\n+\t     f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\t  {\n+\t    /* The fields must have the same name, offset and type.  */\n+\t    if (DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n+\t\t|| !gimple_compare_field_offset (f1, f2)\n+\t\t|| !gimple_canonical_types_compatible_p\n+\t\t      (TREE_TYPE (f1), TREE_TYPE (f2)))\n+\t      goto different_types;\n+\t  }\n+\n+\t/* If one aggregate has more fields than the other, they\n+\t   are not the same.  */\n+\tif (f1 || f2)\n+\t  goto different_types;\n+\n+\tgoto same_types;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Common exit path for types that are not compatible.  */\n+different_types:\n+  p->same_p[GTC_DIAG] = 0;\n+  return false;\n+\n+  /* Common exit path for types that are compatible.  */\n+same_types:\n+  p->same_p[GTC_DIAG] = 1;\n+  return true;\n+}\n+\n+\n /* Returns nonzero if P1 and P2 are equal.  */\n \n static int\n gimple_canonical_type_eq (const void *p1, const void *p2)\n {\n   const_tree t1 = (const_tree) p1;\n   const_tree t2 = (const_tree) p2;\n-  return gimple_types_compatible_p (CONST_CAST_TREE (t1),\n-\t\t\t\t    CONST_CAST_TREE (t2), GTC_DIAG);\n+  return gimple_canonical_types_compatible_p (CONST_CAST_TREE (t1),\n+\t\t\t\t\t      CONST_CAST_TREE (t2));\n }\n \n /* Register type T in the global type table gimple_types."}]}