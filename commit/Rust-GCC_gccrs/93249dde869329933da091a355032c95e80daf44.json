{"sha": "93249dde869329933da091a355032c95e80daf44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMyNDlkZGU4NjkzMjk5MzNkYTA5MWEzNTUwMzJjOTVlODBkYWY0NA==", "commit": {"author": {"name": "Andreas Schwab", "email": "schwab@suse.de", "date": "2018-05-08T10:29:16Z"}, "committer": {"name": "Andreas Schwab", "email": "schwab@gcc.gnu.org", "date": "2018-05-08T10:29:16Z"}, "message": "Backport of RISC-V support for libffi\n\n* configure.host: Add RISC-V support.\n* Makefile.am: Likewise.\n* Makefile.in: Regenerate.\n* src/riscv/ffi.c, src/riscv/ffitarget.h, src/riscv/sysv.S: New\nfiles.\n\nFrom-SVN: r260033", "tree": {"sha": "3081ee7db5fb8525176ae29a143558eebad68f3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3081ee7db5fb8525176ae29a143558eebad68f3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93249dde869329933da091a355032c95e80daf44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93249dde869329933da091a355032c95e80daf44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93249dde869329933da091a355032c95e80daf44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93249dde869329933da091a355032c95e80daf44/comments", "author": {"login": "andreas-schwab", "id": 2175493, "node_id": "MDQ6VXNlcjIxNzU0OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2175493?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andreas-schwab", "html_url": "https://github.com/andreas-schwab", "followers_url": "https://api.github.com/users/andreas-schwab/followers", "following_url": "https://api.github.com/users/andreas-schwab/following{/other_user}", "gists_url": "https://api.github.com/users/andreas-schwab/gists{/gist_id}", "starred_url": "https://api.github.com/users/andreas-schwab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andreas-schwab/subscriptions", "organizations_url": "https://api.github.com/users/andreas-schwab/orgs", "repos_url": "https://api.github.com/users/andreas-schwab/repos", "events_url": "https://api.github.com/users/andreas-schwab/events{/privacy}", "received_events_url": "https://api.github.com/users/andreas-schwab/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0513e3d517795ce27335c60af6289f27c1328fb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0513e3d517795ce27335c60af6289f27c1328fb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0513e3d517795ce27335c60af6289f27c1328fb3"}], "stats": {"total": 768, "additions": 766, "deletions": 2}, "files": [{"sha": "f81c30c2bcff5aa60ac977dacefe159199a9d09f", "filename": "libffi/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93249dde869329933da091a355032c95e80daf44/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93249dde869329933da091a355032c95e80daf44/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=93249dde869329933da091a355032c95e80daf44", "patch": "@@ -1,3 +1,12 @@\n+2018-05-08  Andreas Schwab  <schwab@suse.de>\n+\n+\tBackport of RISC-V support for libffi\n+\t* configure.host: Add RISC-V support.\n+\t* Makefile.am: Likewise.\n+\t* Makefile.in: Regenerate.\n+\t* src/riscv/ffi.c, src/riscv/ffitarget.h, src/riscv/sysv.S: New\n+\tfiles.\n+\n 2018-05-04  Alan Modra  <amodra@gmail.com>\n \n \tImport from upstream"}, {"sha": "37f5ecaf3c354c51a4127baccd3feb9abe3208b6", "filename": "libffi/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93249dde869329933da091a355032c95e80daf44/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93249dde869329933da091a355032c95e80daf44/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=93249dde869329933da091a355032c95e80daf44", "patch": "@@ -138,6 +138,7 @@ noinst_HEADERS = \\\n \tsrc/or1k/ffitarget.h\t\t\t\t\t\t\\\n \tsrc/pa/ffitarget.h\t\t\t\t\t\t\\\n \tsrc/powerpc/ffitarget.h src/powerpc/asm.h src/powerpc/ffi_powerpc.h \\\n+\tsrc/riscv/ffitarget.h\t\t\t  \t\t\t\\\n \tsrc/s390/ffitarget.h\t\t\t\t\t\t\\\n \tsrc/sh/ffitarget.h\t\t\t\t\t\t\\\n \tsrc/sh64/ffitarget.h\t\t\t\t\t\t\\\n@@ -173,6 +174,7 @@ EXTRA_libffi_la_SOURCES = \\\n \t src/powerpc/linux64_closure.S src/powerpc/ppc_closure.S\t\\\n \t src/powerpc/aix.S src/powerpc/darwin.S src/powerpc/aix_closure.S \\\n \t src/powerpc/darwin_closure.S src/powerpc/ffi_darwin.c\t\t\\\n+\tsrc/riscv/ffi.c src/riscv/sysv.S\t\t\t\t\\\n \tsrc/s390/ffi.c src/s390/sysv.S\t\t\t\t\t\\\n \tsrc/sh/ffi.c src/sh/sysv.S\t\t\t\t\t\\\n \tsrc/sh64/ffi.c src/sh64/sysv.S\t\t\t\t\t\\"}, {"sha": "d395d3a8d3dd90488cf644b1b23eacf3b6d43436", "filename": "libffi/Makefile.in", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93249dde869329933da091a355032c95e80daf44/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93249dde869329933da091a355032c95e80daf44/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=93249dde869329933da091a355032c95e80daf44", "patch": "@@ -432,6 +432,7 @@ noinst_HEADERS = \\\n \tsrc/or1k/ffitarget.h\t\t\t\t\t\t\\\n \tsrc/pa/ffitarget.h\t\t\t\t\t\t\\\n \tsrc/powerpc/ffitarget.h src/powerpc/asm.h src/powerpc/ffi_powerpc.h \\\n+\tsrc/riscv/ffitarget.h\t\t\t  \t\t\t\\\n \tsrc/s390/ffitarget.h\t\t\t\t\t\t\\\n \tsrc/sh/ffitarget.h\t\t\t\t\t\t\\\n \tsrc/sh64/ffitarget.h\t\t\t\t\t\t\\\n@@ -467,6 +468,7 @@ EXTRA_libffi_la_SOURCES = \\\n \t src/powerpc/linux64_closure.S src/powerpc/ppc_closure.S\t\\\n \t src/powerpc/aix.S src/powerpc/darwin.S src/powerpc/aix_closure.S \\\n \t src/powerpc/darwin_closure.S src/powerpc/ffi_darwin.c\t\t\\\n+\tsrc/riscv/ffi.c src/riscv/sysv.S\t\t\t\t\\\n \tsrc/s390/ffi.c src/s390/sysv.S\t\t\t\t\t\\\n \tsrc/sh/ffi.c src/sh/sysv.S\t\t\t\t\t\\\n \tsrc/sh64/ffi.c src/sh64/sysv.S\t\t\t\t\t\\\n@@ -831,6 +833,16 @@ src/powerpc/darwin_closure.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n src/powerpc/ffi_darwin.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n+src/riscv/$(am__dirstamp):\n+\t@$(MKDIR_P) src/riscv\n+\t@: > src/riscv/$(am__dirstamp)\n+src/riscv/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/riscv/$(DEPDIR)\n+\t@: > src/riscv/$(DEPDIR)/$(am__dirstamp)\n+src/riscv/ffi.lo: src/riscv/$(am__dirstamp) \\\n+\tsrc/riscv/$(DEPDIR)/$(am__dirstamp)\n+src/riscv/sysv.lo: src/riscv/$(am__dirstamp) \\\n+\tsrc/riscv/$(DEPDIR)/$(am__dirstamp)\n src/s390/$(am__dirstamp):\n \t@$(MKDIR_P) src/s390\n \t@: > src/s390/$(am__dirstamp)\n@@ -1051,6 +1063,10 @@ mostlyclean-compile:\n \t-rm -f src/prep_cif.lo\n \t-rm -f src/raw_api.$(OBJEXT)\n \t-rm -f src/raw_api.lo\n+\t-rm -f src/riscv/ffi.$(OBJEXT)\n+\t-rm -f src/riscv/ffi.lo\n+\t-rm -f src/riscv/sysv.$(OBJEXT)\n+\t-rm -f src/riscv/sysv.lo\n \t-rm -f src/s390/ffi.$(OBJEXT)\n \t-rm -f src/s390/ffi.lo\n \t-rm -f src/s390/sysv.$(OBJEXT)\n@@ -1167,6 +1183,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/linux64_closure.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ppc_closure.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/sysv.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/riscv/$(DEPDIR)/ffi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/riscv/$(DEPDIR)/sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/s390/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/s390/$(DEPDIR)/sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/sh/$(DEPDIR)/ffi.Plo@am__quote@\n@@ -1268,6 +1286,7 @@ clean-libtool:\n \t-rm -rf src/or1k/.libs src/or1k/_libs\n \t-rm -rf src/pa/.libs src/pa/_libs\n \t-rm -rf src/powerpc/.libs src/powerpc/_libs\n+\t-rm -rf src/riscv/.libs src/riscv/_libs\n \t-rm -rf src/s390/.libs src/s390/_libs\n \t-rm -rf src/sh/.libs src/sh/_libs\n \t-rm -rf src/sh64/.libs src/sh64/_libs\n@@ -1672,6 +1691,8 @@ distclean-generic:\n \t-rm -f src/pa/$(am__dirstamp)\n \t-rm -f src/powerpc/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/powerpc/$(am__dirstamp)\n+\t-rm -f src/riscv/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f src/riscv/$(am__dirstamp)\n \t-rm -f src/s390/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/s390/$(am__dirstamp)\n \t-rm -f src/sh/$(DEPDIR)/$(am__dirstamp)\n@@ -1701,7 +1722,7 @@ clean-am: clean-aminfo clean-generic clean-libtool \\\n \n distclean: distclean-multi distclean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf src/$(DEPDIR) src/aarch64/$(DEPDIR) src/alpha/$(DEPDIR) src/arc/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/bfin/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/m88k/$(DEPDIR) src/metag/$(DEPDIR) src/microblaze/$(DEPDIR) src/mips/$(DEPDIR) src/moxie/$(DEPDIR) src/nios2/$(DEPDIR) src/or1k/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/tile/$(DEPDIR) src/vax/$(DEPDIR) src/x86/$(DEPDIR) src/xtensa/$(DEPDIR)\n+\t-rm -rf src/$(DEPDIR) src/aarch64/$(DEPDIR) src/alpha/$(DEPDIR) src/arc/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/bfin/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/m88k/$(DEPDIR) src/metag/$(DEPDIR) src/microblaze/$(DEPDIR) src/mips/$(DEPDIR) src/moxie/$(DEPDIR) src/nios2/$(DEPDIR) src/or1k/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/riscv/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/tile/$(DEPDIR) src/vax/$(DEPDIR) src/x86/$(DEPDIR) src/xtensa/$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-hdr distclean-libtool distclean-tags\n@@ -1840,7 +1861,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf src/$(DEPDIR) src/aarch64/$(DEPDIR) src/alpha/$(DEPDIR) src/arc/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/bfin/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/m88k/$(DEPDIR) src/metag/$(DEPDIR) src/microblaze/$(DEPDIR) src/mips/$(DEPDIR) src/moxie/$(DEPDIR) src/nios2/$(DEPDIR) src/or1k/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/tile/$(DEPDIR) src/vax/$(DEPDIR) src/x86/$(DEPDIR) src/xtensa/$(DEPDIR)\n+\t-rm -rf src/$(DEPDIR) src/aarch64/$(DEPDIR) src/alpha/$(DEPDIR) src/arc/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/bfin/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/m88k/$(DEPDIR) src/metag/$(DEPDIR) src/microblaze/$(DEPDIR) src/mips/$(DEPDIR) src/moxie/$(DEPDIR) src/nios2/$(DEPDIR) src/or1k/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/riscv/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/tile/$(DEPDIR) src/vax/$(DEPDIR) src/x86/$(DEPDIR) src/xtensa/$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-aminfo \\\n \tmaintainer-clean-generic maintainer-clean-vti"}, {"sha": "786b32c5bb00c3efb76d6daf15a024ea4c7e00d4", "filename": "libffi/configure.host", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93249dde869329933da091a355032c95e80daf44/libffi%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93249dde869329933da091a355032c95e80daf44/libffi%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.host?ref=93249dde869329933da091a355032c95e80daf44", "patch": "@@ -195,6 +195,11 @@ case \"${host}\" in\n \tTARGET=POWERPC; TARGETDIR=powerpc\n \t;;\n \n+  riscv*-*)\n+\tTARGET=RISCV; TARGETDIR=riscv\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n   s390-*-* | s390x-*-*)\n \tTARGET=S390; TARGETDIR=s390\n \tSOURCES=\"ffi.c sysv.S\""}, {"sha": "b664ee7d4ed286539cfa484b80d720356911b753", "filename": "libffi/src/riscv/ffi.c", "status": "added", "additions": 445, "deletions": 0, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93249dde869329933da091a355032c95e80daf44/libffi%2Fsrc%2Friscv%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93249dde869329933da091a355032c95e80daf44/libffi%2Fsrc%2Friscv%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Friscv%2Fffi.c?ref=93249dde869329933da091a355032c95e80daf44", "patch": "@@ -0,0 +1,445 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (c) 2015 Michael Knyszek <mknyszek@berkeley.edu>\n+                         2015 Andrew Waterman <waterman@cs.berkeley.edu>\n+                         2018 Stef O'Rear <sorear2@gmail.com>\n+   Based on MIPS N32/64 port\n+\n+   RISC-V Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+#include <stdint.h>\n+\n+#if __riscv_float_abi_double\n+#define ABI_FLEN 64\n+#define ABI_FLOAT double\n+#elif __riscv_float_abi_single\n+#define ABI_FLEN 32\n+#define ABI_FLOAT float\n+#endif\n+\n+#define NARGREG 8\n+#define STKALIGN 16\n+#define MAXCOPYARG (2 * sizeof(double))\n+\n+typedef struct call_context\n+{\n+#if ABI_FLEN\n+    ABI_FLOAT fa[8];\n+#endif\n+    size_t a[8];\n+    /* used by the assembly code to in-place construct its own stack frame */\n+    char frame[16];\n+} call_context;\n+\n+typedef struct call_builder\n+{\n+    call_context *aregs;\n+    int used_integer;\n+    int used_float;\n+    size_t *used_stack;\n+} call_builder;\n+\n+/* integer (not pointer) less than ABI XLEN */\n+/* FFI_TYPE_INT does not appear to be used */\n+#if __SIZEOF_POINTER__ == 8\n+#define IS_INT(type) ((type) >= FFI_TYPE_UINT8 && (type) <= FFI_TYPE_SINT64)\n+#else\n+#define IS_INT(type) ((type) >= FFI_TYPE_UINT8 && (type) <= FFI_TYPE_SINT32)\n+#endif\n+\n+#if ABI_FLEN\n+typedef struct {\n+    char as_elements, type1, offset2, type2;\n+} float_struct_info;\n+\n+#if ABI_FLEN >= 64\n+#define IS_FLOAT(type) ((type) >= FFI_TYPE_FLOAT && (type) <= FFI_TYPE_DOUBLE)\n+#else\n+#define IS_FLOAT(type) ((type) == FFI_TYPE_FLOAT)\n+#endif\n+\n+static ffi_type **flatten_struct(ffi_type *in, ffi_type **out, ffi_type **out_end) {\n+    int i;\n+    if (out == out_end) return out;\n+    if (in->type != FFI_TYPE_STRUCT) {\n+        *(out++) = in;\n+    } else {\n+        for (i = 0; in->elements[i]; i++)\n+            out = flatten_struct(in->elements[i], out, out_end);\n+    }\n+    return out;\n+}\n+\n+/* Structs with at most two fields after flattening, one of which is of\n+   floating point type, are passed in multiple registers if sufficient\n+   registers are available. */\n+static float_struct_info struct_passed_as_elements(call_builder *cb, ffi_type *top) {\n+    float_struct_info ret = {0, 0, 0, 0};\n+    ffi_type *fields[3];\n+    int num_floats, num_ints;\n+    int num_fields = flatten_struct(top, fields, fields + 3) - fields;\n+\n+    if (num_fields == 1) {\n+        if (IS_FLOAT(fields[0]->type)) {\n+            ret.as_elements = 1;\n+            ret.type1 = fields[0]->type;\n+        }\n+    } else if (num_fields == 2) {\n+        num_floats = IS_FLOAT(fields[0]->type) + IS_FLOAT(fields[1]->type);\n+        num_ints = IS_INT(fields[0]->type) + IS_INT(fields[1]->type);\n+        if (num_floats == 0 || num_floats + num_ints != 2)\n+            return ret;\n+        if (cb->used_float + num_floats > NARGREG || cb->used_integer + (2 - num_floats) > NARGREG)\n+            return ret;\n+        if (!IS_FLOAT(fields[0]->type) && !IS_FLOAT(fields[1]->type))\n+            return ret;\n+\n+        ret.type1 = fields[0]->type;\n+        ret.type2 = fields[1]->type;\n+        ret.offset2 = ALIGN(fields[0]->size, fields[1]->alignment);\n+        ret.as_elements = 1;\n+    }\n+\n+    return ret;\n+}\n+#endif\n+\n+/* allocates a single register, float register, or XLEN-sized stack slot to a datum */\n+static void marshal_atom(call_builder *cb, int type, void *data) {\n+    size_t value = 0;\n+    switch (type) {\n+        case FFI_TYPE_UINT8: value = *(uint8_t *)data; break;\n+        case FFI_TYPE_SINT8: value = *(int8_t *)data; break;\n+        case FFI_TYPE_UINT16: value = *(uint16_t *)data; break;\n+        case FFI_TYPE_SINT16: value = *(int16_t *)data; break;\n+        /* 32-bit quantities are always sign-extended in the ABI */\n+        case FFI_TYPE_UINT32: value = *(int32_t *)data; break;\n+        case FFI_TYPE_SINT32: value = *(int32_t *)data; break;\n+#if __SIZEOF_POINTER__ == 8\n+        case FFI_TYPE_UINT64: value = *(uint64_t *)data; break;\n+        case FFI_TYPE_SINT64: value = *(int64_t *)data; break;\n+#endif\n+        case FFI_TYPE_POINTER: value = *(size_t *)data; break;\n+\n+        /* float values may be recoded in an implementation-defined way\n+           by hardware conforming to 2.1 or earlier, so use asm to\n+           reinterpret floats as doubles */\n+#if ABI_FLEN >= 32\n+        case FFI_TYPE_FLOAT:\n+            asm(\"\" : \"=f\"(cb->aregs->fa[cb->used_float++]) : \"0\"(*(float *)data));\n+            return;\n+#endif\n+#if ABI_FLEN >= 64\n+        case FFI_TYPE_DOUBLE:\n+            asm(\"\" : \"=f\"(cb->aregs->fa[cb->used_float++]) : \"0\"(*(double *)data));\n+            return;\n+#endif\n+        default: FFI_ASSERT(0); break;\n+    }\n+\n+    if (cb->used_integer == NARGREG) {\n+        *cb->used_stack++ = value;\n+    } else {\n+        cb->aregs->a[cb->used_integer++] = value;\n+    }\n+}\n+\n+static void unmarshal_atom(call_builder *cb, int type, void *data) {\n+    size_t value;\n+    switch (type) {\n+#if ABI_FLEN >= 32\n+        case FFI_TYPE_FLOAT:\n+            asm(\"\" : \"=f\"(*(float *)data) : \"0\"(cb->aregs->fa[cb->used_float++]));\n+            return;\n+#endif\n+#if ABI_FLEN >= 64\n+        case FFI_TYPE_DOUBLE:\n+            asm(\"\" : \"=f\"(*(double *)data) : \"0\"(cb->aregs->fa[cb->used_float++]));\n+            return;\n+#endif\n+    }\n+\n+    if (cb->used_integer == NARGREG) {\n+        value = *cb->used_stack++;\n+    } else {\n+        value = cb->aregs->a[cb->used_integer++];\n+    }\n+\n+    switch (type) {\n+        case FFI_TYPE_UINT8: *(uint8_t *)data = value; break;\n+        case FFI_TYPE_SINT8: *(uint8_t *)data = value; break;\n+        case FFI_TYPE_UINT16: *(uint16_t *)data = value; break;\n+        case FFI_TYPE_SINT16: *(uint16_t *)data = value; break;\n+        case FFI_TYPE_UINT32: *(uint32_t *)data = value; break;\n+        case FFI_TYPE_SINT32: *(uint32_t *)data = value; break;\n+#if __SIZEOF_POINTER__ == 8\n+        case FFI_TYPE_UINT64: *(uint64_t *)data = value; break;\n+        case FFI_TYPE_SINT64: *(uint64_t *)data = value; break;\n+#endif\n+        case FFI_TYPE_POINTER: *(size_t *)data = value; break;\n+        default: FFI_ASSERT(0); break;\n+    }\n+}\n+\n+/* adds an argument to a call, or a not by reference return value */\n+static void marshal(call_builder *cb, ffi_type *type, int var, void *data) {\n+    size_t realign[2];\n+\n+#if ABI_FLEN\n+    if (!var && type->type == FFI_TYPE_STRUCT) {\n+        float_struct_info fsi = struct_passed_as_elements(cb, type);\n+        if (fsi.as_elements) {\n+            marshal_atom(cb, fsi.type1, data);\n+            if (fsi.offset2)\n+                marshal_atom(cb, fsi.type2, ((char*)data) + fsi.offset2);\n+            return;\n+        }\n+    }\n+\n+    if (!var && cb->used_float < NARGREG && IS_FLOAT(type->type)) {\n+        marshal_atom(cb, type->type, data);\n+        return;\n+    }\n+#endif\n+\n+    if (type->size > 2 * __SIZEOF_POINTER__) {\n+        /* pass by reference */\n+        marshal_atom(cb, FFI_TYPE_POINTER, &data);\n+    } else if (IS_INT(type->type) || type->type == FFI_TYPE_POINTER) {\n+        marshal_atom(cb, type->type, data);\n+    } else {\n+        /* overlong integers, soft-float floats, and structs without special\n+           float handling are treated identically from this point on */\n+\n+        /* variadics are aligned even in registers */\n+        if (type->alignment > __SIZEOF_POINTER__) {\n+            if (var)\n+                cb->used_integer = ALIGN(cb->used_integer, 2);\n+            cb->used_stack = (size_t *)ALIGN(cb->used_stack, 2*__SIZEOF_POINTER__);\n+        }\n+\n+        memcpy(realign, data, type->size);\n+        if (type->size > 0)\n+            marshal_atom(cb, FFI_TYPE_POINTER, realign);\n+        if (type->size > __SIZEOF_POINTER__)\n+            marshal_atom(cb, FFI_TYPE_POINTER, realign + 1);\n+    }\n+}\n+\n+/* for arguments passed by reference returns the pointer, otherwise the arg is copied (up to MAXCOPYARG bytes) */\n+static void *unmarshal(call_builder *cb, ffi_type *type, int var, void *data) {\n+    size_t realign[2];\n+    void *pointer;\n+\n+#if ABI_FLEN\n+    if (!var && type->type == FFI_TYPE_STRUCT) {\n+        float_struct_info fsi = struct_passed_as_elements(cb, type);\n+        if (fsi.as_elements) {\n+            unmarshal_atom(cb, fsi.type1, data);\n+            if (fsi.offset2)\n+                unmarshal_atom(cb, fsi.type2, ((char*)data) + fsi.offset2);\n+            return data;\n+        }\n+    }\n+\n+    if (!var && cb->used_float < NARGREG && IS_FLOAT(type->type)) {\n+        unmarshal_atom(cb, type->type, data);\n+        return data;\n+    }\n+#endif\n+\n+    if (type->size > 2 * __SIZEOF_POINTER__) {\n+        /* pass by reference */\n+        unmarshal_atom(cb, FFI_TYPE_POINTER, (char*)&pointer);\n+        return pointer;\n+    } else if (IS_INT(type->type) || type->type == FFI_TYPE_POINTER) {\n+        unmarshal_atom(cb, type->type, data);\n+        return data;\n+    } else {\n+        /* overlong integers, soft-float floats, and structs without special\n+           float handling are treated identically from this point on */\n+\n+        /* variadics are aligned even in registers */\n+        if (type->alignment > __SIZEOF_POINTER__) {\n+            if (var)\n+                cb->used_integer = ALIGN(cb->used_integer, 2);\n+            cb->used_stack = (size_t *)ALIGN(cb->used_stack, 2*__SIZEOF_POINTER__);\n+        }\n+\n+        if (type->size > 0)\n+            unmarshal_atom(cb, FFI_TYPE_POINTER, realign);\n+        if (type->size > __SIZEOF_POINTER__)\n+            unmarshal_atom(cb, FFI_TYPE_POINTER, realign + 1);\n+        memcpy(data, realign, type->size);\n+        return data;\n+    }\n+}\n+\n+static int passed_by_ref(call_builder *cb, ffi_type *type, int var) {\n+#if ABI_FLEN\n+    if (!var && type->type == FFI_TYPE_STRUCT) {\n+        float_struct_info fsi = struct_passed_as_elements(cb, type);\n+        if (fsi.as_elements) return 0;\n+    }\n+#endif\n+\n+    return type->size > 2 * __SIZEOF_POINTER__;\n+}\n+\n+/* Perform machine dependent cif processing */\n+ffi_status ffi_prep_cif_machdep(ffi_cif *cif) {\n+    cif->riscv_nfixedargs = cif->nargs;\n+    return FFI_OK;\n+}\n+\n+/* Perform machine dependent cif processing when we have a variadic function */\n+\n+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs, unsigned int ntotalargs) {\n+    cif->riscv_nfixedargs = nfixedargs;\n+    return FFI_OK;\n+}\n+\n+/* Low level routine for calling functions */\n+extern void ffi_call_asm(void *stack, struct call_context *regs, void (*fn)(void)) FFI_HIDDEN;\n+\n+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+    /* this is a conservative estimate, assuming a complex return value and\n+       that all remaining arguments are long long / __int128 */\n+    size_t arg_bytes = cif->nargs <= 3 ? 0 :\n+        ALIGN(2 * sizeof(size_t) * (cif->nargs - 3), STKALIGN);\n+    size_t rval_bytes = 0;\n+    if (rvalue == NULL && cif->rtype->size > 2*__SIZEOF_POINTER__)\n+        rval_bytes = ALIGN(cif->rtype->size, STKALIGN);\n+    size_t alloc_size = arg_bytes + rval_bytes + sizeof(call_context);\n+\n+    /* the assembly code will deallocate all stack data at lower addresses\n+       than the argument region, so we need to allocate the frame and the\n+       return value after the arguments in a single allocation */\n+    size_t alloc_base;\n+    /* Argument region must be 16-byte aligned */\n+    if (_Alignof(max_align_t) >= STKALIGN) {\n+        /* since sizeof long double is normally 16, the compiler will\n+           guarantee alloca alignment to at least that much */\n+        alloc_base = (size_t)alloca(alloc_size);\n+    } else {\n+        alloc_base = ALIGN(alloca(alloc_size + STKALIGN - 1), STKALIGN);\n+    }\n+\n+    if (rval_bytes)\n+        rvalue = (void*)(alloc_base + arg_bytes);\n+\n+    call_builder cb;\n+    cb.used_float = cb.used_integer = 0;\n+    cb.aregs = (call_context*)(alloc_base + arg_bytes + rval_bytes);\n+    cb.used_stack = (void*)alloc_base;\n+\n+    int return_by_ref = passed_by_ref(&cb, cif->rtype, 0);\n+    if (return_by_ref)\n+        marshal(&cb, &ffi_type_pointer, 0, &rvalue);\n+\n+    int i;\n+    for (i = 0; i < cif->nargs; i++)\n+        marshal(&cb, cif->arg_types[i], i >= cif->riscv_nfixedargs, avalue[i]);\n+\n+    ffi_call_asm((void*)alloc_base, cb.aregs, fn);\n+\n+    cb.used_float = cb.used_integer = 0;\n+    if (!return_by_ref && rvalue)\n+        unmarshal(&cb, cif->rtype, 0, rvalue);\n+}\n+\n+extern void ffi_closure_asm(void) FFI_HIDDEN;\n+\n+ffi_status ffi_prep_closure_loc(ffi_closure *closure, ffi_cif *cif, void (*fun)(ffi_cif*,void*,void**,void*), void *user_data, void *codeloc)\n+{\n+    uint32_t *tramp = (uint32_t *) &closure->tramp[0];\n+    uint64_t fn = (uint64_t) (uintptr_t) ffi_closure_asm;\n+\n+    if (cif->abi <= FFI_FIRST_ABI || cif->abi >= FFI_LAST_ABI)\n+        return FFI_BAD_ABI;\n+\n+    /* we will call ffi_closure_inner with codeloc, not closure, but as long\n+       as the memory is readable it should work */\n+\n+    tramp[0] = 0x00000317; /* auipc t1, 0 (i.e. t0 <- codeloc) */\n+#if __SIZEOF_POINTER__ == 8\n+    tramp[1] = 0x01033383; /* ld t2, 16(t1) */\n+#else\n+    tramp[1] = 0x01032383; /* lw t2, 16(t1) */\n+#endif\n+    tramp[2] = 0x00038067; /* jr t2 */\n+    tramp[3] = 0x00000013; /* nop */\n+    tramp[4] = fn;\n+    tramp[5] = fn >> 32;\n+\n+    closure->cif = cif;\n+    closure->fun = fun;\n+    closure->user_data = user_data;\n+\n+    __builtin___clear_cache(codeloc, codeloc + FFI_TRAMPOLINE_SIZE);\n+\n+    return FFI_OK;\n+}\n+\n+/* Called by the assembly code with aregs pointing to saved argument registers\n+   and stack pointing to the stacked arguments.  Return values passed in\n+   registers will be reloaded from aregs. */\n+void FFI_HIDDEN ffi_closure_inner(size_t *stack, call_context *aregs, ffi_closure *closure) {\n+    ffi_cif *cif = closure->cif;\n+    void **avalue = alloca(cif->nargs * sizeof(void*));\n+    /* storage for arguments which will be copied by unmarshal().  We could\n+       theoretically avoid the copies in many cases and use at most 128 bytes\n+       of memory, but allocating disjoint storage for each argument is\n+       simpler. */\n+    char *astorage = alloca(cif->nargs * MAXCOPYARG);\n+    void *rvalue;\n+    call_builder cb;\n+    int return_by_ref;\n+    int i;\n+\n+    cb.aregs = aregs;\n+    cb.used_integer = cb.used_float = 0;\n+    cb.used_stack = stack;\n+\n+    return_by_ref = passed_by_ref(&cb, cif->rtype, 0);\n+    if (return_by_ref)\n+        unmarshal(&cb, &ffi_type_pointer, 0, &rvalue);\n+    else\n+        rvalue = alloca(cif->rtype->size);\n+\n+    for (i = 0; i < cif->nargs; i++)\n+        avalue[i] = unmarshal(&cb, cif->arg_types[i],\n+            i >= cif->riscv_nfixedargs, astorage + i*MAXCOPYARG);\n+\n+    (closure->fun)(cif, rvalue, avalue, closure->user_data);\n+\n+    if (!return_by_ref && cif->rtype->type != FFI_TYPE_VOID) {\n+        cb.used_integer = cb.used_float = 0;\n+        marshal(&cb, cif->rtype, 0, rvalue);\n+    }\n+}"}, {"sha": "fcaa8991533077cc4339289cff69b41c66929ec0", "filename": "libffi/src/riscv/ffitarget.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93249dde869329933da091a355032c95e80daf44/libffi%2Fsrc%2Friscv%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93249dde869329933da091a355032c95e80daf44/libffi%2Fsrc%2Friscv%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Friscv%2Fffitarget.h?ref=93249dde869329933da091a355032c95e80daf44", "patch": "@@ -0,0 +1,68 @@\n+/* -----------------------------------------------------------------*-C-*-\n+   ffitarget.h - 2014 Michael Knyszek\n+\n+   Target configuration macros for RISC-V.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n+#ifndef __riscv\n+#error \"libffi was configured for a RISC-V target but this does not appear to be a RISC-V compiler.\"\n+#endif\n+\n+#ifndef LIBFFI_ASM\n+\n+typedef unsigned long ffi_arg;\n+typedef   signed long ffi_sarg;\n+\n+/* FFI_UNUSED_NN and riscv_unused are to maintain ABI compatibility with a\n+   distributed Berkeley patch from 2014, and can be removed at SONAME bump */\n+typedef enum ffi_abi {\n+    FFI_FIRST_ABI = 0,\n+    FFI_SYSV,\n+    FFI_UNUSED_1,\n+    FFI_UNUSED_2,\n+    FFI_UNUSED_3,\n+    FFI_LAST_ABI,\n+\n+    FFI_DEFAULT_ABI = FFI_SYSV\n+} ffi_abi;\n+\n+#endif /* LIBFFI_ASM */\n+\n+/* ---- Definitions for closures ----------------------------------------- */\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 24\n+#define FFI_NATIVE_RAW_API 0\n+#define FFI_EXTRA_CIF_FIELDS unsigned riscv_nfixedargs; unsigned riscv_unused;\n+#define FFI_TARGET_SPECIFIC_VARIADIC\n+\n+#endif\n+"}, {"sha": "2d098651d0da14ff81866fb5a1dd1247f518ad24", "filename": "libffi/src/riscv/sysv.S", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93249dde869329933da091a355032c95e80daf44/libffi%2Fsrc%2Friscv%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93249dde869329933da091a355032c95e80daf44/libffi%2Fsrc%2Friscv%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Friscv%2Fsysv.S?ref=93249dde869329933da091a355032c95e80daf44", "patch": "@@ -0,0 +1,214 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (c) 2015 Michael Knyszek <mknyszek@berkeley.edu>\n+                         2015 Andrew Waterman <waterman@cs.berkeley.edu>\n+                         2018 Stef O'Rear <sorear2@gmail.com>\n+\n+   RISC-V Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+/* Define aliases so that we can handle all ABIs uniformly */\n+\n+#if __SIZEOF_POINTER__ == 8\n+#define PTRS 8\n+#define LARG ld\n+#define SARG sd\n+#else\n+#define PTRS 4\n+#define LARG lw\n+#define SARG sw\n+#endif\n+\n+#if __riscv_float_abi_double\n+#define FLTS 8\n+#define FLARG fld\n+#define FSARG fsd\n+#elif __riscv_float_abi_single\n+#define FLTS 4\n+#define FLARG flw\n+#define FSARG fsw\n+#else\n+#define FLTS 0\n+#endif\n+\n+#define fp s0\n+\n+    .text\n+    .globl  ffi_call_asm\n+    .type   ffi_call_asm, @function\n+    .hidden ffi_call_asm\n+/*\n+  struct call_context {\n+      floatreg fa[8];\n+      intreg a[8];\n+      intreg pad[rv32 ? 2 : 0];\n+      intreg save_fp, save_ra;\n+  }\n+  void ffi_call_asm(size_t *stackargs, struct call_context *regargs,\n+      void (*fn)(void));\n+*/\n+\n+#define FRAME_LEN (8 * FLTS + 8 * PTRS + 16)\n+\n+ffi_call_asm:\n+    .cfi_startproc\n+\n+    /*\n+      We are NOT going to set up an ordinary stack frame.  In order to pass\n+      the stacked args to the called function, we adjust our stack pointer to\n+      a0, which is in the _caller's_ alloca area.  We establish our own stack\n+      frame at the end of the call_context.\n+\n+      Anything below the arguments will be freed at this point, although we\n+      preserve the call_context so that it can be read back in the caller.\n+    */\n+\n+    .cfi_def_cfa 11, FRAME_LEN # interim CFA based on a1\n+    SARG    fp, FRAME_LEN - 2*PTRS(a1)\n+    .cfi_offset 8, -2*PTRS\n+    SARG    ra, FRAME_LEN - 1*PTRS(a1)\n+    .cfi_offset 1, -1*PTRS\n+\n+    addi    fp, a1, FRAME_LEN\n+    mv      sp, a0\n+    .cfi_def_cfa 8, 0 # our frame is fully set up\n+\n+    # Load arguments\n+    mv      t1, a2\n+\n+#if FLTS\n+    FLARG   fa0, -FRAME_LEN+0*FLTS(fp)\n+    FLARG   fa1, -FRAME_LEN+1*FLTS(fp)\n+    FLARG   fa2, -FRAME_LEN+2*FLTS(fp)\n+    FLARG   fa3, -FRAME_LEN+3*FLTS(fp)\n+    FLARG   fa4, -FRAME_LEN+4*FLTS(fp)\n+    FLARG   fa5, -FRAME_LEN+5*FLTS(fp)\n+    FLARG   fa6, -FRAME_LEN+6*FLTS(fp)\n+    FLARG   fa7, -FRAME_LEN+7*FLTS(fp)\n+#endif\n+\n+    LARG    a0, -FRAME_LEN+8*FLTS+0*PTRS(fp)\n+    LARG    a1, -FRAME_LEN+8*FLTS+1*PTRS(fp)\n+    LARG    a2, -FRAME_LEN+8*FLTS+2*PTRS(fp)\n+    LARG    a3, -FRAME_LEN+8*FLTS+3*PTRS(fp)\n+    LARG    a4, -FRAME_LEN+8*FLTS+4*PTRS(fp)\n+    LARG    a5, -FRAME_LEN+8*FLTS+5*PTRS(fp)\n+    LARG    a6, -FRAME_LEN+8*FLTS+6*PTRS(fp)\n+    LARG    a7, -FRAME_LEN+8*FLTS+7*PTRS(fp)\n+\n+    /* Call */\n+    jalr    t1\n+\n+    /* Save return values - only a0/a1 (fa0/fa1) are used */\n+#if FLTS\n+    FSARG   fa0, -FRAME_LEN+0*FLTS(fp)\n+    FSARG   fa1, -FRAME_LEN+1*FLTS(fp)\n+#endif\n+\n+    SARG    a0, -FRAME_LEN+8*FLTS+0*PTRS(fp)\n+    SARG    a1, -FRAME_LEN+8*FLTS+1*PTRS(fp)\n+\n+    /* Restore and return */\n+    addi    sp, fp, -FRAME_LEN\n+    .cfi_def_cfa 2, FRAME_LEN\n+    LARG    ra, -1*PTRS(fp)\n+    .cfi_restore 1\n+    LARG    fp, -2*PTRS(fp)\n+    .cfi_restore 8\n+    ret\n+    .cfi_endproc\n+    .size   ffi_call_asm, .-ffi_call_asm\n+\n+\n+/*\n+  ffi_closure_asm. Expects address of the passed-in ffi_closure in t1.\n+  void ffi_closure_inner(size_t *stackargs, struct call_context *regargs,\n+      ffi_closure *closure);\n+*/\n+\n+    .globl ffi_closure_asm\n+    .hidden ffi_closure_asm\n+    .type ffi_closure_asm, @function\n+ffi_closure_asm:\n+    .cfi_startproc\n+\n+    addi    sp,  sp, -FRAME_LEN\n+    .cfi_def_cfa_offset FRAME_LEN\n+\n+    /* make a frame */\n+    SARG    fp, FRAME_LEN - 2*PTRS(sp)\n+    .cfi_offset 8, -2*PTRS\n+    SARG    ra, FRAME_LEN - 1*PTRS(sp)\n+    .cfi_offset 1, -1*PTRS\n+    addi    fp, sp, FRAME_LEN\n+\n+    /* save arguments */\n+#if FLTS\n+    FSARG   fa0, 0*FLTS(sp)\n+    FSARG   fa1, 1*FLTS(sp)\n+    FSARG   fa2, 2*FLTS(sp)\n+    FSARG   fa3, 3*FLTS(sp)\n+    FSARG   fa4, 4*FLTS(sp)\n+    FSARG   fa5, 5*FLTS(sp)\n+    FSARG   fa6, 6*FLTS(sp)\n+    FSARG   fa7, 7*FLTS(sp)\n+#endif\n+\n+    SARG    a0, 8*FLTS+0*PTRS(sp)\n+    SARG    a1, 8*FLTS+1*PTRS(sp)\n+    SARG    a2, 8*FLTS+2*PTRS(sp)\n+    SARG    a3, 8*FLTS+3*PTRS(sp)\n+    SARG    a4, 8*FLTS+4*PTRS(sp)\n+    SARG    a5, 8*FLTS+5*PTRS(sp)\n+    SARG    a6, 8*FLTS+6*PTRS(sp)\n+    SARG    a7, 8*FLTS+7*PTRS(sp)\n+\n+    /* enter C */\n+    addi    a0, sp, FRAME_LEN\n+    mv      a1, sp\n+    mv      a2, t1\n+\n+    call    ffi_closure_inner\n+\n+    /* return values */\n+#if FLTS\n+    FLARG   fa0, 0*FLTS(sp)\n+    FLARG   fa1, 1*FLTS(sp)\n+#endif\n+\n+    LARG    a0, 8*FLTS+0*PTRS(sp)\n+    LARG    a1, 8*FLTS+1*PTRS(sp)\n+\n+    /* restore and return */\n+    LARG    ra, FRAME_LEN-1*PTRS(sp)\n+    .cfi_restore 1\n+    LARG    fp, FRAME_LEN-2*PTRS(sp)\n+    .cfi_restore 8\n+    addi    sp, sp, FRAME_LEN\n+    .cfi_def_cfa_offset 0\n+    ret\n+    .cfi_endproc\n+    .size ffi_closure_asm, .-ffi_closure_asm"}]}