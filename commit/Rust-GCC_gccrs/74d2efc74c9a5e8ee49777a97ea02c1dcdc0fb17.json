{"sha": "74d2efc74c9a5e8ee49777a97ea02c1dcdc0fb17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRkMmVmYzc0YzlhNWU4ZWU0OTc3N2E5N2VhMDJjMWRjZGMwZmIxNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-04-23T00:47:12Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-04-23T00:47:12Z"}, "message": "tree-ssa-dom.c (block_defs_stack): Remove, no longer needed.\n\n\n\t* tree-ssa-dom.c (block_defs_stack): Remove, no longer needed.\n\t(restore_currdefs_to_original_value): Likewise.\n\t(register_definitions_for_stmt): Likewise.\n\t(tree_ssa_dominator_optimize): No longer initialize CURRENT_DEF\n\tfor each variable.  Do not allocate/free block_defs_stack either.\n\tDo not iterate if we just thread jumps.  Only iterate if the\n\ttree_cleanup_cfg does useful work (temporary).\n\t(dom_opt_initialize_block): No longer push a marker on\n\tBLOCK_DEFS_STACK.\n\t(dom_opt_finalize_block): Removal call to restore currdefs.\n\tRelax restrictions for recording edge equivalences.\n\t(record_equivalences_from_phis): No longer need to track\n\tCURRENT_DEF.\n\t(optimize_stmt): Similarly.\n\t(thread_across_edge): Simplify by removing the requirement that\n\tstatements in the block we are threading through must be nops.\n\t(initialize_hash_element): Handle GOTO_EXPR.\n\nFrom-SVN: r98597", "tree": {"sha": "d704ef62de9cdd8dadf634c28ac937831d0aa4e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d704ef62de9cdd8dadf634c28ac937831d0aa4e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74d2efc74c9a5e8ee49777a97ea02c1dcdc0fb17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74d2efc74c9a5e8ee49777a97ea02c1dcdc0fb17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74d2efc74c9a5e8ee49777a97ea02c1dcdc0fb17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74d2efc74c9a5e8ee49777a97ea02c1dcdc0fb17/comments", "author": null, "committer": null, "parents": [{"sha": "ca075703f52bf7185e6f1016370743a29c11b9a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca075703f52bf7185e6f1016370743a29c11b9a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca075703f52bf7185e6f1016370743a29c11b9a6"}], "stats": {"total": 285, "additions": 124, "deletions": 161}, "files": [{"sha": "3a5e70256d3745feb54d7cec0a3844b1f6110077", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d2efc74c9a5e8ee49777a97ea02c1dcdc0fb17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d2efc74c9a5e8ee49777a97ea02c1dcdc0fb17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74d2efc74c9a5e8ee49777a97ea02c1dcdc0fb17", "patch": "@@ -1,3 +1,23 @@\n+2005-04-22  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (block_defs_stack): Remove, no longer needed.\n+\t(restore_currdefs_to_original_value): Likewise.\n+\t(register_definitions_for_stmt): Likewise.\n+\t(tree_ssa_dominator_optimize): No longer initialize CURRENT_DEF\n+\tfor each variable.  Do not allocate/free block_defs_stack either.\n+\tDo not iterate if we just thread jumps.  Only iterate if the\n+\ttree_cleanup_cfg does useful work (temporary).\n+\t(dom_opt_initialize_block): No longer push a marker on\n+\tBLOCK_DEFS_STACK.\n+\t(dom_opt_finalize_block): Removal call to restore currdefs.\n+\tRelax restrictions for recording edge equivalences.\n+\t(record_equivalences_from_phis): No longer need to track\n+\tCURRENT_DEF.\n+\t(optimize_stmt): Similarly.\n+\t(thread_across_edge): Simplify by removing the requirement that\n+\tstatements in the block we are threading through must be nops.\n+\t(initialize_hash_element): Handle GOTO_EXPR.\n+\n 2005-04-22  David S. Miller  <davem@davemloft.net>\n \n \t* sched-vis.c (print_value): Use CONST_DOUBLE_LOW and"}, {"sha": "d78886b0a72351bbba27af60226bcede24dc3528", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 104, "deletions": 161, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d2efc74c9a5e8ee49777a97ea02c1dcdc0fb17/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d2efc74c9a5e8ee49777a97ea02c1dcdc0fb17/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=74d2efc74c9a5e8ee49777a97ea02c1dcdc0fb17", "patch": "@@ -96,19 +96,6 @@ static htab_t avail_exprs;\n    marker.  */\n static VEC(tree,heap) *avail_exprs_stack;\n \n-/* Stack of trees used to restore the global currdefs to its original\n-   state after completing optimization of a block and its dominator children.\n-\n-   An SSA_NAME indicates that the current definition of the underlying\n-   variable should be set to the given SSA_NAME.\n-\n-   A _DECL node indicates that the underlying variable has no current\n-   definition.\n-\n-   A NULL node is used to mark the last node associated with the\n-   current block.  */\n-static VEC(tree,heap) *block_defs_stack;\n-\n /* Stack of statements we need to rescan during finalization for newly\n    exposed variables.\n \n@@ -295,8 +282,6 @@ static void dom_opt_initialize_block (struct dom_walk_data *, basic_block);\n static void propagate_to_outgoing_edges (struct dom_walk_data *, basic_block);\n static void remove_local_expressions_from_table (void);\n static void restore_vars_to_original_value (void);\n-static void restore_currdefs_to_original_value (void);\n-static void register_definitions_for_stmt (tree);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n static void restore_nonzero_vars_to_original_value (void);\n static inline bool unsafe_associative_fp_binop (tree);\n@@ -376,14 +361,10 @@ tree_ssa_dominator_optimize (void)\n \n   memset (&opt_stats, 0, sizeof (opt_stats));\n \n-  for (i = 0; i < num_referenced_vars; i++)\n-    var_ann (referenced_var (i))->current_def = NULL;\n-\n   /* Create our hash tables.  */\n   avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free);\n   vrp_data = htab_create (ceil_log2 (num_ssa_names), vrp_hash, vrp_eq, free);\n   avail_exprs_stack = VEC_alloc (tree, heap, 20);\n-  block_defs_stack = VEC_alloc (tree, heap, 20);\n   const_and_copies_stack = VEC_alloc (tree, heap, 20);\n   nonzero_vars_stack = VEC_alloc (tree, heap, 20);\n   vrp_variables_stack = VEC_alloc (tree, heap, 20);\n@@ -475,7 +456,7 @@ tree_ssa_dominator_optimize (void)\n       if (cfg_altered)\n         free_dominance_info (CDI_DOMINATORS);\n \n-      cfg_altered |= cleanup_tree_cfg ();\n+      cfg_altered = cleanup_tree_cfg ();\n \n       if (rediscover_loops_after_threading)\n \t{\n@@ -500,9 +481,6 @@ tree_ssa_dominator_optimize (void)\n       htab_empty (avail_exprs);\n       htab_empty (vrp_data);\n \n-      for (i = 0; i < num_referenced_vars; i++)\n-\tvar_ann (referenced_var (i))->current_def = NULL;\n-\n       /* Finally, remove everything except invariants in SSA_NAME_VALUE.\n \n \t This must be done before we iterate as we might have a\n@@ -545,7 +523,6 @@ tree_ssa_dominator_optimize (void)\n   BITMAP_FREE (nonzero_vars);\n   BITMAP_FREE (need_eh_cleanup);\n   \n-  VEC_free (tree, heap, block_defs_stack);\n   VEC_free (tree, heap, avail_exprs_stack);\n   VEC_free (tree, heap, const_and_copies_stack);\n   VEC_free (tree, heap, nonzero_vars_stack);\n@@ -579,8 +556,20 @@ struct tree_opt_pass pass_dominator =\n };\n \n \n-/* We are exiting BB, see if the target block begins with a conditional\n-   jump which has a known value when reached via BB.  */\n+/* We are exiting E->src, see if E->dest ends with a conditional\n+   jump which has a known value when reached via E. \n+\n+   Special care is necessary if E is a back edge in the CFG as we\n+   will have already recorded equivalences for E->dest into our\n+   various tables, including the result of the conditional at\n+   the end of E->dest.  Threading opportunities are severely\n+   limited in that case to avoid short-circuiting the loop\n+   incorrectly.\n+\n+   Note it is quite common for the first block inside a loop to\n+   end with a conditional which is either always true or always\n+   false when reached via the loop backedge.  Thus we do not want\n+   to blindly disable threading across a loop backedge.  */\n \n static void\n thread_across_edge (struct dom_walk_data *walk_data, edge e)\n@@ -589,61 +578,100 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n   tree stmt = NULL;\n   tree phi;\n \n-  /* Each PHI creates a temporary equivalence, record them.  */\n+  /* If E->dest does not end with a conditional, then there is\n+     nothing to do.  */\n+  bsi = bsi_last (e->dest);\n+  if (bsi_end_p (bsi)\n+      || ! bsi_stmt (bsi)\n+      || (TREE_CODE (bsi_stmt (bsi)) != COND_EXPR\n+\t  && TREE_CODE (bsi_stmt (bsi)) != GOTO_EXPR\n+\t  && TREE_CODE (bsi_stmt (bsi)) != SWITCH_EXPR))\n+    return;\n+\n+  /* The basic idea here is to use whatever knowledge we have\n+     from our dominator walk to simplify statements in E->dest,\n+     with the ultimate goal being to simplify the conditional\n+     at the end of E->dest.\n+\n+     Note that we must undo any changes we make to the underlying\n+     statements as the simplifications we are making are control\n+     flow sensitive (ie, the simplifications are valid when we \n+     traverse E, but may not be valid on other paths to E->dest.  */\n+     \n+  /* Each PHI creates a temporary equivalence, record them.  Again\n+     these are context sensitive equivalences and will be removed\n+     by our caller.  */\n   for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n     {\n       tree src = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       tree dst = PHI_RESULT (phi);\n \n       /* If the desired argument is not the same as this PHI's result \n-\t and it is set by a PHI in this block, then we can not thread\n-\t through this block.  */\n+\t and it is set by a PHI in E->dest, then we can not thread\n+\t through E->dest.  */\n       if (src != dst\n \t  && TREE_CODE (src) == SSA_NAME\n \t  && TREE_CODE (SSA_NAME_DEF_STMT (src)) == PHI_NODE\n \t  && bb_for_stmt (SSA_NAME_DEF_STMT (src)) == e->dest)\n \treturn;\n \n       record_const_or_copy (dst, src);\n-      register_new_def (dst, &block_defs_stack);\n     }\n \n+  /* Try to simplify each statement in E->dest, ultimately leading to\n+     a simplification of the COND_EXPR at the end of E->dest.\n+\n+     We might consider marking just those statements which ultimately\n+     feed the COND_EXPR.  It's not clear if the overhead of bookkeeping\n+     would be recovered by trying to simplify fewer statements.\n+\n+     If we are able to simplify a statement into the form\n+     SSA_NAME = (SSA_NAME | gimple invariant), then we can record\n+     a context sensitive equivalency which may help us simplify\n+     later statements in E->dest. \n+\n+     Failure to simplify into the form above merely means that the\n+     statement provides no equivalences to help simplify later\n+     statements.  This does not prevent threading through E->dest.  */\n   for (bsi = bsi_start (e->dest); ! bsi_end_p (bsi); bsi_next (&bsi))\n     {\n-      tree lhs, cached_lhs;\n+      tree cached_lhs;\n \n       stmt = bsi_stmt (bsi);\n \n       /* Ignore empty statements and labels.  */\n       if (IS_EMPTY_STMT (stmt) || TREE_CODE (stmt) == LABEL_EXPR)\n \tcontinue;\n \n+      /* Safely handle threading across loop backedges.  This is\n+\t over conservative, but still allows us to capture the\n+\t majority of the cases where we can thread across a loop\n+\t backedge.  */\n+      if ((e->flags & EDGE_DFS_BACK) != 0\n+\t  && TREE_CODE (stmt) != COND_EXPR\n+\t  && TREE_CODE (stmt) != SWITCH_EXPR)\n+\treturn;\n+\n+      /* If the statement has volatile operands, then we assume we\n+\t can not thread through this block.  This is overly\n+\t conservative in some ways.  */\n+      if (TREE_CODE (stmt) == ASM_EXPR && ASM_VOLATILE_P (stmt))\n+\treturn;\n+\n       /* If this is not a MODIFY_EXPR which sets an SSA_NAME to a new\n-\t value, then stop our search here.  Ideally when we stop a\n-\t search we stop on a COND_EXPR or SWITCH_EXPR.  */\n+\t value, then do not try to simplify this statement as it will\n+\t not simplify in any way that is helpful for jump threading.  */\n       if (TREE_CODE (stmt) != MODIFY_EXPR\n \t  || TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n-\tbreak;\n+\tcontinue;\n \n       /* At this point we have a statement which assigns an RHS to an\n-\t SSA_VAR on the LHS.  We want to prove that the RHS is already\n-\t available and that its value is held in the current definition\n-\t of the LHS -- meaning that this assignment is a NOP when\n-\t reached via edge E.  */\n+\t SSA_VAR on the LHS.  We want to try and simplify this statement\n+\t to expose more context sensitive equivalences which in turn may\n+\t allow us to simplify the condition at the end of the loop.  */\n       if (TREE_CODE (TREE_OPERAND (stmt, 1)) == SSA_NAME)\n \tcached_lhs = TREE_OPERAND (stmt, 1);\n       else\n-\tcached_lhs = lookup_avail_expr (stmt, false);\n-\n-      lhs = TREE_OPERAND (stmt, 0);\n-\n-      /* This can happen if we thread around to the start of a loop.  */\n-      if (lhs == cached_lhs)\n-\tbreak;\n-\n-      /* If we did not find RHS in the hash table, then try again after\n-\t temporarily const/copy propagating the operands.  */\n-      if (!cached_lhs)\n \t{\n \t  /* Copy the operands.  */\n \t  stmt_ann_t ann = stmt_ann (stmt);\n@@ -678,8 +706,13 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t\tSET_VUSE_OP (vuses, i, tmp);\n \t    }\n \n-\t  /* Try to lookup the new expression.  */\n-\t  cached_lhs = lookup_avail_expr (stmt, false);\n+\t  /* Try to fold/lookup the new expression.  Inserting the\n+\t     expression into the hash table is unlikely to help\n+\t     simplify anything later, so just query the hashtable.  */\n+\t  cached_lhs = fold (TREE_OPERAND (stmt, 1));\n+\t  if (TREE_CODE (cached_lhs) != SSA_NAME\n+\t      && !is_gimple_min_invariant (cached_lhs))\n+\t    cached_lhs = lookup_avail_expr (stmt, false);\n \n \t  /* Restore the statement's original uses/defs.  */\n \t  for (i = 0; i < NUM_USES (uses); i++)\n@@ -690,45 +723,22 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \n \t  free (uses_copy);\n \t  free (vuses_copy);\n-\n-\t  /* If we still did not find the expression in the hash table,\n-\t     then we can not ignore this statement.  */\n-\t  if (! cached_lhs)\n-\t    break;\n \t}\n \n-      /* If the expression in the hash table was not assigned to an\n-\t SSA_NAME, then we can not ignore this statement.  */\n-      if (TREE_CODE (cached_lhs) != SSA_NAME)\n-\tbreak;\n-\n-      /* If we have different underlying variables, then we can not\n-\t ignore this statement.  */\n-      if (SSA_NAME_VAR (cached_lhs) != SSA_NAME_VAR (lhs))\n-\tbreak;\n-\n-      /* If CACHED_LHS does not represent the current value of the underlying\n-\t variable in CACHED_LHS/LHS, then we can not ignore this statement.  */\n-      if (var_ann (SSA_NAME_VAR (lhs))->current_def != cached_lhs)\n-\tbreak;\n-\n-      /* If we got here, then we can ignore this statement and continue\n-\t walking through the statements in the block looking for a threadable\n-\t COND_EXPR.\n-\n-\t We want to record an equivalence lhs = cache_lhs so that if\n-\t the result of this statement is used later we can copy propagate\n-\t suitably.  */\n-      record_const_or_copy (lhs, cached_lhs);\n-      register_new_def (lhs, &block_defs_stack);\n+      /* Record the context sensitive equivalence if we were able\n+\t to simplify this statement.  */\n+      if (cached_lhs\n+\t  && (TREE_CODE (cached_lhs) == SSA_NAME\n+\t      || is_gimple_min_invariant (cached_lhs)))\n+\trecord_const_or_copy (TREE_OPERAND (stmt, 0), cached_lhs);\n     }\n \n-  /* If we stopped at a COND_EXPR or SWITCH_EXPR, then see if we know which\n-     arm will be taken.  */\n+  /* If we stopped at a COND_EXPR or SWITCH_EXPR, see if we know which arm\n+     will be taken.  */\n   if (stmt\n       && (TREE_CODE (stmt) == COND_EXPR\n-\t  || TREE_CODE (stmt) == SWITCH_EXPR\n-\t  || TREE_CODE (stmt) == GOTO_EXPR))\n+\t  || TREE_CODE (stmt) == GOTO_EXPR\n+\t  || TREE_CODE (stmt) == SWITCH_EXPR))\n     {\n       tree cond, cached_lhs;\n \n@@ -802,7 +812,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t  cached_lhs = cond;\n \t  cached_lhs = SSA_NAME_VALUE (cached_lhs);\n \t  if (cached_lhs && ! is_gimple_min_invariant (cached_lhs))\n-\t    cached_lhs = 0;\n+\t    cached_lhs = NULL;\n \t}\n       else\n \tcached_lhs = lookup_avail_expr (stmt, false);\n@@ -851,7 +861,6 @@ dom_opt_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   /* Push a marker on the stacks of local information so that we know how\n      far to unwind when we finalize this block.  */\n   VEC_safe_push (tree, heap, avail_exprs_stack, NULL_TREE);\n-  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n   VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n   VEC_safe_push (tree, heap, nonzero_vars_stack, NULL_TREE);\n   VEC_safe_push (tree, heap, vrp_variables_stack, NULL_TREE);\n@@ -893,6 +902,11 @@ initialize_hash_element (tree expr, tree lhs, struct expr_hash_elt *element)\n       element->ann = stmt_ann (expr);\n       element->rhs = TREE_OPERAND (TREE_OPERAND (expr, 0), 1);\n     }\n+  else if (TREE_CODE (expr) == GOTO_EXPR)\n+    {\n+      element->ann = stmt_ann (expr);\n+      element->rhs = GOTO_DESTINATION (expr);\n+    }\n   else\n     {\n       element->ann = stmt_ann (expr);\n@@ -961,39 +975,6 @@ restore_vars_to_original_value (void)\n     }\n }\n \n-/* Similar to restore_vars_to_original_value, except that it restores \n-   CURRDEFS to its original value.  */\n-static void\n-restore_currdefs_to_original_value (void)\n-{\n-  /* Restore CURRDEFS to its original state.  */\n-  while (VEC_length (tree, block_defs_stack) > 0)\n-    {\n-      tree tmp = VEC_pop (tree, block_defs_stack);\n-      tree saved_def, var;\n-\n-      if (tmp == NULL_TREE)\n-\tbreak;\n-\n-      /* If we recorded an SSA_NAME, then make the SSA_NAME the current\n-\t definition of its underlying variable.  If we recorded anything\n-\t else, it must have been an _DECL node and its current reaching\n-\t definition must have been NULL.  */\n-      if (TREE_CODE (tmp) == SSA_NAME)\n-\t{\n-\t  saved_def = tmp;\n-\t  var = SSA_NAME_VAR (saved_def);\n-\t}\n-      else\n-\t{\n-\t  saved_def = NULL;\n-\t  var = tmp;\n-\t}\n-                                                                                \n-      var_ann (var)->current_def = saved_def;\n-    }\n-}\n-\n /* We have finished processing the dominator children of BB, perform\n    any finalization actions in preparation for leaving this node in\n    the dominator tree.  */\n@@ -1051,7 +1032,6 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t     unwind any expressions related to the TRUE arm before processing\n \t     the false arm below.  */\n \t  VEC_safe_push (tree, heap, avail_exprs_stack, NULL_TREE);\n-\t  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n \t  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n \n \t  edge_info = true_edge->aux;\n@@ -1064,15 +1044,8 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t      tree lhs = edge_info->lhs;\n \t      tree rhs = edge_info->rhs;\n \n-\t      /* If we have a simple NAME = VALUE equivalency record it.\n-\t\t Until the jump threading selection code improves, only\n-\t\t do this if both the name and value are SSA_NAMEs with\n-\t\t the same underlying variable to avoid missing threading\n-\t\t opportunities.  */\n-\t      if (lhs\n-\t\t  && TREE_CODE (COND_EXPR_COND (last)) == SSA_NAME\n-\t\t  && TREE_CODE (edge_info->rhs) == SSA_NAME\n-\t\t  && SSA_NAME_VAR (lhs) == SSA_NAME_VAR (rhs))\n+\t      /* If we have a simple NAME = VALUE equivalency record it.  */\n+\t      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t\trecord_const_or_copy (lhs, rhs);\n \n \t      /* If we have 0 = COND or 1 = COND equivalences, record them\n@@ -1094,7 +1067,6 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t     we threaded this edge.  */\n \t  remove_local_expressions_from_table ();\n \t  restore_vars_to_original_value ();\n-\t  restore_currdefs_to_original_value ();\n \t}\n \n       /* Similarly for the ELSE arm.  */\n@@ -1114,13 +1086,8 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t      tree lhs = edge_info->lhs;\n \t      tree rhs = edge_info->rhs;\n \n-\t      /* If we have a simple NAME = VALUE equivalency record it.\n-\t\t Until the jump threading selection code improves, only\n-\t\t do this if both the name and value are SSA_NAMEs with\n-\t\t the same underlying variable to avoid missing threading\n-\t\t opportunities.  */\n-\t      if (lhs\n-\t\t  && TREE_CODE (COND_EXPR_COND (last)) == SSA_NAME)\n+\t      /* If we have a simple NAME = VALUE equivalency record it.  */\n+\t      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t\trecord_const_or_copy (lhs, rhs);\n \n \t      /* If we have 0 = COND or 1 = COND equivalences, record them\n@@ -1146,7 +1113,6 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n   remove_local_expressions_from_table ();\n   restore_nonzero_vars_to_original_value ();\n   restore_vars_to_original_value ();\n-  restore_currdefs_to_original_value ();\n \n   /* Remove VRP records associated with this basic block.  They are no\n      longer valid.\n@@ -1273,7 +1239,6 @@ record_equivalences_from_phis (basic_block bb)\n       if (i == PHI_NUM_ARGS (phi))\n \tbitmap_set_bit (nonzero_vars, SSA_NAME_VERSION (PHI_RESULT (phi)));\n \n-      register_new_def (lhs, &block_defs_stack);\n     }\n }\n \n@@ -3075,8 +3040,6 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n \t\t\t\t   may_optimize_p,\n \t\t\t\t   ann);\n \n-  register_definitions_for_stmt (stmt);\n-\n   /* If STMT is a COND_EXPR and it was modified, then we may know\n      where it goes.  If that is the case, then mark the CFG as altered.\n \n@@ -3518,23 +3481,3 @@ avail_expr_eq (const void *p1, const void *p2)\n \n   return false;\n }\n-\n-/* Given STMT and a pointer to the block local definitions BLOCK_DEFS_P,\n-   register register all objects set by this statement into BLOCK_DEFS_P\n-   and CURRDEFS.  */\n-\n-static void\n-register_definitions_for_stmt (tree stmt)\n-{\n-  tree def;\n-  ssa_op_iter iter;\n-\n-  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n-    {\n-\n-      /* FIXME: We shouldn't be registering new defs if the variable\n-\t doesn't need to be renamed.  */\n-      register_new_def (def, &block_defs_stack);\n-    }\n-}\n-"}]}