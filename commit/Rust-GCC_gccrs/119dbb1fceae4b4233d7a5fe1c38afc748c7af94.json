{"sha": "119dbb1fceae4b4233d7a5fe1c38afc748c7af94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE5ZGJiMWZjZWFlNGI0MjMzZDdhNWZlMWMzOGFmYzc0OGM3YWY5NA==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@optonline.net", "date": "2003-07-15T07:30:29Z"}, "committer": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2003-07-15T07:30:29Z"}, "message": "stl_algo.h (includes, [...]): Document.\n\n2003-07-15  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* include/bits/stl_algo.h (includes, set_union, set_intersection,\n        set_difference, set_symmetric_difference, max_element, min_element,\n        next_permutation, prev_permutation, find_first_of, find_end):\n        Document.\n\t* include/bits/stl_algobase.h (copy,copy_backward):  Clarify overlap\n        restrictions in docs.\n\t* include/bits/stl_heap.h (push_heap, pop_heap, make_heap, sort_heap):\n        Document.\n\t* docs/doxygen/doxygroups.cc (setoperations):  New group.\n\nFrom-SVN: r69387", "tree": {"sha": "651952a1909b071f7631e3a90c01e7b2fec7e335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/651952a1909b071f7631e3a90c01e7b2fec7e335"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/119dbb1fceae4b4233d7a5fe1c38afc748c7af94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/119dbb1fceae4b4233d7a5fe1c38afc748c7af94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/119dbb1fceae4b4233d7a5fe1c38afc748c7af94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/119dbb1fceae4b4233d7a5fe1c38afc748c7af94/comments", "author": {"login": "jlquinn", "id": 826841, "node_id": "MDQ6VXNlcjgyNjg0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/826841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlquinn", "html_url": "https://github.com/jlquinn", "followers_url": "https://api.github.com/users/jlquinn/followers", "following_url": "https://api.github.com/users/jlquinn/following{/other_user}", "gists_url": "https://api.github.com/users/jlquinn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlquinn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlquinn/subscriptions", "organizations_url": "https://api.github.com/users/jlquinn/orgs", "repos_url": "https://api.github.com/users/jlquinn/repos", "events_url": "https://api.github.com/users/jlquinn/events{/privacy}", "received_events_url": "https://api.github.com/users/jlquinn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "284f19bf1781669a37e938648591f2078c92764f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/284f19bf1781669a37e938648591f2078c92764f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/284f19bf1781669a37e938648591f2078c92764f"}], "stats": {"total": 449, "additions": 444, "deletions": 5}, "files": [{"sha": "320ee442cad83a4ad5f1bf12d5cb68efc9ef1823", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119dbb1fceae4b4233d7a5fe1c38afc748c7af94/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119dbb1fceae4b4233d7a5fe1c38afc748c7af94/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=119dbb1fceae4b4233d7a5fe1c38afc748c7af94", "patch": "@@ -1,3 +1,15 @@\n+2003-07-15  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* include/bits/stl_algo.h (includes, set_union, set_intersection,\n+        set_difference, set_symmetric_difference, max_element, min_element,\n+        next_permutation, prev_permutation, find_first_of, find_end):\n+        Document.\n+\t* include/bits/stl_algobase.h (copy,copy_backward):  Clarify overlap\n+        restrictions in docs.\n+\t* include/bits/stl_heap.h (push_heap, pop_heap, make_heap, sort_heap):\n+        Document.\n+\t* docs/doxygen/doxygroups.cc (setoperations):  New group.\n+\n 2003-07-15  Jerry Quinn  <jlquinn@optonline.net>\n \n         * include/bits/basic_string.h:  Document public functions."}, {"sha": "a1f3b2809a59998e55e89d5be7f9924ab77c8358", "filename": "libstdc++-v3/docs/doxygen/doxygroups.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119dbb1fceae4b4233d7a5fe1c38afc748c7af94/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fdoxygroups.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119dbb1fceae4b4233d7a5fe1c38afc748c7af94/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fdoxygroups.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fdoxygroups.cc?ref=119dbb1fceae4b4233d7a5fe1c38afc748c7af94", "patch": "@@ -201,6 +201,14 @@ passed by the user doesn't necessarily need to induce a strict weak ordering\n relation.  Rather, it partitions the range.\n */\n \n+// // // // // // // // // // // // // // // // // // // // // // // //\n+/** @addtogroup setoperations Set operation algorithms\n+These algorithms are common set operations performed on sequences that are\n+already sorted.\n+\n+The number of comparisons will be linear.\n+*/\n+\n // // // // // // // // // // // // // // // // // // // // // // // //\n \n // // // // // // // // // // // // // // // // // // // // // // // //"}, {"sha": "7b3fa9d423296cc35004c796c01efbe08c0d1c7c", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119dbb1fceae4b4233d7a5fe1c38afc748c7af94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119dbb1fceae4b4233d7a5fe1c38afc748c7af94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=119dbb1fceae4b4233d7a5fe1c38afc748c7af94", "patch": "@@ -3593,6 +3593,22 @@ namespace std\n   // that their input ranges are sorted and the postcondition that their output\n   // ranges are sorted.\n \n+  /**\n+   *  @brief Determines whether all elements of a sequence exists in a range.\n+   *  @param  first1  Start of search range.\n+   *  @param  last1   End of search range.\n+   *  @param  first2  Start of sequence\n+   *  @param  last2   End of sequence.\n+   *  @return  True if each element in [first2,last2) is contained in order\n+   *  within [first1,last1).  False otherwise.\n+   *  @ingroup setoperations\n+   *\n+   *  This operation expects both [first1,last1) and [first2,last2) to be\n+   *  sorted.  Searches for the presence of each element in [first2,last2)\n+   *  within [first1,last1).  The iterators over each range only move forward,\n+   *  so this is a linear algorithm.  If an element in [first2,last2) is not\n+   *  found before the search iterator reaches @a last2, false is returned.\n+  */\n   template<typename _InputIterator1, typename _InputIterator2>\n     bool\n     includes(_InputIterator1 __first1, _InputIterator1 __last1,\n@@ -3618,6 +3634,25 @@ namespace std\n       return __first2 == __last2;\n     }\n \n+  /**\n+   *  @brief Determines whether all elements of a sequence exists in a range\n+   *  using comparison.\n+   *  @param  first1  Start of search range.\n+   *  @param  last1   End of search range.\n+   *  @param  first2  Start of sequence\n+   *  @param  last2   End of sequence.\n+   *  @param  comp    Comparison function to use.\n+   *  @return  True if each element in [first2,last2) is contained in order\n+   *  within [first1,last1) according to comp.  False otherwise.\n+   *  @ingroup setoperations\n+   *\n+   *  This operation expects both [first1,last1) and [first2,last2) to be\n+   *  sorted.  Searches for the presence of each element in [first2,last2)\n+   *  within [first1,last1), using comp to decide.  The iterators over each\n+   *  range only move forward, so this is a linear algorithm.  If an element\n+   *  in [first2,last2) is not found before the search iterator reaches @a\n+   *  last2, false is returned.\n+  */\n   template<typename _InputIterator1, typename _InputIterator2, typename _Compare>\n     bool\n     includes(_InputIterator1 __first1, _InputIterator1 __last1,\n@@ -3644,6 +3679,23 @@ namespace std\n       return __first2 == __last2;\n     }\n \n+  /**\n+   *  @brief Return the union of two sorted ranges.\n+   *  @param  first1  Start of first range.\n+   *  @param  last1   End of first range.\n+   *  @param  first2  Start of second range.\n+   *  @param  last2   End of second range.\n+   *  @return  End of the output range.\n+   *  @ingroup setoperations\n+   *\n+   *  This operation iterates over both ranges, copying elements present in\n+   *  each range in order to the output range.  Iterators increment for each\n+   *  range.  When the current element of one range is less than the other,\n+   *  that element is copied and the iterator advanced.  If an element is\n+   *  contained in both ranges, the element from the first range is copied and\n+   *  both ranges advance.  The output range may not overlap either input\n+   *  range.\n+  */\n   template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator>\n     _OutputIterator\n     set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n@@ -3680,6 +3732,24 @@ namespace std\n       return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));\n     }\n \n+  /**\n+   *  @brief Return the union of two sorted ranges using a comparison functor.\n+   *  @param  first1  Start of first range.\n+   *  @param  last1   End of first range.\n+   *  @param  first2  Start of second range.\n+   *  @param  last2   End of second range.\n+   *  @param  comp    The comparison functor.\n+   *  @return  End of the output range.\n+   *  @ingroup setoperations\n+   *\n+   *  This operation iterates over both ranges, copying elements present in\n+   *  each range in order to the output range.  Iterators increment for each\n+   *  range.  When the current element of one range is less than the other\n+   *  according to @a comp, that element is copied and the iterator advanced.\n+   *  If an equivalent element according to @a comp is contained in both\n+   *  ranges, the element from the first range is copied and both ranges\n+   *  advance.  The output range may not overlap either input range.\n+  */\n   template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator,\n \t   typename _Compare>\n     _OutputIterator\n@@ -3718,6 +3788,22 @@ namespace std\n       return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));\n     }\n \n+  /**\n+   *  @brief Return the intersection of two sorted ranges.\n+   *  @param  first1  Start of first range.\n+   *  @param  last1   End of first range.\n+   *  @param  first2  Start of second range.\n+   *  @param  last2   End of second range.\n+   *  @return  End of the output range.\n+   *  @ingroup setoperations\n+   *\n+   *  This operation iterates over both ranges, copying elements present in\n+   *  both ranges in order to the output range.  Iterators increment for each\n+   *  range.  When the current element of one range is less than the other,\n+   *  that iterator advances.  If an element is contained in both ranges, the\n+   *  element from the first range is copied and both ranges advance.  The\n+   *  output range may not overlap either input range.\n+  */\n   template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator>\n     _OutputIterator\n     set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n@@ -3749,6 +3835,25 @@ namespace std\n       return __result;\n     }\n \n+  /**\n+   *  @brief Return the intersection of two sorted ranges using comparison\n+   *  functor. \n+   *  @param  first1  Start of first range.\n+   *  @param  last1   End of first range.\n+   *  @param  first2  Start of second range.\n+   *  @param  last2   End of second range.\n+   *  @param  comp    The comparison functor.\n+   *  @return  End of the output range.\n+   *  @ingroup setoperations\n+   *\n+   *  This operation iterates over both ranges, copying elements present in\n+   *  both ranges in order to the output range.  Iterators increment for each\n+   *  range.  When the current element of one range is less than the other\n+   *  according to @a comp, that iterator advances.  If an element is\n+   *  contained in both ranges according to @a comp, the element from the\n+   *  first range is copied and both ranges advance.  The output range may not\n+   *  overlap either input range.\n+  */\n   template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator,\n \t   typename _Compare>\n     _OutputIterator\n@@ -3782,6 +3887,24 @@ namespace std\n       return __result;\n     }\n \n+  /**\n+   *  @brief Return the difference of two sorted ranges.\n+   *  @param  first1  Start of first range.\n+   *  @param  last1   End of first range.\n+   *  @param  first2  Start of second range.\n+   *  @param  last2   End of second range.\n+   *  @return  End of the output range.\n+   *  @ingroup setoperations\n+   *\n+   *  This operation iterates over both ranges, copying elements present in\n+   *  the first range but not the second in order to the output range.\n+   *  Iterators increment for each range.  When the current element of the\n+   *  first range is less than the second, that element is copied and the\n+   *  iterator advances.  If the current element of the second range is less,\n+   *  the iterator advances, but no element is copied.  If an element is\n+   *  contained in both ranges, no elements are copied and both ranges\n+   *  advance.  The output range may not overlap either input range.\n+  */\n   template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator>\n     _OutputIterator\n     set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n@@ -3814,6 +3937,27 @@ namespace std\n       return std::copy(__first1, __last1, __result);\n     }\n \n+  /**\n+   *  @brief  Return the difference of two sorted ranges using comparison\n+   *  functor.\n+   *  @param  first1  Start of first range.\n+   *  @param  last1   End of first range.\n+   *  @param  first2  Start of second range.\n+   *  @param  last2   End of second range.\n+   *  @param  comp    The comparison functor.\n+   *  @return  End of the output range.\n+   *  @ingroup setoperations\n+   *\n+   *  This operation iterates over both ranges, copying elements present in\n+   *  the first range but not the second in order to the output range.\n+   *  Iterators increment for each range.  When the current element of the\n+   *  first range is less than the second according to @a comp, that element\n+   *  is copied and the iterator advances.  If the current element of the\n+   *  second range is less, no element is copied and the iterator advances.\n+   *  If an element is contained in both ranges according to @a comp, no\n+   *  elements are copied and both ranges advance.  The output range may not\n+   *  overlap either input range.\n+  */\n   template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator,\n \t   typename _Compare>\n     _OutputIterator\n@@ -3848,6 +3992,22 @@ namespace std\n       return std::copy(__first1, __last1, __result);\n     }\n \n+  /**\n+   *  @brief  Return the symmetric difference of two sorted ranges.\n+   *  @param  first1  Start of first range.\n+   *  @param  last1   End of first range.\n+   *  @param  first2  Start of second range.\n+   *  @param  last2   End of second range.\n+   *  @return  End of the output range.\n+   *  @ingroup setoperations\n+   *\n+   *  This operation iterates over both ranges, copying elements present in\n+   *  one range but not the other in order to the output range.  Iterators\n+   *  increment for each range.  When the current element of one range is less\n+   *  than the other, that element is copied and the iterator advances.  If an\n+   *  element is contained in both ranges, no elements are copied and both\n+   *  ranges advance.  The output range may not overlap either input range.\n+  */\n   template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator>\n     _OutputIterator\n     set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n@@ -3883,6 +4043,25 @@ namespace std\n       return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));\n     }\n \n+  /**\n+   *  @brief  Return the symmetric difference of two sorted ranges using\n+   *  comparison functor.\n+   *  @param  first1  Start of first range.\n+   *  @param  last1   End of first range.\n+   *  @param  first2  Start of second range.\n+   *  @param  last2   End of second range.\n+   *  @param  comp    The comparison functor.\n+   *  @return  End of the output range.\n+   *  @ingroup setoperations\n+   *\n+   *  This operation iterates over both ranges, copying elements present in\n+   *  one range but not the other in order to the output range.  Iterators\n+   *  increment for each range.  When the current element of one range is less\n+   *  than the other according to @a comp, that element is copied and the\n+   *  iterator advances.  If an element is contained in both ranges according\n+   *  to @a comp, no elements are copied and both ranges advance.  The output\n+   *  range may not overlap either input range.\n+  */\n   template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator,\n \t   typename _Compare>\n     _OutputIterator\n@@ -3924,6 +4103,12 @@ namespace std\n   // min_element and max_element, with and without an explicitly supplied\n   // comparison function.\n \n+  /**\n+   *  @brief  Return the maximum element in a range.\n+   *  @param  first  Start of range.\n+   *  @param  last   End of range.\n+   *  @return  Iterator referencing the first instance of the largest value.\n+  */\n   template<typename _ForwardIterator>\n     _ForwardIterator\n     max_element(_ForwardIterator __first, _ForwardIterator __last)\n@@ -3941,6 +4126,14 @@ namespace std\n       return __result;\n     }\n \n+  /**\n+   *  @brief  Return the maximum element in a range using comparison functor.\n+   *  @param  first  Start of range.\n+   *  @param  last   End of range.\n+   *  @param  comp   Comparison functor.\n+   *  @return  Iterator referencing the first instance of the largest value\n+   *  according to comp.\n+  */\n   template<typename _ForwardIterator, typename _Compare>\n     _ForwardIterator\n     max_element(_ForwardIterator __first, _ForwardIterator __last,\n@@ -3959,6 +4152,12 @@ namespace std\n       return __result;\n     }\n \n+  /**\n+   *  @brief  Return the minimum element in a range.\n+   *  @param  first  Start of range.\n+   *  @param  last   End of range.\n+   *  @return  Iterator referencing the first instance of the smallest value.\n+  */\n   template<typename _ForwardIterator>\n     _ForwardIterator\n     min_element(_ForwardIterator __first, _ForwardIterator __last)\n@@ -3976,6 +4175,14 @@ namespace std\n       return __result;\n     }\n \n+  /**\n+   *  @brief  Return the minimum element in a range using comparison functor.\n+   *  @param  first  Start of range.\n+   *  @param  last   End of range.\n+   *  @param  comp   Comparison functor.\n+   *  @return  Iterator referencing the first instance of the smallest value\n+   *  according to comp.\n+  */\n   template<typename _ForwardIterator, typename _Compare>\n     _ForwardIterator\n     min_element(_ForwardIterator __first, _ForwardIterator __last,\n@@ -3998,6 +4205,17 @@ namespace std\n   // next_permutation and prev_permutation, with and without an explicitly\n   // supplied comparison function.\n \n+  /**\n+   *  @brief  Permute range into the next \"dictionary\" ordering.\n+   *  @param  first  Start of range.\n+   *  @param  last   End of range.\n+   *  @return  False if wrapped to first permutation, true otherwise.\n+   *\n+   *  Treats all permutations of the range as a set of \"dictionary\" sorted\n+   *  sequences.  Permutes the current sequence into the next one of this set.\n+   *  Returns true if there are more sequences to generate.  If the sequence\n+   *  is the largest of the set, the smallest is generated and false returned.\n+  */\n   template<typename _BidirectionalIterator>\n     bool\n     next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n@@ -4034,6 +4252,20 @@ namespace std\n       }\n     }\n \n+  /**\n+   *  @brief  Permute range into the next \"dictionary\" ordering using\n+   *  comparison functor.\n+   *  @param  first  Start of range.\n+   *  @param  last   End of range.\n+   *  @param  comp   \n+   *  @return  False if wrapped to first permutation, true otherwise.\n+   *\n+   *  Treats all permutations of the range [first,last) as a set of\n+   *  \"dictionary\" sorted sequences ordered by @a comp.  Permutes the current\n+   *  sequence into the next one of this set.  Returns true if there are more\n+   *  sequences to generate.  If the sequence is the largest of the set, the\n+   *  smallest is generated and false returned.\n+  */\n   template<typename _BidirectionalIterator, typename _Compare>\n     bool\n     next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last,\n@@ -4072,6 +4304,18 @@ namespace std\n       }\n     }\n \n+  /**\n+   *  @brief  Permute range into the previous \"dictionary\" ordering.\n+   *  @param  first  Start of range.\n+   *  @param  last   End of range.\n+   *  @return  False if wrapped to last permutation, true otherwise.\n+   *\n+   *  Treats all permutations of the range as a set of \"dictionary\" sorted\n+   *  sequences.  Permutes the current sequence into the previous one of this\n+   *  set.  Returns true if there are more sequences to generate.  If the\n+   *  sequence is the smallest of the set, the largest is generated and false\n+   *  returned.\n+  */\n   template<typename _BidirectionalIterator>\n     bool\n     prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n@@ -4108,6 +4352,20 @@ namespace std\n       }\n     }\n \n+  /**\n+   *  @brief  Permute range into the previous \"dictionary\" ordering using\n+   *  comparison functor.\n+   *  @param  first  Start of range.\n+   *  @param  last   End of range.\n+   *  @param  comp   \n+   *  @return  False if wrapped to last permutation, true otherwise.\n+   *\n+   *  Treats all permutations of the range [first,last) as a set of\n+   *  \"dictionary\" sorted sequences ordered by @a comp.  Permutes the current\n+   *  sequence into the previous one of this set.  Returns true if there are\n+   *  more sequences to generate.  If the sequence is the smallest of the set,\n+   *  the largest is generated and false returned.\n+  */\n   template<typename _BidirectionalIterator, typename _Compare>\n     bool\n     prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last,\n@@ -4148,6 +4406,20 @@ namespace std\n \n   // find_first_of, with and without an explicitly supplied comparison function.\n \n+  /**\n+   *  @brief  Find element from a set in a sequence.\n+   *  @param  first1  Start of range to search.\n+   *  @param  last1   End of range to search.\n+   *  @param  first2  Start of match candidates.\n+   *  @param  last2   End of match candidates.\n+   *  @return   The first iterator @c i in the range\n+   *  @p [first1,last1) such that @c *i == @p *(i2) such that i2 is an\n+   *  interator in [first2,last2), or @p last1 if no such iterator exists.\n+   *\n+   *  Searches the range @p [first1,last1) for an element that is equal to\n+   *  some element in the range [first2,last2).  If found, returns an iterator\n+   *  in the range [first1,last1), otherwise returns @p last1.\n+  */\n   template<typename _InputIterator, typename _ForwardIterator>\n     _InputIterator\n     find_first_of(_InputIterator __first1, _InputIterator __last1,\n@@ -4167,6 +4439,21 @@ namespace std\n       return __last1;\n     }\n \n+  /**\n+   *  @brief  Find element from a set in a sequence using a predicate.\n+   *  @param  first1  Start of range to search.\n+   *  @param  last1   End of range to search.\n+   *  @param  first2  Start of match candidates.\n+   *  @param  last2   End of match candidates.\n+   *  @param  comp    Predicate to use.\n+   *  @return   The first iterator @c i in the range\n+   *  @p [first1,last1) such that @c comp(*i, @p *(i2)) is true and i2 is an\n+   *  interator in [first2,last2), or @p last1 if no such iterator exists.\n+   *\n+   *  Searches the range @p [first1,last1) for an element that is equal to\n+   *  some element in the range [first2,last2).  If found, returns an iterator in\n+   *  the range [first1,last1), otherwise returns @p last1.\n+  */\n   template<typename _InputIterator, typename _ForwardIterator, typename _BinaryPredicate>\n     _InputIterator\n     find_first_of(_InputIterator __first1, _InputIterator __last1,\n@@ -4307,6 +4594,30 @@ namespace std\n \n   // Dispatching functions for find_end.\n \n+  /**\n+   *  @brief  Find last matching subsequence in a sequence.\n+   *  @param  first1  Start of range to search.\n+   *  @param  last1   End of range to search.\n+   *  @param  first2  Start of sequence to match.\n+   *  @param  last2   End of sequence to match.\n+   *  @return   The last iterator @c i in the range\n+   *  @p [first1,last1-(last2-first2)) such that @c *(i+N) == @p *(first2+N)\n+   *  for each @c N in the range @p [0,last2-first2), or @p last1 if no\n+   *  such iterator exists.\n+   *\n+   *  Searches the range @p [first1,last1) for a sub-sequence that compares\n+   *  equal value-by-value with the sequence given by @p [first2,last2) and\n+   *  returns an iterator to the first element of the sub-sequence, or\n+   *  @p last1 if the sub-sequence is not found.  The sub-sequence will be the\n+   *  last such subsequence contained in [first,last1).\n+   *\n+   *  Because the sub-sequence must lie completely within the range\n+   *  @p [first1,last1) it must start at a position less than\n+   *  @p last1-(last2-first2) where @p last2-first2 is the length of the\n+   *  sub-sequence.\n+   *  This means that the returned iterator @c i will be in the range\n+   *  @p [first1,last1-(last2-first2))\n+  */\n   template<typename _ForwardIterator1, typename _ForwardIterator2>\n     inline _ForwardIterator1\n     find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n@@ -4324,6 +4635,32 @@ namespace std\n \t\t\t     std::__iterator_category(__first2));\n     }\n \n+  /**\n+   *  @brief  Find last matching subsequence in a sequence using a predicate.\n+   *  @param  first1  Start of range to search.\n+   *  @param  last1   End of range to search.\n+   *  @param  first2  Start of sequence to match.\n+   *  @param  last2   End of sequence to match.\n+   *  @param  comp    The predicate to use.\n+   *  @return   The last iterator @c i in the range\n+   *  @p [first1,last1-(last2-first2)) such that @c predicate(*(i+N), @p\n+   *  (first2+N)) is true for each @c N in the range @p [0,last2-first2), or\n+   *  @p last1 if no such iterator exists.\n+   *\n+   *  Searches the range @p [first1,last1) for a sub-sequence that compares\n+   *  equal value-by-value with the sequence given by @p [first2,last2) using\n+   *  comp as a predicate and returns an iterator to the first element of the\n+   *  sub-sequence, or @p last1 if the sub-sequence is not found.  The\n+   *  sub-sequence will be the last such subsequence contained in\n+   *  [first,last1).\n+   *\n+   *  Because the sub-sequence must lie completely within the range\n+   *  @p [first1,last1) it must start at a position less than\n+   *  @p last1-(last2-first2) where @p last2-first2 is the length of the\n+   *  sub-sequence.\n+   *  This means that the returned iterator @c i will be in the range\n+   *  @p [first1,last1-(last2-first2))\n+  */\n   template<typename _ForwardIterator1, typename _ForwardIterator2,\n \t   typename _BinaryPredicate>\n     inline _ForwardIterator1"}, {"sha": "73b13591cdcdbc9681807453cbd2b1dc87ec1aab", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119dbb1fceae4b4233d7a5fe1c38afc748c7af94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119dbb1fceae4b4233d7a5fe1c38afc748c7af94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=119dbb1fceae4b4233d7a5fe1c38afc748c7af94", "patch": "@@ -319,8 +319,11 @@ namespace std\n    *  This inline function will boil down to a call to @c memmove whenever\n    *  possible.  Failing that, if random access iterators are passed, then the\n    *  loop count will be known (and therefore a candidate for compiler\n-   *  optimizations such as unrolling).  If the input range and the output\n-   *  range overlap, then the copy_backward function should be used instead.\n+   *  optimizations such as unrolling).  Result may not be contained within\n+   *  [first,last); the copy_backward function should be used instead.\n+   *\n+   *  Note that the end of the output range is permitted to be contained\n+   *  within [first,last).\n   */\n   template<typename _InputIterator, typename _OutputIterator>\n     inline _OutputIterator\n@@ -443,9 +446,9 @@ namespace std\n \n   /**\n    *  @brief Copies the range [first,last) into result.\n-   *  @param  first  An input iterator.\n-   *  @param  last   An input iterator.\n-   *  @param  result An output iterator.\n+   *  @param  first  A bidirectional iterator.\n+   *  @param  last   A bidirectional iterator.\n+   *  @param  result A bidirectional iterator.\n    *  @return   result - (first - last)\n    *\n    *  The function has the same effect as copy, but starts at the end of the\n@@ -454,6 +457,9 @@ namespace std\n    *  possible.  Failing that, if random access iterators are passed, then the\n    *  loop count will be known (and therefore a candidate for compiler\n    *  optimizations such as unrolling).\n+   *\n+   *  Result may not be in the range [first,last).  Use copy instead.  Note\n+   *  that the start of the output range may overlap [first,last).\n   */\n   template <typename _BI1, typename _BI2>\n     inline _BI2"}, {"sha": "697f2c6f7b7e481666632c15504b13a80533005b", "filename": "libstdc++-v3/include/bits/stl_heap.h", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119dbb1fceae4b4233d7a5fe1c38afc748c7af94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119dbb1fceae4b4233d7a5fe1c38afc748c7af94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h?ref=119dbb1fceae4b4233d7a5fe1c38afc748c7af94", "patch": "@@ -79,6 +79,15 @@ namespace std\n       *(__first + __holeIndex) = __value;\n     }\n \n+  /**\n+   *  @brief  Push an element onto a heap.\n+   *  @param  first  Start of heap.\n+   *  @param  last   End of heap + element.\n+   *  @ingroup heap\n+   *\n+   *  This operation pushes the element at last-1 onto the valid heap over the\n+   *  range [first,last-1).  After completion, [first,last) is a valid heap.\n+  */\n   template<typename _RandomAccessIterator>\n     inline void \n     push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n@@ -112,6 +121,17 @@ namespace std\n       *(__first + __holeIndex) = __value;\n     }\n \n+  /**\n+   *  @brief  Push an element onto a heap using comparison functor.\n+   *  @param  first  Start of heap.\n+   *  @param  last   End of heap + element.\n+   *  @param  comp   Comparison functor.\n+   *  @ingroup heap\n+   *\n+   *  This operation pushes the element at last-1 onto the valid heap over the\n+   *  range [first,last-1).  After completion, [first,last) is a valid heap.\n+   *  Compare operations are performed using comp.\n+  */\n   template<typename _RandomAccessIterator, typename _Compare>\n     inline void \n     push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n@@ -161,6 +181,15 @@ namespace std\n       std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value);\n     }\n \n+  /**\n+   *  @brief  Pop an element off a heap.\n+   *  @param  first  Start of heap.\n+   *  @param  last   End of heap.\n+   *  @ingroup heap\n+   *\n+   *  This operation pops the top of the heap.  The elements first and last-1\n+   *  are swapped and [first,last-1) is made into a heap.\n+  */\n   template<typename _RandomAccessIterator>\n     inline void\n     pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n@@ -208,6 +237,17 @@ namespace std\n \t\t\t __value, __comp);\n     }\n \n+  /**\n+   *  @brief  Pop an element off a heap using comparison functor.\n+   *  @param  first  Start of heap.\n+   *  @param  last   End of heap.\n+   *  @param  comp   Comparison functor to use.\n+   *  @ingroup heap\n+   *\n+   *  This operation pops the top of the heap.  The elements first and last-1\n+   *  are swapped and [first,last-1) is made into a heap.  Comparisons are\n+   *  made using comp.\n+  */\n   template<typename _RandomAccessIterator, typename _Compare>\n     inline void \n     pop_heap(_RandomAccessIterator __first,\n@@ -221,6 +261,14 @@ namespace std\n       std::__pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)), __comp);\n     }\n \n+  /**\n+   *  @brief  Construct a heap over a range.\n+   *  @param  first  Start of heap.\n+   *  @param  last   End of heap.\n+   *  @ingroup heap\n+   *\n+   *  This operation makes the elements in [first,last) into a heap.\n+  */\n   template<typename _RandomAccessIterator>\n     void \n     make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n@@ -246,6 +294,16 @@ namespace std\n       }\n     }\n \n+  /**\n+   *  @brief  Construct a heap over a range using comparison functor.\n+   *  @param  first  Start of heap.\n+   *  @param  last   End of heap.\n+   *  @param  comp   Comparison functor to use.\n+   *  @ingroup heap\n+   *\n+   *  This operation makes the elements in [first,last) into a heap.\n+   *  Comparisons are made using comp.\n+  */\n   template<typename _RandomAccessIterator, typename _Compare>\n     inline void \n     make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n@@ -272,6 +330,14 @@ namespace std\n       }\n     }\n \n+  /**\n+   *  @brief  Sort a heap.\n+   *  @param  first  Start of heap.\n+   *  @param  last   End of heap.\n+   *  @ingroup heap\n+   *\n+   *  This operation sorts the valid heap in the range [first,last).\n+  */\n   template<typename _RandomAccessIterator>\n     void\n     sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n@@ -286,6 +352,16 @@ namespace std\n \tstd::pop_heap(__first, __last--);\n     }\n \n+  /**\n+   *  @brief  Sort a heap using comparison functor.\n+   *  @param  first  Start of heap.\n+   *  @param  last   End of heap.\n+   *  @param  comp   Comparison functor to use.\n+   *  @ingroup heap\n+   *\n+   *  This operation sorts the valid heap in the range [first,last).\n+   *  Comparisons are made using comp.\n+  */\n   template<typename _RandomAccessIterator, typename _Compare>\n     void \n     sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,"}]}