{"sha": "c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA1ZGJlODEzMWQ1ZDFmMWI0Y2ZiMWExZjA4YWY1YzllNzk5NDJlMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-11-21T22:54:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-11-21T22:54:20Z"}, "message": "i386-protos.h (x86_64_sign_extended_value): Fix prototype.\n\n\t* i386-protos.h (x86_64_sign_extended_value): Fix prototype.\n\t* i386.c (x86_64_general_operand, x86_64_szext_general_operand,\n\tx86_64_nonmemory_operand, x86_64_movabs_operand,\n\tx86_64_szext_nonmemory_operand, x86_64_immediate_operand,\n\tix86_expand_int_movcc): Update call of x86_64_sign_extended_value.\n\t(local_symbolic_operand): Do not care the 64bit limits.\n\t(x86_64_sign_extended_value): Remove allow_rip support.\n\t(legitimate_pic_address_disp_p): Handle all cases allowed\n\twith RIP addressing.\n\t(legitimate_address_p): Use legitimate_pic_address_disp_p for PIC.\n\t(legitimize_pic_address): Reorganize.\n\t* i386.h (EXTRA_CONSTRAINT): Update call of x86_64_sign_extended_value.\n\nFrom-SVN: r59362", "tree": {"sha": "c6e181d870a0f2ad32f56e87c4132dcad5a9e601", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6e181d870a0f2ad32f56e87c4132dcad5a9e601"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1/comments", "author": null, "committer": null, "parents": [{"sha": "75c2b9730dd2764b603d48f756b76cc2965ab7b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75c2b9730dd2764b603d48f756b76cc2965ab7b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75c2b9730dd2764b603d48f756b76cc2965ab7b5"}], "stats": {"total": 158, "additions": 80, "deletions": 78}, "files": [{"sha": "e3672f9bd4f72ec5efcbd7115355dc12bd1506e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1", "patch": "@@ -1,3 +1,18 @@\n+Thu Nov 21 23:52:04 CET 2002  Jan Hubicka  <jH@suse.cz>\n+\n+\t* i386-protos.h (x86_64_sign_extended_value): Fix prototype.\n+\t* i386.c (x86_64_general_operand, x86_64_szext_general_operand,\n+\tx86_64_nonmemory_operand, x86_64_movabs_operand, \n+\tx86_64_szext_nonmemory_operand, x86_64_immediate_operand,\n+\tix86_expand_int_movcc): Update call of x86_64_sign_extended_value.\n+\t(local_symbolic_operand): Do not care the 64bit limits.\n+\t(x86_64_sign_extended_value): Remove allow_rip support.\n+\t(legitimate_pic_address_disp_p): Handle all cases allowed\n+\twith RIP addressing.\n+\t(legitimate_address_p): Use legitimate_pic_address_disp_p for PIC.\n+\t(legitimize_pic_address): Reorganize.\n+\t* i386.h (EXTRA_CONSTRAINT): Update call of x86_64_sign_extended_value.\n+\n 2002-11-21  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* config.gcc (arm*-*-netbsdelf*): Enable configuration."}, {"sha": "4afdf668bd8db84c0f141733476c417973692d1a", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1", "patch": "@@ -153,7 +153,7 @@ extern int ix86_attr_length_address_default PARAMS ((rtx));\n \n extern enum machine_mode ix86_fp_compare_mode PARAMS ((enum rtx_code));\n \n-extern int x86_64_sign_extended_value PARAMS ((rtx, int));\n+extern int x86_64_sign_extended_value PARAMS ((rtx));\n extern int x86_64_zero_extended_value PARAMS ((rtx));\n extern rtx ix86_libcall_value PARAMS ((enum machine_mode));\n extern bool ix86_function_value_regno_p PARAMS ((int));"}, {"sha": "e379c4aa85fc030c70b66c64626a158c3c443d25", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 62, "deletions": 75, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1", "patch": "@@ -2894,7 +2894,7 @@ x86_64_general_operand (op, mode)\n     return general_operand (op, mode);\n   if (nonimmediate_operand (op, mode))\n     return 1;\n-  return x86_64_sign_extended_value (op, 1);\n+  return x86_64_sign_extended_value (op);\n }\n \n /* Return nonzero if OP is general operand representable on x86_64\n@@ -2909,7 +2909,7 @@ x86_64_szext_general_operand (op, mode)\n     return general_operand (op, mode);\n   if (nonimmediate_operand (op, mode))\n     return 1;\n-  return x86_64_sign_extended_value (op, 1) || x86_64_zero_extended_value (op);\n+  return x86_64_sign_extended_value (op) || x86_64_zero_extended_value (op);\n }\n \n /* Return nonzero if OP is nonmemory operand representable on x86_64.  */\n@@ -2923,7 +2923,7 @@ x86_64_nonmemory_operand (op, mode)\n     return nonmemory_operand (op, mode);\n   if (register_operand (op, mode))\n     return 1;\n-  return x86_64_sign_extended_value (op, 1);\n+  return x86_64_sign_extended_value (op);\n }\n \n /* Return nonzero if OP is nonmemory operand acceptable by movabs patterns.  */\n@@ -2935,7 +2935,7 @@ x86_64_movabs_operand (op, mode)\n {\n   if (!TARGET_64BIT || !flag_pic)\n     return nonmemory_operand (op, mode);\n-  if (register_operand (op, mode) || x86_64_sign_extended_value (op, 0))\n+  if (register_operand (op, mode) || x86_64_sign_extended_value (op))\n     return 1;\n   if (CONSTANT_P (op) && !symbolic_reference_mentioned_p (op))\n     return 1;\n@@ -2953,7 +2953,7 @@ x86_64_szext_nonmemory_operand (op, mode)\n     return nonmemory_operand (op, mode);\n   if (register_operand (op, mode))\n     return 1;\n-  return x86_64_sign_extended_value (op, 0) || x86_64_zero_extended_value (op);\n+  return x86_64_sign_extended_value (op) || x86_64_zero_extended_value (op);\n }\n \n /* Return nonzero if OP is immediate operand representable on x86_64.  */\n@@ -2965,7 +2965,7 @@ x86_64_immediate_operand (op, mode)\n {\n   if (!TARGET_64BIT)\n     return immediate_operand (op, mode);\n-  return x86_64_sign_extended_value (op, 0);\n+  return x86_64_sign_extended_value (op);\n }\n \n /* Return nonzero if OP is immediate operand representable on x86_64.  */\n@@ -3085,10 +3085,7 @@ local_symbolic_operand (op, mode)\n {\n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n-      && (ix86_cmodel != CM_SMALL_PIC\n-\t  || (INTVAL (XEXP (XEXP (op, 0), 1)) >= -16*1024*1024\n-\t      && INTVAL (XEXP (XEXP (op, 0), 1)) < 16*1024*1024)))\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n     op = XEXP (XEXP (op, 0), 0);\n \n   if (GET_CODE (op) == LABEL_REF)\n@@ -3839,9 +3836,8 @@ ix86_can_use_return_insn_p ()\n \f\n /* Return 1 if VALUE can be stored in the sign extended immediate field.  */\n int\n-x86_64_sign_extended_value (value, allow_rip)\n+x86_64_sign_extended_value (value)\n      rtx value;\n-     int allow_rip;\n {\n   switch (GET_CODE (value))\n     {\n@@ -3863,17 +3859,12 @@ x86_64_sign_extended_value (value, allow_rip)\n \t library.  Don't count TLS SYMBOL_REFs here, since they should fit\n \t only if inside of UNSPEC handled below.  */\n       case SYMBOL_REF:\n-\treturn (ix86_cmodel == CM_SMALL || ix86_cmodel == CM_KERNEL\n-\t\t|| (allow_rip\n-\t\t    && ix86_cmodel == CM_SMALL_PIC\n-\t\t    && (CONSTANT_POOL_ADDRESS_P (value)\n-\t\t\t|| SYMBOL_REF_FLAG (value))\n-\t\t    && ! tls_symbolic_operand (value, GET_MODE (value))));\n+\treturn (ix86_cmodel == CM_SMALL || ix86_cmodel == CM_KERNEL);\n \n       /* For certain code models, the code is near as well.  */\n       case LABEL_REF:\n-\treturn ix86_cmodel != CM_LARGE\n-\t       && (allow_rip || ix86_cmodel != CM_SMALL_PIC);\n+\treturn (ix86_cmodel == CM_SMALL || ix86_cmodel == CM_MEDIUM\n+\t\t|| ix86_cmodel == CM_KERNEL);\n \n       /* We also may accept the offsetted memory references in certain special\n          cases.  */\n@@ -3919,26 +3910,11 @@ x86_64_sign_extended_value (value, allow_rip)\n \t\t      && offset > 0\n \t\t      && trunc_int_for_mode (offset, SImode) == offset)\n \t\t    return 1;\n-\t\t  /* For CM_SMALL_PIC, we can make similar assumptions\n-\t\t     as for CM_SMALL model, if we know the symbol is local\n-\t\t     to the shared library.  Disallow any TLS symbols,\n-\t\t     since they should always be enclosed in an UNSPEC.  */\n-\t\t  if (ix86_cmodel == CM_SMALL_PIC\n-\t\t      && allow_rip\n-\t\t      && (CONSTANT_POOL_ADDRESS_P (op1)\n-\t\t\t  || SYMBOL_REF_FLAG (op1))\n-\t\t      && ! tls_symbolic_operand (op1, GET_MODE (op1))\n-\t\t      && offset < 16*1024*1024\n-\t\t      && offset >= -16*1024*1024\n-\t\t      && trunc_int_for_mode (offset, SImode) == offset)\n-\t\t    return 1;\n \t\t  break;\n \t\tcase LABEL_REF:\n \t\t  /* These conditions are similar to SYMBOL_REF ones, just the\n \t\t     constraints for code models differ.  */\n-\t\t  if ((ix86_cmodel == CM_SMALL || ix86_cmodel == CM_MEDIUM\n-\t\t       || (ix86_cmodel == CM_SMALL_PIC && allow_rip\n-\t\t\t   && offset >= -16*1024*1024))\n+\t\t  if ((ix86_cmodel == CM_SMALL || ix86_cmodel == CM_MEDIUM)\n \t\t      && offset < 16*1024*1024\n \t\t      && trunc_int_for_mode (offset, SImode) == offset)\n \t\t    return 1;\n@@ -5148,8 +5124,30 @@ legitimate_pic_address_disp_p (disp)\n \n   /* In 64bit mode we can allow direct addresses of symbols and labels\n      when they are not dynamic symbols.  */\n-  if (TARGET_64BIT && local_symbolic_operand (disp, Pmode))\n-    return 1;\n+  if (TARGET_64BIT)\n+    {\n+      /* TLS references should always be enclosed in UNSPEC.  */\n+      if (tls_symbolic_operand (disp, GET_MODE (disp)))\n+\treturn 0;\n+      if (GET_CODE (disp) == SYMBOL_REF\n+\t  && ix86_cmodel == CM_SMALL_PIC\n+\t  && (CONSTANT_POOL_ADDRESS_P (disp)\n+\t      || SYMBOL_REF_FLAG (disp)))\n+\treturn 1;\n+      if (GET_CODE (disp) == LABEL_REF)\n+\treturn 1;\n+      if (GET_CODE (disp) == CONST\n+\t  && GET_CODE (XEXP (disp, 0)) == PLUS\n+\t  && ((GET_CODE (XEXP (XEXP (disp, 0), 0)) == SYMBOL_REF\n+\t       && ix86_cmodel == CM_SMALL_PIC\n+\t       && (CONSTANT_POOL_ADDRESS_P (XEXP (XEXP (disp, 0), 0))\n+\t\t   || SYMBOL_REF_FLAG (XEXP (XEXP (disp, 0), 0))))\n+\t      || GET_CODE (XEXP (XEXP (disp, 0), 0)) == LABEL_REF)\n+\t  && GET_CODE (XEXP (XEXP (disp, 0), 1)) == CONST_INT\n+\t  && INTVAL (XEXP (XEXP (disp, 0), 1)) < 16*1024*1024\n+\t  && INTVAL (XEXP (XEXP (disp, 0), 1)) >= -16*1024*1024)\n+\treturn 1;\n+    }\n   if (GET_CODE (disp) != CONST)\n     return 0;\n   disp = XEXP (disp, 0);\n@@ -5356,23 +5354,6 @@ legitimate_address_p (mode, addr, strict)\n     {\n       reason_rtx = disp;\n \n-      if (TARGET_64BIT)\n-\t{\n-\t  if (!x86_64_sign_extended_value (disp, !(index || base)))\n-\t    {\n-\t      reason = \"displacement is out of range\";\n-\t      goto report_error;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (GET_CODE (disp) == CONST_DOUBLE)\n-\t    {\n-\t      reason = \"displacement is a const_double\";\n-\t      goto report_error;\n-\t    }\n-\t}\n-\n       if (GET_CODE (disp) == CONST\n \t  && GET_CODE (XEXP (disp, 0)) == UNSPEC)\n \tswitch (XINT (XEXP (disp, 0), 1))\n@@ -5450,6 +5431,16 @@ legitimate_address_p (mode, addr, strict)\n \t  reason = \"displacement is not constant\";\n \t  goto report_error;\n \t}\n+      else if (TARGET_64BIT && !x86_64_sign_extended_value (disp))\n+\t{\n+\t  reason = \"displacement is out of range\";\n+\t  goto report_error;\n+\t}\n+      else if (!TARGET_64BIT && GET_CODE (disp) == CONST_DOUBLE)\n+\t{\n+\t  reason = \"displacement is a const_double\";\n+\t  goto report_error;\n+\t}\n     }\n \n   /* Everything looks valid.  */\n@@ -5511,28 +5502,24 @@ legitimize_pic_address (orig, reg)\n   return machopic_legitimize_pic_address (orig, GET_MODE (orig), reg);\n #endif\n \n-  if (local_symbolic_operand (addr, Pmode))\n+  if (TARGET_64BIT && legitimate_pic_address_disp_p (addr))\n+    new = addr;\n+  else if (!TARGET_64BIT && local_symbolic_operand (addr, Pmode))\n     {\n-      /* In 64bit mode we can address such objects directly.  */\n-      if (TARGET_64BIT)\n-\tnew = addr;\n-      else\n-\t{\n-\t  /* This symbol may be referenced via a displacement from the PIC\n-\t     base address (@GOTOFF).  */\n+      /* This symbol may be referenced via a displacement from the PIC\n+\t base address (@GOTOFF).  */\n \n-\t  if (reload_in_progress)\n-\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n-\t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTOFF);\n-\t  new = gen_rtx_CONST (Pmode, new);\n-\t  new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n+      if (reload_in_progress)\n+\tregs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+      new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTOFF);\n+      new = gen_rtx_CONST (Pmode, new);\n+      new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n \n-\t  if (reg != 0)\n-\t    {\n-\t      emit_move_insn (reg, new);\n-\t      new = reg;\n-\t    }\n-      \t}\n+      if (reg != 0)\n+\t{\n+\t  emit_move_insn (reg, new);\n+\t  new = reg;\n+\t}\n     }\n   else if (GET_CODE (addr) == SYMBOL_REF)\n     {\n@@ -9218,7 +9205,7 @@ ix86_expand_int_movcc (operands)\n \n       if ((diff == 1 || diff == 2 || diff == 4 || diff == 8\n \t   || diff == 3 || diff == 5 || diff == 9)\n-\t  && (mode != DImode || x86_64_sign_extended_value (GEN_INT (cf), 0)))\n+\t  && (mode != DImode || x86_64_sign_extended_value (GEN_INT (cf))))\n \t{\n \t  /*\n \t   * xorl dest,dest"}, {"sha": "373e3373b6422e51cd574bc6cc15b1ae3c7bb70a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1", "patch": "@@ -1430,7 +1430,7 @@ enum reg_class\n    constraint, the value returned should be 0 regardless of VALUE.  */\n \n #define EXTRA_CONSTRAINT(VALUE, D)\t\t\t\t\\\n-  ((D) == 'e' ? x86_64_sign_extended_value (VALUE, 0)\t\t\\\n+  ((D) == 'e' ? x86_64_sign_extended_value (VALUE)\t\t\\\n    : (D) == 'Z' ? x86_64_zero_extended_value (VALUE)\t\t\\\n    : (D) == 'C' ? standard_sse_constant_p (VALUE)\t\t\\\n    : 0)\n@@ -2566,7 +2566,7 @@ do {\t\t\t\t\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\\\n-    if (TARGET_64BIT && !x86_64_sign_extended_value (RTX, 0))\t\\\n+    if (TARGET_64BIT && !x86_64_sign_extended_value (RTX))\t\\\n       return 3;\t\t\t\t\t\t\t\\\n     if (TARGET_64BIT && !x86_64_zero_extended_value (RTX))\t\\\n       return 2;\t\t\t\t\t\t\t\\"}]}