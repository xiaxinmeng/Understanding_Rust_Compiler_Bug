{"sha": "15827d124af737d95f4b728d5980f65c5d9bc9b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU4MjdkMTI0YWY3MzdkOTVmNGI3MjhkNTk4MGY2NWM1ZDliYzliOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2015-07-30T10:24:46Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2015-07-30T10:24:46Z"}, "message": "class.c (check_for_override): Use DECL_SOURCE_LOCATION and \"%qD\" in warning_at instead of \"%q+D\" in warning.\n\n2015-07-30  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* class.c (check_for_override): Use DECL_SOURCE_LOCATION and \"%qD\"\n\tin warning_at instead of \"%q+D\" in warning.\n\t(warn_hidden): Likewise but use location_of.\n\t(finish_struct_anon_r): Likewise use DECL_SOURCE_LOCATION in permerror.\n\t(check_bitfield_decl, check_field_decls): Likewise in warning_at.\n\t(check_field_decls): Likewise for permerror.\n\t(explain_non_literal_class): Likewise for inform.\n\t(check_bases_and_members, layout_class_type): Likewise for warning_at.\n\t(note_name_declared_in_class): Use location_of in permerror.\n\t* name-lookup.c (diagnose_name_conflict): Use location_of in inform.\n\t(pushdecl_maybe_friend_1): Use DECL_SOURCE_LOCATION in pedwarn,\n\tinform, and warning_at.\n\t(check_for_out_of_scope_variable): Likewise for warning_at and\n\tpermerror.\n\nFrom-SVN: r226394", "tree": {"sha": "f6bce95b430b3c3454749147a48f35dde58b4664", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6bce95b430b3c3454749147a48f35dde58b4664"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15827d124af737d95f4b728d5980f65c5d9bc9b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15827d124af737d95f4b728d5980f65c5d9bc9b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15827d124af737d95f4b728d5980f65c5d9bc9b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15827d124af737d95f4b728d5980f65c5d9bc9b9/comments", "author": null, "committer": null, "parents": [{"sha": "2e3f48dc43aae10019e0e56ac0e7323d1e14531a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3f48dc43aae10019e0e56ac0e7323d1e14531a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e3f48dc43aae10019e0e56ac0e7323d1e14531a"}], "stats": {"total": 133, "additions": 83, "deletions": 50}, "files": [{"sha": "c1a7cb6f3526f78fc5ebeaeffb7aa6e89ceba19a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15827d124af737d95f4b728d5980f65c5d9bc9b9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15827d124af737d95f4b728d5980f65c5d9bc9b9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=15827d124af737d95f4b728d5980f65c5d9bc9b9", "patch": "@@ -1,3 +1,20 @@\n+2015-07-30  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* class.c (check_for_override): Use DECL_SOURCE_LOCATION and \"%qD\"\n+\tin warning_at instead of \"%q+D\" in warning.\n+\t(warn_hidden): Likewise but use location_of.\n+\t(finish_struct_anon_r): Likewise use DECL_SOURCE_LOCATION in permerror.\n+\t(check_bitfield_decl, check_field_decls): Likewise in warning_at.\n+\t(check_field_decls): Likewise for permerror.\n+\t(explain_non_literal_class): Likewise for inform.\n+\t(check_bases_and_members, layout_class_type): Likewise for warning_at.\n+\t(note_name_declared_in_class): Use location_of in permerror.\n+\t* name-lookup.c (diagnose_name_conflict): Use location_of in inform.\n+\t(pushdecl_maybe_friend_1): Use DECL_SOURCE_LOCATION in pedwarn,\n+\tinform, and warning_at.\n+\t(check_for_out_of_scope_variable): Likewise for warning_at and\n+\tpermerror.\n+\n 2015-07-30  Jason Merrill  <jason@redhat.com>\n \n \tDR 1558"}, {"sha": "f659fd4d3a50c0516bdc5557508665664172c352", "filename": "gcc/cp/class.c", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15827d124af737d95f4b728d5980f65c5d9bc9b9/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15827d124af737d95f4b728d5980f65c5d9bc9b9/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=15827d124af737d95f4b728d5980f65c5d9bc9b9", "patch": "@@ -2926,7 +2926,7 @@ check_for_override (tree decl, tree ctype)\n       if (warn_override && !DECL_OVERRIDE_P (decl)\n \t  && !DECL_DESTRUCTOR_P (decl))\n \twarning_at (DECL_SOURCE_LOCATION (decl), OPT_Wsuggest_override,\n-\t\t    \"%q+D can be marked override\", decl);\n+\t\t    \"%qD can be marked override\", decl);\n     }\n \n   if (DECL_VIRTUAL_P (decl))\n@@ -3007,9 +3007,12 @@ warn_hidden (tree t)\n       FOR_EACH_VEC_ELT (base_fndecls, k, base_fndecl)\n \tif (base_fndecl)\n \t  {\n-\t      /* Here we know it is a hider, and no overrider exists.  */\n-\t      warning (OPT_Woverloaded_virtual, \"%q+D was hidden\", base_fndecl);\n-\t      warning (OPT_Woverloaded_virtual, \"  by %q+D\", fns);\n+\t    /* Here we know it is a hider, and no overrider exists.  */\n+\t    warning_at (location_of (base_fndecl),\n+\t\t\tOPT_Woverloaded_virtual,\n+\t\t\t\"%qD was hidden\", base_fndecl);\n+\t    warning_at (location_of (fns),\n+\t\t\tOPT_Woverloaded_virtual, \"  by %qD\", fns);\n \t  }\n     }\n }\n@@ -3042,12 +3045,12 @@ finish_struct_anon_r (tree field, bool complain)\n \t  if (complain && !VAR_P (elt))\n \t    {\n \t      if (is_union)\n-\t\tpermerror (input_location,\n-\t\t\t   \"%q+#D invalid; an anonymous union can \"\n+\t\tpermerror (DECL_SOURCE_LOCATION (elt),\n+\t\t\t   \"%q#D invalid; an anonymous union can \"\n \t\t\t   \"only have non-static data members\", elt);\n \t      else\n-\t\tpermerror (input_location,\n-\t\t\t   \"%q+#D invalid; an anonymous struct can \"\n+\t\tpermerror (DECL_SOURCE_LOCATION (elt),\n+\t\t\t   \"%q#D invalid; an anonymous struct can \"\n \t\t\t   \"only have non-static data members\", elt);\n \t    }\n \t  continue;\n@@ -3058,20 +3061,20 @@ finish_struct_anon_r (tree field, bool complain)\n \t  if (TREE_PRIVATE (elt))\n \t    {\n \t      if (is_union)\n-\t\tpermerror (input_location,\n-\t\t\t   \"private member %q+#D in anonymous union\", elt);\n+\t\tpermerror (DECL_SOURCE_LOCATION (elt),\n+\t\t\t   \"private member %q#D in anonymous union\", elt);\n \t      else\n-\t\tpermerror (input_location,\n-\t\t\t   \"private member %q+#D in anonymous struct\", elt);\n+\t\tpermerror (DECL_SOURCE_LOCATION (elt),\n+\t\t\t   \"private member %q#D in anonymous struct\", elt);\n \t    }\n \t  else if (TREE_PROTECTED (elt))\n \t    {\n \t      if (is_union)\n-\t\tpermerror (input_location,\n-\t\t\t   \"protected member %q+#D in anonymous union\", elt);\n+\t\tpermerror (DECL_SOURCE_LOCATION (elt),\n+\t\t\t   \"protected member %q#D in anonymous union\", elt);\n \t      else\n-\t\tpermerror (input_location,\n-\t\t\t   \"protected member %q+#D in anonymous struct\", elt);\n+\t\tpermerror (DECL_SOURCE_LOCATION (elt),\n+\t\t\t   \"protected member %q#D in anonymous struct\", elt);\n \t    }\n \t}\n \n@@ -3460,11 +3463,14 @@ check_bitfield_decl (tree field)\n \t       || ((TREE_CODE (type) == ENUMERAL_TYPE\n \t\t    || TREE_CODE (type) == BOOLEAN_TYPE)\n \t\t   && tree_int_cst_lt (TYPE_SIZE (type), w)))\n-\twarning (0, \"width of %q+D exceeds its type\", field);\n+\twarning_at (DECL_SOURCE_LOCATION (field), 0,\n+\t\t    \"width of %qD exceeds its type\", field);\n       else if (TREE_CODE (type) == ENUMERAL_TYPE\n \t       && (0 > (compare_tree_int\n \t\t\t(w, TYPE_PRECISION (ENUM_UNDERLYING_TYPE (type))))))\n-\twarning (0, \"%q+D is too small to hold all values of %q#T\", field, type);\n+\twarning_at (DECL_SOURCE_LOCATION (field), 0,\n+\t\t    \"%qD is too small to hold all values of %q#T\",\n+\t\t    field, type);\n     }\n \n   if (w != error_mark_node)\n@@ -3737,9 +3743,9 @@ check_field_decls (tree t, tree *access_decls,\n \t{\n \t  if (!layout_pod_type_p (type) && !TYPE_PACKED (type))\n \t    {\n-\t      warning\n-\t\t(0,\n-\t\t \"ignoring packed attribute because of unpacked non-POD field %q+#D\",\n+\t      warning_at\n+\t\t(DECL_SOURCE_LOCATION (x), 0,\n+\t\t \"ignoring packed attribute because of unpacked non-POD field %q#D\",\n \t\t x);\n \t      cant_pack = 1;\n \t    }\n@@ -3854,7 +3860,8 @@ check_field_decls (tree t, tree *access_decls,\n \t user-declared constructor.  */\n       if (constructor_name_p (DECL_NAME (x), t)\n \t  && TYPE_HAS_USER_CONSTRUCTOR (t))\n-\tpermerror (input_location, \"field %q+#D with same name as class\", x);\n+\tpermerror (DECL_SOURCE_LOCATION (x),\n+\t\t   \"field %q#D with same name as class\", x);\n     }\n \n   /* Effective C++ rule 11: if a class has dynamic memory held by pointers,\n@@ -5623,14 +5630,15 @@ explain_non_literal_class (tree t)\n \t  ftype = TREE_TYPE (field);\n \t  if (!literal_type_p (ftype))\n \t    {\n-\t      inform (0, \"  non-static data member %q+D has \"\n-\t\t      \"non-literal type\", field);\n+\t      inform (DECL_SOURCE_LOCATION (field),\n+\t\t      \"  non-static data member %qD has non-literal type\",\n+\t\t      field);\n \t      if (CLASS_TYPE_P (ftype))\n \t\texplain_non_literal_class (ftype);\n \t    }\n \t  if (CP_TYPE_VOLATILE_P (ftype))\n-\t    inform (0, \"  non-static data member %q+D has \"\n-\t\t    \"volatile type\", field);\n+\t    inform (DECL_SOURCE_LOCATION (field),\n+\t\t    \"  non-static data member %qD has volatile type\", field);\n \t}\n     }\n }\n@@ -5775,13 +5783,15 @@ check_bases_and_members (tree t)\n \n \t  type = TREE_TYPE (field);\n \t  if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t    warning (OPT_Wuninitialized, \"non-static reference %q+#D \"\n-\t\t     \"in class without a constructor\", field);\n+\t    warning_at (DECL_SOURCE_LOCATION (field),\n+\t\t\tOPT_Wuninitialized, \"non-static reference %q#D \"\n+\t\t\t\"in class without a constructor\", field);\n \t  else if (CP_TYPE_CONST_P (type)\n \t\t   && (!CLASS_TYPE_P (type)\n \t\t       || !TYPE_HAS_DEFAULT_CONSTRUCTOR (type)))\n-\t    warning (OPT_Wuninitialized, \"non-static const member %q+#D \"\n-\t\t     \"in class without a constructor\", field);\n+\t    warning_at (DECL_SOURCE_LOCATION (field),\n+\t\t\tOPT_Wuninitialized, \"non-static const member %q#D \"\n+\t\t\t\"in class without a constructor\", field);\n \t}\n     }\n \n@@ -6322,8 +6332,9 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  && !integer_zerop (size_binop (TRUNC_MOD_EXPR,\n \t\t\t\t\t DECL_FIELD_BIT_OFFSET (field),\n \t\t\t\t\t bitsize_unit_node)))\n-\twarning (OPT_Wabi, \"offset of %q+D is not ABI-compliant and may \"\n-\t\t \"change in a future version of GCC\", field);\n+\twarning_at (DECL_SOURCE_LOCATION (field), OPT_Wabi,\n+\t\t    \"offset of %qD is not ABI-compliant and may \"\n+\t\t    \"change in a future version of GCC\", field);\n \n       /* The middle end uses the type of expressions to determine the\n \t possible range of expression values.  In order to optimize\n@@ -8113,8 +8124,9 @@ note_name_declared_in_class (tree name, tree decl)\n \t in its context and when re-evaluated in the completed scope of\n \t S.  */\n       permerror (input_location, \"declaration of %q#D\", decl);\n-      permerror (input_location, \"changes meaning of %qD from %q+#D\",\n-\t       DECL_NAME (OVL_CURRENT (decl)), (tree) n->value);\n+      permerror (location_of ((tree) n->value),\n+\t\t \"changes meaning of %qD from %q#D\",\n+\t\t DECL_NAME (OVL_CURRENT (decl)), (tree) n->value);\n     }\n }\n "}, {"sha": "79e28637cae0260741df89c06af4c1149a2ce778", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15827d124af737d95f4b728d5980f65c5d9bc9b9/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15827d124af737d95f4b728d5980f65c5d9bc9b9/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=15827d124af737d95f4b728d5980f65c5d9bc9b9", "patch": "@@ -590,7 +590,7 @@ diagnose_name_conflict (tree decl, tree bval)\n   else\n     error (\"%q#D conflicts with a previous declaration\", decl);\n \n-  inform (input_location, \"previous declaration %q+#D\", bval);\n+  inform (location_of (bval), \"previous declaration %q#D\", bval);\n }\n \n /* Wrapper for supplement_binding_1.  */\n@@ -875,8 +875,8 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t      pedwarn (input_location, 0,\n                                \"declaration of %q#D with C language linkage\",\n \t\t\t       x);\n-\t\t      pedwarn (input_location, 0,\n-                               \"conflicts with previous declaration %q+#D\",\n+\t\t      pedwarn (DECL_SOURCE_LOCATION (previous), 0,\n+                               \"conflicts with previous declaration %q#D\",\n \t\t\t       previous);\n \t\t      pedwarn (input_location, 0,\n                                \"due to different exception specifications\");\n@@ -890,8 +890,8 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t{\n \t\t  pedwarn (input_location, 0,\n \t\t\t   \"declaration of %q#D with C language linkage\", x);\n-\t\t  pedwarn (input_location, 0,\n-\t\t\t   \"conflicts with previous declaration %q+#D\",\n+\t\t  pedwarn (DECL_SOURCE_LOCATION (previous), 0,\n+\t\t\t   \"conflicts with previous declaration %q#D\",\n \t\t\t   previous);\n \t\t}\n \t    }\n@@ -992,8 +992,8 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t    {\n \t      if (permerror (input_location, \"type mismatch with previous \"\n \t\t\t     \"external decl of %q#D\", x))\n-\t\tinform (input_location, \"previous external decl of %q+#D\",\n-\t\t\tdecl);\n+\t\tinform (DECL_SOURCE_LOCATION (decl),\n+\t\t\t\"previous external decl of %q#D\", decl);\n \t    }\n \t}\n \n@@ -1082,7 +1082,8 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t      else\n \t\t{\n \t\t  warning (0, \"extern declaration of %q#D doesn%'t match\", x);\n-\t\t  warning (0, \"global declaration %q+#D\", oldglobal);\n+\t\t  warning_at (DECL_SOURCE_LOCATION (oldglobal), 0,\n+\t\t\t      \"global declaration %q#D\", oldglobal);\n \t\t}\n \t    }\n \t  /* If we have a local external declaration,\n@@ -1170,8 +1171,8 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t\t   || oldscope->kind == sk_for))\n \t\t{\n \t\t  error (\"redeclaration of %q#D\", x);\n-\t\t  inform (input_location, \"%q+#D previously declared here\",\n-\t\t\t  oldlocal);\n+\t\t  inform (DECL_SOURCE_LOCATION (oldlocal),\n+\t\t\t  \"%q#D previously declared here\", oldlocal);\n \t\t  nowarn = true;\n \t\t}\n \t      /* C++11:\n@@ -1193,8 +1194,8 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t\t   && in_function_try_handler))\n \t\t{\n \t\t  if (permerror (input_location, \"redeclaration of %q#D\", x))\n-\t\t    inform (input_location, \"%q+#D previously declared here\",\n-\t\t\t    oldlocal);\n+\t\t    inform (DECL_SOURCE_LOCATION (oldlocal),\n+\t\t\t    \"%q#D previously declared here\", oldlocal);\n \t\t  nowarn = true;\n \t\t}\n \n@@ -1410,9 +1411,11 @@ check_for_out_of_scope_variable (tree decl)\n       if (!DECL_ERROR_REPORTED (decl))\n \t{\n \t  warning (0, \"name lookup of %qD changed\", DECL_NAME (decl));\n-\t  warning (0, \"  matches this %q+D under ISO standard rules\",\n-\t\t   shadowed);\n-\t  warning (0, \"  matches this %q+D under old rules\", decl);\n+\t  warning_at (DECL_SOURCE_LOCATION (shadowed), 0,\n+\t\t      \"  matches this %qD under ISO standard rules\",\n+\t\t      shadowed);\n+\t  warning_at (DECL_SOURCE_LOCATION (decl), 0,\n+\t\t      \"  matches this %qD under old rules\", decl);\n \t  DECL_ERROR_REPORTED (decl) = 1;\n \t}\n       return shadowed;\n@@ -1441,7 +1444,8 @@ check_for_out_of_scope_variable (tree decl)\n       permerror (input_location, \"name lookup of %qD changed for ISO %<for%> scoping\",\n \t         DECL_NAME (decl));\n       if (flag_permissive)\n-        permerror (input_location, \"  using obsolete binding at %q+D\", decl);\n+        permerror (DECL_SOURCE_LOCATION (decl),\n+\t\t   \"  using obsolete binding at %qD\", decl);\n       else\n \t{\n \t  static bool hint;"}]}