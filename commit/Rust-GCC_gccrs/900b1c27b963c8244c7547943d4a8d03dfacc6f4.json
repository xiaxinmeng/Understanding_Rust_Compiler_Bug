{"sha": "900b1c27b963c8244c7547943d4a8d03dfacc6f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAwYjFjMjdiOTYzYzgyNDRjNzU0Nzk0M2Q0YThkMDNkZmFjYzZmNA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-03-11T15:13:24Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-05-11T13:03:57Z"}, "message": "Remove BRIG front-end.\n\ngcc/ada/ChangeLog:\n\n\t* gcc-interface/ada-tree.h (BUILT_IN_LIKELY): Use builtins\n\tfrom COROUTINES.\n\t(BUILT_IN_UNLIKELY): Likewise.\n\ngcc/ChangeLog:\n\n\t* builtins.def (DEF_HSAIL_BUILTIN): Remove.\n\t(DEF_HSAIL_ATOMIC_BUILTIN): Likewise.\n\t(DEF_HSAIL_SAT_BUILTIN): Likewise.\n\t(DEF_HSAIL_INTR_BUILTIN): Likewise.\n\t(DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN): Likewise.\n\t* doc/frontends.texi: Remove BRIG.\n\t* doc/install.texi: Likewise.\n\t* doc/invoke.texi: Likewise.\n\t* doc/standards.texi: Likewise.\n\t* brig-builtins.def: Removed.\n\t* brig/ChangeLog: Removed.\n\t* brig/Make-lang.in: Removed.\n\t* brig/brig-builtins.h: Removed.\n\t* brig/brig-c.h: Removed.\n\t* brig/brig-lang.c: Removed.\n\t* brig/brigfrontend/brig-arg-block-handler.cc: Removed.\n\t* brig/brigfrontend/brig-atomic-inst-handler.cc: Removed.\n\t* brig/brigfrontend/brig-basic-inst-handler.cc: Removed.\n\t* brig/brigfrontend/brig-branch-inst-handler.cc: Removed.\n\t* brig/brigfrontend/brig-cmp-inst-handler.cc: Removed.\n\t* brig/brigfrontend/brig-code-entry-handler.cc: Removed.\n\t* brig/brigfrontend/brig-code-entry-handler.h: Removed.\n\t* brig/brigfrontend/brig-comment-handler.cc: Removed.\n\t* brig/brigfrontend/brig-control-handler.cc: Removed.\n\t* brig/brigfrontend/brig-copy-move-inst-handler.cc: Removed.\n\t* brig/brigfrontend/brig-cvt-inst-handler.cc: Removed.\n\t* brig/brigfrontend/brig-fbarrier-handler.cc: Removed.\n\t* brig/brigfrontend/brig-function-handler.cc: Removed.\n\t* brig/brigfrontend/brig-function.cc: Removed.\n\t* brig/brigfrontend/brig-function.h: Removed.\n\t* brig/brigfrontend/brig-inst-mod-handler.cc: Removed.\n\t* brig/brigfrontend/brig-label-handler.cc: Removed.\n\t* brig/brigfrontend/brig-lane-inst-handler.cc: Removed.\n\t* brig/brigfrontend/brig-machine.c: Removed.\n\t* brig/brigfrontend/brig-machine.h: Removed.\n\t* brig/brigfrontend/brig-mem-inst-handler.cc: Removed.\n\t* brig/brigfrontend/brig-module-handler.cc: Removed.\n\t* brig/brigfrontend/brig-queue-inst-handler.cc: Removed.\n\t* brig/brigfrontend/brig-seg-inst-handler.cc: Removed.\n\t* brig/brigfrontend/brig-signal-inst-handler.cc: Removed.\n\t* brig/brigfrontend/brig-to-generic.cc: Removed.\n\t* brig/brigfrontend/brig-to-generic.h: Removed.\n\t* brig/brigfrontend/brig-util.cc: Removed.\n\t* brig/brigfrontend/brig-util.h: Removed.\n\t* brig/brigfrontend/brig-variable-handler.cc: Removed.\n\t* brig/brigfrontend/hsa-brig-format.h: Removed.\n\t* brig/brigfrontend/phsa.h: Removed.\n\t* brig/brigspec.c: Removed.\n\t* brig/config-lang.in: Removed.\n\t* brig/gccbrig.texi: Removed.\n\t* brig/lang-specs.h: Removed.\n\t* brig/lang.opt: Removed.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/goacc/pr78027.f90: Remove -Wno-hsa option.\n\t* brig.dg/README: Removed.\n\t* brig.dg/dg.exp: Removed.\n\t* brig.dg/test/gimple/alloca.hsail: Removed.\n\t* brig.dg/test/gimple/atomics.hsail: Removed.\n\t* brig.dg/test/gimple/branches.hsail: Removed.\n\t* brig.dg/test/gimple/fbarrier.hsail: Removed.\n\t* brig.dg/test/gimple/function_calls.hsail: Removed.\n\t* brig.dg/test/gimple/internal-casts.hsail: Removed.\n\t* brig.dg/test/gimple/kernarg.hsail: Removed.\n\t* brig.dg/test/gimple/mem.hsail: Removed.\n\t* brig.dg/test/gimple/mulhi.hsail: Removed.\n\t* brig.dg/test/gimple/packed.hsail: Removed.\n\t* brig.dg/test/gimple/priv-array-offset-access.hsail: Removed.\n\t* brig.dg/test/gimple/smoke_test.hsail: Removed.\n\t* brig.dg/test/gimple/variables.hsail: Removed.\n\t* brig.dg/test/gimple/vector.hsail: Removed.\n\t* lib/brig-dg.exp: Removed.\n\t* lib/brig.exp: Removed.", "tree": {"sha": "a9bba5461272a04e99eaf2f45a88d2b895bf0f17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9bba5461272a04e99eaf2f45a88d2b895bf0f17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/900b1c27b963c8244c7547943d4a8d03dfacc6f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/900b1c27b963c8244c7547943d4a8d03dfacc6f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/900b1c27b963c8244c7547943d4a8d03dfacc6f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/900b1c27b963c8244c7547943d4a8d03dfacc6f4/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e0fe7761da9255c9342788956c37b426875d872", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e0fe7761da9255c9342788956c37b426875d872", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e0fe7761da9255c9342788956c37b426875d872"}], "stats": {"total": 14382, "additions": 6, "deletions": 14376}, "files": [{"sha": "9fe52cf61d2644252b0f858fd27f4238bd5539ff", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=900b1c27b963c8244c7547943d4a8d03dfacc6f4", "patch": "@@ -580,6 +580,6 @@ do {\t\t\t\t\t\t   \\\n #define EXIT_STMT_LABEL(NODE)    TREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 1)\n \n /* Small kludge to be able to define Ada built-in functions locally.\n-   We overload them on top of the HSAIL/BRIG builtin functions.  */\n-#define BUILT_IN_LIKELY   BUILT_IN_HSAIL_WORKITEMABSID\n-#define BUILT_IN_UNLIKELY BUILT_IN_HSAIL_GRIDSIZE\n+   We overload them on top of the C++ coroutines builtin functions.  */\n+#define BUILT_IN_LIKELY   BUILT_IN_CORO_PROMISE\n+#define BUILT_IN_UNLIKELY BUILT_IN_CORO_RESUME"}, {"sha": "a9ae2ffbddcb51756babc12da00653de553c8048", "filename": "gcc/brig-builtins.def", "status": "removed", "additions": 0, "deletions": 675, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig-builtins.def?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,675 +0,0 @@\n-/* This file contains the definitions and documentation for the\n-   HSAIL builtins used in the GNU compiler.\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Following builtins are used by the BRIG (the binary representation of\n-   HSAIL) frontend.  Software implementations are available in libhsail-rt.\n-   Use leading double underscore in the name to avoid name space clashes\n-   with kernel program symbols in case the builtin is implemented as\n-   a function call.  */\n-\n-/* Work-item ID related builtins are not constant in the work-group function\n-   mode (each WI has a different return value).  */\n-\n-#ifndef DEF_HSAIL_BUILTIN\n-#define DEF_HSAIL_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE,\t\\\n-\t\t\t  NAME, TYPE, ATTRS)\n-#endif\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMABSID, BRIG_OPCODE_WORKITEMABSID,\n-\t\t  BRIG_TYPE_U32, \"__hsail_workitemabsid\", BT_FN_UINT_UINT_PTR,\n-\t\t  ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_GRIDSIZE, BRIG_OPCODE_GRIDSIZE,\n-\t\t  BRIG_TYPE_U32, \"__hsail_gridsize\", BT_FN_UINT_UINT_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMFLATABSID_U32,\n-\t\t  BRIG_OPCODE_WORKITEMFLATABSID, BRIG_TYPE_U32,\n-\t\t  \"__hsail_workitemflatabsid_u32\", BT_FN_UINT_CONST_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMFLATABSID_U64,\n-\t\t  BRIG_OPCODE_WORKITEMFLATABSID, BRIG_TYPE_U64,\n-\t\t  \"__hsail_workitemflatabsid_u64\", BT_FN_ULONG_CONST_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMFLATID, BRIG_OPCODE_WORKITEMFLATID,\n-\t\t  BRIG_TYPE_U32, \"__hsail_workitemflatid\", BT_FN_UINT_CONST_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMID, BRIG_OPCODE_WORKITEMID,\n-\t\t  BRIG_TYPE_U32, \"__hsail_workitemid\",\n-\t\t  BT_FN_UINT_UINT_CONST_PTR, ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKGROUPID, BRIG_OPCODE_WORKGROUPID,\n-\t\t  BRIG_TYPE_U32, \"__hsail_workgroupid\",\n-\t\t  BT_FN_UINT_UINT_CONST_PTR, ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CURRENTWORKITEMFLATID,\n-\t\t  BRIG_OPCODE_CURRENTWORKITEMFLATID,\n-\t\t  BRIG_TYPE_U32, \"__hsail_currentworkitemflatid\",\n-\t\t  BT_FN_UINT_PTR, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMABSID_U64, BRIG_OPCODE_WORKITEMABSID,\n-\t\t  BRIG_TYPE_U64, \"__hsail_workitemabsid_u64\",\n-\t\t  BT_FN_ULONG_UINT_PTR, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_PACKETID, BRIG_OPCODE_PACKETID,\n-\t\t  BRIG_TYPE_U64, \"__hsail_packetid\", BT_FN_ULONG_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_PACKETCOMPLETIONSIG_SIG64,\n-\t\t  BRIG_OPCODE_PACKETCOMPLETIONSIG, BRIG_TYPE_SIG64,\n-\t\t  \"__hsail_packetcompletionsig_sig64\", BT_FN_ULONG_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_PACKETCOMPLETIONSIG_SIG32,\n-\t\t  BRIG_OPCODE_PACKETCOMPLETIONSIG, BRIG_TYPE_SIG32,\n-\t\t  \"__hsail_packetcompletionsig_sig32\", BT_FN_UINT_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CURRENTWORKGROUPSIZE,\n-\t\t  BRIG_OPCODE_CURRENTWORKGROUPSIZE, BRIG_TYPE_U32,\n-\t\t  \"__hsail_currentworkgroupsize\", BT_FN_UINT_UINT_CONST_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKGROUPSIZE, BRIG_OPCODE_WORKGROUPSIZE,\n-\t\t  BRIG_TYPE_U32, \"__hsail_workgroupsize\",\n-\t\t  BT_FN_UINT_UINT_CONST_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_DIM, BRIG_OPCODE_DIM,\n-\t\t  BRIG_TYPE_U32, \"__hsail_dim\", BT_FN_UINT_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_GRIDGROUPS, BRIG_OPCODE_GRIDGROUPS,\n-\t\t  BRIG_TYPE_U32, \"__hsail_gridgroups\", BT_FN_UINT_UINT_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITEXTRACT_S32, BRIG_OPCODE_BITEXTRACT,\n-\t\t  BRIG_TYPE_S32, \"__hsail_bitextract_s32\",\n-\t\t  BT_FN_INT_INT_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITEXTRACT_U32, BRIG_OPCODE_BITEXTRACT,\n-\t\t  BRIG_TYPE_U32, \"__hsail_bitextract_u32\",\n-\t\t  BT_FN_UINT_UINT_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITEXTRACT_S64, BRIG_OPCODE_BITEXTRACT,\n-\t\t  BRIG_TYPE_S64, \"__hsail_bitextract_s64\",\n-\t\t  BT_FN_LONG_LONG_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITEXTRACT_U64, BRIG_OPCODE_BITEXTRACT,\n-\t\t  BRIG_TYPE_U64, \"__hsail_bitextract_u64\",\n-\t\t  BT_FN_ULONG_ULONG_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITINSERT_U32, BRIG_OPCODE_BITINSERT,\n-\t\t  BRIG_TYPE_U32, \"__hsail_bitinsert_u32\",\n-\t\t  BT_FN_UINT_UINT_UINT_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITINSERT_U64, BRIG_OPCODE_BITINSERT,\n-\t\t  BRIG_TYPE_U64, \"__hsail_bitinsert_u64\",\n-\t\t  BT_FN_ULONG_ULONG_ULONG_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITMASK_B32, BRIG_OPCODE_BITMASK,\n-\t\t  BRIG_TYPE_B32, \"__hsail_bitmask_u32\", BT_FN_UINT_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITMASK_B64, BRIG_OPCODE_BITMASK,\n-\t\t  BRIG_TYPE_B64, \"__hsail_bitmask_u64\", BT_FN_ULONG_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITREV_B32, BRIG_OPCODE_BITREV,\n-\t\t  BRIG_TYPE_B32, \"__hsail_bitrev_u32\", BT_FN_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITREV_B64, BRIG_OPCODE_BITREV,\n-\t\t  BRIG_TYPE_B64, \"__hsail_bitrev_u64\", BT_FN_ULONG_ULONG,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITSELECT_B32, BRIG_OPCODE_BITSELECT,\n-\t\t  BRIG_TYPE_B32, \"__hsail_bitselect_u32\",\n-\t\t  BT_FN_UINT_UINT_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITSELECT_U64, BRIG_OPCODE_BITSELECT,\n-\t\t  BRIG_TYPE_B64, \"__hsail_bitselect_u64\",\n-\t\t  BT_FN_ULONG_ULONG_ULONG_ULONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FIRSTBIT_U32, BRIG_OPCODE_FIRSTBIT,\n-\t\t  BRIG_TYPE_U32, \"__hsail_firstbit_u32\", BT_FN_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FIRSTBIT_S32, BRIG_OPCODE_FIRSTBIT,\n-\t\t  BRIG_TYPE_S32, \"__hsail_firstbit_s32\", BT_FN_UINT_INT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FIRSTBIT_U64, BRIG_OPCODE_FIRSTBIT,\n-\t\t  BRIG_TYPE_U64, \"__hsail_firstbit_u64\", BT_FN_UINT_ULONG,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FIRSTBIT_S64, BRIG_OPCODE_FIRSTBIT,\n-\t\t  BRIG_TYPE_S64, \"__hsail_firstbit_s64\", BT_FN_UINT_LONG,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LASTBIT_U32, BRIG_OPCODE_LASTBIT,\n-\t\t  BRIG_TYPE_U32, \"__hsail_lastbit_u32\", BT_FN_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LASTBIT_U64, BRIG_OPCODE_LASTBIT,\n-\t\t  BRIG_TYPE_U64, \"__hsail_lastbit_u64\", BT_FN_UINT_ULONG,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BORROW_U32, BRIG_OPCODE_BORROW,\n-\t\t  BRIG_TYPE_U32, \"__hsail_borrow_u32\", BT_FN_UINT_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BORROW_U64, BRIG_OPCODE_BORROW,\n-\t\t  BRIG_TYPE_U64, \"__hsail_borrow_u64\", BT_FN_ULONG_ULONG_ULONG,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CARRY_U32, BRIG_OPCODE_CARRY,\n-\t\t  BRIG_TYPE_U32, \"__hsail_carry_u32\", BT_FN_UINT_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CARRY_U64, BRIG_OPCODE_CARRY,\n-\t\t  BRIG_TYPE_U64, \"__hsail_carry_u64\", BT_FN_ULONG_ULONG_ULONG,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_REM_S32, BRIG_OPCODE_REM,\n-\t\t  BRIG_TYPE_S32, \"__hsail_rem_s32\", BT_FN_INT_INT_INT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_REM_S64, BRIG_OPCODE_REM,\n-\t\t  BRIG_TYPE_S64, \"__hsail_rem_s64\", BT_FN_LONG_LONG_LONG,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_MIN_F32, BRIG_OPCODE_MIN,\n-\t\t  BRIG_TYPE_F32, \"__hsail_min_f32\", BT_FN_FLOAT_FLOAT_FLOAT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_MAX_F32, BRIG_OPCODE_MAX,\n-\t\t  BRIG_TYPE_F32, \"__hsail_max_f32\", BT_FN_FLOAT_FLOAT_FLOAT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_MIN_F64, BRIG_OPCODE_MIN,\n-\t\t  BRIG_TYPE_F64, \"__hsail_min_f64\", BT_FN_DOUBLE_DOUBLE_DOUBLE,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_MAX_F64, BRIG_OPCODE_MAX,\n-\t\t  BRIG_TYPE_F64, \"__hsail_max_f64\", BT_FN_DOUBLE_DOUBLE_DOUBLE,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CLASS_F32, BRIG_OPCODE_CLASS,\n-\t\t  BRIG_TYPE_F32, \"__hsail_class_f32\", BT_FN_UINT_FLOAT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CLASS_F64, BRIG_OPCODE_CLASS,\n-\t\t  BRIG_TYPE_F64, \"__hsail_class_f64\", BT_FN_UINT_DOUBLE_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CLASS_F32_F16, BRIG_OPCODE_CLASS,\n-\t\t  BRIG_TYPE_F16, \"__hsail_class_f32_f16\",\n-\t\t  BT_FN_UINT_FLOAT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FRACT_F32, BRIG_OPCODE_FRACT,\n-\t\t  BRIG_TYPE_F32, \"__hsail_fract_f32\", BT_FN_FLOAT_FLOAT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FRACT_F64, BRIG_OPCODE_FRACT,\n-\t\t  BRIG_TYPE_F64, \"__hsail_fract_f64\", BT_FN_DOUBLE_DOUBLE,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BARRIER, BRIG_OPCODE_BARRIER,\n-\t\t  BRIG_TYPE_NONE, \"__hsail_barrier\", BT_FN_VOID_PTR,\n-\t\t  ATTR_RT_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_INITFBAR, BRIG_OPCODE_INITFBAR,\n-\t\t  BRIG_TYPE_NONE, \"__hsail_initfbar\", BT_FN_VOID_UINT_PTR,\n-\t\t  ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_JOINFBAR, BRIG_OPCODE_JOINFBAR,\n-\t\t  BRIG_TYPE_NONE, \"__hsail_joinfbar\", BT_FN_VOID_UINT_PTR,\n-\t\t  ATTR_NOTHROW_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WAITFBAR, BRIG_OPCODE_WAITFBAR,\n-\t\t  BRIG_TYPE_NONE, \"__hsail_waitfbar\", BT_FN_VOID_UINT_PTR,\n-\t\t  ATTR_RT_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_ARRIVEFBAR, BRIG_OPCODE_ARRIVEFBAR,\n-\t\t  BRIG_TYPE_NONE, \"__hsail_arrivefbar\", BT_FN_VOID_UINT_PTR,\n-\t\t  ATTR_RT_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LEAVEFBAR, BRIG_OPCODE_LEAVEFBAR,\n-\t\t  BRIG_TYPE_NONE, \"__hsail_leavefbar\", BT_FN_VOID_UINT_PTR,\n-\t\t  ATTR_NOTHROW_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_RELEASEFBAR, BRIG_OPCODE_RELEASEFBAR,\n-\t\t  BRIG_TYPE_NONE, \"__hsail_releasefbar\", BT_FN_VOID_UINT_PTR,\n-\t\t  ATTR_NOTHROW_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITALIGN, BRIG_OPCODE_BITALIGN,\n-\t\t  BRIG_TYPE_B32, \"__hsail_bitalign\",\n-\t\t  BT_FN_UINT_ULONG_ULONG_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BYTEALIGN, BRIG_OPCODE_BYTEALIGN,\n-\t\t  BRIG_TYPE_B32, \"__hsail_bytealign\",\n-\t\t  BT_FN_UINT_ULONG_ULONG_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LERP, BRIG_OPCODE_LERP,\n-\t\t  BRIG_TYPE_U8X4, \"__hsail_lerp\", BT_FN_UINT_UINT_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_PACKCVT, BRIG_OPCODE_PACKCVT,\n-\t\t  BRIG_TYPE_U8X4, \"__hsail_packcvt\",\n-\t\t  BT_FN_UINT_FLOAT_FLOAT_FLOAT_FLOAT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_UNPACKCVT, BRIG_OPCODE_UNPACKCVT,\n-\t\t  BRIG_TYPE_F32, \"__hsail_unpackcvt\", BT_FN_FLOAT_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SAD_U16X2, BRIG_OPCODE_SAD,\n-\t\t  BRIG_TYPE_U16X2, \"__hsail_sad_u16x2\",\n-\t\t  BT_FN_UINT_UINT_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SAD_U32, BRIG_OPCODE_SAD,\n-\t\t  BRIG_TYPE_U32, \"__hsail_sad_u32\", BT_FN_UINT_UINT_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SAD_U8X4, BRIG_OPCODE_SAD,\n-\t\t  BRIG_TYPE_U8X4, \"__hsail_sad_u8x4\",\n-\t\t  BT_FN_UINT_UINT_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SADHI_U8X4, BRIG_OPCODE_SADHI,\n-\t\t  BRIG_TYPE_U16X2, \"__hsail_sadhi_u16x2_u8x4\",\n-\t\t  BT_FN_UINT_UINT_UINT_UINT,\n-\t\t  ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CLOCK, BRIG_OPCODE_CLOCK,\n-\t\t  BRIG_TYPE_U64, \"__hsail_clock\", BT_FN_ULONG,\n-\t\t  ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CUID, BRIG_OPCODE_CUID,\n-\t\t  BRIG_TYPE_U32, \"__hsail_cuid\", BT_FN_UINT_PTR,\n-\t\t  ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_MAXCUID, BRIG_OPCODE_MAXCUID,\n-\t\t  BRIG_TYPE_U32, \"__hsail_maxcuid\", BT_FN_UINT_PTR,\n-\t\t  ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_DEBUGTRAP, BRIG_OPCODE_DEBUGTRAP,\n-\t\t  BRIG_TYPE_U32, \"__hsail_debugtrap\", BT_FN_VOID_UINT_PTR,\n-\t\t  ATTR_NORETURN_NOTHROW_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_GROUPBASEPTR, BRIG_OPCODE_GROUPBASEPTR,\n-\t\t  BRIG_TYPE_U32, \"__hsail_groupbaseptr\", BT_FN_UINT_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_KERNARGBASEPTR_U64,\n-\t\t  BRIG_OPCODE_KERNARGBASEPTR, BRIG_TYPE_U64,\n-\t\t  \"__hsail_kernargbaseptr_u64\", BT_FN_ULONG_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_KERNARGBASEPTR_U32,\n-\t\t  BRIG_OPCODE_KERNARGBASEPTR, BRIG_TYPE_U32,\n-\t\t  \"__hsail_kernargbaseptr_u32\", BT_FN_UINT_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_ALLOCA, BRIG_OPCODE_ALLOCA,\n-\t\t  BRIG_TYPE_U32, \"__hsail_alloca\", BT_FN_UINT_UINT_UINT_PTR,\n-\t\t  ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LDQUEUEWRITEINDEX,\n-\t\t  BRIG_OPCODE_LDQUEUEWRITEINDEX,\n-\t\t  BRIG_TYPE_U64, \"__hsail_ldqueuewriteindex\",\n-\t\t  BT_FN_ULONG_ULONG, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LDQUEUEREADINDEX,\n-\t\t  BRIG_OPCODE_LDQUEUEREADINDEX,\n-\t\t  BRIG_TYPE_U64, \"__hsail_ldqueuereadindex\",\n-\t\t  BT_FN_ULONG_ULONG, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_STQUEUEWRITEINDEX,\n-\t\t  BRIG_OPCODE_STQUEUEWRITEINDEX,\n-\t\t  BRIG_TYPE_U64, \"__hsail_stqueuewriteindex\",\n-\t\t  BT_FN_VOID_UINT64_UINT64, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_STQUEUEREADINDEX,\n-\t\t  BRIG_OPCODE_STQUEUEREADINDEX,\n-\t\t  BRIG_TYPE_U64, \"__hsail_stqueuereadindex\",\n-\t\t  BT_FN_VOID_UINT64_UINT64, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_ADDQUEUEWRITEINDEX,\n-\t\t  BRIG_OPCODE_ADDQUEUEWRITEINDEX,\n-\t\t  BRIG_TYPE_U64, \"__hsail_addqueuewriteindex\",\n-\t\t  BT_FN_ULONG_ULONG_ULONG, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CASQUEUEWRITEINDEX,\n-\t\t  BRIG_OPCODE_CASQUEUEWRITEINDEX,\n-\t\t  BRIG_TYPE_U64, \"__hsail_casqueuewriteindex\",\n-\t\t  BT_FN_ULONG_ULONG_ULONG_ULONG, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SEGMENTP_GLOBAL,\n-\t\t  BRIG_OPCODE_SEGMENTP,\n-\t\t  BRIG_TYPE_U32, \"__hsail_segmentp_global\",\n-\t\t  BT_FN_UINT32_UINT64_PTR, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SEGMENTP_GROUP,\n-\t\t  BRIG_OPCODE_SEGMENTP,\n-\t\t  BRIG_TYPE_U32, \"__hsail_segmentp_group\",\n-\t\t  BT_FN_UINT32_UINT64_PTR, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SEGMENTP_PRIVATE,\n-\t\t  BRIG_OPCODE_SEGMENTP,\n-\t\t  BRIG_TYPE_U32, \"__hsail_segmentp_private\",\n-\t\t  BT_FN_UINT32_UINT64_PTR, ATTR_NOTHROW_LEAF_LIST)\n-\n-#ifndef DEF_HSAIL_ATOMIC_BUILTIN\n-#define DEF_HSAIL_ATOMIC_BUILTIN(ENUM, ATOMIC_OPCODE, HSAIL_TYPE,\t\\\n-\t\t\t\t NAME, TYPE, ATTRS)\n-#endif\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MIN_S32, BRIG_ATOMIC_MIN,\n-\t\t\t BRIG_TYPE_S32, \"__hsail_atomic_min_s32\",\n-\t\t\t BT_FN_INT_PTR_INT, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MIN_S64, BRIG_ATOMIC_MIN,\n-\t\t\t BRIG_TYPE_S64, \"__hsail_atomic_min_s64\",\n-\t\t\t BT_FN_LONG_PTR_LONG, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MIN_U32, BRIG_ATOMIC_MIN,\n-\t\t\t BRIG_TYPE_U32, \"__hsail_atomic_min_u32\",\n-\t\t\t BT_FN_UINT_PTR_UINT, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MIN_U64, BRIG_ATOMIC_MIN,\n-\t\t\t BRIG_TYPE_U64, \"__hsail_atomic_min_u64\",\n-\t\t\t BT_FN_ULONG_PTR_ULONG, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MAX_S32, BRIG_ATOMIC_MAX,\n-\t\t\t BRIG_TYPE_S32, \"__hsail_atomic_max_s32\",\n-\t\t\t BT_FN_INT_PTR_INT, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MAX_S64, BRIG_ATOMIC_MAX,\n-\t\t\t BRIG_TYPE_S64, \"__hsail_atomic_max_s64\",\n-\t\t\t BT_FN_LONG_PTR_LONG, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MAX_U32, BRIG_ATOMIC_MAX,\n-\t\t\t BRIG_TYPE_U32, \"__hsail_atomic_max_u32\",\n-\t\t\t BT_FN_UINT_PTR_UINT, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MAX_U64, BRIG_ATOMIC_MAX,\n-\t\t\t BRIG_TYPE_U64, \"__hsail_atomic_max_u64\",\n-\t\t\t BT_FN_ULONG_PTR_ULONG, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_WRAPDEC_U32,\n-\t\t\t BRIG_ATOMIC_WRAPDEC, BRIG_TYPE_U32,\n-\t\t\t \"__hsail_atomic_wrapdec_u32\",\n-\t\t\t BT_FN_UINT_PTR_UINT, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_WRAPDEC_U64,\n-\t\t\t BRIG_ATOMIC_WRAPDEC, BRIG_TYPE_U64,\n-\t\t\t \"__hsail_atomic_wrapdec_u64\",\n-\t\t\t BT_FN_ULONG_PTR_ULONG, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_WRAPINC_U32,\n-\t\t\t BRIG_ATOMIC_WRAPINC, BRIG_TYPE_U32,\n-\t\t\t \"__hsail_atomic_wrapinc_u32\",\n-\t\t\t BT_FN_UINT_PTR_UINT, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_WRAPINC_U64,\n-\t\t\t BRIG_ATOMIC_WRAPINC, BRIG_TYPE_U64,\n-\t\t\t \"__hsail_atomic_wrapinc_u64\",\n-\t\t\t BT_FN_ULONG_PTR_ULONG, ATTR_NOTHROW_LEAF_LIST)\n-\n-#ifndef DEF_HSAIL_SAT_BUILTIN\n-#define DEF_HSAIL_SAT_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE,\t\\\n-\t\t\t      NAME, TYPE, ATTRS)\n-#endif\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_U64, BRIG_OPCODE_ADD,\n-\t\t      BRIG_TYPE_U64, \"__hsail_sat_add_u64\",\n-\t\t      BT_FN_ULONG_ULONG_ULONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_S64, BRIG_OPCODE_ADD,\n-\t\t      BRIG_TYPE_S64, \"__hsail_sat_add_s64\",\n-\t\t      BT_FN_LONG_LONG_LONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_U32, BRIG_OPCODE_ADD,\n-\t\t      BRIG_TYPE_U32, \"__hsail_sat_add_u32\",\n-\t\t      BT_FN_UINT_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_S32, BRIG_OPCODE_ADD,\n-\t\t      BRIG_TYPE_S32, \"__hsail_sat_add_s32\",\n-\t\t      BT_FN_INT_INT_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_U16, BRIG_OPCODE_ADD,\n-\t\t      BRIG_TYPE_U16, \"__hsail_sat_add_u16\",\n-\t\t      BT_FN_UINT16_UINT16_UINT16, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_S16, BRIG_OPCODE_ADD,\n-\t\t      BRIG_TYPE_S16, \"__hsail_sat_add_s16\",\n-\t\t      BT_FN_INT16_INT16_INT16, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_U8, BRIG_OPCODE_ADD,\n-\t\t      BRIG_TYPE_U8, \"__hsail_sat_add_u8\",\n-\t\t      BT_FN_UINT8_UINT8_UINT8, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_S8, BRIG_OPCODE_ADD,\n-\t\t      BRIG_TYPE_S8, \"__hsail_sat_add_s8\",\n-\t\t      BT_FN_INT8_INT8_INT8, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_U64, BRIG_OPCODE_SUB,\n-\t\t      BRIG_TYPE_U64, \"__hsail_sat_sub_u64\",\n-\t\t      BT_FN_ULONG_ULONG_ULONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_S64, BRIG_OPCODE_SUB,\n-\t\t      BRIG_TYPE_S64, \"__hsail_sat_sub_s64\",\n-\t\t      BT_FN_LONG_LONG_LONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_U32, BRIG_OPCODE_SUB,\n-\t\t      BRIG_TYPE_U32, \"__hsail_sat_sub_u32\",\n-\t\t      BT_FN_UINT_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_S32, BRIG_OPCODE_SUB,\n-\t\t      BRIG_TYPE_S32, \"__hsail_sat_sub_s32\",\n-\t\t      BT_FN_INT_INT_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_U16, BRIG_OPCODE_SUB,\n-\t\t      BRIG_TYPE_U16, \"__hsail_sat_sub_u16\",\n-\t\t      BT_FN_UINT16_UINT16_UINT16, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_S16, BRIG_OPCODE_SUB,\n-\t\t      BRIG_TYPE_S16, \"__hsail_sat_sub_s16\",\n-\t\t      BT_FN_INT16_INT16_INT16, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_U8, BRIG_OPCODE_SUB,\n-\t\t      BRIG_TYPE_U8, \"__hsail_sat_sub_u8\",\n-\t\t      BT_FN_UINT8_UINT8_UINT8, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_S8, BRIG_OPCODE_SUB,\n-\t\t      BRIG_TYPE_S8, \"__hsail_sat_sub_s8\",\n-\t\t      BT_FN_INT8_INT8_INT8, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_U64, BRIG_OPCODE_MUL,\n-\t\t      BRIG_TYPE_U64, \"__hsail_sat_mul_u64\",\n-\t\t      BT_FN_ULONG_ULONG_ULONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_S64, BRIG_OPCODE_MUL,\n-\t\t      BRIG_TYPE_S64, \"__hsail_sat_mul_s64\",\n-\t\t      BT_FN_LONG_LONG_LONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_U32, BRIG_OPCODE_MUL,\n-\t\t      BRIG_TYPE_U32, \"__hsail_sat_mul_u32\",\n-\t\t      BT_FN_UINT_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_S32, BRIG_OPCODE_MUL,\n-\t\t      BRIG_TYPE_S32, \"__hsail_sat_mul_s32\",\n-\t\t      BT_FN_INT_INT_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_U16, BRIG_OPCODE_MUL,\n-\t\t      BRIG_TYPE_U16, \"__hsail_sat_mul_u16\",\n-\t\t      BT_FN_UINT16_UINT16_UINT16, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_S16, BRIG_OPCODE_MUL,\n-\t\t      BRIG_TYPE_S16, \"__hsail_sat_mul_s16\",\n-\t\t      BT_FN_INT16_INT16_INT16, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_U8, BRIG_OPCODE_MUL,\n-\t\t      BRIG_TYPE_U8, \"__hsail_sat_mul_u8\",\n-\t\t      BT_FN_UINT8_UINT8_UINT8, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_S8, BRIG_OPCODE_MUL,\n-\t\t      BRIG_TYPE_S8, \"__hsail_sat_mul_s8\",\n-\t\t      BT_FN_INT8_INT8_INT8, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-#ifndef DEF_HSAIL_INTR_BUILTIN\n-#define DEF_HSAIL_INTR_BUILTIN(ENUM, NAME, TYPE, ATTRS)\n-#endif\n-\n-DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_FTZ_F32_F16, \"__hsail_ftz_f32_f16\",\n-\t\t       BT_FN_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_FTZ_F32, \"__hsail_ftz_f32\",\n-\t\t       BT_FN_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_FTZ_F64, \"__hsail_ftz_f64\",\n-\t\t       BT_FN_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_PUSH_FRAME, \"__hsail_alloca_push_frame\",\n-\t\t       BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_POP_FRAME, \"__hsail_alloca_pop_frame\",\n-\t\t       BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_SETWORKITEMID, \"__hsail_setworkitemid\",\n-\t\t       BT_FN_VOID_UINT32_UINT32_PTR, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_LAUNCH_WG_FUNC,\n-\t\t       \"__hsail_launch_wg_function\",\n-\t\t       BT_FN_VOID_PTR_PTR_UINT32, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_LAUNCH_KERNEL,\n-\t\t       \"__hsail_launch_kernel\",\n-\t\t       BT_FN_VOID_PTR_PTR_PTR, ATTR_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_F32_TO_F16, \"__hsail_f32_to_f16\",\n-\t\t       BT_FN_UINT16_UINT32, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_F16_TO_F32, \"__hsail_f16_to_f32\",\n-\t\t       BT_FN_UINT32_UINT16, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-#ifndef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n-#define DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN(ENUM, HSAIL_DEST_TYPE, HSAIL_SRC_TYPE, \\\n-\tNAME, TYPE, ATTRS)\n-#endif\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U8_F32,\n-\t\t\t\tBRIG_TYPE_U8, BRIG_TYPE_F32,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_u8_f32\",\n-\t\t\t\tBT_FN_UINT8_FLOAT,\n-\t\t\t\tATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S8_F32,\n-\t\t\t\tBRIG_TYPE_S8, BRIG_TYPE_F32,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_s8_f32\",\n-\t\t\t\tBT_FN_INT8_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U16_F32,\n-\t\t\t\tBRIG_TYPE_U16, BRIG_TYPE_F32,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_u16_f32\",\n-\t\t\t\tBT_FN_UINT16_FLOAT,\n-\t\t\t\tATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S16_F32,\n-\t\t\t\tBRIG_TYPE_S16, BRIG_TYPE_F32,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_s16_f32\",\n-\t\t\t\tBT_FN_INT16_FLOAT,\n-\t\t\t\tATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U32_F32,\n-\t\t\t\tBRIG_TYPE_U32, BRIG_TYPE_F32,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_u32_f32\",\n-\t\t\t\tBT_FN_UINT32_FLOAT,\n-\t\t\t\tATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S32_F32,\n-\t\t\t\tBRIG_TYPE_S32, BRIG_TYPE_F32,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_s32_f32\",\n-\t\t\t\tBT_FN_INT_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U64_F32,\n-\t\t\t\tBRIG_TYPE_U64, BRIG_TYPE_F32,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_u64_f32\",\n-\t\t\t\tBT_FN_UINT64_FLOAT,\n-\t\t\t\tATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S64_F32,\n-\t\t\t\tBRIG_TYPE_S64, BRIG_TYPE_F32,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_s64_f32\",\n-\t\t\t\tBT_FN_LONG_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U8_F64,\n-\t\t\t\tBRIG_TYPE_U8, BRIG_TYPE_F64,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_u8_f64\",\n-\t\t\t\tBT_FN_UINT8_FLOAT,\n-\t\t\t\tATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S8_F64,\n-\t\t\t\tBRIG_TYPE_S8, BRIG_TYPE_F64,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_s8_f64\",\n-\t\t\t\tBT_FN_INT8_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U16_F64,\n-\t\t\t\tBRIG_TYPE_U16, BRIG_TYPE_F64,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_u16_f64\",\n-\t\t\t\tBT_FN_UINT16_FLOAT,\n-\t\t\t\tATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S16_F64,\n-\t\t\t\tBRIG_TYPE_S16, BRIG_TYPE_F64,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_s16_f64\",\n-\t\t\t\tBT_FN_INT16_FLOAT,\n-\t\t\t\tATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U32_F64,\n-\t\t\t\tBRIG_TYPE_U32, BRIG_TYPE_F64,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_u32_f64\",\n-\t\t\t\tBT_FN_UINT32_FLOAT,\n-\t\t\t\tATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S32_F64,\n-\t\t\t\tBRIG_TYPE_S32, BRIG_TYPE_F64,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_s32_f64\",\n-\t\t\t\tBT_FN_INT_FLOAT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U64_F64,\n-\t\t\t\tBRIG_TYPE_U64, BRIG_TYPE_F64,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_u64_f64\",\n-\t\t\t\tBT_FN_UINT64_FLOAT,\n-\t\t\t\tATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S64_F64,\n-\t\t\t\tBRIG_TYPE_S64, BRIG_TYPE_F64,\n-\t\t       \t\t\"__hsail_cvt_zeroi_sat_s64_f64\",\n-\t\t\t\tBT_FN_LONG_FLOAT,\n-\t\t\t\tATTR_CONST_NOTHROW_LEAF_LIST)"}, {"sha": "7d599fab6ac60f321c89ca2a9f9d4bc280a6086e", "filename": "gcc/brig/ChangeLog", "status": "removed", "additions": 0, "deletions": 433, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2FChangeLog?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,433 +0,0 @@\n-2020-12-16  Martin Liska  <mliska@suse.cz>\n-\n-\t* lang.opt: Remove usage of Report.\n-\n-2020-11-20  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR other/97911\n-\t* Make-lang.in (brig.serial): Change from goal to a variable.\n-\t(.PHONY): Drop brig.serial and brig.prev.\n-\t(brig1$(exeext)): Depend on $(brig.serial) rather than brig.serial.\n-\n-2020-11-18  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* Make-lang.in (brig.serial): New goal.\n-\t(.PHONY): Add brig.serial brig.prev.\n-\t(brig1$(exeext)): Depend on brig.prev.  Call LINK_PROGRESS.\n-\n-2020-08-03  Martin Jambor  <mjambor@suse.cz>\n-\n-\t* brigfrontend/brig-util.h (hsa_type_packed_p): Declared.\n-\t* brigfrontend/brig-util.cc (hsa_type_packed_p): Moved here from\n-\tremoved gcc/hsa-common.c.\n-\t* brigfrontend/hsa-brig-format.h: New file.\n-\n-2020-01-01  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tUpdate copyright years.\n-\n-2019-10-04  Joseph Myers  <joseph@codesourcery.com>\n-\n-\t* brig-lang.c (flag_isoc2x): New variable.\n-\n-2019-08-23  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR middle-end/91283\n-\t* brig-lang.c (brig_langhook_post_options): Set flag_excess_precision\n-\tinstead of flag_excess_precision_cmdline.\n-\n-2019-06-25  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n-\n-\t* brig-lang.c (brig_build_c_type_nodes): Accept \"__intN__\"\n-\tformat of \"__intN\" types for SIZE_TYPE.\n-\n-2019-05-16  Martin Sebor  <msebor@redhat.com>\n-\n-\t* brigfrontend/brig-control-handler.cc\n-\t(brig_directive_control_handler::operator): Remove trailing newline\n-\tfrom a diagnostic.\n-\t* brigfrontend/brig-module-handler.cc\n-\t(brig_directive_module_handler::operator): Remove a duplicated space\n-\tfrom a diagnostic.\n-\n-2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tUpdate copyright years.\n-\n-2018-10-17  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* Make-lang.in (selftest-brig): New.\n-\n-2018-07-20  Martin Sebor  <msebor@redhat.com>\n-\n-\tPR middle-end/82063\n-\t* brig-lang.c (brig_langhook_handle_option): Change function\n-\targument to HOST_WIDE_INT.\n-\n-2018-07-04  Martin Jambor  <mjambor@suse.cz>\n-\n-\tPR hsa/86371\n-\t* Make-lang.in (BRIGINCLUDES): Remove erroneous include path in $HOME.\n-\n-2018-06-28  Martin Liska  <mliska@suse.cz>\n-\n-\t* brigspec.c: Add missing header file inclusion.\n-\n-2018-06-08  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* brigfrontend/brig-to-generic.cc\n-\t(brig_to_generic::write_globals): Use TDF_NONE rather than 0.\n-\t(dump_function): Likewise.\n-\n-2018-05-18  Richard Sandiford  <richard.sandiford@linaro.org>\n-\n-\t* brigfrontend/brig-function.cc\n-\t(brig_function::get_builtin_for_hsa_opcode): Use BUILT_IN_FMA\n-\tfor BRIG_OPCODE_FMA.\n-\t(brig_function::get_tree_code_for_hsa_opcode): Treat BUILT_IN_FMA\n-\tas a call.\n-\n-2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brigfrontend/brig-basic-inst-handler.cc: Fix handling of NOPs.\n-\n-2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\tAdd flag -fassume-phsa that is on by default. If -fno-assume-phsa\n-\tis given, these optimizations are disabled.  With this flag, gccbrig\n-\tcan generate GENERIC that assumes we are targeting a phsa-runtime\n-\tbased implementation, which allows us to expose the work-item context\n-\taccesses to retrieve WI IDs etc.  which helps optimizers.\n-\tFirst optimization that takes advantage of this is to get rid of\n-\tthe setworkitemid calls whenever we have non-inlined calls that\n-\tuse IDs internally.  Other optimizations added in this commit:\n-\t- expand absoluteid to similar level of simplicity as workitemid.\n-\tAt the moment absoluteid is the best indexing ID to end up with\n-\tWG vectorization.\n-\t- propagate ID variables closer to their uses. This is mainly\n-\tto avoid known useless casts, which confuse at least scalar\n-\tevolution analysis.\n-\t- use signed long long for storing IDs. Unsigned integers have\n-\tdefined wraparound semantics, which confuse at least scalar\n-\tevolution analysis, leading to unvectorizable WI loops.\n-\t- also refactor some BRIG function generation helpers to brig_function.\n-\t- no point in having the wi-loop as a for-loop. It's really\n-\ta do...while and SCEV can analyze it just fine still.\n-\t- add consts to ptrs etc. in BRIG builtin defs.\n-\tImproves optimization opportunities.\n-\t- add qualifiers to generated function parameters.\n-\tConst and restrict on the hidden local/private pointers,\n-\tthe arg buffer and the context pointer help some optimizations.\n-\t* brigfrontend/brig-basic-inst-handler.cc: See above.\n-\t* brigfrontend/brig-branch-inst-handler.cc: See above.\n-\t* brigfrontend/brig-cmp-inst-handler.cc: See above.\n-\t* brigfrontend/brig-code-entry-handler.cc: See above.\n-\t* brigfrontend/brig-code-entry-handler.h: See above.\n-\t* brigfrontend/brig-control-handler.cc: See above.\n-\t* brigfrontend/brig-cvt-inst-handler.cc: See above.\n-\t* brigfrontend/brig-function-handler.cc: See above.\n-\t* brigfrontend/brig-function.cc: See above.\n-\t* brigfrontend/brig-function.h: See above.\n-\t* brigfrontend/brig-label-handler.cc: See above.\n-\t* brigfrontend/brig-lane-inst-handler.cc: See above.\n-\t* brigfrontend/brig-mem-inst-handler.cc: See above.\n-\t* brigfrontend/phsa.h: See above.\n-\t* lang.opt: See above.\n-\n-2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brigfrontend/brig-function-handler.cc: Skip multiple forward\n-\tdeclarations of the same function.\n-\n-2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brig-lang.c: Do not allow optimizations based on known C\n-\tbuiltins.\n-\n-2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brig-lang.c: Allow controlling strict aliasing from\n-\tcmd line.\n-\n-2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brigfrontend/brig-code-entry-handler.cc: The modulo in\n-\tID computation should not be needed.\n-\n-2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brig-lang.c: Add support for whole program\n-\toptimizations by marking the kernels externally visible.\n-\t* brigfrontend/brig-branch-inst-handler.cc: See above.\n-\t* brigfrontend/brig-function-handler.cc: See above.\n-\t* brigfrontend/brig-function.cc: See above.\n-\t* brigfrontend/brig-to-generic.cc: See above.\n-\t* brigfrontend/brig-to-generic.h: See above.\n-\t* brigfrontend/brig-variable-handler.h: See above.\n-\n-2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n-\t    Alan Hayward  <alan.hayward@arm.com>\n-\t    David Sherwood  <david.sherwood@arm.com>\n-\n-\t* brigfrontend/brig-to-generic.cc (get_unsigned_int_type): Handle\n-\tpolynomial TYPE_VECTOR_SUBPARTS.\n-\t* brigfrontend/brig-util.h (gccbrig_type_vector_subparts): Likewise.\n-\n-2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tUpdate copyright years.\n-\n-2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n-\t    Alan Hayward  <alan.hayward@arm.com>\n-\t    David Sherwood  <david.sherwood@arm.com>\n-\n-\t* brigfrontend/brig-util.h (gccbrig_type_vector_subparts): New\n-\tfunction.\n-\t* brigfrontend/brig-basic-inst-handler.cc\n-\t(brig_basic_inst_handler::build_shuffle): Use it instead of\n-\tTYPE_VECTOR_SUBPARTS.\n-\t(brig_basic_inst_handler::build_unpack): Likewise.\n-\t(brig_basic_inst_handler::build_pack): Likewise.\n-\t(brig_basic_inst_handler::build_unpack_lo_or_hi): Likewise.\n-\t(brig_basic_inst_handler::operator ()): Likewise.\n-\t(brig_basic_inst_handler::build_lower_element_broadcast): Likewise.\n-\t* brigfrontend/brig-code-entry-handler.cc\n-\t(brig_code_entry_handler::get_tree_cst_for_hsa_operand): Likewise.\n-\t(brig_code_entry_handler::get_comparison_result_type): Likewise.\n-\t(brig_code_entry_handler::expand_or_call_builtin): Likewise.\n-\n-2017-12-15  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* brig-lang.c (brig_attribute_table): Swap affects_type_identity\n-\tand handler fields, adjust comments.\n-\n-2017-12-08  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* brig-lang.c (brig_attribute_table): Fix up comment.\n-\n-2017-11-28  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* brigfrontend/brig-branch-inst-handler.cc\n-\t(brig_branch_inst_handler::operator): Build SWITCH_EXPR using build2\n-\tinstead of build3.\n-\n-2017-11-17  Henry Linjam\u00e4ki  <henry.linjamaki@parmance.com>\n-\n-\t* brigfrontend/brig-util.cc: Fix sprintf format string type mismatch\n-\ton 32b machines.\n-\n-2017-11-16  Henry Linjam\u00e4ki  <henry.linjamaki@parmance.com>\n-\n-\tChange internal representation of HSA registers. Instead\n-\trepresenting HSA's untyped registers as unsigned int the gccbrig\n-\tanalyzes brig code and builds the register variables as a type\n-\tused in tree expressions at most. This gives better chance to\n-\toptimize CONVERT_VIEW_EXPRs away.\n-\t* brigfrontend/brig-code-entry-handler.cc: Add analysis method for\n-\tregister type usage. Handle any-typed register variables.\n-\t* brigfrontend/brig-code-entry-handler.h: New declarations for the\n-\tabove.\n-\t* brigfrontend/brig-copy-move-inst-handler.cc: Handle any-typed\n-\tregister variables.\n-\t* brigfrontend/brig-cvt-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-function.cc: Build register variables as a\n-\ttype based on results of analysis phase.\n-\t* brigfrontend/brig-function.h: Move HSA register count defines to\n-\tbrig-utils.h.\n-\t* brigfrontend/brig-to-generic.cc: New analysis handler. Analyze\n-\tHSA register usage.\n-\t* brigfrontend/brig-to-generic.h: New declarations.\n-\t* brigfrontend/brig-util.cc: New utility functions.\n-\t* brigfrontend/brig-util.h: New declarations for the above.\n-\n-2017-11-16  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* gccbrig.texi: Added some documentation.\n-\n-2017-10-31  Henry Linjam\u00e4ki  <henry.linjamaki@parmance.com>\n-\n-\t* brig-lang.c (brig_langhook_type_for_mode): Fix PR 82771.\n-\n-2017-10-23  Richard Sandiford  <richard.sandiford@linaro.org>\n-\n-\t* brig-lang.c (brig_langhook_type_for_mode): Use scalar_int_mode\n-\tand scalar_float_mode.\n-\n-2017-10-09  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brigfrontend/brig-to-generic.cc: Support BRIG_KIND_NONE\n-\tdirectives.  These directives are legal everywhere.  They\n-\tcan be used to patch away BRIG entries at the binary level.\n-\tAlso add extra error detection for zeroed regions: make sure\n-\tthe byteCount field is never zero.\n-\t* brigfrontend/phsa.h: Added a new error prefix for\n-\terrors which are due to corrupted BRIG modules.\n-\n-2017-10-09  Henry Linjam\u00e4ki  <henry.linjamaki@parmance.com>\n-\n-\t* brigfrontend/brig-branch-inst-handler.cc: The call code\n-\tstill failed a few test cases. Now all PRM cases pass again.\n-\n-2017-10-03  Henry Linjam\u00e4ki  <henry.linjamaki@parmance.com>\n-\n-\t* brigfrontend/brig-branch-inst-handler.cc: Fix (more) crash with\n-\tcalls with more than 4 args.  It missed a reference which is required\n-\tbecause vector expansion can move the object to another location.\n-\n-2017-09-29  Henry Linjam\u00e4ki  <henry.linjamaki@parmance.com>\n-\n-\t* brigfrontend/brig-branch-inst-handler.cc: Fix crash with\n-\tcalls with more than 4 args. Also fix a misexecution issue\n-\twith kernels that have both unexpanded ID functions and\n-\tcalls to subfunctions.\n-\n-2017-09-28  Henry Linjam\u00e4ki  <henry.linjamaki@parmance.com>\n-\n-\t* brig-lang.c: Added function attributes and their handlers.\n-\tMake BRIGFE 3-level optimize by default.\n-\n-2017-09-27  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brig-lang.c: Improved support for function and module scope\n-\tgroup segment variables.  PRM specs defines function and module\n-\tscope group segment variables as an experimental feature. However,\n-\tPRM test suite uses and hcc relies on them. In addition, hcc\n-\tassumes certain group variable layout in its dynamic group segment\n-\tallocation code.  We cannot have global group memory offsets if we\n-\twant to both have kernel-specific group segment size and multiple\n-\tkernels calling the same functions that use function scope group memory\n-\tvariables.  Now group segment is handled by separate book keeping of\n-\tmodule scope and function (kernel) offsets. Each function has a \"frame\"\n-\tin the group segment offset to which is given as an argument.\n-\t* brigfrontend/brig-branch-inst-handler.cc: See above.\n-\t* brigfrontend/brig-code-entry-handler.cc: See above.\n-\t* brigfrontend/brig-fbarrier-handler.cc: See above.\n-\t* brigfrontend/brig-function-handler.cc: See above.\n-\t* brigfrontend/brig-function.cc: See above.\n-\t* brigfrontend/brig-function.h: See above.\n-\t* brigfrontend/brig-to-generic.cc: See above.\n-\t* brigfrontend/brig-to-generic.h: See above.\n-\t* brigfrontend/brig-util.cc: See above.\n-\t* brigfrontend/brig-util.h: See above.\n-\t* brigfrontend/brig-variable-handler.cc: See above.\n-\n-2017-09-25  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brigfrontend/brig-to-generic.cc: Ensure per WI copies of\n-\tprivate variables are aligned too.\n-\n-2017-09-17  Thomas Schwinge  <thomas@codesourcery.com>\n-\n-\t* Make-lang.in (GO_TEXI_FILES): Rename to...\n-\t(BRIG_TEXI_FILES): ... this.\n-\t(doc/gccbrig.info, doc/gccbrig.dvi, doc/gccbrig.pdf, brig.info)\n-\t(brig.srcinfo, brig.man, brig.srcman, brig.install-man)\n-\t($(DESTDIR)$(man1dir)/$(GCCBRIG_INSTALL_NAME)$(man1ext)):\n-\tUncomment/enable targets.\n-\t(gccbrig.pod): New target.\n-\t* gccbrig.texi: New file.\n-\n-2017-08-04  Henry Linjam\u00e4ki  <henry.linjamaki@parmance.com>\n-\n-\tFix PR 81713\n-\t* brigfrontend/brig-basic-inst-handler.cc: replace build_int_cst with\n-\tbitsize_int in building BIT_FIELD_REF.\n-\t* brigfrontend/brig-code-entry-handler.cc: likewise.\n-\n-2017-07-05  Richard Sandiford  <richard.sandiford@linaro.org>\n-\t    Alan Hayward  <alan.hayward@arm.com>\n-\t    David Sherwood  <david.sherwood@arm.com>\n-\n-\t* brig-c.h (brig_type_for_mode): Remove \"enum\" before \"machine_mode\".\n-\t* brig-lang.c (brig_langhook_type_for_mode): Likewise.\n-\n-2017-07-04  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* brigfrontend/brig-function.cc: Include profile-count.h.\n-\t* brigfrontend/brig-to-generic.cc: Likewise.\n-\n-2017-05-18  Thomas Schwinge  <thomas@codesourcery.com>\n-\n-\t* brigfrontend/brig-to-generic.h (class brig_to_generic): Use\n-\t\"dump_flags_t\" for \"m_dump_flags\" member.\n-\n-2017-05-13  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brigfrontend/brig-code-entry-handler.cc\n-\t(brig_code_entry_handler::build_address_operand): Fix\n-\tan assertion when doing an 'lda' of a private array\n-\toffset.\n-\n-2017-05-03  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brigfrontend/brig-code-entry-handler.cc\n-\t(brig_code_entry_handler::build_address_operand): Fix a bug\n-\twith reg+offset addressing on 32b segments. In large mode,\n-\tthe offset is treated as 32bits unless it's global, readonly or\n-\tkernarg address space.\n-\n-2016-02-01  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* brigfrontend/brig-code-entry-handler.cc: fix address\n-\texpressions which refer only to offset 0, but nothing else.\n-\t* brigfrontend/brig-lane-inst-handler.cc: fix\n-\tactivelanepermute_b64 HSAIL instruction.\n-\t* brigfrontend/brig-to-generic.cc: remove useless c_str()\n-\tcall. Add missing va_end (). Fix PR79250.\n-\n-2017-01-30  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* brigfrontend/brig-code-entry-handler.cc\n-\t(brig_code_entry_handler::get_tree_cst_for_hsa_operand): For %lu\n-\tcast size_t arguments to unsigned long.\n-\n-2017-01-27  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n-\n-\t* config-lang.in: Removed stale target-libbrig reference.\n-\n-2017-01-26  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tUpdate copyright years.\n-\n-2017-01-24  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka@parmance.com>\n-\t    Martin Jambor  <mjambor@suse.cz>\n-\n-\t* Make-lang.in: New file.\n-\t* brig-builtins.h: Likewise.\n-\t* brig-c.h: Likewise.\n-\t* brig-lang.c: Likewise.\n-\t* brigspec.c: Likewise.\n-\t* config-lang.in: Likewise.\n-\t* lang-specs.h: Likewise.\n-\t* lang.opt: Likewise.\n-\t* brigfrontend/brig-arg-block-handler.cc: Likewise.\n-\t* brigfrontend/brig-atomic-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-basic-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-branch-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-cmp-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-code-entry-handler.cc: Likewise.\n-\t* brigfrontend/brig-code-entry-handler.h: Likewise.\n-\t* brigfrontend/brig-comment-handler.cc: Likewise.\n-\t* brigfrontend/brig-control-handler.cc: Likewise.\n-\t* brigfrontend/brig-copy-move-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-cvt-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-fbarrier-handler.cc: Likewise.\n-\t* brigfrontend/brig-function-handler.cc: Likewise.\n-\t* brigfrontend/brig-function.cc: Likewise.\n-\t* brigfrontend/brig-function.h: Likewise.\n-\t* brigfrontend/brig-inst-mod-handler.cc: Likewise.\n-\t* brigfrontend/brig-label-handler.cc: Likewise.\n-\t* brigfrontend/brig-lane-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-machine.c: Likewise.\n-\t* brigfrontend/brig-machine.h: Likewise.\n-\t* brigfrontend/brig-mem-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-module-handler.cc: Likewise.\n-\t* brigfrontend/brig-queue-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-seg-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-signal-inst-handler.cc: Likewise.\n-\t* brigfrontend/brig-to-generic.cc: Likewise.\n-\t* brigfrontend/brig-to-generic.h: Likewise.\n-\t* brigfrontend/brig-util.cc: Likewise.\n-\t* brigfrontend/brig-util.h: Likewise.\n-\t* brigfrontend/brig-variable-handler.cc: Likewise.\n-\t* brigfrontend/phsa.h: Likewise."}, {"sha": "89370f01c64ea62fa6c8c410c5432f5e665f31cb", "filename": "gcc/brig/Make-lang.in", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2FMake-lang.in?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,251 +0,0 @@\n-# Make-lang.in -- Top level -*- makefile -*- fragment for gcc BRIG (HSAIL)\n-# frontend.\n-\n-# Copyright (C) 2015-2021 Free Software Foundation, Inc.\n-\n-# This file is part of GCC.\n-\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-# This file provides the language dependent support in the main Makefile.\n-\n-# Installation name.\n-\n-GCCBRIG_INSTALL_NAME := $(shell echo gccbrig|sed '$(program_transform_name)')\n-GCCBRIG_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gccbrig|sed \\\n-\t'$(program_transform_name)')\n-\n-# The name for selecting brig in LANGUAGES.\n-brig: brig1$(exeext)\n-brig.serial = brig1$(exeext)\n-\n-.PHONY: brig\n-\n-CFLAGS-brig/brigspec.o += $(DRIVER_DEFINES)\n-\n-GCCBRIG_OBJS = $(GCC_OBJS) brig/brigspec.o\n-gccbrig$(exeext): $(GCCBRIG_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \\\n-\t$(LIBDEPS)\n-\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n-\t  $(GCCBRIG_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \\\n-\t  $(EXTRA_GCC_LIBS) $(LIBS)\n-\n-# The cross-compiler version.  This is built mainly as a signal to the\n-# brig.install-common target.  If this executable exists, it means that\n-# brig.all.cross was run.\n-gccbrig-cross$(exeext): gccbrig$(exeext)\n-\t-rm -f gccbrig-cross$(exeext)\n-\tcp gccbrig$(exeext) gccbrig-cross$(exeext)\n-\n-# Use strict warnings.\n-brig-warn = $(STRICT_WARN)\n-\n-BRIG_OBJS = \\\n-\tbrig/brig-lang.o \\\n-\tbrig/brig-code-entry-handler.o \\\n-\tbrig/brig-function-handler.o \\\n-\tbrig/brig-variable-handler.o \\\n-\tbrig/brig-fbarrier-handler.o \\\n-\tbrig/brig-label-handler.o \\\n-\tbrig/brig-comment-handler.o \\\n-\tbrig/brig-basic-inst-handler.o \\\n-\tbrig/brig-cvt-inst-handler.o \\\n-\tbrig/brig-seg-inst-handler.o \\\n-\tbrig/brig-lane-inst-handler.o \\\n-\tbrig/brig-queue-inst-handler.o \\\n-\tbrig/brig-copy-move-inst-handler.o \\\n-\tbrig/brig-signal-inst-handler.o \\\n-\tbrig/brig-atomic-inst-handler.o \\\n-\tbrig/brig-arg-block-handler.o \\\n-\tbrig/brig-control-handler.o \\\n-\tbrig/brig-cmp-inst-handler.o \\\n-\tbrig/brig-branch-inst-handler.o \\\n-\tbrig/brig-mem-inst-handler.o \\\n-\tbrig/brig-module-handler.o \\\n-\tbrig/brig-inst-mod-handler.o \\\n-\tbrig/brig-function.o \\\n-\tbrig/brig-to-generic.o \\\n-\tbrig/brig-machine.o \\\n-\tbrig/brig-util.o\n-\n-brig_OBJS = $(BRIG_OBJS) brig/brigspec.o\n-\n-brig1$(exeext): $(BRIG_OBJS) attribs.o $(BACKEND) $(LIBDEPS) $(brig.prev)\n-\t@$(call LINK_PROGRESS,$(INDEX.brig),start)\n-\t+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n-\t      $(BRIG_OBJS) attribs.o $(BACKEND) $(LIBS) \\\n-\t\t  $(BACKENDLIBS)\n-\t@$(call LINK_PROGRESS,$(INDEX.brig),end)\n-\n-# Documentation.\n-\n-BRIG_TEXI_FILES = \\\n-\tbrig/gccbrig.texi \\\n-\t$(gcc_docdir)/include/fdl.texi \\\n-\t$(gcc_docdir)/include/gpl_v3.texi \\\n-\t$(gcc_docdir)/include/gcc-common.texi \\\n-\tgcc-vers.texi\n-\n-doc/gccbrig.info: $(BRIG_TEXI_FILES)\n-\tif test \"x$(BUILD_INFO)\" = xinfo; then \\\n-\t  rm -f doc/gccbrig.info*; \\\n-\t  $(MAKEINFO) $(MAKEINFOFLAGS) -I $(gcc_docdir) \\\n-\t\t-I $(gcc_docdir)/include -o $@ $<; \\\n-\telse true; fi\n-\n-doc/gccbrig.dvi: $(BRIG_TEXI_FILES)\n-\t$(TEXI2DVI) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n-\n-doc/gccbrig.pdf: $(BRIG_TEXI_FILES)\n-\t$(TEXI2PDF) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n-\n-$(build_htmldir)/brig/index.html: $(BRIG_TEXI_FILES)\n-\t$(mkinstalldirs) $(@D)\n-\trm -f $(@D)/*\n-\t$(TEXI2HTML) -I $(gcc_docdir) -I $(gcc_docdir)/include \\\n-\t\t-I $(srcdir)/brig -o $(@D) $<\n-\n-.INTERMEDIATE: gccbrig.pod\n-\n-gccbrig.pod: brig/gccbrig.texi\n-\t-$(TEXI2POD) -D gccbrig < $< > $@\n-\n-# Build hooks.\n-\n-brig.all.cross: gccbrig-cross$(exeext)\n-brig.start.encap: gccbrig$(exeext)\n-brig.rest.encap:\n-brig.info: doc/gccbrig.info\n-brig.dvi: doc/gccbrig.dvi\n-brig.pdf: doc/gccbrig.pdf\n-brig.html: $(build_htmldir)/brig/index.html\n-brig.srcinfo: doc/gccbrig.info\n-\t-cp -p $^ $(srcdir)/doc\n-\n-brig.srcextra:\n-brig.tags: force\n-\tcd $(srcdir)/brig; \\\n-\tetags -o TAGS.sub *.c *.h; \\\n-\tetags --include TAGS.sub --include ../TAGS.sub\n-\n-brig.man: doc/gccbrig.1\n-brig.srcman: doc/gccbrig.1\n-\t-cp -p $^ $(srcdir)/doc\n-\n-lang_checks += check-brig\n-\n-# No brig-specific selftests\n-selftest-brig:\n-\n-# Install hooks.\n-\n-brig.install-common: installdirs\n-\t-rm -f $(DESTDIR)$(bindir)/$(GCCBRIG_INSTALL_NAME)$(exeext)\n-\t$(INSTALL_PROGRAM) gccbrig$(exeext) \\\n-\t$(DESTDIR)$(bindir)/$(GCCBRIG_INSTALL_NAME)$(exeext)\n-\t-if test -f brig1$(exeext); then \\\n-\t  if test -f gccbrig-cross$(exeext); then \\\n-\t    :; \\\n-\t  else \\\n-\t    rm -f $(DESTDIR)$(bindir)/$(GCCBRIG_TARGET_INSTALL_NAME)$(exeext); \\\n-\t    ( cd $(DESTDIR)$(bindir) && \\\n-\t      $(LN) $(GCCBRIG_INSTALL_NAME)$(exeext) \\\n-\t      $(GCCBRIG_TARGET_INSTALL_NAME)$(exeext) ); \\\n-\t  fi; \\\n-\tfi\n-\n-brig.install-plugin:\n-\n-brig.install-info: #$(DESTDIR)$(infodir)/gccbrig.info\n-\n-brig.install-pdf: doc/gccbrig.pdf\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(pdfdir)\" || $(mkinstalldirs) \"$(DESTDIR)$(pdfdir)/gcc\"\n-\t@for p in doc/gccbrig.pdf; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  f=$(pdf__strip_dir) \\\n-\t  echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'\"; \\\n-\t  $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(pdfdir)/gcc/$$f\"; \\\n-\tdone\n-\n-brig.install-html: $(build_htmldir)/brig\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(htmldir)\" || $(mkinstalldirs) \"$(DESTDIR)$(htmldir)\"\n-\t@for p in $(build_htmldir)/brig; do \\\n-\t  if test -f \"$$p\" || test -d \"$$p\"; then d=\"\"; else d=\"$(srcdir)/\"; \\\n-\t  fi; \\\n-\t  f=$(html__strip_dir) \\\n-\t  if test -d \"$$d$$p\"; then \\\n-\t    echo \" $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(mkinstalldirs) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n-\t    echo \" $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(INSTALL_DATA) \"$$d$$p\"/* \"$(DESTDIR)$(htmldir)/$$f\"; \\\n-\t  else \\\n-\t    echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(htmldir)/$$f\"; \\\n-\t  fi; \\\n-\tdone\n-\n-brig.install-man: $(DESTDIR)$(man1dir)/$(GCCBRIG_INSTALL_NAME)$(man1ext)\n-\n-$(DESTDIR)$(man1dir)/$(GCCBRIG_INSTALL_NAME)$(man1ext): doc/gccbrig.1 \\\n-\tinstalldirs\n-\t-rm -f $@\n-\t-$(INSTALL_DATA) $< $@\n-\t-chmod a-x $@\n-\n-brig.uninstall:\n-\trm -rf $(DESTDIR)$(bindir)/$(GCCBRIG_INSTALL_NAME)$(exeext)\n-\trm -rf $(DESTDIR)$(man1dir)/$(GCCBRIG_INSTALL_NAME)$(man1ext)\n-\trm -rf $(DESTDIR)$(bindir)/$(GCCBRIG_TARGET_INSTALL_NAME)$(exeext)\n-\trm -rf $(DESTDIR)$(infodir)/gccbrig.info*\n-\n-# Clean hooks.\n-\n-brig.mostlyclean:\n-\t-rm -f brig/*$(objext)\n-\t-rm -f brig/*$(coverageexts)\n-brig.clean:\n-brig.distclean:\n-brig.maintainer-clean:\n-\t-rm -f $(docobjdir)/gccbrig.1\n-\n-# Stage hooks.\n-\n-brig.stage1: stage1-start\n-\t-mv brig/*$(objext) stage1/brig\n-brig.stage2: stage2-start\n-\t-mv brig/*$(objext) stage2/brig\n-brig.stage3: stage3-start\n-\t-mv brig/*$(objext) stage3/brig\n-brig.stage4: stage4-start\n-\t-mv brig/*$(objext) stage4/brig\n-brig.stageprofile: stageprofile-start\n-\t-mv brig/*$(objext) stageprofile/brig\n-brig.stagefeedback: stagefeedback-start\n-\t-mv brig/*$(objext) stagefeedback/brig\n-\n-CFLAGS-brig/brig-lang.o += -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n-\t-DDEFAULT_TARGET_MACHINE=\\\"$(target_noncanonical)\\\"\n-\n-BRIGINCLUDES = -I $(srcdir)/brig -I $(srcdir)/brig/brigfrontend\n-\n-brig/brig-machine.o: brig/brigfrontend/brig-machine.c\n-\t$(COMPILE) $(BRIGINCLUDES) $<\n-\t$(POSTCOMPILE)\n-\n-brig/%.o: brig/brigfrontend/%.cc\n-\t$(COMPILE) $(BRIGINCLUDES) $<\n-\t$(POSTCOMPILE)"}, {"sha": "c891cf191faefe07b944f7e8e3f94c8618023416", "filename": "gcc/brig/brig-builtins.h", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrig-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrig-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrig-builtins.h?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,99 +0,0 @@\n-/* brig-builtins.h -- brig builtin definitions\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-enum built_in_attribute\n-{\n-#define DEF_ATTR_NULL_TREE(ENUM) ENUM,\n-#define DEF_ATTR_INT(ENUM, VALUE) ENUM,\n-#define DEF_ATTR_STRING(ENUM, VALUE) ENUM,\n-#define DEF_ATTR_IDENT(ENUM, STRING) ENUM,\n-#define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN) ENUM,\n-#include \"builtin-attrs.def\"\n-#undef DEF_ATTR_NULL_TREE\n-#undef DEF_ATTR_INT\n-#undef DEF_ATTR_STRING\n-#undef DEF_ATTR_IDENT\n-#undef DEF_ATTR_TREE_LIST\n-  ATTR_LAST\n-};\n-\n-/* Builtin types.  */\n-\n-enum brig_builtin_type\n-{\n-#define DEF_PRIMITIVE_TYPE(NAME, VALUE) NAME,\n-#define DEF_FUNCTION_TYPE_0(NAME, RETURN) NAME,\n-#define DEF_FUNCTION_TYPE_1(NAME, RETURN, ARG1) NAME,\n-#define DEF_FUNCTION_TYPE_2(NAME, RETURN, ARG1, ARG2) NAME,\n-#define DEF_FUNCTION_TYPE_3(NAME, RETURN, ARG1, ARG2, ARG3) NAME,\n-#define DEF_FUNCTION_TYPE_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n-#define DEF_FUNCTION_TYPE_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) NAME,\n-#define DEF_FUNCTION_TYPE_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t    ARG6) NAME,\n-#define DEF_FUNCTION_TYPE_7(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t    ARG6, ARG7) NAME,\n-#define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t    ARG6, ARG7, ARG8) NAME,\n-#define DEF_FUNCTION_TYPE_9(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t    ARG6, ARG7, ARG8, ARG9) NAME,\n-#define DEF_FUNCTION_TYPE_10(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10) NAME,\n-#define DEF_FUNCTION_TYPE_11(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) NAME,\n-#define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n-#define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n-#define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n-#define DEF_FUNCTION_TYPE_VAR_3(NAME, RETURN, ARG1, ARG2, ARG3) NAME,\n-#define DEF_FUNCTION_TYPE_VAR_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n-#define DEF_FUNCTION_TYPE_VAR_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG6) \\\n-\t\t\t\tNAME,\n-#define DEF_FUNCTION_TYPE_VAR_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t\t ARG6) NAME,\n-#define DEF_FUNCTION_TYPE_VAR_7(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t\tARG6, ARG7) NAME,\n-#define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n-#include \"builtin-types.def\"\n-#undef DEF_PRIMITIVE_TYPE\n-#undef DEF_FUNCTION_TYPE_0\n-#undef DEF_FUNCTION_TYPE_1\n-#undef DEF_FUNCTION_TYPE_2\n-#undef DEF_FUNCTION_TYPE_3\n-#undef DEF_FUNCTION_TYPE_4\n-#undef DEF_FUNCTION_TYPE_5\n-#undef DEF_FUNCTION_TYPE_6\n-#undef DEF_FUNCTION_TYPE_7\n-#undef DEF_FUNCTION_TYPE_8\n-#undef DEF_FUNCTION_TYPE_9\n-#undef DEF_FUNCTION_TYPE_10\n-#undef DEF_FUNCTION_TYPE_11\n-#undef DEF_FUNCTION_TYPE_VAR_0\n-#undef DEF_FUNCTION_TYPE_VAR_1\n-#undef DEF_FUNCTION_TYPE_VAR_2\n-#undef DEF_FUNCTION_TYPE_VAR_3\n-#undef DEF_FUNCTION_TYPE_VAR_4\n-#undef DEF_FUNCTION_TYPE_VAR_5\n-#undef DEF_FUNCTION_TYPE_VAR_6\n-#undef DEF_FUNCTION_TYPE_VAR_7\n-#undef DEF_POINTER_TYPE\n-  BT_LAST\n-};\n-\n-typedef enum brig_builtin_type builtin_type;"}, {"sha": "9defcea0933f89e74f20933a7a9f6a4a4ce7b145", "filename": "gcc/brig/brig-c.h", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrig-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrig-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrig-c.h?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,66 +0,0 @@\n-/* brig-c.h -- Header file for brig input's gcc C interface.\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef BRIG_BRIG_C_H\n-#define BRIG_BRIG_C_H\n-\n-#define BRIG_EXTERN_C\n-\n-#include \"machmode.h\"\n-\n-/* Functions defined in the Brig frontend proper called by the GCC\n-   interface.  */\n-\n-extern int brig_enable_dump (const char *);\n-extern int brig_enable_optimize (const char *);\n-\n-extern void brig_add_search_path (const char *);\n-\n-extern void brig_create_brigbrig (int int_type_size, int pointer_size,\n-\t\t\t\t  const char *pkgpath, const char *prefix,\n-\t\t\t\t  const char *relative_import_path);\n-\n-extern void brig_parse_input_files (const char **, unsigned int,\n-\t\t\t\t    bool only_check_syntax,\n-\t\t\t\t    bool require_return_statement);\n-extern void brig_write_globals (void);\n-\n-extern tree brig_type_for_size (unsigned int bits, int unsignedp);\n-extern tree brig_type_for_mode (machine_mode, int unsignedp);\n-\n-/* Functions defined in the GCC interface called by the Brig frontend\n-   proper.  */\n-\n-extern void brig_preserve_from_gc (tree);\n-\n-extern const char *brig_localize_identifier (const char *);\n-\n-extern unsigned int brig_field_alignment (tree);\n-\n-extern void brig_trampoline_info (unsigned int *size, unsigned int *alignment);\n-\n-extern void brig_imported_unsafe (void);\n-\n-extern void brig_write_export_data (const char *, unsigned int);\n-\n-extern const char *brig_read_export_data (int, off_t, char **, size_t *, int *);\n-\n-#endif /* !defined (BRIG_BRIG_C_H) */"}, {"sha": "af903fe3ab76c5b0d01aac2e7df0317341b67c69", "filename": "gcc/brig/brig-lang.c", "status": "removed", "additions": 0, "deletions": 958, "changes": 958, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrig-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrig-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrig-lang.c?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,958 +0,0 @@\n-/* brig-lang.c -- brig (HSAIL) input gcc interface.\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"ansidecl.h\"\n-#include \"coretypes.h\"\n-#include \"opts.h\"\n-#include \"tree.h\"\n-#include \"tree-iterator.h\"\n-#include \"print-tree.h\"\n-#include \"stringpool.h\"\n-#include \"basic-block.h\"\n-#include \"gimple-expr.h\"\n-#include \"gimplify.h\"\n-#include \"dumpfile.h\"\n-#include \"stor-layout.h\"\n-#include \"toplev.h\"\n-#include \"debug.h\"\n-#include \"options.h\"\n-#include \"flags.h\"\n-#include \"convert.h\"\n-#include \"diagnostic.h\"\n-#include \"langhooks.h\"\n-#include \"langhooks-def.h\"\n-#include \"target.h\"\n-#include \"vec.h\"\n-#include \"brigfrontend/brig-to-generic.h\"\n-#include \"machmode.h\"\n-#include \"fold-const.h\"\n-#include \"common/common-target.h\"\n-#include <mpfr.h>\n-#include \"brig-c.h\"\n-#include \"brig-builtins.h\"\n-\n-static tree handle_leaf_attribute (tree *, tree, tree, int, bool *);\n-static tree handle_const_attribute (tree *, tree, tree, int, bool *);\n-static tree handle_pure_attribute (tree *, tree, tree, int, bool *);\n-static tree handle_nothrow_attribute (tree *, tree, tree, int, bool *);\n-static tree handle_returns_twice_attribute (tree *, tree, tree, int, bool *);\n-\n-/* This file is based on Go frontend's go-lang.c and gogo-tree.cc.  */\n-\n-/* If -v set.  */\n-\n-int gccbrig_verbose = 0;\n-\n-/* Language-dependent contents of a type.  */\n-\n-struct GTY (()) lang_type\n-{\n-  char dummy;\n-};\n-\n-/* Language-dependent contents of a decl.  */\n-\n-struct GTY ((variable_size)) lang_decl\n-{\n-  char dummy;\n-};\n-\n-/* Language-dependent contents of an identifier.  This must include a\n-   tree_identifier.  */\n-\n-struct GTY (()) lang_identifier\n-{\n-  struct tree_identifier common;\n-};\n-\n-/* The resulting tree type.  */\n-\n-union GTY ((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-\t    chain_next (\"CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), \"\n-\t\t\t\"TS_COMMON) ? ((union lang_tree_node *) TREE_CHAIN \"\n-\t\t\t\"(&%h.generic)) : NULL\"))) lang_tree_node\n-{\n-  union tree_node GTY ((tag (\"0\"), desc (\"tree_node_structure (&%h)\"))) generic;\n-  struct lang_identifier GTY ((tag (\"1\"))) identifier;\n-};\n-\n-/* We don't use language_function.  */\n-\n-struct GTY (()) language_function\n-{\n-  int dummy;\n-};\n-\n-\n-/* The option mask.  */\n-\n-static unsigned int\n-brig_langhook_option_lang_mask (void)\n-{\n-  return CL_BRIG;\n-}\n-\n-/* Initialize the options structure.  */\n-\n-static void\n-brig_langhook_init_options_struct (struct gcc_options *opts)\n-{\n-  /* Signed overflow is precisely defined.  */\n-  opts->x_flag_wrapv = 1;\n-\n-  /* If we set this to one, the whole program optimizations internalize\n-     all global variables, making them invisible to the dyn loader (and\n-     thus the HSA runtime implementation).  */\n-  opts->x_flag_whole_program = 1;\n-\n-  /* The builtin math functions should not set errno.  */\n-  opts->x_flag_errno_math = 0;\n-  opts->frontend_set_flag_errno_math = false;\n-\n-  opts->x_flag_exceptions = 0;\n-  opts->x_flag_non_call_exceptions = 0;\n-\n-  opts->x_flag_finite_math_only = 0;\n-  opts->x_flag_signed_zeros = 1;\n-\n-  opts->x_optimize = 3;\n-\n-  flag_no_builtin = 1;\n-}\n-\n-/* Handle Brig specific options.  Return 0 if we didn't do anything.  */\n-\n-static bool\n-brig_langhook_handle_option\n-  (size_t scode, const char *arg ATTRIBUTE_UNUSED,\n-  HOST_WIDE_INT value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED,\n-  location_t loc ATTRIBUTE_UNUSED,\n-  const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n-{\n-  enum opt_code code = (enum opt_code) scode;\n-  switch (code)\n-    {\n-    case OPT_v:\n-      gccbrig_verbose = 1;\n-      break;\n-    default:\n-      break;\n-    }\n-  return 1;\n-}\n-\n-/* Run after parsing options.  */\n-\n-static bool\n-brig_langhook_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n-{\n-  if (flag_excess_precision == EXCESS_PRECISION_DEFAULT)\n-    flag_excess_precision = EXCESS_PRECISION_STANDARD;\n-\n-  /* gccbrig casts pointers around like crazy, TBAA might produce broken\n-     code if not disabling it by default.  Some PRM conformance tests such\n-     as prm/core/memory/ordinary/ld/ld_u16 fail currently with strict\n-     aliasing (to fix).  It can be enabled from the command line for cases\n-     that are known not to break the C style aliasing requirements.  */\n-  if (!global_options_set.x_flag_strict_aliasing)\n-    flag_strict_aliasing = 0;\n-  else\n-    flag_strict_aliasing = global_options.x_flag_strict_aliasing;\n-\n-  /* Returning false means that the backend should be used.  */\n-  return false;\n-}\n-\n-static size_t\n-get_file_size (FILE *file)\n-{\n-  size_t size;\n-  fseek (file, 0, SEEK_END);\n-  size = (size_t) ftell (file);\n-  fseek (file, 0, SEEK_SET);\n-  return size;\n-}\n-\n-static void\n-brig_langhook_parse_file (void)\n-{\n-  brig_to_generic brig_to_gen;\n-\n-  std::vector <char*> brig_blobs;\n-\n-  for (unsigned int i = 0; i < num_in_fnames; ++i)\n-    {\n-\n-      FILE *f;\n-      f = fopen (in_fnames[i], \"r\");\n-      size_t fsize = get_file_size (f);\n-      char *brig_blob = new char[fsize];\n-      if (fread (brig_blob, 1, fsize, f) != fsize)\n-\t{\n-\t  error (\"could not read the BRIG file\");\n-\t  exit (1);\n-\t}\n-      fclose (f);\n-\n-      brig_to_gen.analyze (brig_blob);\n-      brig_blobs.push_back (brig_blob);\n-    }\n-\n-  for (size_t i = 0; i < brig_blobs.size(); ++i)\n-    {\n-      char *brig_blob = brig_blobs.at(i);\n-      brig_to_gen.parse (brig_blob);\n-    }\n-\n-  brig_to_gen.write_globals ();\n-\n-  for (size_t i = 0; i < brig_blobs.size (); ++i)\n-    delete brig_blobs[i];\n-}\n-\n-static tree\n-brig_langhook_type_for_size (unsigned int bits,\n-\t\t\t     int unsignedp)\n-{\n-  /* Copied from go-lang.c  */\n-  tree type;\n-  if (unsignedp)\n-    {\n-      if (bits == INT_TYPE_SIZE)\n-        type = unsigned_type_node;\n-      else if (bits == CHAR_TYPE_SIZE)\n-        type = unsigned_char_type_node;\n-      else if (bits == SHORT_TYPE_SIZE)\n-        type = short_unsigned_type_node;\n-      else if (bits == LONG_TYPE_SIZE)\n-        type = long_unsigned_type_node;\n-      else if (bits == LONG_LONG_TYPE_SIZE)\n-        type = long_long_unsigned_type_node;\n-      else\n-        type = make_unsigned_type(bits);\n-    }\n-  else\n-    {\n-      if (bits == INT_TYPE_SIZE)\n-        type = integer_type_node;\n-      else if (bits == CHAR_TYPE_SIZE)\n-        type = signed_char_type_node;\n-      else if (bits == SHORT_TYPE_SIZE)\n-        type = short_integer_type_node;\n-      else if (bits == LONG_TYPE_SIZE)\n-        type = long_integer_type_node;\n-      else if (bits == LONG_LONG_TYPE_SIZE)\n-        type = long_long_integer_type_node;\n-      else\n-        type = make_signed_type(bits);\n-    }\n-  return type;\n-}\n-\n-static tree\n-brig_langhook_type_for_mode (machine_mode mode, int unsignedp)\n-{\n-  if (mode == TYPE_MODE (void_type_node))\n-    return void_type_node;\n-\n-  if (VECTOR_MODE_P (mode))\n-    {\n-      tree inner;\n-\n-      inner = brig_langhook_type_for_mode (GET_MODE_INNER (mode), unsignedp);\n-      if (inner != NULL_TREE)\n-\treturn build_vector_type_for_mode (inner, mode);\n-      gcc_unreachable ();\n-      return NULL_TREE;\n-    }\n-\n-  scalar_int_mode imode;\n-  scalar_float_mode fmode;\n-  if (is_float_mode (mode, &fmode))\n-    {\n-      switch (GET_MODE_BITSIZE (fmode))\n-\t{\n-\tcase 32:\n-\t  return float_type_node;\n-\tcase 64:\n-\t  return double_type_node;\n-\tdefault:\n-\t  /* We have to check for long double in order to support\n-\t     i386 excess precision.  */\n-\t  if (fmode == TYPE_MODE (long_double_type_node))\n-\t    return long_double_type_node;\n-\n-\t  gcc_unreachable ();\n-\t  return NULL_TREE;\n-\t}\n-    }\n-  else if (is_int_mode (mode, &imode))\n-    return brig_langhook_type_for_size (GET_MODE_BITSIZE (imode), unsignedp);\n-  else\n-    {\n-      /* E.g., build_common_builtin_nodes () asks for modes/builtins\n-\t       we do not generate or need.  Just ignore them silently for now.\n-      */\n-      return NULL_TREE;\n-    }\n-  return NULL_TREE;\n-}\n-\n-static tree\n-brig_langhook_builtin_function (tree decl)\n-{\n-  return decl;\n-}\n-\n-static GTY(()) tree registered_builtin_types;\n-\n-static void\n-brig_langhook_register_builtin_type (tree type, const char *name)\n-{\n-  tree decl;\n-\n-  if (!TYPE_NAME (type))\n-    {\n-      decl = build_decl (UNKNOWN_LOCATION, TYPE_DECL,\n-\t\t\t get_identifier (name), type);\n-      DECL_ARTIFICIAL (decl) = 1;\n-      TYPE_NAME (type) = decl;\n-    }\n-\n-  registered_builtin_types = tree_cons (0, type, registered_builtin_types);\n-}\n-\n-\n-/* Return true if we are in the global binding level.  */\n-\n-static bool\n-brig_langhook_global_bindings_p (void)\n-{\n-  return current_function_decl == NULL_TREE;\n-}\n-\n-/* Push a declaration into the current binding level.  From Go: We can't\n-   usefully implement this since we don't want to convert from tree\n-   back to one of our internal data structures.  I think the only way\n-   this is used is to record a decl which is to be returned by\n-   getdecls, and we could implement it for that purpose if\n-   necessary.  */\n-\n-static tree\n-brig_langhook_pushdecl (tree decl ATTRIBUTE_UNUSED)\n-{\n-  gcc_unreachable ();\n-}\n-\n-/* This hook is used to get the current list of declarations as trees.\n-   From Go: We don't support that; instead we use the write_globals hook.\n-   This can't simply crash because it is called by -gstabs.  */\n-\n-static tree\n-brig_langhook_getdecls (void)\n-{\n-  return NULL;\n-}\n-\n-static int\n-brig_langhook_gimplify_expr (tree *expr_p, gimple_seq *pre_p ATTRIBUTE_UNUSED,\n-\t\t\t     gimple_seq *post_p ATTRIBUTE_UNUSED)\n-{\n-\n-  /* Strip off the static chain info that appears to function\n-     calls for some strange reason even though we don't add\n-     nested functions.  Maybe something wrong with the function\n-     declaration contexts? */\n-  if (TREE_CODE (*expr_p) == CALL_EXPR\n-      && CALL_EXPR_STATIC_CHAIN (*expr_p) != NULL_TREE)\n-    CALL_EXPR_STATIC_CHAIN (*expr_p) = NULL_TREE;\n-  return GS_UNHANDLED;\n-}\n-\n-static tree\n-brig_langhook_eh_personality (void)\n-{\n-  gcc_unreachable ();\n-}\n-\n-/* Functions called directly by the generic backend.\n-   Adapted from go-lang.c.  */\n-\n-tree\n-convert (tree type, tree expr)\n-{\n-  if (type == error_mark_node || expr == error_mark_node\n-      || TREE_TYPE (expr) == error_mark_node)\n-    return error_mark_node;\n-\n-  if (type == TREE_TYPE (expr))\n-    return expr;\n-\n-  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n-    return fold_convert (type, expr);\n-\n-  switch (TREE_CODE (type))\n-    {\n-    case VOID_TYPE:\n-    case BOOLEAN_TYPE:\n-      return fold_convert (type, expr);\n-    case INTEGER_TYPE:\n-      return fold (convert_to_integer (type, expr));\n-    case REAL_TYPE:\n-      return fold (convert_to_real (type, expr));\n-    case VECTOR_TYPE:\n-      return fold (convert_to_vector (type, expr));\n-    case POINTER_TYPE:\n-      return build1 (VIEW_CONVERT_EXPR, type, convert (size_type_node, expr));\n-    default:\n-      break;\n-    }\n-\n-  gcc_unreachable ();\n-}\n-\n-static GTY (()) tree brig_gc_root;\n-\n-/* Preserve trees that we create from the garbage collector.  */\n-\n-void\n-brig_preserve_from_gc (tree t)\n-{\n-  brig_gc_root = tree_cons (NULL_TREE, t, brig_gc_root);\n-}\n-\n-/* Convert an identifier for use in an error message.  */\n-\n-const char *\n-brig_localize_identifier (const char *ident)\n-{\n-  return identifier_to_locale (ident);\n-}\n-\n-/* Define supported attributes and their handlers. Code copied from\n-   lto-lang.c */\n-\n-/* Table of machine-independent attributes supported in GIMPLE.  */\n-const struct attribute_spec brig_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req,\n-       affects_type_identity, handler, exclude } */\n-  { \"leaf\",\t\t      0, 0, true,  false, false, false,\n-\t\t\t      handle_leaf_attribute, NULL },\n-  { \"const\",                  0, 0, true,  false, false, false,\n-\t\t\t      handle_const_attribute, NULL },\n-  { \"pure\",                   0, 0, true,  false, false, false,\n-\t\t\t      handle_pure_attribute, NULL },\n-  { \"nothrow\",                0, 0, true,  false, false, false,\n-\t\t\t      handle_nothrow_attribute, NULL },\n-  { \"returns_twice\",          0, 0, true,  false, false, false,\n-\t\t\t      handle_returns_twice_attribute, NULL },\n-  { NULL,                     0, 0, false, false, false, false, NULL, NULL }\n-};\n-\n-/* Attribute handlers.  */\n-/* Handle a \"leaf\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_leaf_attribute (tree *node, tree name,\n-\t\t       tree ARG_UNUSED (args),\n-\t\t       int ARG_UNUSED (flags), bool *no_add_attrs)\n-{\n-  if (TREE_CODE (*node) != FUNCTION_DECL)\n-    {\n-      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n-      *no_add_attrs = true;\n-    }\n-  if (!TREE_PUBLIC (*node))\n-    {\n-      warning (OPT_Wattributes,\n-\t       \"%qE attribute has no effect on unit local functions\", name);\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"const\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_const_attribute (tree *node, tree ARG_UNUSED (name),\n-\t\t\ttree ARG_UNUSED (args), int ARG_UNUSED (flags),\n-\t\t\tbool * ARG_UNUSED (no_add_attrs))\n-{\n-  tree type = TREE_TYPE (*node);\n-\n-  /* See FIXME comment on noreturn in c_common_attribute_table.  */\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    TREE_READONLY (*node) = 1;\n-  else if (TREE_CODE (type) == POINTER_TYPE\n-\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-    TREE_TYPE (*node)\n-      = build_pointer_type\n-\t(build_type_variant (TREE_TYPE (type), 1,\n-\t\t\t     TREE_THIS_VOLATILE (TREE_TYPE (type))));\n-  else\n-    gcc_unreachable ();\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"pure\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_pure_attribute (tree *node, tree ARG_UNUSED (name),\n-\t\t       tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n-\t\t       bool * ARG_UNUSED (no_add_attrs))\n-{\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    DECL_PURE_P (*node) = 1;\n-  else\n-    gcc_unreachable ();\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"nothrow\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_nothrow_attribute (tree *node, tree ARG_UNUSED (name),\n-\t\t\t  tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n-\t\t\t  bool * ARG_UNUSED (no_add_attrs))\n-{\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    TREE_NOTHROW (*node) = 1;\n-  else\n-    gcc_unreachable ();\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"returns_twice\" attribute.  */\n-\n-static tree\n-handle_returns_twice_attribute (tree *node, tree ARG_UNUSED (name),\n-\t\t\t\ttree ARG_UNUSED (args),\n-\t\t\t\tint ARG_UNUSED (flags),\n-\t\t\t\tbool * ARG_UNUSED (no_add_attrs))\n-{\n-  gcc_assert (TREE_CODE (*node) == FUNCTION_DECL);\n-\n-  DECL_IS_RETURNS_TWICE (*node) = 1;\n-\n-  return NULL_TREE;\n-}\n-\n-\n-/* Built-in initialization code cribbed from lto-lang.c which cribbed it\n-   from c-common.c.  */\n-\n-\n-static GTY(()) tree built_in_attributes[(int) ATTR_LAST];\n-\n-\n-static GTY(()) tree builtin_types[(int) BT_LAST + 1];\n-\n-static GTY(()) tree string_type_node;\n-static GTY(()) tree const_string_type_node;\n-static GTY(()) tree wint_type_node;\n-static GTY(()) tree intmax_type_node;\n-static GTY(()) tree uintmax_type_node;\n-static GTY(()) tree signed_size_type_node;\n-\n-/* Flags needed to process builtins.def.  */\n-int flag_isoc94;\n-int flag_isoc99;\n-int flag_isoc11;\n-int flag_isoc2x;\n-\n-static void\n-def_fn_type (builtin_type def, builtin_type ret, bool var, int n, ...)\n-{\n-  tree t;\n-  tree *args = XALLOCAVEC (tree, n);\n-  va_list list;\n-  int i;\n-  bool err = false;\n-\n-  va_start (list, n);\n-  for (i = 0; i < n; ++i)\n-    {\n-      builtin_type a = (builtin_type) va_arg (list, int);\n-      t = builtin_types[a];\n-      if (t == error_mark_node)\n-\terr = true;\n-      args[i] = t;\n-    }\n-  va_end (list);\n-\n-  t = builtin_types[ret];\n-  if (err)\n-    t = error_mark_node;\n-  if (t == error_mark_node)\n-    ;\n-  else if (var)\n-    t = build_varargs_function_type_array (t, n, args);\n-  else\n-    t = build_function_type_array (t, n, args);\n-\n-  builtin_types[def] = t;\n-}\n-\n-/* Used to help initialize the builtin-types.def table.  When a type of\n-   the correct size doesn't exist, use error_mark_node instead of NULL.\n-   The later results in segfaults even when a decl using the type doesn't\n-   get invoked.  */\n-\n-static tree\n-builtin_type_for_size (int size, bool unsignedp)\n-{\n-  tree type = brig_langhook_type_for_size (size, unsignedp);\n-  return type ? type : error_mark_node;\n-}\n-\n-/* Support for DEF_BUILTIN.  */\n-\n-static void\n-def_builtin_1 (enum built_in_function fncode, const char *name,\n-\t       enum built_in_class fnclass ATTRIBUTE_UNUSED,\n-\t       tree fntype, tree libtype ATTRIBUTE_UNUSED,\n-\t       bool both_p ATTRIBUTE_UNUSED, bool fallback_p,\n-\t       bool nonansi_p ATTRIBUTE_UNUSED, tree fnattrs,\n-\t       bool implicit_p)\n-{\n-  tree decl;\n-  const char *libname;\n-\n-  if (fntype == error_mark_node)\n-    return;\n-\n-  libname = name + strlen (\"__builtin_\");\n-  decl = add_builtin_function (name, fntype, fncode, fnclass,\n-\t\t\t       (fallback_p ? libname : NULL),\n-\t\t\t       fnattrs);\n-\n-  set_builtin_decl (fncode, decl, implicit_p);\n-}\n-\n-\n-/* Initialize the attribute table for all the supported builtins.  */\n-\n-static void\n-brig_init_attributes (void)\n-{\n-  /* Fill in the built_in_attributes array.  */\n-#define DEF_ATTR_NULL_TREE(ENUM)\t\t\t\t\\\n-  built_in_attributes[(int) ENUM] = NULL_TREE;\n-#define DEF_ATTR_INT(ENUM, VALUE)\t\t\t\t\\\n-  built_in_attributes[(int) ENUM] = build_int_cst (NULL_TREE, VALUE);\n-#define DEF_ATTR_STRING(ENUM, VALUE)\t\t\t\t\\\n-  built_in_attributes[(int) ENUM] = build_string (strlen (VALUE), VALUE);\n-#define DEF_ATTR_IDENT(ENUM, STRING)\t\t\t\t\\\n-  built_in_attributes[(int) ENUM] = get_identifier (STRING);\n-#define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN)\t\\\n-  built_in_attributes[(int) ENUM]\t\t\t\\\n-    = tree_cons (built_in_attributes[(int) PURPOSE],\t\\\n-\t\t built_in_attributes[(int) VALUE],\t\\\n-\t\t built_in_attributes[(int) CHAIN]);\n-#include \"builtin-attrs.def\"\n-#undef DEF_ATTR_NULL_TREE\n-#undef DEF_ATTR_INT\n-#undef DEF_ATTR_STRING\n-#undef DEF_ATTR_IDENT\n-#undef DEF_ATTR_TREE_LIST\n-}\n-\n-/* Create builtin types and functions.  VA_LIST_REF_TYPE_NODE and\n-   VA_LIST_ARG_TYPE_NODE are used in builtin-types.def.  */\n-\n-static void\n-brig_define_builtins (tree va_list_ref_type_node ATTRIBUTE_UNUSED,\n-\t\t     tree va_list_arg_type_node ATTRIBUTE_UNUSED)\n-{\n-#define DEF_PRIMITIVE_TYPE(ENUM, VALUE) \\\n-  builtin_types[ENUM] = VALUE;\n-#define DEF_FUNCTION_TYPE_0(ENUM, RETURN) \\\n-  def_fn_type (ENUM, RETURN, 0, 0);\n-#define DEF_FUNCTION_TYPE_1(ENUM, RETURN, ARG1) \\\n-  def_fn_type (ENUM, RETURN, 0, 1, ARG1);\n-#define DEF_FUNCTION_TYPE_2(ENUM, RETURN, ARG1, ARG2) \\\n-  def_fn_type (ENUM, RETURN, 0, 2, ARG1, ARG2);\n-#define DEF_FUNCTION_TYPE_3(ENUM, RETURN, ARG1, ARG2, ARG3) \\\n-  def_fn_type (ENUM, RETURN, 0, 3, ARG1, ARG2, ARG3);\n-#define DEF_FUNCTION_TYPE_4(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4) \\\n-  def_fn_type (ENUM, RETURN, 0, 4, ARG1, ARG2, ARG3, ARG4);\n-#define DEF_FUNCTION_TYPE_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\t\\\n-  def_fn_type (ENUM, RETURN, 0, 5, ARG1, ARG2, ARG3, ARG4, ARG5);\n-#define DEF_FUNCTION_TYPE_6(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t    ARG6)\t\t\t\t\t\\\n-  def_fn_type (ENUM, RETURN, 0, 6, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);\n-#define DEF_FUNCTION_TYPE_7(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t    ARG6, ARG7)\t\t\t\t\t\\\n-  def_fn_type (ENUM, RETURN, 0, 7, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);\n-#define DEF_FUNCTION_TYPE_8(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t    ARG6, ARG7, ARG8)\t\t\t\t\\\n-  def_fn_type (ENUM, RETURN, 0, 8, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n-\t       ARG7, ARG8);\n-#define DEF_FUNCTION_TYPE_9(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t    ARG6, ARG7, ARG8, ARG9)\t\t\t\\\n-  def_fn_type (ENUM, RETURN, 0, 9, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n-\t       ARG7, ARG8, ARG9);\n-#define DEF_FUNCTION_TYPE_10(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10)\t\t \\\n-  def_fn_type (ENUM, RETURN, 0, 10, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t \\\n-\t       ARG7, ARG8, ARG9, ARG10);\n-#define DEF_FUNCTION_TYPE_11(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)\t \\\n-  def_fn_type (ENUM, RETURN, 0, 11, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t \\\n-\t       ARG7, ARG8, ARG9, ARG10, ARG11);\n-#define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN) \\\n-  def_fn_type (ENUM, RETURN, 1, 0);\n-#define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1) \\\n-  def_fn_type (ENUM, RETURN, 1, 1, ARG1);\n-#define DEF_FUNCTION_TYPE_VAR_2(ENUM, RETURN, ARG1, ARG2) \\\n-  def_fn_type (ENUM, RETURN, 1, 2, ARG1, ARG2);\n-#define DEF_FUNCTION_TYPE_VAR_3(ENUM, RETURN, ARG1, ARG2, ARG3) \\\n-  def_fn_type (ENUM, RETURN, 1, 3, ARG1, ARG2, ARG3);\n-#define DEF_FUNCTION_TYPE_VAR_4(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4) \\\n-  def_fn_type (ENUM, RETURN, 1, 4, ARG1, ARG2, ARG3, ARG4);\n-#define DEF_FUNCTION_TYPE_VAR_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) \\\n-  def_fn_type (ENUM, RETURN, 1, 5, ARG1, ARG2, ARG3, ARG4, ARG5);\n-#define DEF_FUNCTION_TYPE_VAR_6(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t\t ARG6)\t\\\n-  def_fn_type (ENUM, RETURN, 1, 6, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);\n-#define DEF_FUNCTION_TYPE_VAR_7(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n-\t\t\t\tARG6, ARG7)\t\t\t\t\\\n-  def_fn_type (ENUM, RETURN, 1, 7, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);\n-#define DEF_POINTER_TYPE(ENUM, TYPE) \\\n-  builtin_types[(int) ENUM] = build_pointer_type (builtin_types[(int) TYPE]);\n-\n-#include \"builtin-types.def\"\n-\n-#undef DEF_PRIMITIVE_TYPE\n-#undef DEF_FUNCTION_TYPE_0\n-#undef DEF_FUNCTION_TYPE_1\n-#undef DEF_FUNCTION_TYPE_2\n-#undef DEF_FUNCTION_TYPE_3\n-#undef DEF_FUNCTION_TYPE_4\n-#undef DEF_FUNCTION_TYPE_5\n-#undef DEF_FUNCTION_TYPE_6\n-#undef DEF_FUNCTION_TYPE_7\n-#undef DEF_FUNCTION_TYPE_8\n-#undef DEF_FUNCTION_TYPE_9\n-#undef DEF_FUNCTION_TYPE_10\n-#undef DEF_FUNCTION_TYPE_11\n-#undef DEF_FUNCTION_TYPE_VAR_0\n-#undef DEF_FUNCTION_TYPE_VAR_1\n-#undef DEF_FUNCTION_TYPE_VAR_2\n-#undef DEF_FUNCTION_TYPE_VAR_3\n-#undef DEF_FUNCTION_TYPE_VAR_4\n-#undef DEF_FUNCTION_TYPE_VAR_5\n-#undef DEF_FUNCTION_TYPE_VAR_6\n-#undef DEF_FUNCTION_TYPE_VAR_7\n-#undef DEF_POINTER_TYPE\n-  builtin_types[(int) BT_LAST] = NULL_TREE;\n-\n-  brig_init_attributes ();\n-\n-#define DEF_BUILTIN(ENUM, NAME, CLASS, TYPE, LIBTYPE, BOTH_P, FALLBACK_P,\\\n-\t\t    NONANSI_P, ATTRS, IMPLICIT, COND)\t\t\t\\\n-    if (NAME && COND)\t\t\t\t\t\t\t\\\n-      def_builtin_1 (ENUM, NAME, CLASS, builtin_types[(int) TYPE],\t\\\n-\t\t     builtin_types[(int) LIBTYPE], BOTH_P, FALLBACK_P,\t\\\n-\t\t     NONANSI_P, built_in_attributes[(int) ATTRS], IMPLICIT);\n-\n-#undef DEF_HSAIL_BUILTIN\n-#define DEF_HSAIL_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE, NAME, TYPE, ATTRS) \\\n-  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n-              false, true, true, ATTRS, false, true)\n-\n-/* HSAIL atomic builtins do not have separate identifying opcodes.  */\n-\n-#undef DEF_HSAIL_ATOMIC_BUILTIN\n-#define DEF_HSAIL_ATOMIC_BUILTIN(ENUM, ATOMIC_OPCODE, HSAIL_TYPE, NAME, \\\n-       TYPE, ATTRS) \\\n-  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n-              false, true, true, ATTRS, false, true)\n-\n-/* HSAIL saturating arithmetics builtins.  */\n-\n-#undef DEF_HSAIL_SAT_BUILTIN\n-#define DEF_HSAIL_SAT_BUILTIN(ENUM, BRIG_OPCODE, HSAIL_TYPE, NAME, \\\n-       TYPE, ATTRS) \\\n-  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n-              false, true, true, ATTRS, false, true)\n-\n-/* HSAIL builtins used internally by the frontend.  */\n-\n-#undef DEF_HSAIL_INTR_BUILTIN\n-#define DEF_HSAIL_INTR_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n-  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n-              false, true, true, ATTRS, false, true)\n-\n-/* HSAIL saturated conversions.  */\n-\n-#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n-#define DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN(ENUM, HSAIL_DEST_TYPE, HSAIL_SRC_TYPE, \\\n-  NAME, TYPE, ATTRS) \\\n-  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n-              false, true, true, ATTRS, false, true)\n-\n-#include \"builtins.def\"\n-}\n-\n-/* Build nodes that would have be created by the C front-end; necessary\n-   for including builtin-types.def and ultimately builtins.def.  Borrowed\n-   from lto-lang.c.  */\n-\n-static void\n-brig_build_c_type_nodes (void)\n-{\n-  gcc_assert (void_type_node);\n-\n-  void_list_node = build_tree_list (NULL_TREE, void_type_node);\n-  string_type_node = build_pointer_type (char_type_node);\n-  const_string_type_node\n-    = build_pointer_type (build_qualified_type (char_type_node,\n-\t\t\t\t\t\tTYPE_QUAL_CONST));\n-\n-  if (strcmp (SIZE_TYPE, \"unsigned int\") == 0)\n-    {\n-      intmax_type_node = integer_type_node;\n-      uintmax_type_node = unsigned_type_node;\n-      signed_size_type_node = integer_type_node;\n-    }\n-  else if (strcmp (SIZE_TYPE, \"long unsigned int\") == 0)\n-    {\n-      intmax_type_node = long_integer_type_node;\n-      uintmax_type_node = long_unsigned_type_node;\n-      signed_size_type_node = long_integer_type_node;\n-    }\n-  else if (strcmp (SIZE_TYPE, \"long long unsigned int\") == 0)\n-    {\n-      intmax_type_node = long_long_integer_type_node;\n-      uintmax_type_node = long_long_unsigned_type_node;\n-      signed_size_type_node = long_long_integer_type_node;\n-    }\n-  else\n-    {\n-      int i;\n-\n-      signed_size_type_node = NULL_TREE;\n-      for (i = 0; i < NUM_INT_N_ENTS; i++)\n-\tif (int_n_enabled_p[i])\n-\t  {\n-\t    char name[50], altname[50];\n-\t    sprintf (name, \"__int%d unsigned\", int_n_data[i].bitsize);\n-\t    sprintf (altname, \"__int%d__ unsigned\", int_n_data[i].bitsize);\n-\n-\t    if (strcmp (name, SIZE_TYPE) == 0\n-\t\t|| strcmp (altname, SIZE_TYPE) == 0)\n-\t      {\n-\t\tintmax_type_node = int_n_trees[i].signed_type;\n-\t\tuintmax_type_node = int_n_trees[i].unsigned_type;\n-\t\tsigned_size_type_node = int_n_trees[i].signed_type;\n-\t      }\n-\t  }\n-      if (signed_size_type_node == NULL_TREE)\n-\tgcc_unreachable ();\n-    }\n-\n-  wint_type_node = unsigned_type_node;\n-  pid_type_node = integer_type_node;\n-}\n-\n-\n-static bool\n-brig_langhook_init (void)\n-{\n-  build_common_tree_nodes (false);\n-\n-  /* Builtin initialization related code borrowed from lto-lang.c.  */\n-  void_list_node = build_tree_list (NULL_TREE, void_type_node);\n-\n-  brig_build_c_type_nodes ();\n-\n-  if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n-    {\n-      tree x = build_pointer_type (TREE_TYPE (va_list_type_node));\n-      brig_define_builtins (x, x);\n-    }\n-  else\n-    {\n-      brig_define_builtins (build_reference_type (va_list_type_node),\n-\t\t\t    va_list_type_node);\n-    }\n-\n-  targetm.init_builtins ();\n-  build_common_builtin_nodes ();\n-\n-  return true;\n-}\n-\n-#undef LANG_HOOKS_NAME\n-#undef LANG_HOOKS_INIT\n-#undef LANG_HOOKS_OPTION_LANG_MASK\n-#undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n-#undef LANG_HOOKS_HANDLE_OPTION\n-#undef LANG_HOOKS_POST_OPTIONS\n-#undef LANG_HOOKS_PARSE_FILE\n-#undef LANG_HOOKS_TYPE_FOR_MODE\n-#undef LANG_HOOKS_TYPE_FOR_SIZE\n-#undef LANG_HOOKS_REGISTER_BUILTIN_TYPE\n-#undef LANG_HOOKS_BUILTIN_FUNCTION\n-#undef LANG_HOOKS_GLOBAL_BINDINGS_P\n-#undef LANG_HOOKS_PUSHDECL\n-#undef LANG_HOOKS_GETDECLS\n-#undef LANG_HOOKS_WRITE_GLOBALS\n-#undef LANG_HOOKS_GIMPLIFY_EXPR\n-#undef LANG_HOOKS_EH_PERSONALITY\n-\n-#define LANG_HOOKS_NAME \"GNU Brig\"\n-#define LANG_HOOKS_INIT brig_langhook_init\n-#define LANG_HOOKS_OPTION_LANG_MASK brig_langhook_option_lang_mask\n-#define LANG_HOOKS_INIT_OPTIONS_STRUCT brig_langhook_init_options_struct\n-#define LANG_HOOKS_HANDLE_OPTION brig_langhook_handle_option\n-#define LANG_HOOKS_POST_OPTIONS brig_langhook_post_options\n-#define LANG_HOOKS_PARSE_FILE brig_langhook_parse_file\n-#define LANG_HOOKS_TYPE_FOR_MODE brig_langhook_type_for_mode\n-#define LANG_HOOKS_TYPE_FOR_SIZE brig_langhook_type_for_size\n-#define LANG_HOOKS_REGISTER_BUILTIN_TYPE brig_langhook_register_builtin_type\n-#define LANG_HOOKS_BUILTIN_FUNCTION brig_langhook_builtin_function\n-#define LANG_HOOKS_GLOBAL_BINDINGS_P brig_langhook_global_bindings_p\n-#define LANG_HOOKS_PUSHDECL brig_langhook_pushdecl\n-#define LANG_HOOKS_GETDECLS brig_langhook_getdecls\n-#define LANG_HOOKS_GIMPLIFY_EXPR brig_langhook_gimplify_expr\n-#define LANG_HOOKS_EH_PERSONALITY brig_langhook_eh_personality\n-\n-/* Attribute hooks.  */\n-#undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\n-#define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE brig_attribute_table\n-\n-struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n-\n-#include \"gt-brig-brig-lang.h\"\n-#include \"gtype-brig.h\""}, {"sha": "9d5a8e996395c2844ddf1245523882081b61c0ab", "filename": "gcc/brig/brigfrontend/brig-arg-block-handler.cc", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-arg-block-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-arg-block-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-arg-block-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,66 +0,0 @@\n-/* brig-arg-block-handler.cc -- brig arg block start/end directive handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-#include \"tree-iterator.h\"\n-#include \"system.h\"\n-#include \"errors.h\"\n-\n-#include \"tree-pretty-print.h\"\n-#include \"print-tree.h\"\n-\n-size_t\n-brig_directive_arg_block_handler::operator () (const BrigBase *base)\n-{\n-  if (base->kind == BRIG_KIND_DIRECTIVE_ARG_BLOCK_START)\n-    {\n-      /* Initiate a new code block for the call site.  */\n-      tree stmt_list = alloc_stmt_list ();\n-      tree bind_expr\n-\t= build3 (BIND_EXPR, void_type_node, NULL, stmt_list, NULL);\n-      tree block = make_node (BLOCK);\n-      BIND_EXPR_BLOCK (bind_expr) = block;\n-      static int block_id = 0;\n-      BLOCK_NUMBER (block) = block_id++;\n-      TREE_USED (block) = 1;\n-      tree m_parentblock = DECL_INITIAL (m_parent.m_cf->m_func_decl);\n-      BLOCK_SUPERCONTEXT (block) = m_parentblock;\n-\n-      chainon (BLOCK_SUBBLOCKS (m_parentblock), block);\n-\n-      m_parent.m_cf->m_current_bind_expr = bind_expr;\n-      m_parent.m_cf->m_generating_arg_block = true;\n-    }\n-  else if (base->kind == BRIG_KIND_DIRECTIVE_ARG_BLOCK_END)\n-    {\n-      /* Restore the used bind expression back to the function\n-\t scope.  */\n-      tree new_bind_expr = m_parent.m_cf->m_current_bind_expr;\n-      m_parent.m_cf->m_current_bind_expr\n-\t= DECL_SAVED_TREE (m_parent.m_cf->m_func_decl);\n-      m_parent.m_cf->append_statement (new_bind_expr);\n-      m_parent.m_cf->m_generating_arg_block = false;\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  return base->byteCount;\n-}"}, {"sha": "eeef252975819c080cc58b5416a04521c7e38250", "filename": "gcc/brig/brigfrontend/brig-atomic-inst-handler.cc", "status": "removed", "additions": 0, "deletions": 265, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-atomic-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-atomic-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-atomic-inst-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,265 +0,0 @@\n-/* brig-atomic-inst-handler.cc -- brig atomic instruction handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <sstream>\n-\n-#include \"brig-code-entry-handler.h\"\n-#include \"brig-util.h\"\n-#include \"fold-const.h\"\n-#include \"diagnostic.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"print-tree.h\"\n-#include \"convert.h\"\n-#include \"langhooks.h\"\n-#include \"gimple-expr.h\"\n-#include \"stringpool.h\"\n-#include \"brig-builtins.h\"\n-\n-brig_atomic_inst_handler::brig_atomic_inst_handler (brig_to_generic &parent)\n-  : brig_code_entry_handler (parent)\n-{\n-}\n-\n-size_t\n-brig_atomic_inst_handler::generate_tree (const BrigInstBase &inst,\n-\t\t\t\t\t BrigAtomicOperation8_t atomic_opcode)\n-{\n-  tree_stl_vec operands = build_operands (inst);\n-  const int first_input\n-    = gccbrig_hsa_opcode_op_output_p (inst.opcode, 0) ? 1 : 0;\n-\n-  tree instr_type = gccbrig_tree_type_for_hsa_type (inst.type);\n-\n-  /* Utilize the atomic data types (from C++11 support) for implementing\n-     atomic operations.  */\n-\n-  tree atomic_type = build_qualified_type (instr_type, TYPE_QUAL_ATOMIC);\n-\n-  gcc_assert (atomic_type != NULL_TREE);\n-\n-  tree signal_handle = operands[first_input];\n-  tree atomic_ptype = build_pointer_type (atomic_type);\n-  tree casted_to_ptr = convert_to_pointer (atomic_ptype, signal_handle);\n-\n-  tree src0 = NULL_TREE;\n-  if (atomic_opcode != BRIG_ATOMIC_LD)\n-    src0 = operands[first_input + 1];\n-\n-  tree instr_expr = NULL_TREE;\n-\n-  tree ptype = build_pointer_type (instr_type);\n-  tree ptr = convert_to_pointer (ptype, operands[first_input]);\n-\n-  if (atomic_opcode == BRIG_ATOMIC_ST)\n-    {\n-      tree mem_ref = build2 (MEM_REF, atomic_type, casted_to_ptr,\n-\t\t\t     build_int_cst (atomic_ptype, 0));\n-      instr_expr = build2 (MODIFY_EXPR, atomic_type, mem_ref, src0);\n-    }\n-  else if (atomic_opcode == BRIG_ATOMIC_LD\n-\t   || (atomic_opcode >= BRIG_ATOMIC_WAIT_EQ\n-\t       && atomic_opcode <= BRIG_ATOMIC_WAITTIMEOUT_GTE))\n-    {\n-      tree mem_ref = build2 (MEM_REF, atomic_type, casted_to_ptr,\n-\t\t\t     build_int_cst (atomic_ptype, 0));\n-      /* signal_wait* instructions can return spuriously before the\n-\t condition becomes true.  Therefore it's legal to return\n-\t right away.  TODO: builtin calls which can be\n-\t implemented with a power efficient sleep-wait.  */\n-      instr_expr = mem_ref;\n-    }\n-  else if (atomic_opcode == BRIG_ATOMIC_CAS)\n-    {\n-      /* Special case for CAS due to the two args.  */\n-      tree built_in = NULL_TREE;\n-      switch (gccbrig_hsa_type_bit_size (inst.type))\n-\t{\n-\tcase 32:\n-\t  built_in\n-\t    = builtin_decl_explicit (BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_4);\n-\t  break;\n-\tcase 64:\n-\t  built_in\n-\t    = builtin_decl_explicit (BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_8);\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      tree src1 = operands[first_input + 2];\n-\n-      tree src0_type\n-\t= TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (built_in))));\n-\n-      tree src1_type = TREE_VALUE\n-\t(TREE_CHAIN (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (built_in)))));\n-\n-      instr_expr = call_builtin (built_in, 3, instr_type, ptype, ptr,\n-\t\t\t\t src0_type, src0, src1_type, src1);\n-    }\n-  else\n-    {\n-      tree built_in = NULL_TREE;\n-      /* The rest of the builtins have the same number of parameters.\n-\t Generate a big if..else that finds the correct builtin\n-\t automagically from the def file.  */\n-#undef DEF_HSAIL_SAT_BUILTIN\n-#undef DEF_HSAIL_BUILTIN\n-#undef DEF_HSAIL_ATOMIC_BUILTIN\n-#undef DEF_HSAIL_INTR_BUILTIN\n-#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n-\n-#define DEF_HSAIL_ATOMIC_BUILTIN(ENUM, ATOMIC_OPCODE, HSAIL_TYPE,\t\\\n-\t\t\t\t NAME, TYPE, ATTRS)\t\t\t\\\n-      if (atomic_opcode == ATOMIC_OPCODE && inst.type == HSAIL_TYPE)\t\\\n-\tbuilt_in = builtin_decl_explicit (ENUM);\t\t\t\\\n-      else\n-#include \"brig-builtins.def\"\n-      switch (atomic_opcode)\n-\t{\n-\tcase BRIG_ATOMIC_ADD:\n-\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n-\t    {\n-\t    case 32:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_ADD_4);\n-\t      break;\n-\t    case 64:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_ADD_8);\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\tcase BRIG_ATOMIC_SUB:\n-\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n-\t    {\n-\t    case 32:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_SUB_4);\n-\t      break;\n-\t    case 64:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_SUB_8);\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\tcase BRIG_ATOMIC_AND:\n-\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n-\t    {\n-\t    case 32:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_AND_4);\n-\t      break;\n-\t    case 64:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_AND_8);\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\tcase BRIG_ATOMIC_XOR:\n-\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n-\t    {\n-\t    case 32:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_XOR_4);\n-\t      break;\n-\t    case 64:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_XOR_8);\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\tcase BRIG_ATOMIC_OR:\n-\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n-\t    {\n-\t    case 32:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_OR_4);\n-\t      break;\n-\t    case 64:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_OR_8);\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\tcase BRIG_ATOMIC_EXCH:\n-\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n-\t    {\n-\t    case 32:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_LOCK_TEST_AND_SET_4);\n-\t      break;\n-\t    case 64:\n-\t      built_in\n-\t\t= builtin_decl_explicit (BUILT_IN_SYNC_LOCK_TEST_AND_SET_8);\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t};\n-\n-      gcc_assert (built_in != NULL_TREE);\n-      tree arg0_type\n-\t= TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (built_in))));\n-\n-      instr_expr = call_builtin (built_in, 2, instr_type, ptr_type_node,\n-\t\t\t\t ptr, arg0_type, src0);\n-\n-      /* We need a temp variable for the result, because otherwise\n-\t the gimplifier drops a necessary (unsigned to signed) cast in\n-\t the output assignment and fails a check later.  */\n-      tree tmp_var = create_tmp_var (arg0_type, \"builtin_out\");\n-      tree tmp_assign\n-\t= build2 (MODIFY_EXPR, TREE_TYPE (tmp_var), tmp_var, instr_expr);\n-      m_parent.m_cf->append_statement (tmp_assign);\n-      instr_expr = tmp_var;\n-    }\n-\n-  if (first_input > 0)\n-    build_output_assignment (inst, operands[0], instr_expr);\n-  else\n-    m_parent.m_cf->append_statement (instr_expr);\n-\n-  return inst.base.byteCount;\n-}\n-\n-size_t\n-brig_atomic_inst_handler::operator () (const BrigBase *base)\n-{\n-  const BrigInstAtomic *inst = (const BrigInstAtomic *) base;\n-  BrigAtomicOperation8_t atomic_opcode;\n-  atomic_opcode = inst->atomicOperation;\n-\n-  return generate_tree (inst->base, atomic_opcode);\n-}"}, {"sha": "ebce19778deab6a6b9bab4790049e0ce465a31cb", "filename": "gcc/brig/brigfrontend/brig-basic-inst-handler.cc", "status": "removed", "additions": 0, "deletions": 735, "changes": 735, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,735 +0,0 @@\n-/* brig-basic-inst-handler.cc -- brig basic instruction handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <sstream>\n-\n-#include \"brig-code-entry-handler.h\"\n-#include \"brig-util.h\"\n-\n-#include \"errors.h\"\n-#include \"gimple-expr.h\"\n-#include \"convert.h\"\n-#include \"print-tree.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"langhooks.h\"\n-#include \"stor-layout.h\"\n-#include \"diagnostic-core.h\"\n-#include \"brig-builtins.h\"\n-#include \"fold-const.h\"\n-\n-brig_basic_inst_handler::brig_basic_inst_handler (brig_to_generic &parent)\n-  : brig_code_entry_handler (parent)\n-{\n-}\n-\n-class scalarized_sat_arithmetics : public tree_element_binary_visitor\n-{\n-public:\n-  scalarized_sat_arithmetics (const BrigInstBase &brig_inst)\n-    : m_brig_inst (brig_inst)\n-  {\n-    BrigType16_t element_type = brig_inst.type & BRIG_TYPE_BASE_MASK;\n-\n-#undef DEF_HSAIL_SAT_BUILTIN\n-#undef DEF_HSAIL_BUILTIN\n-#undef DEF_HSAIL_ATOMIC_BUILTIN\n-#undef DEF_HSAIL_INTR_BUILTIN\n-#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n-\n-#define DEF_HSAIL_SAT_BUILTIN(ENUM, BRIG_OPCODE, HSAIL_TYPE,\t\t\\\n-\t\t\t      NAME, TYPE, ATTRS)\t\t\t\\\n-    if (brig_inst.opcode == BRIG_OPCODE && element_type == HSAIL_TYPE)\t\\\n-      m_builtin = builtin_decl_explicit (ENUM);\t\t\t\t\\\n-    else\n-#include \"brig-builtins.def\"\n-      gcc_unreachable ();\n-  }\n-\n-  virtual tree\n-  visit_element (brig_code_entry_handler &, tree operand0, tree operand1)\n-  {\n-    /* Implement saturating arithmetics with scalar built-ins for now.\n-       TODO: emit GENERIC nodes for the simplest cases or at least\n-       emit vector built-ins.  */\n-    return call_builtin (m_builtin, 2, TREE_TYPE (operand0),\n-\t\t\t TREE_TYPE (operand0), operand0,\n-\t\t\t TREE_TYPE (operand1), operand1);\n-  }\n-  const BrigInstBase &m_brig_inst;\n-  tree m_builtin;\n-};\n-\n-/* Implements a vector shuffle.  ARITH_TYPE is the type of the vector,\n-   OPERANDS[0] is the first vector, OPERAND[1] the second vector and\n-   OPERANDS[2] the shuffle mask in HSAIL format.  The output is a VEC_PERM_EXPR\n-   that implements the shuffle as a GENERIC expression.  */\n-\n-tree\n-brig_basic_inst_handler::build_shuffle (tree arith_type,\n-\t\t\t\t\ttree_stl_vec &operands)\n-{\n-  tree element_type\n-    = get_unsigned_int_type (TREE_TYPE (TREE_TYPE (operands[0])));\n-\n-  /* Offsets to add to the mask values to convert from the\n-     HSAIL mask to VEC_PERM_EXPR masks.  VEC_PERM_EXPR mask\n-     assumes an index spanning from 0 to 2 times the vec\n-     width while HSAIL refers separately to two different\n-     input vectors, thus is not a \"full shuffle\" where all\n-     output elements can originate from any input element.  */\n-  vec<constructor_elt, va_gc> *mask_offset_vals = NULL;\n-\n-  unsigned int element_count = gccbrig_type_vector_subparts (arith_type);\n-\n-  vec<constructor_elt, va_gc> *input_mask_vals = NULL;\n-  size_t input_mask_element_size = exact_log2 (element_count);\n-\n-  /* Unpack the tightly packed mask elements to BIT_FIELD_REFs\n-     from which to construct the mask vector as understood by\n-     VEC_PERM_EXPR.  */\n-  tree mask_operand\n-    = m_parent.m_cf->add_temp_var (\"shuffle_mask\", operands[2]);\n-\n-  tree mask_element_type\n-    = build_nonstandard_integer_type (input_mask_element_size, true);\n-\n-  for (size_t i = 0; i < element_count; ++i)\n-    {\n-      tree mask_element\n-\t= build3 (BIT_FIELD_REF, mask_element_type, mask_operand,\n-\t\t  bitsize_int (input_mask_element_size),\n-\t\t  bitsize_int (i * input_mask_element_size));\n-\n-      mask_element = convert (element_type, mask_element);\n-\n-      tree offset;\n-      if (i < element_count / 2)\n-\toffset = build_int_cst (element_type, 0);\n-      else\n-\toffset = build_int_cst (element_type, element_count);\n-\n-      CONSTRUCTOR_APPEND_ELT (mask_offset_vals, NULL_TREE, offset);\n-      CONSTRUCTOR_APPEND_ELT (input_mask_vals, NULL_TREE, mask_element);\n-    }\n-  tree mask_vec_type = build_vector_type (element_type, element_count);\n-\n-  tree mask_vec = build_constructor (mask_vec_type, input_mask_vals);\n-  tree offset_vec = build_constructor (mask_vec_type, mask_offset_vals);\n-\n-  tree mask = build2 (PLUS_EXPR, mask_vec_type, mask_vec, offset_vec);\n-\n-  tree perm = build3 (VEC_PERM_EXPR, TREE_TYPE (operands[0]), operands[0],\n-\t\t      operands[1], mask);\n-  return perm;\n-}\n-\n-/* Unpacks (extracts) a scalar element with an index in OPERANDS[1]\n-   from the vector expression in OPERANDS[0].  */\n-\n-tree\n-brig_basic_inst_handler::build_unpack (tree_stl_vec &operands)\n-{\n-  /* Implement the unpack with a shuffle that stores the unpacked\n-     element to the lowest bit positions in the dest.  After that\n-     a bitwise AND is used to clear the uppermost bits.  */\n-  tree src_element_type = TREE_TYPE (TREE_TYPE (operands[0]));\n-\n-  /* Perform the operations with a raw (unsigned int type) type.  */\n-  tree element_type = get_unsigned_int_type (src_element_type);\n-\n-  vec<constructor_elt, va_gc> *input_mask_vals = NULL;\n-  vec<constructor_elt, va_gc> *and_mask_vals = NULL;\n-\n-  size_t element_count\n-    = gccbrig_type_vector_subparts (TREE_TYPE (operands[0]));\n-  tree vec_type = build_vector_type (element_type, element_count);\n-\n-  for (size_t i = 0; i < element_count; ++i)\n-    {\n-      tree mask_element;\n-      if (i == 0)\n-\tmask_element = convert (element_type, operands[1]);\n-      else\n-\tmask_element = build_int_cst (element_type, 0);\n-\n-      CONSTRUCTOR_APPEND_ELT (input_mask_vals, NULL_TREE, mask_element);\n-\n-      tree and_mask_element;\n-      if (i == 0)\n-\tand_mask_element = build_int_cst (element_type, -1);\n-      else\n-\tand_mask_element = build_int_cst (element_type, 0);\n-      CONSTRUCTOR_APPEND_ELT (and_mask_vals, NULL_TREE, and_mask_element);\n-    }\n-\n-  tree mask_vec = build_constructor (vec_type, input_mask_vals);\n-\n-  tree and_mask_vec = build_constructor (vec_type, and_mask_vals);\n-\n-  tree perm = build3 (VEC_PERM_EXPR, vec_type,\n-\t\t      build_resize_convert_view (vec_type, operands[0]),\n-\t\t      build_resize_convert_view (vec_type, operands[0]),\n-\t\t      mask_vec);\n-\n-  tree cleared = build2 (BIT_AND_EXPR, vec_type, perm, and_mask_vec);\n-\n-  size_t s = int_size_in_bytes (TREE_TYPE (cleared)) * BITS_PER_UNIT;\n-  tree raw_type = build_nonstandard_integer_type (s, true);\n-\n-  tree as_int = build_resize_convert_view (raw_type, cleared);\n-\n-  if (int_size_in_bytes (src_element_type) < 4)\n-    {\n-      if (INTEGRAL_TYPE_P (src_element_type))\n-\treturn extend_int (as_int, uint32_type_node, src_element_type);\n-    }\n-  return as_int;\n-}\n-\n-/* Packs (inserts) a scalar element in OPERANDS[1]\n-   to the vector in OPERANDS[0] at element position defined by\n-   OPERANDS[2].  */\n-\n-tree\n-brig_basic_inst_handler::build_pack (tree_stl_vec &operands)\n-{\n-  /* Implement using a bit level insertion.\n-     TODO: Reuse this for implementing 'bitinsert'\n-     without a builtin call.  */\n-\n-  size_t ecount = gccbrig_type_vector_subparts (TREE_TYPE (operands[0]));\n-  size_t vecsize = int_size_in_bytes (TREE_TYPE (operands[0])) * BITS_PER_UNIT;\n-  tree wide_type = build_nonstandard_integer_type (vecsize, 1);\n-\n-  tree src_vect = build_resize_convert_view (wide_type, operands[0]);\n-  src_vect = m_parent.m_cf->add_temp_var (\"src_vect\", src_vect);\n-\n-  tree scalar = operands[1];\n-  scalar = m_parent.m_cf->add_temp_var (\"scalar\",\n-\t\t\t\t\tconvert_to_integer (wide_type, scalar));\n-\n-  tree pos = operands[2];\n-\n-  /* The upper bits of the position can contain garbage.\n-     Zero them for well-defined semantics.  */\n-  tree t = build2 (BIT_AND_EXPR, TREE_TYPE (pos), operands[2],\n-\t\t   build_int_cstu (TREE_TYPE (pos), ecount - 1));\n-  pos = m_parent.m_cf->add_temp_var (\"pos\", convert (wide_type, t));\n-\n-  tree element_type = TREE_TYPE (TREE_TYPE (operands[0]));\n-  size_t element_width = int_size_in_bytes (element_type) * BITS_PER_UNIT;\n-  tree ewidth = build_int_cstu (wide_type, element_width);\n-\n-  tree bitoffset = build2 (MULT_EXPR, wide_type, ewidth, pos);\n-  bitoffset = m_parent.m_cf->add_temp_var (\"offset\", bitoffset);\n-\n-  uint64_t mask_int\n-    = element_width == 64 ? (uint64_t) -1 : ((uint64_t) 1 << element_width) - 1;\n-\n-  tree mask = build_int_cstu (wide_type, mask_int);\n-\n-  mask = m_parent.m_cf->add_temp_var (\"mask\",\n-\t\t\t\t      convert_to_integer (wide_type, mask));\n-\n-  tree clearing_mask\n-    = build1 (BIT_NOT_EXPR, wide_type,\n-\t      build2 (LSHIFT_EXPR, wide_type, mask, bitoffset));\n-\n-  tree zeroed_element\n-    = build2 (BIT_AND_EXPR, wide_type, src_vect, clearing_mask);\n-\n-  /* TODO: Is the AND necessary: does HSA define what\n-     happens if the upper bits in the inserted element are not\n-     zero? */\n-  tree element_in_position\n-    = build2 (LSHIFT_EXPR, wide_type,\n-\t      build2 (BIT_AND_EXPR, wide_type, scalar, mask), bitoffset);\n-\n-  tree inserted\n-    = build2 (BIT_IOR_EXPR, wide_type, zeroed_element, element_in_position);\n-  return inserted;\n-}\n-\n-/* Implement the unpack{lo,hi}.  BRIG_OPCODE should tell which one and\n-   ARITH_TYPE describe the type of the vector arithmetics.\n-   OPERANDS[0] and OPERANDS[1] are the input vectors.  */\n-\n-tree\n-brig_basic_inst_handler::build_unpack_lo_or_hi (BrigOpcode16_t brig_opcode,\n-\t\t\t\t\t\ttree arith_type,\n-\t\t\t\t\t\ttree_stl_vec &operands)\n-{\n-  tree element_type = get_unsigned_int_type (TREE_TYPE (arith_type));\n-  tree mask_vec_type\n-    = build_vector_type (element_type,\n-\t\t\t gccbrig_type_vector_subparts (arith_type));\n-\n-  size_t element_count = gccbrig_type_vector_subparts (arith_type);\n-  vec<constructor_elt, va_gc> *input_mask_vals = NULL;\n-\n-  size_t offset = (brig_opcode == BRIG_OPCODE_UNPACKLO) ? 0 : element_count / 2;\n-\n-  for (size_t i = 0; i < element_count / 2; ++i)\n-    {\n-      CONSTRUCTOR_APPEND_ELT (input_mask_vals, NULL_TREE,\n-\t\t\t      build_int_cst (element_type, offset + i));\n-      CONSTRUCTOR_APPEND_ELT (input_mask_vals, NULL_TREE,\n-\t\t\t      build_int_cst (element_type,\n-\t\t\t\t\t     offset + i + element_count));\n-    }\n-\n-  tree mask_vec = build_constructor (mask_vec_type, input_mask_vals);\n-\n-  tree perm = build3 (VEC_PERM_EXPR, TREE_TYPE (operands[0]), operands[0],\n-\t\t      operands[1], mask_vec);\n-  return perm;\n-}\n-\n-/* Builds a basic instruction expression from a BRIG instruction.  BRIG_OPCODE\n-   is the opcode, BRIG_TYPE the brig type of the instruction, ARITH_TYPE the\n-   desired tree type for the instruction, and OPERANDS the instruction's\n-   input operands already converted to tree nodes.  */\n-\n-tree\n-brig_basic_inst_handler::build_inst_expr (BrigOpcode16_t brig_opcode,\n-\t\t\t\t\t  BrigType16_t brig_type,\n-\t\t\t\t\t  tree arith_type,\n-\t\t\t\t\t  tree_stl_vec &operands)\n-{\n-  tree_code opcode\n-    = brig_function::get_tree_code_for_hsa_opcode (brig_opcode, brig_type);\n-\n-  BrigType16_t inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n-\n-  tree instr_inner_type\n-    = VECTOR_TYPE_P (arith_type) ? TREE_TYPE (arith_type) : arith_type;\n-\n-  if (opcode == RSHIFT_EXPR || opcode == LSHIFT_EXPR)\n-    {\n-      /* HSA defines modulo/clipping behavior for shift amounts larger\n-\t than the bit width, while tree.def leaves it undefined.\n-\t We need to mask the upper bits to ensure the defined behavior.  */\n-      tree scalar_mask\n-\t= build_int_cst (instr_inner_type,\n-\t\t\t gccbrig_hsa_type_bit_size (inner_type) - 1);\n-\n-      tree mask = VECTOR_TYPE_P (arith_type)\n-\t\t    ? build_vector_from_val (arith_type, scalar_mask)\n-\t\t    : scalar_mask;\n-\n-      /* The shift amount is a scalar, broadcast it to produce\n-\t a vector shift.  */\n-      if (VECTOR_TYPE_P (arith_type))\n-\toperands[1] = build_vector_from_val (arith_type, operands[1]);\n-      operands[1] = build2 (BIT_AND_EXPR, arith_type, operands[1], mask);\n-    }\n-\n-  size_t input_count = operands.size ();\n-  size_t output_count = gccbrig_hsa_opcode_op_output_p (brig_opcode, 0) ?\n-    1 : 0;\n-\n-  if (opcode == TREE_LIST)\n-    {\n-      /* There was no direct GENERIC opcode for the instruction;\n-\t try to emulate it with a chain of GENERIC nodes.  */\n-      if (brig_opcode == BRIG_OPCODE_MAD || brig_opcode == BRIG_OPCODE_MAD24)\n-\t{\n-\t  /* There doesn't seem to be a \"standard\" MAD built-in in gcc so let's\n-\t     use a chain of multiply + add for now (double rounding method).\n-\t     It should be easier for optimizers than a custom built-in call\n-\t     WIDEN_MULT_EXPR is close, but requires a double size result\n-\t     type.  */\n-\t  tree mult_res\n-\t    = build2 (MULT_EXPR, arith_type, operands[0], operands[1]);\n-\t  return build2 (PLUS_EXPR, arith_type, mult_res, operands[2]);\n-\t}\n-      else if (brig_opcode == BRIG_OPCODE_MAD24HI)\n-\t{\n-\t  tree mult_res\n-\t    = build2 (MULT_HIGHPART_EXPR, arith_type, operands[0], operands[1]);\n-\t  return build2 (PLUS_EXPR, arith_type, mult_res, operands[2]);\n-\t}\n-      else if (brig_opcode == BRIG_OPCODE_SHUFFLE)\n-\t{\n-\t  return build_shuffle (arith_type, operands);\n-\t}\n-      else if (brig_opcode == BRIG_OPCODE_UNPACKLO\n-\t       || brig_opcode == BRIG_OPCODE_UNPACKHI)\n-\t{\n-\t  return build_unpack_lo_or_hi (brig_opcode, arith_type, operands);\n-\t}\n-      else if (brig_opcode == BRIG_OPCODE_UNPACK)\n-\t{\n-\t  return build_unpack (operands);\n-\t}\n-      else if (brig_opcode == BRIG_OPCODE_PACK)\n-\t{\n-\t  return build_pack (operands);\n-\t}\n-      else if (brig_opcode == BRIG_OPCODE_NRSQRT)\n-\t{\n-\t  /* Implement as 1.0/sqrt (x) and assume gcc instruction selects to\n-\t     native ISA other than a division, if available.\n-\t     TODO: this will happen only with unsafe math optimizations\n-\t     on which cannot be used in general to remain HSAIL compliant.\n-\t     Perhaps a builtin call would be better option here.  */\n-\t  return build2 (RDIV_EXPR, arith_type, build_one_cst (arith_type),\n-\t\t\t m_parent.m_cf->expand_or_call_builtin\n-\t\t\t (BRIG_OPCODE_SQRT, brig_type, arith_type, operands));\n-\t}\n-      else if (brig_opcode == BRIG_OPCODE_NRCP)\n-\t{\n-\t  /* Implement as 1.0/x and assume gcc instruction selects to\n-\t     native ISA other than a division, if available.  */\n-\t  return build2 (RDIV_EXPR, arith_type, build_one_cst (arith_type),\n-\t\t\t operands[0]);\n-\t}\n-      else if (brig_opcode == BRIG_OPCODE_LANEID\n-\t       || brig_opcode == BRIG_OPCODE_MAXWAVEID\n-\t       || brig_opcode == BRIG_OPCODE_WAVEID)\n-\t{\n-\t  /* Assuming WAVESIZE 1 (for now), therefore LANEID, WAVEID and\n-\t     MAXWAVEID always return 0.  */\n-\t  return build_zero_cst (arith_type);\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (opcode == CALL_EXPR)\n-    return m_parent.m_cf->expand_or_call_builtin (brig_opcode, brig_type,\n-\t\t\t\t\t\t  arith_type, operands);\n-  else if (output_count == 1)\n-    {\n-      if (input_count == 1)\n-\t{\n-\t  if (opcode == MODIFY_EXPR)\n-\t    return operands[0];\n-\t  else\n-\t    return build1 (opcode, arith_type, operands[0]);\n-\t}\n-      else if (input_count == 2)\n-\treturn build2 (opcode, arith_type, operands[0], operands[1]);\n-      else if (input_count == 3)\n-\treturn build3 (opcode, arith_type, operands[0], operands[1],\n-\t\t       operands[2]);\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handles the basic instructions, including packed instructions. Deals\n-   with the different packing modes by unpacking/packing the wanted\n-   elements.  Delegates most of the instruction cases to build_inst_expr(). */\n-\n-size_t\n-brig_basic_inst_handler::operator () (const BrigBase *base)\n-{\n-  const BrigInstBase *brig_inst = (const BrigInstBase *) base;\n-  if (brig_inst->opcode == BRIG_OPCODE_NOP)\n-    return base->byteCount;\n-\n-  tree_stl_vec operands = build_operands (*brig_inst);\n-\n-  size_t output_count\n-    = gccbrig_hsa_opcode_op_output_p (brig_inst->opcode, 0) ? 1 : 0;\n-  size_t input_count\n-    = operands.size () == 0 ? 0 : (operands.size () - output_count);\n-\n-  gcc_assert (output_count == 0 || output_count == 1);\n-\n-  tree_stl_vec::iterator first_input_i = operands.begin ();\n-  if (output_count > 0 && operands.size () > 0)\n-    ++first_input_i;\n-\n-  tree_stl_vec in_operands;\n-  in_operands.assign (first_input_i, operands.end ());\n-\n-  BrigType16_t brig_inst_type = brig_inst->type;\n-\n-  if (brig_inst->opcode == BRIG_OPCODE_FIRSTBIT\n-      || brig_inst->opcode == BRIG_OPCODE_LASTBIT\n-      || brig_inst->opcode == BRIG_OPCODE_SAD)\n-    /* These instructions are reported to be always 32b in HSAIL, but we want\n-       to treat them according to their input argument's type to select the\n-       correct instruction/builtin.  */\n-    brig_inst_type\n-      = gccbrig_tree_type_to_hsa_type (TREE_TYPE (in_operands[0]));\n-\n-  tree instr_type = gccbrig_tree_type_for_hsa_type (brig_inst_type);\n-\n-  if (!instr_type)\n-    {\n-      gcc_unreachable ();\n-      return base->byteCount;\n-    }\n-\n-  bool is_vec_instr = hsa_type_packed_p (brig_inst_type);\n-\n-  size_t element_size_bits;\n-  size_t element_count;\n-\n-  if (is_vec_instr)\n-    {\n-      BrigType16_t brig_element_type = brig_inst_type & BRIG_TYPE_BASE_MASK;\n-      element_size_bits = gccbrig_hsa_type_bit_size (brig_element_type);\n-      element_count = gccbrig_hsa_type_bit_size (brig_inst_type)\n-\t/ gccbrig_hsa_type_bit_size (brig_element_type);\n-    }\n-  else\n-    {\n-      element_size_bits = gccbrig_hsa_type_bit_size (brig_inst_type);\n-      element_count = 1;\n-    }\n-\n-  /* The actual arithmetics type that should be performed with the\n-     operation.  This is not always the same as the original BRIG\n-     opcode's type due to implicit conversions of storage-only f16.  */\n-  tree arith_type = gccbrig_is_bit_operation (brig_inst->opcode)\n-\t\t      ? gccbrig_tree_type_for_hsa_type (brig_inst_type)\n-\t\t      : get_tree_expr_type_for_hsa_type (brig_inst_type);\n-\n-  tree instr_expr = NULL_TREE;\n-\n-  BrigPack8_t p = BRIG_PACK_NONE;\n-  if (brig_inst->base.kind == BRIG_KIND_INST_MOD)\n-    p = ((const BrigInstMod *) brig_inst)->pack;\n-  else if (brig_inst->base.kind == BRIG_KIND_INST_CMP)\n-    p = ((const BrigInstCmp *) brig_inst)->pack;\n-\n-  if (p == BRIG_PACK_PS || p == BRIG_PACK_PSSAT)\n-    in_operands[1] = build_lower_element_broadcast (in_operands[1]);\n-  else if (p == BRIG_PACK_SP || p == BRIG_PACK_SPSAT)\n-    in_operands[0] = build_lower_element_broadcast (in_operands[0]);\n-\n-  tree_code opcode\n-    = brig_function::get_tree_code_for_hsa_opcode (brig_inst->opcode,\n-\t\t\t\t\t\t   brig_inst_type);\n-\n-  if (p >= BRIG_PACK_PPSAT && p <= BRIG_PACK_PSAT)\n-    {\n-      scalarized_sat_arithmetics sat_arith (*brig_inst);\n-      gcc_assert (input_count == 2);\n-      instr_expr = sat_arith (*this, in_operands[0], in_operands[1]);\n-    }\n-  else if (opcode == RETURN_EXPR)\n-    {\n-      if (m_parent.m_cf->m_is_kernel)\n-\t{\n-\t  tree goto_stmt\n-\t    = build1 (GOTO_EXPR, void_type_node, m_parent.m_cf->m_exit_label);\n-\t  m_parent.m_cf->append_statement (goto_stmt);\n-\t  return base->byteCount;\n-\t}\n-      else\n-\t{\n-\t  m_parent.m_cf->append_return_stmt ();\n-\t  return base->byteCount;\n-\t}\n-    }\n-  else if (opcode == MULT_HIGHPART_EXPR &&\n-\t   is_vec_instr && element_size_bits < 64)\n-    {\n-      /* MULT_HIGHPART_EXPR works only on target dependent vector sizes and\n-\t even the scalars do not seem to work at least for char elements.\n-\n-\t Let's fall back to scalarization and promotion of the vector elements\n-\t to larger types with the MULHI computed as a regular MUL.\n-\t MULHI for 2x64b seems to work with the Intel CPUs I've tested so\n-\t that is passed on for vector processing so there is no need for\n-\t 128b scalar arithmetics.\n-\n-\t This is not modular as these type of things do not belong to the\n-\t frontend, there should be a legalization phase before the backend\n-\t that figures out the best way to compute the MULHI for any\n-\t integer vector datatype.\n-\n-\t TODO: promote to larger vector types instead.  For example\n-\t MULT_HIGHPART_EXPR with s8x8 doesn't work, but s16x8 seems to at least\n-\t with my x86-64.\n-      */\n-      tree_stl_vec operand0_elements;\n-      if (input_count > 0)\n-\tm_parent.m_cf->unpack (in_operands[0], operand0_elements);\n-\n-      tree_stl_vec operand1_elements;\n-      if (input_count > 1)\n-\tm_parent.m_cf->unpack (in_operands[1], operand1_elements);\n-\n-      tree_stl_vec result_elements;\n-\n-      tree scalar_type = TREE_TYPE (arith_type);\n-      BrigType16_t element_type = brig_inst_type & BRIG_TYPE_BASE_MASK;\n-      tree promoted_type = short_integer_type_node;\n-      switch (element_type)\n-\t{\n-\tcase BRIG_TYPE_S8:\n-\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_S16);\n-\t  break;\n-\tcase BRIG_TYPE_U8:\n-\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U16);\n-\t  break;\n-\tcase BRIG_TYPE_S16:\n-\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_S32);\n-\t  break;\n-\tcase BRIG_TYPE_U16:\n-\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U32);\n-\t  break;\n-\tcase BRIG_TYPE_S32:\n-\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_S64);\n-\t  break;\n-\tcase BRIG_TYPE_U32:\n-\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U64);\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      size_t promoted_type_size = int_size_in_bytes (promoted_type) * 8;\n-      size_t element_count = gccbrig_type_vector_subparts (arith_type);\n-      for (size_t i = 0; i < element_count; ++i)\n-\t{\n-\t  tree operand0 = convert (promoted_type, operand0_elements.at (i));\n-\t  tree operand1 = convert (promoted_type, operand1_elements.at (i));\n-\n-\t  tree scalar_expr\n-\t    = build2 (MULT_EXPR, promoted_type, operand0, operand1);\n-\n-\t  scalar_expr\n-\t    = build2 (RSHIFT_EXPR, promoted_type, scalar_expr,\n-\t\t      build_int_cstu (promoted_type, promoted_type_size / 2));\n-\n-\t  result_elements.push_back (convert (scalar_type, scalar_expr));\n-\t}\n-      instr_expr = m_parent.m_cf->pack (result_elements);\n-    }\n-  else\n-    {\n-      /* 'class' is always of b1 type, let's consider it by its\n-\t float type when building the instruction to find the\n-\t correct builtin.  */\n-      if (brig_inst->opcode == BRIG_OPCODE_CLASS)\n-\tbrig_inst_type = ((const BrigInstSourceType *) base)->sourceType;\n-      instr_expr = build_inst_expr (brig_inst->opcode, brig_inst_type,\n-\t\t\t\t     arith_type, in_operands);\n-    }\n-\n-  if (instr_expr == NULL_TREE)\n-    {\n-      gcc_unreachable ();\n-      return base->byteCount;\n-    }\n-\n-  if (p == BRIG_PACK_SS || p == BRIG_PACK_S || p == BRIG_PACK_SSSAT\n-      || p == BRIG_PACK_SSAT)\n-    {\n-      /* In case of _s_ or _ss_, select only the lowest element\n-\t from the new input to the output.  We could extract\n-\t the element and use a scalar operation, but try\n-\t to keep data in vector registers as much as possible\n-\t to avoid copies between scalar and vector datapaths.  */\n-      tree old_value;\n-      tree half_storage_type = gccbrig_tree_type_for_hsa_type (brig_inst_type);\n-      bool is_fp16_operation\n-\t= (brig_inst_type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16\n-\t&& !gccbrig_is_bit_operation (brig_inst->opcode);\n-\n-      if (is_fp16_operation)\n-\told_value = build_h2f_conversion\n-\t  (build_resize_convert_view (half_storage_type, operands[0]));\n-      else\n-\told_value\n-\t  = build_resize_convert_view (TREE_TYPE (instr_expr), operands[0]);\n-\n-      size_t esize = is_fp16_operation ? 32 : element_size_bits;\n-\n-      /* Construct a permutation mask where other elements than the lowest one\n-\t is picked from the old_value.  */\n-      tree mask_inner_type = build_nonstandard_integer_type (esize, 1);\n-      vec<constructor_elt, va_gc> *constructor_vals = NULL;\n-      for (size_t i = 0; i < element_count; ++i)\n-\t{\n-\t  tree cst;\n-\n-\t  if (i == 0)\n-\t    cst = build_int_cstu (mask_inner_type, element_count);\n-\t  else\n-\t    cst = build_int_cstu (mask_inner_type, i);\n-\t  CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, cst);\n-\t}\n-      tree mask_vec_type = build_vector_type (mask_inner_type, element_count);\n-      tree mask = build_vector_from_ctor (mask_vec_type, constructor_vals);\n-\n-      tree new_value = create_tmp_var (TREE_TYPE (instr_expr), \"new_output\");\n-      tree assign\n-\t= build2 (MODIFY_EXPR, TREE_TYPE (instr_expr), new_value, instr_expr);\n-      m_parent.m_cf->append_statement (assign);\n-\n-      instr_expr\n-\t= build3 (VEC_PERM_EXPR, arith_type, old_value, new_value, mask);\n-\n-      tree lower_output = create_tmp_var (TREE_TYPE (instr_expr), \"s_output\");\n-      tree assign_lower = build2 (MODIFY_EXPR, TREE_TYPE (instr_expr),\n-\t\t\t\t  lower_output, instr_expr);\n-      m_parent.m_cf->append_statement (assign_lower);\n-      instr_expr = lower_output;\n-    }\n-\n-  if (output_count == 1)\n-    build_output_assignment (*brig_inst, operands[0], instr_expr);\n-  else\n-    m_parent.m_cf->append_statement (instr_expr);\n-  return base->byteCount;\n-}\n-\n-/* Create an expression that broadcasts the lowest element of the\n-   vector in VEC_OPERAND to all elements of the returned vector.  */\n-\n-tree\n-brig_basic_inst_handler::build_lower_element_broadcast (tree vec_operand)\n-{\n-  /* Build the broadcast using shuffle because there's no\n-     direct broadcast in GENERIC and this way there's no need for\n-     a separate extract of the lowest element.  */\n-  tree element_type = TREE_TYPE (TREE_TYPE (vec_operand));\n-  size_t esize = 8 * int_size_in_bytes (element_type);\n-\n-  size_t element_count\n-    = gccbrig_type_vector_subparts (TREE_TYPE (vec_operand));\n-  tree mask_inner_type = build_nonstandard_integer_type (esize, 1);\n-  vec<constructor_elt, va_gc> *constructor_vals = NULL;\n-\n-  /* Construct the mask.  */\n-  for (size_t i = 0; i < element_count; ++i)\n-    {\n-      tree cst = build_int_cstu (mask_inner_type, element_count);\n-      CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, cst);\n-    }\n-  tree mask_vec_type = build_vector_type (mask_inner_type, element_count);\n-  tree mask = build_vector_from_ctor (mask_vec_type, constructor_vals);\n-\n-  return build3 (VEC_PERM_EXPR, TREE_TYPE (vec_operand), vec_operand,\n-\t\t vec_operand, mask);\n-}\n-"}, {"sha": "390571253735cc93ad3903c15cbef0a1cb10a2fa", "filename": "gcc/brig/brigfrontend/brig-branch-inst-handler.cc", "status": "removed", "additions": 0, "deletions": 238, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,238 +0,0 @@\n-/* brig-branch-inst-handler.cc -- brig branch instruction handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-\n-#include \"errors.h\"\n-#include \"brig-util.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"print-tree.h\"\n-#include \"vec.h\"\n-#include \"fold-const.h\"\n-\n-size_t\n-brig_branch_inst_handler::operator () (const BrigBase *base)\n-{\n-  const BrigInstBase *brig_inst\n-    = (const BrigInstBase *) &((const BrigInstBasic *) base)->base;\n-\n-  if (brig_inst->opcode == BRIG_OPCODE_CALL)\n-    {\n-      const BrigData *operand_entries\n-\t= m_parent.get_brig_data_entry (brig_inst->operands);\n-      tree func_ref = NULL_TREE;\n-      vec<tree, va_gc> *out_args;\n-      vec_alloc (out_args, 1);\n-      vec<tree, va_gc> *in_args;\n-      /* Ten elem initially, more reserved if needed. */\n-      vec_alloc (in_args, 10);\n-\n-      size_t operand_count = operand_entries->byteCount / 4;\n-      gcc_assert (operand_count < 4);\n-\n-      for (size_t i = 0; i < operand_count; ++i)\n-\t{\n-\t  uint32_t operand_offset\n-\t    = ((const uint32_t *) &operand_entries->bytes)[i];\n-\t  const BrigBase *operand_data\n-\t    = m_parent.get_brig_operand_entry (operand_offset);\n-\t  if (i == 1)\n-\t    {\n-\t      gcc_assert (operand_data->kind == BRIG_KIND_OPERAND_CODE_REF);\n-\t      func_ref = build_tree_operand (*brig_inst, *operand_data);\n-\t      continue;\n-\t    }\n-\t  gcc_assert (operand_data->kind == BRIG_KIND_OPERAND_CODE_LIST);\n-\t  const BrigOperandCodeList *codelist\n-\t    = (const BrigOperandCodeList *) operand_data;\n-\t  const BrigData *data\n-\t    = m_parent.get_brig_data_entry (codelist->elements);\n-\n-\t  size_t bytes = data->byteCount;\n-\t  const BrigOperandOffset32_t *operand_ptr\n-\t    = (const BrigOperandOffset32_t *) data->bytes;\n-\n-\t  bool out_args_p = i == 0;\n-\n-\t  while (bytes > 0)\n-\t    {\n-\t      BrigOperandOffset32_t offset = *operand_ptr;\n-\t      const BrigBase *code_element\n-\t\t= m_parent.get_brig_code_entry (offset);\n-\t      gcc_assert (code_element->kind == BRIG_KIND_DIRECTIVE_VARIABLE);\n-\t      const BrigDirectiveVariable *brig_var\n-\t\t= (const BrigDirectiveVariable *) code_element;\n-\t      tree var = m_parent.m_cf->arg_variable (brig_var);\n-\n-\t      if (brig_var->type & BRIG_TYPE_ARRAY)\n-\t\t{\n-\t\t  /* Array return values are passed as the first argument.  */\n-\t\t  out_args_p = false;\n-\t\t  /* Pass pointer to the element zero and use its element zero\n-\t\t     as the base address.  */\n-\t\t  tree etype = TREE_TYPE (TREE_TYPE (var));\n-\t\t  tree ptype = build_pointer_type (etype);\n-\t\t  tree element_zero\n-\t\t    = build4 (ARRAY_REF, etype, var, integer_zero_node,\n-\t\t\t      NULL_TREE, NULL_TREE);\n-\t\t  var = build1 (ADDR_EXPR, ptype, element_zero);\n-\t\t}\n-\n-\t      gcc_assert (var != NULL_TREE);\n-\t      vec_safe_push (out_args_p ? out_args : in_args, var);\n-\t      ++operand_ptr;\n-\t      bytes -= 4;\n-\t    }\n-\t}\n-\n-      gcc_assert (func_ref != NULL_TREE);\n-      gcc_assert (out_args->length () == 0 || out_args->length () == 1);\n-\n-      tree ret_val_type = void_type_node;\n-      tree ret_val = NULL_TREE;\n-      if (out_args->length () == 1)\n-\t{\n-\t  ret_val = (*out_args)[0];\n-\t  ret_val_type = TREE_TYPE (ret_val);\n-\t}\n-\n-      /* Pass the hidden kernel arguments along to the called functions as\n-\t they might call builtins that need them or access group/private\n-\t memory.  */\n-\n-      tree group_local_offset\n-\t= m_parent.m_cf->add_temp_var (\"group_local_offset\",\n-\t\t\t\t       build_int_cst\n-\t\t\t\t       (uint32_type_node,\n-\t\t\t\t\tm_parent.m_cf->\n-\t\t\t\t\tm_local_group_variables.size()));\n-\n-      /* TODO: ensure the callee's frame is aligned!  */\n-\n-      vec_safe_reserve (in_args, 4);\n-      vec_safe_push (in_args, m_parent.m_cf->m_context_arg);\n-      vec_safe_push (in_args, m_parent.m_cf->m_group_base_arg);\n-      vec_safe_push (in_args, group_local_offset);\n-      vec_safe_push (in_args, m_parent.m_cf->m_private_base_arg);\n-\n-      tree call = build_call_vec (ret_val_type, build_fold_addr_expr (func_ref),\n-\t\t\t\t  in_args);\n-      TREE_NOTHROW (func_ref) = 1;\n-      TREE_NOTHROW (call) = 1;\n-\n-      if (ret_val != NULL_TREE)\n-\t{\n-\t  TREE_ADDRESSABLE (ret_val) = 1;\n-\t  tree result_assign\n-\t    = build2 (MODIFY_EXPR, TREE_TYPE (ret_val), ret_val, call);\n-\t  m_parent.m_cf->append_statement (result_assign);\n-\t}\n-      else\n-\t{\n-\t  m_parent.m_cf->append_statement (call);\n-\t}\n-\n-      m_parent.m_cf->m_called_functions.push_back (func_ref);\n-      if (DECL_EXTERNAL (func_ref))\n-\tm_parent.add_decl_call (call);\n-      m_parent.m_cf->start_new_bb ();\n-\n-      return base->byteCount;\n-    }\n-\n-  tree instr_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n-  tree_stl_vec operands = build_operands (*brig_inst);\n-\n-  if (brig_inst->opcode == BRIG_OPCODE_BR)\n-    {\n-      tree goto_stmt = build1 (GOTO_EXPR, instr_type, operands[0]);\n-      m_parent.m_cf->append_statement (goto_stmt);\n-    }\n-  else if (brig_inst->opcode == BRIG_OPCODE_SBR)\n-    {\n-      tree select = operands[0];\n-      tree cases = operands[1];\n-\n-      tree switch_expr = build2 (SWITCH_EXPR, TREE_TYPE (select), select,\n-\t\t\t\t NULL_TREE);\n-\n-      tree default_case\n-\t= build_case_label (NULL_TREE, NULL_TREE,\n-\t\t\t    create_artificial_label (UNKNOWN_LOCATION));\n-      append_to_statement_list (default_case, &SWITCH_BODY (switch_expr));\n-\n-      tree default_jump\n-\t= build1 (GOTO_EXPR, void_type_node, TREE_VEC_ELT (cases, 0));\n-      append_to_statement_list (default_jump, &SWITCH_BODY (switch_expr));\n-\n-      for (int c = 0; c < TREE_VEC_LENGTH (cases); ++c)\n-\t{\n-\t  tree case_label\n-\t    = build_case_label (build_int_cst (integer_type_node, c), NULL_TREE,\n-\t\t\t\tcreate_artificial_label (UNKNOWN_LOCATION));\n-\n-\t  append_to_statement_list (case_label, &SWITCH_BODY (switch_expr));\n-\n-\t  tree jump\n-\t    = build1 (GOTO_EXPR, void_type_node, TREE_VEC_ELT (cases, c));\n-\t  append_to_statement_list (jump, &SWITCH_BODY (switch_expr));\n-\t}\n-      m_parent.m_cf->append_statement (switch_expr);\n-    }\n-  else if (brig_inst->opcode == BRIG_OPCODE_CBR)\n-    {\n-      tree condition = operands[0];\n-      tree target_goto = build1 (GOTO_EXPR, void_type_node, operands[1]);\n-      /* Represents the if..else as (condition)?(goto foo):(goto bar).  */\n-      tree if_stmt\n-\t= build3 (COND_EXPR, void_type_node, condition, target_goto, NULL_TREE);\n-      m_parent.m_cf->append_statement (if_stmt);\n-    }\n-  else if (brig_inst->opcode == BRIG_OPCODE_WAVEBARRIER)\n-    {\n-      /* WAVEBARRIER is a NOP when WAVESIZE = 1.  */\n-    }\n-  else if (brig_inst->opcode == BRIG_OPCODE_BARRIER)\n-    {\n-      m_parent.m_cf->m_has_barriers = true;\n-      tree_stl_vec call_operands;\n-      /* FIXME.  We should add attributes (are there suitable ones in gcc?) that\n-\t ensure the barrier won't be duplicated or moved out of loops etc.\n-\t Like the 'noduplicate' of LLVM.  Same goes for fbarriers.  */\n-      m_parent.m_cf->append_statement\n-\t(m_parent.m_cf->expand_or_call_builtin (brig_inst->opcode,\n-\t\t\t\t\t\tBRIG_TYPE_NONE, NULL_TREE,\n-\t\t\t\t\t\tcall_operands));\n-    }\n-  else if (brig_inst->opcode >= BRIG_OPCODE_ARRIVEFBAR\n-\t   && brig_inst->opcode <= BRIG_OPCODE_WAITFBAR)\n-    {\n-      m_parent.m_cf->m_has_barriers = true;\n-      m_parent.m_cf->append_statement\n-\t(m_parent.m_cf->expand_or_call_builtin (brig_inst->opcode,\n-\t\t\t\t\t\tBRIG_TYPE_NONE,\n-\t\t\t\t\t\tuint32_type_node, operands));\n-    }\n-  else\n-    gcc_unreachable ();\n-  m_parent.m_cf->start_new_bb ();\n-  return base->byteCount;\n-}"}, {"sha": "62ebfaca0b379907997a8db2bc0566ea773b5e07", "filename": "gcc/brig/brigfrontend/brig-cmp-inst-handler.cc", "status": "removed", "additions": 0, "deletions": 198, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cmp-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cmp-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cmp-inst-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,198 +0,0 @@\n-/* brig-cmp-inst-handler.cc -- brig cmp instruction handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-#include \"diagnostic.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"print-tree.h\"\n-#include \"brig-util.h\"\n-#include \"convert.h\"\n-\n-size_t\n-brig_cmp_inst_handler::operator () (const BrigBase *base)\n-{\n-  const BrigInstBase *inst_base = (const BrigInstBase *) base;\n-  const BrigInstCmp *inst = (const BrigInstCmp *) base;\n-\n-  tree cmp_type = get_tree_expr_type_for_hsa_type (inst->sourceType);\n-\n-  /* The destination type to convert the comparison result to.  */\n-  tree dest_type = gccbrig_tree_type_for_hsa_type (inst_base->type);\n-\n-  const bool is_fp16_dest\n-    = (inst_base->type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16;\n-  const bool is_boolean_dest\n-    = (inst_base->type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_B1;\n-\n-  bool is_int_cmp = VECTOR_TYPE_P (cmp_type)\n-\t\t      ? INTEGRAL_TYPE_P (TREE_TYPE (cmp_type))\n-\t\t      : INTEGRAL_TYPE_P (cmp_type);\n-\n-  /* The type for the GENERIC comparison.  It should match the\n-     input operand width for vector comparisons, a boolean\n-     otherwise.  */\n-  tree result_type = get_comparison_result_type (cmp_type);\n-\n-  /* Save the result as a boolean and extend/convert it to the\n-     wanted destination type.  */\n-  tree expr = NULL_TREE;\n-\n-  std::vector<tree> operands = build_operands (*inst_base);\n-\n-  switch (inst->compare)\n-    {\n-    case BRIG_COMPARE_SEQ:\n-    case BRIG_COMPARE_EQ:\n-      expr = build2 (EQ_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SNE:\n-    case BRIG_COMPARE_NE:\n-      expr = build2 (NE_EXPR, result_type, operands[1], operands[2]);\n-\n-      if (!is_int_cmp)\n-\texpr = build2 (BIT_AND_EXPR, TREE_TYPE (expr),\n-\t\t       expr,\n-\t\t       build2 (ORDERED_EXPR, result_type, operands[1],\n-\t\t\t       operands[2]));\n-      break;\n-    case BRIG_COMPARE_SLT:\n-    case BRIG_COMPARE_LT:\n-      expr = build2 (LT_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SLE:\n-    case BRIG_COMPARE_LE:\n-      expr = build2 (LE_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SGT:\n-    case BRIG_COMPARE_GT:\n-      expr = build2 (GT_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SGE:\n-    case BRIG_COMPARE_GE:\n-      expr = build2 (GE_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SEQU:\n-    case BRIG_COMPARE_EQU:\n-      expr = build2 (UNEQ_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SNEU:\n-    case BRIG_COMPARE_NEU:\n-      expr = build2 (NE_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SLTU:\n-    case BRIG_COMPARE_LTU:\n-      expr = build2 (UNLT_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SLEU:\n-    case BRIG_COMPARE_LEU:\n-      expr = build2 (UNLE_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SGTU:\n-    case BRIG_COMPARE_GTU:\n-      expr = build2 (UNGT_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SGEU:\n-    case BRIG_COMPARE_GEU:\n-      expr = build2 (UNGE_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SNUM:\n-    case BRIG_COMPARE_NUM:\n-      expr = build2 (ORDERED_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    case BRIG_COMPARE_SNAN:\n-    case BRIG_COMPARE_NAN:\n-      expr = build2 (UNORDERED_EXPR, result_type, operands[1], operands[2]);\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  if (expr == NULL_TREE)\n-    gcc_unreachable ();\n-\n-  if (is_fp16_dest)\n-    {\n-      expr = convert_to_real (brig_to_generic::s_fp32_type, expr);\n-    }\n-  else if (VECTOR_TYPE_P (dest_type) && ANY_INTEGRAL_TYPE_P (dest_type)\n-\t   && !is_boolean_dest\n-\t   && (inst->sourceType & BRIG_TYPE_BASE_MASK) != BRIG_TYPE_F16)\n-    {\n-      /* In later gcc versions, the output of comparison is not\n-\t all ones for vectors like still in 4.9.1.  We need to use\n-\t an additional VEC_COND_EXPR to produce the all ones 'true' value\n-\t required by HSA.\n-\t VEC_COND_EXPR <a == b, { -1, -1, -1, -1 }, { 0, 0, 0, 0 }>; */\n-\n-      tree all_ones\n-\t= build_vector_from_val (dest_type,\n-\t\t\t       build_minus_one_cst (TREE_TYPE (dest_type)));\n-      tree all_zeroes\n-\t= build_vector_from_val (dest_type,\n-\t\t\t       build_zero_cst (TREE_TYPE (dest_type)));\n-      expr = build3 (VEC_COND_EXPR, dest_type, expr, all_ones, all_zeroes);\n-    }\n-  else if (INTEGRAL_TYPE_P (dest_type) && !is_boolean_dest)\n-    {\n-      /* We need to produce the all-ones pattern for the width of the whole\n-\t resulting integer type.  Use back and forth shifts for propagating\n-\t the lower 1.  */\n-      tree signed_type = signed_type_for (dest_type);\n-      tree signed_result = convert_to_integer (signed_type, expr);\n-\n-      size_t result_width = int_size_in_bytes (dest_type) * BITS_PER_UNIT;\n-\n-      tree shift_amount_cst\n-\t= build_int_cstu (signed_type, result_width - 1);\n-\n-      tree shift_left_result\n-\t= build2 (LSHIFT_EXPR, signed_type, signed_result, shift_amount_cst);\n-\n-      expr = build2 (RSHIFT_EXPR, signed_type, shift_left_result,\n-\t\t     shift_amount_cst);\n-    }\n-  else if (SCALAR_FLOAT_TYPE_P (dest_type))\n-    {\n-      expr = convert_to_real (dest_type, expr);\n-    }\n-  else if (VECTOR_TYPE_P (dest_type)\n-\t   && (inst->sourceType & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16)\n-    {\n-      /* Because F16 comparison is emulated as an F32 comparison with S32\n-\t results, we must now truncate the result vector to S16s so it\n-\t fits to the destination register.  We can build the target vector\n-\t type from the f16 storage type (unsigned ints).  */\n-      expr = m_parent.m_cf->add_temp_var (\"wide_cmp_result\", expr);\n-      tree_stl_vec wide_elements;\n-      tree_stl_vec shrunk_elements;\n-      m_parent.m_cf->unpack (expr, wide_elements);\n-      for (size_t i = 0; i < wide_elements.size (); ++i)\n-\t{\n-\t  tree wide = wide_elements.at (i);\n-\t  shrunk_elements.push_back\n-\t    (convert_to_integer (short_integer_type_node, wide));\n-\t}\n-      expr = m_parent.m_cf->pack (shrunk_elements);\n-    }\n-  build_output_assignment (*inst_base, operands[0], expr);\n-\n-  return base->byteCount;\n-}"}, {"sha": "7ead226576d5eb17ddec9eb4e5895a7bc6ed1ce6", "filename": "gcc/brig/brigfrontend/brig-code-entry-handler.cc", "status": "removed", "additions": 0, "deletions": 1305, "changes": 1305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,1305 +0,0 @@\n-/* brig-code-entry-handler.cc -- a gccbrig base class\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-\n-#include \"stringpool.h\"\n-#include \"tree-iterator.h\"\n-#include \"toplev.h\"\n-#include \"diagnostic.h\"\n-#include \"brig-machine.h\"\n-#include \"brig-util.h\"\n-#include \"errors.h\"\n-#include \"real.h\"\n-#include \"print-tree.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"target.h\"\n-#include \"langhooks.h\"\n-#include \"gimple-expr.h\"\n-#include \"convert.h\"\n-#include \"brig-util.h\"\n-#include \"builtins.h\"\n-#include \"phsa.h\"\n-#include \"brig-builtins.h\"\n-#include \"fold-const.h\"\n-\n-brig_code_entry_handler::brig_code_entry_handler (brig_to_generic &parent)\n-  : brig_entry_handler (parent)\n-{\n-}\n-\n-/* Build a tree operand which is a reference to a piece of code.  REF is the\n-   original reference as a BRIG object.  */\n-\n-tree\n-brig_code_entry_handler::build_code_ref (const BrigBase &ref)\n-{\n-  if (ref.kind == BRIG_KIND_DIRECTIVE_LABEL)\n-    {\n-      const BrigDirectiveLabel *brig_label = (const BrigDirectiveLabel *) &ref;\n-\n-      const BrigData *label_name\n-\t= m_parent.get_brig_data_entry (brig_label->name);\n-\n-      std::string label_str ((const char *) (label_name->bytes),\n-\t\t\t     label_name->byteCount);\n-      return m_parent.m_cf->label (label_str);\n-    }\n-  else if (ref.kind == BRIG_KIND_DIRECTIVE_FUNCTION)\n-    {\n-      const BrigDirectiveExecutable *func\n-       = (const BrigDirectiveExecutable *) &ref;\n-      return m_parent.function_decl (m_parent.get_mangled_name (func));\n-    }\n-  else if (ref.kind == BRIG_KIND_DIRECTIVE_FBARRIER)\n-    {\n-      const BrigDirectiveFbarrier* fbar = (const BrigDirectiveFbarrier*)&ref;\n-\n-      std::string var_name = m_parent.get_mangled_name (fbar);\n-      uint64_t offset\n-\t= m_parent.m_cf->group_variable_segment_offset (var_name);\n-\n-      tree local_offset = build_int_cst (uint32_type_node, offset);\n-      if (m_parent.m_cf->m_local_group_variables.has_variable (var_name))\n-\tlocal_offset\n-\t  = build2 (PLUS_EXPR, uint64_type_node, local_offset,\n-\t\t    convert (uint64_type_node,\n-\t\t\t     m_parent.m_cf->m_group_local_offset_arg));\n-      return local_offset;\n-    }\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Produce a tree operand for the given BRIG_INST and its OPERAND.\n-   OPERAND_TYPE should be the operand type in case it should not\n-   be dictated by the BrigBase.  IS_INPUT indicates if the operand\n-   is an input operand or a result.  */\n-\n-tree\n-brig_code_entry_handler::build_tree_operand (const BrigInstBase &brig_inst,\n-\t\t\t\t\t     const BrigBase &operand,\n-\t\t\t\t\t     tree operand_type, bool is_input)\n-{\n-  switch (operand.kind)\n-    {\n-    case BRIG_KIND_OPERAND_OPERAND_LIST:\n-      {\n-\tvec<constructor_elt, va_gc> *constructor_vals = NULL;\n-\tconst BrigOperandOperandList &oplist\n-\t  = (const BrigOperandOperandList &) operand;\n-\tconst BrigData *data = m_parent.get_brig_data_entry (oplist.elements);\n-\tsize_t bytes = data->byteCount;\n-\tconst BrigOperandOffset32_t *operand_ptr\n-\t  = (const BrigOperandOffset32_t *) data->bytes;\n-\twhile (bytes > 0)\n-\t  {\n-\t    BrigOperandOffset32_t offset = *operand_ptr;\n-\t    const BrigBase *operand_element\n-\t      = m_parent.get_brig_operand_entry (offset);\n-\t    tree element\n-\t      = build_tree_operand (brig_inst, *operand_element, operand_type);\n-\n-\t    /* In case a vector is used an input, cast the elements to\n-\t       correct size here so we don't need a separate unpack/pack for it.\n-\t       fp16-fp32 conversion is done in build_operands ().  */\n-\t    if (is_input && TREE_TYPE (element) != operand_type)\n-\t      element = build_resize_convert_view (operand_type, element);\n-\n-\t    CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, element);\n-\t    ++operand_ptr;\n-\t    bytes -= 4;\n-\t  }\n-\tsize_t element_count = data->byteCount / 4;\n-\ttree vec_type = build_vector_type (operand_type, element_count);\n-\n-\treturn build_constructor (vec_type, constructor_vals);\n-      }\n-    case BRIG_KIND_OPERAND_CODE_LIST:\n-      {\n-\t/* Build a TREE_VEC of code expressions.  */\n-\n-\tconst BrigOperandCodeList &oplist\n-\t  = (const BrigOperandCodeList &) operand;\n-\tconst BrigData *data = m_parent.get_brig_data_entry (oplist.elements);\n-\tsize_t bytes = data->byteCount;\n-\tconst BrigOperandOffset32_t *operand_ptr\n-\t  = (const BrigOperandOffset32_t *) data->bytes;\n-\n-\tsize_t case_index = 0;\n-\tsize_t element_count = data->byteCount / 4;\n-\n-\t/* Create a TREE_VEC out of the labels in the list.  */\n-\ttree vec = make_tree_vec (element_count);\n-\n-\twhile (bytes > 0)\n-\t  {\n-\t    BrigOperandOffset32_t offset = *operand_ptr;\n-\t    const BrigBase *ref = m_parent.get_brig_code_entry (offset);\n-\t    tree element = build_code_ref (*ref);\n-\n-\t    gcc_assert (case_index < element_count);\n-\t    TREE_VEC_ELT (vec, case_index) = element;\n-\t    case_index++;\n-\n-\t    ++operand_ptr;\n-\t    bytes -= 4;\n-\t  }\n-\treturn vec;\n-      }\n-    case BRIG_KIND_OPERAND_REGISTER:\n-      {\n-\tconst BrigOperandRegister *brig_reg\n-\t  = (const BrigOperandRegister *) &operand;\n-\treturn m_parent.m_cf->get_m_var_declfor_reg (brig_reg);\n-      }\n-    case BRIG_KIND_OPERAND_CONSTANT_BYTES:\n-      {\n-\tconst BrigOperandConstantBytes *brigConst\n-\t  = (const BrigOperandConstantBytes *) &operand;\n-\t/* The constants can be of different type than the instruction\n-\t   and are implicitly casted to the input operand.  */\n-\treturn get_tree_cst_for_hsa_operand (brigConst, NULL_TREE);\n-      }\n-    case BRIG_KIND_OPERAND_WAVESIZE:\n-      {\n-\tif (!INTEGRAL_TYPE_P (operand_type))\n-\t  {\n-\t    gcc_unreachable ();\n-\t    return NULL_TREE;\n-\t  }\n-\treturn build_int_cstu (operand_type, gccbrig_get_target_wavesize ());\n-      }\n-    case BRIG_KIND_OPERAND_CODE_REF:\n-      {\n-\tconst BrigOperandCodeRef *brig_code_ref\n-\t  = (const BrigOperandCodeRef *) &operand;\n-\n-\tconst BrigBase *ref = m_parent.get_brig_code_entry (brig_code_ref->ref);\n-\n-\treturn build_code_ref (*ref);\n-      }\n-    case BRIG_KIND_OPERAND_ADDRESS:\n-      {\n-\treturn build_address_operand (brig_inst,\n-\t\t\t\t      (const BrigOperandAddress &) operand);\n-      }\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Build a tree node representing an address reference from a BRIG_INST and its\n-   ADDR_OPERAND.  */\n-\n-tree\n-brig_code_entry_handler::build_address_operand\n-  (const BrigInstBase &brig_inst, const BrigOperandAddress &addr_operand)\n-{\n-  tree instr_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n-\n-  BrigSegment8_t segment = BRIG_SEGMENT_GLOBAL;\n-  if (brig_inst.opcode == BRIG_OPCODE_LDA)\n-    segment = ((const BrigInstAddr &) brig_inst).segment;\n-  else if (brig_inst.base.kind == BRIG_KIND_INST_MEM)\n-    segment = ((const BrigInstMem &) brig_inst).segment;\n-  else if (brig_inst.base.kind == BRIG_KIND_INST_ATOMIC)\n-    segment = ((const BrigInstAtomic &) brig_inst).segment;\n-\n-  tree var_offset = NULL_TREE;\n-  tree const_offset = NULL_TREE;\n-  tree symbol_base = NULL_TREE;\n-\n-  if (addr_operand.symbol != 0)\n-    {\n-      const BrigDirectiveVariable *arg_symbol\n-\t= (const BrigDirectiveVariable *) m_parent.get_brig_code_entry\n-\t(addr_operand.symbol);\n-\n-      std::string var_name = m_parent.get_mangled_name (arg_symbol);\n-\n-      if (segment == BRIG_SEGMENT_KERNARG)\n-\t{\n-\t  /* Find the offset to the kernarg buffer for the given\n-\t     kernel argument variable.  */\n-\t  tree func = m_parent.m_cf->m_func_decl;\n-\t  /* __args is the first parameter in kernel functions.  */\n-\t  symbol_base = DECL_ARGUMENTS (func);\n-\t  uint64_t offset = m_parent.m_cf->kernel_arg_offset (arg_symbol);\n-\t  if (offset > 0)\n-\t    const_offset = build_int_cst (size_type_node, offset);\n-\t}\n-      else if (segment == BRIG_SEGMENT_GROUP)\n-\t{\n-\t  uint64_t offset\n-\t    = m_parent.m_cf->group_variable_segment_offset (var_name);\n-\t  const_offset = build_int_cst (size_type_node, offset);\n-\n-\t  /* If it's a local group variable reference, substract the local\n-\t     group segment offset to get the group base ptr offset.  */\n-\t  if (m_parent.m_cf->m_local_group_variables.has_variable (var_name))\n-\t    const_offset\n-\t      = build2 (PLUS_EXPR, uint64_type_node, const_offset,\n-\t\t\tconvert (uint64_type_node,\n-\t\t\t\t m_parent.m_cf->m_group_local_offset_arg));\n-\n-\t}\n-      else if (segment == BRIG_SEGMENT_PRIVATE || segment == BRIG_SEGMENT_SPILL)\n-\t{\n-\t  uint32_t offset = m_parent.private_variable_segment_offset (var_name);\n-\n-\t  /* Compute the offset to the work item's copy:\n-\n-\t     single-wi-offset * local_size + wiflatid * varsize\n-\n-\t     This way the work items have the same variable in\n-\t     successive elements to each other in the segment,\n-\t     helping to achieve autovectorization of loads/stores\n-\t     with stride 1.  */\n-\n-\t  tree_stl_vec uint32_0\n-\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, 0));\n-\n-\t  tree_stl_vec uint32_1\n-\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, 1));\n-\n-\t  tree_stl_vec uint32_2\n-\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, 2));\n-\n-\t  tree local_size\n-\t    = build2 (MULT_EXPR, uint32_type_node,\n-\t\t      m_parent.m_cf->expand_or_call_builtin\n-\t\t      (BRIG_OPCODE_WORKGROUPSIZE, BRIG_TYPE_U32,\n-\t\t       uint32_type_node, uint32_0),\n-\t\t      m_parent.m_cf->expand_or_call_builtin\n-\t\t      (BRIG_OPCODE_WORKGROUPSIZE, BRIG_TYPE_U32,\n-\t\t       uint32_type_node, uint32_1));\n-\n-\t  local_size\n-\t    = build2 (MULT_EXPR, uint32_type_node,\n-\t\t      m_parent.m_cf->expand_or_call_builtin\n-\t\t      (BRIG_OPCODE_WORKGROUPSIZE, BRIG_TYPE_U32,\n-\t\t       uint32_type_node, uint32_2),\n-\t\t      local_size);\n-\n-\t  tree var_region\n-\t    = build2 (MULT_EXPR, uint32_type_node,\n-\t\t      build_int_cst (uint32_type_node, offset), local_size);\n-\n-\t  tree_stl_vec operands;\n-\t  tree pos\n-\t    = build2 (MULT_EXPR, uint32_type_node,\n-\t\t      build_int_cst (uint32_type_node,\n-\t\t\t\t     m_parent.private_variable_size (var_name)),\n-\t\t      m_parent.m_cf->expand_or_call_builtin\n-\t\t      (BRIG_OPCODE_WORKITEMFLATID, BRIG_TYPE_U32,\n-\t\t       uint32_type_node, operands));\n-\n-\t  tree var_offset\n-\t    = build2 (PLUS_EXPR, uint32_type_node, var_region, pos);\n-\n-\t  /* In case of LDA this is returned directly as an integer value.\n-\t     For other mem-related instructions, we will convert this segment\n-\t     offset to a flat address by adding it as an offset to a (private\n-\t     or group) base pointer later on.  Same applies to group_var_offset.  */\n-\t  symbol_base\n-\t    = m_parent.m_cf->add_temp_var (\"priv_var_offset\",\n-\t\t\t\t\t   convert (size_type_node,\n-\t\t\t\t\t\t    var_offset));\n-\t}\n-      else if (segment == BRIG_SEGMENT_ARG)\n-\t{\n-\t  tree arg_var_decl;\n-\t  if (m_parent.m_cf->m_ret_value_brig_var == arg_symbol)\n-\t    arg_var_decl = m_parent.m_cf->m_ret_temp;\n-\t  else\n-\t    arg_var_decl = m_parent.m_cf->arg_variable (arg_symbol);\n-\n-\t  gcc_assert (arg_var_decl != NULL_TREE);\n-\n-\t  tree ptype = build_pointer_type (instr_type);\n-\n-\t  if (arg_symbol->type & BRIG_TYPE_ARRAY)\n-\t    {\n-\n-\t      /* Two different type of array references in case of arguments\n-\t\t depending where they are referred at.  In the caller (argument\n-\t\t segment), the reference is to an array object and\n-\t\t in the callee, the array object has been passed as a pointer\n-\t\t to the array object.  */\n-\n-\t      if (POINTER_TYPE_P (TREE_TYPE (arg_var_decl)))\n-\t\tsymbol_base = build_resize_convert_view (ptype, arg_var_decl);\n-\t      else\n-\t\t{\n-\t\t  /* In case we are referring to an array (the argument in\n-\t\t     call site), use its element zero as the base address.  */\n-\t\t  tree element_zero\n-\t\t    = build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (arg_var_decl)),\n-\t\t\t      arg_var_decl, integer_zero_node, NULL_TREE,\n-\t\t\t      NULL_TREE);\n-\t\t  symbol_base = build1 (ADDR_EXPR, ptype, element_zero);\n-\t\t}\n-\t    }\n-\t  else\n-\t    symbol_base = build1 (ADDR_EXPR, ptype, arg_var_decl);\n-\t}\n-      else\n-\t{\n-\t  tree global_var_decl = m_parent.global_variable (var_name);\n-\n-\t  /* In case the global variable hasn't been defined (yet),\n-\t     use the host def indirection ptr variable.  */\n-\t  if (global_var_decl == NULL_TREE)\n-\t    {\n-\t      std::string host_ptr_name\n-\t\t= std::string (PHSA_HOST_DEF_PTR_PREFIX) + var_name;\n-\t      tree host_defined_ptr = m_parent.global_variable (host_ptr_name);\n-\t      gcc_assert (host_defined_ptr != NULL_TREE);\n-\t      symbol_base = host_defined_ptr;\n-\t    }\n-\t  else\n-\t    {\n-\t      gcc_assert (global_var_decl != NULL_TREE);\n-\n-\t      tree ptype = build_pointer_type (instr_type);\n-\t      symbol_base = build1 (ADDR_EXPR, ptype, global_var_decl);\n-\t    }\n-\t}\n-    }\n-\n-  if (brig_inst.opcode != BRIG_OPCODE_LDA)\n-    {\n-      /* In case of lda_* we want to return the segment address because it's\n-\t used as a value, perhaps in address computation and later converted\n-\t explicitly to a flat address.\n-\n-\t In case of other instructions with memory operands we produce the flat\n-\t address directly here (assuming the target does not have a separate\n-\t address space for group/private segments for now).  */\n-      if (segment == BRIG_SEGMENT_GROUP)\n-\tsymbol_base = m_parent.m_cf->m_group_base_arg;\n-      else if (segment == BRIG_SEGMENT_PRIVATE\n-\t       || segment == BRIG_SEGMENT_SPILL)\n-\t{\n-\t  if (symbol_base != NULL_TREE)\n-\t    symbol_base = build2 (POINTER_PLUS_EXPR, ptr_type_node,\n-\t\t\t\t  m_parent.m_cf->m_private_base_arg,\n-\t\t\t\t  symbol_base);\n-\t  else\n-\t    symbol_base = m_parent.m_cf->m_private_base_arg;\n-\t}\n-    }\n-\n-  if (addr_operand.reg != 0)\n-    {\n-      const BrigOperandRegister *mem_base_reg\n-\t= (const BrigOperandRegister *) m_parent.get_brig_operand_entry\n-\t(addr_operand.reg);\n-      tree base_reg_var = m_parent.m_cf->get_m_var_declfor_reg (mem_base_reg);\n-      tree as_uint = build_reinterpret_to_uint (base_reg_var);\n-      var_offset = convert_to_pointer (ptr_type_node, as_uint);\n-\n-      gcc_assert (var_offset != NULL_TREE);\n-    }\n-  /* The pointer type we use to access the memory.  Should be of the\n-     width of the load/store instruction, not the target/data\n-     register.  */\n-  tree ptype = build_pointer_type (instr_type);\n-\n-  gcc_assert (ptype != NULL_TREE);\n-\n-  tree addr = NULL_TREE;\n-  if (symbol_base != NULL_TREE && var_offset != NULL_TREE)\n-    /* The most complex addressing mode: symbol + reg [+ const offset].  */\n-    addr = build2 (POINTER_PLUS_EXPR, ptr_type_node,\n-\t\t   convert (ptr_type_node, symbol_base),\n-\t\t   convert (size_type_node, var_offset));\n-  else if (var_offset != NULL)\n-    addr = var_offset;\n-  else if (symbol_base != NULL)\n-    addr = symbol_base;\n-\n-  if (const_offset != NULL_TREE)\n-    {\n-      if (addr == NULL_TREE)\n-\t/* At least direct module-scope global group symbol access with LDA\n-\t   has only the const_offset.  Group base ptr is not added as LDA should\n-\t   return the segment address, not the flattened one.  */\n-\taddr = const_offset;\n-      else\n-\taddr = build2 (POINTER_PLUS_EXPR, ptr_type_node,\n-\t\t       addr, convert (size_type_node, const_offset));\n-    }\n-\n-  /* We might have two const offsets in case of group or private arrays\n-     which have the first offset to the incoming group/private pointer\n-     arg, and the second one an offset to it. It's also legal to have\n-     a reference with a zero constant offset but no symbol.  I've seen\n-     codes that reference kernarg segment like this.  Thus, if at this\n-     point there is no address expression at all we assume it's an\n-     access to offset 0. */\n-  uint64_t offs = gccbrig_to_uint64_t (addr_operand.offset);\n-  if (offs > 0 || addr == NULL_TREE)\n-    {\n-      /* In large mode, the offset is treated as 32bits unless it's\n-\t global, readonly or kernarg address space.\n-\t See:\n-\t http://www.hsafoundation.com/html_spec111/HSA_Library.htm\n-\t #PRM/Topics/02_ProgModel/small_and_large_machine_models.htm\n-\t #table_machine_model_data_sizes */\n-\n-      int is64b_offset = segment == BRIG_SEGMENT_GLOBAL\n-\t|| segment == BRIG_SEGMENT_READONLY\n-\t|| segment == BRIG_SEGMENT_KERNARG;\n-\n-      /* The original offset is signed and should be sign\n-\t extended for the pointer arithmetics.  */\n-      tree const_offset_2 = is64b_offset\n-        ? build_int_cst (size_type_node, offs)\n-        : convert (long_integer_type_node,\n-                   build_int_cst (integer_type_node, offs));\n-\n-      if (addr == NULL_TREE)\n-\taddr = const_offset_2;\n-      else\n-\taddr = build2 (POINTER_PLUS_EXPR, ptr_type_node,\n-\t\t       /* Addr can be a constant offset in case this is\n-\t\t\t  a private array access.  */\n-\t\t       convert (ptr_type_node, addr),\n-\t\t       convert (size_type_node, const_offset_2));\n-    }\n-\n-  gcc_assert (addr != NULL_TREE);\n-  return convert_to_pointer (ptype, addr);\n-}\n-\n-/* Builds a tree operand with the given OPERAND_INDEX for the given\n-   BRIG_INST with the desired tree OPERAND_TYPE.  OPERAND_TYPE can\n-   be NULL in case the type is forced by the BRIG_INST type.  */\n-\n-tree\n-brig_code_entry_handler::build_tree_operand_from_brig\n-  (const BrigInstBase *brig_inst, tree operand_type, size_t operand_index)\n-{\n-  const BrigData *operand_entries\n-    = m_parent.get_brig_data_entry (brig_inst->operands);\n-\n-  uint32_t operand_offset\n-    = ((const uint32_t *) &operand_entries->bytes)[operand_index];\n-  const BrigBase *operand_data\n-    = m_parent.get_brig_operand_entry (operand_offset);\n-\n-  bool inputp = !gccbrig_hsa_opcode_op_output_p (brig_inst->opcode,\n-\t\t\t\t\t\t operand_index);\n-  return build_tree_operand (*brig_inst, *operand_data, operand_type, inputp);\n-}\n-\n-/* Builds a single (scalar) constant initialized element of type\n-   ELEMENT_TYPE from the buffer pointed to by NEXT_DATA.  */\n-\n-tree\n-brig_code_entry_handler::build_tree_cst_element\n-  (BrigType16_t element_type, const unsigned char *next_data) const\n-{\n-\n-  tree tree_element_type = gccbrig_tree_type_for_hsa_type (element_type);\n-\n-  tree cst;\n-  switch (element_type)\n-    {\n-    case BRIG_TYPE_F16:\n-      {\n-\tHOST_WIDE_INT low = *(const uint16_t *) next_data;\n-\tcst = build_int_cst (uint16_type_node, low);\n-\tbreak;\n-      }\n-    case BRIG_TYPE_F32:\n-      {\n-\tREAL_VALUE_TYPE val;\n-\tieee_single_format.decode (&ieee_single_format, &val,\n-\t\t\t\t   (const long *) next_data);\n-\tcst = build_real (tree_element_type, val);\n-\tbreak;\n-      }\n-    case BRIG_TYPE_F64:\n-      {\n-\tlong data[2];\n-\tdata[0] = *(const uint32_t *) next_data;\n-\tdata[1] = *(const uint32_t *) (next_data + 4);\n-\tREAL_VALUE_TYPE val;\n-\tieee_double_format.decode (&ieee_double_format, &val, data);\n-\tcst = build_real (tree_element_type, val);\n-\tbreak;\n-      }\n-    case BRIG_TYPE_S8:\n-    case BRIG_TYPE_S16:\n-    case BRIG_TYPE_S32:\n-    case BRIG_TYPE_S64:\n-      {\n-\tHOST_WIDE_INT low = *(const int64_t *) next_data;\n-\tcst = build_int_cst (tree_element_type, low);\n-\tbreak;\n-      }\n-    case BRIG_TYPE_U8:\n-    case BRIG_TYPE_U16:\n-    case BRIG_TYPE_U32:\n-    case BRIG_TYPE_U64:\n-      {\n-\tunsigned HOST_WIDE_INT low = *(const uint64_t *) next_data;\n-\tcst = build_int_cstu (tree_element_type, low);\n-\tbreak;\n-      }\n-    case BRIG_TYPE_SIG64:\n-      {\n-\tunsigned HOST_WIDE_INT low = *(const uint64_t *) next_data;\n-\tcst = build_int_cstu (uint64_type_node, low);\n-\tbreak;\n-      }\n-    case BRIG_TYPE_SIG32:\n-      {\n-\tunsigned HOST_WIDE_INT low = *(const uint64_t *) next_data;\n-\tcst = build_int_cstu (uint32_type_node, low);\n-\tbreak;\n-      }\n-    default:\n-      gcc_unreachable ();\n-      return NULL_TREE;\n-    }\n-  return cst;\n-}\n-\n-/* Produce a tree constant type for the given BRIG constant (BRIG_CONST).\n-   TYPE should be the forced instruction type, otherwise the type is\n-   dictated by the BRIG_CONST.  */\n-\n-tree\n-brig_code_entry_handler::get_tree_cst_for_hsa_operand\n-  (const BrigOperandConstantBytes *brig_const, tree type) const\n-{\n-  const BrigData *data = m_parent.get_brig_data_entry (brig_const->bytes);\n-\n-  tree cst = NULL_TREE;\n-\n-  if (type == NULL_TREE)\n-    type = gccbrig_tree_type_for_hsa_type (brig_const->type);\n-\n-  /* The type of a single (scalar) element inside an array,\n-     vector or an array of vectors.  */\n-  BrigType16_t scalar_element_type\n-    = brig_const->type & BRIG_TYPE_BASE_MASK;\n-  tree tree_element_type = type;\n-\n-  vec<constructor_elt, va_gc> *constructor_vals = NULL;\n-\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    tree_element_type = TREE_TYPE (type);\n-\n-  size_t bytes_left = data->byteCount;\n-  const unsigned char *next_data = data->bytes;\n-  size_t scalar_element_size\n-    = gccbrig_hsa_type_bit_size (scalar_element_type) / BITS_PER_UNIT;\n-\n-  while (bytes_left > 0)\n-    {\n-      if (VECTOR_TYPE_P (tree_element_type))\n-\t{\n-\t  /* In case of vector type elements (or sole vectors),\n-\t     create a vector ctor.  */\n-\t  size_t element_count\n-\t    = gccbrig_type_vector_subparts (tree_element_type);\n-\t  if (bytes_left < scalar_element_size * element_count)\n-\t    fatal_error (UNKNOWN_LOCATION,\n-\t\t\t \"Not enough bytes left for the initializer \"\n-\t\t\t \"(%lu need %lu).\", (unsigned long) bytes_left,\n-\t\t\t (unsigned long) (scalar_element_size\n-\t\t\t\t\t  * element_count));\n-\n-\t  vec<constructor_elt, va_gc> *vec_els = NULL;\n-\t  for (size_t i = 0; i < element_count; ++i)\n-\t    {\n-\t      tree element\n-\t\t= build_tree_cst_element (scalar_element_type, next_data);\n-\t      CONSTRUCTOR_APPEND_ELT (vec_els, NULL_TREE, element);\n-\t      bytes_left -= scalar_element_size;\n-\t      next_data += scalar_element_size;\n-\t    }\n-\t  cst = build_vector_from_ctor (tree_element_type, vec_els);\n-\t}\n-      else\n-\t{\n-\t  if (bytes_left < scalar_element_size)\n-\t    fatal_error (UNKNOWN_LOCATION,\n-\t\t\t \"Not enough bytes left for the initializer \"\n-\t\t\t \"(%lu need %lu).\", (unsigned long) bytes_left,\n-\t\t\t (unsigned long) scalar_element_size);\n-\t  cst = build_tree_cst_element (scalar_element_type, next_data);\n-\t  bytes_left -= scalar_element_size;\n-\t  next_data += scalar_element_size;\n-\t}\n-      CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, cst);\n-    }\n-\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    return build_constructor (type, constructor_vals);\n-  else\n-    return cst;\n-}\n-\n-/* Return the matching tree instruction arithmetics type for the\n-   given BRIG_TYPE.  The aritmethics type is the one with which\n-   computation is done (in contrast to the storage type).  F16\n-   arithmetics type is emulated using F32 for now.  */\n-\n-tree\n-brig_code_entry_handler::get_tree_expr_type_for_hsa_type\n-  (BrigType16_t brig_type) const\n-{\n-  BrigType16_t brig_inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n-  if (brig_inner_type == BRIG_TYPE_F16)\n-    {\n-      if (brig_inner_type == brig_type)\n-\treturn m_parent.s_fp32_type;\n-      size_t element_count = gccbrig_hsa_type_bit_size (brig_type) / 16;\n-      return build_vector_type (m_parent.s_fp32_type, element_count);\n-    }\n-  else\n-    return gccbrig_tree_type_for_hsa_type (brig_type);\n-}\n-\n-/* Return the correct GENERIC type for storing comparison results\n-   of operand with the type given in SOURCE_TYPE.  */\n-\n-tree\n-brig_code_entry_handler::get_comparison_result_type (tree source_type)\n-{\n-  if (VECTOR_TYPE_P (source_type))\n-    {\n-      size_t element_size = int_size_in_bytes (TREE_TYPE (source_type));\n-      return build_vector_type\n-\t(build_nonstandard_boolean_type (element_size * BITS_PER_UNIT),\n-\t gccbrig_type_vector_subparts (source_type));\n-    }\n-  else\n-    return gccbrig_tree_type_for_hsa_type (BRIG_TYPE_B1);\n-}\n-\n-/* Creates a FP32 to FP16 conversion call, assuming the source and destination\n-   are FP32 type variables.  */\n-\n-tree\n-brig_code_entry_handler::build_f2h_conversion (tree source)\n-{\n-  return float_to_half () (*this, source);\n-}\n-\n-/* Creates a FP16 to FP32 conversion call, assuming the source and destination\n-   are FP32 type variables.  */\n-\n-tree\n-brig_code_entry_handler::build_h2f_conversion (tree source)\n-{\n-  return half_to_float () (*this, source);\n-}\n-\n-/* Builds and \"normalizes\" the dest and source operands for the instruction\n-   execution; converts the input operands to the expected instruction type,\n-   performs half to float conversions, constant to correct type variable,\n-   and flush to zero (if applicable).  */\n-\n-tree_stl_vec\n-brig_code_entry_handler::build_operands (const BrigInstBase &brig_inst)\n-{\n-  return build_or_analyze_operands (brig_inst, false);\n-}\n-\n-void\n-brig_code_entry_handler::analyze_operands (const BrigInstBase &brig_inst)\n-{\n-  build_or_analyze_operands (brig_inst, true);\n-}\n-\n-/* Implements both the build_operands () and analyze_operands () call\n-   so changes go in tandem.  Performs build_operands () when ANALYZE\n-   is false.  Otherwise, only analyze operands and return empty\n-   list.\n-\n-   If analyzing record each HSA register operand with the\n-   corresponding resolved operand tree type to\n-   brig_to_generic::m_fn_regs_use_index.  */\n-\n-tree_stl_vec\n-brig_code_entry_handler::\n-build_or_analyze_operands (const BrigInstBase &brig_inst, bool analyze)\n-{\n-  /* Flush to zero.  */\n-  bool ftz = false;\n-  const BrigBase *base = &brig_inst.base;\n-\n-  if (base->kind == BRIG_KIND_INST_MOD)\n-    {\n-      const BrigInstMod *mod = (const BrigInstMod *) base;\n-      ftz = mod->modifier & BRIG_ALU_FTZ;\n-    }\n-  else if (base->kind == BRIG_KIND_INST_CMP)\n-    {\n-      const BrigInstCmp *cmp = (const BrigInstCmp *) base;\n-      ftz = cmp->modifier & BRIG_ALU_FTZ;\n-    }\n-\n-  bool is_vec_instr = hsa_type_packed_p (brig_inst.type);\n-\n-  size_t element_count;\n-  if (is_vec_instr)\n-    {\n-      BrigType16_t brig_element_type = brig_inst.type & BRIG_TYPE_BASE_MASK;\n-      element_count = gccbrig_hsa_type_bit_size (brig_inst.type)\n-\t\t      / gccbrig_hsa_type_bit_size (brig_element_type);\n-    }\n-  else\n-    element_count = 1;\n-\n-  bool is_fp16_arith = false;\n-\n-  tree src_type;\n-  tree dest_type;\n-  if (base->kind == BRIG_KIND_INST_CMP)\n-    {\n-      const BrigInstCmp *cmp_inst = (const BrigInstCmp *) base;\n-      src_type = gccbrig_tree_type_for_hsa_type (cmp_inst->sourceType);\n-      dest_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n-      is_fp16_arith\n-\t= (cmp_inst->sourceType & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16;\n-    }\n-  else if (base->kind == BRIG_KIND_INST_SOURCE_TYPE)\n-    {\n-      const BrigInstSourceType *src_type_inst\n-\t= (const BrigInstSourceType *) base;\n-      src_type = gccbrig_tree_type_for_hsa_type (src_type_inst->sourceType);\n-      dest_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n-      is_fp16_arith\n-\t= (src_type_inst->sourceType & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16\n-\t&& !gccbrig_is_bit_operation (brig_inst.opcode);\n-    }\n-  else if (base->kind == BRIG_KIND_INST_SEG_CVT)\n-    {\n-      const BrigInstSegCvt *seg_cvt_inst = (const BrigInstSegCvt *) base;\n-      src_type = gccbrig_tree_type_for_hsa_type (seg_cvt_inst->sourceType);\n-      dest_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n-    }\n-  else if (base->kind == BRIG_KIND_INST_MEM)\n-    {\n-      src_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n-      dest_type = src_type;\n-      /* With mem instructions we don't want to cast the fp16\n-\t back and forth between fp32, because the load/stores\n-\t are not specific to the data type.  */\n-      is_fp16_arith = false;\n-    }\n-  else if (base->kind == BRIG_KIND_INST_CVT)\n-    {\n-      const BrigInstCvt *cvt_inst = (const BrigInstCvt *) base;\n-\n-      src_type = gccbrig_tree_type_for_hsa_type (cvt_inst->sourceType);\n-      dest_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n-    }\n-  else\n-    {\n-      switch (brig_inst.opcode)\n-\t{\n-\tcase BRIG_OPCODE_INITFBAR:\n-\tcase BRIG_OPCODE_JOINFBAR:\n-\tcase BRIG_OPCODE_WAITFBAR:\n-\tcase BRIG_OPCODE_ARRIVEFBAR:\n-\tcase BRIG_OPCODE_LEAVEFBAR:\n-\tcase BRIG_OPCODE_RELEASEFBAR:\n-\t  src_type = uint32_type_node;\n-\t  break;\n-\tdefault:\n-\t  src_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n-\t  break;\n-\t}\n-      dest_type = src_type;\n-      is_fp16_arith\n-\t= !gccbrig_is_bit_operation (brig_inst.opcode)\n-\t&& (brig_inst.type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16;\n-    }\n-\n-  /* Halfs are a tricky special case: their \"storage format\" is u16, but\n-     scalars are stored in 32b regs while packed f16 are... well packed.  */\n-  tree half_storage_type = element_count > 1\n-\t\t\t     ? gccbrig_tree_type_for_hsa_type (brig_inst.type)\n-\t\t\t     : uint32_type_node;\n-\n-  const BrigData *operand_entries\n-    = m_parent.get_brig_data_entry (brig_inst.operands);\n-  std::vector<tree> operands;\n-  for (size_t i = 0; i < operand_entries->byteCount / 4; ++i)\n-    {\n-      uint32_t operand_offset = ((const uint32_t *) &operand_entries->bytes)[i];\n-      const BrigBase *operand_data\n-\t= m_parent.get_brig_operand_entry (operand_offset);\n-\n-      const bool is_output\n-\t= gccbrig_hsa_opcode_op_output_p (brig_inst.opcode, i);\n-\n-      tree operand_type = is_output ? dest_type : src_type;\n-\n-      bool half_to_float = is_fp16_arith;\n-\n-      /* Special cases for operand types.  */\n-      if ((brig_inst.opcode == BRIG_OPCODE_SHL\n-\t   || brig_inst.opcode == BRIG_OPCODE_SHR)\n-\t  && i == 2)\n-\t  /* The shift amount is always a scalar.  */\n-\toperand_type\n-\t  = VECTOR_TYPE_P (src_type) ? TREE_TYPE (src_type) : src_type;\n-      else if (brig_inst.opcode == BRIG_OPCODE_SHUFFLE)\n-\t{\n-\t  if (i == 3)\n-\t    /* HSAIL shuffle inputs the MASK vector as tightly packed bits\n-\t       while GENERIC VEC_PERM_EXPR expects the mask elements to be\n-\t       of the same size as the elements in the input vectors.  Let's\n-\t       cast to a scalar type here and convert to the VEC_PERM_EXPR\n-\t       format in instruction handling.  There are no arbitrary bit\n-\t       width int types in GENERIC so we cannot use the original\n-\t       vector type.  */\n-\t    operand_type = uint32_type_node;\n-\t  else\n-\t    /* Always treat the element as unsigned ints to avoid\n-\t       sign extensions/negative offsets with masks, which\n-\t       are expected to be of the same element type as the\n-\t       data in VEC_PERM_EXPR.  With shuffles the data type\n-\t       should not matter as it's a \"raw operation\".  */\n-\t    operand_type = get_unsigned_int_type (operand_type);\n-\t}\n-      else if (brig_inst.opcode == BRIG_OPCODE_PACK)\n-\t{\n-\t  if (i == 1)\n-\t    operand_type = get_unsigned_int_type (dest_type);\n-\t  else if (i == 2)\n-\t    operand_type = get_unsigned_int_type (TREE_TYPE (dest_type));\n-\t  else if (i == 3)\n-\t    operand_type = uint32_type_node;\n-\t}\n-      else if (brig_inst.opcode == BRIG_OPCODE_UNPACK && i == 2)\n-\toperand_type = uint32_type_node;\n-      else if (brig_inst.opcode == BRIG_OPCODE_SAD && i == 3)\n-\toperand_type = uint32_type_node;\n-      else if (brig_inst.opcode == BRIG_OPCODE_CLASS && i == 2)\n-\t{\n-\t  operand_type = uint32_type_node;\n-\t  half_to_float = false;\n-\t}\n-      else if (brig_inst.opcode == BRIG_OPCODE_ACTIVELANEPERMUTE && i == 4)\n-\t{\n-\t  operand_type = uint32_type_node;\n-\t}\n-      else if (half_to_float)\n-\t/* Treat the operands as the storage type at this point.  */\n-\toperand_type = half_storage_type;\n-\n-      if (analyze)\n-\t{\n-\t  if (operand_data->kind == BRIG_KIND_OPERAND_REGISTER)\n-\t    {\n-\t      const BrigOperandRegister &brig_reg\n-\t\t= (const BrigOperandRegister &) *operand_data;\n-\t      m_parent.add_reg_used_as_type (brig_reg, operand_type);\n-\t    }\n-\t  continue;\n-\t}\n-\n-      tree operand = build_tree_operand (brig_inst, *operand_data, operand_type,\n-\t\t\t\t\t !is_output);\n-      gcc_assert (operand);\n-\n-      /* Cast/convert the inputs to correct types as expected by the GENERIC\n-\t opcode instruction.  */\n-      if (!is_output)\n-\t{\n-\t  if (half_to_float)\n-\t    operand = build_h2f_conversion\n-\t      (build_resize_convert_view (half_storage_type, operand));\n-\t  else if (TREE_CODE (operand) != LABEL_DECL\n-\t\t   && TREE_CODE (operand) != TREE_VEC\n-\t\t   && operand_data->kind != BRIG_KIND_OPERAND_ADDRESS\n-\t\t   && operand_data->kind != BRIG_KIND_OPERAND_OPERAND_LIST)\n-\t    {\n-\t      operand = build_resize_convert_view (operand_type, operand);\n-\t    }\n-\t  else if (brig_inst.opcode == BRIG_OPCODE_SHUFFLE)\n-\t    /* Force the operand type to be treated as the raw type.  */\n-\t    operand = build_resize_convert_view (operand_type, operand);\n-\n-\t  if (brig_inst.opcode == BRIG_OPCODE_CMOV && i == 1)\n-\t    {\n-\t      /* gcc expects the lower bit to be 1 (or all ones in case of\n-\t\t vectors) while CMOV assumes false iff 0.  Convert the input\n-\t\t here to what gcc likes by generating\n-\t\t 'operand = operand != 0'.  */\n-\t      tree cmp_res_type = get_comparison_result_type (operand_type);\n-\t      operand = build2 (NE_EXPR, cmp_res_type, operand,\n-\t\t\t\tbuild_zero_cst (TREE_TYPE (operand)));\n-\t    }\n-\n-\t  if (ftz)\n-\t    operand = flush_to_zero (is_fp16_arith) (*this, operand);\n-\t}\n-      operands.push_back (operand);\n-    }\n-  return operands;\n-}\n-\n-/* Build the GENERIC for assigning the result of an instruction to the result\n-   \"register\" (variable).  BRIG_INST is the original brig instruction,\n-   OUTPUT the result variable/register, INST_EXPR the one producing the\n-   result.  Required bitcasts and fp32 to fp16 conversions are added as\n-   well.  */\n-\n-tree\n-brig_code_entry_handler::build_output_assignment (const BrigInstBase &brig_inst,\n-\t\t\t\t\t\t  tree output, tree inst_expr)\n-{\n-  /* The result/input type might be different from the output register\n-     variable type (can be any type; see get_m_var_declfor_reg @\n-     brig-function.cc).  */\n-  tree output_type = TREE_TYPE (output);\n-  bool is_fp16 = (brig_inst.type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16\n-\t\t && brig_inst.base.kind != BRIG_KIND_INST_MEM\n-\t\t && !gccbrig_is_bit_operation (brig_inst.opcode);\n-\n-  /* Flush to zero.  */\n-  bool ftz = false;\n-  const BrigBase *base = &brig_inst.base;\n-\n-  if (m_parent.m_cf->is_id_val (inst_expr))\n-    inst_expr = m_parent.m_cf->id_val (inst_expr);\n-\n-  tree input_type = TREE_TYPE (inst_expr);\n-\n-  m_parent.m_cf->add_reg_var_update (output, inst_expr);\n-\n-  if (base->kind == BRIG_KIND_INST_MOD)\n-    {\n-      const BrigInstMod *mod = (const BrigInstMod *) base;\n-      ftz = mod->modifier & BRIG_ALU_FTZ;\n-    }\n-  else if (base->kind == BRIG_KIND_INST_CMP)\n-    {\n-      const BrigInstCmp *cmp = (const BrigInstCmp *) base;\n-      ftz = cmp->modifier & BRIG_ALU_FTZ;\n-    }\n-\n-  if (TREE_CODE (inst_expr) == CALL_EXPR)\n-    {\n-      tree func_decl = TREE_OPERAND (TREE_OPERAND (inst_expr, 1), 0);\n-      input_type = TREE_TYPE (TREE_TYPE (func_decl));\n-    }\n-\n-  if (ftz && (VECTOR_FLOAT_TYPE_P (TREE_TYPE (inst_expr))\n-\t      || SCALAR_FLOAT_TYPE_P (TREE_TYPE (inst_expr)) || is_fp16))\n-    {\n-      /* Ensure we don't duplicate the arithmetics to the arguments of the bit\n-\t field reference operators.  */\n-      inst_expr = m_parent.m_cf->add_temp_var (\"before_ftz\", inst_expr);\n-      inst_expr = flush_to_zero (is_fp16) (*this, inst_expr);\n-    }\n-\n-  if (is_fp16)\n-    {\n-      inst_expr = m_parent.m_cf->add_temp_var (\"before_f2h\", inst_expr);\n-      tree f2h_output = build_f2h_conversion (inst_expr);\n-      tree conv = build_resize_convert_view (output_type, f2h_output);\n-      tree assign = build2 (MODIFY_EXPR, output_type, output, conv);\n-      m_parent.m_cf->append_statement (assign);\n-      return assign;\n-    }\n-  else if (VECTOR_TYPE_P (output_type) && TREE_CODE (output) == CONSTRUCTOR)\n-    {\n-      /* Expand/unpack the input value to the given vector elements.  */\n-      size_t i;\n-      tree input = inst_expr;\n-      tree element_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n-      tree element;\n-      tree last_assign = NULL_TREE;\n-      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (output), i, element)\n-\t{\n-\t  tree element_ref\n-\t    = build3 (BIT_FIELD_REF, element_type, input,\n-\t\t      TYPE_SIZE (element_type),\n-\t\t      bitsize_int (i * int_size_in_bytes (element_type)\n-\t\t\t\t   *  BITS_PER_UNIT));\n-\n-\t  last_assign\n-\t    = build_output_assignment (brig_inst, element, element_ref);\n-\t}\n-      return last_assign;\n-    }\n-  else\n-    {\n-      /* All we do here is to bitcast the result and store it to the\n-\t 'register' (variable).  Mainly need to take care of differing\n-\t bitwidths.  */\n-      size_t src_width = int_size_in_bytes (input_type);\n-      size_t dst_width = int_size_in_bytes (output_type);\n-      tree input = inst_expr;\n-      /* Integer results are extended to the target register width, using\n-\t the same sign as the inst_expr.  */\n-      if (INTEGRAL_TYPE_P (TREE_TYPE (input)) && src_width != dst_width)\n-\t{\n-\t  bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (input));\n-\t  tree resized_type\n-\t    = build_nonstandard_integer_type (dst_width * BITS_PER_UNIT,\n-\t\t\t\t\t      unsigned_p);\n-\t  input = convert_to_integer (resized_type, input);\n-\t}\n-      input = build_resize_convert_view (output_type, input);\n-      tree assign = build2 (MODIFY_EXPR, output_type, output, input);\n-      m_parent.m_cf->append_statement (assign);\n-      return assign;\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Appends a GENERIC statement (STMT) to the currently constructed function.  */\n-\n-void\n-brig_code_entry_handler::append_statement (tree stmt)\n-{\n-  m_parent.m_cf->append_statement (stmt);\n-}\n-\n-/* Visits the element(s) in the OPERAND, calling HANDLER to each of them.  */\n-\n-tree\n-tree_element_unary_visitor::operator () (brig_code_entry_handler &handler,\n-\t\t\t\t\ttree operand)\n-{\n-  if (VECTOR_TYPE_P (TREE_TYPE (operand)))\n-    {\n-      size_t vec_size = int_size_in_bytes (TREE_TYPE (operand));\n-      size_t element_size = int_size_in_bytes (TREE_TYPE (TREE_TYPE (operand)));\n-      size_t element_count = vec_size / element_size;\n-\n-      tree input_element_type = TREE_TYPE (TREE_TYPE (operand));\n-      tree output_element_type = NULL_TREE;\n-\n-      vec<constructor_elt, va_gc> *constructor_vals = NULL;\n-      for (size_t i = 0; i < element_count; ++i)\n-\t{\n-\t  tree element = build3 (BIT_FIELD_REF, input_element_type, operand,\n-\t\t\t\t TYPE_SIZE (input_element_type),\n-\t\t\t\t bitsize_int (i * element_size\n-\t\t\t\t\t      * BITS_PER_UNIT));\n-\n-\t  tree output = visit_element (handler, element);\n-\t  output_element_type = TREE_TYPE (output);\n-\n-\t  CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, output);\n-\t}\n-\n-      tree vec_type = build_vector_type (output_element_type, element_count);\n-\n-      /* build_constructor creates a vector type which is not a vector_cst\n-\t that requires compile time constant elements.  */\n-      tree vec = build_constructor (vec_type, constructor_vals);\n-\n-      /* Add a temp variable for readability.  */\n-      tree tmp_var = create_tmp_var (vec_type, \"vec_out\");\n-      tree vec_tmp_assign\n-\t= build2 (MODIFY_EXPR, TREE_TYPE (tmp_var), tmp_var, vec);\n-      handler.append_statement (vec_tmp_assign);\n-      return tmp_var;\n-    }\n-  else\n-    return visit_element (handler, operand);\n-}\n-\n-/* Visits the element pair(s) in the OPERAND0 and OPERAND1, calling HANDLER\n-   to each of them.  */\n-\n-tree\n-tree_element_binary_visitor::operator () (brig_code_entry_handler &handler,\n-\t\t\t\t\t tree operand0, tree operand1)\n-{\n-  if (VECTOR_TYPE_P (TREE_TYPE (operand0)))\n-    {\n-      gcc_assert (VECTOR_TYPE_P (TREE_TYPE (operand1)));\n-      size_t vec_size = int_size_in_bytes (TREE_TYPE (operand0));\n-      size_t element_size\n-\t= int_size_in_bytes (TREE_TYPE (TREE_TYPE (operand0)));\n-      size_t element_count = vec_size / element_size;\n-\n-      tree input_element_type = TREE_TYPE (TREE_TYPE (operand0));\n-      tree output_element_type = NULL_TREE;\n-\n-      vec<constructor_elt, va_gc> *constructor_vals = NULL;\n-      for (size_t i = 0; i < element_count; ++i)\n-\t{\n-\n-\t  tree element0 = build3 (BIT_FIELD_REF, input_element_type, operand0,\n-\t\t\t\t  TYPE_SIZE (input_element_type),\n-\t\t\t\t  bitsize_int (i * element_size\n-\t\t\t\t\t       * BITS_PER_UNIT));\n-\n-\t  tree element1 = build3 (BIT_FIELD_REF, input_element_type, operand1,\n-\t\t\t\t  TYPE_SIZE (input_element_type),\n-\t\t\t\t  bitsize_int (i * element_size\n-\t\t\t\t\t       * BITS_PER_UNIT));\n-\n-\t  tree output = visit_element (handler, element0, element1);\n-\t  output_element_type = TREE_TYPE (output);\n-\n-\t  CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, output);\n-\t}\n-\n-      tree vec_type = build_vector_type (output_element_type, element_count);\n-\n-      /* build_constructor creates a vector type which is not a vector_cst\n-\t that requires compile time constant elements.  */\n-      tree vec = build_constructor (vec_type, constructor_vals);\n-\n-      /* Add a temp variable for readability.  */\n-      tree tmp_var = create_tmp_var (vec_type, \"vec_out\");\n-      tree vec_tmp_assign\n-\t= build2 (MODIFY_EXPR, TREE_TYPE (tmp_var), tmp_var, vec);\n-      handler.append_statement (vec_tmp_assign);\n-      return tmp_var;\n-    }\n-  else\n-    return visit_element (handler, operand0, operand1);\n-}\n-\n-/* Generates GENERIC code that flushes the visited element to zero.  */\n-\n-tree\n-flush_to_zero::visit_element (brig_code_entry_handler &, tree operand)\n-{\n-  size_t size = int_size_in_bytes (TREE_TYPE (operand));\n-  if (size == 4)\n-    {\n-      tree built_in\n-\t= (m_fp16) ? builtin_decl_explicit (BUILT_IN_HSAIL_FTZ_F32_F16) :\n-\tbuiltin_decl_explicit (BUILT_IN_HSAIL_FTZ_F32);\n-\n-      return call_builtin (built_in, 1, float_type_node, float_type_node,\n-\t\t\t   operand);\n-    }\n-  else if (size == 8)\n-    {\n-      return call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_FTZ_F64), 1,\n-\t\t\t   double_type_node, double_type_node, operand);\n-    }\n-  else\n-    gcc_unreachable ();\n-  return NULL_TREE;\n-}\n-\n-/* Generates GENERIC code that converts a single precision float to half\n-   precision float.  */\n-\n-tree\n-float_to_half::visit_element (brig_code_entry_handler &caller, tree operand)\n-{\n-  tree built_in = builtin_decl_explicit (BUILT_IN_HSAIL_F32_TO_F16);\n-\n-  tree casted_operand = build_resize_convert_view (uint32_type_node, operand);\n-\n-  tree call = call_builtin (built_in, 1, uint16_type_node, uint32_type_node,\n-\t\t\t    casted_operand);\n-  tree output\n-    = create_tmp_var (TREE_TYPE (TREE_TYPE (built_in)), \"fp16out\");\n-  tree assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, call);\n-  caller.append_statement (assign);\n-  return output;\n-}\n-\n-/* Generates GENERIC code that converts a half precision float to single\n-   precision float.  */\n-\n-tree\n-half_to_float::visit_element (brig_code_entry_handler &caller, tree operand)\n-{\n-  tree built_in = builtin_decl_explicit (BUILT_IN_HSAIL_F16_TO_F32);\n-  tree truncated_source = convert_to_integer (uint16_type_node, operand);\n-\n-  tree call\n-    = call_builtin (built_in, 1, uint32_type_node, uint16_type_node,\n-\t\t    truncated_source);\n-\n-  tree const_fp32_type\n-    = build_type_variant (brig_to_generic::s_fp32_type, 1, 0);\n-\n-  tree output = create_tmp_var (const_fp32_type, \"fp32out\");\n-  tree casted_result\n-    = build_resize_convert_view (brig_to_generic::s_fp32_type, call);\n-\n-  tree assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted_result);\n-\n-  caller.append_statement (assign);\n-\n-  return output;\n-}\n-\n-/* Treats the INPUT as SRC_TYPE and sign or zero extends it to DEST_TYPE.  */\n-\n-tree\n-brig_code_entry_handler::extend_int (tree input, tree dest_type, tree src_type)\n-{\n-  /* Extend integer conversions according to the destination's\n-     ext mode.  First we need to clip the input register to\n-     the possible smaller integer size to ensure the correct sign\n-     bit is extended.  */\n-  tree clipped_input = convert_to_integer (src_type, input);\n-  tree conversion_result;\n-\n-  if (TYPE_UNSIGNED (src_type))\n-    conversion_result\n-      = convert_to_integer (unsigned_type_for (dest_type), clipped_input);\n-  else\n-    conversion_result\n-      = convert_to_integer (signed_type_for (dest_type), clipped_input);\n-\n-  /* Treat the result as unsigned so we do not sign extend to the\n-     register width.  For some reason this GENERIC sequence sign\n-     extends to the s register:\n-\n-     D.1541 = (signed char) s1;\n-     D.1542 = (signed short) D.1541;\n-     s0 = (unsigned int) D.1542\n-  */\n-\n-  /* The converted result is then extended to the target register\n-     width, using the same sign as the destination.  */\n-  return convert_to_integer (dest_type, conversion_result);\n-}\n-\n-/* Returns the integer constant value of the given node.\n-   If it's a cast, looks into the source of the cast.  */\n-HOST_WIDE_INT\n-brig_code_entry_handler::int_constant_value (tree node)\n-{\n-  tree n = node;\n-  if (TREE_CODE (n) == VIEW_CONVERT_EXPR)\n-    n = TREE_OPERAND (n, 0);\n-  return int_cst_value (n);\n-}"}, {"sha": "e8308f779705be259fea6542e67ad4d88568e934", "filename": "gcc/brig/brigfrontend/brig-code-entry-handler.h", "status": "removed", "additions": 0, "deletions": 410, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,410 +0,0 @@\n-/* brig-code-entry-handler.h -- a gccbrig base class\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_BRIG_CODE_ENTRY_HANDLER_H\n-#define GCC_BRIG_CODE_ENTRY_HANDLER_H\n-\n-#include \"brig-to-generic.h\"\n-\n-#include <map>\n-#include <vector>\n-\n-class tree_element_unary_visitor;\n-\n-/* An interface to organize the different types of element handlers\n-   for the code section.  */\n-\n-class brig_code_entry_handler : public brig_entry_handler\n-{\n-public:\n-  brig_code_entry_handler (brig_to_generic &parent);\n-\n-  /* Handles the brig_code data at the given pointer and adds it to the\n-     currently built tree.  Returns the number of consumed bytes.  */\n-\n-  virtual size_t operator () (const BrigBase *base) = 0;\n-\n-  void append_statement (tree stmt);\n-\n-protected:\n-\n-  tree get_tree_expr_type_for_hsa_type (BrigType16_t brig_type) const;\n-  tree get_tree_cst_for_hsa_operand (const BrigOperandConstantBytes *brigConst,\n-\t\t\t\t     tree type) const;\n-  tree get_comparison_result_type (tree source_type);\n-\n-  tree build_code_ref (const BrigBase &ref);\n-\n-  tree build_tree_operand (const BrigInstBase &brig_inst,\n-\t\t\t   const BrigBase &operand,\n-\t\t\t   tree operand_type = NULL_TREE,\n-\t\t\t   bool is_input = false);\n-\n-  tree build_address_operand (const BrigInstBase &brig_inst,\n-\t\t\t      const BrigOperandAddress &addr_operand);\n-\n-  tree build_tree_operand_from_brig (const BrigInstBase *brig_inst,\n-\t\t\t\t     tree operand_type, size_t operand_index);\n-\n-  tree build_tree_cst_element (BrigType16_t element_type,\n-\t\t\t       const unsigned char *next_data) const;\n-\n-  bool needs_workitem_context_data (BrigOpcode16_t brig_opcode) const;\n-\n-  tree add_temp_var (std::string name, tree expr);\n-\n-  tree build_f2h_conversion (tree source);\n-  tree build_h2f_conversion (tree source);\n-\n-  tree_stl_vec build_operands (const BrigInstBase &brig_inst);\n-  void analyze_operands (const BrigInstBase &brig_inst);\n-  tree build_output_assignment (const BrigInstBase &brig_inst, tree output,\n-\t\t\t\ttree inst_expr);\n-\n-  tree apply_to_all_elements (tree_element_unary_visitor &visitor,\n-\t\t\t      tree operand);\n-\n-  HOST_WIDE_INT int_constant_value (tree node);\n-\n-  tree extend_int (tree input, tree dest_type, tree src_type);\n-\n-private:\n-\n-  tree_stl_vec build_or_analyze_operands (const BrigInstBase &brig_inst,\n-\t\t\t\t\t  bool analyze);\n-};\n-\n-/* Implement the Visitor software pattern for performing various actions on\n-   elements of vector operands.  This enables separating the vector element\n-   traversal/extraction/packing code from whatever different actions are\n-   performed to each element.  */\n-\n-class tree_element_unary_visitor\n-{\n-public:\n-  tree operator () (brig_code_entry_handler &handler, tree operand);\n-\n-  /* Performs an action to a single element, which can have originally\n-     been a vector element or a scalar.  */\n-\n-  virtual tree visit_element (brig_code_entry_handler &handler, tree operand)\n-    = 0;\n-};\n-\n-class tree_element_binary_visitor\n-{\n-public:\n-  tree operator () (brig_code_entry_handler &handler, tree operand0,\n-\t\t   tree operand1);\n-\n-  /* Performs an action to a pair of elements, which can have originally\n-     been a vector element or a scalar.  */\n-\n-  virtual tree visit_element (brig_code_entry_handler &handler, tree operand0,\n-\t\t\t      tree operand1)\n-    = 0;\n-};\n-\n-/* Visitor for flushing float elements to zero.  */\n-\n-class flush_to_zero : public tree_element_unary_visitor\n-{\n-public:\n-  flush_to_zero (bool fp16) : m_fp16 (fp16)\n-  {\n-  }\n-\n-  virtual tree visit_element (brig_code_entry_handler &caller, tree operand);\n-\n-private:\n-\n-  /* True if the value should be flushed according to fp16 limits.  */\n-\n-  bool m_fp16;\n-};\n-\n-/* Visitor for converting F16 elements to F32.  */\n-\n-class half_to_float : public tree_element_unary_visitor\n-{\n-public:\n-  virtual tree visit_element (brig_code_entry_handler &caller, tree operand);\n-};\n-\n-/* Visitor for converting F32 elements to F16.  */\n-\n-class float_to_half : public tree_element_unary_visitor\n-{\n-public:\n-  virtual tree visit_element (brig_code_entry_handler &caller, tree operand);\n-};\n-\n-/* A base class for instruction types that support floating point\n-   modifiers.\n-\n-   operator () delegates to subclasses (template method pattern) in\n-   type specific parts.  */\n-\n-class brig_inst_mod_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_inst_mod_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  virtual size_t generate (const BrigBase *base);\n-  virtual const BrigAluModifier8_t *modifier (const BrigBase *base) const;\n-  virtual const BrigRound8_t *round (const BrigBase *base) const;\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_directive_function_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_directive_function_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_directive_control_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_directive_control_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_directive_variable_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_directive_variable_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t operator () (const BrigBase *base);\n-\n-  tree build_variable (const BrigDirectiveVariable *brigVar,\n-\t\t       tree_code var_decltype = VAR_DECL);\n-\n-  size_t get_brig_var_alignment (const BrigDirectiveVariable *brigVar);\n-};\n-\n-class brig_directive_fbarrier_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_directive_fbarrier_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_directive_label_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_directive_label_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_directive_comment_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_directive_comment_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_directive_arg_block_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_directive_arg_block_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_basic_inst_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_basic_inst_handler (brig_to_generic &parent);\n-\n-  size_t operator () (const BrigBase *base);\n-\n-private:\n-  tree build_lower_element_broadcast (tree vec_operand);\n-\n-  bool must_be_scalarized (const BrigInstBase *brig_inst,\n-\t\t\t   tree instr_type) const;\n-\n-  tree build_inst_expr (BrigOpcode16_t brig_opcode, BrigType16_t brig_type,\n-\t\t\t tree arith_type, tree_stl_vec &operands);\n-\n-  tree build_shuffle (tree arith_type, tree_stl_vec &operands);\n-  tree build_unpack (tree_stl_vec &operands);\n-  tree build_pack (tree_stl_vec &operands);\n-\n-  tree build_unpack_lo_or_hi (BrigOpcode16_t brig_opcode, tree arith_type,\n-\t\t\t      tree_stl_vec &operands);\n-};\n-\n-class brig_cvt_inst_handler : public brig_inst_mod_handler\n-{\n-public:\n-  brig_cvt_inst_handler (brig_to_generic &parent)\n-    : brig_inst_mod_handler (parent)\n-  {\n-  }\n-\n-  virtual size_t generate (const BrigBase *base);\n-  virtual const BrigAluModifier8_t *modifier (const BrigBase *base) const;\n-  virtual const BrigRound8_t *round (const BrigBase *base) const;\n-};\n-\n-class brig_branch_inst_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_branch_inst_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_mem_inst_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_mem_inst_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t operator () (const BrigBase *base);\n-\n-private:\n-  tree build_mem_access (const BrigInstBase *brig_inst, tree addr, tree data);\n-};\n-\n-class brig_copy_move_inst_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_copy_move_inst_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t operator () (const BrigBase *base);\n-\n-private:\n-  size_t handle_lda (const BrigInstBase *base);\n-};\n-\n-class brig_atomic_inst_handler : public brig_code_entry_handler\n-{\n-private:\n-  typedef std::map<std::string, tree> atomic_builtins_map;\n-\n-public:\n-  brig_atomic_inst_handler (brig_to_generic &parent);\n-\n-  size_t operator () (const BrigBase *base);\n-\n-protected:\n-  size_t generate_tree (const BrigInstBase &inst,\n-\t\t\tBrigAtomicOperation8_t atomic_opcode);\n-};\n-\n-class brig_signal_inst_handler : public brig_atomic_inst_handler\n-{\n-public:\n-  brig_signal_inst_handler (brig_to_generic &parent)\n-    : brig_atomic_inst_handler (parent)\n-  {\n-  }\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_cmp_inst_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_cmp_inst_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_seg_inst_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_seg_inst_handler (brig_to_generic &parent);\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_lane_inst_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_lane_inst_handler (brig_to_generic &parent);\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_queue_inst_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_queue_inst_handler (brig_to_generic &parent);\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-class brig_directive_module_handler : public brig_code_entry_handler\n-{\n-public:\n-  brig_directive_module_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t operator () (const BrigBase *base);\n-};\n-\n-\n-#endif"}, {"sha": "b20e66f390c42a8bebfa3b0cee8d8851fa0c8bd0", "filename": "gcc/brig/brigfrontend/brig-comment-handler.cc", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-comment-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-comment-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-comment-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,38 +0,0 @@\n-/* brig-comment-handler.cc -- brig comment directive handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-\n-extern int gccbrig_verbose;\n-\n-size_t\n-brig_directive_comment_handler::operator () (const BrigBase *base)\n-{\n-  const BrigDirectiveComment *brig_comment\n-    = (const BrigDirectiveComment *) base;\n-\n-  if (gccbrig_verbose)\n-    {\n-      std::string cmnt = m_parent.get_string (brig_comment->name);\n-      fprintf (stderr, \"brig: Comment: '%s'\\n\", cmnt.c_str());\n-    }\n-  return base->byteCount;\n-}"}, {"sha": "3fdf3b53470b65740e4395c76ab75dd763731132", "filename": "gcc/brig/brigfrontend/brig-control-handler.cc", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-control-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-control-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-control-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,108 +0,0 @@\n-/* brig-control-handler.cc -- brig control directive handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-#include \"diagnostic.h\"\n-#include \"print-tree.h\"\n-\n-size_t\n-brig_directive_control_handler::operator () (const BrigBase *base)\n-{\n-  const BrigDirectiveControl *inst = (const BrigDirectiveControl *) base;\n-  const BrigData *operand_entries\n-    = m_parent.get_brig_data_entry (inst->operands);\n-\n-  /* Parse the constant integer operands.  */\n-  std::vector<tree> operands;\n-  for (size_t i = 0; i < operand_entries->byteCount / 4; ++i)\n-    {\n-      uint32_t operand_offset\n-\t= ((const uint32_t *) &operand_entries->bytes)[i];\n-      const BrigBase *operand_data\n-\t= m_parent.get_brig_operand_entry (operand_offset);\n-\n-      tree operand_type\n-\t= (inst->control == BRIG_CONTROL_REQUIREDGRIDSIZE\n-\t   || inst->control == BRIG_CONTROL_MAXFLATGRIDSIZE) ?\n-\tuint64_type_node : uint32_type_node;\n-      operands.push_back\n-\t(build_tree_operand (*(const BrigInstBase*)inst, *operand_data,\n-\t\t\t     operand_type));\n-    }\n-\n-  switch (inst->control)\n-    {\n-    case BRIG_CONTROL_MAXDYNAMICGROUPSIZE:\n-      {\n-\tm_parent.m_cf->m_descriptor.max_dynamic_group_size\n-\t  = brig_function::int_constant_value (operands.at (0));\n-\tbreak;\n-      }\n-    case BRIG_CONTROL_MAXFLATGRIDSIZE:\n-      {\n-\tm_parent.m_cf->m_descriptor.max_flat_grid_size\n-\t  = brig_function::int_constant_value (operands.at (0));\n-\tbreak;\n-      }\n-    case BRIG_CONTROL_MAXFLATWORKGROUPSIZE:\n-      {\n-\tm_parent.m_cf->m_descriptor.max_flat_workgroup_size\n-\t  = brig_function::int_constant_value (operands.at (0));\n-\tbreak;\n-      }\n-    case BRIG_CONTROL_REQUIREDDIM:\n-      {\n-\tm_parent.m_cf->m_descriptor.required_dim\n-\t  = brig_function::int_constant_value (operands.at (0));\n-\tbreak;\n-      }\n-    case BRIG_CONTROL_REQUIREDGRIDSIZE:\n-      {\n-\tm_parent.m_cf->m_descriptor.required_grid_size[0]\n-\t  = brig_function::int_constant_value (operands.at (0));\n-\tm_parent.m_cf->m_descriptor.required_grid_size[1]\n-\t  = brig_function::int_constant_value (operands.at (1));\n-\tm_parent.m_cf->m_descriptor.required_grid_size[2]\n-\t  = brig_function::int_constant_value (operands.at (2));\n-\tbreak;\n-      }\n-    case BRIG_CONTROL_REQUIREDWORKGROUPSIZE:\n-      {\n-\tm_parent.m_cf->m_descriptor.required_workgroup_size[0]\n-\t  = brig_function::int_constant_value (operands.at (0));\n-\tm_parent.m_cf->m_descriptor.required_workgroup_size[1]\n-\t  = brig_function::int_constant_value (operands.at (1));\n-\tm_parent.m_cf->m_descriptor.required_workgroup_size[2]\n-\t  = brig_function::int_constant_value (operands.at (2));\n-\tbreak;\n-      }\n-    case BRIG_CONTROL_REQUIRENOPARTIALWORKGROUPS:\n-      /* Performance hint only, ignored for now.  */\n-      break;\n-    case BRIG_CONTROL_ENABLEBREAKEXCEPTIONS:\n-    case BRIG_CONTROL_ENABLEDETECTEXCEPTIONS:\n-      /* Unimplemented.  */\n-      break;\n-    default:\n-      sorry (\"Unsupported control directive %x.\", inst->control);\n-    }\n-  return base->byteCount;\n-}"}, {"sha": "121a947b4181a872b9778acaa39f51096c5cd1c4", "filename": "gcc/brig/brigfrontend/brig-copy-move-inst-handler.cc", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-copy-move-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-copy-move-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-copy-move-inst-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,73 +0,0 @@\n-/* brig-copy-move-inst-handler.cc -- brig copy/move instruction handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"print-tree.h\"\n-#include \"errors.h\"\n-#include \"brig-util.h\"\n-\n-size_t\n-brig_copy_move_inst_handler::handle_lda (const BrigInstBase *brig_inst)\n-{\n-  tree dest_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n-\n-  tree input = build_tree_operand_from_brig (brig_inst, NULL, 1);\n-  tree output = build_tree_operand_from_brig (brig_inst, dest_type, 0);\n-\n-  build_output_assignment (*brig_inst, output, input);\n-  return brig_inst->base.byteCount;\n-}\n-\n-size_t\n-brig_copy_move_inst_handler::operator () (const BrigBase *base)\n-{\n-  const BrigInstBase *brig_inst\n-    = (const BrigInstBase *) &((const BrigInstBasic *) base)->base;\n-\n-  if (brig_inst->opcode == BRIG_OPCODE_LDA)\n-    return handle_lda (brig_inst);\n-\n-  const BrigInstSourceType *inst_src_type = (const BrigInstSourceType *) base;\n-\n-  tree source_type = gccbrig_tree_type_for_hsa_type (inst_src_type->sourceType);\n-  tree dest_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n-\n-  tree input = build_tree_operand_from_brig (brig_inst, source_type, 1);\n-  tree output = build_tree_operand_from_brig (brig_inst, dest_type, 0);\n-\n-  if (brig_inst->opcode == BRIG_OPCODE_COMBINE)\n-    {\n-      /* For combine, a simple reinterpret cast from the array constructor\n-\t works.  */\n-      tree casted = build_resize_convert_view (TREE_TYPE (output), input);\n-      tree assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted);\n-      m_parent.m_cf->append_statement (assign);\n-    }\n-  else if (brig_inst->opcode == BRIG_OPCODE_EXPAND)\n-    build_output_assignment (*brig_inst, output, input);\n-  else\n-    {\n-      brig_basic_inst_handler basic (m_parent);\n-      return basic (base);\n-    }\n-  return base->byteCount;\n-}"}, {"sha": "319128dbfd1640a4097a421f01fae514c879592a", "filename": "gcc/brig/brigfrontend/brig-cvt-inst-handler.cc", "status": "removed", "additions": 0, "deletions": 268, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,268 +0,0 @@\n-/* brig-cvt-inst-handler.cc -- brig cvt (convert) instruction handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <sstream>\n-\n-#include \"brig-code-entry-handler.h\"\n-\n-#include \"gimple-expr.h\"\n-#include \"errors.h\"\n-#include \"convert.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"print-tree.h\"\n-#include \"diagnostic-core.h\"\n-#include \"brig-util.h\"\n-\n-const BrigAluModifier8_t *\n-brig_cvt_inst_handler::modifier (const BrigBase *base) const\n-{\n-  const BrigInstCvt *inst = (const BrigInstCvt *) base;\n-  return &inst->modifier;\n-}\n-\n-const BrigRound8_t *\n-brig_cvt_inst_handler::round (const BrigBase *base) const\n-{\n-  const BrigInstCvt *inst = (const BrigInstCvt *) base;\n-  return &inst->round;\n-}\n-\n-size_t\n-brig_cvt_inst_handler::generate (const BrigBase *base)\n-{\n-  /* In cvt instructions there can be at least four data types involved:\n-\n-     - the input register type\n-     - the output register type\n-     - the conversion source type\n-     - the conversion destination type\n-  */\n-\n-  const BrigInstBase *brig_inst\n-    = (const BrigInstBase *) &((const BrigInstBasic *) base)->base;\n-  const BrigInstCvt *cvt_inst = (const BrigInstCvt *) base;\n-\n-  const BrigAluModifier8_t *inst_modifier = modifier (base);\n-  const bool FTZ = inst_modifier != NULL && (*inst_modifier) & BRIG_ALU_FTZ;\n-\n-  /* The conversion source type.  */\n-  tree src_type = get_tree_expr_type_for_hsa_type (cvt_inst->sourceType);\n-\n-  bool src_is_fp16 = cvt_inst->sourceType == BRIG_TYPE_F16;\n-\n-  /* The conversion destination type.  */\n-  tree dest_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n-\n-  bool dest_is_fp16 = brig_inst->type == BRIG_TYPE_F16;\n-\n-  if (!dest_type || !src_type)\n-    {\n-      gcc_unreachable ();\n-      return base->byteCount;\n-    }\n-\n-  tree_stl_vec operands = build_operands (*brig_inst);\n-  tree &input = operands.at (1);\n-  tree &output = operands.at (0);\n-\n-  if (m_parent.m_cf->is_id_val (input))\n-    {\n-      input = m_parent.m_cf->id_val (input);\n-      src_type = TREE_TYPE (input);\n-    }\n-\n-  size_t conv_src_size = int_size_in_bytes (src_type);\n-  size_t conv_dst_size = int_size_in_bytes (dest_type);\n-  size_t src_reg_size = int_size_in_bytes (TREE_TYPE (input));\n-\n-  /* The input register can be of different type&size than the\n-     conversion input size.  First cast the input to the conversion\n-     input type.  These casts are always bitcasts which can be\n-     expressed as casts between different unsigned integers.  */\n-  if (src_reg_size != conv_src_size)\n-    {\n-      tree unsigned_int_type = NULL_TREE;\n-      if (INTEGRAL_TYPE_P (src_type))\n-\tunsigned_int_type = unsigned_type_for (src_type);\n-      else /* Find a matching size int type for the REAL type.  */\n-\t{\n-\t  if (conv_src_size == 2)\n-\t    unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U16);\n-\t  else if (conv_src_size == 4)\n-\t    unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U32);\n-\t  else if (conv_src_size == 8)\n-\t    unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U64);\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-      input = convert_to_integer (unsigned_int_type, input);\n-    }\n-\n-  if (src_is_fp16)\n-    input = build_h2f_conversion (input);\n-\n-  /* Flush the float operand to zero if indicated with 'ftz'.  */\n-  if (FTZ && SCALAR_FLOAT_TYPE_P (src_type))\n-    {\n-      tree casted_input = build_resize_convert_view (src_type, input);\n-      input = flush_to_zero (src_is_fp16) (*this, casted_input);\n-    }\n-\n-  tree conversion_result = NULL_TREE;\n-  if (brig_inst->type == BRIG_TYPE_B1)\n-    {\n-      /* When the destination is b1, cvt does a 'ztest' operation which is\n-\t defined as a != 0 for integers and similarly (!= 0.0f) for floats.  */\n-      if (INTEGRAL_TYPE_P (src_type))\n-\t{\n-\t  /* Generate an integer not equal operation.  */\n-\t  conversion_result = build2 (NE_EXPR, TREE_TYPE (input), input,\n-\t\t\t\t      build_int_cst (TREE_TYPE (input), 0));\n-\t}\n-      else\n-\t{\n-\t  /* For REAL source types, ztest returns 1 if the value is not +- 0.0f.\n-\t     We can perform this check with an integer comparison after\n-\t     masking away the sign bit from a correct position.  This is safer\n-\t     than using absf because of exceptions in case of a NaN\n-\t     input (NaN exceptions are not generated with cvt).  */\n-\t  tree unsigned_int_type = NULL_TREE;\n-\t  /* Bit battern with all but the upper bit 1.  */\n-\t  tree and_mask = NULL_TREE;\n-\t  if (conv_src_size == 2)\n-\t    {\n-\t      unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U16);\n-\t      and_mask = build_int_cst (unsigned_int_type, 0x7FFF);\n-\t    }\n-\t  else if (conv_src_size == 4)\n-\t    {\n-\t      unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U32);\n-\t      and_mask = build_int_cst (unsigned_int_type, 0x7FFFFFFF);\n-\t    }\n-\t  else if (conv_src_size == 8)\n-\t    {\n-\t      unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U64);\n-\t      and_mask = build_int_cst (unsigned_int_type, 0x7FFFFFFFFFFFFFFF);\n-\t    }\n-\t  else\n-\t    gcc_unreachable ();\n-\t  tree casted_input = build_resize_convert_view (unsigned_int_type,\n-\t\t\t\t\t\t\t input);\n-\t  tree masked_input\n-\t    = build2 (BIT_AND_EXPR, unsigned_int_type, casted_input, and_mask);\n-\t  conversion_result\n-\t    = build2 (NE_EXPR, TREE_TYPE (masked_input), masked_input,\n-\t\t      build_int_cst (unsigned_int_type, 0));\n-\t}\n-      /* The result from the comparison is a boolean, convert it to such.  */\n-      conversion_result\n-\t= convert_to_integer (gccbrig_tree_type_for_hsa_type (BRIG_TYPE_B1),\n-\t\t\t      conversion_result);\n-    }\n-  else if (dest_is_fp16)\n-    {\n-      tree casted_input = build_resize_convert_view (src_type, input);\n-      conversion_result\n-\t= convert_to_real (brig_to_generic::s_fp32_type, casted_input);\n-      if (FTZ)\n-\tconversion_result = flush_to_zero (true) (*this, conversion_result);\n-      conversion_result = build_f2h_conversion (conversion_result);\n-    }\n-  else if (SCALAR_FLOAT_TYPE_P (dest_type))\n-    {\n-      tree casted_input = build_resize_convert_view (src_type, input);\n-      conversion_result = convert_to_real (dest_type, casted_input);\n-    }\n-  else if (INTEGRAL_TYPE_P (dest_type) && INTEGRAL_TYPE_P (src_type))\n-    {\n-      conversion_result = extend_int (input, dest_type, src_type);\n-    }\n-  else if (INTEGRAL_TYPE_P (dest_type) && SCALAR_FLOAT_TYPE_P (src_type))\n-    {\n-\n-      if (cvt_inst->round == BRIG_ROUND_INTEGER_ZERO_SAT)\n-\t{\n-\n-\t  /* Use builtins for the saturating conversions.  */\n-#undef DEF_HSAIL_SAT_BUILTIN\n-#undef DEF_HSAIL_BUILTIN\n-#undef DEF_HSAIL_ATOMIC_BUILTIN\n-#undef DEF_HSAIL_INTR_BUILTIN\n-#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n-\n-\t  tree builtin = NULL_TREE;\n-\t  BrigType16_t src_arith_type\n-\t    = src_is_fp16\n-\t    ? (BrigType16_t) BRIG_TYPE_F32 : cvt_inst->sourceType;\n-#define DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN(ENUM, HSAIL_DST_TYPE, HSAIL_SRC_TYPE, \\\n-\t\t\t\t\tNAME, TYPE, ATTRS)\t\t\\\n-\t  if (brig_inst->type == HSAIL_DST_TYPE\t\t\t\t\\\n-\t      && src_arith_type == HSAIL_SRC_TYPE)\t\t\\\n-\t    builtin = builtin_decl_explicit (ENUM);\t\t\t\\\n-\t  else\n-#include \"brig-builtins.def\"\n-\t    gcc_unreachable ();\n-\n-\t  tree casted_input = build_resize_convert_view (src_type, input);\n-\t  conversion_result\n-\t    = call_builtin (builtin, 1, dest_type, src_type, casted_input);\n-\t}\n-      else\n-\t{\n-\t  tree casted_input = build_resize_convert_view (src_type, input);\n-\n-\t  /* Perform the float to int conversion.  */\n-\t  conversion_result = convert_to_integer (dest_type, casted_input);\n-\t}\n-    }\n-  else\n-    {\n-      /* Just use CONVERT_EXPR and hope for the best.  */\n-      tree casted_input = build_resize_convert_view (dest_type, input);\n-      conversion_result = build1 (CONVERT_EXPR, dest_type, casted_input);\n-    }\n-\n-  size_t dst_reg_size = int_size_in_bytes (TREE_TYPE (output));\n-\n-  /* The output register can be of different type&size than the\n-     conversion output size. Only need to handle signed integers, rest\n-     is handled by reinterpret_cast.  */\n-  tree casted_output = conversion_result;\n-  if (dst_reg_size > conv_dst_size &&\n-      INTEGRAL_TYPE_P (TREE_TYPE (casted_output)))\n-    {\n-      gcc_assert (!VECTOR_TYPE_P (casted_output));\n-\n-      bool unsignedp = TYPE_UNSIGNED (TREE_TYPE (casted_output));\n-      tree resized_int_type\n-        = build_nonstandard_integer_type (dst_reg_size * BITS_PER_UNIT,\n-\t\t\t\t\t  unsignedp);\n-      casted_output = build1 (CONVERT_EXPR, resized_int_type, casted_output);\n-    }\n-\n-  casted_output\n-    = build_resize_convert_view (TREE_TYPE (output), casted_output);\n-  tree assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted_output);\n-\n-  m_parent.m_cf->append_statement (assign);\n-\n-  return base->byteCount;\n-}"}, {"sha": "b29768b8541c2628c5b41069178630df9f48716c", "filename": "gcc/brig/brigfrontend/brig-fbarrier-handler.cc", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-fbarrier-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-fbarrier-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-fbarrier-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,45 +0,0 @@\n-/* brig-fbarrier-handler.cc -- brig fbarrier directive handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-\n-#include \"stringpool.h\"\n-#include \"errors.h\"\n-\n-/* Allocate this many bytes from the group segment for each fbarrier.  */\n-#define FBARRIER_STRUCT_SIZE 32\n-\n-size_t\n-brig_directive_fbarrier_handler::operator () (const BrigBase *base)\n-{\n-  /* Model fbarriers as group segment variables with fixed size\n-     large enough to store whatever data the actual target needs\n-     to store to maintain the barrier info.  The handle is the\n-     offset to the beginning of the object.  */\n-\n-  const BrigDirectiveFbarrier* fbar = (const BrigDirectiveFbarrier*)base;\n-  if (m_parent.m_cf != NULL)\n-    m_parent.m_cf->m_function_scope_vars.insert (base);\n-  std::string var_name = m_parent.get_mangled_name (fbar);\n-  m_parent.add_group_variable (var_name, FBARRIER_STRUCT_SIZE, 1,\n-\t\t\t       m_parent.m_cf != NULL);\n-  return base->byteCount;\n-}"}, {"sha": "d860bc59cbc0f049e8651ae2a529e2e42ff3e9b7", "filename": "gcc/brig/brigfrontend/brig-function-handler.cc", "status": "removed", "additions": 0, "deletions": 431, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,431 +0,0 @@\n-/* brig-code-entry-handler.cc -- brig function directive handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <sstream>\n-#include <iomanip>\n-\n-#include \"brig-code-entry-handler.h\"\n-\n-#include \"brig-machine.h\"\n-#include \"stringpool.h\"\n-#include \"tree-iterator.h\"\n-#include \"gimple-expr.h\"\n-#include \"function.h\"\n-#include \"phsa.h\"\n-\n-#include \"tree-pretty-print.h\"\n-#include \"print-tree.h\"\n-\n-extern int gccbrig_verbose;\n-\n-size_t\n-brig_directive_function_handler::operator () (const BrigBase *base)\n-{\n-  if (!m_parent.m_analyzing)\n-    m_parent.finish_function ();\n-\n-  size_t bytes_consumed = base->byteCount;\n-\n-  const BrigDirectiveExecutable *exec = (const BrigDirectiveExecutable *) base;\n-\n-  if (gccbrig_verbose)\n-    {\n-      printf (\"brig: function name %s\\n\",\n-\t      m_parent.get_string (exec->name).c_str());\n-      printf (\"brig: inargs %d outargs %d name offset %d\\n\", exec->inArgCount,\n-\t      exec->outArgCount, exec->name);\n-    }\n-\n-  const bool is_definition\n-    = exec->modifier & BRIG_EXECUTABLE_DEFINITION;\n-\n-  const bool is_kernel = base->kind == BRIG_KIND_DIRECTIVE_KERNEL;\n-\n-  /* There doesn't seem to be actual use cases for kernel declarations\n-     as they cannot be called by the program.  Ignore them until there's\n-     a reason not to.  */\n-  if (is_kernel && !is_definition)\n-    return bytes_consumed;\n-\n-  std::string func_name = m_parent.get_mangled_name (exec);\n-  if (is_kernel)\n-    /* The generated kernel function is not the one that should be\n-       called by the host.  */\n-    func_name = std::string (\"_\") + func_name;\n-\n-  m_parent.m_cf = new brig_function (exec, &m_parent);\n-  m_parent.m_cf->m_name = func_name;\n-  m_parent.m_cf->m_is_kernel = is_kernel;\n-\n-  /* During the analyze step, the above information is all we need per\n-     function.  */\n-  if (m_parent.m_analyzing)\n-    return bytes_consumed;\n-\n-  /* There can be multiple forward declarations of the same function.\n-     Skip all but the first one.  */\n-  if (!is_definition && m_parent.function_decl (func_name) != NULL_TREE)\n-    return bytes_consumed;\n-  tree fndecl;\n-  tree ret_value = NULL_TREE;\n-\n-  tree stmt_list = alloc_stmt_list ();\n-\n-  /* Add a function scope BIND_EXPR using which we can push local variables that\n-     represent HSAIL registers.  */\n-  tree bind_expr = build3 (BIND_EXPR, void_type_node, NULL, stmt_list, NULL);\n-\n-  tree restrict_char_ptr\n-    = build_qualified_type (build_pointer_type (char_type_node),\n-\t\t\t    TYPE_QUAL_RESTRICT);\n-  tree restrict_void_ptr\n-    = build_qualified_type (build_pointer_type (void_type_node),\n-\t\t\t    TYPE_QUAL_RESTRICT);\n-\n-  tree restrict_const_char_ptr\n-    = build_qualified_type (build_pointer_type\n-\t\t\t    (build_qualified_type (char_type_node,\n-\t\t\t\t\t\t   TYPE_QUAL_CONST)),\n-\t\t\t    TYPE_QUAL_RESTRICT);\n-\n-  tree restrict_const_void_ptr\n-    = build_qualified_type (build_pointer_type\n-\t\t\t    (build_qualified_type (void_type_node,\n-\t\t\t\t\t\t   TYPE_QUAL_CONST)),\n-\t\t\t    TYPE_QUAL_RESTRICT);\n-\n-  if (is_kernel)\n-    {\n-      tree name_identifier\n-\t= get_identifier_with_length (func_name.c_str (), func_name.size ());\n-\n-      /* The generated kernel functions take the following arguments:\n-\n-\t 1) a char* which is a starting address of the argument segment where\n-\t the call's arguments are stored by the launcher.\n-\t 2) a void* parameter that points to a phsail-finalizer context object\n-\t which passes the hsa kernel packet etc.\n-\t 3) a void* parameter that contains the first flat address of the group\n-\t region allocated to the current work-group.  */\n-\n-      fndecl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, name_identifier,\n-\t\t\t   build_function_type_list (void_type_node,\n-\t\t\t\t\t\t     restrict_const_char_ptr,\n-\t\t\t\t\t\t     restrict_void_ptr,\n-\t\t\t\t\t\t     restrict_char_ptr, NULL_TREE));\n-\n-      SET_DECL_ASSEMBLER_NAME (fndecl, name_identifier);\n-\n-      tree resdecl\n-\t= build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, void_type_node);\n-\n-      tree typelist = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-      tree argtype = TREE_VALUE (typelist);\n-      TYPE_ADDR_SPACE (argtype)\n-\t= gccbrig_get_target_addr_space_id (BRIG_SEGMENT_KERNARG);\n-\n-      tree arg_arg = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t\t\t get_identifier (\"__args\"),\n-\t\t\t\t restrict_const_char_ptr);\n-      DECL_ARGUMENTS (fndecl) = arg_arg;\n-      DECL_ARG_TYPE (arg_arg) = restrict_const_char_ptr;\n-      DECL_CONTEXT (arg_arg) = fndecl;\n-      DECL_ARTIFICIAL (arg_arg) = 1;\n-      TREE_READONLY (arg_arg) = 1;\n-      TREE_USED (arg_arg) = 1;\n-\n-      DECL_RESULT (fndecl) = resdecl;\n-      DECL_CONTEXT (resdecl) = fndecl;\n-      DECL_EXTERNAL (fndecl) = 0;\n-\n-      /* Aggressive inlining to the kernel function is usually a good\n-\t idea with offlined functionality to enchance SIMD execution on\n-\t GPUs and vector units.  */\n-\n-      DECL_ATTRIBUTES (fndecl)\n-\t= tree_cons (get_identifier (\"flatten\"), NULL,\n-\t\t     DECL_ATTRIBUTES (fndecl));\n-    }\n-  else\n-    {\n-      /* Build a regular function fingerprint to enable targets to optimize\n-\t the calling convention as they see fit.  */\n-      tree name_identifier\n-\t= get_identifier_with_length (func_name.c_str (), func_name.size ());\n-\n-      m_parent.m_cf->m_arg_variables.clear ();\n-\n-      brig_directive_variable_handler arg_handler (m_parent);\n-\n-      vec<tree, va_gc> *args;\n-      vec_alloc (args, 4);\n-\n-      tree arg_decls = NULL_TREE;\n-\n-      tree ret_type = void_type_node;\n-      if (exec->outArgCount == 1)\n-\t{\n-\t  /* The return value variable should be the first entry after the\n-\t     function directive.  */\n-\t  const BrigBase *retval\n-\t    = (const BrigBase *) ((const char *) base + base->byteCount);\n-\t  gcc_assert (retval->kind == BRIG_KIND_DIRECTIVE_VARIABLE);\n-\n-\t  const BrigDirectiveVariable *brigVar\n-\t    = (const BrigDirectiveVariable *) retval;\n-\n-\t  brig_directive_variable_handler varhandler (m_parent);\n-\n-\t  if (brigVar->type & BRIG_TYPE_ARRAY)\n-\t    {\n-\t      /* Push array output arguments to the beginning of the\n-\t\t function argument list instead of regular function\n-\t\t return values.  */\n-\n-\t      tree arg_var = varhandler.build_variable (brigVar, PARM_DECL);\n-\t      vec_safe_push (args, TREE_TYPE (arg_var));\n-\n-\t      m_parent.m_cf->add_arg_variable (brigVar, arg_var);\n-\n-\t      if (arg_decls == NULL_TREE)\n-\t\targ_decls = arg_var;\n-\t      else\n-\t\targ_decls = chainon (arg_decls, arg_var);\n-\n-\t      m_parent.m_cf->add_arg_variable (brigVar, arg_var);\n-\n-\t      ret_value = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE,\n-\t\t\t\t      void_type_node);\n-\t    }\n-\t  else\n-\t    {\n-\t      ret_value = varhandler.build_variable (brigVar, RESULT_DECL);\n-\t      m_parent.m_cf->m_ret_value = ret_value;\n-\t      ret_type = TREE_TYPE (ret_value);\n-\t      m_parent.m_cf->m_ret_value_brig_var = brigVar;\n-\t    }\n-\t  bytes_consumed += retval->byteCount;\n-\t}\n-      else\n-\tret_value = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE,\n-\t\t\t\tvoid_type_node);\n-\n-      TREE_ADDRESSABLE (ret_value) = 1;\n-\n-      if (exec->inArgCount > 0)\n-\t{\n-\t  uint32_t arg_offset = exec->firstInArg;\n-\t  for (size_t arg = 0; arg < exec->inArgCount; ++arg)\n-\t    {\n-\n-\t      const BrigDirectiveVariable *brigVar\n-\t\t= (const BrigDirectiveVariable *) m_parent.get_brig_code_entry\n-\t\t(arg_offset);\n-\n-\t      gcc_assert (brigVar->base.kind == BRIG_KIND_DIRECTIVE_VARIABLE);\n-\n-\t      /* Delegate to the brig_directive_variable_handler.  */\n-\t      brig_directive_variable_handler varhandler (m_parent);\n-\t      tree arg_var = varhandler.build_variable (brigVar, PARM_DECL);\n-\t      arg_offset += brigVar->base.byteCount;\n-\t      vec_safe_push (args, TREE_TYPE (arg_var));\n-\n-\t      m_parent.m_cf->add_arg_variable (brigVar, arg_var);\n-\t      arg_decls = chainon (arg_decls, arg_var);\n-\t    }\n-\t}\n-      vec_safe_push (args, restrict_void_ptr);\n-      vec_safe_push (args, restrict_char_ptr);\n-      vec_safe_push (args, uint32_type_node);\n-      vec_safe_push (args, restrict_char_ptr);\n-\n-      fndecl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, name_identifier,\n-\t\t\t   build_function_type_vec (ret_type, args));\n-\n-      DECL_RESULT (fndecl) = ret_value;\n-      DECL_CONTEXT (ret_value) = fndecl;\n-      DECL_EXTERNAL (fndecl) = 0;\n-      DECL_ARGUMENTS (fndecl) = arg_decls;\n-    }\n-\n-  /* All functions need the hidden __context argument passed on\n-     because they might call WI-specific functions which need\n-     the context info.  Only kernels can write it, if they need\n-     to update the local ids in the work-item loop.  */\n-\n-  tree context_arg_type\n-    = true ? restrict_void_ptr : restrict_const_void_ptr;\n-  tree context_arg = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t\t\t get_identifier (\"__context\"),\n-\t\t\t\t context_arg_type);\n-  DECL_ARGUMENTS (fndecl) = chainon (DECL_ARGUMENTS (fndecl), context_arg);\n-  DECL_CONTEXT (context_arg) = fndecl;\n-  DECL_ARG_TYPE (context_arg) = context_arg_type;\n-  DECL_ARTIFICIAL (context_arg) = 1;\n-  TREE_READONLY (context_arg) = 1;\n-  TREE_USED (context_arg) = 1;\n-  m_parent.m_cf->m_context_arg = context_arg;\n-\n-  /* They can also access group memory, so we need to pass the\n-     group pointer along too.  */\n-  tree group_base_arg\n-    = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t  get_identifier (\"__group_base_addr\"),\n-\t\t  restrict_char_ptr);\n-  DECL_ARGUMENTS (fndecl) = chainon (DECL_ARGUMENTS (fndecl), group_base_arg);\n-  DECL_ARG_TYPE (group_base_arg) = restrict_char_ptr;\n-  DECL_CONTEXT (group_base_arg) = fndecl;\n-  DECL_ARTIFICIAL (group_base_arg) = 1;\n-  TREE_READONLY (group_base_arg) = 1;\n-  TREE_USED (group_base_arg) = 1;\n-  m_parent.m_cf->m_group_base_arg = group_base_arg;\n-\n-  /* To implement call stack and (non-kernel) function scope group variables,\n-     we need to pass an offset which describes how far are we from\n-     group_base_ptr.\n-     That must be substracted from any function local group variable offsets to\n-     get the address related to the bottom of the group memory chunk.  */\n-  tree group_local_offset_arg\n-    = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t  get_identifier (\"__group_local_offset\"), uint32_type_node);\n-  DECL_ARGUMENTS (fndecl) = chainon (DECL_ARGUMENTS (fndecl), group_local_offset_arg);\n-  DECL_ARG_TYPE (group_local_offset_arg) = uint32_type_node;\n-  DECL_CONTEXT (group_local_offset_arg) = fndecl;\n-  DECL_ARTIFICIAL (group_local_offset_arg) = 1;\n-  TREE_READONLY (group_local_offset_arg) = 1;\n-  TREE_USED (group_local_offset_arg) = 1;\n-  m_parent.m_cf->m_group_local_offset_arg = group_local_offset_arg;\n-\n-  /* Same for private.  */\n-  tree private_base_arg\n-    = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t  get_identifier (\"__private_base_addr\"), restrict_char_ptr);\n-  DECL_ARGUMENTS (fndecl) = chainon (DECL_ARGUMENTS (fndecl), private_base_arg);\n-  DECL_ARG_TYPE (private_base_arg) = restrict_char_ptr;\n-  DECL_CONTEXT (private_base_arg) = fndecl;\n-  DECL_ARTIFICIAL (private_base_arg) = 1;\n-  TREE_READONLY (private_base_arg) = 1;\n-  TREE_USED (private_base_arg) = 1;\n-  m_parent.m_cf->m_private_base_arg = private_base_arg;\n-\n-  DECL_SAVED_TREE (fndecl) = bind_expr;\n-\n-  if (base->kind == BRIG_KIND_DIRECTIVE_FUNCTION)\n-    {\n-      TREE_STATIC (fndecl) = 0;\n-      TREE_PUBLIC (fndecl) = 1;\n-      DECL_EXTERNAL (fndecl) = 0;\n-      DECL_DECLARED_INLINE_P (fndecl) = 1;\n-      set_inline (fndecl);\n-      set_externally_visible (fndecl);\n-    }\n-  else if (base->kind == BRIG_KIND_DIRECTIVE_KERNEL)\n-    {\n-      TREE_STATIC (fndecl) = 0;\n-      TREE_PUBLIC (fndecl) = 1;\n-      DECL_EXTERNAL (fndecl) = 0;\n-      set_externally_visible (fndecl);\n-    }\n-  else if (base->kind == BRIG_KIND_DIRECTIVE_SIGNATURE)\n-    {\n-      TREE_STATIC (fndecl) = 0;\n-      TREE_PUBLIC (fndecl) = 1;\n-      DECL_EXTERNAL (fndecl) = 1;\n-      set_inline (fndecl);\n-    }\n-  else if (base->kind == BRIG_KIND_DIRECTIVE_INDIRECT_FUNCTION)\n-    {\n-      TREE_STATIC (fndecl) = 0;\n-      TREE_PUBLIC (fndecl) = 1;\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  TREE_USED (fndecl) = 1;\n-  DECL_ARTIFICIAL (fndecl) = 0;\n-\n-  tree initial_block = make_node (BLOCK);\n-  DECL_INITIAL (fndecl) = initial_block;\n-  TREE_USED (DECL_INITIAL (fndecl)) = 1;\n-\n-  if (ret_value != NULL_TREE && TREE_TYPE (ret_value) != void_type_node)\n-    {\n-      DECL_CONTEXT (ret_value) = fndecl;\n-      DECL_CHAIN (ret_value) = BIND_EXPR_VARS (bind_expr);\n-      BIND_EXPR_VARS (bind_expr) = ret_value;\n-    }\n-\n-  tree arg;\n-  for (arg = DECL_ARGUMENTS (fndecl); arg != NULL_TREE; arg = TREE_CHAIN (arg))\n-    {\n-      DECL_CONTEXT (arg) = fndecl;\n-      DECL_ARG_TYPE (arg) = TREE_TYPE (arg);\n-    }\n-\n-  m_parent.add_function_decl (func_name, fndecl);\n-  m_parent.append_global (fndecl);\n-\n-\n-  if (!is_definition)\n-    {\n-      DECL_EXTERNAL (fndecl) = 1;\n-      return bytes_consumed;\n-    }\n-\n-  m_parent.start_function (fndecl);\n-  m_parent.m_cf->m_func_decl = fndecl;\n-  m_parent.m_cf->m_current_bind_expr = bind_expr;\n-\n-  if (ret_value != NULL_TREE && TREE_TYPE (ret_value) != void_type_node)\n-    {\n-      /* We cannot assign to <<retval>> directly in gcc trunk.  We need to\n-\t create a local temporary variable which can be stored to and when\n-\t returning from the function, we'll copy it to the actual <<retval>>\n-\t in return statement's argument.  */\n-      tree temp_var = m_parent.m_cf->m_ret_temp\n-\t= m_parent.m_cf->add_local_variable (\"_retvalue_temp\",\n-\t\t\t\t\t     TREE_TYPE (ret_value));\n-      TREE_ADDRESSABLE (temp_var) = 1;\n-    }\n-\n-  if (is_kernel)\n-    {\n-      m_parent.m_cf->add_id_variables ();\n-\n-      /* Create a single entry point in the function.  */\n-      m_parent.m_cf->m_entry_label_stmt\n-\t= build_stmt (LABEL_EXPR, m_parent.m_cf->label (\"__kernel_entry\"));\n-      m_parent.m_cf->append_statement (m_parent.m_cf->m_entry_label_stmt);\n-\n-      tree bind_expr = m_parent.m_cf->m_current_bind_expr;\n-      tree stmts = BIND_EXPR_BODY (bind_expr);\n-\n-      m_parent.m_cf->m_kernel_entry = tsi_last (stmts);\n-\n-      /* Let's not append the exit label yet, but only after the\n-\t function has been built.  We need to build it so it can\n-\t be referred to because returns are converted to gotos to this\n-\t label.  */\n-      m_parent.m_cf->m_exit_label = m_parent.m_cf->label (\"__kernel_exit\");\n-    }\n-\n-  return bytes_consumed;\n-}"}, {"sha": "c2bddfb8ca540e779dd21ca59e4018a08b3faa57", "filename": "gcc/brig/brigfrontend/brig-function.cc", "status": "removed", "additions": 0, "deletions": 1602, "changes": 1602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,1602 +0,0 @@\n-/* brig-function.cc -- declaration of brig_function class.\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <sstream>\n-#include <iomanip>\n-\n-#include \"brig-function.h\"\n-#include \"stringpool.h\"\n-#include \"tree-iterator.h\"\n-#include \"toplev.h\"\n-#include \"gimplify.h\"\n-#include \"gimple-expr.h\"\n-#include \"print-tree.h\"\n-#include \"hsa-brig-format.h\"\n-#include \"stor-layout.h\"\n-#include \"diagnostic-core.h\"\n-#include \"brig-code-entry-handler.h\"\n-#include \"brig-machine.h\"\n-#include \"brig-util.h\"\n-#include \"phsa.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"dumpfile.h\"\n-#include \"profile-count.h\"\n-#include \"tree-cfg.h\"\n-#include \"errors.h\"\n-#include \"function.h\"\n-#include \"brig-to-generic.h\"\n-#include \"brig-builtins.h\"\n-#include \"options.h\"\n-#include \"fold-const.h\"\n-#include \"target.h\"\n-#include \"builtins.h\"\n-\n-brig_function::builtin_map brig_function::s_custom_builtins;\n-\n-brig_function::brig_function (const BrigDirectiveExecutable *exec,\n-\t\t\t      brig_to_generic *parent)\n-  : m_brig_def (exec), m_is_kernel (false), m_is_finished (false), m_name (\"\"),\n-    m_current_bind_expr (NULL_TREE), m_func_decl (NULL_TREE),\n-    m_context_arg (NULL_TREE), m_group_base_arg (NULL_TREE),\n-    m_private_base_arg (NULL_TREE), m_ret_value (NULL_TREE),\n-    m_next_kernarg_offset (0), m_kernarg_max_align (0),\n-    m_ret_value_brig_var (NULL), m_has_barriers (false), m_has_allocas (false),\n-    m_has_function_calls_with_barriers (false), m_calls_analyzed (false),\n-    m_is_wg_function (false), m_has_unexpanded_dp_builtins (false),\n-    m_generating_arg_block (false), m_parent (parent)\n-{\n-  memset (m_regs, 0,\n-\t  BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT * sizeof (BrigOperandRegister *));\n-  memset (&m_descriptor, 0, sizeof (phsa_descriptor));\n-\n-  if (s_custom_builtins.size () > 0) return;\n-\n-  /* Populate the builtin index.  */\n-#undef DEF_HSAIL_ATOMIC_BUILTIN\n-#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n-#undef DEF_HSAIL_INTR_BUILTIN\n-#undef DEF_HSAIL_SAT_BUILTIN\n-#undef DEF_HSAIL_BUILTIN\n-#define DEF_HSAIL_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE, NAME, TYPE, ATTRS) \\\n-  s_custom_builtins[std::make_pair (HSAIL_OPCODE, HSAIL_TYPE)]\t\t\\\n-    = builtin_decl_explicit (ENUM);\n-\n-#include \"brig-builtins.def\"\n-}\n-\n-brig_function::~brig_function ()\n-{\n-  for (size_t i = 0; i < BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT; ++i)\n-    {\n-      if (m_regs[i] != NULL)\n-\t{\n-\t  delete m_regs[i];\n-\t  m_regs[i] = NULL;\n-\t}\n-    }\n-}\n-\n-/* Returns a GENERIC label with the given name in the given function.\n-   Creates it, if not yet found.  */\n-\n-tree\n-brig_function::label (const std::string &name)\n-{\n-  label_index::const_iterator i = m_label_index.find (name);\n-  if (i == m_label_index.end ())\n-    {\n-      tree name_identifier\n-\t= get_identifier_with_length (name.c_str (), name.size ());\n-\n-      tree label_decl = build_decl (UNKNOWN_LOCATION, LABEL_DECL,\n-\t\t\t\t    name_identifier, void_type_node);\n-\n-      DECL_CONTEXT (label_decl) = m_func_decl;\n-      DECL_ARTIFICIAL (label_decl) = 0;\n-\n-      m_label_index[name] = label_decl;\n-      return label_decl;\n-    }\n-  else\n-    return (*i).second;\n-}\n-\n-/* Record an argument variable for later use.  This includes both local\n-   variables inside arg blocks and incoming function arguments.  */\n-\n-void\n-brig_function::add_arg_variable (const BrigDirectiveVariable *brigVar,\n-\t\t\t\t tree treeDecl)\n-{\n-  m_arg_variables[brigVar] = treeDecl;\n-}\n-\n-tree\n-brig_function::arg_variable (const BrigDirectiveVariable *var) const\n-{\n-  variable_index::const_iterator i = m_arg_variables.find (var);\n-  if (i == m_arg_variables.end ())\n-    return NULL_TREE;\n-  else\n-    return (*i).second;\n-}\n-\n-/* Appends a new kernel argument descriptor for the current kernel's\n-   arg space.  */\n-\n-void\n-brig_function::append_kernel_arg (const BrigDirectiveVariable *var, size_t size,\n-\t\t\t\t  size_t alignment)\n-{\n-  gcc_assert (m_func_decl != NULL_TREE);\n-  gcc_assert (m_is_kernel);\n-\n-  size_t align_padding = m_next_kernarg_offset % alignment == 0 ?\n-    0 : (alignment - m_next_kernarg_offset % alignment);\n-  m_next_kernarg_offset += align_padding;\n-  m_kernarg_offsets[var] = m_next_kernarg_offset;\n-  m_next_kernarg_offset += size;\n-\n-  m_kernarg_max_align\n-    = m_kernarg_max_align < alignment ? alignment : m_kernarg_max_align;\n-}\n-\n-size_t\n-brig_function::kernel_arg_offset (const BrigDirectiveVariable *var) const\n-{\n-  var_offset_table::const_iterator i = m_kernarg_offsets.find (var);\n-  gcc_assert (i != m_kernarg_offsets.end ());\n-  return (*i).second;\n-}\n-\n-/* Add work-item ID variables to the beginning of the kernel function\n-   which can be used for address computation as kernel dispatch packet\n-   instructions can be expanded to GENERIC nodes referring to them.  */\n-\n-void\n-brig_function::add_id_variables ()\n-{\n-  tree bind_expr = m_current_bind_expr;\n-  tree stmts = BIND_EXPR_BODY (bind_expr);\n-\n-  /* Initialize the WG limits and local ids.  */\n-  m_kernel_entry = tsi_start (stmts);\n-\n-  for (int i = 0; i < 3; ++i)\n-    {\n-      char dim_char = (char) ((int) 'x' + i);\n-\n-      /* The local sizes are limited to 16b values, but let's still use 32b\n-\t to avoid unnecessary casts (the ID functions are 32b).  */\n-      m_local_id_vars[i]\n-\t= add_local_variable (std::string (\"__local_\") + dim_char,\n-\t\t\t      long_long_integer_type_node);\n-\n-      tree workitemid_call\n-\t= call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_WORKITEMID), 2,\n-\t\t\tuint32_type_node, uint32_type_node,\n-\t\t\tbuild_int_cst (uint32_type_node, i), ptr_type_node,\n-\t\t\tm_context_arg);\n-\n-      tree id_init = build2 (MODIFY_EXPR, TREE_TYPE (m_local_id_vars[i]),\n-\t\t\t     m_local_id_vars[i],\n-\t\t\t     convert (TREE_TYPE (m_local_id_vars[i]),\n-\t\t\t\t      workitemid_call));\n-\n-      append_statement (id_init);\n-\n-      m_cur_wg_size_vars[i]\n-\t= add_local_variable (std::string (\"__cur_wg_size_\") + dim_char,\n-\t\t\t      long_long_integer_type_node);\n-\n-      tree cwgz_call;\n-      if (flag_assume_phsa)\n-\t{\n-\t  tree_stl_vec operands\n-\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, i));\n-\t  cwgz_call\n-\t    = expand_or_call_builtin (BRIG_OPCODE_CURRENTWORKGROUPSIZE,\n-\t\t\t\t      BRIG_TYPE_U32, uint32_type_node,\n-\t\t\t\t      operands);\n-\t}\n-      else\n-\tcwgz_call = call_builtin\n-\t  (builtin_decl_explicit (BUILT_IN_HSAIL_CURRENTWORKGROUPSIZE),\n-\t   2, uint32_type_node, uint32_type_node,\n-\t   build_int_cst (uint32_type_node, i), ptr_type_node, m_context_arg);\n-\n-      tree limit_init = build2 (MODIFY_EXPR, TREE_TYPE (m_cur_wg_size_vars[i]),\n-\t\t\t\tm_cur_wg_size_vars[i],\n-\t\t\t\tconvert (TREE_TYPE (m_cur_wg_size_vars[i]),\n-\t\t\t\t\t cwgz_call));\n-\n-      append_statement (limit_init);\n-\n-      m_wg_id_vars[i]\n-\t= add_local_variable (std::string (\"__workgroupid_\") + dim_char,\n-\t\t\t      uint32_type_node);\n-\n-      tree wgid_call;\n-      if (flag_assume_phsa)\n-\t{\n-\t  tree_stl_vec operands\n-\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, i));\n-\t  wgid_call\n-\t    = expand_or_call_builtin (BRIG_OPCODE_WORKGROUPID, BRIG_TYPE_U32,\n-\t\t\t\t      uint32_type_node, operands);\n-\t}\n-      else\n-\twgid_call\n-\t  = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_WORKGROUPID),\n-\t\t\t  2, uint32_type_node, uint32_type_node,\n-\t\t\t  build_int_cst (uint32_type_node, i), ptr_type_node,\n-\t\t\t  m_context_arg);\n-\n-      tree wgid_init = build2 (MODIFY_EXPR, TREE_TYPE (m_wg_id_vars[i]),\n-\t\t\t       m_wg_id_vars[i], wgid_call);\n-\n-      append_statement (wgid_init);\n-\n-      m_wg_size_vars[i]\n-\t= add_local_variable (std::string (\"__workgroupsize_\") + dim_char,\n-\t\t\t      uint32_type_node);\n-\n-      tree wgsize_call;\n-      if (flag_assume_phsa)\n-\t{\n-\t  tree_stl_vec operands\n-\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, i));\n-\t  wgsize_call\n-\t    = expand_or_call_builtin (BRIG_OPCODE_WORKGROUPSIZE, BRIG_TYPE_U32,\n-\t\t\t\t      uint32_type_node, operands);\n-\t}\n-      else\n-\twgsize_call\n-\t  = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_WORKGROUPSIZE),\n-\t\t\t  2, uint32_type_node, uint32_type_node,\n-\t\t\t  build_int_cst (uint32_type_node, i), ptr_type_node,\n-\t\t\t  m_context_arg);\n-\n-      tree wgsize_init = build2 (MODIFY_EXPR, TREE_TYPE (m_wg_size_vars[i]),\n-\t\t\t\t m_wg_size_vars[i], wgsize_call);\n-\n-      append_statement (wgsize_init);\n-\n-      m_grid_size_vars[i]\n-\t= add_local_variable (std::string (\"__gridsize_\") + dim_char,\n-\t\t\t      uint32_type_node);\n-\n-      tree gridsize_call\n-\t= call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_GRIDSIZE), 2,\n-\t\t\tuint32_type_node, uint32_type_node,\n-\t\t\tbuild_int_cst (uint32_type_node, i), ptr_type_node,\n-\t\t\tm_context_arg);\n-\n-      tree gridsize_init = build2 (MODIFY_EXPR, TREE_TYPE (m_grid_size_vars[i]),\n-\t\t\t\t   m_grid_size_vars[i], gridsize_call);\n-\n-      append_statement (gridsize_init);\n-\n-      m_abs_id_base_vars[i]\n-\t= add_local_variable (std::string (\"__abs_id_base_\") + dim_char,\n-\t\t\t      long_long_integer_type_node);\n-\n-      m_abs_id_vars[i]\n-\t= add_local_variable (std::string (\"__abs_id_\") + dim_char,\n-\t\t\t      long_long_integer_type_node);\n-\n-      tree abs_id_base\n-\t= build2 (MULT_EXPR, long_long_integer_type_node,\n-\t\t  convert (long_long_integer_type_node, m_wg_id_vars[i]),\n-\t\t  convert (long_long_integer_type_node, m_wg_size_vars[i]));\n-      tree abs_id\n-\t= build2 (PLUS_EXPR, long_long_integer_type_node, abs_id_base,\n-\t\t  convert (long_long_integer_type_node, m_local_id_vars[i]));\n-\n-      tree abs_id_base_init\n-\t= build2 (MODIFY_EXPR, TREE_TYPE (m_abs_id_base_vars[i]),\n-\t\t  m_abs_id_base_vars[i], abs_id_base);\n-      append_statement (abs_id_base_init);\n-\n-      tree abs_id_init = build2 (MODIFY_EXPR,\n-\t\t\t\t TREE_TYPE (m_abs_id_vars[i]),\n-\t\t\t\t m_abs_id_vars[i], abs_id);\n-      append_statement (abs_id_init);\n-    }\n-}\n-\n-/* Creates a new local variable with the given NAME and given GENERIC\n-   TYPE.  */\n-\n-tree\n-brig_function::add_local_variable (std::string name, tree type)\n-{\n-  tree name_identifier\n-    = get_identifier_with_length (name.c_str (), name.size ());\n-  tree variable\n-    = build_decl (UNKNOWN_LOCATION, VAR_DECL, name_identifier, type);\n-\n-  DECL_NONLOCAL (variable) = 0;\n-  TREE_ADDRESSABLE (variable) = 0;\n-  TREE_STATIC (variable) = 0;\n-  TREE_USED (variable) = 1;\n-  DECL_ARTIFICIAL (variable) = 0;\n-\n-  tree bind_expr = DECL_SAVED_TREE (m_func_decl);\n-\n-  DECL_CONTEXT (variable) = m_func_decl;\n-\n-  DECL_CHAIN (variable) = BIND_EXPR_VARS (bind_expr);\n-  BIND_EXPR_VARS (bind_expr) = variable;\n-  return variable;\n-}\n-\n-/* Return tree type for an HSA register.\n-\n-   The tree type can be anything (scalar, vector, int, float, etc.)\n-   but its size is guaranteed to match the HSA register size.\n-\n-   HSA registers are untyped but we select a type based on their use\n-   to reduce (sometimes unoptimizable) VIEW_CONVERT_EXPR nodes (seems\n-   to occur when use or def reaches over current BB).  */\n-\n-tree\n-brig_function::get_tree_type_for_hsa_reg (const BrigOperandRegister *reg) const\n-{\n-  size_t reg_size = gccbrig_reg_size (reg);\n-\n-  /* The default type.  */\n-  tree type = build_nonstandard_integer_type (reg_size, true);\n-\n-  if (m_parent->m_fn_regs_use_index.count (m_name) == 0)\n-    return type;\n-\n-  const regs_use_index &index = m_parent->m_fn_regs_use_index[m_name];\n-  size_t reg_id = gccbrig_hsa_reg_id (*reg);\n-  if (index.count (reg_id) == 0)\n-    return type;\n-\n-  const reg_use_info &info = index.find (reg_id)->second;\n-  std::vector<std::pair<tree, size_t> >::const_iterator it\n-    = info.m_type_refs.begin ();\n-  std::vector<std::pair<tree, size_t> >::const_iterator it_end\n-    = info.m_type_refs.end ();\n-  size_t max_refs_as_type_count = 0;\n-  for (; it != it_end; it++)\n-    {\n-      size_t type_bit_size = int_size_in_bytes (it->first) * BITS_PER_UNIT;\n-      if (type_bit_size != reg_size) continue;\n-      if (it->second > max_refs_as_type_count)\n-\t{\n-\t  type = it->first;\n-\t  max_refs_as_type_count = it->second;\n-\t}\n-    }\n-\n-  return type;\n-}\n-\n-/* Returns a DECL_VAR for the given HSAIL operand register.\n-   If it has not been created yet for the function being generated,\n-   creates it as a type determined by analysis phase.  */\n-\n-tree\n-brig_function::get_m_var_declfor_reg (const BrigOperandRegister *reg)\n-{\n-  size_t offset = gccbrig_hsa_reg_id (*reg);\n-\n-  reg_decl_index_entry *regEntry = m_regs[offset];\n-  if (regEntry == NULL)\n-    {\n-      size_t reg_size = gccbrig_reg_size (reg);\n-      tree type;\n-      if (reg_size > 1)\n-\ttype = get_tree_type_for_hsa_reg (reg);\n-      else\n-\ttype = boolean_type_node;\n-\n-      /* Drop the const qualifier so we do not end up with a read only\n-\t register variable which cannot be written to later.  */\n-      tree nonconst_type = build_type_variant (type, false, false);\n-\n-      regEntry = new reg_decl_index_entry;\n-\n-      regEntry->m_var_decl\n-\t= add_local_variable (gccbrig_reg_name (reg), nonconst_type);\n-      m_regs[offset] = regEntry;\n-    }\n-  return regEntry->m_var_decl;\n-}\n-\n-/* Builds a work-item do..while loop for a single DIM.  HEADER_ENTRY is\n-   a statement after which the iteration variables should be initialized and\n-   the loop body starts.  BRANCH_AFTER is the statement after which the loop\n-   predicate check and the back edge goto will be appended.  */\n-\n-void\n-brig_function::add_wi_loop (int dim, tree_stmt_iterator *header_entry,\n-\t\t\t    tree_stmt_iterator *branch_after)\n-{\n-  tree ivar = m_local_id_vars[dim];\n-  tree abs_id_base_var = m_abs_id_base_vars[dim];\n-  tree abs_id_var = m_abs_id_vars[dim];\n-  tree ivar_max = m_cur_wg_size_vars[dim];\n-  tree_stmt_iterator entry = *header_entry;\n-\n-  /* TODO: this is not a parallel loop as we share the \"register variables\"\n-     across work-items.  Should create a copy of them per WI instance.  That\n-     is, declare temporaries for new definitions inside the loop body, not at\n-     function scope.  */\n-\n-  tree ivar_init = build2 (MODIFY_EXPR, TREE_TYPE (ivar), ivar,\n-\t\t\t   build_zero_cst (TREE_TYPE (ivar)));\n-  tsi_link_after (&entry, ivar_init, TSI_NEW_STMT);\n-\n-  tree abs_id_var_init = build2 (MODIFY_EXPR, TREE_TYPE (abs_id_var),\n-\t\t\t\t abs_id_var,\n-\t\t\t\t convert (TREE_TYPE (abs_id_var),\n-\t\t\t\t\t  abs_id_base_var));\n-  tsi_link_after (&entry, abs_id_var_init, TSI_NEW_STMT);\n-\n-  tree loop_body_label\n-    = label (std::string (\"__wi_loop_\") + (char) ((int) 'x' + dim));\n-  tree loop_body_label_stmt = build_stmt (LABEL_EXPR, loop_body_label);\n-\n-  tsi_link_after (&entry, loop_body_label_stmt, TSI_NEW_STMT);\n-\n-  if (m_has_unexpanded_dp_builtins)\n-    {\n-      if (!flag_assume_phsa)\n-\t{\n-\t  tree id_set_builtin\n-\t    = builtin_decl_explicit (BUILT_IN_HSAIL_SETWORKITEMID);\n-\t  /* Set the local ID to the current wi-loop iteration variable value\n-\t     to ensure the builtins see the correct values.  */\n-\t  tree id_set_call\n-\t    = call_builtin (id_set_builtin, 3,\n-\t\t\t    void_type_node, uint32_type_node,\n-\t\t\t    build_int_cst (uint32_type_node, dim),\n-\t\t\t    uint32_type_node, convert (uint32_type_node, ivar),\n-\t\t\t    ptr_type_node, m_context_arg);\n-\t  tsi_link_after (&entry, id_set_call, TSI_NEW_STMT);\n-\t}\n-      else\n-\t{\n-\t  tree ptr_type = build_pointer_type (uint32_type_node);\n-\t  tree ctx = build2 (MEM_REF, uint32_type_node, m_context_arg,\n-\t\t\t     build_int_cst (ptr_type, dim * 4));\n-\t  tree assign = build2 (MODIFY_EXPR, uint32_type_node, ctx,\n-\t\t\t\tconvert (uint32_type_node, ivar));\n-\n-\t  tsi_link_after (&entry, assign, TSI_NEW_STMT);\n-\t}\n-    }\n-\n-  /* Increment the WI iteration variable.  */\n-  tree incr = build2 (PREINCREMENT_EXPR, TREE_TYPE (ivar), ivar,\n-\t\t      build_one_cst (TREE_TYPE (ivar)));\n-\n-  tsi_link_after (branch_after, incr, TSI_NEW_STMT);\n-\n-  /* ...and the abs id variable.  */\n-  tree abs_id_incr = build2 (PREINCREMENT_EXPR, TREE_TYPE (abs_id_var),\n-\t\t\t     abs_id_var,\n-\t\t\t     build_one_cst (TREE_TYPE (abs_id_var)));\n-\n-  tsi_link_after (branch_after, abs_id_incr, TSI_NEW_STMT);\n-\n-  /* Append the predicate check with the back edge goto.  */\n-  tree condition = build2 (LT_EXPR, TREE_TYPE (ivar), ivar, ivar_max);\n-  tree target_goto = build1 (GOTO_EXPR, void_type_node, loop_body_label);\n-  tree if_stmt\n-    = build3 (COND_EXPR, void_type_node, condition, target_goto, NULL_TREE);\n-  tsi_link_after (branch_after, if_stmt, TSI_NEW_STMT);\n-}\n-\n-/* Recursively analyzes the function and its callees for barrier usage.  */\n-\n-void\n-brig_function::analyze_calls ()\n-{\n-  if (m_calls_analyzed)\n-    return;\n-\n-  /* Set this early to not get stuck in case of recursive call graphs.\n-     This is safe because if the function calls itself, either the function\n-     has barrier calls which implies a call to a function with barrier calls,\n-     or it doesn't in which case the result depends on the later called\n-     functions.  */\n-  m_calls_analyzed = true;\n-\n-  for (size_t i = 0; i < m_called_functions.size (); ++i)\n-    {\n-      tree f = m_called_functions[i];\n-      brig_function *called_f = m_parent->get_finished_function (f);\n-      if (called_f == NULL)\n-\t{\n-\t  /* Unfinished function (only declaration within the set of BRIGs)\n-\t     found.  Cannot finish the CG analysis.  Have to assume it does have\n-\t     a barrier for safety.  */\n-\t  m_has_function_calls_with_barriers = true;\n-\t  m_has_unexpanded_dp_builtins = true;\n-\t  break;\n-\t}\n-      called_f->analyze_calls ();\n-      /* We can assume m_has_barriers has been correctly set during the\n-\t construction of the function decl.  No need to reanalyze it.  */\n-      m_has_function_calls_with_barriers |= called_f->m_has_barriers;\n-\n-      /* If the function or any of its called functions has dispatch\n-\t packet builtin calls that require the local id, we need to\n-\t set the local id to the context in the work item loop before\n-\t the functions are called.  If we analyze the opposite, these\n-\t function calls can be omitted.  */\n-      m_has_unexpanded_dp_builtins |= called_f->m_has_unexpanded_dp_builtins;\n-    }\n-}\n-\n-/* Tries to convert the current kernel to a work-group function that executes\n-   all work-items using loops.  Returns true in case the conversion was\n-   successful.  */\n-\n-bool\n-brig_function::convert_to_wg_function ()\n-{\n-  if (!m_calls_analyzed)\n-    analyze_calls ();\n-\n-  if (m_has_barriers || m_has_function_calls_with_barriers)\n-    return false;\n-\n-  /* The most trivial case: No barriers at all in the kernel.\n-     We can create one big work-item loop around the whole kernel.  */\n-  tree bind_expr = m_current_bind_expr;\n-  tree stmts = BIND_EXPR_BODY (bind_expr);\n-\n-  for (int i = 0; i < 3; ++i)\n-    {\n-      /* The previous loop has added a new label to the end of the function,\n-\t the next level loop should wrap around it also.  */\n-      tree_stmt_iterator function_exit = tsi_last (stmts);\n-      add_wi_loop (i, &m_kernel_entry, &function_exit);\n-    }\n-\n-  m_is_wg_function = true;\n-  return false;\n-}\n-\n-/* Emits a kernel description to a special ELF section so it can be\n-   utilized by an HSA runtime implementation.  The assembly block\n-   must be emitted to a statement list of an function, which is given\n-   as an argument.  Returns the assembly block used to emit the section. */\n-\n-tree\n-brig_function::emit_metadata (tree stmt_list)\n-{\n-  /* Emit an ELF section via an assembly directive that generates a special\n-     ELF section for each kernel that contains raw bytes of a descriptor\n-     object.  This is pretty disgusting, but life is never perfect ;)  */\n-\n-  /* Use the original kernel name without the '_' prefix in the section name.  */\n-  std::string kern_name = m_is_kernel ? m_name.substr (1) : m_name;\n-\n-  std::ostringstream strstr;\n-  strstr << std::endl\n-\t << \".pushsection \" << PHSA_DESC_SECTION_PREFIX << kern_name\n-\t << std::endl\n-\t << \"\\t.p2align 1, 1, 1\" << std::endl\n-\t << \"\\t.byte \";\n-\n-  for (size_t i = 0; i < sizeof (phsa_descriptor); ++i)\n-    {\n-      strstr << \"0x\" << std::setw (2) << std::setfill ('0') << std::hex\n-\t     << (unsigned) *((unsigned char *) &m_descriptor + i);\n-      if (i + 1 < sizeof (phsa_descriptor))\n-\tstrstr << \", \";\n-    }\n-\n-  strstr << std::endl << \".popsection\" << std::endl << std::endl;\n-\n-  tree metadata_asm\n-    = build_stmt (ASM_EXPR,\n-\t\t  build_string (strstr.str ().size (), strstr.str ().c_str ()),\n-\t\t  NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE);\n-\n-  append_to_statement_list_force (metadata_asm, &stmt_list);\n-  return metadata_asm;\n-}\n-\n-/* Emits the kernel launcher function.  Also emits the metadata section\n-   creation statements in it.\n-\n-   The launcher function calls the device-side runtime\n-   that runs the kernel for all work-items.  In C:\n-\n-   void KernelName (void* context, void* group_base_addr)\n-   {\n-     __hsail_launch_kernel (_KernelName, context, group_base_addr);\n-   }\n-\n-   or, in case of a successful conversion to a work-group function:\n-\n-   void KernelName (void* context, void* group_base_addr)\n-   {\n-     __hsail_launch_wg_function (_KernelName, context, group_base_addr);\n-   }\n-\n-   The user/host sees this function as the kernel to call from the\n-   outside.  The actual kernel generated from HSAIL was named _KernelName.\n-*/\n-\n-tree\n-brig_function::emit_launcher_and_metadata ()\n-{\n-  /* The original kernel name without the '_' prefix.  */\n-  std::string kern_name = m_name.substr (1);\n-\n-  tree name_identifier\n-    = get_identifier_with_length (kern_name.c_str (), kern_name.size ());\n-\n-  tree restrict_void_ptr\n-    = build_qualified_type (build_pointer_type (void_type_node),\n-\t\t\t    TYPE_QUAL_RESTRICT);\n-  tree restrict_char_ptr\n-    = build_qualified_type (build_pointer_type (char_type_node),\n-\t\t\t    TYPE_QUAL_RESTRICT);\n-  tree launcher\n-    = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, name_identifier,\n-\t\t  build_function_type_list (void_type_node, restrict_void_ptr,\n-\t\t\t\t\t    restrict_char_ptr, NULL_TREE));\n-\n-  TREE_USED (launcher) = 1;\n-  DECL_ARTIFICIAL (launcher) = 1;\n-\n-  tree context_arg = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t\t\t get_identifier (\"__context\"),\n-\t\t\t\t restrict_void_ptr);\n-\n-  DECL_ARGUMENTS (launcher) = context_arg;\n-  DECL_ARG_TYPE (context_arg) = restrict_void_ptr;\n-  DECL_CONTEXT (context_arg) = launcher;\n-  TREE_USED (context_arg) = 1;\n-  DECL_ARTIFICIAL (context_arg) = 1;\n-\n-  tree group_base_addr_arg\n-    = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t  get_identifier (\"__group_base_addr\"), restrict_char_ptr);\n-\n-  chainon (DECL_ARGUMENTS (launcher), group_base_addr_arg);\n-  DECL_ARG_TYPE (group_base_addr_arg) = restrict_char_ptr;\n-  DECL_CONTEXT (group_base_addr_arg) = launcher;\n-  TREE_USED (group_base_addr_arg) = 1;\n-  DECL_ARTIFICIAL (group_base_addr_arg) = 1;\n-\n-  tree resdecl\n-    = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, void_type_node);\n-\n-  DECL_RESULT (launcher) = resdecl;\n-  DECL_CONTEXT (resdecl) = launcher;\n-\n-  DECL_INITIAL (launcher) = make_node (BLOCK);\n-  TREE_USED (DECL_INITIAL (launcher)) = 1;\n-\n-  tree stmt_list = alloc_stmt_list ();\n-\n-  tree bind_expr = build3 (BIND_EXPR, void_type_node, NULL, stmt_list, NULL);\n-\n-  TREE_STATIC (launcher) = 1;\n-  TREE_PUBLIC (launcher) = 1;\n-\n-  DECL_SAVED_TREE (launcher) = bind_expr;\n-\n-  if (DECL_STRUCT_FUNCTION (launcher) == NULL)\n-    push_struct_function (launcher);\n-  else\n-    push_cfun (DECL_STRUCT_FUNCTION (launcher));\n-\n-  tree kernel_func_ptr = build1 (ADDR_EXPR, ptr_type_node, m_func_decl);\n-\n-  tree phsail_launch_kernel_call;\n-\n-  /* Compute the local group segment frame start pointer.  */\n-  tree group_local_offset_temp\n-    = create_tmp_var (uint32_type_node, \"group_local_offset\");\n-  tree group_local_offset_arg\n-    = build2 (MODIFY_EXPR, uint32_type_node,\n-\t      group_local_offset_temp,\n-\t      build_int_cst (uint32_type_node,\n-\t\t\t     m_parent->m_module_group_variables.size()));\n-\n-  /* Emit a launcher depending whether we converted the kernel function to\n-     a work group function or not.  */\n-  if (m_is_wg_function)\n-    phsail_launch_kernel_call\n-      = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_LAUNCH_WG_FUNC),\n-\t\t      4, void_type_node,\n-\t\t      ptr_type_node, kernel_func_ptr, restrict_void_ptr,\n-\t\t      context_arg, restrict_char_ptr, group_base_addr_arg,\n-\t\t      uint32_type_node, group_local_offset_arg);\n-  else\n-    phsail_launch_kernel_call\n-      = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_LAUNCH_KERNEL),\n-\t\t      4, void_type_node,\n-\t\t      ptr_type_node, kernel_func_ptr, restrict_void_ptr,\n-\t\t      context_arg, restrict_char_ptr, group_base_addr_arg,\n-\t\t      uint32_type_node, group_local_offset_arg);\n-\n-  append_to_statement_list_force (phsail_launch_kernel_call, &stmt_list);\n-\n-  emit_metadata (stmt_list);\n-\n-  set_externally_visible (launcher);\n-\n-  return launcher;\n-}\n-\n-tree\n-brig_function::append_statement (tree stmt)\n-{\n-  gcc_assert (m_func_decl != NULL);\n-\n-  tree bind_expr = m_current_bind_expr;\n-  tree stmts = BIND_EXPR_BODY (bind_expr);\n-\n-  append_to_statement_list_force (stmt, &stmts);\n-  return stmt;\n-}\n-\n-/* Creates a new \"alloca frame\" for the current function by\n-   injecting an alloca frame push in the beginning of the function\n-   and an alloca frame pop before all function exit points.  */\n-\n-void\n-brig_function::create_alloca_frame ()\n-{\n-  tree_stmt_iterator entry;\n-\n-  /* Adds the alloca push only after the ids have been initialized\n-     in case of a kernel function.  */\n-  if (m_is_kernel)\n-    entry = m_kernel_entry;\n-  else\n-    {\n-      tree bind_expr = m_current_bind_expr;\n-      tree stmts = BIND_EXPR_BODY (bind_expr);\n-      entry = tsi_start (stmts);\n-    }\n-\n-  tree push_frame_builtin = builtin_decl_explicit (BUILT_IN_HSAIL_PUSH_FRAME);\n-  tree push_frame_call\n-    = call_builtin (push_frame_builtin, 1, void_type_node, ptr_type_node,\n-\t\t    m_context_arg);\n-\n-  tsi_link_before (&entry, push_frame_call, TSI_NEW_STMT);\n-\n-  tree pop_frame_builtin = builtin_decl_explicit (BUILT_IN_HSAIL_POP_FRAME);\n-\n-  do\n-    {\n-      tree stmt = tsi_stmt (entry);\n-      if (TREE_CODE (stmt) == RETURN_EXPR)\n-\t{\n-\t  tree pop_frame_call\n-\t    = call_builtin (pop_frame_builtin, 1, void_type_node,\n-\t\t\t    ptr_type_node, m_context_arg);\n-\n-\t  tsi_link_before (&entry, pop_frame_call, TSI_SAME_STMT);\n-\t}\n-      tsi_next (&entry);\n-    }\n-  while (!tsi_end_p (entry));\n-}\n-\n-/* Finishes the currently built function.  After calling this, no new\n-   statements should be appeneded to the function.  */\n-void\n-brig_function::finish ()\n-{\n-  append_return_stmt ();\n-\n-  /* Currently assume single alloca frame per WG.  */\n-  if (m_has_allocas)\n-    create_alloca_frame ();\n-}\n-\n-void\n-brig_function::finish_kernel ()\n-{\n-  /* Kernel functions should have a single exit point.\n-     Let's create one.  The return instructions should have\n-     been converted to branches to this label.  */\n-  append_statement (build_stmt (LABEL_EXPR, m_exit_label));\n-  /* Attempt to convert the kernel to a work-group function that\n-     executes all work-items of the WG using a loop.  */\n-  convert_to_wg_function ();\n-\n-  append_return_stmt ();\n-\n-  /* Currently assume single alloca frame per WG.  */\n-  if (m_has_allocas)\n-    create_alloca_frame ();\n-}\n-\n-void\n-brig_function::append_return_stmt ()\n-{\n-  gcc_assert (m_current_bind_expr != NULL_TREE);\n-  tree stmts = BIND_EXPR_BODY (m_current_bind_expr);\n-\n-  if (STATEMENT_LIST_TAIL (stmts) == NULL)\n-    return; /* Empty function.  */\n-\n-  tree last_stmt = tsi_stmt (tsi_last (stmts));\n-\n-  if (TREE_CODE (last_stmt) == RETURN_EXPR)\n-    return;\n-\n-  if (m_ret_value != NULL_TREE)\n-    {\n-      tree result_assign\n-\t= build2 (MODIFY_EXPR, TREE_TYPE (m_ret_value), m_ret_value,\n-\t\t  m_ret_temp);\n-\n-      tree return_expr\n-\t= build1 (RETURN_EXPR, TREE_TYPE (result_assign), result_assign);\n-      append_to_statement_list_force (return_expr, &stmts);\n-    }\n-  else\n-    {\n-      tree return_stmt = build_stmt (RETURN_EXPR, NULL);\n-      append_to_statement_list_force (return_stmt, &stmts);\n-    }\n-}\n-\n-bool\n-brig_function::has_function_scope_var (const BrigBase* var) const\n-{\n-  return m_function_scope_vars.find (var) != m_function_scope_vars.end ();\n-}\n-\n-size_t\n-brig_function::group_variable_segment_offset (const std::string &name) const\n-{\n-  if (m_local_group_variables.has_variable (name))\n-    return m_local_group_variables.segment_offset (name);\n-\n-  gcc_assert (m_parent->m_module_group_variables.has_variable (name));\n-  return m_parent->m_module_group_variables.segment_offset (name);\n-}\n-\n-/* Try to expand the given builtin call to reuse a previously generated\n-   variable, if possible.  If not, just call the given builtin.\n-   BRIG_OPCODE and BRIG_TYPE identify the builtin's BRIG opcode/type,\n-   ARITH_TYPE its GENERIC type, and OPERANDS contains the builtin's\n-   input operands.  */\n-\n-tree\n-brig_function::expand_or_call_builtin (BrigOpcode16_t brig_opcode,\n-\t\t\t\t       BrigType16_t brig_type,\n-\t\t\t\t       tree arith_type,\n-\t\t\t\t       tree_stl_vec &operands)\n-{\n-  if (needs_workitem_context_data (brig_opcode))\n-    m_has_unexpanded_dp_builtins = true;\n-\n-  if (can_expand_builtin (brig_opcode))\n-    return expand_builtin (brig_opcode, operands);\n-\n-  tree built_in\n-    = get_builtin_for_hsa_opcode (arith_type, brig_opcode, brig_type);\n-\n-  if (!VECTOR_TYPE_P (TREE_TYPE (TREE_TYPE (built_in)))\n-      && arith_type != NULL_TREE && VECTOR_TYPE_P (arith_type)\n-      && brig_opcode != BRIG_OPCODE_LERP\n-      && brig_opcode != BRIG_OPCODE_PACKCVT\n-      && brig_opcode != BRIG_OPCODE_SAD\n-      && brig_opcode != BRIG_OPCODE_SADHI)\n-    {\n-      /* Call the scalar built-in for all elements in the vector.  */\n-      tree_stl_vec operand0_elements;\n-      if (operands.size () > 0)\n-\tunpack (operands[0], operand0_elements);\n-\n-      tree_stl_vec operand1_elements;\n-      if (operands.size () > 1)\n-\tunpack (operands[1], operand1_elements);\n-\n-      tree_stl_vec result_elements;\n-\n-      size_t element_count = gccbrig_type_vector_subparts (arith_type);\n-      for (size_t i = 0; i < element_count; ++i)\n-\t{\n-\t  tree_stl_vec call_operands;\n-\t  if (operand0_elements.size () > 0)\n-\t    call_operands.push_back (operand0_elements.at (i));\n-\n-\t  if (operand1_elements.size () > 0)\n-\t    call_operands.push_back (operand1_elements.at (i));\n-\n-\t  result_elements.push_back\n-\t    (expand_or_call_builtin (brig_opcode, brig_type,\n-\t\t\t\t     TREE_TYPE (arith_type),\n-\t\t\t\t     call_operands));\n-\t}\n-      return pack (result_elements);\n-    }\n-\n-  tree_stl_vec call_operands;\n-  tree_stl_vec operand_types;\n-\n-  tree arg_type_chain = TYPE_ARG_TYPES (TREE_TYPE (built_in));\n-\n-  for (size_t i = 0; i < operands.size (); ++i)\n-    {\n-      tree operand_type = TREE_VALUE (arg_type_chain);\n-      call_operands.push_back (convert (operand_type, operands[i]));\n-      operand_types.push_back (operand_type);\n-      arg_type_chain = TREE_CHAIN (arg_type_chain);\n-    }\n-\n-  if (needs_workitem_context_data (brig_opcode))\n-    {\n-      call_operands.push_back (m_context_arg);\n-      operand_types.push_back (ptr_type_node);\n-    }\n-\n-  size_t operand_count = call_operands.size ();\n-\n-  call_operands.resize (4, NULL_TREE);\n-  operand_types.resize (4, NULL_TREE);\n-  for (size_t i = 0; i < operand_count; ++i)\n-    call_operands.at (i) = build_resize_convert_view (operand_types.at (i),\n-\t\t\t\t\t\t      call_operands.at (i));\n-\n-  tree fnptr = build_fold_addr_expr (built_in);\n-  return build_call_array (TREE_TYPE (TREE_TYPE (built_in)), fnptr,\n-\t\t\t   operand_count, &call_operands[0]);\n-}\n-\n-/* Instead of calling a built-in function, use a more efficient mechanism\n-   such as reuse a previously returned value known to be still valid, or\n-   access the work-item context struct directly.  This is beneficial especially\n-   for the work-item identification related builtins as not having them as\n-   unanalyzable black box calls can lead to more easily vectorizable parallel\n-   loops for multi work-item work-groups.  BRIG_OPCODE identifies the builtin\n-   and OPERANDS store the operands.  */\n-\n-tree\n-brig_function::expand_builtin (BrigOpcode16_t brig_opcode,\n-\t\t\t       tree_stl_vec &operands)\n-{\n-  tree_stl_vec uint32_0 = tree_stl_vec (1, build_int_cst (uint32_type_node, 0));\n-\n-  tree_stl_vec uint32_1 = tree_stl_vec (1, build_int_cst (uint32_type_node, 1));\n-\n-  tree_stl_vec uint32_2 = tree_stl_vec (1, build_int_cst (uint32_type_node, 2));\n-\n-  if (brig_opcode == BRIG_OPCODE_WORKITEMFLATABSID)\n-    {\n-      tree id0 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_0);\n-      id0 = convert (uint64_type_node, id0);\n-\n-      tree id1 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_1);\n-      id1 = convert (uint64_type_node, id1);\n-\n-      tree id2 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_2);\n-      id2 = convert (uint64_type_node, id2);\n-\n-      tree max0 = convert (uint64_type_node, m_grid_size_vars[0]);\n-      tree max1 = convert (uint64_type_node, m_grid_size_vars[1]);\n-\n-      tree id2_x_max0_x_max1 = build2 (MULT_EXPR, uint64_type_node, id2, max0);\n-      id2_x_max0_x_max1\n-\t= build2 (MULT_EXPR, uint64_type_node, id2_x_max0_x_max1, max1);\n-\n-      tree id1_x_max0 = build2 (MULT_EXPR, uint64_type_node, id1, max0);\n-\n-      tree sum = build2 (PLUS_EXPR, uint64_type_node, id0, id1_x_max0);\n-      sum = build2 (PLUS_EXPR, uint64_type_node, sum, id2_x_max0_x_max1);\n-\n-      return add_temp_var (\"workitemflatabsid\", sum);\n-    }\n-  else if (brig_opcode == BRIG_OPCODE_WORKITEMABSID)\n-    {\n-      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n-      return m_abs_id_vars[dim];\n-    }\n-  else if (brig_opcode == BRIG_OPCODE_WORKITEMFLATID)\n-    {\n-\n-      tree wg_size_x = expand_builtin (BRIG_OPCODE_WORKGROUPSIZE, uint32_0);\n-      tree wg_size_y = expand_builtin (BRIG_OPCODE_WORKGROUPSIZE, uint32_1);\n-      tree z_x_wgsx_wgsy\n-\t= build2 (MULT_EXPR, uint32_type_node,\n-\t\t  convert (uint32_type_node,\n-\t\t\t   expand_builtin (BRIG_OPCODE_WORKITEMID, uint32_2)),\n-\t\t  wg_size_x);\n-      z_x_wgsx_wgsy = build2 (MULT_EXPR, uint32_type_node, z_x_wgsx_wgsy,\n-\t\t\t      wg_size_y);\n-\n-      tree y_x_wgsx\n-\t= build2 (MULT_EXPR, uint32_type_node,\n-\t\t  convert (uint32_type_node,\n-\t\t\t   expand_builtin (BRIG_OPCODE_WORKITEMID, uint32_1)),\n-\t\t  wg_size_x);\n-\n-      tree sum = build2 (PLUS_EXPR, uint32_type_node, y_x_wgsx, z_x_wgsx_wgsy);\n-      sum = build2 (PLUS_EXPR, uint32_type_node,\n-\t\t    convert (uint32_type_node,\n-\t\t\t     expand_builtin (BRIG_OPCODE_WORKITEMID, uint32_0)),\n-\t\t    sum);\n-      return add_temp_var (\"workitemflatid\", sum);\n-    }\n-  else if (brig_opcode == BRIG_OPCODE_WORKGROUPSIZE)\n-    {\n-      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n-      if (flag_assume_phsa)\n-\t{\n-\t  tree ptr_type = build_pointer_type (uint32_type_node);\n-\t  tree ctx = build2 (MEM_REF, uint32_type_node, m_context_arg,\n-\t\t\t     build_int_cst (ptr_type,\n-\t\t\t\t\t    PHSA_CONTEXT_WG_SIZES\n-\t\t\t\t\t    + dim * 4));\n-\t  std::string name (\"wgsize_x\");\n-\t  name [name.length() - 1] += dim;\n-\t  return add_temp_var (name.c_str(), ctx);\n-\t}\n-      else if (m_is_kernel)\n-\t{\n-\t  /* For kernels without phsa we generate certain temps before\n-\t     the WI loop, which means we don't need to rely on LICM to get\n-\t     them moved out.  */\n-\t  return m_wg_size_vars[dim];\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (brig_opcode == BRIG_OPCODE_WORKITEMID)\n-    {\n-      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n-      if (m_is_kernel)\n-\t{\n-\t  return m_local_id_vars [dim];\n-\t}\n-      else if (flag_assume_phsa)\n-\t{\n-\t  tree ptr_type = build_pointer_type (uint32_type_node);\n-\t  tree ctx = build2 (MEM_REF, uint32_type_node, m_context_arg,\n-\t\t\t     build_int_cst (ptr_type,\n-\t\t\t\t\t    PHSA_CONTEXT_OFFS_WI_IDS\n-\t\t\t\t\t    + dim * 4));\n-\t  std::string name (\"wiid_x\");\n-\t  name [name.length() - 1] += dim;\n-\t  return add_temp_var (name.c_str(), ctx);\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (brig_opcode == BRIG_OPCODE_WORKGROUPID)\n-    {\n-      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n-      if (flag_assume_phsa)\n-\t{\n-\t  tree ptr_type = build_pointer_type (uint32_type_node);\n-\t  tree ctx = build2 (MEM_REF, uint32_type_node, m_context_arg,\n-\t\t\t     build_int_cst (ptr_type,\n-\t\t\t\t\t    PHSA_CONTEXT_OFFS_WG_IDS\n-\t\t\t\t\t    + dim * 4));\n-\t  std::string name (\"wgid_x\");\n-\t  name [name.length() - 1] += dim;\n-\t  return add_temp_var (name.c_str(), ctx);\n-\t} else if (m_is_kernel)\n-\treturn m_wg_id_vars [dim];\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (brig_opcode == BRIG_OPCODE_CURRENTWORKGROUPSIZE)\n-    {\n-      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n-      if (flag_assume_phsa)\n-\t{\n-\t  tree ptr_type = build_pointer_type (uint32_type_node);\n-\t  tree ctx = build2 (MEM_REF, uint32_type_node, m_context_arg,\n-\t\t\t     build_int_cst (ptr_type,\n-\t\t\t\t\t    PHSA_CONTEXT_CURRENT_WG_SIZES\n-\t\t\t\t\t    + dim * 4));\n-\t  std::string name (\"curwgsize_x\");\n-\t  name [name.length() - 1] += dim;\n-\t  return add_temp_var (name.c_str(), ctx);\n-\t} else if (m_is_kernel)\n-\treturn m_cur_wg_size_vars[dim];\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  return NULL_TREE;\n-}\n-\n-/* Returns true in case the given opcode that would normally be generated\n-   as a builtin call can be expanded to tree nodes.  */\n-\n-bool\n-brig_function::can_expand_builtin (BrigOpcode16_t brig_opcode) const\n-{\n-  switch (brig_opcode)\n-    {\n-    case BRIG_OPCODE_CURRENTWORKGROUPSIZE:\n-    case BRIG_OPCODE_WORKITEMFLATID:\n-    case BRIG_OPCODE_WORKITEMID:\n-    case BRIG_OPCODE_WORKGROUPID:\n-    case BRIG_OPCODE_WORKGROUPSIZE:\n-      return m_is_kernel || flag_assume_phsa;\n-    case BRIG_OPCODE_WORKITEMFLATABSID:\n-    case BRIG_OPCODE_WORKITEMABSID:\n-      return m_is_kernel;\n-    default:\n-      return false;\n-    };\n-}\n-\n-/* In case the HSA instruction must be implemented using a builtin,\n-   this function is called to get the correct builtin function.\n-   TYPE is the instruction tree type, BRIG_OPCODE the opcode of the\n-   brig instruction and BRIG_TYPE the brig instruction's type.  */\n-\n-tree\n-brig_function::get_builtin_for_hsa_opcode\n-  (tree type, BrigOpcode16_t brig_opcode, BrigType16_t brig_type) const\n-{\n-  tree builtin = NULL_TREE;\n-  tree builtin_type = type;\n-\n-  /* For vector types, first find the scalar version of the builtin.  */\n-  if (type != NULL_TREE && VECTOR_TYPE_P (type))\n-    builtin_type = TREE_TYPE (type);\n-  BrigType16_t brig_inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n-\n-  /* Some BRIG opcodes can use the same builtins for unsigned and\n-     signed types.  Force these cases to unsigned types.  */\n-\n-  if (brig_opcode == BRIG_OPCODE_BORROW\n-      || brig_opcode == BRIG_OPCODE_CARRY\n-      || brig_opcode == BRIG_OPCODE_LASTBIT\n-      || brig_opcode == BRIG_OPCODE_BITINSERT)\n-    {\n-      if (brig_type == BRIG_TYPE_S32)\n-\tbrig_type = BRIG_TYPE_U32;\n-      else if (brig_type == BRIG_TYPE_S64)\n-\tbrig_type = BRIG_TYPE_U64;\n-    }\n-\n-  switch (brig_opcode)\n-    {\n-    case BRIG_OPCODE_FLOOR:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_FLOOR);\n-      break;\n-    case BRIG_OPCODE_CEIL:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_CEIL);\n-      break;\n-    case BRIG_OPCODE_SQRT:\n-    case BRIG_OPCODE_NSQRT:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_SQRT);\n-      break;\n-    case BRIG_OPCODE_RINT:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_RINT);\n-      break;\n-    case BRIG_OPCODE_TRUNC:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_TRUNC);\n-      break;\n-    case BRIG_OPCODE_COPYSIGN:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_COPYSIGN);\n-      break;\n-    case BRIG_OPCODE_NSIN:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_SIN);\n-      break;\n-    case BRIG_OPCODE_NLOG2:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_LOG2);\n-      break;\n-    case BRIG_OPCODE_NEXP2:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_EXP2);\n-      break;\n-    case BRIG_OPCODE_FMA:\n-    case BRIG_OPCODE_NFMA:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_FMA);\n-      break;\n-    case BRIG_OPCODE_NCOS:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_COS);\n-      break;\n-    case BRIG_OPCODE_POPCOUNT:\n-      /* Popcount should be typed by its argument type (the return value\n-\t is always u32).  Let's use a b64 version for also for b32 for now.  */\n-      return builtin_decl_explicit (BUILT_IN_POPCOUNTL);\n-    case BRIG_OPCODE_BORROW:\n-      /* Borrow uses the same builtin for unsigned and signed types.  */\n-      if (brig_type == BRIG_TYPE_S32 || brig_type == BRIG_TYPE_U32)\n-\treturn builtin_decl_explicit (BUILT_IN_HSAIL_BORROW_U32);\n-      else\n-\treturn builtin_decl_explicit (BUILT_IN_HSAIL_BORROW_U64);\n-    case BRIG_OPCODE_CARRY:\n-      /* Carry also uses the same builtin for unsigned and signed types.  */\n-      if (brig_type == BRIG_TYPE_S32 || brig_type == BRIG_TYPE_U32)\n-\treturn builtin_decl_explicit (BUILT_IN_HSAIL_CARRY_U32);\n-      else\n-\treturn builtin_decl_explicit (BUILT_IN_HSAIL_CARRY_U64);\n-    default:\n-\n-      /* Use our builtin index for finding a proper builtin for the BRIG\n-\t opcode and BRIG type.  This takes care most of the builtin cases,\n-\t the special cases are handled in the separate 'case' statements\n-\t above.  */\n-      builtin_map::const_iterator i\n-\t= s_custom_builtins.find (std::make_pair (brig_opcode, brig_type));\n-      if (i != s_custom_builtins.end ())\n-\treturn (*i).second;\n-\n-      if (brig_inner_type != brig_type)\n-\t{\n-\t  /* Try to find a scalar built-in we could use.  */\n-\t  i = s_custom_builtins.find\n-\t    (std::make_pair (brig_opcode, brig_inner_type));\n-\t  if (i != s_custom_builtins.end ())\n-\t    return (*i).second;\n-\t}\n-\n-      /* In case this is an fp16 operation that is promoted to fp32,\n-\t try to find a fp32 scalar built-in.  */\n-      if (brig_inner_type == BRIG_TYPE_F16)\n-\t{\n-\t  i = s_custom_builtins.find\n-\t    (std::make_pair (brig_opcode, BRIG_TYPE_F32));\n-\t  if (i != s_custom_builtins.end ())\n-\t    return (*i).second;\n-\t}\n-      gcc_unreachable ();\n-    }\n-\n-  if (VECTOR_TYPE_P (type) && builtin != NULL_TREE)\n-    {\n-      /* Try to find a vectorized version of the built-in.\n-\t TODO: properly assert that builtin is a mathfn builtin? */\n-      tree vec_builtin\n-\t= targetm.vectorize.builtin_vectorized_function\n-\t(builtin_mathfn_code (builtin), type, type);\n-      if (vec_builtin != NULL_TREE)\n-\treturn vec_builtin;\n-      else\n-\treturn builtin;\n-    }\n-  if (builtin == NULL_TREE)\n-    gcc_unreachable ();\n-  return builtin;\n-}\n-\n-/* Unpacks the elements of the vector in VALUE to scalars (bit field\n-   references) in ELEMENTS.  */\n-\n-void\n-brig_function::unpack (tree value, tree_stl_vec &elements)\n-{\n-  size_t vec_size = int_size_in_bytes (TREE_TYPE (value));\n-  size_t element_size\n-    = int_size_in_bytes (TREE_TYPE (TREE_TYPE (value))) * BITS_PER_UNIT;\n-  size_t element_count\n-    = vec_size * BITS_PER_UNIT / element_size;\n-\n-  tree input_element_type = TREE_TYPE (TREE_TYPE (value));\n-\n-  value = add_temp_var (\"unpack_input\", value);\n-\n-  for (size_t i = 0; i < element_count; ++i)\n-    {\n-      tree element\n-\t= build3 (BIT_FIELD_REF, input_element_type, value,\n-\t\t  TYPE_SIZE (input_element_type),\n-\t\t  bitsize_int(i * element_size));\n-\n-      element = add_temp_var (\"scalar\", element);\n-      elements.push_back (element);\n-    }\n-}\n-\n-/* Pack the elements of the scalars in ELEMENTS to the returned vector.  */\n-\n-tree\n-brig_function::pack (tree_stl_vec &elements)\n-{\n-  size_t element_count = elements.size ();\n-\n-  gcc_assert (element_count > 1);\n-\n-  tree output_element_type = TREE_TYPE (elements.at (0));\n-\n-  vec<constructor_elt, va_gc> *constructor_vals = NULL;\n-  for (size_t i = 0; i < element_count; ++i)\n-    CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, elements.at (i));\n-\n-  tree vec_type = build_vector_type (output_element_type, element_count);\n-\n-  /* build_constructor creates a vector type which is not a vector_cst\n-     that requires compile time constant elements.  */\n-  tree vec = build_constructor (vec_type, constructor_vals);\n-\n-  /* Add a temp variable for readability.  */\n-  tree tmp_var = create_tmp_var (vec_type, \"vec_out\");\n-  tree vec_tmp_assign = build2 (MODIFY_EXPR, TREE_TYPE (tmp_var), tmp_var, vec);\n-  append_statement (vec_tmp_assign);\n-  return tmp_var;\n-}\n-\n-/* Returns true in case the given opcode needs to know about work-item context\n-   data.  In such case the context data is passed as a pointer to a work-item\n-   context object, as the last argument in the builtin call.  */\n-\n-bool\n-brig_function::needs_workitem_context_data\n-(BrigOpcode16_t brig_opcode)\n-{\n-  switch (brig_opcode)\n-    {\n-    case BRIG_OPCODE_WORKITEMABSID:\n-    case BRIG_OPCODE_WORKITEMFLATABSID:\n-    case BRIG_OPCODE_WORKITEMFLATID:\n-    case BRIG_OPCODE_CURRENTWORKITEMFLATID:\n-    case BRIG_OPCODE_WORKITEMID:\n-    case BRIG_OPCODE_WORKGROUPID:\n-    case BRIG_OPCODE_WORKGROUPSIZE:\n-    case BRIG_OPCODE_CURRENTWORKGROUPSIZE:\n-    case BRIG_OPCODE_GRIDGROUPS:\n-    case BRIG_OPCODE_GRIDSIZE:\n-    case BRIG_OPCODE_DIM:\n-    case BRIG_OPCODE_PACKETID:\n-    case BRIG_OPCODE_PACKETCOMPLETIONSIG:\n-    case BRIG_OPCODE_BARRIER:\n-    case BRIG_OPCODE_WAVEBARRIER:\n-    case BRIG_OPCODE_ARRIVEFBAR:\n-    case BRIG_OPCODE_INITFBAR:\n-    case BRIG_OPCODE_JOINFBAR:\n-    case BRIG_OPCODE_LEAVEFBAR:\n-    case BRIG_OPCODE_RELEASEFBAR:\n-    case BRIG_OPCODE_WAITFBAR:\n-    case BRIG_OPCODE_CUID:\n-    case BRIG_OPCODE_MAXCUID:\n-    case BRIG_OPCODE_DEBUGTRAP:\n-    case BRIG_OPCODE_GROUPBASEPTR:\n-    case BRIG_OPCODE_KERNARGBASEPTR:\n-    case BRIG_OPCODE_ALLOCA:\n-      return true;\n-    default:\n-      return false;\n-    };\n-}\n-\n-/* Appends and returns a new temp variable and an accompanying assignment\n-   statement that stores the value of the given EXPR and has the given NAME.  */\n-\n-tree\n-brig_function::add_temp_var (std::string name, tree expr)\n-{\n-  tree temp_var = create_tmp_var (TREE_TYPE (expr), name.c_str ());\n-  tree assign = build2 (MODIFY_EXPR, TREE_TYPE (temp_var), temp_var, expr);\n-  append_statement (assign);\n-  return temp_var;\n-}\n-\n-/* Returns the integer constant value of the given node.\n-   If it's a cast, looks into the source of the cast.  */\n-\n-HOST_WIDE_INT\n-brig_function::int_constant_value (tree node)\n-{\n-  tree n = node;\n-  if (TREE_CODE (n) == VIEW_CONVERT_EXPR)\n-    n = TREE_OPERAND (n, 0);\n-  return int_cst_value (n);\n-}\n-\n-/* Returns the tree code that should be used to implement the given\n-   HSA instruction opcode (BRIG_OPCODE) for the given type of instruction\n-   (BRIG_TYPE).  In case the opcode cannot be mapped to a TREE node directly,\n-   returns TREE_LIST (if it can be emulated with a simple chain of tree\n-   nodes) or CALL_EXPR if the opcode should be implemented using a builtin\n-   call.  */\n-\n-tree_code\n-brig_function::get_tree_code_for_hsa_opcode\n-  (BrigOpcode16_t brig_opcode, BrigType16_t brig_type)\n-{\n-  BrigType16_t brig_inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n-  switch (brig_opcode)\n-    {\n-    case BRIG_OPCODE_NOP:\n-      return NOP_EXPR;\n-    case BRIG_OPCODE_ADD:\n-      return PLUS_EXPR;\n-    case BRIG_OPCODE_CMOV:\n-      if (brig_inner_type == brig_type)\n-\treturn COND_EXPR;\n-      else\n-\treturn VEC_COND_EXPR;\n-    case BRIG_OPCODE_SUB:\n-      return MINUS_EXPR;\n-    case BRIG_OPCODE_MUL:\n-    case BRIG_OPCODE_MUL24:\n-      return MULT_EXPR;\n-    case BRIG_OPCODE_MULHI:\n-    case BRIG_OPCODE_MUL24HI:\n-      return MULT_HIGHPART_EXPR;\n-    case BRIG_OPCODE_DIV:\n-      if (gccbrig_is_float_type (brig_inner_type))\n-\treturn RDIV_EXPR;\n-      else\n-\treturn TRUNC_DIV_EXPR;\n-    case BRIG_OPCODE_NEG:\n-      return NEGATE_EXPR;\n-    case BRIG_OPCODE_MIN:\n-      if (gccbrig_is_float_type (brig_inner_type))\n-\treturn CALL_EXPR;\n-      else\n-\treturn MIN_EXPR;\n-    case BRIG_OPCODE_MAX:\n-      if (gccbrig_is_float_type (brig_inner_type))\n-\treturn CALL_EXPR;\n-      else\n-\treturn MAX_EXPR;\n-    case BRIG_OPCODE_ABS:\n-      return ABS_EXPR;\n-    case BRIG_OPCODE_SHL:\n-      return LSHIFT_EXPR;\n-    case BRIG_OPCODE_SHR:\n-      return RSHIFT_EXPR;\n-    case BRIG_OPCODE_OR:\n-      return BIT_IOR_EXPR;\n-    case BRIG_OPCODE_XOR:\n-      return BIT_XOR_EXPR;\n-    case BRIG_OPCODE_AND:\n-      return BIT_AND_EXPR;\n-    case BRIG_OPCODE_NOT:\n-      return BIT_NOT_EXPR;\n-    case BRIG_OPCODE_RET:\n-      return RETURN_EXPR;\n-    case BRIG_OPCODE_MOV:\n-    case BRIG_OPCODE_LDF:\n-      return MODIFY_EXPR;\n-    case BRIG_OPCODE_LD:\n-    case BRIG_OPCODE_ST:\n-      return MEM_REF;\n-    case BRIG_OPCODE_BR:\n-      return GOTO_EXPR;\n-    case BRIG_OPCODE_REM:\n-      if (brig_type == BRIG_TYPE_U64 || brig_type == BRIG_TYPE_U32)\n-\treturn TRUNC_MOD_EXPR;\n-      else\n-\treturn CALL_EXPR;\n-    case BRIG_OPCODE_NRCP:\n-    case BRIG_OPCODE_NRSQRT:\n-      /* Implement as 1/f (x).  gcc should pattern detect that and\n-\t use a native instruction, if available, for it.  */\n-      return TREE_LIST;\n-    case BRIG_OPCODE_FMA:\n-    case BRIG_OPCODE_FLOOR:\n-    case BRIG_OPCODE_CEIL:\n-    case BRIG_OPCODE_SQRT:\n-    case BRIG_OPCODE_NSQRT:\n-    case BRIG_OPCODE_RINT:\n-    case BRIG_OPCODE_TRUNC:\n-    case BRIG_OPCODE_POPCOUNT:\n-    case BRIG_OPCODE_COPYSIGN:\n-    case BRIG_OPCODE_NCOS:\n-    case BRIG_OPCODE_NSIN:\n-    case BRIG_OPCODE_NLOG2:\n-    case BRIG_OPCODE_NEXP2:\n-    case BRIG_OPCODE_NFMA:\n-      /* Class has type B1 regardless of the float type, thus\n-\t the below builtin map search cannot find it.  */\n-    case BRIG_OPCODE_CLASS:\n-    case BRIG_OPCODE_WORKITEMABSID:\n-      return CALL_EXPR;\n-    default:\n-\n-      /* Some BRIG opcodes can use the same builtins for unsigned and\n-\t signed types.  Force these cases to unsigned types.\n-      */\n-\n-      if (brig_opcode == BRIG_OPCODE_BORROW\n-\t  || brig_opcode == BRIG_OPCODE_CARRY\n-\t  || brig_opcode == BRIG_OPCODE_LASTBIT\n-\t  || brig_opcode == BRIG_OPCODE_BITINSERT)\n-\t{\n-\t  if (brig_type == BRIG_TYPE_S32)\n-\t    brig_type = BRIG_TYPE_U32;\n-\t  else if (brig_type == BRIG_TYPE_S64)\n-\t    brig_type = BRIG_TYPE_U64;\n-\t}\n-\n-\n-      builtin_map::const_iterator i\n-\t= s_custom_builtins.find (std::make_pair (brig_opcode, brig_type));\n-      if (i != s_custom_builtins.end ())\n-\treturn CALL_EXPR;\n-      else if (s_custom_builtins.find\n-\t       (std::make_pair (brig_opcode, brig_inner_type))\n-\t       != s_custom_builtins.end ())\n-\treturn CALL_EXPR;\n-      if (brig_inner_type == BRIG_TYPE_F16\n-\t  && s_custom_builtins.find\n-\t  (std::make_pair (brig_opcode, BRIG_TYPE_F32))\n-\t  != s_custom_builtins.end ())\n-\treturn CALL_EXPR;\n-      break;\n-    }\n-  return TREE_LIST; /* Emulate using a chain of nodes.  */\n-}\n-\n-/* Inform of an update to the REG_VAR.  */\n-\n-void\n-brig_function::add_reg_var_update (tree reg_var, tree var)\n-{\n-  if (var == m_abs_id_vars[0] || var == m_abs_id_vars[1]\n-      || var == m_abs_id_vars[2] || var == m_local_id_vars[0]\n-      || var == m_local_id_vars[1] || var == m_local_id_vars[2])\n-    m_id_val_defs [reg_var] = var;\n-  else\n-    {\n-      /* Possible overwrite of an ID value.  */\n-\n-      id_val_map::iterator i = m_id_val_defs.find (reg_var);\n-      if (i != m_id_val_defs.end())\n-\tm_id_val_defs.erase (i);\n-    }\n-}\n-\n-/* If the REG_VAR is known to contain an ID value at this point in\n-   the basic block, return true.  */\n-\n-bool\n-brig_function::is_id_val (tree reg_var)\n-{\n-  id_val_map::iterator i = m_id_val_defs.find (reg_var);\n-  return i != m_id_val_defs.end();\n-}\n-\n-/* Return an ID value for the given REG_VAR if its known to contain\n-   one at this point in the BB, NULL_TREE otherwise.  */\n-\n-tree\n-brig_function::id_val (tree reg_var)\n-{\n-  id_val_map::iterator i = m_id_val_defs.find (reg_var);\n-  if (i != m_id_val_defs.end())\n-    return (*i).second;\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Informs of starting a new basic block.  Called when generating\n-   a label, a call, a jump, or a return.  */\n-\n-void\n-brig_function::start_new_bb ()\n-{\n-  m_id_val_defs.clear ();\n-}"}, {"sha": "8a9c3ba180893b808b49e3ce9dec00b643b9736d", "filename": "gcc/brig/brigfrontend/brig-function.h", "status": "removed", "additions": 0, "deletions": 267, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,267 +0,0 @@\n-/* brig-function.h -- declaration of brig_function class.\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef BRIG_FUNCTION_H\n-#define BRIG_FUNCTION_H\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"ansidecl.h\"\n-#include \"coretypes.h\"\n-#include \"opts.h\"\n-#include \"tree.h\"\n-#include \"tree-iterator.h\"\n-#include \"hsa-brig-format.h\"\n-#include \"brig-util.h\"\n-\n-#include <map>\n-#include <string>\n-#include <vector>\n-#include <set>\n-\n-#include \"phsa.h\"\n-\n-class brig_to_generic;\n-\n-typedef std::map<std::string, tree> label_index;\n-typedef std::map<const BrigDirectiveVariable *, tree> variable_index;\n-typedef std::vector<tree> tree_stl_vec;\n-\n-/* Holds data for the currently built GENERIC function.  */\n-\n-class brig_function\n-{\n-public:\n-  typedef std::map<const BrigDirectiveVariable *, size_t> var_offset_table;\n-\n-private:\n-  struct reg_decl_index_entry\n-  {\n-    tree m_var_decl;\n-  };\n-\n-public:\n-  brig_function (const BrigDirectiveExecutable *exec, brig_to_generic *parent);\n-  ~brig_function ();\n-\n-  tree arg_variable (const BrigDirectiveVariable *var) const;\n-  void add_arg_variable (const BrigDirectiveVariable *brigVar, tree treeDecl);\n-\n-  void append_kernel_arg (const BrigDirectiveVariable *var, size_t size,\n-\t\t\t  size_t alignment);\n-\n-  size_t kernel_arg_offset (const BrigDirectiveVariable *var) const;\n-\n-  void add_id_variables ();\n-\n-  tree label (const std::string &name);\n-\n-  tree add_local_variable (std::string name, tree type);\n-\n-  size_t group_variable_segment_offset (const std::string &name) const;\n-\n-  bool has_group_variable (const std::string &name) const;\n-\n-  size_t group_segment_size () const;\n-\n-  tree get_m_var_declfor_reg (const BrigOperandRegister *reg);\n-\n-  bool convert_to_wg_function ();\n-\n-  void add_wi_loop (int dim, tree_stmt_iterator *header_entry,\n-\t\t    tree_stmt_iterator *branch_after);\n-\n-  tree emit_metadata (tree stmt_list);\n-  tree emit_launcher_and_metadata ();\n-\n-  tree append_statement (tree stmt);\n-\n-  void create_alloca_frame ();\n-\n-  void finish ();\n-  void finish_kernel ();\n-\n-  void append_return_stmt ();\n-\n-  bool has_function_scope_var (const BrigBase* var) const;\n-\n-  void analyze_calls ();\n-\n-  tree expand_builtin (BrigOpcode16_t brig_opcode, tree_stl_vec &operands);\n-\n-  tree expand_or_call_builtin (BrigOpcode16_t brig_opcode,\n-\t\t\t       BrigType16_t brig_type, tree arith_type,\n-\t\t\t       tree_stl_vec &operands);\n-  bool can_expand_builtin (BrigOpcode16_t brig_opcode) const;\n-\n-  tree get_builtin_for_hsa_opcode (tree type, BrigOpcode16_t brig_opcode,\n-\t\t\t\t   BrigType16_t brig_type) const;\n-\n-  void unpack (tree value, tree_stl_vec &elements);\n-  tree pack (tree_stl_vec &elements);\n-  tree add_temp_var (std::string name, tree expr);\n-\n-  static bool needs_workitem_context_data (BrigOpcode16_t brig_opcode);\n-  static HOST_WIDE_INT int_constant_value (tree node);\n-  static tree_code get_tree_code_for_hsa_opcode (BrigOpcode16_t brig_opcode,\n-\t\t\t\t\t\t BrigType16_t brig_type);\n-\n-  void start_new_bb ();\n-  void add_reg_var_update (tree reg_var, tree val);\n-  bool is_id_val (tree reg_var);\n-  tree id_val (tree reg_var);\n-\n-  const BrigDirectiveExecutable *m_brig_def;\n-\n-  bool m_is_kernel;\n-  bool m_is_finished;\n-  std::string m_name;\n-  tree m_current_bind_expr;\n-  tree m_func_decl;\n-  tree m_entry_label_stmt;\n-  tree m_exit_label;\n-\n-  /* The __context function argument.  */\n-  tree m_context_arg;\n-\n-  /* The __group_base_ptr argument in the current function.\n-     Points to the start of the group segment for the work-group.  */\n-  tree m_group_base_arg;\n-\n-   /* The __group_local_offset_ptr argument in the current function.  It\n-      contains the offset related to the group_base_ptr where the function's\n-      local area for group variables resides.  */\n-  tree m_group_local_offset_arg;\n-\n-  /* The __private_base_ptr argument in the current function.\n-     Points to the start of the private segment.  */\n-  tree m_private_base_arg;\n-\n-  /* The return value variable for the current function.  */\n-  tree m_ret_value;\n-\n-  /* The offsets of the kernel arguments in the __arg blob\n-     pointing to the kernel argument space.  */\n-  size_t m_next_kernarg_offset;\n-\n-  /* The largest kernel argument variable alignment.  */\n-  size_t m_kernarg_max_align;\n-\n-  var_offset_table m_kernarg_offsets;\n-\n-  /* Argument variables in the currently handled binding expression\n-     (argument segment).  */\n-  variable_index m_arg_variables;\n-\n-  /* The brig variable for the function return value.  */\n-  const BrigDirectiveVariable *m_ret_value_brig_var;\n-\n-  /* The function local temporary variable for the return value.  */\n-  tree m_ret_temp;\n-\n-  /* Labels in the current function are collected here so we can refer\n-     to them from jumps before they have been placed to the function.  */\n-  label_index m_label_index;\n-\n-  /* If the kernel contains at least one barrier, this is set to true.  */\n-  bool m_has_barriers;\n-\n-  /* True if the function has at least one alloca instruction.  */\n-  bool m_has_allocas;\n-\n-  /* If the kernel contains at least one function call that _may_\n-     contain a barrier call, this is set to true.  */\n-  bool m_has_function_calls_with_barriers;\n-\n-  /* Set to true after this function has been analyzed for barrier and\n-     dispatch packet instruction usage in the final call graph analysis.  */\n-  bool m_calls_analyzed;\n-\n-  /* True in case the function was successfully converted to a WG function.  */\n-  bool m_is_wg_function;\n-\n-  /* Work-item ID related variables are cached in the entry of the kernel\n-     function in order to use them directly in address computations, leading\n-     to more efficient optimizations.  The references to the local variables\n-     are stored here.  */\n-  tree m_local_id_vars[3];\n-  tree m_cur_wg_size_vars[3];\n-  tree m_wg_id_vars[3];\n-  tree m_wg_size_vars[3];\n-  tree m_grid_size_vars[3];\n-  /* Explicitly computed WG base for the absolute IDs which is used\n-     as the initial value when looping that dimension.   We update\n-     the abs id with ++ to make it easy for the vectorizer.  */\n-  tree m_abs_id_base_vars[3];\n-  tree m_abs_id_vars[3];\n-\n-  /* Set to true in case the kernel contains at least one dispatch packet\n-     (work-item ID-related) builtin call that could not be expanded to\n-     tree nodes.  */\n-  bool m_has_unexpanded_dp_builtins;\n-\n-  /* Points to the instruction after which the real kernel code starts.\n-     Usually points to the last WI ID variable initialization statement.  */\n-  tree_stmt_iterator m_kernel_entry;\n-\n-  /* True if we are currently generating the contents of an arg block.  */\n-  bool m_generating_arg_block;\n-\n-  /* A collection of function scope variables seen so far for resolving\n-     variable references vs. module scope declarations.  */\n-  std::set<const BrigBase*> m_function_scope_vars;\n-\n-  /* The functions called by this function.  */\n-  std::vector<tree> m_called_functions;\n-\n-  /* Stores the kernel scope group variable offsets if the function is\n-     a kernel.  */\n-  group_variable_offset_index m_local_group_variables;\n-\n-  brig_to_generic *m_parent;\n-  /* The metadata of the function that should be stored with the binary and\n-     passed to the HSA runtime:  */\n-  phsa_descriptor m_descriptor;\n-\n-private:\n-\n-  tree get_tree_type_for_hsa_reg (const BrigOperandRegister *reg) const;\n-\n-  /* Bookkeeping for the different HSA registers and their tree declarations\n-     for the currently generated function.  */\n-  reg_decl_index_entry *m_regs[BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT];\n-\n-  /* Map for keeping book reads of ID variables, which can be propagated\n-     to uses in address expressions to produce cleaner indexing functions\n-     with unnecessary casts stripped off, etc.  */\n-  typedef std::map<tree, tree> id_val_map;\n-\n-  /* Keeps track of ID values alive in registers in the currently\n-     processed BB.  */\n-  id_val_map m_id_val_defs;\n-\n-  /* HSAIL-specific builtin functions not yet integrated to gcc.  */\n-  typedef std::map<std::pair<BrigOpcode16_t, BrigType16_t>, tree> builtin_map;\n-\n-  static builtin_map s_custom_builtins;\n-};\n-\n-#endif"}, {"sha": "3c42468630781515c8149c2c6d53ac6df5c91c34", "filename": "gcc/brig/brigfrontend/brig-inst-mod-handler.cc", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-inst-mod-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-inst-mod-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-inst-mod-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,58 +0,0 @@\n-/* brig-inst-mod-handler.cc -- brig rounding moded instruction handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-\n-#include \"gimple-expr.h\"\n-#include \"errors.h\"\n-\n-size_t\n-brig_inst_mod_handler::generate (const BrigBase *base)\n-{\n-  brig_basic_inst_handler basic_handler (m_parent);\n-  return basic_handler (base);\n-}\n-\n-const BrigAluModifier8_t *\n-brig_inst_mod_handler::modifier (const BrigBase *base) const\n-{\n-  const BrigInstMod *inst = (const BrigInstMod *) base;\n-  return &inst->modifier;\n-}\n-\n-const BrigRound8_t *\n-brig_inst_mod_handler::round (const BrigBase *base) const\n-{\n-  const BrigInstMod *inst = (const BrigInstMod *) base;\n-  return &inst->round;\n-}\n-\n-/* This used to inject fesetround () calls to control the rounding mode of the\n-   actual executed floating point operation.  It turned out that supporting\n-   conversions using fesetround calls won't work in gcc due to it not being\n-   able to restrict code motions across calls at the moment.  This\n-   functionality is therefore disabled for now until a better solution is\n-   found or if fesetround () is fixed in gcc.  */\n-size_t\n-brig_inst_mod_handler::operator () (const BrigBase *base)\n-{\n-  return generate (base);\n-}"}, {"sha": "4cf63376893a0fdb027ce069b32e60bc36aebcbf", "filename": "gcc/brig/brigfrontend/brig-label-handler.cc", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-label-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-label-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-label-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,40 +0,0 @@\n-/* brig-label-handler.cc -- brig label directive handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-\n-size_t\n-brig_directive_label_handler::operator () (const BrigBase *base)\n-{\n-  const BrigDirectiveLabel *brig_label = (const BrigDirectiveLabel *) base;\n-\n-  const BrigData *label_name = m_parent.get_brig_data_entry (brig_label->name);\n-\n-  std::string label_str ((const char *) (label_name->bytes),\n-\t\t\t label_name->byteCount);\n-\n-  m_parent.m_cf->start_new_bb ();\n-\n-  tree stmt = build_stmt (LABEL_EXPR, m_parent.m_cf->label (label_str));\n-  m_parent.m_cf->append_statement (stmt);\n-\n-  return base->byteCount;\n-}"}, {"sha": "e0a3c05f7998798b1be6e06bb689b81753d822c2", "filename": "gcc/brig/brigfrontend/brig-lane-inst-handler.cc", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-lane-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-lane-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-lane-inst-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,85 +0,0 @@\n-/* brig-lane-inst-handler.cc -- brig lane instruction handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-#include \"errors.h\"\n-#include \"diagnostic-core.h\"\n-#include \"brig-util.h\"\n-\n-brig_lane_inst_handler::brig_lane_inst_handler (brig_to_generic &parent)\n-  : brig_code_entry_handler (parent)\n-{\n-}\n-\n-size_t\n-brig_lane_inst_handler::operator () (const BrigBase *base)\n-{\n-  const BrigInstLane &inst = *(const BrigInstLane *) base;\n-  tree_stl_vec operands = build_operands (inst.base);\n-\n-  tree expr = NULL_TREE;\n-  if (inst.base.opcode == BRIG_OPCODE_ACTIVELANECOUNT)\n-    {\n-      /* Because we are fixed to single WI per wave, it's enough to\n-\t just check the src value of the single work item itself.  */\n-      expr = build2 (NE_EXPR, uint32_type_node,\n-\t\t     build_zero_cst (uint32_type_node), operands[1]);\n-    }\n-  else if (inst.base.opcode == BRIG_OPCODE_ACTIVELANEID)\n-    {\n-      expr = build_zero_cst (uint32_type_node);\n-    }\n-  else if (inst.base.opcode == BRIG_OPCODE_ACTIVELANEMASK)\n-    {\n-      tree u64_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U64);\n-      tree zero_cst = build_zero_cst (u64_type);\n-      expr = build2 (NE_EXPR, u64_type, zero_cst, operands[1]);\n-\n-      tree_stl_vec elements;\n-      elements.push_back (expr);\n-      elements.push_back (zero_cst);\n-      elements.push_back (zero_cst);\n-      elements.push_back (zero_cst);\n-\n-      expr = m_parent.m_cf->pack (elements);\n-    }\n-  else if (inst.base.opcode == BRIG_OPCODE_ACTIVELANEPERMUTE)\n-    {\n-      tree src = operands[1];\n-      tree identity = operands[3];\n-      tree use_identity = operands[4];\n-\n-      /* When WAVESIZE is 1, we either select the src of the work-item\n-\t itself or 'identity' in case use_identity is 1.  */\n-\n-      tree cmp = build2 (EQ_EXPR, uint32_type_node,\n-\t\t\t build_int_cstu (TREE_TYPE (use_identity), 1),\n-\t\t\t use_identity);\n-\n-      expr = build3 (COND_EXPR, TREE_TYPE (src), cmp, identity, src);\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  build_output_assignment (inst.base, operands[0], expr);\n-\n-  return base->byteCount;\n-}"}, {"sha": "250c86d48033fe6fdae3265726618cde5a3e3fc3", "filename": "gcc/brig/brigfrontend/brig-machine.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.c?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,44 +0,0 @@\n-/* brig-machine.c -- gccbrig machine queries\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"brig-machine.h\"\n-\n-/* Return the numerical address space id for the segment in the current\n-   target.  Currently a dummy function that always returns 0, serves as\n-   a placeholder for multi-AS machines.  */\n-\n-unsigned\n-gccbrig_get_target_addr_space_id (BrigSegment8_t)\n-{\n-  return 0;\n-}\n-\n-/* Return the WAVESIZE for the current target.  For now a dummy placeholder\n-   returning always 1.  */\n-\n-unsigned\n-gccbrig_get_target_wavesize ()\n-{\n-  return 1;\n-}"}, {"sha": "d3fab9953d61cddaca5c5b08a746ff0552fa3f24", "filename": "gcc/brig/brigfrontend/brig-machine.h", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.h?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,33 +0,0 @@\n-/* brig-machine.h -- gccbrig machine queries\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_BRIG_MACHINE_H\n-#define GCC_BRIG_MACHINE_H\n-\n-#include \"hsa-brig-format.h\"\n-\n-/* These functions should be eventually converted to machine info queries and\n-   redefined at backends.  At that point make these functions delegate to\n-   those.  */\n-\n-unsigned gccbrig_get_target_addr_space_id (BrigSegment8_t segment);\n-\n-unsigned gccbrig_get_target_wavesize ();\n-\n-#endif"}, {"sha": "9b09e98afa6a2c1f196ea6e6563d665787e00f71", "filename": "gcc/brig/brigfrontend/brig-mem-inst-handler.cc", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,178 +0,0 @@\n-/* brig-mem-inst-handler.cc -- brig memory inst handler\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-\n-#include \"errors.h\"\n-#include \"brig-util.h\"\n-#include \"gimple-expr.h\"\n-#include \"print-tree.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"convert.h\"\n-#include \"diagnostic-core.h\"\n-\n-tree\n-brig_mem_inst_handler::build_mem_access (const BrigInstBase *brig_inst,\n-\t\t\t\t\t tree addr, tree data)\n-{\n-  bool is_load = brig_inst->opcode == BRIG_OPCODE_LD;\n-  bool is_store = brig_inst->opcode == BRIG_OPCODE_ST;\n-\n-  if (!is_load && !is_store)\n-    gcc_unreachable ();\n-\n-  tree instr_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n-\n-  /* In case of {ld,st}_v{2,4}. Note: since 'register' variables may\n-     be any type, even a vector type, we distinguish the registers\n-     from operand lists by checking for constructor nodes (which\n-     operand lists are represented as).  */\n-  if (VECTOR_TYPE_P (TREE_TYPE (data)) && TREE_CODE (data) == CONSTRUCTOR)\n-    instr_type = TREE_TYPE (data);\n-\n-  tree ptype = build_pointer_type (instr_type);\n-\n-  /* The HSAIL mem instructions are unaligned by default.\n-     TODO: exploit the align modifier, it should lead to faster code.\n-  */\n-  tree unaligned_type = build_aligned_type (instr_type, 8);\n-\n-  /* Create a mem ref from the previous result, without offset.  */\n-  tree mem_ref\n-    = build2 (MEM_REF, unaligned_type, addr, build_int_cst (ptype, 0));\n-\n-  if (is_load)\n-    {\n-      /* Add a temporary variable so there won't be multiple\n-\t reads in case of vector unpack.  */\n-      mem_ref = m_parent.m_cf->add_temp_var (\"mem_read\", mem_ref);\n-      return build_output_assignment (*brig_inst, data, mem_ref);\n-    }\n-  else\n-    {\n-      tree stmt = build2 (MODIFY_EXPR, TREE_TYPE (mem_ref), mem_ref, data);\n-      return m_parent.m_cf->append_statement (stmt);\n-    }\n-  return mem_ref;\n-}\n-\n-size_t\n-brig_mem_inst_handler::operator () (const BrigBase *base)\n-{\n-  const BrigInstBase *brig_inst\n-    = (const BrigInstBase *) &((const BrigInstBasic *) base)->base;\n-\n-  if (brig_inst->opcode == BRIG_OPCODE_ALLOCA)\n-    {\n-      tree_stl_vec operands = build_operands (*brig_inst);\n-      size_t alignment = 1;\n-      const BrigInstMem *mem_inst = (const BrigInstMem *) brig_inst;\n-      if (mem_inst->align != BRIG_ALIGNMENT_NONE)\n-\t{\n-\t  alignment = 1 << (mem_inst->align - 1);\n-\t}\n-\n-      tree align_opr = build_int_cstu (size_type_node, alignment);\n-      tree_stl_vec inputs;\n-      inputs.push_back (operands[1]);\n-      inputs.push_back (align_opr);\n-      tree builtin_call\n-\t= m_parent.m_cf->expand_or_call_builtin (BRIG_OPCODE_ALLOCA,\n-\t\t\t\t\t\t BRIG_TYPE_U32,\n-\t\t\t\t\t\t uint32_type_node, inputs);\n-      build_output_assignment (*brig_inst, operands[0], builtin_call);\n-      m_parent.m_cf->m_has_allocas = true;\n-      return base->byteCount;\n-    }\n-\n-  tree instr_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n-\n-  const BrigData *operand_entries\n-    = m_parent.get_brig_data_entry (brig_inst->operands);\n-\n-  uint32_t data_operand_offset;\n-  memcpy (&data_operand_offset, &operand_entries->bytes, 4);\n-\n-  const BrigBase *operand\n-    = m_parent.get_brig_operand_entry (data_operand_offset);\n-\n-  const BrigData *operandData = NULL;\n-\n-  bool is_store = brig_inst->opcode == BRIG_OPCODE_ST;\n-\n-  bool is_three_element_vector_access\n-    = operand->kind == BRIG_KIND_OPERAND_OPERAND_LIST\n-      && (operandData = m_parent.get_brig_data_entry\n-\t  (((const BrigOperandOperandList *) operand)->elements))\n-      && operandData->byteCount / 4 == 3;\n-\n-  if (is_three_element_vector_access)\n-    {\n-      /* We need to scalarize the 3-element vector accesses here\n-\t because gcc assumes the GENERIC vector datatypes are of two exponent\n-\t size internally.  */\n-      size_t bytes = operandData->byteCount;\n-      const BrigOperandOffset32_t *operand_ptr\n-\t= (const BrigOperandOffset32_t *) operandData->bytes;\n-\n-      uint32_t addr_operand_offset;\n-      memcpy (&addr_operand_offset, &operand_entries->bytes + 4, 4);\n-\n-      const BrigOperandAddress *addr_operand\n-\t= (const BrigOperandAddress *) m_parent.get_brig_operand_entry\n-\t(addr_operand_offset);\n-\n-      tree address_base = build_address_operand (*brig_inst, *addr_operand);\n-\n-      uint32_t address_offset = 0;\n-      while (bytes > 0)\n-\t{\n-\t  BrigOperandOffset32_t offset = *operand_ptr;\n-\t  const BrigBase *operand_element\n-\t    = m_parent.get_brig_operand_entry (offset);\n-\t  tree data\n-\t    = build_tree_operand (*brig_inst, *operand_element, instr_type);\n-\n-\t  tree ptr_offset = build_int_cst (size_type_node, address_offset);\n-\t  tree address = build2 (POINTER_PLUS_EXPR, TREE_TYPE (address_base),\n-\t\t\t\t address_base, ptr_offset);\n-\n-\t  if (is_store && TREE_TYPE (data) != instr_type)\n-\t    data = build_resize_convert_view (instr_type, data);\n-\n-\t  build_mem_access (brig_inst, address, data);\n-\n-\t  address_offset += int_size_in_bytes (instr_type);\n-\t  ++operand_ptr;\n-\t  bytes -= 4;\n-\t}\n-    }\n-  else\n-    {\n-      tree_stl_vec operands = build_operands (*brig_inst);\n-\n-      tree &data = operands.at (0);\n-      tree &addr = operands.at (1);\n-      build_mem_access (brig_inst, addr, data);\n-    }\n-\n-  return base->byteCount;\n-}"}, {"sha": "f8eeebfe62eb1f66dfaf8341c6924c206652de5e", "filename": "gcc/brig/brigfrontend/brig-module-handler.cc", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-module-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-module-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-module-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,41 +0,0 @@\n-/* brig-module-handler.cc -- brig module directive handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-#include \"diagnostic-core.h\"\n-\n-size_t\n-brig_directive_module_handler::operator () (const BrigBase *base)\n-{\n-  const BrigDirectiveModule* mod = (const BrigDirectiveModule*)base;\n-  m_parent.m_module_name = m_parent.get_string (mod->name).substr (1);\n-  if (mod->hsailMajor != 1 || mod->hsailMinor != 0)\n-    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE\n-\t\t \"HSAIL version not supported. HSAIL 1.0 required.\");\n-  if (mod->machineModel != BRIG_MACHINE_LARGE)\n-    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE\n-\t\t \"Only HSA 'large' machine model supported.\");\n-  /* Do not check for the profile as the runtime conformance suite tests\n-     with 'full' profile BRIGs even though they don't use any full profile\n-     features.  This allows us to run the conformance suite with the\n-     BRIG FE.  */\n-  return base->byteCount;\n-}"}, {"sha": "3c88bc6dda1e134c8f489058cbab6ecd374aaf74", "filename": "gcc/brig/brigfrontend/brig-queue-inst-handler.cc", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-queue-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-queue-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-queue-inst-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,93 +0,0 @@\n-/* brig-queue-inst-handler.cc -- brig user mode queue related instruction\n-   handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include <sstream>\n-\n-#include \"brig-code-entry-handler.h\"\n-#include \"brig-util.h\"\n-#include \"convert.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"errors.h\"\n-#include \"diagnostic-core.h\"\n-#include \"brig-builtins.h\"\n-\n-brig_queue_inst_handler::brig_queue_inst_handler (brig_to_generic &parent)\n-  : brig_code_entry_handler (parent)\n-{\n-}\n-\n-size_t\n-brig_queue_inst_handler::operator () (const BrigBase *base)\n-{\n-  const BrigInstBase &inst_base = *(const BrigInstBase *) base;\n-\n-  tree_stl_vec operands = build_operands (inst_base);\n-\n-  if (inst_base.opcode == BRIG_OPCODE_LDQUEUEWRITEINDEX\n-      || inst_base.opcode == BRIG_OPCODE_LDQUEUEREADINDEX)\n-    {\n-      tree builtin\n-\t= inst_base.opcode == BRIG_OPCODE_LDQUEUEWRITEINDEX\n-\t? builtin_decl_explicit (BUILT_IN_HSAIL_LDQUEUEWRITEINDEX)\n-\t: builtin_decl_explicit (BUILT_IN_HSAIL_LDQUEUEREADINDEX);\n-\n-      tree expr\n-\t= call_builtin (builtin, 1, uint64_type_node,\n-\t\t\tuint64_type_node, operands[1]);\n-      build_output_assignment (inst_base, operands[0], expr);\n-    }\n-  else if (inst_base.opcode == BRIG_OPCODE_STQUEUEWRITEINDEX\n-\t   || inst_base.opcode == BRIG_OPCODE_STQUEUEREADINDEX)\n-    {\n-      tree builtin\n-\t= inst_base.opcode == BRIG_OPCODE_STQUEUEWRITEINDEX\n-\t? builtin_decl_explicit (BUILT_IN_HSAIL_STQUEUEWRITEINDEX)\n-\t: builtin_decl_explicit (BUILT_IN_HSAIL_STQUEUEREADINDEX);\n-\n-      call_builtin (builtin, 2, void_type_node,\n-\t\t    uint64_type_node, operands[0], uint64_type_node,\n-\t\t    operands[1]);\n-    }\n-  else if (inst_base.opcode == BRIG_OPCODE_ADDQUEUEWRITEINDEX)\n-    {\n-      tree builtin = builtin_decl_explicit (BUILT_IN_HSAIL_ADDQUEUEWRITEINDEX);\n-\n-      tree expr = call_builtin (builtin, 2,\n-\t\t\t\tuint64_type_node, uint64_type_node, operands[1],\n-\t\t\t\tuint64_type_node, operands[2]);\n-      build_output_assignment (inst_base, operands[0], expr);\n-    }\n-  else if (inst_base.opcode == BRIG_OPCODE_CASQUEUEWRITEINDEX)\n-    {\n-      tree builtin = builtin_decl_explicit (BUILT_IN_HSAIL_CASQUEUEWRITEINDEX);\n-\n-      tree expr\n-\t= call_builtin (builtin, 3, uint64_type_node,\n-\t\t\tuint64_type_node, operands[1], uint64_type_node,\n-\t\t\toperands[2], uint64_type_node, operands[3]);\n-      build_output_assignment (inst_base, operands[0], expr);\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  return base->byteCount;\n-}"}, {"sha": "9c22715a909a5d3820773eccbcbf9ba40f7f7067", "filename": "gcc/brig/brigfrontend/brig-seg-inst-handler.cc", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-seg-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-seg-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-seg-inst-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,146 +0,0 @@\n-/* brig-seg-inst-handler.cc -- brig segment related instruction handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include <sstream>\n-\n-#include \"brig-code-entry-handler.h\"\n-#include \"brig-util.h\"\n-#include \"convert.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"errors.h\"\n-#include \"diagnostic-core.h\"\n-\n-brig_seg_inst_handler::brig_seg_inst_handler (brig_to_generic &parent)\n-  : brig_code_entry_handler (parent)\n-{\n-}\n-\n-size_t\n-brig_seg_inst_handler::operator () (const BrigBase *base)\n-{\n-  const BrigInstBase &inst_base = *(const BrigInstBase *) base;\n-\n-  std::vector<tree> operands = build_operands (inst_base);\n-\n-  tree expr = NULL_TREE;\n-\n-  if (inst_base.opcode == BRIG_OPCODE_STOF)\n-    {\n-      const BrigInstSegCvt &inst = *(const BrigInstSegCvt *) base;\n-\n-      if (inst.segment == BRIG_SEGMENT_GROUP)\n-\texpr = build2 (PLUS_EXPR, size_type_node,\n-\t\t       convert_to_integer (size_type_node,\n-\t\t\t\t\t   m_parent.m_cf->m_group_base_arg),\n-\t\t       convert_to_integer (size_type_node, operands[1]));\n-      else if (inst.segment == BRIG_SEGMENT_PRIVATE\n-\t       || inst.segment == BRIG_SEGMENT_SPILL)\n-\texpr = build2 (PLUS_EXPR, size_type_node,\n-\t\t       convert_to_integer (size_type_node,\n-\t\t\t\t\t   m_parent.m_cf->m_private_base_arg),\n-\t\t       convert_to_integer (size_type_node, operands[1]));\n-      else\n-       gcc_unreachable ();\n-\n-      if (!(inst.modifier & BRIG_SEG_CVT_NONULL))\n-\t{\n-\t  /* Need to convert the null value. -1 is used for 32b segments,\n-\t     and 0 for flat/global.  */\n-\t  tree cmp\n-\t    = build2 (EQ_EXPR, uint32_type_node,\n-\t\t      build_int_cstu (uint32_type_node, -1), operands[1]);\n-\n-\t  tree null_check = build3 (COND_EXPR, size_type_node, cmp,\n-\t\t\t\t    build_int_cstu (size_type_node, 0), expr);\n-\n-\t  expr = null_check;\n-\t}\n-    }\n-  else if (inst_base.opcode == BRIG_OPCODE_FTOS)\n-    {\n-      const BrigInstSegCvt &inst = *(const BrigInstSegCvt *) base;\n-\n-      if (inst.segment == BRIG_SEGMENT_GROUP)\n-\texpr = build2 (MINUS_EXPR, size_type_node,\n-\t\t       convert_to_integer (size_type_node,\n-\t\t\t\t\t   m_parent.m_cf->m_group_base_arg),\n-\t\t       convert_to_integer (size_type_node, operands[1]));\n-      else if (inst.segment == BRIG_SEGMENT_PRIVATE)\n-\texpr = build2 (MINUS_EXPR, size_type_node,\n-\t\t       convert_to_integer (size_type_node,\n-\t\t\t\t\t   m_parent.m_cf->m_private_base_arg),\n-\t\t       convert_to_integer (size_type_node, operands[1]));\n-      else\n-\tgcc_unreachable ();\n-\n-      if (!(inst.modifier & BRIG_SEG_CVT_NONULL))\n-\t{\n-\t  /* Need to convert the null value. -1 is used for 32b segments,\n-\t     and 0 for flat/global.  */\n-\t  tree cmp = build2 (EQ_EXPR, size_type_node,\n-\t\t\t     build_int_cstu (size_type_node, 0), operands[1]);\n-\n-\t  tree null_check\n-\t    = build3 (COND_EXPR, size_type_node, cmp,\n-\t\t      build_int_cstu (uint32_type_node, -1), expr);\n-\t  expr = null_check;\n-\t}\n-    }\n-  else if (inst_base.opcode == BRIG_OPCODE_NULLPTR)\n-    {\n-      const BrigInstSeg &inst = *(const BrigInstSeg *) base;\n-      if (inst.segment == BRIG_SEGMENT_GLOBAL\n-\t  || inst.segment == BRIG_SEGMENT_FLAT\n-\t  || inst.segment == BRIG_SEGMENT_READONLY)\n-\texpr = build_int_cstu (uint64_type_node, 0);\n-      else\n-\texpr = build_int_cstu (uint32_type_node, -1);\n-    }\n-  else if (inst_base.opcode == BRIG_OPCODE_SEGMENTP)\n-    {\n-      const BrigInstSegCvt &inst = *(const BrigInstSegCvt *) base;\n-\n-      tree builtin = NULL_TREE;\n-      switch (inst.segment)\n-\t{\n-\tcase BRIG_SEGMENT_GLOBAL:\n-\t  builtin = builtin_decl_explicit (BUILT_IN_HSAIL_SEGMENTP_GLOBAL);\n-\t  break;\n-\tcase BRIG_SEGMENT_GROUP:\n-\t  builtin = builtin_decl_explicit (BUILT_IN_HSAIL_SEGMENTP_GROUP);\n-\t  break;\n-\tcase BRIG_SEGMENT_PRIVATE:\n-\t  builtin = builtin_decl_explicit (BUILT_IN_HSAIL_SEGMENTP_PRIVATE);\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      expr = call_builtin (builtin, 2,\n-\t\t\t   uint32_type_node, uint64_type_node, operands[1],\n-\t\t\t   ptr_type_node, m_parent.m_cf->m_context_arg);\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  build_output_assignment (inst_base, operands[0], expr);\n-  return base->byteCount;\n-}"}, {"sha": "be3f01d1bfa10fd3875db668884c41c21dd45ce2", "filename": "gcc/brig/brigfrontend/brig-signal-inst-handler.cc", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-signal-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-signal-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-signal-inst-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,42 +0,0 @@\n-/* brig-signal-inst-handler.cc -- brig signal instruction handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include <sstream>\n-\n-#include \"brig-code-entry-handler.h\"\n-#include \"brig-util.h\"\n-#include \"fold-const.h\"\n-#include \"diagnostic.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"print-tree.h\"\n-#include \"convert.h\"\n-#include \"langhooks.h\"\n-#include \"gimple-expr.h\"\n-\n-size_t\n-brig_signal_inst_handler::operator () (const BrigBase *base)\n-{\n-  const BrigInstSignal *inst = (const BrigInstSignal *) base;\n-  BrigAtomicOperation8_t atomic_opcode;\n-  atomic_opcode = inst->signalOperation;\n-\n-  return generate_tree (inst->base, atomic_opcode);\n-}"}, {"sha": "62e8aecd22ba02716195701b5468dc8594e1dbdb", "filename": "gcc/brig/brigfrontend/brig-to-generic.cc", "status": "removed", "additions": 0, "deletions": 1045, "changes": 1045, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,1045 +0,0 @@\n-/* brig2tree.cc -- brig to gcc generic/gimple tree conversion\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include <cassert>\n-#include <iostream>\n-#include <iomanip>\n-#include <sstream>\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"target.h\"\n-#include \"function.h\"\n-#include \"brig-to-generic.h\"\n-#include \"stringpool.h\"\n-#include \"tree-iterator.h\"\n-#include \"toplev.h\"\n-#include \"gimplify.h\"\n-#include \"gimple-expr.h\"\n-#include \"print-tree.h\"\n-#include \"hsa-brig-format.h\"\n-#include \"stor-layout.h\"\n-#include \"diagnostic-core.h\"\n-#include \"brig-code-entry-handler.h\"\n-#include \"brig-machine.h\"\n-#include \"brig-util.h\"\n-#include \"phsa.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"dumpfile.h\"\n-#include \"profile-count.h\"\n-#include \"tree-cfg.h\"\n-#include \"errors.h\"\n-#include \"fold-const.h\"\n-#include \"cgraph.h\"\n-#include \"dumpfile.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"attribs.h\"\n-\n-extern int gccbrig_verbose;\n-\n-tree brig_to_generic::s_fp16_type;\n-tree brig_to_generic::s_fp32_type;\n-tree brig_to_generic::s_fp64_type;\n-\n-brig_to_generic::brig_to_generic ()\n-  : m_cf (NULL), m_analyzing (true), m_total_group_segment_usage (0),\n-    m_brig (NULL), m_next_private_offset (0)\n-{\n-  m_globals = NULL_TREE;\n-\n-  /* Initialize the basic REAL types.\n-     This doesn't work straight away because most of the targets\n-     do not support fp16 natively.  Let's by default convert\n-     to fp32 and back before and after each instruction (handle it as\n-     a storage format only), and later add an optimization pass\n-     that removes the extra converts (in case of multiple fp16 ops\n-     in a row).  */\n-  s_fp16_type = make_node (REAL_TYPE);\n-  TYPE_PRECISION (s_fp16_type) = 16;\n-  TYPE_SIZE (s_fp16_type) = bitsize_int (16);\n-  TYPE_SIZE_UNIT (s_fp16_type) = size_int (2);\n-  SET_TYPE_ALIGN (s_fp16_type, 16);\n-  layout_type (s_fp16_type);\n-\n-  s_fp32_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_F32);\n-  s_fp64_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_F64);\n-\n-  /* TODO: (machine)query the preferred rounding mode that is set by\n-     the machine by default.  This can be redefined by each BRIG module\n-     header.  */\n-  m_default_float_rounding_mode = BRIG_ROUND_FLOAT_ZERO;\n-\n-  m_dump_file = dump_begin (TDI_original, &m_dump_flags);\n-}\n-\n-class unimplemented_entry_handler : public brig_code_entry_handler\n-{\n-public:\n-  unimplemented_entry_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t\n-  operator () (const BrigBase *base)\n-  {\n-    gcc_unreachable ();\n-    return base->byteCount;\n-  }\n-};\n-\n-/* Handler for entries that can be (and are) safely skipped for the purposes\n-   of GENERIC generation.  */\n-\n-class skipped_entry_handler : public brig_code_entry_handler\n-{\n-public:\n-  skipped_entry_handler (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t\n-  operator () (const BrigBase *base)\n-  {\n-    return base->byteCount;\n-  }\n-};\n-\n-class brig_reg_use_analyzer : public brig_code_entry_handler\n-{\n-public:\n-  brig_reg_use_analyzer (brig_to_generic &parent)\n-    : brig_code_entry_handler (parent)\n-  {\n-  }\n-\n-  size_t\n-  operator () (const BrigBase *base)\n-  {\n-    const BrigInstBase *brig_inst = (const BrigInstBase *) base;\n-    analyze_operands (*brig_inst);\n-    return base->byteCount;\n-  }\n-\n-};\n-\n-/* Helper struct for pairing a BrigKind and a BrigCodeEntryHandler that\n-   should handle its data.  */\n-\n-struct code_entry_handler_info\n-{\n-  BrigKind kind;\n-  brig_code_entry_handler *handler;\n-};\n-\n-\n-/* Finds the BRIG file sections in the currently processed file.  */\n-\n-void\n-brig_to_generic::find_brig_sections ()\n-{\n-  m_data = m_code = m_operand = NULL;\n-  const BrigModuleHeader *mheader = (const BrigModuleHeader *) m_brig;\n-\n-  /* Find the positions of the different sections.  */\n-  for (uint32_t sec = 0; sec < mheader->sectionCount; ++sec)\n-    {\n-      uint64_t offset\n-\t= ((const uint64_t *) (m_brig + mheader->sectionIndex))[sec];\n-\n-      const BrigSectionHeader *section_header\n-\t= (const BrigSectionHeader *) (m_brig + offset);\n-\n-      std::string name ((const char *) (&section_header->name),\n-\t\t\tsection_header->nameLength);\n-\n-      if (sec == BRIG_SECTION_INDEX_DATA && name == \"hsa_data\")\n-\t{\n-\t  m_data = (const char *) section_header;\n-\t  m_data_size = section_header->byteCount;\n-\t}\n-      else if (sec == BRIG_SECTION_INDEX_CODE && name == \"hsa_code\")\n-\t{\n-\t  m_code = (const char *) section_header;\n-\t  m_code_size = section_header->byteCount;\n-\t}\n-      else if (sec == BRIG_SECTION_INDEX_OPERAND && name == \"hsa_operand\")\n-\t{\n-\t  m_operand = (const char *) section_header;\n-\t  m_operand_size = section_header->byteCount;\n-\t}\n-      else\n-\t{\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-\n-  if (m_code == NULL)\n-    gcc_unreachable ();\n-  if (m_data == NULL)\n-    gcc_unreachable ();\n-  if (m_operand == NULL)\n-    gcc_unreachable ();\n-\n-}\n-\n-/* Does a first pass over the given BRIG to collect data needed for the\n-   actual parsing.  Currently this includes only collecting the\n-   group segment variable usage to support the experimental HSA PRM feature\n-   where group variables can be declared also in module and function scope\n-   (in addition to kernel scope).\n-*/\n-\n-void\n-brig_to_generic::analyze (const char *brig_blob)\n-{\n-  const BrigModuleHeader *mheader = (const BrigModuleHeader *) brig_blob;\n-\n-  if (strncmp (mheader->identification, \"HSA BRIG\", 8) != 0)\n-    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE\n-\t\t \"Unrecognized file format.\");\n-  if (mheader->brigMajor != 1 || mheader->brigMinor != 0)\n-    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE\n-\t\t \"BRIG version not supported. BRIG 1.0 required.\");\n-\n-  m_brig = brig_blob;\n-\n-  find_brig_sections ();\n-\n-  brig_directive_variable_handler var_handler (*this);\n-  brig_directive_fbarrier_handler fbar_handler (*this);\n-  brig_directive_function_handler func_handler (*this);\n-  brig_reg_use_analyzer reg_use_analyzer (*this);\n-\n-  /* Need this for grabbing the module names for mangling the\n-     group variable names.  */\n-  brig_directive_module_handler module_handler (*this);\n-  skipped_entry_handler skipped_handler (*this);\n-\n-  const BrigSectionHeader *csection_header = (const BrigSectionHeader *) m_code;\n-\n-  code_entry_handler_info handlers[]\n-    = {{BRIG_KIND_INST_BASIC, &reg_use_analyzer},\n-       {BRIG_KIND_INST_MOD, &reg_use_analyzer},\n-       {BRIG_KIND_INST_CMP, &reg_use_analyzer},\n-       {BRIG_KIND_INST_MEM, &reg_use_analyzer},\n-       {BRIG_KIND_INST_CVT, &reg_use_analyzer},\n-       {BRIG_KIND_INST_SEG_CVT, &reg_use_analyzer},\n-       {BRIG_KIND_INST_SEG, &reg_use_analyzer},\n-       {BRIG_KIND_INST_ADDR, &reg_use_analyzer},\n-       {BRIG_KIND_INST_SOURCE_TYPE, &reg_use_analyzer},\n-       {BRIG_KIND_INST_ATOMIC, &reg_use_analyzer},\n-       {BRIG_KIND_INST_SIGNAL, &reg_use_analyzer},\n-       {BRIG_KIND_INST_BR, &reg_use_analyzer},\n-       {BRIG_KIND_INST_LANE, &reg_use_analyzer},\n-       {BRIG_KIND_INST_QUEUE, &reg_use_analyzer},\n-       {BRIG_KIND_DIRECTIVE_VARIABLE, &var_handler},\n-       {BRIG_KIND_DIRECTIVE_FBARRIER, &fbar_handler},\n-       {BRIG_KIND_DIRECTIVE_KERNEL, &func_handler},\n-       {BRIG_KIND_DIRECTIVE_MODULE, &module_handler},\n-       {BRIG_KIND_DIRECTIVE_FUNCTION, &func_handler}};\n-\n-  m_analyzing = true;\n-  for (size_t b = csection_header->headerByteCount; b < m_code_size;)\n-    {\n-      const BrigBase *entry = (const BrigBase *) (m_code + b);\n-\n-      brig_code_entry_handler *handler = &skipped_handler;\n-\n-      if (m_cf != NULL && b >= m_cf->m_brig_def->nextModuleEntry)\n-\t{\n-\t  /* The function definition ended.  We can just discard the place\n-\t     holder function. */\n-\t  m_total_group_segment_usage += m_cf->m_local_group_variables.size ();\n-\t  delete m_cf;\n-\t  m_cf = NULL;\n-\t}\n-\n-      /* Find a handler.  */\n-      for (size_t i = 0;\n-\t   i < sizeof (handlers) / sizeof (code_entry_handler_info); ++i)\n-\t{\n-\t  if (handlers[i].kind == entry->kind)\n-\t    handler = handlers[i].handler;\n-\t}\n-\n-      int bytes_processed = (*handler) (entry);\n-      if (bytes_processed == 0)\n-\tfatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_CORRUPTED_MODULE\n-\t\t     \"Element with 0 bytes.\");\n-      b += bytes_processed;\n-    }\n-\n-  if (m_cf != NULL)\n-    {\n-      m_total_group_segment_usage += m_cf->m_local_group_variables.size ();\n-      delete m_cf;\n-      m_cf = NULL;\n-    }\n-\n-  m_total_group_segment_usage += m_module_group_variables.size ();\n-  m_analyzing = false;\n-}\n-\n-/* Parses the given BRIG blob.  */\n-\n-void\n-brig_to_generic::parse (const char *brig_blob)\n-{\n-  m_brig = brig_blob;\n-  find_brig_sections ();\n-\n-  brig_basic_inst_handler inst_handler (*this);\n-  brig_branch_inst_handler branch_inst_handler (*this);\n-  brig_cvt_inst_handler cvt_inst_handler (*this);\n-  brig_seg_inst_handler seg_inst_handler (*this);\n-  brig_copy_move_inst_handler copy_move_inst_handler (*this);\n-  brig_signal_inst_handler signal_inst_handler (*this);\n-  brig_atomic_inst_handler atomic_inst_handler (*this);\n-  brig_cmp_inst_handler cmp_inst_handler (*this);\n-  brig_mem_inst_handler mem_inst_handler (*this);\n-  brig_inst_mod_handler inst_mod_handler (*this);\n-  brig_directive_label_handler label_handler (*this);\n-  brig_directive_variable_handler var_handler (*this);\n-  brig_directive_fbarrier_handler fbar_handler (*this);\n-  brig_directive_comment_handler comment_handler (*this);\n-  brig_directive_function_handler func_handler (*this);\n-  brig_directive_control_handler control_handler (*this);\n-  brig_directive_arg_block_handler arg_block_handler (*this);\n-  brig_directive_module_handler module_handler (*this);\n-  brig_lane_inst_handler lane_inst_handler (*this);\n-  brig_queue_inst_handler queue_inst_handler (*this);\n-  skipped_entry_handler skipped_handler (*this);\n-  unimplemented_entry_handler unimplemented_handler (*this);\n-\n-  struct code_entry_handler_info\n-  {\n-    BrigKind kind;\n-    brig_code_entry_handler *handler;\n-  };\n-\n-  /* TODO: Convert to a hash table / map.  For now, put the more common\n-     entries to the top to keep the scan fast on average.  */\n-  code_entry_handler_info handlers[]\n-    = {{BRIG_KIND_INST_BASIC, &inst_handler},\n-       {BRIG_KIND_INST_CMP, &cmp_inst_handler},\n-       {BRIG_KIND_INST_MEM, &mem_inst_handler},\n-       {BRIG_KIND_INST_MOD, &inst_mod_handler},\n-       {BRIG_KIND_INST_CVT, &cvt_inst_handler},\n-       {BRIG_KIND_INST_SEG_CVT, &seg_inst_handler},\n-       {BRIG_KIND_INST_SEG, &seg_inst_handler},\n-       {BRIG_KIND_INST_ADDR, &copy_move_inst_handler},\n-       {BRIG_KIND_INST_SOURCE_TYPE, &copy_move_inst_handler},\n-       {BRIG_KIND_INST_ATOMIC, &atomic_inst_handler},\n-       {BRIG_KIND_INST_SIGNAL, &signal_inst_handler},\n-       {BRIG_KIND_INST_BR, &branch_inst_handler},\n-       {BRIG_KIND_INST_LANE, &lane_inst_handler},\n-       {BRIG_KIND_INST_QUEUE, &queue_inst_handler},\n-       /* Assuming fences are not needed.  FIXME: call builtins\n-\t  when porting to a platform where they are.  */\n-       {BRIG_KIND_INST_MEM_FENCE, &skipped_handler},\n-       {BRIG_KIND_DIRECTIVE_LABEL, &label_handler},\n-       {BRIG_KIND_DIRECTIVE_VARIABLE, &var_handler},\n-       {BRIG_KIND_DIRECTIVE_ARG_BLOCK_START, &arg_block_handler},\n-       {BRIG_KIND_DIRECTIVE_ARG_BLOCK_END, &arg_block_handler},\n-       {BRIG_KIND_DIRECTIVE_FBARRIER, &fbar_handler},\n-       {BRIG_KIND_DIRECTIVE_COMMENT, &comment_handler},\n-       {BRIG_KIND_DIRECTIVE_KERNEL, &func_handler},\n-       {BRIG_KIND_DIRECTIVE_SIGNATURE, &func_handler},\n-       {BRIG_KIND_DIRECTIVE_FUNCTION, &func_handler},\n-       {BRIG_KIND_DIRECTIVE_INDIRECT_FUNCTION, &func_handler},\n-       {BRIG_KIND_DIRECTIVE_MODULE, &module_handler},\n-       /* Skipping debug locations for now as not needed for conformance.  */\n-       {BRIG_KIND_DIRECTIVE_LOC, &skipped_handler},\n-       /* There are no supported pragmas at this moment.  */\n-       {BRIG_KIND_DIRECTIVE_PRAGMA, &skipped_handler},\n-       {BRIG_KIND_DIRECTIVE_CONTROL, &control_handler},\n-       {BRIG_KIND_DIRECTIVE_EXTENSION, &skipped_handler},\n-       /* BRIG_KIND_NONE entries are valid anywhere.  They can be used\n-\t  for patching BRIGs before finalization.  */\n-       {BRIG_KIND_NONE, &skipped_handler}};\n-\n-  const BrigSectionHeader *csection_header = (const BrigSectionHeader *) m_code;\n-\n-  for (size_t b = csection_header->headerByteCount; b < m_code_size;)\n-    {\n-      const BrigBase *entry = (const BrigBase *) (m_code + b);\n-\n-      brig_code_entry_handler *handler = &unimplemented_handler;\n-\n-      if (m_cf != NULL && b >= m_cf->m_brig_def->nextModuleEntry)\n-\tfinish_function (); /* The function definition ended.  */\n-\n-      /* Find a handler.  */\n-      for (size_t i = 0;\n-\t   i < sizeof (handlers) / sizeof (code_entry_handler_info); ++i)\n-\t{\n-\t  if (handlers[i].kind == entry->kind)\n-\t    handler = handlers[i].handler;\n-\t}\n-      b += (*handler) (entry);\n-    }\n-\n-  finish_function ();\n-}\n-\n-const BrigData *\n-brig_to_generic::get_brig_data_entry (size_t entry_offset) const\n-{\n-  return (const BrigData *) (m_data + entry_offset);\n-}\n-\n-const BrigBase *\n-brig_to_generic::get_brig_operand_entry (size_t entry_offset) const\n-{\n-  return (const BrigBase *) (m_operand + entry_offset);\n-}\n-\n-const BrigBase *\n-brig_to_generic::get_brig_code_entry (size_t entry_offset) const\n-{\n-  return (const BrigBase *) (m_code + entry_offset);\n-}\n-\n-void\n-brig_to_generic::append_global (tree g)\n-{\n-  if (m_globals == NULL_TREE)\n-    {\n-      m_globals = g;\n-      return;\n-    }\n-  else\n-    {\n-      tree last = tree_last (m_globals);\n-      TREE_CHAIN (last) = g;\n-    }\n-}\n-\n-tree\n-brig_to_generic::global_variable (const std::string &name) const\n-{\n-  label_index::const_iterator i = m_global_variables.find (name);\n-  if (i == m_global_variables.end ())\n-    return NULL_TREE;\n-  else\n-    return (*i).second;\n-}\n-\n-/* Returns a function declaration with the given name.  Assumes it has been\n-   created previously via a DirectiveFunction or similar.  */\n-\n-tree\n-brig_to_generic::function_decl (const std::string &name)\n-{\n-  label_index::const_iterator i = m_function_index.find (name);\n-  if (i == m_function_index.end ())\n-    return NULL_TREE;\n-  return (*i).second;\n-}\n-\n-void\n-brig_to_generic::add_function_decl (const std::string &name, tree func_decl)\n-{\n-  m_function_index[name] = func_decl;\n-}\n-\n-/* Adds a GENERIC global variable VAR_DECL with the given NAME to the\n-   current module.  If we have generated a host def var ptr (a place holder\n-   for variables that are defined by the HSA host code) for this global\n-   variable definition (because there was a declaration earlier which looked\n-   like it might have been a host defined variable), we now have\n-   to assign its address and make it private to allow the references to\n-   point to the defined variable instead.  */\n-\n-void\n-brig_to_generic::add_global_variable (const std::string &name, tree var_decl)\n-{\n-  append_global (var_decl);\n-  m_global_variables[name] = var_decl;\n-\n-  std::string host_def_var_name\n-    = std::string (PHSA_HOST_DEF_PTR_PREFIX) + name;\n-  tree host_def_var = global_variable (host_def_var_name);\n-  if (host_def_var == NULL_TREE)\n-    return;\n-\n-  tree ptype = build_pointer_type (TREE_TYPE (var_decl));\n-  tree var_addr = build1 (ADDR_EXPR, ptype, var_decl);\n-\n-  DECL_INITIAL (host_def_var) = var_addr;\n-  TREE_PUBLIC (host_def_var) = 1;\n-\n-  set_externally_visible (host_def_var);\n-}\n-\n-/* Adds an indirection pointer for a potential host-defined program scope\n-   variable declaration.  */\n-\n-void\n-brig_to_generic::add_host_def_var_ptr (const std::string &name, tree var_decl)\n-{\n-  std::string var_name = std::string (PHSA_HOST_DEF_PTR_PREFIX) + name;\n-\n-  tree name_identifier = get_identifier (var_name.c_str ());\n-\n-  tree ptr_var = build_decl (UNKNOWN_LOCATION, VAR_DECL, name_identifier,\n-\t\t\t     build_pointer_type (TREE_TYPE (var_decl)));\n-  DECL_EXTERNAL (ptr_var) = 0;\n-  DECL_ARTIFICIAL (ptr_var) = 0;\n-\n-  TREE_PUBLIC (ptr_var) = 1;\n-  TREE_USED (ptr_var) = 1;\n-  TREE_ADDRESSABLE (ptr_var) = 1;\n-  TREE_STATIC (ptr_var) = 1;\n-\n-  set_externally_visible (ptr_var);\n-\n-  append_global (ptr_var);\n-  m_global_variables[var_name] = ptr_var;\n-}\n-\n-void\n-brig_to_generic::add_decl_call (tree call)\n-{\n-  m_decl_call.push_back (call);\n-}\n-\n-/* Produce a \"mangled name\" for the given brig function or kernel.\n-   The mangling is used to make unique global symbol name in case of\n-   module scope functions.  Program scope functions are not mangled\n-   (except for dropping the leading &), which makes the functions\n-   directly visible for linking using the original function name.  */\n-\n-std::string\n-brig_to_generic::get_mangled_name\n-(const BrigDirectiveExecutable *func) const\n-{\n-  /* Strip the leading &.  */\n-  std::string func_name = get_string (func->name).substr (1);\n-  if (func->linkage == BRIG_LINKAGE_MODULE)\n-    {\n-      /* Mangle the module scope function names with the module name and\n-\t make them public so they can be queried by the HSA runtime from\n-\t the produced binary.  Assume it's the currently processed function\n-\t we are always referring to.  */\n-      func_name = \"gccbrig.\" + m_module_name + \".\" + func_name;\n-    }\n-  return func_name;\n-}\n-\n-std::string\n-brig_to_generic::get_string (size_t entry_offset) const\n-{\n-  const BrigData *data_item = get_brig_data_entry (entry_offset);\n-  return std::string ((const char *) &data_item->bytes, data_item->byteCount);\n-}\n-\n-/* Adapted from c-semantics.c.  */\n-\n-tree\n-build_stmt (enum tree_code code, ...)\n-{\n-  tree ret;\n-  int length, i;\n-  va_list p;\n-  bool side_effects;\n-\n-  /* This function cannot be used to construct variably-sized nodes.  */\n-  gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n-\n-  va_start (p, code);\n-\n-  ret = make_node (code);\n-  TREE_TYPE (ret) = void_type_node;\n-  length = TREE_CODE_LENGTH (code);\n-\n-  /* TREE_SIDE_EFFECTS will already be set for statements with\n-     implicit side effects.  Here we make sure it is set for other\n-     expressions by checking whether the parameters have side\n-     effects.  */\n-\n-  side_effects = false;\n-  for (i = 0; i < length; i++)\n-    {\n-      tree t = va_arg (p, tree);\n-      if (t && !TYPE_P (t))\n-\tside_effects |= TREE_SIDE_EFFECTS (t);\n-      TREE_OPERAND (ret, i) = t;\n-    }\n-\n-  TREE_SIDE_EFFECTS (ret) |= side_effects;\n-\n-  va_end (p);\n-  return ret;\n-}\n-\n-/* BRIG regs are untyped, but GENERIC is not.  We need to add implicit casts\n-   in case treating the operand with an instruction with a type different\n-   than the created reg var type in order to select correct instruction type\n-   later on.  This function creates the necessary reinterpret type cast from\n-   a source variable to the destination type.  In case no cast is needed to\n-   the same type, SOURCE is returned directly.\n-\n-   In case of mismatched type sizes, casting:\n-   - to narrower type the upper bits are clipped and\n-   - to wider type the source value is zero extended.  */\n-\n-tree\n-build_resize_convert_view (tree destination_type, tree source)\n-{\n-\n-  gcc_assert (source && destination_type && TREE_TYPE (source) != NULL_TREE\n-\t      && destination_type != NULL_TREE);\n-\n-  tree source_type = TREE_TYPE (source);\n-  if (TREE_CODE (source) == CALL_EXPR)\n-    {\n-      tree func_decl = TREE_OPERAND (TREE_OPERAND (source, 1), 0);\n-      source_type = TREE_TYPE (TREE_TYPE (func_decl));\n-    }\n-\n-  if (destination_type == source_type)\n-    return source;\n-\n-  size_t src_size = int_size_in_bytes (source_type);\n-  size_t dst_size = int_size_in_bytes (destination_type);\n-  if (src_size == dst_size)\n-    return build1 (VIEW_CONVERT_EXPR, destination_type, source);\n-  else /* src_size != dst_size  */\n-    {\n-      /* The src_size can be smaller at least with f16 scalars which are\n-\t stored to 32b register variables.  First convert to an equivalent\n-\t size unsigned type, then extend to an unsigned type of the\n-\t target width, after which VIEW_CONVERT_EXPR can be used to\n-\t force to the target type.  */\n-      tree resized = convert (get_scalar_unsigned_int_type (destination_type),\n-\t\t\t      build_reinterpret_to_uint (source));\n-      gcc_assert ((size_t)int_size_in_bytes (TREE_TYPE (resized)) == dst_size);\n-      return build_resize_convert_view (destination_type, resized);\n-    }\n-}\n-\n-/* Reinterprets SOURCE as a scalar unsigned int with the size\n-   corresponding to the orignal.  */\n-\n-tree build_reinterpret_to_uint (tree source)\n-{\n-  tree src_type = TREE_TYPE (source);\n-  if (INTEGRAL_TYPE_P (src_type) && TYPE_UNSIGNED (src_type))\n-    return source;\n-  tree dest_type = get_scalar_unsigned_int_type (src_type);\n-  return build1 (VIEW_CONVERT_EXPR, dest_type, source);\n-}\n-\n-/* Returns the finished brig_function for the given generic FUNC_DECL,\n-   or NULL, if not found.  */\n-\n-brig_function *\n-brig_to_generic::get_finished_function (tree func_decl)\n-{\n-  std::string func_name\n-    = identifier_to_locale (IDENTIFIER_POINTER (DECL_NAME (func_decl)));\n-  std::map<std::string, brig_function *>::iterator i\n-    = m_finished_functions.find (func_name);\n-  if (i != m_finished_functions.end ())\n-    return (*i).second;\n-  else\n-    return NULL;\n-}\n-\n-/* Adds a group variable to a correct book keeping structure depending\n-   on its segment.  */\n-\n-void\n-brig_to_generic::add_group_variable (const std::string &name, size_t size,\n-\t\t\t\t     size_t alignment, bool function_scope)\n-{\n-  /* Module and function scope group region variables are an experimental\n-     feature.  We implement module scope group variables with a separate\n-     book keeping inside brig_to_generic which is populated in the 'analyze()'\n-     prepass.  This is to ensure we know the group segment offsets when\n-     processing the functions that might refer to them.  */\n-  if (!function_scope)\n-    {\n-      if (!m_module_group_variables.has_variable (name))\n-\tm_module_group_variables.add (name, size, alignment);\n-      return;\n-    }\n-\n-  if (!m_cf->m_local_group_variables.has_variable (name))\n-    m_cf->m_local_group_variables.add (name, size, alignment);\n-}\n-\n-/* Finalizes the currently handled function.  Should be called before\n-   setting a new function.  */\n-\n-void\n-brig_to_generic::finish_function ()\n-{\n-  if (m_cf == NULL || m_cf->m_func_decl == NULL_TREE)\n-    {\n-      /* It can be a finished func declaration fingerprint, in that case we\n-\t don't have m_func_decl.  */\n-      m_cf = NULL;\n-      return;\n-    }\n-\n-  if (!m_cf->m_is_kernel)\n-    {\n-      tree bind_expr = m_cf->m_current_bind_expr;\n-      tree stmts = BIND_EXPR_BODY (bind_expr);\n-      m_cf->finish ();\n-      m_cf->emit_metadata (stmts);\n-      dump_function (m_dump_file, m_cf);\n-    }\n-  else\n-    /* Emit the kernel only at the very end so we can analyze the total\n-       group and private memory usage.  */\n-    m_kernels.push_back (m_cf);\n-\n-  pop_cfun ();\n-\n-  m_finished_functions[m_cf->m_name] = m_cf;\n-  m_cf = NULL;\n-}\n-\n-/* Initializes a new currently handled function.  */\n-\n-void\n-brig_to_generic::start_function (tree f)\n-{\n-  if (DECL_STRUCT_FUNCTION (f) == NULL)\n-    push_struct_function (f);\n-  else\n-    push_cfun (DECL_STRUCT_FUNCTION (f));\n-\n-  m_cf->m_func_decl = f;\n-}\n-\n-/* Appends a new variable to the current kernel's private segment.  */\n-\n-void\n-brig_to_generic::append_private_variable (const std::string &name,\n-\t\t\t\t\t  size_t size, size_t alignment)\n-{\n-  /* We need to take care of two cases of alignment with private\n-     variables because of the layout where the same variable for\n-     each work-item is laid out in successive addresses.\n-\n-     1) Ensure the first work-item's variable is in an aligned\n-     offset:  */\n-  size_t align_padding = m_next_private_offset % alignment == 0 ?\n-    0 : (alignment - m_next_private_offset % alignment);\n-\n-  /* 2) Each successive per-work-item copy should be aligned.\n-     If the variable has wider alignment than size then we need\n-     to add extra padding to ensure it.  The padding must be\n-     included in the size to allow per-work-item offset computation\n-     to find their own aligned copy.  */\n-\n-  size_t per_var_padding = size % alignment == 0 ?\n-    0 : (alignment - size % alignment);\n-  m_private_data_sizes[name] = size + per_var_padding;\n-\n-  m_next_private_offset += align_padding;\n-  m_private_offsets[name] = m_next_private_offset;\n-  m_next_private_offset += size + per_var_padding;\n-}\n-\n-size_t\n-brig_to_generic::private_variable_segment_offset\n-  (const std::string &name) const\n-{\n-  var_offset_table::const_iterator i = m_private_offsets.find (name);\n-  gcc_assert (i != m_private_offsets.end ());\n-  return (*i).second;\n-}\n-\n-bool\n-brig_to_generic::has_private_variable (const std::string &name) const\n-{\n-  std::map<std::string, size_t>::const_iterator i\n-    = m_private_data_sizes.find (name);\n-  return i != m_private_data_sizes.end ();\n-}\n-\n-size_t\n-brig_to_generic::private_variable_size (const std::string &name) const\n-{\n-  std::map<std::string, size_t>::const_iterator i\n-    = m_private_data_sizes.find (name);\n-  gcc_assert (i != m_private_data_sizes.end ());\n-  return (*i).second;\n-}\n-\n-\n-/* The size of private segment required by a single work-item executing\n-   the currently processed kernel.  */\n-\n-size_t\n-brig_to_generic::private_segment_size () const\n-{\n-  return m_next_private_offset;\n-}\n-\n-/* Cached builtins indexed by name.  */\n-\n-typedef std::map<std::string, tree> builtin_index;\n-builtin_index builtin_cache_;\n-\n-/* Build a call to a builtin function.  PDECL is the builtin function to\n-   call.  NARGS is the number of input arguments, RETTYPE the built-in\n-   functions return value type, and ... is the list of arguments passed to\n-   the call with type first, then the value.  */\n-\n-tree\n-call_builtin (tree pdecl, int nargs, tree rettype, ...)\n-{\n-  if (rettype == error_mark_node)\n-    return error_mark_node;\n-\n-  tree *types = new tree[nargs];\n-  tree *args = new tree[nargs];\n-\n-  va_list ap;\n-  va_start (ap, rettype);\n-  for (int i = 0; i < nargs; ++i)\n-    {\n-      types[i] = va_arg (ap, tree);\n-      tree arg = va_arg (ap, tree);\n-      args[i] = build_resize_convert_view (types[i], arg);\n-      if (types[i] == error_mark_node || args[i] == error_mark_node)\n-\t{\n-\t  delete[] types;\n-\t  delete[] args;\n-\t  va_end (ap);\n-\t  return error_mark_node;\n-\t}\n-    }\n-  va_end (ap);\n-\n-  tree fnptr = build_fold_addr_expr (pdecl);\n-\n-  tree ret = build_call_array (rettype, fnptr, nargs, args);\n-\n-  delete[] types;\n-  delete[] args;\n-\n-  return ret;\n-}\n-\n-/* Generate all global declarations.  Should be called after the last\n-   BRIG has been fed in.  */\n-\n-void\n-brig_to_generic::write_globals ()\n-{\n-\n-  /* Replace calls to declarations with calls to definitions.  Otherwise\n-     inlining will fail to find the definition to inline from.  */\n-\n-  for (size_t i = 0; i < m_decl_call.size(); ++i)\n-    {\n-      tree decl_call = m_decl_call.at(i);\n-      tree func_decl = get_callee_fndecl (decl_call);\n-      brig_function *brig_function = get_finished_function (func_decl);\n-\n-      if (brig_function && brig_function->m_func_decl\n-\t  && DECL_EXTERNAL (brig_function->m_func_decl) == 0\n-\t  && brig_function->m_func_decl != func_decl)\n-\t{\n-\n-\t  decl_call = CALL_EXPR_FN (decl_call);\n-\t  STRIP_NOPS (decl_call);\n-\t  if (TREE_CODE (decl_call) == ADDR_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (decl_call, 0)) == FUNCTION_DECL)\n-\t    TREE_OPERAND (decl_call, 0) = brig_function->m_func_decl;\n-\t}\n-    }\n-\n-  for (std::map<std::string, brig_function *>::iterator i\n-\t = m_finished_functions.begin(), e = m_finished_functions.end();\n-       i != e; ++i)\n-    {\n-      brig_function *brig_f = (*i).second;\n-      if (brig_f->m_is_kernel)\n-\tcontinue;\n-\n-      /* Finalize only at this point to allow the cgraph analysis to\n-\t see definitions to calls to later functions.  */\n-      gimplify_function_tree (brig_f->m_func_decl);\n-      cgraph_node::finalize_function (brig_f->m_func_decl, true);\n-    }\n-\n-  /* Now that the whole BRIG module has been processed, build a launcher\n-     and a metadata section for each built kernel.  */\n-  for (size_t i = 0; i < m_kernels.size (); ++i)\n-    {\n-      brig_function *f = m_kernels[i];\n-\n-      /* Finish kernels now that we know the call graphs and their barrier\n-\t usage.  */\n-      f->finish_kernel ();\n-\n-      dump_function (m_dump_file, f);\n-      gimplify_function_tree (f->m_func_decl);\n-      cgraph_node::finalize_function (f->m_func_decl, true);\n-\n-      f->m_descriptor.is_kernel = 1;\n-      /* TODO: analyze the kernel's actual private and group segment usage\n-\t using call graph.  Now the mem size is overly\n-\t pessimistic in case of multiple kernels in the same module.\n-      */\n-      f->m_descriptor.group_segment_size = m_total_group_segment_usage;\n-      f->m_descriptor.private_segment_size = private_segment_size ();\n-\n-      /* The kernarg size is rounded up to a multiple of 16 according to\n-\t the PRM specs.  */\n-      f->m_descriptor.kernarg_segment_size = f->m_next_kernarg_offset;\n-      if (f->m_descriptor.kernarg_segment_size % 16 > 0)\n-\tf->m_descriptor.kernarg_segment_size\n-\t  += 16 - f->m_next_kernarg_offset % 16;\n-      f->m_descriptor.kernarg_max_align = f->m_kernarg_max_align;\n-\n-      tree launcher = f->emit_launcher_and_metadata ();\n-\n-      append_global (launcher);\n-\n-      if (m_dump_file)\n-\t{\n-\t  std::string kern_name = f->m_name.substr (1);\n-\t  fprintf (m_dump_file, \"\\n;; Function %s\", kern_name.c_str());\n-\t  fprintf (m_dump_file, \"\\n;; enabled by -%s\\n\\n\",\n-\t\t   dump_flag_name (TDI_original));\n-\t  print_generic_decl (m_dump_file, launcher, TDF_NONE);\n-\t  print_generic_expr (m_dump_file, DECL_SAVED_TREE (launcher),\n-\t\t\t      TDF_NONE);\n-\t  fprintf (m_dump_file, \"\\n\");\n-\t}\n-\n-      gimplify_function_tree (launcher);\n-      cgraph_node::finalize_function (launcher, true);\n-      pop_cfun ();\n-    }\n-\n-  int no_globals = list_length (m_globals);\n-  tree *vec = new tree[no_globals];\n-\n-  int i = 0;\n-  tree global = m_globals;\n-  while (global)\n-    {\n-      vec[i] = global;\n-      ++i;\n-      global = TREE_CHAIN (global);\n-    }\n-\n-  wrapup_global_declarations (vec, no_globals);\n-\n-  delete[] vec;\n-\n-}\n-\n-/* Returns an type with unsigned int elements corresponding to the\n-   size and element count of ORIGINAL_TYPE.  */\n-\n-tree\n-get_unsigned_int_type (tree original_type)\n-{\n-  if (VECTOR_TYPE_P (original_type))\n-    {\n-      size_t esize\n-\t= int_size_in_bytes (TREE_TYPE (original_type)) * BITS_PER_UNIT;\n-      poly_uint64 ecount = TYPE_VECTOR_SUBPARTS (original_type);\n-      return build_vector_type (build_nonstandard_integer_type (esize, true),\n-\t\t\t\tecount);\n-    }\n-  else\n-    return build_nonstandard_integer_type (int_size_in_bytes (original_type)\n-\t\t\t\t\t   * BITS_PER_UNIT,\n-\t\t\t\t\t   true);\n-}\n-\n-/* Returns a type with unsigned int corresponding to the size\n-   ORIGINAL_TYPE.  */\n-\n-tree\n-get_scalar_unsigned_int_type (tree original_type)\n-{\n-  return build_nonstandard_integer_type (int_size_in_bytes (original_type)\n-\t\t\t\t\t * BITS_PER_UNIT, true);\n-}\n-\n-/* Set the declaration externally visible so it won't get removed by\n-   whole program optimizations.  */\n-\n-void\n-set_externally_visible (tree decl)\n-{\n-  if (!lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n-    DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"externally_visible\"),\n-\t\t\t\t\tNULL, DECL_ATTRIBUTES (decl));\n-}\n-\n-void\n-set_inline (tree decl)\n-{\n-  if (!lookup_attribute (\"inline\", DECL_ATTRIBUTES (decl)))\n-    DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"inline\"),\n-\t\t\t\t\tNULL, DECL_ATTRIBUTES (decl));\n-}\n-\n-void\n-dump_function (FILE *dump_file, brig_function *f)\n-{\n-  /* Dump the BRIG-specific tree IR.  */\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\n;; Function %s\", f->m_name.c_str ());\n-      fprintf (dump_file, \"\\n;; enabled by -%s\\n\\n\",\n-\t       dump_flag_name (TDI_original));\n-      print_generic_decl (dump_file, f->m_func_decl, TDF_NONE);\n-      print_generic_expr (dump_file, f->m_current_bind_expr, TDF_NONE);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-}\n-\n-/* Records use of the BRIG_REG as a TYPE in the current function.  */\n-\n-void\n-brig_to_generic::add_reg_used_as_type (const BrigOperandRegister &brig_reg,\n-\t\t\t\t       tree type)\n-{\n-  gcc_assert (m_cf);\n-  reg_use_info &info\n-    = m_fn_regs_use_index[m_cf->m_name][gccbrig_hsa_reg_id (brig_reg)];\n-\n-  if (info.m_type_refs_lookup.count (type))\n-    info.m_type_refs[info.m_type_refs_lookup[type]].second++;\n-  else\n-    {\n-      info.m_type_refs.push_back (std::make_pair (type, 1));\n-      info.m_type_refs_lookup[type] = info.m_type_refs.size () - 1;\n-    }\n-}"}, {"sha": "f4a67374e40f76772007b25e6508c0f70a3ae0e6", "filename": "gcc/brig/brigfrontend/brig-to-generic.h", "status": "removed", "additions": 0, "deletions": 240, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,240 +0,0 @@\n-/* brig-to-generic.h -- brig to gcc generic conversion\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef BRIG_TO_GENERIC_H\n-#define BRIG_TO_GENERIC_H\n-\n-#include <string>\n-#include <map>\n-#include <vector>\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"ansidecl.h\"\n-#include \"coretypes.h\"\n-#include \"opts.h\"\n-#include \"tree.h\"\n-#include \"tree-iterator.h\"\n-#include \"hsa-brig-format.h\"\n-#include \"brig-function.h\"\n-\n-struct reg_decl_index_entry;\n-\n-/* Converts an HSAIL BRIG input to GENERIC.  This class holds global state\n-   for the translation process.  Handling of the smaller pieces of BRIG data\n-   is delegated to various handler classes declared in\n-   brig-code-entry-handlers.h.  */\n-\n-class brig_to_generic\n-{\n-public:\n-  typedef std::map<const BrigDirectiveVariable *, tree> variable_index;\n-\n-private:\n-  typedef std::map<std::string, size_t> var_offset_table;\n-  typedef std::map<const BrigBase *, std::string> name_index;\n-\n-public:\n-  brig_to_generic ();\n-\n-  void analyze (const char *brig_blob);\n-  void parse (const char *brig_blob);\n-\n-  void write_globals ();\n-\n-  std::string get_string (size_t entry_offset) const;\n-\n-  const BrigData *get_brig_data_entry (size_t entry_offset) const;\n-  const BrigBase *get_brig_operand_entry (size_t entry_offset) const;\n-  const BrigBase *get_brig_code_entry (size_t entry_offset) const;\n-\n-  void append_global (tree g);\n-\n-  tree function_decl (const std::string &name);\n-  void add_function_decl (const std::string &name, tree func_decl);\n-\n-  tree global_variable (const std::string &name) const;\n-  void add_global_variable (const std::string &name, tree var_decl);\n-  void add_host_def_var_ptr (const std::string &name, tree var_decl);\n-  void add_decl_call (tree call);\n-\n-  void start_function (tree f);\n-  void finish_function ();\n-\n-  void append_private_variable (const std::string &name, size_t size,\n-\t\t\t\tsize_t alignment);\n-\n-  size_t\n-  private_variable_segment_offset (const std::string &name) const;\n-\n-  bool\n-  has_private_variable (const std::string &name) const;\n-\n-  size_t private_variable_size (const std::string &name) const;\n-\n-  template <typename T>\n-    std::string\n-    get_mangled_name_tmpl (const T *brigVar) const;\n-\n-  std::string get_mangled_name (const BrigDirectiveFbarrier *fbar) const\n-    { return get_mangled_name_tmpl (fbar); }\n-  std::string get_mangled_name (const BrigDirectiveVariable *var) const\n-    { return get_mangled_name_tmpl (var); }\n-  std::string get_mangled_name (const BrigDirectiveExecutable *func) const;\n-\n-  size_t private_segment_size () const;\n-\n-  brig_function *get_finished_function (tree func_decl);\n-\n-  void add_group_variable (const std::string &name, size_t size,\n-\t\t\t   size_t alignment, bool function_scope);\n-\n-  void add_reg_used_as_type (const BrigOperandRegister &brig_reg,\n-\t\t\t     tree operand_type);\n-\n-  static tree s_fp16_type;\n-  static tree s_fp32_type;\n-  static tree s_fp64_type;\n-\n-  /* The default rounding mode that should be used for float instructions.\n-     This can be set in each BRIG module header.  */\n-  BrigRound8_t m_default_float_rounding_mode;\n-\n-  /* The currently built function.  */\n-  brig_function *m_cf;\n-\n-  /* Stores the module and function scope group variable offsets.  */\n-  group_variable_offset_index m_module_group_variables;\n-\n-  /* The name of the currently handled BRIG module.  */\n-  std::string m_module_name;\n-\n-  /* Set to true if the compilation is in 'analyze' phase.  */\n-  bool m_analyzing;\n-\n-  /* Accumulates the total group segment usage.  */\n-  size_t m_total_group_segment_usage;\n-\n-  /* Statistics about register uses per function.  */\n-  std::map<std::string, regs_use_index> m_fn_regs_use_index;\n-\n-private:\n-\n-  void find_brig_sections ();\n-  /* The BRIG blob and its different sections of the file currently being\n-     parsed.  */\n-  const char *m_brig;\n-  const char *m_data;\n-  size_t m_data_size;\n-  const char *m_operand;\n-  size_t m_operand_size;\n-  const char *m_code;\n-  size_t m_code_size;\n-\n-  tree m_globals;\n-\n-  label_index m_global_variables;\n-\n-  /* Calls to declarations to be fixed in the end of processing to call\n-     defs instead.  */\n-  std::vector<tree> m_decl_call;\n-\n-  /* The size of each private variable, including the alignment padding.  */\n-  std::map<std::string, size_t> m_private_data_sizes;\n-\n-  /* And private.  */\n-  size_t m_next_private_offset;\n-  var_offset_table m_private_offsets;\n-\n-  /* Name index for declared functions.  */\n-  label_index m_function_index;\n-\n-  /* Stores all processed kernels in order.  */\n-  std::vector<brig_function *> m_kernels;\n-\n-  /* Stores all already processed functions from the translation unit\n-     for some interprocedural analysis.  */\n-  std::map<std::string, brig_function *> m_finished_functions;\n-\n-  /* The original dump file.  */\n-  FILE *m_dump_file;\n-\n-  /* The original dump file flags.  */\n-  dump_flags_t m_dump_flags;\n-};\n-\n-/* Produce a \"mangled name\" for the given brig variable.  The mangling is used\n-   to make unique global symbol names for module and function scope variables.\n-   The templated version is suitable for most of the variable types.  Functions\n-   and kernels (BrigDirectiveExecutable) are handled with a specialized\n-   get_mangled_name() version.  */\n-\n-template <typename T>\n-std::string\n-brig_to_generic::get_mangled_name_tmpl (const T *brigVar) const\n-{\n-  std::string var_name = get_string (brigVar->name).substr (1);\n-\n-  /* Mangle the variable name using the function name and the module name\n-     in case of a function scope variable.  */\n-  if (m_cf != NULL\n-      && m_cf->has_function_scope_var (&brigVar->base))\n-    var_name = m_cf->m_name + \".\" + var_name;\n-\n-  if (brigVar->linkage == BRIG_LINKAGE_MODULE)\n-    var_name = \"gccbrig.\" + m_module_name + \".\" + var_name;\n-  return var_name;\n-}\n-\n-/* An interface to organize the different types of BRIG element handlers.  */\n-\n-class brig_entry_handler\n-{\n-public:\n-  brig_entry_handler (brig_to_generic &parent) : m_parent (parent)\n-  {\n-  }\n-\n-  /* Handles the brig_code data at the given pointer and adds it to the\n-     currently built tree.  Returns the number of consumed bytes;  */\n-  virtual size_t operator () (const BrigBase *base) = 0;\n-\n-protected:\n-  brig_to_generic &m_parent;\n-};\n-\n-tree call_builtin (tree pdecl, int nargs, tree rettype, ...);\n-\n-tree build_resize_convert_view (tree destination_type, tree source);\n-tree build_reinterpret_to_uint (tree source);\n-\n-tree build_stmt (enum tree_code code, ...);\n-\n-tree get_unsigned_int_type (tree type);\n-\n-tree get_scalar_unsigned_int_type (tree type);\n-void set_externally_visible (tree decl);\n-\n-void set_inline (tree decl);\n-\n-void dump_function (FILE *dump_file, brig_function *f);\n-\n-#endif"}, {"sha": "2ee561a65bab78048955f9068f761e865b4fb3be", "filename": "gcc/brig/brigfrontend/brig-util.cc", "status": "removed", "additions": 0, "deletions": 574, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,574 +0,0 @@\n-/* brig-util.cc -- gccbrig utility functions\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include <sstream>\n-\n-#include \"stdint.h\"\n-#include \"hsa-brig-format.h\"\n-#include \"brig-util.h\"\n-#include \"errors.h\"\n-#include \"diagnostic-core.h\"\n-#include \"print-tree.h\"\n-\n-bool\n-group_variable_offset_index::has_variable (const std::string &name) const\n-{\n-  varname_offset_table::const_iterator i = m_group_offsets.find (name);\n-  return i != m_group_offsets.end ();\n-}\n-\n-/* Adds a new group segment variable.  */\n-\n-void\n-group_variable_offset_index::add (const std::string &name, size_t size,\n-\t\t\t\t  size_t alignment)\n-{\n-  size_t align_padding = m_next_group_offset % alignment == 0 ?\n-    0 : (alignment - m_next_group_offset % alignment);\n-  m_next_group_offset += align_padding;\n-  m_group_offsets[name] = m_next_group_offset;\n-  m_next_group_offset += size;\n-}\n-\n-size_t\n-group_variable_offset_index::segment_offset (const std::string &name) const\n-{\n-  varname_offset_table::const_iterator i = m_group_offsets.find (name);\n-  gcc_assert (i != m_group_offsets.end ());\n-  return (*i).second;\n-}\n-\n-/* Return true if operand number OPNUM of instruction with OPCODE is an output.\n-   False if it is an input.  Some code reused from Martin Jambor's gcc-hsa\n-   tree.  */\n-\n-bool\n-gccbrig_hsa_opcode_op_output_p (BrigOpcode16_t opcode, int opnum)\n-{\n-  switch (opcode)\n-    {\n-    case BRIG_OPCODE_BR:\n-    case BRIG_OPCODE_SBR:\n-    case BRIG_OPCODE_CBR:\n-    case BRIG_OPCODE_ST:\n-    case BRIG_OPCODE_ATOMICNORET:\n-    case BRIG_OPCODE_SIGNALNORET:\n-    case BRIG_OPCODE_INITFBAR:\n-    case BRIG_OPCODE_JOINFBAR:\n-    case BRIG_OPCODE_WAITFBAR:\n-    case BRIG_OPCODE_ARRIVEFBAR:\n-    case BRIG_OPCODE_LEAVEFBAR:\n-    case BRIG_OPCODE_RELEASEFBAR:\n-    case BRIG_OPCODE_DEBUGTRAP:\n-      return false;\n-    default:\n-      return opnum == 0;\n-    }\n-}\n-\n-unsigned\n-gccbrig_hsa_type_bit_size (BrigType16_t t)\n-{\n-\n-  unsigned pack_type = t & ~BRIG_TYPE_BASE_MASK;\n-\n-  if (pack_type == BRIG_TYPE_PACK_32)\n-    return 32;\n-  else if (pack_type == BRIG_TYPE_PACK_64)\n-    return 64;\n-  else if (pack_type == BRIG_TYPE_PACK_128)\n-    return 128;\n-\n-  switch (t)\n-    {\n-    case BRIG_TYPE_NONE:\n-      return 0;\n-\n-    case BRIG_TYPE_B1:\n-      return 1;\n-\n-    case BRIG_TYPE_U8:\n-    case BRIG_TYPE_S8:\n-    case BRIG_TYPE_B8:\n-      return 8;\n-\n-    case BRIG_TYPE_U16:\n-    case BRIG_TYPE_S16:\n-    case BRIG_TYPE_B16:\n-    case BRIG_TYPE_F16:\n-      return 16;\n-\n-    case BRIG_TYPE_U32:\n-    case BRIG_TYPE_S32:\n-    case BRIG_TYPE_B32:\n-    case BRIG_TYPE_F32:\n-    case BRIG_TYPE_U8X4:\n-    case BRIG_TYPE_U16X2:\n-    case BRIG_TYPE_S8X4:\n-    case BRIG_TYPE_S16X2:\n-    case BRIG_TYPE_F16X2:\n-    case BRIG_TYPE_SIG32:\n-      return 32;\n-\n-    case BRIG_TYPE_U64:\n-    case BRIG_TYPE_S64:\n-    case BRIG_TYPE_F64:\n-    case BRIG_TYPE_B64:\n-    case BRIG_TYPE_U8X8:\n-    case BRIG_TYPE_U16X4:\n-    case BRIG_TYPE_U32X2:\n-    case BRIG_TYPE_S8X8:\n-    case BRIG_TYPE_S16X4:\n-    case BRIG_TYPE_S32X2:\n-    case BRIG_TYPE_F16X4:\n-    case BRIG_TYPE_F32X2:\n-    case BRIG_TYPE_SIG64:\n-      return 64;\n-\n-    case BRIG_TYPE_B128:\n-    case BRIG_TYPE_U8X16:\n-    case BRIG_TYPE_U16X8:\n-    case BRIG_TYPE_U32X4:\n-    case BRIG_TYPE_U64X2:\n-    case BRIG_TYPE_S8X16:\n-    case BRIG_TYPE_S16X8:\n-    case BRIG_TYPE_S32X4:\n-    case BRIG_TYPE_S64X2:\n-    case BRIG_TYPE_F16X8:\n-    case BRIG_TYPE_F32X4:\n-    case BRIG_TYPE_F64X2:\n-      return 128;\n-\n-    default:\n-      printf (\"HMM %d %x\\n\", t, t);\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* gcc-hsa borrowed code ENDS.  */\n-\n-uint64_t\n-gccbrig_to_uint64_t (const BrigUInt64 &brig_type)\n-{\n-  return (uint64_t (brig_type.hi) << 32) | uint64_t (brig_type.lo);\n-}\n-\n-int\n-gccbrig_reg_size (const BrigOperandRegister *brig_reg)\n-{\n-  switch (brig_reg->regKind)\n-    {\n-    case BRIG_REGISTER_KIND_CONTROL:\n-      return 1;\n-    case BRIG_REGISTER_KIND_SINGLE:\n-      return 32;\n-    case BRIG_REGISTER_KIND_DOUBLE:\n-      return 64;\n-    case BRIG_REGISTER_KIND_QUAD:\n-      return 128;\n-    default:\n-      gcc_unreachable ();\n-      break;\n-    }\n-}\n-\n-std::string\n-gccbrig_reg_name (const BrigOperandRegister *reg)\n-{\n-  std::ostringstream strstr;\n-  switch (reg->regKind)\n-    {\n-    case BRIG_REGISTER_KIND_CONTROL:\n-      strstr << 'c';\n-      break;\n-    case BRIG_REGISTER_KIND_SINGLE:\n-      strstr << 's';\n-      break;\n-    case BRIG_REGISTER_KIND_DOUBLE:\n-      strstr << 'd';\n-      break;\n-    case BRIG_REGISTER_KIND_QUAD:\n-      strstr << 'q';\n-      break;\n-    default:\n-      gcc_unreachable ();\n-      return \"\";\n-    }\n-  strstr << reg->regNum;\n-  return strstr.str ();\n-}\n-\n-std::string\n-gccbrig_type_name (BrigType16_t type)\n-{\n-  switch (type)\n-    {\n-    case BRIG_TYPE_U8:\n-      return \"u8\";\n-    case BRIG_TYPE_U16:\n-      return \"u16\";\n-    case BRIG_TYPE_U32:\n-      return \"u32\";\n-    case BRIG_TYPE_U64:\n-      return \"u64\";\n-    case BRIG_TYPE_S8:\n-      return \"s8\";\n-    case BRIG_TYPE_S16:\n-      return \"s16\";\n-    case BRIG_TYPE_S32:\n-      return \"s32\";\n-    case BRIG_TYPE_S64:\n-      return \"s64\";\n-    default:\n-      gcc_unreachable ();\n-      break;\n-    }\n-}\n-\n-std::string\n-gccbrig_segment_name (BrigSegment8_t segment)\n-{\n-  if (segment == BRIG_SEGMENT_GLOBAL)\n-    return \"global\";\n-  else if (segment == BRIG_SEGMENT_GROUP)\n-    return \"group\";\n-  else if (segment == BRIG_SEGMENT_PRIVATE)\n-    return \"private\";\n-  else\n-    gcc_unreachable ();\n-}\n-\n-bool\n-gccbrig_is_float_type (BrigType16_t type)\n-{\n-  return (type == BRIG_TYPE_F32 || type == BRIG_TYPE_F64\n-\t  || type == BRIG_TYPE_F16);\n-}\n-\n-BrigType16_t\n-gccbrig_tree_type_to_hsa_type (tree tree_type)\n-{\n-  if (INTEGRAL_TYPE_P (tree_type))\n-    {\n-      if (TYPE_UNSIGNED (tree_type))\n-\t{\n-\t  switch (int_size_in_bytes (tree_type))\n-\t    {\n-\t    case 1:\n-\t      return BRIG_TYPE_U8;\n-\t    case 2:\n-\t      return BRIG_TYPE_U16;\n-\t    case 4:\n-\t      return BRIG_TYPE_U32;\n-\t    case 8:\n-\t      return BRIG_TYPE_U64;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  switch (int_size_in_bytes (tree_type))\n-\t    {\n-\t    case 1:\n-\t      return BRIG_TYPE_S8;\n-\t    case 2:\n-\t      return BRIG_TYPE_S16;\n-\t    case 4:\n-\t      return BRIG_TYPE_S32;\n-\t    case 8:\n-\t      return BRIG_TYPE_S64;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  else if (VECTOR_TYPE_P (tree_type))\n-    {\n-      tree element_type = TREE_TYPE (tree_type);\n-      size_t element_size = int_size_in_bytes (element_type) * 8;\n-      BrigType16_t brig_element_type;\n-      switch (element_size)\n-\t{\n-\tcase 8:\n-\t  brig_element_type\n-\t    = TYPE_UNSIGNED (element_type) ? BRIG_TYPE_U8 : BRIG_TYPE_S8;\n-\t  break;\n-\tcase 16:\n-\t  brig_element_type\n-\t    = TYPE_UNSIGNED (element_type) ? BRIG_TYPE_U16 : BRIG_TYPE_S16;\n-\t  break;\n-\tcase 32:\n-\t  brig_element_type\n-\t    = TYPE_UNSIGNED (element_type) ? BRIG_TYPE_U32 : BRIG_TYPE_S32;\n-\t  break;\n-\tcase 64:\n-\t  brig_element_type\n-\t    = TYPE_UNSIGNED (element_type) ? BRIG_TYPE_U64 : BRIG_TYPE_S64;\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      BrigType16_t pack_type;\n-      switch (int_size_in_bytes (tree_type) * 8)\n-\t{\n-\tcase 32:\n-\t  pack_type = BRIG_TYPE_PACK_32;\n-\t  break;\n-\tcase 64:\n-\t  pack_type = BRIG_TYPE_PACK_64;\n-\t  break;\n-\tcase 128:\n-\t  pack_type = BRIG_TYPE_PACK_128;\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-      return brig_element_type | pack_type;\n-    }\n-  gcc_unreachable ();\n-}\n-\n-/* Returns true in case the operation is a \"bit level\" operation,\n-   that is, not having operand type depending semantical differences.  */\n-\n-bool\n-gccbrig_is_bit_operation (BrigOpcode16_t opcode)\n-{\n-  return opcode == BRIG_OPCODE_CMOV || opcode == BRIG_OPCODE_SHUFFLE\n-\t || opcode == BRIG_OPCODE_UNPACK || opcode == BRIG_OPCODE_UNPACKLO\n-\t || opcode == BRIG_OPCODE_UNPACKHI || opcode == BRIG_OPCODE_ST\n-\t || opcode == BRIG_OPCODE_PACK;\n-}\n-\n-/* The program scope definition can be left external within the\n-   kernel binary which means it must be defined by the host via\n-   HSA runtime.  For these we have special treatment:\n-   Create additional pointer indirection when accessing the variable\n-   value from kernel code through a generated pointer\n-   __gccbrig_ptr_variable_name.  The pointer value then can be set either\n-   within the kernel binary (in case of a later linked in definition)\n-   or from the host.  */\n-\n-bool\n-gccbrig_might_be_host_defined_var_p (const BrigDirectiveVariable *brigVar)\n-{\n-  bool is_definition = brigVar->modifier & BRIG_VARIABLE_DEFINITION;\n-  return (brigVar->segment == BRIG_SEGMENT_GLOBAL\n-\t  || brigVar->segment == BRIG_SEGMENT_READONLY) && !is_definition\n-    && brigVar->linkage == BRIG_LINKAGE_PROGRAM\n-    && (brigVar->allocation == BRIG_ALLOCATION_PROGRAM\n-\t|| brigVar->allocation == BRIG_ALLOCATION_AGENT);\n-}\n-\n-/* Produce a GENERIC type for the given HSA/BRIG type.  Returns the element\n-   type in case of vector instructions.  */\n-\n-tree\n-gccbrig_tree_type_for_hsa_type (BrigType16_t brig_type)\n-{\n-  tree tree_type = NULL_TREE;\n-\n-  if (hsa_type_packed_p (brig_type))\n-    {\n-      /* The element type is encoded in the bottom 5 bits.  */\n-      BrigType16_t inner_brig_type = brig_type & BRIG_TYPE_BASE_MASK;\n-\n-      unsigned full_size = gccbrig_hsa_type_bit_size (brig_type);\n-\n-      if (inner_brig_type == BRIG_TYPE_F16)\n-\treturn build_vector_type (gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U16),\n-\t\t\t\t  full_size / 16);\n-\n-      tree inner_type = gccbrig_tree_type_for_hsa_type (inner_brig_type);\n-\n-      unsigned inner_size = gccbrig_hsa_type_bit_size (inner_brig_type);\n-      unsigned nunits = full_size / inner_size;\n-      tree_type = build_vector_type (inner_type, nunits);\n-    }\n-  else\n-    {\n-      switch (brig_type)\n-\t{\n-\tcase BRIG_TYPE_NONE:\n-\t  tree_type = void_type_node;\n-\t  break;\n-\tcase BRIG_TYPE_B1:\n-\t  tree_type = boolean_type_node;\n-\t  break;\n-\tcase BRIG_TYPE_S8:\n-\tcase BRIG_TYPE_S16:\n-\tcase BRIG_TYPE_S32:\n-\tcase BRIG_TYPE_S64:\n-\t  /* Ensure a fixed width integer.  */\n-\t  tree_type\n-\t    = build_nonstandard_integer_type\n-\t    (gccbrig_hsa_type_bit_size (brig_type), false);\n-\t  break;\n-\tcase BRIG_TYPE_U8:\n-\t  return unsigned_char_type_node;\n-\tcase BRIG_TYPE_U16:\n-\tcase BRIG_TYPE_U32:\n-\tcase BRIG_TYPE_U64:\n-\tcase BRIG_TYPE_B8: /* Handle bit vectors as unsigned ints.  */\n-\tcase BRIG_TYPE_B16:\n-\tcase BRIG_TYPE_B32:\n-\tcase BRIG_TYPE_B64:\n-\tcase BRIG_TYPE_B128:\n-\tcase BRIG_TYPE_SIG32: /* Handle signals as integers for now.  */\n-\tcase BRIG_TYPE_SIG64:\n-\t  tree_type = build_nonstandard_integer_type\n-\t    (gccbrig_hsa_type_bit_size (brig_type), true);\n-\t  break;\n-\tcase BRIG_TYPE_F16:\n-\t  tree_type = uint16_type_node;\n-\t  break;\n-\tcase BRIG_TYPE_F32:\n-\t  /* TODO: make sure that the alignment of the float are at least as\n-\t     strict than mandated by HSA, and conform to IEEE (like mandated\n-\t     by HSA).  */\n-\t  tree_type = float_type_node;\n-\t  break;\n-\tcase BRIG_TYPE_F64:\n-\t  tree_type = double_type_node;\n-\t  break;\n-\tcase BRIG_TYPE_SAMP:\n-\tcase BRIG_TYPE_ROIMG:\n-\tcase BRIG_TYPE_WOIMG:\n-\tcase BRIG_TYPE_RWIMG:\n-\t  {\n-\t    /* Handle images and samplers as target-specific blobs of data\n-\t       that should be allocated earlier on from the runtime side.\n-\t       Create a void* that should be initialized to point to the blobs\n-\t       by the kernel launcher.  Images and samplers are accessed\n-\t       via builtins that take void* as the reference.  TODO: who and\n-\t       how these arrays should be initialized?  */\n-\t    tree void_ptr = build_pointer_type (void_type_node);\n-\t    return void_ptr;\n-\t  }\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t  break;\n-\t}\n-    }\n-\n-  /* Drop const qualifiers.  */\n-  return tree_type;\n-}\n-\n-/* Calculates numeric identifier for the HSA register REG.\n-\n-   Returned value is bound to [0, BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT].  */\n-\n-size_t\n-gccbrig_hsa_reg_id (const BrigOperandRegister &reg)\n-{\n-  size_t offset = reg.regNum;\n-  switch (reg.regKind)\n-    {\n-    case BRIG_REGISTER_KIND_QUAD:\n-      offset\n-\t+= BRIG_2_TREE_HSAIL_D_REG_COUNT + BRIG_2_TREE_HSAIL_S_REG_COUNT\n-\t+ BRIG_2_TREE_HSAIL_C_REG_COUNT;\n-      break;\n-    case BRIG_REGISTER_KIND_DOUBLE:\n-      offset += BRIG_2_TREE_HSAIL_S_REG_COUNT + BRIG_2_TREE_HSAIL_C_REG_COUNT;\n-      break;\n-    case BRIG_REGISTER_KIND_SINGLE:\n-      offset += BRIG_2_TREE_HSAIL_C_REG_COUNT;\n-    case BRIG_REGISTER_KIND_CONTROL:\n-      break;\n-    default:\n-      gcc_unreachable ();\n-      break;\n-    }\n-  return offset;\n-}\n-\n-std::string\n-gccbrig_hsa_reg_name_from_id (size_t reg_id)\n-{\n-  char reg_name[32];\n-  long unsigned int reg_hash = (long unsigned int) reg_id;\n-  if (reg_hash < BRIG_2_TREE_HSAIL_C_REG_COUNT)\n-    {\n-      sprintf (reg_name, \"$c%lu\", reg_hash);\n-      return reg_name;\n-    }\n-\n-  reg_hash -= BRIG_2_TREE_HSAIL_C_REG_COUNT;\n-  if (reg_hash < BRIG_2_TREE_HSAIL_S_REG_COUNT)\n-    {\n-      sprintf (reg_name, \"$s%lu\", reg_hash);\n-      return reg_name;\n-    }\n-\n-  reg_hash -= BRIG_2_TREE_HSAIL_S_REG_COUNT;\n-  if (reg_hash < BRIG_2_TREE_HSAIL_D_REG_COUNT)\n-    {\n-      sprintf (reg_name, \"$d%lu\", reg_hash);\n-      return reg_name;\n-    }\n-\n-   reg_hash -= BRIG_2_TREE_HSAIL_D_REG_COUNT;\n-   if (reg_hash < BRIG_2_TREE_HSAIL_Q_REG_COUNT)\n-    {\n-      sprintf (reg_name, \"$q%lu\", reg_hash);\n-      return reg_name;\n-    }\n-\n-  gcc_unreachable ();\n-  return \"$??\";\n-}\n-\n-/* Prints statistics of register usage to stdout.  */\n-\n-void\n-gccbrig_print_reg_use_info (FILE *dump, const regs_use_index &info)\n-{\n-  regs_use_index::const_iterator begin_it = info.begin ();\n-  regs_use_index::const_iterator end_it = info.end ();\n-  for (regs_use_index::const_iterator it = begin_it; it != end_it; it++)\n-    {\n-      std::string hsa_reg = gccbrig_hsa_reg_name_from_id (it->first);\n-      printf (\"%s:\\n\", hsa_reg.c_str ());\n-      const reg_use_info &info = it->second;\n-      typedef std::vector<std::pair<tree, size_t> >::const_iterator reg_use_it;\n-      reg_use_it begin_it2 = info.m_type_refs.begin ();\n-      reg_use_it end_it2 = info.m_type_refs.end ();\n-      for (reg_use_it it2 = begin_it2; it2 != end_it2; it2++)\n-\t{\n-\t  fprintf (dump, \"(%lu) \", (long unsigned int) it2->second);\n-\t  print_node_brief (dump, \"\", it2->first, 0);\n-\t  fprintf (dump, \"\\n\");\n-\t}\n-    }\n-}\n-\n-/* Return true if TYPE is a packed HSA type.  */\n-\n-bool\n-hsa_type_packed_p (BrigType16_t type)\n-{\n-  return (type & BRIG_TYPE_PACK_MASK) != BRIG_TYPE_PACK_NONE;\n-}\n-"}, {"sha": "339db61879165de24518fc758772861fa7c64b8d", "filename": "gcc/brig/brigfrontend/brig-util.h", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,120 +0,0 @@\n-/* brig-util.h -- gccbrig utility functions\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_BRIG_UTIL_H\n-#define GCC_BRIG_UTIL_H\n-\n-#include <map>\n-#include <vector>\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"ansidecl.h\"\n-#include \"coretypes.h\"\n-#include \"opts.h\"\n-#include \"tree.h\"\n-\n-/* There are 128 c regs and 2048 s/d/q regs each in the HSAIL.  */\n-#define BRIG_2_TREE_HSAIL_C_REG_COUNT (128)\n-#define BRIG_2_TREE_HSAIL_S_REG_COUNT (2048)\n-#define BRIG_2_TREE_HSAIL_D_REG_COUNT (2048)\n-#define BRIG_2_TREE_HSAIL_Q_REG_COUNT (2048)\n-#define BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT\t\t\t\t\\\n-  (BRIG_2_TREE_HSAIL_C_REG_COUNT + BRIG_2_TREE_HSAIL_S_REG_COUNT\t\\\n-   + BRIG_2_TREE_HSAIL_D_REG_COUNT + BRIG_2_TREE_HSAIL_Q_REG_COUNT)\n-\n-/* Helper class for keeping book of group variable offsets.  */\n-\n-class group_variable_offset_index\n-{\n-public:\n-  group_variable_offset_index () : m_next_group_offset (0) {}\n-\n-  typedef std::map<std::string, size_t> varname_offset_table;\n-\n-  bool has_variable (const std::string &name) const;\n-  void add (const std::string &name, size_t size, size_t alignment);\n-  size_t segment_offset (const std::string &name) const;\n-  size_t size () const { return m_next_group_offset; }\n-\n-private:\n-  size_t m_next_group_offset;\n-  varname_offset_table m_group_offsets;\n-};\n-\n-bool gccbrig_hsa_opcode_op_output_p (BrigOpcode16_t opcode, int opnum);\n-\n-unsigned gccbrig_hsa_type_bit_size (BrigType16_t t);\n-\n-uint64_t gccbrig_to_uint64_t (const BrigUInt64 &brig_type);\n-\n-int gccbrig_reg_size (const BrigOperandRegister *brig_reg);\n-\n-std::string gccbrig_reg_name (const BrigOperandRegister *reg);\n-\n-std::string gccbrig_type_name (BrigType16_t type);\n-\n-std::string gccbrig_segment_name (BrigSegment8_t segment);\n-\n-bool gccbrig_is_float_type (BrigType16_t type);\n-\n-bool gccbrig_is_bit_operation (BrigOpcode16_t opcode);\n-\n-BrigType16_t gccbrig_tree_type_to_hsa_type (tree tree_type);\n-tree gccbrig_tree_type_for_hsa_type (BrigType16_t brig_type);\n-\n-bool gccbrig_might_be_host_defined_var_p (const BrigDirectiveVariable *brigVar);\n-\n-/* From hsa.h.  */\n-bool hsa_type_packed_p (BrigType16_t type);\n-\n-struct reg_use_info\n-{\n-  /* This vector keeps count of the times an HSAIL register is used as\n-     a tree type in generic expressions.  The count is used to select\n-     type for 'register' variables to reduce emission of\n-     VIEW_CONVERT_EXPR nodes.  The data is kept in vector (insertion\n-     order) for determinism, in a case there is a tie with the\n-     counts.  */\n-  std::vector<std::pair<tree, size_t> > m_type_refs;\n-  /* Tree to index.  Lookup for the above vector.  */\n-  std::map<tree, size_t> m_type_refs_lookup;\n-};\n-\n-/* key = hsa register entry generated by gccbrig_hsa_reg_id ().  */\n-typedef std::map<size_t, reg_use_info> regs_use_index;\n-\n-size_t gccbrig_hsa_reg_id (const BrigOperandRegister &reg);\n-std::string gccbrig_hsa_reg_name_from_id (size_t reg_hash);\n-\n-void gccbrig_print_reg_use_info (FILE *dump, const regs_use_index &info);\n-\n-/* Return the number of elements in a VECTOR_TYPE.  BRIG does not support\n-   variable-length vectors.  */\n-inline unsigned HOST_WIDE_INT\n-gccbrig_type_vector_subparts (const_tree type)\n-{\n-  return TYPE_VECTOR_SUBPARTS (type).to_constant ();\n-}\n-\n-bool hsa_type_packed_p (BrigType16_t type);\n-\n-#endif"}, {"sha": "cd77714ef54dc674f553a7167b171a569ede6d59", "filename": "gcc/brig/brigfrontend/brig-variable-handler.cc", "status": "removed", "additions": 0, "deletions": 270, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-variable-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-variable-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-variable-handler.cc?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,270 +0,0 @@\n-/* brig-variable-handler.cc -- brig variable directive handling\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-   for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"brig-code-entry-handler.h\"\n-\n-#include \"stringpool.h\"\n-#include \"errors.h\"\n-#include \"brig-machine.h\"\n-#include \"brig-util.h\"\n-#include \"print-tree.h\"\n-#include \"diagnostic-core.h\"\n-#include \"brig-to-generic.h\"\n-\n-tree\n-brig_directive_variable_handler::build_variable\n-  (const BrigDirectiveVariable *brigVar, tree_code var_decltype)\n-{\n-  std::string var_name = m_parent.get_mangled_name (brigVar);\n-\n-  bool is_definition = brigVar->modifier & BRIG_VARIABLE_DEFINITION;\n-\n-  tree name_identifier = get_identifier (var_name.c_str ());\n-\n-  tree var_decl;\n-  tree t;\n-  if (brigVar->type & BRIG_TYPE_ARRAY)\n-    {\n-      tree element_type\n-\t= gccbrig_tree_type_for_hsa_type (brigVar->type & ~BRIG_TYPE_ARRAY);\n-      uint64_t element_count = gccbrig_to_uint64_t (brigVar->dim);\n-      if (is_definition && element_count == 0)\n-\tfatal_error (UNKNOWN_LOCATION, \"Array definition with zero elements.\");\n-      if (var_decltype == PARM_DECL)\n-\tt = build_pointer_type (element_type);\n-      else\n-\tt = build_array_type_nelts (element_type, element_count);\n-    }\n-  else\n-    {\n-      t = gccbrig_tree_type_for_hsa_type (brigVar->type);\n-    }\n-\n-  size_t alignment = get_brig_var_alignment (brigVar);\n-\n-  if (brigVar->segment == BRIG_SEGMENT_READONLY\n-      || brigVar->segment == BRIG_SEGMENT_KERNARG\n-      || (brigVar->modifier & BRIG_VARIABLE_CONST))\n-    TYPE_READONLY (t) = 1;\n-\n-  TYPE_ADDR_SPACE (t) = gccbrig_get_target_addr_space_id (brigVar->segment);\n-\n-  var_decl = build_decl (UNKNOWN_LOCATION, var_decltype, name_identifier, t);\n-\n-  SET_DECL_ALIGN (var_decl, alignment * BITS_PER_UNIT);\n-\n-  /* Force the HSA alignments.  */\n-  DECL_USER_ALIGN (var_decl) = 1;\n-\n-  TREE_USED (var_decl) = 1;\n-\n-  TREE_PUBLIC (var_decl) = 1;\n-  if (is_definition)\n-    DECL_EXTERNAL (var_decl) = 0;\n-  else\n-    DECL_EXTERNAL (var_decl) = 1; /* The definition is elsewhere.  */\n-\n-  if (brigVar->init != 0)\n-    {\n-      gcc_assert (brigVar->segment == BRIG_SEGMENT_READONLY\n-\t\t  || brigVar->segment == BRIG_SEGMENT_GLOBAL);\n-\n-      const BrigBase *cst_operand_data\n-\t= m_parent.get_brig_operand_entry (brigVar->init);\n-\n-      tree initializer = NULL_TREE;\n-      if (cst_operand_data->kind == BRIG_KIND_OPERAND_CONSTANT_BYTES)\n-\tinitializer = get_tree_cst_for_hsa_operand\n-\t  ((const BrigOperandConstantBytes *) cst_operand_data, t);\n-      else\n-\terror (\"variable initializers of type %x not implemented\",\n-\t       cst_operand_data->kind);\n-      gcc_assert (initializer != NULL_TREE);\n-      DECL_INITIAL (var_decl) = initializer;\n-    }\n-\n-  if (var_decltype == PARM_DECL)\n-    {\n-      DECL_ARG_TYPE (var_decl) = TREE_TYPE (var_decl);\n-      DECL_EXTERNAL (var_decl) = 0;\n-      TREE_PUBLIC (var_decl) = 0;\n-    }\n-\n-  TREE_ADDRESSABLE (var_decl) = 1;\n-\n-  TREE_USED (var_decl) = 1;\n-  DECL_NONLOCAL (var_decl) = 1;\n-  DECL_ARTIFICIAL (var_decl) = 0;\n-\n-  return var_decl;\n-}\n-\n-size_t\n-brig_directive_variable_handler::operator () (const BrigBase *base)\n-{\n-  const BrigDirectiveVariable *brigVar = (const BrigDirectiveVariable *) base;\n-\n-  bool is_definition = brigVar->modifier & BRIG_VARIABLE_DEFINITION;\n-\n-  size_t var_size;\n-  tree var_type;\n-  if (brigVar->type & BRIG_TYPE_ARRAY)\n-    {\n-      tree element_type\n-\t= gccbrig_tree_type_for_hsa_type (brigVar->type & ~BRIG_TYPE_ARRAY);\n-      uint64_t element_count = gccbrig_to_uint64_t (brigVar->dim);\n-      if (is_definition && element_count == 0)\n-\tfatal_error (UNKNOWN_LOCATION, \"Array definition with zero elements.\");\n-      var_type = build_array_type_nelts (element_type, element_count);\n-      size_t element_size = tree_to_uhwi (TYPE_SIZE (element_type));\n-      var_size = element_size * element_count / 8;\n-    }\n-  else\n-    {\n-      var_type = gccbrig_tree_type_for_hsa_type (brigVar->type);\n-      var_size = tree_to_uhwi (TYPE_SIZE (var_type)) / 8;\n-    }\n-\n-  size_t alignment = get_brig_var_alignment (brigVar);\n-\n-  bool function_scope = m_parent.m_cf != NULL;\n-\n-  if (function_scope)\n-    m_parent.m_cf->m_function_scope_vars.insert (base);\n-\n-  std::string var_name = m_parent.get_mangled_name (brigVar);\n-  if (brigVar->segment == BRIG_SEGMENT_GROUP)\n-    {\n-      /* Non-kernel scope group variables have been added at the\n-\t 'analyze' stage.  */\n-      m_parent.add_group_variable (var_name, var_size, alignment,\n-\t\t\t\t   function_scope);\n-      return base->byteCount;\n-    }\n-\n-  /* During analyze, handle only (module scope) group variables.  */\n-  if (m_parent.m_analyzing)\n-    return base->byteCount;\n-\n-  if (brigVar->segment == BRIG_SEGMENT_KERNARG)\n-    {\n-      /* Do not create a real variable, but only a table of\n-\t offsets to the kernarg segment buffer passed as the\n-\t single argument by the kernel launcher for later\n-\t reference.  Ignore kernel declarations.  */\n-      if (m_parent.m_cf != NULL && m_parent.m_cf->m_func_decl != NULL_TREE)\n-\tm_parent.m_cf->append_kernel_arg (brigVar, var_size, alignment);\n-      return base->byteCount;\n-    }\n-  else if (brigVar->segment == BRIG_SEGMENT_PRIVATE\n-\t   || brigVar->segment == BRIG_SEGMENT_SPILL)\n-    {\n-      /* Private variables are handled like group variables,\n-\t except that their offsets are multiplied by the work-item\n-\t flat id, when accessed.  */\n-      if (!m_parent.has_private_variable (var_name))\n-\tm_parent.append_private_variable (var_name, var_size, alignment);\n-      return base->byteCount;\n-    }\n-  else if (brigVar->segment == BRIG_SEGMENT_GLOBAL\n-\t   || brigVar->segment == BRIG_SEGMENT_READONLY)\n-    {\n-      tree def = is_definition ? NULL_TREE :\n-\tm_parent.global_variable (var_name);\n-\n-      if (!is_definition && def != NULL_TREE)\n-\t{\n-\t  /* We have a definition already for this declaration.\n-\t     Use the definition instead of the declaration.  */\n-\t}\n-      else if (gccbrig_might_be_host_defined_var_p (brigVar))\n-\t{\n-\t  tree var_decl = build_variable (brigVar);\n-\t  m_parent.add_host_def_var_ptr (var_name, var_decl);\n-\t}\n-      else\n-\t{\n-\t  tree var_decl = build_variable (brigVar);\n-\t  /* Make all global variables program scope for now\n-\t     so we can get their address from the Runtime API.  */\n-\t  DECL_CONTEXT (var_decl) = NULL_TREE;\n-\t  TREE_STATIC (var_decl) = 1;\n-\t  TREE_PUBLIC (var_decl) = 1;\n-\t  set_externally_visible (var_decl);\n-\t  m_parent.add_global_variable (var_name, var_decl);\n-\t}\n-    }\n-  else if (brigVar->segment == BRIG_SEGMENT_ARG)\n-    {\n-\n-      if (m_parent.m_cf->m_generating_arg_block)\n-\t{\n-\t  tree var_decl = build_variable (brigVar);\n-\t  tree bind_expr = m_parent.m_cf->m_current_bind_expr;\n-\n-\t  DECL_CONTEXT (var_decl) = m_parent.m_cf->m_func_decl;\n-\t  DECL_CHAIN (var_decl) = BIND_EXPR_VARS (bind_expr);\n-\t  BIND_EXPR_VARS (bind_expr) = var_decl;\n-\t  TREE_PUBLIC (var_decl) = 0;\n-\n-\t  m_parent.m_cf->add_arg_variable (brigVar, var_decl);\n-\t}\n-      else\n-\t{\n-\t  /* Must be an incoming function argument which has\n-\t     been parsed in brig-function-handler.cc.  No\n-\t     need to generate anything here.  */\n-\t}\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  return base->byteCount;\n-}\n-\n-/* Returns the alignment for the given BRIG variable.  In case the variable\n-   explicitly defines alignment and its larger than the natural alignment,\n-   returns it instead of the natural one.  */\n-\n-size_t\n-brig_directive_variable_handler::get_brig_var_alignment\n-(const BrigDirectiveVariable *brigVar)\n-{\n-\n-  size_t defined_alignment\n-    = brigVar->align == BRIG_ALIGNMENT_NONE ? 0 : 1 << (brigVar->align - 1);\n-  size_t natural_alignment;\n-  if (brigVar->type & BRIG_TYPE_ARRAY)\n-    {\n-      tree element_type\n-\t= gccbrig_tree_type_for_hsa_type (brigVar->type & ~BRIG_TYPE_ARRAY);\n-      size_t element_size = tree_to_uhwi (TYPE_SIZE (element_type));\n-      natural_alignment = element_size / BITS_PER_UNIT;\n-    }\n-  else\n-    {\n-      tree t = gccbrig_tree_type_for_hsa_type (brigVar->type);\n-      natural_alignment = tree_to_uhwi (TYPE_SIZE (t)) / BITS_PER_UNIT;\n-    }\n-\n-  return natural_alignment > defined_alignment\n-    ? natural_alignment : defined_alignment;\n-}"}, {"sha": "ee72ea83c43a582fb07343cd22b0e6a9729c64c8", "filename": "gcc/brig/brigfrontend/hsa-brig-format.h", "status": "removed", "additions": 0, "deletions": 1234, "changes": 1234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fhsa-brig-format.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fhsa-brig-format.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fhsa-brig-format.h?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,1234 +0,0 @@\n-/* HSA BRIG (binary representation of HSAIL) 1.0.1 representation description.\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.\n-\n-The contents of the file was created by extracting data structures, enum,\n-typedef and other definitions from HSA Programmer's Reference Manual Version\n-1.0.1 (http://www.hsafoundation.com/standards/).\n-\n-HTML version is provided on the following link:\n-http://www.hsafoundation.com/html/Content/PRM/Topics/PRM_title_page.htm */\n-\n-#ifndef HSA_BRIG_FORMAT_H\n-#define HSA_BRIG_FORMAT_H\n-\n-struct BrigModuleHeader;\n-typedef uint16_t BrigKind16_t;\n-typedef uint32_t BrigVersion32_t;\n-\n-typedef BrigModuleHeader *BrigModule_t;\n-typedef uint32_t BrigDataOffset32_t;\n-typedef uint32_t BrigCodeOffset32_t;\n-typedef uint32_t BrigOperandOffset32_t;\n-typedef BrigDataOffset32_t BrigDataOffsetString32_t;\n-typedef BrigDataOffset32_t BrigDataOffsetCodeList32_t;\n-typedef BrigDataOffset32_t BrigDataOffsetOperandList32_t;\n-typedef uint8_t BrigAlignment8_t;\n-\n-enum BrigAlignment\n-{\n-  BRIG_ALIGNMENT_NONE = 0,\n-  BRIG_ALIGNMENT_1 = 1,\n-  BRIG_ALIGNMENT_2 = 2,\n-  BRIG_ALIGNMENT_4 = 3,\n-  BRIG_ALIGNMENT_8 = 4,\n-  BRIG_ALIGNMENT_16 = 5,\n-  BRIG_ALIGNMENT_32 = 6,\n-  BRIG_ALIGNMENT_64 = 7,\n-  BRIG_ALIGNMENT_128 = 8,\n-  BRIG_ALIGNMENT_256 = 9\n-};\n-\n-typedef uint8_t BrigAllocation8_t;\n-\n-enum BrigAllocation\n-{\n-  BRIG_ALLOCATION_NONE = 0,\n-  BRIG_ALLOCATION_PROGRAM = 1,\n-  BRIG_ALLOCATION_AGENT = 2,\n-  BRIG_ALLOCATION_AUTOMATIC = 3\n-};\n-\n-typedef uint8_t BrigAluModifier8_t;\n-\n-enum BrigAluModifierMask\n-{\n-  BRIG_ALU_FTZ = 1\n-};\n-\n-typedef uint8_t BrigAtomicOperation8_t;\n-\n-enum BrigAtomicOperation\n-{\n-  BRIG_ATOMIC_ADD = 0,\n-  BRIG_ATOMIC_AND = 1,\n-  BRIG_ATOMIC_CAS = 2,\n-  BRIG_ATOMIC_EXCH = 3,\n-  BRIG_ATOMIC_LD = 4,\n-  BRIG_ATOMIC_MAX = 5,\n-  BRIG_ATOMIC_MIN = 6,\n-  BRIG_ATOMIC_OR = 7,\n-  BRIG_ATOMIC_ST = 8,\n-  BRIG_ATOMIC_SUB = 9,\n-  BRIG_ATOMIC_WRAPDEC = 10,\n-  BRIG_ATOMIC_WRAPINC = 11,\n-  BRIG_ATOMIC_XOR = 12,\n-  BRIG_ATOMIC_WAIT_EQ = 13,\n-  BRIG_ATOMIC_WAIT_NE = 14,\n-  BRIG_ATOMIC_WAIT_LT = 15,\n-  BRIG_ATOMIC_WAIT_GTE = 16,\n-  BRIG_ATOMIC_WAITTIMEOUT_EQ = 17,\n-  BRIG_ATOMIC_WAITTIMEOUT_NE = 18,\n-  BRIG_ATOMIC_WAITTIMEOUT_LT = 19,\n-  BRIG_ATOMIC_WAITTIMEOUT_GTE = 20\n-};\n-\n-struct BrigBase\n-{\n-  uint16_t byteCount;\n-  BrigKind16_t kind;\n-};\n-\n-typedef uint8_t BrigCompareOperation8_t;\n-\n-enum BrigCompareOperation\n-{\n-  BRIG_COMPARE_EQ = 0,\n-  BRIG_COMPARE_NE = 1,\n-  BRIG_COMPARE_LT = 2,\n-  BRIG_COMPARE_LE = 3,\n-  BRIG_COMPARE_GT = 4,\n-  BRIG_COMPARE_GE = 5,\n-  BRIG_COMPARE_EQU = 6,\n-  BRIG_COMPARE_NEU = 7,\n-  BRIG_COMPARE_LTU = 8,\n-  BRIG_COMPARE_LEU = 9,\n-  BRIG_COMPARE_GTU = 10,\n-  BRIG_COMPARE_GEU = 11,\n-  BRIG_COMPARE_NUM = 12,\n-  BRIG_COMPARE_NAN = 13,\n-  BRIG_COMPARE_SEQ = 14,\n-  BRIG_COMPARE_SNE = 15,\n-  BRIG_COMPARE_SLT = 16,\n-  BRIG_COMPARE_SLE = 17,\n-  BRIG_COMPARE_SGT = 18,\n-  BRIG_COMPARE_SGE = 19,\n-  BRIG_COMPARE_SGEU = 20,\n-  BRIG_COMPARE_SEQU = 21,\n-  BRIG_COMPARE_SNEU = 22,\n-  BRIG_COMPARE_SLTU = 23,\n-  BRIG_COMPARE_SLEU = 24,\n-  BRIG_COMPARE_SNUM = 25,\n-  BRIG_COMPARE_SNAN = 26,\n-  BRIG_COMPARE_SGTU = 27\n-};\n-\n-typedef uint16_t BrigControlDirective16_t;\n-\n-enum BrigControlDirective\n-{\n-  BRIG_CONTROL_NONE = 0,\n-  BRIG_CONTROL_ENABLEBREAKEXCEPTIONS = 1,\n-  BRIG_CONTROL_ENABLEDETECTEXCEPTIONS = 2,\n-  BRIG_CONTROL_MAXDYNAMICGROUPSIZE = 3,\n-  BRIG_CONTROL_MAXFLATGRIDSIZE = 4,\n-  BRIG_CONTROL_MAXFLATWORKGROUPSIZE = 5,\n-  BRIG_CONTROL_REQUIREDDIM = 6,\n-  BRIG_CONTROL_REQUIREDGRIDSIZE = 7,\n-  BRIG_CONTROL_REQUIREDWORKGROUPSIZE = 8,\n-  BRIG_CONTROL_REQUIRENOPARTIALWORKGROUPS = 9\n-};\n-\n-typedef uint32_t BrigExceptions32_t;\n-\n-enum BrigExceptionsMask\n-{\n-  BRIG_EXCEPTIONS_INVALID_OPERATION = 1 << 0,\n-  BRIG_EXCEPTIONS_DIVIDE_BY_ZERO = 1 << 1,\n-  BRIG_EXCEPTIONS_OVERFLOW = 1 << 2,\n-  BRIG_EXCEPTIONS_UNDERFLOW = 1 << 3,\n-  BRIG_EXCEPTIONS_INEXACT = 1 << 4,\n-  BRIG_EXCEPTIONS_FIRST_USER_DEFINED = 1 << 16\n-};\n-\n-typedef uint8_t BrigExecutableModifier8_t;\n-\n-enum BrigExecutableModifierMask\n-{\n-  BRIG_EXECUTABLE_DEFINITION = 1\n-};\n-\n-typedef uint8_t BrigImageChannelOrder8_t;\n-\n-enum BrigImageChannelOrder\n-{\n-  BRIG_CHANNEL_ORDER_A = 0,\n-  BRIG_CHANNEL_ORDER_R = 1,\n-  BRIG_CHANNEL_ORDER_RX = 2,\n-  BRIG_CHANNEL_ORDER_RG = 3,\n-  BRIG_CHANNEL_ORDER_RGX = 4,\n-  BRIG_CHANNEL_ORDER_RA = 5,\n-  BRIG_CHANNEL_ORDER_RGB = 6,\n-  BRIG_CHANNEL_ORDER_RGBX = 7,\n-  BRIG_CHANNEL_ORDER_RGBA = 8,\n-  BRIG_CHANNEL_ORDER_BGRA = 9,\n-  BRIG_CHANNEL_ORDER_ARGB = 10,\n-  BRIG_CHANNEL_ORDER_ABGR = 11,\n-  BRIG_CHANNEL_ORDER_SRGB = 12,\n-  BRIG_CHANNEL_ORDER_SRGBX = 13,\n-  BRIG_CHANNEL_ORDER_SRGBA = 14,\n-  BRIG_CHANNEL_ORDER_SBGRA = 15,\n-  BRIG_CHANNEL_ORDER_INTENSITY = 16,\n-  BRIG_CHANNEL_ORDER_LUMINANCE = 17,\n-  BRIG_CHANNEL_ORDER_DEPTH = 18,\n-  BRIG_CHANNEL_ORDER_DEPTH_STENCIL = 19,\n-  BRIG_CHANNEL_ORDER_FIRST_USER_DEFINED = 128\n-};\n-\n-typedef uint8_t BrigImageChannelType8_t;\n-\n-enum BrigImageChannelType\n-{\n-  BRIG_CHANNEL_TYPE_SNORM_INT8 = 0,\n-  BRIG_CHANNEL_TYPE_SNORM_INT16 = 1,\n-  BRIG_CHANNEL_TYPE_UNORM_INT8 = 2,\n-  BRIG_CHANNEL_TYPE_UNORM_INT16 = 3,\n-  BRIG_CHANNEL_TYPE_UNORM_INT24 = 4,\n-  BRIG_CHANNEL_TYPE_UNORM_SHORT_555 = 5,\n-  BRIG_CHANNEL_TYPE_UNORM_SHORT_565 = 6,\n-  BRIG_CHANNEL_TYPE_UNORM_INT_101010 = 7,\n-  BRIG_CHANNEL_TYPE_SIGNED_INT8 = 8,\n-  BRIG_CHANNEL_TYPE_SIGNED_INT16 = 9,\n-  BRIG_CHANNEL_TYPE_SIGNED_INT32 = 10,\n-  BRIG_CHANNEL_TYPE_UNSIGNED_INT8 = 11,\n-  BRIG_CHANNEL_TYPE_UNSIGNED_INT16 = 12,\n-  BRIG_CHANNEL_TYPE_UNSIGNED_INT32 = 13,\n-  BRIG_CHANNEL_TYPE_HALF_FLOAT = 14,\n-  BRIG_CHANNEL_TYPE_FLOAT = 15,\n-  BRIG_CHANNEL_TYPE_FIRST_USER_DEFINED = 128\n-};\n-\n-typedef uint8_t BrigImageGeometry8_t;\n-\n-enum BrigImageGeometry\n-{\n-  BRIG_GEOMETRY_1D = 0,\n-  BRIG_GEOMETRY_2D = 1,\n-  BRIG_GEOMETRY_3D = 2,\n-  BRIG_GEOMETRY_1DA = 3,\n-  BRIG_GEOMETRY_2DA = 4,\n-  BRIG_GEOMETRY_1DB = 5,\n-  BRIG_GEOMETRY_2DDEPTH = 6,\n-  BRIG_GEOMETRY_2DADEPTH = 7,\n-  BRIG_GEOMETRY_FIRST_USER_DEFINED = 128\n-};\n-\n-typedef uint8_t BrigImageQuery8_t;\n-\n-enum BrigImageQuery\n-{\n-  BRIG_IMAGE_QUERY_WIDTH = 0,\n-  BRIG_IMAGE_QUERY_HEIGHT = 1,\n-  BRIG_IMAGE_QUERY_DEPTH = 2,\n-  BRIG_IMAGE_QUERY_ARRAY = 3,\n-  BRIG_IMAGE_QUERY_CHANNELORDER = 4,\n-  BRIG_IMAGE_QUERY_CHANNELTYPE = 5\n-};\n-\n-enum BrigKind\n-{\n-  BRIG_KIND_NONE = 0x0000,\n-  BRIG_KIND_DIRECTIVE_BEGIN = 0x1000,\n-  BRIG_KIND_DIRECTIVE_ARG_BLOCK_END = 0x1000,\n-  BRIG_KIND_DIRECTIVE_ARG_BLOCK_START = 0x1001,\n-  BRIG_KIND_DIRECTIVE_COMMENT = 0x1002,\n-  BRIG_KIND_DIRECTIVE_CONTROL = 0x1003,\n-  BRIG_KIND_DIRECTIVE_EXTENSION = 0x1004,\n-  BRIG_KIND_DIRECTIVE_FBARRIER = 0x1005,\n-  BRIG_KIND_DIRECTIVE_FUNCTION = 0x1006,\n-  BRIG_KIND_DIRECTIVE_INDIRECT_FUNCTION = 0x1007,\n-  BRIG_KIND_DIRECTIVE_KERNEL = 0x1008,\n-  BRIG_KIND_DIRECTIVE_LABEL = 0x1009,\n-  BRIG_KIND_DIRECTIVE_LOC = 0x100a,\n-  BRIG_KIND_DIRECTIVE_MODULE = 0x100b,\n-  BRIG_KIND_DIRECTIVE_PRAGMA = 0x100c,\n-  BRIG_KIND_DIRECTIVE_SIGNATURE = 0x100d,\n-  BRIG_KIND_DIRECTIVE_VARIABLE = 0x100e,\n-  BRIG_KIND_DIRECTIVE_END = 0x100f,\n-  BRIG_KIND_INST_BEGIN = 0x2000,\n-  BRIG_KIND_INST_ADDR = 0x2000,\n-  BRIG_KIND_INST_ATOMIC = 0x2001,\n-  BRIG_KIND_INST_BASIC = 0x2002,\n-  BRIG_KIND_INST_BR = 0x2003,\n-  BRIG_KIND_INST_CMP = 0x2004,\n-  BRIG_KIND_INST_CVT = 0x2005,\n-  BRIG_KIND_INST_IMAGE = 0x2006,\n-  BRIG_KIND_INST_LANE = 0x2007,\n-  BRIG_KIND_INST_MEM = 0x2008,\n-  BRIG_KIND_INST_MEM_FENCE = 0x2009,\n-  BRIG_KIND_INST_MOD = 0x200a,\n-  BRIG_KIND_INST_QUERY_IMAGE = 0x200b,\n-  BRIG_KIND_INST_QUERY_SAMPLER = 0x200c,\n-  BRIG_KIND_INST_QUEUE = 0x200d,\n-  BRIG_KIND_INST_SEG = 0x200e,\n-  BRIG_KIND_INST_SEG_CVT = 0x200f,\n-  BRIG_KIND_INST_SIGNAL = 0x2010,\n-  BRIG_KIND_INST_SOURCE_TYPE = 0x2011,\n-  BRIG_KIND_INST_END = 0x2012,\n-  BRIG_KIND_OPERAND_BEGIN = 0x3000,\n-  BRIG_KIND_OPERAND_ADDRESS = 0x3000,\n-  BRIG_KIND_OPERAND_ALIGN = 0x3001,\n-  BRIG_KIND_OPERAND_CODE_LIST = 0x3002,\n-  BRIG_KIND_OPERAND_CODE_REF = 0x3003,\n-  BRIG_KIND_OPERAND_CONSTANT_BYTES = 0x3004,\n-  BRIG_KIND_OPERAND_RESERVED = 0x3005,\n-  BRIG_KIND_OPERAND_CONSTANT_IMAGE = 0x3006,\n-  BRIG_KIND_OPERAND_CONSTANT_OPERAND_LIST = 0x3007,\n-  BRIG_KIND_OPERAND_CONSTANT_SAMPLER = 0x3008,\n-  BRIG_KIND_OPERAND_OPERAND_LIST = 0x3009,\n-  BRIG_KIND_OPERAND_REGISTER = 0x300a,\n-  BRIG_KIND_OPERAND_STRING = 0x300b,\n-  BRIG_KIND_OPERAND_WAVESIZE = 0x300c,\n-  BRIG_KIND_OPERAND_END = 0x300d\n-};\n-\n-typedef uint8_t BrigLinkage8_t;\n-\n-enum BrigLinkage\n-{\n-  BRIG_LINKAGE_NONE = 0,\n-  BRIG_LINKAGE_PROGRAM = 1,\n-  BRIG_LINKAGE_MODULE = 2,\n-  BRIG_LINKAGE_FUNCTION = 3,\n-  BRIG_LINKAGE_ARG = 4\n-};\n-\n-typedef uint8_t BrigMachineModel8_t;\n-\n-enum BrigMachineModel\n-{\n-  BRIG_MACHINE_SMALL = 0,\n-  BRIG_MACHINE_LARGE = 1\n-};\n-\n-typedef uint8_t BrigMemoryModifier8_t;\n-\n-enum BrigMemoryModifierMask\n-{\n-  BRIG_MEMORY_CONST = 1\n-};\n-\n-typedef uint8_t BrigMemoryOrder8_t;\n-\n-enum BrigMemoryOrder\n-{\n-  BRIG_MEMORY_ORDER_NONE = 0,\n-  BRIG_MEMORY_ORDER_RELAXED = 1,\n-  BRIG_MEMORY_ORDER_SC_ACQUIRE = 2,\n-  BRIG_MEMORY_ORDER_SC_RELEASE = 3,\n-  BRIG_MEMORY_ORDER_SC_ACQUIRE_RELEASE = 4\n-};\n-\n-typedef uint8_t BrigMemoryScope8_t;\n-\n-enum BrigMemoryScope\n-{\n-  BRIG_MEMORY_SCOPE_NONE = 0,\n-  BRIG_MEMORY_SCOPE_WORKITEM = 1,\n-  BRIG_MEMORY_SCOPE_WAVEFRONT = 2,\n-  BRIG_MEMORY_SCOPE_WORKGROUP = 3,\n-  BRIG_MEMORY_SCOPE_AGENT = 4,\n-  BRIG_MEMORY_SCOPE_SYSTEM = 5\n-};\n-\n-struct BrigModuleHeader\n-{\n-  char identification[8];\n-  BrigVersion32_t brigMajor;\n-  BrigVersion32_t brigMinor;\n-  uint64_t byteCount;\n-  uint8_t hash[64];\n-  uint32_t reserved;\n-  uint32_t sectionCount;\n-  uint64_t sectionIndex;\n-};\n-\n-typedef uint16_t BrigOpcode16_t;\n-\n-enum BrigOpcode\n-{\n-  BRIG_OPCODE_NOP = 0,\n-  BRIG_OPCODE_ABS = 1,\n-  BRIG_OPCODE_ADD = 2,\n-  BRIG_OPCODE_BORROW = 3,\n-  BRIG_OPCODE_CARRY = 4,\n-  BRIG_OPCODE_CEIL = 5,\n-  BRIG_OPCODE_COPYSIGN = 6,\n-  BRIG_OPCODE_DIV = 7,\n-  BRIG_OPCODE_FLOOR = 8,\n-  BRIG_OPCODE_FMA = 9,\n-  BRIG_OPCODE_FRACT = 10,\n-  BRIG_OPCODE_MAD = 11,\n-  BRIG_OPCODE_MAX = 12,\n-  BRIG_OPCODE_MIN = 13,\n-  BRIG_OPCODE_MUL = 14,\n-  BRIG_OPCODE_MULHI = 15,\n-  BRIG_OPCODE_NEG = 16,\n-  BRIG_OPCODE_REM = 17,\n-  BRIG_OPCODE_RINT = 18,\n-  BRIG_OPCODE_SQRT = 19,\n-  BRIG_OPCODE_SUB = 20,\n-  BRIG_OPCODE_TRUNC = 21,\n-  BRIG_OPCODE_MAD24 = 22,\n-  BRIG_OPCODE_MAD24HI = 23,\n-  BRIG_OPCODE_MUL24 = 24,\n-  BRIG_OPCODE_MUL24HI = 25,\n-  BRIG_OPCODE_SHL = 26,\n-  BRIG_OPCODE_SHR = 27,\n-  BRIG_OPCODE_AND = 28,\n-  BRIG_OPCODE_NOT = 29,\n-  BRIG_OPCODE_OR = 30,\n-  BRIG_OPCODE_POPCOUNT = 31,\n-  BRIG_OPCODE_XOR = 32,\n-  BRIG_OPCODE_BITEXTRACT = 33,\n-  BRIG_OPCODE_BITINSERT = 34,\n-  BRIG_OPCODE_BITMASK = 35,\n-  BRIG_OPCODE_BITREV = 36,\n-  BRIG_OPCODE_BITSELECT = 37,\n-  BRIG_OPCODE_FIRSTBIT = 38,\n-  BRIG_OPCODE_LASTBIT = 39,\n-  BRIG_OPCODE_COMBINE = 40,\n-  BRIG_OPCODE_EXPAND = 41,\n-  BRIG_OPCODE_LDA = 42,\n-  BRIG_OPCODE_MOV = 43,\n-  BRIG_OPCODE_SHUFFLE = 44,\n-  BRIG_OPCODE_UNPACKHI = 45,\n-  BRIG_OPCODE_UNPACKLO = 46,\n-  BRIG_OPCODE_PACK = 47,\n-  BRIG_OPCODE_UNPACK = 48,\n-  BRIG_OPCODE_CMOV = 49,\n-  BRIG_OPCODE_CLASS = 50,\n-  BRIG_OPCODE_NCOS = 51,\n-  BRIG_OPCODE_NEXP2 = 52,\n-  BRIG_OPCODE_NFMA = 53,\n-  BRIG_OPCODE_NLOG2 = 54,\n-  BRIG_OPCODE_NRCP = 55,\n-  BRIG_OPCODE_NRSQRT = 56,\n-  BRIG_OPCODE_NSIN = 57,\n-  BRIG_OPCODE_NSQRT = 58,\n-  BRIG_OPCODE_BITALIGN = 59,\n-  BRIG_OPCODE_BYTEALIGN = 60,\n-  BRIG_OPCODE_PACKCVT = 61,\n-  BRIG_OPCODE_UNPACKCVT = 62,\n-  BRIG_OPCODE_LERP = 63,\n-  BRIG_OPCODE_SAD = 64,\n-  BRIG_OPCODE_SADHI = 65,\n-  BRIG_OPCODE_SEGMENTP = 66,\n-  BRIG_OPCODE_FTOS = 67,\n-  BRIG_OPCODE_STOF = 68,\n-  BRIG_OPCODE_CMP = 69,\n-  BRIG_OPCODE_CVT = 70,\n-  BRIG_OPCODE_LD = 71,\n-  BRIG_OPCODE_ST = 72,\n-  BRIG_OPCODE_ATOMIC = 73,\n-  BRIG_OPCODE_ATOMICNORET = 74,\n-  BRIG_OPCODE_SIGNAL = 75,\n-  BRIG_OPCODE_SIGNALNORET = 76,\n-  BRIG_OPCODE_MEMFENCE = 77,\n-  BRIG_OPCODE_RDIMAGE = 78,\n-  BRIG_OPCODE_LDIMAGE = 79,\n-  BRIG_OPCODE_STIMAGE = 80,\n-  BRIG_OPCODE_IMAGEFENCE = 81,\n-  BRIG_OPCODE_QUERYIMAGE = 82,\n-  BRIG_OPCODE_QUERYSAMPLER = 83,\n-  BRIG_OPCODE_CBR = 84,\n-  BRIG_OPCODE_BR = 85,\n-  BRIG_OPCODE_SBR = 86,\n-  BRIG_OPCODE_BARRIER = 87,\n-  BRIG_OPCODE_WAVEBARRIER = 88,\n-  BRIG_OPCODE_ARRIVEFBAR = 89,\n-  BRIG_OPCODE_INITFBAR = 90,\n-  BRIG_OPCODE_JOINFBAR = 91,\n-  BRIG_OPCODE_LEAVEFBAR = 92,\n-  BRIG_OPCODE_RELEASEFBAR = 93,\n-  BRIG_OPCODE_WAITFBAR = 94,\n-  BRIG_OPCODE_LDF = 95,\n-  BRIG_OPCODE_ACTIVELANECOUNT = 96,\n-  BRIG_OPCODE_ACTIVELANEID = 97,\n-  BRIG_OPCODE_ACTIVELANEMASK = 98,\n-  BRIG_OPCODE_ACTIVELANEPERMUTE = 99,\n-  BRIG_OPCODE_CALL = 100,\n-  BRIG_OPCODE_SCALL = 101,\n-  BRIG_OPCODE_ICALL = 102,\n-  BRIG_OPCODE_RET = 103,\n-  BRIG_OPCODE_ALLOCA = 104,\n-  BRIG_OPCODE_CURRENTWORKGROUPSIZE = 105,\n-  BRIG_OPCODE_CURRENTWORKITEMFLATID = 106,\n-  BRIG_OPCODE_DIM = 107,\n-  BRIG_OPCODE_GRIDGROUPS = 108,\n-  BRIG_OPCODE_GRIDSIZE = 109,\n-  BRIG_OPCODE_PACKETCOMPLETIONSIG = 110,\n-  BRIG_OPCODE_PACKETID = 111,\n-  BRIG_OPCODE_WORKGROUPID = 112,\n-  BRIG_OPCODE_WORKGROUPSIZE = 113,\n-  BRIG_OPCODE_WORKITEMABSID = 114,\n-  BRIG_OPCODE_WORKITEMFLATABSID = 115,\n-  BRIG_OPCODE_WORKITEMFLATID = 116,\n-  BRIG_OPCODE_WORKITEMID = 117,\n-  BRIG_OPCODE_CLEARDETECTEXCEPT = 118,\n-  BRIG_OPCODE_GETDETECTEXCEPT = 119,\n-  BRIG_OPCODE_SETDETECTEXCEPT = 120,\n-  BRIG_OPCODE_ADDQUEUEWRITEINDEX = 121,\n-  BRIG_OPCODE_CASQUEUEWRITEINDEX = 122,\n-  BRIG_OPCODE_LDQUEUEREADINDEX = 123,\n-  BRIG_OPCODE_LDQUEUEWRITEINDEX = 124,\n-  BRIG_OPCODE_STQUEUEREADINDEX = 125,\n-  BRIG_OPCODE_STQUEUEWRITEINDEX = 126,\n-  BRIG_OPCODE_CLOCK = 127,\n-  BRIG_OPCODE_CUID = 128,\n-  BRIG_OPCODE_DEBUGTRAP = 129,\n-  BRIG_OPCODE_GROUPBASEPTR = 130,\n-  BRIG_OPCODE_KERNARGBASEPTR = 131,\n-  BRIG_OPCODE_LANEID = 132,\n-  BRIG_OPCODE_MAXCUID = 133,\n-  BRIG_OPCODE_MAXWAVEID = 134,\n-  BRIG_OPCODE_NULLPTR = 135,\n-  BRIG_OPCODE_WAVEID = 136,\n-  BRIG_OPCODE_FIRST_USER_DEFINED = 32768\n-};\n-\n-typedef uint8_t BrigPack8_t;\n-\n-enum BrigPack\n-{\n-  BRIG_PACK_NONE = 0,\n-  BRIG_PACK_PP = 1,\n-  BRIG_PACK_PS = 2,\n-  BRIG_PACK_SP = 3,\n-  BRIG_PACK_SS = 4,\n-  BRIG_PACK_S = 5,\n-  BRIG_PACK_P = 6,\n-  BRIG_PACK_PPSAT = 7,\n-  BRIG_PACK_PSSAT = 8,\n-  BRIG_PACK_SPSAT = 9,\n-  BRIG_PACK_SSSAT = 10,\n-  BRIG_PACK_SSAT = 11,\n-  BRIG_PACK_PSAT = 12\n-};\n-\n-typedef uint8_t BrigProfile8_t;\n-\n-enum BrigProfile\n-{\n-  BRIG_PROFILE_BASE = 0,\n-  BRIG_PROFILE_FULL = 1\n-};\n-\n-typedef uint16_t BrigRegisterKind16_t;\n-\n-enum BrigRegisterKind\n-{\n-  BRIG_REGISTER_KIND_CONTROL = 0,\n-  BRIG_REGISTER_KIND_SINGLE = 1,\n-  BRIG_REGISTER_KIND_DOUBLE = 2,\n-  BRIG_REGISTER_KIND_QUAD = 3\n-};\n-\n-typedef uint8_t BrigRound8_t;\n-\n-enum BrigRound\n-{\n-  BRIG_ROUND_NONE = 0,\n-  BRIG_ROUND_FLOAT_DEFAULT = 1,\n-  BRIG_ROUND_FLOAT_NEAR_EVEN = 2,\n-  BRIG_ROUND_FLOAT_ZERO = 3,\n-  BRIG_ROUND_FLOAT_PLUS_INFINITY = 4,\n-  BRIG_ROUND_FLOAT_MINUS_INFINITY = 5,\n-  BRIG_ROUND_INTEGER_NEAR_EVEN = 6,\n-  BRIG_ROUND_INTEGER_ZERO = 7,\n-  BRIG_ROUND_INTEGER_PLUS_INFINITY = 8,\n-  BRIG_ROUND_INTEGER_MINUS_INFINITY = 9,\n-  BRIG_ROUND_INTEGER_NEAR_EVEN_SAT = 10,\n-  BRIG_ROUND_INTEGER_ZERO_SAT = 11,\n-  BRIG_ROUND_INTEGER_PLUS_INFINITY_SAT = 12,\n-  BRIG_ROUND_INTEGER_MINUS_INFINITY_SAT = 13,\n-  BRIG_ROUND_INTEGER_SIGNALING_NEAR_EVEN = 14,\n-  BRIG_ROUND_INTEGER_SIGNALING_ZERO = 15,\n-  BRIG_ROUND_INTEGER_SIGNALING_PLUS_INFINITY = 16,\n-  BRIG_ROUND_INTEGER_SIGNALING_MINUS_INFINITY = 17,\n-  BRIG_ROUND_INTEGER_SIGNALING_NEAR_EVEN_SAT = 18,\n-  BRIG_ROUND_INTEGER_SIGNALING_ZERO_SAT = 19,\n-  BRIG_ROUND_INTEGER_SIGNALING_PLUS_INFINITY_SAT = 20,\n-  BRIG_ROUND_INTEGER_SIGNALING_MINUS_INFINITY_SAT = 21\n-};\n-\n-typedef uint8_t BrigSamplerAddressing8_t;\n-\n-enum BrigSamplerAddressing\n-{\n-  BRIG_ADDRESSING_UNDEFINED = 0,\n-  BRIG_ADDRESSING_CLAMP_TO_EDGE = 1,\n-  BRIG_ADDRESSING_CLAMP_TO_BORDER = 2,\n-  BRIG_ADDRESSING_REPEAT = 3,\n-  BRIG_ADDRESSING_MIRRORED_REPEAT = 4,\n-  BRIG_ADDRESSING_FIRST_USER_DEFINED = 128\n-};\n-\n-typedef uint8_t BrigSamplerCoordNormalization8_t;\n-\n-enum BrigSamplerCoordNormalization\n-{\n-  BRIG_COORD_UNNORMALIZED = 0,\n-  BRIG_COORD_NORMALIZED = 1\n-};\n-\n-typedef uint8_t BrigSamplerFilter8_t;\n-\n-enum BrigSamplerFilter\n-{\n-  BRIG_FILTER_NEAREST = 0,\n-  BRIG_FILTER_LINEAR = 1,\n-  BRIG_FILTER_FIRST_USER_DEFINED = 128\n-};\n-\n-typedef uint8_t BrigSamplerQuery8_t;\n-\n-enum BrigSamplerQuery\n-{\n-  BRIG_SAMPLER_QUERY_ADDRESSING = 0,\n-  BRIG_SAMPLER_QUERY_COORD = 1,\n-  BRIG_SAMPLER_QUERY_FILTER = 2\n-};\n-\n-typedef uint32_t BrigSectionIndex32_t;\n-\n-enum BrigSectionIndex\n-{\n-  BRIG_SECTION_INDEX_DATA = 0,\n-  BRIG_SECTION_INDEX_CODE = 1,\n-  BRIG_SECTION_INDEX_OPERAND = 2,\n-  BRIG_SECTION_INDEX_BEGIN_IMPLEMENTATION_DEFINED = 3\n-};\n-\n-struct BrigSectionHeader\n-{\n-  uint64_t byteCount;\n-  uint32_t headerByteCount;\n-  uint32_t nameLength;\n-  uint8_t name[1];\n-};\n-\n-typedef uint8_t BrigSegCvtModifier8_t;\n-\n-enum BrigSegCvtModifierMask\n-{\n-  BRIG_SEG_CVT_NONULL = 1\n-};\n-\n-typedef uint8_t BrigSegment8_t;\n-\n-enum BrigSegment\n-{\n-  BRIG_SEGMENT_NONE = 0,\n-  BRIG_SEGMENT_FLAT = 1,\n-  BRIG_SEGMENT_GLOBAL = 2,\n-  BRIG_SEGMENT_READONLY = 3,\n-  BRIG_SEGMENT_KERNARG = 4,\n-  BRIG_SEGMENT_GROUP = 5,\n-  BRIG_SEGMENT_PRIVATE = 6,\n-  BRIG_SEGMENT_SPILL = 7,\n-  BRIG_SEGMENT_ARG = 8,\n-  BRIG_SEGMENT_FIRST_USER_DEFINED = 128\n-};\n-\n-enum\n-{\n-  BRIG_TYPE_BASE_SIZE = 5,\n-  BRIG_TYPE_PACK_SIZE = 2,\n-  BRIG_TYPE_ARRAY_SIZE = 1,\n-\n-  BRIG_TYPE_BASE_SHIFT = 0,\n-  BRIG_TYPE_PACK_SHIFT = BRIG_TYPE_BASE_SHIFT + BRIG_TYPE_BASE_SIZE,\n-  BRIG_TYPE_ARRAY_SHIFT = BRIG_TYPE_PACK_SHIFT + BRIG_TYPE_PACK_SIZE,\n-\n-  BRIG_TYPE_BASE_MASK = ((1 << BRIG_TYPE_BASE_SIZE) - 1)\n-\t\t\t<< BRIG_TYPE_BASE_SHIFT,\n-  BRIG_TYPE_PACK_MASK = ((1 << BRIG_TYPE_PACK_SIZE) - 1)\n-\t\t\t<< BRIG_TYPE_PACK_SHIFT,\n-  BRIG_TYPE_ARRAY_MASK = ((1 << BRIG_TYPE_ARRAY_SIZE) - 1)\n-\t\t\t << BRIG_TYPE_ARRAY_SHIFT,\n-\n-  BRIG_TYPE_PACK_NONE = 0 << BRIG_TYPE_PACK_SHIFT,\n-  BRIG_TYPE_PACK_32 = 1 << BRIG_TYPE_PACK_SHIFT,\n-  BRIG_TYPE_PACK_64 = 2 << BRIG_TYPE_PACK_SHIFT,\n-  BRIG_TYPE_PACK_128 = 3 << BRIG_TYPE_PACK_SHIFT,\n-\n-  BRIG_TYPE_ARRAY = 1 << BRIG_TYPE_ARRAY_SHIFT\n-};\n-\n-typedef uint16_t BrigType16_t;\n-\n-enum BrigType\n-{\n-  BRIG_TYPE_NONE = 0,\n-\n-  BRIG_TYPE_U8 = 1,\n-  BRIG_TYPE_U16 = 2,\n-  BRIG_TYPE_U32 = 3,\n-  BRIG_TYPE_U64 = 4,\n-\n-  BRIG_TYPE_S8 = 5,\n-  BRIG_TYPE_S16 = 6,\n-  BRIG_TYPE_S32 = 7,\n-  BRIG_TYPE_S64 = 8,\n-\n-  BRIG_TYPE_F16 = 9,\n-  BRIG_TYPE_F32 = 10,\n-  BRIG_TYPE_F64 = 11,\n-\n-  BRIG_TYPE_B1 = 12,\n-  BRIG_TYPE_B8 = 13,\n-  BRIG_TYPE_B16 = 14,\n-  BRIG_TYPE_B32 = 15,\n-  BRIG_TYPE_B64 = 16,\n-  BRIG_TYPE_B128 = 17,\n-\n-  BRIG_TYPE_SAMP = 18,\n-  BRIG_TYPE_ROIMG = 19,\n-  BRIG_TYPE_WOIMG = 20,\n-  BRIG_TYPE_RWIMG = 21,\n-\n-  BRIG_TYPE_SIG32 = 22,\n-  BRIG_TYPE_SIG64 = 23,\n-\n-  BRIG_TYPE_U8X4 = BRIG_TYPE_U8 | BRIG_TYPE_PACK_32,\n-  BRIG_TYPE_U8X8 = BRIG_TYPE_U8 | BRIG_TYPE_PACK_64,\n-  BRIG_TYPE_U8X16 = BRIG_TYPE_U8 | BRIG_TYPE_PACK_128,\n-\n-  BRIG_TYPE_U16X2 = BRIG_TYPE_U16 | BRIG_TYPE_PACK_32,\n-  BRIG_TYPE_U16X4 = BRIG_TYPE_U16 | BRIG_TYPE_PACK_64,\n-  BRIG_TYPE_U16X8 = BRIG_TYPE_U16 | BRIG_TYPE_PACK_128,\n-\n-  BRIG_TYPE_U32X2 = BRIG_TYPE_U32 | BRIG_TYPE_PACK_64,\n-  BRIG_TYPE_U32X4 = BRIG_TYPE_U32 | BRIG_TYPE_PACK_128,\n-\n-  BRIG_TYPE_U64X2 = BRIG_TYPE_U64 | BRIG_TYPE_PACK_128,\n-\n-  BRIG_TYPE_S8X4 = BRIG_TYPE_S8 | BRIG_TYPE_PACK_32,\n-  BRIG_TYPE_S8X8 = BRIG_TYPE_S8 | BRIG_TYPE_PACK_64,\n-  BRIG_TYPE_S8X16 = BRIG_TYPE_S8 | BRIG_TYPE_PACK_128,\n-\n-  BRIG_TYPE_S16X2 = BRIG_TYPE_S16 | BRIG_TYPE_PACK_32,\n-  BRIG_TYPE_S16X4 = BRIG_TYPE_S16 | BRIG_TYPE_PACK_64,\n-  BRIG_TYPE_S16X8 = BRIG_TYPE_S16 | BRIG_TYPE_PACK_128,\n-\n-  BRIG_TYPE_S32X2 = BRIG_TYPE_S32 | BRIG_TYPE_PACK_64,\n-  BRIG_TYPE_S32X4 = BRIG_TYPE_S32 | BRIG_TYPE_PACK_128,\n-\n-  BRIG_TYPE_S64X2 = BRIG_TYPE_S64 | BRIG_TYPE_PACK_128,\n-\n-  BRIG_TYPE_F16X2 = BRIG_TYPE_F16 | BRIG_TYPE_PACK_32,\n-  BRIG_TYPE_F16X4 = BRIG_TYPE_F16 | BRIG_TYPE_PACK_64,\n-  BRIG_TYPE_F16X8 = BRIG_TYPE_F16 | BRIG_TYPE_PACK_128,\n-\n-  BRIG_TYPE_F32X2 = BRIG_TYPE_F32 | BRIG_TYPE_PACK_64,\n-  BRIG_TYPE_F32X4 = BRIG_TYPE_F32 | BRIG_TYPE_PACK_128,\n-\n-  BRIG_TYPE_F64X2 = BRIG_TYPE_F64 | BRIG_TYPE_PACK_128,\n-\n-  BRIG_TYPE_U8_ARRAY = BRIG_TYPE_U8 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_U16_ARRAY = BRIG_TYPE_U16 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_U32_ARRAY = BRIG_TYPE_U32 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_U64_ARRAY = BRIG_TYPE_U64 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_S8_ARRAY = BRIG_TYPE_S8 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_S16_ARRAY = BRIG_TYPE_S16 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_S32_ARRAY = BRIG_TYPE_S32 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_S64_ARRAY = BRIG_TYPE_S64 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_F16_ARRAY = BRIG_TYPE_F16 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_F32_ARRAY = BRIG_TYPE_F32 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_F64_ARRAY = BRIG_TYPE_F64 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_B8_ARRAY = BRIG_TYPE_B8 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_B16_ARRAY = BRIG_TYPE_B16 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_B32_ARRAY = BRIG_TYPE_B32 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_B64_ARRAY = BRIG_TYPE_B64 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_B128_ARRAY = BRIG_TYPE_B128 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_SAMP_ARRAY = BRIG_TYPE_SAMP | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_ROIMG_ARRAY = BRIG_TYPE_ROIMG | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_WOIMG_ARRAY = BRIG_TYPE_WOIMG | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_RWIMG_ARRAY = BRIG_TYPE_RWIMG | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_SIG32_ARRAY = BRIG_TYPE_SIG32 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_SIG64_ARRAY = BRIG_TYPE_SIG64 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_U8X4_ARRAY = BRIG_TYPE_U8X4 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_U8X8_ARRAY = BRIG_TYPE_U8X8 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_U8X16_ARRAY = BRIG_TYPE_U8X16 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_U16X2_ARRAY = BRIG_TYPE_U16X2 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_U16X4_ARRAY = BRIG_TYPE_U16X4 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_U16X8_ARRAY = BRIG_TYPE_U16X8 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_U32X2_ARRAY = BRIG_TYPE_U32X2 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_U32X4_ARRAY = BRIG_TYPE_U32X4 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_U64X2_ARRAY = BRIG_TYPE_U64X2 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_S8X4_ARRAY = BRIG_TYPE_S8X4 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_S8X8_ARRAY = BRIG_TYPE_S8X8 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_S8X16_ARRAY = BRIG_TYPE_S8X16 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_S16X2_ARRAY = BRIG_TYPE_S16X2 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_S16X4_ARRAY = BRIG_TYPE_S16X4 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_S16X8_ARRAY = BRIG_TYPE_S16X8 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_S32X2_ARRAY = BRIG_TYPE_S32X2 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_S32X4_ARRAY = BRIG_TYPE_S32X4 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_S64X2_ARRAY = BRIG_TYPE_S64X2 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_F16X2_ARRAY = BRIG_TYPE_F16X2 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_F16X4_ARRAY = BRIG_TYPE_F16X4 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_F16X8_ARRAY = BRIG_TYPE_F16X8 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_F32X2_ARRAY = BRIG_TYPE_F32X2 | BRIG_TYPE_ARRAY,\n-  BRIG_TYPE_F32X4_ARRAY = BRIG_TYPE_F32X4 | BRIG_TYPE_ARRAY,\n-\n-  BRIG_TYPE_F64X2_ARRAY = BRIG_TYPE_F64X2 | BRIG_TYPE_ARRAY\n-};\n-\n-struct BrigUInt64\n-{\n-  uint32_t lo;\n-  uint32_t hi;\n-};\n-\n-typedef uint8_t BrigVariableModifier8_t;\n-\n-enum BrigVariableModifierMask\n-{\n-  BRIG_VARIABLE_DEFINITION = 1,\n-  BRIG_VARIABLE_CONST = 2\n-};\n-\n-enum BrigVersion\n-{\n-  BRIG_VERSION_HSAIL_MAJOR = 1,\n-  BRIG_VERSION_HSAIL_MINOR = 0,\n-  BRIG_VERSION_BRIG_MAJOR = 1,\n-  BRIG_VERSION_BRIG_MINOR = 0\n-};\n-\n-typedef uint8_t BrigWidth8_t;\n-\n-enum BrigWidth\n-{\n-  BRIG_WIDTH_NONE = 0,\n-  BRIG_WIDTH_1 = 1,\n-  BRIG_WIDTH_2 = 2,\n-  BRIG_WIDTH_4 = 3,\n-  BRIG_WIDTH_8 = 4,\n-  BRIG_WIDTH_16 = 5,\n-  BRIG_WIDTH_32 = 6,\n-  BRIG_WIDTH_64 = 7,\n-  BRIG_WIDTH_128 = 8,\n-  BRIG_WIDTH_256 = 9,\n-  BRIG_WIDTH_512 = 10,\n-  BRIG_WIDTH_1024 = 11,\n-  BRIG_WIDTH_2048 = 12,\n-  BRIG_WIDTH_4096 = 13,\n-  BRIG_WIDTH_8192 = 14,\n-  BRIG_WIDTH_16384 = 15,\n-  BRIG_WIDTH_32768 = 16,\n-  BRIG_WIDTH_65536 = 17,\n-  BRIG_WIDTH_131072 = 18,\n-  BRIG_WIDTH_262144 = 19,\n-  BRIG_WIDTH_524288 = 20,\n-  BRIG_WIDTH_1048576 = 21,\n-  BRIG_WIDTH_2097152 = 22,\n-  BRIG_WIDTH_4194304 = 23,\n-  BRIG_WIDTH_8388608 = 24,\n-  BRIG_WIDTH_16777216 = 25,\n-  BRIG_WIDTH_33554432 = 26,\n-  BRIG_WIDTH_67108864 = 27,\n-  BRIG_WIDTH_134217728 = 28,\n-  BRIG_WIDTH_268435456 = 29,\n-  BRIG_WIDTH_536870912 = 30,\n-  BRIG_WIDTH_1073741824 = 31,\n-  BRIG_WIDTH_2147483648 = 32,\n-  BRIG_WIDTH_WAVESIZE = 33,\n-  BRIG_WIDTH_ALL = 34\n-};\n-\n-struct BrigData\n-{\n-  uint32_t byteCount;\n-  uint8_t bytes[1];\n-};\n-\n-struct BrigDirectiveArgBlock\n-{\n-  BrigBase base;\n-};\n-\n-struct BrigDirectiveComment\n-{\n-  BrigBase base;\n-  BrigDataOffsetString32_t name;\n-};\n-\n-struct BrigDirectiveControl\n-{\n-  BrigBase base;\n-  BrigControlDirective16_t control;\n-  uint16_t reserved;\n-  BrigDataOffsetOperandList32_t operands;\n-};\n-\n-struct BrigDirectiveExecutable\n-{\n-  BrigBase base;\n-  BrigDataOffsetString32_t name;\n-  uint16_t outArgCount;\n-  uint16_t inArgCount;\n-  BrigCodeOffset32_t firstInArg;\n-  BrigCodeOffset32_t firstCodeBlockEntry;\n-  BrigCodeOffset32_t nextModuleEntry;\n-  BrigExecutableModifier8_t modifier;\n-  BrigLinkage8_t linkage;\n-  uint16_t reserved;\n-};\n-\n-struct BrigDirectiveExtension\n-{\n-  BrigBase base;\n-  BrigDataOffsetString32_t name;\n-};\n-\n-struct BrigDirectiveFbarrier\n-{\n-  BrigBase base;\n-  BrigDataOffsetString32_t name;\n-  BrigVariableModifier8_t modifier;\n-  BrigLinkage8_t linkage;\n-  uint16_t reserved;\n-};\n-\n-struct BrigDirectiveLabel\n-{\n-  BrigBase base;\n-  BrigDataOffsetString32_t name;\n-};\n-\n-struct BrigDirectiveLoc\n-{\n-  BrigBase base;\n-  BrigDataOffsetString32_t filename;\n-  uint32_t line;\n-  uint32_t column;\n-};\n-\n-struct BrigDirectiveModule\n-{\n-  BrigBase base;\n-  BrigDataOffsetString32_t name;\n-  BrigVersion32_t hsailMajor;\n-  BrigVersion32_t hsailMinor;\n-  BrigProfile8_t profile;\n-  BrigMachineModel8_t machineModel;\n-  BrigRound8_t defaultFloatRound;\n-  uint8_t reserved;\n-};\n-\n-struct BrigDirectiveNone\n-{\n-  BrigBase base;\n-};\n-\n-struct BrigDirectivePragma\n-{\n-  BrigBase base;\n-  BrigDataOffsetOperandList32_t operands;\n-};\n-\n-struct BrigDirectiveVariable\n-{\n-  BrigBase base;\n-  BrigDataOffsetString32_t name;\n-  BrigOperandOffset32_t init;\n-  BrigType16_t type;\n-  BrigSegment8_t segment;\n-  BrigAlignment8_t align;\n-  BrigUInt64 dim;\n-  BrigVariableModifier8_t modifier;\n-  BrigLinkage8_t linkage;\n-  BrigAllocation8_t allocation;\n-  uint8_t reserved;\n-};\n-\n-struct BrigInstBase\n-{\n-  BrigBase base;\n-  BrigOpcode16_t opcode;\n-  BrigType16_t type;\n-  BrigDataOffsetOperandList32_t operands;\n-};\n-\n-struct BrigInstAddr\n-{\n-  BrigInstBase base;\n-  BrigSegment8_t segment;\n-  uint8_t reserved[3];\n-};\n-\n-struct BrigInstAtomic\n-{\n-  BrigInstBase base;\n-  BrigSegment8_t segment;\n-  BrigMemoryOrder8_t memoryOrder;\n-  BrigMemoryScope8_t memoryScope;\n-  BrigAtomicOperation8_t atomicOperation;\n-  uint8_t equivClass;\n-  uint8_t reserved[3];\n-};\n-\n-struct BrigInstBasic\n-{\n-  BrigInstBase base;\n-};\n-\n-struct BrigInstBr\n-{\n-  BrigInstBase base;\n-  BrigWidth8_t width;\n-  uint8_t reserved[3];\n-};\n-\n-struct BrigInstCmp\n-{\n-  BrigInstBase base;\n-  BrigType16_t sourceType;\n-  BrigAluModifier8_t modifier;\n-  BrigCompareOperation8_t compare;\n-  BrigPack8_t pack;\n-  uint8_t reserved[3];\n-};\n-\n-struct BrigInstCvt\n-{\n-  BrigInstBase base;\n-  BrigType16_t sourceType;\n-  BrigAluModifier8_t modifier;\n-  BrigRound8_t round;\n-};\n-\n-struct BrigInstImage\n-{\n-  BrigInstBase base;\n-  BrigType16_t imageType;\n-  BrigType16_t coordType;\n-  BrigImageGeometry8_t geometry;\n-  uint8_t equivClass;\n-  uint16_t reserved;\n-};\n-\n-struct BrigInstLane\n-{\n-  BrigInstBase base;\n-  BrigType16_t sourceType;\n-  BrigWidth8_t width;\n-  uint8_t reserved;\n-};\n-\n-struct BrigInstMem\n-{\n-  BrigInstBase base;\n-  BrigSegment8_t segment;\n-  BrigAlignment8_t align;\n-  uint8_t equivClass;\n-  BrigWidth8_t width;\n-  BrigMemoryModifier8_t modifier;\n-  uint8_t reserved[3];\n-};\n-\n-struct BrigInstMemFence\n-{\n-  BrigInstBase base;\n-  BrigMemoryOrder8_t memoryOrder;\n-  BrigMemoryScope8_t globalSegmentMemoryScope;\n-  BrigMemoryScope8_t groupSegmentMemoryScope;\n-  BrigMemoryScope8_t imageSegmentMemoryScope;\n-};\n-\n-struct BrigInstMod\n-{\n-  BrigInstBase base;\n-  BrigAluModifier8_t modifier;\n-  BrigRound8_t round;\n-  BrigPack8_t pack;\n-  uint8_t reserved;\n-};\n-\n-struct BrigInstQueryImage\n-{\n-  BrigInstBase base;\n-  BrigType16_t imageType;\n-  BrigImageGeometry8_t geometry;\n-  BrigImageQuery8_t query;\n-};\n-\n-struct BrigInstQuerySampler\n-{\n-  BrigInstBase base;\n-  BrigSamplerQuery8_t query;\n-  uint8_t reserved[3];\n-};\n-\n-struct BrigInstQueue\n-{\n-  BrigInstBase base;\n-  BrigSegment8_t segment;\n-  BrigMemoryOrder8_t memoryOrder;\n-  uint16_t reserved;\n-};\n-\n-struct BrigInstSeg\n-{\n-  BrigInstBase base;\n-  BrigSegment8_t segment;\n-  uint8_t reserved[3];\n-};\n-\n-struct BrigInstSegCvt\n-{\n-  BrigInstBase base;\n-  BrigType16_t sourceType;\n-  BrigSegment8_t segment;\n-  BrigSegCvtModifier8_t modifier;\n-};\n-\n-struct BrigInstSignal\n-{\n-  BrigInstBase base;\n-  BrigType16_t signalType;\n-  BrigMemoryOrder8_t memoryOrder;\n-  BrigAtomicOperation8_t signalOperation;\n-};\n-\n-struct BrigInstSourceType\n-{\n-  BrigInstBase base;\n-  BrigType16_t sourceType;\n-  uint16_t reserved;\n-};\n-\n-struct BrigOperandAddress\n-{\n-  BrigBase base;\n-  BrigCodeOffset32_t symbol;\n-  BrigOperandOffset32_t reg;\n-  BrigUInt64 offset;\n-};\n-\n-struct BrigOperandAlign\n-{\n-  BrigBase base;\n-  BrigAlignment8_t align;\n-  uint8_t reserved[3];\n-};\n-\n-struct BrigOperandCodeList\n-{\n-  BrigBase base;\n-  BrigDataOffsetCodeList32_t elements;\n-};\n-\n-struct BrigOperandCodeRef\n-{\n-  BrigBase base;\n-  BrigCodeOffset32_t ref;\n-};\n-\n-struct BrigOperandConstantBytes\n-{\n-  BrigBase base;\n-  BrigType16_t type;\n-  uint16_t reserved;\n-  BrigDataOffsetString32_t bytes;\n-};\n-\n-struct BrigOperandConstantImage\n-{\n-  BrigBase base;\n-  BrigType16_t type;\n-  BrigImageGeometry8_t geometry;\n-  BrigImageChannelOrder8_t channelOrder;\n-  BrigImageChannelType8_t channelType;\n-  uint8_t reserved[3];\n-  BrigUInt64 width;\n-  BrigUInt64 height;\n-  BrigUInt64 depth;\n-  BrigUInt64 array;\n-};\n-\n-struct BrigOperandConstantOperandList\n-{\n-  BrigBase base;\n-  BrigType16_t type;\n-  uint16_t reserved;\n-  BrigDataOffsetOperandList32_t elements;\n-};\n-\n-struct BrigOperandConstantSampler\n-{\n-  BrigBase base;\n-  BrigType16_t type;\n-  BrigSamplerCoordNormalization8_t coord;\n-  BrigSamplerFilter8_t filter;\n-  BrigSamplerAddressing8_t addressing;\n-  uint8_t reserved[3];\n-};\n-\n-struct BrigOperandOperandList\n-{\n-  BrigBase base;\n-  BrigDataOffsetOperandList32_t elements;\n-};\n-\n-struct BrigOperandRegister\n-{\n-  BrigBase base;\n-  BrigRegisterKind16_t regKind;\n-  uint16_t regNum;\n-};\n-\n-struct BrigOperandString\n-{\n-  BrigBase base;\n-  BrigDataOffsetString32_t string;\n-};\n-\n-struct BrigOperandWavesize\n-{\n-  BrigBase base;\n-};\n-\n-#endif /* HSA_BRIG_FORMAT_H */"}, {"sha": "2103a31774af1bdc4dda9d4229b51f1349468fac", "filename": "gcc/brig/brigfrontend/phsa.h", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fphsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigfrontend%2Fphsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fphsa.h?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,79 +0,0 @@\n-/* phsa.h -- interfacing between the gcc BRIG FE and the phsa runtime\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef PHSA_H\n-#define PHSA_H\n-\n-#include <stdint.h>\n-\n-/* This struct is used to pass information from the BRIG FE to the\n-   runtime of the finalizer kernel, its control directives etc.\n-   The data is passed raw in a special ELF section named\n-   phsa.kerneldesc.kernel_function_name.  */\n-\n-typedef struct __attribute__((__packed__))\n-{\n-  /* Set to 1 in case the function is a kernel.  */\n-  uint8_t is_kernel;\n-  /* The size of the group segment used by the kernel.  */\n-  uint32_t group_segment_size;\n-  /* Size of the private segment used by a single work-item.  */\n-  uint32_t private_segment_size;\n-  /* Total size of the kernel arguments.  */\n-  uint32_t kernarg_segment_size;\n-  /* Maximum alignment of a kernel argument variable.  */\n-  uint16_t kernarg_max_align;\n-  /* Maximum size (in bytes) of dynamic group memory.  */\n-  uint32_t max_dynamic_group_size;\n-  /* Max number of work-items used to launch the kernel.  */\n-  uint64_t max_flat_grid_size;\n-  /* Max number of work-items in a work-group used to launch the kernel.  */\n-  uint32_t max_flat_workgroup_size;\n-  /* The grid size required by the kernel.  */\n-  uint64_t required_grid_size[3];\n-  /* The work group size required by the kernel.  */\n-  uint32_t required_workgroup_size[3];\n-  /* The number of dimensions required by the kernel.  */\n-  uint8_t required_dim;\n-\n-} phsa_descriptor;\n-\n-/* The prefix to use in the ELF section containing descriptor for\n-   a function.  */\n-\n-#define PHSA_DESC_SECTION_PREFIX \"phsa.desc.\"\n-#define PHSA_HOST_DEF_PTR_PREFIX \"__phsa.host_def.\"\n-\n-/* The frontend error messages are parsed by the host runtime.  Known\n-   prefix strings are used to separate the different runtime error\n-   codes.  */\n-\n-#define PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE \"Incompatible module: \"\n-#define PHSA_ERROR_PREFIX_CORRUPTED_MODULE \"Corrupted module: \"\n-\n-/* Offsets of attributes in the PHSA context structs.\n-   Used by -fphsa-wi-context-opt.  */\n-#define PHSA_CONTEXT_OFFS_WI_IDS 0\n-#define PHSA_CONTEXT_OFFS_WG_IDS (PHSA_CONTEXT_OFFS_WI_IDS + 3 * 4)\n-#define PHSA_CONTEXT_WG_SIZES (PHSA_CONTEXT_OFFS_WG_IDS + 3 * 4)\n-#define PHSA_CONTEXT_CURRENT_WG_SIZES (PHSA_CONTEXT_WG_SIZES + 3 * 4)\n-\n-#endif"}, {"sha": "cbbc8ea076d1bc444baef8c30e6e0237e6cba79b", "filename": "gcc/brig/brigspec.c", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fbrigspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigspec.c?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,136 +0,0 @@\n-/* brigspec.c -- Specific flags and argument handling of the gcc BRIG front end.\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"opt-suggestions.h\"\n-#include \"gcc.h\"\n-#include \"opts.h\"\n-\n-/* This bit is set if we saw a `-xfoo' language specification.  */\n-#define LANGSPEC (1 << 1)\n-/* This bit is set if they did `-lm' or `-lmath'.  */\n-#define MATHLIB (1 << 2)\n-/* This bit is set if they did `-lpthread'.  */\n-#define THREADLIB (1 << 3)\n-/* This bit is set if they did `-lc'.  */\n-#define WITHLIBC (1 << 4)\n-/* Skip this option.  */\n-#define SKIPOPT (1 << 5)\n-\n-#ifndef MATH_LIBRARY\n-#define MATH_LIBRARY \"m\"\n-#endif\n-#ifndef MATH_LIBRARY_PROFILE\n-#define MATH_LIBRARY_PROFILE MATH_LIBRARY\n-#endif\n-\n-#define LIBHSAIL \"hsail-rt\"\n-\n-void\n-lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n-\t\t      unsigned int *in_decoded_options_count,\n-\t\t      int *in_added_libraries)\n-{\n-  unsigned int i, j;\n-\n-  /* The new argument list will be contained in this.  */\n-  struct cl_decoded_option *new_decoded_options;\n-\n-  /* An array used to flag each argument that needs a bit set for\n-     LANGSPEC, MATHLIB, or WITHLIBC.  */\n-  int *args;\n-\n-  /* By default, we throw on the math library if we have one.  */\n-  int need_math = (MATH_LIBRARY[0] != '\\0');\n-\n-  /* True if we should add -shared-libgcc to the command-line.  */\n-  int shared_libgcc = 1;\n-\n-  /* The total number of arguments with the new stuff.  */\n-  unsigned int argc;\n-\n-  /* The argument list.  */\n-  struct cl_decoded_option *decoded_options;\n-\n-  /* The number of libraries added in.  */\n-  int added_libraries;\n-\n-  /* The total number of arguments with the new stuff.  */\n-  int num_args = 1;\n-\n-  argc = *in_decoded_options_count;\n-  decoded_options = *in_decoded_options;\n-  added_libraries = *in_added_libraries;\n-\n-  args = XCNEWVEC (int, argc);\n-\n-  for (i = 1; i < argc; i++)\n-    {\n-      switch (decoded_options[i].opt_index)\n-\t{\n-\tcase OPT_o:\n-\t  break;\n-\n-\tcase OPT_SPECIAL_input_file:\n-\t  break;\n-\t}\n-    }\n-\n-  /* Make sure to have room for the trailing NULL argument.  */\n-  num_args = argc + need_math + shared_libgcc + 10;\n-  new_decoded_options = XNEWVEC (struct cl_decoded_option, num_args);\n-\n-  i = 0;\n-  j = 0;\n-\n-  /* Copy the 0th argument, i.e., the name of the program itself.  */\n-  new_decoded_options[j++] = decoded_options[i++];\n-\n-  /* NOTE: We start at 1 now, not 0.  */\n-  while (i < argc)\n-    {\n-      new_decoded_options[j] = decoded_options[i];\n-\n-      if ((args[i] & SKIPOPT) != 0)\n-\t--j;\n-\n-      i++;\n-      j++;\n-    }\n-\n-  generate_option (OPT_l, LIBHSAIL, 1, CL_DRIVER, &new_decoded_options[j]);\n-  j++;\n-\n-  *in_decoded_options_count = j;\n-  *in_decoded_options = new_decoded_options;\n-  *in_added_libraries = added_libraries;\n-}\n-\n-/* Called before linking.  Returns 0 on success and -1 on failure.  */\n-\n-int lang_specific_pre_link (void) /* Not used for Brig.  */ { return 0; }\n-\n-/* Number of extra output files that lang_specific_pre_link may generate.  */\n-\n-int lang_specific_extra_outfiles = 0; /* Not used for Brig.  */"}, {"sha": "cf04aac93caa957291b2b98a30eb8fc9d12455d6", "filename": "gcc/brig/config-lang.in", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fconfig-lang.in?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,41 +0,0 @@\n-# config-lang.in -- Top level configure fragment for gcc BRIG (HSAIL) frontend.\n-\n-# Copyright (C) 2015-2021 Free Software Foundation, Inc.\n-\n-# This file is part of GCC.\n-\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-# Configure looks for the existence of this file to auto-config each language.\n-# We define several parameters used by configure:\n-#\n-# language\t- name of language as it would appear in $(LANGUAGES)\n-# compilers\t- value to add to $(COMPILERS)\n-\n-language=\"brig\"\n-\n-compilers=\"brig1\\$(exeext)\"\n-\n-target_libs=\"target-libhsail-rt\"\n-\n-# The BRIG frontend is written in C++, so we need to build the C++\n-# compiler during stage 1.  Note: when cross-compiling / not bootstrapping,\n-# this can be safely removed. gcc 4.9.1 force enables c++/libstdc++ to the\n-# target compiler due to this.\n-lang_requires_boot_languages=c++\n-\n-gtfiles=\"\\$(srcdir)/brig/brig-lang.c \\$(srcdir)/brig/brig-c.h\"\n-\n-build_by_default=\"no\""}, {"sha": "87b36014098f3c9113f29eee30fef05a550e393e", "filename": "gcc/brig/gccbrig.texi", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fgccbrig.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Fgccbrig.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fgccbrig.texi?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,153 +0,0 @@\n-\\input texinfo @c -*-texinfo-*-\n-@setfilename gccbrig.info\n-@settitle The GNU BRIG (HSAIL) Compiler\n-@set copyrights-brig 2017-2021\n-\n-@c Merge the standard indexes into a single one.\n-@syncodeindex fn cp\n-@syncodeindex vr cp\n-@syncodeindex ky cp\n-@syncodeindex pg cp\n-@syncodeindex tp cp\n-\n-@include gcc-common.texi\n-\n-@copying\n-@c man begin COPYRIGHT\n-Copyright @copyright{} @value{copyrights-brig} Free Software Foundation, Inc.\n-\n-Permission is granted to copy, distribute and/or modify this document\n-under the terms of the GNU Free Documentation License, Version 1.3 or\n-any later version published by the Free Software Foundation; with no\n-Invariant Sections, the Front-Cover Texts being (a) (see below), and\n-with the Back-Cover Texts being (b) (see below).\n-A copy of the license is included in the\n-@c man end\n-section entitled ``GNU Free Documentation License''.\n-@ignore\n-@c man begin COPYRIGHT\n-man page gfdl(7).\n-@c man end\n-@end ignore\n-\n-@c man begin COPYRIGHT\n-\n-(a) The FSF's Front-Cover Text is:\n-\n-     A GNU Manual\n-\n-(b) The FSF's Back-Cover Text is:\n-\n-     You have freedom to copy and modify this GNU Manual, like GNU\n-     software.  Copies published by the Free Software Foundation raise\n-     funds for GNU development.\n-@c man end\n-@end copying\n-\n-@ifinfo\n-@format\n-@dircategory Software development\n-@direntry\n-* Gccbrig: (gccbrig).           A GCC-based compiler for BRIG/HSAIL finalization\n-@end direntry\n-@end format\n-\n-@insertcopying\n-@end ifinfo\n-\n-@titlepage\n-@title The GNU BRIG (HSAIL) Compiler\n-@versionsubtitle\n-@author Pekka J\u00e4\u00e4skel\u00e4inen\n-\n-@page\n-@vskip 0pt plus 1filll\n-Published by the Free Software Foundation @*\n-51 Franklin Street, Fifth Floor@*\n-Boston, MA 02110-1301, USA@*\n-@sp 1\n-@insertcopying\n-@end titlepage\n-@contents\n-@page\n-\n-@node Top\n-@top Introduction\n-\n-This manual describes how to use @command{gccbrig}, the GNU compiler for\n-the binary representation (BRIG) of the HSA Intermediate Language (HSAIL).\n-For more information about the Heterogeneous System Architecture (HSA)\n-Foundation's standards in general, see @uref{http://www.hsafoundation.com/}.\n-\n-@menu\n-* Copying::                     The GNU General Public License.\n-* GNU Free Documentation License::\n-                                How you can share and copy this manual.\n-* Using Gccbrig::               How to use Gccbrig.\n-* Index::                       Index.\n-@end menu\n-\n-@include gpl_v3.texi\n-\n-@include fdl.texi\n-\n-\n-@node Using Gccbrig\n-@chapter Using Gccbrig\n-\n-@c man title gccbrig A GCC-based compiler for HSAIL\n-\n-@ignore\n-@c man begin SYNOPSIS gccbrig\n-gccbrig [@option{-c}|@option{-S}]\n-        [@option{-O}@var{level}] [@option{-L}@var{dir}@dots{}]\n-        [@option{-o} @var{outfile}] @var{infile}@dots{}\n-\n-Gccbrig is typically not invoked from the command line, but\n-through an HSA finalizer implementation.\n-@c man end\n-@c man begin SEEALSO\n-The Info entry for @file{gccbrig} and\n-@uref{https://github.com/HSAFoundation/phsa}\n-@c man end\n-@end ignore\n-\n-@c man begin DESCRIPTION gccbrig\n-\n-The BRIG frontend (@command{gccbrig}) differs from the\n-other frontends in GCC on how it's typically used.  It's a translator\n-for an intermediate language that is not meant to be written directly\n-by programmers.  Its input format BRIG is a binary representation of\n-HSAIL, which is a textual assembly format for an imaginary machine\n-of which instruction set is defined in HSA Programmer Reference Manual\n-(PRM) Specification.  Gccbrig currently implements the Base profile\n-of the PRM version 1.0.\n-\n-HSA Runtime Specification defines an API which includes means\n-to build and launch ``kernels'' from a host program running on a CPU\n-to one or more heterogeneous ``kernel agents''. A kernel Agent\n-is typically a GPU or a DSP device controlled by the CPU.\n-The build phase is called ``finalization'', which means translation of\n-one or more target-independent BRIG files describing the program that\n-one wants to run in the Agent to the Agent's instruction set.  Gccbrig\n-implements the translation process by generating GENERIC, which is\n-translated to the ISA of any supported GCC target by the GCC's backend\n-framework, thus enabling potentially any GCC target to act as an HSA agent.\n-\n-As the kernel finalization process can be only launched from the host API,\n-@command{gccbrig} is not typically used directly from the command line by\n-the end user, but through an HSA runtime implementation that implements\n-the finalizer API running on the host CPU.  Gccbrig is\n-designed to work with an open source HSA runtime implementation\n-called ``phsa-runtime'', which can be installed from\n-@uref{https://github.com/HSAFoundation/phsa-runtime}.  Phsa-runtime\n-has an example Agent driver that allows any GCC-supported CPU to act as\n-a kernel Agent.  The web page has further installation instructions for\n-setting up it to work with a gccbrig binary installed with the GCC.\n-\n-@node Index\n-@unnumbered Index\n-\n-@printindex cp\n-\n-@bye"}, {"sha": "1075801c678da4d06a764605b2b97fafb42254a0", "filename": "gcc/brig/lang-specs.h", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Flang-specs.h?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,28 +0,0 @@\n-/* lang-specs.h -- gcc driver specs for BRIG (HSAIL) frontend.\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n-   for General Processor Tech.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* This is the contribution to the `default_compilers' array in gcc.c\n-   for the BRIG (HSAIL) input.  */\n-\n-{\".brig\", \"@brig\", 0, 1, 0},\n-  {\"@brig\",\n-   \"brig1 %i %(cc1_options) %{I*} %{L*} %D %{!fsyntax-only:%(invoke_as)}\", 0, 1,\n-   0},"}, {"sha": "6fcceceb57c61d21b50d9ed4be08af6ac9c8c4ee", "filename": "gcc/brig/lang.opt", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Fbrig%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Flang.opt?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,46 +0,0 @@\n-; lang.opt -- Options for the gcc BRIG (HSAIL) front end.\n-\n-; Copyright (C) 2015-2021 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-; See the GCC internals manual for a description of this file's format.\n-\n-; Please try to keep this file in ASCII collating order.\n-\n-Language\n-BRIG\n-\n--dump\n-BRIG Separate Alias(d)\n-\n--dump=\n-BRIG Joined Alias(d)\n-\n-fassume-phsa\n-BRIG Var(flag_assume_phsa) Init(1) Optimization\n-Assume we are finalizing for phsa and its libhsail-rt.  Enables additional\n-phsa-specific optimizations (default).\n-\n-L\n-BRIG Joined Separate\n-; Not documented\n-\n--output=\n-BRIG Driver Joined Alias(o) MissingArgError(missing filename after %qs)\n-\n-; This comment is to ensure we retain the blank line above."}, {"sha": "ec556df4f66d95a868c34437c5e39da6620f738e", "filename": "gcc/builtins.def", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=900b1c27b963c8244c7547943d4a8d03dfacc6f4", "patch": "@@ -1073,47 +1073,4 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n /* Coroutine builtins.  */\n #include \"coroutine-builtins.def\"\n \n-/* Do not expose the BRIG builtins by default gcc-wide, but only privately in\n-   the BRIG FE as long as there are no references for them in the middle end\n-   or any of the upstream backends.  */\n-\n-#ifndef DEF_HSAIL_BUILTIN\n-#define DEF_HSAIL_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE, NAME, TYPE, ATTRS) \\\n-  DEF_BUILTIN_STUB (ENUM, \"__builtin_\" NAME)\n-#endif\n-\n-/* HSAIL atomic builtins do not have separate identifying opcodes.  */\n-\n-#ifndef DEF_HSAIL_ATOMIC_BUILTIN\n-#define DEF_HSAIL_ATOMIC_BUILTIN(ENUM, ATOMIC_OPCODE, HSAIL_TYPE, NAME, \\\n-\tTYPE, ATTRS) \\\n-  DEF_BUILTIN_STUB (ENUM, \"__builtin_\" NAME)\n-#endif\n-\n-/* HSAIL saturating arithmetics builtins.  */\n-\n-#ifndef DEF_HSAIL_SAT_BUILTIN\n-#define DEF_HSAIL_SAT_BUILTIN(ENUM, BRIG_OPCODE, HSAIL_TYPE, NAME, \\\n-\tTYPE, ATTRS) \\\n-  DEF_BUILTIN_STUB (ENUM, \"__builtin_\" NAME)\n-#endif\n-\n-/* HSAIL builtins used internally by the frontend.  */\n-\n-#ifndef DEF_HSAIL_INTR_BUILTIN\n-#define DEF_HSAIL_INTR_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n-  DEF_BUILTIN_STUB (ENUM, \"__builtin_\" NAME)\n-#endif\n-\n-/* HSAIL saturated conversions.  */\n-\n-#ifndef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n-#define DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN(ENUM, HSAIL_DEST_TYPE, HSAIL_SRC_TYPE, \\\n-  NAME, TYPE, ATTRS) \\\n-  DEF_BUILTIN_STUB (ENUM, \"__builtin_\" NAME)\n-#endif\n-\n-/* HSAIL/BRIG frontend builtins.  */\n-#include \"brig-builtins.def\"\n-\n #undef DEF_BUILTIN"}, {"sha": "7ff691bbaa51d44d9c07427595e8ba83464d7836", "filename": "gcc/doc/frontends.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fdoc%2Ffrontends.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fdoc%2Ffrontends.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ffrontends.texi?ref=900b1c27b963c8244c7547943d4a8d03dfacc6f4", "patch": "@@ -17,7 +17,7 @@\n GCC stands for ``GNU Compiler Collection''.  GCC is an integrated\n distribution of compilers for several major programming languages.  These\n languages currently include C, C++, Objective-C, Objective-C++,\n-Fortran, Ada, D, Go, and BRIG (HSAIL).\n+Fortran, Ada, D, and Go.\n \n The abbreviation @dfn{GCC} has multiple meanings in common use.  The\n current official meaning is ``GNU Compiler Collection'', which refers"}, {"sha": "261951848d42b1abd3f3b5c46d409d0a43f3e623", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=900b1c27b963c8244c7547943d4a8d03dfacc6f4", "patch": "@@ -2995,10 +2995,8 @@ separately.\n \n Second, you must have the testing tools installed.  This includes\n @uref{http://www.gnu.org/software/dejagnu/,,DejaGnu}, Tcl, and Expect;\n-the DejaGnu site has links to these. For running the BRIG frontend\n-tests, a tool to assemble the binary BRIGs from HSAIL text,\n-@uref{https://github.com/HSAFoundation/HSAIL-Tools/,,HSAILasm} must\n-be installed.  Some optional tests also require Python3 and pytest module.\n+the DejaGnu site has links to these.\n+Some optional tests also require Python3 and pytest module.\n \n If the directories where @command{runtest} and @command{expect} were\n installed are not in the @env{PATH}, you may need to set the following"}, {"sha": "fddaa8c356afa2627fe6e350b4f75daff56e7ec5", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=900b1c27b963c8244c7547943d4a8d03dfacc6f4", "patch": "@@ -1538,9 +1538,6 @@ traditional preprocessor).\n @item @var{file}.go\n Go source code.\n \n-@item @var{file}.brig\n-BRIG files (binary representation of HSAIL).\n-\n @item @var{file}.d\n D source code.\n \n@@ -1596,7 +1593,6 @@ ada\n d\n f77  f77-cpp-input f95  f95-cpp-input\n go\n-brig\n @end smallexample\n \n @item -x none"}, {"sha": "128b1c67bbc8a042a3b49cd5ba6e54697408f388", "filename": "gcc/doc/standards.texi", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fdoc%2Fstandards.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Fdoc%2Fstandards.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fstandards.texi?ref=900b1c27b963c8244c7547943d4a8d03dfacc6f4", "patch": "@@ -320,14 +320,6 @@ available online, see @uref{http://gcc.gnu.org/readings.html}\n As of the GCC 4.7.1 release, GCC supports the Go 1 language standard,\n described at @uref{https://golang.org/doc/go1}.\n \n-@section HSA Intermediate Language (HSAIL)\n-\n-GCC can compile the binary representation (BRIG) of the HSAIL text format as\n-described in HSA Programmer's Reference Manual version 1.0.1. This\n-capability is typically utilized to implement the HSA runtime API's HSAIL \n-finalization extension for a gcc supported processor. HSA standards are\n-freely available at @uref{http://www.hsafoundation.com/standards/}.\n-\n @section D language\n \n GCC supports the D 2.0 programming language.  The D language itself is"}, {"sha": "2ad5b24e75e8b7465b0df7bdd96b8fbc426293b7", "filename": "gcc/testsuite/brig.dg/README", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2FREADME?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,12 +0,0 @@\n-BRIG (HSAIL) frontend test cases\n---------------------------------\n-\n-The suite consists of \"smoke tests\" that test several features of\n-the compilation and regression tests, but is not an exhaustive test\n-suite for all HSAIL instructions. The HSA PRM conformance suite\n-is supposed to be used for that.\n-\n-HSAILasm is required for converting the text HSAIL files to BRIGs\n-which the compiler consumes. It can be built from\n-https://github.com/HSAFoundation/HSAIL-Tools\n-"}, {"sha": "6441092895a549fc83762bf8f7ed6fbd0e8c924f", "filename": "gcc/testsuite/brig.dg/dg.exp", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Fdg.exp?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,31 +0,0 @@\n-#   Copyright (C) 2009-2021 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-# GCC testsuite that uses the `dg.exp' driver.\n-\n-load_lib brig-dg.exp\n-\n-# Initialize `dg'.\n-dg-init\n-\n-if [expr [llength [auto_execok HSAILasm]] > 0] {\n-    dg-runtest [find $srcdir/$subdir *.hsail] \"\" \"\"\n-} else {\n-    unsupported \"All BRIG FE tests require HSAILasm in PATH.\"\n-}\n-\n-# All done.\n-dg-finish"}, {"sha": "479ab7237b813dddcfb4ad25c89f901a9812dc86", "filename": "gcc/testsuite/brig.dg/test/gimple/alloca.hsail", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Falloca.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Falloca.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Falloca.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,37 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* Tests for alloca. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n-\n-prog function &subfunction(arg_u32 %return_value)() {\n-     alloca_align(1)_u32 $s2, 256;\n-     st_arg_u32 $s2, [%return_value];\n-     ret;\n-};\n-\n-prog kernel &kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-        ld_kernarg_u64 $d0, [%input_ptr];\n-        ld_global_u32 $s0, [$d0];\n-\n-\talloca_align(256)_u32 $s1, 16;\n-\t{\n-\t\targ_u32 %return_value;\n-\t\tcall &subfunction(%return_value)();\n-\t\tld_arg_u32 $s1, [%return_value];\n-\t}\n-        ld_kernarg_u64 $d1, [%output_ptr];\n-        st_global_u32 $s1, [$d0];\n-};\n-\n-/* { dg-final { scan-tree-dump \"s2 = __builtin___hsail_alloca \\\\\\(256, 1, __context\\\\\\);\" \"gimple\" } } */\n-\n-/* { dg-final { scan-tree-dump \"s1 = __builtin___hsail_alloca \\\\\\(16, 256, __context\\\\\\);\" \"gimple\" } } */\n-\n-\n-/* Both functions should have an alloca frame push and pop. */\n-/* { dg-final { scan-tree-dump-times \"__builtin___hsail_alloca_push_frame \\\\\\(__context\\\\\\);\" 2 \"gimple\" } } */\n-\n-/* { dg-final { scan-tree-dump-times \"__builtin___hsail_alloca_pop_frame \\\\\\(__context\\\\\\);\" 2 \"gimple\" } } */"}, {"sha": "b877a668ec924b22ca0b53f650849fd80bbfe154", "filename": "gcc/testsuite/brig.dg/test/gimple/atomics.hsail", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fatomics.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fatomics.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fatomics.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,33 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* Test for atomic instructions. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-original\" } */\n-\n-prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-        ld_kernarg_u64 $d0, [%input_ptr];\n-\n-\tatomic_ld_global_rlx_system_b32 $s0, [$d0];\n-\tatomic_add_global_rlx_system_u32 $s1, [$d0 + 4], $s0;\n-\n-        ld_kernarg_u64 $d0, [%output_ptr];\n-        atomicnoret_st_global_rlx_system_b32 [$d0], $s2;\n-\n-\tatomicnoret_min_global_rlx_system_u32 [$d0 + 4], $s1;\n-\n-        ret;\n-};\n-\n-/* The atomic loads are implemented by casting to an atomic pointer. */\n-/* { dg-final { scan-tree-dump \"s0 = VIEW_CONVERT_EXPR<unsigned int>\\\\\\(\\\\\\*\\\\\\(atomic unsigned int \\\\\\*\\\\\\)\" \"original\"} } */\n-\n-/* The atomic add should call a gcc builtin. */\n-/* { dg-final { scan-tree-dump \"= __sync_fetch_and_add_4 \\\\\\(\" \"original\"} } */\n-\n-/* The atomic stores are implemented by casting to an atomic pointer. */\n-/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(atomic unsigned int \\\\\\*\\\\\\) d0 = s2;\" \"original\"} } */\n-\n-/* The atomic min is implemented by a custom builtin. */\n-/* { dg-final { scan-tree-dump \"builtin_out.\\[0-9\\]+ = __builtin___hsail_atomic_min_u32 \\\\\\(\" \"original\"} } */"}, {"sha": "081fde3f1c278f5d0837694431cdaab0b4c04bf7", "filename": "gcc/testsuite/brig.dg/test/gimple/branches.hsail", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fbranches.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fbranches.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fbranches.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,58 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* Test different style of branches. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n-\n-prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-        ld_kernarg_u64 $d0, [%input_ptr];\n-        ld_global_u64 $d1, [$d0];\n-        ld_global_u64 $d2, [$d0 + 8];\n-\n-        ld_global_u32 $s0, [$d0 + 16];\n-        ld_global_u32 $s1, [$d0 + 20];\n-\n-\tsbr_width(all)_u32 $s1 [@case0, @case1, @case2];\n-@case0:\n-        st_global_u64 0, [$d0];\n-\tbr @out;\n-@case1:\n-        st_global_u64 1, [$d0];\n-\tbr @out;\n-@case2:\n-        st_global_u64 2, [$d0];\n-@out:\n-\tcmp_eq_u32_u32 $s2, $s1, $s0;\n-\tcvt_b1_u32 $c0, $s2;\n-\n-\tcbr_width(all)_b1 $c0, @true_branch;\n-@false_branch:\n-        st_global_u64 $d1, [$d0];\n-\n-@true_branch:\n-        ld_kernarg_u64 $d0, [%output_ptr];\n-\n-        st_global_u32 $s2, [$d0 + 8];\n-\tbr @skip;\n-        st_global_u32 $s3, [$d0 + 12];\n-\n-@skip:\n-        ret;\n-};\n-\n-/* sbr is converted to a switch */\n-/* { dg-final { scan-tree-dump \"switch \\\\\\(s1\\\\\\) <default: <D.\\[0-9\\]+>, case 0: <D.\\[0-9\\]+>, case 1: <D.\\[0-9\\]+>, case 2: <D.\\[0-9\\]+>>\" \"gimple\"} } */\n-\n-/* br @out converted to gotos */\n-/* { dg-final { scan-tree-dump-times \"goto @out\" 2 \"gimple\"} } */ \n-\n-/* the comparison instruction */\n-/* { dg-final { scan-tree-dump \"c0 = s2 != 0;\" \"gimple\" } } */\n-\n-/* cbr to an if clause */\n-/* { dg-final { scan-tree-dump \"if \\\\\\(c0 != 0\\\\\\) goto @true_branch; else goto <D.\\[0-9\\]+>;\" \"gimple\" } } */\n-\n-/* br @skip converted to a goto */\n-/* { dg-final { scan-tree-dump \"goto @skip\" \"gimple\"} } */ "}, {"sha": "9efe027157155e07700041a461a0326eae826aac", "filename": "gcc/testsuite/brig.dg/test/gimple/fbarrier.hsail", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffbarrier.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffbarrier.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffbarrier.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,74 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* Tests for fbarrier. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n-\n-fbarrier &fb_module_scope;\n-\n-prog function &subfunction(arg_u32 %return_value)() {\n-\n-     workitemflatabsid_u32 $s3;\n-     cvt_b1_u32 $c1, $s3;\n-     cbr_width(all)_b1 $c1, @skip_fbar;\n-     waitfbar &fb_module_scope;\n-@skip_fbar:\n-\n-     st_arg_u32 $s3, [%return_value];\n-     ret;\n-};\n-\n-prog kernel &kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-\tfbarrier %fb_func_scope;\n-\n-        ld_kernarg_u64 $d0, [%input_ptr];\n-        ld_global_u32 $s0, [$d0];\n-\n-\tworkitemflatabsid_u32 $s1;\n-\tcvt_b1_u32 $c1, $s1;\n-\tcbr_width(all)_b1 $c1, @skip_init;\n-\n-\tinitfbar &fb_module_scope;\n-\tinitfbar %fb_func_scope;\n-\n-        joinfbar &fb_module_scope;\n-\n-@skip_init:\n-\tbarrier_width(all);\n-\n-        joinfbar %fb_func_scope;\n-\n-\t{\n-\t\targ_u32 %return_value;\n-\t\tcall &subfunction(%return_value)();\n-\t\tld_arg_u32 $s1, [%return_value];\n-\t}\n-\tarrivefbar %fb_func_scope;\n-\n-        ld_kernarg_u64 $d1, [%output_ptr];\n-        st_global_u32 $s1, [$d0];\n-\n-\tworkitemflatabsid_u32 $s1;\n-\tcvt_b1_u32 $c0, $s1;\n-\tcbr_width(all)_b1 $c0, @skip_fini;\n-\n-\treleasefbar &fb_module_scope;\n-\treleasefbar %fb_func_scope;\n-\n-@skip_fini:\n-\n-};\n-/* fbarriers are allocated from the group memory in the order of \n-   appearance. The current implementation allocates 32B per fbarrier. */\n-\n-/* { dg-final { scan-tree-dump \"__hsail_waitfbar \\\\\\(0, __context\\\\\\);\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"__hsail_initfbar \\\\\\(0, __context\\\\\\);\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"__hsail_initfbar \\\\\\(__group_local_offset, __context\\\\\\);\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"__hsail_joinfbar \\\\\\(0, __context\\\\\\);\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"@skip_init:\\[\\n ]+__builtin___hsail_barrier \\\\\\(__context\\\\\\);\\[\\n ]+__builtin___hsail_joinfbar \\\\\\(__group_local_offset, __context\\\\\\);\" \"gimple\"} } */\n-\n-/* { dg-final { scan-tree-dump \"__hsail_arrivefbar \\\\\\(__group_local_offset, __context\\\\\\);\" \"gimple\"} } */\n-\n-/* { dg-final { scan-tree-dump \"__hsail_releasefbar \\\\\\(0, __context\\\\\\);\\[\\n ]+__builtin___hsail_releasefbar \\\\\\(__group_local_offset, __context\\\\\\);\" \"gimple\"} } */"}, {"sha": "50f79060b592a8fb84a1c7de537dd9be51b69472", "filename": "gcc/testsuite/brig.dg/test/gimple/function_calls.hsail", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffunction_calls.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffunction_calls.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffunction_calls.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,59 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* Function calls and argument passing. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n-\n-prog function &subfunction(arg_u32 %return_value)(arg_f32 %float_arg, arg_f64 %double_arg, arg_f16 %half_arg) {\n-     ld_arg_f32 $s0, [%float_arg];\n-     cvt_u32_f32 $s0, $s0;\n-\n-     ld_arg_f64 $d0, [%double_arg];\n-     cvt_u32_f64 $s1, $d0;\n-\n-     ld_arg_f16 $s2, [%half_arg];\n-     cvt_u32_f16 $s2, $s2;\n-\n-     add_u32 $s3, $s0, $s1;\n-     add_u32 $s3, $s3, $s2;\n-\n-     st_arg_u32 $s3, [%return_value];\n-     ret;\n-};\n-\n-prog kernel &kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-        ld_kernarg_u64 $d0, [%input_ptr];\n-        ld_global_u32 $s0, [$d0];\n-\t{\n-\t\targ_f32 %float_arg;\n-\t\targ_f64 %double_arg;\n-\t\targ_f16 %half_arg;\n-\t\targ_u32 %return_value;\n-\n-\t\tst_arg_f32 12.0f, [%float_arg];\n-\t\tst_arg_f64 640.0d, [%double_arg];\n-\t\tst_arg_f16 12.0h, [%half_arg];\n-\n-\t\tcall &subfunction(%return_value)(%float_arg, %double_arg, %half_arg);\n-\n-\t\tld_arg_u32 $s1, [%return_value];\n-\t}\t\n-        ld_kernarg_u64 $d1, [%output_ptr];\n-        st_global_u32 $s1, [$d0];\n-};\n-\n-/* The generated function call should have the incoming arguments and three hidden arguments. */\n-\n-/* { dg-final { scan-tree-dump \"_\\[0-9\\]+ = subfunction \\\\\\(_kernel.float_arg.\\[_0-9\\]+, _kernel.double_arg.\\[_0-9\\]+, _kernel.half_arg.\\[_0-9\\]+, __context, __group_base_addr, group_local_offset.*, __private_base_addr\\\\\\);\" \"gimple\"} } */\n-\n-/* The callee should refer directly to the scalar arguments when it reads them. */\n-/* { dg-final { scan-tree-dump \"= float_arg;\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"= double_arg;\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"= half_arg;\" \"gimple\"} } */\n-\n-/* The return value is stored to a temporary before returned. */\n-/* { dg-final { scan-tree-dump \"_retvalue_temp = s3;\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"D.\\[0-9\\]+ = _retvalue_temp;\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"return D.\\[0-9\\]+;\" \"gimple\"} } */"}, {"sha": "52673c9e65a0c51bc5f6ff73cbc36243d5dc7c5d", "filename": "gcc/testsuite/brig.dg/test/gimple/internal-casts.hsail", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Finternal-casts.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Finternal-casts.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Finternal-casts.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,146 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* Test for casting from/to representation of HSA registers.          */\n-\n-/* HSA registers are untyped but in gccbrig they are presented as     */\n-/* variables with a type selected by analysis.  Currently, each       */\n-/* register variable, per function, has a type as it is used at       */\n-/* most.  Therefore, register variable can be nearly any type.  The   */\n-/* tests makes sure the generic/tree expressions have the right casts */\n-/* from/to the register variables.                                    */\n-\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-original\" } */\n-\n-prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-        private_u64 %foo;\n-        private_u64 %bar;\n-        private_b128 %baz;\n-\n-        ld_kernarg_u64 $d0, [%input_ptr];\n-        ld_global_u32 $s0, [$d0];\n-\n-        /* Trick gccbrig to set wanted type for the registers.  */\n-\n-/* $s0 is selected as float... */\n-/* { dg-final { scan-tree-dump \"<float:32> s0;\" \"original\"} } */\n-/* ..., therefore, there should not be any casts.  */\n-/* { dg-final { scan-tree-dump \"s10 = s0 \\\\\\+ s0;\" \"original\"} } */\n-\n-        add_f32 $s10, $s0, $s0;\n-        add_f32 $s10, $s0, $s0;\n-        add_f32 $s10, $s0, $s0;\n-        add_f32 $s10, $s0, $s0;\n-        add_f32 $s10, $s0, $s0;\n-\n-/* Expression with other type, a cast is needed.  */\n-/* { dg-final { scan-tree-dump \"s1 = VIEW_CONVERT_EXPR<unsigned int>.s0. \\\\\\+ 123;\" \"original\"} } */\n-\n-        add_u32 $s1, $s0, 123;\n-\n-/* { dg-final { scan-tree-dump \"unsigned int s1;\" \"original\"} } */\n-\n-        add_u32 $s10, $s1, 0;\n-        add_u32 $s10, $s1, 0;\n-        add_u32 $s10, $s1, 0;\n-        add_u32 $s10, $s1, 0;\n-        add_u32 $s10, $s1, 0;\n-\n-/* { dg-final { scan-tree-dump \"s0 = VIEW_CONVERT_EXPR<<float:32>>.s1.;\" \"original\"} } */\n-\n-        mov_b32 $s0, $s1;\n-\n-/* Rig the election for $d0 to be double.  */\n-/* { dg-final { scan-tree-dump \"<float:64> d0;\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"d10 = d0 \\\\\\+ d0;\" \"original\"} } */\n-\n-        add_f64 $d10, $d0, $d0;\n-        add_f64 $d10, $d0, $d0;\n-        add_f64 $d10, $d0, $d0;\n-        add_f64 $d10, $d0, $d0;\n-        add_f64 $d10, $d0, $d0;\n-\n-/* Make $s2 to be vector type.  */\n-/* { dg-final { scan-tree-dump \"vector.4. unsigned char s2;\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"s2 = VIEW_CONVERT_EXPR<vector.4. unsigned char>\\\\\\(s1\\\\\\) \\\\\\+ VIEW_CONVERT_EXPR<vector.4. unsigned char>\\\\\\(s1\\\\\\);\" \"original\"} } */\n-\n-        add_pp_u8x4 $s2, $s1, $s1;\n-\n-/* { dg-final { scan-tree-dump \"s20 = s2 \\\\\\+ s2;\" \"original\"} } */\n-\n-        add_pp_u8x4 $s20, $s2, $s2;\n-        add_pp_u8x4 $s20, $s2, $s2;\n-        add_pp_u8x4 $s20, $s2, $s2;\n-        add_pp_u8x4 $s20, $s2, $s2;\n-\n-/* { dg-final { scan-tree-dump \"d0 = VIEW_CONVERT_EXPR<<float:64>>.{VIEW_CONVERT_EXPR<unsigned int>.s0., VIEW_CONVERT_EXPR<unsigned int>.s2.}.;\" \"original\"} } */\n-\n-        combine_v2_b64_b32 $d0, ($s0, $s2);\n-\n-/* { dg-final { scan-tree-dump \"s2 = VIEW_CONVERT_EXPR<vector.4. unsigned char>.BIT_FIELD_REF <d0, 32, 0>.;\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"s1 = BIT_FIELD_REF <d0, 32, 32>;\" \"original\"} } */\n-\n-        expand_v2_b32_b64 ($s2, $s1), $d0;\n-\n-/* { dg-final { scan-tree-dump \"s0 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(.*VIEW_CONVERT_EXPR<unsigned int>.s0\\[\\)\\]*;\" \"original\"} } */\n-\n-        cvt_s16_s8 $s0, $s0;\n-\n-/* { dg-final { scan-tree-dump \"c0 = .*VIEW_CONVERT_EXPR<<float:32>>.s2..* != 0;\" \"original\"} } */\n-\n-        cvt_b1_f32 $c0, $s2;\n-\n-/* { dg-final { scan-tree-dump \".*__private_base_addr.* = .*\\\\\\(unsigned char\\\\\\) VIEW_CONVERT_EXPR<unsigned int>\\\\\\(s0\\\\\\)\\[\\)\\]*;\" \"original\"} } */\n-\n-        st_private_u8 $s0, [%foo];\n-\n-/* { dg-final { scan-tree-dump \".*__private_base_addr.* = .*\\\\\\(unsigned short\\\\\\) VIEW_CONVERT_EXPR<unsigned int>\\\\\\(s2\\\\\\)\\[\\)\\]*;\" \"original\"} } */\n-\n-        st_private_u16 $s2, [%bar];\n-\n-/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]* = \\\\\\*\\\\\\(signed char \\\\\\*\\\\\\) \\\\\\(__private_base_addr .*\\\\\\);\\[ \\n\\]*s2 = VIEW_CONVERT_EXPR<vector.4. unsigned char>\\\\\\(\\\\\\(signed int\\\\\\) mem_read.\\[0-9\\]*\\\\\\);\" \"original\"} } */\n-\n-        ld_private_s8 $s2, [%foo];\n-\n-/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]* = \\\\\\*\\\\\\(signed short \\\\\\*\\\\\\) \\\\\\(__private_base_addr .*\\\\\\);\\[ \\n\\]*s0 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(\\\\\\(signed int\\\\\\) mem_read.\\[0-9\\]*\\\\\\);\" \"original\"} } */\n-\n-        ld_private_s16 $s0, [%bar];\n-\n-/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 0 = s0;\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 4 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s1\\\\\\);\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 8 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s2\\\\\\);\" \"original\"} } */\n-\n-        st_v3_private_f32 ($s0, $s1, $s2), [%baz];\n-\n-/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]* = \\\\\\*\\\\\\(signed short \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 0;\\[ \\n\\]*s0 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(\\\\\\(signed int\\\\\\) mem_read.\\[0-9\\]*\\\\\\);\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]* = \\\\\\*\\\\\\(signed short \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 2;\\[ \\n\\]*s1 = VIEW_CONVERT_EXPR<unsigned int>\\\\\\(\\\\\\(signed int\\\\\\) mem_read.\\[0-9\\]*\\\\\\);\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]* = \\\\\\*\\\\\\(signed short \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 4;\\[ \\n\\]*s2 = VIEW_CONVERT_EXPR<vector.4. unsigned char>\\\\\\(\\\\\\(signed int\\\\\\) mem_read.\\[0-9\\]*\\\\\\);\" \"original\"} } */\n-\n-        ld_v3_private_s16 ($s0, $s1, $s2), [%baz];\n-\n-/* { dg-final { scan-tree-dump \"s5 = .*VIEW_CONVERT_EXPR<unsigned int>\\\\\\(s0\\\\\\) == VIEW_CONVERT_EXPR<unsigned int>\\\\\\(s2\\\\\\)\\\\\\) .*;\" \"original\"} } */\n-\n-        cmp_eq_s32_u32 $s5, $s0, $s2;\n-\n-/* { dg-final { scan-tree-dump \"s6 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(.*VIEW_CONVERT_EXPR<vector\\\\\\(2\\\\\\) unsigned short>\\\\\\(s0\\\\\\).*VIEW_CONVERT_EXPR<vector\\\\\\(2\\\\\\) unsigned short>\\\\\\(s2\\\\\\).*;\" \"original\"} } */\n-\n-        cmp_eq_pp_u16x2_u16x2 $s6, $s0, $s2;\n-\n-/* { dg-final { scan-tree-dump \"<float:32> s60;\" \"original\"} } */\n-\n-        add_f32 $s60, $s6, $s6;\n-        add_f32 $s60, $s6, $s6;\n-        add_f32 $s60, $s6, $s6;\n-        add_f32 $s60, $s6, $s6;\n-\n-        ld_kernarg_u64 $d0, [%output_ptr];\n-        st_global_u32 $s0, [$d0];\n-\n-        ret;\n-};\n-\n-\n-\n-"}, {"sha": "7f30919e30819d0a42d9a48bb8c8a4bcead3bee5", "filename": "gcc/testsuite/brig.dg/test/gimple/kernarg.hsail", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fkernarg.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fkernarg.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fkernarg.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,25 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* Tests for kernarg addressing modes. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-original\" } */\n-\n-prog kernel &Kernel(kernarg_u64 %input[4], kernarg_u64 %output_ptr, kernarg_u64 %i)\n-{\n-\tld_kernarg_u64 $d0, [%i];\n-\tld_kernarg_u64 $d0, [%input][$d0 + 1];\n-\n-\tld_kernarg_u64 $d1, [%output_ptr];\n-\tst_global_u64 $d0, [$d1];\n-\n-\tret;\n-};\n-\n-/* [%i] */\n-/* { dg-final { scan-tree-dump \" = \\\\\\*\\\\\\(unsigned long \\\\\\*\\\\\\) \\\\\\(__args \\\\\\+ 40\\\\\\);\" \"original\"} } */\n-\n-/* [%input][$d0 + 1] */\n-/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(unsigned long \\\\\\*\\\\\\) \\\\\\(\\\\\\(VIEW_CONVERT_EXPR<void \\\\\\*>\\\\\\(\\\\\\(unsigned long\\\\\\) __args\\\\\\) \\\\\\+ \\\\\\(unsigned long\\\\\\) d0\\\\\\) \\\\\\+ 1\\\\\\);\" \"original\"} } */\n-\n-"}, {"sha": "75835a102592830405480c0073bf4e1c0fccd4b6", "filename": "gcc/testsuite/brig.dg/test/gimple/mem.hsail", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmem.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmem.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmem.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,39 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* Tests for load/store addressing modes. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-original\" } */\n-\n-prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %input_ptr2, kernarg_u64 %output_ptr)\n-{\n-\tglobal_u32 %global_array[4];\n-\n-\tld_kernarg_u64 $d0, [%input_ptr];\n-\tld_kernarg_u64 $d2, [%input_ptr2];\n-\tld_global_u32 $s0, [$d0];\n-\tld_global_u64 $d1, [$d2 + 4];\n-\n-\tld_global_u32 $s2, [%global_array][$d1 + 4];\n-\n-\tld_kernarg_u64 $d0, [%output_ptr];\n-\tst_global_u32 $s0, [$d0];\n-\tst_global_u32 $s1, [$d0 + 4];\n-\tst_global_u32 $s2, [$d0 + 8];\n-\n-\tret;\n-};\n-\n-/* %input_ptr, %input_ptr2 and %output_ptr accesses should generate offsets to the __args array */\n-/* { dg-final { scan-tree-dump \"__args;\\[\\n \\]+d0 =\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"\\\\\\(__args \\\\\\+ 8\\\\\\);\\[\\n \\]+d2 =\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"\\\\\\(__args \\\\\\+ 16\\\\\\);\\[\\n \\]+d0 =\" \"original\"} } */\n-\n-/* ld_global_u32 $s0, [$d0] */\n-/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(unsigned int \\\\\\*\\\\\\) d0;\\[\\n \\]+s0 =\" \"original\"} } */\n-\n-/* ld_global_u64 $d1, [$d2 + 4] pointer arithmetics*/\n-/* { dg-final { scan-tree-dump \"d2 \\\\\\+ 4\\\\\\);\\[\\n \\]+d1 = \" \"original\"} } */\n-\n-/* ld_global_u32 $s2, [%global_array][$d1 + 4]; is the most complex form */\n-/* { dg-final { scan-tree-dump \"\\\\\\(unsigned long\\\\\\) &_Kernel.global_array\\\\\\) \\\\\\+ \\\\\\(unsigned long\\\\\\) d1\\\\\\) \\\\\\+ 4\" \"original\" } } */"}, {"sha": "acdced9ad1c4fe4e1f8fe372d77ab2085f195efe", "filename": "gcc/testsuite/brig.dg/test/gimple/mulhi.hsail", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmulhi.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmulhi.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmulhi.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,33 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* Test high part multiplies. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n-\n-prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-        ld_kernarg_u64 $d0, [%input_ptr];\n-        ld_global_u64 $d1, [$d0];\n-        ld_global_u64 $d2, [$d0 + 8];\n-\n-        ld_global_u32 $s0, [$d0 + 16];\n-        ld_global_u32 $s1, [$d0 + 20];\n-\n-\tmulhi_s32 $s2, $s0, $s1;\n-\tmulhi_s64 $d2, $d1, $d2;\n-\n-\tmad24hi_s32 $s3, $s0, $s1, $s2;\n-\tmul24hi_s32 $s3, $s3, $s1;\n-\n-        ld_kernarg_u64 $d0, [%output_ptr];\n-        st_global_u64 $d1, [$d0];\n-        st_global_u32 $s2, [$d0 + 8];\n-        st_global_u32 $s3, [$d0 + 12];\n-\n-        ret;\n-};\n-\n-/* All of the hipart mults areImplemented using MULT_HIGHPART_EXPR (h*). */\n-/* { dg-final { scan-tree-dump-times \" h\\\\\\* \" 4 \"gimple\"} } */\n-"}, {"sha": "1e2bb53de0d5ee0f19b4cecd7f4bc2b2df56091b", "filename": "gcc/testsuite/brig.dg/test/gimple/packed.hsail", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpacked.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpacked.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpacked.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,76 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* Test for different cases of packed instruction controls. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple -fdump-tree-original\" } */\n-\n-prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-        ld_kernarg_u64 $d0, [%input_ptr];\n-        ld_global_b128 $q0, [$d0];\n-\n-\tadd_pp_u8x16 $q1, $q0, u8x16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n-\n-\t/* Broadcast the 15 as it's the lowest element (pos 0) in the resulting vector. */\n-\tadd_ps_u8x16 $q2, $q1, u8x16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n-\n-\t/* Broadcast the lowest element of q1. */\n-\tadd_sp_u8x16 $q3, $q1, $q2;\n-\n-\t/* Perform a scalar computation with the lowest element of both inputs and store it to the lowest element of dest. */\n-\tadd_ss_u8x16 $q4, $q2, $q3;\n-\n-\t/* Saturating arithmetics variations. */\n-\tadd_pp_sat_u8x16 $q5, $q4, u8x16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n-\n-\t/* Broadcast the 15 as it's the lowest element (pos 0) in the resulting vector. */\n-\tadd_ps_sat_u8x16 $q6, $q5, u8x16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n-\n-\t/* Broadcast the lowest element of q1. */\n-\tadd_sp_sat_u8x16 $q7, $q6, $q5;\n-\n-\t/* Perform a scalar computation with the lowest element of both inputs and store it to the lowest element of dest. */\n-\tadd_ss_sat_u8x16 $q8, $q7, $q6;\n-\n-\t/* Single operand vector computation. */\n-\tneg_p_s16x8 $q9, $q8;\n-\n-        ld_kernarg_u64 $d0, [%output_ptr];\n-        st_global_b128 $q8, [$d0];\n-\n-        ret;\n-};\n-\n-/* The b128 load is done using uint128_t*. */\n-/* { dg-final { scan-tree-dump \"q0 = VIEW_CONVERT_EXPR<uint128_t>\\\\\\(mem_read.\\[0-9\\]+\\\\\\);\" \"original\"} } */\n-\n-/* Before arithmetics, the uint128_t is casted to a vector datatype. */\n-/* { dg-final { scan-tree-dump \"<vector\\\\\\(16\\\\\\) unsigned char>\\\\\\(q0\\\\\\) \\\\\\+ \\\\\\{\" \"original\"} } */\n-\n-/* The u8x16 constant is generated to an array with elements in reverse order */\n-/* in comparison to the HSAIL syntax. */\n-/* { dg-final { scan-tree-dump \"\\\\\\+ { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }\" \"original\"} } */\n-\n-/* Broadcasted the constant vector's lowest element and summed it up in the next line. */\n-/* { dg-final { scan-tree-dump \"= { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 };\\[\\n \\]+\\[a-z0-9_\\]+ = \\[a-z0-9_\\]+ \\\\\\+ \\[a-z0-9_\\]+;\" \"gimple\"} } */\n-\n-/* Broadcasted the registers lowest element via a VEC_PERM_EXPR that has an all-zeros mask. */\n-/* { dg-final { scan-tree-dump \"VEC_PERM_EXPR <\\[a-z0-9_\\]+, \\[a-z0-9_\\]+, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }>;\" \"gimple\" } } */\n-\n-/* For the add_ss we assume performing the computation over the whole vector is cheaper than */\n-/* extracting the scalar and performing a scalar operation. This aims to stay in the vector\n-/* datapath as long as possible. */\n-/* { dg-final { scan-tree-dump \"new_output.\\[0-9\\]+ = q2 \\\\\\+ q3;\" \"gimple\" } } */\n-\n-/* Insert the lowest element of the result to the lowest element of the result register. */\n-/* { dg-final { scan-tree-dump \"= VEC_PERM_EXPR <new_output.\\[0-9\\]+, \\[a-z0-9_\\]+, { 0, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 }>;\" \"gimple\" } } */\n-\n-/* FIXME */\n-/* { dg-final { scan-tree-dump \"q4 = \\(VIEW_CONVERT_EXPR<uint128_t>\\\\\\()?s_output.\\[0-9\\]+\\(_\\[0-9\\]+\\)*\\\\\\)?;\" \"gimple\" } } */\n-\n-/* The saturating arithmetics are (curently) implemented using scalar builtin calls. */\n-/* { dg-final { scan-tree-dump-times \"= __builtin___hsail_sat_add_u8\" 64 \"gimple\" } } */\n-\n-/* A single operand vector instr (neg.) */\n-/* { dg-final { scan-tree-dump \"= VIEW_CONVERT_EXPR<vector\\\\\\(8\\\\\\) signed short>\\\\\\(\\(s_output.\\[0-9\\]+_\\[0-9\\]+|q8\\)\\\\\\);\\[\\n \\]+q9 = -_\\[0-9\\]+;\\[\\n \\]+\" \"gimple\" } } */"}, {"sha": "b20704b2caa6c50c64e40b269d405bb8bca8da4b", "filename": "gcc/testsuite/brig.dg/test/gimple/priv-array-offset-access.hsail", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpriv-array-offset-access.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpriv-array-offset-access.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpriv-array-offset-access.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,87 +0,0 @@\n-module &__llvm_hsail_module:1:0:$full:$large:$near;\n-\n-/* Regression test for a private array access case which used to assert.  */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n-\n-decl prog function &vec_sum()(\n-\targ_u32 %a,\n-\targ_u32 %b,\n-\targ_u32 %res,\n-\targ_u32 %N);\n-\n-prog function &vec_sum()(\n-\targ_u32 %a,\n-\targ_u32 %b,\n-\targ_u32 %res,\n-\targ_u32 %N)\n-{\n-\n-\tld_arg_align(4)_u32\t$s0, [%N];\n-\tld_arg_align(4)_u32\t$s1, [%res];\n-\tld_arg_align(4)_u32\t$s2, [%b];\n-\tld_arg_align(4)_u32\t$s3, [%a];\n-\tcmp_le_b1_s32\t$c0, $s0, 0;\n-\tcbr_b1\t$c0, @BB0_2;\n-@BB0_1:\n-\tld_private_align(4)_u32\t$s4, [$s3];\n-\tld_private_align(4)_u32\t$s5, [$s2];\n-\tadd_u32\t$s4, $s5, $s4;\n-\tst_private_align(4)_u32\t$s4, [$s1];\n-\tadd_u32\t$s1, $s1, 4;\n-\tadd_u32\t$s2, $s2, 4;\n-\tadd_u32\t$s3, $s3, 4;\n-\tadd_u32\t$s0, $s0, 4294967295;\n-\tcmp_ne_b1_s32\t$c0, $s0, 0;\n-\tcbr_b1\t$c0, @BB0_1;\n-@BB0_2:\n-\tret;\n-};\n-\n-prog kernel &test(\n-\tkernarg_u64 %in,\n-\tkernarg_u64 %out)\n-{\n-\n-\talign(4) private_u8 %__privateStack[1200];\n-\tmov_b64\t$d1, 0;\n-/* This used to crash when gcc asserts enabled:  */\n-\tlda_private_u32\t$s0, [%__privateStack][400];\n-\tlda_private_u32\t$s1, [%__privateStack];\n-\tld_kernarg_align(8)_width(all)_u64\t$d0, [%out];\n-\tld_kernarg_align(8)_width(all)_u64\t$d2, [%in];\n-@BB1_1:\n-\tadd_u64\t$d3, $d2, $d1;\n-\tld_global_align(4)_u32\t$s2, [$d3];\n-\tst_private_align(4)_u32\t$s2, [$s0];\n-\tst_private_align(4)_u32\t$s2, [$s1];\n-\tadd_u32\t$s1, $s1, 4;\n-\tadd_u32\t$s0, $s0, 4;\n-\tadd_u64\t$d1, $d1, 4;\n-\tcmp_ne_b1_s64\t$c0, $d1, 400;\n-\tcbr_b1\t$c0, @BB1_1;\n-\tmov_b32\t$s1, 0;\n-\tlda_private_u32\t$s0, [%__privateStack][800];\n-@BB1_3:\n-\tld_private_align(4)_u32\t$s2, [%__privateStack][$s1];\n-\tld_private_align(4)_u32\t$s3, [%__privateStack][$s1+400];\n-\tadd_u32\t$s2, $s3, $s2;\n-\tst_private_align(4)_u32\t$s2, [%__privateStack][$s1+800];\n-\tadd_u32\t$s1, $s1, 4;\n-\tcmp_ne_b1_s32\t$c0, $s1, 400;\n-\tcbr_b1\t$c0, @BB1_3;\n-\tmov_b64\t$d1, 0;\n-@BB1_5:\n-\tadd_u64\t$d2, $d0, $d1;\n-\tld_private_align(4)_u32\t$s1, [$s0];\n-\tst_global_align(4)_u32\t$s1, [$d2];\n-\tadd_u32\t$s0, $s0, 4;\n-\tadd_u64\t$d1, $d1, 4;\n-\tcmp_ne_b1_s64\t$c0, $d1, 400;\n-\tcbr_b1\t$c0, @BB1_5;\n-\tret;\n-};\n-\n-/* br @skip converted to a goto */\n-/* { dg-final { scan-tree-dump \"= \\\\\\(void \\\\\\*\\\\\\) priv_var_offset\" \"gimple\"} } */"}, {"sha": "6e2326391daad66f92af1765c77ccfe9b6f4a04d", "filename": "gcc/testsuite/brig.dg/test/gimple/smoke_test.hsail", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,91 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* A basic smoke test. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n-\n-prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-\tld_kernarg_u64 $d0, [%input_ptr];\n-\tld_global_u32 $s0, [$d0];\n-\tld_global_u32 $s1, [$d0 + 4];\n-\n-\tadd_u32 $s2, $s0, $s1;\n-\tadd_u32 $s3, $s0, 4294967295;\n-\n-\tld_kernarg_u64 $d0, [%output_ptr];\n-\tst_global_u32 $s2, [$d0];\n-\tst_global_u32 $s3, [$d0 + 4];\n-\n-\tret;\n-};\n-\n-prog kernel &KernelWithBarrier(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-\tld_kernarg_u64 $d0, [%input_ptr];\n-\tld_global_u32 $s0, [$d0];\n-\tld_global_u32 $s1, [$d0 + 4];\n-\n-\tadd_u32 $s2, $s0, $s1;\n-\n-\tbarrier_width(all);\n-\n-\tadd_u32 $s3, $s0, 4294967295;\n-\n-\tld_kernarg_u64 $d0, [%output_ptr];\n-\tst_global_u32 $s2, [$d0];\n-\tst_global_u32 $s3, [$d0 + 4];\n-\n-\tret;\n-};\n-\n-/* The kernel function itself should have a fingerprint as follows */\n-/* _Kernel (const unsigned char * restrict __args, void * restrict __context, unsigned char * restrict __group_base_addr, unsigned int __group_local_offset, unsigned char * restrict __private_base_addr) */\n-/* { dg-final { scan-tree-dump \"_Kernel \\\\\\(const unsigned char \\\\\\* restrict __args, void \\\\\\* restrict __context, unsigned char \\\\\\* restrict __group_base_addr, unsigned int __group_local_offset, unsigned char \\\\\\* restrict __private_base_addr\\\\\\)\" \"gimple\"} } */\n-\n-/* ld_kernarg: mem_read.0 = MEM[(unsigned long *)__args]; */\n-/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\] = MEM\\\\\\[\\\\\\(unsigned long \\\\\\*\\\\\\)__args\\\\\\];\" \"gimple\"} } */\n-\n-/* The latter ld_global_u32 should be visible as a pointer dereference (after pointer arithmetics on a temporary var): */\n-/* mem_read.2 = *D.1691; */\n-/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]+ = \\\\\\*\\[_0-9\\]+;\" \"gimple\"} } */\n-\n-/* add_u32s should generate +operators */\n-/* { dg-final { scan-tree-dump \"s2 = s0 \\\\\\+ s1;\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"s3 = s0 \\\\\\+ 4294967295;\" \"gimple\"} } */\n-\n-/* The latter st_global_u32 should be visible as a pointer dereference (after pointer arithmetics on a temporary var): */\n-/* *D.1694 = s3; */\n-/* { dg-final { scan-tree-dump \"\\\\\\*\\[_0-9\\]+ = s3;\" \"gimple\"} } */\n-\n-/* The return inside the kernel should be generated to a goto to the end of the kernel. */\n-/*  goto __kernel_exit; */\n-/*  __kernel_exit: */\n-/* { dg-final { scan-tree-dump \"goto __kernel_exit;\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"__kernel_exit:\" \"gimple\"} } */\n-\n-/* Expecting a work item loop because there are no barrier calls. */\n-/* { dg-final { scan-tree-dump \"if \\\\\\(__local_x < __cur_wg_size_x\\\\\\) goto __wi_loop_x; else goto\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"if \\\\\\(__local_y < __cur_wg_size_y\\\\\\) goto __wi_loop_y; else goto\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"if \\\\\\(__local_z < __cur_wg_size_z\\\\\\) goto __wi_loop_z; else goto\" \"gimple\"} } */\n-\n-/* The launcher should call __hsail_launch_wg_function in this case: */\n-/* Kernel (void * restrict __context, unsigned char * restrict __group_base_addr) */\n-/* { dg-final { scan-tree-dump \"Kernel \\\\\\(void \\\\\\* restrict __context, unsigned char \\\\\\* restrict __group_base_addr\\\\\\)\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"__hsail_launch_wg_function \\\\\\(_Kernel, __context, __group_base_addr, group_local_offset.*\\\\\\);\" \"gimple\"} }*/\n-\n-/* The kernel should have the magic metadata section injected to the ELF. */\n-/* TODO: this should be disabled in case not outputting to an ELF. */\n-/* Currently ELF is assumed by the brig frontend. Do not check for the context */\n-/* as it is likely to change. */\n-/* { dg-final { scan-tree-dump \"\\\\\\.pushsection phsa\\\\\\.desc\\\\\\.Kernel\" \"gimple\"} }*/\n-\n-/* The kernel with the barrier call should have the barrier builtin call in between the two summations. */\n-/* { dg-final { scan-tree-dump \"s2 = s0 \\\\\\+ s1;\\[\\n \\]+__builtin___hsail_barrier \\\\\\(__context\\\\\\);\\[\\n \\]+s3 = s0 \\\\\\+ 4294967295;\" \"gimple\"} } */\n-\n-/* The kernel with the barrier call's launcher function should call the thread-spawning function. */\n-/* { dg-final { scan-tree-dump \"__hsail_launch_kernel \\\\\\(_KernelWithBarrier, __context, __group_base_addr, group_local_offset.*\\\\\\);\" \"gimple\" } } */\n-\n-\n-"}, {"sha": "5fd96c1c7bd51c7e1f6e83f06db5bdd31af54b20", "filename": "gcc/testsuite/brig.dg/test/gimple/variables.hsail", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvariables.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvariables.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvariables.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,125 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* Tests for different variable scopes and address spaces. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple -fdump-tree-original\" } */\n-\n-prog align(256) private_u32 &prog_private;\n-private_u32 &mod_private;\n-\n-prog group_u32 &prog_group;\n-group_u32 &mod_group;\n-\n-prog global_u32 &prog_global;\n-global_u32 &mod_global;\n-\n-decl prog global_u32 &prog_global_host_def;\n-\n-prog readonly_u32 &prog_readonly;\n-readonly_u32 &mod_readonly;\n-\n-prog function &subfunction(arg_u32 %return_value)(arg_u32 %arg) {\n-\n-     private_u32 %func_private;\n-     group_u32 %func_group;\n-     align(256) global_u32 %func_global;\n-     readonly_u32 %func_readonly;\n-\n-     ld_private_u32 $s200, [%func_private];\n-     st_private_u32 $s200, [&prog_private];\n-\n-/* { dg-final { scan-tree-dump \"__group_base_addr \\\\\\+ \\\\\\(0 \\\\\\+\" \"original\" } } */\n-     ld_group_u32 $s203, [%func_group];\n-\n-/* { dg-final { scan-tree-dump \"__group_base_addr \\\\\\+ 0\" \"original\" } } */\n-     st_group_u32 $s203, [&prog_group];\n-\n-     ld_global_u32 $s204, [%func_global];\n-     st_global_u32 $s204, [&prog_global];\n-\n-     ld_readonly_u32 $s205, [%func_readonly];\n-     st_global_u32 $s205, [%func_global];\n-\n-     st_arg_u32 $s2, [%return_value];\n-     ret;\n-};\n-\n-prog kernel &kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-\tprivate_u32 %kern_private;\n-\tgroup_u32 %kern_group;\n-\tglobal_u32 %kern_global;\n-\treadonly_u32 %kern_readonly;\n-\n-        ld_kernarg_u64 $d0, [%input_ptr];\n-        ld_global_u32 $s0, [$d0];\n-\n-\tld_private_u32 $s2, [&prog_private];\n-\tst_private_u32 $s2, [%kern_private];\n-\tld_private_u32 $s3, [&mod_private];\n-\tst_private_u32 $s3, [&prog_private];\n-\n-\tld_group_u32 $s4, [&prog_group];\n-\tst_group_u32 $s4, [%kern_group];\n-\tld_group_u32 $s5, [&mod_group];\n-\tst_group_u32 $s5, [&prog_group];\n-\n-\tld_global_u32 $s6, [&prog_global];\n-\tst_global_u32 $s6, [%kern_global];\n-\tld_global_u32 $s7, [&mod_global];\n-\tst_global_u32 $s7, [&prog_global];\n-\n-\tld_readonly_u32 $s8, [&prog_readonly];\n-\tst_global_u32 $s8, [%kern_global];\n-\tld_readonly_u32 $s9, [&mod_readonly];\n-\tst_global_u32 $s9, [&prog_global];\n-\n-\tld_readonly_u32 $s10, [%kern_readonly];\n-\tst_global_u32 $s10, [%kern_global];\n-\tld_readonly_u32 $s11, [%kern_readonly];\n-\tst_global_u32 $s11, [&prog_global_host_def];\n-\n-\t{\n-\t\targ_u32 %arg;\n-\t\targ_u32 %return_value;\n-\t\tst_arg_u32 $s1, [%arg];\n-\t\tcall &subfunction(%return_value)(%arg);\n-\t\tld_arg_u32 $s1, [%return_value];\n-\t}\n-        ld_kernarg_u64 $d1, [%output_ptr];\n-        st_global_u32 $s1, [$d0];\n-};\n-\n-/* Private variable offsets assigned in the order of their appearance */\n-/*\n- prog_private @0\t(align 256) -> until 254 to ensure all WIs\n- mod_private  @256\t               have their chunks aligned\n- func_private @260\n- kern_private @264\n-*/\n-\n-/* Group variable offsets assigned in the order of their appearance */\n-/*\n- prog_group @0\t\t(2)\n- mod_group  @4\t\t(4)\n- func_group @8\t\t(1)\n- kern_group @12\t\t(3)\n-*/\n-\n-/* The \"mangling\" of the global and readonly vars. */\n-/* { dg-final { scan-tree-dump \"\\[ \\]*prog_global = s204;\" \"gimple\" } } */\n-\n-/* { dg-final { scan-tree-dump \"\\.module.mod_global;\" \"gimple\" } } */\n-\n-/* Host defined variables need indirect access as the address is\n-   known only at run time. */\n-/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\__phsa.host_def.prog_global_host_def.\\[0-9\\]+_\\[0-9\\]+ = s11;\" \"gimple\" } } */\n-\n-/* { dg-final { scan-tree-dump \"\\.subfunction.func_global;\" \"gimple\" } } */\n-/* { dg-final { scan-tree-dump \"\\.subfunction.func_readonly;\" \"gimple\" } } */\n-\n-/* { dg-final { scan-tree-dump \"kernel.kern_global\" \"gimple\" } } */\n-/* { dg-final { scan-tree-dump \"kernel.kern_readonly\" \"gimple\" } } */\n-\n-"}, {"sha": "752933395429f22e0fe225a618dee8f5d622b5fd", "filename": "gcc/testsuite/brig.dg/test/gimple/vector.hsail", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvector.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvector.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvector.hsail?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,57 +0,0 @@\n-module &module:1:0:$full:$large:$default;\n-\n-/* A test for vector operands. */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-original\" } */\n-\n-prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n-{\n-        ld_kernarg_u64 $d0, [%input_ptr];\n-\tld_v2_global_f32 ($s0, $s1), [$d0];\n-\tld_v3_global_f32 ($s2, $s3, $s4), [$d0 + 8];\n-\tld_v4_global_f32 ($s5, $s6, $s7, $s8), [$d0 + 20];\n-\n-\tadd_f32 $s9, $s0, $s1;\n-\tcombine_v2_b64_b32 $d2, ($s1, $s0);\n-\tcombine_v2_b64_b32 $d3, ($s2, $s3);\n-\n-\tadd_pp_f32x2 $d4, $d2, $d3;\n-\n-\texpand_v2_b32_b64 ($s0, $s3), $d4;\n-\n-        ld_kernarg_u64 $d1, [%output_ptr];\n-        st_v2_global_f32 ($s0, $s1), [$d1];\n-        st_v3_global_f32 ($s2, $s3, $s4), [$d1 + 8];\n-        st_v4_global_f32 ($s5, $s6, $s7, $s8), [$d1 + 20];\n-\n-        ret;\n-};\n-\n-/* The v2 load is done via casting to a vector datatype ptr. */\n-/* { dg-final { scan-tree-dump \" = MEM\\\\\\[\\\\\\(vector\\\\\\(2\\\\\\) <float:32> \\\\\\*\\\\\\)\" \"original\"} } */\n-\n-/* The v3 load is scalarized (at the moment) due to gcc requiring 2's exponent wide vectors. */\n-/* { dg-final { scan-tree-dump \"s0 = .*BIT_FIELD_REF <mem_read.\\[0-9\\]+, 32, 0>\\\\\\)?;\\[\\n ]+s1 = .*BIT_FIELD_REF <mem_read.\\[0-9\\]+, 32, 32>\\\\\\)?;\" \"original\"} } */\n-\n-/* The v4 load is done via casting to a vector datatype ptr. */\n-/* { dg-final { scan-tree-dump \" = MEM\\\\\\[\\\\\\(vector\\\\\\(4\\\\\\) <float:32> \\\\\\*\\\\\\)\" \"original\"} } */\n-\n-/* The combines are generated to vector constructors. */\n-/* { dg-final { scan-tree-dump \"{.*s1\\\\\\)?, .*s0\\\\\\)?}\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"{.*s2\\\\\\)?, .*s3\\\\\\)?}\" \"original\"} } */\n-\n-/* Expands to BIT_FIELD_REFs. */\n-/* { dg-final { scan-tree-dump \"s0 = \\(VIEW_CONVERT_EXPR.*\\\\\\(\\)?BIT_FIELD_REF <d4, 32, 0>\\\\\\)?;\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"s3 = \\(VIEW_CONVERT_EXPR.*\\\\\\(\\)?BIT_FIELD_REF <d4, 32, 32>\\\\\\)?;\" \"original\"} } */\n-\n-/* The v1 store is done via casting to a vector datatype ptr and constructing a vector from the inputs. */\n-/* { dg-final { scan-tree-dump \"MEM\\\\\\[\\\\\\(vector\\\\\\(2\\\\\\) <float:32> \\\\\\*\\\\\\)\\\\\\(<float:32> \\\\\\*\\\\\\) d1\\\\\\] = \" \"original\"} } */\n-\n-/* The v3 store is scalarized (at the moment) due to gcc requiring 2's exponent wide vectors. */\n-/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(\\\\\\(sizetype\\\\\\) d1 \\\\\\+ 8\\\\\\) \\\\\\+ 0 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s2\\\\\\);\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(\\\\\\(sizetype\\\\\\) d1 \\\\\\+ 8\\\\\\) \\\\\\+ 4 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s3\\\\\\);\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(\\\\\\(sizetype\\\\\\) d1 \\\\\\+ 8\\\\\\) \\\\\\+ 8 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s4\\\\\\);\" \"original\"} } */\n-\n-/* The v4 store is done via casting to a vector datatype and constructing a vector from the inputs. */\n-/* { dg-final { scan-tree-dump \"MEM\\\\\\[\\\\\\(vector\\\\\\(4\\\\\\) <float:32> \\\\\\*\\\\\\)\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(\\\\\\(sizetype\\\\\\) d1 \\\\\\+ 20\\\\\\)\\\\\\] = {VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s5\\\\\\), VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s6\\\\\\), VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s7\\\\\\), VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s8\\\\\\)};\" \"original\"} } */"}, {"sha": "415e3a17ecdbbbbf4b446239e7a80f40b8ee0ed5", "filename": "gcc/testsuite/gfortran.dg/goacc/pr78027.f90", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fpr78027.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900b1c27b963c8244c7547943d4a8d03dfacc6f4/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fpr78027.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fpr78027.f90?ref=900b1c27b963c8244c7547943d4a8d03dfacc6f4", "patch": "@@ -1,9 +1,5 @@\n ! { dg-additional-options \"-fopenmp -O2 -fdump-ipa-icf\" }\n \n-!     f951: warning: could not emit HSAIL for the function [-Whsa]\n-!     f951: note: HSA does not support functions with variadic arguments (or unknown return type): 'GOACC_parallel_keyed'\n-! { dg-additional-options \"-Wno-hsa\" }\n-\n real function f()\n    !$omp declare target(f)\n    f = 1."}, {"sha": "41c55f913013ffb2778eb9fb81d1f99a69532dd2", "filename": "gcc/testsuite/lib/brig-dg.exp", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Flib%2Fbrig-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Flib%2Fbrig-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fbrig-dg.exp?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,29 +0,0 @@\n-#   Copyright (C) 2009-2021 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-# \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-load_lib gcc-dg.exp\n-\n-# Define brig callbacks for dg.exp.\n-\n-proc brig-dg-test { prog do_what extra_tool_flags } {\n-    set result \\\n-\t[gcc-dg-test-1 brig_target_compile $prog $do_what $extra_tool_flags]\n-    \n-    set comp_output [lindex $result 0]\n-    set output_file [lindex $result 1]\n-\n-    return [list $comp_output $output_file]\n-}"}, {"sha": "d82cd884ad4982a8e380556bd834d46fd26bbcf8", "filename": "gcc/testsuite/lib/brig.exp", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Flib%2Fbrig.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e0fe7761da9255c9342788956c37b426875d872/gcc%2Ftestsuite%2Flib%2Fbrig.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fbrig.exp?ref=7e0fe7761da9255c9342788956c37b426875d872", "patch": "@@ -1,40 +0,0 @@\n-# Copyright (C) 2009-2021 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-load_lib prune.exp\n-load_lib gcc-defs.exp\n-load_lib timeout.exp\n-load_lib target-libpath.exp\n-#\n-# brig_target_compile -- compile a HSAIL input to BRIG using HSAILasm and then\n-#                        compile the BRIG to target ISA using gcc\n-\n-proc brig_target_compile { source dest type options } {\n-    global tmpdir\n-    global testname_with_flags\n-    if { [file extension $source] == \".hsail\" } {\n-\t# We cannot assume all inputs are .hsail as the dg machinery\n-\t# calls this for a some c files to check linker plugin support or\n-\t# similar.\n-\tset brig_source ${tmpdir}/[file rootname [file tail ${source}]].brig\n-\texec HSAILasm $source -o ${brig_source}\n-\tset source ${brig_source}\n-\t# Change the testname the .brig.\n-\tset testname_with_flags [file tail $source]\n-    }\n-    return [target_compile $source $dest $type $options]\n-}\n-"}]}