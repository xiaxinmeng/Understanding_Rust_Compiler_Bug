{"sha": "6ed825558ec5df100d84c284c52618ec397456a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVkODI1NTU4ZWM1ZGYxMDBkODRjMjg0YzUyNjE4ZWMzOTc0NTZhNQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2016-07-19T21:25:33Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2016-07-19T21:25:33Z"}, "message": "re PR fortran/71902 (Unneeded temporary on reallocatable character assignment)\n\n2016-07-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/71902\n\t* dependency.c (gfc_check_dependency): Use dep_ref.  Handle case\n\tif identical is true and two array element references differ.\n\t(gfc_dep_resovler):  Move most of the code to dep_ref.\n\t(dep_ref):  New function.\n\t* frontend-passes.c (realloc_string_callback):  Name temporary\n\tvariable \"realloc_string\".\n\n2016-07-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/71902\n\t* gfortran.dg/dependency_47.f90:  New test.\n\nFrom-SVN: r238497", "tree": {"sha": "118193899a3b655d59e43f384407b7a266f4249c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/118193899a3b655d59e43f384407b7a266f4249c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ed825558ec5df100d84c284c52618ec397456a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ed825558ec5df100d84c284c52618ec397456a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ed825558ec5df100d84c284c52618ec397456a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ed825558ec5df100d84c284c52618ec397456a5/comments", "author": null, "committer": null, "parents": [{"sha": "4833f5615ea56f73106ca8537d0a8b50463fd164", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4833f5615ea56f73106ca8537d0a8b50463fd164", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4833f5615ea56f73106ca8537d0a8b50463fd164"}], "stats": {"total": 111, "additions": 96, "deletions": 15}, "files": [{"sha": "2912fcb125e0e11d851edeffa9c6b96a433f412e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed825558ec5df100d84c284c52618ec397456a5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed825558ec5df100d84c284c52618ec397456a5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6ed825558ec5df100d84c284c52618ec397456a5", "patch": "@@ -1,3 +1,13 @@\n+2016-07-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/71902\n+\t* dependency.c (gfc_check_dependency): Use dep_ref.  Handle case\n+\tif identical is true and two array element references differ.\n+\t(gfc_dep_resovler):  Move most of the code to dep_ref.\n+\t(dep_ref):  New function.\n+\t* frontend-passes.c (realloc_string_callback):  Name temporary\n+\tvariable \"realloc_string\".\n+\n 2016-07-17  Fritz Reese  <fritzoreese@gmail.com>\n \n \tPR fortran/71523"}, {"sha": "a873dbe933ca3ba2053f7ff45b829f7fef2ebbc5", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 65, "deletions": 14, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed825558ec5df100d84c284c52618ec397456a5/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed825558ec5df100d84c284c52618ec397456a5/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=6ed825558ec5df100d84c284c52618ec397456a5", "patch": "@@ -54,6 +54,8 @@ enum gfc_dependency\n static gfc_dependency check_section_vs_section (gfc_array_ref *,\n \t\t\t\t\t\tgfc_array_ref *, int);\n \n+static gfc_dependency dep_ref (gfc_ref *, gfc_ref *, gfc_reverse *);\n+\n /* Returns 1 if the expr is an integer constant value 1, 0 if it is not or\n    def if the value could not be determined.  */\n \n@@ -1316,13 +1318,33 @@ gfc_check_dependency (gfc_expr *expr1, gfc_expr *expr2, bool identical)\n \t  return 0;\n \t}\n \n-      if (identical)\n-\treturn 1;\n-\n       /* Identical and disjoint ranges return 0,\n \t overlapping ranges return 1.  */\n       if (expr1->ref && expr2->ref)\n-\treturn gfc_dep_resolver (expr1->ref, expr2->ref, NULL);\n+\t{\n+\t  gfc_dependency dep;\n+\t  dep = dep_ref (expr1->ref, expr2->ref, NULL);\n+\t  switch (dep)\n+\t    {\n+\t    case GFC_DEP_EQUAL:\n+\t      return identical;\n+\n+\t    case GFC_DEP_FORWARD:\n+\t      return 0;\n+\n+\t    case GFC_DEP_BACKWARD:\n+\t      return 1;\n+\n+\t    case GFC_DEP_OVERLAP:\n+\t      return 1;\n+\n+\t    case GFC_DEP_NODEP:\n+\t      return 0;\n+\n+\t    default:\n+\t      gcc_unreachable();\n+\t    }\n+\t}\n \n       return 1;\n \n@@ -2052,10 +2074,38 @@ ref_same_as_full_array (gfc_ref *full_ref, gfc_ref *ref)\n    \t2 : array references are overlapping but reversal of one or\n \t    more dimensions will clear the dependency.\n    \t1 : array references are overlapping.\n-   \t0 : array references are identical or not overlapping.  */\n+   \t0 : array references are identical or can be handled in a forward loop.  */\n \n int\n gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n+{\n+  enum gfc_dependency dep;\n+  dep = dep_ref (lref, rref, reverse);\n+  switch (dep)\n+    {\n+    case GFC_DEP_EQUAL:\n+      return 0;\n+\n+    case GFC_DEP_FORWARD:\n+      return 0;\n+\n+    case GFC_DEP_BACKWARD:\n+      return 2;\n+\n+    case GFC_DEP_OVERLAP:\n+      return 1;\n+\n+    case GFC_DEP_NODEP:\n+      return 0;\n+\n+    default:\n+      gcc_unreachable();\n+    }\n+}\n+\n+\n+static gfc_dependency\n+dep_ref (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n {\n   int n;\n   int m;\n@@ -2079,21 +2129,22 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t  /* The two ranges can't overlap if they are from different\n \t     components.  */\n \t  if (lref->u.c.component != rref->u.c.component)\n-\t    return 0;\n+\t    return GFC_DEP_NODEP;\n \t  break;\n \n \tcase REF_SUBSTRING:\n \t  /* Substring overlaps are handled by the string assignment code\n \t     if there is not an underlying dependency.  */\n-\t  return (fin_dep == GFC_DEP_OVERLAP) ? 1 : 0;\n+\n+\t  return fin_dep == GFC_DEP_ERROR ? GFC_DEP_NODEP : fin_dep;\n \n \tcase REF_ARRAY:\n \n \t  if (ref_same_as_full_array (lref, rref))\n-\t    return 0;\n+\t    return GFC_DEP_EQUAL;\n \n \t  if (ref_same_as_full_array (rref, lref))\n-\t    return 0;\n+\t    return GFC_DEP_EQUAL;\n \n \t  if (lref->u.ar.dimen != rref->u.ar.dimen)\n \t    {\n@@ -2104,7 +2155,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t\tfin_dep = gfc_full_array_ref_p (lref, NULL) ? GFC_DEP_EQUAL\n \t\t\t\t\t\t\t    : GFC_DEP_OVERLAP;\n \t      else\n-\t\treturn 1;\n+\t\treturn GFC_DEP_OVERLAP;\n \t      break;\n \t    }\n \n@@ -2148,7 +2199,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \n \t      /* If any dimension doesn't overlap, we have no dependency.  */\n \t      if (this_dep == GFC_DEP_NODEP)\n-\t\treturn 0;\n+\t\treturn GFC_DEP_NODEP;\n \n \t      /* Now deal with the loop reversal logic:  This only works on\n \t\t ranges and is activated by setting\n@@ -2215,7 +2266,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t  /* Exactly matching and forward overlapping ranges don't cause a\n \t     dependency.  */\n \t  if (fin_dep < GFC_DEP_BACKWARD)\n-\t    return 0;\n+\t    return fin_dep == GFC_DEP_ERROR ? GFC_DEP_NODEP : fin_dep;\n \n \t  /* Keep checking.  We only have a dependency if\n \t     subsequent references also overlap.  */\n@@ -2233,7 +2284,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \n   /* Assume the worst if we nest to different depths.  */\n   if (lref || rref)\n-    return 1;\n+    return GFC_DEP_OVERLAP;\n \n-  return fin_dep == GFC_DEP_OVERLAP;\n+  return fin_dep;\n }"}, {"sha": "d4dee47ab75b14461bf367de05d065364561883b", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed825558ec5df100d84c284c52618ec397456a5/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed825558ec5df100d84c284c52618ec397456a5/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=6ed825558ec5df100d84c284c52618ec397456a5", "patch": "@@ -185,7 +185,7 @@ realloc_string_callback (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   current_code = c;\n   inserted_block = NULL;\n   changed_statement = NULL;\n-  n = create_var (expr2, \"trim\");\n+  n = create_var (expr2, \"realloc_string\");\n   co->expr2 = n;\n   return 0;\n }"}, {"sha": "47ca52628641a19e33f9a9c147420e9fc7deb078", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed825558ec5df100d84c284c52618ec397456a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed825558ec5df100d84c284c52618ec397456a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6ed825558ec5df100d84c284c52618ec397456a5", "patch": "@@ -1,3 +1,8 @@\n+2016-07-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/71902\n+\t* gfortran.dg/dependency_47.f90:  New test.\n+\n 2016-07-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/71916"}, {"sha": "eebc910766d7cc7e80f53183697dc037dbfe664b", "filename": "gcc/testsuite/gfortran.dg/dependency_47.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed825558ec5df100d84c284c52618ec397456a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_47.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed825558ec5df100d84c284c52618ec397456a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_47.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_47.f90?ref=6ed825558ec5df100d84c284c52618ec397456a5", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! Make sure there is only one instance of a temporary variable here.\n+! { dg-options \"-fdump-tree-original\" }\n+\n+SUBROUTINE prtdata(ilen)\n+  INTEGER :: ilen\n+  character(len=ilen), allocatable :: cline(:)\n+  allocate(cline(2))\n+  cline(1) = 'a'\n+  cline(1)(2:3) = cline(1)(1:2)\n+  cline(2) = cline(1)\n+  print *,c\n+END SUBROUTINE prtdata\n+! { dg-final { scan-tree-dump-not \"__var_2\" \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__var_1\" 3 \"original\" } }"}]}