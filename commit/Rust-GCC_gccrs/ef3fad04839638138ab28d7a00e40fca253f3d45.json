{"sha": "ef3fad04839638138ab28d7a00e40fca253f3d45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYzZmFkMDQ4Mzk2MzgxMzhhYjI4ZDdhMDBlNDBmY2EyNTNmM2Q0NQ==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-25T20:22:38Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-25T20:22:38Z"}, "message": "(extend_range, init_range): New functions.\n\n\t(write_units): Add blockage_function, blockage_range_function,\n\tmax_blockage and max_issue_delay fields to struct function_unit_desc.\n\tDrop max_busy_cost field.  Write #defines for min/max blockage,\n\tissue delay, multiplicity, and simultaneity and for BLOCKAGE_BITS\n\tand INSN_QUEUE_SIZE.\n\t(main): Compute the new values.\n\nFrom-SVN: r1950", "tree": {"sha": "fd13cf1738f09418ef19985b41d60ae8bc78fd02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd13cf1738f09418ef19985b41d60ae8bc78fd02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef3fad04839638138ab28d7a00e40fca253f3d45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3fad04839638138ab28d7a00e40fca253f3d45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3fad04839638138ab28d7a00e40fca253f3d45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3fad04839638138ab28d7a00e40fca253f3d45/comments", "author": null, "committer": null, "parents": [{"sha": "c376c05b38ddd5763372e1946f4705ec2437391a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c376c05b38ddd5763372e1946f4705ec2437391a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c376c05b38ddd5763372e1946f4705ec2437391a"}], "stats": {"total": 178, "additions": 147, "deletions": 31}, "files": [{"sha": "cf9bd3c468200b57e44ffa3e9f8193845bf68530", "filename": "gcc/genattr.c", "status": "modified", "additions": 147, "deletions": 31, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3fad04839638138ab28d7a00e40fca253f3d45/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3fad04839638138ab28d7a00e40fca253f3d45/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=ef3fad04839638138ab28d7a00e40fca253f3d45", "patch": "@@ -38,12 +38,46 @@ char *xmalloc ();\n static void fatal ();\n void fancy_abort ();\n \n-struct namelist\n+/* A range of values.  */\n+\n+struct range\n+{\n+  int min;\n+  int max;\n+};\n+\n+/* Record information about each function unit mentioned in a\n+   DEFINE_FUNCTION_UNIT.  */\n+\n+struct function_unit\n {\n-  struct namelist *next;\n-  char *name;\n+  char *name;\t\t\t/* Function unit name.  */\n+  struct function_unit *next;\t/* Next function unit.  */\n+  int multiplicity;\t\t/* Number of units of this type.  */\n+  int simultaneity;\t\t/* Maximum number of simultaneous insns\n+\t\t\t\t   on this function unit or 0 if unlimited.  */\n+  struct range ready_cost;\t/* Range of ready cost values.  */\n+  struct range issue_delay;\t/* Range of issue delay values.  */\n };\n \n+static void\n+extend_range (range, min, max)\n+     struct range *range;\n+     int min;\n+     int max;\n+{\n+  if (range->min > min) range->min = min;\n+  if (range->max < max) range->max = max;\n+}\n+\n+static void\n+init_range (range)\n+     struct range *range;\n+{\n+  range->min = 100000;\n+  range->max = -1;\n+}\n+\n static void\n write_upcase (str)\n     char *str;\n@@ -106,9 +140,17 @@ gen_attr (attr)\n }\n \n static void\n-write_units (num_units, min_ready_cost, max_ready_cost,\n-\t     min_busy_delay, max_busy_delay)\n+write_units (num_units, multiplicity, simultaneity,\n+\t     ready_cost, issue_delay, blockage)\n+     int num_units;\n+     struct range *multiplicity;\n+     struct range *simultaneity;\n+     struct range *ready_cost;\n+     struct range *issue_delay;\n+     struct range *blockage;\n {\n+  int i, q_size;\n+\n   printf (\"#define INSN_SCHEDULING\\n\\n\");\n   printf (\"extern int result_ready_cost ();\\n\");\n   printf (\"extern int function_units_used ();\\n\\n\");\n@@ -119,15 +161,34 @@ write_units (num_units, min_ready_cost, max_ready_cost,\n   printf (\"  int multiplicity;\\n\");\n   printf (\"  int simultaneity;\\n\");\n   printf (\"  int default_cost;\\n\");\n-  printf (\"  int max_busy_cost;\\n\");\n+  printf (\"  int max_issue_delay;\\n\");\n   printf (\"  int (*ready_cost_function) ();\\n\");\n   printf (\"  int (*conflict_cost_function) ();\\n\");\n+  printf (\"  int max_blockage;\\n\");\n+  printf (\"  unsigned int (*blockage_range_function) ();\\n\");\n+  printf (\"  int (*blockage_function) ();\\n\");\n   printf (\"} function_units[];\\n\\n\");\n   printf (\"#define FUNCTION_UNITS_SIZE %d\\n\", num_units);\n-  printf (\"#define MIN_READY_COST %d\\n\", min_ready_cost);\n-  printf (\"#define MAX_READY_COST %d\\n\", max_ready_cost);\n-  printf (\"#define MIN_BUSY_DELAY %d\\n\", min_busy_delay);\n-  printf (\"#define MAX_BUSY_DELAY %d\\n\\n\", max_busy_delay);\n+  printf (\"#define MIN_MULTIPLICITY %d\\n\", multiplicity->min);\n+  printf (\"#define MAX_MULTIPLICITY %d\\n\", multiplicity->max);\n+  printf (\"#define MIN_SIMULTANEITY %d\\n\", simultaneity->min);\n+  printf (\"#define MAX_SIMULTANEITY %d\\n\", simultaneity->max);\n+  printf (\"#define MIN_READY_COST %d\\n\", ready_cost->min);\n+  printf (\"#define MAX_READY_COST %d\\n\", ready_cost->max);\n+  printf (\"#define MIN_ISSUE_DELAY %d\\n\", issue_delay->min);\n+  printf (\"#define MAX_ISSUE_DELAY %d\\n\", issue_delay->max);\n+  printf (\"#define MIN_BLOCKAGE %d\\n\", blockage->min);\n+  printf (\"#define MAX_BLOCKAGE %d\\n\", blockage->max);\n+  for (i = 0; (1 << i) < blockage->max; i++)\n+    ;\n+  printf (\"#define BLOCKAGE_BITS %d\\n\", i + 1);\n+\n+  /* INSN_QUEUE_SIZE is a power of two larger than MAX_BLOCKAGE and\n+     MAX_READY_COST.  This is the longest time an isnsn may be queued.  */\n+  i = MAX (blockage->max, ready_cost->max);\n+  for (q_size = 1; q_size <= i; q_size <<= 1)\n+    ;\n+  printf (\"#define INSN_QUEUE_SIZE %d\\n\", q_size);\n }\n \n char *\n@@ -182,13 +243,18 @@ main (argc, argv)\n   int have_delay = 0;\n   int have_annul_true = 0;\n   int have_annul_false = 0;\n-  int have_units = 0;\n   int num_units = 0;\n-  int min_ready_cost = 100000, max_ready_cost = -1;\n-  int min_busy_delay = 100000, max_busy_delay = -1;\n-  struct namelist *units = 0;\n+  struct range all_simultaneity, all_multiplicity;\n+  struct range all_ready_cost, all_issue_delay, all_blockage;\n+  struct function_unit *units = 0, *unit;\n   int i;\n \n+  init_range (&all_multiplicity);\n+  init_range (&all_simultaneity);\n+  init_range (&all_ready_cost);\n+  init_range (&all_issue_delay);\n+  init_range (&all_blockage);\n+\n   obstack_init (rtl_obstack);\n \n   if (argc <= 1)\n@@ -255,40 +321,90 @@ from the machine description file `md'.  */\\n\\n\");\n \n       else if (GET_CODE (desc) == DEFINE_FUNCTION_UNIT)\n \t{\n-\t  struct namelist *unit;\n \t  char *name = XSTR (desc, 0);\n-\t  int ready_cost = XINT (desc, 4);\n-\t  int busy_delay = XINT (desc, 5);\n-\n-\t  have_units = 1;\n-\t  if (min_ready_cost > ready_cost) min_ready_cost = ready_cost;\n-\t  if (max_ready_cost < ready_cost) max_ready_cost = ready_cost;\n-\t  if (min_busy_delay > busy_delay) min_busy_delay = busy_delay;\n-\t  if (max_busy_delay < busy_delay) max_busy_delay = busy_delay;\n-\n-\t  /* If the optional conflict vector was specified, the busy delay\n-\t     may be zero.  */\n-\t  if (XVEC (desc, 6) != 0) min_busy_delay = 0;\n+\t  int multiplicity = XINT (desc, 1);\n+\t  int simultaneity = XINT (desc, 2);\n+\t  int ready_cost = MAX (XINT (desc, 4), 1);\n+\t  int issue_delay = MAX (XINT (desc, 5), 1);\n+\t  int issueexp_p = (XVEC (desc, 6) != 0);\n \n \t  for (unit = units; unit; unit = unit->next)\n \t    if (strcmp (unit->name, name) == 0)\n \t      break;\n+\n \t  if (unit == 0)\n \t    {\n \t      int len = strlen (name) + 1;\n-\t      unit = (struct namelist *) alloca (sizeof (struct namelist));\n+\t      unit = (struct function_unit *)\n+\t\talloca (sizeof (struct function_unit));\n \t      unit->name = (char *) alloca (len);\n \t      bcopy (name, unit->name, len);\n+\t      unit->multiplicity = multiplicity;\n+\t      unit->simultaneity = simultaneity;\n+\t      unit->ready_cost.min = unit->ready_cost.max = ready_cost;\n+\t      unit->issue_delay.min = unit->issue_delay.max = issue_delay;\n \t      unit->next = units;\n \t      units = unit;\n \t      num_units++;\n+\n+\t      extend_range (&all_multiplicity, multiplicity, multiplicity);\n+\t      extend_range (&all_simultaneity, simultaneity, simultaneity);\n \t    }\n+\t  else if (unit->multiplicity != multiplicity\n+\t\t   || unit->simultaneity != simultaneity)\n+\t    fatal (\"Differing specifications given for `%s' function unit.\",\n+\t\t   unit->name);\n+\n+\t  extend_range (&unit->ready_cost, ready_cost, ready_cost);\n+\t  extend_range (&unit->issue_delay,\n+\t\t\tissueexp_p ? 1 : issue_delay, issue_delay);\n+\t  extend_range (&all_ready_cost,\n+\t\t\tunit->ready_cost.min, unit->ready_cost.max);\n+\t  extend_range (&all_issue_delay,\n+\t\t\tunit->issue_delay.min, unit->issue_delay.max);\n \t}\n     }\n \n-  if (have_units)\n-    write_units (num_units, min_ready_cost, max_ready_cost,\n-\t\t min_busy_delay, max_busy_delay);\n+  if (num_units > 0)\n+    {\n+      /* Compute the range of blockage cost values.  See genattrtab.c\n+\t for the derivation.  BLOCKAGE (E,C) when SIMULTANEITY is zero is\n+\n+\t     MAX (ISSUE-DELAY (E,C),\n+\t\t  READY-COST (E) - (READY-COST (C) - 1))\n+\n+\t and otherwise\n+\n+\t     MAX (ISSUE-DELAY (E,C),\n+\t\t  READY-COST (E) - (READY-COST (C) - 1),\n+\t\t  READY-COST (E) - FILL-TIME)  */\n+\n+      for (unit = units; unit; unit = unit->next)\n+\t{\n+\t  struct range blockage;\n+\t  int max_issue_time = MAX (unit->issue_delay.max, 1);\n+\n+\t  blockage = unit->issue_delay;\n+\t  blockage.max = MAX (unit->ready_cost.max\n+\t\t\t      - (unit->ready_cost.min - 1),\n+\t\t\t      blockage.max);\n+\t  blockage.min = MAX (1, blockage.min);\n+\n+\t  if (unit->simultaneity != 0)\n+\t    {\n+\t      int fill_time = ((unit->simultaneity - 1)\n+\t\t\t       * unit->issue_delay.min);\n+\t      blockage.min = MAX (unit->ready_cost.min - fill_time,\n+\t\t\t\t  blockage.min);\n+\t      blockage.max = MAX (unit->ready_cost.max - fill_time,\n+\t\t\t\t  blockage.max);\n+\t    }\n+\t  extend_range (&all_blockage, blockage.min, blockage.max);\n+\t}\n+\n+      write_units (num_units, &all_multiplicity, &all_simultaneity,\n+\t\t   &all_ready_cost, &all_issue_delay, &all_blockage);\n+    }\n \n   fflush (stdout);\n   exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);"}]}