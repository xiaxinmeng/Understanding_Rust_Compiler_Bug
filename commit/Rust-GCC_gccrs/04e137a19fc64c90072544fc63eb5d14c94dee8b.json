{"sha": "04e137a19fc64c90072544fc63eb5d14c94dee8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRlMTM3YTE5ZmM2NGM5MDA3MjU0NGZjNjNlYjVkMTRjOTRkZWU4Yg==", "commit": {"author": {"name": "David Wohlferd", "email": "LimeGreenSocks@yahoo.com", "date": "2014-05-09T12:15:41Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2014-05-09T12:15:41Z"}, "message": "014-05-09 David Wohlferd <LimeGreenSocks@yahoo.com> Andrew Haley...\n\n014-05-09  David Wohlferd <LimeGreenSocks@yahoo.com>\n\tAndrew Haley <aph@redhat.com>\n\tRichard Sandiford <rdsandiford@googlemail.com>\n\n\t* doc/extend.texi: Rewrite inline asm page / re-org asm-related\n\tpages.\n\nFrom-SVN: r210273", "tree": {"sha": "eef9a67d2260239c415500247eadad9eba64a5a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eef9a67d2260239c415500247eadad9eba64a5a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04e137a19fc64c90072544fc63eb5d14c94dee8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04e137a19fc64c90072544fc63eb5d14c94dee8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04e137a19fc64c90072544fc63eb5d14c94dee8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04e137a19fc64c90072544fc63eb5d14c94dee8b/comments", "author": null, "committer": null, "parents": [{"sha": "c204f1b5471d9b9b91728c6f9befd878cc015257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c204f1b5471d9b9b91728c6f9befd878cc015257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c204f1b5471d9b9b91728c6f9befd878cc015257"}], "stats": {"total": 1373, "additions": 933, "deletions": 440}, "files": [{"sha": "897c5628d932a5bae4e097e919c189ed33f785a4", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 933, "deletions": 440, "changes": 1373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04e137a19fc64c90072544fc63eb5d14c94dee8b/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04e137a19fc64c90072544fc63eb5d14c94dee8b/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=04e137a19fc64c90072544fc63eb5d14c94dee8b", "patch": "@@ -65,11 +65,7 @@ extensions, accepted by GCC in C90 mode and in C++.\n * Alignment::           Inquiring about the alignment of a type or variable.\n * Inline::              Defining inline functions (as fast as macros).\n * Volatiles::           What constitutes an access to a volatile object.\n-* Extended Asm::        Assembler instructions with C expressions as operands.\n-                        (With them you can define ``built-in'' functions.)\n-* Constraints::         Constraints for asm operands\n-* Asm Labels::          Specifying the assembler name to use for a C symbol.\n-* Explicit Reg Vars::   Defining variables residing in specified registers.\n+* Using Assembly Language with C:: Instructions and extensions for interfacing C with assembler.\n * Alternate Keywords::  @code{__const__}, @code{__asm__}, etc., for header files.\n * Incomplete Enums::    @code{enum foo;}, with details to follow.\n * Function Names::      Printable strings which are the name of the current\n@@ -6137,491 +6133,948 @@ bit-fields are only partially accessed, if they straddle a storage unit\n boundary.  For these reasons it is unwise to use volatile bit-fields to\n access hardware.\n \n+@node Using Assembly Language with C\n+@section How to Use Inline Assembly Language in C Code\n+\n+GCC provides various extensions that allow you to embed assembler within \n+C code.\n+\n+@menu\n+* Basic Asm::          Inline assembler with no operands.\n+* Extended Asm::       Inline assembler with operands.\n+* Constraints::        Constraints for @code{asm} operands\n+* Asm Labels::         Specifying the assembler name to use for a C symbol.\n+* Explicit Reg Vars::  Defining variables residing in specified registers.\n+* Size of an asm::     How GCC calculates the size of an @code{asm} block.\n+@end menu\n+\n+@node Basic Asm\n+@subsection Basic Asm --- Assembler Instructions with No Operands\n+@cindex basic @code{asm}\n+\n+The @code{asm} keyword allows you to embed assembler instructions within \n+C code.\n+\n+@example\n+asm [ volatile ] ( AssemblerInstructions )\n+@end example\n+\n+To create headers compatible with ISO C, write @code{__asm__} instead of \n+@code{asm} (@pxref{Alternate Keywords}).\n+\n+By definition, a Basic @code{asm} statement is one with no operands. \n+@code{asm} statements that contain one or more colons (used to delineate \n+operands) are considered to be Extended (for example, @code{asm(\"int $3\")} \n+is Basic, and @code{asm(\"int $3\" : )} is Extended). @xref{Extended Asm}.\n+\n+@subsubheading Qualifiers\n+@emph{volatile}\n+@*\n+This optional qualifier has no effect. All Basic @code{asm} blocks are \n+implicitly volatile.\n+\n+@subsubheading Parameters\n+@emph{AssemblerInstructions}\n+@*\n+This is a literal string that specifies the assembler code. The string can \n+contain any instructions recognized by the assembler, including directives. \n+GCC does not parse the assembler instructions themselves and \n+does not know what they mean or even whether they are valid assembler input. \n+The compiler copies it verbatim to the assembly language output file, without \n+processing dialects or any of the \"%\" operators that are available with\n+Extended @code{asm}. This results in minor differences between Basic \n+@code{asm} strings and Extended @code{asm} templates. For example, to refer to \n+registers you might use %%eax in Extended @code{asm} and %eax in Basic \n+@code{asm}.\n+\n+You may place multiple assembler instructions together in a single @code{asm} \n+string, separated by the characters normally used in assembly code for the \n+system. A combination that works in most places is a newline to break the \n+line, plus a tab character (written as \"\\n\\t\").\n+Some assemblers allow semicolons as a line separator. However, \n+note that some assembler dialects use semicolons to start a comment. \n+\n+Do not expect a sequence of @code{asm} statements to remain perfectly \n+consecutive after compilation. If certain instructions need to remain \n+consecutive in the output, put them in a single multi-instruction asm \n+statement. Note that GCC's optimizers can move @code{asm} statements \n+relative to other code, including across jumps.\n+\n+@code{asm} statements may not perform jumps into other @code{asm} statements. \n+GCC does not know about these jumps, and therefore cannot take \n+account of them when deciding how to optimize. Jumps from @code{asm} to C \n+labels are only supported in Extended @code{asm}.\n+\n+@subsubheading Remarks\n+Using Extended @code{asm} will typically produce smaller, safer, and more \n+efficient code, and in most cases it is a better solution. When writing \n+inline assembly language outside of C functions, however, you must use Basic \n+@code{asm}. Extended @code{asm} statements have to be inside a C function.\n+\n+Under certain circumstances, GCC may duplicate (or remove duplicates of) your \n+assembly code when optimizing. This can lead to unexpected duplicate \n+symbol errors during compilation if your assembly code defines symbols or \n+labels.\n+\n+Safely accessing C data and calling functions from Basic @code{asm} is more \n+complex than it may appear. To access C data, it is better to use Extended \n+@code{asm}.\n+\n+Since GCC does not parse the AssemblerInstructions, it has no \n+visibility of any symbols it references. This may result in GCC discarding \n+those symbols as unreferenced.\n+\n+Unlike Extended @code{asm}, all Basic @code{asm} blocks are implicitly \n+volatile. @xref{Volatile}.  Similarly, Basic @code{asm} blocks are not treated \n+as though they used a \"memory\" clobber (@pxref{Clobbers}).\n+\n+All Basic @code{asm} blocks use the assembler dialect specified by the \n+@option{-masm} command-line option. Basic @code{asm} provides no\n+mechanism to provide different assembler strings for different dialects.\n+\n+Here is an example of Basic @code{asm} for i386:\n+\n+@example\n+/* Note that this code will not compile with -masm=intel */\n+#define DebugBreak() asm(\"int $3\")\n+@end example\n+\n @node Extended Asm\n-@section Assembler Instructions with C Expression Operands\n+@subsection Extended Asm - Assembler Instructions with C Expression Operands\n+@cindex @code{asm} keyword\n @cindex extended @code{asm}\n-@cindex @code{asm} expressions\n @cindex assembler instructions\n-@cindex registers\n \n-In an assembler instruction using @code{asm}, you can specify the\n-operands of the instruction using C expressions.  This means you need not\n-guess which registers or memory locations contain the data you want\n-to use.\n+The @code{asm} keyword allows you to embed assembler instructions within C \n+code. With Extended @code{asm} you can read and write C variables from \n+assembler and perform jumps from assembler code to C labels.\n \n-You must specify an assembler instruction template much like what\n-appears in a machine description, plus an operand constraint string for\n-each operand.\n+@example\n+@ifhtml\n+asm [volatile] ( AssemblerTemplate : [OutputOperands] [ : [InputOperands] [ : [Clobbers] ] ] )\n+\n+asm [volatile] goto ( AssemblerTemplate : : [InputOperands] : [Clobbers] : GotoLabels )\n+@end ifhtml\n+@ifnothtml\n+asm [volatile] ( AssemblerTemplate \n+                 : [OutputOperands] \n+                 [ : [InputOperands] \n+                 [ : [Clobbers] ] ])\n+\n+asm [volatile] goto ( AssemblerTemplate \n+                      : \n+                      : [InputOperands] \n+                      : [Clobbers] \n+                      : GotoLabels)\n+@end ifnothtml\n+@end example\n \n-For example, here is how to use the 68881's @code{fsinx} instruction:\n+To create headers compatible with ISO C, write @code{__asm__} instead of \n+@code{asm} and @code{__volatile__} instead of @code{volatile} \n+(@pxref{Alternate Keywords}). There is no alternate for @code{goto}.\n+\n+By definition, Extended @code{asm} is an @code{asm} statement that contains \n+operands. To separate the classes of operands, you use colons. Basic \n+@code{asm} statements contain no colons. (So, for example, \n+@code{asm(\"int $3\")} is Basic @code{asm}, and @code{asm(\"int $3\" : )} is \n+Extended @code{asm}. @pxref{Basic Asm}.)\n+\n+@subsubheading Qualifiers\n+@emph{volatile}\n+@*\n+The typical use of Extended @code{asm} statements is to manipulate input \n+values to produce output values. However, your @code{asm} statements may \n+also produce side effects. If so, you may need to use the @code{volatile} \n+qualifier to disable certain optimizations. @xref{Volatile}.\n+\n+@emph{goto}\n+@*\n+This qualifier informs the compiler that the @code{asm} statement may \n+perform a jump to one of the labels listed in the GotoLabels section. \n+@xref{GotoLabels}.\n+\n+@subsubheading Parameters\n+@emph{AssemblerTemplate}\n+@*\n+This is a literal string that contains the assembler code. It is a \n+combination of fixed text and tokens that refer to the input, output, \n+and goto parameters. @xref{AssemblerTemplate}.\n+\n+@emph{OutputOperands}\n+@*\n+A comma-separated list of the C variables modified by the instructions in the \n+AssemblerTemplate. @xref{OutputOperands}.\n+\n+@emph{InputOperands}\n+@*\n+A comma-separated list of C expressions read by the instructions in the \n+AssemblerTemplate. @xref{InputOperands}.\n+\n+@emph{Clobbers}\n+@*\n+A comma-separated list of registers or other values changed by the \n+AssemblerTemplate, beyond those listed as outputs. @xref{Clobbers}.\n+\n+@emph{GotoLabels}\n+@*\n+When you are using the @code{goto} form of @code{asm}, this section contains \n+the list of all C labels to which the AssemblerTemplate may jump. \n+@xref{GotoLabels}.\n+\n+@subsubheading Remarks\n+The @code{asm} statement allows you to include assembly instructions directly \n+within C code. This may help you to maximize performance in time-sensitive \n+code or to access assembly instructions that are not readily available to C \n+programs.\n+\n+Note that Extended @code{asm} statements must be inside a function. Only \n+Basic @code{asm} may be outside functions (@pxref{Basic Asm}).\n+\n+While the uses of @code{asm} are many and varied, it may help to think of an \n+@code{asm} statement as a series of low-level instructions that convert input \n+parameters to output parameters. So a simple (if not particularly useful) \n+example for i386 using @code{asm} might look like this:\n \n-@smallexample\n-asm (\"fsinx %1,%0\" : \"=f\" (result) : \"f\" (angle));\n-@end smallexample\n+@example\n+int src = 1;\n+int dst;   \n \n-@noindent\n-Here @code{angle} is the C expression for the input operand while\n-@code{result} is that of the output operand.  Each has @samp{\"f\"} as its\n-operand constraint, saying that a floating-point register is required.\n-The @samp{=} in @samp{=f} indicates that the operand is an output; all\n-output operands' constraints must use @samp{=}.  The constraints use the\n-same language used in the machine description (@pxref{Constraints}).\n-\n-Each operand is described by an operand-constraint string followed by\n-the C expression in parentheses.  A colon separates the assembler\n-template from the first output operand and another separates the last\n-output operand from the first input, if any.  Commas separate the\n-operands within each group.  The total number of operands is currently\n-limited to 30; this limitation may be lifted in some future version of\n-GCC@.\n-\n-If there are no output operands but there are input operands, you must\n-place two consecutive colons surrounding the place where the output\n-operands would go.\n-\n-As of GCC version 3.1, it is also possible to specify input and output\n-operands using symbolic names which can be referenced within the\n-assembler code.  These names are specified inside square brackets\n-preceding the constraint string, and can be referenced inside the\n-assembler code using @code{%[@var{name}]} instead of a percentage sign\n-followed by the operand number.  Using named operands the above example\n-could look like:\n-\n-@smallexample\n-asm (\"fsinx %[angle],%[output]\"\n-     : [output] \"=f\" (result)\n-     : [angle] \"f\" (angle));\n-@end smallexample\n+asm (\"mov %1, %0\\n\\t\"\n+    \"add $1, %0\"\n+    : \"=r\" (dst) \n+    : \"r\" (src));\n \n-@noindent\n-Note that the symbolic operand names have no relation whatsoever to\n-other C identifiers.  You may use any name you like, even those of\n-existing C symbols, but you must ensure that no two operands within the same\n-assembler construct use the same symbolic name.\n-\n-Output operand expressions must be lvalues; the compiler can check this.\n-The input operands need not be lvalues.  The compiler cannot check\n-whether the operands have data types that are reasonable for the\n-instruction being executed.  It does not parse the assembler instruction\n-template and does not know what it means or even whether it is valid\n-assembler input.  The extended @code{asm} feature is most often used for\n-machine instructions the compiler itself does not know exist.  If\n-the output expression cannot be directly addressed (for example, it is a\n-bit-field), your constraint must allow a register.  In that case, GCC\n-uses the register as the output of the @code{asm}, and then stores\n-that register into the output.\n-\n-The ordinary output operands must be write-only; GCC assumes that\n-the values in these operands before the instruction are dead and need\n-not be generated.  Extended asm supports input-output or read-write\n-operands.  Use the constraint character @samp{+} to indicate such an\n-operand and list it with the output operands.\n-\n-You may, as an alternative, logically split its function into two\n-separate operands, one input operand and one write-only output\n-operand.  The connection between them is expressed by constraints\n-that say they need to be in the same location when the instruction\n-executes.  You can use the same C expression for both operands, or\n-different expressions.  For example, here we write the (fictitious)\n-@samp{combine} instruction with @code{bar} as its read-only source\n-operand and @code{foo} as its read-write destination:\n-\n-@smallexample\n-asm (\"combine %2,%0\" : \"=r\" (foo) : \"0\" (foo), \"g\" (bar));\n-@end smallexample\n+printf(\"%d\\n\", dst);\n+@end example\n \n-@noindent\n-The constraint @samp{\"0\"} for operand 1 says that it must occupy the\n-same location as operand 0.  A number in constraint is allowed only in\n-an input operand and it must refer to an output operand.\n+This code will copy @var{src} to @var{dst} and add 1 to @var{dst}.\n \n-Only a number in the constraint can guarantee that one operand is in\n-the same place as another.  The mere fact that @code{foo} is the value\n-of both operands is not enough to guarantee that they are in the\n-same place in the generated assembler code.  The following does not\n-work reliably:\n+@anchor{Volatile}\n+@subsubsection Volatile\n+@cindex volatile @code{asm}\n+@cindex @code{asm} volatile\n \n-@smallexample\n-asm (\"combine %2,%0\" : \"=r\" (foo) : \"r\" (foo), \"g\" (bar));\n-@end smallexample\n+GCC's optimizers sometimes discard @code{asm} statements if they determine \n+there is no need for the output variables. Also, the optimizers may move \n+code out of loops if they believe that the code will always return the same \n+result (i.e. none of its input values change between calls). Using the \n+@code{volatile} qualifier disables these optimizations. @code{asm} statements \n+that have no output operands are implicitly volatile.\n \n-Various optimizations or reloading could cause operands 0 and 1 to be in\n-different registers; GCC knows no reason not to do so.  For example, the\n-compiler might find a copy of the value of @code{foo} in one register and\n-use it for operand 1, but generate the output operand 0 in a different\n-register (copying it afterward to @code{foo}'s own address).  Of course,\n-since the register for operand 1 is not even mentioned in the assembler\n-code, the result will not work, but GCC can't tell that.\n+Examples:\n \n-As of GCC version 3.1, one may write @code{[@var{name}]} instead of\n-the operand number for a matching constraint.  For example:\n+This i386 code demonstrates a case that does not use (or require) the \n+@code{volatile} qualifier. If it is performing assertion checking, this code \n+uses @code{asm} to perform the validation. Otherwise, @var{dwRes} is \n+unreferenced by any code. As a result, the optimizers can discard the \n+@code{asm} statement, which in turn removes the need for the entire \n+@code{DoCheck} routine. By omitting the @code{volatile} qualifier when it \n+isn't needed you allow the optimizers to produce the most efficient code \n+possible.\n \n-@smallexample\n-asm (\"cmoveq %1,%2,%[result]\"\n-     : [result] \"=r\"(result)\n-     : \"r\" (test), \"r\"(new), \"[result]\"(old));\n-@end smallexample\n+@example\n+void DoCheck(uint32_t dwSomeValue)\n+@{\n+   uint32_t dwRes;\n \n-Sometimes you need to make an @code{asm} operand be a specific register,\n-but there's no matching constraint letter for that register @emph{by\n-itself}.  To force the operand into that register, use a local variable\n-for the operand and specify the register in the variable declaration.\n-@xref{Explicit Reg Vars}.  Then for the @code{asm} operand, use any\n-register constraint letter that matches the register:\n+   // Assumes dwSomeValue is not zero.\n+   asm (\"bsfl %1,%0\"\n+     : \"=r\" (dwRes)\n+     : \"r\" (dwSomeValue)\n+     : \"cc\");\n \n-@smallexample\n-register int *p1 asm (\"r0\") = @dots{};\n-register int *p2 asm (\"r1\") = @dots{};\n-register int *result asm (\"r0\");\n-asm (\"sysint\" : \"=r\" (result) : \"0\" (p1), \"r\" (p2));\n-@end smallexample\n+   assert(dwRes > 3);\n+@}\n+@end example\n \n-@anchor{Example of asm with clobbered asm reg}\n-In the above example, beware that a register that is call-clobbered by\n-the target ABI will be overwritten by any function call in the\n-assignment, including library calls for arithmetic operators.\n-Also a register may be clobbered when generating some operations,\n-like variable shift, memory copy or memory move on x86.\n-Assuming it is a call-clobbered register, this may happen to @code{r0}\n-above by the assignment to @code{p2}.  If you have to use such a\n-register, use temporary variables for expressions between the register\n-assignment and use:\n+The next example shows a case where the optimizers can recognize that the input \n+(@var{dwSomeValue}) never changes during the execution of the function and can \n+therefore move the @code{asm} outside the loop to produce more efficient code. \n+Again, using @code{volatile} disables this type of optimization.\n \n-@smallexample\n-int t1 = @dots{};\n-register int *p1 asm (\"r0\") = @dots{};\n-register int *p2 asm (\"r1\") = t1;\n-register int *result asm (\"r0\");\n-asm (\"sysint\" : \"=r\" (result) : \"0\" (p1), \"r\" (p2));\n-@end smallexample\n+@example\n+void do_print(uint32_t dwSomeValue)\n+@{\n+   uint32_t dwRes;\n+\n+   for (uint32_t x=0; x < 5; x++)\n+   @{\n+      // Assumes dwSomeValue is not zero.\n+      asm (\"bsfl %1,%0\"\n+        : \"=r\" (dwRes)\n+        : \"r\" (dwSomeValue)\n+        : \"cc\");\n+\n+      printf(\"%u: %u %u\\n\", x, dwSomeValue, dwRes);\n+   @}\n+@}\n+@end example\n \n-Some instructions clobber specific hard registers.  To describe this,\n-write a third colon after the input operands, followed by the names of\n-the clobbered hard registers (given as strings).  Here is a realistic\n-example for the VAX:\n+The following example demonstrates a case where you need to use the \n+@code{volatile} qualifier. It uses the i386 RDTSC instruction, which reads \n+the computer's time-stamp counter. Without the @code{volatile} qualifier, \n+the optimizers might assume that the @code{asm} block will always return the \n+same value and therefore optimize away the second call.\n \n-@smallexample\n-asm volatile (\"movc3 %0,%1,%2\"\n-              : /* @r{no outputs} */\n-              : \"g\" (from), \"g\" (to), \"g\" (count)\n-              : \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\");\n-@end smallexample\n+@example\n+uint64_t msr;\n \n-You may not write a clobber description in a way that overlaps with an\n-input or output operand.  For example, you may not have an operand\n-describing a register class with one member if you mention that register\n-in the clobber list.  Variables declared to live in specific registers\n-(@pxref{Explicit Reg Vars}), and used as asm input or output operands must\n-have no part mentioned in the clobber description.\n-There is no way for you to specify that an input\n-operand is modified without also specifying it as an output\n-operand.  Note that if all the output operands you specify are for this\n-purpose (and hence unused), you then also need to specify\n-@code{volatile} for the @code{asm} construct, as described below, to\n-prevent GCC from deleting the @code{asm} statement as unused.\n+asm volatile ( \"rdtsc\\n\\t\"    // Returns the time in EDX:EAX.\n+        \"shl $32, %%rdx\\n\\t\"  // Shift the upper bits left.\n+        \"or %%rdx, %0\"        // 'Or' in the lower bits.\n+        : \"=a\" (msr)\n+        : \n+        : \"rdx\");\n \n-If you refer to a particular hardware register from the assembler code,\n-you probably have to list the register after the third colon to\n-tell the compiler the register's value is modified.  In some assemblers,\n-the register names begin with @samp{%}; to produce one @samp{%} in the\n-assembler code, you must write @samp{%%} in the input.\n+printf(\"msr: %llx\\n\", msr);\n \n-If your assembler instruction can alter the condition code register, add\n-@samp{cc} to the list of clobbered registers.  GCC on some machines\n-represents the condition codes as a specific hardware register;\n-@samp{cc} serves to name this register.  On other machines, the\n-condition code is handled differently, and specifying @samp{cc} has no\n-effect.  But it is valid no matter what the machine.\n+// Do other work...\n \n-If your assembler instructions access memory in an unpredictable\n-fashion, add @samp{memory} to the list of clobbered registers.  This\n-causes GCC to not keep memory values cached in registers across the\n-assembler instruction and not optimize stores or loads to that memory.\n-You also should add the @code{volatile} keyword if the memory\n-affected is not listed in the inputs or outputs of the @code{asm}, as\n-the @samp{memory} clobber does not count as a side-effect of the\n-@code{asm}.  If you know how large the accessed memory is, you can add\n-it as input or output but if this is not known, you should add\n-@samp{memory}.  As an example, if you access ten bytes of a string, you\n-can use a memory input like:\n+// Reprint the timestamp\n+asm volatile ( \"rdtsc\\n\\t\"    // Returns the time in EDX:EAX.\n+        \"shl $32, %%rdx\\n\\t\"  // Shift the upper bits left.\n+        \"or %%rdx, %0\"        // 'Or' in the lower bits.\n+        : \"=a\" (msr)\n+        : \n+        : \"rdx\");\n \n-@smallexample\n-@{\"m\"( (@{ struct @{ char x[10]; @} *p = (void *)ptr ; *p; @}) )@}.\n-@end smallexample\n+printf(\"msr: %llx\\n\", msr);\n+@end example\n \n-Note that in the following example the memory input is necessary,\n-otherwise GCC might optimize the store to @code{x} away:\n-@smallexample\n-int foo ()\n-@{\n-  int x = 42;\n-  int *y = &x;\n-  int result;\n-  asm (\"magic stuff accessing an 'int' pointed to by '%1'\"\n-       : \"=&d\" (result) : \"a\" (y), \"m\" (*y));\n-  return result;\n-@}\n-@end smallexample\n+GCC's optimizers will not treat this code like the non-volatile code in the \n+earlier examples. They do not move it out of loops or omit it on the \n+assumption that the result from a previous call is still valid.\n \n-You can put multiple assembler instructions together in a single\n-@code{asm} template, separated by the characters normally used in assembly\n-code for the system.  A combination that works in most places is a newline\n-to break the line, plus a tab character to move to the instruction field\n-(written as @samp{\\n\\t}).  Sometimes semicolons can be used, if the\n-assembler allows semicolons as a line-breaking character.  Note that some\n-assembler dialects use semicolons to start a comment.\n-The input operands are guaranteed not to use any of the clobbered\n-registers, and neither do the output operands' addresses, so you can\n-read and write the clobbered registers as many times as you like.  Here\n-is an example of multiple instructions in a template; it assumes the\n-subroutine @code{_foo} accepts arguments in registers 9 and 10:\n+Note that the compiler can move even volatile @code{asm} instructions relative \n+to other code, including across jump instructions. For example, on many \n+targets there is a system register that controls the rounding mode of \n+floating-point operations. Setting it with a volatile @code{asm}, as in the \n+following PowerPC example, will not work reliably.\n \n-@smallexample\n-asm (\"movl %0,r9\\n\\tmovl %1,r10\\n\\tcall _foo\"\n-     : /* no outputs */\n-     : \"g\" (from), \"g\" (to)\n-     : \"r9\", \"r10\");\n-@end smallexample\n+@example\n+asm volatile(\"mtfsf 255, %0\" : : \"f\" (fpenv));\n+sum = x + y;\n+@end example\n \n-Unless an output operand has the @samp{&} constraint modifier, GCC\n-may allocate it in the same register as an unrelated input operand, on\n-the assumption the inputs are consumed before the outputs are produced.\n-This assumption may be false if the assembler code actually consists of\n-more than one instruction.  In such a case, use @samp{&} for each output\n-operand that may not overlap an input.  @xref{Modifiers}.\n+The compiler may move the addition back before the volatile @code{asm}. To \n+make it work as expected, add an artificial dependency to the @code{asm} by \n+referencing a variable in the subsequent code, for example: \n \n-If you want to test the condition code produced by an assembler\n-instruction, you must include a branch and a label in the @code{asm}\n-construct, as follows:\n+@example\n+asm volatile (\"mtfsf 255,%1\" : \"=X\" (sum) : \"f\" (fpenv));\n+sum = x + y;\n+@end example\n \n-@smallexample\n-asm (\"clr %0\\n\\tfrob %1\\n\\tbeq 0f\\n\\tmov #1,%0\\n0:\"\n-     : \"g\" (result)\n-     : \"g\" (input));\n-@end smallexample\n+Under certain circumstances, GCC may duplicate (or remove duplicates of) your \n+assembly code when optimizing. This can lead to unexpected duplicate symbol \n+errors during compilation if your asm code defines symbols or labels. Using %= \n+(@pxref{AssemblerTemplate}) may help resolve this problem.\n+\n+@anchor{AssemblerTemplate}\n+@subsubsection Assembler Template\n+@cindex @code{asm} assembler template\n+\n+An assembler template is a literal string containing assembler instructions. \n+The compiler will replace any references to inputs, outputs, and goto labels \n+in the template, and then output the resulting string to the assembler. The \n+string can contain any instructions recognized by the assembler, including \n+directives. GCC does not parse the assembler instructions \n+themselves and does not know what they mean or even whether they are valid \n+assembler input. However, it does count the statements \n+(@pxref{Size of an asm}).\n+\n+You may place multiple assembler instructions together in a single @code{asm} \n+string, separated by the characters normally used in assembly code for the \n+system. A combination that works in most places is a newline to break the \n+line, plus a tab character to move to the instruction field (written as \n+\"\\n\\t\"). Some assemblers allow semicolons as a line separator. However, note \n+that some assembler dialects use semicolons to start a comment. \n+\n+Do not expect a sequence of @code{asm} statements to remain perfectly \n+consecutive after compilation, even when you are using the @code{volatile} \n+qualifier. If certain instructions need to remain consecutive in the output, \n+put them in a single multi-instruction asm statement.\n+\n+Accessing data from C programs without using input/output operands (such as \n+by using global symbols directly from the assembler template) may not work as \n+expected. Similarly, calling functions directly from an assembler template \n+requires a detailed understanding of the target assembler and ABI.\n+\n+Since GCC does not parse the AssemblerTemplate, it has no visibility of any \n+symbols it references. This may result in GCC discarding those symbols as \n+unreferenced unless they are also listed as input, output, or goto operands.\n+\n+GCC can support multiple assembler dialects (for example, GCC for i386 \n+supports \"att\" and \"intel\" dialects) for inline assembler. In builds that \n+support this capability, the @option{-masm} option controls which dialect \n+GCC uses as its default. The hardware-specific documentation for the \n+@option{-masm} option contains the list of supported dialects, as well as the \n+default dialect if the option is not specified. This information may be \n+important to understand, since assembler code that works correctly when \n+compiled using one dialect will likely fail if compiled using another.\n+\n+@subsubheading Using braces in @code{asm} templates\n+\n+If your code needs to support multiple assembler dialects (for example, if \n+you are writing public headers that need to support a variety of compilation \n+options), use constructs of this form:\n \n-@noindent\n-This assumes your assembler supports local labels, as the GNU assembler\n-and most Unix assemblers do.\n+@example\n+@{ dialect0 | dialect1 | dialect2... @}\n+@end example\n \n-Speaking of labels, jumps from one @code{asm} to another are not\n-supported.  The compiler's optimizers do not know about these jumps, and\n-therefore they cannot take account of them when deciding how to\n-optimize.  @xref{Extended asm with goto}.\n+This construct outputs 'dialect0' when using dialect #0 to compile the code, \n+'dialect1' for dialect #1, etc. If there are fewer alternatives within the \n+braces than the number of dialects the compiler supports, the construct \n+outputs nothing.\n \n-@cindex macros containing @code{asm}\n-Usually the most convenient way to use these @code{asm} instructions is to\n-encapsulate them in macros that look like functions.  For example,\n+For example, if an i386 compiler supports two dialects (att, intel), an \n+assembler template such as this:\n \n-@smallexample\n-#define sin(x)       \\\n-(@{ double __value, __arg = (x);   \\\n-   asm (\"fsinx %1,%0\": \"=f\" (__value): \"f\" (__arg));  \\\n-   __value; @})\n-@end smallexample\n+@example\n+\"bt@{l %[Offset],%[Base] | %[Base],%[Offset]@}; jc %l2\"\n+@end example\n \n-@noindent\n-Here the variable @code{__arg} is used to make sure that the instruction\n-operates on a proper @code{double} value, and to accept only those\n-arguments @code{x} that can convert automatically to a @code{double}.\n-\n-Another way to make sure the instruction operates on the correct data\n-type is to use a cast in the @code{asm}.  This is different from using a\n-variable @code{__arg} in that it converts more different types.  For\n-example, if the desired type is @code{int}, casting the argument to\n-@code{int} accepts a pointer with no complaint, while assigning the\n-argument to an @code{int} variable named @code{__arg} warns about\n-using a pointer unless the caller explicitly casts it.\n-\n-If an @code{asm} has output operands, GCC assumes for optimization\n-purposes the instruction has no side effects except to change the output\n-operands.  This does not mean instructions with a side effect cannot be\n-used, but you must be careful, because the compiler may eliminate them\n-if the output operands aren't used, or move them out of loops, or\n-replace two with one if they constitute a common subexpression.  Also,\n-if your instruction does have a side effect on a variable that otherwise\n-appears not to change, the old value of the variable may be reused later\n-if it happens to be found in a register.\n-\n-You can prevent an @code{asm} instruction from being deleted\n-by writing the keyword @code{volatile} after\n-the @code{asm}.  For example:\n-\n-@smallexample\n-#define get_and_set_priority(new)              \\\n-(@{ int __old;                                  \\\n-   asm volatile (\"get_and_set_priority %0, %1\" \\\n-                 : \"=g\" (__old) : \"g\" (new));  \\\n-   __old; @})\n-@end smallexample\n+would produce the output:\n \n-@noindent\n-The @code{volatile} keyword indicates that the instruction has\n-important side-effects.  GCC does not delete a volatile @code{asm} if\n-it is reachable.  (The instruction can still be deleted if GCC can\n-prove that control flow never reaches the location of the\n-instruction.)  Note that even a volatile @code{asm} instruction\n-can be moved relative to other code, including across jump\n-instructions.  For example, on many targets there is a system\n-register that can be set to control the rounding mode of\n-floating-point operations.  You might try\n-setting it with a volatile @code{asm}, like this PowerPC example:\n+@example\n+For att: \"btl %[Offset],%[Base] ; jc %l2\"\n+For intel: \"bt %[Base],%[Offset]; jc %l2\"\n+@end example\n \n-@smallexample\n-       asm volatile(\"mtfsf 255,%0\" : : \"f\" (fpenv));\n-       sum = x + y;\n-@end smallexample\n+Using that same compiler, this code:\n \n-@noindent\n-This does not work reliably, as the compiler may move the addition back\n-before the volatile @code{asm}.  To make it work you need to add an\n-artificial dependency to the @code{asm} referencing a variable in the code\n-you don't want moved, for example:\n+@example\n+\"xchg@{l@}\\t@{%%@}ebx, %1\"\n+@end example\n \n-@smallexample\n-    asm volatile (\"mtfsf 255,%1\" : \"=X\"(sum): \"f\"(fpenv));\n-    sum = x + y;\n-@end smallexample\n+would produce \n \n-Similarly, you can't expect a\n-sequence of volatile @code{asm} instructions to remain perfectly\n-consecutive.  If you want consecutive output, use a single @code{asm}.\n-Also, GCC performs some optimizations across a volatile @code{asm}\n-instruction; GCC does not ``forget everything'' when it encounters\n-a volatile @code{asm} instruction the way some other compilers do.\n+@example\n+For att: \"xchgl\\t%%ebx, %1\"\n+For intel: \"xchg\\tebx, %1\"\n+@end example\n \n-An @code{asm} instruction without any output operands is treated\n-identically to a volatile @code{asm} instruction.\n+There is no support for nesting dialect alternatives. Also, there is no \n+``escape'' for an open brace (@{), so do not use open braces in an Extended \n+@code{asm} template other than as a dialect indicator.\n \n-It is a natural idea to look for a way to give access to the condition\n-code left by the assembler instruction.  However, when we attempted to\n-implement this, we found no way to make it work reliably.  The problem\n-is that output operands might need reloading, which result in\n-additional following ``store'' instructions.  On most machines, these\n-instructions alter the condition code before there is time to\n-test it.  This problem doesn't arise for ordinary ``test'' and\n-``compare'' instructions because they don't have any output operands.\n+@subsubheading Other format strings\n \n-For reasons similar to those described above, it is not possible to give\n-an assembler instruction access to the condition code left by previous\n-instructions.\n+In addition to the tokens described by the input, output, and goto operands, \n+there are a few special cases:\n \n-@anchor{Extended asm with goto}\n-As of GCC version 4.5, @code{asm goto} may be used to have the assembly\n-jump to one or more C labels.  In this form, a fifth section after the\n-clobber list contains a list of all C labels to which the assembly may jump.\n-Each label operand is implicitly self-named.  The @code{asm} is also assumed\n-to fall through to the next statement.\n+@itemize\n+@item\n+\"%%\" outputs a single \"%\" into the assembler code.\n \n-This form of @code{asm} is restricted to not have outputs.  This is due\n-to a internal restriction in the compiler that control transfer instructions\n-cannot have outputs.  This restriction on @code{asm goto} may be lifted\n-in some future version of the compiler.  In the meantime, @code{asm goto}\n-may include a memory clobber, and so leave outputs in memory.\n+@item\n+\"%=\" outputs a number that is unique to each instance of the @code{asm} \n+statement in the entire compilation. This option is useful when creating local \n+labels and referring to them multiple times in a single template that \n+generates multiple assembler instructions. \n \n-@smallexample\n+@end itemize\n+\n+@anchor{OutputOperands}\n+@subsubsection Output Operands\n+@cindex @code{asm} output operands\n+\n+An @code{asm} statement has zero or more output operands indicating the names\n+of C variables modified by the assembler code.\n+\n+In this i386 example, @var{old} (referred to in the template string as \n+@code{%0}) and @var{*Base} (as @code{%1}) are outputs and @var{Offset} \n+(@code{%2}) is an input:\n+\n+@example\n+bool old;\n+\n+__asm__ (\"btsl %2,%1\\n\\t\" // Turn on zero-based bit #Offset in Base.\n+         \"sbb %0,%0\"      // Use the CF to calculate old.\n+   : \"=r\" (old), \"+rm\" (*Base)\n+   : \"Ir\" (Offset)\n+   : \"cc\");\n+\n+return old;\n+@end example\n+\n+Operands use this format:\n+\n+@example\n+[ [asmSymbolicName] ] \"constraint\" (cvariablename)\n+@end example\n+\n+@emph{asmSymbolicName}\n+@*\n+\n+When not using asmSymbolicNames, use the (zero-based) position of the operand \n+in the list of operands in the assembler template. For example if there are \n+three output operands, use @code{%0} in the template to refer to the first, \n+@code{%1} for the second, and @code{%2} for the third. When using an \n+asmSymbolicName, reference it by enclosing the name in square brackets \n+(i.e. @code{%[Value]}). The scope of the name is the @code{asm} statement \n+that contains the definition. Any valid C variable name is acceptable, \n+including names already defined in the surrounding code. No two operands \n+within the same @code{asm} statement can use the same symbolic name.\n+\n+@emph{constraint}\n+@*\n+Output constraints must begin with either @code{\"=\"} (a variable overwriting an \n+existing value) or @code{\"+\"} (when reading and writing). When using \n+@code{\"=\"}, do not assume the location will contain the existing value (except \n+when tying the variable to an input; @pxref{InputOperands,,Input Operands}).\n+\n+After the prefix, there must be one or more additional constraints \n+(@pxref{Constraints}) that describe where the value resides. Common \n+constraints include @code{\"r\"} for register and @code{\"m\"} for memory. \n+When you list more than one possible location (for example @code{\"=rm\"}), the \n+compiler chooses the most efficient one based on the current context. If you \n+list as many alternates as the @code{asm} statement allows, you will permit \n+the optimizers to produce the best possible code. If you must use a specific\n+register, but your Machine Constraints do not provide sufficient \n+control to select the specific register you want, Local Reg Vars may provide \n+a solution (@pxref{Local Reg Vars}).\n+\n+@emph{cvariablename}\n+@*\n+Specifies the C variable name of the output (enclosed by parentheses). Accepts \n+any (non-constant) variable within scope.\n+\n+Remarks:\n+\n+The total number of input + output + goto operands has a limit of 30. Commas \n+separate the operands. When the compiler selects the registers to use to \n+represent the output operands, it will not use any of the clobbered registers \n+(@pxref{Clobbers}).\n+\n+Output operand expressions must be lvalues. The compiler cannot check whether \n+the operands have data types that are reasonable for the instruction being \n+executed. For output expressions that are not directly addressable (for \n+example a bit-field), the constraint must allow a register. In that case, GCC \n+uses the register as the output of the @code{asm}, and then stores that \n+register into the output. \n+\n+Unless an output operand has the '@code{&}' constraint modifier \n+(@pxref{Modifiers}), GCC may allocate it in the same register as an unrelated \n+input operand, on the assumption that the assembler code will consume its \n+inputs before producing outputs. This assumption may be false if the assembler \n+code actually consists of more than one instruction. In this case, use \n+'@code{&}' on each output operand that must not overlap an input.\n+\n+The same problem can occur if one output parameter (@var{a}) allows a register \n+constraint and another output parameter (@var{b}) allows a memory constraint.\n+The code generated by GCC to access the memory address in @var{b} can contain\n+registers which @emph{might} be shared by @var{a}, and GCC considers those \n+registers to be inputs to the asm. As above, GCC assumes that such input\n+registers are consumed before any outputs are written. This assumption may \n+result in incorrect behavior if the asm writes to @var{a} before using \n+@var{b}. Combining the `@code{&}' constraint with the register constraint \n+ensures that modifying @var{a} will not affect what address is referenced by \n+@var{b}. Omitting the `@code{&}' constraint means that the location of @var{b} \n+will be undefined if @var{a} is modified before using @var{b}.\n+\n+@code{asm} supports operand modifiers on operands (for example @code{%k2} \n+instead of simply @code{%2}). Typically these qualifiers are hardware \n+dependent. The list of supported modifiers for i386 is found at \n+@ref{i386Operandmodifiers,i386 Operand modifiers}.\n+\n+If the C code that follows the @code{asm} makes no use of any of the output \n+operands, use @code{volatile} for the @code{asm} statement to prevent the \n+optimizers from discarding the @code{asm} statement as unneeded \n+(see @ref{Volatile}).\n+\n+Examples:\n+\n+This code makes no use of the optional asmSymbolicName. Therefore it \n+references the first output operand as @code{%0} (were there a second, it \n+would be @code{%1}, etc). The number of the first input operand is one greater \n+than that of the last output operand. In this i386 example, that makes \n+@var{Mask} @code{%1}:\n+\n+@example\n+uint32_t Mask = 1234;\n+uint32_t Index;\n+\n+  asm (\"bsfl %1, %0\"\n+     : \"=r\" (Index)\n+     : \"r\" (Mask)\n+     : \"cc\");\n+@end example\n+\n+That code overwrites the variable Index (\"=\"), placing the value in a register \n+(\"r\"). The generic \"r\" constraint instead of a constraint for a specific \n+register allows the compiler to pick the register to use, which can result \n+in more efficient code. This may not be possible if an assembler instruction \n+requires a specific register.\n+\n+The following i386 example uses the asmSymbolicName operand. It produces the \n+same result as the code above, but some may consider it more readable or more \n+maintainable since reordering index numbers is not necessary when adding or \n+removing operands. The names aIndex and aMask are only used to emphasize which \n+names get used where. It is acceptable to reuse the names Index and Mask.\n+\n+@example\n+uint32_t Mask = 1234;\n+uint32_t Index;\n+\n+  asm (\"bsfl %[aMask], %[aIndex]\"\n+     : [aIndex] \"=r\" (Index)\n+     : [aMask] \"r\" (Mask)\n+     : \"cc\");\n+@end example\n+\n+Here are some more examples of output operands.\n+\n+@example\n+uint32_t c = 1;\n+uint32_t d;\n+uint32_t *e = &c;\n+\n+asm (\"mov %[e], %[d]\"\n+   : [d] \"=rm\" (d)\n+   : [e] \"rm\" (*e));\n+@end example\n+\n+Here, @var{d} may either be in a register or in memory. Since the compiler \n+might already have the current value of the uint32_t pointed to by @var{e} \n+in a register, you can enable it to choose the best location\n+for @var{d} by specifying both constraints.\n+\n+@anchor{InputOperands}\n+@subsubsection Input Operands\n+@cindex @code{asm} input operands\n+@cindex @code{asm} expressions\n+\n+Input operands make inputs from C variables and expressions available to the \n+assembly code.\n+\n+Specify input operands by using the format:\n+\n+@example\n+[ [asmSymbolicName] ] \"constraint\" (cexpression)\n+@end example\n+\n+@emph{asmSymbolicName}\n+@*\n+When not using asmSymbolicNames, use the (zero-based) position of the operand \n+in the list of operands, including outputs, in the assembler template. For \n+example, if there are two output parameters and three inputs, @code{%2} refers \n+to the first input, @code{%3} to the second, and @code{%4} to the third.\n+When using an asmSymbolicName, reference it by enclosing the name in square \n+brackets (e.g. @code{%[Value]}). The scope of the name is the @code{asm} \n+statement that contains the definition. Any valid C variable name is \n+acceptable, including names already defined in the surrounding code. No two \n+operands within the same @code{asm} statement can use the same symbolic name.\n+\n+@emph{constraint}\n+@*\n+Input constraints must be a string containing one or more constraints \n+(@pxref{Constraints}). When you give more than one possible constraint \n+(for example, @code{\"irm\"}), the compiler will choose the most efficient \n+method based on the current context. Input constraints may not begin with \n+either \"=\" or \"+\". If you must use a specific register, but your Machine\n+Constraints do not provide sufficient control to select the specific \n+register you want, Local Reg Vars may provide a solution \n+(@pxref{Local Reg Vars}).\n+\n+Input constraints can also be digits (for example, @code{\"0\"}). This indicates \n+that the specified input will be in the same place as the output constraint \n+at the (zero-based) index in the output constraint list. When using \n+asmSymbolicNames for the output operands, you may use these names (enclosed \n+in brackets []) instead of digits.\n+\n+@emph{cexpression}\n+@*\n+This is the C variable or expression being passed to the @code{asm} statement \n+as input.\n+\n+When the compiler selects the registers to use to represent the input \n+operands, it will not use any of the clobbered registers (@pxref{Clobbers}).\n+\n+If there are no output operands but there are input operands, place two \n+consecutive colons where the output operands would go:\n+\n+@example\n+__asm__ (\"some instructions\"\n+   : /* No outputs. */\n+   : \"r\" (Offset / 8);\n+@end example\n+\n+@strong{Warning:} Do @emph{not} modify the contents of input-only operands \n+(except for inputs tied to outputs). The compiler assumes that on exit from \n+the @code{asm} statement these operands will contain the same values as they \n+had before executing the assembler. It is @emph{not} possible to use Clobbers \n+to inform the compiler that the values in these inputs are changing. One \n+common work-around is to tie the changing input variable to an output variable \n+that never gets used. Note, however, that if the code that follows the \n+@code{asm} statement makes no use of any of the output operands, the GCC \n+optimizers may discard the @code{asm} statement as unneeded \n+(see @ref{Volatile}).\n+\n+Remarks:\n+\n+The total number of input + output + goto operands has a limit of 30.\n+\n+@code{asm} supports operand modifiers on operands (for example @code{%k2} \n+instead of simply @code{%2}). Typically these qualifiers are hardware \n+dependent. The list of supported modifiers for i386 is found at \n+@ref{i386Operandmodifiers,i386 Operand modifiers}.\n+\n+Examples:\n+\n+In this example using the fictitious @code{combine} instruction, the \n+constraint @code{\"0\"} for input operand 1 says that it must occupy the same \n+location as output operand 0. Only input operands may use numbers in \n+constraints, and they must each refer to an output operand. Only a number (or \n+the symbolic assembler name) in the constraint can guarantee that one operand \n+is in the same place as another. The mere fact that @var{foo} is the value of \n+both operands is not enough to guarantee that they are in the same place in \n+the generated assembler code.\n+\n+@example\n+asm (\"combine %2, %0\" \n+   : \"=r\" (foo) \n+   : \"0\" (foo), \"g\" (bar));\n+@end example\n+\n+Here is an example using symbolic names.\n+\n+@example\n+asm (\"cmoveq %1, %2, %[result]\" \n+   : [result] \"=r\"(result) \n+   : \"r\" (test), \"r\" (new), \"[result]\" (old));\n+@end example\n+\n+@anchor{Clobbers}\n+@subsubsection Clobbers\n+@cindex @code{asm} clobbers\n+\n+While the compiler is aware of changes to entries listed in the output \n+operands, the assembler code may modify more than just the outputs. For \n+example, calculations may require additional registers, or the processor may \n+overwrite a register as a side effect of a particular assembler instruction. \n+In order to inform the compiler of these changes, list them in the clobber \n+list. Clobber list items are either register names or the special clobbers \n+(listed below). Each clobber list item is enclosed in double quotes and \n+separated by commas.\n+\n+Clobber descriptions may not in any way overlap with an input or output \n+operand. For example, you may not have an operand describing a register class \n+with one member when listing that register in the clobber list. Variables \n+declared to live in specific registers (@pxref{Explicit Reg Vars}), and used \n+as @code{asm} input or output operands, must have no part mentioned in the \n+clobber description. In particular, there is no way to specify that input \n+operands get modified without also specifying them as output operands.\n+\n+When the compiler selects which registers to use to represent input and output \n+operands, it will not use any of the clobbered registers. As a result, \n+clobbered registers are available for any use in the assembler code.\n+\n+Here is a realistic example for the VAX showing the use of clobbered \n+registers: \n+\n+@example\n+asm volatile (\"movc3 %0, %1, %2\"\n+                   : /* No outputs. */\n+                   : \"g\" (from), \"g\" (to), \"g\" (count)\n+                   : \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\");\n+@end example\n+\n+Also, there are two special clobber arguments:\n+\n+@enumerate\n+@item\n+The @code{\"cc\"} clobber indicates that the assembler code modifies the flags \n+register. On some machines, GCC represents the condition codes as a specific \n+hardware register; \"cc\" serves to name this register. On other machines, \n+condition code handling is different, and specifying \"cc\" has no effect. But \n+it is valid no matter what the machine.\n+\n+@item\n+The \"memory\" clobber tells the compiler that the assembly code performs memory \n+reads or writes to items other than those listed in the input and output \n+operands (for example accessing the memory pointed to by one of the input \n+parameters). To ensure memory contains correct values, GCC may need to flush \n+specific register values to memory before executing the @code{asm}. Further, \n+the compiler will not assume that any values read from memory before an \n+@code{asm} will remain unchanged after that @code{asm}; it will reload them as \n+needed. This effectively forms a read/write memory barrier for the compiler.\n+\n+Note that this clobber does not prevent the @emph{processor} from doing \n+speculative reads past the @code{asm} statement. To prevent that, you need \n+processor-specific fence instructions.\n+\n+Flushing registers to memory has performance implications and may be an issue \n+for time-sensitive code. One trick to avoid this is available if the size of \n+the memory being accessed is known at compile time. For example, if accessing \n+ten bytes of a string, use a memory input like: \n+\n+@code{@{\"m\"( (@{ struct @{ char x[10]; @} *p = (void *)ptr ; *p; @}) )@}}.\n+\n+@end enumerate\n+\n+@anchor{GotoLabels}\n+@subsubsection Goto Labels\n+@cindex @code{asm} goto labels\n+\n+@code{asm goto} allows assembly code to jump to one or more C labels. The \n+GotoLabels section in an @code{asm goto} statement contains a comma-separated \n+list of all C labels to which the assembler code may jump. GCC assumes that \n+@code{asm} execution falls through to the next statement (if this is not the \n+case, consider using the @code{__builtin_unreachable} intrinsic after the \n+@code{asm} statement). The total number of input + output + goto operands has \n+a limit of 30.\n+\n+An @code{asm goto} statement can not have outputs (which means that the \n+statement is implicitly volatile). This is due to an internal restriction of \n+the compiler: control transfer instructions cannot have outputs. If the \n+assembler code does modify anything, use the \"memory\" clobber to force the \n+optimizers to flush all register values to memory, and reload them if \n+necessary, after the @code{asm} statement.\n+\n+To reference a label, prefix it with @code{%l} (that's a lowercase L) followed \n+by its (zero-based) position in GotoLabels plus the number of input \n+arguments.  For example, if the @code{asm} has three inputs and references two \n+labels, refer to the first label as @code{%l3} and the second as @code{%l4}).\n+\n+@code{asm} statements may not perform jumps into other @code{asm} statements. \n+GCC's optimizers do not know about these jumps; therefore they cannot take \n+account of them when deciding how to optimize.\n+\n+Example code for i386 might look like:\n+\n+@example\n+asm goto (\n+    \"btl %1, %0\\n\\t\"\n+    \"jc %l2\"\n+    : /* No outputs. */\n+    : \"r\" (p1), \"r\" (p2) \n+    : \"cc\" \n+    : carry);\n+\n+return 0;\n+\n+carry:\n+return 1;\n+@end example\n+\n+The following example shows an @code{asm goto} that uses the memory clobber.\n+\n+@example\n int frob(int x)\n @{\n   int y;\n   asm goto (\"frob %%r5, %1; jc %l[error]; mov (%2), %%r5\"\n-            : : \"r\"(x), \"r\"(&y) : \"r5\", \"memory\" : error);\n+            : /* No outputs. */\n+            : \"r\"(x), \"r\"(&y)\n+            : \"r5\", \"memory\" \n+            : error);\n   return y;\n- error:\n+error:\n   return -1;\n @}\n-@end smallexample\n+@end example\n \n-@noindent\n-In this (inefficient) example, the @code{frob} instruction sets the\n-carry bit to indicate an error.  The @code{jc} instruction detects\n-this and branches to the @code{error} label.  Finally, the output\n-of the @code{frob} instruction (@code{%r5}) is stored into the memory\n-for variable @code{y}, which is later read by the @code{return} statement.\n+@anchor{i386Operandmodifiers}\n+@subsubsection i386 Operand modifiers\n \n-@smallexample\n-void doit(void)\n+Input, output, and goto operands for extended @code{asm} statements can use \n+modifiers to affect the code output to the assembler. For example, the \n+following code uses the \"h\" and \"b\" modifiers for i386:\n+\n+@example\n+uint16_t  num;\n+asm volatile (\"xchg %h0, %b0\" : \"+a\" (num) );\n+@end example\n+\n+These modifiers generate this assembler code:\n+\n+@example\n+xchg %ah, %al\n+@end example\n+\n+The rest of this discussion uses the following code for illustrative purposes.\n+\n+@example\n+int main()\n @{\n-  int i = 0;\n-  asm goto (\"mfsr %%r1, 123; jmp %%r1;\"\n-            \".pushsection doit_table;\"\n-            \".long %l0, %l1, %l2, %l3;\"\n-            \".popsection\"\n-            : : : \"r1\" : label1, label2, label3, label4);\n-  __builtin_unreachable ();\n-\n- label1:\n-  f1();\n-  return;\n- label2:\n-  f2();\n-  return;\n- label3:\n-  i = 1;\n- label4:\n-  f3(i);\n-@}\n-@end smallexample\n+   int iInt = 1;\n \n-@noindent\n-In this (also inefficient) example, the @code{mfsr} instruction reads\n-an address from some out-of-band machine register, and the following\n-@code{jmp} instruction branches to that address.  The address read by\n-the @code{mfsr} instruction is assumed to have been previously set via\n-some application-specific mechanism to be one of the four values stored\n-in the @code{doit_table} section.  Finally, the @code{asm} is followed\n-by a call to @code{__builtin_unreachable} to indicate that the @code{asm}\n-does not in fact fall through.\n-\n-@smallexample\n-#define TRACE1(NUM)                         \\\n-  do @{                                      \\\n-    asm goto (\"0: nop;\"                     \\\n-              \".pushsection trace_table;\"   \\\n-              \".long 0b, %l0;\"              \\\n-              \".popsection\"                 \\\n-              : : : : trace#NUM);           \\\n-    if (0) @{ trace#NUM: trace(); @}          \\\n-  @} while (0)\n-#define TRACE  TRACE1(__COUNTER__)\n-@end smallexample\n+top:\n \n-@noindent\n-In this example (which in fact inspired the @code{asm goto} feature)\n-we want on rare occasions to call the @code{trace} function; on other\n-occasions we'd like to keep the overhead to the absolute minimum.\n-The normal code path consists of a single @code{nop} instruction.\n-However, we record the address of this @code{nop} together with the\n-address of a label that calls the @code{trace} function.  This allows\n-the @code{nop} instruction to be patched at run time to be an\n-unconditional branch to the stored label.  It is assumed that an\n-optimizing compiler moves the labeled block out of line, to\n-optimize the fall through path from the @code{asm}.\n-\n-If you are writing a header file that should be includable in ISO C\n-programs, write @code{__asm__} instead of @code{asm}.  @xref{Alternate\n-Keywords}.\n+   asm volatile goto (\"some assembler instructions here\"\n+   : /* No outputs. */\n+   : \"q\" (iInt), \"X\" (sizeof(unsigned char) + 1)\n+   : /* No clobbers. */\n+   : top);\n+@}\n+@end example\n \n-@subsection Size of an @code{asm}\n+With no modifiers, this is what the output from the operands would be for the \n+att and intel dialects of assembler:\n+\n+@multitable {Operand} {masm=att} {OFFSET FLAT:.L2}\n+@headitem Operand @tab masm=att @tab masm=intel\n+@item @code{%0}\n+@tab @code{%eax}\n+@tab @code{eax}\n+@item @code{%1}\n+@tab @code{$2}\n+@tab @code{2}\n+@item @code{%2}\n+@tab @code{$.L2}\n+@tab @code{OFFSET FLAT:.L2}\n+@end multitable\n \n-Some targets require that GCC track the size of each instruction used in\n-order to generate correct code.  Because the final length of an\n-@code{asm} is only known by the assembler, GCC must make an estimate as\n-to how big it will be.  The estimate is formed by counting the number of\n-statements in the pattern of the @code{asm} and multiplying that by the\n-length of the longest instruction on that processor.  Statements in the\n-@code{asm} are identified by newline characters and whatever statement\n-separator characters are supported by the assembler; on most processors\n-this is the @samp{;} character.\n-\n-Normally, GCC's estimate is perfectly adequate to ensure that correct\n-code is generated, but it is possible to confuse the compiler if you use\n-pseudo instructions or assembler macros that expand into multiple real\n-instructions or if you use assembler directives that expand to more\n-space in the object file than is needed for a single instruction.\n-If this happens then the assembler produces a diagnostic saying that\n-a label is unreachable.\n+The table below shows the list of supported modifiers and their effects.\n+\n+@multitable {Modifier} {Print the opcode suffix for the size of th} {Operand} {masm=att} {masm=intel}\n+@headitem Modifier @tab Description @tab Operand @tab @option{masm=att} @tab @option{masm=intel}\n+@item @code{z}\n+@tab Print the opcode suffix for the size of the current integer operand (one of @code{b}/@code{w}/@code{l}/@code{q}).\n+@tab @code{%z0}\n+@tab @code{l}\n+@tab \n+@item @code{b}\n+@tab Print the QImode name of the register.\n+@tab @code{%b0}\n+@tab @code{%al}\n+@tab @code{al}\n+@item @code{h}\n+@tab Print the QImode name for a ``high'' register.\n+@tab @code{%h0}\n+@tab @code{%ah}\n+@tab @code{ah}\n+@item @code{w}\n+@tab Print the HImode name of the register.\n+@tab @code{%w0}\n+@tab @code{%ax}\n+@tab @code{ax}\n+@item @code{k}\n+@tab Print the SImode name of the register.\n+@tab @code{%k0}\n+@tab @code{%eax}\n+@tab @code{eax}\n+@item @code{q}\n+@tab Print the DImode name of the register.\n+@tab @code{%q0}\n+@tab @code{%rax}\n+@tab @code{rax}\n+@item @code{l}\n+@tab Print the label name with no punctuation.\n+@tab @code{%l2}\n+@tab @code{.L2}\n+@tab @code{.L2}\n+@item @code{c}\n+@tab Require a constant operand and print the constant expression with no punctuation.\n+@tab @code{%c1}\n+@tab @code{2}\n+@tab @code{2}\n+@end multitable\n \n-@subsection i386 floating-point asm operands\n+@anchor{i386floatingpointasmoperands}\n+@subsubsection i386 floating-point asm operands\n \n On i386 targets, there are several rules on the usage of stack-like registers\n in the operands of an @code{asm}.  These rules apply only to the operands\n@@ -6715,10 +7168,34 @@ for the compiler to know that @code{fyl2xp1} pops both inputs.\n asm (\"fyl2xp1\" : \"=t\" (result) : \"0\" (x), \"u\" (y) : \"st(1)\");\n @end smallexample\n \n+@lowersections\n @include md.texi\n+@raisesections\n+\n+@node Size of an asm\n+@subsection Size of an @code{asm}\n+\n+Some targets require that GCC track the size of each instruction used\n+in order to generate correct code.  Because the final length of the\n+code produced by an @code{asm} statement is only known by the\n+assembler, GCC must make an estimate as to how big it will be.  It\n+does this by counting the number of instructions in the pattern of the\n+@code{asm} and multiplying that by the length of the longest\n+instruction supported by that processor.  (When working out the number\n+of instructions, it assumes that any occurrence of a newline or of\n+whatever statement separator character is supported by the assembler --\n+typically @samp{;} --- indicates the end of an instruction.)\n+\n+Normally, GCC's estimate is adequate to ensure that correct\n+code is generated, but it is possible to confuse the compiler if you use\n+pseudo instructions or assembler macros that expand into multiple real\n+instructions, or if you use assembler directives that expand to more\n+space in the object file than is needed for a single instruction.\n+If this happens then the assembler may produce a diagnostic saying that\n+a label is unreachable.\n \n @node Asm Labels\n-@section Controlling Names Used in Assembler Code\n+@subsection Controlling Names Used in Assembler Code\n @cindex assembler names for identifiers\n @cindex names used in assembler code\n @cindex identifiers, names in assembler code\n@@ -6766,7 +7243,7 @@ does not as yet have the ability to store static variables in registers.\n Perhaps that will be added.\n \n @node Explicit Reg Vars\n-@section Variables in Specified Registers\n+@subsection Variables in Specified Registers\n @cindex explicit register variables\n @cindex variables in specified registers\n @cindex specified registers\n@@ -6806,7 +7283,7 @@ specified for that operand in the @code{asm}.)\n @end menu\n \n @node Global Reg Vars\n-@subsection Defining Global Register Variables\n+@subsubsection Defining Global Register Variables\n @cindex global register variables\n @cindex registers, global variables in\n \n@@ -6903,7 +7380,7 @@ On the 68000, a2 @dots{} a5 should be suitable, as should d2 @dots{} d7.\n Of course, it does not do to use more than a few of those.\n \n @node Local Reg Vars\n-@subsection Specifying Registers for Local Variables\n+@subsubsection Specifying Registers for Local Variables\n @cindex local variables, specifying registers\n @cindex specifying registers for local variables\n @cindex registers for local variables\n@@ -6946,21 +7423,37 @@ Stores into local register variables may be deleted when they appear to be dead\n according to dataflow analysis.  References to local register variables may\n be deleted or moved or simplified.\n \n-As for global register variables, it's recommended that you choose a\n+As with global register variables, it is recommended that you choose a\n register that is normally saved and restored by function calls on\n-your machine, so that library routines will not clobber it.  A common\n-pitfall is to initialize multiple call-clobbered registers with\n-arbitrary expressions, where a function call or library call for an\n-arithmetic operator overwrites a register value from a previous\n-assignment, for example @code{r0} below:\n+your machine, so that library routines will not clobber it.  \n+\n+Sometimes when writing inline @code{asm} code, you need to make an operand be a \n+specific register, but there's no matching constraint letter for that \n+register. To force the operand into that register, create a local variable \n+and specify the register in the variable's declaration. Then use the local \n+variable for the asm operand and specify any constraint letter that matches \n+the register:\n+\n @smallexample\n register int *p1 asm (\"r0\") = @dots{};\n register int *p2 asm (\"r1\") = @dots{};\n+register int *result asm (\"r0\");\n+asm (\"sysint\" : \"=r\" (result) : \"0\" (p1), \"r\" (p2));\n @end smallexample\n \n-@noindent\n-In those cases, a solution is to use a temporary variable for\n-each arbitrary expression.   @xref{Example of asm with clobbered asm reg}.\n+@emph{Warning:} In the above example, be aware that a register (for example r0) can be \n+call-clobbered by subsequent code, including function calls and library calls \n+for arithmetic operators on other variables (for example the initialization \n+of p2). In this case, use temporary variables for expressions between the \n+register assignments:\n+\n+@smallexample\n+int t1 = @dots{};\n+register int *p1 asm (\"r0\") = @dots{};\n+register int *p2 asm (\"r1\") = t1;\n+register int *result asm (\"r0\");\n+asm (\"sysint\" : \"=r\" (result) : \"0\" (p1), \"r\" (p2));\n+@end smallexample\n \n @node Alternate Keywords\n @section Alternate Keywords"}]}