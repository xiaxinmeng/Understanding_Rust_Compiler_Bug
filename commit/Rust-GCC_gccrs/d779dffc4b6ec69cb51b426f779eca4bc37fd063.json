{"sha": "d779dffc4b6ec69cb51b426f779eca4bc37fd063", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc3OWRmZmM0YjZlYzY5Y2I1MWI0MjZmNzc5ZWNhNGJjMzdmZDA2Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-27T23:44:29Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-27T23:44:29Z"}, "message": "libgo: update to Go1.10rc1\n    \n    Reviewed-on: https://go-review.googlesource.com/90295\n\nFrom-SVN: r257126", "tree": {"sha": "c305b88e41d468affc247b4f066bc9340fb2209e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c305b88e41d468affc247b4f066bc9340fb2209e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d779dffc4b6ec69cb51b426f779eca4bc37fd063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d779dffc4b6ec69cb51b426f779eca4bc37fd063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d779dffc4b6ec69cb51b426f779eca4bc37fd063", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d779dffc4b6ec69cb51b426f779eca4bc37fd063/comments", "author": null, "committer": null, "parents": [{"sha": "ace36c8bcc112f1ecf889f413e22df5a41ed3e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ace36c8bcc112f1ecf889f413e22df5a41ed3e87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ace36c8bcc112f1ecf889f413e22df5a41ed3e87"}], "stats": {"total": 1478, "additions": 963, "deletions": 515}, "files": [{"sha": "d8350f3957ffaa762f2cb99123935d88e1e50103", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -1,4 +1,4 @@\n-13b25c25faa8afd625732d2630a4f9ece5cacb2e\n+4164071703c531b5234b790b76df4931c37a8d9c\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "4a3c64ed88f381c302e3172a79895ede2f31d789", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -1,4 +1,4 @@\n-594668a5a96267a46282ce3007a584ec07adf705\n+5348aed83e39bd1d450d92d7f627e994c2db6ebf\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "5859fbe0b7adb26d9cd28ba25f2b1c6045e0276e", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -1 +1 @@\n-go1.10beta2\n+go1.10rc1"}, {"sha": "8e4cd88b37c2f7abe219fd8383bab44183ecba95", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 5, "deletions": 63, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -341,69 +341,11 @@ in unexpected and unpredictable ways.\n Special cases\n \n A few special C types which would normally be represented by a pointer\n-type in Go are instead represented by a uintptr. Those types are\n-the CF*Ref types from the CoreFoundation library on Darwin, including:\n-\n-\tCFAllocatorRef\n-\tCFArrayRef\n-\tCFAttributedStringRef\n-\tCFBagRef\n-\tCFBinaryHeapRef\n-\tCFBitVectorRef\n-\tCFBooleanRef\n-\tCFBundleRef\n-\tCFCalendarRef\n-\tCFCharacterSetRef\n-\tCFDataRef\n-\tCFDateFormatterRef\n-\tCFDateRef\n-\tCFDictionaryRef\n-\tCFErrorRef\n-\tCFFileDescriptorRef\n-\tCFFileSecurityRef\n-\tCFLocaleRef\n-\tCFMachPortRef\n-\tCFMessagePortRef\n-\tCFMutableArrayRef\n-\tCFMutableAttributedStringRef\n-\tCFMutableBagRef\n-\tCFMutableBitVectorRef\n-\tCFMutableCharacterSetRef\n-\tCFMutableDataRef\n-\tCFMutableDictionaryRef\n-\tCFMutableSetRef\n-\tCFMutableStringRef\n-\tCFNotificationCenterRef\n-\tCFNullRef\n-\tCFNumberFormatterRef\n-\tCFNumberRef\n-\tCFPlugInInstanceRef\n-\tCFPlugInRef\n-\tCFPropertyListRef\n-\tCFReadStreamRef\n-\tCFRunLoopObserverRef\n-\tCFRunLoopRef\n-\tCFRunLoopSourceRef\n-\tCFRunLoopTimerRef\n-\tCFSetRef\n-\tCFSocketRef\n-\tCFStringRef\n-\tCFStringTokenizerRef\n-\tCFTimeZoneRef\n-\tCFTreeRef\n-\tCFTypeRef\n-\tCFURLCreateFromFSRef\n-\tCFURLEnumeratorRef\n-\tCFURLGetFSRef\n-\tCFURLRef\n-\tCFUUIDRef\n-\tCFUserNotificationRef\n-\tCFWriteStreamRef\n-\tCFXMLNodeRef\n-\tCFXMLParserRef\n-\tCFXMLTreeRef\n-\n-Also the object types from Java's JNI interface:\n+type in Go are instead represented by a uintptr. Those include:\n+\n+1. The *Ref types on Darwin, rooted at CoreFoundation's CFTypeRef type.\n+\n+2. The object types from Java's JNI interface:\n \n \tjobject\n \tjclass"}, {"sha": "fcf334ec44efeb1694b8eadd3114538a72ccb5ca", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 53, "deletions": 10, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -243,6 +243,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t// Determine kinds for names we already know about,\n \t// like #defines or 'struct foo', before bothering with gcc.\n \tvar names, needType []*Name\n+\toptional := map[*Name]bool{}\n \tfor _, key := range nameKeys(f.Name) {\n \t\tn := f.Name[key]\n \t\t// If we've already found this name as a #define\n@@ -279,6 +280,14 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t\tcontinue\n \t\t}\n \n+\t\tif goos == \"darwin\" && strings.HasSuffix(n.C, \"Ref\") {\n+\t\t\t// For FooRef, find out if FooGetTypeID exists.\n+\t\t\ts := n.C[:len(n.C)-3] + \"GetTypeID\"\n+\t\t\tn := &Name{Go: s, C: s}\n+\t\t\tnames = append(names, n)\n+\t\t\toptional[n] = true\n+\t\t}\n+\n \t\t// Otherwise, we'll need to find out from gcc.\n \t\tnames = append(names, n)\n \t}\n@@ -425,6 +434,11 @@ func (p *Package) guessKinds(f *File) []*Name {\n \tfor i, n := range names {\n \t\tswitch sniff[i] {\n \t\tdefault:\n+\t\t\tif sniff[i]&notDeclared != 0 && optional[n] {\n+\t\t\t\t// Ignore optional undeclared identifiers.\n+\t\t\t\t// Don't report an error, and skip adding n to the needType array.\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\terror_(f.NamePos[n], \"could not determine kind of name for C.%s\", fixGo(n.Go))\n \t\tcase notStrLiteral | notType:\n \t\t\tn.Kind = \"iconst\"\n@@ -437,6 +451,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\tcase notIntConst | notNumConst | notStrLiteral | notType:\n \t\t\tn.Kind = \"not-type\"\n \t\t}\n+\t\tneedType = append(needType, n)\n \t}\n \tif nerrors > 0 {\n \t\t// Check if compiling the preamble by itself causes any errors,\n@@ -450,7 +465,6 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\tfatalf(\"unresolved names\")\n \t}\n \n-\tneedType = append(needType, names...)\n \treturn needType\n }\n \n@@ -565,6 +579,11 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t// Record types and typedef information.\n \tvar conv typeConv\n \tconv.Init(p.PtrSize, p.IntSize)\n+\tfor i, n := range names {\n+\t\tif strings.HasSuffix(n.Go, \"GetTypeID\") && types[i].String() == \"func() CFTypeID\" {\n+\t\t\tconv.getTypeIDs[n.Go[:len(n.Go)-9]] = true\n+\t\t}\n+\t}\n \tfor i, n := range names {\n \t\tif types[i] == nil {\n \t\t\tcontinue\n@@ -1737,6 +1756,9 @@ type typeConv struct {\n \t// Keys of ptrs in insertion order (deterministic worklist)\n \tptrKeys []dwarf.Type\n \n+\t// Type names X for which there exists an XGetTypeID function with type func() CFTypeID.\n+\tgetTypeIDs map[string]bool\n+\n \t// Predeclared types.\n \tbool                                   ast.Expr\n \tbyte                                   ast.Expr // denotes padding\n@@ -1766,6 +1788,7 @@ func (c *typeConv) Init(ptrSize, intSize int64) {\n \tc.intSize = intSize\n \tc.m = make(map[dwarf.Type]*Type)\n \tc.ptrs = make(map[dwarf.Type][]*Type)\n+\tc.getTypeIDs = make(map[string]bool)\n \tc.bool = c.Ident(\"bool\")\n \tc.byte = c.Ident(\"byte\")\n \tc.int8 = c.Ident(\"int8\")\n@@ -2152,7 +2175,7 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\tname := c.Ident(\"_Ctype_\" + dt.Name)\n \t\tgoIdent[name.Name] = name\n \t\tsub := c.Type(dt.Type, pos)\n-\t\tif badPointerTypedef(dt) {\n+\t\tif c.badPointerTypedef(dt) {\n \t\t\t// Treat this typedef as a uintptr.\n \t\t\ts := *sub\n \t\t\ts.Go = c.uintptr\n@@ -2318,7 +2341,7 @@ func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\t}\n \t\t\t// ...or the typedef is one in which we expect bad pointers.\n \t\t\t// It will be a uintptr instead of *X.\n-\t\t\tif badPointerTypedef(dt) {\n+\t\t\tif c.badPointerTypedef(dt) {\n \t\t\t\tbreak\n \t\t\t}\n \n@@ -2666,23 +2689,43 @@ func fieldPrefix(fld []*ast.Field) string {\n // A typedef is bad if C code sometimes stores non-pointers in this type.\n // TODO: Currently our best solution is to find these manually and list them as\n // they come up. A better solution is desired.\n-func badPointerTypedef(dt *dwarf.TypedefType) bool {\n-\tif badCFType(dt) {\n+func (c *typeConv) badPointerTypedef(dt *dwarf.TypedefType) bool {\n+\tif c.badCFType(dt) {\n \t\treturn true\n \t}\n-\tif badJNI(dt) {\n+\tif c.badJNI(dt) {\n \t\treturn true\n \t}\n \treturn false\n }\n \n-func badCFType(dt *dwarf.TypedefType) bool {\n+func (c *typeConv) badCFType(dt *dwarf.TypedefType) bool {\n \t// The real bad types are CFNumberRef and CFDateRef.\n \t// Sometimes non-pointers are stored in these types.\n \t// CFTypeRef is a supertype of those, so it can have bad pointers in it as well.\n-\t// We return true for the other CF*Ref types just so casting between them is easier.\n+\t// We return true for the other *Ref types just so casting between them is easier.\n+\t// We identify the correct set of types as those ending in Ref and for which\n+\t// there exists a corresponding GetTypeID function.\n \t// See comment below for details about the bad pointers.\n-\treturn goos == \"darwin\" && strings.HasPrefix(dt.Name, \"CF\") && strings.HasSuffix(dt.Name, \"Ref\")\n+\tif goos != \"darwin\" {\n+\t\treturn false\n+\t}\n+\ts := dt.Name\n+\tif !strings.HasSuffix(s, \"Ref\") {\n+\t\treturn false\n+\t}\n+\ts = s[:len(s)-3]\n+\tif s == \"CFType\" {\n+\t\treturn true\n+\t}\n+\tif c.getTypeIDs[s] {\n+\t\treturn true\n+\t}\n+\tif i := strings.Index(s, \"Mutable\"); i >= 0 && c.getTypeIDs[s[:i]+s[i+7:]] {\n+\t\t// Mutable and immutable variants share a type ID.\n+\t\treturn true\n+\t}\n+\treturn false\n }\n \n // Comment from Darwin's CFInternal.h\n@@ -2720,7 +2763,7 @@ enum {\n };\n */\n \n-func badJNI(dt *dwarf.TypedefType) bool {\n+func (c *typeConv) badJNI(dt *dwarf.TypedefType) bool {\n \t// In Dalvik and ART, the jobject type in the JNI interface of the JVM has the\n \t// property that it is sometimes (always?) a small integer instead of a real pointer.\n \t// Note: although only the android JVMs are bad in this respect, we declare the JNI types"}, {"sha": "85b9d2584f242a643cc2890a5fccc3091376ad8f", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 91, "deletions": 39, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -35,14 +35,15 @@\n // Additional help topics:\n //\n // \tc           calling between Go and C\n-// \tbuildmode   description of build modes\n+// \tbuildmode   build modes\n+// \tcache       build and test caching\n // \tfiletype    file types\n // \tgopath      GOPATH environment variable\n // \tenvironment environment variables\n // \timportpath  import path syntax\n-// \tpackages    description of package lists\n-// \ttestflag    description of testing flags\n-// \ttestfunc    description of testing functions\n+// \tpackages    package lists\n+// \ttestflag    testing flags\n+// \ttestfunc    testing functions\n //\n // Use \"go help [topic]\" for more information about that topic.\n //\n@@ -756,39 +757,51 @@\n // Only a high-confidence subset of the default go vet checks are used.\n // To disable the running of go vet, use the -vet=off flag.\n //\n-// Go test runs in two different modes: local directory mode when invoked with\n-// no package arguments (for example, 'go test'), and package list mode when\n-// invoked with package arguments (for example 'go test math', 'go test ./...',\n-// and even 'go test .').\n-//\n-// In local directory mode, go test compiles and tests the package sources\n-// found in the current directory and then runs the resulting test binary.\n-// In this mode, caching (discussed below) is disabled. After the package test\n-// finishes, go test prints a summary line showing the test status ('ok' or 'FAIL'),\n-// package name, and elapsed time.\n-//\n-// In package list mode, go test compiles and tests each of the packages\n-// listed on the command line. If a package test passes, go test prints only\n-// the final 'ok' summary line. If a package test fails, go test prints the\n-// full test output. If invoked with the -bench or -v flag, go test prints\n-// the full output even for passing package tests, in order to display the\n+// All test output and summary lines are printed to the go command's\n+// standard output, even if the test printed them to its own standard\n+// error. (The go command's standard error is reserved for printing\n+// errors building the tests.)\n+//\n+// Go test runs in two different modes:\n+//\n+// The first, called local directory mode, occurs when go test is\n+// invoked with no package arguments (for example, 'go test' or 'go\n+// test -v'). In this mode, go test compiles the package sources and\n+// tests found in the current directory and then runs the resulting\n+// test binary. In this mode, caching (discussed below) is disabled.\n+// After the package test finishes, go test prints a summary line\n+// showing the test status ('ok' or 'FAIL'), package name, and elapsed\n+// time.\n+//\n+// The second, called package list mode, occurs when go test is invoked\n+// with explicit package arguments (for example 'go test math', 'go\n+// test ./...', and even 'go test .'). In this mode, go test compiles\n+// and tests each of the packages listed on the command line. If a\n+// package test passes, go test prints only the final 'ok' summary\n+// line. If a package test fails, go test prints the full test output.\n+// If invoked with the -bench or -v flag, go test prints the full\n+// output even for passing package tests, in order to display the\n // requested benchmark results or verbose logging.\n //\n-// All test output and summary lines are printed to the go command's standard\n-// output, even if the test printed them to its own standard error.\n-// (The go command's standard error is reserved for printing errors building\n-// the tests.)\n-//\n-// In package list mode, go test also caches successful package test results.\n-// If go test has cached a previous test run using the same test binary and\n-// the same command line consisting entirely of cacheable test flags\n-// (defined as -cpu, -list, -parallel, -run, -short, and -v),\n-// go test will redisplay the previous output instead of running the test\n-// binary again. In the summary line, go test prints '(cached)' in place of\n-// the elapsed time. To disable test caching, use any test flag or argument\n-// other than the cacheable flags. The idiomatic way to disable test caching\n-// explicitly is to use -count=1. A cached result is treated as executing in\n-// no time at all, so a successful package test result will be cached and reused\n+// In package list mode only, go test caches successful package test\n+// results to avoid unnecessary repeated running of tests. When the\n+// result of a test can be recovered from the cache, go test will\n+// redisplay the previous output instead of running the test binary\n+// again. When this happens, go test prints '(cached)' in place of the\n+// elapsed time in the summary line.\n+//\n+// The rule for a match in the cache is that the run involves the same\n+// test binary and the flags on the command line come entirely from a\n+// restricted set of 'cacheable' test flags, defined as -cpu, -list,\n+// -parallel, -run, -short, and -v. If a run of go test has any test\n+// or non-test flags outside this set, the result is not cached. To\n+// disable test caching, use any test flag or argument other than the\n+// cacheable flags. The idiomatic way to disable test caching explicitly\n+// is to use -count=1. Tests that open files within the package's source\n+// root (usually $GOPATH) or that consult environment variables only\n+// match future runs in which the files and environment variables are unchanged.\n+// A cached test result is treated as executing in no time at all,\n+// so a successful package test result will be cached and reused\n // regardless of -timeout setting.\n //\n // In addition to the build flags, the flags handled by 'go test' itself are:\n@@ -893,7 +906,7 @@\n // the C or C++ compiler, respectively, to use.\n //\n //\n-// Description of build modes\n+// Build modes\n //\n // The 'go build' and 'go install' commands take a -buildmode argument which\n // indicates which kind of object file is to be built. Currently supported values\n@@ -939,6 +952,45 @@\n // \t\timport, into a Go plugin. Packages not named main are ignored.\n //\n //\n+// Build and test caching\n+//\n+// The go command caches build outputs for reuse in future builds.\n+// The default location for cache data is a subdirectory named go-build\n+// in the standard user cache directory for the current operating system.\n+// Setting the GOCACHE environment variable overrides this default,\n+// and running 'go env GOCACHE' prints the current cache directory.\n+//\n+// The go command periodically deletes cached data that has not been\n+// used recently. Running 'go clean -cache' deletes all cached data.\n+//\n+// The build cache correctly accounts for changes to Go source files,\n+// compilers, compiler options, and so on: cleaning the cache explicitly\n+// should not be necessary in typical use. However, the build cache\n+// does not detect changes to C libraries imported with cgo.\n+// If you have made changes to the C libraries on your system, you\n+// will need to clean the cache explicitly or else use the -a build flag\n+// (see 'go help build') to force rebuilding of packages that\n+// depend on the updated C libraries.\n+//\n+// The go command also caches successful package test results.\n+// See 'go help test' for details. Running 'go clean -testcache' removes\n+// all cached test results (but not cached build results).\n+//\n+// The GODEBUG environment variable can enable printing of debugging\n+// information about the state of the cache:\n+//\n+// GODEBUG=gocacheverify=1 causes the go command to bypass the\n+// use of any cache entries and instead rebuild everything and check\n+// that the results match existing cache entries.\n+//\n+// GODEBUG=gocachehash=1 causes the go command to print the inputs\n+// for all of the content hashes it uses to construct cache lookup keys.\n+// The output is voluminous but can be useful for debugging the cache.\n+//\n+// GODEBUG=gocachetest=1 causes the go command to print details of its\n+// decisions about whether to reuse a cached test result.\n+//\n+//\n // File types\n //\n // The go command examines the contents of a restricted set of files\n@@ -1396,7 +1448,7 @@\n // See https://golang.org/s/go14customimport for details.\n //\n //\n-// Description of package lists\n+// Package lists\n //\n // Many commands apply to a set of packages:\n //\n@@ -1478,7 +1530,7 @@\n // by the go tool, as are directories named \"testdata\".\n //\n //\n-// Description of testing flags\n+// Testing flags\n //\n // The 'go test' command takes both flags that apply to 'go test' itself\n // and flags that apply to the resulting test binary.\n@@ -1705,7 +1757,7 @@\n // binary, instead of being interpreted as the package list.\n //\n //\n-// Description of testing functions\n+// Testing functions\n //\n // The 'go test' command expects to find test, benchmark, and example functions\n // in the \"*_test.go\" files corresponding to the package under test."}, {"sha": "41a37a575b64173eaf8323faee6c690e66028a36", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -2461,6 +2461,17 @@ func TestCoverageRuns(t *testing.T) {\n \tcheckCoverage(tg, data)\n }\n \n+func TestCoverageDotImport(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"test\", \"-coverpkg=coverdot1,coverdot2\", \"coverdot2\")\n+\tdata := tg.getStdout() + tg.getStderr()\n+\tcheckCoverage(tg, data)\n+}\n+\n // Check that coverage analysis uses set mode.\n // Also check that coverage profiles merge correctly.\n func TestCoverageUsesSetMode(t *testing.T) {\n@@ -3243,6 +3254,16 @@ func TestGoVetWithFlagsOff(t *testing.T) {\n \ttg.run(\"vet\", \"-printf=false\", \"vetpkg\")\n }\n \n+// Issue 23395.\n+func TestGoVetWithOnlyTestFiles(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/p/p_test.go\", \"package p; import \\\"testing\\\"; func TestMe(*testing.T) {}\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"vet\", \"p\")\n+}\n+\n // Issue 9767, 19769.\n func TestGoGetDotSlashDownload(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)"}, {"sha": "8285f787d4c9cae46b178f6ecee94ae538fdcfbe", "filename": "libgo/go/cmd/go/internal/cache/default.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -68,6 +68,11 @@ func DefaultDir() string {\n \tswitch runtime.GOOS {\n \tcase \"windows\":\n \t\tdir = os.Getenv(\"LocalAppData\")\n+\t\tif dir == \"\" {\n+\t\t\t// Fall back to %AppData%, the old name of\n+\t\t\t// %LocalAppData% on Windows XP.\n+\t\t\tdir = os.Getenv(\"AppData\")\n+\t\t}\n \t\tif dir == \"\" {\n \t\t\treturn \"off\"\n \t\t}"}, {"sha": "126e8663fb43d20a12ce560f573e809c4bf78f19", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -30,7 +30,7 @@ the C or C++ compiler, respectively, to use.\n \n var HelpPackages = &base.Command{\n \tUsageLine: \"packages\",\n-\tShort:     \"description of package lists\",\n+\tShort:     \"package lists\",\n \tLong: `\n Many commands apply to a set of packages:\n \n@@ -586,7 +586,7 @@ command.\n \n var HelpBuildmode = &base.Command{\n \tUsageLine: \"buildmode\",\n-\tShort:     \"description of build modes\",\n+\tShort:     \"build modes\",\n \tLong: `\n The 'go build' and 'go install' commands take a -buildmode argument which\n indicates which kind of object file is to be built. Currently supported values\n@@ -632,3 +632,45 @@ are:\n \t\timport, into a Go plugin. Packages not named main are ignored.\n `,\n }\n+\n+var HelpCache = &base.Command{\n+\tUsageLine: \"cache\",\n+\tShort:     \"build and test caching\",\n+\tLong: `\n+The go command caches build outputs for reuse in future builds.\n+The default location for cache data is a subdirectory named go-build\n+in the standard user cache directory for the current operating system.\n+Setting the GOCACHE environment variable overrides this default,\n+and running 'go env GOCACHE' prints the current cache directory.\n+\n+The go command periodically deletes cached data that has not been\n+used recently. Running 'go clean -cache' deletes all cached data.\n+\n+The build cache correctly accounts for changes to Go source files,\n+compilers, compiler options, and so on: cleaning the cache explicitly\n+should not be necessary in typical use. However, the build cache\n+does not detect changes to C libraries imported with cgo.\n+If you have made changes to the C libraries on your system, you\n+will need to clean the cache explicitly or else use the -a build flag\n+(see 'go help build') to force rebuilding of packages that\n+depend on the updated C libraries.\n+\n+The go command also caches successful package test results.\n+See 'go help test' for details. Running 'go clean -testcache' removes\n+all cached test results (but not cached build results).\n+\n+The GODEBUG environment variable can enable printing of debugging\n+information about the state of the cache:\n+\n+GODEBUG=gocacheverify=1 causes the go command to bypass the\n+use of any cache entries and instead rebuild everything and check\n+that the results match existing cache entries.\n+\n+GODEBUG=gocachehash=1 causes the go command to print the inputs\n+for all of the content hashes it uses to construct cache lookup keys.\n+The output is voluminous but can be useful for debugging the cache.\n+\n+GODEBUG=gocachetest=1 causes the go command to print details of its\n+decisions about whether to reuse a cached test result.\n+`,\n+}"}, {"sha": "609a47db4bc4b072a1abfa669320a0d4145508fd", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -1526,3 +1526,153 @@ func GoFilesPackage(gofiles []string) *Package {\n \n \treturn pkg\n }\n+\n+// GetTestPackagesFor returns package structs ptest, the package p plus\n+// its test files, and pxtest, the external tests of package p.\n+// pxtest may be nil. If there are no test files, forceTest decides\n+// whether this returns a new package struct or just returns p.\n+func GetTestPackagesFor(p *Package, forceTest bool) (ptest, pxtest *Package, err error) {\n+\tvar imports, ximports []*Package\n+\tvar stk ImportStack\n+\tstk.Push(p.ImportPath + \" (test)\")\n+\trawTestImports := str.StringList(p.TestImports)\n+\tfor i, path := range p.TestImports {\n+\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], UseVendor)\n+\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif p1.Error != nil {\n+\t\t\treturn nil, nil, p1.Error\n+\t\t}\n+\t\tif len(p1.DepsErrors) > 0 {\n+\t\t\terr := p1.DepsErrors[0]\n+\t\t\terr.Pos = \"\" // show full import stack\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tif str.Contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {\n+\t\t\t// Same error that loadPackage returns (via reusePackage) in pkg.go.\n+\t\t\t// Can't change that code, because that code is only for loading the\n+\t\t\t// non-test copy of a package.\n+\t\t\terr := &PackageError{\n+\t\t\t\tImportStack:   testImportStack(stk[0], p1, p.ImportPath),\n+\t\t\t\tErr:           \"import cycle not allowed in test\",\n+\t\t\t\tIsImportCycle: true,\n+\t\t\t}\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tp.TestImports[i] = p1.ImportPath\n+\t\timports = append(imports, p1)\n+\t}\n+\tstk.Pop()\n+\tstk.Push(p.ImportPath + \"_test\")\n+\tpxtestNeedsPtest := false\n+\trawXTestImports := str.StringList(p.XTestImports)\n+\tfor i, path := range p.XTestImports {\n+\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], UseVendor)\n+\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif p1.Error != nil {\n+\t\t\treturn nil, nil, p1.Error\n+\t\t}\n+\t\tif len(p1.DepsErrors) > 0 {\n+\t\t\terr := p1.DepsErrors[0]\n+\t\t\terr.Pos = \"\" // show full import stack\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tif p1.ImportPath == p.ImportPath {\n+\t\t\tpxtestNeedsPtest = true\n+\t\t} else {\n+\t\t\tximports = append(ximports, p1)\n+\t\t}\n+\t\tp.XTestImports[i] = p1.ImportPath\n+\t}\n+\tstk.Pop()\n+\n+\t// Test package.\n+\tif len(p.TestGoFiles) > 0 || forceTest {\n+\t\tptest = new(Package)\n+\t\t*ptest = *p\n+\t\tptest.GoFiles = nil\n+\t\tptest.GoFiles = append(ptest.GoFiles, p.GoFiles...)\n+\t\tptest.GoFiles = append(ptest.GoFiles, p.TestGoFiles...)\n+\t\tptest.Target = \"\"\n+\t\t// Note: The preparation of the vet config requires that common\n+\t\t// indexes in ptest.Imports, ptest.Internal.Imports, and ptest.Internal.RawImports\n+\t\t// all line up (but RawImports can be shorter than the others).\n+\t\t// That is, for 0 \u2264 i < len(RawImports),\n+\t\t// RawImports[i] is the import string in the program text,\n+\t\t// Imports[i] is the expanded import string (vendoring applied or relative path expanded away),\n+\t\t// and Internal.Imports[i] is the corresponding *Package.\n+\t\t// Any implicitly added imports appear in Imports and Internal.Imports\n+\t\t// but not RawImports (because they were not in the source code).\n+\t\t// We insert TestImports, imports, and rawTestImports at the start of\n+\t\t// these lists to preserve the alignment.\n+\t\tptest.Imports = str.StringList(p.TestImports, p.Imports)\n+\t\tptest.Internal.Imports = append(imports, p.Internal.Imports...)\n+\t\tptest.Internal.RawImports = str.StringList(rawTestImports, p.Internal.RawImports)\n+\t\tptest.Internal.ForceLibrary = true\n+\t\tptest.Internal.Build = new(build.Package)\n+\t\t*ptest.Internal.Build = *p.Internal.Build\n+\t\tm := map[string][]token.Position{}\n+\t\tfor k, v := range p.Internal.Build.ImportPos {\n+\t\t\tm[k] = append(m[k], v...)\n+\t\t}\n+\t\tfor k, v := range p.Internal.Build.TestImportPos {\n+\t\t\tm[k] = append(m[k], v...)\n+\t\t}\n+\t\tptest.Internal.Build.ImportPos = m\n+\t} else {\n+\t\tptest = p\n+\t}\n+\n+\t// External test package.\n+\tif len(p.XTestGoFiles) > 0 {\n+\t\tpxtest = &Package{\n+\t\t\tPackagePublic: PackagePublic{\n+\t\t\t\tName:       p.Name + \"_test\",\n+\t\t\t\tImportPath: p.ImportPath + \"_test\",\n+\t\t\t\tRoot:       p.Root,\n+\t\t\t\tDir:        p.Dir,\n+\t\t\t\tGoFiles:    p.XTestGoFiles,\n+\t\t\t\tImports:    p.XTestImports,\n+\t\t\t},\n+\t\t\tInternal: PackageInternal{\n+\t\t\t\tLocalPrefix: p.Internal.LocalPrefix,\n+\t\t\t\tBuild: &build.Package{\n+\t\t\t\t\tImportPos: p.Internal.Build.XTestImportPos,\n+\t\t\t\t},\n+\t\t\t\tImports:    ximports,\n+\t\t\t\tRawImports: rawXTestImports,\n+\n+\t\t\t\tAsmflags:   p.Internal.Asmflags,\n+\t\t\t\tGcflags:    p.Internal.Gcflags,\n+\t\t\t\tLdflags:    p.Internal.Ldflags,\n+\t\t\t\tGccgoflags: p.Internal.Gccgoflags,\n+\t\t\t},\n+\t\t}\n+\t\tif pxtestNeedsPtest {\n+\t\t\tpxtest.Internal.Imports = append(pxtest.Internal.Imports, ptest)\n+\t\t}\n+\t}\n+\n+\treturn ptest, pxtest, nil\n+}\n+\n+func testImportStack(top string, p *Package, target string) []string {\n+\tstk := []string{top, p.ImportPath}\n+Search:\n+\tfor p.ImportPath != target {\n+\t\tfor _, p1 := range p.Internal.Imports {\n+\t\t\tif p1.ImportPath == target || str.Contains(p1.Deps, target) {\n+\t\t\t\tstk = append(stk, p1.ImportPath)\n+\t\t\t\tp = p1\n+\t\t\t\tcontinue Search\n+\t\t\t}\n+\t\t}\n+\t\t// Can't happen, but in case it does...\n+\t\tstk = append(stk, \"<lost path to cycle>\")\n+\t\tbreak\n+\t}\n+\treturn stk\n+}"}, {"sha": "e77e834cb23989888440f7c02b3c2ed94996f89c", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 67, "deletions": 182, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -6,6 +6,7 @@ package test\n \n import (\n \t\"bytes\"\n+\t\"crypto/sha256\"\n \t\"errors\"\n \t\"fmt\"\n \t\"go/ast\"\n@@ -79,39 +80,51 @@ finds any problems, go test reports those and does not run the test binary.\n Only a high-confidence subset of the default go vet checks are used.\n To disable the running of go vet, use the -vet=off flag.\n \n-Go test runs in two different modes: local directory mode when invoked with\n-no package arguments (for example, 'go test'), and package list mode when\n-invoked with package arguments (for example 'go test math', 'go test ./...',\n-and even 'go test .').\n-\n-In local directory mode, go test compiles and tests the package sources\n-found in the current directory and then runs the resulting test binary.\n-In this mode, caching (discussed below) is disabled. After the package test\n-finishes, go test prints a summary line showing the test status ('ok' or 'FAIL'),\n-package name, and elapsed time.\n-\n-In package list mode, go test compiles and tests each of the packages\n-listed on the command line. If a package test passes, go test prints only\n-the final 'ok' summary line. If a package test fails, go test prints the\n-full test output. If invoked with the -bench or -v flag, go test prints\n-the full output even for passing package tests, in order to display the\n+All test output and summary lines are printed to the go command's\n+standard output, even if the test printed them to its own standard\n+error. (The go command's standard error is reserved for printing\n+errors building the tests.)\n+\n+Go test runs in two different modes:\n+\n+The first, called local directory mode, occurs when go test is\n+invoked with no package arguments (for example, 'go test' or 'go\n+test -v'). In this mode, go test compiles the package sources and\n+tests found in the current directory and then runs the resulting\n+test binary. In this mode, caching (discussed below) is disabled.\n+After the package test finishes, go test prints a summary line\n+showing the test status ('ok' or 'FAIL'), package name, and elapsed\n+time.\n+\n+The second, called package list mode, occurs when go test is invoked\n+with explicit package arguments (for example 'go test math', 'go\n+test ./...', and even 'go test .'). In this mode, go test compiles\n+and tests each of the packages listed on the command line. If a\n+package test passes, go test prints only the final 'ok' summary\n+line. If a package test fails, go test prints the full test output.\n+If invoked with the -bench or -v flag, go test prints the full\n+output even for passing package tests, in order to display the\n requested benchmark results or verbose logging.\n \n-All test output and summary lines are printed to the go command's standard\n-output, even if the test printed them to its own standard error.\n-(The go command's standard error is reserved for printing errors building\n-the tests.)\n-\n-In package list mode, go test also caches successful package test results.\n-If go test has cached a previous test run using the same test binary and\n-the same command line consisting entirely of cacheable test flags\n-(defined as -cpu, -list, -parallel, -run, -short, and -v),\n-go test will redisplay the previous output instead of running the test\n-binary again. In the summary line, go test prints '(cached)' in place of\n-the elapsed time. To disable test caching, use any test flag or argument\n-other than the cacheable flags. The idiomatic way to disable test caching\n-explicitly is to use -count=1. A cached result is treated as executing in\n-no time at all, so a successful package test result will be cached and reused\n+In package list mode only, go test caches successful package test\n+results to avoid unnecessary repeated running of tests. When the\n+result of a test can be recovered from the cache, go test will\n+redisplay the previous output instead of running the test binary\n+again. When this happens, go test prints '(cached)' in place of the\n+elapsed time in the summary line.\n+\n+The rule for a match in the cache is that the run involves the same\n+test binary and the flags on the command line come entirely from a\n+restricted set of 'cacheable' test flags, defined as -cpu, -list,\n+-parallel, -run, -short, and -v. If a run of go test has any test\n+or non-test flags outside this set, the result is not cached. To\n+disable test caching, use any test flag or argument other than the\n+cacheable flags. The idiomatic way to disable test caching explicitly\n+is to use -count=1. Tests that open files within the package's source\n+root (usually $GOPATH) or that consult environment variables only\n+match future runs in which the files and environment variables are unchanged.\n+A cached test result is treated as executing in no time at all,\n+so a successful package test result will be cached and reused\n regardless of -timeout setting.\n \n ` + strings.TrimSpace(testFlag1) + ` See 'go help testflag' for details.\n@@ -167,7 +180,7 @@ func Usage() {\n \n var HelpTestflag = &base.Command{\n \tUsageLine: \"testflag\",\n-\tShort:     \"description of testing flags\",\n+\tShort:     \"testing flags\",\n \tLong: `\n The 'go test' command takes both flags that apply to 'go test' itself\n and flags that apply to the resulting test binary.\n@@ -401,7 +414,7 @@ binary, instead of being interpreted as the package list.\n \n var HelpTestfunc = &base.Command{\n \tUsageLine: \"testfunc\",\n-\tShort:     \"description of testing functions\",\n+\tShort:     \"testing functions\",\n \tLong: `\n The 'go test' command expects to find test, benchmark, and example functions\n in the \"*_test.go\" files corresponding to the package under test.\n@@ -771,62 +784,12 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t//\tpmain - pkg.test binary\n \tvar ptest, pxtest, pmain *load.Package\n \n-\tvar imports, ximports []*load.Package\n-\tvar stk load.ImportStack\n-\tstk.Push(p.ImportPath + \" (test)\")\n-\trawTestImports := str.StringList(p.TestImports)\n-\tfor i, path := range p.TestImports {\n-\t\tp1 := load.LoadImport(path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], load.UseVendor)\n-\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif p1.Error != nil {\n-\t\t\treturn nil, nil, nil, p1.Error\n-\t\t}\n-\t\tif len(p1.DepsErrors) > 0 {\n-\t\t\terr := p1.DepsErrors[0]\n-\t\t\terr.Pos = \"\" // show full import stack\n-\t\t\treturn nil, nil, nil, err\n-\t\t}\n-\t\tif str.Contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {\n-\t\t\t// Same error that loadPackage returns (via reusePackage) in pkg.go.\n-\t\t\t// Can't change that code, because that code is only for loading the\n-\t\t\t// non-test copy of a package.\n-\t\t\terr := &load.PackageError{\n-\t\t\t\tImportStack:   testImportStack(stk[0], p1, p.ImportPath),\n-\t\t\t\tErr:           \"import cycle not allowed in test\",\n-\t\t\t\tIsImportCycle: true,\n-\t\t\t}\n-\t\t\treturn nil, nil, nil, err\n-\t\t}\n-\t\tp.TestImports[i] = p1.ImportPath\n-\t\timports = append(imports, p1)\n-\t}\n-\tstk.Pop()\n-\tstk.Push(p.ImportPath + \"_test\")\n-\tpxtestNeedsPtest := false\n-\trawXTestImports := str.StringList(p.XTestImports)\n-\tfor i, path := range p.XTestImports {\n-\t\tp1 := load.LoadImport(path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], load.UseVendor)\n-\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif p1.Error != nil {\n-\t\t\treturn nil, nil, nil, p1.Error\n-\t\t}\n-\t\tif len(p1.DepsErrors) > 0 {\n-\t\t\terr := p1.DepsErrors[0]\n-\t\t\terr.Pos = \"\" // show full import stack\n-\t\t\treturn nil, nil, nil, err\n-\t\t}\n-\t\tif p1.ImportPath == p.ImportPath {\n-\t\t\tpxtestNeedsPtest = true\n-\t\t} else {\n-\t\t\tximports = append(ximports, p1)\n-\t\t}\n-\t\tp.XTestImports[i] = p1.ImportPath\n+\tlocalCover := testCover && testCoverPaths == nil\n+\n+\tptest, pxtest, err = load.GetTestPackagesFor(p, localCover || p.Name == \"main\")\n+\tif err != nil {\n+\t\treturn nil, nil, nil, err\n \t}\n-\tstk.Pop()\n \n \t// Use last element of import path, not package name.\n \t// They differ when package name is \"main\".\n@@ -844,81 +807,12 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t// only for this package and only for this test?\n \t// Yes, if -cover is on but -coverpkg has not specified\n \t// a list of packages for global coverage.\n-\tlocalCover := testCover && testCoverPaths == nil\n-\n-\t// Test package.\n-\tif len(p.TestGoFiles) > 0 || localCover || p.Name == \"main\" {\n-\t\tptest = new(load.Package)\n-\t\t*ptest = *p\n-\t\tptest.GoFiles = nil\n-\t\tptest.GoFiles = append(ptest.GoFiles, p.GoFiles...)\n-\t\tptest.GoFiles = append(ptest.GoFiles, p.TestGoFiles...)\n-\t\tptest.Target = \"\"\n-\t\t// Note: The preparation of the vet config requires that common\n-\t\t// indexes in ptest.Imports, ptest.Internal.Imports, and ptest.Internal.RawImports\n-\t\t// all line up (but RawImports can be shorter than the others).\n-\t\t// That is, for 0 \u2264 i < len(RawImports),\n-\t\t// RawImports[i] is the import string in the program text,\n-\t\t// Imports[i] is the expanded import string (vendoring applied or relative path expanded away),\n-\t\t// and Internal.Imports[i] is the corresponding *Package.\n-\t\t// Any implicitly added imports appear in Imports and Internal.Imports\n-\t\t// but not RawImports (because they were not in the source code).\n-\t\t// We insert TestImports, imports, and rawTestImports at the start of\n-\t\t// these lists to preserve the alignment.\n-\t\tptest.Imports = str.StringList(p.TestImports, p.Imports)\n-\t\tptest.Internal.Imports = append(imports, p.Internal.Imports...)\n-\t\tptest.Internal.RawImports = str.StringList(rawTestImports, p.Internal.RawImports)\n-\t\tptest.Internal.ForceLibrary = true\n-\t\tptest.Internal.Build = new(build.Package)\n-\t\t*ptest.Internal.Build = *p.Internal.Build\n-\t\tm := map[string][]token.Position{}\n-\t\tfor k, v := range p.Internal.Build.ImportPos {\n-\t\t\tm[k] = append(m[k], v...)\n-\t\t}\n-\t\tfor k, v := range p.Internal.Build.TestImportPos {\n-\t\t\tm[k] = append(m[k], v...)\n-\t\t}\n-\t\tptest.Internal.Build.ImportPos = m\n-\n-\t\tif localCover {\n-\t\t\tptest.Internal.CoverMode = testCoverMode\n-\t\t\tvar coverFiles []string\n-\t\t\tcoverFiles = append(coverFiles, ptest.GoFiles...)\n-\t\t\tcoverFiles = append(coverFiles, ptest.CgoFiles...)\n-\t\t\tptest.Internal.CoverVars = declareCoverVars(ptest.ImportPath, coverFiles...)\n-\t\t}\n-\t} else {\n-\t\tptest = p\n-\t}\n-\n-\t// External test package.\n-\tif len(p.XTestGoFiles) > 0 {\n-\t\tpxtest = &load.Package{\n-\t\t\tPackagePublic: load.PackagePublic{\n-\t\t\t\tName:       p.Name + \"_test\",\n-\t\t\t\tImportPath: p.ImportPath + \"_test\",\n-\t\t\t\tRoot:       p.Root,\n-\t\t\t\tDir:        p.Dir,\n-\t\t\t\tGoFiles:    p.XTestGoFiles,\n-\t\t\t\tImports:    p.XTestImports,\n-\t\t\t},\n-\t\t\tInternal: load.PackageInternal{\n-\t\t\t\tLocalPrefix: p.Internal.LocalPrefix,\n-\t\t\t\tBuild: &build.Package{\n-\t\t\t\t\tImportPos: p.Internal.Build.XTestImportPos,\n-\t\t\t\t},\n-\t\t\t\tImports:    ximports,\n-\t\t\t\tRawImports: rawXTestImports,\n-\n-\t\t\t\tAsmflags:   p.Internal.Asmflags,\n-\t\t\t\tGcflags:    p.Internal.Gcflags,\n-\t\t\t\tLdflags:    p.Internal.Ldflags,\n-\t\t\t\tGccgoflags: p.Internal.Gccgoflags,\n-\t\t\t},\n-\t\t}\n-\t\tif pxtestNeedsPtest {\n-\t\t\tpxtest.Internal.Imports = append(pxtest.Internal.Imports, ptest)\n-\t\t}\n+\tif localCover {\n+\t\tptest.Internal.CoverMode = testCoverMode\n+\t\tvar coverFiles []string\n+\t\tcoverFiles = append(coverFiles, ptest.GoFiles...)\n+\t\tcoverFiles = append(coverFiles, ptest.CgoFiles...)\n+\t\tptest.Internal.CoverVars = declareCoverVars(ptest.ImportPath, coverFiles...)\n \t}\n \n \ttestDir := b.NewObjdir()\n@@ -948,6 +842,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \n \t// The generated main also imports testing, regexp, and os.\n \t// Also the linker introduces implicit dependencies reported by LinkerDeps.\n+\tvar stk load.ImportStack\n \tstk.Push(\"testmain\")\n \tdeps := testMainDeps // cap==len, so safe for append\n \tfor _, d := range load.LinkerDeps(p) {\n@@ -1153,24 +1048,6 @@ func addTestVet(b *work.Builder, p *load.Package, runAction, installAction *work\n \t}\n }\n \n-func testImportStack(top string, p *load.Package, target string) []string {\n-\tstk := []string{top, p.ImportPath}\n-Search:\n-\tfor p.ImportPath != target {\n-\t\tfor _, p1 := range p.Internal.Imports {\n-\t\t\tif p1.ImportPath == target || str.Contains(p1.Deps, target) {\n-\t\t\t\tstk = append(stk, p1.ImportPath)\n-\t\t\t\tp = p1\n-\t\t\t\tcontinue Search\n-\t\t\t}\n-\t\t}\n-\t\t// Can't happen, but in case it does...\n-\t\tstk = append(stk, \"<lost path to cycle>\")\n-\t\tbreak\n-\t}\n-\treturn stk\n-}\n-\n func recompileForTest(pmain, preal, ptest, pxtest *load.Package) {\n \t// The \"test copy\" of preal is ptest.\n \t// For each package that depends on preal, make a \"test copy\"\n@@ -1221,13 +1098,21 @@ func isTestFile(file string) bool {\n func declareCoverVars(importPath string, files ...string) map[string]*load.CoverVar {\n \tcoverVars := make(map[string]*load.CoverVar)\n \tcoverIndex := 0\n+\t// We create the cover counters as new top-level variables in the package.\n+\t// We need to avoid collisions with user variables (GoCover_0 is unlikely but still)\n+\t// and more importantly with dot imports of other covered packages,\n+\t// so we append 12 hex digits from the SHA-256 of the import path.\n+\t// The point is only to avoid accidents, not to defeat users determined to\n+\t// break things.\n+\tsum := sha256.Sum256([]byte(importPath))\n+\th := fmt.Sprintf(\"%x\", sum[:6])\n \tfor _, file := range files {\n \t\tif isTestFile(file) {\n \t\t\tcontinue\n \t\t}\n \t\tcoverVars[file] = &load.CoverVar{\n \t\t\tFile: filepath.Join(importPath, file),\n-\t\t\tVar:  fmt.Sprintf(\"GoCover_%d\", coverIndex),\n+\t\t\tVar:  fmt.Sprintf(\"GoCover_%d_%x\", coverIndex, h),\n \t\t}\n \t\tcoverIndex++\n \t}"}, {"sha": "07eed89458666db7973e4e6a581b6cf9f8b25186", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -57,7 +57,21 @@ func runVet(cmd *base.Command, args []string) {\n \n \troot := &work.Action{Mode: \"go vet\"}\n \tfor _, p := range pkgs {\n-\t\troot.Deps = append(root.Deps, b.VetAction(work.ModeBuild, work.ModeBuild, p))\n+\t\tptest, pxtest, err := load.GetTestPackagesFor(p, false)\n+\t\tif err != nil {\n+\t\t\tbase.Errorf(\"%v\", err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif len(ptest.GoFiles) == 0 && pxtest == nil {\n+\t\t\tbase.Errorf(\"go vet %s: no Go files in %s\", p.ImportPath, p.Dir)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif len(ptest.GoFiles) > 0 {\n+\t\t\troot.Deps = append(root.Deps, b.VetAction(work.ModeBuild, work.ModeBuild, ptest))\n+\t\t}\n+\t\tif pxtest != nil {\n+\t\t\troot.Deps = append(root.Deps, b.VetAction(work.ModeBuild, work.ModeBuild, pxtest))\n+\t\t}\n \t}\n \tb.Do(root)\n }"}, {"sha": "803a6bd4611c3d1cd8e8e1a6101e4b2075b7b592", "filename": "libgo/go/cmd/go/internal/work/action.go", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -652,11 +652,9 @@ func (b *Builder) linkSharedAction(mode, depMode BuildMode, shlib string, a1 *Ac\n \t\t// it is not present in another shared library, add it here.\n \t\t// TODO(rsc): Maybe this should only happen if \"runtime\" is in the original package set.\n \t\t// TODO(rsc): This should probably be changed to use load.LinkerDeps(p).\n-\t\t// TODO(rsc): Find out and explain here why gccgo is excluded.\n-\t\t// If the answer is that gccgo is different in implicit linker deps, maybe\n-\t\t// load.LinkerDeps should be used and updated.\n-\t\t// Link packages into a shared library.\n-\n+\t\t// TODO(rsc): We don't add standard library imports for gccgo\n+\t\t// because they are all always linked in anyhow.\n+\t\t// Maybe load.LinkerDeps should be used and updated.\n \t\ta := &Action{\n \t\t\tMode:    \"go build -buildmode=shared\",\n \t\t\tPackage: p,"}, {"sha": "b58749827083ba7b0ad25932b4c842e416b5ea46", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -308,7 +308,7 @@ func (b *Builder) build(a *Action) (err error) {\n \t\t\t// Need to look for install header actions depending on this action,\n \t\t\t// or depending on a link that depends on this action.\n \t\t\tneedHeader := false\n-\t\t\tif (a.Package.UsesCgo() || a.Package.UsesSwig()) && (cfg.BuildBuildmode == \"c-archive\" || cfg.BuildBuildmode == \"c-header\") {\n+\t\t\tif (a.Package.UsesCgo() || a.Package.UsesSwig()) && (cfg.BuildBuildmode == \"c-archive\" || cfg.BuildBuildmode == \"c-shared\") {\n \t\t\t\tfor _, t1 := range a.triggers {\n \t\t\t\t\tif t1.Mode == \"install header\" {\n \t\t\t\t\t\tneedHeader = true"}, {"sha": "8f5584607052b8779353825caa27cac5d1c468c2", "filename": "libgo/go/cmd/go/internal/work/gccgo.go", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -206,7 +206,6 @@ func (gccgoToolchain) pack(b *Builder, a *Action, afile string, ofiles []string)\n func (tools gccgoToolchain) link(b *Builder, root *Action, out, importcfg string, allactions []*Action, buildmode, desc string) error {\n \t// gccgo needs explicit linking with all package dependencies,\n \t// and all LDFLAGS from cgo dependencies.\n-\tapackagePathsSeen := make(map[string]bool)\n \tafiles := []string{}\n \tshlibs := []string{}\n \tldflags := b.gccArchArgs()\n@@ -294,56 +293,57 @@ func (tools gccgoToolchain) link(b *Builder, root *Action, out, importcfg string\n \t\treturn newArchive, nil\n \t}\n \n-\tactionsSeen := make(map[*Action]bool)\n-\t// Make a pre-order depth-first traversal of the action graph, taking note of\n-\t// whether a shared library action has been seen on the way to an action (the\n-\t// construction of the graph means that if any path to a node passes through\n-\t// a shared library action, they all do).\n-\tvar walk func(a *Action, seenShlib bool)\n-\tvar err error\n-\twalk = func(a *Action, seenShlib bool) {\n-\t\tif actionsSeen[a] {\n-\t\t\treturn\n-\t\t}\n-\t\tactionsSeen[a] = true\n-\t\tif a.Package != nil && !seenShlib {\n-\t\t\tif a.Package.Standard {\n-\t\t\t\treturn\n+\t// If using -linkshared, find the shared library deps.\n+\thaveShlib := make(map[string]bool)\n+\ttargetBase := filepath.Base(root.Target)\n+\tif cfg.BuildLinkshared {\n+\t\tfor _, a := range root.Deps {\n+\t\t\tp := a.Package\n+\t\t\tif p == nil || p.Shlib == \"\" {\n+\t\t\t\tcontinue\n \t\t\t}\n-\t\t\t// We record the target of the first time we see a .a file\n-\t\t\t// for a package to make sure that we prefer the 'install'\n-\t\t\t// rather than the 'build' location (which may not exist any\n-\t\t\t// more). We still need to traverse the dependencies of the\n-\t\t\t// build action though so saying\n-\t\t\t// if apackagePathsSeen[a.Package.ImportPath] { return }\n-\t\t\t// doesn't work.\n-\t\t\tif !apackagePathsSeen[a.Package.ImportPath] {\n-\t\t\t\tapackagePathsSeen[a.Package.ImportPath] = true\n-\t\t\t\ttarget := a.built\n-\t\t\t\tif len(a.Package.CgoFiles) > 0 || a.Package.UsesSwig() {\n-\t\t\t\t\ttarget, err = readAndRemoveCgoFlags(target)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\treturn\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tafiles = append(afiles, target)\n+\n+\t\t\t// The .a we are linking into this .so\n+\t\t\t// will have its Shlib set to this .so.\n+\t\t\t// Don't start thinking we want to link\n+\t\t\t// this .so into itself.\n+\t\t\tbase := filepath.Base(p.Shlib)\n+\t\t\tif base != targetBase {\n+\t\t\t\thaveShlib[base] = true\n \t\t\t}\n \t\t}\n-\t\tif strings.HasSuffix(a.Target, \".so\") {\n-\t\t\tshlibs = append(shlibs, a.Target)\n-\t\t\tseenShlib = true\n+\t}\n+\n+\t// Arrange the deps into afiles and shlibs.\n+\taddedShlib := make(map[string]bool)\n+\tfor _, a := range root.Deps {\n+\t\tp := a.Package\n+\t\tif p != nil && p.Shlib != \"\" && haveShlib[filepath.Base(p.Shlib)] {\n+\t\t\t// This is a package linked into a shared\n+\t\t\t// library that we will put into shlibs.\n+\t\t\tcontinue\n \t\t}\n-\t\tfor _, a1 := range a.Deps {\n-\t\t\twalk(a1, seenShlib)\n-\t\t\tif err != nil {\n-\t\t\t\treturn\n+\n+\t\tif haveShlib[filepath.Base(a.Target)] {\n+\t\t\t// This is a shared library we want to link againt.\n+\t\t\tif !addedShlib[a.Target] {\n+\t\t\t\tshlibs = append(shlibs, a.Target)\n+\t\t\t\taddedShlib[a.Target] = true\n \t\t\t}\n+\t\t\tcontinue\n \t\t}\n-\t}\n-\tfor _, a1 := range root.Deps {\n-\t\twalk(a1, false)\n-\t\tif err != nil {\n-\t\t\treturn err\n+\n+\t\tif p != nil {\n+\t\t\ttarget := a.built\n+\t\t\tif p.UsesCgo() || p.UsesSwig() {\n+\t\t\t\tvar err error\n+\t\t\t\ttarget, err = readAndRemoveCgoFlags(target)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tafiles = append(afiles, target)\n \t\t}\n \t}\n \n@@ -511,9 +511,7 @@ func (tools gccgoToolchain) ld(b *Builder, root *Action, out, importcfg, mainpkg\n }\n \n func (tools gccgoToolchain) ldShared(b *Builder, root *Action, toplevelactions []*Action, out, importcfg string, allactions []*Action) error {\n-\tfakeRoot := *root\n-\tfakeRoot.Deps = toplevelactions\n-\treturn tools.link(b, &fakeRoot, out, importcfg, allactions, \"shared\", out)\n+\treturn tools.link(b, root, out, importcfg, allactions, \"shared\", out)\n }\n \n func (tools gccgoToolchain) cc(b *Builder, a *Action, ofile, cfile string) error {"}, {"sha": "7558e087673fdbbcdacf61c27bab11066abb8de3", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -56,6 +56,7 @@ func init() {\n \n \t\thelp.HelpC,\n \t\thelp.HelpBuildmode,\n+\t\thelp.HelpCache,\n \t\thelp.HelpFileType,\n \t\thelp.HelpGopath,\n \t\thelp.HelpEnvironment,"}, {"sha": "9477e85b95167a8b9d2d1a7b3bd9797f023860cd", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -781,7 +781,17 @@ func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *V\n // If opts.Roots is nil and system roots are unavailable the returned error\n // will be of type SystemRootsError.\n //\n-// WARNING: this doesn't do any revocation checking.\n+// Name constraints in the intermediates will be applied to all names claimed\n+// in the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim\n+// example.com if an intermediate doesn't permit it, even if example.com is not\n+// the name being validated. Note that DirectoryName constraints are not\n+// supported.\n+//\n+// Extended Key Usage values are enforced down a chain, so an intermediate or\n+// root that enumerates EKUs prevents a leaf from asserting an EKU not in that\n+// list.\n+//\n+// WARNING: this function doesn't do any revocation checking.\n func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error) {\n \t// Platform-specific verification needs the ASN.1 contents so\n \t// this makes the behavior consistent across platforms."}, {"sha": "b0aff7b1685cdb9f16aedef1c2dd1a4935b502e4", "filename": "libgo/go/database/sql/convert_test.go", "status": "modified", "additions": 123, "deletions": 120, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -64,125 +64,128 @@ var (\n \tscaniface  interface{}\n )\n \n-var conversionTests = []conversionTest{\n-\t// Exact conversions (destination pointer type matches source type)\n-\t{s: \"foo\", d: &scanstr, wantstr: \"foo\"},\n-\t{s: 123, d: &scanint, wantint: 123},\n-\t{s: someTime, d: &scantime, wanttime: someTime},\n-\n-\t// To strings\n-\t{s: \"string\", d: &scanstr, wantstr: \"string\"},\n-\t{s: []byte(\"byteslice\"), d: &scanstr, wantstr: \"byteslice\"},\n-\t{s: 123, d: &scanstr, wantstr: \"123\"},\n-\t{s: int8(123), d: &scanstr, wantstr: \"123\"},\n-\t{s: int64(123), d: &scanstr, wantstr: \"123\"},\n-\t{s: uint8(123), d: &scanstr, wantstr: \"123\"},\n-\t{s: uint16(123), d: &scanstr, wantstr: \"123\"},\n-\t{s: uint32(123), d: &scanstr, wantstr: \"123\"},\n-\t{s: uint64(123), d: &scanstr, wantstr: \"123\"},\n-\t{s: 1.5, d: &scanstr, wantstr: \"1.5\"},\n-\n-\t// From time.Time:\n-\t{s: time.Unix(1, 0).UTC(), d: &scanstr, wantstr: \"1970-01-01T00:00:01Z\"},\n-\t{s: time.Unix(1453874597, 0).In(time.FixedZone(\"here\", -3600*8)), d: &scanstr, wantstr: \"2016-01-26T22:03:17-08:00\"},\n-\t{s: time.Unix(1, 2).UTC(), d: &scanstr, wantstr: \"1970-01-01T00:00:01.000000002Z\"},\n-\t{s: time.Time{}, d: &scanstr, wantstr: \"0001-01-01T00:00:00Z\"},\n-\t{s: time.Unix(1, 2).UTC(), d: &scanbytes, wantbytes: []byte(\"1970-01-01T00:00:01.000000002Z\")},\n-\t{s: time.Unix(1, 2).UTC(), d: &scaniface, wantiface: time.Unix(1, 2).UTC()},\n-\n-\t// To []byte\n-\t{s: nil, d: &scanbytes, wantbytes: nil},\n-\t{s: \"string\", d: &scanbytes, wantbytes: []byte(\"string\")},\n-\t{s: []byte(\"byteslice\"), d: &scanbytes, wantbytes: []byte(\"byteslice\")},\n-\t{s: 123, d: &scanbytes, wantbytes: []byte(\"123\")},\n-\t{s: int8(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n-\t{s: int64(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n-\t{s: uint8(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n-\t{s: uint16(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n-\t{s: uint32(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n-\t{s: uint64(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n-\t{s: 1.5, d: &scanbytes, wantbytes: []byte(\"1.5\")},\n-\n-\t// To RawBytes\n-\t{s: nil, d: &scanraw, wantraw: nil},\n-\t{s: []byte(\"byteslice\"), d: &scanraw, wantraw: RawBytes(\"byteslice\")},\n-\t{s: \"string\", d: &scanraw, wantraw: RawBytes(\"string\")},\n-\t{s: 123, d: &scanraw, wantraw: RawBytes(\"123\")},\n-\t{s: int8(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n-\t{s: int64(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n-\t{s: uint8(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n-\t{s: uint16(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n-\t{s: uint32(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n-\t{s: uint64(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n-\t{s: 1.5, d: &scanraw, wantraw: RawBytes(\"1.5\")},\n-\t// time.Time has been placed here to check that the RawBytes slice gets\n-\t// correctly reset when calling time.Time.AppendFormat.\n-\t{s: time.Unix(2, 5).UTC(), d: &scanraw, wantraw: RawBytes(\"1970-01-01T00:00:02.000000005Z\")},\n-\n-\t// Strings to integers\n-\t{s: \"255\", d: &scanuint8, wantuint: 255},\n-\t{s: \"256\", d: &scanuint8, wanterr: \"converting driver.Value type string (\\\"256\\\") to a uint8: value out of range\"},\n-\t{s: \"256\", d: &scanuint16, wantuint: 256},\n-\t{s: \"-1\", d: &scanint, wantint: -1},\n-\t{s: \"foo\", d: &scanint, wanterr: \"converting driver.Value type string (\\\"foo\\\") to a int: invalid syntax\"},\n-\n-\t// int64 to smaller integers\n-\t{s: int64(5), d: &scanuint8, wantuint: 5},\n-\t{s: int64(256), d: &scanuint8, wanterr: \"converting driver.Value type int64 (\\\"256\\\") to a uint8: value out of range\"},\n-\t{s: int64(256), d: &scanuint16, wantuint: 256},\n-\t{s: int64(65536), d: &scanuint16, wanterr: \"converting driver.Value type int64 (\\\"65536\\\") to a uint16: value out of range\"},\n-\n-\t// True bools\n-\t{s: true, d: &scanbool, wantbool: true},\n-\t{s: \"True\", d: &scanbool, wantbool: true},\n-\t{s: \"TRUE\", d: &scanbool, wantbool: true},\n-\t{s: \"1\", d: &scanbool, wantbool: true},\n-\t{s: 1, d: &scanbool, wantbool: true},\n-\t{s: int64(1), d: &scanbool, wantbool: true},\n-\t{s: uint16(1), d: &scanbool, wantbool: true},\n-\n-\t// False bools\n-\t{s: false, d: &scanbool, wantbool: false},\n-\t{s: \"false\", d: &scanbool, wantbool: false},\n-\t{s: \"FALSE\", d: &scanbool, wantbool: false},\n-\t{s: \"0\", d: &scanbool, wantbool: false},\n-\t{s: 0, d: &scanbool, wantbool: false},\n-\t{s: int64(0), d: &scanbool, wantbool: false},\n-\t{s: uint16(0), d: &scanbool, wantbool: false},\n-\n-\t// Not bools\n-\t{s: \"yup\", d: &scanbool, wanterr: `sql/driver: couldn't convert \"yup\" into type bool`},\n-\t{s: 2, d: &scanbool, wanterr: `sql/driver: couldn't convert 2 into type bool`},\n-\n-\t// Floats\n-\t{s: float64(1.5), d: &scanf64, wantf64: float64(1.5)},\n-\t{s: int64(1), d: &scanf64, wantf64: float64(1)},\n-\t{s: float64(1.5), d: &scanf32, wantf32: float32(1.5)},\n-\t{s: \"1.5\", d: &scanf32, wantf32: float32(1.5)},\n-\t{s: \"1.5\", d: &scanf64, wantf64: float64(1.5)},\n-\n-\t// Pointers\n-\t{s: interface{}(nil), d: &scanptr, wantnil: true},\n-\t{s: int64(42), d: &scanptr, wantptr: &answer},\n-\n-\t// To interface{}\n-\t{s: float64(1.5), d: &scaniface, wantiface: float64(1.5)},\n-\t{s: int64(1), d: &scaniface, wantiface: int64(1)},\n-\t{s: \"str\", d: &scaniface, wantiface: \"str\"},\n-\t{s: []byte(\"byteslice\"), d: &scaniface, wantiface: []byte(\"byteslice\")},\n-\t{s: true, d: &scaniface, wantiface: true},\n-\t{s: nil, d: &scaniface},\n-\t{s: []byte(nil), d: &scaniface, wantiface: []byte(nil)},\n-\n-\t// To a user-defined type\n-\t{s: 1.5, d: new(userDefined), wantusrdef: 1.5},\n-\t{s: int64(123), d: new(userDefined), wantusrdef: 123},\n-\t{s: \"1.5\", d: new(userDefined), wantusrdef: 1.5},\n-\t{s: []byte{1, 2, 3}, d: new(userDefinedSlice), wanterr: `unsupported Scan, storing driver.Value type []uint8 into type *sql.userDefinedSlice`},\n-\t{s: \"str\", d: new(userDefinedString), wantusrstr: \"str\"},\n-\n-\t// Other errors\n-\t{s: complex(1, 2), d: &scanstr, wanterr: `unsupported Scan, storing driver.Value type complex128 into type *string`},\n+func conversionTests() []conversionTest {\n+\t// Return a fresh instance to test so \"go test -count 2\" works correctly.\n+\treturn []conversionTest{\n+\t\t// Exact conversions (destination pointer type matches source type)\n+\t\t{s: \"foo\", d: &scanstr, wantstr: \"foo\"},\n+\t\t{s: 123, d: &scanint, wantint: 123},\n+\t\t{s: someTime, d: &scantime, wanttime: someTime},\n+\n+\t\t// To strings\n+\t\t{s: \"string\", d: &scanstr, wantstr: \"string\"},\n+\t\t{s: []byte(\"byteslice\"), d: &scanstr, wantstr: \"byteslice\"},\n+\t\t{s: 123, d: &scanstr, wantstr: \"123\"},\n+\t\t{s: int8(123), d: &scanstr, wantstr: \"123\"},\n+\t\t{s: int64(123), d: &scanstr, wantstr: \"123\"},\n+\t\t{s: uint8(123), d: &scanstr, wantstr: \"123\"},\n+\t\t{s: uint16(123), d: &scanstr, wantstr: \"123\"},\n+\t\t{s: uint32(123), d: &scanstr, wantstr: \"123\"},\n+\t\t{s: uint64(123), d: &scanstr, wantstr: \"123\"},\n+\t\t{s: 1.5, d: &scanstr, wantstr: \"1.5\"},\n+\n+\t\t// From time.Time:\n+\t\t{s: time.Unix(1, 0).UTC(), d: &scanstr, wantstr: \"1970-01-01T00:00:01Z\"},\n+\t\t{s: time.Unix(1453874597, 0).In(time.FixedZone(\"here\", -3600*8)), d: &scanstr, wantstr: \"2016-01-26T22:03:17-08:00\"},\n+\t\t{s: time.Unix(1, 2).UTC(), d: &scanstr, wantstr: \"1970-01-01T00:00:01.000000002Z\"},\n+\t\t{s: time.Time{}, d: &scanstr, wantstr: \"0001-01-01T00:00:00Z\"},\n+\t\t{s: time.Unix(1, 2).UTC(), d: &scanbytes, wantbytes: []byte(\"1970-01-01T00:00:01.000000002Z\")},\n+\t\t{s: time.Unix(1, 2).UTC(), d: &scaniface, wantiface: time.Unix(1, 2).UTC()},\n+\n+\t\t// To []byte\n+\t\t{s: nil, d: &scanbytes, wantbytes: nil},\n+\t\t{s: \"string\", d: &scanbytes, wantbytes: []byte(\"string\")},\n+\t\t{s: []byte(\"byteslice\"), d: &scanbytes, wantbytes: []byte(\"byteslice\")},\n+\t\t{s: 123, d: &scanbytes, wantbytes: []byte(\"123\")},\n+\t\t{s: int8(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n+\t\t{s: int64(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n+\t\t{s: uint8(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n+\t\t{s: uint16(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n+\t\t{s: uint32(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n+\t\t{s: uint64(123), d: &scanbytes, wantbytes: []byte(\"123\")},\n+\t\t{s: 1.5, d: &scanbytes, wantbytes: []byte(\"1.5\")},\n+\n+\t\t// To RawBytes\n+\t\t{s: nil, d: &scanraw, wantraw: nil},\n+\t\t{s: []byte(\"byteslice\"), d: &scanraw, wantraw: RawBytes(\"byteslice\")},\n+\t\t{s: \"string\", d: &scanraw, wantraw: RawBytes(\"string\")},\n+\t\t{s: 123, d: &scanraw, wantraw: RawBytes(\"123\")},\n+\t\t{s: int8(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n+\t\t{s: int64(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n+\t\t{s: uint8(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n+\t\t{s: uint16(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n+\t\t{s: uint32(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n+\t\t{s: uint64(123), d: &scanraw, wantraw: RawBytes(\"123\")},\n+\t\t{s: 1.5, d: &scanraw, wantraw: RawBytes(\"1.5\")},\n+\t\t// time.Time has been placed here to check that the RawBytes slice gets\n+\t\t// correctly reset when calling time.Time.AppendFormat.\n+\t\t{s: time.Unix(2, 5).UTC(), d: &scanraw, wantraw: RawBytes(\"1970-01-01T00:00:02.000000005Z\")},\n+\n+\t\t// Strings to integers\n+\t\t{s: \"255\", d: &scanuint8, wantuint: 255},\n+\t\t{s: \"256\", d: &scanuint8, wanterr: \"converting driver.Value type string (\\\"256\\\") to a uint8: value out of range\"},\n+\t\t{s: \"256\", d: &scanuint16, wantuint: 256},\n+\t\t{s: \"-1\", d: &scanint, wantint: -1},\n+\t\t{s: \"foo\", d: &scanint, wanterr: \"converting driver.Value type string (\\\"foo\\\") to a int: invalid syntax\"},\n+\n+\t\t// int64 to smaller integers\n+\t\t{s: int64(5), d: &scanuint8, wantuint: 5},\n+\t\t{s: int64(256), d: &scanuint8, wanterr: \"converting driver.Value type int64 (\\\"256\\\") to a uint8: value out of range\"},\n+\t\t{s: int64(256), d: &scanuint16, wantuint: 256},\n+\t\t{s: int64(65536), d: &scanuint16, wanterr: \"converting driver.Value type int64 (\\\"65536\\\") to a uint16: value out of range\"},\n+\n+\t\t// True bools\n+\t\t{s: true, d: &scanbool, wantbool: true},\n+\t\t{s: \"True\", d: &scanbool, wantbool: true},\n+\t\t{s: \"TRUE\", d: &scanbool, wantbool: true},\n+\t\t{s: \"1\", d: &scanbool, wantbool: true},\n+\t\t{s: 1, d: &scanbool, wantbool: true},\n+\t\t{s: int64(1), d: &scanbool, wantbool: true},\n+\t\t{s: uint16(1), d: &scanbool, wantbool: true},\n+\n+\t\t// False bools\n+\t\t{s: false, d: &scanbool, wantbool: false},\n+\t\t{s: \"false\", d: &scanbool, wantbool: false},\n+\t\t{s: \"FALSE\", d: &scanbool, wantbool: false},\n+\t\t{s: \"0\", d: &scanbool, wantbool: false},\n+\t\t{s: 0, d: &scanbool, wantbool: false},\n+\t\t{s: int64(0), d: &scanbool, wantbool: false},\n+\t\t{s: uint16(0), d: &scanbool, wantbool: false},\n+\n+\t\t// Not bools\n+\t\t{s: \"yup\", d: &scanbool, wanterr: `sql/driver: couldn't convert \"yup\" into type bool`},\n+\t\t{s: 2, d: &scanbool, wanterr: `sql/driver: couldn't convert 2 into type bool`},\n+\n+\t\t// Floats\n+\t\t{s: float64(1.5), d: &scanf64, wantf64: float64(1.5)},\n+\t\t{s: int64(1), d: &scanf64, wantf64: float64(1)},\n+\t\t{s: float64(1.5), d: &scanf32, wantf32: float32(1.5)},\n+\t\t{s: \"1.5\", d: &scanf32, wantf32: float32(1.5)},\n+\t\t{s: \"1.5\", d: &scanf64, wantf64: float64(1.5)},\n+\n+\t\t// Pointers\n+\t\t{s: interface{}(nil), d: &scanptr, wantnil: true},\n+\t\t{s: int64(42), d: &scanptr, wantptr: &answer},\n+\n+\t\t// To interface{}\n+\t\t{s: float64(1.5), d: &scaniface, wantiface: float64(1.5)},\n+\t\t{s: int64(1), d: &scaniface, wantiface: int64(1)},\n+\t\t{s: \"str\", d: &scaniface, wantiface: \"str\"},\n+\t\t{s: []byte(\"byteslice\"), d: &scaniface, wantiface: []byte(\"byteslice\")},\n+\t\t{s: true, d: &scaniface, wantiface: true},\n+\t\t{s: nil, d: &scaniface},\n+\t\t{s: []byte(nil), d: &scaniface, wantiface: []byte(nil)},\n+\n+\t\t// To a user-defined type\n+\t\t{s: 1.5, d: new(userDefined), wantusrdef: 1.5},\n+\t\t{s: int64(123), d: new(userDefined), wantusrdef: 123},\n+\t\t{s: \"1.5\", d: new(userDefined), wantusrdef: 1.5},\n+\t\t{s: []byte{1, 2, 3}, d: new(userDefinedSlice), wanterr: `unsupported Scan, storing driver.Value type []uint8 into type *sql.userDefinedSlice`},\n+\t\t{s: \"str\", d: new(userDefinedString), wantusrstr: \"str\"},\n+\n+\t\t// Other errors\n+\t\t{s: complex(1, 2), d: &scanstr, wanterr: `unsupported Scan, storing driver.Value type complex128 into type *string`},\n+\t}\n }\n \n func intPtrValue(intptr interface{}) interface{} {\n@@ -210,7 +213,7 @@ func timeValue(ptr interface{}) time.Time {\n }\n \n func TestConversions(t *testing.T) {\n-\tfor n, ct := range conversionTests {\n+\tfor n, ct := range conversionTests() {\n \t\terr := convertAssign(ct.d, ct.s)\n \t\terrstr := \"\"\n \t\tif err != nil {"}, {"sha": "98c9e121b055a88327c55934962bf458d4bf8b30", "filename": "libgo/go/go/types/assignments.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Fassignments.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Fassignments.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fassignments.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -154,8 +154,11 @@ func (check *Checker) assignVar(lhs ast.Expr, x *operand) Type {\n \tvar v_used bool\n \tif ident != nil {\n \t\tif _, obj := check.scope.LookupParent(ident.Name, token.NoPos); obj != nil {\n-\t\t\tv, _ = obj.(*Var)\n-\t\t\tif v != nil {\n+\t\t\t// It's ok to mark non-local variables, but ignore variables\n+\t\t\t// from other packages to avoid potential race conditions with\n+\t\t\t// dot-imported variables.\n+\t\t\tif w, _ := obj.(*Var); w != nil && w.pkg == check.pkg {\n+\t\t\t\tv = w\n \t\t\t\tv_used = v.used\n \t\t\t}\n \t\t}\n@@ -249,6 +252,7 @@ func (check *Checker) assignVars(lhs, rhs []ast.Expr) {\n \tl := len(lhs)\n \tget, r, commaOk := unpack(func(x *operand, i int) { check.multiExpr(x, rhs[i]) }, len(rhs), l == 2)\n \tif get == nil {\n+\t\tcheck.useLHS(lhs...)\n \t\treturn // error reported by unpack\n \t}\n \tif l != r {"}, {"sha": "8fe65e41d5f35cb02a07c9ee5740cd30eda482a4", "filename": "libgo/go/go/types/call.go", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -90,15 +90,52 @@ func (check *Checker) call(x *operand, e *ast.CallExpr) exprKind {\n // use type-checks each argument.\n // Useful to make sure expressions are evaluated\n // (and variables are \"used\") in the presence of other errors.\n+// The arguments may be nil.\n func (check *Checker) use(arg ...ast.Expr) {\n \tvar x operand\n \tfor _, e := range arg {\n-\t\tif e != nil { // be safe\n+\t\t// The nil check below is necessary since certain AST fields\n+\t\t// may legally be nil (e.g., the ast.SliceExpr.High field).\n+\t\tif e != nil {\n \t\t\tcheck.rawExpr(&x, e, nil)\n \t\t}\n \t}\n }\n \n+// useLHS is like use, but doesn't \"use\" top-level identifiers.\n+// It should be called instead of use if the arguments are\n+// expressions on the lhs of an assignment.\n+// The arguments must not be nil.\n+func (check *Checker) useLHS(arg ...ast.Expr) {\n+\tvar x operand\n+\tfor _, e := range arg {\n+\t\t// If the lhs is an identifier denoting a variable v, this assignment\n+\t\t// is not a 'use' of v. Remember current value of v.used and restore\n+\t\t// after evaluating the lhs via check.rawExpr.\n+\t\tvar v *Var\n+\t\tvar v_used bool\n+\t\tif ident, _ := unparen(e).(*ast.Ident); ident != nil {\n+\t\t\t// never type-check the blank name on the lhs\n+\t\t\tif ident.Name == \"_\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif _, obj := check.scope.LookupParent(ident.Name, token.NoPos); obj != nil {\n+\t\t\t\t// It's ok to mark non-local variables, but ignore variables\n+\t\t\t\t// from other packages to avoid potential race conditions with\n+\t\t\t\t// dot-imported variables.\n+\t\t\t\tif w, _ := obj.(*Var); w != nil && w.pkg == check.pkg {\n+\t\t\t\t\tv = w\n+\t\t\t\t\tv_used = v.used\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tcheck.rawExpr(&x, e, nil)\n+\t\tif v != nil {\n+\t\t\tv.used = v_used // restore v.used\n+\t\t}\n+\t}\n+}\n+\n // useGetter is like use, but takes a getter instead of a list of expressions.\n // It should be called instead of use if a getter is present to avoid repeated\n // evaluation of the first argument (since the getter was likely obtained via"}, {"sha": "9b250b30e74c96a47936313868a967a6259dbe34", "filename": "libgo/go/go/types/decl.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Fdecl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Fdecl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fdecl.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -111,7 +111,11 @@ func (check *Checker) constDecl(obj *Const, typ, init ast.Expr) {\n \tif typ != nil {\n \t\tt := check.typ(typ)\n \t\tif !isConstType(t) {\n-\t\t\tcheck.errorf(typ.Pos(), \"invalid constant type %s\", t)\n+\t\t\t// don't report an error if the type is an invalid C (defined) type\n+\t\t\t// (issue #22090)\n+\t\t\tif t.Underlying() != Typ[Invalid] {\n+\t\t\t\tcheck.errorf(typ.Pos(), \"invalid constant type %s\", t)\n+\t\t\t}\n \t\t\tobj.typ = Typ[Invalid]\n \t\t\treturn\n \t\t}"}, {"sha": "5221bcc7c1288d3e33552884900b286e572aba20", "filename": "libgo/go/go/types/stmt.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -731,6 +731,9 @@ func (check *Checker) stmt(ctxt stmtContext, s ast.Stmt) {\n \t\t// declaration, but the post statement must not.\"\n \t\tif s, _ := s.Post.(*ast.AssignStmt); s != nil && s.Tok == token.DEFINE {\n \t\t\tcheck.softErrorf(s.Pos(), \"cannot declare in post statement\")\n+\t\t\t// Don't call useLHS here because we want to use the lhs in\n+\t\t\t// this erroneous statement so that we don't get errors about\n+\t\t\t// these lhs variables being declared but not used.\n \t\t\tcheck.use(s.Lhs...) // avoid follow-up errors\n \t\t}\n \t\tcheck.stmt(inner, s.Body)"}, {"sha": "f50f7f33d3e8648da277c37adf9f96bc3290d833", "filename": "libgo/go/go/types/testdata/importC.src", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2FimportC.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2FimportC.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2FimportC.src?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -8,3 +8,28 @@ import \"C\"\n import _ /* ERROR cannot rename import \"C\" */ \"C\"\n import foo /* ERROR cannot rename import \"C\" */ \"C\"\n import . /* ERROR cannot rename import \"C\" */ \"C\"\n+\n+// Test cases extracted from issue #22090.\n+\n+import \"unsafe\"\n+\n+const _ C.int = 0xff // no error due to invalid constant type\n+\n+type T struct {\n+\tName    string\n+\tOrdinal int\n+}\n+\n+func f(args []T) {\n+\tvar s string\n+\tfor i, v := range args {\n+\t\tcname := C.CString(v.Name)\n+\t\targs[i].Ordinal = int(C.sqlite3_bind_parameter_index(s, cname)) // no error due to i not being \"used\"\n+\t\tC.free(unsafe.Pointer(cname))\n+\t}\n+}\n+\n+type CType C.Type\n+\n+const _ CType = C.X // no error due to invalid constant type\n+const _ = C.X"}, {"sha": "92ab06b0f25a3adc2524d2a8483f4cf2370a10c7", "filename": "libgo/go/go/types/typexpr.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Ftypexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fgo%2Ftypes%2Ftypexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypexpr.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -86,6 +86,9 @@ func (check *Checker) ident(x *operand, e *ast.Ident, def *Named, path []*TypeNa\n \t\t}\n \n \tcase *Var:\n+\t\t// It's ok to mark non-local variables, but ignore variables\n+\t\t// from other packages to avoid potential race conditions with\n+\t\t// dot-imported variables.\n \t\tif obj.pkg == check.pkg {\n \t\t\tobj.used = true\n \t\t}"}, {"sha": "96e6973c3a2e710591be25e01b124a73028e2fa9", "filename": "libgo/go/net/rpc/server.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -296,44 +296,44 @@ func suitableMethods(typ reflect.Type, reportErr bool) map[string]*methodType {\n \t\t// Method needs three ins: receiver, *args, *reply.\n \t\tif mtype.NumIn() != 3 {\n \t\t\tif reportErr {\n-\t\t\t\tlog.Println(\"method\", mname, \"has wrong number of ins:\", mtype.NumIn())\n+\t\t\t\tlog.Printf(\"rpc.Register: method %q has %d input parameters; needs exactly three\\n\", mname, mtype.NumIn())\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\t// First arg need not be a pointer.\n \t\targType := mtype.In(1)\n \t\tif !isExportedOrBuiltinType(argType) {\n \t\t\tif reportErr {\n-\t\t\t\tlog.Println(mname, \"argument type not exported:\", argType)\n+\t\t\t\tlog.Printf(\"rpc.Register: argument type of method %q is not exported: %q\\n\", mname, argType)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\t// Second arg must be a pointer.\n \t\treplyType := mtype.In(2)\n \t\tif replyType.Kind() != reflect.Ptr {\n \t\t\tif reportErr {\n-\t\t\t\tlog.Println(\"method\", mname, \"reply type not a pointer:\", replyType)\n+\t\t\t\tlog.Printf(\"rpc.Register: reply type of method %q is not a pointer: %q\\n\", mname, replyType)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\t// Reply type must be exported.\n \t\tif !isExportedOrBuiltinType(replyType) {\n \t\t\tif reportErr {\n-\t\t\t\tlog.Println(\"method\", mname, \"reply type not exported:\", replyType)\n+\t\t\t\tlog.Printf(\"rpc.Register: reply type of method %q is not exported: %q\\n\", mname, replyType)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\t// Method needs one out.\n \t\tif mtype.NumOut() != 1 {\n \t\t\tif reportErr {\n-\t\t\t\tlog.Println(\"method\", mname, \"has wrong number of outs:\", mtype.NumOut())\n+\t\t\t\tlog.Printf(\"rpc.Register: method %q has %d output parameters; needs exactly one\\n\", mname, mtype.NumOut())\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\t// The return type of the method must be error.\n \t\tif returnType := mtype.Out(0); returnType != typeOfError {\n \t\t\tif reportErr {\n-\t\t\t\tlog.Println(\"method\", mname, \"returns\", returnType.String(), \"not error\")\n+\t\t\t\tlog.Printf(\"rpc.Register: return type of method %q is %q, must be error\\n\", mname, returnType)\n \t\t\t}\n \t\t\tcontinue\n \t\t}"}, {"sha": "b82bf0dea37c668772c5b793e5d26ac9a8871ac0", "filename": "libgo/go/os/error_plan9.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fos%2Ferror_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fos%2Ferror_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_plan9.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -5,7 +5,7 @@\n package os\n \n func isExist(err error) bool {\n-\treturn checkErrMessageContent(err, \" exists\")\n+\treturn checkErrMessageContent(err, \"exists\", \"is a directory\")\n }\n \n func isNotExist(err error) bool {"}, {"sha": "6d25466bb44e27070ed8cc469941f150f52a3c90", "filename": "libgo/go/os/getwd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fos%2Fgetwd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fos%2Fgetwd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fgetwd.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -24,7 +24,7 @@ var useSyscallwd = func(error) bool { return true }\n // reached via multiple paths (due to symbolic links),\n // Getwd may return any one of them.\n func Getwd() (dir string, err error) {\n-\tif runtime.GOOS == \"windows\" {\n+\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n \t\treturn syscall.Getwd()\n \t}\n "}, {"sha": "7a099beb765eff5a0add8edeca9f6b110accc503", "filename": "libgo/go/runtime/crash_test.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_test.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -632,3 +632,20 @@ retry:\n \t}\n \tt.Errorf(\"test ran %d times without producing expected output\", tries)\n }\n+\n+func TestBadTraceback(t *testing.T) {\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"gccgo does not do a hex dump\")\n+\t}\n+\toutput := runTestProg(t, \"testprog\", \"BadTraceback\")\n+\tfor _, want := range []string{\n+\t\t\"runtime: unexpected return pc\",\n+\t\t\"called from 0xbad\",\n+\t\t\"00000bad\",    // Smashed LR in hex dump\n+\t\t\"<main.badLR\", // Symbolization in hex dump (badLR1 or badLR2)\n+\t} {\n+\t\tif !strings.Contains(output, want) {\n+\t\t\tt.Errorf(\"output does not contain %q:\\n%s\", want, output)\n+\t\t}\n+\t}\n+}"}, {"sha": "34b7d37c3f88c9b6895566d09610d5126f25a388", "filename": "libgo/go/runtime/error.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ferror.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -138,8 +138,7 @@ func typestring(x interface{}) string {\n \treturn *e._type.string\n }\n \n-// For calling from C.\n-// Prints an argument passed to panic.\n+// printany prints an argument passed to panic.\n func printany(i interface{}) {\n \tswitch v := i.(type) {\n \tcase nil:"}, {"sha": "fbdb17e5e5a93f0400c494ec051a19bd6e072c27", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -403,12 +403,15 @@ func preprintpanics(p *_panic) {\n }\n \n // Print all currently active panics. Used when crashing.\n+// Should only be called after preprintpanics.\n func printpanics(p *_panic) {\n \tif p.link != nil {\n \t\tprintpanics(p.link)\n \t\tprint(\"\\t\")\n \t}\n \tprint(\"panic: \")\n+\t// Because of preprintpanics, p.arg cannot be an error or\n+\t// stringer, so this won't call into user code.\n \tprintany(p.arg)\n \tif p.recovered {\n \t\tprint(\" [recovered]\")\n@@ -833,22 +836,22 @@ var panicking uint32\n // so that two concurrent panics don't overlap their output.\n var paniclk mutex\n \n-// startpanic_m implements unrecoverable panic.\n+// startpanic_m prepares for an unrecoverable panic.\n //\n // It can have write barriers because the write barrier explicitly\n // ignores writes once dying > 0.\n //\n //go:yeswritebarrierrec\n func startpanic() {\n \t_g_ := getg()\n-\t// Uncomment when mheap_ is in Go.\n-\t// if mheap_.cachealloc.size == 0 { // very early\n-\t//\tprint(\"runtime: panic before malloc heap initialized\\n\")\n-\t//\t_g_.m.mallocing = 1 // tell rest of panic not to try to malloc\n-\t// } else\n-\tif _g_.m.mcache == nil { // can happen if called from signal handler or throw\n-\t\t_g_.m.mcache = allocmcache()\n+\tif mheap_.cachealloc.size == 0 { // very early\n+\t\tprint(\"runtime: panic before malloc heap initialized\\n\")\n \t}\n+\t// Disallow malloc during an unrecoverable panic. A panic\n+\t// could happen in a signal handler, or in a throw, or inside\n+\t// malloc itself. We want to catch if an allocation ever does\n+\t// happen (even if we're not in one of these situations).\n+\t_g_.m.mallocing++\n \n \tswitch _g_.m.dying {\n \tcase 0:\n@@ -934,6 +937,9 @@ func dopanic(unused int) {\n \texit(2)\n }\n \n+// canpanic returns false if a signal should throw instead of\n+// panicking.\n+//\n //go:nosplit\n func canpanic(gp *g) bool {\n \t// Note that g is m->gsignal, different from gp."}, {"sha": "be4e86915ef8ea1265f1b89244cff827bdfd2e1b", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -350,7 +350,8 @@ type countProfile interface {\n // as the pprof-proto format output. Translations from cycle count to time duration\n // are done because The proto expects count and time (nanoseconds) instead of count\n // and the number of cycles for block, contention profiles.\n-func printCountCycleProfile(w io.Writer, countName, cycleName string, records []runtime.BlockProfileRecord) error {\n+// Possible 'scaler' functions are scaleBlockProfile and scaleMutexProfile.\n+func printCountCycleProfile(w io.Writer, countName, cycleName string, scaler func(int64, float64) (int64, float64), records []runtime.BlockProfileRecord) error {\n \t// Output profile in protobuf form.\n \tb := newProfileBuilder(w)\n \tb.pbValueType(tagProfile_PeriodType, countName, \"count\")\n@@ -363,8 +364,9 @@ func printCountCycleProfile(w io.Writer, countName, cycleName string, records []\n \tvalues := []int64{0, 0}\n \tvar locs []uint64\n \tfor _, r := range records {\n-\t\tvalues[0] = int64(r.Count)\n-\t\tvalues[1] = int64(float64(r.Cycles) / cpuGHz) // to nanoseconds\n+\t\tcount, nanosec := scaler(r.Count, float64(r.Cycles)/cpuGHz)\n+\t\tvalues[0] = count\n+\t\tvalues[1] = int64(nanosec)\n \t\tlocs = locs[:0]\n \t\tfor _, addr := range r.Stack() {\n \t\t\t// For count profiles, all stack addresses are\n@@ -820,7 +822,7 @@ func writeBlock(w io.Writer, debug int) error {\n \tsort.Slice(p, func(i, j int) bool { return p[i].Cycles > p[j].Cycles })\n \n \tif debug <= 0 {\n-\t\treturn printCountCycleProfile(w, \"contentions\", \"delay\", p)\n+\t\treturn printCountCycleProfile(w, \"contentions\", \"delay\", scaleBlockProfile, p)\n \t}\n \n \tb := bufio.NewWriter(w)\n@@ -847,6 +849,14 @@ func writeBlock(w io.Writer, debug int) error {\n \treturn b.Flush()\n }\n \n+func scaleBlockProfile(cnt int64, ns float64) (int64, float64) {\n+\t// Do nothing.\n+\t// The current way of block profile sampling makes it\n+\t// hard to compute the unsampled number. The legacy block\n+\t// profile parse doesn't attempt to scale or unsample.\n+\treturn cnt, ns\n+}\n+\n // writeMutex writes the current mutex profile to w.\n func writeMutex(w io.Writer, debug int) error {\n \t// TODO(pjw): too much common code with writeBlock. FIX!\n@@ -864,7 +874,7 @@ func writeMutex(w io.Writer, debug int) error {\n \tsort.Slice(p, func(i, j int) bool { return p[i].Cycles > p[j].Cycles })\n \n \tif debug <= 0 {\n-\t\treturn printCountCycleProfile(w, \"contentions\", \"delay\", p)\n+\t\treturn printCountCycleProfile(w, \"contentions\", \"delay\", scaleMutexProfile, p)\n \t}\n \n \tb := bufio.NewWriter(w)\n@@ -892,4 +902,9 @@ func writeMutex(w io.Writer, debug int) error {\n \treturn b.Flush()\n }\n \n+func scaleMutexProfile(cnt int64, ns float64) (int64, float64) {\n+\tperiod := runtime.SetMutexProfileFraction(-1)\n+\treturn cnt * int64(period), ns * float64(period)\n+}\n+\n func runtime_cyclesPerSecond() int64"}, {"sha": "a6da4c979ba21e69b049084a89430243f4a640dd", "filename": "libgo/go/runtime/rwmutex.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Frwmutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Frwmutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Frwmutex.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -10,7 +10,7 @@ import (\n \n // This is a copy of sync/rwmutex.go rewritten to work in the runtime.\n \n-// An rwmutex is a reader/writer mutual exclusion lock.\n+// A rwmutex is a reader/writer mutual exclusion lock.\n // The lock can be held by an arbitrary number of readers or a single writer.\n // This is a variant of sync.RWMutex, for the runtime package.\n // Like mutex, rwmutex blocks the calling M."}, {"sha": "698629d154fdd60715cd32e6bd5defae9257622e", "filename": "libgo/go/runtime/signal_sighandler.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Fsignal_sighandler.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Fsignal_sighandler.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_sighandler.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -40,6 +40,11 @@ func sighandler(sig uint32, info *_siginfo_t, ctxt unsafe.Pointer, gp *g) {\n \tif sig < uint32(len(sigtable)) {\n \t\tflags = sigtable[sig].flags\n \t}\n+\tif flags&_SigPanic != 0 && gp.throwsplit {\n+\t\t// We can't safely sigpanic because it may grow the\n+\t\t// stack. Abort in the signal handler instead.\n+\t\tflags = (flags &^ _SigPanic) | _SigThrow\n+\t}\n \tif c.sigcode() != _SI_USER && flags&_SigPanic != 0 {\n \t\t// Emulate gc by passing arguments out of band,\n \t\t// although we don't really have to."}, {"sha": "02d53488807a433f7847a105c5ceec9c199efc0b", "filename": "libgo/go/runtime/signal_unix.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_unix.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -320,6 +320,12 @@ func sigtrampgo(sig uint32, info *_siginfo_t, ctx unsafe.Pointer) {\n // the signal handler. The effect is that the program will act as\n // though the function that got the signal simply called sigpanic\n // instead.\n+//\n+// This must NOT be nosplit because the linker doesn't know where\n+// sigpanic calls can be injected.\n+//\n+// The signal handler must not inject a call to sigpanic if\n+// getg().throwsplit, since sigpanic may need to grow the stack.\n func sigpanic() {\n \tg := getg()\n \tif !canpanic(g) {"}, {"sha": "b70759026089dcce5bdef18a1175020f7e45982a", "filename": "libgo/go/runtime/time.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fruntime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftime.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -59,6 +59,7 @@ func (t *timer) assignBucket() *timersBucket {\n \treturn t.tb\n }\n \n+//go:notinheap\n type timersBucket struct {\n \tlock         mutex\n \tgp           *g"}, {"sha": "4e9e8197c145590201d0df65c304332d76011a6e", "filename": "libgo/go/sync/rwmutex.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fsync%2Frwmutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fgo%2Fsync%2Frwmutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Frwmutex.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -13,11 +13,11 @@ import (\n // There is a modified copy of this file in runtime/rwmutex.go.\n // If you make any changes here, see if you should make them there.\n \n-// An RWMutex is a reader/writer mutual exclusion lock.\n+// A RWMutex is a reader/writer mutual exclusion lock.\n // The lock can be held by an arbitrary number of readers or a single writer.\n // The zero value for a RWMutex is an unlocked mutex.\n //\n-// An RWMutex must not be copied after first use.\n+// A RWMutex must not be copied after first use.\n //\n // If a goroutine holds a RWMutex for reading and another goroutine might\n // call Lock, no goroutine should expect to be able to acquire a read lock\n@@ -108,7 +108,7 @@ func (rw *RWMutex) Lock() {\n // not locked for writing on entry to Unlock.\n //\n // As with Mutexes, a locked RWMutex is not associated with a particular\n-// goroutine. One goroutine may RLock (Lock) an RWMutex and then\n+// goroutine. One goroutine may RLock (Lock) a RWMutex and then\n // arrange for another goroutine to RUnlock (Unlock) it.\n func (rw *RWMutex) Unlock() {\n \tif race.Enabled {"}, {"sha": "fe8dfff1d891b76eea60b67d06f4c0b9441e8759", "filename": "libgo/misc/cgo/errors/ptr_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fmisc%2Fcgo%2Ferrors%2Fptr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fmisc%2Fcgo%2Ferrors%2Fptr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fptr_test.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -349,6 +349,14 @@ var ptrTests = []ptrTest{\n \t\tbody:    `var wg sync.WaitGroup; wg.Add(100); for i := 0; i < 100; i++ { go func(i int) { for j := 0; j < 100; j++ { C.f(); runtime.GOMAXPROCS(i) }; wg.Done() }(i) }; wg.Wait()`,\n \t\tfail:    false,\n \t},\n+\t{\n+\t\t// Test poller deadline with cgocheck=2.  Issue #23435.\n+\t\tname:    \"deadline\",\n+\t\tc:       `#define US 10`,\n+\t\timports: []string{\"os\", \"time\"},\n+\t\tbody:    `r, _, _ := os.Pipe(); r.SetDeadline(time.Now().Add(C.US * time.Microsecond))`,\n+\t\tfail:    false,\n+\t},\n }\n \n func TestPointerChecks(t *testing.T) {"}, {"sha": "4a8cc0f077b9aa9a63373ef6bfe25ae69b732af4", "filename": "libgo/misc/cgo/testcarchive/carchive_test.go", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -695,3 +695,50 @@ func TestCompileWithoutShared(t *testing.T) {\n \tt.Logf(\"%s\", out)\n \texpectSignal(t, err, syscall.SIGPIPE)\n }\n+\n+// Test that installing a second time recreates the header files.\n+func TestCachedInstall(t *testing.T) {\n+\tdefer os.RemoveAll(\"pkg\")\n+\n+\th1 := filepath.Join(\"pkg\", libgodir, \"libgo.h\")\n+\th2 := filepath.Join(\"pkg\", libgodir, \"p.h\")\n+\n+\tbuildcmd := []string{\"go\", \"install\", \"-i\", \"-buildmode=c-archive\", \"libgo\"}\n+\n+\tcmd := exec.Command(buildcmd[0], buildcmd[1:]...)\n+\tcmd.Env = gopathEnv\n+\tt.Log(buildcmd)\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif _, err := os.Stat(h1); err != nil {\n+\t\tt.Errorf(\"libgo.h not installed: %v\", err)\n+\t}\n+\tif _, err := os.Stat(h2); err != nil {\n+\t\tt.Errorf(\"p.h not installed: %v\", err)\n+\t}\n+\n+\tif err := os.Remove(h1); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := os.Remove(h2); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tcmd = exec.Command(buildcmd[0], buildcmd[1:]...)\n+\tcmd.Env = gopathEnv\n+\tt.Log(buildcmd)\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif _, err := os.Stat(h1); err != nil {\n+\t\tt.Errorf(\"libgo.h not installed in second run: %v\", err)\n+\t}\n+\tif _, err := os.Stat(h2); err != nil {\n+\t\tt.Errorf(\"p.h not installed in second run: %v\", err)\n+\t}\n+}"}, {"sha": "e43422de6e6a599e2dbbaf0ef04b8e0dc7f153f3", "filename": "libgo/misc/cgo/testcshared/cshared_test.go", "status": "modified", "additions": 112, "deletions": 5, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fcshared_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fcshared_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fcshared_test.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -7,6 +7,7 @@ package cshared_test\n import (\n \t\"debug/elf\"\n \t\"fmt\"\n+\t\"io/ioutil\"\n \t\"log\"\n \t\"os\"\n \t\"os/exec\"\n@@ -55,7 +56,8 @@ func TestMain(m *testing.M) {\n \n \tandroiddir = fmt.Sprintf(\"/data/local/tmp/testcshared-%d\", os.Getpid())\n \tif GOOS == \"android\" {\n-\t\tcmd := exec.Command(\"adb\", \"shell\", \"mkdir\", \"-p\", androiddir)\n+\t\targs := append(adbCmd(), \"shell\", \"mkdir\", \"-p\", androiddir)\n+\t\tcmd := exec.Command(args[0], args[1:]...)\n \t\tout, err := cmd.CombinedOutput()\n \t\tif err != nil {\n \t\t\tlog.Fatalf(\"setupAndroid failed: %v\\n%s\\n\", err, out)\n@@ -154,11 +156,19 @@ func cmdToRun(name string) string {\n \treturn \"./\" + name + exeSuffix\n }\n \n+func adbCmd() []string {\n+\tcmd := []string{\"adb\"}\n+\tif flags := os.Getenv(\"GOANDROID_ADB_FLAGS\"); flags != \"\" {\n+\t\tcmd = append(cmd, strings.Split(flags, \" \")...)\n+\t}\n+\treturn cmd\n+}\n+\n func adbPush(t *testing.T, filename string) {\n \tif GOOS != \"android\" {\n \t\treturn\n \t}\n-\targs := []string{\"adb\", \"push\", filename, fmt.Sprintf(\"%s/%s\", androiddir, filename)}\n+\targs := append(adbCmd(), \"push\", filename, fmt.Sprintf(\"%s/%s\", androiddir, filename))\n \tcmd := exec.Command(args[0], args[1:]...)\n \tif out, err := cmd.CombinedOutput(); err != nil {\n \t\tt.Fatalf(\"adb command failed: %v\\n%s\\n\", err, out)\n@@ -169,7 +179,7 @@ func adbRun(t *testing.T, env []string, adbargs ...string) string {\n \tif GOOS != \"android\" {\n \t\tt.Fatalf(\"trying to run adb command when operating system is not android.\")\n \t}\n-\targs := []string{\"adb\", \"shell\"}\n+\targs := append(adbCmd(), \"shell\")\n \t// Propagate LD_LIBRARY_PATH to the adb shell invocation.\n \tfor _, e := range env {\n \t\tif strings.Index(e, \"LD_LIBRARY_PATH=\") != -1 {\n@@ -237,7 +247,7 @@ func createHeaders() error {\n \t}\n \n \tif GOOS == \"android\" {\n-\t\targs = []string{\"adb\", \"push\", libgoname, fmt.Sprintf(\"%s/%s\", androiddir, libgoname)}\n+\t\targs = append(adbCmd(), \"push\", libgoname, fmt.Sprintf(\"%s/%s\", androiddir, libgoname))\n \t\tcmd = exec.Command(args[0], args[1:]...)\n \t\tout, err = cmd.CombinedOutput()\n \t\tif err != nil {\n@@ -270,7 +280,8 @@ func cleanupAndroid() {\n \tif GOOS != \"android\" {\n \t\treturn\n \t}\n-\tcmd := exec.Command(\"adb\", \"shell\", \"rm\", \"-rf\", androiddir)\n+\targs := append(adbCmd(), \"shell\", \"rm\", \"-rf\", androiddir)\n+\tcmd := exec.Command(args[0], args[1:]...)\n \tout, err := cmd.CombinedOutput()\n \tif err != nil {\n \t\tlog.Fatalf(\"cleanupAndroid failed: %v\\n%s\\n\", err, out)\n@@ -477,3 +488,99 @@ func TestPIE(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Test that installing a second time recreates the header files.\n+func TestCachedInstall(t *testing.T) {\n+\ttmpdir, err := ioutil.TempDir(\"\", \"cshared\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// defer os.RemoveAll(tmpdir)\n+\n+\tcopyFile(t, filepath.Join(tmpdir, \"src\", \"libgo\", \"libgo.go\"), filepath.Join(\"src\", \"libgo\", \"libgo.go\"))\n+\tcopyFile(t, filepath.Join(tmpdir, \"src\", \"p\", \"p.go\"), filepath.Join(\"src\", \"p\", \"p.go\"))\n+\n+\tenv := append(os.Environ(), \"GOPATH=\"+tmpdir)\n+\n+\tbuildcmd := []string{\"go\", \"install\", \"-x\", \"-i\", \"-buildmode=c-shared\", \"-installsuffix\", \"testcshared\", \"libgo\"}\n+\n+\tcmd := exec.Command(buildcmd[0], buildcmd[1:]...)\n+\tcmd.Env = env\n+\tt.Log(buildcmd)\n+\tout, err := cmd.CombinedOutput()\n+\tt.Logf(\"%s\", out)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tvar libgoh, ph string\n+\n+\twalker := func(path string, info os.FileInfo, err error) error {\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tvar ps *string\n+\t\tswitch filepath.Base(path) {\n+\t\tcase \"libgo.h\":\n+\t\t\tps = &libgoh\n+\t\tcase \"p.h\":\n+\t\t\tps = &ph\n+\t\t}\n+\t\tif ps != nil {\n+\t\t\tif *ps != \"\" {\n+\t\t\t\tt.Fatalf(\"%s found again\", *ps)\n+\t\t\t}\n+\t\t\t*ps = path\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\tif err := filepath.Walk(tmpdir, walker); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif libgoh == \"\" {\n+\t\tt.Fatal(\"libgo.h not installed\")\n+\t}\n+\tif ph == \"\" {\n+\t\tt.Fatal(\"p.h not installed\")\n+\t}\n+\n+\tif err := os.Remove(libgoh); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := os.Remove(ph); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tcmd = exec.Command(buildcmd[0], buildcmd[1:]...)\n+\tcmd.Env = env\n+\tt.Log(buildcmd)\n+\tout, err = cmd.CombinedOutput()\n+\tt.Logf(\"%s\", out)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif _, err := os.Stat(libgoh); err != nil {\n+\t\tt.Errorf(\"libgo.h not installed in second run: %v\", err)\n+\t}\n+\tif _, err := os.Stat(ph); err != nil {\n+\t\tt.Errorf(\"p.h not installed in second run: %v\", err)\n+\t}\n+}\n+\n+// copyFile copies src to dst.\n+func copyFile(t *testing.T, dst, src string) {\n+\tt.Helper()\n+\tdata, err := ioutil.ReadFile(src)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := os.MkdirAll(filepath.Dir(dst), 0777); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := ioutil.WriteFile(dst, data, 0666); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}"}, {"sha": "cf049ec35b8a11f5ebe22707dad33a7c3bb547a6", "filename": "libgo/misc/cgo/testshared/shared_test.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d779dffc4b6ec69cb51b426f779eca4bc37fd063/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go?ref=d779dffc4b6ec69cb51b426f779eca4bc37fd063", "patch": "@@ -351,10 +351,10 @@ func readNotes(f *elf.File) ([]*note, error) {\n \n func dynStrings(t *testing.T, path string, flag elf.DynTag) []string {\n \tf, err := elf.Open(path)\n-\tdefer f.Close()\n \tif err != nil {\n \t\tt.Fatalf(\"elf.Open(%q) failed: %v\", path, err)\n \t}\n+\tdefer f.Close()\n \tdynstrings, err := f.DynString(flag)\n \tif err != nil {\n \t\tt.Fatalf(\"DynString(%s) failed on %s: %v\", flag, path, err)\n@@ -598,7 +598,6 @@ func TestThreeGopathShlibs(t *testing.T) {\n // If gccgo is not available or not new enough call t.Skip. Otherwise,\n // return a build.Context that is set up for gccgo.\n func prepGccgo(t *testing.T) build.Context {\n-\tt.Skip(\"golang.org/issue/22472\")\n \tgccgoName := os.Getenv(\"GCCGO\")\n \tif gccgoName == \"\" {\n \t\tgccgoName = \"gccgo\"\n@@ -648,8 +647,6 @@ func TestGoPathShlibGccgo(t *testing.T) {\n // library with gccgo, another GOPATH package that depends on the first and an\n // executable that links the second library.\n func TestTwoGopathShlibsGccgo(t *testing.T) {\n-\tt.Skip(\"golang.org/issue/22224\")\n-\n \tgccgoContext := prepGccgo(t)\n \n \tlibgoRE := regexp.MustCompile(\"libgo.so.[0-9]+\")"}]}