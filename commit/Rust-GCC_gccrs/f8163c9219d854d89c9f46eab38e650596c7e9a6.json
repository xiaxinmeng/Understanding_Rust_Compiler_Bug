{"sha": "f8163c9219d854d89c9f46eab38e650596c7e9a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgxNjNjOTIxOWQ4NTRkODljOWY0NmVhYjM4ZTY1MDU5NmM3ZTlhNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-09-06T17:27:22Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-09-06T17:27:22Z"}, "message": "(modified_between_p): Handle vectors.\n\n(modified_in_p): New function.\n(refers_to_regno_p): If setting AP, FP, or SP, we clobber the virtual\nregisters.\n\nFrom-SVN: r5267", "tree": {"sha": "7cf17357ba91b8735d3dfb33067ac90aa301c828", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7cf17357ba91b8735d3dfb33067ac90aa301c828"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8163c9219d854d89c9f46eab38e650596c7e9a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8163c9219d854d89c9f46eab38e650596c7e9a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8163c9219d854d89c9f46eab38e650596c7e9a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8163c9219d854d89c9f46eab38e650596c7e9a6/comments", "author": null, "committer": null, "parents": [{"sha": "966963e68bb35ee9a715f7675def78ad33f8ac1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/966963e68bb35ee9a715f7675def78ad33f8ac1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/966963e68bb35ee9a715f7675def78ad33f8ac1e"}], "stats": {"total": 78, "additions": 74, "deletions": 4}, "files": [{"sha": "82ac3afd3dfdb23b8f19ae8497a111a1d9025e75", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 74, "deletions": 4, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8163c9219d854d89c9f46eab38e650596c7e9a6/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8163c9219d854d89c9f46eab38e650596c7e9a6/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=f8163c9219d854d89c9f46eab38e650596c7e9a6", "patch": "@@ -1,5 +1,5 @@\n /* Analyze RTL for C-Compiler\n-   Copyright (C) 1987, 1988, 1991, 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1992, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -472,7 +472,7 @@ modified_between_p (x, start, end)\n {\n   enum rtx_code code = GET_CODE (x);\n   char *fmt;\n-  int i;\n+  int i, j;\n \n   switch (code)\n     {\n@@ -500,10 +500,68 @@ modified_between_p (x, start, end)\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    if (fmt[i] == 'e'\n-\t&& modified_between_p (XEXP (x, i), start, end))\n+    {\n+      if (fmt[i] == 'e' && modified_between_p (XEXP (x, i), start, end))\n+\treturn 1;\n+\n+      if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  if (modified_between_p (XVECEXP (x, i, j), start, end))\n+\t    return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Similar to reg_set_p, but check all registers in X.  Return 0 only if none\n+   of them are modified in INSN.  Return 1 if X contains a MEM; this routine\n+   does not perform any memory aliasing.  */\n+\n+int\n+modified_in_p (x, insn)\n+     rtx x;\n+     rtx insn;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  char *fmt;\n+  int i, j;\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 0;\n+\n+    case PC:\n+    case CC0:\n       return 1;\n \n+    case MEM:\n+      /* If the memory is not constant, assume it is modified.  If it is\n+\t constant, we still have to check the address.  */\n+      if (! RTX_UNCHANGING_P (x))\n+\treturn 1;\n+      break;\n+\n+    case REG:\n+      return reg_set_p (x, insn);\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e' && modified_in_p (XEXP (x, i), insn))\n+\treturn 1;\n+\n+      if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  if (modified_in_p (XVECEXP (x, i, j), insn))\n+\t    return 1;\n+    }\n+\n   return 0;\n }\n \f\n@@ -618,6 +676,18 @@ refers_to_regno_p (regno, endregno, x, loc)\n     {\n     case REG:\n       i = REGNO (x);\n+\n+      /* If we modifying the stack, frame, or argument pointer, it will\n+\t clobber a virtual register.  In fact, we could be more precise,\n+\t but it isn't worth it.  */\n+      if ((i == STACK_POINTER_REGNUM\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+\t   || i == ARG_POINTER_REGNUM\n+#endif\n+\t   || i == FRAME_POINTER_REGNUM)\n+\t  && regno >= FIRST_VIRTUAL_REGISTER && regno <= LAST_VIRTUAL_REGISTER)\n+\treturn 1;\n+\n       return (endregno > i\n \t      && regno < i + (i < FIRST_PSEUDO_REGISTER \n \t\t\t      ? HARD_REGNO_NREGS (i, GET_MODE (x))"}]}