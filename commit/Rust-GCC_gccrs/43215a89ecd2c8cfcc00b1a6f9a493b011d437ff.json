{"sha": "43215a89ecd2c8cfcc00b1a6f9a493b011d437ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMyMTVhODllY2QyYzhjZmNjMDBiMWE2ZjlhNDkzYjAxMWQ0MzdmZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-23T20:36:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-23T20:36:36Z"}, "message": "dwarf2cfi: Introduce dw_trace_info.\n\nThis patch only introduces the structure definition and adjusts\nthe existing routines to use the new cur_trace global to access\nthe variables that were moved into the structure.\n\n        * dwarf2cfi.c (dw_trace_info): New.\n        (dw_label_info): New.\n        (cie_return_save): New.\n        (cur_trace): New.\n        (queued_args_size): Rename from args_size.  Update all users.\n        (cfa_store, cfa_temp, regs_saved_in_regs): Remove.\n        (def_cfa_1): Use cur_trace instead of cfa_*.\n        (dwarf2out_stack_adjust, record_reg_saved_in_reg): Likewise.\n        (clobbers_queued_reg_save, reg_saved_in): Likewise.\n        (dwarf2out_frame_debug_expr): Likewise.\n        (create_cie_data): Split out from ...\n        (execute_dwarf2_frame): ... here.  Initialize cur_trace.\n\nFrom-SVN: r176704", "tree": {"sha": "d24cbd0128fa7525c4e9c869d4a02daad503e03f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d24cbd0128fa7525c4e9c869d4a02daad503e03f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43215a89ecd2c8cfcc00b1a6f9a493b011d437ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43215a89ecd2c8cfcc00b1a6f9a493b011d437ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43215a89ecd2c8cfcc00b1a6f9a493b011d437ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43215a89ecd2c8cfcc00b1a6f9a493b011d437ff/comments", "author": null, "committer": null, "parents": [{"sha": "6ffc63e112d416582184b8e65db22feb320ae24a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ffc63e112d416582184b8e65db22feb320ae24a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ffc63e112d416582184b8e65db22feb320ae24a"}], "stats": {"total": 455, "additions": 281, "deletions": 174}, "files": [{"sha": "6a0ed285afdf69f87b5954b409d93f74a9d4b58c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43215a89ecd2c8cfcc00b1a6f9a493b011d437ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43215a89ecd2c8cfcc00b1a6f9a493b011d437ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43215a89ecd2c8cfcc00b1a6f9a493b011d437ff", "patch": "@@ -1,3 +1,18 @@\n+2011-07-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c (dw_trace_info): New.\n+\t(dw_label_info): New.\n+\t(cie_return_save): New.\n+\t(cur_trace): New.\n+\t(queued_args_size): Rename from args_size.  Update all users.\n+\t(cfa_store, cfa_temp, regs_saved_in_regs): Remove.\n+\t(def_cfa_1): Use cur_trace instead of cfa_*.\n+\t(dwarf2out_stack_adjust, record_reg_saved_in_reg): Likewise.\n+\t(clobbers_queued_reg_save, reg_saved_in): Likewise.\n+\t(dwarf2out_frame_debug_expr): Likewise.\n+\t(create_cie_data): Split out from ...\n+\t(execute_dwarf2_frame): ... here.  Initialize cur_trace.\n+\n 2011-07-23  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2cfi.c (regs_saved_in_regs): Allocate from heap, not gc."}, {"sha": "9aa1208ad12416ff24ea928ac2f0ecaf2300b3e7", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 266, "deletions": 174, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43215a89ecd2c8cfcc00b1a6f9a493b011d437ff/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43215a89ecd2c8cfcc00b1a6f9a493b011d437ff/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=43215a89ecd2c8cfcc00b1a6f9a493b011d437ff", "patch": "@@ -74,14 +74,107 @@ typedef struct GTY(()) dw_cfi_row_struct\n   HOST_WIDE_INT args_size;\n } dw_cfi_row;\n \n-\f\n+/* The caller's ORIG_REG is saved in SAVED_IN_REG.  */\n+typedef struct GTY(()) reg_saved_in_data_struct {\n+  rtx orig_reg;\n+  rtx saved_in_reg;\n+} reg_saved_in_data;\n+\n+DEF_VEC_O (reg_saved_in_data);\n+DEF_VEC_ALLOC_O (reg_saved_in_data, heap);\n+\n+/* Since we no longer have a proper CFG, we're going to create a facsimile\n+   of one on the fly while processing the frame-related insns.\n+\n+   We create dw_trace structures for each instruction trace beginning at\n+   at a label following a barrier (or beginning of the function), and\n+   ending at a barrier (or the end of the function).\n+\n+   As we encounter control transfer insns, we propagate the \"current\"\n+   row state across the edges to the starts of traces.  If an edge goes\n+   to a label that is not the start of a trace, we ignore it.  This\n+   assumes that previous compiler transformations were correct, and that\n+   we will reach the same row state from any source.  (We can perform some\n+   limited validation of this assumption, but without the full CFG we\n+   cannot be sure of full validation coverage.  It is expensive, so we\n+   only do so with checking enabled.)\n+\n+   All traces are members of the TRACE_INFO array, in the order in which\n+   they appear in the instruction stream.\n+\n+   All labels are given an LUID that indexes the LABEL_INFO array.  If\n+   the label is the start of a trace, the TRACE pointer will be non-NULL\n+   and point into the TRACE_INFO array.  */\n+\n+typedef struct\n+{\n+  /* The label that begins the trace.  This will be NULL for the first\n+     trace beginning at function entry.  */\n+  rtx label;\n+\n+  /* The row state at the beginning and end of the trace.  */\n+  dw_cfi_row *enter_row, *exit_row;\n+\n+  /* The following variables contain data used in interpreting frame related\n+     expressions.  These are not part of the \"real\" row state as defined by\n+     Dwarf, but it seems like they need to be propagated into a trace in case\n+     frame related expressions have been sunk.  */\n+  /* ??? This seems fragile.  These variables are fragments of a larger\n+     expression.  If we do not keep the entire expression together, we risk\n+     not being able to put it together properly.  Consider forcing targets\n+     to generate self-contained expressions and dropping all of the magic\n+     interpretation code in this file.  Or at least refusing to shrink wrap\n+     any frame related insn that doesn't contain a complete expression.  */\n+\n+  /* The register used for saving registers to the stack, and its offset\n+     from the CFA.  */\n+  dw_cfa_location cfa_store;\n+\n+  /* A temporary register holding an integral value used in adjusting SP\n+     or setting up the store_reg.  The \"offset\" field holds the integer\n+     value, not an offset.  */\n+  dw_cfa_location cfa_temp;\n+\n+  /* A set of registers saved in other registers.  This is the inverse of\n+     the row->reg_save info, if the entry is a DW_CFA_register.  This is\n+     implemented as a flat array because it normally contains zero or 1\n+     entry, depending on the target.  IA-64 is the big spender here, using\n+     a maximum of 5 entries.  */\n+  VEC(reg_saved_in_data, heap) *regs_saved_in_regs;\n+\n+} dw_trace_info;\n+\n+DEF_VEC_O (dw_trace_info);\n+DEF_VEC_ALLOC_O (dw_trace_info, heap);\n+\n+typedef struct\n+{\n+  dw_trace_info *trace;\n+\n+#ifdef ENABLE_CHECKING\n+  dw_cfi_row *check_row;\n+#endif\n+} dw_label_info;\n+\n+DEF_VEC_O (dw_label_info);\n+DEF_VEC_ALLOC_O (dw_label_info, heap);\n+\n+/* The variables making up the pseudo-cfg, as described above.  */\n+#if 0\n+static VEC (int, heap) *uid_luid;\n+static VEC (dw_label_info, heap) *label_info;\n+static VEC (dw_trace_info, heap) *trace_info;\n+#endif\n+\n /* A vector of call frame insns for the CIE.  */\n cfi_vec cie_cfi_vec;\n \n /* The state of the first row of the FDE table, which includes the\n    state provided by the CIE.  */\n static GTY(()) dw_cfi_row *cie_cfi_row;\n \n+static GTY(()) reg_saved_in_data *cie_return_save;\n+\n static GTY(()) unsigned long dwarf2out_cfi_label_num;\n \n /* The insn after which a new CFI note should be emitted.  */\n@@ -90,6 +183,34 @@ static rtx add_cfi_insn;\n /* When non-null, add_cfi will add the CFI to this vector.  */\n static cfi_vec *add_cfi_vec;\n \n+/* The current instruction trace.  */\n+static dw_trace_info *cur_trace;\n+\n+/* The current, i.e. most recently generated, row of the CFI table.  */\n+static dw_cfi_row *cur_row;\n+\n+/* The row state from a preceeding DW_CFA_remember_state.  */\n+static dw_cfi_row *remember_row;\n+\n+/* We delay emitting a register save until either (a) we reach the end\n+   of the prologue or (b) the register is clobbered.  This clusters\n+   register saves so that there are fewer pc advances.  */\n+\n+typedef struct {\n+  rtx reg;\n+  rtx saved_reg;\n+  HOST_WIDE_INT cfa_offset;\n+} queued_reg_save;\n+\n+DEF_VEC_O (queued_reg_save);\n+DEF_VEC_ALLOC_O (queued_reg_save, heap);\n+\n+static VEC(queued_reg_save, heap) *queued_reg_saves;\n+\n+/* The (really) current value for DW_CFA_GNU_args_size.  We delay actually\n+   emitting this data, i.e. updating CUR_ROW, without async unwind.  */\n+static HOST_WIDE_INT queued_args_size;\n+\n /* True if remember_state should be emitted before following CFI directive.  */\n static bool emit_cfa_remember;\n \n@@ -464,25 +585,6 @@ lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc, dw_cfa_location *remember)\n     }\n }\n \n-/* The current, i.e. most recently generated, row of the CFI table.  */\n-static dw_cfi_row *cur_row;\n-\n-/* The row state from a preceeding DW_CFA_remember_state.  */\n-static dw_cfi_row *remember_row;\n-\n-/* The register used for saving registers to the stack, and its offset\n-   from the CFA.  */\n-static dw_cfa_location cfa_store;\n-\n-/* A temporary register holding an integral value used in adjusting SP\n-   or setting up the store_reg.  The \"offset\" field holds the integer\n-   value, not an offset.  */\n-static dw_cfa_location cfa_temp;\n-\n-/* The (really) current value for DW_CFA_GNU_args_size.  We delay actually\n-   emitting this data, i.e. updating CUR_ROW, without async unwind.  */\n-static HOST_WIDE_INT args_size;\n-\n /* Determine if two dw_cfa_location structures define the same data.  */\n \n bool\n@@ -621,8 +723,8 @@ def_cfa_1 (dw_cfa_location *new_cfa)\n {\n   dw_cfi_ref cfi;\n \n-  if (cfa_store.reg == new_cfa->reg && new_cfa->indirect == 0)\n-    cfa_store.offset = new_cfa->offset;\n+  if (cur_trace->cfa_store.reg == new_cfa->reg && new_cfa->indirect == 0)\n+    cur_trace->cfa_store.offset = new_cfa->offset;\n \n   cfi = def_cfa_0 (&cur_row->cfa, new_cfa);\n   if (cfi)\n@@ -972,8 +1074,16 @@ dwarf2out_stack_adjust (HOST_WIDE_INT offset)\n   if (loc.reg == dw_stack_pointer_regnum)\n     loc.offset += offset;\n \n-  if (cfa_store.reg == dw_stack_pointer_regnum)\n-    cfa_store.offset += offset;\n+  if (cur_trace->cfa_store.reg == dw_stack_pointer_regnum)\n+    cur_trace->cfa_store.offset += offset;\n+\n+#ifndef STACK_GROWS_DOWNWARD\n+  offset = -offset;\n+#endif\n+\n+  queued_args_size += offset;\n+  if (queued_args_size < 0)\n+    queued_args_size = 0;\n \n   /* ??? The assumption seems to be that if A_O_A, the only CFA adjustments\n      involving the stack pointer are inside the prologue and marked as\n@@ -983,17 +1093,9 @@ dwarf2out_stack_adjust (HOST_WIDE_INT offset)\n   if (ACCUMULATE_OUTGOING_ARGS)\n     return;\n \n-#ifndef STACK_GROWS_DOWNWARD\n-  offset = -offset;\n-#endif\n-\n-  args_size += offset;\n-  if (args_size < 0)\n-    args_size = 0;\n-\n   def_cfa_1 (&loc);\n   if (flag_asynchronous_unwind_tables)\n-    dwarf2out_args_size (args_size);\n+    dwarf2out_args_size (queued_args_size);\n }\n \n /* Check INSN to see if it looks like a push or a stack adjustment, and\n@@ -1035,15 +1137,16 @@ dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n \t  if (GET_CODE (insn) == SET)\n \t    insn = SET_SRC (insn);\n \t  gcc_assert (GET_CODE (insn) == CALL);\n-\t  dwarf2out_args_size (INTVAL (XEXP (insn, 1)));\n+\t  gcc_assert (queued_args_size == INTVAL (XEXP (insn, 1)));\n+\t  dwarf2out_args_size (queued_args_size);\n \t}\n       return;\n     }\n \n   if (CALL_P (insn) && !after_p)\n     {\n       if (!flag_asynchronous_unwind_tables)\n-\tdwarf2out_args_size (args_size);\n+\tdwarf2out_args_size (queued_args_size);\n       return;\n     }\n   else if (BARRIER_P (insn))\n@@ -1061,13 +1164,13 @@ dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n \t    offset = 0;\n \t}\n \n-      offset -= args_size;\n+      offset -= queued_args_size;\n #ifndef STACK_GROWS_DOWNWARD\n       offset = -offset;\n #endif\n     }\n   else if (GET_CODE (PATTERN (insn)) == SET)\n-    offset = stack_adjust_offset (PATTERN (insn), args_size, 0);\n+    offset = stack_adjust_offset (PATTERN (insn), queued_args_size, 0);\n   else if (GET_CODE (PATTERN (insn)) == PARALLEL\n \t   || GET_CODE (PATTERN (insn)) == SEQUENCE)\n     {\n@@ -1076,7 +1179,7 @@ dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n       for (offset = 0, i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n \tif (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET)\n \t  offset += stack_adjust_offset (XVECEXP (PATTERN (insn), 0, i),\n-\t\t\t\t\t args_size, offset);\n+\t\t\t\t\t queued_args_size, offset);\n     }\n   else\n     return;\n@@ -1087,38 +1190,6 @@ dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n   dwarf2out_stack_adjust (offset);\n }\n \n-/* We delay emitting a register save until either (a) we reach the end\n-   of the prologue or (b) the register is clobbered.  This clusters\n-   register saves so that there are fewer pc advances.  */\n-\n-typedef struct {\n-  rtx reg;\n-  rtx saved_reg;\n-  HOST_WIDE_INT cfa_offset;\n-} queued_reg_save;\n-\n-DEF_VEC_O (queued_reg_save);\n-DEF_VEC_ALLOC_O (queued_reg_save, heap);\n-\n-static VEC(queued_reg_save, heap) *queued_reg_saves;\n-\n-/* The caller's ORIG_REG is saved in SAVED_IN_REG.  */\n-typedef struct GTY(()) reg_saved_in_data {\n-  rtx orig_reg;\n-  rtx saved_in_reg;\n-} reg_saved_in_data;\n-\n-DEF_VEC_O (reg_saved_in_data);\n-DEF_VEC_ALLOC_O (reg_saved_in_data, heap);\n-\n-/* A set of registers saved in other registers.  This is implemented as\n-   a flat array because it normally contains zero or 1 entry, depending\n-   on the target.  IA-64 is the big spender here, using a maximum of\n-   5 entries.  */\n-static VEC(reg_saved_in_data, heap) *regs_saved_in_regs;\n-\n-static GTY(()) reg_saved_in_data *cie_return_save;\n-\n /* Short-hand inline for the very common D_F_R (REGNO (x)) operation.  */\n /* ??? This ought to go into dwarf2out.h, except that dwarf2out.h is\n    used in places where rtl is prohibited.  */\n@@ -1148,11 +1219,12 @@ record_reg_saved_in_reg (rtx dest, rtx src)\n   reg_saved_in_data *elt;\n   size_t i;\n \n-  FOR_EACH_VEC_ELT (reg_saved_in_data, regs_saved_in_regs, i, elt)\n+  FOR_EACH_VEC_ELT (reg_saved_in_data, cur_trace->regs_saved_in_regs, i, elt)\n     if (compare_reg_or_pc (elt->orig_reg, src))\n       {\n \tif (dest == NULL)\n-\t  VEC_unordered_remove(reg_saved_in_data, regs_saved_in_regs, i);\n+\t  VEC_unordered_remove (reg_saved_in_data,\n+\t\t\t        cur_trace->regs_saved_in_regs, i);\n \telse\n \t  elt->saved_in_reg = dest;\n \treturn;\n@@ -1161,7 +1233,8 @@ record_reg_saved_in_reg (rtx dest, rtx src)\n   if (dest == NULL)\n     return;\n \n-  elt = VEC_safe_push(reg_saved_in_data, heap, regs_saved_in_regs, NULL);\n+  elt = VEC_safe_push (reg_saved_in_data, heap,\n+\t\t       cur_trace->regs_saved_in_regs, NULL);\n   elt->orig_reg = src;\n   elt->saved_in_reg = dest;\n }\n@@ -1236,7 +1309,8 @@ clobbers_queued_reg_save (const_rtx insn)\n       if (modified_in_p (q->reg, insn))\n \treturn true;\n \n-      FOR_EACH_VEC_ELT (reg_saved_in_data, regs_saved_in_regs, ir, rir)\n+      FOR_EACH_VEC_ELT (reg_saved_in_data,\n+\t\t\tcur_trace->regs_saved_in_regs, ir, rir)\n \tif (compare_reg_or_pc (q->reg, rir->orig_reg)\n \t    && modified_in_p (rir->saved_in_reg, insn))\n \t  return true;\n@@ -1259,7 +1333,7 @@ reg_saved_in (rtx reg)\n     if (q->saved_reg && regn == REGNO (q->saved_reg))\n       return q->reg;\n \n-  FOR_EACH_VEC_ELT (reg_saved_in_data, regs_saved_in_regs, i, rir)\n+  FOR_EACH_VEC_ELT (reg_saved_in_data, cur_trace->regs_saved_in_regs, i, rir)\n     if (regn == REGNO (rir->saved_in_reg))\n       return rir->orig_reg;\n \n@@ -1371,7 +1445,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n       span = NULL;\n       sregno = DWARF_FRAME_RETURN_COLUMN;\n     }\n-  else \n+  else\n     {\n       span = targetm.dwarf_register_span (src);\n       sregno = dwf_regno (src);\n@@ -1727,7 +1801,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t    {\n \t      /* Stack adjustment combining might combine some post-prologue\n \t\t stack adjustment into a prologue stack adjustment.  */\n-\t      HOST_WIDE_INT offset = stack_adjust_offset (elem, args_size, 0);\n+\t      HOST_WIDE_INT offset\n+\t\t= stack_adjust_offset (elem, queued_args_size, 0);\n \n \t      if (offset != 0)\n \t\tdwarf2out_stack_adjust (offset);\n@@ -1768,8 +1843,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t FP.  So we just rely on the backends to only set\n \t\t RTX_FRAME_RELATED_P on appropriate insns.  */\n \t      cfa.reg = dwf_regno (dest);\n-\t      cfa_temp.reg = cfa.reg;\n-\t      cfa_temp.offset = cfa.offset;\n+\t      cur_trace->cfa_temp.reg = cfa.reg;\n+\t      cur_trace->cfa_temp.offset = cfa.offset;\n \t    }\n \t  else\n \t    {\n@@ -1806,8 +1881,9 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t  offset = INTVAL (XEXP (src, 1));\n \t\t  break;\n \t\tcase REG:\n-\t\t  gcc_assert (dwf_regno (XEXP (src, 1)) == cfa_temp.reg);\n-\t\t  offset = cfa_temp.offset;\n+\t\t  gcc_assert (dwf_regno (XEXP (src, 1))\n+\t\t\t      == cur_trace->cfa_temp.reg);\n+\t\t  offset = cur_trace->cfa_temp.offset;\n \t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();\n@@ -1829,8 +1905,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\toffset = -offset;\n \t      if (cfa.reg == dw_stack_pointer_regnum)\n \t\tcfa.offset += offset;\n-\t      if (cfa_store.reg == dw_stack_pointer_regnum)\n-\t\tcfa_store.offset += offset;\n+\t      if (cur_trace->cfa_store.reg == dw_stack_pointer_regnum)\n+\t\tcur_trace->cfa_store.offset += offset;\n \t    }\n \t  else if (dest == hard_frame_pointer_rtx)\n \t    {\n@@ -1863,28 +1939,29 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t  cfa.offset += offset;\n \t\t  cfa.reg = dwf_regno (dest);\n \t\t  /* Or used to save regs to the stack.  */\n-\t\t  cfa_temp.reg = cfa.reg;\n-\t\t  cfa_temp.offset = cfa.offset;\n+\t\t  cur_trace->cfa_temp.reg = cfa.reg;\n+\t\t  cur_trace->cfa_temp.offset = cfa.offset;\n \t\t}\n \n \t      /* Rule 5 */\n \t      else if (REG_P (XEXP (src, 0))\n-\t\t       && dwf_regno (XEXP (src, 0)) == cfa_temp.reg\n+\t\t       && dwf_regno (XEXP (src, 0)) == cur_trace->cfa_temp.reg\n \t\t       && XEXP (src, 1) == stack_pointer_rtx)\n \t\t{\n \t\t  /* Setting a scratch register that we will use instead\n \t\t     of SP for saving registers to the stack.  */\n \t\t  gcc_assert (cfa.reg == dw_stack_pointer_regnum);\n-\t\t  cfa_store.reg = dwf_regno (dest);\n-\t\t  cfa_store.offset = cfa.offset - cfa_temp.offset;\n+\t\t  cur_trace->cfa_store.reg = dwf_regno (dest);\n+\t\t  cur_trace->cfa_store.offset\n+\t\t    = cfa.offset - cur_trace->cfa_temp.offset;\n \t\t}\n \n \t      /* Rule 9 */\n \t      else if (GET_CODE (src) == LO_SUM\n \t\t       && CONST_INT_P (XEXP (src, 1)))\n \t\t{\n-\t\t  cfa_temp.reg = dwf_regno (dest);\n-\t\t  cfa_temp.offset = INTVAL (XEXP (src, 1));\n+\t\t  cur_trace->cfa_temp.reg = dwf_regno (dest);\n+\t\t  cur_trace->cfa_temp.offset = INTVAL (XEXP (src, 1));\n \t\t}\n \t      else\n \t\tgcc_unreachable ();\n@@ -1893,18 +1970,18 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t  /* Rule 6 */\n \tcase CONST_INT:\n-\t  cfa_temp.reg = dwf_regno (dest);\n-\t  cfa_temp.offset = INTVAL (src);\n+\t  cur_trace->cfa_temp.reg = dwf_regno (dest);\n+\t  cur_trace->cfa_temp.offset = INTVAL (src);\n \t  break;\n \n \t  /* Rule 7 */\n \tcase IOR:\n \t  gcc_assert (REG_P (XEXP (src, 0))\n-\t\t      && dwf_regno (XEXP (src, 0)) == cfa_temp.reg\n+\t\t      && dwf_regno (XEXP (src, 0)) == cur_trace->cfa_temp.reg\n \t\t      && CONST_INT_P (XEXP (src, 1)));\n \n-\t  cfa_temp.reg = dwf_regno (dest);\n-\t  cfa_temp.offset |= INTVAL (XEXP (src, 1));\n+\t  cur_trace->cfa_temp.reg = dwf_regno (dest);\n+\t  cur_trace->cfa_temp.offset |= INTVAL (XEXP (src, 1));\n \t  break;\n \n \t  /* Skip over HIGH, assuming it will be followed by a LO_SUM,\n@@ -1931,10 +2008,11 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t Thus we must flush whatever we have queued first.  */\n \t      dwarf2out_flush_queued_reg_saves ();\n \n-              gcc_assert (cfa_store.reg == dwf_regno (XEXP (src, 0)));\n+              gcc_assert (cur_trace->cfa_store.reg\n+\t\t\t  == dwf_regno (XEXP (src, 0)));\n               fde->stack_realign = 1;\n               fde->stack_realignment = INTVAL (XEXP (src, 1));\n-              cfa_store.offset = 0;\n+              cur_trace->cfa_store.offset = 0;\n \n \t      if (cfa.reg != dw_stack_pointer_regnum\n \t\t  && cfa.reg != dw_frame_pointer_regnum)\n@@ -1965,16 +2043,16 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  offset = -INTVAL (XEXP (XEXP (XEXP (dest, 0), 1), 1));\n \n \t  gcc_assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM\n-\t\t      && cfa_store.reg == dw_stack_pointer_regnum);\n+\t\t      && cur_trace->cfa_store.reg == dw_stack_pointer_regnum);\n \n-\t  cfa_store.offset += offset;\n+\t  cur_trace->cfa_store.offset += offset;\n \t  if (cfa.reg == dw_stack_pointer_regnum)\n-\t    cfa.offset = cfa_store.offset;\n+\t    cfa.offset = cur_trace->cfa_store.offset;\n \n \t  if (GET_CODE (XEXP (dest, 0)) == POST_MODIFY)\n-\t    offset -= cfa_store.offset;\n+\t    offset -= cur_trace->cfa_store.offset;\n \t  else\n-\t    offset = -cfa_store.offset;\n+\t    offset = -cur_trace->cfa_store.offset;\n \t  break;\n \n \t  /* Rule 11 */\n@@ -1987,9 +2065,9 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t  gcc_assert ((REGNO (XEXP (XEXP (dest, 0), 0))\n \t\t       == STACK_POINTER_REGNUM)\n-\t\t      && cfa_store.reg == dw_stack_pointer_regnum);\n+\t\t      && cur_trace->cfa_store.reg == dw_stack_pointer_regnum);\n \n-\t  cfa_store.offset += offset;\n+\t  cur_trace->cfa_store.offset += offset;\n \n           /* Rule 18: If stack is aligned, we will use FP as a\n \t     reference to represent the address of the stored\n@@ -1999,16 +2077,16 @@ dwarf2out_frame_debug_expr (rtx expr)\n               && src == hard_frame_pointer_rtx)\n \t    {\n \t      gcc_assert (cfa.reg != dw_frame_pointer_regnum);\n-\t      cfa_store.offset = 0;\n+\t      cur_trace->cfa_store.offset = 0;\n \t    }\n \n \t  if (cfa.reg == dw_stack_pointer_regnum)\n-\t    cfa.offset = cfa_store.offset;\n+\t    cfa.offset = cur_trace->cfa_store.offset;\n \n \t  if (GET_CODE (XEXP (dest, 0)) == POST_DEC)\n-\t    offset += -cfa_store.offset;\n+\t    offset += -cur_trace->cfa_store.offset;\n \t  else\n-\t    offset = -cfa_store.offset;\n+\t    offset = -cur_trace->cfa_store.offset;\n \t  break;\n \n \t  /* Rule 12 */\n@@ -2029,12 +2107,12 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t    if (cfa.reg == regno)\n \t      offset -= cfa.offset;\n-\t    else if (cfa_store.reg == regno)\n-\t      offset -= cfa_store.offset;\n+\t    else if (cur_trace->cfa_store.reg == regno)\n+\t      offset -= cur_trace->cfa_store.offset;\n \t    else\n \t      {\n-\t\tgcc_assert (cfa_temp.reg == regno);\n-\t\toffset -= cfa_temp.offset;\n+\t\tgcc_assert (cur_trace->cfa_temp.reg == regno);\n+\t\toffset -= cur_trace->cfa_temp.offset;\n \t      }\n \t  }\n \t  break;\n@@ -2047,21 +2125,22 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t    if (cfa.reg == regno)\n \t      offset = -cfa.offset;\n-\t    else if (cfa_store.reg == regno)\n-\t      offset = -cfa_store.offset;\n+\t    else if (cur_trace->cfa_store.reg == regno)\n+\t      offset = -cur_trace->cfa_store.offset;\n \t    else\n \t      {\n-\t\tgcc_assert (cfa_temp.reg == regno);\n-\t\toffset = -cfa_temp.offset;\n+\t\tgcc_assert (cur_trace->cfa_temp.reg == regno);\n+\t\toffset = -cur_trace->cfa_temp.offset;\n \t      }\n \t  }\n \t  break;\n \n \t  /* Rule 14 */\n \tcase POST_INC:\n-\t  gcc_assert (cfa_temp.reg == dwf_regno (XEXP (XEXP (dest, 0), 0)));\n-\t  offset = -cfa_temp.offset;\n-\t  cfa_temp.offset -= GET_MODE_SIZE (GET_MODE (dest));\n+\t  gcc_assert (cur_trace->cfa_temp.reg\n+\t\t      == dwf_regno (XEXP (XEXP (dest, 0), 0)));\n+\t  offset = -cur_trace->cfa_temp.offset;\n+\t  cur_trace->cfa_temp.offset -= GET_MODE_SIZE (GET_MODE (dest));\n \t  break;\n \n \tdefault:\n@@ -2453,7 +2532,7 @@ add_cfis_to_fde (void)\n }\n \n /* Scan the function and create the initial set of CFI notes.  */\n- \n+\n static void\n create_cfi_notes (void)\n {\n@@ -2692,75 +2771,87 @@ initial_return_save (rtx rtl)\n     }\n }\n \n+static void\n+create_cie_data (void)\n+{\n+  dw_cfa_location loc;\n+  dw_trace_info cie_trace;\n+\n+  dw_stack_pointer_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);\n+  dw_frame_pointer_regnum = DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM);\n+\n+  memset (&cie_trace, 0, sizeof(cie_trace));\n+  cur_trace = &cie_trace;\n+\n+  add_cfi_vec = &cie_cfi_vec;\n+  cie_cfi_row = cur_row = new_cfi_row ();\n+\n+  /* On entry, the Canonical Frame Address is at SP.  */\n+  memset(&loc, 0, sizeof (loc));\n+  loc.reg = dw_stack_pointer_regnum;\n+  loc.offset = INCOMING_FRAME_SP_OFFSET;\n+  def_cfa_1 (&loc);\n+\n+  if (targetm.debug_unwind_info () == UI_DWARF2\n+      || targetm_common.except_unwind_info (&global_options) == UI_DWARF2)\n+    {\n+      initial_return_save (INCOMING_RETURN_ADDR_RTX);\n+\n+      /* For a few targets, we have the return address incoming into a\n+\t register, but choose a different return column.  This will result\n+\t in a DW_CFA_register for the return, and an entry in\n+\t regs_saved_in_regs to match.  If the target later stores that\n+\t return address register to the stack, we want to be able to emit\n+\t the DW_CFA_offset against the return column, not the intermediate\n+\t save register.  Save the contents of regs_saved_in_regs so that\n+\t we can re-initialize it at the start of each function.  */\n+      switch (VEC_length (reg_saved_in_data, cie_trace.regs_saved_in_regs))\n+\t{\n+\tcase 0:\n+\t  break;\n+\tcase 1:\n+\t  cie_return_save = ggc_alloc_reg_saved_in_data ();\n+\t  *cie_return_save = *VEC_index (reg_saved_in_data,\n+\t\t\t\t\t cie_trace.regs_saved_in_regs, 0);\n+\t  VEC_free (reg_saved_in_data, heap, cie_trace.regs_saved_in_regs);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  add_cfi_vec = NULL;\n+  cur_row = NULL;\n+  cur_trace = NULL;\n+}\n+\n /* Annotate the function with NOTE_INSN_CFI notes to record the CFI\n    state at each location within the function.  These notes will be\n    emitted during pass_final.  */\n \n static unsigned int\n execute_dwarf2_frame (void)\n {\n+  dw_trace_info dummy_trace;\n+\n   gcc_checking_assert (queued_reg_saves == NULL);\n-  gcc_checking_assert (regs_saved_in_regs == NULL);\n \n   /* The first time we're called, compute the incoming frame state.  */\n   if (cie_cfi_vec == NULL)\n-    {\n-      dw_cfa_location loc;\n-\n-      dw_stack_pointer_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);\n-      dw_frame_pointer_regnum = DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM);\n-\n-      add_cfi_vec = &cie_cfi_vec;\n-      cie_cfi_row = cur_row = new_cfi_row ();\n-\n-      /* On entry, the Canonical Frame Address is at SP.  */\n-      memset(&loc, 0, sizeof (loc));\n-      loc.reg = dw_stack_pointer_regnum;\n-      loc.offset = INCOMING_FRAME_SP_OFFSET;\n-      def_cfa_1 (&loc);\n-\n-      if (targetm.debug_unwind_info () == UI_DWARF2\n-          || targetm_common.except_unwind_info (&global_options) == UI_DWARF2)\n-\t{\n-\t  initial_return_save (INCOMING_RETURN_ADDR_RTX);\n-\n-\t  /* For a few targets, we have the return address incoming into a\n-\t     register, but choose a different return column.  This will result\n-\t     in a DW_CFA_register for the return, and an entry in\n-\t     regs_saved_in_regs to match.  If the target later stores that\n-\t     return address register to the stack, we want to be able to emit\n-\t     the DW_CFA_offset against the return column, not the intermediate\n-\t     save register.  Save the contents of regs_saved_in_regs so that\n-\t     we can re-initialize it at the start of each function.  */\n-\t  switch (VEC_length (reg_saved_in_data, regs_saved_in_regs))\n-\t    {\n-\t    case 0:\n-\t      break;\n-\t    case 1:\n-\t      cie_return_save = ggc_alloc_reg_saved_in_data ();\n-\t      *cie_return_save = *VEC_index (reg_saved_in_data,\n-\t\t\t\t\t     regs_saved_in_regs, 0);\n-\t      VEC_pop (reg_saved_in_data, regs_saved_in_regs);\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n+    create_cie_data ();\n \n-      add_cfi_vec = NULL;\n-    }\n+  memset (&dummy_trace, 0, sizeof(dummy_trace));\n+  cur_trace = &dummy_trace;\n \n   /* Set up state for generating call frame debug info.  */\n   cur_row = copy_cfi_row (cie_cfi_row);\n   if (cie_return_save)\n     VEC_safe_push (reg_saved_in_data, heap,\n-\t\t   regs_saved_in_regs, cie_return_save);\n-\n-  cfa_store = cur_row->cfa;\n-  args_size = 0;\n+\t\t   cur_trace->regs_saved_in_regs, cie_return_save);\n \n-  memset (&cfa_temp, 0, sizeof(cfa_temp));\n-  cfa_temp.reg = INVALID_REGNUM;\n+  cur_trace->cfa_store = cur_row->cfa;\n+  cur_trace->cfa_temp.reg = INVALID_REGNUM;\n+  queued_args_size = 0;\n \n   dwarf2out_alloc_current_fde ();\n \n@@ -2771,11 +2862,12 @@ execute_dwarf2_frame (void)\n   /* Reset all function-specific information, particularly for GC.  */\n   XDELETEVEC (barrier_args_size);\n   barrier_args_size = NULL;\n-  VEC_free (reg_saved_in_data, heap, regs_saved_in_regs);\n+  VEC_free (reg_saved_in_data, heap, cur_trace->regs_saved_in_regs);\n   VEC_free (queued_reg_save, heap, queued_reg_saves);\n \n   free_cfi_row (cur_row);\n   cur_row = NULL;\n+  cur_trace = NULL;\n \n   return 0;\n }\n@@ -2864,7 +2956,7 @@ output_cfa_loc (dw_cfi_ref cfi, int for_eh)\n \n   if (cfi->dw_cfi_opc == DW_CFA_expression)\n     {\n-      unsigned r = \n+      unsigned r =\n \tDWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n       dw2_asm_output_data (1, r, NULL);\n       loc = cfi->dw_cfi_oprnd2.dw_cfi_loc;\n@@ -2890,7 +2982,7 @@ output_cfa_loc_raw (dw_cfi_ref cfi)\n \n   if (cfi->dw_cfi_opc == DW_CFA_expression)\n     {\n-      unsigned r = \n+      unsigned r =\n \tDWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n       fprintf (asm_out_file, \"%#x,\", r);\n       loc = cfi->dw_cfi_oprnd2.dw_cfi_loc;"}]}