{"sha": "5c5ea553a72393408e66679dfbae8051f1cb36c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM1ZWE1NTNhNzIzOTM0MDhlNjY2NzlkZmJhZTgwNTFmMWNiMzZjMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-15T06:16:31Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-15T06:16:31Z"}, "message": "Don't crash on undefined anonymous field.\n\nFrom-SVN: r167845", "tree": {"sha": "0a43d208d9e43b7df5eb1732d7ef06d7aa66a785", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a43d208d9e43b7df5eb1732d7ef06d7aa66a785"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c5ea553a72393408e66679dfbae8051f1cb36c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5ea553a72393408e66679dfbae8051f1cb36c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c5ea553a72393408e66679dfbae8051f1cb36c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5ea553a72393408e66679dfbae8051f1cb36c0/comments", "author": null, "committer": null, "parents": [{"sha": "05575a4695b01941551f84e718997f6803c82dbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05575a4695b01941551f84e718997f6803c82dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05575a4695b01941551f84e718997f6803c82dbc"}], "stats": {"total": 30, "additions": 20, "deletions": 10}, "files": [{"sha": "5a75a0bc8cf59be4edc479d60eb0d35eb83566cb", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5ea553a72393408e66679dfbae8051f1cb36c0/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5ea553a72393408e66679dfbae8051f1cb36c0/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=5c5ea553a72393408e66679dfbae8051f1cb36c0", "patch": "@@ -3375,6 +3375,7 @@ Struct_type::do_verify()\n   Struct_field_list* fields = this->fields_;\n   if (fields == NULL)\n     return true;\n+  bool ret = true;\n   for (Struct_field_list::iterator p = fields->begin();\n        p != fields->end();\n        ++p)\n@@ -3384,7 +3385,7 @@ Struct_type::do_verify()\n \t{\n \t  error_at(p->location(), \"struct field type is incomplete\");\n \t  p->set_type(Type::make_error_type());\n-\t  return false;\n+\t  ret = false;\n \t}\n       else if (p->is_anonymous())\n \t{\n@@ -3396,7 +3397,7 @@ Struct_type::do_verify()\n \t    }\n \t}\n     }\n-  return true;\n+  return ret;\n }\n \n // Whether this contains a pointer.\n@@ -3758,13 +3759,16 @@ Struct_type::do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n   bool any_fields_set = false;\n   VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc,\n \t\t\t\t\t    this->fields_->size());\n-  Struct_field_list::const_iterator p = this->fields_->begin();\n-  for (tree field = TYPE_FIELDS(type_tree);\n-       field != NULL_TREE;\n-       field = DECL_CHAIN(field), ++p)\n+\n+  tree field = TYPE_FIELDS(type_tree);\n+  for (Struct_field_list::const_iterator p = this->fields_->begin();\n+       p != this->fields_->end();\n+       ++p, field = DECL_CHAIN(field))\n     {\n-      gcc_assert(p != this->fields_->end());\n       tree value = p->type()->get_init_tree(gogo, is_clear);\n+      if (value == error_mark_node)\n+\treturn error_mark_node;\n+      gcc_assert(field != NULL_TREE);\n       if (value != NULL)\n \t{\n \t  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n@@ -3775,7 +3779,7 @@ Struct_type::do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n \t    is_constant = false;\n \t}\n     }\n-  gcc_assert(p == this->fields_->end());\n+  gcc_assert(field == NULL_TREE);\n \n   if (!any_fields_set)\n     {\n@@ -6891,7 +6895,9 @@ Named_type::do_get_tree(Gogo* gogo)\n \treturn this->named_tree_;\n       t = make_node(RECORD_TYPE);\n       this->named_tree_ = t;\n-      this->type_->struct_type()->fill_in_tree(gogo, t);\n+      t = this->type_->struct_type()->fill_in_tree(gogo, t);\n+      if (t == error_mark_node)\n+\treturn error_mark_node;\n       break;\n \n     case TYPE_ARRAY:\n@@ -7728,6 +7734,9 @@ Type::find_field_or_method(const Type* type,\n       if (!pf->is_anonymous())\n \tcontinue;\n \n+      if (pf->type()->is_error_type() || pf->type()->is_undefined())\n+\tcontinue;\n+\n       Named_type* fnt = pf->type()->deref()->named_type();\n       gcc_assert(fnt != NULL);\n \n@@ -7845,7 +7854,8 @@ Type::is_unexported_field_or_method(Gogo* gogo, const Type* type,\n        pf != fields->end();\n        ++pf)\n     {\n-      if (pf->is_anonymous())\n+      if (pf->is_anonymous()\n+\t  && (!pf->type()->is_error_type() && !pf->type()->is_undefined()))\n \t{\n \t  Named_type* subtype = pf->type()->deref()->named_type();\n \t  gcc_assert(subtype != NULL);"}]}