{"sha": "a5093353f1d469f42be7672f4e857bc36d09936d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUwOTMzNTNmMWQ0NjlmNDJiZTc2NzJmNGU4NTdiYzM2ZDA5OTM2ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-12-16T18:10:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-12-16T18:10:08Z"}, "message": "omp-low.c (expand_omp_parallel): Set function properties.\n\n\t* omp-low.c (expand_omp_parallel): Set function properties.\n\t* function.h (struct function): Add curr_properties and last_verified.\n\t* passes.c (register_dump_files): Do not set TODO_set_props for the\n\tfirst pass\n\t(init_optimization_passes): Set it here; reorder initialization so the\n\tdump files appear in more logical order.\n\t(last_verified, curr_properties): Kill.\n\t(do_per_function): New function.\n\t(execute_function_todo): Break out from ...\n\t(execute_todo): ... here; handle per-function flags.\n\t(clear_last_verified, verify_curr_properties,\n\tupdate_properties_after_pass): New functions.\n\t(execute_one_pass): Handle per-function properties.\n\t(execute_ipa_pass_list): Use do_per_function; sanity check that cfun\n\tand current_function_decls are cleared out.\n\t* ipa-cp.c (constant_val_insert): Clear cfun/current_function_decl\n\tafter use.\n\nFrom-SVN: r119966", "tree": {"sha": "dd7896f1a2b9c68948381b4e79fb25400240afa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd7896f1a2b9c68948381b4e79fb25400240afa0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5093353f1d469f42be7672f4e857bc36d09936d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5093353f1d469f42be7672f4e857bc36d09936d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5093353f1d469f42be7672f4e857bc36d09936d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5093353f1d469f42be7672f4e857bc36d09936d/comments", "author": null, "committer": null, "parents": [{"sha": "e5c0ebd921c534e1b56fab49a589884e2ffeb334", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c0ebd921c534e1b56fab49a589884e2ffeb334", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5c0ebd921c534e1b56fab49a589884e2ffeb334"}], "stats": {"total": 180, "additions": 131, "deletions": 49}, "files": [{"sha": "b667dd1d74ddaec48c884436022ea5052a488668", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5093353f1d469f42be7672f4e857bc36d09936d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5093353f1d469f42be7672f4e857bc36d09936d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5093353f1d469f42be7672f4e857bc36d09936d", "patch": "@@ -1,3 +1,23 @@\n+2006-12-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* omp-low.c (expand_omp_parallel): Set function properties.\n+\t* function.h (struct function): Add curr_properties and last_verified.\n+\t* passes.c (register_dump_files): Do not set TODO_set_props for the\n+\tfirst pass\n+\t(init_optimization_passes): Set it here; reorder initialization so the\n+\tdump files appear in more logical order.\n+\t(last_verified, curr_properties): Kill.\n+\t(do_per_function): New function.\n+\t(execute_function_todo): Break out from ...\n+\t(execute_todo): ... here; handle per-function flags.\n+\t(clear_last_verified, verify_curr_properties,\n+\tupdate_properties_after_pass): New functions.\n+\t(execute_one_pass): Handle per-function properties.\n+\t(execute_ipa_pass_list): Use do_per_function; sanity check that cfun\n+\tand current_function_decls are cleared out.\n+\t* ipa-cp.c (constant_val_insert): Clear cfun/current_function_decl\n+\tafter use.\n+\n 2006-12-16  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR middle-end/7651"}, {"sha": "e8039a711a1807ce52dcbca233551bc90d72222f", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5093353f1d469f42be7672f4e857bc36d09936d/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5093353f1d469f42be7672f4e857bc36d09936d/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=a5093353f1d469f42be7672f4e857bc36d09936d", "patch": "@@ -373,6 +373,10 @@ struct function GTY(())\n      Used for detecting stack clobbers.  */\n   tree stack_protect_guard;\n \n+  /* Properties used by the pass manager.  */\n+  unsigned int curr_properties;\n+  unsigned int last_verified;\n+\n   /* Collected bit flags.  */\n \n   /* Nonzero if function being compiled needs to be given an address"}, {"sha": "0451667917c000cd8409c781d19c241f6455cedb", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5093353f1d469f42be7672f4e857bc36d09936d/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5093353f1d469f42be7672f4e857bc36d09936d/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=a5093353f1d469f42be7672f4e857bc36d09936d", "patch": "@@ -453,6 +453,8 @@ constant_val_insert (tree fn, tree parm1, tree val)\n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (func)->succs)\n     FOR_EACH_EDGE (e_step, ei, ENTRY_BLOCK_PTR_FOR_FUNCTION (func)->succs)\n       bsi_insert_on_edge_immediate (e_step, init_stmt);\n+  current_function_decl = NULL;\n+  cfun = NULL;\n }\n \n /* build INTEGER_CST tree with type TREE_TYPE and "}, {"sha": "e744a244fe374aab8ec7d38c57eb1e5babba40f0", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5093353f1d469f42be7672f4e857bc36d09936d/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5093353f1d469f42be7672f4e857bc36d09936d/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=a5093353f1d469f42be7672f4e857bc36d09936d", "patch": "@@ -2531,6 +2531,8 @@ expand_omp_parallel (struct omp_region *region)\n       new_bb = move_sese_region_to_fn (child_cfun, entry_bb, exit_bb);\n       if (exit_bb)\n \tsingle_succ_edge (new_bb)->flags = EDGE_FALLTHRU;\n+      DECL_STRUCT_FUNCTION (child_fn)->curr_properties\n+\t= cfun->curr_properties;\n       cgraph_add_new_function (child_fn);\n \n       /* Convert OMP_RETURN into a RETURN_EXPR.  */"}, {"sha": "e4bac7a844b885d953afeef8ac8d7421d4ecf388", "filename": "gcc/passes.c", "status": "modified", "additions": 103, "deletions": 49, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5093353f1d469f42be7672f4e857bc36d09936d/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5093353f1d469f42be7672f4e857bc36d09936d/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=a5093353f1d469f42be7672f4e857bc36d09936d", "patch": "@@ -371,7 +371,6 @@ static void\n register_dump_files (struct tree_opt_pass *pass, bool ipa, int properties)\n {\n   pass->properties_required |= properties;\n-  pass->todo_flags_start |= TODO_set_props;\n   register_dump_files_1 (pass, ipa, properties);\n }\n \n@@ -695,29 +694,52 @@ init_optimization_passes (void)\n #undef NEXT_PASS\n \n   /* Register the passes with the tree dump code.  */\n+  register_dump_files (all_lowering_passes, false, PROP_gimple_any);\n+  all_lowering_passes->todo_flags_start |= TODO_set_props;\n   register_dump_files (all_ipa_passes, true,\n \t\t       PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh\n \t\t       | PROP_cfg);\n-  register_dump_files (all_lowering_passes, false, PROP_gimple_any);\n   register_dump_files (all_passes, false,\n \t\t       PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh\n \t\t       | PROP_cfg);\n }\n \n-static unsigned int last_verified;\n-static unsigned int curr_properties;\n+/* If we are in IPA mode (i.e., current_function_decl is NULL), call\n+   function CALLBACK for every function in the call graph.  Otherwise,\n+   call CALLBACK on the current function.  */ \n \n static void\n-execute_todo (unsigned int flags)\n+do_per_function (void (*callback) (void *data), void *data)\n {\n-#if defined ENABLE_CHECKING\n-  if (need_ssa_update_p ())\n-    gcc_assert (flags & TODO_update_ssa_any);\n-#endif\n+  if (current_function_decl)\n+    callback (data);\n+  else\n+    {\n+      struct cgraph_node *node;\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->analyzed)\n+\t  {\n+\t    push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\t    current_function_decl = node->decl;\n+\t    callback (data);\n+\t    free_dominance_info (CDI_DOMINATORS);\n+\t    free_dominance_info (CDI_POST_DOMINATORS);\n+\t    current_function_decl = NULL;\n+\t    pop_cfun ();\n+\t    ggc_collect ();\n+\t  }\n+    }\n+}\n+\n+/* Perform all TODO actions that ought to be done on each function.  */\n \n-  if (curr_properties & PROP_ssa)\n+static void\n+execute_function_todo (void *data)\n+{\n+  unsigned int flags = (size_t)data;\n+  if (cfun->curr_properties & PROP_ssa)\n     flags |= TODO_verify_ssa;\n-  flags &= ~last_verified;\n+  flags &= ~cfun->last_verified;\n   if (!flags)\n     return;\n   \n@@ -743,7 +765,7 @@ execute_todo (unsigned int flags)\n     {\n       unsigned update_flags = flags & TODO_update_ssa_any;\n       update_ssa (update_flags);\n-      last_verified &= ~TODO_verify_ssa;\n+      cfun->last_verified &= ~TODO_verify_ssa;\n     }\n \n   if (flags & TODO_remove_unused_locals)\n@@ -752,19 +774,20 @@ execute_todo (unsigned int flags)\n   if ((flags & TODO_dump_func)\n       && dump_file && current_function_decl)\n     {\n-      if (curr_properties & PROP_trees)\n+      if (cfun->curr_properties & PROP_trees)\n         dump_function_to_file (current_function_decl,\n                                dump_file, dump_flags);\n       else\n \t{\n \t  if (dump_flags & TDF_SLIM)\n \t    print_rtl_slim_with_bb (dump_file, get_insns (), dump_flags);\n-\t  else if ((curr_properties & PROP_cfg) && (dump_flags & TDF_BLOCKS))\n+\t  else if ((cfun->curr_properties & PROP_cfg)\n+\t\t   && (dump_flags & TDF_BLOCKS))\n \t    print_rtl_with_bb (dump_file, get_insns ());\n           else\n \t    print_rtl (dump_file, get_insns ());\n \n-\t  if (curr_properties & PROP_cfg\n+\t  if (cfun->curr_properties & PROP_cfg\n \t      && graph_dump_format != no_graph\n \t      && (dump_flags & TDF_GRAPH))\n \t    print_rtl_graph_with_bb (dump_file_name, get_insns ());\n@@ -774,6 +797,32 @@ execute_todo (unsigned int flags)\n \t close the file before aborting.  */\n       fflush (dump_file);\n     }\n+\n+#if defined ENABLE_CHECKING\n+  if (flags & TODO_verify_ssa)\n+    verify_ssa (true);\n+  if (flags & TODO_verify_flow)\n+    verify_flow_info ();\n+  if (flags & TODO_verify_stmts)\n+    verify_stmts ();\n+  if (flags & TODO_verify_loops)\n+    verify_loop_closed_ssa ();\n+#endif\n+\n+  cfun->last_verified = flags & TODO_verify_all;\n+}\n+\n+/* Perform all TODO actions.  */\n+static void\n+execute_todo (unsigned int flags)\n+{\n+#if defined ENABLE_CHECKING\n+  if (need_ssa_update_p ())\n+    gcc_assert (flags & TODO_update_ssa_any);\n+#endif\n+\n+  do_per_function (execute_function_todo, (void *)(size_t) flags);\n+\n   if ((flags & TODO_dump_cgraph)\n       && dump_file && !current_function_decl)\n     {\n@@ -787,19 +836,34 @@ execute_todo (unsigned int flags)\n     {\n       ggc_collect ();\n     }\n+}\n \n-#if defined ENABLE_CHECKING\n-  if (flags & TODO_verify_ssa)\n-    verify_ssa (true);\n-  if (flags & TODO_verify_flow)\n-    verify_flow_info ();\n-  if (flags & TODO_verify_stmts)\n-    verify_stmts ();\n-  if (flags & TODO_verify_loops)\n-    verify_loop_closed_ssa ();\n-#endif\n+/* Clear the last verified flag.  */\n+\n+static void\n+clear_last_verified (void *data ATTRIBUTE_UNUSED)\n+{\n+  cfun->last_verified = 0;\n+}\n+\n+/* Helper function. Verify that the properties has been turn into the\n+   properties expected by the pass.  */\n \n-  last_verified = flags & TODO_verify_all;\n+static void\n+verify_curr_properties (void *data)\n+{\n+  unsigned int props = (size_t)data;\n+  gcc_assert ((cfun->curr_properties & props) == props);\n+}\n+\n+/* After executing the pass, apply expected changes to the function\n+   properties. */\n+static void\n+update_properties_after_pass (void *data)\n+{\n+  struct tree_opt_pass *pass = data;\n+  cfun->curr_properties = (cfun->curr_properties | pass->properties_provided)\n+\t\t           & ~pass->properties_destroyed;\n }\n \n static bool\n@@ -813,17 +877,19 @@ execute_one_pass (struct tree_opt_pass *pass)\n     return false;\n \n   if (pass->todo_flags_start & TODO_set_props)\n-    curr_properties = pass->properties_required;\n+    cfun->curr_properties = pass->properties_required;\n \n   /* Note that the folders should only create gimple expressions.\n      This is a hack until the new folder is ready.  */\n-  in_gimple_form = (curr_properties & PROP_trees) != 0;\n+  in_gimple_form = (cfun && (cfun->curr_properties & PROP_trees)) != 0;\n \n   /* Run pre-pass verification.  */\n   execute_todo (pass->todo_flags_start);\n \n-  gcc_assert ((curr_properties & pass->properties_required)\n-\t      == pass->properties_required);\n+#ifdef ENABLE_CHECKING\n+  do_per_function (verify_curr_properties,\n+\t\t   (void *)(size_t)pass->properties_required);\n+#endif\n \n   /* If a dump file name is present, open it if enabled.  */\n   if (pass->static_pass_number != -1)\n@@ -856,20 +922,20 @@ execute_one_pass (struct tree_opt_pass *pass)\n   if (pass->execute)\n     {\n       todo_after = pass->execute ();\n-      last_verified = 0;\n+      do_per_function (clear_last_verified, NULL);\n     }\n \n   /* Stop timevar.  */\n   if (pass->tv_id)\n     timevar_pop (pass->tv_id);\n \n-  curr_properties = (curr_properties | pass->properties_provided)\n-\t\t    & ~pass->properties_destroyed;\n+  do_per_function (update_properties_after_pass, pass);\n \n   if (initializing_dump\n       && dump_file\n       && graph_dump_format != no_graph\n-      && (curr_properties & (PROP_cfg | PROP_rtl)) == (PROP_cfg | PROP_rtl))\n+      && (cfun->curr_properties & (PROP_cfg | PROP_rtl))\n+\t  == (PROP_cfg | PROP_rtl))\n     {\n       get_dump_file_info (pass->static_pass_number)->flags |= TDF_GRAPH;\n       dump_flags |= TDF_GRAPH;\n@@ -914,22 +980,10 @@ execute_ipa_pass_list (struct tree_opt_pass *pass)\n {\n   do\n     {\n+      gcc_assert (!current_function_decl);\n+      gcc_assert (!cfun);\n       if (execute_one_pass (pass) && pass->sub)\n-\t{\n-\t  struct cgraph_node *node;\n-\t  for (node = cgraph_nodes; node; node = node->next)\n-\t    if (node->analyzed)\n-\t      {\n-\t\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-\t\tcurrent_function_decl = node->decl;\n-\t\texecute_pass_list (pass->sub);\n-\t\tfree_dominance_info (CDI_DOMINATORS);\n-\t\tfree_dominance_info (CDI_POST_DOMINATORS);\n-\t\tcurrent_function_decl = NULL;\n-\t\tpop_cfun ();\n-\t\tggc_collect ();\n-\t      }\n-\t}\n+\tdo_per_function ((void (*)(void *))execute_pass_list, pass->sub);\n       pass = pass->next;\n     }\n   while (pass);"}]}