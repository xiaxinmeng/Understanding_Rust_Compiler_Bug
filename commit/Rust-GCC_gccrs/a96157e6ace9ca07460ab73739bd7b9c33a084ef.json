{"sha": "a96157e6ace9ca07460ab73739bd7b9c33a084ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk2MTU3ZTZhY2U5Y2EwNzQ2MGFiNzM3MzliZDdiOWMzM2EwODRlZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T13:30:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T13:30:34Z"}, "message": "[multiple changes]\n\n2013-04-11  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* ttypes.ads, get_targ.ads: More minor rewording of comments.\n\n2013-04-11  Johannes Kanig  <kanig@adacore.com>\n\n\t* debug.adb: Document use of switch -gnatd.Z.\n\n2013-04-11  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma): Both pragma Depends and Global can now\n\tsupport renamings of entire objects. Legal renamings are replaced by\n\tthe object they rename.\n\t(Is_Renaming): New routine.\n\n2013-04-11  Yannick Moy  <moy@adacore.com>\n\n\t* set_targ.adb, opt.ads: Minor changes in comments.\n\nFrom-SVN: r197795", "tree": {"sha": "e298a7c6060e05952e462afd584372d0e59fb0f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e298a7c6060e05952e462afd584372d0e59fb0f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a96157e6ace9ca07460ab73739bd7b9c33a084ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96157e6ace9ca07460ab73739bd7b9c33a084ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a96157e6ace9ca07460ab73739bd7b9c33a084ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96157e6ace9ca07460ab73739bd7b9c33a084ef/comments", "author": null, "committer": null, "parents": [{"sha": "88ff8916c7cbbf0810255d8db096fd69cd4d1105", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ff8916c7cbbf0810255d8db096fd69cd4d1105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88ff8916c7cbbf0810255d8db096fd69cd4d1105"}], "stats": {"total": 162, "additions": 116, "deletions": 46}, "files": [{"sha": "86ad8e43319370461386b2c3eca324f200b48bea", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a96157e6ace9ca07460ab73739bd7b9c33a084ef", "patch": "@@ -1,3 +1,22 @@\n+2013-04-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* ttypes.ads, get_targ.ads: More minor rewording of comments.\n+\n+2013-04-11  Johannes Kanig  <kanig@adacore.com>\n+\n+\t* debug.adb: Document use of switch -gnatd.Z.\n+\n+2013-04-11  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Both pragma Depends and Global can now\n+\tsupport renamings of entire objects. Legal renamings are replaced by\n+\tthe object they rename.\n+\t(Is_Renaming): New routine.\n+\n+2013-04-11  Yannick Moy  <moy@adacore.com>\n+\n+\t* set_targ.adb, opt.ads: Minor changes in comments.\n+\n 2013-04-11  Ben Brosgol  <brosgol@adacore.com>\n \n \t* gnat_ugn.texi: Minor clean ups."}, {"sha": "d0923fcd28acc3fe3d372d0be3ba09a820544823", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=a96157e6ace9ca07460ab73739bd7b9c33a084ef", "patch": "@@ -143,7 +143,7 @@ package body Debug is\n    --  d.W  Print out debugging information for Walk_Library_Items\n    --  d.X  Use Expression_With_Actions\n    --  d.Y  Do not use Expression_With_Actions\n-   --  d.Z\n+   --  d.Z  Dump flow analysis graphs, for debugging purposes (gnat2why)\n \n    --  d1   Error msgs have node numbers where possible\n    --  d2   Eliminate error flags in verbose form error messages\n@@ -683,6 +683,11 @@ package body Debug is\n    --       forces use of the new N_Expression_With_Actions node in these other\n    --       cases and is intended for transitional use.\n \n+   --  d.Z  In gnat2why, in Flow analysis mode (-gnatd.Q), dump the different\n+   --       graphs (control flow, control dependence) for debugging purposes.\n+   --       This debug flag will be removed when flow analysis is sufficiently\n+   --       stable.\n+\n    --  d.Y  Prevents the use of the N_Expression_With_Actions node even in the\n    --       case of the gcc back end. Provided as a back up in case the new\n    --       scheme has problems."}, {"sha": "08af7f33855da44f9279d7944e2ce29dfc339690", "filename": "gcc/ada/get_targ.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fget_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fget_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_targ.ads?ref=a96157e6ace9ca07460ab73739bd7b9c33a084ef", "patch": "@@ -102,10 +102,11 @@ package Get_Targ is\n    --  Alignment guaranteed by malloc falls\n \n    function Get_Double_Float_Alignment     return Nat;\n-   --  Alignment required for Long_Float\n+   --  Alignment required for Long_Float or 0 if no special requirement\n \n    function Get_Double_Scalar_Alignment    return Nat;\n-   --  Alignment required for Long_Long_Integer\n+   --  Alignment required for Long_Long_Integer or larger integer types\n+   --  or 0 if no special requirement.\n \n    --  Other subprograms\n "}, {"sha": "330c8bfad012e2452e4b1c73c1513770d570f9dc", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=a96157e6ace9ca07460ab73739bd7b9c33a084ef", "patch": "@@ -1335,20 +1335,14 @@ package Opt is\n    --  GNAT\n    --  Set True to override the normal processing in Get_Targ and set the\n    --  necessary information by reading the target dependent information\n-   --  file (see package Get_Targ in get_targ.ads for full details). Set\n-   --  True by use of the -gnateT switch.\n+   --  file (see packages Get_Targ and Set_Targ for full details). Set True\n+   --  by use of the -gnateT switch.\n \n    Target_Dependent_Info_Write : Boolean := False;\n    --  GNAT\n-   --  Set True to enable a call to Get_Targ.Write_Target_Dependent_Info which\n-   --  writes a target independent information file (see package Get_Targ in\n-   --  get_targ.ads for full details). Set True by use of the -gnatet switch.\n-   --\n-   --  Note: although we do indeed set this switch to True as documented above\n-   --  if -gnatet is encountered, we actually do not use this flag to enable\n-   --  writing of the file. That's because the read in Get_Targ has to be done\n-   --  long before the normal circuit for setting switches (see Get_Targ for\n-   --  full details of how we handle this requirement).\n+   --  Set True to enable a call to Set_Targ.Write_Target_Dependent_Info which\n+   --  writes a target independent information file (see packages Get_Targ and\n+   --  Set_Targ for full details). Set True by use of the -gnatet switch.\n \n    Task_Dispatching_Policy : Character := ' ';\n    --  GNAT, GNATBIND"}, {"sha": "828578048f3567c4ae603aefceeb4b81dce1d013", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 62, "deletions": 21, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a96157e6ace9ca07460ab73739bd7b9c33a084ef", "patch": "@@ -806,6 +806,9 @@ package body Sem_Prag is\n       --  Returns True if pragma appears within the context clause of a unit,\n       --  and False for any other placement (does not generate any messages).\n \n+      function Is_Renaming (N : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node N is a renaming\n+\n       function Is_Static_String_Expression (Arg : Node_Id) return Boolean;\n       --  Analyzes the argument, and determines if it is a static string\n       --  expression, returns True if so, False if non-static or not String.\n@@ -3013,6 +3016,17 @@ package body Sem_Prag is\n          return True;\n       end Is_In_Context_Clause;\n \n+      -----------------\n+      -- Is_Renaming --\n+      -----------------\n+\n+      function Is_Renaming (N : Node_Id) return Boolean is\n+      begin\n+         return\n+           Is_Entity_Name (N)\n+             and then Present (Renamed_Object (Entity (N)));\n+      end Is_Renaming;\n+\n       ---------------------------------\n       -- Is_Static_String_Expression --\n       ---------------------------------\n@@ -9017,8 +9031,8 @@ package body Sem_Prag is\n                   Null_Seen : in out Boolean)\n                is\n                   Is_Output : constant Boolean := not Is_Input;\n-                  Item_Id   : Entity_Id;\n                   Grouped   : Node_Id;\n+                  Item_Id   : Entity_Id;\n \n                begin\n                   --  Multiple input or output items appear as an aggregate\n@@ -9106,15 +9120,19 @@ package body Sem_Prag is\n                   else\n                      Analyze (Item);\n \n-                     if Is_Entity_Name (Item) then\n-                        Item_Id := Entity_Of (Item);\n+                     --  Find the entity of the item. If this is a renaming,\n+                     --  climb the renaming chain to reach the root object.\n+                     --  Renamings of non-entire objects do not yield an\n+                     --  entity (Empty).\n \n-                        if Present (Item_Id)\n-                          and then Ekind_In (Item_Id, E_Abstract_State,\n-                                                      E_In_Parameter,\n-                                                      E_In_Out_Parameter,\n-                                                      E_Out_Parameter,\n-                                                      E_Variable)\n+                     Item_Id := Entity_Of (Item);\n+\n+                     if Present (Item_Id) then\n+                        if Ekind_In (Item_Id, E_Abstract_State,\n+                                              E_In_Parameter,\n+                                              E_In_Out_Parameter,\n+                                              E_Out_Parameter,\n+                                              E_Variable)\n                         then\n                            --  Detect multiple uses of the same state, variable\n                            --  or formal parameter. If this is not the case,\n@@ -9148,6 +9166,15 @@ package body Sem_Prag is\n                               Append_Unique_Elmt (Item_Id, All_Inputs_Seen);\n                            end if;\n \n+                           --  When the item renames an entire object, replace\n+                           --  the item with a reference to the object.\n+\n+                           if Is_Renaming (Item) then\n+                              Rewrite (Item,\n+                                New_Reference_To (Item_Id, Sloc (Item)));\n+                              Analyze (Item);\n+                           end if;\n+\n                         --  All other input/output items are illegal\n \n                         else\n@@ -10809,7 +10836,7 @@ package body Sem_Prag is\n                  (Item        : Node_Id;\n                   Global_Mode : Name_Id)\n                is\n-                  Id : Entity_Id;\n+                  Item_Id : Entity_Id;\n \n                begin\n                   --  Detect one of the following cases\n@@ -10826,13 +10853,18 @@ package body Sem_Prag is\n \n                   Analyze (Item);\n \n-                  if Is_Entity_Name (Item) then\n-                     Id := Entity (Item);\n+                  --  Find the entity of the item. If this is a renaming, climb\n+                  --  the renaming chain to reach the root object. Renamings of\n+                  --  non-entire objects do not yield an entity (Empty).\n+\n+                  Item_Id := Entity_Of (Item);\n+\n+                  if Present (Item_Id) then\n \n                      --  A global item cannot reference a formal parameter. Do\n                      --  this check first to provide a better error diagnostic.\n \n-                     if Is_Formal (Id) then\n+                     if Is_Formal (Item_Id) then\n                         Error_Msg_N\n                           (\"global item cannot reference formal parameter\",\n                            Item);\n@@ -10841,14 +10873,23 @@ package body Sem_Prag is\n                      --  The only legal references are those to abstract states\n                      --  and variables.\n \n-                     elsif not Ekind_In (Entity (Item), E_Abstract_State,\n-                                                        E_Variable)\n+                     elsif not Ekind_In (Item_Id, E_Abstract_State,\n+                                                  E_Variable)\n                      then\n                         Error_Msg_N\n                           (\"global item must denote variable or state\", Item);\n                         return;\n                      end if;\n \n+                     --  When the item renames an entire object, replace the\n+                     --  item with a reference to the object.\n+\n+                     if Is_Renaming (Item) then\n+                        Rewrite (Item,\n+                          New_Reference_To (Item_Id, Sloc (Item)));\n+                        Analyze (Item);\n+                     end if;\n+\n                   --  Some form of illegal construct masquerading as a name\n \n                   else\n@@ -10860,7 +10901,7 @@ package body Sem_Prag is\n                   --  The same entity might be referenced through various way.\n                   --  Check the entity of the item rather than the item itself.\n \n-                  if Contains (Seen, Id) then\n+                  if Contains (Seen, Item_Id) then\n                      Error_Msg_N (\"duplicate global item\", Item);\n \n                   --  Add the entity of the current item to the list of\n@@ -10871,16 +10912,16 @@ package body Sem_Prag is\n                         Seen := New_Elmt_List;\n                      end if;\n \n-                     Append_Elmt (Id, Seen);\n+                     Append_Elmt (Item_Id, Seen);\n                   end if;\n \n-                  if Ekind (Id) = E_Abstract_State\n-                    and then Is_Volatile_State (Id)\n+                  if Ekind (Item_Id) = E_Abstract_State\n+                    and then Is_Volatile_State (Item_Id)\n                   then\n                      --  A global item of mode In_Out or Output cannot denote a\n                      --  volatile Input state.\n \n-                     if Is_Input_State (Id)\n+                     if Is_Input_State (Item_Id)\n                        and then (Global_Mode = Name_In_Out\n                                    or else\n                                  Global_Mode = Name_Output)\n@@ -10892,7 +10933,7 @@ package body Sem_Prag is\n                      --  A global item of mode In_Out or Input cannot reference\n                      --  a volatile Output state.\n \n-                     elsif Is_Output_State (Id)\n+                     elsif Is_Output_State (Item_Id)\n                        and then (Global_Mode = Name_In_Out\n                                    or else\n                                  Global_Mode = Name_Input)"}, {"sha": "bc8cf674fcfe3ad50d75f3860fe97a39f0fa100b", "filename": "gcc/ada/set_targ.adb", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fset_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fset_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.adb?ref=a96157e6ace9ca07460ab73739bd7b9c33a084ef", "patch": "@@ -470,8 +470,8 @@ package body Set_Targ is\n begin\n    --  First step: see if the -gnateT switch is present. As we have noted,\n    --  this has to be done very early, so can not depend on the normal circuit\n-   --  for reading switches and setting switches in opt. The following code\n-   --  will set Opt.Target_Dependent_Info_Read if an option starting -gnatet\n+   --  for reading switches and setting switches in Opt. The following code\n+   --  will set Opt.Target_Dependent_Info_Read if an option starting -gnateT\n    --  is present in the options string.\n \n    declare\n@@ -494,6 +494,12 @@ begin\n          declare\n             Argv_Ptr : constant Big_String_Ptr := save_argv (Arg);\n          begin\n+\n+            --  ??? Is there no problem accessing at indices 1 to 7 or 8\n+            --  without first checking if the length of the underlying string\n+            --  may be smaller? See back_end.adb for an example where function\n+            --  Len_Arg is used to retrieve this length.\n+\n             if Argv_Ptr (1 .. 7) = \"-gnateT\" then\n                Opt.Target_Dependent_Info_Read := True;\n             elsif Argv_Ptr (1 .. 8) = \"-gnatd.b\" then\n@@ -507,7 +513,7 @@ begin\n \n    if not Opt.Target_Dependent_Info_Read then\n \n-      --  Set values set by direct calls to the back end\n+      --  Set values by direct calls to the back end\n \n       Bits_BE                    := Get_Bits_BE;\n       Bits_Per_Unit              := Get_Bits_Per_Unit;\n@@ -536,13 +542,13 @@ begin\n \n       Register_Back_End_Types (Register_Float_Type'Access);\n \n-      --  Case of reading the target dependent values from target.atp\n+   --  Case of reading the target dependent values from target.atp\n \n-      --  This is bit more complex than might be expected, because it has to\n-      --  be done very early. All kinds of packages depend on these values,\n-      --  and we can't wait till the normal processing of reading command line\n-      --  switches etc to read the file. We do this at the System.OS_Lib level\n-      --  since it is too early to be using Osint directly.\n+   --  This is bit more complex than might be expected, because it has to be\n+   --  done very early. All kinds of packages depend on these values, and we\n+   --  can't wait till the normal processing of reading command line switches\n+   --  etc to read the file. We do this at the System.OS_Lib level since it is\n+   --  too early to be using Osint directly.\n \n    else\n       Read_File : declare"}, {"sha": "5e27cbd2e5829834fa156dca1b1e1dd30603fb30", "filename": "gcc/ada/ttypes.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fttypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96157e6ace9ca07460ab73739bd7b9c33a084ef/gcc%2Fada%2Fttypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fttypes.ads?ref=a96157e6ace9ca07460ab73739bd7b9c33a084ef", "patch": "@@ -234,12 +234,16 @@ package Ttypes is\n                                      Set_Targ.Double_Float_Alignment;\n    --  The default alignment of \"double\" floating-point types, i.e. floating\n    --  point types whose size is equal to 64 bits, or 0 if this alignment is\n-   --  not specifically capped.\n+   --  not lower than the largest power of 2 multiple of System.Storage_Unit\n+   --  that does not exceed either the object size of the type or the maximum\n+   --  allowed alignment.\n \n    Target_Double_Scalar_Alignment : constant Nat :=\n                                       Set_Targ.Double_Scalar_Alignment;\n    --  The default alignment of \"double\" or larger scalar types, i.e. scalar\n    --  types whose size is greater or equal to 64 bits, or 0 if this alignment\n-   --  is not specifically capped.\n+   --  is not lower than the largest power of 2 multiple of System.Storage_Unit\n+   --  that does not exceed either the object size of the type or the maximum\n+   --  allowed alignment.\n \n end Ttypes;"}]}