{"sha": "3475f10cbf58ff748298be438a4bf8cf98fec4ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ3NWYxMGNiZjU4ZmY3NDgyOThiZTQzOGE0YmY4Y2Y5OGZlYzRhYg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-14T17:19:06Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-19T14:30:19Z"}, "message": "Add QualifiedPathInExpression name resolution\n\nQualified paths such as: <Foo as Bar>::A give the ability to resolve to\ntrait-impls or trait-items directly. It is a type of projection.\n\nRemember trait impl blocks have the relevant canonical path so we can\nresolve with canonical paths and reuse the existing path in expression\ncode.", "tree": {"sha": "b8d15877eb5f6790d4a382acb66746c10fab2a04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8d15877eb5f6790d4a382acb66746c10fab2a04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3475f10cbf58ff748298be438a4bf8cf98fec4ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3475f10cbf58ff748298be438a4bf8cf98fec4ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3475f10cbf58ff748298be438a4bf8cf98fec4ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3475f10cbf58ff748298be438a4bf8cf98fec4ab/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71cf0d44d3fceb235c95d5acaf92b498f8cf923b"}], "stats": {"total": 164, "additions": 143, "deletions": 21}, "files": [{"sha": "74ea79528af637c72c25bd349e6b3ddd0f9da602", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3475f10cbf58ff748298be438a4bf8cf98fec4ab/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3475f10cbf58ff748298be438a4bf8cf98fec4ab/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=3475f10cbf58ff748298be438a4bf8cf98fec4ab", "patch": "@@ -771,25 +771,25 @@ struct QualifiedPathType\n {\n private:\n   std::unique_ptr<Type> type_to_invoke_on;\n-\n-  // bool has_as_clause;\n   TypePath trait_path;\n-\n   Location locus;\n+  NodeId node_id;\n \n public:\n   // Constructor\n   QualifiedPathType (std::unique_ptr<Type> invoke_on_type,\n \t\t     Location locus = Location (),\n \t\t     TypePath trait_path = TypePath::create_error ())\n     : type_to_invoke_on (std::move (invoke_on_type)),\n-      trait_path (std::move (trait_path)), locus (locus)\n+      trait_path (std::move (trait_path)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor uses custom deep copy for Type to preserve polymorphism\n   QualifiedPathType (QualifiedPathType const &other)\n     : trait_path (other.trait_path), locus (other.locus)\n   {\n+    node_id = other.node_id;\n     // guard to prevent null dereference\n     if (other.type_to_invoke_on != nullptr)\n       type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n@@ -801,6 +801,7 @@ struct QualifiedPathType\n   // overload assignment operator to use custom clone method\n   QualifiedPathType &operator= (QualifiedPathType const &other)\n   {\n+    node_id = other.node_id;\n     trait_path = other.trait_path;\n     locus = other.locus;\n \n@@ -846,6 +847,8 @@ struct QualifiedPathType\n     rust_assert (has_as_clause ());\n     return trait_path;\n   }\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n /* AST node representing a qualified path-in-expression pattern (path that\n@@ -855,6 +858,7 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n   std::vector<Attribute> outer_attrs;\n   QualifiedPathType path_type;\n   Location locus;\n+  NodeId _node_id;\n \n public:\n   std::string as_string () const override;\n@@ -864,7 +868,8 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n \t\t\t     std::vector<Attribute> outer_attrs, Location locus)\n     : PathPattern (std::move (path_segments)),\n       outer_attrs (std::move (outer_attrs)),\n-      path_type (std::move (qual_path_type)), locus (locus)\n+      path_type (std::move (qual_path_type)), locus (locus),\n+      _node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n@@ -907,6 +912,8 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n     outer_attrs = std::move (new_attrs);\n   }\n \n+  NodeId get_node_id () const override { return _node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "c5f88f9756d0f426f68be3b56334fe15a7c18b29", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3475f10cbf58ff748298be438a4bf8cf98fec4ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3475f10cbf58ff748298be438a4bf8cf98fec4ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=3475f10cbf58ff748298be438a4bf8cf98fec4ab", "patch": "@@ -39,10 +39,22 @@ class ResolvePath : public ResolverBase\n     resolver.resolve_path (expr);\n   }\n \n+  static void go (AST::QualifiedPathInExpression *expr, NodeId parent)\n+  {\n+    ResolvePath resolver (parent);\n+    resolver.resolve_path (expr);\n+  }\n+\n private:\n   ResolvePath (NodeId parent) : ResolverBase (parent) {}\n \n   void resolve_path (AST::PathInExpression *expr);\n+\n+  void resolve_path (AST::QualifiedPathInExpression *expr);\n+\n+  void resolve_segments (CanonicalPath prefix, size_t offs,\n+\t\t\t std::vector<AST::PathExprSegment> &segs,\n+\t\t\t NodeId expr_node_id, Location expr_locus);\n };\n \n class ResolveExpr : public ResolverBase\n@@ -75,6 +87,11 @@ class ResolveExpr : public ResolverBase\n     ResolvePath::go (&expr, parent);\n   }\n \n+  void visit (AST::QualifiedPathInExpression &expr) override\n+  {\n+    ResolvePath::go (&expr, parent);\n+  }\n+\n   void visit (AST::ReturnExpr &expr) override\n   {\n     if (expr.has_returned_expr ())"}, {"sha": "12392067be71e2f31c78b9ba93684dc4951c2041", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3475f10cbf58ff748298be438a4bf8cf98fec4ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3475f10cbf58ff748298be438a4bf8cf98fec4ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=3475f10cbf58ff748298be438a4bf8cf98fec4ab", "patch": "@@ -206,6 +206,19 @@ class ResolveTopLevel : public ResolverBase\n \t\t\t\t      impl_type_seg);\n     CanonicalPath impl_prefix = prefix.append (projection);\n \n+    resolver->get_name_scope ().insert (\n+      impl_prefix, impl_block.get_node_id (), impl_block.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (impl_block.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (impl_block.get_node_id (),\n+\t\t\t\t     Definition{impl_block.get_node_id (),\n+\t\t\t\t\t\timpl_block.get_node_id ()});\n+    resolver->insert_resolved_name (impl_block.get_node_id (),\n+\t\t\t\t    impl_block.get_node_id ());\n+\n     for (auto &impl_item : impl_block.get_impl_items ())\n       ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n   }"}, {"sha": "5b6bb2427ab5ece3cff41a88c7a69a40addd512c", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 101, "deletions": 16, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3475f10cbf58ff748298be438a4bf8cf98fec4ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3475f10cbf58ff748298be438a4bf8cf98fec4ab/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=3475f10cbf58ff748298be438a4bf8cf98fec4ab", "patch": "@@ -483,12 +483,13 @@ void\n ResolvePath::resolve_path (AST::PathInExpression *expr)\n {\n   // resolve root segment first then apply segments in turn\n-  AST::PathExprSegment &root_segment = expr->get_segments ().at (0);\n+  std::vector<AST::PathExprSegment> &segs = expr->get_segments ();\n+  AST::PathExprSegment &root_segment = segs.at (0);\n   AST::PathIdentSegment &root_ident_seg = root_segment.get_ident_segment ();\n \n   bool segment_is_type = false;\n   CanonicalPath root_seg_path\n-    = CanonicalPath::new_seg (expr->get_node_id (),\n+    = CanonicalPath::new_seg (root_segment.get_node_id (),\n \t\t\t      root_ident_seg.as_string ());\n \n   // name scope first\n@@ -515,7 +516,7 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n     {\n       rust_error_at (expr->get_locus (),\n \t\t     \"Cannot find path %<%s%> in this scope\",\n-\t\t     expr->as_string ().c_str ());\n+\t\t     root_segment.as_string ().c_str ());\n       return;\n     }\n \n@@ -531,7 +532,8 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n \t}\n     }\n \n-  if (expr->is_single_segment ())\n+  bool is_single_segment = segs.size () == 1;\n+  if (is_single_segment)\n     {\n       if (segment_is_type)\n \tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n@@ -544,11 +546,97 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n       return;\n     }\n \n+  resolve_segments (root_seg_path, 1, expr->get_segments (),\n+\t\t    expr->get_node_id (), expr->get_locus ());\n+}\n+\n+void\n+ResolvePath::resolve_path (AST::QualifiedPathInExpression *expr)\n+{\n+  AST::QualifiedPathType &root_segment = expr->get_qualified_path_type ();\n+\n+  bool canonicalize_type_with_generics = false;\n+  ResolveType::go (&root_segment.get_as_type_path (),\n+\t\t   root_segment.get_node_id (),\n+\t\t   canonicalize_type_with_generics);\n+\n+  ResolveType::go (root_segment.get_type ().get (), root_segment.get_node_id (),\n+\t\t   canonicalize_type_with_generics);\n+\n+  bool canonicalize_type_args = true;\n+  bool type_resolve_generic_args = true;\n+\n+  CanonicalPath impl_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (*root_segment.get_type ().get (),\n+\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   type_resolve_generic_args);\n+\n+  CanonicalPath trait_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (root_segment.get_as_type_path (),\n+\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   type_resolve_generic_args);\n+  CanonicalPath root_seg_path\n+    = TraitImplProjection::resolve (root_segment.get_node_id (), trait_type_seg,\n+\t\t\t\t    impl_type_seg);\n+  bool segment_is_type = false;\n+\n+  // name scope first\n+  if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n+    {\n+      segment_is_type = false;\n+      resolver->insert_resolved_name (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  // check the type scope\n+  else if (resolver->get_type_scope ().lookup (root_seg_path, &resolved_node))\n+    {\n+      segment_is_type = true;\n+      resolver->insert_resolved_type (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  else\n+    {\n+      rust_error_at (expr->get_locus (),\n+\t\t     \"Cannot find path %<%s%> in this scope\",\n+\t\t     root_segment.as_string ().c_str ());\n+      return;\n+    }\n+\n+  bool is_single_segment = expr->get_segments ().empty ();\n+  if (is_single_segment)\n+    {\n+      if (segment_is_type)\n+\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n+      else\n+\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n+\n+      resolver->insert_new_definition (expr->get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+      return;\n+    }\n+\n+  resolve_segments (root_seg_path, 0, expr->get_segments (),\n+\t\t    expr->get_node_id (), expr->get_locus ());\n+}\n+\n+void\n+ResolvePath::resolve_segments (CanonicalPath prefix, size_t offs,\n+\t\t\t       std::vector<AST::PathExprSegment> &segs,\n+\t\t\t       NodeId expr_node_id, Location expr_locus)\n+{\n   // we can attempt to resolve this path fully\n-  CanonicalPath path = root_seg_path;\n-  for (size_t i = 1; i < expr->get_segments ().size (); i++)\n+  CanonicalPath path = prefix;\n+  bool segment_is_type = false;\n+  for (size_t i = offs; i < segs.size (); i++)\n     {\n-      AST::PathExprSegment &seg = expr->get_segments ().at (i);\n+      AST::PathExprSegment &seg = segs.at (i);\n       auto s = ResolvePathSegmentToCanonicalPath::resolve (seg);\n       path = path.append (s);\n \n@@ -560,17 +648,15 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n \t{\n \t  resolver->insert_resolved_name (seg.get_node_id (), resolved_node);\n \t  resolver->insert_new_definition (seg.get_node_id (),\n-\t\t\t\t\t   Definition{expr->get_node_id (),\n-\t\t\t\t\t\t      parent});\n+\t\t\t\t\t   Definition{expr_node_id, parent});\n \t}\n       // check the type scope\n       else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n \t{\n \t  segment_is_type = true;\n \t  resolver->insert_resolved_type (seg.get_node_id (), resolved_node);\n \t  resolver->insert_new_definition (seg.get_node_id (),\n-\t\t\t\t\t   Definition{expr->get_node_id (),\n-\t\t\t\t\t\t      parent});\n+\t\t\t\t\t   Definition{expr_node_id, parent});\n \t}\n       else\n \t{\n@@ -621,13 +707,12 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n   if (resolved_node != UNKNOWN_NODEID)\n     {\n       if (segment_is_type)\n-\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n+\tresolver->insert_resolved_type (expr_node_id, resolved_node);\n       else\n-\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n+\tresolver->insert_resolved_name (expr_node_id, resolved_node);\n \n-      resolver->insert_new_definition (expr->get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n+      resolver->insert_new_definition (expr_node_id,\n+\t\t\t\t       Definition{expr_node_id, parent});\n     }\n }\n "}]}