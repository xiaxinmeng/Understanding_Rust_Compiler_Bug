{"sha": "c58f195fd2267f3f5459ff5b8b6c6e05fb981aa3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU4ZjE5NWZkMjI2N2YzZjU0NTlmZjViOGI2YzZlMDVmYjk4MWFhMw==", "commit": {"author": {"name": "Sven de Marothy", "email": "sven@physto.se", "date": "2005-04-22T05:48:06Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-22T05:48:06Z"}, "message": "LogManager.java: Reformatted.\n\n2005-04-22  Sven de Marothy  <sven@physto.se>\n\n\t* java/util/logging/LogManager.java: Reformatted.\n\t(readConfiguration): If a logger for a key is not found, create one.\n\nFrom-SVN: r98543", "tree": {"sha": "7c876060eef571ae52601eb89c2fdf0a7ef86516", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c876060eef571ae52601eb89c2fdf0a7ef86516"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c58f195fd2267f3f5459ff5b8b6c6e05fb981aa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c58f195fd2267f3f5459ff5b8b6c6e05fb981aa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c58f195fd2267f3f5459ff5b8b6c6e05fb981aa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c58f195fd2267f3f5459ff5b8b6c6e05fb981aa3/comments", "author": null, "committer": null, "parents": [{"sha": "6a15d30b22f278b793baeebec6f02facc5baa278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a15d30b22f278b793baeebec6f02facc5baa278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a15d30b22f278b793baeebec6f02facc5baa278"}], "stats": {"total": 455, "additions": 217, "deletions": 238}, "files": [{"sha": "b85cdf23eaa270a793b227b79f6f09692ab03304", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58f195fd2267f3f5459ff5b8b6c6e05fb981aa3/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58f195fd2267f3f5459ff5b8b6c6e05fb981aa3/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c58f195fd2267f3f5459ff5b8b6c6e05fb981aa3", "patch": "@@ -1,3 +1,8 @@\n+2005-04-22  Sven de Marothy  <sven@physto.se>\n+\n+\t* java/util/logging/LogManager.java: Reformatted.\n+\t(readConfiguration): If a logger for a key is not found, create one.\n+\n 2005-04-22  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n \n \t* java/rmi/Naming.java:"}, {"sha": "d771a7015039e486c7c94ec104c015235f721519", "filename": "libjava/java/util/logging/LogManager.java", "status": "modified", "additions": 212, "deletions": 238, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58f195fd2267f3f5459ff5b8b6c6e05fb981aa3/libjava%2Fjava%2Futil%2Flogging%2FLogManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58f195fd2267f3f5459ff5b8b6c6e05fb981aa3/libjava%2Fjava%2Futil%2Flogging%2FLogManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FLogManager.java?ref=c58f195fd2267f3f5459ff5b8b6c6e05fb981aa3", "patch": "@@ -103,17 +103,14 @@\n    * The singleton LogManager instance.\n    */\n   private static LogManager logManager;\n-  \n \n   /**\n    * The registered named loggers; maps the name of a Logger to\n    * a WeakReference to it.\n    */\n   private Map loggers;\n-\n   final Logger rootLogger;\n \n-\n   /**\n    * The properties for the logging framework which have been\n    * read in last.\n@@ -132,20 +129,19 @@\n    * behave differently from the reference implementation in\n    * this case.\n    */\n-  private final PropertyChangeSupport pcs\n-    = new PropertyChangeSupport(/* source bean */ LogManager.class);\n+  private final PropertyChangeSupport pcs = new PropertyChangeSupport( /* source bean */\n+  LogManager.class);\n \n   protected LogManager()\n   {\n     if (logManager != null)\n-      throw new IllegalStateException(\n-        \"there can be only one LogManager; use LogManager.getLogManager()\");\n+      throw new IllegalStateException(\"there can be only one LogManager; use LogManager.getLogManager()\");\n \n     logManager = this;\n     loggers = new java.util.HashMap();\n     rootLogger = new Logger(\"\", null);\n     addLogger(rootLogger);\n-    \n+\n     /* Make sure that Logger.global has the rootLogger as its parent.\n      *\n      * Logger.global is set during class initialization of Logger,\n@@ -166,7 +162,6 @@ protected LogManager()\n     Logger.getLogger(\"global\").setUseParentHandlers(true);\n   }\n \n-\n   /**\n    * Returns the globally shared LogManager instance.\n    */\n@@ -176,32 +171,30 @@ public static LogManager getLogManager()\n   }\n \n   static\n-  {\n-    makeLogManager();\n-    \n-    /* The Javadoc description of the class explains\n-     * what is going on here.\n-     */\n-    Object configurator = createInstance(\n-      System.getProperty(\"java.util.logging.config.class\"),\n-      /* must be instance of */ Object.class);\n-\n-    try\n-    {\n-      if (configurator == null)\n-        getLogManager().readConfiguration();\n-    }\n-    catch (IOException ex)\n     {\n-      /* FIXME: Is it ok to ignore exceptions here? */\n+      makeLogManager();\n+\n+      /* The Javadoc description of the class explains\n+       * what is going on here.\n+       */\n+      Object configurator = createInstance(System.getProperty(\"java.util.logging.config.class\"),\n+                                           /* must be instance of */ Object.class);\n+\n+      try\n+        {\n+\t  if (configurator == null)\n+\t    getLogManager().readConfiguration();\n+        }\n+      catch (IOException ex)\n+        {\n+\t  /* FIXME: Is it ok to ignore exceptions here? */\n+        }\n     }\n-  }\n-  \n \n   private static LogManager makeLogManager()\n   {\n-    String      managerClassName;\n-    LogManager  manager;\n+    String managerClassName;\n+    LogManager manager;\n \n     managerClassName = System.getProperty(\"java.util.logging.manager\");\n     manager = (LogManager) createInstance(managerClassName, LogManager.class);\n@@ -210,12 +203,11 @@ private static LogManager makeLogManager()\n \n     if (managerClassName != null)\n       System.err.println(\"WARNING: System property \\\"java.util.logging.manager\\\"\"\n-\t\t\t + \" should be the name of a subclass of java.util.logging.LogManager\");\n+                         + \" should be the name of a subclass of java.util.logging.LogManager\");\n \n     return new LogManager();\n   }\n \n-\n   /**\n    * Registers a listener which will be notified when the\n    * logging properties are re-read.\n@@ -228,7 +220,6 @@ public synchronized void addPropertyChangeListener(PropertyChangeListener listen\n     pcs.addPropertyChangeListener(listener);\n   }\n \n-\n   /**\n    * Unregisters a listener.\n    *\n@@ -242,7 +233,6 @@ public synchronized void removePropertyChangeListener(PropertyChangeListener lis\n       pcs.removePropertyChangeListener(listener);\n   }\n \n-\n   /**\n    * Adds a named logger.  If a logger with the same name has\n    * already been registered, the method returns <code>false</code>\n@@ -271,9 +261,8 @@ public synchronized boolean addLogger(Logger logger)\n      * that LogManager does its synchronization on the globally\n      * shared instance of LogManager.\n      */\n-\n     String name;\n-    WeakReference  ref;\n+    WeakReference ref;\n \n     /* This will throw a NullPointerException if logger is null,\n      * as required by the API specification.\n@@ -282,18 +271,18 @@ public synchronized boolean addLogger(Logger logger)\n \n     ref = (WeakReference) loggers.get(name);\n     if (ref != null)\n-    {\n-      if (ref.get() != null)\n-\treturn false;\n+      {\n+\tif (ref.get() != null)\n+\t  return false;\n \n-      /* There has been a logger under this name in the past,\n-       * but it has been garbage collected.\n-       */\n-      loggers.remove(ref);\n-    }\n+\t/* There has been a logger under this name in the past,\n+\t * but it has been garbage collected.\n+\t */\n+\tloggers.remove(ref);\n+      }\n \n     /* Adding a named logger requires a security permission. */\n-    if ((name != null) && !name.equals(\"\"))\n+    if ((name != null) && ! name.equals(\"\"))\n       checkAccess();\n \n     Logger parent = findAncestor(logger);\n@@ -308,27 +297,28 @@ public synchronized boolean addLogger(Logger logger)\n      * its parent to \"foo.bar\".\n      */\n     if (parent != rootLogger)\n-    {\n-      for (Iterator iter = loggers.keySet().iterator(); iter.hasNext();)\n       {\n-        Logger possChild = (Logger) ((WeakReference) loggers.get(iter.next())).get();\n-        if ((possChild == null) || (possChild == logger) || (possChild.getParent() != parent))\n-\t  continue;\n+\tfor (Iterator iter = loggers.keySet().iterator(); iter.hasNext();)\n+\t  {\n+\t    Logger possChild = (Logger) ((WeakReference) loggers.get(iter.next()))\n+\t                       .get();\n+\t    if ((possChild == null) || (possChild == logger)\n+\t        || (possChild.getParent() != parent))\n+\t      continue;\n \n-\tif (!possChild.getName().startsWith(name))\n-\t  continue;\n+\t    if (! possChild.getName().startsWith(name))\n+\t      continue;\n \n-\tif (possChild.getName().charAt(name.length()) != '.')\n-\t  continue;\n+\t    if (possChild.getName().charAt(name.length()) != '.')\n+\t      continue;\n \n-\tpossChild.setParent(logger);\n+\t    possChild.setParent(logger);\n+\t  }\n       }\n-    }\n \n     return true;\n   }\n \n-\n   /**\n    * Finds the closest ancestor for a logger among the currently\n    * registered ones.  For example, if the currently registered\n@@ -348,40 +338,39 @@ public synchronized boolean addLogger(Logger logger)\n   private synchronized Logger findAncestor(Logger child)\n   {\n     String childName = child.getName();\n-    int    childNameLength = childName.length();\n+    int childNameLength = childName.length();\n     Logger best = rootLogger;\n-    int    bestNameLength = 0;\n+    int bestNameLength = 0;\n \n-    Logger  cand;\n-    String  candName;\n-    int     candNameLength;\n+    Logger cand;\n+    String candName;\n+    int candNameLength;\n \n     if (child == rootLogger)\n       return null;\n \n     for (Iterator iter = loggers.keySet().iterator(); iter.hasNext();)\n-    {\n-      candName = (String) iter.next();\n-      candNameLength = candName.length();\n-\n-      if (candNameLength > bestNameLength\n-\t  && childNameLength > candNameLength\n-\t  && childName.startsWith(candName)\n-\t  && childName.charAt(candNameLength) == '.')\n       {\n-        cand = (Logger) ((WeakReference) loggers.get(candName)).get();\n-\tif ((cand == null) || (cand == child))\n-\t  continue;\n+\tcandName = (String) iter.next();\n+\tcandNameLength = candName.length();\n+\n+\tif (candNameLength > bestNameLength\n+\t    && childNameLength > candNameLength\n+\t    && childName.startsWith(candName)\n+\t    && childName.charAt(candNameLength) == '.')\n+\t  {\n+\t    cand = (Logger) ((WeakReference) loggers.get(candName)).get();\n+\t    if ((cand == null) || (cand == child))\n+\t      continue;\n \n-\tbestNameLength = candName.length();\n-\tbest = cand;\n+\t    bestNameLength = candName.length();\n+\t    best = cand;\n+\t  }\n       }\n-    }\n \n     return best;\n   }\n \n-\n   /**\n    * Returns a Logger given its name.\n    *\n@@ -395,7 +384,7 @@ private synchronized Logger findAncestor(Logger child)\n    */\n   public synchronized Logger getLogger(String name)\n   {\n-    WeakReference  ref;\n+    WeakReference ref;\n \n     /* Throw a NullPointerException if name is null. */\n     name.getClass();\n@@ -407,7 +396,6 @@ public synchronized Logger getLogger(String name)\n       return null;\n   }\n \n-\n   /**\n    * Returns an Enumeration of currently registered Logger names.\n    * Since other threads can register loggers at any time, the\n@@ -421,7 +409,6 @@ public synchronized Enumeration getLoggerNames()\n     return Collections.enumeration(loggers.keySet());\n   }\n \n-\n   /**\n    * Resets the logging configuration by removing all handlers for\n    * registered named loggers and setting their level to <code>null</code>.\n@@ -431,8 +418,7 @@ public synchronized Enumeration getLoggerNames()\n    *         the caller is not granted the permission to control\n    *         the logging infrastructure.\n    */\n-  public synchronized void reset()\n-    throws SecurityException\n+  public synchronized void reset() throws SecurityException\n   {\n     /* Throw a SecurityException if the caller does not have the\n      * permission to control the logging infrastructure.\n@@ -443,26 +429,25 @@ public synchronized void reset()\n \n     Iterator iter = loggers.values().iterator();\n     while (iter.hasNext())\n-    {\n-      WeakReference  ref;\n-      Logger         logger;\n-\n-      ref = (WeakReference) iter.next();\n-      if (ref != null)\n       {\n-\tlogger = (Logger) ref.get();\n+\tWeakReference ref;\n+\tLogger logger;\n \n-\tif (logger == null)\n-\t  iter.remove();\n-\telse if (logger != rootLogger)\n-\t  logger.setLevel(null);\n+\tref = (WeakReference) iter.next();\n+\tif (ref != null)\n+\t  {\n+\t    logger = (Logger) ref.get();\n+\n+\t    if (logger == null)\n+\t      iter.remove();\n+\t    else if (logger != rootLogger)\n+\t      logger.setLevel(null);\n+\t  }\n       }\n-    }\n \n     rootLogger.setLevel(Level.INFO);\n   }\n \n-\n   /**\n    * Configures the logging framework by reading a configuration file.\n    * The name and location of this file are specified by the system\n@@ -488,97 +473,99 @@ else if (logger != rootLogger)\n   public synchronized void readConfiguration()\n     throws IOException, SecurityException\n   {\n-    String       path;\n-    InputStream  inputStream;\n+    String path;\n+    InputStream inputStream;\n \n     path = System.getProperty(\"java.util.logging.config.file\");\n     if ((path == null) || (path.length() == 0))\n-    {\n-      String url = (System.getProperty(\"gnu.classpath.home.url\")\n-\t\t    + \"/logging.properties\");\n-      inputStream = new URL(url).openStream();\n-    }\n+      {\n+\tString url = (System.getProperty(\"gnu.classpath.home.url\")\n+\t             + \"/logging.properties\");\n+\tinputStream = new URL(url).openStream();\n+      }\n     else\n-    {\n       inputStream = new java.io.FileInputStream(path);\n-    }\n \n     try\n-    {\n-      readConfiguration(inputStream);\n-    }\n+      {\n+\treadConfiguration(inputStream);\n+      }\n     finally\n-    {\n-      /* Close the stream in order to save\n-       * resources such as file descriptors.\n-       */\n-      inputStream.close();\n-    }\n+      {\n+\t/* Close the stream in order to save\n+\t * resources such as file descriptors.\n+\t */\n+\tinputStream.close();\n+      }\n   }\n \n-\n   public synchronized void readConfiguration(InputStream inputStream)\n     throws IOException, SecurityException\n-  {\t\n-    Properties   newProperties;\n-    Enumeration  keys;\n+  {\n+    Properties newProperties;\n+    Enumeration keys;\n \n     checkAccess();\n     newProperties = new Properties();\n     newProperties.load(inputStream);\n-    this.properties = newProperties;    \n+    this.properties = newProperties;\n     keys = newProperties.propertyNames();\n \n     while (keys.hasMoreElements())\n-    {\n-      String key = ((String) keys.nextElement()).trim();\n-      String value = newProperties.getProperty(key);\n-  \n-      if (value == null)\n-\tcontinue;\n-\t\n-\t  value = value.trim();\n-\t\n-\t  if(\"handlers\".equals(key))\n-        {\n-          StringTokenizer tokenizer = new StringTokenizer(value);\n-          while(tokenizer.hasMoreTokens())\n-            {\n-              String handlerName = tokenizer.nextToken();\t\n-              try\n-                {\n-              \t  Class handlerClass = Class.forName(handlerName);\n-              \t  getLogger(\"\").addHandler((Handler)handlerClass.newInstance()); \n-                }\n-              catch (ClassCastException ex)\n-                {\n-                  System.err.println(\"[LogManager] class \" + handlerName + \" is not subclass of java.util.logging.Handler\");\n-                }\n-              catch (Exception ex)\n-                {\n-                  //System.out.println(\"[LogManager.readConfiguration]\"+ex);\n-                }\n-            }\n-        }\n-\t  \n-      if (key.endsWith(\".level\"))\n       {\n-\tString loggerName = key.substring(0, key.length() - 6);\n-\tLogger logger = getLogger(loggerName);\n-\tif (logger != null)\n-\t{\n-\t  try\n+\tString key = ((String) keys.nextElement()).trim();\n+\tString value = newProperties.getProperty(key);\n+\n+\tif (value == null)\n+\t  continue;\n+\n+\tvalue = value.trim();\n+\n+\tif (\"handlers\".equals(key))\n \t  {\n-\t    logger.setLevel(Level.parse(value));\n+\t    StringTokenizer tokenizer = new StringTokenizer(value);\n+\t    while (tokenizer.hasMoreTokens())\n+\t      {\n+\t\tString handlerName = tokenizer.nextToken();\n+\t\ttry\n+\t\t  {\n+\t\t    Class handlerClass = Class.forName(handlerName);\n+\t\t    getLogger(\"\").addHandler((Handler) handlerClass\n+\t\t                             .newInstance());\n+\t\t  }\n+\t\tcatch (ClassCastException ex)\n+\t\t  {\n+\t\t    System.err.println(\"[LogManager] class \" + handlerName\n+\t\t                       + \" is not subclass of java.util.logging.Handler\");\n+\t\t  }\n+\t\tcatch (Exception ex)\n+\t\t  {\n+\t\t    //System.out.println(\"[LogManager.readConfiguration]\"+ex);\n+\t\t  }\n+\t      }\n \t  }\n-\t  catch (Exception _)\n+\n+\tif (key.endsWith(\".level\"))\n \t  {\n-        //System.out.println(\"[LogManager.readConfiguration] \"+_);\n+\t    String loggerName = key.substring(0, key.length() - 6);\n+\t    Logger logger = getLogger(loggerName);\n+\n+\t    if (logger == null)\n+\t      {\n+\t\tlogger = Logger.getLogger(loggerName);\n+\t\taddLogger(logger);\n+\t      }\n+\t    try\n+\t      {\n+\t\tlogger.setLevel(Level.parse(value));\n+\t      }\n+\t    catch (Exception _)\n+\t      {\n+\t\t//System.out.println(\"[LogManager.readConfiguration] \"+_);\n+\t      }\n+\t    continue;\n \t  }\n-\t  continue;\n-\t}\n       }\n-    }\n \n     /* The API specification does not talk about the\n      * property name that is distributed with the\n@@ -589,7 +576,6 @@ public synchronized void readConfiguration(InputStream inputStream)\n     pcs.firePropertyChange(null, null, null);\n   }\n \n-  \n   /**\n    * Returns the value of a configuration property as a String.\n    */\n@@ -601,7 +587,6 @@ public synchronized String getProperty(String name)\n       return null;\n   }\n \n-\n   /**\n    * Returns the value of a configuration property as an integer.\n    * This function is a helper used by the Classpath implementation\n@@ -617,16 +602,15 @@ public synchronized String getProperty(String name)\n   static int getIntProperty(String name, int defaultValue)\n   {\n     try\n-    {\n-      return Integer.parseInt(getLogManager().getProperty(name));\n-    }\n+      {\n+\treturn Integer.parseInt(getLogManager().getProperty(name));\n+      }\n     catch (Exception ex)\n-    {\n-      return defaultValue;\n-    }\n+      {\n+\treturn defaultValue;\n+      }\n   }\n \n-\n   /**\n    * Returns the value of a configuration property as an integer,\n    * provided it is inside the acceptable range.\n@@ -646,15 +630,14 @@ static int getIntProperty(String name, int defaultValue)\n    *        or if it is greater than the maximum value.\n    */\n   static int getIntPropertyClamped(String name, int defaultValue,\n-\t\t\t\t   int minValue, int maxValue)\n+                                   int minValue, int maxValue)\n   {\n     int val = getIntProperty(name, defaultValue);\n     if ((val < minValue) || (val > maxValue))\n       val = defaultValue;\n     return val;\n   }\n \n-\n   /**\n    * Returns the value of a configuration property as a boolean.\n    * This function is a helper used by the Classpath implementation\n@@ -670,17 +653,15 @@ static int getIntPropertyClamped(String name, int defaultValue,\n   static boolean getBooleanProperty(String name, boolean defaultValue)\n   {\n     try\n-    {\n-      return (new Boolean(getLogManager().getProperty(name)))\n-        .booleanValue();\n-    }\n+      {\n+\treturn (new Boolean(getLogManager().getProperty(name))).booleanValue();\n+      }\n     catch (Exception ex)\n-    {\n-      return defaultValue;\n-    }\n+      {\n+\treturn defaultValue;\n+      }\n   }\n \n-\n   /**\n    * Returns the value of a configuration property as a Level.\n    * This function is a helper used by the Classpath implementation\n@@ -697,16 +678,15 @@ static boolean getBooleanProperty(String name, boolean defaultValue)\n   static Level getLevelProperty(String propertyName, Level defaultValue)\n   {\n     try\n-    {\n-      return Level.parse(getLogManager().getProperty(propertyName));\n-    }\n+      {\n+\treturn Level.parse(getLogManager().getProperty(propertyName));\n+      }\n     catch (Exception ex)\n-    {\n-      return defaultValue;\n-    }\n+      {\n+\treturn defaultValue;\n+      }\n   }\n \n-\n   /**\n    * Returns the value of a configuration property as a Class.\n    * This function is a helper used by the Classpath implementation\n@@ -724,64 +704,60 @@ static final Class getClassProperty(String propertyName, Class defaultValue)\n     Class usingClass = null;\n \n     try\n-    {\n-      String propertyValue = logManager.getProperty(propertyName);\n-      if (propertyValue != null)\n-        usingClass = Class.forName(propertyValue);\n-      if (usingClass != null)\n-        return usingClass;\n-    }\n+      {\n+\tString propertyValue = logManager.getProperty(propertyName);\n+\tif (propertyValue != null)\n+\t  usingClass = Class.forName(propertyValue);\n+\tif (usingClass != null)\n+\t  return usingClass;\n+      }\n     catch (Exception _)\n-    {\n-    }\n+      {\n+      }\n \n     return defaultValue;\n   }\n \n-\n-  static final Object getInstanceProperty(String propertyName,\n-\t\t\t\t\t  Class ofClass,\n-\t\t\t\t\t  Class defaultClass)\n+  static final Object getInstanceProperty(String propertyName, Class ofClass,\n+                                          Class defaultClass)\n   {\n     Class klass = getClassProperty(propertyName, defaultClass);\n     if (klass == null)\n       return null;\n \n     try\n-    {\n-      Object obj = klass.newInstance();\n-      if (ofClass.isInstance(obj))\n-\treturn obj;\n-    }\n+      {\n+\tObject obj = klass.newInstance();\n+\tif (ofClass.isInstance(obj))\n+\t  return obj;\n+      }\n     catch (Exception _)\n-    {\n-    }\n+      {\n+      }\n \n     if (defaultClass == null)\n       return null;\n \n     try\n-    {\n-      return defaultClass.newInstance();\n-    }\n+      {\n+\treturn defaultClass.newInstance();\n+      }\n     catch (java.lang.InstantiationException ex)\n-    {\n-      throw new RuntimeException(ex.getMessage());\n-    }\n+      {\n+\tthrow new RuntimeException(ex.getMessage());\n+      }\n     catch (java.lang.IllegalAccessException ex)\n-    {\n-      throw new RuntimeException(ex.getMessage());\n-    }\n+      {\n+\tthrow new RuntimeException(ex.getMessage());\n+      }\n   }\n \n-\n   /**\n    * An instance of <code>LoggingPermission(\"control\")</code>\n    * that is shared between calls to <code>checkAccess()</code>.\n    */\n-  private static final LoggingPermission controlPermission\n-    = new LoggingPermission(\"control\", null);\n-\n+  private static final LoggingPermission controlPermission = new LoggingPermission(\"control\",\n+                                                                                   null);\n \n   /**\n    * Checks whether the current security context allows changing\n@@ -793,21 +769,19 @@ static final Object getInstanceProperty(String propertyName,\n    *         the caller is not granted the permission to control\n    *         the logging infrastructure.\n    */\n-  public void checkAccess()\n-    throws SecurityException\n+  public void checkAccess() throws SecurityException\n   {\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       sm.checkPermission(controlPermission);\n   }\n \n-\n-  /** \n+  /**\n    * Creates a new instance of a class specified by name.\n    *\n    * @param className the name of the class of which a new instance\n    *        should be created.\n-   *       \n+   *\n    * @param ofClass the class to which the new instance should\n    *        be either an instance or an instance of a subclass.\n    *        FIXME: This description is just terrible.\n@@ -820,26 +794,26 @@ public void checkAccess()\n    */\n   static final Object createInstance(String className, Class ofClass)\n   {\n-    Class   klass;\n+    Class klass;\n \n     if ((className == null) || (className.length() == 0))\n       return null;\n \n     try\n-    {\n-      klass = Class.forName(className);\n-      if (!ofClass.isAssignableFrom(klass))\n-\treturn null;\n+      {\n+\tklass = Class.forName(className);\n+\tif (! ofClass.isAssignableFrom(klass))\n+\t  return null;\n \n-      return klass.newInstance();\n-    }\n+\treturn klass.newInstance();\n+      }\n     catch (Exception _)\n-    {\n-      return null;\n-    }\n+      {\n+\treturn null;\n+      }\n     catch (java.lang.LinkageError _)\n-    {\n-      return null;\n-    }\n+      {\n+\treturn null;\n+      }\n   }\n }"}]}