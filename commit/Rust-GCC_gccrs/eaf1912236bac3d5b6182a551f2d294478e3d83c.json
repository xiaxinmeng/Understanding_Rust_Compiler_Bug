{"sha": "eaf1912236bac3d5b6182a551f2d294478e3d83c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFmMTkxMjIzNmJhYzNkNWI2MTgyYTU1MWYyZDI5NDQ3OGUzZDgzYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-10-23T18:50:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-10-23T18:50:40Z"}, "message": "builtins.c (expand_builtin_memmove): Remove ORIG_EXP argument; don't do conversion from memmove to memcpy here.\n\n\t* builtins.c (expand_builtin_memmove): Remove ORIG_EXP argument;\n\tdon't do conversion from memmove to memcpy here.\n\t(expand_builtin_bcopy, expand_builtin): Update call of\n\texpand_builtin_memmove.\n\t(fold_builtin_memory_op): Do folding of memmove to memcpy here.\n\n\t* gcc.dg/memmove-1.c: New test.\n\nFrom-SVN: r117979", "tree": {"sha": "d8fd80b47f68bac6cd4e41ae69cc7c05702cc8c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8fd80b47f68bac6cd4e41ae69cc7c05702cc8c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaf1912236bac3d5b6182a551f2d294478e3d83c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf1912236bac3d5b6182a551f2d294478e3d83c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaf1912236bac3d5b6182a551f2d294478e3d83c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf1912236bac3d5b6182a551f2d294478e3d83c/comments", "author": null, "committer": null, "parents": [{"sha": "353293e7f758be575d88aa78edb9ccddb7816cba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/353293e7f758be575d88aa78edb9ccddb7816cba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/353293e7f758be575d88aa78edb9ccddb7816cba"}], "stats": {"total": 98, "additions": 55, "deletions": 43}, "files": [{"sha": "c304f18a473a10883736ff1c325de161f1110050", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf1912236bac3d5b6182a551f2d294478e3d83c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf1912236bac3d5b6182a551f2d294478e3d83c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eaf1912236bac3d5b6182a551f2d294478e3d83c", "patch": "@@ -1,3 +1,11 @@\n+2006-10-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* builtins.c (expand_builtin_memmove): Remove ORIG_EXP argument;\n+\tdon't do conversion from memmove to memcpy here.\n+\t(expand_builtin_bcopy, expand_builtin): Update call of\n+\texpand_builtin_memmove.\n+\t(fold_builtin_memory_op): Do folding of memmove to memcpy here.\n+\n 2006-10-23  Paul Brook  <paul@codesourcery.com>\n \n \t* stor-layout.c (start_record_layout): maximum_field_alignment"}, {"sha": "b2a8647b9fa29c0dcdf22d978edb5bf8ab432ad7", "filename": "gcc/builtins.c", "status": "modified", "additions": 25, "deletions": 43, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf1912236bac3d5b6182a551f2d294478e3d83c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf1912236bac3d5b6182a551f2d294478e3d83c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=eaf1912236bac3d5b6182a551f2d294478e3d83c", "patch": "@@ -111,7 +111,7 @@ static rtx expand_builtin_strspn (tree, rtx, enum machine_mode);\n static rtx expand_builtin_strcspn (tree, rtx, enum machine_mode);\n static rtx expand_builtin_memcpy (tree, rtx, enum machine_mode);\n static rtx expand_builtin_mempcpy (tree, tree, rtx, enum machine_mode, int);\n-static rtx expand_builtin_memmove (tree, tree, rtx, enum machine_mode, tree);\n+static rtx expand_builtin_memmove (tree, tree, rtx, enum machine_mode);\n static rtx expand_builtin_bcopy (tree);\n static rtx expand_builtin_strcpy (tree, tree, rtx, enum machine_mode);\n static rtx expand_builtin_stpcpy (tree, rtx, enum machine_mode);\n@@ -3089,20 +3089,13 @@ expand_builtin_mempcpy (tree arglist, tree type, rtx target, enum machine_mode m\n \n static rtx\n expand_builtin_memmove (tree arglist, tree type, rtx target,\n-\t\t\tenum machine_mode mode, tree orig_exp)\n+\t\t\tenum machine_mode mode)\n {\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n   else\n     {\n-      tree dest = TREE_VALUE (arglist);\n-      tree src = TREE_VALUE (TREE_CHAIN (arglist));\n-      tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-\n-      unsigned int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n-      unsigned int dest_align\n-\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n       tree result = fold_builtin_memory_op (arglist, type, false, /*endp=*/3);\n \n       if (result)\n@@ -3116,38 +3109,6 @@ expand_builtin_memmove (tree arglist, tree type, rtx target,\n \t  return expand_expr (result, target, mode, EXPAND_NORMAL);\n \t}\n \n-      /* If DEST is not a pointer type, call the normal function.  */\n-      if (dest_align == 0)\n-\treturn 0;\n-\n-      /* If either SRC is not a pointer type, don't do this\n-\t operation in-line.  */\n-      if (src_align == 0)\n-\treturn 0;\n-\n-      /* If src is categorized for a readonly section we can use\n-\t normal memcpy.  */\n-      if (readonly_data_expr (src))\n-\t{\n-\t  tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-\t  if (!fn)\n-\t    return 0;\n-\t  fn = build_function_call_expr (fn, arglist);\n-\t  if (TREE_CODE (fn) == CALL_EXPR)\n-\t    CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (orig_exp);\n-\t  return expand_expr (fn, target, mode, EXPAND_NORMAL);\n-\t}\n-\n-      /* If length is 1 and we can expand memcpy call inline,\n-\t it is ok to use memcpy as well.  */\n-      if (integer_onep (len))\n-\t{\n-\t  rtx ret = expand_builtin_mempcpy (arglist, type, target, mode,\n-\t\t\t\t\t    /*endp=*/0);\n-\t  if (ret)\n-\t    return ret;\n-\t}\n-\n       /* Otherwise, call the normal function.  */\n       return 0;\n    }\n@@ -3180,7 +3141,7 @@ expand_builtin_bcopy (tree exp)\n   newarglist = tree_cons (NULL_TREE, src, newarglist);\n   newarglist = tree_cons (NULL_TREE, dest, newarglist);\n \n-  return expand_builtin_memmove (newarglist, type, const0_rtx, VOIDmode, exp);\n+  return expand_builtin_memmove (newarglist, type, const0_rtx, VOIDmode);\n }\n \n #ifndef HAVE_movstr\n@@ -6073,7 +6034,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \n     case BUILT_IN_MEMMOVE:\n       target = expand_builtin_memmove (arglist, TREE_TYPE (exp), target,\n-\t\t\t\t       mode, exp);\n+\t\t\t\t       mode);\n       if (target)\n \treturn target;\n       break;\n@@ -8146,6 +8107,27 @@ fold_builtin_memory_op (tree arglist, tree type, bool ignore, int endp)\n     expr = len;\n   else\n     {\n+      if (endp == 3)\n+\t{\n+          unsigned int src_align\n+\t     = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n+          unsigned int dest_align\n+\t     = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+\t  /* Both DEST and SRC must be pointer types. \n+\t     ??? This is what old code did.  Is the testing for pointer types\n+\t     really mandatory?\n+\n+\t     If either SRC is readonly or length is 1, we can use memcpy.  */\n+\t  if (dest_align && src_align\n+\t      && (readonly_data_expr (src)\n+\t\t  || integer_onep (len)))\n+\t    {\n+\t      tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+\t      if (!fn)\n+\t\treturn 0;\n+\t      return build_function_call_expr (fn, arglist);\n+\t    }\n+\t}\n       if (! host_integerp (len, 1))\n \treturn 0;\n "}, {"sha": "ebbae936261337fe4a40c2a71c326caf216e9f43", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf1912236bac3d5b6182a551f2d294478e3d83c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf1912236bac3d5b6182a551f2d294478e3d83c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eaf1912236bac3d5b6182a551f2d294478e3d83c", "patch": "@@ -1,3 +1,7 @@\n+2006-10-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/memmove-1.c: New test.\n+\n 2006-10-23  Paul Brook  <paul@codesourcery.com>\n \n \t* gcc.dg/pragma-pack-5.c: New test."}, {"sha": "46918ee0f3fe43d98248e152e8ab3e6b0f8523ab", "filename": "gcc/testsuite/gcc.dg/memmove-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf1912236bac3d5b6182a551f2d294478e3d83c/gcc%2Ftestsuite%2Fgcc.dg%2Fmemmove-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf1912236bac3d5b6182a551f2d294478e3d83c/gcc%2Ftestsuite%2Fgcc.dg%2Fmemmove-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemmove-1.c?ref=eaf1912236bac3d5b6182a551f2d294478e3d83c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \"memmove\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+static const char a[100]={1,2,3,4};\n+char b[1000];\n+int i,i1;\n+static inline void\n+__attribute__ ((always_inline))\n+domem (void *dest, const void *src, int len)\n+{\n+\t__builtin_memmove (dest, src, len);\n+}\n+t()\n+{\n+\tdomem (b,a,100);\n+\tdomem (b+i1,(const void *)b,1);\n+}"}]}