{"sha": "5366b18679f7ead0a02c29759d4bb455f52114ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM2NmIxODY3OWY3ZWFkMGEwMmMyOTc1OWQ0YmI0NTVmNTIxMTRjZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2011-11-07T18:14:46Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2011-11-07T18:14:46Z"}, "message": "libgcov.c (struct gcov_fn_buffer): New struct.\n\n\tlibgcc/\n\t* libgcov.c (struct gcov_fn_buffer): New struct.\n\t(buffer_fn_data): New helper.\n\t(gcov_exit): Rework for new gcov data structures.\n\n\tgcc/\n\t* gcov.c (object_summary): Replace with ...\n\t(object_runs): ... this.\n\t(process_file): Remove functions with no data.\n\t(generate_results): Ignore files with no lines.\n\t(release_function): New helper, broken out of ...\n\t(release_structures): ... here.  Use it.\n\t(read_count_file): Adjust for new data file format.\n\t(output_lines): Use object_runs.\n\t* gcov-io.h (GCOV_TAG_OBJECT_SUMMARY): Obsolete.\n\t(struct gcov_ctr_info): Move definition.\n\t(struct gcov_fn_info): Add key field, use gcov_ctr_info for\n\ttrailing array.\n\t(struct gcov_info): Add merge function array, remove mask and\n\tcounts.  Trailing array is array of pointers to function info.\n\t* coverage.c (struct function_list): Replace counter numbers with\n\tcounter arrays.  Add fndecl field.  GTYify.\n\t(counts_entry): Remove chain workspace.\n\t(functions_head): GTYify.\n\t(prg_n_ctrs): Remove.\n\t(fn_v_ctrs): New.\n\t(tree_ctr_tables): Remove.\n\t(read_counts_file): Cope with blank entries and expect program\n\tsummaries before functions.  Don't warn on missing entries.\n\t(coverage_counter_alloc): Allocate individual function arrays.\n\t(tree_coverage_counter_ref, tree_coverage_counter_addr): Adjust\n\tfor individual function arrays.\n\t(coverage_end_function): GTYify function list object. Finalize\n\tfunction's counter arrays.\n\t(build_var): New.  Create a counter-related variable with\n\tappropriate linkage.\n\t(build_fn_info_type): Adjust for new runtime structure.\n\t(build_fn_info_value): Rename to ...\n\t(build_fn_info): ... here.  Build new format data.\n\t(build_ctr_info_type, build_ctr_info_value): Remove.\n\t(build_info_type): New. Build new format data structure.\n\t(build_info): Adjust for new format data.\n\t(create_coverage): Likewise.\n\t* gcov-dump.c (tag_function): Recognize placeholders.\n\n\tgcc/testsuite/\n\t* gcc.dg/profile-dir-1.c: Adjust final scan.\n\t* gcc.dg/profile-dir-2.c: Adjust final scan.\n\t* gcc.dg/profile-dir-3.c: Adjust final scan.\n\t* gcc.misc-tests/gcov.exp: Adjust regexp.\n\t* gcc.misc-tests/gcov-12.c: New.\n\t* gcc.misc-tests/gcov-13.c: New.\n\t* gcc.misc-tests/gcovpart-13b.c: New.\n\t* gcc.misc-tests/gcov-14.c: New.\n\nFrom-SVN: r181105", "tree": {"sha": "66b4b76e062cf2c04e721c2d80f9445608ebb3a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66b4b76e062cf2c04e721c2d80f9445608ebb3a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5366b18679f7ead0a02c29759d4bb455f52114ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5366b18679f7ead0a02c29759d4bb455f52114ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5366b18679f7ead0a02c29759d4bb455f52114ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5366b18679f7ead0a02c29759d4bb455f52114ce/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "74155a6f37c3cabdf3875a560876c4b9fa3288f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74155a6f37c3cabdf3875a560876c4b9fa3288f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74155a6f37c3cabdf3875a560876c4b9fa3288f9"}], "stats": {"total": 1447, "additions": 850, "deletions": 597}, "files": [{"sha": "d0f96d9a67243a808f7cf73f2d72efdfd0d6d2f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -1,3 +1,44 @@\n+2011-11-07  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* gcov.c (object_summary): Replace with ...\n+\t(object_runs): ... this.\n+\t(process_file): Remove functions with no data.\n+\t(generate_results): Ignore files with no lines.\n+\t(release_function): New helper, broken out of ...\n+\t(release_structures): ... here.  Use it.\n+\t(read_count_file): Adjust for new data file format.\n+\t(output_lines): Use object_runs.\n+\t* gcov-io.h (GCOV_TAG_OBJECT_SUMMARY): Obsolete.\n+\t(struct gcov_ctr_info): Move definition.\n+\t(struct gcov_fn_info): Add key field, use gcov_ctr_info for\n+\ttrailing array.\n+\t(struct gcov_info): Add merge function array, remove mask and\n+\tcounts.  Trailing array is array of pointers to function info.\n+\t* coverage.c (struct function_list): Replace counter numbers with\n+\tcounter arrays.  Add fndecl field.  GTYify.\n+\t(counts_entry): Remove chain workspace.\n+\t(functions_head): GTYify.\n+\t(prg_n_ctrs): Remove.\n+\t(fn_v_ctrs): New.\n+\t(tree_ctr_tables): Remove.\n+\t(read_counts_file): Cope with blank entries and expect program\n+\tsummaries before functions.  Don't warn on missing entries.\n+\t(coverage_counter_alloc): Allocate individual function arrays.\n+\t(tree_coverage_counter_ref, tree_coverage_counter_addr): Adjust\n+\tfor individual function arrays.\n+\t(coverage_end_function): GTYify function list object. Finalize\n+\tfunction's counter arrays.\n+\t(build_var): New.  Create a counter-related variable with\n+\tappropriate linkage.\n+\t(build_fn_info_type): Adjust for new runtime structure.\n+\t(build_fn_info_value): Rename to ...\n+\t(build_fn_info): ... here.  Build new format data.\n+\t(build_ctr_info_type, build_ctr_info_value): Remove.\n+\t(build_info_type): New. Build new format data structure.\n+\t(build_info): Adjust for new format data.\n+\t(create_coverage): Likewise.\n+\t* gcov-dump.c (tag_function): Recognize placeholders.\n+\n 2011-11-07  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/constraints.md (Cm2): New constraint for int -2."}, {"sha": "520652b1e71112c328cd913a77907773b6411456", "filename": "gcc/coverage.c", "status": "modified", "additions": 342, "deletions": 307, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -1,6 +1,6 @@\n /* Read and write coverage files, and associated functionality.\n    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n+   2000, 2001, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;\n    based on some ideas from Dain Samples of UC Berkeley.\n@@ -54,13 +54,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcov-io.h\"\n #include \"gcov-io.c\"\n \n-struct function_list\n+struct GTY((chain_next (\"%h.next\"))) function_list\n {\n   struct function_list *next;\t /* next function */\n   unsigned ident;\t\t /* function ident */\n   unsigned lineno_checksum;\t /* function lineno checksum */\n   unsigned cfg_checksum;\t /* function cfg checksum */\n-  unsigned n_ctrs[GCOV_COUNTERS];/* number of counters.  */\n+  tree fn_decl;\t\t\t /* the function decl */\n+  tree ctr_vars[GCOV_COUNTERS];\t /* counter variables.  */\n };\n \n /* Counts information for a function.  */\n@@ -75,22 +76,18 @@ typedef struct counts_entry\n   unsigned cfg_checksum;\n   gcov_type *counts;\n   struct gcov_ctr_summary summary;\n-\n-  /* Workspace */\n-  struct counts_entry *chain;\n-\n } counts_entry_t;\n \n-static struct function_list *functions_head = 0;\n+static GTY(()) struct function_list *functions_head = 0;\n static struct function_list **functions_tail = &functions_head;\n static unsigned no_coverage = 0;\n \n /* Cumulative counter information for whole program.  */\n static unsigned prg_ctr_mask; /* Mask of counter types generated.  */\n-static unsigned prg_n_ctrs[GCOV_COUNTERS]; /* Total counters allocated.  */\n \n /* Counter information for current function.  */\n static unsigned fn_ctr_mask; /* Mask of counters used.  */\n+static GTY(()) tree fn_v_ctrs[GCOV_COUNTERS];   /* counter variables.  */\n static unsigned fn_n_ctrs[GCOV_COUNTERS]; /* Counters allocated.  */\n static unsigned fn_b_ctrs[GCOV_COUNTERS]; /* Allocation base.  */\n \n@@ -105,9 +102,6 @@ static char *da_file_name;\n /* Hash table of count data.  */\n static htab_t counts_hash = NULL;\n \n-/* Trees representing the counter table arrays.  */\n-static GTY(()) tree tree_ctr_tables[GCOV_COUNTERS];\n-\n /* The names of merge functions for counters.  */\n static const char *const ctr_merge_functions[GCOV_COUNTERS] = GCOV_MERGE_FUNCTIONS;\n static const char *const ctr_names[GCOV_COUNTERS] = GCOV_COUNTER_NAMES;\n@@ -117,11 +111,11 @@ static hashval_t htab_counts_entry_hash (const void *);\n static int htab_counts_entry_eq (const void *, const void *);\n static void htab_counts_entry_del (void *);\n static void read_counts_file (void);\n-static tree build_fn_info_type (unsigned);\n-static tree build_fn_info_value (const struct function_list *, tree);\n-static tree build_ctr_info_type (void);\n-static tree build_ctr_info_value (unsigned, tree);\n-static tree build_gcov_info (void);\n+static tree build_var (tree, tree, int);\n+static void build_fn_info_type (tree, unsigned, tree);\n+static tree build_fn_info (const struct function_list *, tree, tree);\n+static void build_info_type (tree, unsigned, tree);\n+static tree build_info (tree, tree, tree, unsigned);\n static void create_coverage (void);\n \f\n /* Return the type node for gcov_type.  */\n@@ -172,8 +166,8 @@ static void\n read_counts_file (void)\n {\n   gcov_unsigned_t fn_ident = 0;\n-  counts_entry_t *summaried = NULL;\n-  unsigned seen_summary = 0;\n+  struct gcov_summary summary;\n+  unsigned new_summary = 1;\n   gcov_unsigned_t tag;\n   int is_error = 0;\n   unsigned lineno_checksum = 0;\n@@ -216,42 +210,34 @@ read_counts_file (void)\n       offset = gcov_position ();\n       if (tag == GCOV_TAG_FUNCTION)\n \t{\n-\t  fn_ident = gcov_read_unsigned ();\n-\t  lineno_checksum = gcov_read_unsigned ();\n-\t  cfg_checksum = gcov_read_unsigned ();\n-\t  if (seen_summary)\n+\t  if (length)\n \t    {\n-\t      /* We have already seen a summary, this means that this\n-\t\t new function begins a new set of program runs. We\n-\t\t must unlink the summaried chain.  */\n-\t      counts_entry_t *entry, *chain;\n-\n-\t      for (entry = summaried; entry; entry = chain)\n-\t\t{\n-\t\t  chain = entry->chain;\n-\t\t  entry->chain = NULL;\n-\t\t}\n-\t      summaried = NULL;\n-\t      seen_summary = 0;\n+\t      fn_ident = gcov_read_unsigned ();\n+\t      lineno_checksum = gcov_read_unsigned ();\n+\t      cfg_checksum = gcov_read_unsigned ();\n \t    }\n+\t  else\n+\t    fn_ident = lineno_checksum = cfg_checksum = 0;\n+\t  new_summary = 1;\n \t}\n       else if (tag == GCOV_TAG_PROGRAM_SUMMARY)\n \t{\n-\t  counts_entry_t *entry;\n-\t  struct gcov_summary summary;\n+\t  struct gcov_summary sum;\n+\t  unsigned ix;\n \n-\t  gcov_read_summary (&summary);\n-\t  seen_summary = 1;\n-\t  for (entry = summaried; entry; entry = entry->chain)\n-\t    {\n-\t      struct gcov_ctr_summary *csum = &summary.ctrs[entry->ctr];\n+\t  if (new_summary)\n+\t    memset (&summary, 0, sizeof (summary));\n \n-\t      entry->summary.runs += csum->runs;\n-\t      entry->summary.sum_all += csum->sum_all;\n-\t      if (entry->summary.run_max < csum->run_max)\n-\t\tentry->summary.run_max = csum->run_max;\n-\t      entry->summary.sum_max += csum->sum_max;\n+\t  gcov_read_summary (&sum);\n+\t  for (ix = 0; ix != GCOV_COUNTERS_SUMMABLE; ix++)\n+\t    {\n+\t      summary.ctrs[ix].runs += sum.ctrs[ix].runs;\n+\t      summary.ctrs[ix].sum_all += sum.ctrs[ix].sum_all;\n+\t      if (summary.ctrs[ix].run_max < sum.ctrs[ix].run_max)\n+\t\tsummary.ctrs[ix].run_max = sum.ctrs[ix].run_max;\n+\t      summary.ctrs[ix].sum_max += sum.ctrs[ix].sum_max;\n \t    }\n+\t  new_summary = 0;\n \t}\n       else if (GCOV_TAG_IS_COUNTER (tag) && fn_ident)\n \t{\n@@ -272,6 +258,7 @@ read_counts_file (void)\n \t      entry->ctr = elt.ctr;\n \t      entry->lineno_checksum = lineno_checksum;\n \t      entry->cfg_checksum = cfg_checksum;\n+\t      entry->summary = summary.ctrs[elt.ctr];\n \t      entry->summary.num = n_counts;\n \t      entry->counts = XCNEWVEC (gcov_type, n_counts);\n \t    }\n@@ -298,15 +285,13 @@ read_counts_file (void)\n \t\t     ctr_names[elt.ctr], fn_ident);\n \t      goto skip_merge;\n \t    }\n-\n-\t  if (elt.ctr < GCOV_COUNTERS_SUMMABLE\n-\t      /* This should always be true for a just allocated entry,\n-\t\t and always false for an existing one. Check this way, in\n-\t\t case the gcov file is corrupt.  */\n-\t      && (!entry->chain || summaried != entry))\n+\t  else\n \t    {\n-\t      entry->chain = summaried;\n-\t      summaried = entry;\n+\t      entry->summary.runs += summary.ctrs[elt.ctr].runs;\n+\t      entry->summary.sum_all += summary.ctrs[elt.ctr].sum_all;\n+\t      if (entry->summary.run_max < summary.ctrs[elt.ctr].run_max)\n+\t\tentry->summary.run_max = summary.ctrs[elt.ctr].run_max;\n+\t      entry->summary.sum_max += summary.ctrs[elt.ctr].sum_max;\n \t    }\n \t  for (ix = 0; ix != n_counts; ix++)\n \t    entry->counts[ix] += gcov_read_counter ();\n@@ -350,13 +335,12 @@ get_coverage_counts (unsigned counter, unsigned expected,\n   elt.ident = current_function_funcdef_no + 1;\n   elt.ctr = counter;\n   entry = (counts_entry_t *) htab_find (counts_hash, &elt);\n-  if (!entry)\n-    {\n-      warning (0, \"no coverage for function %qE found\",\n-\t       DECL_ASSEMBLER_NAME (current_function_decl));\n-      return NULL;\n-    }\n-\n+  if (!entry || !entry->summary.num)\n+    /* The function was not emitted, or is weak and not chosen in the\n+       final executable.  Silently fail, because there's nothing we\n+       can do about it.  */\n+    return NULL;\n+  \n   if (entry->cfg_checksum != cfg_checksum\n       || entry->summary.num != expected)\n     {\n@@ -366,11 +350,11 @@ get_coverage_counts (unsigned counter, unsigned expected,\n \n       warning_printed =\n \twarning_at (input_location, OPT_Wcoverage_mismatch,\n-\t\t    \"The control flow of function %qE does not match \"\n+\t\t    \"the control flow of function %qE does not match \"\n \t\t    \"its profile data (counter %qs)\", id, ctr_names[counter]);\n       if (warning_printed)\n \t{\n-\t inform (input_location, \"Use -Wno-error=coverage-mismatch to tolerate \"\n+\t inform (input_location, \"use -Wno-error=coverage-mismatch to tolerate \"\n \t \t \"the mismatch but performance may drop if the function is hot\");\n \t  \n \t  if (!seen_error ()\n@@ -388,12 +372,12 @@ get_coverage_counts (unsigned counter, unsigned expected,\n \n       return NULL;\n     }\n-    else if (entry->lineno_checksum != lineno_checksum)\n-      {\n-        warning (0, \"Source location for function %qE have changed,\"\n-                 \" the profile data may be out of date\",\n-                 DECL_ASSEMBLER_NAME (current_function_decl));\n-      }\n+  else if (entry->lineno_checksum != lineno_checksum)\n+    {\n+      warning (0, \"source location for function %qE have changed,\"\n+\t       \" the profile data may be out of date\",\n+\t       DECL_ASSEMBLER_NAME (current_function_decl));\n+    }\n \n   if (summary)\n     *summary = &entry->summary;\n@@ -413,28 +397,17 @@ coverage_counter_alloc (unsigned counter, unsigned num)\n   if (!num)\n     return 1;\n \n-  if (!tree_ctr_tables[counter])\n+  if (!fn_v_ctrs[counter])\n     {\n-      /* Generate and save a copy of this so it can be shared.  Leave\n-\t the index type unspecified for now; it will be set after all\n-\t functions have been compiled.  */\n-      char buf[20];\n-      tree gcov_type_node = get_gcov_type ();\n-      tree gcov_type_array_type\n-        = build_array_type (gcov_type_node, NULL_TREE);\n-      tree_ctr_tables[counter]\n-        = build_decl (BUILTINS_LOCATION,\n-\t\t      VAR_DECL, NULL_TREE, gcov_type_array_type);\n-      TREE_STATIC (tree_ctr_tables[counter]) = 1;\n-      ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", counter + 1);\n-      DECL_NAME (tree_ctr_tables[counter]) = get_identifier (buf);\n-      DECL_ALIGN (tree_ctr_tables[counter]) = TYPE_ALIGN (gcov_type_node);\n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"Using data file %s\\n\", da_file_name);\n+      tree array_type = build_array_type (get_gcov_type (), NULL_TREE);\n+\n+      fn_v_ctrs[counter]\n+\t= build_var (current_function_decl, array_type, counter);\n     }\n+\n   fn_b_ctrs[counter] = fn_n_ctrs[counter];\n   fn_n_ctrs[counter] += num;\n+  \n   fn_ctr_mask |= 1 << counter;\n   return 1;\n }\n@@ -447,10 +420,11 @@ tree_coverage_counter_ref (unsigned counter, unsigned no)\n   tree gcov_type_node = get_gcov_type ();\n \n   gcc_assert (no < fn_n_ctrs[counter] - fn_b_ctrs[counter]);\n-  no += prg_n_ctrs[counter] + fn_b_ctrs[counter];\n \n+  no += fn_b_ctrs[counter];\n+  \n   /* \"no\" here is an array index, scaled to bytes later.  */\n-  return build4 (ARRAY_REF, gcov_type_node, tree_ctr_tables[counter],\n+  return build4 (ARRAY_REF, gcov_type_node, fn_v_ctrs[counter],\n \t\t build_int_cst (integer_type_node, no), NULL, NULL);\n }\n \n@@ -462,13 +436,11 @@ tree_coverage_counter_addr (unsigned counter, unsigned no)\n   tree gcov_type_node = get_gcov_type ();\n \n   gcc_assert (no < fn_n_ctrs[counter] - fn_b_ctrs[counter]);\n-  no += prg_n_ctrs[counter] + fn_b_ctrs[counter];\n-\n-  TREE_ADDRESSABLE (tree_ctr_tables[counter]) = 1;\n+  no += fn_b_ctrs[counter];\n \n   /* \"no\" here is an array index, scaled to bytes later.  */\n   return build_fold_addr_expr (build4 (ARRAY_REF, gcov_type_node,\n-\t\t\t\t       tree_ctr_tables[counter],\n+\t\t\t\t       fn_v_ctrs[counter],\n \t\t\t\t       build_int_cst (integer_type_node, no),\n \t\t\t\t       NULL, NULL));\n }\n@@ -647,78 +619,159 @@ coverage_end_function (unsigned lineno_checksum, unsigned cfg_checksum)\n     {\n       struct function_list *item;\n \n-      item = XCNEW (struct function_list);\n-\n-      *functions_tail = item;\n-      functions_tail = &item->next;\n-\n+      item = ggc_alloc_function_list ();\n \n       item->next = 0;\n       item->ident = current_function_funcdef_no + 1;\n       item->lineno_checksum = lineno_checksum;\n       item->cfg_checksum = cfg_checksum;\n+      item->fn_decl = current_function_decl;\n       for (i = 0; i != GCOV_COUNTERS; i++)\n \t{\n-\t  item->n_ctrs[i] = fn_n_ctrs[i];\n-\t  prg_n_ctrs[i] += fn_n_ctrs[i];\n-\t  fn_n_ctrs[i] = fn_b_ctrs[i] = 0;\n+\t  tree var = fn_v_ctrs[i];\n+\t  \n+\t  item->ctr_vars[i] = var;\n+\t  if (var)\n+\t    {\n+\t      tree array_type = build_index_type (size_int (fn_n_ctrs[i] - 1));\n+\t      array_type = build_array_type (get_gcov_type (), array_type);\n+\t      TREE_TYPE (var) = array_type;\n+\t      DECL_SIZE (var) = TYPE_SIZE (array_type);\n+\t      DECL_SIZE_UNIT (var) = TYPE_SIZE_UNIT (array_type);\n+\t      varpool_finalize_decl (var);\n+\t    }\n+\t  fn_b_ctrs[i] = fn_n_ctrs[i] = 0;\n+\t  fn_v_ctrs[i] = NULL_TREE;\n \t}\n       prg_ctr_mask |= fn_ctr_mask;\n       fn_ctr_mask = 0;\n+      /* If the function is extern (i.e. extern inline), then we won't\n+\t be outputting it, so don't chain it onto the function list.  */\n+      if (!DECL_EXTERNAL (item->fn_decl))\n+\t{\n+\t  *functions_tail = item;\n+\t  functions_tail = &item->next;\n+\t}\n     }\n   bbg_function_announced = 0;\n }\n \n-/* Creates the gcov_fn_info RECORD_TYPE.  */\n+/* Build a coverage variable of TYPE for function FN_DECL.  If COUNTER\n+   >= 0 it is a counter array, and thus local.  Otherwise it is the\n+   function structure and needs to be globalized.  All cases must be\n+   in the same comdat group as FN_DECL.  */\n \n static tree\n-build_fn_info_type (unsigned int counters)\n+build_var (tree fn_decl, tree type, int counter)\n+{\n+  tree var = build_decl (BUILTINS_LOCATION, VAR_DECL, NULL_TREE, type);\n+  tree fn_name = DECL_ASSEMBLER_NAME (fn_decl);\n+  char *buf = (char *)alloca (IDENTIFIER_LENGTH (fn_name) + 10);\n+\n+  if (counter >= 0)\n+    TREE_STATIC (var) = 1;\n+  else\n+    {\n+      TREE_PUBLIC (var) = TREE_PUBLIC (fn_decl);\n+      TREE_STATIC (var) = TREE_STATIC (fn_decl);\n+    }\n+  TREE_ADDRESSABLE (var) = 1;\n+  DECL_ALIGN (var) = TYPE_ALIGN (type);\n+\n+  if (counter < 0)\n+    sprintf (buf, \"__gcov__%s\", IDENTIFIER_POINTER (fn_name));\n+  else\n+    sprintf (buf, \"__gcov%u_%s\", counter, IDENTIFIER_POINTER (fn_name));\n+  DECL_NAME (var) = get_identifier (buf);\n+\n+  /* Initialize assembler name so we can stream out. */\n+  if (TREE_PUBLIC (var))\n+    DECL_ASSEMBLER_NAME (var);    \n+\n+  DECL_WEAK (var) = TREE_PUBLIC (var) && DECL_WEAK (fn_decl);\n+  DECL_COMDAT (var) = DECL_COMDAT (fn_decl);\n+  DECL_COMDAT_GROUP (var) = DECL_COMDAT_GROUP (fn_decl);\n+\n+  return var;\n+}\n+\n+/* Creates the gcov_fn_info RECORD_TYPE.  */\n+\n+static void\n+build_fn_info_type (tree type, unsigned counters, tree gcov_info_type)\n {\n-  tree type = lang_hooks.types.make_type (RECORD_TYPE);\n+  tree ctr_info = lang_hooks.types.make_type (RECORD_TYPE);\n   tree field, fields;\n   tree array_type;\n \n+  gcc_assert (counters);\n+  \n+  /* ctr_info::num */\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      get_gcov_unsigned_t ());\n+  fields = field;\n+  \n+  /* ctr_info::values */\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      build_pointer_type (get_gcov_type ()));\n+  DECL_CHAIN (field) = fields;\n+  fields = field;\n+  \n+  finish_builtin_struct (ctr_info, \"__gcov_ctr_info\", fields, NULL_TREE);\n+\n+  /* key */\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      build_pointer_type (build_qualified_type\n+\t\t\t\t\t  (gcov_info_type, TYPE_QUAL_CONST)));\n+  fields = field;\n+  \n   /* ident */\n-  fields = build_decl (BUILTINS_LOCATION,\n-\t\t       FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      get_gcov_unsigned_t ());\n+  DECL_CHAIN (field) = fields;\n+  fields = field;\n+  \n   /* lineno_checksum */\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      get_gcov_unsigned_t ());\n   DECL_CHAIN (field) = fields;\n   fields = field;\n \n   /* cfg checksum */\n-  field = build_decl (BUILTINS_LOCATION,\n-                      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      get_gcov_unsigned_t ());\n   DECL_CHAIN (field) = fields;\n   fields = field;\n \n   array_type = build_index_type (size_int (counters - 1));\n-  array_type = build_array_type (get_gcov_unsigned_t (), array_type);\n+  array_type = build_array_type (ctr_info, array_type);\n \n   /* counters */\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, array_type);\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE, array_type);\n   DECL_CHAIN (field) = fields;\n   fields = field;\n \n   finish_builtin_struct (type, \"__gcov_fn_info\", fields, NULL_TREE);\n-\n-  return type;\n }\n \n /* Creates a CONSTRUCTOR for a gcov_fn_info. FUNCTION is\n    the function being processed and TYPE is the gcov_fn_info\n-   RECORD_TYPE.  */\n+   RECORD_TYPE.  KEY is the object file key. */\n \n static tree\n-build_fn_info_value (const struct function_list *function, tree type)\n+build_fn_info (const struct function_list *function, tree type, tree key)\n {\n   tree fields = TYPE_FIELDS (type);\n+  tree ctr_type;\n   unsigned ix;\n   VEC(constructor_elt,gc) *v1 = NULL;\n   VEC(constructor_elt,gc) *v2 = NULL;\n \n+  /* key */\n+  CONSTRUCTOR_APPEND_ELT (v1, fields,\n+\t\t\t  build1 (ADDR_EXPR, TREE_TYPE (fields), key));\n+  fields = DECL_CHAIN (fields);\n+  \n   /* ident */\n   CONSTRUCTOR_APPEND_ELT (v1, fields,\n \t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n@@ -738,240 +791,194 @@ build_fn_info_value (const struct function_list *function, tree type)\n   fields = DECL_CHAIN (fields);\n \n   /* counters */\n+  ctr_type = TREE_TYPE (TREE_TYPE (fields));\n   for (ix = 0; ix != GCOV_COUNTERS; ix++)\n     if (prg_ctr_mask & (1 << ix))\n-      CONSTRUCTOR_APPEND_ELT (v2, NULL,\n-\t\t\t      build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t\t      function->n_ctrs[ix]));\n-\n+      {\n+\tVEC(constructor_elt,gc) *ctr = NULL;\n+\ttree var = function->ctr_vars[ix];\n+\tunsigned count = 0;\n+\n+\tif (var)\n+\t  count\n+\t    = tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (var))), 0)\n+\t    + 1;\n+\n+\tCONSTRUCTOR_APPEND_ELT (ctr, TYPE_FIELDS (ctr_type),\n+\t\t\t\tbuild_int_cstu (get_gcov_unsigned_t (),\n+\t\t\t\t\t\tcount));\n+\n+\tif (var)\n+\t  CONSTRUCTOR_APPEND_ELT (ctr, DECL_CHAIN (TYPE_FIELDS (ctr_type)),\n+\t\t\t\t  build_fold_addr_expr (var));\n+\t\n+\tCONSTRUCTOR_APPEND_ELT (v2, NULL, build_constructor (ctr_type, ctr));\n+      }\n+  \n   CONSTRUCTOR_APPEND_ELT (v1, fields,\n \t\t\t  build_constructor (TREE_TYPE (fields), v2));\n \n   return build_constructor (type, v1);\n }\n \n-/* Creates the gcov_ctr_info RECORD_TYPE.  */\n+/* Creaste gcov_info_struct.  N_FUNCS is the number of functions in\n+   the trailing array.  */\n \n-static tree\n-build_ctr_info_type (void)\n+static void\n+build_info_type (tree type, unsigned n_funcs, tree fn_info_type)\n {\n-  tree type = lang_hooks.types.make_type (RECORD_TYPE);\n   tree field, fields = NULL_TREE;\n-  tree gcov_ptr_type = build_pointer_type (get_gcov_type ());\n-  tree gcov_merge_fn_type;\n+  tree merge_fn_type, fn_info_array;\n \n-  /* counters */\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  gcc_assert (n_funcs);\n+  \n+  /* Version ident */\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      get_gcov_unsigned_t ());\n   DECL_CHAIN (field) = fields;\n   fields = field;\n \n-  /* values */\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, gcov_ptr_type);\n+  /* next pointer */\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      build_pointer_type (build_qualified_type\n+\t\t\t\t\t  (type, TYPE_QUAL_CONST)));\n   DECL_CHAIN (field) = fields;\n   fields = field;\n \n-  /* merge */\n-  gcov_merge_fn_type =\n-    build_function_type_list (void_type_node,\n-\t\t\t      gcov_ptr_type, get_gcov_unsigned_t (),\n-\t\t\t      NULL_TREE);\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE,\n-\t\t      build_pointer_type (gcov_merge_fn_type));\n+  /* stamp */\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      get_gcov_unsigned_t ());\n   DECL_CHAIN (field) = fields;\n   fields = field;\n \n-  finish_builtin_struct (type, \"__gcov_ctr_info\", fields, NULL_TREE);\n-\n-  return type;\n-}\n-\n-/* Creates a CONSTRUCTOR for a gcov_ctr_info. COUNTER is\n-   the counter being processed and TYPE is the gcov_ctr_info\n-   RECORD_TYPE.  */\n-\n-static tree\n-build_ctr_info_value (unsigned int counter, tree type)\n-{\n-  tree fields = TYPE_FIELDS (type);\n-  tree fn;\n-  VEC(constructor_elt,gc) *v = NULL;\n-\n-  /* counters */\n-  CONSTRUCTOR_APPEND_ELT (v, fields,\n-\t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t\t  prg_n_ctrs[counter]));\n-  fields = DECL_CHAIN (fields);\n+  /* Filename */\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      build_pointer_type (build_qualified_type\n+\t\t\t\t\t  (char_type_node, TYPE_QUAL_CONST)));\n+  DECL_CHAIN (field) = fields;\n+  fields = field;\n \n-  if (prg_n_ctrs[counter])\n-    {\n-      tree array_type;\n-\n-      array_type = build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t   prg_n_ctrs[counter] - 1);\n-      array_type = build_index_type (array_type);\n-      array_type = build_array_type (TREE_TYPE (TREE_TYPE (fields)),\n-\t\t\t\t     array_type);\n-\n-      TREE_TYPE (tree_ctr_tables[counter]) = array_type;\n-      DECL_SIZE (tree_ctr_tables[counter]) = TYPE_SIZE (array_type);\n-      DECL_SIZE_UNIT (tree_ctr_tables[counter]) = TYPE_SIZE_UNIT (array_type);\n-      varpool_finalize_decl (tree_ctr_tables[counter]);\n-\n-      CONSTRUCTOR_APPEND_ELT (v, fields,\n-\t\t\t      build1 (ADDR_EXPR, TREE_TYPE (fields),\n-\t\t\t\t      tree_ctr_tables[counter]));\n-    }\n-  else\n-    CONSTRUCTOR_APPEND_ELT (v, fields, null_pointer_node);\n-  fields = DECL_CHAIN (fields);\n+  /* merge fn array */\n+  merge_fn_type\n+    = build_function_type_list (void_type_node,\n+\t\t\t\tbuild_pointer_type (get_gcov_type ()),\n+\t\t\t\tget_gcov_unsigned_t (), NULL_TREE);\n+  merge_fn_type\n+    = build_array_type (build_pointer_type (merge_fn_type),\n+\t\t\tbuild_index_type (size_int (GCOV_COUNTERS - 1)));\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      merge_fn_type);\n+  DECL_CHAIN (field) = fields;\n+  fields = field;\n+  \n+  /* n_functions */\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      get_gcov_unsigned_t ());\n+  DECL_CHAIN (field) = fields;\n+  fields = field;\n+  \n+  /* function_info pointer array */\n+  fn_info_type = build_pointer_type\n+    (build_qualified_type (fn_info_type, TYPE_QUAL_CONST));\n+  fn_info_array = build_index_type (size_int (n_funcs));\n+  fn_info_array = build_array_type (fn_info_type, fn_info_array);\n+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t      fn_info_array);\n+  DECL_CHAIN (field) = fields;\n+  fields = field;\n \n-  fn = build_decl (BUILTINS_LOCATION,\n-\t\t   FUNCTION_DECL,\n-\t\t   get_identifier (ctr_merge_functions[counter]),\n-\t\t   TREE_TYPE (TREE_TYPE (fields)));\n-  DECL_EXTERNAL (fn) = 1;\n-  TREE_PUBLIC (fn) = 1;\n-  DECL_ARTIFICIAL (fn) = 1;\n-  TREE_NOTHROW (fn) = 1;\n-  DECL_ASSEMBLER_NAME (fn);  /* Initialize assembler name so we can stream out. */\n-  CONSTRUCTOR_APPEND_ELT (v, fields, build1 (ADDR_EXPR, TREE_TYPE (fields), fn));\n-\n-  return build_constructor (type, v);\n+  finish_builtin_struct (type, \"__gcov_info\", fields, NULL_TREE);\n }\n \n-/* Creates the gcov_info RECORD_TYPE and initializer for it. Returns a\n-   CONSTRUCTOR.  */\n+/* Creates the gcov_info initializer. Returns a CONSTRUCTOR.  */\n \n static tree\n-build_gcov_info (void)\n+build_info (tree info_type, tree fn_type, tree key_var, unsigned n_funcs)\n {\n-  unsigned n_ctr_types, ix;\n-  tree type, const_type;\n-  tree fn_info_type, fn_info_value = NULL_TREE;\n-  tree fn_info_ptr_type;\n-  tree ctr_info_type, ctr_info_ary_type, ctr_info_value = NULL_TREE;\n-  tree field, fields = NULL_TREE;\n+  tree info_fields = TYPE_FIELDS (info_type);\n+  tree merge_fn_type, fn_info_ptr_type;\n+  unsigned ix;\n   tree filename_string;\n   int da_file_name_len;\n-  unsigned n_fns;\n   const struct function_list *fn;\n-  tree string_type;\n   VEC(constructor_elt,gc) *v1 = NULL;\n   VEC(constructor_elt,gc) *v2 = NULL;\n-\n-  /* Count the number of active counters.  */\n-  for (n_ctr_types = 0, ix = 0; ix != GCOV_COUNTERS; ix++)\n-    if (prg_ctr_mask & (1 << ix))\n-      n_ctr_types++;\n-\n-  type = lang_hooks.types.make_type (RECORD_TYPE);\n-  const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n+  VEC(constructor_elt,gc) *v3 = NULL;\n \n   /* Version ident */\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n-  DECL_CHAIN (field) = fields;\n-  fields = field;\n-  CONSTRUCTOR_APPEND_ELT (v1, field,\n-\t\t\t  build_int_cstu (TREE_TYPE (field), GCOV_VERSION));\n+  CONSTRUCTOR_APPEND_ELT (v1, info_fields,\n+\t\t\t  build_int_cstu (TREE_TYPE (info_fields),\n+\t\t\t\t\t  GCOV_VERSION));\n+  info_fields = DECL_CHAIN (info_fields);\n \n   /* next -- NULL */\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, build_pointer_type (const_type));\n-  DECL_CHAIN (field) = fields;\n-  fields = field;\n-  CONSTRUCTOR_APPEND_ELT (v1, field, null_pointer_node);\n-\n+  CONSTRUCTOR_APPEND_ELT (v1, info_fields, null_pointer_node);\n+  info_fields = DECL_CHAIN (info_fields);\n+  \n   /* stamp */\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n-  DECL_CHAIN (field) = fields;\n-  fields = field;\n-  CONSTRUCTOR_APPEND_ELT (v1, field,\n-\t\t\t  build_int_cstu (TREE_TYPE (field), local_tick));\n+  CONSTRUCTOR_APPEND_ELT (v1, info_fields,\n+\t\t\t  build_int_cstu (TREE_TYPE (info_fields),\n+\t\t\t\t\t  local_tick));\n+  info_fields = DECL_CHAIN (info_fields);\n \n   /* Filename */\n-  string_type = build_pointer_type (build_qualified_type (char_type_node,\n-\t\t\t\t\t\t    TYPE_QUAL_CONST));\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, string_type);\n-  DECL_CHAIN (field) = fields;\n-  fields = field;\n   da_file_name_len = strlen (da_file_name);\n   filename_string = build_string (da_file_name_len + 1, da_file_name);\n   TREE_TYPE (filename_string) = build_array_type\n     (char_type_node, build_index_type (size_int (da_file_name_len)));\n-  CONSTRUCTOR_APPEND_ELT (v1, field,\n-\t\t\t  build1 (ADDR_EXPR, string_type, filename_string));\n+  CONSTRUCTOR_APPEND_ELT (v1, info_fields,\n+\t\t\t  build1 (ADDR_EXPR, TREE_TYPE (info_fields),\n+\t\t\t\t  filename_string));\n+  info_fields = DECL_CHAIN (info_fields);\n \n-  /* Build the fn_info type and initializer.  */\n-  fn_info_type = build_fn_info_type (n_ctr_types);\n-  fn_info_ptr_type = build_pointer_type (build_qualified_type\n-\t\t\t\t\t (fn_info_type, TYPE_QUAL_CONST));\n-  for (fn = functions_head, n_fns = 0; fn; fn = fn->next, n_fns++)\n-    CONSTRUCTOR_APPEND_ELT (v2, NULL_TREE,\n-\t\t\t    build_fn_info_value (fn, fn_info_type));\n-\n-  if (n_fns)\n+  /* merge fn array -- NULL slots indicate unmeasured counters */\n+  merge_fn_type = TREE_TYPE (TREE_TYPE (info_fields));\n+  for (ix = 0; ix != GCOV_COUNTERS; ix++)\n     {\n-      tree array_type;\n-\n-      array_type = build_index_type (size_int (n_fns - 1));\n-      array_type = build_array_type (fn_info_type, array_type);\n+      tree ptr = null_pointer_node;\n \n-      fn_info_value = build_constructor (array_type, v2);\n-      fn_info_value = build1 (ADDR_EXPR, fn_info_ptr_type, fn_info_value);\n+      if ((1u << ix) & prg_ctr_mask)\n+\t{\n+\t  tree merge_fn = build_decl (BUILTINS_LOCATION,\n+\t\t\t\t      FUNCTION_DECL,\n+\t\t\t\t      get_identifier (ctr_merge_functions[ix]),\n+\t\t\t\t      TREE_TYPE (merge_fn_type));\n+\t  DECL_EXTERNAL (merge_fn) = 1;\n+\t  TREE_PUBLIC (merge_fn) = 1;\n+\t  DECL_ARTIFICIAL (merge_fn) = 1;\n+\t  TREE_NOTHROW (merge_fn) = 1;\n+\t  /* Initialize assembler name so we can stream out. */\n+\t  DECL_ASSEMBLER_NAME (merge_fn);\n+\t  ptr = build1 (ADDR_EXPR, merge_fn_type, merge_fn);\n+\t}\n+      CONSTRUCTOR_APPEND_ELT (v2, NULL, ptr);\n     }\n-  else\n-    fn_info_value = null_pointer_node;\n-\n-  /* number of functions */\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n-  DECL_CHAIN (field) = fields;\n-  fields = field;\n-  CONSTRUCTOR_APPEND_ELT (v1, field,\n-\t\t\t  build_int_cstu (get_gcov_unsigned_t (), n_fns));\n-\n-  /* fn_info table */\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, fn_info_ptr_type);\n-  DECL_CHAIN (field) = fields;\n-  fields = field;\n-  CONSTRUCTOR_APPEND_ELT (v1, field, fn_info_value);\n-\n-  /* counter_mask */\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n-  DECL_CHAIN (field) = fields;\n-  fields = field;\n-  CONSTRUCTOR_APPEND_ELT (v1, field, \n-\t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t\t  prg_ctr_mask));\n-\n-  /* counters */\n-  ctr_info_type = build_ctr_info_type ();\n-  ctr_info_ary_type = build_index_type (size_int (n_ctr_types));\n-  ctr_info_ary_type = build_array_type (ctr_info_type, ctr_info_ary_type);\n-  v2 = NULL;\n-  for (ix = 0; ix != GCOV_COUNTERS; ix++)\n-    if (prg_ctr_mask & (1 << ix))\n-      CONSTRUCTOR_APPEND_ELT (v2, NULL_TREE,\n-\t\t\t      build_ctr_info_value (ix, ctr_info_type));\n-  ctr_info_value = build_constructor (ctr_info_ary_type, v2);\n-\n-  field = build_decl (BUILTINS_LOCATION,\n-\t\t      FIELD_DECL, NULL_TREE, ctr_info_ary_type);\n-  DECL_CHAIN (field) = fields;\n-  fields = field;\n-  CONSTRUCTOR_APPEND_ELT (v1, field, ctr_info_value);\n-\n-  finish_builtin_struct (type, \"__gcov_info\", fields, NULL_TREE);\n-\n-  return build_constructor (type, v1);\n+  CONSTRUCTOR_APPEND_ELT (v1, info_fields,\n+\t\t\t  build_constructor (TREE_TYPE (info_fields), v2));\n+  info_fields = DECL_CHAIN (info_fields);\n+\n+  /* n_functions */\n+  CONSTRUCTOR_APPEND_ELT (v1, info_fields,\n+\t\t\t  build_int_cstu (TREE_TYPE (info_fields), n_funcs));\n+  info_fields = DECL_CHAIN (info_fields);\n+  \n+  /* Build the fn_info type and initializer.  */\n+  fn_info_ptr_type = TREE_TYPE (TREE_TYPE (info_fields));\n+  \n+  for (fn = functions_head; fn; fn = fn->next)\n+    {\n+      tree init = build_fn_info (fn, fn_type, key_var);\n+      tree var = build_var (fn->fn_decl, fn_type, -1);\n+\n+      DECL_INITIAL (var) = init;\n+      varpool_finalize_decl (var);\n+      \n+      CONSTRUCTOR_APPEND_ELT (v3, NULL,\n+\t\t\t      build1 (ADDR_EXPR, fn_info_ptr_type, var));\n+    }\n+  CONSTRUCTOR_APPEND_ELT (v1, info_fields,\n+\t\t\t  build_constructor (TREE_TYPE (info_fields), v3));\n+  return build_constructor (info_type, v1);\n }\n \n /* Write out the structure which libgcov uses to locate all the\n@@ -982,21 +989,49 @@ static void\n create_coverage (void)\n {\n   tree gcov_info, gcov_init, body, t;\n+  tree gcov_info_type, gcov_fn_type;\n+  unsigned n_counters = 0, n_functions  = 0;\n+  struct function_list *fn;\n+  struct function_list **fn_prev;\n+  unsigned ix;\n   char name_buf[32];\n \n   no_coverage = 1; /* Disable any further coverage.  */\n \n   if (!prg_ctr_mask)\n     return;\n \n-  t = build_gcov_info ();\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"Using data file %s\\n\", da_file_name);\n \n+  for (ix = 0; ix != GCOV_COUNTERS; ix++)\n+    if ((1u << ix) & prg_ctr_mask)\n+      n_counters++;\n+  for (fn_prev = &functions_head; (fn = *fn_prev);)\n+    if (DECL_STRUCT_FUNCTION (fn->fn_decl))\n+      {\n+\tn_functions++;\n+\tfn_prev = &fn->next;\n+      }\n+    else\n+      /* The function is not being emitted, remove from list.  */\n+      *fn_prev = fn->next;\n+  \n+  /* Build the info and fn_info types.  These are mutually recursive.  */\n+  gcov_info_type = lang_hooks.types.make_type (RECORD_TYPE);\n+  gcov_fn_type = lang_hooks.types.make_type (RECORD_TYPE);\n+  build_fn_info_type (gcov_fn_type, n_counters, gcov_info_type);\n+  build_info_type (gcov_info_type, n_functions, gcov_fn_type);\n+  \n+  /* Build the gcov info var, this is referred to in its own\n+     initializer.  */\n   gcov_info = build_decl (BUILTINS_LOCATION,\n-\t\t\t  VAR_DECL, NULL_TREE, TREE_TYPE (t));\n+\t\t\t  VAR_DECL, NULL_TREE, gcov_info_type);\n   TREE_STATIC (gcov_info) = 1;\n   ASM_GENERATE_INTERNAL_LABEL (name_buf, \"LPBX\", 0);\n   DECL_NAME (gcov_info) = get_identifier (name_buf);\n-  DECL_INITIAL (gcov_info) = t;\n+  DECL_INITIAL (gcov_info) = build_info (gcov_info_type, gcov_fn_type,\n+\t\t\t\t\t gcov_info, n_functions);\n \n   /* Build structure.  */\n   varpool_finalize_decl (gcov_info);"}, {"sha": "a6c5b33c62208fc5f4acb00a4c1545802b45df0e", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -276,23 +276,28 @@ dump_file (const char *filename)\n \n static void\n tag_function (const char *filename ATTRIBUTE_UNUSED,\n-\t      unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n+\t      unsigned tag ATTRIBUTE_UNUSED, unsigned length)\n {\n   unsigned long pos = gcov_position ();\n \n-  printf (\" ident=%u\", gcov_read_unsigned ());\n-  printf (\", lineno_checksum=0x%08x\", gcov_read_unsigned ());\n-  printf (\", cfg_checksum_checksum=0x%08x\", gcov_read_unsigned ());\n-\n-  if (gcov_position () - pos < length)\n+  if (!length)\n+    printf (\" placeholder\");\n+  else\n     {\n-      const char *name;\n+      printf (\" ident=%u\", gcov_read_unsigned ());\n+      printf (\", lineno_checksum=0x%08x\", gcov_read_unsigned ());\n+      printf (\", cfg_checksum_checksum=0x%08x\", gcov_read_unsigned ());\n \n-      name = gcov_read_string ();\n-      printf (\", `%s'\", name ? name : \"NULL\");\n-      name = gcov_read_string ();\n-      printf (\" %s\", name ? name : \"NULL\");\n-      printf (\":%u\", gcov_read_unsigned ());\n+      if (gcov_position () - pos < length)\n+\t{\n+\t  const char *name;\n+\t  \n+\t  name = gcov_read_string ();\n+\t  printf (\", `%s'\", name ? name : \"NULL\");\n+\t  name = gcov_read_string ();\n+\t  printf (\" %s\", name ? name : \"NULL\");\n+\t  printf (\":%u\", gcov_read_unsigned ());\n+\t}\n     }\n }\n "}, {"sha": "3ff9fcd22f051acf5535f08a7f5a9ccca908e5ae", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -130,26 +130,26 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    blocks they are for.\n \n    The data file contains the following records.\n-        data: {unit function-data* summary:object summary:program*}*\n+        data: {unit summary:object summary:program* function-data*}*\n \tunit: header int32:checksum\n-        function-data:\tannounce_function arc_counts\n+        function-data:\tannounce_function present counts\n \tannounce_function: header int32:ident\n \t\tint32:lineno_checksum int32:cfg_checksum\n-\tarc_counts: header int64:count*\n-\tsummary: int32:checksum {count-summary}GCOV_COUNTERS\n+\tpresent: header int32:present\n+\tcounts: header int64:count*\n+\tsummary: int32:checksum {count-summary}GCOV_COUNTERS_SUMMABLE\n \tcount-summary:\tint32:num int32:runs int64:sum\n \t\t\tint64:max int64:sum_max\n \n    The ANNOUNCE_FUNCTION record is the same as that in the note file,\n-   but without the source location.  The ARC_COUNTS gives the counter\n-   values for those arcs that are instrumented.  The SUMMARY records\n-   give information about the whole object file and about the whole\n+   but without the source location.  The COUNTS gives the\n+   counter values for instrumented features.  The about the whole\n    program.  The checksum is used for whole program summaries, and\n    disambiguates different programs which include the same\n    instrumented object file.  There may be several program summaries,\n-   each with a unique checksum.  The object summary's checksum is zero.\n-   Note that the data file might contain information from several runs\n-   concatenated, or the data might be merged.\n+   each with a unique checksum.  The object summary's checksum is\n+   zero.  Note that the data file might contain information from\n+   several runs concatenated, or the data might be merged.\n \n    This file is included by both the compiler, gcov tools and the\n    runtime support library libgcov. IN_LIBGCOV and IN_GCOV are used to\n@@ -307,7 +307,7 @@ typedef HOST_WIDEST_INT gcov_type;\n #define GCOV_TAG_COUNTER_BASE \t ((gcov_unsigned_t)0x01a10000)\n #define GCOV_TAG_COUNTER_LENGTH(NUM) ((NUM) * 2)\n #define GCOV_TAG_COUNTER_NUM(LENGTH) ((LENGTH) / 2)\n-#define GCOV_TAG_OBJECT_SUMMARY  ((gcov_unsigned_t)0xa1000000)\n+#define GCOV_TAG_OBJECT_SUMMARY  ((gcov_unsigned_t)0xa1000000) /* Obsolete */\n #define GCOV_TAG_PROGRAM_SUMMARY ((gcov_unsigned_t)0xa3000000)\n #define GCOV_TAG_SUMMARY_LENGTH  \\\n \t(1 + GCOV_COUNTERS_SUMMABLE * (2 + 3 * 2))\n@@ -343,7 +343,7 @@ typedef HOST_WIDEST_INT gcov_type;\n \n   /* A list of human readable names of the counters */\n #define GCOV_COUNTER_NAMES\t{\"arcs\", \"interval\", \"pow2\", \"single\", \\\n-\t\t\t\t \"delta\",\"indirect_call\", \"average\", \"ior\"}\n+      \t\t\t\t \"delta\", \"indirect_call\", \"average\", \"ior\"}\n \n   /* Names of merge functions for counters.  */\n #define GCOV_MERGE_FUNCTIONS\t{\"__gcov_merge_add\",\t\\\n@@ -410,30 +410,31 @@ struct gcov_summary\n    by write_profile must match these.  */\n \n #if IN_LIBGCOV\n+/* Information about counters for a single function.  */\n+struct gcov_ctr_info\n+{\n+  gcov_unsigned_t num;\t\t/* number of counters.  */\n+  gcov_type *values;\t\t/* their values.  */\n+};\n+\n /* Information about a single function.  This uses the trailing array\n-   idiom. The number of counters is determined from the counter_mask\n-   in gcov_info.  We hold an array of function info, so have to\n-   explicitly calculate the correct array stride.  */\n+   idiom. The number of counters is determined from the merge pointer\n+   array in gcov_info.  The key is used to detect which of a set of\n+   comdat functions was selected -- it points to the gcov_info object\n+   of the object file containing the selected comdat function.  */\n \n struct gcov_fn_info\n {\n-  gcov_unsigned_t ident;\t/* unique ident of function */\n+  const struct gcov_info *key;\t\t/* comdat key */\n+  gcov_unsigned_t ident;\t\t/* unique ident of function */\n   gcov_unsigned_t lineno_checksum;\t/* function lineo_checksum */\n-  gcov_unsigned_t cfg_checksum;\t/* function cfg checksum */\n-  unsigned n_ctrs[0];\t\t/* instrumented counters */\n+  gcov_unsigned_t cfg_checksum;\t\t/* function cfg checksum */\n+  struct gcov_ctr_info ctrs[0];\t\t/* instrumented counters */\n };\n \n /* Type of function used to merge counters.  */\n typedef void (*gcov_merge_fn) (gcov_type *, gcov_unsigned_t);\n \n-/* Information about counters.  */\n-struct gcov_ctr_info\n-{\n-  gcov_unsigned_t num;\t\t/* number of counters.  */\n-  gcov_type *values;\t\t/* their values.  */\n-  gcov_merge_fn merge;  \t/* The function used to merge them.  */\n-};\n-\n /* Information about a single object file.  */\n struct gcov_info\n {\n@@ -443,14 +444,12 @@ struct gcov_info\n   gcov_unsigned_t stamp;\t/* uniquifying time stamp */\n   const char *filename;\t\t/* output file name */\n \n+  gcov_merge_fn merge[GCOV_COUNTERS];  /* merge functions (null for\n+\t\t\t\t\t  unused) */\n+  \n   unsigned n_functions;\t\t/* number of functions */\n-  const struct gcov_fn_info *functions; /* table of functions */\n-\n-  unsigned ctr_mask;\t\t/* mask of counters instrumented.  */\n-  struct gcov_ctr_info counts[0]; /* count data. The number of bits\n-\t\t\t\t     set in the ctr_mask field\n-\t\t\t\t     determines how big this array\n-\t\t\t\t     is.  */\n+  const struct gcov_fn_info *functions[0]; /* pointers to function\n+\t\t\t\t\t      information  */\n };\n \n /* Register a new object file module.  */"}, {"sha": "6711f7e6a47bdaaffd869e8fb582b76473f5d4f3", "filename": "gcc/gcov.c", "status": "modified", "additions": 76, "deletions": 50, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -265,7 +265,7 @@ static unsigned source_index;\n \n /* This holds data summary information.  */\n \n-static struct gcov_summary object_summary;\n+static unsigned object_runs;\n static unsigned program_count;\n \n /* Modification time of graph file.  */\n@@ -362,6 +362,7 @@ static int output_branch_count (FILE *, int, const arc_t *);\n static void output_lines (FILE *, const source_t *);\n static char *make_gcov_file_name (const char *, const char *);\n static void release_structures (void);\n+static void release_function (function_t *);\n extern int main (int, char **);\n \n int\n@@ -537,7 +538,7 @@ static void\n process_file (const char *file_name)\n {\n   function_t *fn;\n-  function_t *fn_p;\n+  function_t **fn_p;\n   function_t *old_functions;\n \n   /* Save and clear the list of current functions.  They will be appended\n@@ -558,11 +559,25 @@ process_file (const char *file_name)\n   if (read_count_file ())\n     return;\n \n-  for (fn_p = NULL, fn = functions; fn; fn_p = fn, fn = fn->next)\n-    solve_flow_graph (fn);\n+  fn_p = &functions;\n+  while ((fn = *fn_p) != NULL)\n+    {\n+      if (fn->counts)\n+\t{\n+\t  solve_flow_graph (fn);\n+\t  fn_p = &fn->next;\n+\t}\n+      else\n+\t{\n+\t  /* The function was not in the executable -- some other\n+\t     instance must have been selected.  */\n+\t  function_t *next = fn->next;\n+\t  release_function (fn);\n+\t  *fn_p = next;\n+\t}\n+    }\n \n-  if (fn_p)\n-    fn_p->next = old_functions;\n+  *fn_p = old_functions;\n }\n \n static void\n@@ -591,7 +606,7 @@ generate_results (const char *file_name)\n     {\n       accumulate_line_counts (src);\n       function_summary (&src->coverage, \"File\");\n-      if (flag_gcov_file)\n+      if (flag_gcov_file && src->coverage.lines)\n \t{\n \t  char *gcov_file_name = make_gcov_file_name (file_name, src->name);\n \t  FILE *gcov_file = fopen (gcov_file_name, \"w\");\n@@ -615,6 +630,28 @@ generate_results (const char *file_name)\n     }\n }\n \n+/* Release a function structure */\n+\n+static void\n+release_function (function_t *fn)\n+{\n+  unsigned ix;\n+  block_t *block;\n+\n+  for (ix = fn->num_blocks, block = fn->blocks; ix--; block++)\n+    {\n+      arc_t *arc, *arc_n;\n+\n+      for (arc = block->succ; arc; arc = arc_n)\n+\t{\n+\t  arc_n = arc->succ_next;\n+\t  free (arc);\n+\t}\n+    }\n+  free (fn->blocks);\n+  free (fn->counts);\n+}\n+\n /* Release all memory used.  */\n \n static void\n@@ -633,22 +670,8 @@ release_structures (void)\n \n   while ((fn = functions))\n     {\n-      unsigned ix;\n-      block_t *block;\n-\n       functions = fn->next;\n-      for (ix = fn->num_blocks, block = fn->blocks; ix--; block++)\n-\t{\n-\t  arc_t *arc, *arc_n;\n-\n-\t  for (arc = block->succ; arc; arc = arc_n)\n-\t    {\n-\t      arc_n = arc->succ_next;\n-\t      free (arc);\n-\t    }\n-\t}\n-      free (fn->blocks);\n-      free (fn->counts);\n+      release_function (fn);\n     }\n }\n \n@@ -1085,35 +1108,39 @@ read_count_file (void)\n       unsigned length = gcov_read_unsigned ();\n       unsigned long base = gcov_position ();\n \n-      if (tag == GCOV_TAG_OBJECT_SUMMARY)\n-\tgcov_read_summary (&object_summary);\n-      else if (tag == GCOV_TAG_PROGRAM_SUMMARY)\n-\tprogram_count++;\n-      else if (tag == GCOV_TAG_FUNCTION)\n+      if (tag == GCOV_TAG_PROGRAM_SUMMARY)\n \t{\n-\t  {\n-\t    unsigned ident = gcov_read_unsigned ();\n-\t    struct function_info *fn_n = functions;\n+\t  struct gcov_summary summary;\n+\t  gcov_read_summary (&summary);\n+\t  object_runs += summary.ctrs[GCOV_COUNTER_ARCS].runs;\n+\t  program_count++;\n+\t}\n+      else if (tag == GCOV_TAG_FUNCTION && !length)\n+\t; /* placeholder  */\n+      else if (tag == GCOV_TAG_FUNCTION && length == GCOV_TAG_FUNCTION_LENGTH)\n+\t{\n+\t  unsigned ident;\n+\t  struct function_info *fn_n;\n \n-\t    /* Try to find the function in the list.\n-\t       To speed up the search, first start from the last function\n-\t       found.   */\n-\t    for (fn = fn ? fn->next : NULL; ; fn = fn->next)\n-\t      {\n-\t\tif (fn)\n-\t\t  ;\n-\t\telse if ((fn = fn_n))\n-\t\t  fn_n = NULL;\n-\t\telse\n-\t\t  {\n-\t\t    fnotice (stderr, \"%s:unknown function '%u'\\n\",\n-\t\t\t     da_file_name, ident);\n-\t\t    break;\n-\t\t  }\n-\t\tif (fn->ident == ident)\n+\t  /* Try to find the function in the list.  To speed up the\n+\t     search, first start from the last function found.  */\n+\t  ident = gcov_read_unsigned ();\n+\t  fn_n = functions;\n+\t  for (fn = fn ? fn->next : NULL; ; fn = fn->next)\n+\t    {\n+\t      if (fn)\n+\t\t;\n+\t      else if ((fn = fn_n))\n+\t\tfn_n = NULL;\n+\t      else\n+\t\t{\n+\t\t  fnotice (stderr, \"%s:unknown function '%u'\\n\",\n+\t\t\t   da_file_name, ident);\n \t\t  break;\n-\t      }\n-\t  }\n+\t\t}\n+\t      if (fn->ident == ident)\n+\t\tbreak;\n+\t    }\n \n \t  if (!fn)\n \t    ;\n@@ -1908,8 +1935,7 @@ output_lines (FILE *gcov_file, const source_t *src)\n       fprintf (gcov_file, \"%9s:%5d:Graph:%s\\n\", \"-\", 0, bbg_file_name);\n       fprintf (gcov_file, \"%9s:%5d:Data:%s\\n\", \"-\", 0,\n \t       no_data_file ? \"-\" : da_file_name);\n-      fprintf (gcov_file, \"%9s:%5d:Runs:%u\\n\", \"-\", 0,\n-\t       object_summary.ctrs[GCOV_COUNTER_ARCS].runs);\n+      fprintf (gcov_file, \"%9s:%5d:Runs:%u\\n\", \"-\", 0, object_runs);\n     }\n   fprintf (gcov_file, \"%9s:%5d:Programs:%u\\n\", \"-\", 0, program_count);\n "}, {"sha": "0dd3896bd51565e8299512d389075267573b1cb6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -1,3 +1,14 @@\n+2011-11-07  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* gcc.dg/profile-dir-1.c: Adjust final scan.\n+\t* gcc.dg/profile-dir-2.c: Adjust final scan.\n+\t* gcc.dg/profile-dir-3.c: Adjust final scan.\n+\t* gcc.misc-tests/gcov.exp: Adjust regexp.\n+\t* gcc.misc-tests/gcov-12.c: New.\n+\t* gcc.misc-tests/gcov-13.c: New.\n+\t* gcc.misc-tests/gcovpart-13b.c: New.\n+\t* gcc.misc-tests/gcov-14.c: New.\n+\n 2011-11-07  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/35688"}, {"sha": "fbe66ad22a8172379d34c8e9498abe8c4aabe10d", "filename": "gcc/testsuite/gcc.dg/profile-dir-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-1.c?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -1,11 +1,11 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fprofile-generate=. -fdump-ipa-profile\" } */\n-/* { dg-final { scan-ipa-dump \" ./profile-dir-1.gcda\" \"profile\" } } */\n+/* { dg-options \"-O -fprofile-generate=. -fdump-ipa-cgraph\" } */\n+/* { dg-final { scan-ipa-dump \" ./profile-dir-1.gcda\" \"cgraph\" } } */\n \n int\n main(void)\n {\n   return 0;\n }\n \n-/* { dg-final { cleanup-ipa-dump \"profile\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cgraph\" } } */"}, {"sha": "1708f7b7275c716c481105b65c329db5e526d820", "filename": "gcc/testsuite/gcc.dg/profile-dir-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-2.c?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -1,11 +1,11 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fprofile-generate -fdump-ipa-profile\" } */\n-/* { dg-final { scan-ipa-dump \"/profile-dir-2.gcda\" \"profile\" } } */\n+/* { dg-options \"-O -fprofile-generate -fdump-ipa-cgraph\" } */\n+/* { dg-final { scan-ipa-dump \"/profile-dir-2.gcda\" \"cgraph\" } } */\n \n int\n main(void)\n {\n   return 0;\n }\n \n-/* { dg-final { cleanup-ipa-dump \"profile\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cgraph\" } } */"}, {"sha": "ccedf0e7447ee7b79b11b1158418992bebc4d99f", "filename": "gcc/testsuite/gcc.dg/profile-dir-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-3.c?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -1,11 +1,11 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fprofile-generate -fprofile-dir=. -fdump-ipa-profile\" } */\n-/* { dg-final { scan-ipa-dump \" ./profile-dir-3.gcda\" \"profile\" } } */\n+/* { dg-options \"-O -fprofile-generate -fprofile-dir=. -fdump-ipa-cgraph\" } */\n+/* { dg-final { scan-ipa-dump \" ./profile-dir-3.gcda\" \"cgraph\" } } */\n \n int\n main(void)\n {\n   return 0;\n }\n \n-/* { dg-final { cleanup-ipa-dump \"profile\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cgraph\" } } */"}, {"sha": "1898aadb4ce67770634230f0a9427cd01f031663", "filename": "gcc/testsuite/gcc.misc-tests/gcov-12.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-12.c?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -0,0 +1,17 @@\n+/* Test gcov weak ellision.  */\n+\n+/* { dg-options \"-fprofile-arcs -ftest-coverage\" } */\n+/* { dg-require-weak \"\" } */\n+/* { dg-do run { target native } } */\n+\n+int __attribute__ ((weak)) weak ()\n+{\n+  return 0;  /* count(1) */\n+}\n+\n+int main ()\n+{\n+  return weak (); /* count(1) */\n+}\n+\n+/* { dg-final { run-gcov { -a gcov-12.c } } } */"}, {"sha": "605d4d4b3823a31d36107da8998cbb48222e70eb", "filename": "gcc/testsuite/gcc.misc-tests/gcov-13.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-13.c?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -0,0 +1,18 @@\n+/* Test gcov weak ellision.  */\n+\n+/* { dg-options \"-fprofile-arcs -ftest-coverage\" } */\n+/* { dg-require-weak \"\" } */\n+/* { dg-do run { target native } } */\n+/* { dg-additional-sources \"gcovpart-13b.c\" } */\n+\n+int __attribute__ ((weak)) weak ()\n+{\n+  return 1;  /* count(-) */\n+}\n+\n+int main ()\n+{\n+  return weak (); /* count(1) */\n+}\n+\n+/* { dg-final { run-gcov { -a gcov-13.c } } } */"}, {"sha": "0eaf284a9c4120d80b6dc572688956fdc1afa663", "filename": "gcc/testsuite/gcc.misc-tests/gcov-14.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-14.c?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -0,0 +1,24 @@\n+/* Test gcov extern inline.  */\n+\n+/* { dg-options \"-O2 -fprofile-arcs -ftest-coverage\" } */\n+/* { dg-require-weak \"\" } */\n+/* { dg-do run { target native } } */\n+\n+extern int __attribute__ ((weak)) Foo ();\n+\n+extern __inline int Foo ()\n+{\n+  return 0; /* count(-) */\n+}\n+\n+int (* __attribute__ ((noinline)) Bar ()) ()\n+{\n+  return Foo; /* count(1) */\n+}\n+\n+int main ()\n+{\n+  return Bar () != 0; /* count(1) */\n+}\n+\n+/* { dg-final { run-gcov { -a gcov-14.c } } } */"}, {"sha": "85a1c34abd943f24b59b980dfc2a521418f988e0", "filename": "gcc/testsuite/gcc.misc-tests/gcov.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov.exp?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -33,7 +33,7 @@ if { ![is_remote host] && [string match \"*/*\" [lindex $GCC_UNDER_TEST 0]] } {\n dg-init\n \n # Delete old .gcda files.\n-set files [glob -nocomplain gcov-*.gcda]\n+set files [glob -nocomplain gcov*.gcda]\n if { $files != \"\" } {\n     eval \"remote_file build delete $files\"\n }"}, {"sha": "0900ab48021e3ae61ecb4c8c9d1bb801d104705b", "filename": "gcc/testsuite/gcc.misc-tests/gcovpart-13b.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcovpart-13b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcovpart-13b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcovpart-13b.c?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -0,0 +1,4 @@\n+int weak ()\n+{\n+  return 0;  /* count(1) */\n+}"}, {"sha": "1f2070b03d7de15971b9a6bc17ddd7439a5b8cde", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -1,3 +1,9 @@\n+2011-11-07  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* libgcov.c (struct gcov_fn_buffer): New struct.\n+\t(buffer_fn_data): New helper.\n+\t(gcov_exit): Rework for new gcov data structures.\n+\n 2011-11-07  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/49313"}, {"sha": "f7691df967c520dc67a1c9afeb5c0c964cae2d65", "filename": "libgcc/libgcov.c", "status": "modified", "additions": 252, "deletions": 185, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5366b18679f7ead0a02c29759d4bb455f52114ce/libgcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5366b18679f7ead0a02c29759d4bb455f52114ce/libgcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.c?ref=5366b18679f7ead0a02c29759d4bb455f52114ce", "patch": "@@ -78,6 +78,14 @@ void __gcov_merge_delta (gcov_type *counters  __attribute__ ((unused)),\n #ifdef L_gcov\n #include \"gcov-io.c\"\n \n+struct gcov_fn_buffer\n+{\n+  struct gcov_fn_buffer *next;\n+  unsigned fn_ix;\n+  struct gcov_fn_info info;\n+  /* note gcov_fn_info ends in a trailing array.  */\n+};\n+\n /* Chain of per-object gcov structures.  */\n static struct gcov_info *gcov_list;\n \n@@ -135,6 +143,64 @@ create_file_directory (char *filename)\n #endif\n }\n \n+static struct gcov_fn_buffer **\n+buffer_fn_data (struct gcov_info *gi_ptr, struct gcov_fn_buffer **end_ptr,\n+\t\tunsigned fn_ix)\n+{\n+  unsigned n_ctrs = 0, ix;\n+  struct gcov_fn_buffer *fn_buffer;\n+\n+  for (ix = GCOV_COUNTERS; ix--;)\n+    if (gi_ptr->merge[ix])\n+      n_ctrs++;\n+\n+  fn_buffer = (struct gcov_fn_buffer *)malloc\n+    (sizeof (*fn_buffer) + sizeof (fn_buffer->info.ctrs[0]) * n_ctrs);\n+\n+  if (!fn_buffer)\n+    return 0; /* We'll horribly fail.  */\n+  \n+  fn_buffer->next = 0;\n+  fn_buffer->fn_ix = fn_ix;\n+  fn_buffer->info.ident = gcov_read_unsigned ();\n+  fn_buffer->info.lineno_checksum = gcov_read_unsigned ();\n+  fn_buffer->info.cfg_checksum = gcov_read_unsigned ();\n+\n+  for (n_ctrs = ix = 0; ix != GCOV_COUNTERS; ix++)\n+    {\n+      gcov_unsigned_t length;\n+      gcov_type *values;\n+\n+      if (!gi_ptr->merge[ix])\n+\tcontinue;\n+      \n+      if (gcov_read_unsigned () != GCOV_TAG_FOR_COUNTER (ix))\n+\tgoto fail;\n+\n+      length = GCOV_TAG_COUNTER_NUM (gcov_read_unsigned ());\n+      values = (gcov_type *)malloc (length * sizeof (gcov_type));\n+      if (!values)\n+\t{\n+\t  while (n_ctrs--)\n+\t    free (fn_buffer->info.ctrs[n_ctrs].values);\n+\t  goto fail;\n+\t}\n+      fn_buffer->info.ctrs[n_ctrs].num = length;\n+      fn_buffer->info.ctrs[n_ctrs].values = values;\n+\n+      while (length--)\n+\t*values++ = gcov_read_counter ();\n+      n_ctrs++;\n+    }\n+  \n+  *end_ptr = fn_buffer;\n+  return &fn_buffer->next;\n+\n+ fail:\n+  free (fn_buffer);\n+  return 0;\n+}\n+\n /* Check if VERSION of the info block PTR matches libgcov one.\n    Return 1 on success, or zero in case of versions mismatch.\n    If FILENAME is not NULL, its value used for reporting purposes\n@@ -170,39 +236,46 @@ static void\n gcov_exit (void)\n {\n   struct gcov_info *gi_ptr;\n-  struct gcov_summary this_program;\n-  struct gcov_summary all;\n+  const struct gcov_fn_info *gfi_ptr;\n+  struct gcov_summary this_prg; /* summary for program.  */\n+  struct gcov_summary all_prg;  /* summary for all instances of program.  */\n   struct gcov_ctr_summary *cs_ptr;\n   const struct gcov_ctr_info *ci_ptr;\n-  unsigned t_ix;\n+  unsigned t_ix, f_ix;\n   gcov_unsigned_t c_num;\n   const char *gcov_prefix;\n   int gcov_prefix_strip = 0;\n   size_t prefix_length;\n   char *gi_filename, *gi_filename_up;\n \n-  memset (&all, 0, sizeof (all));\n+  memset (&all_prg, 0, sizeof (all_prg));\n   /* Find the totals for this execution.  */\n-  memset (&this_program, 0, sizeof (this_program));\n+  memset (&this_prg, 0, sizeof (this_prg));\n   for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n-    {\n-      ci_ptr = gi_ptr->counts;\n-      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n-\t{\n-\t  if (!((1 << t_ix) & gi_ptr->ctr_mask))\n-\t    continue;\n+    for (f_ix = 0; f_ix != gi_ptr->n_functions; f_ix++)\n+      {\n+\tgfi_ptr = gi_ptr->functions[f_ix];\n+\t\n+\tif (!gfi_ptr || gfi_ptr->key != gi_ptr)\n+\t  continue;\n+\t\n+\tci_ptr = gfi_ptr->ctrs;\n+\tfor (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)\n+\t  {\n+\t    if (!gi_ptr->merge[t_ix])\n+\t      continue;\n \n-\t  cs_ptr = &this_program.ctrs[t_ix];\n-\t  cs_ptr->num += ci_ptr->num;\n-\t  for (c_num = 0; c_num < ci_ptr->num; c_num++)\n-\t    {\n-      \t      cs_ptr->sum_all += ci_ptr->values[c_num];\n-\t      if (cs_ptr->run_max < ci_ptr->values[c_num])\n-\t\tcs_ptr->run_max = ci_ptr->values[c_num];\n-\t    }\n-\t  ci_ptr++;\n-\t}\n-    }\n+\t    cs_ptr = &this_prg.ctrs[t_ix];\n+\t    cs_ptr->num += ci_ptr->num;\n+\t    for (c_num = 0; c_num < ci_ptr->num; c_num++)\n+\t      {\n+\t\tcs_ptr->sum_all += ci_ptr->values[c_num];\n+\t\tif (cs_ptr->run_max < ci_ptr->values[c_num])\n+\t\t  cs_ptr->run_max = ci_ptr->values[c_num];\n+\t      }\n+\t    ci_ptr++;\n+\t  }\n+      }\n \n   {\n     /* Check if the level of dirs to strip off specified. */\n@@ -215,6 +288,7 @@ gcov_exit (void)\n \t  gcov_prefix_strip = 0;\n       }\n   }\n+\n   /* Get file name relocation prefix.  Non-absolute values are ignored. */\n   gcov_prefix = getenv(\"GCOV_PREFIX\");\n   if (gcov_prefix)\n@@ -244,24 +318,20 @@ gcov_exit (void)\n   /* Now merge each file.  */\n   for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n     {\n-      struct gcov_summary this_object;\n-      struct gcov_summary object, program;\n-      gcov_type *values[GCOV_COUNTERS];\n-      const struct gcov_fn_info *fi_ptr;\n-      unsigned fi_stride;\n-      unsigned c_ix, f_ix, n_counts;\n-      struct gcov_ctr_summary *cs_obj, *cs_tobj, *cs_prg, *cs_tprg, *cs_all;\n+      unsigned n_counts;\n+      struct gcov_summary prg; /* summary for this object over all\n+\t\t\t\t  program.  */\n+      struct gcov_ctr_summary *cs_prg, *cs_tprg, *cs_all;\n       int error = 0;\n       gcov_unsigned_t tag, length;\n       gcov_position_t summary_pos = 0;\n       gcov_position_t eof_pos = 0;\n       const char *fname, *s;\n+      struct gcov_fn_buffer *fn_buffer = 0;\n+      struct gcov_fn_buffer **fn_tail = &fn_buffer;\n \n       fname = gi_ptr->filename;\n \n-      memset (&this_object, 0, sizeof (this_object));\n-      memset (&object, 0, sizeof (object));\n-\n       /* Avoid to add multiple drive letters into combined path.  */\n       if (prefix_length != 0 && HAS_DRIVE_SPEC(fname))\n         fname += 2;\n@@ -283,6 +353,7 @@ gcov_exit (void)\n \t\tlevel++;\n \t      }\n         }\n+\n       /* Update complete filename with stripped original. */\n       if (prefix_length != 0 && !IS_DIR_SEPARATOR (*fname))\n         {\n@@ -293,42 +364,6 @@ gcov_exit (void)\n       else\n         strcpy (gi_filename_up, fname);\n \n-      /* Totals for this object file.  */\n-      ci_ptr = gi_ptr->counts;\n-      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n-\t{\n-\t  if (!((1 << t_ix) & gi_ptr->ctr_mask))\n-\t    continue;\n-\n-\t  cs_ptr = &this_object.ctrs[t_ix];\n-\t  cs_ptr->num += ci_ptr->num;\n-\t  for (c_num = 0; c_num < ci_ptr->num; c_num++)\n-\t    {\n-\t      cs_ptr->sum_all += ci_ptr->values[c_num];\n-\t      if (cs_ptr->run_max < ci_ptr->values[c_num])\n-\t\tcs_ptr->run_max = ci_ptr->values[c_num];\n-\t    }\n-\n-\t  ci_ptr++;\n-\t}\n-\n-      c_ix = 0;\n-      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n-\tif ((1 << t_ix) & gi_ptr->ctr_mask)\n-\t  {\n-\t    values[c_ix] = gi_ptr->counts[c_ix].values;\n-\t    c_ix++;\n-\t  }\n-\n-      /* Calculate the function_info stride. This depends on the\n-\t number of counter types being measured.  */\n-      fi_stride = sizeof (struct gcov_fn_info) + c_ix * sizeof (unsigned);\n-      if (__alignof__ (struct gcov_fn_info) > sizeof (unsigned))\n-\t{\n-\t  fi_stride += __alignof__ (struct gcov_fn_info) - 1;\n-\t  fi_stride &= ~(__alignof__ (struct gcov_fn_info) - 1);\n-\t}\n-\n       if (!gcov_open (gi_filename))\n \t{\n \t  /* Open failed likely due to missed directory.\n@@ -364,83 +399,98 @@ gcov_exit (void)\n \t    /* Read from a different compilation. Overwrite the file.  */\n \t    goto rewrite;\n \n-\t  /* Merge execution counts for each function.  */\n-\t  for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)\n+\t  /* Look for program summary.  */\n+\t  for (f_ix = ~0u;;)\n \t    {\n-\t      fi_ptr = (const struct gcov_fn_info *)\n-\t\t      ((const char *) gi_ptr->functions + f_ix * fi_stride);\n+\t      struct gcov_summary tmp;\n+\t      \n+\t      eof_pos = gcov_position ();\n \t      tag = gcov_read_unsigned ();\n+\t      if (tag != GCOV_TAG_PROGRAM_SUMMARY)\n+\t\tbreak;\n+\n+\t      length = gcov_read_unsigned ();\n+\t      if (length != GCOV_TAG_SUMMARY_LENGTH)\n+\t\tgoto read_mismatch;\n+\t      gcov_read_summary (&tmp);\n+\t      if ((error = gcov_is_error ()))\n+\t\tgoto read_error;\n+\t      if (!summary_pos && tmp.checksum == gcov_crc32)\n+\t\t{\n+\t\t  prg = tmp;\n+\t\t  summary_pos = eof_pos;\n+\t\t}\n+\t    }\n+\t  \n+\t  /* Merge execution counts for each function.  */\n+\t  for (f_ix = 0; f_ix != gi_ptr->n_functions;\n+\t       f_ix++, tag = gcov_read_unsigned ())\n+\t    {\n+\t      gfi_ptr = gi_ptr->functions[f_ix];\n+\n+\t      if (tag != GCOV_TAG_FUNCTION)\n+\t\tgoto read_mismatch;\n \t      length = gcov_read_unsigned ();\n \n-\t      /* Check function.  */\n-\t      if (tag != GCOV_TAG_FUNCTION\n-\t          || length != GCOV_TAG_FUNCTION_LENGTH\n-\t\t  || gcov_read_unsigned () != fi_ptr->ident\n-\t\t  || gcov_read_unsigned () != fi_ptr->lineno_checksum\n-\t\t  || gcov_read_unsigned () != fi_ptr->cfg_checksum)\n+\t      if (!length)\n+\t\t/* This function did not appear in the other program.\n+\t\t   We have nothing to merge.  */\n+\t\tcontinue;\n+\n+\t      if (length != GCOV_TAG_FUNCTION_LENGTH)\n+\t\tgoto read_mismatch;\n+\t      \n+\t      if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n \t\t{\n-\t\tread_mismatch:;\n-\t\t  fprintf (stderr, \"profiling:%s:Merge mismatch for %s\\n\",\n-\t\t\t   gi_filename,\n-\t\t\t   f_ix + 1 ? \"function\" : \"summaries\");\n-\t\t  goto read_fatal;\n+\t\t  /* This function appears in the other program.  We\n+\t\t     need to buffer the information in order to write\n+\t\t     it back out -- we'll be inserting data before\n+\t\t     this point, so cannot simply keep the data in the\n+\t\t     file.  */\n+\t\t  fn_tail = buffer_fn_data (gi_ptr, fn_tail, f_ix);\n+\t\t  if (!fn_tail)\n+\t\t    goto read_mismatch;\n+\t\t  continue;\n \t\t}\n \n-\t      c_ix = 0;\n+\t      if (gcov_read_unsigned () != gfi_ptr->ident\n+\t\t  || gcov_read_unsigned () != gfi_ptr->lineno_checksum\n+\t\t  || gcov_read_unsigned () != gfi_ptr->cfg_checksum)\n+\t\tgoto read_mismatch;\n+\t      \n+\t      ci_ptr = gfi_ptr->ctrs;\n \t      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n \t\t{\n-\t\t  gcov_merge_fn merge;\n+\t\t  gcov_merge_fn merge = gi_ptr->merge[t_ix];\n \n-\t\t  if (!((1 << t_ix) & gi_ptr->ctr_mask))\n+\t\t  if (!merge)\n \t\t    continue;\n \n-\t\t  n_counts = fi_ptr->n_ctrs[c_ix];\n-\t\t  merge = gi_ptr->counts[c_ix].merge;\n-\n \t\t  tag = gcov_read_unsigned ();\n \t\t  length = gcov_read_unsigned ();\n \t\t  if (tag != GCOV_TAG_FOR_COUNTER (t_ix)\n-\t\t      || length != GCOV_TAG_COUNTER_LENGTH (n_counts))\n+\t\t      || length != GCOV_TAG_COUNTER_LENGTH (ci_ptr->num))\n \t\t    goto read_mismatch;\n-\t\t  (*merge) (values[c_ix], n_counts);\n-\t\t  values[c_ix] += n_counts;\n-\t\t  c_ix++;\n+\t\t  (*merge) (ci_ptr->values, ci_ptr->num);\n+\t\t  ci_ptr++;\n \t\t}\n \t      if ((error = gcov_is_error ()))\n \t\tgoto read_error;\n \t    }\n \n-\t  f_ix = ~0u;\n-\t  /* Check program & object summary */\n-\t  while (1)\n+\t  if (tag)\n \t    {\n-\t      int is_program;\n-\n-\t      eof_pos = gcov_position ();\n-\t      tag = gcov_read_unsigned ();\n-\t      if (!tag)\n-\t\tbreak;\n-\n-\t      length = gcov_read_unsigned ();\n-\t      is_program = tag == GCOV_TAG_PROGRAM_SUMMARY;\n-\t      if (length != GCOV_TAG_SUMMARY_LENGTH\n-\t\t  || (!is_program && tag != GCOV_TAG_OBJECT_SUMMARY))\n-\t\tgoto read_mismatch;\n-\t      gcov_read_summary (is_program ? &program : &object);\n-\t      if ((error = gcov_is_error ()))\n-\t\tgoto read_error;\n-\t      if (is_program && program.checksum == gcov_crc32)\n-\t\t{\n-\t\t  summary_pos = eof_pos;\n-\t\t  goto rewrite;\n-\t\t}\n+\t    read_mismatch:;\n+\t      fprintf (stderr, \"profiling:%s:Merge mismatch for %s\\n\",\n+\t\t       gi_filename, f_ix + 1 ? \"function\" : \"summaries\");\n+\t      goto read_fatal;\n \t    }\n \t}\n       goto rewrite;\n \n     read_error:;\n-      fprintf (stderr, error < 0 ? \"profiling:%s:Overflow merging\\n\"\n-\t       : \"profiling:%s:Error merging\\n\", gi_filename);\n+      fprintf (stderr, \"profiling:%s:%s merging\\n\", gi_filename,\n+\t       error < 0 ? \"Overflow\": \"Error\");\n \n     read_fatal:;\n       gcov_close ();\n@@ -449,29 +499,20 @@ gcov_exit (void)\n     rewrite:;\n       gcov_rewrite ();\n       if (!summary_pos)\n-\tmemset (&program, 0, sizeof (program));\n+\t{\n+\t  memset (&prg, 0, sizeof (prg));\n+\t  summary_pos = eof_pos;\n+\t}\n \n       /* Merge the summaries.  */\n-      f_ix = ~0u;\n       for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n \t{\n-\t  cs_obj = &object.ctrs[t_ix];\n-\t  cs_tobj = &this_object.ctrs[t_ix];\n-\t  cs_prg = &program.ctrs[t_ix];\n-\t  cs_tprg = &this_program.ctrs[t_ix];\n-\t  cs_all = &all.ctrs[t_ix];\n+\t  cs_prg = &prg.ctrs[t_ix];\n+\t  cs_tprg = &this_prg.ctrs[t_ix];\n+\t  cs_all = &all_prg.ctrs[t_ix];\n \n-\t  if ((1 << t_ix) & gi_ptr->ctr_mask)\n+\t  if (gi_ptr->merge[t_ix])\n \t    {\n-\t      if (!cs_obj->runs++)\n-\t\tcs_obj->num = cs_tobj->num;\n-\t      else if (cs_obj->num != cs_tobj->num)\n-\t\tgoto read_mismatch;\n-\t      cs_obj->sum_all += cs_tobj->sum_all;\n-\t      if (cs_obj->run_max < cs_tobj->run_max)\n-\t\tcs_obj->run_max = cs_tobj->run_max;\n-\t      cs_obj->sum_max += cs_tobj->run_max;\n-\n \t      if (!cs_prg->runs++)\n \t\tcs_prg->num = cs_tprg->num;\n \t      else if (cs_prg->num != cs_tprg->num)\n@@ -481,78 +522,94 @@ gcov_exit (void)\n \t\tcs_prg->run_max = cs_tprg->run_max;\n \t      cs_prg->sum_max += cs_tprg->run_max;\n \t    }\n-\t  else if (cs_obj->num || cs_prg->num)\n+\t  else if (cs_prg->runs)\n \t    goto read_mismatch;\n \n \t  if (!cs_all->runs && cs_prg->runs)\n \t    memcpy (cs_all, cs_prg, sizeof (*cs_all));\n-\t  else if (!all.checksum\n+\t  else if (!all_prg.checksum\n \t\t   && (!GCOV_LOCKED || cs_all->runs == cs_prg->runs)\n \t\t   && memcmp (cs_all, cs_prg, sizeof (*cs_all)))\n \t    {\n-\t      fprintf (stderr, \"profiling:%s:Invocation mismatch - some data files may have been removed%s\",\n+\t      fprintf (stderr, \"profiling:%s:Invocation mismatch - some data files may have been removed%s\\n\",\n \t\t       gi_filename, GCOV_LOCKED\n-\t\t       ? \"\" : \" or concurrent update without locking support\");\n-\t      all.checksum = ~0u;\n+\t\t       ? \"\" : \" or concurrently updated without locking support\");\n+\t      all_prg.checksum = ~0u;\n \t    }\n \t}\n \n-      c_ix = 0;\n-      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n-\tif ((1 << t_ix) & gi_ptr->ctr_mask)\n-\t  {\n-\t    values[c_ix] = gi_ptr->counts[c_ix].values;\n-\t    c_ix++;\n-\t  }\n-\n-      program.checksum = gcov_crc32;\n+      prg.checksum = gcov_crc32;\n \n       /* Write out the data.  */\n-      gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);\n-      gcov_write_unsigned (gi_ptr->stamp);\n+      if (!eof_pos)\n+\t{\n+\t  gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);\n+\t  gcov_write_unsigned (gi_ptr->stamp);\n+\t}\n+\n+      if (summary_pos)\n+\tgcov_seek (summary_pos);\n+\n+      /* Generate whole program statistics.  */\n+      gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &prg);\n+\n+      if (summary_pos < eof_pos)\n+\tgcov_seek (eof_pos);\n \n       /* Write execution counts for each function.  */\n       for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)\n \t{\n-\t  fi_ptr = (const struct gcov_fn_info *)\n-\t\t  ((const char *) gi_ptr->functions + f_ix * fi_stride);\n+\t  unsigned buffered = 0;\n \n-\t  /* Announce function.  */\n-\t  gcov_write_tag_length (GCOV_TAG_FUNCTION, GCOV_TAG_FUNCTION_LENGTH);\n-\t  gcov_write_unsigned (fi_ptr->ident);\n-\t  gcov_write_unsigned (fi_ptr->lineno_checksum);\n-\t  gcov_write_unsigned (fi_ptr->cfg_checksum);\n+\t  if (fn_buffer && fn_buffer->fn_ix == f_ix)\n+\t    {\n+\t      /* Buffered data from another program.  */\n+\t      buffered = 1;\n+\t      gfi_ptr = &fn_buffer->info;\n+\t      length = GCOV_TAG_FUNCTION_LENGTH;\n+\t    }\n+\t  else\n+\t    {\n+\t      gfi_ptr = gi_ptr->functions[f_ix];\n+\t      if (gfi_ptr && gfi_ptr->key == gi_ptr)\n+\t\tlength = GCOV_TAG_FUNCTION_LENGTH;\n+\t      else\n+\t\tlength = 0;\n+\t    }\n+\t  \n+\t  gcov_write_tag_length (GCOV_TAG_FUNCTION, length);\n+\t  if (!length)\n+\t    continue;\n+\t  \n+\t  gcov_write_unsigned (gfi_ptr->ident);\n+\t  gcov_write_unsigned (gfi_ptr->lineno_checksum);\n+\t  gcov_write_unsigned (gfi_ptr->cfg_checksum);\n \n-\t  c_ix = 0;\n+\t  ci_ptr = gfi_ptr->ctrs;\n \t  for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n \t    {\n-\t      gcov_type *c_ptr;\n-\n-\t      if (!((1 << t_ix) & gi_ptr->ctr_mask))\n+\t      if (!gi_ptr->merge[t_ix])\n \t\tcontinue;\n \n-\t      n_counts = fi_ptr->n_ctrs[c_ix];\n-\n+\t      n_counts = ci_ptr->num;\n \t      gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n \t\t\t\t     GCOV_TAG_COUNTER_LENGTH (n_counts));\n-\t      c_ptr = values[c_ix];\n+\t      gcov_type *c_ptr = ci_ptr->values;\n \t      while (n_counts--)\n \t\tgcov_write_counter (*c_ptr++);\n-\n-\t      values[c_ix] = c_ptr;\n-\t      c_ix++;\n+\t      if (buffered)\n+\t\tfree (ci_ptr->values);\n+\t      ci_ptr++;\n+\t    }\n+\t  if (buffered)\n+\t    {\n+\t      struct gcov_fn_buffer *tmp = fn_buffer;\n+\t      fn_buffer = fn_buffer->next;\n+\t      free (tmp);\n \t    }\n \t}\n \n-      /* Object file summary.  */\n-      gcov_write_summary (GCOV_TAG_OBJECT_SUMMARY, &object);\n-\n-      /* Generate whole program statistics.  */\n-      if (eof_pos)\n-\tgcov_seek (eof_pos);\n-      gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &program);\n-      if (!summary_pos)\n-\tgcov_write_unsigned (0);\n+      gcov_write_unsigned (0);\n       if ((error = gcov_close ()))\n \t  fprintf (stderr, error  < 0 ?\n \t\t   \"profiling:%s:Overflow writing\\n\" :\n@@ -618,15 +675,25 @@ __gcov_flush (void)\n   gcov_exit ();\n   for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n     {\n-      unsigned t_ix;\n-      const struct gcov_ctr_info *ci_ptr;\n+      unsigned f_ix;\n \n-      for (t_ix = 0, ci_ptr = gi_ptr->counts; t_ix != GCOV_COUNTERS; t_ix++)\n-\tif ((1 << t_ix) & gi_ptr->ctr_mask)\n-\t  {\n-\t    memset (ci_ptr->values, 0, sizeof (gcov_type) * ci_ptr->num);\n-\t    ci_ptr++;\n-\t  }\n+      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)\n+\t{\n+\t  unsigned t_ix;\n+\t  const struct gcov_fn_info *gfi_ptr = gi_ptr->functions[f_ix];\n+\n+\t  if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n+\t    continue;\n+\t  const struct gcov_ctr_info *ci_ptr = gfi_ptr->ctrs;\n+\t  for (t_ix = 0; t_ix != GCOV_COUNTERS; t_ix++)\n+\t    {\n+\t      if (!gi_ptr->merge[t_ix])\n+\t\tcontinue;\n+\t      \n+\t      memset (ci_ptr->values, 0, sizeof (gcov_type) * ci_ptr->num);\n+\t      ci_ptr++;\n+\t    }\n+\t}\n     }\n }\n "}]}