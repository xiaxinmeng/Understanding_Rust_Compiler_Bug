{"sha": "630d3fad23b067a707161db41e58f13406a0174a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMwZDNmYWQyM2IwNjdhNzA3MTYxZGI0MWU1OGYxMzQwNmEwMTc0YQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-05-26T10:30:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-05-26T10:30:31Z"}, "message": "re PR rtl-optimization/44164 (Aliasing bug triggered by Boost.Bind/Boost.Function)\n\n2010-05-26  Richard Guenther  <rguenther@suse.de>\n\n\tPR rtl-optimization/44164\n\t* tree-ssa-alias.c (aliasing_component_refs_p): Fix the\n\tno-common access-path disambiguation.\n\t(indirect_ref_may_alias_decl_p): Adjust.\n\t(indirect_refs_may_alias_p): Likewise.\n\t(refs_may_alias_p_1): Likewise.\n\n\t* gcc.c-torture/execute/pr44164.c: New testcase.\n\t* g++.dg/tree-ssa/pr13146.C: Adjust.\n\nFrom-SVN: r159861", "tree": {"sha": "e629cdd028a222d98c2cb8569146c330a61a9b68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e629cdd028a222d98c2cb8569146c330a61a9b68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/630d3fad23b067a707161db41e58f13406a0174a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630d3fad23b067a707161db41e58f13406a0174a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/630d3fad23b067a707161db41e58f13406a0174a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630d3fad23b067a707161db41e58f13406a0174a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9b6c0843114c581b7f203075d87357c23b8f88a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9b6c0843114c581b7f203075d87357c23b8f88a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9b6c0843114c581b7f203075d87357c23b8f88a"}], "stats": {"total": 94, "additions": 84, "deletions": 10}, "files": [{"sha": "7996315d1bd0ce840add9f59dd4582ee016f1b24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630d3fad23b067a707161db41e58f13406a0174a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630d3fad23b067a707161db41e58f13406a0174a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=630d3fad23b067a707161db41e58f13406a0174a", "patch": "@@ -1,3 +1,12 @@\n+2010-05-26  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR rtl-optimization/44164\n+\t* tree-ssa-alias.c (aliasing_component_refs_p): Fix the\n+\tno-common access-path disambiguation.\n+\t(indirect_ref_may_alias_decl_p): Adjust.\n+\t(indirect_refs_may_alias_p): Likewise.\n+\t(refs_may_alias_p_1): Likewise.\n+\n 2010-05-26  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* c-typeck.c: Do not include expr.h."}, {"sha": "a319f63060f1136751cd02a7c5f994da2990c645", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630d3fad23b067a707161db41e58f13406a0174a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630d3fad23b067a707161db41e58f13406a0174a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=630d3fad23b067a707161db41e58f13406a0174a", "patch": "@@ -1,3 +1,9 @@\n+2010-05-26  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR rtl-optimization/44164\n+\t* gcc.c-torture/execute/pr44164.c: New testcase.\n+\t* g++.dg/tree-ssa/pr13146.C: Adjust.\n+\n 2010-05-26  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/40011"}, {"sha": "22baf03d33b3edb7cbb65d13a37e7a8a47ac14c7", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr13146.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630d3fad23b067a707161db41e58f13406a0174a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr13146.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630d3fad23b067a707161db41e58f13406a0174a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr13146.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr13146.C?ref=630d3fad23b067a707161db41e58f13406a0174a", "patch": "@@ -30,7 +30,10 @@ class multi: public third, public second\n {\n public:\n   short s;\n-  char f3;\n+  /* The following field used to be of type char but that causes\n+     class multi to effectively get alias-set zero which we end\n+     up not optimizing because of the fix for PR44164.  */\n+  int f3;\n };\n \n extern void link_error ();"}, {"sha": "171f9c39f59760a98f2c81d8303a9791919cc3a1", "filename": "gcc/testsuite/gcc.c-torture/execute/pr44164.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630d3fad23b067a707161db41e58f13406a0174a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr44164.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630d3fad23b067a707161db41e58f13406a0174a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr44164.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr44164.c?ref=630d3fad23b067a707161db41e58f13406a0174a", "patch": "@@ -0,0 +1,24 @@\n+struct X {\n+    struct Y {\n+\tstruct YY {\n+\t    struct Z {\n+\t\tint i;\n+\t    } c;\n+\t} bb;\n+    } b;\n+} a;\n+int __attribute__((noinline, noclone))\n+foo (struct Z *p)\n+{\n+  int i = p->i;\n+  a.b = (struct Y){};\n+  return p->i + i;\n+}\n+extern void abort (void);\n+int main()\n+{\n+  a.b.bb.c.i = 1;\n+  if (foo (&a.b.bb.c) != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "10292f27a964f8262953adcfc908ea4ac3d5f76b", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630d3fad23b067a707161db41e58f13406a0174a/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630d3fad23b067a707161db41e58f13406a0174a/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=630d3fad23b067a707161db41e58f13406a0174a", "patch": "@@ -563,13 +563,21 @@ same_type_for_tbaa (tree type1, tree type2)\n \n /* Determine if the two component references REF1 and REF2 which are\n    based on access types TYPE1 and TYPE2 and of which at least one is based\n-   on an indirect reference may alias.  */\n+   on an indirect reference may alias.  REF2 is the only one that can\n+   be a decl in which case REF2_IS_DECL is true.\n+   REF1_ALIAS_SET, BASE1_ALIAS_SET, REF2_ALIAS_SET and BASE2_ALIAS_SET\n+   are the respective alias sets.  */\n \n static bool\n aliasing_component_refs_p (tree ref1, tree type1,\n+\t\t\t   alias_set_type ref1_alias_set,\n+\t\t\t   alias_set_type base1_alias_set,\n \t\t\t   HOST_WIDE_INT offset1, HOST_WIDE_INT max_size1,\n \t\t\t   tree ref2, tree type2,\n-\t\t\t   HOST_WIDE_INT offset2, HOST_WIDE_INT max_size2)\n+\t\t\t   alias_set_type ref2_alias_set,\n+\t\t\t   alias_set_type base2_alias_set,\n+\t\t\t   HOST_WIDE_INT offset2, HOST_WIDE_INT max_size2,\n+\t\t\t   bool ref2_is_decl)\n {\n   /* If one reference is a component references through pointers try to find a\n      common base and apply offset based disambiguation.  This handles\n@@ -613,8 +621,20 @@ aliasing_component_refs_p (tree ref1, tree type1,\n       offset1 -= offadj;\n       return ranges_overlap_p (offset1, max_size1, offset2, max_size2);\n     }\n+\n   /* If we have two type access paths B1.path1 and B2.path2 they may\n-     only alias if either B1 is in B2.path2 or B2 is in B1.path1.  */\n+     only alias if either B1 is in B2.path2 or B2 is in B1.path1.\n+     But we can still have a path that goes B1.path1...B2.path2 with\n+     a part that we do not see.  So we can only disambiguate now\n+     if there is no B2 in the tail of path1 and no B1 on the\n+     tail of path2.  */\n+  if (base1_alias_set == ref2_alias_set\n+      || alias_set_subset_of (base1_alias_set, ref2_alias_set))\n+    return true;\n+  /* If this is ptr vs. decl then we know there is no ptr ... decl path.  */\n+  if (!ref2_is_decl)\n+    return (base2_alias_set == ref1_alias_set\n+\t    || alias_set_subset_of (base2_alias_set, ref1_alias_set));\n   return false;\n }\n \n@@ -649,9 +669,11 @@ decl_refs_may_alias_p (tree base1,\n static bool\n indirect_ref_may_alias_decl_p (tree ref1, tree ptr1,\n \t\t\t       HOST_WIDE_INT offset1, HOST_WIDE_INT max_size1,\n+\t\t\t       alias_set_type ref1_alias_set,\n \t\t\t       alias_set_type base1_alias_set,\n \t\t\t       tree ref2, tree base2,\n \t\t\t       HOST_WIDE_INT offset2, HOST_WIDE_INT max_size2,\n+\t\t\t       alias_set_type ref2_alias_set,\n \t\t\t       alias_set_type base2_alias_set)\n {\n   /* If only one reference is based on a variable, they cannot alias if\n@@ -695,9 +717,11 @@ indirect_ref_may_alias_decl_p (tree ref1, tree ptr1,\n       && handled_component_p (ref1)\n       && handled_component_p (ref2))\n     return aliasing_component_refs_p (ref1, TREE_TYPE (TREE_TYPE (ptr1)),\n+\t\t\t\t      ref1_alias_set, base1_alias_set,\n \t\t\t\t      offset1, max_size1,\n \t\t\t\t      ref2, TREE_TYPE (base2),\n-\t\t\t\t      offset2, max_size2);\n+\t\t\t\t      ref2_alias_set, base2_alias_set,\n+\t\t\t\t      offset2, max_size2, true);\n \n   return true;\n }\n@@ -712,9 +736,11 @@ indirect_ref_may_alias_decl_p (tree ref1, tree ptr1,\n static bool\n indirect_refs_may_alias_p (tree ref1, tree ptr1,\n \t\t\t   HOST_WIDE_INT offset1, HOST_WIDE_INT max_size1,\n+\t\t\t   alias_set_type ref1_alias_set,\n \t\t\t   alias_set_type base1_alias_set,\n \t\t\t   tree ref2, tree ptr2,\n \t\t\t   HOST_WIDE_INT offset2, HOST_WIDE_INT max_size2,\n+\t\t\t   alias_set_type ref2_alias_set,\n \t\t\t   alias_set_type base2_alias_set)\n {\n   /* If both bases are based on pointers they cannot alias if they may not\n@@ -756,9 +782,11 @@ indirect_refs_may_alias_p (tree ref1, tree ptr1,\n       && handled_component_p (ref1)\n       && handled_component_p (ref2))\n     return aliasing_component_refs_p (ref1, TREE_TYPE (TREE_TYPE (ptr1)),\n+\t\t\t\t      ref1_alias_set, base1_alias_set,\n \t\t\t\t      offset1, max_size1,\n \t\t\t\t      ref2, TREE_TYPE (TREE_TYPE (ptr2)),\n-\t\t\t\t      offset2, max_size2);\n+\t\t\t\t      ref2_alias_set, base2_alias_set,\n+\t\t\t\t      offset2, max_size2, false);\n \n   return true;\n }\n@@ -911,14 +939,18 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n   set = tbaa_p ? -1 : 0;\n   if (var1_p && ind2_p)\n     return indirect_ref_may_alias_decl_p (ref2->ref, TREE_OPERAND (base2, 0),\n-\t\t\t\t\t  offset2, max_size2, set,\n+\t\t\t\t\t  offset2, max_size2,\n+\t\t\t\t\t  ao_ref_alias_set (ref2), set,\n \t\t\t\t\t  ref1->ref, base1,\n-\t\t\t\t\t  offset1, max_size1, set);\n+\t\t\t\t\t  offset1, max_size1,\n+\t\t\t\t\t  ao_ref_alias_set (ref1), set);\n   else if (ind1_p && ind2_p)\n     return indirect_refs_may_alias_p (ref1->ref, TREE_OPERAND (base1, 0),\n-\t\t\t\t      offset1, max_size1, set,\n+\t\t\t\t      offset1, max_size1,\n+\t\t\t\t      ao_ref_alias_set (ref1), set,\n \t\t\t\t      ref2->ref, TREE_OPERAND (base2, 0),\n-\t\t\t\t      offset2, max_size2, set);\n+\t\t\t\t      offset2, max_size2,\n+\t\t\t\t      ao_ref_alias_set (ref2), set);\n \n   gcc_unreachable ();\n }"}]}