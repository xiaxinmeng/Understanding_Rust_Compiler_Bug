{"sha": "b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ5ZDIzZjNlMjM4YzA4YmRiYzViODkyYjJlZDBhNTdiNWY1Y2FmOQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-06T05:07:35Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-06T05:07:35Z"}, "message": "c++: adc_unify deduction with constrained auto [PR99365]\n\nMy recent r11-7454 changed the way do_auto_deduction handles constrained\nplaceholders during template argument deduction (context == adc_unify)\nwhen processing_template_decl != 0.  Before the patch, we would just\nignore the constraints on the placeholder, and return the deduced type.\nAfter the patch, we now punt and return the original placeholder type\n\nWhile this change fixed instances where we'd prematurely resolve a\nconstrained placeholder return or variable type with non-dependent\ninitializer at template parse time (such as PR96444), it broke the\nadc_unify callers that rely on the previous behavior.\n\nThis patch restores the previous behavior during adc_unify deduction\nwhile retaining the new behavior only during adc_variable_type or\nadc_return_type deduction.\n\nWe additionally now need to pass the outer template arguments to\ndo_auto_deduction during unify, for sake of constraint checking.\nBut we want to avoid substituting these outer arguments into type\nwhen the caller has already done so, so this patch adds a\nTEMPLATE_TYPE_LEVEL check to do_auto_deduction to that effect.\n\nThis above is enough to fix partial specialization of non-nested\ntemplates with constrained 'auto' template parameters, but it doesn't\nfix the nested template case, ultimately because\nmost_specialized_partial_spec passes only the innermost template\narguments to get_partial_spec_bindings, and so outer_targs during\ndo_auto_deduction (called from unify) contains only the innermost\ntemplate arguments, and this breaks satisfaction.  Fixing this properly\nis perhaps too risky at this stage, so this patch adds a hack to\ndo_auto_deduction to compensate for callers that don't supply all outer\ntemplate arguments.  The goal of this hack is to ensure placeholder type\nconstraint checking continues to work whenever it worked before\nr11-7454, namely whenever the constraint is non-dependent.\n\nFinally, this patch allows do_auto_deduction to resolve a constrained\nplaceholder type ahead of time (at template parse time), as long as the\nconstraint is non-dependent.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/99365\n\t* pt.c (unify) <case TEMPLATE_TYPE_PARM>: Pass targs as\n\touter_targs to do_auto_deduction.\n\t(placeholder_type_constraint_dependent_p): Define.\n\t(do_auto_deduction): When processing_template_decl != 0\n\tand context is adc_unify and we have constraints, pretend the\n\tconstraints are satisfied instead of punting.  Otherwise don't\n\tpunt unless placeholder_type_constraint_dependent_p holds.\n\tAdd some clarifying sanity checks.  Add a hack to add missing\n\toutermost template levels to outer_args before checking\n\tsatisfaction.  Don't substitute outer_targs into type if it's\n\talready been done.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/99365\n\t* g++.dg/cpp2a/concepts-partial-spec9.C: New test.\n\t* g++.dg/cpp2a/concepts-placeholder4.C: New test.", "tree": {"sha": "39b2214af8c06e99bf30a142017be583af2fc682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39b2214af8c06e99bf30a142017be583af2fc682"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9/comments", "author": null, "committer": null, "parents": [{"sha": "7723f569345ae82ba440552251a84e65c2a9dcb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7723f569345ae82ba440552251a84e65c2a9dcb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7723f569345ae82ba440552251a84e65c2a9dcb5"}], "stats": {"total": 180, "additions": 136, "deletions": 44}, "files": [{"sha": "7794137a359d9e1fd9df7a65f1b6ca763e772208", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 89, "deletions": 44, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9", "patch": "@@ -23683,7 +23683,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \n \t  if (tree a = type_uses_auto (tparm))\n \t    {\n-\t      tparm = do_auto_deduction (tparm, arg, a, complain, adc_unify);\n+\t      tparm = do_auto_deduction (tparm, arg, a,\n+\t\t\t\t\t complain, adc_unify, targs);\n \t      if (tparm == error_mark_node)\n \t\treturn 1;\n \t    }\n@@ -28206,6 +28207,23 @@ make_constrained_decltype_auto (tree con, tree args)\n   return make_constrained_placeholder_type (type, con, args);\n }\n \n+/* Returns true if the placeholder type constraint T has any dependent\n+   (explicit) template arguments.  */\n+\n+static bool\n+placeholder_type_constraint_dependent_p (tree t)\n+{\n+  tree id = unpack_concept_check (t);\n+  tree args = TREE_OPERAND (id, 1);\n+  tree first = TREE_VEC_ELT (args, 0);\n+  gcc_checking_assert (TREE_CODE (first) == WILDCARD_DECL\n+\t\t       || is_auto (first));\n+  for (int i = 1; i < TREE_VEC_LENGTH (args); ++i)\n+    if (dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n+      return true;\n+  return false;\n+}\n+\n /* Build and return a concept definition. Like other templates, the\n    CONCEPT_DECL node is wrapped by a TEMPLATE_DECL.  This returns the\n    the TEMPLATE_DECL. */\n@@ -29614,52 +29632,79 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n     }\n \n   /* Check any placeholder constraints against the deduced type. */\n-  if (flag_concepts)\n-    if (NON_ERROR (PLACEHOLDER_TYPE_CONSTRAINTS (auto_node)))\n-      {\n-\tif (processing_template_decl)\n-\t  /* In general we can't check satisfaction until we know all\n-\t     template arguments.  */\n-\t  return type;\n+  if (processing_template_decl && context == adc_unify)\n+    /* Constraints will be checked after deduction.  */;\n+  else if (tree constr = NON_ERROR (PLACEHOLDER_TYPE_CONSTRAINTS (auto_node)))\n+    {\n+      if (processing_template_decl)\n+\t{\n+\t  gcc_checking_assert (context == adc_variable_type\n+\t\t\t       || context == adc_return_type);\n+\t  gcc_checking_assert (!type_dependent_expression_p (init));\n+\t  /* If the constraint is dependent, we need to wait until\n+\t     instantiation time to resolve the placeholder.  */\n+\t  if (placeholder_type_constraint_dependent_p (constr))\n+\t    return type;\n+\t}\n \n-\tif ((context == adc_return_type || context == adc_variable_type)\n-\t    && current_function_decl\n-\t    && DECL_TEMPLATE_INFO (current_function_decl))\n-\t  outer_targs = DECL_TI_ARGS (current_function_decl);\n+      if ((context == adc_return_type || context == adc_variable_type)\n+\t  && current_function_decl\n+\t  && DECL_TEMPLATE_INFO (current_function_decl))\n+\touter_targs = DECL_TI_ARGS (current_function_decl);\n \n-\ttree full_targs = add_to_template_args (outer_targs, targs);\n-\tif (!constraints_satisfied_p (auto_node, full_targs))\n-          {\n-            if (complain & tf_warning_or_error)\n-              {\n-\t\tauto_diagnostic_group d;\n-                switch (context)\n-                  {\n-                  case adc_unspecified:\n-\t\t  case adc_unify:\n-                    error(\"placeholder constraints not satisfied\");\n-                    break;\n-                  case adc_variable_type:\n-\t\t  case adc_decomp_type:\n-                    error (\"deduced initializer does not satisfy \"\n-                           \"placeholder constraints\");\n-                    break;\n-                  case adc_return_type:\n-                    error (\"deduced return type does not satisfy \"\n-                           \"placeholder constraints\");\n-                    break;\n-                  case adc_requirement:\n-\t\t    error (\"deduced expression type does not satisfy \"\n-                           \"placeholder constraints\");\n-                    break;\n-                  }\n-\t\tdiagnose_constraints (input_location, auto_node, full_targs);\n-              }\n-            return error_mark_node;\n-          }\n-      }\n+      tree full_targs = add_to_template_args (outer_targs, targs);\n+\n+      /* HACK: Compensate for callers not always communicating all levels of\n+\t outer template arguments by filling in the outermost missing levels\n+\t with dummy levels before checking satisfaction.  We'll still crash\n+\t if the constraint depends on a template argument belonging to one of\n+\t these missing levels, but this hack otherwise allows us to handle a\n+\t large subset of possible constraints (including all non-dependent\n+\t constraints).  */\n+      if (int missing_levels = (TEMPLATE_TYPE_ORIG_LEVEL (auto_node)\n+\t\t\t\t- TMPL_ARGS_DEPTH (full_targs)))\n+\t{\n+\t  tree dummy_levels = make_tree_vec (missing_levels);\n+\t  for (int i = 0; i < missing_levels; ++i)\n+\t    TREE_VEC_ELT (dummy_levels, i) = make_tree_vec (0);\n+\t  full_targs = add_to_template_args (dummy_levels, full_targs);\n+\t}\n+\n+      if (!constraints_satisfied_p (auto_node, full_targs))\n+\t{\n+\t  if (complain & tf_warning_or_error)\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      switch (context)\n+\t\t{\n+\t\tcase adc_unspecified:\n+\t\tcase adc_unify:\n+\t\t  error(\"placeholder constraints not satisfied\");\n+\t\t  break;\n+\t\tcase adc_variable_type:\n+\t\tcase adc_decomp_type:\n+\t\t  error (\"deduced initializer does not satisfy \"\n+\t\t\t \"placeholder constraints\");\n+\t\t  break;\n+\t\tcase adc_return_type:\n+\t\t  error (\"deduced return type does not satisfy \"\n+\t\t\t \"placeholder constraints\");\n+\t\t  break;\n+\t\tcase adc_requirement:\n+\t\t  error (\"deduced expression type does not satisfy \"\n+\t\t\t \"placeholder constraints\");\n+\t\t  break;\n+\t\t}\n+\t      diagnose_constraints (input_location, auto_node, full_targs);\n+\t    }\n+\t  return error_mark_node;\n+\t}\n+    }\n \n-  if (context == adc_unify)\n+  if (TEMPLATE_TYPE_LEVEL (auto_node) == 1)\n+    /* The outer template arguments are already substituted into type\n+       (but we still may have used them for constraint checking above).  */;\n+  else if (context == adc_unify)\n     targs = add_to_template_args (outer_targs, targs);\n   else if (processing_template_decl)\n     targs = add_to_template_args (current_template_args (), targs);"}, {"sha": "3dae24d915ab7b9d63f73857117f42927c3bba09", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-partial-spec9.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec9.C?ref=b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/99365\n+// { dg-do compile { target c++20 } }\n+\n+template <class> concept C = true;\n+template <class T, class U> concept D = C<T> && __is_same(T, U);\n+\n+template <class, C auto> struct A { static const int i = 0; };\n+template <class T, D<T> auto V> struct A<T, V> { static const int i = 1; };\n+\n+static_assert(A<int, 0>::i == 1);\n+static_assert(A<char, 0>::i == 0);\n+static_assert(A<int, '0'>::i == 0);\n+static_assert(A<char, '0'>::i == 1);\n+\n+template <class> struct O {\n+  template <class, C auto> struct A { static const int i = 0; };\n+  template <class T, D<T> auto V> struct A<T, V> { static const int i = 1; };\n+};\n+\n+static_assert(O<void>::A<int, 0>::i == 1);\n+static_assert(O<void>::A<char, 0>::i == 0);\n+static_assert(O<void>::A<int, '0'>::i == 0);\n+static_assert(O<void>::A<char, '0'>::i == 1);"}, {"sha": "9f39d45284016404d605a1bf7815d744dc0b3dcc", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-placeholder4.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder4.C?ref=b49d23f3e238c08bdbc5b892b2ed0a57b5f5caf9", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile { target c++20 } }\n+\n+template <class T, class U> concept same_as = __is_same(T, U);\n+\n+// this constrained placeholder type should get resolved at parse time\n+template <class T> same_as<bool> auto x = true;\n+\n+template <auto V> same_as<int> auto y = V; // { dg-error \"constraint\" }\n+\n+template <class>\n+struct A {\n+  template <auto V> static inline same_as<int> auto z = V; // { dg-error \"constraint\" }\n+};\n+\n+int main() {\n+  x<int>;          // { dg-bogus \"\" }\n+  y<0>;            // { dg-bogus \"\" }\n+  y<'0'>;          // { dg-message \"required from here\" }\n+  A<void>::z<0>;   // { dg-bogus \"\" }\n+  A<void>::z<'0'>; // { dg-message \"required from here\" }\n+}\n+\n+// unsatisfied placeholder type constraint diagnosed at parse time\n+template <class T> same_as<int> auto w = true; // { dg-error \"constraint\" }"}]}