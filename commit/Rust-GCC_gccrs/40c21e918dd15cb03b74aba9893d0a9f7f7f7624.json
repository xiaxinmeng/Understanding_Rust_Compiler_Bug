{"sha": "40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBjMjFlOTE4ZGQxNWNiMDNiNzRhYmE5ODkzZDBhOWY3ZjdmNzYyNA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-12-05T12:45:35Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-12-05T12:45:35Z"}, "message": "sem_util.adb (Contains_Refined_State): Remove.\n\ngcc/ada/\n\n2017-12-05  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* sem_util.adb (Contains_Refined_State): Remove.\n\n2017-12-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications, case Predicate): A\n\tpredicate cannot apply to a formal type.\n\n2017-12-05  Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_unst.ads: Fix typos.\n\n2017-12-05  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* libgnarl/s-taprop__qnx.adb: Better detect priority ceiling bug in\n\tQNX.  At startup, the first mutex created has a non-zero ceiling\n\tpriority whatever its actual policy. This makes some tests fail\n\t(c940013 for example).\n\n2017-12-05  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch11.adb (Expand_N_Handled_Sequence_Of_Statements): Call\n\tExpand_Cleanup_Actions for N_Extended_Return_Statement.\n\t* exp_ch7.adb (Expand_Cleanup_Actions): Handle\n\tN_Extended_Return_Statement by transforming the statements into a\n\tblock, and (indirectly) calling Expand_Cleanup_Actions on the block.\n\tIt's too hard for Expand_Cleanup_Actions to operate directly on the\n\tN_Extended_Return_Statement, because it has a different structure than\n\tthe other node kinds that Expand_Cleanup_Actions.\n\t* exp_util.adb (Requires_Cleanup_Actions): Add support for\n\tN_Extended_Return_Statement.  Change \"when others => return False;\" to\n\t\"when others => raise ...;\" so it's clear what nodes this function\n\thandles.  Use named notation where appropriate.\n\t* exp_util.ads: Mark incorrect comment with ???.\n\n2017-12-05  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch9.adb (Install_Private_Data_Declarations): Add missing\n\tDebug_Info_Needed decoration of internally generated discriminal\n\trenaming declaration.\n\n2017-12-05  Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_unst.adb (Unnest_Subprogram): Add handling of 'Access on\n\tnested subprograms.\n\n2017-12-05  Sergey Rybin  <rybin@adacore.com>\n\n\t* doc/gnat_ugn/gnat_utility_programs.rst: Add description of '--ignore'\n\toption for gnatmetric, gnatpp, gnat2xml, and gnattest.\n\n2017-12-05  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* sem_util.adb (Contains_Refined_State): Remove.\n\n2017-12-05  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* rtsfind.ads: Add new enumeration literals: RE_Clock_Time (for\n\tAda.Real_Time.Clock_Time) and RO_CA_Clock_Time (for\n\tAda.Calendar.Clock_Time).\n\n2017-12-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Is_Private_Overriding): If the candidate private\n\tsubprogram is overloaded, scan the list of homonyms in the same\n\tscope, to find the inherited operation that may be overridden\n\tby the candidate.\n\t* exp_ch11.adb, exp_ch7.adb: Minor reformatting.\n\n2017-12-05  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): If the\n\tInit_Assignment is rewritten, we need to set Assignment_OK on the new\n\tnode.  Otherwise, we will get spurious errors when initializing via\n\tassignment statement.\n\ngcc/testsuite/\n\n2017-12-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* gnat.dg/private_overriding.adb: New testcase.\n\nFrom-SVN: r255414", "tree": {"sha": "d7b6988c125ecff465230975f6b54d0a5933b820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7b6988c125ecff465230975f6b54d0a5933b820"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/comments", "author": null, "committer": null, "parents": [{"sha": "b91f986b2d9cd7c80dea854258a9f078d61345a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b91f986b2d9cd7c80dea854258a9f078d61345a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b91f986b2d9cd7c80dea854258a9f078d61345a9"}], "stats": {"total": 645, "additions": 376, "deletions": 269}, "files": [{"sha": "2619b162c3a1a4763d46b8a937ce692962ea64ff", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -1,3 +1,80 @@\n+2017-12-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_util.adb (Contains_Refined_State): Remove.\n+\n+2017-12-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications, case Predicate): A\n+\tpredicate cannot apply to a formal type.\n+\n+2017-12-05  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_unst.ads: Fix typos.\n+\n+2017-12-05  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* libgnarl/s-taprop__qnx.adb: Better detect priority ceiling bug in\n+\tQNX.  At startup, the first mutex created has a non-zero ceiling\n+\tpriority whatever its actual policy. This makes some tests fail\n+\t(c940013 for example).\n+\n+2017-12-05  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch11.adb (Expand_N_Handled_Sequence_Of_Statements): Call\n+\tExpand_Cleanup_Actions for N_Extended_Return_Statement.\n+\t* exp_ch7.adb (Expand_Cleanup_Actions): Handle\n+\tN_Extended_Return_Statement by transforming the statements into a\n+\tblock, and (indirectly) calling Expand_Cleanup_Actions on the block.\n+\tIt's too hard for Expand_Cleanup_Actions to operate directly on the\n+\tN_Extended_Return_Statement, because it has a different structure than\n+\tthe other node kinds that Expand_Cleanup_Actions.\n+\t* exp_util.adb (Requires_Cleanup_Actions): Add support for\n+\tN_Extended_Return_Statement.  Change \"when others => return False;\" to\n+\t\"when others => raise ...;\" so it's clear what nodes this function\n+\thandles.  Use named notation where appropriate.\n+\t* exp_util.ads: Mark incorrect comment with ???.\n+\n+2017-12-05  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch9.adb (Install_Private_Data_Declarations): Add missing\n+\tDebug_Info_Needed decoration of internally generated discriminal\n+\trenaming declaration.\n+\n+2017-12-05  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_unst.adb (Unnest_Subprogram): Add handling of 'Access on\n+\tnested subprograms.\n+\n+2017-12-05  Sergey Rybin  <rybin@adacore.com>\n+\n+\t* doc/gnat_ugn/gnat_utility_programs.rst: Add description of '--ignore'\n+\toption for gnatmetric, gnatpp, gnat2xml, and gnattest.\n+\n+2017-12-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_util.adb (Contains_Refined_State): Remove.\n+\n+2017-12-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* rtsfind.ads: Add new enumeration literals: RE_Clock_Time (for\n+\tAda.Real_Time.Clock_Time) and RO_CA_Clock_Time (for\n+\tAda.Calendar.Clock_Time).\n+\n+2017-12-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Is_Private_Overriding): If the candidate private\n+\tsubprogram is overloaded, scan the list of homonyms in the same\n+\tscope, to find the inherited operation that may be overridden\n+\tby the candidate.\n+\t* exp_ch11.adb, exp_ch7.adb: Minor reformatting.\n+\n+2017-12-05  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): If the\n+\tInit_Assignment is rewritten, we need to set Assignment_OK on the new\n+\tnode.  Otherwise, we will get spurious errors when initializing via\n+\tassignment statement.\n+\n 2017-12-05  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_elab.adb: Update the terminology and switch sections."}, {"sha": "912356a5b4ed7e6dedb5d3120299cc1e2036f90a", "filename": "gcc/ada/doc/gnat_ugn/gnat_utility_programs.rst", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -1400,6 +1400,11 @@ Alternatively, you may run the script using the following command line:\n          Each nonempty line should contain the name of an existing file.\n          Several such switches may be specified simultaneously.\n \n+     :switch:`--ignore={filename}`\n+        Do not process the sources listed in a specified file. This option cannot\n+        be used in incremental mode.\n+\n+\n      :switch:`-q`\n          Quiet\n \n@@ -2753,6 +2758,12 @@ Alternatively, you may run the script using the following command line:\n     Several such switches may be specified simultaneously.\n \n \n+  .. index:: --ignore (gnatmetric)\n+\n+  :switch:`--ignore={filename}`\n+    Do not process the sources listed in a specified file.\n+\n+\n   .. index:: -j (gnatmetric)\n \n   :switch:`-j{n}`\n@@ -3466,6 +3477,13 @@ Alternatively, you may run the script using the following command line:\n      Several such switches may be specified simultaneously.\n \n \n+  .. index:: --ignore (gnatpp)\n+\n+  :switch:`--ignore={filename}`\n+    Do not process the sources listed in a specified file. This option cannot\n+    be used in incremental mode.\n+\n+\n    .. index:: -j (gnatpp)\n \n    :switch:`-j{n}`\n@@ -4294,6 +4312,11 @@ Alternatively, you may run the script using the following command line:\n     Each nonempty line should contain the name of an existing file.\n     Several such switches may be specified simultaneously.\n \n+    .. index:: --ignore (gnattest)\n+\n+  :switch:`--ignore={filename}`\n+    Do not process the sources listed in a specified file.\n+\n     .. index:: --RTS (gnattest)\n \n   :switch:`--RTS={rts-path}`"}, {"sha": "666e380224caeafabd47aecce44a3b572e192f69", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -1419,19 +1419,28 @@ package body Exp_Ch11 is\n          return;\n       end if;\n \n-      --  Add clean up actions if required\n+      --  Add cleanup actions if required. No cleanup actions are needed in\n+      --  thunks associated with interfaces, because they only displace the\n+      --  pointer to the object. For extended return statements, we need\n+      --  cleanup actions if the Handled_Statement_Sequence contains generated\n+      --  objects of controlled types, for example. We do not want to clean up\n+      --  the return object.\n \n       if not Nkind_In (Parent (N), N_Accept_Statement,\n                                    N_Extended_Return_Statement,\n                                    N_Package_Body)\n         and then not Delay_Cleanups (Current_Scope)\n-\n-        --  No cleanup action needed in thunks associated with interfaces\n-        --  because they only displace the pointer to the object.\n-\n         and then not Is_Thunk (Current_Scope)\n       then\n          Expand_Cleanup_Actions (Parent (N));\n+\n+      elsif Nkind (Parent (N)) = N_Extended_Return_Statement\n+        and then Handled_Statement_Sequence (Parent (N)) = N\n+        and then not Delay_Cleanups (Current_Scope)\n+      then\n+         pragma Assert (not Is_Thunk (Current_Scope));\n+         Expand_Cleanup_Actions (Parent (N));\n+\n       else\n          Set_First_Real_Statement (N, First (Statements (N)));\n       end if;"}, {"sha": "43731c802392a42e56f7962eb7034e32b908f231", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -5370,6 +5370,10 @@ package body Exp_Ch6 is\n                         Rewrite (Name (Init_Assignment),\n                           Make_Explicit_Dereference (Loc,\n                             Prefix => New_Occurrence_Of (Alloc_Obj_Id, Loc)));\n+                        pragma Assert\n+                          (Assignment_OK\n+                             (Original_Node (Name (Init_Assignment))));\n+                        Set_Assignment_OK (Name (Init_Assignment));\n \n                         Set_Etype (Name (Init_Assignment), Etype (Ret_Obj_Id));\n \n@@ -7310,7 +7314,7 @@ package body Exp_Ch6 is\n             begin\n                --  ???For now, enable build-in-place for a very narrow set of\n                --  controlled types. Change \"if True\" to \"if False\" to\n-               --  experiment more controlled types. Eventually, we would\n+               --  experiment with more controlled types. Eventually, we might\n                --  like to enable build-in-place for all tagged types, all\n                --  types that need finalization, and all caller-unknown-size\n                --  types."}, {"sha": "11278751670126f67bbccb8efc5c5c96c748f967", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 78, "deletions": 27, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -310,7 +310,7 @@ package body Exp_Ch7 is\n    function Build_Cleanup_Statements\n      (N                  : Node_Id;\n       Additional_Cleanup : List_Id) return List_Id;\n-   --  Create the clean up calls for an asynchronous call block, task master,\n+   --  Create the cleanup calls for an asynchronous call block, task master,\n    --  protected subprogram body, task allocation block or task body, or\n    --  additional cleanup actions parked on a transient block. If the context\n    --  does not contain the above constructs, the routine returns an empty\n@@ -479,7 +479,7 @@ package body Exp_Ch7 is\n          return False;\n \n       --  Do not consider C and C++ types since it is assumed that the non-Ada\n-      --  side will handle their clean up.\n+      --  side will handle their cleanup.\n \n       elsif Convention (Desig_Typ) = Convention_C\n         or else Convention (Desig_Typ) = Convention_CPP\n@@ -1554,8 +1554,8 @@ package body Exp_Ch7 is\n             Jump_Alts := New_List;\n          end if;\n \n-         --  If the context requires additional clean up, the finalization\n-         --  machinery is added after the clean up code.\n+         --  If the context requires additional cleanup, the finalization\n+         --  machinery is added after the cleanup code.\n \n          if Acts_As_Clean then\n             Finalizer_Stmts       := Clean_Stmts;\n@@ -1784,7 +1784,7 @@ package body Exp_Ch7 is\n          end if;\n \n          --  Protect the statements with abort defer/undefer. This is only when\n-         --  aborts are allowed and the clean up statements require deferral or\n+         --  aborts are allowed and the cleanup statements require deferral or\n          --  there are controlled objects to be finalized. Note that the abort\n          --  defer/undefer pair does not require an extra block because each\n          --  finalization exception is caught in its corresponding finalization\n@@ -1800,7 +1800,7 @@ package body Exp_Ch7 is\n \n          --  The local exception does not need to be reraised for library-level\n          --  finalizers. Note that this action must be carried out after object\n-         --  clean up, secondary stack release and abort undeferral. Generate:\n+         --  cleanup, secondary stack release, and abort undeferral. Generate:\n \n          --    if Raised and then not Abort then\n          --       Raise_From_Controlled_Operation (E);\n@@ -1907,7 +1907,7 @@ package body Exp_Ch7 is\n             Append_To (Spec_Decls, Fin_Spec);\n             Analyze (Fin_Spec);\n \n-            --  When the finalizer acts solely as a clean up routine, the body\n+            --  When the finalizer acts solely as a cleanup routine, the body\n             --  is inserted right after the spec.\n \n             if Acts_As_Clean and not Has_Ctrl_Objs then\n@@ -4200,13 +4200,22 @@ package body Exp_Ch7 is\n    ----------------------------\n \n    procedure Expand_Cleanup_Actions (N : Node_Id) is\n+      pragma Assert\n+        (Nkind_In (N,\n+                   N_Extended_Return_Statement,\n+                   N_Block_Statement,\n+                   N_Subprogram_Body,\n+                   N_Task_Body,\n+                   N_Entry_Body));\n+\n       Scop : constant Entity_Id := Current_Scope;\n \n       Is_Asynchronous_Call   : constant Boolean :=\n                                  Nkind (N) = N_Block_Statement\n                                    and then Is_Asynchronous_Call_Block (N);\n       Is_Master              : constant Boolean :=\n-                                 Nkind (N) /= N_Entry_Body\n+                                 Nkind (N) /= N_Extended_Return_Statement\n+                                   and then Nkind (N) /= N_Entry_Body\n                                    and then Is_Task_Master (N);\n       Is_Protected_Subp_Body : constant Boolean :=\n                                  Nkind (N) = N_Subprogram_Body\n@@ -4301,6 +4310,62 @@ package body Exp_Ch7 is\n          return;\n       end if;\n \n+      --  If we are generating expanded code for debugging purposes, use the\n+      --  Sloc of the point of insertion for the cleanup code. The Sloc will be\n+      --  updated subsequently to reference the proper line in .dg files. If we\n+      --  are not debugging generated code, use No_Location instead, so that\n+      --  no debug information is generated for the cleanup code. This makes\n+      --  the behavior of the NEXT command in GDB monotonic, and makes the\n+      --  placement of breakpoints more accurate.\n+\n+      if Debug_Generated_Code then\n+         Loc := Sloc (Scop);\n+      else\n+         Loc := No_Location;\n+      end if;\n+\n+      --  If an extended return statement contains something like\n+      --     X := F (...);\n+      --  where F is a build-in-place function call returning a controlled\n+      --  type, then a temporary object will be implicitly declared as part of\n+      --  the statement list, and this will need cleanup. In such cases, we\n+      --  transform:\n+      --\n+      --    return Result : T := ... do\n+      --       <statements> -- possibly with handlers\n+      --    end return;\n+      --\n+      --  into:\n+      --\n+      --    return Result : T := ... do\n+      --       declare -- no declarations\n+      --       begin\n+      --          <statements> -- possibly with handlers\n+      --       end; -- no handlers\n+      --    end return;\n+      --\n+      --  So Expand_Cleanup_Actions will end up being called recursively on the\n+      --  block statement.\n+\n+      if Nkind (N) = N_Extended_Return_Statement then\n+         declare\n+            Block : constant Node_Id :=\n+              Make_Block_Statement (Loc,\n+               Declarations => Empty_List,\n+               Handled_Statement_Sequence =>\n+                 Handled_Statement_Sequence (N));\n+         begin\n+            Set_Handled_Statement_Sequence\n+              (N, Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (Block)));\n+            Analyze (Block);\n+         end;\n+\n+         --  Analysis of the block did all the work\n+\n+         return;\n+      end if;\n+\n       if Needs_Custom_Cleanup then\n          Cln := Cleanup_Actions (N);\n       else\n@@ -4315,20 +4380,6 @@ package body Exp_Ch7 is\n          Old_Poll  : Boolean;\n \n       begin\n-         --  If we are generating expanded code for debugging purposes, use the\n-         --  Sloc of the point of insertion for the cleanup code. The Sloc will\n-         --  be updated subsequently to reference the proper line in .dg files.\n-         --  If we are not debugging generated code, use No_Location instead,\n-         --  so that no debug information is generated for the cleanup code.\n-         --  This makes the behavior of the NEXT command in GDB monotonic, and\n-         --  makes the placement of breakpoints more accurate.\n-\n-         if Debug_Generated_Code then\n-            Loc := Sloc (Scop);\n-         else\n-            Loc := No_Location;\n-         end if;\n-\n          --  Set polling off. The finalization and cleanup code is executed\n          --  with aborts deferred.\n \n@@ -5207,10 +5258,10 @@ package body Exp_Ch7 is\n             then\n                Loc := Sloc (Obj_Decl);\n \n-               --  Before generating the clean up code for the first transient\n+               --  Before generating the cleanup code for the first transient\n                --  object, create a wrapper block which houses all hook clear\n                --  statements and finalization calls. This wrapper is needed by\n-               --  the back-end.\n+               --  the back end.\n \n                if not Built then\n                   Built     := True;\n@@ -8680,10 +8731,10 @@ package body Exp_Ch7 is\n       --       Finalizer;\n       --    end;\n \n-      --  A special case is made for Boolean expressions so that the back-end\n+      --  A special case is made for Boolean expressions so that the back end\n       --  knows to generate a conditional branch instruction, if running with\n-      --  -fpreserve-control-flow. This ensures that a control flow change\n-      --  signalling the decision outcome occurs before the cleanup actions.\n+      --  -fpreserve-control-flow. This ensures that a control-flow change\n+      --  signaling the decision outcome occurs before the cleanup actions.\n \n       if Opt.Suppress_Control_Flow_Optimizations\n         and then Is_Boolean_Type (Typ)"}, {"sha": "cd260b267dbae7d8881061ef66e70992a13af5a1", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -13450,6 +13450,12 @@ package body Exp_Ch9 is\n                        Selector_Name => Make_Identifier (Loc, Chars (D))));\n                Add (Decl);\n \n+               --  Set debug info needed on this renaming declaration even\n+               --  though it does not come from source, so that the debugger\n+               --  will get the right information for these generated names.\n+\n+               Set_Debug_Info_Needed (Discriminal (D));\n+\n                Next_Discriminant (D);\n             end loop;\n          end;"}, {"sha": "9e5465bc6de11ad6f1b14a44c7447898ac201bd2", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -574,6 +574,38 @@ package body Exp_Unst is\n                   end if;\n                end if;\n \n+            --  Record a 'Access as a (potential) call\n+\n+            elsif Nkind (N) = N_Attribute_Reference then\n+               declare\n+                  Attr : constant Attribute_Id :=\n+                           Get_Attribute_Id (Attribute_Name (N));\n+               begin\n+                  case Attr is\n+                     when Attribute_Access\n+                        | Attribute_Unchecked_Access\n+                        | Attribute_Unrestricted_Access\n+                     =>\n+                        Ent := Entity (Prefix (N));\n+\n+                        --  We are only interested in calls to subprograms\n+                        --  nested within Subp.\n+\n+                        if Scope_Within (Ent, Subp) then\n+                           if Is_Imported (Ent) then\n+                              null;\n+\n+                           elsif Is_Subprogram (Ent) then\n+                              Append_Unique_Call\n+                                ((N, Current_Subprogram, Ent));\n+                           end if;\n+                        end if;\n+\n+                     when others =>\n+                        null;\n+                  end case;\n+               end;\n+\n             --  Record a subprogram. We record a subprogram body that acts as\n             --  a spec. Otherwise we record a subprogram declaration, providing\n             --  that it has a corresponding body we can get hold of. The case\n@@ -1616,7 +1648,9 @@ package body Exp_Unst is\n             Act    : Node_Id;\n \n          begin\n-            if Present (STT.ARECnF) then\n+            if Present (STT.ARECnF)\n+              and then Nkind (CTJ.N) /= N_Attribute_Reference\n+            then\n \n                --  CTJ.N is a call to a subprogram which may require a pointer\n                --  to an activation record. The subprogram containing the call"}, {"sha": "3cd7496c18ae478b19d44cf51e114d0f2f36216f", "filename": "gcc/ada/exp_unst.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -64,7 +64,7 @@ package Exp_Unst is\n    --     doing transformations of this type.\n \n    --     Second: given that the transformation will be semantics-preserving,\n-   --     we can still used the standard GCC back end to build code from it.\n+   --     we can still use the standard GCC back end to build code from it.\n    --     This means we can easily run our full test suite to verify that the\n    --     transformations are indeed semantics preserving. It is a lot more\n    --     work to thoroughly test the output of specialized back ends.\n@@ -239,7 +239,7 @@ package Exp_Unst is\n    --          procedure inner (bb : integer; AREC1F : AREC1PT) is\n    --          begin\n    --             Integer'Deref(AREC1F.x) :=\n-   --               Integer'Deref(AREC1F.rv) + y + b + Integer_Deref(AREC1F.b);\n+   --               Integer'Deref(AREC1F.rv) + y + b + Integer'Deref(AREC1F.b);\n    --          end;\n    --\n    --       begin\n@@ -658,7 +658,7 @@ package Exp_Unst is\n       ARECnU : Entity_Id;\n       --  This AREC entity is the uplink component. It is other than Empty only\n       --  for nested subprograms that declare an activation record as indicated\n-      --  by Declares_AREC being Ture, and which have uplevel references (Lev\n+      --  by Declares_AREC being True, and which have uplevel references (Lev\n       --  greater than Uplevel_Ref). It is the additional component in the\n       --  activation record that references the ARECnF pointer (which points\n       --  the activation record one level higher, thus forming the chain)."}, {"sha": "b06e91a3c8bef8b712c6240e03e0e127097b8b34", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -10701,7 +10701,9 @@ package body Exp_Util is\n               and then not Is_Empty_List (Then_Statements (N))\n               and then not Are_Wrapped (Then_Statements (N))\n               and then Requires_Cleanup_Actions\n-                         (Then_Statements (N), False, False)\n+                         (Then_Statements (N),\n+                          Lib_Level => False,\n+                          Nested_Constructs => False)\n             then\n                Block := Wrap_Statements_In_Block (Then_Statements (N));\n                Set_Then_Statements (N, New_List (Block));\n@@ -10718,7 +10720,9 @@ package body Exp_Util is\n               and then not Is_Empty_List (Else_Statements (N))\n               and then not Are_Wrapped (Else_Statements (N))\n               and then Requires_Cleanup_Actions\n-                         (Else_Statements (N), False, False)\n+                         (Else_Statements (N),\n+                          Lib_Level => False,\n+                          Nested_Constructs => False)\n             then\n                Block := Wrap_Statements_In_Block (Else_Statements (N));\n                Set_Else_Statements (N, New_List (Block));\n@@ -10737,7 +10741,10 @@ package body Exp_Util is\n          =>\n             if not Is_Empty_List (Statements (N))\n               and then not Are_Wrapped (Statements (N))\n-              and then Requires_Cleanup_Actions (Statements (N), False, False)\n+              and then Requires_Cleanup_Actions\n+                         (Statements (N),\n+                          Lib_Level => False,\n+                          Nested_Constructs => False)\n             then\n                if Nkind (N) = N_Loop_Statement\n                  and then Present (Identifier (N))\n@@ -11815,24 +11822,38 @@ package body Exp_Util is\n             | N_Task_Body\n          =>\n             return\n-              Requires_Cleanup_Actions (Declarations (N), At_Lib_Level, True)\n+              Requires_Cleanup_Actions\n+                (Declarations (N), At_Lib_Level, Nested_Constructs => True)\n                 or else\n                   (Present (Handled_Statement_Sequence (N))\n                     and then\n                       Requires_Cleanup_Actions\n                         (Statements (Handled_Statement_Sequence (N)),\n-                         At_Lib_Level, True));\n+                         At_Lib_Level, Nested_Constructs => True));\n+\n+         --  Extended return statements are the same as the above, except that\n+         --  there is no Declarations field. We do not want to clean up the\n+         --  Return_Object_Declarations.\n+\n+         when N_Extended_Return_Statement =>\n+            return\n+               Present (Handled_Statement_Sequence (N))\n+               and then Requires_Cleanup_Actions\n+                          (Statements (Handled_Statement_Sequence (N)),\n+                           At_Lib_Level, Nested_Constructs => True);\n \n          when N_Package_Specification =>\n             return\n               Requires_Cleanup_Actions\n-                (Visible_Declarations (N), At_Lib_Level, True)\n+                (Visible_Declarations (N), At_Lib_Level,\n+                 Nested_Constructs => True)\n                   or else\n               Requires_Cleanup_Actions\n-                (Private_Declarations (N), At_Lib_Level, True);\n+                (Private_Declarations (N), At_Lib_Level,\n+                 Nested_Constructs => True);\n \n          when others =>\n-            return False;\n+            raise Program_Error;\n       end case;\n    end Requires_Cleanup_Actions;\n "}, {"sha": "0b377898f74f22d6c6ec92542973a35c85666733", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -52,7 +52,9 @@ package Exp_Util is\n \n    --    For an expression occurring in a declaration (declarations always\n    --    appear in lists), the actions are similarly inserted into the list\n-   --    just before the associated declaration.\n+   --    just before the associated declaration. ???Declarations do not always\n+   --    appear in lists; in particular, a library unit declaration does not\n+   --    appear in a list, and Insert_Action will crash in that case.\n \n    --  The following special cases arise:\n "}, {"sha": "e5133b751953c96b883c344d0b67b8dac2fd0aaf", "filename": "gcc/ada/libgnarl/s-taprop__qnx.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -442,16 +442,15 @@ package body System.Task_Primitives.Operations is\n \n       --  Workaround bug in QNX on ceiling locks: tasks with priority higher\n       --  than the ceiling priority don't receive EINVAL upon trying to lock.\n-      if Result = 0 then\n+      if Result = 0 and then Locking_Policy = 'C' then\n          Result := pthread_getschedparam (Self, Policy'Access, Sched'Access);\n          pragma Assert (Result = 0);\n          Result := pthread_mutex_getprioceiling (L.WO'Access, Ceiling'Access);\n          pragma Assert (Result = 0);\n \n-         --  Ceiling = 0 means no Ceiling Priority policy is set on this mutex\n-         --  Else, Ceiling < current priority means Ceiling violation\n+         --  Ceiling < current priority means Ceiling violation\n          --  (otherwise the current priority == ceiling)\n-         if Ceiling > 0 and then Ceiling < Sched.sched_curpriority then\n+         if Ceiling < Sched.sched_curpriority then\n             Ceiling_Violation := True;\n             Result := pthread_mutex_unlock (L.WO'Access);\n             pragma Assert (Result = 0);"}, {"sha": "b399ca9f3683ca8954a452b897ef3a85bca36bd3", "filename": "gcc/ada/libgnat/s-regexp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Flibgnat%2Fs-regexp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Flibgnat%2Fs-regexp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-regexp.ads?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -41,7 +41,7 @@\n \n with Ada.Finalization;\n \n-package System.Regexp is\n+package System.Regexp is -- ????????????????\n \n    --  The regular expression must first be compiled, using the Compile\n    --  function, which creates a finite state matching table, allowing"}, {"sha": "ccb00dc607e54a027d76f01d88be8068aa8fb98b", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -1445,7 +1445,7 @@ package Opt is\n    --  GNAT.Exception_Traces is with'ed. Used to inhibit transformation of\n    --  local raise statements into gotos in the presence of either package.\n \n-   Sprint_Line_Limit : Nat := 72;\n+   Sprint_Line_Limit : Nat := 72; -- ????????????????\n    --  GNAT\n    --  Limit values for chopping long lines in Cprint/Sprint output, can be\n    --  reset by use of NNN parameter with -gnatG or -gnatD switches."}, {"sha": "72c48a88bef909fb6e412ca41f02a7a9fa302fca", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -543,6 +543,7 @@ package Rtsfind is\n      RE_Null,\n \n      RO_CA_Time,                         -- Ada.Calendar\n+     RO_CA_Clock_Time,                   -- Ada.Calendar\n \n      RO_CA_Delay_For,                    -- Ada.Calendar.Delays\n      RO_CA_Delay_Until,                  -- Ada.Calendar.Delays\n@@ -582,6 +583,7 @@ package Rtsfind is\n      RE_Names,                           -- Ada.Interrupts.Names\n \n      RE_Clock,                           -- Ada.Real_Time\n+     RE_Clock_Time,                      -- Ada.Real_Time\n      RE_Time_Span,                       -- Ada.Real_Time\n      RE_Time_Span_Zero,                  -- Ada.Real_Time\n      RO_RT_Time,                         -- Ada.Real_Time\n@@ -1779,6 +1781,7 @@ package Rtsfind is\n      RE_Null                             => RTU_Null,\n \n      RO_CA_Time                          => Ada_Calendar,\n+     RO_CA_Clock_Time                    => Ada_Calendar,\n \n      RO_CA_Delay_For                     => Ada_Calendar_Delays,\n      RO_CA_Delay_Until                   => Ada_Calendar_Delays,\n@@ -1818,6 +1821,7 @@ package Rtsfind is\n      RE_Names                            => Ada_Interrupts_Names,\n \n      RE_Clock                            => Ada_Real_Time,\n+     RE_Clock_Time                       => Ada_Real_Time,\n      RE_Time_Span                        => Ada_Real_Time,\n      RE_Time_Span_Zero                   => Ada_Real_Time,\n      RO_RT_Time                          => Ada_Real_Time,"}, {"sha": "ebf1328e4ce63096dbc63a13e07148af1b60981e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -2389,6 +2389,10 @@ package body Sem_Ch13 is\n                   elsif Is_Incomplete_Type (E) then\n                      Error_Msg_N\n                        (\"predicate cannot apply to incomplete view\", Aspect);\n+\n+                  elsif Is_Generic_Type (E) then\n+                     Error_Msg_N\n+                       (\"predicate cannot apply to formal type\", Aspect);\n                      goto Continue;\n                   end if;\n "}, {"sha": "5d760c28de0442df39dfadc4186752eed4498253", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -9411,14 +9411,31 @@ package body Sem_Ch4 is\n          ---------------------------\n \n          function Is_Private_Overriding (Op : Entity_Id) return Boolean is\n-            Visible_Op : constant Entity_Id := Homonym (Op);\n+            Visible_Op : Entity_Id;\n \n          begin\n-            return Present (Visible_Op)\n-              and then Scope (Op) = Scope (Visible_Op)\n-              and then not Comes_From_Source (Visible_Op)\n-              and then Alias (Visible_Op) = Op\n-              and then not Is_Hidden (Visible_Op);\n+            --  The subprogram may be overloaded with both visible and private\n+            --  entities with the same name. We have to scan the chain of\n+            --  homonyms to determine whether there is a previous implicit\n+            --  declaration in the same scope that is overridden by the\n+            --  private candidate.\n+\n+            Visible_Op := Homonym (Op);\n+            while Present (Visible_Op) loop\n+               if Scope (Op) /= Scope (Visible_Op) then\n+                  return False;\n+\n+               elsif not Comes_From_Source (Visible_Op)\n+                 and then Alias (Visible_Op) = Op\n+                 and then not Is_Hidden (Visible_Op)\n+               then\n+                  return True;\n+               end if;\n+\n+               Visible_Op := Homonym (Visible_Op);\n+            end loop;\n+\n+            return False;\n          end Is_Private_Overriding;\n \n          -----------------"}, {"sha": "ea2379c3e1a72b5e2b4af7cb95fba991d4846643", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -5296,209 +5296,6 @@ package body Sem_Util is\n       end if;\n    end Conditional_Delay;\n \n-   ----------------------------\n-   -- Contains_Refined_State --\n-   ----------------------------\n-\n-   function Contains_Refined_State (Prag : Node_Id) return Boolean is\n-      function Has_State_In_Dependency (List : Node_Id) return Boolean;\n-      --  Determine whether a dependency list mentions a state with a visible\n-      --  refinement.\n-\n-      function Has_State_In_Global (List : Node_Id) return Boolean;\n-      --  Determine whether a global list mentions a state with a visible\n-      --  refinement.\n-\n-      function Is_Refined_State (Item : Node_Id) return Boolean;\n-      --  Determine whether Item is a reference to an abstract state with a\n-      --  visible refinement.\n-\n-      -----------------------------\n-      -- Has_State_In_Dependency --\n-      -----------------------------\n-\n-      function Has_State_In_Dependency (List : Node_Id) return Boolean is\n-         Clause : Node_Id;\n-         Output : Node_Id;\n-\n-      begin\n-         --  A null dependency list does not mention any states\n-\n-         if Nkind (List) = N_Null then\n-            return False;\n-\n-         --  Dependency clauses appear as component associations of an\n-         --  aggregate.\n-\n-         elsif Nkind (List) = N_Aggregate\n-           and then Present (Component_Associations (List))\n-         then\n-            Clause := First (Component_Associations (List));\n-            while Present (Clause) loop\n-\n-               --  Inspect the outputs of a dependency clause\n-\n-               Output := First (Choices (Clause));\n-               while Present (Output) loop\n-                  if Is_Refined_State (Output) then\n-                     return True;\n-                  end if;\n-\n-                  Next (Output);\n-               end loop;\n-\n-               --  Inspect the outputs of a dependency clause\n-\n-               if Is_Refined_State (Expression (Clause)) then\n-                  return True;\n-               end if;\n-\n-               Next (Clause);\n-            end loop;\n-\n-            --  If we get here, then none of the dependency clauses mention a\n-            --  state with visible refinement.\n-\n-            return False;\n-\n-         --  An illegal pragma managed to sneak in\n-\n-         else\n-            raise Program_Error;\n-         end if;\n-      end Has_State_In_Dependency;\n-\n-      -------------------------\n-      -- Has_State_In_Global --\n-      -------------------------\n-\n-      function Has_State_In_Global (List : Node_Id) return Boolean is\n-         Item : Node_Id;\n-\n-      begin\n-         --  A null global list does not mention any states\n-\n-         if Nkind (List) = N_Null then\n-            return False;\n-\n-         --  Simple global list or moded global list declaration\n-\n-         elsif Nkind (List) = N_Aggregate then\n-\n-            --  The declaration of a simple global list appear as a collection\n-            --  of expressions.\n-\n-            if Present (Expressions (List)) then\n-               Item := First (Expressions (List));\n-               while Present (Item) loop\n-                  if Is_Refined_State (Item) then\n-                     return True;\n-                  end if;\n-\n-                  Next (Item);\n-               end loop;\n-\n-            --  The declaration of a moded global list appears as a collection\n-            --  of component associations where individual choices denote\n-            --  modes.\n-\n-            else\n-               Item := First (Component_Associations (List));\n-               while Present (Item) loop\n-                  if Has_State_In_Global (Expression (Item)) then\n-                     return True;\n-                  end if;\n-\n-                  Next (Item);\n-               end loop;\n-            end if;\n-\n-            --  If we get here, then the simple/moded global list did not\n-            --  mention any states with a visible refinement.\n-\n-            return False;\n-\n-         --  Single global item declaration\n-\n-         elsif Is_Entity_Name (List) then\n-            return Is_Refined_State (List);\n-\n-         --  An illegal pragma managed to sneak in\n-\n-         else\n-            raise Program_Error;\n-         end if;\n-      end Has_State_In_Global;\n-\n-      ----------------------\n-      -- Is_Refined_State --\n-      ----------------------\n-\n-      function Is_Refined_State (Item : Node_Id) return Boolean is\n-         Elmt    : Node_Id;\n-         Item_Id : Entity_Id;\n-\n-      begin\n-         if Nkind (Item) = N_Null then\n-            return False;\n-\n-         --  States cannot be subject to attribute 'Result. This case arises\n-         --  in dependency relations.\n-\n-         elsif Nkind (Item) = N_Attribute_Reference\n-           and then Attribute_Name (Item) = Name_Result\n-         then\n-            return False;\n-\n-         --  Multiple items appear as an aggregate. This case arises in\n-         --  dependency relations.\n-\n-         elsif Nkind (Item) = N_Aggregate\n-           and then Present (Expressions (Item))\n-         then\n-            Elmt := First (Expressions (Item));\n-            while Present (Elmt) loop\n-               if Is_Refined_State (Elmt) then\n-                  return True;\n-               end if;\n-\n-               Next (Elmt);\n-            end loop;\n-\n-            --  If we get here, then none of the inputs or outputs reference a\n-            --  state with visible refinement.\n-\n-            return False;\n-\n-         --  Single item\n-\n-         else\n-            Item_Id := Entity_Of (Item);\n-\n-            return\n-              Present (Item_Id)\n-                and then Ekind (Item_Id) = E_Abstract_State\n-                and then Has_Visible_Refinement (Item_Id);\n-         end if;\n-      end Is_Refined_State;\n-\n-      --  Local variables\n-\n-      Arg : constant Node_Id :=\n-              Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n-      Nam : constant Name_Id := Pragma_Name (Prag);\n-\n-   --  Start of processing for Contains_Refined_State\n-\n-   begin\n-      if Nam = Name_Depends then\n-         return Has_State_In_Dependency (Arg);\n-\n-      else pragma Assert (Nam = Name_Global);\n-         return Has_State_In_Global (Arg);\n-      end if;\n-   end Contains_Refined_State;\n-\n    -------------------------\n    -- Copy_Component_List --\n    -------------------------"}, {"sha": "c1f421f36f5f393078e0095dcd09d53ae1ca5247", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -480,13 +480,6 @@ package Sem_Util is\n    --  of Old_Ent is set and Old_Ent has not yet been Frozen (i.e. Is_Frozen is\n    --  False).\n \n-   function Contains_Refined_State (Prag : Node_Id) return Boolean;\n-   --  Determine whether pragma Prag contains a reference to the entity of an\n-   --  abstract state with a visible refinement. Prag must denote one of the\n-   --  following pragmas:\n-   --    Depends\n-   --    Global\n-\n    function Copy_Component_List\n      (R_Typ : Entity_Id;\n       Loc   : Source_Ptr) return List_Id;"}, {"sha": "c523053be340767da842ddd9c201268ec02ac82f", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -49,7 +49,7 @@ with System;\n with Unchecked_Conversion;\n with Unchecked_Deallocation;\n \n-package Types is\n+package Types is -- ????????????????\n    pragma Preelaborate;\n \n    -------------------------------"}, {"sha": "b9b09d494151741eb06b63b6232c358b1b13df78", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -1,3 +1,7 @@\n+2017-12-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* gnat.dg/private_overriding.adb: New testcase.\n+\n 2017-12-05  Martin Liska  <mliska@suse.cz>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "0d59ae0b872bf16b169e0c3069320e59e98bfe94", "filename": "gcc/testsuite/gnat.dg/private_overriding.adb", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Ftestsuite%2Fgnat.dg%2Fprivate_overriding.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40c21e918dd15cb03b74aba9893d0a9f7f7f7624/gcc%2Ftestsuite%2Fgnat.dg%2Fprivate_overriding.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fprivate_overriding.adb?ref=40c21e918dd15cb03b74aba9893d0a9f7f7f7624", "patch": "@@ -0,0 +1,62 @@\n+--  { dg-do compile }\n+\n+procedure Private_Overriding is\n+\n+   package Foo is\n+\n+      type Bar is abstract tagged null record;\n+   \n+      procedure Overloaded_Subprogram\n+         (Self : in out Bar)\n+         is abstract;\n+   \n+      procedure Overloaded_Subprogram\n+         (Self : in out Bar;\n+          P1 : Integer)\n+         is abstract;\n+\n+      procedure Not_Overloaded_Subprogram\n+         (Self : in out Bar)\n+         is abstract;\n+\n+\n+      type Baz is new Bar with null record;\n+         -- promise to override both overloaded subprograms,\n+         -- shouldn't matter that they're defined in the private part,\n+\n+   private -- workaround: override in the public view\n+\n+      overriding\n+      procedure Overloaded_Subprogram\n+         (Self : in out Baz) \n+         is null;\n+\n+      overriding\n+      procedure Overloaded_Subprogram\n+         (Self : in out Baz;\n+          P1 : Integer) \n+          is null;\n+\n+      overriding\n+      procedure Not_Overloaded_Subprogram\n+         (Self : in out Baz)\n+         is null;\n+\n+   end Foo;\n+\n+   Qux : Foo.Baz;\n+begin\n+\n+  -- this is allowed, as expected\n+  Foo.Not_Overloaded_Subprogram(Qux);\n+  Foo.Overloaded_Subprogram(Qux);\n+  Foo.Overloaded_Subprogram(Foo.Baz'Class(Qux));\n+  Foo.Overloaded_Subprogram(Foo.Bar'Class(Qux));\n+\n+  -- however, using object-dot notation\n+  Qux.Not_Overloaded_Subprogram; -- this is allowed\n+  Qux.Overloaded_Subprogram; -- \"no selector...\"\n+  Foo.Baz'Class(Qux).Overloaded_Subprogram; -- \"no selector...\"\n+  Foo.Bar'Class(Qux).Overloaded_Subprogram; -- this is allowed\n+\n+end Private_Overriding;"}]}