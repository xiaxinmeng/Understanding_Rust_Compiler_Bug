{"sha": "bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZjYWJjNmNlMmExOGExYTQyZGI1NDgzYTFiNjM0ZjBiMjhlYmU2YQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-01-16T18:15:19Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-01-16T18:15:19Z"}, "message": "re PR fortran/30404 ([4.1 only] Wrong FORALL result)\n\n2007-01-16  Roger Sayle  <roger@eyesopen.com>\n\n\tPR fortran/30404\n\t* trans-stmt.c (forall_info): Remove pmask field.\n\t(gfc_trans_forall_loop): Remove NVAR argument, instead assume that\n\tNVAR covers all the interation variables in the current forall_info.\n\tAdd an extra OUTER parameter, which specified the loop header in\n\twhich to place mask index initializations.\n\t(gfc_trans_nested_forall_loop): Remove NEST_FLAG argument.\n\tChange the semantics of MASK_FLAG to only control the mask in the\n\tinnermost loop.\n\t(compute_overall_iter_number): Optimize the trivial case of a\n\ttop-level loop having a constant number of iterations.  Update\n\tcall to gfc_trans_nested_forall_loop.  Calculate the number of\n\ttimes the inner loop will be executed, not to size of the \n\titeration space.\n\t(allocate_temp_for_forall_nest_1): Reuse SIZE as BYTESIZE when\n\tsizeof(type) == 1.  Tidy up.\n\t(gfc_trans_assign_need_temp): Remove NEST_FLAG argument from calls\n\tto gfc_trans_nested_forall_loop.\n\t(gfc_trans_pointer_assign_need_temp): Likewise.\n\t(gfc_trans_forall_1): Remove unused BYTESIZE, TMPVAR, SIZEVAR and\n\tLENVAR local variables.  Split mask allocation into a separate\n\thunk/pass from mask population.  Use allocate_temp_for_forall_nest\n\tto allocate the FORALL mask with the correct size.  Update calls\n\tto gfc_trans_nested_forall_loop.\n\t(gfc_evaluate_where_mask): Update call to\n\tgfc_trans_nested_forall_loop.\n\t(gfc_trans_where_2): Likewise.\n\n\t* gfortran.dg/forall_6.f90: New test case.\n\t* gfortran.dg/dependency_8.f90: Update test to find \"temp\" array.\n\t* gfortran.dg/dependency_13.f90: Likewise.\n\n\nCo-Authored-By: Paul Thomas <pault@gcc.gnu.org>\nCo-Authored-By: Steven G. Kargl <kargl@gcc.gnu.org>\n\nFrom-SVN: r120829", "tree": {"sha": "d8223da56e40dbec680e05c76e4f24950c7370b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8223da56e40dbec680e05c76e4f24950c7370b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/comments", "author": null, "committer": null, "parents": [{"sha": "d0768f1953bf01b9665c7fd0ea1e2702dfd67db9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0768f1953bf01b9665c7fd0ea1e2702dfd67db9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0768f1953bf01b9665c7fd0ea1e2702dfd67db9"}], "stats": {"total": 297, "additions": 168, "deletions": 129}, "files": [{"sha": "cba3de897de805f2d46cff72d236dac8709d4ac3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a", "patch": "@@ -1,3 +1,33 @@\n+2007-01-16  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR fortran/30404\n+\t* trans-stmt.c (forall_info): Remove pmask field.\n+\t(gfc_trans_forall_loop): Remove NVAR argument, instead assume that\n+\tNVAR covers all the interation variables in the current forall_info.\n+\tAdd an extra OUTER parameter, which specified the loop header in\n+\twhich to place mask index initializations.\n+\t(gfc_trans_nested_forall_loop): Remove NEST_FLAG argument.\n+\tChange the semantics of MASK_FLAG to only control the mask in the\n+\tinnermost loop.\n+\t(compute_overall_iter_number): Optimize the trivial case of a\n+\ttop-level loop having a constant number of iterations.  Update\n+\tcall to gfc_trans_nested_forall_loop.  Calculate the number of\n+\ttimes the inner loop will be executed, not to size of the \n+\titeration space.\n+\t(allocate_temp_for_forall_nest_1): Reuse SIZE as BYTESIZE when\n+\tsizeof(type) == 1.  Tidy up.\n+\t(gfc_trans_assign_need_temp): Remove NEST_FLAG argument from calls\n+\tto gfc_trans_nested_forall_loop.\n+\t(gfc_trans_pointer_assign_need_temp): Likewise.\n+\t(gfc_trans_forall_1): Remove unused BYTESIZE, TMPVAR, SIZEVAR and\n+\tLENVAR local variables.  Split mask allocation into a separate\n+\thunk/pass from mask population.  Use allocate_temp_for_forall_nest\n+\tto allocate the FORALL mask with the correct size.  Update calls\n+\tto gfc_trans_nested_forall_loop.\n+\t(gfc_evaluate_where_mask): Update call to\n+\tgfc_trans_nested_forall_loop.\n+\t(gfc_trans_where_2): Likewise.\n+\n 2007-01-15  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/28172"}, {"sha": "437aa3642484859e79492f504ee78004e5183bd1", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 109, "deletions": 127, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a", "patch": "@@ -1,6 +1,6 @@\n /* Statement translation -- generate GCC trees from gfc_code.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n \n@@ -54,7 +54,6 @@ typedef struct forall_info\n {\n   iter_info *this_loop;\n   tree mask;\n-  tree pmask;\n   tree maskindex;\n   int nvar;\n   tree size;\n@@ -1526,7 +1525,13 @@ gfc_trans_select (gfc_code * code)\n }\n \n \n-/* Generate the loops for a FORALL block.  The normal loop format:\n+/* Generate the loops for a FORALL block, specified by FORALL_TMP.  BODY\n+   is the contents of the FORALL block/stmt to be iterated.  MASK_FLAG\n+   indicates whether we should generate code to test the FORALLs mask\n+   array.  OUTER is the loop header to be used for initializing mask\n+   indices.\n+\n+   The generated loop format is:\n     count = (end - start + step) / step\n     loopvar = start\n     while (1)\n@@ -1540,9 +1545,10 @@ gfc_trans_select (gfc_code * code)\n     end_of_loop:  */\n \n static tree\n-gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_flag)\n+gfc_trans_forall_loop (forall_info *forall_tmp, tree body,\n+                       int mask_flag, stmtblock_t *outer)\n {\n-  int n;\n+  int n, nvar;\n   tree tmp;\n   tree cond;\n   stmtblock_t block;\n@@ -1551,7 +1557,12 @@ gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_fl\n   tree var, start, end, step;\n   iter_info *iter;\n \n+  /* Initialize the mask index outside the FORALL nest.  */\n+  if (mask_flag && forall_tmp->mask)\n+    gfc_add_modify_expr (outer, forall_tmp->maskindex, gfc_index_zero_node);\n+\n   iter = forall_tmp->this_loop;\n+  nvar = forall_tmp->nvar;\n   for (n = 0; n < nvar; n++)\n     {\n       var = iter->var;\n@@ -1603,11 +1614,6 @@ gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_fl\n       gfc_init_block (&block);\n       gfc_add_modify_expr (&block, var, start);\n \n-      /* Initialize maskindex counter.  Only do this before the\n-\t outermost loop.  */\n-      if (n == nvar - 1 && mask_flag && forall_tmp->mask)\n-\tgfc_add_modify_expr (&block, forall_tmp->maskindex,\n-\t\t\t     gfc_index_zero_node);\n \n       /* Initialize the loop counter.  */\n       tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (var), step, start);\n@@ -1630,60 +1636,47 @@ gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_fl\n }\n \n \n-/* Generate the body and loops according to MASK_FLAG and NEST_FLAG.\n-   if MASK_FLAG is nonzero, the body is controlled by maskes in forall\n-   nest, otherwise, the body is not controlled by maskes.\n-   if NEST_FLAG is nonzero, generate loops for nested forall, otherwise,\n-   only generate loops for the current forall level.  */\n+/* Generate the body and loops according to MASK_FLAG.  If MASK_FLAG\n+   is nonzero, the body is controlled by all masks in the forall nest.\n+   Otherwise, the innermost loop is not controlled by it's mask.  This\n+   is used for initializing that mask.  */\n \n static tree\n gfc_trans_nested_forall_loop (forall_info * nested_forall_info, tree body,\n-                              int mask_flag, int nest_flag)\n+                              int mask_flag)\n {\n   tree tmp;\n-  int nvar;\n+  stmtblock_t header;\n   forall_info *forall_tmp;\n-  tree pmask, mask, maskindex;\n+  tree mask, maskindex;\n+\n+  gfc_start_block (&header);\n \n   forall_tmp = nested_forall_info;\n-  /* Generate loops for nested forall.  */\n-  if (nest_flag)\n+  while (forall_tmp->next_nest != NULL)\n+    forall_tmp = forall_tmp->next_nest;\n+  while (forall_tmp != NULL)\n     {\n-      while (forall_tmp->next_nest != NULL)\n-        forall_tmp = forall_tmp->next_nest;\n-      while (forall_tmp != NULL)\n+      /* Generate body with masks' control.  */\n+      if (mask_flag)\n         {\n-          /* Generate body with masks' control.  */\n-          if (mask_flag)\n-            {\n-              pmask = forall_tmp->pmask;\n-              mask = forall_tmp->mask;\n-              maskindex = forall_tmp->maskindex;\n+          mask = forall_tmp->mask;\n+          maskindex = forall_tmp->maskindex;\n \n-              if (mask)\n-                {\n-                  /* If a mask was specified make the assignment conditional.  */\n-                  if (pmask)\n-\t\t    tmp = build_fold_indirect_ref (mask);\n-                  else\n-                    tmp = mask;\n-                  tmp = gfc_build_array_ref (tmp, maskindex);\n-\n-                  body = build3_v (COND_EXPR, tmp, body, build_empty_stmt ());\n-                }\n+          /* If a mask was specified make the assignment conditional.  */\n+          if (mask)\n+            {\n+              tmp = gfc_build_array_ref (mask, maskindex);\n+              body = build3_v (COND_EXPR, tmp, body, build_empty_stmt ());\n             }\n-          nvar = forall_tmp->nvar;\n-          body = gfc_trans_forall_loop (forall_tmp, nvar, body, mask_flag);\n-          forall_tmp = forall_tmp->outer;\n         }\n-    }\n-  else\n-    {\n-      nvar = forall_tmp->nvar;\n-      body = gfc_trans_forall_loop (forall_tmp, nvar, body, mask_flag);\n+      body = gfc_trans_forall_loop (forall_tmp, body, mask_flag, &header);\n+      forall_tmp = forall_tmp->outer;\n+      mask_flag = 1;\n     }\n \n-  return body;\n+  gfc_add_expr_to_block (&header, body);\n+  return gfc_finish_block (&header);\n }\n \n \n@@ -2041,6 +2034,10 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n   tree tmp, number;\n   stmtblock_t body;\n \n+  /* Optimize the case for an outer-most loop with constant bounds.  */\n+  if (INTEGER_CST_P (inner_size) && !nested_forall_info)\n+    return inner_size;\n+  \n   /* TODO: optimizing the computing process.  */\n   number = gfc_create_var (gfc_array_index_type, \"num\");\n   gfc_add_modify_expr (block, number, gfc_index_zero_node);\n@@ -2058,7 +2055,7 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n \n   /* Generate loops.  */\n   if (nested_forall_info != NULL)\n-    tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 0, 1);\n+    tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1);\n \n   gfc_add_expr_to_block (block, tmp);\n \n@@ -2073,22 +2070,21 @@ static tree\n allocate_temp_for_forall_nest_1 (tree type, tree size, stmtblock_t * block,\n \t\t\t\t tree * ptemp1)\n {\n+  tree bytesize;\n   tree unit;\n-  tree temp1;\n   tree tmp;\n-  tree bytesize;\n \n   unit = TYPE_SIZE_UNIT (type);\n-  bytesize = fold_build2 (MULT_EXPR, gfc_array_index_type, size, unit);\n+  if (!integer_onep (unit))\n+    bytesize = fold_build2 (MULT_EXPR, gfc_array_index_type, size, unit);\n+  else\n+    bytesize = size;\n \n   *ptemp1 = NULL;\n-  temp1 = gfc_do_allocate (bytesize, size, ptemp1, block, type);\n+  tmp = gfc_do_allocate (bytesize, size, ptemp1, block, type);\n \n   if (*ptemp1)\n-    tmp = build_fold_indirect_ref (temp1);\n-  else\n-    tmp = temp1;\n-\n+    tmp = build_fold_indirect_ref (tmp);\n   return tmp;\n }\n \n@@ -2193,7 +2189,7 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n   /* Generate body and loops according to the information in\n      nested_forall_info.  */\n-  tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n+  tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1);\n   gfc_add_expr_to_block (block, tmp);\n \n   /* Reset count1.  */\n@@ -2209,7 +2205,7 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n   /* Generate body and loops according to the information in\n      nested_forall_info.  */\n-  tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n+  tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1);\n   gfc_add_expr_to_block (block, tmp);\n \n   if (ptemp1)\n@@ -2278,7 +2274,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n       /* Generate body and loops according to the information in\n          nested_forall_info.  */\n-      tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n+      tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1);\n       gfc_add_expr_to_block (block, tmp);\n \n       /* Reset count.  */\n@@ -2301,7 +2297,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n       /* Generate body and loops according to the information in\n          nested_forall_info.  */\n-      tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n+      tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1);\n       gfc_add_expr_to_block (block, tmp);\n     }\n   else\n@@ -2346,7 +2342,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n       /* Generate body and loops according to the information in\n          nested_forall_info.  */\n-      tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n+      tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1);\n       gfc_add_expr_to_block (block, tmp);\n \n       /* Reset count.  */\n@@ -2368,7 +2364,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n       tmp = gfc_finish_block (&body);\n \n-      tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n+      tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1);\n       gfc_add_expr_to_block (block, tmp);\n     }\n   /* Free the temporary.  */\n@@ -2432,10 +2428,6 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   tree tmp;\n   tree assign;\n   tree size;\n-  tree bytesize;\n-  tree tmpvar;\n-  tree sizevar;\n-  tree lenvar;\n   tree maskindex;\n   tree mask;\n   tree pmask;\n@@ -2446,10 +2438,8 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   gfc_se se;\n   gfc_code *c;\n   gfc_saved_var *saved_vars;\n-  iter_info *this_forall, *iter_tmp;\n-  forall_info *info, *forall_tmp;\n-\n-  gfc_start_block (&block);\n+  iter_info *this_forall;\n+  forall_info *info;\n \n   n = 0;\n   /* Count the FORALL index number.  */\n@@ -2467,12 +2457,15 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \n   /* Allocate the space for info.  */\n   info = (forall_info *) gfc_getmem (sizeof (forall_info));\n+\n+  gfc_start_block (&block);\n+\n   n = 0;\n   for (fa = code->ext.forall_iterator; fa; fa = fa->next)\n     {\n       gfc_symbol *sym = fa->var->symtree->n.sym;\n \n-      /* allocate space for this_forall.  */\n+      /* Allocate space for this_forall.  */\n       this_forall = (iter_info *) gfc_getmem (sizeof (iter_info));\n \n       /* Create a temporary variable for the FORALL index.  */\n@@ -2513,31 +2506,24 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       /* Set the NEXT field of this_forall to NULL.  */\n       this_forall->next = NULL;\n       /* Link this_forall to the info construct.  */\n-      if (info->this_loop == NULL)\n-        info->this_loop = this_forall;\n-      else\n+      if (info->this_loop)\n         {\n-          iter_tmp = info->this_loop;\n+          iter_info *iter_tmp = info->this_loop;\n           while (iter_tmp->next != NULL)\n             iter_tmp = iter_tmp->next;\n           iter_tmp->next = this_forall;\n         }\n+      else\n+        info->this_loop = this_forall;\n \n       n++;\n     }\n   nvar = n;\n \n-  /* Work out the number of elements in the mask array.  */\n-  tmpvar = NULL_TREE;\n-  lenvar = NULL_TREE;\n+  /* Calculate the size needed for the current forall level.  */\n   size = gfc_index_one_node;\n-  sizevar = NULL_TREE;\n-\n   for (n = 0; n < nvar; n++)\n     {\n-      if (lenvar && TREE_TYPE (lenvar) != TREE_TYPE (start[n]))\n-\tlenvar = NULL_TREE;\n-\n       /* size = (end + step - start) / step.  */\n       tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (start[n]), \n \t\t\t step[n], start[n]);\n@@ -2553,39 +2539,44 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   info->nvar = nvar;\n   info->size = size;\n \n-  /* Link the current forall level to nested_forall_info.  */\n-  forall_tmp = nested_forall_info;\n-  if (forall_tmp == NULL)\n-    nested_forall_info = info;\n+  /* First we need to allocate the mask.  */\n+  if (code->expr)\n+    {\n+      /* As the mask array can be very big, prefer compact boolean types.  */\n+      tree mask_type = gfc_get_logical_type (gfc_logical_kinds[0].kind);\n+      mask = allocate_temp_for_forall_nest (nested_forall_info, mask_type,\n+\t\t\t\t\t    size, NULL, &block, &pmask);\n+      maskindex = gfc_create_var_np (gfc_array_index_type, \"mi\");\n+\n+      /* Record them in the info structure.  */\n+      info->maskindex = maskindex;\n+      info->mask = mask;\n+    }\n   else\n     {\n+      /* No mask was specified.  */\n+      maskindex = NULL_TREE;\n+      mask = pmask = NULL_TREE;\n+    }\n+\n+  /* Link the current forall level to nested_forall_info.  */\n+  if (nested_forall_info)\n+    {\n+      forall_info *forall_tmp = nested_forall_info;\n       while (forall_tmp->next_nest != NULL)\n         forall_tmp = forall_tmp->next_nest;\n       info->outer = forall_tmp;\n       forall_tmp->next_nest = info;\n     }\n+  else\n+    nested_forall_info = info;\n \n   /* Copy the mask into a temporary variable if required.\n      For now we assume a mask temporary is needed.  */\n   if (code->expr)\n     {\n-      /* As the mask array can be very big, prefer compact\n-\t boolean types.  */\n-      tree smallest_boolean_type_node\n-\t= gfc_get_logical_type (gfc_logical_kinds[0].kind);\n-\n-      /* Allocate the mask temporary.  */\n-      bytesize = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n-\t\t\t      TYPE_SIZE_UNIT (smallest_boolean_type_node));\n-\n-      mask = gfc_do_allocate (bytesize, size, &pmask, &block,\n-\t\t\t      smallest_boolean_type_node);\n-\n-      maskindex = gfc_create_var_np (gfc_array_index_type, \"mi\");\n-      /* Record them in the info structure.  */\n-      info->pmask = pmask;\n-      info->mask = mask;\n-      info->maskindex = maskindex;\n+      /* As the mask array can be very big, prefer compact boolean types.  */\n+      tree mask_type = gfc_get_logical_type (gfc_logical_kinds[0].kind);\n \n       gfc_add_modify_expr (&block, maskindex, gfc_index_zero_node);\n \n@@ -2598,31 +2589,21 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       gfc_add_block_to_block (&body, &se.pre);\n \n       /* Store the mask.  */\n-      se.expr = convert (smallest_boolean_type_node, se.expr);\n+      se.expr = convert (mask_type, se.expr);\n \n-      if (pmask)\n-\ttmp = build_fold_indirect_ref (mask);\n-      else\n-\ttmp = mask;\n-      tmp = gfc_build_array_ref (tmp, maskindex);\n+      tmp = gfc_build_array_ref (mask, maskindex);\n       gfc_add_modify_expr (&body, tmp, se.expr);\n \n       /* Advance to the next mask element.  */\n       tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t   maskindex, gfc_index_one_node);\n+\t\t    maskindex, gfc_index_one_node);\n       gfc_add_modify_expr (&body, maskindex, tmp);\n \n       /* Generate the loops.  */\n       tmp = gfc_finish_block (&body);\n-      tmp = gfc_trans_nested_forall_loop (info, tmp, 0, 0);\n+      tmp = gfc_trans_nested_forall_loop (info, tmp, 0);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n-  else\n-    {\n-      /* No mask was specified.  */\n-      maskindex = NULL_TREE;\n-      mask = pmask = NULL_TREE;\n-    }\n \n   c = code->block->next;\n \n@@ -2646,7 +2627,8 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n               assign = gfc_trans_assignment (c->expr, c->expr2, false);\n \n               /* Generate body and loops.  */\n-              tmp = gfc_trans_nested_forall_loop (nested_forall_info, assign, 1, 1);\n+              tmp = gfc_trans_nested_forall_loop (nested_forall_info,\n+\t\t\t\t\t\t  assign, 1);\n               gfc_add_expr_to_block (&block, tmp);\n             }\n \n@@ -2669,8 +2651,8 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n               assign = gfc_trans_pointer_assignment (c->expr, c->expr2);\n \n               /* Generate body and loops.  */\n-              tmp = gfc_trans_nested_forall_loop (nested_forall_info, assign,\n-                                                  1, 1);\n+              tmp = gfc_trans_nested_forall_loop (nested_forall_info,\n+\t\t\t\t\t\t  assign, 1);\n               gfc_add_expr_to_block (&block, tmp);\n             }\n           break;\n@@ -2684,7 +2666,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \t   assignments can legitimately produce them.  */\n \tcase EXEC_ASSIGN_CALL:\n \t  assign = gfc_trans_call (c, true);\n-          tmp = gfc_trans_nested_forall_loop (nested_forall_info, assign, 1, 1);\n+          tmp = gfc_trans_nested_forall_loop (nested_forall_info, assign, 1);\n           gfc_add_expr_to_block (&block, tmp);\n           break;\n \n@@ -2858,7 +2840,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   tmp1 = gfc_finish_block (&body);\n   /* If the WHERE construct is inside FORALL, fill the full temporary.  */\n   if (nested_forall_info != NULL)\n-    tmp1 = gfc_trans_nested_forall_loop (nested_forall_info, tmp1, 1, 1);\n+    tmp1 = gfc_trans_nested_forall_loop (nested_forall_info, tmp1, 1);\n \n   gfc_add_expr_to_block (block, tmp1);\n }\n@@ -3230,7 +3212,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n \t\t\t\t\t\t    count1, count2);\n \n                       tmp = gfc_trans_nested_forall_loop (nested_forall_info,\n-                                                          tmp, 1, 1);\n+                                                          tmp, 1);\n                       gfc_add_expr_to_block (block, tmp);\n                     }\n                 }"}, {"sha": "5d3374783bbb8ad75d5f3b60e9fa2481ab29584f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a", "patch": "@@ -1,3 +1,12 @@\n+2007-01-16  Roger Sayle  <roger@eyesopen.com>\n+\t    Paul Thomas  <pault@gcc.gnu.org>\n+\t    Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/30404\n+\t* gfortran.dg/forall_6.f90: New test case.\n+\t* gfortran.dg/dependency_8.f90: Update test to find \"temp\" array.\n+\t* gfortran.dg/dependency_13.f90: Likewise.\n+\n 2007-01-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \tPR testsuite/12325"}, {"sha": "887da9dbba6dd00fd976658b479c7d86e93aaa04", "filename": "gcc/testsuite/gfortran.dg/dependency_13.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_13.f90?ref=bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a", "patch": "@@ -9,5 +9,5 @@\n      x(2:5) = -42.\n    end where\n    end\n-! { dg-final { scan-tree-dump-times \"malloc\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"temp\" 3 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "9f7837d6037174e300173642ec23eb6aefb0d536", "filename": "gcc/testsuite/gfortran.dg/dependency_8.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_8.f90?ref=bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a", "patch": "@@ -9,5 +9,5 @@ subroutine foo(a,i,j)\n     a(j,2:4) = 1\n   endwhere\n end subroutine\n-! { dg-final { scan-tree-dump-times \"malloc\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"temp\" 3 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "158c549cce16ca3cfbf0be537fe869c2c22be8ab", "filename": "gcc/testsuite/gfortran.dg/forall_6.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_6.f90?ref=bfcabc6ce2a18a1a42db5483a1b634f0b28ebe6a", "patch": "@@ -0,0 +1,18 @@\n+! PR fortran/30404\n+! Checks that we correctly handle nested masks in nested FORALL blocks.\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+! { dg-do run }\n+  logical :: l1(2,2)\n+  integer :: it(2,2)\n+  l1(:,:) = reshape ((/.false.,.true.,.true.,.false./), (/2,2/))\n+  it(:,:) = reshape ((/1,2,3,4/), (/2,2/))\n+  forall (i = 1:2, i < 3)\n+    forall (j = 1:2, l1(i,j))\n+      it(i, j) = 0\n+    end forall\n+  end forall\n+!  print *, l1\n+!  print '(4i2)', it\n+  if (any (it .ne. reshape ((/1, 0, 0, 4/), (/2, 2/)))) call abort ()\n+end"}]}