{"sha": "1b5963f7995824c4583515e6e255406ef615d60f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI1OTYzZjc5OTU4MjRjNDU4MzUxNWU2ZTI1NTQwNmVmNjE1ZDYwZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-02-19T09:02:48Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-02-19T09:02:48Z"}, "message": "re PR target/12916 (No vector ABI)\n\n\tPR target/12916\n\t* config/sparc/sparc.h (NPARM_REGS): Delete.\n\t(BASE_RETURN_VALUE_REG): Likewise.\n\t(BASE_OUTGOING_VALUE_REG): Likewise.\n\t(BASE_PASSING_ARG_REG): Likewise.\n\t(BASE_INCOMING_ARG_REG): Likewise.\n\t* config/sparc/sparc.c (sparc_strict_argument_naming): Test\n\tTARGET_ARCH64, not TARGET_V9.\n\t(function_arg_slotno): Dispatch based on the mode class.\n\tHandle vector modes like floating-point modes.\n\t(function_arg_record_value_1): Handle vector types like\n\tfloating-point types.\n\t(function_arg_record_value_2): Likewise.\n\tCalculate regno after mode transformation.\n\t(function_arg): Handle vector modes like floating-point modes.\n\t(function_arg_partial_nregs): Replace NPARM_REGS by SPARC_INT_ARG_MAX.\n\tIf ARCH64, do not recheck alignment.\n\t(function_arg_pass_by_reference): Reorder the conditions.\n\t(sparc_return_in_memory): Move after function_arg_padding.\n\tImplement calling conventions for vector modes.\n\t(sparc_struct_value_rtx): Move after sparc_return_in_memory.\n\t(function_value): Move scope of 'regbase'.\n\tImplement calling conventions for vector modes.\n\t(sparc_builtin_saveregs): Replace NPARM_REGS by SPARC_INT_ARG_MAX\n\tand BASE_INCOMING_ARG_REG by SPARC_INCOMING_INT_ARG_FIRST.\n\t(sparc_va_arg): Use function_arg_pass_by_reference to test whether\n\tthe argument is passed by reference.\n\t(sparc_type_code): Handle vector types.\n\nFrom-SVN: r78087", "tree": {"sha": "e7e523d18c057794414cbe0b29fbcafb099ded13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7e523d18c057794414cbe0b29fbcafb099ded13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b5963f7995824c4583515e6e255406ef615d60f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b5963f7995824c4583515e6e255406ef615d60f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b5963f7995824c4583515e6e255406ef615d60f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b5963f7995824c4583515e6e255406ef615d60f/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "19037b5c9e4647b07708e2414deee35c02b21f0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19037b5c9e4647b07708e2414deee35c02b21f0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19037b5c9e4647b07708e2414deee35c02b21f0a"}], "stats": {"total": 480, "additions": 275, "deletions": 205}, "files": [{"sha": "7bc78d51375d3b5c9a760ec984bfe9c3f8a93c26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b5963f7995824c4583515e6e255406ef615d60f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b5963f7995824c4583515e6e255406ef615d60f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b5963f7995824c4583515e6e255406ef615d60f", "patch": "@@ -1,3 +1,34 @@\n+2004-02-19  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/12916\n+\t* config/sparc/sparc.h (NPARM_REGS): Delete.\n+\t(BASE_RETURN_VALUE_REG): Likewise.\n+\t(BASE_OUTGOING_VALUE_REG): Likewise.\n+\t(BASE_PASSING_ARG_REG): Likewise.\n+\t(BASE_INCOMING_ARG_REG): Likewise.\n+\t* config/sparc/sparc.c (sparc_strict_argument_naming): Test\n+\tTARGET_ARCH64, not TARGET_V9.\n+\t(function_arg_slotno): Dispatch based on the mode class.\n+\tHandle vector modes like floating-point modes.\n+\t(function_arg_record_value_1): Handle vector types like\n+\tfloating-point types.\n+\t(function_arg_record_value_2): Likewise.\n+\tCalculate regno after mode transformation.\n+\t(function_arg): Handle vector modes like floating-point modes.\n+\t(function_arg_partial_nregs): Replace NPARM_REGS by SPARC_INT_ARG_MAX.\n+\tIf ARCH64, do not recheck alignment.\n+\t(function_arg_pass_by_reference): Reorder the conditions.\n+\t(sparc_return_in_memory): Move after function_arg_padding.\n+\tImplement calling conventions for vector modes.\n+\t(sparc_struct_value_rtx): Move after sparc_return_in_memory.\n+\t(function_value): Move scope of 'regbase'.\n+\tImplement calling conventions for vector modes.\n+\t(sparc_builtin_saveregs): Replace NPARM_REGS by SPARC_INT_ARG_MAX\n+\tand BASE_INCOMING_ARG_REG by SPARC_INCOMING_INT_ARG_FIRST.\n+\t(sparc_va_arg): Use function_arg_pass_by_reference to test whether\n+\tthe argument is passed by reference.\n+\t(sparc_type_code): Handle vector types.\n+\n 2004-02-19  Alan Modra  <amodra@bigpond.net.au>\n \n \t* function.c (assign_parms): When building decl_rtl for"}, {"sha": "258dfc2d81e545d39f246a28ab5498f9de7a2706", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 244, "deletions": 178, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b5963f7995824c4583515e6e255406ef615d60f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b5963f7995824c4583515e6e255406ef615d60f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=1b5963f7995824c4583515e6e255406ef615d60f", "patch": "@@ -4769,11 +4769,11 @@ output_sibcall (rtx insn, rtx call_operand)\n \f\n /* Functions for handling argument passing.\n \n-   For v8 the first six args are normally in registers and the rest are\n+   For 32-bit, the first 6 args are normally in registers and the rest are\n    pushed.  Any arg that starts within the first 6 words is at least\n    partially passed in a register unless its data type forbids.\n \n-   For v9, the argument registers are laid out as an array of 16 elements\n+   For 64-bit, the argument registers are laid out as an array of 16 elements\n    and arguments are added sequentially.  The first 6 int args and up to the\n    first 16 fp args (depending on size) are passed in regs.\n \n@@ -4798,7 +4798,7 @@ output_sibcall (rtx insn, rtx call_operand)\n \n    Here SP = %sp if -mno-stack-bias or %sp+stack_bias otherwise.\n \n-   Integral arguments are always passed as 64 bit quantities appropriately\n+   Integral arguments are always passed as 64-bit quantities appropriately\n    extended.\n \n    Passing of floating point values is handled as follows.\n@@ -4815,7 +4815,81 @@ output_sibcall (rtx insn, rtx call_operand)\n      appropriate integer reg and the appropriate fp reg.\n      If the value is not one of the first 6 arguments the value is passed in\n      the appropriate fp reg and in memory.\n-   */\n+\n+\n+   Summary of the calling conventions implemented by GCC on SPARC:\n+\n+   32-bit ABI:\n+                                size      argument     return value\n+\n+      small integer              <4       int. reg.      int. reg.\n+      word                        4       int. reg.      int. reg.\n+      double word                 8       int. reg.      int. reg.\n+\n+      _Complex small integer     <8       int. reg.      int. reg.\n+      _Complex word               8       int. reg.      int. reg.\n+      _Complex double word       16        memory        int. reg.\n+\n+      vector integer            <=8       int. reg.       FP reg.\n+      vector integer             >8        memory         memory\n+\n+      float                       4       int. reg.       FP reg.\n+      double                      8       int. reg.       FP reg.\n+      long double                16        memory         memory\n+\n+      _Complex float              8        memory         FP reg.\n+      _Complex double            16        memory         FP reg.\n+      _Complex long double       32        memory         FP reg.\n+\n+      vector float             <=32        memory         FP reg.\n+      vector float              >32        memory         memory\n+\n+      aggregate                 any        memory         memory\n+\n+\n+\n+    64-bit ABI:\n+                                size      argument     return value\n+\n+      small integer              <8       int. reg.      int. reg.\n+      word                        8       int. reg.      int. reg.\n+      double word                16       int. reg.      int. reg.\n+\n+      _Complex small integer    <16       int. reg.      int. reg.\n+      _Complex word              16       int. reg.      int. reg.\n+      _Complex double word       32        memory        int. reg.\n+\n+      vector integer           <=16        FP reg.        FP reg.\n+      vector integer       16<s<=32        memory         FP reg.\n+      vector integer            >32        memory         memory\n+\n+      float                       4        FP reg.        FP reg.\n+      double                      8        FP reg.        FP reg.\n+      long double                16        FP reg.        FP reg.\n+\n+      _Complex float              8        FP reg.        FP reg.\n+      _Complex double            16        FP reg.        FP reg.\n+      _Complex long double       32        memory         FP reg.\n+\n+      vector float             <=16        FP reg.        FP reg.\n+      vector float         16<s<=32        memory         FP reg.\n+      vector float              >32        memory         memory\n+\n+      aggregate                <=16         reg.           reg.\n+      aggregate            16<s<=32        memory          reg.\n+      aggregate                 >32        memory         memory\n+\n+\n+\n+Note #1: complex floating-point types follow the extended SPARC ABIs as\n+implemented by the Sun compiler.\n+\n+Note #2: integral vector types follow the scalar floating-point types\n+conventions to match what is implemented by the Sun VIS SDK.\n+\n+Note #3: floating-point vector types follow the complex floating-point\n+types conventions.  */\n+\n \n /* Maximum number of int regs for args.  */\n #define SPARC_INT_ARG_MAX 6\n@@ -4853,44 +4927,7 @@ sparc_promote_prototypes (tree fntype ATTRIBUTE_UNUSED)\n static bool\n sparc_strict_argument_naming (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n {\n-  /* For the V9 we want NAMED to mean what it says it means.  */\n-  return TARGET_V9 ? true : false;\n-}\n-\n-/* Handle the TARGET_RETURN_IN_MEMORY target hook.\n-   Specify whether to return the return value in memory.  */\n-\n-static bool\n-sparc_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n-{\n-  /* SPARC ABI says that quad-precision floats and all structures are\n-     returned in memory.\n-     For V9: unions <= 32 bytes in size are returned in int regs,\n-     structures up to 32 bytes are returned in int and fp regs.  */\n-  return (TARGET_ARCH32\n-\t  ? (TYPE_MODE (type) == BLKmode\n-\t     || TYPE_MODE (type) == TFmode)\n-\t  : (TYPE_MODE (type) == BLKmode\n-\t     && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 32));\n-}\n-\n-/* Handle the TARGET_STRUCT_VALUE target hook.\n-   Return where to find the structure return value address.  */\n-\n-static rtx\n-sparc_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED, int incoming)\n-{\n-  if (TARGET_ARCH64)\n-    return 0;\n-  else\n-    {\n-      if (incoming)\n-\treturn gen_rtx_MEM (Pmode, plus_constant (frame_pointer_rtx,\n-\t\t\t\t\t\t  STRUCT_VALUE_OFFSET));\n-      else\n-\treturn gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t  STRUCT_VALUE_OFFSET));\n-    }\n+  return TARGET_ARCH64 ? true : false;\n }\n \n /* Scan the record type TYPE and return the following predicates:\n@@ -4952,82 +4989,69 @@ function_arg_slotno (const struct sparc_args *cum, enum machine_mode mode,\n \n   *ppadding = 0;\n \n-  if (type != 0 && TREE_ADDRESSABLE (type))\n+  if (type && TREE_ADDRESSABLE (type))\n     return -1;\n+\n   if (TARGET_ARCH32\n-      && type != 0 && mode == BLKmode\n+      && mode == BLKmode\n+      && type\n       && TYPE_ALIGN (type) % PARM_BOUNDARY != 0)\n     return -1;\n \n-  switch (mode)\n-    {\n-    case VOIDmode :\n-      /* MODE is VOIDmode when generating the actual call.\n-\t See emit_call_1.  */\n-      return -1;\n+  /* For SPARC64, objects requiring 16-byte alignment get it.  */\n+  if (TARGET_ARCH64\n+      && GET_MODE_ALIGNMENT (mode) >= 2 * BITS_PER_WORD\n+      && (slotno & 1) != 0)\n+    slotno++, *ppadding = 1;\n \n-    case TImode : case CTImode :\n-      if (TARGET_ARCH64 && (slotno & 1) != 0)\n-\tslotno++, *ppadding = 1;\n+  switch (GET_MODE_CLASS (mode))\n+    {\n+    case MODE_FLOAT:\n+    case MODE_COMPLEX_FLOAT:\n+    case MODE_VECTOR_INT:\n+    case MODE_VECTOR_FLOAT:\n+      if (TARGET_ARCH64 && TARGET_FPU && named)\n+\t{\n+\t  if (slotno >= SPARC_FP_ARG_MAX)\n+\t    return -1;\n+\t  regno = SPARC_FP_ARG_FIRST + slotno * 2;\n+\t  /* Arguments filling only one single FP register are\n+\t     right-justified in the outer double FP register.  */\n+\t  if (GET_MODE_SIZE (mode) <= 4)\n+\t    regno++;\n+\t  break;\n+\t}\n       /* fallthrough */\n \n-    case QImode : case CQImode :\n-    case HImode : case CHImode :\n-    case SImode : case CSImode :\n-    case DImode : case CDImode :\n+    case MODE_INT:\n+    case MODE_COMPLEX_INT:\n       if (slotno >= SPARC_INT_ARG_MAX)\n \treturn -1;\n       regno = regbase + slotno;\n       break;\n \n-    case TFmode : case TCmode :\n-      if (TARGET_ARCH64 && (slotno & 1) != 0)\n-\tslotno++, *ppadding = 1;\n-      /* fallthrough */\n+    case MODE_RANDOM:\n+      if (mode == VOIDmode)\n+\t/* MODE is VOIDmode when generating the actual call.  */\n+\treturn -1;\n \n-    case SFmode : case SCmode :\n-    case DFmode : case DCmode :\n-      if (TARGET_ARCH32)\n-\t{\n-\t  if (slotno >= SPARC_INT_ARG_MAX)\n-\t    return -1;\n-\t  regno = regbase + slotno;\n-\t}\n-      else\n-\t{\n-\t  if (TARGET_FPU && named)\n-\t    {\n-\t      if (slotno >= SPARC_FP_ARG_MAX)\n-\t\treturn -1;\n-\t      regno = SPARC_FP_ARG_FIRST + slotno * 2;\n-\t      if (mode == SFmode)\n-\t\tregno++;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (slotno >= SPARC_INT_ARG_MAX)\n-\t\treturn -1;\n-\t      regno = regbase + slotno;\n-\t    }\n-\t}\n-      break;\n+      if (mode != BLKmode)\n+\tabort ();\n \n-    case BLKmode :\n-      /* For sparc64, objects requiring 16 byte alignment get it.  */\n-      if (TARGET_ARCH64)\n-\t{\n-\t  if (type && TYPE_ALIGN (type) == 128 && (slotno & 1) != 0)\n-\t    slotno++, *ppadding = 1;\n-\t}\n+      /* For SPARC64, objects requiring 16-byte alignment get it.  */\n+      if (TARGET_ARCH64\n+\t  && type\n+\t  && TYPE_ALIGN (type) >= 2 * BITS_PER_WORD\n+\t  && (slotno & 1) != 0)\n+\tslotno++, *ppadding = 1;\n \n-      if (TARGET_ARCH32\n-\t  || (type && TREE_CODE (type) == UNION_TYPE))\n+      if (TARGET_ARCH32 || (type && TREE_CODE (type) == UNION_TYPE))\n \t{\n \t  if (slotno >= SPARC_INT_ARG_MAX)\n \t    return -1;\n \t  regno = regbase + slotno;\n \t}\n-      else\n+      else  /* TARGET_ARCH64 && type && TREE_CODE (type) == RECORD_TYPE */\n \t{\n \t  int intregs_p = 0, fpregs_p = 0, packed_p = 0;\n \n@@ -5043,10 +5067,12 @@ function_arg_slotno (const struct sparc_args *cum, enum machine_mode mode,\n \t  /* If all arg slots are filled, then must pass on stack.  */\n \t  if (fpregs_p && slotno >= SPARC_FP_ARG_MAX)\n \t    return -1;\n+\n \t  /* If there are only int args and all int arg slots are filled,\n \t     then must pass on stack.  */\n \t  if (!fpregs_p && intregs_p && slotno >= SPARC_INT_ARG_MAX)\n \t    return -1;\n+\n \t  /* Note that even if all int arg slots are filled, fp members may\n \t     still be passed in regs if such regs are available.\n \t     *PREGNO isn't set because there may be more than one, it's up\n@@ -5130,7 +5156,8 @@ function_arg_record_value_1 (tree type, HOST_WIDE_INT startbitpos,\n \t    \t\t\t\t bitpos,\n \t\t\t\t\t parms,\n \t\t\t\t\t packed_p);\n-\t  else if (FLOAT_TYPE_P (TREE_TYPE (field))\n+\t  else if ((FLOAT_TYPE_P (TREE_TYPE (field))\n+\t\t    || TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE)\n \t\t   && TARGET_FPU\n \t\t   && parms->named\n \t\t   && ! packed_p)\n@@ -5268,7 +5295,8 @@ function_arg_record_value_2 (tree type, HOST_WIDE_INT startbitpos,\n \t    \t\t\t\t bitpos,\n \t\t\t\t\t parms,\n \t\t\t\t\t packed_p);\n-\t  else if (FLOAT_TYPE_P (TREE_TYPE (field))\n+\t  else if ((FLOAT_TYPE_P (TREE_TYPE (field))\n+\t\t    || TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE)\n \t\t   && TARGET_FPU\n \t\t   && parms->named\n \t\t   && ! packed_p)\n@@ -5279,16 +5307,16 @@ function_arg_record_value_2 (tree type, HOST_WIDE_INT startbitpos,\n \t      rtx reg;\n \n \t      function_arg_record_value_3 (bitpos, parms);\n-\t      regno = SPARC_FP_ARG_FIRST + this_slotno * 2\n-\t\t      + ((mode == SFmode || mode == SCmode)\n-\t\t\t && (bitpos & 32) != 0);\n \t      switch (mode)\n \t\t{\n \t\tcase SCmode: mode = SFmode; break;\n \t\tcase DCmode: mode = DFmode; break;\n \t\tcase TCmode: mode = TFmode; break;\n \t\tdefault: break;\n \t\t}\n+\t      regno = SPARC_FP_ARG_FIRST + this_slotno * 2;\n+\t      if (GET_MODE_SIZE (mode) <= 4 && (bitpos & 32) != 0)\n+\t\tregno++;\n \t      reg = gen_rtx_REG (mode, regno);\n \t      XVECEXP (parms->ret, 0, parms->stack + parms->nregs)\n \t\t= gen_rtx_EXPR_LIST (VOIDmode, reg,\n@@ -5506,7 +5534,9 @@ function_arg (const struct sparc_args *cum, enum machine_mode mode,\n      If no prototype is in scope fp values in register slots get passed\n      in two places, either fp regs and int regs or fp regs and memory.  */\n   else if ((GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t    || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+\t    || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n+\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n       && SPARC_FP_REG_P (regno))\n     {\n       reg = gen_rtx_REG (mode, regno);\n@@ -5607,20 +5637,20 @@ function_arg_partial_nregs (const struct sparc_args *cum,\n       if ((slotno + (mode == BLKmode\n \t\t     ? ROUND_ADVANCE (int_size_in_bytes (type))\n \t\t     : ROUND_ADVANCE (GET_MODE_SIZE (mode))))\n-\t  > NPARM_REGS (SImode))\n-\treturn NPARM_REGS (SImode) - slotno;\n-      return 0;\n+\t  > SPARC_INT_ARG_MAX)\n+\treturn SPARC_INT_ARG_MAX - slotno;\n     }\n   else\n     {\n+      /* We are guaranteed by function_arg_pass_by_reference that the size\n+\t of the argument is not greater than 16 bytes, so we only need to\n+\t return 1 if the argument is partially passed in registers.  */\n+\n       if (type && AGGREGATE_TYPE_P (type))\n \t{\n \t  int size = int_size_in_bytes (type);\n-\t  int align = TYPE_ALIGN (type);\n \n-\t  if (align == 16)\n-\t    slotno += slotno & 1;\n-\t  if (size > 8 && size <= 16\n+\t  if (size > UNITS_PER_WORD\n \t      && slotno == SPARC_INT_ARG_MAX - 1)\n \t    return 1;\n \t}\n@@ -5629,33 +5659,19 @@ function_arg_partial_nregs (const struct sparc_args *cum,\n \t\t   && ! (TARGET_FPU && named)))\n \t{\n \t  /* The complex types are passed as packed types.  */\n-\t  if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n-\t    return 0;\n-\n-\t  if (GET_MODE_ALIGNMENT (mode) == 128)\n-\t    {\n-\t      slotno += slotno & 1;\n-\n-\t      /* ??? The mode needs 3 slots?  */\n-\t      if (slotno == SPARC_INT_ARG_MAX - 2)\n-\t\treturn 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (slotno == SPARC_INT_ARG_MAX - 1)\n-\t\treturn 1;\n-\t    }\n+\t  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+\t      && slotno == SPARC_INT_ARG_MAX - 1)\n+\t    return 1;\n \t}\n       else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n \t{\n-\t  if (GET_MODE_ALIGNMENT (mode) == 128)\n-\t    slotno += slotno & 1;\n \t  if ((slotno + GET_MODE_SIZE (mode) / UNITS_PER_WORD)\n \t      > SPARC_FP_ARG_MAX)\n \t    return 1;\n \t}\n-      return 0;\n     }\n+\n+  return 0;\n }\n \n /* Handle the FUNCTION_ARG_PASS_BY_REFERENCE macro.\n@@ -5672,18 +5688,23 @@ function_arg_pass_by_reference (const struct sparc_args *cum ATTRIBUTE_UNUSED,\n   if (TARGET_ARCH32)\n     {\n       return ((type && AGGREGATE_TYPE_P (type))\n+\t      /* Extended ABI (as implemented by the Sun compiler) says\n+\t\t that all complex floats are passed in memory.  */\n \t      || mode == SCmode\n+\t      /* Enforce the 2-word cap for passing arguments in registers.\n+\t\t This affects CDImode, TFmode, DCmode, TCmode and large\n+\t\t vector modes.  */\n \t      || GET_MODE_SIZE (mode) > 8);\n     }\n   else\n     {\n       return ((type && TREE_CODE (type) == ARRAY_TYPE)\n-\t      /* Consider complex values as aggregates, so care\n-\t\t for CTImode and TCmode.  */\n-\t      || GET_MODE_SIZE (mode) > 16\n \t      || (type\n \t\t  && AGGREGATE_TYPE_P (type)\n-\t\t  && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 16));\n+\t\t  && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 16)\n+\t      /* Enforce the 2-word cap for passing arguments in registers.\n+\t\t This affects CTImode, TCmode and large vector modes.  */\n+\t      || GET_MODE_SIZE (mode) > 16);\n     }\n }\n \n@@ -5747,21 +5768,73 @@ function_arg_padding (enum machine_mode mode, tree type)\n   return DEFAULT_FUNCTION_ARG_PADDING (mode, type);\n }\n \n+/* Handle the TARGET_RETURN_IN_MEMORY target hook.\n+   Specify whether to return the return value in memory.  */\n+\n+static bool\n+sparc_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n+{\n+  if (TARGET_ARCH32)\n+    /* Original SPARC 32-bit ABI says that quad-precision floats\n+       and all structures are returned in memory.  Extended ABI\n+       (as implemented by the Sun compiler) says that all complex\n+       floats are returned in registers (8 FP registers at most\n+       for '_Complex long double').  Return all complex integers\n+       in registers (4 at most for '_Complex long long').  */\n+    return (TYPE_MODE (type) == BLKmode\n+\t    || TYPE_MODE (type) == TFmode\n+\t    /* Integral vector types follow the scalar FP types conventions.  */\n+\t    || (GET_MODE_CLASS (TYPE_MODE (type)) == MODE_VECTOR_INT\n+\t\t&& GET_MODE_SIZE (TYPE_MODE (type)) > 8)\n+\t    /* FP vector types follow the complex FP types conventions.  */\n+\t    || (GET_MODE_CLASS (TYPE_MODE (type)) == MODE_VECTOR_FLOAT\n+\t\t&& GET_MODE_SIZE (TYPE_MODE (type)) > 32));\n+  else\n+    /* Original SPARC 64-bit ABI says that structures and unions\n+       smaller than 32 bytes are returned in registers.  Extended\n+       ABI (as implemented by the Sun compiler) says that all complex\n+       floats are returned in registers (8 FP registers at most\n+       for '_Complex long double').  Return all complex integers\n+       in registers (4 at most for '_Complex TItype').  */\n+    return ((TYPE_MODE (type) == BLKmode\n+\t     && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 32)\n+\t    || GET_MODE_SIZE (TYPE_MODE (type)) > 32);\n+}\n+\n+/* Handle the TARGET_STRUCT_VALUE target hook.\n+   Return where to find the structure return value address.  */\n+\n+static rtx\n+sparc_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED, int incoming)\n+{\n+  if (TARGET_ARCH64)\n+    return 0;\n+  else\n+    {\n+      if (incoming)\n+\treturn gen_rtx_MEM (Pmode, plus_constant (frame_pointer_rtx,\n+\t\t\t\t\t\t  STRUCT_VALUE_OFFSET));\n+      else\n+\treturn gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t  STRUCT_VALUE_OFFSET));\n+    }\n+}\n+\n /* Handle FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE, and LIBCALL_VALUE macros.\n    For v9, function return values are subject to the same rules as arguments,\n-   except that up to 32-bytes may be returned in registers.  */\n+   except that up to 32 bytes may be returned in registers.  */\n \n rtx\n function_value (tree type, enum machine_mode mode, int incoming_p)\n {\n+  /* Beware that the two values are swapped here wrt function_arg.  */\n+  int regbase = (incoming_p\n+\t\t ? SPARC_OUTGOING_INT_ARG_FIRST\n+\t\t : SPARC_INCOMING_INT_ARG_FIRST);\n   int regno;\n \n   if (TARGET_ARCH64 && type)\n     {\n-      int regbase = (incoming_p\n-\t\t     ? SPARC_OUTGOING_INT_ARG_FIRST\n-\t\t     : SPARC_INCOMING_INT_ARG_FIRST);\n-\n       if (TREE_CODE (type) == RECORD_TYPE)\n \t{\n \t  /* Structures up to 32 bytes in size are passed in registers,\n@@ -5788,7 +5861,7 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n \t  HOST_WIDE_INT bytes = int_size_in_bytes (type);\n \n \t  if (bytes > 32)\n-\t    abort ();\n+\t    abort (); /* shouldn't get here */\n \n \t  mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 0);\n \t}\n@@ -5797,10 +5870,10 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n \tmode = word_mode;\n     }\n \n-  if (incoming_p)\n-    regno = BASE_RETURN_VALUE_REG (mode);\n+  if (TARGET_FPU && (FLOAT_MODE_P (mode) || VECTOR_MODE_P (mode)))\n+    regno = SPARC_FP_ARG_FIRST;\n   else\n-    regno = BASE_OUTGOING_VALUE_REG (mode);\n+    regno = regbase;\n \n   return gen_rtx_REG (mode, regno);\n }\n@@ -5816,15 +5889,15 @@ sparc_builtin_saveregs (void)\n   rtx address;\n   int regno;\n \n-  for (regno = first_reg; regno < NPARM_REGS (word_mode); regno++)\n+  for (regno = first_reg; regno < SPARC_INT_ARG_MAX; regno++)\n     emit_move_insn (gen_rtx_MEM (word_mode,\n \t\t\t\t gen_rtx_PLUS (Pmode,\n \t\t\t\t\t       frame_pointer_rtx,\n \t\t\t\t\t       GEN_INT (FIRST_PARM_OFFSET (0)\n \t\t\t\t\t\t\t+ (UNITS_PER_WORD\n \t\t\t\t\t\t\t   * regno)))),\n \t\t    gen_rtx_REG (word_mode,\n-\t\t\t\t BASE_INCOMING_ARG_REG (word_mode) + regno));\n+\t\t\t\t SPARC_INCOMING_INT_ARG_FIRST + regno));\n \n   address = gen_rtx_PLUS (Pmode,\n \t\t\t  frame_pointer_rtx,\n@@ -5834,7 +5907,7 @@ sparc_builtin_saveregs (void)\n   return address;\n }\n \n-/* Implement `va_start' for varargs and stdarg.  */\n+/* Implement `va_start' for stdarg.  */\n \n void\n sparc_va_start (tree valist, rtx nextarg)\n@@ -5843,52 +5916,44 @@ sparc_va_start (tree valist, rtx nextarg)\n   std_expand_builtin_va_start (valist, nextarg);\n }\n \n-/* Implement `va_arg'.  */\n+/* Implement `va_arg' for stdarg.  */\n \n rtx\n sparc_va_arg (tree valist, tree type)\n {\n   HOST_WIDE_INT size, rsize, align;\n   tree addr, incr;\n   rtx addr_rtx;\n-  int indirect = 0;\n+  bool indirect;\n \n-  /* Round up sizeof(type) to a word.  */\n-  size = int_size_in_bytes (type);\n-  rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n-  align = 0;\n-\n-  if (TARGET_ARCH64)\n+  if (function_arg_pass_by_reference (0, TYPE_MODE (type), type, 0))\n     {\n-      if (TYPE_ALIGN (type) >= 2 * (unsigned) BITS_PER_WORD)\n-\talign = 2 * UNITS_PER_WORD;\n-\n-      /* Consider complex values as aggregates, so care\n-\t for CTImode and TCmode.  */\n-      if ((unsigned HOST_WIDE_INT) size > 16)\n-\t{\n-\t  indirect = 1;\n-\t  size = rsize = UNITS_PER_WORD;\n-\t  align = 0;\n-\t}\n-      else if (AGGREGATE_TYPE_P (type))\n-\t{\n-\t  /* SPARC-V9 ABI states that structures up to 16 bytes in size\n-\t     are given whole slots as needed.  */\n-\t  if (size == 0)\n-\t    size = rsize = UNITS_PER_WORD;\n-\t  else\n-\t    size = rsize;\n-\t}\n+      indirect = true;\n+      size = rsize = UNITS_PER_WORD;\n+      align = 0;\n     }\n   else\n     {\n-      if (AGGREGATE_TYPE_P (type)\n-\t  || TYPE_MODE (type) == SCmode\n-\t  || GET_MODE_SIZE (TYPE_MODE (type)) > 8)\n+      indirect = false;\n+      size = int_size_in_bytes (type);\n+      rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n+      align = 0;\n+    \n+      if (TARGET_ARCH64)\n \t{\n-\t  indirect = 1;\n-\t  size = rsize = UNITS_PER_WORD;\n+\t  /* For SPARC64, objects requiring 16-byte alignment get it.  */\n+\t  if (TYPE_ALIGN (type) >= 2 * (unsigned) BITS_PER_WORD)\n+\t    align = 2 * UNITS_PER_WORD;\n+\n+\t  /* SPARC-V9 ABI states that structures up to 16 bytes in size\n+\t     are given whole slots as needed.  */\n+\t  if (AGGREGATE_TYPE_P (type))\n+\t    {\n+\t      if (size == 0)\n+\t\tsize = rsize = UNITS_PER_WORD;\n+\t      else\n+\t\tsize = rsize;\n+\t    }\n \t}\n     }\n \n@@ -7259,6 +7324,7 @@ sparc_type_code (register tree type)\n \t     existing front-ends.  */\n \t  return (qualifiers | 7);\t/* Who knows? */\n \n+\tcase VECTOR_TYPE:\n \tcase CHAR_TYPE:\t\t/* GNU Pascal CHAR type.  Not used in C.  */\n \tcase BOOLEAN_TYPE:\t/* GNU Fortran BOOLEAN type.  */\n \tcase FILE_TYPE:\t\t/* GNU Pascal FILE type.  */"}, {"sha": "515291cb371b3764fe4f033b5ff3eb28646ba42b", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b5963f7995824c4583515e6e255406ef615d60f/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b5963f7995824c4583515e6e255406ef615d60f/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=1b5963f7995824c4583515e6e255406ef615d60f", "patch": "@@ -1467,17 +1467,6 @@ extern char leaf_reg_remap[];\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n-/* Define the number of register that can hold parameters.\n-   This macro is only used in other macro definitions below and in sparc.c.\n-   MODE is the mode of the argument.\n-   !v9: All args are passed in %o0-%o5.\n-   v9: %o0-%o5 and %f0-%f31 are cumulatively used to pass values.\n-   See the description in sparc.c.  */\n-#define NPARM_REGS(MODE) \\\n-(TARGET_ARCH64 \\\n- ? (GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 6) \\\n- : 6)\n-\n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n #define STACK_GROWS_DOWNWARD\n@@ -1565,22 +1554,6 @@ extern char leaf_reg_remap[];\n \n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n \n-/* Some subroutine macros specific to this machine.\n-   When !TARGET_FPU, put float return values in the general registers,\n-   since we don't have any fp registers.  */\n-#define BASE_RETURN_VALUE_REG(MODE)\t\\\n-  (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 8)\n-\n-#define BASE_OUTGOING_VALUE_REG(MODE)\t\\\n-  (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 24)\n-\n-#define BASE_PASSING_ARG_REG(MODE)\t\t\t\t\\\n-  (TARGET_ARCH64 && TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 8)\n-\n-/* ??? FIXME -- seems wrong for v9 structure passing...  */\n-#define BASE_INCOMING_ARG_REG(MODE)\t\t\t\t\\\n-  (TARGET_ARCH64 && TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 24)\n-\n /* Define this macro if the target machine has \"register windows\".  This\n    C expression returns the register number as seen by the called function\n    corresponding to register number OUT as seen by the calling function."}]}