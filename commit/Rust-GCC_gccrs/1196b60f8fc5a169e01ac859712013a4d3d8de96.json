{"sha": "1196b60f8fc5a169e01ac859712013a4d3d8de96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE5NmI2MGY4ZmM1YTE2OWUwMWFjODU5NzEyMDEzYTRkM2Q4ZGU5Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-08-07T01:04:43Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-08-12T23:33:10Z"}, "message": "compiler: store pointers to go:notinheap types indirectly\n\nThis is the gofrontend version of https://golang.org/cl/264480.\n\nFor golang/go#42076\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/340609", "tree": {"sha": "431a9cea9e59f3dda3f12a613802b04f094f5712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/431a9cea9e59f3dda3f12a613802b04f094f5712"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1196b60f8fc5a169e01ac859712013a4d3d8de96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1196b60f8fc5a169e01ac859712013a4d3d8de96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1196b60f8fc5a169e01ac859712013a4d3d8de96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1196b60f8fc5a169e01ac859712013a4d3d8de96/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0befed793b94f3f407be44e6f69f81a02f5f073", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0befed793b94f3f407be44e6f69f81a02f5f073", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0befed793b94f3f407be44e6f69f81a02f5f073"}], "stats": {"total": 114, "additions": 94, "deletions": 20}, "files": [{"sha": "539d886b08f6afc4bb46dc622c3371cd371c93fb", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1196b60f8fc5a169e01ac859712013a4d3d8de96/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1196b60f8fc5a169e01ac859712013a4d3d8de96/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=1196b60f8fc5a169e01ac859712013a4d3d8de96", "patch": "@@ -1,4 +1,4 @@\n-7e092d2cc5af7648036496485b639f2c9db2f2d8\n+5edbb624b2595d644eb6842c952a292c41f7d6fa\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "8d4d168f4e396a14d373d0cdd50767f267d9f4e3", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1196b60f8fc5a169e01ac859712013a4d3d8de96/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1196b60f8fc5a169e01ac859712013a4d3d8de96/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=1196b60f8fc5a169e01ac859712013a4d3d8de96", "patch": "@@ -408,7 +408,14 @@ Expression::convert_type_to_interface(Type* lhs_type, Expression* rhs,\n     {\n       // We are assigning a non-pointer value to the interface; the\n       // interface gets a copy of the value in the heap if it escapes.\n-      if (rhs->is_constant())\n+\n+      // An exception is &global if global is notinheap, which is a\n+      // pointer value but not a direct-iface type and we can't simply\n+      // take its address.\n+      bool is_address = (rhs->unary_expression() != NULL\n+                         && rhs->unary_expression()->op() == OPERATOR_AND);\n+\n+      if (rhs->is_constant() && !is_address)\n         obj = Expression::make_unary(OPERATOR_AND, rhs, location);\n       else\n         {\n@@ -11331,6 +11338,7 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n       // We always pass a pointer when calling a method, except for\n       // direct interface types when calling a value method.\n       if (!first_arg->type()->is_error()\n+          && first_arg->type()->points_to() == NULL\n           && !first_arg->type()->is_direct_iface_type())\n \t{\n \t  first_arg = Expression::make_unary(OPERATOR_AND, first_arg, loc);\n@@ -18630,12 +18638,20 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n       else\n \tm = st->method_function(p->name(), &is_ambiguous);\n       go_assert(m != NULL);\n-      Named_object* no =\n-        (this->is_pointer_\n-         && this->type_->is_direct_iface_type()\n-         && m->is_value_method()\n-         ? m->iface_stub_object()\n-         : m->named_object());\n+\n+      // See the comment in Type::method_constructor.\n+      bool use_direct_iface_stub = false;\n+      if (m->is_value_method()\n+\t  && this->is_pointer_\n+\t  && this->type_->is_direct_iface_type())\n+\tuse_direct_iface_stub = true;\n+      if (!m->is_value_method()\n+\t  && this->is_pointer_\n+\t  && !this->type_->in_heap())\n+\tuse_direct_iface_stub = true;\n+      Named_object* no = (use_direct_iface_stub\n+\t\t\t  ? m->iface_stub_object()\n+\t\t\t  : m->named_object());\n \n       go_assert(no->is_function() || no->is_function_declaration());\n "}, {"sha": "e76600daab9a811c923afa5a4411938d6b2843b1", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 67, "deletions": 8, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1196b60f8fc5a169e01ac859712013a4d3d8de96/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1196b60f8fc5a169e01ac859712013a4d3d8de96/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=1196b60f8fc5a169e01ac859712013a4d3d8de96", "patch": "@@ -2464,8 +2464,16 @@ Type::is_direct_iface_type() const\n bool\n Type::is_direct_iface_type_helper(Unordered_set(const Type*)* visited) const\n {\n-  if (this->points_to() != NULL\n-      || this->channel_type() != NULL\n+  if (this->points_to() != NULL)\n+    {\n+      // Pointers to notinheap types must be stored indirectly.  See\n+      // https://golang.org/issue/42076.\n+      if (!this->points_to()->in_heap())\n+\treturn false;\n+      return true;\n+    }\n+\n+  if (this->channel_type() != NULL\n       || this->function_type() != NULL\n       || this->map_type() != NULL)\n     return true;\n@@ -3597,10 +3605,36 @@ Type::method_constructor(Gogo*, Type* method_type,\n       vals->push_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n     }\n \n-  bool use_direct_iface_stub =\n-    this->points_to() != NULL\n-    && this->points_to()->is_direct_iface_type()\n-    && m->is_value_method();\n+  // The direct_iface_stub dereferences the value stored in the\n+  // interface when calling the method.\n+  //\n+  // We need this for a value method if this type is a pointer to a\n+  // direct-iface type.  For example, if we have \"type C chan int\" and M\n+  // is a value method on C, then since a channel is a direct-iface type\n+  // M expects a value of type C.  We are generating the method table\n+  // for *C, so the value stored in the interface is *C.  We have to\n+  // call the direct-iface stub to dereference *C to get C to pass to M.\n+  //\n+  // We also need this for a pointer method if the pointer itself is not\n+  // a direct-iface type, as arises for notinheap types.  In this case\n+  // we have \"type NIH ...\" where NIH is go:notinheap.  Since NIH is\n+  // notinheap, *NIH is a pointer type that is not a direct-iface type,\n+  // so the value stored in the interface is actually **NIH.  The method\n+  // expects *NIH, so we have to call the direct-iface stub to\n+  // dereference **NIH to get *NIH to pass to M.  (This case doesn't\n+  // arise for value methods because pointer types can't have methods,\n+  // so there is no such thing as a value method for type *NIH.)\n+\n+  bool use_direct_iface_stub = false;\n+  if (m->is_value_method()\n+      && this->points_to() != NULL\n+      && this->points_to()->is_direct_iface_type())\n+    use_direct_iface_stub = true;\n+  if (!m->is_value_method()\n+      && this->points_to() != NULL\n+      && !this->is_direct_iface_type())\n+    use_direct_iface_stub = true;\n+\n   Named_object* no = (use_direct_iface_stub\n                       ? m->iface_stub_object()\n                       : (m->needs_stub_method()\n@@ -10902,6 +10936,20 @@ Named_type::do_needs_key_update()\n   return ret;\n }\n \n+// Return whether this type is permitted in the heap.\n+bool\n+Named_type::do_in_heap() const\n+{\n+  if (!this->in_heap_)\n+    return false;\n+  if (this->seen_)\n+    return true;\n+  this->seen_ = true;\n+  bool ret = this->type_->in_heap();\n+  this->seen_ = false;\n+  return ret;\n+}\n+\n // Return a hash code.  This is used for method lookup.  We simply\n // hash on the name itself.\n \n@@ -11434,7 +11482,7 @@ Type::finalize_methods(Gogo* gogo, const Type* type, Location location,\n       *all_methods = NULL;\n     }\n   Type::build_stub_methods(gogo, type, *all_methods, location);\n-  if (type->is_direct_iface_type())\n+  if (type->is_direct_iface_type() || !type->in_heap())\n     Type::build_direct_iface_stub_methods(gogo, type, *all_methods, location);\n }\n \n@@ -11814,12 +11862,23 @@ Type::build_direct_iface_stub_methods(Gogo* gogo, const Type* type,\n   if (methods == NULL)\n     return;\n \n+  bool is_direct_iface = type->is_direct_iface_type();\n+  bool in_heap = type->in_heap();\n   for (Methods::const_iterator p = methods->begin();\n        p != methods->end();\n        ++p)\n     {\n       Method* m = p->second;\n-      if (!m->is_value_method())\n+\n+      // We need a direct-iface stub for a value method for a\n+      // direct-iface type, and for a pointer method for a not-in-heap\n+      // type.\n+      bool need_stub = false;\n+      if (is_direct_iface && m->is_value_method())\n+        need_stub = true;\n+      if (!in_heap && !m->is_value_method())\n+        need_stub = true;\n+      if (!need_stub)\n         continue;\n \n       Type* receiver_type = const_cast<Type*>(type);"}, {"sha": "ca1ab49c57e95a3b7d8d6cdc375d7f1eda0d4fea", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1196b60f8fc5a169e01ac859712013a4d3d8de96/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1196b60f8fc5a169e01ac859712013a4d3d8de96/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=1196b60f8fc5a169e01ac859712013a4d3d8de96", "patch": "@@ -3605,8 +3605,7 @@ class Named_type : public Type\n   do_needs_key_update();\n \n   bool\n-  do_in_heap() const\n-  { return this->in_heap_ && this->type_->in_heap(); }\n+  do_in_heap() const;\n \n   unsigned int\n   do_hash_for_method(Gogo*, int) const;"}, {"sha": "879112a728d6b84cacddd6152a635122aa393f3a", "filename": "libgo/go/runtime/netpoll.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1196b60f8fc5a169e01ac859712013a4d3d8de96/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1196b60f8fc5a169e01ac859712013a4d3d8de96/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll.go?ref=1196b60f8fc5a169e01ac859712013a4d3d8de96", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build aix || darwin || dragonfly || freebsd || hurd || (js && wasm) || linux || netbsd || openbsd || solaris || windows\n // +build aix darwin dragonfly freebsd hurd js,wasm linux netbsd openbsd solaris windows\n \n package runtime\n@@ -567,8 +568,7 @@ func (c *pollCache) alloc() *pollDesc {\n func (pd *pollDesc) makeArg() (i interface{}) {\n \tx := (*eface)(unsafe.Pointer(&i))\n \tx._type = pdType\n-\t// For gccgo, we still use pd.self here, not &pd.self.\n-\tx.data = unsafe.Pointer(pd.self)\n+\tx.data = unsafe.Pointer(&pd.self)\n \treturn\n }\n "}]}