{"sha": "aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVlNGUwZGJmYTMxZWFiYmEwZmFmNGY1YTZkN2IwNDM3M2Q5OTE0Yw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-10-15T16:27:34Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-10-15T16:27:34Z"}, "message": "s390.c (s390_split_branches): Add return value.\n\n\t* config/s390/s390.c (s390_split_branches): Add return\n\tvalue.  Add parameters TEMP_REG and TEMP_USED.  Use unspec 104.\n\n\t(find_base_register_in_addr): New function.\n\t(find_base_register_ref): New function.\n\t(replace_base_register_ref): New function.\n\n\t(struct constant_pool): Add members pool_insn, insns, and anchor.\n\tRemove member last_insn.\n\t(s390_start_pool): Initialize them.\n\t(s390_end_pool): Emit pool placeholder insn.\n\t(s390_add_pool_insn): New function.\n\t(s390_find_pool): Use insns bitmap instead of addresses.\n\t(s390_dump_pool): Replace placeholder insn.  Emit anchor.\n\tReplace unspec 104 by local-pool-relative references.\n\t(s390_output_constant_pool): Output anchor label if required.\n\t(s390_output_symbolic_const): Handle unspec 104 and 105.\n\t(s390_add_pool): Remove, replace by ...\n\t(s390_add_constant, s390_find_constant): ... these new functions.\n\t(s390_add_anchor): New function.\n\n\t(s390_chunkify_pool): Delete, replace by ...\n\t(s390_chunkify_start, s390_chunkify_finish,\n\ts390_chunkify_cancel): ... these new functions.\n\t(s390_optimize_prolog): Add parameter TEMP_REGNO.\n\tRecompute register live data for special registers.\n\t(s390_fixup_clobbered_return_reg): New function.\n\t(s390_machine_dependent_reorg): Rewrite to use new\n\ts390_chunkify_... routines.\n\n\tconfig/s390/s390.md (\"reload_base\"): Rename to ...\n\t(\"reload_base_31\"): ... this.\n\t(\"reload_base_64\"): New insn.\n\t(\"reload_base2\"): Remove.\n\t(\"reload_anchor\"): New insn.\n\t(\"pool\"): New insn.\n\n\ts390.c (s390_pool_overflow): Remove.\n\ts390.h (s390_pool_overflow): Likewise.\n\ts390.md (\"cjump\", \"icjump\", \"doloop_si\"): Remove s390_pool_overflow.\n\nFrom-SVN: r58168", "tree": {"sha": "70e672c489b3c41dbcbaf66481eef5c6e83c2942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70e672c489b3c41dbcbaf66481eef5c6e83c2942"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c/comments", "author": null, "committer": null, "parents": [{"sha": "6742d92b7f8742b0ac8bc860d5ed4e809a2f901b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6742d92b7f8742b0ac8bc860d5ed4e809a2f901b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6742d92b7f8742b0ac8bc860d5ed4e809a2f901b"}], "stats": {"total": 868, "additions": 692, "deletions": 176}, "files": [{"sha": "b7b666732af0d03367d6dd5bee4aaad26af67272", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c", "patch": "@@ -1,3 +1,46 @@\n+2002-10-15  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_split_branches): Add return\n+\tvalue.  Add parameters TEMP_REG and TEMP_USED.  Use unspec 104.\n+\n+\t(find_base_register_in_addr): New function.\n+\t(find_base_register_ref): New function.\n+\t(replace_base_register_ref): New function.\n+\n+\t(struct constant_pool): Add members pool_insn, insns, and anchor.\n+\tRemove member last_insn.\n+\t(s390_start_pool): Initialize them.\n+\t(s390_end_pool): Emit pool placeholder insn. \n+\t(s390_add_pool_insn): New function.\n+\t(s390_find_pool): Use insns bitmap instead of addresses.\n+\t(s390_dump_pool): Replace placeholder insn.  Emit anchor.\n+\tReplace unspec 104 by local-pool-relative references.\n+\t(s390_output_constant_pool): Output anchor label if required.\n+\t(s390_output_symbolic_const): Handle unspec 104 and 105.\n+\t(s390_add_pool): Remove, replace by ...\n+\t(s390_add_constant, s390_find_constant): ... these new functions.\n+\t(s390_add_anchor): New function.\n+\n+\t(s390_chunkify_pool): Delete, replace by ...\n+\t(s390_chunkify_start, s390_chunkify_finish, \n+\ts390_chunkify_cancel): ... these new functions.\n+\t(s390_optimize_prolog): Add parameter TEMP_REGNO.\n+\tRecompute register live data for special registers.\n+\t(s390_fixup_clobbered_return_reg): New function.\n+\t(s390_machine_dependent_reorg): Rewrite to use new\n+\ts390_chunkify_... routines.\n+\n+\tconfig/s390/s390.md (\"reload_base\"): Rename to ...\n+\t(\"reload_base_31\"): ... this.\n+\t(\"reload_base_64\"): New insn.\n+\t(\"reload_base2\"): Remove.\n+\t(\"reload_anchor\"): New insn.\n+\t(\"pool\"): New insn.\n+\n+\ts390.c (s390_pool_overflow): Remove.\n+\ts390.h (s390_pool_overflow): Likewise.\n+\ts390.md (\"cjump\", \"icjump\", \"doloop_si\"): Remove s390_pool_overflow.\n+\n Tue Oct 15 16:51:04 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* sh.md (movv8qi_i+2): Don't split if source is -1."}, {"sha": "d84b72714e6f6dab410384cbf37513bf31c879ee", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 630, "deletions": 161, "changes": 791, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c", "patch": "@@ -130,11 +130,14 @@ static int general_s_operand PARAMS ((rtx, enum machine_mode, int));\n static int s390_decompose_address PARAMS ((rtx, struct s390_address *));\n static int reg_used_in_mem_p PARAMS ((int, rtx));\n static int addr_generation_dependency_p PARAMS ((rtx, rtx));\n-static void s390_split_branches PARAMS ((void));\n+static int s390_split_branches PARAMS ((rtx, bool *));\n static void find_constant_pool_ref PARAMS ((rtx, rtx *));\n static void replace_constant_pool_ref PARAMS ((rtx *, rtx, rtx));\n-static void s390_chunkify_pool PARAMS ((void));\n-static void s390_optimize_prolog PARAMS ((void));\n+static int find_base_register_in_addr PARAMS ((struct s390_address *));\n+static bool find_base_register_ref PARAMS ((rtx));\n+static void replace_base_register_ref PARAMS ((rtx *, rtx));\n+static void s390_optimize_prolog PARAMS ((int));\n+static bool s390_fixup_clobbered_return_reg PARAMS ((rtx));\n static int find_unused_clobbered_reg PARAMS ((void));\n static void s390_frame_info PARAMS ((struct s390_frame *));\n static rtx save_fpr PARAMS ((rtx, int, int));\n@@ -2569,9 +2572,14 @@ s390_output_symbolic_const (file, x)\n       switch (XINT (x, 1))\n         {\n         case 100:\n+        case 104:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n           fprintf (file, \"-.LT%d\", current_function_funcdef_no);\n \t  break;\n+        case 105:\n+          fprintf (file, \".LT%d-\", current_function_funcdef_no);\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+\t  break;\n \tcase 110:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n \t  fprintf (file, \"@GOT12\");\n@@ -2985,12 +2993,19 @@ s390_adjust_priority (insn, priority)\n }\n \n \n-/* Split all branches that exceed the maximum distance.  */\n+/* Split all branches that exceed the maximum distance.  \n+   Returns true if this created a new literal pool entry.  \n+\n+   Code generated by this routine is allowed to use\n+   TEMP_REG as temporary scratch register.  If this is\n+   done, TEMP_USED is set to true.  */\n \n-static void \n-s390_split_branches ()\n+static int \n+s390_split_branches (temp_reg, temp_used)\n+     rtx temp_reg;\n+     bool *temp_used;\n {\n-  rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n+  int new_literal = 0;\n   rtx insn, pat, tmp, target;\n   rtx *label;\n \n@@ -3030,7 +3045,7 @@ s390_split_branches ()\n       if (get_attr_length (insn) <= (TARGET_64BIT ? 6 : 4))\n \tcontinue;\n \n-      regs_ever_live[RETURN_REGNUM] = 1;\n+      *temp_used = 1;\n \n       if (TARGET_64BIT)\n \t{\n@@ -3041,6 +3056,7 @@ s390_split_branches ()\n \t}\n       else if (!flag_pic)\n \t{\n+\t  new_literal = 1;\n \t  tmp = force_const_mem (Pmode, *label);\n \t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, tmp), insn);\n \t  INSN_ADDRESSES_NEW (tmp, -1);\n@@ -3049,7 +3065,8 @@ s390_split_branches ()\n \t}\n       else\n \t{\n-\t  tmp = gen_rtx_UNSPEC (SImode, gen_rtvec (1, *label), 100);\n+\t  new_literal = 1;\n+\t  tmp = gen_rtx_UNSPEC (SImode, gen_rtvec (1, *label), 104);\n \t  tmp = gen_rtx_CONST (SImode, tmp);\n \t  tmp = force_const_mem (SImode, tmp);\n \t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, tmp), insn);\n@@ -3062,6 +3079,8 @@ s390_split_branches ()\n       if (!validate_change (insn, label, target, 0))\n \tabort ();\n     }\n+\n+  return new_literal;\n }\n \n \n@@ -3179,6 +3198,153 @@ replace_constant_pool_ref (x, ref, addr)\n     }\n }\n \n+/* Check whether ADDR is an address that uses the base register, \n+   without actually constituting a literal pool access.  (This happens\n+   in 31-bit PIC mode, where the base register is used as anchor for\n+   relative addressing of local symbols.) \n+\n+   Returns 1 if the base register occupies the base slot,\n+   returns 2 if the base register occupies the index slot,\n+   returns 0 if the address is not of this form.  */\n+\n+static int\n+find_base_register_in_addr (addr)\n+     struct s390_address *addr;\n+{\n+  /* If DISP is complex, we might have a literal pool reference.  */\n+  if (addr->disp && GET_CODE (addr->disp) != CONST_INT)\n+    return 0;\n+\n+  if (addr->base && REG_P (addr->base) && REGNO (addr->base) == BASE_REGISTER)\n+    return 1;\n+\n+  if (addr->indx && REG_P (addr->indx) && REGNO (addr->indx) == BASE_REGISTER)\n+    return 2;\n+\n+  return 0;\n+}\n+\n+/* Return true if X contains an address that uses the base register, \n+   without actually constituting a literal pool access.  */\n+\n+static bool\n+find_base_register_ref (x)\n+     rtx x;\n+{\n+  bool retv = FALSE;\n+  struct s390_address addr;\n+  int i, j;\n+  const char *fmt;\n+\n+  /* Addresses can only occur inside a MEM ...  */\n+  if (GET_CODE (x) == MEM)\n+    {\n+      if (s390_decompose_address (XEXP (x, 0), &addr)\n+\t  && find_base_register_in_addr (&addr))\n+\treturn TRUE;\n+    }\n+\n+  /* ... or a load-address type pattern.  */\n+  if (GET_CODE (x) == SET && GET_CODE (SET_DEST (x)) == REG)\n+    {\n+      if (s390_decompose_address (SET_SRC (x), &addr)\n+\t  && find_base_register_in_addr (&addr))\n+\treturn TRUE;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+        {\n+          retv |= find_base_register_ref (XEXP (x, i));\n+        }\n+      else if (fmt[i] == 'E')\n+        {\n+          for (j = 0; j < XVECLEN (x, i); j++)\n+            retv |= find_base_register_ref (XVECEXP (x, i, j));\n+        }\n+    }\n+\n+  return retv;\n+}\n+\n+/* If X contains an address that uses the base register,\n+   without actually constituting a literal pool access,\n+   replace the base register with REPL in all such cases.\n+\n+   Handles both MEMs and load address patterns.  */\n+\n+static void\n+replace_base_register_ref (x, repl)\n+     rtx *x;\n+     rtx repl;\n+{\n+  struct s390_address addr;\n+  rtx new_addr;\n+  int i, j, pos;\n+  const char *fmt;\n+\n+  /* Addresses can only occur inside a MEM ...  */\n+  if (GET_CODE (*x) == MEM)\n+    {\n+      if (s390_decompose_address (XEXP (*x, 0), &addr)\n+\t  && (pos = find_base_register_in_addr (&addr)))\n+\t{\n+\t  if (pos == 1)\n+\t    addr.base = repl;\n+\t  else\n+\t    addr.indx = repl;\n+\n+\t  new_addr = addr.base;\n+\t  if (addr.indx)\n+\t    new_addr = gen_rtx_PLUS (Pmode, new_addr, addr.indx);\n+\t  if (addr.disp)\n+\t    new_addr = gen_rtx_PLUS (Pmode, new_addr, addr.disp);\n+\n+\t  *x = replace_equiv_address (*x, new_addr);\n+\t  return;\n+\t}\n+    }\n+\n+  /* ... or a load-address type pattern.  */\n+  if (GET_CODE (*x) == SET && GET_CODE (SET_DEST (*x)) == REG)\n+    {\n+      if (s390_decompose_address (SET_SRC (*x), &addr)\n+\t  && (pos = find_base_register_in_addr (&addr)))\n+\t{\n+\t  if (pos == 1)\n+\t    addr.base = repl;\n+\t  else\n+\t    addr.indx = repl;\n+\n+\t  new_addr = addr.base;\n+\t  if (addr.indx)\n+\t    new_addr = gen_rtx_PLUS (Pmode, new_addr, addr.indx);\n+\t  if (addr.disp)\n+\t    new_addr = gen_rtx_PLUS (Pmode, new_addr, addr.disp);\n+\n+\t  SET_SRC (*x) = new_addr;\n+\t  return;\n+\t}\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (*x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (*x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+        {\n+          replace_base_register_ref (&XEXP (*x, i), repl);\n+        }\n+      else if (fmt[i] == 'E')\n+        {\n+          for (j = 0; j < XVECLEN (*x, i); j++)\n+            replace_base_register_ref (&XVECEXP (*x, i, j), repl);\n+        }\n+    }\n+}\n+\n+\n /* We keep a list of constants we which we have to add to internal\n    constant tables in the middle of large functions.  */\n \n@@ -3210,17 +3376,26 @@ struct constant_pool\n {\n   struct constant_pool *next;\n   rtx first_insn;\n-  rtx last_insn;\n+  rtx pool_insn;\n+  bitmap insns;\n \n   struct constant *constants[NR_C_MODES];\n   rtx label;\n   int size;\n+  bool anchor;\n };\n \n+static struct constant_pool * s390_chunkify_start PARAMS ((rtx, bool *));\n+static void s390_chunkify_finish PARAMS ((struct constant_pool *, rtx));\n+static void s390_chunkify_cancel PARAMS ((struct constant_pool *));\n+\n static struct constant_pool *s390_start_pool PARAMS ((struct constant_pool **, rtx));\n static void s390_end_pool PARAMS ((struct constant_pool *, rtx));\n+static void s390_add_pool_insn PARAMS ((struct constant_pool *, rtx));\n static struct constant_pool *s390_find_pool PARAMS ((struct constant_pool *, rtx));\n-static rtx s390_add_pool PARAMS ((struct constant_pool *, rtx, enum machine_mode));\n+static void s390_add_constant PARAMS ((struct constant_pool *, rtx, enum machine_mode));\n+static rtx s390_find_constant PARAMS ((struct constant_pool *, rtx, enum machine_mode));\n+static void s390_add_anchor PARAMS ((struct constant_pool *));\n static rtx s390_dump_pool PARAMS ((struct constant_pool *));\n static void s390_free_pool PARAMS ((struct constant_pool *));\n \n@@ -3242,24 +3417,43 @@ s390_start_pool (pool_list, insn)\n \n   pool->label = gen_label_rtx ();\n   pool->first_insn = insn;\n-  pool->last_insn = NULL_RTX;\n+  pool->pool_insn = NULL_RTX;\n+  pool->insns = BITMAP_XMALLOC ();\n   pool->size = 0;\n- \n+  pool->anchor = FALSE;\n+\n   for (prev = pool_list; *prev; prev = &(*prev)->next)\n     ;\n   *prev = pool;\n \n   return pool;\n }\n \n-/* End range of instructions covered by POOL at INSN.  */\n+/* End range of instructions covered by POOL at INSN and emit\n+   placeholder insn representing the pool.  */\n \n static void\n s390_end_pool (pool, insn)\n      struct constant_pool *pool;\n      rtx insn;\n {\n-  pool->last_insn = insn;\n+  rtx pool_size = GEN_INT (pool->size + 8 /* alignment slop */);\n+\n+  if (!insn)\n+    insn = get_last_insn ();\n+\n+  pool->pool_insn = emit_insn_after (gen_pool (pool_size), insn);\n+  INSN_ADDRESSES_NEW (pool->pool_insn, -1);\n+}\n+\n+/* Add INSN to the list of insns covered by POOL.  */\n+\n+static void\n+s390_add_pool_insn (pool, insn)\n+     struct constant_pool *pool;\n+     rtx insn;\n+{\n+  bitmap_set_bit (pool->insns, INSN_UID (insn));\n }\n \n /* Return pool out of POOL_LIST that covers INSN.  */\n@@ -3269,33 +3463,24 @@ s390_find_pool (pool_list, insn)\n      struct constant_pool *pool_list;\n      rtx insn;\n {\n-  int addr = INSN_ADDRESSES (INSN_UID (insn));\n   struct constant_pool *pool;\n \n-  if (addr == -1)\n-    return NULL;\n-\n   for (pool = pool_list; pool; pool = pool->next)\n-    if (INSN_ADDRESSES (INSN_UID (pool->first_insn)) <= addr\n-        && (pool->last_insn == NULL_RTX\n-            || INSN_ADDRESSES (INSN_UID (pool->last_insn)) > addr))\n+    if (bitmap_bit_p (pool->insns, INSN_UID (insn)))\n       break;\n \n   return pool;\n }\n \n-/* Add constant VAL of mode MODE to the constant pool POOL.\n-   Return an RTX describing the distance from the start of\n-   the pool to the location of the new constant.  */\n+/* Add constant VAL of mode MODE to the constant pool POOL.  */\n \n-static rtx\n-s390_add_pool (pool, val, mode)\n+static void\n+s390_add_constant (pool, val, mode)\n      struct constant_pool *pool;\n      rtx val;\n      enum machine_mode mode;\n {\n   struct constant *c;\n-  rtx offset;\n   int i;\n \n   for (i = 0; i < NR_C_MODES; i++)\n@@ -3317,13 +3502,54 @@ s390_add_pool (pool, val, mode)\n       pool->constants[i] = c;\n       pool->size += GET_MODE_SIZE (mode);\n     }\n+}\n \n-  offset = gen_rtx_MINUS (Pmode, gen_rtx_LABEL_REF (Pmode, c->label), \n-\t\t\t\t gen_rtx_LABEL_REF (Pmode, pool->label));\n+/* Find constant VAL of mode MODE in the constant pool POOL.\n+   Return an RTX describing the distance from the start of\n+   the pool to the location of the new constant.  */\n+ \n+static rtx\n+s390_find_constant (pool, val, mode)\n+     struct constant_pool *pool;\n+     rtx val;\n+     enum machine_mode mode;\n+{\n+  struct constant *c;\n+  rtx offset;\n+  int i;\n+ \n+  for (i = 0; i < NR_C_MODES; i++)\n+    if (constant_modes[i] == mode)\n+      break;\n+  if (i == NR_C_MODES)\n+    abort ();\n+ \n+  for (c = pool->constants[i]; c != NULL; c = c->next)\n+    if (rtx_equal_p (val, c->value))\n+      break;\n+ \n+  if (c == NULL)\n+    abort ();\n+ \n+  offset = gen_rtx_MINUS (Pmode, gen_rtx_LABEL_REF (Pmode, c->label),\n+                                 gen_rtx_LABEL_REF (Pmode, pool->label));\n   offset = gen_rtx_CONST (Pmode, offset);\n   return offset;\n }\n \n+/* Set 'anchor' flag in POOL.  */\n+\n+static void\n+s390_add_anchor (pool)\n+     struct constant_pool *pool;\n+{\n+  if (!pool->anchor)\n+    {\n+      pool->anchor = TRUE;\n+      pool->size += 4;\n+    }\n+}\n+\n /* Dump out the constants in POOL.  */\n \n static rtx\n@@ -3334,31 +3560,47 @@ s390_dump_pool (pool)\n   rtx insn;\n   int i;\n \n-  /* Select location to put literal pool.  */\n-  if (TARGET_64BIT)\n-    insn = get_last_insn ();\n-  else\n-    insn = pool->last_insn? pool->last_insn : get_last_insn ();\n-\n   /* Pool start insn switches to proper section \n      and guarantees necessary alignment.  */\n   if (TARGET_64BIT)\n-    insn = emit_insn_after (gen_pool_start_64 (), insn);\n+    insn = emit_insn_after (gen_pool_start_64 (), pool->pool_insn);\n   else\n-    insn = emit_insn_after (gen_pool_start_31 (), insn);\n+    insn = emit_insn_after (gen_pool_start_31 (), pool->pool_insn);\n   INSN_ADDRESSES_NEW (insn, -1);\n \n   insn = emit_label_after (pool->label, insn);\n   INSN_ADDRESSES_NEW (insn, -1);\n \n+  /* Emit anchor if we need one.  */\n+  if (pool->anchor)\n+    {\n+      rtx anchor = gen_rtx_LABEL_REF (VOIDmode, pool->label);\n+      anchor = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, anchor), 105);\n+      anchor = gen_rtx_CONST (VOIDmode, anchor);\n+      insn = emit_insn_after (gen_consttable_si (anchor), insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+    }\n+\n   /* Dump constants in descending alignment requirement order,\n      ensuring proper alignment for every constant.  */\n   for (i = 0; i < NR_C_MODES; i++)\n     for (c = pool->constants[i]; c; c = c->next)\n       {\n+\t/* Convert 104 unspecs to pool-relative references.  */\n+\trtx value = c->value;\n+\tif (GET_CODE (value) == CONST\n+\t    && GET_CODE (XEXP (value, 0)) == UNSPEC\n+\t    && XINT (XEXP (value, 0), 1) == 104\n+\t    && XVECLEN (XEXP (value, 0), 0) == 1)\n+\t  {\n+\t    value = gen_rtx_MINUS (Pmode, XVECEXP (XEXP (value, 0), 0, 0),\n+\t    \t\t\t   gen_rtx_LABEL_REF (VOIDmode, pool->label));\n+\t    value = gen_rtx_CONST (VOIDmode, value);\n+\t  }\n+\n \tinsn = emit_label_after (c->label, insn);\n \tINSN_ADDRESSES_NEW (insn, -1);\n-\tinsn = emit_insn_after (gen_consttable[i] (c->value), insn);\n+\tinsn = emit_insn_after (gen_consttable[i] (value), insn);\n \tINSN_ADDRESSES_NEW (insn, -1);\n       }\n \n@@ -3373,6 +3615,9 @@ s390_dump_pool (pool)\n   insn = emit_barrier_after (insn);\n   INSN_ADDRESSES_NEW (insn, -1);\n \n+  /* Remove placeholder insn.  */\n+  remove_insn (pool->pool_insn);\n+\n   return insn;\n }\n \n@@ -3395,65 +3640,86 @@ s390_free_pool (pool)\n \t}\n     }\n \n+  BITMAP_XFREE (pool->insns);\n   free (pool);\n } \n \n-/* Used in s390.md for branch length calculation.  */\n-int s390_pool_overflow = 0;\n \n-/* Chunkify the literal pool if required.  */\n+/* Chunkify the literal pool if required.\n+\n+   Code generated by this routine is allowed to use\n+   TEMP_REG as temporary scratch register.  If this is\n+   done, TEMP_USED is set to true.  */\n \n #define S390_POOL_CHUNK_MIN\t0xc00\n #define S390_POOL_CHUNK_MAX\t0xe00\n \n-static void \n-s390_chunkify_pool ()\n+static struct constant_pool * \n+s390_chunkify_start (temp_reg, temp_used)\n+     rtx temp_reg;\n+     bool *temp_used;\n {\n-  rtx base_reg = gen_rtx_REG (Pmode, \n-\t\t\t      TARGET_64BIT? BASE_REGISTER : RETURN_REGNUM);\n+  rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n \n   struct constant_pool *curr_pool = NULL, *pool_list = NULL;\n   int extra_size = 0;\n   bitmap far_labels;\n   rtx insn;\n \n+  rtx (*gen_reload_base) PARAMS ((rtx, rtx)) =\n+    TARGET_64BIT? gen_reload_base_64 : gen_reload_base_31;\n+\n+\n   /* Do we need to chunkify the literal pool?  */\n \n   if (get_pool_size () < S390_POOL_CHUNK_MAX)\n-    return;\n-\n-  if (!TARGET_64BIT)\n-    regs_ever_live[RETURN_REGNUM] = 1;\n+    return NULL;\n \n   /* We need correct insn addresses.  */\n \n   shorten_branches (get_insns ());\n \n-\n   /* Scan all insns and move literals to pool chunks.\n-     Replace all occurrances of literal pool references\n-     by explicit references to pool chunk entries.  */\n+     Also, emit anchor reload insns before every insn that uses \n+     the literal pool base register as anchor pointer.  */\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == INSN)\n+      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n \t{\n-\t  rtx addr, pool_ref = NULL_RTX;\n+\t  rtx pool_ref = NULL_RTX;\n \t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n \t  if (pool_ref)\n \t    {\n \t      if (!curr_pool)\n \t\tcurr_pool = s390_start_pool (&pool_list, insn);\n \n-\t      addr = s390_add_pool (curr_pool, get_pool_constant (pool_ref), \n-\t\t\t\t\t       get_pool_mode (pool_ref));\n+\t      s390_add_constant (curr_pool, get_pool_constant (pool_ref), \n+\t\t\t\t\t    get_pool_mode (pool_ref));\n+\t      s390_add_pool_insn (curr_pool, insn);\n+\t    }\n+\n+\t  else if (!TARGET_64BIT && flag_pic\n+                   && find_base_register_ref (PATTERN (insn)))\n+\t    {\n+\t      rtx new = gen_reload_anchor (temp_reg, base_reg);\n+\t      new = emit_insn_before (new, insn);\n+\t      INSN_ADDRESSES_NEW (new, INSN_ADDRESSES (INSN_UID (insn)));\n+\t      extra_size += 8;\n+\t      *temp_used = 1;\n+\t      \n+\t      if (!curr_pool)\n+\t\tcurr_pool = s390_start_pool (&pool_list, new);\n \n-\t      addr = gen_rtx_PLUS (Pmode, base_reg, addr);\n-\t      replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n-\t      INSN_CODE (insn) = -1;\n+\t      s390_add_anchor (curr_pool);\n+\t      s390_add_pool_insn (curr_pool, insn);\n \t    }\n \t}\n \n+      if (GET_CODE (insn) == JUMP_INSN || GET_CODE (insn) == CODE_LABEL)\n+\tif (curr_pool)\n+\t  s390_add_pool_insn (curr_pool, insn);\n+\n       if (!curr_pool \n \t  || INSN_ADDRESSES_SIZE () <= (size_t) INSN_UID (insn)\n           || INSN_ADDRESSES (INSN_UID (insn)) == -1)\n@@ -3464,7 +3730,7 @@ s390_chunkify_pool ()\n \t  if (curr_pool->size < S390_POOL_CHUNK_MAX)\n \t    continue;\n \n-\t  s390_end_pool (curr_pool, insn);\n+\t  s390_end_pool (curr_pool, NULL_RTX);\n \t  curr_pool = NULL;\n \t}\n       else\n@@ -3477,11 +3743,8 @@ s390_chunkify_pool ()\n \t     Those will have an effect on code size, which we need to\n \t     consider here.  This calculation makes rather pessimistic\n \t     worst-case assumptions.  */\n-\t  if (GET_CODE (insn) == CODE_LABEL\n-\t      || GET_CODE (insn) == JUMP_INSN)\n+\t  if (GET_CODE (insn) == CODE_LABEL)\n \t    extra_size += 6;\n-\t  else if (GET_CODE (insn) == CALL_INSN)\n-\t    extra_size += 4;\n \n \t  if (chunk_size < S390_POOL_CHUNK_MIN\n \t      && curr_pool->size < S390_POOL_CHUNK_MIN)\n@@ -3497,21 +3760,31 @@ s390_chunkify_pool ()\n \n \t  /* ... so if we don't find one in time, create one.  */\n           else if ((chunk_size > S390_POOL_CHUNK_MAX\n-\t           || curr_pool->size > S390_POOL_CHUNK_MAX)\n-\t          && (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN))\n+\t           || curr_pool->size > S390_POOL_CHUNK_MAX))\n \t    {\n-\t      int addr = INSN_ADDRESSES (INSN_UID (insn));\n               rtx label, jump, barrier;\n \n+\t      /* We can insert the barrier only after a 'real' insn.  */\n+\t      if (GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n+\t\tcontinue;\n+\t      if (get_attr_length (insn) == 0)\n+\t\tcontinue;\n+\n+\t      /* Don't separate insns created by s390_split_branches.  */\n+\t      if (GET_CODE (insn) == INSN \n+\t\t  && GET_CODE (PATTERN (insn)) == SET\n+\t\t  && rtx_equal_p (SET_DEST (PATTERN (insn)), temp_reg))\n+\t\tcontinue;\n+\n  \t      label = gen_label_rtx ();\n \t      jump = emit_jump_insn_after (gen_jump (label), insn);\n \t      barrier = emit_barrier_after (jump);\n \t      insn = emit_label_after (label, barrier);\n \t      JUMP_LABEL (jump) = label;\n \t      LABEL_NUSES (label) = 1;\n \n-\t      INSN_ADDRESSES_NEW (jump, addr+1);\n-\t      INSN_ADDRESSES_NEW (barrier, addr+1);\n+\t      INSN_ADDRESSES_NEW (jump, -1);\n+\t      INSN_ADDRESSES_NEW (barrier, -1);\n \t      INSN_ADDRESSES_NEW (insn, -1);\n \n \t      s390_end_pool (curr_pool, barrier);\n@@ -3521,10 +3794,8 @@ s390_chunkify_pool ()\n \t}\n     }\n \n-  /* Dump out all literal pools.  */\n-\n-  for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n-    s390_dump_pool (curr_pool);\n+  if (curr_pool)\n+    s390_end_pool (curr_pool, NULL_RTX);\n \n \n   /* Find all labels that are branched into \n@@ -3563,20 +3834,7 @@ s390_chunkify_pool ()\n \n           if (GET_CODE (pat) == SET) \n             {\n-\t      rtx label = 0;\n-\n-              if (GET_CODE (SET_SRC (pat)) == LABEL_REF) \n-\t        {\n-\t          label = XEXP (SET_SRC (pat), 0);\n-\t        } \n-              else if (GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE) \n-\t        {\n-\t          if (GET_CODE (XEXP (SET_SRC (pat), 1)) == LABEL_REF) \n-\t            label = XEXP (XEXP (SET_SRC (pat), 1), 0);\n-\t          else if (GET_CODE (XEXP (SET_SRC (pat), 2)) == LABEL_REF) \n-\t            label = XEXP (XEXP (SET_SRC (pat), 2), 0);\n-\t        }\n-\n+\t      rtx label = JUMP_LABEL (insn);\n \t      if (label)\n \t\t{\n \t          if (s390_find_pool (pool_list, label) \n@@ -3617,19 +3875,11 @@ s390_chunkify_pool ()\n   /* Insert base register reload insns before every pool.  */\n \n   for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n-    if (TARGET_64BIT)\n-      {\n-\trtx pool_ref = gen_rtx_LABEL_REF (Pmode, curr_pool->label);\n-\trtx new_insn = gen_rtx_SET (Pmode, base_reg, pool_ref);\n-\trtx insn = curr_pool->first_insn;\n-        INSN_ADDRESSES_NEW (emit_insn_before (new_insn, insn), -1);\n-      }\n-    else\n-      {\n-\trtx new_insn = gen_reload_base (base_reg, curr_pool->label);\n-\trtx insn = curr_pool->first_insn;\n-        INSN_ADDRESSES_NEW (emit_insn_before (new_insn, insn), -1);\n-      }\n+    {\n+      rtx new_insn = gen_reload_base (base_reg, curr_pool->label);\n+      rtx insn = curr_pool->first_insn;\n+      INSN_ADDRESSES_NEW (emit_insn_before (new_insn, insn), -1);\n+    }\n \n   /* Insert base register reload insns at every far label.  */\n \n@@ -3640,69 +3890,144 @@ s390_chunkify_pool ()\n \tstruct constant_pool *pool = s390_find_pool (pool_list, insn);\n \tif (pool)\n \t  {\n-\t    if (TARGET_64BIT)\n-\t      {\n-\t\trtx pool_ref = gen_rtx_LABEL_REF (Pmode, pool->label);\n-\t\trtx new_insn = gen_rtx_SET (Pmode, base_reg, pool_ref);\n-\t        INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n-\t      }\n-\t    else\n-\t      {\n-\t\trtx new_insn = gen_reload_base (base_reg, pool->label);\n-\t        INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n- \t      }\n+\t    rtx new_insn = gen_reload_base (base_reg, pool->label);\n+\t    INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n \t  }\n       }\n \n-  /* Insert base register reload insns after every call if necessary.  */\n-\n-  if (REGNO (base_reg) == RETURN_REGNUM)\n-    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) == CALL_INSN)\n-\t {\n-\t   struct constant_pool *pool = s390_find_pool (pool_list, insn);\n-\t   if (pool)\n-\t     {\n-\t       rtx new_insn = gen_reload_base2 (base_reg, pool->label);\n-\t       INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n-\t     }\n-\t  }\n+\n+  BITMAP_XFREE (far_labels);\n \n \n   /* Recompute insn addresses.  */\n \n-  s390_pool_overflow = 1;\n   init_insn_lengths ();\n   shorten_branches (get_insns ());\n-  s390_pool_overflow = 0;\n \n-  /* Insert base register reload insns after far branches.  */\n+  return pool_list;\n+}\n \n-  if (!TARGET_64BIT)\n-    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) == JUMP_INSN\n-\t  && GET_CODE (PATTERN (insn)) == SET\n-\t  && get_attr_length (insn) >= 12)\n-\t{\n-\t  struct constant_pool *pool = s390_find_pool (pool_list, insn);\n-\t  if (pool)\n+/* POOL_LIST is a chunk list as prepared by s390_chunkify_start.\n+   After we have decided to use this list, finish implementing \n+   all changes to the current function as required.\n+\n+   Code generated by this routine is allowed to use\n+   TEMP_REG as temporary scratch register.  */\n+ \n+static void\n+s390_chunkify_finish (pool_list, temp_reg)\n+     struct constant_pool *pool_list;\n+     rtx temp_reg;\n+{\n+  rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n+  struct constant_pool *curr_pool = NULL;\n+  rtx insn;\n+ \n+ \n+  /* Replace all literal pool references.  */\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn)) \n+    {\n+      curr_pool = s390_find_pool (pool_list, insn);\n+      if (!curr_pool)\n+\tcontinue;\n+\n+      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+        {\n+          rtx addr, pool_ref = NULL_RTX;\n+          find_constant_pool_ref (PATTERN (insn), &pool_ref);\n+          if (pool_ref)\n+            {\n+              addr = s390_find_constant (curr_pool, get_pool_constant (pool_ref),\n+                                                    get_pool_mode (pool_ref));\n+              addr = gen_rtx_PLUS (Pmode, base_reg, addr);\n+              replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n+              INSN_CODE (insn) = -1;\n+            }\n+\n+\t  else if (!TARGET_64BIT && flag_pic\n+                   && find_base_register_ref (PATTERN (insn)))\n \t    {\n-\t      rtx new_insn = gen_reload_base (base_reg, pool->label);\n-\t      INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n+\t      replace_base_register_ref (&PATTERN (insn), temp_reg);\n \t    }\n+        }\n+    }\n+\n+  /* Dump out all literal pools.  */\n+ \n+  for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n+    s390_dump_pool (curr_pool);\n+ \n+  /* Free pool list.  */\n+\n+  while (pool_list)\n+    {\n+      struct constant_pool *next = pool_list->next;\n+      s390_free_pool (pool_list);\n+      pool_list = next;\n+    }\n+}\n+\n+/* POOL_LIST is a chunk list as prepared by s390_chunkify_start.\n+   We have decided we cannot use this list, so revert all changes\n+   to the current function that were done by s390_chunkify_start.  */\n+ \n+static void\n+s390_chunkify_cancel (pool_list)\n+     struct constant_pool *pool_list;\n+{\n+  struct constant_pool *curr_pool = NULL;\n+  rtx insn;\n+\n+  /* Remove all pool placeholder insns.  */\n+\n+  for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n+    {\n+      /* Did we insert an extra barrier?  Remove it.  */\n+      rtx barrier = PREV_INSN (curr_pool->pool_insn);\n+      rtx jump = barrier? PREV_INSN (barrier) : NULL_RTX;\n+      rtx label = NEXT_INSN (curr_pool->pool_insn);\n+\n+      if (jump && GET_CODE (jump) == JUMP_INSN\n+\t  && barrier && GET_CODE (barrier) == BARRIER\n+\t  && label && GET_CODE (label) == CODE_LABEL\n+\t  && GET_CODE (PATTERN (jump)) == SET\n+\t  && SET_DEST (PATTERN (jump)) == pc_rtx\n+\t  && GET_CODE (SET_SRC (PATTERN (jump))) == LABEL_REF\n+\t  && XEXP (SET_SRC (PATTERN (jump)), 0) == label)\n+\t{\n+\t  remove_insn (jump);\n+\t  remove_insn (barrier);\n+\t  remove_insn (label);\n \t}\n \n+      remove_insn (curr_pool->pool_insn);\n+    }\n+\n+  /* Remove all base/anchor register reload insns.  */\n+\n+  for (insn = get_insns (); insn; )\n+    {\n+      rtx next_insn = NEXT_INSN (insn);\n+\n+      if (GET_CODE (insn) == INSN\n+\t  && GET_CODE (PATTERN (insn)) == SET\n+\t  && GET_CODE (SET_SRC (PATTERN (insn))) == UNSPEC\n+\t  && (XINT (SET_SRC (PATTERN (insn)), 1) == 210\n+\t      || XINT (SET_SRC (PATTERN (insn)), 1) == 211))\n+\tremove_insn (insn);\n \n-  /* Free all memory.  */\n+      insn = next_insn;\n+    }\n+\n+  /* Free pool list.  */\n \n   while (pool_list)\n     {\n       struct constant_pool *next = pool_list->next;\n       s390_free_pool (pool_list);\n       pool_list = next;\n     }\n-\n-  BITMAP_XFREE (far_labels);\n }\n \n \n@@ -3745,19 +4070,51 @@ s390_output_constant_pool (file)\n       else\n         fprintf (file, \".LTN%d:\\n\", current_function_funcdef_no);\n     }\n+\n+  /* If no pool required, at least output the anchor label.  */\n+  else if (!TARGET_64BIT && flag_pic)\n+    fprintf (file, \".LT%d:\\n\", current_function_funcdef_no);\n }\n \n \n /* Rework the prolog/epilog to avoid saving/restoring\n-   registers unnecessarily.  */\n+   registers unnecessarily.  If TEMP_REGNO is nonnegative,\n+   it specifies the number of a caller-saved register used \n+   as temporary scratch register by code emitted during \n+   machine dependent reorg.  */\n \n static void\n-s390_optimize_prolog ()\n+s390_optimize_prolog (temp_regno)\n+     int temp_regno;\n {\n   int save_first, save_last, restore_first, restore_last;\n   int i, j;\n   rtx insn, new_insn, next_insn;\n \n+  struct s390_frame frame;\n+  s390_frame_info (&frame);\n+\n+  /* Recompute regs_ever_live data for special registers.  */\n+  regs_ever_live[BASE_REGISTER] = 0;\n+  regs_ever_live[RETURN_REGNUM] = 0;\n+  regs_ever_live[STACK_POINTER_REGNUM] = frame.frame_size > 0;\n+\n+  /* If there is (possibly) any pool entry, we need to\n+     load the base register.  \n+     ??? FIXME: this should be more precise.  */\n+  if (get_pool_size ())\n+    regs_ever_live[BASE_REGISTER] = 1;\n+\n+  /* In non-leaf functions, the prolog/epilog code relies \n+     on RETURN_REGNUM being saved in any case.  */\n+  if (!current_function_is_leaf)\n+    regs_ever_live[RETURN_REGNUM] = 1;\n+\n+  /* We need to save/restore the temporary register.  */\n+  if (temp_regno >= 0)\n+    regs_ever_live[temp_regno] = 1;\n+\n+\n   /* Find first and last gpr to be saved.  */\n   \n   for (i = 6; i < 16; i++)\n@@ -3865,34 +4222,146 @@ s390_optimize_prolog ()\n     }\n }\n \n+/* Check whether any insn in the function makes use of the original\n+   value of RETURN_REG (e.g. for __builtin_return_address).\n+   If so, insert an insn reloading that value.\n+\n+   Return true if any such insn was found.  */\n+\n+static bool\n+s390_fixup_clobbered_return_reg (return_reg)\n+    rtx return_reg;\n+{\n+  bool replacement_done = 0;\n+  rtx insn;\n+\n+  struct s390_frame frame;\n+  s390_frame_info (&frame);\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx reg, off, new_insn;\n+\n+      if (GET_CODE (insn) != INSN)\n+\tcontinue;\n+      if (!reg_referenced_p (return_reg, PATTERN (insn)))\n+\tcontinue;\n+      if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t  && store_multiple_operation (PATTERN (insn), VOIDmode))\n+\tcontinue;\n+\n+      if (frame.frame_pointer_p)\n+\treg = hard_frame_pointer_rtx;\n+      else\n+\treg = stack_pointer_rtx;\n+\n+      off = GEN_INT (frame.frame_size + REGNO (return_reg) * UNITS_PER_WORD);\n+      if (INTVAL (off) >= 4096)\n+\t{\n+\t  off = force_const_mem (Pmode, off);\n+\t  new_insn = gen_rtx_SET (Pmode, return_reg, off);\n+\t  new_insn = emit_insn_before (new_insn, insn);\n+\t  INSN_ADDRESSES_NEW (new_insn, -1);\n+\t  off = return_reg;\n+\t}\n+\n+      new_insn = gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, reg, off));\n+      new_insn = gen_rtx_SET (Pmode, return_reg, new_insn);\n+      new_insn = emit_insn_before (new_insn, insn);\n+      INSN_ADDRESSES_NEW (new_insn, -1);\n+\n+      replacement_done = 1;\n+    }\n+\n+  return replacement_done;\n+}\n+\n /* Perform machine-dependent processing.  */\n \n void\n s390_machine_dependent_reorg (first)\n      rtx first ATTRIBUTE_UNUSED;\n {\n-  struct s390_frame frame;\n-  s390_frame_info (&frame);\n+  bool fixed_up_clobbered_return_reg = 0;\n+  rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n+  bool temp_used = 0;\n \n-  /* Recompute regs_ever_live data for special registers.  */\n-  regs_ever_live[BASE_REGISTER] = 0;\n-  regs_ever_live[RETURN_REGNUM] = 0;\n-  regs_ever_live[STACK_POINTER_REGNUM] = frame.frame_size > 0;\n+  /* Make sure all splits have been performed; splits after\n+     machine_dependent_reorg might confuse insn length counts.  */\n+  split_all_insns_noflow ();\n \n-  /* If there is (possibly) any pool entry, we need to\n-     load the base register.  \n-     ??? FIXME: this should be more precise.  */\n-  if (get_pool_size ())\n-    regs_ever_live[BASE_REGISTER] = 1;\n \n-  /* In non-leaf functions, the prolog/epilog code relies \n-     on RETURN_REGNUM being saved in any case.  */\n-  if (!current_function_is_leaf)\n-    regs_ever_live[RETURN_REGNUM] = 1;\n+  /* There are two problematic situations we need to correct:\n+ \n+     - the literal pool might be > 4096 bytes in size, so that\n+       some of its elements cannot be directly accessed\n+ \n+     - a branch target might be > 64K away from the branch, so that\n+       it is not possible to use a PC-relative instruction.\n+ \n+     To fix those, we split the single literal pool into multiple\n+     pool chunks, reloading the pool base register at various\n+     points throughout the function to ensure it always points to\n+     the pool chunk the following code expects, and / or replace\n+     PC-relative branches by absolute branches.\n+ \n+     However, the two problems are interdependent: splitting the\n+     literal pool can move a branch further away from its target,\n+     causing the 64K limit to overflow, and on the other hand,\n+     replacing a PC-relative branch by an absolute branch means\n+     we need to put the branch target address into the literal\n+     pool, possibly causing it to overflow.\n+ \n+     So, we loop trying to fix up both problems until we manage\n+     to satisfy both conditions at the same time.  Note that the\n+     loop is guaranteed to terminate as every pass of the loop\n+     strictly decreases the total number of PC-relative branches\n+     in the function.  (This is not completely true as there\n+     might be branch-over-pool insns introduced by chunkify_start.\n+     Those never need to be split however.)  */\n+ \n+  for (;;)\n+    {\n+      struct constant_pool *pool_list;\n+ \n+      /* Try to chunkify the literal pool.  */\n+      pool_list = s390_chunkify_start (temp_reg, &temp_used);\n+\n+      /* Split out-of-range branches.  If this has created new\n+\t literal pool entries, cancel current chunk list and\n+\t recompute it.  */\n+      if (s390_split_branches (temp_reg, &temp_used))\n+        {\n+          if (pool_list)\n+            s390_chunkify_cancel (pool_list);\n+ \n+          continue;\n+        }\n+\n+      /* Check whether we have clobbered a use of the return\n+\t register (e.g. for __builtin_return_address).  If so,\n+\t add insns reloading the register where necessary.  */\n+      if (temp_used && !fixed_up_clobbered_return_reg\n+\t  && s390_fixup_clobbered_return_reg (temp_reg))\n+\t{\n+\t  fixed_up_clobbered_return_reg = 1;\n \n-  s390_chunkify_pool ();\n-  s390_split_branches ();\n-  s390_optimize_prolog ();\n+\t  /* The fixup insns might have caused a jump to overflow.  */\n+\t  if (pool_list)\n+\t    s390_chunkify_cancel (pool_list);\n+\n+\t  continue;\n+\t}\n+ \n+      /* If we made it up to here, both conditions are satisfied.\n+\t Finish up pool chunkification if required.  */\n+      if (pool_list)\n+\ts390_chunkify_finish (pool_list, temp_reg);\n+ \n+      break;\n+    }\n+ \n+  s390_optimize_prolog (temp_used? RETURN_REGNUM : -1);\n }\n \n "}, {"sha": "4b992c38b1c512f7d19a40db4aa1b80accf3f8bf", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c", "patch": "@@ -1299,7 +1299,6 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n \n extern int s390_pool_count;\n extern int s390_nr_constants;\n-extern int s390_pool_overflow;\n \n #define ASM_OUTPUT_POOL_PROLOGUE(FILE, FUNNAME, fndecl, size)  \t        \\\n {\t\t\t\t\t\t\t\t       \t\\"}, {"sha": "e998c4de7636e6917fd8d46fe1b054b225a89a02", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=aee4e0dbfa31eabba0faf4f5a6d7b04373d9914c", "patch": "@@ -5724,9 +5724,6 @@\n                 (const_int 4)\n                (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n                  (const_int 6)\n-\t       (ne (symbol_ref \"s390_pool_overflow\") (const_int 0))\n-                 (if_then_else (eq (symbol_ref \"flag_pic\") (const_int 0))\n-                               (const_int 12) (const_int 14))\n                (eq (symbol_ref \"flag_pic\") (const_int 0))\n                  (const_int 6)] (const_int 8)))])\n \n@@ -5776,9 +5773,6 @@\n                 (const_int 4)\n                (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n                  (const_int 6)\n-\t       (ne (symbol_ref \"s390_pool_overflow\") (const_int 0))\n-                 (if_then_else (eq (symbol_ref \"flag_pic\") (const_int 0))\n-                               (const_int 12) (const_int 14))\n                (eq (symbol_ref \"flag_pic\") (const_int 0))\n                  (const_int 6)] (const_int 8)))])\n \n@@ -5888,9 +5882,6 @@\n                 (const_int 4)\n                (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n                  (const_int 10)\n-\t       (ne (symbol_ref \"s390_pool_overflow\") (const_int 0))\n-                 (if_then_else (eq (symbol_ref \"flag_pic\") (const_int 0))\n-                               (const_int 12) (const_int 14))\n                (eq (symbol_ref \"flag_pic\") (const_int 0))\n                  (const_int 6)] (const_int 8)))])\n \n@@ -6707,7 +6698,7 @@\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"0\")])\n \n-(define_insn \"reload_base\"\n+(define_insn \"reload_base_31\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n         (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] 210))]\n   \"!TARGET_64BIT\"\n@@ -6716,15 +6707,29 @@\n    (set_attr \"type\"    \"la\")\n    (set_attr \"length\"  \"6\")])\n \n-(define_insn \"reload_base2\"\n+(define_insn \"reload_base_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+        (unspec:DI [(label_ref (match_operand 1 \"\" \"\"))] 210))]\n+  \"TARGET_64BIT\"\n+  \"larl\\\\t%0,%1\"\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"    \"la\")])\n+\n+(define_insn \"reload_anchor\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-        (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] 211))]\n+        (unspec:SI [(match_operand:SI 1 \"register_operand\" \"a\")] 211))]\n   \"!TARGET_64BIT\"\n-  \"la\\\\t%0,%1-.(%0)\"\n+  \"l\\\\t%0,0(%1)\\;la\\\\t%0,0(%0,%1)\"\n   [(set_attr \"op_type\" \"NN\")\n    (set_attr \"type\"    \"la\")\n-   (set_attr \"length\"  \"4\")])\n+   (set_attr \"length\"  \"8\")])\n \n+(define_insn \"pool\"\n+  [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"n\")] 220)]\n+  \"\"\n+  \"* abort ();\"\n+  [(set_attr \"op_type\" \"NN\")\n+   (set (attr \"length\") (symbol_ref \"INTVAL (operands[0])\"))])\n \n ;;\n ;; Insns related to generating the function prologue and epilogue."}]}