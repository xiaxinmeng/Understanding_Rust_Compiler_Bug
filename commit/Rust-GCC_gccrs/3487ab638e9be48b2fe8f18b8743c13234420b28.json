{"sha": "3487ab638e9be48b2fe8f18b8743c13234420b28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ4N2FiNjM4ZTliZTQ4YjJmZThmMThiODc0M2MxMzIzNDQyMGIyOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-10-30T19:13:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-10-30T19:13:47Z"}, "message": "* tree.c\n\t(free_lang_data_d, add_tree_to_fld_list, fld_worklist_push): Move\n\thead in file.\n\t(free_lang_data_in_type): Forward declare.\n\t(fld_type_variant_equal_p): New function.\n\t(fld_type_variant): New function\n\t(fld_incomplete_types): New hash.\n\t(fld_incomplete_type_of): New function\n\t(fld_simplfied-type): New function.\n\t(free_lang_data_in_decl): Add fld parameter; simplify type of FIELD_DECL\n\t(free_lang_data): Allocate and free fld_incomplete_type; update call\n\tof free_lang_data_in_decl.\n\nFrom-SVN: r265638", "tree": {"sha": "59112306dd4319d0c32c7ee888a10ce1dfeec3b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59112306dd4319d0c32c7ee888a10ce1dfeec3b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3487ab638e9be48b2fe8f18b8743c13234420b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3487ab638e9be48b2fe8f18b8743c13234420b28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3487ab638e9be48b2fe8f18b8743c13234420b28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3487ab638e9be48b2fe8f18b8743c13234420b28/comments", "author": null, "committer": null, "parents": [{"sha": "190facef83142f0b226b72d93abca4ee21347bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/190facef83142f0b226b72d93abca4ee21347bfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/190facef83142f0b226b72d93abca4ee21347bfa"}], "stats": {"total": 228, "additions": 181, "deletions": 47}, "files": [{"sha": "91cc761bc425c4a649c7642d4974cd78a5fc6743", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3487ab638e9be48b2fe8f18b8743c13234420b28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3487ab638e9be48b2fe8f18b8743c13234420b28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3487ab638e9be48b2fe8f18b8743c13234420b28", "patch": "@@ -1,3 +1,18 @@\n+2018-10-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree.c\n+\t(free_lang_data_d, add_tree_to_fld_list, fld_worklist_push): Move\n+\thead in file.\n+\t(free_lang_data_in_type): Forward declare.\n+\t(fld_type_variant_equal_p): New function.\n+\t(fld_type_variant): New function\n+\t(fld_incomplete_types): New hash.\n+\t(fld_incomplete_type_of): New function\n+\t(fld_simplfied-type): New function.\n+\t(free_lang_data_in_decl): Add fld parameter; simplify type of FIELD_DECL\n+\t(free_lang_data): Allocate and free fld_incomplete_type; update call\n+\tof free_lang_data_in_decl.\n+\n 2018-10-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcov.c (output_lines): Remove duplicate line."}, {"sha": "472b6082be96beb30bcaac289ced9bb30a4c826c", "filename": "gcc/tree.c", "status": "modified", "additions": 166, "deletions": 47, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3487ab638e9be48b2fe8f18b8743c13234420b28/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3487ab638e9be48b2fe8f18b8743c13234420b28/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3487ab638e9be48b2fe8f18b8743c13234420b28", "patch": "@@ -5037,7 +5037,163 @@ protected_set_expr_location (tree t, location_t loc)\n   if (CAN_HAVE_LOCATION_P (t))\n     SET_EXPR_LOCATION (t, loc);\n }\n+\n+/* Data used when collecting DECLs and TYPEs for language data removal.  */\n+\n+struct free_lang_data_d\n+{\n+  free_lang_data_d () : decls (100), types (100) {}\n+\n+  /* Worklist to avoid excessive recursion.  */\n+  auto_vec<tree> worklist;\n+\n+  /* Set of traversed objects.  Used to avoid duplicate visits.  */\n+  hash_set<tree> pset;\n+\n+  /* Array of symbols to process with free_lang_data_in_decl.  */\n+  auto_vec<tree> decls;\n+\n+  /* Array of types to process with free_lang_data_in_type.  */\n+  auto_vec<tree> types;\n+};\n+\n+\n+/* Add type or decl T to one of the list of tree nodes that need their\n+   language data removed.  The lists are held inside FLD.  */\n+\n+static void\n+add_tree_to_fld_list (tree t, struct free_lang_data_d *fld)\n+{\n+  if (DECL_P (t))\n+    fld->decls.safe_push (t);\n+  else if (TYPE_P (t))\n+    fld->types.safe_push (t);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Push tree node T into FLD->WORKLIST.  */\n+\n+static inline void\n+fld_worklist_push (tree t, struct free_lang_data_d *fld)\n+{\n+  if (t && !is_lang_specific (t) && !fld->pset.contains (t))\n+    fld->worklist.safe_push ((t));\n+}\n+\n+\n \f\n+/* Do same comparsion as check_qualified_type skipping lang part of type\n+   and be more permissive about type names: we only care that names are\n+   same (for diagnostics) and that ODR names are the same.  */\n+\n+static bool\n+fld_type_variant_equal_p (tree t, tree v)\n+{\n+  if (TYPE_QUALS (t) != TYPE_QUALS (v)\n+      || TYPE_NAME (t) != TYPE_NAME (v)\n+      || TYPE_ALIGN (t) != TYPE_ALIGN (v)\n+      || !attribute_list_equal (TYPE_ATTRIBUTES (t),\n+\t\t\t        TYPE_ATTRIBUTES (v)))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Find variant of FIRST that match T and create new one if necessary.  */\n+\n+static tree\n+fld_type_variant (tree first, tree t, struct free_lang_data_d *fld)\n+{\n+  if (first == TYPE_MAIN_VARIANT (t))\n+    return t;\n+  for (tree v = first; v; v = TYPE_NEXT_VARIANT (v))\n+    if (fld_type_variant_equal_p (t, v))\n+      return v;\n+  tree v = build_variant_type_copy (first);\n+  TYPE_READONLY (v) = TYPE_READONLY (t);\n+  TYPE_VOLATILE (v) = TYPE_VOLATILE (t);\n+  TYPE_ATOMIC (v) = TYPE_ATOMIC (t);\n+  TYPE_RESTRICT (v) = TYPE_RESTRICT (t);\n+  TYPE_ADDR_SPACE (v) = TYPE_ADDR_SPACE (t);\n+  TYPE_NAME (v) = TYPE_NAME (t);\n+  TYPE_ATTRIBUTES (v) = TYPE_ATTRIBUTES (t);\n+  add_tree_to_fld_list (v, fld);\n+  return v;\n+}\n+\n+/* Map complete types to incomplete types.  */\n+\n+static hash_map<tree, tree> *fld_incomplete_types;\n+\n+/* For T being aggregate type try to turn it into a incomplete variant.\n+   Return T if no simplification is possible.  */\n+\n+static tree\n+fld_incomplete_type_of (tree t, struct free_lang_data_d *fld)\n+{\n+  if (!t)\n+    return NULL;\n+  if (POINTER_TYPE_P (t))\n+    {\n+      tree t2 = fld_incomplete_type_of (TREE_TYPE (t), fld);\n+      if (t2 != TREE_TYPE (t))\n+\t{\n+\t  tree first;\n+\t  if (TREE_CODE (t) == POINTER_TYPE)\n+\t    first = build_pointer_type_for_mode (t2, TYPE_MODE (t),\n+\t\t\t\t\t\tTYPE_REF_CAN_ALIAS_ALL (t));\n+\t  else\n+\t    first = build_reference_type_for_mode (t2, TYPE_MODE (t),\n+\t\t\t\t\t\tTYPE_REF_CAN_ALIAS_ALL (t));\n+\t  add_tree_to_fld_list (first, fld);\n+\t  return fld_type_variant (first, t, fld);\n+\t}\n+      return t;\n+    }\n+  if (!RECORD_OR_UNION_TYPE_P (t) || !COMPLETE_TYPE_P (t))\n+    return t;\n+  if (TYPE_MAIN_VARIANT (t) == t)\n+    {\n+      bool existed;\n+      tree &copy\n+\t = fld_incomplete_types->get_or_insert (t, &existed);\n+\n+      if (!existed)\n+\t{\n+\t  copy = build_distinct_type_copy (t);\n+\n+\t  /* It is possible type was not seen by free_lang_data yet.  */\n+\t  add_tree_to_fld_list (copy, fld);\n+\t  TYPE_SIZE (copy) = NULL;\n+\t  SET_TYPE_MODE (copy, VOIDmode);\n+\t  SET_TYPE_ALIGN (copy, BITS_PER_UNIT);\n+\t  TYPE_SIZE_UNIT (copy) = NULL;\n+\t  if (AGGREGATE_TYPE_P (t))\n+\t    {\n+\t      TYPE_FIELDS (copy) = NULL;\n+\t      TYPE_BINFO (copy) = NULL;\n+\t    }\n+\t  else\n+\t    TYPE_VALUES (copy) = NULL;\n+\t}\n+      return copy;\n+   }\n+  return (fld_type_variant\n+\t    (fld_incomplete_type_of (TYPE_MAIN_VARIANT (t), fld), t, fld));\n+}\n+\n+/* Simplify type T for scenarios where we do not need complete pointer\n+   types.  */\n+\n+static tree\n+fld_simplified_type (tree t, struct free_lang_data_d *fld)\n+{\n+  if (t && POINTER_TYPE_P (t))\n+    return fld_incomplete_type_of (t, fld);\n+  return t;\n+}\n+\n /* Reset the expression *EXPR_P, a size or position.\n \n    ??? We could reset all non-constant sizes or positions.  But it's cheap\n@@ -5261,7 +5417,7 @@ need_assembler_name_p (tree decl)\n    DECL.  */\n \n static void\n-free_lang_data_in_decl (tree decl)\n+free_lang_data_in_decl (tree decl, struct free_lang_data_d *fld)\n {\n   gcc_assert (DECL_P (decl));\n \n@@ -5356,7 +5512,10 @@ free_lang_data_in_decl (tree decl)\n       DECL_ORIGINAL_TYPE (decl) = NULL_TREE;\n     }\n   else if (TREE_CODE (decl) == FIELD_DECL)\n-    DECL_INITIAL (decl) = NULL_TREE;\n+    {\n+      TREE_TYPE (decl) = fld_simplified_type (TREE_TYPE (decl), fld);\n+      DECL_INITIAL (decl) = NULL_TREE;\n+    }\n   else if (TREE_CODE (decl) == TRANSLATION_UNIT_DECL\n            && DECL_INITIAL (decl)\n            && TREE_CODE (DECL_INITIAL (decl)) == BLOCK)\n@@ -5400,50 +5559,6 @@ free_lang_data_in_decl (tree decl)\n }\n \n \n-/* Data used when collecting DECLs and TYPEs for language data removal.  */\n-\n-struct free_lang_data_d\n-{\n-  free_lang_data_d () : decls (100), types (100) {}\n-\n-  /* Worklist to avoid excessive recursion.  */\n-  auto_vec<tree> worklist;\n-\n-  /* Set of traversed objects.  Used to avoid duplicate visits.  */\n-  hash_set<tree> pset;\n-\n-  /* Array of symbols to process with free_lang_data_in_decl.  */\n-  auto_vec<tree> decls;\n-\n-  /* Array of types to process with free_lang_data_in_type.  */\n-  auto_vec<tree> types;\n-};\n-\n-\n-/* Add type or decl T to one of the list of tree nodes that need their\n-   language data removed.  The lists are held inside FLD.  */\n-\n-static void\n-add_tree_to_fld_list (tree t, struct free_lang_data_d *fld)\n-{\n-  if (DECL_P (t))\n-    fld->decls.safe_push (t);\n-  else if (TYPE_P (t))\n-    fld->types.safe_push (t);\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Push tree node T into FLD->WORKLIST.  */\n-\n-static inline void\n-fld_worklist_push (tree t, struct free_lang_data_d *fld)\n-{\n-  if (t && !is_lang_specific (t) && !fld->pset.contains (t))\n-    fld->worklist.safe_push ((t));\n-}\n-\n-\n /* Operand callback helper for free_lang_data_in_node.  *TP is the\n    subtree operand being considered.  */\n \n@@ -5841,7 +5956,7 @@ free_lang_data_in_cgraph (void)\n \n   /* Traverse every decl found freeing its language data.  */\n   FOR_EACH_VEC_ELT (fld.decls, i, t)\n-    free_lang_data_in_decl (t);\n+    free_lang_data_in_decl (t, &fld);\n \n   /* Traverse every type found freeing its language data.  */\n   FOR_EACH_VEC_ELT (fld.types, i, t)\n@@ -5866,6 +5981,8 @@ free_lang_data (void)\n       || (!flag_generate_lto && !flag_generate_offload))\n     return 0;\n \n+  fld_incomplete_types = new hash_map<tree, tree>;\n+\n   /* Provide a dummy TRANSLATION_UNIT_DECL if the FE failed to provide one.  */\n   if (vec_safe_is_empty (all_translation_units))\n     build_translation_unit_decl (NULL_TREE);\n@@ -5904,6 +6021,8 @@ free_lang_data (void)\n \n   rebuild_type_inheritance_graph ();\n \n+  delete fld_incomplete_types;\n+\n   return 0;\n }\n "}]}