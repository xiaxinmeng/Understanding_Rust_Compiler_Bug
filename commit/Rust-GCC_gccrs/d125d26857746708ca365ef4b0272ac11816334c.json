{"sha": "d125d26857746708ca365ef4b0272ac11816334c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEyNWQyNjg1Nzc0NjcwOGNhMzY1ZWY0YjAyNzJhYzExODE2MzM0Yw==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "2000-01-03T21:48:49Z"}, "committer": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "2000-01-03T21:48:49Z"}, "message": "(format_char_info): Update comment.\n\n(format_char_info): Update comment.  (check_format_info): Recognize 'z'\nmodifier in the same way 'Z' was recognized.  Emit warning for formats\nnew in ISO C99 only if flag_isoc9x is not set.\n\nFrom-SVN: r31188", "tree": {"sha": "cf1de20a2babdde3897e0eb905cd0658b1000cb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf1de20a2babdde3897e0eb905cd0658b1000cb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d125d26857746708ca365ef4b0272ac11816334c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d125d26857746708ca365ef4b0272ac11816334c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d125d26857746708ca365ef4b0272ac11816334c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d125d26857746708ca365ef4b0272ac11816334c/comments", "author": null, "committer": null, "parents": [{"sha": "0bd209d9bf36adaf990613f4e7f3c591a9caa5f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd209d9bf36adaf990613f4e7f3c591a9caa5f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bd209d9bf36adaf990613f4e7f3c591a9caa5f6"}], "stats": {"total": 85, "additions": 42, "deletions": 43}, "files": [{"sha": "665710b77851f622ee86f0b55f43e659062cd28d", "filename": "gcc/c-common.c", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d125d26857746708ca365ef4b0272ac11816334c/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d125d26857746708ca365ef4b0272ac11816334c/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=d125d26857746708ca365ef4b0272ac11816334c", "patch": "@@ -42,7 +42,7 @@ enum cpp_token cpp_token;\n #define WCHAR_TYPE_SIZE TYPE_PRECISION (wchar_type_node)\n \n /* The following symbols are subsumed in the c_global_trees array, and\n-   listed here individually for documentation purposes. \n+   listed here individually for documentation purposes.\n \n    INTEGER_TYPE and REAL_TYPE nodes for the standard data types.\n \n@@ -537,11 +537,11 @@ decl_attributes (node, attributes, prefix_attributes)\n      anything done here.  */\n   PRAGMA_INSERT_ATTRIBUTES (node, & attributes, & prefix_attributes);\n #endif\n-  \n+\n #ifdef INSERT_ATTRIBUTES\n   INSERT_ATTRIBUTES (node, & attributes, & prefix_attributes);\n #endif\n-  \n+\n   attributes = chainon (prefix_attributes, attributes);\n \n   for (a = attributes; a; a = TREE_CHAIN (a))\n@@ -775,7 +775,7 @@ decl_attributes (node, attributes, prefix_attributes)\n \t      = (args ? TREE_VALUE (args)\n \t\t : size_int (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n \t    int align;\n-\t    \n+\n \t    /* Strip any NOPs of any kind.  */\n \t    while (TREE_CODE (align_expr) == NOP_EXPR\n \t\t   || TREE_CODE (align_expr) == CONVERT_EXPR\n@@ -821,7 +821,7 @@ decl_attributes (node, attributes, prefix_attributes)\n \t\t\t \"argument format specified for non-function `%s'\");\n \t\tcontinue;\n \t      }\n-\t\n+\n \t    if (TREE_CODE (format_type_id) != IDENTIFIER_NODE)\n \t      {\n \t\terror (\"unrecognized format specifier\");\n@@ -830,7 +830,7 @@ decl_attributes (node, attributes, prefix_attributes)\n \t    else\n \t      {\n \t\tconst char *p = IDENTIFIER_POINTER (format_type_id);\n-\t\t\n+\n \t\tif (!strcmp (p, \"printf\") || !strcmp (p, \"__printf__\"))\n \t\t  format_type = printf_format_type;\n \t\telse if (!strcmp (p, \"scanf\") || !strcmp (p, \"__scanf__\"))\n@@ -1195,7 +1195,7 @@ typedef struct {\n   /* Type of argument if length modifier `L' is used.\n      If NULL, then this modifier is not allowed.  */\n   tree *bigllen;\n-  /* Type of argument if length modifier `Z' is used.\n+  /* Type of argument if length modifiers 'z' or `Z' is used.\n      If NULL, then this modifier is not allowed.  */\n   tree *zlen;\n   /* List of other modifier characters allowed with these options.  */\n@@ -1250,7 +1250,7 @@ static format_char_info time_char_table[] = {\n   { \"HIMSUWdemw\",\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0Ow\" },\n   { \"Vju\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0Oow\" },\n   { \"Gklsz\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0OGw\" },\n-  { \"ABZa\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"^#\" },\n+  { \"ABZza\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"^#\" },\n   { \"p\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"#\" },\n   { \"bh\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"^\" },\n   { \"CY\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0EOw\" },\n@@ -1764,26 +1764,25 @@ check_format_info (info, params)\n \t\twarning (\"ANSI C does not support the `%c' length modifier\",\n \t\t\t length_char);\n \t    }\n-\t  else if (*format_chars == 'Z')\n+\t  else if (*format_chars == 'Z' || *format_chars == 'z')\n \t    {\n \t      length_char = *format_chars++;\n-\t      if (pedantic)\n-\t\twarning (\"ANSI C does not support the `Z' length modifier\");\n+\t      if (pedantic && (length_char == 'Z' || !flag_isoc9x))\n+\t\twarning (\"ANSI C does not support the `%c' length modifier\",\n+\t\t\t length_char);\n \t    }\n \t  else\n \t    length_char = 0;\n \t  if (length_char == 'l' && *format_chars == 'l')\n \t    {\n \t      length_char = 'q', format_chars++;\n-\t      /* FIXME: Is allowed in ISO C 9x.  */\n-\t      if (pedantic)\n+\t      if (pedantic && !flag_isoc9x)\n \t\twarning (\"ANSI C does not support the `ll' length modifier\");\n \t    }\n \t  else if (length_char == 'h' && *format_chars == 'h')\n \t    {\n \t      length_char = 'H', format_chars++;\n-\t      /* FIXME: Is allowed in ISO C 9x.  */\n-\t      if (pedantic)\n+\t      if (pedantic && !flag_isoc9x)\n \t\twarning (\"ANSI C does not support the `hh' length modifier\");\n \t    }\n \t  if (*format_chars == 'a' && info->format_type == scanf_format_type)\n@@ -1810,10 +1809,10 @@ check_format_info (info, params)\n       if (pedantic && info->format_type != strftime_format_type\n \t  && (format_char == 'm' || format_char == 'C' || format_char == 'S'))\n \twarning (\"ANSI C does not support the `%c' format\", format_char);\n-      /* ??? The a and A formats are C9X extensions, and should be allowed\n-\t when a C9X option is added.  */\n+      /* The a and A formats are C99 extensions.  */\n       if (pedantic && info->format_type != strftime_format_type\n-\t  && (format_char == 'a' || format_char == 'A'))\n+\t  && (format_char == 'a' || format_char == 'A')\n+\t  && !flag_isoc9x)\n \twarning (\"ANSI C does not support the `%c' format\", format_char);\n       format_chars++;\n       switch (info->format_type)\n@@ -1912,7 +1911,7 @@ check_format_info (info, params)\n \tcase 'l': wanted_type = fci->llen ? *(fci->llen) : 0; break;\n \tcase 'q': wanted_type = fci->qlen ? *(fci->qlen) : 0; break;\n \tcase 'L': wanted_type = fci->bigllen ? *(fci->bigllen) : 0; break;\n-\tcase 'Z': wanted_type = fci->zlen ? *fci->zlen : 0; break;\n+\tcase 'z': case 'Z': wanted_type = fci->zlen ? *fci->zlen : 0; break;\n \t}\n       if (wanted_type == 0)\n \twarning (\"use of `%c' length character with `%c' type character\",\n@@ -2259,7 +2258,7 @@ type_for_mode (mode, unsignedp)\n     return unsignedp ? long_long_unsigned_type_node : long_long_integer_type_node;\n \n   if (mode == TYPE_MODE (widest_integer_literal_type_node))\n-    return unsignedp ? widest_unsigned_literal_type_node \n+    return unsignedp ? widest_unsigned_literal_type_node\n                      : widest_integer_literal_type_node;\n \n   if (mode == TYPE_MODE (intQI_type_node))\n@@ -2380,16 +2379,16 @@ signed_or_unsigned_type (unsignedp, type)\n \n   if (TYPE_PRECISION (type) == TYPE_PRECISION (signed_char_type_node))\n     return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)) \n+  if (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node))\n     return unsignedp ? unsigned_type_node : integer_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (short_integer_type_node)) \n+  if (TYPE_PRECISION (type) == TYPE_PRECISION (short_integer_type_node))\n     return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (long_integer_type_node)) \n+  if (TYPE_PRECISION (type) == TYPE_PRECISION (long_integer_type_node))\n     return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (long_long_integer_type_node)) \n+  if (TYPE_PRECISION (type) == TYPE_PRECISION (long_long_integer_type_node))\n     return (unsignedp ? long_long_unsigned_type_node\n \t    : long_long_integer_type_node);\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (widest_integer_literal_type_node)) \n+  if (TYPE_PRECISION (type) == TYPE_PRECISION (widest_integer_literal_type_node))\n     return (unsignedp ? widest_unsigned_literal_type_node\n \t    : widest_integer_literal_type_node);\n   return type;\n@@ -3265,9 +3264,9 @@ c_apply_type_quals_to_decl (type_quals, decl)\n \t     alias set for the type pointed to by the type of the\n \t     decl.  */\n \n-\t  int pointed_to_alias_set \n+\t  int pointed_to_alias_set\n \t    = get_alias_set (TREE_TYPE (TREE_TYPE (decl)));\n-\t  \n+\n \t  if (!pointed_to_alias_set)\n \t    /* It's not legal to make a subset of alias set zero.  */\n \t    ;\n@@ -3301,7 +3300,7 @@ c_find_base_decl (t)\n \n   decl = NULL_TREE;\n \n-  if (TREE_CODE (t) == FIELD_DECL \n+  if (TREE_CODE (t) == FIELD_DECL\n       || TREE_CODE (t) == PARM_DECL\n       || TREE_CODE (t) == VAR_DECL)\n     /* Aha, we found a pointer-typed declaration.  */\n@@ -3397,7 +3396,7 @@ c_get_alias_set (t)\n       && DECL_BIT_FIELD_TYPE (TREE_OPERAND (t, 1)))\n     /* Since build_modify_expr calls get_unwidened for stores to\n        component references, the type of a bit field can be changed\n-       from (say) `unsigned int : 16' to `unsigned short' or from \n+       from (say) `unsigned int : 16' to `unsigned short' or from\n        `enum E : 16' to `short'.  We want the real type of the\n        bit-field in this case, not some the integral equivalent.  */\n     type = DECL_BIT_FIELD_TYPE (TREE_OPERAND (t, 1));\n@@ -3434,7 +3433,7 @@ c_get_alias_set (t)\n   else if (TREE_CODE (type) == FUNCTION_TYPE)\n     /* There are no objects of FUNCTION_TYPE, so there's no point in\n        using up an alias set for them.  (There are, of course,\n-       pointers and references to functions, but that's \n+       pointers and references to functions, but that's\n        different.)  */\n     TYPE_ALIAS_SET (type) = 0;\n   else if (TREE_CODE (type) == RECORD_TYPE\n@@ -3454,7 +3453,7 @@ c_get_alias_set (t)\n \t In particular, if we have `typedef int I', then `int *', and\n \t `I *' are different types.  So, we have to pick a canonical\n \t representative.  We do this below.\n-\t \n+\n \t Technically, this approach is actually more conservative that\n \t it needs to be.  In particular, `const int *' and `int *'\n \t chould be in different alias sets, according to the C and C++\n@@ -3480,7 +3479,7 @@ c_get_alias_set (t)\n \tTYPE_ALIAS_SET (type) = c_get_alias_set (t);\n     }\n \n-  if (!TYPE_ALIAS_SET_KNOWN_P (type)) \n+  if (!TYPE_ALIAS_SET_KNOWN_P (type))\n     {\n       /* Types that are not allocated on the permanent obstack are not\n \t placed in the type hash table.  Thus, there can be multiple\n@@ -3498,9 +3497,9 @@ c_get_alias_set (t)\n }\n \n /* Build tree nodes and builtin functions common to both C and C++ language\n-   frontends.  \n+   frontends.\n    CPLUS_MODE is nonzero if we are called from the C++ frontend, we generate\n-   some stricter prototypes in that case. \n+   some stricter prototypes in that case.\n    NO_BUILTINS and NO_NONANSI_BUILTINS contain the respective values of\n    the language frontend flags flag_no_builtin and\n    flag_no_nonansi_builtin.  */\n@@ -3761,23 +3760,23 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n \t\t    BUILT_IN_STRCPY, BUILT_IN_NORMAL, \"strcpy\");\n   builtin_function (\"__builtin_strlen\", strlen_ftype,\n \t\t    BUILT_IN_STRLEN, BUILT_IN_NORMAL, \"strlen\");\n-  builtin_function (\"__builtin_sqrtf\", float_ftype_float, \n+  builtin_function (\"__builtin_sqrtf\", float_ftype_float,\n \t\t    BUILT_IN_FSQRT, BUILT_IN_NORMAL, \"sqrtf\");\n   builtin_function (\"__builtin_fsqrt\", double_ftype_double,\n \t\t    BUILT_IN_FSQRT, BUILT_IN_NORMAL, \"sqrt\");\n   builtin_function (\"__builtin_sqrtl\", ldouble_ftype_ldouble,\n \t\t    BUILT_IN_FSQRT, BUILT_IN_NORMAL, \"sqrtl\");\n-  builtin_function (\"__builtin_sinf\", float_ftype_float, \n+  builtin_function (\"__builtin_sinf\", float_ftype_float,\n \t\t    BUILT_IN_SIN, BUILT_IN_NORMAL, \"sinf\");\n-  builtin_function (\"__builtin_sin\", double_ftype_double, \n+  builtin_function (\"__builtin_sin\", double_ftype_double,\n \t\t    BUILT_IN_SIN, BUILT_IN_NORMAL, \"sin\");\n-  builtin_function (\"__builtin_sinl\", ldouble_ftype_ldouble, \n+  builtin_function (\"__builtin_sinl\", ldouble_ftype_ldouble,\n \t\t    BUILT_IN_SIN, BUILT_IN_NORMAL, \"sinl\");\n-  builtin_function (\"__builtin_cosf\", float_ftype_float, \n+  builtin_function (\"__builtin_cosf\", float_ftype_float,\n \t\t    BUILT_IN_COS, BUILT_IN_NORMAL, \"cosf\");\n-  builtin_function (\"__builtin_cos\", double_ftype_double, \n+  builtin_function (\"__builtin_cos\", double_ftype_double,\n \t\t    BUILT_IN_COS, BUILT_IN_NORMAL, \"cos\");\n-  builtin_function (\"__builtin_cosl\", ldouble_ftype_ldouble, \n+  builtin_function (\"__builtin_cosl\", ldouble_ftype_ldouble,\n \t\t    BUILT_IN_COS, BUILT_IN_NORMAL, \"cosl\");\n \n   if (! no_builtins)\n@@ -3883,9 +3882,9 @@ build_va_arg (expr, type)\n \f\n /* Given a type, apply default promotions wrt unnamed function arguments\n    and return the new type.  Return NULL_TREE if no change.  */\n-/* ??? There is a function of the same name in the C++ front end that \n+/* ??? There is a function of the same name in the C++ front end that\n    does something similar, but is more thorough and does not return NULL\n-   if no change.  We could perhaps share code, but it would make the \n+   if no change.  We could perhaps share code, but it would make the\n    self_promoting_type property harder to identify.  */\n \n tree"}]}