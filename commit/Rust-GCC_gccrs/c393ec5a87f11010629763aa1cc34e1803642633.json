{"sha": "c393ec5a87f11010629763aa1cc34e1803642633", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM5M2VjNWE4N2YxMTAxMDYyOTc2M2FhMWNjMzRlMTgwMzY0MjYzMw==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2008-10-18T23:02:17Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-10-18T23:02:17Z"}, "message": "stl_pair.h (__may_be_null_pointer_init): New.\n\n2008-10-18  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* include/bits/stl_pair.h (__may_be_null_pointer_init): New.\n\t(pair::pair): Eliminate the redundant pair(U1&&, U2&&) constructor.\n\tAdd lvalue pair<U1, U2> constructor to handle non-const pair lvalues.\n\tRemove the old variadic constructor, and instead provide several\n\tvariadic constructors that avoid failing when attempting to\n\tinitialize a pointer from a null pointer constant.\n\t* testsuite/20_util/pair/moveable.cc (test3): Add new tests with\n\tinitialization of pointers from the null pointer constant.\n\nFrom-SVN: r141214", "tree": {"sha": "ff25247aece9e9b8e144f8ebe19cfb4acc03bbf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff25247aece9e9b8e144f8ebe19cfb4acc03bbf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c393ec5a87f11010629763aa1cc34e1803642633", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c393ec5a87f11010629763aa1cc34e1803642633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c393ec5a87f11010629763aa1cc34e1803642633", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c393ec5a87f11010629763aa1cc34e1803642633/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3cdf0c6237613202df8fa9f7e27bec61178122d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cdf0c6237613202df8fa9f7e27bec61178122d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cdf0c6237613202df8fa9f7e27bec61178122d5"}], "stats": {"total": 147, "additions": 138, "deletions": 9}, "files": [{"sha": "cbbc0efe65253da09e3710fb8b6c8428a972a17c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c393ec5a87f11010629763aa1cc34e1803642633/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c393ec5a87f11010629763aa1cc34e1803642633/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c393ec5a87f11010629763aa1cc34e1803642633", "patch": "@@ -1,3 +1,14 @@\n+2008-10-18  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\t* include/bits/stl_pair.h (__may_be_null_pointer_init): New.\n+\t(pair::pair): Eliminate the redundant pair(U1&&, U2&&) constructor.\n+\tAdd lvalue pair<U1, U2> constructor to handle non-const pair lvalues.\n+\tRemove the old variadic constructor, and instead provide several\n+\tvariadic constructors that avoid failing when attempting to\n+\tinitialize a pointer from a null pointer constant.\n+\t* testsuite/20_util/pair/moveable.cc (test3): Add new tests with\n+\tinitialization of pointers from the null pointer constant.\n+\n 2008-10-17  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/bits/forward_list.tcc (forward_list<>::"}, {"sha": "c169275ece3f5c91436bab9a41ec252246f2190e", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 82, "deletions": 9, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c393ec5a87f11010629763aa1cc34e1803642633/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c393ec5a87f11010629763aa1cc34e1803642633/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=c393ec5a87f11010629763aa1cc34e1803642633", "patch": "@@ -65,8 +65,35 @@\n #include <bits/move.h> // for std::move / std::forward, std::decay, and\n                        // std::swap\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <type_traits>\n+#endif\n+\n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+// A trait that determines whether the initialization of a T from\n+// arguments of type Args could possibly be the initialization of a\n+// pointer from a null pointer constant.\n+template<typename, typename...>\n+struct __may_be_null_pointer_init \n+  : public false_type { };\n+\n+template<typename _Tp, typename _Up>\n+struct __may_be_null_pointer_init<_Tp*, _Up>  \n+  : public integral_constant<bool,\n+             (is_integral<typename remove_reference<_Up>::type>::value \n+              || is_enum<typename remove_reference<_Up>::type>::value)> \n+  { };\n+\n+template<typename _Class, typename _Tp, typename _Up>\n+struct __may_be_null_pointer_init<_Tp _Class::*, _Up>  \n+  : public integral_constant<bool,\n+             (is_integral<typename remove_reference<_Up>::type>::value \n+              || is_enum<typename remove_reference<_Up>::type>::value)> \n+  { };\n+#endif\n+\n   /// pair holds two objects of arbitrary type.\n   template<class _T1, class _T2>\n     struct pair\n@@ -89,10 +116,12 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       : first(__a), second(__b) { }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      template<class _U1, class _U2>\n-        pair(_U1&& __x, _U2&& __y)\n-\t: first(std::forward<_U1>(__x)),\n-\t  second(std::forward<_U2>(__y)) { }\n+      // Omitted the following constructor, which appears in the C++0x\n+      // working paper but is redundant with the variadic constructors\n+      // below.\n+      //\n+      //   template<class _U1, class _U2>\n+      //     pair(_U1&& __x, _U2&& __y);\n \n       pair(pair&& __p)\n       : first(std::move(__p.first)),\n@@ -111,12 +140,56 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t: first(std::move(__p.first)),\n \t  second(std::move(__p.second)) { }\n \n-      // http://gcc.gnu.org/ml/libstdc++/2007-08/msg00052.html\n-      template<class _U1, class _Arg0, class... _Args>\n-        pair(_U1&& __x, _Arg0&& __arg0, _Args&&... __args)\n+      // This constructor is required so that lvalue pairs don't get\n+      // pushed to the variadic constructor below.\n+      template<class _U1, class _U2>\n+        pair(pair<_U1, _U2>& __p)\n+          : first(const_cast<const pair<_U1, _U2>&>(__p).first),\n+  \t    second(const_cast<const pair<_U1, _U2>&>(__p).second) { }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 811.  pair of pointers no longer works with literal 0\n+\n+      // Variadic constructor. The enable_if makes sure that we won't\n+      // try to initialize a pointer from an integral type, which\n+      // needs to be handled by a different constructor that will\n+      // convert a null pointer constant to that pointer type. See\n+      // library issue 767.\n+      template<class _U1, class... _Args,\n+        class _Checker \n+          = typename enable_if<\n+                       (!__may_be_null_pointer_init<_T1, _U1>::value\n+                        && !__may_be_null_pointer_init<_T2, _Args...>::value), \n+                     void>::type>\n+        pair(_U1&& __x, _Args&&... __args)\n+\t: first(std::forward<_U1>(__x)),\n+\t  second(std::forward<_Args>(__args)...) { }\n+\n+      // Variadic constructor. The enable_if makes sure that the\n+      // second argument isn't going to try to initialize a pointer\n+      // from an integral type. However, T1 may be a pointer whose\n+      // argument was a null pointer constant.\n+      template<class... _Args,\n+        class _Checker \n+          = typename enable_if<\n+                       !__may_be_null_pointer_init<_T2, _Args...>::value, \n+                     void>::type>\n+        pair(const _T1& __x, _Args&&... __args)\n+\t: first(__x),\n+\t  second(std::forward<_Args>(__args)...) { }\n+\n+      // Constructor typically used when T2 is a pointer and the\n+      // second argument was a null pointer constant. The enable_if\n+      // makes sure that the first argument isn't going to try to\n+      // initialize a pointer from an integral type.\n+      template<class _U1,\n+        class _Checker \n+          = typename enable_if<\n+                     !__may_be_null_pointer_init<_T1, _U1>::value,\n+                     void>::type>\n+        pair(_U1&& __x, const _T2& __y)\n \t: first(std::forward<_U1>(__x)),\n-\t  second(std::forward<_Arg0>(__arg0),\n-\t\t std::forward<_Args>(__args)...) { }\n+\t  second(__y) { }\n \n       pair&\n       operator=(pair&& __p)"}, {"sha": "4e5c53583cd6b4f13776dd30a3fc512aff96a314", "filename": "libstdc++-v3/testsuite/20_util/pair/moveable.cc", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c393ec5a87f11010629763aa1cc34e1803642633/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c393ec5a87f11010629763aa1cc34e1803642633/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fmoveable.cc?ref=c393ec5a87f11010629763aa1cc34e1803642633", "patch": "@@ -64,9 +64,54 @@ test2()\n          r.second.size() == 2 && p.second.size() == 0);\n }\n \n+struct X { \n+  explicit X(int, int) { }\n+\n+private:\n+  X(const X&) = delete;\n+};\n+\n+struct move_only {\n+  move_only() { }\n+  move_only(move_only&&) { }\n+\n+private:\n+  move_only(const move_only&) = delete;\n+};\n+\n+void\n+test3()\n+{\n+  int *ip = 0;\n+  int X::*mp = 0;\n+  std::pair<int*, int*> p1(0, 0);\n+  std::pair<int*, int*> p2(ip, 0);\n+  std::pair<int*, int*> p3(0, ip);\n+  std::pair<int*, int*> p4(ip, ip);\n+\n+  std::pair<int X::*, int*> p5(0, 0);\n+  std::pair<int X::*, int X::*> p6(mp, 0);\n+  std::pair<int X::*, int X::*> p7(0, mp);\n+  std::pair<int X::*, int X::*> p8(mp, mp);\n+\n+  std::pair<int*, X> p9(0, 1, 2);\n+  std::pair<int X::*, X> p10(0, 1, 2);\n+  std::pair<int*, X> p11(ip, 1, 2);\n+  std::pair<int X::*, X> p12(mp, 1, 2);\n+\n+  std::pair<int*, move_only> p13(0);\n+  std::pair<int X::*, move_only> p14(0);\n+\n+  std::pair<int*, move_only> p15(0, move_only());\n+  std::pair<int X::*, move_only> p16(0, move_only());\n+  std::pair<move_only, int*> p17(move_only(), 0);\n+  std::pair<move_only, int X::*> p18(move_only(), 0);\n+}\n+\n int \n main() \n {\n   test1();\n   test2();\n+  test3();\n }"}]}