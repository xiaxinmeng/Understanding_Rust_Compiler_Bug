{"sha": "d5e07b79f448ea911bda0acb00c57795eb96e7fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVlMDdiNzlmNDQ4ZWE5MTFiZGEwYWNiMDBjNTc3OTVlYjk2ZTdmYw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-11-22T14:53:03Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-11-22T14:53:03Z"}, "message": "re PR libstdc++/24975 (Aliasing problems inside libstdc++)\n\n2005-11-22  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/24975\n\t* include/bits/stl_set.h (insert(iterator, const value_type&),\n\terase(iterator), erase(iterator, iterator)): Don't break aliasing\n\trules casting to _Rep_iterator&, forward to _Rb_tree facilities.\n\t* include/bits/stl_multiset.h (insert(iterator, const value_type&),\n\terase(iterator), erase(iterator, iterator)): Likewise.\n\t* include/bits/stl_tree.h (_Rb_tree<>::_M_insert(_Const_Base_ptr,\n\t_Const_Base_ptr, const value_type&), insert_unique(const_iterator,\n\tconst value_type&), insert_equal(const_iterator, const value_type&),\n\terase(const_iterator), erase(const_iterator, const_iterator)): New,\n\t_Rb_tree<>::const_iterator counterparts of existing facilities.\n\nFrom-SVN: r107362", "tree": {"sha": "4692df2ab32a99fb35a2951790770a5fc8a14b34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4692df2ab32a99fb35a2951790770a5fc8a14b34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5e07b79f448ea911bda0acb00c57795eb96e7fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e07b79f448ea911bda0acb00c57795eb96e7fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5e07b79f448ea911bda0acb00c57795eb96e7fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e07b79f448ea911bda0acb00c57795eb96e7fc/comments", "author": null, "committer": null, "parents": [{"sha": "d66437c5fefeb55405daacce3a9272f9b2ff31dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d66437c5fefeb55405daacce3a9272f9b2ff31dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d66437c5fefeb55405daacce3a9272f9b2ff31dd"}], "stats": {"total": 240, "additions": 205, "deletions": 35}, "files": [{"sha": "8517757ea00339efe3d76316ce46028ddd147281", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e07b79f448ea911bda0acb00c57795eb96e7fc/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e07b79f448ea911bda0acb00c57795eb96e7fc/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d5e07b79f448ea911bda0acb00c57795eb96e7fc", "patch": "@@ -1,3 +1,17 @@\n+2005-11-22  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/24975\n+\t* include/bits/stl_set.h (insert(iterator, const value_type&),\n+\terase(iterator), erase(iterator, iterator)): Don't break aliasing\n+\trules casting to _Rep_iterator&, forward to _Rb_tree facilities.\n+\t* include/bits/stl_multiset.h (insert(iterator, const value_type&),\n+\terase(iterator), erase(iterator, iterator)): Likewise.\n+\t* include/bits/stl_tree.h (_Rb_tree<>::_M_insert(_Const_Base_ptr,\n+\t_Const_Base_ptr, const value_type&), insert_unique(const_iterator,\n+\tconst value_type&), insert_equal(const_iterator, const value_type&),\n+\terase(const_iterator), erase(const_iterator, const_iterator)): New,\n+\t_Rb_tree<>::const_iterator counterparts of existing facilities.\n+\n 2005-11-21  Benjamin Kosnik  <bkoz@redhat.com>\n             Ulrich Drepper  <drepper@redhat.com>\n "}, {"sha": "185f51ce989ffb2b7d2eccea265bb06ae581d1f0", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e07b79f448ea911bda0acb00c57795eb96e7fc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e07b79f448ea911bda0acb00c57795eb96e7fc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=d5e07b79f448ea911bda0acb00c57795eb96e7fc", "patch": "@@ -331,10 +331,7 @@ namespace _GLIBCXX_STD\n        */\n       iterator\n       insert(iterator __position, const value_type& __x)\n-      {\n-\ttypedef typename _Rep_type::iterator _Rep_iterator;\n-\treturn _M_t.insert_equal((_Rep_iterator&)__position, __x);\n-      }\n+      { return _M_t.insert_equal(__position, __x); }\n \n       /**\n        *  @brief A template function that attemps to insert a range of elements.\n@@ -361,10 +358,7 @@ namespace _GLIBCXX_STD\n        */\n       void\n       erase(iterator __position)\n-      {\n-\ttypedef typename _Rep_type::iterator _Rep_iterator;\n-\t_M_t.erase((_Rep_iterator&)__position);\n-      }\n+      { _M_t.erase(__position); }\n \n       /**\n        *  @brief Erases elements according to the provided key.\n@@ -394,10 +388,7 @@ namespace _GLIBCXX_STD\n        */\n       void\n       erase(iterator __first, iterator __last)\n-      {\n-\ttypedef typename _Rep_type::iterator _Rep_iterator;\n-\t_M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last);\n-      }\n+      { _M_t.erase(__first, __last); }\n \n       /**\n        *  Erases all elements in a %multiset.  Note that this function only"}, {"sha": "1172e509311eece15698cf96aa3d21c792818d3d", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e07b79f448ea911bda0acb00c57795eb96e7fc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e07b79f448ea911bda0acb00c57795eb96e7fc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=d5e07b79f448ea911bda0acb00c57795eb96e7fc", "patch": "@@ -343,10 +343,7 @@ namespace _GLIBCXX_STD\n        */\n       iterator\n       insert(iterator __position, const value_type& __x)\n-      {\n-\ttypedef typename _Rep_type::iterator _Rep_iterator;\n-\treturn _M_t.insert_unique((_Rep_iterator&)__position, __x);\n-      }\n+      { return _M_t.insert_unique(__position, __x); }\n \n       /**\n        *  @brief A template function that attemps to insert a range of elements.\n@@ -357,9 +354,9 @@ namespace _GLIBCXX_STD\n        *  Complexity similar to that of the range constructor.\n        */\n       template<class _InputIterator>\n-      void\n-      insert(_InputIterator __first, _InputIterator __last)\n-      { _M_t.insert_unique(__first, __last); }\n+        void\n+        insert(_InputIterator __first, _InputIterator __last)\n+        { _M_t.insert_unique(__first, __last); }\n \n       /**\n        *  @brief Erases an element from a %set.\n@@ -372,10 +369,7 @@ namespace _GLIBCXX_STD\n        */\n       void\n       erase(iterator __position)\n-      {\n-\ttypedef typename _Rep_type::iterator _Rep_iterator;\n-\t_M_t.erase((_Rep_iterator&)__position);\n-      }\n+      { _M_t.erase(__position); }\n \n       /**\n        *  @brief Erases elements according to the provided key.\n@@ -389,7 +383,8 @@ namespace _GLIBCXX_STD\n        *  in any way.  Managing the pointer is the user's responsibilty.\n        */\n       size_type\n-      erase(const key_type& __x) { return _M_t.erase(__x); }\n+      erase(const key_type& __x)\n+      { return _M_t.erase(__x); }\n \n       /**\n        *  @brief Erases a [first,last) range of elements from a %set.\n@@ -404,10 +399,7 @@ namespace _GLIBCXX_STD\n        */\n       void\n       erase(iterator __first, iterator __last)\n-      {\n-\ttypedef typename _Rep_type::iterator _Rep_iterator;\n-\t_M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last);\n-      }\n+      { _M_t.erase(__first, __last); }\n \n       /**\n        *  Erases all elements in a %set.  Note that this function only erases"}, {"sha": "13088ca75550d298c9d2992af533fb307b8a867b", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 180, "deletions": 7, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e07b79f448ea911bda0acb00c57795eb96e7fc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e07b79f448ea911bda0acb00c57795eb96e7fc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=d5e07b79f448ea911bda0acb00c57795eb96e7fc", "patch": "@@ -539,6 +539,10 @@ namespace std\n       iterator\n       _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);\n \n+      const_iterator\n+      _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __y,\n+\t\tconst value_type& __v);\n+\n       _Link_type\n       _M_copy(_Const_Link_type __x, _Link_type __p);\n \n@@ -647,9 +651,15 @@ namespace std\n       iterator\n       insert_unique(iterator __position, const value_type& __x);\n \n+      const_iterator\n+      insert_unique(const_iterator __position, const value_type& __x);\n+\n       iterator\n       insert_equal(iterator __position, const value_type& __x);\n \n+      const_iterator\n+      insert_equal(const_iterator __position, const value_type& __x);\n+\n       template<typename _InputIterator>\n         void\n         insert_unique(_InputIterator __first, _InputIterator __last);\n@@ -661,12 +671,18 @@ namespace std\n       void\n       erase(iterator __position);\n \n+      void\n+      erase(const_iterator __position);\n+\n       size_type\n       erase(const key_type& __x);\n \n       void\n       erase(iterator __first, iterator __last);\n \n+      void\n+      erase(const_iterator __first, const_iterator __last);\n+\n       void\n       erase(const key_type* __first, const key_type* __last);\n \n@@ -808,6 +824,25 @@ namespace std\n       return iterator(__z);\n     }\n \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)\n+    {\n+      bool __insert_left = (__x != 0 || __p == _M_end()\n+\t\t\t    || _M_impl._M_key_compare(_KeyOfValue()(__v), \n+\t\t\t\t\t\t      _S_key(__p)));\n+\n+      _Link_type __z = _M_create_node(__v);\n+\n+      _Rb_tree_insert_and_rebalance(__insert_left, __z,\n+\t\t\t\t    const_cast<_Base_ptr>(__p),  \n+\t\t\t\t    this->_M_impl._M_header);\n+      ++_M_impl._M_node_count;\n+      return const_iterator(__z);\n+    }\n+\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n@@ -954,6 +989,63 @@ namespace std\n \treturn __position; // Equivalent keys.\n     }\n \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    insert_unique(const_iterator __position, const _Val& __v)\n+    {\n+      // end()\n+      if (__position._M_node == _M_end())\n+\t{\n+\t  if (size() > 0\n+\t      && _M_impl._M_key_compare(_S_key(_M_rightmost()), \n+\t\t\t\t\t_KeyOfValue()(__v)))\n+\t    return _M_insert(0, _M_rightmost(), __v);\n+\t  else\n+\t    return const_iterator(insert_unique(__v).first);\n+\t}\n+      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n+\t\t\t\t      _S_key(__position._M_node)))\n+\t{\n+\t  // First, try before...\n+\t  const_iterator __before = __position;\n+\t  if (__position._M_node == _M_leftmost()) // begin()\n+\t    return _M_insert(_M_leftmost(), _M_leftmost(), __v);\n+\t  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), \n+\t\t\t\t\t  _KeyOfValue()(__v)))\n+\t    {\n+\t      if (_S_right(__before._M_node) == 0)\n+\t\treturn _M_insert(0, __before._M_node, __v);\n+\t      else\n+\t\treturn _M_insert(__position._M_node,\n+\t\t\t\t __position._M_node, __v);\n+\t    }\n+\t  else\n+\t    return const_iterator(insert_unique(__v).first);\n+\t}\n+      else if (_M_impl._M_key_compare(_S_key(__position._M_node),\n+\t\t\t\t      _KeyOfValue()(__v)))\n+\t{\n+\t  // ... then try after.\n+\t  const_iterator __after = __position;\n+\t  if (__position._M_node == _M_rightmost())\n+\t    return _M_insert(0, _M_rightmost(), __v);\n+\t  else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n+\t\t\t\t\t  _S_key((++__after)._M_node)))\n+\t    {\n+\t      if (_S_right(__position._M_node) == 0)\n+\t\treturn _M_insert(0, __position._M_node, __v);\n+\t      else\n+\t\treturn _M_insert(__after._M_node, __after._M_node, __v);\n+\t    }\n+\t  else\n+\t    return const_iterator(insert_unique(__v).first);\n+\t}\n+      else\n+\treturn __position; // Equivalent keys.\n+    }\n+\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n@@ -1008,6 +1100,60 @@ namespace std\n \t}\n     }\n \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    insert_equal(const_iterator __position, const _Val& __v)\n+    {\n+      // end()\n+      if (__position._M_node == _M_end())\n+\t{\n+\t  if (size() > 0\n+\t      && !_M_impl._M_key_compare(_KeyOfValue()(__v),\n+\t\t\t\t\t _S_key(_M_rightmost())))\n+\t    return _M_insert(0, _M_rightmost(), __v);\n+\t  else\n+\t    return const_iterator(insert_equal(__v));\n+\t}\n+      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),\n+\t\t\t\t       _KeyOfValue()(__v)))\n+\t{\n+\t  // First, try before...\n+\t  const_iterator __before = __position;\n+\t  if (__position._M_node == _M_leftmost()) // begin()\n+\t    return _M_insert(_M_leftmost(), _M_leftmost(), __v);\n+\t  else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),\n+\t\t\t\t\t   _S_key((--__before)._M_node)))\n+\t    {\n+\t      if (_S_right(__before._M_node) == 0)\n+\t\treturn _M_insert(0, __before._M_node, __v);\n+\t      else\n+\t\treturn _M_insert(__position._M_node,\n+\t\t\t\t __position._M_node, __v);\n+\t    }\n+\t  else\n+\t    return const_iterator(insert_equal(__v));\n+\t}\n+      else\n+\t{\n+\t  // ... then try after.  \n+\t  const_iterator __after = __position;\n+\t  if (__position._M_node == _M_rightmost())\n+\t    return _M_insert(0, _M_rightmost(), __v);\n+\t  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),\n+\t\t\t\t\t   _KeyOfValue()(__v)))\n+\t    {\n+\t      if (_S_right(__position._M_node) == 0)\n+\t\treturn _M_insert(0, __position._M_node, __v);\n+\t      else\n+\t\treturn _M_insert(__after._M_node, __after._M_node, __v);\n+\t    }\n+\t  else\n+\t    return const_iterator(insert_equal(__v));\n+\t}\n+    }\n+\n   template<typename _Key, typename _Val, typename _KoV,\n            typename _Cmp, typename _Alloc>\n     template<class _II>\n@@ -1022,13 +1168,13 @@ namespace std\n   template<typename _Key, typename _Val, typename _KoV,\n            typename _Cmp, typename _Alloc>\n     template<class _II>\n-    void\n-    _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::\n-    insert_unique(_II __first, _II __last)\n-    {\n-      for (; __first != __last; ++__first)\n-\tinsert_unique(end(), *__first);\n-    }\n+      void\n+      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::\n+      insert_unique(_II __first, _II __last)\n+      {\n+\tfor (; __first != __last; ++__first)\n+\t  insert_unique(end(), *__first);\n+      }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n@@ -1044,6 +1190,20 @@ namespace std\n       --_M_impl._M_node_count;\n     }\n \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    inline void\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    erase(const_iterator __position)\n+    {\n+      _Link_type __y =\n+\tstatic_cast<_Link_type>(_Rb_tree_rebalance_for_erase\n+\t\t\t\t(const_cast<_Base_ptr>(__position._M_node),\n+\t\t\t\t this->_M_impl._M_header));\n+      destroy_node(__y);\n+      --_M_impl._M_node_count;\n+    }\n+\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type\n@@ -1121,6 +1281,19 @@ namespace std\n \t  erase(__first++);\n     }\n \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    void\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    erase(const_iterator __first, const_iterator __last)\n+    {\n+      if (__first == begin() && __last == end())\n+\tclear();\n+      else\n+\twhile (__first != __last)\n+\t  erase(__first++);\n+    }\n+\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     void"}]}