{"sha": "372d6395266c651119da7da9b870d0dd8ec56d6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcyZDYzOTUyNjZjNjUxMTE5ZGE3ZGE5Yjg3MGQwZGQ4ZWM1NmQ2Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-05-09T09:22:57Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-05-09T09:22:57Z"}, "message": "re PR bootstrap/53249 (Bootstrap failure)\n\ngcc/\n\tPR middle-end/53249\n\t* dwarf2out.h (get_address_mode): Move declaration to...\n\t* rtl.h: ...here.\n\t* dwarf2out.c (get_address_mode): Move definition to...\n\t* rtlanal.c: ...here.\n\t* var-tracking.c (get_address_mode): Delete.\n\t* combine.c (find_split_point): Use get_address_mode instead of\n\ttargetm.addr_space.address_mode.\n\t* cselib.c (cselib_record_sets): Likewise.\n\t* dse.c (canon_address, record_store): Likewise.\n\t* emit-rtl.c (adjust_address_1, offset_address): Likewise.\n\t* expr.c (move_by_pieces, emit_block_move_via_loop, store_by_pieces)\n\t(store_by_pieces_1, expand_assignment, store_expr, store_constructor)\n\t(expand_expr_real_1): Likewise.\n\t* ifcvt.c (noce_try_cmove_arith): Likewise.\n\t* optabs.c (maybe_legitimize_operand_same_code): Likewise.\n\t* reload.c (find_reloads): Likewise.\n\t* sched-deps.c (sched_analyze_1, sched_analyze_2): Likewise.\n\t* sel-sched-dump.c (debug_mem_addr_value): Likewise.\n\nFrom-SVN: r187320", "tree": {"sha": "66becb49e2a6ddf4ae20c76c905c9a2f85112ee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66becb49e2a6ddf4ae20c76c905c9a2f85112ee3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/372d6395266c651119da7da9b870d0dd8ec56d6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/372d6395266c651119da7da9b870d0dd8ec56d6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/372d6395266c651119da7da9b870d0dd8ec56d6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/372d6395266c651119da7da9b870d0dd8ec56d6c/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45d05c5fecb93383a55db7c024e3ccb3137fe4a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d05c5fecb93383a55db7c024e3ccb3137fe4a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d05c5fecb93383a55db7c024e3ccb3137fe4a5"}], "stats": {"total": 131, "additions": 61, "deletions": 70}, "files": [{"sha": "7f7c9e5e3facec3b623fa44e016e21608cc682b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -1,3 +1,25 @@\n+2012-05-09  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tPR middle-end/53249\n+\t* dwarf2out.h (get_address_mode): Move declaration to...\n+\t* rtl.h: ...here.\n+\t* dwarf2out.c (get_address_mode): Move definition to...\n+\t* rtlanal.c: ...here.\n+\t* var-tracking.c (get_address_mode): Delete.\n+\t* combine.c (find_split_point): Use get_address_mode instead of\n+\ttargetm.addr_space.address_mode.\n+\t* cselib.c (cselib_record_sets): Likewise.\n+\t* dse.c (canon_address, record_store): Likewise.\n+\t* emit-rtl.c (adjust_address_1, offset_address): Likewise.\n+\t* expr.c (move_by_pieces, emit_block_move_via_loop, store_by_pieces)\n+\t(store_by_pieces_1, expand_assignment, store_expr, store_constructor)\n+\t(expand_expr_real_1): Likewise.\n+\t* ifcvt.c (noce_try_cmove_arith): Likewise.\n+\t* optabs.c (maybe_legitimize_operand_same_code): Likewise.\n+\t* reload.c (find_reloads): Likewise.\n+\t* sched-deps.c (sched_analyze_1, sched_analyze_2): Likewise.\n+\t* sel-sched-dump.c (debug_mem_addr_value): Likewise.\n+\n 2012-05-09  Maciej W. Rozycki  <macro@codesourcery.com>\n \n \t* config/mips/mips.c (mips16_gp_pseudo_reg): Remove line"}, {"sha": "d23ecfcbccd7aeead245594ca65de5440941f4c9", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -4611,8 +4611,7 @@ find_split_point (rtx *loc, rtx insn, bool set_src)\n       if (GET_CODE (XEXP (x, 0)) == CONST\n \t  || GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n \t{\n-\t  enum machine_mode address_mode\n-\t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (x));\n+\t  enum machine_mode address_mode = get_address_mode (x);\n \n \t  SUBST (XEXP (x, 0),\n \t\t gen_rtx_LO_SUM (address_mode,"}, {"sha": "a8c66b8dee96c80abcbee7c9ac4c3e36bb3f8d96", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -2524,8 +2524,7 @@ cselib_record_sets (rtx insn)\n \t  sets[i].src_elt = cselib_lookup (src, GET_MODE (dest), 1, VOIDmode);\n \t  if (MEM_P (dest))\n \t    {\n-\t      enum machine_mode address_mode\n-\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (dest));\n+\t      enum machine_mode address_mode = get_address_mode (dest);\n \n \t      sets[i].dest_addr_elt = cselib_lookup (XEXP (dest, 0),\n \t\t\t\t\t\t     address_mode, 1,"}, {"sha": "6bc48c8efe1bcff92b371e533b8b05f54739d084", "filename": "gcc/dse.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -1146,8 +1146,7 @@ canon_address (rtx mem,\n \t       HOST_WIDE_INT *offset,\n \t       cselib_val **base)\n {\n-  enum machine_mode address_mode\n-    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n+  enum machine_mode address_mode = get_address_mode (mem);\n   rtx mem_address = XEXP (mem, 0);\n   rtx expanded_address, address;\n   int expanded;\n@@ -1392,7 +1391,6 @@ record_store (rtx body, bb_info_t bb_info)\n   cselib_val *base = NULL;\n   insn_info_t ptr, last, redundant_reason;\n   bool store_is_unused;\n-  enum machine_mode address_mode;\n \n   if (GET_CODE (body) != SET && GET_CODE (body) != CLOBBER)\n     return 0;\n@@ -1455,8 +1453,6 @@ record_store (rtx body, bb_info_t bb_info)\n       return 0;\n     }\n \n-  address_mode = targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n-\n   if (GET_MODE (mem) == BLKmode)\n     width = MEM_SIZE (mem);\n   else\n@@ -1564,7 +1560,7 @@ record_store (rtx body, bb_info_t bb_info)\n \t  mem_addr = group->canon_base_addr;\n \t}\n       if (offset)\n-\tmem_addr = plus_constant (address_mode, mem_addr, offset);\n+\tmem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);\n     }\n \n   while (ptr)\n@@ -2181,11 +2177,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t  mem_addr = group->canon_base_addr;\n \t}\n       if (offset)\n-\t{\n-\t  enum machine_mode address_mode\n-\t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n-\t  mem_addr = plus_constant (address_mode, mem_addr, offset);\n-\t}\n+\tmem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);\n     }\n \n   /* We ignore the clobbers in store_info.  The is mildly aggressive,"}, {"sha": "7460bbf670e44120877df85874fc48ab5543a6cb", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -10971,17 +10971,6 @@ parameter_ref_descriptor (rtx rtl)\n   return ret;\n }\n \n-/* Helper function to get mode of MEM's address.  */\n-\n-enum machine_mode\n-get_address_mode (rtx mem)\n-{\n-  enum machine_mode mode = GET_MODE (XEXP (mem, 0));\n-  if (mode != VOIDmode)\n-    return mode;\n-  return targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n-}\n-\n /* The following routine converts the RTL for a variable or parameter\n    (resident in memory) into an equivalent Dwarf representation of a\n    mechanism for getting the address of that same variable onto the top of a"}, {"sha": "1bc83aa9ade16496582e27be44b8cb1bae02cf92", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -228,7 +228,6 @@ extern struct dw_loc_descr_struct *mem_loc_descriptor\n   (rtx, enum machine_mode mode, enum machine_mode mem_mode,\n    enum var_init_status);\n extern bool loc_descr_equal_p (dw_loc_descr_ref, dw_loc_descr_ref);\n-extern enum machine_mode get_address_mode (rtx mem);\n extern dw_fde_ref dwarf2out_alloc_current_fde (void);\n \n extern unsigned long size_of_locs (dw_loc_descr_ref);"}, {"sha": "8a9b8b26882c99f748e5a03037cef0ad91777d77", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -2092,7 +2092,7 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \n   /* Convert a possibly large offset to a signed value within the\n      range of the target address space.  */\n-  address_mode = targetm.addr_space.address_mode (attrs.addrspace);\n+  address_mode = get_address_mode (memref);\n   pbits = GET_MODE_BITSIZE (address_mode);\n   if (HOST_BITS_PER_WIDE_INT > pbits)\n     {\n@@ -2179,7 +2179,7 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n   struct mem_attrs attrs, *defattrs;\n \n   attrs = *get_mem_attrs (memref);\n-  address_mode = targetm.addr_space.address_mode (attrs.addrspace);\n+  address_mode = get_address_mode (memref);\n   new_rtx = simplify_gen_binary (PLUS, address_mode, addr, offset);\n \n   /* At this point we don't know _why_ the address is invalid.  It"}, {"sha": "3edb4a27d9edc3fce75c7bbb71a5e4397c1c2146", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -867,8 +867,8 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n \t\tunsigned int align, int endp)\n {\n   struct move_by_pieces_d data;\n-  enum machine_mode to_addr_mode, from_addr_mode\n-    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (from));\n+  enum machine_mode to_addr_mode;\n+  enum machine_mode from_addr_mode = get_address_mode (from);\n   rtx to_addr, from_addr = XEXP (from, 0);\n   unsigned int max_size = MOVE_MAX_PIECES + 1;\n   enum insn_code icode;\n@@ -879,7 +879,7 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n   data.from_addr = from_addr;\n   if (to)\n     {\n-      to_addr_mode = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to));\n+      to_addr_mode = get_address_mode (to);\n       to_addr = XEXP (to, 0);\n       data.to = to;\n       data.autinc_to\n@@ -1434,10 +1434,8 @@ emit_block_move_via_loop (rtx x, rtx y, rtx size,\n \t\t\t  unsigned int align ATTRIBUTE_UNUSED)\n {\n   rtx cmp_label, top_label, iter, x_addr, y_addr, tmp;\n-  enum machine_mode x_addr_mode\n-    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (x));\n-  enum machine_mode y_addr_mode\n-    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (y));\n+  enum machine_mode x_addr_mode = get_address_mode (x);\n+  enum machine_mode y_addr_mode = get_address_mode (y);\n   enum machine_mode iter_mode;\n \n   iter_mode = GET_MODE (size);\n@@ -2464,8 +2462,7 @@ store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n \t\t rtx (*constfun) (void *, HOST_WIDE_INT, enum machine_mode),\n \t\t void *constfundata, unsigned int align, bool memsetp, int endp)\n {\n-  enum machine_mode to_addr_mode\n-    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to));\n+  enum machine_mode to_addr_mode = get_address_mode (to);\n   struct store_by_pieces_d data;\n \n   if (len == 0)\n@@ -2551,8 +2548,7 @@ static void\n store_by_pieces_1 (struct store_by_pieces_d *data ATTRIBUTE_UNUSED,\n \t\t   unsigned int align ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode to_addr_mode\n-    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (data->to));\n+  enum machine_mode to_addr_mode = get_address_mode (data->to);\n   rtx to_addr = XEXP (data->to, 0);\n   unsigned int max_size = STORE_MAX_PIECES + 1;\n   enum insn_code icode;\n@@ -4707,8 +4703,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t    }\n \n \t  offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, EXPAND_SUM);\n-\t  address_mode\n-\t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to_rtx));\n+\t  address_mode = get_address_mode (to_rtx);\n \t  if (GET_MODE (offset_rtx) != address_mode)\n \t    offset_rtx = convert_to_mode (address_mode, offset_rtx, 0);\n \n@@ -5247,8 +5242,7 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t    {\n \t      enum machine_mode pointer_mode\n \t\t= targetm.addr_space.pointer_mode (MEM_ADDR_SPACE (target));\n-\t      enum machine_mode address_mode\n-\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (target));\n+\t      enum machine_mode address_mode = get_address_mode (target);\n \n \t      /* Compute the size of the data to copy from the string.  */\n \t      tree copy_size\n@@ -5816,8 +5810,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\toffset_rtx = expand_normal (offset);\n \t\tgcc_assert (MEM_P (to_rtx));\n \n-\t\taddress_mode\n-\t\t  = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to_rtx));\n+\t\taddress_mode = get_address_mode (to_rtx);\n \t\tif (GET_MODE (offset_rtx) != address_mode)\n \t\t  offset_rtx = convert_to_mode (address_mode, offset_rtx, 0);\n \n@@ -9937,8 +9930,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t    gcc_assert (MEM_P (op0));\n \n-\t    address_mode\n-\t      = targetm.addr_space.address_mode (MEM_ADDR_SPACE (op0));\n+\t    address_mode = get_address_mode (op0);\n \t    if (GET_MODE (offset_rtx) != address_mode)\n \t      offset_rtx = convert_to_mode (address_mode, offset_rtx, 0);\n "}, {"sha": "6f2101ef80b861d9f1ac580853c494cf1e83d5d4", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -1520,8 +1520,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n       && MEM_ADDR_SPACE (a) == MEM_ADDR_SPACE (b)\n       && if_info->branch_cost >= 5)\n     {\n-      enum machine_mode address_mode\n-\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (a));\n+      enum machine_mode address_mode = get_address_mode (a);\n \n       a = XEXP (a, 0);\n       b = XEXP (b, 0);"}, {"sha": "9a549ff066776501ec49c825b7c6d5c63c524006", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -8253,7 +8253,7 @@ maybe_legitimize_operand_same_code (enum insn_code icode, unsigned int opno,\n \t  enum machine_mode mode;\n \n \t  last = get_last_insn ();\n-\t  mode = targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n+\t  mode = get_address_mode (mem);\n \t  mem = replace_equiv_address (mem, copy_to_mode_reg (mode, addr));\n \t  if (insn_operand_matches (icode, opno, mem))\n \t    {"}, {"sha": "ed14e63fe71e2292cf4519d9541c59cda1074ba6", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -3993,10 +3993,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t       as would have been done by find_reloads_address.  */\n \t    addr_space_t as = MEM_ADDR_SPACE (recog_data.operand[i]);\n \t    enum machine_mode address_mode;\n-\t    address_mode = GET_MODE (XEXP (recog_data.operand[i], 0));\n-\t    if (address_mode == VOIDmode)\n-\t      address_mode = targetm.addr_space.address_mode (as);\n \n+\t    address_mode = get_address_mode (recog_data.operand[i]);\n \t    operand_reloadnum[i]\n \t      = push_reload (XEXP (recog_data.operand[i], 0), NULL_RTX,\n \t\t\t     &XEXP (recog_data.operand[i], 0), (rtx*) 0,"}, {"sha": "6f7aabc32c2903dfe0c633421427a1601f95d0fe", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -1899,6 +1899,7 @@ typedef struct replace_label_data\n   bool update_label_nuses;\n } replace_label_data;\n \n+extern enum machine_mode get_address_mode (rtx mem);\n extern int rtx_addr_can_trap_p (const_rtx);\n extern bool nonzero_address_p (const_rtx);\n extern int rtx_unstable_p (const_rtx);"}, {"sha": "beed221ef63eece16f8de4ae620663fe43b134ed", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -5279,3 +5279,17 @@ low_bitmask_len (enum machine_mode mode, unsigned HOST_WIDE_INT m)\n \n   return exact_log2 (m + 1);\n }\n+\n+/* Return the mode of MEM's address.  */\n+\n+enum machine_mode\n+get_address_mode (rtx mem)\n+{\n+  enum machine_mode mode;\n+\n+  gcc_assert (MEM_P (mem));\n+  mode = GET_MODE (XEXP (mem, 0));\n+  if (mode != VOIDmode)\n+    return mode;\n+  return targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n+}"}, {"sha": "be45c6afa168a0f686c385294a1553b3d65bbc32", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -2445,8 +2445,7 @@ sched_analyze_1 (struct deps_desc *deps, rtx x, rtx insn)\n \n       if (sched_deps_info->use_cselib)\n \t{\n-\t  enum machine_mode address_mode\n-\t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (dest));\n+\t  enum machine_mode address_mode = get_address_mode (dest);\n \n \t  t = shallow_copy_rtx (dest);\n \t  cselib_lookup_from_insn (XEXP (t, 0), address_mode, 1,\n@@ -2607,8 +2606,7 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx insn)\n \n \tif (sched_deps_info->use_cselib)\n \t  {\n-\t    enum machine_mode address_mode\n-\t      = targetm.addr_space.address_mode (MEM_ADDR_SPACE (t));\n+\t    enum machine_mode address_mode = get_address_mode (t);\n \n \t    t = shallow_copy_rtx (t);\n \t    cselib_lookup_from_insn (XEXP (t, 0), address_mode, 1,"}, {"sha": "f0a6b075e0809e8e8935481128dc66545d59c89d", "filename": "gcc/sel-sched-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fsel-sched-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fsel-sched-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -957,7 +957,7 @@ debug_mem_addr_value (rtx x)\n   enum machine_mode address_mode;\n \n   gcc_assert (MEM_P (x));\n-  address_mode = targetm.addr_space.address_mode (MEM_ADDR_SPACE (x));\n+  address_mode = get_address_mode (x);\n \n   t = shallow_copy_rtx (x);\n   if (cselib_lookup (XEXP (t, 0), address_mode, 0, GET_MODE (t)))"}, {"sha": "69e6847d0224223ab3ef8a654d1bbdfd7d506d95", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372d6395266c651119da7da9b870d0dd8ec56d6c/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=372d6395266c651119da7da9b870d0dd8ec56d6c", "patch": "@@ -4909,17 +4909,6 @@ find_use_val (rtx x, enum machine_mode mode, struct count_use_info *cui)\n   return NULL;\n }\n \n-/* Helper function to get mode of MEM's address.  */\n-\n-static inline enum machine_mode\n-get_address_mode (rtx mem)\n-{\n-  enum machine_mode mode = GET_MODE (XEXP (mem, 0));\n-  if (mode != VOIDmode)\n-    return mode;\n-  return targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n-}\n-\n /* Replace all registers and addresses in an expression with VALUE\n    expressions that map back to them, unless the expression is a\n    register.  If no mapping is or can be performed, returns NULL.  */"}]}