{"sha": "c7ce71c2263051ea52654243916c7e61640a8a03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdjZTcxYzIyNjMwNTFlYTUyNjU0MjQzOTE2YzdlNjE2NDBhOGEwMw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-06-06T10:39:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:39:47Z"}, "message": "sem_aggr.adb (Resolve_Record_Aggregate): Ignore internal components of the type that specify the position of interface...\n\n2007-04-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Record_Aggregate): Ignore internal components\n\tof the type that specify the position of interface tags when the type\n\tinherits discriminated array components from the parent type.\n\tIf a component is initialized with a box, check for the presence of a\n\tdefault expression in its declaration before using its default\n\tinitialization procedure.\n\t(Resolve_Record_Aggregate): If a component is box-initialized, and the\n\tcomponent type has a discriminants, create a partial aggregate for it\n\tby copying the discriminants of the component subtype.\n\tReject attempt to initialize a discriminant with a box.\n\t(Array_Aggr_Subtype): Indicate to the backend that the size of arrays\n\tassociated with dispatch tables is known at compile time.\n\t(Get_Value): If an association in a record aggregate has a box\n\tassociation, and the corresponding record component has a default\n\texpression, always copy the default expression, even when the\n\tassociation has a single choice, in order to create a proper\n\tassociation for the expanded aggregate.\n\nFrom-SVN: r125438", "tree": {"sha": "5499c8c53641e1f1f69c4c4836da65c42ce708fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5499c8c53641e1f1f69c4c4836da65c42ce708fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7ce71c2263051ea52654243916c7e61640a8a03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7ce71c2263051ea52654243916c7e61640a8a03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7ce71c2263051ea52654243916c7e61640a8a03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7ce71c2263051ea52654243916c7e61640a8a03/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b73cf6852765d6fc6034577369fc90524987a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b73cf6852765d6fc6034577369fc90524987a8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b73cf6852765d6fc6034577369fc90524987a8c"}], "stats": {"total": 152, "additions": 129, "deletions": 23}, "files": [{"sha": "87204e70b36d5d40496c5e39cf2b68f1ed267ec5", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 129, "deletions": 23, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ce71c2263051ea52654243916c7e61640a8a03/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ce71c2263051ea52654243916c7e61640a8a03/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=c7ce71c2263051ea52654243916c7e61640a8a03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,11 +33,13 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n with Itypes;   use Itypes;\n+with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n+with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n@@ -124,7 +126,7 @@ package body Sem_Aggr is\n    --  subtree transformation is performed during resolution rather than\n    --  expansion. Had we decided otherwise we would have had to duplicate most\n    --  of the code in the expansion procedure Expand_Record_Aggregate. Note,\n-   --  however, that all the expansion concerning aggegates for tagged records\n+   --  however, that all the expansion concerning aggregates for tagged records\n    --  is done in Expand_Record_Aggregate.\n    --\n    --  The algorithm of Resolve_Record_Aggregate proceeds as follows:\n@@ -177,7 +179,7 @@ package body Sem_Aggr is\n    --     should we not find such values or should they be duplicated.\n    --\n    --  7. We then make sure no illegal component names appear in the\n-   --     record aggegate and make sure that the type of the record\n+   --     record aggregate and make sure that the type of the record\n    --     components appearing in a same choice list is the same.\n    --     Finally we ensure that the others choice, if present, is\n    --     used to provide the value of at least a record component.\n@@ -352,7 +354,7 @@ package body Sem_Aggr is\n    --  those defined by the aggregate. When this routine is invoked\n    --  Resolve_Array_Aggregate has already processed aggregate N. Thus the\n    --  Aggregate_Bounds of each sub-aggregate, is an N_Range node giving the\n-   --  sub-aggregate bounds. When building the aggegate itype, this function\n+   --  sub-aggregate bounds. When building the aggregate itype, this function\n    --  traverses the array aggregate N collecting such Aggregate_Bounds and\n    --  constructs the proper array aggregate itype.\n    --\n@@ -682,15 +684,32 @@ package body Sem_Aggr is\n       Set_Is_Internal    (Itype, True);\n       Init_Size_Align    (Itype);\n \n+      --  Handle aggregate initializing statically allocated dispatch table\n+\n+      if Static_Dispatch_Tables\n+        and then VM_Target = No_VM\n+        and then RTU_Loaded (Ada_Tags)\n+\n+         --  Avoid circularity when rebuilding the compiler\n+\n+        and then Cunit_Entity (Get_Source_Unit (N)) /= RTU_Entity (Ada_Tags)\n+        and then (Etype (N) = RTE (RE_Address_Array)\n+                    or else\n+                  Base_Type (Etype (N)) = RTE (RE_Tag_Table))\n+      then\n+         Set_Size_Known_At_Compile_Time (Itype);\n+\n       --  A simple optimization: purely positional aggregates of static\n       --  components should be passed to gigi unexpanded whenever possible,\n       --  and regardless of the staticness of the bounds themselves. Subse-\n       --  quent checks in exp_aggr verify that type is not packed, etc.\n \n-      Set_Size_Known_At_Compile_Time (Itype,\n-         Is_Fully_Positional\n-           and then Comes_From_Source (N)\n-           and then Size_Known_At_Compile_Time (Component_Type (Typ)));\n+      else\n+         Set_Size_Known_At_Compile_Time (Itype,\n+            Is_Fully_Positional\n+              and then Comes_From_Source (N)\n+              and then Size_Known_At_Compile_Time (Component_Type (Typ)));\n+      end if;\n \n       --  We always need a freeze node for a packed array subtype, so that\n       --  we can build the Packed_Array_Type corresponding to the subtype.\n@@ -1467,14 +1486,14 @@ package body Sem_Aggr is\n \n       Aggr_Low  : Node_Id := Empty;\n       Aggr_High : Node_Id := Empty;\n-      --  The actual low and high bounds of this sub-aggegate\n+      --  The actual low and high bounds of this sub-aggregate\n \n       Choices_Low  : Node_Id := Empty;\n       Choices_High : Node_Id := Empty;\n       --  The lowest and highest discrete choices values for a named aggregate\n \n       Nb_Elements : Uint := Uint_0;\n-      --  The number of elements in a positional aggegate\n+      --  The number of elements in a positional aggregate\n \n       Others_Present : Boolean := False;\n \n@@ -2397,14 +2416,15 @@ package body Sem_Aggr is\n                         Is_Box_Present := True;\n \n                         --  Duplicate the default expression of the component\n-                        --  from the record type declaration\n+                        --  from the record type declaration, so a new copy\n+                        --  can be attached to the association.\n \n-                        if Present (Next (Selector_Name)) then\n-                           Expr :=\n-                             New_Copy_Tree (Expression (Parent (Compon)));\n-                        else\n-                           Expr := Expression (Parent (Compon));\n-                        end if;\n+                        --  Note that we always copy the default expression,\n+                        --  even when the association has a single choice, in\n+                        --  order to create a proper association for the\n+                        --  expanded aggregate.\n+\n+                        Expr := New_Copy_Tree (Expression (Parent (Compon)));\n \n                      else\n                         if Present (Next (Selector_Name)) then\n@@ -2996,17 +3016,94 @@ package body Sem_Aggr is\n                   Ctyp := Etype (Component);\n                end if;\n \n+               --  If there is a default expression for the aggregate, copy\n+               --  it into a new association.\n+\n                --  If the component has an initialization procedure (IP) we\n                --  pass the component to the expander, which will generate\n                --  the call to such IP.\n \n-               if Has_Non_Null_Base_Init_Proc (Ctyp)\n-                 or else not Expander_Active\n+               --  If the component has discriminants, their values must\n+               --  be taken from their subtype. This is indispensable for\n+               --  constraints that are given by the current instance of an\n+               --  enclosing type, to allow the expansion of the aggregate\n+               --  to replace the reference to the current instance by the\n+               --  target object of the aggregate.\n+\n+               if Present (Parent (Component))\n+                 and then\n+                   Nkind (Parent (Component)) = N_Component_Declaration\n+                 and then Present (Expression (Parent (Component)))\n                then\n+                  Expr :=\n+                    New_Copy_Tree (Expression (Parent (Component)),\n+                      New_Sloc => Sloc (N));\n+\n                   Add_Association\n-                    (Component      => Component,\n-                     Expr           => Empty,\n-                     Is_Box_Present => True);\n+                    (Component => Component,\n+                     Expr      => Expr);\n+                  Set_Has_Self_Reference (N);\n+\n+               elsif Has_Non_Null_Base_Init_Proc (Ctyp)\n+                 or else not Expander_Active\n+               then\n+                  if Is_Record_Type (Ctyp)\n+                    and then Has_Discriminants (Ctyp)\n+                  then\n+                     --  We build a partially initialized aggregate with the\n+                     --  values of the discriminants and box initialization\n+                     --  for the rest.\n+\n+                     declare\n+                        Loc        : constant Source_Ptr := Sloc (N);\n+                        Discr_Elmt : Elmt_Id;\n+                        Discr_Val  : Node_Id;\n+                        Expr       : Node_Id;\n+\n+                     begin\n+                        Expr := Make_Aggregate (Loc, New_List, New_List);\n+\n+                        Discr_Elmt :=\n+                          First_Elmt (Discriminant_Constraint (Ctyp));\n+                        while Present (Discr_Elmt) loop\n+                           Discr_Val := Node (Discr_Elmt);\n+                           Append\n+                             (New_Copy_Tree (Discr_Val), Expressions (Expr));\n+\n+                           --  If the discriminant constraint is a current\n+                           --  instance, mark the current aggregate so that\n+                           --  the self-reference can be expanded later.\n+\n+                           if Nkind (Discr_Val) = N_Attribute_Reference\n+                             and then Is_Entity_Name (Prefix (Discr_Val))\n+                             and then Is_Type (Entity (Prefix (Discr_Val)))\n+                             and then Etype (N) = Entity (Prefix (Discr_Val))\n+                           then\n+                              Set_Has_Self_Reference (N);\n+                           end if;\n+\n+                           Next_Elmt (Discr_Elmt);\n+                        end loop;\n+\n+                        Append\n+                          (Make_Component_Association (Loc,\n+                             Choices     =>\n+                               New_List (Make_Others_Choice (Loc)),\n+                             Expression  => Empty,\n+                             Box_Present => True),\n+                           Component_Associations (Expr));\n+\n+                        Add_Association\n+                          (Component      => Component,\n+                           Expr           => Expr);\n+                     end;\n+\n+                  else\n+                     Add_Association\n+                       (Component      => Component,\n+                        Expr           => Empty,\n+                        Is_Box_Present => True);\n+                  end if;\n \n                --  Otherwise we only need to resolve the expression if the\n                --  component has partially initialized values (required to\n@@ -3025,7 +3122,16 @@ package body Sem_Aggr is\n             end;\n \n          elsif No (Expr) then\n-            Error_Msg_NE (\"no value supplied for component &!\", N, Component);\n+\n+            --  Ignore hidden components associated with the position of the\n+            --  interface tags: these are initialized dynamically.\n+\n+            if Present (Related_Interface (Component)) then\n+               null;\n+            else\n+               Error_Msg_NE\n+                 (\"no value supplied for component &!\", N, Component);\n+            end if;\n \n          else\n             Resolve_Aggr_Expr (Expr, Component);"}]}