{"sha": "465c8c1983a68b36059414b7bd589a48693f94e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY1YzhjMTk4M2E2OGIzNjA1OTQxNGI3YmQ1ODlhNDg2OTNmOTRlMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-07-05T12:11:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-07-05T12:11:57Z"}, "message": "re PR tree-optimization/66718 (Non-invariant ADDR_EXPR not vectorized)\n\n\tPR tree-optimization/66718\n\t* tree-vect-stmts.c (vectorizable_assignment, vectorizable_store,\n\tvectorizable_load, vectorizable_condition): Move vectype,\n\tnunits, ncopies computation after checking what kind of statement\n\tstmt is.\n\nFrom-SVN: r225433", "tree": {"sha": "9ae459375db346bb5db013138a04b63c3b5d7eb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ae459375db346bb5db013138a04b63c3b5d7eb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/465c8c1983a68b36059414b7bd589a48693f94e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/465c8c1983a68b36059414b7bd589a48693f94e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/465c8c1983a68b36059414b7bd589a48693f94e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/465c8c1983a68b36059414b7bd589a48693f94e0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "234d14ac72066f06b8da319f98793d0614cda8b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/234d14ac72066f06b8da319f98793d0614cda8b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/234d14ac72066f06b8da319f98793d0614cda8b0"}], "stats": {"total": 167, "additions": 90, "deletions": 77}, "files": [{"sha": "4ccf4396074ce6ddd189a55c48458a37e9e4dcb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465c8c1983a68b36059414b7bd589a48693f94e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465c8c1983a68b36059414b7bd589a48693f94e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=465c8c1983a68b36059414b7bd589a48693f94e0", "patch": "@@ -1,3 +1,11 @@\n+2015-07-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/66718\n+\t* tree-vect-stmts.c (vectorizable_assignment, vectorizable_store,\n+\tvectorizable_load, vectorizable_condition): Move vectype,\n+\tnunits, ncopies computation after checking what kind of statement\n+\tstmt is.\n+\n 2015-07-05  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target-insns.def (extv, extzv, insv): New targetm instruction"}, {"sha": "c6565228d087ec6735dd86eacb82fc2ec9b7663b", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 82, "deletions": 77, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465c8c1983a68b36059414b7bd589a48693f94e0/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465c8c1983a68b36059414b7bd589a48693f94e0/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=465c8c1983a68b36059414b7bd589a48693f94e0", "patch": "@@ -4043,13 +4043,11 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   tree scalar_dest;\n   tree op;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree new_temp;\n   tree def;\n   gimple def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n-  unsigned int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies;\n   int i, j;\n   vec<tree> vec_oprnds = vNULL;\n@@ -4060,16 +4058,6 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   enum tree_code code;\n   tree vectype_in;\n \n-  /* Multiple types in SLP are handled by creating the appropriate number of\n-     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n-     case of SLP.  */\n-  if (slp_node || PURE_SLP_STMT (stmt_info))\n-    ncopies = 1;\n-  else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n-\n-  gcc_assert (ncopies >= 1);\n-\n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n@@ -4095,6 +4083,19 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   if (code == VIEW_CONVERT_EXPR)\n     op = TREE_OPERAND (op, 0);\n \n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  unsigned int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\n+  /* Multiple types in SLP are handled by creating the appropriate number of\n+     vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n+     case of SLP.  */\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n+    ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+\n+  gcc_assert (ncopies >= 1);\n+\n   if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n@@ -5006,7 +5007,6 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   tree vec_oprnd = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr = NULL;\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree elem_type;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n@@ -5020,7 +5020,6 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   tree dataref_ptr = NULL_TREE;\n   tree dataref_offset = NULL_TREE;\n   gimple ptr_incr = NULL;\n-  unsigned int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies;\n   int j;\n   gimple next_stmt, first_stmt = NULL;\n@@ -5039,28 +5038,6 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   tree aggr_type;\n \n-  if (loop_vinfo)\n-    loop = LOOP_VINFO_LOOP (loop_vinfo);\n-\n-  /* Multiple types in SLP are handled by creating the appropriate number of\n-     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n-     case of SLP.  */\n-  if (slp || PURE_SLP_STMT (stmt_info))\n-    ncopies = 1;\n-  else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n-\n-  gcc_assert (ncopies >= 1);\n-\n-  /* FORNOW. This restriction should be relaxed.  */\n-  if (loop && nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"multiple types in nested loop.\\n\");\n-      return false;\n-    }\n-\n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n@@ -5086,6 +5063,32 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     return false;\n \n   gcc_assert (gimple_assign_single_p (stmt));\n+\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  unsigned int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\n+  if (loop_vinfo)\n+    loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\n+  /* Multiple types in SLP are handled by creating the appropriate number of\n+     vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n+     case of SLP.  */\n+  if (slp || PURE_SLP_STMT (stmt_info))\n+    ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+\n+  gcc_assert (ncopies >= 1);\n+\n+  /* FORNOW.  This restriction should be relaxed.  */\n+  if (loop && nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"multiple types in nested loop.\\n\");\n+      return false;\n+    }\n+\n   op = gimple_assign_rhs1 (stmt);\n   if (!vect_is_simple_use (op, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n \t\t\t   &def, &dt))\n@@ -5834,7 +5837,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   struct loop *containing_loop = (gimple_bb (stmt))->loop_father;\n   bool nested_in_vect_loop = false;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr = NULL;\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree elem_type;\n   tree new_temp;\n   machine_mode mode;\n@@ -5844,7 +5846,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   tree dataref_ptr = NULL_TREE;\n   tree dataref_offset = NULL_TREE;\n   gimple ptr_incr = NULL;\n-  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies;\n   int i, j, group_size = -1, group_gap_adj;\n   tree msq = NULL_TREE, lsq;\n@@ -5872,6 +5873,37 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   int gather_scale = 1;\n   enum vect_def_type gather_dt = vect_unknown_def_type;\n \n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n+    return false;\n+\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n+    return false;\n+\n+  /* Is vectorizable load? */\n+  if (!is_gimple_assign (stmt))\n+    return false;\n+\n+  scalar_dest = gimple_assign_lhs (stmt);\n+  if (TREE_CODE (scalar_dest) != SSA_NAME)\n+    return false;\n+\n+  code = gimple_assign_rhs_code (stmt);\n+  if (code != ARRAY_REF\n+      && code != BIT_FIELD_REF\n+      && code != INDIRECT_REF\n+      && code != COMPONENT_REF\n+      && code != IMAGPART_EXPR\n+      && code != REALPART_EXPR\n+      && code != MEM_REF\n+      && TREE_CODE_CLASS (code) != tcc_declaration)\n+    return false;\n+\n+  if (!STMT_VINFO_DATA_REF (stmt_info))\n+    return false;\n+\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\n   if (loop_vinfo)\n     {\n       loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -5914,34 +5946,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       return false;\n     }\n \n-  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n-    return false;\n-\n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n-    return false;\n-\n-  /* Is vectorizable load? */\n-  if (!is_gimple_assign (stmt))\n-    return false;\n-\n-  scalar_dest = gimple_assign_lhs (stmt);\n-  if (TREE_CODE (scalar_dest) != SSA_NAME)\n-    return false;\n-\n-  code = gimple_assign_rhs_code (stmt);\n-  if (code != ARRAY_REF\n-      && code != BIT_FIELD_REF\n-      && code != INDIRECT_REF\n-      && code != COMPONENT_REF\n-      && code != IMAGPART_EXPR\n-      && code != REALPART_EXPR\n-      && code != MEM_REF\n-      && TREE_CODE_CLASS (code) != tcc_declaration)\n-    return false;\n-\n-  if (!STMT_VINFO_DATA_REF (stmt_info))\n-    return false;\n-\n   elem_type = TREE_TYPE (vectype);\n   mode = TYPE_MODE (vectype);\n \n@@ -7021,7 +7025,6 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   tree vec_dest = NULL_TREE;\n   tree cond_expr, then_clause, else_clause;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree comp_vectype = NULL_TREE;\n   tree vec_cond_lhs = NULL_TREE, vec_cond_rhs = NULL_TREE;\n   tree vec_then_clause = NULL_TREE, vec_else_clause = NULL_TREE;\n@@ -7030,7 +7033,6 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree def;\n   enum vect_def_type dt, dts[4];\n-  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies;\n   enum tree_code code;\n   stmt_vec_info prev_stmt_info = NULL;\n@@ -7042,15 +7044,6 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   vec<tree> vec_oprnds3 = vNULL;\n   tree vec_cmp_type;\n \n-  if (slp_node || PURE_SLP_STMT (stmt_info))\n-    ncopies = 1;\n-  else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n-\n-  gcc_assert (ncopies >= 1);\n-  if (reduc_index && ncopies > 1)\n-    return false; /* FORNOW */\n-\n   if (reduc_index && STMT_SLP_TYPE (stmt_info))\n     return false;\n \n@@ -7080,6 +7073,18 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   if (code != COND_EXPR)\n     return false;\n \n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n+    ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+\n+  gcc_assert (ncopies >= 1);\n+  if (reduc_index && ncopies > 1)\n+    return false; /* FORNOW */\n+\n   cond_expr = gimple_assign_rhs1 (stmt);\n   then_clause = gimple_assign_rhs2 (stmt);\n   else_clause = gimple_assign_rhs3 (stmt);"}]}