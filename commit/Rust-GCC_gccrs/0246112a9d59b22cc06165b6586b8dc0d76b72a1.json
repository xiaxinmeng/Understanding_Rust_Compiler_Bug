{"sha": "0246112a9d59b22cc06165b6586b8dc0d76b72a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI0NjExMmE5ZDU5YjIyY2MwNjE2NWI2NTg2YjhkYzBkNzZiNzJhMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-08-03T12:56:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-08-03T12:56:55Z"}, "message": "Handle SLP of call pattern statements\n\nWe couldn't vectorise:\n\n  for (int j = 0; j < n; ++j)\n    {\n      for (int i = 0; i < 16; ++i)\n\ta[i] = (b[i] + c[i]) >> 1;\n      a += step;\n      b += step;\n      c += step;\n    }\n\nat -O3 because cunrolli unrolled the inner loop and SLP couldn't handle\nAVG_FLOOR patterns (see also PR86504).  The problem was some overly\nstrict checking of pattern statements compared to normal statements\nin vect_get_and_check_slp_defs:\n\n          switch (gimple_code (def_stmt))\n            {\n            case GIMPLE_PHI:\n            case GIMPLE_ASSIGN:\n\t      break;\n\n\t    default:\n\t      if (dump_enabled_p ())\n\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n\t\t\t\t \"unsupported defining stmt:\\n\");\n\t      return -1;\n            }\n\nThe easy fix would have been to add GIMPLE_CALL to the switch,\nbut I don't think the switch is doing anything useful.  We only create\npattern statements that the rest of the vectoriser can handle, and the\nother checks in this function and elsewhere check whether SLP is possible.\n\nI'm also not sure why:\n\n          if (!first && !oprnd_info->first_pattern\n\t      /* Allow different pattern state for the defs of the\n\t\t first stmt in reduction chains.  */\n\t      && (oprnd_info->first_dt != vect_reduction_def\n\nis necessary.  All that should matter is that the statements in the\nnode are \"similar enough\".  It turned out to be quite hard to find a\nconvincing example that used a mixture of pattern and non-pattern\nstatements, so bb-slp-pow-1.c is the best I could come up with.\nBut it does show that the combination of \"xi * xi\" statements and\n\"pow (xj, 2) -> xj * xj\" patterns are handled correctly.\n\nThe patch therefore just removes the whole if block.\n\nThe loop also needed commutative swapping to be extended to at least\nAVG_FLOOR.\n\nThis gives +3.9% on 525.x264_r at -O3.\n\n2018-08-03  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* internal-fn.h (first_commutative_argument): Declare.\n\t* internal-fn.c (first_commutative_argument): New function.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Remove extra\n\trestrictions for pattern statements.  Use first_commutative_argument\n\tto look for commutative operands in calls to internal functions.\n\ngcc/testsuite/\n\t* gcc.dg/vect/bb-slp-over-widen-1.c: Expect AVG_FLOOR to be used\n\ton vect_avg_qi targets.\n\t* gcc.dg/vect/bb-slp-over-widen-2.c: Likewise.\n\t* gcc.dg/vect/bb-slp-pow-1.c: New test.\n\t* gcc.dg/vect/vect-avg-15.c: Likewise.\n\nFrom-SVN: r263290", "tree": {"sha": "c5cea056f707c9b77bae206e6dad99911f65d947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5cea056f707c9b77bae206e6dad99911f65d947"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0246112a9d59b22cc06165b6586b8dc0d76b72a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0246112a9d59b22cc06165b6586b8dc0d76b72a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0246112a9d59b22cc06165b6586b8dc0d76b72a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0246112a9d59b22cc06165b6586b8dc0d76b72a1/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d7487e2ae8666f071cb841a845e1e8770b4f9f67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7487e2ae8666f071cb841a845e1e8770b4f9f67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7487e2ae8666f071cb841a845e1e8770b4f9f67"}], "stats": {"total": 217, "additions": 152, "deletions": 65}, "files": [{"sha": "5220e66562f0413b790d611f030d6db1123193b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0246112a9d59b22cc06165b6586b8dc0d76b72a1", "patch": "@@ -1,3 +1,11 @@\n+2018-08-03  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* internal-fn.h (first_commutative_argument): Declare.\n+\t* internal-fn.c (first_commutative_argument): New function.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Remove extra\n+\trestrictions for pattern statements.  Use first_commutative_argument\n+\tto look for commutative operands in calls to internal functions.\n+\n 2018-08-03  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* Makefile.in (wide-int-range.o): New."}, {"sha": "34d4f9efab9a45e0a9e3622f37dab0fa417b76f7", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=0246112a9d59b22cc06165b6586b8dc0d76b72a1", "patch": "@@ -3183,6 +3183,42 @@ direct_internal_fn_supported_p (internal_fn fn, tree type,\n   return direct_internal_fn_supported_p (fn, tree_pair (type, type), opt_type);\n }\n \n+/* If FN is commutative in two consecutive arguments, return the\n+   index of the first, otherwise return -1.  */\n+\n+int\n+first_commutative_argument (internal_fn fn)\n+{\n+  switch (fn)\n+    {\n+    case IFN_FMA:\n+    case IFN_FMS:\n+    case IFN_FNMA:\n+    case IFN_FNMS:\n+    case IFN_AVG_FLOOR:\n+    case IFN_AVG_CEIL:\n+    case IFN_FMIN:\n+    case IFN_FMAX:\n+      return 0;\n+\n+    case IFN_COND_ADD:\n+    case IFN_COND_MUL:\n+    case IFN_COND_MIN:\n+    case IFN_COND_MAX:\n+    case IFN_COND_AND:\n+    case IFN_COND_IOR:\n+    case IFN_COND_XOR:\n+    case IFN_COND_FMA:\n+    case IFN_COND_FMS:\n+    case IFN_COND_FNMA:\n+    case IFN_COND_FNMS:\n+      return 1;\n+\n+    default:\n+      return -1;\n+    }\n+}\n+\n /* Return true if IFN_SET_EDOM is supported.  */\n \n bool"}, {"sha": "99765cf407acc7d65356b156e91f9dc51f1dba34", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=0246112a9d59b22cc06165b6586b8dc0d76b72a1", "patch": "@@ -201,6 +201,8 @@ direct_internal_fn_supported_p (internal_fn fn, tree type0, tree type1,\n \t\t\t\t\t opt_type);\n }\n \n+extern int first_commutative_argument (internal_fn);\n+\n extern bool set_edom_supported_p (void);\n \n extern internal_fn get_conditional_internal_fn (tree_code);"}, {"sha": "25a59801a2629e2107d96fe73d8fa18261fc95c0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0246112a9d59b22cc06165b6586b8dc0d76b72a1", "patch": "@@ -1,3 +1,11 @@\n+2018-08-03  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/vect/bb-slp-over-widen-1.c: Expect AVG_FLOOR to be used\n+\ton vect_avg_qi targets.\n+\t* gcc.dg/vect/bb-slp-over-widen-2.c: Likewise.\n+\t* gcc.dg/vect/bb-slp-pow-1.c: New test.\n+\t* gcc.dg/vect/vect-avg-15.c: Likewise.\n+\n 2018-08-03  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.dg/predict-1.c: Adjust scanned pattern to cover 2 digits."}, {"sha": "0dd163ef3aa7a0eb53d6dbd1851f9b2626e076e5", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-over-widen-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-1.c?ref=0246112a9d59b22cc06165b6586b8dc0d76b72a1", "patch": "@@ -63,4 +63,5 @@ main (void)\n \n /* { dg-final { scan-tree-dump \"demoting int to signed short\" \"slp2\" { target { ! vect_widen_shift } } } } */\n /* { dg-final { scan-tree-dump \"demoting int to unsigned short\" \"slp2\" { target { ! vect_widen_shift } } } } */\n+/* { dg-final { scan-tree-dump {\\.AVG_FLOOR} \"slp2\" { target vect_avg_qi } } } */\n /* { dg-final { scan-tree-dump-times \"basic block vectorized\" 2 \"slp2\" } } */"}, {"sha": "3750fb79c12db2bf6940e451e4abaa71c2c32efa", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-over-widen-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-2.c?ref=0246112a9d59b22cc06165b6586b8dc0d76b72a1", "patch": "@@ -62,4 +62,5 @@ main (void)\n \n /* { dg-final { scan-tree-dump \"demoting int to signed short\" \"slp2\" { target { ! vect_widen_shift } } } } */\n /* { dg-final { scan-tree-dump \"demoting int to unsigned short\" \"slp2\" { target { ! vect_widen_shift } } } } */\n+/* { dg-final { scan-tree-dump {\\.AVG_FLOOR} \"slp2\" { target vect_avg_qi } } } */\n /* { dg-final { scan-tree-dump-times \"basic block vectorized\" 2 \"slp2\" } } */"}, {"sha": "5a05bd493126ba54bc1331ec9b28c49af8f8a3de", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pow-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pow-1.c?ref=0246112a9d59b22cc06165b6586b8dc0d76b72a1", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-additional-options \"-fno-math-errno -fdisable-tree-sincos\" } */\n+/* { dg-require-effective-target vect_float } */\n+\n+void __attribute__ ((noipa))\n+f (float *a)\n+{\n+  a[0] = a[0] * a[0];\n+  a[1] = __builtin_powf (a[1], 2);\n+  a[2] = a[2] * a[2];\n+  a[3] = __builtin_powf (a[3], 2);\n+}\n+\n+float a[4] = { 1, 2, 3, 4 };\n+\n+int\n+main (void)\n+{\n+  f (a);\n+  for (int i = 0; i < 4; ++i)\n+    {\n+      if (a[i] != (i + 1) * (i + 1))\n+\t__builtin_abort ();\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\" } } */"}, {"sha": "48d7ed773000486c42277535cebe34f101e035ef", "filename": "gcc/testsuite/gcc.dg/vect/vect-avg-15.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-avg-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-avg-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-avg-15.c?ref=0246112a9d59b22cc06165b6586b8dc0d76b72a1", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-additional-options \"-O3\" } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 80\n+\n+void __attribute__ ((noipa))\n+f (signed char *restrict a, signed char *restrict b,\n+   signed char *restrict c, int n, int step)\n+{\n+  for (int j = 0; j < n; ++j)\n+    {\n+      for (int i = 0; i < 16; ++i)\n+\ta[i] = (b[i] + c[i]) >> 1;\n+      a += step;\n+      b += step;\n+      c += step;\n+    }\n+}\n+\n+#define BASE1 -126\n+#define BASE2 -42\n+\n+signed char a[N], b[N], c[N];\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  for (int i = 0; i < N; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = BASE1 + i * 3;\n+      c[i] = BASE2 + i * 2;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b, c, N / 20, 20);\n+  for (int i = 0; i < N; ++i)\n+    {\n+      int d = (BASE1 + BASE2 + i * 5) >> 1;\n+      if (a[i] != (i % 20 < 16 ? d : i))\n+\t__builtin_abort ();\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vect_recog_average_pattern: detected\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump {\\.AVG_FLOOR} \"vect\" { target vect_avg_qi } } } */\n+/* { dg-final { scan-tree-dump \"Loop contains only SLP stmts\" \"vect\" { target vect_avg_qi } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" { target vect_avg_qi } } } */"}, {"sha": "367945b69cdf08e62fd6556a8548d60b2445fbfe", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 16, "deletions": 65, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0246112a9d59b22cc06165b6586b8dc0d76b72a1/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=0246112a9d59b22cc06165b6586b8dc0d76b72a1", "patch": "@@ -309,7 +309,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n   bool pattern = false;\n   slp_oprnd_info oprnd_info;\n   int first_op_idx = 1;\n-  bool commutative = false;\n+  unsigned int commutative_op = -1U;\n   bool first_op_cond = false;\n   bool first = stmt_num == 0;\n   bool second = stmt_num == 1;\n@@ -318,6 +318,11 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n     {\n       number_of_oprnds = gimple_call_num_args (stmt);\n       first_op_idx = 3;\n+      if (gimple_call_internal_p (stmt))\n+\t{\n+\t  internal_fn ifn = gimple_call_internal_fn (stmt);\n+\t  commutative_op = first_commutative_argument (ifn);\n+\t}\n     }\n   else if (gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt))\n     {\n@@ -332,7 +337,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t  number_of_oprnds++;\n \t}\n       else\n-\tcommutative = commutative_tree_code (code);\n+\tcommutative_op = commutative_tree_code (code) ? 0U : -1U;\n     }\n   else\n     return -1;\n@@ -373,62 +378,6 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t  return -1;\n \t}\n \n-      /* Check if DEF_STMT_INFO is a part of a pattern in LOOP and get\n-\t the def stmt from the pattern.  Check that all the stmts of the\n-\t node are in the pattern.  */\n-      if (def_stmt_info && is_pattern_stmt_p (def_stmt_info))\n-        {\n-          pattern = true;\n-          if (!first && !oprnd_info->first_pattern\n-\t      /* Allow different pattern state for the defs of the\n-\t\t first stmt in reduction chains.  */\n-\t      && (oprnd_info->first_dt != vect_reduction_def\n-\t\t  || (!second && !oprnd_info->second_pattern)))\n-\t    {\n-\t      if (i == 0\n-\t\t  && !swapped\n-\t\t  && commutative)\n-\t\t{\n-\t\t  swapped = true;\n-\t\t  goto again;\n-\t\t}\n-\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"Build SLP failed: some of the stmts\"\n-\t\t\t\t   \" are in a pattern, and others are not \");\n-\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, oprnd);\n-                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t\t}\n-\n-\t      return 1;\n-            }\n-\n-\t  dt = STMT_VINFO_DEF_TYPE (def_stmt_info);\n-\n-          if (dt == vect_unknown_def_type)\n-            {\n-              if (dump_enabled_p ())\n-                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"Unsupported pattern.\\n\");\n-              return -1;\n-            }\n-\n-\t  switch (gimple_code (def_stmt_info->stmt))\n-            {\n-            case GIMPLE_PHI:\n-            case GIMPLE_ASSIGN:\n-\t      break;\n-\n-\t    default:\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"unsupported defining stmt:\\n\");\n-\t      return -1;\n-            }\n-        }\n-\n       if (second)\n \toprnd_info->second_pattern = pattern;\n \n@@ -456,9 +405,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t      || !types_compatible_p (oprnd_info->first_op_type, type))\n \t    {\n \t      /* Try swapping operands if we got a mismatch.  */\n-\t      if (i == 0\n-\t\t  && !swapped\n-\t\t  && commutative)\n+\t      if (i == commutative_op && !swapped)\n \t\t{\n \t\t  swapped = true;\n \t\t  goto again;\n@@ -534,9 +481,9 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t  return -1;\n \t}\n \n-      gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n       if (first_op_cond)\n \t{\n+\t  gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n \t  tree cond = gimple_assign_rhs1 (stmt);\n \t  enum tree_code code = TREE_CODE (cond);\n \n@@ -559,13 +506,17 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t    }\n \t}\n       else\n-\tswap_ssa_operands (stmt, gimple_assign_rhs1_ptr (stmt),\n-\t\t\t   gimple_assign_rhs2_ptr (stmt));\n+\t{\n+\t  unsigned int op = commutative_op + first_op_idx;\n+\t  swap_ssa_operands (stmt_info->stmt,\n+\t\t\t     gimple_op_ptr (stmt_info->stmt, op),\n+\t\t\t     gimple_op_ptr (stmt_info->stmt, op + 1));\n+\t}\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"swapped operands to match def types in \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n \t}\n     }\n "}]}