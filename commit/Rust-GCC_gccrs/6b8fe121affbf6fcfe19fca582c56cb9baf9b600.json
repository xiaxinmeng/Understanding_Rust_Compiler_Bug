{"sha": "6b8fe121affbf6fcfe19fca582c56cb9baf9b600", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI4ZmUxMjFhZmZiZjZmY2ZlMTlmY2E1ODJjNTZjYjliYWY5YjYwMA==", "commit": {"author": {"name": "Edward Smith-Rowland", "email": "3dw4rd@verizon.net", "date": "2013-10-19T01:31:19Z"}, "committer": {"name": "Edward Smith-Rowland", "email": "emsr@gcc.gnu.org", "date": "2013-10-19T01:31:19Z"}, "message": "re PR libstdc++/58729 (tr2::dynamic_bitset::resize fails)\n\n2013-10-18  Edward Smith-Rowland  <3dw4rd@verizon.net>\n\n\tPR libstdc++/58729\n\t* include/tr2/dynamic_bitset (_M_resize, resize): Use input value\n\tto set bits; (_M_do_left_shift, _M_do_right_shift, _M_do_to_ulong,\n\t_M_do_to_ullong, _M_do_find_first, _M_do_find_next, _M_copy_from_ptr,\n\toperator>>): Move long methods outline to...\n\t* include/tr2/dynamic_bitset.tcc: New.\n\t* include/Makefile.am: Add dynamic_bitset.tcc.\n\t* include/Makefile.in: Add dynamic_bitset.tcc.\n\t* testsuite/tr2/dynamic_bitset/pr58729.cc: New.\n\nFrom-SVN: r203841", "tree": {"sha": "6c13387d2b1e6d35e2d97616603d95b65a65a270", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c13387d2b1e6d35e2d97616603d95b65a65a270"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b8fe121affbf6fcfe19fca582c56cb9baf9b600", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8fe121affbf6fcfe19fca582c56cb9baf9b600", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b8fe121affbf6fcfe19fca582c56cb9baf9b600", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/comments", "author": {"login": "emsr", "id": 1936479, "node_id": "MDQ6VXNlcjE5MzY0Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1936479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emsr", "html_url": "https://github.com/emsr", "followers_url": "https://api.github.com/users/emsr/followers", "following_url": "https://api.github.com/users/emsr/following{/other_user}", "gists_url": "https://api.github.com/users/emsr/gists{/gist_id}", "starred_url": "https://api.github.com/users/emsr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emsr/subscriptions", "organizations_url": "https://api.github.com/users/emsr/orgs", "repos_url": "https://api.github.com/users/emsr/repos", "events_url": "https://api.github.com/users/emsr/events{/privacy}", "received_events_url": "https://api.github.com/users/emsr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d979bbbb845ada9bee20db91fe057f2357dc1b3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d979bbbb845ada9bee20db91fe057f2357dc1b3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d979bbbb845ada9bee20db91fe057f2357dc1b3e"}], "stats": {"total": 662, "additions": 408, "deletions": 254}, "files": [{"sha": "c3fa989b86713c88684f0d2efcaff3d41df7cc63", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6b8fe121affbf6fcfe19fca582c56cb9baf9b600", "patch": "@@ -1,3 +1,15 @@\n+2013-10-18  Edward Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tPR libstdc++/58729\n+\t* include/tr2/dynamic_bitset (_M_resize, resize): Use input value\n+\tto set bits; (_M_do_left_shift, _M_do_right_shift, _M_do_to_ulong,\n+\t_M_do_to_ullong, _M_do_find_first, _M_do_find_next, _M_copy_from_ptr,\n+\toperator>>): Move long methods outline to...\n+\t* include/tr2/dynamic_bitset.tcc: New.\n+\t* include/Makefile.am: Add dynamic_bitset.tcc.\n+\t* include/Makefile.in: Add dynamic_bitset.tcc.\n+\t* testsuite/tr2/dynamic_bitset/pr58729.cc: New.\n+\n 2013-10-18  Tim Shen  <timshen91@gmail.com>\n \n \t* include/bits/regex_scanner.tcc: (_Scanner<>::_M_scan_normal,"}, {"sha": "0ddc8b51419f57ee7780f06786ec131ce2b0a098", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=6b8fe121affbf6fcfe19fca582c56cb9baf9b600", "patch": "@@ -623,6 +623,7 @@ tr2_headers = \\\n \t${tr2_srcdir}/bool_set \\\n \t${tr2_srcdir}/bool_set.tcc \\\n \t${tr2_srcdir}/dynamic_bitset \\\n+\t${tr2_srcdir}/dynamic_bitset.tcc \\\n \t${tr2_srcdir}/ratio \\\n \t${tr2_srcdir}/type_traits\n "}, {"sha": "a1fd1d39982da8520c33fae9cbcc752e4c5b0efe", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=6b8fe121affbf6fcfe19fca582c56cb9baf9b600", "patch": "@@ -888,6 +888,7 @@ tr2_headers = \\\n \t${tr2_srcdir}/bool_set \\\n \t${tr2_srcdir}/bool_set.tcc \\\n \t${tr2_srcdir}/dynamic_bitset \\\n+\t${tr2_srcdir}/dynamic_bitset.tcc \\\n \t${tr2_srcdir}/ratio \\\n \t${tr2_srcdir}/type_traits\n "}, {"sha": "5cd05f53c54f8a0929b664f38e7f5c419632b29d", "filename": "libstdc++-v3/include/tr2/dynamic_bitset", "status": "modified", "additions": 44, "deletions": 254, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset?ref=6b8fe121affbf6fcfe19fca582c56cb9baf9b600", "patch": "@@ -137,7 +137,12 @@ public:\n \tif (__nbits % _S_bits_per_block > 0)\n \t  ++__sz;\n \tif (__sz != this->_M_w.size())\n-\t  this->_M_w.resize(__sz);\n+\t  {\n+\t    block_type __val = 0;\n+\t    if (__value)\n+\t      __val = std::numeric_limits<block_type>::max();\n+\t    this->_M_w.resize(__sz, __val);\n+\t  }\n       }\n \n       allocator_type\n@@ -246,7 +251,7 @@ public:\n       bool\n       _M_is_equal(const __dynamic_bitset_base& __x) const\n       {\n-\tif (__x.size() == this->size())\n+\tif (__x._M_w.size() == this->_M_w.size())\n \t  {\n \t    for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n \t      if (this->_M_w[__i] != __x._M_w[__i])\n@@ -260,7 +265,7 @@ public:\n       bool\n       _M_is_less(const __dynamic_bitset_base& __x) const\n       {\n-\tif (__x.size() == this->size())\n+\tif (__x._M_w.size() == this->_M_w.size())\n \t  {\n \t    for (size_t __i = this->_M_w.size(); __i > 0; --__i)\n \t      {\n@@ -297,9 +302,9 @@ public:\n       bool\n       _M_is_subset_of(const __dynamic_bitset_base& __b)\n       {\n-\tif (__b.size() == this->size())\n+\tif (__b._M_w.size() == this->_M_w.size())\n \t  {\n-\t    for (size_t __i = 0; __i < _M_w.size(); ++__i)\n+\t    for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n \t      if (this->_M_w[__i] != (this->_M_w[__i] | __b._M_w[__i]))\n \t\treturn false;\n \t    return true;\n@@ -364,140 +369,6 @@ public:\n       }\n     };\n \n-  // Definitions of non-inline functions from __dynamic_bitset_base.\n-  template<typename _WordT, typename _Alloc>\n-    void\n-    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_left_shift(size_t __shift)\n-    {\n-      if (__builtin_expect(__shift != 0, 1))\n-\t{\n-\t  const size_t __wshift = __shift / _S_bits_per_block;\n-\t  const size_t __offset = __shift % _S_bits_per_block;\n-\n-\t  if (__offset == 0)\n-\t    for (size_t __n = this->_M_w.size() - 1; __n >= __wshift; --__n)\n-\t      this->_M_w[__n] = this->_M_w[__n - __wshift];\n-\t  else\n-\t    {\n-\t      const size_t __sub_offset = _S_bits_per_block - __offset;\n-\t      for (size_t __n = _M_w.size() - 1; __n > __wshift; --__n)\n-\t\tthis->_M_w[__n] = ((this->_M_w[__n - __wshift] << __offset)\n-\t\t\t     | (this->_M_w[__n - __wshift - 1] >> __sub_offset));\n-\t      this->_M_w[__wshift] = this->_M_w[0] << __offset;\n-\t    }\n-\n-\t  //// std::fill(this->_M_w.begin(), this->_M_w.begin() + __wshift,\n-\t  ////          static_cast<_WordT>(0));\n-\t}\n-    }\n-\n-  template<typename _WordT, typename _Alloc>\n-    void\n-    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_right_shift(size_t __shift)\n-    {\n-      if (__builtin_expect(__shift != 0, 1))\n-\t{\n-\t  const size_t __wshift = __shift / _S_bits_per_block;\n-\t  const size_t __offset = __shift % _S_bits_per_block;\n-\t  const size_t __limit = this->_M_w.size() - __wshift - 1;\n-\n-\t  if (__offset == 0)\n-\t    for (size_t __n = 0; __n <= __limit; ++__n)\n-\t      this->_M_w[__n] = this->_M_w[__n + __wshift];\n-\t  else\n-\t    {\n-\t      const size_t __sub_offset = (_S_bits_per_block\n-\t\t\t\t\t   - __offset);\n-\t      for (size_t __n = 0; __n < __limit; ++__n)\n-\t\tthis->_M_w[__n] = ((this->_M_w[__n + __wshift] >> __offset)\n-\t\t\t     | (this->_M_w[__n + __wshift + 1] << __sub_offset));\n-\t      this->_M_w[__limit] = this->_M_w[_M_w.size()-1] >> __offset;\n-\t    }\n-\n-\t  ////std::fill(this->_M_w.begin() + __limit + 1, this->_M_w.end(),\n-\t  ////          static_cast<_WordT>(0));\n-\t}\n-    }\n-\n-  template<typename _WordT, typename _Alloc>\n-    unsigned long\n-    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_to_ulong() const\n-    {\n-      size_t __n = sizeof(unsigned long) / sizeof(block_type);\n-      for (size_t __i = __n; __i < this->_M_w.size(); ++__i)\n-\tif (this->_M_w[__i])\n-\t  __throw_overflow_error(__N(\"__dynamic_bitset_base::_M_do_to_ulong\"));\n-      unsigned long __res = 0UL;\n-      for (size_t __i = 0; __i < __n && __i < this->_M_w.size(); ++__i)\n-\t__res += this->_M_w[__i] << (__i * _S_bits_per_block);\n-      return __res;\n-    }\n-\n-  template<typename _WordT, typename _Alloc>\n-    unsigned long long\n-    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_to_ullong() const\n-    {\n-      size_t __n = sizeof(unsigned long long) / sizeof(block_type);\n-      for (size_t __i = __n; __i < this->_M_w.size(); ++__i)\n-\tif (this->_M_w[__i])\n-\t  __throw_overflow_error(__N(\"__dynamic_bitset_base::_M_do_to_ullong\"));\n-      unsigned long long __res = 0ULL;\n-      for (size_t __i = 0; __i < __n && __i < this->_M_w.size(); ++__i)\n-\t__res += this->_M_w[__i] << (__i * _S_bits_per_block);\n-      return __res;\n-    }\n-\n-  template<typename _WordT, typename _Alloc>\n-    size_t\n-    __dynamic_bitset_base<_WordT, _Alloc>\n-    ::_M_do_find_first(size_t __not_found) const\n-    {\n-      for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n-\t{\n-\t  _WordT __thisword = this->_M_w[__i];\n-\t  if (__thisword != static_cast<_WordT>(0))\n-\t    return (__i * _S_bits_per_block\n-\t\t    + __builtin_ctzl(__thisword));\n-\t}\n-      // not found, so return an indication of failure.\n-      return __not_found;\n-    }\n-\n-  template<typename _WordT, typename _Alloc>\n-    size_t\n-    __dynamic_bitset_base<_WordT, _Alloc>\n-    ::_M_do_find_next(size_t __prev, size_t __not_found) const\n-    {\n-      // make bound inclusive\n-      ++__prev;\n-\n-      // check out of bounds\n-      if (__prev >= this->_M_w.size() * _S_bits_per_block)\n-\treturn __not_found;\n-\n-      // search first word\n-      size_t __i = _S_whichword(__prev);\n-      _WordT __thisword = this->_M_w[__i];\n-\n-      // mask off bits below bound\n-      __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n-\n-      if (__thisword != static_cast<_WordT>(0))\n-\treturn (__i * _S_bits_per_block\n-\t\t+ __builtin_ctzl(__thisword));\n-\n-      // check subsequent words\n-      for (++__i; __i < this->_M_w.size(); ++__i)\n-\t{\n-\t  __thisword = this->_M_w[__i];\n-\t  if (__thisword != static_cast<_WordT>(0))\n-\t    return (__i * _S_bits_per_block\n-\t\t    + __builtin_ctzl(__thisword));\n-\t}\n-      // not found, so return an indication of failure.\n-      return __not_found;\n-    } // end _M_do_find_next\n-\n   /**\n    *  @brief  The %dynamic_bitset class represents a sequence of bits.\n    *\n@@ -594,6 +465,15 @@ public:\n \t  this->_M_hiword() &= ~((~static_cast<block_type>(0)) << __shift);\n       }\n \n+      //  Set the unused bits in the uppermost word.\n+      void\n+      _M_do_fill()\n+      {\n+\tsize_type __shift = this->_M_Nb % bits_per_block;\n+\tif (__shift > 0)\n+\t  this->_M_hiword() |= ((~static_cast<block_type>(0)) << __shift);\n+      }\n+\n       /**\n        *  These versions of single-bit set, reset, flip, and test\n        *  do no range checking.\n@@ -847,6 +727,8 @@ public:\n       void\n       resize(size_type __nbits, bool __value = false)\n       {\n+\tif (__value)\n+\t  this->_M_do_fill();\n \tthis->_M_resize(__nbits, __value);\n \tthis->_M_Nb = __nbits;\n \tthis->_M_do_sanitize();\n@@ -1240,33 +1122,21 @@ public:\n       bool\n       is_proper_subset_of(const dynamic_bitset& __b) const\n       { return this->_M_is_proper_subset_of(__b); }\n-    };\n \n-  // Definitions of non-inline member functions.\n-  template<typename _WordT, typename _Alloc>\n-    template<typename _CharT, typename _Traits>\n-      void\n-      dynamic_bitset<_WordT, _Alloc>::\n-      _M_copy_from_ptr(const _CharT* __str, size_t __len,\n-\t\t       size_t __pos, size_t __n, _CharT __zero, _CharT __one)\n-      {\n-\treset();\n-\tconst size_t __nbits = std::min(_M_Nb, std::min(__n, __len - __pos));\n-\tfor (size_t __i = __nbits; __i > 0; --__i)\n-\t  {\n-\t    const _CharT __c = __str[__pos + __nbits - __i];\n-\t    if (_Traits::eq(__c, __zero))\n-\t      ;\n-\t    else if (_Traits::eq(__c, __one))\n-\t      _M_unchecked_set(__i - 1);\n-\t    else\n-\t      __throw_invalid_argument(__N(\"dynamic_bitset::_M_copy_from_ptr\"));\n-\t  }\n-      }\n+      friend bool\n+      operator==(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n+\t\t const dynamic_bitset<_WordT, _Alloc>& __rhs)\n+      { return __lhs._M_is_equal(__rhs); }\n+\n+      friend bool\n+      operator<(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n+\t\tconst dynamic_bitset<_WordT, _Alloc>& __rhs)\n+      { return __lhs._M_is_less(__rhs); }\n+    };\n \n   template<typename _WordT, typename _Alloc>\n     template<typename _CharT, typename _Traits, typename _Alloc1>\n-      void\n+      inline void\n       dynamic_bitset<_WordT, _Alloc>::\n       _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc1>& __str,\n \t\t\t_CharT __zero, _CharT __one) const\n@@ -1280,38 +1150,27 @@ public:\n \n   //@{\n   /// These comparisons for equality/inequality are, well, @e bitwise.\n-  template<typename _WordT, typename _Alloc>\n-    bool\n-    operator==(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n-\t       const dynamic_bitset<_WordT, _Alloc>& __rhs)\n-    { return __lhs._M_is_equal(__rhs); }\n \n   template<typename _WordT, typename _Alloc>\n-    bool\n+    inline bool\n     operator!=(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n \t       const dynamic_bitset<_WordT, _Alloc>& __rhs)\n-    { return !__lhs._M_is_equal(__rhs); }\n-\n-  template<typename _WordT, typename _Alloc>\n-    bool\n-    operator<(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n-\t      const dynamic_bitset<_WordT, _Alloc>& __rhs)\n-    { return __lhs._M_is_less(__rhs); }\n+    { return !(__lhs == __rhs); }\n \n   template<typename _WordT, typename _Alloc>\n-    bool\n+    inline bool\n     operator<=(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n \t       const dynamic_bitset<_WordT, _Alloc>& __rhs)\n     { return !(__lhs > __rhs); }\n \n   template<typename _WordT, typename _Alloc>\n-    bool\n+    inline bool\n     operator>(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n \t      const dynamic_bitset<_WordT, _Alloc>& __rhs)\n     { return __rhs < __lhs; }\n \n   template<typename _WordT, typename _Alloc>\n-    bool\n+    inline bool\n     operator>=(const dynamic_bitset<_WordT, _Alloc>& __lhs,\n \t       const dynamic_bitset<_WordT, _Alloc>& __rhs)\n     { return !(__lhs < __rhs); }\n@@ -1368,90 +1227,19 @@ public:\n     }\n   //@}\n \n-  //@{\n   /**\n+   *  @defgroup Global I/O operators for bitsets.\n+   *  @{\n    *  @brief Global I/O operators for bitsets.\n    *\n    *  Direct I/O between streams and bitsets is supported.  Output is\n    *  straightforward.  Input will skip whitespace and only accept '0'\n    *  and '1' characters.  The %dynamic_bitset will grow as necessary\n    *  to hold the string of bits.\n    */\n-  template<typename _CharT, typename _Traits,\n-\t   typename _WordT, typename _Alloc>\n-    std::basic_istream<_CharT, _Traits>&\n-    operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t       dynamic_bitset<_WordT, _Alloc>& __x)\n-    {\n-      typedef typename _Traits::char_type          char_type;\n-      typedef std::basic_istream<_CharT, _Traits>  __istream_type;\n-      typedef typename __istream_type::ios_base    __ios_base;\n-\n-      std::basic_string<_CharT, _Traits> __tmp;\n-      __tmp.reserve(__x.size());\n-\n-      const char_type __zero = __is.widen('0');\n-      const char_type __one = __is.widen('1');\n-\n-      typename __ios_base::iostate __state = __ios_base::goodbit;\n-      typename __istream_type::sentry __sentry(__is);\n-      if (__sentry)\n-\t{\n-\t  __try\n-\t    {\n-\t      while (1)\n-\t\t{\n-\t\t  static typename _Traits::int_type __eof = _Traits::eof();\n-\n-\t\t  typename _Traits::int_type __c1 = __is.rdbuf()->sbumpc();\n-\t\t  if (_Traits::eq_int_type(__c1, __eof))\n-\t\t    {\n-\t\t      __state |= __ios_base::eofbit;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      const char_type __c2 = _Traits::to_char_type(__c1);\n-\t\t      if (_Traits::eq(__c2, __zero))\n-\t\t\t__tmp.push_back(__zero);\n-\t\t      else if (_Traits::eq(__c2, __one))\n-\t\t\t__tmp.push_back(__one);\n-\t\t      else if (_Traits::\n-\t\t\t       eq_int_type(__is.rdbuf()->sputbackc(__c2),\n-\t\t\t\t\t   __eof))\n-\t\t\t{\n-\t\t\t  __state |= __ios_base::failbit;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      else\n-\t\t\tbreak;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  __catch(__cxxabiv1::__forced_unwind&)\n-\t    {\n-\t      __is._M_setstate(__ios_base::badbit);\n-\t      __throw_exception_again;\n-\t    }\n-\t  __catch(...)\n-\t    { __is._M_setstate(__ios_base::badbit); }\n-\t}\n-\n-      __x.resize(__tmp.size());\n-\n-      if (__tmp.empty() && __x.size())\n-\t__state |= __ios_base::failbit;\n-      else\n-\t__x._M_copy_from_string(__tmp, static_cast<size_t>(0), __x.size(),\n-\t\t\t\t__zero, __one);\n-      if (__state)\n-\t__is.setstate(__state);\n-      return __is;\n-    }\n-\n   template <typename _CharT, typename _Traits,\n \t    typename _WordT, typename _Alloc>\n-    std::basic_ostream<_CharT, _Traits>&\n+    inline std::basic_ostream<_CharT, _Traits>&\n     operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n \t       const dynamic_bitset<_WordT, _Alloc>& __x)\n     {\n@@ -1461,12 +1249,14 @@ public:\n       __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));\n       return __os << __tmp;\n     }\n-  //@}\n+  /**\n+   *  @}\n+   */\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // tr2\n } // std\n \n-#undef _GLIBCXX_BITSET_BITS_PER_WORD\n+#include <tr2/dynamic_bitset.tcc>\n \n #endif /* _GLIBCXX_TR2_DYNAMIC_BITSET */"}, {"sha": "016fdf0bd824148cc75e07c7efff94e88e9662ef", "filename": "libstdc++-v3/include/tr2/dynamic_bitset.tcc", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr2%2Fdynamic_bitset.tcc?ref=6b8fe121affbf6fcfe19fca582c56cb9baf9b600", "patch": "@@ -0,0 +1,286 @@\n+// TR2 <dynamic_bitset> -*- C++ -*-\n+\n+// Copyright (C) 2009-2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file tr2/dynamic_bitset.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{tr2/dynamic_bitset}\n+ */\n+\n+#ifndef _GLIBCXX_TR2_DYNAMIC_BITSET_TCC\n+#define _GLIBCXX_TR2_DYNAMIC_BITSET_TCC 1\n+\n+#pragma GCC system_header\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace tr2\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  // Definitions of non-inline functions from __dynamic_bitset_base.\n+  template<typename _WordT, typename _Alloc>\n+    void\n+    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_left_shift(size_t __shift)\n+    {\n+      if (__builtin_expect(__shift != 0, 1))\n+\t{\n+\t  const size_t __wshift = __shift / _S_bits_per_block;\n+\t  const size_t __offset = __shift % _S_bits_per_block;\n+\n+\t  if (__offset == 0)\n+\t    for (size_t __n = this->_M_w.size() - 1; __n >= __wshift; --__n)\n+\t      this->_M_w[__n] = this->_M_w[__n - __wshift];\n+\t  else\n+\t    {\n+\t      const size_t __sub_offset = _S_bits_per_block - __offset;\n+\t      for (size_t __n = _M_w.size() - 1; __n > __wshift; --__n)\n+\t\tthis->_M_w[__n] = ((this->_M_w[__n - __wshift] << __offset)\n+\t\t\t     | (this->_M_w[__n - __wshift - 1] >> __sub_offset));\n+\t      this->_M_w[__wshift] = this->_M_w[0] << __offset;\n+\t    }\n+\n+\t  //// std::fill(this->_M_w.begin(), this->_M_w.begin() + __wshift,\n+\t  ////          static_cast<_WordT>(0));\n+\t}\n+    }\n+\n+  template<typename _WordT, typename _Alloc>\n+    void\n+    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_right_shift(size_t __shift)\n+    {\n+      if (__builtin_expect(__shift != 0, 1))\n+\t{\n+\t  const size_t __wshift = __shift / _S_bits_per_block;\n+\t  const size_t __offset = __shift % _S_bits_per_block;\n+\t  const size_t __limit = this->_M_w.size() - __wshift - 1;\n+\n+\t  if (__offset == 0)\n+\t    for (size_t __n = 0; __n <= __limit; ++__n)\n+\t      this->_M_w[__n] = this->_M_w[__n + __wshift];\n+\t  else\n+\t    {\n+\t      const size_t __sub_offset = (_S_bits_per_block\n+\t\t\t\t\t   - __offset);\n+\t      for (size_t __n = 0; __n < __limit; ++__n)\n+\t\tthis->_M_w[__n] = ((this->_M_w[__n + __wshift] >> __offset)\n+\t\t\t     | (this->_M_w[__n + __wshift + 1] << __sub_offset));\n+\t      this->_M_w[__limit] = this->_M_w[_M_w.size()-1] >> __offset;\n+\t    }\n+\n+\t  ////std::fill(this->_M_w.begin() + __limit + 1, this->_M_w.end(),\n+\t  ////          static_cast<_WordT>(0));\n+\t}\n+    }\n+\n+  template<typename _WordT, typename _Alloc>\n+    unsigned long\n+    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_to_ulong() const\n+    {\n+      size_t __n = sizeof(unsigned long) / sizeof(block_type);\n+      for (size_t __i = __n; __i < this->_M_w.size(); ++__i)\n+\tif (this->_M_w[__i])\n+\t  __throw_overflow_error(__N(\"__dynamic_bitset_base::_M_do_to_ulong\"));\n+      unsigned long __res = 0UL;\n+      for (size_t __i = 0; __i < __n && __i < this->_M_w.size(); ++__i)\n+\t__res += this->_M_w[__i] << (__i * _S_bits_per_block);\n+      return __res;\n+    }\n+\n+  template<typename _WordT, typename _Alloc>\n+    unsigned long long\n+    __dynamic_bitset_base<_WordT, _Alloc>::_M_do_to_ullong() const\n+    {\n+      size_t __n = sizeof(unsigned long long) / sizeof(block_type);\n+      for (size_t __i = __n; __i < this->_M_w.size(); ++__i)\n+\tif (this->_M_w[__i])\n+\t  __throw_overflow_error(__N(\"__dynamic_bitset_base::_M_do_to_ullong\"));\n+      unsigned long long __res = 0ULL;\n+      for (size_t __i = 0; __i < __n && __i < this->_M_w.size(); ++__i)\n+\t__res += this->_M_w[__i] << (__i * _S_bits_per_block);\n+      return __res;\n+    }\n+\n+  template<typename _WordT, typename _Alloc>\n+    size_t\n+    __dynamic_bitset_base<_WordT, _Alloc>\n+    ::_M_do_find_first(size_t __not_found) const\n+    {\n+      for (size_t __i = 0; __i < this->_M_w.size(); ++__i)\n+\t{\n+\t  _WordT __thisword = this->_M_w[__i];\n+\t  if (__thisword != static_cast<_WordT>(0))\n+\t    return (__i * _S_bits_per_block\n+\t\t    + __builtin_ctzl(__thisword));\n+\t}\n+      // not found, so return an indication of failure.\n+      return __not_found;\n+    }\n+\n+  template<typename _WordT, typename _Alloc>\n+    size_t\n+    __dynamic_bitset_base<_WordT, _Alloc>\n+    ::_M_do_find_next(size_t __prev, size_t __not_found) const\n+    {\n+      // make bound inclusive\n+      ++__prev;\n+\n+      // check out of bounds\n+      if (__prev >= this->_M_w.size() * _S_bits_per_block)\n+\treturn __not_found;\n+\n+      // search first word\n+      size_t __i = _S_whichword(__prev);\n+      _WordT __thisword = this->_M_w[__i];\n+\n+      // mask off bits below bound\n+      __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n+\n+      if (__thisword != static_cast<_WordT>(0))\n+\treturn (__i * _S_bits_per_block\n+\t\t+ __builtin_ctzl(__thisword));\n+\n+      // check subsequent words\n+      for (++__i; __i < this->_M_w.size(); ++__i)\n+\t{\n+\t  __thisword = this->_M_w[__i];\n+\t  if (__thisword != static_cast<_WordT>(0))\n+\t    return (__i * _S_bits_per_block\n+\t\t    + __builtin_ctzl(__thisword));\n+\t}\n+      // not found, so return an indication of failure.\n+      return __not_found;\n+    } // end _M_do_find_next\n+\n+  // Definitions of non-inline member functions.\n+  template<typename _WordT, typename _Alloc>\n+    template<typename _CharT, typename _Traits>\n+      void\n+      dynamic_bitset<_WordT, _Alloc>::\n+      _M_copy_from_ptr(const _CharT* __str, size_t __len,\n+\t\t       size_t __pos, size_t __n, _CharT __zero, _CharT __one)\n+      {\n+\treset();\n+\tconst size_t __nbits = std::min(_M_Nb, std::min(__n, __len - __pos));\n+\tfor (size_t __i = __nbits; __i > 0; --__i)\n+\t  {\n+\t    const _CharT __c = __str[__pos + __nbits - __i];\n+\t    if (_Traits::eq(__c, __zero))\n+\t      ;\n+\t    else if (_Traits::eq(__c, __one))\n+\t      _M_unchecked_set(__i - 1);\n+\t    else\n+\t      __throw_invalid_argument(__N(\"dynamic_bitset::_M_copy_from_ptr\"));\n+\t  }\n+      }\n+\n+  /**\n+   *  @defgroup Global I/O operators for bitsets.\n+   *  @{\n+   *  @brief Global I/O operators for bitsets.\n+   *\n+   *  Direct I/O between streams and bitsets is supported.  Output is\n+   *  straightforward.  Input will skip whitespace and only accept '0'\n+   *  and '1' characters.  The %dynamic_bitset will grow as necessary\n+   *  to hold the string of bits.\n+   */\n+  template<typename _CharT, typename _Traits,\n+\t   typename _WordT, typename _Alloc>\n+    std::basic_istream<_CharT, _Traits>&\n+    operator>>(std::basic_istream<_CharT, _Traits>& __is,\n+\t       dynamic_bitset<_WordT, _Alloc>& __x)\n+    {\n+      typedef typename _Traits::char_type          char_type;\n+      typedef std::basic_istream<_CharT, _Traits>  __istream_type;\n+      typedef typename __istream_type::ios_base    __ios_base;\n+\n+      std::basic_string<_CharT, _Traits> __tmp;\n+      __tmp.reserve(__x.size());\n+\n+      const char_type __zero = __is.widen('0');\n+      const char_type __one = __is.widen('1');\n+\n+      typename __ios_base::iostate __state = __ios_base::goodbit;\n+      typename __istream_type::sentry __sentry(__is);\n+      if (__sentry)\n+\t{\n+\t  __try\n+\t    {\n+\t      while (1)\n+\t\t{\n+\t\t  static typename _Traits::int_type __eof = _Traits::eof();\n+\n+\t\t  typename _Traits::int_type __c1 = __is.rdbuf()->sbumpc();\n+\t\t  if (_Traits::eq_int_type(__c1, __eof))\n+\t\t    {\n+\t\t      __state |= __ios_base::eofbit;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      const char_type __c2 = _Traits::to_char_type(__c1);\n+\t\t      if (_Traits::eq(__c2, __zero))\n+\t\t\t__tmp.push_back(__zero);\n+\t\t      else if (_Traits::eq(__c2, __one))\n+\t\t\t__tmp.push_back(__one);\n+\t\t      else if (_Traits::\n+\t\t\t       eq_int_type(__is.rdbuf()->sputbackc(__c2),\n+\t\t\t\t\t   __eof))\n+\t\t\t{\n+\t\t\t  __state |= __ios_base::failbit;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      else\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  __catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __is._M_setstate(__ios_base::badbit);\n+\t      __throw_exception_again;\n+\t    }\n+\t  __catch(...)\n+\t    { __is._M_setstate(__ios_base::badbit); }\n+\t}\n+\n+      __x.resize(__tmp.size());\n+\n+      if (__tmp.empty() && __x.size())\n+\t__state |= __ios_base::failbit;\n+      else\n+\t__x._M_copy_from_string(__tmp, static_cast<size_t>(0), __x.size(),\n+\t\t\t\t__zero, __one);\n+      if (__state)\n+\t__is.setstate(__state);\n+      return __is;\n+    }\n+  /**\n+   *  @}\n+   */\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // tr2\n+} // std\n+\n+#endif /* _GLIBCXX_TR2_DYNAMIC_BITSET_TCC */"}, {"sha": "7607e3f2c76da61b318b1e471844bf0a6c2064bb", "filename": "libstdc++-v3/testsuite/tr2/dynamic_bitset/pr58729.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fpr58729.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8fe121affbf6fcfe19fca582c56cb9baf9b600/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fpr58729.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr2%2Fdynamic_bitset%2Fpr58729.cc?ref=6b8fe121affbf6fcfe19fca582c56cb9baf9b600", "patch": "@@ -0,0 +1,64 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+// 2013-10-15  Edward M. Smith-Rowland  <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/58729\n+\n+#include <tr2/dynamic_bitset>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::tr2::dynamic_bitset<> pdb2{};\n+\n+  pdb2.resize(10, true);\n+  VERIFY (pdb2 == std::tr2::dynamic_bitset<>{\"1111111111\"});\n+\n+  pdb2.resize(15);\n+  VERIFY (pdb2 == std::tr2::dynamic_bitset<>{\"000001111111111\"});\n+\n+  pdb2.flip();\n+  VERIFY (pdb2 == std::tr2::dynamic_bitset<>{\"111110000000000\"});\n+\n+  VERIFY (pdb2.size() == 15);\n+  VERIFY (pdb2.count() == 5);\n+\n+  pdb2.resize(20, false);\n+  VERIFY (pdb2 == std::tr2::dynamic_bitset<>{\"00000111110000000000\"});\n+\n+  pdb2.resize(25, true);\n+  VERIFY (pdb2 == std::tr2::dynamic_bitset<>{\"1111100000111110000000000\"});\n+\n+  pdb2.resize(75, true);\n+  VERIFY (pdb2 == std::tr2::dynamic_bitset<>{\"1111111111111111111111111\"\n+\t\t\t\t\t     \"1111111111111111111111111\"\n+\t\t\t\t\t     \"1111100000111110000000000\"});\n+\n+  VERIFY (pdb2.size() == 75);\n+  VERIFY (pdb2.count() == 60);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}