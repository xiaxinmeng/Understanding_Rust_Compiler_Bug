{"sha": "d7b8f2b7816952c96c769c62eca10c647caa3530", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdiOGYyYjc4MTY5NTJjOTZjNzY5YzYyZWNhMTBjNjQ3Y2FhMzUzMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-17T05:30:25Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-17T05:30:25Z"}, "message": "runtime: Print stack trace on panic or signal.\n\nFrom-SVN: r187623", "tree": {"sha": "ee128f558640851fefb4f2a94c2d38f45b2ee2a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee128f558640851fefb4f2a94c2d38f45b2ee2a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7b8f2b7816952c96c769c62eca10c647caa3530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7b8f2b7816952c96c769c62eca10c647caa3530", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7b8f2b7816952c96c769c62eca10c647caa3530", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7b8f2b7816952c96c769c62eca10c647caa3530/comments", "author": null, "committer": null, "parents": [{"sha": "8730965e4297b5f96210b2e80e70c5b302486723", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8730965e4297b5f96210b2e80e70c5b302486723", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8730965e4297b5f96210b2e80e70c5b302486723"}], "stats": {"total": 323, "additions": 262, "deletions": 61}, "files": [{"sha": "a27216a962649f2a97cf6e244ac7f6be1c392661", "filename": "libgo/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=d7b8f2b7816952c96c769c62eca10c647caa3530", "patch": "@@ -439,6 +439,7 @@ runtime_files = \\\n \truntime/go-string-to-int-array.c \\\n \truntime/go-strplus.c \\\n \truntime/go-strslice.c \\\n+\truntime/go-traceback.c \\\n \truntime/go-trampoline.c \\\n \truntime/go-type-complex.c \\\n \truntime/go-type-eface.c \\"}, {"sha": "018ac859fcb72eb30756b7d899f435ea0c42d32b", "filename": "libgo/Makefile.in", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=d7b8f2b7816952c96c769c62eca10c647caa3530", "patch": "@@ -197,22 +197,23 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-setenv.c runtime/go-signal.c runtime/go-strcmp.c \\\n \truntime/go-string-to-byte-array.c \\\n \truntime/go-string-to-int-array.c runtime/go-strplus.c \\\n-\truntime/go-strslice.c runtime/go-trampoline.c \\\n-\truntime/go-type-complex.c runtime/go-type-eface.c \\\n-\truntime/go-type-error.c runtime/go-type-float.c \\\n-\truntime/go-type-identity.c runtime/go-type-interface.c \\\n-\truntime/go-type-string.c runtime/go-typedesc-equal.c \\\n-\truntime/go-typestring.c runtime/go-unsafe-new.c \\\n-\truntime/go-unsafe-newarray.c runtime/go-unsafe-pointer.c \\\n-\truntime/go-unwind.c runtime/chan.c runtime/cpuprof.c \\\n-\truntime/lock_sema.c runtime/thread-sema.c runtime/lock_futex.c \\\n-\truntime/thread-linux.c runtime/mcache.c runtime/mcentral.c \\\n-\truntime/mem_posix_memalign.c runtime/mem.c runtime/mfinal.c \\\n-\truntime/mfixalloc.c runtime/mgc0.c runtime/mheap.c \\\n-\truntime/msize.c runtime/proc.c runtime/runtime.c \\\n-\truntime/signal_unix.c runtime/thread.c runtime/yield.c \\\n-\truntime/rtems-task-variable-add.c iface.c malloc.c map.c \\\n-\tmprof.c reflect.c runtime1.c sema.c sigqueue.c string.c time.c\n+\truntime/go-strslice.c runtime/go-traceback.c \\\n+\truntime/go-trampoline.c runtime/go-type-complex.c \\\n+\truntime/go-type-eface.c runtime/go-type-error.c \\\n+\truntime/go-type-float.c runtime/go-type-identity.c \\\n+\truntime/go-type-interface.c runtime/go-type-string.c \\\n+\truntime/go-typedesc-equal.c runtime/go-typestring.c \\\n+\truntime/go-unsafe-new.c runtime/go-unsafe-newarray.c \\\n+\truntime/go-unsafe-pointer.c runtime/go-unwind.c runtime/chan.c \\\n+\truntime/cpuprof.c runtime/lock_sema.c runtime/thread-sema.c \\\n+\truntime/lock_futex.c runtime/thread-linux.c runtime/mcache.c \\\n+\truntime/mcentral.c runtime/mem_posix_memalign.c runtime/mem.c \\\n+\truntime/mfinal.c runtime/mfixalloc.c runtime/mgc0.c \\\n+\truntime/mheap.c runtime/msize.c runtime/proc.c \\\n+\truntime/runtime.c runtime/signal_unix.c runtime/thread.c \\\n+\truntime/yield.c runtime/rtems-task-variable-add.c iface.c \\\n+\tmalloc.c map.c mprof.c reflect.c runtime1.c sema.c sigqueue.c \\\n+\tstring.c time.c\n @LIBGO_IS_LINUX_FALSE@am__objects_1 = lock_sema.lo thread-sema.lo\n @LIBGO_IS_LINUX_TRUE@am__objects_1 = lock_futex.lo thread-linux.lo\n @HAVE_SYS_MMAN_H_FALSE@am__objects_2 = mem_posix_memalign.lo\n@@ -234,16 +235,16 @@ am__objects_4 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-reflect-map.lo go-rune.lo go-runtime-error.lo go-setenv.lo \\\n \tgo-signal.lo go-strcmp.lo go-string-to-byte-array.lo \\\n \tgo-string-to-int-array.lo go-strplus.lo go-strslice.lo \\\n-\tgo-trampoline.lo go-type-complex.lo go-type-eface.lo \\\n-\tgo-type-error.lo go-type-float.lo go-type-identity.lo \\\n-\tgo-type-interface.lo go-type-string.lo go-typedesc-equal.lo \\\n-\tgo-typestring.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n-\tgo-unsafe-pointer.lo go-unwind.lo chan.lo cpuprof.lo \\\n-\t$(am__objects_1) mcache.lo mcentral.lo $(am__objects_2) \\\n-\tmfinal.lo mfixalloc.lo mgc0.lo mheap.lo msize.lo proc.lo \\\n-\truntime.lo signal_unix.lo thread.lo yield.lo $(am__objects_3) \\\n-\tiface.lo malloc.lo map.lo mprof.lo reflect.lo runtime1.lo \\\n-\tsema.lo sigqueue.lo string.lo time.lo\n+\tgo-traceback.lo go-trampoline.lo go-type-complex.lo \\\n+\tgo-type-eface.lo go-type-error.lo go-type-float.lo \\\n+\tgo-type-identity.lo go-type-interface.lo go-type-string.lo \\\n+\tgo-typedesc-equal.lo go-typestring.lo go-unsafe-new.lo \\\n+\tgo-unsafe-newarray.lo go-unsafe-pointer.lo go-unwind.lo \\\n+\tchan.lo cpuprof.lo $(am__objects_1) mcache.lo mcentral.lo \\\n+\t$(am__objects_2) mfinal.lo mfixalloc.lo mgc0.lo mheap.lo \\\n+\tmsize.lo proc.lo runtime.lo signal_unix.lo thread.lo yield.lo \\\n+\t$(am__objects_3) iface.lo malloc.lo map.lo mprof.lo reflect.lo \\\n+\truntime1.lo sema.lo sigqueue.lo string.lo time.lo\n am_libgo_la_OBJECTS = $(am__objects_4)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -855,6 +856,7 @@ runtime_files = \\\n \truntime/go-string-to-int-array.c \\\n \truntime/go-strplus.c \\\n \truntime/go-strslice.c \\\n+\truntime/go-traceback.c \\\n \truntime/go-trampoline.c \\\n \truntime/go-type-complex.c \\\n \truntime/go-type-eface.c \\\n@@ -2408,6 +2410,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-string-to-int-array.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strplus.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strslice.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-traceback.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-trampoline.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-complex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-eface.Plo@am__quote@\n@@ -2823,6 +2826,13 @@ go-strslice.lo: runtime/go-strslice.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-strslice.lo `test -f 'runtime/go-strslice.c' || echo '$(srcdir)/'`runtime/go-strslice.c\n \n+go-traceback.lo: runtime/go-traceback.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-traceback.lo -MD -MP -MF $(DEPDIR)/go-traceback.Tpo -c -o go-traceback.lo `test -f 'runtime/go-traceback.c' || echo '$(srcdir)/'`runtime/go-traceback.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-traceback.Tpo $(DEPDIR)/go-traceback.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-traceback.c' object='go-traceback.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-traceback.lo `test -f 'runtime/go-traceback.c' || echo '$(srcdir)/'`runtime/go-traceback.c\n+\n go-trampoline.lo: runtime/go-trampoline.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-trampoline.lo -MD -MP -MF $(DEPDIR)/go-trampoline.Tpo -c -o go-trampoline.lo `test -f 'runtime/go-trampoline.c' || echo '$(srcdir)/'`runtime/go-trampoline.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-trampoline.Tpo $(DEPDIR)/go-trampoline.Plo"}, {"sha": "5d398b04a02251d9184d9f5a3c63018616cef759", "filename": "libgo/runtime/go-signal.c", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fgo-signal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fgo-signal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-signal.c?ref=d7b8f2b7816952c96c769c62eca10c647caa3530", "patch": "@@ -157,7 +157,6 @@ sig_handler (int sig)\n \n   for (i = 0; runtime_sigtab[i].sig != -1; ++i)\n     {\n-      struct sigaction sa;\n       SigTab *t;\n \n       t = &runtime_sigtab[i];\n@@ -177,21 +176,33 @@ sig_handler (int sig)\n \n       runtime_startpanic ();\n \n-      /* We should do a stack backtrace here.  Until we can do that,\n-\t we reraise the signal in order to get a slightly better\n-\t report from the shell.  */\n+      {\n+\tconst char *name = NULL;\n \n-      memset (&sa, 0, sizeof sa);\n+#ifdef HAVE_STRSIGNAL\n+\tname = strsignal (sig);\n+#endif\n \n-      sa.sa_handler = SIG_DFL;\n+\tif (name == NULL)\n+\t  runtime_printf (\"Signal %d\\n\", sig);\n+\telse\n+\t  runtime_printf (\"%s\\n\", name);\n+      }\n \n-      i = sigemptyset (&sa.sa_mask);\n-      __go_assert (i == 0);\n+      runtime_printf (\"\\n\");\n \n-      if (sigaction (sig, &sa, NULL) != 0)\n-\tabort ();\n+      if (runtime_gotraceback ())\n+\t{\n+\t  G *g;\n \n-      raise (sig);\n+\t  g = runtime_g ();\n+\t  runtime_traceback (g);\n+\t  runtime_tracebackothers (g);\n+\n+\t  /* The gc library calls runtime_dumpregs here, and provides\n+\t     a function that prints the registers saved in context in\n+\t     a readable form.  */\n+\t}\n \n       runtime_exit (2);\n     }\n@@ -230,12 +241,22 @@ static void\n sig_panic_info_handler (int sig, siginfo_t *info,\n \t\t\tvoid *context __attribute__ ((unused)))\n {\n-  if (runtime_g () == NULL || info->si_code == SI_USER)\n+  G *g;\n+\n+  g = runtime_g ();\n+  if (g == NULL || info->si_code == SI_USER)\n     {\n       sig_handler (sig);\n       return;\n     }\n \n+  g->sig = sig;\n+  g->sigcode0 = info->si_code;\n+  g->sigcode1 = (uintptr_t) info->si_addr;\n+\n+  /* It would be nice to set g->sigpc here as the gc library does, but\n+     I don't know how to get it portably.  */\n+\n   sig_panic_leadin (sig);\n \n   switch (sig)\n@@ -284,12 +305,19 @@ sig_panic_info_handler (int sig, siginfo_t *info,\n static void\n sig_panic_handler (int sig)\n {\n-  if (runtime_g () == NULL)\n+  G *g;\n+\n+  g = runtime_g ();\n+  if (g == NULL)\n     {\n       sig_handler (sig);\n       return;\n     }\n \n+  g->sig = sig;\n+  g->sigcode0 = 0;\n+  g->sigcode1 = 0;\n+\n   sig_panic_leadin (sig);\n \n   switch (sig)"}, {"sha": "2ff2ce3faef3434c5e3e0a4b9dfc2df9de13d0a8", "filename": "libgo/runtime/go-traceback.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fgo-traceback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fgo-traceback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-traceback.c?ref=d7b8f2b7816952c96c769c62eca10c647caa3530", "patch": "@@ -0,0 +1,62 @@\n+/* go-traceback.c -- stack backtrace for Go.\n+\n+   Copyright 2012 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include \"config.h\"\n+\n+#include \"unwind.h\"\n+\n+#include \"runtime.h\"\n+#include \"go-string.h\"\n+\n+static _Unwind_Reason_Code\n+traceback (struct _Unwind_Context *context, void *varg)\n+{\n+  int *parg = (int *) varg;\n+  uintptr pc;\n+  int ip_before_insn = 0;\n+  struct __go_string fn;\n+  struct __go_string file;\n+  int line;\n+\n+#ifdef HAVE_GETIPINFO\n+  pc = _Unwind_GetIPInfo (context, &ip_before_insn);\n+#else\n+  pc = _Unwind_GetIP (context);\n+#endif\n+\n+  if (*parg > 100)\n+    return _URC_END_OF_STACK;\n+  ++*parg;\n+\n+  /* FIXME: If PC is in the __morestack routine, we should ignore\n+     it.  */\n+\n+  /* Back up to the call instruction.  */\n+  if (!ip_before_insn)\n+    --pc;\n+\n+  if (!__go_file_line (pc, &fn, &file, &line))\n+    return _URC_END_OF_STACK;\n+\n+  if (runtime_showframe (fn.__data))\n+    {\n+      runtime_printf (\"%s\\n\", fn.__data);\n+      runtime_printf (\"\\t%s:%d\\n\", file.__data, line);\n+    }\n+\n+  return _URC_NO_REASON;\n+}\n+\n+/* Print a stack trace for the current goroutine.  */\n+\n+void\n+runtime_traceback ()\n+{\n+  int c;\n+\n+  c = 0;\n+  _Unwind_Backtrace (traceback, &c);\n+}"}, {"sha": "a8bee206f9c00ce80ba34c48207652ea221085cf", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=d7b8f2b7816952c96c769c62eca10c647caa3530", "patch": "@@ -361,10 +361,11 @@ func Stack(b Slice, all bool) (n int32) {\n \t\tg->writenbuf = b.__count;\n \t\tUSED(pc);\n \t\tUSED(sp);\n-\t\t// runtime_goroutineheader(g);\n-\t\t// runtime_traceback(pc, sp, 0, g);\n-\t\t// if(all)\n-\t\t//\truntime_tracebackothers(g);\n+\t\truntime_goroutineheader(g);\n+\t\truntime_traceback();\n+\t\truntime_goroutinetrailer(g);\n+\t\tif(all)\n+\t\t\truntime_tracebackothers(g);\n \t\tn = b.__count - g->writenbuf;\n \t\tg->writebuf = nil;\n \t\tg->writenbuf = 0;"}, {"sha": "890b492d404eeefac63bb10d4fc76044979a3659", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 70, "deletions": 9, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=d7b8f2b7816952c96c769c62eca10c647caa3530", "patch": "@@ -50,6 +50,8 @@ uintptr runtime_stacks_sys;\n \n static void schedule(G*);\n \n+static void gtraceback(G*);\n+\n typedef struct Sched Sched;\n \n M\truntime_m0;\n@@ -345,6 +347,9 @@ runtime_mcall(void (*pfn)(G*))\n \t\t// the values for this thread.\n \t\tmp = runtime_m();\n \t\tgp = runtime_g();\n+\n+\t\tif(gp->dotraceback != nil)\n+\t\t\tgtraceback(gp);\n \t}\n \tif (gp == nil || !gp->fromgogo) {\n #ifdef USING_SPLIT_STACK\n@@ -523,19 +528,73 @@ runtime_goroutineheader(G *g)\n }\n \n void\n-runtime_tracebackothers(G *me)\n+runtime_goroutinetrailer(G *g)\n {\n-\tG *g;\n+\tif(g != nil && g->gopc != 0 && g->goid != 1) {\n+\t\tstruct __go_string fn;\n+\t\tstruct __go_string file;\n+\t\tint line;\n+\n+\t\tif(__go_file_line(g->gopc - 1, &fn, &file, &line)) {\n+\t\t\truntime_printf(\"created by %s\\n\", fn.__data);\n+\t\t\truntime_printf(\"\\t%s:%d\\n\", file.__data, line);\n+\t\t}\n+\t}\n+}\n+\n+void\n+runtime_tracebackothers(G * volatile me)\n+{\n+\tG * volatile g;\n \n \tfor(g = runtime_allg; g != nil; g = g->alllink) {\n \t\tif(g == me || g->status == Gdead)\n \t\t\tcontinue;\n \t\truntime_printf(\"\\n\");\n \t\truntime_goroutineheader(g);\n-\t\t// runtime_traceback(g->sched.pc, g->sched.sp, 0, g);\n+\n+\t\t// Our only mechanism for doing a stack trace is\n+\t\t// _Unwind_Backtrace.  And that only works for the\n+\t\t// current thread, not for other random goroutines.\n+\t\t// So we need to switch context to the goroutine, get\n+\t\t// the backtrace, and then switch back.\n+\n+\t\t// This means that if g is running or in a syscall, we\n+\t\t// can't reliably print a stack trace.  FIXME.\n+\t\tif(g->status == Gsyscall || g->status == Grunning) {\n+\t\t\truntime_printf(\"no stack trace available\\n\");\n+\t\t\truntime_goroutinetrailer(g);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tg->dotraceback = me;\n+\n+#ifdef USING_SPLIT_STACK\n+\t\t__splitstack_getcontext(&me->stack_context[0]);\n+#endif\n+\t\tgetcontext(&me->context);\n+\n+\t\tif(g->dotraceback) {\n+\t\t\truntime_gogo(g);\n+\t\t}\n \t}\n }\n \n+// Do a stack trace of gp, and then restore the context to\n+// gp->dotraceback.\n+\n+static void\n+gtraceback(G* gp)\n+{\n+\tG* ret;\n+\n+\truntime_traceback(nil);\n+\truntime_goroutinetrailer(gp);\n+\tret = gp->dotraceback;\n+\tgp->dotraceback = nil;\n+\truntime_gogo(ret);\n+}\n+\n // Mark this g as m's idle goroutine.\n // This functionality might be used in environments where programs\n // are limited to a single thread, to simulate a select-driven\n@@ -1171,7 +1230,7 @@ runtime_entersyscall(void)\n \n \t// Leave SP around for gc and traceback.\n #ifdef USING_SPLIT_STACK\n-\tg->gcstack = __splitstack_find(NULL, NULL, &g->gcstack_size,\n+\tg->gcstack = __splitstack_find(nil, nil, &g->gcstack_size,\n \t\t\t\t       &g->gcnext_segment, &g->gcnext_sp,\n \t\t\t\t       &g->gcinitial_sp);\n #else\n@@ -1227,9 +1286,11 @@ runtime_exitsyscall(void)\n \t// find that we still have mcpu <= mcpumax, then we can\n \t// start executing Go code immediately, without having to\n \t// schedlock/schedunlock.\n+\t// Also do fast return if any locks are held, so that\n+\t// panic code can use syscalls to open a file.\n \tgp = g;\n \tv = runtime_xadd(&runtime_sched.atomic, (1<<mcpuShift));\n-\tif(m->profilehz == runtime_sched.profilehz && atomic_mcpu(v) <= atomic_mcpumax(v)) {\n+\tif((m->profilehz == runtime_sched.profilehz && atomic_mcpu(v) <= atomic_mcpumax(v)) || m->locks > 0) {\n \t\t// There's a cpu for us, so we can run.\n \t\tgp->status = Grunning;\n \t\t// Garbage collector isn't running (since we are),\n@@ -1561,7 +1622,7 @@ runtime_sigprof(uint8 *pc __attribute__ ((unused)),\n \t\tuint8 *lr __attribute__ ((unused)),\n \t\tG *gp __attribute__ ((unused)))\n {\n-\t// int32 n;\n+\tint32 n;\n \n \tif(prof.fn == nil || prof.hz == 0)\n \t\treturn;\n@@ -1571,9 +1632,9 @@ runtime_sigprof(uint8 *pc __attribute__ ((unused)),\n \t\truntime_unlock(&prof);\n \t\treturn;\n \t}\n-\t// n = runtime_gentraceback(pc, sp, lr, gp, 0, prof.pcbuf, nelem(prof.pcbuf));\n-\t// if(n > 0)\n-\t// \tprof.fn(prof.pcbuf, n);\n+\tn = runtime_callers(0, prof.pcbuf, nelem(prof.pcbuf));\n+\tif(n > 0)\n+\t\tprof.fn(prof.pcbuf, n);\n \truntime_unlock(&prof);\n }\n "}, {"sha": "3c8d76225fc7a5d98944df0eee1d6804487d55cd", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=d7b8f2b7816952c96c769c62eca10c647caa3530", "patch": "@@ -11,6 +11,17 @@\n \n uint32\truntime_panicking;\n \n+int32\n+runtime_gotraceback(void)\n+{\n+\tconst byte *p;\n+\n+\tp = runtime_getenv(\"GOTRACEBACK\");\n+\tif(p == nil || p[0] == '\\0')\n+\t\treturn 1;\t// default is on\n+\treturn runtime_atoi(p);\n+}\n+\n static Lock paniclk;\n \n void\n@@ -31,20 +42,26 @@ runtime_startpanic(void)\n void\n runtime_dopanic(int32 unused __attribute__ ((unused)))\n {\n-\t/*\n+\tG* g;\n \tstatic bool didothers;\n \n+\tg = runtime_g();\n \tif(g->sig != 0)\n-\t\truntime_printf(\"[signal %x code=%p addr=%p pc=%p]\\n\",\n-\t\t\tg->sig, g->sigcode0, g->sigcode1, g->sigpc);\n+\t\truntime_printf(\"[signal %x code=%p addr=%p]\\n\",\n+\t\t\tg->sig, (void*)(g->sigcode0), (void*)(g->sigcode1));\n \n \tif(runtime_gotraceback()){\n+\t\tif(g != runtime_m()->g0) {\n+\t\t\truntime_printf(\"\\n\");\n+\t\t\truntime_goroutineheader(g);\n+\t\t\truntime_traceback();\n+\t\t\truntime_goroutinetrailer(g);\n+\t\t}\n \t\tif(!didothers) {\n \t\t\tdidothers = true;\n \t\t\truntime_tracebackothers(g);\n \t\t}\n \t}\n-\t*/\n \n \truntime_unlock(&paniclk);\n \tif(runtime_xadd(&runtime_panicking, -1) != 0) {\n@@ -185,10 +202,10 @@ runtime_fastrand1(void)\n }\n \n static struct root_list runtime_roots =\n-{ NULL,\n+{ nil,\n   { { &syscall_Envs, sizeof syscall_Envs },\n     { &os_Args, sizeof os_Args },\n-    { NULL, 0 } },\n+    { nil, 0 } },\n };\n \n void\n@@ -209,3 +226,13 @@ runtime_cputicks(void)\n   return 0;\n #endif\n }\n+\n+bool\n+runtime_showframe(const unsigned char *s)\n+{\n+\tstatic int32 traceback = -1;\n+\t\n+\tif(traceback < 0)\n+\t\ttraceback = runtime_gotraceback();\n+\treturn traceback > 1 || (__builtin_strchr((const char*)s, '.') != nil && __builtin_memcmp(s, \"runtime.\", 7) != 0);\n+}"}, {"sha": "91044184b1fb3cc81c7ffd62ec69defcca5084f7", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b8f2b7816952c96c769c62eca10c647caa3530/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=d7b8f2b7816952c96c769c62eca10c647caa3530", "patch": "@@ -143,14 +143,16 @@ struct\tG\n \tM*\tm;\t\t// for debuggers, but offset not hard-coded\n \tM*\tlockedm;\n \tM*\tidlem;\n-\t// int32\tsig;\n+\tint32\tsig;\n \tint32\twritenbuf;\n \tbyte*\twritebuf;\n-\t// uintptr\tsigcode0;\n-\t// uintptr\tsigcode1;\n+\tuintptr\tsigcode0;\n+\tuintptr\tsigcode1;\n \t// uintptr\tsigpc;\n \tuintptr\tgopc;\t// pc of go statement that created this goroutine\n \n+\tG*\tdotraceback;\n+\n \tucontext_t\tcontext;\n \tvoid*\t\tstack_context[10];\n };\n@@ -289,6 +291,11 @@ void*\truntime_mal(uintptr);\n void\truntime_schedinit(void);\n void\truntime_initsig(void);\n void\truntime_sigenable(uint32 sig);\n+int32\truntime_gotraceback(void);\n+void\truntime_goroutineheader(G*);\n+void\truntime_goroutinetrailer(G*);\n+void\truntime_traceback();\n+void\truntime_tracebackothers(G*);\n String\truntime_gostringnocopy(const byte*);\n void*\truntime_mstart(void*);\n G*\truntime_malg(int32, byte**, size_t*);\n@@ -434,6 +441,8 @@ void\truntime_osyield(void);\n void\truntime_LockOSThread(void) __asm__(\"runtime.LockOSThread\");\n void\truntime_UnlockOSThread(void) __asm__(\"runtime.UnlockOSThread\");\n \n+bool\truntime_showframe(const unsigned char*);\n+\n uintptr\truntime_memlimit(void);\n \n // If appropriate, ask the operating system to control whether this\n@@ -468,3 +477,5 @@ void\t__go_register_gc_roots(struct root_list*);\n // This will be 0 when using split stacks, as in that case\n // the stacks are allocated by the splitstack library.\n extern uintptr runtime_stacks_sys;\n+\n+extern _Bool __go_file_line (uintptr, String*, String*, int *);"}]}