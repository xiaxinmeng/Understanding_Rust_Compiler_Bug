{"sha": "b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM1ZTVkY2IxNGI4NWFkYjYyMmYwZjZlZTRjNjI5ZTlhNDRkY2RkMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-19T12:18:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-19T12:18:59Z"}, "message": "[multiple changes]\n\n2016-04-19  Bob Duff  <duff@adacore.com>\n\n\t* sem_elab.adb (Check_A_Call): There are cases where we have No\n\t(Ent) after the Alias loop, even when there was no previous error,\n\tso we can't assert that there was an error.\n\n2016-04-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Access_Attribute, OK_Self_Reference):\n\tReject use of type name as a prefix to 'access within an aggregate\n\tin a context that is not the declarative region of a type.\n\n2016-04-19  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb: Make \"gnat ls -P\" invoke gprls Make \"gnat bind\n\t-P\" invoke \"gprbuild -b\" Make \"gnat link -P\" invoke \"gprbuild\n\t-l\" Fail if the invocation is \"gnat find -P\" or \"gnat xref -P\"\n\tRemove anything related to project files\n\t* g-mbdira.adb: minor whitespace cleanup\n\t* g-spipat.adb: minor removal of extra spaces after closing paren\n\n2016-04-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Expand_Actuals):  If post-statements are present\n\tand the enclosing context is a function call or indexing, build\n\tan Expression_With_Actions for the call.\n\n2016-04-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* lib-writ.adb (Write_With_Lines): Code cleanup. Do not generate\n\ta with line for an ignored Ghost unit.\n\t* sem_ch7.adb (Analyze_Package_Declaration): Add local constant\n\tPar. A child package is Ghost when its parent is Ghost.\n\t* sem_prag.adb (Analyze_Pragma): Pragma Ghost can now apply to\n\ta subprogram declaration that acts as a compilation unit.\n\nFrom-SVN: r235191", "tree": {"sha": "404f95f515c48269fcc3d2370141e4036cc8208a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/404f95f515c48269fcc3d2370141e4036cc8208a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/comments", "author": null, "committer": null, "parents": [{"sha": "d247f8e23afb71d88a38105d3bdc342b5ecd9edc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d247f8e23afb71d88a38105d3bdc342b5ecd9edc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d247f8e23afb71d88a38105d3bdc342b5ecd9edc"}], "stats": {"total": 1401, "additions": 166, "deletions": 1235}, "files": [{"sha": "7c37bef09f6230bacbf275071f6d29e06b853e8f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "patch": "@@ -1,3 +1,39 @@\n+2016-04-19  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_elab.adb (Check_A_Call): There are cases where we have No\n+\t(Ent) after the Alias loop, even when there was no previous error,\n+\tso we can't assert that there was an error.\n+\n+2016-04-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Access_Attribute, OK_Self_Reference):\n+\tReject use of type name as a prefix to 'access within an aggregate\n+\tin a context that is not the declarative region of a type.\n+\n+2016-04-19  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb: Make \"gnat ls -P\" invoke gprls Make \"gnat bind\n+\t-P\" invoke \"gprbuild -b\" Make \"gnat link -P\" invoke \"gprbuild\n+\t-l\" Fail if the invocation is \"gnat find -P\" or \"gnat xref -P\"\n+\tRemove anything related to project files\n+\t* g-mbdira.adb: minor whitespace cleanup\n+\t* g-spipat.adb: minor removal of extra spaces after closing paren\n+\n+2016-04-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Actuals):  If post-statements are present\n+\tand the enclosing context is a function call or indexing, build\n+\tan Expression_With_Actions for the call.\n+\n+2016-04-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* lib-writ.adb (Write_With_Lines): Code cleanup. Do not generate\n+\ta with line for an ignored Ghost unit.\n+\t* sem_ch7.adb (Analyze_Package_Declaration): Add local constant\n+\tPar. A child package is Ghost when its parent is Ghost.\n+\t* sem_prag.adb (Analyze_Pragma): Pragma Ghost can now apply to\n+\ta subprogram declaration that acts as a compilation unit.\n+\n 2016-04-18  Michael Matz  <matz@suse.de>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity): Use SET_TYPE_ALIGN."}, {"sha": "4e6fadbf64f08282dca6a6b051c08023cdf9e56e", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "patch": "@@ -2074,10 +2074,13 @@ package body Exp_Ch6 is\n \n       if not Is_Empty_List (Post_Call) then\n \n-         --  Cases where the call is not a member of a statement list\n-\n-         if not Is_List_Member (N) then\n+         --  Cases where the call is not a member of a statement list.\n+         --  This includes the case where the call is an actual in another\n+         --  function call or indexing, i.e. an expression context as well.\n \n+         if not Is_List_Member (N)\n+           or else Nkind_In (Parent (N), N_Function_Call, N_Indexed_Component)\n+         then\n             --  In Ada 2012 the call may be a function call in an expression\n             --  (since OUT and IN OUT parameters are now allowed for such\n             --  calls). The write-back of (in)-out parameters is handled"}, {"sha": "c5d8c8b72912a7703952ed33f911320c775be4a0", "filename": "gcc/ada/g-mbdira.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fg-mbdira.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fg-mbdira.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-mbdira.adb?ref=b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -178,7 +178,7 @@ package body GNAT.MBBS_Discrete_Random is\n \n    begin\n       X1 := Int (Calendar.Year    (Now)) * 12 * 31 +\n-            Int (Calendar.Month   (Now) * 31)     +\n+            Int (Calendar.Month   (Now) * 31)      +\n             Int (Calendar.Day     (Now));\n \n       X2 := Int (Calendar.Seconds (Now) * Duration (1000.0));"}, {"sha": "065e37dfdd11df3bfcada1fcb56826a6be6512c6", "filename": "gcc/ada/g-spipat.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fg-spipat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fg-spipat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spipat.adb?ref=b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1998-2013, AdaCore                     --\n+--                     Copyright (C) 1998-2015, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1241,13 +1241,13 @@ package body GNAT.Spitbol.Patterns is\n    --  Called to raise Program_Error with an appropriate message if an\n    --  internal logic error is detected.\n \n-   function Str_BF (A : Boolean_Func)   return String;\n-   function Str_FP (A : File_Ptr)       return String;\n-   function Str_NF (A : Natural_Func)   return String;\n-   function Str_NP (A : Natural_Ptr)    return String;\n-   function Str_PP (A : Pattern_Ptr)    return String;\n-   function Str_VF (A : VString_Func)   return String;\n-   function Str_VP (A : VString_Ptr)    return String;\n+   function Str_BF (A : Boolean_Func) return String;\n+   function Str_FP (A : File_Ptr)     return String;\n+   function Str_NF (A : Natural_Func) return String;\n+   function Str_NP (A : Natural_Ptr)  return String;\n+   function Str_PP (A : Pattern_Ptr)  return String;\n+   function Str_VF (A : VString_Func) return String;\n+   function Str_VP (A : VString_Ptr)  return String;\n    --  These are debugging routines, which return a representation of the\n    --  given access value (they are called only by Image and Dump)\n "}, {"sha": "0d36566b8e4512d480e0de42aaf0b8f30b8ed671", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 54, "deletions": 1201, "changes": 1255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "patch": "@@ -23,32 +23,13 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-\n-with Csets;\n with Gnatvsn;\n-with Makeutl;  use Makeutl;\n-with MLib.Tgt; use MLib.Tgt;\n-with MLib.Utl;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Osint;    use Osint;\n-with Output;   use Output;\n-with Prj;      use Prj;\n-with Prj.Env;\n-with Prj.Ext;  use Prj.Ext;\n-with Prj.Pars;\n-with Prj.Tree; use Prj.Tree;\n-with Prj.Util; use Prj.Util;\n-with Sdefault;\n-with Sinput.P;\n-with Snames;   use Snames;\n-with Stringt;\n with Switch;   use Switch;\n with Table;\n with Targparm; use Targparm;\n-with Tempdir;\n-with Types;    use Types;\n \n with Ada.Characters.Handling; use Ada.Characters.Handling;\n with Ada.Command_Line;        use Ada.Command_Line;\n@@ -60,9 +41,7 @@ procedure GNATCmd is\n    Gprbuild : constant String := \"gprbuild\";\n    Gprclean : constant String := \"gprclean\";\n    Gprname  : constant String := \"gprname\";\n-\n-   Normal_Exit : exception;\n-   --  Raise this exception for normal program termination\n+   Gprls    : constant String := \"gprls\";\n \n    Error_Exit : exception;\n    --  Raise this exception if error detected\n@@ -103,25 +82,6 @@ procedure GNATCmd is\n       Pp    => Pretty);\n    --  Mapping of alternate commands to commands\n \n-   Project_Node_Tree : Project_Node_Tree_Ref;\n-   Project_File      : String_Access;\n-   Project           : Prj.Project_Id;\n-   Current_Verbosity : Prj.Verbosity := Prj.Default;\n-   Tool_Package_Name : Name_Id       := No_Name;\n-\n-   Project_Tree : constant Project_Tree_Ref :=\n-                    new Project_Tree_Data (Is_Root_Tree => True);\n-   --  The project tree\n-\n-   Old_Project_File_Used : Boolean := False;\n-   --  This flag indicates a switch -p (for gnatxref and gnatfind) for\n-   --  an old fashioned project file. -p cannot be used in conjunction\n-   --  with -P.\n-\n-   Temp_File_Name : Path_Name_Type := No_Path;\n-   --  The name of the temporary text file to put a list of source/object\n-   --  files to pass to a tool.\n-\n    package First_Switches is new Table.Table\n      (Table_Component_Type => String_Access,\n       Table_Index_Type     => Integer,\n@@ -131,32 +91,6 @@ procedure GNATCmd is\n       Table_Name           => \"Gnatcmd.First_Switches\");\n    --  A table to keep the switches from the project file\n \n-   package Carg_Switches is new Table.Table\n-     (Table_Component_Type => String_Access,\n-      Table_Index_Type     => Integer,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 20,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Gnatcmd.Carg_Switches\");\n-   --  A table to keep the switches following -cargs for ASIS tools\n-\n-   package Rules_Switches is new Table.Table\n-     (Table_Component_Type => String_Access,\n-      Table_Index_Type     => Integer,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 20,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Gnatcmd.Rules_Switches\");\n-   --  A table to keep the switches following -rules for gnatcheck\n-\n-   package Library_Paths is new Table.Table (\n-     Table_Component_Type => String_Access,\n-     Table_Index_Type     => Integer,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 20,\n-     Table_Increment      => 100,\n-     Table_Name           => \"Make.Library_Path\");\n-\n    package Last_Switches is new Table.Table\n      (Table_Component_Type => String_Access,\n       Table_Index_Type     => Integer,\n@@ -165,36 +99,6 @@ procedure GNATCmd is\n       Table_Increment      => 100,\n       Table_Name           => \"Gnatcmd.Last_Switches\");\n \n-   --  Packages of project files to pass to Prj.Pars.Parse, depending on the\n-   --  tool. We allocate objects because we cannot declare aliased objects\n-   --  as we are in a procedure, not a library level package.\n-\n-   subtype SA is String_Access;\n-\n-   Naming_String      : constant SA := new String'(\"naming\");\n-   Binder_String      : constant SA := new String'(\"binder\");\n-   Finder_String      : constant SA := new String'(\"finder\");\n-   Linker_String      : constant SA := new String'(\"linker\");\n-   Gnatls_String      : constant SA := new String'(\"gnatls\");\n-   Xref_String        : constant SA := new String'(\"cross_reference\");\n-\n-   Packages_To_Check_By_Binder   : constant String_List_Access :=\n-     new String_List'((Naming_String, Binder_String));\n-\n-   Packages_To_Check_By_Finder    : constant String_List_Access :=\n-     new String_List'((Naming_String, Finder_String));\n-\n-   Packages_To_Check_By_Linker    : constant String_List_Access :=\n-     new String_List'((Naming_String, Linker_String));\n-\n-   Packages_To_Check_By_Gnatls    : constant String_List_Access :=\n-     new String_List'((Naming_String, Gnatls_String));\n-\n-   Packages_To_Check_By_Xref      : constant String_List_Access :=\n-     new String_List'((Naming_String, Xref_String));\n-\n-   Packages_To_Check : String_List_Access := Prj.All_Packages;\n-\n    ----------------------------------\n    -- Declarations for GNATCMD use --\n    ----------------------------------\n@@ -208,14 +112,6 @@ procedure GNATCmd is\n    My_Exit_Status : Exit_Status := Success;\n    --  The exit status of the spawned tool\n \n-   Current_Work_Dir : constant String := Get_Current_Dir;\n-   --  The path of the working directory\n-\n-   All_Projects : Boolean := False;\n-   --  Flag used for GNAT CHECK, GNAT PRETTY and GNAT METRIC to indicate that\n-   --  the underlying tool (gnatcheck, gnatpp or gnatmetric) should be invoked\n-   --  for all sources of all projects.\n-\n    type Command_Entry is record\n       Cname : String_Access;\n       --  Command name for GNAT xxx command\n@@ -330,275 +226,12 @@ procedure GNATCmd is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Check_Files;\n-   --  For GNAT LIST, GNAT PRETTY and GNAT METRIC, check if a project file\n-   --  is specified, without any file arguments and without a switch -files=.\n-   --  If it is the case, invoke the GNAT tool with the proper list of files,\n-   --  derived from the sources of the project.\n-\n-   procedure Check_Relative_Executable (Name : in out String_Access);\n-   --  Check if an executable is specified as a relative path. If it is, and\n-   --  the path contains directory information, fail. Otherwise, prepend the\n-   --  exec directory. This procedure is only used for GNAT LINK when a project\n-   --  file is specified.\n-\n-   procedure Delete_Temp_Config_Files;\n-   --  Delete all temporary config files. The caller is responsible for\n-   --  ensuring that Keep_Temporary_Files is False.\n-\n-   procedure Ensure_Absolute_Path\n-     (Switch : in out String_Access;\n-      Parent : String);\n-   --  Test if Switch is a relative search path switch. If it is and it\n-   --  includes directory information, prepend the path with Parent. This\n-   --  subprogram is only called when using project files.\n-\n    procedure Output_Version;\n    --  Output the version of this program\n \n    procedure Usage;\n    --  Display usage\n \n-   procedure Process_Link;\n-   --  Process GNAT LINK, when there is a project file specified\n-\n-   procedure Set_Library_For\n-     (Project           : Project_Id;\n-      Tree              : Project_Tree_Ref;\n-      Libraries_Present : in out Boolean);\n-   --  If Project is a library project, add the correct -L and -l switches to\n-   --  the linker invocation.\n-\n-   procedure Set_Libraries is new\n-     For_Every_Project_Imported (Boolean, Set_Library_For);\n-   --  Add the -L and -l switches to the linker for all the library projects\n-\n-   -----------------\n-   -- Check_Files --\n-   -----------------\n-\n-   procedure Check_Files is\n-      Add_Sources : Boolean := True;\n-      Unit        : Prj.Unit_Index;\n-      Subunit     : Boolean := False;\n-      FD          : File_Descriptor := Invalid_FD;\n-      Status      : Integer;\n-      Success     : Boolean;\n-\n-      procedure Add_To_Response_File\n-        (File_Name  : String;\n-         Check_File : Boolean := True);\n-      --  Include the file name passed as parameter in the response file for\n-      --  the tool being called. If the response file can not be written then\n-      --  the file name is passed in the parameter list of the tool. If the\n-      --  Check_File parameter is True then the procedure verifies the\n-      --  existence of the file before adding it to the response file.\n-\n-      --------------------------\n-      -- Add_To_Response_File --\n-      --------------------------\n-\n-      procedure Add_To_Response_File\n-        (File_Name  : String;\n-         Check_File : Boolean := True)\n-      is\n-      begin\n-         Name_Len := 0;\n-\n-         Add_Str_To_Name_Buffer (File_Name);\n-\n-         if not Check_File or else\n-           Is_Regular_File (Name_Buffer (1 .. Name_Len))\n-         then\n-            if FD /= Invalid_FD then\n-               Name_Len := Name_Len + 1;\n-               Name_Buffer (Name_Len) := ASCII.LF;\n-\n-               Status := Write (FD, Name_Buffer (1)'Address, Name_Len);\n-\n-               if Status /= Name_Len then\n-                  Osint.Fail (\"disk full\");\n-               end if;\n-            else\n-               Last_Switches.Increment_Last;\n-               Last_Switches.Table (Last_Switches.Last) :=\n-                 new String'(File_Name);\n-            end if;\n-         end if;\n-      end Add_To_Response_File;\n-\n-   --  Start of processing for Check_Files\n-\n-   begin\n-      --  Check if there is at least one argument that is not a switch\n-\n-      for Index in 1 .. Last_Switches.Last loop\n-         if Last_Switches.Table (Index) (1) /= '-'\n-           or else (Last_Switches.Table (Index).all'Length > 7\n-                     and then Last_Switches.Table (Index) (1 .. 7) = \"-files=\")\n-         then\n-            Add_Sources := False;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      --  If all arguments are switches and there is no switch -files=, add the\n-      --  path names of all the sources of the main project.\n-\n-      if Add_Sources then\n-         Tempdir.Create_Temp_File (FD, Temp_File_Name);\n-         Last_Switches.Increment_Last;\n-         Last_Switches.Table (Last_Switches.Last) :=\n-           new String'(\"-files=\" & Get_Name_String (Temp_File_Name));\n-\n-         Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n-         while Unit /= No_Unit_Index loop\n-\n-            --  We only need to put the library units, body or spec, but not\n-            --  the subunits.\n-\n-            if Unit.File_Names (Impl) /= null\n-              and then not Unit.File_Names (Impl).Locally_Removed\n-            then\n-               --  There is a body, check if it is for this project\n-\n-               if All_Projects\n-                 or else Unit.File_Names (Impl).Project = Project\n-               then\n-                  Subunit := False;\n-\n-                  if Unit.File_Names (Spec) = null\n-                    or else Unit.File_Names (Spec).Locally_Removed\n-                  then\n-                     --  We have a body with no spec: we need to check if\n-                     --  this is a subunit, because gnatls will complain\n-                     --  about subunits.\n-\n-                     declare\n-                        Src_Ind : constant Source_File_Index :=\n-                                    Sinput.P.Load_Project_File\n-                                      (Get_Name_String\n-                                         (Unit.File_Names (Impl).Path.Name));\n-                     begin\n-                        Subunit := Sinput.P.Source_File_Is_Subunit (Src_Ind);\n-                     end;\n-                  end if;\n-\n-                  if not Subunit then\n-                     Add_To_Response_File\n-                       (Get_Name_String (Unit.File_Names (Impl).Display_File),\n-                        Check_File => False);\n-                  end if;\n-               end if;\n-\n-            elsif Unit.File_Names (Spec) /= null\n-              and then not Unit.File_Names (Spec).Locally_Removed\n-            then\n-               --  We have a spec with no body. Check if it is for this project\n-\n-               if All_Projects\n-                 or else Unit.File_Names (Spec).Project = Project\n-               then\n-                  Add_To_Response_File\n-                    (Get_Name_String (Unit.File_Names (Spec).Display_File),\n-                     Check_File => False);\n-               end if;\n-            end if;\n-\n-            Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n-         end loop;\n-\n-         if FD /= Invalid_FD then\n-            Close (FD, Success);\n-\n-            if not Success then\n-               Osint.Fail (\"disk full\");\n-            end if;\n-         end if;\n-      end if;\n-   end Check_Files;\n-\n-   -------------------------------\n-   -- Check_Relative_Executable --\n-   -------------------------------\n-\n-   procedure Check_Relative_Executable (Name : in out String_Access) is\n-      Exec_File_Name : constant String := Name.all;\n-\n-   begin\n-      if not Is_Absolute_Path (Exec_File_Name) then\n-         for Index in Exec_File_Name'Range loop\n-            if Exec_File_Name (Index) = Directory_Separator then\n-               Fail (\"relative executable (\"\"\" & Exec_File_Name\n-                     & \"\"\") with directory part not allowed \"\n-                     & \"when using project files\");\n-            end if;\n-         end loop;\n-\n-         Get_Name_String (Project.Exec_Directory.Name);\n-\n-         if Name_Buffer (Name_Len) /= Directory_Separator then\n-            Name_Len := Name_Len + 1;\n-            Name_Buffer (Name_Len) := Directory_Separator;\n-         end if;\n-\n-         Name_Buffer (Name_Len + 1 .. Name_Len + Exec_File_Name'Length) :=\n-           Exec_File_Name;\n-         Name_Len := Name_Len + Exec_File_Name'Length;\n-         Name := new String'(Name_Buffer (1 .. Name_Len));\n-      end if;\n-   end Check_Relative_Executable;\n-\n-   ------------------------------\n-   -- Delete_Temp_Config_Files --\n-   ------------------------------\n-\n-   procedure Delete_Temp_Config_Files is\n-      Success : Boolean;\n-      Proj    : Project_List;\n-      pragma Warnings (Off, Success);\n-\n-   begin\n-      --  This should only be called if Keep_Temporary_Files is False\n-\n-      pragma Assert (not Keep_Temporary_Files);\n-\n-      if Project /= No_Project then\n-         Proj := Project_Tree.Projects;\n-         while Proj /= null loop\n-            if Proj.Project.Config_File_Temp then\n-               Delete_Temporary_File\n-                 (Project_Tree.Shared, Proj.Project.Config_File_Name);\n-            end if;\n-\n-            Proj := Proj.Next;\n-         end loop;\n-      end if;\n-\n-      --  If a temporary text file that contains a list of files for a tool\n-      --  has been created, delete this temporary file.\n-\n-      if Temp_File_Name /= No_Path then\n-         Delete_Temporary_File (Project_Tree.Shared, Temp_File_Name);\n-      end if;\n-   end Delete_Temp_Config_Files;\n-\n-   ---------------------------\n-   -- Ensure_Absolute_Path --\n-   ---------------------------\n-\n-   procedure Ensure_Absolute_Path\n-     (Switch : in out String_Access;\n-      Parent : String)\n-   is\n-   begin\n-      Makeutl.Ensure_Absolute_Path\n-        (Switch, Parent,\n-         Do_Fail              => Osint.Fail'Access,\n-         Including_Non_Switch => False,\n-         Including_RTS        => True);\n-   end Ensure_Absolute_Path;\n-\n    --------------------\n    -- Output_Version --\n    --------------------\n@@ -628,7 +261,6 @@ procedure GNATCmd is\n       New_Line;\n \n       for C in Command_List'Range loop\n-\n          if Targparm.AAMP_On_Target then\n             Put (\"gnaampcmd \");\n          else\n@@ -654,361 +286,20 @@ procedure GNATCmd is\n       end loop;\n \n       New_Line;\n-      Put_Line (\"Commands bind, find, link, list and xref \"\n-                & \"accept project file switches -vPx, -Pprj, -Xnam=val,\"\n-                & \"--subdirs= and -eL\");\n-      New_Line;\n    end Usage;\n \n-   ------------------\n-   -- Process_Link --\n-   ------------------\n-\n-   procedure Process_Link is\n-      Look_For_Executable : Boolean := True;\n-      Libraries_Present   : Boolean := False;\n-      Path_Option         : constant String_Access :=\n-                              MLib.Linker_Library_Path_Option;\n-      Prj                 : Project_Id := Project;\n-      Arg                 : String_Access;\n-      Last                : Natural := 0;\n-      Skip_Executable     : Boolean := False;\n-\n-   begin\n-      --  Add the default search directories, to be able to find libgnat in\n-      --  call to MLib.Utl.Lib_Directory.\n-\n-      Add_Default_Search_Dirs;\n-\n-      Library_Paths.Set_Last (0);\n-\n-      --  Check if there are library project files\n-\n-      if MLib.Tgt.Support_For_Libraries /= None then\n-         Set_Libraries (Project, Project_Tree, Libraries_Present);\n-      end if;\n-\n-      --  If there are, add the necessary additional switches\n-\n-      if Libraries_Present then\n-\n-         --  Add -Wl,-rpath,<lib_dir>\n-\n-         --  If Path_Option is not null, create the switch (\"-Wl,-rpath,\" or\n-         --  equivalent) with all the library dirs plus the standard GNAT\n-         --  library dir.\n-\n-         if Path_Option /= null then\n-            declare\n-               Option  : String_Access;\n-               Length  : Natural := Path_Option'Length;\n-               Current : Natural;\n-\n-            begin\n-               if MLib.Separate_Run_Path_Options then\n-\n-                  --  We are going to create one switch of the form\n-                  --  \"-Wl,-rpath,dir_N\" for each directory to consider.\n-\n-                  --  One switch for each library directory\n-\n-                  for Index in\n-                    Library_Paths.First .. Library_Paths.Last\n-                  loop\n-                     Last_Switches.Increment_Last;\n-                     Last_Switches.Table\n-                       (Last_Switches.Last) := new String'\n-                       (Path_Option.all &\n-                        Last_Switches.Table (Index).all);\n-                  end loop;\n-\n-                  --  One switch for the standard GNAT library dir\n-\n-                  Last_Switches.Increment_Last;\n-                  Last_Switches.Table\n-                    (Last_Switches.Last) := new String'\n-                    (Path_Option.all & MLib.Utl.Lib_Directory);\n-\n-               else\n-                  --  First, compute the exact length for the switch\n-\n-                  for Index in Library_Paths.First .. Library_Paths.Last loop\n-\n-                     --  Add the length of the library dir plus one for the\n-                     --  directory separator.\n-\n-                     Length :=\n-                       Length +\n-                         Library_Paths.Table (Index)'Length + 1;\n-                  end loop;\n-\n-                  --  Finally, add the length of the standard GNAT library dir\n-\n-                  Length := Length + MLib.Utl.Lib_Directory'Length;\n-                  Option := new String (1 .. Length);\n-                  Option (1 .. Path_Option'Length) := Path_Option.all;\n-                  Current := Path_Option'Length;\n-\n-                  --  Put each library dir followed by a dir separator\n-\n-                  for Index in\n-                    Library_Paths.First .. Library_Paths.Last\n-                  loop\n-                     Option\n-                       (Current + 1 ..\n-                        Current + Library_Paths.Table (Index)'Length) :=\n-                       Library_Paths.Table (Index).all;\n-                     Current :=\n-                       Current + Library_Paths.Table (Index)'Length + 1;\n-                     Option (Current) := Path_Separator;\n-                  end loop;\n-\n-                  --  Finally put the standard GNAT library dir\n-\n-                  Option\n-                    (Current + 1 .. Current + MLib.Utl.Lib_Directory'Length) :=\n-                      MLib.Utl.Lib_Directory;\n-\n-                  --  And add the switch to the last switches\n-\n-                  Last_Switches.Increment_Last;\n-                  Last_Switches.Table (Last_Switches.Last) := Option;\n-               end if;\n-            end;\n-         end if;\n-      end if;\n-\n-      --  Check if the first ALI file specified can be found, either in the\n-      --  object directory of the main project or in an object directory of a\n-      --  project file extended by the main project. If the ALI file can be\n-      --  found, replace its name with its absolute path.\n-\n-      Skip_Executable := False;\n-\n-      Switch_Loop : for J in 1 .. Last_Switches.Last loop\n-\n-         --  If we have an executable just reset the flag\n-\n-         if Skip_Executable then\n-            Skip_Executable := False;\n-\n-         --  If -o, set flag so that next switch is not processed\n-\n-         elsif Last_Switches.Table (J).all = \"-o\" then\n-            Skip_Executable := True;\n-\n-         --  Normal case\n-\n-         else\n-            declare\n-               Switch    : constant String := Last_Switches.Table (J).all;\n-               ALI_File  : constant String (1 .. Switch'Length + 4) :=\n-                             Switch & \".ali\";\n-\n-               Test_Existence : Boolean := False;\n-\n-            begin\n-               Last := Switch'Length;\n-\n-               --  Skip real switches\n-\n-               if Switch'Length /= 0\n-                 and then Switch (Switch'First) /= '-'\n-               then\n-                  --  Append \".ali\" if file name does not end with it\n-\n-                  if Switch'Length <= 4\n-                    or else Switch (Switch'Last - 3 .. Switch'Last) /= \".ali\"\n-                  then\n-                     Last := ALI_File'Last;\n-                  end if;\n-\n-                  --  If file name includes directory information, stop if ALI\n-                  --  file exists.\n-\n-                  if Is_Absolute_Path (ALI_File (1 .. Last)) then\n-                     Test_Existence := True;\n-\n-                  else\n-                     for K in Switch'Range loop\n-                        if Is_Directory_Separator (Switch (K)) then\n-                           Test_Existence := True;\n-                           exit;\n-                        end if;\n-                     end loop;\n-                  end if;\n-\n-                  if Test_Existence then\n-                     if Is_Regular_File (ALI_File (1 .. Last)) then\n-                        exit Switch_Loop;\n-                     end if;\n-\n-                  --  Look in object directories if ALI file exists\n-\n-                  else\n-                     Project_Loop : loop\n-                        declare\n-                           Dir : constant String :=\n-                                   Get_Name_String (Prj.Object_Directory.Name);\n-                        begin\n-                           if Is_Regular_File (Dir & ALI_File (1 .. Last)) then\n-\n-                              --  We have found the correct project, so we\n-                              --  replace the file with the absolute path.\n-\n-                              Last_Switches.Table (J) :=\n-                                new String'(Dir & ALI_File (1 .. Last));\n-\n-                              --  And we are done\n-\n-                              exit Switch_Loop;\n-                           end if;\n-                        end;\n-\n-                        --  Go to the project being extended, if any\n-\n-                        Prj := Prj.Extends;\n-                        exit Project_Loop when Prj = No_Project;\n-                     end loop Project_Loop;\n-                  end if;\n-               end if;\n-            end;\n-         end if;\n-      end loop Switch_Loop;\n-\n-      --  If a relative path output file has been specified, we add the exec\n-      --  directory.\n-\n-      for J in reverse 1 .. Last_Switches.Last - 1 loop\n-         if Last_Switches.Table (J).all = \"-o\" then\n-            Check_Relative_Executable (Name => Last_Switches.Table (J + 1));\n-            Look_For_Executable := False;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      if Look_For_Executable then\n-         for J in reverse 1 .. First_Switches.Last - 1 loop\n-            if First_Switches.Table (J).all = \"-o\" then\n-               Look_For_Executable := False;\n-               Check_Relative_Executable\n-                 (Name => First_Switches.Table (J + 1));\n-               exit;\n-            end if;\n-         end loop;\n-      end if;\n-\n-      --  If no executable is specified, then find the name of the first ALI\n-      --  file on the command line and issue a -o switch with the absolute path\n-      --  of the executable in the exec directory.\n-\n-      if Look_For_Executable then\n-         for J in 1 .. Last_Switches.Last loop\n-            Arg  := Last_Switches.Table (J);\n-            Last := 0;\n-\n-            if Arg'Length /= 0 and then Arg (Arg'First) /= '-' then\n-               if Arg'Length > 4\n-                 and then Arg (Arg'Last - 3 .. Arg'Last) = \".ali\"\n-               then\n-                  Last := Arg'Last - 4;\n-\n-               elsif Is_Regular_File (Arg.all & \".ali\") then\n-                  Last := Arg'Last;\n-               end if;\n-\n-               if Last /= 0 then\n-                  Last_Switches.Increment_Last;\n-                  Last_Switches.Table (Last_Switches.Last) :=\n-                    new String'(\"-o\");\n-                  Get_Name_String (Project.Exec_Directory.Name);\n-                  Last_Switches.Increment_Last;\n-                  Last_Switches.Table (Last_Switches.Last) :=\n-                    new String'(Name_Buffer (1 .. Name_Len) &\n-                                Executable_Name\n-                                  (Base_Name (Arg (Arg'First .. Last))));\n-                  exit;\n-               end if;\n-            end if;\n-         end loop;\n-      end if;\n-   end Process_Link;\n-\n-   ---------------------\n-   -- Set_Library_For --\n-   ---------------------\n-\n-   procedure Set_Library_For\n-     (Project           : Project_Id;\n-      Tree              : Project_Tree_Ref;\n-      Libraries_Present : in out Boolean)\n-   is\n-      pragma Unreferenced (Tree);\n-\n-      Path_Option : constant String_Access := MLib.Linker_Library_Path_Option;\n-\n-   begin\n-      --  Case of library project\n-\n-      if Project.Library then\n-         Libraries_Present := True;\n-\n-         --  Add the -L switch\n-\n-         Last_Switches.Increment_Last;\n-         Last_Switches.Table (Last_Switches.Last) :=\n-           new String'(\"-L\" & Get_Name_String (Project.Library_Dir.Name));\n-\n-         --  Add the -l switch\n-\n-         Last_Switches.Increment_Last;\n-         Last_Switches.Table (Last_Switches.Last) :=\n-           new String'(\"-l\" & Get_Name_String (Project.Library_Name));\n-\n-         --  Add the directory to table Library_Paths, to be processed later\n-         --  if library is not static and if Path_Option is not null.\n-\n-         if Project.Library_Kind /= Static\n-           and then Path_Option /= null\n-         then\n-            Library_Paths.Increment_Last;\n-            Library_Paths.Table (Library_Paths.Last) :=\n-              new String'(Get_Name_String (Project.Library_Dir.Name));\n-         end if;\n-      end if;\n-   end Set_Library_For;\n-\n    procedure Check_Version_And_Help is new Check_Version_And_Help_G (Usage);\n \n --  Start of processing for GNATCmd\n \n begin\n-   --  All output from GNATCmd is debugging or error output: send to stderr\n-\n-   Set_Standard_Error;\n-\n    --  Initializations\n \n-   Csets.Initialize;\n-   Snames.Initialize;\n-   Stringt.Initialize;\n-\n-   Prj.Tree.Initialize (Root_Environment, Gnatmake_Flags);\n-\n-   Project_Node_Tree := new Project_Node_Tree_Data;\n-   Prj.Tree.Initialize (Project_Node_Tree);\n-\n-   Prj.Initialize (Project_Tree);\n-\n    Last_Switches.Init;\n    Last_Switches.Set_Last (0);\n \n    First_Switches.Init;\n    First_Switches.Set_Last (0);\n-   Carg_Switches.Init;\n-   Carg_Switches.Set_Last (0);\n-   Rules_Switches.Init;\n-   Rules_Switches.Set_Last (0);\n \n    --  Set AAMP_On_Target from command name, for testing in Osint.Program_Name\n    --  to handle the mapping of GNAAMP tool names. We don't extract it from\n@@ -1171,6 +462,7 @@ begin\n \n    begin\n       if The_Command = Stack then\n+\n          --  Never call gnatstack with a prefix\n \n          Program := new String'(Command_List (The_Command).Unixcmd.all);\n@@ -1182,12 +474,15 @@ begin\n          --  If we want to invoke gnatmake/gnatclean with -P, then check if\n          --  gprbuild/gprclean is available; if it is, use gprbuild/gprclean\n          --  instead of gnatmake/gnatclean.\n-         --  Ditto for gnatname -> gprname.\n+         --  Ditto for gnatname -> gprname and gnatls -> gprls.\n \n          if The_Command = Make\n-            or else The_Command = Compile\n-            or else The_Command = Clean\n-            or else The_Command = Name\n+           or else The_Command = Compile\n+           or else The_Command = Bind\n+           or else The_Command = Link\n+           or else The_Command = Clean\n+           or else The_Command = Name\n+           or else The_Command = List\n          then\n             declare\n                Project_File_Used : Boolean := False;\n@@ -1196,8 +491,8 @@ begin\n             begin\n                for J in 1 .. Last_Switches.Last loop\n                   Switch := Last_Switches.Table (J);\n-                  if Switch'Length >= 2 and then\n-                    Switch (Switch'First .. Switch'First + 1) = \"-P\"\n+                  if Switch'Length >= 2\n+                    and then Switch (Switch'First .. Switch'First + 1) = \"-P\"\n                   then\n                      Project_File_Used := True;\n                      exit;\n@@ -1206,10 +501,26 @@ begin\n \n                if Project_File_Used then\n                   case The_Command is\n-                     when Make | Compile =>\n+                     when Make | Compile | Bind | Link =>\n                         if Locate_Exec_On_Path (Gprbuild) /= null  then\n-                           Program := new String'(Gprbuild);\n+                           Program    := new String'(Gprbuild);\n                            Get_Target := True;\n+\n+                           if The_Command = Bind then\n+                              First_Switches.Append (new String'(\"-b\"));\n+                           elsif The_Command = Link then\n+                              First_Switches.Append (new String'(\"-l\"));\n+                           end if;\n+\n+                        elsif The_Command = Bind then\n+                           Fail\n+                             (\"'gnat bind -P' is no longer supported;\" &\n+                              \" use 'gprbuild -b' instead.\");\n+\n+                        elsif The_Command = Link then\n+                           Fail\n+                             (\"'gnat Link -P' is no longer supported;\" &\n+                              \" use 'gprbuild -l' instead.\");\n                         end if;\n \n                      when Clean =>\n@@ -1224,6 +535,12 @@ begin\n                            Get_Target := True;\n                         end if;\n \n+                     when List =>\n+                        if Locate_Exec_On_Path (Gprls) /= null then\n+                           Program := new String'(Gprls);\n+                           Get_Target := True;\n+                        end if;\n+\n                      when others =>\n                         null;\n                   end case;\n@@ -1242,15 +559,6 @@ begin\n          end if;\n       end if;\n \n-      --  For the tools where the GNAT driver processes the project files,\n-      --  allow shared library projects to import projects that are not shared\n-      --  library projects, to avoid adding a switch for these tools. For the\n-      --  builder (gnatmake), if a shared library project imports a project\n-      --  that is not a shared library project and the appropriate switch is\n-      --  not specified, the invocation of gnatmake will fail.\n-\n-      Opt.Unchecked_Shared_Lib_Imports := True;\n-\n       --  Locate the executable for the command\n \n       Exec_Path := Locate_Exec_On_Path (Program.all);\n@@ -1270,465 +578,35 @@ begin\n          end loop;\n       end if;\n \n-      --  For BIND, FIND, LINK, LIST and XREF, look for project file related\n-      --  switches.\n-\n-      case The_Command is\n-         when Bind =>\n-            Tool_Package_Name := Name_Binder;\n-            Packages_To_Check := Packages_To_Check_By_Binder;\n-         when Find =>\n-            Tool_Package_Name := Name_Finder;\n-            Packages_To_Check := Packages_To_Check_By_Finder;\n-         when Link =>\n-            Tool_Package_Name := Name_Linker;\n-            Packages_To_Check := Packages_To_Check_By_Linker;\n-         when List =>\n-            Tool_Package_Name := Name_Gnatls;\n-            Packages_To_Check := Packages_To_Check_By_Gnatls;\n-         when Xref =>\n-            Tool_Package_Name := Name_Cross_Reference;\n-            Packages_To_Check := Packages_To_Check_By_Xref;\n-         when others =>\n-            Tool_Package_Name := No_Name;\n-      end case;\n-\n-      if Tool_Package_Name /= No_Name then\n-\n-         --  Check that the switches are consistent. Detect project file\n-         --  related switches.\n-\n-         Inspect_Switches : declare\n-            Arg_Num : Positive := 1;\n-            Argv    : String_Access;\n-\n-            procedure Remove_Switch (Num : Positive);\n-            --  Remove a project related switch from table Last_Switches\n-\n-            -------------------\n-            -- Remove_Switch --\n-            -------------------\n-\n-            procedure Remove_Switch (Num : Positive) is\n-            begin\n-               Last_Switches.Table (Num .. Last_Switches.Last - 1) :=\n-                 Last_Switches.Table (Num + 1 .. Last_Switches.Last);\n-               Last_Switches.Decrement_Last;\n-            end Remove_Switch;\n-\n-         --  Start of processing for Inspect_Switches\n+      --  For FIND and XREF, look for switch -P. If it is specified, then\n+      --  report an error indicating that the command is no longer supporting\n+      --  project files.\n \n+      if The_Command = Find or else  The_Command = Xref then\n+         declare\n+            Argv    : String_Access;\n          begin\n-            while Arg_Num <= Last_Switches.Last loop\n+            for Arg_Num in 1 .. Last_Switches.Last loop\n                Argv := Last_Switches.Table (Arg_Num);\n \n-               if Argv (Argv'First) = '-' then\n-                  if Argv'Length = 1 then\n-                     Fail (\"switch character cannot be followed by a blank\");\n-                  end if;\n-\n-                  --  The two style project files (-p and -P) cannot be used\n-                  --  together\n-\n-                  if (The_Command = Find or else The_Command = Xref)\n-                    and then Argv (2) = 'p'\n-                  then\n-                     Old_Project_File_Used := True;\n-                     if Project_File /= null then\n-                        Fail (\"-P and -p cannot be used together\");\n-                     end if;\n-                  end if;\n-\n-                  --  --subdirs=... Specify Subdirs\n-\n-                  if Argv'Length > Makeutl.Subdirs_Option'Length\n-                    and then\n-                      Argv\n-                       (Argv'First ..\n-                        Argv'First + Makeutl.Subdirs_Option'Length - 1) =\n-                                                        Makeutl.Subdirs_Option\n-                  then\n-                     Subdirs :=\n-                       new String'\n-                         (Argv (Argv'First + Makeutl.Subdirs_Option'Length ..\n-                                Argv'Last));\n-\n-                     Remove_Switch (Arg_Num);\n-\n-                  --  -aPdir  Add dir to the project search path\n-\n-                  elsif Argv'Length > 3\n-                    and then Argv (Argv'First + 1 .. Argv'First + 2) = \"aP\"\n-                  then\n-                     Prj.Env.Add_Directories\n-                       (Root_Environment.Project_Path,\n-                        Argv (Argv'First + 3 .. Argv'Last));\n-\n-                     --  Pass -aPdir to gnatls, but not to other tools\n-\n-                     if The_Command = List then\n-                        Arg_Num := Arg_Num + 1;\n-                     else\n-                        Remove_Switch (Arg_Num);\n-                     end if;\n-\n-                  --  -eL  Follow links for files\n-\n-                  elsif Argv.all = \"-eL\" then\n-                     Follow_Links_For_Files := True;\n-                     Follow_Links_For_Dirs  := True;\n-\n-                     Remove_Switch (Arg_Num);\n-\n-                  --  -vPx  Specify verbosity while parsing project files\n-\n-                  elsif Argv'Length >= 3\n-                    and then  Argv (Argv'First + 1 .. Argv'First + 2) = \"vP\"\n-                  then\n-                     if Argv'Length = 4\n-                       and then Argv (Argv'Last) in '0' .. '2'\n-                     then\n-                        case Argv (Argv'Last) is\n-                           when '0' =>\n-                              Current_Verbosity := Prj.Default;\n-                           when '1' =>\n-                              Current_Verbosity := Prj.Medium;\n-                           when '2' =>\n-                              Current_Verbosity := Prj.High;\n-                           when others =>\n-\n-                              --  Cannot happen\n-\n-                              raise Program_Error;\n-                        end case;\n-                     else\n-                        Fail (\"invalid verbosity level: \"\n-                              & Argv (Argv'First + 3 .. Argv'Last));\n-                     end if;\n-\n-                     Remove_Switch (Arg_Num);\n-\n-                  --  -Pproject_file  Specify project file to be used\n-\n-                  elsif Argv (Argv'First + 1) = 'P' then\n-\n-                     --  Only one -P switch can be used\n-\n-                     if Project_File /= null then\n-                        Fail\n-                          (Argv.all\n-                           & \": second project file forbidden (first is \"\"\"\n-                           & Project_File.all & \"\"\")\");\n-\n-                     --  The two style project files (-p and -P) cannot be\n-                     --  used together.\n-\n-                     elsif Old_Project_File_Used then\n-                        Fail (\"-p and -P cannot be used together\");\n-\n-                     elsif Argv'Length = 2 then\n-\n-                        --  There is space between -P and the project file\n-                        --  name. -P cannot be the last option.\n-\n-                        if Arg_Num = Last_Switches.Last then\n-                           Fail (\"project file name missing after -P\");\n-\n-                        else\n-                           Remove_Switch (Arg_Num);\n-                           Argv := Last_Switches.Table (Arg_Num);\n-\n-                           --  After -P, there must be a project file name,\n-                           --  not another switch.\n-\n-                           if Argv (Argv'First) = '-' then\n-                              Fail (\"project file name missing after -P\");\n-\n-                           else\n-                              Project_File := new String'(Argv.all);\n-                           end if;\n-                        end if;\n-\n-                     else\n-                        --  No space between -P and project file name\n-\n-                        Project_File :=\n-                          new String'(Argv (Argv'First + 2 .. Argv'Last));\n-                     end if;\n-\n-                     Remove_Switch (Arg_Num);\n-\n-                  --  -Xexternal=value Specify an external reference to be\n-                  --                   used in project files\n-\n-                  elsif Argv'Length >= 5\n-                    and then Argv (Argv'First + 1) = 'X'\n-                  then\n-                     if not Check (Root_Environment.External,\n-                                    Argv (Argv'First + 2 .. Argv'Last))\n-                     then\n-                        Fail\n-                          (Argv.all & \" is not a valid external assignment.\");\n-                     end if;\n-\n-                     Remove_Switch (Arg_Num);\n-\n-                  elsif\n-                    The_Command = List\n-                    and then Argv'Length = 2\n-                    and then Argv (2) = 'U'\n-                  then\n-                     All_Projects := True;\n-                     Remove_Switch (Arg_Num);\n-\n+               if Argv'Length >= 2 and then\n+                  Argv (Argv'First .. Argv'First + 1) = \"-P\"\n+               then\n+                  if The_Command = Find then\n+                     Fail (\"'gnat find -P' is no longer supported;\");\n                   else\n-                     Arg_Num := Arg_Num + 1;\n+                     Fail (\"'gnat xref -P' is no longer supported;\");\n                   end if;\n-\n-               else\n-                  Arg_Num := Arg_Num + 1;\n                end if;\n             end loop;\n-         end Inspect_Switches;\n-      end if;\n-\n-      --  Add the default project search directories now, after the directories\n-      --  that have been specified by switches -aP<dir>.\n-\n-      Prj.Env.Initialize_Default_Project_Path\n-        (Root_Environment.Project_Path,\n-         Target_Name => Sdefault.Target_Name.all);\n-\n-      --  If there is a project file specified, parse it, get the switches\n-      --  for the tool and setup PATH environment variables.\n-\n-      if Project_File /= null then\n-         Prj.Pars.Set_Verbosity (To => Current_Verbosity);\n-\n-         Prj.Pars.Parse\n-           (Project           => Project,\n-            In_Tree           => Project_Tree,\n-            In_Node_Tree      => Project_Node_Tree,\n-            Project_File_Name => Project_File.all,\n-            Env               => Root_Environment,\n-            Packages_To_Check => Packages_To_Check);\n-\n-         --  Prj.Pars.Parse calls Set_Standard_Output, reset to stderr\n-\n-         Set_Standard_Error;\n-\n-         if Project = Prj.No_Project then\n-            Fail (\"\"\"\" & Project_File.all & \"\"\" processing failed\");\n-\n-         elsif Project.Qualifier = Aggregate then\n-            Fail (\"aggregate projects are not supported\");\n-\n-         elsif Aggregate_Libraries_In (Project_Tree) then\n-            Fail (\"aggregate library projects are not supported\");\n-         end if;\n-\n-         --  Check if a package with the name of the tool is in the project\n-         --  file and if there is one, get the switches, if any, and scan them.\n-\n-         declare\n-            Pkg : constant Prj.Package_Id :=\n-                    Prj.Util.Value_Of\n-                      (Name        => Tool_Package_Name,\n-                       In_Packages => Project.Decl.Packages,\n-                       Shared      => Project_Tree.Shared);\n-\n-            Element : Package_Element;\n-\n-            Switches_Array : Array_Element_Id;\n-\n-            The_Switches : Prj.Variable_Value;\n-            Current      : Prj.String_List_Id;\n-            The_String   : String_Element;\n-\n-            Main : String_Access := null;\n-\n-         begin\n-            if Pkg /= No_Package then\n-               Element := Project_Tree.Shared.Packages.Table (Pkg);\n-\n-               --  Package Gnatls has a single attribute Switches, that is not\n-               --  an associative array.\n-\n-               if The_Command = List then\n-                  The_Switches :=\n-                    Prj.Util.Value_Of\n-                    (Variable_Name => Snames.Name_Switches,\n-                     In_Variables  => Element.Decl.Attributes,\n-                     Shared        => Project_Tree.Shared);\n-\n-               --  Packages Binder (for gnatbind), Cross_Reference (for\n-               --  gnatxref), Linker (for gnatlink), Finder (for gnatfind),\n-               --  have an attributed Switches, an associative array, indexed\n-               --  by the name of the file.\n-\n-               --  They also have an attribute Default_Switches, indexed by the\n-               --  name of the programming language.\n-\n-               else\n-                  --  First check if there is a single main\n-\n-                  for J in 1 .. Last_Switches.Last loop\n-                     if Last_Switches.Table (J) (1) /= '-' then\n-                        if Main = null then\n-                           Main := Last_Switches.Table (J);\n-                        else\n-                           Main := null;\n-                           exit;\n-                        end if;\n-                     end if;\n-                  end loop;\n-\n-                  if Main /= null then\n-                     Switches_Array :=\n-                       Prj.Util.Value_Of\n-                         (Name      => Name_Switches,\n-                          In_Arrays => Element.Decl.Arrays,\n-                          Shared    => Project_Tree.Shared);\n-                     Name_Len := 0;\n-\n-                     --  If the single main has been specified as an absolute\n-                     --  path, use only the simple file name. If the absolute\n-                     --  path is incorrect, an error will be reported by the\n-                     --  underlying tool and it does not make a difference\n-                     --  what switches are used.\n-\n-                     if Is_Absolute_Path (Main.all) then\n-                        Add_Str_To_Name_Buffer (File_Name (Main.all));\n-                     else\n-                        Add_Str_To_Name_Buffer (Main.all);\n-                     end if;\n-\n-                     The_Switches := Prj.Util.Value_Of\n-                       (Index     => Name_Find,\n-                        Src_Index => 0,\n-                        In_Array  => Switches_Array,\n-                        Shared    => Project_Tree.Shared);\n-                  end if;\n-\n-                  if The_Switches.Kind = Prj.Undefined then\n-                     Switches_Array :=\n-                       Prj.Util.Value_Of\n-                         (Name      => Name_Default_Switches,\n-                          In_Arrays => Element.Decl.Arrays,\n-                          Shared    => Project_Tree.Shared);\n-                     The_Switches := Prj.Util.Value_Of\n-                       (Index     => Name_Ada,\n-                        Src_Index => 0,\n-                        In_Array  => Switches_Array,\n-                        Shared    => Project_Tree.Shared);\n-                  end if;\n-               end if;\n-\n-               --  If there are switches specified in the package of the\n-               --  project file corresponding to the tool, scan them.\n-\n-               case The_Switches.Kind is\n-                  when Prj.Undefined =>\n-                     null;\n-\n-                  when Prj.Single =>\n-                     declare\n-                        Switch : constant String :=\n-                                   Get_Name_String (The_Switches.Value);\n-                     begin\n-                        if Switch'Length > 0 then\n-                           First_Switches.Increment_Last;\n-                           First_Switches.Table (First_Switches.Last) :=\n-                             new String'(Switch);\n-                        end if;\n-                     end;\n-\n-                  when Prj.List =>\n-                     Current := The_Switches.Values;\n-                     while Current /= Prj.Nil_String loop\n-                        The_String := Project_Tree.Shared.String_Elements.\n-                                        Table (Current);\n-\n-                        declare\n-                           Switch : constant String :=\n-                                      Get_Name_String (The_String.Value);\n-                        begin\n-                           if Switch'Length > 0 then\n-                              First_Switches.Increment_Last;\n-                              First_Switches.Table (First_Switches.Last) :=\n-                                new String'(Switch);\n-                           end if;\n-                        end;\n-\n-                        Current := The_String.Next;\n-                     end loop;\n-               end case;\n-            end if;\n          end;\n-\n-         if The_Command = Bind or else The_Command = Link then\n-            if Project.Object_Directory.Name = No_Path then\n-               Fail (\"project \" & Get_Name_String (Project.Display_Name)\n-                     & \" has no object directory\");\n-            end if;\n-\n-            Change_Dir (Get_Name_String (Project.Object_Directory.Name));\n-         end if;\n-\n-         --  Set up the env vars for project path files\n-\n-         Prj.Env.Set_Ada_Paths\n-           (Project, Project_Tree, Including_Libraries => True);\n-\n-         --  For gnatcheck, gnatstub, gnatmetric, gnatpp and gnatelim, create\n-         --  a configuration pragmas file, if necessary.\n-\n-         if The_Command = Link then\n-            Process_Link;\n-         end if;\n-\n-         if The_Command = Link or else The_Command = Bind then\n-\n-            --  For files that are specified as relative paths with directory\n-            --  information, we convert them to absolute paths, with parent\n-            --  being the current working directory if specified on the command\n-            --  line and the project directory if specified in the project\n-            --  file. This is what gnatmake is doing for linker and binder\n-            --  arguments.\n-\n-            for J in 1 .. Last_Switches.Last loop\n-               GNATCmd.Ensure_Absolute_Path\n-                 (Last_Switches.Table (J), Current_Work_Dir);\n-            end loop;\n-\n-            Get_Name_String (Project.Directory.Name);\n-\n-            declare\n-               Project_Dir : constant String := Name_Buffer (1 .. Name_Len);\n-            begin\n-               for J in 1 .. First_Switches.Last loop\n-                  GNATCmd.Ensure_Absolute_Path\n-                    (First_Switches.Table (J), Project_Dir);\n-               end loop;\n-            end;\n-         end if;\n-\n-         --  For gnat list, if no file has been put on the command line, call\n-         --  tool with all the sources of the main project.\n-\n-         if The_Command = List then\n-            Check_Files;\n-         end if;\n       end if;\n \n       --  Gather all the arguments and invoke the executable\n \n       declare\n          The_Args : Argument_List\n-                      (1 .. First_Switches.Last +\n-                            Last_Switches.Last +\n-                            Carg_Switches.Last +\n-                            Rules_Switches.Last);\n+                      (1 .. First_Switches.Last + Last_Switches.Last);\n          Arg_Num  : Natural := 0;\n \n       begin\n@@ -1742,47 +620,22 @@ begin\n             The_Args (Arg_Num) := Last_Switches.Table (J);\n          end loop;\n \n-         for J in 1 .. Carg_Switches.Last loop\n-            Arg_Num := Arg_Num + 1;\n-            The_Args (Arg_Num) := Carg_Switches.Table (J);\n-         end loop;\n-\n-         for J in 1 .. Rules_Switches.Last loop\n-            Arg_Num := Arg_Num + 1;\n-            The_Args (Arg_Num) := Rules_Switches.Table (J);\n-         end loop;\n-\n          if Verbose_Mode then\n-            Output.Write_Str (Exec_Path.all);\n+            Put (Exec_Path.all);\n \n             for Arg in The_Args'Range loop\n-               Output.Write_Char (' ');\n-               Output.Write_Str (The_Args (Arg).all);\n+               Put (\" \" & The_Args (Arg).all);\n             end loop;\n \n-            Output.Write_Eol;\n+            New_Line;\n          end if;\n \n-         My_Exit_Status :=\n-           Exit_Status (Spawn (Exec_Path.all, The_Args));\n-         raise Normal_Exit;\n+         My_Exit_Status := Exit_Status (Spawn (Exec_Path.all, The_Args));\n+         Set_Exit_Status (My_Exit_Status);\n       end;\n    end;\n \n exception\n    when Error_Exit =>\n-      if not Keep_Temporary_Files then\n-         Prj.Delete_All_Temp_Files (Project_Tree.Shared);\n-         Delete_Temp_Config_Files;\n-      end if;\n-\n       Set_Exit_Status (Failure);\n-\n-   when Normal_Exit =>\n-      if not Keep_Temporary_Files then\n-         Prj.Delete_All_Temp_Files (Project_Tree.Shared);\n-         Delete_Temp_Config_Files;\n-      end if;\n-\n-      Set_Exit_Status (My_Exit_Status);\n end GNATCmd;"}, {"sha": "b65892ae3b64fcb24f75f0721a9669ceaeacdd34", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "patch": "@@ -747,16 +747,16 @@ package body Lib.Writ is\n       ----------------------\n \n       procedure Write_With_Lines is\n-         With_Table : Unit_Ref_Table (1 .. Pos (Last_Unit - Units.First + 1));\n-         Num_Withs  : Int := 0;\n-         Unum       : Unit_Number_Type;\n-         Cunit      : Node_Id;\n-         Uname      : Unit_Name_Type;\n-         Fname      : File_Name_Type;\n          Pname      : constant Unit_Name_Type :=\n                         Get_Parent_Spec_Name (Unit_Name (Main_Unit));\n          Body_Fname : File_Name_Type;\n          Body_Index : Nat;\n+         Cunit      : Node_Id;\n+         Fname      : File_Name_Type;\n+         Num_Withs  : Int := 0;\n+         Unum       : Unit_Number_Type;\n+         Uname      : Unit_Name_Type;\n+         With_Table : Unit_Ref_Table (1 .. Pos (Last_Unit - Units.First + 1));\n \n          procedure Write_With_File_Names\n            (Nam : in out File_Name_Type;\n@@ -814,10 +814,18 @@ package body Lib.Writ is\n          Sort (With_Table (1 .. Num_Withs));\n \n          for J in 1 .. Num_Withs loop\n-            Unum   := With_Table (J);\n-            Cunit  := Units.Table (Unum).Cunit;\n-            Uname  := Units.Table (Unum).Unit_Name;\n-            Fname  := Units.Table (Unum).Unit_File_Name;\n+            Unum := With_Table (J);\n+\n+            --  Do not generate a with line for an ignored Ghost unit because\n+            --  the unit does not have an ALI file.\n+\n+            if Is_Ignored_Ghost_Entity (Cunit_Entity (Unum)) then\n+               goto Next_With_Line;\n+            end if;\n+\n+            Cunit := Units.Table (Unum).Cunit;\n+            Uname := Units.Table (Unum).Unit_Name;\n+            Fname := Units.Table (Unum).Unit_File_Name;\n \n             if Implicit_With (Unum) = Yes then\n                Write_Info_Initiate ('Z');\n@@ -914,6 +922,9 @@ package body Lib.Writ is\n             end if;\n \n             Write_Info_EOL;\n+\n+         <<Next_With_Line>>\n+            null;\n          end loop;\n \n          --  Finally generate the special lines for cases of Restriction_Set\n@@ -932,7 +943,7 @@ package body Lib.Writ is\n \n                for U in 0 .. Last_Unit loop\n                   if Unit_Name (U) = Unam then\n-                     goto Continue;\n+                     goto Next_Restriction_Set;\n                   end if;\n                end loop;\n \n@@ -943,7 +954,7 @@ package body Lib.Writ is\n                Write_Info_Name (Unam);\n                Write_Info_EOL;\n \n-            <<Continue>>\n+            <<Next_Restriction_Set>>\n                null;\n             end loop;\n          end;\n@@ -996,8 +1007,8 @@ package body Lib.Writ is\n          end if;\n       end if;\n \n-      --  Otherwise acquire compilation arguments and prepare to write\n-      --  out a new ali file.\n+      --  Otherwise acquire compilation arguments and prepare to write out a\n+      --  new ali file.\n \n       Create_Output_Library_Info;\n "}, {"sha": "1356497abea6b0bc2c1cc4f5e3a9dd030445abf4", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "patch": "@@ -748,7 +748,25 @@ package body Sem_Attr is\n                if Nkind_In (Par, N_Aggregate, N_Extension_Aggregate) then\n                   if Etype (Par) = Typ then\n                      Set_Has_Self_Reference (Par);\n-                     return True;\n+\n+                     --  Check the context: the aggregate must be part of the\n+                     --  initialization of a type or component, or it is the\n+                     --  resulting expansion in an initialization procedure.\n+\n+                     if Is_Init_Proc (Current_Scope) then\n+                        return True;\n+                     else\n+                        Par := Parent (Par);\n+                        while Present (Par) loop\n+                           if Nkind (Par) = N_Full_Type_Declaration then\n+                              return True;\n+                           end if;\n+\n+                           Par := Parent (Par);\n+                        end loop;\n+                     end if;\n+\n+                     return False;\n                   end if;\n                end if;\n "}, {"sha": "e24de93e59f61800583f56c4eea4678feab7c99e", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "patch": "@@ -937,7 +937,8 @@ package body Sem_Ch7 is\n    ---------------------------------\n \n    procedure Analyze_Package_Declaration (N : Node_Id) is\n-      Id : constant Node_Id := Defining_Entity (N);\n+      Id  : constant Node_Id := Defining_Entity (N);\n+      Par : constant Node_Id := Parent_Spec (N);\n \n       Body_Required : Boolean;\n       --  True when this package declaration requires a corresponding body\n@@ -972,10 +973,13 @@ package body Sem_Ch7 is\n          Set_SPARK_Aux_Pragma_Inherited (Id);\n       end if;\n \n-      --  A package declared within a Ghost refion is automatically Ghost\n-      --  (SPARK RM 6.9(2)).\n+      --  A package declared within a Ghost refion is automatically Ghost. A\n+      --  child package is Ghost when its parent is Ghost (SPARK RM 6.9(2)).\n \n-      if Ghost_Mode > None then\n+      if Ghost_Mode > None\n+        or else (Present (Par)\n+                  and then Is_Ghost_Entity (Defining_Entity (Unit (Par))))\n+      then\n          Set_Is_Ghost_Entity (Id);\n       end if;\n "}, {"sha": "b2a092cbe88426b400e9d38fd0d0120c9bd64841", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "patch": "@@ -958,10 +958,10 @@ package body Sem_Elab is\n             Ent := Alias (Ent);\n             E_Scope := Ent;\n \n-            --  If no alias, there is a previous error\n+            --  If no alias, there could be a previous error, but not if we've\n+            --  already reached the outermost level (Standard).\n \n             if No (Ent) then\n-               Check_Error_Detected;\n                return;\n             end if;\n          end loop;"}, {"sha": "644cfaa4fd25f8d526d52e1d26f2e51735ae8dc3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b35e5dcb14b85adb622f0f6ee4c629e9a44dcdd0", "patch": "@@ -15063,6 +15063,12 @@ package body Sem_Prag is\n                  and then No (Corresponding_Spec (Context))\n                then\n                   Id := Defining_Entity (Context);\n+\n+               --  Pragma Ghost applies to a subprogram declaration that acts\n+               --  as a compilation unit.\n+\n+               elsif Nkind (Context) = N_Subprogram_Declaration then\n+                  Id := Defining_Entity (Context);\n                end if;\n             end if;\n "}]}