{"sha": "241cea859c70e32d3de9ee887b29be2d5c675956", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQxY2VhODU5YzcwZTMyZDNkZTllZTg4N2IyOWJlMmQ1YzY3NTk1Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-28T22:32:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-28T22:32:45Z"}, "message": "(previous_num_undos): Deleted variable.\n\n(MAX_UNDO): Deleted macro.\n(struct undo): New field, next.\n(struct undobuf): Deleted num_undos and undo.\nNew fields undos, frees, and previous_undos.\n(SUBST, SUBST_INT): Rework to allocate memory and chain undo entries.\n(combine_instructions): Initialize undobuf.{undos,previous_undos},\nnot undobuf.num_undo and previous_num_undos.\n(try_combine): Likewise.\n(undo_all, gen_rtx_combine): Rework to use new data structures.\n\nFrom-SVN: r12372", "tree": {"sha": "f25879d15fdaabe63603fd7e668a4d7572ca7482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f25879d15fdaabe63603fd7e668a4d7572ca7482"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/241cea859c70e32d3de9ee887b29be2d5c675956", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241cea859c70e32d3de9ee887b29be2d5c675956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/241cea859c70e32d3de9ee887b29be2d5c675956", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241cea859c70e32d3de9ee887b29be2d5c675956/comments", "author": null, "committer": null, "parents": [{"sha": "ad24823466a52926eb20b83b07fd60d39fd139c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad24823466a52926eb20b83b07fd60d39fd139c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad24823466a52926eb20b83b07fd60d39fd139c6"}], "stats": {"total": 119, "additions": 66, "deletions": 53}, "files": [{"sha": "2cfda48afb365ee81a08dbae60148cea20bbb225", "filename": "gcc/combine.c", "status": "modified", "additions": 66, "deletions": 53, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241cea859c70e32d3de9ee887b29be2d5c675956/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241cea859c70e32d3de9ee887b29be2d5c675956/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=241cea859c70e32d3de9ee887b29be2d5c675956", "patch": "@@ -198,13 +198,6 @@ static HARD_REG_SET newpat_used_regs;\n \n static rtx added_links_insn;\n \n-/* This is the value of undobuf.num_undo when we started processing this \n-   substitution.  This will prevent gen_rtx_combine from re-used a piece\n-   from the previous expression.  Doing so can produce circular rtl\n-   structures.  */\n-\n-static int previous_num_undos;\n-\n /* Basic block number of the block in which we are performing combines.  */\n static int this_basic_block;\n \f\n@@ -319,6 +312,7 @@ static char *reg_last_set_sign_bit_copies;\n \n struct undo\n {\n+  struct undo *next;\n   int is_int;\n   union {rtx r; int i;} old_contents;\n   union {rtx *r; int *i;} where;\n@@ -331,15 +325,19 @@ struct undo\n    The value of storage is what to pass to obfree.\n \n    other_insn is nonzero if we have modified some other insn in the process\n-   of working on subst_insn.  It must be verified too.  */\n+   of working on subst_insn.  It must be verified too.\n \n-#define MAX_UNDO 50\n+   previous_undos is the value of undobuf.undos when we started processing\n+   this substitution.  This will prevent gen_rtx_combine from re-used a piece\n+   from the previous expression.  Doing so can produce circular rtl\n+   structures.  */\n \n struct undobuf\n {\n-  int num_undo;\n   char *storage;\n-  struct undo undo[MAX_UNDO];\n+  struct undo *undos;\n+  struct undo *frees;\n+  struct undo *previous_undos;\n   rtx other_insn;\n };\n \n@@ -352,32 +350,44 @@ static struct undobuf undobuf;\n    the undo table.  */\n \n #define SUBST(INTO, NEWVAL)  \\\n- do { rtx _new = (NEWVAL);\t\t\t\t\t\t\\\n-      if (undobuf.num_undo < MAX_UNDO)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  undobuf.undo[undobuf.num_undo].is_int = 0;\t\t\t\\\n-\t  undobuf.undo[undobuf.num_undo].where.r = &INTO;\t\t\\\n-\t  undobuf.undo[undobuf.num_undo].old_contents.r = INTO;\t\\\n-\t  INTO = _new;\t\t\t\t\t\t\t\\\n-\t  if (undobuf.undo[undobuf.num_undo].old_contents.r != INTO)\t\\\n-\t    undobuf.num_undo++; \t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n+ do { rtx _new = (NEWVAL);\t\t\t\t\t\\\n+      struct undo *_buf;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      if (undobuf.frees)\t\t\t\t\t\\\n+\t_buf = undobuf.frees, undobuf.frees = _buf->next;\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t_buf = (struct undo *) xmalloc (sizeof (struct undo));\t\\\n+\t\t\t\t\t\t\t\t\\\n+      _buf->is_int = 0;\t\t\t\t\t\t\\\n+      _buf->where.r = &INTO;\t\t\t\t\t\\\n+      _buf->old_contents.r = INTO;\t\t\t\t\\\n+      INTO = _new;\t\t\t\t\t\t\\\n+      if (_buf->old_contents.r == INTO)\t\t\t\t\\\n+\t_buf->next = undobuf.frees, undobuf.frees = _buf;\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t_buf->next = undobuf.undos, undobuf.undos = _buf;\t\\\n     } while (0)\n \n-/* Similar to SUBST, but NEWVAL is an int.  INTO will normally be an XINT\n-   expression.\n-   Note that substitution for the value of a CONST_INT is not safe.  */\n+/* Similar to SUBST, but NEWVAL is an int expression.  Note that substitution\n+   for the value of a HOST_WIDE_INT value (including CONST_INT) is\n+   not safe.  */\n \n #define SUBST_INT(INTO, NEWVAL)  \\\n- do { if (undobuf.num_undo < MAX_UNDO)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-\t  undobuf.undo[undobuf.num_undo].is_int = 1;\t\t\t\\\n-\t  undobuf.undo[undobuf.num_undo].where.i = (int *) &INTO;\t\\\n-\t  undobuf.undo[undobuf.num_undo].old_contents.i = INTO;\t\t\\\n-\t  INTO = NEWVAL;\t\t\t\t\t\t\\\n-\t  if (undobuf.undo[undobuf.num_undo].old_contents.i != INTO)\t\\\n-\t    undobuf.num_undo++;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n+ do { struct undo *_buf;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      if (undobuf.frees)\t\t\t\t\t\\\n+\t_buf = undobuf.frees, undobuf.frees = _buf->next;\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t_buf = (struct undo *) xmalloc (sizeof (struct undo));\t\\\n+\t\t\t\t\t\t\t\t\\\n+      _buf->is_int = 1;\t\t\t\t\t\t\\\n+      _buf->where.i = (int *) &INTO;\t\t\t\t\\\n+      _buf->old_contents.i = INTO;\t\t\t\t\\\n+      INTO = NEWVAL;\t\t\t\t\t\t\\\n+      if (_buf->old_contents.i == INTO)\t\t\t\t\\\n+\t_buf->next = undobuf.frees, undobuf.frees = _buf;\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t_buf->next = undobuf.undos, undobuf.undos = _buf;\t\\\n      } while (0)\n \n /* Number of times the pseudo being substituted for\n@@ -463,7 +473,7 @@ combine_instructions (f, nregs)\n   combine_merges = 0;\n   combine_extras = 0;\n   combine_successes = 0;\n-  undobuf.num_undo = previous_num_undos = 0;\n+  undobuf.undos = undobuf.previous_undos = 0;\n \n   combine_max_regno = nregs;\n \n@@ -1243,7 +1253,7 @@ try_combine (i3, i2, i1)\n \n   combine_attempts++;\n \n-  undobuf.num_undo = previous_num_undos = 0;\n+  undobuf.undos = undobuf.previous_undos = 0;\n   undobuf.other_insn = 0;\n \n   /* Save the current high-water-mark so we can free storage if we didn't\n@@ -1517,7 +1527,7 @@ try_combine (i3, i2, i1)\n \t  i2src = subst (i2src, pc_rtx, pc_rtx, 0, 0);\n \t}\n \n-      previous_num_undos = undobuf.num_undo;\n+      undobuf.previous_undos = undobuf.undos;\n     }\n \n #ifndef HAVE_cc0\n@@ -1591,7 +1601,7 @@ try_combine (i3, i2, i1)\n       subst_low_cuid = INSN_CUID (i2);\n       newpat = subst (PATTERN (i3), i2dest, i2src, 0,\n \t\t      ! i1_feeds_i3 && i1dest_in_i1src);\n-      previous_num_undos = undobuf.num_undo;\n+      undobuf.previous_undos = undobuf.undos;\n \n       /* Record whether i2's body now appears within i3's body.  */\n       i2_is_used = n_occurrences;\n@@ -1616,7 +1626,7 @@ try_combine (i3, i2, i1)\n       n_occurrences = 0;\n       subst_low_cuid = INSN_CUID (i1);\n       newpat = subst (newpat, i1dest, i1src, 0, 0);\n-      previous_num_undos = undobuf.num_undo;\n+      undobuf.previous_undos = undobuf.undos;\n     }\n \n   /* Fail if an autoincrement side-effect has been duplicated.  Be careful\n@@ -2404,20 +2414,22 @@ try_combine (i3, i2, i1)\n static void\n undo_all ()\n {\n-  register int i;\n-  if (undobuf.num_undo > MAX_UNDO)\n-    undobuf.num_undo = MAX_UNDO;\n-  for (i = undobuf.num_undo - 1; i >= 0; i--)\n+  struct undo *undo, *next;\n+\n+  for (undo = undobuf.undos; undo; undo = next)\n     {\n-      if (undobuf.undo[i].is_int)\n-\t*undobuf.undo[i].where.i = undobuf.undo[i].old_contents.i;\n+      next = undo->next;\n+      if (undo->is_int)\n+\t*undo->where.i = undo->old_contents.i;\n       else\n-\t*undobuf.undo[i].where.r = undobuf.undo[i].old_contents.r;\n-      \n+\t*undo->where.r = undo->old_contents.r;\n+\n+      undo->next = undobuf.frees;\n+      undobuf.frees = undo;\n     }\n \n   obfree (undobuf.storage);\n-  undobuf.num_undo = 0;\n+  undobuf.undos = 0;\n \n   /* Clear this here, so that subsequent get_last_value calls are not\n      affected.  */\n@@ -8711,6 +8723,7 @@ gen_rtx_combine VPROTO((enum rtx_code code, enum machine_mode mode, ...))\n   int i, j;\n   char *fmt;\n   rtx rt;\n+  struct undo *undo;\n \n   VA_START (p, mode);\n \n@@ -8737,17 +8750,17 @@ gen_rtx_combine VPROTO((enum rtx_code code, enum machine_mode mode, ...))\n   /* See if this is in undobuf.  Be sure we don't use objects that came\n      from another insn; this could produce circular rtl structures.  */\n \n-  for (i = previous_num_undos; i < undobuf.num_undo; i++)\n-    if (!undobuf.undo[i].is_int\n-\t&& GET_CODE (undobuf.undo[i].old_contents.r) == code\n-\t&& GET_MODE (undobuf.undo[i].old_contents.r) == mode)\n+  for (undo = undobuf.undos; undo != undobuf.previous_undos; undo = undo->next)\n+    if (!undo->is_int\n+\t&& GET_CODE (undo->old_contents.r) == code\n+\t&& GET_MODE (undo->old_contents.r) == mode)\n       {\n \tfor (j = 0; j < n_args; j++)\n-\t  if (XEXP (undobuf.undo[i].old_contents.r, j) != args[j])\n+\t  if (XEXP (undo->old_contents.r, j) != args[j])\n \t    break;\n \n \tif (j == n_args)\n-\t  return undobuf.undo[i].old_contents.r;\n+\t  return undo->old_contents.r;\n       }\n \n   /* Otherwise make a new rtx.  We know we have 1, 2, or 3 args."}]}