{"sha": "a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMwNjhjYTZlN2QzY2I5ZTdiZjVkYjAyNzlhZDZjYTgxNGJkNmUyOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-19T09:03:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-19T09:03:03Z"}, "message": "[multiple changes]\n\n2011-09-19  Steve Baird  <baird@adacore.com>\n\n\t* snames.ads-tmpl: Move declaration of Name_Annotate into range of\n\tconfiguration pragma names so that Is_Configuration_Pragma_Name\n\twill return True for Name_Annotate.  Make corresponding change in\n\tPragma_Id enumeration type.  This is needed to allow an Annotate\n\tpragma to occur in a configuration pragma file (typically,\n\ta gnat.adc file).\n\t* gnat_ugn.texi: Add Annotate to the list of configuration pragmas.\n\t* gnat_rm.texi: Note that pragma Annotate may be used as a\n\tconfiguration pragma.\n\n2011-09-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-cbmutr.adb, a-cbmutr.ads, a-cimutr.adb, a-cimutr.ads,\n\ta-comutr.adb, a-comutr.ads: Add iterator machinery for multiway trees.\n\n2011-09-19  Yannick Moy  <moy@adacore.com>\n\n\t* exp_alfa.adb, exp_alfa.ads (Expand_Alfa_N_In): New function\n\tfor expansion of set membership.\n\t(Expand_Alfa): Call expansion for N_In and N_Not_In nodes.\n\t* exp_ch4.adb, exp_ch4.ads (Expand_Set_Membership): Make procedure\n\tvisible for use in Alfa expansion.\n\t* sem_ch5.adb (Analyze_Iterator_Specification): Introduce loop\n\tvariable in Alfa mode.\n\n2011-09-19  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-osinte-darwin.ads: Change SIGADAABRT on Darwin to SIGABRT.\n\n2011-09-19  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch9.adb: Minor reformatting.\n\n2011-09-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* freeze.adb (Build_Renamed_Body): Generic subprograms\n\tinstantiations cannot be poperly inlined by the compiler, do\n\tnot set the Body_To_Inline attribute in such cases.\n\t* sem_ch12.adb (Analyze_Subprogram_Instantiation): Inherit all\n\tinlining-related flags from the generic subprogram declaration.\n\n2011-09-19  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_dist.adb, rtsfind.ads, sem_util.adb, sem_util.ads\n\t(Build_Stub_Type): Remove, instead copy components from\n\tSystem.Partition_Interface.RACW_Stub_Type.\n\t(RPC_Receiver_Decl): Remainder of code from old Build_Stub_Type routine.\n\t(Copy_Component_List): New subprogram.\n\n2011-09-19  Yannick Moy  <moy@adacore.com>\n\n\t* lib-xref.adb (Generate_Reference): Ignore references to\n\tconstants in Standard.\n\nFrom-SVN: r178962", "tree": {"sha": "b33e70843b45fbf14c84216c61cb9b7028bbef0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b33e70843b45fbf14c84216c61cb9b7028bbef0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/comments", "author": null, "committer": null, "parents": [{"sha": "e7fceebce65739f184ad8e090d0fac712336df34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7fceebce65739f184ad8e090d0fac712336df34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7fceebce65739f184ad8e090d0fac712336df34"}], "stats": {"total": 1209, "additions": 968, "deletions": 241}, "files": [{"sha": "86bbd122acf69ea5fb496977b996ba636aaae47f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -1,3 +1,59 @@\n+2011-09-19  Steve Baird  <baird@adacore.com>\n+\n+\t* snames.ads-tmpl: Move declaration of Name_Annotate into range of\n+\tconfiguration pragma names so that Is_Configuration_Pragma_Name\n+\twill return True for Name_Annotate.  Make corresponding change in\n+\tPragma_Id enumeration type.  This is needed to allow an Annotate\n+\tpragma to occur in a configuration pragma file (typically,\n+\ta gnat.adc file).\n+\t* gnat_ugn.texi: Add Annotate to the list of configuration pragmas.\n+\t* gnat_rm.texi: Note that pragma Annotate may be used as a\n+\tconfiguration pragma.\n+\n+2011-09-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-cbmutr.adb, a-cbmutr.ads, a-cimutr.adb, a-cimutr.ads,\n+\ta-comutr.adb, a-comutr.ads: Add iterator machinery for multiway trees.\n+\n+2011-09-19  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_alfa.adb, exp_alfa.ads (Expand_Alfa_N_In): New function\n+\tfor expansion of set membership.\n+\t(Expand_Alfa): Call expansion for N_In and N_Not_In nodes.\n+\t* exp_ch4.adb, exp_ch4.ads (Expand_Set_Membership): Make procedure\n+\tvisible for use in Alfa expansion.\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): Introduce loop\n+\tvariable in Alfa mode.\n+\n+2011-09-19  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-osinte-darwin.ads: Change SIGADAABRT on Darwin to SIGABRT.\n+\n+2011-09-19  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch9.adb: Minor reformatting.\n+\n+2011-09-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* freeze.adb (Build_Renamed_Body): Generic subprograms\n+\tinstantiations cannot be poperly inlined by the compiler, do\n+\tnot set the Body_To_Inline attribute in such cases.\n+\t* sem_ch12.adb (Analyze_Subprogram_Instantiation): Inherit all\n+\tinlining-related flags from the generic subprogram declaration.\n+\n+2011-09-19  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_dist.adb, rtsfind.ads, sem_util.adb, sem_util.ads\n+\t(Build_Stub_Type): Remove, instead copy components from\n+\tSystem.Partition_Interface.RACW_Stub_Type.\n+\t(RPC_Receiver_Decl): Remainder of code from old Build_Stub_Type routine.\n+\t(Copy_Component_List): New subprogram.\n+\n+2011-09-19  Yannick Moy  <moy@adacore.com>\n+\n+\t* lib-xref.adb (Generate_Reference): Ignore references to\n+\tconstants in Standard.\n+\n 2011-09-19  Robert Dewar  <dewar@adacore.com>\n \n \t* err_vars.ads, errout.ads: Minor reformatting."}, {"sha": "32ab0828942442a35bb952b315df742a4b913f92", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 166, "deletions": 3, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -28,9 +28,22 @@\n ------------------------------------------------------------------------------\n \n with System;  use type System.Address;\n-\n package body Ada.Containers.Bounded_Multiway_Trees is\n \n+   No_Node : constant Count_Type'Base := -1;\n+\n+   type Iterator is new Tree_Iterator_Interfaces.Forward_Iterator with\n+   record\n+      Container : Tree_Access;\n+      Position  : Cursor;\n+      From_Root : Boolean;\n+   end record;\n+\n+   overriding function First (Object : Iterator) return Cursor;\n+   overriding function Next\n+     (Object : Iterator;\n+      Position : Cursor) return Cursor;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -381,7 +394,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          First     => First,\n          Last      => Last,\n          Parent    => Parent.Node,\n-         Before    => -1);  -- means \"insert at end of list\"\n+         Before    => No_Node);  -- means \"insert at end of list\"\n \n       Container.Count := Container.Count + Count;\n    end Append_Child;\n@@ -1223,6 +1236,11 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       return Cursor'(Container'Unrestricted_Access, Node);\n    end Find;\n \n+   function First (Object : Iterator) return Cursor is\n+   begin\n+      return Object.Position;\n+   end First;\n+\n    -----------------\n    -- First_Child --\n    -----------------\n@@ -1367,7 +1385,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    is\n    begin\n       Container.Nodes (Index) :=\n-        (Parent   => -1,\n+        (Parent   => No_Node,\n          Prev     => 0,\n          Next     => 0,\n          Children => (others => 0));\n@@ -1715,6 +1733,23 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          raise;\n    end Iterate;\n \n+   function Iterate (Container : Tree)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class\n+   is\n+      Root_Cursor : constant Cursor :=\n+        (Container'Unrestricted_Access, Root_Node (Container));\n+   begin\n+      return\n+        Iterator'(Container'Unrestricted_Access,\n+                     First_Child (Root_Cursor), From_Root => True);\n+   end Iterate;\n+\n+   function Iterate_Subtree (Position : Cursor)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class is\n+   begin\n+      return Iterator'(Position.Container, Position, From_Root => False);\n+   end Iterate_Subtree;\n+\n    ----------------------\n    -- Iterate_Children --\n    ----------------------\n@@ -1888,6 +1923,74 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Source.Clear;\n    end Move;\n \n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next\n+     (Object : Iterator;\n+      Position : Cursor) return Cursor\n+   is\n+      T  : Tree renames Position.Container.all;\n+      NN : Tree_Node_Array renames T.Nodes;\n+      N  : Tree_Node_Type renames NN (Position.Node);\n+\n+   begin\n+      if Is_Leaf (Position) then\n+\n+         --  If sibling is present, return it.\n+\n+         if N.Next /= 0 then\n+            return (Object.Container, N.Next);\n+\n+         --  If this is the last sibling, go to sibling of first ancestor that\n+         --  has a sibling, or terminate.\n+\n+         else\n+            declare\n+               Pos : Count_Type := N.Parent;\n+               Par : Tree_Node_Type := NN (Pos);\n+\n+            begin\n+               while Par.Next = 0 loop\n+                  Pos := Par.Parent;\n+\n+                  --  If we are back at the root the iteration is complete.\n+\n+                  if Pos = No_Node then\n+                     return No_Element;\n+\n+                  --  If this is a subtree iterator and we are back at the\n+                  --  starting node, iteration is complete.\n+\n+                  elsif Pos = Object.Position.Node\n+                    and then not Object.From_Root\n+                  then\n+                     return No_Element;\n+\n+                  else\n+                     Par := NN (Pos);\n+                  end if;\n+               end loop;\n+\n+               if Pos = Object.Position.Node\n+                 and then not Object.From_Root\n+               then\n+                  return No_Element;\n+               end if;\n+\n+               return (Object.Container, Par.Next);\n+            end;\n+         end if;\n+\n+      else\n+\n+         --  If an internal node, return its first child.\n+\n+         return (Object.Container, N.Children.First);\n+      end if;\n+   end Next;\n+\n    ------------------\n    -- Next_Sibling --\n    ------------------\n@@ -2224,6 +2327,50 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       raise Program_Error with \"attempt to read tree cursor from stream\";\n    end Read;\n \n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      pragma Unreferenced (Container);\n+\n+      return\n+        (Element =>\n+            Position.Container.Elements (Position.Node)'Unchecked_Access);\n+   end Constant_Reference;\n+\n+   function Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Reference_Type\n+   is\n+   begin\n+      pragma Unreferenced (Container);\n+\n+      return\n+        (Element =>\n+            Position.Container.Elements (Position.Node)'Unchecked_Access);\n+   end Reference;\n+\n    --------------------\n    -- Remove_Subtree --\n    --------------------\n@@ -3073,4 +3220,20 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       raise Program_Error with \"attempt to write tree cursor to stream\";\n    end Write;\n \n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n end Ada.Containers.Bounded_Multiway_Trees;"}, {"sha": "f20af0487c507214df450fa68270dcf582c190f5", "filename": "gcc/ada/a-cbmutr.ads", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-cbmutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-cbmutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.ads?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -31,6 +31,7 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+with Ada.Iterator_Interfaces;\n private with Ada.Streams;\n \n generic\n@@ -42,7 +43,11 @@ package Ada.Containers.Bounded_Multiway_Trees is\n    pragma Pure;\n    pragma Remote_Types;\n \n-   type Tree (Capacity : Count_Type) is tagged private;\n+   type Tree (Capacity : Count_Type) is tagged private\n+     with Constant_Indexing => Constant_Reference,\n+          Variable_Indexing => Reference,\n+          Default_Iterator  => Iterate,\n+          Iterator_Element  => Element_Type;\n    pragma Preelaborable_Initialization (Tree);\n \n    type Cursor is private;\n@@ -51,6 +56,10 @@ package Ada.Containers.Bounded_Multiway_Trees is\n    Empty_Tree : constant Tree;\n \n    No_Element : constant Cursor;\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   package Tree_Iterator_Interfaces is new\n+     Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n    function Equal_Subtree\n      (Left_Position  : Cursor;\n@@ -90,6 +99,14 @@ package Ada.Containers.Bounded_Multiway_Trees is\n       Position  : Cursor;\n       Process   : not null access procedure (Element : in out Element_Type));\n \n+   type Constant_Reference_Type\n+     (Element : not null access constant Element_Type) is private\n+        with Implicit_Dereference => Element;\n+\n+   type Reference_Type\n+     (Element : not null access Element_Type) is private\n+        with Implicit_Dereference => Element;\n+\n    procedure Assign (Target : in out Tree; Source : Tree);\n \n    function Copy (Source : Tree; Capacity : Count_Type := 0) return Tree;\n@@ -148,8 +165,6 @@ package Ada.Containers.Bounded_Multiway_Trees is\n      (Container : Tree;\n       Item      : Element_Type) return Boolean;\n \n-   function Has_Element (Position : Cursor) return Boolean;\n-\n    procedure Iterate\n      (Container : Tree;\n       Process   : not null access procedure (Position : Cursor));\n@@ -158,6 +173,12 @@ package Ada.Containers.Bounded_Multiway_Trees is\n      (Position  : Cursor;\n       Process   : not null access procedure (Position : Cursor));\n \n+   function Iterate (Container : Tree)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class;\n+\n+   function Iterate_Subtree (Position : Cursor)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class;\n+\n    function Child_Count (Parent : Cursor) return Count_Type;\n \n    function Child_Depth (Parent, Child : Cursor) return Count_Type;\n@@ -273,6 +294,7 @@ package Ada.Containers.Bounded_Multiway_Trees is\n       Process : not null access procedure (Position : Cursor));\n \n private\n+   use Ada.Streams;\n \n    type Children_Type is record\n       First : Count_Type'Base;\n@@ -287,7 +309,7 @@ private\n    end record;\n \n    type Tree_Node_Array is array (Count_Type range <>) of Tree_Node_Type;\n-   type Element_Array is array (Count_Type range <>) of Element_Type;\n+   type Element_Array is array (Count_Type range <>) of aliased Element_Type;\n \n    type Tree (Capacity : Count_Type) is tagged record\n       Nodes    : Tree_Node_Array (0 .. Capacity) := (others => <>);\n@@ -298,8 +320,6 @@ private\n       Count    : Count_Type := 0;\n    end record;\n \n-   use Ada.Streams;\n-\n    procedure Write\n      (Stream    : not null access Root_Stream_Type'Class;\n       Container : Tree);\n@@ -320,19 +340,52 @@ private\n       Node      : Count_Type'Base := -1;\n    end record;\n \n+   procedure  Read\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : out Cursor);\n+   for Cursor'Read use Read;\n+\n    procedure Write\n      (Stream   : not null access Root_Stream_Type'Class;\n       Position : Cursor);\n-\n    for Cursor'Write use Write;\n \n+   type Constant_Reference_Type\n+     (Element : not null access constant Element_Type) is null record;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+   for Constant_Reference_Type'Write use Write;\n+\n    procedure Read\n-     (Stream   : not null access Root_Stream_Type'Class;\n-      Position : out Cursor);\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+   for Constant_Reference_Type'Read use Read;\n \n-   for Cursor'Read use Read;\n+   type Reference_Type\n+     (Element : not null access Element_Type) is null record;\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+   for Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+   for Reference_Type'Read use Read;\n+\n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor)\n+   return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor)\n+    return Reference_Type;\n \n-   Empty_Tree : constant Tree := Tree'(Capacity => 0, others => <>);\n+   Empty_Tree : constant Tree := (Capacity => 0, others => <>);\n \n    No_Element : constant Cursor := Cursor'(others => <>);\n "}, {"sha": "96c1fe26d7a7762286a19962107a24d01fb9ce73", "filename": "gcc/ada/a-cimutr.adb", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -32,6 +32,18 @@ with System;  use type System.Address;\n \n package body Ada.Containers.Indefinite_Multiway_Trees is\n \n+   type Iterator is new Tree_Iterator_Interfaces.Forward_Iterator with\n+   record\n+      Container : Tree_Access;\n+      Position  : Cursor;\n+      From_Root : Boolean;\n+   end record;\n+\n+   overriding function First (Object : Iterator) return Cursor;\n+   overriding function Next\n+     (Object : Iterator;\n+      Position : Cursor) return Cursor;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -915,6 +927,15 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       return Cursor'(Container'Unrestricted_Access, N);\n    end Find;\n \n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Object : Iterator) return Cursor is\n+   begin\n+      return Object.Position;\n+   end First;\n+\n    -----------------\n    -- First_Child --\n    -----------------\n@@ -1280,6 +1301,23 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          raise;\n    end Iterate;\n \n+   function Iterate (Container : Tree)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class\n+   is\n+      Root_Cursor : constant Cursor :=\n+        (Container'Unrestricted_Access, Root_Node (Container));\n+   begin\n+      return\n+        Iterator'(Container'Unrestricted_Access,\n+                     First_Child (Root_Cursor), From_Root => True);\n+   end Iterate;\n+\n+   function Iterate_Subtree (Position : Cursor)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class is\n+   begin\n+      return Iterator'(Position.Container, Position, From_Root => False);\n+   end Iterate_Subtree;\n+\n    ----------------------\n    -- Iterate_Children --\n    ----------------------\n@@ -1446,6 +1484,71 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Source.Count := 0;\n    end Move;\n \n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next\n+     (Object : Iterator;\n+      Position : Cursor) return Cursor\n+   is\n+      T  : Tree renames Position.Container.all;\n+      N  : constant Tree_Node_Access := Position.Node;\n+\n+   begin\n+      if Is_Leaf (Position) then\n+\n+         --  If sibling is present, return it.\n+\n+         if N.Next /= null then\n+            return (Object.Container, N.Next);\n+\n+         --  If this is the last sibling, go to sibling of first ancestor that\n+         --  has a sibling, or terminate.\n+\n+         else\n+            declare\n+               Par : Tree_Node_Access := N.Parent;\n+\n+            begin\n+               while Par.Next = null loop\n+\n+                  --  If we are back at the root the iteration is complete.\n+\n+                  if Par = Root_Node (T)  then\n+                     return No_Element;\n+\n+                  --  If this is a subtree iterator and we are back at the\n+                  --  starting node, iteration is complete.\n+\n+                  elsif Par = Object.Position.Node\n+                    and then not Object.From_Root\n+                  then\n+                     return No_Element;\n+\n+                  else\n+                     Par := Par.Parent;\n+                  end if;\n+               end loop;\n+\n+               if Par = Object.Position.Node\n+                 and then not Object.From_Root\n+               then\n+                  return No_Element;\n+               end if;\n+\n+               return (Object.Container, Par.Next);\n+            end;\n+         end if;\n+\n+      else\n+\n+         --  If an internal node, return its first child.\n+\n+         return (Object.Container, N.Children.First);\n+      end if;\n+   end Next;\n+\n    ------------------\n    -- Next_Sibling --\n    ------------------\n@@ -1746,6 +1849,46 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       raise Program_Error with \"attempt to read tree cursor from stream\";\n    end Read;\n \n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      pragma Unreferenced (Container);\n+\n+      return (Element => Position.Node.Element.all'Unchecked_Access);\n+   end Constant_Reference;\n+\n+   function Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Reference_Type\n+   is\n+   begin\n+      pragma Unreferenced (Container);\n+\n+      return (Element => Position.Node.Element.all'Unchecked_Access);\n+   end Reference;\n+\n    --------------------\n    -- Remove_Subtree --\n    --------------------\n@@ -2414,4 +2557,20 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       raise Program_Error with \"attempt to write tree cursor to stream\";\n    end Write;\n \n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n end Ada.Containers.Indefinite_Multiway_Trees;"}, {"sha": "c47f986c9b3710b4a35fa70894b021e867b07c27", "filename": "gcc/ada/a-cimutr.ads", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-cimutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-cimutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.ads?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -31,6 +31,7 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+with Ada.Iterator_Interfaces;\n private with Ada.Finalization;\n private with Ada.Streams;\n \n@@ -43,7 +44,12 @@ package Ada.Containers.Indefinite_Multiway_Trees is\n    pragma Preelaborate;\n    pragma Remote_Types;\n \n-   type Tree is tagged private;\n+   type Tree is tagged private\n+     with Constant_Indexing => Constant_Reference,\n+          Variable_Indexing => Reference,\n+          Default_Iterator  => Iterate,\n+          Iterator_Element  => Element_Type;\n+\n    pragma Preelaborable_Initialization (Tree);\n \n    type Cursor is private;\n@@ -52,6 +58,10 @@ package Ada.Containers.Indefinite_Multiway_Trees is\n    Empty_Tree : constant Tree;\n \n    No_Element : constant Cursor;\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   package Tree_Iterator_Interfaces is new\n+     Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n    function Equal_Subtree\n      (Left_Position  : Cursor;\n@@ -91,6 +101,14 @@ package Ada.Containers.Indefinite_Multiway_Trees is\n       Position  : Cursor;\n       Process   : not null access procedure (Element : in out Element_Type));\n \n+   type Constant_Reference_Type\n+     (Element : not null access constant Element_Type) is private\n+        with Implicit_Dereference => Element;\n+\n+   type Reference_Type\n+     (Element : not null access Element_Type) is private\n+        with Implicit_Dereference => Element;\n+\n    procedure Assign (Target : in out Tree; Source : Tree);\n \n    function Copy (Source : Tree) return Tree;\n@@ -149,8 +167,6 @@ package Ada.Containers.Indefinite_Multiway_Trees is\n      (Container : Tree;\n       Item      : Element_Type) return Boolean;\n \n-   function Has_Element (Position : Cursor) return Boolean;\n-\n    procedure Iterate\n      (Container : Tree;\n       Process   : not null access procedure (Position : Cursor));\n@@ -159,6 +175,12 @@ package Ada.Containers.Indefinite_Multiway_Trees is\n      (Position  : Cursor;\n       Process   : not null access procedure (Position : Cursor));\n \n+   function Iterate (Container : Tree)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class;\n+\n+   function Iterate_Subtree (Position : Cursor)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class;\n+\n    function Child_Count (Parent : Cursor) return Count_Type;\n \n    function Child_Depth (Parent, Child : Cursor) return Count_Type;\n@@ -343,6 +365,46 @@ private\n \n    for Cursor'Read use Read;\n \n+   type Constant_Reference_Type\n+     (Element : not null access constant Element_Type) is null record;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   type Reference_Type\n+     (Element : not null access Element_Type) is null record;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor)\n+   return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor)\n+    return Reference_Type;\n+\n    Empty_Tree : constant Tree := (Controlled with others => <>);\n \n    No_Element : constant Cursor := (others => <>);"}, {"sha": "17b70d4dc1ba08d4b99cbc2ef98b0bea2308601d", "filename": "gcc/ada/a-comutr.adb", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-comutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-comutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -33,6 +33,18 @@ with System;  use type System.Address;\n \n package body Ada.Containers.Multiway_Trees is\n \n+   type Iterator is new Tree_Iterator_Interfaces.Forward_Iterator with\n+   record\n+      Container : Tree_Access;\n+      Position  : Cursor;\n+      From_Root : Boolean;\n+   end record;\n+\n+   overriding function First (Object : Iterator) return Cursor;\n+   overriding function Next\n+     (Object : Iterator;\n+      Position : Cursor) return Cursor;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -891,6 +903,15 @@ package body Ada.Containers.Multiway_Trees is\n       return Cursor'(Container'Unrestricted_Access, N);\n    end Find;\n \n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Object : Iterator) return Cursor is\n+   begin\n+      return Object.Position;\n+   end First;\n+\n    -----------------\n    -- First_Child --\n    -----------------\n@@ -1323,6 +1344,23 @@ package body Ada.Containers.Multiway_Trees is\n          raise;\n    end Iterate;\n \n+   function Iterate (Container : Tree)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class\n+   is\n+      Root_Cursor : constant Cursor :=\n+        (Container'Unrestricted_Access, Root_Node (Container));\n+   begin\n+      return\n+        Iterator'(Container'Unrestricted_Access,\n+                     First_Child (Root_Cursor), From_Root => True);\n+   end Iterate;\n+\n+   function Iterate_Subtree (Position : Cursor)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class is\n+   begin\n+      return Iterator'(Position.Container, Position, From_Root => False);\n+   end Iterate_Subtree;\n+\n    ----------------------\n    -- Iterate_Children --\n    ----------------------\n@@ -1490,6 +1528,71 @@ package body Ada.Containers.Multiway_Trees is\n       Source.Count := 0;\n    end Move;\n \n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next\n+     (Object : Iterator;\n+      Position : Cursor) return Cursor\n+   is\n+      T  : Tree renames Position.Container.all;\n+      N  : constant Tree_Node_Access := Position.Node;\n+\n+   begin\n+      if Is_Leaf (Position) then\n+\n+         --  If sibling is present, return it.\n+\n+         if N.Next /= null then\n+            return (Object.Container, N.Next);\n+\n+         --  If this is the last sibling, go to sibling of first ancestor that\n+         --  has a sibling, or terminate.\n+\n+         else\n+            declare\n+               Par : Tree_Node_Access := N.Parent;\n+\n+            begin\n+               while Par.Next = null loop\n+\n+                  --  If we are back at the root the iteration is complete.\n+\n+                  if Par = Root_Node (T)  then\n+                     return No_Element;\n+\n+                  --  If this is a subtree iterator and we are back at the\n+                  --  starting node, iteration is complete.\n+\n+                  elsif Par = Object.Position.Node\n+                    and then not Object.From_Root\n+                  then\n+                     return No_Element;\n+\n+                  else\n+                     Par := Par.Parent;\n+                  end if;\n+               end loop;\n+\n+               if Par = Object.Position.Node\n+                 and then not Object.From_Root\n+               then\n+                  return No_Element;\n+               end if;\n+\n+               return (Object.Container, Par.Next);\n+            end;\n+         end if;\n+\n+      else\n+\n+         --  If an internal node, return its first child.\n+\n+         return (Object.Container, N.Children.First);\n+      end if;\n+   end Next;\n+\n    ------------------\n    -- Next_Sibling --\n    ------------------\n@@ -1784,6 +1887,46 @@ package body Ada.Containers.Multiway_Trees is\n       raise Program_Error with \"attempt to read tree cursor from stream\";\n    end Read;\n \n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      pragma Unreferenced (Container);\n+\n+      return (Element => Position.Node.Element'Unrestricted_Access);\n+   end Constant_Reference;\n+\n+   function Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Reference_Type\n+   is\n+   begin\n+      pragma Unreferenced (Container);\n+\n+      return (Element => Position.Node.Element'Unrestricted_Access);\n+   end Reference;\n+\n    --------------------\n    -- Remove_Subtree --\n    --------------------\n@@ -2460,4 +2603,20 @@ package body Ada.Containers.Multiway_Trees is\n       raise Program_Error with \"attempt to write tree cursor to stream\";\n    end Write;\n \n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n end Ada.Containers.Multiway_Trees;"}, {"sha": "00a78e3aebb5faa834f4007bda19a0bbab577455", "filename": "gcc/ada/a-comutr.ads", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-comutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fa-comutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.ads?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -31,6 +31,7 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+with Ada.Iterator_Interfaces;\n private with Ada.Finalization;\n private with Ada.Streams;\n \n@@ -43,7 +44,11 @@ package Ada.Containers.Multiway_Trees is\n    pragma Preelaborate;\n    pragma Remote_Types;\n \n-   type Tree is tagged private;\n+   type Tree is tagged private\n+     with Constant_Indexing => Constant_Reference,\n+          Variable_Indexing => Reference,\n+          Default_Iterator  => Iterate,\n+          Iterator_Element  => Element_Type;\n    pragma Preelaborable_Initialization (Tree);\n \n    type Cursor is private;\n@@ -52,6 +57,10 @@ package Ada.Containers.Multiway_Trees is\n    Empty_Tree : constant Tree;\n \n    No_Element : constant Cursor;\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   package Tree_Iterator_Interfaces is new\n+     Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n    function Equal_Subtree\n      (Left_Position  : Cursor;\n@@ -91,6 +100,14 @@ package Ada.Containers.Multiway_Trees is\n       Position  : Cursor;\n       Process   : not null access procedure (Element : in out Element_Type));\n \n+   type Constant_Reference_Type\n+     (Element : not null access constant Element_Type) is private\n+        with Implicit_Dereference => Element;\n+\n+   type Reference_Type\n+     (Element : not null access Element_Type) is private\n+        with Implicit_Dereference => Element;\n+\n    procedure Assign (Target : in out Tree; Source : Tree);\n \n    function Copy (Source : Tree) return Tree;\n@@ -149,8 +166,6 @@ package Ada.Containers.Multiway_Trees is\n      (Container : Tree;\n       Item      : Element_Type) return Boolean;\n \n-   function Has_Element (Position : Cursor) return Boolean;\n-\n    procedure Iterate\n      (Container : Tree;\n       Process   : not null access procedure (Position : Cursor));\n@@ -159,6 +174,12 @@ package Ada.Containers.Multiway_Trees is\n      (Position  : Cursor;\n       Process   : not null access procedure (Position : Cursor));\n \n+   function Iterate (Container : Tree)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class;\n+\n+   function Iterate_Subtree (Position : Cursor)\n+     return Tree_Iterator_Interfaces.Forward_Iterator'Class;\n+\n    function Child_Count (Parent : Cursor) return Count_Type;\n \n    function Child_Depth (Parent, Child : Cursor) return Count_Type;\n@@ -389,6 +410,46 @@ private\n \n    for Cursor'Read use Read;\n \n+   type Constant_Reference_Type\n+     (Element : not null access constant Element_Type) is null record;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   type Reference_Type\n+     (Element : not null access Element_Type) is null record;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor)\n+   return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor)\n+    return Reference_Type;\n+\n    Empty_Tree : constant Tree := (Controlled with others => <>);\n \n    No_Element : constant Cursor := (others => <>);"}, {"sha": "988d16fba1f7b350397cb9c47fbee79301cfaa91", "filename": "gcc/ada/exp_alfa.adb", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_alfa.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -26,8 +26,10 @@\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Exp_Attr; use Exp_Attr;\n+with Exp_Ch4;  use Exp_Ch4;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Dbug; use Exp_Dbug;\n+with Nlists;   use Nlists;\n with Rtsfind;  use Rtsfind;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Res;  use Sem_Res;\n@@ -51,6 +53,9 @@ package body Exp_Alfa is\n    procedure Expand_Alfa_N_Attribute_Reference (N : Node_Id);\n    --  Expand attributes 'Old and 'Result only\n \n+   procedure Expand_Alfa_N_In (N : Node_Id);\n+   --  Expand set membership into individual ones\n+\n    procedure Expand_Alfa_N_Simple_Return_Statement (N : Node_Id);\n    --  Insert conversion on function return if necessary\n \n@@ -81,6 +86,12 @@ package body Exp_Alfa is\n          when N_Attribute_Reference =>\n             Expand_Alfa_N_Attribute_Reference (N);\n \n+         when N_In =>\n+            Expand_Alfa_N_In (N);\n+\n+         when N_Not_In =>\n+            Expand_N_Not_In (N);\n+\n          when others =>\n             null;\n       end case;\n@@ -167,6 +178,18 @@ package body Exp_Alfa is\n       end case;\n    end Expand_Alfa_N_Attribute_Reference;\n \n+   ----------------------\n+   -- Expand_Alfa_N_In --\n+   ----------------------\n+\n+   procedure Expand_Alfa_N_In (N : Node_Id) is\n+   begin\n+      if Present (Alternatives (N)) then\n+         Expand_Set_Membership (N);\n+         return;\n+      end if;\n+   end Expand_Alfa_N_In;\n+\n    -------------------------------------------\n    -- Expand_Alfa_N_Simple_Return_Statement --\n    -------------------------------------------"}, {"sha": "dbb8cb220315ab861c98198eb4850666704049de", "filename": "gcc/ada/exp_alfa.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_alfa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_alfa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_alfa.ads?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -37,7 +37,7 @@\n --        conversions, expand actuals in calls to introduce temporaries)\n \n --    2. Facilitate treatment for the formal verification back-end (fully\n---       qualify names)\n+--       qualify names, set membership)\n \n --    3. Avoid the introduction of low-level code that is difficult to analyze\n --       formally, as typically done in the full expansion for high-level"}, {"sha": "c099933c310e16e390b46acb11a65a61f2c43f55", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 62, "deletions": 64, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -4630,68 +4630,6 @@ package body Exp_Ch4 is\n       Ltyp  : Entity_Id;\n       Rtyp  : Entity_Id;\n \n-      procedure Expand_Set_Membership;\n-      --  For each choice we create a simple equality or membership test.\n-      --  The whole membership is rewritten connecting these with OR ELSE.\n-\n-      ---------------------------\n-      -- Expand_Set_Membership --\n-      ---------------------------\n-\n-      procedure Expand_Set_Membership is\n-         Alt  : Node_Id;\n-         Res  : Node_Id;\n-\n-         function Make_Cond (Alt : Node_Id) return Node_Id;\n-         --  If the alternative is a subtype mark, create a simple membership\n-         --  test. Otherwise create an equality test for it.\n-\n-         ---------------\n-         -- Make_Cond --\n-         ---------------\n-\n-         function Make_Cond (Alt : Node_Id) return Node_Id is\n-            Cond : Node_Id;\n-            L    : constant Node_Id := New_Copy (Lop);\n-            R    : constant Node_Id := Relocate_Node (Alt);\n-\n-         begin\n-            if (Is_Entity_Name (Alt) and then Is_Type (Entity (Alt)))\n-              or else Nkind (Alt) = N_Range\n-            then\n-               Cond :=\n-                 Make_In (Sloc (Alt),\n-                   Left_Opnd  => L,\n-                   Right_Opnd => R);\n-            else\n-               Cond :=\n-                 Make_Op_Eq (Sloc (Alt),\n-                   Left_Opnd  => L,\n-                   Right_Opnd => R);\n-            end if;\n-\n-            return Cond;\n-         end Make_Cond;\n-\n-      --  Start of processing for Expand_Set_Membership\n-\n-      begin\n-         Alt := Last (Alternatives (N));\n-         Res := Make_Cond (Alt);\n-\n-         Prev (Alt);\n-         while Present (Alt) loop\n-            Res :=\n-              Make_Or_Else (Sloc (Alt),\n-                Left_Opnd  => Make_Cond (Alt),\n-                Right_Opnd => Res);\n-            Prev (Alt);\n-         end loop;\n-\n-         Rewrite (N, Res);\n-         Analyze_And_Resolve (N, Standard_Boolean);\n-      end Expand_Set_Membership;\n-\n       procedure Substitute_Valid_Check;\n       --  Replaces node N by Lop'Valid. This is done when we have an explicit\n       --  test for the left operand being in range of its subtype.\n@@ -4721,8 +4659,7 @@ package body Exp_Ch4 is\n       --  If set membership case, expand with separate procedure\n \n       if Present (Alternatives (N)) then\n-         Remove_Side_Effects (Lop);\n-         Expand_Set_Membership;\n+         Expand_Set_Membership (N);\n          return;\n       end if;\n \n@@ -9717,6 +9654,67 @@ package body Exp_Ch4 is\n       return Result;\n    end Expand_Record_Equality;\n \n+   ---------------------------\n+   -- Expand_Set_Membership --\n+   ---------------------------\n+\n+   procedure Expand_Set_Membership (N : Node_Id) is\n+      Lop : constant Node_Id := Left_Opnd (N);\n+      Alt : Node_Id;\n+      Res : Node_Id;\n+\n+      function Make_Cond (Alt : Node_Id) return Node_Id;\n+      --  If the alternative is a subtype mark, create a simple membership\n+      --  test. Otherwise create an equality test for it.\n+\n+      ---------------\n+      -- Make_Cond --\n+      ---------------\n+\n+      function Make_Cond (Alt : Node_Id) return Node_Id is\n+         Cond : Node_Id;\n+         L    : constant Node_Id := New_Copy (Lop);\n+         R    : constant Node_Id := Relocate_Node (Alt);\n+\n+      begin\n+         if (Is_Entity_Name (Alt) and then Is_Type (Entity (Alt)))\n+           or else Nkind (Alt) = N_Range\n+         then\n+            Cond :=\n+              Make_In (Sloc (Alt),\n+                Left_Opnd  => L,\n+                Right_Opnd => R);\n+         else\n+            Cond :=\n+              Make_Op_Eq (Sloc (Alt),\n+                Left_Opnd  => L,\n+                Right_Opnd => R);\n+         end if;\n+\n+         return Cond;\n+      end Make_Cond;\n+\n+   --  Start of processing for Expand_Set_Membership\n+\n+   begin\n+      Remove_Side_Effects (Lop);\n+\n+      Alt := Last (Alternatives (N));\n+      Res := Make_Cond (Alt);\n+\n+      Prev (Alt);\n+      while Present (Alt) loop\n+         Res :=\n+           Make_Or_Else (Sloc (Alt),\n+             Left_Opnd  => Make_Cond (Alt),\n+             Right_Opnd => Res);\n+         Prev (Alt);\n+      end loop;\n+\n+      Rewrite (N, Res);\n+      Analyze_And_Resolve (N, Standard_Boolean);\n+   end Expand_Set_Membership;\n+\n    -----------------------------------\n    -- Expand_Short_Circuit_Operator --\n    -----------------------------------"}, {"sha": "2e9c68b836c76fb656c142f6f409ab1408fcda2a", "filename": "gcc/ada/exp_ch4.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.ads?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -91,6 +91,11 @@ package Exp_Ch4 is\n    --  to insert those bodies at the right place. Nod provides the Sloc\n    --  value for generated code.\n \n+   procedure Expand_Set_Membership (N : Node_Id);\n+   --  For each choice of a set membership, we create a simple equality or\n+   --  membership test. The whole membership is rewritten connecting these\n+   --  with OR ELSE.\n+\n    function Integer_Promotion_Possible (N : Node_Id) return Boolean;\n    --  Returns true if the node is a type conversion whose operand is an\n    --  arithmetic operation on signed integers, and the base type of the"}, {"sha": "5b9d4f8f6089830c2328ad6dd7c9e10759c06f7a", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -5219,7 +5219,7 @@ package body Exp_Ch9 is\n \n       Comps := New_List (\n         Make_Component_Declaration (Loc,\n-          Defining_Identifier => Make_Temporary (Loc, 'P'),\n+          Defining_Identifier  => Make_Temporary (Loc, 'P'),\n           Component_Definition =>\n             Make_Component_Definition (Loc,\n               Aliased_Present => False,\n@@ -5236,11 +5236,10 @@ package body Exp_Ch9 is\n       Decl2 :=\n         Make_Full_Type_Declaration (Loc,\n           Defining_Identifier => E_T,\n-          Type_Definition =>\n+          Type_Definition     =>\n             Make_Record_Definition (Loc,\n               Component_List =>\n-                Make_Component_List (Loc,\n-                  Component_Items => Comps)));\n+                Make_Component_List (Loc, Component_Items => Comps)));\n \n       Insert_After (Decl1, Decl2);\n       Analyze (Decl2);"}, {"sha": "f857d0e82c4a7dfca4102d3d07de5a6d8bb32b62", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 61, "deletions": 141, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -328,8 +328,8 @@ package body Exp_Dist is\n \n       RPC_Receiver_Decl : Node_Id;\n       --  Declaration for the RPC receiver entity associated with the\n-      --  designated type. As an exception, for the case of an RACW that\n-      --  implements a RAS, no object RPC receiver is generated. Instead,\n+      --  designated type. As an exception, in the case of GARLIC, for an RACW\n+      --  that implements a RAS, no object RPC receiver is generated. Instead,\n       --  RPC_Receiver_Decl is the declaration after which the RPC receiver\n       --  would have been inserted.\n \n@@ -559,14 +559,9 @@ package body Exp_Dist is\n    --  call. Decls provides a location where variable declarations can be\n    --  appended to construct the necessary values.\n \n-   procedure Specific_Build_Stub_Type\n-     (RACW_Type         : Entity_Id;\n-      Stub_Type_Comps   : out List_Id;\n-      RPC_Receiver_Decl : out Node_Id);\n-   --  Build a components list for the stub type associated with an RACW type,\n-   --  and build the necessary RPC receiver, if applicable. PCS-specific\n-   --  ancillary subprogram for Add_Stub_Type. If no RPC receiver declaration\n-   --  is generated, then RPC_Receiver_Decl is set to Empty.\n+   function Specific_RPC_Receiver_Decl\n+     (RACW_Type : Entity_Id) return Node_Id;\n+   --  Build the RPC receiver, for RACW, if applicable, else return Empty\n \n    procedure Specific_Build_RPC_Receiver_Body\n      (RPC_Receiver : Entity_Id;\n@@ -656,10 +651,7 @@ package body Exp_Dist is\n          RCI_Locator           : Entity_Id;\n          Controlling_Parameter : Entity_Id) return RPC_Target;\n \n-      procedure Build_Stub_Type\n-        (RACW_Type         : Entity_Id;\n-         Stub_Type_Comps   : out List_Id;\n-         RPC_Receiver_Decl : out Node_Id);\n+      function RPC_Receiver_Decl (RACW_Type : Entity_Id) return Node_Id;\n \n       function Build_Subprogram_Receiving_Stubs\n         (Vis_Decl                 : Node_Id;\n@@ -733,10 +725,7 @@ package body Exp_Dist is\n          RCI_Locator           : Entity_Id;\n          Controlling_Parameter : Entity_Id) return RPC_Target;\n \n-      procedure Build_Stub_Type\n-        (RACW_Type         : Entity_Id;\n-         Stub_Type_Comps   : out List_Id;\n-         RPC_Receiver_Decl : out Node_Id);\n+      function RPC_Receiver_Decl (RACW_Type : Entity_Id) return Node_Id;\n \n       function Build_Subprogram_Receiving_Stubs\n         (Vis_Decl                 : Node_Id;\n@@ -1976,7 +1965,6 @@ package body Exp_Dist is\n \n       Stub_Elements         : constant Stub_Structure :=\n                                 Stubs_Table.Get (Designated_Type);\n-      Stub_Type_Comps       : List_Id;\n       Stub_Type_Decl        : Node_Id;\n       Stub_Type_Access_Decl : Node_Id;\n \n@@ -1999,7 +1987,9 @@ package body Exp_Dist is\n           Chars => New_External_Name\n                      (Related_Id => Chars (Stub_Type), Suffix => 'A'));\n \n-      Specific_Build_Stub_Type (RACW_Type, Stub_Type_Comps, RPC_Receiver_Decl);\n+      RPC_Receiver_Decl := Specific_RPC_Receiver_Decl (RACW_Type);\n+\n+      --  Create new stub type, copying components from generic RACW_Stub_Type\n \n       Stub_Type_Decl :=\n         Make_Full_Type_Declaration (Loc,\n@@ -2010,7 +2000,8 @@ package body Exp_Dist is\n               Limited_Present => True,\n               Component_List  =>\n                 Make_Component_List (Loc,\n-                  Component_Items => Stub_Type_Comps)));\n+                  Component_Items =>\n+                    Copy_Component_List (RTE (RE_RACW_Stub_Type), Loc))));\n \n       --  Does the stub type need to explicitly implement interfaces from the\n       --  designated type???\n@@ -2041,7 +2032,10 @@ package body Exp_Dist is\n \n       if Present (RPC_Receiver_Decl) then\n          Append_To (Decls, RPC_Receiver_Decl);\n+\n       else\n+         --  Kludge, requires comment???\n+\n          RPC_Receiver_Decl := Last (Decls);\n       end if;\n \n@@ -2399,7 +2393,6 @@ package body Exp_Dist is\n           Limited_Present => True,\n           Component_List  =>\n             Make_Component_List (Loc,\n-\n               Component_Items => New_List (\n                 Make_Component_Declaration (Loc,\n                   Defining_Identifier =>\n@@ -3874,7 +3867,7 @@ package body Exp_Dist is\n             --  Compute distribution identifier\n \n             Assign_Subprogram_Identifier\n-              (Subp_Def, Current_Subp_Number,  Subp_Val);\n+              (Subp_Def, Current_Subp_Number, Subp_Val);\n \n             pragma Assert (Current_Subp_Number = Get_Subprogram_Id (Subp_Def));\n \n@@ -4711,72 +4704,6 @@ package body Exp_Dist is\n          return Target_Info;\n       end Build_Stub_Target;\n \n-      ---------------------\n-      -- Build_Stub_Type --\n-      ---------------------\n-\n-      procedure Build_Stub_Type\n-        (RACW_Type         : Entity_Id;\n-         Stub_Type_Comps   : out List_Id;\n-         RPC_Receiver_Decl : out Node_Id)\n-      is\n-         Loc    : constant Source_Ptr := Sloc (RACW_Type);\n-         Is_RAS : constant Boolean    := not Comes_From_Source (RACW_Type);\n-\n-      begin\n-         Stub_Type_Comps := New_List (\n-           Make_Component_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_Origin),\n-             Component_Definition =>\n-               Make_Component_Definition (Loc,\n-                 Aliased_Present    => False,\n-                 Subtype_Indication =>\n-                   New_Occurrence_Of (RTE (RE_Partition_ID), Loc))),\n-\n-           Make_Component_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_Receiver),\n-             Component_Definition =>\n-               Make_Component_Definition (Loc,\n-                 Aliased_Present    => False,\n-                 Subtype_Indication =>\n-                   New_Occurrence_Of (RTE (RE_Unsigned_64), Loc))),\n-\n-           Make_Component_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_Addr),\n-             Component_Definition =>\n-               Make_Component_Definition (Loc,\n-                 Aliased_Present    => False,\n-                 Subtype_Indication =>\n-                   New_Occurrence_Of (RTE (RE_Unsigned_64), Loc))),\n-\n-           Make_Component_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_Asynchronous),\n-             Component_Definition =>\n-               Make_Component_Definition (Loc,\n-                 Aliased_Present    => False,\n-                 Subtype_Indication =>\n-                   New_Occurrence_Of (Standard_Boolean, Loc))));\n-\n-         if Is_RAS then\n-            RPC_Receiver_Decl := Empty;\n-         else\n-            declare\n-               RPC_Receiver_Request : constant Entity_Id :=\n-                                        Make_Defining_Identifier (Loc, Name_R);\n-            begin\n-               RPC_Receiver_Decl :=\n-                 Make_Subprogram_Declaration (Loc,\n-                   Build_RPC_Receiver_Specification\n-                     (RPC_Receiver      => Make_Temporary (Loc, 'R'),\n-                      Request_Parameter => RPC_Receiver_Request));\n-            end;\n-         end if;\n-      end Build_Stub_Type;\n-\n       --------------------------------------\n       -- Build_Subprogram_Receiving_Stubs --\n       --------------------------------------\n@@ -5253,6 +5180,28 @@ package body Exp_Dist is\n          return Make_Identifier (Loc, Name_V);\n       end Result;\n \n+      -----------------------\n+      -- RPC_Receiver_Decl --\n+      -----------------------\n+\n+      function RPC_Receiver_Decl (RACW_Type : Entity_Id) return Node_Id is\n+         Loc    : constant Source_Ptr := Sloc (RACW_Type);\n+         Is_RAS : constant Boolean    := not Comes_From_Source (RACW_Type);\n+\n+      begin\n+         --  No RPC receiver for remote access-to-subprogram\n+\n+         if Is_RAS then\n+            return Empty;\n+         end if;\n+\n+         return\n+           Make_Subprogram_Declaration (Loc,\n+             Build_RPC_Receiver_Specification\n+               (RPC_Receiver      => Make_Temporary (Loc, 'R'),\n+                Request_Parameter => Make_Defining_Identifier (Loc, Name_R)));\n+      end RPC_Receiver_Decl;\n+\n       ----------------------\n       -- Stream_Parameter --\n       ----------------------\n@@ -7659,46 +7608,6 @@ package body Exp_Dist is\n          return Target_Info;\n       end Build_Stub_Target;\n \n-      ---------------------\n-      -- Build_Stub_Type --\n-      ---------------------\n-\n-      procedure Build_Stub_Type\n-        (RACW_Type         : Entity_Id;\n-         Stub_Type_Comps   : out List_Id;\n-         RPC_Receiver_Decl : out Node_Id)\n-      is\n-         Loc : constant Source_Ptr := Sloc (RACW_Type);\n-\n-      begin\n-         Stub_Type_Comps := New_List (\n-           Make_Component_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_Target),\n-             Component_Definition =>\n-               Make_Component_Definition (Loc,\n-                 Aliased_Present     => False,\n-                 Subtype_Indication  =>\n-                   New_Occurrence_Of (RTE (RE_Entity_Ptr), Loc))),\n-\n-           Make_Component_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_Asynchronous),\n-\n-             Component_Definition =>\n-               Make_Component_Definition (Loc,\n-                 Aliased_Present    => False,\n-                 Subtype_Indication =>\n-                   New_Occurrence_Of (Standard_Boolean, Loc))));\n-\n-         RPC_Receiver_Decl :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Make_Temporary (Loc, 'R'),\n-             Aliased_Present     => True,\n-             Object_Definition   =>\n-               New_Occurrence_Of (RTE (RE_Servant), Loc));\n-      end Build_Stub_Type;\n-\n       -----------------------------\n       -- Build_RPC_Receiver_Body --\n       -----------------------------\n@@ -11160,6 +11069,21 @@ package body Exp_Dist is\n          Overload_Counter_Table.Set (Name_Find, 1);\n       end Reserve_NamingContext_Methods;\n \n+      -----------------------\n+      -- RPC_Receiver_Decl --\n+      -----------------------\n+\n+      function RPC_Receiver_Decl (RACW_Type : Entity_Id) return Node_Id is\n+         Loc : constant Source_Ptr := Sloc (RACW_Type);\n+\n+      begin\n+         return\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Make_Temporary (Loc, 'R'),\n+             Aliased_Present     => True,\n+             Object_Definition   => New_Occurrence_Of (RTE (RE_Servant), Loc));\n+      end RPC_Receiver_Decl;\n+\n    end PolyORB_Support;\n \n    -------------------------------\n@@ -11514,26 +11438,22 @@ package body Exp_Dist is\n       end case;\n    end Specific_Build_Stub_Target;\n \n-   ------------------------------\n-   -- Specific_Build_Stub_Type --\n-   ------------------------------\n+   --------------------------------\n+   -- Specific_RPC_Receiver_Decl --\n+   --------------------------------\n \n-   procedure Specific_Build_Stub_Type\n-     (RACW_Type         : Entity_Id;\n-      Stub_Type_Comps   : out List_Id;\n-      RPC_Receiver_Decl : out Node_Id)\n+   function Specific_RPC_Receiver_Decl\n+     (RACW_Type : Entity_Id) return Node_Id\n    is\n    begin\n       case Get_PCS_Name is\n          when Name_PolyORB_DSA =>\n-            PolyORB_Support.Build_Stub_Type\n-              (RACW_Type, Stub_Type_Comps, RPC_Receiver_Decl);\n+            return PolyORB_Support.RPC_Receiver_Decl (RACW_Type);\n \n          when others =>\n-            GARLIC_Support.Build_Stub_Type\n-              (RACW_Type, Stub_Type_Comps, RPC_Receiver_Decl);\n+            return GARLIC_Support.RPC_Receiver_Decl (RACW_Type);\n       end case;\n-   end Specific_Build_Stub_Type;\n+   end Specific_RPC_Receiver_Decl;\n \n    -----------------------------------------------\n    -- Specific_Build_Subprogram_Receiving_Stubs --"}, {"sha": "e807864889286bb58d920f5fb20c48e669d503bf", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -361,10 +361,13 @@ package body Freeze is\n \n       --  For simple renamings, subsequent calls can be expanded directly as\n       --  calls to the renamed entity. The body must be generated in any case\n-      --  for calls that may appear elsewhere.\n+      --  for calls that may appear elsewhere. This is not done in the case\n+      --  where the subprogram is an instantiation because the actual proper\n+      --  body has not been built yet.\n \n       if Ekind_In (Old_S, E_Function, E_Procedure)\n         and then Nkind (Decl) = N_Subprogram_Declaration\n+        and then not Is_Generic_Instance (Old_S)\n       then\n          Set_Body_To_Inline (Decl, Old_S);\n       end if;"}, {"sha": "7e9ff7d8b7e61bfc675f15009f9a9e0ce33a5643", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -1014,7 +1014,8 @@ by any part of the GNAT compiler, except to generate corresponding note\n lines in the generated ALI file. For the format of these note lines, see\n the compiler source file lib-writ.ads. This pragma is intended for use by\n external tools, including ASIS@. The use of pragma Annotate does not\n-affect the compilation process in any way.\n+affect the compilation process in any way. This pragma may be used as\n+a configuration pragma.\n \n @node Pragma Assert\n @unnumberedsec Pragma Assert"}, {"sha": "6d9138c7505141ee74d22ae0121c0ed7306cdd95", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -5735,7 +5735,7 @@ as shown in the following example.\n This switch activates warnings for use of @code{pragma Warnings (Off, entity)}\n where either the pragma is entirely useless (because it suppresses no\n warnings), or it could be replaced by @code{pragma Unreferenced} or\n-@code{pragma Unmodified}.The default is that these warnings are not given.\n+@code{pragma Unmodified}. The default is that these warnings are not given.\n Note that this warning is not included in -gnatwa, it must be\n activated explicitly.\n \n@@ -11591,6 +11591,7 @@ recognized by GNAT:\n    Ada_2005\n    Ada_12\n    Ada_2012\n+   Annotate\n    Assertion_Policy\n    Assume_No_Invalid_Values\n    C_Pass_By_Copy\n@@ -17578,7 +17579,7 @@ Same as @option{^-gnatyM^/MAX_LINE_LENGTH=^@var{n}}\n \n @item ^--no-exception^/NO_EXCEPTION^\n @cindex @option{^--no-exception^/NO_EXCEPTION^} (@command{gnatstub})\n-void raising PROGRAM_ERROR in the generated bodies of program unit stubs.\n+Avoid raising PROGRAM_ERROR in the generated bodies of program unit stubs.\n This is not always possible for function stubs.\n \n @item ^--no-local-header^/NO_LOCAL_HEADER^"}, {"sha": "35cfdfca8a1ee64df0bc064457afd4ff3a68c500", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -1010,8 +1010,17 @@ package body Lib.Xref is\n          if Alfa_Mode then\n             Ref_Scope := Alfa.Enclosing_Subprogram_Or_Package (N);\n             Ent_Scope := Alfa.Enclosing_Subprogram_Or_Package (Ent);\n-            Ent_Scope_File := Get_Source_Unit (Ent_Scope);\n \n+            --  Since we are reaching through renamings in Alfa mode, we may\n+            --  end up with standard constants. Ignore those.\n+\n+            if Sloc (Ent_Scope) <= Standard_Location\n+              or else Def <= Standard_Location\n+            then\n+               return;\n+            end if;\n+\n+            Ent_Scope_File := Get_Source_Unit (Ent_Scope);\n          else\n             Ref_Scope := Empty;\n             Ent_Scope := Empty;"}, {"sha": "ddbede2bf049fb999cb38b1fbfe573052c65b3d7", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -1163,6 +1163,7 @@ package Rtsfind is\n      RE_Get_RACW,                        -- System.Partition_Interface\n      RE_Get_RCI_Package_Receiver,        -- System.Partition_Interface\n      RE_Get_Unique_Remote_Pointer,       -- System.Partition_Interface\n+     RE_RACW_Stub_Type,                  -- System.Partition_Interface\n      RE_RACW_Stub_Type_Access,           -- System.Partition_Interface\n      RE_RAS_Proxy_Type_Access,           -- System.Partition_Interface\n      RE_Raise_Program_Error_Unknown_Tag, -- System.Partition_Interface\n@@ -2357,6 +2358,7 @@ package Rtsfind is\n      RE_Get_RACW                         => System_Partition_Interface,\n      RE_Get_RCI_Package_Receiver         => System_Partition_Interface,\n      RE_Get_Unique_Remote_Pointer        => System_Partition_Interface,\n+     RE_RACW_Stub_Type                   => System_Partition_Interface,\n      RE_RACW_Stub_Type_Access            => System_Partition_Interface,\n      RE_RAS_Proxy_Type_Access            => System_Partition_Interface,\n      RE_Raise_Program_Error_Unknown_Tag  => System_Partition_Interface,"}, {"sha": "2bd15a8b211abc3e6b910bcd771c6b8629f32108", "filename": "gcc/ada/s-osinte-darwin.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fs-osinte-darwin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fs-osinte-darwin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-darwin.ads?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -108,7 +108,7 @@ package System.OS_Interface is\n    SIGUSR1    : constant := 30; --  user defined signal 1\n    SIGUSR2    : constant := 31; --  user defined signal 2\n \n-   SIGADAABORT : constant := SIGTERM;\n+   SIGADAABORT : constant := SIGABRT;\n    --  Change this if you want to use another signal for task abort.\n    --  SIGTERM might be a good one.\n "}, {"sha": "dbf3896bdb397e16399fe3d560c2e3ec544f1c2e", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -4454,9 +4454,20 @@ package body Sem_Ch12 is\n          Set_Contract (Anon_Id, Make_Contract (Sloc (Anon_Id))); -- ??? needed?\n          Set_Contract (Act_Decl_Id, Make_Contract (Sloc (Act_Decl_Id)));\n \n+         --  Inherit all inlining-related flags which apply to the generic in\n+         --  the subprogram and its declaration.\n+\n          Set_Is_Inlined (Act_Decl_Id, Is_Inlined (Gen_Unit));\n          Set_Is_Inlined (Anon_Id,     Is_Inlined (Gen_Unit));\n \n+         Set_Has_Pragma_Inline (Act_Decl_Id, Has_Pragma_Inline (Gen_Unit));\n+         Set_Has_Pragma_Inline (Anon_Id,     Has_Pragma_Inline (Gen_Unit));\n+\n+         Set_Has_Pragma_Inline_Always\n+           (Act_Decl_Id, Has_Pragma_Inline_Always (Gen_Unit));\n+         Set_Has_Pragma_Inline_Always\n+           (Anon_Id,     Has_Pragma_Inline_Always (Gen_Unit));\n+\n          if not Is_Intrinsic_Subprogram (Gen_Unit) then\n             Check_Elab_Instantiation (N);\n          end if;"}, {"sha": "fdd4b1fbc6703af09235f9c9ae310f4b71b618a6", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -2302,10 +2302,12 @@ package body Sem_Ch5 is\n       Typ : Entity_Id;\n \n    begin\n-      --  In semantics mode, introduce loop variable so that loop body can be\n-      --  properly analyzed. Otherwise this is one after expansion.\n+      --  In semantics and Alfa modes, introduce loop variable so that loop\n+      --  body can be properly analyzed. Otherwise this is one after expansion.\n \n-      if Operating_Mode = Check_Semantics then\n+      if Operating_Mode = Check_Semantics\n+        or else Alfa_Mode\n+      then\n          Enter_Name (Def_Id);\n       end if;\n "}, {"sha": "26d90af4dd6ebb78cf72b3a8bafe2671892811c0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -2264,6 +2264,39 @@ package body Sem_Util is\n       end if;\n    end Conditional_Delay;\n \n+   -------------------------\n+   -- Copy_Component_List --\n+   -------------------------\n+\n+   function Copy_Component_List\n+     (R_Typ : Entity_Id;\n+      Loc   : Source_Ptr) return List_Id\n+   is\n+      Comp  : Node_Id;\n+      Comps : constant List_Id := New_List;\n+   begin\n+      Comp := First_Component (Underlying_Type (R_Typ));\n+\n+      while Present (Comp) loop\n+         if Comes_From_Source (Comp) then\n+            declare\n+               Comp_Decl : constant Node_Id := Declaration_Node (Comp);\n+            begin\n+               Append_To (Comps,\n+                 Make_Component_Declaration (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Loc, Chars (Comp)),\n+                   Component_Definition =>\n+                     New_Copy_Tree\n+                       (Component_Definition (Comp_Decl), New_Sloc => Loc)));\n+            end;\n+         end if;\n+         Next_Component (Comp);\n+      end loop;\n+\n+      return Comps;\n+   end Copy_Component_List;\n+\n    -------------------------\n    -- Copy_Parameter_List --\n    -------------------------"}, {"sha": "77f26b40e8be7c06f0e51f165435599e4255c3f2", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -272,6 +272,13 @@ package Sem_Util is\n    --  of inlining, and for private protected ops. Also used to create bodies\n    --  for stubbed subprograms.\n \n+   function Copy_Component_List\n+     (R_Typ : Entity_Id;\n+      Loc   : Source_Ptr) return List_Id;\n+   --  Copy components from record type R_Typ that come from source. Used to\n+   --  create a new compatible record type. Loc is the source location assigned\n+   --  to the created nodes.\n+\n    function Current_Entity (N : Node_Id) return Entity_Id;\n    pragma Inline (Current_Entity);\n    --  Find the currently visible definition for a given identifier, that is to"}, {"sha": "5f321db7f391d77cdb88f328d97391bb11aa152a", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=a3068ca6e7d3cb9e7bf5db0279ad6ca814bd6e28", "patch": "@@ -347,6 +347,7 @@ package Snames is\n    Name_Ada_2005                       : constant Name_Id := N + $; -- GNAT\n    Name_Ada_12                         : constant Name_Id := N + $; -- GNAT\n    Name_Ada_2012                       : constant Name_Id := N + $; -- GNAT\n+   Name_Annotate                       : constant Name_Id := N + $; -- GNAT\n    Name_Assertion_Policy               : constant Name_Id := N + $; -- Ada 05\n    Name_Assume_No_Invalid_Values       : constant Name_Id := N + $; -- GNAT\n    Name_C_Pass_By_Copy                 : constant Name_Id := N + $; -- GNAT\n@@ -418,7 +419,6 @@ package Snames is\n \n    Name_Abort_Defer                    : constant Name_Id := N + $; -- GNAT\n    Name_All_Calls_Remote               : constant Name_Id := N + $;\n-   Name_Annotate                       : constant Name_Id := N + $; -- GNAT\n \n    --  Note: AST_Entry is not in this list because its name matches -- VMS\n    --  the name of the corresponding attribute. However, it is\n@@ -1520,6 +1520,7 @@ package Snames is\n       Pragma_Ada_2005,\n       Pragma_Ada_12,\n       Pragma_Ada_2012,\n+      Pragma_Annotate,\n       Pragma_Assertion_Policy,\n       Pragma_Assume_No_Invalid_Values,\n       Pragma_C_Pass_By_Copy,\n@@ -1583,7 +1584,6 @@ package Snames is\n \n       Pragma_Abort_Defer,\n       Pragma_All_Calls_Remote,\n-      Pragma_Annotate,\n       Pragma_Assert,\n       Pragma_Asynchronous,\n       Pragma_Atomic,"}]}