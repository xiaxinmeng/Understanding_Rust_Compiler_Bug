{"sha": "0289a8d7ef1288cc9b2be36b3080981c9fac839e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI4OWE4ZDdlZjEyODhjYzliMmJlMzZiMzA4MDk4MWM5ZmFjODM5ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-12T14:42:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-12T14:42:42Z"}, "message": "[multiple changes]\n\n2017-01-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute_Reference, case Loop_Entry):\n\tHnadle properly the attribute reference when it appears as part\n\tof an expression in another loop aspect.\n\n2017-01-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch3.adb (Check_Predicated_Discriminant): New procedure,\n\tsubsidiary of Build_Initialization_Call, to complete generation\n\tof predicate checks on discriminants whose (sub)types have\n\tpredicates, and to add checks on variants that do not have an\n\tothers clause.\n\t* sem_util.adb (Gather_Components): A missing Others alternative is\n\tnot an error when the type of the discriminant is a static predicate\n\t(and coverage has been checked when analyzing the case statement). A\n\truntime check is generated to verify that a given discriminant\n\tsatisfies the predicate (RM 3.8.1. (21.1/2)).\n\n2017-01-12  Yannick Moy  <moy@adacore.com>\n\n\t* gnat1drv.adb (Adjust_Global_Switches): Only\n\tperform checking of exception mechanism when generating code.\n\n2017-01-12  Justin Squirek  <squirek@adacore.com>\n\n\t* exp_ch7.adb (Add_Type_Invariants, Process_Array_Component):\n\tRemove handling of access component with invariant.\n\t(Build_Invariant_Procedure_Declaration): Remove return on class\n\twide type.\n\t* freeze.adb (Freeze_Array_Type, Freeze_Record_Type): Remove\n\tconditional exception for component or array so Has_Own_Invariants\n\tflag is not falsly set.\n\t* sem_ch3.adb (Make_Class_Wide_Type): Initialize copy of class\n\twide type to have no invariant flags.\n\nFrom-SVN: r244366", "tree": {"sha": "a42b6be679d4996088b2a19352ff0f10c6e31a63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a42b6be679d4996088b2a19352ff0f10c6e31a63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0289a8d7ef1288cc9b2be36b3080981c9fac839e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0289a8d7ef1288cc9b2be36b3080981c9fac839e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0289a8d7ef1288cc9b2be36b3080981c9fac839e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0289a8d7ef1288cc9b2be36b3080981c9fac839e/comments", "author": null, "committer": null, "parents": [{"sha": "2168d7cc3ba6f3b2280bfefcc8a789ea4d8d90a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2168d7cc3ba6f3b2280bfefcc8a789ea4d8d90a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2168d7cc3ba6f3b2280bfefcc8a789ea4d8d90a5"}], "stats": {"total": 393, "additions": 218, "deletions": 175}, "files": [{"sha": "7d56374a0950481efcff613bfaa32cb75f30c6fc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0289a8d7ef1288cc9b2be36b3080981c9fac839e", "patch": "@@ -1,3 +1,39 @@\n+2017-01-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute_Reference, case Loop_Entry):\n+\tHnadle properly the attribute reference when it appears as part\n+\tof an expression in another loop aspect.\n+\n+2017-01-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch3.adb (Check_Predicated_Discriminant): New procedure,\n+\tsubsidiary of Build_Initialization_Call, to complete generation\n+\tof predicate checks on discriminants whose (sub)types have\n+\tpredicates, and to add checks on variants that do not have an\n+\tothers clause.\n+\t* sem_util.adb (Gather_Components): A missing Others alternative is\n+\tnot an error when the type of the discriminant is a static predicate\n+\t(and coverage has been checked when analyzing the case statement). A\n+\truntime check is generated to verify that a given discriminant\n+\tsatisfies the predicate (RM 3.8.1. (21.1/2)).\n+\n+2017-01-12  Yannick Moy  <moy@adacore.com>\n+\n+\t* gnat1drv.adb (Adjust_Global_Switches): Only\n+\tperform checking of exception mechanism when generating code.\n+\n+2017-01-12  Justin Squirek  <squirek@adacore.com>\n+\n+\t* exp_ch7.adb (Add_Type_Invariants, Process_Array_Component):\n+\tRemove handling of access component with invariant.\n+\t(Build_Invariant_Procedure_Declaration): Remove return on class\n+\twide type.\n+\t* freeze.adb (Freeze_Array_Type, Freeze_Record_Type): Remove\n+\tconditional exception for component or array so Has_Own_Invariants\n+\tflag is not falsly set.\n+\t* sem_ch3.adb (Make_Class_Wide_Type): Initialize copy of class\n+\twide type to have no invariant flags.\n+\n 2017-01-12  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch9.adb, sem_prag.adb, s-tassta.adb, sem_util.adb, s-tarest.adb,"}, {"sha": "c1039c5b53fa92017b9b8f568324d09ab3964a46", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 117, "deletions": 9, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=0289a8d7ef1288cc9b2be36b3080981c9fac839e", "patch": "@@ -1286,19 +1286,131 @@ package body Exp_Ch3 is\n       With_Default_Init : Boolean := False;\n       Constructor_Ref   : Node_Id := Empty) return List_Id\n    is\n-      Res            : constant List_Id := New_List;\n+      Res : constant List_Id := New_List;\n+\n+      Full_Type : Entity_Id;\n+\n+      procedure Check_Predicated_Discriminant\n+        (Val   : Node_Id;\n+         Discr : Entity_Id);\n+      --  Discriminants whose subtypes have predicates are checked in two\n+      --  cases:\n+      --    a) When an object is default-initialized and assertions are enabled\n+      --       we check that the value of the discriminant obeys the predicate.\n+\n+      --    b) In all cases, if the discriminant controls a variant and the\n+      --       variant has no others_choice, Constraint_Error must be raised if\n+      --       the predicate is violated, because there is no variant covered\n+      --       by the illegal discriminant value.\n+\n+      -----------------------------------\n+      -- Check_Predicated_Discriminant --\n+      -----------------------------------\n+\n+      procedure Check_Predicated_Discriminant\n+        (Val   : Node_Id;\n+         Discr : Entity_Id)\n+      is\n+         Typ : constant Entity_Id := Etype (Discr);\n+\n+         procedure Check_Missing_Others (V : Node_Id);\n+         --  ???\n+\n+         --------------------------\n+         -- Check_Missing_Others --\n+         --------------------------\n+\n+         procedure Check_Missing_Others (V : Node_Id) is\n+            Alt      : Node_Id;\n+            Choice   : Node_Id;\n+            Last_Var : Node_Id;\n+\n+         begin\n+            Last_Var := Last_Non_Pragma (Variants (V));\n+            Choice   := First (Discrete_Choices (Last_Var));\n+\n+            --  An others_choice is added during expansion for gcc use, but\n+            --  does not cover the illegality.\n+\n+            if Entity (Name (V)) = Discr then\n+               if Present (Choice)\n+                 and then (Nkind (Choice) /= N_Others_Choice\n+                            or else not Comes_From_Source (Choice))\n+               then\n+                  Check_Expression_Against_Static_Predicate (Val, Typ);\n+\n+                  if not Is_Static_Expression (Val) then\n+                     Prepend_To (Res,\n+                        Make_Raise_Constraint_Error (Loc,\n+                          Condition =>\n+                            Make_Op_Not (Loc,\n+                              Right_Opnd => Make_Predicate_Call (Typ, Val)),\n+                          Reason    => CE_Invalid_Data));\n+                  end if;\n+               end if;\n+            end if;\n+\n+            --  Check whether some nested variant is ruled by the predicated\n+            --  discriminant.\n+\n+            Alt := First (Variants (V));\n+            while Present (Alt) loop\n+               if Nkind (Alt) = N_Variant\n+                 and then Present (Variant_Part (Component_List (Alt)))\n+               then\n+                  Check_Missing_Others\n+                    (Variant_Part (Component_List (Alt)));\n+               end if;\n+\n+               Next (Alt);\n+            end loop;\n+         end Check_Missing_Others;\n+\n+         --  Local variables\n+\n+         Def : Node_Id;\n+\n+      --  Start of processing for Check_Predicated_Discriminant\n+\n+      begin\n+         if Ekind (Base_Type (Full_Type)) = E_Record_Type then\n+            Def := Type_Definition (Parent (Base_Type (Full_Type)));\n+         else\n+            return;\n+         end if;\n+\n+         if Policy_In_Effect (Name_Assert) = Name_Check\n+           and then not Predicates_Ignored (Etype (Discr))\n+         then\n+            Prepend_To (Res, Make_Predicate_Check (Typ, Val));\n+         end if;\n+\n+         --  If discriminant controls a variant, verify that predicate is\n+         --  obeyed or else an Others_Choice is present.\n+\n+         if Nkind (Def) = N_Record_Definition\n+           and then Present (Variant_Part (Component_List (Def)))\n+           and then Policy_In_Effect (Name_Assert) = Name_Ignore\n+         then\n+            Check_Missing_Others (Variant_Part (Component_List (Def)));\n+         end if;\n+      end Check_Predicated_Discriminant;\n+\n+      --  Local variables\n+\n       Arg            : Node_Id;\n       Args           : List_Id;\n       Decls          : List_Id;\n       Decl           : Node_Id;\n       Discr          : Entity_Id;\n       First_Arg      : Node_Id;\n       Full_Init_Type : Entity_Id;\n-      Full_Type      : Entity_Id;\n       Init_Call      : Node_Id;\n       Init_Type      : Entity_Id;\n       Proc           : Entity_Id;\n \n+   --  Start of processing for Build_Initialization_Call\n+\n    begin\n       pragma Assert (Constructor_Ref = Empty\n         or else Is_CPP_Constructor_Call (Constructor_Ref));\n@@ -1490,14 +1602,10 @@ package body Exp_Ch3 is\n                   --  of the discriminant, insert it ahead of the call.\n \n                   Arg := New_Copy_Tree (Arg, New_Sloc => Loc);\n+               end if;\n \n-                  if Has_Predicates (Etype (Discr))\n-                    and then not Predicate_Checks_Suppressed (Empty)\n-                    and then not Predicates_Ignored (Etype (Discr))\n-                  then\n-                     Prepend_To (Res,\n-                       Make_Predicate_Check (Etype (Discr), Arg));\n-                  end if;\n+               if Has_Predicates (Etype (Discr)) then\n+                  Check_Predicated_Discriminant (Arg, Discr);\n                end if;\n             end if;\n "}, {"sha": "9c5cb468c2c2e60d63c7cea868a051aec99c1251", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 2, "deletions": 125, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=0289a8d7ef1288cc9b2be36b3080981c9fac839e", "patch": "@@ -3605,60 +3605,6 @@ package body Exp_Ch7 is\n \n                Produced_Check := True;\n             end if;\n-\n-            --  In a rare case the designated type of an access component may\n-            --  have an invariant. In this case verify the dereference of the\n-            --  component.\n-\n-            if Is_Access_Type (Comp_Typ)\n-              and then Has_Invariants (Designated_Type (Comp_Typ))\n-            then\n-               Proc_Id :=\n-                 Invariant_Procedure (Base_Type (Designated_Type (Comp_Typ)));\n-\n-               --  The designated type should have an invariant procedure if it\n-               --  has invariants of its own or inherits class-wide invariants\n-               --  from parent or interface types.\n-\n-               pragma Assert (Present (Proc_Id));\n-\n-               --  Generate:\n-               --    if _object (<Indexes>) /= null then\n-               --       <Desig_Comp_Typ>Invariant (_object (<Indices>).all);\n-               --    end if;\n-\n-               --  Note that the invariant procedure may have a null body if\n-               --  assertions are disabled or Assertion_Polity Ignore is in\n-               --  effect.\n-\n-               if not Has_Null_Body (Proc_Id) then\n-                  Append_New_To (Comp_Checks,\n-                    Make_If_Statement (Loc,\n-                      Condition       =>\n-                        Make_Op_Ne (Loc,\n-                          Left_Opnd  =>\n-                            Make_Indexed_Component (Loc,\n-                              Prefix      => New_Occurrence_Of (Obj_Id, Loc),\n-                              Expressions => New_Copy_List (Indices)),\n-                          Right_Opnd => Make_Null (Loc)),\n-\n-                      Then_Statements => New_List (\n-                        Make_Procedure_Call_Statement (Loc,\n-                          Name                   =>\n-                            New_Occurrence_Of (Proc_Id, Loc),\n-\n-                          Parameter_Associations => New_List (\n-                            Make_Explicit_Dereference (Loc,\n-                              Prefix =>\n-                                Make_Indexed_Component (Loc,\n-                                  Prefix      =>\n-                                    New_Occurrence_Of (Obj_Id, Loc),\n-                                  Expressions =>\n-                                    New_Copy_List (Indices))))))));\n-               end if;\n-\n-               Produced_Check := True;\n-            end if;\n          end Process_Array_Component;\n \n          ---------------------------\n@@ -4001,65 +3947,6 @@ package body Exp_Ch7 is\n                Produced_Component_Check := True;\n             end if;\n \n-            --  In a rare case the designated type of an access component may\n-            --  have a invariant. In this case verify the dereference of the\n-            --  component.\n-\n-            if Is_Access_Type (Comp_Typ)\n-              and then Has_Invariants (Designated_Type (Comp_Typ))\n-            then\n-               Proc_Id :=\n-                 Invariant_Procedure (Base_Type (Designated_Type (Comp_Typ)));\n-\n-               --  The designated type should have an invariant procedure if it\n-               --  has invariants of its own or inherits class-wide invariants\n-               --  from parent or interface types.\n-\n-               pragma Assert (Present (Proc_Id));\n-\n-               --  Generate:\n-               --    if T (_object).<Comp_Id> /= null then\n-               --       <Desig_Comp_Typ>Invariant (T (_object).<Comp_Id>.all);\n-               --    end if;\n-\n-               --  Note that the invariant procedure may have a null body if\n-               --  assertions are disabled or Assertion_Polity Ignore is in\n-               --  effect.\n-\n-               if not Has_Null_Body (Proc_Id) then\n-                  Append_New_To (Comp_Checks,\n-                    Make_If_Statement (Loc,\n-                      Condition       =>\n-                        Make_Op_Ne (Loc,\n-                          Left_Opnd  =>\n-                            Make_Selected_Component (Loc,\n-                              Prefix        =>\n-                                Unchecked_Convert_To\n-                                  (T, New_Occurrence_Of (Obj_Id, Loc)),\n-                              Selector_Name =>\n-                                New_Occurrence_Of (Comp_Id, Loc)),\n-                          Right_Opnd => Make_Null (Loc)),\n-\n-                      Then_Statements => New_List (\n-                        Make_Procedure_Call_Statement (Loc,\n-                          Name                   =>\n-                            New_Occurrence_Of (Proc_Id, Loc),\n-\n-                          Parameter_Associations => New_List (\n-                            Make_Explicit_Dereference (Loc,\n-                              Prefix =>\n-                                Make_Selected_Component (Loc,\n-                                  Prefix        =>\n-                                    Unchecked_Convert_To\n-                                      (T, New_Occurrence_Of (Obj_Id, Loc)),\n-                                  Selector_Name =>\n-                                    New_Occurrence_Of (Comp_Id, Loc))))))));\n-               end if;\n-\n-               Produced_Check           := True;\n-               Produced_Component_Check := True;\n-            end if;\n-\n             if Produced_Component_Check and then Has_Unchecked_Union (T) then\n                Error_Msg_NE\n                  (\"invariants cannot be checked on components of \"\n@@ -4525,15 +4412,10 @@ package body Exp_Ch7 is\n \n       pragma Assert (Has_Invariants (Work_Typ));\n \n-      --  ??? invariants of class-wide types are not properly implemented\n-\n-      if Is_Class_Wide_Type (Work_Typ) then\n-         return;\n-\n       --  Nothing to do for interface types as their class-wide invariants are\n       --  inherited by implementing types.\n \n-      elsif Is_Interface (Work_Typ) then\n+      if Is_Interface (Work_Typ) then\n          return;\n       end if;\n \n@@ -4849,15 +4731,10 @@ package body Exp_Ch7 is\n \n       pragma Assert (Has_Invariants (Work_Typ));\n \n-      --  ??? invariants of class-wide types are not properly implemented\n-\n-      if Is_Class_Wide_Type (Work_Typ) then\n-         return;\n-\n       --  Nothing to do for interface types as their class-wide invariants are\n       --  inherited by implementing types.\n \n-      elsif Is_Interface (Work_Typ) then\n+      if Is_Interface (Work_Typ) then\n          return;\n \n       --  Nothing to do if the type already has a \"partial\" invariant procedure"}, {"sha": "6c90bd39537a09bdc706d2c2b4ff26823b74c957", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=0289a8d7ef1288cc9b2be36b3080981c9fac839e", "patch": "@@ -2377,12 +2377,7 @@ package body Freeze is\n             --  The array type requires its own invariant procedure in order to\n             --  verify the component invariant over all elements.\n \n-            if Has_Invariants (Component_Type (Arr))\n-              or else\n-                (Is_Access_Type (Component_Type (Arr))\n-                  and then Has_Invariants\n-                             (Designated_Type (Component_Type (Arr))))\n-            then\n+            if Has_Invariants (Component_Type (Arr)) then\n                Set_Has_Own_Invariants (Arr);\n \n                --  The array type is an implementation base type. Propagate the\n@@ -4305,12 +4300,7 @@ package body Freeze is\n                --  parent class-wide invariants are always inherited.\n \n                if Comes_From_Source (Comp)\n-                 and then\n-                   (Has_Invariants (Etype (Comp))\n-                     or else\n-                       (Is_Access_Type (Etype (Comp))\n-                         and then Has_Invariants\n-                                    (Designated_Type (Etype (Comp)))))\n+                 and then Has_Invariants (Etype (Comp))\n                then\n                   Set_Has_Own_Invariants (Rec);\n                end if;"}, {"sha": "8582b93277e0fa0baef7f4522375d9be469c95fe", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=0289a8d7ef1288cc9b2be36b3080981c9fac839e", "patch": "@@ -521,28 +521,35 @@ procedure Gnat1drv is\n          Targparm.Frontend_Layout_On_Target := True;\n       end if;\n \n-      --  Set and check exception mechanism\n-\n-      case Targparm.Frontend_Exceptions_On_Target is\n-         when True =>\n-            case Targparm.ZCX_By_Default_On_Target is\n-               when True =>\n-                  Write_Line\n-                    (\"Run-time library configured incorrectly\");\n-                  Write_Line\n-                    (\"(requesting support for Frontend ZCX exceptions)\");\n-                  raise Unrecoverable_Error;\n-               when False =>\n-                  Exception_Mechanism := Front_End_SJLJ;\n-            end case;\n-         when False =>\n-            case Targparm.ZCX_By_Default_On_Target is\n-               when True =>\n-                  Exception_Mechanism := Back_End_ZCX;\n-               when False =>\n-                  Exception_Mechanism := Back_End_SJLJ;\n-            end case;\n-      end case;\n+      --  Set and check exception mechanism. This is only meaningful when\n+      --  compiling, and in particular not meaningful for special modes used\n+      --  for program analysis rather than compilation: ASIS mode, CodePeer\n+      --  mode and GNATprove mode.\n+\n+      if Operating_Mode = Generate_Code\n+        and then not (ASIS_Mode or CodePeer_Mode or GNATprove_Mode)\n+      then\n+         case Targparm.Frontend_Exceptions_On_Target is\n+            when True =>\n+               case Targparm.ZCX_By_Default_On_Target is\n+                  when True =>\n+                     Write_Line\n+                       (\"Run-time library configured incorrectly\");\n+                     Write_Line\n+                       (\"(requesting support for Frontend ZCX exceptions)\");\n+                     raise Unrecoverable_Error;\n+                  when False =>\n+                     Exception_Mechanism := Front_End_SJLJ;\n+               end case;\n+            when False =>\n+               case Targparm.ZCX_By_Default_On_Target is\n+                  when True =>\n+                     Exception_Mechanism := Back_End_ZCX;\n+                  when False =>\n+                     Exception_Mechanism := Back_End_SJLJ;\n+               end case;\n+         end case;\n+      end if;\n \n       --  Set proper status for overflow check mechanism\n "}, {"sha": "494579ac9f8118b71aa18f9cd27113401534dcdc", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=0289a8d7ef1288cc9b2be36b3080981c9fac839e", "patch": "@@ -4465,7 +4465,17 @@ package body Sem_Attr is\n          --  purpose if they appear in an appropriate location in a loop,\n          --  which was already checked by the top level pragma circuit).\n \n-         if No (Enclosing_Pragma) then\n+         --  Loop_Entry also denotes a value and as such can appear within an\n+         --  expression that is an argument for another loop aspect. In that\n+         --  case it will have been expanded into the corresponding assignment.\n+\n+         if Expander_Active\n+           and then Nkind (Parent (N)) = N_Assignment_Statement\n+           and then not Comes_From_Source (Parent (N))\n+         then\n+            null;\n+\n+         elsif No (Enclosing_Pragma) then\n             Error_Attr (\"attribute% must appear within appropriate pragma\", N);\n          end if;\n \n@@ -4519,7 +4529,9 @@ package body Sem_Attr is\n          --  early transformation also avoids the generation of a useless loop\n          --  entry constant.\n \n-         if Is_Ignored (Enclosing_Pragma) then\n+         if Present (Enclosing_Pragma)\n+           and then Is_Ignored (Enclosing_Pragma)\n+         then\n             Rewrite (N, Relocate_Node (P));\n             Preanalyze_And_Resolve (N);\n \n@@ -11039,7 +11051,7 @@ package body Sem_Attr is\n \n             if Is_Entity_Name (P)\n              and then (Attr_Id = Attribute_Unrestricted_Access\n-                       or else Is_Subprogram (Entity (P)))\n+                        or else Is_Subprogram (Entity (P)))\n             then\n                Set_Address_Taken (Entity (P));\n             end if;"}, {"sha": "512615fe4b9858151c9fee69ee6def88222d0022", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=0289a8d7ef1288cc9b2be36b3080981c9fac839e", "patch": "@@ -18307,7 +18307,8 @@ package body Sem_Ch3 is\n       Set_Freeze_Node (CW_Type, Empty);\n \n       --  Customize the class-wide type: It has no prim. op., it cannot be\n-      --  abstract and its Etype points back to the specific root type.\n+      --  abstract, its Etype points back to the specific root type, and it\n+      --  cannot have any invariants.\n \n       Set_Ekind                       (CW_Type, E_Class_Wide_Type);\n       Set_Is_Tagged_Type              (CW_Type, True);\n@@ -18316,6 +18317,9 @@ package body Sem_Ch3 is\n       Set_Is_Constrained              (CW_Type, False);\n       Set_Is_First_Subtype            (CW_Type, Is_First_Subtype (T));\n       Set_Default_SSO                 (CW_Type);\n+      Set_Has_Inheritable_Invariants  (CW_Type, False);\n+      Set_Has_Inherited_Invariants    (CW_Type, False);\n+      Set_Has_Own_Invariants          (CW_Type, False);\n \n       if Ekind (T) = E_Class_Wide_Subtype then\n          Set_Etype (CW_Type, Etype (Base_Type (T)));"}, {"sha": "ead3efdd8dbcd283c82983141e35a8cd6fa63749", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0289a8d7ef1288cc9b2be36b3080981c9fac839e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=0289a8d7ef1288cc9b2be36b3080981c9fac839e", "patch": "@@ -7572,7 +7572,14 @@ package body Sem_Util is\n          end loop Find_Discrete_Value;\n       end Search_For_Discriminant_Value;\n \n-      if No (Variant) then\n+      --  The case statement must include a variant that corresponds to the\n+      --  value of the discriminant, unless the discriminant type has a\n+      --  static predicate. In that case the absence of an others_choice that\n+      --  would cover this value becomes a run-time error (3.8,1 (21.1/2)).\n+\n+      if No (Variant)\n+        and then not Has_Static_Predicate (Etype (Discrim_Name))\n+      then\n          Error_Msg_NE\n            (\"value of discriminant & is out of range\", Discrim_Value, Discrim);\n          Report_Errors := True;\n@@ -7583,8 +7590,10 @@ package body Sem_Util is\n       --  components to the Into list. The nested components are part of\n       --  the same record type.\n \n-      Gather_Components\n-        (Typ, Component_List (Variant), Governed_By, Into, Report_Errors);\n+      if Present (Variant) then\n+         Gather_Components\n+           (Typ, Component_List (Variant), Governed_By, Into, Report_Errors);\n+      end if;\n    end Gather_Components;\n \n    ------------------------"}]}