{"sha": "800dd123ee432ee01bbb515e30efccee505e39ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwZGQxMjNlZTQzMmVlMDFiYmI1MTVlMzBlZmNjZWU1MDVlMzlhYw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-09-06T22:06:29Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-09-06T22:06:29Z"}, "message": "tree-ssa-phiopt.c (conditional_replacement): Construct proper SSA form manually.\n\n\t* tree-ssa-phiopt.c (conditional_replacement): Construct proper SSA\n\tform manually.\n\t(abs_replacement): Likewise.\n\t(pass_phiopt): Remove TODO_update_ssa.\n\nFrom-SVN: r103970", "tree": {"sha": "1306afa9ce263f84803604908d3eda1d5c45b586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1306afa9ce263f84803604908d3eda1d5c45b586"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/800dd123ee432ee01bbb515e30efccee505e39ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/800dd123ee432ee01bbb515e30efccee505e39ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/800dd123ee432ee01bbb515e30efccee505e39ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/800dd123ee432ee01bbb515e30efccee505e39ac/comments", "author": null, "committer": null, "parents": [{"sha": "0c9b182b9f454fb2d5f57b17d22e860490c3c68f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9b182b9f454fb2d5f57b17d22e860490c3c68f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c9b182b9f454fb2d5f57b17d22e860490c3c68f"}], "stats": {"total": 75, "additions": 55, "deletions": 20}, "files": [{"sha": "c0eb165dfbbeb6b678934db6203d5dfd437cd5e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800dd123ee432ee01bbb515e30efccee505e39ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800dd123ee432ee01bbb515e30efccee505e39ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=800dd123ee432ee01bbb515e30efccee505e39ac", "patch": "@@ -1,10 +1,17 @@\n+2005-09-06  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* tree-ssa-phiopt.c (conditional_replacement): Construct proper SSA\n+\tform manually.\n+\t(abs_replacement): Likewise.\n+\t(pass_phiopt): Remove TODO_update_ssa.\n+\n 2005-09-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/23075\n \t* c-typeck.c (c_finish_return): Set TREE_NO_WARNING on RETURN_EXPR\n \tif \"return with no value, in function returning non-void\" warning\n \thas been issued.\n-  \t* tree-cfg.c (execute_warn_function_return): Don't look at\n+\t* tree-cfg.c (execute_warn_function_return): Don't look at\n \tRETURN_EXPRs with TREE_NO_WARNING set.\n \n \tPR target/22362\n@@ -14,7 +21,7 @@\n \tvariables.\n \n 2005-09-06  Olivier Hainque  <hainque@adacore.com>\n-            Eric Botcazou  <ebotcazou@adacore.com>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/14997\n \t* expr.c (expand_expr_real) <normal_inner_ref>: Force op0 to mem\n@@ -138,7 +145,7 @@\n \t    John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR middle-end/23671\n-\tpa.c (emit_move_sequence): Use replace_equiv_address instead of\n+\t* pa.c (emit_move_sequence): Use replace_equiv_address instead of\n \tgen_rtx_MEM.\n \n 2005-09-02  Nicolas Pitre <nico@cam.org>"}, {"sha": "277e733960999b2c6aea275204d81bfabc41180f", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800dd123ee432ee01bbb515e30efccee505e39ac/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800dd123ee432ee01bbb515e30efccee505e39ac/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=800dd123ee432ee01bbb515e30efccee505e39ac", "patch": "@@ -399,7 +399,14 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n   if (TREE_CODE (cond) != SSA_NAME\n       && !lang_hooks.types_compatible_p (TREE_TYPE (cond), TREE_TYPE (result)))\n     {\n-      new_var = make_rename_temp (TREE_TYPE (cond), NULL);\n+      tree tmp;\n+\n+      if (!COMPARISON_CLASS_P (cond))\n+\treturn false;\n+\n+      tmp = create_tmp_var (TREE_TYPE (cond), NULL);\n+      add_referenced_tmp_var (tmp);\n+      new_var = make_ssa_name (tmp, NULL);\n       old_result = cond;\n       cond = new_var;\n     }\n@@ -422,14 +429,14 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n   if (old_result)\n     {\n       tree new1;\n-      if (!COMPARISON_CLASS_P (old_result))\n-\treturn false;\n \n       new1 = build2 (TREE_CODE (old_result), TREE_TYPE (old_result),\n \t\t     TREE_OPERAND (old_result, 0),\n \t\t     TREE_OPERAND (old_result, 1));\n \n       new1 = build2 (MODIFY_EXPR, TREE_TYPE (old_result), new_var, new1);\n+      SSA_NAME_DEF_STMT (new_var) = new1;\n+\n       bsi_insert_after (&bsi, new1, BSI_NEW_STMT);\n     }\n \n@@ -465,6 +472,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n       tree cond1 = invert_truthvalue (cond);\n \n       cond = cond1;\n+\n       /* If what we get back is a conditional expression, there is no\n \t  way that it can be gimple.  */\n       if (TREE_CODE (cond) == COND_EXPR)\n@@ -473,23 +481,39 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n \t  return false;\n \t}\n \n+      /* If COND is not something we can expect to be reducible to a GIMPLE\n+\t condition, return early.  */\n+      if (is_gimple_cast (cond))\n+\tcond1 = TREE_OPERAND (cond, 0);\n+      if (TREE_CODE (cond1) == TRUTH_NOT_EXPR\n+\t  && !is_gimple_val (TREE_OPERAND (cond1, 0)))\n+\t{\n+\t  release_ssa_name (new_var1);\n+\t  return false;\n+\t}\n+\n       /* If what we get back is not gimple try to create it as gimple by\n \t using a temporary variable.  */\n       if (is_gimple_cast (cond)\n \t  && !is_gimple_val (TREE_OPERAND (cond, 0)))\n \t{\n-\t  tree temp = TREE_OPERAND (cond, 0);\n-\t  tree new_var_1 = make_rename_temp (TREE_TYPE (temp), NULL);\n-\t  new = build2 (MODIFY_EXPR, TREE_TYPE (new_var_1), new_var_1, temp);\n-\t  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n-\t  cond = fold_convert (TREE_TYPE (result), new_var_1);\n-\t}\n+\t  tree op0, tmp, cond_tmp;\n \n-      if (TREE_CODE (cond) == TRUTH_NOT_EXPR\n-\t  &&  !is_gimple_val (TREE_OPERAND (cond, 0)))\n-\t{\n-\t  release_ssa_name (new_var1);\n-\t  return false;\n+\t  /* Only \"real\" casts are OK here, not everything that is\n+\t     acceptable to is_gimple_cast.  Make sure we don't do\n+\t     anything stupid here.  */\n+\t  gcc_assert (TREE_CODE (cond) == NOP_EXPR\n+\t\t      || TREE_CODE (cond) == CONVERT_EXPR);\n+\n+\t  op0 = TREE_OPERAND (cond, 0);\n+\t  tmp = create_tmp_var (TREE_TYPE (op0), NULL);\n+\t  add_referenced_tmp_var (tmp);\n+\t  cond_tmp = make_ssa_name (tmp, NULL);\n+\t  new = build2 (MODIFY_EXPR, TREE_TYPE (cond_tmp), cond_tmp, op0);\n+\t  SSA_NAME_DEF_STMT (cond_tmp) = new;\n+\n+\t  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n+\t  cond = fold_convert (TREE_TYPE (result), cond_tmp);\n \t}\n \n       new = build2 (MODIFY_EXPR, TREE_TYPE (new_var1), new_var1, cond);\n@@ -928,13 +952,18 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n   result = duplicate_ssa_name (result, NULL);\n \n   if (negate)\n-    lhs = make_rename_temp (TREE_TYPE (result), NULL);\n+    {\n+      tree tmp = create_tmp_var (TREE_TYPE (result), NULL);\n+      add_referenced_tmp_var (tmp);\n+      lhs = make_ssa_name (tmp, NULL);\n+    }\n   else\n     lhs = result;\n \n   /* Build the modify expression with abs expression.  */\n   new = build2 (MODIFY_EXPR, TREE_TYPE (lhs),\n \t\tlhs, build1 (ABS_EXPR, TREE_TYPE (lhs), rhs));\n+  SSA_NAME_DEF_STMT (lhs) = new;\n \n   bsi = bsi_last (cond_bb);\n   bsi_insert_before (&bsi, new, BSI_NEW_STMT);\n@@ -946,11 +975,11 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n \t in the block.  */\n       new = build2 (MODIFY_EXPR, TREE_TYPE (result),\n \t\t    result, build1 (NEGATE_EXPR, TREE_TYPE (lhs), lhs));\n+      SSA_NAME_DEF_STMT (result) = new;\n \n       bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n     }\n \n-  SSA_NAME_DEF_STMT (result) = new;\n   replace_phi_edge_with_variable (cond_bb, e1, phi, result);\n \n   /* Note that we optimized this PHI.  */\n@@ -983,7 +1012,6 @@ struct tree_opt_pass pass_phiopt =\n     | TODO_dump_func\n     | TODO_ggc_collect\n     | TODO_verify_ssa\n-    | TODO_update_ssa\n     | TODO_verify_flow\n     | TODO_verify_stmts,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */"}]}