{"sha": "6b5c98c1c0003bd470a4428bede6c862637a94b8", "node_id": "C_kwDOANBUbNoAKDZiNWM5OGMxYzAwMDNiZDQ3MGE0NDI4YmVkZTZjODYyNjM3YTk0Yjg", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-20T16:42:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-20T16:42:42Z"}, "message": "reg-stack: Fix a -fcompare-debug bug in reg-stack [PR107183]\n\nAs the following testcase shows, the swap_rtx_condition function\nin reg-stack can result in different code generation between -g and -g0.\nThe function is doing the changes as it goes, so does analysis and\nchanges together, which makes it harder to deal with DEBUG_INSNs,\nwhere normally analysis phase ignores them and the later phase\ndoesn't.\nswap_rtx_condition walks instructions two different ways, one is\nusing next_flags_user function which stops on non-call instructions\nthat mention the flags register, and the other is a loop on fnstsw\nwhere it stops on instructions mentioning it and tries to find\nsahf instruction that uses it (in both cases calls stop it and so\ndoes end of basic block).\nNow both of these currently stop on DEBUG_INSNs that mention\nthe flags register resp. the fnstsw result register.\nOn success the function recurses on next flags user instruction\nif still live and if the recursion failed, reverts the changes\nit did too and fails.\nIf it were just for the next_flags_user case, the fix could be\njust not doing\n      INSN_CODE (insn) = -1;\n      if (recog_memoized (insn) == -1)\n        fail = 1;\non DEBUG_INSNs (assuming all changes to those are fine),\nswap_rtx_condition_1 just changes one comparison to a different\none.  But due to the possibility of fnstsw result being used\nin theory before sahf in some DEBUG_INSNs, this patch takes\na different approach.  swap_rtx_condition has now a new argument\nand two modes.  The first mode is when debug_seen is >= 0, in this\ncase both next_flags_user and the loop for fnstsw -> sahf will\nignore but note DEBUG_INSNs (that mention flags register or fnstsw\nresult).  If no such DEBUG_INSN is found during the whole call\nincluding recursive invocations (so e.g. for -g0 but probably most\noften for -g as well), it behaves as before, if it returns true\nall the changes are done and nothing further needs to be done later.\nIf any DEBUG_INSNs are seen along the way, even when returning success\nall the changes are reverted, so it just reports that the function\nwould be successful if DEBUG_INSNs were ignored.\nIn this case, compare_for_stack_reg needs to call it again in\ndebug_seen = -1 mode, which tells the function to update everything\nincluding DEBUG_INSNs.  For the fnstsw -> sahf case which I hope\nwill be very rare I just reset the DEBUG_INSNs, I don't really\nknow how to express it easily otherwise.  For the rest\nswap_rtx_condition_1 is done even on the DEBUG_INSNs.\n\n2022-11-20  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/107183\n\t* reg-stack.cc (next_flags_user): Add DEBUG_SEEN argument.\n\tIf >= 0 and a DEBUG_INSN would be otherwise returned, set\n\tDEBUG_SEEN to 1 and ignore it.\n\t(swap_rtx_condition): Add DEBUG_SEEN argument.  In >= 0\n\tmode only set DEBUG_SEEN to 1 if problematic DEBUG_ISNSs\n\twere seen and revert all changes on success in that case.\n\tDon't try to recog_memoized DEBUG_INSNs.\n\t(compare_for_stack_reg): Adjust swap_rtx_condition caller.\n\tIf it returns true and debug_seen is 1, call swap_rtx_condition\n\tagain with debug_seen -1.\n\n\t* gcc.dg/ubsan/pr107183.c: New test.", "tree": {"sha": "71241d393eace514cd5866eb4f6e091301dc70d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71241d393eace514cd5866eb4f6e091301dc70d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b5c98c1c0003bd470a4428bede6c862637a94b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5c98c1c0003bd470a4428bede6c862637a94b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b5c98c1c0003bd470a4428bede6c862637a94b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5c98c1c0003bd470a4428bede6c862637a94b8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0275ff207027954d16e873ccdbd92f9881a14e72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0275ff207027954d16e873ccdbd92f9881a14e72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0275ff207027954d16e873ccdbd92f9881a14e72"}], "stats": {"total": 98, "additions": 77, "deletions": 21}, "files": [{"sha": "4046f17f98f11996820c832a6b6e148b8993d93c", "filename": "gcc/reg-stack.cc", "status": "modified", "additions": 65, "deletions": 21, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5c98c1c0003bd470a4428bede6c862637a94b8/gcc%2Freg-stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5c98c1c0003bd470a4428bede6c862637a94b8/gcc%2Freg-stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.cc?ref=6b5c98c1c0003bd470a4428bede6c862637a94b8", "patch": "@@ -263,14 +263,14 @@ static void swap_to_top (rtx_insn *, stack_ptr, rtx, rtx);\n static bool move_for_stack_reg (rtx_insn *, stack_ptr, rtx);\n static bool move_nan_for_stack_reg (rtx_insn *, stack_ptr, rtx);\n static int swap_rtx_condition_1 (rtx);\n-static int swap_rtx_condition (rtx_insn *);\n+static int swap_rtx_condition (rtx_insn *, int &);\n static void compare_for_stack_reg (rtx_insn *, stack_ptr, rtx, bool);\n static bool subst_stack_regs_pat (rtx_insn *, stack_ptr, rtx);\n static void subst_asm_stack_regs (rtx_insn *, stack_ptr);\n static bool subst_stack_regs (rtx_insn *, stack_ptr);\n static void change_stack (rtx_insn *, stack_ptr, stack_ptr, enum emit_where);\n static void print_stack (FILE *, stack_ptr);\n-static rtx_insn *next_flags_user (rtx_insn *);\n+static rtx_insn *next_flags_user (rtx_insn *, int &);\n \f\n /* Return nonzero if any stack register is mentioned somewhere within PAT.  */\n \n@@ -336,7 +336,7 @@ stack_regs_mentioned (const_rtx insn)\n static rtx ix86_flags_rtx;\n \n static rtx_insn *\n-next_flags_user (rtx_insn *insn)\n+next_flags_user (rtx_insn *insn, int &debug_seen)\n {\n   /* Search forward looking for the first use of this value.\n      Stop at block boundaries.  */\n@@ -346,7 +346,14 @@ next_flags_user (rtx_insn *insn)\n       insn = NEXT_INSN (insn);\n \n       if (INSN_P (insn) && reg_mentioned_p (ix86_flags_rtx, PATTERN (insn)))\n-\treturn insn;\n+\t{\n+\t  if (DEBUG_INSN_P (insn) && debug_seen >= 0)\n+\t    {\n+\t      debug_seen = 1;\n+\t      continue;\n+\t    }\n+\t  return insn;\n+\t}\n \n       if (CALL_P (insn))\n \treturn NULL;\n@@ -1248,8 +1255,22 @@ swap_rtx_condition_1 (rtx pat)\n   return r;\n }\n \n+/* This function swaps condition in cc users and returns true\n+   if successful.  It is invoked in 2 different modes, one with\n+   DEBUG_SEEN set initially to 0.  In this mode, next_flags_user\n+   will skip DEBUG_INSNs that it would otherwise return and just\n+   sets DEBUG_SEEN to 1 in that case.  If DEBUG_SEEN is 0 at\n+   the end of toplevel swap_rtx_condition which returns true,\n+   it means no problematic DEBUG_INSNs were seen and all changes\n+   have been applied.  If it returns true but DEBUG_SEEN is 1,\n+   it means some problematic DEBUG_INSNs were seen and no changes\n+   have been applied so far.  In that case one needs to call\n+   swap_rtx_condition again with DEBUG_SEEN set to -1, in which\n+   case it doesn't skip DEBUG_INSNs, but instead adjusts the\n+   flags related condition in them or resets them as needed.  */\n+\n static int\n-swap_rtx_condition (rtx_insn *insn)\n+swap_rtx_condition (rtx_insn *insn, int &debug_seen)\n {\n   rtx pat = PATTERN (insn);\n \n@@ -1259,7 +1280,7 @@ swap_rtx_condition (rtx_insn *insn)\n       && REG_P (SET_DEST (pat))\n       && REGNO (SET_DEST (pat)) == FLAGS_REG)\n     {\n-      insn = next_flags_user (insn);\n+      insn = next_flags_user (insn, debug_seen);\n       if (insn == NULL_RTX)\n \treturn 0;\n       pat = PATTERN (insn);\n@@ -1281,7 +1302,18 @@ swap_rtx_condition (rtx_insn *insn)\n \t{\n \t  insn = NEXT_INSN (insn);\n \t  if (INSN_P (insn) && reg_mentioned_p (dest, insn))\n-\t    break;\n+\t    {\n+\t      if (DEBUG_INSN_P (insn))\n+\t\t{\n+\t\t  if (debug_seen >= 0)\n+\t\t    debug_seen = 1;\n+\t\t  else\n+\t\t    /* Reset the DEBUG insn otherwise.  */\n+\t\t    INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n+\t\t  continue;\n+\t\t}\n+\t      break;\n+\t    }\n \t  if (CALL_P (insn))\n \t    return 0;\n \t}\n@@ -1301,7 +1333,7 @@ swap_rtx_condition (rtx_insn *insn)\n \treturn 0;\n \n       /* Now we are prepared to handle this.  */\n-      insn = next_flags_user (insn);\n+      insn = next_flags_user (insn, debug_seen);\n       if (insn == NULL_RTX)\n \treturn 0;\n       pat = PATTERN (insn);\n@@ -1310,23 +1342,25 @@ swap_rtx_condition (rtx_insn *insn)\n   if (swap_rtx_condition_1 (pat))\n     {\n       int fail = 0;\n-      INSN_CODE (insn) = -1;\n-      if (recog_memoized (insn) == -1)\n-\tfail = 1;\n-      /* In case the flags don't die here, recurse to try fix\n-         following user too.  */\n-      else if (! dead_or_set_p (insn, ix86_flags_rtx))\n+      if (DEBUG_INSN_P (insn))\n+\tgcc_assert (debug_seen < 0);\n+      else\n \t{\n-\t  insn = next_flags_user (insn);\n-\t  if (!insn || !swap_rtx_condition (insn))\n+\t  INSN_CODE (insn) = -1;\n+\t  if (recog_memoized (insn) == -1)\n \t    fail = 1;\n \t}\n-      if (fail)\n+      /* In case the flags don't die here, recurse to try fix\n+\t following user too.  */\n+      if (!fail && !dead_or_set_p (insn, ix86_flags_rtx))\n \t{\n-\t  swap_rtx_condition_1 (pat);\n-\t  return 0;\n+\t  insn = next_flags_user (insn, debug_seen);\n+\t  if (!insn || !swap_rtx_condition (insn, debug_seen))\n+\t    fail = 1;\n \t}\n-      return 1;\n+      if (fail || debug_seen == 1)\n+\tswap_rtx_condition_1 (pat);\n+      return !fail;\n     }\n   return 0;\n }\n@@ -1345,6 +1379,7 @@ compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack,\n {\n   rtx *src1, *src2;\n   rtx src1_note, src2_note;\n+  int debug_seen = 0;\n \n   src1 = get_true_reg (&XEXP (pat_src, 0));\n   src2 = get_true_reg (&XEXP (pat_src, 1));\n@@ -1354,8 +1389,17 @@ compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack,\n   if ((! STACK_REG_P (*src1)\n        || (STACK_REG_P (*src2)\n \t   && get_hard_regnum (regstack, *src2) == FIRST_STACK_REG))\n-      && swap_rtx_condition (insn))\n+      && swap_rtx_condition (insn, debug_seen))\n     {\n+      /* If swap_rtx_condition succeeded but some debug insns\n+\t were seen along the way, it has actually reverted all the\n+\t changes.  Rerun swap_rtx_condition in a mode where DEBUG_ISNSs\n+\t will be adjusted as well.  */\n+      if (debug_seen)\n+\t{\n+\t  debug_seen = -1;\n+\t  swap_rtx_condition (insn, debug_seen);\n+\t}\n       std::swap (XEXP (pat_src, 0), XEXP (pat_src, 1));\n \n       src1 = get_true_reg (&XEXP (pat_src, 0));"}, {"sha": "e54a361c7c99388eaa2d4681a946da65ae074133", "filename": "gcc/testsuite/gcc.dg/ubsan/pr107183.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5c98c1c0003bd470a4428bede6c862637a94b8/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fpr107183.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5c98c1c0003bd470a4428bede6c862637a94b8/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fpr107183.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fpr107183.c?ref=6b5c98c1c0003bd470a4428bede6c862637a94b8", "patch": "@@ -0,0 +1,12 @@\n+/* PR target/107183 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fsanitize=float-cast-overflow -fcompare-debug\" } */\n+\n+long double a, b, c;\n+\n+int\n+foo (void)\n+{\n+  unsigned u = b || __builtin_rintl (c);\n+  return u + (unsigned) a;\n+}"}]}