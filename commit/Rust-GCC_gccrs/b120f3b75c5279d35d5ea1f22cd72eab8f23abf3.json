{"sha": "b120f3b75c5279d35d5ea1f22cd72eab8f23abf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEyMGYzYjc1YzUyNzlkMzVkNWVhMWYyMmNkNzJlYWI4ZjIzYWJmMw==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2005-03-04T19:54:16Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2005-03-04T19:54:16Z"}, "message": "unwind-dw2-fde-glibc.c (struct unw_eh_callback_data.check_cache): New field.\n\n2005-03-04  Andrew Haley  <aph@redhat.com>\n\n        * unwind-dw2-fde-glibc.c (struct\n        unw_eh_callback_data.check_cache): New field.\n        (frame_hdr_cache): New.\n        (_Unwind_IteratePhdrCallback): Add ext_dl_phdr_info.\n        Cache frame header info.\n\nFrom-SVN: r95894", "tree": {"sha": "d16e8a2c4477ef795b0ce5c429d9f36a08a8add7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d16e8a2c4477ef795b0ce5c429d9f36a08a8add7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b120f3b75c5279d35d5ea1f22cd72eab8f23abf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b120f3b75c5279d35d5ea1f22cd72eab8f23abf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b120f3b75c5279d35d5ea1f22cd72eab8f23abf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b120f3b75c5279d35d5ea1f22cd72eab8f23abf3/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "37e860a298acde8c2e62f20adf4018fa74af2301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37e860a298acde8c2e62f20adf4018fa74af2301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37e860a298acde8c2e62f20adf4018fa74af2301"}], "stats": {"total": 145, "additions": 138, "deletions": 7}, "files": [{"sha": "703d62cd60e18603988942918f3c94c75a00defe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120f3b75c5279d35d5ea1f22cd72eab8f23abf3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120f3b75c5279d35d5ea1f22cd72eab8f23abf3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b120f3b75c5279d35d5ea1f22cd72eab8f23abf3", "patch": "@@ -1,3 +1,11 @@\n+2005-03-04  Andrew Haley  <aph@redhat.com>\n+\n+\t* unwind-dw2-fde-glibc.c (struct\n+\tunw_eh_callback_data.check_cache): New field.\n+\t(frame_hdr_cache): New.\n+\t(_Unwind_IteratePhdrCallback): Add ext_dl_phdr_info.\n+\tCache frame header info.\n+\n 2005-03-04  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* rtl.h (copy_rtx_ptr_loc, print_rtx_ptr_loc, join_c_conditions)"}, {"sha": "d4853e07639a0f4c0778cbc57b2d7710ac7bb8e8", "filename": "gcc/unwind-dw2-fde-glibc.c", "status": "modified", "additions": 130, "deletions": 7, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120f3b75c5279d35d5ea1f22cd72eab8f23abf3/gcc%2Funwind-dw2-fde-glibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120f3b75c5279d35d5ea1f22cd72eab8f23abf3/gcc%2Funwind-dw2-fde-glibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde-glibc.c?ref=b120f3b75c5279d35d5ea1f22cd72eab8f23abf3", "patch": "@@ -74,6 +74,7 @@ struct unw_eh_callback_data\n   void *dbase;\n   void *func;\n   const fde *ret;\n+  int check_cache;\n };\n \n struct unw_eh_frame_hdr\n@@ -84,6 +85,20 @@ struct unw_eh_frame_hdr\n   unsigned char table_enc;\n };\n \n+#define FRAME_HDR_CACHE_SIZE 8\n+\n+static struct frame_hdr_cache_element\n+{\n+  _Unwind_Ptr pc_low;\n+  _Unwind_Ptr pc_high;\n+  _Unwind_Ptr load_base;\n+  const ElfW(Phdr) *p_eh_frame_hdr;\n+  const ElfW(Phdr) *p_dynamic;\n+  struct frame_hdr_cache_element *link;\n+} frame_hdr_cache[FRAME_HDR_CACHE_SIZE];\n+\n+static struct frame_hdr_cache_element *frame_hdr_cache_head;\n+\n /* Like base_of_encoded_value, but take the base from a struct\n    unw_eh_callback_data instead of an _Unwind_Context.  */\n \n@@ -123,18 +138,99 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n   const struct unw_eh_frame_hdr *hdr;\n   _Unwind_Ptr eh_frame;\n   struct object ob;\n-\n-  /* Make sure struct dl_phdr_info is at least as big as we need.  */\n-  if (size < offsetof (struct dl_phdr_info, dlpi_phnum)\n-\t     + sizeof (info->dlpi_phnum))\n-    return -1;\n+  \n+  struct ext_dl_phdr_info\n+    {\n+      ElfW(Addr) dlpi_addr;\n+      const char *dlpi_name;\n+      const ElfW(Phdr) *dlpi_phdr;\n+      ElfW(Half) dlpi_phnum;\n+      unsigned long long int dlpi_adds;\n+      unsigned long long int dlpi_subs;\n+    };\n \n   match = 0;\n   phdr = info->dlpi_phdr;\n   load_base = info->dlpi_addr;\n   p_eh_frame_hdr = NULL;\n   p_dynamic = NULL;\n \n+  struct frame_hdr_cache_element *prev_cache_entry = NULL,\n+    *last_cache_entry = NULL;\n+\n+  if (data->check_cache && size >= sizeof (struct ext_dl_phdr_info))\n+    {\n+      static unsigned long long adds = -1ULL, subs;\n+      struct ext_dl_phdr_info *einfo = (struct ext_dl_phdr_info *) info;\n+\n+      /* We use a least recently used cache replacement policy.  Also,\n+\t the most recently used cache entries are placed at the head\n+\t of the search chain.  */\n+\n+      if (einfo->dlpi_adds == adds && einfo->dlpi_subs == subs)\n+\t{\n+\t  /* Find data->pc in shared library cache.\n+\t     Set load_base, p_eh_frame_hdr and p_dynamic\n+\t     plus match from the cache and goto\n+\t     \"Read .eh_frame_hdr header.\" below.  */\n+\n+\t  struct frame_hdr_cache_element *cache_entry;\n+\n+\t  for (cache_entry = frame_hdr_cache_head;\n+\t       cache_entry;\n+\t       cache_entry = cache_entry->link)\n+\t    {\n+\t      if (data->pc >= cache_entry->pc_low\n+\t\t  && data->pc < cache_entry->pc_high)\n+\t\t{\n+\t\t  load_base = cache_entry->load_base;\n+\t\t  p_eh_frame_hdr = cache_entry->p_eh_frame_hdr;\n+\t\t  p_dynamic = cache_entry->p_dynamic;\n+\n+\t\t  /* And move the entry we're using to the head.  */\n+\t\t  if (cache_entry != frame_hdr_cache_head)\n+\t\t    {\n+\t\t      prev_cache_entry->link = cache_entry->link;\n+\t\t      cache_entry->link = frame_hdr_cache_head;\n+\t\t      frame_hdr_cache_head = cache_entry;\n+\t\t    }\n+\t\t  goto found;\n+\t\t}\n+\t\t  \n+\t      last_cache_entry = cache_entry;\n+\t      /* Exit early if we found an unused entry.  */\n+\t      if ((cache_entry->pc_low | cache_entry->pc_high) == 0)\n+\t\tbreak;\n+\t      if (cache_entry->link != NULL)\n+\t\tprev_cache_entry = cache_entry;\t\t  \n+\t    }\n+\t}\n+      else\n+\t{\n+\t  adds = einfo->dlpi_adds;\n+\t  subs = einfo->dlpi_subs;\n+\t  /* Initialize the cache.  Create a chain of cache entries,\n+\t     with the final one terminated by a NULL link.  */\n+\t  int i;\n+\t  for (i = 0; i < FRAME_HDR_CACHE_SIZE; i++)\n+\t    {\n+\t      frame_hdr_cache[i].pc_low = 0;\n+\t      frame_hdr_cache[i].pc_high = 0;\n+\t      frame_hdr_cache[i].link = &frame_hdr_cache[i+1];\n+\t    }\n+\t  frame_hdr_cache[i-1].link = NULL;\n+\t  frame_hdr_cache_head = &frame_hdr_cache[0];\n+\t  data->check_cache = 0;\n+\t}\n+    }\n+\n+  /* Make sure struct dl_phdr_info is at least as big as we need.  */\n+  if (size < offsetof (struct dl_phdr_info, dlpi_phnum)\n+\t     + sizeof (info->dlpi_phnum))\n+    return -1;\n+ \n+  _Unwind_Ptr pc_low = 0, pc_high = 0;\n+\n   /* See if PC falls into one of the loaded segments.  Find the eh_frame\n      segment at the same time.  */\n   for (n = info->dlpi_phnum; --n >= 0; phdr++)\n@@ -144,14 +240,40 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n \t  _Unwind_Ptr vaddr = (_Unwind_Ptr)\n \t    __RELOC_POINTER (phdr->p_vaddr, load_base);\n \t  if (data->pc >= vaddr && data->pc < vaddr + phdr->p_memsz)\n-\t    match = 1;\n+\t    {\n+\t      match = 1;\n+\t      pc_low = vaddr;\n+\t      pc_high =  vaddr + phdr->p_memsz;\n+\t    }\n \t}\n       else if (phdr->p_type == PT_GNU_EH_FRAME)\n \tp_eh_frame_hdr = phdr;\n       else if (phdr->p_type == PT_DYNAMIC)\n \tp_dynamic = phdr;\n     }\n-  if (!match || !p_eh_frame_hdr)\n+  \n+  if (!match)\n+    return 0;\n+\n+  if (size >= sizeof (struct ext_dl_phdr_info))\n+    {\n+      if (last_cache_entry != NULL)\n+\t{\n+\t  prev_cache_entry->link = last_cache_entry->link;\n+\t  last_cache_entry->link = frame_hdr_cache_head;\n+\t  frame_hdr_cache_head = last_cache_entry;\n+\t}\n+\n+      frame_hdr_cache_head->load_base = load_base;\n+      frame_hdr_cache_head->p_eh_frame_hdr = p_eh_frame_hdr;\n+      frame_hdr_cache_head->p_dynamic = p_dynamic;\n+      frame_hdr_cache_head->pc_low = pc_low;\n+      frame_hdr_cache_head->pc_high = pc_high;\n+    }\n+\n+ found:\n+\n+  if (!p_eh_frame_hdr)\n     return 0;\n \n   /* Read .eh_frame_hdr header.  */\n@@ -289,6 +411,7 @@ _Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)\n   data.dbase = NULL;\n   data.func = NULL;\n   data.ret = NULL;\n+  data.check_cache = 1;\n \n   if (dl_iterate_phdr (_Unwind_IteratePhdrCallback, &data) < 0)\n     return NULL;"}]}