{"sha": "981c353ef5e0af5f0a7766d6458b67c38ba95b4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgxYzM1M2VmNWUwYWY1ZjBhNzc2NmQ2NDU4YjY3YzM4YmE5NWI0Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-09-10T21:42:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-09-10T21:42:00Z"}, "message": "re PR c++/17386 (libstdc++ iostreams miscompilation)\n\n        PR c++/17386\n        * call.c (build_vfield_ref): Move...\n        * class.c (build_vfield_ref): ... here.  Convert datum to the\n        primary base containing the vptr.\n        (make_new_vtable): Simplify build_primary_vtable arguments.\n        (finish_struct_1): Do not duplicate TYPE_VFIELD.\n        * typeck.c (build_class_member_access_expr): Don't warn for\n        null object access to base fields.\n\nFrom-SVN: r87322", "tree": {"sha": "01b5fc23b14cf877549458bcf476b9498c62d4fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01b5fc23b14cf877549458bcf476b9498c62d4fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/981c353ef5e0af5f0a7766d6458b67c38ba95b4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981c353ef5e0af5f0a7766d6458b67c38ba95b4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/981c353ef5e0af5f0a7766d6458b67c38ba95b4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981c353ef5e0af5f0a7766d6458b67c38ba95b4f/comments", "author": null, "committer": null, "parents": [{"sha": "80aa8340eb9eefbbf55ba9150abec353500573d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80aa8340eb9eefbbf55ba9150abec353500573d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80aa8340eb9eefbbf55ba9150abec353500573d5"}], "stats": {"total": 92, "additions": 50, "deletions": 42}, "files": [{"sha": "42660e8d9f63cda98237fa5d546ccfa485bc46eb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981c353ef5e0af5f0a7766d6458b67c38ba95b4f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981c353ef5e0af5f0a7766d6458b67c38ba95b4f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=981c353ef5e0af5f0a7766d6458b67c38ba95b4f", "patch": "@@ -1,3 +1,14 @@\n+2004-09-10  Richard Henderson  <rth@redhat.com>\n+\n+\tPR c++/17386\n+\t* call.c (build_vfield_ref): Move...\n+\t* class.c (build_vfield_ref): ... here.  Convert datum to the\n+\tprimary base containing the vptr.\n+\t(make_new_vtable): Simplify build_primary_vtable arguments.\n+\t(finish_struct_1): Do not duplicate TYPE_VFIELD.\n+\t* typeck.c (build_class_member_access_expr): Don't warn for\n+\tnull object access to base fields.\n+\n 2004-09-10  Ziemowit Laski  <zlaski@apple.com>\n \n \t* decl.c (objc_get_current_scope, objc_mark_locals_volatile):"}, {"sha": "c08fb7447040ae4557b4c39e55361071767f56b1", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981c353ef5e0af5f0a7766d6458b67c38ba95b4f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981c353ef5e0af5f0a7766d6458b67c38ba95b4f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=981c353ef5e0af5f0a7766d6458b67c38ba95b4f", "patch": "@@ -191,23 +191,6 @@ static bool magic_varargs_p (tree);\n static tree build_temp (tree, tree, int, void (**)(const char *, ...));\n static void check_constructor_callable (tree, tree);\n \n-tree\n-build_vfield_ref (tree datum, tree type)\n-{\n-  if (datum == error_mark_node)\n-    return error_mark_node;\n-\n-  if (TREE_CODE (TREE_TYPE (datum)) == REFERENCE_TYPE)\n-    datum = convert_from_reference (datum);\n-\n-  if (TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (type)\n-      && !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (datum), type))\n-    datum = convert_to_base (datum, type, /*check_access=*/false);\n-\n-  return build3 (COMPONENT_REF, TREE_TYPE (TYPE_VFIELD (type)),\n-\t\t datum, TYPE_VFIELD (type), NULL_TREE);\n-}\n-\n /* Returns nonzero iff the destructor name specified in NAME\n    (a BIT_NOT_EXPR) matches BASETYPE.  The operand of NAME can take many\n    forms...  */"}, {"sha": "999551b435d622e3648d637b64104be56be53daf", "filename": "gcc/cp/class.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981c353ef5e0af5f0a7766d6458b67c38ba95b4f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981c353ef5e0af5f0a7766d6458b67c38ba95b4f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=981c353ef5e0af5f0a7766d6458b67c38ba95b4f", "patch": "@@ -483,6 +483,38 @@ convert_to_base_statically (tree expr, tree base)\n }\n \n \f\n+tree\n+build_vfield_ref (tree datum, tree type)\n+{\n+  tree vfield, vcontext;\n+\n+  if (datum == error_mark_node)\n+    return error_mark_node;\n+\n+  if (TREE_CODE (TREE_TYPE (datum)) == REFERENCE_TYPE)\n+    datum = convert_from_reference (datum);\n+\n+  /* First, convert to the requested type.  */\n+  if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (datum), type))\n+    datum = convert_to_base (datum, type, /*check_access=*/false);\n+\n+  /* Second, the requested type may not be the owner of its own vptr.\n+     If not, convert to the base class that owns it.  We cannot use\n+     convert_to_base here, because VCONTEXT may appear more than once\n+     in the inheritence hierarchy of TYPE, and thus direct conversion\n+     between the types may be ambiguous.  Following the path back up\n+     one step at a time via primary bases avoids the problem.  */\n+  vfield = TYPE_VFIELD (type);\n+  vcontext = DECL_CONTEXT (vfield);\n+  while (!same_type_ignoring_top_level_qualifiers_p (vcontext, type))\n+    {\n+      datum = build_simple_base_path (datum, CLASSTYPE_PRIMARY_BINFO (type));\n+      type = TREE_TYPE (datum);\n+    }\n+\n+  return build3 (COMPONENT_REF, TREE_TYPE (vfield), datum, vfield, NULL_TREE);\n+}\n+\n /* Given an object INSTANCE, return an expression which yields the\n    vtable element corresponding to INDEX.  There are many special\n    cases for INSTANCE which we take care of here, mainly to avoid\n@@ -783,10 +815,7 @@ make_new_vtable (tree t, tree binfo)\n     /* In this case, it is *type*'s vtable we are modifying.  We start\n        with the approximation that its vtable is that of the\n        immediate base class.  */\n-    /* ??? This actually passes TYPE_BINFO (t), not the primary base binfo,\n-       since we've updated DECL_CONTEXT (TYPE_VFIELD (t)) by now.  */\n-    return build_primary_vtable (TYPE_BINFO (DECL_CONTEXT (TYPE_VFIELD (t))),\n-\t\t\t\t t);\n+    return build_primary_vtable (binfo, t);\n   else\n     /* This is our very own copy of `basetype' to play with.  Later,\n        we will fill in all the virtual functions that override the\n@@ -4927,7 +4956,6 @@ finish_struct_1 (tree t)\n   /* A TREE_LIST.  The TREE_VALUE of each node is a FUNCTION_DECL.  */\n   tree virtuals = NULL_TREE;\n   int n_fields = 0;\n-  tree vfield;\n \n   if (COMPLETE_TYPE_P (t))\n     {\n@@ -4981,25 +5009,6 @@ finish_struct_1 (tree t)\n        needs a mode.  */\n     compute_record_mode (CLASSTYPE_AS_BASE (t));\n \n-  /* Make sure that we get our own copy of the vfield FIELD_DECL.  */\n-  vfield = TYPE_VFIELD (t);\n-  if (vfield && CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n-    {\n-      tree primary = CLASSTYPE_PRIMARY_BINFO (t);\n-\n-      gcc_assert (same_type_p (DECL_FIELD_CONTEXT (vfield),\n-\t\t\t       BINFO_TYPE (primary)));\n-      /* The vtable better be at the start.  */\n-      gcc_assert (integer_zerop (DECL_FIELD_OFFSET (vfield)));\n-      gcc_assert (integer_zerop (BINFO_OFFSET (primary)));\n-      \n-      vfield = copy_decl (vfield);\n-      DECL_FIELD_CONTEXT (vfield) = t;\n-      TYPE_VFIELD (t) = vfield;\n-    }\n-  else\n-    gcc_assert (!vfield || DECL_FIELD_CONTEXT (vfield) == t);\n-\n   virtuals = modify_all_vtables (t, nreverse (virtuals));\n \n   /* If necessary, create the primary vtable for this class.  */"}, {"sha": "77fd20af6c9759b1bc6bbae977f2b7777a167579", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981c353ef5e0af5f0a7766d6458b67c38ba95b4f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981c353ef5e0af5f0a7766d6458b67c38ba95b4f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=981c353ef5e0af5f0a7766d6458b67c38ba95b4f", "patch": "@@ -1711,9 +1711,14 @@ build_class_member_access_expr (tree object, tree member,\n \t give the right answer.  Note that we complain whether or not they\n \t actually used the offsetof macro, since there's no way to know at this\n \t point.  So we just give a warning, instead of a pedwarn.  */\n+      /* Do not produce this warning for base class field references, because\n+\t we know for a fact that didn't come from offsetof.  This does occur\n+\t in various testsuite cases where a null object is passed where a\n+\t vtable access is required.  */\n       if (null_object_p && warn_invalid_offsetof\n \t  && CLASSTYPE_NON_POD_P (object_type)\n-\t  && ! skip_evaluation)\n+\t  && !DECL_FIELD_IS_BASE (member)\n+\t  && !skip_evaluation)\n \t{\n \t  warning (\"invalid access to non-static data member `%D' of NULL object\", \n \t\t   member);"}]}