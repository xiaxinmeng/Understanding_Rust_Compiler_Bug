{"sha": "533c4863631a304fb908021829934a6b81fcb24c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMzYzQ4NjM2MzFhMzA0ZmI5MDgwMjE4Mjk5MzRhNmI4MWZjYjI0Yw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2002-07-22T02:04:25Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2002-07-22T02:04:25Z"}, "message": "ra-build.c (check_conflict_numbers): Hide unused function.\n\n\t* ra-build.c (check_conflict_numbers): Hide unused function.\n\t(livethrough_conflicts_bb): Avoid automatic aggregate\n\tinitialization.\n\t(parts_to_webs_1): Avoid `U' integer constant modifier.\n\t(conflicts_between_webs): Wrap a variable in the macro controlling\n\tits usage.\n\t* ra-debug.c (ra_debug_msg): Use VA_OPEN/VA_CLOSE.\n\t(dump_igraph, dump_graph_cost): Avoid string concatenation\n\t(dump_static_insn_cost): Avoid automatic aggregate\n\tinitialization.\n\t* ra-rewrite.c (insert_stores): Avoid automatic aggregate\n\tinitialization.\n\t(dump_cost): Avoid string concatenation\n\nFrom-SVN: r55637", "tree": {"sha": "3114403bb3070cab9b0afd98aedb05080340f804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3114403bb3070cab9b0afd98aedb05080340f804"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/533c4863631a304fb908021829934a6b81fcb24c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533c4863631a304fb908021829934a6b81fcb24c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/533c4863631a304fb908021829934a6b81fcb24c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533c4863631a304fb908021829934a6b81fcb24c/comments", "author": null, "committer": null, "parents": [{"sha": "8943a0b4d855341542bf9b5fe4d29b616078ca9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8943a0b4d855341542bf9b5fe4d29b616078ca9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8943a0b4d855341542bf9b5fe4d29b616078ca9a"}], "stats": {"total": 104, "additions": 59, "deletions": 45}, "files": [{"sha": "cfd9e50fabe01069f68f6f0a22aa55b80030d5dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533c4863631a304fb908021829934a6b81fcb24c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533c4863631a304fb908021829934a6b81fcb24c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=533c4863631a304fb908021829934a6b81fcb24c", "patch": "@@ -1,3 +1,19 @@\n+2002-07-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* ra-build.c (check_conflict_numbers): Hide unused function.\n+\t(livethrough_conflicts_bb): Avoid automatic aggregate\n+\tinitialization.\n+\t(parts_to_webs_1): Avoid `U' integer constant modifier.\n+\t(conflicts_between_webs): Wrap a variable in the macro controlling\n+\tits usage.\n+\t* ra-debug.c (ra_debug_msg): Use VA_OPEN/VA_CLOSE.\n+\t(dump_igraph, dump_graph_cost): Avoid string concatenation\n+\t(dump_static_insn_cost): Avoid automatic aggregate\n+\tinitialization.\n+\t* ra-rewrite.c (insert_stores): Avoid automatic aggregate\n+\tinitialization.\n+\t(dump_cost): Avoid string concatenation\n+\n 2002-07-21  Richard Henderson  <rth@redhat.com>\n \n \t* expr.c (expand_expr) [TRY_FINALLY_EXPR]: Don't use"}, {"sha": "a7351f20037b8eba40b5dc10f9911be4402ccd58", "filename": "gcc/ra-build.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533c4863631a304fb908021829934a6b81fcb24c/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533c4863631a304fb908021829934a6b81fcb24c/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=533c4863631a304fb908021829934a6b81fcb24c", "patch": "@@ -101,7 +101,9 @@ static unsigned int parts_to_webs_1 PARAMS ((struct df *, struct web_link **,\n \t\t\t\t\t     struct df_link *));\n static void parts_to_webs PARAMS ((struct df *));\n static void reset_conflicts PARAMS ((void));\n+#if 0\n static void check_conflict_numbers PARAMS ((void));\n+#endif\n static void conflicts_between_webs PARAMS ((struct df *));\n static void remember_web_was_spilled PARAMS ((struct web *));\n static void detect_spill_temps PARAMS ((void));\n@@ -1069,8 +1071,10 @@ livethrough_conflicts_bb (bb)\n     {\n       if (INSN_P (insn))\n \t{\n-\t  struct ra_insn_info info = insn_df[INSN_UID (insn)];\n \t  unsigned int n;\n+\t  struct ra_insn_info info;\n+\n+\t  info = insn_df[INSN_UID (insn)];\n \t  for (n = 0; n < info.num_defs; n++)\n \t    bitmap_set_bit (all_defs, DF_REF_ID (info.defs[n]));\n \t  if (TEST_BIT (insns_with_deaths, INSN_UID (insn)))\n@@ -1826,7 +1830,7 @@ parts_to_webs_1 (df, copy_webs, all_refs)\n       if (! wp->uplink)\n \t{\n \t  /* If we have a web part root, create a new web.  */\n-\t  unsigned int newid = ~0U;\n+\t  unsigned int newid = ~(unsigned)0;\n \t  unsigned int old_web = 0;\n \n \t  /* In the first pass, there are no old webs, so unconditionally\n@@ -1871,7 +1875,7 @@ parts_to_webs_1 (df, copy_webs, all_refs)\n \t\t    }\n \t\t}\n \t      /* The id is zeroed in init_one_web().  */\n-\t      if (newid == ~0U)\n+\t      if (newid == ~(unsigned)0)\n \t\tnewid = web->id;\n \t      if (old_web)\n \t\treinit_one_web (web, GET_CODE (reg) == SUBREG\n@@ -2188,6 +2192,7 @@ reset_conflicts ()\n /* For each web check it's num_conflicts member against that\n    number, as calculated from scratch from all neighbors.  */\n \n+#if 0\n static void\n check_conflict_numbers ()\n {\n@@ -2204,6 +2209,7 @@ check_conflict_numbers ()\n \tabort ();\n     }\n }\n+#endif\n \n /* Convert the conflicts between web parts to conflicts between full webs.\n \n@@ -2223,7 +2229,9 @@ conflicts_between_webs (df)\n      struct df *df;\n {\n   unsigned int i;\n+#ifdef STACK_REGS\n   struct dlist *d;\n+#endif\n   bitmap ignore_defs = BITMAP_XMALLOC ();\n   unsigned int have_ignored;\n   unsigned int *pass_cache = (unsigned int *) xcalloc (num_webs, sizeof (int));"}, {"sha": "a96d708d9b2db77629a4062d21517cf65c8da8ea", "filename": "gcc/ra-debug.c", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533c4863631a304fb908021829934a6b81fcb24c/gcc%2Fra-debug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533c4863631a304fb908021829934a6b81fcb24c/gcc%2Fra-debug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-debug.c?ref=533c4863631a304fb908021829934a6b81fcb24c", "patch": "@@ -47,22 +47,12 @@ static const char *const reg_class_names[] = REG_CLASS_NAMES;\n void\n ra_debug_msg VPARAMS ((unsigned int level, const char *format, ...))\n {\n-#ifndef ANSI_PROTOTYPES\n-  int level;\n-  const char *format;\n-#endif\n-  va_list ap;\n+  VA_OPEN (ap, format);\n+  VA_FIXEDARG (ap, unsigned int, level);\n+  VA_FIXEDARG (ap, const char *, format);\n   if ((debug_new_regalloc & level) != 0 && rtl_dump_file != NULL)\n-    {\n-      VA_START (ap, format);\n-\n-#ifndef ANSI_PROTOTYPES\n-      format = va_arg (ap, const char *);\n-#endif\n-\n-      vfprintf (rtl_dump_file, format, ap);\n-      va_end (ap);\n-    }\n+    vfprintf (rtl_dump_file, format, ap);\n+  VA_CLOSE (ap);\n }\n \n \n@@ -720,10 +710,10 @@ dump_igraph (df)\n \t  ra_debug_msg (DUMP_WEBS, \" sub %d\", SUBREG_BYTE (web->orig_x));\n \t  ra_debug_msg (DUMP_WEBS, \" par %d\", find_web_for_subweb (web)->id);\n \t}\n-      ra_debug_msg (DUMP_WEBS, \" +%d (span %d, cost \"\n-\t\t HOST_WIDE_INT_PRINT_DEC \") (%s)\",\n-\t         web->add_hardregs, web->span_deaths, web->spill_cost,\n-\t         reg_class_names[web->regclass]);\n+      ra_debug_msg (DUMP_WEBS, \" +%d (span %d, cost \",\n+\t\t    web->add_hardregs, web->span_deaths);\n+      ra_debug_msg (DUMP_WEBS, HOST_WIDE_INT_PRINT_DEC, web->spill_cost);\n+      ra_debug_msg (DUMP_WEBS, \") (%s)\", reg_class_names[web->regclass]);\n       if (web->spill_temp == 1)\n \tra_debug_msg (DUMP_WEBS, \" (spilltemp)\");\n       else if (web->spill_temp == 2)\n@@ -866,7 +856,6 @@ dump_graph_cost (level, msg)\n {\n   unsigned int i;\n   unsigned HOST_WIDE_INT cost;\n-#define LU HOST_WIDE_INT_PRINT_UNSIGNED\n   if (!rtl_dump_file || (debug_new_regalloc & level) == 0)\n     return;\n \n@@ -877,9 +866,9 @@ dump_graph_cost (level, msg)\n       if (alias (web)->type == SPILLED)\n \tcost += web->orig_spill_cost;\n     }\n-  ra_debug_msg (level, \" spill cost of graph (%s) = \" LU \"\\n\",\n-\t     msg ? msg : \"\", cost);\n-#undef LU\n+  ra_debug_msg (level, \" spill cost of graph (%s) = \", msg ? msg : \"\");\n+  ra_debug_msg (level, HOST_WIDE_INT_PRINT_UNSIGNED, cost);\n+  ra_debug_msg (level, \"\\n\");\n }\n \n /* Dump the color assignment per web, the coalesced and spilled webs.  */\n@@ -930,12 +919,13 @@ dump_static_insn_cost (file, message, prefix)\n       unsigned HOST_WIDE_INT cost;\n       unsigned int count;\n     };\n-  struct cost load = {0, 0};\n-  struct cost store = {0, 0};\n-  struct cost regcopy = {0, 0};\n-  struct cost selfcopy = {0, 0};\n-  struct cost overall = {0, 0};\n   basic_block bb;\n+  struct cost load, store, regcopy, selfcopy, overall;\n+  memset (&load, 0, sizeof(load));\n+  memset (&store, 0, sizeof(store));\n+  memset (&regcopy, 0, sizeof(regcopy));\n+  memset (&selfcopy, 0, sizeof(selfcopy));\n+  memset (&overall, 0, sizeof(overall));\n \n   if (!file)\n     return;"}, {"sha": "7d0bbb6c292950a825335ad6693d904d224cd88d", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533c4863631a304fb908021829934a6b81fcb24c/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533c4863631a304fb908021829934a6b81fcb24c/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=533c4863631a304fb908021829934a6b81fcb24c", "patch": "@@ -666,9 +666,11 @@ insert_stores (new_deaths)\n       if (uid < insn_df_max_uid)\n \t{\n \t  unsigned int n;\n-\t  struct ra_insn_info info = insn_df[uid];\n \t  rtx following = NEXT_INSN (insn);\n \t  basic_block bb = BLOCK_FOR_INSN (insn);\n+\t  struct ra_insn_info info;\n+\n+\t  info = insn_df[uid];\n \t  for (n = 0; n < info.num_defs; n++)\n \t    {\n \t      struct web *web = def2web[DF_REF_ID (info.defs[n])];\n@@ -1949,20 +1951,18 @@ void\n dump_cost (level)\n      unsigned int level;\n {\n-#define LU HOST_WIDE_INT_PRINT_UNSIGNED\n   ra_debug_msg (level, \"Instructions for spilling\\n added:\\n\");\n-  ra_debug_msg (level, \"  loads =%d cost=\" LU \"\\n\", emitted_spill_loads,\n-\t     spill_load_cost);\n-  ra_debug_msg (level, \"  stores=%d cost=\" LU \"\\n\", emitted_spill_stores,\n-\t     spill_store_cost);\n-  ra_debug_msg (level, \"  remat =%d cost=\" LU \"\\n\", emitted_remat,\n-\t     spill_remat_cost);\n-  ra_debug_msg (level, \" removed:\\n\");\n-  ra_debug_msg (level, \"  moves =%d cost=\" LU \"\\n\", deleted_move_insns,\n-\t     deleted_move_cost);\n-  ra_debug_msg (level, \"  others=%d cost=\" LU \"\\n\", deleted_def_insns,\n-\t     deleted_def_cost);\n-#undef LU\n+  ra_debug_msg (level, \"  loads =%d cost=\", emitted_spill_loads);\n+  ra_debug_msg (level, HOST_WIDE_INT_PRINT_UNSIGNED, spill_load_cost);\n+  ra_debug_msg (level, \"\\n  stores=%d cost=\", emitted_spill_stores);\n+  ra_debug_msg (level, HOST_WIDE_INT_PRINT_UNSIGNED, spill_store_cost);\n+  ra_debug_msg (level, \"\\n  remat =%d cost=\", emitted_remat);\n+  ra_debug_msg (level, HOST_WIDE_INT_PRINT_UNSIGNED, spill_remat_cost);\n+  ra_debug_msg (level, \"\\n removed:\\n  moves =%d cost=\", deleted_move_insns);\n+  ra_debug_msg (level, HOST_WIDE_INT_PRINT_UNSIGNED, deleted_move_cost);\n+  ra_debug_msg (level, \"\\n  others=%d cost=\", deleted_def_insns);\n+  ra_debug_msg (level, HOST_WIDE_INT_PRINT_UNSIGNED, deleted_def_cost);\n+  ra_debug_msg (level, \"\\n\");\n }\n \n /* Initialization of the rewrite phase.  */"}]}