{"sha": "b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBiYzZlOGU2Y2QzZjBhNTc4OWY3ZTMwNzlmMDVkNTgzZTgwYTU2NQ==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2004-01-02T11:41:51Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2004-01-02T11:41:51Z"}, "message": "re PR c++/13520 (gcc crashes with inheritance + default template parameter of nested template type)\n\n\tPR c++/13520\n\t* cp-tree.h (DECL_UNBOUND_CLASS_TEMPLATE_P): New macro.\n\t(DECL_FUNCTION_TEMPLATE_P): Use it.\n\t(DECL_CLASS_TEMPLATE_P): Likewise.\n\t* parser.c (cp_parser_lookup_name): Add is_template parameter.\n\t(cp_parser_type_parameter): Adjust call to cp_parser_lookup_name.\n\t(cp_parser_template_name): Likewise.\n\t(cp_parser_elaborated_type_specifier): Likewise.\n\t(cp_parser_namespace_name): Likewise.\n\t(cp_parser_class_name): Likewise.\n\t(cp_parser_lookup_name_simple): Likewise.\n\n\t* g++.dg/template/qualttp22.C: New test.\n\nFrom-SVN: r75321", "tree": {"sha": "28a6954b822b13e1756c9d931d9283cfa4358f34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28a6954b822b13e1756c9d931d9283cfa4358f34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565/comments", "author": null, "committer": null, "parents": [{"sha": "daef8bbd72bac6afdc1f0c13ff4b6349128d8674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daef8bbd72bac6afdc1f0c13ff4b6349128d8674", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daef8bbd72bac6afdc1f0c13ff4b6349128d8674"}], "stats": {"total": 94, "additions": 83, "deletions": 11}, "files": [{"sha": "fa814377cc0e1045d92e73fc9547b4f52e881c79", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565", "patch": "@@ -1,2 +1,15 @@\n+2004-01-02  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/13520\n+\t* cp-tree.h (DECL_UNBOUND_CLASS_TEMPLATE_P): New macro.\n+\t(DECL_FUNCTION_TEMPLATE_P): Use it.\n+\t(DECL_CLASS_TEMPLATE_P): Likewise.\n+\t* parser.c (cp_parser_lookup_name): Add is_template parameter.\n+\t(cp_parser_type_parameter): Adjust call to cp_parser_lookup_name.\n+\t(cp_parser_template_name): Likewise.\n+\t(cp_parser_elaborated_type_specifier): Likewise.\n+\t(cp_parser_namespace_name): Likewise.\n+\t(cp_parser_class_name): Likewise.\n+\t(cp_parser_lookup_name_simple): Likewise.\n \n See ChangeLog.3 for earlier changes."}, {"sha": "fb04af38785447e62ffc536748b88af69a0c3637", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for C++ parsing and type checking.\n    Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -2720,13 +2720,20 @@ struct lang_decl GTY(())\n #define DECL_TEMPLATE_TEMPLATE_PARM_P(NODE) \\\n   (TREE_CODE (NODE) == TEMPLATE_DECL && DECL_TEMPLATE_PARM_P (NODE))\n \n+/* Nonzero if NODE is a TEMPLATE_DECL representing an\n+   UNBOUND_CLASS_TEMPLATE tree node.  */\n+#define DECL_UNBOUND_CLASS_TEMPLATE_P(NODE) \\\n+  (TREE_CODE (NODE) == TEMPLATE_DECL && !DECL_TEMPLATE_RESULT (NODE))\n+\n #define DECL_FUNCTION_TEMPLATE_P(NODE)  \\\n   (TREE_CODE (NODE) == TEMPLATE_DECL \\\n+   && !DECL_UNBOUND_CLASS_TEMPLATE_P (NODE) \\\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == FUNCTION_DECL)\n \n /* Nonzero for a DECL that represents a template class.  */\n #define DECL_CLASS_TEMPLATE_P(NODE) \\\n   (TREE_CODE (NODE) == TEMPLATE_DECL \\\n+   && !DECL_UNBOUND_CLASS_TEMPLATE_P (NODE) \\\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == TYPE_DECL \\\n    && !DECL_TEMPLATE_TEMPLATE_PARM_P (NODE))\n "}, {"sha": "f66a0a80780074b5cf7cb8bc1e67f9db37418471", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565", "patch": "@@ -1,5 +1,5 @@\n /* C++ Parser.\n-   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>.\n \n    This file is part of GCC.\n@@ -1621,7 +1621,7 @@ static void cp_parser_label_declaration\n /* Utility Routines */\n \n static tree cp_parser_lookup_name\n-  (cp_parser *, tree, bool, bool, bool);\n+  (cp_parser *, tree, bool, bool, bool, bool);\n static tree cp_parser_lookup_name_simple\n   (cp_parser *, tree);\n static tree cp_parser_maybe_treat_template_as_class\n@@ -7660,18 +7660,24 @@ cp_parser_type_parameter (cp_parser* parser)\n \t   default-argument.  */\n \tif (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n \t  {\n+\t    bool is_template;\n+\n \t    /* Consume the `='.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Parse the id-expression.  */\n \t    default_argument \n \t      = cp_parser_id_expression (parser,\n \t\t\t\t\t /*template_keyword_p=*/false,\n \t\t\t\t\t /*check_dependency_p=*/true,\n-\t\t\t\t\t /*template_p=*/NULL,\n+\t\t\t\t\t /*template_p=*/&is_template,\n \t\t\t\t\t /*declarator_p=*/false);\n \t    /* Look up the name.  */\n \t    default_argument \n-\t      = cp_parser_lookup_name_simple (parser, default_argument);\n+\t      = cp_parser_lookup_name (parser, default_argument,\n+\t\t\t\t       /*is_type=*/false,\n+\t\t\t\t       /*is_template=*/is_template,\n+\t\t\t\t       /*is_namespace=*/false,\n+\t\t\t\t       /*check_dependency=*/true);\n \t    /* See if the default argument is valid.  */\n \t    default_argument\n \t      = check_template_template_default_arg (default_argument);\n@@ -7979,6 +7985,7 @@ cp_parser_template_name (cp_parser* parser,\n   /* Look up the name.  */\n   decl = cp_parser_lookup_name (parser, identifier,\n \t\t\t\t/*is_type=*/false,\n+\t\t\t\t/*is_template=*/false,\n \t\t\t\t/*is_namespace=*/false,\n \t\t\t\tcheck_dependency_p);\n   decl = maybe_get_template_decl_from_type_decl (decl);\n@@ -8934,6 +8941,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t     cp_parser_lookup_name.  */\n \t  decl = cp_parser_lookup_name (parser, identifier, \n \t\t\t\t\t/*is_type=*/true,\n+\t\t\t\t\t/*is_template=*/false,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\t/*check_dependency=*/true);\n \n@@ -9206,6 +9214,7 @@ cp_parser_namespace_name (cp_parser* parser)\n      operator.)  */\n   namespace_decl = cp_parser_lookup_name (parser, identifier,\n \t\t\t\t\t  /*is_type=*/false,\n+\t\t\t\t\t  /*is_template=*/false,\n \t\t\t\t\t  /*is_namespace=*/true,\n \t\t\t\t\t  /*check_dependency=*/true);\n   /* If it's not a namespace, issue an error.  */\n@@ -11414,6 +11423,7 @@ cp_parser_class_name (cp_parser *parser,\n \t  /* Look up the name.  */\n \t  decl = cp_parser_lookup_name (parser, identifier, \n \t\t\t\t\ttype_p,\n+\t\t\t\t\t/*is_template=*/false,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\tcheck_dependency_p);\n \t}\n@@ -13245,6 +13255,9 @@ cp_parser_label_declaration (cp_parser* parser)\n    If IS_TYPE is TRUE, bindings that do not refer to types are\n    ignored.\n \n+   If IS_TEMPLATE is TRUE, bindings that do not refer to templates are\n+   ignored.\n+\n    If IS_NAMESPACE is TRUE, bindings that do not refer to namespaces\n    are ignored.\n \n@@ -13253,7 +13266,8 @@ cp_parser_label_declaration (cp_parser* parser)\n \n static tree\n cp_parser_lookup_name (cp_parser *parser, tree name, \n-\t\t       bool is_type, bool is_namespace, bool check_dependency)\n+\t\t       bool is_type, bool is_template, bool is_namespace,\n+\t\t       bool check_dependency)\n {\n   tree decl;\n   tree object_type = parser->context->object_type;\n@@ -13325,15 +13339,19 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n       if ((check_dependency || !CLASS_TYPE_P (parser->scope))\n \t   && dependent_p)\n \t{\n-\t  if (!is_type)\n-\t    decl = build_nt (SCOPE_REF, parser->scope, name);\n-\t  else\n+\t  if (is_type)\n \t    /* The resolution to Core Issue 180 says that `struct A::B'\n \t       should be considered a type-name, even if `A' is\n \t       dependent.  */\n \t    decl = TYPE_NAME (make_typename_type (parser->scope,\n \t\t\t\t\t\t  name,\n \t\t\t\t\t\t  /*complain=*/1));\n+\t  else if (is_template)\n+\t    decl = TYPE_NAME (make_unbound_class_template (parser->scope,\n+\t\t\t\t\t\t\t   name,\n+\t\t\t\t\t\t\t   /*complain=*/1));\n+\t  else\n+\t    decl = build_nt (SCOPE_REF, parser->scope, name);\n \t}\n       else\n \t{\n@@ -13427,14 +13445,15 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n }\n \n /* Like cp_parser_lookup_name, but for use in the typical case where\n-   CHECK_ACCESS is TRUE, IS_TYPE is FALSE, and CHECK_DEPENDENCY is\n-   TRUE.  */\n+   CHECK_ACCESS is TRUE, IS_TYPE is FALSE, IS_TEMPLATE is FALSE,\n+   IS_NAMESPACE is FALSE, and CHECK_DEPENDENCY is TRUE.  */\n \n static tree\n cp_parser_lookup_name_simple (cp_parser* parser, tree name)\n {\n   return cp_parser_lookup_name (parser, name, \n \t\t\t\t/*is_type=*/false,\n+\t\t\t\t/*is_template=*/false,\n \t\t\t\t/*is_namespace=*/false,\n \t\t\t\t/*check_dependency=*/true);\n }"}, {"sha": "55b8f033e6bc15da39b76926efc39aff64a7d2e3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565", "patch": "@@ -1,3 +1,8 @@\n+2004-01-02  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/13520\n+\t* g++.dg/template/qualttp22.C: New test.\n+\n 2004-01-01  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/debug/20031231-1.c: New."}, {"sha": "21aa7568d902bf5c768289c69166cff03175f3b8", "filename": "gcc/testsuite/g++.dg/template/qualttp22.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp22.C?ref=b0bc6e8e6cd3f0a5789f7e3079f05d583e80a565", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do compile }\n+\n+// Origin: Philippe Van Deyck <hetadres@email.com>\n+\n+// PR c++/13520: Default template template argument that is a qualified id\n+// with dependent scope.\n+\n+template<typename regular_type> class Policy {};\n+\n+template <typename regular_type, template<typename> class OriginalPolicy>\n+class ChangedPolicy_impl {};\n+\n+template <template<typename> class OriginalPolicy > class ChangedPolicy {\n+public:\n+  template<typename regular_type> class Type : public \n+  ChangedPolicy_impl<regular_type,OriginalPolicy> { };\n+};\n+\n+template <typename regular_type, template<typename> class Policy1,\n+\t  template<typename> class Policy2\n+\t    = ChangedPolicy<Policy1>::template Type>\n+class Host : public Policy1<regular_type>, public Policy2<regular_type> { };\n+\n+int main()\n+{\n+  Host<void, Policy> h;\n+  return 0;\n+}"}]}