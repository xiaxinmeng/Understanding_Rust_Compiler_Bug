{"sha": "9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJmYjI4ZWQzYzZmYjcwMmMyY2FiNjc5ODk1OTY3OWUxYmJkN2QwOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-03-13T15:13:37Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-03-13T15:13:37Z"}, "message": "[SLP/AArch64] Fix unpack handling for big-endian SVE\n\nI hadn't realised that on big-endian targets, VEC_UNPACK*HI_EXPR unpacks\nthe low-numbered lanes and VEC_UNPACK*LO_EXPR unpacks the high-numbered\nlanes.  This meant that both the SVE patterns and the handling of\nfully-masked loops were wrong.\n\nThe patch deals with that by making sure that all vec_unpack* optabs\nare define_expands, using BYTES_BIG_ENDIAN to choose the appropriate\ndefine_insn.  This in turn meant that we can get rid of the duplication\nbetween the signed and unsigned patterns for predicates.  (We provide\nimplementations of both the signed and unsigned optabs because the sign\ndoesn't matter for predicates: every element contains only one\nsignificant bit.)\n\nAlso, the float unpacks need to unpack one half of the input vector,\nbut the unpacked upper bits are \"don't care\".  There are two obvious\nways of handling that: use an unpack (filling with zeros) or use a ZIP\n(filling with a duplicate of the low bits).  The code previously used\nunpacks, but the sequence involved a subreg that is semantically an\nelement reverse on big-endian targets.  Using the ZIP patterns avoids\nthat, and at the moment there's no reason to prefer one over the other\nfor performance reasons, so the patch switches to ZIP unconditionally.\nAs the comment says, it would be easy to optimise this later if UUNPK\nturns out to be better for some implementations.\n\n2018-03-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vect-loop-manip.c (vect_maybe_permute_loop_masks):\n\tReverse the choice between VEC_UNPACK_LO_EXPR and VEC_UNPACK_HI_EXPR\n\tfor big-endian.\n\t* config/aarch64/iterators.md (hi_lanes_optab): New int attribute.\n\t* config/aarch64/aarch64-sve.md\n\t(*aarch64_sve_<perm_insn><perm_hilo><mode>): Rename to...\n\t(aarch64_sve_<perm_insn><perm_hilo><mode>): ...this.\n\t(*extend<mode><Vwide>2): Rename to...\n\t(aarch64_sve_extend<mode><Vwide>2): ...this.\n\t(vec_unpack<su>_<perm_hilo>_<mode>): Turn into a define_expand,\n\trenaming the old pattern to...\n\t(aarch64_sve_punpk<perm_hilo>_<mode>): ...this.  Only define\n\tunsigned packs.\n\t(vec_unpack<su>_<perm_hilo>_<SVE_BHSI:mode>): Turn into a\n\tdefine_expand, renaming the old pattern to...\n\t(aarch64_sve_<su>unpk<perm_hilo>_<SVE_BHSI:mode>): ...this.\n\t(*vec_unpacku_<perm_hilo>_<mode>_no_convert): Delete.\n\t(vec_unpacks_<perm_hilo>_<mode>): Take BYTES_BIG_ENDIAN into\n\taccount when deciding which SVE instruction the optab should use.\n\t(vec_unpack<su_optab>_float_<perm_hilo>_vnx4si): Likewise.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/unpack_fcvt_signed_1.c: Expect zips rather\n\tthan unpacks.\n\t* gcc.target/aarch64/sve/unpack_fcvt_unsigned_1.c: Likewise.\n\t* gcc.target/aarch64/sve/unpack_float_1.c: Likewise.\n\nFrom-SVN: r258489", "tree": {"sha": "441543123e7d06028b9fbd87da8bb03bbcb2837a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/441543123e7d06028b9fbd87da8bb03bbcb2837a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/comments", "author": null, "committer": null, "parents": [{"sha": "80c13ac5ec1a584561a2c474a5d61e7881ef4f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80c13ac5ec1a584561a2c474a5d61e7881ef4f82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80c13ac5ec1a584561a2c474a5d61e7881ef4f82"}], "stats": {"total": 170, "additions": 123, "deletions": 47}, "files": [{"sha": "4a6f4d47b60d35cf62fc627f54836f6d528acd6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "patch": "@@ -1,3 +1,26 @@\n+2018-03-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vect-loop-manip.c (vect_maybe_permute_loop_masks):\n+\tReverse the choice between VEC_UNPACK_LO_EXPR and VEC_UNPACK_HI_EXPR\n+\tfor big-endian.\n+\t* config/aarch64/iterators.md (hi_lanes_optab): New int attribute.\n+\t* config/aarch64/aarch64-sve.md\n+\t(*aarch64_sve_<perm_insn><perm_hilo><mode>): Rename to...\n+\t(aarch64_sve_<perm_insn><perm_hilo><mode>): ...this.\n+\t(*extend<mode><Vwide>2): Rename to...\n+\t(aarch64_sve_extend<mode><Vwide>2): ...this.\n+\t(vec_unpack<su>_<perm_hilo>_<mode>): Turn into a define_expand,\n+\trenaming the old pattern to...\n+\t(aarch64_sve_punpk<perm_hilo>_<mode>): ...this.  Only define\n+\tunsigned packs.\n+\t(vec_unpack<su>_<perm_hilo>_<SVE_BHSI:mode>): Turn into a\n+\tdefine_expand, renaming the old pattern to...\n+\t(aarch64_sve_<su>unpk<perm_hilo>_<SVE_BHSI:mode>): ...this.\n+\t(*vec_unpacku_<perm_hilo>_<mode>_no_convert): Delete.\n+\t(vec_unpacks_<perm_hilo>_<mode>): Take BYTES_BIG_ENDIAN into\n+\taccount when deciding which SVE instruction the optab should use.\n+\t(vec_unpack<su_optab>_float_<perm_hilo>_vnx4si): Likewise.\n+\n 2018-03-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* config/aarch64/aarch64.md (V4_REGNUM, V8_REGNUM, V12_REGNUM)"}, {"sha": "d88553405094853ab58ba1c55cd212092a14116c", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 76, "deletions": 40, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "patch": "@@ -817,7 +817,7 @@\n   \"<perm_insn><perm_hilo>\\t%0.<Vetype>, %1.<Vetype>, %2.<Vetype>\"\n )\n \n-(define_insn \"*aarch64_sve_<perm_insn><perm_hilo><mode>\"\n+(define_insn \"aarch64_sve_<perm_insn><perm_hilo><mode>\"\n   [(set (match_operand:SVE_ALL 0 \"register_operand\" \"=w\")\n \t(unspec:SVE_ALL [(match_operand:SVE_ALL 1 \"register_operand\" \"w\")\n \t\t\t (match_operand:SVE_ALL 2 \"register_operand\" \"w\")]\n@@ -2184,7 +2184,7 @@\n )\n \n ;; Conversion of DI or SI to DF, predicated with a PTRUE.\n-(define_insn \"*<optab><mode>vnx2df2\"\n+(define_insn \"aarch64_sve_<optab><mode>vnx2df2\"\n   [(set (match_operand:VNx2DF 0 \"register_operand\" \"=w\")\n \t(unspec:VNx2DF\n \t  [(match_operand:VNx2BI 1 \"register_operand\" \"Upl\")\n@@ -2211,7 +2211,7 @@\n \n ;; Conversion of SFs to the same number of DFs, or HFs to the same number\n ;; of SFs.\n-(define_insn \"*extend<mode><Vwide>2\"\n+(define_insn \"aarch64_sve_extend<mode><Vwide>2\"\n   [(set (match_operand:<VWIDE> 0 \"register_operand\" \"=w\")\n \t(unspec:<VWIDE>\n \t  [(match_operand:<VWIDE_PRED> 1 \"register_operand\" \"Upl\")\n@@ -2223,69 +2223,105 @@\n   \"fcvt\\t%0.<Vewtype>, %1/m, %2.<Vetype>\"\n )\n \n+;; Unpack the low or high half of a predicate, where \"high\" refers to\n+;; the low-numbered lanes for big-endian and the high-numbered lanes\n+;; for little-endian.\n+(define_expand \"vec_unpack<su>_<perm_hilo>_<mode>\"\n+  [(match_operand:<VWIDE> 0 \"register_operand\")\n+   (unspec:<VWIDE> [(match_operand:PRED_BHS 1 \"register_operand\")]\n+\t\t   UNPACK)]\n+  \"TARGET_SVE\"\n+  {\n+    emit_insn ((<hi_lanes_optab>\n+\t\t? gen_aarch64_sve_punpkhi_<PRED_BHS:mode>\n+\t\t: gen_aarch64_sve_punpklo_<PRED_BHS:mode>)\n+\t       (operands[0], operands[1]));\n+    DONE;\n+  }\n+)\n+\n ;; PUNPKHI and PUNPKLO.\n-(define_insn \"vec_unpack<su>_<perm_hilo>_<mode>\"\n+(define_insn \"aarch64_sve_punpk<perm_hilo>_<mode>\"\n   [(set (match_operand:<VWIDE> 0 \"register_operand\" \"=Upa\")\n \t(unspec:<VWIDE> [(match_operand:PRED_BHS 1 \"register_operand\" \"Upa\")]\n-\t\t\tUNPACK))]\n+\t\t\tUNPACK_UNSIGNED))]\n   \"TARGET_SVE\"\n   \"punpk<perm_hilo>\\t%0.h, %1.b\"\n )\n \n+;; Unpack the low or high half of a vector, where \"high\" refers to\n+;; the low-numbered lanes for big-endian and the high-numbered lanes\n+;; for little-endian.\n+(define_expand \"vec_unpack<su>_<perm_hilo>_<SVE_BHSI:mode>\"\n+  [(match_operand:<VWIDE> 0 \"register_operand\")\n+   (unspec:<VWIDE> [(match_operand:SVE_BHSI 1 \"register_operand\")] UNPACK)]\n+  \"TARGET_SVE\"\n+  {\n+    emit_insn ((<hi_lanes_optab>\n+\t\t? gen_aarch64_sve_<su>unpkhi_<SVE_BHSI:mode>\n+\t\t: gen_aarch64_sve_<su>unpklo_<SVE_BHSI:mode>)\n+\t       (operands[0], operands[1]));\n+    DONE;\n+  }\n+)\n+\n ;; SUNPKHI, UUNPKHI, SUNPKLO and UUNPKLO.\n-(define_insn \"vec_unpack<su>_<perm_hilo>_<SVE_BHSI:mode>\"\n+(define_insn \"aarch64_sve_<su>unpk<perm_hilo>_<SVE_BHSI:mode>\"\n   [(set (match_operand:<VWIDE> 0 \"register_operand\" \"=w\")\n \t(unspec:<VWIDE> [(match_operand:SVE_BHSI 1 \"register_operand\" \"w\")]\n \t\t\tUNPACK))]\n   \"TARGET_SVE\"\n   \"<su>unpk<perm_hilo>\\t%0.<Vewtype>, %1.<Vetype>\"\n )\n \n-;; Used by the vec_unpacks_<perm_hilo>_<mode> expander to unpack the bit\n-;; representation of a VNx4SF or VNx8HF without conversion.  The choice\n-;; between signed and unsigned isn't significant.\n-(define_insn \"*vec_unpacku_<perm_hilo>_<mode>_no_convert\"\n-  [(set (match_operand:SVE_HSF 0 \"register_operand\" \"=w\")\n-\t(unspec:SVE_HSF [(match_operand:SVE_HSF 1 \"register_operand\" \"w\")]\n-\t\t\tUNPACK_UNSIGNED))]\n-  \"TARGET_SVE\"\n-  \"uunpk<perm_hilo>\\t%0.<Vewtype>, %1.<Vetype>\"\n-)\n-\n ;; Unpack one half of a VNx4SF to VNx2DF, or one half of a VNx8HF to VNx4SF.\n ;; First unpack the source without conversion, then float-convert the\n ;; unpacked source.\n (define_expand \"vec_unpacks_<perm_hilo>_<mode>\"\n-  [(set (match_dup 2)\n-\t(unspec:SVE_HSF [(match_operand:SVE_HSF 1 \"register_operand\")]\n-\t\t\tUNPACK_UNSIGNED))\n-   (set (match_operand:<VWIDE> 0 \"register_operand\")\n-\t(unspec:<VWIDE> [(match_dup 3)\n-\t\t\t (unspec:<VWIDE> [(match_dup 2)] UNSPEC_FLOAT_CONVERT)]\n-\t\t\tUNSPEC_MERGE_PTRUE))]\n-  \"TARGET_SVE\"\n-  {\n-    operands[2] = gen_reg_rtx (<MODE>mode);\n-    operands[3] = force_reg (<VWIDE_PRED>mode, CONSTM1_RTX (<VWIDE_PRED>mode));\n+  [(match_operand:<VWIDE> 0 \"register_operand\")\n+   (unspec:SVE_HSF [(match_operand:SVE_HSF 1 \"register_operand\")]\n+\t\t   UNPACK_UNSIGNED)]\n+  \"TARGET_SVE\"\n+  {\n+    /* Use ZIP to do the unpack, since we don't care about the upper halves\n+       and since it has the nice property of not needing any subregs.\n+       If using UUNPK* turns out to be preferable, we could model it as\n+       a ZIP whose first operand is zero.  */\n+    rtx temp = gen_reg_rtx (<MODE>mode);\n+    emit_insn ((<hi_lanes_optab>\n+\t\t? gen_aarch64_sve_zip2<mode>\n+\t\t: gen_aarch64_sve_zip1<mode>)\n+\t\t(temp, operands[1], operands[1]));\n+    rtx ptrue = force_reg (<VWIDE_PRED>mode, CONSTM1_RTX (<VWIDE_PRED>mode));\n+    emit_insn (gen_aarch64_sve_extend<mode><Vwide>2 (operands[0],\n+\t\t\t\t\t\t     ptrue, temp));\n+    DONE;\n   }\n )\n \n ;; Unpack one half of a VNx4SI to VNx2DF.  First unpack from VNx4SI\n ;; to VNx2DI, reinterpret the VNx2DI as a VNx4SI, then convert the\n ;; unpacked VNx4SI to VNx2DF.\n (define_expand \"vec_unpack<su_optab>_float_<perm_hilo>_vnx4si\"\n-  [(set (match_dup 2)\n-\t(unspec:VNx2DI [(match_operand:VNx4SI 1 \"register_operand\")]\n-\t\t       UNPACK_UNSIGNED))\n-   (set (match_operand:VNx2DF 0 \"register_operand\")\n-\t(unspec:VNx2DF [(match_dup 3)\n-\t\t\t(FLOATUORS:VNx2DF (match_dup 4))]\n-\t\t       UNSPEC_MERGE_PTRUE))]\n-  \"TARGET_SVE\"\n-  {\n-    operands[2] = gen_reg_rtx (VNx2DImode);\n-    operands[3] = force_reg (VNx2BImode, CONSTM1_RTX (VNx2BImode));\n-    operands[4] = gen_rtx_SUBREG (VNx4SImode, operands[2], 0);\n+  [(match_operand:VNx2DF 0 \"register_operand\")\n+   (FLOATUORS:VNx2DF\n+     (unspec:VNx2DI [(match_operand:VNx4SI 1 \"register_operand\")]\n+\t\t    UNPACK_UNSIGNED))]\n+  \"TARGET_SVE\"\n+  {\n+    /* Use ZIP to do the unpack, since we don't care about the upper halves\n+       and since it has the nice property of not needing any subregs.\n+       If using UUNPK* turns out to be preferable, we could model it as\n+       a ZIP whose first operand is zero.  */\n+    rtx temp = gen_reg_rtx (VNx4SImode);\n+    emit_insn ((<hi_lanes_optab>\n+\t        ? gen_aarch64_sve_zip2vnx4si\n+\t        : gen_aarch64_sve_zip1vnx4si)\n+\t       (temp, operands[1], operands[1]));\n+    rtx ptrue = force_reg (VNx2BImode, CONSTM1_RTX (VNx2BImode));\n+    emit_insn (gen_aarch64_sve_<FLOATUORS:optab>vnx4sivnx2df2 (operands[0],\n+\t\t\t\t\t\t\t       ptrue, temp));\n+    DONE;\n   }\n )\n "}, {"sha": "fa181794392d4dc48e9a6df5cf5db14a9824cd2d", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "patch": "@@ -1680,6 +1680,15 @@\n \t\t\t    (UNSPEC_UNPACKSHI \"hi\") (UNSPEC_UNPACKUHI \"hi\")\n \t\t\t    (UNSPEC_UNPACKSLO \"lo\") (UNSPEC_UNPACKULO \"lo\")])\n \n+;; Return true if the associated optab refers to the high-numbered lanes,\n+;; false if it refers to the low-numbered lanes.  The convention is for\n+;; \"hi\" to refer to the low-numbered lanes (the first ones in memory)\n+;; for big-endian.\n+(define_int_attr hi_lanes_optab [(UNSPEC_UNPACKSHI \"!BYTES_BIG_ENDIAN\")\n+\t\t\t\t (UNSPEC_UNPACKUHI \"!BYTES_BIG_ENDIAN\")\n+\t\t\t\t (UNSPEC_UNPACKSLO \"BYTES_BIG_ENDIAN\")\n+\t\t\t\t (UNSPEC_UNPACKULO \"BYTES_BIG_ENDIAN\")])\n+\n (define_int_attr frecp_suffix  [(UNSPEC_FRECPE \"e\") (UNSPEC_FRECPX \"x\")])\n \n (define_int_attr crc_variant [(UNSPEC_CRC32B \"crc32b\") (UNSPEC_CRC32H \"crc32h\")"}, {"sha": "cee70dc0bc9b8f567c7bdfdfcbdb90c5907199d0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "patch": "@@ -1,3 +1,10 @@\n+2018-03-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.target/aarch64/sve/unpack_fcvt_signed_1.c: Expect zips rather\n+\tthan unpacks.\n+\t* gcc.target/aarch64/sve/unpack_fcvt_unsigned_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/unpack_float_1.c: Likewise.\n+\n 2018-03-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.target/aarch64/sve/tls_1.c: New test."}, {"sha": "0f96dc2ff007340541c2ba7d51e1ccfa0f3f2d39", "filename": "gcc/testsuite/gcc.target/aarch64/sve/unpack_fcvt_signed_1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Funpack_fcvt_signed_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Funpack_fcvt_signed_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Funpack_fcvt_signed_1.c?ref=9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "patch": "@@ -10,6 +10,6 @@ unpack_double_int_plus8 (double *d, int32_t *s, int size)\n     d[i] = s[i] + 8;\n }\n \n-/* { dg-final { scan-assembler-times {\\tuunpklo\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 1 } } */\n-/* { dg-final { scan-assembler-times {\\tuunpkhi\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tzip1\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tzip2\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tscvtf\\tz[0-9]+\\.d, p[0-7]/m, z[0-9]+\\.s\\n} 2 } } */"}, {"sha": "70465f91eba4f80140b2059481eb8f06bbc9ace7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/unpack_fcvt_unsigned_1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Funpack_fcvt_unsigned_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Funpack_fcvt_unsigned_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Funpack_fcvt_unsigned_1.c?ref=9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "patch": "@@ -10,6 +10,6 @@ unpack_double_int_plus9 (double *d, uint32_t *s, int size)\n     d[i] = (double) (s[i] + 9);\n }\n \n-/* { dg-final { scan-assembler-times {\\tuunpklo\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 1 } } */\n-/* { dg-final { scan-assembler-times {\\tuunpkhi\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tzip1\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tzip2\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tucvtf\\tz[0-9]+\\.d, p[0-7]/m, z[0-9]+\\.s\\n} 2 } } */"}, {"sha": "deb4cf5e940b186fb11468fea27b697cc2737010", "filename": "gcc/testsuite/gcc.target/aarch64/sve/unpack_float_1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Funpack_float_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Funpack_float_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Funpack_float_1.c?ref=9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "patch": "@@ -8,6 +8,6 @@ unpack_float_plus_7point9 (double *d, float *s, int size)\n     d[i] = s[i] + 7.9;\n }\n \n-/* { dg-final { scan-assembler-times {\\tuunpklo\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 1 } } */\n-/* { dg-final { scan-assembler-times {\\tuunpkhi\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tzip1\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tzip2\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tfcvt\\tz[0-9]+\\.d, p[0-7]/m, z[0-9]+\\.s\\n} 2 } } */"}, {"sha": "1c43ed0becd58abc81ca12c527672ec55c4a0809", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfb28ed3c6fb702c2cab6798959679e1bbd7d09/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=9bfb28ed3c6fb702c2cab6798959679e1bbd7d09", "patch": "@@ -334,7 +334,8 @@ vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_masks *dest_rgm,\n \t{\n \t  tree src = src_rgm->masks[i / 2];\n \t  tree dest = dest_rgm->masks[i];\n-\t  tree_code code = (i & 1 ? VEC_UNPACK_HI_EXPR\n+\t  tree_code code = ((i & 1) == (BYTES_BIG_ENDIAN ? 0 : 1)\n+\t\t\t    ? VEC_UNPACK_HI_EXPR\n \t\t\t    : VEC_UNPACK_LO_EXPR);\n \t  gassign *stmt;\n \t  if (dest_masktype == unpack_masktype)"}]}