{"sha": "95e3eb80a8148663288821987ffab98e0b30062b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVlM2ViODBhODE0ODY2MzI4ODgyMTk4N2ZmYWI5OGUwYjMwMDYyYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-11-22T21:35:24Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-11-22T21:35:24Z"}, "message": "i386.c (ix86_option_override_internal, [...]): Formatting fixes.\n\n\t* config/i386/i386.c (ix86_option_override_internal,\n\tix86_can_inline_p, classify_argument, construct_container,\n\tix86_expand_prologue, ix86_expand_split_stack_prologue,\n\tix86_expand_carry_flag_compare, expand_set_or_movmem_via_loop,\n\texpand_setmem_epilogue_via_loop, promote_duplicated_reg,\n\tix86_expand_set_or_movmem, ix86_init_builtins_va_builtins_abi):\n\tFormatting fixes.\n\nFrom-SVN: r266391", "tree": {"sha": "6bc8fa8cbc14b415f34c6bdf5bb02deb297caeec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bc8fa8cbc14b415f34c6bdf5bb02deb297caeec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95e3eb80a8148663288821987ffab98e0b30062b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e3eb80a8148663288821987ffab98e0b30062b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95e3eb80a8148663288821987ffab98e0b30062b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e3eb80a8148663288821987ffab98e0b30062b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7433f32ecdfe959fc1bea8e330a73693b478d0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7433f32ecdfe959fc1bea8e330a73693b478d0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7433f32ecdfe959fc1bea8e330a73693b478d0b"}], "stats": {"total": 127, "additions": 64, "deletions": 63}, "files": [{"sha": "58eb3af41c5f352eaede3d284ef93a81ae1efef3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e3eb80a8148663288821987ffab98e0b30062b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e3eb80a8148663288821987ffab98e0b30062b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95e3eb80a8148663288821987ffab98e0b30062b", "patch": "@@ -1,5 +1,13 @@\n 2018-11-22  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* config/i386/i386.c (ix86_option_override_internal,\n+\tix86_can_inline_p, classify_argument, construct_container,\n+\tix86_expand_prologue, ix86_expand_split_stack_prologue,\n+\tix86_expand_carry_flag_compare, expand_set_or_movmem_via_loop,\n+\texpand_setmem_epilogue_via_loop, promote_duplicated_reg,\n+\tix86_expand_set_or_movmem, ix86_init_builtins_va_builtins_abi):\n+\tFormatting fixes.\n+\n \t* config/i386/i386.c (ix86_option_override_internal): For\n \tstack_protector_guard related options, use opts_set->x_ instead\n \tof global_options_set. and prefix options with opts->x_ .  Move"}, {"sha": "ef585333448a15691fba5d9d9956ebd980a75a38", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 56, "deletions": 63, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e3eb80a8148663288821987ffab98e0b30062b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e3eb80a8148663288821987ffab98e0b30062b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=95e3eb80a8148663288821987ffab98e0b30062b", "patch": "@@ -4658,8 +4658,8 @@ ix86_option_override_internal (bool main_args_p,\n       = build_target_option_node (opts);\n \n   if (opts->x_flag_cf_protection != CF_NONE)\n-    opts->x_flag_cf_protection =\n-      (cf_protection_level) (opts->x_flag_cf_protection | CF_SET);\n+    opts->x_flag_cf_protection\n+      = (cf_protection_level) (opts->x_flag_cf_protection | CF_SET);\n \n   if (ix86_tune_features [X86_TUNE_AVOID_128FMA_CHAINS])\n     maybe_set_param_value (PARAM_AVOID_FMA_MAX_BITS, 128,\n@@ -5475,10 +5475,10 @@ ix86_can_inline_p (tree caller, tree callee)\n   struct cl_target_option *caller_opts = TREE_TARGET_OPTION (caller_tree);\n   struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);\n   bool ret = false;\n-  bool always_inline =\n-     (DECL_DISREGARD_INLINE_LIMITS (callee)\n-      && lookup_attribute (\"always_inline\",\n-\t\t\t   DECL_ATTRIBUTES (callee)));\n+  bool always_inline\n+    = (DECL_DISREGARD_INLINE_LIMITS (callee)\n+       && lookup_attribute (\"always_inline\",\n+\t\t\t    DECL_ATTRIBUTES (callee)));\n \n   cgraph_node *callee_node = cgraph_node::get (callee);\n   /* Callee's isa options should be a subset of the caller's, i.e. a SSE4\n@@ -7375,8 +7375,8 @@ static int\n classify_argument (machine_mode mode, const_tree type,\n \t\t   enum x86_64_reg_class classes[MAX_CLASSES], int bit_offset)\n {\n-  HOST_WIDE_INT bytes =\n-    (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n+  HOST_WIDE_INT bytes\n+    = mode == BLKmode ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n   int words = CEIL (bytes + (bit_offset % 64) / 8, UNITS_PER_WORD);\n \n   /* Variable sized entities are always passed/returned in memory.  */\n@@ -7432,9 +7432,8 @@ classify_argument (machine_mode mode, const_tree type,\n \t\t\t   i < ((int_bit_position (field) + (bit_offset % 64))\n \t\t\t        + tree_to_shwi (DECL_SIZE (field))\n \t\t\t\t+ 63) / 8 / 8; i++)\n-\t\t\tclasses[i] =\n-\t\t\t  merge_classes (X86_64_INTEGER_CLASS,\n-\t\t\t\t\t classes[i]);\n+\t\t\tclasses[i]\n+\t\t\t  = merge_classes (X86_64_INTEGER_CLASS, classes[i]);\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -7471,8 +7470,8 @@ classify_argument (machine_mode mode, const_tree type,\n \t\t      pos = (int_bit_position (field)\n \t\t\t     + (bit_offset % 64)) / 8 / 8;\n \t\t      for (i = 0; i < num && (i + pos) < words; i++)\n-\t\t\tclasses[i + pos] =\n-\t\t\t  merge_classes (subclasses[i], classes[i + pos]);\n+\t\t\tclasses[i + pos]\n+\t\t\t  = merge_classes (subclasses[i], classes[i + pos]);\n \t\t    }\n \t\t}\n \t    }\n@@ -7827,8 +7826,8 @@ construct_container (machine_mode mode, machine_mode orig_mode,\n   static bool issued_x87_ret_error;\n \n   machine_mode tmpmode;\n-  int bytes =\n-    (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n+  int bytes\n+    = mode == BLKmode ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n   enum x86_64_reg_class regclass[MAX_CLASSES];\n   int n;\n   int i;\n@@ -13369,8 +13368,8 @@ ix86_expand_prologue (void)\n       && frame.stack_pointer_offset > SEH_MAX_FRAME_SIZE\n       && !sse_registers_saved)\n     {\n-      HOST_WIDE_INT sse_size =\n-\tframe.sse_reg_save_offset - frame.reg_save_offset;\n+      HOST_WIDE_INT sse_size\n+\t= frame.sse_reg_save_offset - frame.reg_save_offset;\n \n       gcc_assert (int_registers_saved);\n \n@@ -14651,8 +14650,8 @@ ix86_expand_split_stack_prologue (void)\n \n \t  if (split_stack_fn_large == NULL_RTX)\n \t    {\n-\t      split_stack_fn_large =\n-\t        gen_rtx_SYMBOL_REF (Pmode, \"__morestack_large_model\");\n+\t      split_stack_fn_large\n+\t\t= gen_rtx_SYMBOL_REF (Pmode, \"__morestack_large_model\");\n \t      SYMBOL_REF_FLAGS (split_stack_fn_large) |= SYMBOL_FLAG_LOCAL;\n \t    }\n \t  if (ix86_cmodel == CM_LARGE_PIC)\n@@ -22700,8 +22699,8 @@ ix86_expand_setcc (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n static bool\n ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n {\n-  machine_mode mode =\n-    GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n+  machine_mode mode\n+    = GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n \n   /* Do not handle double-mode compares that go through special path.  */\n   if (mode == (TARGET_64BIT ? TImode : DImode))\n@@ -25839,10 +25838,10 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n \t    {\n \t      if (i)\n \t\t{\n-\t\t  destmem =\n-\t\t    adjust_address (copy_rtx (destmem), mode, GET_MODE_SIZE (mode));\n-\t\t  srcmem =\n-\t\t    adjust_address (copy_rtx (srcmem), mode, GET_MODE_SIZE (mode));\n+\t\t  destmem = adjust_address (copy_rtx (destmem), mode,\n+\t\t\t\t\t    GET_MODE_SIZE (mode));\n+\t\t  srcmem = adjust_address (copy_rtx (srcmem), mode,\n+\t\t\t\t\t   GET_MODE_SIZE (mode));\n \t\t}\n \t      emit_move_insn (destmem, srcmem);\n \t    }\n@@ -25855,19 +25854,15 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n \t    {\n \t      tmpreg[i] = gen_reg_rtx (mode);\n \t      if (i)\n-\t\t{\n-\t\t  srcmem =\n-\t\t    adjust_address (copy_rtx (srcmem), mode, GET_MODE_SIZE (mode));\n-\t\t}\n+\t\tsrcmem = adjust_address (copy_rtx (srcmem), mode,\n+\t\t\t\t\t GET_MODE_SIZE (mode));\n \t      emit_move_insn (tmpreg[i], srcmem);\n \t    }\n \t  for (i = 0; i < unroll; i++)\n \t    {\n \t      if (i)\n-\t\t{\n-\t\t  destmem =\n-\t\t    adjust_address (copy_rtx (destmem), mode, GET_MODE_SIZE (mode));\n-\t\t}\n+\t\tdestmem = adjust_address (copy_rtx (destmem), mode,\n+\t\t\t\t\t  GET_MODE_SIZE (mode));\n \t      emit_move_insn (destmem, tmpreg[i]);\n \t    }\n \t}\n@@ -25876,8 +25871,8 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n     for (i = 0; i < unroll; i++)\n       {\n \tif (i)\n-\t  destmem =\n-\t    adjust_address (copy_rtx (destmem), mode, GET_MODE_SIZE (mode));\n+\t  destmem = adjust_address (copy_rtx (destmem), mode,\n+\t\t\t\t    GET_MODE_SIZE (mode));\n \temit_move_insn (destmem, value);\n       }\n \n@@ -25896,7 +25891,8 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n       else if (expected_size > REG_BR_PROB_BASE)\n \tpredict_jump (REG_BR_PROB_BASE - 1);\n       else\n-        predict_jump (REG_BR_PROB_BASE - (REG_BR_PROB_BASE + expected_size / 2) / expected_size);\n+        predict_jump (REG_BR_PROB_BASE - (REG_BR_PROB_BASE + expected_size / 2)\n+\t\t      / expected_size);\n     }\n   else\n     predict_jump (REG_BR_PROB_BASE * 80 / 100);\n@@ -26239,9 +26235,8 @@ static void\n expand_setmem_epilogue_via_loop (rtx destmem, rtx destptr, rtx value,\n \t\t\t\t rtx count, int max_size)\n {\n-  count =\n-    expand_simple_binop (counter_mode (count), AND, count,\n-\t\t\t GEN_INT (max_size - 1), count, 1, OPTAB_DIRECT);\n+  count = expand_simple_binop (counter_mode (count), AND, count,\n+\t\t\t       GEN_INT (max_size - 1), count, 1, OPTAB_DIRECT);\n   expand_set_or_movmem_via_loop (destmem, NULL, destptr, NULL,\n \t\t\t\t gen_lowpart (QImode, value), count, QImode,\n \t\t\t\t 1, max_size / 2, true);\n@@ -27051,8 +27046,8 @@ promote_duplicated_reg (machine_mode mode, rtx val)\n \t{\n \t  tmp = expand_simple_binop (mode, ASHIFT, reg, GEN_INT (8),\n \t\t\t\t     NULL, 1, OPTAB_DIRECT);\n-\t  reg =\n-\t    expand_simple_binop (mode, IOR, reg, tmp, reg, 1, OPTAB_DIRECT);\n+\t  reg = expand_simple_binop (mode, IOR, reg, tmp, reg, 1,\n+\t\t\t\t     OPTAB_DIRECT);\n \t}\n       tmp = expand_simple_binop (mode, ASHIFT, reg, GEN_INT (16),\n \t\t\t         NULL, 1, OPTAB_DIRECT);\n@@ -27586,10 +27581,9 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \n       if (size_needed < epilogue_size_needed)\n \t{\n-\t  tmp =\n-\t    expand_simple_binop (counter_mode (count_exp), AND, count_exp,\n-\t\t\t\t GEN_INT (size_needed - 1), count_exp, 1,\n-\t\t\t\t OPTAB_DIRECT);\n+\t  tmp = expand_simple_binop (counter_mode (count_exp), AND, count_exp,\n+\t\t\t\t     GEN_INT (size_needed - 1), count_exp, 1,\n+\t\t\t\t     OPTAB_DIRECT);\n \t  if (tmp != count_exp)\n \t    emit_move_insn (count_exp, tmp);\n \t}\n@@ -33378,24 +33372,23 @@ ix86_init_builtins_va_builtins_abi (void)\n   fnattr_ms = build_tree_list (get_identifier (\"ms_abi\"), NULL_TREE);\n   fnattr_sysv = build_tree_list (get_identifier (\"sysv_abi\"), NULL_TREE);\n   ms_va_ref = build_reference_type (ms_va_list_type_node);\n-  sysv_va_ref =\n-    build_pointer_type (TREE_TYPE (sysv_va_list_type_node));\n-\n-  fnvoid_va_end_ms =\n-    build_function_type_list (void_type_node, ms_va_ref, NULL_TREE);\n-  fnvoid_va_start_ms =\n-    build_varargs_function_type_list (void_type_node, ms_va_ref, NULL_TREE);\n-  fnvoid_va_end_sysv =\n-    build_function_type_list (void_type_node, sysv_va_ref, NULL_TREE);\n-  fnvoid_va_start_sysv =\n-    build_varargs_function_type_list (void_type_node, sysv_va_ref,\n-    \t\t\t\t       NULL_TREE);\n-  fnvoid_va_copy_ms =\n-    build_function_type_list (void_type_node, ms_va_ref, ms_va_list_type_node,\n-    \t\t\t      NULL_TREE);\n-  fnvoid_va_copy_sysv =\n-    build_function_type_list (void_type_node, sysv_va_ref,\n-    \t\t\t      sysv_va_ref, NULL_TREE);\n+  sysv_va_ref = build_pointer_type (TREE_TYPE (sysv_va_list_type_node));\n+\n+  fnvoid_va_end_ms = build_function_type_list (void_type_node, ms_va_ref,\n+\t\t\t\t\t       NULL_TREE);\n+  fnvoid_va_start_ms\n+    = build_varargs_function_type_list (void_type_node, ms_va_ref, NULL_TREE);\n+  fnvoid_va_end_sysv\n+    = build_function_type_list (void_type_node, sysv_va_ref, NULL_TREE);\n+  fnvoid_va_start_sysv\n+    = build_varargs_function_type_list (void_type_node, sysv_va_ref,\n+\t\t\t\t\tNULL_TREE);\n+  fnvoid_va_copy_ms\n+    = build_function_type_list (void_type_node, ms_va_ref,\n+\t\t\t\tms_va_list_type_node, NULL_TREE);\n+  fnvoid_va_copy_sysv\n+    = build_function_type_list (void_type_node, sysv_va_ref,\n+\t\t\t\tsysv_va_ref, NULL_TREE);\n \n   add_builtin_function (\"__builtin_ms_va_start\", fnvoid_va_start_ms,\n   \t\t\tBUILT_IN_VA_START, BUILT_IN_NORMAL, NULL, fnattr_ms);"}]}