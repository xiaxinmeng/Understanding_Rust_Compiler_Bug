{"sha": "5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUzNmI2MWMxZTJhODQ5ZjI5ZTFhNGQ5OTkxY2M4NWMyZTI0YzhjNw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2003-11-27T17:56:05Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-11-27T17:56:05Z"}, "message": "re PR libstdc++/11544 (wifstream conversion errors result in wrong rdstate())\n\n2003-11-27  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/11544\n\tPR libstdc++/11603\n\t* include/bits/fstream.tcc (underflow): Throw ios_base:failure\n\tupon incomplete or invalid byte sequences in the file.\n\t* testsuite/27_io/basic_filebuf/underflow/wchar_t/11544-1.cc: New.\n\t* testsuite/27_io/basic_filebuf/underflow/wchar_t/11544-2.cc: New.\n\t* testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc: New.\n\nFrom-SVN: r74000", "tree": {"sha": "b67fd3f002c2a7bc3de9e3d78dd0af338a2c7a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b67fd3f002c2a7bc3de9e3d78dd0af338a2c7a96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7/comments", "author": null, "committer": null, "parents": [{"sha": "c9ae693dcf516cdda79ee17f4942aaf61b307a9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9ae693dcf516cdda79ee17f4942aaf61b307a9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9ae693dcf516cdda79ee17f4942aaf61b307a9c"}], "stats": {"total": 592, "additions": 589, "deletions": 3}, "files": [{"sha": "cc6d881a14fd2e482653a34eba790e6c656bad2a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7", "patch": "@@ -1,3 +1,13 @@\n+2003-11-27  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/11544\n+\tPR libstdc++/11603\n+\t* include/bits/fstream.tcc (underflow): Throw ios_base:failure\n+\tupon incomplete or invalid byte sequences in the file.\n+\t* testsuite/27_io/basic_filebuf/underflow/wchar_t/11544-1.cc: New.\n+\t* testsuite/27_io/basic_filebuf/underflow/wchar_t/11544-2.cc: New.\n+\t* testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc: New.\n+\n 2003-11-27  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/std/std_streambuf.h (__copy_streambufs): Remove"}, {"sha": "db46588d00fa38adea7e3cd66ca69468fb78821a", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7", "patch": "@@ -201,6 +201,7 @@ namespace std\n \t  bool __got_eof = false;\n \t  // Number of internal characters produced.\n \t  streamsize __ilen = 0;\n+\t  codecvt_base::result __r = codecvt_base::ok;\t  \n \t  if (__check_facet(_M_codecvt).always_noconv())\n \t    {\n \t      __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()), \n@@ -261,9 +262,8 @@ namespace std\n \t\t\t__got_eof = true;\n \t\t      _M_ext_end += __elen;\n \t\t    }\n-\t\t  \n+\n \t\t  char_type* __iend;\n-\t\t  codecvt_base::result __r;\n \t\t  __r = _M_codecvt->in(_M_state_cur, _M_ext_next,\n \t\t\t\t       _M_ext_end, _M_ext_next, this->eback(), \n \t\t\t\t       this->eback() + __buflen, __iend);\n@@ -277,7 +277,7 @@ namespace std\n \t\t    }\n \t\t  else\n \t\t    __ilen = __iend - this->eback();\n-\t\t  \n+\n \t\t  // _M_codecvt->in may return error while __ilen > 0: this is\n \t\t  // ok, and actually occurs in case of mixed encodings (e.g.,\n \t\t  // XML files).\n@@ -302,7 +302,13 @@ namespace std\n \t      // intervening seek.\n \t      _M_set_buffer(-1);\n \t      _M_reading = false;\n+\t      // However, reaching it while looping on partial means that\n+\t      // the file has got an incomplete character.\n+\t      if (__r == codecvt_base::partial)\n+\t\t__throw_ios_failure(\"incomplete character in file\");\n \t    }\n+\t  else if (__r == codecvt_base::error)\n+\t    __throw_ios_failure(\"invalid byte sequence in file\");\n \t}\n       return __ret;\n     }"}, {"sha": "91d92e4d12746d043c1d4b60b541fa2e2fb28833", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/11544-1.cc", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F11544-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F11544-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F11544-1.cc?ref=5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7", "patch": "@@ -0,0 +1,185 @@\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 27.8.1.4 Overridden virtual functions\n+\n+#include <fstream>\n+#include <locale>\n+#include <cstdio>\n+#include <testsuite_hooks.h>\n+\n+template <typename InternT, typename StateT = mbstate_t>\n+class checksumcvt : public std::codecvt<InternT, char, StateT>\n+{\n+  typedef std::codecvt<InternT, char, StateT> Base;\n+  static const size_t width = sizeof(InternT) + 1;\n+\n+public:\n+  typedef InternT intern_type;\n+  typedef char extern_type;\n+\n+  explicit checksumcvt(size_t refs = 0)\n+  : Base(refs)\n+  { }\n+\n+protected:\n+  virtual typename std::codecvt<InternT, char, StateT>::result\n+  do_out(StateT&, const intern_type* from,\n+\t const intern_type* from_end, const intern_type*& from_next,\n+\t extern_type* to, extern_type* to_end,\n+\t extern_type*& to_next) const\n+  {\n+    size_t len = std::min(static_cast<size_t>(from_end - from),\n+\t\t\t  static_cast<size_t>(to_end - to) / width);\n+\n+    while (len--)\n+      {\n+\tconst char* p = reinterpret_cast<const char*>(from);\n+\tunsigned char checksum = 0;\n+\t\t\t\t\n+\tfor (size_t i = 0; i < sizeof(intern_type); ++i)\n+\t  {\n+\t    *to++ = p[i];\n+\t    checksum ^= static_cast<unsigned char>(p[i]);\n+\t  }\n+\n+\t*to++ = checksum;\n+\t++from;\n+      }\n+\n+    from_next = from;\n+    to_next = to;\n+    return from_next == from_end ? std::codecvt<InternT, char, StateT>::ok\n+           : std::codecvt<InternT, char, StateT>::partial;\n+  }\n+\n+  virtual typename std::codecvt<InternT, char, StateT>::result\n+  do_unshift(StateT&, extern_type* to,\n+\t     extern_type*, extern_type*& to_next) const\n+  {\n+    to_next = to;\n+    return std::codecvt<InternT, char, StateT>::ok;\n+  }\n+\n+  virtual typename std::codecvt<InternT, char, StateT>::result\n+  do_in(StateT&, const extern_type* from,\n+\tconst extern_type* from_end, const extern_type*& from_next,\n+\tintern_type* to, intern_type* to_end,\n+\tintern_type*& to_next) const\n+  {\n+    size_t len = std::min(static_cast<size_t>(to_end - to),\n+\t\t\t  static_cast<size_t>(from_end - from) / width);\n+\t\t\t\n+    while (len)\n+      {\n+\tconst char* f = from;\n+\tintern_type tmp;\n+\tchar* p = reinterpret_cast<char*>(&tmp);\n+\tunsigned char checksum = 0;\n+\n+\tfor (size_t i = 0; i < sizeof(intern_type); ++i)\n+\t  {\n+\t    p[i] = *f;\n+\t    checksum ^= static_cast<unsigned char>(*f++);\n+\t  }\n+\n+\tif (*f++ != checksum)\n+\t  break;\n+\n+\tfrom = f;\n+\t*to++ = tmp;\n+\tlen--;\n+      }\n+\n+    from_next = from;\n+    to_next = to;\n+    return len ? std::codecvt<InternT, char, StateT>::error :\n+      (from_next == from_end ? std::codecvt<InternT, char, StateT>::ok\n+       : std::codecvt<InternT, char, StateT>::partial);\n+  }\n+\n+  virtual int\n+  do_encoding() const throw()\n+  { return width; }\n+\n+  virtual int\n+  do_length(StateT&, const extern_type* from,\n+\t    const extern_type* end, size_t max) const\n+  {\n+    size_t len = std::min(max, static_cast<size_t>(end - from) / width);\n+\n+    int ret = 0;\n+    while (len--)\n+      {\n+\tunsigned char checksum = 0;\n+\n+\tfor (size_t i = 0; i < sizeof(intern_type); ++i)\n+\t  {\n+\t    checksum ^= static_cast<unsigned char>(*from++);\n+\t  }\n+\n+\tif (*from++ != checksum)\n+\t  break;\n+\n+\tret++;\n+      }\n+\n+    return ret;\n+  }\n+\n+  virtual int\n+  do_max_length() const throw()\n+  { return width; }\n+\n+  virtual bool\n+  do_always_noconv() const throw()\n+  { return false; }\n+};\n+\n+// libstdc++/11544 (incomplete character in file)\n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  locale loc(locale::classic(), new checksumcvt<wchar_t>);\n+\n+  const char* name = \"tmp_11544-1\";\n+  \n+  FILE* f = fopen(name, \"w\");\n+  putc('a', f);\n+  fclose(f);\n+  \n+  wifstream in;\n+  in.imbue(loc);\n+  in.open(name);\n+  \n+  VERIFY( in.good() );\n+  in.get();\n+  VERIFY( !in.good() );\n+  VERIFY( in.bad() );\n+  VERIFY( !in.eof() );\n+  \n+  in.close();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c5e617d7bdf737bf87496d11726227c2ae28fe4e", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/11544-2.cc", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F11544-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F11544-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F11544-2.cc?ref=5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7", "patch": "@@ -0,0 +1,185 @@\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 27.8.1.4 Overridden virtual functions\n+\n+#include <fstream>\n+#include <locale>\n+#include <cstdio>\n+#include <testsuite_hooks.h>\n+\n+template <typename InternT, typename StateT = mbstate_t>\n+class checksumcvt : public std::codecvt<InternT, char, StateT>\n+{\n+  typedef std::codecvt<InternT, char, StateT> Base;\n+  static const size_t width = sizeof(InternT) + 1;\n+\n+public:\n+  typedef InternT intern_type;\n+  typedef char extern_type;\n+\n+  explicit checksumcvt(size_t refs = 0)\n+  : Base(refs)\n+  { }\n+\n+protected:\n+  virtual typename std::codecvt<InternT, char, StateT>::result\n+  do_out(StateT&, const intern_type* from,\n+\t const intern_type* from_end, const intern_type*& from_next,\n+\t extern_type* to, extern_type* to_end,\n+\t extern_type*& to_next) const\n+  {\n+    size_t len = std::min(static_cast<size_t>(from_end - from),\n+\t\t\t  static_cast<size_t>(to_end - to) / width);\n+\n+    while (len--)\n+      {\n+\tconst char* p = reinterpret_cast<const char*>(from);\n+\tunsigned char checksum = 0;\n+\t\t\t\t\n+\tfor (size_t i = 0; i < sizeof(intern_type); ++i)\n+\t  {\n+\t    *to++ = p[i];\n+\t    checksum ^= static_cast<unsigned char>(p[i]);\n+\t  }\n+\n+\t*to++ = checksum;\n+\t++from;\n+      }\n+\n+    from_next = from;\n+    to_next = to;\n+    return from_next == from_end ? std::codecvt<InternT, char, StateT>::ok\n+           : std::codecvt<InternT, char, StateT>::partial;\n+  }\n+\n+  virtual typename std::codecvt<InternT, char, StateT>::result\n+  do_unshift(StateT&, extern_type* to,\n+\t     extern_type*, extern_type*& to_next) const\n+  {\n+    to_next = to;\n+    return std::codecvt<InternT, char, StateT>::ok;\n+  }\n+\n+  virtual typename std::codecvt<InternT, char, StateT>::result\n+  do_in(StateT&, const extern_type* from,\n+\tconst extern_type* from_end, const extern_type*& from_next,\n+\tintern_type* to, intern_type* to_end,\n+\tintern_type*& to_next) const\n+  {\n+    size_t len = std::min(static_cast<size_t>(to_end - to),\n+\t\t\t  static_cast<size_t>(from_end - from) / width);\n+\t\t\t\n+    while (len)\n+      {\n+\tconst char* f = from;\n+\tintern_type tmp;\n+\tchar* p = reinterpret_cast<char*>(&tmp);\n+\tunsigned char checksum = 0;\n+\n+\tfor (size_t i = 0; i < sizeof(intern_type); ++i)\n+\t  {\n+\t    p[i] = *f;\n+\t    checksum ^= static_cast<unsigned char>(*f++);\n+\t  }\n+\n+\tif (*f++ != checksum)\n+\t  break;\n+\n+\tfrom = f;\n+\t*to++ = tmp;\n+\tlen--;\n+      }\n+\n+    from_next = from;\n+    to_next = to;\n+    return len ? std::codecvt<InternT, char, StateT>::error :\n+      (from_next == from_end ? std::codecvt<InternT, char, StateT>::ok\n+       : std::codecvt<InternT, char, StateT>::partial);\n+  }\n+\n+  virtual int\n+  do_encoding() const throw()\n+  { return width; }\n+\n+  virtual int\n+  do_length(StateT&, const extern_type* from,\n+\t    const extern_type* end, size_t max) const\n+  {\n+    size_t len = std::min(max, static_cast<size_t>(end - from) / width);\n+\n+    int ret = 0;\n+    while (len--)\n+      {\n+\tunsigned char checksum = 0;\n+\n+\tfor (size_t i = 0; i < sizeof(intern_type); ++i)\n+\t  {\n+\t    checksum ^= static_cast<unsigned char>(*from++);\n+\t  }\n+\n+\tif (*from++ != checksum)\n+\t  break;\n+\n+\tret++;\n+      }\n+\n+    return ret;\n+  }\n+\n+  virtual int\n+  do_max_length() const throw()\n+  { return width; }\n+\n+  virtual bool\n+  do_always_noconv() const throw()\n+  { return false; }\n+};\n+\n+// libstdc++/11544 (invalid byte sequence in file)\n+void test02()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  locale loc(locale::classic(), new checksumcvt<wchar_t>);\n+  \n+  const char* name = \"tmp_11544-2\";\n+  \n+  FILE* f = fopen(name, \"w\");\n+  fwrite(\"aaaab\", 1, 5, f);\n+  fclose(f);\n+  \n+  wifstream in;\n+  in.imbue(loc);\n+  in.open(name);\n+  \n+  VERIFY( in.good() );\n+  in.get();\n+  VERIFY( !in.good() );\n+  VERIFY( in.bad() );\n+  VERIFY( !in.eof() );\n+  \n+  in.close();\n+}\n+\n+int main()\n+{\n+  test02();\n+  return 0;\n+}"}, {"sha": "6b827f15b6ea8932f31d18db489d4a4396a9b3f3", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F11603.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F11603.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F11603.cc?ref=5536b61c1e2a849f29e1a4d9991cc85c2e24c8c7", "patch": "@@ -0,0 +1,200 @@\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 27.8.1.4 Overridden virtual functions\n+\n+#include <fstream>\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+template <typename InternT, typename StateT = std::mbstate_t>\n+class checksumcvt : public std::codecvt<InternT, char, StateT>\n+{\n+  typedef std::codecvt<InternT, char, StateT> Base;\n+  static const std::size_t width = sizeof(InternT) + 1;\n+\n+public:\n+  typedef InternT intern_type;\n+  typedef char extern_type;\n+\n+  explicit checksumcvt(std::size_t refs = 0)\n+    : Base(refs)\n+  { }\n+\n+protected:\n+  virtual std::codecvt_base::result\n+  do_out(StateT&, const intern_type* from,\n+\t const intern_type* from_end, const intern_type*& from_next,\n+\t extern_type* to, extern_type* to_end,\n+\t extern_type*& to_next) const\n+  {\n+    size_t len = std::min(static_cast<size_t>(from_end - from),\n+\t\t\t  static_cast<size_t>(to_end - to) / width);\n+\n+    while (len--)\n+      {\n+\tconst char* p =\n+\t  reinterpret_cast<const char*>(from);\n+\tunsigned char checksum = 0;\n+\t\t\t\t\n+\tfor (std::size_t i = 0; i < sizeof(intern_type); ++i)\n+\t  {\n+\t    *to++ = p[i];\n+\t    checksum ^= static_cast<unsigned char>(p[i]);\n+\t  }\n+\n+\t*to++ = checksum;\n+\t++from;\n+      }\n+\n+    from_next = from;\n+    to_next = to;\n+    return from_next == from_end ? std::codecvt_base::ok \n+                                 : std::codecvt_base::partial;\n+  }\n+\n+  virtual std::codecvt_base::result\n+  do_unshift(StateT&, extern_type* to,\n+\t     extern_type*, extern_type*& to_next) const\n+  {\n+    to_next = to;\n+    return std::codecvt_base::ok;\n+  }\n+\n+  virtual std::codecvt_base::result\n+  do_in(StateT&, const extern_type* from,\n+\tconst extern_type* from_end, const extern_type*& from_next,\n+\tintern_type* to, intern_type* to_end,\n+\tintern_type*& to_next) const\n+  {\n+    size_t len = std::min(static_cast<size_t>(to_end - to),\n+\t\t\t  static_cast<size_t>(from_end - from) / width);\n+\t\t\t\n+    while (len)\n+      {\n+\tconst char* f = from;\n+\tintern_type tmp;\n+\tchar* p = reinterpret_cast<char*>(&tmp);\n+\tunsigned char checksum = 0;\n+\n+\tfor (std::size_t i = 0; i < sizeof(intern_type); ++i)\n+\t  {\n+\t    p[i] = *f;\n+\t    checksum ^= static_cast<unsigned char>(*f++);\n+\t  }\n+\n+\tif (*f++ != checksum)\n+\t  break;\n+\n+\tfrom = f;\n+\t*to++ = tmp;\n+\tlen--;\n+      }\n+\n+    from_next = from;\n+    to_next = to;\n+    return len ? std::codecvt_base::error :\n+      (from_next == from_end ? std::codecvt_base::ok\n+                             : std::codecvt_base::partial);\n+  }\n+\n+  virtual int\n+  do_encoding() const throw()\n+  { return width; }\n+\n+  virtual int\n+  do_length(const StateT&, const extern_type* from,\n+\t    const extern_type* end, size_t max) const\n+  {\n+    size_t len = std::min(max,\n+\t\t\t  static_cast<size_t>(end - from) / width);\n+\n+    int ret = 0;\n+    while (len--)\n+      {\n+\tunsigned char checksum = 0;\n+\n+\tfor (std::size_t i = 0; i < sizeof(intern_type); ++i)\n+\t  {\n+\t    checksum ^= static_cast<unsigned char>(*from++);\n+\t  }\n+\n+\tif (*from++ != checksum)\n+\t  break;\n+\n+\tret++;\n+      }\n+\n+    return ret;\n+  }\n+\n+  virtual int\n+  do_max_length() const throw()\n+  { return width; }\n+\n+  virtual bool\n+  do_always_noconv() const throw()\n+  { return false; }\n+};\n+\n+class Buf : public std::wfilebuf\n+{\n+public:\n+  std::streamsize pub_showmanyc()\n+  { return showmanyc(); }\n+  std::wfilebuf::int_type pub_underflow()\n+  { return underflow(); }\n+};\n+\n+// libstdc++/11603\n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  filebuf fbout;\n+  fbout.open(\"tmp_11603\", ios_base::out);\n+  fbout.sputn(\"aaaab\", 5);\n+  fbout.close();\n+\n+  locale loc(locale::classic(), new checksumcvt<wchar_t>);\n+  \n+  Buf fb;\n+  fb.pubimbue(loc);\n+  fb.open(\"tmp_11603\", ios_base::in);\n+  assert(fb.pub_showmanyc() == 1);\n+  \n+  try\n+    {\n+      wfilebuf::int_type ret = fb.pub_underflow();\n+      VERIFY( ret != wfilebuf::traits_type::eof() );\n+      fb.sbumpc();\n+      ret = fb.pub_underflow();\n+      VERIFY( ret == wfilebuf::traits_type::eof() );\n+    }\n+  catch (...)\n+    { }\n+\n+  fb.close();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}