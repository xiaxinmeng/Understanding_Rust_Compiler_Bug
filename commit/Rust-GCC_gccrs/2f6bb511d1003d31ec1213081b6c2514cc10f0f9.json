{"sha": "2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY2YmI1MTFkMTAwM2QzMWVjMTIxMzA4MWI2YzI1MTRjYzEwZjBmOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-07-03T05:03:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-07-03T05:03:58Z"}, "message": "tree-core.h (enum omp_clause_code): Add OMP_CLAUSE__SCANTEMP_ clause.\n\n\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE__SCANTEMP_\n\tclause.\n\t* tree.h (OMP_CLAUSE_DECL): Use OMP_CLAUSE__SCANTEMP_ instead of\n\tOMP_CLAUSE__CONDTEMP_ as range's upper bound.\n\t(OMP_CLAUSE__SCANTEMP__ALLOC, OMP_CLAUSE__SCANTEMP__CONTROL): Define.\n\t* tree.c (omp_clause_num_ops, omp_clause_code_name): Add\n\tOMP_CLAUSE__SCANTEMP_ entry.\n\t(walk_tree_1): Handle OMP_CLAUSE__SCANTEMP_.\n\t* tree-pretty-print.c (dump_omp_clause): Likewise.\n\t* tree-nested.c (convert_nonlocal_omp_clauses,\n\tconvert_local_omp_clauses): Likewise.\n\t* omp-general.h (struct omp_for_data): Add have_scantemp and\n\thave_nonctrl_scantemp members.\n\t* omp-general.c (omp_extract_for_data): Initialize them.\n\t* omp-low.c (struct omp_context): Add scan_exclusive member.\n\t(scan_omp_1_stmt): Don't unnecessarily mask gimple_omp_for_kind\n\tresult again with GF_OMP_FOR_KIND_MASK.  Initialize also\n\tctx->scan_exclusive.\n\t(lower_rec_simd_input_clauses): Use ctx->scan_exclusive instead\n\tof !ctx->scan_inclusive.\n\t(lower_rec_input_clauses): Simplify gimplification of dtors using\n\tgimplify_and_add.  For non-is_simd test OMP_CLAUSE_REDUCTION_INSCAN\n\trather than rvarp.  Handle OMP_CLAUSE_REDUCTION_INSCAN in worksharing\n\tloops.  Don't add barrier for reduction_omp_orig_ref if\n\tctx->scan_??xclusive.\n\t(lower_reduction_clauses): Don't do anything for ctx->scan_??xclusive.\n\t(lower_omp_scan): Use ctx->scan_exclusive instead\n\tof !ctx->scan_inclusive.  Handle worksharing loops with inscan\n\treductions.  Use new_vard != new_var instead of repeated\n\tomp_is_reference calls.\n\t(omp_find_scan, lower_omp_for_scan): New functions.\n\t(lower_omp_for): Call lower_omp_for_scan for worksharing loops with\n\tinscan reductions.\n\t* omp-expand.c (expand_omp_scantemp_alloc): New function.\n\t(expand_omp_for_static_nochunk): Handle fd->have_nonctrl_scantemp\n\tand fd->have_scantemp.\n\n\t* c-c++-common/gomp/scan-3.c (f1): Don't expect a sorry message.\n\t* c-c++-common/gomp/scan-5.c (foo): Likewise.\n\n\t* testsuite/libgomp.c++/scan-1.C: New test.\n\t* testsuite/libgomp.c++/scan-2.C: New test.\n\t* testsuite/libgomp.c++/scan-3.C: New test.\n\t* testsuite/libgomp.c++/scan-4.C: New test.\n\t* testsuite/libgomp.c++/scan-5.C: New test.\n\t* testsuite/libgomp.c++/scan-6.C: New test.\n\t* testsuite/libgomp.c++/scan-7.C: New test.\n\t* testsuite/libgomp.c++/scan-8.C: New test.\n\t* testsuite/libgomp.c/scan-1.c: New test.\n\t* testsuite/libgomp.c/scan-2.c: New test.\n\t* testsuite/libgomp.c/scan-3.c: New test.\n\t* testsuite/libgomp.c/scan-4.c: New test.\n\t* testsuite/libgomp.c/scan-5.c: New test.\n\t* testsuite/libgomp.c/scan-6.c: New test.\n\t* testsuite/libgomp.c/scan-7.c: New test.\n\t* testsuite/libgomp.c/scan-8.c: New test.\n\nFrom-SVN: r272958", "tree": {"sha": "2389139c9c8169da0772490aa58f0cc7c40f8599", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2389139c9c8169da0772490aa58f0cc7c40f8599"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "83eb9522087c0f1f152873da00ade34e5f3e67e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83eb9522087c0f1f152873da00ade34e5f3e67e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83eb9522087c0f1f152873da00ade34e5f3e67e5"}], "stats": {"total": 3406, "additions": 3264, "deletions": 142}, "files": [{"sha": "2e7c74f52703bf59e3fac596a15cd7294c066adc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -1,5 +1,42 @@\n 2019-07-03  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE__SCANTEMP_\n+\tclause.\n+\t* tree.h (OMP_CLAUSE_DECL): Use OMP_CLAUSE__SCANTEMP_ instead of\n+\tOMP_CLAUSE__CONDTEMP_ as range's upper bound.\n+\t(OMP_CLAUSE__SCANTEMP__ALLOC, OMP_CLAUSE__SCANTEMP__CONTROL): Define.\n+\t* tree.c (omp_clause_num_ops, omp_clause_code_name): Add\n+\tOMP_CLAUSE__SCANTEMP_ entry.\n+\t(walk_tree_1): Handle OMP_CLAUSE__SCANTEMP_.\n+\t* tree-pretty-print.c (dump_omp_clause): Likewise.\n+\t* tree-nested.c (convert_nonlocal_omp_clauses,\n+\tconvert_local_omp_clauses): Likewise.\n+\t* omp-general.h (struct omp_for_data): Add have_scantemp and\n+\thave_nonctrl_scantemp members.\n+\t* omp-general.c (omp_extract_for_data): Initialize them.\n+\t* omp-low.c (struct omp_context): Add scan_exclusive member.\n+\t(scan_omp_1_stmt): Don't unnecessarily mask gimple_omp_for_kind\n+\tresult again with GF_OMP_FOR_KIND_MASK.  Initialize also\n+\tctx->scan_exclusive.\n+\t(lower_rec_simd_input_clauses): Use ctx->scan_exclusive instead\n+\tof !ctx->scan_inclusive.\n+\t(lower_rec_input_clauses): Simplify gimplification of dtors using\n+\tgimplify_and_add.  For non-is_simd test OMP_CLAUSE_REDUCTION_INSCAN\n+\trather than rvarp.  Handle OMP_CLAUSE_REDUCTION_INSCAN in worksharing\n+\tloops.  Don't add barrier for reduction_omp_orig_ref if\n+\tctx->scan_??xclusive.\n+\t(lower_reduction_clauses): Don't do anything for ctx->scan_??xclusive.\n+\t(lower_omp_scan): Use ctx->scan_exclusive instead\n+\tof !ctx->scan_inclusive.  Handle worksharing loops with inscan\n+\treductions.  Use new_vard != new_var instead of repeated\n+\tomp_is_reference calls.\n+\t(omp_find_scan, lower_omp_for_scan): New functions.\n+\t(lower_omp_for): Call lower_omp_for_scan for worksharing loops with\n+\tinscan reductions.\n+\t* omp-expand.c (expand_omp_scantemp_alloc): New function.\n+\t(expand_omp_for_static_nochunk): Handle fd->have_nonctrl_scantemp\n+\tand fd->have_scantemp.\n+\n \t* gimplify.c (gimplify_scan_omp_clauses): For inscan reductions\n \ton worksharing loop propagate it as shared clause to containing\n \tcombined parallel."}, {"sha": "9236b3665e4a01221671b23cc3c7acf8fce3e2bc", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 278, "deletions": 14, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -3502,6 +3502,98 @@ expand_omp_for_generic (struct omp_region *region,\n     }\n }\n \n+/* Helper function for expand_omp_for_static_nochunk.  If PTR is NULL,\n+   compute needed allocation size.  If !ALLOC of team allocations,\n+   if ALLOC of thread allocation.  SZ is the initial needed size for\n+   other purposes, ALLOC_ALIGN guaranteed alignment of allocation in bytes,\n+   CNT number of elements of each array, for !ALLOC this is\n+   omp_get_num_threads (), for ALLOC number of iterations handled by the\n+   current thread.  If PTR is non-NULL, it is the start of the allocation\n+   and this routine shall assign to OMP_CLAUSE_DECL (c) of those _scantemp_\n+   clauses pointers to the corresponding arrays.  */\n+\n+static tree\n+expand_omp_scantemp_alloc (tree clauses, tree ptr, unsigned HOST_WIDE_INT sz,\n+\t\t\t   unsigned HOST_WIDE_INT alloc_align, tree cnt,\n+\t\t\t   gimple_stmt_iterator *gsi, bool alloc)\n+{\n+  tree eltsz = NULL_TREE;\n+  unsigned HOST_WIDE_INT preval = 0;\n+  if (ptr && sz)\n+    ptr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (ptr),\n+\t\t       ptr, size_int (sz));\n+  for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE__SCANTEMP_\n+\t&& !OMP_CLAUSE__SCANTEMP__CONTROL (c)\n+\t&& (!OMP_CLAUSE__SCANTEMP__ALLOC (c)) != alloc)\n+      {\n+\ttree pointee_type = TREE_TYPE (TREE_TYPE (OMP_CLAUSE_DECL (c)));\n+\tunsigned HOST_WIDE_INT al = TYPE_ALIGN_UNIT (pointee_type);\n+\tif (tree_fits_uhwi_p (TYPE_SIZE_UNIT (pointee_type)))\n+\t  {\n+\t    unsigned HOST_WIDE_INT szl\n+\t      = tree_to_uhwi (TYPE_SIZE_UNIT (pointee_type));\n+\t    szl = least_bit_hwi (szl);\n+\t    if (szl)\n+\t      al = MIN (al, szl);\n+\t  }\n+\tif (ptr == NULL_TREE)\n+\t  {\n+\t    if (eltsz == NULL_TREE)\n+\t      eltsz = TYPE_SIZE_UNIT (pointee_type);\n+\t    else\n+\t      eltsz = size_binop (PLUS_EXPR, eltsz,\n+\t\t\t\t  TYPE_SIZE_UNIT (pointee_type));\n+\t  }\n+\tif (preval == 0 && al <= alloc_align)\n+\t  {\n+\t    unsigned HOST_WIDE_INT diff = ROUND_UP (sz, al) - sz;\n+\t    sz += diff;\n+\t    if (diff && ptr)\n+\t      ptr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (ptr),\n+\t\t\t\t ptr, size_int (diff));\n+\t  }\n+\telse if (al > preval)\n+\t  {\n+\t    if (ptr)\n+\t      {\n+\t\tptr = fold_convert (pointer_sized_int_node, ptr);\n+\t\tptr = fold_build2 (PLUS_EXPR, pointer_sized_int_node, ptr,\n+\t\t\t\t   build_int_cst (pointer_sized_int_node,\n+\t\t\t\t\t\t  al - 1));\n+\t\tptr = fold_build2 (BIT_AND_EXPR, pointer_sized_int_node, ptr,\n+\t\t\t\t   build_int_cst (pointer_sized_int_node,\n+\t\t\t\t\t\t  -(HOST_WIDE_INT) al));\n+\t\tptr = fold_convert (ptr_type_node, ptr);\n+\t      }\n+\t    else\n+\t      sz += al - 1;\n+\t  }\n+\tif (tree_fits_uhwi_p (TYPE_SIZE_UNIT (pointee_type)))\n+\t  preval = al;\n+\telse\n+\t  preval = 1;\n+\tif (ptr)\n+\t  {\n+\t    expand_omp_build_assign (gsi, OMP_CLAUSE_DECL (c), ptr, false);\n+\t    ptr = OMP_CLAUSE_DECL (c);\n+\t    ptr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+\t\t\t       size_binop (MULT_EXPR, cnt,\n+\t\t\t\t\t   TYPE_SIZE_UNIT (pointee_type)));\n+\t  }\n+      }\n+\n+  if (ptr == NULL_TREE)\n+    {\n+      eltsz = size_binop (MULT_EXPR, eltsz, cnt);\n+      if (sz)\n+\teltsz = size_binop (PLUS_EXPR, eltsz, size_int (sz));\n+      return eltsz;\n+    }\n+  else\n+    return ptr;\n+}\n+\n /* A subroutine of expand_omp_for.  Generate code for a parallel\n    loop with static schedule and no specified chunk size.  Given\n    parameters:\n@@ -3544,11 +3636,12 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t       struct omp_for_data *fd,\n \t\t\t       gimple *inner_stmt)\n {\n-  tree n, q, s0, e0, e, t, tt, nthreads, threadid;\n+  tree n, q, s0, e0, e, t, tt, nthreads = NULL_TREE, threadid;\n   tree type, itype, vmain, vback;\n   basic_block entry_bb, second_bb, third_bb, exit_bb, seq_start_bb;\n   basic_block body_bb, cont_bb, collapse_bb = NULL;\n-  basic_block fin_bb;\n+  basic_block fin_bb, fourth_bb = NULL, fifth_bb = NULL, sixth_bb = NULL;\n+  basic_block exit1_bb = NULL, exit2_bb = NULL, exit3_bb = NULL;\n   gimple_stmt_iterator gsi, gsip;\n   edge ep;\n   bool broken_loop = region->cont == NULL;\n@@ -3650,7 +3743,9 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       c = omp_find_clause (OMP_CLAUSE_CHAIN (c), OMP_CLAUSE__CONDTEMP_);\n       cond_var = OMP_CLAUSE_DECL (c);\n     }\n-  if (fd->have_reductemp || fd->have_pointer_condtemp)\n+  if (fd->have_reductemp\n+      || fd->have_pointer_condtemp\n+      || fd->have_nonctrl_scantemp)\n     {\n       tree t1 = build_int_cst (long_integer_type_node, 0);\n       tree t2 = build_int_cst (long_integer_type_node, 1);\n@@ -3660,8 +3755,11 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       gimple_stmt_iterator gsi2 = gsi_none ();\n       gimple *g = NULL;\n       tree mem = null_pointer_node, memv = NULL_TREE;\n+      unsigned HOST_WIDE_INT condtemp_sz = 0;\n+      unsigned HOST_WIDE_INT alloc_align = 0;\n       if (fd->have_reductemp)\n \t{\n+\t  gcc_assert (!fd->have_nonctrl_scantemp);\n \t  tree c = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n \t  reductions = OMP_CLAUSE_DECL (c);\n \t  gcc_assert (TREE_CODE (reductions) == SSA_NAME);\n@@ -3678,16 +3776,40 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t    gsi2 = gsip;\n \t  reductions = null_pointer_node;\n \t}\n-      if (fd->have_pointer_condtemp)\n+      if (fd->have_pointer_condtemp || fd->have_nonctrl_scantemp)\n \t{\n-\t  tree type = TREE_TYPE (condtemp);\n+\t  tree type;\n+\t  if (fd->have_pointer_condtemp)\n+\t    type = TREE_TYPE (condtemp);\n+\t  else\n+\t    type = ptr_type_node;\n \t  memv = create_tmp_var (type);\n \t  TREE_ADDRESSABLE (memv) = 1;\n-\t  unsigned HOST_WIDE_INT sz\n-\t    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (type)));\n-\t  sz *= fd->lastprivate_conditional;\n-\t  expand_omp_build_assign (&gsi2, memv, build_int_cst (type, sz),\n-\t\t\t\t   false);\n+\t  unsigned HOST_WIDE_INT sz = 0;\n+\t  tree size = NULL_TREE;\n+\t  if (fd->have_pointer_condtemp)\n+\t    {\n+\t      sz = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t      sz *= fd->lastprivate_conditional;\n+\t      condtemp_sz = sz;\n+\t    }\n+\t  if (fd->have_nonctrl_scantemp)\n+\t    {\n+\t      nthreads = builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS);\n+\t      gimple *g = gimple_build_call (nthreads, 0);\n+\t      nthreads = create_tmp_var (integer_type_node);\n+\t      gimple_call_set_lhs (g, nthreads);\n+\t      gsi_insert_before (&gsi2, g, GSI_SAME_STMT);\n+\t      nthreads = fold_convert (sizetype, nthreads);\n+\t      alloc_align = TYPE_ALIGN_UNIT (long_long_integer_type_node);\n+\t      size = expand_omp_scantemp_alloc (clauses, NULL_TREE, sz,\n+\t\t\t\t\t\talloc_align, nthreads, NULL,\n+\t\t\t\t\t\tfalse);\n+\t      size = fold_convert (type, size);\n+\t    }\n+\t  else\n+\t    size = build_int_cst (type, sz);\n+\t  expand_omp_build_assign (&gsi2, memv, size, false);\n \t  mem = build_fold_addr_expr (memv);\n \t}\n       tree t\n@@ -3698,6 +3820,12 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t\ttrue, GSI_SAME_STMT);\n       if (fd->have_pointer_condtemp)\n \texpand_omp_build_assign (&gsi2, condtemp, memv, false);\n+      if (fd->have_nonctrl_scantemp)\n+\t{\n+\t  tree ptr = fd->have_pointer_condtemp ? condtemp : memv;\n+\t  expand_omp_scantemp_alloc (clauses, ptr, condtemp_sz,\n+\t\t\t\t     alloc_align, nthreads, &gsi2, false);\n+\t}\n       if (fd->have_reductemp)\n \t{\n \t  gsi_remove (&gsi2, true);\n@@ -3788,6 +3916,72 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   gsi = gsi_last_nondebug_bb (third_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n+  if (fd->have_nonctrl_scantemp)\n+    {\n+      tree clauses = gimple_omp_for_clauses (fd->for_stmt);\n+      tree controlp = NULL_TREE, controlb = NULL_TREE;\n+      for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE__SCANTEMP_\n+\t    && OMP_CLAUSE__SCANTEMP__CONTROL (c))\n+\t  {\n+\t    if (TREE_TYPE (OMP_CLAUSE_DECL (c)) == boolean_type_node)\n+\t      controlb = OMP_CLAUSE_DECL (c);\n+\t    else\n+\t      controlp = OMP_CLAUSE_DECL (c);\n+\t    if (controlb && controlp)\n+\t      break;\n+\t  }\n+      gcc_assert (controlp && controlb);\n+      tree cnt = create_tmp_var (sizetype);\n+      gimple *g = gimple_build_assign (cnt, NOP_EXPR, q);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      unsigned HOST_WIDE_INT alloc_align = TYPE_ALIGN_UNIT (ptr_type_node);\n+      tree sz = expand_omp_scantemp_alloc (clauses, NULL_TREE, 0,\n+\t\t\t\t\t   alloc_align, cnt, NULL, true);\n+      tree size = create_tmp_var (sizetype);\n+      expand_omp_build_assign (&gsi, size, sz, false);\n+      tree cmp = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t      size, size_int (16384));\n+      expand_omp_build_assign (&gsi, controlb, cmp);\n+      g = gimple_build_cond (NE_EXPR, controlb, boolean_false_node,\n+\t\t\t     NULL_TREE, NULL_TREE);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      fourth_bb = split_block (third_bb, g)->dest;\n+      gsi = gsi_last_nondebug_bb (fourth_bb);\n+      /* FIXME: Once we have allocators, this should use allocator.  */\n+      g = gimple_build_call (builtin_decl_explicit (BUILT_IN_MALLOC), 1, size);\n+      gimple_call_set_lhs (g, controlp);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      expand_omp_scantemp_alloc (clauses, controlp, 0, alloc_align, cnt,\n+\t\t\t\t &gsi, true);\n+      gsi_prev (&gsi);\n+      g = gsi_stmt (gsi);\n+      fifth_bb = split_block (fourth_bb, g)->dest;\n+      gsi = gsi_last_nondebug_bb (fifth_bb);\n+\n+      g = gimple_build_call (builtin_decl_implicit (BUILT_IN_STACK_SAVE), 0);\n+      gimple_call_set_lhs (g, controlp);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      tree alloca_decl = builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN);\n+      for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE__SCANTEMP_\n+\t    && OMP_CLAUSE__SCANTEMP__ALLOC (c))\n+\t  {\n+\t    tree tmp = create_tmp_var (sizetype);\n+\t    tree pointee_type = TREE_TYPE (TREE_TYPE (OMP_CLAUSE_DECL (c)));\n+\t    g = gimple_build_assign (tmp, MULT_EXPR, cnt,\n+\t\t\t\t     TYPE_SIZE_UNIT (pointee_type));\n+\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t    g = gimple_build_call (alloca_decl, 2, tmp,\n+\t\t\t\t   size_int (TYPE_ALIGN (pointee_type)));\n+\t    gimple_call_set_lhs (g, OMP_CLAUSE_DECL (c));\n+\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t  }\n+\n+      sixth_bb = split_block (fifth_bb, g)->dest;\n+      gsi = gsi_last_nondebug_bb (sixth_bb);\n+    }\n+\n   t = build2 (MULT_EXPR, itype, q, threadid);\n   t = build2 (PLUS_EXPR, itype, t, tt);\n   s0 = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, true, GSI_SAME_STMT);\n@@ -4018,7 +4212,9 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   if (!gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n     {\n       t = gimple_omp_return_lhs (gsi_stmt (gsi));\n-      if (fd->have_reductemp || fd->have_pointer_condtemp)\n+      if (fd->have_reductemp\n+\t  || ((fd->have_pointer_condtemp || fd->have_scantemp)\n+\t      && !fd->have_nonctrl_scantemp))\n \t{\n \t  tree fn;\n \t  if (t)\n@@ -4045,6 +4241,38 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       gcall *g = gimple_build_call (fn, 0);\n       gsi_insert_after (&gsi, g, GSI_SAME_STMT);\n     }\n+  if (fd->have_scantemp && !fd->have_nonctrl_scantemp)\n+    {\n+      tree clauses = gimple_omp_for_clauses (fd->for_stmt);\n+      tree controlp = NULL_TREE, controlb = NULL_TREE;\n+      for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE__SCANTEMP_\n+\t    && OMP_CLAUSE__SCANTEMP__CONTROL (c))\n+\t  {\n+\t    if (TREE_TYPE (OMP_CLAUSE_DECL (c)) == boolean_type_node)\n+\t      controlb = OMP_CLAUSE_DECL (c);\n+\t    else\n+\t      controlp = OMP_CLAUSE_DECL (c);\n+\t    if (controlb && controlp)\n+\t      break;\n+\t  }\n+      gcc_assert (controlp && controlb);\n+      gimple *g = gimple_build_cond (NE_EXPR, controlb, boolean_false_node,\n+\t\t\t\t     NULL_TREE, NULL_TREE);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      exit1_bb = split_block (exit_bb, g)->dest;\n+      gsi = gsi_after_labels (exit1_bb);\n+      g = gimple_build_call (builtin_decl_explicit (BUILT_IN_FREE), 1,\n+\t\t\t     controlp);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      exit2_bb = split_block (exit1_bb, g)->dest;\n+      gsi = gsi_after_labels (exit2_bb);\n+      g = gimple_build_call (builtin_decl_implicit (BUILT_IN_STACK_RESTORE), 1,\n+\t\t\t     controlp);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      exit3_bb = split_block (exit2_bb, g)->dest;\n+      gsi = gsi_after_labels (exit3_bb);\n+    }\n   gsi_remove (&gsi, true);\n \n   /* Connect all the blocks.  */\n@@ -4053,8 +4281,34 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   ep = find_edge (entry_bb, second_bb);\n   ep->flags = EDGE_TRUE_VALUE;\n   ep->probability = profile_probability::guessed_always ().apply_scale (1, 4);\n-  find_edge (third_bb, seq_start_bb)->flags = EDGE_FALSE_VALUE;\n-  find_edge (third_bb, fin_bb)->flags = EDGE_TRUE_VALUE;\n+  if (fourth_bb)\n+    {\n+      ep = make_edge (third_bb, fifth_bb, EDGE_FALSE_VALUE);\n+      ep->probability\n+\t= profile_probability::guessed_always ().apply_scale (1, 2);\n+      ep = find_edge (third_bb, fourth_bb);\n+      ep->flags = EDGE_TRUE_VALUE;\n+      ep->probability\n+\t= profile_probability::guessed_always ().apply_scale (1, 2);\n+      ep = find_edge (fourth_bb, fifth_bb);\n+      redirect_edge_and_branch (ep, sixth_bb);\n+    }\n+  else\n+    sixth_bb = third_bb;\n+  find_edge (sixth_bb, seq_start_bb)->flags = EDGE_FALSE_VALUE;\n+  find_edge (sixth_bb, fin_bb)->flags = EDGE_TRUE_VALUE;\n+  if (exit1_bb)\n+    {\n+      ep = make_edge (exit_bb, exit2_bb, EDGE_FALSE_VALUE);\n+      ep->probability\n+\t= profile_probability::guessed_always ().apply_scale (1, 2);\n+      ep = find_edge (exit_bb, exit1_bb);\n+      ep->flags = EDGE_TRUE_VALUE;\n+      ep->probability\n+\t= profile_probability::guessed_always ().apply_scale (1, 2);\n+      ep = find_edge (exit1_bb, exit2_bb);\n+      redirect_edge_and_branch (ep, exit3_bb);\n+    }\n \n   if (!broken_loop)\n     {\n@@ -4082,12 +4336,22 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \n   set_immediate_dominator (CDI_DOMINATORS, second_bb, entry_bb);\n   set_immediate_dominator (CDI_DOMINATORS, third_bb, entry_bb);\n-  set_immediate_dominator (CDI_DOMINATORS, seq_start_bb, third_bb);\n+  if (fourth_bb)\n+    {\n+      set_immediate_dominator (CDI_DOMINATORS, fifth_bb, third_bb);\n+      set_immediate_dominator (CDI_DOMINATORS, sixth_bb, third_bb);\n+    }\n+  set_immediate_dominator (CDI_DOMINATORS, seq_start_bb, sixth_bb);\n \n   set_immediate_dominator (CDI_DOMINATORS, body_bb,\n \t\t\t   recompute_dominator (CDI_DOMINATORS, body_bb));\n   set_immediate_dominator (CDI_DOMINATORS, fin_bb,\n \t\t\t   recompute_dominator (CDI_DOMINATORS, fin_bb));\n+  if (exit1_bb)\n+    {\n+      set_immediate_dominator (CDI_DOMINATORS, exit2_bb, exit_bb);\n+      set_immediate_dominator (CDI_DOMINATORS, exit3_bb, exit_bb);\n+    }\n \n   struct loop *loop = body_bb->loop_father;\n   if (loop != entry_bb->loop_father)"}, {"sha": "8086f9ac392bb33d1578a18b456734dbb95a4c5b", "filename": "gcc/omp-general.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -169,6 +169,8 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n   fd->have_ordered = false;\n   fd->have_reductemp = false;\n   fd->have_pointer_condtemp = false;\n+  fd->have_scantemp = false;\n+  fd->have_nonctrl_scantemp = false;\n   fd->lastprivate_conditional = 0;\n   fd->tiling = NULL_TREE;\n   fd->collapse = 1;\n@@ -231,6 +233,12 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \tif (POINTER_TYPE_P (TREE_TYPE (OMP_CLAUSE_DECL (t))))\n \t  fd->have_pointer_condtemp = true;\n \tbreak;\n+      case OMP_CLAUSE__SCANTEMP_:\n+\tfd->have_scantemp = true;\n+\tif (!OMP_CLAUSE__SCANTEMP__ALLOC (t)\n+\t    && !OMP_CLAUSE__SCANTEMP__CONTROL (t))\n+\t  fd->have_nonctrl_scantemp = true;\n+\tbreak;\n       default:\n \tbreak;\n       }"}, {"sha": "80d42aff3c86373ffcd661bd6ec2f622965cd158", "filename": "gcc/omp-general.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -63,7 +63,7 @@ struct omp_for_data\n   int collapse;  /* Collapsed loops, 1 for a non-collapsed loop.  */\n   int ordered;\n   bool have_nowait, have_ordered, simd_schedule, have_reductemp;\n-  bool have_pointer_condtemp;\n+  bool have_pointer_condtemp, have_scantemp, have_nonctrl_scantemp;\n   int lastprivate_conditional;\n   unsigned char sched_modifiers;\n   enum omp_clause_schedule_kind sched_kind;"}, {"sha": "98a9df583bccfc4128d2650bfed2453190853f23", "filename": "gcc/omp-low.c", "status": "modified", "additions": 815, "deletions": 124, "changes": 939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -144,6 +144,9 @@ struct omp_context\n \n   /* True if there is nested scan context with inclusive clause.  */\n   bool scan_inclusive;\n+\n+  /* True if there is nested scan context with exclusive clause.  */\n+  bool scan_exclusive;\n };\n \n static splay_tree all_contexts;\n@@ -3316,8 +3319,8 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_OMP_FOR:\n-      if (((gimple_omp_for_kind (as_a <gomp_for *> (stmt))\n-\t    & GF_OMP_FOR_KIND_MASK) == GF_OMP_FOR_KIND_SIMD)\n+      if ((gimple_omp_for_kind (as_a <gomp_for *> (stmt))\n+\t   == GF_OMP_FOR_KIND_SIMD)\n \t  && omp_maybe_offloaded_ctx (ctx)\n \t  && omp_max_simt_vf ())\n \tscan_omp_simd (gsi, as_a <gomp_for *> (stmt), ctx);\n@@ -3335,8 +3338,12 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n     case GIMPLE_OMP_SCAN:\n       if (tree clauses = gimple_omp_scan_clauses (as_a <gomp_scan *> (stmt)))\n-\tif (OMP_CLAUSE_CODE (clauses) == OMP_CLAUSE_INCLUSIVE)\n-\t  ctx->scan_inclusive = true;\n+\t{\n+\t  if (OMP_CLAUSE_CODE (clauses) == OMP_CLAUSE_INCLUSIVE)\n+\t    ctx->scan_inclusive = true;\n+\t  else if (OMP_CLAUSE_CODE (clauses) == OMP_CLAUSE_EXCLUSIVE)\n+\t    ctx->scan_exclusive = true;\n+\t}\n       /* FALLTHRU */\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_MASTER:\n@@ -3769,7 +3776,7 @@ lower_rec_simd_input_clauses (tree new_var, omp_context *ctx,\n \t\t\t  sctx->lastlane, NULL_TREE, NULL_TREE);\n \t  TREE_THIS_NOTRAP (*rvar) = 1;\n \n-\t  if (!ctx->scan_inclusive)\n+\t  if (ctx->scan_exclusive)\n \t    {\n \t      /* And for exclusive scan yet another one, which will\n \t\t hold the value during the scan phase.  */\n@@ -3854,7 +3861,7 @@ static void\n lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t omp_context *ctx, struct omp_for_data *fd)\n {\n-  tree c, dtor, copyin_seq, x, ptr;\n+  tree c, copyin_seq, x, ptr;\n   bool copyin_by_ref = false;\n   bool lastprivate_firstprivate = false;\n   bool reduction_omp_orig_ref = false;\n@@ -4541,12 +4548,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      x = lang_hooks.decls.omp_clause_dtor\n \t\t\t\t\t\t(c, build_simple_mem_ref (y2));\n \t\t      if (x)\n-\t\t\t{\n-\t\t\t  gimple_seq tseq = NULL;\n-\t\t\t  dtor = x;\n-\t\t\t  gimplify_stmt (&dtor, &tseq);\n-\t\t\t  gimple_seq_add_seq (dlist, tseq);\n-\t\t\t}\n+\t\t\tgimplify_and_add (x, dlist);\n \t\t    }\n \t\t}\n \t      else\n@@ -4913,13 +4915,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t{\n \t\t\t  y = lang_hooks.decls.omp_clause_dtor (c, ivar);\n \t\t\t  if (y)\n-\t\t\t    {\n-\t\t\t      gimple_seq tseq = NULL;\n-\n-\t\t\t      dtor = y;\n-\t\t\t      gimplify_stmt (&dtor, &tseq);\n-\t\t\t      gimple_seq_add_seq (&llist[1], tseq);\n-\t\t\t    }\n+\t\t\t    gimplify_and_add (y, &llist[1]);\n \t\t\t}\n \t\t      break;\n \t\t    }\n@@ -4949,13 +4945,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t    do_dtor:\n \t      x = lang_hooks.decls.omp_clause_dtor (c, new_var);\n \t      if (x)\n-\t\t{\n-\t\t  gimple_seq tseq = NULL;\n-\n-\t\t  dtor = x;\n-\t\t  gimplify_stmt (&dtor, &tseq);\n-\t\t  gimple_seq_add_seq (dlist, tseq);\n-\t\t}\n+\t\tgimplify_and_add (x, dlist);\n \t      break;\n \n \t    case OMP_CLAUSE_LINEAR:\n@@ -5103,13 +5093,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      gimplify_and_add (x, &llist[0]);\n \t\t      x = lang_hooks.decls.omp_clause_dtor (c, ivar);\n \t\t      if (x)\n-\t\t\t{\n-\t\t\t  gimple_seq tseq = NULL;\n-\n-\t\t\t  dtor = x;\n-\t\t\t  gimplify_stmt (&dtor, &tseq);\n-\t\t\t  gimple_seq_add_seq (&llist[1], tseq);\n-\t\t\t}\n+\t\t\tgimplify_and_add (x, &llist[1]);\n \t\t      break;\n \t\t    }\n \t\t  if (omp_is_reference (var))\n@@ -5282,12 +5266,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n \t\t\t      x = lang_hooks.decls.omp_clause_dtor (c, nv);\n \t\t\t      if (x)\n-\t\t\t\t{\n-\t\t\t\t  tseq = NULL;\n-\t\t\t\t  dtor = x;\n-\t\t\t\t  gimplify_stmt (&dtor, &tseq);\n-\t\t\t\t  gimple_seq_add_seq (dlist, tseq);\n-\t\t\t\t}\n+\t\t\t\tgimplify_and_add (x, dlist);\n \t\t\t    }\n \n \t\t\t  tree ref = build_outer_var_ref (var, ctx);\n@@ -5310,34 +5289,19 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n \t\t\t  x = lang_hooks.decls.omp_clause_dtor (c, ivar);\n \t\t\t  if (x)\n-\t\t\t    {\n-\t\t\t      tseq = NULL;\n-\t\t\t      dtor = x;\n-\t\t\t      gimplify_stmt (&dtor, &tseq);\n-\t\t\t      gimple_seq_add_seq (&llist[1], tseq);\n-\t\t\t    }\n+\t\t\t    gimplify_and_add (x, &llist[1]);\n \n \t\t\t  tree ivar2 = unshare_expr (lvar);\n \t\t\t  TREE_OPERAND (ivar2, 1) = sctx.idx;\n \t\t\t  x = lang_hooks.decls.omp_clause_dtor (c, ivar2);\n \t\t\t  if (x)\n-\t\t\t    {\n-\t\t\t      tseq = NULL;\n-\t\t\t      dtor = x;\n-\t\t\t      gimplify_stmt (&dtor, &tseq);\n-\t\t\t      gimple_seq_add_seq (&llist[1], tseq);\n-\t\t\t    }\n+\t\t\t    gimplify_and_add (x, &llist[1]);\n \n \t\t\t  if (rvar2)\n \t\t\t    {\n \t\t\t      x = lang_hooks.decls.omp_clause_dtor (c, rvar2);\n \t\t\t      if (x)\n-\t\t\t\t{\n-\t\t\t\t  tseq = NULL;\n-\t\t\t\t  dtor = x;\n-\t\t\t\t  gimplify_stmt (&dtor, &tseq);\n-\t\t\t\t  gimple_seq_add_seq (&llist[1], tseq);\n-\t\t\t\t}\n+\t\t\t\tgimplify_and_add (x, &llist[1]);\n \t\t\t    }\n \t\t\t  break;\n \t\t\t}\n@@ -5362,12 +5326,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t\t\t     build_fold_addr_expr (lvar));\n \t\t      x = lang_hooks.decls.omp_clause_dtor (c, ivar);\n \t\t      if (x)\n-\t\t\t{\n-\t\t\t  tseq = NULL;\n-\t\t\t  dtor = x;\n-\t\t\t  gimplify_stmt (&dtor, &tseq);\n-\t\t\t  gimple_seq_add_seq (&llist[1], tseq);\n-\t\t\t}\n+\t\t\tgimplify_and_add (x, &llist[1]);\n \t\t      break;\n \t\t    }\n \t\t  /* If this is a reference to constant size reduction var\n@@ -5409,16 +5368,19 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  if (x)\n \t\t    gimplify_and_add (x, ilist);\n \n-\t\t  if (rvarp)\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t      && OMP_CLAUSE_REDUCTION_INSCAN (c))\n \t\t    {\n-\t\t      if (x)\n+\t\t      if (x || (!is_simd\n+\t\t\t\t&& OMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c)))\n \t\t\t{\n \t\t\t  tree nv = create_tmp_var_raw (TREE_TYPE (new_var));\n \t\t\t  gimple_add_tmp_var (nv);\n \t\t\t  ctx->cb.decl_map->put (new_vard, nv);\n \t\t\t  x = lang_hooks.decls.omp_clause_default_ctor\n \t\t\t\t(c, nv, build_outer_var_ref (var, ctx));\n-\t\t\t  gimplify_and_add (x, ilist);\n+\t\t\t  if (x)\n+\t\t\t    gimplify_and_add (x, ilist);\n \t\t\t  if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))\n \t\t\t    {\n \t\t\t      tseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n@@ -5433,7 +5395,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t      gimple_seq_add_seq (ilist, tseq);\n \t\t\t    }\n \t\t\t  OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n-\t\t\t  if (!ctx->scan_inclusive)\n+\t\t\t  if (is_simd && ctx->scan_exclusive)\n \t\t\t    {\n \t\t\t      tree nv2\n \t\t\t\t= create_tmp_var_raw (TREE_TYPE (new_var));\n@@ -5444,36 +5406,22 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t      gimplify_and_add (x, ilist);\n \t\t\t      x = lang_hooks.decls.omp_clause_dtor (c, nv2);\n \t\t\t      if (x)\n-\t\t\t\t{\n-\t\t\t\t  tseq = NULL;\n-\t\t\t\t  dtor = x;\n-\t\t\t\t  gimplify_stmt (&dtor, &tseq);\n-\t\t\t\t  gimple_seq_add_seq (dlist, tseq);\n-\t\t\t\t}\n+\t\t\t\tgimplify_and_add (x, dlist);\n \t\t\t    }\n \t\t\t  x = lang_hooks.decls.omp_clause_dtor (c, nv);\n \t\t\t  if (x)\n-\t\t\t    {\n-\t\t\t      tseq = NULL;\n-\t\t\t      dtor = x;\n-\t\t\t      gimplify_stmt (&dtor, &tseq);\n-\t\t\t      gimple_seq_add_seq (dlist, tseq);\n-\t\t\t    }\n+\t\t\t    gimplify_and_add (x, dlist);\n \t\t\t}\n-\t\t      else if (!ctx->scan_inclusive\n+\t\t      else if (is_simd\n+\t\t\t       && ctx->scan_exclusive\n \t\t\t       && TREE_ADDRESSABLE (TREE_TYPE (new_var)))\n \t\t\t{\n \t\t\t  tree nv2 = create_tmp_var_raw (TREE_TYPE (new_var));\n \t\t\t  gimple_add_tmp_var (nv2);\n \t\t\t  ctx->cb.decl_map->put (new_vard, nv2);\n \t\t\t  x = lang_hooks.decls.omp_clause_dtor (c, nv2);\n \t\t\t  if (x)\n-\t\t\t    {\n-\t\t\t      tseq = NULL;\n-\t\t\t      dtor = x;\n-\t\t\t      gimplify_stmt (&dtor, &tseq);\n-\t\t\t      gimple_seq_add_seq (dlist, tseq);\n-\t\t\t    }\n+\t\t\t    gimplify_and_add (x, dlist);\n \t\t\t}\n \t\t      DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n \t\t      goto do_dtor;\n@@ -5611,7 +5559,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t    {\n \t\t      if (omp_is_reference (var) && is_simd)\n \t\t\thandle_simd_reference (clause_loc, new_vard, ilist);\n-\t\t      if (rvarp)\n+\t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t\t  && OMP_CLAUSE_REDUCTION_INSCAN (c))\n \t\t\tbreak;\n \t\t      gimplify_assign (new_var, x, ilist);\n \t\t      if (is_simd)\n@@ -5815,7 +5764,10 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n      lastprivate clauses we need to ensure the lastprivate copying\n      happens after firstprivate copying in all threads.  And similarly\n      for UDRs if initializer expression refers to omp_orig.  */\n-  if (copyin_by_ref || lastprivate_firstprivate || reduction_omp_orig_ref)\n+  if (copyin_by_ref || lastprivate_firstprivate\n+      || (reduction_omp_orig_ref\n+\t  && !ctx->scan_inclusive\n+\t  && !ctx->scan_exclusive))\n     {\n       /* Don't add any barrier for #pragma omp simd or\n \t #pragma omp distribute.  */\n@@ -6464,6 +6416,10 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp,\n       && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD)\n     return;\n \n+  /* inscan reductions are handled elsewhere.  */\n+  if (ctx->scan_inclusive || ctx->scan_exclusive)\n+    return;\n+\n   /* First see if there is exactly one reduction clause.  Use OMP_ATOMIC\n      update in that case, otherwise use a lock.  */\n   for (c = clauses; c && count < 2; c = OMP_CLAUSE_CHAIN (c))\n@@ -8650,7 +8606,7 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gimple_seq before = NULL;\n   omp_context *octx = ctx->outer;\n   gcc_assert (octx);\n-  if (!octx->scan_inclusive && !has_clauses)\n+  if (octx->scan_exclusive && !has_clauses)\n     {\n       gimple_stmt_iterator gsi2 = *gsi_p;\n       gsi_next (&gsi2);\n@@ -8672,23 +8628,29 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n     }\n \n   bool input_phase = has_clauses ^ octx->scan_inclusive;\n-  if (gimple_code (octx->stmt) == GIMPLE_OMP_FOR\n-      && (gimple_omp_for_kind (octx->stmt) & GF_OMP_FOR_SIMD)\n-      && !gimple_omp_for_combined_into_p (octx->stmt))\n+  bool is_simd = (gimple_code (octx->stmt) == GIMPLE_OMP_FOR\n+\t\t  && (gimple_omp_for_kind (octx->stmt) & GF_OMP_FOR_SIMD)\n+\t\t  && !gimple_omp_for_combined_into_p (octx->stmt));\n+  bool is_for = (gimple_code (octx->stmt) == GIMPLE_OMP_FOR\n+\t\t && gimple_omp_for_kind (octx->stmt) == GF_OMP_FOR_KIND_FOR\n+\t\t && !gimple_omp_for_combined_p (octx->stmt));\n+  if (is_simd)\n+    if (tree c = omp_find_clause (gimple_omp_for_clauses (octx->stmt),\n+\t\t\t\t  OMP_CLAUSE__SIMDUID_))\n+      {\n+\ttree uid = OMP_CLAUSE__SIMDUID__DECL (c);\n+\tlane = create_tmp_var (unsigned_type_node);\n+\ttree t = build_int_cst (integer_type_node,\n+\t\t\t\tinput_phase ? 1\n+\t\t\t\t: octx->scan_inclusive ? 2 : 3);\n+\tgimple *g\n+\t  = gimple_build_call_internal (IFN_GOMP_SIMD_LANE, 2, uid, t);\n+\tgimple_call_set_lhs (g, lane);\n+\tgimple_seq_add_stmt (&before, g);\n+      }\n+\n+  if (is_simd || is_for)\n     {\n-      if (tree c = omp_find_clause (gimple_omp_for_clauses (octx->stmt),\n-\t\t\t\t    OMP_CLAUSE__SIMDUID_))\n-\t{\n-\t  tree uid = OMP_CLAUSE__SIMDUID__DECL (c);\n-\t  lane = create_tmp_var (unsigned_type_node);\n-\t  tree t = build_int_cst (integer_type_node,\n-\t\t\t\t  input_phase ? 1\n-\t\t\t\t  : octx->scan_inclusive ? 2 : 3);\n-\t  gimple *g\n-\t    = gimple_build_call_internal (IFN_GOMP_SIMD_LANE, 2, uid, t);\n-\t  gimple_call_set_lhs (g, lane);\n-\t  gimple_seq_add_stmt (&before, g);\n-\t}\n       for (tree c = gimple_omp_for_clauses (octx->stmt);\n \t   c; c = OMP_CLAUSE_CHAIN (c))\n \tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n@@ -8711,7 +8673,7 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    if (DECL_HAS_VALUE_EXPR_P (new_vard))\n \t      {\n \t\tval = DECL_VALUE_EXPR (new_vard);\n-\t\tif (omp_is_reference (var))\n+\t\tif (new_vard != new_var)\n \t\t  {\n \t\t    gcc_assert (TREE_CODE (val) == ADDR_EXPR);\n \t\t    val = TREE_OPERAND (val, 0);\n@@ -8727,7 +8689,7 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\tlane0 = TREE_OPERAND (val, 1);\n \t\t\tTREE_OPERAND (val, 1) = lane;\n \t\t\tvar2 = lookup_decl (v, octx);\n-\t\t\tif (!octx->scan_inclusive)\n+\t\t\tif (octx->scan_exclusive)\n \t\t\t  var4 = lookup_decl (var2, octx);\n \t\t\tif (input_phase\n \t\t\t    && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n@@ -8737,7 +8699,7 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t    var2 = build4 (ARRAY_REF, TREE_TYPE (val),\n \t\t\t\t\t   var2, lane, NULL_TREE, NULL_TREE);\n \t\t\t    TREE_THIS_NOTRAP (var2) = 1;\n-\t\t\t    if (!octx->scan_inclusive)\n+\t\t\t    if (octx->scan_exclusive)\n \t\t\t      {\n \t\t\t\tvar4 = build4 (ARRAY_REF, TREE_TYPE (val),\n \t\t\t\t\t       var4, lane, NULL_TREE,\n@@ -8759,7 +8721,7 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t    var3 = maybe_lookup_decl (new_vard, octx);\n \t\t    if (var3 == new_vard || var3 == NULL_TREE)\n \t\t      var3 = NULL_TREE;\n-\t\t    else if (!octx->scan_inclusive && !input_phase)\n+\t\t    else if (is_simd && octx->scan_exclusive && !input_phase)\n \t\t      {\n \t\t\tvar4 = maybe_lookup_decl (var3, octx);\n \t\t\tif (var4 == var3 || var4 == NULL_TREE)\n@@ -8774,7 +8736,10 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t  }\n \t\t      }\n \t\t  }\n-\t\tif (!octx->scan_inclusive && !input_phase && var4 == NULL_TREE)\n+\t\tif (is_simd\n+\t\t    && octx->scan_exclusive\n+\t\t    && !input_phase\n+\t\t    && var4 == NULL_TREE)\n \t\t  var4 = create_tmp_var (TREE_TYPE (val));\n \t      }\n \t    if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n@@ -8794,12 +8759,14 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t      {\n \t\t\t/* Otherwise, assign to it the identity element.  */\n \t\t\tgimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n+\t\t\tif (is_for)\n+\t\t\t  tseq = copy_gimple_seq_and_replace_locals (tseq);\n \t\t\ttree ref = build_outer_var_ref (var, octx);\n \t\t\ttree x = (DECL_HAS_VALUE_EXPR_P (new_vard)\n \t\t\t\t  ? DECL_VALUE_EXPR (new_vard) : NULL_TREE);\n \t\t\tif (x)\n \t\t\t  {\n-\t\t\t    if (omp_is_reference (var))\n+\t\t\t    if (new_vard != new_var)\n \t\t\t      val = build_fold_addr_expr_loc (clause_loc, val);\n \t\t\t    SET_DECL_VALUE_EXPR (new_vard, val);\n \t\t\t  }\n@@ -8811,13 +8778,14 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\tSET_DECL_VALUE_EXPR (placeholder, NULL_TREE);\n \t\t\tDECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n \t\t\tgimple_seq_add_seq (&before, tseq);\n-\t\t\tOMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n+\t\t\tif (is_simd)\n+\t\t\t  OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n \t\t      }\n \t\t  }\n-\t\telse\n+\t\telse if (is_simd)\n \t\t  {\n \t\t    tree x;\n-\t\t    if (!octx->scan_inclusive)\n+\t\t    if (octx->scan_exclusive)\n \t\t      {\n \t\t\ttree v4 = unshare_expr (var4);\n \t\t\ttree v2 = unshare_expr (var2);\n@@ -8828,7 +8796,7 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t    x = (DECL_HAS_VALUE_EXPR_P (new_vard)\n \t\t\t ? DECL_VALUE_EXPR (new_vard) : NULL_TREE);\n \t\t    tree vexpr = val;\n-\t\t    if (x && omp_is_reference (var))\n+\t\t    if (x && new_vard != new_var)\n \t\t      vexpr = build_fold_addr_expr_loc (clause_loc, val);\n \t\t    if (x)\n \t\t      SET_DECL_VALUE_EXPR (new_vard, vexpr);\n@@ -8864,7 +8832,7 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t    tree x = omp_reduction_init (c, TREE_TYPE (new_var));\n \t\t    gimplify_assign (val, x, &before);\n \t\t  }\n-\t\telse\n+\t\telse if (is_simd)\n \t\t  {\n \t\t    /* scan phase.  */\n \t\t    enum tree_code code = OMP_CLAUSE_REDUCTION_CODE (c);\n@@ -8888,11 +8856,11 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t      }\n \t\t  }\n \t      }\n-\t    if (!octx->scan_inclusive && !input_phase && lane0)\n+\t    if (octx->scan_exclusive && !input_phase && lane0)\n \t      {\n \t\ttree vexpr = unshare_expr (var4);\n \t\tTREE_OPERAND (vexpr, 1) = lane0;\n-\t\tif (omp_is_reference (var))\n+\t\tif (new_vard != new_var)\n \t\t  vexpr = build_fold_addr_expr_loc (clause_loc, vexpr);\n \t\tSET_DECL_VALUE_EXPR (new_vard, vexpr);\n \t      }\n@@ -8901,9 +8869,17 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   else if (has_clauses)\n     sorry_at (gimple_location (stmt),\n \t      \"%<#pragma omp scan%> not supported yet\");\n-  gsi_insert_seq_after (gsi_p, gimple_omp_body (stmt), GSI_SAME_STMT);\n-  gsi_insert_seq_after (gsi_p, before, GSI_SAME_STMT);\n-  gsi_replace (gsi_p, gimple_build_nop (), true);\n+  if (!is_for)\n+    {\n+      gsi_insert_seq_after (gsi_p, gimple_omp_body (stmt), GSI_SAME_STMT);\n+      gsi_insert_seq_after (gsi_p, before, GSI_SAME_STMT);\n+      gsi_replace (gsi_p, gimple_build_nop (), true);\n+    }\n+  else if (before)\n+    {\n+      gimple_stmt_iterator gsi = gsi_start_1 (gimple_omp_body_ptr (stmt));\n+      gsi_insert_seq_before (&gsi, before, GSI_SAME_STMT);\n+    }\n }\n \n \n@@ -9124,6 +9100,712 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,\n     }\n }\n \n+/* Callback for walk_gimple_seq.  Find #pragma omp scan statement.  */\n+\n+tree\n+omp_find_scan (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n+\t       struct walk_stmt_info *wi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi_p);\n+\n+  *handled_ops_p = true;\n+  switch (gimple_code (stmt))\n+    {\n+    WALK_SUBSTMTS;\n+\n+    case GIMPLE_OMP_SCAN:\n+      *(gimple_stmt_iterator *) (wi->info) = *gsi_p;\n+      return integer_zero_node;\n+    default:\n+      break;\n+    }\n+  return NULL;\n+}\n+\n+/* Helper function for lower_omp_for, add transformations for a worksharing\n+   loop with scan directives inside of it.\n+   For worksharing loop not combined with simd, transform:\n+   #pragma omp for reduction(inscan,+:r) private(i)\n+   for (i = 0; i < n; i = i + 1)\n+     {\n+       {\n+\t update (r);\n+       }\n+       #pragma omp scan inclusive(r)\n+       {\n+\t use (r);\n+       }\n+     }\n+\n+   into two worksharing loops + code to merge results:\n+\n+   num_threads = omp_get_num_threads ();\n+   thread_num = omp_get_thread_num ();\n+   if (thread_num == 0) goto <D.2099>; else goto <D.2100>;\n+   <D.2099>:\n+   var2 = r;\n+   goto <D.2101>;\n+   <D.2100>:\n+   // For UDRs this is UDR init, or if ctors are needed, copy from\n+   // var3 that has been constructed to contain the neutral element.\n+   var2 = 0;\n+   <D.2101>:\n+   ivar = 0;\n+   // The _scantemp_ clauses will arrange for rpriva to be initialized to\n+   // a shared array with num_threads elements and rprivb to a local array\n+   // number of elements equal to the number of (contiguous) iterations the\n+   // current thread will perform.  controlb and controlp variables are\n+   // temporaries to handle deallocation of rprivb at the end of second\n+   // GOMP_FOR.\n+   #pragma omp for _scantemp_(rpriva) _scantemp_(rprivb) _scantemp_(controlb) \\\n+     _scantemp_(controlp) reduction(inscan,+:r) private(i) nowait\n+   for (i = 0; i < n; i = i + 1)\n+     {\n+       {\n+\t // For UDRs this is UDR init or copy from var3.\n+\t r = 0;\n+\t // This is the input phase from user code.\n+\t update (r);\n+       }\n+       {\n+\t // For UDRs this is UDR merge.\n+\t var2 = var2 + r;\n+\t // Rather than handing it over to the user, save to local thread's\n+\t // array.\n+\t rprivb[ivar] = var2;\n+\t // For exclusive scan, the above two statements are swapped.\n+\t ivar = ivar + 1;\n+       }\n+     }\n+   // And remember the final value from this thread's into the shared\n+   // rpriva array.\n+   rpriva[(sizetype) thread_num] = var2;\n+   // If more than one thread, compute using Work-Efficient prefix sum\n+   // the inclusive parallel scan of the rpriva array.\n+   if (num_threads > 1) goto <D.2102>; else goto <D.2103>;\n+   <D.2102>:\n+   GOMP_barrier ();\n+   down = 0;\n+   k = 1;\n+   num_threadsu = (unsigned int) num_threads;\n+   thread_numup1 = (unsigned int) thread_num + 1;\n+   <D.2108>:\n+   twok = k << 1;\n+   if (twok > num_threadsu) goto <D.2110>; else goto <D.2111>;\n+   <D.2110>:\n+   down = 4294967295;\n+   k = k >> 1;\n+   if (k == num_threadsu) goto <D.2112>; else goto <D.2111>;\n+   <D.2112>:\n+   k = k >> 1;\n+   <D.2111>:\n+   twok = k << 1;\n+   cplx = .MUL_OVERFLOW (thread_nump1, twok);\n+   mul = REALPART_EXPR <cplx>;\n+   ovf = IMAGPART_EXPR <cplx>;\n+   if (ovf == 0) goto <D.2116>; else goto <D.2117>;\n+   <D.2116>:\n+   andv = k & down;\n+   andvm1 = andv + 4294967295;\n+   l = mul + andvm1;\n+   if (l < num_threadsu) goto <D.2120>; else goto <D.2117>;\n+   <D.2120>:\n+   // For UDRs this is UDR merge, performed using var2 variable as temporary,\n+   // i.e. var2 = rpriva[l - k]; UDR merge (var2, rpriva[l]); rpriva[l] = var2;\n+   rpriva[l] = rpriva[l - k] + rpriva[l];\n+   <D.2117>:\n+   if (down == 0) goto <D.2121>; else goto <D.2122>;\n+   <D.2121>:\n+   k = k << 1;\n+   goto <D.2123>;\n+   <D.2122>:\n+   k = k >> 1;\n+   <D.2123>:\n+   GOMP_barrier ();\n+   if (k != 0) goto <D.2108>; else goto <D.2103>;\n+   <D.2103>:\n+   if (thread_num == 0) goto <D.2124>; else goto <D.2125>;\n+   <D.2124>:\n+   // For UDRs this is UDR init or copy from var3.\n+   var2 = 0;\n+   goto <D.2126>;\n+   <D.2125>:\n+   var2 = rpriva[thread_num - 1];\n+   <D.2126>:\n+   ivar = 0;\n+   #pragma omp for _scantemp_(controlb) _scantemp_(controlp) \\\n+     reduction(inscan,+:r) private(i)\n+   for (i = 0; i < n; i = i + 1)\n+     {\n+       {\n+\t // For UDRs, this is UDR merge (rprivb[ivar], var2); r = rprivb[ivar];\n+\t r = rprivb[ivar] + var2;\n+       }\n+       {\n+\t // This is the scan phase from user code.\n+\t use (r);\n+\t // Plus a bump of the iterator.\n+\t ivar = ivar + 1;\n+       }\n+     }  */\n+\n+static void\n+lower_omp_for_scan (gimple_seq *body_p, gimple_seq *dlist, gomp_for *stmt,\n+\t\t    struct omp_for_data *fd, omp_context *ctx)\n+{\n+  gcc_assert (ctx->scan_inclusive || ctx->scan_exclusive);\n+\n+  gimple_seq body = gimple_omp_body (stmt);\n+  gimple_stmt_iterator input1_gsi = gsi_none ();\n+  struct walk_stmt_info wi;\n+  memset (&wi, 0, sizeof (wi));\n+  wi.val_only = true;\n+  wi.info = (void *) &input1_gsi;\n+  walk_gimple_seq_mod (&body, omp_find_scan, NULL, &wi);\n+  gcc_assert (!gsi_end_p (input1_gsi));\n+\n+  gimple *input_stmt1 = gsi_stmt (input1_gsi);\n+  gimple_stmt_iterator gsi = input1_gsi;\n+  gsi_next (&gsi);\n+  gimple_stmt_iterator scan1_gsi = gsi;\n+  gimple *scan_stmt1 = gsi_stmt (gsi);\n+  gcc_assert (scan_stmt1 && gimple_code (scan_stmt1) == GIMPLE_OMP_SCAN);\n+\n+  gimple_seq input_body = gimple_omp_body (input_stmt1);\n+  gimple_seq scan_body = gimple_omp_body (scan_stmt1);\n+  gimple_omp_set_body (input_stmt1, NULL);\n+  gimple_omp_set_body (scan_stmt1, NULL);\n+  gimple_omp_set_body (stmt, NULL);\n+\n+  gomp_for *new_stmt = as_a <gomp_for *> (gimple_copy (stmt));\n+  gimple_seq new_body = copy_gimple_seq_and_replace_locals (body);\n+  gimple_omp_set_body (stmt, body);\n+  gimple_omp_set_body (input_stmt1, input_body);\n+\n+  gimple_stmt_iterator input2_gsi = gsi_none ();\n+  memset (&wi, 0, sizeof (wi));\n+  wi.val_only = true;\n+  wi.info = (void *) &input2_gsi;\n+  walk_gimple_seq_mod (&new_body, omp_find_scan, NULL, &wi);\n+  gcc_assert (!gsi_end_p (input2_gsi));\n+\n+  gimple *input_stmt2 = gsi_stmt (input2_gsi);\n+  gsi = input2_gsi;\n+  gsi_next (&gsi);\n+  gimple_stmt_iterator scan2_gsi = gsi;\n+  gimple *scan_stmt2 = gsi_stmt (gsi);\n+  gcc_assert (scan_stmt2 && gimple_code (scan_stmt2) == GIMPLE_OMP_SCAN);\n+  gimple_omp_set_body (scan_stmt2, scan_body);\n+\n+  tree num_threads = create_tmp_var (integer_type_node);\n+  tree thread_num = create_tmp_var (integer_type_node);\n+  tree nthreads_decl = builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS);\n+  tree threadnum_decl = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);\n+  gimple *g = gimple_build_call (nthreads_decl, 0);\n+  gimple_call_set_lhs (g, num_threads);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_call (threadnum_decl, 0);\n+  gimple_call_set_lhs (g, thread_num);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree ivar = create_tmp_var (sizetype);\n+  tree new_clauses1 = NULL_TREE, new_clauses2 = NULL_TREE;\n+  tree *cp1 = &new_clauses1, *cp2 = &new_clauses2;\n+  tree k = create_tmp_var (unsigned_type_node);\n+  tree l = create_tmp_var (unsigned_type_node);\n+\n+  gimple_seq clist = NULL, mdlist = NULL;\n+  gimple_seq thr01_list = NULL, thrn1_list = NULL;\n+  gimple_seq thr02_list = NULL, thrn2_list = NULL;\n+  gimple_seq scan1_list = NULL, input2_list = NULL;\n+  gimple_seq last_list = NULL, reduc_list = NULL;\n+  for (tree c = gimple_omp_for_clauses (stmt); c; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t&& OMP_CLAUSE_REDUCTION_INSCAN (c))\n+      {\n+\tlocation_t clause_loc = OMP_CLAUSE_LOCATION (c);\n+\ttree var = OMP_CLAUSE_DECL (c);\n+\ttree new_var = lookup_decl (var, ctx);\n+\ttree var3 = NULL_TREE;\n+\ttree new_vard = new_var;\n+\tif (omp_is_reference (var))\n+\t  new_var = build_simple_mem_ref_loc (clause_loc, new_var);\n+\tif (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t  {\n+\t    var3 = maybe_lookup_decl (new_vard, ctx);\n+\t    if (var3 == new_vard)\n+\t      var3 = NULL_TREE;\n+\t  }\n+\n+\ttree ptype = build_pointer_type (TREE_TYPE (new_var));\n+\ttree rpriva = create_tmp_var (ptype);\n+\ttree nc = build_omp_clause (clause_loc, OMP_CLAUSE__SCANTEMP_);\n+\tOMP_CLAUSE_DECL (nc) = rpriva;\n+\t*cp1 = nc;\n+\tcp1 = &OMP_CLAUSE_CHAIN (nc);\n+\n+\ttree rprivb = create_tmp_var (ptype);\n+\tnc = build_omp_clause (clause_loc, OMP_CLAUSE__SCANTEMP_);\n+\tOMP_CLAUSE_DECL (nc) = rprivb;\n+\tOMP_CLAUSE__SCANTEMP__ALLOC (nc) = 1;\n+\t*cp1 = nc;\n+\tcp1 = &OMP_CLAUSE_CHAIN (nc);\n+\n+\ttree var2 = create_tmp_var_raw (TREE_TYPE (new_var));\n+\tif (new_vard != new_var)\n+\t  TREE_ADDRESSABLE (var2) = 1;\n+\tgimple_add_tmp_var (var2);\n+\n+\ttree x = fold_convert_loc (clause_loc, sizetype, thread_num);\n+\tx = fold_build2_loc (clause_loc, MULT_EXPR, sizetype, x,\n+\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (ptype)));\n+\tx = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (rpriva), rpriva, x);\n+\ttree rpriva_ref = build_simple_mem_ref_loc (clause_loc, x);\n+\n+\tx = fold_build2_loc (clause_loc, PLUS_EXPR, integer_type_node,\n+\t\t\t     thread_num, integer_minus_one_node);\n+\tx = fold_convert_loc (clause_loc, sizetype, x);\n+\tx = fold_build2_loc (clause_loc, MULT_EXPR, sizetype, x,\n+\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (ptype)));\n+\tx = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (rpriva), rpriva, x);\n+\ttree rprivam1_ref = build_simple_mem_ref_loc (clause_loc, x);\n+\n+\tx = fold_convert_loc (clause_loc, sizetype, l);\n+\tx = fold_build2_loc (clause_loc, MULT_EXPR, sizetype, x,\n+\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (ptype)));\n+\tx = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (rpriva), rpriva, x);\n+\ttree rprival_ref = build_simple_mem_ref_loc (clause_loc, x);\n+\n+\tx = fold_build2_loc (clause_loc, MINUS_EXPR, unsigned_type_node, l, k);\n+\tx = fold_convert_loc (clause_loc, sizetype, x);\n+\tx = fold_build2_loc (clause_loc, MULT_EXPR, sizetype, x,\n+\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (ptype)));\n+\tx = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (rpriva), rpriva, x);\n+\ttree rprivalmk_ref = build_simple_mem_ref_loc (clause_loc, x);\n+\n+\tx = fold_build2_loc (clause_loc, MULT_EXPR, sizetype, ivar,\n+\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (ptype)));\n+\tx = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (rprivb), rprivb, x);\n+\ttree rprivb_ref = build_simple_mem_ref_loc (clause_loc, x);\n+\n+\tif (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t  {\n+\t    tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n+\t    tree val = var2;\n+\t    if (new_vard != new_var)\n+\t      val = build_fold_addr_expr_loc (clause_loc, val);\n+\n+\t    x = lang_hooks.decls.omp_clause_default_ctor\n+\t\t    (c, var2, build_outer_var_ref (var, ctx));\n+\t    if (x)\n+\t      gimplify_and_add (x, &clist);\n+\n+\t    x = build_outer_var_ref (var, ctx);\n+\t    x = lang_hooks.decls.omp_clause_assign_op (c, var2, x);\n+\t    gimplify_and_add (x, &thr01_list);\n+\n+\t    tree y = (DECL_HAS_VALUE_EXPR_P (new_vard)\n+\t\t      ? DECL_VALUE_EXPR (new_vard) : NULL_TREE);\n+\t    if (var3)\n+\t      {\n+\t\tx = lang_hooks.decls.omp_clause_assign_op (c, var2, var3);\n+\t\tgimplify_and_add (x, &thrn1_list);\n+\t\tx = lang_hooks.decls.omp_clause_assign_op (c, var2, var3);\n+\t\tgimplify_and_add (x, &thr02_list);\n+\t      }\n+\t    else if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))\n+\t      {\n+\t\t/* Otherwise, assign to it the identity element.  */\n+\t\tgimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n+\t\ttseq = copy_gimple_seq_and_replace_locals (tseq);\n+\t\tSET_DECL_VALUE_EXPR (new_vard, val);\n+\t\tDECL_HAS_VALUE_EXPR_P (new_vard) = 1;\n+\t\tSET_DECL_VALUE_EXPR (placeholder, error_mark_node);\n+\t\tDECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n+\t\tlower_omp (&tseq, ctx);\n+\t\tgimple_seq_add_seq (&thrn1_list, tseq);\n+\t\ttseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n+\t\tlower_omp (&tseq, ctx);\n+\t\tgimple_seq_add_seq (&thr02_list, tseq);\n+\t\tSET_DECL_VALUE_EXPR (placeholder, NULL_TREE);\n+\t\tDECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n+\t\tOMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n+\t\tif (y)\n+\t\t  SET_DECL_VALUE_EXPR (new_vard, y);\n+\t\telse\n+\t\t  {\n+\t\t    DECL_HAS_VALUE_EXPR_P (new_vard) = 0;\n+\t\t    SET_DECL_VALUE_EXPR (new_vard, NULL_TREE);\n+\t\t  }\n+\t      }\n+\n+\t    x = lang_hooks.decls.omp_clause_assign_op (c, var2, rprivam1_ref);\n+\t    gimplify_and_add (x, &thrn2_list);\n+\n+\t    if (ctx->scan_exclusive)\n+\t      {\n+\t\tx = unshare_expr (rprivb_ref);\n+\t\tx = lang_hooks.decls.omp_clause_assign_op (c, x, var2);\n+\t\tgimplify_and_add (x, &scan1_list);\n+\t      }\n+\n+\t    gimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c);\n+\t    tseq = copy_gimple_seq_and_replace_locals (tseq);\n+\t    SET_DECL_VALUE_EXPR (placeholder, var2);\n+\t    DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n+\t    lower_omp (&tseq, ctx);\n+\t    gimple_seq_add_seq (&scan1_list, tseq);\n+\n+\t    if (ctx->scan_inclusive)\n+\t      {\n+\t\tx = unshare_expr (rprivb_ref);\n+\t\tx = lang_hooks.decls.omp_clause_assign_op (c, x, var2);\n+\t\tgimplify_and_add (x, &scan1_list);\n+\t      }\n+\n+\t    x = unshare_expr (rpriva_ref);\n+\t    x = lang_hooks.decls.omp_clause_assign_op (c, x, var2);\n+\t    gimplify_and_add (x, &mdlist);\n+\n+\t    tseq = OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c);\n+\t    tseq = copy_gimple_seq_and_replace_locals (tseq);\n+\t    SET_DECL_VALUE_EXPR (new_vard, val);\n+\t    DECL_HAS_VALUE_EXPR_P (new_vard) = 1;\n+\t    SET_DECL_VALUE_EXPR (placeholder, rprivb_ref);\n+\t    lower_omp (&tseq, ctx);\n+\t    if (y)\n+\t      SET_DECL_VALUE_EXPR (new_vard, y);\n+\t    else\n+\t      {\n+\t\tDECL_HAS_VALUE_EXPR_P (new_vard) = 0;\n+\t\tSET_DECL_VALUE_EXPR (new_vard, NULL_TREE);\n+\t      }\n+\t    gimple_seq_add_seq (&input2_list, tseq);\n+\n+\t    x = unshare_expr (new_var);\n+\t    x = lang_hooks.decls.omp_clause_assign_op (c, x, rprivb_ref);\n+\t    gimplify_and_add (x, &input2_list);\n+\n+\t    x = build_outer_var_ref (var, ctx);\n+\t    x = lang_hooks.decls.omp_clause_assign_op (c, x, rpriva_ref);\n+\t    gimplify_and_add (x, &last_list);\n+\n+\t    x = lang_hooks.decls.omp_clause_assign_op (c, var2, rprivalmk_ref);\n+\t    gimplify_and_add (x, &reduc_list);\n+\t    tseq = OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c);\n+\t    tseq = copy_gimple_seq_and_replace_locals (tseq);\n+\t    val = rprival_ref;\n+\t    if (new_vard != new_var)\n+\t      val = build_fold_addr_expr_loc (clause_loc, val);\n+\t    SET_DECL_VALUE_EXPR (new_vard, val);\n+\t    DECL_HAS_VALUE_EXPR_P (new_vard) = 1;\n+\t    SET_DECL_VALUE_EXPR (placeholder, var2);\n+\t    lower_omp (&tseq, ctx);\n+\t    OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c) = NULL;\n+\t    SET_DECL_VALUE_EXPR (placeholder, NULL_TREE);\n+\t    DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n+\t    if (y)\n+\t      SET_DECL_VALUE_EXPR (new_vard, y);\n+\t    else\n+\t      {\n+\t\tDECL_HAS_VALUE_EXPR_P (new_vard) = 0;\n+\t\tSET_DECL_VALUE_EXPR (new_vard, NULL_TREE);\n+\t      }\n+\t    gimple_seq_add_seq (&reduc_list, tseq);\n+\t    x = lang_hooks.decls.omp_clause_assign_op (c, rprival_ref, var2);\n+\t    gimplify_and_add (x, &reduc_list);\n+\n+\t    x = lang_hooks.decls.omp_clause_dtor (c, var2);\n+\t    if (x)\n+\t      gimplify_and_add (x, dlist);\n+\t  }\n+\telse\n+\t  {\n+\t    x = build_outer_var_ref (var, ctx);\n+\t    gimplify_assign (var2, x, &thr01_list);\n+\n+\t    x = omp_reduction_init (c, TREE_TYPE (new_var));\n+\t    gimplify_assign (var2, unshare_expr (x), &thrn1_list);\n+\t    gimplify_assign (var2, x, &thr02_list);\n+\n+\t    gimplify_assign (var2, rprivam1_ref, &thrn2_list);\n+\n+\t    enum tree_code code = OMP_CLAUSE_REDUCTION_CODE (c);\n+\t    if (code == MINUS_EXPR)\n+\t      code = PLUS_EXPR;\n+\n+\t    if (ctx->scan_exclusive)\n+\t      gimplify_assign (unshare_expr (rprivb_ref), var2, &scan1_list);\n+\t    x = build2 (code, TREE_TYPE (new_var), var2, new_var);\n+\t    gimplify_assign (var2, x, &scan1_list);\n+\t    if (ctx->scan_inclusive)\n+\t      gimplify_assign (unshare_expr (rprivb_ref), var2, &scan1_list);\n+\n+\t    gimplify_assign (unshare_expr (rpriva_ref), var2, &mdlist);\n+\n+\t    x = build2 (code, TREE_TYPE (new_var), rprivb_ref, var2);\n+\t    gimplify_assign (new_var, x, &input2_list);\n+\n+\t    gimplify_assign (build_outer_var_ref (var, ctx), rpriva_ref,\n+\t\t\t     &last_list);\n+\n+\t    x = build2 (code, TREE_TYPE (new_var), rprivalmk_ref,\n+\t\t\tunshare_expr (rprival_ref));\n+\t    gimplify_assign (rprival_ref, x, &reduc_list);\n+\t  }\n+      }\n+\n+  g = gimple_build_assign (ivar, PLUS_EXPR, ivar, size_one_node);\n+  gimple_seq_add_stmt (&scan1_list, g);\n+  g = gimple_build_assign (ivar, PLUS_EXPR, ivar, size_one_node);\n+  gimple_seq_add_stmt (gimple_omp_body_ptr (scan_stmt2), g);\n+\n+  tree controlb = create_tmp_var (boolean_type_node);\n+  tree controlp = create_tmp_var (ptr_type_node);\n+  tree nc = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__SCANTEMP_);\n+  OMP_CLAUSE_DECL (nc) = controlb;\n+  OMP_CLAUSE__SCANTEMP__CONTROL (nc) = 1;\n+  *cp1 = nc;\n+  cp1 = &OMP_CLAUSE_CHAIN (nc);\n+  nc = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__SCANTEMP_);\n+  OMP_CLAUSE_DECL (nc) = controlp;\n+  OMP_CLAUSE__SCANTEMP__CONTROL (nc) = 1;\n+  *cp1 = nc;\n+  cp1 = &OMP_CLAUSE_CHAIN (nc);\n+  nc = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__SCANTEMP_);\n+  OMP_CLAUSE_DECL (nc) = controlb;\n+  OMP_CLAUSE__SCANTEMP__CONTROL (nc) = 1;\n+  *cp2 = nc;\n+  cp2 = &OMP_CLAUSE_CHAIN (nc);\n+  nc = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__SCANTEMP_);\n+  OMP_CLAUSE_DECL (nc) = controlp;\n+  OMP_CLAUSE__SCANTEMP__CONTROL (nc) = 1;\n+  *cp2 = nc;\n+  cp2 = &OMP_CLAUSE_CHAIN (nc);\n+\n+  *cp1 = gimple_omp_for_clauses (stmt);\n+  gimple_omp_for_set_clauses (stmt, new_clauses1);\n+  *cp2 = gimple_omp_for_clauses (new_stmt);\n+  gimple_omp_for_set_clauses (new_stmt, new_clauses2);\n+\n+  gimple_omp_set_body (scan_stmt1, scan1_list);\n+  gimple_omp_set_body (input_stmt2, input2_list);\n+\n+  gsi_insert_seq_after (&input1_gsi, gimple_omp_body (input_stmt1),\n+\t\t\tGSI_SAME_STMT);\n+  gsi_remove (&input1_gsi, true);\n+  gsi_insert_seq_after (&scan1_gsi, gimple_omp_body (scan_stmt1),\n+\t\t\tGSI_SAME_STMT);\n+  gsi_remove (&scan1_gsi, true);\n+  gsi_insert_seq_after (&input2_gsi, gimple_omp_body (input_stmt2),\n+\t\t\tGSI_SAME_STMT);\n+  gsi_remove (&input2_gsi, true);\n+  gsi_insert_seq_after (&scan2_gsi, gimple_omp_body (scan_stmt2),\n+\t\t\tGSI_SAME_STMT);\n+  gsi_remove (&scan2_gsi, true);\n+\n+  gimple_seq_add_seq (body_p, clist);\n+\n+  tree lab1 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree lab2 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree lab3 = create_artificial_label (UNKNOWN_LOCATION);\n+  g = gimple_build_cond (EQ_EXPR, thread_num, integer_zero_node, lab1, lab2);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab1);\n+  gimple_seq_add_stmt (body_p, g);\n+  gimple_seq_add_seq (body_p, thr01_list);\n+  g = gimple_build_goto (lab3);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab2);\n+  gimple_seq_add_stmt (body_p, g);\n+  gimple_seq_add_seq (body_p, thrn1_list);\n+  g = gimple_build_label (lab3);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = gimple_build_assign (ivar, size_zero_node);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  gimple_seq_add_stmt (body_p, stmt);\n+  gimple_seq_add_seq (body_p, body);\n+  gimple_seq_add_stmt (body_p, gimple_build_omp_continue (fd->loop.v,\n+\t\t\t\t\t\t\t  fd->loop.v));\n+\n+  g = gimple_build_omp_return (true);\n+  gimple_seq_add_stmt (body_p, g);\n+  gimple_seq_add_seq (body_p, mdlist);\n+\n+  lab1 = create_artificial_label (UNKNOWN_LOCATION);\n+  lab2 = create_artificial_label (UNKNOWN_LOCATION);\n+  g = gimple_build_cond (GT_EXPR, num_threads, integer_one_node, lab1, lab2);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab1);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = omp_build_barrier (NULL);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree down = create_tmp_var (unsigned_type_node);\n+  g = gimple_build_assign (down, build_zero_cst (unsigned_type_node));\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = gimple_build_assign (k, build_one_cst (unsigned_type_node));\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree num_threadsu = create_tmp_var (unsigned_type_node);\n+  g = gimple_build_assign (num_threadsu, NOP_EXPR, num_threads);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree thread_numu = create_tmp_var (unsigned_type_node);\n+  g = gimple_build_assign (thread_numu, NOP_EXPR, thread_num);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree thread_nump1 = create_tmp_var (unsigned_type_node);\n+  g = gimple_build_assign (thread_nump1, PLUS_EXPR, thread_numu,\n+\t\t\t   build_int_cst (unsigned_type_node, 1));\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  lab3 = create_artificial_label (UNKNOWN_LOCATION);\n+  g = gimple_build_label (lab3);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree twok = create_tmp_var (unsigned_type_node);\n+  g = gimple_build_assign (twok, LSHIFT_EXPR, k, integer_one_node);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree lab4 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree lab5 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree lab6 = create_artificial_label (UNKNOWN_LOCATION);\n+  g = gimple_build_cond (GT_EXPR, twok, num_threadsu, lab4, lab5);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab4);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_assign (down, build_all_ones_cst (unsigned_type_node));\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_assign (k, RSHIFT_EXPR, k, integer_one_node);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = gimple_build_cond (EQ_EXPR, k, num_threadsu, lab6, lab5);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab6);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = gimple_build_assign (k, RSHIFT_EXPR, k, integer_one_node);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = gimple_build_label (lab5);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = gimple_build_assign (twok, LSHIFT_EXPR, k, integer_one_node);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree cplx = create_tmp_var (build_complex_type (unsigned_type_node, false));\n+  g = gimple_build_call_internal (IFN_MUL_OVERFLOW, 2, thread_nump1, twok);\n+  gimple_call_set_lhs (g, cplx);\n+  gimple_seq_add_stmt (body_p, g);\n+  tree mul = create_tmp_var (unsigned_type_node);\n+  g = gimple_build_assign (mul, REALPART_EXPR,\n+\t\t\t   build1 (REALPART_EXPR, unsigned_type_node, cplx));\n+  gimple_seq_add_stmt (body_p, g);\n+  tree ovf = create_tmp_var (unsigned_type_node);\n+  g = gimple_build_assign (ovf, IMAGPART_EXPR,\n+\t\t\t   build1 (IMAGPART_EXPR, unsigned_type_node, cplx));\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree lab7 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree lab8 = create_artificial_label (UNKNOWN_LOCATION);\n+  g = gimple_build_cond (EQ_EXPR, ovf, build_zero_cst (unsigned_type_node),\n+\t\t\t lab7, lab8);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab7);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree andv = create_tmp_var (unsigned_type_node);\n+  g = gimple_build_assign (andv, BIT_AND_EXPR, k, down);\n+  gimple_seq_add_stmt (body_p, g);\n+  tree andvm1 = create_tmp_var (unsigned_type_node);\n+  g = gimple_build_assign (andvm1, PLUS_EXPR, andv,\n+\t\t\t   build_minus_one_cst (unsigned_type_node));\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = gimple_build_assign (l, PLUS_EXPR, mul, andvm1);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree lab9 = create_artificial_label (UNKNOWN_LOCATION);\n+  g = gimple_build_cond (LT_EXPR, l, num_threadsu, lab9, lab8);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab9);\n+  gimple_seq_add_stmt (body_p, g);\n+  gimple_seq_add_seq (body_p, reduc_list);\n+  g = gimple_build_label (lab8);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  tree lab10 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree lab11 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree lab12 = create_artificial_label (UNKNOWN_LOCATION);\n+  g = gimple_build_cond (EQ_EXPR, down, build_zero_cst (unsigned_type_node),\n+\t\t\t lab10, lab11);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab10);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_assign (k, LSHIFT_EXPR, k, integer_one_node);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_goto (lab12);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab11);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_assign (k, RSHIFT_EXPR, k, integer_one_node);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab12);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = omp_build_barrier (NULL);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = gimple_build_cond (NE_EXPR, k, build_zero_cst (unsigned_type_node),\n+\t\t\t lab3, lab2);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = gimple_build_label (lab2);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  lab1 = create_artificial_label (UNKNOWN_LOCATION);\n+  lab2 = create_artificial_label (UNKNOWN_LOCATION);\n+  lab3 = create_artificial_label (UNKNOWN_LOCATION);\n+  g = gimple_build_cond (EQ_EXPR, thread_num, integer_zero_node, lab1, lab2);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab1);\n+  gimple_seq_add_stmt (body_p, g);\n+  gimple_seq_add_seq (body_p, thr02_list);\n+  g = gimple_build_goto (lab3);\n+  gimple_seq_add_stmt (body_p, g);\n+  g = gimple_build_label (lab2);\n+  gimple_seq_add_stmt (body_p, g);\n+  gimple_seq_add_seq (body_p, thrn2_list);\n+  g = gimple_build_label (lab3);\n+  gimple_seq_add_stmt (body_p, g);\n+\n+  g = gimple_build_assign (ivar, size_zero_node);\n+  gimple_seq_add_stmt (body_p, g);\n+  gimple_seq_add_stmt (body_p, new_stmt);\n+  gimple_seq_add_seq (body_p, new_body);\n+\n+  gimple_seq new_dlist = NULL;\n+  lab1 = create_artificial_label (UNKNOWN_LOCATION);\n+  lab2 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree num_threadsm1 = create_tmp_var (integer_type_node);\n+  g = gimple_build_assign (num_threadsm1, PLUS_EXPR, num_threads,\n+\t\t\t   integer_minus_one_node);\n+  gimple_seq_add_stmt (&new_dlist, g);\n+  g = gimple_build_cond (EQ_EXPR, thread_num, num_threadsm1, lab1, lab2);\n+  gimple_seq_add_stmt (&new_dlist, g);\n+  g = gimple_build_label (lab1);\n+  gimple_seq_add_stmt (&new_dlist, g);\n+  gimple_seq_add_seq (&new_dlist, last_list);\n+  g = gimple_build_label (lab2);\n+  gimple_seq_add_stmt (&new_dlist, g);\n+  gimple_seq_add_seq (&new_dlist, *dlist);\n+  *dlist = new_dlist;\n+}\n \n /* Lower code for an OMP loop directive.  */\n \n@@ -9317,9 +9999,18 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   bool phony_loop = (gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_GRID_LOOP\n \t\t     && gimple_omp_for_grid_phony (stmt));\n-  if (!phony_loop)\n-    gimple_seq_add_stmt (&body, stmt);\n-  gimple_seq_add_seq (&body, gimple_omp_body (stmt));\n+  if ((ctx->scan_inclusive || ctx->scan_exclusive)\n+      && gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_FOR)\n+    {\n+      gcc_assert (!phony_loop);\n+      lower_omp_for_scan (&body, &dlist, stmt, &fd, ctx);\n+    }\n+  else\n+    {\n+      if (!phony_loop)\n+\tgimple_seq_add_stmt (&body, stmt);\n+      gimple_seq_add_seq (&body, gimple_omp_body (stmt));\n+    }\n \n   if (!phony_loop)\n     gimple_seq_add_stmt (&body, gimple_build_omp_continue (fd.loop.v,"}, {"sha": "b2c4cc31b10731e528f219ec25e688c3024f10f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -1,5 +1,8 @@\n 2019-07-03  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* c-c++-common/gomp/scan-3.c (f1): Don't expect a sorry message.\n+\t* c-c++-common/gomp/scan-5.c (foo): Likewise.\n+\n \t* c-c++-common/gomp/scan-5.c: New test.\n \n \t* c-c++-common/gomp/lastprivate-conditional-5.c: New test."}, {"sha": "4e290eb02dfdffeac8486008d8ec901173ca4755", "filename": "gcc/testsuite/c-c++-common/gomp/scan-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-3.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -8,7 +8,7 @@ f1 (int *c, int *d)\n   for (i = 0; i < 64; i++)\n     {\n       d[i] = a;\n-      #pragma omp scan inclusive (a)\t\t/* { dg-message \"sorry, unimplemented: '#pragma omp scan' not supported yet\" } */\n+      #pragma omp scan inclusive (a)\n       a += c[i];\n     }\n }"}, {"sha": "8241621d35990709b3de155b4943146529a55848", "filename": "gcc/testsuite/c-c++-common/gomp/scan-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-5.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -6,7 +6,7 @@ foo (int *a, int *b)\n   for (int i = 0; i < 64; i++)\n     {\n       r += a[i];\n-      #pragma omp scan inclusive (r)\t/* { dg-message \"sorry, unimplemented: '#pragma omp scan' not supported yet\" } */\n+      #pragma omp scan inclusive (r)\n       b[i] = r;\n     }\n   return r;"}, {"sha": "9ea8638c3c0401cdc573b545074339dc2d989b4b", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -352,6 +352,9 @@ enum omp_clause_code {\n   /* Internal clause: temporary for lastprivate(conditional:).  */\n   OMP_CLAUSE__CONDTEMP_,\n \n+  /* Internal clause: temporary for inscan reductions.  */\n+  OMP_CLAUSE__SCANTEMP_,\n+\n   /* OpenACC/OpenMP clause: if (scalar-expression).  */\n   OMP_CLAUSE_IF,\n "}, {"sha": "e703cd982a6c1afe9e89f0da639d2d89b850b668", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -1349,6 +1349,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_IF_PRESENT:\n \tcase OMP_CLAUSE_FINALIZE:\n \tcase OMP_CLAUSE__CONDTEMP_:\n+\tcase OMP_CLAUSE__SCANTEMP_:\n \t  break;\n \n \t  /* The following clause belongs to the OpenACC cache directive, which\n@@ -2078,6 +2079,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_IF_PRESENT:\n \tcase OMP_CLAUSE_FINALIZE:\n \tcase OMP_CLAUSE__CONDTEMP_:\n+\tcase OMP_CLAUSE__SCANTEMP_:\n \t  break;\n \n \t  /* The following clause belongs to the OpenACC cache directive, which"}, {"sha": "dacda7bd0534627e0fef24dcc3bddb972fcd7cd1", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -483,6 +483,9 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n     case OMP_CLAUSE__CONDTEMP_:\n       name = \"_condtemp_\";\n       goto print_remap;\n+    case OMP_CLAUSE__SCANTEMP_:\n+      name = \"_scantemp_\";\n+      goto print_remap;\n     case OMP_CLAUSE_TO_DECLARE:\n       name = \"to\";\n       goto print_remap;"}, {"sha": "76d94c6578a5ed9216e72d275d7400815a47c21f", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -311,6 +311,7 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE__LOOPTEMP_  */\n   1, /* OMP_CLAUSE__REDUCTEMP_  */\n   1, /* OMP_CLAUSE__CONDTEMP_  */\n+  1, /* OMP_CLAUSE__SCANTEMP_  */\n   1, /* OMP_CLAUSE_IF  */\n   1, /* OMP_CLAUSE_NUM_THREADS  */\n   1, /* OMP_CLAUSE_SCHEDULE  */\n@@ -391,6 +392,7 @@ const char * const omp_clause_code_name[] =\n   \"_looptemp_\",\n   \"_reductemp_\",\n   \"_condtemp_\",\n+  \"_scantemp_\",\n   \"if\",\n   \"num_threads\",\n   \"schedule\",\n@@ -12316,6 +12318,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE__REDUCTEMP_:\n \tcase OMP_CLAUSE__CONDTEMP_:\n+\tcase OMP_CLAUSE__SCANTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n \t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 0));\n \t  /* FALLTHRU */"}, {"sha": "3dce602dfbaca03f568e1c3638d56dfe3a3fd01c", "filename": "gcc/tree.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -1449,7 +1449,7 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE_DECL(NODE)      \t\t\t\t\t\\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),\t\\\n \t\t\t\t\t      OMP_CLAUSE_PRIVATE,\t\\\n-\t\t\t\t\t      OMP_CLAUSE__CONDTEMP_), 0)\n+\t\t\t\t\t      OMP_CLAUSE__SCANTEMP_), 0)\n #define OMP_CLAUSE_HAS_LOCATION(NODE) \\\n   (LOCATION_LOCUS ((OMP_CLAUSE_CHECK (NODE))->omp_clause.locus)\t\t\\\n   != UNKNOWN_LOCATION)\n@@ -1761,6 +1761,17 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE__CONDTEMP__ITER(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__CONDTEMP_)->base.public_flag)\n \n+/* _SCANTEMP_ holding temporary with pointer to thread's local array;\n+   allocation.  */\n+#define OMP_CLAUSE__SCANTEMP__ALLOC(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__SCANTEMP_)->base.public_flag)\n+\n+/* _SCANTEMP_ holding temporary with a control variable for deallocation;\n+   one boolean_type_node for test whether alloca was used, another one\n+   to pass to __builtin_stack_restore or free.  */\n+#define OMP_CLAUSE__SCANTEMP__CONTROL(NODE) \\\n+  TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__SCANTEMP_))\n+\n /* SSA_NAME accessors.  */\n \n /* Whether SSA_NAME NODE is a virtual operand.  This simply caches the"}, {"sha": "e54f260a6a7009a9debc7d406da39d7d08b335e5", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -1,3 +1,22 @@\n+2019-07-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.c++/scan-1.C: New test.\n+\t* testsuite/libgomp.c++/scan-2.C: New test.\n+\t* testsuite/libgomp.c++/scan-3.C: New test.\n+\t* testsuite/libgomp.c++/scan-4.C: New test.\n+\t* testsuite/libgomp.c++/scan-5.C: New test.\n+\t* testsuite/libgomp.c++/scan-6.C: New test.\n+\t* testsuite/libgomp.c++/scan-7.C: New test.\n+\t* testsuite/libgomp.c++/scan-8.C: New test.\n+\t* testsuite/libgomp.c/scan-1.c: New test.\n+\t* testsuite/libgomp.c/scan-2.c: New test.\n+\t* testsuite/libgomp.c/scan-3.c: New test.\n+\t* testsuite/libgomp.c/scan-4.c: New test.\n+\t* testsuite/libgomp.c/scan-5.c: New test.\n+\t* testsuite/libgomp.c/scan-6.c: New test.\n+\t* testsuite/libgomp.c/scan-7.c: New test.\n+\t* testsuite/libgomp.c/scan-8.c: New test.\n+\n 2019-06-18  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* testsuite/libgomp.oacc-c++/firstprivate-mappings-1.C: New file."}, {"sha": "d148dac924b37fbcf1ca56eafd996eb4064283c9", "filename": "libgomp/testsuite/libgomp.c++/scan-1.C", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-1.C?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,151 @@\n+// { dg-require-effective-target size32plus }\n+\n+extern \"C\" void abort ();\n+\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  int s;\n+};\n+\n+S::S () : s (0)\n+{\n+}\n+\n+S::~S ()\n+{\n+}\n+\n+S::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+S &\n+S::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+static inline void\n+ini (S &x)\n+{\n+  x.s = 0;\n+}\n+\n+S r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+__attribute__((noipa)) void\n+foo (S *a, S *b)\n+{\n+  #pragma omp for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+bar (void)\n+{\n+  S s;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return S (s);\n+}\n+\n+__attribute__((noipa)) void\n+baz (S *a, S *b)\n+{\n+  #pragma omp parallel for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+qux (void)\n+{\n+  S s;\n+  #pragma omp parallel for reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return S (s);\n+}\n+\n+int\n+main ()\n+{\n+  S s;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (bar ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+  r.s = 0;\n+  baz (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "94555ccde30ea137c765490cbdb6062eac0e4e64", "filename": "libgomp/testsuite/libgomp.c++/scan-2.C", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-2.C?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,116 @@\n+// { dg-require-effective-target size32plus }\n+\n+extern \"C\" void abort ();\n+int r, a[1024], b[1024], q;\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, int &r)\n+{\n+  #pragma omp for reduction (inscan, +:r) nowait\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, +:s) nowait\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, int &r)\n+{\n+  #pragma omp parallel for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel for reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+}"}, {"sha": "5e83958bf77e0e89b7d0aef225a4077ffca3a61f", "filename": "libgomp/testsuite/libgomp.c++/scan-3.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-3.C?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,119 @@\n+// { dg-require-effective-target size32plus }\n+\n+extern \"C\" void abort ();\n+int r, a[1024], b[1024], q;\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, int &r)\n+{\n+  #pragma omp for reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, int &r)\n+{\n+  #pragma omp parallel for reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel for reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "fc2c682849f1dbe95281b9fa6d14fc90c61d8707", "filename": "libgomp/testsuite/libgomp.c++/scan-4.C", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-4.C?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,150 @@\n+// { dg-require-effective-target size32plus }\n+\n+extern \"C\" void abort ();\n+\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  int s;\n+};\n+\n+S::S () : s (0)\n+{\n+}\n+\n+S::~S ()\n+{\n+}\n+\n+S::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+S &\n+S::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+static inline void\n+ini (S &x)\n+{\n+  x.s = 0;\n+}\n+\n+S r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+__attribute__((noipa)) void\n+foo (S *a, S *b, S &r)\n+{\n+  #pragma omp for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+bar ()\n+{\n+  S s;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (S *a, S *b, S &r)\n+{\n+  #pragma omp parallel for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+qux ()\n+{\n+  S s;\n+  #pragma omp parallel for reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  S s;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (bar ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+  r.s = 0;\n+  baz (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+}"}, {"sha": "5931a7fe14e856901b34de4557d429ed6af3a8b8", "filename": "libgomp/testsuite/libgomp.c++/scan-5.C", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-5.C?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,158 @@\n+// { dg-require-effective-target size32plus }\n+\n+extern \"C\" void abort ();\n+\n+template <typename T>\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  T s;\n+};\n+\n+template <typename T>\n+S<T>::S () : s (0)\n+{\n+}\n+\n+template <typename T>\n+S<T>::~S ()\n+{\n+}\n+\n+template <typename T>\n+S<T>::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+template <typename T>\n+S<T> &\n+S<T>::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+template <typename T>\n+static inline void\n+ini (S<T> &x)\n+{\n+  x.s = 0;\n+}\n+\n+S<int> r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S<int>: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S<int>: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+template <typename T>\n+__attribute__((noipa)) void\n+foo (S<T> *a, S<T> *b)\n+{\n+  #pragma omp for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) S<T>\n+bar (void)\n+{\n+  S<T> s;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return S<T> (s);\n+}\n+\n+__attribute__((noipa)) void\n+baz (S<int> *a, S<int> *b)\n+{\n+  #pragma omp parallel for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+__attribute__((noipa)) S<int>\n+qux (void)\n+{\n+  S<int> s;\n+  #pragma omp parallel for reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return S<int> (s);\n+}\n+\n+int\n+main ()\n+{\n+  S<int> s;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (bar<int> ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+  r.s = 0;\n+  baz (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+}"}, {"sha": "46674e7a243cb7fe4ce92cdabf98fb3effca7723", "filename": "libgomp/testsuite/libgomp.c++/scan-6.C", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-6.C?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,120 @@\n+// { dg-require-effective-target size32plus }\n+\n+extern \"C\" void abort ();\n+int r, a[1024], b[1024], q;\n+\n+template <typename T, typename U>\n+__attribute__((noipa)) void\n+foo (T a, T b, U r)\n+{\n+  #pragma omp for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) T\n+bar ()\n+{\n+  T &s = q;\n+  q = 0;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) void\n+baz (T *a, T *b, T &r)\n+{\n+  #pragma omp parallel for reduction (inscan, +:r)\n+  for (T i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) int\n+qux ()\n+{\n+  T s = q;\n+  q = 0;\n+  #pragma omp parallel for reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo<int *, int &> (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar<int> () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz<int> (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux<int &> () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+}"}, {"sha": "ebeb20302bfa22700edf02489bb2a4b9c0998204", "filename": "libgomp/testsuite/libgomp.c++/scan-7.C", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-7.C?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,118 @@\n+// { dg-require-effective-target size32plus }\n+\n+extern \"C\" void abort ();\n+int r, a[1024], b[1024], q;\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, int &r)\n+{\n+  #pragma omp for reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, foo:s) nowait\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, int &r)\n+{\n+  #pragma omp parallel for reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel for reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+}"}, {"sha": "cfdfb6b7624c9753d8c6cad3770f867b4d524566", "filename": "libgomp/testsuite/libgomp.c++/scan-8.C", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-8.C?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,150 @@\n+// { dg-require-effective-target size32plus }\n+\n+extern \"C\" void abort ();\n+\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  int s;\n+};\n+\n+S::S () : s (0)\n+{\n+}\n+\n+S::~S ()\n+{\n+}\n+\n+S::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+S &\n+S::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+static inline void\n+ini (S &x)\n+{\n+  x.s = 0;\n+}\n+\n+S r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+__attribute__((noipa)) void\n+foo (S *a, S *b, S &r)\n+{\n+  #pragma omp for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+bar (void)\n+{\n+  S s;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (S *a, S *b, S &r)\n+{\n+  #pragma omp parallel for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+qux (void)\n+{\n+  S s;\n+  #pragma omp parallel for reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  S s;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (bar ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+  r.s = 0;\n+  baz (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+}"}, {"sha": "dd34f33a694f435ef3e9a872653b351e0fc555c9", "filename": "libgomp/testsuite/libgomp.c/scan-1.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-1.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,115 @@\n+/* { dg-require-effective-target size32plus } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp parallel for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel for reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "476bbedfd60a66d8c53861fc2087f64ac0850d2b", "filename": "libgomp/testsuite/libgomp.c/scan-2.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-2.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,117 @@\n+/* { dg-require-effective-target size32plus } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp for reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp parallel for reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel for reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "2e1fcadba04632af1f2c7faad51d4354a2d90cf5", "filename": "libgomp/testsuite/libgomp.c/scan-3.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-3.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-require-effective-target size32plus } */\n+\n+extern void abort (void);\n+float r = 1.0f, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (float *a, float *b)\n+{\n+  #pragma omp for reduction (inscan, *:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r *= a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) float\n+bar (void)\n+{\n+  float s = -__builtin_inff ();\n+  #pragma omp parallel for reduction (inscan, max:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s = s > a[i] ? s : a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  float s = 1.0f;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (i < 80)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 200)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else if (i < 280)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 380)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else\n+\tswitch (i % 6)\n+\t  {\n+\t  case 0: a[i] = 0.25f; break;\n+\t  case 1: a[i] = 2.0f; break;\n+\t  case 2: a[i] = -1.0f; break;\n+\t  case 3: a[i] = -4.0f; break;\n+\t  case 4: a[i] = 0.5f; break;\n+\t  case 5: a[i] = 1.0f; break;\n+\t  default: a[i] = 0.0f; break;\n+\t  }\n+      b[i] = -19.0f;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r * 16384.0f != 0.125f)\n+    abort ();\n+  float m = -175.25f;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s *= a[i];\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\t{\n+\t  a[i] = m - ((i % 3) == 1 ? 2.0f : (i % 3) == 2 ? 4.0f : 0.0f);\n+\t  b[i] = -231.75f;\n+\t  m += 0.75f;\n+\t}\n+    }\n+  if (bar () != 592.0f)\n+    abort ();\n+  s = -__builtin_inff ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (s < a[i])\n+\ts = a[i];\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "b1e999352fa2072312e7edd5511d7e79112011e5", "filename": "libgomp/testsuite/libgomp.c/scan-4.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-4.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,179 @@\n+/* { dg-require-effective-target size32plus } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+unsigned short r2, b2[1024];\n+unsigned char r3, b3[1024];\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, unsigned short *b2, unsigned char *b3)\n+{\n+  #pragma omp for reduction (inscan, +:r, r2, r3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      { r += a[i]; r2 += a[i]; r3 += a[i]; }\n+      #pragma omp scan inclusive(r, r2, r3)\n+      {\n+\tb[i] = r;\n+\tb2[i] = r2;\n+\tb3[i] = r3;\n+      }\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (unsigned short *s2p, unsigned char *s3p)\n+{\n+  int s = 0;\n+  unsigned short s2 = 0;\n+  unsigned char s3 = 0;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, +:s, s2, s3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      {\n+\ts += 2 * a[i];\n+\ts2 += 2 * a[i];\n+\ts3 += 2 * a[i];\n+      }\n+      #pragma omp scan inclusive(s, s2, s3)\n+      { b[i] = s; b2[i] = s2; b3[i] = s3; }\n+    }\n+  *s2p = s2;\n+  *s3p = s3;\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, unsigned short *b2, unsigned char *b3)\n+{\n+  #pragma omp parallel for reduction (inscan, +:r, r2, r3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      {\n+\tr += a[i];\n+\tr2 += a[i];\n+\tr3 += a[i];\n+      }\n+      #pragma omp scan inclusive(r, r2, r3)\n+      {\n+\tb[i] = r;\n+\tb2[i] = r2;\n+\tb3[i] = r3;\n+      }\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (unsigned short *s2p, unsigned char *s3p)\n+{\n+  int s = 0;\n+  unsigned short s2 = 0;\n+  unsigned char s3 = 0;\n+  #pragma omp parallel for reduction (inscan, +:s, s2, s3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      { s += 2 * a[i]; s2 += 2 * a[i]; s3 += 2 * a[i]; }\n+      #pragma omp scan inclusive(s, s2, s3)\n+      { b[i] = s; b2[i] = s2; b3[i] = s3; }\n+    }\n+  *s2p = s2;\n+  *s3p = s3;\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  unsigned short s2;\n+  unsigned char s3;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      b2[i] = -1;\n+      b3[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, b2, b3);\n+  if (r != 1024 * 1023 / 2\n+      || r2 != (unsigned short) r\n+      || r3 != (unsigned char) r)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = 25;\n+\t  b2[i] = 24;\n+\t  b3[i] = 26;\n+\t}\n+    }\n+  if (bar (&s2, &s3) != 1024 * 1023)\n+    abort ();\n+  if (s2 != (unsigned short) (1024 * 1023)\n+      || s3 != (unsigned char) (1024 * 1023))\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = -1;\n+\t  b2[i] = -1;\n+\t  b3[i] = -1;\n+\t}\n+    }\n+  r = 0;\n+  r2 = 0;\n+  r3 = 0;\n+  baz (a, b, b2, b3);\n+  if (r != 1024 * 1023 / 2\n+      || r2 != (unsigned short) r\n+      || r3 != (unsigned char) r)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = 25;\n+\t  b2[i] = 24;\n+\t  b3[i] = 26;\n+\t}\n+    }\n+  s2 = 0;\n+  s3 = 0;\n+  if (qux (&s2, &s3) != 1024 * 1023)\n+    abort ();\n+  if (s2 != (unsigned short) (1024 * 1023)\n+      || s3 != (unsigned char) (1024 * 1023))\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "c50418264efc391201d252f4a28a430ee1035b52", "filename": "libgomp/testsuite/libgomp.c/scan-5.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-5.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,115 @@\n+/* { dg-require-effective-target size32plus } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp parallel for reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel for reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+  return 0;\n+}"}, {"sha": "9434ebb2b5a305c6c7ecbaedb0f5a1bebb4facc0", "filename": "libgomp/testsuite/libgomp.c/scan-6.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-6.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,117 @@\n+/* { dg-require-effective-target size32plus } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp for reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp parallel for reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel for reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+  return 0;\n+}"}, {"sha": "20b7071e8f6bb293eaa0d8baa89d8eb1f865b011", "filename": "libgomp/testsuite/libgomp.c/scan-7.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-7.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-require-effective-target size32plus } */\n+\n+extern void abort (void);\n+float r = 1.0f, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (float *a, float *b)\n+{\n+  #pragma omp for reduction (inscan, *:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r *= a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) float\n+bar (void)\n+{\n+  float s = -__builtin_inff ();\n+  #pragma omp parallel for reduction (inscan, max:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s = s > a[i] ? s : a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  float s = 1.0f;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (i < 80)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 200)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else if (i < 280)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 380)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else\n+\tswitch (i % 6)\n+\t  {\n+\t  case 0: a[i] = 0.25f; break;\n+\t  case 1: a[i] = 2.0f; break;\n+\t  case 2: a[i] = -1.0f; break;\n+\t  case 3: a[i] = -4.0f; break;\n+\t  case 4: a[i] = 0.5f; break;\n+\t  case 5: a[i] = 1.0f; break;\n+\t  default: a[i] = 0.0f; break;\n+\t  }\n+      b[i] = -19.0f;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r * 16384.0f != 0.125f)\n+    abort ();\n+  float m = -175.25f;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -231.75f;\n+      s *= a[i];\n+      a[i] = m - ((i % 3) == 1 ? 2.0f : (i % 3) == 2 ? 4.0f : 0.0f);\n+      m += 0.75f;\n+    }\n+  if (bar () != 592.0f)\n+    abort ();\n+  s = -__builtin_inff ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      if (s < a[i])\n+\ts = a[i];\n+    }\n+  return 0;\n+}"}, {"sha": "f09c85c36e7e98a96fdbe241580c23d3b933b793", "filename": "libgomp/testsuite/libgomp.c/scan-8.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6bb511d1003d31ec1213081b6c2514cc10f0f9/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-8.c?ref=2f6bb511d1003d31ec1213081b6c2514cc10f0f9", "patch": "@@ -0,0 +1,179 @@\n+/* { dg-require-effective-target size32plus } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+unsigned short r2, b2[1024];\n+unsigned char r3, b3[1024];\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, unsigned short *b2, unsigned char *b3)\n+{\n+  #pragma omp for reduction (inscan, +:r, r2, r3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      {\n+\tb[i] = r;\n+\tb2[i] = r2;\n+\tb3[i] = r3;\n+      }\n+      #pragma omp scan exclusive(r, r2, r3)\n+      { r += a[i]; r2 += a[i]; r3 += a[i]; }\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (unsigned short *s2p, unsigned char *s3p)\n+{\n+  int s = 0;\n+  unsigned short s2 = 0;\n+  unsigned char s3 = 0;\n+  #pragma omp parallel\n+  #pragma omp for reduction (inscan, +:s, s2, s3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      { b[i] = s; b2[i] = s2; b3[i] = s3; }\n+      #pragma omp scan exclusive(s, s2, s3)\n+      {\n+\ts += 2 * a[i];\n+\ts2 += 2 * a[i];\n+\ts3 += 2 * a[i];\n+      }\n+    }\n+  *s2p = s2;\n+  *s3p = s3;\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, unsigned short *b2, unsigned char *b3)\n+{\n+  #pragma omp parallel for reduction (inscan, +:r, r2, r3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      {\n+\tb[i] = r;\n+\tb2[i] = r2;\n+\tb3[i] = r3;\n+      }\n+      #pragma omp scan exclusive(r, r2, r3)\n+      {\n+\tr += a[i];\n+\tr2 += a[i];\n+\tr3 += a[i];\n+      }\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (unsigned short *s2p, unsigned char *s3p)\n+{\n+  int s = 0;\n+  unsigned short s2 = 0;\n+  unsigned char s3 = 0;\n+  #pragma omp parallel for reduction (inscan, +:s, s2, s3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      { b[i] = s; b2[i] = s2; b3[i] = s3; }\n+      #pragma omp scan exclusive(s, s2, s3)\n+      { s += 2 * a[i]; s2 += 2 * a[i]; s3 += 2 * a[i]; }\n+    }\n+  *s2p = s2;\n+  *s3p = s3;\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  unsigned short s2;\n+  unsigned char s3;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      b2[i] = -1;\n+      b3[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, b2, b3);\n+  if (r != 1024 * 1023 / 2\n+      || r2 != (unsigned short) r\n+      || r3 != (unsigned char) r)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = 25;\n+\t  b2[i] = 24;\n+\t  b3[i] = 26;\n+\t}\n+      s += i;\n+    }\n+  if (bar (&s2, &s3) != 1024 * 1023)\n+    abort ();\n+  if (s2 != (unsigned short) (1024 * 1023)\n+      || s3 != (unsigned char) (1024 * 1023))\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = -1;\n+\t  b2[i] = -1;\n+\t  b3[i] = -1;\n+\t}\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  r2 = 0;\n+  r3 = 0;\n+  baz (a, b, b2, b3);\n+  if (r != 1024 * 1023 / 2\n+      || r2 != (unsigned short) r\n+      || r3 != (unsigned char) r)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = 25;\n+\t  b2[i] = 24;\n+\t  b3[i] = 26;\n+\t}\n+      s += i;\n+    }\n+  s2 = 0;\n+  s3 = 0;\n+  if (qux (&s2, &s3) != 1024 * 1023)\n+    abort ();\n+  if (s2 != (unsigned short) (1024 * 1023)\n+      || s3 != (unsigned char) (1024 * 1023))\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+  return 0;\n+}"}]}