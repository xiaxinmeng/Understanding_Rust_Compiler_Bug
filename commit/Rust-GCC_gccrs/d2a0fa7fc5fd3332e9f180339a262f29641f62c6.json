{"sha": "d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "node_id": "C_kwDOANBUbNoAKGQyYTBmYTdmYzVmZDMzMzJlOWYxODAzMzlhMjYyZjI5NjQxZjYyYzY", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-02T14:25:50Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-02T15:50:13Z"}, "message": "Add new RustIdent struct to track canonical-path and location info\n\nThis refactors our TyTy type abstractions to contain their repspective\ncanonical-path and location info. This cleans up alot of location tracking\nfor example when we have generic structures we create implicit hirids which\nmay or may not have location info this now tracks the location info of\nthe declaration of the type avoiding any confustion.", "tree": {"sha": "0a911f2033756f2ef2a29c840d0ea61413b20ffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a911f2033756f2ef2a29c840d0ea61413b20ffb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7f14de056eb3887e70f29b0f29da4025f746559", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7f14de056eb3887e70f29b0f29da4025f746559", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7f14de056eb3887e70f29b0f29da4025f746559"}], "stats": {"total": 821, "additions": 580, "deletions": 241}, "files": [{"sha": "11784c9909884660929932f0e0143e8b6cda848f", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -132,13 +132,14 @@ TyTyResolveCompile::visit (const TyTy::FnType &type)\n     }\n \n   if (!type.is_varadic ())\n-    translated = ctx->get_backend ()->function_type (\n-      receiver, parameters, results, NULL,\n-      ctx->get_mappings ()->lookup_location (type.get_ref ()));\n+    translated\n+      = ctx->get_backend ()->function_type (receiver, parameters, results, NULL,\n+\t\t\t\t\t    type.get_ident ().locus);\n   else\n-    translated = ctx->get_backend ()->function_type_varadic (\n-      receiver, parameters, results, NULL,\n-      ctx->get_mappings ()->lookup_location (type.get_ref ()));\n+    translated\n+      = ctx->get_backend ()->function_type_varadic (receiver, parameters,\n+\t\t\t\t\t\t    results, NULL,\n+\t\t\t\t\t\t    type.get_ident ().locus);\n }\n \n void\n@@ -153,9 +154,8 @@ TyTyResolveCompile::visit (const TyTy::FnPtr &type)\n     return true;\n   });\n \n-  translated = ctx->get_backend ()->function_ptr_type (\n-    result_type, parameters,\n-    ctx->get_mappings ()->lookup_location (type.get_ref ()));\n+  translated = ctx->get_backend ()->function_ptr_type (result_type, parameters,\n+\t\t\t\t\t\t       type.get_ident ().locus);\n }\n \n void\n@@ -248,8 +248,8 @@ TyTyResolveCompile::visit (const TyTy::ADTType &type)\n \n \t  tree variant_record = ctx->get_backend ()->struct_type (fields);\n \t  tree named_variant_record = ctx->get_backend ()->named_type (\n-\t    variant->get_identifier (), variant_record,\n-\t    ctx->get_mappings ()->lookup_location (variant->get_id ()));\n+\t    variant->get_ident ().path.get (), variant_record,\n+\t    variant->get_ident ().locus);\n \n \t  // set the qualifier to be a builtin\n \t  DECL_ARTIFICIAL (TYPE_FIELDS (variant_record)) = 1;\n@@ -278,10 +278,11 @@ TyTyResolveCompile::visit (const TyTy::ADTType &type)\n       type_record = ctx->get_backend ()->union_type (enum_fields);\n     }\n \n+  std::string named_struct_str\n+    = type.get_ident ().path.get () + type.subst_as_string ();\n   tree named_struct\n-    = ctx->get_backend ()->named_type (type.get_name (), type_record,\n-\t\t\t\t       ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\t type.get_ref ()));\n+    = ctx->get_backend ()->named_type (named_struct_str, type_record,\n+\t\t\t\t       type.get_ident ().locus);\n \n   ctx->push_type (named_struct);\n   translated = named_struct;\n@@ -324,8 +325,7 @@ TyTyResolveCompile::visit (const TyTy::TupleType &type)\n   tree struct_type_record = ctx->get_backend ()->struct_type (fields);\n   tree named_struct\n     = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n-\t\t\t\t       ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\t type.get_ty_ref ()));\n+\t\t\t\t       type.get_ident ().locus);\n \n   ctx->push_type (named_struct);\n   ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n@@ -496,8 +496,7 @@ TyTyResolveCompile::visit (const TyTy::DynamicObjectType &type)\n   tree type_record = ctx->get_backend ()->struct_type (fields);\n   tree named_struct\n     = ctx->get_backend ()->named_type (type.get_name (), type_record,\n-\t\t\t\t       ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\t type.get_ty_ref ()));\n+\t\t\t\t       type.get_ident ().locus);\n \n   ctx->push_type (named_struct);\n   translated = named_struct;"}, {"sha": "8aef313af7a1e82a72d081c6f194626eb94878e4", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -187,9 +187,8 @@ Resolver::generate_builtins ()\n   MKBUILTIN_TYPE (\"str\", builtins, str);\n \n   // unit type ()\n-\n   TyTy::TupleType *unit_tyty\n-    = new TyTy::TupleType (mappings->get_next_hir_id ());\n+    = TyTy::TupleType::get_unit_type (mappings->get_next_hir_id ());\n   std::vector<std::unique_ptr<AST::Type> > elems;\n   AST::TupleType *unit_type\n     = new AST::TupleType (std::move (elems), Linemap::predeclared_location ());"}, {"sha": "9701a20b1e243838b0716ac37e14de2f7516b1dd", "filename": "gcc/rust/typecheck/rust-hir-type-check-enumitem.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -70,8 +70,9 @@ class TypeCheckEnumItem : public TypeCheckBase\n \t\t\t\t\t  &canonical_path);\n     rust_assert (ok);\n \n+    RustIdent ident{*canonical_path, item.get_locus ()};\n     variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n-\t\t\t\t    item.get_identifier (), discim_expr);\n+\t\t\t\t    item.get_identifier (), ident, discim_expr);\n   }\n \n   void visit (HIR::EnumItemDiscriminant &item) override\n@@ -99,8 +100,9 @@ class TypeCheckEnumItem : public TypeCheckBase\n \t\t\t\t\t &canonical_path);\n     rust_assert (ok);\n \n+    RustIdent ident{*canonical_path, item.get_locus ()};\n     variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n-\t\t\t\t    item.get_identifier (),\n+\t\t\t\t    item.get_identifier (), ident,\n \t\t\t\t    item.get_discriminant_expression ().get ());\n   }\n \n@@ -146,8 +148,9 @@ class TypeCheckEnumItem : public TypeCheckBase\n \t\t\t\t\t  &canonical_path);\n     rust_assert (ok);\n \n+    RustIdent ident{*canonical_path, item.get_locus ()};\n     variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n-\t\t\t\t    item.get_identifier (),\n+\t\t\t\t    item.get_identifier (), ident,\n \t\t\t\t    TyTy::VariantDef::VariantType::TUPLE,\n \t\t\t\t    discim_expr, fields);\n   }\n@@ -192,8 +195,9 @@ class TypeCheckEnumItem : public TypeCheckBase\n \t\t\t\t\t  &canonical_path);\n     rust_assert (ok);\n \n+    RustIdent ident{*canonical_path, item.get_locus ()};\n     variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n-\t\t\t\t    item.get_identifier (),\n+\t\t\t\t    item.get_identifier (), ident,\n \t\t\t\t    TyTy::VariantDef::VariantType::STRUCT,\n \t\t\t\t    discrim_expr, fields);\n   }"}, {"sha": "150eb1a52d64ce721120c435e746753002685b5e", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -158,26 +158,19 @@ class TypeCheckExpr : public TypeCheckBase\n \tauto field_ty = TypeCheckExpr::Resolve (elem.get (), false);\n \tfields.push_back (TyTy::TyVar (field_ty->get_ref ()));\n       }\n-    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid (), fields);\n+    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t   expr.get_locus (), fields);\n   }\n \n   void visit (HIR::ReturnExpr &expr) override\n   {\n     auto fn_return_tyty = context->peek_return_type ();\n     rust_assert (fn_return_tyty != nullptr);\n \n-    TyTy::BaseType *expr_ty;\n-    if (expr.has_return_expr ())\n-      expr_ty = TypeCheckExpr::Resolve (expr.get_expr (), false);\n-    else\n-      expr_ty = new TyTy::TupleType (expr.get_mappings ().get_hirid ());\n-\n-    if (expr_ty == nullptr)\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"failed to resolve type for ReturnExpr\");\n-\treturn;\n-      }\n+    TyTy::BaseType *expr_ty\n+      = expr.has_return_expr ()\n+\t  ? TypeCheckExpr::Resolve (expr.get_expr (), false)\n+\t  : TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n \n     infered = fn_return_tyty->unify (expr_ty);\n     fn_return_tyty->append_reference (expr_ty->get_ref ());\n@@ -405,7 +398,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::AssignmentExpr &expr) override\n   {\n-    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid ());\n+    infered\n+      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n \n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n@@ -454,7 +448,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::CompoundAssignmentExpr &expr) override\n   {\n-    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid ());\n+    infered\n+      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n \n     auto lhs = TypeCheckExpr::Resolve (expr.get_left_expr ().get (), false);\n     auto rhs = TypeCheckExpr::Resolve (expr.get_right_expr ().get (), false);\n@@ -603,9 +598,10 @@ class TypeCheckExpr : public TypeCheckBase\n \n \t    default:\n \t      ok = true;\n-\t      infered = new TyTy::InferType (\n-\t\texpr.get_mappings ().get_hirid (),\n-\t\tTyTy::InferType::InferTypeKind::INTEGRAL);\n+\t      infered\n+\t\t= new TyTy::InferType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       TyTy::InferType::InferTypeKind::INTEGRAL,\n+\t\t\t\t       expr.get_locus ());\n \t      break;\n \t    }\n \t  rust_assert (ok);\n@@ -628,7 +624,8 @@ class TypeCheckExpr : public TypeCheckBase\n \t      ok = true;\n \t      infered\n \t\t= new TyTy::InferType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t       TyTy::InferType::InferTypeKind::FLOAT);\n+\t\t\t\t       TyTy::InferType::InferTypeKind::FLOAT,\n+\t\t\t\t       expr.get_locus ());\n \t      break;\n \t    }\n \t  rust_assert (ok);\n@@ -701,7 +698,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n \t  TyTy::ArrayType *array\n \t    = new TyTy::ArrayType (array_mapping.get_hirid (),\n-\t\t\t\t   *literal_capacity,\n+\t\t\t\t   expr.get_locus (), *literal_capacity,\n \t\t\t\t   TyTy::TyVar (u8->get_ref ()));\n \t  context->insert_type (array_mapping, array);\n \n@@ -842,7 +839,8 @@ class TypeCheckExpr : public TypeCheckBase\n     TypeCheckExpr::Resolve (expr.get_if_condition (), false);\n     TypeCheckExpr::Resolve (expr.get_if_block (), inside_loop);\n \n-    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid ());\n+    infered\n+      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::IfExprConseqElse &expr) override\n@@ -1000,9 +998,9 @@ class TypeCheckExpr : public TypeCheckBase\n \tbreak;\n       }\n \n-    infered\n-      = new TyTy::ArrayType (expr.get_mappings ().get_hirid (), *capacity_expr,\n-\t\t\t     TyTy::TyVar (element_type->get_ref ()));\n+    infered = new TyTy::ArrayType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t   expr.get_locus (), *capacity_expr,\n+\t\t\t\t   TyTy::TyVar (element_type->get_ref ()));\n   }\n \n   // empty struct\n@@ -1078,7 +1076,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::LoopExpr &expr) override\n   {\n-    context->push_new_loop_context (expr.get_mappings ().get_hirid ());\n+    context->push_new_loop_context (expr.get_mappings ().get_hirid (),\n+\t\t\t\t    expr.get_locus ());\n     TyTy::BaseType *block_expr\n       = TypeCheckExpr::Resolve (expr.get_loop_block ().get (), true);\n     if (!block_expr->is_unit ())\n@@ -1097,9 +1096,10 @@ class TypeCheckExpr : public TypeCheckBase\n \t    && (((TyTy::InferType *) loop_context_type)->get_infer_kind ()\n \t\t!= TyTy::InferType::GENERAL));\n \n-    infered = loop_context_type_infered\n-\t\t? loop_context_type\n-\t\t: new TyTy::TupleType (expr.get_mappings ().get_hirid ());\n+    infered\n+      = loop_context_type_infered\n+\t  ? loop_context_type\n+\t  : TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::WhileLoopExpr &expr) override\n@@ -1119,7 +1119,8 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     context->pop_loop_context ();\n-    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid ());\n+    infered\n+      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::BreakExpr &expr) override\n@@ -1262,7 +1263,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n     if (kase_block_tys.size () == 0)\n       {\n-\tinfered = new TyTy::TupleType (expr.get_mappings ().get_hirid ());\n+\tinfered\n+\t  = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n \treturn;\n       }\n "}, {"sha": "10d4ea8d6d70034778960f8f4176802bff825e5c", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -77,7 +77,8 @@ class TypeCheckTopLevelExternItem : public TypeCheckBase\n \n     TyTy::BaseType *ret_type = nullptr;\n     if (!function.has_return_type ())\n-      ret_type = new TyTy::TupleType (function.get_mappings ().get_hirid ());\n+      ret_type = TyTy::TupleType::get_unit_type (\n+\tfunction.get_mappings ().get_hirid ());\n     else\n       {\n \tauto resolved\n@@ -121,11 +122,19 @@ class TypeCheckTopLevelExternItem : public TypeCheckBase\n     if (function.is_variadic ())\n       flags |= TyTy::FnType::FNTYPE_IS_VARADIC_FLAG;\n \n-    auto fnType = new TyTy::FnType (\n-      function.get_mappings ().get_hirid (),\n-      function.get_mappings ().get_defid (), function.get_item_name (), flags,\n-      ::Backend::get_abi_from_string (parent.get_abi (), parent.get_locus ()),\n-      std::move (params), ret_type, std::move (substitutions));\n+    RustIdent ident{\n+      CanonicalPath::new_seg (function.get_mappings ().get_nodeid (),\n+\t\t\t      function.get_item_name ()),\n+      function.get_locus ()};\n+    auto fnType\n+      = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t  function.get_item_name (), ident, flags,\n+\t\t\t  ::Backend::get_abi_from_string (parent.get_abi (),\n+\t\t\t\t\t\t\t  parent.get_locus ()),\n+\t\t\t  std::move (params), ret_type,\n+\t\t\t  std::move (substitutions));\n+\n     context->insert_type (function.get_mappings (), fnType);\n   }\n \n@@ -206,7 +215,8 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \n     TyTy::BaseType *ret_type = nullptr;\n     if (!function.has_function_return_type ())\n-      ret_type = new TyTy::TupleType (function.get_mappings ().get_hirid ());\n+      ret_type = TyTy::TupleType::get_unit_type (\n+\tfunction.get_mappings ().get_hirid ());\n     else\n       {\n \tauto resolved\n@@ -291,9 +301,16 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n+    const CanonicalPath *canonical_path = nullptr;\n+    bool ok = mappings->lookup_canonical_path (\n+      function.get_mappings ().get_crate_num (),\n+      function.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n+\n+    RustIdent ident{*canonical_path, function.get_locus ()};\n     auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n \t\t\t\t    function.get_mappings ().get_defid (),\n-\t\t\t\t    function.get_function_name (),\n+\t\t\t\t    function.get_function_name (), ident,\n \t\t\t\t    function.is_method ()\n \t\t\t\t      ? TyTy::FnType::FNTYPE_IS_METHOD_FLAG\n \t\t\t\t      : TyTy::FnType::FNTYPE_DEFAULT_FLAGS,"}, {"sha": "f2196b7908f614513e9eae93773d114856b2ebd5", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 66, "deletions": 17, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -68,7 +68,8 @@ class TypeCheckStmt : public TypeCheckBase\n \n   void visit (HIR::LetStmt &stmt) override\n   {\n-    infered = new TyTy::TupleType (stmt.get_mappings ().get_hirid ());\n+    infered\n+      = TyTy::TupleType::get_unit_type (stmt.get_mappings ().get_hirid ());\n \n     TyTy::BaseType *init_expr_ty = nullptr;\n     if (stmt.has_init_expr ())\n@@ -115,7 +116,8 @@ class TypeCheckStmt : public TypeCheckBase\n \t    context->insert_type (\n \t      stmt.get_mappings (),\n \t      new TyTy::InferType (stmt.get_mappings ().get_hirid (),\n-\t\t\t\t   TyTy::InferType::InferTypeKind::GENERAL));\n+\t\t\t\t   TyTy::InferType::InferTypeKind::GENERAL,\n+\t\t\t\t   stmt.get_locus ()));\n \t  }\n       }\n \n@@ -167,16 +169,26 @@ class TypeCheckStmt : public TypeCheckBase\n \tidx++;\n       }\n \n+    // get the path\n+    const CanonicalPath *canonical_path = nullptr;\n+    bool ok = mappings->lookup_canonical_path (\n+      struct_decl.get_mappings ().get_crate_num (),\n+      struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n+    RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n     // there is only a single variant\n     std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (new TyTy::VariantDef (\n-      struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n-      TyTy::VariantDef::VariantType::TUPLE, nullptr, std::move (fields)));\n+    variants.push_back (\n+      new TyTy::VariantDef (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t    struct_decl.get_identifier (), ident,\n+\t\t\t    TyTy::VariantDef::VariantType::TUPLE, nullptr,\n+\t\t\t    std::move (fields)));\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (),\n+\t\t\t   struct_decl.get_identifier (), ident,\n \t\t\t   TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n \t\t\t   std::move (variants), std::move (substitutions));\n \n@@ -223,10 +235,18 @@ class TypeCheckStmt : public TypeCheckBase\n \tvariants.push_back (field_type);\n       }\n \n+    // get the path\n+    const CanonicalPath *canonical_path = nullptr;\n+    bool ok = mappings->lookup_canonical_path (\n+      enum_decl.get_mappings ().get_crate_num (),\n+      enum_decl.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n+    RustIdent ident{*canonical_path, enum_decl.get_locus ()};\n+\n     TyTy::BaseType *type\n       = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   enum_decl.get_identifier (),\n+\t\t\t   enum_decl.get_identifier (), ident,\n \t\t\t   TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n \t\t\t   std::move (substitutions));\n \n@@ -275,16 +295,26 @@ class TypeCheckStmt : public TypeCheckBase\n \t\t\t      ty_field->get_field_type ());\n       }\n \n+    // get the path\n+    const CanonicalPath *canonical_path = nullptr;\n+    bool ok = mappings->lookup_canonical_path (\n+      struct_decl.get_mappings ().get_crate_num (),\n+      struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n+    RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n     // there is only a single variant\n     std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (new TyTy::VariantDef (\n-      struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n-      TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+    variants.push_back (\n+      new TyTy::VariantDef (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t    struct_decl.get_identifier (), ident,\n+\t\t\t    TyTy::VariantDef::VariantType::STRUCT, nullptr,\n+\t\t\t    std::move (fields)));\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (),\n+\t\t\t   struct_decl.get_identifier (), ident,\n \t\t\t   TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n \t\t\t   std::move (variants), std::move (substitutions));\n \n@@ -333,16 +363,26 @@ class TypeCheckStmt : public TypeCheckBase\n \t\t\t      ty_variant->get_field_type ());\n       }\n \n+    // get the path\n+    const CanonicalPath *canonical_path = nullptr;\n+    bool ok = mappings->lookup_canonical_path (\n+      union_decl.get_mappings ().get_crate_num (),\n+      union_decl.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n+    RustIdent ident{*canonical_path, union_decl.get_locus ()};\n+\n     // there is only a single variant\n     std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (new TyTy::VariantDef (\n-      union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n-      TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+    variants.push_back (\n+      new TyTy::VariantDef (union_decl.get_mappings ().get_hirid (),\n+\t\t\t    union_decl.get_identifier (), ident,\n+\t\t\t    TyTy::VariantDef::VariantType::STRUCT, nullptr,\n+\t\t\t    std::move (fields)));\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   union_decl.get_identifier (),\n+\t\t\t   union_decl.get_identifier (), ident,\n \t\t\t   TyTy::ADTType::ADTKind::UNION, std::move (variants),\n \t\t\t   std::move (substitutions));\n \n@@ -380,7 +420,8 @@ class TypeCheckStmt : public TypeCheckBase\n \n     TyTy::BaseType *ret_type = nullptr;\n     if (!function.has_function_return_type ())\n-      ret_type = new TyTy::TupleType (function.get_mappings ().get_hirid ());\n+      ret_type = TyTy::TupleType::get_unit_type (\n+\tfunction.get_mappings ().get_hirid ());\n     else\n       {\n \tauto resolved\n@@ -409,9 +450,17 @@ class TypeCheckStmt : public TypeCheckBase\n \tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n+    // get the path\n+    const CanonicalPath *canonical_path = nullptr;\n+    bool ok = mappings->lookup_canonical_path (\n+      function.get_mappings ().get_crate_num (),\n+      function.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n+\n+    RustIdent ident{*canonical_path, function.get_locus ()};\n     auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n \t\t\t\t    function.get_mappings ().get_defid (),\n-\t\t\t\t    function.get_function_name (),\n+\t\t\t\t    function.get_function_name (), ident,\n \t\t\t\t    TyTy::FnType::FNTYPE_DEFAULT_FLAGS,\n \t\t\t\t    ABI::RUST, std::move (params), ret_type,\n \t\t\t\t    std::move (substitutions));"}, {"sha": "2271dace78cabd78b3d7b9fe0c4b3a3c8af96975", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 64, "deletions": 18, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -102,16 +102,26 @@ class TypeCheckTopLevel : public TypeCheckBase\n \tidx++;\n       }\n \n-    // there is only a single variant\n+    // get the path\n+    const CanonicalPath *canonical_path = nullptr;\n+    bool ok = mappings->lookup_canonical_path (\n+      struct_decl.get_mappings ().get_crate_num (),\n+      struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n+    RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+    // its a single variant ADT\n     std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (new TyTy::VariantDef (\n-      struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n-      TyTy::VariantDef::VariantType::TUPLE, nullptr, std::move (fields)));\n+    variants.push_back (\n+      new TyTy::VariantDef (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t    struct_decl.get_identifier (), ident,\n+\t\t\t    TyTy::VariantDef::VariantType::TUPLE, nullptr,\n+\t\t\t    std::move (fields)));\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (),\n+\t\t\t   struct_decl.get_identifier (), ident,\n \t\t\t   TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n \t\t\t   std::move (variants), std::move (substitutions));\n \n@@ -158,7 +168,6 @@ class TypeCheckTopLevel : public TypeCheckBase\n       }\n \n     std::vector<TyTy::StructFieldType *> fields;\n-\n     for (auto &field : struct_decl.get_fields ())\n       {\n \tTyTy::BaseType *field_type\n@@ -171,16 +180,26 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t\t\t      ty_field->get_field_type ());\n       }\n \n-    // there is only a single variant\n+    // get the path\n+    const CanonicalPath *canonical_path = nullptr;\n+    bool ok = mappings->lookup_canonical_path (\n+      struct_decl.get_mappings ().get_crate_num (),\n+      struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n+    RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+    // its a single variant ADT\n     std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (new TyTy::VariantDef (\n-      struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n-      TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+    variants.push_back (\n+      new TyTy::VariantDef (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t    struct_decl.get_identifier (), ident,\n+\t\t\t    TyTy::VariantDef::VariantType::STRUCT, nullptr,\n+\t\t\t    std::move (fields)));\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (),\n+\t\t\t   struct_decl.get_identifier (), ident,\n \t\t\t   TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n \t\t\t   std::move (variants), std::move (substitutions));\n \n@@ -226,10 +245,19 @@ class TypeCheckTopLevel : public TypeCheckBase\n \tvariants.push_back (field_type);\n       }\n \n+    // get the path\n+    const CanonicalPath *canonical_path = nullptr;\n+    bool ok = mappings->lookup_canonical_path (\n+      enum_decl.get_mappings ().get_crate_num (),\n+      enum_decl.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n+    RustIdent ident{*canonical_path, enum_decl.get_locus ()};\n+\n+    // multi variant ADT\n     TyTy::BaseType *type\n       = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   enum_decl.get_identifier (),\n+\t\t\t   enum_decl.get_identifier (), ident,\n \t\t\t   TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n \t\t\t   std::move (substitutions));\n \n@@ -282,16 +310,26 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t\t\t      ty_variant->get_field_type ());\n       }\n \n+    // get the path\n+    const CanonicalPath *canonical_path = nullptr;\n+    bool ok = mappings->lookup_canonical_path (\n+      union_decl.get_mappings ().get_crate_num (),\n+      union_decl.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n+    RustIdent ident{*canonical_path, union_decl.get_locus ()};\n+\n     // there is only a single variant\n     std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (new TyTy::VariantDef (\n-      union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n-      TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+    variants.push_back (\n+      new TyTy::VariantDef (union_decl.get_mappings ().get_hirid (),\n+\t\t\t    union_decl.get_identifier (), ident,\n+\t\t\t    TyTy::VariantDef::VariantType::STRUCT, nullptr,\n+\t\t\t    std::move (fields)));\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   union_decl.get_identifier (),\n+\t\t\t   union_decl.get_identifier (), ident,\n \t\t\t   TyTy::ADTType::ADTKind::UNION, std::move (variants),\n \t\t\t   std::move (substitutions));\n \n@@ -350,7 +388,8 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n     TyTy::BaseType *ret_type = nullptr;\n     if (!function.has_function_return_type ())\n-      ret_type = new TyTy::TupleType (function.get_mappings ().get_hirid ());\n+      ret_type = TyTy::TupleType::get_unit_type (\n+\tfunction.get_mappings ().get_hirid ());\n     else\n       {\n \tauto resolved\n@@ -379,9 +418,16 @@ class TypeCheckTopLevel : public TypeCheckBase\n \tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n+    const CanonicalPath *canonical_path = nullptr;\n+    bool ok = mappings->lookup_canonical_path (\n+      function.get_mappings ().get_crate_num (),\n+      function.get_mappings ().get_nodeid (), &canonical_path);\n+    rust_assert (ok);\n+\n+    RustIdent ident{*canonical_path, function.get_locus ()};\n     auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n \t\t\t\t    function.get_mappings ().get_defid (),\n-\t\t\t\t    function.get_function_name (),\n+\t\t\t\t    function.get_function_name (), ident,\n \t\t\t\t    TyTy::FnType::FNTYPE_DEFAULT_FLAGS,\n \t\t\t\t    ABI::RUST, std::move (params), ret_type,\n \t\t\t\t    std::move (substitutions));"}, {"sha": "9902614e269c3280d017c93c82c6e529e10c0737", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -572,8 +572,10 @@ TypeCheckType::visit (HIR::TraitObjectType &type)\n \tspecified_bounds.push_back (std::move (predicate));\n     }\n \n-  translated = new TyTy::DynamicObjectType (type.get_mappings ().get_hirid (),\n-\t\t\t\t\t    std::move (specified_bounds));\n+  RustIdent ident{CanonicalPath::create_empty (), type.get_locus ()};\n+  translated\n+    = new TyTy::DynamicObjectType (type.get_mappings ().get_hirid (), ident,\n+\t\t\t\t   std::move (specified_bounds));\n }\n \n void\n@@ -594,7 +596,7 @@ TypeCheckType::visit (HIR::ArrayType &type)\n \n   TyTy::BaseType *base = TypeCheckType::Resolve (type.get_element_type ());\n   translated = new TyTy::ArrayType (type.get_mappings ().get_hirid (),\n-\t\t\t\t    *type.get_size_expr (),\n+\t\t\t\t    type.get_locus (), *type.get_size_expr (),\n \t\t\t\t    TyTy::TyVar (base->get_ref ()));\n }\n "}, {"sha": "400328c3fb43a92497f953db99741bec925f8a0c", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -74,7 +74,8 @@ class TypeCheckType : public TypeCheckBase\n     TyTy::BaseType *return_type\n       = fntype.has_return_type ()\n \t  ? TypeCheckType::Resolve (fntype.get_return_type ().get ())\n-\t  : new TyTy::TupleType (fntype.get_mappings ().get_hirid ());\n+\t  : TyTy::TupleType::get_unit_type (\n+\t    fntype.get_mappings ().get_hirid ());\n \n     std::vector<TyTy::TyVar> params;\n     for (auto &param : fntype.get_function_params ())\n@@ -85,7 +86,7 @@ class TypeCheckType : public TypeCheckBase\n       }\n \n     translated = new TyTy::FnPtr (fntype.get_mappings ().get_hirid (),\n-\t\t\t\t  std::move (params),\n+\t\t\t\t  fntype.get_locus (), std::move (params),\n \t\t\t\t  TyTy::TyVar (return_type->get_ref ()));\n   }\n \n@@ -109,8 +110,8 @@ class TypeCheckType : public TypeCheckBase\n \tfields.push_back (TyTy::TyVar (field_ty->get_ref ()));\n       }\n \n-    translated\n-      = new TyTy::TupleType (tuple.get_mappings ().get_hirid (), fields);\n+    translated = new TyTy::TupleType (tuple.get_mappings ().get_hirid (),\n+\t\t\t\t      tuple.get_locus (), fields);\n   }\n \n   void visit (HIR::TypePath &path) override;\n@@ -140,7 +141,8 @@ class TypeCheckType : public TypeCheckBase\n   void visit (HIR::InferredType &type) override\n   {\n     translated = new TyTy::InferType (type.get_mappings ().get_hirid (),\n-\t\t\t\t      TyTy::InferType::InferTypeKind::GENERAL);\n+\t\t\t\t      TyTy::InferType::InferTypeKind::GENERAL,\n+\t\t\t\t      type.get_locus ());\n   }\n \n   void visit (HIR::TraitObjectType &type) override;\n@@ -265,6 +267,7 @@ class TypeResolveGenericParam : public TypeCheckBase\n       }\n \n     resolved = new TyTy::ParamType (param.get_type_representation (),\n+\t\t\t\t    param.get_locus (),\n \t\t\t\t    param.get_mappings ().get_hirid (), param,\n \t\t\t\t    specified_bounds);\n   }"}, {"sha": "6666603f56227c21ed62943d9237b51bed9e0ffa", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -119,7 +119,8 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n \n       if (s->is_unit_check_needed () && !resolved->is_unit ())\n \t{\n-\t  auto unit = new TyTy::TupleType (s->get_mappings ().get_hirid ());\n+\t  auto unit\n+\t    = TyTy::TupleType::get_unit_type (s->get_mappings ().get_hirid ());\n \t  resolved = unit->unify (resolved);\n \t}\n     }\n@@ -129,7 +130,8 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n       = TypeCheckExpr::Resolve (expr.get_final_expr ().get (), inside_loop)\n \t  ->clone ();\n   else if (expr.is_tail_reachable ())\n-    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid ());\n+    infered\n+      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n   else\n     infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n }\n@@ -234,7 +236,7 @@ TraitItemReference::get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const\n \n   TyTy::BaseType *ret_type = nullptr;\n   if (!function.has_return_type ())\n-    ret_type = new TyTy::TupleType (fn.get_mappings ().get_hirid ());\n+    ret_type = TyTy::TupleType::get_unit_type (fn.get_mappings ().get_hirid ());\n   else\n     {\n       auto resolved\n@@ -320,10 +322,19 @@ TraitItemReference::get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const\n       context->insert_type (param.get_mappings (), param_tyty);\n     }\n \n+  auto mappings = Analysis::Mappings::get ();\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (fn.get_mappings ().get_crate_num (),\n+\t\t\t\t       fn.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, fn.get_locus ()};\n   auto resolved\n     = new TyTy::FnType (fn.get_mappings ().get_hirid (),\n \t\t\tfn.get_mappings ().get_defid (),\n-\t\t\tfunction.get_function_name (),\n+\t\t\tfunction.get_function_name (), ident,\n \t\t\tfunction.is_method ()\n \t\t\t  ? TyTy::FnType::FNTYPE_IS_METHOD_FLAG\n \t\t\t  : TyTy::FnType::FNTYPE_DEFAULT_FLAGS,"}, {"sha": "49141b3b46ba5ef3532ae67fb0d55e81e4b0d50d", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -125,10 +125,11 @@ class TypeCheckContext\n       }\n   }\n \n-  void push_new_loop_context (HirId id)\n+  void push_new_loop_context (HirId id, Location locus)\n   {\n     TyTy::BaseType *infer_var\n-      = new TyTy::InferType (id, TyTy::InferType::InferTypeKind::GENERAL);\n+      = new TyTy::InferType (id, TyTy::InferType::InferTypeKind::GENERAL,\n+\t\t\t     locus);\n     loop_type_stack.push_back (infer_var);\n   }\n "}, {"sha": "b9f4e1456dd248cb786620e340b882402d24f0c0", "filename": "gcc/rust/typecheck/rust-tyty-cast.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -806,9 +806,10 @@ class ArrayCastRules : public BaseCastRules\n \treturn;\n       }\n \n-    resolved = new ArrayType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t      type.get_capacity_expr (),\n-\t\t\t      TyVar (base_resolved->get_ref ()));\n+    resolved\n+      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t       type.get_ident ().locus, type.get_capacity_expr (),\n+\t\t       TyVar (base_resolved->get_ref ()));\n   }\n \n private:\n@@ -1063,8 +1064,8 @@ class TupleCastRules : public BaseCastRules\n \tfields.push_back (TyVar (unified_ty->get_ref ()));\n       }\n \n-    resolved\n-      = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (), fields);\n+    resolved = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t    type.get_ident ().locus, fields);\n   }\n \n private:"}, {"sha": "75913f0483ec92b773a3d5bfd43b4f7e63c57ce3", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -824,9 +824,10 @@ class ArrayCoercionRules : public BaseCoercionRules\n \treturn;\n       }\n \n-    resolved = new ArrayType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t      type.get_capacity_expr (),\n-\t\t\t      TyVar (base_resolved->get_ref ()));\n+    resolved\n+      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t       type.get_ident ().locus, type.get_capacity_expr (),\n+\t\t       TyVar (base_resolved->get_ref ()));\n   }\n \n private:\n@@ -1071,8 +1072,8 @@ class TupleCoercionRules : public BaseCoercionRules\n \tfields.push_back (TyVar (unified_ty->get_ref ()));\n       }\n \n-    resolved\n-      = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (), fields);\n+    resolved = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t    type.get_ident ().locus, fields);\n   }\n \n private:"}, {"sha": "906e33d5583363f1b770444bb1a5e4b77326b4e8", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -838,9 +838,10 @@ class ArrayRules : public BaseRules\n \treturn;\n       }\n \n-    resolved = new ArrayType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t      type.get_capacity_expr (),\n-\t\t\t      TyVar (base_resolved->get_ref ()));\n+    resolved\n+      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t       type.get_ident ().locus, type.get_capacity_expr (),\n+\t\t       TyVar (base_resolved->get_ref ()));\n   }\n \n private:\n@@ -1083,8 +1084,8 @@ class TupleRules : public BaseRules\n \tfields.push_back (TyVar (unified_ty->get_ref ()));\n       }\n \n-    resolved\n-      = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (), fields);\n+    resolved = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t    type.get_ident ().locus, fields);\n   }\n \n private:"}, {"sha": "6a6592396393abe88988783f204d351d26cdf6d0", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -159,7 +159,7 @@ TyVar::get_implicit_infer_var (Location locus)\n   auto context = Resolver::TypeCheckContext::get ();\n \n   InferType *infer = new InferType (mappings->get_next_hir_id (),\n-\t\t\t\t    InferType::InferTypeKind::GENERAL);\n+\t\t\t\t    InferType::InferTypeKind::GENERAL, locus);\n   context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n \t\t\t\t\t       UNKNOWN_NODEID,\n \t\t\t\t\t       infer->get_ref (),\n@@ -229,7 +229,7 @@ BaseType *\n InferType::clone () const\n {\n   return new InferType (get_ref (), get_ty_ref (), get_infer_kind (),\n-\t\t\tget_combined_refs ());\n+\t\t\tget_ident ().locus, get_combined_refs ());\n }\n \n bool\n@@ -316,14 +316,14 @@ StructFieldType::is_equal (const StructFieldType &other) const\n {\n   bool names_eq = get_name ().compare (other.get_name ()) == 0;\n \n-  TyTy::BaseType &o = *other.get_field_type ();\n-  if (o.get_kind () == TypeKind::PARAM)\n+  TyTy::BaseType *o = other.get_field_type ();\n+  if (o->get_kind () == TypeKind::PARAM)\n     {\n-      ParamType &op = static_cast<ParamType &> (o);\n-      o = *op.resolve ();\n+      ParamType *op = static_cast<ParamType *> (o);\n+      o = op->resolve ();\n     }\n \n-  bool types_eq = get_field_type ()->is_equal (o);\n+  bool types_eq = get_field_type ()->is_equal (*o);\n \n   return names_eq && types_eq;\n }\n@@ -749,9 +749,9 @@ ADTType::clone () const\n   for (auto &variant : variants)\n     cloned_variants.push_back (variant->clone ());\n \n-  return new ADTType (get_ref (), get_ty_ref (), identifier, get_adt_kind (),\n-\t\t      cloned_variants, clone_substs (), used_arguments,\n-\t\t      get_combined_refs ());\n+  return new ADTType (get_ref (), get_ty_ref (), identifier, ident,\n+\t\t      get_adt_kind (), cloned_variants, clone_substs (),\n+\t\t      used_arguments, get_combined_refs ());\n }\n \n static bool\n@@ -916,7 +916,7 @@ TupleType::is_equal (const BaseType &other) const\n BaseType *\n TupleType::clone () const\n {\n-  return new TupleType (get_ref (), get_ty_ref (), fields,\n+  return new TupleType (get_ref (), get_ty_ref (), get_ident ().locus, fields,\n \t\t\tget_combined_refs ());\n }\n \n@@ -1043,7 +1043,7 @@ FnType::clone () const\n       std::pair<HIR::Pattern *, BaseType *> (p.first, p.second->clone ()));\n \n   return new FnType (get_ref (), get_ty_ref (), get_id (), get_identifier (),\n-\t\t     flags, abi, std::move (cloned_params),\n+\t\t     ident, flags, abi, std::move (cloned_params),\n \t\t     get_return_type ()->clone (), clone_substs (),\n \t\t     get_combined_refs ());\n }\n@@ -1246,8 +1246,9 @@ FnPtr::clone () const\n   for (auto &p : params)\n     cloned_params.push_back (TyVar (p.get_ref ()));\n \n-  return new FnPtr (get_ref (), get_ty_ref (), std::move (cloned_params),\n-\t\t    result_type, get_combined_refs ());\n+  return new FnPtr (get_ref (), get_ty_ref (), ident.locus,\n+\t\t    std::move (cloned_params), result_type,\n+\t\t    get_combined_refs ());\n }\n \n void\n@@ -1306,7 +1307,7 @@ ClosureType::is_equal (const BaseType &other) const\n BaseType *\n ClosureType::clone () const\n {\n-  return new ClosureType (get_ref (), get_ty_ref (), id, parameter_types,\n+  return new ClosureType (get_ref (), get_ty_ref (), ident, id, parameter_types,\n \t\t\t  result_type, clone_substs (), get_combined_refs ());\n }\n \n@@ -1386,8 +1387,8 @@ ArrayType::get_element_type () const\n BaseType *\n ArrayType::clone () const\n {\n-  return new ArrayType (get_ref (), get_ty_ref (), capacity_expr, element_type,\n-\t\t\tget_combined_refs ());\n+  return new ArrayType (get_ref (), get_ty_ref (), ident.locus, capacity_expr,\n+\t\t\telement_type, get_combined_refs ());\n }\n \n void\n@@ -2068,8 +2069,8 @@ ParamType::can_eq (const BaseType *other, bool emit_errors) const\n BaseType *\n ParamType::clone () const\n {\n-  return new ParamType (get_symbol (), get_ref (), get_ty_ref (), param,\n-\t\t\tget_specified_bounds (), get_combined_refs ());\n+  return new ParamType (get_symbol (), ident.locus, get_ref (), get_ty_ref (),\n+\t\t\tparam, get_specified_bounds (), get_combined_refs ());\n }\n \n std::string\n@@ -2516,8 +2517,8 @@ DynamicObjectType::cast (BaseType *other)\n BaseType *\n DynamicObjectType::clone () const\n {\n-  return new DynamicObjectType (get_ref (), get_ty_ref (), specified_bounds,\n-\t\t\t\tget_combined_refs ());\n+  return new DynamicObjectType (get_ref (), get_ty_ref (), ident,\n+\t\t\t\tspecified_bounds, get_combined_refs ());\n }\n \n std::string"}, {"sha": "6c9daf73cae498986d1d45d3a460ab3d2d03d9c3", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 240, "deletions": 87, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-diagnostics.h\"\n #include \"rust-abi.h\"\n #include \"rust-common.h\"\n+#include \"rust-identifier.h\"\n \n namespace Rust {\n \n@@ -393,24 +394,30 @@ class BaseType : public TypeBoundsMappings\n \n   const BaseType *get_root () const;\n \n+  const RustIdent &get_ident () const { return ident; }\n+\n+  Location get_locus () const { return ident.locus; }\n+\n protected:\n-  BaseType (HirId ref, HirId ty_ref, TypeKind kind,\n+  BaseType (HirId ref, HirId ty_ref, TypeKind kind, RustIdent ident,\n \t    std::set<HirId> refs = std::set<HirId> ())\n     : TypeBoundsMappings ({}), kind (kind), ref (ref), ty_ref (ty_ref),\n-      combined (refs), mappings (Analysis::Mappings::get ())\n+      combined (refs), ident (ident), mappings (Analysis::Mappings::get ())\n   {}\n \n-  BaseType (HirId ref, HirId ty_ref, TypeKind kind,\n+  BaseType (HirId ref, HirId ty_ref, TypeKind kind, RustIdent ident,\n \t    std::vector<TypeBoundPredicate> specified_bounds,\n \t    std::set<HirId> refs = std::set<HirId> ())\n     : TypeBoundsMappings (specified_bounds), kind (kind), ref (ref),\n-      ty_ref (ty_ref), combined (refs), mappings (Analysis::Mappings::get ())\n+      ty_ref (ty_ref), combined (refs), ident (ident),\n+      mappings (Analysis::Mappings::get ())\n   {}\n \n   TypeKind kind;\n   HirId ref;\n   HirId ty_ref;\n   std::set<HirId> combined;\n+  RustIdent ident;\n \n   Analysis::Mappings *mappings;\n };\n@@ -441,14 +448,18 @@ class InferType : public BaseType\n     FLOAT\n   };\n \n-  InferType (HirId ref, InferTypeKind infer_kind,\n+  InferType (HirId ref, InferTypeKind infer_kind, Location locus,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::INFER, refs), infer_kind (infer_kind)\n+    : BaseType (ref, ref, TypeKind::INFER,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      infer_kind (infer_kind)\n   {}\n \n-  InferType (HirId ref, HirId ty_ref, InferTypeKind infer_kind,\n+  InferType (HirId ref, HirId ty_ref, InferTypeKind infer_kind, Location locus,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::INFER, refs), infer_kind (infer_kind)\n+    : BaseType (ref, ty_ref, TypeKind::INFER,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      infer_kind (infer_kind)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -481,11 +492,13 @@ class ErrorType : public BaseType\n {\n public:\n   ErrorType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::ERROR, refs)\n+    : BaseType (ref, ref, TypeKind::ERROR,\n+\t\t{Resolver::CanonicalPath::create_empty (), Location ()}, refs)\n   {}\n \n   ErrorType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::ERROR, refs)\n+    : BaseType (ref, ty_ref, TypeKind::ERROR,\n+\t\t{Resolver::CanonicalPath::create_empty (), Location ()}, refs)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -511,18 +524,25 @@ class SubstitutionArgumentMappings;\n class ParamType : public BaseType\n {\n public:\n-  ParamType (std::string symbol, HirId ref, HIR::GenericParam &param,\n+  ParamType (std::string symbol, Location locus, HirId ref,\n+\t     HIR::GenericParam &param,\n \t     std::vector<TypeBoundPredicate> specified_bounds,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PARAM, specified_bounds, refs),\n+    : BaseType (ref, ref, TypeKind::PARAM,\n+\t\t{Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n+\t\t locus},\n+\t\tspecified_bounds, refs),\n       symbol (symbol), param (param)\n   {}\n \n-  ParamType (std::string symbol, HirId ref, HirId ty_ref,\n+  ParamType (std::string symbol, Location locus, HirId ref, HirId ty_ref,\n \t     HIR::GenericParam &param,\n \t     std::vector<TypeBoundPredicate> specified_bounds,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PARAM, specified_bounds, refs),\n+    : BaseType (ref, ty_ref, TypeKind::PARAM,\n+\t\t{Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n+\t\t locus},\n+\t\tspecified_bounds, refs),\n       symbol (symbol), param (param)\n   {}\n \n@@ -600,18 +620,26 @@ class StructFieldType\n class TupleType : public BaseType\n {\n public:\n-  TupleType (HirId ref, std::vector<TyVar> fields = std::vector<TyVar> (),\n+  TupleType (HirId ref, Location locus,\n+\t     std::vector<TyVar> fields = std::vector<TyVar> (),\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::TUPLE, refs), fields (fields)\n+    : BaseType (ref, ref, TypeKind::TUPLE,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      fields (fields)\n   {}\n \n-  TupleType (HirId ref, HirId ty_ref,\n+  TupleType (HirId ref, HirId ty_ref, Location locus,\n \t     std::vector<TyVar> fields = std::vector<TyVar> (),\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::TUPLE, refs), fields (fields)\n+    : BaseType (ref, ty_ref, TypeKind::TUPLE,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      fields (fields)\n   {}\n \n-  static TupleType *get_unit_type (HirId ref) { return new TupleType (ref); }\n+  static TupleType *get_unit_type (HirId ref)\n+  {\n+    return new TupleType (ref, Linemap::predeclared_location ());\n+  }\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -1027,26 +1055,53 @@ class VariantDef\n     return \"\";\n   }\n \n-  VariantDef (HirId id, std::string identifier, HIR::Expr *discriminant)\n-    : id (id), identifier (identifier), discriminant (discriminant)\n+  VariantDef (HirId id, std::string identifier, RustIdent ident,\n+\t      HIR::Expr *discriminant)\n+    : id (id), identifier (identifier), ident (ident),\n+      discriminant (discriminant)\n+\n   {\n     type = VariantType::NUM;\n     fields = {};\n   }\n \n-  VariantDef (HirId id, std::string identifier, VariantType type,\n-\t      HIR::Expr *discriminant, std::vector<StructFieldType *> fields)\n-    : id (id), identifier (identifier), type (type),\n+  VariantDef (HirId id, std::string identifier, RustIdent ident,\n+\t      VariantType type, HIR::Expr *discriminant,\n+\t      std::vector<StructFieldType *> fields)\n+    : id (id), identifier (identifier), ident (ident), type (type),\n       discriminant (discriminant), fields (fields)\n   {\n     rust_assert (\n       (type == VariantType::NUM && fields.empty ())\n       || (type == VariantType::TUPLE || type == VariantType::STRUCT));\n   }\n \n+  VariantDef (const VariantDef &other)\n+    : id (other.id), identifier (other.identifier), ident (other.ident),\n+      type (other.type), discriminant (other.discriminant),\n+      fields (other.fields)\n+  {}\n+\n+  VariantDef &operator= (const VariantDef &other)\n+  {\n+    id = other.id;\n+    identifier = other.identifier;\n+    type = other.type;\n+    discriminant = other.discriminant;\n+    fields = other.fields;\n+    ident = other.ident;\n+\n+    return *this;\n+  }\n+\n   static VariantDef &get_error_node ()\n   {\n-    static VariantDef node = VariantDef (UNKNOWN_HIRID, \"\", nullptr);\n+    static VariantDef node\n+      = VariantDef (UNKNOWN_HIRID, \"\",\n+\t\t    {Resolver::CanonicalPath::create_empty (),\n+\t\t     Linemap::unknown_location ()},\n+\t\t    nullptr);\n+\n     return node;\n   }\n \n@@ -1063,7 +1118,7 @@ class VariantDef\n   size_t num_fields () const { return fields.size (); }\n   StructFieldType *get_field_at_index (size_t index)\n   {\n-    // FIXME this is not safe\n+    rust_assert (index < fields.size ());\n     return fields.at (index);\n   }\n \n@@ -1148,12 +1203,16 @@ class VariantDef\n     for (auto &f : fields)\n       cloned_fields.push_back ((StructFieldType *) f->clone ());\n \n-    return new VariantDef (id, identifier, type, discriminant, cloned_fields);\n+    return new VariantDef (id, identifier, ident, type, discriminant,\n+\t\t\t   cloned_fields);\n   }\n \n+  const RustIdent &get_ident () const { return ident; }\n+\n private:\n   HirId id;\n   std::string identifier;\n+  RustIdent ident;\n   VariantType type;\n   // can either be a structure or a discriminant value\n   HIR::Expr *discriminant;\n@@ -1171,24 +1230,24 @@ class ADTType : public BaseType, public SubstitutionRef\n     ENUM\n   };\n \n-  ADTType (HirId ref, std::string identifier, ADTKind adt_kind,\n+  ADTType (HirId ref, std::string identifier, RustIdent ident, ADTKind adt_kind,\n \t   std::vector<VariantDef *> variants,\n \t   std::vector<SubstitutionParamMapping> subst_refs,\n \t   SubstitutionArgumentMappings generic_arguments\n \t   = SubstitutionArgumentMappings::error (),\n \t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::ADT, refs),\n+    : BaseType (ref, ref, TypeKind::ADT, ident, refs),\n       SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n       identifier (identifier), variants (variants), adt_kind (adt_kind)\n   {}\n \n-  ADTType (HirId ref, HirId ty_ref, std::string identifier, ADTKind adt_kind,\n-\t   std::vector<VariantDef *> variants,\n+  ADTType (HirId ref, HirId ty_ref, std::string identifier, RustIdent ident,\n+\t   ADTKind adt_kind, std::vector<VariantDef *> variants,\n \t   std::vector<SubstitutionParamMapping> subst_refs,\n \t   SubstitutionArgumentMappings generic_arguments\n \t   = SubstitutionArgumentMappings::error (),\n \t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::ADT, refs),\n+    : BaseType (ref, ty_ref, TypeKind::ADT, ident, refs),\n       SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n       identifier (identifier), variants (variants), adt_kind (adt_kind)\n   {}\n@@ -1312,11 +1371,12 @@ class FnType : public BaseType, public SubstitutionRef\n   static const uint8_t FNTYPE_IS_EXTERN_FLAG = 0x02;\n   static const uint8_t FNTYPE_IS_VARADIC_FLAG = 0X04;\n \n-  FnType (HirId ref, DefId id, std::string identifier, uint8_t flags, ABI abi,\n+  FnType (HirId ref, DefId id, std::string identifier, RustIdent ident,\n+\t  uint8_t flags, ABI abi,\n \t  std::vector<std::pair<HIR::Pattern *, BaseType *>> params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::FNDEF, refs),\n+    : BaseType (ref, ref, TypeKind::FNDEF, ident, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n       params (std::move (params)), type (type), flags (flags),\n@@ -1327,11 +1387,11 @@ class FnType : public BaseType, public SubstitutionRef\n   }\n \n   FnType (HirId ref, HirId ty_ref, DefId id, std::string identifier,\n-\t  uint8_t flags, ABI abi,\n+\t  RustIdent ident, uint8_t flags, ABI abi,\n \t  std::vector<std::pair<HIR::Pattern *, BaseType *>> params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::FNDEF, refs),\n+    : BaseType (ref, ty_ref, TypeKind::FNDEF, ident, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n       params (params), type (type), flags (flags), identifier (identifier),\n@@ -1444,16 +1504,18 @@ class FnType : public BaseType, public SubstitutionRef\n class FnPtr : public BaseType\n {\n public:\n-  FnPtr (HirId ref, std::vector<TyVar> params, TyVar result_type,\n-\t std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::FNPTR, refs), params (std::move (params)),\n-      result_type (result_type)\n+  FnPtr (HirId ref, Location locus, std::vector<TyVar> params,\n+\t TyVar result_type, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::FNPTR,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      params (std::move (params)), result_type (result_type)\n   {}\n \n-  FnPtr (HirId ref, HirId ty_ref, std::vector<TyVar> params, TyVar result_type,\n-\t std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::FNPTR, refs), params (params),\n-      result_type (result_type)\n+  FnPtr (HirId ref, HirId ty_ref, Location locus, std::vector<TyVar> params,\n+\t TyVar result_type, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::FNPTR,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      params (params), result_type (result_type)\n   {}\n \n   std::string get_name () const override final { return as_string (); }\n@@ -1505,11 +1567,11 @@ class FnPtr : public BaseType\n class ClosureType : public BaseType, public SubstitutionRef\n {\n public:\n-  ClosureType (HirId ref, DefId id, std::vector<TyVar> parameter_types,\n-\t       TyVar result_type,\n+  ClosureType (HirId ref, DefId id, RustIdent ident,\n+\t       std::vector<TyVar> parameter_types, TyVar result_type,\n \t       std::vector<SubstitutionParamMapping> subst_refs,\n \t       std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::CLOSURE, refs),\n+    : BaseType (ref, ref, TypeKind::CLOSURE, ident, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n       parameter_types (std::move (parameter_types)),\n@@ -1519,11 +1581,11 @@ class ClosureType : public BaseType, public SubstitutionRef\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n   }\n \n-  ClosureType (HirId ref, HirId ty_ref, DefId id,\n+  ClosureType (HirId ref, HirId ty_ref, RustIdent ident, DefId id,\n \t       std::vector<TyVar> parameter_types, TyVar result_type,\n \t       std::vector<SubstitutionParamMapping> subst_refs,\n \t       std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::CLOSURE, refs),\n+    : BaseType (ref, ty_ref, TypeKind::CLOSURE, ident, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n       parameter_types (std::move (parameter_types)),\n@@ -1583,16 +1645,18 @@ class ClosureType : public BaseType, public SubstitutionRef\n class ArrayType : public BaseType\n {\n public:\n-  ArrayType (HirId ref, HIR::Expr &capacity_expr, TyVar base,\n+  ArrayType (HirId ref, Location locus, HIR::Expr &capacity_expr, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::ARRAY, refs), element_type (base),\n-      capacity_expr (capacity_expr)\n+    : BaseType (ref, ref, TypeKind::ARRAY,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      element_type (base), capacity_expr (capacity_expr)\n   {}\n \n-  ArrayType (HirId ref, HirId ty_ref, HIR::Expr &capacity_expr, TyVar base,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::ARRAY, refs), element_type (base),\n-      capacity_expr (capacity_expr)\n+  ArrayType (HirId ref, HirId ty_ref, Location locus, HIR::Expr &capacity_expr,\n+\t     TyVar base, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::ARRAY,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      element_type (base), capacity_expr (capacity_expr)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1629,11 +1693,17 @@ class BoolType : public BaseType\n {\n public:\n   BoolType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::BOOL, refs)\n+    : BaseType (ref, ref, TypeKind::BOOL,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   BoolType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::BOOL, refs)\n+    : BaseType (ref, ty_ref, TypeKind::BOOL,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1665,12 +1735,20 @@ class IntType : public BaseType\n   };\n \n   IntType (HirId ref, IntKind kind, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::INT, refs), int_kind (kind)\n+    : BaseType (ref, ref, TypeKind::INT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      int_kind (kind)\n   {}\n \n   IntType (HirId ref, HirId ty_ref, IntKind kind,\n \t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::INT, refs), int_kind (kind)\n+    : BaseType (ref, ty_ref, TypeKind::INT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      int_kind (kind)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1709,12 +1787,20 @@ class UintType : public BaseType\n   };\n \n   UintType (HirId ref, UintKind kind, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::UINT, refs), uint_kind (kind)\n+    : BaseType (ref, ref, TypeKind::UINT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      uint_kind (kind)\n   {}\n \n   UintType (HirId ref, HirId ty_ref, UintKind kind,\n \t    std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::UINT, refs), uint_kind (kind)\n+    : BaseType (ref, ty_ref, TypeKind::UINT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      uint_kind (kind)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1751,12 +1837,20 @@ class FloatType : public BaseType\n \n   FloatType (HirId ref, FloatKind kind,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::FLOAT, refs), float_kind (kind)\n+    : BaseType (ref, ref, TypeKind::FLOAT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      float_kind (kind)\n   {}\n \n   FloatType (HirId ref, HirId ty_ref, FloatKind kind,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::FLOAT, refs), float_kind (kind)\n+    : BaseType (ref, ty_ref, TypeKind::FLOAT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      float_kind (kind)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1786,11 +1880,17 @@ class USizeType : public BaseType\n {\n public:\n   USizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::USIZE, refs)\n+    : BaseType (ref, ref, TypeKind::USIZE,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   USizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::USIZE, refs)\n+    : BaseType (ref, ty_ref, TypeKind::USIZE,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1813,11 +1913,17 @@ class ISizeType : public BaseType\n {\n public:\n   ISizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::ISIZE, refs)\n+    : BaseType (ref, ref, TypeKind::ISIZE,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   ISizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::ISIZE, refs)\n+    : BaseType (ref, ty_ref, TypeKind::ISIZE,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1840,11 +1946,17 @@ class CharType : public BaseType\n {\n public:\n   CharType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::CHAR, refs)\n+    : BaseType (ref, ref, TypeKind::CHAR,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   CharType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::CHAR, refs)\n+    : BaseType (ref, ty_ref, TypeKind::CHAR,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1868,12 +1980,20 @@ class ReferenceType : public BaseType\n public:\n   ReferenceType (HirId ref, TyVar base, Mutability mut,\n \t\t std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::REF, refs), base (base), mut (mut)\n+    : BaseType (ref, ref, TypeKind::REF,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      base (base), mut (mut)\n   {}\n \n   ReferenceType (HirId ref, HirId ty_ref, TyVar base, Mutability mut,\n \t\t std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::REF, refs), base (base), mut (mut)\n+    : BaseType (ref, ty_ref, TypeKind::REF,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      base (base), mut (mut)\n   {}\n \n   BaseType *get_base () const;\n@@ -1918,12 +2038,20 @@ class PointerType : public BaseType\n public:\n   PointerType (HirId ref, TyVar base, Mutability mut,\n \t       std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::POINTER, refs), base (base), mut (mut)\n+    : BaseType (ref, ref, TypeKind::POINTER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      base (base), mut (mut)\n   {}\n \n   PointerType (HirId ref, HirId ty_ref, TyVar base, Mutability mut,\n \t       std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::POINTER, refs), base (base), mut (mut)\n+    : BaseType (ref, ty_ref, TypeKind::POINTER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      base (base), mut (mut)\n   {}\n \n   BaseType *get_base () const;\n@@ -1969,11 +2097,17 @@ class StrType : public BaseType\n {\n public:\n   StrType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::STR, refs)\n+    : BaseType (ref, ref, TypeKind::STR,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   StrType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::STR, refs)\n+    : BaseType (ref, ty_ref, TypeKind::STR,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   std::string get_name () const override final { return as_string (); }\n@@ -2008,11 +2142,17 @@ class NeverType : public BaseType\n {\n public:\n   NeverType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::NEVER, refs)\n+    : BaseType (ref, ref, TypeKind::NEVER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   NeverType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::NEVER, refs)\n+    : BaseType (ref, ty_ref, TypeKind::NEVER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -2040,13 +2180,20 @@ class PlaceholderType : public BaseType\n public:\n   PlaceholderType (std::string symbol, HirId ref,\n \t\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PLACEHOLDER, refs), symbol (symbol)\n-\n+    : BaseType (ref, ref, TypeKind::PLACEHOLDER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      symbol (symbol)\n   {}\n \n   PlaceholderType (std::string symbol, HirId ref, HirId ty_ref,\n \t\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER, refs), symbol (symbol)\n+    : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      symbol (symbol)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -2101,7 +2248,10 @@ class ProjectionType : public BaseType, public SubstitutionRef\n \t\t  SubstitutionArgumentMappings generic_arguments\n \t\t  = SubstitutionArgumentMappings::error (),\n \t\t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PROJECTION, refs),\n+    : BaseType (ref, ref, TypeKind::PROJECTION,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n       SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n       base (base), trait (trait), item (item)\n   {}\n@@ -2112,7 +2262,10 @@ class ProjectionType : public BaseType, public SubstitutionRef\n \t\t  SubstitutionArgumentMappings generic_arguments\n \t\t  = SubstitutionArgumentMappings::error (),\n \t\t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PROJECTION, refs),\n+    : BaseType (ref, ty_ref, TypeKind::PROJECTION,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n       SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n       base (base), trait (trait), item (item)\n   {}\n@@ -2162,16 +2315,16 @@ class ProjectionType : public BaseType, public SubstitutionRef\n class DynamicObjectType : public BaseType\n {\n public:\n-  DynamicObjectType (HirId ref,\n+  DynamicObjectType (HirId ref, RustIdent ident,\n \t\t     std::vector<TypeBoundPredicate> specified_bounds,\n \t\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::DYNAMIC, specified_bounds, refs)\n+    : BaseType (ref, ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n   {}\n \n-  DynamicObjectType (HirId ref, HirId ty_ref,\n+  DynamicObjectType (HirId ref, HirId ty_ref, RustIdent ident,\n \t\t     std::vector<TypeBoundPredicate> specified_bounds,\n \t\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::DYNAMIC, specified_bounds, refs)\n+    : BaseType (ref, ty_ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;"}, {"sha": "0b5cb70b373ca778abdfcefb3fc0f70570e76129", "filename": "gcc/rust/util/rust-identifier.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Futil%2Frust-identifier.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Frust%2Futil%2Frust-identifier.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-identifier.h?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_IDENTIFIER\n+#define RUST_IDENTIFIER\n+\n+#include \"rust-canonical-path.h\"\n+#include \"rust-location.h\"\n+\n+namespace Rust {\n+\n+struct RustIdent\n+{\n+  Resolver::CanonicalPath path;\n+  Location locus;\n+\n+  RustIdent (const Resolver::CanonicalPath &path, Location locus)\n+    : path (path), locus (locus)\n+  {}\n+\n+  RustIdent (const RustIdent &other) : path (other.path), locus (other.locus) {}\n+\n+  RustIdent &operator= (const RustIdent &other)\n+  {\n+    path = other.path;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+};\n+\n+} // namespace Rust\n+\n+#endif // RUST_IDENTIFIER"}, {"sha": "965666ee54120200ef3cdbed3ba5c4ebaf652178", "filename": "gcc/testsuite/rust/compile/torture/struct_decl.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fstruct_decl.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a0fa7fc5fd3332e9f180339a262f29641f62c6/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fstruct_decl.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fstruct_decl.rs?ref=d2a0fa7fc5fd3332e9f180339a262f29641f62c6", "patch": "@@ -1,14 +1,14 @@\n // { dg-additional-options -fdump-tree-gimple }\n \n struct Foo {\n-  a: u16,\n-// { dg-warning \"field is never read\" \"\" { target *-*-* } .-1 }\n-  b: u8,\n-// { dg-warning \"field is never read\" \"\" { target *-*-* } .-1 }\n+    a: u16,\n+    // { dg-warning \"field is never read\" \"\" { target *-*-* } .-1 }\n+    b: u8,\n+    // { dg-warning \"field is never read\" \"\" { target *-*-* } .-1 }\n }\n \n fn main() {\n-  let my_foo = Foo { a: 1, b: 2 };\n-  // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n-  // { dg-final { scan-tree-dump-times {(?n)const struct Foo my_foo;$} 1 gimple } }\n+    let my_foo = Foo { a: 1, b: 2 };\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+    // { dg-final { scan-tree-dump-times {(?n)const struct example::Foo my_foo;$} 1 gimple } }\n }"}]}