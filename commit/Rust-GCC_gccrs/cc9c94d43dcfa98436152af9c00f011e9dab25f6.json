{"sha": "cc9c94d43dcfa98436152af9c00f011e9dab25f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M5Yzk0ZDQzZGNmYTk4NDM2MTUyYWY5YzAwZjAxMWU5ZGFiMjVmNg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-18T23:33:39Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-18T23:33:39Z"}, "message": "libstdc++: Reduce ranges::minmax/minmax_element comparison complexity\n\nThis rewrites ranges::minmax and ranges::minmax_element so that it\nperforms at most 3*N/2 many comparisons, as required by the standard.\nIn passing, this also fixes PR100387 by avoiding a premature std::move\nin ranges::minmax and in std::shift_right.\n\n\tPR libstdc++/100387\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/ranges_algo.h (__minmax_fn::operator()): Rewrite\n\tto limit comparison complexity to 3*N/2.\n\t(__minmax_element_fn::operator()): Likewise.\n\t(shift_right): Avoid premature std::move of __result.\n\t* testsuite/25_algorithms/minmax/constrained.cc (test04, test05):\n\tNew tests.\n\t* testsuite/25_algorithms/minmax_element/constrained.cc (test02):\n\tLikewise.", "tree": {"sha": "2f588eb09a0135ca675ccfaa3cbc1ba57d435901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f588eb09a0135ca675ccfaa3cbc1ba57d435901"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc9c94d43dcfa98436152af9c00f011e9dab25f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9c94d43dcfa98436152af9c00f011e9dab25f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc9c94d43dcfa98436152af9c00f011e9dab25f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9c94d43dcfa98436152af9c00f011e9dab25f6/comments", "author": null, "committer": null, "parents": [{"sha": "a798b3f15c47be55f535b754932a820b858870a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a798b3f15c47be55f535b754932a820b858870a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a798b3f15c47be55f535b754932a820b858870a8"}], "stats": {"total": 182, "additions": 156, "deletions": 26}, "files": [{"sha": "83371a4bdf0a113fc042eaf400f43e5a36e05ad4", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 87, "deletions": 26, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9c94d43dcfa98436152af9c00f011e9dab25f6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9c94d43dcfa98436152af9c00f011e9dab25f6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=cc9c94d43dcfa98436152af9c00f011e9dab25f6", "patch": "@@ -3076,26 +3076,59 @@ namespace ranges\n     template<input_range _Range, typename _Proj = identity,\n \t     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>\n \t       _Comp = ranges::less>\n-      requires indirectly_copyable_storable<iterator_t<_Range>,\n-      range_value_t<_Range>*>\n+      requires indirectly_copyable_storable<iterator_t<_Range>, range_value_t<_Range>*>\n       constexpr minmax_result<range_value_t<_Range>>\n       operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const\n       {\n \tauto __first = ranges::begin(__r);\n \tauto __last = ranges::end(__r);\n \t__glibcxx_assert(__first != __last);\n+\tauto __comp_proj = __detail::__make_comp_proj(__comp, __proj);\n \tminmax_result<range_value_t<_Range>> __result = {*__first, *__first};\n+\tif (++__first == __last)\n+\t  return __result;\n+\telse\n+\t  {\n+\t    // At this point __result.min == __result.max, so a single\n+\t    // comparison with the next element suffices.\n+\t    auto&& __val = *__first;\n+\t    if (__comp_proj(__val, __result.min))\n+\t      __result.min = std::forward<decltype(__val)>(__val);\n+\t    else\n+\t      __result.max = std::forward<decltype(__val)>(__val);\n+\t  }\n \twhile (++__first != __last)\n \t  {\n-\t    auto __tmp = *__first;\n-\t    if (std::__invoke(__comp,\n-\t\t\t      std::__invoke(__proj, __tmp),\n-\t\t\t      std::__invoke(__proj, __result.min)))\n-\t      __result.min = std::move(__tmp);\n-\t    if (!(bool)std::__invoke(__comp,\n-\t\t\t\t     std::__invoke(__proj, __tmp),\n-\t\t\t\t     std::__invoke(__proj, __result.max)))\n-\t      __result.max = std::move(__tmp);\n+\t    // Now process two elements at a time so that we perform at most\n+\t    // 1 + 3*(N-2)/2 comparisons in total (each of the (N-2)/2\n+\t    // iterations of this loop performs three comparisons).\n+\t    range_value_t<_Range> __val1 = *__first;\n+\t    if (++__first == __last)\n+\t      {\n+\t\t// N is odd; in this final iteration, we perform at most two\n+\t\t// comparisons, for a total of 1 + 3*(N-3)/2 + 2 comparisons,\n+\t\t// which is not more than 3*N/2, as required.\n+\t\tif (__comp_proj(__val1, __result.min))\n+\t\t  __result.min = std::move(__val1);\n+\t\telse if (!__comp_proj(__val1, __result.max))\n+\t\t  __result.max = std::move(__val1);\n+\t\tbreak;\n+\t      }\n+\t    auto&& __val2 = *__first;\n+\t    if (!__comp_proj(__val2, __val1))\n+\t      {\n+\t\tif (__comp_proj(__val1, __result.min))\n+\t\t  __result.min = std::move(__val1);\n+\t\tif (!__comp_proj(__val2, __result.max))\n+\t\t  __result.max = std::forward<decltype(__val2)>(__val2);\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (__comp_proj(__val2, __result.min))\n+\t\t  __result.min = std::forward<decltype(__val2)>(__val2);\n+\t\tif (!__comp_proj(__val1, __result.max))\n+\t\t  __result.max = std::move(__val1);\n+\t      }\n \t  }\n \treturn __result;\n       }\n@@ -3201,21 +3234,50 @@ namespace ranges\n       operator()(_Iter __first, _Sent __last,\n \t\t _Comp __comp = {}, _Proj __proj = {}) const\n       {\n-\tif (__first == __last)\n-\t  return {__first, __first};\n-\n+\tauto __comp_proj = __detail::__make_comp_proj(__comp, __proj);\n \tminmax_element_result<_Iter> __result = {__first, __first};\n-\tauto __i = __first;\n-\twhile (++__i != __last)\n+\tif (__first == __last || ++__first == __last)\n+\t  return __result;\n+\telse\n \t  {\n-\t    if (std::__invoke(__comp,\n-\t\t\t      std::__invoke(__proj, *__i),\n-\t\t\t      std::__invoke(__proj, *__result.min)))\n-\t      __result.min = __i;\n-\t    if (!(bool)std::__invoke(__comp,\n-\t\t\t\t     std::__invoke(__proj, *__i),\n-\t\t\t\t     std::__invoke(__proj, *__result.max)))\n-\t      __result.max = __i;\n+\t    // At this point __result.min == __result.max, so a single\n+\t    // comparison with the next element suffices.\n+\t    if (__comp_proj(*__first, *__result.min))\n+\t      __result.min = __first;\n+\t    else\n+\t      __result.max = __first;\n+\t  }\n+\twhile (++__first != __last)\n+\t  {\n+\t    // Now process two elements at a time so that we perform at most\n+\t    // 1 + 3*(N-2)/2 comparisons in total (each of the (N-2)/2\n+\t    // iterations of this loop performs three comparisons).\n+\t    auto __prev = __first;\n+\t    if (++__first == __last)\n+\t      {\n+\t\t// N is odd; in this final iteration, we perform at most two\n+\t\t// comparisons, for a total of 1 + 3*(N-3)/2 + 2 comparisons,\n+\t\t// which is not more than 3*N/2, as required.\n+\t\tif (__comp_proj(*__prev, *__result.min))\n+\t\t  __result.min = __prev;\n+\t\telse if (!__comp_proj(*__prev, *__result.max))\n+\t\t  __result.max = __prev;\n+\t\tbreak;\n+\t      }\n+\t    if (!__comp_proj(*__first, *__prev))\n+\t      {\n+\t\tif (__comp_proj(*__prev, *__result.min))\n+\t\t  __result.min = __prev;\n+\t\tif (!__comp_proj(*__first, *__result.max))\n+\t\t  __result.max = __first;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (__comp_proj(*__first, *__result.min))\n+\t\t  __result.min = __first;\n+\t\tif (!__comp_proj(*__prev, *__result.max))\n+\t\t  __result.max = __prev;\n+\t      }\n \t  }\n \treturn __result;\n       }\n@@ -3542,8 +3604,7 @@ namespace ranges\n \t\t  // i.e. we are shifting out at least half of the range.  In\n \t\t  // this case we can safely perform the shift with a single\n \t\t  // move.\n-\t\t  std::move(std::move(__first), std::move(__dest_head),\n-\t\t\t    std::move(__result));\n+\t\t  std::move(std::move(__first), std::move(__dest_head), __result);\n \t\t  return __result;\n \t\t}\n \t      ++__dest_head;"}, {"sha": "c365152bf2bce39af2e996b40d9bdd05b94734e0", "filename": "libstdc++-v3/testsuite/25_algorithms/minmax/constrained.cc", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9c94d43dcfa98436152af9c00f011e9dab25f6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9c94d43dcfa98436152af9c00f011e9dab25f6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax%2Fconstrained.cc?ref=cc9c94d43dcfa98436152af9c00f011e9dab25f6", "patch": "@@ -19,6 +19,8 @@\n // { dg-do run { target c++2a } }\n \n #include <algorithm>\n+#include <string>\n+#include <vector>\n #include <testsuite_hooks.h>\n #include <testsuite_iterators.h>\n \n@@ -89,10 +91,50 @@ test03()\n \t  == res_t(1,4) );\n }\n \n+void\n+test04()\n+{\n+  // Verify we perform at most 3*N/2 applications of the comparison predicate.\n+  static int counter;\n+  struct counted_less\n+  { bool operator()(int a, int b) { ++counter; return a < b; } };\n+\n+  ranges::minmax({1,2}, counted_less{});\n+  VERIFY( counter == 1 );\n+\n+  counter = 0;\n+  ranges::minmax({1,2,3}, counted_less{});\n+  VERIFY( counter == 3 );\n+\n+  counter = 0;\n+  ranges::minmax({1,2,3,4,5,6,7,8,9,10}, counted_less{});\n+  VERIFY( counter <= 15 );\n+\n+  counter = 0;\n+  ranges::minmax({10,9,8,7,6,5,4,3,2,1}, counted_less{});\n+  VERIFY( counter <= 15 );\n+}\n+\n+void\n+test05()\n+{\n+  // PR libstdc++/100387\n+  using namespace std::literals::string_literals;\n+  auto comp = [](const auto& a, const auto& b) {\n+    return a.size() == b.size() ? a.front() < b.front() : a.size() > b.size();\n+  };\n+  auto result = ranges::minmax({\"b\"s, \"a\"s}, comp);\n+  VERIFY( result.min == \"a\"s && result.max == \"b\"s );\n+  result = ranges::minmax({\"c\"s, \"b\"s, \"a\"s}, comp);\n+  VERIFY( result.min == \"a\"s && result.max == \"c\"s );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n+  test04();\n+  test05();\n }"}, {"sha": "0919f7dda8f9adc8c3725ff11ad7320c2878a2f2", "filename": "libstdc++-v3/testsuite/25_algorithms/minmax_element/constrained.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9c94d43dcfa98436152af9c00f011e9dab25f6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax_element%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9c94d43dcfa98436152af9c00f011e9dab25f6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax_element%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fminmax_element%2Fconstrained.cc?ref=cc9c94d43dcfa98436152af9c00f011e9dab25f6", "patch": "@@ -61,8 +61,35 @@ test01()\n   static_assert(ranges::minmax_element(y, y+3, {}, &X::i).max->j == 3);\n }\n \n+void\n+test02()\n+{\n+  // Verify we perform at most 3*N/2 applications of the comparison predicate.\n+  static int counter;\n+  struct counted_less\n+  { bool operator()(int a, int b) { ++counter; return a < b; } };\n+\n+  int x[] = {1,2,3,4,5,6,7,8,9,10};\n+  ranges::minmax_element(x, x+2, counted_less{});\n+  VERIFY( counter == 1 );\n+\n+  counter = 0;\n+  ranges::minmax_element(x, x+3, counted_less{});\n+  VERIFY( counter == 3 );\n+\n+  counter = 0;\n+  ranges::minmax_element(x, counted_less{});\n+  VERIFY( counter <= 15 );\n+\n+  ranges::reverse(x);\n+  counter = 0;\n+  ranges::minmax_element(x, counted_less{});\n+  VERIFY( counter <= 15 );\n+}\n+\n int\n main()\n {\n   test01();\n+  test02();\n }"}]}