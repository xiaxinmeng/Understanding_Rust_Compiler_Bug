{"sha": "49ad7cfa7ac804b56cff13d70022020126f24c55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlhZDdjZmE3YWM4MDRiNTZjZmYxM2Q3MDAyMjAyMDEyNmYyNGM1NQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-08-09T14:00:21Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-08-09T14:00:21Z"}, "message": "Include function.h in most files.\n\nInclude function.h in most files.  Remove most of the global variables\nduplicated in function.h.  Add accessor macros for them which access\ncurrent_function.  Delete INLINE_HEADER rtx and related code, replace\nwith code using struct function to store inlining related data.\n\nFrom-SVN: r28626", "tree": {"sha": "0c9ea6c13240638f450e4b7c92af4127356208c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c9ea6c13240638f450e4b7c92af4127356208c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49ad7cfa7ac804b56cff13d70022020126f24c55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49ad7cfa7ac804b56cff13d70022020126f24c55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49ad7cfa7ac804b56cff13d70022020126f24c55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49ad7cfa7ac804b56cff13d70022020126f24c55/comments", "author": null, "committer": null, "parents": [{"sha": "0dde4175efc346c70069a8a090590d3e63be04fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dde4175efc346c70069a8a090590d3e63be04fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dde4175efc346c70069a8a090590d3e63be04fa"}], "stats": {"total": 2651, "additions": 1120, "deletions": 1531}, "files": [{"sha": "38d40c0ab4669ca7a85ff28caf5c644e9a91da51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -1,3 +1,291 @@\n+Mon Aug  9 10:08:50 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* Makefile.in: Update dependencies.\n+\t* alias.c: Include \"function.h\"\n+\t* c-decl.c: Likewise.\n+\t* caller-save.c: Likewise.\n+\t* calls.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* cse.c: Likewise.\n+\t* explow.c: Likewise.\n+\t* final.c: Likewise.\n+\t* global.c: Likewise.\n+\t* graph.c: Likewise.\n+\t* local-alloc.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* optabs.c: Likewise.\n+\t* profile.c: Likewise.\n+\t* recog.c: Likewise.\n+\t* regclass.c: Likewise.\n+\t* regmove.c: Likewise.\n+\t* reload.c: Likewise.\n+\t* reorg.c: Likewise.\n+\t* resource.c: Likewise.\n+\t* sched.c: Likewise.\n+\t* stupid.c: Likewise.\n+\t* config/1750a/1750a.c: Likewise.\n+\t* config/a29k/a29k.c: Likewise.\n+\t* config/arc/arc.c: Likewise.\n+\t* config/arm/arm.c: Likewise.\n+\t* config/arm/thumb.c: Likewise.\n+\t* config/c4x/c4x.c: Likewise.\n+\t* config/clipper/clipper.c: Likewise.\n+\t* config/convex/convex.c: Likewise.\n+\t* config/fx80/fx80.c: Likewise.\n+\t* config/i860/i860.c: Likewise.\n+\t* config/m68k/m68k.c: Likewise.\n+\t* config/m88k/m88k.c: Likewise.\n+\t* config/mips/mips.c: Likewise.\n+\t* config/pdp11/pdp11.c: Likewise.\n+\t* config/pyr/pyr.c: Likewise.\n+\t* config/romp/romp.c: Likewise.\n+\t* config/sh/sh.c: Likewise.\n+\t* config/tahoe/tahoe.c: Likewise.\n+\t* config/vax/vax.c: Likewise.\n+\t* config/we32k/we32k.c: Likewise.\n+\t* config/sparc/sparc.c: Include \"function.h\".\n+\t(mem_min_alignment): Test current_function rather than\n+\tregno_pointer_align.\n+\t* config/pa/pa.c: Likewise.\n+\t(compute_frame_size): Delete declaration of\n+\tcurrent_function_outgoing_args_size.\n+\t* config/arc/arc.h (current_function_varargs): Delete declaration.\n+\t* config/elxsi/elxsi.h (current_function_calls_alloca): Delete\n+\tdeclaration.\n+\t* config/i370/i370.h (current_function_outgoing_args_size): Delete\n+\tdeclaration.\n+\t* config/i386/i386.h (FINALIZE_PIC): Delete declaration of\n+\tcurrent_function_uses_pic_offset_table.\n+\t* config/m68k/a-ux.h (FUNCTION_EXTRA_EPILOGUE): Delete declaration\n+\tof current_function_returns_pointer.\n+\t* config/m68k/altos3068.h (FUNCTION_EXTRA_EPILOGUE): Likewise.\n+\t* config/m68k/linux.h (FUNCTION_EXTRA_EPILOGUE): Likewise.\n+\t* config/m68k/m68kv4.h (FUNCTION_EXTRA_EPILOGUE): Likewise.\n+\t* config/m68k/mot3300.h (FUNCTION_EXTRA_EPILOGUE): Likewise.\n+\t* config/m68k/pbb.h (FUNCTION_EXTRA_EPILOGUE): Likewise.\n+\t* config/m68k/tower-as.h (FUNCTION_EXTRA_EPILOGUE): Likewise.\n+\t* config/m88k/m88k.c: Include \"function.h\"\n+\t(call_used_regs, current_function_pretend_args_size,\n+\tcurrent_function_outgoing_args_size, frame_pointer_needed): Delete\n+\tdeclarations.\n+\t* config/m88k/m88k.h (current_function_pretend_args_size): Delete\n+\tdeclaration.\n+\t* config/mips/mips.h (current_function_calls_alloca): Delete\n+\tdeclaration.\n+\t* config/mn10200/mn10200.h (current_function_needs_context,\n+\trtx_equal_function_value_matters): Delete declarations.\n+\t* config/ns32k/ns32k (current_function_uses_pic_offset_table,\n+\tflag_pic): Delete declarations.\n+\t* config/pa/pa.h (current_function_pretend_args_size,\n+\tcurrent_function_decl): Delete declarations.\n+\t* config/pa/som.h (current_function_varargs): Delete declaration.\n+\t* config/pdp11/pdp11.h (current_function_pretend_args_size): Delete\n+\tdeclaration.\n+\t* config/pyr/pyr.h (current_function_pretend_args_size,\n+\tcurrent_function_args_size, current_function_calls_alloca): Delete\n+\tdeclarations.\n+\t* config/sh/sh.h (current_function_varargs): Delete declaration.\n+\t* config/sparc/sparc.h (current_function_outgoing_args_size,\n+\tcurrent_function_calls_alloca, current_function_decl): Delete\n+\tdeclarations.\n+\t* config/spur/spur.h (current_function_pretend_args_size,\n+\tcurrent_function_calls_alloca): Delete declarations.\n+\t* config/v850/v850.c (current_function_outgoing_args_size): Delete\n+\tdeclaration.\n+\t* config/vax/vms.h (current_function_name): Delete declaration.\n+\t* gcse.c: Include \"function.h\".\n+\t(current_function_name, current_function_calls_setjmp): Delete\n+\tdeclarations.\n+\t* haifa-sched.c: Include \"function.h\".\n+\t(forced_labels): Delete declaration.\n+\t* jump.c: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* genemit.c (main): Make generated file include function.h.\n+\t* genoutput.c (output_prologue): Likewise.\n+\n+\t* builtins.c (saveregs_value, apply_args_value): Delete variables.\n+\t* emit-rtl.c (reg_rtx_no, first_label_num, first_insn, last_insn,\n+\tsequence_rtl_expr, cur_insn_uid, last_linenum, last_filename,\n+\tregno_pointer_flag, regno_pointer_flag_length, regno_pointer_align,\n+\tregno_reg_rtx, sequence_stack): Delete variables.  Add accessor\n+\tmacros for some of them.\n+\t(emit_filename, emit_lineno): Delete declarations.\n+\t(gen_reg_rtx): Use memset/memcpy instead of bzero/bcopy.  Access\n+\tregno_pointer_* variables through current_function.\n+\t(gen_inline_header_rtx): Delete function.\n+\t(save_emit_status): Delete function.\n+\t(set_new_last_label_num): New function.\n+\t(clear_emit_caches): New function.\n+\t(restore_emit_status): Just clear last_labelnum and call\n+\tclear_emit_caches.\n+\t(get_last_insn_anywhere): Variable sequence_stack is now accessed\n+\tthrough macro seq_stack.\n+\t(add_insn_after): Likewise.\n+\t(add_insn_before): Likewise.\n+\t(remove_insn): Likewise.\n+\t(pop_topmost_sequence): Likewise.\n+\t(in_sequence_p): Likewise.\n+\t(start_sequence_for_rtl_expr): Likewise.\n+\t(start_sequence): Likewise, and likewise for\n+\tsequence_rtl_expr/seq_rtl_expr.\n+\t(push_topmost_sequence): Likewise.\n+\t(end_sequence): Likewise.\n+\t(init_virtual_regs): Now takes a \"struct emit_status *\" argument.\n+\tAll callers changed.  Store into that pointer instead of globals.\n+\t(init_emit): Allocate emit elt of current_function.\n+\tChanges for sequence_rtl_expr/sequence_stack renaming.\n+\tCall clear_emit_caches instead of doing it in-line.\n+\tAccess regno_pointer_* variables through current_function.\n+\t(init_emit_once) Don't clear sequence_stack.\n+\t\n+\t* expr.c (pending_stack_adjust, inhibit_defer_pop, pending_chain):\n+\tDelete variables.\n+\t(arg_pointer_save_area): Delete declaration.\n+\t(finish_expr_for_function): Renamed from init_queue; no longer static.\n+\t(init_expr): Don't call init_queue.\n+\t(save_expr_status, restore_expr_status): Delete functions.\n+\t(expand_expr): Changes to reflect new layout of struct function.\n+\tDon't access current_function_check_memory_usage when current_function\n+\tis 0.\n+\t* expr.h (forced_labels, save_expr_regs, saveregs_value,\n+\tapply_args_value, current_function_calls_alloca, inhibit_defer_pop,\n+\tcurrent_function_outgoing_args_size, current_function_arg_offset_rtx,\n+\tcurrent_function_uses_const_pool, function_call_count,\n+\tcurrent_function_uses_pic_offset_table, nonlocal_labels,\n+\tcurrent_function_internal_arg_pointer, nonlocal_goto_stack_level,\n+\tcurrent_function_check_memory_usage, nonlocal_goto_handler_slots,\n+\tpending_stack_adjust, target_temp_slot_level, temp_slot_level): Delete\n+\tdeclarations.\n+\t(finish_expr_for_function): Declare.\n+\t* flags.h (current_function_has_nonlocal_label,\n+\tcurrent_function_has_nonlocal_goto, current_function_is_thunk,\n+\tcurrent_function_has_computed_jump): Delete declarations.\n+\t* flow.c (forced_labels): Delete declaration.\n+\t* function.c (current_function_pops_args,\n+\tcurrent_function_returns_struct, current_function_returns_pcc_struct,\n+\tcurrent_function_needs_context, current_function_calls_setjmp,\n+\tcurrent_function_calls_longjmp, current_function_has_nonlocal_label,\n+\tcurrent_function_has_nonlocal_goto, current_function_is_thunk,\n+\tcurrent_function_has_computed_jump, current_function_calls_alloca,\n+\tcurrent_function_contains_functions, current_function_returns_pointer,\n+\tcurrent_function_epilogue_delay_list, current_function_args_size,\n+\tcurrent_function_pretend_args_size, current_function_arg_offset_rtx,\n+\tcurrent_function_outgoing_args_size, current_function_varargs,\n+\tcurrent_function_stdarg, current_function_args_info, cleanup_label,\n+\tcurrent_function_name, current_function_uses_const_pool,\n+\tcurrent_function_instrument_entry_exit, current_function_return_rtx,\n+\tcurrent_function_uses_pic_offset_table, nonlocal_labels,\n+\tcurrent_function_internal_arg_pointer, current_function_cannot_inline,\n+\tcurrent_function_check_memory_usage, function_call_count,\n+\tnonlocal_goto_handler_slots, nonlocal_goto_handler_labels,\n+\tnonlocal_goto_stack_level, return_label, save_expr_regs,\n+\tstack_slot_list, rtl_expr_chain, tail_recursion_label, temp_slots,\n+\ttail_recursion_reentry, arg_pointer_save_area, frame_offset,\n+\tcontext_display, trampoline_list, parm_birth_insn, invalid_stack_slot,\n+\tlast_parm_insn, max_parm_reg, parm_reg_stack_loc, sequence_rtl_expr,\n+\ttemp_slot_level, var_temp_slot_level, target_temp_slot_level):\n+\tDelete variables.\n+\t(push_function_context_to): Don't save them.  Don't call\n+\tsave_storage_status, save_emit_status or save_expr_status.\n+\t(pop_function_context_from): Don't restore them.  Don't call\n+\trestore_storage_status or restore_expr_status.\n+\t(get_func_frame_size): New function.\n+\t(get_frame_size): Use it.\n+\t(assign_outer_stack_local): Reflect some member name changes in struct\n+\tfunction.\n+\t(put_reg_into_stack): Likewise.\n+\t(assign_stack_temp_for_type): sequence_rtl_expr was renamed to\n+\tseq_rtl_expr.\n+\t(fixup_var_refs): Likewise.\n+\t(fix_lexical_addr): Likewise.\n+\t(trampoline_address): Likewise.\n+\t(prepare_function_start): Clear field inlinable of current_function.\n+\t(init_function_for_compilation): New function.\n+\t(expand_dummy_function_end): New function.\n+\t(expand_function_end): Call finish_expr_for_function.\n+\t* function.h (struct emit_status): New; fields moved here from struct\n+\tfunction and from global variables.  Add accessor macros for some of\n+\tthe fields.\n+\t(struct expr_status): Likewise.\n+\t(REGNO_POINTER_ALIGN, REGNO_POINTER_FLAG): Moved here from regs.h.\n+\t(struct function): Add fields expr and emit, inlinable, inl_emit,\n+\toriginal_arg_vector, original_decl_initial, inl_last_parm_insn,\n+\tinl_max_label_num.  Add many comments.\n+\tAdd accessor macros for all elts of struct function that no longer\n+\thave a global variable.\n+\t(cleanup_label, return_label, frame_offset, tail_recursion_label,\n+\ttail_recursion_reentry, arg_pointer_save_area, rtl_expr_chain,\n+\tstack_slot_list): Delete declarations.\n+\t(get_func_frame_size): Declare.\n+\t(save_expr_status, restore_expr_status, save_emit_status,\n+\tsave_storage_status, restore_storage_status): Delete declarations.\n+\t(init_virtual_regs): Declare.\n+\t* output.h (current_function_pops_args,\n+\tcurrent_function_returns_struct, current_function_returns_pcc_struct,\n+\tcurrent_function_needs_context, current_function_calls_setjmp,\n+\tcurrent_function_calls_longjmp, current_function_calls_alloca,\n+\tcurrent_function_has_nonlocal_label, current_function_varargs,\n+\tcurrent_function_has_computed_jump, current_function_returns_pointer,\n+\tcurrent_function_contains_functions, current_function_args_size,\n+\tcurrent_function_pretend_args_size, current_function_stdarg,\n+\tcurrent_function_outgoing_args_size, current_function_args_info,\n+\tcurrent_function_name, current_function_return_rtx,\n+\tcurrent_function_epilogue_delay_list,\n+\tcurrent_function_uses_const_pool, current_function_cannot_inline):\n+\tDelete declarations.\n+\t* regs.h (reg_rtx_no, regno_pointer_flag, regno_pointer_flag_length,\n+\tregno_reg_rtx): Delete declaration.\n+\t(REGNO_POINTER_FLAG): Delete macro.\n+\t* stmt.c (expand_goto): Changes to reflect that some fields in struct\n+\tfunction were renamed.\n+\t* stor-layout.c (save_storage_status, restore_storage_status): Delete\n+\tfunctions.\n+\t* toplev.c: Include \"function.h\".\n+\t(current_function_decl): Delete declaration.\n+\t(compile_file): Call init_dummy_function_start and\n+\texpand_dummy_function_end around some initializations that need to\n+\temit rtl.\n+\t(rest_of_compilation): Use DECL_SAVED_INSNS properly.\n+\tCall init_function_for_compilation.\n+\t* unroll.c: Include \"function.h\"\n+\t(unroll_loop): Access regno_pointer_* variables through\n+\tcurrent_function.\n+\n+\t* tree.h (struct tree_decl): Add elt f to saved_insns member.\n+\t(DECL_SAVED_INSNS): use it.\n+\t(expand_dummy_function_end): Declare.\n+\t(init_function_for_compilation): Declare.\n+\t* calls.c (calls_function_1): Change use of DECL_SAVED_INSNS now\n+\tthat it's no longer an INLINE_HEADER.\n+\t(expand_call): Likewise.\n+\t* integrate.c (finish_inline): Delete function.\n+\t(max_parm_reg, parm_reg_stack_loc): Delete declarations.\n+\t(initialize_for_inline): Delete min_labelno, max_labelno and max_reg\n+\targs.  Don't generate an INLINE_HEADER rtx, just return the arg\n+\tvector.  All callers changed.\n+\t(save_for_inline_copying):  Create a duplicate struct emit_status to\n+\thold the emit state for compiling the current function.  Use this and\n+\tthe other new fields in struct function that are for integration\n+\tinstead of an INLINE_HEADER.\n+\tUse memcpy instead of bcopy.\n+\tStore the current struct function in DECL_SAVED_INSNS of fndecl.\n+\t(save_for_inline_nocopy): Similar changes, except no new emit_status\n+\tis needed here.\n+\t(expand_inline_function): Get information from function structure,\n+\tnot from an inline header rtx.\n+\t(output_inline_function): Lose code to extract the necessary\n+\tinformation from an inline header; simply put back the function\n+\tstructure into current_function.  Clear its inlinable elt.\n+\t* rtl.def (INLINE_HEADER): Delete.\n+\t* rtl.h: Delete all accessors for an INLINE_HEADER.\n+\t(gen_inline_header_rtx): Delete declaration.\n+\t(regno_reg_rtx, regno_pointer_align, nonlocal_goto_handler_labels):\n+\tDelete declarations.\n+\t(REGNO_POINTER_ALIGN): Delete.\n+\t(clear_emit_caches): Declare.\n+\t(set_new_last_label_num): Declare.\n+\n Mon Aug  9 01:52:24 1999  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* print-tree.c (print_node): Print base for OFFSET_TYPEs."}, {"sha": "5f01370eb979c9ddfca45f23af72fe483b853dcf", "filename": "gcc/Makefile.in", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -1327,7 +1327,7 @@ $(srcdir)/c-gperf.h: c-parse.gperf\n \t $(srcdir)/move-if-change tmp-gperf.h $(srcdir)/c-gperf.h\n \n c-decl.o : c-decl.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-common.h \\\n-    c-lex.h flags.h output.h toplev.h defaults.h\n+    c-lex.h flags.h function.h output.h toplev.h defaults.h\n c-typeck.o : c-typeck.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-common.h \\\n     flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h\n c-lang.o : c-lang.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-common.h \\\n@@ -1344,7 +1344,7 @@ c-iterate.o: c-iterate.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-tree.h \\\n     c-common.h flags.h toplev.h $(EXPR_H)\n mbchar.o: mbchar.c $(CONFIG_H) system.h mbchar.h\n graph.o: graph.c $(CONFIG_H) system.h toplev.h flags.h output.h $(RTL_H) \\\n-    hard-reg-set.h $(BASIC_BLOCK_H)\n+    function.h hard-reg-set.h $(BASIC_BLOCK_H)\n sbitmap.o: sbitmap.c $(CONFIG_H) system.h $(RTL_H) flags.h $(BASIC_BLOCK_H)\n \n COLLECT2_OBJS = collect2.o tlink.o hash.o intl.o underscore.o version.o \n@@ -1445,7 +1445,7 @@ stor-layout.o : stor-layout.c $(CONFIG_H) system.h $(TREE_H) flags.h \\\n    function.h $(EXPR_H) $(RTL_H) toplev.h\n fold-const.o : fold-const.c $(CONFIG_H) system.h $(TREE_H) flags.h toplev.h \\\n    $(RTL_H)\n-toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) \\\n+toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) function.h \\\n    flags.h input.h insn-attr.h xcoffout.h defaults.h output.h \\\n    insn-codes.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h dwarfout.h \\\n    dwarf2out.h sdbout.h dbxout.h $(EXPR_H) $(BASIC_BLOCK_H) \\\n@@ -1513,80 +1513,82 @@ integrate.o : integrate.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    intl.h function.h output.h $(RECOG_H) except.h toplev.h\n \n jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n-   insn-config.h insn-flags.h $(RECOG_H) $(EXPR_H) real.h except.h \\\n+   insn-config.h insn-flags.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \\\n    toplev.h insn-attr.h\n stupid.o : stupid.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h \\\n-   $(BASIC_BLOCK_H) insn-config.h reload.h flags.h toplev.h\n+   $(BASIC_BLOCK_H) insn-config.h reload.h flags.h function.h toplev.h\n \n cse.o : cse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n-   real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h \\\n+   real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h function.h \\\n    $(srcdir)/../include/splay-tree.h\n gcse.o : gcse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h \\\n    flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) \\\n-   output.h toplev.h\n+   function.h output.h toplev.h\n resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h system.h \\\n-   $(BASIC_BLOCK_H) $(REGS_H) flags.h output.h resource.h toplev.h\n+   $(BASIC_BLOCK_H) $(REGS_H) flags.h output.h resource.h function.h toplev.h\n lcm.o : lcm.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-flags.h \\\n-   gcov-io.h $(TREE_H) output.h $(REGS_H) toplev.h insn-config.h\n+   gcov-io.h $(TREE_H) output.h $(REGS_H) toplev.h function.h insn-config.h\n loop.o : loop.c $(CONFIG_H) system.h $(RTL_H) flags.h loop.h insn-config.h \\\n    insn-flags.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) real.h \\\n-   toplev.h varray.h\n-unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n+   function.h toplev.h varray.h\n+unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h function.h \\\n    integrate.h $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) loop.h toplev.h varray.h\n flow.o : flow.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h recog.h \\\n    insn-flags.h function.h\n-combine.o : combine.c $(CONFIG_H) system.h $(RTL_H) flags.h  \\\n+combine.o : combine.c $(CONFIG_H) system.h $(RTL_H) flags.h function.h \\\n    insn-config.h insn-flags.h insn-codes.h insn-attr.h $(REGS_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h\n regclass.o : regclass.c $(CONFIG_H) system.h $(RTL_H) hard-reg-set.h flags.h \\\n-   $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(RECOG_H) reload.h real.h toplev.h \\\n-   output.h\n+   $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(RECOG_H) reload.h real.h \\\n+   toplev.h function.h output.h\n local-alloc.o : local-alloc.c $(CONFIG_H) system.h $(RTL_H) flags.h \\\n-   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) output.h \\\n-   insn-attr.h toplev.h\n+   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n+   output.h function.h insn-attr.h toplev.h\n bitmap.o : bitmap.c $(CONFIG_H) system.h $(RTL_H) flags.h $(BASIC_BLOCK_H) \\\n    $(REGS_H)\n-global.o : global.c $(CONFIG_H) system.h $(RTL_H) flags.h reload.h \\\n+global.o : global.c $(CONFIG_H) system.h $(RTL_H) flags.h reload.h function.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h output.h toplev.h\n varray.o : varray.c $(CONFIG_H) system.h varray.h $(RTL_H) $(TREE_H) bitmap.h\n \n reload.o : reload.c $(CONFIG_H) system.h $(RTL_H) flags.h output.h $(EXPR_H) \\\n    reload.h $(RECOG_H) hard-reg-set.h insn-config.h insn-codes.h $(REGS_H) \\\n-   real.h toplev.h\n+   function.h real.h toplev.h\n reload1.o : reload1.c $(CONFIG_H) system.h $(RTL_H) real.h flags.h $(EXPR_H) \\\n    reload.h $(REGS_H) hard-reg-set.h insn-config.h insn-flags.h insn-codes.h \\\n-   $(BASIC_BLOCK_H) $(RECOG_H) output.h toplev.h\n+   $(BASIC_BLOCK_H) $(RECOG_H) output.h function.h toplev.h\n caller-save.o : caller-save.c $(CONFIG_H) system.h $(RTL_H) flags.h \\\n-   $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) \\\n+   $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) function.h \\\n    $(RECOG_H) reload.h $(EXPR_H) toplev.h\n reorg.o : reorg.c $(CONFIG_H) system.h $(RTL_H) conditions.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) insn-config.h insn-attr.h insn-flags.h \\\n-   $(RECOG_H) flags.h output.h $(EXPR_H) toplev.h\n+   $(RECOG_H) function.h flags.h output.h $(EXPR_H) toplev.h\n alias.o : alias.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h \\\n    $(REGS_H) toplev.h output.h $(EXPR_H) \n regmove.o : regmove.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n-   $(RECOG_H) output.h reload.h $(REGS_H) hard-reg-set.h flags.h \\\n+   $(RECOG_H) output.h reload.h $(REGS_H) hard-reg-set.h flags.h function.h \\\n    $(EXPR_H) insn-flags.h $(BASIC_BLOCK_H) toplev.h\n $(SCHED_PREFIX)sched.o : $(SCHED_PREFIX)sched.c $(CONFIG_H) system.h $(RTL_H) \\\n-   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h \\\n+   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n    insn-attr.h toplev.h recog.h\n final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h intl.h \\\n-   $(REGS_H) $(RECOG_H) conditions.h insn-config.h insn-attr.h except.h real.h \\\n-   output.h hard-reg-set.h insn-flags.h insn-codes.h gstab.h xcoffout.h \\\n-   defaults.h toplev.h reload.h dwarfout.h dwarf2out.h sdbout.h dbxout.h\n-recog.o : recog.c $(CONFIG_H) system.h $(RTL_H)  \\\n+   $(REGS_H) $(RECOG_H) conditions.h insn-config.h insn-attr.h function.h \\\n+   real.h output.h hard-reg-set.h insn-flags.h insn-codes.h gstab.h except.h \\\n+   xcoffout.h defaults.h toplev.h reload.h dwarfout.h dwarf2out.h sdbout.h \\\n+   dbxout.h\n+recog.o : recog.c $(CONFIG_H) system.h $(RTL_H) function.h \\\n    $(REGS_H) $(RECOG_H) hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n    insn-flags.h insn-codes.h real.h toplev.h\n reg-stack.o : reg-stack.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) recog.h \\\n-   $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-flags.h toplev.h\n+   $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-flags.h toplev.h \\\n+   function.h\n dyn-string.o: dyn-string.c dyn-string.h $(CONFIG_H) system.h\n \n $(out_object_file): $(out_file) $(CONFIG_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \\\n-   insn-flags.h output.h insn-attr.h insn-codes.h system.h toplev.h\n+   insn-flags.h output.h insn-attr.h insn-codes.h system.h toplev.h function.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(out_file)\n \n # Build auxiliary files that support ecoff format.\n@@ -1658,7 +1660,7 @@ s-codes : $(md_file) gencodes $(srcdir)/move-if-change\n \ttouch s-codes\n \n insn-emit.o : insn-emit.c $(CONFIG_H) $(RTL_H) $(EXPR_H) real.h output.h \\\n-  insn-config.h insn-flags.h insn-codes.h system.h reload.h recog.h\n+  insn-config.h insn-flags.h insn-codes.h system.h reload.h recog.h function.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-emit.c\n \n insn-emit.c: s-emit ; @true\n@@ -1725,7 +1727,7 @@ s-attrtab : $(md_file) genattrtab $(srcdir)/move-if-change\n \n insn-output.o : insn-output.c $(CONFIG_H) $(RTL_H) $(REGS_H) real.h conditions.h \\\n     hard-reg-set.h insn-config.h insn-flags.h insn-attr.h output.h $(RECOG_H) \\\n-    insn-codes.h system.h\n+    function.h insn-codes.h system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-output.c\n \n insn-output.c: s-output ; @true"}, {"sha": "d24b0b64543ba2188bcd8785d9a9612d300c834c", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -22,6 +22,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\""}, {"sha": "8e69652a0ade6be9c147e1912691e35141205eed", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -52,14 +52,6 @@ Boston, MA 02111-1307, USA.  */\n #define OUTGOING_REGNO(IN) (IN)\n #endif\n \n-/* Nonzero means __builtin_saveregs has already been done in this function.\n-   The value is the pseudoreg containing the value __builtin_saveregs\n-   returned.  */\n-rtx saveregs_value;\n-\n-/* Similarly for __builtin_apply_args.  */\n-rtx apply_args_value;\n-\n static int get_pointer_alignment\tPROTO((tree, unsigned));\n static tree c_strlen\t\t\tPROTO((tree));\n static rtx get_memory_rtx\t\tPROTO((tree));"}, {"sha": "97fdd8ad46597c13796d9102f79dd5a9efe6cd96", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -30,6 +30,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n+#include \"function.h\"\n #include \"output.h\"\n #include \"c-tree.h\"\n #include \"c-lex.h\""}, {"sha": "4edabfade14b0c279368e7d8951fc4d245608ca2", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -28,6 +28,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"basic-block.h\"\n #include \"reload.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"toplev.h\"\n "}, {"sha": "b646be8ba821eb8a87e9942699ee1ed51c9738e2", "filename": "gcc/calls.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -24,6 +24,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"flags.h\"\n #include \"expr.h\"\n+#include \"function.h\"\n #include \"regs.h\"\n #include \"insn-flags.h\"\n #include \"toplev.h\"\n@@ -218,8 +219,7 @@ calls_function_1 (exp, which)\n \t  if ((DECL_BUILT_IN (fndecl)\n \t       && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_ALLOCA)\n \t      || (DECL_SAVED_INSNS (fndecl)\n-\t\t  && (FUNCTION_FLAGS (DECL_SAVED_INSNS (fndecl))\n-\t\t      & FUNCTION_FLAGS_CALLS_ALLOCA)))\n+\t\t  && DECL_SAVED_INSNS (fndecl)->calls_alloca))\n \t    return 1;\n \t}\n \n@@ -1649,7 +1649,7 @@ expand_call (exp, target, ignore)\n \t      && fndecl != current_function_decl\n \t      && DECL_INLINE (fndecl)\n \t      && DECL_SAVED_INSNS (fndecl)\n-\t      && RTX_INTEGRATED_P (DECL_SAVED_INSNS (fndecl)))\n+\t      && DECL_SAVED_INSNS (fndecl)->inlinable)\n \t    is_integrable = 1;\n \t  else if (! TREE_ADDRESSABLE (fndecl))\n \t    {\n@@ -1786,11 +1786,11 @@ expand_call (exp, target, ignore)\n \t      rtx insn, seq;\n \n \t      /* Look for a call in the inline function code.\n-\t\t If OUTGOING_ARGS_SIZE (DECL_SAVED_INSNS (fndecl)) is\n+\t\t If DECL_SAVED_INSNS (fndecl)->outgoing_args_size is\n \t\t nonzero then there is a call and it is not necessary\n \t\t to scan the insns.  */\n \n-\t      if (OUTGOING_ARGS_SIZE (DECL_SAVED_INSNS (fndecl)) == 0)\n+\t      if (DECL_SAVED_INSNS (fndecl)->outgoing_args_size == 0)\n \t\tfor (insn = first_insn; insn; insn = NEXT_INSN (insn))\n \t\t  if (GET_CODE (insn) == CALL_INSN)\n \t\t    break;\n@@ -1814,7 +1814,7 @@ expand_call (exp, target, ignore)\n \t\t     value of reg_parm_stack_space is wrong, but gives\n \t\t     correct results on all supported machines.  */\n \n-\t\t  int adjust = (OUTGOING_ARGS_SIZE (DECL_SAVED_INSNS (fndecl))\n+\t\t  int adjust = (DECL_SAVED_INSNS (fndecl)->outgoing_args_size\n \t\t\t\t+ reg_parm_stack_space);\n \n \t\t  start_sequence ();"}, {"sha": "9df5ae57f215a6e11918bc2c8894ce20e1941e13", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -82,6 +82,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"insn-config.h\"\n+#include \"function.h\"\n /* Include expr.h after insn-config.h so we get HAVE_conditional_move. */\n #include \"expr.h\"\n #include \"insn-flags.h\""}, {"sha": "789eedb6c589cca3f5b87217927f1d8a5c3af6cb", "filename": "gcc/config/1750a/1750a.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -25,6 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #include <string.h>\n #include \"rtl.h\"\n #include \"tree.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #define HAVE_cc0\n #include \"conditions.h\""}, {"sha": "31b111754c948f792a70b4073930f1c7d948c056", "filename": "gcc/config/a29k/a29k.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-attr.h\"\n #include \"flags.h\"\n #include \"recog.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"obstack.h\"\n #include \"tree.h\""}, {"sha": "39b6cef2e0c1e0e526f7186b6efc4cef38b59b5d", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"insn-attr.h\"\n #include \"flags.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"recog.h\"\n "}, {"sha": "6eee03819898734418606c4ca1fdff05090c3a0f", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -699,7 +699,6 @@ extern enum reg_class arc_regno_reg_class[];\n    varargs function we want to treat the last named arg (which is\n    `__builtin_va_alist') as unnamed.\n    This macro is only used in this file.  */\n-extern int current_function_varargs;\n #define PASS_IN_REG_P(CUM, MODE, TYPE, NAMED) \\\n ((!current_function_varargs || (NAMED))\t\t\t\t\t\\\n  && (CUM) < MAX_ARC_PARM_REGS\t\t\t\t\t\t\\"}, {"sha": "a5013f9d5480987c2b5464ff24a1406447cc960a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -35,6 +35,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"reload.h\"\n #include \"tree.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"toplev.h\"\n #include \"recog.h\""}, {"sha": "62c4e6a4905aa804b9007b942c0ba485866acad8", "filename": "gcc/config/arm/thumb.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Farm%2Fthumb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Farm%2Fthumb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-attr.h\"\n #include \"flags.h\"\n #include \"tree.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"insn-config.h\"\n #include \"recog.h\""}, {"sha": "35bd196f8ddeeeb82b5820a1fd9f33a4286e9478", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -37,6 +37,7 @@\n #include \"insn-flags.h\"\n #include \"output.h\"\n #include \"tree.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"flags.h\"\n #include \"loop.h\""}, {"sha": "b9279ace0c686d919b48ca86573c979e811c3676", "filename": "gcc/config/clipper/clipper.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fclipper%2Fclipper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fclipper%2Fclipper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-attr.h\"\n #include \"tree.h\"\n #include \"c-tree.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"flags.h\"\n #include \"machmode.h\""}, {"sha": "1a588e034c565678141f88904b98c037d680c9c3", "filename": "gcc/config/convex/convex.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -30,6 +30,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-flags.h\"\n #include \"insn-attr.h\"\n #include \"output.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n \n /* Tables used in convex.h */"}, {"sha": "b38af880fd77ed7577ceb65f2452953b8caec233", "filename": "gcc/config/elxsi/elxsi.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Felxsi%2Felxsi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Felxsi%2Felxsi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -440,10 +440,9 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n { register int regno;\t\t\t\t\t\t\t\\\n   register int cnt = 0;\t\t\t\t\t\t\t\\\n   extern char call_used_regs[];\t\t\t\t\t\t\\\n-  extern int current_function_calls_alloca;\t\t\t\t\t\t\\\n   /* this conditional is ONLY here because there is a BUG;\t\t\\\n-\t     EXIT_IGNORE_STACK is ignored itself when the first part of\t\t\\\n-\t     the condition is true! (at least in version 1.35) */\t\t\\\n+\t     EXIT_IGNORE_STACK is ignored itself when the first part of\t\\\n+\t     the condition is true! (at least in version 1.35) */\t\\\n   /* the 8*10 is for 64 bits of .r5 - .r14 */\t\t\t\t\\\n   if (current_function_calls_alloca || (SIZE)>=(256-8*10)) {\t\t\\\n     /* use .r4 as a temporary! Ok for now.... */\t\t\t\\"}, {"sha": "48658e24fecf8725caa445d403fc1c70b717c7c8", "filename": "gcc/config/fx80/fx80.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Ffx80%2Ffx80.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Ffx80%2Ffx80.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -29,6 +29,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"conditions.h\"\n #include \"insn-flags.h\"\n+#include \"function.h\"\n #include \"output.h\"\n #include \"insn-attr.h\"\n "}, {"sha": "88656d13834cac7eac47ef73ea15653cad73cd2c", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -43,10 +43,6 @@ extern char *mvs_function_name;\n \n extern int mvs_function_name_length;\n \n-/* The amount of space used for outgoing arguments.  */\n-\n-extern int current_function_outgoing_args_size;\n-\n /* Compile using char instructions (mvc, nc, oc, xc).  On 4341 use this since\n    these are more than twice as fast as load-op-store.\n    On 3090 don't use this since load-op-store is much faster.  */"}, {"sha": "3b6385ae13e6b675389f2568a0896a07442e5d97", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -1859,8 +1859,6 @@ while (0)\n #define FINALIZE_PIC\t\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    extern int current_function_uses_pic_offset_table;\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n     current_function_uses_pic_offset_table |= profile_flag | profile_block_flag; \\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)"}, {"sha": "966c5724b2093c294219008cdd7e0807a3a9ce79", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -39,6 +39,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"recog.h\"\n #include \"insn-attr.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n \n static rtx find_addr_reg ();"}, {"sha": "229b6ab045bd7b31e4fed06cf11846a2550c4d2e", "filename": "gcc/config/m68k/a-ux.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Fa-ux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Fa-ux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fa-ux.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -150,9 +150,8 @@ crt2.o%s \"\n \n #define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  extern int current_function_returns_pointer;\t\t\t\t\\\n-  if ((current_function_returns_pointer) &&\t\t\t\t\\\n-      ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n+  if (current_function_returns_pointer\t\t\t\t\t\\\n+      && ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n     asm_fprintf (FILE, \"\\t%s %Ra0,%Rd0\\n\", ASM_MOV_INSN);\t\t\\\n }\n "}, {"sha": "d68efb47f3905615ba430e3e8aa21f4ed0e43bb0", "filename": "gcc/config/m68k/altos3068.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Faltos3068.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Faltos3068.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Faltos3068.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -126,10 +126,9 @@ Boston, MA 02111-1307, USA.  */\n /* Return pointer values in both d0 and a0.  */\n \n #undef FUNCTION_EXTRA_EPILOGUE\n-#define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  extern int current_function_returns_pointer;\t\t\t\\\n-  if ((current_function_returns_pointer) && \t\t\t\\\n-      ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\\\n-    fprintf (FILE, \"\\tmovel d0,a0\\n\");\t\t\t\t\\\n+#define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (current_function_returns_pointer\t\t\t\t\t\\\n+      && ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n+    fprintf (FILE, \"\\tmovel d0,a0\\n\");\t\t\t\t\t\\\n }"}, {"sha": "d100f5c6fe5eab74070d619aea83664f38950dc1", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -282,11 +282,10 @@ Boston, MA 02111-1307, USA.  */\n    callers that have neglected to properly declare the callee can\n    still find the correct return value.  */\n \n-extern int current_function_returns_pointer;\n #define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if ((current_function_returns_pointer) && \t\t\t\t\\\n-      ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n+  if (current_function_returns_pointer\t\t\t\t\t\\\n+      && ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n     asm_fprintf (FILE, \"\\tmove.l %Ra0,%Rd0\\n\");\t\t\t\t\\\n } while (0);\n "}, {"sha": "659c7057cb20547fa3870ab56df56f106e1ddeaa", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -24,6 +24,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"function.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"real.h\""}, {"sha": "6c229b6e5582efaeb836fb67e07cc09d8cbd3df7", "filename": "gcc/config/m68k/m68kv4.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kv4.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -179,11 +179,10 @@ while (0)\n    neglected to properly declare the callee can still find the correct return\n    value. */\n \n-extern int current_function_returns_pointer;\n #define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if ((current_function_returns_pointer) && \t\t\t\t\\\n-      ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n+  if (current_function_returns_pointer\t\t\t\t\t\\\n+      && ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n     asm_fprintf (FILE, \"\\tmov.l %Ra0,%Rd0\\n\");\t\t\t\t\\\n } while (0);\n "}, {"sha": "1a4ca6dbf848e732218a7409bfdd86b7b30549a4", "filename": "gcc/config/m68k/mot3300.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmot3300.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -145,10 +145,9 @@ Boston, MA 02111-1307, USA.  */\n \n #undef FUNCTION_EXTRA_EPILOGUE\n #define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n-  { extern int current_function_returns_pointer;\t\t\t\\\n-    if ((current_function_returns_pointer) &&\t\t\t\t\\\n-      ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))        \\\n-      asm_fprintf (FILE, \"\\tmov.l %Ra0,%Rd0\\n\"); } \n+{ if (current_function_returns_pointer\t\t\t\t\t\\\n+      && ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n+    asm_fprintf (FILE, \"\\tmov.l %Ra0,%Rd0\\n\"); }\n \n #undef FUNCTION_PROFILER\n #define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\"}, {"sha": "9197ac3539899234fa1251cacbb8eac3597783dd", "filename": "gcc/config/m68k/pbb.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Fpbb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Fpbb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fpbb.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -109,9 +109,8 @@ Boston, MA 02111-1307, USA.  */\n \n #undef FUNCTION_EXTRA_EPILOGUE\n #define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n-  { extern int current_function_returns_pointer;\t\t\t\\\n-    if ((current_function_returns_pointer) &&\t\t\t\t\\\n-      ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))        \\\n+{ if (current_function_returns_pointer\t\t\t\t\t\\\n+      && ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n       asm_fprintf (FILE, \"\\tmovl %Rd0,%Ra0\\n\"); } \n \n #define ASM_RETURN_CASE_JUMP \\"}, {"sha": "aeb5478849759997c671faf606eaf0c040377489", "filename": "gcc/config/m68k/tower-as.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Ftower-as.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm68k%2Ftower-as.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ftower-as.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -185,10 +185,9 @@ Boston, MA 02111-1307, USA.  */\n \n #undef FUNCTION_EXTRA_EPILOGUE\n #define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n-  { extern int current_function_returns_pointer;\t\t\t\\\n-    if ((current_function_returns_pointer) &&\t\t\t\t\\\n-      ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))        \\\n-      asm_fprintf (FILE, \"\\tmov.l %Rd0,%Ra0\\n\"); } \n+{ if (current_function_returns_pointer\t\t\t\t\t\\\n+      && ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n+    asm_fprintf (FILE, \"\\tmov.l %Rd0,%Ra0\\n\"); } \n \n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */"}, {"sha": "b8452169af378e1dc1f75a6c6afc5100419c7d55", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"insn-attr.h\"\n #include \"tree.h\"\n+#include \"function.h\"\n #include \"c-tree.h\"\n #include \"expr.h\"\n #include \"flags.h\"\n@@ -1759,11 +1760,6 @@ static int  variable_args_p;\n static int  epilogue_marked;\n static int  prologue_marked;\n \n-extern char call_used_regs[];\n-extern int  current_function_pretend_args_size;\n-extern int  current_function_outgoing_args_size;\n-extern int  frame_pointer_needed;\n-\n #define FIRST_OCS_PRESERVE_REGISTER\t14\n #define LAST_OCS_PRESERVE_REGISTER\t30\n "}, {"sha": "9c377c491584e14e6192b236ece8742dadcb90b9", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -155,7 +155,6 @@ extern enum m88k_instruction classify_integer ();\n \n extern int target_flags;\t\t\t/* -m compiler switches */\n extern int frame_pointer_needed;\t\t/* current function has a FP */\n-extern int current_function_pretend_args_size;\t/* args size without ... */\n extern int flag_delayed_branch;\t\t\t/* -fdelayed-branch */\n extern int flag_pic;\t\t\t\t/* -fpic */\n extern char * reg_names[];\n@@ -198,13 +197,13 @@ extern char * reg_names[];\n    Redefined in sysv4.h, and luna.h.  */\n #define VERSION_INFO1\t\"m88k, \"\n #ifndef VERSION_INFO2\n-#define VERSION_INFO2   \"$Revision: 1.14 $\"\n+#define VERSION_INFO2   \"$Revision: 1.15 $\"\n #endif\n \n #ifndef VERSION_STRING\n #define VERSION_STRING  version_string\n #ifdef __STDC__\n-#define TM_RCS_ID      \"@(#)\" __FILE__ \" $Revision: 1.14 $ \" __DATE__\n+#define TM_RCS_ID      \"@(#)\" __FILE__ \" $Revision: 1.15 $ \" __DATE__\n #else\n #define TM_RCS_ID      \"$What: <@(#) m88k.h,v\t1.1.1.2.2.2> $\"\n #endif  /* __STDC__ */"}, {"sha": "4c61676dab029a8083a1c5c7ff4a62c66e8ab8e3", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -41,8 +41,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-codes.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n-\n #include \"tree.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"flags.h\"\n #include \"reload.h\""}, {"sha": "4592c29bf0eb3fa191a51d41080ce425c7343518", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -27,7 +27,6 @@ Boston, MA 02111-1307, USA.  */\n \n extern char    *asm_file_name;\n extern char\tcall_used_regs[];\n-extern int\tcurrent_function_calls_alloca;\n extern char    *language_string;\n extern int\tmay_call_alloca;\n extern char   **save_argv;"}, {"sha": "c1e87609c5e0fe9a51814b45645e04f938f4945e", "filename": "gcc/config/mn10200/mn10200.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -1069,9 +1069,7 @@ extern void notice_update_cc ();\n extern int call_address_operand ();\n extern enum reg_class secondary_reload_class ();\n extern char *emit_a_shift ();\n-extern int current_function_needs_context;\n extern char *output_tst ();\n extern int extendpsi_operand ();\n-extern int rtx_equal_function_value_matters;\n extern struct rtx_def *zero_dreg;\n extern struct rtx_def *zero_areg;"}, {"sha": "5e0268c64c0114b6011ac7dc0af56fb5f5762b96", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -711,7 +711,6 @@ enum reg_class\n   int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n   int used_fregs_buf[17], *fbufp = used_fregs_buf;\t\t\\\n   extern char call_used_regs[];\t\t\t\t\t\\\n-  extern int current_function_uses_pic_offset_table, flag_pic;\t\\\n   MAIN_FUNCTION_PROLOGUE;\t\t\t\t\t\\\n   for (regno = R0_REGNUM; regno < F0_REGNUM; regno++)\t\t\\\n     if (regs_ever_live[regno]\t\t\t\t\t\\\n@@ -836,7 +835,6 @@ enum reg_class\n   int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n   int used_fregs_buf[17], *fbufp = used_fregs_buf;\t\t\\\n   extern char call_used_regs[];\t\t\t\t\t\\\n-  extern int current_function_uses_pic_offset_table, flag_pic;\t\\\n   if (flag_pic && current_function_uses_pic_offset_table)\t\\\n     fprintf (FILE, \"\\tlprd sb,tos\\n\");\t\t\t\t\\\n   *fbufp++ = -2;\t\t\t\t\t\t\\\n@@ -898,7 +896,6 @@ enum reg_class\n {\t\t\t\t\t\t\t\t\\\n   int regno;\t\t\t\t\t\t\t\\\n   int offset = -4;\t\t\t\t\t\t\\\n-  extern int current_function_uses_pic_offset_table, flag_pic;\t\\\n   for (regno = 0; regno < L1_REGNUM; regno++)\t\t\t\\\n     if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n       offset += 4;\t\t\t\t\t\t\\\n@@ -1196,7 +1193,6 @@ __transfer_from_trampoline ()\t\t\\\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n { register rtx xfooy, xfoo0, xfoo1;\t\t\t\t\t\\\n   unsigned xfoo2;\t\t\t\t\t\t\t\\\n-  extern int current_function_uses_pic_offset_table, flag_pic;\t\t\\\n   xfooy = X;\t\t\t\t\t\t\t\t\\\n   if (flag_pic && ! current_function_uses_pic_offset_table\t\t\\\n       && global_symbolic_reference_mentioned_p (X, 1))\t\t\t\\\n@@ -1240,7 +1236,6 @@ __transfer_from_trampoline ()\t\t\\\n    when generating PIC code.  It is given that flag_pic is on and\n    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-extern int current_function_uses_pic_offset_table, flag_pic;\n #define LEGITIMATE_PIC_OPERAND_P(X) \\\n   (((! current_function_uses_pic_offset_table\t\t\t\\\n      && symbolic_reference_mentioned_p (X))?\t\t\t\\"}, {"sha": "cdf1a4bfd3cb203686d2aa1b5985c671076c6240", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -35,6 +35,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"reload.h\"\n #include \"c-tree.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n@@ -2599,7 +2600,6 @@ compute_frame_size (size, fregs_live)\n      int size;\n      int *fregs_live;\n {\n-  extern int current_function_outgoing_args_size;\n   int i, fsize;\n \n   /* Space for frame pointer + filler. If any frame is allocated"}, {"sha": "c27fbf09d26b5077ddc992e0d18c6d0d0ef6a72e", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -1121,7 +1121,6 @@ extern enum cmp_type hppa_branch_type;\n    No definition is equivalent to always zero.  */\n \n extern int may_call_alloca;\n-extern int current_function_pretend_args_size;\n \n #define EXIT_IGNORE_STACK\t\\\n  (get_frame_size () != 0\t\\\n@@ -1138,11 +1137,6 @@ extern int current_function_pretend_args_size;\n    of alloca; we also take advantage of it to omit stack adjustments\n    before returning.  */\n \n-/* This declaration is needed due to traditional/ANSI\n-   incompatibilities which cannot be #ifdefed away\n-   because they occur inside of macros.  Sigh.  */\n-extern union tree_node *current_function_decl;\n-\n #define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\\\n   output_function_epilogue (FILE, SIZE)\n "}, {"sha": "6f3d779a1dbce07db7e46731d87116a1b24f47ca", "filename": "gcc/config/pa/som.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpa%2Fsom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpa%2Fsom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fsom.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -136,7 +136,7 @@ do {\t\t\t\t\t\t\t\t\\\n \t tree parm;\t\t\t\t\t\t\t\\\n \t int i;\t\t\t\t\t\t\t\t\\\n \t if (TREE_PUBLIC (DECL) || TARGET_GAS)\t\t\t\t\\\n-\t   { extern int current_function_varargs;\t\t\t\\\n+\t   { \t\t\t\t\t\t\t\t\\\n \t     if (TREE_PUBLIC (DECL))\t\t\t\t\t\\\n \t       {\t\t\t\t\t\t\t\\\n \t\t fputs (\"\\t.EXPORT \", FILE);\t\t\t\t\\"}, {"sha": "ebe76e3e1e5532b6435a812295460ede253a8664", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -28,6 +28,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"conditions.h\"\n #include \"insn-flags.h\"\n+#include \"function.h\"\n #include \"output.h\"\n #include \"insn-attr.h\"\n #include \"flags.h\""}, {"sha": "746a8e4d27c30a3889ab264f7142dd0854225759", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -684,7 +684,6 @@ maybe ac0 ? - as option someday! */\n    No definition is equivalent to always zero.  */\n \n extern int may_call_alloca;\n-extern int current_function_pretend_args_size;\n \n #define EXIT_IGNORE_STACK\t1\n "}, {"sha": "eaf0d4bb88a54fca1ee630fc4ab20fde2fb30161", "filename": "gcc/config/pyr/pyr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpyr%2Fpyr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpyr%2Fpyr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"insn-attr.h\"\n #include \"tree.h\"\n+#include \"function.h\"\n \n /*\n  * Do FUNCTION_ARG."}, {"sha": "e4395029189f0988d9e8affe9d24b01f44cd8600", "filename": "gcc/config/pyr/pyr.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpyr%2Fpyr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fpyr%2Fpyr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -783,9 +783,6 @@ extern void* pyr_function_arg ();\n \n /* This should return non-zero when we really set up a frame pointer.\n    Otherwise, GCC is directed to preserve sp by returning zero.  */\n-extern int current_function_pretend_args_size;\n-extern int current_function_args_size;\n-extern int current_function_calls_alloca;\n #define EXIT_IGNORE_STACK \\\n   (get_frame_size () + current_function_pretend_args_size\t\t\\\n    + current_function_args_size != 0\t\t\t\t\t\\"}, {"sha": "0b1a2a3f1b98709e0b0af1fe87d656802696a190", "filename": "gcc/config/romp/romp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"obstack.h\"\n #include \"tree.h\"\n+#include \"function.h\"\n \n #define min(A,B)\t((A) < (B) ? (A) : (B))\n #define max(A,B)\t((A) > (B) ? (A) : (B))"}, {"sha": "b6799d95ff1e3180edfd86c6776856f223a2dc47", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -30,6 +30,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"insn-flags.h\"\n #include \"expr.h\"\n+#include \"function.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"output.h\""}, {"sha": "949e2e714b64af1ab7be8961ab7061bed69d95ff", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -1039,8 +1039,6 @@ struct sh_args {\n    NPARM_REGS words is at least partially passed in a register unless\n    its data type forbids.  */\n \n-extern int current_function_varargs;\n-\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   ((PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n     && ((NAMED)\t\t\t\t\t\t\t\t\\"}, {"sha": "067680bdeefc56d729cf34eb5de6cc9253c89740", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -34,6 +34,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"insn-attr.h\"\n #include \"flags.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n@@ -2674,7 +2675,7 @@ mem_min_alignment (mem, desired)\n \t  /* Check if the compiler has recorded some information\n \t     about the alignment of the base REG.  If reload has\n \t     completed, we already matched with proper alignments.  */\n-\t  if (((regno_pointer_align != NULL\n+\t  if (((current_function != 0\n \t\t&& REGNO_POINTER_ALIGN (regno) >= desired)\n \t       || reload_completed)\n \t      && ((INTVAL (offset) & (desired - 1)) == 0))"}, {"sha": "7fafc4dc4c69272e7e42224a7c8520bd13fb5be4", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -2009,9 +2009,6 @@ LFLGRET\"ID\":\\n\\\n    functions that have frame pointers.\n    No definition is equivalent to always zero.  */\n \n-extern int current_function_calls_alloca;\n-extern int current_function_outgoing_args_size;\n-\n #define EXIT_IGNORE_STACK\t\\\n  (get_frame_size () != 0\t\\\n   || current_function_calls_alloca || current_function_outgoing_args_size)\n@@ -2026,11 +2023,6 @@ extern int current_function_outgoing_args_size;\n    of alloca; we also take advantage of it to omit stack adjustments\n    before returning.  */\n \n-/* This declaration is needed due to traditional/ANSI\n-   incompatibilities which cannot be #ifdefed away\n-   because they occur inside of macros.  Sigh.  */\n-extern union tree_node *current_function_decl;\n-\n #define FUNCTION_EPILOGUE(FILE, SIZE) \\\n   (TARGET_FLAT ? sparc_flat_output_function_epilogue (FILE, (int)SIZE) \\\n    : output_function_epilogue (FILE, (int)SIZE, \\"}, {"sha": "3ce499ef9de0582cb6cc250c6dfcca6f1cbebfd9", "filename": "gcc/config/spur/spur.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fspur%2Fspur.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fspur%2Fspur.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fspur.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -484,7 +484,6 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   extern char call_used_regs[];\t\t\t\t\t\\\n-  extern int current_function_pretend_args_size;\t\t\\\n   int fsize = ((SIZE) + 7) & ~7;\t\t\t\t\\\n   int nregs, i, fp_used = 0;\t\t\t\t\t\\\n   for (i = 32, nregs = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\\\n@@ -534,9 +533,6 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n    functions that have frame pointers.\n    No definition is equivalent to always zero.  */\n \n-extern int current_function_calls_alloca;\n-extern int current_function_pretend_args_size;\n-\n #define EXIT_IGNORE_STACK\t\\\n  (get_frame_size () != 0\t\\\n   || current_function_calls_alloca || current_function_pretend_args_size)\n@@ -554,8 +550,6 @@ extern int current_function_pretend_args_size;\n #define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   extern char call_used_regs[];\t\t\t\t\t\\\n-  extern int current_function_calls_alloca;\t\t\t\\\n-  extern int current_function_pretend_args_size;\t\t\\\n   int fsize = ((SIZE) + 7) & ~7;\t\t\t\t\\\n   int nregs, i, fp_used = 0;\t\t\t\t\t\\\n   for (i = 32, nregs = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\\"}, {"sha": "53f77d64be2ab88ce2c6d07e543b647a28631ab1", "filename": "gcc/config/tahoe/tahoe.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Ftahoe%2Ftahoe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Ftahoe%2Ftahoe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -28,6 +28,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"conditions.h\"\n #include \"insn-flags.h\"\n+#include \"function.h\"\n #include \"output.h\"\n #include \"insn-attr.h\"\n "}, {"sha": "7222bbb3193a4a2d4ceb1dbdc3c0005cb39d0b9c", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -1508,8 +1508,6 @@ compute_frame_size (size, p_reg_saved)\n      int size;\n      long *p_reg_saved;\n {\n-  extern int current_function_outgoing_args_size;\n-\n   return (size\n \t  + compute_register_save_size (p_reg_saved)\n \t  + current_function_outgoing_args_size);"}, {"sha": "4035d6a67f492c4d0fe884c66f9b7ee90c78db31", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -27,6 +27,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"conditions.h\"\n #include \"insn-flags.h\"\n+#include \"function.h\"\n #include \"output.h\"\n #include \"insn-attr.h\"\n #ifdef VMS_TARGET"}, {"sha": "a4302797664d8d48c92d78398b03c62d90da359f", "filename": "gcc/config/vax/vms.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fvax%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fvax%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvms.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -94,8 +94,7 @@ Boston, MA 02111-1307, USA.  */\n  * setting of -4 will end up adding them right back again, but don't bother.\n  */\n #define MAYBE_VMS_FUNCTION_PROLOGUE(FILE)\t\\\n-{ extern char *current_function_name;\t\t\\\n-  char *p = current_function_name;\t\t\\\n+{ char *p = current_function_name;\t\t\\\n   int is_main = strcmp (\"main\", p) == 0;\t\\\n   while (!is_main && *p != '\\0')\t\t\\\n     {\t\t\t\t\t\t\\"}, {"sha": "e1b58f9f477fbe069860002792f14cacee9e4e2a", "filename": "gcc/config/we32k/we32k.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -23,6 +23,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include <stdio.h>\n #include \"rtl.h\"\n+#include \"function.h\"\n #include \"real.h\"\n \n "}, {"sha": "43a7486625bbd94d09627a2f4cd3304d63d792fd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -1,3 +1,20 @@\n+1999-08-09  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* Makefile.in: Update dependencies.\n+\t* class.c (finish_struct_1): Don't initialize DECL_SAVED_INSNS with\n+\tNULL_RTX.\n+\t* decl.c: Include \"function.h\"\n+\t(cleanup_label, return_label): Delete declarations.\n+\t(store_parm_decls):  Don't initialize DECL_SAVED_INSNS with NULL_RTX.\n+\t(finish_function): Rename last_parm_insn variable to\n+\tfn_last_parm_insn.  Don't compare DECL_SAVED_INSNS to NULL_RTX.\n+\t* decl2.c: Include \"function.h\".\n+\t(rtl_expr_chain): Delete declaration.\n+\t* method.c: Include \"function.h\"\n+\t* tree.c (build_vbase_pointer_fields): Don't initialize\n+\tDECL_SAVED_INSNS with NULL_RTX.\n+\t* typeck.c: Include \"function.h\"\n+\n 1999-08-09  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* semantics.c (begin_function_try_block, finish_function_try_block,"}, {"sha": "c8be4d63bdca914b0402ec535b9de9ea9dafd1db", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -257,16 +257,17 @@ lex.o : lex.c $(CONFIG_H) $(CXX_TREE_H) \\\n decl.o : decl.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(srcdir)/../stack.h $(srcdir)/../output.h  \\\n   $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n-  $(srcdir)/../hash.h\n+  $(srcdir)/../hash.h $(srcdir)/../function.h\n decl2.o : decl2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  lex.h decl.h $(EXPR_H) $(srcdir)/../except.h \\\n+  lex.h decl.h $(EXPR_H) $(srcdir)/../except.h $(srcdir)/../function.h \\\n   $(srcdir)/../output.h $(srcdir)/../except.h $(srcdir)/../system.h \\\n   $(srcdir)/../toplev.h $(srcdir)/../dwarf2out.h $(srcdir)/../dwarfout.h \\\n   $(srcdir)/../../include/splay-tree.h $(srcdir)/../varray.h\n typeck2.o : typeck2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n typeck.o : typeck.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n-  $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h\n+  $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n+  $(srcdir)/../function.h\n class.o : class.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n   $(srcdir)/../../include/splay-tree.h\n@@ -275,9 +276,10 @@ call.o : call.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n friend.o : friend.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n init.o : init.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n-  $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h\n+  $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n+  $(srcdir)/../function.h\n method.o : method.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n-  $(srcdir)/../toplev.h\n+  $(srcdir)/../toplev.h $(srcdir)/../function.h\n cvt.o : cvt.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h decl.h \\\n   $(srcdir)/../flags.h $(srcdir)/../toplev.h $(srcdir)/../convert.h\n search.o : search.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../stack.h \\"}, {"sha": "a33c8892ee8978d215bd78abbc3e690f84cbd4dc", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -3404,7 +3404,7 @@ finish_struct_1 (t)\n \t if the insn `r' member and the size `i' member are\n \t different sizes, as on the alpha, the larger of the two\n \t will end up with garbage in it.  */\n-      DECL_SAVED_INSNS (x) = NULL_RTX;\n+      DECL_SAVED_INSNS (x) = 0;\n       DECL_FIELD_SIZE (x) = 0;\n \n       check_for_override (x, t);\n@@ -3503,7 +3503,7 @@ finish_struct_1 (t)\n       if (type == error_mark_node)\n \tcontinue;\n \t  \n-      DECL_SAVED_INSNS (x) = NULL_RTX;\n+      DECL_SAVED_INSNS (x) = 0;\n       DECL_FIELD_SIZE (x) = 0;\n \n       /* When this goes into scope, it will be a non-local reference.  */\n@@ -3871,7 +3871,7 @@ finish_struct_1 (t)\n       DECL_FIELD_CONTEXT (vfield) = t;\n       DECL_CLASS_CONTEXT (vfield) = t;\n       DECL_FCONTEXT (vfield) = t;\n-      DECL_SAVED_INSNS (vfield) = NULL_RTX;\n+      DECL_SAVED_INSNS (vfield) = 0;\n       DECL_FIELD_SIZE (vfield) = 0;\n       DECL_ALIGN (vfield) = TYPE_ALIGN (ptr_type_node);\n #if 0"}, {"sha": "4f0369368ec08433cb85c642c606cb0eee6342e7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"function.h\"\n #include \"flags.h\"\n #include \"cp-tree.h\"\n #include \"decl.h\"\n@@ -315,8 +316,6 @@ static rtx last_parm_cleanup_insn;\n \n tree ctor_label;\n \n-extern rtx cleanup_label, return_label;\n-\n /* If original DECL_RESULT of current function was a register,\n    but due to being an addressable named return value, would up\n    on the stack, this variable holds the named return value's\n@@ -13509,7 +13508,7 @@ store_parm_decls ()\n   declare_function_name ();\n \n   /* Initialize the RTL code for the function.  */\n-  DECL_SAVED_INSNS (fndecl) = NULL_RTX;\n+  DECL_SAVED_INSNS (fndecl) = 0;\n   if (! processing_template_decl)\n     expand_function_start (fndecl, parms_have_cleanups);\n \n@@ -13639,7 +13638,7 @@ finish_function (lineno, flags, nested)\n {\n   register tree fndecl = current_function_decl;\n   tree fntype, ctype = NULL_TREE;\n-  rtx last_parm_insn, insns;\n+  rtx fn_last_parm_insn, insns;\n   /* Label to use if this function is supposed to return a value.  */\n   tree no_return_label = NULL_TREE;\n   tree decls = NULL_TREE;\n@@ -13875,13 +13874,13 @@ finish_function (lineno, flags, nested)\n \t  insns = get_insns ();\n \t  end_sequence ();\n \n-\t  last_parm_insn = get_first_nonparm_insn ();\n-\t  if (last_parm_insn == NULL_RTX)\n-\t    last_parm_insn = get_last_insn ();\n+\t  fn_last_parm_insn = get_first_nonparm_insn ();\n+\t  if (fn_last_parm_insn == NULL_RTX)\n+\t    fn_last_parm_insn = get_last_insn ();\n \t  else\n-\t    last_parm_insn = previous_insn (last_parm_insn);\n+\t    fn_last_parm_insn = previous_insn (fn_last_parm_insn);\n \n-\t  emit_insns_after (insns, last_parm_insn);\n+\t  emit_insns_after (insns, fn_last_parm_insn);\n \n \t  if (! ok_to_optimize_dtor)\n \t    expand_end_cond ();\n@@ -14183,7 +14182,7 @@ finish_function (lineno, flags, nested)\n   if (! nested)\n     permanent_allocation (1);\n \n-  if (DECL_SAVED_INSNS (fndecl) == NULL_RTX)\n+  if (DECL_SAVED_INSNS (fndecl) == 0)\n     {\n       tree t;\n "}, {"sha": "a044f450d738f28292078661b25bb3ca423d13d6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"lex.h\"\n #include \"output.h\"\n #include \"except.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"defaults.h\"\n #include \"toplev.h\""}, {"sha": "90e9d90a2fedf1b23e75b819ef5aed5b8f7a5a91", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -25,6 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"function.h\"\n #include \"cp-tree.h\"\n #include \"flags.h\"\n #include \"output.h\"\n@@ -504,7 +505,7 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n    Note that emit_base_init does *not* initialize virtual base\n    classes.  That is done specially, elsewhere.  */\n \n-extern tree base_init_expr, rtl_expr_chain;\n+extern tree base_init_expr;\n \n void\n emit_base_init (t, immediately)"}, {"sha": "3cc4df220e72b1398f9947eaee38f3cc2361ea71", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"rtl.h\"\n #include \"expr.h\"\n+#include \"function.h\"\n #include \"output.h\"\n #include \"hard-reg-set.h\"\n #include \"flags.h\""}, {"sha": "b26548f98945be2e3f3f4dc6dacfa3d4e492bded", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -1010,7 +1010,7 @@ build_vbase_pointer_fields (rec)\n \t  DECL_FIELD_CONTEXT (decl) = rec;\n \t  DECL_CLASS_CONTEXT (decl) = rec;\n \t  DECL_FCONTEXT (decl) = basetype;\n-\t  DECL_SAVED_INSNS (decl) = NULL_RTX;\n+\t  DECL_SAVED_INSNS (decl) = 0;\n \t  DECL_FIELD_SIZE (decl) = 0;\n \t  DECL_ALIGN (decl) = TYPE_ALIGN (ptr_type_node);\n \t  TREE_CHAIN (decl) = vbase_decls;"}, {"sha": "030178639937b247abab8ac815a3da35efdc4558", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"output.h\"\n #include \"expr.h\"\n+#include \"function.h\"\n #include \"toplev.h\"\n #include \"defaults.h\"\n "}, {"sha": "9eca723e442c6f0bebb9e5da867fd9f84028e6e5", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"toplev.h\"\n #include \"output.h\""}, {"sha": "cf05529ebbfcdd2e4c4a06fd28ec038be6f2f708", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 86, "deletions": 206, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -57,20 +57,12 @@ enum machine_mode word_mode;\t/* Mode whose width is BITS_PER_WORD.  */\n enum machine_mode double_mode;\t/* Mode whose width is DOUBLE_TYPE_SIZE.  */\n enum machine_mode ptr_mode;\t/* Mode whose width is POINTER_SIZE.  */\n \n-/* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.\n-   After rtl generation, it is 1 plus the largest register number used.  */\n-\n-int reg_rtx_no = LAST_VIRTUAL_REGISTER + 1;\n \n /* This is *not* reset after each function.  It gives each CODE_LABEL\n    in the entire compilation a unique label number.  */\n \n static int label_num = 1;\n \n-/* Lowest label number in current function.  */\n-\n-static int first_label_num;\n-\n /* Highest label number in current function.\n    Zero means use the value of label_num instead.\n    This is nonzero only when belatedly compiling an inline function.  */\n@@ -162,58 +154,6 @@ rtx return_address_pointer_rtx;\t/* (REG:Pmode RETURN_ADDRESS_POINTER_REGNUM) */\n \n struct rtx_def const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n \n-/* The ends of the doubly-linked chain of rtl for the current function.\n-   Both are reset to null at the start of rtl generation for the function.\n-   \n-   start_sequence saves both of these on `sequence_stack' along with\n-   `sequence_rtl_expr' and then starts a new, nested sequence of insns.  */\n-\n-static rtx first_insn = NULL;\n-static rtx last_insn = NULL;\n-\n-/* RTL_EXPR within which the current sequence will be placed.  Use to\n-   prevent reuse of any temporaries within the sequence until after the\n-   RTL_EXPR is emitted.  */\n-\n-tree sequence_rtl_expr = NULL;\n-\n-/* INSN_UID for next insn emitted.\n-   Reset to 1 for each function compiled.  */\n-\n-static int cur_insn_uid = 1;\n-\n-/* Line number and source file of the last line-number NOTE emitted.\n-   This is used to avoid generating duplicates.  */\n-\n-static int last_linenum = 0;\n-static char *last_filename = 0;\n-\n-/* A vector indexed by pseudo reg number.  The allocated length\n-   of this vector is regno_pointer_flag_length.  Since this\n-   vector is needed during the expansion phase when the total\n-   number of registers in the function is not yet known,\n-   it is copied and made bigger when necessary.  */\n-\n-char *regno_pointer_flag;\n-int regno_pointer_flag_length;\n-\n-/* Indexed by pseudo register number, if nonzero gives the known alignment\n-   for that pseudo (if regno_pointer_flag is set).\n-   Allocated in parallel with regno_pointer_flag.  */\n-char *regno_pointer_align;\n-\n-/* Indexed by pseudo register number, gives the rtx for that pseudo.\n-   Allocated in parallel with regno_pointer_flag.  */\n-\n-rtx *regno_reg_rtx;\n-\n-/* Stack of pending (incomplete) sequences saved by `start_sequence'.\n-   Each element describes one pending sequence.\n-   The main insn-chain is saved in the last element of the chain,\n-   unless the chain is empty.  */\n-\n-struct sequence_stack *sequence_stack;\n-\n /* start_sequence and gen_sequence can make a lot of rtx expressions which are\n    shortly thrown away.  We use two mechanisms to prevent this waste:\n \n@@ -237,12 +177,14 @@ static rtx sequence_result[SEQUENCE_RESULT_SIZE];\n /* During RTL generation, we also keep a list of free INSN rtl codes.  */\n static rtx free_insn;\n \n-extern int rtx_equal_function_value_matters;\n+#define first_insn (current_function->emit->x_first_insn)\n+#define last_insn (current_function->emit->x_last_insn)\n+#define cur_insn_uid (current_function->emit->x_cur_insn_uid)\n+#define last_linenum (current_function->emit->x_last_linenum)\n+#define last_filename (current_function->emit->x_last_filename)\n+#define first_label_num (current_function->emit->x_first_label_num)\n \n-/* Filename and line number of last line-number note,\n-   whether we actually emitted it or not.  */\n-extern char *emit_filename;\n-extern int emit_lineno;\n+extern int rtx_equal_function_value_matters;\n \n static rtx make_jump_insn_raw\t\tPROTO((rtx));\n static rtx make_call_insn_raw\t\tPROTO((rtx));\n@@ -544,6 +486,7 @@ rtx\n gen_reg_rtx (mode)\n      enum machine_mode mode;\n {\n+  struct function *f = current_function;\n   register rtx val;\n \n   /* Don't let anything called after initial flow analysis create new\n@@ -575,28 +518,26 @@ gen_reg_rtx (mode)\n   /* Make sure regno_pointer_flag and regno_reg_rtx are large\n      enough to have an element for this pseudo reg number.  */\n \n-  if (reg_rtx_no == regno_pointer_flag_length)\n+  if (reg_rtx_no == f->emit->regno_pointer_flag_length)\n     {\n+      int old_size = f->emit->regno_pointer_flag_length;\n       rtx *new1;\n-      char *new =\n-\t(char *) savealloc (regno_pointer_flag_length * 2);\n-      bcopy (regno_pointer_flag, new, regno_pointer_flag_length);\n-      bzero (&new[regno_pointer_flag_length], regno_pointer_flag_length);\n-      regno_pointer_flag = new;\n-\n-      new = (char *) savealloc (regno_pointer_flag_length * 2);\n-      bcopy (regno_pointer_align, new, regno_pointer_flag_length);\n-      bzero (&new[regno_pointer_flag_length], regno_pointer_flag_length);\n-      regno_pointer_align = new;\n-\n-      new1 = (rtx *) savealloc (regno_pointer_flag_length * 2 * sizeof (rtx));\n-      bcopy ((char *) regno_reg_rtx, (char *) new1,\n-\t     regno_pointer_flag_length * sizeof (rtx));\n-      bzero ((char *) &new1[regno_pointer_flag_length],\n-\t     regno_pointer_flag_length * sizeof (rtx));\n+      char *new = (char *) savealloc (old_size * 2);\n+      memcpy (new, f->emit->regno_pointer_flag, old_size);\n+      memset (new + old_size, 0, old_size);\n+      f->emit->regno_pointer_flag = new;\n+\n+      new = (char *) savealloc (old_size * 2);\n+      memcpy (new, f->emit->regno_pointer_align, old_size);\n+      memset (new + old_size, 0, old_size);\n+      f->emit->regno_pointer_align = new;\n+\n+      new1 = (rtx *) savealloc (old_size * 2 * sizeof (rtx));\n+      memcpy (new1, regno_reg_rtx, old_size * sizeof (rtx));\n+      memset (new1 + old_size, 0, old_size * sizeof (rtx));\n       regno_reg_rtx = new1;\n \n-      regno_pointer_flag_length *= 2;\n+      f->emit->regno_pointer_flag_length = old_size * 2;\n     }\n \n   val = gen_rtx_raw_REG (mode, reg_rtx_no);\n@@ -1617,44 +1558,6 @@ gen_label_rtx ()\n \f\n /* For procedure integration.  */\n \n-/* Return a newly created INLINE_HEADER rtx.  Should allocate this\n-   from a permanent obstack when the opportunity arises.  */\n-\n-rtx\n-gen_inline_header_rtx (first_insn, first_parm_insn, first_labelno,\n-\t\t       last_labelno, max_parm_regnum, max_regnum, args_size,\n-\t\t       pops_args, stack_slots, forced_labels, function_flags,\n-\t\t       outgoing_args_size, original_arg_vector,\n-\t\t       original_decl_initial, regno_rtx, regno_flag,\n-\t\t       regno_align, parm_reg_stack_loc)\n-     rtx first_insn, first_parm_insn;\n-     int first_labelno, last_labelno, max_parm_regnum, max_regnum, args_size;\n-     int pops_args;\n-     rtx stack_slots;\n-     rtx forced_labels;\n-     int function_flags;\n-     int outgoing_args_size;\n-     rtvec original_arg_vector;\n-     rtx original_decl_initial;\n-     rtvec regno_rtx;\n-     char *regno_flag;\n-     char *regno_align;\n-     rtvec parm_reg_stack_loc;\n-{\n-  rtx header = gen_rtx_INLINE_HEADER (VOIDmode,\n-\t\t\t\t      cur_insn_uid++, NULL_RTX,\n-\t\t\t\t      first_insn, first_parm_insn,\n-\t\t\t\t      first_labelno, last_labelno,\n-\t\t\t\t      max_parm_regnum, max_regnum, args_size,\n-\t\t\t\t      pops_args, stack_slots, forced_labels,\n-\t\t\t\t      function_flags, outgoing_args_size,\n-\t\t\t\t      original_arg_vector,\n-\t\t\t\t      original_decl_initial,\n-\t\t\t\t      regno_rtx, regno_flag, regno_align,\n-\t\t\t\t      parm_reg_stack_loc);\n-  return header;\n-}\n-\n /* Install new pointers to the first and last insns in the chain.\n    Also, set cur_insn_uid to one higher than the last in use.\n    Used for an inline-procedure after copying the insn chain.  */\n@@ -1686,60 +1589,27 @@ set_new_first_and_last_label_num (first, last)\n   first_label_num = first;\n   last_label_num = last;\n }\n-\f\n-/* Save all variables describing the current status into the structure *P.\n-   This is used before starting a nested function.  */\n+\n+/* Set the last label number found in the current function.\n+   This is used when belatedly compiling an inline function.  */\n \n void\n-save_emit_status (p)\n-     struct function *p;\n+set_new_last_label_num (last)\n+     int last;\n {\n-  p->reg_rtx_no = reg_rtx_no;\n-  p->first_label_num = first_label_num;\n-  p->first_insn = first_insn;\n-  p->last_insn = last_insn;\n-  p->sequence_rtl_expr = sequence_rtl_expr;\n-  p->sequence_stack = sequence_stack;\n-  p->cur_insn_uid = cur_insn_uid;\n-  p->last_linenum = last_linenum;\n-  p->last_filename = last_filename;\n-  p->regno_pointer_flag = regno_pointer_flag;\n-  p->regno_pointer_align = regno_pointer_align;\n-  p->regno_pointer_flag_length = regno_pointer_flag_length;\n-  p->regno_reg_rtx = regno_reg_rtx;\n+  base_label_num = label_num;\n+  last_label_num = last;\n }\n-\n+\f\n /* Restore all variables describing the current status from the structure *P.\n    This is used after a nested function.  */\n \n void\n restore_emit_status (p)\n      struct function *p;\n {\n-  int i;\n-\n-  reg_rtx_no = p->reg_rtx_no;\n-  first_label_num = p->first_label_num;\n   last_label_num = 0;\n-  first_insn = p->first_insn;\n-  last_insn = p->last_insn;\n-  sequence_rtl_expr = p->sequence_rtl_expr;\n-  sequence_stack = p->sequence_stack;\n-  cur_insn_uid = p->cur_insn_uid;\n-  last_linenum = p->last_linenum;\n-  last_filename = p->last_filename;\n-  regno_pointer_flag = p->regno_pointer_flag;\n-  regno_pointer_align = p->regno_pointer_align;\n-  regno_pointer_flag_length = p->regno_pointer_flag_length;\n-  regno_reg_rtx = p->regno_reg_rtx;\n-\n-  /* Clear our cache of rtx expressions for start_sequence and\n-     gen_sequence.  */\n-  sequence_element_free_list = 0;\n-  for (i = 0; i < SEQUENCE_RESULT_SIZE; i++)\n-    sequence_result[i] = 0;\n-\n-  free_insn = 0;\n+  clear_emit_caches ();\n }\n \f\n /* Go through all the RTL insn bodies and copy any invalid shared structure.\n@@ -2033,7 +1903,7 @@ get_last_insn_anywhere ()\n   struct sequence_stack *stack;\n   if (last_insn)\n     return last_insn;\n-  for (stack = sequence_stack; stack; stack = stack->next)\n+  for (stack = seq_stack; stack; stack = stack->next)\n     if (stack->last != 0)\n       return stack->last;\n   return 0;\n@@ -2498,7 +2368,7 @@ add_insn_after (insn, after)\n     last_insn = insn;\n   else\n     {\n-      struct sequence_stack *stack = sequence_stack;\n+      struct sequence_stack *stack = seq_stack;\n       /* Scan all pending sequences too.  */\n       for (; stack; stack = stack->next)\n \tif (after == stack->last)\n@@ -2549,7 +2419,7 @@ add_insn_before (insn, before)\n     first_insn = insn;\n   else\n     {\n-      struct sequence_stack *stack = sequence_stack;\n+      struct sequence_stack *stack = seq_stack;\n       /* Scan all pending sequences too.  */\n       for (; stack; stack = stack->next)\n \tif (before == stack->first)\n@@ -2588,7 +2458,7 @@ remove_insn (insn)\n     first_insn = next;\n   else\n     {\n-      struct sequence_stack *stack = sequence_stack;\n+      struct sequence_stack *stack = seq_stack;\n       /* Scan all pending sequences too.  */\n       for (; stack; stack = stack->next)\n \tif (insn == stack->first)\n@@ -2611,7 +2481,7 @@ remove_insn (insn)\n     last_insn = prev;\n   else\n     {\n-      struct sequence_stack *stack = sequence_stack;\n+      struct sequence_stack *stack = seq_stack;\n       /* Scan all pending sequences too.  */\n       for (; stack; stack = stack->next)\n \tif (insn == stack->last)\n@@ -3335,12 +3205,12 @@ start_sequence ()\n   else\n     tem = (struct sequence_stack *) permalloc (sizeof (struct sequence_stack));\n \n-  tem->next = sequence_stack;\n+  tem->next = seq_stack;\n   tem->first = first_insn;\n   tem->last = last_insn;\n-  tem->sequence_rtl_expr = sequence_rtl_expr;\n+  tem->sequence_rtl_expr = seq_rtl_expr;\n \n-  sequence_stack = tem;\n+  seq_stack = tem;\n \n   first_insn = 0;\n   last_insn = 0;\n@@ -3356,7 +3226,7 @@ start_sequence_for_rtl_expr (t)\n {\n   start_sequence ();\n \n-  sequence_rtl_expr = t;\n+  seq_rtl_expr = t;\n }\n \n /* Set up the insn chain starting with FIRST as the current sequence,\n@@ -3387,12 +3257,12 @@ push_topmost_sequence ()\n \n   start_sequence ();\n \n-  for (stack = sequence_stack; stack; stack = stack->next)\n+  for (stack = seq_stack; stack; stack = stack->next)\n     top = stack;\n \n   first_insn = top->first;\n   last_insn = top->last;\n-  sequence_rtl_expr = top->sequence_rtl_expr;\n+  seq_rtl_expr = top->sequence_rtl_expr;\n }\n \n /* After emitting to the outer-level insn chain, update the outer-level\n@@ -3403,12 +3273,12 @@ pop_topmost_sequence ()\n {\n   struct sequence_stack *stack, *top = NULL;\n \n-  for (stack = sequence_stack; stack; stack = stack->next)\n+  for (stack = seq_stack; stack; stack = stack->next)\n     top = stack;\n \n   top->first = first_insn;\n   top->last = last_insn;\n-  /* ??? Why don't we save sequence_rtl_expr here?  */\n+  /* ??? Why don't we save seq_rtl_expr here?  */\n \n   end_sequence ();\n }\n@@ -3429,12 +3299,12 @@ pop_topmost_sequence ()\n void\n end_sequence ()\n {\n-  struct sequence_stack *tem = sequence_stack;\n+  struct sequence_stack *tem = seq_stack;\n \n   first_insn = tem->first;\n   last_insn = tem->last;\n-  sequence_rtl_expr = tem->sequence_rtl_expr;\n-  sequence_stack = tem->next;\n+  seq_rtl_expr = tem->sequence_rtl_expr;\n+  seq_stack = tem->next;\n \n   tem->next = sequence_element_free_list;\n   sequence_element_free_list = tem;\n@@ -3445,7 +3315,7 @@ end_sequence ()\n int\n in_sequence_p ()\n {\n-  return sequence_stack != 0;\n+  return seq_stack != 0;\n }\n \n /* Generate a SEQUENCE rtx containing the insns already emitted\n@@ -3506,13 +3376,27 @@ gen_sequence ()\n /* Put the various virtual registers into REGNO_REG_RTX.  */\n \n void\n-init_virtual_regs ()\n+init_virtual_regs (es)\n+     struct emit_status *es;\n {\n-  regno_reg_rtx[VIRTUAL_INCOMING_ARGS_REGNUM] = virtual_incoming_args_rtx;\n-  regno_reg_rtx[VIRTUAL_STACK_VARS_REGNUM] = virtual_stack_vars_rtx;\n-  regno_reg_rtx[VIRTUAL_STACK_DYNAMIC_REGNUM] = virtual_stack_dynamic_rtx;\n-  regno_reg_rtx[VIRTUAL_OUTGOING_ARGS_REGNUM] = virtual_outgoing_args_rtx;\n-  regno_reg_rtx[VIRTUAL_CFA_REGNUM] = virtual_cfa_rtx;\n+  rtx *ptr = es->x_regno_reg_rtx;\n+  ptr[VIRTUAL_INCOMING_ARGS_REGNUM] = virtual_incoming_args_rtx;\n+  ptr[VIRTUAL_STACK_VARS_REGNUM] = virtual_stack_vars_rtx;\n+  ptr[VIRTUAL_STACK_DYNAMIC_REGNUM] = virtual_stack_dynamic_rtx;\n+  ptr[VIRTUAL_OUTGOING_ARGS_REGNUM] = virtual_outgoing_args_rtx;\n+  ptr[VIRTUAL_CFA_REGNUM] = virtual_cfa_rtx;\n+}\n+\n+void\n+clear_emit_caches ()\n+{\n+  int i;\n+\n+  /* Clear the start_sequence/gen_sequence cache.  */\n+  sequence_element_free_list = 0;\n+  for (i = 0; i < SEQUENCE_RESULT_SIZE; i++)\n+    sequence_result[i] = 0;\n+  free_insn = 0;\n }\n \n /* Initialize data structures and variables in this file\n@@ -3521,43 +3405,41 @@ init_virtual_regs ()\n void\n init_emit ()\n {\n-  int i;\n+  struct function *f = current_function;\n \n+  f->emit = (struct emit_status *) xmalloc (sizeof (struct emit_status));\n   first_insn = NULL;\n   last_insn = NULL;\n-  sequence_rtl_expr = NULL;\n+  seq_rtl_expr = NULL;\n   cur_insn_uid = 1;\n   reg_rtx_no = LAST_VIRTUAL_REGISTER + 1;\n   last_linenum = 0;\n   last_filename = 0;\n   first_label_num = label_num;\n   last_label_num = 0;\n-  sequence_stack = NULL;\n+  seq_stack = NULL;\n \n-  /* Clear the start_sequence/gen_sequence cache.  */\n-  sequence_element_free_list = 0;\n-  for (i = 0; i < SEQUENCE_RESULT_SIZE; i++)\n-    sequence_result[i] = 0;\n-  free_insn = 0;\n+  clear_emit_caches ();\n \n   /* Init the tables that describe all the pseudo regs.  */\n \n-  regno_pointer_flag_length = LAST_VIRTUAL_REGISTER + 101;\n+  f->emit->regno_pointer_flag_length = LAST_VIRTUAL_REGISTER + 101;\n \n-  regno_pointer_flag \n-    = (char *) savealloc (regno_pointer_flag_length);\n-  bzero (regno_pointer_flag, regno_pointer_flag_length);\n+  f->emit->regno_pointer_flag \n+    = (char *) savealloc (f->emit->regno_pointer_flag_length);\n+  bzero (f->emit->regno_pointer_flag, f->emit->regno_pointer_flag_length);\n \n-  regno_pointer_align\n-    = (char *) savealloc (regno_pointer_flag_length);\n-  bzero (regno_pointer_align, regno_pointer_flag_length);\n+  f->emit->regno_pointer_align\n+    = (char *) savealloc (f->emit->regno_pointer_flag_length);\n+  bzero (f->emit->regno_pointer_align, f->emit->regno_pointer_flag_length);\n \n   regno_reg_rtx \n-    = (rtx *) savealloc (regno_pointer_flag_length * sizeof (rtx));\n-  bzero ((char *) regno_reg_rtx, regno_pointer_flag_length * sizeof (rtx));\n+    = (rtx *) savealloc (f->emit->regno_pointer_flag_length * sizeof (rtx));\n+  bzero ((char *) regno_reg_rtx,\n+\t f->emit->regno_pointer_flag_length * sizeof (rtx));\n \n   /* Put copies of all the virtual register rtx into regno_reg_rtx.  */\n-  init_virtual_regs ();\n+  init_virtual_regs (f->emit);\n \n   /* Indicate that the virtual registers and stack locations are\n      all pointers.  */\n@@ -3608,8 +3490,6 @@ init_emit_once (line_numbers)\n \n   no_line_numbers = ! line_numbers;\n \n-  sequence_stack = NULL;\n-\n   /* Compute the word and byte modes.  */\n \n   byte_mode = VOIDmode;"}, {"sha": "b79aa9b63aed2d8e9627dc635a9467bc6cc1064c", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -25,6 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"hard-reg-set.h\"\n #include \"insn-config.h\""}, {"sha": "d9382aad0e7cb8a451caa00122ed98d955ccbb65", "filename": "gcc/expr.c", "status": "modified", "additions": 16, "deletions": 73, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -83,35 +83,11 @@ int cse_not_expected;\n    Nowadays this is never zero.  */\n int do_preexpand_calls = 1;\n \n-/* Number of units that we should eventually pop off the stack.\n-   These are the arguments to function calls that have already returned.  */\n-int pending_stack_adjust;\n-\n-/* Under some ABIs, it is the caller's responsibility to pop arguments\n-   pushed for function calls.  A naive implementation would simply pop\n-   the arguments immediately after each call.  However, if several\n-   function calls are made in a row, it is typically cheaper to pop\n-   all the arguments after all of the calls are complete since a\n-   single pop instruction can be used.  Therefore, GCC attempts to\n-   defer popping the arguments until absolutely necessary.  (For\n-   example, at the end of a conditional, the arguments must be popped,\n-   since code outside the conditional won't know whether or not the\n-   arguments need to be popped.)\n-\n-   When INHIBIT_DEFER_POP is non-zero, however, the compiler does not\n-   attempt to defer pops.  Instead, the stack is popped immediately\n-   after each call.  Rather then setting this variable directly, use\n-   NO_DEFER_POP and OK_DEFER_POP.  */\n-int inhibit_defer_pop;\n-\n /* Don't check memory usage, since code is being emitted to check a memory\n    usage.  Used when current_function_check_memory_usage is true, to avoid\n    infinite recursion.  */\n static int in_check_memory_usage;\n \n-/* Postincrements that still need to be expanded.  */\n-static rtx pending_chain;\n-\n /* This structure is used by move_by_pieces to describe the move to\n    be performed.  */\n struct move_by_pieces\n@@ -147,12 +123,10 @@ struct clear_by_pieces\n };\n \n extern struct obstack permanent_obstack;\n-extern rtx arg_pointer_save_area;\n \n static rtx get_push_address\tPROTO ((int));\n \n static rtx enqueue_insn\t\tPROTO((rtx, rtx));\n-static void init_queue\t\tPROTO((void));\n static int move_by_pieces_ninsns PROTO((unsigned int, int));\n static void move_by_pieces_1\tPROTO((rtx (*) (rtx, ...), enum machine_mode,\n \t\t\t\t       struct move_by_pieces *));\n@@ -302,50 +276,23 @@ init_expr_once ()\n void\n init_expr ()\n {\n-  init_queue ();\n+  current_function->expr\n+    = (struct expr_status *) xmalloc (sizeof (struct expr_status));\n \n+  pending_chain = 0;\n   pending_stack_adjust = 0;\n   inhibit_defer_pop = 0;\n   saveregs_value = 0;\n   apply_args_value = 0;\n   forced_labels = 0;\n }\n \n-/* Save all variables describing the current status into the structure *P.\n-   This is used before starting a nested function.  */\n-\n+/* Small sanity check that the queue is empty at the end of a function.  */\n void\n-save_expr_status (p)\n-     struct function *p;\n+finish_expr_for_function ()\n {\n-  p->pending_chain = pending_chain;\n-  p->pending_stack_adjust = pending_stack_adjust;\n-  p->inhibit_defer_pop = inhibit_defer_pop;\n-  p->saveregs_value = saveregs_value;\n-  p->apply_args_value = apply_args_value;\n-  p->forced_labels = forced_labels;\n-\n-  pending_chain = NULL_RTX;\n-  pending_stack_adjust = 0;\n-  inhibit_defer_pop = 0;\n-  saveregs_value = 0;\n-  apply_args_value = 0;\n-  forced_labels = 0;\n-}\n-\n-/* Restore all variables describing the current status from the structure *P.\n-   This is used after a nested function.  */\n-\n-void\n-restore_expr_status (p)\n-     struct function *p;\n-{\n-  pending_chain = p->pending_chain;\n-  pending_stack_adjust = p->pending_stack_adjust;\n-  inhibit_defer_pop = p->inhibit_defer_pop;\n-  saveregs_value = p->saveregs_value;\n-  apply_args_value = p->apply_args_value;\n-  forced_labels = p->forced_labels;\n+  if (pending_chain)\n+    abort ();\n }\n \f\n /* Manage the queue of increment instructions to be output\n@@ -507,13 +454,6 @@ emit_queue ()\n       pending_chain = QUEUED_NEXT (p);\n     }\n }\n-\n-static void\n-init_queue ()\n-{\n-  if (pending_chain)\n-    abort ();\n-}\n \f\n /* Copy data from FROM to TO, where the machine modes are not the same.\n    Both modes may be integer, or both may be floating.\n@@ -5687,9 +5627,9 @@ expand_expr (exp, target, tmode, modifier)\n \t    push_obstacks (p->function_obstack,\n \t\t\t   p->function_maybepermanent_obstack);\n \n-\t    p->forced_labels = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\t  label_rtx (exp),\n-\t\t\t\t\t\t  p->forced_labels);\n+\t    p->expr->x_forced_labels\n+\t      = gen_rtx_EXPR_LIST (VOIDmode, label_rtx (exp),\n+\t\t\t\t   p->expr->x_forced_labels);\n \t    pop_obstacks ();\n \t  }\n \telse\n@@ -5737,7 +5677,8 @@ expand_expr (exp, target, tmode, modifier)\n \t memory protection).\n \n \t Aggregates are not checked here; they're handled elsewhere.  */\n-      if (current_function_check_memory_usage && code == VAR_DECL\n+      if (current_function && current_function_check_memory_usage\n+\t  && code == VAR_DECL\n \t  && GET_CODE (DECL_RTL (exp)) == MEM\n \t  && ! AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n \t{\n@@ -6254,7 +6195,8 @@ expand_expr (exp, target, tmode, modifier)\n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address (mode, op0);\n \n-\tif (current_function_check_memory_usage && !AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n+\tif (current_function && current_function_check_memory_usage\n+\t    && ! AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n \t  {\n \t    enum memory_use_mode memory_usage;\n \t    memory_usage = get_memory_usage_from_modifier (modifier);\n@@ -6542,7 +6484,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  }\n \n \t/* Check the access.  */\n-\tif (current_function_check_memory_usage && GET_CODE (op0) == MEM)\n+\tif (current_function && current_function_check_memory_usage\n+\t    && GET_CODE (op0) == MEM)\n           {\n \t    enum memory_use_mode memory_usage;\n \t    memory_usage = get_memory_usage_from_modifier (modifier);"}, {"sha": "8319e25102b462bc8cfc71b469d07770f6bde61b", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 91, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -68,104 +68,13 @@ enum memory_use_mode {MEMORY_USE_BAD = 0, MEMORY_USE_RO = 1,\n \t\t      MEMORY_USE_WO = 2, MEMORY_USE_RW = 3,\n \t\t      MEMORY_USE_TW = 6, MEMORY_USE_DONT = 99};\n \n-/* List of labels that must never be deleted.  */\n-extern rtx forced_labels;\n-\n-/* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.\n-   So we can mark them all live at the end of the function, if stupid.  */\n-extern rtx save_expr_regs;\n-\n-/* Nonzero means __builtin_saveregs has already been done in this function.\n-   The value is the pseudoreg containing the value __builtin_saveregs\n-   returned.  */\n-extern rtx saveregs_value;\n-\n-/* Similarly for __builtin_apply_args.  */\n-extern rtx apply_args_value;\n-\n-extern int current_function_calls_alloca;\n-extern int current_function_outgoing_args_size;\n-\n-/* This is the offset from the arg pointer to the place where the first\n-   anonymous arg can be found, if there is one.  */\n-extern rtx current_function_arg_offset_rtx;\n-\n-/* This is nonzero if the current function uses the constant pool.  */\n-extern int current_function_uses_const_pool;\n-\n-/* This is nonzero if the current function uses pic_offset_table_rtx.  */\n-extern int current_function_uses_pic_offset_table;\n-\n-/* The arg pointer hard register, or the pseudo into which it was copied.  */\n-extern rtx current_function_internal_arg_pointer;\n-\n-/* This is nonzero if memory access checking be enabled in the current\n-   function.  */\n-extern int current_function_check_memory_usage;\n-\n-/* Under some ABIs, it is the caller's responsibility to pop arguments\n-   pushed for function calls.  A naive implementation would simply pop\n-   the arguments immediately after each call.  However, if several\n-   function calls are made in a row, it is typically cheaper to pop\n-   all the arguments after all of the calls are complete since a\n-   single pop instruction can be used.  Therefore, GCC attempts to\n-   defer popping the arguments until absolutely necessary.  (For\n-   example, at the end of a conditional, the arguments must be popped,\n-   since code outside the conditional won't know whether or not the\n-   arguments need to be popped.)\n-\n-   When INHIBIT_DEFER_POP is non-zero, however, the compiler does not\n-   attempt to defer pops.  Instead, the stack is popped immediately\n-   after each call.  Rather then setting this variable directly, use\n-   NO_DEFER_POP and OK_DEFER_POP.  */\n-extern int inhibit_defer_pop;\n-\n /* Prevent the compiler from deferring stack pops.  See\n    inhibit_defer_pop for more information.  */\n #define NO_DEFER_POP (inhibit_defer_pop += 1)\n \n /* Allow the compiler to defer stack pops.  See inhibit_defer_pop for\n    more information.  */\n #define OK_DEFER_POP (inhibit_defer_pop -= 1)\n-\n-/* Number of function calls seen so far in current function.  */\n-\n-extern int function_call_count;\n-\n-/* List (chain of EXPR_LIST) of stack slots that hold the current handlers\n-   for nonlocal gotos.  There is one for every nonlocal label in the function;\n-   this list matches the one in nonlocal_labels.\n-   Zero when function does not have nonlocal labels.  */\n-\n-extern rtx nonlocal_goto_handler_slots;\n-\n-/* RTX for stack slot that holds the stack pointer value to restore\n-   for a nonlocal goto.\n-   Zero when function does not have nonlocal labels.  */\n-\n-extern rtx nonlocal_goto_stack_level;\n-\n-/* List (chain of TREE_LIST) of LABEL_DECLs for all nonlocal labels\n-   (labels to which there can be nonlocal gotos from nested functions)\n-   in this function.  */\n-\n-#ifdef TREE_CODE   /* Don't lose if tree.h not included.  */\n-extern tree nonlocal_labels;\n-#endif\n-\n-/* Number of units that we should eventually pop off the stack.\n-   These are the arguments to function calls that have already returned.  */\n-extern int pending_stack_adjust;\n-\n-/* When temporaries are created by TARGET_EXPRs, they are created at\n-   this level of temp_slot_level, so that they can remain allocated\n-   until no longer needed.  CLEANUP_POINT_EXPRs define the lifetime\n-   of TARGET_EXPRs.  */\n-extern int target_temp_slot_level;\n-\n-/* Current level for normal temporaries.  */\n-\n-extern int temp_slot_level;\n \f\n #ifdef TREE_CODE /* Don't lose if tree.h not included.  */\n /* Structure to record the size of a sequence of arguments\n@@ -756,6 +665,9 @@ extern void init_expr_once PROTO((void));\n /* This is run at the start of compiling a function.  */\n extern void init_expr PROTO((void));\n \n+/* This is run at the end of compiling a function.  */\n+extern void finish_expr_for_function PROTO((void));\n+\n /* Use protect_from_queue to convert a QUEUED expression\n    into something that you can put immediately into an instruction.  */\n extern rtx protect_from_queue PROTO((rtx, int));"}, {"sha": "a6dc137e61bad3128420cfe0545ac2d44e341d72", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -62,6 +62,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"defaults.h\"\n #include \"output.h\"\n #include \"except.h\"\n+#include \"function.h\"\n #include \"toplev.h\"\n #include \"reload.h\"\n #include \"intl.h\""}, {"sha": "6f2f93fda75a376dfaa05bca1804d64238129b9d", "filename": "gcc/flags.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -485,23 +485,6 @@ extern int frame_pointer_needed;\n \n extern int can_reach_end;\n \n-/* Nonzero if function being compiled receives nonlocal gotos\n-   from nested functions.  */\n-\n-extern int current_function_has_nonlocal_label;\n-\n-/* Nonzero if function being compiled has nonlocal gotos to parent\n-   function.  */\n-\n-extern int current_function_has_nonlocal_goto;\n-\n-/* Nonzero if this function has a computed goto.\n-\n-   It is computed during find_basic_blocks or during stupid life\n-   analysis.  */\n-\n-extern int current_function_has_computed_jump;\n-\n /* Nonzero if GCC must add code to check memory access (used by Checker).  */\n \n extern int flag_check_memory_usage;\n@@ -510,9 +493,6 @@ extern int flag_check_memory_usage;\n    flag_check_memory_usage).  */\n \n extern int flag_prefix_function_name;\n-/* Nonzero if the current function is a thunk, so we should try to cut\n-   corners where we can.  */\n-extern int current_function_is_thunk;\n \n /* Value of the -G xx switch, and whether it was passed or not.  */\n extern int g_switch_value;"}, {"sha": "47f037c3d50521c8ba758dda739d8538d7128505", "filename": "gcc/flow.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -154,9 +154,6 @@ Boston, MA 02111-1307, USA.  */\n \n extern struct obstack *function_obstack;\n \n-/* List of labels that must never be deleted.  */\n-extern rtx forced_labels;\n-\n /* Number of basic blocks in the current function.  */\n \n int n_basic_blocks;"}, {"sha": "c30c0d113c6a366ba64169cbebe155b267463973", "filename": "gcc/function.c", "status": "modified", "additions": 60, "deletions": 396, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -94,266 +94,22 @@ Boston, MA 02111-1307, USA.  */\n #define NEED_SEPARATE_AP\n #endif\n \n-/* Number of bytes of args popped by function being compiled on its return.\n-   Zero if no bytes are to be popped.\n-   May affect compilation of return insn or of function epilogue.  */\n-\n-int current_function_pops_args;\n-\n-/* Nonzero if function being compiled needs to be given an address\n-   where the value should be stored.  */\n-\n-int current_function_returns_struct;\n-\n-/* Nonzero if function being compiled needs to\n-   return the address of where it has put a structure value.  */\n-\n-int current_function_returns_pcc_struct;\n-\n-/* Nonzero if function being compiled needs to be passed a static chain.  */\n-\n-int current_function_needs_context;\n-\n-/* Nonzero if function being compiled can call setjmp.  */\n-\n-int current_function_calls_setjmp;\n-\n-/* Nonzero if function being compiled can call longjmp.  */\n-\n-int current_function_calls_longjmp;\n-\n-/* Nonzero if function being compiled receives nonlocal gotos\n-   from nested functions.  */\n-\n-int current_function_has_nonlocal_label;\n-\n-/* Nonzero if function being compiled has nonlocal gotos to parent\n-   function.  */\n-\n-int current_function_has_nonlocal_goto;\n-\n-/* Nonzero if function being compiled contains nested functions.  */\n-\n-int current_function_contains_functions;\n-\n /* Nonzero if function being compiled doesn't contain any calls\n    (ignoring the prologue and epilogue).  This is set prior to\n    local register allocation and is valid for the remaining\n    compiler passes. */\n-\n int current_function_is_leaf;\n \n /* Nonzero if function being compiled doesn't modify the stack pointer\n    (ignoring the prologue and epilogue).  This is only valid after\n    life_analysis has run. */\n-\n int current_function_sp_is_unchanging;\n \n /* Nonzero if the function being compiled is a leaf function which only\n    uses leaf registers.  This is valid after reload (specifically after\n    sched2) and is useful only if the port defines LEAF_REGISTERS.  */\n-\n int current_function_uses_only_leaf_regs;\n \n-/* Nonzero if the function being compiled issues a computed jump.  */\n-\n-int current_function_has_computed_jump;\n-\n-/* Nonzero if the current function is a thunk (a lightweight function that\n-   just adjusts one of its arguments and forwards to another function), so\n-   we should try to cut corners where we can.  */\n-int current_function_is_thunk;\n-\n-/* Nonzero if function being compiled can call alloca,\n-   either as a subroutine or builtin.  */\n-\n-int current_function_calls_alloca;\n-\n-/* Nonzero if the current function returns a pointer type */\n-\n-int current_function_returns_pointer;\n-\n-/* If some insns can be deferred to the delay slots of the epilogue, the\n-   delay list for them is recorded here.  */\n-\n-rtx current_function_epilogue_delay_list;\n-\n-/* If function's args have a fixed size, this is that size, in bytes.\n-   Otherwise, it is -1.\n-   May affect compilation of return insn or of function epilogue.  */\n-\n-int current_function_args_size;\n-\n-/* # bytes the prologue should push and pretend that the caller pushed them.\n-   The prologue must do this, but only if parms can be passed in registers.  */\n-\n-int current_function_pretend_args_size;\n-\n-/* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is\n-   defined, the needed space is pushed by the prologue.  */\n-\n-int current_function_outgoing_args_size;\n-\n-/* This is the offset from the arg pointer to the place where the first\n-   anonymous arg can be found, if there is one.  */\n-\n-rtx current_function_arg_offset_rtx;\n-\n-/* Nonzero if current function uses varargs.h or equivalent.\n-   Zero for functions that use stdarg.h.  */\n-\n-int current_function_varargs;\n-\n-/* Nonzero if current function uses stdarg.h or equivalent.\n-   Zero for functions that use varargs.h.  */\n-\n-int current_function_stdarg;\n-\n-/* Quantities of various kinds of registers\n-   used for the current function's args.  */\n-\n-CUMULATIVE_ARGS current_function_args_info;\n-\n-/* Name of function now being compiled.  */\n-\n-char *current_function_name;\n-\n-/* If non-zero, an RTL expression for the location at which the current \n-   function returns its result.  If the current function returns its\n-   result in a register, current_function_return_rtx will always be\n-   the hard register containing the result.  */\n-\n-rtx current_function_return_rtx;\n-\n-/* Nonzero if the current function uses the constant pool.  */\n-\n-int current_function_uses_const_pool;\n-\n-/* Nonzero if the current function uses pic_offset_table_rtx.  */\n-int current_function_uses_pic_offset_table;\n-\n-/* The arg pointer hard register, or the pseudo into which it was copied.  */\n-rtx current_function_internal_arg_pointer;\n-\n-/* Language-specific reason why the current function cannot be made inline.  */\n-char *current_function_cannot_inline;\n-\n-/* Nonzero if instrumentation calls for function entry and exit should be\n-   generated.  */\n-int current_function_instrument_entry_exit;\n-\n-/* Nonzero if memory access checking be enabled in the current function.  */\n-int current_function_check_memory_usage;\n-\n-/* The FUNCTION_DECL for an inline function currently being expanded.  */\n-tree inline_function_decl;\n-\n-/* Number of function calls seen so far in current function.  */\n-\n-int function_call_count;\n-\n-/* List (chain of TREE_LIST) of LABEL_DECLs for all nonlocal labels\n-   (labels to which there can be nonlocal gotos from nested functions)\n-   in this function.  */\n-\n-tree nonlocal_labels;\n-\n-/* List (chain of EXPR_LIST) of stack slots that hold the current handlers\n-   for nonlocal gotos.  There is one for every nonlocal label in the function;\n-   this list matches the one in nonlocal_labels.\n-   Zero when function does not have nonlocal labels.  */\n-\n-rtx nonlocal_goto_handler_slots;\n-\n-/* List (chain of EXPR_LIST) of labels heading the current handlers for\n-   nonlocal gotos.  */\n-\n-rtx nonlocal_goto_handler_labels;\n-\n-/* RTX for stack slot that holds the stack pointer value to restore\n-   for a nonlocal goto.\n-   Zero when function does not have nonlocal labels.  */\n-\n-rtx nonlocal_goto_stack_level;\n-\n-/* Label that will go on parm cleanup code, if any.\n-   Jumping to this label runs cleanup code for parameters, if\n-   such code must be run.  Following this code is the logical return label.  */\n-\n-rtx cleanup_label;\n-\n-/* Label that will go on function epilogue.\n-   Jumping to this label serves as a \"return\" instruction\n-   on machines which require execution of the epilogue on all returns.  */\n-\n-rtx return_label;\n-\n-/* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.\n-   So we can mark them all live at the end of the function, if nonopt.  */\n-rtx save_expr_regs;\n-\n-/* List (chain of EXPR_LISTs) of all stack slots in this function.\n-   Made for the sake of unshare_all_rtl.  */\n-rtx stack_slot_list;\n-\n-/* Chain of all RTL_EXPRs that have insns in them.  */\n-tree rtl_expr_chain;\n-\n-/* Label to jump back to for tail recursion, or 0 if we have\n-   not yet needed one for this function.  */\n-rtx tail_recursion_label;\n-\n-/* Place after which to insert the tail_recursion_label if we need one.  */\n-rtx tail_recursion_reentry;\n-\n-/* Location at which to save the argument pointer if it will need to be\n-   referenced.  There are two cases where this is done: if nonlocal gotos\n-   exist, or if vars stored at an offset from the argument pointer will be\n-   needed by inner routines.  */\n-\n-rtx arg_pointer_save_area;\n-\n-/* Offset to end of allocated area of stack frame.\n-   If stack grows down, this is the address of the last stack slot allocated.\n-   If stack grows up, this is the address for the next slot.  */\n-HOST_WIDE_INT frame_offset;\n-\n-/* List (chain of TREE_LISTs) of static chains for containing functions.\n-   Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx\n-   in an RTL_EXPR in the TREE_VALUE.  */\n-static tree context_display;\n-\n-/* List (chain of TREE_LISTs) of trampolines for nested functions.\n-   The trampoline sets up the static chain and jumps to the function.\n-   We supply the trampoline's address when the function's address is requested.\n-\n-   Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx\n-   in an RTL_EXPR in the TREE_VALUE.  */\n-static tree trampoline_list;\n-\n-/* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */\n-static rtx parm_birth_insn;\n-\n-#if 0\n-/* Nonzero if a stack slot has been generated whose address is not\n-   actually valid.  It means that the generated rtl must all be scanned\n-   to detect and correct the invalid addresses where they occur.  */\n-static int invalid_stack_slot;\n-#endif\n-\n-/* Last insn of those whose job was to put parms into their nominal homes.  */\n-static rtx last_parm_insn;\n-\n-/* 1 + last pseudo register number possibly used for loading a copy\n-   of a parameter of this function. */\n-int max_parm_reg;\n-\n-/* Vector indexed by REGNO, containing location on stack in which\n-   to put the parm which is nominally in pseudo register REGNO,\n-   if we discover that that parm must go in the stack.  The highest\n-   element in this vector is one less than MAX_PARM_REG, above.  */\n-rtx *parm_reg_stack_loc;\n-\n /* Nonzero once virtual register instantiation has been done.\n    assign_stack_local uses frame_pointer_rtx when this is nonzero.  */\n static int virtuals_instantiated;\n@@ -369,7 +125,9 @@ void (*restore_machine_status) PROTO((struct function *));\n    integrate.c  */\n \n extern int rtx_equal_function_value_matters;\n-extern tree sequence_rtl_expr;\n+\n+/* The FUNCTION_DECL for an inline function currently being expanded.  */\n+tree inline_function_decl;\n \n /* The currently compiled function.  */\n struct function *current_function = 0;\n@@ -440,24 +198,6 @@ struct temp_slot\n      info is for combine_temp_slots.  */\n   HOST_WIDE_INT full_size;\n };\n-\n-/* List of all temporaries allocated, both available and in use.  */\n-\n-struct temp_slot *temp_slots;\n-\n-/* Current nesting level for temporaries.  */\n-\n-int temp_slot_level;\n-\n-/* Current nesting level for variables in a block.  */\n-\n-int var_temp_slot_level;\n-\n-/* When temporaries are created by TARGET_EXPRs, they are created at\n-   this level of temp_slot_level, so that they can remain allocated\n-   until no longer needed.  CLEANUP_POINT_EXPRs define the lifetime\n-   of TARGET_EXPRs.  */\n-int target_temp_slot_level;\n \f\n /* This structure is used to record MEMs or pseudos used to replace VAR, any\n    SUBREGs of VAR, and any MEMs containing VAR as an address.  We need to\n@@ -569,67 +309,10 @@ push_function_context_to (context)\n \n   p->next = outer_function_chain;\n   outer_function_chain = p;\n-\n-  p->name = current_function_name;\n   p->decl = current_function_decl;\n-  p->pops_args = current_function_pops_args;\n-  p->returns_struct = current_function_returns_struct;\n-  p->returns_pcc_struct = current_function_returns_pcc_struct;\n-  p->returns_pointer = current_function_returns_pointer;\n-  p->needs_context = current_function_needs_context;\n-  p->calls_setjmp = current_function_calls_setjmp;\n-  p->calls_longjmp = current_function_calls_longjmp;\n-  p->calls_alloca = current_function_calls_alloca;\n-  p->has_nonlocal_label = current_function_has_nonlocal_label;\n-  p->has_nonlocal_goto = current_function_has_nonlocal_goto;\n-  p->contains_functions = current_function_contains_functions;\n-  p->has_computed_jump = current_function_has_computed_jump;\n-  p->is_thunk = current_function_is_thunk;\n-  p->args_size = current_function_args_size;\n-  p->pretend_args_size = current_function_pretend_args_size;\n-  p->arg_offset_rtx = current_function_arg_offset_rtx;\n-  p->varargs = current_function_varargs;\n-  p->stdarg = current_function_stdarg;\n-  p->uses_const_pool = current_function_uses_const_pool;\n-  p->uses_pic_offset_table = current_function_uses_pic_offset_table;\n-  p->internal_arg_pointer = current_function_internal_arg_pointer;\n-  p->cannot_inline = current_function_cannot_inline;\n-  p->max_parm_reg = max_parm_reg;\n-  p->parm_reg_stack_loc = parm_reg_stack_loc;\n-  p->outgoing_args_size = current_function_outgoing_args_size;\n-  p->return_rtx = current_function_return_rtx;\n-  p->nonlocal_goto_handler_slots = nonlocal_goto_handler_slots;\n-  p->nonlocal_goto_handler_labels = nonlocal_goto_handler_labels;\n-  p->nonlocal_goto_stack_level = nonlocal_goto_stack_level;\n-  p->nonlocal_labels = nonlocal_labels;\n-  p->cleanup_label = cleanup_label;\n-  p->return_label = return_label;\n-  p->save_expr_regs = save_expr_regs;\n-  p->stack_slot_list = stack_slot_list;\n-  p->parm_birth_insn = parm_birth_insn;\n-  p->frame_offset = frame_offset;\n-  p->tail_recursion_label = tail_recursion_label;\n-  p->tail_recursion_reentry = tail_recursion_reentry;\n-  p->arg_pointer_save_area = arg_pointer_save_area;\n-  p->rtl_expr_chain = rtl_expr_chain;\n-  p->last_parm_insn = last_parm_insn;\n-  p->context_display = context_display;\n-  p->trampoline_list = trampoline_list;\n-  p->function_call_count = function_call_count;\n-  p->temp_slots = temp_slots;\n-  p->temp_slot_level = temp_slot_level;\n-  p->target_temp_slot_level = target_temp_slot_level;\n-  p->var_temp_slot_level = var_temp_slot_level;\n   p->fixup_var_refs_queue = 0;\n-  p->epilogue_delay_list = current_function_epilogue_delay_list;\n-  p->args_info = current_function_args_info;\n-  p->check_memory_usage = current_function_check_memory_usage;\n-  p->instrument_entry_exit = current_function_instrument_entry_exit;\n \n   save_tree_status (p, context);\n-  save_storage_status (p);\n-  save_emit_status (p);\n-  save_expr_status (p);\n   save_varasm_status (p, context);\n   if (save_machine_status)\n     (*save_machine_status) (p);\n@@ -657,66 +340,11 @@ pop_function_context_from (context)\n   outer_function_chain = p->next;\n \n   current_function_contains_functions\n-    = p->contains_functions || p->inline_obstacks\n-      || context == current_function_decl;\n-  current_function_has_computed_jump = p->has_computed_jump;\n-  current_function_name = p->name;\n+    |= p->inline_obstacks || context == current_function_decl;\n   current_function_decl = p->decl;\n-  current_function_pops_args = p->pops_args;\n-  current_function_returns_struct = p->returns_struct;\n-  current_function_returns_pcc_struct = p->returns_pcc_struct;\n-  current_function_returns_pointer = p->returns_pointer;\n-  current_function_needs_context = p->needs_context;\n-  current_function_calls_setjmp = p->calls_setjmp;\n-  current_function_calls_longjmp = p->calls_longjmp;\n-  current_function_calls_alloca = p->calls_alloca;\n-  current_function_has_nonlocal_label = p->has_nonlocal_label;\n-  current_function_has_nonlocal_goto = p->has_nonlocal_goto;\n-  current_function_is_thunk = p->is_thunk;\n-  current_function_args_size = p->args_size;\n-  current_function_pretend_args_size = p->pretend_args_size;\n-  current_function_arg_offset_rtx = p->arg_offset_rtx;\n-  current_function_varargs = p->varargs;\n-  current_function_stdarg = p->stdarg;\n-  current_function_uses_const_pool = p->uses_const_pool;\n-  current_function_uses_pic_offset_table = p->uses_pic_offset_table;\n-  current_function_internal_arg_pointer = p->internal_arg_pointer;\n-  current_function_cannot_inline = p->cannot_inline;\n-  max_parm_reg = p->max_parm_reg;\n-  parm_reg_stack_loc = p->parm_reg_stack_loc;\n-  current_function_outgoing_args_size = p->outgoing_args_size;\n-  current_function_return_rtx = p->return_rtx;\n-  nonlocal_goto_handler_slots = p->nonlocal_goto_handler_slots;\n-  nonlocal_goto_handler_labels = p->nonlocal_goto_handler_labels;\n-  nonlocal_goto_stack_level = p->nonlocal_goto_stack_level;\n-  nonlocal_labels = p->nonlocal_labels;\n-  cleanup_label = p->cleanup_label;\n-  return_label = p->return_label;\n-  save_expr_regs = p->save_expr_regs;\n-  stack_slot_list = p->stack_slot_list;\n-  parm_birth_insn = p->parm_birth_insn;\n-  frame_offset = p->frame_offset;\n-  tail_recursion_label = p->tail_recursion_label;\n-  tail_recursion_reentry = p->tail_recursion_reentry;\n-  arg_pointer_save_area = p->arg_pointer_save_area;\n-  rtl_expr_chain = p->rtl_expr_chain;\n-  last_parm_insn = p->last_parm_insn;\n-  context_display = p->context_display;\n-  trampoline_list = p->trampoline_list;\n-  function_call_count = p->function_call_count;\n-  temp_slots = p->temp_slots;\n-  temp_slot_level = p->temp_slot_level;\n-  target_temp_slot_level = p->target_temp_slot_level;\n-  var_temp_slot_level = p->var_temp_slot_level;\n-  current_function_epilogue_delay_list = p->epilogue_delay_list;\n   reg_renumber = 0;\n-  current_function_args_info = p->args_info;\n-  current_function_check_memory_usage = p->check_memory_usage;\n-  current_function_instrument_entry_exit = p->instrument_entry_exit;\n \n   restore_tree_status (p, context);\n-  restore_storage_status (p);\n-  restore_expr_status (p);\n   restore_emit_status (p);\n   restore_varasm_status (p);\n \n@@ -741,20 +369,31 @@ void pop_function_context ()\n \f\n /* Allocate fixed slots in the stack frame of the current function.  */\n \n-/* Return size needed for stack frame based on slots so far allocated.\n+/* Return size needed for stack frame based on slots so far allocated in\n+   function F.\n    This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;\n    the caller may have to do that.  */\n \n HOST_WIDE_INT\n-get_frame_size ()\n+get_func_frame_size (f)\n+     struct function *f;\n {\n #ifdef FRAME_GROWS_DOWNWARD\n-  return -frame_offset;\n+  return -f->x_frame_offset;\n #else\n-  return frame_offset;\n+  return f->x_frame_offset;\n #endif\n }\n \n+/* Return size needed for stack frame based on slots so far allocated.\n+   This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;\n+   the caller may have to do that.  */\n+HOST_WIDE_INT\n+get_frame_size ()\n+{\n+  return get_func_frame_size (current_function);\n+}\n+\n /* Allocate a stack slot of SIZE bytes and return a MEM rtx for it\n    with machine mode MODE.\n    \n@@ -885,14 +524,14 @@ assign_outer_stack_local (mode, size, align, function)\n     alignment = align / BITS_PER_UNIT;\n \n #ifdef FRAME_GROWS_DOWNWARD\n-  function->frame_offset -= size;\n+  function->x_frame_offset -= size;\n #endif\n \n   /* Round frame offset to that alignment.  */\n #ifdef FRAME_GROWS_DOWNWARD\n-  function->frame_offset = FLOOR_ROUND (function->frame_offset, alignment);\n+  function->x_frame_offset = FLOOR_ROUND (function->x_frame_offset, alignment);\n #else\n-  function->frame_offset = CEIL_ROUND (function->frame_offset, alignment);\n+  function->x_frame_offset = CEIL_ROUND (function->x_frame_offset, alignment);\n #endif\n \n   /* On a big-endian machine, if we are allocating more space than we will use,\n@@ -901,15 +540,15 @@ assign_outer_stack_local (mode, size, align, function)\n     bigend_correction = size - GET_MODE_SIZE (mode);\n \n   addr = plus_constant (virtual_stack_vars_rtx,\n-\t\t\tfunction->frame_offset + bigend_correction);\n+\t\t\tfunction->x_frame_offset + bigend_correction);\n #ifndef FRAME_GROWS_DOWNWARD\n-  function->frame_offset += size;\n+  function->x_frame_offset += size;\n #endif\n \n   x = gen_rtx_MEM (mode, addr);\n \n-  function->stack_slot_list\n-    = gen_rtx_EXPR_LIST (VOIDmode, x, function->stack_slot_list);\n+  function->x_stack_slot_list\n+    = gen_rtx_EXPR_LIST (VOIDmode, x, function->x_stack_slot_list);\n \n   pop_obstacks ();\n \n@@ -1079,7 +718,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n \n   p->in_use = 1;\n   p->addr_taken = 0;\n-  p->rtl_expr = sequence_rtl_expr;\n+  p->rtl_expr = seq_rtl_expr;\n \n   if (keep == 2)\n     {\n@@ -1693,8 +1332,8 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n \n   if (function)\n     {\n-      if (regno < function->max_parm_reg)\n-\tnew = function->parm_reg_stack_loc[regno];\n+      if (regno < function->x_max_parm_reg)\n+\tnew = function->x_parm_reg_stack_loc[regno];\n       if (new == 0)\n \tnew = assign_outer_stack_local (decl_mode, GET_MODE_SIZE (decl_mode),\n \t\t\t\t\t0, function);\n@@ -1758,7 +1397,7 @@ fixup_var_refs (var, promoted_mode, unsignedp, ht)\n {\n   tree pending;\n   rtx first_insn = get_insns ();\n-  struct sequence_stack *stack = sequence_stack;\n+  struct sequence_stack *stack = seq_stack;\n   tree rtl_exps = rtl_expr_chain;\n \n   /* Must scan all insns for stack-refs that exceed the limit.  */\n@@ -5584,11 +5223,11 @@ fix_lexical_addr (addr, var)\n #ifdef NEED_SEPARATE_AP\n       rtx addr;\n \n-      if (fp->arg_pointer_save_area == 0)\n-\tfp->arg_pointer_save_area\n+      if (fp->x_arg_pointer_save_area == 0)\n+\tfp->x_arg_pointer_save_area\n \t  = assign_outer_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0, fp);\n \n-      addr = fix_lexical_addr (XEXP (fp->arg_pointer_save_area, 0), var);\n+      addr = fix_lexical_addr (XEXP (fp->x_arg_pointer_save_area, 0), var);\n       addr = memory_address (Pmode, addr);\n \n       base = copy_to_reg (gen_rtx_MEM (Pmode, addr));\n@@ -5641,7 +5280,7 @@ trampoline_address (function)\n \tround_trampoline_addr (XEXP (RTL_EXPR_RTL (TREE_VALUE (link)), 0));\n \n   for (fp = outer_function_chain; fp; fp = fp->next)\n-    for (link = fp->trampoline_list; link; link = TREE_CHAIN (link))\n+    for (link = fp->x_trampoline_list; link; link = TREE_CHAIN (link))\n       if (TREE_PURPOSE (link) == function)\n \t{\n \t  tramp = fix_lexical_addr (XEXP (RTL_EXPR_RTL (TREE_VALUE (link)), 0),\n@@ -5687,7 +5326,8 @@ trampoline_address (function)\n \t\t     fp->function_maybepermanent_obstack);\n       rtlexp = make_node (RTL_EXPR);\n       RTL_EXPR_RTL (rtlexp) = tramp;\n-      fp->trampoline_list = tree_cons (function, rtlexp, fp->trampoline_list);\n+      fp->x_trampoline_list = tree_cons (function, rtlexp,\n+\t\t\t\t\t fp->x_trampoline_list);\n       pop_obstacks ();\n     }\n   else\n@@ -5949,6 +5589,8 @@ prepare_function_start ()\n   current_function_uses_pic_offset_table = 0;\n   current_function_cannot_inline = 0;\n \n+  current_function->inlinable = 0;\n+\n   /* We have not yet needed to make a label to jump to for tail-recursion.  */\n   tail_recursion_label = 0;\n \n@@ -6054,7 +5696,14 @@ init_function_start (subr, filename, line)\n \n   current_function_returns_pointer\n     = POINTER_TYPE_P (TREE_TYPE (DECL_RESULT (subr)));\n+}\n \n+/* Make sure all values used by the optimization passes have sane\n+   defaults.  */\n+void\n+init_function_for_compilation ()\n+{\n+  reg_renumber = 0;\n   /* No prologue/epilogue insns yet.  */\n   prologue = epilogue = 0;\n }\n@@ -6343,6 +5992,19 @@ expand_function_start (subr, parms_have_cleanups)\n   force_next_line_note ();\n }\n \f\n+/* Undo the effects of init_dummy_function_start.  */\n+void\n+expand_dummy_function_end ()\n+{\n+  /* End any sequences that failed to be closed due to syntax errors.  */\n+  while (in_sequence_p ())\n+    end_sequence ();\n+\n+  /* Outside function body, can't compute type's actual size\n+     until next function's body starts.  */\n+  current_function = 0;\n+}\n+\n /* Generate RTL for the end of the current function.\n    FILENAME and LINE are the current position in the source file. \n \n@@ -6362,6 +6024,8 @@ expand_function_end (filename, line, end_bindings)\n   static rtx initial_trampoline;\n #endif\n \n+  finish_expr_for_function ();\n+\n #ifdef NON_SAVING_SETJMP\n   /* Don't put any variables in registers if we call setjmp\n      on a machine that fails to restore the registers.  */"}, {"sha": "49cbe59f05f4d3d6cf4b5fbada4acb63f1f92c4a", "filename": "gcc/function.h", "status": "modified", "additions": 382, "deletions": 102, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -59,6 +59,117 @@ struct simple_obstack_stack\n   struct simple_obstack_stack *next;\n };\n \f\n+struct emit_status\n+{\n+  /* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.\n+     After rtl generation, it is 1 plus the largest register number used.  */\n+  int x_reg_rtx_no;\n+\n+  /* Lowest label number in current function.  */\n+  int x_first_label_num;\n+\n+  /* The ends of the doubly-linked chain of rtl for the current function.\n+     Both are reset to null at the start of rtl generation for the function.\n+   \n+     start_sequence saves both of these on `sequence_stack' along with\n+     `sequence_rtl_expr' and then starts a new, nested sequence of insns.  */\n+  rtx x_first_insn;\n+  rtx x_last_insn;\n+\n+  /* RTL_EXPR within which the current sequence will be placed.  Use to\n+     prevent reuse of any temporaries within the sequence until after the\n+     RTL_EXPR is emitted.  */\n+  tree sequence_rtl_expr;\n+\n+  /* Stack of pending (incomplete) sequences saved by `start_sequence'.\n+     Each element describes one pending sequence.\n+     The main insn-chain is saved in the last element of the chain,\n+     unless the chain is empty.  */\n+  struct sequence_stack *sequence_stack;\n+\n+  /* INSN_UID for next insn emitted.\n+     Reset to 1 for each function compiled.  */\n+  int x_cur_insn_uid;\n+\n+  /* Line number and source file of the last line-number NOTE emitted.\n+     This is used to avoid generating duplicates.  */\n+  int x_last_linenum;\n+  char *x_last_filename;\n+\n+  /* A vector indexed by pseudo reg number.  The allocated length\n+     of this vector is regno_pointer_flag_length.  Since this\n+     vector is needed during the expansion phase when the total\n+     number of registers in the function is not yet known,\n+     it is copied and made bigger when necessary.  */\n+  char *regno_pointer_flag;\n+  int regno_pointer_flag_length;\n+\n+  /* Indexed by pseudo register number, if nonzero gives the known alignment\n+     for that pseudo (if regno_pointer_flag is set).\n+     Allocated in parallel with regno_pointer_flag.  */\n+  char *regno_pointer_align;\n+\n+  /* Indexed by pseudo register number, gives the rtx for that pseudo.\n+     Allocated in parallel with regno_pointer_flag.  */\n+  rtx *x_regno_reg_rtx;\n+};\n+\n+/* For backward compatibility... eventually these should all go away.  */\n+#define reg_rtx_no (current_function->emit->x_reg_rtx_no)\n+#define seq_rtl_expr (current_function->emit->sequence_rtl_expr)\n+#define regno_reg_rtx (current_function->emit->x_regno_reg_rtx)\n+#define seq_stack (current_function->emit->sequence_stack)\n+\n+#define REGNO_POINTER_ALIGN(REGNO) \\\n+  (current_function->emit->regno_pointer_align[REGNO])\n+#define REGNO_POINTER_FLAG(REGNO) \\\n+  (current_function->emit->regno_pointer_flag[REGNO])\n+\n+struct expr_status\n+{\n+  /* Number of units that we should eventually pop off the stack.\n+     These are the arguments to function calls that have already returned.  */\n+  int x_pending_stack_adjust;\n+\n+  /* Under some ABIs, it is the caller's responsibility to pop arguments\n+     pushed for function calls.  A naive implementation would simply pop\n+     the arguments immediately after each call.  However, if several\n+     function calls are made in a row, it is typically cheaper to pop\n+     all the arguments after all of the calls are complete since a\n+     single pop instruction can be used.  Therefore, GCC attempts to\n+     defer popping the arguments until absolutely necessary.  (For\n+     example, at the end of a conditional, the arguments must be popped,\n+     since code outside the conditional won't know whether or not the\n+     arguments need to be popped.)\n+\n+     When INHIBIT_DEFER_POP is non-zero, however, the compiler does not\n+     attempt to defer pops.  Instead, the stack is popped immediately\n+     after each call.  Rather then setting this variable directly, use\n+     NO_DEFER_POP and OK_DEFER_POP.  */\n+  int x_inhibit_defer_pop;\n+\n+  /* Nonzero means __builtin_saveregs has already been done in this function.\n+     The value is the pseudoreg containing the value __builtin_saveregs\n+     returned.  */\n+  rtx x_saveregs_value;\n+\n+  /* Similarly for __builtin_apply_args.  */\n+  rtx x_apply_args_value;\n+\n+  /* List of labels that must never be deleted.  */\n+  rtx x_forced_labels;\n+\n+  /* Postincrements that still need to be expanded.  */\n+  rtx x_pending_chain;\n+};\n+\n+#define pending_stack_adjust (current_function->expr->x_pending_stack_adjust)\n+#define inhibit_defer_pop (current_function->expr->x_inhibit_defer_pop)\n+#define saveregs_value (current_function->expr->x_saveregs_value)\n+#define apply_args_value (current_function->expr->x_apply_args_value)\n+#define forced_labels (current_function->expr->x_forced_labels)\n+#define pending_chain (current_function->expr->x_pending_chain)\n+\n /* This structure can save all the important global and static variables\n    describing the status of the current function.  */\n \n@@ -69,93 +180,227 @@ struct function\n \n   struct eh_status *eh;\n   struct stmt_status *stmt;\n+  struct expr_status *expr;\n+  struct emit_status *emit;\n \n   /* For function.c.  */\n+\n+  /* Name of this function.  */\n   char *name;\n+  /* Points to the FUNCTION_DECL of this function. */\n   tree decl;\n+\n+  /* Number of bytes of args popped by function being compiled on its return.\n+     Zero if no bytes are to be popped.\n+     May affect compilation of return insn or of function epilogue.  */\n   int pops_args;\n+\n+  /* Nonzero if function being compiled needs to be given an address\n+     where the value should be stored.  */\n   int returns_struct;\n+\n+  /* Nonzero if function being compiled needs to\n+     return the address of where it has put a structure value.  */\n   int returns_pcc_struct;\n+  \n+  /* Nonzero if the current function returns a pointer type.  */\n   int returns_pointer;\n+\n+  /* Nonzero if function being compiled needs to be passed a static chain.  */\n   int needs_context;\n+\n+  /* Nonzero if function being compiled can call setjmp.  */\n   int calls_setjmp;\n+\n+  /* Nonzero if function being compiled can call longjmp.  */\n   int calls_longjmp;\n+  \n+  /* Nonzero if function being compiled can call alloca,\n+     either as a subroutine or builtin.  */\n   int calls_alloca;\n+\n+  /* Nonzero if function being compiled receives nonlocal gotos\n+     from nested functions.  */\n+\n   int has_nonlocal_label;\n+\n+  /* Nonzero if function being compiled has nonlocal gotos to parent\n+     function.  */\n   int has_nonlocal_goto;\n+\n+  /* Nonzero if function being compiled contains nested functions.  */\n   int contains_functions;\n+\n+  /* Nonzero if the function being compiled issues a computed jump.  */\n   int has_computed_jump;\n+\n+  /* Nonzero if the current function is a thunk (a lightweight function that\n+     just adjusts one of its arguments and forwards to another function), so\n+     we should try to cut corners where we can.  */\n   int is_thunk;\n-  rtx nonlocal_goto_handler_slots;\n-  rtx nonlocal_goto_handler_labels;\n-  rtx nonlocal_goto_stack_level;\n-  tree nonlocal_labels;\n+\n+  /* If function's args have a fixed size, this is that size, in bytes.\n+     Otherwise, it is -1.\n+     May affect compilation of return insn or of function epilogue.  */\n   int args_size;\n+\n+  /* # bytes the prologue should push and pretend that the caller pushed them.\n+     The prologue must do this, but only if parms can be passed in\n+     registers.  */\n   int pretend_args_size;\n+\n+  /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is\n+     defined, the needed space is pushed by the prologue.  */\n+  int outgoing_args_size;\n+\n+  /* This is the offset from the arg pointer to the place where the first\n+     anonymous arg can be found, if there is one.  */\n   rtx arg_offset_rtx;\n+\n+  /* Nonzero if current function uses varargs.h or equivalent.\n+     Zero for functions that use stdarg.h.  */\n   int varargs;\n+\n+  /* Nonzero if current function uses stdarg.h or equivalent.\n+     Zero for functions that use varargs.h.  */\n   int stdarg;\n-  int max_parm_reg;\n-  rtx *parm_reg_stack_loc;\n-  int outgoing_args_size;\n+\n+  /* Quantities of various kinds of registers\n+     used for the current function's args.  */\n+  CUMULATIVE_ARGS args_info;\n+\n+  /* If non-zero, an RTL expression for the location at which the current \n+     function returns its result.  If the current function returns its\n+     result in a register, current_function_return_rtx will always be\n+     the hard register containing the result.  */\n   rtx return_rtx;\n-  rtx cleanup_label;\n-  rtx return_label;\n-  rtx save_expr_regs;\n-  rtx stack_slot_list;\n-  rtx parm_birth_insn;\n-  HOST_WIDE_INT frame_offset;\n-  rtx tail_recursion_label;\n-  rtx tail_recursion_reentry;\n+\n+  /* The arg pointer hard register, or the pseudo into which it was copied.  */\n   rtx internal_arg_pointer;\n+\n+  /* Language-specific reason why the current function cannot be made\n+     inline.  */\n   char *cannot_inline;\n-  rtx arg_pointer_save_area;\n-  tree rtl_expr_chain;\n-  rtx last_parm_insn;\n-  tree context_display;\n-  tree trampoline_list;\n-  int function_call_count;\n-  struct temp_slot *temp_slots;\n-  int temp_slot_level;\n-  int target_temp_slot_level;\n-  int var_temp_slot_level;\n+\n+  /* Nonzero if instrumentation calls for function entry and exit should be\n+     generated.  */\n   int instrument_entry_exit;\n-  /* This slot is initialized as 0 and is added to\n-     during the nested function.  */\n-  struct var_refs_queue *fixup_var_refs_queue;\n-  CUMULATIVE_ARGS args_info;\n \n-  /* For expr.c.  */\n-  rtx pending_chain;\n-  int pending_stack_adjust;\n-  int inhibit_defer_pop;\n-  rtx saveregs_value;\n-  rtx apply_args_value;\n-  rtx forced_labels;\n+  /* Nonzero if memory access checking be enabled in the current function.  */\n   int check_memory_usage;\n \n-  /* For emit-rtl.c.  */\n-  int reg_rtx_no;\n-  int first_label_num;\n-  rtx first_insn;\n-  rtx last_insn;\n-  tree sequence_rtl_expr;\n-  struct sequence_stack *sequence_stack;\n-  int cur_insn_uid;\n-  int last_linenum;\n-  char *last_filename;\n-  char *regno_pointer_flag;\n-  char *regno_pointer_align;\n-  int regno_pointer_flag_length;\n-  rtx *regno_reg_rtx;\n-\n-  /* For stor-layout.c.  */\n-  tree permanent_type_chain;\n-  tree temporary_type_chain;\n-  tree permanent_type_end;\n-  tree temporary_type_end;\n-  tree pending_sizes;\n-  int immediate_size_expand;\n+  /* Number of function calls seen so far in current function.  */\n+  int x_function_call_count;\n+\n+  /* List (chain of TREE_LIST) of LABEL_DECLs for all nonlocal labels\n+     (labels to which there can be nonlocal gotos from nested functions)\n+     in this function.  */\n+  tree x_nonlocal_labels;\n+\n+  /* List (chain of EXPR_LIST) of stack slots that hold the current handlers\n+     for nonlocal gotos.  There is one for every nonlocal label in the\n+     function; this list matches the one in nonlocal_labels.\n+     Zero when function does not have nonlocal labels.  */\n+  rtx x_nonlocal_goto_handler_slots;\n+\n+  /* List (chain of EXPR_LIST) of labels heading the current handlers for\n+     nonlocal gotos.  */\n+  rtx x_nonlocal_goto_handler_labels;\n+\n+  /* RTX for stack slot that holds the stack pointer value to restore\n+     for a nonlocal goto.\n+     Zero when function does not have nonlocal labels.  */\n+  rtx x_nonlocal_goto_stack_level;\n+\n+  /* Label that will go on parm cleanup code, if any.\n+     Jumping to this label runs cleanup code for parameters, if\n+     such code must be run.  Following this code is the logical return\n+     label.  */\n+  rtx x_cleanup_label;\n+\n+  /* Label that will go on function epilogue.\n+     Jumping to this label serves as a \"return\" instruction\n+     on machines which require execution of the epilogue on all returns.  */\n+  rtx x_return_label;\n+\n+  /* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.\n+     So we can mark them all live at the end of the function, if nonopt.  */\n+  rtx x_save_expr_regs;\n+\n+  /* List (chain of EXPR_LISTs) of all stack slots in this function.\n+     Made for the sake of unshare_all_rtl.  */\n+  rtx x_stack_slot_list;\n+\n+  /* Chain of all RTL_EXPRs that have insns in them.  */\n+  tree x_rtl_expr_chain;\n+\n+  /* Label to jump back to for tail recursion, or 0 if we have\n+     not yet needed one for this function.  */\n+  rtx x_tail_recursion_label;\n+\n+  /* Place after which to insert the tail_recursion_label if we need one.  */\n+  rtx x_tail_recursion_reentry;\n+\n+  /* Location at which to save the argument pointer if it will need to be\n+     referenced.  There are two cases where this is done: if nonlocal gotos\n+     exist, or if vars stored at an offset from the argument pointer will be\n+     needed by inner routines.  */\n+  rtx x_arg_pointer_save_area;\n+\n+  /* Offset to end of allocated area of stack frame.\n+     If stack grows down, this is the address of the last stack slot allocated.\n+     If stack grows up, this is the address for the next slot.  */\n+  HOST_WIDE_INT x_frame_offset;\n+\n+  /* List (chain of TREE_LISTs) of static chains for containing functions.\n+     Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx\n+     in an RTL_EXPR in the TREE_VALUE.  */\n+  tree x_context_display;\n+\n+  /* List (chain of TREE_LISTs) of trampolines for nested functions.\n+     The trampoline sets up the static chain and jumps to the function.\n+     We supply the trampoline's address when the function's address is\n+     requested.\n+\n+     Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx\n+     in an RTL_EXPR in the TREE_VALUE.  */\n+  tree x_trampoline_list;\n+\n+  /* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */\n+  rtx x_parm_birth_insn;\n+\n+  /* Last insn of those whose job was to put parms into their nominal\n+     homes.  */\n+  rtx x_last_parm_insn;\n+\n+  /* 1 + last pseudo register number possibly used for loading a copy\n+     of a parameter of this function. */\n+  int x_max_parm_reg;\n+\n+  /* Vector indexed by REGNO, containing location on stack in which\n+     to put the parm which is nominally in pseudo register REGNO,\n+     if we discover that that parm must go in the stack.  The highest\n+     element in this vector is one less than MAX_PARM_REG, above.  */\n+  rtx *x_parm_reg_stack_loc;\n+\n+  /* List of all temporaries allocated, both available and in use.  */\n+  struct temp_slot *x_temp_slots;\n+\n+  /* Current nesting level for temporaries.  */\n+  int x_temp_slot_level;\n+\n+  /* Current nesting level for variables in a block.  */\n+  int x_var_temp_slot_level;\n+\n+  /* When temporaries are created by TARGET_EXPRs, they are created at\n+     this level of temp_slot_level, so that they can remain allocated\n+     until no longer needed.  CLEANUP_POINT_EXPRs define the lifetime\n+     of TARGET_EXPRs.  */\n+  int x_target_temp_slot_level;\n+  \n+  /* This slot is initialized as 0 and is added to\n+     during the nested function.  */\n+  struct var_refs_queue *fixup_var_refs_queue;\n \n   /* For tree.c.  */\n   int all_types_permanent;\n@@ -172,15 +417,33 @@ struct function\n   struct obstack *rtl_obstack;\n   struct simple_obstack_stack *inline_obstacks;\n \n-  /* For integrate.c.  */\n+  /* For integrate.c.  We duplicate some of the fields so that\n+     save_for_inline_copying can keep two versions.  */\n+  int inlinable;\n+  struct emit_status *inl_emit;\n+  /* This is in fact an rtvec.  */\n+  void *original_arg_vector;\n+  tree original_decl_initial;\n+  /* Last insn of those whose job was to put parms into their nominal\n+     homes.  */\n+  rtx inl_last_parm_insn;\n+  /* Highest label number in current function.  */\n+  int inl_max_label_num;\n+\n+  /* Nonzero if the current function uses the constant pool.  */\n   int uses_const_pool;\n \n   /* For md files.  */\n+\n+  /* Nonzero if the current function uses pic_offset_table_rtx.  */\n   int uses_pic_offset_table;\n   /* tm.h can use this to store whatever it likes.  */\n   struct machine_function *machine;\n \n   /* For reorg.  */\n+\n+  /* If some insns can be deferred to the delay slots of the epilogue, the\n+     delay list for them is recorded here.  */\n   rtx epilogue_delay_list;\n \n   /* For varasm.  */\n@@ -194,47 +457,65 @@ struct function\n extern struct function *current_function;\n extern struct function *all_functions;\n \n+/* For backward compatibility... eventually these should all go away.  */\n+#define current_function_name (current_function->name)\n+#define current_function_pops_args (current_function->pops_args)\n+#define current_function_returns_struct (current_function->returns_struct)\n+#define current_function_returns_pcc_struct (current_function->returns_pcc_struct)\n+#define current_function_returns_pointer (current_function->returns_pointer)\n+#define current_function_needs_context (current_function->needs_context)\n+#define current_function_calls_setjmp (current_function->calls_setjmp)\n+#define current_function_calls_alloca (current_function->calls_alloca)\n+#define current_function_calls_longjmp (current_function->calls_longjmp)\n+#define current_function_has_computed_jump (current_function->has_computed_jump)\n+#define current_function_contains_functions (current_function->contains_functions)\n+#define current_function_is_thunk (current_function->is_thunk)\n+#define current_function_args_info (current_function->args_info)\n+#define current_function_args_size (current_function->args_size)\n+#define current_function_pretend_args_size (current_function->pretend_args_size)\n+#define current_function_outgoing_args_size (current_function->outgoing_args_size)\n+#define current_function_arg_offset_rtx (current_function->arg_offset_rtx)\n+#define current_function_varargs (current_function->varargs)\n+#define current_function_stdarg (current_function->stdarg)\n+#define current_function_internal_arg_pointer (current_function->internal_arg_pointer)\n+#define current_function_return_rtx (current_function->return_rtx)\n+#define current_function_instrument_entry_exit (current_function->instrument_entry_exit)\n+#define current_function_check_memory_usage (current_function->check_memory_usage)\n+#define current_function_uses_pic_offset_table (current_function->uses_pic_offset_table)\n+#define current_function_uses_const_pool (current_function->uses_const_pool)\n+#define current_function_cannot_inline (current_function->cannot_inline)\n+#define current_function_epilogue_delay_list (current_function->epilogue_delay_list)\n+#define current_function_has_nonlocal_label (current_function->has_nonlocal_label)\n+#define current_function_has_nonlocal_goto (current_function->has_nonlocal_goto)\n+\n+#define max_parm_reg (current_function->x_max_parm_reg)\n+#define parm_reg_stack_loc (current_function->x_parm_reg_stack_loc)\n+#define cleanup_label (current_function->x_cleanup_label)\n+#define return_label (current_function->x_return_label)\n+#define save_expr_regs (current_function->x_save_expr_regs)\n+#define stack_slot_list (current_function->x_stack_slot_list)\n+#define parm_birth_insn (current_function->x_parm_birth_insn)\n+#define frame_offset (current_function->x_frame_offset)\n+#define tail_recursion_label (current_function->x_tail_recursion_label)\n+#define tail_recursion_reentry (current_function->x_tail_recursion_reentry)\n+#define arg_pointer_save_area (current_function->x_arg_pointer_save_area)\n+#define rtl_expr_chain (current_function->x_rtl_expr_chain)\n+#define last_parm_insn (current_function->x_last_parm_insn)\n+#define context_display (current_function->x_context_display)\n+#define trampoline_list (current_function->x_trampoline_list)\n+#define function_call_count (current_function->x_function_call_count)\n+#define temp_slots (current_function->x_temp_slots)\n+#define temp_slot_level (current_function->x_temp_slot_level)\n+#define target_temp_slot_level (current_function->x_target_temp_slot_level)\n+#define var_temp_slot_level (current_function->x_var_temp_slot_level)\n+#define nonlocal_labels (current_function->x_nonlocal_labels)\n+#define nonlocal_goto_handler_slots (current_function->x_nonlocal_goto_handler_slots)\n+#define nonlocal_goto_handler_labels (current_function->x_nonlocal_goto_handler_labels)\n+#define nonlocal_goto_stack_level (current_function->x_nonlocal_goto_stack_level)\n+\n /* The FUNCTION_DECL for an inline function currently being expanded.  */\n extern tree inline_function_decl;\n \n-/* Label that will go on parm cleanup code, if any.\n-   Jumping to this label runs cleanup code for parameters, if\n-   such code must be run.  Following this code is the logical return label.  */\n-\n-extern rtx cleanup_label;\n-\n-/* Label that will go on function epilogue.\n-   Jumping to this label serves as a \"return\" instruction\n-   on machines which require execution of the epilogue on all returns.  */\n-\n-extern rtx return_label;\n-\n-/* Offset to end of allocated area of stack frame.\n-   If stack grows down, this is the address of the last stack slot allocated.\n-   If stack grows up, this is the address for the next slot.  */\n-extern HOST_WIDE_INT frame_offset;\n-\n-/* Label to jump back to for tail recursion, or 0 if we have\n-   not yet needed one for this function.  */\n-extern rtx tail_recursion_label;\n-\n-/* Place after which to insert the tail_recursion_label if we need one.  */\n-extern rtx tail_recursion_reentry;\n-\n-/* Location at which to save the argument pointer if it will need to be\n-   referenced.  There are two cases where this is done: if nonlocal gotos\n-   exist, or if vars whose is an offset from the argument pointer will be\n-   needed by inner routines.  */\n-\n-extern rtx arg_pointer_save_area;\n-\n-/* Chain of all RTL_EXPRs that have insns in them.  */\n-extern tree rtl_expr_chain;\n-\n-/* List (chain of EXPR_LISTs) of all stack slots in this function.\n-   Made for the sake of unshare_all_rtl.  */\n-extern rtx stack_slot_list;\n-\n /* Given a function decl for a containing function,\n    return the `struct function' for it.  */\n struct function *find_function_data PROTO((tree));\n@@ -251,6 +532,8 @@ extern tree *identify_blocks PROTO((tree, rtx));\n    This size counts from zero.  It is not rounded to STACK_BOUNDARY;\n    the caller may have to do that.  */\n extern HOST_WIDE_INT get_frame_size PROTO((void));\n+/* Likewise, but for a different than the current function.  */\n+extern HOST_WIDE_INT get_func_frame_size PROTO((struct function *));\n \n /* These variables hold pointers to functions to\n    save and restore machine-specific data,\n@@ -263,15 +546,12 @@ extern void save_tree_status\t\tPROTO((struct function *, tree));\n extern void restore_tree_status\t\tPROTO((struct function *, tree));\n extern void save_varasm_status\t\tPROTO((struct function *, tree));\n extern void restore_varasm_status\tPROTO((struct function *));\n-extern void save_expr_status\t\tPROTO((struct function *));\n-extern void restore_expr_status\t\tPROTO((struct function *));\n-extern void save_emit_status\t\tPROTO((struct function *));\n extern void restore_emit_status\t\tPROTO((struct function *));\n-extern void save_storage_status\t\tPROTO((struct function *));\n-extern void restore_storage_status\tPROTO((struct function *));\n \n extern rtx get_first_block_beg\t\tPROTO((void));\n \n+extern void init_virtual_regs\t\tPROTO((struct emit_status *));\n+\n #ifdef rtx\n #undef rtx\n #endif"}, {"sha": "53b81143aa70d408c164471bd5ec8112abe2a33d", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -152,6 +152,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"basic-block.h\"\n #include \"output.h\"\n+#include \"function.h\"\n #include \"expr.h\" \n \n #include \"obstack.h\"\n@@ -479,9 +480,6 @@ static int gcse_create_count;\n static int const_prop_count;\n /* Number of copys propagated.  */\n static int copy_prop_count;\n-\n-extern char *current_function_name;\n-extern int current_function_calls_setjmp;\n \f\n /* These variables are used by classic GCSE.\n    Normally they'd be defined a bit later, but `rd_gen' needs to"}, {"sha": "7744145074c09c6c4d3d8fa73b70f8acf310f040", "filename": "gcc/genemit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -770,6 +770,7 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"config.h\\\"\\n\");\n   printf (\"#include \\\"system.h\\\"\\n\");\n   printf (\"#include \\\"rtl.h\\\"\\n\");\n+  printf (\"#include \\\"function.h\\\"\\n\");\n   printf (\"#include \\\"expr.h\\\"\\n\");\n   printf (\"#include \\\"real.h\\\"\\n\");\n   printf (\"#include \\\"flags.h\\\"\\n\");"}, {"sha": "83263838b02ac060893bf0a2ade075634e194e99", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -215,6 +215,7 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"system.h\\\"\\n\");\n   printf (\"#include \\\"flags.h\\\"\\n\");\n   printf (\"#include \\\"rtl.h\\\"\\n\");\n+  printf (\"#include \\\"function.h\\\"\\n\");\n   printf (\"#include \\\"regs.h\\\"\\n\");\n   printf (\"#include \\\"hard-reg-set.h\\\"\\n\");\n   printf (\"#include \\\"real.h\\\"\\n\");"}, {"sha": "0c5b050db98e978df83763ef36a0558322fa5039", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -28,6 +28,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n+#include \"function.h\"\n #include \"insn-config.h\"\n #include \"reload.h\"\n #include \"output.h\""}, {"sha": "3086e402e562a7e57df5cfe519646993453c7b6d", "filename": "gcc/graph.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -25,6 +25,7 @@\n #include \"rtl.h\"\n #include \"flags.h\"\n #include \"output.h\"\n+#include \"function.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"toplev.h\""}, {"sha": "1341338f307ea817ede11ecfd4616b7dac815fb1", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -161,6 +161,7 @@\n #include \"rtl.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n+#include \"function.h\"\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"insn-config.h\"\n@@ -494,9 +495,6 @@ static int *out_edges;\n #define IN_EDGES(block) (in_edges[block])\n #define OUT_EDGES(block) (out_edges[block])\n \n-/* List of labels which cannot be deleted, needed for control\n-   flow graph construction.  */\n-extern rtx forced_labels;\n \n \n static int is_cfg_nonregular PROTO ((void));"}, {"sha": "9049ac00c552c4c310bb540a9cc1520ed47364b1", "filename": "gcc/integrate.c", "status": "modified", "additions": 88, "deletions": 204, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -60,8 +60,7 @@ extern struct obstack *function_maybepermanent_obstack;\n    : (8 * (8 + list_length (DECL_ARGUMENTS (DECL)))))\n #endif\n \f\n-static rtx initialize_for_inline\tPROTO((tree, int, int, int, int));\n-static void finish_inline\t\tPROTO((tree, rtx));\n+static rtvec initialize_for_inline\tPROTO((tree, int));\n static void adjust_copied_decl_tree\tPROTO((tree));\n static tree copy_decl_list\t\tPROTO((tree));\n static tree copy_decl_tree\t\tPROTO((tree));\n@@ -256,10 +255,6 @@ static rtx *insn_map;\n    Only reg numbers less than max_parm_reg are mapped here.  */\n static tree *parmdecl_map;\n \n-/* Keep track of first pseudo-register beyond those that are parms.  */\n-extern int max_parm_reg;\n-extern rtx *parm_reg_stack_loc;\n-\n /* When an insn is being copied by copy_for_inline,\n    this is nonzero if we have copied an ASM_OPERANDS.\n    In that case, it is the original input-operand vector.  */\n@@ -289,36 +284,15 @@ save_for_inline_eh_labelmap (label)\n /* Subroutine for `save_for_inline{copying,nocopy}'.  Performs initialization\n    needed to save FNDECL's insns and info for future inline expansion.  */\n    \n-static rtx\n-initialize_for_inline (fndecl, min_labelno, max_labelno, max_reg, copy)\n+static rtvec\n+initialize_for_inline (fndecl, copy)\n      tree fndecl;\n-     int min_labelno;\n-     int max_labelno;\n-     int max_reg;\n      int copy;\n {\n-  int function_flags, i;\n+  int i;\n   rtvec arg_vector;\n   tree parms;\n \n-  /* Compute the values of any flags we must restore when inlining this.  */\n-\n-  function_flags\n-    = (current_function_calls_alloca * FUNCTION_FLAGS_CALLS_ALLOCA\n-       + current_function_calls_setjmp * FUNCTION_FLAGS_CALLS_SETJMP\n-       + current_function_calls_longjmp * FUNCTION_FLAGS_CALLS_LONGJMP\n-       + current_function_returns_struct * FUNCTION_FLAGS_RETURNS_STRUCT\n-       + (current_function_returns_pcc_struct\n-\t  * FUNCTION_FLAGS_RETURNS_PCC_STRUCT)\n-       + current_function_needs_context * FUNCTION_FLAGS_NEEDS_CONTEXT\n-       + (current_function_has_nonlocal_label\n-\t  * FUNCTION_FLAGS_HAS_NONLOCAL_LABEL)\n-       + current_function_returns_pointer * FUNCTION_FLAGS_RETURNS_POINTER\n-       + current_function_uses_const_pool * FUNCTION_FLAGS_USES_CONST_POOL\n-       + (current_function_uses_pic_offset_table\n-\t  * FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE)\n-       + current_function_has_computed_jump * FUNCTION_FLAGS_HAS_COMPUTED_JUMP);\n-\n   /* Clear out PARMDECL_MAP.  It was allocated in the caller's frame.  */\n   bzero ((char *) parmdecl_map, max_parm_reg * sizeof (tree));\n   arg_vector = rtvec_alloc (list_length (DECL_ARGUMENTS (fndecl)));\n@@ -393,54 +367,7 @@ initialize_for_inline (fndecl, min_labelno, max_labelno, max_reg, copy)\n \t}\n     }\n \n-  /* Assume we start out in the insns that set up the parameters.  */\n-  in_nonparm_insns = 0;\n-\n-  /* The list of DECL_SAVED_INSNS, starts off with a header which\n-     contains the following information:\n-\n-     the first insn of the function (not including the insns that copy\n-     parameters into registers).\n-     the first parameter insn of the function,\n-     the first label used by that function,\n-     the last label used by that function,\n-     the highest register number used for parameters,\n-     the total number of registers used,\n-     the size of the incoming stack area for parameters,\n-     the number of bytes popped on return,\n-     the stack slot list,\n-     the labels that are forced to exist,\n-     some flags that are used to restore compiler globals,\n-     the value of current_function_outgoing_args_size,\n-     the original argument vector,\n-     the original DECL_INITIAL,\n-     and pointers to the table of pseudo regs, pointer flags, and alignment. */\n-\n-  return gen_inline_header_rtx (NULL_RTX, NULL_RTX, min_labelno, max_labelno,\n-\t\t\t\tmax_parm_reg, max_reg,\n-\t\t\t\tcurrent_function_args_size,\n-\t\t\t\tcurrent_function_pops_args,\n-\t\t\t\tstack_slot_list, forced_labels, function_flags,\n-\t\t\t\tcurrent_function_outgoing_args_size,\n-\t\t\t\targ_vector, (rtx) DECL_INITIAL (fndecl),\n-\t\t\t\t(rtvec) regno_reg_rtx, regno_pointer_flag,\n-\t\t\t\tregno_pointer_align,\n-\t\t\t\t(rtvec) parm_reg_stack_loc);\n-}\n-\n-/* Subroutine for `save_for_inline{copying,nocopy}'.  Finishes up the\n-   things that must be done to make FNDECL expandable as an inline function.\n-   HEAD contains the chain of insns to which FNDECL will expand.  */\n-   \n-static void\n-finish_inline (fndecl, head)\n-     tree fndecl;\n-     rtx head;\n-{\n-  FIRST_FUNCTION_INSN (head) = get_first_nonparm_insn ();\n-  FIRST_PARM_INSN (head) = get_insns ();\n-  DECL_SAVED_INSNS (fndecl) = head;\n-  DECL_FRAME_SIZE (fndecl) = get_frame_size ();\n+  return arg_vector;\n }\n \n /* Adjust the BLOCK_END_NOTE pointers in a given copied DECL tree so that\n@@ -487,15 +414,17 @@ void\n save_for_inline_copying (fndecl)\n      tree fndecl;\n {\n-  rtx first_insn, last_insn, insn;\n-  rtx head, copy;\n+  rtvec argvec;\n+  rtx new_first_insn, new_last_insn, insn;\n   int max_labelno, min_labelno, i, len;\n   int max_reg;\n   int max_uid;\n   rtx first_nonparm_insn;\n   char *new, *new1;\n   rtx *new_parm_reg_stack_loc;\n   rtx *new2;\n+  struct emit_status *es\n+    = (struct emit_status *) xmalloc (sizeof (struct emit_status));\n \n   /* Make and emit a return-label if we have not already done so. \n      Do this before recording the bounds on label numbers.  */\n@@ -506,6 +435,8 @@ save_for_inline_copying (fndecl)\n       emit_label (return_label);\n     }\n \n+  *es = *current_function->emit;\n+\n   /* Get some bounds on the labels and registers used.  */\n \n   max_labelno = max_label_num ();\n@@ -520,7 +451,7 @@ save_for_inline_copying (fndecl)\n \n   parmdecl_map = (tree *) alloca (max_parm_reg * sizeof (tree));\n \n-  head = initialize_for_inline (fndecl, min_labelno, max_labelno, max_reg, 1);\n+  argvec = initialize_for_inline (fndecl, 1);\n \n   if (current_function_uses_const_pool)\n     {\n@@ -544,7 +475,7 @@ save_for_inline_copying (fndecl)\n       clear_const_double_mem ();\n     }\n \n-  max_uid = INSN_UID (head);\n+  max_uid = get_max_uid ();\n \n   /* We have now allocated all that needs to be allocated permanently\n      on the rtx obstack.  Set our high-water mark, so that we\n@@ -565,29 +496,29 @@ save_for_inline_copying (fndecl)\n   insn = get_insns ();\n   if (GET_CODE (insn) != NOTE)\n     abort ();\n-  first_insn = rtx_alloc (NOTE);\n-  NOTE_SOURCE_FILE (first_insn) = NOTE_SOURCE_FILE (insn);\n-  NOTE_LINE_NUMBER (first_insn) = NOTE_LINE_NUMBER (insn);\n-  INSN_UID (first_insn) = INSN_UID (insn);\n-  PREV_INSN (first_insn) = NULL;\n-  NEXT_INSN (first_insn) = NULL;\n-  last_insn = first_insn;\n+  new_first_insn = rtx_alloc (NOTE);\n+  NOTE_SOURCE_FILE (new_first_insn) = NOTE_SOURCE_FILE (insn);\n+  NOTE_LINE_NUMBER (new_first_insn) = NOTE_LINE_NUMBER (insn);\n+  INSN_UID (new_first_insn) = INSN_UID (insn);\n+  PREV_INSN (new_first_insn) = NULL;\n+  NEXT_INSN (new_first_insn) = NULL;\n+  new_last_insn = new_first_insn;\n \n   /* Each pseudo-reg in the old insn chain must have a unique rtx in the copy.\n      Make these new rtx's now, and install them in regno_reg_rtx, so they\n      will be the official pseudo-reg rtx's for the rest of compilation.  */\n \n-  reg_map = (rtx *) savealloc (regno_pointer_flag_length * sizeof (rtx));\n+  reg_map = (rtx *) savealloc (es->regno_pointer_flag_length * sizeof (rtx));\n \n   len = sizeof (struct rtx_def) + (GET_RTX_LENGTH (REG) - 1) * sizeof (rtunion);\n   for (i = max_reg - 1; i > LAST_VIRTUAL_REGISTER; i--)\n     reg_map[i] = (rtx)obstack_copy (function_maybepermanent_obstack,\n \t\t\t\t    regno_reg_rtx[i], len);\n \n-  regno_reg_rtx = reg_map;\n+  es->x_regno_reg_rtx = reg_map;\n \n   /* Put copies of all the virtual register rtx into the new regno_reg_rtx.  */\n-  init_virtual_regs ();\n+  init_virtual_regs (es);\n \n   /* Likewise each label rtx must have a unique rtx as its copy.  */\n \n@@ -663,6 +594,7 @@ save_for_inline_copying (fndecl)\n \n   for (insn = NEXT_INSN (insn); insn; insn = NEXT_INSN (insn))\n     {\n+      rtx copy;\n       orig_asm_operands_vector = 0;\n \n       if (insn == first_nonparm_insn)\n@@ -732,9 +664,9 @@ save_for_inline_copying (fndecl)\n \t}\n       INSN_UID (copy) = INSN_UID (insn);\n       insn_map[INSN_UID (insn)] = copy;\n-      NEXT_INSN (last_insn) = copy;\n-      PREV_INSN (copy) = last_insn;\n-      last_insn = copy;\n+      NEXT_INSN (new_last_insn) = copy;\n+      PREV_INSN (copy) = new_last_insn;\n+      new_last_insn = copy;\n     }\n \n   adjust_copied_decl_tree (DECL_INITIAL (fndecl));\n@@ -746,23 +678,28 @@ save_for_inline_copying (fndecl)\n       REG_NOTES (insn_map[INSN_UID (insn)])\n \t= copy_for_inline (REG_NOTES (insn));\n \n-  NEXT_INSN (last_insn) = NULL;\n-\n-  finish_inline (fndecl, head);\n+  NEXT_INSN (new_last_insn) = NULL;\n \n   /* Make new versions of the register tables.  */\n-  new = (char *) savealloc (regno_pointer_flag_length);\n-  bcopy (regno_pointer_flag, new, regno_pointer_flag_length);\n-  new1 = (char *) savealloc (regno_pointer_flag_length);\n-  bcopy (regno_pointer_align, new1, regno_pointer_flag_length);\n-\n-  regno_pointer_flag = new;\n-  regno_pointer_align = new1;\n-\n-  set_new_first_and_last_insn (first_insn, last_insn);\n-\n-  if (label_map)\n-    free (label_map);\n+  new = (char *) savealloc (es->regno_pointer_flag_length);\n+  memcpy (new, es->regno_pointer_flag, es->regno_pointer_flag_length);\n+  new1 = (char *) savealloc (es->regno_pointer_flag_length);\n+  memcpy (new1, es->regno_pointer_align, es->regno_pointer_flag_length);\n+  es->regno_pointer_flag = new;\n+  es->regno_pointer_align = new1;\n+\n+  free (label_map);\n+\n+  current_function->inl_max_label_num = max_label_num ();\n+  current_function->inl_last_parm_insn = current_function->x_last_parm_insn;\n+  current_function->original_arg_vector = argvec;\n+  current_function->original_decl_initial = DECL_INITIAL (fndecl);\n+  /* Use the copy we made for compiling the function now, and\n+     use the original values for inlining.  */\n+  current_function->inl_emit = current_function->emit;\n+  current_function->emit = es;\n+  set_new_first_and_last_insn (new_first_insn, new_last_insn);\n+  DECL_SAVED_INSNS (fndecl) = current_function;\n }\n \n /* Copy NODE (as with copy_node).  NODE must be a DECL.  Set the\n@@ -885,7 +822,7 @@ save_for_inline_nocopy (fndecl)\n      tree fndecl;\n {\n   rtx insn;\n-  rtx head;\n+  rtvec argvec;\n   rtx first_nonparm_insn;\n \n   /* Set up PARMDECL_MAP which maps pseudo-reg number to its PARM_DECL.\n@@ -904,8 +841,7 @@ save_for_inline_nocopy (fndecl)\n       emit_label (return_label);\n     }\n \n-  head = initialize_for_inline (fndecl, get_first_label_num (),\n-\t\t\t\tmax_label_num (), max_reg_num (), 0);\n+  argvec = initialize_for_inline (fndecl, 0);\n \n   /* If there are insns that copy parms from the stack into pseudo registers,\n      those insns are not copied.  `expand_inline_function' must\n@@ -957,7 +893,12 @@ save_for_inline_nocopy (fndecl)\n \n   preserve_data ();\n \n-  finish_inline (fndecl, head);\n+  current_function->inl_emit = current_function->emit;\n+  current_function->inl_max_label_num = max_label_num ();\n+  current_function->inl_last_parm_insn = current_function->x_last_parm_insn;\n+  current_function->original_arg_vector = argvec;\n+  current_function->original_decl_initial = DECL_INITIAL (fndecl);\n+  DECL_SAVED_INSNS (fndecl) = current_function;\n }\n \f\n /* Given PX, a pointer into an insn, search for references to the constant\n@@ -1385,17 +1326,19 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n      tree type;\n      rtx structure_value_addr;\n {\n+  struct function *inl_f = DECL_SAVED_INSNS (fndecl);\n   tree formal, actual, block;\n-  rtx header = DECL_SAVED_INSNS (fndecl);\n-  rtx insns = FIRST_FUNCTION_INSN (header);\n-  rtx parm_insns = FIRST_PARM_INSN (header);\n+  rtx parm_insns = inl_f->inl_emit->x_first_insn;\n+  rtx insns = (inl_f->inl_last_parm_insn\n+\t       ? NEXT_INSN (inl_f->inl_last_parm_insn)\n+\t       : parm_insns);\n   tree *arg_trees;\n   rtx *arg_vals;\n   rtx insn;\n   int max_regno;\n   register int i;\n-  int min_labelno = FIRST_LABELNO (header);\n-  int max_labelno = LAST_LABELNO (header);\n+  int min_labelno = inl_f->inl_emit->x_first_label_num;\n+  int max_labelno = inl_f->inl_max_label_num;\n   int nargs;\n   rtx local_return_label = 0;\n   rtx loc;\n@@ -1405,15 +1348,16 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n #ifdef HAVE_cc0\n   rtx cc0_insn = 0;\n #endif\n-  rtvec arg_vector = ORIGINAL_ARG_VECTOR (header);\n+  rtvec arg_vector = (rtvec) inl_f->original_arg_vector;\n   rtx static_chain_value = 0;\n+  int inl_max_uid;\n \n   /* The pointer used to track the true location of the memory used\n      for MAP->LABEL_MAP.  */\n   rtx *real_label_map = 0;\n \n   /* Allow for equivalences of the pseudos we make for virtual fp and ap.  */\n-  max_regno = MAX_REGNUM (header) + 3;\n+  max_regno = inl_f->inl_emit->x_reg_rtx_no + 3;\n   if (max_regno < FIRST_PSEUDO_REGISTER)\n     abort ();\n \n@@ -1556,10 +1500,11 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n     = (rtx *) xmalloc ((max_labelno) * sizeof (rtx));\n   map->label_map = real_label_map;\n \n-  map->insn_map = (rtx *) alloca (INSN_UID (header) * sizeof (rtx));\n-  bzero ((char *) map->insn_map, INSN_UID (header) * sizeof (rtx));\n+  inl_max_uid = (inl_f->inl_emit->x_cur_insn_uid + 1);\n+  map->insn_map = (rtx *) alloca (inl_max_uid * sizeof (rtx));\n+  bzero ((char *) map->insn_map, inl_max_uid * sizeof (rtx));\n   map->min_insnno = 0;\n-  map->max_insnno = INSN_UID (header);\n+  map->max_insnno = inl_max_uid;\n \n   map->integrating = 1;\n \n@@ -1591,21 +1536,21 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   if (map->insns_at_start == 0)\n     map->insns_at_start = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n \n-  map->regno_pointer_flag = INLINE_REGNO_POINTER_FLAG (header);\n-  map->regno_pointer_align = INLINE_REGNO_POINTER_ALIGN (header);\n+  map->regno_pointer_flag = inl_f->inl_emit->regno_pointer_flag;\n+  map->regno_pointer_align = inl_f->inl_emit->regno_pointer_align;\n \n   /* Update the outgoing argument size to allow for those in the inlined\n      function.  */\n-  if (OUTGOING_ARGS_SIZE (header) > current_function_outgoing_args_size)\n-    current_function_outgoing_args_size = OUTGOING_ARGS_SIZE (header);\n+  if (inl_f->outgoing_args_size > current_function_outgoing_args_size)\n+    current_function_outgoing_args_size = inl_f->outgoing_args_size;\n \n   /* If the inline function needs to make PIC references, that means\n      that this function's PIC offset table must be used.  */\n-  if (FUNCTION_FLAGS (header) & FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE)\n+  if (inl_f->uses_pic_offset_table)\n     current_function_uses_pic_offset_table = 1;\n \n   /* If this function needs a context, set it up.  */\n-  if (FUNCTION_FLAGS (header) & FUNCTION_FLAGS_NEEDS_CONTEXT)\n+  if (inl_f->needs_context)\n     static_chain_value = lookup_static_chain (fndecl);\n \n   if (GET_CODE (parm_insns) == NOTE\n@@ -1871,7 +1816,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n      stack pointer around the call.  This saves stack space, but\n      also is required if this inline is being done between two\n      pushes.  */\n-  if (FUNCTION_FLAGS (header) & FUNCTION_FLAGS_CALLS_ALLOCA)\n+  if (inl_f->calls_alloca)\n     emit_stack_save (SAVE_BLOCK, &stack_save, NULL_RTX);\n \n   /* Now copy the insns one by one.  Do this in two passes, first the insns and\n@@ -2134,7 +2079,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n     emit_label (local_return_label);\n \n   /* Restore the stack pointer if we saved it above.  */\n-  if (FUNCTION_FLAGS (header) & FUNCTION_FLAGS_CALLS_ALLOCA)\n+  if (inl_f->calls_alloca)\n     emit_stack_restore (SAVE_BLOCK, stack_save, NULL_RTX);\n \n   /* Make copies of the decls of the symbols in the inline function, so that\n@@ -2144,7 +2089,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n   inline_function_decl = fndecl;\n   integrate_parm_decls (DECL_ARGUMENTS (fndecl), map, arg_vector);\n-  integrate_decl_tree ((tree) ORIGINAL_DECL_INITIAL (header), 0, map);\n+  integrate_decl_tree (inl_f->original_decl_initial, 0, map);\n   inline_function_decl = 0;\n \n   /* End the scope containing the copied formal parameter variables\n@@ -2363,7 +2308,7 @@ copy_rtx_and_substitute (orig, map)\n \t  if (regno == VIRTUAL_STACK_VARS_REGNUM)\n \t    {\n \t      rtx loc, seq;\n-\t      int size = DECL_FRAME_SIZE (map->fndecl);\n+\t      int size = get_func_frame_size (DECL_SAVED_INSNS (map->fndecl));\n \n #ifdef FRAME_GROWS_DOWNWARD\n \t      /* In this case, virtual_stack_vars_rtx points to one byte\n@@ -2401,7 +2346,7 @@ copy_rtx_and_substitute (orig, map)\n \t      /* Do the same for a block to contain any arguments referenced\n \t\t in memory.  */\n \t      rtx loc, seq;\n-\t      int size = FUNCTION_ARGS_SIZE (DECL_SAVED_INSNS (map->fndecl));\n+\t      int size = DECL_SAVED_INSNS (map->fndecl)->args_size;\n \n \t      start_sequence ();\n \t      loc = assign_stack_temp (BLKmode, size, 1);\n@@ -3374,81 +3319,19 @@ void\n output_inline_function (fndecl)\n      tree fndecl;\n {\n-  rtx head;\n+  struct function *f = DECL_SAVED_INSNS (fndecl);\n   rtx last;\n \n   /* Things we allocate from here on are part of this function, not\n      permanent.  */\n   temporary_allocation ();\n-\n-  head = DECL_SAVED_INSNS (fndecl);\n+  current_function = f;\n   current_function_decl = fndecl;\n-\n-  /* This call is only used to initialize global variables.  */\n-  init_function_start (fndecl, \"lossage\", 1);\n-\n-  /* Redo parameter determinations in case the FUNCTION_...\n-     macros took machine-specific actions that need to be redone.  */\n-  assign_parms (fndecl, 1);\n-\n-  /* Set stack frame size.  */\n-  assign_stack_local (BLKmode, DECL_FRAME_SIZE (fndecl), 0);\n-\n-  /* The first is a bit of a lie (the array may be larger), but doesn't\n-     matter too much and it isn't worth saving the actual bound.  */\n-  reg_rtx_no = regno_pointer_flag_length = MAX_REGNUM (head);\n-  regno_reg_rtx = (rtx *) INLINE_REGNO_REG_RTX (head);\n-  regno_pointer_flag = INLINE_REGNO_POINTER_FLAG (head);\n-  regno_pointer_align = INLINE_REGNO_POINTER_ALIGN (head);\n-  max_parm_reg = MAX_PARMREG (head);\n-  parm_reg_stack_loc = (rtx *) PARMREG_STACK_LOC (head);\n-  \n-  stack_slot_list = STACK_SLOT_LIST (head);\n-  forced_labels = FORCED_LABELS (head);\n-\n-  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_HAS_COMPUTED_JUMP)\n-    current_function_has_computed_jump = 1;\n-\n-  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_CALLS_ALLOCA)\n-    current_function_calls_alloca = 1;\n-\n-  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_CALLS_SETJMP)\n-    current_function_calls_setjmp = 1;\n-\n-  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_CALLS_LONGJMP)\n-    current_function_calls_longjmp = 1;\n-\n-  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_RETURNS_STRUCT)\n-    current_function_returns_struct = 1;\n-\n-  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_RETURNS_PCC_STRUCT)\n-    current_function_returns_pcc_struct = 1;\n-\n-  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_NEEDS_CONTEXT)\n-    current_function_needs_context = 1;\n-\n-  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_HAS_NONLOCAL_LABEL)\n-    current_function_has_nonlocal_label = 1;\n-\n-  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_RETURNS_POINTER)\n-    current_function_returns_pointer = 1;\n-\n-  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_USES_CONST_POOL)\n-    current_function_uses_const_pool = 1;\n-\n-  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE)\n-    current_function_uses_pic_offset_table = 1;\n-\n-  current_function_outgoing_args_size = OUTGOING_ARGS_SIZE (head);\n-  current_function_pops_args = POPS_ARGS (head);\n-\n-  /* This is the only thing the expand_function_end call that uses to be here\n-     actually does and that call can cause problems.  */\n-  immediate_size_expand--;\n+  clear_emit_caches ();\n \n   /* Find last insn and rebuild the constant pool.  */\n-  for (last = FIRST_PARM_INSN (head);\n-       NEXT_INSN (last); last = NEXT_INSN (last))\n+  init_const_rtx_hash_table ();\n+  for (last = get_insns (); NEXT_INSN (last); last = NEXT_INSN (last))\n     {\n       if (GET_RTX_CLASS (GET_CODE (last)) == 'i')\n \t{\n@@ -3457,8 +3340,7 @@ output_inline_function (fndecl)\n \t}\n     }\n \n-  set_new_first_and_last_insn (FIRST_PARM_INSN (head), last);\n-  set_new_first_and_last_label_num (FIRST_LABELNO (head), LAST_LABELNO (head));\n+  set_new_last_label_num (f->inl_max_label_num);\n \n   /* We must have already output DWARF debugging information for the\n      original (abstract) inline function declaration/definition, so\n@@ -3475,10 +3357,12 @@ output_inline_function (fndecl)\n   DECL_DEFER_OUTPUT (fndecl) = 0;\n \n   /* We can't inline this anymore.  */\n+  f->inlinable = 0;\n   DECL_INLINE (fndecl) = 0;\n \n   /* Compile this function all the way down to assembly code.  */\n   rest_of_compilation (fndecl);\n \n+  current_function = 0;\n   current_function_decl = 0;\n }"}, {"sha": "9ff6bc99ee9d60463c8bcfcf5729ec5621c1cf81", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -61,6 +61,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-flags.h\"\n #include \"insn-attr.h\"\n #include \"recog.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"real.h\"\n #include \"except.h\"\n@@ -89,10 +90,6 @@ Boston, MA 02111-1307, USA.  */\n \n static rtx *jump_chain;\n \n-/* List of labels referred to from initializers.\n-   These can never be deleted.  */\n-rtx forced_labels;\n-\n /* Maximum index in jump_chain.  */\n \n static int max_jump_chain;"}, {"sha": "9dccdaad5f82f0d97830bd770a6f662e2af676ad", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -65,6 +65,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n+#include \"function.h\"\n #include \"hard-reg-set.h\"\n #include \"insn-config.h\"\n #include \"insn-attr.h\""}, {"sha": "97461014ea04cd63b9cdb9c28504528328f16c04", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"obstack.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"insn-config.h\"\n #include \"insn-flags.h\""}, {"sha": "3765133ab71af20c62f3daf08fdd1a7744b5e74d", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"insn-flags.h\"\n #include \"insn-codes.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"recog.h\"\n #include \"reload.h\""}, {"sha": "1e88be55a846ec6ad677912338b6cbf8a534e693", "filename": "gcc/output.h", "status": "modified", "additions": 12, "deletions": 121, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -341,48 +341,23 @@ extern int which_alternative;\n extern rtx final_sequence;\n #endif\n \n-/* Number of bytes of args popped by function being compiled on its return.\n-   Zero if no bytes are to be popped.\n-   May affect compilation of return insn or of function epilogue.  */\n-\n-extern int current_function_pops_args;\n-\n-/* Nonzero if function being compiled needs to be given an address\n-   where the value should be stored.  */\n-\n-extern int current_function_returns_struct;\n-\n-/* Nonzero if function being compiled needs to\n-   return the address of where it has put a structure value.  */\n-\n-extern int current_function_returns_pcc_struct;\n-\n-/* Nonzero if function being compiled needs to be passed a static chain.  */\n-\n-extern int current_function_needs_context;\n-\n-/* Nonzero if function being compiled can call setjmp.  */\n-\n-extern int current_function_calls_setjmp;\n-\n-/* Nonzero if function being compiled can call longjmp.  */\n-\n-extern int current_function_calls_longjmp;\n-\n-/* Nonzero if function being compiled can call alloca,\n-   either as a subroutine or builtin.  */\n-\n-extern int current_function_calls_alloca;\n+/* Nonzero means generate position-independent code.\n+   This is not fully implemented yet.  */\n \n-/* Nonzero if function being compiled receives nonlocal gotos\n-   from nested functions.  */\n+extern int flag_pic;\n \n-extern int current_function_has_nonlocal_label;\n+/* The line number of the beginning of the current function.\n+   sdbout.c needs this so that it can output relative linenumbers.  */\n \n-/* Nonzero if function being compiled contains nested functions.  */\n+#ifdef SDB_DEBUGGING_INFO /* Avoid undef sym in certain broken linkers.  */\n+extern int sdb_begin_function_line;\n+#endif\n \n-extern int current_function_contains_functions;\n+/* File in which assembler code is being written.  */\n \n+#ifdef BUFSIZ\n+extern FILE *asm_out_file;\n+#endif\n /* Nonzero if function being compiled doesn't contain any calls\n    (ignoring the prologue and epilogue).  This is set prior to\n    local register allocation and is valid for the remaining\n@@ -402,90 +377,6 @@ extern int current_function_sp_is_unchanging;\n \n extern int current_function_uses_only_leaf_regs;\n \n-/* Nonzero if the function being compiled issues a computed jump.  */\n-\n-extern int current_function_has_computed_jump;\n-\n-/* Nonzero if the current function returns a pointer type */\n-\n-extern int current_function_returns_pointer;\n-\n-/* If function's args have a fixed size, this is that size, in bytes.\n-   Otherwise, it is -1.\n-   May affect compilation of return insn or of function epilogue.  */\n-\n-extern int current_function_args_size;\n-\n-/* # bytes the prologue should push and pretend that the caller pushed them.\n-   The prologue must do this, but only if parms can be passed in registers.  */\n-\n-extern int current_function_pretend_args_size;\n-\n-/* # of bytes of outgoing arguments required to be pushed by the prologue.\n-   If this is non-zero, it means that ACCUMULATE_OUTGOING_ARGS was defined\n-   and no stack adjusts will be done on function calls.  */\n-\n-extern int current_function_outgoing_args_size;\n-\n-/* Nonzero if current function uses varargs.h or equivalent.\n-   Zero for functions that use stdarg.h.  */\n-\n-extern int current_function_varargs;\n-\n-/* Nonzero if current function uses stdarg.h or equivalent.\n-   Zero for functions that use varargs.h.  */\n-\n-extern int current_function_stdarg;\n-\n-/* Quantities of various kinds of registers\n-   used for the current function's args.  */\n-\n-extern CUMULATIVE_ARGS current_function_args_info;\n-\n-/* Name of function now being compiled.  */\n-\n-extern char *current_function_name;\n-\n-#ifdef RTX_CODE\n-/* If non-zero, an RTL expression for that location at which the current\n-   function returns its result.  Usually equal to\n-   DECL_RTL (DECL_RESULT (current_function_decl)).  */\n-\n-extern rtx current_function_return_rtx;\n-\n-/* If some insns can be deferred to the delay slots of the epilogue, the\n-   delay list for them is recorded here.  */\n-\n-extern rtx current_function_epilogue_delay_list;\n-#endif\n-\n-/* Nonzero means generate position-independent code.\n-   This is not fully implemented yet.  */\n-\n-extern int flag_pic;\n-\n-/* This is nonzero if the current function uses pic_offset_table_rtx.  */\n-extern int current_function_uses_pic_offset_table;\n-\n-/* This is nonzero if the current function uses the constant pool.  */\n-extern int current_function_uses_const_pool;\n-\n-/* Language-specific reason why the current function cannot be made inline.  */\n-extern char *current_function_cannot_inline;\n-\n-/* The line number of the beginning of the current function.\n-   sdbout.c needs this so that it can output relative linenumbers.  */\n-\n-#ifdef SDB_DEBUGGING_INFO /* Avoid undef sym in certain broken linkers.  */\n-extern int sdb_begin_function_line;\n-#endif\n-\n-/* File in which assembler code is being written.  */\n-\n-#ifdef BUFSIZ\n-extern FILE *asm_out_file;\n-#endif\n-\n /* Default file in which to dump debug output.  */\n \n #ifdef BUFSIZ"}, {"sha": "f39ea9c835c19901f2dad884a0195298158905fd", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -44,12 +44,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n+#include \"tree.h\"\n #include \"flags.h\"\n #include \"insn-flags.h\"\n #include \"insn-config.h\"\n #include \"output.h\"\n #include \"regs.h\"\n-#include \"tree.h\"\n+#include \"function.h\"\n #include \"output.h\"\n #include \"gcov-io.h\"\n #include \"toplev.h\""}, {"sha": "69048526eedc5540f2e7350b1e35ff10d10b670e", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -29,6 +29,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n+#include \"function.h\"\n #include \"flags.h\"\n #include \"real.h\"\n #include \"toplev.h\""}, {"sha": "766d7dc83bcdabc061e93d76f02d9baf9e656e3e", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -154,6 +154,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"function.h\"\n #include \"insn-config.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -249,8 +250,6 @@ BLOCK_NUM(insn)\n   return tmp;\n }\n \n-extern rtx forced_labels;\n-\n /* Forward declarations */\n \n static void mark_regs_pat\t\tPROTO((rtx, HARD_REG_SET *));"}, {"sha": "fc3de1c2e9702cfe4d1058389821e92a920d643a", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -30,6 +30,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n+#include \"function.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"reload.h\""}, {"sha": "8742c22e39bed95b8d7fd1abf2cf603be90f2f70", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -34,6 +34,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"insn-flags.h\"\n #include \"basic-block.h\""}, {"sha": "e551dae8cbd93d58cdce64afab9fb1cfc8a6185f", "filename": "gcc/regs.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -166,28 +166,10 @@ extern enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n \n #define REGNO_LAST_NOTE_UID(N) (VARRAY_REG (reg_n_info, N)->last_note_uid)\n \n-/* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.\n-   After rtl generation, it is 1 plus the largest register number used.  */\n-\n-extern int reg_rtx_no;\n-\n-/* Vector indexed by regno; contains 1 for a register is considered a pointer.\n-   Reloading, etc. will use a pointer register rather than a non-pointer\n-   as the base register in an address, when there is a choice of two regs.  */\n-\n-extern char *regno_pointer_flag;\n-#define REGNO_POINTER_FLAG(REGNO) regno_pointer_flag[REGNO]\n-extern int regno_pointer_flag_length;\n-\n /* List made of EXPR_LIST rtx's which gives pairs of pseudo registers\n    that have to go in the same hard reg.  */\n extern rtx regs_may_share;\n \n-/* Vector mapping pseudo regno into the REG rtx for that register.\n-   This is computed by reg_scan.  */\n-\n-extern rtx *regno_reg_rtx;\n-\n /* Flag set by local-alloc or global-alloc if they decide to allocate\n    something in a call-clobbered register.  */\n "}, {"sha": "3fecafd94b74a9f92b1330a08c44b236e87caac1", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -99,6 +99,7 @@ a register with any other reload.  */\n #include \"flags.h\"\n #include \"real.h\"\n #include \"output.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"toplev.h\"\n "}, {"sha": "e3c3a7f7a02ff18e9f02e7da7d28be80c902cb8e", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -30,6 +30,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-flags.h\"\n #include \"insn-codes.h\"\n #include \"flags.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"regs.h\"\n #include \"basic-block.h\"\n@@ -279,9 +280,6 @@ char *reload_firstobj;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* List of labels that must never be deleted.  */\n-extern rtx forced_labels;\n-\n /* List of insn_chain instructions, one for every insn that reload needs to\n    examine.  */\n struct insn_chain *reload_insn_chain;"}, {"sha": "43203350efb30db741307472caac8968549406ac", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -124,6 +124,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"rtl.h\"\n #include \"expr.h\"\n+#include \"function.h\"\n #include \"insn-config.h\"\n #include \"conditions.h\"\n #include \"hard-reg-set.h\""}, {"sha": "8bbcff0195ae5fa095045cd40a90c536c4e0915d", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -24,6 +24,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"hard-reg-set.h\"\n #include \"system.h\"\n #include \"basic-block.h\"\n+#include \"function.h\"\n #include \"regs.h\"\n #include \"flags.h\"\n #include \"output.h\""}, {"sha": "0a5e7def148ad35680afd2b9c6499f9e0faa4fde", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -392,12 +392,6 @@ DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuuis00\", 'x')\n    -3 means end of a contour; output N_RBRAC.  */\n DEF_RTL_EXPR(NOTE, \"note\", \"iuusn\", 'x')\n \n-/* INLINE_HEADER is use by inline function machinery.  The information\n-   it contains helps to build the mapping function between the rtx's of\n-   the function to be inlined and the current function being expanded.  */\n-\n-DEF_RTL_EXPR(INLINE_HEADER, \"inline_header\", \"iuuuiiiiiieeiiEeEssE\", 'x')\n-\n /* ----------------------------------------------------------------------\n    Top level constituents of INSN, JUMP_INSN and CALL_INSN.\n    ---------------------------------------------------------------------- */"}, {"sha": "508aac35a70f21be0a899db2e80c397acfab8655", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 80, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -660,68 +660,6 @@ extern char *note_insn_name[];\n /* 1 means a SYMBOL_REF has been the library function in emit_library_call.  */\n #define SYMBOL_REF_USED(RTX) ((RTX)->used)\n \n-/* For an INLINE_HEADER rtx, FIRST_FUNCTION_INSN is the first insn\n-   of the function that is not involved in copying parameters to\n-   pseudo-registers.  FIRST_PARM_INSN is the very first insn of\n-   the function, including the parameter copying.\n-   We keep this around in case we must splice\n-   this function into the assembly code at the end of the file.\n-   FIRST_LABELNO is the first label number used by the function (inclusive).\n-   LAST_LABELNO is the last label used by the function (exclusive).\n-   MAX_REGNUM is the largest pseudo-register used by that function.\n-   FUNCTION_ARGS_SIZE is the size of the argument block in the stack.\n-   POPS_ARGS is the number of bytes of input arguments popped by the function\n-   STACK_SLOT_LIST is the list of stack slots.\n-   FORCED_LABELS is the list of labels whose address was taken.\n-   FUNCTION_FLAGS are where single-bit flags are saved.\n-   OUTGOING_ARGS_SIZE is the size of the largest outgoing stack parameter list.\n-   ORIGINAL_ARG_VECTOR is a vector of the original DECL_RTX values\n-    for the function arguments.\n-   ORIGINAL_DECL_INITIAL is a pointer to the original DECL_INITIAL for the\n-    function.\n-   INLINE_REGNO_REG_RTX, INLINE_REGNO_POINTER_FLAG, and\n-    INLINE_REGNO_POINTER_ALIGN are pointers to the corresponding arrays.\n-\n-   We want this to lay down like an INSN.  The PREV_INSN field\n-   is always NULL.  The NEXT_INSN field always points to the\n-   first function insn of the function being squirreled away.  */\n-\n-#define FIRST_FUNCTION_INSN(RTX) ((RTX)->fld[2].rtx)\n-#define FIRST_PARM_INSN(RTX) ((RTX)->fld[3].rtx)\n-#define FIRST_LABELNO(RTX) ((RTX)->fld[4].rtint)\n-#define LAST_LABELNO(RTX) ((RTX)->fld[5].rtint)\n-#define MAX_PARMREG(RTX) ((RTX)->fld[6].rtint)\n-#define MAX_REGNUM(RTX) ((RTX)->fld[7].rtint)\n-#define FUNCTION_ARGS_SIZE(RTX) ((RTX)->fld[8].rtint)\n-#define POPS_ARGS(RTX) ((RTX)->fld[9].rtint)\n-#define STACK_SLOT_LIST(RTX) ((RTX)->fld[10].rtx)\n-#define FORCED_LABELS(RTX) ((RTX)->fld[11].rtx)\n-#define FUNCTION_FLAGS(RTX) ((RTX)->fld[12].rtint)\n-#define OUTGOING_ARGS_SIZE(RTX) ((RTX)->fld[13].rtint)\n-#define ORIGINAL_ARG_VECTOR(RTX) ((RTX)->fld[14].rtvec)\n-#define ORIGINAL_DECL_INITIAL(RTX) ((RTX)->fld[15].rtx)\n-#define INLINE_REGNO_REG_RTX(RTX) ((RTX)->fld[16].rtvec)\n-#define INLINE_REGNO_POINTER_FLAG(RTX) ((RTX)->fld[17].rtstr)\n-#define INLINE_REGNO_POINTER_ALIGN(RTX) ((RTX)->fld[18].rtstr)\n-#define PARMREG_STACK_LOC(RTX) ((RTX)->fld[19].rtvec)\n-\n-/* In FUNCTION_FLAGS we save some variables computed when emitting the code\n-   for the function and which must be `or'ed into the current flag values when\n-   insns from that function are being inlined.  */\n-\n-/* These ought to be an enum, but non-ANSI compilers don't like that.  */\n-#define FUNCTION_FLAGS_CALLS_ALLOCA 01\n-#define FUNCTION_FLAGS_CALLS_SETJMP 02\n-#define FUNCTION_FLAGS_RETURNS_STRUCT 04\n-#define FUNCTION_FLAGS_RETURNS_PCC_STRUCT 010\n-#define FUNCTION_FLAGS_NEEDS_CONTEXT 020\n-#define FUNCTION_FLAGS_HAS_NONLOCAL_LABEL 040\n-#define FUNCTION_FLAGS_RETURNS_POINTER 0100\n-#define FUNCTION_FLAGS_USES_CONST_POOL 0200\n-#define FUNCTION_FLAGS_CALLS_LONGJMP 0400\n-#define FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE 01000\n-#define FUNCTION_FLAGS_HAS_COMPUTED_JUMP 02000\n-\n /* Define a macro to look for REG_INC notes,\n    but save time on machines where they never exist.  */\n \n@@ -935,10 +873,6 @@ extern rtvec gen_rtvec_v\t\tPROTO((int, rtx *));\n extern rtvec gen_rtvec_vv\t\tPROTO((int, rtunion *));\n extern rtx gen_reg_rtx\t\t\tPROTO((enum machine_mode));\n extern rtx gen_label_rtx\t\tPROTO((void));\n-extern rtx gen_inline_header_rtx\tPROTO((rtx, rtx, int, int, int, int,\n-\t\t\t\t\t       int, int, rtx, rtx, int, int,\n-\t\t\t\t\t       rtvec, rtx,\n-\t\t\t\t\t       rtvec, char *, char *, rtvec));\n extern rtx gen_lowpart_common\t\tPROTO((enum machine_mode, rtx));\n extern rtx gen_lowpart\t\t\tPROTO((enum machine_mode, rtx));\n extern rtx gen_lowpart_if_possible\tPROTO((enum machine_mode, rtx));\n@@ -1309,15 +1243,6 @@ extern int cse_not_expected;\n    generate any new pseudo registers.  */\n extern int no_new_pseudos;\n \n-/* Indexed by pseudo register number, gives the rtx for that pseudo.\n-   Allocated in parallel with regno_pointer_flag.  */\n-extern rtx *regno_reg_rtx;\n-\n-/* Vector indexed by regno; contain the alignment in bytes and type\n-   pointed to for a register that contains a pointer, if known.  */\n-extern char *regno_pointer_align;\n-#define REGNO_POINTER_ALIGN(REGNO) regno_pointer_align[REGNO]\n-\n /* Translates rtx code to tree code, for those codes needed by\n    REAL_ARITHMETIC.  The function returns an int because the caller may not\n    know what `enum tree_code' means.  */\n@@ -1385,6 +1310,7 @@ extern void reorder_insns\t\t\tPROTO ((rtx, rtx, rtx));\n extern int get_max_uid\t\t\t\tPROTO ((void));\n extern int in_sequence_p\t\t\tPROTO ((void));\n extern void force_next_line_note\t\tPROTO ((void));\n+extern void clear_emit_caches\t\t\tPROTO ((void));\n extern void init_emit\t\t\t\tPROTO ((void));\n extern void init_emit_once\t\t\tPROTO ((int));\n extern void push_topmost_sequence\t\tPROTO ((void));\n@@ -1393,6 +1319,7 @@ extern int subreg_realpart_p\t\t\tPROTO ((rtx));\n extern void reverse_comparison\t\t\tPROTO ((rtx));\n extern void set_new_first_and_last_insn\t\tPROTO ((rtx, rtx));\n extern void set_new_first_and_last_label_num\tPROTO ((int, int));\n+extern void set_new_last_label_num\t\tPROTO ((int));\n extern void unshare_all_rtl\t\t\tPROTO ((rtx));\n extern void set_last_insn\t\t\tPROTO ((rtx));\n extern void link_cc0_insns\t\t\tPROTO ((rtx));\n@@ -1403,7 +1330,6 @@ extern void remove_insn\t\t\t\tPROTO ((rtx));\n extern void reorder_insns_with_line_notes\tPROTO ((rtx, rtx, rtx));\n extern void emit_insn_after_with_line_notes\tPROTO ((rtx, rtx, rtx));\n extern enum rtx_code classify_insn\t\tPROTO ((rtx));\n-extern void init_virtual_regs                   PROTO ((void));\n extern rtx emit\t\t\t\t\tPROTO ((rtx));\n /* Query and clear/ restore no_line_numbers.  This is used by the\n    switch / case handling in stmt.c to give proper line numbers in\n@@ -1471,10 +1397,6 @@ extern void expand_null_return\t\tPROTO((void));\n extern void emit_jump\t\t\tPROTO ((rtx));\n extern int preserve_subexpressions_p\tPROTO ((void));\n \n-/* List (chain of EXPR_LIST) of labels heading the current handlers for\n-   nonlocal gotos.  */\n-extern rtx nonlocal_goto_handler_labels;\n-\n /* In expr.c */\n extern void init_expr_once\t\tPROTO ((void));\n extern void move_by_pieces\t\tPROTO ((rtx, rtx, int, int));"}, {"sha": "20ca1e74e1075db23cd8e4ba2604e7b2454ae084", "filename": "gcc/sched.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -123,6 +123,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n+#include \"function.h\"\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"insn-config.h\""}, {"sha": "8c089977239243a037be672e29efb0043e4d770d", "filename": "gcc/stmt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -625,8 +625,8 @@ expand_goto (label)\n       tree link;\n \n       /* Find the corresponding handler slot for this label.  */\n-      handler_slot = p->nonlocal_goto_handler_slots;\n-      for (link = p->nonlocal_labels; TREE_VALUE (link) != label;\n+      handler_slot = p->x_nonlocal_goto_handler_slots;\n+      for (link = p->x_nonlocal_labels; TREE_VALUE (link) != label;\n \t   link = TREE_CHAIN (link))\n \thandler_slot = XEXP (handler_slot, 1);\n       handler_slot = XEXP (handler_slot, 0);\n@@ -643,7 +643,7 @@ expand_goto (label)\n       if (HAVE_nonlocal_goto)\n \temit_insn (gen_nonlocal_goto (lookup_static_chain (label),\n \t\t\t\t      copy_rtx (handler_slot),\n-\t\t\t\t      copy_rtx (p->nonlocal_goto_stack_level),\n+\t\t\t\t      copy_rtx (p->x_nonlocal_goto_stack_level),\n \t\t\t\t      label_ref));\n       else\n #endif\n@@ -669,7 +669,7 @@ expand_goto (label)\n \t\t\t\t\t   hard_frame_pointer_rtx));\n \t  \n \t  /* Restore the stack pointer.  Note this uses fp just restored.  */\n-\t  addr = p->nonlocal_goto_stack_level;\n+\t  addr = p->x_nonlocal_goto_stack_level;\n \t  if (addr)\n \t    addr = replace_rtx (copy_rtx (addr),\n \t\t\t\tvirtual_stack_vars_rtx,"}, {"sha": "fe9fb90da3dbcf1afa4ed041533a3cffafb6e333", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -1386,29 +1386,3 @@ get_best_mode (bitsize, bitpos, align, largest_mode, volatilep)\n \n   return mode;\n }\n-\f\n-/* Save all variables describing the current status into the structure *P.\n-   This is used before starting a nested function.  */\n-\n-void\n-save_storage_status (p)\n-     struct function *p ATTRIBUTE_UNUSED;\n-{\n-#if 0  /* Need not save, since always 0 and non0 (resp.) within a function.  */\n-  p->pending_sizes = pending_sizes;\n-  p->immediate_size_expand = immediate_size_expand;\n-#endif /* 0 */\n-}\n-\n-/* Restore all variables describing the current status from the structure *P.\n-   This is used after a nested function.  */\n-\n-void\n-restore_storage_status (p)\n-     struct function *p ATTRIBUTE_UNUSED;\n-{\n-#if 0\n-  pending_sizes = p->pending_sizes;\n-  immediate_size_expand = p->immediate_size_expand;\n-#endif /* 0 */\n-}"}, {"sha": "e111802867abc2e96777dddaef6ea8a98eed1e20", "filename": "gcc/stupid.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -49,6 +49,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n+#include \"function.h\"\n #include \"insn-config.h\"\n #include \"reload.h\"\n #include \"flags.h\""}, {"sha": "5c7041e654cd5544710ec7b8c9570ff870a840b3", "filename": "gcc/toplev.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -49,6 +49,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"defaults.h\"\n #include \"output.h\"\n #include \"except.h\"\n+#include \"function.h\"\n #include \"toplev.h\"\n #include \"expr.h\"\n #include \"basic-block.h\"\n@@ -266,10 +267,6 @@ struct file_stack *input_file_stack;\n /* Incremented on each change to input_file_stack.  */\n int input_file_stack_tick;\n \n-/* FUNCTION_DECL for function now being parsed or compiled.  */\n-\n-extern tree current_function_decl;\n-\n /* Name to use as base of names for dump output files.  */\n \n const char *dump_base_name;\n@@ -2952,14 +2949,18 @@ compile_file (name)\n   init_decl_processing ();\n   init_optabs ();\n   init_stmt ();\n-  init_expmed ();\n-  init_expr_once ();\n   init_loop ();\n   init_reload ();\n   init_alias_once ();\n \n+  /* The following initialization functions need to generate rtl, so\n+     provide a dummy function context for them.  */\n+  init_dummy_function_start ();\n+  init_expmed ();\n+  init_expr_once ();\n   if (flag_caller_saves)\n     init_caller_save ();\n+  expand_dummy_function_end ();\n \n   /* If auxiliary info generation is desired, open the output file.\n      This goes in the same directory as the source file--unlike\n@@ -3730,7 +3731,7 @@ rest_of_compilation (decl)\n \t    }\n #endif\n \t  TIMEVAR (integration_time, save_for_inline_nocopy (decl));\n-\t  RTX_INTEGRATED_P (DECL_SAVED_INSNS (decl)) = inlinable;\n+\t  DECL_SAVED_INSNS (decl)->inlinable = inlinable;\n \t  goto exit_rest_of_compilation;\n \t}\n \n@@ -3765,7 +3766,7 @@ rest_of_compilation (decl)\n \t  saved_block_tree = DECL_INITIAL (decl);\n \t  saved_arguments = DECL_ARGUMENTS (decl);\n \t  TIMEVAR (integration_time, save_for_inline_copying (decl));\n-\t  RTX_INTEGRATED_P (DECL_SAVED_INSNS (decl)) = inlinable;\n+\t  DECL_SAVED_INSNS (decl)->inlinable = inlinable;\n \t}\n \n       /* If specified extern inline but we aren't inlining it, we are\n@@ -3775,6 +3776,9 @@ rest_of_compilation (decl)\n \tgoto exit_rest_of_compilation;\n     }\n \n+  /* Initialize some variables used by the optimizers.  */\n+  init_function_for_compilation ();\n+\n   if (! DECL_DEFER_OUTPUT (decl))\n     TREE_ASM_WRITTEN (decl) = 1;\n \n@@ -3846,9 +3850,8 @@ rest_of_compilation (decl)\n     goto exit_rest_of_compilation;\n \n   /* Dump rtl code after jump, if we are doing that.  */\n-\n-    if (jump_opt_dump)\n-      dump_rtl (\".jump\", decl, print_rtl, insns);\n+  if (jump_opt_dump)\n+    dump_rtl (\".jump\", decl, print_rtl, insns);\n \n   /* Perform common subexpression elimination.\n      Nonzero value from `cse_main' means that jumps were simplified"}, {"sha": "8380560e8eeaf59ec12427fdaeaf58865422f38e", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -1095,7 +1095,7 @@ struct tree_type\n    where the data was actually passed.  */\n #define DECL_INCOMING_RTL(NODE) (DECL_CHECK (NODE)->decl.saved_insns.r)\n /* For FUNCTION_DECL, if it is inline, holds the saved insn chain.  */\n-#define DECL_SAVED_INSNS(NODE) (DECL_CHECK (NODE)->decl.saved_insns.r)\n+#define DECL_SAVED_INSNS(NODE) (DECL_CHECK (NODE)->decl.saved_insns.f)\n /* For FUNCTION_DECL, if it is inline,\n    holds the size of the stack frame, as an integer.  */\n #define DECL_FRAME_SIZE(NODE) (DECL_CHECK (NODE)->decl.frame_size.i)\n@@ -1363,6 +1363,7 @@ struct tree_decl\n   /* For FUNCTION_DECLs: points to insn that constitutes its definition\n      on the permanent obstack.  For FIELD_DECL, this is DECL_FIELD_SIZE.  */\n   union {\n+    struct function *f;\n     struct rtx_def *r;\n     HOST_WIDE_INT i;\n   } saved_insns;\n@@ -2202,6 +2203,8 @@ extern void setjmp_protect\t\tPROTO ((tree));\n extern void expand_main_function\tPROTO ((void));\n extern void mark_varargs\t\tPROTO ((void));\n extern void init_dummy_function_start\tPROTO ((void));\n+extern void expand_dummy_function_end\tPROTO ((void));\n+extern void init_function_for_compilation\tPROTO ((void));\n extern void init_function_start\t\tPROTO ((tree, char *, int));\n extern void assign_parms\t\tPROTO ((tree, int));\n extern void put_var_into_stack\t\tPROTO ((tree));"}, {"sha": "c2297f91b1b41cb5fd927ee689571f478a00d3e4", "filename": "gcc/unroll.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad7cfa7ac804b56cff13d70022020126f24c55/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=49ad7cfa7ac804b56cff13d70022020126f24c55", "patch": "@@ -154,6 +154,7 @@ enum unroll_types { UNROLL_COMPLETELY, UNROLL_MODULO, UNROLL_NAIVE };\n #include \"regs.h\"\n #include \"recog.h\"\n #include \"flags.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"loop.h\"\n #include \"toplev.h\"\n@@ -1180,8 +1181,8 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n     }\n \n   /* Use our current register alignment and pointer flags.  */\n-  map->regno_pointer_flag = regno_pointer_flag;\n-  map->regno_pointer_align = regno_pointer_align;\n+  map->regno_pointer_flag = current_function->emit->regno_pointer_flag;\n+  map->regno_pointer_align = current_function->emit->regno_pointer_align;\n \n   /* If the loop is being partially unrolled, and the iteration variables\n      are being split, and are being renamed for the split, then must fix up"}]}