{"sha": "10d185b9845ad96edf45d55ca066a0258d3c3f9a", "node_id": "C_kwDOANBUbNoAKDEwZDE4NWI5ODQ1YWQ5NmVkZjQ1ZDU1Y2EwNjZhMDI1OGQzYzNmOWE", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-12-06T16:23:22Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-12-09T16:51:47Z"}, "message": "Introduce access_ref::merge_ref.\n\ngcc/ChangeLog:\n\n\t* pointer-query.cc (access_ref::merge_ref): Define new function.\n\t(access_ref::get_ref): Move code into merge_ref and call it.\n\t* pointer-query.h (access_ref::merge_ref): Declare new function.", "tree": {"sha": "a291395488c5f1fe2c52aa1bf08f7faa2839a8db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a291395488c5f1fe2c52aa1bf08f7faa2839a8db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10d185b9845ad96edf45d55ca066a0258d3c3f9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d185b9845ad96edf45d55ca066a0258d3c3f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10d185b9845ad96edf45d55ca066a0258d3c3f9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d185b9845ad96edf45d55ca066a0258d3c3f9a/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9354a7d70caef1c94b8d0a66bb2fd4d86c037e7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9354a7d70caef1c94b8d0a66bb2fd4d86c037e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9354a7d70caef1c94b8d0a66bb2fd4d86c037e7d"}], "stats": {"total": 231, "additions": 147, "deletions": 84}, "files": [{"sha": "24fbac84ec4629bb2ddd4974550a3ce7f7214428", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 143, "deletions": 84, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d185b9845ad96edf45d55ca066a0258d3c3f9a/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d185b9845ad96edf45d55ca066a0258d3c3f9a/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=10d185b9845ad96edf45d55ca066a0258d3c3f9a", "patch": "@@ -624,6 +624,97 @@ access_ref::phi () const\n   return as_a <gphi *> (def_stmt);\n }\n \n+/* Determine the size and offset for ARG, append it to ALL_REFS, and\n+   merge the result with *THIS.  Ignore ARG if SKIP_NULL is set and\n+   ARG refers to the null pointer.  Return true on success and false\n+   on failure.  */\n+\n+bool\n+access_ref::merge_ref (vec<access_ref> *all_refs, tree arg, gimple *stmt,\n+\t\t       int ostype, bool skip_null,\n+\t\t       ssa_name_limit_t &snlim, pointer_query &qry)\n+{\n+  access_ref aref;\n+  if (!compute_objsize_r (arg, stmt, ostype, &aref, snlim, &qry)\n+      || aref.sizrng[0] < 0)\n+    /* This may be a PHI with all null pointer arguments.  */\n+    return false;\n+\n+  if (all_refs)\n+    {\n+      access_ref dummy_ref;\n+      aref.get_ref (all_refs, &dummy_ref, ostype, &snlim, &qry);\n+    }\n+\n+  if (TREE_CODE (arg) == SSA_NAME)\n+    qry.put_ref (arg, aref, ostype);\n+\n+  if (all_refs)\n+    all_refs->safe_push (aref);\n+\n+  aref.deref += deref;\n+\n+  bool merged_parmarray = aref.parmarray;\n+\n+  const bool nullp = skip_null && integer_zerop (arg);\n+  const offset_int maxobjsize = wi::to_offset (max_object_size ());\n+  offset_int minsize = sizrng[0];\n+\n+  if (sizrng[0] < 0)\n+    {\n+      /* If *THIS doesn't contain a meaningful result yet set it to AREF\n+\t unless the argument is null and it's okay to ignore it.  */\n+      if (!nullp)\n+\t*this = aref;\n+\n+      /* Set if the current argument refers to one or more objects of\n+\t known size (or range of sizes), as opposed to referring to\n+\t one or more unknown object(s).  */\n+      const bool arg_known_size = (aref.sizrng[0] != 0\n+\t\t\t\t   || aref.sizrng[1] != maxobjsize);\n+      if (arg_known_size)\n+\tsizrng[0] = aref.sizrng[0];\n+\n+      return true;\n+    }\n+\n+  /* Disregard null pointers in PHIs with two or more arguments.\n+     TODO: Handle this better!  */\n+  if (nullp)\n+    return true;\n+\n+  const bool known_size = (sizrng[0] != 0 || sizrng[1] != maxobjsize);\n+\n+  if (known_size && aref.sizrng[0] < minsize)\n+    minsize = aref.sizrng[0];\n+\n+  /* Determine the amount of remaining space in the argument.  */\n+  offset_int argrem[2];\n+  argrem[1] = aref.size_remaining (argrem);\n+\n+  /* Determine the amount of remaining space computed so far and\n+     if the remaining space in the argument is more use it instead.  */\n+  offset_int merged_rem[2];\n+  merged_rem[1] = size_remaining (merged_rem);\n+\n+  /* Reset the PHI's BASE0 flag if any of the nonnull arguments\n+     refers to an object at an unknown offset.  */\n+  if (!aref.base0)\n+    base0 = false;\n+\n+  if (merged_rem[1] < argrem[1]\n+      || (merged_rem[1] == argrem[1]\n+\t  && sizrng[1] < aref.sizrng[1]))\n+    /* Use the argument with the most space remaining as the result,\n+       or the larger one if the space is equal.  */\n+    *this = aref;\n+\n+  sizrng[0] = minsize;\n+  parmarray = merged_parmarray;\n+\n+  return true;\n+}\n+\n /* Determine and return the largest object to which *THIS refers.  If\n    *THIS refers to a PHI and PREF is nonnull, fill *PREF with the details\n    of the object determined by compute_objsize(ARG, OSTYPE) for each PHI\n@@ -636,23 +727,58 @@ access_ref::get_ref (vec<access_ref> *all_refs,\n \t\t     ssa_name_limit_t *psnlim /* = NULL */,\n \t\t     pointer_query *qry /* = NULL */) const\n {\n-  gphi *phi_stmt = this->phi ();\n-  if (!phi_stmt)\n-    return ref;\n+  if (!ref || TREE_CODE (ref) != SSA_NAME)\n+    return NULL;\n \n   /* FIXME: Calling get_ref() with a null PSNLIM is dangerous and might\n      cause unbounded recursion.  */\n   ssa_name_limit_t snlim_buf;\n   if (!psnlim)\n     psnlim = &snlim_buf;\n \n-  if (!psnlim->visit_phi (ref))\n-    return NULL_TREE;\n-\n   pointer_query empty_qry;\n   if (!qry)\n     qry = &empty_qry;\n \n+  if (gimple *def_stmt = SSA_NAME_DEF_STMT (ref))\n+    {\n+      if (is_gimple_assign (def_stmt))\n+\t{\n+\t  tree_code code = gimple_assign_rhs_code (def_stmt);\n+\t  if (code != MIN_EXPR && code != MAX_EXPR)\n+\t    return NULL_TREE;\n+\n+\t  access_ref aref;\n+\t  tree arg1 = gimple_assign_rhs1 (def_stmt);\n+\t  if (!aref.merge_ref (all_refs, arg1, def_stmt, ostype, false,\n+\t\t\t       *psnlim, *qry))\n+\t    return NULL_TREE;\n+\n+\t  tree arg2 = gimple_assign_rhs2 (def_stmt);\n+\t  if (!aref.merge_ref (all_refs, arg2, def_stmt, ostype, false,\n+\t\t\t       *psnlim, *qry))\n+\t    return NULL_TREE;\n+\n+\t  if (pref && pref != this)\n+\t    {\n+\t      tree ref = pref->ref;\n+\t      *pref = aref;\n+\t      pref->ref = ref;\n+\t    }\n+\n+\t  return aref.ref;\n+\t}\n+    }\n+  else\n+    return NULL_TREE;\n+\n+  gphi *phi_stmt = this->phi ();\n+  if (!phi_stmt)\n+    return ref;\n+\n+  if (!psnlim->visit_phi (ref))\n+    return NULL_TREE;\n+\n   /* The conservative result of the PHI reflecting the offset and size\n      of the largest PHI argument, regardless of whether or not they all\n      refer to the same object.  */\n@@ -670,91 +796,17 @@ access_ref::get_ref (vec<access_ref> *all_refs,\n       phi_ref = *pref;\n     }\n \n-  /* Set if any argument is a function array (or VLA) parameter not\n-     declared [static].  */\n-  bool parmarray = false;\n-  /* The size of the smallest object referenced by the PHI arguments.  */\n-  offset_int minsize = 0;\n-  const offset_int maxobjsize = wi::to_offset (max_object_size ());\n-\n   const unsigned nargs = gimple_phi_num_args (phi_stmt);\n   for (unsigned i = 0; i < nargs; ++i)\n     {\n       access_ref phi_arg_ref;\n+      bool skip_null = i || i + 1 < nargs;\n       tree arg = gimple_phi_arg_def (phi_stmt, i);\n-      if (!compute_objsize_r (arg, phi_stmt, ostype, &phi_arg_ref, *psnlim,\n-\t\t\t      qry)\n-\t  || phi_arg_ref.sizrng[0] < 0)\n-\t/* A PHI with all null pointer arguments.  */\n+      if (!phi_ref.merge_ref (all_refs, arg, phi_stmt, ostype, skip_null,\n+\t\t\t      *psnlim, *qry))\n \treturn NULL_TREE;\n-\n-      if (TREE_CODE (arg) == SSA_NAME)\n-\tqry->put_ref (arg, phi_arg_ref);\n-\n-      if (all_refs)\n-\tall_refs->safe_push (phi_arg_ref);\n-\n-      parmarray |= phi_arg_ref.parmarray;\n-\n-      const bool nullp = integer_zerop (arg) && (i || i + 1 < nargs);\n-\n-      if (phi_ref.sizrng[0] < 0)\n-\t{\n-\t  /* If PHI_REF doesn't contain a meaningful result yet set it\n-\t     to the result for the first argument.  */\n-\t  if (!nullp)\n-\t    phi_ref = phi_arg_ref;\n-\n-\t  /* Set if the current argument refers to one or more objects of\n-\t     known size (or range of sizes), as opposed to referring to\n-\t     one or more unknown object(s).  */\n-\t  const bool arg_known_size = (phi_arg_ref.sizrng[0] != 0\n-\t\t\t\t       || phi_arg_ref.sizrng[1] != maxobjsize);\n-\t  if (arg_known_size)\n-\t    minsize = phi_arg_ref.sizrng[0];\n-\n-\t  continue;\n-\t}\n-\n-      const bool phi_known_size = (phi_ref.sizrng[0] != 0\n-\t\t\t\t   || phi_ref.sizrng[1] != maxobjsize);\n-\n-      if (phi_known_size && phi_arg_ref.sizrng[0] < minsize)\n-\tminsize = phi_arg_ref.sizrng[0];\n-\n-      /* Disregard null pointers in PHIs with two or more arguments.\n-\t TODO: Handle this better!  */\n-      if (nullp)\n-\tcontinue;\n-\n-      /* Determine the amount of remaining space in the argument.  */\n-      offset_int argrem[2];\n-      argrem[1] = phi_arg_ref.size_remaining (argrem);\n-\n-      /* Determine the amount of remaining space computed so far and\n-\t if the remaining space in the argument is more use it instead.  */\n-      offset_int phirem[2];\n-      phirem[1] = phi_ref.size_remaining (phirem);\n-\n-      /* Reset the PHI's BASE0 flag if any of the nonnull arguments\n-\t refers to an object at an unknown offset.  */\n-      if (!phi_arg_ref.base0)\n-\tphi_ref.base0 = false;\n-\n-      if (phirem[1] < argrem[1]\n-\t  || (phirem[1] == argrem[1]\n-\t      && phi_ref.sizrng[1] < phi_arg_ref.sizrng[1]))\n-\t/* Use the argument with the most space remaining as the result,\n-\t   or the larger one if the space is equal.  */\n-\tphi_ref = phi_arg_ref;\n     }\n \n-  /* Replace the lower bound of the largest argument with the size\n-     of the smallest argument, and set PARMARRAY if any argument\n-     was one.  */\n-  phi_ref.sizrng[0] = minsize;\n-  phi_ref.parmarray = parmarray;\n-\n   if (phi_ref.sizrng[0] < 0)\n     {\n       /* Fail if none of the PHI's arguments resulted in updating PHI_REF\n@@ -766,7 +818,14 @@ access_ref::get_ref (vec<access_ref> *all_refs,\n \n   /* Avoid changing *THIS.  */\n   if (pref && pref != this)\n-    *pref = phi_ref;\n+    {\n+      /* Keep the SSA_NAME of the PHI unchanged so that all PHI arguments\n+\t can be referred to later if necessary.  This is useful even if\n+\t they all refer to the same object.  */\n+      tree ref = pref->ref;\n+      *pref = phi_ref;\n+      pref->ref = ref;\n+    }\n \n   psnlim->leave_phi (ref);\n "}, {"sha": "fe46f711e96b415703aaa47f7ff917e499383ad0", "filename": "gcc/pointer-query.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d185b9845ad96edf45d55ca066a0258d3c3f9a/gcc%2Fpointer-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d185b9845ad96edf45d55ca066a0258d3c3f9a/gcc%2Fpointer-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.h?ref=10d185b9845ad96edf45d55ca066a0258d3c3f9a", "patch": "@@ -66,6 +66,10 @@ struct access_ref\n   /* Return the PHI node REF refers to or null if it doesn't.  */\n   gphi *phi () const;\n \n+  /* Merge the result for a pointer with *THIS.  */\n+  bool merge_ref (vec<access_ref> *all_refs, tree, gimple *, int, bool,\n+\t\t  ssa_name_limit_t &, pointer_query &);\n+\n   /* Return the object to which REF refers.  */\n   tree get_ref (vec<access_ref> *, access_ref * = nullptr, int = 1,\n \t\tssa_name_limit_t * = nullptr, pointer_query * = nullptr) const;"}]}