{"sha": "ef83161cd8c6e5cb95bb621d1ed2b3831f2648be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY4MzE2MWNkOGM2ZTVjYjk1YmI2MjFkMWVkMmIzODMxZjI2NDhiZQ==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@gnat.com", "date": "2002-03-26T21:07:04Z"}, "committer": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2002-03-26T21:07:04Z"}, "message": "* prj-makr.ads, prj-makr.adb : New files.\n\nFrom-SVN: r51406", "tree": {"sha": "b3bea72fdd756ba99df7a65285382203b646a396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3bea72fdd756ba99df7a65285382203b646a396"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef83161cd8c6e5cb95bb621d1ed2b3831f2648be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef83161cd8c6e5cb95bb621d1ed2b3831f2648be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef83161cd8c6e5cb95bb621d1ed2b3831f2648be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef83161cd8c6e5cb95bb621d1ed2b3831f2648be/comments", "author": null, "committer": null, "parents": [{"sha": "1f3f6dadcbc709ed1a2aa24f28c0e72bc7da8cf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3f6dadcbc709ed1a2aa24f28c0e72bc7da8cf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3f6dadcbc709ed1a2aa24f28c0e72bc7da8cf4"}], "stats": {"total": 1085, "additions": 1085, "deletions": 0}, "files": [{"sha": "e33fc4a406c4924c4430db13c5ea59df52bf0376", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef83161cd8c6e5cb95bb621d1ed2b3831f2648be/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef83161cd8c6e5cb95bb621d1ed2b3831f2648be/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ef83161cd8c6e5cb95bb621d1ed2b3831f2648be", "patch": "@@ -1,3 +1,7 @@\n+2002-03-27  Geert Bosch  <bosch@gnat.com>\n+\n+\t* prj-makr.ads, prj-makr.adb : New files.\n+\n 2002-03-26  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* misc.c (LANG_HOOKS_MARK_TREE): Redefine."}, {"sha": "b74b5664d49b8596f9e31f7853fd852215f75a53", "filename": "gcc/ada/prj-makr.adb", "status": "added", "additions": 1016, "deletions": 0, "changes": 1016, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef83161cd8c6e5cb95bb621d1ed2b3831f2648be/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef83161cd8c6e5cb95bb621d1ed2b3831f2648be/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=ef83161cd8c6e5cb95bb621d1ed2b3831f2648be", "patch": "@@ -0,0 +1,1016 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P R J . M A K R                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 2001-2002 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Csets;\n+with Namet;    use Namet;\n+with Opt;\n+with Output;\n+with Osint;    use Osint;\n+with Prj;      use Prj;\n+with Prj.Part;\n+with Prj.PP;\n+with Prj.Tree; use Prj.Tree;\n+with Snames;   use Snames;\n+with Stringt;  use Stringt;\n+with Table;    use Table;\n+\n+with Ada.Characters.Handling;   use Ada.Characters.Handling;\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.Expect;               use GNAT.Expect;\n+with GNAT.OS_Lib;               use GNAT.OS_Lib;\n+with GNAT.Regexp;               use GNAT.Regexp;\n+with GNAT.Regpat;               use GNAT.Regpat;\n+\n+package body Prj.Makr is\n+\n+   type Matched_Type is (True, False, Excluded);\n+\n+   Naming_File_Suffix      : constant String := \"_naming\";\n+   Source_List_File_Suffix : constant String := \"_source_list.txt\";\n+\n+   Output_FD   : File_Descriptor;\n+   --  To save the project file and its naming project file.\n+\n+   procedure Write_Eol;\n+   --  Output an empty line.\n+\n+   procedure Write_A_Char (C : Character);\n+   --  Write one character to Output_FD\n+\n+   procedure Write_A_String (S : String);\n+   --  Write a String to Output_FD\n+\n+   ----------\n+   -- Make --\n+   ----------\n+\n+   procedure Make\n+     (File_Path         : String;\n+      Project_File      : Boolean;\n+      Directories       : Argument_List;\n+      Name_Patterns     : Argument_List;\n+      Excluded_Patterns : Argument_List;\n+      Very_Verbose      : Boolean)\n+   is\n+      Path_Name : String (1 .. File_Path'Length +\n+                                      Project_File_Extension'Length);\n+      Path_Last : Natural := File_Path'Length;\n+\n+      Directory_Last    : Natural := 0;\n+\n+      Output_Name      : String (Path_Name'Range);\n+      Output_Name_Last : Natural;\n+      Output_Name_Id   : Name_Id;\n+\n+      Project_Node        : Project_Node_Id := Empty_Node;\n+      Project_Declaration : Project_Node_Id := Empty_Node;\n+      Source_Dirs_List    : Project_Node_Id := Empty_Node;\n+      Current_Source_Dir  : Project_Node_Id := Empty_Node;\n+\n+      Project_Naming_Node : Project_Node_Id := Empty_Node;\n+      Project_Naming_Decl : Project_Node_Id := Empty_Node;\n+      Naming_Package      : Project_Node_Id := Empty_Node;\n+\n+      Project_Naming_File_Name : String (1 .. Output_Name'Length +\n+                                                Naming_File_Suffix'Length);\n+\n+      Project_Naming_Last : Natural;\n+      Project_Naming_Id   : Name_Id := No_Name;\n+\n+      Excluded_Expressions : array (Excluded_Patterns'Range) of Regexp;\n+      Regular_Expressions  : array (Name_Patterns'Range) of Regexp;\n+\n+      Source_List_Path : String (1 .. Output_Name'Length +\n+                                        Source_List_File_Suffix'Length);\n+      Source_List_Last : Natural;\n+\n+      Source_List_FD : File_Descriptor;\n+\n+      Str     : String (1 .. 2_000);\n+      Last    : Natural;\n+      Dir     : Dir_Type;\n+\n+      PD      : Process_Descriptor;\n+      Result  : Expect_Match;\n+      Matcher : constant Pattern_Matcher :=\n+                  Compile (Expression => \"expected|Unit.*\\)|No such\");\n+\n+      Args : Argument_List :=\n+        (1 => new String'(\"-c\"),\n+         2 => new String'(\"-gnats\"),\n+         3 => new String'(\"-gnatu\"),\n+         4 => new String'(\"-x\"),\n+         5 => new String'(\"ada\"),\n+         6 => null);\n+\n+      type SFN_Pragma is record\n+        Unit : String_Access;\n+        File : String_Access;\n+        Spec : Boolean;\n+      end record;\n+\n+      package SFN_Pragmas is new Table.Table\n+        (Table_Component_Type => SFN_Pragma,\n+         Table_Index_Type     => Natural,\n+         Table_Low_Bound      => 0,\n+         Table_Initial        => 50,\n+         Table_Increment      => 50,\n+         Table_Name           => \"Prj.Makr.SFN_Pragmas\");\n+\n+   begin\n+      --  Do some needed initializations\n+\n+      Csets.Initialize;\n+      Namet.Initialize;\n+      Snames.Initialize;\n+      Prj.Initialize;\n+\n+      SFN_Pragmas.Set_Last (0);\n+\n+      --  Get the path and file names\n+\n+      if File_Names_Case_Sensitive then\n+         Path_Name (1 .. Path_Last) := File_Path;\n+      else\n+         Path_Name (1 .. Path_Last) := To_Lower (File_Path);\n+      end if;\n+\n+      Path_Name (Path_Last + 1 .. Path_Name'Last) :=\n+        Project_File_Extension;\n+\n+      --  Get the end of directory information, if any\n+\n+      for Index in reverse 1 .. Path_Last loop\n+         if Path_Name (Index) = Directory_Separator then\n+            Directory_Last := Index;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      if Project_File then\n+         if Path_Last < Project_File_Extension'Length + 1\n+           or else Path_Name\n+                 (Path_Last - Project_File_Extension'Length + 1 .. Path_Last)\n+                    /= Project_File_Extension\n+         then\n+            Path_Last := Path_Name'Last;\n+         end if;\n+\n+         Output_Name (1 .. Path_Last) := To_Lower (Path_Name (1 .. Path_Last));\n+         Output_Name_Last := Path_Last - Project_File_Extension'Length;\n+\n+         if Directory_Last /= 0 then\n+            Output_Name (1 .. Output_Name_Last - Directory_Last) :=\n+              Output_Name (Directory_Last + 1 .. Output_Name_Last);\n+            Output_Name_Last := Output_Name_Last - Directory_Last;\n+         end if;\n+\n+         --  Get the project name id\n+\n+         Name_Len := Output_Name_Last;\n+         Name_Buffer (1 .. Name_Len) := Output_Name (1 .. Name_Len);\n+         Output_Name_Id := Name_Find;\n+\n+         --  Create the project naming file name\n+\n+         Project_Naming_Last := Output_Name_Last;\n+         Project_Naming_File_Name (1 .. Project_Naming_Last) :=\n+           Output_Name (1 .. Project_Naming_Last);\n+         Project_Naming_File_Name\n+           (Project_Naming_Last + 1 ..\n+            Project_Naming_Last + Naming_File_Suffix'Length) :=\n+           Naming_File_Suffix;\n+         Project_Naming_Last :=\n+           Project_Naming_Last + Naming_File_Suffix'Length;\n+\n+         --  Get the project naming id\n+\n+         Name_Len := Project_Naming_Last;\n+         Name_Buffer (1 .. Name_Len) :=\n+           Project_Naming_File_Name (1 .. Name_Len);\n+         Project_Naming_Id := Name_Find;\n+\n+         Project_Naming_File_Name\n+           (Project_Naming_Last + 1 ..\n+            Project_Naming_Last + Project_File_Extension'Length) :=\n+           Project_File_Extension;\n+         Project_Naming_Last :=\n+           Project_Naming_Last + Project_File_Extension'Length;\n+\n+         --  Create the source list file name\n+\n+         Source_List_Last := Output_Name_Last;\n+         Source_List_Path (1 .. Source_List_Last) :=\n+           Output_Name (1 .. Source_List_Last);\n+         Source_List_Path\n+           (Source_List_Last + 1 ..\n+            Source_List_Last + Source_List_File_Suffix'Length) :=\n+           Source_List_File_Suffix;\n+         Source_List_Last := Source_List_Last + Source_List_File_Suffix'Length;\n+\n+         --  Add the project file extension to the project name\n+\n+         Output_Name\n+           (Output_Name_Last + 1 ..\n+            Output_Name_Last + Project_File_Extension'Length) :=\n+           Project_File_Extension;\n+         Output_Name_Last := Output_Name_Last + Project_File_Extension'Length;\n+      end if;\n+\n+      --  Change the current directory to the directory of the project file,\n+      --  if any directory information is specified.\n+\n+      if Directory_Last /= 0 then\n+         begin\n+            Change_Dir (Path_Name (1 .. Directory_Last));\n+         exception\n+            when Directory_Error =>\n+               Fail (\"unknown directory \"\"\" &\n+                     Path_Name (1 .. Directory_Last) & '\"');\n+         end;\n+      end if;\n+\n+      if Project_File then\n+\n+         --  Delete the source list file, if it already exists\n+\n+         declare\n+            Discard : Boolean;\n+\n+         begin\n+            Delete_File\n+              (Source_List_Path (1 .. Source_List_Last),\n+               Success => Discard);\n+         end;\n+\n+         --  And create a new source list file.\n+         --  Fail if file cannot be created.\n+\n+         Source_List_FD := Create_New_File\n+           (Name  => Source_List_Path (1 .. Source_List_Last),\n+            Fmode => Text);\n+\n+         if Source_List_FD = Invalid_FD then\n+            Fail (\"cannot create file \"\"\" &\n+                  Source_List_Path (1 .. Source_List_Last) & '\"');\n+         end if;\n+      end if;\n+\n+      --  Compile the regular expressions. Fails immediately if any of\n+      --  the specified strings is in error.\n+\n+      for Index in Excluded_Expressions'Range loop\n+         begin\n+            Excluded_Expressions (Index) :=\n+              Compile (Pattern => Excluded_Patterns (Index).all, Glob => True);\n+\n+         exception\n+            when Error_In_Regexp =>\n+               Fail (\"invalid regular expression \"\"\" &\n+                     Excluded_Patterns (Index).all & '\"');\n+         end;\n+      end loop;\n+\n+      for Index in Regular_Expressions'Range loop\n+         begin\n+            Regular_Expressions (Index) :=\n+              Compile (Pattern => Name_Patterns (Index).all, Glob => True);\n+\n+         exception\n+            when Error_In_Regexp =>\n+               Fail (\"invalid regular expression \"\"\" &\n+                     Name_Patterns (Index).all & '\"');\n+         end;\n+      end loop;\n+\n+      if Project_File then\n+         if Opt.Verbose_Mode then\n+            Output.Write_Str (\"Naming project file name is \"\"\");\n+            Output.Write_Str\n+              (Project_Naming_File_Name (1 .. Project_Naming_Last));\n+            Output.Write_Line (\"\"\"\");\n+         end if;\n+\n+         --  If there is already a project file with the specified name,\n+         --  parse it to get the components that are not automatically\n+         --  generated.\n+\n+         if Is_Regular_File (Output_Name (1 .. Output_Name_Last)) then\n+            if Opt.Verbose_Mode then\n+               Output.Write_Str (\"Parsing already existing project file \"\"\");\n+               Output.Write_Str (Output_Name (1 .. Output_Name_Last));\n+               Output.Write_Line (\"\"\"\");\n+            end if;\n+\n+            Part.Parse\n+              (Project           => Project_Node,\n+               Project_File_Name => Output_Name (1 .. Output_Name_Last),\n+               Always_Errout_Finalize => False);\n+\n+            --  If parsing was successful, remove the components that are\n+            --  automatically generated, if any, so that they will be\n+            --  unconditionally added later.\n+\n+            if Project_Node /= Empty_Node then\n+\n+               --  Remove the with clause for the naming project file\n+\n+               declare\n+                  With_Clause : Project_Node_Id :=\n+                    First_With_Clause_Of (Project_Node);\n+                  Previous    : Project_Node_Id := Empty_Node;\n+\n+               begin\n+                  while With_Clause /= Empty_Node loop\n+                     if Tree.Name_Of (With_Clause) = Project_Naming_Id then\n+                        if Previous = Empty_Node then\n+                           Set_First_With_Clause_Of\n+                             (Project_Node,\n+                              To => Next_With_Clause_Of (With_Clause));\n+                        else\n+                           Set_Next_With_Clause_Of\n+                             (Previous,\n+                              To => Next_With_Clause_Of (With_Clause));\n+                        end if;\n+\n+                        exit;\n+                     end if;\n+\n+                     Previous := With_Clause;\n+                     With_Clause := Next_With_Clause_Of (With_Clause);\n+                  end loop;\n+               end;\n+\n+               --  Remove attribute declarations of Source_Files,\n+               --  Source_List_File, Source_Dirs, and the declaration of\n+               --  package Naming, if they exist.\n+\n+               declare\n+                  Declaration  : Project_Node_Id :=\n+                    First_Declarative_Item_Of\n+                    (Project_Declaration_Of (Project_Node));\n+                  Previous     : Project_Node_Id := Empty_Node;\n+                  Current_Node : Project_Node_Id := Empty_Node;\n+\n+               begin\n+                  while Declaration /= Empty_Node loop\n+                     Current_Node := Current_Item_Node (Declaration);\n+\n+                     if (Kind_Of (Current_Node) = N_Attribute_Declaration\n+                           and then\n+                             (Tree.Name_Of (Current_Node) = Name_Source_Files\n+                                or else Tree.Name_Of (Current_Node) =\n+                                                        Name_Source_List_File\n+                                or else Tree.Name_Of (Current_Node) =\n+                                                        Name_Source_Dirs))\n+                       or else\n+                         (Kind_Of (Current_Node) = N_Package_Declaration\n+                            and then Tree.Name_Of (Current_Node) = Name_Naming)\n+                     then\n+                        if Previous = Empty_Node then\n+                           Set_First_Declarative_Item_Of\n+                             (Project_Declaration_Of (Project_Node),\n+                              To => Next_Declarative_Item (Declaration));\n+\n+                        else\n+                           Set_Next_Declarative_Item\n+                             (Previous,\n+                              To => Next_Declarative_Item (Declaration));\n+                        end if;\n+\n+                     else\n+                        Previous := Declaration;\n+                     end if;\n+\n+                     Declaration := Next_Declarative_Item (Declaration);\n+                  end loop;\n+               end;\n+            end if;\n+         end if;\n+\n+         --  If there were no already existing project file, or if the parsing\n+         --  was unsuccessful, create an empty project node with the correct\n+         --  name and its project declaration node.\n+\n+         if Project_Node = Empty_Node then\n+            Project_Node := Default_Project_Node (Of_Kind => N_Project);\n+            Set_Name_Of (Project_Node, To => Output_Name_Id);\n+            Set_Project_Declaration_Of\n+              (Project_Node,\n+               To => Default_Project_Node (Of_Kind => N_Project_Declaration));\n+\n+         end if;\n+\n+         --  Create the naming project node, and add an attribute declaration\n+         --  for Source_Files as an empty list, to indicate there are no\n+         --  sources in the naming project.\n+\n+         Project_Naming_Node := Default_Project_Node (Of_Kind => N_Project);\n+         Set_Name_Of (Project_Naming_Node, To => Project_Naming_Id);\n+         Project_Naming_Decl :=\n+           Default_Project_Node (Of_Kind => N_Project_Declaration);\n+         Set_Project_Declaration_Of (Project_Naming_Node, Project_Naming_Decl);\n+         Naming_Package :=\n+           Default_Project_Node (Of_Kind => N_Package_Declaration);\n+         Set_Name_Of (Naming_Package, To => Name_Naming);\n+\n+         declare\n+            Decl_Item : constant Project_Node_Id :=\n+              Default_Project_Node (Of_Kind => N_Declarative_Item);\n+\n+            Attribute : constant Project_Node_Id :=\n+              Default_Project_Node\n+              (Of_Kind => N_Attribute_Declaration,\n+               And_Expr_Kind => List);\n+\n+            Expression : constant Project_Node_Id :=\n+              Default_Project_Node\n+              (Of_Kind => N_Expression,\n+               And_Expr_Kind => List);\n+\n+            Term  : constant Project_Node_Id :=\n+              Default_Project_Node\n+              (Of_Kind => N_Term,\n+               And_Expr_Kind => List);\n+\n+            Empty_List : constant Project_Node_Id :=\n+              Default_Project_Node\n+              (Of_Kind => N_Literal_String_List);\n+\n+         begin\n+            Set_First_Declarative_Item_Of\n+              (Project_Naming_Decl, To => Decl_Item);\n+            Set_Next_Declarative_Item (Decl_Item, Naming_Package);\n+            Set_Current_Item_Node (Decl_Item, To => Attribute);\n+            Set_Name_Of (Attribute, To => Name_Source_Files);\n+            Set_Expression_Of (Attribute, To => Expression);\n+            Set_First_Term (Expression, To => Term);\n+            Set_Current_Term (Term, To => Empty_List);\n+         end;\n+\n+         --  Add a with clause on the naming project in the main project\n+\n+         declare\n+            With_Clause : constant Project_Node_Id :=\n+              Default_Project_Node (Of_Kind => N_With_Clause);\n+\n+         begin\n+            Set_Next_With_Clause_Of\n+              (With_Clause, To => First_With_Clause_Of (Project_Node));\n+            Set_First_With_Clause_Of (Project_Node, To => With_Clause);\n+            Set_Name_Of (With_Clause, To => Project_Naming_Id);\n+            Start_String;\n+            Store_String_Chars\n+              (Project_Naming_File_Name (1 .. Project_Naming_Last));\n+            Set_String_Value_Of (With_Clause, To => End_String);\n+         end;\n+\n+         Project_Declaration := Project_Declaration_Of (Project_Node);\n+\n+         --  Add a renaming declaration for package Naming in the main project\n+\n+         declare\n+            Decl_Item  : constant Project_Node_Id :=\n+              Default_Project_Node (Of_Kind => N_Declarative_Item);\n+\n+            Naming : constant Project_Node_Id :=\n+              Default_Project_Node (Of_Kind => N_Package_Declaration);\n+         begin\n+            Set_Next_Declarative_Item\n+              (Decl_Item,\n+               To => First_Declarative_Item_Of (Project_Declaration));\n+            Set_First_Declarative_Item_Of\n+              (Project_Declaration, To => Decl_Item);\n+            Set_Current_Item_Node (Decl_Item, To => Naming);\n+            Set_Name_Of (Naming, To => Name_Naming);\n+            Set_Project_Of_Renamed_Package_Of\n+              (Naming, To => Project_Naming_Node);\n+         end;\n+\n+         --  Add an attribute declaration for Source_Dirs, initialized as an\n+         --  empty list. Directories will be added as they are read from the\n+         --  directory list file.\n+\n+         declare\n+            Decl_Item  : constant Project_Node_Id :=\n+              Default_Project_Node (Of_Kind => N_Declarative_Item);\n+\n+            Attribute : constant Project_Node_Id :=\n+              Default_Project_Node\n+              (Of_Kind => N_Attribute_Declaration,\n+               And_Expr_Kind => List);\n+\n+            Expression : constant Project_Node_Id :=\n+              Default_Project_Node\n+              (Of_Kind => N_Expression,\n+               And_Expr_Kind => List);\n+\n+            Term  : constant Project_Node_Id :=\n+              Default_Project_Node\n+              (Of_Kind => N_Term, And_Expr_Kind => List);\n+\n+         begin\n+            Set_Next_Declarative_Item\n+              (Decl_Item,\n+               To => First_Declarative_Item_Of (Project_Declaration));\n+            Set_First_Declarative_Item_Of\n+              (Project_Declaration, To => Decl_Item);\n+            Set_Current_Item_Node (Decl_Item, To => Attribute);\n+            Set_Name_Of (Attribute, To => Name_Source_Dirs);\n+            Set_Expression_Of (Attribute, To => Expression);\n+            Set_First_Term (Expression, To => Term);\n+            Source_Dirs_List :=\n+              Default_Project_Node (Of_Kind => N_Literal_String_List,\n+                                    And_Expr_Kind => List);\n+            Set_Current_Term (Term, To => Source_Dirs_List);\n+         end;\n+\n+         --  Add an attribute declaration for Source_List_File with the\n+         --  source list file name that will be created.\n+\n+         declare\n+            Decl_Item  : constant Project_Node_Id :=\n+              Default_Project_Node (Of_Kind => N_Declarative_Item);\n+\n+            Attribute : constant Project_Node_Id :=\n+              Default_Project_Node\n+              (Of_Kind => N_Attribute_Declaration,\n+               And_Expr_Kind => Single);\n+\n+            Expression : constant Project_Node_Id :=\n+              Default_Project_Node\n+              (Of_Kind => N_Expression,\n+               And_Expr_Kind => Single);\n+\n+            Term  : constant Project_Node_Id :=\n+              Default_Project_Node\n+              (Of_Kind => N_Term,\n+               And_Expr_Kind => Single);\n+\n+            Value : constant Project_Node_Id :=\n+              Default_Project_Node\n+              (Of_Kind => N_Literal_String,\n+               And_Expr_Kind => Single);\n+\n+         begin\n+            Set_Next_Declarative_Item\n+              (Decl_Item,\n+               To => First_Declarative_Item_Of (Project_Declaration));\n+            Set_First_Declarative_Item_Of\n+              (Project_Declaration, To => Decl_Item);\n+            Set_Current_Item_Node (Decl_Item, To => Attribute);\n+            Set_Name_Of (Attribute, To => Name_Source_List_File);\n+            Set_Expression_Of (Attribute, To => Expression);\n+            Set_First_Term (Expression, To => Term);\n+            Set_Current_Term (Term, To => Value);\n+            Start_String;\n+            Store_String_Chars (Source_List_Path (1 .. Source_List_Last));\n+            Set_String_Value_Of (Value, To => End_String);\n+         end;\n+      end if;\n+\n+      --  Process each directory\n+\n+      for Index in Directories'Range  loop\n+\n+         declare\n+            Dir_Name : constant String := Directories (Index).all;\n+            Matched  : Matched_Type := False;\n+\n+         begin\n+            if Opt.Verbose_Mode then\n+               Output.Write_Str (\"Processing directory \"\"\");\n+               Output.Write_Str (Dir_Name);\n+               Output.Write_Line (\"\"\"\");\n+            end if;\n+\n+            if Project_File then\n+\n+               --  Add the directory in the list for attribute Source_Dirs\n+\n+               declare\n+                  Expression : constant Project_Node_Id :=\n+                    Default_Project_Node\n+                    (Of_Kind => N_Expression,\n+                     And_Expr_Kind => Single);\n+\n+                  Term : constant Project_Node_Id :=\n+                    Default_Project_Node\n+                    (Of_Kind => N_Term,\n+                     And_Expr_Kind => Single);\n+\n+                  Value : constant Project_Node_Id :=\n+                    Default_Project_Node\n+                    (Of_Kind => N_Literal_String,\n+                     And_Expr_Kind => Single);\n+\n+               begin\n+                  if Current_Source_Dir = Empty_Node then\n+                     Set_First_Expression_In_List\n+                       (Source_Dirs_List, To => Expression);\n+                  else\n+                     Set_Next_Expression_In_List\n+                       (Current_Source_Dir, To => Expression);\n+                  end if;\n+\n+                  Current_Source_Dir := Expression;\n+                  Set_First_Term (Expression, To => Term);\n+                  Set_Current_Term (Term, To => Value);\n+                  Start_String;\n+                  Store_String_Chars (S => Dir_Name);\n+                  Set_String_Value_Of (Value, To => End_String);\n+               end;\n+            end if;\n+\n+            --  Get the source file names from the directory.\n+            --  Fails if the directory does not exist.\n+\n+            begin\n+               Open (Dir, Dir_Name);\n+\n+            exception\n+               when Directory_Error =>\n+                  Fail (\"cannot open directory \"\"\" & Dir_Name & '\"');\n+            end;\n+\n+            --  Process each regular file in the directory\n+\n+            loop\n+               Read (Dir, Str, Last);\n+               exit when Last = 0;\n+\n+               if Is_Regular_File\n+                 (Dir_Name & Directory_Separator & Str (1 .. Last))\n+               then\n+                  Matched := True;\n+\n+                  --  First, check if the file name matches at least one of\n+                  --  the excluded expressions;\n+\n+                  for Index in Excluded_Expressions'Range loop\n+                     if\n+                       Match (Str (1 .. Last), Excluded_Expressions (Index))\n+                     then\n+                        Matched := Excluded;\n+                        exit;\n+                     end if;\n+                  end loop;\n+\n+                  --  If it does not match any of the excluded expressions,\n+                  --  check if the file name matches at least one of the\n+                  --  regular expressions.\n+\n+                  if Matched = True then\n+                     Matched := False;\n+                     for Index in Regular_Expressions'Range loop\n+                        if\n+                          Match (Str (1 .. Last), Regular_Expressions (Index))\n+                        then\n+                           Matched := True;\n+                           exit;\n+                        end if;\n+                     end loop;\n+                  end if;\n+\n+                  if Very_Verbose\n+                    or else (Matched = True and then Opt.Verbose_Mode)\n+                  then\n+                     Output.Write_Str (\"   Checking \"\"\");\n+                     Output.Write_Str (Str (1 .. Last));\n+                     Output.Write_Str (\"\"\": \");\n+                  end if;\n+\n+                  --  If the file name matches one of the regular expressions,\n+                  --  parse it to get its unit name.\n+\n+                  if Matched = True then\n+                     Args (6) := new String'\n+                       (Dir_Name &\n+                        Directory_Separator &\n+                        Str (1 .. Last));\n+\n+                     begin\n+                        Non_Blocking_Spawn\n+                          (PD, \"gcc\", Args, Err_To_Out => True);\n+                        Expect (PD, Result, Matcher);\n+\n+                     exception\n+                        when Process_Died =>\n+                           if Opt.Verbose_Mode then\n+                              Output.Write_Str (\"(process died) \");\n+                           end if;\n+\n+                           Result := Expect_Timeout;\n+                     end;\n+\n+                     if Result /= Expect_Timeout then\n+\n+                        --  If we got a unit name, this is a valid source file\n+\n+                        declare\n+                           S : constant String := Expect_Out_Match (PD);\n+\n+                        begin\n+                           if S'Length >= 13\n+                             and then S (S'First .. S'First + 3) = \"Unit\"\n+                           then\n+                              if Opt.Verbose_Mode then\n+                                 Output.Write_Str\n+                                   (S (S'Last - 4 .. S'Last - 1));\n+                                 Output.Write_Str (\" of \");\n+                                 Output.Write_Line\n+                                   (S (S'First + 5 .. S'Last - 7));\n+                              end if;\n+\n+                              if Project_File then\n+\n+                                 --  Add the corresponding attribute in the\n+                                 --  Naming package of the naming project.\n+\n+                                 declare\n+                                    Decl_Item : constant Project_Node_Id :=\n+                                      Default_Project_Node\n+                                      (Of_Kind =>\n+                                         N_Declarative_Item);\n+\n+                                    Attribute : constant Project_Node_Id :=\n+                                      Default_Project_Node\n+                                      (Of_Kind =>\n+                                         N_Attribute_Declaration);\n+\n+                                    Expression : constant Project_Node_Id :=\n+                                      Default_Project_Node\n+                                      (Of_Kind => N_Expression,\n+                                       And_Expr_Kind => Single);\n+\n+                                    Term : constant Project_Node_Id :=\n+                                      Default_Project_Node\n+                                      (Of_Kind => N_Term,\n+                                       And_Expr_Kind => Single);\n+\n+                                    Value : constant Project_Node_Id :=\n+                                      Default_Project_Node\n+                                      (Of_Kind => N_Literal_String,\n+                                       And_Expr_Kind => Single);\n+\n+                                 begin\n+                                    Set_Next_Declarative_Item\n+                                      (Decl_Item,\n+                                       To => First_Declarative_Item_Of\n+                                       (Naming_Package));\n+                                    Set_First_Declarative_Item_Of\n+                                      (Naming_Package, To => Decl_Item);\n+                                    Set_Current_Item_Node\n+                                      (Decl_Item, To => Attribute);\n+\n+                                    if S (S'Last - 5 .. S'Last) = \"(spec)\" then\n+                                       Set_Name_Of\n+                                         (Attribute, To => Name_Specification);\n+                                    else\n+                                       Set_Name_Of\n+                                         (Attribute,\n+                                          To => Name_Implementation);\n+                                    end if;\n+\n+                                    Start_String;\n+                                    Store_String_Chars\n+                                      (To_Lower\n+                                       (S (S'First + 5 .. S'Last - 7)));\n+                                    Set_Associative_Array_Index_Of\n+                                      (Attribute, To => End_String);\n+\n+                                    Set_Expression_Of\n+                                      (Attribute, To => Expression);\n+                                    Set_First_Term (Expression, To => Term);\n+                                    Set_Current_Term (Term, To => Value);\n+\n+                                    Start_String;\n+                                    Store_String_Chars (Str (1 .. Last));\n+                                    Set_String_Value_Of\n+                                      (Value, To => End_String);\n+                                 end;\n+\n+                                 --  Add source file name to source list file\n+\n+                                 Last := Last + 1;\n+                                 Str (Last) := ASCII.LF;\n+\n+                                 if Write (Source_List_FD,\n+                                           Str (1)'Address,\n+                                           Last) /= Last\n+                                 then\n+                                    Fail (\"disk full\");\n+                                 end if;\n+                              else\n+                                 --  Add an entry in the SFN_Pragmas table\n+\n+                                 SFN_Pragmas.Increment_Last;\n+                                 SFN_Pragmas.Table (SFN_Pragmas.Last) :=\n+                                   (Unit => new String'\n+                                    (S (S'First + 5 .. S'Last - 7)),\n+                                    File => new String'(Str (1 .. Last)),\n+                                    Spec => S (S'Last - 5 .. S'Last)\n+                                    = \"(spec)\");\n+                              end if;\n+\n+                           else\n+                              if Opt.Verbose_Mode then\n+                                 Output.Write_Line (\"not a unit\");\n+                              end if;\n+                           end if;\n+                        end;\n+\n+                     else\n+                        if Opt.Verbose_Mode then\n+                           Output.Write_Line (\"not a unit\");\n+                        end if;\n+                     end if;\n+\n+                     Close (PD);\n+\n+                  else\n+                     if Very_Verbose then\n+                        if Matched = False then\n+                           Output.Write_Line (\"no match\");\n+\n+                        else\n+                           Output.Write_Line (\"excluded\");\n+                        end if;\n+                     end if;\n+                  end if;\n+               end if;\n+            end loop;\n+\n+            Close (Dir);\n+         end;\n+      end loop;\n+\n+      if Project_File then\n+         Close (Source_List_FD);\n+      end if;\n+\n+      declare\n+         Discard : Boolean;\n+\n+      begin\n+         --  Delete the file if it already exists\n+\n+         Delete_File\n+           (Path_Name (Directory_Last + 1 .. Path_Last),\n+            Success => Discard);\n+\n+         --  Create a new one\n+\n+         if Opt.Verbose_Mode then\n+            Output.Write_Str (\"Creating new file \"\"\");\n+            Output.Write_Str (Path_Name (Directory_Last + 1 .. Path_Last));\n+            Output.Write_Line (\"\"\"\");\n+         end if;\n+\n+         Output_FD := Create_New_File\n+           (Path_Name (Directory_Last + 1 .. Path_Last),\n+            Fmode => Text);\n+\n+         --  Fails if project file cannot be created\n+\n+         if Output_FD = Invalid_FD then\n+            Fail (\"cannot create new \"\"\" & Path_Name (1 .. Path_Last) & '\"');\n+         end if;\n+\n+         if Project_File then\n+\n+            --  Output the project file\n+\n+            Prj.PP.Pretty_Print\n+              (Project_Node,\n+               W_Char => Write_A_Char'Access,\n+               W_Eol  => Write_Eol'Access,\n+               W_Str  => Write_A_String'Access);\n+            Close (Output_FD);\n+\n+            --  Delete the naming project file if it already exists\n+\n+            Delete_File\n+              (Project_Naming_File_Name (1 .. Project_Naming_Last),\n+               Success => Discard);\n+\n+            --  Create a new one\n+\n+            if Opt.Verbose_Mode then\n+               Output.Write_Str (\"Creating new naming project file \"\"\");\n+               Output.Write_Str (Project_Naming_File_Name\n+                                 (1 .. Project_Naming_Last));\n+               Output.Write_Line (\"\"\"\");\n+            end if;\n+\n+            Output_FD := Create_New_File\n+              (Project_Naming_File_Name (1 .. Project_Naming_Last),\n+               Fmode => Text);\n+\n+            --  Fails if naming project file cannot be created\n+\n+            if Output_FD = Invalid_FD then\n+               Fail (\"cannot create new \"\"\" &\n+                     Project_Naming_File_Name (1 .. Project_Naming_Last) &\n+                     '\"');\n+            end if;\n+\n+            --  Output the naming project file\n+\n+            Prj.PP.Pretty_Print\n+              (Project_Naming_Node,\n+               W_Char => Write_A_Char'Access,\n+               W_Eol  => Write_Eol'Access,\n+               W_Str  => Write_A_String'Access);\n+            Close (Output_FD);\n+\n+         else\n+            --  Write to the output file each entry in the SFN_Pragmas table\n+            --  as an pragma Source_File_Name.\n+\n+            for Index in 1 .. SFN_Pragmas.Last loop\n+               Write_A_String (\"pragma Source_File_Name\");\n+               Write_Eol;\n+               Write_A_String (\"  (\");\n+               Write_A_String (SFN_Pragmas.Table (Index).Unit.all);\n+               Write_A_String (\",\");\n+               Write_Eol;\n+\n+               if SFN_Pragmas.Table (Index).Spec then\n+                  Write_A_String (\"   Spec_File_Name => \"\"\");\n+\n+               else\n+                  Write_A_String (\"   Body_File_Name => \"\"\");\n+               end if;\n+\n+               Write_A_String (SFN_Pragmas.Table (Index).File.all);\n+               Write_A_String (\"\"\");\");\n+               Write_Eol;\n+            end loop;\n+\n+            Close (Output_FD);\n+         end if;\n+      end;\n+\n+   end Make;\n+\n+   ----------------\n+   -- Write_Char --\n+   ----------------\n+   procedure Write_A_Char (C : Character) is\n+   begin\n+      Write_A_String ((1 => C));\n+   end Write_A_Char;\n+\n+   ---------------\n+   -- Write_Eol --\n+   ---------------\n+\n+   procedure Write_Eol is\n+   begin\n+      Write_A_String ((1 => ASCII.LF));\n+   end Write_Eol;\n+\n+   --------------------\n+   -- Write_A_String --\n+   --------------------\n+\n+   procedure Write_A_String (S : String) is\n+      Str : String (1 .. S'Length);\n+\n+   begin\n+      if S'Length > 0 then\n+         Str := S;\n+\n+         if Write (Output_FD, Str (1)'Address, Str'Length) /= Str'Length then\n+            Fail (\"disk full\");\n+         end if;\n+      end if;\n+   end Write_A_String;\n+\n+end Prj.Makr;"}, {"sha": "4bba35c6cc3de83c209f1d6ee47e0f3c716209ed", "filename": "gcc/ada/prj-makr.ads", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef83161cd8c6e5cb95bb621d1ed2b3831f2648be/gcc%2Fada%2Fprj-makr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef83161cd8c6e5cb95bb621d1ed2b3831f2648be/gcc%2Fada%2Fprj-makr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.ads?ref=ef83161cd8c6e5cb95bb621d1ed2b3831f2648be", "patch": "@@ -0,0 +1,65 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P R J . M A K R                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--             Copyright (C) 2001-2002 Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Support for procedure Gnatname.\n+\n+--  For arbitrary naming schemes, create or update a project file,\n+--  or create a configuration pragmas file.\n+\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+\n+package Prj.Makr is\n+\n+   procedure Make\n+     (File_Path         : String;\n+      Project_File      : Boolean;\n+      Directories       : Argument_List;\n+      Name_Patterns     : Argument_List;\n+      Excluded_Patterns : Argument_List;\n+      Very_Verbose      : Boolean);\n+   --  Create a project file or a configuration pragmas file\n+   --\n+   --  Project_File is the path name of the project file. If the project\n+   --  file already exists parse it and keep all the elements that are not\n+   --  automatically generated.\n+   --\n+   --  Directory_List_File is the path name of a text file that\n+   --  contains on each non empty line the path names of the source\n+   --  directories for the project file. The source directories\n+   --  are relative to the directory of the project file.\n+   --\n+   --  File_Name_Patterns is a GNAT.Regexp string pattern such as\n+   --  \".*\\.ads|.*\\.adb\" or any other pattern.\n+   --\n+   --  A project file (without any sources) is automatically generated\n+   --  with the name <project>_naming. It contains a package Naming with\n+   --  all the specs and bodies for the project.\n+   --  A file containing the source file names is automatically\n+   --  generated and used as the Source_File_List for the project file.\n+\n+end Prj.Makr;"}]}