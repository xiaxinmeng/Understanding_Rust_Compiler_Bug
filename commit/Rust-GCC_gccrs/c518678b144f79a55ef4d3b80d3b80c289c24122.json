{"sha": "c518678b144f79a55ef4d3b80d3b80c289c24122", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUxODY3OGIxNDRmNzlhNTVlZjRkM2I4MGQzYjgwYzI4OWMyNDEyMg==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2015-11-09T17:30:24Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2015-11-09T17:30:24Z"}, "message": "Support sized delete.\n\nThis adds transactional clones of the sized version of operator delete.\n\nFrom-SVN: r230036", "tree": {"sha": "58c417279b864efbb72173956d0999192f531ded", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58c417279b864efbb72173956d0999192f531ded"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c518678b144f79a55ef4d3b80d3b80c289c24122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c518678b144f79a55ef4d3b80d3b80c289c24122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c518678b144f79a55ef4d3b80d3b80c289c24122", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c518678b144f79a55ef4d3b80d3b80c289c24122/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d1f0d3769edfb2217f19f0937f30423e6298f744", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1f0d3769edfb2217f19f0937f30423e6298f744", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1f0d3769edfb2217f19f0937f30423e6298f744"}], "stats": {"total": 188, "additions": 139, "deletions": 49}, "files": [{"sha": "0564345903bd3b703a192237b0c44a8d8f5d788d", "filename": "libitm/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=c518678b144f79a55ef4d3b80d3b80c289c24122", "patch": "@@ -1,3 +1,17 @@\n+2015-11-09  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* alloc_cpp.cc (_ZdlPvX, _ZdlPvXRKSt9nothrow_t, _ZGTtdlPvX,\n+\t_ZGTtdlPvXRKSt9nothrow_t, delsz_opnt): New.\n+\t* libitm.map: Add _ZGTtdlPvX and _ZGTtdlPvXRKSt9nothrow_t.\n+\t* libitm_i.h (gtm_alloc_action): Add free_fn_sz and sz.  Add comments.\n+\t(gtm_thread::forget_allocations): New overload with size_t argument.\n+\t* alloc.c (gtm_thread::forget_allocation): Define new overload and\n+\tadapt existing one.\n+\t(gtm_thread::record_allocation): Adapt.\n+\t(gtm_thread::commit_allocations_1): Adapt.\n+\t(gtm_thread::commit_allocations_2): Adapt.\n+\t* testsuite/libitm.c++/newdelete.C: New.\n+\n 2015-10-27  Daniel Jacobowitz  <dan@codesourcery.com>\n \t    Joseph Myers  <joseph@codesourcery.com>\n \t    Mark Shinwell  <shinwell@codesourcery.com>"}, {"sha": "7b8786c5ec537b23cbb610b5f38200342d3753bb", "filename": "libitm/alloc.cc", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2Falloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2Falloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Falloc.cc?ref=c518678b144f79a55ef4d3b80d3b80c289c24122", "patch": "@@ -29,26 +29,38 @@ namespace GTM HIDDEN {\n void\n gtm_thread::record_allocation (void *ptr, void (*free_fn)(void *))\n {\n-  uintptr_t iptr = (uintptr_t) ptr;\n-\n-  gtm_alloc_action *a = this->alloc_actions.find(iptr);\n-  if (a == 0)\n-    a = this->alloc_actions.insert(iptr);\n+  // We do not deallocate before outermost commit, so we should never have\n+  // an existing log entry for a new allocation.\n+  gtm_alloc_action *a = this->alloc_actions.insert((uintptr_t) ptr);\n \n   a->free_fn = free_fn;\n+  a->free_fn_sz = 0;\n   a->allocated = true;\n }\n \n void\n gtm_thread::forget_allocation (void *ptr, void (*free_fn)(void *))\n {\n-  uintptr_t iptr = (uintptr_t) ptr;\n-\n-  gtm_alloc_action *a = this->alloc_actions.find(iptr);\n-  if (a == 0)\n-    a = this->alloc_actions.insert(iptr);\n-\n+  // We do not deallocate before outermost commit, so we should never have\n+  // an existing log entry for a deallocation at the same address.  We may\n+  // have an existing entry for a matching allocation, but this is handled\n+  // correctly because both are complementary in that only one of these will\n+  // cause an action at commit or abort.\n+  gtm_alloc_action *a = this->alloc_actions.insert((uintptr_t) ptr);\n   a->free_fn = free_fn;\n+  a->free_fn_sz = 0;\n+  a->allocated = false;\n+}\n+\n+void\n+gtm_thread::forget_allocation (void *ptr, size_t sz,\n+\t\t\t       void (*free_fn_sz)(void *, size_t))\n+{\n+  // Same as forget_allocation but with a size.\n+  gtm_alloc_action *a = this->alloc_actions.insert((uintptr_t) ptr);\n+  a->free_fn = 0;\n+  a->free_fn_sz = free_fn_sz;\n+  a->sz = sz;\n   a->allocated = false;\n }\n \n@@ -67,42 +79,43 @@ commit_allocations_2 (uintptr_t key, gtm_alloc_action *a, void *data)\n \n   if (cb_data->revert_p)\n     {\n-      // Roll back nested allocations.\n+      // Roll back nested allocations, discard deallocations.\n       if (a->allocated)\n-\ta->free_fn (ptr);\n+\t{\n+\t  if (a->free_fn_sz != 0)\n+\t    a->free_fn_sz (ptr, a->sz);\n+\t  else\n+\t    a->free_fn (ptr);\n+\t}\n     }\n   else\n     {\n-      if (a->allocated)\n-\t{\n-\t  // Add nested allocations to parent transaction.\n-\t  gtm_alloc_action* a_parent = cb_data->parent->insert(key);\n-\t  *a_parent = *a;\n-\t}\n-      else\n-\t{\n-\t  // ??? We could eliminate a parent allocation that matches this\n-\t  // memory release, if we had support for removing all accesses\n-\t  // to this allocation from the transaction's undo and redo logs\n-\t  // (otherwise, the parent transaction's undo or redo might write to\n-\t  // data that is already shared again because of calling free()).\n-\t  // We don't have this support currently, and the benefit of this\n-\t  // optimization is unknown, so just add it to the parent.\n-\t  gtm_alloc_action* a_parent;\n-\t  a_parent = cb_data->parent->insert(key);\n-\t  *a_parent = *a;\n-\t}\n+      // Add allocations and deallocations to parent.\n+      // ??? We could eliminate a (parent) allocation that matches this\n+      // a deallocation, if we had support for removing all accesses\n+      // to this allocation from the transaction's undo and redo logs\n+      // (otherwise, the parent transaction's undo or redo might write to\n+      // data that is already shared again because of calling free()).\n+      // We don't have this support currently, and the benefit of this\n+      // optimization is unknown, so just add it to the parent.\n+      gtm_alloc_action* a_parent = cb_data->parent->insert(key);\n+      *a_parent = *a;\n     }\n }\n \n static void\n commit_allocations_1 (uintptr_t key, gtm_alloc_action *a, void *cb_data)\n {\n   void *ptr = (void *)key;\n-  uintptr_t revert_p = (uintptr_t) cb_data;\n+  bool revert_p = (bool) (uintptr_t) cb_data;\n \n-  if (a->allocated == revert_p)\n-    a->free_fn (ptr);\n+  if (revert_p == a->allocated)\n+    {\n+      if (a->free_fn_sz != 0)\n+\ta->free_fn_sz (ptr, a->sz);\n+      else\n+\ta->free_fn (ptr);\n+    }\n }\n \n /* Permanently commit allocated memory during transaction."}, {"sha": "13185a785d81bedbb33965c7e5c9538c688c145e", "filename": "libitm/alloc_cpp.cc", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2Falloc_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2Falloc_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Falloc_cpp.cc?ref=c518678b144f79a55ef4d3b80d3b80c289c24122", "patch": "@@ -35,41 +35,50 @@ using namespace GTM;\n \n #define _ZnwX\t\t\tS(_Znw,MANGLE_SIZE_T)\n #define _ZnaX\t\t\tS(_Zna,MANGLE_SIZE_T)\n+#define _ZdlPvX\t\t\tS(_ZdlPv,MANGLE_SIZE_T)\n #define _ZnwXRKSt9nothrow_t\tS(S(_Znw,MANGLE_SIZE_T),RKSt9nothrow_t)\n #define _ZnaXRKSt9nothrow_t\tS(S(_Zna,MANGLE_SIZE_T),RKSt9nothrow_t)\n+#define _ZdlPvXRKSt9nothrow_t\tS(S(_ZdlPv,MANGLE_SIZE_T),RKSt9nothrow_t)\n \n #define _ZGTtnwX\t\tS(_ZGTtnw,MANGLE_SIZE_T)\n #define _ZGTtnaX\t\tS(_ZGTtna,MANGLE_SIZE_T)\n+#define _ZGTtdlPvX\t\tS(_ZGTtdlPv,MANGLE_SIZE_T)\n #define _ZGTtnwXRKSt9nothrow_t\tS(S(_ZGTtnw,MANGLE_SIZE_T),RKSt9nothrow_t)\n #define _ZGTtnaXRKSt9nothrow_t\tS(S(_ZGTtna,MANGLE_SIZE_T),RKSt9nothrow_t)\n+#define _ZGTtdlPvXRKSt9nothrow_t S(S(_ZGTtdlPv,MANGLE_SIZE_T),RKSt9nothrow_t)\n \n /* Everything from libstdc++ is weak, to avoid requiring that library\n    to be linked into plain C applications using libitm.so.  */\n \n extern \"C\" {\n \n-extern void *_ZnwX (size_t) __attribute__((weak));\n-extern void _ZdlPv (void *) __attribute__((weak));\n-extern void *_ZnaX (size_t) __attribute__((weak));\n-extern void _ZdaPv (void *) __attribute__((weak));\n+extern void *_ZnwX  (size_t) __attribute__((weak));\n+extern void _ZdlPv  (void *) __attribute__((weak));\n+extern void _ZdlPvX (void *, size_t) __attribute__((weak));\n+extern void *_ZnaX  (size_t) __attribute__((weak));\n+extern void _ZdaPv  (void *) __attribute__((weak));\n \n typedef const struct nothrow_t { } *c_nothrow_p;\n \n extern void *_ZnwXRKSt9nothrow_t (size_t, c_nothrow_p) __attribute__((weak));\n extern void _ZdlPvRKSt9nothrow_t (void *, c_nothrow_p) __attribute__((weak));\n+extern void _ZdlPvXRKSt9nothrow_t\n+(void *, size_t, c_nothrow_p) __attribute__((weak));\n extern void *_ZnaXRKSt9nothrow_t (size_t, c_nothrow_p) __attribute__((weak));\n extern void _ZdaPvRKSt9nothrow_t (void *, c_nothrow_p) __attribute__((weak));\n \n #if !defined (HAVE_ELF_STYLE_WEAKREF) \n-void *_ZnwX (size_t) { return NULL; }\n-void _ZdlPv (void *) { return; }\n-void *_ZnaX (size_t) { return NULL; }\n-void _ZdaPv (void *) { return; }\n-\n-void *_ZnwXRKSt9nothrow_t (size_t, c_nothrow_p) { return NULL; }\n-void _ZdlPvRKSt9nothrow_t (void *, c_nothrow_p) { return; }\n-void *_ZnaXRKSt9nothrow_t (size_t, c_nothrow_p) { return NULL; }\n-void _ZdaPvRKSt9nothrow_t (void *, c_nothrow_p) { return; }\n+void *_ZnwX  (size_t) { return NULL; }\n+void _ZdlPv  (void *) { return; }\n+void _ZdlPvX (void *, size_t) { return; }\n+void *_ZnaX  (size_t) { return NULL; }\n+void _ZdaPv  (void *) { return; }\n+\n+void *_ZnwXRKSt9nothrow_t  (size_t, c_nothrow_p) { return NULL; }\n+void _ZdlPvRKSt9nothrow_t  (void *, c_nothrow_p) { return; }\n+void _ZdlPvXRKSt9nothrow_t (void *, size_t, c_nothrow_p) { return; }\n+void *_ZnaXRKSt9nothrow_t  (size_t, c_nothrow_p) { return NULL; }\n+void _ZdaPvRKSt9nothrow_t  (void *, c_nothrow_p) { return; }\n #endif /* HAVE_ELF_STYLE_WEAKREF */\n \n /* Wrap the delete nothrow symbols for usage with a single argument.\n@@ -89,6 +98,12 @@ del_opvnt (void *ptr)\n   _ZdaPvRKSt9nothrow_t (ptr, NULL);\n }\n \n+static void\n+delsz_opnt (void *ptr, size_t sz)\n+{\n+  _ZdlPvXRKSt9nothrow_t (ptr, sz, NULL);\n+}\n+\n /* Wrap: operator new (std::size_t sz)  */\n void *\n _ZGTtnwX (size_t sz)\n@@ -161,4 +176,20 @@ _ZGTtdaPvRKSt9nothrow_t (void *ptr, c_nothrow_p nt UNUSED)\n     gtm_thr()->forget_allocation (ptr, del_opvnt);\n }\n \n+/* Wrap: operator delete(void* ptr, std::size_t sz)  */\n+void\n+_ZGTtdlPvX (void *ptr, size_t sz)\n+{\n+  if (ptr)\n+    gtm_thr()->forget_allocation (ptr, sz, _ZdlPvX);\n+}\n+\n+/* Wrap: operator delete (void *ptr, std::size_t sz, const std::nothrow_t&)  */\n+void\n+_ZGTtdlPvXRKSt9nothrow_t (void *ptr, size_t sz, c_nothrow_p nt UNUSED)\n+{\n+  if (ptr)\n+    gtm_thr()->forget_allocation (ptr, sz, delsz_opnt);\n+}\n+\n } // extern \"C\""}, {"sha": "ac371dedee60c58c8b2d5e3b12e194eb081397e9", "filename": "libitm/libitm.map", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2Flibitm.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2Flibitm.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm.map?ref=c518678b144f79a55ef4d3b80d3b80c289c24122", "patch": "@@ -182,3 +182,8 @@ LIBITM_1.0 {\n   local:\n \t*;\n };\n+LIBITM_1.1 {\n+  global:\n+\t_ZGTtdlPv?;\n+\t_ZGTtdlPv?RKSt9nothrow_t;\n+} LIBITM_1.0;"}, {"sha": "bf8d4d1897eeda7663b74af640276f5c0745982f", "filename": "libitm/libitm_i.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2Flibitm_i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2Flibitm_i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm_i.h?ref=c518678b144f79a55ef4d3b80d3b80c289c24122", "patch": "@@ -97,11 +97,25 @@ enum gtm_restart_reason\n \n namespace GTM HIDDEN {\n \n+// A log of (de)allocation actions.  We defer handling of some actions until\n+// a commit of the outermost transaction.  We also rely on potentially having\n+// both an allocation and a deallocation for the same piece of memory in the\n+// log; the order in which such entries are processed does not matter because\n+// the actions are not in conflict (see below).\n // This type is private to alloc.c, but needs to be defined so that\n // the template used inside gtm_thread can instantiate.\n struct gtm_alloc_action\n {\n-  void (*free_fn)(void *);\n+  // Iff free_fn_sz is nonzero, it must be used instead of free_fn.\n+  union\n+  {\n+    void (*free_fn)(void *);\n+    void (*free_fn_sz)(void *, size_t);\n+  };\n+  size_t sz;\n+  // If true, this is an allocation; we discard the log entry on outermost\n+  // commit, and deallocate on abort.  If false, this is a deallocation and\n+  // we deallocate on outermost commit and discard the log entry on abort.\n   bool allocated;\n };\n \n@@ -269,6 +283,7 @@ struct gtm_thread\n   void commit_allocations (bool, aa_tree<uintptr_t, gtm_alloc_action>*);\n   void record_allocation (void *, void (*)(void *));\n   void forget_allocation (void *, void (*)(void *));\n+  void forget_allocation (void *, size_t, void (*)(void *, size_t));\n   void drop_references_allocations (const void *ptr)\n   {\n     this->alloc_actions.erase((uintptr_t) ptr);"}, {"sha": "10eba4f66d9cf17c59bd50726de9c1f1a6771318", "filename": "libitm/testsuite/libitm.c++/newdelete.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fnewdelete.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c518678b144f79a55ef4d3b80d3b80c289c24122/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fnewdelete.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fnewdelete.C?ref=c518678b144f79a55ef4d3b80d3b80c289c24122", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do run }\n+\n+int main ()\n+{\n+  atomic_commit {\n+    int* data = new int;\n+    delete data;\n+    data = new int[10];\n+    delete[] data;\n+  }\n+  return 0;\n+}"}]}