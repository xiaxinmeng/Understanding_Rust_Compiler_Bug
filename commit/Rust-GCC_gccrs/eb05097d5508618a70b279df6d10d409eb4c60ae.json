{"sha": "eb05097d5508618a70b279df6d10d409eb4c60ae", "node_id": "C_kwDOANBUbNoAKGViMDUwOTdkNTUwODYxOGE3MGIyNzlkZjZkMTBkNDA5ZWI0YzYwYWU", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-01-03T10:32:48Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-09T09:27:31Z"}, "message": "[Ada] Revamp type resolution for comparison and equality operators\n\nThe main goal was to make it symmetrical, but this also moves error handling\nentirely to the second phase of type resolution.\n\ngcc/ada/\n\n\t* einfo.ads (Access Kinds): Reorder and beef up.\n\t* sem.adb (Analyze): Call Analyze_Comparison_Equality_Op for all\n\tcomparison and equality operators.\n\t* sem_ch4.ads (Analyze_Comparison_Op): Delete.\n\t(Analyze_Equality_Op): Likewise.\n\t(Analyze_Comparison_Equality_Op): Declare.\n\t(Ambiguous_Operands): Likewise.\n\t* sem_ch4.adb (Ambiguous_Operands): Remove declaration.\n\t(Defined_In_Scope): Delete.\n\t(Find_Comparison_Types): Merge into...\n\t(Find_Equality_Types): Merge into...\n\t(Find_Comparison_Equality_Types): ...this.  Make fully symmetrical.\n\t(Analyze_Arithmetic_Op): Minor consistency tweaks.\n\t(Analyze_Comparison_Op): Merge into...\n\t(Analyze_Equality_Op): Merge into...\n\t(Analyze_Comparison_Equality_Op): ...this.  Make fully symmetrical.\n\t(Analyze_Logical_Op): Minor consistency tweaks.\n\t(Analyze_Membership_Op): Make fully symmetrical.\n\t(Analyze_One_Call): Minor comment tweak.\n\t(Analyze_Operator_Call): Call Find_Comparison_Equality_Types.\n\t(Analyze_User_Defined_Binary_Op): Make fully symmetrical.\n\t(Check_Arithmetic_Pair.Specific_Type): Delete.\n\t(Diagnose_Call): Add special handling for \"+\" operator.\n\t(Operator_Check): Call Analyze_Comparison_Equality_Op.\n\t* sem_ch8.adb (Has_Implicit_Operator): Add Is_Type guard for boolean\n\toperators, use Valid_Comparison_Arg and Valid_Equality_Arg for resp.\n\tcomparison and equality operators.\n\t* sem_res.adb (Check_For_Visible_Operator): Call Is_Visible_Operator\n\t(Make_Call_Into_Operator): Use Preserve_Comes_From_Source.\n\t(Resolve_Actuals): Deal specifically with Any_Type actuals for user-\n\tdefined comparison and equality operators.\n\t(Resolve_Call): Minor tweaks.\n\t(Resolve_Comparison_Op): Tidy up and give error for ambiguity.\n\t(Resolve_Equality_Op): Likewise, as well as other errors.\n\t(Rewrite_Renamed_Operator): Simplify.\n\t* sem_type.ads (Is_Invisible_Operator): Delete.\n\t(Is_Visible_Operator): Declare.\n\t(Has_Compatible_Type): Remove For_Comparison parameter.\n\t(Specific_Type): Declare.\n\t(Valid_Equality_Arg): Likewise.\n\t* sem_type.adb (Specific_Type): Remove declaration.\n\t(Add_One_Interp): Call Is_Visible_Operator for the visibility test.\n\t(Remove_Conversions): Rename into...\n\t(Remove_Conversions_And_Abstract_Operations): ...this.  Do not apply\n\tnumeric-type treatment to Any_Type.  Expand the special handling for\n\tabstract interpretations to second operand.  Remove obsolete code.\n\t(Disambiguate): Adjust to above renaming.  Tweak to hidden case and\n\tcall Remove_Conversions_And_Abstract_Operations for operators too.\n\t(Entity_Matches_Spec): Minor tweak.\n\t(Find_Unique_Type): Simplify and deal with user-defined literals.\n\t(Has_Compatible_Type): Remove For_Comparison parameter and adjust.\n\tCall the Is_User_Defined_Literal predicate and remove call to\n\tthe Is_Invisible_Operator predicate.\n\t(Is_Invisible_Operator): Delete.\n\t(Is_Visible_Operator): New function.\n\t(Operator_Matches_Spec): Use Valid_Equality_Arg predicate.\n\t(Specific_Type): Tidy up, make fully symmetrical and deal with\n\tprivate views the same way as Covers.\n\t(Valid_Comparison_Arg): Return true for Any_Composite/Any_String.\n\t(Valid_Equality_Arg): New function.\n\t* sem_util.ads (Is_User_Defined_Literal): Declare.\n\t* sem_util.adb (Is_User_Defined_Literal): New function.", "tree": {"sha": "34160b8f8a46ec7552f1c8e12d52cbdd75373887", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34160b8f8a46ec7552f1c8e12d52cbdd75373887"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb05097d5508618a70b279df6d10d409eb4c60ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb05097d5508618a70b279df6d10d409eb4c60ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb05097d5508618a70b279df6d10d409eb4c60ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb05097d5508618a70b279df6d10d409eb4c60ae/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "320eb42df09f3cb96fea9a7b090ae61d9edb20b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/320eb42df09f3cb96fea9a7b090ae61d9edb20b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/320eb42df09f3cb96fea9a7b090ae61d9edb20b6"}], "stats": {"total": 2312, "additions": 1056, "deletions": 1256}, "files": [{"sha": "9fed73d92a426cbedf1dd6c6561b5cd994865e4e", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=eb05097d5508618a70b279df6d10d409eb4c60ae", "patch": "@@ -4846,23 +4846,29 @@ package Einfo is\n \n --    E_Access_Type,\n --    E_General_Access_Type,\n+--    E_Anonymous_Access_Type\n+\n --    E_Access_Subprogram_Type,\n --    E_Anonymous_Access_Subprogram_Type,\n+\n --    E_Access_Protected_Subprogram_Type,\n --    E_Anonymous_Access_Protected_Subprogram_Type\n---    E_Anonymous_Access_Type.\n \n---  E_Access_Subtype is for an access subtype created by a subtype\n---  declaration.\n+--  E_Access_Subtype is for an access subtype created by a subtype declaration\n \n --  In addition, we define the kind E_Allocator_Type to label allocators.\n --  This is because special resolution rules apply to this construct.\n --  Eventually the constructs are labeled with the access type imposed by\n --  the context. The backend should never see types with this Ekind.\n \n---  Similarly, the type E_Access_Attribute_Type is used as the initial kind\n---  associated with an access attribute. After resolution a specific access\n---  type will be established as determined by the context.\n+--  Similarly, we define the kind E_Access_Attribute_Type as the initial\n+--  kind associated with an access attribute whose prefix is an object.\n+--  After resolution, a specific access type will be established instead\n+--  as determined by the context. Note that, for the case of an access\n+--  attribute whose prefix is a subprogram, we build a corresponding type\n+--  with E_Access_Subprogram_Type or E_Access_Protected_Subprogram_Type kind\n+--  but whose designated type is the subprogram itself, instead of a regular\n+--  E_Subprogram_Type entity.\n \n    --------------------------------------------------------\n    -- Description of Defined Attributes for Entity_Kinds --"}, {"sha": "ea6469007c2a00fe74e01e2c6418bbaa8bb91857", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=eb05097d5508618a70b279df6d10d409eb4c60ae", "patch": "@@ -380,22 +380,22 @@ package body Sem is\n             Analyze_Arithmetic_Op (N);\n \n          when N_Op_Eq =>\n-            Analyze_Equality_Op (N);\n+            Analyze_Comparison_Equality_Op (N);\n \n          when N_Op_Expon =>\n             Analyze_Arithmetic_Op (N);\n \n          when N_Op_Ge =>\n-            Analyze_Comparison_Op (N);\n+            Analyze_Comparison_Equality_Op (N);\n \n          when N_Op_Gt =>\n-            Analyze_Comparison_Op (N);\n+            Analyze_Comparison_Equality_Op (N);\n \n          when N_Op_Le =>\n-            Analyze_Comparison_Op (N);\n+            Analyze_Comparison_Equality_Op (N);\n \n          when N_Op_Lt =>\n-            Analyze_Comparison_Op (N);\n+            Analyze_Comparison_Equality_Op (N);\n \n          when N_Op_Minus =>\n             Analyze_Unary_Op (N);\n@@ -407,7 +407,7 @@ package body Sem is\n             Analyze_Arithmetic_Op (N);\n \n          when N_Op_Ne =>\n-            Analyze_Equality_Op (N);\n+            Analyze_Comparison_Equality_Op (N);\n \n          when N_Op_Not =>\n             Analyze_Negation (N);"}, {"sha": "68839b31345493ad9ac1719e701272077d5bc802", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 495, "deletions": 791, "changes": 1286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=eb05097d5508618a70b279df6d10d409eb4c60ae", "patch": "@@ -148,10 +148,6 @@ package body Sem_Ch4 is\n    --  like a function, but instead of a list of actuals, it is presented with\n    --  the operand of the operator node.\n \n-   procedure Ambiguous_Operands (N : Node_Id);\n-   --  For equality, membership, and comparison operators with overloaded\n-   --  arguments, list possible interpretations.\n-\n    procedure Analyze_One_Call\n       (N          : Node_Id;\n        Nam        : Entity_Id;\n@@ -184,12 +180,6 @@ package body Sem_Ch4 is\n    --  Analyze_Selected_Component after producing an invalid selector error\n    --  message.\n \n-   function Defined_In_Scope (T : Entity_Id; S : Entity_Id) return Boolean;\n-   --  Verify that type T is declared in scope S. Used to find interpretations\n-   --  for operators given by expanded names. This is abstracted as a separate\n-   --  function to handle extensions to System, where S is System, but T is\n-   --  declared in the extension.\n-\n    procedure Find_Arithmetic_Types\n      (L, R  : Node_Id;\n       Op_Id : Entity_Id;\n@@ -198,25 +188,19 @@ package body Sem_Ch4 is\n    --  pairs of interpretations for L and R that have a numeric type consistent\n    --  with the semantics of the operator.\n \n-   procedure Find_Comparison_Types\n+   procedure Find_Comparison_Equality_Types\n      (L, R  : Node_Id;\n       Op_Id : Entity_Id;\n       N     : Node_Id);\n-   --  L and R are operands of a comparison operator. Find consistent pairs of\n-   --  interpretations for L and R.\n+   --  L and R are operands of a comparison or equality operator. Find valid\n+   --  pairs of interpretations for L and R.\n \n    procedure Find_Concatenation_Types\n      (L, R  : Node_Id;\n       Op_Id : Entity_Id;\n       N     : Node_Id);\n    --  For the four varieties of concatenation\n \n-   procedure Find_Equality_Types\n-     (L, R  : Node_Id;\n-      Op_Id : Entity_Id;\n-      N     : Node_Id);\n-   --  Ditto for equality operators\n-\n    procedure Find_Boolean_Types\n      (L, R  : Node_Id;\n       Op_Id : Entity_Id;\n@@ -229,18 +213,6 @@ package body Sem_Ch4 is\n       N     : Node_Id);\n    --  Find consistent interpretation for operand of negation operator\n \n-   procedure Find_Non_Universal_Interpretations\n-     (N     : Node_Id;\n-      R     : Node_Id;\n-      Op_Id : Entity_Id;\n-      T1    : Entity_Id);\n-   --  For equality and comparison operators, the result is always boolean, and\n-   --  the legality of the operation is determined from the visibility of the\n-   --  operand types. If one of the operands has a universal interpretation,\n-   --  the legality check uses some compatible non-universal interpretation of\n-   --  the other operand. N can be an operator node, or a function call whose\n-   --  name is an operator designator.\n-\n    function Find_Primitive_Operation (N : Node_Id) return Boolean;\n    --  Find candidate interpretations for the name Obj.Proc when it appears in\n    --  a subprogram renaming declaration.\n@@ -911,12 +883,15 @@ package body Sem_Ch4 is\n    ---------------------------\n \n    procedure Analyze_Arithmetic_Op (N : Node_Id) is\n-      L     : constant Node_Id := Left_Opnd (N);\n-      R     : constant Node_Id := Right_Opnd (N);\n+      L : constant Node_Id := Left_Opnd (N);\n+      R : constant Node_Id := Right_Opnd (N);\n+\n       Op_Id : Entity_Id;\n \n    begin\n+      Set_Etype (N, Any_Type);\n       Candidate_Type := Empty;\n+\n       Analyze_Expression (L);\n       Analyze_Expression (R);\n \n@@ -926,22 +901,18 @@ package body Sem_Ch4 is\n       --  and we do not need to collect interpretations, instead we just get\n       --  the single possible interpretation.\n \n-      Op_Id := Entity (N);\n+      if Present (Entity (N)) then\n+         Op_Id := Entity (N);\n \n-      if Present (Op_Id) then\n          if Ekind (Op_Id) = E_Operator then\n-            Set_Etype (N, Any_Type);\n             Find_Arithmetic_Types (L, R, Op_Id, N);\n          else\n-            Set_Etype (N, Any_Type);\n             Add_One_Interp (N, Op_Id, Etype (Op_Id));\n          end if;\n \n       --  Entity is not already set, so we do need to collect interpretations\n \n       else\n-         Set_Etype (N, Any_Type);\n-\n          Op_Id := Get_Name_Entity_Id (Chars (N));\n          while Present (Op_Id) loop\n             if Ekind (Op_Id) = E_Operator\n@@ -1761,50 +1732,6 @@ package body Sem_Ch4 is\n       end if;\n    end Analyze_Case_Expression;\n \n-   ---------------------------\n-   -- Analyze_Comparison_Op --\n-   ---------------------------\n-\n-   procedure Analyze_Comparison_Op (N : Node_Id) is\n-      L     : constant Node_Id := Left_Opnd (N);\n-      R     : constant Node_Id := Right_Opnd (N);\n-      Op_Id : Entity_Id        := Entity (N);\n-\n-   begin\n-      Set_Etype (N, Any_Type);\n-      Candidate_Type := Empty;\n-\n-      Analyze_Expression (L);\n-      Analyze_Expression (R);\n-\n-      if Present (Op_Id) then\n-         if Ekind (Op_Id) = E_Operator then\n-            Find_Comparison_Types (L, R, Op_Id, N);\n-         else\n-            Add_One_Interp (N, Op_Id, Etype (Op_Id));\n-         end if;\n-\n-         if Is_Overloaded (L) then\n-            Set_Etype (L, Intersect_Types (L, R));\n-         end if;\n-\n-      else\n-         Op_Id := Get_Name_Entity_Id (Chars (N));\n-         while Present (Op_Id) loop\n-            if Ekind (Op_Id) = E_Operator then\n-               Find_Comparison_Types (L, R, Op_Id, N);\n-            else\n-               Analyze_User_Defined_Binary_Op (N, Op_Id);\n-            end if;\n-\n-            Op_Id := Homonym (Op_Id);\n-         end loop;\n-      end if;\n-\n-      Operator_Check (N);\n-      Check_Function_Writable_Actuals (N);\n-   end Analyze_Comparison_Op;\n-\n    ---------------------------\n    -- Analyze_Concatenation --\n    ---------------------------\n@@ -1956,14 +1883,15 @@ package body Sem_Ch4 is\n       Operator_Check (N);\n    end Analyze_Concatenation_Rest;\n \n-   -------------------------\n-   -- Analyze_Equality_Op --\n-   -------------------------\n+   ------------------------------------\n+   -- Analyze_Comparison_Equality_Op --\n+   ------------------------------------\n+\n+   procedure Analyze_Comparison_Equality_Op (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+      L   : constant Node_Id    := Left_Opnd (N);\n+      R   : constant Node_Id    := Right_Opnd (N);\n \n-   procedure Analyze_Equality_Op (N : Node_Id) is\n-      Loc   : constant Source_Ptr := Sloc (N);\n-      L     : constant Node_Id := Left_Opnd (N);\n-      R     : constant Node_Id := Right_Opnd (N);\n       Op_Id : Entity_Id;\n \n    begin\n@@ -1980,9 +1908,9 @@ package body Sem_Ch4 is\n \n       --  For the predefined case, the result is Boolean, regardless of the\n       --  type of the operands. The operands may even be limited, if they are\n-      --  generic actuals. If they are overloaded, label the left argument with\n-      --  the common type that must be present, or with the type of the formal\n-      --  of the user-defined function.\n+      --  generic actuals. If they are overloaded, label the operands with the\n+      --  common type that must be present, or with the type of the formal of\n+      --  the user-defined function.\n \n       if Present (Entity (N)) then\n          Op_Id := Entity (N);\n@@ -2001,11 +1929,20 @@ package body Sem_Ch4 is\n             end if;\n          end if;\n \n+         if Is_Overloaded (R) then\n+            if Ekind (Op_Id) = E_Operator then\n+               Set_Etype (R, Intersect_Types (L, R));\n+            else\n+               Set_Etype (R, Etype (Next_Formal (First_Formal (Op_Id))));\n+            end if;\n+         end if;\n+\n       else\n          Op_Id := Get_Name_Entity_Id (Chars (N));\n+\n          while Present (Op_Id) loop\n             if Ekind (Op_Id) = E_Operator then\n-               Find_Equality_Types (L, R, Op_Id, N);\n+               Find_Comparison_Equality_Types (L, R, Op_Id, N);\n             else\n                Analyze_User_Defined_Binary_Op (N, Op_Id);\n             end if;\n@@ -2026,7 +1963,7 @@ package body Sem_Ch4 is\n          Op_Id := Get_Name_Entity_Id (Name_Op_Eq);\n          while Present (Op_Id) loop\n             if Ekind (Op_Id) = E_Operator then\n-               Find_Equality_Types (L, R, Op_Id, N);\n+               Find_Comparison_Equality_Types (L, R, Op_Id, N);\n             else\n                Analyze_User_Defined_Binary_Op (N, Op_Id);\n             end if;\n@@ -2051,7 +1988,7 @@ package body Sem_Ch4 is\n \n       Operator_Check (N);\n       Check_Function_Writable_Actuals (N);\n-   end Analyze_Equality_Op;\n+   end Analyze_Comparison_Equality_Op;\n \n    ----------------------------------\n    -- Analyze_Explicit_Dereference --\n@@ -2259,7 +2196,6 @@ package body Sem_Ch4 is\n \n    procedure Analyze_Expression (N : Node_Id) is\n    begin\n-\n       --  If the expression is an indexed component that will be rewritten\n       --  as a container indexing, it has already been analyzed.\n \n@@ -2909,9 +2845,10 @@ package body Sem_Ch4 is\n    ------------------------\n \n    procedure Analyze_Logical_Op (N : Node_Id) is\n-      L     : constant Node_Id := Left_Opnd (N);\n-      R     : constant Node_Id := Right_Opnd (N);\n-      Op_Id : Entity_Id := Entity (N);\n+      L : constant Node_Id := Left_Opnd (N);\n+      R : constant Node_Id := Right_Opnd (N);\n+\n+      Op_Id : Entity_Id;\n \n    begin\n       Set_Etype (N, Any_Type);\n@@ -2920,14 +2857,23 @@ package body Sem_Ch4 is\n       Analyze_Expression (L);\n       Analyze_Expression (R);\n \n-      if Present (Op_Id) then\n+      --  If the entity is already set, the node is the instantiation of a\n+      --  generic node with a non-local reference, or was manufactured by a\n+      --  call to Make_Op_xxx. In either case the entity is known to be valid,\n+      --  and we do not need to collect interpretations, instead we just get\n+      --  the single possible interpretation.\n+\n+      if Present (Entity (N)) then\n+         Op_Id := Entity (N);\n \n          if Ekind (Op_Id) = E_Operator then\n             Find_Boolean_Types (L, R, Op_Id, N);\n          else\n             Add_One_Interp (N, Op_Id, Etype (Op_Id));\n          end if;\n \n+      --  Entity is not already set, so we do need to collect interpretations\n+\n       else\n          Op_Id := Get_Name_Entity_Id (Chars (N));\n          while Present (Op_Id) loop\n@@ -2954,25 +2900,24 @@ package body Sem_Ch4 is\n       L     : constant Node_Id    := Left_Opnd (N);\n       R     : constant Node_Id    := Right_Opnd (N);\n \n-      Index : Interp_Index;\n-      It    : Interp;\n-      Found : Boolean := False;\n-      I_F   : Interp_Index;\n-      T_F   : Entity_Id;\n-\n       procedure Analyze_Set_Membership;\n       --  If a set of alternatives is present, analyze each and find the\n       --  common type to which they must all resolve.\n \n-      procedure Find_Interpretation;\n-      function Find_Interpretation return Boolean;\n-      --  Routine and wrapper to find a matching interpretation\n+      function Find_Interp return Boolean;\n+      --  Find a valid interpretation of the test. Note that the context of the\n+      --  operation plays no role in resolving the operands, so that if there\n+      --  is more than one interpretation of the operands that is compatible\n+      --  with the test, the operation is ambiguous.\n+\n+      function Try_Left_Interp (T : Entity_Id) return Boolean;\n+      --  Try an interpretation of the left operand with type T. Return true if\n+      --  one interpretation (at least) of the right operand making up a valid\n+      --  operand pair exists, otherwise false if no such pair exists.\n \n-      procedure Try_One_Interp (T1 : Entity_Id);\n-      --  Routine to try one proposed interpretation. Note that the context\n-      --  of the operation plays no role in resolving the arguments, so that\n-      --  if there is more than one interpretation of the operands that is\n-      --  compatible with a membership test, the operation is ambiguous.\n+      function Is_Valid_Pair (T1, T2 : Entity_Id) return Boolean;\n+      --  Return true if T1 and T2 constitute a valid pair of operand types for\n+      --  L and R respectively.\n \n       ----------------------------\n       -- Analyze_Set_Membership --\n@@ -3055,8 +3000,6 @@ package body Sem_Ch4 is\n             end loop;\n          end if;\n \n-         Set_Etype (N, Standard_Boolean);\n-\n          if Present (Common_Type) then\n             Set_Etype (L, Common_Type);\n \n@@ -3068,63 +3011,134 @@ package body Sem_Ch4 is\n          end if;\n       end Analyze_Set_Membership;\n \n-      -------------------------\n-      -- Find_Interpretation --\n-      -------------------------\n+      -----------------\n+      -- Find_Interp --\n+      -----------------\n+\n+      function Find_Interp return Boolean is\n+         Found   : Boolean;\n+         I       : Interp_Index;\n+         It      : Interp;\n+         L_Typ   : Entity_Id;\n+         Valid_I : Interp_Index;\n \n-      procedure Find_Interpretation is\n       begin\n+         --  Loop through the interpretations of the left operand\n+\n          if not Is_Overloaded (L) then\n-            Try_One_Interp (Etype (L));\n+            Found := Try_Left_Interp (Etype (L));\n \n          else\n-            Get_First_Interp (L, Index, It);\n+            Found   := False;\n+            L_Typ   := Empty;\n+            Valid_I := 0;\n+\n+            Get_First_Interp (L, I, It);\n             while Present (It.Typ) loop\n-               Try_One_Interp (It.Typ);\n-               Get_Next_Interp (Index, It);\n+               if Try_Left_Interp (It.Typ) then\n+                  --  If several interpretations are possible, disambiguate\n+\n+                  if Present (L_Typ)\n+                    and then Base_Type (It.Typ) /= Base_Type (L_Typ)\n+                  then\n+                     It := Disambiguate (L, Valid_I, I, Any_Type);\n+\n+                     if It = No_Interp then\n+                        Ambiguous_Operands (N);\n+                        Set_Etype (L, Any_Type);\n+                        return True;\n+                     end if;\n+\n+                  else\n+                     Valid_I := I;\n+                  end if;\n+\n+                  L_Typ := It.Typ;\n+                  Set_Etype (L, L_Typ);\n+                  Found := True;\n+               end if;\n+\n+               Get_Next_Interp (I, It);\n             end loop;\n          end if;\n-      end Find_Interpretation;\n-\n-      function Find_Interpretation return Boolean is\n-      begin\n-         Find_Interpretation;\n \n          return Found;\n-      end Find_Interpretation;\n+      end Find_Interp;\n \n-      --------------------\n-      -- Try_One_Interp --\n-      --------------------\n+      ---------------------\n+      -- Try_Left_Interp --\n+      ---------------------\n+\n+      function Try_Left_Interp (T : Entity_Id) return Boolean is\n+         Found   : Boolean;\n+         I       : Interp_Index;\n+         It      : Interp;\n+         R_Typ   : Entity_Id;\n+         Valid_I : Interp_Index;\n \n-      procedure Try_One_Interp (T1 : Entity_Id) is\n       begin\n-         if Has_Compatible_Type (R, T1, For_Comparison => True) then\n-            if Found\n-              and then Base_Type (T1) /= Base_Type (T_F)\n-            then\n-               It := Disambiguate (L, I_F, Index, Any_Type);\n+         --  Defend against previous error\n \n-               if It = No_Interp then\n-                  Ambiguous_Operands (N);\n-                  Set_Etype (L, Any_Type);\n-                  return;\n+         if Nkind (R) = N_Error then\n+            Found := False;\n \n-               else\n-                  T_F := It.Typ;\n-               end if;\n+         --  Loop through the interpretations of the right operand\n \n-            else\n-               Found := True;\n-               T_F   := T1;\n-               I_F   := Index;\n-            end if;\n+         elsif not Is_Overloaded (R) then\n+            Found := Is_Valid_Pair (T, Etype (R));\n+\n+         else\n+            Found   := False;\n+            R_Typ   := Empty;\n+            Valid_I := 0;\n+\n+            Get_First_Interp (R, I, It);\n+            while Present (It.Typ) loop\n+               if Is_Valid_Pair (T, It.Typ) then\n+                  --  If several interpretations are possible, disambiguate\n+\n+                  if Present (R_Typ)\n+                    and then Base_Type (It.Typ) /= Base_Type (R_Typ)\n+                  then\n+                     It := Disambiguate (R, Valid_I, I, Any_Type);\n+\n+                     if It = No_Interp then\n+                        Ambiguous_Operands (N);\n+                        Set_Etype (R, Any_Type);\n+                        return True;\n+                     end if;\n \n-            Set_Etype (L, T_F);\n+                  else\n+                     Valid_I := I;\n+                  end if;\n+\n+                  R_Typ := It.Typ;\n+                  Found := True;\n+               end if;\n+\n+               Get_Next_Interp (I, It);\n+            end loop;\n          end if;\n-      end Try_One_Interp;\n \n-      Op : Node_Id;\n+         return Found;\n+      end Try_Left_Interp;\n+\n+      -------------------\n+      -- Is_Valid_Pair --\n+      -------------------\n+\n+      function Is_Valid_Pair (T1, T2 : Entity_Id) return Boolean is\n+      begin\n+         return Covers (T1 => T1, T2 => T2)\n+           or else Covers (T1 => T2, T2 => T1)\n+           or else Is_User_Defined_Literal (L, T2)\n+           or else Is_User_Defined_Literal (R, T1);\n+      end Is_Valid_Pair;\n+\n+      --  Local variables\n+\n+      Dummy : Boolean;\n+      Op    : Node_Id;\n \n    --  Start of processing for Analyze_Membership_Op\n \n@@ -3133,31 +3147,29 @@ package body Sem_Ch4 is\n \n       if No (R) then\n          pragma Assert (Ada_Version >= Ada_2012);\n+\n          Analyze_Set_Membership;\n-         Check_Function_Writable_Actuals (N);\n-         return;\n-      end if;\n \n-      if Nkind (R) = N_Range\n+      elsif Nkind (R) = N_Range\n         or else (Nkind (R) = N_Attribute_Reference\n                   and then Attribute_Name (R) = Name_Range)\n       then\n-         Analyze (R);\n+         Analyze_Expression (R);\n \n-         Find_Interpretation;\n+         Dummy := Find_Interp;\n \n       --  If not a range, it can be a subtype mark, or else it is a degenerate\n       --  membership test with a singleton value, i.e. a test for equality,\n       --  if the types are compatible.\n \n       else\n-         Analyze (R);\n+         Analyze_Expression (R);\n \n          if Is_Entity_Name (R) and then Is_Type (Entity (R)) then\n             Find_Type (R);\n             Check_Fully_Declared (Entity (R), R);\n \n-         elsif Ada_Version >= Ada_2012 and then Find_Interpretation then\n+         elsif Ada_Version >= Ada_2012 and then Find_Interp then\n             if Nkind (N) = N_In then\n                Op := Make_Op_Eq (Loc, Left_Opnd => L, Right_Opnd => R);\n             else\n@@ -3616,8 +3628,8 @@ package body Sem_Ch4 is\n             return;\n          end if;\n \n-         --  This can occur when the prefix of the call is an operator\n-         --  name or an expanded name whose selector is an operator name.\n+         --  This occurs when the prefix of the call is an operator name\n+         --  or an expanded name whose selector is an operator name.\n \n          Analyze_Operator_Call (N, Nam);\n \n@@ -3933,17 +3945,14 @@ package body Sem_Ch4 is\n             =>\n                Find_Boolean_Types (Act1, Act2, Op_Id, N);\n \n-            when Name_Op_Ge\n+            when Name_Op_Eq\n+               | Name_Op_Ge\n                | Name_Op_Gt\n                | Name_Op_Le\n                | Name_Op_Lt\n-            =>\n-               Find_Comparison_Types (Act1, Act2, Op_Id,  N);\n-\n-            when Name_Op_Eq\n                | Name_Op_Ne\n             =>\n-               Find_Equality_Types (Act1, Act2, Op_Id,  N);\n+               Find_Comparison_Equality_Types (Act1, Act2, Op_Id,  N);\n \n             when Name_Op_Concat =>\n                Find_Concatenation_Types (Act1, Act2, Op_Id, N);\n@@ -5927,7 +5936,7 @@ package body Sem_Ch4 is\n          then\n             Add_One_Interp (N, Op_Id, Etype (Op_Id));\n \n-            --  If the left operand is overloaded, indicate that the current\n+            --  If the operands are overloaded, indicate that the current\n             --  type is a viable candidate. This is redundant in most cases,\n             --  but for equality and comparison operators where the context\n             --  does not impose a type on the operands, setting the proper\n@@ -5939,6 +5948,10 @@ package body Sem_Ch4 is\n                Set_Etype (Left_Opnd (N), Etype (F1));\n             end if;\n \n+            if Is_Overloaded (Right_Opnd (N)) then\n+               Set_Etype (Right_Opnd (N), Etype (F2));\n+            end if;\n+\n             if Debug_Flag_E then\n                Write_Str (\"user defined operator \");\n                Write_Name (Chars (Op_Id));\n@@ -6005,9 +6018,6 @@ package body Sem_Ch4 is\n       --  Standard, the predefined universal fixed operator is available,\n       --  as specified by AI-420 (RM 4.5.5 (19.1/2)).\n \n-      function Specific_Type (T1, T2 : Entity_Id) return Entity_Id;\n-      --  Get specific type (i.e. non-universal type if there is one)\n-\n       ------------------\n       -- Has_Fixed_Op --\n       ------------------\n@@ -6064,19 +6074,6 @@ package body Sem_Ch4 is\n          return False;\n       end Has_Fixed_Op;\n \n-      -------------------\n-      -- Specific_Type --\n-      -------------------\n-\n-      function Specific_Type (T1, T2 : Entity_Id) return Entity_Id is\n-      begin\n-         if Is_Universal_Numeric_Type (T1) then\n-            return Base_Type (T2);\n-         else\n-            return Base_Type (T1);\n-         end if;\n-      end Specific_Type;\n-\n    --  Start of processing for Check_Arithmetic_Pair\n \n    begin\n@@ -6246,18 +6243,6 @@ package body Sem_Ch4 is\n       end if;\n    end Check_Misspelled_Selector;\n \n-   ----------------------\n-   -- Defined_In_Scope --\n-   ----------------------\n-\n-   function Defined_In_Scope (T : Entity_Id; S : Entity_Id) return Boolean\n-   is\n-      S1 : constant Entity_Id := Scope (Base_Type (T));\n-   begin\n-      return S1 = S\n-        or else (S1 = System_Aux_Id and then S = Scope (S1));\n-   end Defined_In_Scope;\n-\n    -------------------\n    -- Diagnose_Call --\n    -------------------\n@@ -6268,32 +6253,35 @@ package body Sem_Ch4 is\n       It               : Interp;\n       Err_Mode         : Boolean;\n       New_Nam          : Node_Id;\n+      Num_Actuals      : Natural;\n+      Num_Interps      : Natural;\n       Void_Interp_Seen : Boolean := False;\n \n       Success : Boolean;\n       pragma Warnings (Off, Boolean);\n \n    begin\n-      if Ada_Version >= Ada_2005 then\n-         Actual := First_Actual (N);\n-         while Present (Actual) loop\n+      Num_Actuals := 0;\n+      Actual := First_Actual (N);\n \n-            --  Ada 2005 (AI-50217): Post an error in case of premature\n-            --  usage of an entity from the limited view.\n+      while Present (Actual) loop\n+         --  Ada 2005 (AI-50217): Post an error in case of premature\n+         --  usage of an entity from the limited view.\n \n-            if not Analyzed (Etype (Actual))\n-             and then From_Limited_With (Etype (Actual))\n-            then\n-               Error_Msg_Qual_Level := 1;\n-               Error_Msg_NE\n-                (\"missing with_clause for scope of imported type&\",\n-                  Actual, Etype (Actual));\n-               Error_Msg_Qual_Level := 0;\n-            end if;\n+         if not Analyzed (Etype (Actual))\n+          and then From_Limited_With (Etype (Actual))\n+          and then Ada_Version >= Ada_2005\n+         then\n+            Error_Msg_Qual_Level := 1;\n+            Error_Msg_NE\n+             (\"missing with_clause for scope of imported type&\",\n+               Actual, Etype (Actual));\n+            Error_Msg_Qual_Level := 0;\n+         end if;\n \n-            Next_Actual (Actual);\n-         end loop;\n-      end if;\n+         Num_Actuals := Num_Actuals + 1;\n+         Next_Actual (Actual);\n+      end loop;\n \n       --  Before listing the possible candidates, check whether this is\n       --  a prefix of a selected component that has been rewritten as a\n@@ -6328,17 +6316,9 @@ package body Sem_Ch4 is\n          end;\n       end if;\n \n-      --  Analyze each candidate call again, with full error reporting for\n-      --  each.\n-\n-      Error_Msg_N\n-        (\"no candidate interpretations match the actuals:!\", Nam);\n-      Err_Mode := All_Errors_Mode;\n-      All_Errors_Mode := True;\n-\n-      --  If this is a call to an operation of a concurrent type,\n-      --  the failed interpretations have been removed from the\n-      --  name. Recover them to provide full diagnostics.\n+      --  If this is a call to an operation of a concurrent type, the failed\n+      --  interpretations have been removed from the name. Recover them now\n+      --  in order to provide full diagnostics.\n \n       if Nkind (Parent (Nam)) = N_Selected_Component then\n          Set_Entity (Nam, Empty);\n@@ -6352,6 +6332,48 @@ package body Sem_Ch4 is\n          Get_First_Interp (Nam, X, It);\n       end if;\n \n+      --  If the number of actuals is 2, then remove interpretations involving\n+      --  a unary \"+\" operator as they might yield confusing errors downstream.\n+\n+      if Num_Actuals = 2\n+        and then Nkind (Parent (Nam)) /= N_Selected_Component\n+      then\n+         Num_Interps := 0;\n+\n+         while Present (It.Nam) loop\n+            if Ekind (It.Nam) = E_Operator\n+              and then Chars (It.Nam) = Name_Op_Add\n+              and then (No (First_Formal (It.Nam))\n+                         or else No (Next_Formal (First_Formal (It.Nam))))\n+            then\n+               Remove_Interp (X);\n+            else\n+               Num_Interps := Num_Interps + 1;\n+            end if;\n+\n+            Get_Next_Interp (X, It);\n+         end loop;\n+\n+         if Num_Interps = 0 then\n+            Error_Msg_N (\"!too many arguments in call to&\", Nam);\n+            return;\n+         end if;\n+\n+         Get_First_Interp (Nam, X, It);\n+\n+      else\n+         Num_Interps := 2; -- at least\n+      end if;\n+\n+      --  Analyze each candidate call again with full error reporting for each\n+\n+      if Num_Interps > 1 then\n+         Error_Msg_N (\"!no candidate interpretations match the actuals:\", Nam);\n+      end if;\n+\n+      Err_Mode := All_Errors_Mode;\n+      All_Errors_Mode := True;\n+\n       while Present (It.Nam) loop\n          if Etype (It.Nam) = Standard_Void_Type then\n             Void_Interp_Seen := True;\n@@ -6443,7 +6465,8 @@ package body Sem_Ch4 is\n       procedure Check_Right_Argument (T : Entity_Id) is\n       begin\n          if not Is_Overloaded (R) then\n-            Check_Arithmetic_Pair (T, Etype (R), Op_Id,  N);\n+            Check_Arithmetic_Pair (T, Etype (R), Op_Id, N);\n+\n          else\n             Get_First_Interp (R, Index2, It2);\n             while Present (It2.Typ) loop\n@@ -6466,7 +6489,6 @@ package body Sem_Ch4 is\n             Get_Next_Interp (Index1, It1);\n          end loop;\n       end if;\n-\n    end Find_Arithmetic_Types;\n \n    ------------------------\n@@ -6562,652 +6584,334 @@ package body Sem_Ch4 is\n       end if;\n    end Find_Boolean_Types;\n \n-   ---------------------------\n-   -- Find_Comparison_Types --\n-   ---------------------------\n+   ------------------------------------\n+   -- Find_Comparison_Equality_Types --\n+   ------------------------------------\n \n-   procedure Find_Comparison_Types\n+   --  The context of the operator plays no role in resolving the operands,\n+   --  so that if there is more than one interpretation of the operands that\n+   --  is compatible with the comparison or equality, then the operation is\n+   --  ambiguous, but this cannot be reported at this point because there is\n+   --  no guarantee that the operation will be resolved to this operator yet.\n+\n+   procedure Find_Comparison_Equality_Types\n      (L, R  : Node_Id;\n       Op_Id : Entity_Id;\n       N     : Node_Id)\n    is\n-      Index : Interp_Index;\n-      It    : Interp;\n-      Found : Boolean := False;\n-      I_F   : Interp_Index;\n-      T_F   : Entity_Id;\n-      Scop  : Entity_Id := Empty;\n+      Op_Name : constant Name_Id := Chars (Op_Id);\n+      Op_Typ  : Entity_Id renames Standard_Boolean;\n \n-      procedure Try_One_Interp (T1 : Entity_Id);\n-      --  Routine to try one proposed interpretation. Note that the context\n-      --  of the operator plays no role in resolving the arguments, so that\n-      --  if there is more than one interpretation of the operands that is\n-      --  compatible with comparison, the operation is ambiguous.\n+      function Try_Left_Interp (T : Entity_Id) return Entity_Id;\n+      --  Try an interpretation of the left operand with type T. Return the\n+      --  type of the interpretation of the right operand making up a valid\n+      --  operand pair, or else Any_Type if the right operand is ambiguous,\n+      --  otherwise Empty if no such pair exists.\n \n-      --------------------\n-      -- Try_One_Interp --\n-      --------------------\n+      function Is_Valid_Comparison_Type (T : Entity_Id) return Boolean;\n+      --  Return true if T is a valid comparison type\n \n-      procedure Try_One_Interp (T1 : Entity_Id) is\n-      begin\n-         --  If the operator is an expanded name, then the type of the operand\n-         --  must be defined in the corresponding scope. If the type is\n-         --  universal, the context will impose the correct type. Note that we\n-         --  also avoid returning if we are currently within a generic instance\n-         --  due to the fact that the generic package declaration has already\n-         --  been successfully analyzed and Defined_In_Scope expects the base\n-         --  type to be defined within the instance which will never be the\n-         --  case.\n-\n-         if Present (Scop)\n-           and then not Defined_In_Scope (T1, Scop)\n-           and then not In_Instance\n-           and then T1 /= Universal_Integer\n-           and then T1 /= Universal_Real\n-           and then T1 /= Any_String\n-           and then T1 /= Any_Composite\n-         then\n-            return;\n-         end if;\n+      function Is_Valid_Equality_Type\n+        (T           : Entity_Id;\n+         Anon_Access : Boolean) return Boolean;\n+      --  Return true if T is a valid equality type\n \n-         if Valid_Comparison_Arg (T1)\n-           and then Has_Compatible_Type (R, T1, For_Comparison => True)\n-         then\n-            if Found and then Base_Type (T1) /= Base_Type (T_F) then\n-               It := Disambiguate (L, I_F, Index, Any_Type);\n+      function Is_Valid_Pair (T1, T2 : Entity_Id) return Boolean;\n+      --  Return true if T1 and T2 constitute a valid pair of operand types for\n+      --  L and R respectively.\n \n-               if It = No_Interp then\n-                  Ambiguous_Operands (N);\n-                  Set_Etype (L, Any_Type);\n-                  return;\n+      ---------------------\n+      -- Try_Left_Interp --\n+      ---------------------\n \n-               else\n-                  T_F := It.Typ;\n-               end if;\n-            else\n-               Found := True;\n-               T_F   := T1;\n-               I_F   := Index;\n-            end if;\n+      function Try_Left_Interp (T : Entity_Id) return Entity_Id is\n+         I       : Interp_Index;\n+         It      : Interp;\n+         R_Typ   : Entity_Id;\n+         Valid_I : Interp_Index;\n \n-            Set_Etype (L, T_F);\n-            Find_Non_Universal_Interpretations (N, R, Op_Id, T1);\n-         end if;\n-      end Try_One_Interp;\n+      begin\n+         --  Defend against previous error\n \n-   --  Start of processing for Find_Comparison_Types\n+         if Nkind (R) = N_Error then\n+            null;\n \n-   begin\n-      --  If left operand is aggregate, the right operand has to\n-      --  provide a usable type for it.\n+         --  Loop through the interpretations of the right operand\n \n-      if Nkind (L) = N_Aggregate and then Nkind (R) /= N_Aggregate then\n-         Find_Comparison_Types (L => R, R => L, Op_Id => Op_Id, N => N);\n-         return;\n-      end if;\n+         elsif not Is_Overloaded (R) then\n+            if Is_Valid_Pair (T, Etype (R)) then\n+               return Etype (R);\n+            end if;\n \n-      if Nkind (N) = N_Function_Call\n-         and then Nkind (Name (N)) = N_Expanded_Name\n-      then\n-         Scop := Entity (Prefix (Name (N)));\n+         else\n+            R_Typ   := Empty;\n+            Valid_I := 0;\n \n-         --  The prefix may be a package renaming, and the subsequent test\n-         --  requires the original package.\n+            Get_First_Interp (R, I, It);\n+            while Present (It.Typ) loop\n+               if Is_Valid_Pair (T, It.Typ) then\n+                  --  If several interpretations are possible, disambiguate\n \n-         if Ekind (Scop) = E_Package\n-           and then Present (Renamed_Entity (Scop))\n-         then\n-            Scop := Renamed_Entity (Scop);\n-            Set_Entity (Prefix (Name (N)), Scop);\n-         end if;\n-      end if;\n-\n-      if not Is_Overloaded (L) then\n-         Try_One_Interp (Etype (L));\n-\n-      else\n-         Get_First_Interp (L, Index, It);\n-         while Present (It.Typ) loop\n-            Try_One_Interp (It.Typ);\n-            Get_Next_Interp (Index, It);\n-         end loop;\n-      end if;\n-   end Find_Comparison_Types;\n-\n-   ----------------------------------------\n-   -- Find_Non_Universal_Interpretations --\n-   ----------------------------------------\n-\n-   procedure Find_Non_Universal_Interpretations\n-     (N     : Node_Id;\n-      R     : Node_Id;\n-      Op_Id : Entity_Id;\n-      T1    : Entity_Id)\n-   is\n-      Index : Interp_Index;\n-      It    : Interp;\n+                  if Present (R_Typ)\n+                    and then Base_Type (It.Typ) /= Base_Type (R_Typ)\n+                  then\n+                     It := Disambiguate (R, Valid_I, I, Any_Type);\n \n-   begin\n-      --  Defend against previous error\n+                     if It = No_Interp then\n+                        R_Typ := Any_Type;\n+                        exit;\n+                     end if;\n \n-      if Nkind (R) = N_Error then\n-         return;\n-      end if;\n+                  else\n+                     Valid_I := I;\n+                  end if;\n \n-      if T1 = Universal_Integer\n-        or else T1 = Universal_Real\n-        or else T1 = Universal_Access\n-      then\n-         if not Is_Overloaded (R) then\n-            Add_One_Interp (N, Op_Id, Standard_Boolean, Base_Type (Etype (R)));\n-         else\n-            Get_First_Interp (R, Index, It);\n-            while Present (It.Typ) loop\n-               if Covers (It.Typ, T1) then\n-                  Add_One_Interp\n-                    (N, Op_Id, Standard_Boolean, Base_Type (It.Typ));\n+                  R_Typ := It.Typ;\n                end if;\n \n-               Get_Next_Interp (Index, It);\n+               Get_Next_Interp (I, It);\n             end loop;\n-         end if;\n \n-      elsif Has_Compatible_Type (R, T1) or else Covers (Etype (R), T1) then\n-         Add_One_Interp (N, Op_Id, Standard_Boolean, Base_Type (T1));\n-      end if;\n-   end Find_Non_Universal_Interpretations;\n-\n-   ------------------------------\n-   -- Find_Concatenation_Types --\n-   ------------------------------\n-\n-   procedure Find_Concatenation_Types\n-     (L, R  : Node_Id;\n-      Op_Id : Entity_Id;\n-      N     : Node_Id)\n-   is\n-      Is_String : constant Boolean := Nkind (L) = N_String_Literal\n-                                        or else\n-                                      Nkind (R) = N_String_Literal;\n-      Op_Type   : constant Entity_Id := Etype (Op_Id);\n-\n-   begin\n-      if Is_Array_Type (Op_Type)\n-\n-        --  Small but very effective optimization: if at least one operand is a\n-        --  string literal, then the type of the operator must be either array\n-        --  of characters or array of strings.\n-\n-        and then (not Is_String\n-                    or else\n-                  Is_Character_Type (Component_Type (Op_Type))\n-                    or else\n-                  Is_String_Type (Component_Type (Op_Type)))\n-\n-        and then not Is_Limited_Type (Op_Type)\n-\n-        and then (Has_Compatible_Type (L, Op_Type)\n-                    or else\n-                  Has_Compatible_Type (L, Component_Type (Op_Type)))\n-\n-        and then (Has_Compatible_Type (R, Op_Type)\n-                    or else\n-                  Has_Compatible_Type (R, Component_Type (Op_Type)))\n-      then\n-         Add_One_Interp (N, Op_Id, Op_Type);\n-      end if;\n-   end Find_Concatenation_Types;\n-\n-   -------------------------\n-   -- Find_Equality_Types --\n-   -------------------------\n-\n-   procedure Find_Equality_Types\n-     (L, R  : Node_Id;\n-      Op_Id : Entity_Id;\n-      N     : Node_Id)\n-   is\n-      Index               : Interp_Index := 0;\n-      It                  : Interp;\n-      Found               : Boolean := False;\n-      Is_Universal_Access : Boolean := False;\n-      I_F                 : Interp_Index;\n-      T_F                 : Entity_Id;\n-      Scop                : Entity_Id := Empty;\n-\n-      procedure Check_Access_Attribute (N : Node_Id);\n-      --  For any object, '[Unchecked_]Access of such object can never be\n-      --  passed as a parameter of a call to the Universal_Access equality\n-      --  operator.\n-      --  This is because the expected type for Obj'Access in a call to\n-      --  the Standard.\"=\" operator whose formals are of type\n-      --  Universal_Access is Universal_Access, and Universal_Access\n-      --  doesn't have a designated type. For more detail see RM 6.4.1(3)\n-      --  and 3.10.2.\n-      --  This procedure assumes that the context is a universal_access.\n-\n-      function Check_Access_Object_Types\n-        (N : Node_Id; Typ : Entity_Id) return Boolean;\n-      --  Check for RM 4.5.2 (9.6/2): When both are of access-to-object types,\n-      --  the designated types shall be the same or one shall cover the other,\n-      --  and if the designated types are elementary or array types, then the\n-      --  designated subtypes shall statically match.\n-      --  If N is not overloaded, then its unique type must be compatible as\n-      --  per above. Otherwise iterate through the interpretations of N looking\n-      --  for a compatible one.\n-\n-      procedure Check_Compatible_Profiles (N : Node_Id; Typ : Entity_Id);\n-      --  Check for RM 4.5.2(9.7/2): When both are of access-to-subprogram\n-      --  types, the designated profiles shall be subtype conformant.\n-\n-      function References_Anonymous_Access_Type\n-        (N : Node_Id; Typ : Entity_Id) return Boolean;\n-      --  Return True either if N is not overloaded and its Etype is an\n-      --  anonymous access type or if one of the interpretations of N refers\n-      --  to an anonymous access type compatible with Typ.\n-\n-      procedure Try_One_Interp (T1 : Entity_Id);\n-      --  The context of the equality operator plays no role in resolving the\n-      --  arguments, so that if there is more than one interpretation of the\n-      --  operands that is compatible with equality, the construct is ambiguous\n-      --  and an error can be emitted now, after trying to disambiguate, i.e.\n-      --  applying preference rules.\n-\n-      ----------------------------\n-      -- Check_Access_Attribute --\n-      ----------------------------\n-\n-      procedure Check_Access_Attribute (N : Node_Id) is\n-      begin\n-         if Nkind (N) = N_Attribute_Reference\n-           and then Attribute_Name (N) in Name_Access | Name_Unchecked_Access\n-         then\n-            Error_Msg_N\n-              (\"access attribute cannot be used as actual for \"\n-               & \"universal_access equality\", N);\n+            if Present (R_Typ) then\n+               return R_Typ;\n+            end if;\n          end if;\n-      end Check_Access_Attribute;\n \n-      -------------------------------\n-      -- Check_Access_Object_Types --\n-      -------------------------------\n-\n-      function Check_Access_Object_Types\n-        (N : Node_Id; Typ : Entity_Id) return Boolean\n-      is\n-         function Check_Designated_Types (DT1, DT2 : Entity_Id) return Boolean;\n-         --  Check RM 4.5.2 (9.6/2) on the given designated types.\n-\n-         ----------------------------\n-         -- Check_Designated_Types --\n-         ----------------------------\n-\n-         function Check_Designated_Types\n-           (DT1, DT2 : Entity_Id) return Boolean is\n-         begin\n-            --  If the designated types are elementary or array types, then\n-            --  the designated subtypes shall statically match.\n+         return Empty;\n+      end Try_Left_Interp;\n \n-            if Is_Elementary_Type (DT1) or else Is_Array_Type (DT1) then\n-               if Base_Type (DT1) /= Base_Type (DT2) then\n-                  return False;\n-               else\n-                  return Subtypes_Statically_Match (DT1, DT2);\n-               end if;\n-\n-            --  Otherwise, the designated types shall be the same or one\n-            --  shall cover the other.\n-\n-            else\n-               return DT1 = DT2\n-                 or else Covers (DT1, DT2)\n-                 or else Covers (DT2, DT1);\n-            end if;\n-         end Check_Designated_Types;\n-\n-      --  Start of processing for Check_Access_Object_Types\n+      ------------------------------\n+      -- Is_Valid_Comparison_Type --\n+      ------------------------------\n \n+      function Is_Valid_Comparison_Type (T : Entity_Id) return Boolean is\n       begin\n-         --  Return immediately with no checks if Typ is not an\n-         --  access-to-object type.\n+         --  The operation must be performed in a context where the operators\n+         --  of the base type are visible.\n \n-         if not Is_Access_Object_Type (Typ) then\n-            return True;\n+         if Is_Visible_Operator (N, Base_Type (T)) then\n+            null;\n \n-         --  Any_Type is compatible with all types in this context, and is used\n-         --  in particular for the designated type of a 'null' value.\n+         --  Save candidate type for subsequent error message, if any\n \n-         elsif Directly_Designated_Type (Typ) = Any_Type\n-           or else Nkind (N) = N_Null\n-         then\n-            return True;\n-         end if;\n-\n-         if not Is_Overloaded (N) then\n-            if Is_Access_Object_Type (Etype (N)) then\n-               return Check_Designated_Types\n-                 (Designated_Type (Typ), Designated_Type (Etype (N)));\n-            end if;\n          else\n-            declare\n-               Typ_Is_Anonymous : constant Boolean :=\n-                 Is_Anonymous_Access_Type (Typ);\n-\n-               I  : Interp_Index;\n-               It : Interp;\n-\n-            begin\n-               Get_First_Interp (N, I, It);\n-               while Present (It.Typ) loop\n-\n-                  --  The check on designated types if only relevant when one\n-                  --  of the types is anonymous, ignore other (non relevant)\n-                  --  types.\n-\n-                  if (Typ_Is_Anonymous\n-                       or else Is_Anonymous_Access_Type (It.Typ))\n-                    and then Is_Access_Object_Type (It.Typ)\n-                  then\n-                     if Check_Designated_Types\n-                          (Designated_Type (Typ), Designated_Type (It.Typ))\n-                     then\n-                        return True;\n-                     end if;\n-                  end if;\n+            if Valid_Comparison_Arg (T) then\n+               Candidate_Type := T;\n+            end if;\n \n-                  Get_Next_Interp (I, It);\n-               end loop;\n-            end;\n+            return False;\n          end if;\n \n-         return False;\n-      end Check_Access_Object_Types;\n+         --  Defer to the common implementation for the rest\n \n-      -------------------------------\n-      -- Check_Compatible_Profiles --\n-      -------------------------------\n+         return Valid_Comparison_Arg (T);\n+      end Is_Valid_Comparison_Type;\n \n-      procedure Check_Compatible_Profiles (N : Node_Id; Typ : Entity_Id) is\n-         I     : Interp_Index;\n-         It    : Interp;\n-         I1    : Interp_Index := 0;\n-         Found : Boolean      := False;\n-         Tmp   : Entity_Id    := Empty;\n+      ----------------------------\n+      -- Is_Valid_Equality_Type --\n+      ----------------------------\n \n+      function Is_Valid_Equality_Type\n+        (T           : Entity_Id;\n+         Anon_Access : Boolean) return Boolean\n+      is\n       begin\n-         if not Is_Overloaded (N) then\n-            Check_Subtype_Conformant\n-              (Designated_Type (Etype (N)), Designated_Type (Typ), N);\n-         else\n-            Get_First_Interp (N, I, It);\n-            while Present (It.Typ) loop\n-               if Is_Access_Subprogram_Type (It.Typ) then\n-                  if not Found then\n-                     Found := True;\n-                     Tmp   := It.Typ;\n-                     I1    := I;\n+         --  The operation must be performed in a context where the operators\n+         --  of the base type are visible. Deal with special types used with\n+         --  access types before type resolution is done.\n \n-                  else\n-                     It := Disambiguate (N, I1, I, Any_Type);\n-\n-                     if It /= No_Interp then\n-                        Tmp := It.Typ;\n-                        I1  := I;\n-                     else\n-                        Found := False;\n-                        exit;\n-                     end if;\n-                  end if;\n-               end if;\n+         if Ekind (T) = E_Access_Attribute_Type\n+           or else (Ekind (T) in E_Access_Subprogram_Type\n+                               | E_Access_Protected_Subprogram_Type\n+                      and then\n+                    Ekind (Designated_Type (T)) /= E_Subprogram_Type)\n+           or else Is_Visible_Operator (N, Base_Type (T))\n+         then\n+            null;\n \n-               Get_Next_Interp (I, It);\n-            end loop;\n+         --  AI95-0230: Keep restriction imposed by Ada 83 and 95, do not allow\n+         --  anonymous access types in universal_access equality operators.\n \n-            if Found then\n-               Check_Subtype_Conformant\n-                 (Designated_Type (Tmp), Designated_Type (Typ), N);\n+         elsif Anon_Access then\n+            if Ada_Version < Ada_2005 then\n+               return False;\n             end if;\n-         end if;\n-      end Check_Compatible_Profiles;\n \n-      --------------------------------------\n-      -- References_Anonymous_Access_Type --\n-      --------------------------------------\n+         --  Save candidate type for subsequent error message, if any\n \n-      function References_Anonymous_Access_Type\n-        (N : Node_Id; Typ : Entity_Id) return Boolean\n-      is\n-         I  : Interp_Index;\n-         It : Interp;\n-      begin\n-         if not Is_Overloaded (N) then\n-            return Is_Anonymous_Access_Type (Etype (N));\n          else\n-            Get_First_Interp (N, I, It);\n-            while Present (It.Typ) loop\n-               if Is_Anonymous_Access_Type (It.Typ)\n-                 and then (Covers (It.Typ, Typ) or else Covers (Typ, It.Typ))\n-               then\n-                  return True;\n-               end if;\n-\n-               Get_Next_Interp (I, It);\n-            end loop;\n+            if Valid_Equality_Arg (T) then\n+               Candidate_Type := T;\n+            end if;\n \n             return False;\n          end if;\n-      end References_Anonymous_Access_Type;\n-\n-      --------------------\n-      -- Try_One_Interp --\n-      --------------------\n \n-      procedure Try_One_Interp (T1 : Entity_Id) is\n-         Anonymous_Access : Boolean;\n-         Bas              : Entity_Id;\n+         --  For the use of a \"/=\" operator on a tagged type, several possible\n+         --  interpretations of equality need to be considered, we don't want\n+         --  the default inequality declared in Standard to be chosen, and the\n+         --  \"/=\" operator will be rewritten as a negation of \"=\" (see the end\n+         --  of Analyze_Comparison_Equality_Op). This ensures the rewriting\n+         --  occurs during analysis rather than being delayed until expansion.\n+         --  Note that, if the node is N_Op_Ne but Op_Id is Name_Op_Eq, then we\n+         --  still proceed with the interpretation, because this indicates\n+         --  the aforementioned rewriting case where the interpretation to be\n+         --  considered is actually that of the \"=\" operator.\n+\n+         if Nkind (N) = N_Op_Ne\n+           and then Op_Name /= Name_Op_Eq\n+           and then Is_Tagged_Type (T)\n+         then\n+            return False;\n \n-      begin\n-         --  Perform a sanity check in case of previous errors\n+         --  Defer to the common implementation for the rest\n \n-         if No (T1) then\n-            return;\n+         else\n+            return Valid_Equality_Arg (T);\n          end if;\n+      end Is_Valid_Equality_Type;\n \n-         Bas := Base_Type (T1);\n-\n-         --  If the operator is an expanded name, then the type of the operand\n-         --  must be defined in the corresponding scope. If the type is\n-         --  universal, the context will impose the correct type. An anonymous\n-         --  type for a 'Access reference is also universal in this sense, as\n-         --  the actual type is obtained from context.\n-\n-         --  In Ada 2005, the equality operator for anonymous access types\n-         --  is declared in Standard, and preference rules apply to it.\n-\n-         Anonymous_Access := Is_Anonymous_Access_Type (T1)\n-           or else References_Anonymous_Access_Type (R, T1);\n+      -------------------\n+      -- Is_Valid_Pair --\n+      -------------------\n \n-         if Present (Scop) then\n+      function Is_Valid_Pair (T1, T2 : Entity_Id) return Boolean is\n+      begin\n+         if Op_Name = Name_Op_Eq or else Op_Name = Name_Op_Ne then\n+            declare\n+               Anon_Access : constant Boolean :=\n+                 Is_Anonymous_Access_Type (T1)\n+                   or else Is_Anonymous_Access_Type (T2);\n+               --  RM 4.5.2(9.1/2): At least one of the operands of an equality\n+               --  operator for universal_access shall be of specific anonymous\n+               --  access type.\n \n-            --  Note that we avoid returning if we are currently within a\n-            --  generic instance due to the fact that the generic package\n-            --  declaration has already been successfully analyzed and\n-            --  Defined_In_Scope expects the base type to be defined within\n-            --  the instance which will never be the case.\n+            begin\n+               if not Is_Valid_Equality_Type (T1, Anon_Access)\n+                 or else not Is_Valid_Equality_Type (T2, Anon_Access)\n+               then\n+                  return False;\n+               end if;\n+            end;\n \n-            if Defined_In_Scope (T1, Scop)\n-              or else In_Instance\n-              or else T1 = Universal_Integer\n-              or else T1 = Universal_Real\n-              or else T1 = Universal_Access\n-              or else T1 = Any_String\n-              or else T1 = Any_Composite\n-              or else (Ekind (T1) = E_Access_Subprogram_Type\n-                        and then not Comes_From_Source (T1))\n+         else\n+            if not Is_Valid_Comparison_Type (T1)\n+              or else not Is_Valid_Comparison_Type (T2)\n             then\n-               null;\n-\n-            elsif Scop /= Standard_Standard or else not Anonymous_Access then\n-\n-               --  The scope does not contain an operator for the type\n-\n-               return;\n+               return False;\n             end if;\n+         end if;\n \n-         --  If we have infix notation, the operator must be usable. Within\n-         --  an instance, the type may have been immediately visible if the\n-         --  types are compatible.\n+         return Covers (T1 => T1, T2 => T2)\n+           or else Covers (T1 => T2, T2 => T1)\n+           or else Is_User_Defined_Literal (L, T2)\n+           or else Is_User_Defined_Literal (R, T1);\n+      end Is_Valid_Pair;\n \n-         elsif In_Open_Scopes (Scope (Bas))\n-           or else Is_Potentially_Use_Visible (Bas)\n-           or else In_Use (Bas)\n-           or else (In_Use (Scope (Bas)) and then not Is_Hidden (Bas))\n-           or else\n-             ((In_Instance or else In_Inlined_Body)\n-                and then Has_Compatible_Type (R, T1))\n-         then\n-            null;\n+      --  Local variables\n \n-         elsif not Anonymous_Access then\n-            --  Save candidate type for subsequent error message, if any\n+      I       : Interp_Index;\n+      It      : Interp;\n+      L_Typ   : Entity_Id;\n+      R_Typ   : Entity_Id;\n+      T       : Entity_Id;\n+      Valid_I : Interp_Index;\n \n-            if not Is_Limited_Type (T1) then\n-               Candidate_Type := T1;\n-            end if;\n+   --  Start of processing for Find_Comparison_Equality_Types\n \n-            return;\n-         end if;\n+   begin\n+      --  Loop through the interpretations of the left operand\n \n-         --  Ada 2005 (AI-230): Keep restriction imposed by Ada 83 and 95:\n-         --  Do not allow anonymous access types in equality operators.\n+      if not Is_Overloaded (L) then\n+         T := Try_Left_Interp (Etype (L));\n \n-         if Ada_Version < Ada_2005 and then Anonymous_Access then\n-            return;\n+         if Present (T) then\n+            Set_Etype (R, T);\n+            Add_One_Interp (N, Op_Id, Op_Typ, Find_Unique_Type (L, R));\n          end if;\n \n-         --  If the right operand has a type compatible with T1, check for an\n-         --  acceptable interpretation, unless T1 is limited (no predefined\n-         --  equality available), or this is use of a \"/=\" for a tagged type.\n-         --  In the latter case, possible interpretations of equality need\n-         --  to be considered, we don't want the default inequality declared\n-         --  in Standard to be chosen, and the \"/=\" will be rewritten as a\n-         --  negation of \"=\" (see the end of Analyze_Equality_Op). This ensures\n-         --  that rewriting happens during analysis rather than being\n-         --  delayed until expansion (is this still needed now that ASIS mode\n-         --  is gone???). Note that if the node is N_Op_Ne, but Op_Id\n-         --  is Name_Op_Eq then we still proceed with the interpretation,\n-         --  because that indicates the potential rewriting case where the\n-         --  interpretation to consider is actually \"=\" and the node may be\n-         --  about to be rewritten by Analyze_Equality_Op.\n-         --  Finally, also check for RM 4.5.2 (9.6/2).\n-\n-         if T1 /= Standard_Void_Type\n-           and then (Anonymous_Access\n-                      or else\n-                     Has_Compatible_Type (R, T1, For_Comparison => True))\n+      else\n+         L_Typ   := Empty;\n+         R_Typ   := Empty;\n+         Valid_I := 0;\n \n-           and then\n-             ((not Is_Limited_Type (T1)\n-                and then not Is_Limited_Composite (T1))\n+         Get_First_Interp (L, I, It);\n+         while Present (It.Typ) loop\n+            T := Try_Left_Interp (It.Typ);\n \n-               or else\n-                 (Is_Array_Type (T1)\n-                   and then not Is_Limited_Type (Component_Type (T1))\n-                   and then Available_Full_View_Of_Component (T1)))\n+            if Present (T) then\n+               --  If several interpretations are possible, disambiguate\n \n-           and then\n-             (Nkind (N) /= N_Op_Ne\n-               or else not Is_Tagged_Type (T1)\n-               or else Chars (Op_Id) = Name_Op_Eq)\n-\n-           and then (not Anonymous_Access\n-                      or else Check_Access_Object_Types (R, T1))\n-         then\n-            if Found\n-              and then Base_Type (T1) /= Base_Type (T_F)\n-            then\n-               It := Disambiguate (L, I_F, Index, Any_Type);\n+               if Present (L_Typ)\n+                 and then Base_Type (It.Typ) /= Base_Type (L_Typ)\n+               then\n+                  It := Disambiguate (L, Valid_I, I, Any_Type);\n \n-               if It = No_Interp then\n-                  Ambiguous_Operands (N);\n-                  Set_Etype (L, Any_Type);\n-                  return;\n+                  if It = No_Interp then\n+                     L_Typ := Any_Type;\n+                     R_Typ := T;\n+                     exit;\n+                  end if;\n \n                else\n-                  T_F := It.Typ;\n-                  Is_Universal_Access := Anonymous_Access;\n+                  Valid_I := I;\n                end if;\n \n-            else\n-               Found := True;\n-               T_F   := T1;\n-               I_F   := Index;\n-               Is_Universal_Access := Anonymous_Access;\n+               L_Typ := It.Typ;\n+               R_Typ := T;\n             end if;\n \n-            if not Analyzed (L) then\n-               Set_Etype (L, T_F);\n-            end if;\n-\n-            Find_Non_Universal_Interpretations (N, R, Op_Id, T1);\n-\n-            --  Case of operator was not visible, Etype still set to Any_Type\n+            Get_Next_Interp (I, It);\n+         end loop;\n \n-            if Etype (N) = Any_Type then\n-               Found := False;\n-            end if;\n+         if Present (L_Typ) then\n+            Set_Etype (L, L_Typ);\n+            Set_Etype (R, R_Typ);\n+            Add_One_Interp (N, Op_Id, Op_Typ, Find_Unique_Type (L, R));\n          end if;\n-      end Try_One_Interp;\n-\n-   --  Start of processing for Find_Equality_Types\n+      end if;\n+   end Find_Comparison_Equality_Types;\n \n-   begin\n-      --  If left operand is aggregate, the right operand has to\n-      --  provide a usable type for it.\n+   ------------------------------\n+   -- Find_Concatenation_Types --\n+   ------------------------------\n \n-      if Nkind (L) = N_Aggregate and then Nkind (R) /= N_Aggregate then\n-         Find_Equality_Types (L => R, R => L, Op_Id => Op_Id, N => N);\n-         return;\n-      end if;\n+   procedure Find_Concatenation_Types\n+     (L, R  : Node_Id;\n+      Op_Id : Entity_Id;\n+      N     : Node_Id)\n+   is\n+      Is_String : constant Boolean := Nkind (L) = N_String_Literal\n+                                        or else\n+                                      Nkind (R) = N_String_Literal;\n+      Op_Type   : constant Entity_Id := Etype (Op_Id);\n \n-      if Nkind (N) = N_Function_Call\n-         and then Nkind (Name (N)) = N_Expanded_Name\n-      then\n-         Scop := Entity (Prefix (Name (N)));\n+   begin\n+      if Is_Array_Type (Op_Type)\n \n-         --  The prefix may be a package renaming, and the subsequent test\n-         --  requires the original package.\n+        --  Small but very effective optimization: if at least one operand is a\n+        --  string literal, then the type of the operator must be either array\n+        --  of characters or array of strings.\n \n-         if Ekind (Scop) = E_Package\n-           and then Present (Renamed_Entity (Scop))\n-         then\n-            Scop := Renamed_Entity (Scop);\n-            Set_Entity (Prefix (Name (N)), Scop);\n-         end if;\n-      end if;\n+        and then (not Is_String\n+                    or else\n+                  Is_Character_Type (Component_Type (Op_Type))\n+                    or else\n+                  Is_String_Type (Component_Type (Op_Type)))\n \n-      if not Is_Overloaded (L) then\n-         Try_One_Interp (Etype (L));\n-      else\n-         Get_First_Interp (L, Index, It);\n-         while Present (It.Typ) loop\n-            Try_One_Interp (It.Typ);\n-            Get_Next_Interp (Index, It);\n-         end loop;\n-      end if;\n+        and then not Is_Limited_Type (Op_Type)\n \n-      if Is_Universal_Access then\n-         if Is_Access_Subprogram_Type (Etype (L))\n-           and then Nkind (L) /= N_Null\n-           and then Nkind (R) /= N_Null\n-         then\n-            Check_Compatible_Profiles (R, Etype (L));\n-         end if;\n+        and then (Has_Compatible_Type (L, Op_Type)\n+                    or else\n+                  Has_Compatible_Type (L, Component_Type (Op_Type)))\n \n-         Check_Access_Attribute (R);\n-         Check_Access_Attribute (L);\n+        and then (Has_Compatible_Type (R, Op_Type)\n+                    or else\n+                  Has_Compatible_Type (R, Component_Type (Op_Type)))\n+      then\n+         Add_One_Interp (N, Op_Id, Op_Type);\n       end if;\n-   end Find_Equality_Types;\n+   end Find_Concatenation_Types;\n \n    -------------------------\n    -- Find_Negation_Types --\n@@ -7605,7 +7309,7 @@ package body Sem_Ch4 is\n                          Standard_Address, Relocate_Node (R)));\n \n                      if Nkind (N) in N_Op_Ge | N_Op_Gt | N_Op_Le | N_Op_Lt then\n-                        Analyze_Comparison_Op (N);\n+                        Analyze_Comparison_Equality_Op (N);\n                      else\n                         Analyze_Arithmetic_Op (N);\n                      end if;\n@@ -7627,7 +7331,7 @@ package body Sem_Ch4 is\n                          Standard_Address, Relocate_Node (R)));\n \n                      if Nkind (N) in N_Op_Ge | N_Op_Gt | N_Op_Le | N_Op_Lt then\n-                        Analyze_Comparison_Op (N);\n+                        Analyze_Comparison_Equality_Op (N);\n                      else\n                         Analyze_Arithmetic_Op (N);\n                      end if;\n@@ -7657,7 +7361,7 @@ package body Sem_Ch4 is\n                          Standard_Address, Relocate_Node (R)));\n \n                      if Nkind (N) in N_Op_Ge | N_Op_Gt | N_Op_Le | N_Op_Lt then\n-                        Analyze_Comparison_Op (N);\n+                        Analyze_Comparison_Equality_Op (N);\n                      else\n                         Analyze_Arithmetic_Op (N);\n                      end if;\n@@ -7681,7 +7385,7 @@ package body Sem_Ch4 is\n                   Replace_Null_By_Null_Address (N);\n \n                   if Nkind (N) in N_Op_Ge | N_Op_Gt | N_Op_Le | N_Op_Lt then\n-                     Analyze_Comparison_Op (N);\n+                     Analyze_Comparison_Equality_Op (N);\n                   else\n                      Analyze_Arithmetic_Op (N);\n                   end if;\n@@ -7758,15 +7462,15 @@ package body Sem_Ch4 is\n                   Rewrite (R,\n                     Unchecked_Convert_To (\n                       Standard_Address, Relocate_Node (R)));\n-                  Analyze_Equality_Op (N);\n+                  Analyze_Comparison_Equality_Op (N);\n                   return;\n \n                --  Under relaxed RM semantics silently replace occurrences of\n                --  null by System.Address_Null.\n \n                elsif Null_To_Null_Address_Convert_OK (N) then\n                   Replace_Null_By_Null_Address (N);\n-                  Analyze_Equality_Op (N);\n+                  Analyze_Comparison_Equality_Op (N);\n                   return;\n                end if;\n             end if;"}, {"sha": "870edea0b64821ab7d708acd0686eb30c0966719", "filename": "gcc/ada/sem_ch4.ads", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.ads?ref=eb05097d5508618a70b279df6d10d409eb4c60ae", "patch": "@@ -31,9 +31,8 @@ package Sem_Ch4  is\n    procedure Analyze_Arithmetic_Op             (N : Node_Id);\n    procedure Analyze_Call                      (N : Node_Id);\n    procedure Analyze_Case_Expression           (N : Node_Id);\n-   procedure Analyze_Comparison_Op             (N : Node_Id);\n+   procedure Analyze_Comparison_Equality_Op    (N : Node_Id);\n    procedure Analyze_Concatenation             (N : Node_Id);\n-   procedure Analyze_Equality_Op               (N : Node_Id);\n    procedure Analyze_Explicit_Dereference      (N : Node_Id);\n    procedure Analyze_Expression_With_Actions   (N : Node_Id);\n    procedure Analyze_If_Expression             (N : Node_Id);\n@@ -54,6 +53,10 @@ package Sem_Ch4  is\n    procedure Analyze_Unchecked_Expression      (N : Node_Id);\n    procedure Analyze_Unchecked_Type_Conversion (N : Node_Id);\n \n+   procedure Ambiguous_Operands (N : Node_Id);\n+   --  Give an error for comparison, equality and membership operators with\n+   --  ambiguous operands, and list possible interpretations.\n+\n    procedure Analyze_Indexed_Component_Form    (N : Node_Id);\n    --  Prior to semantic analysis, an indexed component node can denote any\n    --  of the following syntactic constructs:"}, {"sha": "77f8817fe24c4503eab526cedb33028f71294962", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=eb05097d5508618a70b279df6d10d409eb4c60ae", "patch": "@@ -509,6 +509,7 @@ package body Sem_Ch8 is\n \n    function Has_Implicit_Operator (N : Node_Id) return Boolean;\n    --  N is an expanded name whose selector is an operator name (e.g. P.\"+\").\n+   --  Determine if N denotes an operator implicitly declared in prefix P: P's\n    --  declarative part contains an implicit declaration of an operator if it\n    --  has a declaration of a type to which one of the predefined operators\n    --  apply. The existence of this routine is an implementation artifact. A\n@@ -8650,7 +8651,10 @@ package body Sem_Ch8 is\n             | Name_Op_Xor\n          =>\n             while Id /= Priv_Id loop\n-               if Valid_Boolean_Arg (Id) and then Is_Base_Type (Id) then\n+               if Is_Type (Id)\n+                 and then Valid_Boolean_Arg (Id)\n+                 and then Is_Base_Type (Id)\n+               then\n                   Add_Implicit_Operator (Id);\n                   return True;\n                end if;\n@@ -8665,7 +8669,7 @@ package body Sem_Ch8 is\n          =>\n             while Id /= Priv_Id loop\n                if Is_Type (Id)\n-                 and then not Is_Limited_Type (Id)\n+                 and then Valid_Equality_Arg (Id)\n                  and then Is_Base_Type (Id)\n                then\n                   Add_Implicit_Operator (Standard_Boolean, Id);\n@@ -8683,9 +8687,8 @@ package body Sem_Ch8 is\n             | Name_Op_Lt\n          =>\n             while Id /= Priv_Id loop\n-               if (Is_Scalar_Type (Id)\n-                    or else (Is_Array_Type (Id)\n-                              and then Is_Scalar_Type (Component_Type (Id))))\n+               if Is_Type (Id)\n+                 and then Valid_Comparison_Arg (Id)\n                  and then Is_Base_Type (Id)\n                then\n                   Add_Implicit_Operator (Standard_Boolean, Id);"}, {"sha": "b918615904ede8112e9ec481cd1a9f21c4d9f4ae", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 222, "deletions": 136, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=eb05097d5508618a70b279df6d10d409eb4c60ae", "patch": "@@ -141,7 +141,7 @@ package body Sem_Res is\n \n    function Is_Atomic_Ref_With_Address (N : Node_Id) return Boolean;\n    --  N is either an indexed component or a selected component. This function\n-   --  returns true if the prefix refers to an object that has an address\n+   --  returns true if the prefix denotes an atomic object that has an address\n    --  clause (the case in which we may want to issue a warning).\n \n    function Is_Definite_Access_Type (E : Entity_Id) return Boolean;\n@@ -823,7 +823,10 @@ package body Sem_Res is\n \n    procedure Check_For_Visible_Operator (N : Node_Id; T : Entity_Id) is\n    begin\n-      if Is_Invisible_Operator (N, T) then\n+      if Comes_From_Source (N)\n+        and then not Is_Visible_Operator (Original_Node (N), T)\n+        and then not Error_Posted (N)\n+      then\n          Error_Msg_NE -- CODEFIX\n            (\"operator for} is not directly visible!\", N, First_Subtype (T));\n          Error_Msg_N -- CODEFIX\n@@ -1662,6 +1665,14 @@ package body Sem_Res is\n    begin\n       Op_Node := New_Node (Operator_Kind (Op_Name, Is_Binary), Sloc (N));\n \n+      --  Preserve the Comes_From_Source flag on the result if the original\n+      --  call came from source. Although it is not strictly the case that the\n+      --  operator as such comes from the source, logically it corresponds\n+      --  exactly to the function call in the source, so it should be marked\n+      --  this way (e.g. to make sure that validity checks work fine).\n+\n+      Preserve_Comes_From_Source (Op_Node, N);\n+\n       --  Ensure that the corresponding operator has the same parent as the\n       --  original call. This guarantees that parent traversals performed by\n       --  the ABE mechanism succeed.\n@@ -1900,18 +1911,7 @@ package body Sem_Res is\n       Set_Entity (Op_Node, Op_Id);\n       Generate_Reference (Op_Id, N, ' ');\n \n-      --  Do rewrite setting Comes_From_Source on the result if the original\n-      --  call came from source. Although it is not strictly the case that the\n-      --  operator as such comes from the source, logically it corresponds\n-      --  exactly to the function call in the source, so it should be marked\n-      --  this way (e.g. to make sure that validity checks work fine).\n-\n-      declare\n-         CS : constant Boolean := Comes_From_Source (N);\n-      begin\n-         Rewrite (N, Op_Node);\n-         Set_Comes_From_Source (N, CS);\n-      end;\n+      Rewrite (N, Op_Node);\n \n       --  If this is an arithmetic operator and the result type is private,\n       --  the operands and the result must be wrapped in conversion to\n@@ -4148,15 +4148,38 @@ package body Sem_Res is\n          if No (A) and then Needs_No_Actuals (Nam) then\n             null;\n \n-         --  If we have an error in any actual or formal, indicated by a type\n+         --  If we have an error in any formal or actual, indicated by a type\n          --  of Any_Type, then abandon resolution attempt, and set result type\n-         --  to Any_Type. Skip this if the actual is a Raise_Expression, whose\n-         --  type is imposed from context.\n+         --  to Any_Type.\n \n-         elsif (Present (A) and then Etype (A) = Any_Type)\n-           or else Etype (F) = Any_Type\n-         then\n-            if Nkind (A) /= N_Raise_Expression then\n+         elsif Etype (F) = Any_Type then\n+            Set_Etype (N, Any_Type);\n+            return;\n+\n+         elsif Present (A) and then Etype (A) = Any_Type then\n+            --  For the peculiar case of a user-defined comparison or equality\n+            --  operator that does not return a boolean type, the operands may\n+            --  have been ambiguous for the predefined operator and, therefore,\n+            --  marked with Any_Type. Since the operation has been resolved to\n+            --  the user-defined operator, that is irrelevant, so reset Etype.\n+\n+            if Nkind (Original_Node (N)) in N_Op_Eq\n+                                          | N_Op_Ge\n+                                          | N_Op_Gt\n+                                          | N_Op_Le\n+                                          | N_Op_Lt\n+                                          | N_Op_Ne\n+              and then not Is_Boolean_Type (Etype (N))\n+            then\n+               Set_Etype (A, Etype (F));\n+\n+            --  Also skip this if the actual is a Raise_Expression, whose type\n+            --  is imposed from context.\n+\n+            elsif Nkind (A) = N_Raise_Expression then\n+               null;\n+\n+            else\n                Set_Etype (N, Any_Type);\n                return;\n             end if;\n@@ -6856,13 +6879,11 @@ package body Sem_Res is\n       --  functional notation. Replace call node with operator node, so\n       --  that actuals can be resolved appropriately.\n \n-      if Is_Predefined_Op (Nam) or else Ekind (Nam) = E_Operator then\n-         Make_Call_Into_Operator (N, Typ, Entity (Name (N)));\n+      if Ekind (Nam) = E_Operator or else Is_Predefined_Op (Nam) then\n+         Make_Call_Into_Operator (N, Typ, Nam);\n          return;\n \n-      elsif Present (Alias (Nam))\n-        and then Is_Predefined_Op (Alias (Nam))\n-      then\n+      elsif Present (Alias (Nam)) and then Is_Predefined_Op (Alias (Nam)) then\n          Resolve_Actuals (N, Nam);\n          Make_Call_Into_Operator (N, Typ, Alias (Nam));\n          return;\n@@ -7489,39 +7510,35 @@ package body Sem_Res is\n    -- Resolve_Comparison_Op --\n    ---------------------------\n \n-   --  Context requires a boolean type, and plays no role in resolution.\n-   --  Processing identical to that for equality operators. The result type is\n-   --  the base type, which matters when pathological subtypes of booleans with\n-   --  limited ranges are used.\n+   --  The operands must have compatible types and the boolean context does not\n+   --  participate in the resolution. The first pass verifies that the operands\n+   --  are not ambiguous and sets their type correctly, or to Any_Type in case\n+   --  of ambiguity. If both operands are strings or aggregates, then they are\n+   --  ambiguous even if they carry a single (universal) type.\n \n    procedure Resolve_Comparison_Op (N : Node_Id; Typ : Entity_Id) is\n       L : constant Node_Id := Left_Opnd (N);\n       R : constant Node_Id := Right_Opnd (N);\n-      T : Entity_Id;\n-\n-   begin\n-      --  If this is an intrinsic operation which is not predefined, use the\n-      --  types of its declared arguments to resolve the possibly overloaded\n-      --  operands. Otherwise the operands are unambiguous and specify the\n-      --  expected type.\n \n-      if Scope (Entity (N)) /= Standard_Standard then\n-         T := Etype (First_Entity (Entity (N)));\n-\n-      else\n-         T := Find_Unique_Type (L, R);\n+      T : Entity_Id := Find_Unique_Type (L, R);\n \n-         if T = Any_Fixed then\n-            T := Unique_Fixed_Point_Type (L);\n-         end if;\n+   begin\n+      if T = Any_Fixed then\n+         T := Unique_Fixed_Point_Type (L);\n       end if;\n \n       Set_Etype (N, Base_Type (Typ));\n       Generate_Reference (T, N, ' ');\n \n-      --  Skip remaining processing if already set to Any_Type\n-\n       if T = Any_Type then\n+         --  Deal with explicit ambiguity of operands\n+\n+         if Ekind (Entity (N)) = E_Operator\n+           and then (Is_Overloaded (L) or else Is_Overloaded (R))\n+         then\n+            Ambiguous_Operands (N);\n+         end if;\n+\n          return;\n       end if;\n \n@@ -8510,25 +8527,38 @@ package body Sem_Res is\n       --  overlapping actuals, just like for a subprogram call.\n \n       Warn_On_Overlapping_Actuals (Nam, N);\n-\n    end Resolve_Entry_Call;\n \n    -------------------------\n    -- Resolve_Equality_Op --\n    -------------------------\n \n-   --  Both arguments must have the same type, and the boolean context does\n-   --  not participate in the resolution. The first pass verifies that the\n-   --  interpretation is not ambiguous, and the type of the left argument is\n-   --  correctly set, or is Any_Type in case of ambiguity. If both arguments\n-   --  are strings or aggregates, allocators, or Null, they are ambiguous even\n-   --  though they carry a single (universal) type. Diagnose this case here.\n+   --  The operands must have compatible types and the boolean context does not\n+   --  participate in the resolution. The first pass verifies that the operands\n+   --  are not ambiguous and sets their type correctly, or to Any_Type in case\n+   --  of ambiguity. If both operands are strings, aggregates, allocators, or\n+   --  null, they are ambiguous even if they carry a single (universal) type.\n \n    procedure Resolve_Equality_Op (N : Node_Id; Typ : Entity_Id) is\n-      L : constant Node_Id   := Left_Opnd (N);\n-      R : constant Node_Id   := Right_Opnd (N);\n+      L : constant Node_Id := Left_Opnd (N);\n+      R : constant Node_Id := Right_Opnd (N);\n+\n       T : Entity_Id := Find_Unique_Type (L, R);\n \n+      procedure Check_Access_Attribute (N : Node_Id);\n+      --  For any object, '[Unchecked_]Access of such object can never be\n+      --  passed as an operand to the Universal_Access equality operators.\n+      --  This is so because the expected type for Obj'Access in a call to\n+      --  these operators, whose formals are of type Universal_Access, is\n+      --  Universal_Access, and Universal_Access does not have a designated\n+      --  type. For more details, see RM 3.10.2(2/2) and 6.4.1(3).\n+\n+      procedure Check_Designated_Object_Types (T1, T2 : Entity_Id);\n+      --  Check RM 4.5.2(9.6/2) on the given designated object types\n+\n+      procedure Check_Designated_Subprogram_Types (T1, T2 : Entity_Id);\n+      --  Check RM 4.5.2(9.7/2) on the given designated subprogram types\n+\n       procedure Check_If_Expression (Cond : Node_Id);\n       --  The resolution rule for if expressions requires that each such must\n       --  have a unique type. This means that if several dependent expressions\n@@ -8554,6 +8584,54 @@ package body Sem_Res is\n       --  could be the cause of confused priorities. Note that if the not is\n       --  in parens, then False is returned.\n \n+      ----------------------------\n+      -- Check_Access_Attribute --\n+      ----------------------------\n+\n+      procedure Check_Access_Attribute (N : Node_Id) is\n+      begin\n+         if Nkind (N) = N_Attribute_Reference\n+           and then Attribute_Name (N) in Name_Access | Name_Unchecked_Access\n+         then\n+            Error_Msg_N\n+              (\"access attribute cannot be used as actual for \"\n+               & \"universal_access equality\", N);\n+         end if;\n+      end Check_Access_Attribute;\n+\n+      -----------------------------------\n+      -- Check_Designated_Object_Types --\n+      -----------------------------------\n+\n+      procedure Check_Designated_Object_Types (T1, T2 : Entity_Id) is\n+      begin\n+         if (Is_Elementary_Type (T1) or else Is_Array_Type (T1))\n+           and then (Base_Type (T1) /= Base_Type (T2)\n+                      or else not Subtypes_Statically_Match (T1, T2))\n+         then\n+            Error_Msg_N\n+              (\"designated subtypes for universal_access equality \"\n+               & \"do not statically match (RM 4.5.2(9.6/2)\", N);\n+            Error_Msg_NE (\"\\left operand has}!\",  N, Etype (L));\n+            Error_Msg_NE (\"\\right operand has}!\", N, Etype (R));\n+         end if;\n+      end Check_Designated_Object_Types;\n+\n+      ---------------------------------------\n+      -- Check_Designated_Subprogram_Types --\n+      ---------------------------------------\n+\n+      procedure Check_Designated_Subprogram_Types (T1, T2 : Entity_Id) is\n+      begin\n+         if not Subtype_Conformant (T1, T2) then\n+            Error_Msg_N\n+              (\"designated subtypes for universal_access equality \"\n+               & \"not subtype conformant (RM 4.5.2(9.7/2)\", N);\n+            Error_Msg_NE (\"\\left operand has}!\",  N, Etype (L));\n+            Error_Msg_NE (\"\\right operand has}!\", N, Etype (R));\n+         end if;\n+      end Check_Designated_Subprogram_Types;\n+\n       -------------------------\n       -- Check_If_Expression --\n       -------------------------\n@@ -8727,14 +8805,25 @@ package body Sem_Res is\n    --  Start of processing for Resolve_Equality_Op\n \n    begin\n-      Set_Etype (N, Base_Type (Typ));\n-      Generate_Reference (T, N, ' ');\n-\n       if T = Any_Fixed then\n          T := Unique_Fixed_Point_Type (L);\n       end if;\n \n-      if T /= Any_Type then\n+      Set_Etype (N, Base_Type (Typ));\n+      Generate_Reference (T, N, ' ');\n+\n+      if T = Any_Type then\n+         --  Deal with explicit ambiguity of operands\n+\n+         if Ekind (Entity (N)) = E_Operator\n+           and then (Is_Overloaded (L) or else Is_Overloaded (R))\n+         then\n+            Ambiguous_Operands (N);\n+         end if;\n+\n+      else\n+         --  Deal with other error cases\n+\n          if T = Any_String    or else\n             T = Any_Composite or else\n             T = Any_Character\n@@ -8773,6 +8862,44 @@ package body Sem_Res is\n             Check_If_Expression (R);\n          end if;\n \n+         --  RM 4.5.2(9.5/2): At least one of the operands of the equality\n+         --  operators for universal_access shall be of type universal_access,\n+         --  or both shall be of access-to-object types, or both shall be of\n+         --  access-to-subprogram types (RM 4.5.2(9.5/2)).\n+\n+         if Is_Anonymous_Access_Type (T)\n+           and then Etype (L) /= Universal_Access\n+           and then Etype (R) /= Universal_Access\n+         then\n+            --  RM 4.5.2(9.6/2): When both are of access-to-object types, the\n+            --  designated types shall be the same or one shall cover the other\n+            --  and if the designated types are elementary or array types, then\n+            --  the designated subtypes shall statically match.\n+\n+            if Is_Access_Object_Type (Etype (L))\n+              and then Is_Access_Object_Type (Etype (R))\n+            then\n+               Check_Designated_Object_Types\n+                 (Designated_Type (Etype (L)), Designated_Type (Etype (R)));\n+\n+            --  RM 4.5.2(9.7/2): When both are of access-to-subprogram types,\n+            --  the designated profiles shall be subtype conformant.\n+\n+            elsif Is_Access_Subprogram_Type (Etype (L))\n+              and then Is_Access_Subprogram_Type (Etype (R))\n+            then\n+               Check_Designated_Subprogram_Types\n+                 (Designated_Type (Etype (L)), Designated_Type (Etype (R)));\n+            end if;\n+         end if;\n+\n+         --  Check another case of equality operators for universal_access\n+\n+         if Is_Anonymous_Access_Type (T) and then Comes_From_Source (N) then\n+            Check_Access_Attribute (L);\n+            Check_Access_Attribute (R);\n+         end if;\n+\n          Resolve (L, T);\n          Resolve (R, T);\n \n@@ -8895,33 +9022,6 @@ package body Sem_Res is\n          then\n             Error_Msg_NE (\"cannot call abstract subprogram &!\", N, Entity (N));\n          end if;\n-\n-         --  Ada 2005: If one operand is an anonymous access type, convert the\n-         --  other operand to it, to ensure that the underlying types match in\n-         --  the back-end. Same for access_to_subprogram, and the conversion\n-         --  verifies that the types are subtype conformant.\n-\n-         --  We apply the same conversion in the case one of the operands is a\n-         --  private subtype of the type of the other.\n-\n-         --  Why the Expander_Active test here ???\n-\n-         if Expander_Active\n-           and then\n-             (Ekind (T) in E_Anonymous_Access_Type\n-                         | E_Anonymous_Access_Subprogram_Type\n-               or else Is_Private_Type (T))\n-         then\n-            if Etype (L) /= T then\n-               Rewrite (L, Unchecked_Convert_To (T, L));\n-               Analyze_And_Resolve (L, T);\n-            end if;\n-\n-            if (Etype (R)) /= T then\n-               Rewrite (R, Unchecked_Convert_To (Etype (L), R));\n-               Analyze_And_Resolve (R, T);\n-            end if;\n-         end if;\n       end if;\n    end Resolve_Equality_Op;\n \n@@ -12592,63 +12692,49 @@ package body Sem_Res is\n          end;\n       end if;\n \n-      --  Rewrite the operator node using the real operator, not its renaming.\n-      --  Exclude user-defined intrinsic operations of the same name, which are\n-      --  treated separately and rewritten as calls.\n-\n-      if Ekind (Op) /= E_Function or else Chars (N) /= Nam then\n-         Op_Node := New_Node (Operator_Kind (Nam, Is_Binary), Sloc (N));\n-         Set_Chars      (Op_Node, Nam);\n-         Set_Etype      (Op_Node, Etype (N));\n-         Set_Entity     (Op_Node, Op);\n-         Set_Right_Opnd (Op_Node, Right_Opnd (N));\n+      Op_Node := New_Node (Operator_Kind (Nam, Is_Binary), Sloc (N));\n+      Set_Chars      (Op_Node, Nam);\n+      Set_Etype      (Op_Node, Etype (N));\n+      Set_Entity     (Op_Node, Op);\n+      Set_Right_Opnd (Op_Node, Right_Opnd (N));\n \n-         --  Indicate that both the original entity and its renaming are\n-         --  referenced at this point.\n-\n-         Generate_Reference (Entity (N), N);\n-         Generate_Reference (Op, N);\n-\n-         if Is_Binary then\n-            Set_Left_Opnd (Op_Node, Left_Opnd (N));\n-         end if;\n+      if Is_Binary then\n+         Set_Left_Opnd (Op_Node, Left_Opnd (N));\n+      end if;\n \n-         Rewrite (N, Op_Node);\n+      --  Indicate that both the original entity and its renaming are\n+      --  referenced at this point.\n \n-         --  If the context type is private, add the appropriate conversions so\n-         --  that the operator is applied to the full view. This is done in the\n-         --  routines that resolve intrinsic operators.\n+      Generate_Reference (Entity (N), N);\n+      Generate_Reference (Op, N);\n \n-         if Is_Intrinsic_Subprogram (Op) and then Is_Private_Type (Typ) then\n-            case Nkind (N) is\n-               when N_Op_Add\n-                  | N_Op_Divide\n-                  | N_Op_Expon\n-                  | N_Op_Mod\n-                  | N_Op_Multiply\n-                  | N_Op_Rem\n-                  | N_Op_Subtract\n-               =>\n-                  Resolve_Intrinsic_Operator (N, Typ);\n-\n-               when N_Op_Abs\n-                  | N_Op_Minus\n-                  | N_Op_Plus\n-               =>\n-                  Resolve_Intrinsic_Unary_Operator (N, Typ);\n+      Rewrite (N, Op_Node);\n \n-               when others =>\n-                  Resolve (N, Typ);\n-            end case;\n-         end if;\n+      --  If the context type is private, add the appropriate conversions so\n+      --  that the operator is applied to the full view. This is done in the\n+      --  routines that resolve intrinsic operators.\n \n-      elsif Ekind (Op) = E_Function and then Is_Intrinsic_Subprogram (Op) then\n+      if Is_Intrinsic_Subprogram (Op) and then Is_Private_Type (Typ) then\n+         case Nkind (N) is\n+            when N_Op_Add\n+               | N_Op_Divide\n+               | N_Op_Expon\n+               | N_Op_Mod\n+               | N_Op_Multiply\n+               | N_Op_Rem\n+               | N_Op_Subtract\n+            =>\n+               Resolve_Intrinsic_Operator (N, Typ);\n \n-         --  Operator renames a user-defined operator of the same name. Use the\n-         --  original operator in the node, which is the one Gigi knows about.\n+            when N_Op_Abs\n+               | N_Op_Minus\n+               | N_Op_Plus\n+            =>\n+               Resolve_Intrinsic_Unary_Operator (N, Typ);\n \n-         Set_Entity (N, Op);\n-         Set_Is_Overloaded (N, False);\n+            when others =>\n+               Resolve (N, Typ);\n+         end case;\n       end if;\n    end Rewrite_Renamed_Operator;\n "}, {"sha": "4cb0d8d9e9f18d4705af1be8cb121357b62f2789", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 257, "deletions": 289, "changes": 546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=eb05097d5508618a70b279df6d10d409eb4c60ae", "patch": "@@ -192,10 +192,6 @@ package body Sem_Type is\n    --  multiple interpretations. Interpretations can be added to only one\n    --  node at a time.\n \n-   function Specific_Type (Typ_1, Typ_2 : Entity_Id) return Entity_Id;\n-   --  If Typ_1 and Typ_2 are compatible, return the one that is not universal\n-   --  or is not a \"class\" type (any_character, etc).\n-\n    --------------------\n    -- Add_One_Interp --\n    --------------------\n@@ -365,14 +361,12 @@ package body Sem_Type is\n    --  Start of processing for Add_One_Interp\n \n    begin\n-      --  If the interpretation is a predefined operator, verify that the\n-      --  result type is visible, or that the entity has already been\n-      --  resolved (case of an instantiation node that refers to a predefined\n-      --  operation, or an internally generated operator node, or an operator\n-      --  given as an expanded name). If the operator is a comparison or\n-      --  equality, it is the type of the operand that matters to determine\n-      --  whether the operator is visible. In an instance, the check is not\n-      --  performed, given that the operator was visible in the generic.\n+      --  If the interpretation is a predefined operator, verify that it is\n+      --  visible, or that the entity has already been resolved (case of an\n+      --  instantiation node that refers to a predefined operation, or an\n+      --  internally generated operator node, or an operator given as an\n+      --  expanded name). If the operator is a comparison or equality, then\n+      --  it is the type of the operand that is relevant here.\n \n       if Ekind (E) = E_Operator then\n          if Present (Opnd_Type) then\n@@ -381,29 +375,9 @@ package body Sem_Type is\n             Vis_Type := Base_Type (T);\n          end if;\n \n-         if In_Open_Scopes (Scope (Vis_Type))\n-           or else Is_Potentially_Use_Visible (Vis_Type)\n-           or else In_Use (Vis_Type)\n-           or else (In_Use (Scope (Vis_Type))\n-                     and then not Is_Hidden (Vis_Type))\n-           or else Nkind (N) = N_Expanded_Name\n+         if Nkind (N) = N_Expanded_Name\n            or else (Nkind (N) in N_Op and then E = Entity (N))\n-           or else (In_Instance or else In_Inlined_Body)\n-           or else Is_Anonymous_Access_Type (Vis_Type)\n-         then\n-            null;\n-\n-         --  If the node is given in functional notation and the prefix\n-         --  is an expanded name, then the operator is visible if the\n-         --  prefix is the scope of the result type as well. If the\n-         --  operator is (implicitly) defined in an extension of system,\n-         --  it is know to be valid (see Defined_In_Scope, sem_ch4.adb).\n-\n-         elsif Nkind (N) = N_Function_Call\n-           and then Nkind (Name (N)) = N_Expanded_Name\n-           and then (Entity (Prefix (Name (N))) = Scope (Base_Type (T))\n-                      or else Entity (Prefix (Name (N))) = Scope (Vis_Type)\n-                      or else Scope (Vis_Type) = System_Aux_Id)\n+           or else Is_Visible_Operator (N, Vis_Type)\n          then\n             null;\n \n@@ -1334,7 +1308,7 @@ package body Sem_Type is\n       --  It may given by an operator name, or by an expanded name whose prefix\n       --  is Standard.\n \n-      function Remove_Conversions return Interp;\n+      function Remove_Conversions_And_Abstract_Operations return Interp;\n       --  Last chance for pathological cases involving comparisons on literals,\n       --  and user overloadings of the same operator. Such pathologies have\n       --  been removed from the ACVC, but still appear in two DEC tests, with\n@@ -1522,11 +1496,11 @@ package body Sem_Type is\n          return Etype (Opnd);\n       end Operand_Type;\n \n-      ------------------------\n-      -- Remove_Conversions --\n-      ------------------------\n+      ------------------------------------------------\n+      -- Remove_Conversions_And_Abstract_Operations --\n+      ------------------------------------------------\n \n-      function Remove_Conversions return Interp is\n+      function Remove_Conversions_And_Abstract_Operations return Interp is\n          I    : Interp_Index;\n          It   : Interp;\n          It1  : Interp;\n@@ -1535,13 +1509,16 @@ package body Sem_Type is\n          Act2 : Node_Id;\n \n          function Has_Abstract_Interpretation (N : Node_Id) return Boolean;\n-         --  If an operation has universal operands the universal operation\n+         --  If an operation has universal operands, the universal operation\n          --  is present among its interpretations. If there is an abstract\n          --  interpretation for the operator, with a numeric result, this\n          --  interpretation was already removed in sem_ch4, but the universal\n          --  one is still visible. We must rescan the list of operators and\n          --  remove the universal interpretation to resolve the ambiguity.\n \n+         function Is_Numeric_Only_Type (T : Entity_Id) return Boolean;\n+         --  Return True if T is a numeric type and not Any_Type\n+\n          ---------------------------------\n          -- Has_Abstract_Interpretation --\n          ---------------------------------\n@@ -1562,7 +1539,7 @@ package body Sem_Type is\n                while Present (E) loop\n                   if Is_Overloadable (E)\n                     and then Is_Abstract_Subprogram (E)\n-                    and then Is_Numeric_Type (Etype (E))\n+                    and then Is_Numeric_Only_Type (Etype (E))\n                   then\n                      return True;\n                   else\n@@ -1587,7 +1564,16 @@ package body Sem_Type is\n             end if;\n          end Has_Abstract_Interpretation;\n \n-      --  Start of processing for Remove_Conversions\n+         --------------------------\n+         -- Is_Numeric_Only_Type --\n+         --------------------------\n+\n+         function Is_Numeric_Only_Type (T : Entity_Id) return Boolean is\n+         begin\n+            return Is_Numeric_Type (T) and then T /= Any_Type;\n+         end Is_Numeric_Only_Type;\n+\n+      --  Start of processing for Remove_Conversions_And_Abstract_Operations\n \n       begin\n          It1 := No_Interp;\n@@ -1676,11 +1662,11 @@ package body Sem_Type is\n                      It1 := It;\n                   end if;\n \n-               elsif Is_Numeric_Type (Etype (F1))\n+               elsif Is_Numeric_Only_Type (Etype (F1))\n                  and then Has_Abstract_Interpretation (Act1)\n                then\n                   --  Current interpretation is not the right one because it\n-                  --  expects a numeric operand. Examine all the other ones.\n+                  --  expects a numeric operand. Examine all the others.\n \n                   declare\n                      I  : Interp_Index;\n@@ -1689,14 +1675,14 @@ package body Sem_Type is\n                   begin\n                      Get_First_Interp (N, I, It);\n                      while Present (It.Typ) loop\n-                        if\n-                          not Is_Numeric_Type (Etype (First_Formal (It.Nam)))\n+                        if not Is_Numeric_Only_Type\n+                                 (Etype (First_Formal (It.Nam)))\n                         then\n                            if No (Act2)\n-                             or else not Has_Abstract_Interpretation (Act2)\n                              or else not\n-                               Is_Numeric_Type\n+                               Is_Numeric_Only_Type\n                                  (Etype (Next_Formal (First_Formal (It.Nam))))\n+                             or else not Has_Abstract_Interpretation (Act2)\n                            then\n                               return It;\n                            end if;\n@@ -1707,44 +1693,46 @@ package body Sem_Type is\n \n                      return No_Interp;\n                   end;\n-               end if;\n-            end if;\n-\n-            <<Next_Interp>>\n-               Get_Next_Interp (I, It);\n-         end loop;\n \n-         --  After some error, a formal may have Any_Type and yield a spurious\n-         --  match. To avoid cascaded errors if possible, check for such a\n-         --  formal in either candidate.\n+               elsif Is_Numeric_Only_Type (Etype (F1))\n+                 and then Present (Act2)\n+                 and then Has_Abstract_Interpretation (Act2)\n+               then\n+                  --  Current interpretation is not the right one because it\n+                  --  expects a numeric operand. Examine all the others.\n \n-         if Serious_Errors_Detected > 0 then\n-            declare\n-               Formal : Entity_Id;\n+                  declare\n+                     I  : Interp_Index;\n+                     It : Interp;\n \n-            begin\n-               Formal := First_Formal (Nam1);\n-               while Present (Formal) loop\n-                  if Etype (Formal) = Any_Type then\n-                     return Disambiguate.It2;\n-                  end if;\n+                  begin\n+                     Get_First_Interp (N, I, It);\n+                     while Present (It.Typ) loop\n+                        if not Is_Numeric_Only_Type\n+                                (Etype (Next_Formal (First_Formal (It.Nam))))\n+                        then\n+                           if not Is_Numeric_Only_Type\n+                                    (Etype (First_Formal (It.Nam)))\n+                             or else not Has_Abstract_Interpretation (Act1)\n+                           then\n+                              return It;\n+                           end if;\n+                        end if;\n \n-                  Next_Formal (Formal);\n-               end loop;\n+                        Get_Next_Interp (I, It);\n+                     end loop;\n \n-               Formal := First_Formal (Nam2);\n-               while Present (Formal) loop\n-                  if Etype (Formal) = Any_Type then\n-                     return Disambiguate.It1;\n-                  end if;\n+                     return No_Interp;\n+                  end;\n+               end if;\n+            end if;\n \n-                  Next_Formal (Formal);\n-               end loop;\n-            end;\n-         end if;\n+            <<Next_Interp>>\n+               Get_Next_Interp (I, It);\n+         end loop;\n \n          return It1;\n-      end Remove_Conversions;\n+      end Remove_Conversions_And_Abstract_Operations;\n \n       -----------------------\n       -- Standard_Operator --\n@@ -2145,10 +2133,10 @@ package body Sem_Type is\n                end if;\n \n             else\n-               return Remove_Conversions;\n+               return Remove_Conversions_And_Abstract_Operations;\n             end if;\n          else\n-            return Remove_Conversions;\n+            return Remove_Conversions_And_Abstract_Operations;\n          end if;\n       end if;\n \n@@ -2162,18 +2150,19 @@ package body Sem_Type is\n       then\n          return No_Interp;\n \n-      --  If the user-defined operator is in an open scope, or in the scope\n-      --  of the resulting type, or given by an expanded name that names its\n-      --  scope, it hides the predefined operator for the type. Exponentiation\n-      --  has to be special-cased because the implicit operator does not have\n-      --  a symmetric signature, and may not be hidden by the explicit one.\n-\n-      elsif (Nkind (N) = N_Function_Call\n-              and then Nkind (Name (N)) = N_Expanded_Name\n-              and then (Chars (Predef_Subp) /= Name_Op_Expon\n-                         or else Hides_Op (User_Subp, Predef_Subp))\n-              and then Scope (User_Subp) = Entity (Prefix (Name (N))))\n-        or else Hides_Op (User_Subp, Predef_Subp)\n+      --  If the user-defined operator matches the signature of the operator,\n+      --  and is declared in an open scope, or in the scope of the resulting\n+      --  type, or given by an expanded name that names its scope, it hides\n+      --  the predefined operator for the type. But exponentiation has to be\n+      --  special-cased because the latter operator does not have a symmetric\n+      --  signature, and may not be hidden by the explicit one.\n+\n+      elsif Hides_Op (User_Subp, Predef_Subp)\n+        or else (Nkind (N) = N_Function_Call\n+                  and then Nkind (Name (N)) = N_Expanded_Name\n+                  and then (Chars (Predef_Subp) /= Name_Op_Expon\n+                             or else Hides_Op (User_Subp, Predef_Subp))\n+                  and then Scope (User_Subp) = Entity (Prefix (Name (N))))\n       then\n          if It1.Nam = User_Subp then\n             return It1;\n@@ -2246,7 +2235,7 @@ package body Sem_Type is\n                end if;\n \n             else\n-               return No_Interp;\n+               return Remove_Conversions_And_Abstract_Operations;\n             end if;\n \n          elsif It1.Nam = Predef_Subp then\n@@ -2264,21 +2253,25 @@ package body Sem_Type is\n \n    function Entity_Matches_Spec (Old_S, New_S : Entity_Id) return Boolean is\n    begin\n-      --  Simple case: same entity kinds, type conformance is required. A\n-      --  parameterless function can also rename a literal.\n+      --  For the simple case of same kinds, type conformance is required, but\n+      --  a parameterless function can also rename a literal.\n \n       if Ekind (Old_S) = Ekind (New_S)\n         or else (Ekind (New_S) = E_Function\n                   and then Ekind (Old_S) = E_Enumeration_Literal)\n       then\n          return Type_Conformant (New_S, Old_S);\n \n-      elsif Ekind (New_S) = E_Function and then Ekind (Old_S) = E_Operator then\n-         return Operator_Matches_Spec (Old_S, New_S);\n+      --  Likewise for a procedure and an entry\n \n       elsif Ekind (New_S) = E_Procedure and then Is_Entry (Old_S) then\n          return Type_Conformant (New_S, Old_S);\n \n+      --  For a user-defined operator, use the dedicated predicate\n+\n+      elsif Ekind (New_S) = E_Function and then Ekind (Old_S) = E_Operator then\n+         return Operator_Matches_Spec (Old_S, New_S);\n+\n       else\n          return False;\n       end if;\n@@ -2289,60 +2282,18 @@ package body Sem_Type is\n    ----------------------\n \n    function Find_Unique_Type (L : Node_Id; R : Node_Id) return Entity_Id is\n-      T  : constant Entity_Id := Etype (L);\n-      I  : Interp_Index;\n-      It : Interp;\n-      TR : Entity_Id := Any_Type;\n+      T  : constant Entity_Id := Specific_Type (Etype (L), Etype (R));\n \n    begin\n-      if Is_Overloaded (R) then\n-         Get_First_Interp (R, I, It);\n-         while Present (It.Typ) loop\n-            if Covers (T, It.Typ) or else Covers (It.Typ, T) then\n-\n-               --  If several interpretations are possible and L is universal,\n-               --  apply preference rule.\n-\n-               if TR /= Any_Type then\n-                  if Is_Universal_Numeric_Type (T)\n-                    and then It.Typ = T\n-                  then\n-                     TR := It.Typ;\n-                  end if;\n-\n-               else\n-                  TR := It.Typ;\n-               end if;\n-            end if;\n-\n-            Get_Next_Interp (I, It);\n-         end loop;\n-\n-         Set_Etype (R, TR);\n-\n-      --  In the non-overloaded case, the Etype of R is already set correctly\n-\n-      else\n-         null;\n+      if T = Any_Type then\n+         if Is_User_Defined_Literal (L, Etype (R)) then\n+            return Etype (R);\n+         elsif Is_User_Defined_Literal (R, Etype (L)) then\n+            return Etype (L);\n+         end if;\n       end if;\n \n-      --  If one of the operands is Universal_Fixed, the type of the other\n-      --  operand provides the context.\n-\n-      if Etype (R) = Universal_Fixed then\n-         return T;\n-\n-      elsif T = Universal_Fixed then\n-         return Etype (R);\n-\n-      --  If one operand is a raise_expression, use type of other operand\n-\n-      elsif Nkind (L) = N_Raise_Expression then\n-         return Etype (R);\n-\n-      else\n-         return Specific_Type (T, Etype (R));\n-      end if;\n+      return T;\n    end Find_Unique_Type;\n \n    -------------------------------------\n@@ -2446,10 +2397,7 @@ package body Sem_Type is\n    -- Has_Compatible_Type --\n    -------------------------\n \n-   function Has_Compatible_Type\n-     (N              : Node_Id;\n-      Typ            : Entity_Id;\n-      For_Comparison : Boolean := False) return Boolean\n+   function Has_Compatible_Type (N : Node_Id; Typ : Entity_Id) return Boolean\n    is\n       I  : Interp_Index;\n       It : Interp;\n@@ -2463,8 +2411,8 @@ package body Sem_Type is\n          if Covers (Typ, Etype (N))\n \n             --  Ada 2005 (AI-345): The context may be a synchronized interface.\n-            --  If the type is already frozen use the corresponding_record\n-            --  to check whether it is a proper descendant.\n+            --  If the type is already frozen, use the corresponding_record to\n+            --  check whether it is a proper descendant.\n \n            or else\n              (Is_Record_Type (Typ)\n@@ -2478,23 +2426,8 @@ package body Sem_Type is\n                and then Present (Corresponding_Record_Type (Typ))\n                and then Covers (Corresponding_Record_Type (Typ), Etype (N)))\n \n-           or else\n-             (Nkind (N) = N_Integer_Literal\n-               and then Present (Find_Aspect (Typ, Aspect_Integer_Literal)))\n+           or else Is_User_Defined_Literal (N, Typ)\n \n-           or else\n-             (Nkind (N) = N_Real_Literal\n-               and then Present (Find_Aspect (Typ, Aspect_Real_Literal)))\n-\n-           or else\n-             (Nkind (N) = N_String_Literal\n-               and then Present (Find_Aspect (Typ, Aspect_String_Literal)))\n-\n-           or else\n-             (For_Comparison\n-               and then not Is_Tagged_Type (Typ)\n-               and then Ekind (Typ) /= E_Anonymous_Access_Type\n-               and then Covers (Etype (N), Typ))\n          then\n             return True;\n          end if;\n@@ -2504,26 +2437,24 @@ package body Sem_Type is\n       else\n          Get_First_Interp (N, I, It);\n          while Present (It.Typ) loop\n-            if (Covers (Typ, It.Typ)\n-                 and then\n-                   (Scope (It.Nam) /= Standard_Standard\n-                     or else not Is_Invisible_Operator (N, Base_Type (Typ))))\n+            if Covers (Typ, It.Typ)\n \n                --  Ada 2005 (AI-345)\n \n               or else\n                 (Is_Record_Type (Typ)\n                   and then Is_Concurrent_Type (It.Typ)\n-                  and then Present (Corresponding_Record_Type\n-                                                             (Etype (It.Typ)))\n-                  and then Covers (Typ, Corresponding_Record_Type\n-                                                             (Etype (It.Typ))))\n-\n-             or else\n-               (For_Comparison\n-                 and then not Is_Tagged_Type (Typ)\n-                 and then Ekind (Typ) /= E_Anonymous_Access_Type\n-                 and then Covers (It.Typ, Typ))\n+                  and then Present (Corresponding_Record_Type (Etype (It.Typ)))\n+                  and then\n+                    Covers (Typ, Corresponding_Record_Type (Etype (It.Typ))))\n+\n+              or else\n+                (Is_Concurrent_Type (Typ)\n+                  and then Is_Record_Type (It.Typ)\n+                  and then Present (Corresponding_Record_Type (Typ))\n+                  and then\n+                    Covers (Corresponding_Record_Type (Typ), Etype (It.Typ)))\n+\n             then\n                return True;\n             end if;\n@@ -3010,45 +2941,6 @@ package body Sem_Type is\n       end if;\n    end Is_Ancestor;\n \n-   ---------------------------\n-   -- Is_Invisible_Operator --\n-   ---------------------------\n-\n-   function Is_Invisible_Operator\n-     (N : Node_Id;\n-      T : Entity_Id) return Boolean\n-   is\n-      Orig_Node : constant Node_Id := Original_Node (N);\n-\n-   begin\n-      if Nkind (N) not in N_Op then\n-         return False;\n-\n-      elsif not Comes_From_Source (N) then\n-         return False;\n-\n-      elsif No (Universal_Interpretation (Right_Opnd (N))) then\n-         return False;\n-\n-      elsif Nkind (N) in N_Binary_Op\n-        and then No (Universal_Interpretation (Left_Opnd (N)))\n-      then\n-         return False;\n-\n-      else\n-         return Is_Numeric_Type (T)\n-           and then not In_Open_Scopes (Scope (T))\n-           and then not Is_Potentially_Use_Visible (T)\n-           and then not In_Use (T)\n-           and then not In_Use (Scope (T))\n-           and then\n-            (Nkind (Orig_Node) /= N_Function_Call\n-              or else Nkind (Name (Orig_Node)) /= N_Expanded_Name\n-              or else Entity (Prefix (Name (Orig_Node))) /= Scope (T))\n-           and then not In_Instance;\n-      end if;\n-   end Is_Invisible_Operator;\n-\n    --------------------\n    --  Is_Progenitor --\n    --------------------\n@@ -3081,6 +2973,65 @@ package body Sem_Type is\n       return False;\n    end Is_Subtype_Of;\n \n+   -------------------------\n+   -- Is_Visible_Operator --\n+   -------------------------\n+\n+   function Is_Visible_Operator (N : Node_Id; Typ : Entity_Id) return Boolean\n+   is\n+   begin\n+      --  The predefined operators of the universal types are always visible\n+\n+      if Typ in Universal_Integer | Universal_Real | Universal_Access then\n+         return True;\n+\n+      --  AI95-0230: Keep restriction imposed by Ada 83 and 95, do not allow\n+      --  anonymous access types in universal_access equality operators.\n+\n+      elsif Is_Anonymous_Access_Type (Typ) then\n+         return Ada_Version >= Ada_2005;\n+\n+      --  Similar reasoning for special types used for composite types before\n+      --  type resolution is done.\n+\n+      elsif Typ = Any_Composite or else Typ = Any_String then\n+         return True;\n+\n+      --  Within an instance, the predefined operators of the formal types are\n+      --  visible and, for the other types, the generic package declaration has\n+      --  already been successfully analyzed. Likewise for an inlined body.\n+\n+      elsif In_Instance or else In_Inlined_Body then\n+         return True;\n+\n+     --  If the operation is given in functional notation and the prefix is an\n+     --  expanded name, then the operator is visible if the prefix is the scope\n+     --  of the type, or System if the type is declared in an extension of it.\n+\n+      elsif Nkind (N) = N_Function_Call\n+        and then Nkind (Name (N)) = N_Expanded_Name\n+      then\n+         declare\n+            Pref : constant Entity_Id := Entity (Prefix (Name (N)));\n+            Scop : constant Entity_Id := Scope (Typ);\n+\n+         begin\n+            return Pref = Scop\n+              or else (Present (System_Aux_Id)\n+                        and then Scop = System_Aux_Id\n+                        and then Pref = Scope (Scop));\n+         end;\n+\n+      --  Otherwise the operator is visible when the type is visible\n+\n+      else\n+         return Is_Potentially_Use_Visible (Typ)\n+           or else In_Use (Typ)\n+           or else (In_Use (Scope (Typ)) and then not Is_Hidden (Typ))\n+           or else In_Open_Scopes (Scope (Typ));\n+      end if;\n+   end Is_Visible_Operator;\n+\n    ------------------\n    -- List_Interps --\n    ------------------\n@@ -3184,7 +3135,7 @@ package body Sem_Type is\n \n          elsif Op_Name in Name_Op_Eq | Name_Op_Ne then\n             return Base_Type (T1) = Base_Type (T2)\n-              and then not Is_Limited_Type (T1)\n+              and then Valid_Equality_Arg (T1)\n               and then Is_Boolean_Type (T);\n \n          elsif Op_Name in Name_Op_Lt | Name_Op_Le | Name_Op_Gt | Name_Op_Ge\n@@ -3366,60 +3317,41 @@ package body Sem_Type is\n         or else (T1 = Universal_Real    and then Is_Real_Type (T2))\n         or else (T1 = Universal_Fixed   and then Is_Fixed_Point_Type (T2))\n         or else (T1 = Any_Fixed         and then Is_Fixed_Point_Type (T2))\n+        or else (T1 = Any_Modular       and then Is_Modular_Integer_Type (T2))\n+        or else (T1 = Any_Character     and then Is_Character_Type (T2))\n+        or else (T1 = Any_String        and then Is_String_Type (T2))\n+        or else (T1 = Any_Composite     and then Is_Aggregate_Type (T2))\n       then\n          return B2;\n \n-      elsif     (T2 = Universal_Integer and then Is_Integer_Type (T1))\n-        or else (T2 = Universal_Real    and then Is_Real_Type (T1))\n-        or else (T2 = Universal_Fixed   and then Is_Fixed_Point_Type (T1))\n-        or else (T2 = Any_Fixed         and then Is_Fixed_Point_Type (T1))\n+      elsif (T1 = Universal_Access\n+              or else Ekind (T1) in E_Allocator_Type | E_Access_Attribute_Type)\n+        and then (Is_Access_Type (T2) or else Is_Remote_Access (T2))\n       then\n-         return B1;\n-\n-      elsif T2 = Any_String and then Is_String_Type (T1) then\n-         return B1;\n-\n-      elsif T1 = Any_String and then Is_String_Type (T2) then\n          return B2;\n \n-      elsif T2 = Any_Character and then Is_Character_Type (T1) then\n-         return B1;\n-\n-      elsif T1 = Any_Character and then Is_Character_Type (T2) then\n+      elsif T1 = Raise_Type then\n          return B2;\n \n-      elsif T1 = Universal_Access\n-        and then (Is_Access_Type (T2) or else Is_Remote_Access (T2))\n+      elsif     (T2 = Universal_Integer and then Is_Integer_Type (T1))\n+        or else (T2 = Universal_Real    and then Is_Real_Type (T1))\n+        or else (T2 = Universal_Fixed   and then Is_Fixed_Point_Type (T1))\n+        or else (T2 = Any_Fixed         and then Is_Fixed_Point_Type (T1))\n+        or else (T2 = Any_Modular       and then Is_Modular_Integer_Type (T1))\n+        or else (T2 = Any_Character     and then Is_Character_Type (T1))\n+        or else (T2 = Any_String        and then Is_String_Type (T1))\n+        or else (T2 = Any_Composite     and then Is_Aggregate_Type (T1))\n       then\n-         return T2;\n+         return B1;\n \n-      elsif T2 = Universal_Access\n+      elsif (T2 = Universal_Access\n+              or else Ekind (T2) in E_Allocator_Type | E_Access_Attribute_Type)\n         and then (Is_Access_Type (T1) or else Is_Remote_Access (T1))\n       then\n-         return T1;\n-\n-      --  In an instance, the specific type may have a private view. Use full\n-      --  view to check legality.\n-\n-      elsif T2 = Universal_Access\n-        and then Is_Private_Type (T1)\n-        and then Present (Full_View (T1))\n-        and then Is_Access_Type (Full_View (T1))\n-        and then In_Instance\n-      then\n-         return T1;\n-\n-      elsif T2 = Any_Composite and then Is_Aggregate_Type (T1) then\n-         return T1;\n-\n-      elsif T1 = Any_Composite and then Is_Aggregate_Type (T2) then\n-         return T2;\n-\n-      elsif T1 = Any_Modular and then Is_Modular_Integer_Type (T2) then\n-         return T2;\n+         return B1;\n \n-      elsif T2 = Any_Modular and then Is_Modular_Integer_Type (T1) then\n-         return T1;\n+      elsif T2 = Raise_Type then\n+         return B1;\n \n       --  ----------------------------------------------------------\n       --  Special cases for equality operators (all other predefined\n@@ -3488,16 +3420,6 @@ package body Sem_Type is\n       then\n          return T1;\n \n-      elsif Ekind (T1) in E_Allocator_Type | E_Access_Attribute_Type\n-        and then Is_Access_Type (T2)\n-      then\n-         return T2;\n-\n-      elsif Ekind (T2) in E_Allocator_Type | E_Access_Attribute_Type\n-        and then Is_Access_Type (T1)\n-      then\n-         return T1;\n-\n       --  Ada 2005 (AI-230): Support the following operators:\n \n       --    function \"=\"  (L, R : universal_access) return Boolean;\n@@ -3513,16 +3435,34 @@ package body Sem_Type is\n       --  Note that this does not preclude one operand to be a pool-specific\n       --  access type, as a previous version of this code enforced.\n \n-      elsif Ada_Version >= Ada_2005 then\n-         if Is_Anonymous_Access_Type (T1)\n-           and then Is_Access_Type (T2)\n-         then\n-            return T1;\n+      elsif Is_Anonymous_Access_Type (T1)\n+        and then Is_Access_Type (T2)\n+        and then Ada_Version >= Ada_2005\n+      then\n+         return T1;\n \n-         elsif Is_Anonymous_Access_Type (T2)\n-           and then Is_Access_Type (T1)\n-         then\n-            return T2;\n+      elsif Is_Anonymous_Access_Type (T2)\n+        and then Is_Access_Type (T1)\n+        and then Ada_Version >= Ada_2005\n+      then\n+         return T2;\n+\n+      --  In instances, also check private views the same way as Covers\n+\n+      elsif Is_Private_Type (T1) and then In_Instance then\n+         if Present (Full_View (T1)) then\n+            return Specific_Type (Full_View (T1), T2);\n+\n+         elsif Present (Underlying_Full_View (T1)) then\n+            return Specific_Type (Underlying_Full_View (T1), T2);\n+         end if;\n+\n+      elsif Is_Private_Type (T2) and then In_Instance then\n+         if Present (Full_View (T2)) then\n+            return Specific_Type (T1, Full_View (T2));\n+\n+         elsif Present (Underlying_Full_View (T2)) then\n+            return Specific_Type (T1, Underlying_Full_View (T2));\n          end if;\n       end if;\n \n@@ -3580,15 +3520,14 @@ package body Sem_Type is\n    -- Valid_Comparison_Arg --\n    --------------------------\n \n+   --  See above for the reason why aggregates and strings are included\n+\n    function Valid_Comparison_Arg (T : Entity_Id) return Boolean is\n    begin\n+      if Is_Discrete_Type (T) or else Is_Real_Type (T) then\n+         return True;\n \n-      if T = Any_Composite then\n-         return False;\n-\n-      elsif Is_Discrete_Type (T)\n-        or else Is_Real_Type (T)\n-      then\n+      elsif T = Any_Composite or else T = Any_String then\n          return True;\n \n       elsif Is_Array_Type (T)\n@@ -3608,11 +3547,40 @@ package body Sem_Type is\n \n       elsif Is_String_Type (T) then\n          return True;\n+\n       else\n          return False;\n       end if;\n    end Valid_Comparison_Arg;\n \n+   ------------------------\n+   -- Valid_Equality_Arg --\n+   ------------------------\n+\n+   --  Same reasoning as above but implicit because of the nonlimited test\n+\n+   function Valid_Equality_Arg (T : Entity_Id) return Boolean is\n+   begin\n+      --  AI95-0230: Keep restriction imposed by Ada 83 and 95, do not allow\n+      --  anonymous access types in universal_access equality operators.\n+\n+      if Is_Anonymous_Access_Type (T) then\n+         return Ada_Version >= Ada_2005;\n+\n+      elsif not Is_Limited_Type (T) then\n+         return True;\n+\n+      elsif Is_Array_Type (T)\n+        and then not Is_Limited_Type (Component_Type (T))\n+        and then Available_Full_View_Of_Component (T)\n+      then\n+         return True;\n+\n+      else\n+         return False;\n+      end if;\n+   end Valid_Equality_Arg;\n+\n    ------------------\n    -- Write_Interp --\n    ------------------"}, {"sha": "a6111b1d0e27d3d553dfcf19d004a69028b23d95", "filename": "gcc/ada/sem_type.ads", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_type.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_type.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.ads?ref=eb05097d5508618a70b279df6d10d409eb4c60ae", "patch": "@@ -103,9 +103,12 @@ package Sem_Type is\n    --  in N. If the name is an expanded name, the homonyms are only those that\n    --  belong to the same scope.\n \n-   function Is_Invisible_Operator (N : Node_Id; T : Entity_Id) return Boolean;\n-   --  Check whether a predefined operation with universal operands appears in\n-   --  a context in which the operators of the expected type are not visible.\n+   function Is_Visible_Operator (N : Node_Id; Typ : Entity_Id) return Boolean;\n+   --  Determine whether a predefined operation is performed in a context where\n+   --  the predefined operators of base type Typ are visible. The existence of\n+   --  this routine is an implementation artifact. A more straightforward but\n+   --  more space-consuming choice would be to make all inherited operators\n+   --  explicit in the symbol table. See also Sem_ch8.Has_Implicit_Operator.\n \n    procedure List_Interps (Nam : Node_Id; Err : Node_Id);\n    --  List candidate interpretations of an overloaded name. Used for various\n@@ -181,22 +184,15 @@ package Sem_Type is\n    --  opposed to an operator, type and mode conformance are required.\n \n    function Find_Unique_Type (L : Node_Id; R : Node_Id) return Entity_Id;\n-   --  Used in second pass of resolution, for equality and comparison nodes. L\n-   --  is the left operand, whose type is known to be correct, and R is the\n-   --  right operand, which has one interpretation compatible with that of L.\n-   --  Return the type intersection of the two.\n-\n-   function Has_Compatible_Type\n-     (N              : Node_Id;\n-      Typ            : Entity_Id;\n-      For_Comparison : Boolean := False) return Boolean;\n+   --  Used in type resolution for equality and comparison nodes. L and R are\n+   --  the operands, whose type is known to be correct or Any_Type in case of\n+   --  ambiguity. Return the type intersection of the two.\n+\n+   function Has_Compatible_Type (N : Node_Id; Typ : Entity_Id) return Boolean;\n    --  Verify that some interpretation of the node N has a type compatible with\n    --  Typ. If N is not overloaded, then its unique type must be compatible\n    --  with Typ. Otherwise iterate through the interpretations of N looking for\n-   --  a compatible one. If For_Comparison is true, the function is invoked for\n-   --  a comparison (or equality) operator and also needs to verify the reverse\n-   --  compatibility, because the implementation of type resolution for these\n-   --  operators is not fully symmetrical.\n+   --  a compatible one.\n \n    function Hides_Op (F : Entity_Id; Op : Entity_Id) return Boolean;\n    --  A user-defined function hides a predefined operator if it matches the\n@@ -259,13 +255,22 @@ package Sem_Type is\n    procedure Set_Abstract_Op (I : Interp_Index; V : Entity_Id);\n    --  Set the abstract operation field of an interpretation\n \n-   function Valid_Comparison_Arg (T : Entity_Id) return Boolean;\n-   --  A valid argument to an ordering operator must be a discrete type, a\n-   --  real type, or a one dimensional array with a discrete component type.\n+   function Specific_Type (Typ_1, Typ_2 : Entity_Id) return Entity_Id;\n+   --  If Typ_1 and Typ_2 are compatible, return the one that is not universal\n+   --  or is not a \"class\" type (any_character, etc).\n \n    function Valid_Boolean_Arg (T : Entity_Id) return Boolean;\n-   --  A valid argument of a boolean operator is either some boolean type, or a\n-   --  one-dimensional array of boolean type.\n+   --  A valid argument of a predefined boolean operator must be a boolean type\n+   --  or a 1-dimensional array of boolean type.\n+\n+   function Valid_Comparison_Arg (T : Entity_Id) return Boolean;\n+   --  A valid argument of a predefined comparison operator must be a discrete\n+   --  type, real type or a 1-dimensional array with a discrete component type.\n+\n+   function Valid_Equality_Arg (T : Entity_Id) return Boolean;\n+   --  A valid argument of a predefined equality operator must be a nonlimited\n+   --  type or an array with a limited private component whose full view is not\n+   --  limited.\n \n    procedure Write_Interp (It : Interp);\n    --  Debugging procedure to display an Interp"}, {"sha": "7f56ab496ed38d485fe0fe2c9cae467b57913584", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=eb05097d5508618a70b279df6d10d409eb4c60ae", "patch": "@@ -21478,6 +21478,25 @@ package body Sem_Util is\n         and then Nkind (Parent (Id)) = N_Function_Specification;\n    end Is_User_Defined_Equality;\n \n+   -----------------------------\n+   -- Is_User_Defined_Literal --\n+   -----------------------------\n+\n+   function Is_User_Defined_Literal\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Boolean\n+   is\n+      Literal_Aspect_Map :\n+        constant array (N_Numeric_Or_String_Literal) of Aspect_Id :=\n+          (N_Integer_Literal => Aspect_Integer_Literal,\n+           N_Real_Literal    => Aspect_Real_Literal,\n+           N_String_Literal  => Aspect_String_Literal);\n+\n+   begin\n+      return Nkind (N) in N_Numeric_Or_String_Literal\n+        and then Present (Find_Aspect (Typ, Literal_Aspect_Map (Nkind (N))));\n+   end Is_User_Defined_Literal;\n+\n    --------------------------------------\n    -- Is_Validation_Variable_Reference --\n    --------------------------------------"}, {"sha": "e5dee96b7f46a19da1b33ed2ca5c217aec5fa90c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb05097d5508618a70b279df6d10d409eb4c60ae/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=eb05097d5508618a70b279df6d10d409eb4c60ae", "patch": "@@ -2468,6 +2468,12 @@ package Sem_Util is\n    function Is_User_Defined_Equality (Id : Entity_Id) return Boolean;\n    --  Determine whether an entity denotes a user-defined equality\n \n+   function Is_User_Defined_Literal\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Boolean;\n+   pragma Inline (Is_User_Defined_Literal);\n+   --  Determine whether N is a user-defined literal for Typ\n+\n    function Is_Validation_Variable_Reference (N : Node_Id) return Boolean;\n    --  Determine whether N denotes a reference to a variable which captures the\n    --  value of an object for validation purposes."}]}