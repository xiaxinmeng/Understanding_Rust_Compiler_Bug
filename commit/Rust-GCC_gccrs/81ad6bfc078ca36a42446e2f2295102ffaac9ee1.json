{"sha": "81ad6bfc078ca36a42446e2f2295102ffaac9ee1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFhZDZiZmMwNzhjYTM2YTQyNDQ2ZTJmMjI5NTEwMmZmYWFjOWVlMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:37Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:37Z"}, "message": "vect: Remove new_phis from vect_create_epilog_for_reduction\n\nvect_create_epilog_for_reduction had a variable called new_phis.\nIt collected the statements that produce the exit block definitions\nof the vector reduction accumulators.  Although those statements\nare indeed phis initially, they are often replaced with normal\nstatements later, leading to puzzling code like:\n\n          FOR_EACH_VEC_ELT (new_phis, i, new_phi)\n            {\n              int bit_offset;\n              if (gimple_code (new_phi) == GIMPLE_PHI)\n                vec_temp = PHI_RESULT (new_phi);\n              else\n                vec_temp = gimple_assign_lhs (new_phi);\n\nAlso, although the array collects statements, in practice all users want\nthe lhs instead.\n\nThis patch therefore replaces new_phis with a vector of gimple values\ncalled \u201creduc_inputs\u201d.\n\nAlso, reduction chains and ncopies>1 were handled with identical code\n(and there was a comment saying so).  The patch unites them into\na single \u201cif\u201d.\n\ngcc/\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Replace\n\tthe new_phis vector with a reduc_inputs vector.  Combine handling\n\tof reduction chains and ncopies > 1.", "tree": {"sha": "ae8e8304dd2065c4e90e6fe822762f6303e50bad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae8e8304dd2065c4e90e6fe822762f6303e50bad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81ad6bfc078ca36a42446e2f2295102ffaac9ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ad6bfc078ca36a42446e2f2295102ffaac9ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81ad6bfc078ca36a42446e2f2295102ffaac9ee1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ad6bfc078ca36a42446e2f2295102ffaac9ee1/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b68eb70bd6df8c4b846bddb4f0aeae9054b932bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b68eb70bd6df8c4b846bddb4f0aeae9054b932bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b68eb70bd6df8c4b846bddb4f0aeae9054b932bc"}], "stats": {"total": 113, "additions": 41, "deletions": 72}, "files": [{"sha": "b7f73ca52c75dd35666ab3c91c5d51f73a193788", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 41, "deletions": 72, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ad6bfc078ca36a42446e2f2295102ffaac9ee1/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ad6bfc078ca36a42446e2f2295102ffaac9ee1/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=81ad6bfc078ca36a42446e2f2295102ffaac9ee1", "patch": "@@ -5005,7 +5005,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n   imm_use_iterator imm_iter, phi_imm_iter;\n   use_operand_p use_p, phi_use_p;\n   gimple *use_stmt;\n-  auto_vec<gimple *> new_phis;\n+  auto_vec<tree> reduc_inputs;\n   int j, i;\n   auto_vec<tree> scalar_results;\n   unsigned int group_size = 1, k;\n@@ -5017,7 +5017,6 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n      b2 = operation (b1)  */\n   bool slp_reduc = (slp_node && !REDUC_GROUP_FIRST_ELEMENT (stmt_info));\n   bool direct_slp_reduc;\n-  tree new_phi_result;\n   tree induction_index = NULL_TREE;\n \n   if (slp_node)\n@@ -5215,27 +5214,22 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n   if (double_reduc)\n     loop = outer_loop;\n   exit_bb = single_exit (loop)->dest;\n-  new_phis.create (slp_node ? vec_num : ncopies);\n+  reduc_inputs.create (slp_node ? vec_num : ncopies);\n   for (unsigned i = 0; i < vec_num; i++)\n     {\n       if (slp_node)\n \tdef = vect_get_slp_vect_def (slp_node, i);\n       else\n \tdef = gimple_get_lhs (STMT_VINFO_VEC_STMTS (rdef_info)[0]);\n       for (j = 0; j < ncopies; j++)\n-        {\n+\t{\n \t  tree new_def = copy_ssa_name (def);\n-          phi = create_phi_node (new_def, exit_bb);\n-          if (j == 0)\n-            new_phis.quick_push (phi);\n-          else\n-\t    {\n-\t      def = gimple_get_lhs (STMT_VINFO_VEC_STMTS (rdef_info)[j]);\n-\t      new_phis.quick_push (phi);\n-\t    }\n-\n-          SET_PHI_ARG_DEF (phi, single_exit (loop)->dest_idx, def);\n-        }\n+\t  phi = create_phi_node (new_def, exit_bb);\n+\t  if (j)\n+\t    def = gimple_get_lhs (STMT_VINFO_VEC_STMTS (rdef_info)[j]);\n+\t  SET_PHI_ARG_DEF (phi, single_exit (loop)->dest_idx, def);\n+\t  reduc_inputs.quick_push (new_def);\n+\t}\n     }\n \n   exit_gsi = gsi_after_labels (exit_bb);\n@@ -5274,52 +5268,32 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n      a2 = operation (a1)\n      a3 = operation (a2),\n \n-     we may end up with more than one vector result.  Here we reduce them to\n-     one vector.  */\n-  if (REDUC_GROUP_FIRST_ELEMENT (stmt_info) || direct_slp_reduc)\n+     we may end up with more than one vector result.  Here we reduce them\n+     to one vector.\n+\n+     The same is true if we couldn't use a single defuse cycle.  */\n+  if (REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n+      || direct_slp_reduc\n+      || ncopies > 1)\n     {\n       gimple_seq stmts = NULL;\n-      tree first_vect = PHI_RESULT (new_phis[0]);\n-      first_vect = gimple_convert (&stmts, vectype, first_vect);\n-      for (k = 1; k < new_phis.length (); k++)\n+      tree first_vect = gimple_convert (&stmts, vectype, reduc_inputs[0]);\n+      for (k = 1; k < reduc_inputs.length (); k++)\n         {\n-\t  gimple *next_phi = new_phis[k];\n-          tree second_vect = PHI_RESULT (next_phi);\n-\t  second_vect = gimple_convert (&stmts, vectype, second_vect);\n+\t  tree second_vect = gimple_convert (&stmts, vectype, reduc_inputs[k]);\n           first_vect = gimple_build (&stmts, code, vectype,\n \t\t\t\t     first_vect, second_vect);\n         }\n       gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n \n-      new_phi_result = first_vect;\n-      new_phis.truncate (0);\n-      new_phis.safe_push (SSA_NAME_DEF_STMT (first_vect));\n+      reduc_inputs.truncate (0);\n+      reduc_inputs.safe_push (first_vect);\n     }\n-  /* Likewise if we couldn't use a single defuse cycle.  */\n-  else if (ncopies > 1)\n-    {\n-      gimple_seq stmts = NULL;\n-      tree first_vect = PHI_RESULT (new_phis[0]);\n-      first_vect = gimple_convert (&stmts, vectype, first_vect);\n-      for (int k = 1; k < ncopies; ++k)\n-\t{\n-\t  tree second_vect = PHI_RESULT (new_phis[k]);\n-\t  second_vect = gimple_convert (&stmts, vectype, second_vect);\n-\t  first_vect = gimple_build (&stmts, code, vectype,\n-\t\t\t\t     first_vect, second_vect);\n-\t}\n-      gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n-      new_phi_result = first_vect;\n-      new_phis.truncate (0);\n-      new_phis.safe_push (SSA_NAME_DEF_STMT (first_vect));\n-    }\n-  else\n-    new_phi_result = PHI_RESULT (new_phis[0]);\n \n   if (STMT_VINFO_REDUC_TYPE (reduc_info) == COND_REDUCTION\n       && reduc_fn != IFN_LAST)\n     {\n-      /* For condition reductions, we have a vector (NEW_PHI_RESULT) containing\n+      /* For condition reductions, we have a vector (REDUC_INPUTS 0) containing\n \t various data values where the condition matched and another vector\n \t (INDUCTION_INDEX) containing all the indexes of those matches.  We\n \t need to extract the last matching index (which will be the index with\n@@ -5350,7 +5324,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       tree zero_vec = build_zero_cst (vectype);\n \n       gimple_seq stmts = NULL;\n-      new_phi_result = gimple_convert (&stmts, vectype, new_phi_result);\n+      reduc_inputs[0] = gimple_convert (&stmts, vectype, reduc_inputs[0]);\n       gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n \n       /* Find maximum value from the vector of found indexes.  */\n@@ -5370,7 +5344,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \n       /* Next we compare the new vector (MAX_INDEX_VEC) full of max indexes\n \t with the vector (INDUCTION_INDEX) of found indexes, choosing values\n-\t from the data vector (NEW_PHI_RESULT) for matches, 0 (ZERO_VEC)\n+\t from the data vector (REDUC_INPUTS 0) for matches, 0 (ZERO_VEC)\n \t otherwise.  Only one value should match, resulting in a vector\n \t (VEC_COND) with one data value and the rest zeros.\n \t In the case where the loop never made any matches, every index will\n@@ -5389,7 +5363,8 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t zero.  */\n       tree vec_cond = make_ssa_name (vectype);\n       gimple *vec_cond_stmt = gimple_build_assign (vec_cond, VEC_COND_EXPR,\n-\t\t\t\t\t\t   vec_compare, new_phi_result,\n+\t\t\t\t\t\t   vec_compare,\n+\t\t\t\t\t\t   reduc_inputs[0],\n \t\t\t\t\t\t   zero_vec);\n       gsi_insert_before (&exit_gsi, vec_cond_stmt, GSI_SAME_STMT);\n \n@@ -5437,7 +5412,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t     val = data_reduc[i], idx_val = induction_index[i];\n \t return val;  */\n \n-      tree data_eltype = TREE_TYPE (TREE_TYPE (new_phi_result));\n+      tree data_eltype = TREE_TYPE (TREE_TYPE (reduc_inputs[0]));\n       tree idx_eltype = TREE_TYPE (TREE_TYPE (induction_index));\n       unsigned HOST_WIDE_INT el_size = tree_to_uhwi (TYPE_SIZE (idx_eltype));\n       poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (TREE_TYPE (induction_index));\n@@ -5461,7 +5436,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t  epilog_stmt = gimple_build_assign (val, BIT_FIELD_REF,\n \t\t\t\t\t     build3 (BIT_FIELD_REF,\n \t\t\t\t\t\t     data_eltype,\n-\t\t\t\t\t\t     new_phi_result,\n+\t\t\t\t\t\t     reduc_inputs[0],\n \t\t\t\t\t\t     bitsize_int (el_size),\n \t\t\t\t\t\t     bitsize_int (off)));\n \t  gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n@@ -5513,10 +5488,10 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t\t\t \"Reduce using direct vector reduction.\\n\");\n \n       gimple_seq stmts = NULL;\n-      new_phi_result = gimple_convert (&stmts, vectype, new_phi_result);\n-      vec_elem_type = TREE_TYPE (TREE_TYPE (new_phi_result));\n+      reduc_inputs[0] = gimple_convert (&stmts, vectype, reduc_inputs[0]);\n+      vec_elem_type = TREE_TYPE (TREE_TYPE (reduc_inputs[0]));\n       new_temp = gimple_build (&stmts, as_combined_fn (reduc_fn),\n-\t\t\t       vec_elem_type, new_phi_result);\n+\t\t\t       vec_elem_type, reduc_inputs[0]);\n       new_temp = gimple_convert (&stmts, scalar_type, new_temp);\n       gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n \n@@ -5546,7 +5521,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t neutral value.  We can then do a normal reduction on each vector.  */\n \n       /* Enforced by vectorizable_reduction.  */\n-      gcc_assert (new_phis.length () == 1);\n+      gcc_assert (reduc_inputs.length () == 1);\n       gcc_assert (pow2p_hwi (group_size));\n \n       slp_tree orig_phis_slp_node = slp_node_instance->reduc_phis;\n@@ -5602,7 +5577,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \n \t     sel[j] = (index[j] == i);\n \n-\t     which selects the elements of NEW_PHI_RESULT that should\n+\t     which selects the elements of REDUC_INPUTS[0] that should\n \t     be included in the result.  */\n \t  tree compare_val = build_int_cst (index_elt_type, i);\n \t  compare_val = build_vector_from_val (index_type, compare_val);\n@@ -5611,11 +5586,11 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \n \t  /* Calculate the equivalent of:\n \n-\t     vec = seq ? new_phi_result : vector_identity;\n+\t     vec = seq ? reduc_inputs[0] : vector_identity;\n \n \t     VEC is now suitable for a full vector reduction.  */\n \t  tree vec = gimple_build (&seq, VEC_COND_EXPR, vectype,\n-\t\t\t\t   sel, new_phi_result, vector_identity);\n+\t\t\t\t   sel, reduc_inputs[0], vector_identity);\n \n \t  /* Do the reduction and convert it to the appropriate type.  */\n \t  tree scalar = gimple_build (&seq, as_combined_fn (reduc_fn),\n@@ -5630,7 +5605,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       bool reduce_with_shift;\n       tree vec_temp;\n \n-      gcc_assert (slp_reduc || new_phis.length () == 1);\n+      gcc_assert (slp_reduc || reduc_inputs.length () == 1);\n \n       /* See if the target wants to do the final (shift) reduction\n \t in a vector mode of smaller size and first reduce upper/lower\n@@ -5640,7 +5615,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       unsigned nunits = TYPE_VECTOR_SUBPARTS (vectype).to_constant ();\n       unsigned nunits1 = nunits;\n       if ((mode1 = targetm.vectorize.split_reduction (mode)) != mode\n-\t  && new_phis.length () == 1)\n+\t  && reduc_inputs.length () == 1)\n \t{\n \t  nunits1 = GET_MODE_NUNITS (mode1).to_constant ();\n \t  /* For SLP reductions we have to make sure lanes match up, but\n@@ -5672,7 +5647,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \n       /* First reduce the vector to the desired vector size we should\n \t do shift reduction on by combining upper and lower halves.  */\n-      new_temp = new_phi_result;\n+      new_temp = reduc_inputs[0];\n       while (nunits > nunits1)\n \t{\n \t  nunits /= 2;\n@@ -5751,7 +5726,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t  new_temp = make_ssa_name (vectype1);\n \t  epilog_stmt = gimple_build_assign (new_temp, code, dst1, dst2);\n \t  gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-\t  new_phis[0] = epilog_stmt;\n+\t  reduc_inputs[0] = new_temp;\n \t}\n \n       if (reduce_with_shift && !slp_reduc)\n@@ -5832,13 +5807,9 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t  int element_bitsize = tree_to_uhwi (bitsize);\n \t  tree compute_type = TREE_TYPE (vectype);\n \t  gimple_seq stmts = NULL;\n-          FOR_EACH_VEC_ELT (new_phis, i, new_phi)\n+\t  FOR_EACH_VEC_ELT (reduc_inputs, i, vec_temp)\n             {\n               int bit_offset;\n-              if (gimple_code (new_phi) == GIMPLE_PHI)\n-                vec_temp = PHI_RESULT (new_phi);\n-              else\n-                vec_temp = gimple_assign_lhs (new_phi);\n \t      new_temp = gimple_build (&stmts, BIT_FIELD_REF, compute_type,\n \t\t\t\t       vec_temp, bitsize, bitsize_zero_node);\n \n@@ -5929,11 +5900,10 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       gimple_seq stmts = NULL;\n       if (double_reduc)\n \t{\n-          new_phi = new_phis[0];\n \t  gcc_assert (VECTOR_TYPE_P (TREE_TYPE (adjustment_def)));\n \t  adjustment_def = gimple_convert (&stmts, vectype, adjustment_def);\n \t  new_temp = gimple_build (&stmts, code, vectype,\n-\t\t\t\t   PHI_RESULT (new_phi), adjustment_def);\n+\t\t\t\t   reduc_inputs[0], adjustment_def);\n \t}\n       else\n \t{\n@@ -5947,7 +5917,6 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       epilog_stmt = gimple_seq_last_stmt (stmts);\n       gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n       scalar_results[0] = new_temp;\n-      new_phis[0] = epilog_stmt;\n     }\n \n   if (double_reduc)"}]}