{"sha": "809192e77e6e112a0fe32dee7fada7a49fbf25cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA5MTkyZTc3ZTZlMTEyYTBmZTMyZGVlN2ZhZGE3YTQ5ZmJmMjVjZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-18T17:59:21Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-22T18:47:03Z"}, "message": "analyzer: add -fdump-analyzer-json\n\nI've found this useful for debugging state explosions in the analyzer.\n\ngcc/analyzer/ChangeLog:\n\t* analysis-plan.cc: Include \"json.h\".\n\t* analyzer.opt (fdump-analyzer-json): New.\n\t* call-string.cc: Include \"json.h\".\n\t(call_string::to_json): New.\n\t* call-string.h (call_string::to_json): New decl.\n\t* checker-path.cc: Include \"json.h\".\n\t* constraint-manager.cc: Include \"json.h\".\n\t(equiv_class::to_json): New.\n\t(constraint::to_json): New.\n\t(constraint_manager::to_json): New.\n\t* constraint-manager.h (equiv_class::to_json): New decl.\n\t(constraint::to_json): New decl.\n\t(constraint_manager::to_json): New decl.\n\t* diagnostic-manager.cc: Include \"json.h\".\n\t(saved_diagnostic::to_json): New.\n\t(diagnostic_manager::to_json): New.\n\t* diagnostic-manager.h (saved_diagnostic::to_json): New decl.\n\t(diagnostic_manager::to_json): New decl.\n\t* engine.cc: Include \"json.h\", <zlib.h>.\n\t(exploded_node::status_to_str): New.\n\t(exploded_node::to_json): New.\n\t(exploded_edge::to_json): New.\n\t(exploded_graph::to_json): New.\n\t(dump_analyzer_json): New.\n\t(impl_run_checkers): Call it.\n\t* exploded-graph.h (exploded_node::status_to_str): New decl.\n\t(exploded_node::to_json): New.\n\t(exploded_edge::to_json): New.\n\t(exploded_graph::to_json): New.\n\t* pending-diagnostic.cc: Include \"json.h\".\n\t* program-point.cc: Include \"json.h\".\n\t(program_point::to_json): New.\n\t* program-point.h (program_point::to_json): New decl.\n\t* program-state.cc: Include \"json.h\".\n\t(extrinsic_state::to_json): New.\n\t(sm_state_map::to_json): New.\n\t(program_state::to_json): New.\n\t* program-state.h (extrinsic_state::to_json): New decl.\n\t(sm_state_map::to_json): New decl.\n\t(program_state::to_json): New decl.\n\t* region-model-impl-calls.cc: Include \"json.h\".\n\t* region-model-manager.cc: Include \"json.h\".\n\t* region-model-reachability.cc: Include \"json.h\".\n\t* region-model.cc: Include \"json.h\".\n\t* region-model.h (svalue::to_json): New decl.\n\t(region::to_json): New decl.\n\t* region.cc: Include \"json.h\".\n\t(region::to_json: New.\n\t* sm-file.cc: Include \"json.h\".\n\t* sm-malloc.cc: Include \"json.h\".\n\t* sm-pattern-test.cc: Include \"json.h\".\n\t* sm-sensitive.cc: Include \"json.h\".\n\t* sm-signal.cc: Include \"json.h\".\n\t(signal_delivery_edge_info_t::to_json): New.\n\t* sm-taint.cc: Include \"json.h\".\n\t* sm.cc: Include \"diagnostic.h\", \"tree-diagnostic.h\", and\n\t\"json.h\".\n\t(state_machine::state::to_json): New.\n\t(state_machine::to_json): New.\n\t* sm.h (state_machine::state::to_json): New.\n\t(state_machine::to_json): New.\n\t* state-purge.cc: Include \"json.h\".\n\t* store.cc: Include \"json.h\".\n\t(binding_key::get_desc): New.\n\t(binding_map::to_json): New.\n\t(binding_cluster::to_json): New.\n\t(store::to_json): New.\n\t* store.h (binding_key::get_desc): New decl.\n\t(binding_map::to_json): New decl.\n\t(binding_cluster::to_json): New decl.\n\t(store::to_json): New decl.\n\t* supergraph.cc: Include \"json.h\".\n\t(supergraph::to_json): New.\n\t(supernode::to_json): New.\n\t(superedge::to_json): New.\n\t* supergraph.h (supergraph::to_json): New decl.\n\t(supernode::to_json): New decl.\n\t(superedge::to_json): New decl.\n\t* svalue.cc: Include \"json.h\".\n\t(svalue::to_json): New.\n\ngcc/ChangeLog:\n\t* doc/analyzer.texi (Other Debugging Techniques): Mention\n\t-fdump-analyzer-json.\n\t* doc/invoke.texi (Static Analyzer Options): Add\n\t-fdump-analyzer-json.", "tree": {"sha": "d6a2be6a09802aad22e6eb2a779f6baefacf700c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6a2be6a09802aad22e6eb2a779f6baefacf700c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/809192e77e6e112a0fe32dee7fada7a49fbf25cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809192e77e6e112a0fe32dee7fada7a49fbf25cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/809192e77e6e112a0fe32dee7fada7a49fbf25cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809192e77e6e112a0fe32dee7fada7a49fbf25cd/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c8ba5da80d5d95a8521010d6731d0d83036145d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c8ba5da80d5d95a8521010d6731d0d83036145d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c8ba5da80d5d95a8521010d6731d0d83036145d"}], "stats": {"total": 804, "additions": 804, "deletions": 0}, "files": [{"sha": "7e48f5260947caed17ceb84b45f31c5ca8e4fbcb", "filename": "gcc/analyzer/analysis-plan.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fanalysis-plan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fanalysis-plan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalysis-plan.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"ipa-utils.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-core.h\"\n #include \"analyzer/analyzer-logging.h\""}, {"sha": "872fb31048e4ccc26631f739aa427148f081b99a", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -186,6 +186,10 @@ fdump-analyzer-exploded-nodes-3\n Common RejectNegative Var(flag_dump_analyzer_exploded_nodes_3)\n Dump a textual representation of the exploded graph to SRCFILE.eg-ID.txt.\n \n+fdump-analyzer-json\n+Common RejectNegative Var(flag_dump_analyzer_json)\n+Dump analyzer-specific data to a SRCFILE.analyzer.json.gz file.\n+\n fdump-analyzer-state-purge\n Common RejectNegative Var(flag_dump_analyzer_state_purge)\n Dump state-purging information to a SRCFILE.state-purge.dot file."}, {"sha": "72568c6efa7ee68e5edbcb102e3e22f47979d85a", "filename": "gcc/analyzer/call-string.cc", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fcall-string.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fcall-string.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pretty-print.h\"\n #include \"tree.h\"\n #include \"options.h\"\n+#include \"json.h\"\n #include \"analyzer/call-string.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n@@ -104,6 +105,34 @@ call_string::print (pretty_printer *pp) const\n   pp_string (pp, \"]\");\n }\n \n+/* Return a new json::array of the form\n+   [{\"src_snode_idx\" : int,\n+     \"dst_snode_idx\" : int,\n+     \"funcname\" : str},\n+     ...for each return_superedge in the callstring].  */\n+\n+json::value *\n+call_string::to_json () const\n+{\n+  json::array *arr = new json::array ();\n+\n+  const return_superedge *e;\n+  int i;\n+  FOR_EACH_VEC_ELT (m_return_edges, i, e)\n+    {\n+      json::object *e_obj = new json::object ();\n+      e_obj->set (\"src_snode_idx\",\n+\t\t  new json::integer_number (e->m_src->m_index));\n+      e_obj->set (\"dst_snode_idx\",\n+\t\t  new json::integer_number (e->m_dest->m_index));\n+      e_obj->set (\"funcname\",\n+\t\t  new json::string (function_name (e->m_dest->m_fun)));\n+      arr->append (e_obj);\n+    }\n+\n+  return arr;\n+}\n+\n /* Generate a hash value for this call_string.  */\n \n hashval_t"}, {"sha": "5a03c592ecb678bf579230f0de1ffd9cfc67b79d", "filename": "gcc/analyzer/call-string.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fcall-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fcall-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.h?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -47,6 +47,8 @@ class call_string\n \n   void print (pretty_printer *pp) const;\n \n+  json::value *to_json () const;\n+\n   hashval_t hash () const;\n \n   bool empty_p () const { return m_return_edges.is_empty (); }"}, {"sha": "1f6d6a86001ab2cebbcb6584df6520914e179f88", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fibonacci_heap.h\"\n #include \"diagnostic-event-id.h\"\n #include \"shortest-paths.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\""}, {"sha": "5cd2c9e0e0bf63de2a56820285f74e6504ac67aa", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"graphviz.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n@@ -299,6 +300,33 @@ equiv_class::print (pretty_printer *pp) const\n   pp_character (pp, '}');\n }\n \n+/* Return a new json::object of the form\n+   {\"svals\" : [str],\n+    \"constant\" : optional str}.  */\n+\n+json::object *\n+equiv_class::to_json () const\n+{\n+  json::object *ec_obj = new json::object ();\n+\n+  json::array *sval_arr = new json::array ();\n+  int i;\n+  const svalue *sval;\n+  FOR_EACH_VEC_ELT (m_vars, i, sval)\n+    sval_arr->append (sval->to_json ());\n+  ec_obj->set (\"svals\", sval_arr);\n+\n+  if (m_constant)\n+    {\n+      pretty_printer pp;\n+      pp_format_decoder (&pp) = default_tree_printer;\n+      pp_printf (&pp, \"%qE\", m_constant);\n+      ec_obj->set (\"constant\", new json::string (pp_formatted_text (&pp)));\n+    }\n+\n+  return ec_obj;\n+}\n+\n /* Generate a hash value for this equiv_class.\n    This relies on the ordering of m_vars, and so this object needs to\n    have been canonicalized for this to be meaningful.  */\n@@ -499,6 +527,23 @@ constraint::print (pretty_printer *pp, const constraint_manager &cm) const\n   m_rhs.get_obj (cm).print (pp);\n }\n \n+/* Return a new json::object of the form\n+   {\"lhs\" : int, the EC index\n+    \"op\"  : str,\n+    \"rhs\" : int, the EC index}.  */\n+\n+json::object *\n+constraint::to_json () const\n+{\n+  json::object *con_obj = new json::object ();\n+\n+  con_obj->set (\"lhs\", new json::integer_number (m_lhs.as_int ()));\n+  con_obj->set (\"op\", new json::string (constraint_op_code (m_op)));\n+  con_obj->set (\"rhs\", new json::integer_number (m_rhs.as_int ()));\n+\n+  return con_obj;\n+}\n+\n /* Generate a hash value for this constraint.  */\n \n hashval_t\n@@ -768,6 +813,38 @@ debug (const constraint_manager &cm)\n   cm.dump ();\n }\n \n+/* Return a new json::object of the form\n+   {\"ecs\" : array of objects, one per equiv_class\n+    \"constraints\" : array of objects, one per constraint}.  */\n+\n+json::object *\n+constraint_manager::to_json () const\n+{\n+  json::object *cm_obj = new json::object ();\n+\n+  /* Equivalence classes.  */\n+  {\n+    json::array *ec_arr = new json::array ();\n+    int i;\n+    equiv_class *ec;\n+    FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+      ec_arr->append (ec->to_json ());\n+    cm_obj->set (\"ecs\", ec_arr);\n+  }\n+\n+  /* Constraints.  */\n+  {\n+    json::array *con_arr = new json::array ();\n+    int i;\n+    constraint *c;\n+    FOR_EACH_VEC_ELT (m_constraints, i, c)\n+      con_arr->append (c->to_json ());\n+    cm_obj->set (\"constraints\", con_arr);\n+  }\n+\n+  return cm_obj;\n+}\n+\n /* Attempt to add the constraint LHS OP RHS to this constraint_manager.\n    Return true if the constraint could be added (or is already true).\n    Return false if the constraint contradicts existing knowledge.  */"}, {"sha": "98960ffad84db12cda35ef2912f1f3ecd999f337", "filename": "gcc/analyzer/constraint-manager.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -88,6 +88,8 @@ class equiv_class\n \n   void print (pretty_printer *pp) const;\n \n+  json::object *to_json () const;\n+\n   /* An equivalence class can contain multiple constants (e.g. multiple\n      different zeroes, for different types); these are just for the last\n      constant added.  */\n@@ -160,6 +162,8 @@ class constraint\n \n   void print (pretty_printer *pp, const constraint_manager &cm) const;\n \n+  json::object *to_json () const;\n+\n   hashval_t hash () const;\n   bool operator== (const constraint &other) const;\n \n@@ -215,6 +219,8 @@ class constraint_manager\n   void dump (FILE *fp) const;\n   void dump () const;\n \n+  json::object *to_json () const;\n+\n   const equiv_class &get_equiv_class_by_index (unsigned idx) const\n   {\n     return *m_equiv_classes[idx];"}, {"sha": "8d7e5084cc0b3b5aed56b0eed22eb3b2c11bafa1", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tristate.h\"\n #include \"selftest.h\"\n #include \"ordered-hash-map.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n@@ -114,6 +115,43 @@ saved_diagnostic::operator== (const saved_diagnostic &other) const\n \t  && m_trailing_eedge == other.m_trailing_eedge);\n }\n \n+/* Return a new json::object of the form\n+   {\"sm\": optional str,\n+    \"enode\": int,\n+    \"snode\": int,\n+    \"sval\": optional str,\n+    \"state\": optional str,\n+    \"path_length\": int,\n+    \"pending_diagnostic\": str}.  */\n+\n+json::object *\n+saved_diagnostic::to_json () const\n+{\n+  json::object *sd_obj = new json::object ();\n+\n+  if (m_sm)\n+    sd_obj->set (\"sm\", new json::string (m_sm->get_name ()));\n+  sd_obj->set (\"enode\", new json::integer_number (m_enode->m_index));\n+  sd_obj->set (\"snode\", new json::integer_number (m_snode->m_index));\n+  if (m_sval)\n+    sd_obj->set (\"sval\", m_sval->to_json ());\n+  if (m_state)\n+    sd_obj->set (\"state\", m_state->to_json ());\n+  sd_obj->set (\"path_length\", new json::integer_number (m_epath_length));\n+  sd_obj->set (\"pending_diagnostic\", new json::string (m_d->get_kind ()));\n+\n+  /* We're not yet JSONifying the following fields:\n+     const gimple *m_stmt;\n+     stmt_finder *m_stmt_finder;\n+     tree m_var;\n+     exploded_edge *m_trailing_eedge;\n+     enum status m_status;\n+     feasibility_problem *m_problem;\n+  */\n+\n+  return sd_obj;\n+}\n+\n /* State for building a checker_path from a particular exploded_path.\n    In particular, this precomputes reachability information: the set of\n    source enodes for which a path be found to the diagnostic enode.  */\n@@ -199,6 +237,26 @@ diagnostic_manager::add_diagnostic (const exploded_node *enode,\n   add_diagnostic (NULL, enode, snode, stmt, finder, NULL_TREE, NULL, 0, d);\n }\n \n+/* Return a new json::object of the form\n+   {\"diagnostics\"  : [obj for saved_diagnostic]}.  */\n+\n+json::object *\n+diagnostic_manager::to_json () const\n+{\n+  json::object *dm_obj = new json::object ();\n+\n+  {\n+    json::array *sd_arr = new json::array ();\n+    int i;\n+    saved_diagnostic *sd;\n+    FOR_EACH_VEC_ELT (m_saved_diagnostics, i, sd)\n+      sd_arr->append (sd->to_json ());\n+    dm_obj->set (\"diagnostics\", sd_arr);\n+  }\n+\n+  return dm_obj;\n+}\n+\n /* A class for identifying sets of duplicated pending_diagnostic.\n \n    We want to find the simplest dedupe_candidate amongst those that share a"}, {"sha": "c32f0c47dc1b977d776c707769e77dce5c0fd2b7", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -46,6 +46,8 @@ class saved_diagnostic\n \n   bool operator== (const saved_diagnostic &other) const;\n \n+  json::object *to_json () const;\n+\n   void set_feasible ()\n   {\n     gcc_assert (m_status == STATUS_NEW);\n@@ -105,6 +107,8 @@ class diagnostic_manager : public log_user\n \n   engine *get_engine () const { return m_eng; }\n \n+  json::object *to_json () const;\n+\n   void add_diagnostic (const state_machine *sm,\n \t\t       const exploded_node *enode,\n \t\t       const supernode *snode, const gimple *stmt,"}, {"sha": "df7e33564f1115af2203399b92eeb6d69a2a2a9d", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tristate.h\"\n #include \"ordered-hash-map.h\"\n #include \"selftest.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/call-string.h\"\n@@ -61,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/checker-path.h\"\n #include \"analyzer/state-purge.h\"\n #include \"analyzer/bar-chart.h\"\n+#include <zlib.h>\n \n /* For an overview, see gcc/doc/analyzer.texi.  */\n \n@@ -764,6 +766,19 @@ eg_traits::dump_args_t::show_enode_details_p (const exploded_node &enode) const\n \n /* class exploded_node : public dnode<eg_traits>.  */\n \n+const char *\n+exploded_node::status_to_str (enum status s)\n+{\n+  switch (s)\n+    {\n+    default: gcc_unreachable ();\n+    case STATUS_WORKLIST: return \"WORKLIST\";\n+    case STATUS_PROCESSED: return \"PROCESSED\";\n+    case STATUS_MERGER: return \"MERGER\";\n+    case STATUS_BULK_MERGED: return \"BULK_MERGED\";\n+    }\n+}\n+\n /* exploded_node's ctor.  */\n \n exploded_node::exploded_node (const point_and_state &ps,\n@@ -952,6 +967,28 @@ exploded_node::dump (const extrinsic_state &ext_state) const\n   dump (stderr, ext_state);\n }\n \n+/* Return a new json::object of the form\n+   {\"point\"  : object for program_point,\n+    \"state\"  : object for program_state,\n+    \"status\" : str,\n+    \"idx\"    : int,\n+    \"processed_stmts\" : int}.  */\n+\n+json::object *\n+exploded_node::to_json (const extrinsic_state &ext_state) const\n+{\n+  json::object *enode_obj = new json::object ();\n+\n+  enode_obj->set (\"point\", get_point ().to_json ());\n+  enode_obj->set (\"state\", get_state ().to_json (ext_state));\n+  enode_obj->set (\"status\", new json::string (status_to_str (m_status)));\n+  enode_obj->set (\"idx\", new json::integer_number (m_index));\n+  enode_obj->set (\"processed_stmts\",\n+\t\t  new json::integer_number (m_num_processed_stmts));\n+\n+  return enode_obj;\n+}\n+\n } // namespace ana\n \n /* Return true if FNDECL has a gimple body.  */\n@@ -1502,6 +1539,30 @@ exploded_edge::dump_dot (graphviz_out *gv, const dump_args_t &) const\n   pp_printf (pp, \"\\\"];\\n\");\n }\n \n+/* Return a new json::object of the form\n+   {\"src_idx\": int, the index of the source exploded edge,\n+    \"dst_idx\": int, the index of the destination exploded edge,\n+    \"sedge\": (optional) object for the superedge, if any,\n+    \"custom\": (optional) str, a description, if this is a custom edge}.  */\n+\n+json::object *\n+exploded_edge::to_json () const\n+{\n+  json::object *eedge_obj = new json::object ();\n+  eedge_obj->set (\"src_idx\", new json::integer_number (m_src->m_index));\n+  eedge_obj->set (\"dst_idx\", new json::integer_number (m_dest->m_index));\n+  if (m_sedge)\n+    eedge_obj->set (\"sedge\", m_sedge->to_json ());\n+  if (m_custom_info)\n+    {\n+      pretty_printer pp;\n+      pp_format_decoder (&pp) = default_tree_printer;\n+      m_custom_info->print (&pp);\n+      eedge_obj->set (\"custom\", new json::string (pp_formatted_text (&pp)));\n+    }\n+  return eedge_obj;\n+}\n+\n /* struct stats.  */\n \n /* stats' ctor.  */\n@@ -3057,6 +3118,55 @@ exploded_graph::dump_states_for_supernode (FILE *out,\n \t   snode->m_index, state_idx);\n }\n \n+/* Return a new json::object of the form\n+   {\"nodes\" : [objs for enodes],\n+    \"edges\" : [objs for eedges],\n+    \"ext_state\": object for extrinsic_state,\n+    \"diagnostic_manager\": object for diagnostic_manager}.  */\n+\n+json::object *\n+exploded_graph::to_json () const\n+{\n+  json::object *egraph_obj = new json::object ();\n+\n+  /* Nodes.  */\n+  {\n+    json::array *nodes_arr = new json::array ();\n+    unsigned i;\n+    exploded_node *n;\n+    FOR_EACH_VEC_ELT (m_nodes, i, n)\n+      nodes_arr->append (n->to_json (m_ext_state));\n+    egraph_obj->set (\"nodes\", nodes_arr);\n+  }\n+\n+  /* Edges.  */\n+  {\n+    json::array *edges_arr = new json::array ();\n+    unsigned i;\n+    exploded_edge *n;\n+    FOR_EACH_VEC_ELT (m_edges, i, n)\n+      edges_arr->append (n->to_json ());\n+    egraph_obj->set (\"edges\", edges_arr);\n+  }\n+\n+  /* m_sg is JSONified at the top-level.  */\n+\n+  egraph_obj->set (\"ext_state\", m_ext_state.to_json ());\n+  egraph_obj->set (\"diagnostic_manager\", m_diagnostic_manager.to_json ());\n+\n+  /* The following fields aren't yet being JSONified:\n+     worklist m_worklist;\n+     const state_purge_map *const m_purge_map;\n+     const analysis_plan &m_plan;\n+     stats m_global_stats;\n+     function_stat_map_t m_per_function_stats;\n+     stats m_functionless_stats;\n+     call_string_data_map_t m_per_call_string_data;\n+     auto_vec<int> m_PK_AFTER_SUPERNODE_per_snode;  */\n+\n+  return egraph_obj;\n+}\n+\n /* Look for the last use of SEARCH_STMT within this path.\n    If found write the edge's index to *OUT_IDX and return true, otherwise\n    return false.  */\n@@ -4241,6 +4351,39 @@ class exploded_graph_annotator : public dot_annotator\n   auto_delete_vec<auto_vec <exploded_node *> > m_enodes_per_snodes;\n };\n \n+/* Implement -fdump-analyzer-json.  */\n+\n+static void\n+dump_analyzer_json (const supergraph &sg,\n+\t\t    const exploded_graph &eg)\n+{\n+  auto_timevar tv (TV_ANALYZER_DUMP);\n+  char *filename = concat (dump_base_name, \".analyzer.json.gz\", NULL);\n+  gzFile output = gzopen (filename, \"w\");\n+  if (!output)\n+    {\n+      error_at (UNKNOWN_LOCATION, \"unable to open %qs for writing\", filename);\n+      free (filename);\n+      return;\n+    }\n+\n+  json::object *toplev_obj = new json::object ();\n+  toplev_obj->set (\"sgraph\", sg.to_json ());\n+  toplev_obj->set (\"egraph\", eg.to_json ());\n+\n+  pretty_printer pp;\n+  toplev_obj->print (&pp);\n+  pp_formatted_text (&pp);\n+\n+  delete toplev_obj;\n+\n+  if (gzputs (output, pp_formatted_text (&pp)) == EOF\n+      || gzclose (output))\n+    error_at (UNKNOWN_LOCATION, \"error writing %qs\", filename);\n+\n+  free (filename);\n+}\n+\n /* Run the analysis \"engine\".  */\n \n void\n@@ -4341,6 +4484,9 @@ impl_run_checkers (logger *logger)\n       free (filename);\n     }\n \n+  if (flag_dump_analyzer_json)\n+    dump_analyzer_json (sg, eg);\n+\n   delete purge_map;\n }\n "}, {"sha": "f723d52bdf8c4d713b61f429948da3406b25cf29", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -165,6 +165,7 @@ class exploded_node : public dnode<eg_traits>\n     /* Node was processed by maybe_process_run_of_before_supernode_enodes.  */\n     STATUS_BULK_MERGED\n   };\n+  static const char * status_to_str (enum status s);\n \n   exploded_node (const point_and_state &ps, int index);\n \n@@ -179,6 +180,8 @@ class exploded_node : public dnode<eg_traits>\n   void dump (FILE *fp, const extrinsic_state &ext_state) const;\n   void dump (const extrinsic_state &ext_state) const;\n \n+  json::object *to_json (const extrinsic_state &ext_state) const;\n+\n   /* The result of on_stmt.  */\n   struct on_stmt_flags\n   {\n@@ -307,6 +310,8 @@ class exploded_edge : public dedge<eg_traits>\n   void dump_dot (graphviz_out *gv, const dump_args_t &args)\n     const FINAL OVERRIDE;\n \n+  json::object *to_json () const;\n+\n   //private:\n   const superedge *const m_sedge;\n \n@@ -782,6 +787,8 @@ class exploded_graph : public digraph<eg_traits>\n   void dump_states_for_supernode (FILE *, const supernode *snode) const;\n   void dump_exploded_nodes () const;\n \n+  json::object *to_json () const;\n+\n   exploded_node *get_node_by_index (int idx) const;\n \n   const call_string_data_map_t *get_per_call_string_data () const"}, {"sha": "502d17719b0221a4dd14a9a03369ace8b704a77e", "filename": "gcc/analyzer/pending-diagnostic.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"diagnostic.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\""}, {"sha": "429d6ece724e550293c45b49447ba4b2675eb84b", "filename": "gcc/analyzer/program-point.cc", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"gimple-pretty-print.h\"\n #include \"gcc-rich-location.h\"\n+#include \"json.h\"\n #include \"analyzer/call-string.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n@@ -281,6 +282,43 @@ program_point::dump () const\n   pp_flush (&pp);\n }\n \n+/* Return a new json::object of the form\n+   {\"kind\"  : str,\n+    \"snode_idx\" : int (optional), the index of the supernode,\n+    \"from_edge_snode_idx\" : int (only for kind=='PK_BEFORE_SUPERNODE'),\n+    \"stmt_idx\": int (only for kind=='PK_BEFORE_STMT',\n+    \"call_string\": object for the call_string}.  */\n+\n+json::object *\n+program_point::to_json () const\n+{\n+  json::object *point_obj = new json::object ();\n+\n+  point_obj->set (\"kind\",\n+\t\t  new json::string (point_kind_to_string (get_kind ())));\n+\n+  if (get_supernode ())\n+    point_obj->set (\"snode_idx\",\n+\t\t    new json::integer_number (get_supernode ()->m_index));\n+\n+  switch (get_kind ())\n+    {\n+    default: break;\n+    case PK_BEFORE_SUPERNODE:\n+      if (const superedge *sedge = get_from_edge ())\n+\tpoint_obj->set (\"from_edge_snode_idx\",\n+\t\t\tnew json::integer_number (sedge->m_src->m_index));\n+      break;\n+    case PK_BEFORE_STMT:\n+      point_obj->set (\"stmt_idx\", new json::integer_number (get_stmt_idx ()));\n+      break;\n+    }\n+\n+  point_obj->set (\"call_string\", m_call_string.to_json ());\n+\n+  return point_obj;\n+}\n+\n /* Generate a hash value for this program_point.  */\n \n hashval_t"}, {"sha": "d804621a7159a3fd72733daaa8f12edc59b618ba", "filename": "gcc/analyzer/program-point.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fprogram-point.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fprogram-point.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.h?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -175,6 +175,8 @@ class program_point\n   void print_source_line (pretty_printer *pp) const;\n   void dump () const;\n \n+  json::object *to_json () const;\n+\n   hashval_t hash () const;\n   bool operator== (const program_point &other) const\n   {"}, {"sha": "83a6e5b081e6ee607b173f27a2920f581071f235", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"diagnostic.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n@@ -99,6 +100,26 @@ extrinsic_state::dump () const\n   dump_to_file (stderr);\n }\n \n+/* Return a new json::object of the form\n+   {\"checkers\"  : array of objects, one for each state_machine}.  */\n+\n+json::object *\n+extrinsic_state::to_json () const\n+{\n+  json::object *ext_state_obj = new json::object ();\n+\n+  {\n+    json::array *checkers_arr = new json::array ();\n+    unsigned i;\n+    state_machine *sm;\n+    FOR_EACH_VEC_ELT (m_checkers, i, sm)\n+      checkers_arr->append (sm->to_json ());\n+    ext_state_obj->set (\"checkers\", checkers_arr);\n+  }\n+\n+  return ext_state_obj;\n+}\n+\n /* Get the region_model_manager for this extrinsic_state.  */\n \n region_model_manager *\n@@ -208,6 +229,33 @@ sm_state_map::dump (bool simple) const\n   pp_flush (&pp);\n }\n \n+/* Return a new json::object of the form\n+   {\"global\"  : (optional) value for global state,\n+    SVAL_DESC : value for state}.  */\n+\n+json::object *\n+sm_state_map::to_json () const\n+{\n+  json::object *map_obj = new json::object ();\n+\n+  if (m_global_state != m_sm.get_start_state ())\n+    map_obj->set (\"global\", m_global_state->to_json ());\n+  for (map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end ();\n+       ++iter)\n+    {\n+      const svalue *sval = (*iter).first;\n+      entry_t e = (*iter).second;\n+\n+      label_text sval_desc = sval->get_desc ();\n+      map_obj->set (sval_desc.m_buffer, e.m_state->to_json ());\n+      sval_desc.maybe_free ();\n+\n+      /* This doesn't yet JSONify e.m_origin.  */\n+    }\n+  return map_obj;\n+}\n+\n /* Return true if no states have been set within this map\n    (all expressions are for the start state).  */\n \n@@ -733,6 +781,43 @@ program_state::dump (const extrinsic_state &ext_state,\n   dump_to_file (ext_state, summarize, true, stderr);\n }\n \n+/* Return a new json::object of the form\n+   {\"store\"  : object for store,\n+    \"constraints\" : object for constraint_manager,\n+    \"curr_frame\" : (optional) str for current frame,\n+    \"checkers\" : { STATE_NAME : object per sm_state_map },\n+    \"valid\" : true/false}.  */\n+\n+json::object *\n+program_state::to_json (const extrinsic_state &ext_state) const\n+{\n+  json::object *state_obj = new json::object ();\n+\n+  state_obj->set (\"store\", m_region_model->get_store ()->to_json ());\n+  state_obj->set (\"constraints\",\n+\t\t  m_region_model->get_constraints ()->to_json ());\n+  if (m_region_model->get_current_frame ())\n+    state_obj->set (\"curr_frame\",\n+\t\t    m_region_model->get_current_frame ()->to_json ());\n+\n+  /* Provide m_checker_states as an object, using names as keys.  */\n+  {\n+    json::object *checkers_obj = new json::object ();\n+\n+    int i;\n+    sm_state_map *smap;\n+    FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n+      if (!smap->is_empty_p ())\n+\tcheckers_obj->set (ext_state.get_name (i), smap->to_json ());\n+\n+    state_obj->set (\"checkers\", checkers_obj);\n+  }\n+\n+  state_obj->set (\"valid\", new json::literal (m_valid));\n+\n+  return state_obj;\n+}\n+\n /* Update this program_state to reflect a top-level call to FUN.\n    The params will have initial_svalues.  */\n "}, {"sha": "a52fbeb2e3eb37a1e7d5bc661a10aef34839f109", "filename": "gcc/analyzer/program-state.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -53,6 +53,8 @@ class extrinsic_state\n   void dump_to_file (FILE *outf) const;\n   void dump () const;\n \n+  json::object *to_json () const;\n+\n   engine *get_engine () const { return m_engine; }\n   region_model_manager *get_model_manager () const;\n \n@@ -109,6 +111,8 @@ class sm_state_map\n \t      pretty_printer *pp) const;\n   void dump (bool simple) const;\n \n+  json::object *to_json () const;\n+\n   bool is_empty_p () const;\n \n   hashval_t hash () const;\n@@ -204,6 +208,8 @@ class program_state\n \t\t     bool multiline, FILE *outf) const;\n   void dump (const extrinsic_state &ext_state, bool simple) const;\n \n+  json::object *to_json (const extrinsic_state &ext_state) const;\n+\n   void push_frame (const extrinsic_state &ext_state, function *fun);\n   function * get_current_function () const;\n "}, {"sha": "009b8c3ecb075210509dd36b90aff16557c41a7e", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"selftest.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\""}, {"sha": "8dd3ad0020a0a7698a5d8057893a66f6c02c4831", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"selftest.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\""}, {"sha": "c1b3b2db6303d4f73fe36cd0b328eb378ff3bcb9", "filename": "gcc/analyzer/region-model-reachability.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-reachability.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"cfg.h\"\n #include \"digraph.h\"\n+#include \"json.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\""}, {"sha": "74a96b025a4276686db7fefd0f18afa6cbf39401", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"selftest.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\""}, {"sha": "1e8a517dd8cacca264a3f3d426d2ad2c0ca7c096", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -256,6 +256,8 @@ class svalue\n   void dump (bool simple=true) const;\n   label_text get_desc (bool simple=true) const;\n \n+  json::value *to_json () const;\n+\n   virtual const region_svalue *\n   dyn_cast_region_svalue () const { return NULL; }\n   virtual const constant_svalue *\n@@ -1400,6 +1402,8 @@ class region\n   virtual void dump_to_pp (pretty_printer *pp, bool simple) const = 0;\n   void dump (bool simple) const;\n \n+  json::value *to_json () const;\n+\n   bool non_null_p () const;\n \n   static int cmp_ptrs (const void *, const void *);"}, {"sha": "0820893a9b4f7516c9a2b843d18f218e8bbf8530", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"selftest.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\"\n@@ -460,6 +461,17 @@ region::dump (bool simple) const\n   pp_flush (&pp);\n }\n \n+/* Return a new json::string describing the region.  */\n+\n+json::value *\n+region::to_json () const\n+{\n+  label_text desc = get_desc (true);\n+  json::value *reg_js = new json::string (desc.m_buffer);\n+  desc.maybe_free ();\n+  return reg_js;\n+}\n+\n /* Generate a description of this region.  */\n \n DEBUG_FUNCTION label_text"}, {"sha": "d20107105295754915158f3a9deb69f82feaf0cb", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\""}, {"sha": "6293d7885cd8ba58b016fd009517161e30b81fd6", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\""}, {"sha": "c430476a8460fc30f3c1c562abbaa7b95552cba8", "filename": "gcc/analyzer/sm-pattern-test.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-pattern-test.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\""}, {"sha": "aec0a6ab8daebcedc8f5f0283ae10a73be28ecfd", "filename": "gcc/analyzer/sm-sensitive.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-sensitive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-sensitive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-sensitive.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\""}, {"sha": "2e05de8a2defaf50eef425472e2240479b71479d", "filename": "gcc/analyzer/sm-signal.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\"\n@@ -220,6 +221,12 @@ class signal_delivery_edge_info_t : public exploded_edge::custom_info_t\n     pp_string (pp, \"signal delivered\");\n   }\n \n+  json::object *to_json () const\n+  {\n+    json::object *custom_obj = new json::object ();\n+    return custom_obj;\n+  }\n+\n   void update_model (region_model *model,\n \t\t     const exploded_edge &eedge) FINAL OVERRIDE\n   {"}, {"sha": "37491d8a49a7389221a7d03accd65133831cf6a8", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-path.h\"\n #include \"diagnostic-metadata.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/analyzer-logging.h\""}, {"sha": "3fe75ef8c4a9f47713d8ed05e6a31a60d1855fb9", "filename": "gcc/analyzer/sm.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -29,6 +29,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"diagnostic-core.h\"\n #include \"pretty-print.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-diagnostic.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n@@ -56,6 +59,17 @@ state_machine::state::dump_to_pp (pretty_printer *pp) const\n   pp_string (pp, m_name);\n }\n \n+/* Return a new json::string describing the state.  */\n+\n+json::value *\n+state_machine::state::to_json () const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  dump_to_pp (&pp);\n+  return new json::string (pp_formatted_text (&pp));\n+}\n+\n /* class state_machine.  */\n \n /* state_machine's ctor.  */\n@@ -109,6 +123,28 @@ state_machine::dump_to_pp (pretty_printer *pp) const\n     }\n }\n \n+/* Return a new json::object of the form\n+   {\"name\" : str,\n+    \"states\" : [str]}.  */\n+\n+json::object *\n+state_machine::to_json () const\n+{\n+  json::object *sm_obj = new json::object ();\n+\n+  sm_obj->set (\"name\", new json::string (m_name));\n+  {\n+    json::array *states_arr = new json::array ();\n+    unsigned i;\n+    state *s;\n+    FOR_EACH_VEC_ELT (m_states, i, s)\n+      states_arr->append (s->to_json ());\n+    sm_obj->set (\"states\", states_arr);\n+  }\n+\n+  return sm_obj;\n+}\n+\n /* Create instances of the various state machines, each using LOGGER,\n    and populate OUT with them.  */\n "}, {"sha": "46b93ffb79083143b96c0c3572a7c2101eee6d0a", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -48,6 +48,7 @@ class state_machine : public log_user\n \n     const char *get_name () const { return m_name; }\n     virtual void dump_to_pp (pretty_printer *pp) const;\n+    virtual json::value *to_json () const;\n \n     unsigned get_id () const { return m_id; }\n \n@@ -121,6 +122,8 @@ class state_machine : public log_user\n \n   void dump_to_pp (pretty_printer *pp) const;\n \n+  json::object *to_json () const;\n+\n   state_t get_start_state () const { return m_start; }\n \n protected:"}, {"sha": "e4942a692fa145de8a12cc4de93453bbb703e010", "filename": "gcc/analyzer/state-purge.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fstate-purge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fstate-purge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"gimple-pretty-print.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/call-string.h\"\n #include \"digraph.h\""}, {"sha": "115851235618135620702d120d50f0b5c05c3f89", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"selftest.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"ordered-hash-map.h\"\n@@ -122,6 +123,17 @@ binding_key::dump (bool simple) const\n   pp_flush (&pp);\n }\n \n+/* Get a description of this binding_key.  */\n+\n+label_text\n+binding_key::get_desc (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  dump_to_pp (&pp, simple);\n+  return label_text::take (xstrdup (pp_formatted_text (&pp)));\n+}\n+\n /* qsort callback.  */\n \n int\n@@ -366,6 +378,37 @@ binding_map::dump (bool simple) const\n   pp_flush (&pp);\n }\n \n+/* Return a new json::object of the form\n+   {KEY_DESC : SVALUE_DESC,\n+    ...for the various key/value pairs in this binding_map}.  */\n+\n+json::object *\n+binding_map::to_json () const\n+{\n+  json::object *map_obj = new json::object ();\n+\n+  auto_vec <const binding_key *> binding_keys;\n+  for (map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end (); ++iter)\n+    {\n+      const binding_key *key = (*iter).first;\n+      binding_keys.safe_push (key);\n+    }\n+  binding_keys.qsort (binding_key::cmp_ptrs);\n+\n+  const binding_key *key;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (binding_keys, i, key)\n+    {\n+      const svalue *value = *const_cast <map_t &> (m_map).get (key);\n+      label_text key_desc = key->get_desc ();\n+      map_obj->set (key_desc.m_buffer, value->to_json ());\n+      key_desc.maybe_free ();\n+    }\n+\n+  return map_obj;\n+}\n+\n /* Get the child region of PARENT_REG based upon INDEX within a\n    CONSTRUCTOR.   */\n \n@@ -657,6 +700,23 @@ binding_cluster::dump (bool simple) const\n   pp_flush (&pp);\n }\n \n+/* Return a new json::object of the form\n+   {\"escaped\": true/false,\n+    \"touched\": true/false,\n+    \"map\" : object for the the binding_map.  */\n+\n+json::object *\n+binding_cluster::to_json () const\n+{\n+  json::object *cluster_obj = new json::object ();\n+\n+  cluster_obj->set (\"escaped\", new json::literal (m_escaped));\n+  cluster_obj->set (\"touched\", new json::literal (m_touched));\n+  cluster_obj->set (\"map\", m_map.to_json ());\n+\n+  return cluster_obj;\n+}\n+\n /* Add a binding of SVAL of kind KIND to REG, unpacking SVAL if it is a\n    compound_sval.  */\n \n@@ -1575,6 +1635,64 @@ store::dump (bool simple) const\n   pp_flush (&pp);\n }\n \n+/* Return a new json::object of the form\n+   {PARENT_REGION_DESC: {BASE_REGION_DESC: object for binding_map,\n+\t\t\t ... for each cluster within parent region},\n+    ...for each parent region,\n+    \"called_unknown_function\": true/false}.  */\n+\n+json::object *\n+store::to_json () const\n+{\n+  json::object *store_obj = new json::object ();\n+\n+  /* Sort into some deterministic order.  */\n+  auto_vec<const region *> base_regions;\n+  for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+       iter != m_cluster_map.end (); ++iter)\n+    {\n+      const region *base_reg = (*iter).first;\n+      base_regions.safe_push (base_reg);\n+    }\n+  base_regions.qsort (region::cmp_ptrs);\n+\n+  /* Gather clusters, organize by parent region, so that we can group\n+     together locals, globals, etc.  */\n+  auto_vec<const region *> parent_regions;\n+  get_sorted_parent_regions (&parent_regions, base_regions);\n+\n+  const region *parent_reg;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (parent_regions, i, parent_reg)\n+    {\n+      gcc_assert (parent_reg);\n+\n+      json::object *clusters_in_parent_reg_obj = new json::object ();\n+\n+      const region *base_reg;\n+      unsigned j;\n+      FOR_EACH_VEC_ELT (base_regions, j, base_reg)\n+\t{\n+\t  /* This is O(N * M), but N ought to be small.  */\n+\t  if (base_reg->get_parent_region () != parent_reg)\n+\t    continue;\n+\t  binding_cluster *cluster\n+\t    = *const_cast<cluster_map_t &> (m_cluster_map).get (base_reg);\n+\t  label_text base_reg_desc = base_reg->get_desc ();\n+\t  clusters_in_parent_reg_obj->set (base_reg_desc.m_buffer,\n+\t\t\t\t\t   cluster->to_json ());\n+\t  base_reg_desc.maybe_free ();\n+\t}\n+      label_text parent_reg_desc = parent_reg->get_desc ();\n+      store_obj->set (parent_reg_desc.m_buffer, clusters_in_parent_reg_obj);\n+      parent_reg_desc.maybe_free ();\n+    }\n+\n+  store_obj->set (\"called_unknown_fn\", new json::literal (m_called_unknown_fn));\n+\n+  return store_obj;\n+}\n+\n /* Get any svalue bound to REG, or NULL.  */\n \n const svalue *"}, {"sha": "0f4e7ab2a56f4755481893ac8deb9e0f3966ecf1", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -159,6 +159,7 @@ class binding_key\n \n   virtual void dump_to_pp (pretty_printer *pp, bool simple) const;\n   void dump (bool simple) const;\n+  label_text get_desc (bool simple=true) const;\n \n   static int cmp_ptrs (const void *, const void *);\n   static int cmp (const binding_key *, const binding_key *);\n@@ -340,6 +341,8 @@ class binding_map\n   void dump_to_pp (pretty_printer *pp, bool simple, bool multiline) const;\n   void dump (bool simple) const;\n \n+  json::object *to_json () const;\n+\n   bool apply_ctor_to_region (const region *parent_reg, tree ctor,\n \t\t\t     region_model_manager *mgr);\n \n@@ -392,6 +395,8 @@ class binding_cluster\n   void dump_to_pp (pretty_printer *pp, bool simple, bool multiline) const;\n   void dump (bool simple) const;\n \n+  json::object *to_json () const;\n+\n   void bind (store_manager *mgr, const region *, const svalue *,\n \t     binding_kind kind);\n \n@@ -517,6 +522,8 @@ class store\n   void dump (bool simple) const;\n   void summarize_to_pp (pretty_printer *pp, bool simple) const;\n \n+  json::object *to_json () const;\n+\n   const svalue *get_direct_binding (store_manager *mgr, const region *reg);\n   const svalue *get_default_binding (store_manager *mgr, const region *reg);\n   const svalue *get_any_binding (store_manager *mgr, const region *reg) const;"}, {"sha": "735c4a30e09a4fe90f476ed98c0db852b7193d4b", "filename": "gcc/analyzer/supergraph.cc", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsupergraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsupergraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"cfganal.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n@@ -374,6 +375,38 @@ supergraph::dump_dot (const char *path, const dump_args_t &dump_args) const\n   fclose (fp);\n }\n \n+/* Return a new json::object of the form\n+   {\"nodes\" : [objs for snodes],\n+    \"edges\" : [objs for sedges]}.  */\n+\n+json::object *\n+supergraph::to_json () const\n+{\n+  json::object *sgraph_obj = new json::object ();\n+\n+  /* Nodes.  */\n+  {\n+    json::array *nodes_arr = new json::array ();\n+    unsigned i;\n+    supernode *n;\n+    FOR_EACH_VEC_ELT (m_nodes, i, n)\n+      nodes_arr->append (n->to_json ());\n+    sgraph_obj->set (\"nodes\", nodes_arr);\n+  }\n+\n+  /* Edges.  */\n+  {\n+    json::array *edges_arr = new json::array ();\n+    unsigned i;\n+    superedge *n;\n+    FOR_EACH_VEC_ELT (m_edges, i, n)\n+      edges_arr->append (n->to_json ());\n+    sgraph_obj->set (\"edges\", edges_arr);\n+  }\n+\n+  return sgraph_obj;\n+}\n+\n /* Create a supernode for BB within FUN and add it to this supergraph.\n \n    If RETURNING_CALL is non-NULL, the supernode represents the resumption\n@@ -594,6 +627,63 @@ supernode::dump_dot_id (pretty_printer *pp) const\n   pp_printf (pp, \"node_%i\", m_index);\n }\n \n+/* Return a new json::object of the form\n+   {\"idx\": int,\n+    \"bb_idx\": int,\n+    \"m_returning_call\": optional str,\n+    \"phis\": [str],\n+    \"stmts\" : [str]}.  */\n+\n+json::object *\n+supernode::to_json () const\n+{\n+  json::object *snode_obj = new json::object ();\n+\n+  snode_obj->set (\"idx\", new json::integer_number (m_index));\n+  snode_obj->set (\"bb_idx\", new json::integer_number (m_bb->index));\n+\n+  if (m_returning_call)\n+    {\n+      pretty_printer pp;\n+      pp_format_decoder (&pp) = default_tree_printer;\n+      pp_gimple_stmt_1 (&pp, m_returning_call, 0, (dump_flags_t)0);\n+      snode_obj->set (\"returning_call\",\n+\t\t      new json::string (pp_formatted_text (&pp)));\n+    }\n+\n+  /* Phi nodes.  */\n+  {\n+    json::array *phi_arr = new json::array ();\n+    for (gphi_iterator gpi = const_cast<supernode *> (this)->start_phis ();\n+\t !gsi_end_p (gpi); gsi_next (&gpi))\n+      {\n+\tconst gimple *stmt = gsi_stmt (gpi);\n+\tpretty_printer pp;\n+\tpp_format_decoder (&pp) = default_tree_printer;\n+\tpp_gimple_stmt_1 (&pp, stmt, 0, (dump_flags_t)0);\n+\tphi_arr->append (new json::string (pp_formatted_text (&pp)));\n+      }\n+    snode_obj->set (\"phis\", phi_arr);\n+  }\n+\n+  /* Statements.  */\n+  {\n+    json::array *stmt_arr = new json::array ();\n+    int i;\n+    gimple *stmt;\n+    FOR_EACH_VEC_ELT (m_stmts, i, stmt)\n+      {\n+\tpretty_printer pp;\n+\tpp_format_decoder (&pp) = default_tree_printer;\n+\tpp_gimple_stmt_1 (&pp, stmt, 0, (dump_flags_t)0);\n+\tstmt_arr->append (new json::string (pp_formatted_text (&pp)));\n+      }\n+    snode_obj->set (\"stmts\", stmt_arr);\n+  }\n+\n+  return snode_obj;\n+}\n+\n /* Get a location_t for the start of this supernode.  */\n \n location_t\n@@ -759,6 +849,28 @@ superedge::dump_dot (graphviz_out *gv, const dump_args_t &) const\n   pp_printf (pp, \"\\\"];\\n\");\n }\n \n+/* Return a new json::object of the form\n+   {\"src_idx\": int, the index of the source supernode,\n+    \"dst_idx\": int, the index of the destination supernode,\n+    \"desc\"   : str.  */\n+\n+json::object *\n+superedge::to_json () const\n+{\n+  json::object *sedge_obj = new json::object ();\n+  sedge_obj->set (\"src_idx\", new json::integer_number (m_src->m_index));\n+  sedge_obj->set (\"dst_idx\", new json::integer_number (m_dest->m_index));\n+\n+  {\n+    pretty_printer pp;\n+    pp_format_decoder (&pp) = default_tree_printer;\n+    dump_label_to_pp (&pp, false);\n+    sedge_obj->set (\"desc\", new json::string (pp_formatted_text (&pp)));\n+  }\n+\n+  return sedge_obj;\n+}\n+\n /* If this is an intraprocedural superedge, return the associated\n    CFG edge.  Otherwise, return NULL.  */\n "}, {"sha": "40ae9ff8ac2e1a39c3b6f50b1041f726f20547c8", "filename": "gcc/analyzer/supergraph.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsupergraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsupergraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.h?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -148,6 +148,8 @@ class supergraph : public digraph<supergraph_traits>\n   void dump_dot_to_file (FILE *fp, const dump_args_t &) const;\n   void dump_dot (const char *path, const dump_args_t &) const;\n \n+  json::object *to_json () const;\n+\n   int num_nodes () const { return m_nodes.length (); }\n   int num_edges () const { return m_edges.length (); }\n \n@@ -231,6 +233,8 @@ class supernode : public dnode<supergraph_traits>\n   void dump_dot (graphviz_out *gv, const dump_args_t &args) const OVERRIDE;\n   void dump_dot_id (pretty_printer *pp) const;\n \n+  json::object *to_json () const;\n+\n   location_t get_start_location () const;\n   location_t get_end_location () const;\n \n@@ -289,6 +293,8 @@ class superedge : public dedge<supergraph_traits>\n   virtual void dump_label_to_pp (pretty_printer *pp,\n \t\t\t\t bool user_facing) const = 0;\n \n+  json::object *to_json () const;\n+\n   enum edge_kind get_kind () const { return m_kind; }\n \n   virtual cfg_superedge *dyn_cast_cfg_superedge () { return NULL; }"}, {"sha": "ae3b6783e9cd1ee574f83fb64f2047bc4ad6e321", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"selftest.h\"\n #include \"function.h\"\n+#include \"json.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n #include \"options.h\"\n@@ -116,6 +117,17 @@ svalue::get_desc (bool simple) const\n   return label_text::take (xstrdup (pp_formatted_text (&pp)));\n }\n \n+/* Return a new json::string describing the svalue.  */\n+\n+json::value *\n+svalue::to_json () const\n+{\n+  label_text desc = get_desc (true);\n+  json::value *sval_js = new json::string (desc.m_buffer);\n+  desc.maybe_free ();\n+  return sval_js;\n+}\n+\n /* If this svalue is a constant_svalue, return the underlying tree constant.\n    Otherwise return NULL_TREE.  */\n "}, {"sha": "6b7d70cccaae3ebeb51ddb51bbc074a4dae64abb", "filename": "gcc/doc/analyzer.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fdoc%2Fanalyzer.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fdoc%2Fanalyzer.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fanalyzer.texi?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -488,6 +488,9 @@ truthfulness of the argument.  This is useful for writing DejaGnu tests.\n \n @subsection Other Debugging Techniques\n \n+The option @option{-fdump-analyzer-json} will dump both the supergraph\n+and the exploded graph in compressed JSON form.\n+\n One approach when tracking down where a particular bogus state is\n introduced into the @code{exploded_graph} is to add custom code to\n @code{program_state::validate}."}, {"sha": "f726ff4756b5722eb0e8678cf097adbdedbd38ae", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809192e77e6e112a0fe32dee7fada7a49fbf25cd/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=809192e77e6e112a0fe32dee7fada7a49fbf25cd", "patch": "@@ -407,6 +407,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-analyzer-exploded-nodes @gol\n -fdump-analyzer-exploded-nodes-2 @gol\n -fdump-analyzer-exploded-nodes-3 @gol\n+-fdump-analyzer-json @gol\n -fdump-analyzer-state-purge @gol\n -fdump-analyzer-supergraph @gol\n -Wno-analyzer-double-fclose @gol\n@@ -9123,6 +9124,12 @@ Dump a textual representation of the ``exploded graph'' to\n one dump file per node, to @file{@var{file}.eg-@var{id}.txt}.\n This is typically a large number of dump files.\n \n+@item -fdump-analyzer-json\n+@opindex fdump-analyzer-json\n+Dump a compressed JSON representation of analyzer internals to\n+@file{@var{file}.analyzer.json.gz}.  The precise format is subject\n+to change.\n+\n @item -fdump-analyzer-state-purge\n @opindex fdump-analyzer-state-purge\n As per @option{-fdump-analyzer-supergraph}, dump a representation of the"}]}